<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>「IDEA插件精选」安利一个IDEA骚操作:一键生成方法的序列图 - JavaGuide</title>
<link>http://www.cnblogs.com/javaguide/p/13876627.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/javaguide/p/13876627.html</guid>
<description>&lt;p&gt;在平时的学习/工作中，我们会经常面临如下场景：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;阅读别人的代码&lt;/li&gt;
&lt;li&gt;阅读框架源码&lt;/li&gt;
&lt;li&gt;阅读自己很久之前写的代码。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;千万不要觉得工作就是单纯写代码，实际工作中，你会发现你的大部分时间实际都花在了阅读和理解已有代码上。&lt;/p&gt;
&lt;p&gt;为了能够更快更清晰地搞清对象之间的调用关系，我经常需要用到序列图。手动画序列图还是很麻烦费时间的，不过 IDEA 提供了一个叫做&lt;strong&gt;SequenceDiagram&lt;/strong&gt; 的插件帮助我们解决这个问题。通过 SequenceDiagram 这个插件，我们一键可以生成时序图。&lt;/p&gt;
&lt;h2 id=&quot;何为序列图？&quot;&gt;何为序列图？&lt;/h2&gt;
&lt;p&gt;网上对于序列图的定义有很多，我觉得都不太好理解，太抽象了。最神奇的是，大部分文章对于序列图的定义竟然都是一模一样，看来大家是充分发挥了写代码的“精髓”啊！&lt;/p&gt;
&lt;p&gt;我还是简单说一说我的理解吧！不过，说实话，我自己对于 Sequence Diagram 也不是很明朗。下面的描述如有问题和需要完善的地方，还请指出。&lt;/p&gt;
&lt;blockquote readability=&quot;9.9316628701595&quot;&gt;
&lt;p&gt;&lt;strong&gt;序列图&lt;/strong&gt;（Sequence Diagram），亦称为&lt;strong&gt;循序图&lt;/strong&gt;，是一种&lt;a href=&quot;https://zh.m.wikipedia.org/wiki/UML&quot;&gt;UML&lt;/a&gt;行为图。表示系统执行某个方法/操作（如登录操作）时，对象之间的顺序调用关系。&lt;/p&gt;
&lt;p&gt;这个顺序调用关系可以这样理解：你需要执行系统中某个对象 a 提供的方法/操作 login（登录），但是这个对象又依赖了对象 b 提供的方法 getUser(获取用户)。因此，这里就有了 a -&amp;gt; b 调用关系之说。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;再举两个例子来说一下！&lt;/p&gt;
&lt;p&gt;下图是微信支付的业务流程时序图。这个图描述了微信支付相关角色（顾客，商家...）在微信支付场景下，基础支付和支付的的顺序调用关系。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1843652/202010/1843652-20201026082741821-1764491189.png&quot; alt=&quot;img&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下图是我写的一个 HTTP 框架中的执行某个方法的序列图。这个图描述了我们在调用 &lt;code&gt;InterceptorFactory&lt;/code&gt;类的 &lt;code&gt;loadInterceptors()&lt;/code&gt; 方法的时候，所涉及到的类之间的调用关系。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1843652/202010/1843652-20201026082742188-1349821892.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外，国内一般更喜欢称呼序列图为&quot;时序图&quot;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果你按照纯翻译的角度来说， sequence 这个单词并无&quot;时间&quot;的意思，只有序列，顺序等意思，因此也有人说“时序图”的说法是不准确的。&lt;/li&gt;
&lt;li&gt;如果从定义角度来说，时序图这个描述是没问题的。因为 Sequence Diagram 中每条消息的触发时机确实是按照时间顺序执行的。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我觉得称呼 Sequence Diagram 为时序图或者序列图都是没问题的，不用太纠结。&lt;/p&gt;
&lt;h2 id=&quot;哪些场景下需要查看类的时序图&quot;&gt;哪些场景下需要查看类的时序图?&lt;/h2&gt;
&lt;p&gt;我们在很多场景下都需要时序图，比如说：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;阅读源码&lt;/strong&gt; ：阅读源码的时候，你可能需要查看调用目标方法涉及的相关类的调用关系。特别是在代码的调用层级比较多的时候，对于我们理解源码非常有用。（&lt;em&gt;题外话：实际工作中，大部分时间实际我们都花在了阅读理解已有代码上。&lt;/em&gt;）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;技术文档编写&lt;/strong&gt; ：我们在写项目介绍文档的时候，为了让别人更容易理解你的代码，你需要根据核心方法为相关的类生成时序图来展示他们之间的调用关系。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;梳理业务流程&lt;/strong&gt; ：当我们的系统业务流程比较复杂的时候，我们可以通过序列图将系统中涉及的重要的角色和对象的之间关系可视化出来。&lt;/li&gt;
&lt;li&gt;......&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;如何使用-idea-根据类中方法生成时序图？&quot;&gt;如何使用 IDEA 根据类中方法生成时序图？&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;通过 SequenceDiagram 这个插件，我们一键可以生成时序图。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;并且，你还可以：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;点击时序图中的类/方法即可跳转到对应的地方。&lt;/li&gt;
&lt;li&gt;从时序图中删除对应的类或者方法。&lt;/li&gt;
&lt;li&gt;将生成的时序图导出为 PNG 图片格式。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;安装&quot;&gt;安装&lt;/h3&gt;
&lt;p&gt;我们直接在 IDEA 的插件市场即可找到这个插件。我这里已经安装好了。&lt;/p&gt;
&lt;blockquote readability=&quot;4.8857142857143&quot;&gt;
&lt;p&gt;如果你因为网络问题没办法使用 IDEA 自带的插件市场的话，也可以通过&lt;a href=&quot;https://plugins.jetbrains.com/idea&quot;&gt;IDEA 插件市场的官网&lt;/a&gt;手动下载安装。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1843652/202010/1843652-20201026082742692-254844345.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;简单使用&quot;&gt;简单使用&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;选中方法名（注意不要选类名），然后点击鼠标右键，选择 &lt;strong&gt;Sequence Diagram&lt;/strong&gt; 选项即可！&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1843652/202010/1843652-20201026082743299-1293610901.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;配置生成的序列图的一些基本的参数比如调用深度之后，我们点击 ok 即可！&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1843652/202010/1843652-20201026082743643-40131159.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;你还可以通过生成的时序图来定位到相关的代码，这对于我们阅读源码的时候尤其有帮助！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1843652/202010/1843652-20201026082743849-373933541.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;时序图生成完成之后，你还可以选择将其导出为图片。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1843652/202010/1843652-20201026082744210-1058548285.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;我的开源项目推荐&quot;&gt;我的开源项目推荐&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/Snailclimb/JavaGuide&quot;&gt;JavaGuide&lt;/a&gt; ：「Java学习+面试指南」一份涵盖大部分Java程序员所需要掌握的核心知识。准备 Java 面试，首选 JavaGuide！&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Snailclimb/guide-rpc-framework&quot;&gt;guide-rpc-framework&lt;/a&gt; ：A custom RPC framework implemented by Netty+Kyro+Zookeeper.（一款基于 Netty+Kyro+Zookeeper 实现的自定义 RPC 框架-附详细实现过程和相关教程）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Snailclimb/jsoncat&quot;&gt;jsoncat&lt;/a&gt; ：仿 Spring Boot 但不同于 Spring Boot 的一个轻量级的 HTTP 框架&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Snailclimb/programmer-advancement&quot;&gt;programmer-advancement&lt;/a&gt; ：程序员应该有的一些好习惯+面试必知事项！&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Snailclimb/springboot-guide&quot;&gt;springboot-guide&lt;/a&gt; ：Not only Spring Boot but also important knowledge of Spring（不只是SpringBoot还有Spring重要知识点）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Snailclimb/awesome-java&quot;&gt;awesome-java&lt;/a&gt; ：Collection of awesome Java project on Github(Github 上非常棒的 Java 开源项目集合).&lt;br/&gt;&lt;a href=&quot;https://www.yuque.com/docs/share/71251673-1fef-416e-93d7-489a25a9eda5?#%20%E3%80%8A%E8%B5%B0%E8%BF%91JavaGuide%E3%80%8B&quot;&gt;我是 Guide 哥，一 Java 后端开发，会一点前端，自由的少年。我们下期再见！微信搜“&lt;strong&gt;JavaGuide&lt;/strong&gt;”回复“&lt;strong&gt;面试突击&lt;/strong&gt;”领取我整理的 4 本原创PDF&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Mon, 26 Oct 2020 00:28:00 +0000</pubDate>
<dc:creator>JavaGuide</dc:creator>
<og:description>在平时的学习/工作中，我们会经常面临如下场景： 阅读别人的代码 阅读框架源码 阅读自己很久之前写的代码。 千万不要觉得工作就是单纯写代码，实际工作中，你会发现你的大部分时间实际都花在了阅读和理解已有代</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/javaguide/p/13876627.html</dc:identifier>
</item>
<item>
<title>Monitor Ctrl-Break线程，有点坑 - 常温的冰</title>
<link>http://www.cnblogs.com/hpdblogs/p/13876624.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hpdblogs/p/13876624.html</guid>
<description>&lt;p&gt;Monitor Ctrl-Break线程这个在idea中特有的线程，你了解吗？这线程可能会在你调试的时候给你带来谜一样的结果，为什么呢？请看下面的例子：&lt;/p&gt;
&lt;p&gt;首先我们先复习一下多线程的状态（因为这个问题是我在复习多线程的时候发现的问题）&lt;/p&gt;
&lt;p&gt;对于线程的所有状态该如何去查看呢？线程的状态都是怎么产生的这些面试高频题目，我们是否还记得呢？下面附上代码用代码再一次复习一下，简单明了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1970848/202010/1970848-20201026081906814-402887787.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面是全部的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; &lt;span&gt; * @Description: 查看线程的所有状态
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt; &lt;span&gt; * @ProjectName: demo
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; &lt;span&gt; * @Package: com.thread
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; &lt;span&gt; * @Author: XiaoHeMa
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; &lt;span&gt; * @CreateDate: 2020/10/24 9:03
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;  8&lt;/span&gt; 
&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ThreadSate {
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt; 
&lt;span&gt; 11&lt;/span&gt;  
&lt;span&gt; 12&lt;/span&gt; 
&lt;span&gt; 13&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt; 
&lt;span&gt; 15&lt;/span&gt;         Thread thread = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt; 
&lt;span&gt; 17&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 5; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt; 
&lt;span&gt; 19&lt;/span&gt;                 &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; 
&lt;span&gt; 21&lt;/span&gt;                     Thread.sleep(100&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt; 
&lt;span&gt; 23&lt;/span&gt;                 } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt; 
&lt;span&gt; 25&lt;/span&gt; &lt;span&gt;                    e.printStackTrace();
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt; 
&lt;span&gt; 27&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt; 
&lt;span&gt; 29&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt; 
&lt;span&gt; 31&lt;/span&gt;             System.out.println(&quot;---thread线程结束---&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt; 
&lt;span&gt; 33&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt; 
&lt;span&gt; 35&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;查看线程的状态&lt;/span&gt;
&lt;span&gt; 36&lt;/span&gt; 
&lt;span&gt; 37&lt;/span&gt;         Thread.State state =&lt;span&gt; thread.getState();
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt; 
&lt;span&gt; 39&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这时候我们只是创建了个线程 也就是NEW的状态&lt;/span&gt;
&lt;span&gt; 40&lt;/span&gt; 
&lt;span&gt; 41&lt;/span&gt;         System.out.println(&quot;线程状态  &quot; +&lt;span&gt; state);
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt; 
&lt;span&gt; 43&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动线程&lt;/span&gt;
&lt;span&gt; 44&lt;/span&gt; 
&lt;span&gt; 45&lt;/span&gt; &lt;span&gt;        thread.start();
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt; 
&lt;span&gt; 47&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;查看线程的状态&lt;/span&gt;
&lt;span&gt; 48&lt;/span&gt; 
&lt;span&gt; 49&lt;/span&gt;         state =&lt;span&gt; thread.getState();
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt; 
&lt;span&gt; 51&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这时候我们已经启动了线程，然后来看看现在线程的状态 RUNNABLE&lt;/span&gt;
&lt;span&gt; 52&lt;/span&gt; 
&lt;span&gt; 53&lt;/span&gt;         System.out.println(&quot;线程状态  &quot; +&lt;span&gt; state);
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt; 
&lt;span&gt; 55&lt;/span&gt;  
&lt;span&gt; 56&lt;/span&gt; 
&lt;span&gt; 57&lt;/span&gt;  
&lt;span&gt; 58&lt;/span&gt; 
&lt;span&gt; 59&lt;/span&gt;  
&lt;span&gt; 60&lt;/span&gt; 
&lt;span&gt; 61&lt;/span&gt;           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据线程的状态来停止死循环
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt; 
&lt;span&gt; 63&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;        while (state != Thread.State.TERMINATED) {
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt; 
&lt;span&gt; 65&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;            try {
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; 
&lt;span&gt; 67&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;                Thread.sleep(200);
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt; 
&lt;span&gt; 69&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;            } catch (InterruptedException e) {
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt; 
&lt;span&gt; 71&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;                e.printStackTrace();
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt; 
&lt;span&gt; 73&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt; 
&lt;span&gt; 75&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;查看线程的状态
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt; 
&lt;span&gt; 77&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;            state = thread.getState();
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt; 
&lt;span&gt; 79&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;            System.out.println(&quot;线程状态  &quot; + state);
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt; 
&lt;span&gt; 81&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt; 
&lt;span&gt; 83&lt;/span&gt;  
&lt;span&gt; 84&lt;/span&gt; 
&lt;span&gt; 85&lt;/span&gt;  
&lt;span&gt; 86&lt;/span&gt; 
&lt;span&gt; 87&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据线程的总条数来停止死循环&lt;/span&gt;
&lt;span&gt; 88&lt;/span&gt; 
&lt;span&gt; 89&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt; 
&lt;span&gt; 91&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; i =&lt;span&gt; Thread.activeCount();
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt; 
&lt;span&gt; 93&lt;/span&gt;             System.out.println(&quot;目前线程数量：&quot; +&lt;span&gt; i);
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt; 
&lt;span&gt; 95&lt;/span&gt;             &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 96&lt;/span&gt; &lt;span&gt;             * Monitor Ctrl-Break这个线程只会在IDEA中被打印出来
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt; &lt;span&gt;             * 在IDEA中通过debug启动的不会出现，只有run启动的会出现
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt; &lt;span&gt;             * 所以在idea中执行run的时候这个要写成2而不能是1在eclipse
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt; &lt;span&gt;             * 中却不会出现这个问题，这是软件引起的在开发调试过程要注意。
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;              &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;101&lt;/span&gt; 
&lt;span&gt;102&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (i == 2&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt; 
&lt;span&gt;104&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt; 
&lt;span&gt;106&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt; 
&lt;span&gt;108&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt; 
&lt;span&gt;110&lt;/span&gt;                 Thread.sleep(200&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt; 
&lt;span&gt;112&lt;/span&gt;             } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt; 
&lt;span&gt;114&lt;/span&gt; &lt;span&gt;                e.printStackTrace();
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt; 
&lt;span&gt;116&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt; 
&lt;span&gt;118&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;查看线程的状态&lt;/span&gt;
&lt;span&gt;119&lt;/span&gt; 
&lt;span&gt;120&lt;/span&gt;             state =&lt;span&gt; thread.getState();
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt; 
&lt;span&gt;122&lt;/span&gt;             System.out.println(&quot;线程状态  &quot; +&lt;span&gt; state);
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt; 
&lt;span&gt;124&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt; 
&lt;span&gt;126&lt;/span&gt;  
&lt;span&gt;127&lt;/span&gt; 
&lt;span&gt;128&lt;/span&gt;  
&lt;span&gt;129&lt;/span&gt; 
&lt;span&gt;130&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt; 
&lt;span&gt;132&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果：&lt;img src=&quot;https://img2020.cnblogs.com/blog/1970848/202010/1970848-20201026082039104-558114390.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;对于代码中有检验的方式：一种是&lt;/p&gt;
&lt;pre&gt;
Thread.State.TERMINATED
&lt;/pre&gt;
&lt;p&gt;采用线程的状态来判断线程是否结束&lt;/p&gt;
&lt;p&gt;另一种是通过线程的数量来判断线程的数量&lt;/p&gt;
&lt;pre&gt;
Thread.activeCount()
&lt;/pre&gt;
&lt;p&gt;注意（使用idea的小伙伴要注意了，在idea中使用&lt;/p&gt;
&lt;pre&gt;
Thread.activeCount()
&lt;/pre&gt;
&lt;p&gt;debug启动的不会出现，只有run启动的会出现，出现线程数最后有2条的问题，所以在上面的代码中才用&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
if (i == 2) {
  break;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;）&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1970848/202010/1970848-20201026082203349-642783430.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Monitor Ctrl-Break线程是在idea中才有的，而且还是要用run启动方式，所以在写测试代码的小伙伴要注意了！！！&lt;/p&gt;
&lt;p&gt;测试代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class Main extends Thread {
    public static void main(String[] args) {
        Main t1 = new Main();
        t1.setName(&quot;thread01&quot;);
        t1.start();
        ThreadGroup currentGroup =
                Thread.currentThread().getThreadGroup();
        int noThreads = currentGroup.activeCount();
        Thread[] lstThreads = new Thread[noThreads];
        currentGroup.enumerate(lstThreads);
        for (int i = 0; i &amp;lt; noThreads; i++) {
            System.out.println(&quot;线程号：&quot; + i + &quot; = &quot; + lstThreads[i].getName());
        }
    }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1970848/202010/1970848-20201026082431512-1572550800.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 26 Oct 2020 00:25:00 +0000</pubDate>
<dc:creator>常温的冰</dc:creator>
<og:description>Monitor Ctrl-Break线程这个在idea中特有的线程，你了解吗？这线程可能会在你调试的时候给你带来谜一样的结果，为什么呢？请看下面的例子： 首先我们先复习一下多线程的状态（因为这个问题是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hpdblogs/p/13876624.html</dc:identifier>
</item>
<item>
<title>群晖DS218+做maven私服(nexus3) - 程序员欣宸</title>
<link>http://www.cnblogs.com/bolingcavalry/p/13876565.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bolingcavalry/p/13876565.html</guid>
<description>&lt;h3 id=&quot;欢迎访问我的github&quot;&gt;欢迎访问我的GitHub&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS等；&lt;/p&gt;
&lt;h3 id=&quot;背景&quot;&gt;背景&lt;/h3&gt;
&lt;p&gt;本人是个Java工程师，在家里撸代码时台式机、笔记本、虚拟机都可能用来编译构建maven项目，此时如果家里有个maven私服，对构建速度的提升效果是明显的；&lt;/p&gt;
&lt;h3 id=&quot;纠结&quot;&gt;纠结&lt;/h3&gt;
&lt;p&gt;准备一台电脑部署好私服后，是24小时开机么？似乎有些浪费，那么用的时候开启，用完关机？略为麻烦（您想骂我懒么？您骂得对...）&lt;/p&gt;
&lt;h3 id=&quot;群晖ds218&quot;&gt;群晖DS218+&lt;/h3&gt;
&lt;p&gt;家里有一台群晖DS218+，很久以来始终24小时开机为全家服务，如果能把私服装到这里，似乎前面的纠结就没有了；&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;下图是DS218+刚买来的样子，两块NAS硬盘，一直稳定服务中：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201026075826788-2029382086.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;下图是网购的内存条，现在一共2+8=10G内存，内存充足才是敢折腾maven私服的底气：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201026075827677-415075283.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;思路&quot;&gt;思路&lt;/h3&gt;
&lt;p&gt;其实操作很简单：群晖带有docker服务，用docker来部署nexus即可，所以，本文其实也就是群晖docker的基本操作记录，以下几处是要注意的地方：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;容器端口&lt;/li&gt;
&lt;li&gt;容器数据卷&lt;/li&gt;
&lt;li&gt;文件权限&lt;/li&gt;
&lt;li&gt;登录容器操作&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;环境信息&quot;&gt;环境信息&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;群晖系统：DSM 6.2.2-24922 Update 4&lt;/li&gt;
&lt;li&gt;部署nexus之前群晖的资源情况：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201026075828659-1583488414.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;打开Docker，在&lt;span&gt;注册表&lt;/span&gt;页面搜索&lt;span&gt;nexus&lt;/span&gt;，找到&lt;span&gt;sonatype/nexus3&lt;/span&gt;，选择标签&lt;span&gt;3.19.1&lt;/span&gt;，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201026075829120-1496941792.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;镜像下载完毕后，在映像页面选中该镜像，点击&lt;span&gt;启动&lt;/span&gt;按钮：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201026075829609-504234120.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;在启动页面点击&lt;span&gt;高级设置&lt;/span&gt;：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201026075829887-1356080682.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;允许容器自动重启，创建桌面快捷方式：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201026075830101-1000555255.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;数据卷映射，按照下图操作，在宿主机新建一个文件夹，名为&lt;span&gt;nexus3&lt;/span&gt;：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201026075830395-1314439894.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;再将容器的&lt;span&gt;/nexus-data&lt;/span&gt;目录映射到宿主机的nexus3，这样容器的所有数据都能保存下来了：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201026075830749-432096460.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;端口映射，如果宿主机的8081端口没有被占用，就直接映射到8081吧，否则换一个没占用的：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201026075831062-674732794.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;设置完成，勾选&lt;span&gt;向导完成后运行此容器&lt;/span&gt;，再点击&lt;span&gt;应用&lt;/span&gt;即可创建nexus3容器：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201026075831442-1756012711.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;本以为这样就完成了，没想到弹出很多报错的消息：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201026075831699-475879620.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;如下图，查看容器日志：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201026075832201-932146291.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;很快就查到了问题：宿主机映射给容器的目录，容器的进程因为权限问题写操作失败了：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201026075832679-2042818600.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;想想也是，为了安全起见，宿主机的nexus3目录，容器是不能随意操作的，这里我们就给把这个目录的写权限放开吧，如下图，用File Station来设置这个目录：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201026075833075-154936214.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;增加写入权限：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201026075833418-543277893.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;上述操作完毕后开始等待，因为容器每次意外退出后会自动重启，终于，看到了启动成功的日志：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201026075833778-1396423116.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;操作nexus3&quot;&gt;操作nexus3&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;我这里群晖的内网IP是&lt;span&gt;192.168.50.42&lt;/span&gt;，因此浏览器访问地址：&lt;a href=&quot;http://192.168.50.42:8081&quot;&gt;http://192.168.50.42:8081&lt;/a&gt;，熟悉的页面出来了：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201026075834061-1384863026.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;接下来要面对的问题是如何取得登录密码，nexus的默认密码保存在容器的&lt;span&gt;/nexus-data/admin.password&lt;/span&gt;文件中，所以有以下两种方法取得，您任选一种吧；&lt;/li&gt;
&lt;li&gt;容器的&lt;span&gt;/nexus-data&lt;/span&gt;目录已经映射到宿主机的&lt;span&gt;docker/nexus3&lt;/span&gt;目录，所以用File Statiion打开该目录，下载&lt;span&gt;admin.password&lt;/span&gt;文件，再用文本编辑器打开即可：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201026075834467-533447834.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;另一种方法是进入容器查看该文件，操作如下，选中容器增加一个命令：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201026075834895-638316912.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;在弹出的输入框中输入&lt;span&gt;/bin/bash&lt;/span&gt;，这样就在该容器的namespace下新建了bash进程，该进程可见同一个namespace下的所有文件，包括/nexus-data/admin.password，再用cat命令查看文件内容即可：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201026075835227-894168976.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;拿到密码后就能在页面上登录nexus了，账号是&lt;span&gt;admin&lt;/span&gt;：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201026075835539-819415065.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;登录成功后，按照提示设置新密码：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201026075835908-1773449182.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;接下来就是nexus的常规操作了，这里不再多说，挑重点说吧，新建一个管理员权限的账号&lt;span&gt;bolingcavalry&lt;/span&gt;，设置密码为&lt;span&gt;123456&lt;/span&gt;：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201026075836253-956664765.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;取得私服的中央仓库地址：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201026075836583-2132200477.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;至此，部署成功，接下来验证一下这个私服好不好用。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;准备两台电脑验证nexus服务&quot;&gt;准备两台电脑验证Nexus服务&lt;/h3&gt;
&lt;p&gt;下图是部署私服后的架构图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201026075836950-681803234.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;准备两台电脑，分别是A电脑和B电脑，用来验证刚刚部署的Nexus3可以缓存中央仓库的jar包（您也可以用虚拟机创建两台电脑）；&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;A、B两台电脑都已经装好了JDK8和Maven3；&lt;/li&gt;
&lt;li&gt;A、B两台电脑上的maven目录下的conf/settings.xml文件都要做以下修改；&lt;/li&gt;
&lt;li&gt;找到&lt;span&gt;servers&lt;/span&gt;节点，增加以下内容：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;server&amp;gt;
  &amp;lt;id&amp;gt;maven-central&amp;lt;/id&amp;gt;
  &amp;lt;username&amp;gt;bolingcavalry&amp;lt;/username&amp;gt;
  &amp;lt;password&amp;gt;123456&amp;lt;/password&amp;gt;
&amp;lt;/server&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;找到&lt;span&gt;mirrors&lt;/span&gt;节点，增加以下内容，其中url的内容就是前面得到的&lt;span&gt;maven-central&lt;/span&gt;仓库地址：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;mirror&amp;gt;
  &amp;lt;id&amp;gt;maven-central&amp;lt;/id&amp;gt;
  &amp;lt;mirrorOf&amp;gt;*&amp;lt;/mirrorOf&amp;gt;
  &amp;lt;url&amp;gt;http://192.168.50.42:8081/repository/maven-central/&amp;lt;/url&amp;gt;
&amp;lt;/mirror&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;在a电脑上编译构建项目应该很慢&quot;&gt;在A电脑上编译构建项目(应该很慢)&lt;/h3&gt;
&lt;p&gt;在A电脑上编译开源项目spring-cloud-alibaba，此时Nexus上没有缓存任何jar包，所以编译速度会很慢，因为所有依赖jar都要从中央仓库下载，我们来试试：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;登录A电脑，下载spring-cloud-alibaba的2.1.1.RELEASE归档包：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;wget https://github.com/alibaba/spring-cloud-alibaba/archive/v2.1.1.RELEASE.tar.gz
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;解压下载的文件：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;tar -zxvf v2.1.1.RELEASE.tar.gz
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;进入解压后的目录：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;cd spring-cloud-alibaba-2.1.1.RELEASE/
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;编译：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;mvn clean compile -U -DskipTests
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;编译完成，如下图红框所示，本次编译耗时&lt;span&gt;7分32秒&lt;/span&gt;：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201026075837551-501717984.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;去Nexus网页上看看，如下图，此时已经缓存了不少jar：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201026075837965-1889346542.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;在b电脑上编译构建项目应该很快&quot;&gt;在B电脑上编译构建项目(应该很快)&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;在B电脑做同样的操作，此时Nexus上已缓存了编译所需的jar包，编译过程明显变快，最终操作结果如下图，仅用&lt;span&gt;1分零8秒&lt;/span&gt;：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201026075838492-1806119986.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;看看nexus服务占用的资源，内存用了不少，如果没加内存条，用自带的2G内存估计会拖垮整个群晖，虽然容器可以限制内存，但是也会导致nexus进程频繁的GC，依旧很卡，所以保障内存充足是很有必要的：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201026075838796-1245247688.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;至此，群晖DS218+部署maven私服的实战就完成了，今后在家撸代码算是有了稳定的私服，无需打理，随时可用。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;欢迎关注公众号：程序员欣宸&quot;&gt;欢迎关注公众号：程序员欣宸&lt;/h3&gt;
&lt;blockquote readability=&quot;4.258064516129&quot;&gt;
&lt;p&gt;微信搜索「程序员欣宸」，我是欣宸，期待与您一同畅游Java世界...&lt;br/&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sun, 25 Oct 2020 23:59:00 +0000</pubDate>
<dc:creator>程序员欣宸</dc:creator>
<og:description>欢迎访问我的GitHub https://github.com/zq2599/blog_demos 内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bolingcavalry/p/13876565.html</dc:identifier>
</item>
<item>
<title>拿了十几个offer，怎样做选择？ - 龙跃十二</title>
<link>http://www.cnblogs.com/zhonglongbo/p/13876563.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhonglongbo/p/13876563.html</guid>
<description>&lt;p&gt;本文已经收录至我的GitHub,欢迎大家踊跃star 和 issues。&lt;/p&gt;
&lt;p&gt;https://github.com/midou-tech/articles&lt;/p&gt;
&lt;p&gt;最近收到好几个读者的咨询，关于如何选offer的问题，暖心的龙叔都一一解答了&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1gjw5x11lxbj30t0078gmx.jpg&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;大家问的问题，忽然又唤起了我的回忆&lt;/p&gt;
&lt;p&gt;那个秋天很特别，马上秋招了，出了点车祸，休息了大概一个月，一直晚到9.6号才入场秋招，入场时我的嘴还是封着线&lt;/p&gt;
&lt;p&gt;那段时间还爱上了杨超越，以为这是一场持久战，必须给自己一点精神食粮，准备好了一切去迎接生活的馈赠&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1gjs643p326j30h80biaf2.jpg&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;然而事实告诉我，真正的猛男总是能 &lt;strong&gt;速战速决&lt;/strong&gt;，从国庆开始秋招基本结束，就进入了下一段旅途——毕业生活&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1gjs63d09m3j30hs0fa7bd.jpg&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;但是好景不长，蜂拥而至的offer砸向了我，那一刻我眼花缭乱，被砸晕了&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1gjs6vvbns8j30hk0e640q.jpg&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;和大家一样，我也陷入了对人生，对未来的思考&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1gjs7n36ks0g308c08cmx4.gif&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;秋天的风不再缠绵，而是有些微醺，我必须时刻保持清醒&lt;/p&gt;
&lt;p&gt;那段时间，同学之间见面打招呼，一定是这样子&lt;/p&gt;
&lt;p&gt;同学A：班长签哪里了？&lt;/p&gt;
&lt;p&gt;龙叔：还没定…&lt;/p&gt;
&lt;p&gt;同学B：签哪里了？&lt;/p&gt;
&lt;p&gt;龙叔：还没定…&lt;/p&gt;
&lt;p&gt;也不能老是犹豫不决，最坏的选择就是拖着不选择&lt;/p&gt;
&lt;p&gt;于是我把这些offer都罗列了一遍，把我要选择的点做了一个优先级排序，从左往右优先级依次降低&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1gjs81hdr3kj31940u0akw.jpg&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;接下来龙叔从六个方向说说，如何把自己卖个好价钱✌️&lt;/p&gt;
&lt;h3 id=&quot;h&quot;&gt;&lt;span&gt;城市选择&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;城市选择很重要，一个城市的选择代表着你选择了一个环境，代表着你未来的生活水准，代表你能走多远&lt;/p&gt;
&lt;p&gt;选择城市，可不是简单的考虑是否离家近，是否和对象一个城市&lt;/p&gt;
&lt;p&gt;这些因素需要考虑，但&lt;strong&gt;切忌&lt;/strong&gt;作为首要考虑城市的因素&lt;/p&gt;
&lt;p&gt;举个我的老友A例子，毕业找工作时下定决心要去女朋友的城市，而且选择&lt;strong&gt;面哪家公司&lt;/strong&gt;都是看女朋友有么有参加&lt;/p&gt;
&lt;p&gt;最终放弃了一家 &lt;strong&gt;行业地位高&lt;/strong&gt;、&lt;strong&gt;公司技术底蕴好&lt;/strong&gt;、&lt;strong&gt;给的岗位也非常nice&lt;/strong&gt;、领导&lt;strong&gt;多次沟通&lt;/strong&gt;想要他去 的公司，最后&lt;strong&gt;随便&lt;/strong&gt;选择了一家女友城市的公司&lt;/p&gt;
&lt;p&gt;简单来说就是放弃了一家&lt;strong&gt;什么都好&lt;/strong&gt;就是女朋友不在的的城市，选择了一个&lt;strong&gt;什么都不好&lt;/strong&gt;，只有女朋友在的城市&lt;/p&gt;
&lt;p&gt;他以为从此拥有了世界，殊不知世界早已抛弃他&lt;/p&gt;
&lt;p&gt;女友选择自己非常喜欢的&lt;strong&gt;公司&lt;/strong&gt;和&lt;strong&gt;岗位&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;毕业后在公司做的非常出色，老板很器重她，自己能力也得到很大提升，很快升职加薪&lt;/p&gt;
&lt;p&gt;每次回到家和男友都是小心翼翼的说话，生怕一个不小心就是伤害&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1gjw65a7n8xj307z06bq2y.jpg&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;而那个男孩子，岗位不是他喜欢的，工作没动力；公司是个创业公司，薪资低偶尔发不出来工资；老板整天想着怎么让公司活下来，对员工也是最大化压榨，经常性加班到很晚&lt;/p&gt;
&lt;p&gt;社会的毒打让他失去了对&lt;strong&gt;生活热爱&lt;/strong&gt;，对待感情也没有了当初的&lt;strong&gt;耐心和执着&lt;/strong&gt;，对未来增加了更多的&lt;strong&gt;迷茫&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;工作在占据了一大半的生活，如果工作一点兴奋都没有，我真的想象不到你的生活会有怎样的开心&lt;/p&gt;
&lt;p&gt;事业是自己的，感情是不确定的，人的感情会根据现实情况发生很多变化的&lt;/p&gt;
&lt;p&gt;也许当初听了我们的一丁点劝阻，也许…&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1gjw6q20yrag306y06y761.gif&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;所以我们在选择城市首先要考虑的是以下几点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;行业密集型&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;高速发展、人口密集&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;行业底蕴深厚&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;h-1&quot;&gt;&lt;span&gt;行业密集型&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;一个行业密集型的城市，意味着&lt;strong&gt;机会比边缘城市多很多&lt;/strong&gt;，行业密集型时，政府、人才、资本家都会向这里倾斜&lt;/p&gt;
&lt;p&gt;行业上下游链条完整，很容易接触到行业的&lt;strong&gt;上下游&lt;/strong&gt;，对职业成长帮助很大。&lt;/p&gt;
&lt;p&gt;行业密集，资源竞争激烈，对人才的竞争也会很激烈，你的价值会得到更充分的体现。&lt;/p&gt;
&lt;p&gt;像我虽然没那么强，但是经常收到各种猎头的电话挖角（真的痛恨那个恶心人泄露我的电话），被迫无奈最后把手机号直接换了。&lt;/p&gt;
&lt;p&gt;溢价概率更高，对人才渴求度了，自然就有人被迫溢价了。&lt;/p&gt;
&lt;h4 id=&quot;h-2&quot;&gt;&lt;span&gt;高速发展、人口密集&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;在短视频发展的如今，小城市里的你感觉和大城市的信息差没那么大了，其实不然&lt;/p&gt;
&lt;p&gt;信息差在任何发达的社会都会存在，因为有一个很重要的因素，社会具有群体效应，有圈子的存在。&lt;/p&gt;
&lt;p&gt;小城市可能节奏慢、圈子固定，很容易让你陷入一种舒适区&lt;/p&gt;
&lt;p&gt;而在高速发展、人口密集的大城市，人们的文化程度、受教育程度、信息发散程度、圈子间碰撞和流动性都会增多。&lt;/p&gt;
&lt;p&gt;而这些因素都会使你的价值观、职业发展、人生走向产生很大的变化&lt;/p&gt;
&lt;h3 id=&quot;h-3&quot;&gt;&lt;span&gt;公司&amp;amp;产品&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;好的公司和靠谱的产品&lt;/p&gt;
&lt;p&gt;刚找工作那会大家对公司了解程度太浅，记得我毕业面试那会，非常流行东南亚杀猪盘。&lt;/p&gt;
&lt;p&gt;招你过去，保安持枪上班，写完bug就是一顿爆锤，让你天天菊花残，这种例子网上很多。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1gjv1hkdqkjj30u00rfgnd.jpg&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;这种公司很好识别，网上一搜 总部在国外，国内无办地点，只存在一些招聘人员或者挂着一些莫须有的公司名字。&lt;/p&gt;
&lt;p&gt;一般灰产行业的公司承诺的&lt;strong&gt;薪资待遇&lt;/strong&gt;都非常优厚，其他条件也给你承诺的&lt;strong&gt;非常完美&lt;/strong&gt;，但是等你一入职就两眼一抹黑，被限制人生自由。&lt;/p&gt;
&lt;p&gt;完美本身就是一种不完美，所以只要你稍微警惕一点也就不至于。&lt;/p&gt;
&lt;p&gt;对于不了解的公司多在网上查询资料，看看广大网友的评价&lt;/p&gt;
&lt;p&gt;如果是出国工作，而且还是小公司 那就必须超级谨慎，别怀着一个出国梦，结果出去就回不来了&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1gjubxz5sf6j315204imy6.jpg&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;可能有些人说，这是法制社会，哪有那么恐怖，整体上来说没问题的，但是像东南亚国家 博彩业占据GDP的一大半，总不能为了你 割了自己的GDP吧。&lt;/p&gt;
&lt;p&gt;擦亮眼睛，不要因为那点钱赌进去自己的未来&lt;/p&gt;
&lt;p&gt;我认为，好的产品必须满足：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;符合法律要求&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;符合道德约束&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;受到人们喜爱或者未来可能受到人们喜爱&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;能赚到钱的产品&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;h-4&quot;&gt;&lt;span&gt;岗位&amp;amp;方向&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;岗位和方向主要是和自己未来职业规划相匹配的&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;p&gt;有人毕业做了运维，做了几年又转到业务开发，做了几年又搞了支付，做了几年又转到搜索 等等频繁更换岗位方向的。&lt;/p&gt;
&lt;p&gt;经常更换岗位方向，意味着你在每个岗位都是&lt;strong&gt;走马观花&lt;/strong&gt;，不可能沉淀出自己独到的见解。&lt;/p&gt;
&lt;p&gt;这样你倒是尝试挺多的，满足了自己的好奇心，但是你的薪资、你的专业能力全部没有得到应有的提升，而且年龄还在增长&lt;/p&gt;
&lt;p&gt;年龄红利期一过去，专业&lt;strong&gt;深度&lt;/strong&gt;没有，随便找个应届生就把你踢掉，剩下的泪目生活就不必说了吧&lt;/p&gt;
&lt;p&gt;选择岗位时&lt;strong&gt;尽量贴合&lt;/strong&gt;自己职业规划，一般一个岗位规划3~5年时间，在这段时间里，好好研究专业方向的内容&lt;/p&gt;
&lt;p&gt;好好沉淀，好好沉淀，好好沉淀 &lt;strong&gt;重要的事情说三遍&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;h-5&quot;&gt;&lt;span&gt;公司的发展阶段&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;发展阶段主要反映公司整体&lt;strong&gt;技术能力&lt;/strong&gt;和&lt;strong&gt;给钱能力&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一般规律 公司起步前1~3年主要做业务量，技术架构是什么东东 不存在的，都是单体服务，也没什么并发，耦合度高的惊人。&lt;/p&gt;
&lt;p&gt;能撑到第四年，说明业务模式已经经受市场检验了，这时候公司的量来了，技术架构也必须起来了，微服务、分布式、高并发设计这时候必须上了。&lt;/p&gt;
&lt;p&gt;解释一下这是一般规律啊，别拿个别情况忽悠自己&lt;/p&gt;
&lt;p&gt;融资情况可以看出资本对该业务的看好情况，资本看好的一个直接后果就是多金，这样你被高薪砸中的概率大。&lt;/p&gt;
&lt;p&gt;资本家帮你过滤一遍，你在细细筛选一遍，基本能过滤掉一把垃圾公司。&lt;/p&gt;
&lt;p&gt;当然遇上ofo，那就只能是运气不佳了…&lt;/p&gt;
&lt;h3 id=&quot;h-6&quot;&gt;&lt;span&gt;领导情况&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;领导分为直属领导和创始人两个层面&lt;/p&gt;
&lt;p&gt;直属领导就是你进去之后直接给你分配任务的，同时也是决定你的职业成长的。&lt;/p&gt;
&lt;p&gt;遇到垃圾领导就是&lt;strong&gt;脏活&lt;/strong&gt;给你干、&lt;strong&gt;锅给你背&lt;/strong&gt;、升职加薪没你份。&lt;/p&gt;
&lt;p&gt;更有甚者，天天给你画大饼，给你谈未来，给你谈梦想&lt;/p&gt;
&lt;p&gt;遇到这种真的是大不幸，特别是刚毕业的小伙，简直会造成对世界认知的偏见&lt;/p&gt;
&lt;p&gt;所以一般确定给你发offer之后，一定问HR要到直属领导或者带你学长的电话，做一个电话访谈或者微信沟通&lt;/p&gt;
&lt;p&gt;访谈内容主要如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;进去之后负责工作的具体内容是什么？&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;有没有关于你的培养计划，越详细越好？&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;组内会不会经常分享技术，频率是多少？&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;跨部门沟通多不多？&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;说完直属领导，说说&lt;strong&gt;创始人&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有人说，创始人离我很远，我工作几年也从来没见过。&lt;/p&gt;
&lt;p&gt;他真的离你很远么？ 你每天都是在花自己的时间，为别人拼命的实现梦想，难道你都不知道是为谁实现么？&lt;/p&gt;
&lt;p&gt;创始人非常很重要的，他不会直接和你接触，但他是谈梦想的人，你是为他实现梦想的人。&lt;/p&gt;
&lt;p&gt;给你说几个创始人&lt;/p&gt;
&lt;p&gt;某某创始人在年会上公然宣布996是常态化，生活工作不平衡可以离婚；某某创始人提倡四小时睡眠法，说自己坚持多年，效果良好；莫老板发全员邮件说，你们在这里工作虽然赚不了多少钱，但你们会非常的体面。&lt;/p&gt;
&lt;p&gt;你说要是遇到这种创始人，你会怎样？&lt;/p&gt;
&lt;p&gt;创始人情况可以网上查下，看看广大热心网友的评价怎么样&lt;/p&gt;
&lt;h3 id=&quot;h-7&quot;&gt;&lt;span&gt;薪资福利&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;这块放在最后了，不是这块不重要，是相对没那么重要。&lt;/p&gt;
&lt;p&gt;按照前面的条件筛选下来，基本薪资待遇八九不离十了，即使没那么高的离谱的薪资，也算是有一个明朗的未来了。&lt;/p&gt;
&lt;p&gt;薪资这块一定要&lt;strong&gt;问清楚问具体&lt;/strong&gt;，不要听HR忽悠，以下几个问题要特别问清楚&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;薪资计算规则，一般分为以下两种：&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;月薪*月份 + 奖金(年终奖、期权/股票、其他奖励)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;年薪+奖金(年终奖、期权/股票、其他奖励)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ol readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;薪资发放时间，是 **按月发放 ** &lt;strong&gt;还是按年发放&lt;/strong&gt; 或者其他&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;是否有加班薪资，加班薪资怎么计算&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;有没有单位餐厅、是否有餐补或者房补&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;其他福利待遇 年假、婚假、产假等等假期&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;h-8&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;还是那句话，出来卖一定要卖个好价钱，和资本做谈判最好衡量的就是钱，最直接收益的也是钱。&lt;/p&gt;
&lt;p&gt;钱多活少离家近的工作毕竟少，但可以找一个有发展潜力的、看重你的、愿意为你花钱的、合法的公司工作。&lt;/p&gt;
&lt;p&gt;大家在社会中一切东西都要用白纸黑字写清楚，电话沟通能录音的尽量录音，现场也一样，做这些并不是为了其他，只是为了保护好自己。&lt;/p&gt;
&lt;p&gt;最后希望大家都能签一个满意的offer，我是龙叔，一个半吊子架构师，喜欢我记得关注我，给我点赞&lt;br/&gt;欢迎关注公众号 龙跃十二 更多精彩等着你&lt;/p&gt;
</description>
<pubDate>Sun, 25 Oct 2020 23:58:00 +0000</pubDate>
<dc:creator>龙跃十二</dc:creator>
<og:description>幸福的烦恼来的太突然，一下把我砸的晕头转向.....</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhonglongbo/p/13876563.html</dc:identifier>
</item>
<item>
<title>那些鼓吹国内首个.NET 5框架的，该醒醒了！ - 李玉宝</title>
<link>http://www.cnblogs.com/yubaolee/p/Net3ToNet5.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yubaolee/p/Net3ToNet5.html</guid>
<description>&lt;p&gt;前两天看过园子里有篇【国内首个 .NET 5 框架 XX 斩获 XXX stars，XXX 发布】，一顿羡慕嫉妒恨啊。我这.net core 3.1才上手没几天,还没用热乎呢，你这.NET 5的框架都出来了。我好难啊！不过难归难咱也得跟上啊。于是一个天高云淡的的夜晚，一顿猛操作。花费了我.....5分钟的时间把.net core 3.1的项目升级到.NET 5预览版。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;81.120209059233&quot;&gt;
&lt;p&gt;前两天看过园子里有篇【国内首个 .NET 5 框架 XX 斩获 XXX stars，XXX 发布】，一顿羡慕嫉妒恨啊。我这.net core 3.1才上手没几天,还没用热乎呢，你这.NET 5的框架都出来了。我好难啊！不过难归难咱也得跟上啊。于是一个天高云淡的的夜晚，一顿猛操作。花费了我.....5分钟的时间把.net core 3.1的项目升级到.NET 5预览版。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/42655/202010/42655-20201023235539131-2000564927.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;是的，你没看错！还有4分钟是用来下载安装SDK的。我究竟干了什么？&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/42655/202010/42655-20201023233100439-362332270.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;整个工程总共改了11行代码，还有6行一样的。其中包括：&lt;br/&gt;6个相同的地方，把所有的csproj项目目标改为5.0：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;PropertyGroup&amp;gt;
    &amp;lt;TargetFramework&amp;gt;netcoreapp5.0&amp;lt;/TargetFramework&amp;gt;
&amp;lt;/PropertyGroup&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;增加一个global.json文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    &quot;sdk&quot;: {
      &quot;version&quot;: &quot;5.0.100-rc.2.20479.15&quot;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后，点了下调试：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/42655/202010/42655-20201025163843704-481987082.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;完美运行，不相信的可以自己下载体验：&lt;a href=&quot;https://gitee.com/yubaolee/OpenAuth.Net&quot;&gt;https://gitee.com/yubaolee/OpenAuth.Net&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;然后我就很好奇在asp.net core开发方面.NET 5 到底做了什么？&lt;br/&gt;一顿百度发现，其实也并不多，主要集中在以下几点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Azure：删除了Microsoft前缀的Azure集成程序包&lt;/li&gt;
&lt;li&gt;SignalR：MessagePack集线器协议已移至MessagePack 2.x程序包&lt;/li&gt;
&lt;li&gt;SignalR：UseSignalR和UseConnections方法已删除&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;底层基础框架改动是巨大的，但到asp.net这层最大的改变，是版本号少了一个“core“。是的，从3.1到5更重要的意义，在于标志这.NET全新时代的到来。&lt;/p&gt;
&lt;p&gt;所有.net core 3.0/3.1的伙伴，安心写代码，让我们共同期待将今年年底前发布的.NET 5正式版。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以，不要再鼓吹首个了，所有.NET 2.0/3.0/3.1的项目，都在你前面！没事的时候别再删评论了，好好写代码！&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Sun, 25 Oct 2020 23:33:00 +0000</pubDate>
<dc:creator>李玉宝</dc:creator>
<og:description>前两天看过园子里有篇【国内首个 .NET 5 框架 XX 斩获 XXX stars，XXX 发布】，一顿羡慕嫉妒恨啊。我这.net core 3.1才上手没几天,还没用热乎呢，你这.NET 5的框架都</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yubaolee/p/Net3ToNet5.html</dc:identifier>
</item>
<item>
<title>数据结构和算法躬行记（8）——动态规划 - 咖啡机（K.F.J）</title>
<link>http://www.cnblogs.com/strick/p/13403324.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/strick/p/13403324.html</guid>
<description>&lt;p&gt;　　动态规划（Dynamic Programming，DP）是指在给定的约束条件下求最优值的算法，在解决问题的过程，需要经历多个决策阶段，每个决策阶段都对应着一组状态。&lt;/p&gt;
&lt;p&gt;　　适用于动态规划解决的问题包含三个特征：&lt;/p&gt;
&lt;p&gt;　　（1）最优子结构：通过子问题的最优解，可推导出问题的最优解，即后面阶段的状态可以通过前面阶段的状态推导出来。&lt;/p&gt;
&lt;p&gt;　　（2）无后效性：某阶段状态一旦确定，就不受之后阶段的决策影响。即子问题的解一旦确定，就不再改变。&lt;/p&gt;
&lt;p&gt;　　（3）子问题重叠：不同的决策序列，到达某个相同的阶段时，可能会产生重复的状态。即有些子问题会被重复计算多次。&lt;/p&gt;
&lt;p&gt;　　动态规划对每个子问题只计算一次，然后将其计算结果保存到一张表中记忆化存储，以便下次需要同一个子问题解时直接查表，从而获得较高的效率，降低了时间复杂度。&lt;/p&gt;

&lt;p&gt;　　在之前《&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/strick/p/13384038.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;回溯&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;》一文中也提到了0-1背包问题，而此处会在背包重量限制的前提下，计算装入物品的最大总价值。&lt;/p&gt;
&lt;p&gt;　　假设背包容量为4斤，吉他（1斤，价值1500）、音响（4斤，价值3000）和笔记本（3斤，价值2000），求背包的最大价值（题目来源于《图解算法 9.1节》）。&lt;/p&gt;
&lt;p&gt;　　先画状态转移表（如下所示），一般是二维的，在画之前需要回答三个问题：&lt;/p&gt;
&lt;p&gt;　　（1）单元格中的值是什么？当前背包中的最大总价值。&lt;/p&gt;
&lt;p&gt;　　（2）如何划分子问题？考虑容量为1、2、3和4的背包，并且将物品依次放入。&lt;/p&gt;
&lt;p&gt;　　（3）网格的坐标轴是什么？横坐标是背包重量，纵坐标是物品。&lt;/p&gt;
&lt;p&gt;　　接下来将计算每个单元格的值。&lt;/p&gt;
&lt;p&gt;　　（1）第一步是将吉他放入背包的四个重量中，而重量1、2和3其实就是在解决各个子问题。&lt;/p&gt;
&lt;p&gt;　　（2）第二步是依次处理音响，判断是否需要放入，经过比对发现只有最大容量才能放入，更新最大价值为3000。&lt;/p&gt;
&lt;p&gt;　　（3）第三步是依次处理笔记本，在背包容量为3斤时更新最大价值为2000，而在4斤时，可同时放入吉他和笔记本，更新最大价值为3500。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202007/211606-20200730133614062-513234256.png&quot; width=&quot;400&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　根据状态表得出状态转移方程，先计算当前商品价值和剩余空间价值，得到的结果与上一个单元格比对，将较大值填充到当前单元格中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
dp[i][j] = max(goods[i].value + dp[i-&lt;span&gt;1&lt;/span&gt;][j-goods[i].weight], dp[i-&lt;span&gt;1&lt;/span&gt;][j])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　具体的代码实现&lt;span&gt;&lt;a href=&quot;https://codepen.io/strick/pen/bGEyJQq&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;如下所示&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;，本文的代码仅做参考，没有经过严格的测试用例论证。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; knapsack(goods, w) {
  let max &lt;/span&gt;=&lt;span&gt; Number.MIN_VALUE,
    dp &lt;/span&gt;= [&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Array(w)],
    length &lt;/span&gt;=&lt;span&gt; goods.length;
  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (let j = 1; j &amp;lt;= w; j++&lt;span&gt;) {
    dp[&lt;/span&gt;0][j] = goods[0&lt;span&gt;].value;
  }
  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (let i = 1; i &amp;lt; length; i++&lt;span&gt;) {
    dp[i] &lt;/span&gt;=&lt;span&gt; [];
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (let j = 1; j &amp;lt;= w; j++&lt;span&gt;) {
      let rest &lt;/span&gt;= j - goods[i].weight;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算减去当前商品重量后的背包容量&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt; (rest &amp;gt; 0) {                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;套用状态转移方程&lt;/span&gt;
        dp[i][j] = Math.max(goods[i].value + dp[i - 1][rest], dp[i - 1&lt;span&gt;][j]);
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        dp[i][j] &lt;/span&gt;= dp[i - 1][j];             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;沿用上一个单元格的价值&lt;/span&gt;
&lt;span&gt;      }
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (max &amp;lt; dp[i][j]) max = dp[i][j];    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算最大值&lt;/span&gt;
&lt;span&gt;    }
  }
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; max;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）最长公共子串&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　最长公共子串是指在不改变字符相对顺序的情况下提取两段字符串中共有的子串，例如fosh和fish，最长公共子串是sh，长度为2（题目来源于《图解算法 9.3节》）。例题：&lt;span&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/longest-increasing-subsequence/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;300. 最长上升子序列&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　在画状态表之前先回答三个问题：&lt;/p&gt;
&lt;p&gt;　　（1）单元格中的值是什么？公共子串的长度。&lt;/p&gt;
&lt;p&gt;　　（2）如何划分子问题？将两段字符串分割成字符，从前往后依次比对。&lt;/p&gt;
&lt;p&gt;　　（3）网格的坐标轴是什么？横坐标是第一段字符串，纵坐标是第二段字符串。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202007/211606-20200730134007048-763662458.png&quot; width=&quot;400&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　根据状态表得出状态转移方程，当两个字符相同时，左上角的单元格加一，否则单元格为0。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
dp[i][j] = 0 | dp[i-1][j-1] + 1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　具体的代码实现&lt;span&gt;&lt;a href=&quot;https://codepen.io/strick/pen/jOWooxe&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;如下所示&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; longestCommonSubstr(str1, str2) {
  let len1 &lt;/span&gt;=&lt;span&gt; str1.length,
    len2 &lt;/span&gt;=&lt;span&gt; str2.length,
    max &lt;/span&gt;=&lt;span&gt; Number.MIN_VALUE,
    dp &lt;/span&gt;=&lt;span&gt; [];
  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (let i = 0; i &amp;lt; len1; i++&lt;span&gt;) {
    dp[i] &lt;/span&gt;=&lt;span&gt; [];
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (let j = 0; j &amp;lt; len2; j++&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (str1[i] != str2[j]) {            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;两个字符不同&lt;/span&gt;
        dp[i][j] = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
      }
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;应对 i-1 或 j-1 小于0的情况&lt;/span&gt;
      dp[i][j] = i &amp;lt; 1 || j &amp;lt; 1 ? 1 : dp[i - 1][j - 1] + 1&lt;span&gt;;
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (max &amp;lt;&lt;span&gt; dp[i][j]) {
        max &lt;/span&gt;=&lt;span&gt; dp[i][j];
      }
    }
  }
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; max;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）最长公共子序列&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　还有一个类似的题目是求最长公共子序列，其实就是提取共有的子序列，例如fosh和fish，最长公共子序列是fsh，例题：&lt;span&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/longest-common-subsequence/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;1143. 最长公共子序列&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。状态转移表如下所示。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202007/211606-20200730134337451-1908868860.png&quot; width=&quot;400&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　根据状态表得出状态转移方程，当两个字符相同时，仍然是左上角的单元格加一，否则比较左和上两个单元格的值，取较大值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
dp[i][j] = (dp[i-1][j-1] + 1) | max(dp[i-1][j], dp[i][j-1])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　具体的代码实现&lt;span&gt;&lt;a href=&quot;https://codepen.io/strick/pen/yLeWdOB&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;如下所示&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; longestCommonSubsequence(str1, str2) {
  let len1 &lt;/span&gt;=&lt;span&gt; str1.length,
    len2 &lt;/span&gt;=&lt;span&gt; str2.length,
    max &lt;/span&gt;=&lt;span&gt; Number.MIN_VALUE,
    dp &lt;/span&gt;=&lt;span&gt; [];
  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (let i = 0; i &amp;lt; len1; i++&lt;span&gt;) {
    dp[i] &lt;/span&gt;=&lt;span&gt; [];
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (let j = 0; j &amp;lt; len2; j++&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (str1[i] !=&lt;span&gt; str2[j]) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;两个字符不同&lt;/span&gt;
        dp[i][j] =&lt;span&gt; Math.max(
            i &lt;/span&gt;&amp;lt; 1 ? 0 : dp[i - 1&lt;span&gt;][j], 
            j &lt;/span&gt;&amp;lt; 1 ? 0 : dp[i][j - 1&lt;span&gt;]
        );
        max &lt;/span&gt;=&lt;span&gt; Math.max(max, dp[i][j]);
        &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
      }
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;应对 i-1 或 j-1 小于0的情况&lt;/span&gt;
      dp[i][j] = i &amp;lt; 1 || j &amp;lt; 1 ? 1 : dp[i - 1][j - 1] + 1&lt;span&gt;;
      max &lt;/span&gt;=&lt;span&gt; Math.max(max, dp[i][j]);
    }
  }
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; max;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3）最长上升子序列&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　求出一个无序的整数数组中最长上升子序列的长度。例题：&lt;span&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/longest-increasing-subsequence/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;300. 最长上升子序列&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　网上的解法都是用一维状态转移方程，此处仍然采用二维的解法（可观察各个步骤），其中dp[i][j]是指以第 i 个元素结尾的前 j 个元素中的最长上升子序列。&lt;/p&gt;
&lt;p&gt;　　状态表如下所示，每次只计算dp[i][i]的值，其余值沿用上一行的结果。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202007/211606-20200730134541215-217561509.png&quot; width=&quot;500&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　根据状态表得出状态转移方程，当第 i 个元素比第 j 个元素大时，在该值的基础上加一，否则默认赋为一。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
dp[i][i] = 1 | max(dp[i][j]) + 1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　具体的代码实现&lt;span&gt;&lt;a href=&quot;https://codepen.io/strick/pen/ExPBYRx&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;如下所示&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; lengthOfLIS(nums) {
  let len &lt;/span&gt;=&lt;span&gt; nums.length,
    max &lt;/span&gt;= 1&lt;span&gt;,
    dp &lt;/span&gt;=&lt;span&gt; [];
  dp[&lt;/span&gt;0] = [1];            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化dp[0][0]的值&lt;/span&gt;
  &lt;span&gt;for&lt;/span&gt; (let i = 1; i &amp;lt; len; i++&lt;span&gt;) {
    dp[i] &lt;/span&gt;=&lt;span&gt; [];
    dp[i][i] &lt;/span&gt;= 1;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化dp[i][i]的值&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (let j = 0; j &amp;lt; i; j++) {     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;让第i个元素与前j个元素逐一比较&lt;/span&gt;
      dp[i][j] = dp[i-1][j];          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;默认沿用上一行的值&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt; (nums[i] &amp;gt; nums[j]) {        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;当第i个元素比第j个元素大时，取其中的较大值&lt;/span&gt;
        dp[i][i] = Math.max(dp[i][i], dp[i][j] + 1&lt;span&gt;);
      }
    }
    max &lt;/span&gt;=&lt;span&gt; Math.max(max, dp[i][i]);
  }
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; max;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　在《&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/strick/p/13391105.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;贪心算法&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;》一节中曾提到过钱币找零的问题，此处会加大难度。&lt;/p&gt;
&lt;p&gt;　　假设有几种不同面值的纸币 v1，v2，……，vn（单位是元），如果要支付 w 元，那么最少需要多少张纸币，例如有 3 种不同的纸币，1元、2元、5元，要支付 9元，最少需要 3张纸币。例题：&lt;span&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/coin-change/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;322. 零钱兑换&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　在画状态表之前先回答三个问题：&lt;/p&gt;
&lt;p&gt;　　（1）单元格中的值是什么？最少纸币数。&lt;/p&gt;
&lt;p&gt;　　（2）如何划分子问题？考虑要支付1、2...9等金额时，各自需要的最少纸币数。&lt;/p&gt;
&lt;p&gt;　　（3）网格的坐标轴是什么？横坐标是支付金额，纵坐标是可用的纸币。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202007/211606-20200730134905327-715856750.png&quot; width=&quot;800&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　根据状态表得出状态转移方程，计算金额减去当前面值的剩余金额所用的最少纸币数，将其加一和上一行的最少纸币数做比较，取小值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
dp[i][j] = min(dp[i-1][j], dp[i][j - coins[i]] + 1)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　具体的代码实现&lt;span&gt;&lt;a href=&quot;https://codepen.io/strick/pen/NWxZgZW&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;如下所示&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;，虽然代码比较长，但好多都是在判断边界条件，以及做各类情况的处理，核心其实还是围绕着状态转移方程。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; coinChange(coins, amount) {
  let len &lt;/span&gt;=&lt;span&gt; coins.length,
    min &lt;/span&gt;=&lt;span&gt; Number.MAX_VALUE,
    dp &lt;/span&gt;= [&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Array(amount)];
  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (let j = 1; j &amp;lt;= amount; j++) {    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化第一行&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;纸币面值比金额大，或金额无法整除纸币&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;(coins[0] &amp;gt; j || (j % coins[0]) &amp;gt; 0&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对于无法支付金额的情况，赋值为0&lt;/span&gt;
      dp[0][j] = 0&lt;span&gt;;
      &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
    }
    dp[&lt;/span&gt;0][j] = j / coins[0];            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到纸币数量&lt;/span&gt;
&lt;span&gt;  }
  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (let i = 1; i &amp;lt; len; i++&lt;span&gt;) {
    dp[i] &lt;/span&gt;=&lt;span&gt; [];
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (let j = 1; j &amp;lt;= amount; j++&lt;span&gt;) {
      let rest &lt;/span&gt;= j -&lt;span&gt; coins[i];
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(rest == 0) {        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;可用当前纸币支付金额&lt;/span&gt;
        dp[i][j] = 1&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
      }
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(rest &amp;lt; 0) {        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前纸币比支付金额大&lt;/span&gt;
        dp[i][j] = dp[i-1&lt;span&gt;][j];
        &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
      }
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(dp[i-1][j] &amp;gt; 0 &amp;amp;&amp;amp; dp[i][rest] &amp;gt; 0) {    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;都可以支付金额&lt;/span&gt;
        dp[i][j] = Math.min(dp[i-1][j], dp[i][rest] + 1&lt;span&gt;);
      }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(dp[i-1][j] &amp;gt; 0) {                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;只有上一行可以支付金额&lt;/span&gt;
        dp[i][j] = dp[i-1&lt;span&gt;][j];
      }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(dp[i][rest] &amp;gt; 0) {                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;只能借助剩余金额的纸币数支付&lt;/span&gt;
        dp[i][j] = dp[i][rest] + 1&lt;span&gt;;
      }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; {                                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;无法支付&lt;/span&gt;
        dp[i][j] = 0&lt;span&gt;;
      }
    }
  }
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取金额的最小值&lt;/span&gt;
  &lt;span&gt;for&lt;/span&gt;(let i = 0; i &amp;lt; len; i++&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(dp[i][amount] == 0) {        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;过滤掉无法支付的数据&lt;/span&gt;
      &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(dp[i][amount] &amp;gt; 0&lt;span&gt;) {
      min &lt;/span&gt;=&lt;span&gt; Math.min(min, dp[i][amount]);
    }
  }
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; min == Number.MAX_VALUE ? -1&lt;span&gt; : min;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sun, 25 Oct 2020 23:25:00 +0000</pubDate>
<dc:creator>咖啡机（K.F.J）</dc:creator>
<og:description>动态规划（Dynamic Programming，DP）是指在给定的约束条件下求最优值的算法，在解决问题的过程，需要经历多个决策阶段，每个决策阶段都对应着一组状态。 适用于动态规划解决的问题包含三个特</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/strick/p/13403324.html</dc:identifier>
</item>
<item>
<title>跨站资源共享CORS原理深度解析 - 字母哥博客</title>
<link>http://www.cnblogs.com/zimug/p/13876509.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zimug/p/13876509.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202010/1815316-20201026071231557-1866414231.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我相信如果你写过前后端分离的web应用程序，或者写过一些ajax请求调用，你可能会遇到过CORS错误。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;CORS是什么？&lt;/li&gt;
&lt;li&gt;它与安全性有关吗？&lt;/li&gt;
&lt;li&gt;为什么要有CORS？它解决了什么目的？&lt;/li&gt;
&lt;li&gt;CORS是怎样运行的？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果您有这些问题，那么这篇文章非常适合您。&lt;/p&gt;
&lt;h2 id=&quot;一、什么是cors？&quot;&gt;一、什么是CORS？&lt;/h2&gt;
&lt;p&gt;要了解什么是CORS（Cross-Origin Resource Sharing：跨站资源共享），首先我们需要了解什么是同源策略&lt;code&gt;Same Origin Policy&lt;/code&gt;（SOP）。SOP是所有的现代浏览器都具备的安全措施，它不允许从一个加载的js脚本和资源的Origin域与另一个Origin域进行交互。换句话说，如果您的网站是&lt;code&gt;www.example.com&lt;/code&gt;，则您无法向&lt;code&gt;www.test.com&lt;/code&gt;发出XHR请求。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那么SOP有什么用？如果没有同源策略的限制，你想想会发生什么？&lt;/strong&gt; 比如：您已经登录到微博，并且不小心打开了一个恶意网站。该网站可以向微博发出请求，并从您微博登录的会话中提取个人信息。这显然是巨大的安全问题，为了防止这种情况，在浏览器中实施同源策略的限制。实际上，服务器并没有意识到在浏览器端发生的这一切，您仍然可以使用curl或postman发出相同的请求，并且一切响应正常，因为这些工具上没有SOP。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果说SOP是限制跨源访问的一种方式，那么CORS是一种绕过SOP限制并允许您的前端向服务器提出合法请求的方法。&lt;/strong&gt; 如果您的服务端的确是存在跨域的情况（实际上对于现代分布式应用，这很常见），由于SOP限制您的客户端将无法向多节点跨域服务器发出xhr请求。救星就出现了，CORS使我们能够以安全且可管理的方式做到跨域请求，突破同源策略的限制。&lt;/p&gt;
&lt;h2 id=&quot;二、同源策略的源same-origin-policy的origin&quot;&gt;二、同源策略的源(Same Origin Policy的Origin)&lt;/h2&gt;
&lt;p&gt;源由三部分组成：协议，hostip（域）和端口。例如&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;http://example.com/xxx/index.html&lt;/code&gt;和&lt;code&gt;http://example.com/yyy/index.html&lt;/code&gt;是同源，&lt;/li&gt;
&lt;li&gt;&lt;code&gt;http://example.com:80&lt;/code&gt;和&lt;code&gt;http://example.com&lt;/code&gt;（对于http默认端口为80）是同源。&lt;/li&gt;
&lt;li&gt;由于协议不同，&lt;code&gt;http://example.com/app1&lt;/code&gt;和&lt;code&gt;https://example.com/app2&lt;/code&gt;是不同的源。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;http://example.com&lt;/code&gt;，&lt;code&gt;http://www.example.com&lt;/code&gt;由于域名不同，也是不同的源&lt;/li&gt;
&lt;li&gt;非常要注意的是&lt;code&gt;http://localhost&lt;/code&gt; 和&lt;code&gt;http://127.0.0.1&lt;/code&gt;是不同的源&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;同源策略就是：不允许不同的ip、端口、协议的应用在浏览器内进行互相资源共享、请求调用。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;三、cors如何运作？&quot;&gt;三、CORS如何运作？&lt;/h2&gt;
&lt;p&gt;CORS规范允许服务器向浏览器返回一些HTTP Headers，浏览器可以基于这些HTTP Headers来决定是否突破SOP的限制。最主要的一个HTTP Headers是Access-Control-Allow-Origin。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//目标服务允许所有的网站对其进行跨域访问
Access-Control-Allow-Origin: * 
//目标服务允许特定的网站对其进行跨域访问
Access-Control-Allow-Origin: https://example.com
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;CORS有两种类型的请求：“simple”简单请求和“preflight”预检请求，根据请求方法的不同由浏览器确定使用哪种请求。&lt;/p&gt;
&lt;h4 id=&quot;simple简单请求：&quot;&gt;simple简单请求：&lt;/h4&gt;
&lt;p&gt;如果符合以下所有条件，则API请求被视为简单请求：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;API方法是以下方法之一：GET，POST或HEAD。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Content-Type&lt;/code&gt;请求头包含：&lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt;，&lt;code&gt;multipart/form-data&lt;/code&gt;，&lt;code&gt;text/plain&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这两个条件将构成大多数简单请求的用例，但是可以在&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Simple_requests&quot;&gt;此处&lt;/a&gt;找到更详细的简单请求条件列表。&lt;/p&gt;
&lt;p&gt;如果您的API请求被视为&lt;code&gt;simple&lt;/code&gt;简单请求，这个请求就可以直接被发送给服务器。服务器使用CORS HTTP Headers进行响应，浏览器将检查&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;后决定这个请求是否可以突破同源策略的限制，进行下一步的处理。&lt;/p&gt;
&lt;h4 id=&quot;preflight预检请求：&quot;&gt;preflight预检请求：&lt;/h4&gt;
&lt;p&gt;如果您的API请求不满足成为简单请求的标准（最常见不满足简单请求标准的&lt;code&gt;Content-Type&lt;/code&gt;值为&lt;code&gt;application/json&lt;/code&gt;），则浏览器将在发送实际请求之前发出预检请求。&lt;/p&gt;
&lt;p&gt;举一个例子，我们尝试使用&lt;code&gt;GET&lt;/code&gt;请求&lt;code&gt;https://example.com/status&lt;/code&gt;，&lt;code&gt;Content-Type&lt;/code&gt;是&lt;code&gt;application/json&lt;/code&gt;，所以浏览器认为它不符合一个简单请求的标准，因此浏览器会在发出实际请求之前发出预检请求，这个预检请求是使用HTTP的 OPTIONS方法发出的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;curl --location --request OPTIONS 'http://example.com/status' \
--header 'Access-Control-Request-Method: GET' \
--header 'Access-Control-Request-Headers: Content-Type, Accept' \
--header 'Origin: http://test.com'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的curl就是模拟预检请求，实际作用是：浏览器希望告诉服务器，我的实际请求将使用HTTP &lt;code&gt;GET&lt;/code&gt;method进行调用，&lt;code&gt;Content-Type&lt;/code&gt;与&lt;code&gt;Accept&lt;/code&gt;作为HTTP headers，这个请求是从&lt;code&gt;https://test.com&lt;/code&gt;发起的。服务器响应此请求：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;HTTP/1.1 204 No Content
Access-Control-Allow-Origin: *
Access-Control-Allow-Methods: OPTIONS, GET, HEAD, POST
Access-Control-Allow-Headers: Content-Type, Accept
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;：允许发出请求的源，或者&lt;code&gt;*&lt;/code&gt;可以从任何来源发出请求。（即允许跨域的源）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;：允许的以逗号分隔的HTTP方法列表。（即允许跨域的HTTP方法）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt;：允许发送的HTTP headers列表。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;浏览器收到服务端的预检请求响应之后，在我们的示例中服务器响应&lt;code&gt;*&lt;/code&gt;可以从任何来源发出请求，因此现在浏览器将再次访问&lt;code&gt;https://example.com/status&lt;/code&gt;，使用GET方法(不再是OPTIONS方法)，浏览器将不再限制该请求的发出与响应数据的接收。&lt;br/&gt;如果预检请求响应的Origin是特定的&lt;code&gt;Access-Control-Allow-Origin: http://domain.com&lt;/code&gt;，浏览器将出现&lt;code&gt;Cross-Origin Request Blocked&lt;/code&gt;错误。因为服务器端预检结果只允许&lt;code&gt;http://domain.com&lt;/code&gt;发出跨域请求，不允许其他应用向我发出跨域请求。&lt;/p&gt;
&lt;h2 id=&quot;四、如何处理cors错误&quot;&gt;四、如何处理CORS错误&lt;/h2&gt;
&lt;p&gt;我们现在知道什么是CORS及其工作原理，后面的事情其实就简单了。从上面的内容我们需要注意的是，对CORS的完全控制权在服务器，即服务器可以允许或禁止源的跨域访问。所以说跨域问题的处理一般都在服务端进行,不同的服务端的处理HTTP 请求头的代码是不一样的，当然也可以不用写代码，比如：nginx、haproxy设置。&lt;strong&gt;但是万变不离其宗：最终都是对HTTP Headers进行重写&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我就简单的举几个例子：&lt;/p&gt;
&lt;h4 id=&quot;比如servlet处理跨域&quot;&gt;比如Servlet处理跨域&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain)
                        throws IOException, ServletException {
                HttpServletResponse response = (HttpServletResponse) resp; 
            response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); //解决跨域访问报错   
            response.setHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;POST, PUT, GET, OPTIONS, DELETE&quot;);   
            chain.doFilter(req, resp); 
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;比如spring-mvc配置&quot;&gt;比如Spring MVC配置&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;@Configuration
public class GlobalCorsConfig {
    @Bean
    public WebMvcConfigurer corsConfigurer() {
        return new WebMvcConfigurer() {
            @Override
            public void addCorsMappings(CorsRegistry registry) {
                registry.addMapping(&quot;/**&quot;)    //添加映射路径，“/**”表示对所有的路径实行全局跨域访问权限的设置
                        .allowedOrigins(&quot;*&quot;)    //开放哪些ip、端口、域名的访问权限
                        .allowCredentials(true)  //是否允许发送Cookie信息 
                        .allowedMethods(&quot;GET&quot;,&quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;)     //开放哪些Http方法，允许跨域访问
                        .allowedHeaders(&quot;*&quot;)     //允许HTTP请求中的携带哪些Header信息
                        .exposedHeaders(&quot;*&quot;);   //暴露哪些头部信息（因为跨域访问默认不能获取全部头部信息）
            }
        };
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;欢迎关注我的博客，里面有很多精品合集&quot;&gt;欢迎关注我的博客，里面有很多精品合集&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;本文转载注明出处（必须带连接，不能只转文字）：&lt;a href=&quot;http://www.zimug.com&quot;&gt;字母哥博客&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;觉得对您有帮助的话，帮我点赞、分享！您的支持是我不竭的创作动力！&lt;/strong&gt; 。另外，笔者最近一段时间输出了如下的精品内容，期待您的关注。&lt;/p&gt;
</description>
<pubDate>Sun, 25 Oct 2020 23:13:00 +0000</pubDate>
<dc:creator>字母哥博客</dc:creator>
<og:description>我相信如果你写过前后端分离的web应用程序，或者写过一些ajax请求调用，你可能会遇到过CORS错误。 CORS是什么？ 它与安全性有关吗？ 为什么要有CORS？它解决了什么目的？ CORS是怎样运行</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zimug/p/13876509.html</dc:identifier>
</item>
<item>
<title>5. Bean Validation声明式验证四大级别：字段、属性、容器元素、类 - YourBatman</title>
<link>http://www.cnblogs.com/yourbatman/p/13876469.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yourbatman/p/13876469.html</guid>
<description>&lt;blockquote readability=&quot;6.3346007604563&quot;&gt;
&lt;p&gt;1024，代码改变世界。本文已被 &lt;a href=&quot;https://www.yourbatman.cn&quot;&gt;&lt;strong&gt;https://www.yourbatman.cn&lt;/strong&gt;&lt;/a&gt; 收录，里面一并有Spring技术栈、MyBatis、JVM、中间件等小而美的&lt;strong&gt;专栏&lt;/strong&gt;供以免费学习。关注公众号【&lt;strong&gt;BAT的乌托邦&lt;/strong&gt;】逐个击破，深入掌握，拒绝浅尝辄止。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201023161125192.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;你好，我是YourBatman。又一年1024程序员节，你快乐吗？还是在加班上线呢？&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/jzOv67ZTSx2rByj0aeUTgw&quot;&gt;上篇文章&lt;/a&gt; 介绍了Validator校验器的五大核心组件，在结合前面几篇所讲，相信你对Bean Validation已有了一个整体认识了。&lt;/p&gt;
&lt;p&gt;本文将&lt;strong&gt;非常实用&lt;/strong&gt;，因为将要讲述的是Bean Validation在4个层级上的验证方式，它将覆盖你使用过程中的方方面面，不信你看。&lt;/p&gt;
&lt;h2 id=&quot;版本约定&quot;&gt;版本约定&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Bean Validation版本：&lt;code&gt;2.0.2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Hibernate Validator版本：&lt;code&gt;6.1.5.Final&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Jakarta Bean它的验证约束是通过声明式方式（注解）来表达的，我们知道Java注解几乎可以标注在任何地方（package上都可标注注解你敢信？），那么Jakarta Bean支持哪些呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Jakarta Bean&lt;/strong&gt;共支持四个级别的约束：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;字段约束（Field）&lt;/li&gt;
&lt;li&gt;属性约束（Property）&lt;/li&gt;
&lt;li&gt;容器&lt;strong&gt;元素&lt;/strong&gt;约束（Container Element）&lt;/li&gt;
&lt;li&gt;类约束（Class）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;值得注意的是，并不是所有的&lt;strong&gt;约束注解&lt;/strong&gt;都能够标注在上面四种级别上。现实情况是：Bean Validation自带的22个标准约束全部支持1/2/3级别，且全部&lt;strong&gt;不支持&lt;/strong&gt;第4级别（类级别）约束。当然喽，作为补充的&lt;code&gt;Hibernate-Validator&lt;/code&gt;它提供了一些专门用于类级别的约束注解，如&lt;code&gt;org.hibernate.validator.constraints.@ScriptAssert&lt;/code&gt;就是一常用案例。&lt;/p&gt;
&lt;p&gt;说明：为简化接下来示例代码，共用工具代码提前展示如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public abstract class ValidatorUtil {

    public static ValidatorFactory obtainValidatorFactory() {
        return Validation.buildDefaultValidatorFactory();
    }

    public static Validator obtainValidator() {
        return obtainValidatorFactory().getValidator();
    }

    public static ExecutableValidator obtainExecutableValidator() {
        return obtainValidator().forExecutables();
    }

    public static &amp;lt;T&amp;gt; void printViolations(Set&amp;lt;ConstraintViolation&amp;lt;T&amp;gt;&amp;gt; violations) {
        violations.stream().map(v -&amp;gt; v.getPropertyPath()  + v.getMessage() + &quot;，但你的值是： &quot; + v.getInvalidValue()).forEach(System.out::println);
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;1、字段级别约束（field）&quot;&gt;1、字段级别约束（Field）&lt;/h2&gt;
&lt;p&gt;这是我们&lt;strong&gt;最为常用&lt;/strong&gt;的一种约束方式：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Room {

    @NotNull
    public String name;
    @AssertTrue
    public boolean finished;

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;书写测试用例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static void main(String[] args) {
    Room bean = new Room();
    bean.finished = false;
    ValidatorUtil.printViolations(ValidatorUtil.obtainValidator().validate(bean));
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行程序，输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;finished只能为true，但你的值是： false
name不能为null，但你的值是： null
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当把约束标注在Field字段上时，Bean Validation将使用字段的访问策略来校验，&lt;strong&gt;不会调用任何方法&lt;/strong&gt;，即使你提供了对应的get/set方法也不会触碰。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;话外音：使用&lt;code&gt;Field#get()&lt;/code&gt;得到字段的值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;使用细节&quot;&gt;使用细节&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;字段约束可以应用于&lt;strong&gt;任何访问修饰符&lt;/strong&gt;的字段&lt;/li&gt;
&lt;li&gt;不支持对静态字段的约束（static静态字段使用约束无效）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;若你的对象会被&lt;strong&gt;字节码增强&lt;/strong&gt;，那么请不要使用Field约束，而是使用下面介绍的属性级别约束更为合适。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;原因：增强过的类并不一定能通过字段反射去获取到它的值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;绝大多数情况下，对Field字段做约束的话均是POJO，被增强的可能性极小，因此此种方式是&lt;strong&gt;被推荐的&lt;/strong&gt;，看着清爽。&lt;/p&gt;
&lt;h2 id=&quot;2、属性级别约束（property）&quot;&gt;2、属性级别约束（Property）&lt;/h2&gt;
&lt;p&gt;若一个Bean遵循&lt;strong&gt;Java Bean规范&lt;/strong&gt;，那么也可以使用属性约束来代替字段约束。比如上例可改写为如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Room {

    public String name;
    public boolean finished;

    @NotNull
    public String getName() {
        return name;
    }

    @AssertTrue
    public boolean isFinished() {
        return finished;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行上面相同的测试用例，输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;finished只能为true，但你的值是： false
name不能为null，但你的值是： null
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果“完全”一样。&lt;/p&gt;
&lt;p&gt;当把约束标注在Property属性上时，将采用属性访问策略来获取要验证的值。说白了：会调用你的Method来获取待校验的值。&lt;/p&gt;
&lt;h3 id=&quot;使用细节-2&quot;&gt;使用细节&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;约束放在get方法上&lt;strong&gt;优于&lt;/strong&gt;放在set方法上，这样只读属性（没有get方法）依然可以执行约束逻辑&lt;/li&gt;
&lt;li&gt;不要在&lt;strong&gt;属性和字段&lt;/strong&gt;上都标注注解，否则会重复执行约束逻辑（有多少个注解就执行多少次）&lt;/li&gt;
&lt;li&gt;不要既在属性的get方法上又在set方法上标注约束注解&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;3、容器元素级别约束（container-element）&quot;&gt;3、容器元素级别约束（Container Element）&lt;/h2&gt;
&lt;p&gt;还有一种非常非常常见的验证场景：验证容器内（每个）元素，也就验证参数化类型&lt;code&gt;parameterized type&lt;/code&gt;。形如&lt;code&gt;List&amp;lt;Room&amp;gt;&lt;/code&gt;希望里面装的每个Room都是合法的，传统的做法是在for循环里对每个room进行验证：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;List&amp;lt;Room&amp;gt; beans = new ArrayList&amp;lt;&amp;gt;();
for (Room bean : beans) {
    validate(bean);
    ...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;很明显这么做至少存在下面两个不足：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;验证逻辑具有侵入性&lt;/li&gt;
&lt;li&gt;验证逻辑是黑匣子（不看内部源码无法知道你有哪些约束），非声明式&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在本专栏&lt;a href=&quot;https://mp.weixin.qq.com/s/g04HMhrjbvbPn1Mb9JYa5g&quot;&gt;第一篇&lt;/a&gt;知道了从Bean Validation 2.0开始就支持容器元素校验了（本专栏使用版本为：&lt;code&gt;2.02&lt;/code&gt;），下面我们来体验一把：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Room {
    @NotNull
    public String name;
    @AssertTrue
    public boolean finished;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;书写测试用例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static void main(String[] args) {
    List&amp;lt;@NotNull Room&amp;gt; rooms = new ArrayList&amp;lt;&amp;gt;();
    rooms.add(null);
    rooms.add(new Room());

    Room room = new Room();
    room.name = &quot;YourBatman&quot;;
    rooms.add(room);

    ValidatorUtil.printViolations(ValidatorUtil.obtainValidator().validate(rooms));
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行程序，&lt;strong&gt;没有任何输出&lt;/strong&gt;，也就是说并没有对rooms立面的元素进行验证。这里有一个误区：Bean Validator是基于&lt;strong&gt;Java Bean&lt;/strong&gt;进行验证的，而此处你的&lt;code&gt;rooms&lt;/code&gt;仅仅只是一个容器类型的变量而已，因此不会验证。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;其实它是把List当作一个Bean，去验证List里面的标注有约束注解的属性/方法。很显然，List里面不可能标注有约束注解嘛，所以什么都不输出喽&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为了让验证生效，我们只需这么做：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Data
@NoArgsConstructor
@AllArgsConstructor
public class Rooms {
    private List&amp;lt;@Valid @NotNull Room&amp;gt; rooms;
}

public static void main(String[] args) {
    List&amp;lt;@NotNull Room&amp;gt; beans = new ArrayList&amp;lt;&amp;gt;();
    beans.add(null);
    beans.add(new Room());

    Room room = new Room();
    room.name = &quot;YourBatman&quot;;
    beans.add(room);

    // 必须基于Java Bean，验证才会生效
    Rooms rooms = new Rooms(beans);
    ValidatorUtil.printViolations(ValidatorUtil.obtainValidator().validate(rooms));
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行程序，输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;rooms[0].&amp;lt;list element&amp;gt;不能为null，但你的值是： null
rooms[2].finished只能为true，但你的值是： false
rooms[1].name不能为null，但你的值是： null
rooms[1].finished只能为true，但你的值是： false
rooms[1].finished只能为true，但你的值是： false
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从日志中可以看出，元素的验证顺序是不保证的。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;小贴士：在HV 6.0 &lt;strong&gt;之前&lt;/strong&gt;的版本中，验证容器元素时@Valid是必须，也就是必须写成这样：&lt;code&gt;List&amp;lt;@Valid @NotNull Room&amp;gt; rooms&lt;/code&gt;才有效。在HV 6.0之后@Valid这个注解就不是必须的了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;使用细节-3&quot;&gt;使用细节&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;若约束注解想标注在容器元素上，那么注解定义的&lt;code&gt;@Target&lt;/code&gt;里必须包含&lt;code&gt;TYPE_USE&lt;/code&gt;（Java8新增）这个类型
&lt;ol&gt;&lt;li&gt;BV和HV（除了Class级别）的&lt;strong&gt;所有注解&lt;/strong&gt;均能标注在容器元素上&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;BV规定了可以验证容器内元素，HV提供实现。它默认支持如下容器类型：
&lt;ol&gt;&lt;li&gt;&lt;code&gt;java.util.Iterable&lt;/code&gt;的实现（如List、Set）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;java.util.Map&lt;/code&gt;的实现，支持key和value&lt;/li&gt;
&lt;li&gt;&lt;code&gt;java.util.Optional/OptionalInt/OptionalDouble...&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;JavaFX的&lt;code&gt;javafx.beans.observable.ObservableValue&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;自定义容器类型（自定义很重要，详见下篇文章）&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;4、类级别约束（class）&quot;&gt;4、类级别约束（Class）&lt;/h2&gt;
&lt;p&gt;类级别的约束验证是很多同学不太熟悉的一块，但它却很是重要。&lt;/p&gt;
&lt;p&gt;其实Hibernate-Validator已内置提供了一部分能力，但可能还不够，很多场景需要自己动手优雅解决。为了体现此part的重要性，我决定专门撰文描述，当然还有&lt;strong&gt;自定义容器类型&lt;/strong&gt;类型的校验喽，我们下文见。&lt;/p&gt;
&lt;h2 id=&quot;字段约束和属性约束的区别&quot;&gt;字段约束和属性约束的区别&lt;/h2&gt;
&lt;p&gt;字段（Field） VS 属性（Property）本身就属于一对“近义词”，很多时候口头上我们并不做区分，是因为&lt;strong&gt;在POJO里&lt;/strong&gt;他俩一般都同时存在，因此大多数情况下可以对等沟通。比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Data
public class Room {
    @NotNull
    private String name;
    @AssertTrue
    private boolean finished;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;字段和属性的区别&quot;&gt;字段和属性的区别&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;字段具有存储功能：字段是类的一个成员，值在内存中真实存在；而属性它不具有存储功能，属于Java Bean规范抽象出来的一个叫法&lt;/li&gt;
&lt;li&gt;字段一般用于类&lt;strong&gt;内部&lt;/strong&gt;（一般是private），而属性可供外部访问（get/set一般是public）
&lt;ol&gt;&lt;li&gt;这指的是一般情况下的规律&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;字段的本质是Field，属性的本质是Method&lt;/li&gt;
&lt;li&gt;属性并&lt;strong&gt;不依赖于&lt;/strong&gt;字段而存在，只是他们一般都成双成对出现
&lt;ol&gt;&lt;li&gt;如&lt;code&gt;getClass()&lt;/code&gt;你可认为它有名为class的属性，但是它并没有名为class的字段&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;知晓了字段和属性的区别，再去理解&lt;strong&gt;字段约束&lt;/strong&gt;和&lt;strong&gt;属性约束&lt;/strong&gt;的差异就简单了，它俩的差异仅仅体现在&lt;strong&gt;待验证值&lt;/strong&gt;访问策略上的区别：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;字段约束：直接反射访问字段的值 -&amp;gt; Field#get（不会执行get方法体）&lt;/li&gt;
&lt;li&gt;属性约束：调用属性get方法 -&amp;gt; getXXX（会执行get方法体）&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;小贴士：如果你希望执行了验证就输出一句日志，又或者你的POJO被字节码增强了，那么属性约束更适合你。否则，推荐使用字段约束&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;嗯，这篇文章还不错吧，总体浏览下来行文简单，但内容还是挺干的哈，毕竟1024节嘛，不来点的干的心里有愧。&lt;/p&gt;
&lt;p&gt;作为此part姊妹篇的&lt;strong&gt;上篇&lt;/strong&gt;，它是每个同学都有必要掌握的使用方式。而&lt;strong&gt;下篇&lt;/strong&gt;我觉得应该更为兴奋些，毕竟那里才能加分。1024，撸起袖子继续干。&lt;/p&gt;
&lt;h5 id=&quot;推荐阅读：&quot;&gt;✔推荐阅读：&lt;/h5&gt;
</description>
<pubDate>Sun, 25 Oct 2020 22:29:00 +0000</pubDate>
<dc:creator>YourBatman</dc:creator>
<og:description>1024，撸起袖子继续干</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yourbatman/p/13876469.html</dc:identifier>
</item>
<item>
<title>SpringBoot整合原生OpenFegin的坑（非SpringCloud） - 冰河团队</title>
<link>http://www.cnblogs.com/binghe001/p/13876226.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/binghe001/p/13876226.html</guid>
<description>&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;最近，在使用SpringBoot+K8S开发微服务系统，既然使用了K8S，我就不想使用SpringCloud了。为啥，因为K8S本身的就提供了非常6的服务注册与发现、限流、熔断、负载均衡等等微服务需要使用的技术，那我为啥还要接入SpringCloud呢？额，说了这么多，在真正使用SpringBoot+K8S这一套技术栈的时候，也会遇到一些问题，比如我不需要使用SpringCloud时，调用其他服务时，我使用的是原生的OpenFegin，在使用OpenFegin调用其他服务的时候，就遇到了一个大坑。通过OpenFeign请求返回值LocalDateTime发生了异常，今天，我们就来说说这个坑！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;项目集成openfegin&quot;&gt;项目集成OpenFegin&lt;/h2&gt;
&lt;h3 id=&quot;集成openfegin依赖&quot;&gt;集成OpenFegin依赖&lt;/h3&gt;
&lt;p&gt;首先，我先跟大家说下项目的配置，整体项目使用的SpringBoot版本为2.2.6，原生的OpenFegin使用的是11.0，我们通过如下方式在pom.xml中引入OpenFegin。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;properties&amp;gt;
    &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;
    &amp;lt;skip_maven_deploy&amp;gt;false&amp;lt;/skip_maven_deploy&amp;gt;
    &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;
    &amp;lt;openfegin.version&amp;gt;11.0&amp;lt;/openfegin.version&amp;gt;
&amp;lt;/properties&amp;gt;
&amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;io.github.openfeign&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;feign-core&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;${openfegin.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;io.github.openfeign&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;feign-jackson&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;${openfegin.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里，我省略了一些其他的配置项。&lt;/p&gt;
&lt;p&gt;接下来，我就开始在我的项目中使用OpenFegin调用远程服务了。具体步骤如下。&lt;/p&gt;
&lt;h3 id=&quot;实现远程调用&quot;&gt;实现远程调用&lt;/h3&gt;
&lt;p&gt;首先，创建OpenFeignConfig类，配置OpenFegin默认使用的Contract。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Configuration
public class OpenFeignConfig {
        @Bean
        public Contract useFeignAnnotations() {
                return new Contract.Default();
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来，我们写一个通用的获取OpenFeign客户端的工厂类，这个类也比较简单，本质上就是以一个HashMap来缓存所有的FeginClient，这个的FeginClient本质上就是我们自定义的Fegin接口，缓存中的Key为请求连接的基础URL，缓存的Value就是我们定义的FeginClient接口。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class FeginClientFactory {
        
        /**
         * 缓存所有的Fegin客户端
         */
        private volatile static Map&amp;lt;String, Object&amp;gt; feginClientCache = new HashMap&amp;lt;&amp;gt;();
        
        /**
         * 从Map中获取数据
         * @return 
         */
        @SuppressWarnings(&quot;unchecked&quot;)
        public static &amp;lt;T&amp;gt; T getFeginClient(Class&amp;lt;T&amp;gt; clazz, String baseUrl){
                if(!feginClientCache.containsKey(baseUrl)) {
                        synchronized (FeginClientFactory.class) {
                                if(!feginClientCache.containsKey(baseUrl)) {
                                        T feginClient = Feign.builder().decoder(new JacksonDecoder()).encoder(new JacksonEncoder()).target(clazz, baseUrl);
                                        feginClientCache.put(baseUrl, feginClient);
                                }
                        }
                }
                return (T)feginClientCache.get(baseUrl);
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来，我们就定义一个FeginClient接口。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface FeginClientProxy {
        @Headers(&quot;Content-Type:application/json;charset=UTF-8&quot;)
        @RequestLine(&quot;POST /user/login&quot;)
        UserLoginVo login(UserLoginVo loginVo);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来，我们创建SpringBoot的测试类。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@RunWith(SpringRunner.class)
@SpringBootTest
public class IcpsWeightStarterTest {
        @Test
        public void testUserLogin() {
                ResponseMessage result = FeginClientFactory.getFeginClient(FeginClientProxy.class, &quot;http://127.0.0.1&quot;).login(new UserLoginVo(&quot;zhangsan&quot;, &quot;123456&quot;, 1));
                System.out.println(JsonUtils.bean2Json(result));
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一切准备就绪，运行测试。麻蛋，出问题了。主要的问题就是通过OpenFeign请求返回值LocalDateTime字段会发生异常！！！&lt;/p&gt;
&lt;p&gt;注：此时异常时，我们在LocalDateTime字段上添加的注解如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;import java.time.LocalDateTime;
import com.baomidou.mybatisplus.annotation.FieldFill;
import com.baomidou.mybatisplus.annotation.TableField;
import com.fasterxml.jackson.annotation.JsonFormat;


@TableField(value = &quot;CREATE_TIME&quot;, fill = FieldFill.INSERT)
@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;, locale = &quot;zh&quot;, timezone = &quot;GMT+8&quot;)
private LocalDateTime createTime;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;解决问题&quot;&gt;解决问题&lt;/h2&gt;
&lt;h3 id=&quot;问题描述&quot;&gt;问题描述&lt;/h3&gt;
&lt;p&gt;SpringBoot通过原生OpenFeign客户端调用HTTP接口，如果返回值中包含LocalDateTime类型（包括其他JSR-310中java.time包的时间类），在客户端可能会出现反序列化失败的错误。错误信息如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt; Caused by:com.fasterxml.jackson.databind.exc.InvalidDefinitionException: Cannot construct instance of `java.time.LocalDateTime` (no Creators, like default construct, exist): no String-argument constructor/factory method to deserialize from String value ('2020-10-07T11:04:32')
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;问题分析&quot;&gt;问题分析&lt;/h3&gt;
&lt;p&gt;从客户端调用fegin，也是相当于URL传参就相当于经过一次JSON转换，数据库取出‘2020-10-07T11:04:32’数据这时是时间类型，进过JSON之后就变成了String类型，T就变成了字符不再是一个特殊字符，因此String的字符串“2020-10-07T11:04:32”反序列化就会失败。&lt;/p&gt;
&lt;h3 id=&quot;问题解决&quot;&gt;问题解决&lt;/h3&gt;
&lt;p&gt;在项目中增加依赖。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.fasterxml.jackson.datatype&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;jackson-datatype-jsr310&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.9.9&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注：如果是用的是SpringBoot，并且明确指定了SpringBoot版本，引入jackson-datatype-jsr310时，可以不用指定版本号。&lt;/p&gt;
&lt;p&gt;接下来，在POJO类的LocalDateTime类型字段增加如下注解。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.datatype.jsr310.deser.LocalDateTimeDeserializer;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;添加后的效果如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;import java.time.LocalDateTime;
import com.baomidou.mybatisplus.annotation.FieldFill;
import com.baomidou.mybatisplus.annotation.TableField;
import com.fasterxml.jackson.annotation.JsonFormat;

import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.datatype.jsr310.deser.LocalDateTimeDeserializer;


@TableField(value = &quot;CREATE_TIME&quot;, fill = FieldFill.INSERT)
@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;, locale = &quot;zh&quot;, timezone = &quot;GMT+8&quot;)
@JsonDeserialize(using = LocalDateTimeDeserializer.class)
private LocalDateTime createTime;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时，再次调用远程接口，问题解决。&lt;/p&gt;
&lt;h2 id=&quot;重磅福利&quot;&gt;重磅福利&lt;/h2&gt;
&lt;p&gt;微信搜一搜【冰河技术】微信公众号，关注这个有深度的程序员，每天阅读超硬核技术干货，公众号内回复【PDF】有我准备的一线大厂面试资料和我原创的超硬核PDF技术文档，以及我为大家精心准备的多套简历模板（不断更新中），希望大家都能找到心仪的工作，学习是一条时而郁郁寡欢，时而开怀大笑的路，加油。如果你通过努力成功进入到了心仪的公司，一定不要懈怠放松，职场成长和新技术学习一样，不进则退。如果有幸我们江湖再见！&lt;/p&gt;
&lt;p&gt;另外，我开源的各个PDF，后续我都会持续更新和维护，感谢大家长期以来对冰河的支持！！&lt;/p&gt;
</description>
<pubDate>Sun, 25 Oct 2020 17:37:00 +0000</pubDate>
<dc:creator>冰河团队</dc:creator>
<og:description>写在前面 最近，在使用SpringBoot+K8S开发微服务系统，既然使用了K8S，我就不想使用SpringCloud了。为啥，因为K8S本身的就提供了非常6的服务注册与发现、限流、熔断、负载均衡等等</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/binghe001/p/13876226.html</dc:identifier>
</item>
<item>
<title>APP打开（三）—激活率提升20%的思考 - 花开可缓归</title>
<link>http://www.cnblogs.com/zshcnblogs/p/13876117.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zshcnblogs/p/13876117.html</guid>
<description>&lt;p&gt;&lt;span&gt;激活是APP拉新后的一个重要环节。通常，我们希望用户打开我们的APP之后，能够顺利的被激活，从而留下来成为我们的忠实用户。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;激活一词，就跟北斗星指标一样，对每个产品来说都是不一样的。有些APP一旦打开就算激活了，有些APP注册了才算激活，有些APP使用了服务才算激活，总之不同的APP都有着不同的标准。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1. 实例&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在增长黑客的世界里，往往一个小小的改动就能够引起一连串的化学反应，这些改动可能是一个文案、一个按钮、一个特别的小挂件等。而我今天要说的，就是一个简单的逻辑变化，但是这个变化却能够就APP的激活率提升20%，简单画个图看看。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/2135113/202010/2135113-20201026001823125-987122376.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们做的是一个流量工具+电商类的产品，新用户成功启用一次我们的服务才算激活，在激活之前的打开注册等在这里不讨论，我们只说激活。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;拉新的彩头是送新手红包，所以每一个新用户打开首页之后，都会弹出一个红包框，在红包框上面可以选择“立即领取”or“关掉红包”，原本的流程是 01-&amp;gt;03，用户不论是在红包框上面选择什么，都会直接关掉红包框，同时将红包里面赠送的流量充值到用户账户并展示首页给用户，红包消失后没有任何引导，这个时候全靠用户自己去启用服务才能够到02，在03到02之间流失了大量的用户。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;这个时候我们考虑到以下两个问题：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;① 我们已经赠送给用户免费的流量，用户来也是希望体验这个产品的，我们为什么一定要用户自己手动去启用服务，而不能直接帮用户启用服务进行体验呢？这个过程中，用户是没有任何损失的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;②领用红包之后用户就不知道干嘛了，那能不能让用户干点什么？让用户傻等着显然不是一件好事情。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;先说问题①&lt;/strong&gt;，帮用户把服务启起来，这看起来是个好主意，反正也是要用的，索性就少掉那个用户要自己去启用的过程（03页面），直接从01-&amp;gt;02，一步到位，&lt;strong&gt;将手动激活变更为自动激活。这样做了之后，我们的激活率直接提升了20%左右&lt;/strong&gt;，这个数字无疑是很振奋人心的。每一个指标想做出跨越性的提升都是艰难的，做增长的产品应该都能够体会到这其中的五味杂陈。过了半个月之后，我们发现激活率上去了，但是留存降低了很多。&lt;strong&gt;手动变为自动，用户体验了，但却没学会怎么更好的使用，也没有增加更多有效的措施留下用户，毛病就出来了。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;再说一下问题②，让用户做点什么。新产品刚上去还在探索期，总是瞻前不顾后，帮用户激活了服务，那激活这个步骤跟过程是怎么样的却没有告诉给用户，导致用户一脸懵逼，莫名其妙的我的服务就能用了，莫名其妙的我就不知道怎么用了，又不是一锤子买卖，怎么留住用户也是一个关键点。很多产品，尤其是游戏类的产品，新手引导都做的很棒，手把手教学，还有像微信漂流瓶，用户在界面上停留几秒没有操作它就会小箭头提示用户要干嘛，这都是我们应该借鉴的点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2. 回顾&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;将手动变更为自动，激活率提升上去之后，我们接下来就该考虑怎么做留存留住用户，一步没做到位没关系，多迭代两个版本推广这一块就问题不大了，每一个指标提升都不易，很多时候试很多办法可能都提不上去，所以一旦有提升一定要坚守住当前的指标，在这个指标的基础上再去提升其他的指标。但很遗憾的是，因为某些原因（产品经理无法坚守）我们去掉了自动激活，激活率又掉了下去，做的补充方案也并没有达到效果，可以说是十分遗憾了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果有机会实际上我还是想试一下自动激活这个方案加上留存的补充措施，最终能够达到的实际效果，从推演来看，产品工作做到位后，在激活提升20%的基础上，留存最终至少能够提升10%，这样获客成本就能够降低￥15+。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;总的来说，帮用户做是可行的，可以先享受到服务，但别忘了教用户怎么做，两者结合才能够同步提升激活和留存。同时，帮用户做的时候，一定要注意不能损害用户的任何利益。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;拓展到其他的APP和其他的指标，比如说注册，一定要邮箱注册谷歌注册手机号注册吗？不一定，还可以选择免账号注册（比如华为的天际通），当然免账号涉及到手机系统参数读取问题，并不是所有的APP都能搞。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;写在最后：产品经理一定不能让眼前的小利益或者小困难蒙蔽住了双眼，要尽可能从更高的地方，全局思考，并且多转换自己的思路，不要一叶障目。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 25 Oct 2020 16:25:00 +0000</pubDate>
<dc:creator>花开可缓归</dc:creator>
<og:description>激活是APP拉新后的一个重要环节。通常，我们希望用户打开我们的APP之后，能够顺利的被激活，从而留下来成为我们的忠实用户。 激活一词，就跟北斗星指标一样，对每个产品来说都是不一样的。有些APP一旦打开</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zshcnblogs/p/13876117.html</dc:identifier>
</item>
</channel>
</rss>