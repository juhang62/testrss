<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>MySQL如何计算统计redo log大小 - 潇湘隐者</title>
<link>http://www.cnblogs.com/kerrycode/p/14187235.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kerrycode/p/14187235.html</guid>
<description>&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;在MySQL中如何计算、统计重做日志（redo log)的生成情况呢？ 例如10分钟内，生成了多少M的redo log呢?30分钟内又生成了多少M的redo log.....。MySQL没有像Oracle中那样的系统视图统计这些数据，但是我们可以通过一些方法曲线的统计二进制日志的生成量。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;虽然我在这篇博客&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;“&lt;a href=&quot;https://www.cnblogs.com/kerrycode/p/13814012.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;&lt;strong&gt;MySQL中Redo Log相关的重要参数总结&lt;/strong&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;”&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;中介绍了，MySQL 8.0引入了innodb_dedicated_server自适应参数，可基于服务器的内存来动态设置innodb_buffer_pool_size，innodb_log_file_size和innodb_flush_method。默认情况下，此参数是关闭的。但是在MySQL 8.0之前，通过计算重做日志（redo log）的生成量来判断判断innodb_log_buffer_size和innodb_log_file_size的大小是否合适是非常必要的，个人认为即使MySQL 8.0版本下，这个也是非常有参考和研究意义的。我们通过统计、分析计算重做日志（redo log）的生成量，从而判断InnoDB的事务日志文件大概能支撑多长时间就会切换。有具体数据支撑，你才好分析判断，否则巧妇也难为无米之炊。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;在MySQL的information_schema.global_status或performance_schema.global_status中有个服务器状态变量(Server Status Variables）Innodb_os_log_written,它记录了Innodb的重做日志（redo log）的生成量，它记录写入InnoDB重做日志文件的字节数，它是一个累积值。官方文档关于此服务器状态变量的描述如下&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;Innodb_os_log_written&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;The number of bytes written to the&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;InnoDB&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;redo log&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;files.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;我们主要通过一个计划任务/事件调度定期的去采集Innodb_os_log_written服务器状态变量获取重做日志的大小，将其存储在innodb_log_size_his表中，方便分析统计。具体脚本如下：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;注意：performance_schema.global_status是MySQL 5.7引入的，而MySQL 8.0开始，information_schema.global_status直接被丢弃了。所以注意MySQL版本，选择合适脚本。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; readability=&quot;30&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt;USE&lt;/span&gt; mysqls;
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; &lt;span&gt;IF&lt;/span&gt; &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;EXISTS&lt;/span&gt; innodb_log_size_his
&lt;/pre&gt;
&lt;pre&gt;
(
&lt;/pre&gt;
&lt;pre&gt;
    log_id          &lt;span&gt;INT&lt;/span&gt; AUTO_INCREMENT &lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt; COMMENT &lt;span&gt;'日志编号'&lt;/span&gt;,
&lt;/pre&gt;
&lt;pre&gt;
    log_date        DATETIME COMMENT &lt;span&gt;'记录当前数据的时间'&lt;/span&gt;,
&lt;/pre&gt;
&lt;pre&gt;
    log_size        &lt;span&gt;DOUBLE&lt;/span&gt; COMMENT &lt;span&gt;'redo log的大小,单位为mb'&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
) ENGINE=InnoDB &lt;span&gt;DEFAULT&lt;/span&gt; CHARSET=utf8mb4 &lt;span&gt;COLLATE&lt;/span&gt;=utf8mb4_0900_ai_ci COMMENT &lt;span&gt;'redo日志大小信息表'&lt;/span&gt;;
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
--MySQL 5.*版本用下面脚本
&lt;/pre&gt;
&lt;pre&gt;
DELIMITER &amp;amp;&amp;amp;
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;DROP&lt;/span&gt; &lt;span&gt;PROCEDURE&lt;/span&gt; &lt;span&gt;IF&lt;/span&gt; &lt;span&gt;EXISTS&lt;/span&gt; `Record_Innodb_Log_Size`&amp;amp;&amp;amp;
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;PROCEDURE&lt;/span&gt; Record_Innodb_Log_Size()
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;BEGIN&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
      INSERT &lt;span&gt;INTO&lt;/span&gt; mysql.`innodb_log_size_his`
&lt;/pre&gt;
&lt;pre&gt;
      (
&lt;/pre&gt;
&lt;pre&gt;
          log_date,
&lt;/pre&gt;
&lt;pre&gt;
          log_size
&lt;/pre&gt;
&lt;pre&gt;
      )
&lt;/pre&gt;
&lt;pre&gt;
      &lt;span&gt;SELECT&lt;/span&gt; now() &lt;span&gt;AS&lt;/span&gt; log_date,
&lt;/pre&gt;
&lt;pre&gt;
             ROUND(&lt;span&gt;CAST&lt;/span&gt;(VARIABLE_VALUE &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;DOUBLE&lt;/span&gt; )/1024/1024, 1) &lt;span&gt;as&lt;/span&gt; log_size
&lt;/pre&gt;
&lt;pre&gt;
      &lt;span&gt;FROM&lt;/span&gt; information_schema.global_status
&lt;/pre&gt;
&lt;pre&gt;
      &lt;span&gt;WHERE&lt;/span&gt; VARIABLE_NAME = &lt;span&gt;'innodb_os_log_written'&lt;/span&gt;;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;END&lt;/span&gt; &amp;amp;&amp;amp;
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
DELIMITER ;
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
--MySQL 8.0以上版本使用下面脚本
&lt;/pre&gt;
&lt;pre&gt;
DELIMITER &amp;amp;&amp;amp;
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;DROP&lt;/span&gt; &lt;span&gt;PROCEDURE&lt;/span&gt; &lt;span&gt;IF&lt;/span&gt; &lt;span&gt;EXISTS&lt;/span&gt; `Record_Innodb_Log_Size`&amp;amp;&amp;amp;
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;PROCEDURE&lt;/span&gt; Record_Innodb_Log_Size()
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;BEGIN&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
      INSERT &lt;span&gt;INTO&lt;/span&gt; mysql.`innodb_log_size_his`
&lt;/pre&gt;
&lt;pre&gt;
      (
&lt;/pre&gt;
&lt;pre&gt;
          log_date,
&lt;/pre&gt;
&lt;pre&gt;
          log_size
&lt;/pre&gt;
&lt;pre&gt;
      )
&lt;/pre&gt;
&lt;pre&gt;
      &lt;span&gt;SELECT&lt;/span&gt; now() &lt;span&gt;AS&lt;/span&gt; log_date,
&lt;/pre&gt;
&lt;pre&gt;
             ROUND(&lt;span&gt;CAST&lt;/span&gt;(VARIABLE_VALUE &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;DOUBLE&lt;/span&gt; )/1024/1024, 1) &lt;span&gt;as&lt;/span&gt; log_size
&lt;/pre&gt;
&lt;pre&gt;
      &lt;span&gt;FROM&lt;/span&gt; performance_schema.global_status
&lt;/pre&gt;
&lt;pre&gt;
      &lt;span&gt;WHERE&lt;/span&gt; VARIABLE_NAME = &lt;span&gt;'innodb_os_log_written'&lt;/span&gt;;
&lt;/pre&gt;
&lt;pre&gt;
    
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;END&lt;/span&gt; &amp;amp;&amp;amp;
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
DELIMITER ;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;然后创建MySQL的计划任务/事件调度，这个可以根据需求弹性设定。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; readability=&quot;8&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; readability=&quot;11&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; EVENT DPA_BINGLOG_SIZE 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;ON&lt;/span&gt; SCHEDULE &lt;span&gt;EVERY&lt;/span&gt; 10 &lt;span&gt;MINUTE&lt;/span&gt; STARTS &lt;span&gt;'2020-10-16 08:00:00'&lt;/span&gt; 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;ON&lt;/span&gt; &lt;span&gt;COMPLETION&lt;/span&gt; &lt;span&gt;PRESERVE&lt;/span&gt; 
&lt;/pre&gt;
&lt;pre&gt;
DO &lt;span&gt;CALL&lt;/span&gt; mysql.Record_Innodb_Log_Size;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;然后你就可以基于这个表做一些简单的分析和统计了，例如，统计10分钟内生成重做日志生成了多少。如下所示：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; readability=&quot;10&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; readability=&quot;15&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; m.*
&lt;/pre&gt;
&lt;pre&gt;
      ,@lag  &lt;span&gt;AS&lt;/span&gt; last_redo_size
&lt;/pre&gt;
&lt;pre&gt;
      ,ROUND(m.log_size - @lag,2) &lt;span&gt;AS&lt;/span&gt; gen_redo_size
&lt;/pre&gt;
&lt;pre&gt;
      ,@lag:=log_size
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;FROM&lt;/span&gt; mysql.`innodb_log_size_his` m, (&lt;span&gt;SELECT&lt;/span&gt; @lag :=&lt;span&gt;''&lt;/span&gt;) &lt;span&gt;AS&lt;/span&gt; n
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;WHERE&lt;/span&gt; m.log_date &amp;gt;= date_add(now(), &lt;span&gt;interval&lt;/span&gt; -1 &lt;span&gt;day&lt;/span&gt;)
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;ORDER&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt; m.log_id;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/73542/202012/73542-20201225083544048-872912856.png&quot;&gt;&lt;img title=&quot;clip_image001&quot; border=&quot;0&quot; alt=&quot;clip_image001&quot; src=&quot;https://img2020.cnblogs.com/blog/73542/202012/73542-20201225083544600-1193319352.png&quot; width=&quot;696&quot; height=&quot;422&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 25 Dec 2020 00:36:00 +0000</pubDate>
<dc:creator>潇湘隐者</dc:creator>
<og:description>在MySQL中如何计算、统计重做日志（redo log)的生成情况呢？ 例如10分钟内，生成了多少M的redo log呢?30分钟内又生成了多少M的redo log.....。MySQL没有像Orac</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kerrycode/p/14187235.html</dc:identifier>
</item>
<item>
<title>C#中的深度学习（五）：在ML.NET中使用预训练模型进行硬币识别 - 码农译站</title>
<link>http://www.cnblogs.com/hhhnicvscs/p/14187225.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hhhnicvscs/p/14187225.html</guid>
<description>&lt;p&gt;在本系列的最后，我们将介绍另一种方法，即利用一个预先训练好的CNN来解决我们一直在研究的硬币识别问题。&lt;/p&gt;
&lt;p&gt;在这里，我们看一下转移学习，调整预定义的CNN，并使用Model Builder训练我们的硬币识别模型。&lt;/p&gt;
&lt;p&gt;我们将使用ML.NET代替Keras.NET。为什么不使用Keras.NET呢?尽管Keras.NET非常简单，易于学习，虽然它包含前面提到的预定义模型，但它的简单性使我们无法自定义CNN架构来适应我们的问题。&lt;/p&gt;
&lt;p&gt;ML.NET是一个微软的免费机器学习框架，旨在使用C#和F#进行开发。最重要的是，我们可以将ML.NET与Azure结合使用，这意味着我们可以使用基于云的基础设施来训练我们的模型。让多个虚拟机以分布式方式运行我们的代码可以使训练更快、更准确。&lt;/p&gt;
&lt;p&gt;为什么预训练的CNN如此有价值?因为有人花了很多时间和资源培训他们，我们可以利用这一点。我们可以重用嵌入在为网络计算的权值，我们可以将它们重新应用到类似的问题中。也就是说，它们不仅可以应用于CNN最初训练解决的问题。这种方法就被称为迁移学习。它可以为我们节省大量的培训时间，并大大提高所获得的结果。&lt;/p&gt;
&lt;p&gt;在迁移学习中，我们不像以前那样从零开始。相反，我们从一个已知的模型开始，该模型具有预定义的体系结构和在第一次请求模型时下载的计算权重。流行的模型包括Inception、ResNet和VGG16等。&lt;/p&gt;
&lt;p&gt;要针对我们的问题调整预定义的CNN，我们必须做三件事。首先，我们必须将输入层的形状更改为数据集中图像的维度。其次，我们至少需要更改输出层，以便模型拥有与数据集相同数量的类。第三，我们必须调整模型，让它知道我们对训练预定义模型的层不感兴趣。&lt;/p&gt;
&lt;p&gt;完成这些步骤后，我们可以训练或使我们的模型适合于给定的数据集。&lt;/p&gt;
&lt;p&gt;让我们开始吧。在Visual Studio中，转到&lt;strong&gt;Extensions&lt;/strong&gt; &amp;gt; &lt;strong&gt;Manage Extensions&lt;/strong&gt;，浏览&lt;strong&gt;ML.NET Model Builder&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2248030/202012/2248030-20201225082757285-1134362653.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们还需要安装Nuget包ML.NET。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2248030/202012/2248030-20201225082810011-1343448714.png&quot; alt=&quot;&quot; width=&quot;452&quot; height=&quot;58&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了训练我们的模型来解决硬币识别问题，我们将使用 Model Builder 扩展。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2248030/202012/2248030-20201225082840532-2082255805.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用这个工具，我们可以轻松地设置数据集并训练模型，它通过 Model Builder中添加的Auto ML特性自动选择模型。自动机器学习(automatic Machine Learning, Auto ML)是一种自动化机器学习模型开发中的耗时任务。所以Model Builder将为我们简化准备数据集的过程，以及选择预先训练好的模型和所有涉及的参数。关于所选的预训练模型，有一点是只有最后一层会被重新训练;其他所有人都保持权重。&lt;/p&gt;
&lt;p&gt;对于数据集的情况，唯一的要求是将其组织在文件夹中，这样文件夹名就是其中所有图像的类或标签。&lt;/p&gt;
&lt;p&gt;当我们到目前为止使用的硬币数据集被输入到模型构建器中时，AutoML引擎选择ResNet作为预先训练好的架构来用于我们的问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2248030/202012/2248030-20201225082915205-1411817318.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一旦训练结束，我们就可以预测新的输入数据，甚至可以得到与为预测而生成的模型相对应的代码。只需这么少的工作，我们就可以在几乎没有任何相关知识的情况下使用ML，通过UI简单地完成所有工作，选择、单击并在最后获得代码。&lt;/p&gt;
&lt;p&gt;关于使用C#进行硬币识别的系列文章到此结束。希望你喜欢！如果有任何问题，不要忘记留言或发信息。感谢你的阅读。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;欢迎关注我的公众号，如果你有喜欢的外文技术文章，可以通过公众号留言推荐给我。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2248030/202012/2248030-20201225082936825-1260437882.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;原文链接：https://www.codeproject.com/Articles/5284231/Deep-Learning-in-Csharp-Coin-Recognition-with-a-Pr&lt;/p&gt;

</description>
<pubDate>Fri, 25 Dec 2020 00:30:00 +0000</pubDate>
<dc:creator>码农译站</dc:creator>
<og:description>在本系列的最后，我们将介绍另一种方法，即利用一个预先训练好的CNN来解决我们一直在研究的硬币识别问题。 在这里，我们看一下转移学习，调整预定义的CNN，并使用Model Builder训练我们的硬币识</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hhhnicvscs/p/14187225.html</dc:identifier>
</item>
<item>
<title>springboot的jar为何能独立运行 - 程序员欣宸</title>
<link>http://www.cnblogs.com/bolingcavalry/p/14187202.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bolingcavalry/p/14187202.html</guid>
<description>&lt;h3 id=&quot;欢迎访问我的github&quot;&gt;欢迎访问我的GitHub&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot; target=&quot;_blank&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS等；&lt;/p&gt;
&lt;h3 id=&quot;欢迎访问我的github-1&quot;&gt;欢迎访问我的GitHub&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot; target=&quot;_blank&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;br/&gt;内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS等；&lt;/p&gt;
&lt;h3 id=&quot;能独立运行的jar文件&quot;&gt;能独立运行的jar文件&lt;/h3&gt;
&lt;p&gt;在开发springboot应用时，通过&lt;span&gt;java -jar&lt;/span&gt;命令启动应用是常用的方式，今天就来一起了解这个简单操作背后的技术；&lt;/p&gt;
&lt;h3 id=&quot;开发demo&quot;&gt;开发demo&lt;/h3&gt;
&lt;p&gt;开发一个springboot应用作为本次研究的对象，对应的版本信息如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;JDK：1.8.0_211&lt;/li&gt;
&lt;li&gt;springboot：2.3.1.RELEASE&lt;/li&gt;
&lt;li&gt;maven：3.6.0&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;接下来开发springboot应用，这个应用非常简单：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;springboot应用名为&lt;span&gt;springbootstarterdemo&lt;/span&gt;，pom.xml文件内容：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;
    &amp;lt;parent&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;2.3.1.RELEASE&amp;lt;/version&amp;gt;
        &amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt;
    &amp;lt;/parent&amp;gt;
    &amp;lt;groupId&amp;gt;com.bolingcavalry&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;springbootstarterdemo&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;name&amp;gt;springbootstarterdemo&amp;lt;/name&amp;gt;
    &amp;lt;description&amp;gt;Demo project for Spring Boot&amp;lt;/description&amp;gt;
    &amp;lt;properties&amp;gt;
        &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;
    &amp;lt;/properties&amp;gt;
    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;
    &amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;
&amp;lt;/project&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;只有一个java类，里面有个http接口：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.bolingcavalry.springbootstarterdemo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.Date;

@SpringBootApplication
@RestController
public class SpringbootstarterdemoApplication {

    public static void main(String[] args) {
        SpringApplication.run(SpringbootstarterdemoApplication.class, args);
    }
    @RequestMapping(value = &quot;/hello&quot;)
    public String hello(){
        return &quot;hello &quot; + new Date();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;编码完成，在pom.xml所在目录执行命令&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;mvn clean package -U -DskipTests
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;构建成功后，在target目录下得到文件&lt;span&gt;springbootstarterdemo-0.0.1-SNAPSHOT.jar&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;就是这个&lt;span&gt;springbootstarterdemo-0.0.1-SNAPSHOT.jar&lt;/span&gt;，此时执行&lt;span&gt;java -jar springbootstarterdemo-0.0.1-SNAPSHOT.jar&lt;/span&gt;就能启动应用，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201225080520492-624470586.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;接下来就用这个&lt;span&gt;springbootstarterdemo-0.0.1-SNAPSHOT.jar&lt;/span&gt;来分析jar文件能够独立启动的原因；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;java--jar做了什么&quot;&gt;java -jar做了什么&lt;/h3&gt;
&lt;ul readability=&quot;0.96581196581197&quot;&gt;&lt;li readability=&quot;2.8842443729904&quot;&gt;
&lt;p&gt;先要弄清楚&lt;span&gt;java -jar&lt;/span&gt;命令做了什么，在&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html&quot; target=&quot;_blank&quot;&gt;oracle官网&lt;/a&gt;找到了该命令的描述：&lt;br/&gt;&lt;span&gt;&lt;br/&gt;If the -jar option is specified, its argument is the name of the JAR file containing class and resource files for the application. The startup class must be indicated by the Main-Class manifest header in its source code.&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;再次秀出我蹩脚的英文翻译：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;使用&lt;span&gt;-jar&lt;/span&gt;参数时，后面的参数是的jar文件名(本例中是springbootstarterdemo-0.0.1-SNAPSHOT.jar)；&lt;/li&gt;
&lt;li&gt;该jar文件中包含的是class和资源文件；&lt;/li&gt;
&lt;li&gt;在manifest文件中有&lt;span&gt;Main-Class&lt;/span&gt;的定义；&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Main-Class&lt;/span&gt;的源码中指定了整个应用的启动类；(in its source code)&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;小结一下：&lt;br/&gt;&lt;span&gt;java -jar&lt;/span&gt;会去找jar中的manifest文件，在那里面找到真正的启动类；&lt;/p&gt;
&lt;h3 id=&quot;探查springbootstarterdemo-001-snapshotjar&quot;&gt;探查springbootstarterdemo-0.0.1-SNAPSHOT.jar&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;springbootstarterdemo-0.0.1-SNAPSHOT.jar&lt;/span&gt;是前面的springboot工程的构建结果，是个压缩包，用常见的压缩工具就能解压，我这里的环境是MacBook Pro，用unzip即可解压；&lt;/li&gt;
&lt;li&gt;解压后有很多内容，我们先关注manifest相关的，下图红框中就是manifest文件：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201225080520861-705981578.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;打开上图红框中的文件，内容如下：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-properties&quot;&gt;Spring-Boot-Classpath-Index: BOOT-INF/classpath.idx
Implementation-Title: springbootstarterdemo
Implementation-Version: 0.0.1-SNAPSHOT
Start-Class: com.bolingcavalry.springbootstarterdemo.Springbootstarter
 demoApplication
Spring-Boot-Classes: BOOT-INF/classes/
Spring-Boot-Lib: BOOT-INF/lib/
Build-Jdk-Spec: 1.8
Spring-Boot-Version: 2.3.1.RELEASE
Created-By: Maven Jar Plugin 3.2.0
Implementation-Vendor: Pivotal Software, Inc.
Main-Class: org.springframework.boot.loader.JarLauncher
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;在上述内容可见Main-Class的值&lt;span&gt;org.springframework.boot.loader.JarLauncher&lt;/span&gt;，这个和前面的java官方文档对应上了，正是这个JarLauncher类的代码中指定了真正的启动类；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;疑惑出现&quot;&gt;疑惑出现&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;在MANIFEST.MF文件中有这么一行内容：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-properties&quot;&gt;Start-Class: com.bolingcavalry.springbootstarterdemo.Springbootstarter
 demoApplication
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;前面的java官方文档中，只提到过&lt;span&gt;Main-Class&lt;/span&gt; ，并没有提到&lt;span&gt;Start-Class&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;Start-Class的值是SpringbootstarterdemoApplication，这是我们的java代码中的唯一类，也只真正的应用启动类；&lt;/li&gt;
&lt;li&gt;所以问题就来了：理论上看，执行java -jar命令时JarLauncher类会被执行，但实际上是SpringbootstarterdemoApplication被执行了，这其中发生了什么呢？&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;猜测&quot;&gt;猜测&lt;/h3&gt;
&lt;p&gt;动手之前先猜一下，个人觉得原因应该如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;java -jar命令会启动JarLauncher；&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Start-Class&lt;/span&gt;是给JarLauncher用的；&lt;/li&gt;
&lt;li&gt;JarLauncher根据&lt;span&gt;Start-Class&lt;/span&gt;找到了SpringbootstarterdemoApplication，然后执行它；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;分析jarlauncher&quot;&gt;分析JarLauncher&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;先下载SpringBoot源码，我下载的是2.3.1版本，地址：&lt;a href=&quot;https://github.com/spring-projects/spring-boot/releases/tag/v2.3.1.RELEASE&quot; target=&quot;_blank&quot;&gt;https://github.com/spring-projects/spring-boot/releases/tag/v2.3.1.RELEASE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;JarLauncher所在的工程是spring-boot-loader，先弄明白JarLauncher的继承关系，如下图，可见JarLauncher继承自ExecutableArchiveLauncher，而ExecutableArchiveLauncher的父类Launcher位于最顶层，是个抽象类：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201225080521038-971967716.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;3. java -jar执行的是JarLauncher的main方法，如下，会实例化一个JarLauncher对象，然后执行其launch方法，并且将所有入参都带入：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static void main(String[] args) throws Exception {
        new JarLauncher().launch(args);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;上面的launch方法在父类Launcher中：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;protected void launch(String[] args) throws Exception {
    // 将jar解压后运行的方式叫做exploded mode
    // 如果是exploded mode，就不能支持通过URL加载jar
    // 如果不是exploded mode,就可以通过URL加载jar
        if (!isExploded()) {
            // 如果允许通过URL加载jar，就在此注册对应的处理类
                JarFile.registerUrlProtocolHandler();
        }
        // 创建classLoader
        ClassLoader classLoader = createClassLoader(getClassPathArchivesIterator());
        // jarmode是创建docker镜像时用到的参数，使用该参数是为了生成带有多个layer信息的镜像
        // 这里暂时不关注jarmode
        String jarMode = System.getProperty(&quot;jarmode&quot;);
        //如果没有jarmode参数，launchClass的值就来自getMainClass()返回
        String launchClass = (jarMode != null &amp;amp;&amp;amp; !jarMode.isEmpty()) ? JAR_MODE_LAUNCHER : getMainClass();
        launch(args, launchClass, classLoader);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;可见要重点关注的是&lt;span&gt;getMainClass()&lt;/span&gt;方法，在看这个方法之前，我们先去关注一个重要的成员变量&lt;span&gt;archive&lt;/span&gt;，是JarLauncher的父类ExecutableArchiveLauncher的archive，如下可见，该变量又来自方法&lt;span&gt;createArchive&lt;/span&gt;：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public ExecutableArchiveLauncher() {
                try {
                        this.archive = createArchive();
                        this.classPathIndex = getClassPathIndex(this.archive);
                }
                catch (Exception ex) {
                        throw new IllegalStateException(ex);
                }
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;6&quot;&gt;&lt;li&gt;方法来自Launcher.createArchive，如下所示，可见成员变量&lt;span&gt;archive&lt;/span&gt;实际上是个JarFileArchive对象：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;protected final Archive createArchive() throws Exception {
                ProtectionDomain protectionDomain = getClass().getProtectionDomain();
                CodeSource codeSource = protectionDomain.getCodeSource();
                URI location = (codeSource != null) ? codeSource.getLocation().toURI() : null;
                String path = (location != null) ? location.getSchemeSpecificPart() : null;
                if (path == null) {
                        throw new IllegalStateException(&quot;Unable to determine code source archive&quot;);
                }
                File root = new File(path);
                if (!root.exists()) {
                        throw new IllegalStateException(&quot;Unable to determine code source archive from &quot; + root);
                }
                return (root.isDirectory() ? new ExplodedArchive(root) : new JarFileArchive(root));
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;7&quot;&gt;&lt;li&gt;现在回到getMainClass()方法，可见&lt;span&gt;this.archive.getManifest&lt;/span&gt;方法返回的是&lt;span&gt;META-INF/MANIFEST.MF&lt;/span&gt;文件的内容，然后getValue(START_CLASS_ATTRIBUTE)方法实际上就是从META-INF/MANIFEST.MF中取得了Start-Class的属性：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Override
        protected String getMainClass() throws Exception {
            // 对应的是JarFileArchive.getManifest方法，
            // 进去后发现对应的就是JarFile.getManifest方法，
            // JarFile.getManifest对应的就是META-INF/MANIFEST.MF文件的内容
                Manifest manifest = this.archive.getManifest();
                String mainClass = null;
                if (manifest != null) {
                    // 对应的是META-INF/MANIFEST.MF文件中的Start-Class的属性
                        mainClass = manifest.getMainAttributes().getValue(START_CLASS_ATTRIBUTE);
                }
                if (mainClass == null) {
                        throw new IllegalStateException(&quot;No 'Start-Class' manifest entry specified in &quot; + this);
                }
                return mainClass;
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;8&quot;&gt;&lt;li&gt;从上述分析可知：getMainClass()方法返回的是META-INF/MANIFEST.MF中取得了&lt;span&gt;Start-Class&lt;/span&gt;的属性com.bolingcavalry.springbootstarterdemo.SpringbootstarterdemoApplication，再次回到launch方法中，可见最终运行的代码是launch(args, launchClass, classLoader)，它的launchClass参数就是com.bolingcavalry.springbootstarterdemo.SpringbootstarterdemoApplication：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;protected void launch(String[] args) throws Exception {
                if (!isExploded()) {
                        JarFile.registerUrlProtocolHandler();
                }
                ClassLoader classLoader = createClassLoader(getClassPathArchivesIterator());
                String jarMode = System.getProperty(&quot;jarmode&quot;);
                // 这里的launchClass等于&quot;com.bolingcavalry.springbootstarterdemo.SpringbootstarterdemoApplication&quot;
                String launchClass = (jarMode != null &amp;amp;&amp;amp; !jarMode.isEmpty()) ? JAR_MODE_LAUNCHER : getMainClass();
                // 这里就是启动SpringbootstarterdemoApplication的地方
                launch(args, launchClass, classLoader);
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;9&quot;&gt;&lt;li&gt;展开launch(args, launchClass, classLoader)，最终查到了MainMethodRunner类：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class MainMethodRunner {

        private final String mainClassName;

        private final String[] args;

        /**
         * Create a new {@link MainMethodRunner} instance.
         * @param mainClass the main class
         * @param args incoming arguments
         */
        public MainMethodRunner(String mainClass, String[] args) {
            // mainClassName被赋值为&quot;com.bolingcavalry.springbootstarterdemo.SpringbootstarterdemoApplication&quot;
                this.mainClassName = mainClass;
                this.args = (args != null) ? args.clone() : null;
        }

        public void run() throws Exception {
            // 得到SpringbootstarterdemoApplication的Class对象
                Class&amp;lt;?&amp;gt; mainClass = Class.forName(this.mainClassName, false, Thread.currentThread().getContextClassLoader());
                // 得到SpringbootstarterdemoApplication的main方法对象
                Method mainMethod = mainClass.getDeclaredMethod(&quot;main&quot;, String[].class);
                mainMethod.setAccessible(true);
                // 通过反射执行main方法
                mainMethod.invoke(null, new Object[] { this.args });
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;终于，真相大白了；&lt;/p&gt;
&lt;h3 id=&quot;小结&quot;&gt;小结&lt;/h3&gt;
&lt;p&gt;最后尽可能简短做个小结，先看jar是如何产生的，如下图，maven插件生成的jar文件中，有常见的class、jar，也有符合java规范的MANIFEST.MF文件，并且，还在MANIFEST.MF文件中额外生成了名为&lt;span&gt;Start-Class&lt;/span&gt;的配置，这里面是我们编写的应用启动类&lt;span&gt;SpringbootstarterdemoApplication&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201225080521441-1610169076.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;启动类是&lt;span&gt;JarLauncher&lt;/span&gt;，它是如何与MANIFEST.MF文件关联的呢？从下图可以看出，最终是通过JarFile类的成员变量&lt;span&gt;manifestSupplier&lt;/span&gt;关联上的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201225080521891-511653638.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;再来看看关键代码的执行情况，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201225080522494-954278508.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，SpringBoot的jar独立运行的基本原理已经清楚，探究的过程中，除了熟悉关键代码流程，还对jar中的文件有了更多了解，如果您正在学习SpringBoot，希望本文能给您一些参考；&lt;/p&gt;
&lt;h3 id=&quot;官方文档&quot;&gt;官方文档&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;最后附上&lt;a href=&quot;https://docs.spring.io/spring-boot/docs/2.3.1.RELEASE/reference/htmlsingle/#executable-jar-launching&quot; target=&quot;_blank&quot;&gt;SpringBoot官方文档&lt;/a&gt;，可以看到&lt;span&gt;Start-Class&lt;/span&gt;描述信息：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201225080522840-362743251.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;上述文档明确提到：Start-Class定义的是实际的启动类，此时的您应该对一切都了然于胸，产生本该如此的感慨；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;你不孤单，欣宸原创一路相伴&quot;&gt;你不孤单，欣宸原创一路相伴&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105068742&quot; target=&quot;_blank&quot;&gt;Java系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086498&quot; target=&quot;_blank&quot;&gt;Spring系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086732&quot; target=&quot;_blank&quot;&gt;Docker系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086794&quot; target=&quot;_blank&quot;&gt;kubernetes系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086850&quot; target=&quot;_blank&quot;&gt;数据库+中间件系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086920&quot; target=&quot;_blank&quot;&gt;DevOps系列&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;欢迎关注公众号：程序员欣宸&quot;&gt;欢迎关注公众号：程序员欣宸&lt;/h3&gt;
&lt;blockquote readability=&quot;4.258064516129&quot;&gt;
&lt;p&gt;微信搜索「程序员欣宸」，我是欣宸，期待与您一同畅游Java世界...&lt;br/&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot; target=&quot;_blank&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 25 Dec 2020 00:05:00 +0000</pubDate>
<dc:creator>程序员欣宸</dc:creator>
<og:description>欢迎访问我的GitHub https://github.com/zq2599/blog_demos 内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bolingcavalry/p/14187202.html</dc:identifier>
</item>
<item>
<title>C#中烦人的Null值判断竟然这样就被消灭了 - 依乐祝</title>
<link>http://www.cnblogs.com/yilezhu/p/14177595.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yilezhu/p/14177595.html</guid>
<description>&lt;blockquote readability=&quot;3.2884615384615&quot;&gt;
&lt;p&gt;作者：依乐祝&lt;br/&gt;首发自：DotNetCore实战 公众号&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/yilezhu/p/14177595.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/yilezhu/p/14177595.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Null值检查应该算是开发中最常见且烦人的工作了吧，有人反对吗？反对的话请右上角关门不送。这篇文章就教大家一招来简化这个烦人又不可避免的工作。&lt;br/&gt;罗嗦话不多说，先看下面一段简单的不能再简单的null值判断代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public void DoSomething(string message)
{
  if(message == null)
    throw new ArgumentNullException();
    
    // ...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;方法体的每个参数都将用if语句进行检查，并逐个抛出 &lt;code&gt;ArgumentNullException&lt;/code&gt; 的异常。&lt;br/&gt;关注我的朋友，应该看过我上篇《&lt;a href=&quot;https://www.cnblogs.com/yilezhu/p/14174990.html&quot; target=&quot;_blank&quot;&gt;一个小技巧助您减少if语句的状态判断&lt;/a&gt;》的文章，它也是简化Null值判断的一种方式。简化后可以如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;
public void DoSomething(string message)
{
  Assert.That&amp;lt;ArgumentNullException&amp;gt;(message == null, nameof(DoSomething));
    // ...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是还是很差强人意。&lt;br/&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/jpeg/266699/1608693683209-4ad2d9c1-979f-4a09-aee2-ea41f1e93ab4.jpeg#align=left&amp;amp;display=inline&amp;amp;height=333&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;originHeight=333&amp;amp;originWidth=500&amp;amp;size=0&amp;amp;status=done&amp;amp;style=none&amp;amp;width=500&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;**&lt;/p&gt;
&lt;h3 id=&quot;notnullattribute&quot;&gt;NotNullAttribute&lt;/h3&gt;
&lt;p&gt;这里你可能想到了 &lt;code&gt;_System.Diagnostics.CodeAnalysis_&lt;/code&gt; 命名空间下的这个 [NotNull] 特性。这不会在运行时检查任何内容。它只适用于CodeAnalysis，并在编译时而不是在运行时发出警告或错误！&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public void DoSomething([NotNull]string message) // Does not affect anything at runtime.
{
}

public void AnotherMethod()
{
  DoSomething(null); // MsBuild doesn't allow to build.
  string parameter = null;
  DoSomething(parameter); // MsBuild allows build. But nothing happend at runtime.
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;自定义解决方案&quot;&gt;自定义解决方案&lt;/h3&gt;
&lt;p&gt;这里我们将去掉用于Null检查的if语句。如何处理csharp中方法参数的赋值？答案是你不能！. 但你可以使用另一种方法来处理隐式运算符的赋值。让我们创建 &lt;code&gt;NotNull&amp;lt;T&amp;gt;&lt;/code&gt; 类并定义一个隐式运算符，然后我们可以处理赋值。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public class NotNull&amp;lt;T&amp;gt;
{
    public NotNull(T value)
    {
        this.Value = value;
    }

    public T Value { get; set; }

    public static implicit operator NotNull&amp;lt;T&amp;gt;(T value)
    {
        if (value == null)
            throw new ArgumentNullException();
        return new NotNull&amp;lt;T&amp;gt;(value);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在我们可以使用NotNull对象作为方法参数.&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;static void Main(string[] args)
{
  DoSomething(&quot;Hello World!&quot;); // Works perfectly 👌
  
  DoSomething(null); // Throws ArgumentNullException at runtime.
  
  string parameter = null;
  DoSomething(parameter); // Throws ArgumentNullException at runtime.
}

public static void DoSomething(NotNull&amp;lt;string&amp;gt; message) // &amp;lt;--- NotNull is used here
{
    Console.WriteLine(message.Value);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如您所见， &lt;code&gt;DoSomething()&lt;/code&gt; 方法的代码比以前更简洁。也可以将NotNull类与任何类型一起使用，如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public void DoSomething(NotNull&amp;lt;string&amp;gt; message, NotNull&amp;lt;int&amp;gt; id, NotNull&amp;lt;Product&amp;gt; product)
{
  // ...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;感谢您的阅读，我们下篇文章见，我是依乐祝，我为合肥.NET技术社区“带盐”~&lt;br/&gt;参考自：&lt;a href=&quot;https://enisn.medium.com/never-null-check-again-in-c-bd5aae27a48e&quot; target=&quot;_blank&quot;&gt;https://enisn.medium.com/never-null-check-again-in-c-bd5aae27a48e&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 24 Dec 2020 23:45:00 +0000</pubDate>
<dc:creator>依乐祝</dc:creator>
<og:description>作者：依乐祝 首发自：DotNetCore实战 公众号 https://www.cnblogs.com/yilezhu/p/14177595.html Null值检查应该算是开发中最常见且烦人的工作了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yilezhu/p/14177595.html</dc:identifier>
</item>
<item>
<title>【Tomcat】Tomcat服务器核心配置说明及标签 - 邓晓晖</title>
<link>http://www.cnblogs.com/isdxh/p/14187129.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/isdxh/p/14187129.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;首先带着疑问&lt;/p&gt;
&lt;p&gt;问题一：去哪配置?&lt;br/&gt;核心配置在Tomcat目录下 &lt;code&gt;conf/&lt;/code&gt;目录下的&lt;code&gt;server.xml&lt;/code&gt;文件中&lt;/p&gt;
&lt;p&gt;问题二：怎么配置？&lt;/p&gt;
&lt;p&gt;如下&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;Tomcat 作为服务器的配置，主要是 server.xml ⽂件的配置；&lt;/li&gt;
&lt;li&gt;server.xml中包含了 Servlet容器的相关配置，即 Catalina 的配置；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://typora-files.oss-cn-beijing.aliyuncs.com/file/2020-12-24_230624.png&quot; alt=&quot;2020-12-24_230624&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;一，主要标签结构&quot;&gt;一，主要标签结构&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;!--
        Server 根元素，创建⼀个Server实例，⼦标签有 Listener、GlobalNamingResources、Service
--&amp;gt;
&amp;lt;Server&amp;gt;
     &amp;lt;!--定义监听器--&amp;gt;
     &amp;lt;Listener/&amp;gt;
     &amp;lt;!--定义服务器的全局JNDI资源 --&amp;gt;
     &amp;lt;GlobalNamingResources/&amp;gt;
     &amp;lt;!-- 定义⼀个Service服务，⼀个Server标签可以有多个Service服务实例 --&amp;gt;
        &amp;lt;Service/&amp;gt;
&amp;lt;/Server&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;二，server标签&quot;&gt;二，Server标签&lt;/h2&gt;
&lt;h3 id=&quot;标签属性：&quot;&gt;标签属性：&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;port&lt;/li&gt;
&lt;li&gt;shutdown&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;说明Tomcat来监听port端口来执行关闭&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;!--
        port：关闭服务器的监听端⼝
        shutdown：关闭服务器的指令字符串
--&amp;gt;
&amp;lt;Server port=&quot;8005&quot; shutdown=&quot;SHUTDOWN&quot;&amp;gt;
     &amp;lt;!-- 以⽇志形式输出服务器 、操作系统、JVM的版本信息 --&amp;gt;
     &amp;lt;Listener className=&quot;org.apache.catalina.startup.VersionLoggerListener&quot; /&amp;gt;
     &amp;lt;!-- Security listener. Documentation at /docs/config/listeners.html
     &amp;lt;Listener className=&quot;org.apache.catalina.security.SecurityListener&quot; /&amp;gt;
     --&amp;gt;
     &amp;lt;!--APR library loader. Documentation at /docs/apr.html --&amp;gt;
     &amp;lt;!-- 加载（服务器启动） 和 销毁 （服务器停⽌） APR。 如果找不到APR库， 则会输出⽇志， 并不影响 Tomcat启动 --&amp;gt;
     &amp;lt;Listener className=&quot;org.apache.catalina.core.AprLifecycleListener&quot; SSLEngine=&quot;on&quot; /&amp;gt;
     &amp;lt;!-- Prevent memory leaks due to use of particular java/javax APIs--&amp;gt;
     &amp;lt;!-- 避免JRE内存泄漏问题 --&amp;gt;
     &amp;lt;Listener className=&quot;org.apache.catalina.core.JreMemoryLeakPreventionListener&quot; /&amp;gt;
     &amp;lt;!-- 加载（服务器启动） 和 销毁（服务器停⽌） 全局命名服务 --&amp;gt;
     &amp;lt;Listener className=&quot;org.apache.catalina.mbeans.GlobalResourcesLifecycleListener&quot; /&amp;gt;
     &amp;lt;!-- 在Context停⽌时重建 Executor 池中的线程， 以避免ThreadLocal 相关的内存泄漏 --&amp;gt;
     &amp;lt;Listener className=&quot;org.apache.catalina.core.ThreadLocalLeakPreventionListener&quot; /&amp;gt;


     &amp;lt;!-- Global JNDI resources Documentation at /docs/jndi-resources-howto.html 
        GlobalNamingResources 中定义了全局命名服务
     --&amp;gt;
     &amp;lt;GlobalNamingResources&amp;gt;
     &amp;lt;!-- Editable user database that can also be used by
     UserDatabaseRealm to authenticate users
     --&amp;gt;
     &amp;lt;Resource name=&quot;UserDatabase&quot; auth=&quot;Container&quot;
         type=&quot;org.apache.catalina.UserDatabase&quot;
         description=&quot;User database that can be updated and saved&quot;
         factory=&quot;org.apache.catalina.users.MemoryUserDatabaseFactory&quot;
         pathname=&quot;conf/tomcat-users.xml&quot; /&amp;gt;
     &amp;lt;/GlobalNamingResources&amp;gt;
     &amp;lt;!-- A &quot;Service&quot; is a collection of one or more &quot;Connectors&quot; that share
         a single &quot;Container&quot; Note: A &quot;Service&quot; is not itself a &quot;Container&quot;,
         so you may not define subcomponents such as &quot;Valves&quot; at this level.
         Documentation at /docs/config/service.html
     --&amp;gt;
     &amp;lt;Service name=&quot;Catalina&quot;&amp;gt;
         ...
     &amp;lt;/Service&amp;gt;
&amp;lt;/Server&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;子标签：&quot;&gt;子标签：&lt;/h3&gt;
&lt;p&gt;以上标签&lt;code&gt;Listener&lt;/code&gt;、&lt;code&gt;GlobalNamingResources&lt;/code&gt;一般情况下保持默认即可，不需要而外操作，重点在于&lt;strong&gt;Service&lt;/strong&gt; 标签&lt;/p&gt;
&lt;h2 id=&quot;三，service-标签&quot;&gt;三，Service 标签&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;Service name=&quot;Catalina&quot;&amp;gt;
 ...
&amp;lt;/Service&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该标签⽤于创建 Service 实例，默认使⽤ &lt;code&gt;org.apache.catalina.core.StandardService&lt;/code&gt;。 默认情况下，Tomcat 仅指定了Service 的名称， 值为 &quot;&lt;strong&gt;Catalina&lt;/strong&gt;&quot;。&lt;/p&gt;
&lt;h3 id=&quot;子标签：-1&quot;&gt;子标签：&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Listener&lt;/strong&gt; (Listener ⽤于为Service添加⽣命周期监听器)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Executor&lt;/strong&gt; (⽤于配置Service 共享线程池，给Connector使用)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Connector&lt;/strong&gt; （⽤于配置Service 包含的链接器）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Engine&lt;/strong&gt; （⽤于配置Service中链接器对应的Servlet 容器引擎）&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;四，executor-标签&quot;&gt;四，Executor 标签&lt;/h2&gt;
&lt;p&gt;用来定义共享线程池的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://typora-files.oss-cn-beijing.aliyuncs.com/file/image-20201224233733864.png&quot; alt=&quot;image-20201224233733864&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;默认是被注释掉的，且属性不全。那么该如何使用呢?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;默认情况下，Service 并未添加共享线程池配置。 如果我们想添加⼀个线程池， 可以在下添加如下配置：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;Executor name=&quot;commonThreadPool&quot;
        namePrefix=&quot;thread-exec-&quot;
        maxThreads=&quot;200&quot;
        minSpareThreads=&quot;100&quot;
        maxIdleTime=&quot;60000&quot;
        maxQueueSize=&quot;Integer.MAX_VALUE&quot;
        prestartminSpareThreads=&quot;false&quot;
        threadPriority=&quot;5&quot;
        className=&quot;org.apache.catalina.core.StandardThreadExecutor&quot;/&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;属性：&quot;&gt;属性：&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;name&lt;/strong&gt;：线程池名称，&lt;strong&gt;⽤于 Connector中指定&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;namePrefix&lt;/strong&gt;：所创建的每个线程的名称前缀，⼀个单独的线程名称为 namePrefix+threadNumber&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;maxThreads&lt;/strong&gt;：池中最⼤线程数&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;minSpareThreads&lt;/strong&gt;：活跃线程数，也就是核⼼池线程数，这些线程不会被销毁，会⼀直存在&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;maxIdleTime&lt;/strong&gt;：线程空闲时间，超过该时间后，空闲线程会被销毁，默认值为6000（1分钟），单位 毫秒&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;maxQueueSize&lt;/strong&gt;：在被执⾏前最⼤线程排队数⽬，默认为Int的最⼤值，也就是⼴义的⽆限。除⾮特殊情况，这个值不需要更改，否则会有请求不会被处理的情况发⽣&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;prestartminSpareThreads&lt;/strong&gt;：启动线程池时是否启动 &lt;strong&gt;minSpareThreads&lt;/strong&gt;部分线程。默认值为 &lt;strong&gt;false&lt;/strong&gt;，即不启动&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;threadPriority&lt;/strong&gt;：线程池中线程优先级，默认值为5，值从1到10&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;className&lt;/strong&gt;：线程池实现类，未指定情况下，默认实现类为：&lt;br/&gt;&lt;code&gt;org.apache.catalina.core.StandardThreadExecutor&lt;/code&gt;。如果想使⽤⾃定义线程池⾸先需要实现 &lt;code&gt;org.apache.catalina.Executor&lt;/code&gt;接⼝&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;五，connector标签&quot;&gt;五，Connector标签&lt;/h2&gt;
&lt;p&gt;Connector 标签⽤于创建链接器实例默认情况下，&lt;code&gt;server.xml&lt;/code&gt;配置了两个链接器，⼀个⽀持&lt;strong&gt;HTTP协议&lt;/strong&gt;，⼀个⽀持&lt;strong&gt;AJP协议&lt;/strong&gt;，⼤多数情况下，我们并不需要新增链接器配置，只是根据需要对已有链接器进⾏优化。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;!--org.apache.coyote.http11.Http11NioProtocol ， ⾮阻塞式 Java NIO 链接器--&amp;gt;
&amp;lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&amp;gt;
&amp;lt;Connector port=&quot;8009&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;属性：-1&quot;&gt;属性：&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;port&lt;/strong&gt;：端⼝号，Connector ⽤于创建服务端Socket 并进⾏监听， 以等待客户端请求链接。如果该属性设置 为0， Tomcat将会随机选择⼀个可⽤的端⼝号给当前Connector 使⽤&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;protocol&lt;/strong&gt;：当前Connector ⽀持的访问协议。 默认为 HTTP/1.1 ， 并采⽤⾃动切换机制选择⼀个基于 JAVA NIO 的链接器或者基于本地APR的链接器（根据本地是否含有Tomcat的本地库判定）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;connectionTimeOut&lt;/strong&gt;: Connector接收链接后的等待超时时间， 单位为毫秒。 -1 表示不超时。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;redirectPort&lt;/strong&gt;： 当前Connector 不⽀持SSL请求， 接收到了⼀个请求， 并且也符合security-constraint 约束， 需要SSL传输，Catalina⾃动将请求重定向到指定的端⼝。&lt;strong&gt;比如说：如果访问的是8080端口，然后它发现是一个https的请求，那么他就会转发到8443端口&lt;/strong&gt;，当然也可以直接访问8443端口&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;executor&lt;/strong&gt;： 指定共享线程池的名称(&lt;strong&gt;就是Executor标签的name属性&lt;/strong&gt;)， 也可以通过&lt;code&gt;maxThreads&lt;/code&gt;、&lt;code&gt;minSpareThreads&lt;/code&gt;等属性配置内部线程池。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;URIEncoding&lt;/strong&gt;: ⽤于指定编码URI的字符编码， &lt;strong&gt;Tomcat8.x版本默认的编码为 UTF-8&lt;/strong&gt; , &lt;strong&gt;Tomcat7.x版本默认为ISO8859-1&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;可以使用共享线程池：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;Connector port=&quot;8080&quot;
     protocol=&quot;HTTP/1.1&quot;
     executor=&quot;commonThreadPool&quot;
     maxThreads=&quot;1000&quot;          
     minSpareThreads=&quot;100&quot;
     acceptCount=&quot;1000&quot; //往往和maxThreads保持一致
     maxConnections=&quot;1000&quot; //往往和maxThreads保持一致
     connectionTimeout=&quot;20000&quot;
     compression=&quot;on&quot;   //要不要启动gzip压缩
     compressionMinSize=&quot;2048&quot; //压缩处理的最小大小，超过此大小才压缩
     disableUploadTimeout=&quot;true&quot; //单独的给servlet放宽超时时间
     redirectPort=&quot;8443&quot;
     URIEncoding=&quot;UTF-8&quot; /&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;可以看到&lt;code&gt;Connector&lt;/code&gt;标签和&lt;code&gt;Executor&lt;/code&gt;都有&lt;code&gt;maxThreads&lt;/code&gt;和&lt;code&gt;minSpareThreads&lt;/code&gt;标签。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;每一个Connector都可以自己定义一个线程池，如果每个Connector都自己定义线程池就浪费了。所以为什么不用一个呢？于是就有了Executor标签来定义一个共享线程池。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;六，engine标签&quot;&gt;六，Engine标签&lt;/h2&gt;
&lt;p&gt;Engine 表示 Servlet 引擎&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;Engine name=&quot;Catalina&quot; defaultHost=&quot;localhost&quot;&amp;gt;
 ...
&amp;lt;/Engine&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;属性：-2&quot;&gt;属性：&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;name&lt;/strong&gt;：⽤于指定Engine 的名称， 默认为Catalina&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;defaultHost&lt;/strong&gt;：默认使⽤的虚拟主机名称， 当客户端请求指向的主机⽆效时， 将交由默认的虚拟主机处理， 默认为localhost&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://typora-files.oss-cn-beijing.aliyuncs.com/file/image-20201225005456558.png&quot; alt=&quot;image-20201225005456558&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;子标签：-2&quot;&gt;子标签：&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Cluster&lt;/strong&gt;：集群方面的标签&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Realm&lt;/strong&gt;：验证安全的标签&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Host&lt;/strong&gt;：⽤于配置⼀个虚拟主机&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;七，host标签&quot;&gt;七，Host标签&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;Host name=&quot;localhost&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&amp;gt;
 ...
&amp;lt;/Host&amp;gt; 
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;标签属性：-1&quot;&gt;标签属性：&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;appBase&lt;/strong&gt;：这个网站的程序存放的位置，可以是绝对路径也可以是相对路径。webapps就是相对路径，在tomcat的根目录下&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;unpackWARs&lt;/strong&gt;：默认为true，把war包解压成文件夹&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;autoDeploy&lt;/strong&gt;：自动部署，当资源变更时自动部署，类似于热部署&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;子标签：-3&quot;&gt;子标签：&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;Valve className=&quot;org.apache.catalina.valves.AccessLogValve&quot; directory=&quot;logs&quot;
               prefix=&quot;localhost_access_log&quot; suffix=&quot;.txt&quot;
               pattern=&quot;%h %l %u %t &amp;amp;quot;%r&amp;amp;quot; %s %b&quot; /&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当请求来临时，日志存放起来，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;存放在&lt;code&gt;directory&lt;/code&gt;值的目录&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;prefix&lt;/strong&gt;：日志文件前缀&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;suffix&lt;/strong&gt;：日志文件后缀&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;pattern&lt;/strong&gt;：打印的日志格式&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;启动tomcat-浏览器输入：httplocalhost8080&quot;&gt;启动Tomcat 浏览器输入：&lt;a href=&quot;http://localhost:8080&quot; target=&quot;_blank&quot;&gt;http://localhost:8080&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://typora-files.oss-cn-beijing.aliyuncs.com/file/image-20201225011255980.png&quot; alt=&quot;image-20201225011255980&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://typora-files.oss-cn-beijing.aliyuncs.com/file/image-20201225011309987.png&quot; alt=&quot;image-20201225011309987&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;Host name=&quot;localhost&quot;  appBase=&quot;webapps&quot;
            unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;hostname是&lt;strong&gt;localhost&lt;/strong&gt;，appBase是&lt;strong&gt;webapps&lt;/strong&gt;，去&lt;strong&gt;webapps&lt;/strong&gt;文件夹下找应用程序文件夹，没有指定，默认就去ROOT文件夹下：&lt;br/&gt;&lt;img src=&quot;https://typora-files.oss-cn-beijing.aliyuncs.com/file/image-20201225011532363.png&quot; alt=&quot;image-20201225011532363&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;我们来做个实验：&quot;&gt;我们来做个实验：&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;把host标签复制一份，两个host标签的name分别为&lt;code&gt;www.abc.com&lt;/code&gt;，&lt;code&gt;www.def.com&lt;/code&gt;。appBase分别为&lt;code&gt;webapps&lt;/code&gt;、&lt;code&gt;webapps2&lt;/code&gt;&lt;br/&gt;&lt;img src=&quot;https://typora-files.oss-cn-beijing.aliyuncs.com/file/image-20201225012119802.png&quot; alt=&quot;image-20201225012119802&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;进入Tomcat根目录，把webapps拷贝一份到根目录，命名为webapps2&lt;br/&gt;&lt;img src=&quot;https://typora-files.oss-cn-beijing.aliyuncs.com/file/image-20201225012241881.png&quot; alt=&quot;image-20201225012241881&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;为了方便区分，把webapps2/ROOT/index.jsp 中的&lt;strong&gt;Home&lt;/strong&gt;改为&lt;strong&gt;Home-webapps2&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://typora-files.oss-cn-beijing.aliyuncs.com/file/image-20201225012344132.png&quot; alt=&quot;image-20201225012344132&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;重新启动Tomcat&lt;/li&gt;
&lt;li&gt;配置hosts文件&lt;br/&gt;&lt;img src=&quot;https://typora-files.oss-cn-beijing.aliyuncs.com/file/image-20201225012858171.png&quot; alt=&quot;image-20201225012858171&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;访问浏览器http://localhost:8080、 &lt;a href=&quot;http://www.abc.xn--comhttp-bs4l&quot; target=&quot;_blank&quot;&gt;http://www.abc.com和http&lt;/a&gt;😕/www.def.com&lt;/li&gt;
&lt;li&gt;可以看到：&lt;br/&gt;&lt;img src=&quot;https://typora-files.oss-cn-beijing.aliyuncs.com/file/image-20201225013221920.png&quot; alt=&quot;image-20201225013221920&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;可以看到localhost:8080访问不到了，因为这个虚拟主机被我们修改了&lt;/p&gt;
&lt;p&gt;而abc和def均可以找到。同时def.com的Home也被修改为Home-webapps2了。&lt;/p&gt;
&lt;h2 id=&quot;八，context标签&quot;&gt;八，Context标签&lt;/h2&gt;
&lt;p&gt;用于配置一个Web应用——&lt;strong&gt;一个虚拟主机下可以配置多个应用&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;Host name=&quot;www.abc.com&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot;
autoDeploy=&quot;true&quot;&amp;gt;
&amp;lt;!--
 docBase：Web应⽤⽬录或者War包的部署路径。可以是绝对路径，也可以是相对于 Host appBase的
相对路径。
 path：Web应⽤的Context 路径。如果我们Host名为localhost， 则该web应⽤访问的根路径为：
 http://localhost:8080/web_demo。
--&amp;gt;
 &amp;lt;Context docBase=&quot;E://dengxhh&quot; path=&quot;/dengxh&quot;&amp;gt;&amp;lt;/Context&amp;gt;

 &amp;lt;Valve className=&quot;org.apache.catalina.valves.AccessLogValve&quot;
directory=&quot;logs&quot;
 prefix=&quot;localhost_access_log&quot; suffix=&quot;.txt&quot;
 pattern=&quot;%h %l %u %t &amp;amp;quot;%r&amp;amp;quot; %s %b&quot; /&amp;gt;
&amp;lt;/Host&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;刚才我们访问的是&lt;code&gt;http://www.abc.com:8080&lt;/code&gt;，那么现在我想输入&lt;code&gt;http://www.abc.com:8080/dengxh&lt;/code&gt;，&lt;strong&gt;dengxh&lt;/strong&gt;所代表的位置是我的磁盘上的某个文件夹，这个文件夹里放的我的程序资源。如何做？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;为了方便演示，我们就拿ROOT中的程序做例子，把&lt;strong&gt;webapps中的ROOT文件夹复制到E盘根目录&lt;/strong&gt;，&lt;strong&gt;取名为dengxhh&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在Host标签中，增加 &lt;code&gt;&amp;lt;Context docBase=&quot;E://dengxhh&quot; path=&quot;/dengxh&quot;&amp;gt;&amp;lt;/Context&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;重启Tomcat，访问www.abc.com/dengxh/ ，成功跳转了。&lt;br/&gt;&lt;img src=&quot;https://typora-files.oss-cn-beijing.aliyuncs.com/file/image-20201225014648017.png&quot; alt=&quot;image-20201225014648017&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如此操作就可以在一个虚拟主机中，配置多个应用，只需要在host标签中配置多个Context标签，区分的时候只需要在虚拟主机后跟上Context的path属性的值即可找到对应的资源。&lt;br/&gt;例如：Host name=&quot;www.abc.com&quot; ，Context path =&quot;dengxh&quot; ，那么浏览器中输入 &lt;code&gt;www.abc.com/dengxh&lt;/code&gt;即可。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;总结：&quot;&gt;总结：&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://typora-files.oss-cn-beijing.aliyuncs.com/file/image-20201225021451534.png&quot; alt=&quot;image-20201225021451534&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://typora-files.oss-cn-beijing.aliyuncs.com/file/image-20201225021557645.png&quot; alt=&quot;image-20201225021557645&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;思维导图在线观看地址：&lt;/strong&gt;&lt;a href=&quot;https://www.processon.com/view/link/5fe4da565653bb054783ca6e&quot; target=&quot;_blank&quot;&gt;https://www.processon.com/view/link/5fe4da565653bb054783ca6e&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 24 Dec 2020 18:19:00 +0000</pubDate>
<dc:creator>邓晓晖</dc:creator>
<og:description>首先带着疑问 问题一：去哪配置? 核心配置在Tomcat目录下 conf/目录下的server.xml文件中 问题二：怎么配置？ 如下 Tomcat 作为服务器的配置，主要是 server.xml ⽂</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/isdxh/p/14187129.html</dc:identifier>
</item>
<item>
<title>SpringCloud 源码系列（5）—— 负载均衡 Ribbon（下） - bojiangzhou</title>
<link>http://www.cnblogs.com/chiangchou/p/ribbon-2.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chiangchou/p/ribbon-2.html</guid>
<description>&lt;p&gt;Ribbon 负载均衡核心接口、Ribbon HTTP客户端组件，定制化使得 RestTemplate 可以使用 Apache httpclient 或 Okhttp，还介绍了 Ribbon 的请求重试和 RetryTemplate 的请求重试。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;660.76399635867&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/chiangchou/p/ribbon-1.html&quot; target=&quot;_blank&quot;&gt;SpringCloud 源码系列（4）—— 负载均衡 Ribbon（上）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/chiangchou/p/ribbon-2.html&quot; target=&quot;_blank&quot;&gt;SpringCloud 源码系列（5）—— 负载均衡 Ribbon（下）&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;五、Ribbon 核心接口&lt;/h2&gt;
&lt;p&gt;前面已经了解到 Ribbon 核心接口以及默认实现如何协作来查找要调用的一个实例，这节再来看下各个核心接口的一些特性及其它实现类。&lt;/p&gt;
&lt;h3&gt;1、客户端配置 — IClientConfig&lt;/h3&gt;
&lt;p&gt;IClientConfig 就是管理客户端配置的核心接口，它的默认实现类是 DefaultClientConfigImpl。可以看到在创建 IClientConfig 时，设置了 Ribbon 客户端默认的连接和读取超时时间为 1 秒，例如读取如果超过1秒，就会返回超时，这两个一般需要根据实际情况来调整。、&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Bean
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;@ConditionalOnMissingBean
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; IClientConfig ribbonClientConfig() {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     DefaultClientConfigImpl config = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultClientConfigImpl();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 加载配置&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     config.loadProperties(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 连接超时默认 1 秒&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    config.set(CommonClientConfigKey.ConnectTimeout, DEFAULT_CONNECT_TIMEOUT);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 读取超时默认 1 秒&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    config.set(CommonClientConfigKey.ReadTimeout, DEFAULT_READ_TIMEOUT);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    config.set(CommonClientConfigKey.GZipPayload, DEFAULT_GZIP_PAYLOAD);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; config;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;CommonClientConfigKey 这个类定义了 Ribbon 客户端相关的所有配置的键常量，可以通过这个类来看有哪些配置。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_17526302-0291-42be-9704-594e414fbe35&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_17526302-0291-42be-9704-594e414fbe35&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_17526302-0291-42be-9704-594e414fbe35&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CommonClientConfigKey&amp;lt;T&amp;gt; &lt;span&gt;implements&lt;/span&gt; IClientConfigKey&amp;lt;T&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; 
&lt;span&gt;  3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;String&amp;gt; AppName = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;String&amp;gt;(&quot;AppName&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; 
&lt;span&gt;  5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;String&amp;gt; Version = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;String&amp;gt;(&quot;Version&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; 
&lt;span&gt;  7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Integer&amp;gt; Port = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Integer&amp;gt;(&quot;Port&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; 
&lt;span&gt;  9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Integer&amp;gt; SecurePort = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Integer&amp;gt;(&quot;SecurePort&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt; 
&lt;span&gt; 11&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;String&amp;gt; VipAddress = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;String&amp;gt;(&quot;VipAddress&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; 
&lt;span&gt; 13&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Boolean&amp;gt; ForceClientPortConfiguration = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Boolean&amp;gt;(&quot;ForceClientPortConfiguration&quot;){}; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; use client defined port regardless of server advert&lt;/span&gt;
&lt;span&gt; 14&lt;/span&gt; 
&lt;span&gt; 15&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;String&amp;gt; DeploymentContextBasedVipAddresses = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;String&amp;gt;(&quot;DeploymentContextBasedVipAddresses&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt; 
&lt;span&gt; 17&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Integer&amp;gt; MaxAutoRetries = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Integer&amp;gt;(&quot;MaxAutoRetries&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt; 
&lt;span&gt; 19&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Integer&amp;gt; MaxAutoRetriesNextServer = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Integer&amp;gt;(&quot;MaxAutoRetriesNextServer&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; 
&lt;span&gt; 21&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Boolean&amp;gt; OkToRetryOnAllOperations = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Boolean&amp;gt;(&quot;OkToRetryOnAllOperations&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt; 
&lt;span&gt; 23&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Boolean&amp;gt; RequestSpecificRetryOn = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Boolean&amp;gt;(&quot;RequestSpecificRetryOn&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt; 
&lt;span&gt; 25&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Integer&amp;gt; ReceiveBufferSize = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Integer&amp;gt;(&quot;ReceiveBufferSize&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt; 
&lt;span&gt; 27&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Boolean&amp;gt; EnablePrimeConnections = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Boolean&amp;gt;(&quot;EnablePrimeConnections&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt; 
&lt;span&gt; 29&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;String&amp;gt; PrimeConnectionsClassName = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;String&amp;gt;(&quot;PrimeConnectionsClassName&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt; 
&lt;span&gt; 31&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Integer&amp;gt; MaxRetriesPerServerPrimeConnection = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Integer&amp;gt;(&quot;MaxRetriesPerServerPrimeConnection&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt; 
&lt;span&gt; 33&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Integer&amp;gt; MaxTotalTimeToPrimeConnections = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Integer&amp;gt;(&quot;MaxTotalTimeToPrimeConnections&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt; 
&lt;span&gt; 35&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Float&amp;gt; MinPrimeConnectionsRatio = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Float&amp;gt;(&quot;MinPrimeConnectionsRatio&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt; 
&lt;span&gt; 37&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;String&amp;gt; PrimeConnectionsURI = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;String&amp;gt;(&quot;PrimeConnectionsURI&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt; 
&lt;span&gt; 39&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Integer&amp;gt; PoolMaxThreads = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Integer&amp;gt;(&quot;PoolMaxThreads&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt; 
&lt;span&gt; 41&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Integer&amp;gt; PoolMinThreads = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Integer&amp;gt;(&quot;PoolMinThreads&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt; 
&lt;span&gt; 43&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Integer&amp;gt; PoolKeepAliveTime = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Integer&amp;gt;(&quot;PoolKeepAliveTime&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt; 
&lt;span&gt; 45&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;String&amp;gt; PoolKeepAliveTimeUnits = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;String&amp;gt;(&quot;PoolKeepAliveTimeUnits&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt; 
&lt;span&gt; 47&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Boolean&amp;gt; EnableConnectionPool = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Boolean&amp;gt;(&quot;EnableConnectionPool&quot;&lt;span&gt;) {};
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt; 
&lt;span&gt; 49&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 50&lt;/span&gt; &lt;span&gt;     * Use {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #MaxConnectionsPerHost}
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 52&lt;/span&gt; &lt;span&gt;    @Deprecated
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Integer&amp;gt; MaxHttpConnectionsPerHost = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Integer&amp;gt;(&quot;MaxHttpConnectionsPerHost&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt; 
&lt;span&gt; 55&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 56&lt;/span&gt; &lt;span&gt;     * Use {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #MaxTotalConnections}
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 58&lt;/span&gt; &lt;span&gt;    @Deprecated
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Integer&amp;gt; MaxTotalHttpConnections = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Integer&amp;gt;(&quot;MaxTotalHttpConnections&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt; 
&lt;span&gt; 61&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Integer&amp;gt; MaxConnectionsPerHost = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Integer&amp;gt;(&quot;MaxConnectionsPerHost&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt; 
&lt;span&gt; 63&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Integer&amp;gt; MaxTotalConnections = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Integer&amp;gt;(&quot;MaxTotalConnections&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt; 
&lt;span&gt; 65&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Boolean&amp;gt; IsSecure = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Boolean&amp;gt;(&quot;IsSecure&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; 
&lt;span&gt; 67&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Boolean&amp;gt; GZipPayload = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Boolean&amp;gt;(&quot;GZipPayload&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt; 
&lt;span&gt; 69&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Integer&amp;gt; ConnectTimeout = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Integer&amp;gt;(&quot;ConnectTimeout&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt; 
&lt;span&gt; 71&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Integer&amp;gt; BackoffInterval = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Integer&amp;gt;(&quot;BackoffTimeout&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt; 
&lt;span&gt; 73&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Integer&amp;gt; ReadTimeout = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Integer&amp;gt;(&quot;ReadTimeout&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt; 
&lt;span&gt; 75&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Integer&amp;gt; SendBufferSize = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Integer&amp;gt;(&quot;SendBufferSize&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt; 
&lt;span&gt; 77&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Boolean&amp;gt; StaleCheckingEnabled = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Boolean&amp;gt;(&quot;StaleCheckingEnabled&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt; 
&lt;span&gt; 79&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Integer&amp;gt; Linger = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Integer&amp;gt;(&quot;Linger&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt; 
&lt;span&gt; 81&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Integer&amp;gt; ConnectionManagerTimeout = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Integer&amp;gt;(&quot;ConnectionManagerTimeout&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt; 
&lt;span&gt; 83&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Boolean&amp;gt; FollowRedirects = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Boolean&amp;gt;(&quot;FollowRedirects&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt; 
&lt;span&gt; 85&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Boolean&amp;gt; ConnectionPoolCleanerTaskEnabled = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Boolean&amp;gt;(&quot;ConnectionPoolCleanerTaskEnabled&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt; 
&lt;span&gt; 87&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Integer&amp;gt; ConnIdleEvictTimeMilliSeconds = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Integer&amp;gt;(&quot;ConnIdleEvictTimeMilliSeconds&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt; 
&lt;span&gt; 89&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Integer&amp;gt; ConnectionCleanerRepeatInterval = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Integer&amp;gt;(&quot;ConnectionCleanerRepeatInterval&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt; 
&lt;span&gt; 91&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Boolean&amp;gt; EnableGZIPContentEncodingFilter = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Boolean&amp;gt;(&quot;EnableGZIPContentEncodingFilter&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt; 
&lt;span&gt; 93&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;String&amp;gt; ProxyHost = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;String&amp;gt;(&quot;ProxyHost&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt; 
&lt;span&gt; 95&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Integer&amp;gt; ProxyPort = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Integer&amp;gt;(&quot;ProxyPort&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt; 
&lt;span&gt; 97&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;String&amp;gt; KeyStore = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;String&amp;gt;(&quot;KeyStore&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt; 
&lt;span&gt; 99&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;String&amp;gt; KeyStorePassword = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;String&amp;gt;(&quot;KeyStorePassword&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; 
&lt;span&gt;101&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;String&amp;gt; TrustStore = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;String&amp;gt;(&quot;TrustStore&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt; 
&lt;span&gt;103&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;String&amp;gt; TrustStorePassword = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;String&amp;gt;(&quot;TrustStorePassword&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt; 
&lt;span&gt;105&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; if this is a secure rest client, must we use client auth too?&lt;/span&gt;
&lt;span&gt;106&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Boolean&amp;gt; IsClientAuthRequired = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Boolean&amp;gt;(&quot;IsClientAuthRequired&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt; 
&lt;span&gt;108&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;String&amp;gt; CustomSSLSocketFactoryClassName = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;String&amp;gt;(&quot;CustomSSLSocketFactoryClassName&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; must host name match name in certificate?&lt;/span&gt;
&lt;span&gt;110&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Boolean&amp;gt; IsHostnameValidationRequired = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Boolean&amp;gt;(&quot;IsHostnameValidationRequired&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt; 
&lt;span&gt;112&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; see also &lt;/span&gt;&lt;span&gt;http://hc.apache.org/httpcomponents-client-ga/tutorial/html/advanced.html&lt;/span&gt;
&lt;span&gt;113&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Boolean&amp;gt; IgnoreUserTokenInConnectionPoolForSecureClient = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Boolean&amp;gt;(&quot;IgnoreUserTokenInConnectionPoolForSecureClient&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt; 
&lt;span&gt;115&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Client implementation&lt;/span&gt;
&lt;span&gt;116&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;String&amp;gt; ClientClassName = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;String&amp;gt;(&quot;ClientClassName&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt; 
&lt;span&gt;118&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;LoadBalancer Related&lt;/span&gt;
&lt;span&gt;119&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Boolean&amp;gt; InitializeNFLoadBalancer = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Boolean&amp;gt;(&quot;InitializeNFLoadBalancer&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt; 
&lt;span&gt;121&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;String&amp;gt; NFLoadBalancerClassName = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;String&amp;gt;(&quot;NFLoadBalancerClassName&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt; 
&lt;span&gt;123&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;String&amp;gt; NFLoadBalancerRuleClassName = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;String&amp;gt;(&quot;NFLoadBalancerRuleClassName&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt; 
&lt;span&gt;125&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;String&amp;gt; NFLoadBalancerPingClassName = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;String&amp;gt;(&quot;NFLoadBalancerPingClassName&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt; 
&lt;span&gt;127&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Integer&amp;gt; NFLoadBalancerPingInterval = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Integer&amp;gt;(&quot;NFLoadBalancerPingInterval&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt;128&lt;/span&gt; 
&lt;span&gt;129&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Integer&amp;gt; NFLoadBalancerMaxTotalPingTime = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Integer&amp;gt;(&quot;NFLoadBalancerMaxTotalPingTime&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt; 
&lt;span&gt;131&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;String&amp;gt; NFLoadBalancerStatsClassName = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;String&amp;gt;(&quot;NFLoadBalancerStatsClassName&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt; 
&lt;span&gt;133&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;String&amp;gt; NIWSServerListClassName = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;String&amp;gt;(&quot;NIWSServerListClassName&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt;134&lt;/span&gt; 
&lt;span&gt;135&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;String&amp;gt; ServerListUpdaterClassName = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;String&amp;gt;(&quot;ServerListUpdaterClassName&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt; 
&lt;span&gt;137&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;String&amp;gt; NIWSServerListFilterClassName = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;String&amp;gt;(&quot;NIWSServerListFilterClassName&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt;138&lt;/span&gt; 
&lt;span&gt;139&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Integer&amp;gt; ServerListRefreshInterval = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Integer&amp;gt;(&quot;ServerListRefreshInterval&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt;140&lt;/span&gt; 
&lt;span&gt;141&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Boolean&amp;gt; EnableMarkingServerDownOnReachingFailureLimit = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Boolean&amp;gt;(&quot;EnableMarkingServerDownOnReachingFailureLimit&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt;142&lt;/span&gt; 
&lt;span&gt;143&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Integer&amp;gt; ServerDownFailureLimit = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Integer&amp;gt;(&quot;ServerDownFailureLimit&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt;144&lt;/span&gt; 
&lt;span&gt;145&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Integer&amp;gt; ServerDownStatWindowInMillis = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Integer&amp;gt;(&quot;ServerDownStatWindowInMillis&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt;146&lt;/span&gt; 
&lt;span&gt;147&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Boolean&amp;gt; EnableZoneAffinity = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Boolean&amp;gt;(&quot;EnableZoneAffinity&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt;148&lt;/span&gt; 
&lt;span&gt;149&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Boolean&amp;gt; EnableZoneExclusivity = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Boolean&amp;gt;(&quot;EnableZoneExclusivity&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt;150&lt;/span&gt; 
&lt;span&gt;151&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Boolean&amp;gt; PrioritizeVipAddressBasedServers = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Boolean&amp;gt;(&quot;PrioritizeVipAddressBasedServers&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt;152&lt;/span&gt; 
&lt;span&gt;153&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;String&amp;gt; VipAddressResolverClassName = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;String&amp;gt;(&quot;VipAddressResolverClassName&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt;154&lt;/span&gt; 
&lt;span&gt;155&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;String&amp;gt; TargetRegion = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;String&amp;gt;(&quot;TargetRegion&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt;156&lt;/span&gt; 
&lt;span&gt;157&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;String&amp;gt; RulePredicateClasses = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;String&amp;gt;(&quot;RulePredicateClasses&quot;&lt;span&gt;){};
&lt;/span&gt;&lt;span&gt;158&lt;/span&gt; 
&lt;span&gt;159&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;String&amp;gt; RequestIdHeaderName = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;String&amp;gt;(&quot;RequestIdHeaderName&quot;&lt;span&gt;) {};
&lt;/span&gt;&lt;span&gt;160&lt;/span&gt; 
&lt;span&gt;161&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;Boolean&amp;gt; UseIPAddrForServer = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;Boolean&amp;gt;(&quot;UseIPAddrForServer&quot;&lt;span&gt;) {};
&lt;/span&gt;&lt;span&gt;162&lt;/span&gt; 
&lt;span&gt;163&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IClientConfigKey&amp;lt;String&amp;gt; ListOfServers = &lt;span&gt;new&lt;/span&gt; CommonClientConfigKey&amp;lt;String&amp;gt;(&quot;listOfServers&quot;&lt;span&gt;) {};
&lt;/span&gt;&lt;span&gt;164&lt;/span&gt; 
&lt;span&gt;165&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Set&amp;lt;IClientConfigKey&amp;gt; keys = &lt;span&gt;new&lt;/span&gt; HashSet&amp;lt;IClientConfigKey&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;166&lt;/span&gt; 
&lt;span&gt;167&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;168&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;进入到 DefaultClientConfigImpl，可以看到 CommonClientConfigKey 中的每个配置都对应了一个默认值。在加载配置的时候，如果用户没有定制配置，就会使用默认的配置。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;57&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_941afa48-85fe-4606-8815-aa208d54b410&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_941afa48-85fe-4606-8815-aa208d54b410&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_941afa48-85fe-4606-8815-aa208d54b410&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;109&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DefaultClientConfigImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; IClientConfig {
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; 
&lt;span&gt;  3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Boolean DEFAULT_PRIORITIZE_VIP_ADDRESS_BASED_SERVERS =&lt;span&gt; Boolean.TRUE;
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; 
&lt;span&gt;  5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String DEFAULT_NFLOADBALANCER_PING_CLASSNAME = &quot;com.netflix.loadbalancer.DummyPing&quot;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; DummyPing.class.getName();&lt;/span&gt;
&lt;span&gt;  6&lt;/span&gt; 
&lt;span&gt;  7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String DEFAULT_NFLOADBALANCER_RULE_CLASSNAME = &quot;com.netflix.loadbalancer.AvailabilityFilteringRule&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; 
&lt;span&gt;  9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String DEFAULT_NFLOADBALANCER_CLASSNAME = &quot;com.netflix.loadbalancer.ZoneAwareLoadBalancer&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt; 
&lt;span&gt; 11&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; DEFAULT_USEIPADDRESS_FOR_SERVER =&lt;span&gt; Boolean.FALSE;
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; 
&lt;span&gt; 13&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String DEFAULT_CLIENT_CLASSNAME = &quot;com.netflix.niws.client.http.RestClient&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt; 
&lt;span&gt; 15&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String DEFAULT_VIPADDRESS_RESOLVER_CLASSNAME = &quot;com.netflix.client.SimpleVipAddressResolver&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt; 
&lt;span&gt; 17&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String DEFAULT_PRIME_CONNECTIONS_URI = &quot;/&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt; 
&lt;span&gt; 19&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_MAX_TOTAL_TIME_TO_PRIME_CONNECTIONS = 30000&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; 
&lt;span&gt; 21&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_MAX_RETRIES_PER_SERVER_PRIME_CONNECTION = 9&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt; 
&lt;span&gt; 23&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Boolean DEFAULT_ENABLE_PRIME_CONNECTIONS =&lt;span&gt; Boolean.FALSE;
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt; 
&lt;span&gt; 25&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_MAX_REQUESTS_ALLOWED_PER_WINDOW =&lt;span&gt; Integer.MAX_VALUE;
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt; 
&lt;span&gt; 27&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_REQUEST_THROTTLING_WINDOW_IN_MILLIS = 60000&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt; 
&lt;span&gt; 29&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Boolean DEFAULT_ENABLE_REQUEST_THROTTLING =&lt;span&gt; Boolean.FALSE;
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt; 
&lt;span&gt; 31&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Boolean DEFAULT_ENABLE_GZIP_CONTENT_ENCODING_FILTER =&lt;span&gt; Boolean.FALSE;
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt; 
&lt;span&gt; 33&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Boolean DEFAULT_CONNECTION_POOL_CLEANER_TASK_ENABLED =&lt;span&gt; Boolean.TRUE;
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt; 
&lt;span&gt; 35&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Boolean DEFAULT_FOLLOW_REDIRECTS =&lt;span&gt; Boolean.FALSE;
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt; 
&lt;span&gt; 37&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; DEFAULT_PERCENTAGE_NIWS_EVENT_LOGGED = 0.0f&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt; 
&lt;span&gt; 39&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_MAX_AUTO_RETRIES_NEXT_SERVER = 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt; 
&lt;span&gt; 41&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_MAX_AUTO_RETRIES = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt; 
&lt;span&gt; 43&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_BACKOFF_INTERVAL = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt; 
&lt;span&gt; 45&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_READ_TIMEOUT = 5000&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt; 
&lt;span&gt; 47&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_CONNECTION_MANAGER_TIMEOUT = 2000&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt; 
&lt;span&gt; 49&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_CONNECT_TIMEOUT = 2000&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt; 
&lt;span&gt; 51&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Boolean DEFAULT_ENABLE_CONNECTION_POOL =&lt;span&gt; Boolean.TRUE;
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt; 
&lt;span&gt; 53&lt;/span&gt; &lt;span&gt;    @Deprecated
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_MAX_HTTP_CONNECTIONS_PER_HOST = 50&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt; 
&lt;span&gt; 56&lt;/span&gt; &lt;span&gt;    @Deprecated
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_MAX_TOTAL_HTTP_CONNECTIONS = 200&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt; 
&lt;span&gt; 59&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_MAX_CONNECTIONS_PER_HOST = 50&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt; 
&lt;span&gt; 61&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_MAX_TOTAL_CONNECTIONS = 200&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt; 
&lt;span&gt; 63&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; DEFAULT_MIN_PRIME_CONNECTIONS_RATIO = 1.0f&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt; 
&lt;span&gt; 65&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String DEFAULT_PRIME_CONNECTIONS_CLASS = &quot;com.netflix.niws.client.http.HttpPrimeConnection&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; 
&lt;span&gt; 67&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String DEFAULT_SEVER_LIST_CLASS = &quot;com.netflix.loadbalancer.ConfigurationBasedServerList&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt; 
&lt;span&gt; 69&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String DEFAULT_SERVER_LIST_UPDATER_CLASS = &quot;com.netflix.loadbalancer.PollingServerListUpdater&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt; 
&lt;span&gt; 71&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_CONNECTION_IDLE_TIMERTASK_REPEAT_IN_MSECS = 30000; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; every half minute (30 secs)&lt;/span&gt;
&lt;span&gt; 72&lt;/span&gt; 
&lt;span&gt; 73&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_CONNECTIONIDLE_TIME_IN_MSECS = 30000; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; all connections idle for 30 secs&lt;/span&gt;
&lt;span&gt; 74&lt;/span&gt; 
&lt;span&gt; 75&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; Map&amp;lt;String, Object&amp;gt; properties = &lt;span&gt;new&lt;/span&gt; ConcurrentHashMap&amp;lt;String, Object&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt; 
&lt;span&gt; 77&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; Map&amp;lt;IClientConfigKey&amp;lt;?&amp;gt;, Object&amp;gt; typedProperties = &lt;span&gt;new&lt;/span&gt; ConcurrentHashMap&amp;lt;IClientConfigKey&amp;lt;?&amp;gt;, Object&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt; 
&lt;span&gt; 79&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Logger LOG = LoggerFactory.getLogger(DefaultClientConfigImpl.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt; 
&lt;span&gt; 81&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; String clientName = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt; 
&lt;span&gt; 83&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; VipAddressResolver resolver = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt; 
&lt;span&gt; 85&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; enableDynamicProperties = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 87&lt;/span&gt; &lt;span&gt;     * Defaults for the parameters for the thread pool used by batchParallel
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt; &lt;span&gt;     * calls
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 90&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_POOL_MAX_THREADS =&lt;span&gt; DEFAULT_MAX_TOTAL_HTTP_CONNECTIONS;
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_POOL_MIN_THREADS = 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; DEFAULT_POOL_KEEP_ALIVE_TIME = 15 * 60L&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; TimeUnit DEFAULT_POOL_KEEP_ALIVE_TIME_UNITS =&lt;span&gt; TimeUnit.SECONDS;
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Boolean DEFAULT_ENABLE_ZONE_AFFINITY =&lt;span&gt; Boolean.FALSE;
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Boolean DEFAULT_ENABLE_ZONE_EXCLUSIVITY =&lt;span&gt; Boolean.FALSE;
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_PORT = 7001&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Boolean DEFAULT_ENABLE_LOADBALANCER =&lt;span&gt; Boolean.TRUE;
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt; 
&lt;span&gt; 99&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String DEFAULT_PROPERTY_NAME_SPACE = &quot;ribbon&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; 
&lt;span&gt;101&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; String propertyNameSpace =&lt;span&gt; DEFAULT_PROPERTY_NAME_SPACE;
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt; 
&lt;span&gt;103&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Boolean DEFAULT_OK_TO_RETRY_ON_ALL_OPERATIONS =&lt;span&gt; Boolean.FALSE;
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt; 
&lt;span&gt;105&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Boolean DEFAULT_ENABLE_NIWS_EVENT_LOGGING =&lt;span&gt; Boolean.TRUE;
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt; 
&lt;span&gt;107&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Boolean DEFAULT_IS_CLIENT_AUTH_REQUIRED =&lt;span&gt; Boolean.FALSE;
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt; 
&lt;span&gt;109&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Map&amp;lt;String, DynamicStringProperty&amp;gt; dynamicProperties = &lt;span&gt;new&lt;/span&gt; ConcurrentHashMap&amp;lt;String, DynamicStringProperty&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt; 
&lt;span&gt;111&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Boolean getDefaultPrioritizeVipAddressBasedServers() {
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_PRIORITIZE_VIP_ADDRESS_BASED_SERVERS;
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt; 
&lt;span&gt;115&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getDefaultNfloadbalancerPingClassname() {
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_NFLOADBALANCER_PING_CLASSNAME;
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt; 
&lt;span&gt;119&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getDefaultNfloadbalancerRuleClassname() {
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_NFLOADBALANCER_RULE_CLASSNAME;
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt; 
&lt;span&gt;123&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getDefaultNfloadbalancerClassname() {
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_NFLOADBALANCER_CLASSNAME;
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt; 
&lt;span&gt;127&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; getDefaultUseIpAddressForServer() {
&lt;/span&gt;&lt;span&gt;128&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_USEIPADDRESS_FOR_SERVER;
&lt;/span&gt;&lt;span&gt;129&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt; 
&lt;span&gt;131&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getDefaultClientClassname() {
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_CLIENT_CLASSNAME;
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;134&lt;/span&gt; 
&lt;span&gt;135&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getDefaultVipaddressResolverClassname() {
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_VIPADDRESS_RESOLVER_CLASSNAME;
&lt;/span&gt;&lt;span&gt;137&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;138&lt;/span&gt; 
&lt;span&gt;139&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getDefaultPrimeConnectionsUri() {
&lt;/span&gt;&lt;span&gt;140&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_PRIME_CONNECTIONS_URI;
&lt;/span&gt;&lt;span&gt;141&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;142&lt;/span&gt; 
&lt;span&gt;143&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getDefaultMaxTotalTimeToPrimeConnections() {
&lt;/span&gt;&lt;span&gt;144&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_MAX_TOTAL_TIME_TO_PRIME_CONNECTIONS;
&lt;/span&gt;&lt;span&gt;145&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;146&lt;/span&gt; 
&lt;span&gt;147&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getDefaultMaxRetriesPerServerPrimeConnection() {
&lt;/span&gt;&lt;span&gt;148&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_MAX_RETRIES_PER_SERVER_PRIME_CONNECTION;
&lt;/span&gt;&lt;span&gt;149&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;150&lt;/span&gt; 
&lt;span&gt;151&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Boolean getDefaultEnablePrimeConnections() {
&lt;/span&gt;&lt;span&gt;152&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_ENABLE_PRIME_CONNECTIONS;
&lt;/span&gt;&lt;span&gt;153&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;154&lt;/span&gt; 
&lt;span&gt;155&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getDefaultMaxRequestsAllowedPerWindow() {
&lt;/span&gt;&lt;span&gt;156&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_MAX_REQUESTS_ALLOWED_PER_WINDOW;
&lt;/span&gt;&lt;span&gt;157&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;158&lt;/span&gt; 
&lt;span&gt;159&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getDefaultRequestThrottlingWindowInMillis() {
&lt;/span&gt;&lt;span&gt;160&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_REQUEST_THROTTLING_WINDOW_IN_MILLIS;
&lt;/span&gt;&lt;span&gt;161&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;162&lt;/span&gt; 
&lt;span&gt;163&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Boolean getDefaultEnableRequestThrottling() {
&lt;/span&gt;&lt;span&gt;164&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_ENABLE_REQUEST_THROTTLING;
&lt;/span&gt;&lt;span&gt;165&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;166&lt;/span&gt; 
&lt;span&gt;167&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Boolean getDefaultEnableGzipContentEncodingFilter() {
&lt;/span&gt;&lt;span&gt;168&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_ENABLE_GZIP_CONTENT_ENCODING_FILTER;
&lt;/span&gt;&lt;span&gt;169&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;170&lt;/span&gt; 
&lt;span&gt;171&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Boolean getDefaultConnectionPoolCleanerTaskEnabled() {
&lt;/span&gt;&lt;span&gt;172&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_CONNECTION_POOL_CLEANER_TASK_ENABLED;
&lt;/span&gt;&lt;span&gt;173&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;174&lt;/span&gt; 
&lt;span&gt;175&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Boolean getDefaultFollowRedirects() {
&lt;/span&gt;&lt;span&gt;176&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_FOLLOW_REDIRECTS;
&lt;/span&gt;&lt;span&gt;177&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;178&lt;/span&gt; 
&lt;span&gt;179&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;float&lt;/span&gt;&lt;span&gt; getDefaultPercentageNiwsEventLogged() {
&lt;/span&gt;&lt;span&gt;180&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_PERCENTAGE_NIWS_EVENT_LOGGED;
&lt;/span&gt;&lt;span&gt;181&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;182&lt;/span&gt; 
&lt;span&gt;183&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getDefaultMaxAutoRetriesNextServer() {
&lt;/span&gt;&lt;span&gt;184&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_MAX_AUTO_RETRIES_NEXT_SERVER;
&lt;/span&gt;&lt;span&gt;185&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;186&lt;/span&gt; 
&lt;span&gt;187&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getDefaultMaxAutoRetries() {
&lt;/span&gt;&lt;span&gt;188&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_MAX_AUTO_RETRIES;
&lt;/span&gt;&lt;span&gt;189&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;190&lt;/span&gt; 
&lt;span&gt;191&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getDefaultReadTimeout() {
&lt;/span&gt;&lt;span&gt;192&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_READ_TIMEOUT;
&lt;/span&gt;&lt;span&gt;193&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;194&lt;/span&gt; 
&lt;span&gt;195&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getDefaultConnectionManagerTimeout() {
&lt;/span&gt;&lt;span&gt;196&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_CONNECTION_MANAGER_TIMEOUT;
&lt;/span&gt;&lt;span&gt;197&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;198&lt;/span&gt; 
&lt;span&gt;199&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getDefaultConnectTimeout() {
&lt;/span&gt;&lt;span&gt;200&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_CONNECT_TIMEOUT;
&lt;/span&gt;&lt;span&gt;201&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;202&lt;/span&gt; 
&lt;span&gt;203&lt;/span&gt; &lt;span&gt;    @Deprecated
&lt;/span&gt;&lt;span&gt;204&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getDefaultMaxHttpConnectionsPerHost() {
&lt;/span&gt;&lt;span&gt;205&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_MAX_HTTP_CONNECTIONS_PER_HOST;
&lt;/span&gt;&lt;span&gt;206&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;207&lt;/span&gt; 
&lt;span&gt;208&lt;/span&gt; &lt;span&gt;    @Deprecated
&lt;/span&gt;&lt;span&gt;209&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getDefaultMaxTotalHttpConnections() {
&lt;/span&gt;&lt;span&gt;210&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_MAX_TOTAL_HTTP_CONNECTIONS;
&lt;/span&gt;&lt;span&gt;211&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;212&lt;/span&gt; 
&lt;span&gt;213&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getDefaultMaxConnectionsPerHost() {
&lt;/span&gt;&lt;span&gt;214&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_MAX_CONNECTIONS_PER_HOST;
&lt;/span&gt;&lt;span&gt;215&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;216&lt;/span&gt; 
&lt;span&gt;217&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getDefaultMaxTotalConnections() {
&lt;/span&gt;&lt;span&gt;218&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_MAX_TOTAL_CONNECTIONS;
&lt;/span&gt;&lt;span&gt;219&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;220&lt;/span&gt; 
&lt;span&gt;221&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;float&lt;/span&gt;&lt;span&gt; getDefaultMinPrimeConnectionsRatio() {
&lt;/span&gt;&lt;span&gt;222&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_MIN_PRIME_CONNECTIONS_RATIO;
&lt;/span&gt;&lt;span&gt;223&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;224&lt;/span&gt; 
&lt;span&gt;225&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getDefaultPrimeConnectionsClass() {
&lt;/span&gt;&lt;span&gt;226&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_PRIME_CONNECTIONS_CLASS;
&lt;/span&gt;&lt;span&gt;227&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;228&lt;/span&gt; 
&lt;span&gt;229&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getDefaultSeverListClass() {
&lt;/span&gt;&lt;span&gt;230&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_SEVER_LIST_CLASS;
&lt;/span&gt;&lt;span&gt;231&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;232&lt;/span&gt; 
&lt;span&gt;233&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getDefaultConnectionIdleTimertaskRepeatInMsecs() {
&lt;/span&gt;&lt;span&gt;234&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_CONNECTION_IDLE_TIMERTASK_REPEAT_IN_MSECS;
&lt;/span&gt;&lt;span&gt;235&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;236&lt;/span&gt; 
&lt;span&gt;237&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getDefaultConnectionidleTimeInMsecs() {
&lt;/span&gt;&lt;span&gt;238&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_CONNECTIONIDLE_TIME_IN_MSECS;
&lt;/span&gt;&lt;span&gt;239&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;240&lt;/span&gt; 
&lt;span&gt;241&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; VipAddressResolver getResolver() {
&lt;/span&gt;&lt;span&gt;242&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; resolver;
&lt;/span&gt;&lt;span&gt;243&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;244&lt;/span&gt; 
&lt;span&gt;245&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isEnableDynamicProperties() {
&lt;/span&gt;&lt;span&gt;246&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; enableDynamicProperties;
&lt;/span&gt;&lt;span&gt;247&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;248&lt;/span&gt; 
&lt;span&gt;249&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getDefaultPoolMaxThreads() {
&lt;/span&gt;&lt;span&gt;250&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_POOL_MAX_THREADS;
&lt;/span&gt;&lt;span&gt;251&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;252&lt;/span&gt; 
&lt;span&gt;253&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getDefaultPoolMinThreads() {
&lt;/span&gt;&lt;span&gt;254&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_POOL_MIN_THREADS;
&lt;/span&gt;&lt;span&gt;255&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;256&lt;/span&gt; 
&lt;span&gt;257&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; getDefaultPoolKeepAliveTime() {
&lt;/span&gt;&lt;span&gt;258&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_POOL_KEEP_ALIVE_TIME;
&lt;/span&gt;&lt;span&gt;259&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;260&lt;/span&gt; 
&lt;span&gt;261&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; TimeUnit getDefaultPoolKeepAliveTimeUnits() {
&lt;/span&gt;&lt;span&gt;262&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_POOL_KEEP_ALIVE_TIME_UNITS;
&lt;/span&gt;&lt;span&gt;263&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;264&lt;/span&gt; 
&lt;span&gt;265&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Boolean getDefaultEnableZoneAffinity() {
&lt;/span&gt;&lt;span&gt;266&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_ENABLE_ZONE_AFFINITY;
&lt;/span&gt;&lt;span&gt;267&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;268&lt;/span&gt; 
&lt;span&gt;269&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Boolean getDefaultEnableZoneExclusivity() {
&lt;/span&gt;&lt;span&gt;270&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_ENABLE_ZONE_EXCLUSIVITY;
&lt;/span&gt;&lt;span&gt;271&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;272&lt;/span&gt; 
&lt;span&gt;273&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getDefaultPort() {
&lt;/span&gt;&lt;span&gt;274&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_PORT;
&lt;/span&gt;&lt;span&gt;275&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;276&lt;/span&gt; 
&lt;span&gt;277&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Boolean getDefaultEnableLoadbalancer() {
&lt;/span&gt;&lt;span&gt;278&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_ENABLE_LOADBALANCER;
&lt;/span&gt;&lt;span&gt;279&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;280&lt;/span&gt; 
&lt;span&gt;281&lt;/span&gt; 
&lt;span&gt;282&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Boolean getDefaultOkToRetryOnAllOperations() {
&lt;/span&gt;&lt;span&gt;283&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_OK_TO_RETRY_ON_ALL_OPERATIONS;
&lt;/span&gt;&lt;span&gt;284&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;285&lt;/span&gt; 
&lt;span&gt;286&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Boolean getDefaultIsClientAuthRequired(){
&lt;/span&gt;&lt;span&gt;287&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DEFAULT_IS_CLIENT_AUTH_REQUIRED;
&lt;/span&gt;&lt;span&gt;288&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;289&lt;/span&gt; 
&lt;span&gt;290&lt;/span&gt; 
&lt;span&gt;291&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;292&lt;/span&gt; &lt;span&gt;     * Create instance with no properties in default name space {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #DEFAULT_PROPERTY_NAME_SPACE}
&lt;/span&gt;&lt;span&gt;293&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;294&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; DefaultClientConfigImpl() {
&lt;/span&gt;&lt;span&gt;295&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.dynamicProperties.clear();
&lt;/span&gt;&lt;span&gt;296&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.enableDynamicProperties = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;297&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;298&lt;/span&gt; 
&lt;span&gt;299&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;300&lt;/span&gt; &lt;span&gt;     * Create instance with no properties in the specified name space
&lt;/span&gt;&lt;span&gt;301&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;302&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; DefaultClientConfigImpl(String nameSpace) {
&lt;/span&gt;&lt;span&gt;303&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;304&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.propertyNameSpace =&lt;span&gt; nameSpace;
&lt;/span&gt;&lt;span&gt;305&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;306&lt;/span&gt; 
&lt;span&gt;307&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; loadDefaultValues() {
&lt;/span&gt;&lt;span&gt;308&lt;/span&gt; &lt;span&gt;        putDefaultIntegerProperty(CommonClientConfigKey.MaxHttpConnectionsPerHost, getDefaultMaxHttpConnectionsPerHost());
&lt;/span&gt;&lt;span&gt;309&lt;/span&gt; &lt;span&gt;        putDefaultIntegerProperty(CommonClientConfigKey.MaxTotalHttpConnections, getDefaultMaxTotalHttpConnections());
&lt;/span&gt;&lt;span&gt;310&lt;/span&gt; &lt;span&gt;        putDefaultBooleanProperty(CommonClientConfigKey.EnableConnectionPool, getDefaultEnableConnectionPool());
&lt;/span&gt;&lt;span&gt;311&lt;/span&gt; &lt;span&gt;        putDefaultIntegerProperty(CommonClientConfigKey.MaxConnectionsPerHost, getDefaultMaxConnectionsPerHost());
&lt;/span&gt;&lt;span&gt;312&lt;/span&gt; &lt;span&gt;        putDefaultIntegerProperty(CommonClientConfigKey.MaxTotalConnections, getDefaultMaxTotalConnections());
&lt;/span&gt;&lt;span&gt;313&lt;/span&gt; &lt;span&gt;        putDefaultIntegerProperty(CommonClientConfigKey.ConnectTimeout, getDefaultConnectTimeout());
&lt;/span&gt;&lt;span&gt;314&lt;/span&gt; &lt;span&gt;        putDefaultIntegerProperty(CommonClientConfigKey.ConnectionManagerTimeout, getDefaultConnectionManagerTimeout());
&lt;/span&gt;&lt;span&gt;315&lt;/span&gt; &lt;span&gt;        putDefaultIntegerProperty(CommonClientConfigKey.ReadTimeout, getDefaultReadTimeout());
&lt;/span&gt;&lt;span&gt;316&lt;/span&gt; &lt;span&gt;        putDefaultIntegerProperty(CommonClientConfigKey.MaxAutoRetries, getDefaultMaxAutoRetries());
&lt;/span&gt;&lt;span&gt;317&lt;/span&gt; &lt;span&gt;        putDefaultIntegerProperty(CommonClientConfigKey.MaxAutoRetriesNextServer, getDefaultMaxAutoRetriesNextServer());
&lt;/span&gt;&lt;span&gt;318&lt;/span&gt; &lt;span&gt;        putDefaultBooleanProperty(CommonClientConfigKey.OkToRetryOnAllOperations, getDefaultOkToRetryOnAllOperations());
&lt;/span&gt;&lt;span&gt;319&lt;/span&gt; &lt;span&gt;        putDefaultBooleanProperty(CommonClientConfigKey.FollowRedirects, getDefaultFollowRedirects());
&lt;/span&gt;&lt;span&gt;320&lt;/span&gt; &lt;span&gt;        putDefaultBooleanProperty(CommonClientConfigKey.ConnectionPoolCleanerTaskEnabled, getDefaultConnectionPoolCleanerTaskEnabled());
&lt;/span&gt;&lt;span&gt;321&lt;/span&gt; &lt;span&gt;        putDefaultIntegerProperty(CommonClientConfigKey.ConnIdleEvictTimeMilliSeconds, getDefaultConnectionidleTimeInMsecs());
&lt;/span&gt;&lt;span&gt;322&lt;/span&gt; &lt;span&gt;        putDefaultIntegerProperty(CommonClientConfigKey.ConnectionCleanerRepeatInterval, getDefaultConnectionIdleTimertaskRepeatInMsecs());
&lt;/span&gt;&lt;span&gt;323&lt;/span&gt; &lt;span&gt;        putDefaultBooleanProperty(CommonClientConfigKey.EnableGZIPContentEncodingFilter, getDefaultEnableGzipContentEncodingFilter());
&lt;/span&gt;&lt;span&gt;324&lt;/span&gt;         String proxyHost =&lt;span&gt; ConfigurationManager.getConfigInstance().getString(getDefaultPropName(CommonClientConfigKey.ProxyHost.key()));
&lt;/span&gt;&lt;span&gt;325&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (proxyHost != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; proxyHost.length() &amp;gt; 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;326&lt;/span&gt; &lt;span&gt;            setProperty(CommonClientConfigKey.ProxyHost, proxyHost);
&lt;/span&gt;&lt;span&gt;327&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;328&lt;/span&gt;         Integer proxyPort =&lt;span&gt; ConfigurationManager
&lt;/span&gt;&lt;span&gt;329&lt;/span&gt; &lt;span&gt;                .getConfigInstance()
&lt;/span&gt;&lt;span&gt;330&lt;/span&gt; &lt;span&gt;                .getInteger(
&lt;/span&gt;&lt;span&gt;331&lt;/span&gt; &lt;span&gt;                        getDefaultPropName(CommonClientConfigKey.ProxyPort),
&lt;/span&gt;&lt;span&gt;332&lt;/span&gt;                         (Integer.MIN_VALUE + 1)); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; + 1 just to avoid potential clash with user setting&lt;/span&gt;
&lt;span&gt;333&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (proxyPort != (Integer.MIN_VALUE + 1&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt;334&lt;/span&gt; &lt;span&gt;            setProperty(CommonClientConfigKey.ProxyPort, proxyPort);
&lt;/span&gt;&lt;span&gt;335&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;336&lt;/span&gt; &lt;span&gt;        putDefaultIntegerProperty(CommonClientConfigKey.Port, getDefaultPort());
&lt;/span&gt;&lt;span&gt;337&lt;/span&gt; &lt;span&gt;        putDefaultBooleanProperty(CommonClientConfigKey.EnablePrimeConnections, getDefaultEnablePrimeConnections());
&lt;/span&gt;&lt;span&gt;338&lt;/span&gt; &lt;span&gt;        putDefaultIntegerProperty(CommonClientConfigKey.MaxRetriesPerServerPrimeConnection, getDefaultMaxRetriesPerServerPrimeConnection());
&lt;/span&gt;&lt;span&gt;339&lt;/span&gt; &lt;span&gt;        putDefaultIntegerProperty(CommonClientConfigKey.MaxTotalTimeToPrimeConnections, getDefaultMaxTotalTimeToPrimeConnections());
&lt;/span&gt;&lt;span&gt;340&lt;/span&gt; &lt;span&gt;        putDefaultStringProperty(CommonClientConfigKey.PrimeConnectionsURI, getDefaultPrimeConnectionsUri());
&lt;/span&gt;&lt;span&gt;341&lt;/span&gt; &lt;span&gt;        putDefaultIntegerProperty(CommonClientConfigKey.PoolMinThreads, getDefaultPoolMinThreads());
&lt;/span&gt;&lt;span&gt;342&lt;/span&gt; &lt;span&gt;        putDefaultIntegerProperty(CommonClientConfigKey.PoolMaxThreads, getDefaultPoolMaxThreads());
&lt;/span&gt;&lt;span&gt;343&lt;/span&gt; &lt;span&gt;        putDefaultLongProperty(CommonClientConfigKey.PoolKeepAliveTime, getDefaultPoolKeepAliveTime());
&lt;/span&gt;&lt;span&gt;344&lt;/span&gt; &lt;span&gt;        putDefaultTimeUnitProperty(CommonClientConfigKey.PoolKeepAliveTimeUnits, getDefaultPoolKeepAliveTimeUnits());
&lt;/span&gt;&lt;span&gt;345&lt;/span&gt; &lt;span&gt;        putDefaultBooleanProperty(CommonClientConfigKey.EnableZoneAffinity, getDefaultEnableZoneAffinity());
&lt;/span&gt;&lt;span&gt;346&lt;/span&gt; &lt;span&gt;        putDefaultBooleanProperty(CommonClientConfigKey.EnableZoneExclusivity, getDefaultEnableZoneExclusivity());
&lt;/span&gt;&lt;span&gt;347&lt;/span&gt; &lt;span&gt;        putDefaultStringProperty(CommonClientConfigKey.ClientClassName, getDefaultClientClassname());
&lt;/span&gt;&lt;span&gt;348&lt;/span&gt; &lt;span&gt;        putDefaultStringProperty(CommonClientConfigKey.NFLoadBalancerClassName, getDefaultNfloadbalancerClassname());
&lt;/span&gt;&lt;span&gt;349&lt;/span&gt; &lt;span&gt;        putDefaultStringProperty(CommonClientConfigKey.NFLoadBalancerRuleClassName, getDefaultNfloadbalancerRuleClassname());
&lt;/span&gt;&lt;span&gt;350&lt;/span&gt; &lt;span&gt;        putDefaultStringProperty(CommonClientConfigKey.NFLoadBalancerPingClassName, getDefaultNfloadbalancerPingClassname());
&lt;/span&gt;&lt;span&gt;351&lt;/span&gt; &lt;span&gt;        putDefaultBooleanProperty(CommonClientConfigKey.PrioritizeVipAddressBasedServers, getDefaultPrioritizeVipAddressBasedServers());
&lt;/span&gt;&lt;span&gt;352&lt;/span&gt; &lt;span&gt;        putDefaultFloatProperty(CommonClientConfigKey.MinPrimeConnectionsRatio, getDefaultMinPrimeConnectionsRatio());
&lt;/span&gt;&lt;span&gt;353&lt;/span&gt; &lt;span&gt;        putDefaultStringProperty(CommonClientConfigKey.PrimeConnectionsClassName, getDefaultPrimeConnectionsClass());
&lt;/span&gt;&lt;span&gt;354&lt;/span&gt; &lt;span&gt;        putDefaultStringProperty(CommonClientConfigKey.NIWSServerListClassName, getDefaultSeverListClass());
&lt;/span&gt;&lt;span&gt;355&lt;/span&gt; &lt;span&gt;        putDefaultStringProperty(CommonClientConfigKey.VipAddressResolverClassName, getDefaultVipaddressResolverClassname());
&lt;/span&gt;&lt;span&gt;356&lt;/span&gt; &lt;span&gt;        putDefaultBooleanProperty(CommonClientConfigKey.IsClientAuthRequired, getDefaultIsClientAuthRequired());
&lt;/span&gt;&lt;span&gt;357&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; putDefaultStringProperty(CommonClientConfigKey.RequestIdHeaderName, getDefaultRequestIdHeaderName());&lt;/span&gt;
&lt;span&gt;358&lt;/span&gt; &lt;span&gt;        putDefaultBooleanProperty(CommonClientConfigKey.UseIPAddrForServer, getDefaultUseIpAddressForServer());
&lt;/span&gt;&lt;span&gt;359&lt;/span&gt;         putDefaultStringProperty(CommonClientConfigKey.ListOfServers, &quot;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;360&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;361&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;也可以在配置文件中定制配置，例如配置超时和重试：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;# 全局配置
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;ribbon:
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;  # 客户端读取超时时间
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;   ReadTimeout: 3000
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;  # 客户端连接超时时间
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;   ConnectTimeout: 3000
&lt;span&gt; 7&lt;/span&gt;   # 默认只重试 GET，设置为 &lt;span&gt;true&lt;/span&gt;&lt;span&gt; 时将重试所有类型，如 POST、PUT、DELETE
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;   OkToRetryOnAllOperations: &lt;span&gt;false&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;  # 重试次数
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;   MaxAutoRetries: 1
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;  # 最多重试几个实例
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;   MaxAutoRetriesNextServer: 1
&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; # 只针对 demo-&lt;span&gt;producer 客户端
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; demo-&lt;span&gt;producer:
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;  ribbon:
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    # 客户端读取超时时间
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     ReadTimeout: 5000
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    # 客户端连接超时时间
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     ConnectTimeout: 3000
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2、均衡策略 — IRule&lt;/h3&gt;
&lt;p&gt;IRule 是最终选择 Server 的策略规则类，核心的接口就是 choose。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IRule{
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 选择 Server&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Server choose(Object key);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置 ILoadBalancer&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setLoadBalancer(ILoadBalancer lb);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取 ILoadBalancer&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ILoadBalancer getLoadBalancer();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Ribbon 提供了丰富的负载均衡策略，我们也可以通过配置指定使用某个均衡策略。下面是整个Ribbon提供的 IRule 均衡策略。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202012/856154-20201216141424713-1149639373.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202012/856154-20201216141550724-1761844405.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3、服务检查 — IPing&lt;/h3&gt;
&lt;p&gt;IPing 是用于定期检查 Server 的可用性的，它只提供了一个接口，用来判断 Server 是否存活：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1 &lt;span&gt;public &lt;span&gt;interface&lt;span&gt; IPing {
&lt;span&gt;2     
&lt;span&gt;3     &lt;span&gt;public &lt;span&gt;boolean&lt;span&gt; isAlive(Server server);
&lt;span&gt;4 }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;IPing 也提供了多种策略可选，下面是整个 IPing 体系结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202012/856154-20201216143650669-1089978409.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202012/856154-20201216155204028-959715095.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;4、获取服务列表 — ServerList&lt;/h3&gt;
&lt;p&gt;ServerList 提供了两个接口，一个是第一次获取 Server 列表，一个是更新 Server 列表，其中 getUpdatedListOfServers 会每被 Loadbalancer 隔 30 秒调一次来更新 allServerList。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1 &lt;span&gt;public &lt;span&gt;interface ServerList&amp;lt;T &lt;span&gt;extends Server&amp;gt;&lt;span&gt; {
&lt;span&gt; 2 
&lt;span&gt; 3     &lt;span&gt;public List&amp;lt;T&amp;gt;&lt;span&gt; getInitialListOfServers();
&lt;span&gt; 4     
&lt;span&gt; 5     &lt;span&gt;/**
&lt;span&gt; 6 &lt;span&gt;     * Return updated list of servers. This is called say every 30 secs
&lt;span&gt; 7 &lt;span&gt;     * (configurable) by the Loadbalancer's Ping cycle
&lt;span&gt; 8      &lt;span&gt;*/
&lt;span&gt; 9     &lt;span&gt;public List&amp;lt;T&amp;gt;&lt;span&gt; getUpdatedListOfServers();   
&lt;span&gt;10 }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ServerList 也提供了多种实现，ServerList 体系结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202012/856154-20201216153448922-1665417546.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202012/856154-20201216155415765-1116927601.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;5、过滤服务 — ServerListFilter&lt;/h3&gt;
&lt;p&gt;ServerListFilter 提供了一个接口用来过滤出可用的 Server。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; ServerListFilter&amp;lt;T &lt;span&gt;extends&lt;/span&gt; Server&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; List&amp;lt;T&amp;gt; getFilteredListOfServers(List&amp;lt;T&amp;gt;&lt;span&gt; servers);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ServerListFilter 体系结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202012/856154-20201216155723158-899384324.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;6、服务列表更新 — ServerListUpdater&lt;/h3&gt;
&lt;p&gt;ServerListUpdater 有多个接口，最核心的就是 start 开启定时任务调用 updateAction 来更新 allServerList。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1 &lt;span&gt;public &lt;span&gt;interface&lt;span&gt; ServerListUpdater {
&lt;span&gt; 2 
&lt;span&gt; 3     &lt;span&gt;/**
&lt;span&gt; 4 &lt;span&gt;     * an interface for the updateAction that actually executes a server list update
&lt;span&gt; 5      &lt;span&gt;*/
&lt;span&gt; 6     &lt;span&gt;public &lt;span&gt;interface&lt;span&gt; UpdateAction {
&lt;span&gt; 7         &lt;span&gt;void&lt;span&gt; doUpdate();
&lt;span&gt; 8 &lt;span&gt;    }
&lt;span&gt; 9 
&lt;span&gt;10     &lt;span&gt;/**
&lt;span&gt;11 &lt;span&gt;     * start the serverList updater with the given update action
&lt;span&gt;12 &lt;span&gt;     * This call should be idempotent.
&lt;span&gt;13      &lt;span&gt;*/
&lt;span&gt;14     &lt;span&gt;void&lt;span&gt; start(UpdateAction updateAction);
&lt;span&gt;15 }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;默认有两个实现类：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202012/856154-20201216160325559-919949316.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;7、负载均衡器 — ILoadBalancer&lt;/h3&gt;
&lt;p&gt;ILoadBalancer 是负载均衡选择服务的核心接口，主要提供了如下的获取Server列表和根据客户端名称选择Server的接口。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1 &lt;span&gt;public &lt;span&gt;interface&lt;span&gt; ILoadBalancer {
&lt;span&gt; 2 
&lt;span&gt; 3     &lt;span&gt;//&lt;span&gt; 添加Server
&lt;span&gt; 4     &lt;span&gt;public &lt;span&gt;void addServers(List&amp;lt;Server&amp;gt;&lt;span&gt; newServers);
&lt;span&gt; 5     
&lt;span&gt; 6     &lt;span&gt;//&lt;span&gt; 根据key选择一个Server
&lt;span&gt; 7     &lt;span&gt;public&lt;span&gt; Server chooseServer(Object key);
&lt;span&gt; 8     
&lt;span&gt; 9     &lt;span&gt;//&lt;span&gt; 获取存活的Server列表，返回 upServerList
&lt;span&gt;10     &lt;span&gt;public List&amp;lt;Server&amp;gt;&lt;span&gt; getReachableServers();
&lt;span&gt;11 
&lt;span&gt;12     &lt;span&gt;//&lt;span&gt; 获取所有Server列表，返回 allServerList
&lt;span&gt;13     &lt;span&gt;public List&amp;lt;Server&amp;gt;&lt;span&gt; getAllServers();
&lt;span&gt;14 }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ILoadBalancer 的体系结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202012/856154-20201216160719383-1823772896.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;8、Ribbon 相关配置类&lt;/h3&gt;
&lt;p&gt;从前面一直看下来，可以发现有很多与 Ribbon 相关的配置类，这里总结下与 Ribbon 相关的配置类，看每个配置类的配置顺序，以及都主要配置了哪些东西。&lt;/p&gt;
&lt;p&gt;① 首先是Eureka客户端配置类 EurekaClientAutoConfiguration，这个自动化配置类主要配置了 Ribbon 所需的 EurekaClient。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35.5&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_01cd9278-96c5-4bb1-88f1-5005f4d1eff3&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_01cd9278-96c5-4bb1-88f1-5005f4d1eff3&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_01cd9278-96c5-4bb1-88f1-5005f4d1eff3&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; @Configuration(proxyBeanMethods = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;@EnableConfigurationProperties
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; @ConditionalOnClass(EurekaClientConfig.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; @ConditionalOnProperty(value = &quot;eureka.client.enabled&quot;, matchIfMissing = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;@ConditionalOnDiscoveryEnabled
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; @AutoConfigureBefore({ NoopDiscoveryClientAutoConfiguration.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         CommonsClientAutoConfiguration.&lt;span&gt;class&lt;/span&gt;, ServiceRegistryAutoConfiguration.&lt;span&gt;class&lt;/span&gt;&lt;span&gt; })
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; @AutoConfigureAfter(name =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &quot;org.springframework.cloud.netflix.eureka.config.DiscoveryClientOptionalArgsConfiguration&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &quot;org.springframework.cloud.autoconfigure.RefreshAutoConfiguration&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &quot;org.springframework.cloud.netflix.eureka.EurekaDiscoveryClientConfiguration&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &quot;org.springframework.cloud.client.serviceregistry.AutoServiceRegistrationAutoConfiguration&quot;&lt;span&gt; })
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; EurekaClientAutoConfiguration {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ....&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;② 接着是Ribbon自动化配置类 RibbonAutoConfiguration，这个类主要配置了如下类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;SpringClientFactory：管理 Ribbon 客户端上下文。&lt;/li&gt;
&lt;li&gt;LoadBalancerClient：负载均衡客户端，默认实现类为 RibbonLoadBalancerClient（实际是在 RibbonClientConfiguration 中配置的）。&lt;/li&gt;
&lt;li&gt;PropertiesFactory：用于判断配置文件中是否自定义了核心接口的实现类，如 NFLoadBalancerClassName、NFLoadBalancerPingClassName 等。&lt;/li&gt;
&lt;li&gt;RibbonApplicationContextInitializer：开启饥饿配置的时候，用这个类来在启动时初始化 Ribbon 客户端上下文。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34.5&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_30a3e041-598e-4ce9-b976-2229d15e075e&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_30a3e041-598e-4ce9-b976-2229d15e075e&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_30a3e041-598e-4ce9-b976-2229d15e075e&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; org.springframework.cloud.netflix.ribbon;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;@Configuration
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; @Conditional(RibbonAutoConfiguration.RibbonClassesConditions.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;@RibbonClients
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在 EurekaClientAutoConfiguration 之后配置&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; @AutoConfigureAfter(name = &quot;org.springframework.cloud.netflix.eureka.EurekaClientAutoConfiguration&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在 LoadBalancerAutoConfiguration、AsyncLoadBalancerAutoConfiguration 之前配置&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; @AutoConfigureBefore({ LoadBalancerAutoConfiguration.&lt;span&gt;class&lt;/span&gt;, AsyncLoadBalancerAutoConfiguration.&lt;span&gt;class&lt;/span&gt;&lt;span&gt; })
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; @EnableConfigurationProperties({ RibbonEagerLoadProperties.&lt;span&gt;class&lt;/span&gt;, ServerIntrospectorProperties.&lt;span&gt;class&lt;/span&gt;&lt;span&gt; })
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RibbonAutoConfiguration {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     @Autowired(required = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; List&amp;lt;RibbonClientSpecification&amp;gt; configurations = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    @Autowired
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; RibbonEagerLoadProperties ribbonEagerLoadProperties;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; HasFeatures ribbonFeature() {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; HasFeatures.namedFeature(&quot;Ribbon&quot;, Ribbon.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    @ConditionalOnMissingBean
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; SpringClientFactory springClientFactory() {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         SpringClientFactory factory = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SpringClientFactory();
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         factory.setConfigurations(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.configurations);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; factory;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt; &lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     @ConditionalOnMissingBean(LoadBalancerClient.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; LoadBalancerClient loadBalancerClient() {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RibbonLoadBalancerClient(springClientFactory());
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt; &lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;     @ConditionalOnClass(name = &quot;org.springframework.retry.support.RetryTemplate&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;    @ConditionalOnMissingBean
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; LoadBalancedRetryFactory loadBalancedRetryPolicyFactory(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; SpringClientFactory clientFactory) {
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RibbonLoadBalancedRetryFactory(clientFactory);
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; 
&lt;span&gt;45&lt;/span&gt; &lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;    @ConditionalOnMissingBean
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; PropertiesFactory propertiesFactory() {
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PropertiesFactory();
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; 
&lt;span&gt;51&lt;/span&gt; &lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;     @ConditionalOnProperty(&quot;ribbon.eager-load.enabled&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; RibbonApplicationContextInitializer ribbonApplicationContextInitializer() {
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RibbonApplicationContextInitializer(springClientFactory(), ribbonEagerLoadProperties.getClients());
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;③ 接着是负载均衡器配置类 LoadBalancerAutoConfiguration，这个类主要是创建了负载均衡拦截器 LoadBalancerInterceptor，并添加到 RestTemplae 的拦截器中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_b5e3c0b5-9134-4165-921c-487b7e84d49c&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_b5e3c0b5-9134-4165-921c-487b7e84d49c&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_b5e3c0b5-9134-4165-921c-487b7e84d49c&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; org.springframework.cloud.client.loadbalancer;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; @Configuration(proxyBeanMethods = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; @ConditionalOnClass(RestTemplate.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; @ConditionalOnBean(LoadBalancerClient.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; @EnableConfigurationProperties(LoadBalancerRetryProperties.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LoadBalancerAutoConfiguration {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    @LoadBalanced
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     @Autowired(required = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; List&amp;lt;RestTemplate&amp;gt; restTemplates =&lt;span&gt; Collections.emptyList();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     @Autowired(required = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; List&amp;lt;LoadBalancerRequestTransformer&amp;gt; transformers =&lt;span&gt; Collections.emptyList();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对 RestTemplate 定制化&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; SmartInitializingSingleton loadBalancedRestTemplateInitializerDeprecated(
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;final&lt;/span&gt; ObjectProvider&amp;lt;List&amp;lt;RestTemplateCustomizer&amp;gt;&amp;gt;&lt;span&gt; restTemplateCustomizers) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; () -&amp;gt; restTemplateCustomizers.ifAvailable(customizers -&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (RestTemplate restTemplate : LoadBalancerAutoConfiguration.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.restTemplates) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (RestTemplateCustomizer customizer : customizers) {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;                    customizer.customize(restTemplate);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    @ConditionalOnMissingBean
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; LoadBalancerRequestFactory loadBalancerRequestFactory(LoadBalancerClient loadBalancerClient) {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; LoadBalancerRequestFactory(loadBalancerClient, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.transformers);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt;     @Configuration(proxyBeanMethods = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     @ConditionalOnMissingClass(&quot;org.springframework.retry.support.RetryTemplate&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LoadBalancerInterceptorConfig {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; 
&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建 RestTemplate 拦截器&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt; &lt;span&gt;        @Bean
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; LoadBalancerInterceptor ribbonInterceptor(LoadBalancerClient loadBalancerClient,
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;                                                         LoadBalancerRequestFactory requestFactory) {
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LoadBalancerInterceptor(loadBalancerClient, requestFactory);
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; 
&lt;span&gt;46&lt;/span&gt; &lt;span&gt;        @Bean
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;        @ConditionalOnMissingBean
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; RestTemplateCustomizer restTemplateCustomizer(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; LoadBalancerInterceptor loadBalancerInterceptor) {
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; restTemplate -&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;                 List&amp;lt;ClientHttpRequestInterceptor&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;(
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;                        restTemplate.getInterceptors());
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;                list.add(loadBalancerInterceptor);
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;                restTemplate.setInterceptors(list);
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;            };
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; 
&lt;span&gt;57&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;④ 之后是默认的 Ribbon 客户端配置类 RibbonClientConfiguration，这个类主要配置了 Ribbon 核心接口的默认实现。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;IClientConfig：Ribbon 客户端配置类，默认实现是 DefaultClientConfigImpl。&lt;/li&gt;
&lt;li&gt;IRule：负载均衡策略规则组件，默认实现是 ZoneAvoidanceRule。&lt;/li&gt;
&lt;li&gt;IPing：判断 Server 是否存活，默认实现是 DummyPing，永远都是返回 true。&lt;/li&gt;
&lt;li&gt;ServerList：获取 Server 的组件，默认实现类为 ConfigurationBasedServerList，从配置文件获取。&lt;/li&gt;
&lt;li&gt;ServerListUpdater：Server 列表更新组件，默认实现类为 PollingServerListUpdater。&lt;/li&gt;
&lt;li&gt;ServerListFilter：过滤可用的 Server 列表，默认实现类为 ZonePreferenceServerListFilter。&lt;/li&gt;
&lt;li&gt;RibbonLoadBalancerContext：负载均衡客户端。&lt;/li&gt;
&lt;li&gt;RetryHandler：重试处理器，默认实现类为 DefaultLoadBalancerRetryHandler。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_c3c407f0-5d30-4ec3-85ad-3c7e12d24085&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_c3c407f0-5d30-4ec3-85ad-3c7e12d24085&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c3c407f0-5d30-4ec3-85ad-3c7e12d24085&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;95&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; org.springframework.cloud.netflix.ribbon;
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; 
&lt;span&gt;  3&lt;/span&gt; @SuppressWarnings(&quot;deprecation&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; @Configuration(proxyBeanMethods = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;@EnableConfigurationProperties
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; @Import({ HttpClientConfiguration.&lt;span&gt;class&lt;/span&gt;, OkHttpRibbonConfiguration.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt;         RestClientRibbonConfiguration.&lt;span&gt;class&lt;/span&gt;, HttpClientRibbonConfiguration.&lt;span&gt;class&lt;/span&gt;&lt;span&gt; })
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RibbonClientConfiguration {
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_CONNECT_TIMEOUT = 1000&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_READ_TIMEOUT = 1000&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; DEFAULT_GZIP_PAYLOAD = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; 
&lt;span&gt; 13&lt;/span&gt; &lt;span&gt;    @RibbonClientName
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; String name = &quot;client&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt; 
&lt;span&gt; 16&lt;/span&gt; &lt;span&gt;    @Autowired
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; PropertiesFactory propertiesFactory;
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt; 
&lt;span&gt; 19&lt;/span&gt; &lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; &lt;span&gt;    @ConditionalOnMissingBean
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; IClientConfig ribbonClientConfig() {
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt;         DefaultClientConfigImpl config = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultClientConfigImpl();
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt;         config.loadProperties(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name);
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt; &lt;span&gt;        config.set(CommonClientConfigKey.ConnectTimeout, DEFAULT_CONNECT_TIMEOUT);
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt; &lt;span&gt;        config.set(CommonClientConfigKey.ReadTimeout, DEFAULT_READ_TIMEOUT);
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt; &lt;span&gt;        config.set(CommonClientConfigKey.GZipPayload, DEFAULT_GZIP_PAYLOAD);
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; config;
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt; 
&lt;span&gt; 30&lt;/span&gt; &lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt; &lt;span&gt;    @ConditionalOnMissingBean
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; IRule ribbonRule(IClientConfig config) {
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.propertiesFactory.isSet(IRule.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, name)) {
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.propertiesFactory.get(IRule.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, config, name);
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt;         ZoneAvoidanceRule rule = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ZoneAvoidanceRule();
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt; &lt;span&gt;        rule.initWithNiwsConfig(config);
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; rule;
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt; 
&lt;span&gt; 41&lt;/span&gt; &lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt; &lt;span&gt;    @ConditionalOnMissingBean
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; IPing ribbonPing(IClientConfig config) {
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.propertiesFactory.isSet(IPing.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, name)) {
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.propertiesFactory.get(IPing.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, config, name);
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DummyPing();
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt; 
&lt;span&gt; 50&lt;/span&gt; &lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt; &lt;span&gt;    @ConditionalOnMissingBean
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt;     @SuppressWarnings(&quot;unchecked&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; ServerList&amp;lt;Server&amp;gt;&lt;span&gt; ribbonServerList(IClientConfig config) {
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.propertiesFactory.isSet(ServerList.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, name)) {
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.propertiesFactory.get(ServerList.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, config, name);
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;         ConfigurationBasedServerList serverList = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConfigurationBasedServerList();
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt; &lt;span&gt;        serverList.initWithNiwsConfig(config);
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; serverList;
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt; 
&lt;span&gt; 62&lt;/span&gt; &lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt; &lt;span&gt;    @ConditionalOnMissingBean
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ServerListUpdater ribbonServerListUpdater(IClientConfig config) {
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PollingServerListUpdater(config);
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt; 
&lt;span&gt; 68&lt;/span&gt; &lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt; &lt;span&gt;    @ConditionalOnMissingBean
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ILoadBalancer ribbonLoadBalancer(IClientConfig config,
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt;             ServerList&amp;lt;Server&amp;gt; serverList, ServerListFilter&amp;lt;Server&amp;gt;&lt;span&gt; serverListFilter,
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt; &lt;span&gt;            IRule rule, IPing ping, ServerListUpdater serverListUpdater) {
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.propertiesFactory.isSet(ILoadBalancer.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, name)) {
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.propertiesFactory.get(ILoadBalancer.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, config, name);
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ZoneAwareLoadBalancer&amp;lt;&amp;gt;&lt;span&gt;(config, rule, ping, serverList,
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt; &lt;span&gt;                serverListFilter, serverListUpdater);
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt; 
&lt;span&gt; 80&lt;/span&gt; &lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt; &lt;span&gt;    @ConditionalOnMissingBean
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;     @SuppressWarnings(&quot;unchecked&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; ServerListFilter&amp;lt;Server&amp;gt;&lt;span&gt; ribbonServerListFilter(IClientConfig config) {
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.propertiesFactory.isSet(ServerListFilter.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, name)) {
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.propertiesFactory.get(ServerListFilter.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, config, name);
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt;         ZonePreferenceServerListFilter filter = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ZonePreferenceServerListFilter();
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt; &lt;span&gt;        filter.initWithNiwsConfig(config);
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; filter;
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt; 
&lt;span&gt; 92&lt;/span&gt; &lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt; &lt;span&gt;    @ConditionalOnMissingBean
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; RibbonLoadBalancerContext ribbonLoadBalancerContext(ILoadBalancer loadBalancer,
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt; &lt;span&gt;            IClientConfig config, RetryHandler retryHandler) {
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RibbonLoadBalancerContext(loadBalancer, config, retryHandler);
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt; 
&lt;span&gt; 99&lt;/span&gt; &lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; &lt;span&gt;    @ConditionalOnMissingBean
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; RetryHandler retryHandler(IClientConfig config) {
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultLoadBalancerRetryHandler(config);
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt; 
&lt;span&gt;105&lt;/span&gt; &lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt; &lt;span&gt;    @ConditionalOnMissingBean
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ServerIntrospector serverIntrospector() {
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultServerIntrospector();
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;⑤ Ribbon Eureka 自动化配置类 RibbonEurekaAutoConfiguration，判断是否启用 Ribbon Eureka，并触发 EurekaRibbonClientConfiguration 配置类。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_c2c17ad6-b7fc-4b08-80b7-caa6a40b6df3&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_c2c17ad6-b7fc-4b08-80b7-caa6a40b6df3&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c2c17ad6-b7fc-4b08-80b7-caa6a40b6df3&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; org.springframework.cloud.netflix.ribbon.eureka;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; @Configuration(proxyBeanMethods = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;@EnableConfigurationProperties
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;@ConditionalOnRibbonAndEurekaEnabled
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; @AutoConfigureAfter(RibbonAutoConfiguration.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; @RibbonClients(defaultConfiguration = EurekaRibbonClientConfiguration.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RibbonEurekaAutoConfiguration {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;⑥ 默认启用 Ribbon Eureka 的情况下，会使用 Ribbon Eureka 客户端配置类 EurekaRibbonClientConfiguration：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;IPing：替换了默认实现类 DummyPing，改为 NIWSDiscoveryPing，通过判断 InstanceInfo 的状态是否为 UP 来判断 Server 是否存活。&lt;/li&gt;
&lt;li&gt;ServerList：替换了默认的实现类 ConfigurationBasedServerList，改为 DomainExtractingServerList，实际是 DiscoveryEnabledNIWSServerList，从 EurekaClient 获取 Server 列表。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_90bf4e3f-4946-48b7-8296-6690ad6a4679&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_90bf4e3f-4946-48b7-8296-6690ad6a4679&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_90bf4e3f-4946-48b7-8296-6690ad6a4679&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;73&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; org.springframework.cloud.netflix.ribbon.eureka;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; @Configuration(proxyBeanMethods = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; EurekaRibbonClientConfiguration {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Log log = LogFactory.getLog(EurekaRibbonClientConfiguration.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;     @Value(&quot;${ribbon.eureka.approximateZoneFromHostname:false}&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; approximateZoneFromHostname = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    @RibbonClientName
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; String serviceId = &quot;client&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     @Autowired(required = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; EurekaClientConfig clientConfig;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     @Autowired(required = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; EurekaInstanceConfig eurekaConfig;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    @Autowired
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; PropertiesFactory propertiesFactory;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; EurekaRibbonClientConfiguration() {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; EurekaRibbonClientConfiguration(EurekaClientConfig clientConfig,
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;            String serviceId, EurekaInstanceConfig eurekaConfig,
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; approximateZoneFromHostname) {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.clientConfig =&lt;span&gt; clientConfig;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.serviceId =&lt;span&gt; serviceId;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.eurekaConfig =&lt;span&gt; eurekaConfig;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.approximateZoneFromHostname =&lt;span&gt; approximateZoneFromHostname;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt; &lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;    @ConditionalOnMissingBean
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; IPing ribbonPing(IClientConfig config) {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.propertiesFactory.isSet(IPing.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, serviceId)) {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.propertiesFactory.get(IPing.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, config, serviceId);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         NIWSDiscoveryPing ping = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NIWSDiscoveryPing();
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;        ping.initWithNiwsConfig(config);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ping;
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; 
&lt;span&gt;42&lt;/span&gt; &lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;    @ConditionalOnMissingBean
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; ServerList&amp;lt;?&amp;gt; ribbonServerList(IClientConfig config, Provider&amp;lt;EurekaClient&amp;gt;&lt;span&gt; eurekaClientProvider) {
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.propertiesFactory.isSet(ServerList.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, serviceId)) {
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.propertiesFactory.get(ServerList.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, config, serviceId);
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;         DiscoveryEnabledNIWSServerList discoveryServerList = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DiscoveryEnabledNIWSServerList(
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;                config, eurekaClientProvider);
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;         DomainExtractingServerList serverList = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DomainExtractingServerList(
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;                 discoveryServerList, config, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.approximateZoneFromHostname);
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; serverList;
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;⑦ 各个配置类所属模块&lt;/p&gt;
&lt;p&gt;spring-cloud-netflix-eureka-client：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;org.springframework.cloud.netflix.eureka.EurekaClientAutoConfiguration&lt;/li&gt;
&lt;li&gt;org.springframework.cloud.netflix.ribbon.eureka.RibbonEurekaAutoConfiguration&lt;/li&gt;
&lt;li&gt;org.springframework.cloud.netflix.ribbon.eureka.EurekaRibbonClientConfiguration&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;spring-cloud-netflix-ribbon：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;org.springframework.cloud.netflix.ribbon.RibbonAutoConfiguration&lt;/li&gt;
&lt;li&gt;org.springframework.cloud.netflix.ribbon.RibbonClientConfiguration&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;spring-cloud-commons：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;org.springframework.cloud.client.loadbalancer.LoadBalancerAutoConfiguration&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;六、Ribbon HTTP客户端组件&lt;/h2&gt;
&lt;h3&gt;1、Java HTTP 组件库&lt;/h3&gt;
&lt;p&gt;① HTTP 组件库&lt;/p&gt;
&lt;p&gt;首先简单了解下常用的 Java HTTP 组件库，Ribbon 中通过不同的配置便可以启用某个 HTTP 组件来进行服务间的通信。&lt;/p&gt;
&lt;p&gt;Java 中的 HTTP 组件库，大体可以分为三类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;JDK 自带的标准库 HttpURLConnection&lt;/li&gt;
&lt;li&gt;Apache HttpComponents HttpClient&lt;/li&gt;
&lt;li&gt;OkHttp&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;HttpURLConnection 发起 HTTP 请求最大的优点是不需要引入额外的依赖，但是 HttpURLConnection 封装层次太低，使用起来非常繁琐。支持的特性太少，缺乏连接池管理、域名机械控制，无法支持 HTTP/2等。&lt;/p&gt;
&lt;p&gt;Apache HttpComponents HttpClient 和 OkHttp 都支持连接池管理、超时、空闲连接数控制等特性。OkHttp 接口设计更友好，且支持 HTTP/2，Android 开发中用得更多。&lt;/p&gt;
&lt;p&gt;② 超时重试配置&lt;/p&gt;
&lt;p&gt;先给 demo-consumer 中添加如下默认配置，即读取、连接超时时间设置为 1 秒，这也是默认值。然后重试次数为1，重试一个Server。后面基于这些配置来验证Ribbon HTTP客户端的超时和重试。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;ribbon:
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;  # 客户端读取超时时间
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;   ReadTimeout: 1000
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;  # 客户端连接超时时间
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;   ConnectTimeout: 1000
&lt;span&gt; 6&lt;/span&gt;   # 默认只重试 GET，设置为 &lt;span&gt;true&lt;/span&gt;&lt;span&gt; 时将重试所有类型，如 POST、PUT、DELETE
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;   OkToRetryOnAllOperations: &lt;span&gt;false&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;  # 重试次数
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;   MaxAutoRetries: 1
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;  # 最多重试几个实例
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;   MaxAutoRetriesNextServer: 1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后 demo-producer 的接口休眠3秒，造成网络延迟的现象，并且 demo-producer 启两个实例。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; @GetMapping(&quot;/v1/uuid&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; ResponseEntity&amp;lt;String&amp;gt; getUUID() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     String uuid =&lt;span&gt; UUID.randomUUID().toString();
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     logger.info(&quot;generate uuid: {}&quot;&lt;span&gt;, uuid);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     Thread.sleep(3000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ResponseEntity.ok(uuid);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2、Ribbon 默认使用 HttpURLConnection&lt;/h3&gt;
&lt;p&gt;① Ribbon 默认的 HTTP 组件&lt;/p&gt;
&lt;p&gt;在不添加其它配置的情况下，我们来看下 Ribbon 默认使用的 HTTP 组件是什么。&lt;/p&gt;
&lt;p&gt;首先通过之前的分析可以知道，默认情况下，LoadBalancerAutoConfiguration 配置类会向 RestTemplate 添加 LoadBalancerInterceptor 拦截器。然后在 RestTemplate 调用时，即在 doExecute 方法中，创建 ClientHttpRequest 时，因为配置了拦截器，所以 ClientHttpRequestFactory 就是 InterceptingClientHttpRequestFactory，而且创建 InterceptingClientHttpRequestFactory 传入的 ClientHttpRequestFactory 默认是父类的 SimpleClientHttpRequestFactory。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_fbee5c7e-a5d4-44ce-ab7d-70c1a2fac850&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_fbee5c7e-a5d4-44ce-ab7d-70c1a2fac850&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_fbee5c7e-a5d4-44ce-ab7d-70c1a2fac850&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;69&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; &amp;lt;T&amp;gt;&lt;span&gt; T doExecute(URI url, @Nullable HttpMethod method, @Nullable RequestCallback requestCallback,
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         @Nullable ResponseExtractor&amp;lt;T&amp;gt; responseExtractor) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; RestClientException {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     ClientHttpResponse response = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建 ClientHttpRequest&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         ClientHttpRequest request =&lt;span&gt; createRequest(url, method);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (requestCallback != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            requestCallback.doWithRequest(request);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ClientHttpRequest 发起请求&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;         response =&lt;span&gt; request.execute();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        handleResponse(url, method, response);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; (responseExtractor != &lt;span&gt;null&lt;/span&gt; ? responseExtractor.extractData(response) : &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException ex) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (response != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;            response.close();
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; ClientHttpRequest createRequest(URI url, HttpMethod method) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; getRequestFactory 获取 ClientHttpRequestFactory&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;     ClientHttpRequest request =&lt;span&gt; getRequestFactory().createRequest(url, method);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;    initialize(request);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isDebugEnabled()) {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         logger.debug(&quot;HTTP &quot; + method.name() + &quot; &quot; +&lt;span&gt; url);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; request;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ClientHttpRequestFactory getRequestFactory() {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;     List&amp;lt;ClientHttpRequestInterceptor&amp;gt; interceptors =&lt;span&gt; getInterceptors();
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;CollectionUtils.isEmpty(interceptors)) {
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         ClientHttpRequestFactory factory = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.interceptingRequestFactory;
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (factory == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 有拦截器的情况，super.getRequestFactory() 默认返回的是 SimpleClientHttpRequestFactory&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt;             factory = &lt;span&gt;new&lt;/span&gt; InterceptingClientHttpRequestFactory(&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.getRequestFactory(), interceptors);
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.interceptingRequestFactory =&lt;span&gt; factory;
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; factory;
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 无拦截器的情况&lt;/span&gt;
&lt;span&gt;49&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.getRequestFactory();
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;InterceptingClientHttpRequestFactory 这个工厂类创建的 ClientHttpRequest 类型是 InterceptingClientHttpRequest。最终 RestTemplate 的 doExecute 方法中调用 ClientHttpRequest 的 execute 方法时，就调用到了 InterceptingClientHttpRequest 中的内部类 InterceptingRequestExecution 中。&lt;/p&gt;
&lt;p&gt;在 InterceptingRequestExecution 的 execute 方法中，首先是遍历所有拦截器对 RestTemplate 定制化，最后则通过 requestFactory 创建 ClientHttpRequest 来发起最终的 HTTP 调用。从这里可以看出，无论有没有拦截器，其实最终都会使用 requestFactory 来创建 ClientHttpRequest。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; InterceptingRequestExecution &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; ClientHttpRequestExecution {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Iterator&amp;lt;ClientHttpRequestInterceptor&amp;gt;&lt;span&gt; iterator;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; ClientHttpResponse execute(HttpRequest request, &lt;span&gt;byte&lt;/span&gt;[] body) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.iterator.hasNext()) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 拦截器定制化 RestTemplate&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;             ClientHttpRequestInterceptor nextInterceptor = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.iterator.next();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; nextInterceptor.intercept(request, body, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             HttpMethod method =&lt;span&gt; request.getMethod();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; delegate =&amp;gt; SimpleBufferingClientHttpRequest&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;             ClientHttpRequest delegate =&lt;span&gt; requestFactory.createRequest(request.getURI(), method);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; delegate.execute();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里的 requestFactory 就是前面传进来的 SimpleClientHttpRequestFactory，从它的 createRequest 方法可以看出，默认情况下，就是用的 JDK 标准 HTTP 库组件 HttpURLConnection 来进行服务间的请求通信。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; ClientHttpRequest createRequest(URI uri, HttpMethod httpMethod) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; JDK 标准HTTP库 HttpURLConnection&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     HttpURLConnection connection = openConnection(uri.toURL(), &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.proxy);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    prepareConnection(connection, httpMethod.name());
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.bufferRequestBody) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; SimpleBufferingClientHttpRequest(connection, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.outputStreaming);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; SimpleStreamingClientHttpRequest(connection, &lt;span&gt;this&lt;/span&gt;.chunkSize, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.outputStreaming);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;总结：&lt;/p&gt;
&lt;p&gt;从前面的源码分析可以看出，Ribbon 默认的 HTTP 客户端是 HttpURLConnection。&lt;/p&gt;
&lt;p&gt;在前面默认的超时配置下，可以验证出超时配置并未生效，一直阻塞3秒后才返回了结果，说明 Ribbon 默认情况下就不支持超时重试。&lt;/p&gt;
&lt;p&gt;而且 HttpURLConnection 每次都是新创建的，请求返回来之后就关闭连接，没有连接池管理机制，网络连接的建立和关闭本身就会损耗一定的性能，所以正式环境下，最好不要使用默认的配置。&lt;/p&gt;
&lt;p&gt;② HttpClient 配置类&lt;/p&gt;
&lt;p&gt;另外，我们从 RibbonClientConfiguration 配置类的定义可以看到，其导入了 HttpClientConfiguration、OkHttpRibbonConfiguration、RestClientRibbonConfiguration、HttpClientRibbonConfiguration 四个 HttpClient 的配置类，通过注释也可以了解到，最后一个是默认配置类，前面三个在某些配置启用的情况下才会生效。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; @Configuration(proxyBeanMethods = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;@EnableConfigurationProperties
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Order is important here, last should be the default, first should be optional&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; @Import({ HttpClientConfiguration.&lt;span&gt;class&lt;/span&gt;, OkHttpRibbonConfiguration.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         RestClientRibbonConfiguration.&lt;span&gt;class&lt;/span&gt;, HttpClientRibbonConfiguration.&lt;span&gt;class&lt;/span&gt;&lt;span&gt; })
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RibbonClientConfiguration {
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; 
&lt;span&gt;8&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;进入 HttpClientRibbonConfiguration，这个配置类在 ribbon.httpclient.enabled=true 时才生效，而且默认为 true。在从 SpringClientFactory 中获取 ILoadBalancer 时，会通过这个配置类初始化 HttpClient，按先后顺序会初始化 HttpClientConnectionManager、CloseableHttpClient、RibbonLoadBalancingHttpClient。CloseableHttpClient 是 Apache HttpComponents HttpClient 中的组件，也就是说默认情况下应该是使用 apache HttpComponents 作为 HTTP 组件库。&lt;/p&gt;
&lt;p&gt;但经过前面源码的分析，以及测试发现，最终其实走的的 HttpURLConnection，并没有用到 CloseableHttpClient。把 ribbon.httpclient.enabled 设置为 false，也没有什么影响，还是默认走 HttpURLConnection。我们后面再来分析这个问题。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_aaddf497-1cbb-4bb7-921e-2d76f8f9dc7d&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_aaddf497-1cbb-4bb7-921e-2d76f8f9dc7d&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_aaddf497-1cbb-4bb7-921e-2d76f8f9dc7d&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;89&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; @Configuration(proxyBeanMethods = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; @ConditionalOnClass(name = &quot;org.apache.http.client.HttpClient&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ribbon.httpclient.enabled more文为 true&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; @ConditionalOnProperty(name = &quot;ribbon.httpclient.enabled&quot;, matchIfMissing = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HttpClientRibbonConfiguration {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    @RibbonClientName
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; String name = &quot;client&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; RibbonLoadBalancingHttpClient&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     @ConditionalOnMissingBean(AbstractLoadBalancerAwareClient.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     @ConditionalOnMissingClass(&quot;org.springframework.retry.support.RetryTemplate&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; RibbonLoadBalancingHttpClient ribbonLoadBalancingHttpClient(
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            IClientConfig config, ServerIntrospector serverIntrospector,
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            ILoadBalancer loadBalancer, RetryHandler retryHandler,
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            CloseableHttpClient httpClient) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         RibbonLoadBalancingHttpClient client = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RibbonLoadBalancingHttpClient(
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;                httpClient, config, serverIntrospector);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        client.setLoadBalancer(loadBalancer);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        client.setRetryHandler(retryHandler);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         Monitors.registerObject(&quot;Client_&quot; + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name, client);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; client;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在引入了 spring-retry 时，即可以重试的 RetryTemplate 时，就创建 RetryableRibbonLoadBalancingHttpClient&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     @ConditionalOnMissingBean(AbstractLoadBalancerAwareClient.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     @ConditionalOnClass(name = &quot;org.springframework.retry.support.RetryTemplate&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; RetryableRibbonLoadBalancingHttpClient retryableRibbonLoadBalancingHttpClient(
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;            IClientConfig config, ServerIntrospector serverIntrospector,
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;            ILoadBalancer loadBalancer, RetryHandler retryHandler,
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;            LoadBalancedRetryFactory loadBalancedRetryFactory,
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;            CloseableHttpClient httpClient,
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;            RibbonLoadBalancerContext ribbonLoadBalancerContext) {
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         RetryableRibbonLoadBalancingHttpClient client = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RetryableRibbonLoadBalancingHttpClient(
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;                httpClient, config, serverIntrospector, loadBalancedRetryFactory);
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;        client.setLoadBalancer(loadBalancer);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;        client.setRetryHandler(retryHandler);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;        client.setRibbonLoadBalancerContext(ribbonLoadBalancerContext);
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;         Monitors.registerObject(&quot;Client_&quot; + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name, client);
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; client;
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; 
&lt;span&gt;45&lt;/span&gt;     @Configuration(proxyBeanMethods = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ApacheHttpClientConfiguration {
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; 
&lt;span&gt;48&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Timer connectionManagerTimer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Timer(
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;                 &quot;RibbonApacheHttpClientConfiguration.connectionManagerTimer&quot;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; 
&lt;span&gt;51&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt;&lt;span&gt; CloseableHttpClient httpClient;
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; 
&lt;span&gt;53&lt;/span&gt;         @Autowired(required = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt;&lt;span&gt; RegistryBuilder registryBuilder;
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; 
&lt;span&gt;56&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; HttpClient 连接池管理器&lt;/span&gt;
&lt;span&gt;57&lt;/span&gt; &lt;span&gt;        @Bean
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;         @ConditionalOnMissingBean(HttpClientConnectionManager.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; HttpClientConnectionManager httpClientConnectionManager(
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; &lt;span&gt;                IClientConfig config,
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; &lt;span&gt;                ApacheHttpClientConnectionManagerFactory connectionManagerFactory) {
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;             RibbonProperties ribbon =&lt;span&gt; RibbonProperties.from(config);
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; maxTotalConnections =&lt;span&gt; ribbon.maxTotalConnections();
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; maxConnectionsPerHost =&lt;span&gt; ribbon.maxConnectionsPerHost();
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; timerRepeat =&lt;span&gt; ribbon.connectionCleanerRepeatInterval();
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;             &lt;span&gt;long&lt;/span&gt; timeToLive =&lt;span&gt; ribbon.poolKeepAliveTime();
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;             TimeUnit ttlUnit =&lt;span&gt; ribbon.getPoolKeepAliveTimeUnits();
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;             &lt;span&gt;final&lt;/span&gt; HttpClientConnectionManager connectionManager =&lt;span&gt; connectionManagerFactory
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;                     .newConnectionManager(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;, maxTotalConnections,
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; &lt;span&gt;                            maxConnectionsPerHost, timeToLive, ttlUnit, registryBuilder);
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.connectionManagerTimer.schedule(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; TimerTask() {
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt; &lt;span&gt;                @Override
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt;                 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt; &lt;span&gt;                    connectionManager.closeExpiredConnections();
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt;             }, 30000&lt;span&gt;, timerRepeat);
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; connectionManager;
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt; 
&lt;span&gt;80&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; HttpClient =&amp;gt; CloseableHttpClient&lt;/span&gt;
&lt;span&gt;81&lt;/span&gt; &lt;span&gt;        @Bean
&lt;/span&gt;&lt;span&gt;82&lt;/span&gt;         @ConditionalOnMissingBean(CloseableHttpClient.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;83&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; CloseableHttpClient httpClient(ApacheHttpClientFactory httpClientFactory,
&lt;/span&gt;&lt;span&gt;84&lt;/span&gt; &lt;span&gt;                HttpClientConnectionManager connectionManager, IClientConfig config) {
&lt;/span&gt;&lt;span&gt;85&lt;/span&gt;             RibbonProperties ribbon =&lt;span&gt; RibbonProperties.from(config);
&lt;/span&gt;&lt;span&gt;86&lt;/span&gt;             Boolean followRedirects =&lt;span&gt; ribbon.isFollowRedirects();
&lt;/span&gt;&lt;span&gt;87&lt;/span&gt;             Integer connectTimeout =&lt;span&gt; ribbon.connectTimeout();
&lt;/span&gt;&lt;span&gt;88&lt;/span&gt;             RequestConfig defaultRequestConfig =&lt;span&gt; RequestConfig.custom()
&lt;/span&gt;&lt;span&gt;89&lt;/span&gt; &lt;span&gt;                    .setConnectTimeout(connectTimeout)
&lt;/span&gt;&lt;span&gt;90&lt;/span&gt; &lt;span&gt;                    .setRedirectsEnabled(followRedirects).build();
&lt;/span&gt;&lt;span&gt;91&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.httpClient =&lt;span&gt; httpClientFactory.createBuilder()
&lt;/span&gt;&lt;span&gt;92&lt;/span&gt; &lt;span&gt;                    .setDefaultRequestConfig(defaultRequestConfig)
&lt;/span&gt;&lt;span&gt;93&lt;/span&gt; &lt;span&gt;                    .setConnectionManager(connectionManager).build();
&lt;/span&gt;&lt;span&gt;94&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; httpClient;
&lt;/span&gt;&lt;span&gt;95&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;96&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;97&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;③ 默认配置下的 RestTemplate 的调用过程大致可以用下图来表示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202012/856154-20201223223322089-1060203106.png&quot; width=&quot;1000&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3、启用 RestClient&lt;/h3&gt;
&lt;p&gt;① 启用 RestClient&lt;/p&gt;
&lt;p&gt;可以添加如下配置启用 RestClient：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;ribbon:
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;  # 关闭 httpclient
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;  httpclient:
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     enabled: &lt;span&gt;false&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;  # 启用 RestClient
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;  restclient:
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     enabled: &lt;span&gt;true&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;  # 启用 RestClient
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;  http:
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    client:
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;       enabled: &lt;span&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;进入 RestClientRibbonConfiguration  可以看到，只要 ribbon.http.client.enabled、ribbon.restclient.enabled 其中一个配置了启用，就可以启用 RestClient。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; @SuppressWarnings(&quot;deprecation&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; @Configuration(proxyBeanMethods = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 启用条件 ConditionalOnRibbonRestClient&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;@RibbonAutoConfiguration.ConditionalOnRibbonRestClient
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RestClientRibbonConfiguration {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    @RibbonClientName
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; String name = &quot;client&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; RestClient 已过期&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    @Lazy
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     @ConditionalOnMissingBean(AbstractLoadBalancerAwareClient.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; RestClient ribbonRestClient(IClientConfig config, ILoadBalancer loadBalancer,
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            ServerIntrospector serverIntrospector, RetryHandler retryHandler) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         RestClient client = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RibbonClientConfiguration.OverrideRestClient(config, serverIntrospector);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        client.setLoadBalancer(loadBalancer);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        client.setRetryHandler(retryHandler);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; client;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;@Target({ ElementType.TYPE, ElementType.METHOD })
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;@Retention(RetentionPolicy.RUNTIME)
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;@Documented
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; @Conditional(OnRibbonRestClientCondition.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; ConditionalOnRibbonRestClient {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; OnRibbonRestClientCondition &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; AnyNestedCondition {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     @Deprecated &lt;span&gt;//&lt;/span&gt;&lt;span&gt; remove in Edgware&quot;&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;     @ConditionalOnProperty(&quot;ribbon.http.client.enabled&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ZuulProperty {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt;     @ConditionalOnProperty(&quot;ribbon.restclient.enabled&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RibbonProperty {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;RestClient 继承自 AbstractLoadBalancerAwareClient。需要注意的是，RestClient 已经过期，所以生产环境中我们就不要启用 RestTemplate 了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;@Deprecated
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; RestClient &lt;span&gt;extends&lt;/span&gt; AbstractLoadBalancerAwareClient&amp;lt;HttpRequest, HttpResponse&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; 
&lt;span&gt;4&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;② LoadBalancerContext 类体系结构&lt;/p&gt;
&lt;p&gt;负载均衡上下文 LoadBalancerContext 体系的类结构如下。可以看出，Ribbon 是支持 Feign、OkHttp、HttpClient、RestClient 的。默认配置下使用的实现类是 RibbonLoadBalancerContext。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202012/856154-20201223212456447-1178386001.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;③ RestTemplate 的 ClientHttpRequest 工厂类配置&lt;/p&gt;
&lt;p&gt;接着看 RibbonAutoConfiguration 中有如下的配置，跟前面 RestClientRibbonConfiguration 也是一样，满足 @ConditionalOnRibbonRestClient 的条件。&lt;/p&gt;
&lt;p&gt;可以看到，它会创建 RibbonClientHttpRequestFactory 并设置到 RestTemplate 中，也就是说，这时 RestTemplate 中的 requestFactory 就不是默认的 SimpleClientHttpRequestFactory 了，而是 RibbonClientHttpRequestFactory。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; @Configuration(proxyBeanMethods = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; @ConditionalOnClass(HttpRequest.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;@ConditionalOnRibbonRestClient
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RibbonClientHttpRequestFactoryConfiguration {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    @Autowired
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; SpringClientFactory springClientFactory;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; RestTemplateCustomizer restTemplateCustomizer(
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;final&lt;/span&gt;&lt;span&gt; RibbonClientHttpRequestFactory ribbonClientHttpRequestFactory) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; RestTemplate 设置 requestFactory 为 RibbonClientHttpRequestFactory&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; restTemplate -&amp;gt;&lt;span&gt; restTemplate
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;                .setRequestFactory(ribbonClientHttpRequestFactory);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ClientHttpRequest 工厂类 =&amp;gt; RibbonClientHttpRequestFactory&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; RibbonClientHttpRequestFactory ribbonClientHttpRequestFactory() {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RibbonClientHttpRequestFactory(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.springClientFactory);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而且，由于这里配置了 RestTemplateCustomizer，原本默认配置下，在 LoadBalancerAutoConfiguration 中创建 RestTemplateCustomizer 的方法就不会生效了。&lt;/p&gt;
&lt;p&gt;LoadBalancerAutoConfiguration 中的 RestTemplateCustomizer 是向 RestTemplate 中添加 LoadBalancerInterceptor 拦截器，所以在启用了 RestClient 的情况下，原本的 LoadBalancerInterceptor 就不会生效了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33.5&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_938f15c9-3b3b-432f-8392-f9e987155915&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_938f15c9-3b3b-432f-8392-f9e987155915&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_938f15c9-3b3b-432f-8392-f9e987155915&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; @Configuration(proxyBeanMethods = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; @ConditionalOnMissingClass(&quot;org.springframework.retry.support.RetryTemplate&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LoadBalancerInterceptorConfig {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; LoadBalancerInterceptor ribbonInterceptor(
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;            LoadBalancerClient loadBalancerClient,
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;            LoadBalancerRequestFactory requestFactory) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LoadBalancerInterceptor(loadBalancerClient, requestFactory);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    @ConditionalOnMissingBean
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; RestTemplateCustomizer restTemplateCustomizer(
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;final&lt;/span&gt;&lt;span&gt; LoadBalancerInterceptor loadBalancerInterceptor) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; restTemplate -&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             List&amp;lt;ClientHttpRequestInterceptor&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;(
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;                    restTemplate.getInterceptors());
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;            list.add(loadBalancerInterceptor);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;            restTemplate.setInterceptors(list);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        };
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;那么 RestTemplate 的 doExecute 方法中，在调用 createRequest 方法创建 ClientHttpRequest 时，就会用 RibbonClientHttpRequestFactory 来创建，进去可以看到 ClientHttpRequest 的实际类型就是 RibbonHttpRequest。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; ClientHttpRequest createRequest(URI originalUri, HttpMethod httpMethod) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     String serviceId =&lt;span&gt; originalUri.getHost();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (serviceId == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IOException(&quot;Invalid hostname in the URI [&quot; + originalUri.toASCIIString() + &quot;]&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     IClientConfig clientConfig = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.clientFactory.getClientConfig(serviceId);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     RestClient client = &lt;span&gt;this&lt;/span&gt;.clientFactory.getClient(serviceId, RestClient.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     HttpRequest.Verb verb =&lt;span&gt; HttpRequest.Verb.valueOf(httpMethod.name());
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RibbonHttpRequest(originalUri, verb, client, clientConfig);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用 RibbonHttpRequest 的 execute 方法，实际组中是调用了它的 executeInternal 方法，然后最后是使用 RestClient 来发起负载均衡的调用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; ClientHttpResponse executeInternal(HttpHeaders headers) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         HttpRequest request =&lt;span&gt; builder.build();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; client =&amp;gt; RestClient&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         HttpResponse response =&lt;span&gt; client.executeWithLoadBalancer(request, config);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RibbonHttpResponse(response);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IOException(e);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;④ RestClient HTTP 调用&lt;/p&gt;
&lt;p&gt;RestClient 的 executeWithLoadBalancer 实际是进入到父类 AbstractLoadBalancerAwareClient 的 executeWithLoadBalancer  方法中。&lt;/p&gt;
&lt;p&gt;从这个方法可以知道，主要的负载均衡请求是在 LoadBalancerCommand 中的，LoadBalancerCommand 必定会通过负载均衡器 ILoadBalancer 得到一个 Server，然后通过 submit 的这个 ServerOperation 对原始URI进行重构，重构之后调用 RestClient 的 execute 发起HTTP请求。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; T executeWithLoadBalancer(&lt;span&gt;final&lt;/span&gt; S request, &lt;span&gt;final&lt;/span&gt; IClientConfig requestConfig) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ClientException {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 负载均衡命令&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     LoadBalancerCommand&amp;lt;T&amp;gt; command =&lt;span&gt; buildLoadBalancerCommand(request, requestConfig);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 发起负载均衡请求&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; command.submit(
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;new&lt;/span&gt; ServerOperation&amp;lt;T&amp;gt;&lt;span&gt;() {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;                @Override
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 &lt;span&gt;public&lt;/span&gt; Observable&amp;lt;T&amp;gt;&lt;span&gt; call(Server server) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 重构 URI，将服务名用 Server 的 IP 和端口替换&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;                     URI finalUri =&lt;span&gt; reconstructURIWithServer(server, request.getUri());
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                     S requestForServer =&lt;span&gt; (S) request.replaceUri(finalUri);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; execute 发起调用，实际调用的是 RestClient 中的 execute&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;                         &lt;span&gt;return&lt;/span&gt; Observable.just(AbstractLoadBalancerAwareClient.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.execute(requestForServer, requestConfig));
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                     &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Observable.error(e);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;            })
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;            .toBlocking()
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;            .single();
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;....&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再看 RestClient 的 execute 方法，最终可以发现，RestClient 其实是使用基于 jersey 的 WebResource 来发起 HTTP 请求的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_6c1c3320-b899-45b3-a40c-46e1b3a0b48e&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_6c1c3320-b899-45b3-a40c-46e1b3a0b48e&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_6c1c3320-b899-45b3-a40c-46e1b3a0b48e&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;73&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt;&lt;span&gt; HttpResponse execute(HttpRequest.Verb verb, URI uri,
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         Map&amp;lt;String, Collection&amp;lt;String&amp;gt;&amp;gt; headers, Map&amp;lt;String, Collection&amp;lt;String&amp;gt;&amp;gt;&lt;span&gt; params,
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         IClientConfig overriddenClientConfig, Object requestEntity) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; WebResource 是基于 jersey 封装的 HTTP 客户端组件&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     WebResource xResource =&lt;span&gt; restClient.resource(uri.toString());
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    ClientResponse jerseyResponse;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     Builder b =&lt;span&gt; xResource.getRequestBuilder();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     Object entity =&lt;span&gt; requestEntity;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (verb) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;case&lt;/span&gt;&lt;span&gt; GET:
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         jerseyResponse = b.get(ClientResponse.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;case&lt;/span&gt;&lt;span&gt; POST:
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         jerseyResponse = b.post(ClientResponse.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, entity);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;case&lt;/span&gt;&lt;span&gt; PUT:
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         jerseyResponse = b.put(ClientResponse.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, entity);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;case&lt;/span&gt;&lt;span&gt; DELETE:
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         jerseyResponse = b.delete(ClientResponse.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;case&lt;/span&gt;&lt;span&gt; HEAD:
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         jerseyResponse =&lt;span&gt; b.head();
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;case&lt;/span&gt;&lt;span&gt; OPTIONS:
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         jerseyResponse = b.options(ClientResponse.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ClientException(
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;                ClientException.ErrorType.GENERAL,
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                 &quot;You have to one of the REST verbs such as GET, POST etc.&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt;     thisResponse = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpClientResponse(jerseyResponse, uri, overriddenClientConfig);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (thisResponse.getStatus() == 503&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;        thisResponse.close();
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ClientException(ClientException.ErrorType.SERVER_THROTTLED);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; thisResponse;
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;⑤ 最后，RestTemplate 基于 RestClient 的请求流程可以用下图来做个总结。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202012/856154-20201223230954406-1358305609.png&quot; width=&quot;1000&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;4、Apache HttpClient 或 OkHttp 对 RestTemplate 不生效（BUG？）&lt;/h3&gt;
&lt;p&gt;① Apache HttpClient&lt;/p&gt;
&lt;p&gt;默认情况下，ribbon.httpclient.enabled=true，在 HttpClientRibbonConfiguration 中会初始化 apache httpcomponents 相关的组件，前已经分析过了，但是在 RestTemplate 中并未使用相关的组件。&lt;/p&gt;
&lt;p&gt;也就是说，默认情况下启用了 apache httpcomponents，但是 RestTemplate 最后是使用 HttpURLConnection 来发起 HTTP 请求的，而不是配置的 CloseableHttpClient。&lt;/p&gt;
&lt;p&gt;② OkHttp&lt;/p&gt;
&lt;p&gt;首先需要加入 OkHttp 的依赖：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.squareup.okhttp3&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;okhttp&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后添加如下配置就可以启用 OkHttp：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1 &lt;span&gt;ribbon:
&lt;span&gt;2 &lt;span&gt;  httpclient:
&lt;span&gt;3     enabled: &lt;span&gt;false
&lt;span&gt;4 &lt;span&gt;  # 启用 okhttp
&lt;span&gt;5 &lt;span&gt;  okhttp:
&lt;span&gt;6     enabled: &lt;span&gt;true&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;配置 ribbon.okhttp.enabled=true 后，在 OkHttpRibbonConfiguration 中会初始化 OkHttp 相关的组件。&lt;/p&gt;
&lt;p&gt;但是调试之后会发现，其实它还是走的默认的流程，就是最终用 HttpURLConnection 发起 HTTP 请求，跟 httpcomponents 是一样的效果。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44.5&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_494a5d64-ed44-416e-9cb3-29d72de17650&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_494a5d64-ed44-416e-9cb3-29d72de17650&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_494a5d64-ed44-416e-9cb3-29d72de17650&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;84&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; @Configuration(proxyBeanMethods = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; @ConditionalOnProperty(&quot;ribbon.okhttp.enabled&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; @ConditionalOnClass(name = &quot;okhttp3.OkHttpClient&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OkHttpRibbonConfiguration {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    @RibbonClientName
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; String name = &quot;client&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     @ConditionalOnMissingBean(AbstractLoadBalancerAwareClient.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     @ConditionalOnClass(name = &quot;org.springframework.retry.support.RetryTemplate&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; RetryableOkHttpLoadBalancingClient retryableOkHttpLoadBalancingClient(
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            IClientConfig config, ServerIntrospector serverIntrospector,
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            ILoadBalancer loadBalancer, RetryHandler retryHandler,
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            LoadBalancedRetryFactory loadBalancedRetryFactory, OkHttpClient delegate,
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            RibbonLoadBalancerContext ribbonLoadBalancerContext) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         RetryableOkHttpLoadBalancingClient client = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RetryableOkHttpLoadBalancingClient(
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;                delegate, config, serverIntrospector, loadBalancedRetryFactory);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        client.setLoadBalancer(loadBalancer);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        client.setRetryHandler(retryHandler);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        client.setRibbonLoadBalancerContext(ribbonLoadBalancerContext);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         Monitors.registerObject(&quot;Client_&quot; + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name, client);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; client;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     @ConditionalOnMissingBean(AbstractLoadBalancerAwareClient.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     @ConditionalOnMissingClass(&quot;org.springframework.retry.support.RetryTemplate&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; OkHttpLoadBalancingClient okHttpLoadBalancingClient(IClientConfig config,
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;            ServerIntrospector serverIntrospector, ILoadBalancer loadBalancer,
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;            RetryHandler retryHandler, OkHttpClient delegate) {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         OkHttpLoadBalancingClient client = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; OkHttpLoadBalancingClient(delegate, config,
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;                serverIntrospector);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;        client.setLoadBalancer(loadBalancer);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;        client.setRetryHandler(retryHandler);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         Monitors.registerObject(&quot;Client_&quot; + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name, client);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; client;
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; 
&lt;span&gt;40&lt;/span&gt;     @Configuration(proxyBeanMethods = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OkHttpClientConfiguration {
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; 
&lt;span&gt;43&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt;&lt;span&gt; OkHttpClient httpClient;
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; 
&lt;span&gt;45&lt;/span&gt; &lt;span&gt;        @Bean
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;         @ConditionalOnMissingBean(ConnectionPool.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ConnectionPool httpClientConnectionPool(IClientConfig config,
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;                OkHttpClientConnectionPoolFactory connectionPoolFactory) {
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;             RibbonProperties ribbon =&lt;span&gt; RibbonProperties.from(config);
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; maxTotalConnections =&lt;span&gt; ribbon.maxTotalConnections();
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;             &lt;span&gt;long&lt;/span&gt; timeToLive =&lt;span&gt; ribbon.poolKeepAliveTime();
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;             TimeUnit ttlUnit =&lt;span&gt; ribbon.getPoolKeepAliveTimeUnits();
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; connectionPoolFactory.create(maxTotalConnections, timeToLive, ttlUnit);
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; 
&lt;span&gt;56&lt;/span&gt; &lt;span&gt;        @Bean
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;         @ConditionalOnMissingBean(OkHttpClient.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; OkHttpClient client(OkHttpClientFactory httpClientFactory,
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;                ConnectionPool connectionPool, IClientConfig config) {
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;             RibbonProperties ribbon =&lt;span&gt; RibbonProperties.from(config);
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.httpClient = httpClientFactory.createBuilder(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; &lt;span&gt;                    .connectTimeout(ribbon.connectTimeout(), TimeUnit.MILLISECONDS)
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; &lt;span&gt;                    .readTimeout(ribbon.readTimeout(), TimeUnit.MILLISECONDS)
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; &lt;span&gt;                    .followRedirects(ribbon.isFollowRedirects())
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt; &lt;span&gt;                    .connectionPool(connectionPool).build();
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.httpClient;
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt; 
&lt;span&gt;69&lt;/span&gt; &lt;span&gt;        @PreDestroy
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; destroy() {
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (httpClient != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt; &lt;span&gt;                httpClient.dispatcher().executorService().shutdown();
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt; &lt;span&gt;                httpClient.connectionPool().evictAll();
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt; 
&lt;span&gt;77&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt; 
&lt;span&gt;79&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Cod&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;③ 启用 HttpClient 或 OkHttp 不生效的原因&lt;/p&gt;
&lt;p&gt;经过前面的分析，可以知道启用 apache httpcomponents 或者 OkHttp，对 RestTemplate 都没有起作用，最终还是用 HttpURLConnection 发起 HTTP 请求。那为什么为出现这种情况呢？我们可以看下 RestTemplate  的 setRequestFactory 方法。&lt;/p&gt;
&lt;p&gt;通过 RestTemplate 的 setRequestFactory 方法的注释也可以了解到，默认的 requestFactory 是 SimpleClientHttpRequestFactory，它是基于 JDK 标准 HTTP 库的 HttpURLConnection。&lt;/p&gt;
&lt;p&gt;默认的 HttpURLConnection 不支持 PATCH，如果想支持，需设置为 Apache HttpComponents 或 OkHttp 的 request factory。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * Set the request factory that this accessor uses for obtaining client request handles.
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; * &amp;lt;p&amp;gt;The default is a {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; SimpleClientHttpRequestFactory} based on the JDK's own
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; * HTTP libraries ({&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; java.net.HttpURLConnection}).
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt; * &amp;lt;p&amp;gt;&amp;lt;b&amp;gt;Note that the standard JDK HTTP library does not support the HTTP PATCH method.
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt; * Configure the Apache HttpComponents or OkHttp request factory to enable PATCH.&amp;lt;/b&amp;gt;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@see&lt;/span&gt;&lt;span&gt; #createRequest(URI, HttpMethod)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@see&lt;/span&gt;&lt;span&gt; SimpleClientHttpRequestFactory
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@see&lt;/span&gt;&lt;span&gt; org.springframework.http.client.HttpComponentsAsyncClientHttpRequestFactory
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@see&lt;/span&gt;&lt;span&gt; org.springframework.http.client.OkHttp3ClientHttpRequestFactory
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setRequestFactory(ClientHttpRequestFactory requestFactory) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     Assert.notNull(requestFactory, &quot;ClientHttpRequestFactory must not be null&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.requestFactory =&lt;span&gt; requestFactory;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ClientHttpRequestFactory 体系类结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202012/856154-20201223235414070-2083193738.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那 RestClient 又是如何生效的呢？通过上一节的分析可以知道，在 RibbonAutoConfiguration 中有如下的配置，这个 RibbonClientHttpRequestFactoryConfiguration 通过自定义 RestTemplateCustomizer 向 RestTemplate 设置了 requestFactory 为 RibbonClientHttpRequestFactory。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; @Configuration(proxyBeanMethods = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; @ConditionalOnClass(HttpRequest.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;@ConditionalOnRibbonRestClient
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RibbonClientHttpRequestFactoryConfiguration {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    @Autowired
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; SpringClientFactory springClientFactory;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; RestTemplateCustomizer restTemplateCustomizer(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; RibbonClientHttpRequestFactory ribbonClientHttpRequestFactory) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; restTemplate -&amp;gt;&lt;span&gt; restTemplate.setRequestFactory(ribbonClientHttpRequestFactory);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; RibbonClientHttpRequestFactory ribbonClientHttpRequestFactory() {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RibbonClientHttpRequestFactory(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.springClientFactory);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;RibbonClientHttpRequestFactory 是对应 RestClient 的，也就是说要启用 OkHttp 或 HttpClient，还需自己创建对应的 ClientHttpRequestFactory，并设置给 RestTemplate。从上面的类结构可以看出，是提供了 HttpComponentsClientHttpRequestFactory 和 OkHttp3ClientHttpRequestFactory 工厂类了的。&lt;/p&gt;
&lt;p&gt;这里其实也比较奇怪，既然启用了 apache httpcomponents 或者 OkHttp，却没有创建默认的 ClientHttpRequestFactory 实现类设置给 RestTemplate，感觉这是 spring-cloud-netflix-ribbon 的一个 BUG。&lt;/p&gt;
&lt;h3&gt;5、定制 RestTemplate 使用 Apache httpcomponents&lt;/h3&gt;
&lt;p&gt;如果想让 RestTemplate 使用 httpcomponents  的组件，就需要自己创建一个 ClientHttpRequestFactory，并设置给 RestTemplate。下面我们一步步来看看如何修复这个问题。&lt;/p&gt;
&lt;p&gt;① 设置 HttpComponentsClientHttpRequestFactory&lt;/p&gt;
&lt;p&gt;httpcomponents  中提供的 ClientHttpRequestFactory 实现类是 HttpComponentsClientHttpRequestFactory，但是并不能直接使用这个工厂类，因为它创建的 HttpComponentsClientHttpRequest 不具备重试的能力，它直接使用 CloseableHttpClient 执行请求，虽然有超时的功能，但不能重试。而且，它本质上也没有负载均衡的能力，需要借助 LoadBalancerInterceptor 拦截器来重构 URI。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; HttpComponentsClientHttpRequest &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; AbstractBufferingClientHttpRequest {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; HttpClient httpClient;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; HttpUriRequest httpRequest;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; HttpContext httpContext;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; ClientHttpResponse executeInternal(HttpHeaders headers, &lt;span&gt;byte&lt;/span&gt;[] bufferedOutput) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; httpClient =&amp;gt; CloseableHttpClient&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         HttpResponse httpResponse = &lt;span&gt;this&lt;/span&gt;.httpClient.execute(&lt;span&gt;this&lt;/span&gt;.httpRequest, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.httpContext);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpComponentsClientHttpResponse(httpResponse);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所以，如果不需要重试的功能，可以直接创建一个 HttpComponentsClientHttpRequest，并设置给 RestTemplate 即可。这样就会使用 LoadBalancerInterceptor 来做负载均衡，重构 URI，然后用 HttpComponentsClientHttpRequest 来执行请求。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;@Bean
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;@LoadBalanced
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; RestTemplate restTemplate() {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     HttpComponentsClientHttpRequestFactory requestFactory = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpComponentsClientHttpRequestFactory();
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     RestTemplate restTemplate = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RestTemplate();
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;    restTemplate.setRequestFactory(requestFactory);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; restTemplate;
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;② 定制 apache ClientHttpRequestFactory&lt;/p&gt;
&lt;p&gt;如果想让 RestTemplate 即有负载均衡的能力，又能使用 apache HttpComponents 组件，且具备重试的功能，我们就需要自己定制 ClientHttpRequestFactory 了。关于重试后面再单独来讲。&lt;/p&gt;
&lt;p&gt;对比 RestClient 可以发现，RibbonClientHttpRequestFactory 创建的 RibbonHttpRequest 其实是使用 RestClient 执行请求，而 RestClient  内部使用 LoadBalancerCommand 来进行重试。&lt;/p&gt;
&lt;p&gt;类似的，我们至少要用上已经配置好的 RibbonLoadBalancingHttpClient 来执行请求，所以需要自定义一个类似的 RibbonHttpRequest 。&lt;/p&gt;
&lt;p&gt;1）定制 apache ClientHttpRequest&lt;/p&gt;
&lt;p&gt;创建 ApacheClientHttpRequest 继承自 RibbonHttpRequest，核心的点在于要注入 RibbonLoadBalancingHttpClient，如果要支持重试，需注入 RetryableRibbonLoadBalancingHttpClient。RetryableRibbonLoadBalancingHttpClient 在引入 spring-retry 后才会创建，这个后面分析重试时再看。&lt;/p&gt;
&lt;p&gt;然后在 executeInternal 根据 retryable 判断，如果要重试，就调用 execute 方法，看 RetryableRibbonLoadBalancingHttpClient 的源码可以发现，它本身是支持负载均衡的，会自动选择 Server。&lt;/p&gt;
&lt;p&gt;如果不需要重试，就需要调用 executeWithLoadBalancer，它是利用 LoadBalancerCommand 来提交请求，就跟 RestClient 是一样的了。但是不一样的地方是 RibbonLoadBalancingHttpClient 的 executeWithLoadBalancer 是不会进行重试的，这个也放到后面分析。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_378e88a5-0c8e-4ca7-97b2-1a5f162fcc85&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_378e88a5-0c8e-4ca7-97b2-1a5f162fcc85&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_378e88a5-0c8e-4ca7-97b2-1a5f162fcc85&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;77&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.lyyzoo.sunny.register.ribbon.apache;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.net.URI;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.ArrayList;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.netflix.client.config.IClientConfig;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.netflix.client.http.HttpResponse;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cloud.netflix.ribbon.RibbonHttpRequest;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cloud.netflix.ribbon.RibbonHttpResponse;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cloud.netflix.ribbon.apache.RetryableRibbonLoadBalancingHttpClient;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cloud.netflix.ribbon.apache.RibbonApacheHttpRequest;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cloud.netflix.ribbon.apache.RibbonLoadBalancingHttpClient;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cloud.netflix.ribbon.support.RibbonCommandContext;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.http.HttpHeaders;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.http.HttpMethod;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.http.client.ClientHttpResponse;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.util.LinkedMultiValueMap;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt; * Apache ClientHttpRequest
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt; *
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; bojiangzhou
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ApacheClientHttpRequest &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; RibbonHttpRequest {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; URI uri;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; HttpMethod httpMethod;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; String serviceId;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; RibbonLoadBalancingHttpClient client;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; IClientConfig config;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt; &lt;span&gt;     * 是否重试
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; retryable;
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; 
&lt;span&gt;41&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ApacheClientHttpRequest(URI uri,
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;                                   HttpMethod httpMethod,
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;                                   String serviceId,
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;                                   RibbonLoadBalancingHttpClient client,
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;                                   IClientConfig config,
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;                                    &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; retryable) {
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;         &lt;span&gt;super&lt;/span&gt;(uri, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;, config);
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.uri =&lt;span&gt; uri;
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.httpMethod =&lt;span&gt; httpMethod;
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.serviceId =&lt;span&gt; serviceId;
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.client =&lt;span&gt; client;
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.config =&lt;span&gt; config;
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.retryable =&lt;span&gt; retryable;
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (retryable &amp;amp;&amp;amp; !(client &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; RetryableRibbonLoadBalancingHttpClient)) {
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&quot;Retryable client must be RetryableRibbonLoadBalancingHttpClient&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; 
&lt;span&gt;59&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; ClientHttpResponse executeInternal(HttpHeaders headers) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;             RibbonCommandContext ribbonCommandContext = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RibbonCommandContext(serviceId, httpMethod.name(),
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;                     uri.toString(), retryable, headers, &lt;span&gt;new&lt;/span&gt; LinkedMultiValueMap&amp;lt;&amp;gt;(), &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;());
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; 
&lt;span&gt;65&lt;/span&gt;             RibbonApacheHttpRequest request = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RibbonApacheHttpRequest(ribbonCommandContext);
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; 
&lt;span&gt;67&lt;/span&gt; &lt;span&gt;            HttpResponse response;
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (retryable) {
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; RetryableRibbonLoadBalancingHttpClient 本身具备负载均衡的能力&lt;/span&gt;
&lt;span&gt;70&lt;/span&gt;                 response =&lt;span&gt; client.execute(request, config);
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; RibbonLoadBalancingHttpClient 需调用 executeWithLoadBalancer 才具备负载均衡的能力&lt;/span&gt;
&lt;span&gt;73&lt;/span&gt;                 response =&lt;span&gt; client.executeWithLoadBalancer(request, config);
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt; 
&lt;span&gt;76&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RibbonHttpResponse(response);
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IOException(e);
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;80&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;81&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;2）定制 apache ClientHttpRequestFactory&lt;/p&gt;
&lt;p&gt;创建 ApacheClientHttpRequestFactory 继承自 HttpComponentsClientHttpRequestFactory，主要是在 createRequest 方法中创建自定义的 ApacheClientHttpRequest。RibbonLoadBalancingHttpClient 可以从 SpringClientFactory 中获取。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36.5&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_8742c3d2-9b38-433d-a71b-261e8e9721bd&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_8742c3d2-9b38-433d-a71b-261e8e9721bd&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_8742c3d2-9b38-433d-a71b-261e8e9721bd&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;68&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.lyyzoo.sunny.register.ribbon.apache;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.net.URI;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.netflix.client.config.IClientConfig;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cloud.netflix.ribbon.SpringClientFactory;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cloud.netflix.ribbon.apache.RibbonLoadBalancingHttpClient;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.http.HttpMethod;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.http.client.ClientHttpRequest;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.http.client.HttpComponentsClientHttpRequestFactory;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.lang.NonNull;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt; * Apache HttpComponents ClientHttpRequest factory
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt; *
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; bojiangzhou
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ApacheClientHttpRequestFactory &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; HttpComponentsClientHttpRequestFactory {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; SpringClientFactory clientFactory;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; retryable;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; ApacheClientHttpRequestFactory(SpringClientFactory clientFactory, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; retryable) {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.clientFactory =&lt;span&gt; clientFactory;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.retryable =&lt;span&gt; retryable;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    @NonNull
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; ClientHttpRequest createRequest(URI originalUri, HttpMethod httpMethod) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         String serviceId =&lt;span&gt; originalUri.getHost();
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (serviceId == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IOException(
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                     &quot;Invalid hostname in the URI [&quot; + originalUri.toASCIIString() + &quot;]&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         IClientConfig clientConfig = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.clientFactory.getClientConfig(serviceId);
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         RibbonLoadBalancingHttpClient httpClient = &lt;span&gt;this&lt;/span&gt;.clientFactory.getClient(serviceId, RibbonLoadBalancingHttpClient.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; 
&lt;span&gt;40&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ApacheClientHttpRequest(originalUri, httpMethod, serviceId, httpClient, clientConfig, retryable);
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;3）定制 apache ClientHttpRequestFactory 配置类&lt;/p&gt;
&lt;p&gt;跟 RestClient 的配置类类似，定制 ApacheClientHttpRequestFactory 的配置类，同样的，默认启用 httpclient。在存在 RetryTemplate 时，就设置 ApacheClientHttpRequestFactory 的 retryable 参数为 true，否则为 false。&lt;/p&gt;
&lt;p&gt;然后自定义 RestTemplateCustomizer，将 ApacheClientHttpRequestFactory 设置到 RestTemplate 中，注意这时 LoadBalancerInterceptor 就不会添加到 RestTemplate 中了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_91d2f15b-f58c-483f-84eb-f09447d63736&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_91d2f15b-f58c-483f-84eb-f09447d63736&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_91d2f15b-f58c-483f-84eb-f09447d63736&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.lyyzoo.sunny.register.ribbon.apache;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.http.client.HttpClient;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.autoconfigure.AutoConfigureAfter;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.autoconfigure.AutoConfigureBefore;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.autoconfigure.condition.ConditionalOnMissingClass;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cloud.client.loadbalancer.AsyncLoadBalancerAutoConfiguration;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cloud.client.loadbalancer.LoadBalancerAutoConfiguration;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cloud.client.loadbalancer.RestTemplateCustomizer;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cloud.netflix.ribbon.SpringClientFactory;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Bean;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Configuration;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.client.RestTemplate;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; &lt;span&gt; *
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; bojiangzhou
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;@Configuration
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; @ConditionalOnClass(RestTemplate.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; @AutoConfigureAfter(name = &quot;org.springframework.cloud.netflix.eureka.EurekaClientAutoConfiguration&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; @AutoConfigureBefore({LoadBalancerAutoConfiguration.&lt;span&gt;class&lt;/span&gt;, AsyncLoadBalancerAutoConfiguration.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;})
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; @ConditionalOnProperty(name = &quot;ribbon.httpclient.restTemplate.enabled&quot;, matchIfMissing = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ApacheClientHttpRequestFactoryConfiguration {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt;     @Configuration(proxyBeanMethods = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     @ConditionalOnClass(HttpClient.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     @ConditionalOnProperty(name = &quot;ribbon.httpclient.enabled&quot;, matchIfMissing = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HttpComponentsClientHttpRequestFactoryConfiguration {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt; &lt;span&gt;        @Autowired
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt;&lt;span&gt; SpringClientFactory springClientFactory;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt; &lt;span&gt;        @Bean
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;        @ConditionalOnMissingBean
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; RestTemplateCustomizer restTemplateCustomizer(
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;                 &lt;span&gt;final&lt;/span&gt;&lt;span&gt; ApacheClientHttpRequestFactory apacheClientHttpRequestFactory) {
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; restTemplate -&amp;gt;&lt;span&gt; restTemplate
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;                    .setRequestFactory(apacheClientHttpRequestFactory);
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; 
&lt;span&gt;46&lt;/span&gt; &lt;span&gt;        @Bean
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;         @ConditionalOnMissingClass(&quot;org.springframework.retry.support.RetryTemplate&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ApacheClientHttpRequestFactory apacheClientHttpRequestFactory() {
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ApacheClientHttpRequestFactory(springClientFactory, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; 
&lt;span&gt;52&lt;/span&gt; &lt;span&gt;        @Bean
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;         @ConditionalOnClass(name = &quot;org.springframework.retry.support.RetryTemplate&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ApacheClientHttpRequestFactory retryableApacheClientHttpRequestFactory() {
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ApacheClientHttpRequestFactory(springClientFactory, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;4）简单调试下&lt;/p&gt;
&lt;p&gt;配置好之后，把 demo-consumer 服务启动起来，简单测试下。&lt;/p&gt;
&lt;p&gt;a) 首先请求会进入到 RestTemplate 的 doExecute 中，然后通过 createRequest，调用 ApacheClientHttpRequestFactory 创建 ApacheClientHttpRequest。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202012/856154-20201224174545170-2139762452.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;b) 接着调用 ApacheClientHttpRequest 的 execute 方法，在 ApacheClientHttpRequest  的 executeInternal 中，就会调用 RibbonLoadBalancingHttpClient 的 executeWithLoadBalancer 方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202012/856154-20201224175046310-2090861344.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;c) 最后，进入 RibbonLoadBalancingHttpClient 的 execute 方法中，它又将请求转给了代理对象 delegate 来执行，delegate 就是在 HttpClientRibbonConfiguration 中配置的 CloseableHttpClient 对象，实际类型是 InternalHttpClient。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202012/856154-20201224175332007-889954901.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;经过验证，通过自定义的配置，最终使得 RestTemplate 可以使用 apache httpcomponents 组件来执行 HTTP 请求。重试那块后面再来研究。&lt;/p&gt;
&lt;p&gt;③ 还是用一张图来总结下 RestTemplate 基于 apache HttpClient 后的执行流程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202012/856154-20201224194200569-4872653.png&quot; width=&quot;1000&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;6、定制 RestTemplate 使用 OkHttp&lt;/h3&gt;
&lt;p&gt;① 设置 OkHttp3ClientHttpRequestFactory&lt;/p&gt;
&lt;p&gt;类似的，可以给 RestTemplate 直接设置 OkHttp3ClientHttpRequestFactory，但它同样也不具备重试的能力。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;@Bean
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;@LoadBalanced
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; RestTemplate restTemplate() {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     OkHttp3ClientHttpRequestFactory requestFactory = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; OkHttp3ClientHttpRequestFactory();
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     RestTemplate restTemplate = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RestTemplate();
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;    restTemplate.setRequestFactory(requestFactory);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; restTemplate;
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;② 定制 OkHttp ClientHttpRequestFactory&lt;/p&gt;
&lt;p&gt;与定制 apache httpcomponents  类似，我这里就直接把三个类的代码放出来了。&lt;/p&gt;
&lt;p&gt;a) OkHttpClientHttpRequest：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_787c2791-fd32-49b3-9525-a00c995f2b51&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_787c2791-fd32-49b3-9525-a00c995f2b51&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_787c2791-fd32-49b3-9525-a00c995f2b51&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;77&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.lyyzoo.sunny.register.ribbon.okhttp;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.net.URI;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.ArrayList;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.netflix.client.config.IClientConfig;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.netflix.client.http.HttpResponse;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cloud.netflix.ribbon.RibbonHttpRequest;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cloud.netflix.ribbon.RibbonHttpResponse;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cloud.netflix.ribbon.okhttp.OkHttpLoadBalancingClient;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cloud.netflix.ribbon.okhttp.OkHttpRibbonRequest;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cloud.netflix.ribbon.okhttp.RetryableOkHttpLoadBalancingClient;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cloud.netflix.ribbon.support.RibbonCommandContext;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.http.HttpHeaders;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.http.HttpMethod;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.http.client.ClientHttpResponse;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.util.LinkedMultiValueMap;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt; * OkHttp ClientHttpRequest
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt; *
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; bojiangzhou
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; OkHttpClientHttpRequest &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; RibbonHttpRequest {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; URI uri;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; HttpMethod httpMethod;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; String serviceId;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; OkHttpLoadBalancingClient client;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; IClientConfig config;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt; &lt;span&gt;     * 是否重试
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; retryable;
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; 
&lt;span&gt;41&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; OkHttpClientHttpRequest(URI uri,
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;                                   HttpMethod httpMethod,
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;                                   String serviceId,
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;                                   OkHttpLoadBalancingClient client,
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;                                   IClientConfig config,
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;                                    &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; retryable) {
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;         &lt;span&gt;super&lt;/span&gt;(uri, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;, config);
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.uri =&lt;span&gt; uri;
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.httpMethod =&lt;span&gt; httpMethod;
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.serviceId =&lt;span&gt; serviceId;
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.client =&lt;span&gt; client;
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.config =&lt;span&gt; config;
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.retryable =&lt;span&gt; retryable;
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (retryable &amp;amp;&amp;amp; !(client &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; RetryableOkHttpLoadBalancingClient)) {
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&quot;Retryable client must be RetryableOkHttpLoadBalancingClient&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; 
&lt;span&gt;59&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; ClientHttpResponse executeInternal(HttpHeaders headers) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;             RibbonCommandContext ribbonCommandContext = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RibbonCommandContext(serviceId, httpMethod.name(),
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;                     uri.toString(), retryable, headers, &lt;span&gt;new&lt;/span&gt; LinkedMultiValueMap&amp;lt;&amp;gt;(), &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;());
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; 
&lt;span&gt;65&lt;/span&gt;             OkHttpRibbonRequest request = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; OkHttpRibbonRequest(ribbonCommandContext);
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; 
&lt;span&gt;67&lt;/span&gt; &lt;span&gt;            HttpResponse response;
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (retryable) {
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; RetryableRibbonLoadBalancingHttpClient 本身具备负载均衡的能力&lt;/span&gt;
&lt;span&gt;70&lt;/span&gt;                 response =&lt;span&gt; client.execute(request, config);
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; RibbonLoadBalancingHttpClient 需调用 executeWithLoadBalancer 才具备负载均衡的能力&lt;/span&gt;
&lt;span&gt;73&lt;/span&gt;                 response =&lt;span&gt; client.executeWithLoadBalancer(request, config);
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt; 
&lt;span&gt;76&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RibbonHttpResponse(response);
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IOException(e);
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;80&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;81&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;b) OkHttpClientHttpRequestFactory&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36.5&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_3ed7ca81-b07b-49fb-a365-e27447c34a08&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_3ed7ca81-b07b-49fb-a365-e27447c34a08&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_3ed7ca81-b07b-49fb-a365-e27447c34a08&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;68&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.lyyzoo.sunny.register.ribbon.okhttp;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.net.URI;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.netflix.client.config.IClientConfig;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cloud.netflix.ribbon.SpringClientFactory;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cloud.netflix.ribbon.okhttp.OkHttpLoadBalancingClient;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.http.HttpMethod;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.http.client.ClientHttpRequest;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.http.client.HttpComponentsClientHttpRequestFactory;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.lang.NonNull;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt; * OkHttp ClientHttpRequest factory
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt; *
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; bojiangzhou
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; OkHttpClientHttpRequestFactory &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; HttpComponentsClientHttpRequestFactory {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; SpringClientFactory clientFactory;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; retryable;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; OkHttpClientHttpRequestFactory(SpringClientFactory clientFactory, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; retryable) {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.clientFactory =&lt;span&gt; clientFactory;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.retryable =&lt;span&gt; retryable;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    @NonNull
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; ClientHttpRequest createRequest(URI originalUri, HttpMethod httpMethod) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         String serviceId =&lt;span&gt; originalUri.getHost();
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (serviceId == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IOException(
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                     &quot;Invalid hostname in the URI [&quot; + originalUri.toASCIIString() + &quot;]&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         IClientConfig clientConfig = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.clientFactory.getClientConfig(serviceId);
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         OkHttpLoadBalancingClient httpClient = &lt;span&gt;this&lt;/span&gt;.clientFactory.getClient(serviceId, OkHttpLoadBalancingClient.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; 
&lt;span&gt;40&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; OkHttpClientHttpRequest(originalUri, httpMethod, serviceId, httpClient, clientConfig, retryable);
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;c) OkHttpClientHttpRequestFactoryConfiguration&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34.5&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_2b88852b-fe43-4ec8-96fe-cc592d096ec6&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_2b88852b-fe43-4ec8-96fe-cc592d096ec6&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_2b88852b-fe43-4ec8-96fe-cc592d096ec6&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.lyyzoo.sunny.register.ribbon.okhttp;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.autoconfigure.AutoConfigureAfter;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.autoconfigure.AutoConfigureBefore;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.autoconfigure.condition.ConditionalOnMissingClass;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cloud.client.loadbalancer.AsyncLoadBalancerAutoConfiguration;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cloud.client.loadbalancer.LoadBalancerAutoConfiguration;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cloud.client.loadbalancer.RestTemplateCustomizer;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cloud.netflix.ribbon.SpringClientFactory;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Bean;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Configuration;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.client.RestTemplate;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt; *
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; bojiangzhou
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;@Configuration
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; @ConditionalOnClass(RestTemplate.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; @AutoConfigureAfter(name = &quot;org.springframework.cloud.netflix.eureka.EurekaClientAutoConfiguration&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; @AutoConfigureBefore({LoadBalancerAutoConfiguration.&lt;span&gt;class&lt;/span&gt;, AsyncLoadBalancerAutoConfiguration.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;})
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; @ConditionalOnProperty(name = &quot;ribbon.okhttp.restTemplate.enabled&quot;, matchIfMissing = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OkHttpClientHttpRequestFactoryConfiguration {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt;     @Configuration(proxyBeanMethods = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     @ConditionalOnProperty(&quot;ribbon.okhttp.enabled&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     @ConditionalOnClass(name = &quot;okhttp3.OkHttpClient&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ClientHttpRequestFactoryConfiguration {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;        @Autowired
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt;&lt;span&gt; SpringClientFactory springClientFactory;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; 
&lt;span&gt;37&lt;/span&gt; &lt;span&gt;        @Bean
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;        @ConditionalOnMissingBean
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; RestTemplateCustomizer restTemplateCustomizer(
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;                 &lt;span&gt;final&lt;/span&gt;&lt;span&gt; OkHttpClientHttpRequestFactory okHttpClientHttpRequestFactory) {
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; restTemplate -&amp;gt;&lt;span&gt; restTemplate
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;                    .setRequestFactory(okHttpClientHttpRequestFactory);
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; 
&lt;span&gt;45&lt;/span&gt; &lt;span&gt;        @Bean
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;         @ConditionalOnMissingClass(&quot;org.springframework.retry.support.RetryTemplate&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; OkHttpClientHttpRequestFactory okHttpClientHttpRequestFactory() {
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; OkHttpClientHttpRequestFactory(springClientFactory, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; 
&lt;span&gt;51&lt;/span&gt; &lt;span&gt;        @Bean
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;         @ConditionalOnClass(name = &quot;org.springframework.retry.support.RetryTemplate&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; OkHttpClientHttpRequestFactory retryableOkHttpClientHttpRequestFactory() {
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; OkHttpClientHttpRequestFactory(springClientFactory, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h2&gt;七、RestTemplate 超时重试&lt;/h2&gt;
&lt;h3&gt;1、AbstractLoadBalancerAwareClient&lt;/h3&gt;
&lt;p&gt;① AbstractLoadBalancerAwareClient&lt;/p&gt;
&lt;p&gt;通过上一节的分析，可以知道有重试功能的其实有两个组件，一个是 Ribbon 的 LoadBalancerCommand，一个是 spring-retry 的 RetryTemplate。RetryableRibbonLoadBalancingHttpClient 和 RetryableOkHttpLoadBalancingClient 都要依赖 RetryTemplate，所以必须先引入 spring-retry 依赖，它们最终都是使用 RetryTemplate 实现请求重试的能力的。除了 RetryTemplate，其它客户端想要获取重试的功能，就要用 ribbon 中的 AbstractLoadBalancerAwareClient 相关的组件，并调用 executeWithLoadBalancer 方法。&lt;/p&gt;
&lt;p&gt;再看下 AbstractLoadBalancerAwareClient 的体系，通过源码可以了解到：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;RetryableFeignLoadBalancer、RetryableRibbonLoadBalancingHttpClient、RetryableOkHttpLoadBalancingClient 都是使用 RetryTemplate 实现重试功能的，也就是 spring-retry 的重试。&lt;/li&gt;
&lt;li&gt;RestClient、FeignLoadBalancer、RibbonLoadBalancingHttpClient、OkHttpLoadBalancingClient 是在 AbstractLoadBalancerAwareClient 中使用 LoadBalancerCommand 实现重试功能的，就是是 Ribbon 的重试。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202012/856154-20201223212456447-1178386001.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;② executeWithLoadBalancer&lt;/p&gt;
&lt;p&gt;具体的 AbstractLoadBalancerAwareClient 客户端想要负载均衡调用以及能进行重试，需调用 AbstractLoadBalancerAwareClient 的 executeWithLoadBalancer 方法。&lt;/p&gt;
&lt;p&gt;在这个方法里面，它先构建了 LoadBalancerCommand，然后用 command 提交了一个 ServerOperation，这个 ServerOperation 中对 URI 进行了 重构，转到具体的 LoadBalancerContext 去执行请求。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; T executeWithLoadBalancer(&lt;span&gt;final&lt;/span&gt; S request, &lt;span&gt;final&lt;/span&gt; IClientConfig requestConfig) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ClientException {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 负载均衡命令&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     LoadBalancerCommand&amp;lt;T&amp;gt; command =&lt;span&gt; buildLoadBalancerCommand(request, requestConfig);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; command.submit(
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;new&lt;/span&gt; ServerOperation&amp;lt;T&amp;gt;&lt;span&gt;() {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;                @Override
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 &lt;span&gt;public&lt;/span&gt; Observable&amp;lt;T&amp;gt;&lt;span&gt; call(Server server) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 重构URI&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;                     URI finalUri =&lt;span&gt; reconstructURIWithServer(server, request.getUri());
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                     S requestForServer =&lt;span&gt; (S) request.replaceUri(finalUri);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用具体的 AbstractLoadBalancerAwareClient 客户端执行请求&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;                         &lt;span&gt;return&lt;/span&gt; Observable.just(AbstractLoadBalancerAwareClient.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.execute(requestForServer, requestConfig));
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                     &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Observable.error(e);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;            })
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;            .toBlocking()
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;            .single();
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再看 buildLoadBalancerCommand 方法，它首先会通过 getRequestSpecificRetryHandler 方法获取请求重试处理器 RequestSpecificRetryHandler，而 getRequestSpecificRetryHandler 是一个抽象方法。这里就要重点注意了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 抽象方法，获取请求重试处理器&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt;&lt;span&gt; RequestSpecificRetryHandler getRequestSpecificRetryHandler(S request, IClientConfig requestConfig);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; LoadBalancerCommand&amp;lt;T&amp;gt; buildLoadBalancerCommand(&lt;span&gt;final&lt;/span&gt; S request, &lt;span&gt;final&lt;/span&gt;&lt;span&gt; IClientConfig config) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取请求重试处理器&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     RequestSpecificRetryHandler handler =&lt;span&gt; getRequestSpecificRetryHandler(request, config);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     LoadBalancerCommand.Builder&amp;lt;T&amp;gt; builder = LoadBalancerCommand.&amp;lt;T&amp;gt;&lt;span&gt;builder()
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             .withLoadBalancerContext(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            .withRetryHandler(handler)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            .withLoadBalancerURI(request.getUri());
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    customizeLoadBalancerCommandBuilder(request, config, builder);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; builder.build();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2、请求重试处理器 RequestSpecificRetryHandler&lt;/h3&gt;
&lt;p&gt;① 先了解下 RequestSpecificRetryHandler：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先看它的构造方法，注意第一个参数和第二个参数，因为不同的 getRequestSpecificRetryHandler 方法实现，主要差异就在于这两个参数。&lt;/li&gt;
&lt;li&gt;然后看 isRetriableException，这个方法就是 LoadBalancerCommand 用来判断异常后是否需要重试的方法，可以了解到 okToRetryOnAllErrors=true 时就可以重试，否则 okToRetryOnConnectErrors=true 才可能重试。需要注意的是就算这个方法返回 true 也不一定会重试，这跟重试次数也是有一定关系的。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; RequestSpecificRetryHandler(&lt;span&gt;boolean&lt;/span&gt; okToRetryOnConnectErrors, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; okToRetryOnAllErrors, RetryHandler baseRetryHandler, @Nullable IClientConfig requestConfig) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    Preconditions.checkNotNull(baseRetryHandler);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.okToRetryOnConnectErrors =&lt;span&gt; okToRetryOnConnectErrors;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.okToRetryOnAllErrors =&lt;span&gt; okToRetryOnAllErrors;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.fallback =&lt;span&gt; baseRetryHandler;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (requestConfig != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在同一个Server上重试的次数&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (requestConfig.containsProperty(CommonClientConfigKey.MaxAutoRetries)) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             retrySameServer =&lt;span&gt; requestConfig.get(CommonClientConfigKey.MaxAutoRetries);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 重试下一个Server的次数&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (requestConfig.containsProperty(CommonClientConfigKey.MaxAutoRetriesNextServer)) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             retryNextServer =&lt;span&gt; requestConfig.get(CommonClientConfigKey.MaxAutoRetriesNextServer);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; isRetriableException(Throwable e, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; sameServer) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 所有错误都重试&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (okToRetryOnAllErrors) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ClientException 才可能重试&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (e &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; ClientException) {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         ClientException ce =&lt;span&gt; (ClientException) e;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (ce.getErrorType() ==&lt;span&gt; ClientException.ErrorType.SERVER_THROTTLED) {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; !&lt;span&gt;sameServer;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt;  {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 连接错误才重试，就是抛出 SocketException 异常时才重试&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; okToRetryOnConnectErrors &amp;amp;&amp;amp;&lt;span&gt; isConnectionException(e);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;② 不同 LoadBalancerCommand 的 getRequestSpecificRetryHandler 实现&lt;/p&gt;
&lt;p&gt;a）RestClient&lt;/p&gt;
&lt;p&gt;默认配置下，RestClient 的 getRequestSpecificRetryHandler 会走到最后一步，okToRetryOnConnectErrors、okToRetryOnAllErrors 都为 true，也就是说 isRetriableException 始终返回 true，也就是说抛出异常都会重试。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; RequestSpecificRetryHandler getRequestSpecificRetryHandler(
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;        HttpRequest request, IClientConfig requestConfig) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;request.isRetriable()) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RequestSpecificRetryHandler(&lt;span&gt;false&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getRetryHandler(), requestConfig);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.ncc.get(CommonClientConfigKey.OkToRetryOnAllOperations, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RequestSpecificRetryHandler(&lt;span&gt;true&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getRetryHandler(), requestConfig);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (request.getVerb() !=&lt;span&gt; HttpRequest.Verb.GET) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RequestSpecificRetryHandler(&lt;span&gt;true&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getRetryHandler(), requestConfig);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; okToRetryOnConnectErrors、okToRetryOnAllErrors 都为 true&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RequestSpecificRetryHandler(&lt;span&gt;true&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getRetryHandler(), requestConfig);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;b）AbstractLoadBalancingClient&lt;/p&gt;
&lt;p&gt;AbstractLoadBalancingClient 中的 getRequestSpecificRetryHandler 相当于一个默认实现，默认情况下 okToRetryOnAllOperations 为 false，最后也会到最后一步，即 okToRetryOnConnectErrors、okToRetryOnAllErrors 都为 true，isRetriableException 始终返回 true。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; RequestSpecificRetryHandler getRequestSpecificRetryHandler(&lt;span&gt;final&lt;/span&gt; S request, &lt;span&gt;final&lt;/span&gt;&lt;span&gt; IClientConfig requestConfig) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; okToRetryOnAllOperations：是否所有操作都重试，默认 false&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.okToRetryOnAllOperations) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RequestSpecificRetryHandler(&lt;span&gt;true&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getRetryHandler(), requestConfig);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!request.getContext().getMethod().equals(&quot;GET&quot;&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RequestSpecificRetryHandler(&lt;span&gt;true&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getRetryHandler(), requestConfig);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RequestSpecificRetryHandler(&lt;span&gt;true&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getRetryHandler(), requestConfig);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;c）RibbonLoadBalancingHttpClient&lt;/p&gt;
&lt;p&gt;RibbonLoadBalancingHttpClient 也重载了 getRequestSpecificRetryHandler，但是它设置了 okToRetryOnConnectErrors、okToRetryOnAllErrors 都为 false，isRetriableException 始终返回 false。&lt;/p&gt;
&lt;p&gt;至此我们应该就知道为什么调用 RibbonLoadBalancingHttpClient 的 executeWithLoadBalancer 不具备重试的功能的原因了。所以启用 apache httpclient 时，RibbonLoadBalancingHttpClient 调用是不支持重试的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; RequestSpecificRetryHandler getRequestSpecificRetryHandler(RibbonApacheHttpRequest request, IClientConfig requestConfig) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; okToRetryOnConnectErrors、okToRetryOnAllErrors 都为 false&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RequestSpecificRetryHandler(&lt;span&gt;false&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;, RetryHandler.DEFAULT, requestConfig);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;RetryableRibbonLoadBalancingHttpClient 中也重写了 getRequestSpecificRetryHandler，同样也是设置 okToRetryOnConnectErrors、okToRetryOnAllErrors 都为 false。但是在引入 spring-retry 后，它会使用 RetryTemplate 实现重试的功能。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; RequestSpecificRetryHandler getRequestSpecificRetryHandler(RibbonApacheHttpRequest request, IClientConfig requestConfig) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; okToRetryOnConnectErrors、okToRetryOnAllErrors 都为 false&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RequestSpecificRetryHandler(&lt;span&gt;false&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, RetryHandler.DEFAULT, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;d）OkHttpLoadBalancingClient&lt;/p&gt;
&lt;p&gt;OkHttpLoadBalancingClient 并没有重写 getRequestSpecificRetryHandler，所以它是使用父类 AbstractLoadBalancingClient 中的方法，也就是 okToRetryOnConnectErrors、okToRetryOnAllErrors 都为 true。所以，启用 okhttp 时，OkHttpLoadBalancingClient 是支持重试的，这里需要注意。&lt;/p&gt;
&lt;p&gt;而 RetryableOkHttpLoadBalancingClient 跟 RetryableRibbonLoadBalancingHttpClient 一样的重写方式，使用 RetryTemplate 实现重试。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; RequestSpecificRetryHandler getRequestSpecificRetryHandler(RibbonApacheHttpRequest request, IClientConfig requestConfig) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; okToRetryOnConnectErrors、okToRetryOnAllErrors 都为 false&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RequestSpecificRetryHandler(&lt;span&gt;false&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, RetryHandler.DEFAULT, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3、LoadBalancerCommand&lt;/h3&gt;
&lt;p&gt;看 LoadBalancerCommand 的 submit 方法，这个方法是重试的核心代码。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先获取了同一个Server重试次数 maxRetrysSame 和 重试下一个Server的次数 maxRetrysNext，其实就是前面配置的 ribbon.MaxAutoRetries 和 ribbon.MaxAutoRetriesNextServer，我设置的是 1。&lt;/li&gt;
&lt;li&gt;然后创建了一个 Observable，它的第一层会先通过 loadBalancerContext 获取 Server。在重试下一个 Server 时，这里就会获取下一个 Server。&lt;/li&gt;
&lt;li&gt;在第二层，又创建了一个 Observable，这个 Observable 就是调用 ServerOperation 的，就是重构 URI，调用具体的 AbstractLoadBalancerAwareClient 执行请求。&lt;/li&gt;
&lt;li&gt;在第二层里，会根据 maxRetrysSame 重试同一个 Server，从 retryPolicy 中可以了解到，当重试次数大于 maxRetrysSame 后，同一个 Server 重试就结束了，否则就用 retryHandler.isRetriableException 判断是否重试，这个前面已经分析过了。&lt;/li&gt;
&lt;li&gt;在外层，则根据 maxRetrysNext 重试不同的 Server，从 retryPolicy 中可以了解到，当不同Server重试次数大于 maxRetrysNext 后，就重试结束了，整个重试也就结束了，如果还是失败，就会进入 onErrorResumeNext 进行最后的失败处理。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;最后来总结一下 LoadBalancerCommand 重试：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;重试分为同一个 Server 重试和重试下一个Server，当重试次数大于设置的重试值时，就停止重试。否则通过 retryHandler.isRetriableException 判断是否重试。&lt;/li&gt;
&lt;li&gt;那这里一共请求了多少次呢？可以总结出如下公式：请求次数 = （maxRetrysSame + 1） * （maxRetrysNext + 1），所以按 ribbon.MaxAutoRetries = 1、ribbon.MaxAutoRetriesNextServer = 1 的配置，如果每次请求都超时，就会发起 4 次请求。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; Observable&amp;lt;T&amp;gt; submit(&lt;span&gt;final&lt;/span&gt; ServerOperation&amp;lt;T&amp;gt;&lt;span&gt; operation) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; ExecutionInfoContext context = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ExecutionInfoContext();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 同一个Server重试次数&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; maxRetrysSame =&lt;span&gt; retryHandler.getMaxRetriesOnSameServer();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 重试下一个Server的次数&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; maxRetrysNext =&lt;span&gt; retryHandler.getMaxRetriesOnNextServer();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建一个 Observable&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     Observable&amp;lt;T&amp;gt; o =
&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用 loadBalancerContext 获取 Server&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;             (server == &lt;span&gt;null&lt;/span&gt; ?&lt;span&gt; selectServer() : Observable.just(server))
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             .concatMap(&lt;span&gt;new&lt;/span&gt; Func1&amp;lt;Server, Observable&amp;lt;T&amp;gt;&amp;gt;&lt;span&gt;() {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;                @Override
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                 &lt;span&gt;public&lt;/span&gt; Observable&amp;lt;T&amp;gt;&lt;span&gt; call(Server server) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置Server&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;                    context.setServer(server);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                     &lt;span&gt;final&lt;/span&gt; ServerStats stats =&lt;span&gt; loadBalancerContext.getServerStats(server);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建 Observable&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;                     Observable&amp;lt;T&amp;gt; o =&lt;span&gt; Observable
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;                            .just(server)
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                             .concatMap(&lt;span&gt;new&lt;/span&gt; Func1&amp;lt;Server, Observable&amp;lt;T&amp;gt;&amp;gt;&lt;span&gt;() {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;                                @Override
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                                 &lt;span&gt;public&lt;/span&gt; Observable&amp;lt;T&amp;gt; call(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; Server server) {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 增加尝试次数&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;                                    context.incAttemptCount();
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用 ServerOperation&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;                                     &lt;span&gt;return&lt;/span&gt; operation.call(server).doOnEach(&lt;span&gt;new&lt;/span&gt; Observer&amp;lt;T&amp;gt;&lt;span&gt;() {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 一些回调方法&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt; &lt;span&gt;                                    });
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;                                }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;                            });
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 重试同一个Server&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (maxRetrysSame &amp;gt; 0&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;                         o = o.retry(retryPolicy(maxRetrysSame, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; o;
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; 
&lt;span&gt;42&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (maxRetrysNext &amp;gt; 0 &amp;amp;&amp;amp; server == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 重试不同Server&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt;         o = o.retry(retryPolicy(maxRetrysNext, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; 
&lt;span&gt;46&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; o.onErrorResumeNext(&lt;span&gt;new&lt;/span&gt; Func1&amp;lt;Throwable, Observable&amp;lt;T&amp;gt;&amp;gt;&lt;span&gt;() {
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;        @Override
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; Observable&amp;lt;T&amp;gt;&lt;span&gt; call(Throwable e) {
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 异常处理&lt;/span&gt;
&lt;span&gt;50&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Observable.error(e);
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;    });
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; 
&lt;span&gt;55&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; retryPolicy 返回一个是否重试的断言&lt;/span&gt;
&lt;span&gt;56&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; Func2&amp;lt;Integer, Throwable, Boolean&amp;gt; retryPolicy(&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; maxRetrys, &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; same) {
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Func2&amp;lt;Integer, Throwable, Boolean&amp;gt;&lt;span&gt;() {
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; &lt;span&gt;        @Override
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Boolean call(Integer tryCount, Throwable e) {
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 请求拒绝异常就不允许重试&lt;/span&gt;
&lt;span&gt;61&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (e &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; AbortExecutionException) {
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 尝试次数是否大于最大重试次数&lt;/span&gt;
&lt;span&gt;65&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (tryCount &amp;gt;&lt;span&gt; maxRetrys) {
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用 RequestSpecificRetryHandler 判断是否重试&lt;/span&gt;
&lt;span&gt;69&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; retryHandler.isRetriableException(e, same);
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt; &lt;span&gt;    };
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;4、RetryTemplate&lt;/h3&gt;
&lt;p&gt;① spring-retry&lt;/p&gt;
&lt;p&gt;要启用 RetryTemplate 需先引入 spring-retry：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.retry&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-retry&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以 RetryableRibbonLoadBalancingHttpClient 为例，先看看它的 execute 方法，它先创建了负载均衡重试策略类 LoadBalancedRetryPolicy，然后将请求调用的逻辑封装到 RetryCallback 中，最后其实就是用 RetryTemplate 执行这个 RetryCallback，也就是说请求重试的逻辑都在 RetryTemplate 中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; RibbonApacheHttpResponse execute(&lt;span&gt;final&lt;/span&gt; RibbonApacheHttpRequest request, &lt;span&gt;final&lt;/span&gt; IClientConfig configOverride) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;...
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 负载均衡重试策略 RibbonLoadBalancedRetryPolicy&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; LoadBalancedRetryPolicy retryPolicy = loadBalancedRetryFactory.createRetryPolicy(&lt;span&gt;this&lt;/span&gt;.getClientName(), &lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     RetryCallback&amp;lt;RibbonApacheHttpResponse, Exception&amp;gt; retryCallback = context -&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; delegate =&amp;gt; CloseableHttpClient&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; HttpResponse httpResponse = RetryableRibbonLoadBalancingHttpClient.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.delegate.execute(httpUriRequest);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 成功 返回结果&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RibbonApacheHttpResponse(httpResponse, httpUriRequest.getURI());
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    };
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;     LoadBalancedRecoveryCallback&amp;lt;RibbonApacheHttpResponse, HttpResponse&amp;gt; recoveryCallback = &lt;span&gt;new&lt;/span&gt; LoadBalancedRecoveryCallback&amp;lt;RibbonApacheHttpResponse, HttpResponse&amp;gt;()&lt;span&gt;//&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.executeWithRetry(request, retryPolicy, retryCallback, recoveryCallback);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;private&lt;/span&gt;&lt;span&gt; RibbonApacheHttpResponse executeWithRetry(RibbonApacheHttpRequest request,
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        LoadBalancedRetryPolicy retryPolicy,
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         RetryCallback&amp;lt;RibbonApacheHttpResponse, Exception&amp;gt;&lt;span&gt; callback,
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         RecoveryCallback&amp;lt;RibbonApacheHttpResponse&amp;gt;&lt;span&gt; recoveryCallback)
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     RetryTemplate retryTemplate = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RetryTemplate();
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; retryable =&amp;gt; 取自 RibbonCommandContext 设置的 retryable 参数&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;boolean&lt;/span&gt; retryable =&lt;span&gt; isRequestRetryable(request);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置重试策略&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;     retryTemplate.setRetryPolicy(retryPolicy == &lt;span&gt;null&lt;/span&gt; || !&lt;span&gt;retryable
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             ? &lt;span&gt;new&lt;/span&gt; NeverRetryPolicy() : &lt;span&gt;new&lt;/span&gt; RetryPolicy(request, retryPolicy, &lt;span&gt;this&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getClientName()));
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt;     BackOffPolicy backOffPolicy = loadBalancedRetryFactory.createBackOffPolicy(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getClientName());
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;     retryTemplate.setBackOffPolicy(backOffPolicy == &lt;span&gt;null&lt;/span&gt; ? &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NoBackOffPolicy() : backOffPolicy);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; 
&lt;span&gt;37&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 利用 retryTemplate 执行请求 callback&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; retryTemplate.execute(callback, recoveryCallback);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;需要注意的是，在 executeWithRetry 中，会判断是否要重试，判断的逻辑中 getRetryable 其实就是取的 ApacheClientHttpRequest 中 executeInternal 方法里创建的 RibbonCommandContext 设置的 retryable 参数，这就和前面定制化的逻辑衔接上了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isRequestRetryable(ContextAwareRequest request) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (request.getContext() == &lt;span&gt;null&lt;/span&gt; || request.getContext().getRetryable() == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; request.getContext().getRetryable();
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;② RetryTemplate&lt;/p&gt;
&lt;p&gt;进入 RetryTemplate 的 execute 方法，核心的逻辑我精简成如下代码，主要就是一个 while 循环判断是否可以重试，然后调用 retryCallback 执行请求。请求失败后，比如超时，抛出异常，就会 registerThrowable 来注册异常。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; &amp;lt;T, E &lt;span&gt;extends&lt;/span&gt; Throwable&amp;gt; T doExecute(RetryCallback&amp;lt;T, E&amp;gt;&lt;span&gt; retryCallback,
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         RecoveryCallback&amp;lt;T&amp;gt; recoveryCallback, RetryState state) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; E, ExhaustedRetryException {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; retryPolicy =&amp;gt; InterceptorRetryPolicy&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     RetryPolicy retryPolicy = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.retryPolicy;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     BackOffPolicy backOffPolicy = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.backOffPolicy;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;....&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; canRetry 判断是否重试&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; (canRetry(retryPolicy, context) &amp;amp;&amp;amp; !&lt;span&gt;context.isExhaustedOnly()) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; retryCallback 调用&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; retryCallback.doWithRetry(context);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable e) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注册异常&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;                registerThrowable(retryPolicy, state, context, e);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         exhausted = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; handleRetryExhausted(recoveryCallback, context, state);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看 canRetry 方法，它实际是调用了 InterceptorRetryPolicy 的 canRetry。第一次调用时，会去获取 Server；否则就用 RibbonLoadBalancedRetryPolicy 判断是否重试下一个 Server，注意它判断的逻辑是 GET 请求或者允许所有操作操作重试，且 Server 重试次数 nextServerCount  小于等于配置的 MaxAutoRetriesNextServer 。也就是说，while 循环判断的 canRetry 是重试下一个 Server 的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; canRetry(RetryPolicy retryPolicy, RetryContext context) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; retryPolicy.canRetry(context);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;////////////&lt;/span&gt;&lt;span&gt; InterceptorRetryPolicy&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; canRetry(RetryContext context) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     LoadBalancedRetryContext lbContext =&lt;span&gt; (LoadBalancedRetryContext) context;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (lbContext.getRetryCount() == 0 &amp;amp;&amp;amp; lbContext.getServiceInstance() == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取 Server&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         lbContext.setServiceInstance(&lt;span&gt;this&lt;/span&gt;.serviceInstanceChooser.choose(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.serviceName));
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; RibbonLoadBalancedRetryPolicy =&amp;gt; 重试下一个Server&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.policy.canRetryNextServer(lbContext);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;////////&lt;/span&gt;&lt;span&gt;/ RibbonLoadBalancedRetryPolicy&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; canRetryNextServer(LoadBalancedRetryContext context) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断重试下一个Server&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; nextServerCount &amp;lt;=&lt;span&gt; lbContext.getRetryHandler().getMaxRetriesOnNextServer()
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             &amp;amp;&amp;amp;&lt;span&gt; canRetry(context);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; canRetry(LoadBalancedRetryContext context) {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; GET 请求或者允许所有操作重试时，就允许重试&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;     HttpMethod method =&lt;span&gt; context.getRequest().getMethod();
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; HttpMethod.GET == method ||&lt;span&gt; lbContext.isOkToRetryOnAllOperations();
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接着看请求失败后的注册异常 registerThrowable，它最后会向 RibbonLoadBalancedRetryPolicy 注册异常。在 RibbonLoadBalancedRetryPolicy 的 registerThrowable 方法中，如果不重试同一个Server且可以重试下一个Server，就会轮询获取下一个Server。如果可以在同一个Server上重试，sameServerCount 计数器就+1，否则重置 sameServerCount，然后 nextServerCount +1。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; registerThrowable(RetryPolicy retryPolicy, RetryState state,
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;        RetryContext context, Throwable e) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    retryPolicy.registerThrowable(context, e);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    registerContext(context, state);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;////////&lt;/span&gt;&lt;span&gt;/ InterceptorRetryPolicy &lt;/span&gt;&lt;span&gt;////////&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; registerThrowable(RetryContext context, Throwable throwable) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     LoadBalancedRetryContext lbContext =&lt;span&gt; (LoadBalancedRetryContext) context;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    lbContext.registerThrowable(throwable);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; RibbonLoadBalancedRetryPolicy&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.policy.registerThrowable(lbContext, throwable);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;////////&lt;/span&gt;&lt;span&gt;/ RibbonLoadBalancedRetryPolicy &lt;/span&gt;&lt;span&gt;////////&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; registerThrowable(LoadBalancedRetryContext context, Throwable throwable) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;...
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果不在在同一个Server 上重试且可以重试下一个Server，则重新选择一个 Server&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!canRetrySameServer(context) &amp;amp;&amp;amp;&lt;span&gt; canRetryNextServer(context)) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        context.setServiceInstance(loadBalanceChooser.choose(serviceId));
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 同一个Server重试超过设置的值后，就重置 sameServerCount&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (sameServerCount &amp;gt;=&lt;span&gt; lbContext.getRetryHandler().getMaxRetriesOnSameServer()
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             &amp;amp;&amp;amp;&lt;span&gt; canRetry(context)) {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 重置 nextServerCount&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;         sameServerCount = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 下一个Server重试次数+1&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;         nextServerCount++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;canRetryNextServer(context)) {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 不能重试下一个Server了&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt; &lt;span&gt;            context.setExhaustedOnly();
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 同一个Server重试次数+1&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;         sameServerCount++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; 
&lt;span&gt;41&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断是否重试同一个Server&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; canRetrySameServer(LoadBalancedRetryContext context) {
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; sameServerCount &amp;lt;&lt;span&gt; lbContext.getRetryHandler().getMaxRetriesOnSameServer()
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;             &amp;amp;&amp;amp;&lt;span&gt; canRetry(context);
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; 
&lt;span&gt;47&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; canRetry(LoadBalancedRetryContext context) {
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; GET 请求或者允许所有操作重试时，就允许重试&lt;/span&gt;
&lt;span&gt;49&lt;/span&gt;     HttpMethod method =&lt;span&gt; context.getRequest().getMethod();
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; HttpMethod.GET == method ||&lt;span&gt; lbContext.isOkToRetryOnAllOperations();
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;5、Ribbon 重试总结&lt;/h3&gt;
&lt;p&gt;① 首先，Ribbon 关于超时和重试的配置参数如下，这些参数也可以针对某个客户端配置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;ribbon:
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;  # 客户端读取超时时间
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;   ReadTimeout: 1000
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;  # 客户端连接超时时间
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;   ConnectTimeout: 1000
&lt;span&gt; 6&lt;/span&gt;   # 默认只重试 GET，设置为 &lt;span&gt;true&lt;/span&gt;&lt;span&gt; 时将重试所有类型，如 POST、PUT、DELETE
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;   OkToRetryOnAllOperations: &lt;span&gt;false&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;  # 同一个Server重试次数
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;   MaxAutoRetries: 1
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;  # 最多重试几个Server
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;   MaxAutoRetriesNextServer: 1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;② RetryTemplate 是 spring-retry 的重试组件，LoadBalancerCommand 是 Ribbon 的重试组件。它们重试的请求次数是一样的，重试逻辑也是类似，都是先重试当前 Server，再重试下一个Server，总的请求次数 = （MaxAutoRetries + 1） * （MaxAutoRetriesNextServer + 1）。&lt;/p&gt;
&lt;p&gt;③ 但是有点差别的是，RetryTemplate 会判断请求方法为 GET 或者 OkToRetryOnAllOperations=true 时才允许重试，而 LoadBalancerCommand  是所有 http 方法都可以重试。这个其实是有问题的，一般只有GET才允许重试，因为GET是查询操作，接口是幂等的，而POST、PUT、DELETE一般是非幂等的。所以一般更建议使用 RetryTemplate，并且配置 OkToRetryOnAllOperations=false。&lt;/p&gt;
&lt;p&gt;④ 为了提升服务间通信性能，一般可以启用 apache httpclient 或者 OkHttp，如果要启用重试功能，还需要引入 spring-retry 依赖。重试时，当前Server就不要重试了（MaxAutoRetries=0），直接重试下一个Server。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;ribbon:
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;  # 客户端读取超时时间
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;   ReadTimeout: 1000
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;  # 客户端连接超时时间
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;   ConnectTimeout: 1000
&lt;span&gt; 6&lt;/span&gt;   # 默认只重试 GET，设置为 &lt;span&gt;true&lt;/span&gt;&lt;span&gt; 时将重试所有类型，如 POST、PUT、DELETE
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;   OkToRetryOnAllOperations: &lt;span&gt;false&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;  # 同一个Server重试次数
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;   MaxAutoRetries: 0
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;  # 最多重试几个Server
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;   MaxAutoRetriesNextServer: 1
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;  # 启用 httpclient
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;  httpclient:
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     enabled: &lt;span&gt;false&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;  # 启用 RestClient
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;  restclient:
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     enabled: &lt;span&gt;false&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;  # 启用 okhttp
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;  okhttp:
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     enabled: &lt;span&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;</description>
<pubDate>Thu, 24 Dec 2020 16:39:00 +0000</pubDate>
<dc:creator>bojiangzhou</dc:creator>
<og:description>Ribbon 负载均衡核心接口、Ribbon HTTP客户端组件，定制化使得 RestTemplate 可以使用 Apache httpclient 或 Okhttp，还介绍了 Ribbon 的请求</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chiangchou/p/ribbon-2.html</dc:identifier>
</item>
<item>
<title>函数进阶· 第3篇《常用内置函数filter()、map()、zip()，怎么用的呢？》 - 清菡</title>
<link>http://www.cnblogs.com/qinghan123/p/14187006.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qinghan123/p/14187006.html</guid>
<description>&lt;h3 id=&quot;坚持原创输出，点击蓝字关注我吧&quot;&gt;坚持原创输出，点击蓝字关注我吧&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/qinghanstudy/qinghan/raw/master/img/20201224165601.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;作者：清菡&lt;br/&gt;博客：oschina、云+社区、知乎等各大平台都有。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;由于微信公众号推送改为了信息流的形式，防止走丢，请给加个星标 ⭐，你就可以第一时间接收到本公众号的推送！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;&lt;li&gt;一、filter()函数
&lt;ul&gt;&lt;li&gt;1.filter()过滤序列&lt;/li&gt;
&lt;li&gt;2.生成器、迭代器都是可迭代对象&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;二、map()函数&lt;/li&gt;
&lt;li&gt;三、zip()函数
&lt;ul&gt;&lt;li&gt;1.什么是 zip()函数&lt;/li&gt;
&lt;li&gt;2.zip()可以快速创建字典&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;常用的内置函数：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;map()函数：会根据提供的函数对指定序列做映射。&lt;/li&gt;
&lt;li&gt;filter()函数：函数用于过滤序列。&lt;/li&gt;
&lt;li&gt;zip()函数：函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;一、filter函数&quot;&gt;一、filter()函数&lt;/h2&gt;
&lt;h3 id=&quot;1filter过滤序列&quot;&gt;1.filter()过滤序列&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;filter:过滤序列。第一参数是函数；第二参数是可迭代对象。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;看看&lt;code&gt;filter()&lt;/code&gt;这个内置函数的源码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-PYTHON&quot;&gt;class filter(object):
    &quot;&quot;&quot;
    filter(function or None, iterable) --&amp;gt; filter object

    Return an iterator yielding those items of iterable for which function(item)
    is true. If function is None, return the items that are true.
    &quot;&quot;&quot;
    def __getattribute__(self, *args, **kwargs): # real signature unknown
        &quot;&quot;&quot; Return getattr(self, name). &quot;&quot;&quot;
        pass

    def __init__(self, function_or_None, iterable): # real signature unknown; restored from __doc__
        pass

    def __iter__(self, *args, **kwargs): # real signature unknown
        &quot;&quot;&quot; Implement iter(self). &quot;&quot;&quot;
        pass

    @staticmethod # known case of __new__
    def __new__(*args, **kwargs): # real signature unknown
        &quot;&quot;&quot; Create and return a new object.  See help(type) for accurate signature. &quot;&quot;&quot;
        pass

    def __next__(self, *args, **kwargs): # real signature unknown
        &quot;&quot;&quot; Implement next(self). &quot;&quot;&quot;
        pass

    def __reduce__(self, *args, **kwargs): # real signature unknown
        &quot;&quot;&quot; Return state information for pickling. &quot;&quot;&quot;
        pass
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看源码发现居然是个类。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;它接收到的是2个参数，2个参数在哪里看呢？&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;__init__&lt;/code&gt;方法里面看。既然是个类，调用的时候创建一个对象。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/qinghanstudy/qinghan/raw/master/img/20201222135731.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Python 中的可迭代对象在一个模块里面。迭代器、生成器、可迭代对象都在这个模块里面。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;from collections import Iterator,Iterable,Generator&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;生成器属于迭代器，生成器是可迭代对象。&lt;/p&gt;
&lt;p&gt;列表是个可迭代对象。&lt;code&gt;filter()&lt;/code&gt;这个内置函数传 2 个参数后，会返回出一个对象。&lt;/p&gt;
&lt;p&gt;看&lt;code&gt;filter()&lt;/code&gt;源码可以看出它是个类，调用它给它传参，类返回的结果肯定是个对象。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;filter()&lt;/code&gt;的作用是过滤，它会进行迭代操作。&lt;/p&gt;
&lt;p&gt;它会把后面传入的可迭代对象，里面的元素全部遍历一遍。然后把遍历出来的元素当作参数传到这个&lt;code&gt;fun&lt;/code&gt;函数里面。&lt;/p&gt;
&lt;p&gt;当前这个&lt;code&gt;fun()&lt;/code&gt;函数没有定义参数，这个时候运行看看：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-PYTHON&quot;&gt;# 内置函数
def fun():
    pass

li = [1,2,122,331,11,22,33,4,6,7,2,88,31]

res=filter(fun,li)
print(list(res))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回列表的时候报错了，&lt;code&gt;fun()&lt;/code&gt;需要 0 个参数，但是这里给了一个参数：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/qinghanstudy/qinghan/raw/master/img/20201224130742.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当我们把它转换成列表的时候，在这里传进去，它会返回一个对象，这个对象里有一个函数，还有个可迭代对象&lt;code&gt;filter(fun,li)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;filter()&lt;/code&gt;传出来的数据也是个迭代器。它也是个可迭代对象，就可以通过&lt;code&gt;list&lt;/code&gt;把它转换成列表。&lt;/p&gt;
&lt;p&gt;当你转换的时候，它会把第一个参数拿到，传到&lt;code&gt;fun()&lt;/code&gt;里面去，会自动传参的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/qinghanstudy/qinghan/raw/master/img/20201224131730.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;加个参数，再运行：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-PYTHON&quot;&gt;# 内置函数
def fun(n):
    pass

li = [1,2,122,331,11,22,33,4,6,7,2,88,31]

res=filter(fun,li)
print(list(res))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/qinghanstudy/qinghan/raw/master/img/20201224132059.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个列表是空的。因为函数&lt;code&gt;pass&lt;/code&gt;掉了。只写个&lt;code&gt;pass&lt;/code&gt;，调用这个函数，返回的值是没有结果的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;filter()&lt;/code&gt;会根据传进去的参数，调用&lt;code&gt;func()&lt;/code&gt;函数，这个函数根据返回值&lt;code&gt;pass&lt;/code&gt;，来确定函数&lt;code&gt;li&lt;/code&gt;要不要添加到新的列表里面。&lt;/p&gt;
&lt;p&gt;如果将代码修改成这样&lt;code&gt;return True&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;def fun(n):
    return True

li = [1,2,122,331,11,22,33,4,6,7,2,88,31]

res=filter(fun,li)
print(list(res))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/qinghanstudy/qinghan/raw/master/img/20201224133607.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;返回一个 False:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/qinghanstudy/qinghan/raw/master/img/20201224133723.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输出结果是一个都没有了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;filter()&lt;/code&gt;函数可以过滤，可以写过滤条件。比如要保留&lt;code&gt;n&amp;lt;10&lt;/code&gt;的数据要保留下来，&lt;code&gt;n&amp;lt;10&lt;/code&gt;是个比较语句。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;n&amp;lt;10&lt;/code&gt;返回的是个 True（当前传入的参数保留，添加到新的列表里面），&lt;code&gt;n&amp;gt;10&lt;/code&gt;返回的是个 False（就把数据去掉不要了）：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-PYTHON&quot;&gt;def fun(n):
    return n&amp;lt;10

li = [1,2,122,331,11,22,33,4,6,7,2,88,31]

res=filter(fun,li)
print(list(res))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/qinghanstudy/qinghan/raw/master/img/20201224134818.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实和这段代码的操作是一样一样的：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-PYTHON&quot;&gt;li1 = []
for i in li:
    if i &amp;gt; 10:
        li1.append(i)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;内部操作是这样的：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义了个新的列表&lt;code&gt;li1&lt;/code&gt;，在这里面来了一个&lt;code&gt;for&lt;/code&gt;循环，判断&lt;code&gt;i&lt;/code&gt;是不是大于 10，如果大于 10，就把它添加到新的列表里面。&lt;/p&gt;
&lt;p&gt;会根据你传入的参数&lt;code&gt;fun(n)&lt;/code&gt;进行相应的判断和比较。根据函数返回的是&lt;code&gt;True&lt;/code&gt;还是&lt;code&gt;None&lt;/code&gt;，来决定这个数据要不要保留起来。&lt;/p&gt;
&lt;h3 id=&quot;2生成器、迭代器都是可迭代对象&quot;&gt;2.生成器、迭代器都是可迭代对象&lt;/h3&gt;
&lt;p&gt;定义个生成器、可迭代对象、迭代器：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-PYTHON&quot;&gt;from collections import Iterator,Iterable,Generator
def fun(n):
    return n &amp;lt; 10

# 列表就是可迭代对象
li = [1, 2, 122, 331, 11, 22, 33, 4, 6, 7, 2, 88, 31]
res = filter(fun, li)

# 定义个迭代器
# 可以把一个可迭代对象转换成一个迭代器
li2 = iter(li)

# 定义个生成器
li3 = (i for i in range(5))

# 用isinstance 判断下列表是不是个可迭代对象
print(isinstance(li,Iterable))
print(isinstance(li2,Iterable))
print(isinstance(li3,Iterable))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;isinstance()&lt;/code&gt; 函数来判断一个对象是否是一个已知的类型，类似 &lt;code&gt;type()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/qinghanstudy/qinghan/raw/master/img/20201224143240.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;返回都是&lt;code&gt;True&lt;/code&gt;，所以它们 3 个都是可迭代对象。&lt;/p&gt;
&lt;p&gt;生成器属于迭代器，那么生成器也是可迭代对象。迭代器是可迭代对象，但是迭代器不是生成器。&lt;/p&gt;
&lt;h2 id=&quot;二、map函数&quot;&gt;二、map()函数&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;map()&lt;/code&gt;的机制和&lt;code&gt;filter()&lt;/code&gt;是一样的。它也会将后面的可迭代对象里面的数据迭代出来，放到第一个函数里面。&lt;/p&gt;
&lt;p&gt;它接收的也是 2 个参数。&lt;strong&gt;第一个参数：&lt;code&gt;func&lt;/code&gt; ，第二个参数：可迭代对象。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-PYTHON&quot;&gt;def fun(n):
    return n &amp;lt; 10

# 列表就是可迭代对象
li = [1, 2, 122, 331, 11, 22, 33, 4, 6, 7, 2, 88, 31]
res = filter(fun, li)

# map:将可迭代对象中的数据迭代出来，一个一个传到函数中去调用，将返回结果放到新的对象中。
res2=map(fun,li)
print(list(res2))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/qinghanstudy/qinghan/raw/master/img/20201224144608.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;它返回的结果全是&lt;code&gt;True&lt;/code&gt;和&lt;code&gt;False&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;map()函数可以用来做：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.把这些数据做统一的处理，比如算这些数据的阶乘，有一批数据要算阶乘，可以一起拿过去。&lt;/p&gt;
&lt;p&gt;2.它会把数据当作个参数，放到函数里去调用。&lt;/p&gt;
&lt;p&gt;3.然后把函数的返回值放到一个列表里面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/qinghanstudy/qinghan/raw/master/img/20201224145551.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;它返回什么就放什么，改成返回 1000：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/qinghanstudy/qinghan/raw/master/img/20201224150209.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;改成&lt;code&gt;n*2&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/qinghanstudy/qinghan/raw/master/img/20201224150453.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;map()&lt;/code&gt;将可迭代对象里面的元素迭代出来，每个元素当作一个参数，传到前面这个函数&lt;code&gt;fun&lt;/code&gt;里面，然后把函数的返回值添加到新的列表里面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/qinghanstudy/qinghan/raw/master/img/20201224150903.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;要统一处理一批数据的时候，就可以通过它来做。&lt;/p&gt;
&lt;h2 id=&quot;三、zip函数&quot;&gt;三、zip()函数&lt;/h2&gt;
&lt;h3 id=&quot;1什么是-zip函数&quot;&gt;1.什么是 zip()函数&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;zip()函数后面接收的是个可迭代对象，后面可接收多个可迭代对象。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/qinghanstudy/qinghan/raw/master/img/20201224151656.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;来看看 zip 的源码：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;它的内部其实也是个类，那么它返回的就是个可迭代对象。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/qinghanstudy/qinghan/raw/master/img/20201224151929.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;准确得来说，它是个迭代器，迭代器也属于可迭代对象。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-PYTHON&quot;&gt;# zip # 打包
res3 = zip([1, 2, 3], [11, 22, 33])
print(res3)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 Python2 的时候，&lt;code&gt;filter()&lt;/code&gt;、&lt;code&gt;map()&lt;/code&gt;、&lt;code&gt;zip()&lt;/code&gt;函数返回出来的直接是列表。Python3 做了个性能的优化，返回的是个迭代器，可以节约内存。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/qinghanstudy/qinghan/raw/master/img/20201224152817.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过&lt;code&gt;next()&lt;/code&gt;去取值，能获取出来内容的话，说明它就是个迭代器：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/qinghanstudy/qinghan/raw/master/img/20201224152948.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;直接一次性把它转换成列表，方便看结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-PYTHON&quot;&gt;# zip # 打包
res3 = zip([1, 2, 3], [11, 22, 33])
print(list(res3))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;它是这样打包的：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;zip()&lt;/code&gt;函数传入 2 个可迭代对象，把第一个可迭代对象的第一个元素和第二个可迭代对象的第一个元素拿出来打包成一个元组，后面以此类推。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/qinghanstudy/qinghan/raw/master/img/20201224153650.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/qinghanstudy/qinghan/raw/master/img/20201224154015.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;为什么里面放的是元组？&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;元组省内存啊。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;如果可迭代对象里面元素多少不一样（长短不一）怎么办？&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-PYTHON&quot;&gt;# zip # 打包
res3 = zip([1, 2, 3], [11, 22, 33,44,55],[111,222,333],[111,222,333])
print(list(res3))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它会只会保留最短的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/qinghanstudy/qinghan/raw/master/img/20201224154916.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码中最短的一组：这里只有 3 个元素。&lt;/p&gt;
&lt;p&gt;那么这里的话，只会分成 3 组。就算第二组有 5 个元素，只会拿第一个、第二个、第三个。多余的数据清除掉了，不要了。&lt;/p&gt;
&lt;h3 id=&quot;2zip可以快速创建字典&quot;&gt;2.zip()可以快速创建字典&lt;/h3&gt;
&lt;p&gt;你看，和字典&lt;code&gt;items()&lt;/code&gt;取值出来的数据是一样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/qinghanstudy/qinghan/raw/master/img/20201224161106.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过&lt;code&gt;dict&lt;/code&gt;转换下，你看，它变成了一个字典：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-PYTHON&quot;&gt;# zip # 打包
res3 = zip([1, 2, 3], [11, 22, 33])
print(dict(list(res3)))

dict1={&quot;key1&quot;:1,&quot;key2&quot;:2,&quot;key3&quot;:3}
print(list(dict1.items()))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/qinghanstudy/qinghan/raw/master/img/20201224161248.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;创建字典的时候，可通过这种方式快速创建字典。&lt;/p&gt;
&lt;p&gt;把键放在一个列表里，把值放在一个列表里，通过&lt;code&gt;zip()&lt;/code&gt;打包一下，通过&lt;code&gt;dit()&lt;/code&gt;就能把它转换成一个字典。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;公众号&lt;strong&gt;清菡软件测试&lt;/strong&gt;首发，更多原创文章：&lt;strong&gt;清菡软件测试 112+原创文章&lt;/strong&gt;，欢迎关注、交流，禁止第三方擅自转载。&lt;/p&gt;
</description>
<pubDate>Thu, 24 Dec 2020 16:10:00 +0000</pubDate>
<dc:creator>清菡</dc:creator>
<og:description>坚持原创输出，点击蓝字关注我吧 作者：清菡 博客：oschina、云+社区、知乎等各大平台都有。 由于微信公众号推送改为了信息流的形式，防止走丢，请给加个星标 ⭐，你就可以第一时间接收到本公众号的推送</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qinghan123/p/14187006.html</dc:identifier>
</item>
<item>
<title>ucore操作系统学习(七) ucore lab7同步互斥 - 小熊餐馆</title>
<link>http://www.cnblogs.com/xiaoxiongcanguan/p/14152830.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaoxiongcanguan/p/14152830.html</guid>
<description>&lt;p&gt;　　ucore在前面的实验中实现了进程/线程机制，并在lab6中实现了抢占式的线程调度机制。基于中断的抢占式线程调度机制使得线程在执行的过程中随时可能被操作系统打断，被阻塞挂起而令其它的线程获得CPU。多个线程并发的执行，大大提升了非cpu密集型应用程序的cpu吞吐量，使得计算机系统中宝贵的cpu硬件资源得到了充分利用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　操作系统提供的内核线程并发机制的优点是明显的，但同时也带来了一些问题，其中首当其冲的便是线程安全问题。&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;并发带来的线程安全问题&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;　　线程安全指的是在拥有共享数据的多条线程并行执行的程序中，线程安全的代码会通过同步机制保证各个线程都可以正常且正确的执行，不会出现数据污染等意外情况。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　举一个经典的例子：在高级语言中对于某一共享整型变量i（假设i=5）进行的i++操作，在最终的机器代码中会被分解为几个更细致的机器指令：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　1. 从内存的对应地址中读取出变量i的值（高级语言的变量在机器层面表现为一个内存地址），写入cpu的寄存器中（假设是edx）&lt;/p&gt;
&lt;p&gt;　　2. 对寄存器edx进行+1运算（运算后edx寄存器中的值为5+1=6）&lt;/p&gt;
&lt;p&gt;　　3. 将edx的值写入变量i对应的内存空间中（在高级语言层面看，写入edx中的新值后i变成了6）&lt;/p&gt;
&lt;p&gt;　　通过之前lab5/lab6的学习，我们知道在i++具体的机器指令序列执行的每一步过程中，操作系统都可能通过时钟中断打断对应线程的执行，进行线程的上下文切换。机器指令是原子性的，但高级语言中的一条指令底层可能对应多个机器指令，在执行的过程中可能被中断介入，无法保证执行的连贯性。&lt;/p&gt;
&lt;h2&gt;线程安全问题举例&lt;/h2&gt;
&lt;p&gt;　　例如，存在两个并发执行的线程a、线程b，都对线程间的共享变量i（i=5）进行了i++操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;两个线程的执行i++时的机器指令流按照时间顺序依次为：　　&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　1. 线程a读取内存中变量i的值，写入寄存器edx（此时内存中i的值为5，edx的值为5）。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　2. 线程a令edx进行+1运算，此时寄存器edx的值为6。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　3. 操作系统处理时钟中断，发现线程a的时间片已经用完，将其挂起，保存线程a的上下文（此时线程a的寄存器上下文中edx=6）；并调度线程b开始获取cpu执行。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　4. 线程b读取内存中变量i的值，写入寄存器edx（此时内存中i的值为5，edx的值为5）。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　5. 线程b令edx进行+1运算，此时寄存器edx的值为6。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　6. 操作系统处理时钟中断，发现线程b的时间片已经用完，将其挂起，保存线程b的上下文（此时线程b的寄存器上下文中edx=6）；并调度线程a开始获取cpu执行。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　7. 线程a恢复现场继续往下执行，将现场恢复后edx的值写回内存中变量i对应的内存地址中，写回后变量i=6。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　8. 操作系统处理时钟中断，发现线程a的时间片已经用完，将其挂起；并调度线程a开始获取cpu执行。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　9. 线程b恢复现场继续往下执行，将现场恢复后edx的值写会内存中变量i对应的内存地址中，写回后变量i=6。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　上述的例子中，由于操作系统的抢占式调度以及高级语言中i++操作的非原子性，使得原本初始值为5的变量i，在执行两次i++之后得到的并不是预期的7，而是错误的6。这还仅仅是两个并发线程对于一个共享变量的操作问题，实际的程序中会涉及到更多的并发线程和共享变量，使得所编写的多线程并发程序正确性无法得到保证。&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;操作系统解决线程安全问题的手段&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;在绝大多数情况下，程序的正确性都比性能重要的多。操作系统在引入抢占式调度的线程并发机制的同时，也需要提供相应的手段来解决线程安全问题。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;解决线程安全问题，主要有两个思路：一是消除程序的并发性；二是阻止多个线程并发的访问共享资源(共享内存、共享文件、共享外设等等)的访问，即互斥：使得一个线程在访问某一共享资源时，其它的线程不能进行同样的操作。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　第一种思路被一些I/O密集型的应用程序所使用，即整个程序(进程)中只有一个线程在工作，通过操作系统底层提供的i/o多路复用机制进行工作，早期的redis以及nodeJS就是工作在单线程模型下的。单线程工作的应用程序由于不存在多个线程并发执行的场景，消除了线程的并发性，自然也不需要处理线程安全问题了。&lt;/p&gt;
&lt;p&gt;　　而操作系统解决线程安全问题的方式采用的是第二种思路(通用操作系统是用于同时为大量进程、线程服务的，因此不能再回过头来禁止并发)，通过一些机制限制并发线程同时访问会引起线程安全问题的共享变量，保证访问的互斥性。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;　　在关于操作系统原理的理论书籍中介绍了很多用于实现互斥机制的办法，而ucore在lab7中主要实现了“信号量”和“条件变量”这两种效率较高的、主流的、基于休眠/唤醒机制的同步互斥机制。lab7中也以哲学家就餐问题为例，通过信号量Semaphore以及管程Monitor解决并发领域中很经典的线程同步问题。&lt;/strong&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;　　通过lab7的学习，将能够深入学习操作系统底层实现线程同步、互斥机制，理解信号量、条件变量、管程等同步互斥机制的工作原理；也可以对更上层的如java中的synchronized、AQS悲观锁、管程monitor、notify/wait等线程并发同步机制有更深的理解。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　lab7是建立在之前实验的基础之上的，需要先理解之前的实验才能更好的理解lab7中的内容。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可以参考一下我关于前面实验的博客：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　1. &lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2 vertical-middle&quot; href=&quot;https://www.cnblogs.com/xiaoxiongcanguan/p/13714587.html&quot;&gt;ucore操作系统学习(一) ucore lab1系统启动流程分析&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　2. &lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2 vertical-middle&quot; href=&quot;https://www.cnblogs.com/xiaoxiongcanguan/p/13756389.html&quot;&gt;ucore操作系统学习(二) ucore lab2物理内存管理分析&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　3. &lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2 vertical-middle&quot; href=&quot;https://www.cnblogs.com/xiaoxiongcanguan/p/13854711.html&quot;&gt;ucore操作系统学习(三) ucore lab3虚拟内存管理分析&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　4. &lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2 vertical-middle&quot; href=&quot;https://www.cnblogs.com/xiaoxiongcanguan/p/13904233.html&quot;&gt;ucore操作系统学习(四) ucore lab4内核线程管理&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　5. &lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2 vertical-middle&quot; href=&quot;https://www.cnblogs.com/xiaoxiongcanguan/p/14007886.html&quot;&gt;ucore操作系统学习(五) ucore lab5用户进程管理&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　6. &lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2 vertical-middle&quot; href=&quot;https://www.cnblogs.com/xiaoxiongcanguan/p/14087833.html&quot;&gt;ucore操作系统学习(六) ucore lab6线程调度器&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　ucore在lab7中的内容大致分为以下几个部分：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;1.  实现等待队列&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　2.  实现信号量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　3.  使用信号量解决哲学家就餐问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　4.  基于信号量实现条件变量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　5.  基于信号量和条件变量实现管程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　6.  使用管程解决哲学家就餐问题&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;2.1 实现等待队列&lt;/h2&gt;
&lt;h3&gt;等待队列介绍&lt;/h3&gt;
&lt;p&gt;　　前面提到，ucore在lab7中实现的同步机制是基于休眠/唤醒机制的。为了保证线程对于临界区访问的互斥性，在前一个线程已经进入了临界区后，后续要访问临界区的线程会被阻塞以等待前一个线程离开临界区，在之前进入临界区的线程离开临界区后被阻塞的线程会被再次唤醒获得进入临界区的资格。&lt;/p&gt;
&lt;p&gt;　　在有许多线程并发时，可能会有不止一个线程被阻塞在对应的临界区，为此抽象出了等待队列结构(&lt;strong&gt;wait_queue&lt;/strong&gt;)用于维护这一被阻塞线程的集合。当线程由于互斥而被阻塞在临界区时，将其加入等待队列并放弃cpu进入阻塞态；当之前获得临界区访问权限的线程离开后，再从对应的等待队列中选择一个被阻塞、处于等待状态的线程唤醒，被唤醒的线程能接着进入临界区。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　利用等待队列，使得自始至终都只有最多一个线程在临界区中，保证了互斥性；而线程在等待队列中的休眠(阻塞)/唤醒动作，则实现了线程之间对于临界区访问的同步。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　等待队列当然并不只适用于线程并发同步，当线程进入等待状态以等待某一特定完成事件时(定时休眠一段时间、等待阻塞IO读写完成等等事件)，底层都可以使用等待队列来实现。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;等待队列实现&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;　　ucore在/kern/sync目录下的wait.c、wait.h中实现了等待队列wait_queue、等待队列节点项wait_t以及相关的函数。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　ucore的等待队列底层是通过双向链表结构实现的。和前面的实验类似的，提供了一个宏定义le2wait用于访问wait_link节点项对应的wait_t结构。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;等待队列结构：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 等待队列
 * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
typedef &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 等待队列的头结点(哨兵节点)&lt;/span&gt;
&lt;span&gt;    list_entry_t wait_head;
} wait_queue_t;

&lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; proc_struct;

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 等待队列节点项
 * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
typedef &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 关联的线程&lt;/span&gt;
    &lt;span&gt;struct&lt;/span&gt; proc_struct *&lt;span&gt;proc;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 唤醒标识&lt;/span&gt;
&lt;span&gt;    uint32_t wakeup_flags;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 该节点所属的等待队列&lt;/span&gt;
    wait_queue_t *&lt;span&gt;wait_queue;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 等待队列节点&lt;/span&gt;
&lt;span&gt;    list_entry_t wait_link;
} wait_t;

&lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; le2wait(le, member)         \&lt;span&gt;
    to_struct((le), wait_t, member)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;等待队列结构底层操作：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化wait_t等待队列项&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; wait_init(wait_t *wait, &lt;span&gt;struct&lt;/span&gt; proc_struct *&lt;span&gt;proc);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化等待队列&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; wait_queue_init(wait_queue_t *&lt;span&gt;queue);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将wait节点项插入等待队列&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; wait_queue_add(wait_queue_t *queue, wait_t *&lt;span&gt;wait);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将wait项从等待队列中移除&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; wait_queue_del(wait_queue_t *queue, wait_t *&lt;span&gt;wait);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取等待队列中wait节点的下一项&lt;/span&gt;
wait_t *wait_queue_next(wait_queue_t *queue, wait_t *&lt;span&gt;wait);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取等待队列中wait节点的前一项&lt;/span&gt;
wait_t *wait_queue_prev(wait_queue_t *queue, wait_t *&lt;span&gt;wait);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取等待队列的第一项&lt;/span&gt;
wait_t *wait_queue_first(wait_queue_t *&lt;span&gt;queue);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取等待队列的最后一项&lt;/span&gt;
wait_t *wait_queue_last(wait_queue_t *&lt;span&gt;queue);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 等待队列是否为空&lt;/span&gt;
&lt;span&gt;bool&lt;/span&gt; wait_queue_empty(wait_queue_t *&lt;span&gt;queue);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; wait项是否在等待队列中&lt;/span&gt;
&lt;span&gt;bool&lt;/span&gt; wait_in_queue(wait_t *&lt;span&gt;wait);&lt;br/&gt;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将wait项从等待队列中删除（如果存在的话）&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; wait_current_del(queue, wait)                                       \
    &lt;span&gt;do&lt;/span&gt;&lt;span&gt; {                                                                    \
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (wait_in_queue(wait)) {                                          \
            wait_queue_del(queue, wait);                                    \
        }                                                                   \
    } &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt; /* !__KERN_SYNC_WAIT_H__ */
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37.5&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_8ee5c62f-ab3f-4d9a-a4aa-7c1481cdaf59&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_8ee5c62f-ab3f-4d9a-a4aa-7c1481cdaf59&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_8ee5c62f-ab3f-4d9a-a4aa-7c1481cdaf59&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;70&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 初始化wait_t等待队列项
 * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt;
wait_init(wait_t &lt;/span&gt;*wait, &lt;span&gt;struct&lt;/span&gt; proc_struct *&lt;span&gt;proc) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; wait项与proc建立关联&lt;/span&gt;
    wait-&amp;gt;proc =&lt;span&gt; proc;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 等待的状态&lt;/span&gt;
    wait-&amp;gt;wakeup_flags =&lt;span&gt; WT_INTERRUPTED;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 加入等待队列&lt;/span&gt;
    list_init(&amp;amp;(wait-&amp;gt;&lt;span&gt;wait_link));
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 初始化等待队列
 * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt;
wait_queue_init(wait_queue_t &lt;/span&gt;*&lt;span&gt;queue) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 等待队列头结点初始化&lt;/span&gt;
    list_init(&amp;amp;(queue-&amp;gt;&lt;span&gt;wait_head));
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 将wait节点项插入等待队列
 * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt;
wait_queue_add(wait_queue_t &lt;/span&gt;*queue, wait_t *&lt;span&gt;wait) {
    assert(list_empty(&lt;/span&gt;&amp;amp;(wait-&amp;gt;wait_link)) &amp;amp;&amp;amp; wait-&amp;gt;proc !=&lt;span&gt; NULL);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; wait项与等待队列建立关联&lt;/span&gt;
    wait-&amp;gt;wait_queue =&lt;span&gt; queue;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将wait项插入头结点前&lt;/span&gt;
    list_add_before(&amp;amp;(queue-&amp;gt;wait_head), &amp;amp;(wait-&amp;gt;&lt;span&gt;wait_link));
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 将wait项从等待队列中移除
 * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt;
wait_queue_del(wait_queue_t &lt;/span&gt;*queue, wait_t *&lt;span&gt;wait) {
    assert(&lt;/span&gt;!list_empty(&amp;amp;(wait-&amp;gt;wait_link)) &amp;amp;&amp;amp; wait-&amp;gt;wait_queue ==&lt;span&gt; queue);
    list_del_init(&lt;/span&gt;&amp;amp;(wait-&amp;gt;&lt;span&gt;wait_link));
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 获取等待队列中wait节点的下一项
 * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
wait_t &lt;/span&gt;*&lt;span&gt;
wait_queue_next(wait_queue_t &lt;/span&gt;*queue, wait_t *&lt;span&gt;wait) {
    assert(&lt;/span&gt;!list_empty(&amp;amp;(wait-&amp;gt;wait_link)) &amp;amp;&amp;amp; wait-&amp;gt;wait_queue ==&lt;span&gt; queue);
    list_entry_t &lt;/span&gt;*le = list_next(&amp;amp;(wait-&amp;gt;&lt;span&gt;wait_link));
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (le != &amp;amp;(queue-&amp;gt;&lt;span&gt;wait_head)) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; *wait的下一项不是头结点，将其返回&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; le2wait(le, wait_link);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NULL;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 获取等待队列中wait节点的前一项
 * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
wait_t &lt;/span&gt;*&lt;span&gt;
wait_queue_prev(wait_queue_t &lt;/span&gt;*queue, wait_t *&lt;span&gt;wait) {
    assert(&lt;/span&gt;!list_empty(&amp;amp;(wait-&amp;gt;wait_link)) &amp;amp;&amp;amp; wait-&amp;gt;wait_queue ==&lt;span&gt; queue);
    list_entry_t &lt;/span&gt;*le = list_prev(&amp;amp;(wait-&amp;gt;&lt;span&gt;wait_link));
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (le != &amp;amp;(queue-&amp;gt;&lt;span&gt;wait_head)) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; *wait的前一项不是头结点，将其返回&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; le2wait(le, wait_link);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NULL;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 获取等待队列的第一项
 * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
wait_t &lt;/span&gt;*&lt;span&gt;
wait_queue_first(wait_queue_t &lt;/span&gt;*&lt;span&gt;queue) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取头结点的下一项&lt;/span&gt;
    list_entry_t *le = list_next(&amp;amp;(queue-&amp;gt;&lt;span&gt;wait_head));
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (le != &amp;amp;(queue-&amp;gt;&lt;span&gt;wait_head)) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 头结点的下一项不是头结点，将其返回&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; le2wait(le, wait_link);
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 头结点的下一项还是头结点，说明等待队列为空(只有一个wait_head哨兵节点)&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; NULL;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 获取等待队列的最后一项
 * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
wait_t &lt;/span&gt;*&lt;span&gt;
wait_queue_last(wait_queue_t &lt;/span&gt;*&lt;span&gt;queue) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取头结点的前一项&lt;/span&gt;
    list_entry_t *le = list_prev(&amp;amp;(queue-&amp;gt;&lt;span&gt;wait_head));
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (le != &amp;amp;(queue-&amp;gt;&lt;span&gt;wait_head)) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 头结点的前一项不是头结点，将其返回&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; le2wait(le, wait_link);
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 头结点的前一项还是头结点，说明等待队列为空(只有一个wait_head哨兵节点)&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; NULL;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 等待队列是否为空
 * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;bool&lt;/span&gt;&lt;span&gt;
wait_queue_empty(wait_queue_t &lt;/span&gt;*&lt;span&gt;queue) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; list_empty(&amp;amp;(queue-&amp;gt;&lt;span&gt;wait_head));
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * wait项是否在等待队列中
 * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;bool&lt;/span&gt;&lt;span&gt;
wait_in_queue(wait_t &lt;/span&gt;*&lt;span&gt;wait) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; !list_empty(&amp;amp;(wait-&amp;gt;&lt;span&gt;wait_link));
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;等待队列休眠/唤醒等高层操作：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　等待队列对于线程的休眠、唤醒对应的高级操作依赖于上面介绍的、底层的等待队列增删改查操作。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将等待队列中的wait项对应的线程唤醒&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; wakeup_wait(wait_queue_t *queue, wait_t *wait, uint32_t wakeup_flags, &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; del);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将等待队列中的第一项对应的线程唤醒&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; wakeup_first(wait_queue_t *queue, uint32_t wakeup_flags, &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; del);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将等待队列中的所有项对应的线程全部唤醒&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; wakeup_queue(wait_queue_t *queue, uint32_t wakeup_flags, &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; del);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 令对应wait项加入当前等待队列;令当前线程阻塞休眠，挂载在该等待队列中&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; wait_current_set(wait_queue_t *queue, wait_t *&lt;span&gt;wait, uint32_t wait_state);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43.5&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_78d5cedd-9167-40ec-b4cf-b69861be48f3&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_78d5cedd-9167-40ec-b4cf-b69861be48f3&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_78d5cedd-9167-40ec-b4cf-b69861be48f3&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;82&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 将等待队列中的wait项对应的线程唤醒
 * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt;
wakeup_wait(wait_queue_t &lt;/span&gt;*queue, wait_t *wait, uint32_t wakeup_flags, &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; del) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (del) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将wait项从等待队列中删除&lt;/span&gt;
&lt;span&gt;        wait_queue_del(queue, wait);
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置唤醒的原因标识&lt;/span&gt;
    wait-&amp;gt;wakeup_flags =&lt;span&gt; wakeup_flags;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 唤醒对应线程&lt;/span&gt;
    wakeup_proc(wait-&amp;gt;&lt;span&gt;proc);
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 将等待队列中的第一项对应的线程唤醒
 * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt;
wakeup_first(wait_queue_t &lt;/span&gt;*queue, uint32_t wakeup_flags, &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; del) {
    wait_t &lt;/span&gt;*&lt;span&gt;wait;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((wait = wait_queue_first(queue)) !=&lt;span&gt; NULL) {
        wakeup_wait(queue, wait, wakeup_flags, del);
    }
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 将等待队列中的所有项对应的线程全部唤醒
 * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt;
wakeup_queue(wait_queue_t &lt;/span&gt;*queue, uint32_t wakeup_flags, &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; del) {
    wait_t &lt;/span&gt;*&lt;span&gt;wait;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((wait = wait_queue_first(queue)) !=&lt;span&gt; NULL) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (del) {
            &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
                wakeup_wait(queue, wait, wakeup_flags, &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
            } &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; ((wait = wait_queue_first(queue)) !=&lt;span&gt; NULL);
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
                wakeup_wait(queue, wait, wakeup_flags, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
            } &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; ((wait = wait_queue_next(queue, wait)) !=&lt;span&gt; NULL);
        }
    }
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 令对应wait项加入当前等待队列;令当前线程阻塞休眠，挂载在该等待队列中
 * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt;
wait_current_set(wait_queue_t &lt;/span&gt;*queue, wait_t *&lt;span&gt;wait, uint32_t wait_state) {
    assert(current &lt;/span&gt;!=&lt;span&gt; NULL);
    wait_init(wait, current);
    current&lt;/span&gt;-&amp;gt;state =&lt;span&gt; PROC_SLEEPING;
    current&lt;/span&gt;-&amp;gt;wait_state =&lt;span&gt; wait_state;
    wait_queue_add(queue, wait);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h2&gt;2.2 实现信号量&lt;/h2&gt;
&lt;p&gt;　　信号量是一种同步互斥机制的实现，普遍存在于现在的各种操作系统内核里，最早是由著名计算机科学家Dijkstra提出。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ucore信号量定义：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　信号量的定义和使用非常简单和基础，包含了一个信号量的值value以及用于线程同步的等待队列。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 信号量
 * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
typedef &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 信号量值&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt;&lt;span&gt; value;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 信号量对应的等待队列&lt;/span&gt;
&lt;span&gt;    wait_queue_t wait_queue;
} semaphore_t;

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 初始化信号量
 * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt;
sem_init(semaphore_t &lt;/span&gt;*sem, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; value) {
    sem&lt;/span&gt;-&amp;gt;value =&lt;span&gt; value;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化等待队列&lt;/span&gt;
    wait_queue_init(&amp;amp;(sem-&amp;gt;&lt;span&gt;wait_queue));
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　信号量的主要操作分别是down和up，对应于Dijkstra提出信号量时提出的P/V操作。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;信号量作为同步互斥的基本结构，其down/up操作必须是原子性的，无法被打断发生上下文切换。令软件程序表现出原子性的方法有很多，由于ucore是运行在单核的80386cpu上的，简单起见便直接使用关闭中断的方式来实现信号量操作的原子性(多核cpu的情况下，关闭单核的中断是不够的，而关闭所有核心的中断则性能损失太大，需要采取锁总线等其它手段来实现软件原子性)。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;信号量的down操作：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;信号量的&lt;strong&gt;down&lt;/strong&gt;操作，是请求获取一个信号量。&lt;/p&gt;
&lt;p&gt;　　当信号量的value值大于0时，说明还能容纳当前线程进入临界区。&lt;/p&gt;
&lt;p&gt;　　当信号量的value值等于0时，说明已经无法容纳更多的线程了，此时需要将当前线程阻塞在信号量的等待队列上，等待信号量的up操作将其唤醒。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 信号量down操作 扣减信号量
 * 当信号量value不足时将当前线程阻塞在信号量上，等待其它线程up操作时将其唤醒
 * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; __noinline uint32_t __down(semaphore_t *&lt;span&gt;sem, uint32_t wait_state) {
    &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt;&lt;span&gt; intr_flag;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 暂时关闭中断，保证信号量的down操作是原子操作&lt;/span&gt;
&lt;span&gt;    local_intr_save(intr_flag);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sem-&amp;gt;value &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 信号量对应的value大于0，还有权使用&lt;/span&gt;
        sem-&amp;gt;value --&lt;span&gt;;
        local_intr_restore(intr_flag);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 信号量对应的value小于等于0，需要阻塞当前线程&lt;/span&gt;
    wait_t __wait, *wait = &amp;amp;&lt;span&gt;__wait;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 令当前线程挂在信号量的阻塞队列中&lt;/span&gt;
    wait_current_set(&amp;amp;(sem-&amp;gt;&lt;span&gt;wait_queue), wait, wait_state);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 恢复中断，原子操作结束&lt;/span&gt;
&lt;span&gt;    local_intr_restore(intr_flag);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前线程进入阻塞状态了，进行一次调度&lt;/span&gt;
&lt;span&gt;    schedule();

    local_intr_save(intr_flag);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 唤醒后，原子操作将当前项从信号量的等待队列中删除&lt;/span&gt;
    wait_current_del(&amp;amp;(sem-&amp;gt;&lt;span&gt;wait_queue), wait);
    local_intr_restore(intr_flag);

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (wait-&amp;gt;wakeup_flags !=&lt;span&gt; wait_state) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果等待线程唤醒的标识与之前设置的参数wait_state不一致，将其状态返回给调用方做进一步判断&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; wait-&amp;gt;&lt;span&gt;wakeup_flags;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;信号量的up操作：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　信号量的up操作，是增加一个信号量中的值。&lt;/p&gt;
&lt;p&gt;　　当增加信号量值时发现当前信号量的等待队列为空时，则说明当前没有线程被阻塞、需要进入信号量管制的临界区中，简单的将信号量值加1。&lt;/p&gt;
&lt;p&gt;　　当增加信号量时发现等待队列不为空，则说明存在线程想要进入临界区中，却由于没有满足信号量的条件，被阻塞在了临界区外。此时便从信号量的等待队列中挑选出最早被阻塞的线程，将其唤醒，使得其得以进入临界区。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 信号量up操作 增加信号量或唤醒被阻塞在信号量上的一个线程（如果有的话）
 * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; __noinline &lt;span&gt;void&lt;/span&gt; __up(semaphore_t *&lt;span&gt;sem, uint32_t wait_state) {
    &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt;&lt;span&gt; intr_flag;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 暂时关闭中断，保证信号量的up操作是原子操作&lt;/span&gt;
&lt;span&gt;    local_intr_save(intr_flag);
    {
        wait_t &lt;/span&gt;*&lt;span&gt;wait;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((wait = wait_queue_first(&amp;amp;(sem-&amp;gt;wait_queue))) ==&lt;span&gt; NULL) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 信号量的等待队列为空，说明没有线程等待在该信号量上
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 信号量value加1&lt;/span&gt;
            sem-&amp;gt;value ++&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;            assert(wait-&amp;gt;proc-&amp;gt;wait_state ==&lt;span&gt; wait_state);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将等待队列中的对应等待线程唤醒&lt;/span&gt;
            wakeup_wait(&amp;amp;(sem-&amp;gt;wait_queue), wait, wait_state, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
        }
    }
    local_intr_restore(intr_flag);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　信号量的down与up操作关系十分紧密，互相对照着看可以更好的理解其工作原理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;互斥信号量：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　value值被初始化为1的信号量比较特殊，称为二元信号量，也被叫做互斥信号量。互斥信号量能够作为mutex互斥锁，用于保证临界区中数据不会被线程并发的访问。&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;2.3 使用信号量解决哲学家就餐问题&lt;/strong&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;strong&gt;哲学家就餐问题介绍&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　哲学家就餐问题是Dijkstra提出的一个经典的多线程同步问题。&lt;strong&gt;大概场景是在一个环形的圆桌上，坐着五个哲学家，而桌上有五把叉子和五个碗。一个哲学家平时进行思考，饥饿时便试图取用其左右最靠近他的叉子，只有在他拿到两只叉子时才能进餐。进餐完毕，放下叉子继续思考。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　解决哲学家就餐问题的基本思路是使用线程模拟哲学家，每个线程对应一个活动着的哲学家。但是由于5个并发活动的哲学家线程争抢仅有的5把叉子，且哲学家只有在同时拿到两根叉子时才能进餐，如果没有良好的同步机制对这5个哲学家线程进行协调，那么哲学家线程互相之间容易发生死锁(例如，五个哲学家线程同时拿起了自己左手边的叉子，都无法拿起自己右边的叉子，互相等待着。哲学家之间将永远无法进餐，纷纷饿死)。&lt;/p&gt;
&lt;p&gt;　　使用Dijkstra提出的信号量机制可以很好的解决哲学家就餐问题，下面看看ucore中是如何使用信号量解决哲学家就餐问题的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;哲学家线程主体执行逻辑：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　ucore的lab7中的check_sync函数是整个lab7实验的总控函数。在check_sync的前半部分使用kern_thread函数创建了N(N=5)个哲学家内核线程，用于执行philosopher_using_semaphore，模拟哲学家就餐问题。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;philosopher_using_semaphore中哲学家循环往复的进行如下操作：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;　　1. 哲学家进行思考(通过do_sleep系统调用进行休眠阻塞，模拟哲学家思考)&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;　　2. 通过phi_take_forks_sema函数尝试着同时拿起左右两个叉子（如果无法拿到左右叉子，则会陷入阻塞状态）&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;　　3. 哲学家进行就餐(&lt;/strong&gt;&lt;strong&gt;通过do_sleep系统调用进行休眠阻塞，模拟哲学家就餐&lt;/strong&gt;&lt;/strong&gt;)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;　　4. 通过phi_put_forks_sema函数同时放下左右两个叉子&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;　　拿起叉子的&lt;/strong&gt;&lt;strong&gt;phi_take_forks_sema函数和放下叉子&lt;/strong&gt;&lt;strong&gt;phi_put_forks_sema的函数内部都是通过信号量进行同步的，在下面进行更进一步的分析。&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#define&lt;/span&gt; N 5 /* 哲学家数目 */
&lt;span&gt;#define&lt;/span&gt; LEFT (i-1+N)%N /* i的左邻号码 */
&lt;span&gt;#define&lt;/span&gt; RIGHT (i+1)%N /* i的右邻号码 */
&lt;span&gt;#define&lt;/span&gt; THINKING 0 /* 哲学家正在思考 */
&lt;span&gt;#define&lt;/span&gt; HUNGRY 1 /* 哲学家想取得叉子 */
&lt;span&gt;#define&lt;/span&gt; EATING 2 /* 哲学家正在吃面 */
&lt;span&gt;#define&lt;/span&gt; TIMES  4 /* 吃4次饭 */
&lt;span&gt;#define&lt;/span&gt; SLEEP_TIME 10

&lt;span&gt;void&lt;/span&gt; check_sync(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;){
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;check semaphore 信号量解决哲学家就餐问题&lt;/span&gt;
    sem_init(&amp;amp;mutex, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;N;i++&lt;span&gt;){
        sem_init(&lt;/span&gt;&amp;amp;s[i], &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; pid = kernel_thread(philosopher_using_semaphore, (&lt;span&gt;void&lt;/span&gt; *)i, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (pid &amp;lt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
            panic(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;create No.%d philosopher_using_semaphore failed.\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
        philosopher_proc_sema[i] &lt;/span&gt;=&lt;span&gt; find_proc(pid);
        set_proc_name(philosopher_proc_sema[i], &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;philosopher_sema_proc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }

    。。。 条件变量(管程)解决哲学家就餐问题(暂时忽略)
}


&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;---------- philosophers problem using semaphore ----------------------&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; state_sema[N]; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 记录每个人状态的数组 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 信号量是一个特殊的整型变量 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
semaphore_t mutex; &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 临界区互斥 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
semaphore_t s[N]; &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 每个哲学家一个信号量 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 哲学家线程主体执行逻辑
 * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; philosopher_using_semaphore(&lt;span&gt;void&lt;/span&gt; * arg) &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; i：哲学家号码，从0到N-1 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i, iter=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    i&lt;/span&gt;=(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)arg;
    cprintf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;I am No.%d philosopher_sema\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,i);
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(iter++&amp;lt;&lt;span&gt;TIMES)
    { &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 无限循环 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        cprintf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Iter %d, No.%d philosopher_sema is thinking\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,iter,i); &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 哲学家正在思考 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用休眠阻塞来模拟思考(哲学家线程阻塞N秒)&lt;/span&gt;
&lt;span&gt;        do_sleep(SLEEP_TIME);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 哲学家尝试着去拿左右两边的叉子(如果没拿到会阻塞)&lt;/span&gt;
&lt;span&gt;        phi_take_forks_sema(i); 
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 需要两只叉子，或者阻塞 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        cprintf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Iter %d, No.%d philosopher_sema is eating\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,iter,i); &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 进餐 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用休眠阻塞来模拟进餐(哲学家线程阻塞N秒)&lt;/span&gt;
&lt;span&gt;        do_sleep(SLEEP_TIME);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 哲学家就餐结束，将叉子放回桌子。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当发现之前有临近的哲学家尝试着拿左右叉子就餐时却没有成功拿到，尝试着唤醒对应的哲学家&lt;/span&gt;
&lt;span&gt;        phi_put_forks_sema(i); 
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 把两把叉子同时放回桌子 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    }
    cprintf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;No.%d philosopher_sema quit\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,i);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;strong&gt;拿起叉子/放下叉子函数分析：&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　&lt;strong&gt;phi_take_forks_sema&lt;/strong&gt;函数表示&lt;strong&gt;哲学家尝试着拿起左右叉子想要就餐&lt;/strong&gt;；而&lt;strong&gt;phi_put_forks_sema&lt;/strong&gt;函数表示&lt;strong&gt;哲学家进餐结束后放下左右叉子&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　两者都是通过全局的互斥信号量&lt;strong&gt;mutex&lt;/strong&gt;的&lt;strong&gt;down&lt;/strong&gt;操作进行全局的互斥，保证在同一时刻只有一个哲学家线程能够进入临界区，对临界区的资源叉子进行拿起/放下操作。对不同的哲学家线程进行互斥，保证查看左右叉子的状态时不会出现并发问题。在后面对&lt;strong&gt;mutex&lt;/strong&gt;的&lt;strong&gt;up&lt;/strong&gt;操作用于释放&lt;strong&gt;mutex&lt;/strong&gt;互斥信号量，以离开临界区，唤醒可能阻塞在mutex信号量中的其它哲学家线程，让阻塞在&lt;strong&gt;mutex&lt;/strong&gt;信号量中的另一个线程得以进入临界区。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;phi_take_forks_sema函数分析：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在执行&lt;strong&gt;phi_take_forks_sema&lt;/strong&gt;拿叉子时，通过关键的&lt;strong&gt;phi_test_sema&lt;/strong&gt;函数进行条件的判断，判断当前哲学家线程i的左右哲学家线程是否都未就餐。&lt;/p&gt;
&lt;p&gt;　　如果条件满足(在拿叉子时，&lt;strong&gt;phi_test_sema&lt;/strong&gt;前哲学家i已经被预先设置为&lt;strong&gt;HUNGRY&lt;/strong&gt;饥饿状态了)，则代表当前哲学家i可以进餐(其拿起了左右叉子，也代表着其相邻的左右哲学家无法就餐)。&lt;/p&gt;
&lt;p&gt;　　而如果条件不满足则会在&lt;strong&gt;phi_take_forks_sema&lt;/strong&gt;的最后，被&lt;strong&gt;down(&amp;amp;s[i])&lt;/strong&gt;阻塞在信号量&lt;strong&gt;s[i]&lt;/strong&gt;上，等待其被左右两旁就餐完毕的哲学家将其唤醒。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;phi_put_forks_sema函数分析：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 　　在执行&lt;strong&gt;phi_put_forks_sema&lt;/strong&gt;放下叉子时，首先通过设置&lt;strong&gt;state_sema[i]&lt;/strong&gt;的状态为&lt;strong&gt;Thinking&lt;/strong&gt;，代表哲学家i已经就餐完毕重新进入思考状态。同时哲学家i在放下叉子后，通过&lt;strong&gt;phi_test_sema(LEFT)&lt;/strong&gt;和&lt;strong&gt;phi_test_sema(RIGHT)&lt;/strong&gt;来判断相邻的哲学家在自己就餐的这段时间是否也陷入了饥饿状态，却由于暂时拿不到叉子而被阻塞了(LEFT和RIGHT宏利用取模，解决下标回环计算的问题)。如果确实存在这种情况，通过&lt;strong&gt;phi_test_sema&lt;/strong&gt;函数&lt;strong&gt;尝试&lt;/strong&gt;着令相邻的哲学家进行就餐(也许被阻塞哲学家的隔壁另一边的哲学家依然在就餐，那么此时依然无法将其唤醒就餐；而需要等到另一边的哲学家就餐完毕来&lt;strong&gt;尝试&lt;/strong&gt;将其唤醒)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　通过互斥信号量mutex实现哲学家线程就餐对临界区资源-叉子访问的互斥性，避免了并发时对叉子状态判断不准确的情况产生；同时利用信号量数组semaphore_t s[N]对哲学家拿取、放下叉子的操作进行同步，使得哲学家们在叉子资源有限、冲突的情况下有序的就餐，不会出死锁、饥饿等现象。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 哲学家i拿起左右叉子
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; phi_take_forks_sema(&lt;span&gt;int&lt;/span&gt; i) &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; i：哲学家号码从0到N-1 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
{ 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 拿叉子时需要通过mutex信号量进行互斥，防止并发问题(进入临界区)&lt;/span&gt;
    down(&amp;amp;&lt;span&gt;mutex);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 记录下哲学家i饥饿的事实(执行phi_take_forks_sema尝试拿叉子，说明哲学家i进入了HUNGRY饥饿状态)&lt;/span&gt;
    state_sema[i]=&lt;span&gt;HUNGRY;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 试图同时得到左右两只叉子&lt;/span&gt;
&lt;span&gt;    phi_test_sema(i);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 离开临界区(唤醒可能阻塞在mutex上的其它线程)&lt;/span&gt;
    up(&amp;amp;&lt;span&gt;mutex);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; phi_test_sema中如果成功拿到叉子进入了就餐状态，会先执行up(&amp;amp;s[i])，再执行down(&amp;amp;s[i])时便不会阻塞
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 反之，如果phi_test_sema中没有拿到叉子，则down(&amp;amp;s[i])将会令哲学家i阻塞在信号量s[i]上&lt;/span&gt;
    down(&amp;amp;&lt;span&gt;s[i]);
}
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 哲学家i放下左右叉子
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; phi_put_forks_sema(&lt;span&gt;int&lt;/span&gt; i) &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; i：哲学家号码从0到N-1 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
{ 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 放叉子时需要通过mutex信号量进行互斥，防止并发问题(进入临界区)&lt;/span&gt;
    down(&amp;amp;mutex); &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 进入临界区 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 哲学家进餐结束(执行phi_put_forks_sema放下叉子，说明哲学家已经就餐完毕，重新进入THINKING思考状态)&lt;/span&gt;
    state_sema[i]=&lt;span&gt;THINKING;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当哲学家i就餐结束，放下叉子时。需要判断左、右临近的哲学家在自己就餐的这段时间内是否也进入了饥饿状态，却因为自己就餐拿走了叉子而无法同时获得左右两个叉子。
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 为此哲学家i在放下叉子后需要尝试着判断在自己放下叉子后，左/右临近的、处于饥饿的哲学家能否进行就餐,如果可以就唤醒阻塞的哲学家线程，并令其进入就餐状态(EATING)&lt;/span&gt;
    phi_test_sema(LEFT); &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 看一下左邻居现在是否能进餐 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    phi_test_sema(RIGHT); &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 看一下右邻居现在是否能进餐 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    up(&lt;/span&gt;&amp;amp;mutex); &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 离开临界区q(唤醒可能阻塞在mutex上的其它线程) &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 判断哲学家i是否可以拿起左右叉子
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; phi_test_sema(i) &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; i：哲学家号码从0到N-1 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
{ 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当哲学家i处于饥饿状态(HUNGRY),且其左右临近的哲学家都没有在就餐状态(EATING)&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;(state_sema[i]==HUNGRY&amp;amp;&amp;amp;state_sema[LEFT]!=&lt;span&gt;EATING
            &lt;/span&gt;&amp;amp;&amp;amp;state_sema[RIGHT]!=&lt;span&gt;EATING)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 哲学家i饿了(HUNGRY)，且左右两边的叉子都没人用。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 令哲学家进入就餐状态（EATING）&lt;/span&gt;
        state_sema[i]=&lt;span&gt;EATING;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 唤醒阻塞在对应信号量上的哲学家线程(当是哲学家线程i自己执行phi_test_sema(i)时，则信号量直接加1，抵消掉phi_take_forks_sema中的down操作，代表直接拿起叉子就餐成功而不用进入阻塞态)&lt;/span&gt;
        up(&amp;amp;&lt;span&gt;s[i]);
    }
}&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2.4 实现条件变量和管程&lt;/h2&gt;
&lt;h2&gt;&lt;span&gt;　　条件变量和信号量的功能很相似，条件变量也提供了类似的线程同步机制，和信号量的down/up操作对应的是wait和signal操作。在原始的定义中条件变量可以用信号量作为基础实现；反过来信号量也能用已经实现的条件变量来实现。&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　ucore中的条件变量是基于信号量实现的，同时条件变量也作为管程Monitor结构的重要组成部分。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;条件变量condvar结构定义：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 条件变量
 * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
typedef &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; condvar{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 条件变量相关的信号量，用于阻塞/唤醒线程&lt;/span&gt;
    semaphore_t sem;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; the sem semaphore  is used to down the waiting proc, and the signaling proc should up the waiting proc
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 等待在条件变量之上的线程数&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; count;              &lt;span&gt;//&lt;/span&gt;&lt;span&gt; the number of waiters on condvar
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 拥有该条件变量的monitor管程&lt;/span&gt;
    monitor_t * owner;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; the owner(monitor) of this condvar&lt;/span&gt;
} condvar_t;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;管程monitor结构定义：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 管程
 * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
typedef &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; monitor{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 管程控制并发的互斥锁（应该被初始化为1的互斥信号量）&lt;/span&gt;
    semaphore_t mutex;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; the mutex lock for going into the routines in monitor, should be initialized to 1
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 管程内部协调各并发线程的信号量（线程可以通过该信号量挂起自己，其它并发线程或者被唤醒的线程可以反过来唤醒它）&lt;/span&gt;
    semaphore_t next;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; the next semaphore is used to down the signaling proc itself, and the other OR wakeuped waiting proc should wake up the sleeped signaling proc.
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 休眠在next信号量中的线程个数&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; next_count;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; the number of of sleeped signaling proc
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 管程所属的条件变量（可以是数组，对应n个条件变量）&lt;/span&gt;
    condvar_t *cv;          &lt;span&gt;//&lt;/span&gt;&lt;span&gt; the condvars in monitor&lt;/span&gt;
&lt;span&gt;} monitor_t;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 初始化管程
 * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt;     
monitor_init (monitor_t &lt;/span&gt;*&lt;span&gt; mtp, size_t num_cv) {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i;
    assert(num_cv&lt;/span&gt;&amp;gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
    mtp&lt;/span&gt;-&amp;gt;next_count = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    mtp&lt;/span&gt;-&amp;gt;cv =&lt;span&gt; NULL;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 管程的互斥信号量值设为1（初始化时未被锁住）&lt;/span&gt;
    sem_init(&amp;amp;(mtp-&amp;gt;mutex), &lt;span&gt;1&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;unlocked
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 管程的协调信号量设为0，当任何一个线程发现不满足条件时，立即阻塞在该信号量上&lt;/span&gt;
    sem_init(&amp;amp;(mtp-&amp;gt;next), &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 为条件变量分配内存空间（参数num_cv指定管程所拥有的条件变量的个数）&lt;/span&gt;
    mtp-&amp;gt;cv =(condvar_t *) kmalloc(&lt;span&gt;sizeof&lt;/span&gt;(condvar_t)*&lt;span&gt;num_cv);
    assert(mtp&lt;/span&gt;-&amp;gt;cv!=&lt;span&gt;NULL);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 构造对应个数的条件变量&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;; i&amp;lt;num_cv; i++&lt;span&gt;){
        mtp&lt;/span&gt;-&amp;gt;cv[i].count=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 条件变量信号量初始化时设置为0，当任何一个线程发现不满足条件时，立即阻塞在该信号量上&lt;/span&gt;
        sem_init(&amp;amp;(mtp-&amp;gt;cv[i].sem),&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
        mtp&lt;/span&gt;-&amp;gt;cv[i].owner=&lt;span&gt;mtp;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;条件变量的等待操作实现：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　cond_wait函数实现条件变量的wait操作。条件变量的wait操作和信号量的down功能类似。当条件变量对应的条件不满足时，通过信号量的down操作，令当前线程阻塞、等待在条件变量所属的信号量上。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Suspend calling thread on a condition variable waiting for condition Atomically unlocks 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; mutex and suspends calling thread on conditional variable after waking up locks mutex. Notice: mp is mutex semaphore for monitor's procedures&lt;/span&gt;&lt;span&gt;
/*&lt;/span&gt;&lt;span&gt;*
 * 条件变量阻塞等待操作
 * 令当前线程阻塞在该条件变量上，等待其它线程将其通过cond_signal将其唤醒。
 * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt;
cond_wait (condvar_t &lt;/span&gt;*&lt;span&gt;cvp) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;LAB7 EXERCISE1: YOUR CODE&lt;/span&gt;
    cprintf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cond_wait begin:  cvp %x, cvp-&amp;gt;count %d, cvp-&amp;gt;owner-&amp;gt;next_count %d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, cvp, cvp-&amp;gt;count, cvp-&amp;gt;owner-&amp;gt;&lt;span&gt;next_count);
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
     *         cv.count ++;
     *         if(mt.next_count&amp;gt;0)
     *            signal(mt.next)
     *         else
     *            signal(mt.mutex);
     *         wait(cv.sem);
     *         cv.count --;
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 阻塞在当前条件变量上的线程数加1&lt;/span&gt;
    cvp-&amp;gt;count++&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(cvp-&amp;gt;owner-&amp;gt;next_count &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对应管程中存在被阻塞的其它线程
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 唤醒阻塞在对应管程协调信号量next中的线程&lt;/span&gt;
        up(&amp;amp;(cvp-&amp;gt;owner-&amp;gt;&lt;span&gt;next));
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果对应管程中不存在被阻塞的其它线程
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 释放对应管程的mutex二元信号量&lt;/span&gt;
        up(&amp;amp;(cvp-&amp;gt;owner-&amp;gt;&lt;span&gt;mutex));
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 令当前线程阻塞在条件变量上&lt;/span&gt;
    down(&amp;amp;(cvp-&amp;gt;&lt;span&gt;sem));
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; down返回，说明已经被再次唤醒，条件变量count减1&lt;/span&gt;
    cvp-&amp;gt;count --&lt;span&gt;;
    cprintf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cond_wait end:  cvp %x, cvp-&amp;gt;count %d, cvp-&amp;gt;owner-&amp;gt;next_count %d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, cvp, cvp-&amp;gt;count, cvp-&amp;gt;owner-&amp;gt;&lt;span&gt;next_count);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;条件变量的唤醒操作实现：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　cond_signal函数用于实现条件变量的signal操作。条件变量的signal操作和信号量的up功能类似。当条件变量对应的条件满足时，通过信号量的up操作，唤醒阻塞在对应条件变量中的线程。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Unlock one of threads waiting on the condition variable. &lt;/span&gt;&lt;span&gt;
/*&lt;/span&gt;&lt;span&gt;*
 * 条件变量唤醒操作
 * 解锁（唤醒）一个等待在当前条件变量上的线程
 * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; 
cond_signal (condvar_t &lt;/span&gt;*&lt;span&gt;cvp) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;LAB7 EXERCISE1: YOUR CODE&lt;/span&gt;
    cprintf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cond_signal begin: cvp %x, cvp-&amp;gt;count %d, cvp-&amp;gt;owner-&amp;gt;next_count %d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, cvp, cvp-&amp;gt;count, cvp-&amp;gt;owner-&amp;gt;&lt;span&gt;next_count);
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
     *      cond_signal(cv) {
     *          if(cv.count&amp;gt;0) {
     *             mt.next_count ++;
     *             signal(cv.sem);
     *             wait(mt.next);
     *             mt.next_count--;
     *          }
     *       }
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果等待在条件变量上的线程数大于0&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;(cvp-&amp;gt;count&amp;gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 需要将当前线程阻塞在管程的协调信号量next上，next_count加1&lt;/span&gt;
        cvp-&amp;gt;owner-&amp;gt;next_count ++&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 令阻塞在条件变量上的线程进行up操作，唤醒线程&lt;/span&gt;
        up(&amp;amp;(cvp-&amp;gt;&lt;span&gt;sem));
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 令当前线程阻塞在管程的协调信号量next上
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 保证管程临界区中只有一个活动线程，先令自己阻塞在next信号量上；等待被唤醒的线程在离开临界区后来反过来将自己从next信号量上唤醒&lt;/span&gt;
        down(&amp;amp;(cvp-&amp;gt;owner-&amp;gt;&lt;span&gt;next));
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前线程被其它线程唤醒从down函数中返回，next_count减1&lt;/span&gt;
        cvp-&amp;gt;owner-&amp;gt;next_count --&lt;span&gt;;
    }
    cprintf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cond_signal end: cvp %x, cvp-&amp;gt;count %d, cvp-&amp;gt;owner-&amp;gt;next_count %d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, cvp, cvp-&amp;gt;count, cvp-&amp;gt;owner-&amp;gt;&lt;span&gt;next_count);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;条件变量与管程的交互：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　仔细比对条件变量与信号量的实现，会发现大致的实现思路是一致的。但ucore中实现的条件变量是作为管程的一部分工作的，因此在wait和signal操作中都额外耦合了与对应管程owner交互的地方。&lt;/p&gt;
&lt;p&gt;　&lt;strong&gt;　在管程中进入临界区的线程发现条件不满足而进行条件变量的wait操作时，需要释放管程中临界区的锁，在wait操作挂起自身时令其它想要进入管程内的线程获得临界区的访问权限。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　在管程中临界区的线程发现某一条件得到满足时，将执行对应条件变量的signal操作以唤醒等待在其上的某一个线程。但是由于管程临界区的互斥性，不能允许临界区内有超过一个的线程在其中运行，因此执行signal操作的线程需要首先将自己阻塞挂起在管程的next信号量上，使得被唤醒的那一个线程独占临界区资源。当被唤醒的线程离开临界区时，也会及时的唤醒挂起在管程next信号量上的对应线程。&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;2.5 使用管程解决哲学家就餐问题&lt;/h2&gt;
&lt;p&gt;　　由于并发环境下多个线程通过条件变量等同步机制交替的休眠/唤醒，逻辑执行流并不是连贯的，因此条件变量和管程的实现显得比较绕，令人费解。通过学习如何用管程解决哲学家就餐问题，看看使用管程/条件变量是如何进行线程同步互斥的，加深对条件变量、管程工作机制的理解。 &lt;/p&gt;
&lt;p&gt;　　在&lt;strong&gt;checkSync&lt;/strong&gt;函数的后半部分，是关于如何使用管程解决哲学家就餐问题。&lt;strong&gt;在check_sync的后半部分创建了N(N=5)个哲学家内核线程，用于执行&lt;/strong&gt;&lt;strong&gt;philosopher_using_condvar&lt;/strong&gt;&lt;strong&gt;函数，模拟哲学家就餐问题。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;philosopher_using_condvar&lt;/strong&gt;中哲学家循环往复的进行如下操作(整体流程和信号量的实现大体一致)：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　1. 哲学家进行思考(通过do_sleep系统调用进行休眠阻塞，模拟哲学家思考)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　2. 通过phi_take_forks_condvar&lt;/strong&gt;&lt;strong&gt;函数尝试着同时拿起左右两个叉子（如果没有拿到左右叉子，陷入阻塞）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　3. 哲学家进行就餐(&lt;/strong&gt;&lt;strong&gt;通过do_sleep系统调用进行休眠阻塞，模拟哲学家就餐&lt;/strong&gt;)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　4. 通过phi_put_forks_condvar函数同时放下左右两个叉子，回到思考状态&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;　　拿起叉子的phi_take_forks_condvar&lt;/strong&gt;&lt;strong&gt;函数和放下叉子phi_put_forks_condvar&lt;/strong&gt;&lt;strong&gt;的函数内部都是通过条件变量进行同步的，在下面进行更进一步的分析。&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;checkSync函数：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; check_sync(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;){
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;check semaphore&lt;/span&gt;
    sem_init(&amp;amp;mutex, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;N;i++&lt;span&gt;){
        sem_init(&lt;/span&gt;&amp;amp;s[i], &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; pid = kernel_thread(philosopher_using_semaphore, (&lt;span&gt;void&lt;/span&gt; *)i, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (pid &amp;lt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
            panic(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;create No.%d philosopher_using_semaphore failed.\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
        philosopher_proc_sema[i] &lt;/span&gt;=&lt;span&gt; find_proc(pid);
        set_proc_name(philosopher_proc_sema[i], &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;philosopher_sema_proc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;check condition variable&lt;/span&gt;
    monitor_init(&amp;amp;&lt;span&gt;mt, N);
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;N;i++&lt;span&gt;){
        state_condvar[i]&lt;/span&gt;=&lt;span&gt;THINKING;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; pid = kernel_thread(philosopher_using_condvar, (&lt;span&gt;void&lt;/span&gt; *)i, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (pid &amp;lt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
            panic(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;create No.%d philosopher_using_condvar failed.\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
        philosopher_proc_condvar[i] &lt;/span&gt;=&lt;span&gt; find_proc(pid);
        set_proc_name(philosopher_proc_condvar[i], &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;philosopher_condvar_proc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;管程实现中拿起叉子/放下叉子函数分析：&lt;/h3&gt;
&lt;p&gt; 　　&lt;strong&gt;phi_take_forks_condvar&lt;/strong&gt;函数表达哲学家尝试着拿起左右叉子想要就餐；而&lt;strong&gt;phi_put_forks_condvar&lt;/strong&gt;函数表达哲学家进餐结束后放下左右叉子。&lt;/p&gt;
&lt;p&gt;　　两者通过&lt;strong&gt;管程中的互斥信号量mutex&lt;/strong&gt;的&lt;strong&gt;down&lt;/strong&gt;操作进行全局的互斥，保证在同一时刻只有一个哲学家线程能够进入临界区，对临界区的资源叉子进行拿起/放下操作，对不同的哲学家线程进行互斥，保证查看左右叉子的状态时不会出现并发问题。&lt;/p&gt;
&lt;p&gt;　　在离开管程的临界区时(注释into routine in monitor和leave routine in monitor之间为管程的临界区代码)，当前线程会根据管程内是否存在其它线程(mtp-&amp;gt;next_count&amp;gt;0)而有不同的操作。当发现管程中的next信号量上存在其它线程阻塞在上面时，优先唤醒next信号量上的线程(阻塞在next上的线程是由于要唤醒等待在某一条件变量上的线程，为了保证临界区互斥自愿被阻塞的，因此被唤醒的线程在离开临界区后需要第一时间将其唤醒)；而如果next信号量中不存在休眠的线程，那么就和信号量的实现类似，释放mutex互斥锁，唤醒可能等待在其上的某一线程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　上述ucore实现的管程其线程交互的逻辑是基于Hoare语义的，此外还存在MESA语义的管程和Hansen语义的管程(MESA管程和Hansen管程实现类似前面的信号量实现哲学家就餐)。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　Hoare管程在signal唤醒其它线程时会令自己陷入休眠，严格的保证了临界区线程的互斥，理论上更加可靠，常见于教科书的理论中。由于Hoare语义的管程需要额外引入一个等待队列(next信号量)，因此其性能并不如其它两种语义的管程，现实中被使用的地方很少。&lt;/strong&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;phi_take_forks_condvar函数(同时拿起左右叉子)：&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; phi_take_forks_condvar(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 拿叉子时需要通过mutex信号量进行互斥，防止并发问题(进入临界区)&lt;/span&gt;
    down(&amp;amp;(mtp-&amp;gt;&lt;span&gt;mutex));
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;--------into routine in monitor--------------
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; LAB7 EXERCISE1: YOUR CODE
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; I am hungry
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; try to get fork
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; I am hungry
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 记录下哲学家i饥饿的事实(执行phi_take_forks_condvar尝试拿叉子，说明哲学家i进入了HUNGRY饥饿状态)&lt;/span&gt;
    state_condvar[i]=&lt;span&gt;HUNGRY;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 试图同时得到左右两只叉子&lt;/span&gt;
&lt;span&gt;    phi_test_condvar(i);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (state_condvar[i] !=&lt;span&gt; EATING) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; state_condvar[i]状态不为EATING，说明phi_test_condvar尝试拿左右叉子进餐失败&lt;/span&gt;
        cprintf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;phi_take_forks_condvar: %d didn't get fork and will wait\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,i);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 等待阻塞在管程的条件变量cv[i]上&lt;/span&gt;
        cond_wait(&amp;amp;mtp-&amp;gt;&lt;span&gt;cv[i]);
    }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;--------leave routine in monitor--------------&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;(mtp-&amp;gt;next_count&amp;gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当离开管程临界区时，如果发现存在线程等待在mtp-&amp;gt;next上
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在当前实验中，执行到这里的当前线程可能是阻塞在cond_wait中被其它线程唤醒的，对应线程是通过phi_test_condvar的cond_signal操作唤醒当前线程的
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行cond_signal时为了保证管程临界区内不存在并发的线程访问，在唤醒其它线程时，会把自己阻塞在管程的next信号量上，等待此时离开临界区的线程将其唤醒&lt;/span&gt;
        up(&amp;amp;(mtp-&amp;gt;&lt;span&gt;next));
    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当离开管程临界区时,没有其它线程等待在mtp-&amp;gt;next上，直接释放管程的互斥锁mutex即可(唤醒可能阻塞在mutex上的其它线程)&lt;/span&gt;
        up(&amp;amp;(mtp-&amp;gt;&lt;span&gt;mutex));
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;phi_put_forks_condvar函数(同时放下左右叉子)：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; phi_put_forks_condvar(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 放叉子时需要通过mutex信号量进行互斥，防止并发问题(进入临界区)&lt;/span&gt;
    down(&amp;amp;(mtp-&amp;gt;&lt;span&gt;mutex));

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;--------into routine in monitor--------------
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; LAB7 EXERCISE1: YOUR CODE
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; I ate over
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; test left and right neighbors
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; I ate over
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 哲学家进餐结束(执行phi_put_forks_condvar放下叉子，说明哲学家已经就餐完毕，重新进入THINKING思考状态)&lt;/span&gt;
    state_condvar[i]=&lt;span&gt;THINKING;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; test left and right neighbors
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当哲学家i就餐结束，放下叉子时。需要判断左、右临近的哲学家在自己就餐的这段时间内是否也进入了饥饿状态，却因为自己就餐拿走了叉子而无法同时获得左右两个叉子。
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 为此哲学家i在放下叉子后需要尝试着判断在自己放下叉子后，左/右临近的、处于饥饿的哲学家能否进行就餐,如果可以就唤醒阻塞的哲学家线程，并令其进入就餐状态(EATING)&lt;/span&gt;
    phi_test_condvar(LEFT); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 看一下左邻居现在是否能进餐&lt;/span&gt;
    phi_test_condvar(RIGHT); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 看一下右邻居现在是否能进餐
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;--------leave routine in monitor--------------
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; lab7的参考答案&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;(mtp-&amp;gt;next_count&amp;gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;){
        cprintf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;execute here mtp-&amp;gt;next_count&amp;gt;0 \n\n\n\n\n\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        up(&lt;/span&gt;&amp;amp;(mtp-&amp;gt;&lt;span&gt;next));
    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
        cprintf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;execute here mtp-&amp;gt;next_count=0 \n\n\n\n\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        up(&lt;/span&gt;&amp;amp;(mtp-&amp;gt;&lt;span&gt;mutex));
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 个人认为放叉子和取叉子的情况并不一样，不会出现mtp-&amp;gt;next_count&amp;gt;0的情况，这里只需要释放互斥锁即可（如果这里理解的有问题，还请指正）
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当放叉子的线程在phi_put_forks_condvar中离开管程临界区时，只有两种情况
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1. 没有发现邻居可以进餐，自身不会被阻塞
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2. 发现有邻居之前被拿不到叉子阻塞了，现在可以进餐了，phi_test_condvar中的cond_signal会暂时令自己阻塞在next信号量上
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 但是很快被自己叫醒的相邻的哲学家线程在被唤醒后一离开临界区就会将自己唤醒，在cond_signal被唤醒后的操作中mtp-&amp;gt;next_count会自减，而变为0
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 以上两种情况下，由于管程本身最外面有一个mutex互斥信号量，所以不会出现两个线程同时阻塞在next信号量中，因此也就不会出现参考答案中mtp-&amp;gt;next_count&amp;gt;0的情况
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; up(&amp;amp;(mtp-&amp;gt;mutex));&lt;/span&gt;
} 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;phi_test_condvar函数(判断哲学家i是否能拿起左右叉子开始就餐)：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; phi_test_condvar (i) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当哲学家i处于饥饿状态(HUNGRY),且其左右临近的哲学家都没有在就餐状态(EATING)&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;(state_condvar[i]==HUNGRY&amp;amp;&amp;amp;state_condvar[LEFT]!=&lt;span&gt;EATING
            &lt;/span&gt;&amp;amp;&amp;amp;state_condvar[RIGHT]!=&lt;span&gt;EATING) {
        cprintf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;phi_test_condvar: state_condvar[%d] will eating\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,i);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 哲学家i饿了(HUNGRY)，且左右两边的叉子都没人用。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 令哲学家进入就餐状态（EATING）&lt;/span&gt;
        state_condvar[i] =&lt;span&gt; EATING ;
        cprintf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;phi_test_condvar: signal self_cv[%d] \n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,i);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 唤醒阻塞在对应信号量上的哲学家线程&lt;/span&gt;
        cond_signal(&amp;amp;mtp-&amp;gt;&lt;span&gt;cv[i]) ;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2.6 信号量和管程的区别&lt;/h2&gt;
&lt;p&gt;　　信号量是一个简单、高效的同步互斥机制，但也正是由于其过于底层，所以在编写线程同步代码时需要十分小心谨慎，对每一处信号量的使用仔细斟酌才能保证程序的正确性，对开发人员的心智是一个巨大的负担。&lt;/p&gt;
&lt;p&gt;　　而将管程作为一个整体的结构来看的话，会发现管程虽然将控制同步的代码逻辑抽象为了一个固定的模板变得容易使用，但却与要保护的临界区业务逻辑代码耦合的很严重，操作系统的开发者很难将管程控制同步的代码植入进对应的应用程序内部。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　因此操作系统通常只提供了信号量以及条件变量这种偏底层、耦合性低的同步互斥机制；而管程机制则更多的由高级语言的编译器在语言层面实现，以简化程序员开发复杂并发同步程序的复杂度。&lt;/strong&gt;&lt;strong&gt;高级语言编译器在编译本地机器代码时，可以在需要进行同步的代码逻辑块中利用操作系统底层提供的信号量或是条件变量机制来实现管程。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;例如java中如果在方法定义时简单的加上synchronized关键字就能控制多线程环境下不会并发的执行该方法。这是因为在编译成字节码时，相比于普通方法额外插入了一些管程Monitor相关的同步控制代码(管程底层依赖的信号量、条件变量机制还是取决于对应的操作系统平台，只不过被jvm屏蔽掉了差异，让java程序员感知不到)。&lt;/p&gt;

&lt;p&gt;　　通过ucore的lab7的学习，让我理解了等待队列、信号量、条件变量以及管程的大致工作原理，也对平常会接触到的java中的synchronized、AQS、Reentrantlock其底层机制有了进一步的认识。&lt;/p&gt;
&lt;p&gt;　　lab7的学习使我收获颇丰，但这对于线程同步相关领域的学习还是远远不够。同属于进程间通信IPC领域的经典问题除了哲学家就餐问题外，还有读者/写者问题等；对于线程安全问题，除了使用休眠/唤醒进行线程上下文切换的阻塞的方式之外，还有使用CAS等重试的方法；除了信号量、条件变量等基于单机系统内的线程同步方式外，还有基于分布式系统，通过网络进行多机器线程同步的机制等等。虽然不够了解的知识还有很多，但通过ucore操作系统的学习，为我学习相关的领域知识打下了基础，也给了我相信最终能融会贯通这些知识的信心。&lt;/p&gt;
&lt;p&gt;　　这篇博客的完整代码注释在我的github上：&lt;a href=&quot;https://github.com/1399852153/ucore_os_lab&quot; target=&quot;_blank&quot;&gt;https://github.com/1399852153/ucore_os_lab&lt;/a&gt; (fork自官方仓库)中的&lt;strong&gt;lab7_answer&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　希望我的博客能帮助到对操作系统、ucore os感兴趣的人。存在许多不足之处，还请多多指教。&lt;/p&gt;
</description>
<pubDate>Thu, 24 Dec 2020 15:58:00 +0000</pubDate>
<dc:creator>小熊餐馆</dc:creator>
<og:description>1. ucore lab7介绍 ucore在前面的实验中实现了进程/线程机制，并在lab6中实现了抢占式的线程调度机制。基于中断的抢占式线程调度机制使得线程在执行的过程中随时可能被操作系统打断，被阻塞</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiaoxiongcanguan/p/14152830.html</dc:identifier>
</item>
<item>
<title>浅析Python装饰器 - hcs_learn</title>
<link>http://www.cnblogs.com/053179hu/p/14183348.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/053179hu/p/14183348.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;1、什么是装饰器&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在介绍装饰器之前，我们先来思考一个问题：使用Python语言进行程序设计时，如果我们想扩展一个函数的功能，一般会怎么做呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如，有一个名为print_info函数，当前该函数内只做一些简单的打印操作，现在我们想扩展这个函数功能，如在发生错误时，我们将错误行号传入到该函数打印出来。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; print_info():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello World&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;看到这个问题，我们的第一反应肯定是重新修改这个函数。在print_info函数增加一个参数，用于接收外部传入的错误行号，在函数内部增加打印行号信息语句。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; print_info(err_line):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello World&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;The Error Occurred Line Number: %d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %(err_line))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;似乎，通过修改函数内容，也能实现我们的需求。但有没有这种可能呢，不直接进行修改print_info函数内容，通过其他的方式增加print_info函数的额外功能。答案肯定是有的，能实现这种功能的就是我们要讲的装饰器。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;装饰器到底是什么呢？使用比较严谨的语言来描述：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;&lt;span&gt;装饰器本质上是一个Python函数，它可以让其他函数在不需要做任何代码变动的前提下增加额外功能，装饰器的返回值也是一个函数对象。它经常用于有切面需求的场景，比如：插入日志、性能测试、事务处理、缓存、权限校验等场景。装饰器是解决这类&lt;/span&gt;&lt;span&gt;问题的绝佳设计，有了装饰器，&lt;br/&gt;我们就可以抽离出大量与函数功能本身无关的雷同代码并继续重用。&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;概括的讲，装饰器的作用就是&lt;strong&gt;为已经存在的函数或对象添加额外的功能&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2、怎么写一个装饰器&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们先来看一段这样的代码&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; sys
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; log(fcn):
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; wrapper(*argc, **&lt;span&gt;kw):
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;New Operations Are Added Here&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; len(argc) != 1&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Illegal parameter&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; -1
&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;The Error Occurred Line Number: %d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt;(argc[0]))
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; fcn()
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; wrapper      
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; print_info():
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello World&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; print_info =&lt;span&gt; log(print_info) &lt;code class=&quot;language-python hljs&quot;/&gt;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; main():
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    print_info(sys._getframe().f_lineno) # &lt;span&gt;sys._getframe().f_lineno代表当前的行号&lt;/span&gt;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     main()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;log函数是一个“&lt;span&gt;闭包&lt;/span&gt;”（关于什么是“闭包”可参考&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/053179hu/p/14180479.html&quot; target=&quot;_blank&quot;&gt;“浅析Python闭包”&lt;/a&gt;&lt;/strong&gt;），该函数有一个参数fcn，返回值是内部实现的wrapper函数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比较重要的一条语句&lt;strong&gt;print_info = log(print_info)&lt;/strong&gt;，这里通过对print_info变量赋值改变它原来指向的类型，起到了对print_info函数赋予了新功能。执行这句语句之后print_info变量不再表示前面定义的print_info函数，&lt;span&gt;而是表示log函数内实现的&lt;span&gt;wrapper函数，&lt;/span&gt;&lt;/span&gt;但原来定义的print_info函数仍然存在。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最终调用的print_info函数，其实调用的是log中的&lt;span&gt;&lt;span&gt;wrapper函数&lt;/span&gt;&lt;/span&gt;。由于“闭包”特性，虽然wrapper函数已经离开了创造它的环境log函数，但它仍然可以使用log函数中的自由变量。&lt;/span&gt;&lt;span&gt;&lt;span&gt;wrapper函数中，打印了传入的错误行号，并调用了传入的原定义的print_info函数，这样便做到了对定义的print_info函数内容做修改，调用print_info增加了额外功能。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;运行结果&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
The Error Occurred Line Number: 19 # 打印出新增的对应行号信息，在19行被调用，所以传入行号是19&lt;span&gt;
Hello World #原print_info函数执行内容&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;上面的log函数其实已经是一个装饰器了，它对原函数做了包装并返回了另外一个函数，额外添加了一些功能。因为这样写实在不太优雅，新版本Python中支持了@语法糖，我们可以把它使用起来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面代码等同于上面的写法。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; sys

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; log(fcn):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; wrapper(*argc, **&lt;span&gt;kw):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;New Operations Are Added Here&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; len(argc) != 1&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Illegal parameter&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -1
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;The Error Occurred Line Number: %d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt;(argc[0]))
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; fcn()
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; wrapper    
    
@log                      
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; print_info():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello World&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;print_info = log(print_info)&lt;/span&gt;

&lt;span&gt;def&lt;/span&gt;&lt;span&gt; main():
    print_info(sys._getframe().f_lineno)

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
    main()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;把@log放到print_info函数定义处，相当于执行了print_info = log(print_info)语句&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3、完整装饰器的写法&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;前面写的装饰器都没有问题，但是还差最后一步，虽然装饰器装饰过的函数看上去名字没变，其实已经变了。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; log(fcn):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; wrapper(*args, **&lt;span&gt;kw):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(fcn.&lt;span&gt;__name__&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; fcn()
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; wrapper  

@log
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; print_info():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Hello World&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; main():
    print_info()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(print_info.&lt;span&gt;__name__&lt;/span&gt;&lt;span&gt;)
    
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
    main()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;运行结果&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
print_info&lt;br/&gt;Hello World&lt;br/&gt;wrapper&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;上面print_info函数经log装饰器装饰后，它的__name__属性已经从原来的‘print_info’变成了‘wrapper’&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为返回的那个wrapper()函数名字就是'wrapper'，所以，需要把原始函数的__name__等属性复制到wrapper()函数中，否则，有些依赖函数签名的代码执行就会出错。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不需要在内部添加wrapper.__name__=fcn.__name__这样的代码，Python内置的functools.wraps就是干这个事的，所以，一个完整的decorator的写法如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; functools

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; log(fcn):
    @functools.wraps(fcn)
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; wrapper(*args, **&lt;span&gt;kw):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(fcn.&lt;span&gt;__name__&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; fcn()
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; wrapper
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4、高阶一点装饰器&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.1 带参数装饰器&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果装饰器函数本身要传入参数，那么装饰器就会是这样的&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; sys

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; log(text):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; wrapper(fcn)
        &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; inner_wrapper(*argc, **&lt;span&gt;kw):
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;New Operations Are Added Here&lt;/span&gt;
            &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(text)
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; len(argc) != 1&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Illegal parameter&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -1
            &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;The Error Occurred Line Number: %d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt;(argc[0]))
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; fcn()
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; inner_wrapper
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; wrapper    
    
@log('With Parameter Decorator')
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; print_info():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello World&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;print_info = log(print_info)&lt;/span&gt;

&lt;span&gt;def&lt;/span&gt;&lt;span&gt; main():
    print_info(sys._getframe().f_lineno)

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
    main()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;对于带参数装饰器，可以这么理解，当带参数的装饰器被装饰在某个函数上时，比如上述代码@log('With Parameter Decorator')&lt;/span&gt;&lt;span&gt;&lt;code&gt;，&lt;/code&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;log('With Parameter Decorator')&lt;/span&gt;其实是一个函数，会马上被执行，它返回的结果任是一个装饰器wrapper。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也就是下面代码其实等价于print_info = wrapper(print_info)&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
@log(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;With Parameter Decorator&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; print_info():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello World&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.2 装饰器装饰类方法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;前面我们介绍的都是用装饰器装饰函数，装饰器同时也可以装饰类方法，下面来看如何用装饰器装饰类的方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们定义了名为simple_test的类，这个类有一个data属性和get_data方法。类里的实现非常简单，get_data方法只返回data属性值，并不进行其他操作。同时，我们还需定义了一个装饰器装饰类的get_data方法，装饰器中根据数据获取源来编写其中功能，比如我们这里选择从串口终端获取数据，直接修改装饰器的内容让其获取终端输入数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这样在设计一个类时，做到了将类中稳定的部分和经常要修改的部分独立开。类设计完成后，我们不需要更改类的源码，在使用时只需要根据需求修改类方法的装饰器就能实现我们的需求。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; serial_data(fcn):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; wrapper(self, *args, **&lt;span&gt;kw):
        str &lt;/span&gt;= input(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Please enter an integer: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
            tmp &lt;/span&gt;=&lt;span&gt; int(str)
        &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; ValueError:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Invalid Value&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; None
        self.data &lt;/span&gt;=&lt;span&gt; tmp
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; fcn(self)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; wrapper

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; simple_test(object):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(self, _val =&lt;span&gt; 0):
        self.data &lt;/span&gt;=&lt;span&gt; _val
    
    @serial_data
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_data(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; self.data
    
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; main():
    obj &lt;/span&gt;=&lt;span&gt; simple_test()
    val &lt;/span&gt;=&lt;span&gt; obj.get_data()
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; val &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; None:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;get Data: %d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt;(val))
    
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
    main()&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;运行结果：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Please enter an integer: 100&lt;span&gt;
get Data: &lt;/span&gt;100
&amp;gt;&amp;gt;&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Thu, 24 Dec 2020 15:15:00 +0000</pubDate>
<dc:creator>hcs_learn</dc:creator>
<og:description>1、什么是装饰器 在介绍装饰器之前，我们先来思考一个问题：使用Python语言进行程序设计时，如果我们想扩展一个函数的功能，一般会怎么做呢？ 比如，有一个名为print_info函数，当前该函数内只做</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/053179hu/p/14183348.html</dc:identifier>
</item>
<item>
<title>如何做好Code Review - 麦机长</title>
<link>http://www.cnblogs.com/Autumoon/p/14186629.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Autumoon/p/14186629.html</guid>
<description>&lt;div id=&quot;cnblogs_post_description&quot; readability=&quot;32&quot;&gt;&lt;img src=&quot;https://captnotes.com/wp-content/uploads/2020/12/featured_effective_code_review.jpg&quot; class=&quot;desc_img&quot;/&gt;很多团队都会做，效果如何不好说。&lt;/div&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;131.11377506539&quot;&gt;
&lt;p&gt;Code Review（代码审查）很多团队都会做，效果如何不好说。如果你能轻易地从一堆出自正经团队之手的代码里找出几个低级错误，往往意味着团队管理者长期忽视了Code Review的重要性。&lt;/p&gt;
&lt;p&gt;根据经验，匆匆应付功能实现和漏洞修复而将Code Review流于形式的团队不在少数。当然，每个人都能列举一大堆“客观原因”，而且每一条理由听起来都是那么的有说服力。然而，没做好就是没做好，狡辩只会让场面变得更加恶心。&lt;/p&gt;

&lt;blockquote readability=&quot;5.568345323741&quot;&gt;
&lt;p&gt;A code review is the process of examining written code with the purpose of highlighting mistakes in order to learn from them.&lt;/p&gt;
&lt;p&gt;-- &lt;a href=&quot;https://www.techopedia.com/definition/14299/code-review&quot; target=&quot;_blank&quot;&gt;Techopedia&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是目前我见过对Code Review最言简意赅的定义。其实怎么描述并不重要，重要的是我们要达到什么样的目的。&lt;/p&gt;

&lt;p&gt;提高代码质量是程序员端稳饭碗、少挨点儿骂的最有效途径。其实Code Review就是很好的相互切磋、共同进步的机会，效果要比独自埋头干啃《21天精通×××》之类的“宝典”好得多。当然，前提是目的明确、态度端正。&lt;/p&gt;
&lt;p&gt;Code Review主要目的就两个：&lt;/p&gt;
&lt;h2 id=&quot;查错&quot;&gt;查错&lt;/h2&gt;
&lt;p&gt;Code Review不是用来查找低级错误的，而是参与者以提交者以外的视角阅读和审视代码，尽可能地找到逻辑上的问题。&lt;/p&gt;
&lt;h2 id=&quot;学习&quot;&gt;学习&lt;/h2&gt;
&lt;p&gt;与其说Code Review重在找到问题，不如说其核心目的在于营造团队学习氛围、提升成员对软件品质的追求。我经历过不少团队，为了营造学习氛围，生拉硬拽地要求成员定期举行技术分享会，结果往往敷衍了事、不了了之。&lt;/p&gt;

&lt;p&gt;下面根据Code Review中涉及的主要人物角色来讲讲我推荐的方式。注意，这不是标准答案。&lt;/p&gt;
&lt;p&gt;具体划分角色责任之前，我建议每个技术团队都要找到并严格执行适合本团队技术栈的编码规范，甚至包括IDE配置和开发环境参数设定等，以确保每位成员都“说着同样的语言”，并减少在命名规则、排版样式等方面的争论，将时间和精力聚焦到对功能实现和业务优化这些实质性的问题上来。&lt;/p&gt;
&lt;h2 id=&quot;开发小组技术负责人&quot;&gt;开发小组技术负责人&lt;/h2&gt;
&lt;p&gt;每一位开发小组技术负责人都应该积极实施并维护Code Review机制，要求每位成员在提交代码的时候，都必须经过交叉Review，也就是每一次代码提交到主干时，都必须经过另一位相同技术领域同事的Review，否则将被视为提交了与存在编译时错误的代码同等的严重过失。&lt;/p&gt;
&lt;p&gt;每次代码提交的交叉Review，开发小组技术负责人应当随机抽取包括自己在内的任何一位技术人员进行，不要让提交者能够很轻易地预知将会是谁来做自己这一次的Reviewer，否则很容易变成形式主义。&lt;/p&gt;
&lt;p&gt;并且，对于Feature实现的Code Review，开发小组技术负责人应该较为频繁但不定期地进行公开Review。组织一场会议，召集整个开发小组的成员一起对此次提交的代码进行审查。&lt;/p&gt;
&lt;h2 id=&quot;提交者&quot;&gt;提交者&lt;/h2&gt;
&lt;p&gt;不论Code Review是私下的还是公开的，提交者都不能提交任何存在编译时错误的代码，这是非常低级的错误。首先在提交代码之前再次进行编译，是确保即将提交的代码不存在编译时错误的必要步骤。其次，也是很多人容易疏忽的，确保本次新增的本地资源文件都被加入了源代码管理，否则即使本地能编译通过，别人拿到你的代码也依然存在编译时问题。&lt;/p&gt;
&lt;p&gt;提交代码之前，自己先&lt;code&gt;diff&lt;/code&gt;一下，首先确保代码不存在前面提到的诸如命名、格式等方面的低级错误；然后确定自己对每一处代码变动的理解都非常明确，并且自己已经找不出改进方案；最后确保所有Hard Code都已经被移除，这一点可以参考我之前写的&lt;a href=&quot;https://captnotes.com/remove_before_flight&quot; target=&quot;_blank&quot;&gt;《没什么技术含量的Remove Before Flight》&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;提交者在代码被Review之前，还应该调整好心态，把别人的询问、质疑、建议、批评，通通视作可能的提升机会，而不要主观上认定自己给出的就是最优解，而别人都是“不明真相的围观群众”。也许别人在不了解背景信息或上下文的情况下，给出了错误的建议，提交者也应当将此作为锻炼思维和口才的友好辩论，而不是玻璃心受到了侵犯似的直接怼回去。&lt;/p&gt;
&lt;h2 id=&quot;参与者&quot;&gt;参与者&lt;/h2&gt;
&lt;p&gt;参与者应该对编码规范了然于心，对于代码中每一处不符合团队现行编码规范的地方都要不厌其烦地标注出来。很多人认为这个无所谓，反正机器最后读的都是0和1——对，机器只认识0和1，所以源代码其实是写给人看的。不管代码由多少人写就，最终看上去如同出自同一人之手，这种代码的阅读体验和效率绝对要比那种百家争鸣式的好得多。&lt;/p&gt;
&lt;p&gt;如果是面向对象的编程语言，参与者应当考察提交者对抽象的理解和实践，是否准确以及是否过浅或过深。抽象过浅，看上去往往是大杂烩；抽象过深，读起来显得吃力。对于这两种情况，参与者都可以提出自己的看法和建议，不要抱着“你这不行，听我的”的态度，否则很容易形成对立的情绪，进而影响团队对Code Review的积极性。&lt;/p&gt;
&lt;p&gt;对于代码实现是否存在改进空间这个问题，参与者应该在阅读新代码时，尽可能全面地去理解问题域、了解需求的具体细节，而不是想当然地抛出质疑和意见，给人以浮躁的印象。如果参与者确定自己清楚地理解了需求和问题，依然对当前的代码实现有改进建议，那么就大胆地提出来，这就是Code Review的核心目的！&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Thu, 24 Dec 2020 14:05:00 +0000</pubDate>
<dc:creator>麦机长</dc:creator>
<og:description>Code Review（代码审查）很多团队都会做，效果如何不好说。如果你能轻易地从一堆出自正经团队之手的代码里找出几个低级错误，往往意味着团队管理者长期忽视了Code Review的重要性。 根据经验</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Autumoon/p/14186629.html</dc:identifier>
</item>
</channel>
</rss>