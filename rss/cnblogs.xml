<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>基于spring-boot和docker-java实现对docker容器的动态管理和监控[附完整源码下载] - crazy_joe</title>
<link>http://www.cnblogs.com/qiaobing/p/11020870.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qiaobing/p/11020870.html</guid>
<description>&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;19&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://upload-images.jianshu.io/upload_images/6332485-6978664499db5189.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://upload-images.jianshu.io/upload_images/6332485-6978664499db5189.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://upload-images.jianshu.io/upload_images/6332485-6978664499db5189.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（我是个封面）&lt;/p&gt;
&lt;h3&gt;docker简介&lt;/h3&gt;
&lt;p&gt;Docker 是一个开源的应用容器引擎，和传统的虚拟机技术相比，Docker 容器性能开销极低，因此也广受开发者喜爱。随着基于docker的开发者越来越多，docker的镜像也原来越丰富，未来各种企业级的完整解决方案都可以直接通过下载镜像拿来即用。因此docker变得越来越重要。&lt;/p&gt;
&lt;h3&gt;本文目的&lt;/h3&gt;
&lt;p&gt;本文通过一个项目实例来介绍如果通过docker对外接口来实现对docker容器的管理和监控。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;应用场景：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对服务器资源池通过docker进行统一管理，按需分配资源和创建容器，达到资源最大化利用。同时保证各业务（容器）之间的隔离。并可支持项目的在线部署。&lt;/p&gt;
&lt;p&gt;本项目模拟实现以上场景，代码不完全严禁，代码仅供学习。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现功能：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、通过界面创建docker的tomcat容器，并配置限额。&lt;/p&gt;
&lt;p&gt;2、上传war包并部署到容器。&lt;/p&gt;
&lt;p&gt;3、动态监控docker所有容器的资源使用情况。&lt;/p&gt;
&lt;p&gt;代码基于docker-java开源组件，基于spring-boot完成功能开发。界面如下图：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;18&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://upload-images.jianshu.io/upload_images/6332485-31762b353bc52a18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://upload-images.jianshu.io/upload_images/6332485-31762b353bc52a18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://upload-images.jianshu.io/upload_images/6332485-31762b353bc52a18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;基础环境&lt;/h3&gt;
&lt;p&gt;1、eclipse  2019-03；&lt;/p&gt;
&lt;p&gt;2、docker for windows。本着学习和简单的目的，并未使用linux环境，但原理和基本命令相同。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;相关技术和知识点:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;maven，spring-boot；spring mvc；spring上传下载，jquery ajax和上传。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现原理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;docker对外提供了丰富接口（如：restfull APi），通过这些接口可对docker进行管理。docker-java开源组件基于这个接口做了封装，使得开发更加简单。当然市面上还有其他一些封装好的组件，大家可自行比较和学习。在这里对开源作者表示感谢。当然本人也会开源的参与者，相关文章：&lt;a href=&quot;https://blog.csdn.net/crazy_joe/article/details/90051435&quot; data-cke-saved-href=&quot;https://blog.csdn.net/crazy_joe/article/details/90051435&quot;&gt;本人的ORM开源组件&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;实现过程之前期准备&lt;/h3&gt;
&lt;p&gt;1、升级windows&lt;/p&gt;
&lt;p&gt;由于我们使用的是windows环境， 笔者自己电脑预装的是win10 家庭版，而docker for windows 需要运行在更高级别的操作系统上，才能使用虚拟化技术，因此需要升级到专业版。&lt;/p&gt;
&lt;p&gt;如果需要升级的，升级过程也比较简单，简单介绍如下（已经是专业版的可以略过）：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;17&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://upload-images.jianshu.io/upload_images/6332485-5e412a9237b1f6f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://upload-images.jianshu.io/upload_images/6332485-5e412a9237b1f6f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://upload-images.jianshu.io/upload_images/6332485-5e412a9237b1f6f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;点击更改产品密匙，输入专业版的密匙之后，就等待慢慢升级了。密匙自己在网上找，反正是有的。&lt;/p&gt;
&lt;p&gt;2、安装docker for windows&lt;/p&gt;
&lt;p&gt;去官网下载后，一路下一步就可以了。安装完后，会自己启动，启动后工具栏就会出现docker的标志。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;16&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://upload-images.jianshu.io/upload_images/6332485-b832878692971239.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://upload-images.jianshu.io/upload_images/6332485-b832878692971239.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://upload-images.jianshu.io/upload_images/6332485-b832878692971239.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;安装成功后，可以敲一些命令测试一下是否成功。如：查看docker基本信息。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;15&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://upload-images.jianshu.io/upload_images/6332485-3b3eb7973e3cee62.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://upload-images.jianshu.io/upload_images/6332485-3b3eb7973e3cee62.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://upload-images.jianshu.io/upload_images/6332485-3b3eb7973e3cee62.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;3、修改docker镜像地址。&lt;/p&gt;
&lt;p&gt;由于默认的镜像地址较慢，一个tomcat镜像都500多m，网络不好下载会很慢，可将镜像地址配置成网易的镜像地址，如下：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;14&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://upload-images.jianshu.io/upload_images/6332485-241449437053fdac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://upload-images.jianshu.io/upload_images/6332485-241449437053fdac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://upload-images.jianshu.io/upload_images/6332485-241449437053fdac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;4、启动远程管理&lt;/p&gt;
&lt;p&gt;勾选上最后一项，这里面的tcp//xxx就是远程连接地址。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;13&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://upload-images.jianshu.io/upload_images/6332485-64a6aa34d5c10650.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://upload-images.jianshu.io/upload_images/6332485-64a6aa34d5c10650.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://upload-images.jianshu.io/upload_images/6332485-64a6aa34d5c10650.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;启动后，在浏览器里面敲一下地址，看看是否能返回结果：&lt;/p&gt;
&lt;p&gt;http://localhost:2375/info（此地址同在cmd里面输入docker indo）返回的是json格式的内容：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;12&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://upload-images.jianshu.io/upload_images/6332485-911ec86d8bed267c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://upload-images.jianshu.io/upload_images/6332485-911ec86d8bed267c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://upload-images.jianshu.io/upload_images/6332485-911ec86d8bed267c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;实现过程之代码开发&lt;/h3&gt;
&lt;p&gt;1、创建maven项目。&lt;/p&gt;
&lt;p&gt;  由于过程简单，省略此过程。整个项目的代码结构如下：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;11&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://upload-images.jianshu.io/upload_images/6332485-db263d54269cf83d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://upload-images.jianshu.io/upload_images/6332485-db263d54269cf83d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://upload-images.jianshu.io/upload_images/6332485-db263d54269cf83d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;2、配置docker-java和spring boot的maven依赖，最终pom文件内容如下&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;10&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://upload-images.jianshu.io/upload_images/6332485-5d12b00529d57056.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://upload-images.jianshu.io/upload_images/6332485-5d12b00529d57056.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://upload-images.jianshu.io/upload_images/6332485-5d12b00529d57056.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;通过看jar包，docker-java底层应该是用了netty依赖。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、添加spring配置文件application.properties&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;配置jsp的位置和docker的管理地址。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;9&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://upload-images.jianshu.io/upload_images/6332485-0b2188e736dff055.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://upload-images.jianshu.io/upload_images/6332485-0b2188e736dff055.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://upload-images.jianshu.io/upload_images/6332485-0b2188e736dff055.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;4、主要类介绍：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.spring boot启动主类。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当然也可以配置其他容器或者用maven的jetty插件来启动。&lt;/p&gt;
&lt;p&gt;可参考另外一篇文章：&lt;a href=&quot;https://www.cnblogs.com/qiaobing/p/10985748.html&quot; data-cke-saved-href=&quot;https://blog.csdn.net/crazy_joe/article/details/91045646&quot;&gt;Spring-boot原理（附带实现一个spring-boot-starter实例）附源码下载&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;8&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://upload-images.jianshu.io/upload_images/6332485-adf65dd19dc86801.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://upload-images.jianshu.io/upload_images/6332485-adf65dd19dc86801.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://upload-images.jianshu.io/upload_images/6332485-adf65dd19dc86801.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;注意这个类放的位置，最好放在根目录，这样根目录下的所有子目录都能被spring扫描到了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.DockerClientOperaterServer(与docker交互的类)，具体如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;包括如下方法：&lt;/p&gt;
&lt;p&gt;initClient：初始化链接。&lt;/p&gt;
&lt;p&gt;getDockerInfo：获取docker基本信息；&lt;/p&gt;
&lt;p&gt;stat：实时统计信息；&lt;/p&gt;
&lt;p&gt;refreshContainers：获取所有容器的基本信息，并放入缓存；&lt;/p&gt;
&lt;p&gt;createAndStartrContainerAnddeployApp：根据界面传递的参数创建并启动容器，同时部署项目；&lt;/p&gt;
&lt;p&gt;stopContainer：停止容器；&lt;/p&gt;
&lt;p&gt;rmContainer：删除容器；&lt;/p&gt;
&lt;p&gt;closeClient：关闭链接；&lt;/p&gt;
&lt;p&gt;pushAppToCotainer：部署war包到tomcat；&lt;/p&gt;
&lt;p&gt;由于代码片段太长，这里看几个主要的方法：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;createContainer（创建容器）：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;7&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://upload-images.jianshu.io/upload_images/6332485-6fb8744d7df3ca6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://upload-images.jianshu.io/upload_images/6332485-6fb8744d7df3ca6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://upload-images.jianshu.io/upload_images/6332485-6fb8744d7df3ca6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;这个方法里面通过docker-java创建容器，分配限额，配置端口映射等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;pushAppToCotainer：部署项目到tomcat&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;6&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://upload-images.jianshu.io/upload_images/6332485-4742bc2299844993.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://upload-images.jianshu.io/upload_images/6332485-4742bc2299844993.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://upload-images.jianshu.io/upload_images/6332485-4742bc2299844993.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;stat，监控方法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;监控这一块没有用docker-java的方法，其实它是支持的，但是由于返回结果需要各种处理，就用了投机取巧的方法。使用java调用cmd来执行（docker stats）获取监控结果。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;5&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://upload-images.jianshu.io/upload_images/6332485-1756e3cf74647fba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://upload-images.jianshu.io/upload_images/6332485-1756e3cf74647fba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://upload-images.jianshu.io/upload_images/6332485-1756e3cf74647fba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;docker-java来获取监控信息的代码如下：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;4&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://upload-images.jianshu.io/upload_images/6332485-aef864a8464824bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://upload-images.jianshu.io/upload_images/6332485-aef864a8464824bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://upload-images.jianshu.io/upload_images/6332485-aef864a8464824bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.DockerClientController（和界面交互的controller）。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;主要方法介绍：&lt;/p&gt;
&lt;p&gt;addContainer：添加容器以及上传war包&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;3&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://upload-images.jianshu.io/upload_images/6332485-66700ae283464d5b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://upload-images.jianshu.io/upload_images/6332485-66700ae283464d5b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://upload-images.jianshu.io/upload_images/6332485-66700ae283464d5b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;以上便是主要代码的讲解。&lt;/p&gt;
&lt;p&gt;具体代码详情，请下载源码启动后按照过程查看。&lt;/p&gt;
&lt;h3&gt;实现后的主要界面：&lt;/h3&gt;
&lt;p&gt;由于是示例项目，代码没有用什么vue和bootstrap框架。自己写了点css和js。具体效果如下：&lt;/p&gt;
&lt;p&gt;1、监控管理主页&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;2&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://upload-images.jianshu.io/upload_images/6332485-31762b353bc52a18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://upload-images.jianshu.io/upload_images/6332485-31762b353bc52a18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://upload-images.jianshu.io/upload_images/6332485-31762b353bc52a18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;2、添加容器；&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;1&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://upload-images.jianshu.io/upload_images/6332485-2ed7c348c04c2f65.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://upload-images.jianshu.io/upload_images/6332485-2ed7c348c04c2f65.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://upload-images.jianshu.io/upload_images/6332485-2ed7c348c04c2f65.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;~以上便是本次分享所有内容~&lt;/p&gt;
&lt;p&gt;过程中又问可以留言，如果有时间可以一起讨论。谢谢！&lt;/p&gt;
&lt;h3&gt;源码下载&lt;/h3&gt;
&lt;p&gt;为防止地址失效，所有下载链接都在公众号维护，请关注公众号后，回复“R004” 获取完整源码。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;0&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://upload-images.jianshu.io/upload_images/6332485-113d5c205df59aba.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;124&quot; height=&quot;124&quot; data-cke-saved-src=&quot;https://upload-images.jianshu.io/upload_images/6332485-113d5c205df59aba.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://upload-images.jianshu.io/upload_images/6332485-113d5c205df59aba.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;124&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;124&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 14 Jun 2019 00:39:00 +0000</pubDate>
<dc:creator>crazy_joe</dc:creator>
<og:description>基于spring-boot和docker-java实现对docker容器的动态管理和监控[附完整源码下载]</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qiaobing/p/11020870.html</dc:identifier>
</item>
<item>
<title>Kubernetes基本概念之Label - 周国通</title>
<link>http://www.cnblogs.com/tylerzhou/p/11020761.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tylerzhou/p/11020761.html</guid>
<description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/tylerzhou/p/10969041.html&quot;&gt;系列目录&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在为对象定义好Label后，其他对象就可以通过Label来对对象进行引用。Label的最常见的用法便是通过spec.selector来引用对象。&lt;/p&gt;
&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;apiVersion: v1
kind: ReplicationController
metadata:
  name: nginx
spec:
  replicas: 3
  selector:
    app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx
        ports:
        - containerPort: 80
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于Label的用法重点在于这两步：&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;通过&lt;code&gt;template.metadata.labels&lt;/code&gt;字段&lt;code&gt;为即将新建的Pod附加Label&lt;/code&gt;。在上面的例子中，新建了一个名称为nginx的Pod，它拥有一个键值对为app:nginx的Label。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;通过&lt;code&gt;spec.selector&lt;/code&gt;字段来&lt;code&gt;指定这个RC管理哪些Pod&lt;/code&gt;。在上面的例子中，新建的RC会管理所有拥有app:nginxLabel的Pod。这样的&lt;code&gt;spec.selector&lt;/code&gt;在Kubernetes中被称作&lt;code&gt;Label Selector&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;label的定义&quot;&gt;1.1. Label的定义&lt;/h2&gt;
&lt;p&gt;我们通常使用&lt;code&gt;metadata.labels&lt;/code&gt;字段，来为对象添加Label。Label可以为多个。一个简单的例子如下：&lt;/p&gt;
&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;apiVersion: v1
kind: Pod
metadata:
  name: nginx
  labels:
    app: nginx
    release: stable
spec:
  containers:
  - name: nginx
    image: nginx
    ports:
    - containerPort: 80
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的描述文件为名为nginx的Pod添加了两个Label，分别为app: nginx和release: stable。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注: label为任意键值对,只要selector在选择的时候匹配即可&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;常见的label&quot;&gt;1.1.1. 常见的Label&lt;/h3&gt;
&lt;p&gt;一般来说，我们会给一个Pod（或其他对象）定义&lt;code&gt;多个Label&lt;/code&gt;，以便于配置，部署等管理工作。例如：部署不同版本的应用到不同的环境中；或者监控和分析应用（日志记录，监控，报警等）。通过多个Label的设置，我们就可以多维度的Pod或其他对象进行精细化管理。一些常用的Label示例如下：&lt;/p&gt;
&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;relase: stable
release: canary
environment: dev
environemnt: qa
environment: production
tier: frontend
tier: backend
tier: middleware
......
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;上面说过,Label是自定义的一些key/value对，你可以随心所欲的设置,但是强烈建议按照一定的惯例或者组织内部规则,以便维护管理&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;label-selector&quot;&gt;1.2. Label Selector&lt;/h2&gt;
&lt;p&gt;带有Label的对象创建好之后，我们就可以通过Label Selector来引用这些对象。&lt;br/&gt;通常我们通过描述文件中的&lt;code&gt;spec.selector&lt;/code&gt;字段来指定Label，从而Kubernetes寻找到所有包含你指定Label的对象，进行管理。&lt;br/&gt;Kubernetes目前支持两种类型的Label Selector：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;基于等式的Selector（Equality-based）&lt;/li&gt;
&lt;li&gt;基于集合的Selector（Set-based）&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;RC只支持基于等式的Selector，而RS两种Selector都支持。而RC是很早版本就建议弃用的特征,因此实际项目中强烈建议使用&lt;code&gt;Deployment&lt;/code&gt;来代替&lt;code&gt;Repliation Controller (RC)&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;基于等式的selector&quot;&gt;1.2.1. 基于等式的Selector&lt;/h3&gt;
&lt;p&gt;上文中创建RC的例子中的使用的就是基于等式的Selector。基于等式的Selector通过等式类的表达式来进行筛选。例如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;app=nginx 选择所有Label中key为app，value为nginx的对象。&lt;/li&gt;
&lt;li&gt;env!=dev 选择所有Label中key为env，value不等于dev的对象。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;基于集合的selector&quot;&gt;1.2.2. 基于集合的Selector&lt;/h3&gt;
&lt;p&gt;基于集合的Selector通过集合操作的表达式来进行筛选。例如&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;name in (redis-master, redis-slave) 选择所有Label中key为name，并且value为redis-master或redis-slave的对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;env not in (dev) 选择所有Label中key为env，并且value不为dev的对象。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;使用Label可以给对象创建一组或多组标签，Service，ReplicationController ReplicaSet,Deployment等组件则通过Label Selector来定位需要管理的对象，Label和Label Selector共同构成了Kubernetes系统中最核心的应用模型，使得对象能够精细分组，同时实现了集群的高可用性。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 14 Jun 2019 00:23:00 +0000</pubDate>
<dc:creator>周国通</dc:creator>
<og:description>'系列目录' 在为对象定义好Label后，其他对象就可以通过Label来对对象进行引用。Label的最常见的用法便是通过spec.selector来引用对象。 关于Label的用法重点在于这两步： +</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tylerzhou/p/11020761.html</dc:identifier>
</item>
<item>
<title>asp.net core 集成JWT（二）token的强制失效，基于策略模式细化api权限 - 7tiny</title>
<link>http://www.cnblogs.com/7tiny/p/11019698.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/7tiny/p/11019698.html</guid>
<description>&lt;h2&gt;【前言】&lt;/h2&gt;
&lt;p&gt;　　上一篇我们介绍了什么是JWT，以及如何在asp.net core api项目中集成JWT权限认证。传送门：&lt;a href=&quot;https://www.cnblogs.com/7tiny/p/11012035.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/7tiny/p/11012035.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　很多博友在留言中提出了疑问：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如何结合jwt认证对用户进行API授权？&lt;/li&gt;
&lt;li&gt;token过期了怎么办?&lt;/li&gt;
&lt;li&gt;如何自动刷新token？&lt;/li&gt;
&lt;li&gt;如何强制token失效？&lt;/li&gt;
&lt;li&gt;如何应用到集群模式？&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　那么，便有了本篇。本篇在上一篇的基础上继续完善JWT的使用，并陆续回答上面的疑问。当然Demo中没有体现的也会提供思路供博友参考。&lt;/p&gt;
&lt;h2&gt;【一、如何结合JWT认证对用户进行API授权】&lt;/h2&gt;
&lt;p&gt;　　场景：我们有多个API接口，我们希望细化地控制哪个用户可以访问哪些API（可能是在某个授权界面进行API授权）&lt;/p&gt;
&lt;p&gt;　　还是我们上一篇中的Demo项目：&lt;a href=&quot;https://github.com/sevenTiny/Demo.Jwt&quot; target=&quot;_blank&quot;&gt;https://github.com/sevenTiny/Demo.Jwt&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201906/998608-20190613205231447-1469442753.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　我们添加了两个类:PolicyHandler.cs和PolicyRequirement.cs&lt;/p&gt;
&lt;p&gt;　　首先是：PolicyRequirement.cs，这个类文件中定义了一个用户名和url的对应实体，UserPermission用户权限承载实体。然后实现了微软自带的接口IAuthorizationRequirement，里面构造方法赋值了如果没有权限将要跳转的接口和某用户所有有权限的接口的配置集合，因为只写了一个接口，这里只配置了一条作为Demo，当然了，在实际应用的时候，所有的这些配置我们都可以写在数据库中持久化，需要的时候读取出来即可。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Authorization;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Http;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Demo.Jwt.AuthManagement
{
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 权限承载实体
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; PolicyRequirement : IAuthorizationRequirement
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 用户权限集合
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; List&amp;lt;UserPermission&amp;gt; UserPermissions { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 无权限action
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; DeniedAction { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 构造
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; PolicyRequirement()
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;没有权限则跳转到这个路由&lt;/span&gt;
            DeniedAction = &lt;span&gt;new&lt;/span&gt; PathString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/api/nopermission&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用户有权限访问的路由配置,当然可以从数据库获取&lt;/span&gt;
            UserPermissions = &lt;span&gt;new&lt;/span&gt; List&amp;lt;UserPermission&amp;gt;&lt;span&gt; {
                              &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; UserPermission {  Url=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/api/value3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, UserName=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;admin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;},
                          };
        }
    }

    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 用户权限承载实体
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserPermission
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 用户名
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; UserName { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 请求Url
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Url { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　PolicyHandler 这个类继承了微软提供的类型AuthorizationHandler&amp;lt;PolicyRequirement&amp;gt;，泛型是我们上一步刚定义的类型。&lt;/p&gt;
&lt;p&gt;　　在这个类里面，我们实现了抽象方法 Task HandleRequirementAsync(AuthorizationHandlerContext context, PolicyRequirement requirement)，这个方法里面明确了如何具体地校验用户是否有API权限，并且根据校验结果控制应该跳转到提示API，还是继续执行有权限的API。&lt;/p&gt;
&lt;p&gt;　　这里的校验逻辑比较简单，Demo级别的，但是提供了校验的入口，具体业务场景根据需求进行适当替换即可。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Authorization;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Security.Claims;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Demo.Jwt.AuthManagement
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; PolicyHandler : AuthorizationHandler&amp;lt;PolicyRequirement&amp;gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;span&gt; Task HandleRequirementAsync(AuthorizationHandlerContext context, PolicyRequirement requirement)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;赋值用户权限&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; userPermissions =&lt;span&gt; requirement.UserPermissions;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从AuthorizationHandlerContext转成HttpContext，以便取出表求信息&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; httpContext = (context.Resource &lt;span&gt;as&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Mvc.Filters.AuthorizationFilterContext).HttpContext;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;请求Url&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; questUrl =&lt;span&gt; httpContext.Request.Path.Value.ToUpperInvariant();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否经过验证&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; isAuthenticated =&lt;span&gt; httpContext.User.Identity.IsAuthenticated;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isAuthenticated)
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (userPermissions.GroupBy(g =&amp;gt; g.Url).Any(w =&amp;gt; w.Key.ToUpperInvariant() ==&lt;span&gt; questUrl))
                {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用户名&lt;/span&gt;
                    &lt;span&gt;var&lt;/span&gt; userName = httpContext.User.Claims.SingleOrDefault(s =&amp;gt; s.Type ==&lt;span&gt; ClaimTypes.NameIdentifier).Value;
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (userPermissions.Any(w =&amp;gt; w.UserName == userName &amp;amp;&amp;amp; w.Url.ToUpperInvariant() ==&lt;span&gt; questUrl))
                    {
                        context.Succeed(requirement);
                    }
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                    {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;无权限跳转到拒绝页面&lt;/span&gt;
&lt;span&gt;                        httpContext.Response.Redirect(requirement.DeniedAction);
                    }
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                {
                    context.Succeed(requirement);
                }
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Task.CompletedTask;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后我们改造一下模拟数据的API，添加一个 api/value3 不同的是，这个action我们添加了一个带有策略名称的权限特性标签：[Authorize(&quot;Permission&quot;)] 通过这个特性标签制定了这个action 会走我们自定义的策略方法。我们在返回值里面提示了“这个接口只有管理员才能访问到”，并且返回了登陆用户的用户名和角色信息。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[HttpGet]
[Route(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api/value3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
[Authorize(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Permission&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ActionResult&amp;lt;IEnumerable&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt; Get3()
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这是获取自定义参数的方法&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; auth =&lt;span&gt; HttpContext.AuthenticateAsync().Result.Principal.Claims;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; userName = auth.FirstOrDefault(t =&amp;gt; t.Type.Equals(ClaimTypes.NameIdentifier))?&lt;span&gt;.Value;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; role = auth.FirstOrDefault(t =&amp;gt; t.Type.Equals(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Role&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;))?&lt;span&gt;.Value;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这个接口有管理员权限才可以访问&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;userName={userName}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,$&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Role={role}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上文中获取token的方法我们也微微进行了调整，对不同的登陆用户返回不同的角色名，让演示更加直观一些，因为改动较小，这里不粘贴代码，有想看详情的请下载代码查看。&lt;/p&gt;
&lt;p&gt;　　然后我们改造一下Startup，主要改造的地方是添加了策略模式的配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
services.AddAuthorization(options =&amp;gt;&lt;span&gt;
{
    options.AddPolicy(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Permission&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, policy =&amp;gt; policy.Requirements.Add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; PolicyRequirement()));
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　还有添加了策略模式控制类的依赖注入&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注入授权Handler&lt;/span&gt;
services.AddSingleton&amp;lt;IAuthorizationHandler, PolicyHandler&amp;gt;();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　下面是完整的Startup.cs代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Demo.Jwt.AuthManagement;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Authentication.JwtBearer;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Authorization;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Builder;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Hosting;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Mvc;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.Configuration;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.DependencyInjection;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.IdentityModel.Tokens;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Demo.Jwt
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Startup
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Startup(IConfiguration configuration)
        {
            Configuration &lt;/span&gt;=&lt;span&gt; configuration;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IConfiguration Configuration { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; This method gets called by the runtime. Use this method to add services to the container.&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加策略鉴权模式&lt;/span&gt;
            services.AddAuthorization(options =&amp;gt;&lt;span&gt;
            {
                options.AddPolicy(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Permission&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, policy =&amp;gt; policy.Requirements.Add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; PolicyRequirement()));
            })
            .AddAuthentication(s &lt;/span&gt;=&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加JWT Scheme&lt;/span&gt;
                s.DefaultAuthenticateScheme =&lt;span&gt; JwtBearerDefaults.AuthenticationScheme;
                s.DefaultScheme &lt;/span&gt;=&lt;span&gt; JwtBearerDefaults.AuthenticationScheme;
                s.DefaultChallengeScheme &lt;/span&gt;=&lt;span&gt; JwtBearerDefaults.AuthenticationScheme;
            })
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加jwt验证：&lt;/span&gt;
            .AddJwtBearer(options =&amp;gt;&lt;span&gt;
            {
                options.TokenValidationParameters &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TokenValidationParameters
                {
                    ValidateLifetime &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否验证失效时间&lt;/span&gt;
                    ClockSkew = TimeSpan.FromSeconds(&lt;span&gt;30&lt;/span&gt;&lt;span&gt;),

                    ValidateAudience &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否验证Audience
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ValidAudience = Const.GetValidudience(),&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Audience
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里采用动态验证的方式，在重新登陆时，刷新token，旧token就强制失效了&lt;/span&gt;
                    AudienceValidator = (m, n, z) =&amp;gt;&lt;span&gt;
                    {
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; m != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; m.FirstOrDefault().Equals(Const.ValidAudience);
                    },
                    ValidateIssuer &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否验证Issuer&lt;/span&gt;
                    ValidIssuer = Const.Domain,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Issuer，这两项和前面签发jwt的设置一致&lt;/span&gt;
&lt;span&gt;
                    ValidateIssuerSigningKey &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否验证SecurityKey&lt;/span&gt;
                    IssuerSigningKey = &lt;span&gt;new&lt;/span&gt; SymmetricSecurityKey(Encoding.UTF8.GetBytes(Const.SecurityKey))&lt;span&gt;//&lt;/span&gt;&lt;span&gt;拿到SecurityKey&lt;/span&gt;
&lt;span&gt;                };
                options.Events &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JwtBearerEvents
                {
                    OnAuthenticationFailed &lt;/span&gt;= context =&amp;gt;&lt;span&gt;
                    {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Token expired&lt;/span&gt;
                        &lt;span&gt;if&lt;/span&gt; (context.Exception.GetType() == &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(SecurityTokenExpiredException))
                        {
                            context.Response.Headers.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Token-Expired&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                        }
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Task.CompletedTask;
                    }
                };
            });

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注入授权Handler&lt;/span&gt;
            services.AddSingleton&amp;lt;IAuthorizationHandler, PolicyHandler&amp;gt;&lt;span&gt;();

            services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2);
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; This method gets called by the runtime. Use this method to configure the HTTP request pipeline.&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app, IHostingEnvironment env)
        {
            &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;添加jwt验证&lt;/span&gt;
&lt;span&gt;            app.UseAuthentication();

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (env.IsDevelopment())
            {
                app.UseDeveloperExceptionPage();
            }

            app.UseMvc(routes &lt;/span&gt;=&amp;gt;&lt;span&gt;
            {
                routes.MapRoute(
                    name: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                        template: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{controller=Home}/{action=Index}/{id?}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            });
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我们完成了这些工作以后，我们明确我们的目标：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;api/value1 接口我们不登陆就可以直接进行访问&lt;/li&gt;
&lt;li&gt;api/value2 接口只有登陆用户可以访问，不登录的用户是没有权限的&lt;/li&gt;
&lt;li&gt;api/value3 接口只有admin账号登陆（代码里写死的账号admin，也只为admin配置了权限）才可以访问，普通用户是不能访问的&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　明确了上面的几个目标后，下面我们进行测试，依然是运行起来我们的项目：&lt;/p&gt;
&lt;h4&gt;　　1.api/value1 接口我们不登陆就可以直接进行访问&lt;/h4&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201906/998608-20190613211220045-212889810.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201906/998608-20190613211229386-1271254575.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　我们没有登陆便可以访问到api/value1接口&lt;/p&gt;
&lt;h4&gt;　　2.api/value2 接口只有登陆用户可以访问，不登录的用户是没有权限的&lt;/h4&gt;
&lt;p&gt;　　2.1. 我们先直接访问api/value2接口&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201906/998608-20190613211329195-229438109.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201906/998608-20190613211346748-539660476.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　返回了状态码：401 无权限&lt;/p&gt;
&lt;p&gt;　　2.2. 那么我们调用登陆接口获取token&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201906/998608-20190613211449860-1075799940.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201906/998608-20190613211500090-772105355.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2.3. 成功返回了token，我们拿该token去访问 api/value2 接口&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201906/998608-20190613211641302-1889000936.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201906/998608-20190613211649051-191233898.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　可以看到，我们成功拿到了数据，足以证明，api/value2 接口是需要登陆权限的&lt;/p&gt;
&lt;h4&gt;　　3. 那么，我们用这个token去访问 api/value3 又会怎样呢？&lt;/h4&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201906/998608-20190613211828741-173178412.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201906/998608-20190613211840964-1843170969.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　返回了403，访问错误。这个403是怎么来的呢？&lt;/p&gt;
&lt;p&gt;　　我们上文说过的PolicyHandler.cs文件中如果校验接口没有权限呢，我们会走下面这段逻辑：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;无权限跳转到拒绝页面&lt;/span&gt;
httpContext.Response.Redirect(requirement.DeniedAction);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201906/998608-20190613212017783-1470664307.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　requirement.DeniedAction是我们PolicyRequirement.cs文件中配置死的地址：&quot;/api/nopermission&quot;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201906/998608-20190613212108381-1536182252.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这个地址返回的就是403 Forbid，当然这里可以根据需要修改返回内容，不再赘述。&lt;/p&gt;
&lt;h4&gt;　　4. 我们换一个admin账号重新登陆，然后访问 api/value3 接口&lt;/h4&gt;
&lt;p&gt;　　4.1 首先我们调用获取token接口进行token获取&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201906/998608-20190613212230758-2146927626.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201906/998608-20190613212253513-226076884.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　4.2 我们拿到一个新的token，然后用这个新的token去访问刚才没权限的接口&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201906/998608-20190613212335314-1264093731.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201906/998608-20190613212342826-324924059.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　成功地获取到了结果，说明我们的配置策略生效了，只有admin账号才有权限获取到这个接口。&lt;/p&gt;
&lt;p&gt;　　上面就是我们完整的策略模式的实现方案，完整的代码可以在github地址中进行下载或clone。&lt;/p&gt;
&lt;h2&gt;【二、Token的使用策略】&lt;/h2&gt;
&lt;h4&gt;　　1.token过期了怎么办?&lt;/h4&gt;
&lt;p&gt;　　关于token过期这个话题呢，有很多应用场景，对应不同的处理方式。&lt;/p&gt;
&lt;p&gt;　　比如：token过期可以提示用户重新登陆，常见的有登陆一段时间后要重新登陆校验密码；&lt;/p&gt;
&lt;p&gt;　　比如：token过期可以使用其他手段进行“偷偷”刷新，用户感觉不到，但是token已经是新的了；&lt;/p&gt;
&lt;h4&gt;　　2.如何自动刷新token&lt;/h4&gt;
&lt;p&gt;　　那么token偷偷刷新有什么实现方式呢？&lt;/p&gt;
&lt;p&gt;　　比如：约定好失效的时间，前端在失效前进行重新调用登陆接口进行获取；&lt;/p&gt;
&lt;p&gt;　　比如：使用SingleR，保持前后端通讯也可以一定时间轮询刷新token；&lt;/p&gt;
&lt;p&gt;　　比如：后端执行策略，定时任务刷新token，如果持续请求接口，就可以拿到最新的token进行“续命”，如果长时间不访问任意接口，那么token也就失效了；&lt;/p&gt;
&lt;h4&gt;　　3.如何强制token失效？&lt;/h4&gt;
&lt;p&gt;　　什么场景要强制token失效呢？比如我们只允许账号一个地方登陆一次，异地登陆会将账号挤下线。这种时候我们就要将旧token失效，仅仅让新的token生效。&lt;/p&gt;
&lt;p&gt;　　下面我们在Demo中体现如何让旧token强制失效。&lt;/p&gt;
&lt;p&gt;　　3.1  在我们之前说过的Const.cs类中添加一个静态变量（不是const，const是只读的），让我们在程序中可以直接修改值。当然又是为了模拟，真实场景这个值应该持久化或者存在redis里面，这里我们为了代码简洁易懂就不集成太多的组件了。&lt;/p&gt;
&lt;p&gt;　　3.2 稍微修改一下我们的获取token的action，在密码验证成功之后，修改静态变量的值。&lt;/p&gt;
&lt;p&gt;　　变量值采用账号密码加当前时间字符串，以保证每次登陆都是不一样的值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;每次登陆动态刷新&lt;/span&gt;
Const.ValidAudience = userName + pwd + DateTime.Now.ToString();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后我们在生成token的时候，让接收者=我们静态变量的值，audience: Const.ValidAudience&lt;/p&gt;
&lt;p&gt;　　完整的代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[AllowAnonymous]
        [HttpGet]
        [Route(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api/auth&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IActionResult Get(&lt;span&gt;string&lt;/span&gt; userName, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; pwd)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (CheckAccount(userName, pwd, &lt;span&gt;out&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; role))
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;每次登陆动态刷新&lt;/span&gt;
                Const.ValidAudience = userName + pwd +&lt;span&gt; DateTime.Now.ToString();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; push the user’s name into a claim, so we can identify the user later on.
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里可以随意加入自定义的参数，key可以自己随便起&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; claims = &lt;span&gt;new&lt;/span&gt;&lt;span&gt;[]
                {
                    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Claim(JwtRegisteredClaimNames.Nbf,$&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{new DateTimeOffset(DateTime.Now).ToUnixTimeSeconds()}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) ,
                    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Claim (JwtRegisteredClaimNames.Exp,$&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{new DateTimeOffset(DateTime.Now.AddMinutes(30)).ToUnixTimeSeconds()}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
                    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Claim(ClaimTypes.NameIdentifier, userName),
                    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Claim(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Role&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, role)
                };
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;sign the token using a secret key.This secret will be shared between your API and anything that needs to check that the token is legit.&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; key = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SymmetricSecurityKey(Encoding.UTF8.GetBytes(Const.SecurityKey));
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; creds = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SigningCredentials(key, SecurityAlgorithms.HmacSha256);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;.NET Core’s JwtSecurityToken class takes on the heavy lifting and actually creates the token.&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; token = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JwtSecurityToken(
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;颁发者&lt;/span&gt;
&lt;span&gt;                    issuer: Const.Domain,
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;接收者&lt;/span&gt;
&lt;span&gt;                    audience: Const.ValidAudience,
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;过期时间&lt;/span&gt;
                    expires: DateTime.Now.AddMinutes(&lt;span&gt;30&lt;/span&gt;&lt;span&gt;),
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;签名证书&lt;/span&gt;
&lt;span&gt;                    signingCredentials: creds,
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;自定义参数&lt;/span&gt;
&lt;span&gt;                    claims: claims
                    );

                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Ok(&lt;span&gt;new&lt;/span&gt;&lt;span&gt;
                {
                    token &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JwtSecurityTokenHandler().WriteToken(token)
                });
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; BadRequest(&lt;span&gt;new&lt;/span&gt; { message = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;username or password is incorrect.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; });
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　3.3 然后改造一下StartUp.cs&lt;/p&gt;
&lt;p&gt;　　我们仅仅需要关心改动的地方，也就是AddJwtBearer这个验证token的方法，我们不用原先的固定值的校验方式，而提供一个代理方法进行运行时执行校验&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
.AddJwtBearer(options =&amp;gt;&lt;span&gt;

options.TokenValidationParameters &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TokenValidationParameters
{
    ValidateLifetime &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否验证失效时间&lt;/span&gt;
    ClockSkew = TimeSpan.FromSeconds(&lt;span&gt;30&lt;/span&gt;&lt;span&gt;),
    ValidateAudience &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否验证Audience
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ValidAudience = Const.GetValidudience(),&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Audience
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里采用动态验证的方式，在重新登陆时，刷新token，旧token就强制失效了&lt;/span&gt;
    AudienceValidator = (m, n, z) =&amp;gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; m != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; m.FirstOrDefault().Equals(Const.ValidAudience);
    },
    ValidateIssuer &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否验证Issuer&lt;/span&gt;
    ValidIssuer = Const.Domain,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Issuer，这两项和前面签发jwt的设置一致&lt;/span&gt;
    ValidateIssuerSigningKey = &lt;span&gt;true&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否验证SecurityKey&lt;/span&gt;
    IssuerSigningKey = &lt;span&gt;new&lt;/span&gt; SymmetricSecurityKey(Encoding.UTF8.GetBytes(Const.SecurityKey))&lt;span&gt;//&lt;/span&gt;&lt;span&gt;拿到SecurityKey&lt;/span&gt;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里逻辑是这样的：因为重新登陆将原来的变量更改了，所以这里校验的时候也一并修改成了新的变量值，那么旧的token当然就不匹配了，也就是旧的token被强制失效了。&lt;/p&gt;
&lt;p&gt; 　　3.4 我们实际验证一下&lt;/p&gt;
&lt;p&gt;　　3.4.1 首先我们用admin账号获取token&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201906/998608-20190613214743570-1951655533.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201906/998608-20190613214750004-2121560026.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　3.4.2 然后用该token访问有权限的 api/value3 接口&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201906/998608-20190613214834576-1628046124.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201906/998608-20190613214846704-442491284.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　意料之中，我们成功访问到了值，而且在有效期内访问多次都是可以访问成功的。&lt;/p&gt;
&lt;p&gt;　　3.4.3 那么我们用admin账号重新获取token&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201906/998608-20190613215018058-1383048062.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201906/998608-20190613215028879-968650809.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　拿到一个新的token&lt;/p&gt;
&lt;p&gt;　　3.4.4 我们不更换token，再用旧的token调用一下 api/value3&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201906/998608-20190613215103871-595240257.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201906/998608-20190613215114145-801438376.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　返回状态码401了，说明没有权限了&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201906/998608-20190613215145597-1753157229.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　同时headers里面有错误描述时接收人参数错误，说明一切尽在我们的预期之中。&lt;/p&gt;
&lt;p&gt;　　3.4.5 那么我们使用我们第二次登陆用的新的token进行访问api/value3&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201906/998608-20190613215316977-401633832.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201906/998608-20190613215325092-1101093637.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　又成功地获取到了数据，表明我们新的token占有了当前宝座，老国王已经被挤下台了！&lt;/p&gt;
&lt;h4&gt;　　4. 如何应用到集群模式&lt;/h4&gt;
&lt;p&gt;　　这个问题其实在测试过Demo，然后再结合我们日常应用的话，答案很容易得到。以下几种参考：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;我们这个Demo其实相关参数都是从Const.cs常量文件中获取的，文中也说了，实际应用中应从数据库或redis中获取。这些信号都表明了实际应用中很多都是走的配置中心或者是数据库，这些中间件本就天然支持集群模式，因此部署多套服务和部署一套服务是一样的，一个接口能通过的验证，多个接口也同样能通过验证。&lt;/li&gt;
&lt;li&gt;第二种场景在大项目中或者微服务场景中比较常见，那就是微服务网关，我们完全可以将JWT集成在微服务网关上，而不用关心具体的下游服务。只要网关能通过认证就可以访问到下游的服务节点。&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;【结尾】&lt;/h2&gt;
&lt;p&gt;　　到这里，我们在上一篇中“JWT的简介以及asp.net core 集成JWT”中遗留的问题已经全部解释完毕了，当然了，如果有新的问题也非常欢迎各路朋友在评论区留下您宝贵的意见。&lt;/p&gt;
&lt;p&gt;　　上一篇传送门：&lt;a href=&quot;https://www.cnblogs.com/7tiny/p/11012035.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/7tiny/p/11012035.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　如果想要完整项目源码的，可以参考地址：&lt;a href=&quot;https://github.com/sevenTiny/Demo.Jwt&quot; target=&quot;_blank&quot;&gt;https://github.com/sevenTiny/Demo.Jwt&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　如果有幸能帮助到你，高抬贵手点个star吧~&lt;/p&gt;
</description>
<pubDate>Thu, 13 Jun 2019 23:44:00 +0000</pubDate>
<dc:creator>7tiny</dc:creator>
<og:description>【前言】 上一篇我们介绍了什么是JWT，以及如何在asp.net core api项目中集成JWT权限认证。传送门：https://www.cnblogs.com/7tiny/p/11012035.h</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/7tiny/p/11019698.html</dc:identifier>
</item>
<item>
<title>synchronized到底锁住的是谁？ - OKevin</title>
<link>http://www.cnblogs.com/yulinfeng/p/11020576.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yulinfeng/p/11020576.html</guid>
<description>&lt;p&gt;本文代码仓库：&lt;a href=&quot;https://github.com/yu-linfeng/BlogRepositories/tree/master/repositories/sync&quot; target=&quot;_blank&quot;&gt;https://github.com/yu-linfeng/BlogRepositories/tree/master/repositories/sync&lt;/a&gt;&lt;/p&gt;
&lt;p dir=&quot;ltr&quot;&gt;先来一道&lt;strong&gt;校招级&lt;/strong&gt;并发编程笔试题&lt;/p&gt;
&lt;p dir=&quot;ltr&quot;&gt;&lt;strong&gt;题目：利用5个线程并发执行，num数字累计计数到10000，并打印。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;* Description:
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;* 利用5个线程并发执行，num数字累加计数到10000，并打印。
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;* 2019-06-13
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;* Created with OKevin.
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Count {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; num = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;        Count count = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Count();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;        Thread thread1 = &lt;span&gt;new&lt;/span&gt; Thread(count.&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyThread());
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;        Thread thread2 = &lt;span&gt;new&lt;/span&gt; Thread(count.&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyThread());
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;        Thread thread3 = &lt;span&gt;new&lt;/span&gt; Thread(count.&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyThread());
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;        Thread thread4 = &lt;span&gt;new&lt;/span&gt; Thread(count.&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyThread());
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;        Thread thread5 = &lt;span&gt;new&lt;/span&gt; Thread(count.&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyThread());
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;       thread1.start();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;       thread2.start();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;       thread3.start();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;       thread4.start();
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;       thread5.start();
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;       thread1.join();
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;       thread2.join();
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;       thread3.join();
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;       thread4.join();
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;       thread5.join();
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;       System.out.println(count.num);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; increse() {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 2000; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;            num++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;       }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; 
&lt;span&gt;39&lt;/span&gt;    &lt;span&gt;class&lt;/span&gt; MyThread &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable {
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;       @Override
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;           increse();
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;       }
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p dir=&quot;ltr&quot;&gt;这道&lt;strong&gt;校招级&lt;/strong&gt;的并发编程面试题，题目不难，方法简单。其中涉及一个核心知识点——synchronized（当然这题的解法有很多），这也是本文想要弄清的主题。&lt;/p&gt;
&lt;p dir=&quot;ltr&quot;&gt;synchronized被大大小小的程序员广泛使用，有的程序员偷懒，在要求保证线程安全时，不加思索的就在方法前加入了synchronized关键字（例如我刚才那道&lt;strong&gt;校招级&lt;/strong&gt;大题）。偷懒归偷懒，CodeReview总是要进行的，面对同事的“指责”，要求优化这个方法，将synchronized使用同步代码块的方式提高效率。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/630246/201906/630246-20190614002332217-1672865177.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p dir=&quot;ltr&quot;&gt; &lt;/p&gt;
&lt;p dir=&quot;ltr&quot;&gt;synchronized要按照同步代码块来保证线程安全，这可就加在方法“复杂”多了。有：synchronized(this){}这么写的，也有synchronized(Count.class){}这么写的，还有定义了一个private Object obj = new Object; ….synchronized(obj){}这么写的。此时不禁在心里“W*F”。&lt;/p&gt;
&lt;p dir=&quot;ltr&quot;&gt;synchronized你到底锁住的是谁？&lt;/p&gt;
&lt;p dir=&quot;ltr&quot;&gt;synchronized从语法的维度一共有3个用法：&lt;/p&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li dir=&quot;ltr&quot; readability=&quot;-1&quot;&gt;
&lt;p dir=&quot;ltr&quot;&gt;静态方法加上关键字&lt;/p&gt;
&lt;/li&gt;
&lt;li dir=&quot;ltr&quot; readability=&quot;-1&quot;&gt;
&lt;p dir=&quot;ltr&quot;&gt;实例方法（也就是普通方法）加上关键字&lt;/p&gt;
&lt;/li&gt;
&lt;li dir=&quot;ltr&quot; readability=&quot;-1&quot;&gt;
&lt;p dir=&quot;ltr&quot;&gt;方法中使用同步代码块&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p dir=&quot;ltr&quot;&gt;前两种方式最为偷懒，第三种方式比前两种性能要好。&lt;/p&gt;
&lt;p dir=&quot;ltr&quot;&gt;synchronized从锁的是谁的维度一共有两种情况：&lt;/p&gt;
&lt;ol&gt;&lt;li dir=&quot;ltr&quot;&gt;
&lt;p dir=&quot;ltr&quot;&gt;锁住类&lt;/p&gt;
&lt;/li&gt;
&lt;li dir=&quot;ltr&quot;&gt;
&lt;p dir=&quot;ltr&quot;&gt;锁住对象实例&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p dir=&quot;ltr&quot;&gt;我们还是从直观的语法结构上来讲述synchronized。&lt;/p&gt;
&lt;h3 dir=&quot;ltr&quot;&gt;1）静态方法上的锁&lt;/h3&gt;
&lt;p dir=&quot;ltr&quot;&gt;静态方法是属于“类”，不属于某个实例，是所有对象实例所共享的方法。也就是说如果在静态方法上加入synchronized，那么它获取的就是这个类的锁，&lt;strong&gt;锁住的就是这个类&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 dir=&quot;ltr&quot;&gt;2）实例方法（普通方法）上的锁&lt;/h3&gt;
&lt;p dir=&quot;ltr&quot;&gt;实例方法并不是类所独有的，每个对象实例独立拥有它，它并不被对象实例所共享。这也比较能推出，在实例方法上加入synchronized，那么它获取的就是这个累的锁，&lt;strong&gt;锁住的就是这个对象实例&lt;/strong&gt;。&lt;/p&gt;
&lt;p dir=&quot;ltr&quot;&gt;那锁住类还是锁住对象实例，这跟我线程安全关系大吗？大，差之毫厘谬以千里的大。为了更好的理解锁住类还是锁住对象实例，在进入“3）方法中使用同步代码块”前，先直观的感受下这两者的区别。&lt;/p&gt;
&lt;h4 dir=&quot;ltr&quot;&gt;对实例方法（普通方法）上加关键字锁住对象实例锁的解释&lt;/h4&gt;
&lt;p&gt;&lt;span id=&quot;docs-internal-guid-c0651a7c-7fff-589d-cf4f-8a53cfbba8b2&quot;&gt;首先定义一个Demo类，其中的实例方法加上了synchronized关键字，按照所述也就是说锁住的对象实例。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;* Description:
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;* 死循环，目的是两个线程抢占一个锁时，只要其中一个线程获取，另一个线程就会一直阻塞
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;* 2019-06-13
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;* Created with OKevin.
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Demo {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; demo() {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;        &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) {   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;synchronized方法内部是一个死循环，一旦一个线程持有过后就不会释放这个锁&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;           System.out.println(Thread.currentThread());
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;       }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p dir=&quot;ltr&quot;&gt;可以看到在demo方法中定义了一个死循环，一旦一个线程持有这个锁后其他线程就不可能获取这个锁。结合上述synchronized修饰实例方法锁住的是对象实例，如果两个线程针对的是一个对象实例，那么其中一个线程必然不可能获取这个锁；如果两个线程针对的是两个对象实例，那么这两个线程不相关均能获取这个锁。&lt;/p&gt;
&lt;p dir=&quot;ltr&quot;&gt;自定义线程，调用demo方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;* Description:
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;* 自定义线程
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;* 2019-06-13
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;* Created with OKevin.
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MyThread &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Demo demo;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; MyThread(Demo demo) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;        &lt;span&gt;this&lt;/span&gt;.demo =&lt;span&gt; demo;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;   @Override
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;       demo.demo();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p dir=&quot;ltr&quot;&gt;&lt;strong&gt;测试程序1：两个线程抢占一个对象实例的锁&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;* Description:
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;* 两个线程抢占一个对象实例的锁
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;* 2019-06-13
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;* Created with OKevin.
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Main1 {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;        Demo demo = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Demo();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;        Thread thread1 = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyThread(demo));
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;        Thread thread2 = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyThread(demo));
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;       thread1.start();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;       thread2.start();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/630246/201906/630246-20190614002806048-1777287193.png&quot; alt=&quot;&quot; width=&quot;222&quot; height=&quot;285&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 如上图所示，输出结果显然只会打印一个线程的信息，另一个线程永远也获取不到这个锁。&lt;/p&gt;
&lt;p dir=&quot;ltr&quot;&gt;&lt;strong&gt;测试程序2：两个线程分别抢占两个对象实例的锁&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;* Description:
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;* 两个线程分别抢占两个对象实例的锁
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;* 2019-06-13
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;* Created with OKevin.
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Main2 {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;        Demo demo1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Demo();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;        Demo demo2 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Demo();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;        Thread thread1 = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyThread(demo1));
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;        Thread thread2 = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyThread(demo2));
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;       thread1.start();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;       thread2.start();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/630246/201906/630246-20190614002856873-716525039.png&quot; alt=&quot;&quot; width=&quot;223&quot; height=&quot;284&quot;/&gt;&lt;/p&gt;
&lt;p dir=&quot;ltr&quot;&gt;如上图所示，显然，两个线程均进入到了demo方法，也就是均获取到了锁，证明，两个线程抢占的就不是同一个锁，这就是&lt;strong&gt;synchronized修饰实例方法时，锁住的是对象实例的解释。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 dir=&quot;ltr&quot;&gt;对静态方法上加关键字锁住类锁的解释&lt;/h4&gt;
&lt;p dir=&quot;ltr&quot;&gt;静态方法是类所有对象实例所共享的，无论定义多少个实例，是要是静态方法上的锁，它至始至终只有1个。将上面的程序Demo中的方法加上static，无论使用“测试程序1”还是“测试程序2”，均只有一个线程可以抢占到锁，另一个线程仍然是永远无法获取到锁。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p dir=&quot;ltr&quot;&gt;让我们重新回到从语法结构上解释synchronized。&lt;/p&gt;
&lt;h3 dir=&quot;ltr&quot;&gt;3）方法中使用同步代码块&lt;/h3&gt;
&lt;p dir=&quot;ltr&quot;&gt;程序的改良优化需要建立在有坚实的基础，如果在不了解其内部机制，改良也仅仅是“形式主义”。&lt;/p&gt;
&lt;p dir=&quot;ltr&quot;&gt;结合开始CodeReview的例子：&lt;/p&gt;
&lt;p dir=&quot;ltr&quot;&gt;你的同事在CodeReview时，要求你将实例方法上的synchronized，改为效率更高的同步代码块方式。在你不清楚同步代码的用法时，网上搜到了一段synchronized(this){}代码，复制下来发现也能用，此时你以为你改良优化了代码。但实际上，你可能只是做了一点形式主义上的优化。&lt;/p&gt;

&lt;p dir=&quot;ltr&quot;&gt;为什么这么说？这需要清楚地认识同步代码块到底应该怎么用。&lt;/p&gt;
&lt;h4 dir=&quot;ltr&quot;&gt;3.1）synchronized(this){...}&lt;/h4&gt;
&lt;p&gt;&lt;span id=&quot;docs-internal-guid-bef4c17a-7fff-0b61-dd1b-4b752ea7090e&quot;&gt;this关键字所代表的意思是该对象实例，换句话说，这种用法synchronized锁住的仍然是对象实例，他和public synchronized void demo(){}可以说仅仅是做了语法上的改变。&lt;/span&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;* 2019-06-13
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;* Created with OKevin.
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Demo {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;   
&lt;span&gt; 7&lt;/span&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; demo1() {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;        &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) {  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;死循环目的是为了让线程一直持有该锁&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;           System.out.println(Thread.currentThread());
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;       }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; demo2() {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;        &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;           System.out.println(Thread.currentThread());
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;       }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p dir=&quot;ltr&quot;&gt;改为以下方式： &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;* Description:
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;* synchronized同步代码块对本实例加锁（this）
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;* 假设demo1与demo2方法不相关，此时两个线程对同一个对象实例分别调用demo1与demo2，只要其中一个线程获取到了锁即执行了demo1或者demo2，此时另一个线程会永远处于阻塞状态
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;* 2019-06-13
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;* Created with OKevin.
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Demo {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; demo1() {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;        &lt;span&gt;synchronized&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;            &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) {  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;死循环目的是为了让线程一直持有该锁&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;               System.out.println(Thread.currentThread());
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;           }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;       }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; demo2() {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;        &lt;span&gt;synchronized&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;            &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;               System.out.println(Thread.currentThread());
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;           }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;       }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span id=&quot;docs-internal-guid-f0bb0d00-7fff-b8c2-0062-40eae6676ef8&quot;&gt;也许后者在JVM中可能会做一些特殊的优化，但从代码分析上来讲，两者并没有做到很大的优化，线程1执行demo1，线程2执行demo2，由于两个方法均是抢占对象实例的锁，只要有一个线程获取到锁，另外一个线程只能阻塞等待，即使两个方法不相关。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;&lt;span id=&quot;docs-internal-guid-7da385f8-7fff-d15c-260d-c0085ce72abd&quot;&gt;3.2）private Object obj = new Object();    synchronized(obj){...}&lt;/span&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;* Description:
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;* synchronized同步代码块对对象内部的实例加锁
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;* 假设demo1与demo2方法不相关，此时两个线程对同一个对象实例分别调用demo1与demo2，均能获取各自的锁
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;* 2019-06-13
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;* Created with OKevin.
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Demo {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;    &lt;span&gt;private&lt;/span&gt; Object lock1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;    &lt;span&gt;private&lt;/span&gt; Object lock2 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; demo1() {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;        &lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; (lock1) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;            &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) {  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;死循环目的是为了让线程一直持有该锁&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;               System.out.println(Thread.currentThread());
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;           }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;       }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; demo2() {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;        &lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; (lock2) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;            &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;               System.out.println(Thread.currentThread());
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;           }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;       }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p dir=&quot;ltr&quot;&gt;经过上面的分析，看到这里，你可能会开始懂了，可以看到demo1方法中的同步代码块锁住的是lock1对象实例，demo2方法中的同步代码块锁住的是lock2对象实例。如果线程1执行demo1，线程2执行demo2，由于两个方法抢占的是不同的对象实例锁，也就是说两个线程均能获取到锁执行各自的方法（当然前提是两个方法互不相关，才不会出现逻辑错误）。&lt;/p&gt;
&lt;p dir=&quot;ltr&quot;&gt; &lt;/p&gt;
&lt;h4 dir=&quot;ltr&quot;&gt;3.3)synchronized(Demo.class){...}&lt;/h4&gt;
&lt;p dir=&quot;ltr&quot;&gt;这种形式等同于抢占获取类锁，这种方式，同样和3.1一样，收效甚微。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p dir=&quot;ltr&quot;&gt;&lt;strong&gt;所以CodeReivew后的代码应该是3.2) private Object obj = new Object();    synchronized(obj){...}，这才是对你代码的改良优化。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文代码仓库：&lt;a href=&quot;https://github.com/yu-linfeng/BlogRepositories/tree/master/repositories/sync&quot; target=&quot;_blank&quot;&gt;https://github.com/yu-linfeng/BlogRepositories/tree/master/repositories/sync&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p dir=&quot;ltr&quot;&gt;关注公众号：&lt;strong&gt;coderbuff&lt;/strong&gt;，下期预告：&lt;strong&gt;synchronized凭什么锁得住？&lt;/strong&gt;&lt;/p&gt;
&lt;p dir=&quot;ltr&quot;&gt; &lt;/p&gt;
&lt;p dir=&quot;ltr&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这是一个能给程序员加buff的公众号 （CoderBuff）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/630246/201901/630246-20190106013233246-1297584549.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
</description>
<pubDate>Thu, 13 Jun 2019 16:35:00 +0000</pubDate>
<dc:creator>OKevin</dc:creator>
<og:description>本文代码仓库：https://github.com/yu-linfeng/BlogRepositories/tree/master/repositories/sync 先来一道校招级并发编程笔试题 题</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yulinfeng/p/11020576.html</dc:identifier>
</item>
<item>
<title>生活小例子，通俗易懂讲接口 - 陈彦斌</title>
<link>http://www.cnblogs.com/chenyanbin/p/11020578.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenyanbin/p/11020578.html</guid>
<description>[unable to retrieve full-text content]接口 注：本篇文字约4300字，可能花费10分钟。 先不讲开发中为什么要使用接口？有什么好处？ 假设你是一个修水管的工人，有一个客户让你装水管，但是客户喜欢管子是三角形的。 很熟练的你就将水管安装到墙上，如图： 过几天，客户又来找你，他觉得三角形的不好看，要让你把三角形的管子，换成正方形的，你不得不</description>
<pubDate>Thu, 13 Jun 2019 16:34:00 +0000</pubDate>
<dc:creator>陈彦斌</dc:creator>
<og:description>本文代码仓库：https://github.com/yu-linfeng/BlogRepositories/tree/master/repositories/sync 先来一道校招级并发编程笔试题 题</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yulinfeng/p/11020576.html</dc:identifier>
</item>
<item>
<title>HTTP协议解析小白文 - blackc</title>
<link>http://www.cnblogs.com/passer101/p/11020539.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/passer101/p/11020539.html</guid>
<description>&lt;h2&gt;1. &lt;strong&gt;&lt;span&gt;什么是&lt;/span&gt;HTTP&lt;span&gt;协议？&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。&lt;/p&gt;
&lt;p&gt;RFC 1945定义了HTTP/1.0版本。其中最著名的就是RFC 2616。RFC 2616定义了今天普遍使用的一个版本——HTTP 1.1。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1098547/201906/1098547-20190614015147530-1408395536.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;简单地说，我们上网就是用户（客户端）遵循该协议向服务器发送请求获取资源，服务器解析该协议知道用户请求什么，然后把结果返回。&lt;/p&gt;
&lt;h2&gt;2. &lt;strong&gt;HTTP&lt;span&gt;协议的内容？&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;HTTP是基于传输层的TCP协议，而TCP是一个端到端的面向连接的协议。所以HTTP在开始传输之前，首先需要建立TCP连接，而TCP连接的过程需要所谓的“三次握手”。下图所示TCP连接的三次握手。&lt;br/&gt;&lt;span&gt;在&lt;/span&gt;TCP三次握手之后，建立了TCP连接，此时HTTP就可以进行传输了。一个重要的概念是面向连接，既HTTP在传输完成之间并不断开TCP连接。在HTTP1.1中(通过Connection头设置 keep alive)这是默认行为。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1098547/201906/1098547-20190614001010086-377663176.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;简单地说，三次握手就是去小餐厅点菜，会先问我能点菜吗？可以，你确定要点餐吗？我确定要点餐。我要点吧啦吧啦&lt;/span&gt;……开始写菜单&lt;/p&gt;
&lt;h3&gt;2.1 &lt;strong&gt;&lt;span&gt;客户端使用&lt;/span&gt;HTTP&lt;span&gt;协议给服务器发送了什么？&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;HTTP请求由&lt;strong&gt;状态行、请求头、请求&lt;/strong&gt;&lt;strong&gt;体&lt;/strong&gt;三部分组成：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;请求行&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;①是请求方法，GET和POST是最常见的HTTP方法，除此以外还包括DELETE、HEAD、OPTIONS、PUT、TRACE&lt;span&gt;、&lt;/span&gt;CONNECT，一共八种。&lt;/p&gt;
&lt;p&gt;②为请求对应的URL地址，它和报文头的Host属性组成完整的请求URL。&lt;/p&gt;
&lt;p&gt;③是协议名称及版本号。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;请求头：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;④是HTTP的报文头，报文头包含若干个属性，格式为“属性名:属性值”，服务端据此获取客户端的信息。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;与缓存相关的规则信息，均包含在&lt;/span&gt;header中&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;请求体：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;⑤是报文体，它将一个页面表单中的组件值通过param1=value1¶m2=value2的键值对形式编码成一个格式化串，它承载多个请求参数的数据。不但报文体可以传递请求参数，请求URL也可以通过类似于“/chapter15/user.html? param1=value1¶m2=value2”的方式传递请求参数。 &lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1098547/201906/1098547-20190614001034389-1699913016.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;简单来说，就是下菜单，点菜，写备注写要求。&lt;/p&gt;
&lt;h3&gt;2.2 &lt;strong&gt;&lt;span&gt;服务器使用&lt;/span&gt;HTTP&lt;span&gt;协议给客户端返回了什么？&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;HTTP的响应报文也由三部分组成，分别是响应行、响应头、响应体。&lt;/p&gt;
&lt;p&gt;响应行：&lt;/p&gt;
&lt;p&gt;①报文协议及版本； &lt;br/&gt;②状态码及状态描述；&lt;/p&gt;
&lt;p&gt;响应头：&lt;/p&gt;
&lt;p&gt;③响应报文头，也是由多个属性组成；&lt;/p&gt;
&lt;p&gt;响应体：&lt;/p&gt;
&lt;p&gt;④响应报文体，即我们真正要的“干货”。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1098547/201906/1098547-20190614001044483-1014176328.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;响应状态码&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;和请求报文相比，响应报文多了一个&lt;/span&gt;“响应状态码”，它以“清晰明确”的语言告诉客户端本次请求的处理结果。 &lt;br/&gt;HTTP的响应状态码由5段组成：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1）1xx 消息，一般是告诉客户端，请求已经收到了，正在处理，别急...&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;2）2xx 处理成功，一般表示：请求收悉、我明白你要的、请求已受理、已经处理完成等信息。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;3）3xx 重定向到其它地方。它让客户端再发起一个请求以完成整个处理。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;4）4xx 处理发生错误，责任在客户端，如客户端的请求一个不存在的资源，客户端未被授权，禁止访问等。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;5）5xx 处理发生错误，责任在服务端，如服务端抛出异常，路由出错，HTTP版本不支持等。&lt;/p&gt;
&lt;p&gt;常见的状态码：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;200 OK&lt;/strong&gt; &lt;span&gt;请求成功；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;302&lt;/strong&gt; &lt;span&gt;临时重定向&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;304 Not Modified&lt;/strong&gt;  &lt;span&gt;请求内容没有修改，使用本地缓存啦&lt;/span&gt;...&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;404 Not Found&lt;/strong&gt; 请求的资源不存在&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;500 Internal Server Error&lt;/strong&gt; &lt;span&gt;服务器错误&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;3. &lt;strong&gt;HTTP&lt;span&gt;的无状态特点&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;根据早期的&lt;/span&gt;HTTP协议，每次请求响应&lt;span&gt;时，都要重新建立&lt;/span&gt;TCP连接。TCP连接每次都重新建立，所以服务器无法知道上次请求和本次请求是否来自于同一个客户端。因此，HTTP通信是&lt;span&gt;无状态&lt;/span&gt;(stateless)的。服务器认为每次请求都是一个全新的请求，无论该请求是否来自同一地址。&lt;/p&gt;

&lt;p&gt;问题：为什么登录后就不用登录了？这不是记录的状态了吗？&lt;/p&gt;
&lt;p&gt;&lt;span&gt;答：&lt;/span&gt;HTTP并没有记录状态，而是程序，如PHP程序把状态保存在了cookie，session，不是HTTP记录了。&lt;/p&gt;
&lt;h2&gt;1. &lt;strong&gt;HTTP&lt;span&gt;版本更替&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;HTTP/0.9&lt;/p&gt;
&lt;p&gt;HTTP协议的最初版本，功能简陋，仅支持请求方式GET，并且仅能请求访问HTML格式的资源。&lt;/p&gt;
&lt;p&gt;HTTP/1.0&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在&lt;/span&gt;0.9版本上做了进步，增加了请求方式POST和HEAD；不再局限于0.9版本的HTML格式，根据Content-Type可以支持多种数据格式，即MIME多用途互联网邮件扩展，例如text/html、image/jpeg等；同时也开始支持cache，就是当客户端在规定时间内访问统一网站，直接访问cache即可。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是&lt;/span&gt;1.0版本的工作方式是每次TCP连接只能发送一个请求，当服务器响应后就会关闭这次连接，下一个请求需要再次建立TCP连接，就是不支持keepalive。&lt;/p&gt;
&lt;p&gt;HTTP/1.1&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解决了&lt;/span&gt;1.0版本的keepalive问题，1.1版本加入了持久连接，一个TCP连接可以允许多个HTTP请求； 加入了管道机制，一个TCP连接同时允许多个请求同时发送，增加了并发性；新增了请求方式PUT、PATCH、DELETE等。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是还存在一些问题，服务端是按队列顺序处理请求的，假如一个请求处理时间很长，则会导致后边的请求无法处理，这样就造成了队头阻塞的问题；同时&lt;/span&gt;HTTP是无状态的连接，因此每次请求都需要添加重复的字段，降低了带宽的利用率。&lt;/p&gt;
&lt;p&gt;HTTP/2.0&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了解决&lt;/span&gt;1.1版本利用率不高的问题，提出了HTTP/2.0版本。增加双工模式，即不仅客户端能够同时发送多个请求，服务端也能同时处理多个请求，解决了队头堵塞的问题；HTTP请求和响应中，状态行和请求/响应头都是些信息字段，并没有真正的数据，因此在2.0版本中将所有的信息字段建立一张表，为表中的每个字段建立索引，客户端和服务端共同使用这个表，他们之间就以索引号来表示信息字段，这样就避免了1.0旧版本的重复繁琐的字段，并以压缩的方式传输，提高利用率。&lt;/p&gt;
&lt;p&gt;另外也增加服务器推送的功能，即不经请求服务端主动向客户端发送数据，&lt;span&gt;例如服务端可以主动把&lt;/span&gt; JS 和 CSS 文件推送给客户端，而不需要客户端解析 HTML 再发送这些请求，当客户端需要的时候，它已经在客户端了。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;当前主流的协议版本还是&lt;/span&gt;HTTP/1.1版本&lt;span&gt;，既然&lt;/span&gt;HTTP/2.0这么好，为什么主流还是HTTP/1.1呢？&lt;/p&gt;
&lt;p&gt;原因有很多：&lt;/p&gt;
&lt;p&gt;（1）设备问题，以前的旧手机系统很多不支持。&lt;/p&gt;
&lt;p&gt;（2）&lt;span&gt;成本问题，&lt;/span&gt;HTTP/2.0开启https，就需要证书，购买证书需要花费。&lt;/p&gt;
&lt;p&gt;（3）&lt;span&gt;技术、运维成本，&lt;/span&gt;HTTPS部署相对HTTP来说麻烦好多。而且，如果正在使用HTTP，再转HTTP2，就可能需要替换时间成本。&lt;/p&gt;
&lt;p&gt;（4）&lt;span&gt;开发语言不支持，目前主流的开发语言，如&lt;/span&gt;C/C++,java,php等等都支持，但是有个别小众的语言应该还不支持。&lt;/p&gt;
&lt;p&gt;（5）目前网站速度可以，不想更换。&lt;/p&gt;
&lt;p&gt;（6）……&lt;/p&gt;
</description>
<pubDate>Thu, 13 Jun 2019 16:11:00 +0000</pubDate>
<dc:creator>blackc</dc:creator>
<og:description>1. 什么是HTTP协议？ HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/passer101/p/11020539.html</dc:identifier>
</item>
<item>
<title>设计模式-装饰模式(Decorator Pattern) - 爱在惜缘前</title>
<link>http://www.cnblogs.com/treeshu/p/11020503.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/treeshu/p/11020503.html</guid>
<description>&lt;h4&gt;Attach additional responsibilities to an object dynamically keeping the same interface.Decorators provide a flexible alternative to subclassing for extending functionality.（动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式相比生成子类更为灵活。）&lt;/h4&gt;
&lt;p&gt;装饰模式有四个角色：&lt;br/&gt;1.Component抽象构件&lt;br/&gt;Component是一个接口或者是抽象类，就是定义我们最核心的对象，也就是最原始的对&lt;br/&gt;象。&lt;br/&gt;2.ConcreteComponent 具体构件&lt;br/&gt;ConcreteComponent是最核心、最原始、最基本的接口或抽象类的实现，你要装饰的就是&lt;br/&gt;它。&lt;br/&gt;3.Decorator装饰角色&lt;br/&gt;一般是一个抽象类，做什么用呢？实现接口或者抽象方法，它里面可不一定有抽象的方&lt;br/&gt;法呀，在它的属性里必然有一个private变量指向Component抽象构件。&lt;br/&gt;4.具体装饰角色&lt;br/&gt;ConcreteDecoratorA和ConcreteDecoratorB是两个具体的装饰类，你要把你最核心的、最&lt;br/&gt;原始的、最基本的东西装饰成其他东西。&lt;/p&gt;
&lt;p&gt;具体请看例子：&lt;br/&gt;Car&lt;/p&gt;
&lt;pre class=&quot;hljs java&quot;&gt;
&lt;code class=&quot;java&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;AudiCar&lt;/p&gt;
&lt;pre class=&quot;hljs java&quot;&gt;
&lt;code class=&quot;java&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;DecoratorCar&lt;/p&gt;
&lt;pre class=&quot;hljs java&quot;&gt;
&lt;code class=&quot;java&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;BlueAudiCar&lt;/p&gt;
&lt;pre class=&quot;hljs java&quot;&gt;
&lt;code class=&quot;java&quot;/&gt;
&lt;/pre&gt;
&lt;pre class=&quot;hljs java&quot;&gt;
&lt;code class=&quot;java&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;客户端&lt;/p&gt;
&lt;pre class=&quot;hljs java&quot;&gt;
&lt;code class=&quot;java&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;441&quot; data-height=&quot;132&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4327221-dc7afc77de64011d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/441/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/4327221-dc7afc77de64011d.png&quot; data-original-width=&quot;441&quot; data-original-height=&quot;132&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;69256&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;image.png&lt;/p&gt;
&lt;/div&gt;
&lt;h4&gt;装饰模式优点：&lt;/h4&gt;
&lt;p&gt;1.装饰类和被装饰类可以独立发展，而不会相互耦合。&lt;br/&gt;2.装饰模式是继承关系的一个替代方案。&lt;br/&gt;3.可以动态扩展类。&lt;/p&gt;
&lt;h4&gt;装饰模式缺点：&lt;/h4&gt;
&lt;p&gt;多层的装饰是比较复杂。&lt;/p&gt;
&lt;h4&gt;装饰模式使用场景：&lt;/h4&gt;
&lt;p&gt;需要动态地给一个对象增加功能、需要扩展一个类的功能。&lt;/p&gt;
&lt;p&gt;举个简单例子可以看出装饰模式的好处：三个继承关系Father、Son、GrandSon三个类，我要在Son类上增强一些功能怎么办？我想你会坚决地顶回去！不允许，对了，为什么呢？你增强的功能是修改Son类中的方法吗？增加方法吗？对GrandSon的影响呢？特别是GrandSon有多个的情况，你会怎么办？这个评估的工作量就够你受的，所以这是不允许的，那还是要解决问题的呀，怎么办？通过建立SonDecorator类来修饰Son，相当于创建了一个新的类，这个对原有程序没有变更，通过扩展很好地完成了这次变更。&lt;/p&gt;
&lt;h4&gt;注意：继承是静态地给类增加功能，而装饰模式则是动态地增加功能。&lt;/h4&gt;
</description>
<pubDate>Thu, 13 Jun 2019 15:54:00 +0000</pubDate>
<dc:creator>爱在惜缘前</dc:creator>
<og:description>Attach additional responsibilities to an object dynamically keeping the same interface.Decorators pr</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/treeshu/p/11020503.html</dc:identifier>
</item>
<item>
<title>SpringBoot(15)—@Conditional注解 - 雨点的名字</title>
<link>http://www.cnblogs.com/qdhxhz/p/11020434.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qdhxhz/p/11020434.html</guid>
<description>&lt;center&gt;

&lt;/center&gt;
&lt;p&gt;&lt;code&gt;作用&lt;/code&gt; @Conditional是Spring4新提供的注解，它的作用是按照一定的条件进行判断，满足条件的才给容器注册Bean。&lt;/p&gt;
&lt;h2 id=&quot;一概述&quot;&gt;&lt;span&gt;一、概述&lt;/span&gt;&lt;/h2&gt;
&lt;h4 id=&quot;conditional注解定义&quot;&gt;1、@Conditional注解定义&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Conditional {
    Class&amp;lt;? extends Condition&amp;gt;[] value();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;condition&quot;&gt;2、Condition&lt;/h4&gt;
&lt;p&gt;我们点进去看后，发现它是一个接口，有一个方法。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@FunctionalInterface
public interface Condition {
    boolean matches(ConditionContext var1, AnnotatedTypeMetadata var2);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;conditioncontext&quot;&gt;3、ConditionContext&lt;/h4&gt;
&lt;p&gt;它持有不少有用的对象，可以用来获取很多系统相关的信息，来丰富条件判断，接口定义如下&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface ConditionContext {
    /**
     * 获取Bean定义
     */
    BeanDefinitionRegistry getRegistry();
    /**
     * 获取Bean工程，因此就可以获取容器中的所有bean
     */
    @Nullable
    ConfigurableListableBeanFactory getBeanFactory();
    /**
     * environment 持有所有的配置信息
     */
    Environment getEnvironment();
    /**
     * 资源信息
     */
    ResourceLoader getResourceLoader();
    /**
     * 类加载信息
     */
    @Nullable
    ClassLoader getClassLoader();
}&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;二案例&quot;&gt;&lt;span&gt;二、案例&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;需求&lt;/code&gt; 根据当前系统环境的的不同实例不同的Bean，比如现在是&lt;code&gt;Mac&lt;/code&gt;那就实例一个Bean,如果是&lt;code&gt;Window&lt;/code&gt;系统实例另一个Bean。&lt;/p&gt;
&lt;h4 id=&quot;systembean&quot;&gt;1、SystemBean&lt;/h4&gt;
&lt;p&gt;首先创建一个Bean类&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Data
@AllArgsConstructor
@NoArgsConstructor
@ToString
public class SystemBean {
    /**
     * 系统名称
     */
    private String systemName;
    /**
     * 系统code
     */
    private String systemCode;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;通过configuration配置实例化bean&quot;&gt;2、通过Configuration配置实例化Bean&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Slf4j
@Configuration
public class ConditionalConfig {
    /**
     * 如果WindowsCondition的实现方法返回true，则注入这个bean
     */
    @Bean(&quot;windows&quot;)
    @Conditional({WindowsCondition.class})
    public SystemBean systemWi() {
        log.info(&quot;ConditionalConfig方法注入 windows实体&quot;);
        return new SystemBean(&quot;windows系统&quot;,&quot;002&quot;);
    }
    /**
     * 如果LinuxCondition的实现方法返回true，则注入这个bean
     */
    @Bean(&quot;mac&quot;)
    @Conditional({MacCondition.class})
    public SystemBean systemMac() {
        log.info(&quot;ConditionalConfig方法注入 mac实体&quot;);
        return new SystemBean(&quot;Mac ios系统&quot;,&quot;001&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;windowscondition和maccondition&quot;&gt;3、WindowsCondition和MacCondition&lt;/h4&gt;
&lt;p&gt;这两个类都实现了Condition接口, &lt;code&gt;只有matches方法返回true才会实例化当前Bean&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1）WindowsCondition&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Slf4j
public class WindowsCondition implements Condition {
    /**
     * @param conditionContext:判断条件能使用的上下文环境
     * @param annotatedTypeMetadata:注解所在位置的注释信息
     */
    @Override
    public boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata) {
        //获取ioc使用的beanFactory
        ConfigurableListableBeanFactory beanFactory = conditionContext.getBeanFactory();
        //获取类加载器
        ClassLoader classLoader = conditionContext.getClassLoader();
        //获取当前环境信息
        Environment environment = conditionContext.getEnvironment();
        //获取bean定义的注册类
        BeanDefinitionRegistry registry = conditionContext.getRegistry();
        //获得当前系统名
        String property = environment.getProperty(&quot;os.name&quot;);
        //包含Windows则说明是windows系统，返回true
        if (property.contains(&quot;Windows&quot;)){
            log.info(&quot;当前操作系统是：Windows&quot;);
            return true;
        }
        return false;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2) MacCondition&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Slf4j
public class MacCondition implements Condition {

   @Override
    public boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata) {
        Environment environment = conditionContext.getEnvironment();
        String property = environment.getProperty(&quot;os.name&quot;);
        if (property.contains(&quot;Mac&quot;)) {
            log.info(&quot;当前操作系统是：Mac OS X&quot;);
            return true;
        }
        return false;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;测试类测试&quot;&gt;4、测试类测试&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * @author xub
 * @date 2019/6/13 下午10:42
 */
@SpringBootTest(classes = Application.class)
@RunWith(SpringRunner.class)
public class TestConditionOn {

    @Autowired
    private SystemBean windows;
    @Autowired
    private SystemBean mac;

    @Test
    public void test() {
        if (windows != null) {
            System.out.println(&quot;windows = &quot; + windows);
        }
        if (mac != null) {
            System.out.println(&quot;linux = &quot; + mac);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;运行结果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201906/1090617-20190613233252721-1485656376.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过运行结果可以看出&lt;/p&gt;
&lt;p&gt;1、虽然配置两个Bean,但这里只实例化了一个Bean,因为我这边是Mac电脑，所以实例化的是mac的SystemBean&lt;/p&gt;
&lt;p&gt;2、注意一点，我们可以看出 &lt;code&gt;window&lt;/code&gt;并不为null,而是mac实例化的Bean。说明 只要实例化一个Bean的，不管你命名什么，都可以注入这个Bean。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;修改一下&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里做一个修改,我们把&lt;code&gt;ConditionalConfig&lt;/code&gt;中的这行代码注释掉。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// @Conditional({WindowsCondition.class})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;再运行下代码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201906/1090617-20190613233302198-726700849.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过运行结果可以看出，配置类的两个Bean都已经注入成功了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;注意&lt;/code&gt; 当同一个对象被注入两次及以上的时候，那么你在使用当前对象的时候，名称一定要是两个bean名称的一个,否则报错。比如修改为&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @Autowired
    private SystemBean windows;
    @Autowired
    private SystemBean mac;
    @Autowired
    private SystemBean linux;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在启动发现，报错了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201906/1090617-20190613233311255-2070563849.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;意思很明显，就是上面只实例化成功一个SystemBean的时候，你取任何名字，反正就是把当前已经实例化的对象注入给你就好了。&lt;br/&gt;但是你现在同时注入了两个SystemBean,你这个时候有个名称为linux，它不知道应该注入那个Bean,所以采用了报错的策略。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;GitHub源码&lt;/code&gt; &lt;a href=&quot;https://github.com/yudiandemingzi/SpringBootBlog&quot; class=&quot;uri&quot;&gt;https://github.com/yudiandemingzi/SpringBootBlog&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;项目名称&lt;/strong&gt; 03-conditional&lt;/p&gt;

&lt;h3 id=&quot;参考&quot;&gt;&lt;span&gt;参考&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/xcy1193068639/article/details/81491071&quot;&gt;1、Spring @Conditional注解&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;只要自己变优秀了，其他的事情才会跟着好起来（中将3）&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 13 Jun 2019 15:41:00 +0000</pubDate>
<dc:creator>雨点的名字</dc:creator>
<og:description>SpringBoot(15)—@Conditional注解 @Conditional是Spring4新提供的注解，它的作用是按照一定的条件进行判断，满足条件的才给容器注册Bean。 一、概述 1、@C</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qdhxhz/p/11020434.html</dc:identifier>
</item>
<item>
<title>从零到一带你手写基于Redis的分布式锁框架 - 像风一样i</title>
<link>http://www.cnblogs.com/yueshutong/p/11020223.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yueshutong/p/11020223.html</guid>
<description>&lt;h2 id=&quot;分布式锁缘由&quot;&gt;1.分布式锁缘由&lt;/h2&gt;
&lt;p&gt;学习编程初期，我们做的诸如教务系统、成绩管理系统大多是单机架构，单机架构在处理并发的问题上一般是依赖于JDK内置的并发编程类库，如synchronize关键字、Lock类等。随着业务以及需求的提高，单机架构不再满足我们的要求，这个时候我们不免要进行业务上的分离，例如基于Maven进行多模块开发。业务与业务分离之后，遇到的首要问题就是业务之间如何进行通信，相信会有不少读者了解诸如Dubbo、SpringCloud之类的RPC框架，但这些RPC框架并没有自带处理分布式并发问题的功能，所以，分布式并发问题还需要我们自己去实现分布式锁。&lt;/p&gt;
&lt;h2 id=&quot;分布式锁条件&quot;&gt;2.分布式锁条件&lt;/h2&gt;
&lt;p&gt;为了确保分布式锁可用，我们至少要确保锁的实现同时满足以下四个条件：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;互斥性。在任意时刻，只有一个客户端能持有锁。&lt;/li&gt;
&lt;li&gt;不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。&lt;/li&gt;
&lt;li&gt;具有容错性。只要大部分的Redis节点正常运行，客户端就可以加锁和解锁。&lt;/li&gt;
&lt;li&gt;解铃还须系铃人。加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;分布式锁方式&quot;&gt;3.分布式锁方式&lt;/h2&gt;
&lt;p&gt;分布式锁一般有三种实现方式：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;数据库乐观锁&lt;/li&gt;
&lt;li&gt;基于Redis的分布式锁&lt;/li&gt;
&lt;li&gt;基于Zookeeper的分布式锁&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;下面我按个提一下这三种方式的大致实现思路。&lt;/p&gt;
&lt;h3 id=&quot;数据库乐观锁&quot;&gt;3.1 数据库乐观锁&lt;/h3&gt;
&lt;p&gt;数据库乐观锁的实现方式是先使用SELECT语句查询某字段的值（版本号），该字段即理解为要获取的分布式锁。然后在使用UPDATE语句对正常业务数据进行更新，在UPDATE语句执行时一定要用WHERE条件对版本号进行判断，若版本号在这段时间内并没有发生变化则该语句默认执行成功，否则循环执行即可。&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;select (status,version) from goods where id=#{id}

update goods set status=2,version=version+1 where id=#{id} and version=#{version};&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;基于zookeeper的分布式锁&quot;&gt;3.2 基于Zookeeper的分布式锁&lt;/h3&gt;
&lt;p&gt;基于Zookeeper实现分布式锁的算法思路大致如下假设锁空间的根节点为/lock：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;客户端连接zookeeper，并在/lock下创建临时的且有序的子节点，第一个客户端对应的子节点为/lock/lock-0000000000，第二个为/lock/lock-0000000001，以此类推。&lt;/li&gt;
&lt;li&gt;客户端获取/lock下的子节点列表，判断自己创建的子节点是否为当前子节点列表中序号最小的子节点，如果是则认为获得锁，否则监听/lock的子节点变更消息，获得子节点变更通知后重复此步骤直至获得锁。&lt;/li&gt;
&lt;li&gt;执行业务代码。&lt;/li&gt;
&lt;li&gt;完成业务流程后，删除对应的子节点释放锁。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;基于redis的分布式锁&quot;&gt;3.3 基于Redis的分布式锁&lt;/h3&gt;
&lt;p&gt;基于Redis的分布式锁实现是基于Redis自带的 setnx 命令。该命令只有在要设置的字段不存在的情况下才能设置成功，也就是获得分布式锁，否则失败。为了防止客户端异常导致的锁未释放问题，还需要对该字段设置过期时间。&lt;/p&gt;
&lt;p&gt;本文将基于Redis分布式锁的实现思路设计一个spring-boot-starter-redis-lock框架。&lt;/p&gt;
&lt;p&gt;核心代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.data.redis.core.script.DefaultRedisScript;
import org.springframework.stereotype.Component;

import java.util.Arrays;
import java.util.concurrent.TimeUnit;

@Component
public class RedisLock {
    @Autowired
    private StringRedisTemplate template;
    @Autowired
    private DefaultRedisScript&amp;lt;Long&amp;gt; redisScript;

    private static final Long RELEASE_SUCCESS = 1L;

    private long timeout = 3000;

    public boolean lock(String key, String value) {
        //执行set命令
        Boolean absent = template.opsForValue().setIfAbsent(key, value, timeout, TimeUnit.MILLISECONDS);//1
        //其实没必要判NULL，这里是为了程序的严谨而加的逻辑
        if (absent == null) {
            return false;
        }
        //是否成功获取锁
        return true;
    }

    public boolean unlock(String key, String value) {
        //使用Lua脚本：先判断是否是自己设置的锁，再执行删除
        Long result = template.execute(redisScript, Arrays.asList(key,value));
        //返回最终结果
        return RELEASE_SUCCESS.equals(result);
    }

    public void setTimeout(long timeout) {
        this.timeout = timeout;
    }

    @Bean
    public DefaultRedisScript&amp;lt;Long&amp;gt; defaultRedisScript() {
        DefaultRedisScript&amp;lt;Long&amp;gt; defaultRedisScript = new DefaultRedisScript&amp;lt;&amp;gt;();
        defaultRedisScript.setResultType(Long.class);
        defaultRedisScript.setScriptText(&quot;if redis.call('get', KEYS[1]) == KEYS[2] then return redis.call('del', KEYS[1]) else return 0 end&quot;);
        return defaultRedisScript;
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行上面的setIfAbsent()方法就只会导致两种结果：1. 当前没有锁（key不存在），那么就进行加锁操作，并对锁设置个有效期，同时value表示加锁的客户端。2. 已有锁存在，不做任何操作。&lt;/p&gt;
&lt;p&gt;回顾上面提到的分布式锁的四个条件，在任意时刻，该代码都能保证只有一个客户端能持有锁，并且每一个分布式锁都加了过期时间，保证不会出现死锁，容错性暂时不考虑的话，加锁和解锁通过key保证了对多个客户端而言都是同一把锁，value的作用则是保证对同一把锁的加锁和解锁操作都是同一个客户端。&lt;/p&gt;
&lt;h2 id=&quot;为什么上述方案不够好&quot;&gt;4.为什么上述方案不够好&lt;/h2&gt;
&lt;p&gt;为了理解我们想要提高的到底是什么，我们先看下当前大多数基于Redis的分布式锁三方库的现状。 用Redis来实现分布式锁最简单的方式就是在实例里创建一个键值，创建出来的键值一般都是有一个超时时间的（这个是Redis自带的超时特性），所以每个锁最终都会释放（参见前文属性2）。而当一个客户端想要释放锁时，它只需要删除这个键值即可。 表面来看，这个方法似乎很管用，但是这里存在一个问题：在我们的系统架构里存在一个单点故障，如果Redis的master节点宕机了怎么办呢？有人可能会说：加一个slave节点！在master宕机时用slave就行了！但是其实这个方案明显是不可行的，因为这种方案无法保证第1个安全互斥属性，因为Redis的复制是异步的。 总的来说，这个方案里有一个明显的竞争条件（race condition），举例来说：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;客户端A在master节点拿到了锁。&lt;/li&gt;
&lt;li&gt;master节点在把A创建的key写入slave之前宕机了。&lt;/li&gt;
&lt;li&gt;slave变成了master节点&lt;/li&gt;
&lt;li&gt;B也得到了和A还持有的相同的锁（因为原来的slave里还没有A持有锁的信息）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;当然，在某些特殊场景下，前面提到的这个方案则完全没有问题，比如在宕机期间，多个客户端允许同时都持有锁，如果你可以容忍这个问题的话，那用这个基于复制的方案就完全没有问题，否则的话我还是建议你对上述方案进行改进。比如，考虑使用Redlock算法。&lt;/p&gt;
&lt;h2 id=&quot;redlock算法&quot;&gt;5.Redlock算法&lt;/h2&gt;
&lt;p&gt;在分布式版本的算法里我们假设我们有N个Redis master节点，这些节点都是完全独立的，我们不用任何复制或者其他隐含的分布式协调算法。我们已经描述了如何在单节点环境下安全地获取和释放锁。因此我们理所当然地应当用这个方法在每个单节点里来获取和释放锁。在我们的例子里面我们把N设成5，这个数字是一个相对比较合理的数值，因此我们需要在不同的计算机或者虚拟机上运行5个master节点来保证他们大多数情况下都不会同时宕机。一个客户端需要做如下操作来获取锁：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;获取当前时间（单位是毫秒）。&lt;/li&gt;
&lt;li&gt;轮流用相同的key和随机值在N个节点上请求锁，在这一步里，客户端在每个master上请求锁时，会有一个和总的锁释放时间相比小的多的超时时间。比如如果锁自动释放时间是10秒钟，那每个节点锁请求的超时时间可能是5-50毫秒的范围，这个可以防止一个客户端在某个宕掉的master节点上阻塞过长时间，如果一个master节点不可用了，我们应该尽快尝试下一个master节点。&lt;/li&gt;
&lt;li&gt;客户端计算第二步中获取锁所花的时间，只有当客户端在大多数master节点上成功获取了锁（在这里是3个），而且总共消耗的时间不超过锁释放时间，这个锁就认为是获取成功了。&lt;/li&gt;
&lt;li&gt;如果锁获取成功了，那现在锁自动释放时间就是最初的锁释放时间减去之前获取锁所消耗的时间。&lt;/li&gt;
&lt;li&gt;如果锁获取失败了，不管是因为获取成功的锁不超过一半（N/2+1)还是因为总消耗时间超过了锁释放时间，客户端都会到每个master节点上释放锁，即便是那些他认为没有获取成功的锁。&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;本文代码仓库：https://github.com/yueshutong/spring-boot-starter-redis-lock&lt;/p&gt;
&lt;p&gt;参考文章：https://www.cnblogs.com/ironPhoenix/p/6048467.html&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 13 Jun 2019 14:52:00 +0000</pubDate>
<dc:creator>像风一样i</dc:creator>
<og:description>1.分布式锁缘由 学习编程初期，我们做的诸如教务系统、成绩管理系统大多是单机架构，单机架构在处理并发的问题上一般是依赖于JDK内置的并发编程类库，如synchronize关键字、Lock类等。随着业务</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yueshutong/p/11020223.html</dc:identifier>
</item>
<item>
<title>008.MongoDB分片群集概念及原理 - 木二</title>
<link>http://www.cnblogs.com/itzgr/p/11019870.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/itzgr/p/11019870.html</guid>
<description>&lt;h2 align=&quot;left&quot;&gt;一 MongoDB分片介绍&lt;/h2&gt;
&lt;h3 align=&quot;left&quot;&gt;1.1 分片&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;Mongodb另一种集群，就是分片技术，可以满足MongoDB数据量大量增长的需求。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当MongoDB存储海量的数据时，一台机器可能不足以存储数据，也可能不足以提供可接受的读写吞吐量。这时，可通过在多台机器上分割数据，使得数据库系统能存储和处理更多的数据。即通过分片进行水平扩展。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;延伸：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;复制与分片的区别：复制时让多台服务器都拥有同样的数据副本，每一台服务器都是其他服务器的镜像，而每一个分片都和其他分片拥有不同的数据子集。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;1.2 为什么使用分片&lt;/h3&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;复制所有的写入操作到主节点&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;延迟的敏感数据会在主节点查询&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;单个副本集限制在12个节点&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;当请求量巨大时会出现内存不足。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;本地磁盘不足&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;垂直扩展价格昂贵&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;h3 align=&quot;left&quot;&gt;1.3 分片的优势&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;分片为应对高吞吐量与大数据量提够了方法：&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;使用分片减少了每个分片需要处理的请求数：通过水平扩展，群集可以提高自己的存储容量。比如，当插入一条数据时，应用只需要访问存储这条数据的分片。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;使用分片减少了每个分片存储的数据：分片的优势在于提供类似线性增长的架构，提高数据可用性，提高大型数据库查询服务器的性能。当MongoDB单点数据库服务器存储成为瓶颈、单点数据库服务器的性能成为瓶颈或需要部署大型应用以充分利用内存时，可以使用分片技术。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;h2 align=&quot;left&quot;&gt;二 MongoDB分片架构&lt;/h2&gt;
&lt;h3 align=&quot;left&quot;&gt;2.1 主要组件&lt;/h3&gt;
&lt;div align=&quot;center&quot;&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/680719/201906/680719-20190613220354039-1686810377.jpg&quot;&gt;&lt;img title=&quot;001&quot; src=&quot;https://img2018.cnblogs.com/blog/680719/201906/680719-20190613220354721-338617158.jpg&quot; alt=&quot;001&quot; width=&quot;603&quot; height=&quot;427&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;Shard：用于存储实际的数据块，实际生产环境中一个shard server角色可由几台机器组个一个replica set承担，防止主机单点故障。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Config Server：mongod实例，存储了整个 ClusterMetadata，其中包括 chunk信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Query Routers：前端路由，客户端由此接入，且让整个集群看上去像单一数据库，前端应用可以透明使用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;数据划分&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;MongoDB的数据划分，是以集合级别为标准。分片通过shard key来划分集合数据。&lt;/span&gt;&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;2.2 shard key&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;在集合中分发文档，MongoDB使用shard key对进行进行分片。shard key既可以是集合的每个文档的索引字段也可以是集合中每个文档都有的组合索引字段。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;MongoDB将shard keys值按照块（chunks）划分，并且均匀的将这些chunks分配到各个分片上。MongoDB使用基于范围划分或基于散列划分来划分chunks的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意：确定shard key时需要谨慎，以确保集群性能和效率。分片后不能更改shard key，也不能取消分片。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;2.3 分片集和非分片集&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;数据库可以混合使用分片和非分片集合。分片集合在集群中的分片上进行分区和分布，非分片集合存储在主分片上，每个数据库都有自己的主分片。&lt;/span&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/680719/201906/680719-20190613220355112-1646481676.png&quot;&gt;&lt;img title=&quot;026&quot; src=&quot;https://img2018.cnblogs.com/blog/680719/201906/680719-20190613220355393-1067981728.png&quot; alt=&quot;026&quot; width=&quot;379&quot; height=&quot;410&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;h3 align=&quot;left&quot;&gt;2.4 分片集连接&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;可以使用与连接到单个mongos相同的方式连接分片集mongod，如通过mongoshell或MongoDB 驱动程序。但必须连接到mongos路由器，才能与分片集群中的任何集合进行交互。这包括分片和非分片集合，客户端永远不应连接到单个分片以执行读取或写入操作。&lt;/span&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/680719/201906/680719-20190613220355965-1154735372.png&quot;&gt;&lt;img title=&quot;027&quot; src=&quot;https://img2018.cnblogs.com/blog/680719/201906/680719-20190613220356592-845191704.png&quot; alt=&quot;027&quot; width=&quot;683&quot; height=&quot;363&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;h2 align=&quot;left&quot;&gt;三 分片策略&lt;/h2&gt;
&lt;h3 align=&quot;left&quot;&gt;3.1 基于范围划分&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;MongoDB通过shard key值将数据集划分到不同的范围就称为基于范围划分。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于数值型的shard key：可以虚构一条从负无穷到正无穷的直线（理解为x轴），每个shard key 值都落在这条直线的某个点上，然后MongoDB把这条线划分为许多更小的没有重复的范围成为块（chunks），一个chunk就是某些最小值到最大值的范围。&lt;/span&gt;&lt;/p&gt;
&lt;div align=&quot;left&quot;&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/680719/201906/680719-20190613220358288-949735697.png&quot;&gt;&lt;img title=&quot;028&quot; src=&quot;https://img2018.cnblogs.com/blog/680719/201906/680719-20190613220359346-187626484.png&quot; alt=&quot;028&quot; width=&quot;1927&quot; height=&quot;580&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;h3 align=&quot;left&quot;&gt;3.2 基于散列划分&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;MongoDB计算每个字段的hash值，然后用这些hash值建立chunks。基于散列值的数据分布有助于更均匀的数据分布，尤其是在shard key单调变化的数据集中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是，散列分布意味着对shard key的基于范围的查询不太可能以单个分片为目标，从而导致更多群集范围的广播操作。&lt;/span&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/680719/201906/680719-20190613220400378-1785640160.png&quot;&gt;&lt;img title=&quot;029&quot; src=&quot;https://img2018.cnblogs.com/blog/680719/201906/680719-20190613220401302-131350099.png&quot; alt=&quot;029&quot; width=&quot;1659&quot; height=&quot;554&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;基于范围和基于散列划分的性能比较：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;基于范围划分对于范围查询比较高效。假设在shard key上进行范围查询，查询路由很容易能够知道哪些块与这个范围重叠，然后把相关查询按照这个路线发送到仅仅包含这些chunks的分片。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是基于范围划分很容易导致数据不均匀分布，这样会削弱分片集群的功能。例如当shard key是个成直线上升的字段，如时间。那么，所有在给定时间范围内的请求都会映射到相同的chunk，也就是相同的分片上。这种情况下，小部分的分片将会承受大多数的请求，那么系统整体扩展并不理想。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;相反的，基于散列划分是以牺牲高效范围查询为代价，它能够均匀的分布数据，散列值能够保证数据随机分布到各个分片上。&lt;/span&gt;&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;3.3 自定义标签划分&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;MongoDB支持通过自定义标签标记分片的方式直接平衡数据分布策略，可以创建标签并且将它们与shard key值的范围进行关联，然后分配这些标签到各个分片上，最终平衡器转移带有标签标记的数据到对应的分片上，确保集群总是按标签描述的那样进行数据分布。标签是控制平衡器行为及集群中块分布的主要方法。&lt;/span&gt;&lt;/p&gt;
&lt;h2 align=&quot;left&quot;&gt;四 数据均衡&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;新加入的数据及服务器都会导致集群数据分布不平衡，MongoDB采用两种方式确保数据分布的平衡：&lt;/span&gt;&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;4.1 拆分&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;拆分是一个后台进程，防止块变得太大。当一个块增长到指定块大小的时候，拆分进程就会块一分为二，整个拆分过程是高效的。不会涉及到数据的迁移等操作。&lt;/span&gt;&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;4.2 平衡&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;平衡器是一个后台进程，管理块的迁移。平衡器能够运行在集群任何的mongd实例上。当集群中数据分布不均匀时，平衡器就会将某个分片中比较多的块迁移到拥有块较少的分片中，直到数据分片平衡为止。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;举个例子：如果集合users有100个块在分片1里，50个块在分片2中，那么平衡器就会将分片1中的块迁移到分片2中，直到维持平衡。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;分片采用后台操作的方式管理着源分片和目标分片之间块的迁移。在迁移的过程中，源分片中的块会将所有文档发送到目标分片中，然后目标分片会获取并应用这些变化。最后，更新配置服务器上关于块位置元数据。&lt;/span&gt;&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;4.3 从集群中增加和删除分片&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;添加新分片到集群中会产生数据不平衡，因为新分片中没有块，当MongoDB开始迁移数据到新分片中时，等到数据分片平衡需要一定时间。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当删除一个分片时，平衡器将会把分片中所有块迁移到另一个分片中，在完成这些迁移并更新元数据后，才可安全的删除分片了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;更多分片参考官方：https://docs.mongodb.com/manual/sharding/#sharding-strategy&lt;/span&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/680719/201906/680719-20190613220402261-384898969.png&quot;&gt;&lt;img title=&quot;030&quot; src=&quot;https://img2018.cnblogs.com/blog/680719/201906/680719-20190613220402966-95027380.png&quot; alt=&quot;030&quot; width=&quot;600&quot; height=&quot;411&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;相关参考：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;https://blog.51cto.com/13643643/2148825&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;https://www.cnblogs.com/Jtianlin/p/5128977.html&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;https://www.jianshu.com/p/cb55bb333e2d&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 13 Jun 2019 14:04:00 +0000</pubDate>
<dc:creator>木二</dc:creator>
<og:description>一 MongoDB分片介绍 1.1 分片 Mongodb另一种集群，就是分片技术，可以满足MongoDB数据量大量增长的需求。 当MongoDB存储海量的数据时，一台机器可能不足以存储数据，也可能不足</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/itzgr/p/11019870.html</dc:identifier>
</item>
</channel>
</rss>