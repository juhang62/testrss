<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>blfs学习笔记-制作一个简单的桌面系统 - 仁人</title>
<link>http://www.cnblogs.com/renren-study-notes/p/10325336.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/renren-study-notes/p/10325336.html</guid>
<description>&lt;p&gt;大概思路：&lt;/p&gt;
&lt;p&gt;lfs（系统）+xorg（驱动）+i3-wm（窗口+桌面）+lightdm（显示管理器+登录管理器）&lt;/p&gt;
&lt;p&gt;链接：&lt;/p&gt;
&lt;p&gt;lfs学习笔记系列：&lt;a href=&quot;https://www.cnblogs.com/renren-study-notes/p/10199344.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/renren-study-notes/p/10199344.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;                            &lt;a href=&quot;https://www.cnblogs.com/renren-study-notes/p/10199381.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/renren-study-notes/p/10199381.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;                            &lt;a href=&quot;https://www.cnblogs.com/renren-study-notes/p/10199965.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/renren-study-notes/p/10199965.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;                           &lt;a target=&quot;_blank&quot;&gt; https://www.cnblogs.com/renren-study-notes/p/10279446.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;blfs书籍内容的学习笔记：&lt;/p&gt;
&lt;p&gt;总页：&lt;a href=&quot;https://www.cnblogs.com/renren-study-notes/p/10214504.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/renren-study-notes/p/10214504.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;前几章节的脚本：&lt;a href=&quot;https://www.cnblogs.com/renren-study-notes/p/10287905.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/renren-study-notes/p/10287905.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;构建xorg：&lt;a href=&quot;https://www.cnblogs.com/renren-study-notes/p/10291901.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/renren-study-notes/p/10291901.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;构建i3-wm：&lt;a href=&quot;https://www.cnblogs.com/renren-study-notes/p/10309977.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/renren-study-notes/p/10309977.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;构建lightdm：&lt;a href=&quot;https://www.cnblogs.com/renren-study-notes/p/10325321.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/renren-study-notes/p/10325321.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 26 Jan 2019 15:49:00 +0000</pubDate>
<dc:creator>仁人</dc:creator>
<og:description>大概思路： lfs（系统）+xorg（驱动）+i3-wm（窗口+桌面）+lightdm（显示管理器+登录管理器） 链接： lfs学习笔记系列：https://www.cnblogs.com/renre</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/renren-study-notes/p/10325336.html</dc:identifier>
</item>
<item>
<title>iOS学小程序从0到发布(适合iOS开发看) - 二进制||</title>
<link>http://www.cnblogs.com/wangcongiOS/p/10325325.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangcongiOS/p/10325325.html</guid>
<description>&lt;p&gt;Emmmm，最近一波失业潮。富某康、某团、摩某、京某、知某、某浪、58 某大面积裁员，那么在这个千钧一发之际，单纯iOS开发也着实不好过，回过头看一下，裁掉的都是单一选手，为了节约成本公司留下的都是身兼多职的全栈开发工程师。&lt;/p&gt;
&lt;p&gt;那么iOS, 有些选手就要找对方向再学一手以备下次被裁员的不是自己。HTML，CSS, JS,小程序，React， React Native浮现在选手面前。 好，进入正题，今天开始从0入门小程序。咦，等等，为什么叫选手呢，因为当前环境下经济不景气都是去竞争口饭吃的，就像是在比赛，故本文称之为选手。&lt;/p&gt;
&lt;p&gt;首先，学习小程序开发对于学习iOS开发成本实在是低，低到什么程度呢？低到你单看这篇文章就可以开发并发布小程序。&lt;/p&gt;
&lt;p&gt;一：小程序注册&lt;/p&gt;
&lt;p&gt;注册小程序帐号&lt;/p&gt;
&lt;p&gt;在微信公众平台官网首页（&lt;a href=&quot;https://mp.weixin.qq.com/&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;mp.weixin.qq.com&lt;/a&gt;）点击右上角的“立即注册”按钮。&lt;/p&gt;
&lt;p&gt;关于小程序账号注册填写从相关的各位选手可以去微信公众平台自己看官方文档这里不做详细介绍&lt;a href=&quot;https://developers.weixin.qq.com/miniprogram/introduction/index.html&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;https://developers.weixin.qq.com/miniprogram/introduction/index.html&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;980&quot; data-height=&quot;473&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3467163-cae3ca9a5da76e8c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/980/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3467163-cae3ca9a5da76e8c.png&quot; data-original-width=&quot;980&quot; data-original-height=&quot;473&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;378207&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;image&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;二：这篇文章重点要介绍的是开发工具和代码方面的知识。&lt;/p&gt;
&lt;p&gt;微信开发工具下载地址:&lt;a href=&quot;https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;那么现在我已经下载好了&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;966&quot; data-height=&quot;1328&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3467163-26b89855a7215801.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/966/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3467163-26b89855a7215801.png&quot; data-original-width=&quot;966&quot; data-original-height=&quot;1328&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;966916&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;image&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;点击小程序项目，进入&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1252&quot; data-height=&quot;948&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3467163-ca0c1b75cc4a0d0f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3467163-ca0c1b75cc4a0d0f.png&quot; data-original-width=&quot;1252&quot; data-original-height=&quot;948&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;202421&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;image&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;如图，我这是之前已经创建好的项目，会显示在图上右边，如果是本地没有小程序项目，则创建就可以了，相信我们的iOS开发们这些都不是事，emm不行，怕有些 人还是不会，老规矩上图&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1930&quot; data-height=&quot;1396&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3467163-142e637fc98838de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3467163-142e637fc98838de.png&quot; data-original-width=&quot;1930&quot; data-original-height=&quot;1396&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;614139&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;image&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;好，终于看到代码了，到这里才是本文接下来要讲的重点。&lt;/p&gt;
&lt;p&gt;先来看下我们今天要实现的效果。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;320&quot; data-height=&quot;618&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3467163-c85e9fe02e663ea9.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/320/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3467163-c85e9fe02e663ea9.gif&quot; data-original-width=&quot;320&quot; data-original-height=&quot;618&quot; data-original-format=&quot;image/gif&quot; data-original-filesize=&quot;2318102&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;image&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;再来整体看下代码架构&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;2572&quot; data-height=&quot;1714&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3467163-79b291a25827f45b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3467163-79b291a25827f45b.png&quot; data-original-width=&quot;2572&quot; data-original-height=&quot;1714&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;517091&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;image&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;先来看四种文件，.js, .json,.wxss,.wxml。&lt;/p&gt;
&lt;p&gt;.js处理逻辑，数据，获取网络请求的数据即在这里面&lt;/p&gt;
&lt;p&gt;.json 配置文件，比如tabbar的配置，navigationbar的配置等&lt;/p&gt;
&lt;p&gt;.wxml创建的控件，比如view，button，map组件&lt;/p&gt;
&lt;p&gt;.wxss控件的修饰，比如frame，backgroudcolor等&lt;/p&gt;
&lt;p&gt;看到这里是不是感觉有点跟MVVM设计模式相似呀,不同功能的代码分文件来写，一目了然。&lt;/p&gt;
&lt;p&gt;好，先看示例首页搜索页面的输入框。&lt;/p&gt;
&lt;p&gt;.wxml里&lt;/p&gt;
&lt;pre class=&quot;hljs xml&quot;&gt;
&lt;code class=&quot;xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;input &lt;span class=&quot;hljs-attr&quot;&gt;class=&lt;span class=&quot;hljs-string&quot;&gt;&quot;searchPut&quot; &lt;span class=&quot;hljs-attr&quot;&gt;bindconfirm=&lt;span class=&quot;hljs-string&quot;&gt;&quot;shouldDone&quot; &lt;span class=&quot;hljs-attr&quot;&gt;placeholder=&lt;span class=&quot;hljs-string&quot;&gt;&quot;输入来搜索🔍&quot; &lt;span class=&quot;hljs-attr&quot;&gt;type=&lt;span class=&quot;hljs-string&quot;&gt;&quot;text&quot; &lt;span class=&quot;hljs-attr&quot;&gt;confirm-type=&lt;span class=&quot;hljs-string&quot;&gt;&quot;Search&quot;&amp;gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;input&amp;gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;view &lt;span class=&quot;hljs-attr&quot;&gt;class=&lt;span class=&quot;hljs-string&quot;&gt;&quot;table&quot;&amp;gt;
  &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;view &lt;span class=&quot;hljs-attr&quot;&gt;class=&lt;span class=&quot;hljs-string&quot;&gt;'contentview' &lt;span class=&quot;hljs-attr&quot;&gt;wx:for=&lt;span class=&quot;hljs-string&quot;&gt;&quot;{{searchResults}}&quot; &lt;span class=&quot;hljs-attr&quot;&gt;wx:for-index=&lt;span class=&quot;hljs-string&quot;&gt;&quot;bindex&quot;&amp;gt;
   &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;view &lt;span class=&quot;hljs-attr&quot;&gt;class=&lt;span class=&quot;hljs-string&quot;&gt;&quot;listitem&quot;  &lt;span class=&quot;hljs-attr&quot;&gt;bindtap=&lt;span class=&quot;hljs-string&quot;&gt;'didSelectCell'  &lt;span class=&quot;hljs-attr&quot;&gt;data-bindex=&lt;span class=&quot;hljs-string&quot;&gt;'{{bindex}}'&amp;gt;
     &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;image &lt;span class=&quot;hljs-attr&quot;&gt;class=&lt;span class=&quot;hljs-string&quot;&gt;&quot;img&quot; &lt;span class=&quot;hljs-attr&quot;&gt;src=&lt;span class=&quot;hljs-string&quot;&gt;&quot;{{item.cover_path}}&quot;&amp;gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;image&amp;gt;
      &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;view &lt;span class=&quot;hljs-attr&quot;&gt;class=&lt;span class=&quot;hljs-string&quot;&gt;&quot;right&quot;&amp;gt;
          &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;view &lt;span class=&quot;hljs-attr&quot;&gt;class=&lt;span class=&quot;hljs-string&quot;&gt;&quot;name&quot;&amp;gt;{{item.title}}&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;view&amp;gt;
          &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;view &lt;span class=&quot;hljs-attr&quot;&gt;class=&lt;span class=&quot;hljs-string&quot;&gt;&quot;nameDes&quot;&amp;gt;{{item.intro}}&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;view&amp;gt;
          &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;view &lt;span class=&quot;hljs-attr&quot;&gt;class=&lt;span class=&quot;hljs-string&quot;&gt;&quot;bottomView&quot;&amp;gt;
           &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;view &lt;span class=&quot;hljs-attr&quot;&gt;class=&lt;span class=&quot;hljs-string&quot;&gt;'playtimes'&amp;gt;播放次数:{{item.play}}&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;view&amp;gt;
           &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;view &lt;span class=&quot;hljs-attr&quot;&gt;class=&lt;span class=&quot;hljs-string&quot;&gt;'length'&amp;gt;总共:{{item.tracks}}集&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;view&amp;gt;
          &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;view&amp;gt;
      &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;view&amp;gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;view&amp;gt;
  &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;view&amp;gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;view&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如图不同颜色框对应不同UI组件&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;2742&quot; data-height=&quot;1388&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3467163-13733bba12ac812f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3467163-13733bba12ac812f.png&quot; data-original-width=&quot;2742&quot; data-original-height=&quot;1388&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;754265&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;image.png&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;.wxss&lt;/p&gt;
&lt;pre class=&quot;hljs css&quot;&gt;
&lt;code class=&quot;css&quot;&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.searchPut
{
  &lt;span class=&quot;hljs-attribute&quot;&gt;margin-left: &lt;span class=&quot;hljs-number&quot;&gt;20rpx;
  &lt;span class=&quot;hljs-attribute&quot;&gt;margin-right: &lt;span class=&quot;hljs-number&quot;&gt;20rpx;
  &lt;span class=&quot;hljs-attribute&quot;&gt;height: &lt;span class=&quot;hljs-number&quot;&gt;60rpx;
  &lt;span class=&quot;hljs-attribute&quot;&gt;border: &lt;span class=&quot;hljs-number&quot;&gt;2rpx ridge black;
}

&lt;span class=&quot;hljs-selector-class&quot;&gt;.table
{
  &lt;span class=&quot;hljs-attribute&quot;&gt;top: &lt;span class=&quot;hljs-number&quot;&gt;80rpx;
  &lt;span class=&quot;hljs-attribute&quot;&gt;width: &lt;span class=&quot;hljs-number&quot;&gt;100vw;
  &lt;span class=&quot;hljs-attribute&quot;&gt;margin-bottom: &lt;span class=&quot;hljs-number&quot;&gt;0rpx;
}

&lt;span class=&quot;hljs-selector-class&quot;&gt;.contentview
{
  &lt;span class=&quot;hljs-attribute&quot;&gt;padding: &lt;span class=&quot;hljs-number&quot;&gt;0;
}

&lt;span class=&quot;hljs-selector-class&quot;&gt;.listitem{  
  &lt;span class=&quot;hljs-attribute&quot;&gt;display: flex;  
  &lt;span class=&quot;hljs-attribute&quot;&gt;flex-direction: row;  
  &lt;span class=&quot;hljs-attribute&quot;&gt;padding:&lt;span class=&quot;hljs-number&quot;&gt;20rpx;  
}

&lt;span class=&quot;hljs-selector-class&quot;&gt;.img
{
  &lt;span class=&quot;hljs-attribute&quot;&gt;width: &lt;span class=&quot;hljs-number&quot;&gt;100rpx;
  &lt;span class=&quot;hljs-attribute&quot;&gt;height: &lt;span class=&quot;hljs-number&quot;&gt;100rpx;
}

&lt;span class=&quot;hljs-selector-class&quot;&gt;.right
{
  &lt;span class=&quot;hljs-attribute&quot;&gt;flex: &lt;span class=&quot;hljs-number&quot;&gt;1;
  &lt;span class=&quot;hljs-attribute&quot;&gt;width: &lt;span class=&quot;hljs-number&quot;&gt;590rpx;  
  &lt;span class=&quot;hljs-attribute&quot;&gt;margin-left: &lt;span class=&quot;hljs-number&quot;&gt;20rpx;  
  &lt;span class=&quot;hljs-attribute&quot;&gt;display: flex;  
  &lt;span class=&quot;hljs-attribute&quot;&gt;flex-direction: column;  
}

&lt;span class=&quot;hljs-selector-class&quot;&gt;.name
{
  &lt;span class=&quot;hljs-attribute&quot;&gt;font-size: &lt;span class=&quot;hljs-number&quot;&gt;35rpx;
}
&lt;span class=&quot;hljs-selector-class&quot;&gt;.nameDes
{
  &lt;span class=&quot;hljs-attribute&quot;&gt;font-size: &lt;span class=&quot;hljs-number&quot;&gt;30rpx;
}

&lt;span class=&quot;hljs-selector-class&quot;&gt;.bottomView
{
  &lt;span class=&quot;hljs-attribute&quot;&gt;flex: &lt;span class=&quot;hljs-number&quot;&gt;1; 
  &lt;span class=&quot;hljs-attribute&quot;&gt;display: flex;  
  &lt;span class=&quot;hljs-attribute&quot;&gt;flex-direction: row;  
  &lt;span class=&quot;hljs-attribute&quot;&gt;justify-content:space-between;
}

&lt;span class=&quot;hljs-selector-class&quot;&gt;.playtimes
{
  &lt;span class=&quot;hljs-attribute&quot;&gt;font-size: &lt;span class=&quot;hljs-number&quot;&gt;30rpx;
  &lt;span class=&quot;hljs-attribute&quot;&gt;color: gray;
  &lt;span class=&quot;hljs-attribute&quot;&gt;vertical-align: center;
}

&lt;span class=&quot;hljs-selector-class&quot;&gt;.length
{
  &lt;span class=&quot;hljs-attribute&quot;&gt;font-size: &lt;span class=&quot;hljs-number&quot;&gt;30rpx;
  &lt;span class=&quot;hljs-attribute&quot;&gt;color: gray;
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;1.searchPut ：margin-left ：距离左边， 那距离右边同理margin-right&lt;br/&gt;讲下border：border: 2rpx ridge black; 代表边框宽2rpx，样式ridge，颜色黑色&lt;br/&gt;2..table： width: 100vw;代表铺满宽，即100%&lt;br/&gt;3..listitem： display：flex；采用flex弹性布局，flex-direction: row; 即竖向布局，即我们熟悉的tableview样式，同理flex-direction: column; 横向布局。padding:20rpx;即向里周边都缩进20rpx&lt;br/&gt;4..bottomView ： justify-content:space-between;justify-content 用于设置或检索弹性盒子元素在主轴（横轴）方向上的对齐方式。&lt;br/&gt;| flex-start | 默认值。项目位于容器的开头。 | &lt;a href=&quot;http://www.runoob.com/try/playit.php?f=playcss_justify-content&amp;amp;preval=flex-start&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;测试 »&lt;/a&gt; |&lt;br/&gt;| flex-end | 项目位于容器的结尾。 | &lt;a href=&quot;http://www.runoob.com/try/playit.php?f=playcss_justify-content&amp;amp;preval=flex-end&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;测试 »&lt;/a&gt; |&lt;br/&gt;| center | 项目位于容器的中心。 | &lt;a href=&quot;http://www.runoob.com/try/playit.php?f=playcss_justify-content&amp;amp;preval=center&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;测试 »&lt;/a&gt; |&lt;br/&gt;| space-between | 项目位于各行之间留有空白的容器内。 | &lt;a href=&quot;http://www.runoob.com/try/playit.php?f=playcss_justify-content&amp;amp;preval=space-between&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;测试 »&lt;/a&gt; |&lt;br/&gt;| space-around | 项目位于各行之前、之间、之后都留有空白的容器内。 | &lt;a href=&quot;http://www.runoob.com/try/playit.php?f=playcss_justify-content&amp;amp;preval=space-around&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;测试 »&lt;/a&gt; |&lt;br/&gt;| initial | 设置该属性为它的默认值。请参阅 &lt;a href=&quot;http://www.runoob.com/cssref/css-initial.html&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;&lt;em&gt;initial&lt;/em&gt;&lt;/a&gt;。 | &lt;a href=&quot;http://www.runoob.com/try/playit.php?f=playcss_justify-content&amp;amp;preval=initial&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;测试 »&lt;/a&gt; |&lt;br/&gt;| inherit | 从父元素继承该属性。请参阅 &lt;a href=&quot;http://www.runoob.com/cssref/css-inherit.html&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;&lt;em&gt;inherit&lt;/em&gt;&lt;/a&gt;。 |&lt;br/&gt;5.其他诸如：color，font-size这些不多做解释。&lt;/p&gt;
&lt;p&gt;下面来到了.js文件有了这一步，咸鱼变活鱼，界面搭好了，就等渠里通水了。&lt;/p&gt;
&lt;pre class=&quot;hljs javascript&quot;&gt;
&lt;code class=&quot;javascript&quot;&gt;age({

  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先输入搜索的内容后，点击搜索，iOS里应该是有个textfieldshouldReturn，这个事件。那么小程序同理，我们之前已经在wxml里绑定过了，那就是bindconfirm=&quot;shouldDone&quot;这行代码，bindconfirm就是这个事件，我们绑定上之后，在js文件里实现这个shouldDone方法，然后再shouldDone方法里进行网络请求去获取数据就好。&lt;/p&gt;
&lt;p&gt;说到网络请求，微信小程序的封装那是厉害的一批，&lt;br/&gt;看图&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1720&quot; data-height=&quot;992&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3467163-8debfffba797f493.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3467163-8debfffba797f493.png&quot; data-original-width=&quot;1720&quot; data-original-height=&quot;992&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;191049&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;image.png&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;wx.request就是调网络请求，url是请求的链接，method是请求的方法get，post。&lt;br/&gt;post需要传参的话下面再加个data参数传进去就好。&lt;br/&gt;success就是请求成功的回调，res就是response，更神奇的是，返回数据的解析如图上：var results = res.data.album.docs; 竟然直接点语法就把json给解析了，如图所示的格式&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;428&quot; data-height=&quot;252&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3467163-1e8772765558ed0f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/428/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3467163-1e8772765558ed0f.png&quot; data-original-width=&quot;428&quot; data-original-height=&quot;252&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;185953&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;image.png&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;是不是太方便了。&lt;br/&gt;有了数据了，下面来处理数据，如图&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;666&quot; data-height=&quot;1120&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3467163-64d95b6adbbfcad0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/666/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3467163-64d95b6adbbfcad0.png&quot; data-original-width=&quot;666&quot; data-original-height=&quot;1120&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;139247&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;image.png&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;播放次数，实际服务器返回的“play”这个字段播放次数是64168345，那我们要转为6416.8万，这该怎么转呢，如果是OC代码那我们就得心应手，但这里是小程序。&lt;br/&gt;首先这是一个列表，每条数据里都有play这个字段，两种方案：1.就是要遍历下数组，然后把数组中的这个字段对应的值做下修改。2.直接在对控件赋值的时候做转换（也就是对应iOS里cellforrow里给控件赋值的时候）。那我们现在wxml里已经写好了，直接取的就是play这个字段的值，并没有做转换，如图&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;872&quot; data-height=&quot;282&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3467163-e12f75f3223bc2a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/872/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3467163-e12f75f3223bc2a1.png&quot; data-original-width=&quot;872&quot; data-original-height=&quot;282&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;71903&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;suo&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;所以我们现在采用第一种方法&lt;/p&gt;
&lt;p&gt;遍历数组&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1506&quot; data-height=&quot;390&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3467163-8b86b8001b44764b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3467163-8b86b8001b44764b.png&quot; data-original-width=&quot;1506&quot; data-original-height=&quot;390&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;192847&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;image.png&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;那么现在数据就修改完了，要显示了&lt;/p&gt;
&lt;pre class=&quot;hljs css&quot;&gt;
&lt;code class=&quot;css&quot;&gt; &lt;span class=&quot;hljs-selector-tag&quot;&gt;that&lt;span class=&quot;hljs-selector-class&quot;&gt;.setData({
          &lt;span class=&quot;hljs-attribute&quot;&gt;searchResults: results,
        })
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这句话就是把我们得到的返回的数据赋值给我们在data里定义的searchResults&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;558&quot; data-height=&quot;304&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3467163-baff713f546cc918.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/558/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3467163-baff713f546cc918.png&quot; data-original-width=&quot;558&quot; data-original-height=&quot;304&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;23162&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;image.png&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;同时，wxml里绑定的searchResults，就会刷新出来界面。&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1684&quot; data-height=&quot;660&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3467163-5647f9246b703ed9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3467163-5647f9246b703ed9.png&quot; data-original-width=&quot;1684&quot; data-original-height=&quot;660&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;186999&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;image.png&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;到此首页搜索界面的实现介绍完毕。下班了，先回家吃饭了，饿死。回来继续&lt;/p&gt;
&lt;p&gt;感谢各位看官！&lt;/p&gt;
&lt;p&gt;代码地址:&lt;a href=&quot;https://git.dev.tencent.com/cong_Wang/xcx.git&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;https://git.dev.tencent.com/cong_Wang/xcx.git&lt;/a&gt;&lt;br/&gt;git clone 即可下载下来代码。&lt;br/&gt;如图：已经下载下来了&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;870&quot; data-height=&quot;854&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3467163-e65e026a7755aa8d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/870/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3467163-e65e026a7755aa8d.png&quot; data-original-width=&quot;870&quot; data-original-height=&quot;854&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;53005&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;image.png&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;那么怎么跑这个代码呢？我们打开微信开发工具，&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1628&quot; data-height=&quot;1104&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3467163-bc87330957280b1e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3467163-bc87330957280b1e.png&quot; data-original-width=&quot;1628&quot; data-original-height=&quot;1104&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;210259&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;image.png&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;点击+号，即新建项目，导入项目，选择代码的目录，选择测试号，即会为你生成一个测试appid，点击导入按钮。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1628&quot; data-height=&quot;1104&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3467163-66859a9bba4780e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3467163-66859a9bba4780e4.png&quot; data-original-width=&quot;1628&quot; data-original-height=&quot;1104&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;118963&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;image.png&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;大功告成，现在就可以跑项目了&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;2048&quot; data-height=&quot;1554&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3467163-a433247b8e0d3230.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3467163-a433247b8e0d3230.png&quot; data-original-width=&quot;2048&quot; data-original-height=&quot;1554&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;250118&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Sat, 26 Jan 2019 15:43:00 +0000</pubDate>
<dc:creator>二进制||</dc:creator>
<og:description>Emmmm，最近一波失业潮。富某康、某团、摩某、京某、知某、某浪、58 某大面积裁员，那么在这个千钧一发之际，单纯iOS开发也着实不好过，回过头看一下，裁掉的都是单一选手，为了节约成本公司留下的都是身</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wangcongiOS/p/10325325.html</dc:identifier>
</item>
<item>
<title>浅析C# Dictionary实现原理 - InCerry</title>
<link>http://www.cnblogs.com/InCerry/p/10325290.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/InCerry/p/10325290.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;

&lt;h2 id=&quot;一前言&quot;&gt;一、前言&lt;/h2&gt;
&lt;p&gt;本篇文章配图以及文字其实整理出来很久了，但是由于各种各样的原因推迟到现在才发出来，还有之前立Flag的《多线程编程》的笔记也都已经写好了，只是说还比较糙，需要找个时间整理一下才能和大家见面。&lt;/p&gt;
&lt;p&gt;对于C#中的&lt;code&gt;Dictionary&lt;/code&gt;类相信大家都不陌生，这是一个&lt;code&gt;Collection(集合)&lt;/code&gt;类型，可以通过&lt;strong&gt;Key/Value(键值对&lt;/strong&gt;的形式来存放数据；该类最大的优点就是它查找元素的时间复杂度接近&lt;code&gt;O(1)&lt;/code&gt;，实际项目中常被用来做一些数据的本地缓存，提升整体效率。&lt;/p&gt;
&lt;p&gt;那么是什么样的设计能使得&lt;code&gt;Dictionary&lt;/code&gt;类能实现&lt;code&gt;O(1)&lt;/code&gt;的时间复杂度呢？那就是本篇文章想和大家讨论的东西；这些都是个人的一些理解和观点，&lt;strong&gt;如有表述不清楚、错误之处，请大家批评指正，共同进步。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;二理论知识&quot;&gt;二、理论知识&lt;/h2&gt;
&lt;p&gt;对于Dictionary的实现原理，其中有两个关键的算法，一个是&lt;strong&gt;Hash&lt;/strong&gt;算法，一个是用于应对Hash碰撞&lt;strong&gt;冲突解决&lt;/strong&gt;算法。&lt;/p&gt;
&lt;h3 id=&quot;hash算法&quot;&gt;1、Hash算法&lt;/h3&gt;
&lt;p&gt;Hash算法是一种&lt;strong&gt;数字摘要&lt;/strong&gt;算法，它能将不定长度的二进制数据集给&lt;strong&gt;映射&lt;/strong&gt;到一个较短的二进制长度数据集，常见的MD5算法就是一种Hash算法，通过MD5算法可对任何数据生成数字摘要。而实现了Hash算法的函数我们叫她&lt;strong&gt;Hash函数&lt;/strong&gt;。Hash函数有以下几点特征。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;相同的数据进行Hash运算，得到的结果一定相同。&lt;code&gt;HashFunc(key1) == HashFunc(key1)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;不同的数据进行Hash运算，其结果也可能会相同，(&lt;strong&gt;Hash会产生碰撞&lt;/strong&gt;)。&lt;code&gt;key1 != key2 =&amp;gt; HashFunc(key1) == HashFunc(key2)&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Hash运算时不可逆的，不能由key获取原始的数据。&lt;code&gt;key1 =&amp;gt; hashCode&lt;/code&gt;但是&lt;code&gt;hashCode =\=&amp;gt; key1&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;下图就是Hash函数的一个简单说明，任意长度的数据通过HashFunc映射到一个较短的数据集中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/997046/201901/997046-20190126232146262-598525962.png&quot; alt=&quot;1548491108167&quot;/&gt;&lt;/p&gt;
&lt;p&gt;关于Hash碰撞下图很清晰的就解释了，可从图中得知&lt;code&gt;Sandra Dee&lt;/code&gt; 和 &lt;code&gt;John Smith&lt;/code&gt;通过hash运算后都落到了&lt;code&gt;02&lt;/code&gt;的位置，产生了碰撞和冲突。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/997046/201901/997046-20190126232145973-1148017578.png&quot; alt=&quot;1548485331574&quot;/&gt;&lt;br/&gt;常见的构造Hash函数的算法有以下几种。&lt;/p&gt;
&lt;blockquote readability=&quot;25&quot;&gt;
&lt;p&gt;&lt;strong&gt;1. 直接寻址法：&lt;/strong&gt;取keyword或keyword的某个线性函数值为散列地址。即H(key)=key或H(key) = a•key + b，当中a和b为常数（这样的散列函数叫做自身函数）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 数字分析法：&lt;/strong&gt;分析一组数据，比方一组员工的出生年月日，这时我们发现出生年月日的前几位数字大体同样，这种话，出现冲突的几率就会非常大，可是我们发现年月日的后几位表示月份和详细日期的数字区别非常大，假设用后面的数字来构成散列地址，则冲突的几率会明显减少。因此数字分析法就是找出数字的规律，尽可能利用这些数据来构造冲突几率较低的散列地址。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 平方取中法：&lt;/strong&gt;取keyword平方后的中间几位作为散列地址。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. 折叠法：&lt;/strong&gt;将keyword切割成位数同样的几部分，最后一部分位数能够不同，然后取这几部分的叠加和（去除进位）作为散列地址。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5. 随机数法：&lt;/strong&gt;选择一随机函数，取keyword的随机值作为散列地址，通经常使用于keyword长度不同的场合。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6. 除留余数法：&lt;/strong&gt;取keyword被某个不大于散列表表长m的数p除后所得的余数为散列地址。即 H(key) = key MOD p, p&amp;lt;=m。不仅能够对keyword直接取模，也可在折叠、平方取中等运算之后取模。对p的选择非常重要，一般取素数或m，若p选的不好，容易产生碰撞.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;hash桶算法&quot;&gt;2、Hash桶算法&lt;/h3&gt;
&lt;p&gt;说到Hash算法大家就会想到&lt;strong&gt;Hash表&lt;/strong&gt;，一个Key通过Hash函数运算后可快速的得到hashCode，通过hashCode的映射可直接Get到Value，但是hashCode一般取值都是非常大的，经常是2^32以上，不可能对每个hashCode都指定一个映射。&lt;/p&gt;
&lt;p&gt;因为这样的一个问题，所以人们就将生成的HashCode以分段的形式来映射，把每一段称之为一个&lt;strong&gt;Bucket（桶）&lt;/strong&gt;，一般常见的Hash桶就是直接对结果取余。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;假设将生成的hashCode可能取值有2^32个，然后将其切分成一段一段，使用&lt;strong&gt;8&lt;/strong&gt;个桶来映射，那么就可以通过&lt;code&gt;bucketIndex = HashFunc(key1) % 8&lt;/code&gt;这样一个算法来确定这个hashCode映射到具体的哪个桶中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;大家可以看出来，通过hash桶这种形式来进行映射，所以会加剧hash的冲突。&lt;/p&gt;
&lt;h3 id=&quot;解决冲突算法&quot;&gt;3、解决冲突算法&lt;/h3&gt;
&lt;p&gt;对于一个hash算法，不可避免的会产生冲突，那么产生冲突以后如何处理，是一个很关键的地方，目前常见的冲突解决算法有&lt;strong&gt;拉链法(Dictionary实现采用的)、开放定址法、再Hash法、公共溢出分区法&lt;/strong&gt;，本文只介绍拉链法与再Hash法，对于其它算法感兴趣的同学可参考文章最后的参考文献。&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;strong&gt;1. 拉链法：&lt;/strong&gt;这种方法的思路是将产生冲突的元素建立一个单链表，并将头指针地址存储至Hash表对应桶的位置。这样定位到Hash表桶的位置后可通过遍历单链表的形式来查找元素。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 再Hash法：&lt;/strong&gt;顾名思义就是将key使用其它的Hash函数再次Hash，直到找到不冲突的位置为止。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于拉链法有一张图来描述，通过在冲突位置建立单链表，来解决冲突。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/997046/201901/997046-20190126232145660-1825878982.png&quot; alt=&quot;1548485607652&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;三dictionary实现&quot;&gt;三、Dictionary实现&lt;/h2&gt;
&lt;p&gt;Dictionary实现我们主要对照源码来解析，目前对照源码的版本是&lt;strong&gt;.Net Framwork 4.7&lt;/strong&gt;。地址可戳一戳这个链接 源码地址：&lt;a href=&quot;https://referencesource.microsoft.com/#mscorlib/system/collections/generic/dictionary.cs,d3599058f8d79be0&quot;&gt;Link&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这一章节中主要介绍Dictionary中几个比较关键的类和对象，然后跟着代码来走一遍插入、删除和扩容的流程，相信大家就能理解它的设计原理。&lt;/p&gt;
&lt;h3 id=&quot;entry结构体&quot;&gt;1. Entry结构体&lt;/h3&gt;
&lt;p&gt;首先我们引入&lt;strong&gt;Entry&lt;/strong&gt;这样一个结构体，它的定义如下代码所示。这是Dictionary种存放数据的最小单位，调用&lt;code&gt;Add(Key,Value)&lt;/code&gt;方法添加的元素都会被封装在这样的一个结构体中。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;private struct Entry {
    public int hashCode;    // 除符号位以外的31位hashCode值, 如果该Entry没有被使用，那么为-1
    public int next;        // 下一个元素的下标索引，如果没有下一个就为-1
    public TKey key;        // 存放元素的键
    public TValue value;    // 存放元素的值
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;其它关键私有变量&quot;&gt;2. 其它关键私有变量&lt;/h3&gt;
&lt;p&gt;除了Entry结构体外，还有几个关键的私有变量，其定义和解释如下代码所示。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;private int[] buckets;      // Hash桶
private Entry[] entries;    // Entry数组，存放元素
private int count;          // 当前entries的index位置
private int version;        // 当前版本，防止迭代过程中集合被更改
private int freeList;       // 被删除Entry在entries中的下标index，这个位置是空闲的
private int freeCount;      // 有多少个被删除的Entry，有多少个空闲的位置
private IEqualityComparer&amp;lt;TKey&amp;gt; comparer;   // 比较器
private KeyCollection keys;     // 存放Key的集合
private ValueCollection values;     // 存放Value的集合&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码中，需要注意的是&lt;code&gt;buckets、entries&lt;/code&gt;这两个数组，这是实现Dictionary的关键。&lt;/p&gt;
&lt;h3 id=&quot;dictionary---add操作&quot;&gt;3. Dictionary - Add操作&lt;/h3&gt;
&lt;p&gt;经过上面的分析，相信大家还不是特别明白为什么需要这么设计，需要这么做。那我们现在来走一遍Dictionary的Add流程，来体会一下。&lt;/p&gt;
&lt;p&gt;首先我们用图的形式来描述一个Dictionary的数据结构，其中只画出了关键的地方。桶大小为4以及Entry大小也为4的一个数据结构。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/997046/201901/997046-20190126232145341-1401582594.png&quot; alt=&quot;1548491185593&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我们假设需要执行一个&lt;strong&gt;Add&lt;/strong&gt;操作，&lt;code&gt;dictionary.Add(&quot;a&quot;,&quot;b&quot;)&lt;/code&gt;，其中&lt;code&gt;key = &quot;a&quot;,value = &quot;b&quot;&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol readability=&quot;7&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;根据&lt;strong&gt;key&lt;/strong&gt;的值，计算出它的hashCode。我们假设&quot;a&quot;的hash值为6（&lt;code&gt;GetHashCode(&quot;a&quot;) = 6&lt;/code&gt;）。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;通过对hashCode取余运算，计算出该hashCode落在哪一个buckets桶中。现在桶的长度（&lt;code&gt;buckets.Length&lt;/code&gt;）为4，那么就是&lt;code&gt;6 % 4&lt;/code&gt;最后落在&lt;code&gt;index&lt;/code&gt;为2的桶中，也就是&lt;code&gt;buckets[2]&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;避开一种其它情况不谈，接下来它会将&lt;code&gt;hashCode、key、value&lt;/code&gt;等信息存入&lt;code&gt;entries[count]&lt;/code&gt;中，因为&lt;code&gt;count&lt;/code&gt;位置是空闲的；继续&lt;code&gt;count++&lt;/code&gt;指向下一个空闲位置。上图中第一个位置，index=0就是空闲的，所以就存放在&lt;code&gt;entries[0]&lt;/code&gt;的位置。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;将&lt;code&gt;Entry&lt;/code&gt;的下标&lt;code&gt;entryIndex&lt;/code&gt;赋值给&lt;code&gt;buckets&lt;/code&gt;中对应下标的&lt;code&gt;bucket&lt;/code&gt;。步骤3中是存放在&lt;code&gt;entries[0]&lt;/code&gt;的位置，所以&lt;code&gt;buckets[2]=0&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;最后&lt;code&gt;version++&lt;/code&gt;，集合发生了变化，所以版本需要+1。&lt;strong&gt;只有增加、替换和删除元素才会更新版本&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;上文中的步骤1~5只是方便大家理解，实际上有一些偏差，后文再谈Add操作小节中会补充。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;完成上面Add操作后，数据结构更新成了下图这样的形式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/997046/201901/997046-20190126232144972-327613048.png&quot; alt=&quot;1548492100757&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样是理想情况下的操作，一个bucket中只有一个hashCode没有碰撞的产生，但是实际上是会经常产生碰撞；那么Dictionary类中又是如何解决碰撞的呢。&lt;/p&gt;
&lt;p&gt;我们继续执行一个&lt;strong&gt;Add&lt;/strong&gt;操作，&lt;code&gt;dictionary.Add(&quot;c&quot;,&quot;d&quot;)&lt;/code&gt;，假设&lt;code&gt;GetHashCode(“c”)=6&lt;/code&gt;，最后&lt;code&gt;6 % 4 = 2&lt;/code&gt;。最后桶的&lt;code&gt;index&lt;/code&gt;也是2，按照之前的&lt;strong&gt;步骤1~3&lt;/strong&gt;是没有问题的，执行完后数据结构如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/997046/201901/997046-20190126232144707-1105753624.png&quot; alt=&quot;1548493287583&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果继续执行&lt;strong&gt;步骤4&lt;/strong&gt;那么&lt;code&gt;buckets[2] = 1&lt;/code&gt;，然后原来的&lt;code&gt;buckets[2]=&amp;gt;entries[0]&lt;/code&gt;的关系就会丢失，这是我们不愿意看到的。现在Entry中的&lt;code&gt;next&lt;/code&gt;就发挥大作用了。&lt;/p&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;如果对应的&lt;code&gt;buckets[index]&lt;/code&gt;有其它元素已经存在，那么会执行以下两条语句，让新的&lt;code&gt;entry.next&lt;/code&gt;指向之前的元素，让&lt;code&gt;buckets[index]&lt;/code&gt;指向现在的新的元素，就构成了一个单链表。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;entries[index].next = buckets[targetBucket];
...
buckets[targetBucket] = index;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实际上&lt;strong&gt;步骤4&lt;/strong&gt;也就是做一个这样的操作，并不会去判断是不是有其它元素，因为&lt;code&gt;buckets&lt;/code&gt;中桶初始值就是-1，不会造成问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;经过上面的步骤以后，数据结构就更新成了下图这个样子。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/997046/201901/997046-20190126232144436-391161641.png&quot; alt=&quot;1548494357566&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;dictionary---find操作&quot;&gt;4. Dictionary - Find操作&lt;/h3&gt;
&lt;p&gt;为了方便演示如何查找，我们继续Add一个元素&lt;code&gt;dictionary.Add(&quot;e&quot;,&quot;f&quot;)&lt;/code&gt;，&lt;code&gt;GetHashCode(“e”) = 7; 7% buckets.Length=3&lt;/code&gt;,数据结构如下所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/997046/201901/997046-20190126232143619-706622936.png&quot; alt=&quot;1548494583006&quot;/&gt;&lt;/p&gt;
&lt;p&gt;假设我们现在执行这样一条语句&lt;code&gt;dictionary.GetValueOrDefault(&quot;a&quot;)&lt;/code&gt;，会执行以下步骤.&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;获取key的hashCode，计算出所在的桶位置。我们之前提到，&quot;a&quot;的&lt;code&gt;hashCode=6&lt;/code&gt;，所以最后计算出来&lt;code&gt;targetBucket=2&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;buckets[2]=1&lt;/code&gt;找到&lt;code&gt;entries[1]&lt;/code&gt;,比较key的值是否相等，相等就返回&lt;code&gt;entryIndex&lt;/code&gt;，不想等就继续&lt;code&gt;entries[next]&lt;/code&gt;查找，直到找到key相等元素或者&lt;code&gt;next == -1&lt;/code&gt;的时候。这里我们找到了&lt;code&gt;key == &quot;a&quot;&lt;/code&gt;的元素，返回&lt;code&gt;entryIndex=0&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;如果&lt;code&gt;entryIndex &amp;gt;= 0&lt;/code&gt;那么返回对应的&lt;code&gt;entries[entryIndex]&lt;/code&gt;元素，否则返回&lt;code&gt;default(TValue)&lt;/code&gt;。这里我们直接返回&lt;code&gt;entries[0].value&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;整个查找的过程如下图所示.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/997046/201901/997046-20190126232143933-534053020.png&quot; alt=&quot;1548495296415&quot;/&gt;&lt;/p&gt;
&lt;p&gt;将查找的代码摘录下来，如下所示。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;// 寻找Entry元素的位置
private int FindEntry(TKey key) {
    if( key == null) {
        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.key);
    }

    if (buckets != null) {
        int hashCode = comparer.GetHashCode(key) &amp;amp; 0x7FFFFFFF; // 获取HashCode，忽略符号位
        // int i = buckets[hashCode % buckets.Length] 找到对应桶，然后获取entry在entries中位置
        // i &amp;gt;= 0; i = entries[i].next 遍历单链表
        for (int i = buckets[hashCode % buckets.Length]; i &amp;gt;= 0; i = entries[i].next) {
            // 找到就返回了
            if (entries[i].hashCode == hashCode &amp;amp;&amp;amp; comparer.Equals(entries[i].key, key)) return i;
        }
    }
    return -1;
}
...
internal TValue GetValueOrDefault(TKey key) {
    int i = FindEntry(key);
    // 大于等于0代表找到了元素位置，直接返回value
    // 否则返回该类型的默认值
    if (i &amp;gt;= 0) {
        return entries[i].value;
    }
    return default(TValue);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;dictionary---remove操作&quot;&gt;5. Dictionary - Remove操作&lt;/h3&gt;
&lt;p&gt;前面已经向大家介绍了增加、查找，接下来向大家介绍Dictionary如何执行删除操作。我们沿用之前的Dictionary数据结构。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/997046/201901/997046-20190126232143619-706622936.png&quot; alt=&quot;1548494583006&quot;/&gt;&lt;/p&gt;
&lt;p&gt;删除前面步骤和查找类似，也是需要找到元素的位置，然后再进行删除的操作。&lt;/p&gt;
&lt;p&gt;我们现在执行这样一条语句&lt;code&gt;dictionary.Remove(&quot;a&quot;)&lt;/code&gt;，hashFunc运算结果和上文中一致。步骤大部分与查找类似，我们直接看摘录的代码，如下所示。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public bool Remove(TKey key) {
    if(key == null) {
        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.key);
    }

    if (buckets != null) {
        // 1. 通过key获取hashCode
        int hashCode = comparer.GetHashCode(key) &amp;amp; 0x7FFFFFFF;
        // 2. 取余获取bucket位置
        int bucket = hashCode % buckets.Length;
        // last用于确定是否当前bucket的单链表中最后一个元素
        int last = -1;
        // 3. 遍历bucket对应的单链表
        for (int i = buckets[bucket]; i &amp;gt;= 0; last = i, i = entries[i].next) {
            if (entries[i].hashCode == hashCode &amp;amp;&amp;amp; comparer.Equals(entries[i].key, key)) {
                // 4. 找到元素后，如果last&amp;lt; 0，代表当前是bucket中最后一个元素，那么直接让bucket内下标赋值为 entries[i].next即可
                if (last &amp;lt; 0) {
                    buckets[bucket] = entries[i].next;
                }
                else {
                    // 4.1 last不小于0，代表当前元素处于bucket单链表中间位置，需要将该元素的头结点和尾节点相连起来,防止链表中断
                    entries[last].next = entries[i].next;
                }
                // 5. 将Entry结构体内数据初始化
                entries[i].hashCode = -1;
                // 5.1 建立freeList单链表
                entries[i].next = freeList;
                entries[i].key = default(TKey);
                entries[i].value = default(TValue);
                // *6. 关键的代码，freeList等于当前的entry位置，下一次Add元素会优先Add到该位置
                freeList = i;
                freeCount++;
                // 7. 版本号+1
                version++;
                return true;
            }
        }
    }
    return false;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行完上面代码后，数据结构就更新成了下图所示。需要注意&lt;code&gt;varsion、freeList、freeCount&lt;/code&gt;的值都被更新了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/997046/201901/997046-20190126232143380-1521029377.png&quot; alt=&quot;1548496815179&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;dictionary---resize操作扩容&quot;&gt;6. Dictionary - Resize操作(扩容)&lt;/h3&gt;
&lt;p&gt;有细心的小伙伴可能看过了&lt;strong&gt;Add&lt;/strong&gt;操作以后就想问了，&lt;code&gt;buckets、entries&lt;/code&gt;不就是两个数组么，那万一数组放满了怎么办？接下来就是我所要介绍的&lt;strong&gt;Resize（扩容）&lt;/strong&gt;这样一种操作，对我们的&lt;code&gt;buckets、entries&lt;/code&gt;进行扩容。&lt;/p&gt;
&lt;h4 id=&quot;扩容操作的触发条件&quot;&gt;6.1 扩容操作的触发条件&lt;/h4&gt;
&lt;p&gt;首先我们需要知道在什么情况下，会发生扩容操作；&lt;strong&gt;第一种情况自然就是数组已经满了，没有办法继续存放新的元素。&lt;/strong&gt;如下图所示的情况。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/997046/201901/997046-20190126232142991-753412617.png&quot; alt=&quot;1548498710430&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上文中大家都知道，Hash运算会不可避免的产生冲突，Dictionary中使用拉链法来解决冲突的问题，但是大家看下图中的这种情况。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/997046/201901/997046-20190126232142685-1366765345.png&quot; alt=&quot;1548498901496&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所有的元素都刚好落在&lt;code&gt;buckets[3]&lt;/code&gt;上面，结果就是导致了&lt;strong&gt;时间复杂度O(n)&lt;/strong&gt;，查找性能会下降；所以&lt;strong&gt;第二种，Dictionary中发生的碰撞次数太多，会严重影响性能，&lt;/strong&gt;也会触发扩容操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;目前.Net Framwork 4.7中设置的碰撞次数阈值为100.&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public const int HashCollisionThreshold = 100;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;扩容操作如何进行&quot;&gt;6.2 扩容操作如何进行&lt;/h4&gt;
&lt;p&gt;为了给大家演示的清楚，模拟了以下这种数据结构，大小为2的Dictionary，假设碰撞的阈值为2；现在触发Hash碰撞扩容。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/997046/201901/997046-20190126232142310-209798626.png&quot; alt=&quot;1548499708530&quot;/&gt;&lt;/p&gt;
&lt;p&gt;开始扩容操作。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;1.申请两倍于现在大小的buckets、entries&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;2.将现有的元素拷贝到新的entries&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;完成上面两步操作后，新数据结构如下所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/997046/201901/997046-20190126232142082-458174885.png&quot; alt=&quot;1548499785441&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;3、如果是Hash碰撞扩容，使用新HashCode函数重新计算Hash值&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上文提到了，这是发生了Hash碰撞扩容，所以需要使用新的Hash函数计算Hash值。新的Hash函数并一定能解决碰撞的问题，有可能会更糟，像下图中一样的还是会落在同一个&lt;code&gt;bucket&lt;/code&gt;上。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/997046/201901/997046-20190126232141840-1221070461.png&quot; alt=&quot;1548500174305&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;4、对entries每个元素bucket = newEntries[i].hashCode % newSize确定新buckets位置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5、重建hash链，newEntries[i].next=buckets[bucket]; buckets[bucket]=i;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因为&lt;code&gt;buckets&lt;/code&gt;也扩充为两倍大小了，所以需要重新确定&lt;code&gt;hashCode&lt;/code&gt;在哪个&lt;code&gt;bucket&lt;/code&gt;中；最后重新建立hash单链表.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/997046/201901/997046-20190126232141497-1107893517.png&quot; alt=&quot;1548500290419&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这就完成了扩容的操作，如果是达到&lt;strong&gt;Hash碰撞阈值&lt;/strong&gt;触发的扩容可能扩容后结果会更差。&lt;/p&gt;
&lt;p&gt;在JDK中，&lt;code&gt;HashMap&lt;/code&gt;如果碰撞的次数太多了，那么会将&lt;strong&gt;单链表转换为红黑树&lt;/strong&gt;提升查找性能。目前&lt;strong&gt;.Net Framwork&lt;/strong&gt;中还没有这样的优化，&lt;strong&gt;.Net Core&lt;/strong&gt;中已经有了类似的优化，以后有时间在分享&lt;strong&gt;.Net Core&lt;/strong&gt;的一些集合实现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;每次扩容操作都需要遍历所有元素，会影响性能。所以创建Dictionary实例时最好设置一个预估的初始大小。&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;private void Resize(int newSize, bool forceNewHashCodes) {
    Contract.Assert(newSize &amp;gt;= entries.Length);
    // 1. 申请新的Buckets和entries
    int[] newBuckets = new int[newSize];
    for (int i = 0; i &amp;lt; newBuckets.Length; i++) newBuckets[i] = -1;
    Entry[] newEntries = new Entry[newSize];
    // 2. 将entries内元素拷贝到新的entries总
    Array.Copy(entries, 0, newEntries, 0, count);
    // 3. 如果是Hash碰撞扩容，使用新HashCode函数重新计算Hash值
    if(forceNewHashCodes) {
        for (int i = 0; i &amp;lt; count; i++) {
            if(newEntries[i].hashCode != -1) {
                newEntries[i].hashCode = (comparer.GetHashCode(newEntries[i].key) &amp;amp; 0x7FFFFFFF);
            }
        }
    }
    // 4. 确定新的bucket位置
    // 5. 重建Hahs单链表
    for (int i = 0; i &amp;lt; count; i++) {
        if (newEntries[i].hashCode &amp;gt;= 0) {
            int bucket = newEntries[i].hashCode % newSize;
            newEntries[i].next = newBuckets[bucket];
            newBuckets[bucket] = i;
        }
    }
    buckets = newBuckets;
    entries = newEntries;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;dictionary---再谈add操作&quot;&gt;7. Dictionary - 再谈Add操作&lt;/h3&gt;
&lt;p&gt;在我们之前的&lt;strong&gt;Add&lt;/strong&gt;操作步骤中，提到了这样一段话，这里提到会有一种其它的情况，那就是&lt;strong&gt;有元素被删除&lt;/strong&gt;的情况。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;避开一种其它情况不谈，接下来它会将&lt;code&gt;hashCode、key、value&lt;/code&gt;等信息存入&lt;code&gt;entries[count]&lt;/code&gt;中，因为&lt;code&gt;count&lt;/code&gt;位置是空闲的；继续&lt;code&gt;count++&lt;/code&gt;指向下一个空闲位置。上图中第一个位置，index=0就是空闲的，所以就存放在&lt;code&gt;entries[0]&lt;/code&gt;的位置。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;因为&lt;code&gt;count&lt;/code&gt;是通过自增的方式来指向&lt;code&gt;entries[]&lt;/code&gt;下一个空闲的&lt;code&gt;entry&lt;/code&gt;，如果有元素被删除了，那么在&lt;code&gt;count&lt;/code&gt;之前的位置就会出现一个空闲的&lt;code&gt;entry&lt;/code&gt;；如果不处理，会有很多空间被浪费。&lt;/p&gt;
&lt;p&gt;这就是为什么&lt;strong&gt;Remove&lt;/strong&gt;操作会记录&lt;code&gt;freeList、freeCount&lt;/code&gt;，就是为了将删除的空间利用起来。实际上&lt;strong&gt;Add&lt;/strong&gt;操作会优先使用&lt;code&gt;freeList&lt;/code&gt;的空闲&lt;code&gt;entry&lt;/code&gt;位置，摘录代码如下。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;private void Insert(TKey key, TValue value, bool add){
    
    if( key == null ) {
        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.key);
    }

    if (buckets == null) Initialize(0);
    // 通过key获取hashCode
    int hashCode = comparer.GetHashCode(key) &amp;amp; 0x7FFFFFFF;
    // 计算出目标bucket下标
    int targetBucket = hashCode % buckets.Length;
    // 碰撞次数
    int collisionCount = 0;
    for (int i = buckets[targetBucket]; i &amp;gt;= 0; i = entries[i].next) {
        if (entries[i].hashCode == hashCode &amp;amp;&amp;amp; comparer.Equals(entries[i].key, key)) {
            // 如果是增加操作，遍历到了相同的元素，那么抛出异常
            if (add) {      
                ThrowHelper.ThrowArgumentException(ExceptionResource.Argument_AddingDuplicate);
            }
            // 如果不是增加操作，那可能是索引赋值操作 dictionary[&quot;foo&quot;] = &quot;foo&quot;
            // 那么赋值后版本++，退出
            entries[i].value = value;
            version++;
            return;
        }
        // 每遍历一个元素，都是一次碰撞
        collisionCount++;
    }
    int index;
    // 如果有被删除的元素，那么将元素放到被删除元素的空闲位置
    if (freeCount &amp;gt; 0) {
        index = freeList;
        freeList = entries[index].next;
        freeCount--;
    }
    else {
        // 如果当前entries已满，那么触发扩容
        if (count == entries.Length)
        {
            Resize();
            targetBucket = hashCode % buckets.Length;
        }
        index = count;
        count++;
    }

    // 给entry赋值
    entries[index].hashCode = hashCode;
    entries[index].next = buckets[targetBucket];
    entries[index].key = key;
    entries[index].value = value;
    buckets[targetBucket] = index;
    // 版本号++
    version++;

    // 如果碰撞次数大于设置的最大碰撞次数，那么触发Hash碰撞扩容
    if(collisionCount &amp;gt; HashHelpers.HashCollisionThreshold &amp;amp;&amp;amp; HashHelpers.IsWellKnownEqualityComparer(comparer)) 
    {
        comparer = (IEqualityComparer&amp;lt;TKey&amp;gt;) HashHelpers.GetRandomizedEqualityComparer(comparer);
        Resize(entries.Length, true);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面就是完整的&lt;strong&gt;Add&lt;/strong&gt;代码，还是很简单的对不对？&lt;/p&gt;
&lt;h3 id=&quot;collection版本控制&quot;&gt;8. Collection版本控制&lt;/h3&gt;
&lt;p&gt;在上文中一直提到了&lt;code&gt;version&lt;/code&gt;这个变量，在每一次新增、修改和删除操作时，都会使&lt;code&gt;version++&lt;/code&gt;；那么这个&lt;code&gt;version&lt;/code&gt;存在的意义是什么呢？&lt;/p&gt;
&lt;p&gt;首先我们来看一段代码，这段代码中首先实例化了一个Dictionary实例，然后通过&lt;code&gt;foreach&lt;/code&gt;遍历该实例，在&lt;code&gt;foreach&lt;/code&gt;代码块中使用&lt;code&gt;dic.Remove(kv.Key)&lt;/code&gt;删除元素。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/997046/201901/997046-20190126232140770-1720202601.png&quot; alt=&quot;1548504444217&quot;/&gt;&lt;/p&gt;
&lt;p&gt;结果就是抛出了&lt;code&gt;System.InvalidOperationException:&quot;Collection was modified...&quot;&lt;/code&gt;这样的异常，&lt;strong&gt;迭代过程中不允许集合出现变化&lt;/strong&gt;。如果在Java中遍历直接删除元素，会出现诡异的问题，所以.Net中就使用了&lt;code&gt;version&lt;/code&gt;来实现版本控制。&lt;/p&gt;
&lt;p&gt;那么如何在迭代过程中实现版本控制的呢？我们看一看源码就很清楚的知道。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/997046/201901/997046-20190126232140302-855859067.png&quot; alt=&quot;1548504844162&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在迭代器初始化时，就会记录&lt;code&gt;dictionary.version&lt;/code&gt;版本号，之后每一次迭代过程都会检查版本号是否一致，如果不一致将抛出异常。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这样就避免了在迭代过程中修改了集合，造成很多诡异的问题。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;四参考文献及总结&quot;&gt;四、参考文献及总结&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;本文在编写过程中，主要参考了以下文献，在此感谢其作者在知识分享上作出的贡献！&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/mengfanrong/p/4034950.html&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/mengfanrong/p/4034950.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Hash_table&quot; class=&quot;uri&quot;&gt;https://en.wikipedia.org/wiki/Hash_table&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/wuchaodzxx/p/7396599.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/wuchaodzxx/p/7396599.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/liwei2222/p/8013367.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/liwei2222/p/8013367.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://referencesource.microsoft.com/#mscorlib/system/collections/generic/dictionary.cs,fd1acf96113fbda9&quot; class=&quot;uri&quot;&gt;https://referencesource.microsoft.com/#mscorlib/system/collections/generic/dictionary.cs,fd1acf96113fbda9&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
<pubDate>Sat, 26 Jan 2019 15:24:00 +0000</pubDate>
<dc:creator>InCerry</dc:creator>
<og:description>﻿ 浅析C Dictionary实现原理 [TOC] 一、前言 本篇文章配图以及文字其实整理出来很久了，但是由于各种各样的原因推迟到现在才发出来，还有之前立Flag的《多线程编程》的笔记也都已经写好了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/InCerry/p/10325290.html</dc:identifier>
</item>
<item>
<title>AcceptEx与完成端口结合实例 - 源之缘</title>
<link>http://www.cnblogs.com/yuanchenhui/p/acceptex_socket.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuanchenhui/p/acceptex_socket.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/span&gt; 在windows平台下实现高性能网络服务器，iocp（完成端口）是唯一选择。编写网络服务器面临的问题有：1 快速接收客户端的连接。2 快速收发数据。3 快速处理数据。本文主要解决第一个问题。&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;AcceptEx&lt;/span&gt;函数定义
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;BOOL AcceptEx(
  SOCKET       sListenSocket,
  SOCKET       sAcceptSocket,
  PVOID        lpOutputBuffer,
  DWORD        dwReceiveDataLength,
  DWORD        dwLocalAddressLength,
  DWORD        dwRemoteAddressLength,
  LPDWORD      lpdwBytesReceived,
  LPOVERLAPPED lpOverlapped
);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;为什么要用AcceptEx&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;owner_title text-overflow&quot; title=&quot;请教accept和AcceptEx的区别&quot;&gt;  传统的accept函数能满足大部分场景的需要；但在某些极端条件下，必须使用acceptEx来实现。两个函数的区别如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;owner_title text-overflow&quot; title=&quot;请教accept和AcceptEx的区别&quot;&gt;  1）accept是阻塞的；在一个端口监听，必须启动一个专用线程调用accept。当然也可以用迂回的方式，绕过这个限制，处理起来会很麻烦，见文章&lt;a href=&quot;https://www.cnblogs.com/yuanchenhui/p/icop_accept.html&quot; target=&quot;_blank&quot;&gt;单线程实现同时监听多个端口&lt;/a&gt;。acceptEx是异步的，可以同时对很多端口监听（监听端口的数量没有上限的限制）。采用迂回的方式，使用accept监听，一个线程最多监听64个端口。这一点可能不是AcceptEx最大优点，毕竟同时对多个端口监听的情况非常少见。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;owner_title text-overflow&quot; title=&quot;请教accept和AcceptEx的区别&quot;&gt; 2）AcceptEx可以返回更多的数据。a）AcceptEx可以返回本地和对方ip地址和端口；而不需要调用函数getsockname和getpeername获取网络地址了。b）AcceptEx可以再接收到一段数据后，再返回。这种做法有利有弊，一般不建议这样做。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;owner_title text-overflow&quot; title=&quot;请教accept和AcceptEx的区别&quot;&gt; 3）AcceptEx是先准备套接字（socket）后接收。为了应对突发的连接高峰，可以多次投放AcceptEx。accept是事后建立SOCKET，就是tcp三次握手完成后，accept调用才返回，再生成socket。生成套接字是相对比较耗时的操作，accept的方式无法及时处理突发连接。对于AcceptEx的处理方式为建议做如下处理：一个线程负责创建socket，一个线程负责处理AcceptEx返回。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;owner_title text-overflow&quot; title=&quot;请教accept和AcceptEx的区别&quot;&gt;以上仅仅通过文字说明了AcceptEx的特点。下面通过具体代码，逐一剖析。我将AcceptEx的处理封装到类IocpAcceptEx中。编写该类时，尽量做到高内聚低耦合，使该类可以方便的被其他模块使用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span class=&quot;owner_title text-overflow&quot; title=&quot;请教accept和AcceptEx的区别&quot;&gt;IocpAcceptEx外部功能说明&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; IocpAcceptEx
{
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    IocpAcceptEx();
    &lt;/span&gt;~&lt;span&gt;IocpAcceptEx();

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置回调接口。当accept成功，调用回调接口。&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; SetCallback(IAcceptCallback*&lt;span&gt; callback);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 增加监听端口&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; AddListenPort(UINT16 port);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动服务&lt;/span&gt;
&lt;span&gt;    BOOL Start();
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; Stop();
        。。。以下代码省略
}&lt;br/&gt;#define POST_ACCEPT 1
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用IocpAcceptEx类，必须实现该接口。接收客户端的连接&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; IAcceptCallback
{
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; OnAcceptClient(SOCKET hSocketClient, UINT16 nListenPort) = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该类的调用函数很简单，对外接口也很明确。说明该类的职责很清楚，这也符合单一职责原则。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;实现步骤说明&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;AcceptEx不但需要与监听端口绑定，还需要与完成端口绑定。所以程序的第一步是创建完成端口：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;a）创建完成端口&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
m_hIocp = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, NULL, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (m_hIocp ==&lt;span&gt; NULL)
     &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; FALSE;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;b）监听端口创建与绑定&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;生成套接字&lt;/span&gt;
    SOCKET serverSocket = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, WSA_FLAG_OVERLAPPED);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (serverSocket ==&lt;span&gt; INVALID_SOCKET)
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;绑定&lt;/span&gt;
&lt;span&gt;    SOCKADDR_IN addr;
    memset(&lt;/span&gt;&amp;amp;addr, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(addr));
    addr.sin_family &lt;/span&gt;=&lt;span&gt; AF_INET;
    addr.sin_addr.s_addr &lt;/span&gt;=&lt;span&gt;  INADDR_ANY ;
    addr.sin_port &lt;/span&gt;=&lt;span&gt; htons(port);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (bind(serverSocket, (sockaddr *)&amp;amp;addr, &lt;span&gt;sizeof&lt;/span&gt;(addr)) != &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
    {
        closesocket(serverSocket);
        serverSocket &lt;/span&gt;=&lt;span&gt; INVALID_SOCKET;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动监听&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (listen(serverSocket, SOMAXCONN) != &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
    {
        closesocket(serverSocket);
        serverSocket &lt;/span&gt;=&lt;span&gt; INVALID_SOCKET;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;监听端口与完成端口绑定&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (CreateIoCompletionPort((HANDLE)serverSocket, m_hIocp, (ULONG_PTR)&lt;span&gt;this&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;) ==&lt;span&gt; NULL)
    {
        closesocket(serverSocket);
        serverSocket &lt;/span&gt;=&lt;span&gt; INVALID_SOCKET;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;c）投递AcceptEx&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; AcceptOverlapped
{
    OVERLAPPED     overlap;
    INT32 opType;
    SOCKET serverSocket;
    SOCKET clientSocket;

    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; lpOutputBuf[&lt;span&gt;128&lt;/span&gt;&lt;span&gt;];
    DWORD dwBytes;
};

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; IocpAcceptEx::NewAccept(SOCKET serverSocket)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建socket&lt;/span&gt;
    SOCKET _socket =&lt;span&gt; socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); 

    AcceptOverlapped &lt;/span&gt;*ov = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AcceptOverlapped();
    ZeroMemory(ov,&lt;/span&gt;&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(AcceptOverlapped));
    ov&lt;/span&gt;-&amp;gt;opType =&lt;span&gt; POST_ACCEPT;
    ov&lt;/span&gt;-&amp;gt;clientSocket =&lt;span&gt; _socket;
    ov&lt;/span&gt;-&amp;gt;serverSocket =&lt;span&gt; serverSocket;

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;存放网络地址的长度&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; addrLen = &lt;span&gt;sizeof&lt;/span&gt;(sockaddr_in) + &lt;span&gt;16&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; bRetVal = AcceptEx(serverSocket, _socket, ov-&amp;gt;&lt;span&gt;lpOutputBuf,
        &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,addrLen, addrLen,
        &lt;/span&gt;&amp;amp;ov-&amp;gt;&lt;span&gt;dwBytes, (LPOVERLAPPED)ov);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (bRetVal ==&lt;span&gt; FALSE)
    {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; error =&lt;span&gt; WSAGetLastError();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (error !=&lt;span&gt; WSA_IO_PENDING)
        {
            closesocket(_socket);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        }
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre readability=&quot;5&quot;&gt;
AcceptEx是非阻塞操作，调用会立即返回。当有客户端连接时，怎么得到通知。答案是通过完成端口返回。注意有一个步骤：监听端口与完成端口绑定，就是serverSocket与m_hIocp绑定，所以当有客户端连接serverSocket时，m_hIocp会得到通知。需要生成线程，等待完成端口的通知。&lt;p&gt;&lt;strong&gt;&lt;span&gt;d)通过完成端口，获取通知&lt;/span&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;/p&gt;&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    DWORD dwBytesTransferred;
    ULONG_PTR    Key;
    BOOL rc;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; error;

    AcceptOverlapped &lt;/span&gt;*lpPerIOData =&lt;span&gt; NULL;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (m_bServerStart)
    {
        error &lt;/span&gt;=&lt;span&gt; NO_ERROR;
        rc &lt;/span&gt;=&lt;span&gt; GetQueuedCompletionStatus(
            m_hIocp,
            &lt;/span&gt;&amp;amp;&lt;span&gt;dwBytesTransferred,
            &lt;/span&gt;&amp;amp;&lt;span&gt;Key,
            (LPOVERLAPPED &lt;/span&gt;*)&amp;amp;&lt;span&gt;lpPerIOData,
            INFINITE);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (rc ==&lt;span&gt; FALSE)
        {
            error &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (lpPerIOData ==&lt;span&gt; NULL)
            {
                DWORD lastError &lt;/span&gt;=&lt;span&gt; GetLastError();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (lastError ==&lt;span&gt; WAIT_TIMEOUT)
                {
                    &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                {
                    assert(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; lastError;
                }
            }
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (lpPerIOData !=&lt;span&gt; NULL)
        {
            &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt; (lpPerIOData-&amp;gt;&lt;span&gt;opType)
            {
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; POST_ACCEPT:
            {
                OnIocpAccept(lpPerIOData, dwBytesTransferred, error);
            }
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; 
        {            
        }
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;　　
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;strong&gt; &lt;/strong&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;DWORD WINAPI IocpAcceptEx::AcceptExThreadPool(PVOID pContext)
{
    ThreadPoolParam &lt;/span&gt;*param = (ThreadPoolParam*&lt;span&gt;)pContext;
    param&lt;/span&gt;-&amp;gt;pIocpAcceptEx-&amp;gt;NewAccept(param-&amp;gt;&lt;span&gt;ServeSocket);
    delete param;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; IocpAcceptEx::OnIocpAccept(AcceptOverlapped *acceptData, &lt;span&gt;int&lt;/span&gt; transLen, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; error)
{
    m_IAcceptCallback&lt;/span&gt;-&amp;gt;OnAcceptClient(acceptData-&amp;gt;clientSocket, acceptData-&amp;gt;&lt;span&gt;serverSocket);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当一个AcceptEx返回，需要投递一个新的AcceptEx。 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用线程池好像有点小题大做。前文已说过，套接字的创建相对是比较耗时的操作。
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果不在线程池投递AcceptEx，AcceptEx的优点就被抹杀了。&lt;/span&gt;
    ThreadPoolParam *param = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadPoolParam();
    param&lt;/span&gt;-&amp;gt;pIocpAcceptEx = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
    param&lt;/span&gt;-&amp;gt;ServeSocket = acceptData-&amp;gt;&lt;span&gt;serverSocket;
    QueueUserWorkItem(AcceptExThreadPool, &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

    delete acceptData;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}　　　　&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;后记 &lt;/strong&gt;&lt;/span&gt;采用完成端口是提高IO处理能力的一个途径（广义上讲，通讯操作也是IO）。为了提高IO处理能力，windows提供很多异步操作函数，这些函数都与完成端口关联，所以这一类处理的思路基本一致。学会了AcceptEx的使用，可以做到触类旁通的效果。
&lt;/pre&gt;</description>
<pubDate>Sat, 26 Jan 2019 15:03:00 +0000</pubDate>
<dc:creator>源之缘</dc:creator>
<og:description>前言 在windows平台下实现高性能网络服务器，iocp（完成端口）是唯一选择。编写网络服务器面临的问题有：1 快速接收客户端的连接。2 快速收发数据。3 快速处理数据。本文主要解决第一个问题。 为</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuanchenhui/p/acceptex_socket.html</dc:identifier>
</item>
<item>
<title>GF(p)上的ELGamal型椭圆曲线密码详解（Java实现） - 蒙丿鑫</title>
<link>http://www.cnblogs.com/mx-lqk/p/10325192.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mx-lqk/p/10325192.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://github.com/lqk1017237457/ECC_p&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;&lt;span&gt;GitHub&lt;/span&gt;&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;　　椭圆曲线密码（Elliptic Curve Cryptosystem），简称ECC，是Neal Koblitz和Victor Miller于1985年提出的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　研究发现，有限域上的椭圆曲线上的一些点构成交换群，而且离散对数问题是难解的。于是在此群上定义ELGamal密码，并称为椭圆曲线密码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　目前，椭圆曲线密码已成为除RSA密码之外呼声最高的公钥密码之一。它密钥短、签名短、软件实现规模小、硬件实现电路省电。普遍认为，160位长的椭圆曲线密码的安全性相当于1024位的RSA密码，而且运算速度也较快。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;　　设p是大于3的素数，且4a&lt;sup&gt;3&lt;/sup&gt;+27b&lt;sup&gt;2&lt;/sup&gt;≠0(mod p)，称曲线&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;y&lt;sup&gt;2&lt;/sup&gt;=x&lt;sup&gt;3&lt;/sup&gt;+ax+b（a,b∈GF(p)）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为GF(p)上的椭圆曲线。&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　由椭圆曲线方程可得到一同余方程：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;y&lt;sup&gt;2&lt;/sup&gt;=x&lt;sup&gt;3&lt;/sup&gt;+ax+b(mod p)（a,b∈GF(p)）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其解为一个二元组(x,y)，其中x,y∈GF(p)，表示椭圆曲线上的一个点，称为该椭圆曲线上的解点。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;无穷点O&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　定义一个点O(∞,∞)表示无穷点，作为0元素。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;两解点相加&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　设P(x&lt;sub&gt;1&lt;/sub&gt;,y&lt;sub&gt;1&lt;/sub&gt;)和Q(x&lt;sub&gt;2&lt;/sub&gt;,y&lt;sub&gt;2&lt;/sub&gt;)是解点，R(x&lt;sub&gt;3&lt;/sub&gt;,y&lt;sub&gt;3&lt;/sub&gt;)=P(x&lt;sub&gt;1&lt;/sub&gt;,y&lt;sub&gt;1&lt;/sub&gt;)+Q(x&lt;sub&gt;2&lt;/sub&gt;,y&lt;sub&gt;2&lt;/sub&gt;)：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1.若P为无穷点，即P=O，此时R=P+Q=Q；若Q为无穷点，即Q=O，此时R=P+Q=P；若P和Q都为无穷点，即P=Q=O，则R=P+Q=O。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2.若x&lt;sub&gt;1&lt;/sub&gt;=x&lt;sub&gt;2&lt;/sub&gt;且y&lt;sub&gt;1&lt;/sub&gt;=y&lt;sub&gt;2&lt;/sub&gt;，即P=Q，此时R=P+Q=2P，其中&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1582448/201901/1582448-20190126213309668-1828141427.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3.若x1=x2而y1=-y2，此时称Q点为P点的逆，记为P=-Q，且R=P+Q=O。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　4.除上述特殊情况之外的一般情况，即P≠±Q时，R=P+Q，其中&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1582448/201901/1582448-20190126213524575-741998183.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　集合E={所有的解点,无穷点O}和加法运算构成加法交换群。&lt;/span&gt;&lt;span&gt;设G(G≠O，即G为一个解点)为一个加法群的生成元，则使得nG=G+G+...+G=O的倍数n为该加法群的阶。加法群的阶整除集合E的阶，即n | |E|。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;求椭圆曲线的所有解点&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　当p较小，即GF(p)较小时，可以利用穷举的方法根据同余方程y&lt;sup&gt;2&lt;/sup&gt;=x&lt;sup&gt;3&lt;/sup&gt;+ax+b(mod p)（a,b∈GF(p)）求出所有解点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　具体方法为：求出x取0~p-1，x&lt;sup&gt;3&lt;/sup&gt;+ax+b(mod p)的结果是否为模p的二次剩余。如果是，则一个x值可得到两个对应的y值，也就得到互逆的两个解点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　e.m.取p=11，椭圆曲线y&lt;sup&gt;2&lt;/sup&gt;=x&lt;sup&gt;3&lt;/sup&gt;+x+6&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1582448/201901/1582448-20190126212911980-1076446260.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　       由此表得到所有的解点：(2,4)、(2,7)、(3,5)、(3,6)、(5,2)、(5,9)、(7,2)、(7,9)、(8,3)、(8,8)、(10,2)、(10,9)，再加上无穷点O共13个点的集合E加上加法运算就构成一个加法交换群。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　       因为集合E的阶|E|=13为素数，所以该加法群的阶为13。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　       取G=(2,7)为生成元，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;G=(2,7)，&lt;/span&gt;&lt;span&gt;2G=(5,2)，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3G=(8,3)，4G=(10,2)，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5G=(3,6)，6G=(7,9)，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;7G=(7,2)，8G=(3,5)，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;9G=(10,9)，10G=(8,8)，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;11G=(5,9)，12G=(2,4)，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　       最终得到13G=O，所以加法群的阶为13。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;　　1.选择一个素数p，从而确定有限域GF(p)，将p公开。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2.选择元素a,b∈GF(p)，从而确定一条GF(p)上的椭圆曲线，确定加法交换群E，将a和b公开。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3.选择一个大素数n，并确定一个阶为n的基点G(x,y)，将n和G(x,y)公开。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　4.余因子h=|E|/n，将h公开。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　5.随机选择一个整数d(0&amp;lt;d&amp;lt;n)作为私钥保密。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　6.定义Q=dG作为公钥公开。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;加密&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　1.随机选择一个整数k(0&amp;lt;k&amp;lt;n)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2.计算X&lt;sub&gt;1&lt;/sub&gt;=kG。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3.计算X&lt;sub&gt;2&lt;/sub&gt;=kQ，若x&lt;sub&gt;2&lt;/sub&gt;=∞，则回到第1步。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　4.加密：C=Mx&lt;sub&gt;2&lt;/sub&gt;(mod n)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　5.将(X&lt;sub&gt;1&lt;/sub&gt;,C)作为密文发送。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;解密&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　1.用私钥d求出X&lt;sub&gt;2&lt;/sub&gt;=dX&lt;sub&gt;1&lt;/sub&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2.解密：M=Cx&lt;sub&gt;2&lt;/sub&gt;&lt;sup&gt;-1&lt;/sup&gt;(mod n)。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;推荐椭圆曲线&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　NIST向社会推荐了5条素域GF(p)上随机选取的椭圆曲线：&lt;/span&gt;&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;&lt;span&gt;P-192&lt;/span&gt;&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　p=2&lt;sup&gt;192&lt;/sup&gt;-2&lt;sup&gt;64&lt;/sup&gt;-1&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　a=-3&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　b=64210519 E59C80E7 0FA7E9AB 72243049 FEB8DEEC C146B9B1&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　x=188DA80E B03090F6 7CBf20EB 43A18800 F4FF0AFD 82FF1012&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　y=07192B95 FFC8DA78 631011ED 6B24CDD5 73F977A1 1E794811&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　n=FFFFFFFF FFFFFFFF FFFFFFFF 99DEF836 146BC9B1 B4D22831&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　h=1&lt;/span&gt;&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;&lt;span&gt;P-224&lt;/span&gt;&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　p=2&lt;sup&gt;224&lt;/sup&gt;-2&lt;sup&gt;96&lt;/sup&gt;-1&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　a=-3&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　b=B4050A85 0C04B3AB F5413256 5044B0B7 D7BFD8BA 270B3943 2355FFB4&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　x=B70E0CBD 6BB4BF7F 321390B9 4A03C1D3 56C21122 343280D6 115C1D21&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　y=BD376388 B5F723FB 4C22DFE6 CD4375A0 5A074764 44D58199 85007E34&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　n=FFFFFFFF FFFFFFFF FFFFFFFF FFFF16A2 E0B8F03E 13DD2945 5C5C2A3D&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　h=1&lt;/span&gt;&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;&lt;span&gt;P-256&lt;/span&gt;&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　p=2&lt;sup&gt;256&lt;/sup&gt;-2&lt;sup&gt;224&lt;/sup&gt;+2&lt;sup&gt;192&lt;/sup&gt;+2&lt;sup&gt;96&lt;/sup&gt;-1&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　a=-3&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　b=5AC635D8 AA3A93E7 B3EBBD55 769886BC 651D06B0 CC53B0F6 3BCE3C3E 27D2604B&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　x=6B17D1F2 E12C4247 F8BCE6E5 63A440F2 77037D81 2DEB33A0 F4A13945 D898C296&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　y=4FE342E2 FE1A7F9B 8EE7EB4A 7C0F9E16 2BCE3357 6B315ECE CBB64068 37BF51F5&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　n=FFFFFFFF 00000000 FFFFFFFF FFFFFFFF BCE6FAAD A7179E84 F3B9CAC2 FC632551&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　h=1&lt;/span&gt;&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;&lt;span&gt;P-384&lt;/span&gt;&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　p=2&lt;sup&gt;384&lt;/sup&gt;-2&lt;sup&gt;128&lt;/sup&gt;-2&lt;sup&gt;96&lt;/sup&gt;+2&lt;sup&gt;32&lt;/sup&gt;-1&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　a=-3&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　b=B3312FA7 E23EE7E4 988E056B E3F82D19 181D9C6E FE814112 0314088F 5013875A C656398D 8A2ED19D 2A85C8ED D3EC2AEF&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　x=AA87CA22 BE8B0537 8EB1C71E F320AD74 6E1D3B62 8BA79B98 59F741E0 82542A38 5502F25D BF55296C 3A545E38 72760AB7&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　y=3617DE4A 96262C6F 5D9E98BF 9292DC29 F8F41DBD 289A147C E9DA3113 B5F0B8C0 0A60B1CE 1D7E819D 7A431D7C 90EA0E5F&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　n=FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF C7634D81 F4372DDF 581A0DB2 48B0A77A ECEC196A CCC52973&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　h=1&lt;/span&gt;&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;&lt;span&gt;P-521&lt;/span&gt;&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　p=2&lt;sup&gt;521&lt;/sup&gt;-1&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　a=-3&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　b=00000051 953EB961 8E1C9A1F 929A21A0 B68540EE A2DA725B 99B315F3 B8B48991 8EF109E1 56193951 EC7E937B 1652C0BD 3BB1BF07 3573DF88 3D2C34F1 EF451FD4 6B503F00&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　x=000000C6 858E06B7 0404E9CD 9E3ECB66 2395B442 9C648139 053FB521 F828AF60 6B4D3DBA A14B5E77 EFE75928 FE1DC127 A2FFA8DE 3348B3C1 856A429B F97E7E31 C2E5BD66&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　y=00000118 39296A78 9A3BC004 5C8A5FB4 2C7D1BD9 98F54449 579B4468 17AFBD17 273E662C 97EE7299 5EF42640 C550B901 3FAD0761 353C7086 A272C240 88BE9476 9FD16650&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　n=000001FF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF 51868783 BF2F966B 7FCC0148 F709A5D0 3BB5C9B8 899C47AE BB6FB71E 91386409&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　h=1&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;　　椭圆曲线密码的安全性建立在椭圆曲线离散对数问题的困难性之上。当素数p和n足够大时椭圆曲线密码是安全的。这就要求椭圆曲线解点群的阶要有大素数因子的根本原因，在理想情况下群的阶本身就是一个大素数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　为了确保椭圆曲线密码的安全，应当避免使用弱的椭圆曲线。所谓弱的椭圆曲线主要指超奇异椭圆曲线和反常椭圆曲线。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　椭圆曲线密码的密钥越长，自然越安全，但是技术实现也就越困难，效率也越低。一般认为，在目前的技术水平下采用190~256位的椭圆曲线，其安全性就足够了。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;h2&gt;&lt;span&gt;&lt;span&gt;解点类&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.math.BigInteger;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ECPoint {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    BigInteger x;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    BigInteger y;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ECPoint() {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         x = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         y = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ECPoint(BigInteger x, BigInteger y) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.x =&lt;span&gt; x;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.y =&lt;span&gt; y;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isO()) 
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &quot;O&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &quot;(&quot; + x.toString(16) + &quot;, &quot; + y.toString(16) + &quot;)&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isO() {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (x == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; y == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) 
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;&lt;span&gt;两解点相加&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * 两解点相加
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; p1
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; p2
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;ECPoint add(ECPoint p1, ECPoint p2) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (p1.isO()) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; p2;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (p2.isO()) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; p1;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     ECPoint p3 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ECPoint();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    BigInteger lambda;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (p1.x.compareTo(p2.x) == 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (p1.y.compareTo(p2.y) == 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             lambda = &lt;span&gt;new&lt;/span&gt; BigInteger(&quot;3&quot;).multiply(p1.x.pow(2)).add(a).multiply(&lt;span&gt;new&lt;/span&gt; BigInteger(&quot;2&quot;).multiply(p1.y).modPow(&lt;span&gt;new&lt;/span&gt; BigInteger(&quot;-1&quot;&lt;span&gt;), p)).mod(p);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             p3.x = lambda.pow(2).subtract(&lt;span&gt;new&lt;/span&gt; BigInteger(&quot;2&quot;&lt;span&gt;).multiply(p1.x)).mod(p);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             p3.y =&lt;span&gt; lambda.multiply(p1.x.subtract(p3.x)).subtract(p1.y).mod(p);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; p3;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (p1.y.compareTo(p.subtract(p2.y)) == 0&lt;span&gt;) 
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; p3;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     lambda = p2.y.subtract(p1.y).multiply(p2.x.subtract(p1.x).modPow(&lt;span&gt;new&lt;/span&gt; BigInteger(&quot;-1&quot;&lt;span&gt;), p)).mod(p);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     p3.x = lambda.pow(2&lt;span&gt;).subtract(p1.x).subtract(p2.x).mod(p);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     p3.y =&lt;span&gt; lambda.multiply(p1.x.subtract(p3.x)).subtract(p1.y).mod(p);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; p3;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;倍乘&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * 倍乘
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; p
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; n
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt;  np
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;ECPoint multiply(ECPoint p, BigInteger n) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     ECPoint q = add(p, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ECPoint());
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     ECPoint r = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ECPoint();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (n.and(&lt;span&gt;new&lt;/span&gt; BigInteger(&quot;1&quot;)).intValue() == 1&lt;span&gt;) 
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             r =&lt;span&gt; add(r, q);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         q =&lt;span&gt; add(q, q);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         n = n.shiftRight(1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     } &lt;span&gt;while&lt;/span&gt; (n.intValue() != 0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; r;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;&lt;span&gt;求所有解点&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * 求所有解点
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; List&amp;lt;ECPoint&amp;gt;&lt;span&gt; solutionPoints() {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     List&amp;lt;ECPoint&amp;gt; r = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;ECPoint&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     List&amp;lt;BigInteger&amp;gt; l = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;BigInteger&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (BigInteger y = &lt;span&gt;new&lt;/span&gt; BigInteger(&quot;1&quot;); y.compareTo(p.divide(&lt;span&gt;new&lt;/span&gt; BigInteger(&quot;2&quot;))) != 1; y = y.add(&lt;span&gt;new&lt;/span&gt; BigInteger(&quot;1&quot;&lt;span&gt;))) 
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         l.add(y.modPow(&lt;span&gt;new&lt;/span&gt; BigInteger(&quot;2&quot;&lt;span&gt;), p));
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (BigInteger x = &lt;span&gt;new&lt;/span&gt; BigInteger(&quot;0&quot;); x.compareTo(p) == -1; x = x.add(&lt;span&gt;new&lt;/span&gt; BigInteger(&quot;1&quot;&lt;span&gt;))) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         BigInteger t = x.pow(3&lt;span&gt;).add(a.multiply(x)).add(b).mod(p);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (isExist(t, l) != -1&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             BigInteger y = &lt;span&gt;new&lt;/span&gt; BigInteger(isExist(t, l) + &quot;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             r.add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ECPoint(x, y));
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             r.add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ECPoint(x, p.subtract(y)));
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     r.add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ECPoint());
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; r;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; isExist(BigInteger b, List&amp;lt;BigInteger&amp;gt;&lt;span&gt; l) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; l.size(); i++&lt;span&gt;) 
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (l.get(i).compareTo(b) == 0) &lt;span&gt;return&lt;/span&gt; (i + 1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; -1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;求阶&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * 求阶
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; p  生成元
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt;   p对应的阶
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;BigInteger o(ECPoint p) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     BigInteger r = &lt;span&gt;new&lt;/span&gt; BigInteger(&quot;1&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt; (!&lt;span&gt; p.isO()) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         r = r.add(&lt;span&gt;new&lt;/span&gt; BigInteger(&quot;1&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         p =&lt;span&gt; multiply(p, r);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; r;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;加密&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * 加密
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; M
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;BigInteger[] encrypt(BigInteger M) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    BigInteger k;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    ECPoint X1, X2;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         k = &lt;span&gt;new&lt;/span&gt; BigInteger(n.bitLength(), &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Random());
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     } &lt;span&gt;while&lt;/span&gt; ((X2 = ec.multiply(Q, k)).x == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     X1 =&lt;span&gt; ec.multiply(G, k);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     BigInteger[] C = &lt;span&gt;new&lt;/span&gt; BigInteger[3&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     C[0] =&lt;span&gt; X1.x;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     C[1] =&lt;span&gt; X1.y;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     C[2] =&lt;span&gt; M.multiply(X2.x).mod(n);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; C;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;解密&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * 解密
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; C
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;BigInteger decrypt(BigInteger[] C) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     ECPoint X1 = &lt;span&gt;new&lt;/span&gt; ECPoint(C[0], C[1&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     ECPoint X2 =&lt;span&gt; ec.multiply(X1, d);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     BigInteger M = C[2].multiply(X2.x.modPow(&lt;span&gt;new&lt;/span&gt; BigInteger(&quot;-1&quot;&lt;span&gt;), n)).mod(n);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; M;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;
&lt;h2&gt;&lt;span&gt;测试数据&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　M=1234567890abcdef&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　k=abcdef&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;测试结果&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;P-192&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1582448/201901/1582448-20190126223416707-506749300.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;P-224&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1582448/201901/1582448-20190126223444524-1071421583.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;h3&gt;&lt;span&gt;P-256&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1582448/201901/1582448-20190126223517620-548565659.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;P-384&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1582448/201901/1582448-20190126223550814-1550786638.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;P-521&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1582448/201901/1582448-20190126223610960-1153651329.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;　　张焕国，唐明.密码学引论（第三版）.武汉大学出版社，2015年&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 26 Jan 2019 14:46:00 +0000</pubDate>
<dc:creator>蒙丿鑫</dc:creator>
<og:description>GitHub 椭圆曲线密码 椭圆曲线密码（Elliptic Curve Cryptosystem），简称ECC，是Neal Koblitz和Victor Miller于1985年提出的。 研究发现，有</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mx-lqk/p/10325192.html</dc:identifier>
</item>
<item>
<title>Jmeter 二次开发 将CSV Data Set Config添加从哪一行开始读数据 - 夏天里的Jasmine</title>
<link>http://www.cnblogs.com/qianjinyan/p/9543879.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qianjinyan/p/9543879.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1064427/201808/1064427-20180827175812774-452934253.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;经常遇到性能测试的时候，有100万条数据，才用了5万条，中途因为某些原因停止了，继续用的时候，&lt;/p&gt;
&lt;p&gt;要么要清除DB中数据，要么要清除数据源中的数据，&lt;/p&gt;
&lt;p&gt;觉得特别麻烦，&lt;/p&gt;
&lt;p&gt;希望改写下代码，将&lt;/p&gt;
&lt;pre readability=&quot;6&quot;&gt;
Ignore first line (only used if Variable Names is not empty)&lt;br/&gt;一列变成开始圆形需要选择的行数， StartLineNumber&lt;br/&gt;或者新增一个属性，StartLineNumber，原有的属性不需要更改。&lt;p&gt;看了一下大概涉及的java文件如下：&lt;br/&gt;config目录下的CSVDataSet和CSVDataSetBeanInfo，以及gui页面上的信息，gui又有几个语言版本，都要稍加修改。
&lt;/p&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1064427/201808/1064427-20180827180222291-1075882083.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Core目录下的Services目录下的FileServer， 其中Readline方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1064427/201808/1064427-20180827180419104-1332007655.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;要采取第一种，改写Ignore first line 为StartLineNumber. 我觉得这种比较合理，一个忽略第一行，从第二行开始；另一个直接设置开始的行数。&lt;/p&gt;
&lt;p&gt;初步想法：&lt;/p&gt;
&lt;p&gt;1. 为空，则从第一行开始&lt;/p&gt;
&lt;p&gt;2. 有值，必须在【0，文件的行数-1】区间，从设置的行数开始。&lt;/p&gt;
&lt;p&gt;3. 如果选择Recyle on EOF， 首次从N行开始，接下去从0行开始取值？。。。。【其实从N行开始取值，就不应当可循环】&lt;/p&gt;
&lt;p&gt; &lt;span&gt;&lt;strong&gt;更新20180828， 改好了，如下，有点丑&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1064427/201808/1064427-20180828101848029-1473693207.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;页面布局没有注意，放到了最上面，并且ignoreFirstLine没有去除&lt;/p&gt;
&lt;p&gt;自己测试了下，用了一个BeanShell Sampler&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1064427/201808/1064427-20180828101957330-1658908047.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;查看结果树看到的确是从20开始取值的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1064427/201808/1064427-20180828102031796-982883764.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;修改的代码：&lt;/p&gt;
&lt;pre&gt;
CSVDataSet
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;87&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

package org.apache.jmeter.config;

import java.beans.BeanInfo;
import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.io.IOException;
import java.util.ResourceBundle;

import org.apache.commons.lang3.StringUtils;
import org.apache.jmeter.engine.event.LoopIterationEvent;
import org.apache.jmeter.engine.event.LoopIterationListener;
import org.apache.jmeter.engine.util.NoConfigMerge;
import org.apache.jmeter.gui.GUIMenuSortOrder;
import org.apache.jmeter.save.CSVSaveService;
import org.apache.jmeter.services.FileServer;
import org.apache.jmeter.testbeans.TestBean;
import org.apache.jmeter.testbeans.gui.GenericTestBeanCustomizer;
import org.apache.jmeter.testelement.property.JMeterProperty;
import org.apache.jmeter.testelement.property.StringProperty;
import org.apache.jmeter.threads.JMeterContext;
import org.apache.jmeter.threads.JMeterVariables;
import org.apache.jmeter.util.JMeterUtils;
import org.apache.jorphan.util.JMeterStopThreadException;
import org.apache.jorphan.util.JOrphanUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Read lines from a file and split int variables.
 *
 * The iterationStart() method is used to set up each set of values.
 *
 * By default, the same file is shared between all threads
 * (and other thread groups, if they use the same file name).
 *
 * The shareMode can be set to:
 * &amp;lt;ul&amp;gt;
 * &amp;lt;li&amp;gt;All threads - default, as described above&amp;lt;/li&amp;gt;
 * &amp;lt;li&amp;gt;Current thread group&amp;lt;/li&amp;gt;
 * &amp;lt;li&amp;gt;Current thread&amp;lt;/li&amp;gt;
 * &amp;lt;li&amp;gt;Identifier - all threads sharing the same identifier&amp;lt;/li&amp;gt;
 * &amp;lt;/ul&amp;gt;
 *
 * The class uses the FileServer alias mechanism to provide the different share modes.
 * For all threads, the file alias is set to the file name.
 * Otherwise, a suffix is appended to the filename to make it unique within the required context.
 * For current thread group, the thread group identityHashcode is used;
 * for individual threads, the thread hashcode is used as the suffix.
 * Or the user can provide their own suffix, in which case the file is shared between all
 * threads with the same suffix.
 *
 */
@GUIMenuSortOrder(1)
public class CSVDataSet extends ConfigTestElement
        implements TestBean, LoopIterationListener, NoConfigMerge {
    private static final Logger log = LoggerFactory.getLogger(CSVDataSet.class);

    private static final long serialVersionUID = 233L;

    private static final String EOFVALUE = // value to return at EOF
            JMeterUtils.getPropDefault(&quot;csvdataset.eofstring&quot;, &quot;&amp;lt;EOF&amp;gt;&quot;); //$NON-NLS-1$ //$NON-NLS-2$

    private transient String filename;

    private transient String fileEncoding;

    private transient String variableNames;

    private transient String delimiter;

    private transient boolean quoted;

    private transient boolean recycle = true;

    private transient boolean stopThread;

    private transient String[] vars;

    private transient String alias;
    private transient String linenumber;

    private transient String shareMode;

    private boolean firstLineIsNames = false;

    private boolean ignoreFirstLine = false;

    private Object readResolve(){
        recycle = true;
        return this;
    }

    /**
     * Override the setProperty method in order to convert
     * the original String shareMode property.
     * This used the locale-dependent display value, so caused
     * problems when the language was changed.
     * If the &quot;shareMode&quot; value matches a resource value then it is converted
     * into the resource key.
     * To reduce the need to look up resources, we only attempt to
     * convert values with spaces in them, as these are almost certainly
     * not variables (and they are definitely not resource keys).
     */
    @Override
    public void setProperty(JMeterProperty property) {
        if (property instanceof StringProperty) {
            final String propName = property.getName();
            if (&quot;shareMode&quot;.equals(propName)) { // The original name of the property
                final String propValue = property.getStringValue();
                if (propValue.contains(&quot; &quot;)){ // variables are unlikely to contain spaces, so most likely a translation
                    try {
                        final BeanInfo beanInfo = Introspector.getBeanInfo(this.getClass());
                        final ResourceBundle rb = (ResourceBundle) beanInfo.getBeanDescriptor().getValue(GenericTestBeanCustomizer.RESOURCE_BUNDLE);
                        for(String resKey : CSVDataSetBeanInfo.getShareTags()) {
                            if (propValue.equals(rb.getString(resKey))) {
                                if (log.isDebugEnabled()) {
                                    log.debug(&quot;Converted {}={} to {} using Locale: {}&quot;, propName, propValue, resKey, rb.getLocale());
                                }
                                ((StringProperty) property).setValue(resKey); // reset the value
                                super.setProperty(property);
                                return;
                            }
                        }
                        // This could perhaps be a variable name
                        log.warn(&quot;Could not translate {}={} using Locale: {}&quot;, propName, propValue, rb.getLocale());
                    } catch (IntrospectionException e) {
                        log.error(&quot;Could not find BeanInfo; cannot translate shareMode entries&quot;, e);
                    }
                }
            }
        }
        super.setProperty(property);
    }

    @Override
    public void iterationStart(LoopIterationEvent iterEvent) {
        FileServer server = FileServer.getFileServer();
        final JMeterContext context = getThreadContext();
        String delim = getDelimiter();
        if (&quot;\\t&quot;.equals(delim)) { // $NON-NLS-1$
            delim = &quot;\t&quot;;// Make it easier to enter a Tab // $NON-NLS-1$
        } else if (delim.isEmpty()){
            log.debug(&quot;Empty delimiter, will use ','&quot;);
            delim=&quot;,&quot;;
        }
        if (vars == null) {
            String fileName = getFilename().trim();
            String mode = getShareMode();
            int modeInt = CSVDataSetBeanInfo.getShareModeAsInt(mode);
            switch(modeInt){
                case CSVDataSetBeanInfo.SHARE_ALL:
                    alias = fileName;
                    break;
                case CSVDataSetBeanInfo.SHARE_GROUP:
                    alias = fileName+&quot;@&quot;+System.identityHashCode(context.getThreadGroup());
                    break;
                case CSVDataSetBeanInfo.SHARE_THREAD:
                    alias = fileName+&quot;@&quot;+System.identityHashCode(context.getThread());
                    break;
                default:
                    alias = fileName+&quot;@&quot;+mode; // user-specified key
                    break;
            }
            final String names = getVariableNames();
            if (StringUtils.isEmpty(names)) {
                String header = server.reserveFile(fileName, getFileEncoding(), alias, true);
                try {
                    vars = CSVSaveService.csvSplitString(header, delim.charAt(0));
                    firstLineIsNames = true;
                } catch (IOException e) {
                    throw new IllegalArgumentException(&quot;Could not split CSV header line from file:&quot; + fileName,e);
                }
            } else {
                server.reserveFile(fileName, getFileEncoding(), alias, ignoreFirstLine);
                vars = JOrphanUtils.split(names, &quot;,&quot;); // $NON-NLS-1$
            }
            trimVarNames(vars);
        }

        // TODO: fetch this once as per vars above?
        JMeterVariables threadVars = context.getVariables();
        String[] lineValues = {};
        try {
            if (getQuotedData()) {
                lineValues = server.getParsedLine(alias, recycle,linenumber, delim.charAt(0));
            } else {
                //String line = server.readLine(alias, recycle,firstLineIsNames || ignoreFirstLine);
                String line = server.readLine(alias, recycle,linenumber);
                lineValues = JOrphanUtils.split(line, delim, false);
            }
            for (int a = 0; a &amp;lt; vars.length &amp;amp;&amp;amp; a &amp;lt; lineValues.length; a++) {
                threadVars.put(vars[a], lineValues[a]);
            }
        } catch (IOException e) { // treat the same as EOF
            log.error(e.toString());
        }
        if (lineValues.length == 0) {// i.e. EOF
            if (getStopThread()) {
                throw new JMeterStopThreadException(&quot;End of file:&quot;+ getFilename()+&quot; detected for CSV DataSet:&quot;
                        +getName()+&quot; configured with stopThread:&quot;+ getStopThread()+&quot;, recycle:&quot; + getRecycle());
            }
            for (String var :vars) {
                threadVars.put(var, EOFVALUE);
            }
        }
    }

    /**
     * trim content of array varNames
     * @param varsNames
     */
    private void trimVarNames(String[] varsNames) {
        for (int i = 0; i &amp;lt; varsNames.length; i++) {
            varsNames[i] = varsNames[i].trim();
        }
    }

    /**
     * @return Returns the filename.
     */
    public String getFilename() {
        return filename;
    }

    public String getLinenumber() {
        return linenumber;
    }

    public void setLinenumber(String linenumber) {
        this.linenumber = linenumber;
    }

    /**
     * @param filename
     *            The filename to set.
     */
    public void setFilename(String filename) {
        this.filename = filename;
    }

    /**
     * @return Returns the file encoding.
     */
    public String getFileEncoding() {
        return fileEncoding;
    }

    /**
     * @param fileEncoding
     *            The fileEncoding to set.
     */
    public void setFileEncoding(String fileEncoding) {
        this.fileEncoding = fileEncoding;
    }

    /**
     * @return Returns the variableNames.
     */
    public String getVariableNames() {
        return variableNames;
    }

    /**
     * @param variableNames
     *            The variableNames to set.
     */
    public void setVariableNames(String variableNames) {
        this.variableNames = variableNames;
    }

    public String getDelimiter() {
        return delimiter;
    }

    public void setDelimiter(String delimiter) {
        this.delimiter = delimiter;
    }

    public boolean getQuotedData() {
        return quoted;
    }

    public void setQuotedData(boolean quoted) {
        this.quoted = quoted;
    }

    public boolean getRecycle() {
        return recycle;
    }

    public void setRecycle(boolean recycle) {
        this.recycle = recycle;
    }

    public boolean getStopThread() {
        return stopThread;
    }

    public void setStopThread(boolean value) {
        this.stopThread = value;
    }

    public String getShareMode() {
        return shareMode;
    }

    public void setShareMode(String value) {
        this.shareMode = value;
    }

    /**
     * @return the ignoreFirstLine
     */
    public boolean isIgnoreFirstLine() {
        return ignoreFirstLine;
    }

    /**
     * @param ignoreFirstLine the ignoreFirstLine to set
     */
    public void setIgnoreFirstLine(boolean ignoreFirstLine) {
        this.ignoreFirstLine = ignoreFirstLine;
    }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;pre&gt;
CSVDataSetBeanInfo
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;86&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

package org.apache.jmeter.config;

import java.beans.PropertyDescriptor;

import org.apache.jmeter.testbeans.BeanInfoSupport;
import org.apache.jmeter.testbeans.gui.FileEditor;
import org.apache.jmeter.testbeans.gui.TypeEditor;
import org.apache.jmeter.util.JMeterUtils;
import org.apache.jorphan.util.JOrphanUtils;

public class CSVDataSetBeanInfo extends BeanInfoSupport {

    // These names must agree case-wise with the variable and property names
    private static final String FILENAME = &quot;filename&quot;;               //$NON-NLS-1$
    private static final String FILE_ENCODING = &quot;fileEncoding&quot;;      //$NON-NLS-1$
    private static final String VARIABLE_NAMES = &quot;variableNames&quot;;    //$NON-NLS-1$
    private static final String IGNORE_FIRST_LINE = &quot;ignoreFirstLine&quot;;    //$NON-NLS-1$
    private static final String DELIMITER = &quot;delimiter&quot;;             //$NON-NLS-1$
    private static final String RECYCLE = &quot;recycle&quot;;                 //$NON-NLS-1$
    private static final String STOPTHREAD = &quot;stopThread&quot;;           //$NON-NLS-1$
    private static final String QUOTED_DATA = &quot;quotedData&quot;;          //$NON-NLS-1$
    private static final String SHAREMODE = &quot;shareMode&quot;;             //$NON-NLS-1$
    private static final String LINE_NUMBER = &quot;linenumber&quot;;

    // Access needed from CSVDataSet
    private static final String[] SHARE_TAGS = new String[3];
    static final int SHARE_ALL    = 0;
    static final int SHARE_GROUP  = 1;
    static final int SHARE_THREAD = 2;

    // Store the resource keys
    static {
        SHARE_TAGS[SHARE_ALL]    = &quot;shareMode.all&quot;; //$NON-NLS-1$
        SHARE_TAGS[SHARE_GROUP]  = &quot;shareMode.group&quot;; //$NON-NLS-1$
        SHARE_TAGS[SHARE_THREAD] = &quot;shareMode.thread&quot;; //$NON-NLS-1$
    }

    public CSVDataSetBeanInfo() {
        super(CSVDataSet.class);

        createPropertyGroup(&quot;csv_data&quot;,             //$NON-NLS-1$
                new String[] { FILENAME, FILE_ENCODING, VARIABLE_NAMES,
                        IGNORE_FIRST_LINE, DELIMITER, QUOTED_DATA,
                        RECYCLE, STOPTHREAD, SHAREMODE });

        PropertyDescriptor p = property(FILENAME);
        p.setValue(NOT_UNDEFINED, Boolean.TRUE);
        p.setValue(DEFAULT, &quot;&quot;);        //$NON-NLS-1$
        p.setValue(NOT_EXPRESSION, Boolean.TRUE);
        p.setPropertyEditorClass(FileEditor.class);

        p = property(FILE_ENCODING, TypeEditor.ComboStringEditor);
        p.setValue(NOT_UNDEFINED, Boolean.TRUE);
        p.setValue(DEFAULT, &quot;&quot;);        //$NON-NLS-1$
        p.setValue(TAGS, getListFileEncoding());

        p = property(VARIABLE_NAMES);
        p.setValue(NOT_UNDEFINED, Boolean.TRUE);
        p.setValue(DEFAULT, &quot;&quot;);        //$NON-NLS-1$
        p.setValue(NOT_EXPRESSION, Boolean.TRUE);

        p = property(IGNORE_FIRST_LINE);
        p.setValue(NOT_UNDEFINED, Boolean.TRUE);
        p.setValue(DEFAULT, Boolean.FALSE);

        //添加LINE_number的配置
        p = property(LINE_NUMBER);
        p.setValue(NOT_UNDEFINED, Boolean.TRUE);
        p.setValue(DEFAULT, &quot;&quot;);
        p.setValue(NOT_EXPRESSION, Boolean.TRUE);

        p = property(DELIMITER);
        p.setValue(NOT_UNDEFINED, Boolean.TRUE);
        p.setValue(DEFAULT, &quot;,&quot;);        //$NON-NLS-1$
        p.setValue(NOT_EXPRESSION, Boolean.TRUE);

        p = property(QUOTED_DATA);
        p.setValue(NOT_UNDEFINED, Boolean.TRUE);
        p.setValue(DEFAULT, Boolean.FALSE);

        p = property(RECYCLE);
        p.setValue(NOT_UNDEFINED, Boolean.TRUE);
        p.setValue(DEFAULT, Boolean.TRUE);

        p = property(STOPTHREAD);
        p.setValue(NOT_UNDEFINED, Boolean.TRUE);
        p.setValue(DEFAULT, Boolean.FALSE);

        p = property(SHAREMODE, TypeEditor.ComboStringEditor);
        p.setValue(RESOURCE_BUNDLE, getBeanDescriptor().getValue(RESOURCE_BUNDLE));
        p.setValue(NOT_UNDEFINED, Boolean.TRUE);
        p.setValue(DEFAULT, SHARE_TAGS[SHARE_ALL]);
        p.setValue(NOT_OTHER, Boolean.FALSE);
        p.setValue(NOT_EXPRESSION, Boolean.FALSE);
        p.setValue(TAGS, SHARE_TAGS);
    }

    public static int getShareModeAsInt(String mode) {
        if (mode == null || mode.length() == 0){
            return SHARE_ALL; // default (e.g. if test plan does not have definition)
        }
        for (int i = 0; i &amp;lt; SHARE_TAGS.length; i++) {
            if (SHARE_TAGS[i].equals(mode)) {
                return i;
            }
        }
        return -1;
    }

    /**
     * @return array of String for possible sharing modes
     */
    public static String[] getShareTags() {
        String[] copy = new String[SHARE_TAGS.length];
        System.arraycopy(SHARE_TAGS, 0, copy, 0, SHARE_TAGS.length);
        return copy;
    }

    /**
     * Get the mains file encoding
     * list from https://docs.oracle.com/javase/8/docs/technotes/guides/intl/encoding.doc.html
     * @return a String[] with the list of file encoding
     */
    private String[] getListFileEncoding() {
        return JOrphanUtils.split(JMeterUtils.getPropDefault(&quot;csvdataset.file.encoding_list&quot;, &quot;&quot;), &quot;|&quot;); //$NON-NLS-1$
    }

}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; CSVDataSetResources.properties&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
#   Licensed to the Apache Software Foundation (ASF) under one or more
#   contributor license agreements.  See the NOTICE file distributed with
#   this work for additional information regarding copyright ownership.
#   The ASF licenses this file to You under the Apache License, Version 2.0
#   (the &quot;License&quot;); you may not use this file except in compliance with
#   the License.  You may obtain a copy of the License at
# 
#       http://www.apache.org/licenses/LICENSE-2.0
# 
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#   LINE_NUMBER=StartFromLineNumber

displayName=CSV Data Set Config
csv_data.displayName=Configure the CSV Data Source
filename.displayName=Filename
filename.shortDescription=Name of the file that holds the cvs data (relative or absolute filename)
fileEncoding.displayName=File encoding
fileEncoding.shortDescription=The character set encoding used in the file
#   ignoreFirstLine.displayName=Ignore first line (only used if Variable Names is not empty)
linenumber.displayName=StartFromLineNumber
linenumber.shortDescription=if linenumber blank, all the data would be involved;if linenum has value N, will read data from row N
#   ignoreFirstLine.shortDescription=Ignore first line of CSV file, it will only be used used if Variable Names is not empty, if Variable Names is empty the first line must contain the headers.
variableNames.displayName=Variable Names (comma-delimited)
variableNames.shortDescription=List your variable names in order to match the order of columns in your csv data. Keep it empty to use the first line of the file for variable names.
delimiter.displayName=Delimiter (use '\\t' for tab)
delimiter.shortDescription=Enter the delimiter ('\\t' for tab)
quotedData.displayName=Allow quoted data?
quotedData.shortDescription=Allow CSV data values to be quoted?
recycle.displayName=Recycle on EOF ?
recycle.shortDescription=Should the file be re-read from the start on reaching EOF ?
stopThread.displayName=Stop thread on EOF ?
stopThread.shortDescription=Should the thread be stopped on reaching EOF (if Recycle is false) ?
shareMode.displayName=Sharing mode
shareMode.shortDescription=Select which threads share the same file pointer
shareMode.all=All threads
shareMode.group=Current thread group
shareMode.thread=Current thread
&lt;/pre&gt;&lt;/div&gt;

&lt;pre&gt;
FileServer
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;133&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 */

package org.apache.jmeter.services;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.Closeable;
import java.io.EOFException;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.Reader;
import java.io.Writer;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ThreadLocalRandom;

import org.apache.commons.collections.ArrayStack;
import org.apache.jmeter.gui.JMeterFileFilter;
import org.apache.jmeter.save.CSVSaveService;
import org.apache.jmeter.util.JMeterUtils;
import org.apache.jorphan.util.JOrphanUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * This class provides thread-safe access to files, and to
 * provide some simplifying assumptions about where to find files and how to
 * name them. For instance, putting supporting files in the same directory as
 * the saved test plan file allows users to refer to the file with just it's
 * name - this FileServer class will find the file without a problem.
 * Eventually, I want all in-test file access to be done through here, with the
 * goal of packaging up entire test plans as a directory structure that can be
 * sent via rmi to remote servers (currently, one must make sure the remote
 * server has all support files in a relative-same location) and to package up
 * test plans to execute on unknown boxes that only have Java installed.
 */
public class FileServer {

    private static final Logger log = LoggerFactory.getLogger(FileServer.class);

    /**
     * The default base used for resolving relative files, i.e.&amp;lt;br/&amp;gt;
     * {@code System.getProperty(&quot;user.dir&quot;)}
     */
    private static final String DEFAULT_BASE = System.getProperty(&quot;user.dir&quot;);// $NON-NLS-1$

    /** Default base prefix: {@value} */
    private static final String BASE_PREFIX_DEFAULT = &quot;~/&quot;; // $NON-NLS-1$

    private static final String BASE_PREFIX =
            JMeterUtils.getPropDefault(&quot;jmeter.save.saveservice.base_prefix&quot;, // $NON-NLS-1$
                    BASE_PREFIX_DEFAULT);

    private File base;

    private final Map&amp;lt;String, FileEntry&amp;gt; files = new HashMap&amp;lt;&amp;gt;();

    private static final FileServer server = new FileServer();

    // volatile needed to ensure safe publication
    private volatile String scriptName;

    // Cannot be instantiated
    private FileServer() {
        base = new File(DEFAULT_BASE);
        log.info(&quot;Default base='{}'&quot;, DEFAULT_BASE);
    }

    /**
     * @return the singleton instance of the server.
     */
    public static FileServer getFileServer() {
        return server;
    }

    /**
     * Resets the current base to {@link #DEFAULT_BASE}.
     */
    public synchronized void resetBase() {
        checkForOpenFiles();
        base = new File(DEFAULT_BASE);
        log.info(&quot;Reset base to '{}'&quot;, base);
    }

    /**
     * Sets the current base directory for relative file names from the provided path.
     * If the path does not refer to an existing directory, then its parent is used.
     * Normally the provided path is a file, so using the parent directory is appropriate.
     *
     * @param basedir the path to set, or {@code null} if the GUI is being cleared
     * @throws IllegalStateException if files are still open
     */
    public synchronized void setBasedir(String basedir) {
        checkForOpenFiles(); // TODO should this be called if basedir == null?
        if (basedir != null) {
            File newBase = new File(basedir);
            if (!newBase.isDirectory()) {
                newBase = newBase.getParentFile();
            }
            base = newBase;
            log.info(&quot;Set new base='{}'&quot;, base);
        }
    }

    /**
     * Sets the current base directory for relative file names from the provided script file.
     * The parameter is assumed to be the path to a JMX file, so the base directory is derived
     * from its parent.
     *
     * @param scriptPath the path of the script file; must be not be {@code null}
     * @throws IllegalStateException if files are still open
     * @throws IllegalArgumentException if scriptPath parameter is null
     */
    public synchronized void setBaseForScript(File scriptPath) {
        if (scriptPath == null){
            throw new IllegalArgumentException(&quot;scriptPath must not be null&quot;);
        }
        setScriptName(scriptPath.getName());
        // getParentFile() may not work on relative paths
        setBase(scriptPath.getAbsoluteFile().getParentFile());
    }

    /**
     * Sets the current base directory for relative file names.
     *
     * @param jmxBase the path of the script file base directory, cannot be null
     * @throws IllegalStateException if files are still open
     * @throws IllegalArgumentException if {@code basepath} is null
     */
    public synchronized void setBase(File jmxBase) {
        if (jmxBase == null) {
            throw new IllegalArgumentException(&quot;jmxBase must not be null&quot;);
        }
        checkForOpenFiles();
        base = jmxBase;
        log.info(&quot;Set new base='{}'&quot;, base);
    }

    /**
     * Check if there are entries in use.
     * &amp;lt;p&amp;gt;
     * Caller must ensure that access to the files map is single-threaded as
     * there is a window between checking the files Map and clearing it.
     *
     * @throws IllegalStateException if there are any entries still in use
     */
    private void checkForOpenFiles() throws IllegalStateException {
        if (filesOpen()) { // checks for entries in use
            throw new IllegalStateException(&quot;Files are still open, cannot change base directory&quot;);
        }
        files.clear(); // tidy up any unused entries
    }

    public synchronized String getBaseDir() {
        return base.getAbsolutePath();
    }

    public static String getDefaultBase(){
        return DEFAULT_BASE;
    }

    /**
     * Calculates the relative path from {@link #DEFAULT_BASE} to the current base,
     * which must be the same as or a child of the default.
     *
     * @return the relative path, or {@code &quot;.&quot;} if the path cannot be determined
     */
    public synchronized File getBaseDirRelative() {
        // Must first convert to absolute path names to ensure parents are available
        File parent = new File(DEFAULT_BASE).getAbsoluteFile();
        File f = base.getAbsoluteFile();
        ArrayStack l = new ArrayStack();
        while (f != null) {
            if (f.equals(parent)){
                if (l.isEmpty()){
                    break;
                }
                File rel = new File((String) l.pop());
                while(!l.isEmpty()) {
                    rel = new File(rel, (String) l.pop());
                }
                return rel;
            }
            l.push(f.getName());
            f = f.getParentFile();
        }
        return new File(&quot;.&quot;);
    }

    /**
     * Creates an association between a filename and a File inputOutputObject,
     * and stores it for later use - unless it is already stored.
     *
     * @param filename - relative (to base) or absolute file name (must not be null)
     */
    public void reserveFile(String filename) {
        reserveFile(filename,null);
    }

    /**
     * Creates an association between a filename and a File inputOutputObject,
     * and stores it for later use - unless it is already stored.
     *
     * @param filename - relative (to base) or absolute file name (must not be null)
     * @param charsetName - the character set encoding to use for the file (may be null)
     */
    public void reserveFile(String filename, String charsetName) {
        reserveFile(filename, charsetName, filename, false);
    }

    /**
     * Creates an association between a filename and a File inputOutputObject,
     * and stores it for later use - unless it is already stored.
     *
     * @param filename - relative (to base) or absolute file name (must not be null)
     * @param charsetName - the character set encoding to use for the file (may be null)
     * @param alias - the name to be used to access the object (must not be null)
     */
    public void reserveFile(String filename, String charsetName, String alias) {
        reserveFile(filename, charsetName, alias, false);
    }

    /**
     * Creates an association between a filename and a File inputOutputObject,
     * and stores it for later use - unless it is already stored.
     *
     * @param filename - relative (to base) or absolute file name (must not be null or empty)
     * @param charsetName - the character set encoding to use for the file (may be null)
     * @param alias - the name to be used to access the object (must not be null)
     * @param hasHeader true if the file has a header line describing the contents
     * @return the header line; may be null
     * @throws IllegalArgumentException if header could not be read or filename is null or empty
     */
    public synchronized String reserveFile(String filename, String charsetName, String alias, boolean hasHeader) {
        if (filename == null || filename.isEmpty()){
            throw new IllegalArgumentException(&quot;Filename must not be null or empty&quot;);
        }
        if (alias == null){
            throw new IllegalArgumentException(&quot;Alias must not be null&quot;);
        }
        FileEntry fileEntry = files.get(alias);
        if (fileEntry == null) {
            fileEntry = new FileEntry(resolveFileFromPath(filename), null, charsetName);
            if (filename.equals(alias)){
                log.info(&quot;Stored: {}&quot;, filename);
            } else {
                log.info(&quot;Stored: {} Alias: {}&quot;, filename, alias);
            }
            files.put(alias, fileEntry);
            if (hasHeader) {
                try {
                    fileEntry.headerLine = readLine(alias, false);
                    if (fileEntry.headerLine == null) {
                        fileEntry.exception = new EOFException(&quot;File is empty: &quot; + fileEntry.file);
                    }
                } catch (IOException | IllegalArgumentException e) {
                    fileEntry.exception = e;
                }
            }
        }
        if (hasHeader &amp;amp;&amp;amp; fileEntry.headerLine == null) {
            throw new IllegalArgumentException(&quot;Could not read file header line for file &quot; + filename,
                    fileEntry.exception);
        }
        return fileEntry.headerLine;
    }

    /**
     * Resolves file name into {@link File} instance.
     * When filename is not absolute and not found from current working dir,
     * it tries to find it under current base directory
     * @param filename original file name
     * @return {@link File} instance
     */
    private File resolveFileFromPath(String filename) {
        File f = new File(filename);
        if (f.isAbsolute() || f.exists()) {
            return f;
        } else {
            return new File(base, filename);
        }
    }

    /**
     * Get the next line of the named file, recycle by default.
     *
     * @param filename the filename or alias that was used to reserve the file
     * @return String containing the next line in the file
     * @throws IOException when reading of the file fails, or the file was not reserved properly
     */
    public String readLine(String filename) throws IOException {
        return readLine(filename, true);
    }

    /**
     * Get the next line of the named file, first line is name to false
     *
     * @param filename the filename or alias that was used to reserve the file
     * @param recycle - should file be restarted at EOF?
     * @return String containing the next line in the file (null if EOF reached and not recycle)
     * @throws IOException when reading of the file fails, or the file was not reserved properly
     */
    public String readLine(String filename, boolean recycle) throws IOException {
        return readLine(filename, recycle, &quot;1&quot;);
    }
    /**
     * Get the next line of the named file
     *
     * @param filename the filename or alias that was used to reserve the file
     * @param recycle - should file be restarted at EOF?
     * //@param ignoreFirstLine - Ignore first line
     * @return String containing the next line in the file (null if EOF reached and not recycle)
     * @throws IOException when reading of the file fails, or the file was not reserved properly
     */
    public synchronized String readLine(String filename, boolean recycle,String linenum) throws IOException {
        FileEntry fileEntry = files.get(filename);
        String line =&quot;&quot;;
        if (fileEntry != null) {
            if (fileEntry.inputOutputObject == null) {
                fileEntry.inputOutputObject = createBufferedReader(fileEntry);
                BufferedReader reader = (BufferedReader) fileEntry.inputOutputObject;
                if(linenum!=&quot;&quot;){
                    for(int i=0;i&amp;lt;Integer.parseInt(linenum)-1;i++){
                        reader.readLine();
                    }
                }
            } else if (!(fileEntry.inputOutputObject instanceof Reader)) {
                throw new IOException(&quot;File &quot; + filename + &quot; already in use&quot;);
            }
            BufferedReader reader = (BufferedReader) fileEntry.inputOutputObject;
            line = reader.readLine();
            if (line == null &amp;amp;&amp;amp; recycle) {
                reader.close();
                reader = createBufferedReader(fileEntry);
                fileEntry.inputOutputObject = reader;
                //if (ignoreFirstLine) {
                    // read first line and forget
                  //  reader.readLine();//NOSONAR
                //}
                line = reader.readLine();
            }
            log.debug(&quot;Read:{}&quot;, line);
            return line;
        }
        throw new IOException(&quot;File never reserved: &quot;+filename);
    }

    /**
     *
     * @param alias the file name or alias
     * @param recycle whether the file should be re-started on EOF
    // * @param ignoreFirstLine whether the file contains a file header which will be ignored
     * @param delim the delimiter to use for parsing
     * @return the parsed line, will be empty if the file is at EOF
     * @throws IOException when reading of the aliased file fails, or the file was not reserved properly
     */
    public synchronized String[] getParsedLine(String alias, boolean recycle, String linenum, char delim) throws IOException {
        BufferedReader reader = getReader(alias, recycle, linenum);
        return CSVSaveService.csvReadFile(reader, delim);
    }

    /**
     * Return BufferedReader handling close if EOF reached and recycle is true
     * and ignoring first line if ignoreFirstLine is true
     *
     * @param alias           String alias
     * @param recycle         Recycle at eof
     //* @param ignoreFirstLine Ignore first line
     * @return {@link BufferedReader}
     */
    private BufferedReader getReader(String alias, boolean recycle, String linenum) throws IOException {
        FileEntry fileEntry = files.get(alias);
        if (fileEntry != null) {
            BufferedReader reader;
            if (fileEntry.inputOutputObject == null) {
                reader = createBufferedReader(fileEntry);
                fileEntry.inputOutputObject = reader;
                 if(linenum!=&quot;&quot;){
                    for(int i=0;i&amp;lt;Integer.parseInt(linenum)-1;i++){
                        reader.readLine();
                    }
                 }
            } else if (!(fileEntry.inputOutputObject instanceof Reader)) {
                throw new IOException(&quot;File &quot; + alias + &quot; already in use&quot;);
            } else {
                reader = (BufferedReader) fileEntry.inputOutputObject;
                if (recycle) { // need to check if we are at EOF already
                    reader.mark(1);
                    int peek = reader.read();
                    if (peek == -1) { // already at EOF
                        reader.close();
                        reader = createBufferedReader(fileEntry);
                        fileEntry.inputOutputObject = reader;
                        if(linenum!=&quot;&quot;){
                            for(int i=0;i&amp;lt;Integer.parseInt(linenum)-1;i++){
                                reader.readLine();
                            }
                        }
                    } else { // OK, we still have some data, restore it
                        reader.reset();
                    }
                }
            }
            return reader;
        } else {
            throw new IOException(&quot;File never reserved: &quot;+alias);
        }
    }

    private BufferedReader createBufferedReader(FileEntry fileEntry) throws IOException {
        if (!fileEntry.file.canRead() || !fileEntry.file.isFile()) {
            throw new IllegalArgumentException(&quot;File &quot;+ fileEntry.file.getName()+ &quot; must exist and be readable&quot;);
        }
        FileInputStream fis = new FileInputStream(fileEntry.file);
        InputStreamReader isr = null;
        // If file encoding is specified, read using that encoding, otherwise use default platform encoding
        String charsetName = fileEntry.charSetEncoding;
        if(!JOrphanUtils.isBlank(charsetName)) {
            isr = new InputStreamReader(fis, charsetName);
        } else {
            isr = new InputStreamReader(fis);
        }
        return new BufferedReader(isr);
    }

    public synchronized void write(String filename, String value) throws IOException {
        FileEntry fileEntry = files.get(filename);
        if (fileEntry != null) {
            if (fileEntry.inputOutputObject == null) {
                fileEntry.inputOutputObject = createBufferedWriter(fileEntry);
            } else if (!(fileEntry.inputOutputObject instanceof Writer)) {
                throw new IOException(&quot;File &quot; + filename + &quot; already in use&quot;);
            }
            BufferedWriter writer = (BufferedWriter) fileEntry.inputOutputObject;
            log.debug(&quot;Write:{}&quot;, value);
            writer.write(value);
        } else {
            throw new IOException(&quot;File never reserved: &quot;+filename);
        }
    }

    private BufferedWriter createBufferedWriter(FileEntry fileEntry) throws IOException {
        FileOutputStream fos = new FileOutputStream(fileEntry.file);
        OutputStreamWriter osw;
        // If file encoding is specified, write using that encoding, otherwise use default platform encoding
        String charsetName = fileEntry.charSetEncoding;
        if(!JOrphanUtils.isBlank(charsetName)) {
            osw = new OutputStreamWriter(fos, charsetName);
        } else {
            osw = new OutputStreamWriter(fos);
        }
        return new BufferedWriter(osw);
    }

    public synchronized void closeFiles() throws IOException {
        for (Map.Entry&amp;lt;String, FileEntry&amp;gt; me : files.entrySet()) {
            closeFile(me.getKey(),me.getValue() );
        }
        files.clear();
    }

    /**
     * @param name the name or alias of the file to be closed
     * @throws IOException when closing of the aliased file fails
     */
    public synchronized void closeFile(String name) throws IOException {
        FileEntry fileEntry = files.get(name);
        closeFile(name, fileEntry);
    }

    private void closeFile(String name, FileEntry fileEntry) throws IOException {
        if (fileEntry != null &amp;amp;&amp;amp; fileEntry.inputOutputObject != null) {
            log.info(&quot;Close: {}&quot;, name);
            fileEntry.inputOutputObject.close();
            fileEntry.inputOutputObject = null;
        }
    }

    boolean filesOpen() { // package access for test code only
        return files.values().stream()
                .anyMatch(fileEntry -&amp;gt; fileEntry.inputOutputObject != null);
    }

    /**
     * Method will get a random file in a base directory
     * &amp;lt;p&amp;gt;
     * TODO hey, not sure this method belongs here.
     * FileServer is for thread safe File access relative to current test's base directory.
     *
     * @param basedir    name of the directory in which the files can be found
     * @param extensions array of allowed extensions, if &amp;lt;code&amp;gt;null&amp;lt;/code&amp;gt; is given,
     *                   any file be allowed
     * @return a random File from the &amp;lt;code&amp;gt;basedir&amp;lt;/code&amp;gt; that matches one of
     * the extensions
     */
    public File getRandomFile(String basedir, String[] extensions) {
        File input = null;
        if (basedir != null) {
            File src = new File(basedir);
            File[] lfiles = src.listFiles(new JMeterFileFilter(extensions));
            if (lfiles != null) {
                // lfiles cannot be null as it has been checked before
                int count = lfiles.length;
                input = lfiles[ThreadLocalRandom.current().nextInt(count)];
            }
        }
        return input;
    }

    /**
     * Get {@link File} instance for provided file path,
     * resolve file location relative to base dir or script dir when needed
     *
     * @param path original path to file, maybe relative
     * @return {@link File} instance
     */
    public File getResolvedFile(String path) {
        reserveFile(path);
        return files.get(path).file;
    }

    private static class FileEntry{
        private String headerLine;
        private Throwable exception;
        private final File file;
        private Closeable inputOutputObject;
        private final String charSetEncoding;

        FileEntry(File f, Closeable o, String e) {
            file = f;
            inputOutputObject = o;
            charSetEncoding = e;
        }
    }

    /**
     * Resolve a file name that may be relative to the base directory. If the
     * name begins with the value of the JMeter property
     * &quot;jmeter.save.saveservice.base_prefix&quot; - default &quot;~/&quot; - then the name is
     * assumed to be relative to the basename.
     *
     * @param relativeName
     *            filename that should be checked for
     *            &amp;lt;code&amp;gt;jmeter.save.saveservice.base_prefix&amp;lt;/code&amp;gt;
     * @return the updated filename
     */
    public static String resolveBaseRelativeName(String relativeName) {
        if (relativeName.startsWith(BASE_PREFIX)){
            String newName = relativeName.substring(BASE_PREFIX.length());
            return new File(getFileServer().getBaseDir(),newName).getAbsolutePath();
        }
        return relativeName;
    }

    /**
     * @return JMX Script name
     * @since 2.6
     */
    public String getScriptName() {
        return scriptName;
    }

    /**
     * @param scriptName Script name
     * @since 2.6
     */
    public void setScriptName(String scriptName) {
        this.scriptName = scriptName;
    }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;pre&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 26 Jan 2019 14:46:00 +0000</pubDate>
<dc:creator>夏天里的Jasmine</dc:creator>
<og:description>经常遇到性能测试的时候，有100万条数据，才用了5万条，中途因为某些原因停止了，继续用的时候， 要么要清除DB中数据，要么要清除数据源中的数据， 觉得特别麻烦， 希望改写下代码，将 Core目录下的S</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qianjinyan/p/9543879.html</dc:identifier>
</item>
<item>
<title>12 JVM 垃圾回收（下） - 黑_子</title>
<link>http://www.cnblogs.com/yuepenglei/p/10325174.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuepenglei/p/10325174.html</guid>
<description>&lt;h4 id=&quot;java-虚拟机的堆划分&quot;&gt;Java 虚拟机的堆划分&lt;/h4&gt;
&lt;p&gt;Java 虚拟机将堆划分为新生代和老年代。其中新生代又被划分为 Eden 区，以及两个大小相同的 Survivor 区。&lt;/p&gt;
&lt;p&gt;默认情况下，Java 虚拟机采取一种动态分配的策略，根据对象生成的速率，以及 Survivor 区的使用情况动态调整 Eden 区和 Survivor 区的比例。也可以通过参数 -XX:SurvivorRatio 来固定这个比例。需要注意的是，其中一个 Survivor 区会一直为空，因此比例越低浪费的空间越高。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190125233636563.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlbmdsZWkxMjM0NTY=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当调用 new 指令时，它会在 Eden 区中划出一块作为存储对象的内存。由于堆内存是线程共享的，因此直接在这里划分空间是需要进行同步的。否则会出现两个对象公用一段内存的事故。&lt;/p&gt;
&lt;p&gt;Java 虚拟机的解决方法是：每个线程可以向 Java 虚拟机申请一段连续的内存，比如 2048 字节，作为线程私有的 TLAB。这个操作需要加锁，线程需要维护两个重要的指针，一个指向 TLAB 中空余内存的起始位置，一个则指向 TLAB 末尾。&lt;/p&gt;
&lt;p&gt;然后通过 new 指令，便可以直接通过指针加法来实现，即把指向空余内存位置的指针加上所请求的字节数。如果加法后空余内存指针的值扔小于或等于指向末尾的指针，则代表分配成功。否则，TLAB 以及没有足够的空间来满足本次新建操作。这个时候，便需要当前线程重新申请新的 TLAB。&lt;/p&gt;
&lt;p&gt;当 Eden 区的空间耗尽了，这个时候 Java 虚拟机便会触发一次 Minor GC，来收集新生代的垃圾。存活下来的对象，则会被送到 Survivor 区。当发生 MinorGC时，Eden 区和 from 指向的 Survivor 区中的存活对象会被复制到 to 指向的 Survivor 区中，然后交换 from 和 to 指针，以保证下一次 Minor GC 时，to 指向的 Survivor 区还是空的。&lt;/p&gt;
&lt;p&gt;Java 虚拟机会记录 Survivor 区中的对象一共被来回复制了几次。如果一个对象被复制 15 次，那么该对象将被晋升至老年代。如果单个 Survivor 区已经被占用了 50%，那么较高复制次数的对象也会被晋升至老年代。&lt;/p&gt;
&lt;p&gt;Minor GC 有一个问题，那就是老年代的对象可能引用新生代的对象。在标记存活对象的时候，我们需要扫描老年代中的对象。如果该对象拥有对新生代对象的引用，那么这个引用也会被作为 GC Roots。这样的话，就相当于进行了一次全堆扫描。&lt;/p&gt;
&lt;h4 id=&quot;卡表&quot;&gt;卡表&lt;/h4&gt;
&lt;p&gt;针对上述的问题，HotSpot 给出了一种解决方案叫做卡表。该技术将整个堆划分为一个个大小为 512 字节的卡，并且维护一个卡表，用来存储每张卡的一个标示位。这个标示位代表对应的卡是否可能存在指向新生代对象的引用。如果可能存在，那么我们就认为这张卡是脏的。&lt;/p&gt;
&lt;p&gt;在进行 Minor GC 的时候，我们不用扫描整个老年代，而是在卡表中寻找脏卡，并将脏卡中的对象加入到 Minor GC 的 GC Roots 里。当完成所有脏卡的扫描之后，Java 虚拟机便会将所有脏卡的标示位清零。&lt;/p&gt;
&lt;p&gt;上述总结介绍了用卡表这种方式解决全堆扫描效率低下的问题，置于如何标记脏卡，如何更新脏卡就不做深入总结了。&lt;/p&gt;
&lt;h4 id=&quot;问答&quot;&gt;问答&lt;/h4&gt;
&lt;h6 id=&quot;q请问jvm分代收集新生代对象进入老年代年龄为什么是15而不是其他的&quot;&gt;Q：请问JVM分代收集新生代对象进入老年代，年龄为什么是15而不是其他的?&lt;/h6&gt;
&lt;p&gt;HotSpot会在对象头中的标记字段里记录年龄，分配到的空间只有4位，最多只能记录到15&lt;/p&gt;
&lt;h6 id=&quot;qgc-root到底指的是对象本身还是引用&quot;&gt;Q：GC ROOT到底指的是对象本身，还是引用？&lt;/h6&gt;
&lt;p&gt;严格来说应该是对象。像局部变量中存放的引用只是导致对象成为GC roots的原因。我个人倾向于将这些引用作为GC roots，因为GC是从这些地方出发开始探索的。看各人理解方便吧。&lt;/p&gt;
&lt;h4 id=&quot;总结&quot;&gt;总结&lt;/h4&gt;
&lt;p&gt;本文创作灵感来源于 极客时间 郑雨迪老师的《深入拆解 Java 虚拟机》课程，通过课后反思以及借鉴各位学友的发言总结，现整理出自己的知识架构，以便日后温故知新，查漏补缺。&lt;/p&gt;
&lt;h4 id=&quot;关注本人公众号第一时间获取最新文章发布每日更新一篇技术文章&quot;&gt;关注本人公众号，第一时间获取最新文章发布，每日更新一篇技术文章。&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1562380/201901/1562380-20190113225450069-1906096752.png&quot; alt=&quot;关注我就是给我最大的鼓励和支持&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 26 Jan 2019 14:36:00 +0000</pubDate>
<dc:creator>黑_子</dc:creator>
<og:description>Java 虚拟机的堆划分 Java 虚拟机将堆划分为新生代和老年代。其中新生代又被划分为 Eden 区，以及两个大小相同的 Survivor 区。 默认情况下，Java 虚拟机采取一种动态分配的策略，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuepenglei/p/10325174.html</dc:identifier>
</item>
<item>
<title>基于 pyMongo 和 wxPython 实现的 MongoDB Schema Analyser - HanseyLee</title>
<link>http://www.cnblogs.com/HanseyLee/p/10325091.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/HanseyLee/p/10325091.html</guid>
<description>&lt;p&gt;MongoDB 作为文档型 NoSql 数据库，它的集合表结构往往不像关系型数据库那么固定和统一，同一个集合下的文档（document）的字段变化和差异可能很大，特别是在数据模型缺乏良好规划和规范的数据库。&lt;/p&gt;
&lt;p&gt;当接手一个基于 MongoDB 存储、计算的新项目，在缺乏 ORM 等映射抽象的情况下，了解其库表的结构以及集合的Schema十分的重要。MongoBooster(MongoDB4.0 之后为 NoSQlBooster for MongoDB) 可视化数据库客户端是一个方便高效的工具，它集成了mongo Shell，提供了对数据库的各种操作，包括CRUD、数据库表状态查询等等。它非常强大，自然也包含了对 Schema 的分析，遗憾的是，这个功能只对注册用户开放，非注册用户只能在test数据库上做test...&lt;/p&gt;
&lt;p&gt;以下对本机mongodb://localhost:27017,localhost:27019,localhost:27020副本集上的test数据库的test集合进行Schema 分析为例。下图为MongoBooster 的Schema 分析结果。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190125195909317.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z6bHVsZWU=,size_18,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里，为了表达对自由开放的推崇，对于MongoDB Schema Analyser的功能，我找到了两个替代工具。&lt;/p&gt;
&lt;h2 id=&quot;variety.js&quot;&gt;Variety.js&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt; https://github.com/variety/variety&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Schema 分析的命令行工具。&lt;br/&gt;命令行调用：&lt;code&gt;mongo [mongoURI] --eval &quot; var collection = 'test'&quot; variety.js&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;基于javaScript，支持的参数很多，但是运行速度不能报很高期望，对于大集合程序往往也会崩溃。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190125200656404.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z6bHVsZWU=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;pymonschema&quot;&gt;pyMonSchema&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt; https://github.com/HanseyLee/pyMonSchema&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;pyMonSchema是一个基于pyMongo 和 wxPython 实现的 MongoDB Schema Analyser GUI 工具，界面连接和切换数据库集合，支持自定义查询语句、查询排序、限值，支持忽略键名数组及忽略键名的正则表达式，支持嵌套字段的分析。Schema 分析使用MongoDB 的 MapReduce，速度和稳定性上远高于Variety.js。&lt;br/&gt;自定义字段的使用说明：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    - Query -&amp;gt; MongoDB query document to filter input to analyse. e.g. {&quot;keyName&quot;: {&quot;$in&quot;: [&quot;key1&quot;, &quot;key2&quot;]}}, {&quot;keyName&quot;: {&quot;$exists&quot;: True}}(Note that: PyMonSchema use &quot;eval()&quot; to deserialize query string, so use 'True'/'False' as bool value)
    - Order -&amp;gt; Positive/Negative, used in sort document, order=Positive equivalent to sort(&quot;_id&quot;:1), order=Negative equivalent to sort(&quot;_id&quot;:-1).
    - Limit -&amp;gt; Int, limit value of query result. Empty default is 0, which means no limit.
    - Omit_keys -&amp;gt; Fields string to be omitted, sperate by comma. such as: keyName1, keyName2 .
    - Omit_patterns -&amp;gt; Fileds match these regular expression patterns will be omitted, sperate by comma. such as: ^keyNameHead, keyNameTail$ .
    - Embed-keys -&amp;gt; Whether to analyse embed-key (e.g. keyNameParent.keyNameChild1.keyNameChild2) or not.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意，这里的Query Document 输入实为字符串，程序会使用python eval 函数对其进行转化为python 对象，如：{&quot;keyName&quot;: {&quot;&lt;span class=&quot;math inline&quot;&gt;\(in&quot;: [&quot;key1&quot;, &quot;key2&quot;]}}, {&quot;keyName&quot;: {&quot;\)&lt;/span&gt;exists&quot;: True}}。&lt;/p&gt;
&lt;p&gt;pyMonSchema分析的字段类型，对于Number 类型，会进一步推断其为Int32, 或Double类型（MongoDB 默认超过Int32的整数也为Double类型）。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019012519474793.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z6bHVsZWU=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190125202154290.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z6bHVsZWU=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外，对应分析的结果，还可以保存的json文件，格式如下：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;[
    {
        &quot;key&quot;: &quot;_id&quot;,
        &quot;total_occurrence&quot;: 15.0,
        &quot;statics&quot;: [
            {
                &quot;type&quot;: &quot;ObjectId&quot;,
                &quot;occurrence&quot;: 15.0,
                &quot;percent&quot;: 100.0
            }
        ]
    },
    {
        &quot;key&quot;: &quot;hello&quot;,
        &quot;total_occurrence&quot;: 9.0,
        &quot;statics&quot;: [
            {
                &quot;type&quot;: &quot;Int32&quot;,
                &quot;occurrence&quot;: 1.0,
                &quot;percent&quot;: 6.666666666666667
            },
            {
                &quot;type&quot;: &quot;String&quot;,
                &quot;occurrence&quot;: 8.0,
                &quot;percent&quot;: 53.333333333333336
            }
        ]
    },
    ...
 ]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于多数据库/集合的批量Schema 分析，pyMonSchema 的 mongoDBM.DBManager 类对此提供了充分的支持，可以使用多进程、多线程来对其进行实现，参考https://blog.csdn.net/fzlulee/article/details/85944967 ，或 github 源码https://github.com/HanseyLee/pyMonSchema。&lt;br/&gt;【正文完】&lt;/p&gt;
&lt;blockquote readability=&quot;2.2448979591837&quot;&gt;
&lt;p&gt;注，以上内容同步自同名博客 &lt;a href=&quot;https://blog.csdn.net/fzlulee/article/details/86651664&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/fzlulee/article/details/86651664&lt;/a&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sat, 26 Jan 2019 14:09:00 +0000</pubDate>
<dc:creator>HanseyLee</dc:creator>
<og:description>MongoDB 作为文档型 NoSql 数据库，它的集合表结构往往不像关系型数据库那么固定和统一，同一个集合下的文档（document）的字段变化和差异可能很大，特别是在数据模型缺乏良好规划和规范的数</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/HanseyLee/p/10325091.html</dc:identifier>
</item>
<item>
<title>EF Core 快速上手——EF Core 入门 - 戎&quot;码&quot;一生</title>
<link>http://www.cnblogs.com/lucky_hu/p/10325087.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lucky_hu/p/10325087.html</guid>
<description>&lt;hr/&gt;&lt;h2 id=&quot;本章导航&quot;&gt;本章导航&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;从本书你能学到什么&lt;/li&gt;
&lt;li&gt;对EF6.x 程序员的一些话&lt;/li&gt;
&lt;li&gt;EF Core 概述
&lt;ul&gt;&lt;li&gt;1.3.1 ORM框架的缺点&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;h2 id=&quot;第一个ef-core应用&quot;&gt;第一个EF Core应用&lt;/h2&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://pepper.img.zhikestreet.com/EF%20Core%20In%20Action.png&quot; alt=&quot;使用场景&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;  本文是对《Entity framework in action》部分章节的翻译,某些场景也会附上笔者实践的Demo。尽管很认真的斟酌,但是水平有限,还请各位批评和斧正。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;14&quot;&gt;
&lt;p&gt;  Entity Framework Core, 或者 EF Core,是一个方便软件工程师访问数据库的库。有很多方法来构建这样的一个库,但是EF Core 被设计为一个对象和关系的映射器(也就是我们常说的ORM框架)。ORM是把两个世界的东西映射在一起,一个是关系型数据库自身API,另一个是面向对象世界的类和软件代码。EF Core的优势在于,让软件工程师能够通过代码快速访问数据库。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;  EF Core,微软发布于2016年,它具有跨平台性:它可以运行在Windows,Linux,mac等操作系统上。它使用EF Core来命名的主要原因,确实是因为他是.NET Core 原创的一部分(但是.NET Core 也可以用于现存的.NET Framework)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;   EF Core, ASP.NET Core (服务端APP), 和 .NET Core都是开源的,并且都有提供给开发团队交流的活跃的issues页面。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;   EF Core不是 Entity Framework的第一个版本.现存的大家最为熟知的Entity Framework版本是EF 6.X. EF Core一开始就汲取了Entity Framework 4到6.x多年积累的经验和反馈意见。她保持了和EF 6.x一样接口,但是在底层做了重大改造。比如,它支持非关系性数据库,这在EF 6.x中并没有设计。作为EF5和6.x的用户,我能看到EF Core相对于此前的版本有了提高,同时也看到我喜欢的那些在EF 6.x中的特性在EF Core中还没有(尽管那些特性已经在列入了开发日程)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;   本书的目标读者可以是那些从未使用过Entity Framework的开发人员,也可以是那些EF 6.x老手,还可以是那些想了解EF Core 能做什么的人。我假定你们都熟悉.net 和 C#开发,至少对关系型数据库有所了解。但我不假定你们会使用SQL语言(一种用于大多数关系型数据库的语言),因为EF Core能够帮你做太多的事情(不用sql).但是,我会想你展示EF Core生成的SQL,因为它能帮助您理解发生了什么。使用EF的某些高级特性需要有SQL知识,而本书会提供大量的插图来帮助您学习。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;  本章将通过也小例子来价绍EF Core的使用。这个例子会调用EF Core.你也将会你看到 EF Core是底层是如何翻译软件命令并访问数据库。对EF Core底层原理的概览有助于阅读本书的其余部分。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;从本书你能学到什么&quot;&gt;1.1 从本书你能学到什么&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;  本书被分为三个部分.除了本章,第一部分还有其它四章。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;  学完第一部分,你将能够使用关系数据库构建一个.net 应用。但是数据库的组织方式留给EF Core来处理。举个例子,EF Core 默认会设置数据库字段的类型和大小,这会浪费一点点空间。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;  第二部分,会涉及到如何和为什么要修改默认配置,并深入地查看一些EF Core 命令。学完第二部分,您将能够根据您的想法,用EF Core精准的创建数据库.或者链接那些具有特定结构和设计的数据库。并且,通过使用EF Core的一些高级特性,您能够改变你.net 应用程序中数据库数据的暴露方式——比如,控制软件更加谨慎地访问数据或者构建代码来自动跟踪数据库的变化。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;  第三部分,全是关于提高您的技能,以及使您能够更好地开发和调试EF Core应用程序。我展示了一个真实的EF Core应用,从一系列熟知的模式和实践入手,而这是您是可以拿来即用的。阅读这些章节,你可单元测试,对EF Core进行扩展,而最重要的是,可以发现和修复EF Core 的性能问题。&lt;/p&gt;

&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果你是Entity Framework的新手,可以跳过本节。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;   如果你是熟悉EF 6.x的读者,EF Core的大部分你会熟悉。为了引导您快速地阅读完本书,我增加了EF6的说明。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;EF 6&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;在本书中,请留意这样的说明。他们指出了EF Core和EF 6.x的不同之处。同时,一定要看每章末尾的总结。他们会指出EF Core和EF 6.x的重大变化。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;  我将以自己学习EF Core经历给你一些建议。我太熟悉EF 6.x,在我刚开始学习EF Core的时候,却变成了一个问题。&lt;/p&gt;
&lt;p&gt;  我使用EF 6.x的方法处理问题,但不知道EF Core 有新的方法解决这些问题。在大多数情况中,这些方法是类似的,但是一些方面,却不是。&lt;/p&gt;
&lt;p&gt;  对于使用过EF 6.x的读者,我的建议是请把EF Core当成一个新的库,就当是某些人模仿EF 6.x写的。但是,必须明白它与EF 6.x不同。&lt;br/&gt;那样,你会注意到EF Core中c处理问题的新的和不同的方法。&lt;/p&gt;

&lt;p&gt;  .NETCore用于关系型数据库和.net世界中类和代码的映射,俗称ORM框架。表1.1展示了他们之间的映射关系。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pepper.img.zhikestreet.com/EF%20Core%20Mapping.png&quot; alt=&quot;使用场景&quot;/&gt;&lt;/p&gt;

&lt;p&gt;  造一个好的ORM框架非常困难。尽管EF 6.x和EF Core看起来很好用,某些时候的EF Core的“魔法”让你惊叹。在我们深入学习EF Core工作原理之前,请让我提出两个问题。&lt;/p&gt;
&lt;p&gt;  第一个是对象关系的不匹配。数据库服务器和面向对象的软件使用不同的规则:数据库使用主键来定义一条记录的唯一性,然而,.net类的实例默认是以它们的引用来区分。EF Core帮助你处理了大部分,但是.net 类会被这些key和value&quot;污染&quot;。大多数情况下,EF Core会运行良好,但是为了适应数据库,对于纯软件的项目解决方案,有时候我们处理的有一点点不同。你将在第二章看的例子就是多对多关系:在C#中处理很容易,但是在数据库中有点繁琐。&lt;/p&gt;
&lt;p&gt;  第二个问题是ORM框架——特别像EF Core这样尽善尽美的框架——把数据库隐藏的很好以至于有时候你会忘记数据库的底层是如何运作的。这个问题回导致你的代码在测试APP上运行良好,但是在数据库很复杂且同时有大量用户时的真实环境中表现糟糕。&lt;/p&gt;
&lt;p&gt;  这就是我为什么会花时间在本章,展示EF Core内部是如何工作的,以及如何生成SQL的。你越了解EF Core的工作原理,你就越能够写出好的EF Core代码。更重要的是,当它不工作的时候你知道做什么。&lt;/p&gt;
&lt;p&gt;NOTE:&lt;/p&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;贯穿于这本书,我本着&quot;先跑起来,但是在我需要的时候能够变得更快&quot;的思路来使用EF Core.&lt;br/&gt;EF Core 让我开发快速,但是我也意识到，因为EF Core或者我没有很好的使用EF Core导致在一些特定的业务需求,数据库访问的性能不够好。第5章会介绍如何隔离你EF Core，这样你就能以最小的副作用体调整它。第13章将介绍如何发现和优化那些不够快速的EF Core代码。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/HuYiDaoKing/zhikecore&quot; class=&quot;uri&quot;&gt;https://github.com/HuYiDaoKing/zhikecore&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;参考&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;  《Entity Framework Core In Action》&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://pepper.img.zhikestreet.com/ZhiKeCode.jpg&quot; alt=&quot;使用场景&quot;/&gt;&lt;img src=&quot;http://pepper.img.zhikestreet.com/wechat%E6%94%B6%E6%AC%BE.png&quot; alt=&quot;使用场景&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 26 Jan 2019 14:07:00 +0000</pubDate>
<dc:creator>戎&amp;quot;码&amp;quot;一生</dc:creator>
<og:description>EF Core 快速上手——EF Core 介绍 本章导航 从本书你能学到什么 对EF6.x 程序员的一些话 EF Core 概述 1.3.1 ORM框架的缺点 第一个EF Core应用  </og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lucky_hu/p/10325087.html</dc:identifier>
</item>
<item>
<title>Quartz.NET 3.0.7 + MySql 实现动态调度作业+动态切换版本+多作业引用同一程序集不同版本+持久化+集群(一) - 热敷哥</title>
<link>http://www.cnblogs.com/refuge/p/10324578.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/refuge/p/10324578.html</guid>
<description>&lt;p&gt;前端时间,接到领导任务,写了一个调度框架.今天决定把心路历程记录在这里.做个纪念.也方便提供给我这样的新手朋友,避免大家踩同样的坑.&lt;/p&gt;
&lt;p&gt;在生活中,&quot;经验教训&quot;常常一起出现,但在如今的快餐年代,太多人往往只关注经验,希望可以一步登天.&lt;/p&gt;
&lt;p&gt;在巨人的肩膀上固然可以看得更高,更远,但任何事物都应该辩证的看.&lt;/p&gt;
&lt;p&gt;经验固然可以让人走捷径,&lt;/p&gt;
&lt;p&gt;但教训可以让人不走弯路.&lt;/p&gt;
&lt;p&gt;希望这篇&quot;心路历程&quot;能让大家有所收获,也希望各位大佬留下宝贵意见.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;需求&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;直接上领导的原话:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1189148/201901/1189148-20190126144412711-1674094863.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在博客园看了几篇 Quartz.NET 的入门贴后,对该框架有了一个大致的了解.接下来就开始设计了.&lt;/p&gt;
&lt;p&gt;正所谓路要一步一步走,饭要一口一口吃.&lt;/p&gt;
&lt;p&gt;于是我需求的划分成如下几个功能点和需要解决的问题:&lt;/p&gt;
&lt;p&gt;1.利用反射动态创建Job;&lt;/p&gt;
&lt;p&gt;2.调度服务如何知道有新的任务来了?是调度服务轮询数据库?还是管理后台通知调度服务?又或者远程代理?&lt;/p&gt;
&lt;p&gt;3.需要一个管理后台,提供启动,暂停,恢复,停止等功能;&lt;/p&gt;
&lt;p&gt;4.至于集群,Quartz.NET 本身就提供该功能,只不过要使用它的持久化方案而已.这个点只需要在配置文件上做做手脚就可以了,并不需要怎么开发.&lt;/p&gt;
&lt;p&gt;5.管理后台如何实现启动,暂停,恢复,停止等功能?靠远程代理?还是通过其他方式?&lt;/p&gt;

&lt;p&gt;要想通过 dll 方式灵活添加必然要用到反射.这点毋庸置疑.&lt;/p&gt;
&lt;p&gt;Quartz.NET 创建一个Job的核心代码如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 IJobDetail jobDetail = JobBuilder.Create(&lt;span&gt;typeof&lt;/span&gt;(Job)).Build()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同时,Job 类需要实现 IJob 接口,实现Execute() 方法.(关于 Quartz.NET 的基础知识本篇就不介绍了,博客园有很多大神写了很多好文章)&lt;/p&gt;
&lt;p&gt;那么,我只要能拿到 Type 不就完事儿了么?&lt;/p&gt;
&lt;p&gt;这不 so easy.... 么&lt;/p&gt;
&lt;p&gt;有新的调度任务了,就新建一个类库,Nuget 安装 Quartz.NET ,然后新建类,实现IJob接口,实现 Execute() 方法,调度服务里面反射加载程序集,拿到 type ,完事儿...&lt;/p&gt;
&lt;p&gt;于是乎,我提笔就干,写下了如下代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
       Assembly assembly = Assembly.LoadFile(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;程序集物理路径&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
       Type type &lt;/span&gt;= assembly.GetType(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;类型完全限定名&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;至于调度服务怎么知道有新的调度任务来了,这个属于管理后台如何与调度服务通信的问题,这个问题不是当前需要解决的,暂时放一边,后面再考虑.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;上面代码写完后,测试了下,没问题,运行正常.&lt;/p&gt;
&lt;p&gt;但是,问题来了.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.我这个调度任务要切换版本怎么办?&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.我好几个调度任务引用了同一个程序集的不同版本怎么办?&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.我这个调度任务里面要用自己的配置文件怎么办?&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如果有朋友没有理解到上面这3个问题,我再举例说明一下:&lt;/p&gt;
&lt;h3&gt;第一个问题:&lt;/h3&gt;
&lt;p&gt;现在有两个调度任务&lt;/p&gt;
&lt;p&gt;1. 类库项目 TestJob1.dll  ,定义了一个类型: Job1 ,其完全限定名为 TestJob1.Job1&lt;/p&gt;
&lt;p&gt;2. 类库项目 TestJob2.dll  ,定义了一个类型: Job2 ,其完全限定名为 TestJob2.Job2&lt;/p&gt;
&lt;p&gt;现在调度服务已经运行起来了,我通过某种方式通知到调度服务,并且已经成功反射加载了上述两个程序集.&lt;/p&gt;
&lt;p&gt;如果这时候, TestJob1.dll 需要更新.怎么办?直接覆盖?不行的,会提示你:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1189148/201901/1189148-20190126152058129-1907479019.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&quot;把调度服务关了,再覆盖&quot;&lt;/p&gt;
&lt;p&gt;这个可以有...&lt;/p&gt;
&lt;p&gt;但是,我这个调度服务还管理者 Job2 ...实际工作中,可能有更多.为了更新某一个调度任务的版本就关闭整个调度服务,让所有的调度任务都停摆?Boss会砍死你的.&lt;/p&gt;
&lt;p&gt;&quot;我的调度任务都是每天凌晨运行,白天关一下没问题&quot;.------ &lt;span&gt;What are you talking about ?&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;第二个问题:&lt;/h3&gt;
&lt;p&gt;同样以 TestJob1.dll 和 TestJob2.dll 举例.&lt;/p&gt;
&lt;p&gt;假如这两个调度任务都引用了同一个程序集 Tools.dll ,但是版本不一样.TestJob1.dll 引用 Tools.dll  v1.0.0.0 ,TestJob2.dll 引用的是 v1.0.0.1&lt;/p&gt;
&lt;p&gt;那么如果反射加载 TestJob1.dll 和 TestJob2.dll 的时候到底会加载哪个版本的 Tools.dll 呢?&lt;/p&gt;
&lt;p&gt;谁先加载,就会加载谁引用的版本.&lt;/p&gt;
&lt;p&gt;比如,如果先反射加载了TestJob1.dll ,那么会加载Tools.dll v1.0.0.0 .这时候再反射加载 TestJob2.dll 时,不会再加载 Tools.dll 了.&lt;/p&gt;
&lt;p&gt;我曾奢望用什么骚操作能加载同一个程序集的不同版本,或者说更新到高版本也行;最终以失败而告终.&lt;/p&gt;
&lt;p&gt;所以,如果TestJob2.dll 用到了 v1.0.0.1 里面的新方法,那么很遗憾,调度服务运行时会报错,大概提示是:未在程序集 Tools.dll v1.0.0.0 中找到方法 .......&lt;/p&gt;
&lt;h3&gt;第三个问题:&lt;/h3&gt;
&lt;p&gt;依然以 TestJob1.dll 为例.&lt;/p&gt;
&lt;p&gt;我在该类库项目中,新建应用程序配置文件:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1189148/201901/1189148-20190126155135458-2074700217.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;configuration&amp;gt;
  &amp;lt;appSettings&amp;gt;
    &amp;lt;add key=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;释放自我&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;
  &amp;lt;/appSettings&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Job1
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name = System.Configuration.ConfigurationManager.AppSettings[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;大家觉得反射后,创建的 Job1 的实例能拿到&quot;释放自我&quot;么?肯定是拿不到了啦...除非你把配置写在 调度服务 的配置文件中..但是不可能我每加一个调度任务,都去调度服务的配置文件中添加配置吧..而且还有可能重名.当然,你要用File读取,当我没说...&lt;/p&gt;
&lt;p&gt;那么,能不能程序集用的时候再加载,用完就卸载.再用的时候再引用呢?&lt;/p&gt;
&lt;p&gt;这时候,我想到&amp;lt;CLR via C#  第4版&amp;gt;这本书提到过:&lt;/p&gt;
&lt;p&gt;&quot;程序集加载后不能卸载,只能通过卸载 AppDomain 来卸载程序集&quot;.&lt;/p&gt;
&lt;p&gt;于是乎,我翻开 &amp;lt;CLR via C#  第4版&amp;gt; ,依葫芦画瓢,天真而充满自信的写出如下代码:    &lt;/p&gt;
&lt;p&gt;TestJob1.dll :&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Job1 : &lt;span&gt;MarshalByRefObject&lt;/span&gt;, IJob
    {    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Task Execute(IJobExecutionContext context)
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;我不会写PPT,只会干活&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Task.FromResult(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;TestConsole.exe (调度服务):&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;string&lt;/span&gt; assemblyPath = &lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;H:\0开发项目\Go.Job.QuartzNET\TestJob1\bin\1\TestJob1.dll&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            AppDomainSetup setup &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AppDomainSetup();
            setup.ShadowCopyFiles &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;&lt;span&gt;//这句话非常重要,核心中的核心,没有它,就算跨域也没有价值.这句代码的效果是:你看到的程序集并不是正在用的程序集.用的是 它们的 Shadow.&lt;/span&gt;
            setup.ApplicationBase &lt;/span&gt;=&lt;span&gt; System.IO.Path.GetDirectoryName(assemblyPath);          &lt;/span&gt;&lt;span&gt;
      &lt;span&gt;      AppDomain appDomain &lt;/span&gt;&lt;/span&gt;&lt;span&gt;= AppDomain.CreateDomain(&quot;newDomain&quot;, null, setup);

            &lt;/span&gt;&lt;span&gt;object&lt;/span&gt; job = &lt;span&gt;appDomain&lt;/span&gt;.CreateInstanceFromAndUnwrap(assemblyPath, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TestJob1.Job1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Type type &lt;/span&gt;=&lt;span&gt; job.GetType();

            IScheduler scheduler &lt;/span&gt;=&lt;span&gt; StdSchedulerFactory.GetDefaultScheduler().Result;
            scheduler.Start();

            IJobDetail jobDetail &lt;/span&gt;= JobBuilder.Create(type).WithIdentity(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;job1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;job1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).Build();

            ITrigger trigger &lt;/span&gt;=&lt;span&gt; TriggerBuilder.Create()
                .WithIdentity(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;trigger1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;trigger1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                .WithSimpleSchedule(s &lt;/span&gt;=&amp;gt; s.WithIntervalInSeconds(&lt;span&gt;3&lt;/span&gt;&lt;span&gt;)
                    .RepeatForever()).StartNow()
                .Build();

            scheduler.ScheduleJob(jobDetail, trigger);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果运行报错,错在这一行: &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1189148/201901/1189148-20190126183503425-1617322343.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;注意看 type ,是 MarshalByRefObject 类型.这类型,让 Quartz.NET 怎么创建 JobDetail...&lt;/p&gt;
&lt;p&gt;于是,我又稍微改了改,让 &lt;span&gt;调度服务 添加 TestJob1.dll 的引用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;同时,跨域按&quot;引用&quot;封送过来后,强转为 Job1:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1189148/201901/1189148-20190126163902321-105224834.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;运行,没毛病...&lt;/p&gt;
&lt;p&gt;修改一下Job1,复制一下,看会不会报错,居然OK了,没有向上面提到的第一个问题那样,报下面这个错误.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1189148/201901/1189148-20190126152058129-1907479019.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这意味这代码可以在不关闭 调度服务的情况切换版本了...&lt;/p&gt;
&lt;p&gt;但是仔细一想,不对啊! 调度服务运行起来后,我怎么添加引用......再说了,我怎么知道要转成哪个 Job 类型?&lt;/p&gt;
&lt;p&gt;这时候,一句名言用上心头:&lt;/p&gt;
&lt;p&gt;&lt;span&gt;凡是能用技术问题解决的问题,都可以通过包一层来解决&lt;/span&gt;,于是乎我改了一下代码:&lt;/p&gt;
&lt;p&gt;新建了一个BaseJob类库,通过 Nuget 安装 Quartz.NET&lt;/p&gt;
&lt;p&gt;三个类库的引用关系为:&lt;/p&gt;
&lt;p&gt;TestConsole(调度服务)引用 BaseJob,两者都需要安装 Quartz.NET&lt;/p&gt;
&lt;p&gt;TestJob1 引用 BaseJob.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;TestConsole 没有引用 TestJob1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1189148/201901/1189148-20190126173308537-2018170841.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BaseJob : MarshalByRefObject, IJob
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Task Execute(IJobExecutionContext context)
        {
            Run();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Task.FromResult(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Run();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Job1 : BaseJob.BaseJob
    {
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Run()
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;版本1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调度服务中,跨域按&quot;引用&quot;封送后强转成 BaseJob &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1189148/201901/1189148-20190126164833504-2141131259.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;运行一下,看看效果: &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1189148/201901/1189148-20190126173840812-1118222648.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;肯定是扯蛋的嘛!&lt;/p&gt;
&lt;p&gt;调度服务都没有引用 TestJob1 怎么可能拿得到 Job1 的 Type,拿到的 Type 只会是 BaseJob&lt;/p&gt;
&lt;p&gt;什么?关闭调度服务,把 TestJob1.dll copy到 调度服务的运行目录下.嗯,这个方法能解决问题.&lt;/p&gt;
&lt;p&gt;但是,我想说一句:&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&quot;what are you talking about&quot;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我彻底懵逼了......&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;长时间的挣扎后,终于,在博客园找到一位大神2年前的一篇文章:&lt;strong&gt;https://www.cnblogs.com/zhuzhiyuan/p/6180870.html&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当时看了不到几行,&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&quot;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;作业管理（运行）池&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;&quot;&lt;/strong&gt; 几个字简直让我醍醐灌顶!!!&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;至于后面的故事,大家可以看大神的文章了......&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不过我这里还是继续写,算是对自己开发过程的一个总结.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;要用&quot;池&quot;的概念,就必须提到Quartz.NET 框架的两个知识点:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了更好理解,我们先新建一个 JobCenter , 这是也我这个框架用的到类:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt;&lt;span&gt; JobCenter&lt;/span&gt;: IJob
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task Execute(IJobExecutionContext context)
        {           &lt;/span&gt;
            &lt;span&gt;await&lt;/span&gt; Task.FromResult(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;第一个知识点:&lt;/h3&gt;
&lt;p&gt;我们在创建一个JobDetail 的时候,需要通过 WithIdentity 方法注册&quot;名称&quot;和&quot;分组&quot;,如:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
 IJobDetail jobDetail = JobBuilder.Create&amp;lt;&lt;span&gt;JobCenter&lt;/span&gt;&amp;gt;&lt;span&gt;()
                .WithIdentity(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;测试名称&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;测试组&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)            
                .Build();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;大家完全可以这样理解:&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;就当下面的红色代码被&quot;某种&quot;神秘力量隐藏了,而 WithIdentity(&quot;测试名称&quot;,&quot;测试组&quot;)   方法就相当于是实例化 JobCenter 类型时传入了两个入参.&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;上面的代码创建了一个 jobDetail,等同于创建了一个 JobCenter 类型的实例,其中构造函数的入参是&quot;测试名称&quot;和&quot;测试组&quot;.&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; JobCenter : IJob
    {
        &lt;/span&gt;&lt;span&gt;private readonly string _name;
        private readonly string _group;

        public JobCenter(string name, string group)
        {
            _name = name;
            _group = group;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task Execute(IJobExecutionContext context)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;里面是具体的逻辑&lt;/span&gt;
            &lt;span&gt;await&lt;/span&gt; Task.FromResult(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;第二个知识点:&lt;/h3&gt;
&lt;p&gt;我们创建一个 JobDetail 的时候,是可以通过 SetJobData(...) 方法来保存数据的,比如红色部分:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　　　　　　var data = new Dictionary&amp;lt;string, object&amp;gt;()
           　　　　　　 {               　　　　　
               　　　　　　 [&quot;jobInfo&quot;] =&lt;/span&gt;&lt;span&gt;&lt;span&gt; new JobInfo()//JobInfo 这个类后面会讲到
            　　　　　　};&lt;/span&gt;

            IJobDetail jobDetail &lt;/span&gt;= JobBuilder.Create&amp;lt;JobCenter&amp;gt;&lt;span&gt;()
&lt;/span&gt;                .WithIdentity(&quot;测试名称&quot;,&quot;测试组&quot;)&lt;span&gt;
&lt;span&gt;                .SetJobData(&lt;/span&gt;&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt;&lt;span&gt; JobDataMap(data))&lt;/span&gt;
                .Build();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这两个知识点 + 作业池+跨 AppDomain 按&quot;引用&quot;封送就构成了整个框架的核心.&lt;/p&gt;
&lt;p&gt;由于定义了一个JobCenter,并且用到了池,所以 BaseJob 也不需要继承 IJob 了:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 逻辑Job基类
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BaseJob : MarshalByRefObject
    {   &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 具体逻辑
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Execute();

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 将对象生存期更改为永久,因为默认5分钟不调用,会被回收.
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt; InitializeLifetimeService()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;核心伪代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义一个Job池.
    &lt;/span&gt;&lt;span&gt;//在&lt;/span&gt;&lt;span&gt;创建 jobDetail 前,先创建逻辑job,即通过跨域按&quot;引用&quot;封送,拿到逻辑job的代理对象的引用.&lt;br/&gt;　　 //然后在创建 jobDetail 的时候,将该 jobDetail 的信息 jobInfo 存入 JobDataMap 永久保存起来.
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;同时,将该 jobDetail 执行时所要正真调用的 逻辑job(也就是 BaseJob 的子类)信息存入 job 池.
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;trigger 触发时,
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从该 jobDetail 保存的数据中取出 jobInfo
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据 jobInfo 从 job 池中查找 对应的 逻辑job.
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用 逻辑job 的 Execute()方法执行具体逻辑.&lt;/span&gt;
&lt;span&gt;
    再简单讲就是,触发器触发一个作业时,作业先去作业池找到属于它自己的逻辑作业,然后再执行逻辑作业.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这里提前讲一点:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;作业池是在内存中,如果宕机是会丢失的;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而 JobDetail 和 Trigger 的数据都是在数据库中,不会丢失.(框架采用了官方的持久化方案).&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以需要写代码来处理这种意外情况.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;终于...上面提到的3个问题被完全解决了...万里长征终于迈出了第一步!!!&lt;/p&gt;

</description>
<pubDate>Sat, 26 Jan 2019 13:50:00 +0000</pubDate>
<dc:creator>热敷哥</dc:creator>
<og:description>前端时间,接到领导任务,写了一个调度框架.今天决定把心路历程记录在这里.做个纪念.也方便提供给我这样的新手朋友,避免大家踩同样的坑. 在生活中,&quot;经验教训&quot;常常一起出现,但在如今的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/refuge/p/10324578.html</dc:identifier>
</item>
</channel>
</rss>