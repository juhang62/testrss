<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>高等数学——复杂函数的求导方法 - TechFlow2019</title>
<link>http://www.cnblogs.com/techflow/p/12306205.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/techflow/p/12306205.html</guid>
<description>&lt;p&gt;本文始发于个人公众号：&lt;strong&gt;TechFlow，原创不易，求个关注&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;上一篇文章我们复习了函数求导的定义和一些常见函数的导数，今天这篇文章我们回顾一下复杂函数的求导方法。先强调一下，今天的文章很重要，想要看懂机器学习各种公式推导，想要能够自己推一推各种公式，函数求导是基础中的基础，在算法这个领域，它比积分要重要得多。&lt;/p&gt;
&lt;p&gt;我们先来看第一种情况：多个函数进行四则运算的导数。&lt;/p&gt;

&lt;h2 id=&quot;函数四则运算求导法则&quot;&gt;函数四则运算求导法则&lt;/h2&gt;

&lt;p&gt;我们假设&lt;span class=&quot;math inline&quot;&gt;\(u=u(x)\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(v=v(x)\)&lt;/span&gt;都在x点有导数，那么它们进行加减乘除四则运算之后的结果的导数有如下性质：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{aligned} \left[u(x) \pm v(x)\right]'&amp;amp;= u'(x) \pm v'(x) \\ \left[u(x)v(x)\right]' &amp;amp;= u'(x)v(x) + u(x)v'(x) \\ \left[\frac{u(x)}{v(x)}\right] &amp;amp;= \frac{u'(x)v(x)-u(x)v'(x)}{v^2(x)} (v(x) \neq 0) \end{aligned} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们来看一下证明过程，熟悉证明过程并不是炫技，除了能加深对公式的理解之外，更重要的是防止遗忘。即使以后真的不记得公式的细节了，也可以临时推导一下，这是学算法和数学很重要的技巧。&lt;/p&gt;
&lt;p&gt;我们先来看第一个，第一个很容易证明，我们直接套一下导数的公式即可：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{aligned} \left[u(x) \pm v(x) \right]' &amp;amp;= \lim_{\Delta x \to 0} \frac{\left[u(x+\Delta x) \pm v(x + \Delta x) \right] - \left[u(x) \pm v(x) \right] }{\Delta x} \\ &amp;amp;= \lim_{\Delta x \to 0}\frac{u(x+\Delta x)}{\Delta x} \pm \lim_{\Delta x \to 0} \frac{v(x+\Delta x)}{\Delta x} \\ &amp;amp;= u'(x) \pm v'(x) \end{aligned} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;第二个式子同样套用公式：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{aligned} \left[u(x)v(x)\right]' &amp;amp;= \lim_{\Delta x \to 0} \frac{u(x+\Delta x) v(x + \Delta x) - u(x) v(x)}{\Delta x} \\ &amp;amp;= \lim_{\Delta x \to 0} \frac{u(x+\Delta x) v(x + \Delta x) - u(x)v(x+ \Delta x) + u(x)v(x+\Delta x) - u(x) v(x)}{\Delta x} \\ &amp;amp;= \lim_{\Delta x \to 0} \frac{(u(x+\Delta x) - u(x))v(x+\Delta x) + u(x)(v(x+\Delta x) - v(x))}{\Delta x} \\ &amp;amp;= \lim_{\Delta x \to 0}v(x+\Delta x) \frac{u(x+\Delta x) - u(x)}{\Delta x} + \lim_{\Delta x \to 0}u(x)\frac{v(x+\Delta x) - v(x)}{\Delta x}\\ &amp;amp;=v(x+\Delta x)u'(x) + u(x)v'(x) \\ &amp;amp;=u(x)v'(x) + u'(x)v(x) \end{aligned} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;最后是第三个式子的推导，也并不复杂：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \displaystyle \begin{aligned} \left[\frac{u(x)}{v(x)}\right] &amp;amp;= \lim_{\Delta x \to 0}\frac{\frac{u(x+\Delta x)}{v(x+\Delta x)} - \frac{u(x)}{v(x)}}{\Delta x} \\ &amp;amp;= \lim_{\Delta x \to 0}\frac{v(x)u(x+\Delta x)-v(x+\Delta x)u(x)}{v(x+\Delta x)v(x)\Delta x} \\ &amp;amp;=\lim_{\Delta x \to 0} \\ &amp;amp;= \lim_{\Delta x \to 0}\frac{v(x)u(x+\Delta x)-v(x)u(x)+v(x)u(x)-v(x+\Delta x)u(x)}{v(x+\Delta x)v(x)\Delta x} \\ &amp;amp;=\lim_{\Delta x \to 0} \frac{\frac{u(x+\Delta x)-u(x)}{\Delta x}v(x)-\frac{v(x+\Delta x)-v(x)}{\Delta x}u(x)}{v(x+\Delta x)v(x)}\\ &amp;amp;=\frac{u'(x)v(x)-u(x)v'(x)}{v^2(x)} \end{aligned} \]&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;反函数求导法则&quot;&gt;反函数求导法则&lt;/h2&gt;

&lt;p&gt;推导完了四则运算的求导法则，我们再来看一下反函数的求导法则。&lt;/p&gt;
&lt;p&gt;我们陷在了看结论，如果函数&lt;span class=&quot;math inline&quot;&gt;\(x=f(y)\)&lt;/span&gt;在区间&lt;span class=&quot;math inline&quot;&gt;\(I_y\)&lt;/span&gt;内单调、可导并且&lt;span class=&quot;math inline&quot;&gt;\(f'(x)!=0\)&lt;/span&gt;，那么它的反函数&lt;span class=&quot;math inline&quot;&gt;\(y=f^{-1}(x)\)&lt;/span&gt;在区间&lt;span class=&quot;math inline&quot;&gt;\(I_x=\{x|x=f(y), y\in I_y\}\)&lt;/span&gt;内也可导，那么：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\left[f^{-1}(x)\right]'=\frac{1}{f'(y)}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;关于这个结论的证明很简单，因为&lt;span class=&quot;math inline&quot;&gt;\(x=f(y)\)&lt;/span&gt;在区间内单调、可导，所以它的反函数&lt;span class=&quot;math inline&quot;&gt;\(y=f^{-1}(x)\)&lt;/span&gt;存在，并且也单调且连续。&lt;/p&gt;
&lt;p&gt;所以:&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{aligned} \Delta y=f^{-1}(x+\Delta x)-f^{-1}x \neq 0 \\ \frac{\Delta y}{\Delta x} = \frac{1}{\frac{\Delta x}{\Delta y}}=\frac{1}{f'(y)} \end{aligned} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;由于&lt;span class=&quot;math inline&quot;&gt;\(y=f^{-1}(x)\)&lt;/span&gt;连续，&lt;span class=&quot;math inline&quot;&gt;\(\displaystyle\lim_{\Delta x \to 0}\Delta y=0\)&lt;/span&gt;，所以上式成立。&lt;/p&gt;
&lt;p&gt;我们来看一个例子：&lt;span class=&quot;math inline&quot;&gt;\(x=\sin y, y\in \left[-\frac{\pi}{2}, \frac{\pi}{2} \right]\)&lt;/span&gt;，则&lt;span class=&quot;math inline&quot;&gt;\(y=\arcsin x\)&lt;/span&gt;是它的反函数，根据上面的公式，我们可以得到：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[(\arcsin x)'=\frac{1}{(\sin y)'}=\frac{1}{\cos y}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;由于&lt;span class=&quot;math inline&quot;&gt;\(\cos y= \sqrt{1-\sin^2 y} = \sqrt{1-x^2}\)&lt;/span&gt;，代入上式可以得到：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[(\arcsin x)'=\frac{1}{\sqrt{1-x^2}}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;利用同样的方法，我们还可以求出其他反三角函数的导数，由于这些并不太常用，所以我们就不多介绍了，感兴趣的同学可以自己利用导数的定义推导一下，我想应该也不难。&lt;/p&gt;

&lt;h2 id=&quot;复合函数求导&quot;&gt;复合函数求导&lt;/h2&gt;

&lt;p&gt;这是最后一个法则，也是本篇文章的重点，因为经常用到。我们现在已经搞定了一些常见的函数，还搞定了常见函数加减乘除之后求导的结果，但是对于一些看起来比较复杂的函数，我们并不能一下写出它们的导数。&lt;/p&gt;
&lt;p&gt;比如说：&lt;span class=&quot;math inline&quot;&gt;\(\sin (x^2+3x)\)&lt;/span&gt;，比如&lt;span class=&quot;math inline&quot;&gt;\(\ln (3x -1)\)&lt;/span&gt;等等，这些函数基本上都可以确定是连续并且可导的，但是我们一下子并不能写出它们的导数，而且要通过导数的定义推导也非常麻烦，对于这些导数就需要用到今天的重头戏，也就是复合函数的求导法则了。&lt;/p&gt;
&lt;p&gt;对于复合函数而言，拥有如下法则：如果函数&lt;span class=&quot;math inline&quot;&gt;\(u=g(x)\)&lt;/span&gt;在点x处可导，并且&lt;span class=&quot;math inline&quot;&gt;\(y=f(u)\)&lt;/span&gt;在点&lt;span class=&quot;math inline&quot;&gt;\(u=g(x)\)&lt;/span&gt;处也可导，那么复合函数&lt;span class=&quot;math inline&quot;&gt;\(y=f[g(x)]\)&lt;/span&gt;在x处可导，它的导数为：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\frac{dy}{dx}=f'(u)\cdot g'(x)=\frac{dy}{du}\cdot \frac{du}{dx}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如果复合函数的数量更多也是一样的，我们按照顺序依次相乘即可。由于公式的形式像是一根链条一样依次所以，复合函数求导法则也叫链式求导法则。在举例之前，我们先来证明一下。&lt;/p&gt;
&lt;p&gt;由于&lt;span class=&quot;math inline&quot;&gt;\(y=f(u)\)&lt;/span&gt;在点u处可导，因此&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\displaystyle\lim_{\Delta u \to 0}\frac{\Delta y}{\Delta u} = f'(u)\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;因为&lt;span class=&quot;math inline&quot;&gt;\(f'(u)\)&lt;/span&gt;存在，所以我们将它变形为：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\frac{\Delta y}{\Delta u} = f'(u) + a\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中a是&lt;span class=&quot;math inline&quot;&gt;\(\Delta u \to 0\)&lt;/span&gt;时的无穷小，我们对两边同时乘上&lt;span class=&quot;math inline&quot;&gt;\(\Delta u\)&lt;/span&gt;，可以得到：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\Delta y = f'(u)\Delta u + a\cdot \Delta u\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;上式当中&lt;span class=&quot;math inline&quot;&gt;\(\Delta u\)&lt;/span&gt;和a都是无穷小，所以当&lt;span class=&quot;math inline&quot;&gt;\(\Delta u \to 0\)&lt;/span&gt;时，&lt;span class=&quot;math inline&quot;&gt;\(\Delta y=0\)&lt;/span&gt;，我们对上式两边同时除以&lt;span class=&quot;math inline&quot;&gt;\(\Delta x\)&lt;/span&gt;，得：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\displaystyle\frac{\Delta y}{\Delta x}=f'(u)\frac{\Delta u}{\Delta x} + a\cdot\frac{\Delta u}{\Delta x}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;于是：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\displaystyle \lim_{\Delta x \to 0}\frac{\Delta y}{\Delta x}=\lim_{\Delta x \to 0}[f'(u)\frac{\Delta u}{\Delta x}+a\frac{\Delta u}{\Delta x}]\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;又根据&lt;span class=&quot;math inline&quot;&gt;\(u=g(x)\)&lt;/span&gt;在点x处可导，所以有：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\displaystyle \lim_{\Delta x \to 0}\frac{\Delta u}{\Delta x}=g'(x)\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们代入，就可以得到：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\displaystyle \lim_{\Delta x \to 0}\frac{\Delta y}{\Delta x}=f'(u)\cdot \frac{\Delta u}{\Delta x}=f'(u)\cdot g'(x)\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其实我们都知道相比于公式的证明，公式的运用更加重要，下面我们就来看两个例子，来巩固一下这个链式求导法则：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(y=\ln \sin 3x\)&lt;/span&gt;，求&lt;span class=&quot;math inline&quot;&gt;\(\frac{dy}{dx}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们令&lt;span class=&quot;math inline&quot;&gt;\(u=3x, g=\sin u\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;所以：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{aligned} \frac{dy}{dx}&amp;amp;=\frac{dy}{dg}\cdot \frac{dg}{du}\cdot\frac{du}{dx}\\ &amp;amp;=\frac{1}{g}\cdot \cos u\cdot 3\\ &amp;amp;=3\frac{\cos 3x}{\sin 3x} \\ &amp;amp;=3 \cot 3x \end{aligned} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;还记得我们之前推导线性回归时候用到的均方差的公式吗：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[f(\theta) = \frac{1}{m}(\theta X-Y)^2\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们来试着学以致用，求一下&lt;span class=&quot;math inline&quot;&gt;\(f(\theta)\)&lt;/span&gt;的导数，在机器学习当中，X和Y都是样本都是已知的参数，要求的是&lt;span class=&quot;math inline&quot;&gt;\(\theta\)&lt;/span&gt;，所以我们对&lt;span class=&quot;math inline&quot;&gt;\(\theta\)&lt;/span&gt;求导：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{aligned} f'(\theta) &amp;amp;= \frac{1}{m}\cdot 2 \cdot (\theta X - Y)\cdot X \\ &amp;amp;=\frac{2}{m}X^T(\theta X - Y) \end{aligned} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这个结果其实就是之前我们说的梯度，梯度本来就是由导数计算得到的，所以理解了链式求导的公式，可以再回过头看看之前线性回归和梯度推导的公式，相信会有更深刻的体会。&lt;/p&gt;
&lt;p&gt;今天的文章篇幅有些长，但是除去证明之后，剩下的内容并不多，重要的是它的应用范围很广，所以希望大家都能学会。&lt;/p&gt;
&lt;p&gt;如果觉得有所收获，请&lt;strong&gt;顺手扫码点个关注&lt;/strong&gt;吧，你们的举手之劳对我来说很重要。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/2/14/17041114cec64d7f?w=258&amp;amp;h=258&amp;amp;f=png&amp;amp;s=23988&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 14 Feb 2020 00:26:00 +0000</pubDate>
<dc:creator>TechFlow2019</dc:creator>
<og:description>本文始发于个人公众号： TechFlow，原创不易，求个关注 上一篇文章我们复习了函数求导的定义和一些常见函数的导数，今天这篇文章我们回顾一下复杂函数的求导方法。先强调一下，今天的文章很重要，想要看懂</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/techflow/p/12306205.html</dc:identifier>
</item>
<item>
<title>软工实践寒假作业（2/2） - 索隆不喝酒</title>
<link>http://www.cnblogs.com/hhhqqq/p/12306200.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hhhqqq/p/12306200.html</guid>
<description>&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/904566722/InfectStatistic-main&quot; target=&quot;_blank&quot;&gt;https://github.com/904566722/InfectStatistic-main&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section&quot;&gt;学习记录&lt;/h2&gt;
&lt;blockquote readability=&quot;1.2295081967213&quot;&gt;
&lt;p&gt;学习笔记：&lt;a href=&quot;https://www.cnblogs.com/hhhqqq/p/12287911.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/hhhqqq/p/12287911.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;psp-1&quot;&gt;PSP表格&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;PSP2.1&lt;/th&gt;
&lt;th&gt;Personal Software Process Stages&lt;/th&gt;
&lt;th&gt;预估耗时（min）&lt;/th&gt;
&lt;th&gt;实际耗时（min）&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;6.5&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Planning&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;计划&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;60&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;50&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Estimate&lt;/td&gt;
&lt;td&gt;估计这个任务需要多少时间&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;15&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Development&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;开发&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;760&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;735&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Analysis&lt;/td&gt;
&lt;td&gt;需求分析 (包括学习新技术)&lt;/td&gt;
&lt;td&gt;180&lt;/td&gt;
&lt;td&gt;200&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Design Spec&lt;/td&gt;
&lt;td&gt;生成设计文档&lt;/td&gt;
&lt;td&gt;20&lt;/td&gt;
&lt;td&gt;30&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Design Review&lt;/td&gt;
&lt;td&gt;设计复审&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Coding Standard&lt;/td&gt;
&lt;td&gt;代码规范 (为目前的开发制定合适的规范)&lt;/td&gt;
&lt;td&gt;40&lt;/td&gt;
&lt;td&gt;30&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Design&lt;/td&gt;
&lt;td&gt;具体设计&lt;/td&gt;
&lt;td&gt;60&lt;/td&gt;
&lt;td&gt;90&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Coding&lt;/td&gt;
&lt;td&gt;具体编码&lt;/td&gt;
&lt;td&gt;300&lt;/td&gt;
&lt;td&gt;290&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Code Review&lt;/td&gt;
&lt;td&gt;代码复审&lt;/td&gt;
&lt;td&gt;30&lt;/td&gt;
&lt;td&gt;25&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Test&lt;/td&gt;
&lt;td&gt;测试（自我测试，修改代码，提交修改）&lt;/td&gt;
&lt;td&gt;120&lt;/td&gt;
&lt;td&gt;60&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Reporting&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;报告&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;90&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;150&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Test Report&lt;/td&gt;
&lt;td&gt;测试报告&lt;/td&gt;
&lt;td&gt;15&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Size Measurement&lt;/td&gt;
&lt;td&gt;计算工作量&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;20&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;Postmortem &amp;amp; Process Improvement Plan&lt;/td&gt;
&lt;td&gt;事后总结, 并提出过程改进计划&lt;/td&gt;
&lt;td&gt;45&lt;/td&gt;
&lt;td&gt;25&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;total&lt;/td&gt;
&lt;td&gt;合计&lt;/td&gt;
&lt;td&gt;990&lt;/td&gt;
&lt;td&gt;1005&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;blockquote readability=&quot;16.5&quot;&gt;
&lt;h3 id=&quot;section-2&quot;&gt;对照“疫情统计程序的需求文档”理清文档的结构&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;221701419
    \--src      //源代码
        InfectStatistic.java
        Lib.java
    \--log      //项目的输入文本，
        2020-01-22.log.txt
        ...
    \--result   //处理后最终结果的输出
        ListOut1.txt
        ...
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;section-3&quot;&gt;找到合适的数据结构&lt;/h3&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;ul&gt;&lt;li&gt;分析“日志文本”，需要统计的是每个省的数据，可以创建一个**省类(Province)**来记录感染患者、疑似患者、治愈等信息&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Province{
    String provinceName; // 省份名称
    int ip; // 感染患者
    int sp; // 疑似患者
    int cure; // 治愈
    int dead; // 死亡
    //构造等其他方法
    ...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;分析“需求”，最终的处理结果要将每个省的信息按行输出，因此可以将之前参加统计的每个省类加入一个&lt;strong&gt;集合&lt;/strong&gt;，输出时从该集合中依次取出，并打印结果，我选择了&lt;strong&gt;哈希表(HashTable)&lt;/strong&gt;，将省名作为键，Province作为值&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Province Fujian = new Province();
HashTable&amp;lt;String, Province&amp;gt; hastable = new HashTable&amp;lt;String, Province&amp;gt;(35);
hashtable.put(&quot;福建&quot;,Fujian);
&lt;/code&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;section-4&quot;&gt;对日志文本详细分析&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;1.5&quot;&gt;
&lt;p&gt;对log日志中出现的几种情况分析，可以用String的**split(&quot; &quot;)**来分割主谓宾&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;该日志中出现的几种情况&lt;/th&gt;
&lt;th&gt;用split分割后的数组长度&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;1、&amp;lt;省&amp;gt; 新增 感染患者 n人&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;2、&amp;lt;省&amp;gt; 新增 疑似患者 n人&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;3、&amp;lt;省1&amp;gt; 感染患者 流入 &amp;lt;省2&amp;gt; n人&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;4、&amp;lt;省1&amp;gt; 疑似患者 流入 &amp;lt;省2&amp;gt; n人&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;5、&amp;lt;省&amp;gt; 死亡 n人&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;6、&amp;lt;省&amp;gt; 治愈 n人&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;7、&amp;lt;省&amp;gt; 疑似患者 确诊感染 n人&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;8、&amp;lt;省&amp;gt; 排除 疑似患者 n人&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;String line = &quot;福建 新增 感染患者 1人&quot;;
String[] afterSplitStrings = line.split(&quot; &quot;);
//afterSplitStrings[0]:&quot;福建&quot; [1]:&quot;新增&quot; [2]:&quot;感染患者&quot; [3]:&quot;1人&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;分类后数组长度的三种情况：3、4、5&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;分类后可以得到需要修改的&lt;strong&gt;省份名称&lt;/strong&gt;，两种情况：1.仅需修改一个省份；2.需修改两个省份&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;得到需要修改的省份后判断需要执行的&lt;strong&gt;操作类型&lt;/strong&gt;，分析日志中出现的几种情况思考要如何修改相应省份的数据，并将操作赋予一个&lt;strong&gt;类型ID&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;日志出现的情况&lt;/th&gt;
&lt;th&gt;数据修改&lt;/th&gt;
&lt;th&gt;操作类型ID&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;10&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&amp;lt;省&amp;gt; 死亡 n人&lt;/td&gt;
&lt;td&gt;死亡数+n &amp;amp;&amp;amp; 感染者-n&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&amp;lt;省&amp;gt; 治愈 n人&lt;/td&gt;
&lt;td&gt;治愈+n &amp;amp;&amp;amp; 感染者-n&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&amp;lt;省&amp;gt; 新增 感染患者 n人&lt;/td&gt;
&lt;td&gt;感染者+n&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&amp;lt;省&amp;gt; 新增 疑似患者 n人&lt;/td&gt;
&lt;td&gt;疑似者+n&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&amp;lt;省&amp;gt; 排除 疑似患者 n人&lt;/td&gt;
&lt;td&gt;疑似者-n&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&amp;lt;省&amp;gt; 疑似患者 确诊感染 n人&lt;/td&gt;
&lt;td&gt;疑似者-n &amp;amp;&amp;amp; 感染者+n&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&amp;lt;省1&amp;gt; 感染患者 流入 &amp;lt;省2&amp;gt; n人&lt;/td&gt;
&lt;td&gt;省1 感染者-n &amp;amp;&amp;amp; 省2 感染者+n&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&amp;lt;省1&amp;gt; 疑似患者 流入 &amp;lt;省2&amp;gt; n人&lt;/td&gt;
&lt;td&gt;省1 疑似者-n &amp;amp;&amp;amp; 省2 疑似者+n&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;因此需要：1.Province对数据相应修改的方法&lt;/p&gt;
&lt;p&gt;​ 2.一个能够根据省份名称和操作类型ID执行相应操作的方法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;section-5&quot;&gt;对需求文档详细分析&lt;/h3&gt;
&lt;blockquote readability=&quot;14&quot;&gt;
&lt;p&gt;先不考虑命令以及参数的内容，先将日期、输入目录、输出文件作为常量使用，来完成需求里要求的功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;读取log文件夹里的文件&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;ol readability=&quot;-2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;能够筛选出指定日期前的文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;忽略注释行&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;数据的统计&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;11&quot;&gt;
&lt;ol&gt;&lt;li&gt;省份的统计&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;从输入文件读取一行后进行分析，省份存在以下情况：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-txt&quot;&gt;只有一个省
    *哈希表中没有该省
    *哈希表中存在该省
两个省
   *存在省1，存在省2
   *存在省1，不存在省2
   *不存在省1，存在省2
   *不存在省1，不存在省2
----存在则从hashtable取出，不存在则新建Province类，然后put进hashtable
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;全国的统计&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;所有要求的log日志文件处理完后，遍历hashtable来统计全国的数据&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;输出到相应目录，全国总是排第一个，别的省按拼音先后排序，末尾填上一行文档数据说名和一行命令&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-txt&quot;&gt;输出示例：
全国 感染患者22人 疑似患者25人 治愈10人 死亡2人
福建 感染患者2人 疑似患者5人 治愈0人 死亡0人
浙江 感染患者3人 疑似患者5人 治愈2人 死亡1人
// 该文档并非真实数据，仅供测试使用
// 命令： ....
&lt;/code&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;section-6&quot;&gt;命令行参数&lt;/h3&gt;
&lt;blockquote readability=&quot;9.5&quot;&gt;
&lt;p&gt;一个命令&lt;strong&gt;list&lt;/strong&gt;，五个参数名&lt;strong&gt;-log、 -out、 -date、 -type、 -province&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;示例命令行：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-txt&quot;&gt;java InfectStatistic list -date 2020-01-22 -log D:/log/ -out D:/output.txt -type sp ip -province 福建
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;从list开始，其后的参数都存入了args数组，写个方法从其中提取出参数名，然后再取得相应的参数值&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;比较需要注意的几点：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;ol readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;-date 不设置为默认最新的一天，因此要有一个取得log里最新时间的方法；传入的时间超过最新时间给出“日期超出范围的提示”&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;-type 与 -province可能携带一到多个命令参数，-province指定输出的省份也要排序，两者的参数需要作为参数传入给写入文件的方法，对输出的格式进行规约，可能出现以下四种组合：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-txt&quot;&gt;1.指定类型 &amp;amp;&amp;amp; 指定省份
2.指定类型 &amp;amp;&amp;amp; 无指定省份
3.无指定类型 &amp;amp;&amp;amp; 指定省份
4.无指定类型 &amp;amp;&amp;amp; 无指定省份
&lt;/code&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-8&quot;&gt;大致流程&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;graph LR a[命令行处理]--&amp;gt;b[初始化相应变量] b--&amp;gt;c[获得log文件] c--&amp;gt;d[遍历log统计数据] d--&amp;gt;e[打印结果到txt文件]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;section-9&quot;&gt;代码组织&lt;/h2&gt;
&lt;blockquote readability=&quot;18&quot;&gt;
&lt;p&gt;InfectStatistic的结构：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;InfectStatistic{
    public class Province{...}  //省类，用来记录感染患者、疑似患者、治愈、死亡等信息
    static class ×××Methods{...}        //存储静态方法的静态类,编程过程中根据方法作用的类别归类
    public static void main(String[] args){}
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;省类Province：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Province{
    String provinceName; // 省份名称
    int ip; // 感染患者
    int sp; // 疑似患者
    int cure; // 治愈
    int dead; // 死亡
    //构造等其他方法
    //属性的加减
    //输出属性信息
    ...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;graph LR a[InfectStatistic]--&amp;gt;b[Province类] a--&amp;gt;c[静态类-命令行处理相关方法] a--&amp;gt;d[静态类-取得log文件相关方法] a--&amp;gt;e[静态类-统计信息相关方法] a--&amp;gt;f[静态类-哈希表操作的相关方法] a--&amp;gt;g[静态类-打印结果相关方法]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;section-10&quot;&gt;关键函数流程图&lt;/h2&gt;
&lt;blockquote readability=&quot;17&quot;&gt;
&lt;h3 id=&quot;section-11&quot;&gt;读入信息，修改省份数据&lt;/h3&gt;
&lt;p&gt;graph LR A[一行信息]--&amp;gt;B[分割该字符串&amp;lt;/br&amp;gt;得到省份&amp;amp;人数&amp;amp;操作类型] B--&amp;gt;C{哈希表中是否存在省} C--&amp;gt;|存在| D[取出该省] D--&amp;gt;E[修改数据] C--&amp;gt;|不存在| F[新建并初始化Province实例] F--&amp;gt;G[存入哈希表]&lt;/p&gt;
&lt;h3 id=&quot;section-12&quot;&gt;获取文件夹下指定日期前的所有文件名&lt;/h3&gt;
&lt;p&gt;graph TD a[格式化日期格式]--&amp;gt;b[用目录下的文件名列表初始化字符串数组] b--&amp;gt;c[将字符串日期转为Date格式] c--&amp;gt;d{指定的日期与列表中最大日期比较} d--&amp;gt;|指定日期大于最大日期|e[日期超出范围提示] d--&amp;gt;|指定日期小于最大日期|f[遍历日期字符串数组] f--&amp;gt;g{与指定日期比较} g--&amp;gt;|小于等于指定日期|h[加入结果数组] g--&amp;gt;|大于指定日期|i[无操作] j[编写getMaxDate函数&amp;lt;/br&amp;gt;获得最大日期]--&amp;gt;d&lt;/p&gt;
&lt;h3 id=&quot;section-13&quot;&gt;输出文件&lt;/h3&gt;
&lt;p&gt;graph TD a[开始]--&amp;gt;b{判断有无省份参数} b--&amp;gt;|没有| e[排序传入的哈希表] e--&amp;gt;f[遍历该哈希表] f--&amp;gt;g{判断有无类型参数} g--&amp;gt;|没有|h[打印全部信息] g--&amp;gt;|有|i[打印指定信息] b--&amp;gt;|有|j[新建哈希表] j--&amp;gt;k[遍历指定的省份] k--&amp;gt;L{判断传入的哈希表是否有该省} L--&amp;gt;|没有| m[新建并初始化Province实例&amp;lt;/br&amp;gt;传入新的哈希表] L--&amp;gt;|有| o[从传入的哈希表取出并传入新的哈希表] m--&amp;gt;p[排序新的哈希表] o--&amp;gt;p p--&amp;gt;f&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-15&quot;&gt;判断操作类型&lt;/h2&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * description：判断操作类型
 * @param strings 分割后的字符串数组
 * @return 返回值操作类型ID（1~8）
 */
public static int getOperateType(String[] strings) {
    int len = strings.length;
    int res = 0;
    if (len == 3) {
        if (strings[1].equals(&quot;死亡&quot;)) {
            res = 1;
        } else if (strings[1].equals(&quot;治愈&quot;)) {
            res = 2;
        }
    } else if (len == 4) {
        if (strings[1].equals(&quot;新增&quot;)) {
            if (strings[2].equals(&quot;感染患者&quot;)) {
                res = 3;
            } else if (strings[2].equals(&quot;疑似患者&quot;)) {
                res = 4;
            }
        } else if (strings[1].equals(&quot;排除&quot;)) {
            res = 5;
        } else {
            res = 6;
        }
    } else {
        if (strings[1].equals(&quot;感染患者&quot;)) {
            res = 7;
        } else {
            res = 8;
        }
    }
    return res;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解释思路：&lt;/p&gt;
&lt;p&gt;根据读取的每行信息分割后的数组，其长度只有三种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;3：&lt;code&gt;&amp;lt;省&amp;gt; 死亡 n人&lt;/code&gt; 或 &lt;code&gt;&amp;lt;省&amp;gt; 治愈 n人&lt;/code&gt;，通过判断第二个字符串区分操作类型；&lt;/li&gt;
&lt;li&gt;4：&lt;code&gt;&amp;lt;省&amp;gt; 新增 感染患者 n人&lt;/code&gt; 或 &lt;code&gt;&amp;lt;省&amp;gt; 新增 疑似患者 n人&lt;/code&gt; 或 &lt;code&gt;&amp;lt;省&amp;gt; 疑似患者 确诊感染 n人&lt;/code&gt; 或 &lt;code&gt;&amp;lt;省&amp;gt; 排除 疑似患者 n人&lt;/code&gt;，先判断第二个字符串是“新增”还是“排除”，“新增”里再判断第三个字符串是“感染患者”还是“疑似患者”，便可区分四者；&lt;/li&gt;
&lt;li&gt;5：&lt;code&gt;&amp;lt;省1&amp;gt; 感染患者 流入 &amp;lt;省2&amp;gt; n人&lt;/code&gt; 或 &lt;code&gt;&amp;lt;省1&amp;gt; 疑似患者 流入 &amp;lt;省2&amp;gt; n人&lt;/code&gt;，判断第二个字符即可&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h2 id=&quot;section-16&quot;&gt;统计数据&lt;/h2&gt;
&lt;blockquote readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
* description：统计省份数据
* @param lineString 一行字符串
* @param hashtable 保存参与统计的省份
*/
public static void calcProvince(String lineString, Hashtable&amp;lt;String, Province&amp;gt; hashtable) {
    InfectStatistic infectStatistic = new InfectStatistic();
    String[] afterSplitStrings = lineString.split(&quot; &quot;);
    int numAfterSplit = afterSplitStrings.length; // 切割后数量
    int number = OpLineStringMethods.getNumber(afterSplitStrings[numAfterSplit - 1]); // 一行信息中涉及的人数
    String[] provinceNameStrings = OpLineStringMethods.getNeedModifyProvinceNames(afterSplitStrings);   //需要修改数据的省份名称
    int operateType = OpLineStringMethods.getOperateType(afterSplitStrings);    // 获得操作类型

    if (provinceNameStrings[1].equals(&quot;&quot;)) { // 只有一个省
        if (!hashtable.containsKey(provinceNameStrings[0])) { // 哈希表中没有该省
            Province province = infectStatistic.new Province(provinceNameStrings[0], 0, 0, 0, 0);
            RelativeProviceMethods.executeOperate(province, province, operateType, number);
            hashtable.put(province.getProvinceName(), province);
        } else {
            Province province = hashtable.get(provinceNameStrings[0]);
            RelativeProviceMethods.executeOperate(province, province, operateType, number);
        }
    } else if (!provinceNameStrings[1].equals(&quot;&quot;)) { // 有两个省
        Province province1 = null;
        Province province2 = null;
        if (hashtable.containsKey(provinceNameStrings[0]) &amp;amp;&amp;amp; hashtable.containsKey(provinceNameStrings[1])) {
            province1 = hashtable.get(provinceNameStrings[0]);
            province2 = hashtable.get(provinceNameStrings[1]);
        } else if (hashtable.containsKey(provinceNameStrings[0])
                   &amp;amp;&amp;amp; !hashtable.containsKey(provinceNameStrings[1])) {
            province1 = hashtable.get(provinceNameStrings[0]);
            province2 = infectStatistic.new Province(provinceNameStrings[1], 0, 0, 0, 0);
            hashtable.put(provinceNameStrings[1], province2);
        } else if (!hashtable.containsKey(provinceNameStrings[0])
                   &amp;amp;&amp;amp; hashtable.containsKey(provinceNameStrings[1])) {
            province1 = infectStatistic.new Province(provinceNameStrings[0], 0, 0, 0, 0);
            hashtable.put(provinceNameStrings[0], province1);
            province2 = hashtable.get(provinceNameStrings[1]);
        } else if (!hashtable.containsKey(provinceNameStrings[0])
                   &amp;amp;&amp;amp; !hashtable.containsKey(provinceNameStrings[1])) {
            province1 = infectStatistic.new Province(provinceNameStrings[0], 0, 0, 0, 0);
            province2 = infectStatistic.new Province(provinceNameStrings[1], 0, 0, 0, 0);
            hashtable.put(provinceNameStrings[0], province1);
            hashtable.put(provinceNameStrings[1], province2);

        }
        RelativeProviceMethods.executeOperate(province1, province2, operateType, number);
    }

}

 /**
 * description：统计全国的数据
 * @param hashtable 保存着所有参与统计的省份
 */
public static void calcWholeNation(Hashtable&amp;lt;String, Province&amp;gt; hashtable) {
    InfectStatistic infectStatistic = new InfectStatistic();
    Province wholeNation = infectStatistic.new Province(&quot;全国&quot;, 0, 0, 0, 0);
    Set set = hashtable.keySet();
    Iterator iterator = set.iterator();
    while(iterator.hasNext()) {
        Object keyObject = iterator.next();
        wholeNation.ip += hashtable.get(keyObject).getIp();
        wholeNation.sp += hashtable.get(keyObject).getSp();
        wholeNation.cure += hashtable.get(keyObject).getCure();
        wholeNation.dead += hashtable.get(keyObject).getDead();
    }
    hashtable.put(&quot;全国&quot;, wholeNation);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解释思路：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;统计省份数据函数&lt;/code&gt;：传入从log文件读取的一行，切割取得数组，获得需要修改数据的&lt;strong&gt;省份&lt;/strong&gt;、&lt;strong&gt;人数数量&lt;/strong&gt;以及&lt;strong&gt;操作类型&lt;/strong&gt;，然后判别省份个数（1个|2个），进而判别哈希表中是否存在该省份，如果存在，说明该省前面已经统计过部分数据，所以从哈希表中取出；如果不存在，则创建一个Province类；接着将省份、人数数量、操作类型传入执行操作的静态方法executeOperate()，执行相应的操作；操作完成后，之前新建的Province类要put进哈希表。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;统计全国数据&lt;/code&gt;：统计完所有日志文档后，新建一个全国的Province实例wholeNation，遍历哈希表，累计各项属性的值，赋给wholeNation的相应属性，再将wholeNation存入哈希表&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;section-17&quot;&gt;写入文件&lt;/h2&gt;
&lt;blockquote readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
* description：写入文件
* @param hashtable 保存着所有参与统计的省份
* @param fileOutputStream 输出文件流
* @param paramenterOfType数组 -type的参数值
* @param paramenterOfProvice数组 -province的参数值
* @param commandLineStrings数组 命令行数组 argv
*/
public static void writeFile(Hashtable&amp;lt;String, Province&amp;gt; hashtable, FileOutputStream fileOutputStream, 
                             String[] paramentersOfType, String[] paramentersOfProvince,String[] commandLineStrings) {
    String endLineString = &quot;// 该文档并非真实数据，仅供测试使用&quot;;
    String commandLineString = &quot;// 命令：&quot;;
    for(int i=0; i&amp;lt;commandLineStrings.length; i++) {
        commandLineString = commandLineString + commandLineStrings[i] + &quot; &quot;;
    }
    InfectStatistic infectStatistic = new InfectStatistic();
    Province wholeNation = hashtable.get(&quot;全国&quot;);
    try {

        OutputStreamWriter outputStreamWriter = new OutputStreamWriter(fileOutputStream,&quot;UTF8&quot;);

        if(paramentersOfProvince[0].equals(&quot;null&quot;)) {   //没有指定省份
            Set set = hashtable.keySet();
            Iterator iterator = set.iterator();
            List&amp;lt;Map.Entry&amp;lt;String,Province&amp;gt;&amp;gt; list = OpHashTableMethods.sortByHeadAlphabet(hashtable);       //排序
            for (Map.Entry entry : list){
                Province province = (Province) entry.getValue();

                if(paramentersOfType[0].equals(&quot;null&quot;)) {   //没有指定输出类型
                    outputStreamWriter.write(province.getAllResult() + &quot;\r\n&quot;);
                    outputStreamWriter.flush();
                }else {
                    outputStreamWriter.write(province.getResultByRequest(paramentersOfType) + &quot;\r\n&quot;);
                    outputStreamWriter.flush();
                }
            }
            outputStreamWriter.write(endLineString + &quot;\r\n&quot; + commandLineString);
            outputStreamWriter.flush();
        }else { //指定省份
            Hashtable&amp;lt;String, Province&amp;gt; requestProvinceHashtable = new Hashtable&amp;lt;String, InfectStatistic.Province&amp;gt;();
            //                    for(int i=0; i&amp;lt;paramentersOfProvince.length; i++) {   // 别用.length，指定的省的个数不一定等于数组的大小
            for(int i=0; paramentersOfProvince[i] != null; i++) {
                if(!hashtable.containsKey(paramentersOfProvince[i])) {  //哈希表中不存在
                    Province province = infectStatistic.new Province(paramentersOfProvince[i], 0, 0, 0, 0);
                    requestProvinceHashtable.put(paramentersOfProvince[i], province);
                }else { //哈希表中存在
                    Province province = hashtable.get(paramentersOfProvince[i]);
                    requestProvinceHashtable.put(paramentersOfProvince[i], province);
                }
            }

            List&amp;lt;Map.Entry&amp;lt;String,Province&amp;gt;&amp;gt; list = OpHashTableMethods.sortByHeadAlphabet(requestProvinceHashtable);       //排序

            for (Map.Entry entry : list){
                Province province = (Province) entry.getValue();

                if(paramentersOfType[0].equals(&quot;null&quot;)) {   //没有指定输出类型
                    outputStreamWriter.write(province.getAllResult() + &quot;\r\n&quot;);
                    outputStreamWriter.flush();
                }else {
                    outputStreamWriter.write(province.getResultByRequest(paramentersOfType) + &quot;\r\n&quot;);
                    outputStreamWriter.flush();
                }
            }
            outputStreamWriter.write(endLineString + &quot;\r\n&quot; + commandLineString);
            outputStreamWriter.flush();
        }

    } catch (Exception e) {
        // TODO: handle exception
        e.printStackTrace();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解释思路：&lt;/p&gt;
&lt;p&gt;主要是判断用户是否传入了-type和-province，有四种组合，不过该方法里主要判别province，有无type只要通过调用Province不同的方法来输出不同的结果即可，所以主要两大类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;没有指定省份&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;先对&lt;strong&gt;哈希表排序&lt;/strong&gt;，然后&lt;strong&gt;遍历哈希表&lt;/strong&gt;，再判别有无-type，调用Province的方法打印该省的&lt;strong&gt;相应数据&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;指定了省份&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;新建一个保存&lt;strong&gt;指定省份信息的哈希表requestProvinceHashtable&lt;/strong&gt;，&lt;strong&gt;遍历指定的所有省份&lt;/strong&gt;，判断传入的哈希表hashtable（即保存着在log中出现的所有省份的数据）中是否存在当前的省（指定输出的省份可能没在log文件中出现），如果&lt;strong&gt;不存在&lt;/strong&gt;，新建该省份的Province实例，并加入requestProvinceHashtable，如果&lt;strong&gt;存在&lt;/strong&gt;，从hashtable中取出该省，并加入requestProvinceHashtable，因此requestProvinceHashtable中保存了想要输出的省份的数据，然后&lt;strong&gt;排序requestProvinceHashtable&lt;/strong&gt;，再&lt;strong&gt;遍历输出&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Province的两个获得结果的方法：&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
* description：打印全部统计的数据结果
* @return resString 返回值为字符串
*/
public String getAllResult() {
    String resString = provinceName + &quot; &quot; + &quot;感染患者&quot; + ip + &quot;人&quot; + &quot; &quot; + &quot;疑似患者&quot; + sp + &quot;人&quot; + &quot; &quot; + &quot;治愈&quot; + cure
        + &quot;人&quot; + &quot; &quot; + &quot;死亡&quot; + dead + &quot;人&quot;;
    return resString;
}

/**
* description：按指定参数值要求给出结果
* @param paramenterOf 一个保存着-type的参数值的数组
* @return resString 返回值为字符串
*/
public String getResultByRequest(String[] paramentersOfType) {
    String resString = provinceName + &quot; &quot;;
    for(int i=0; paramentersOfType[i] != null; i++) {
        switch (paramentersOfType[i]) {
            case &quot;ip&quot;:
                resString += &quot;感染患者&quot; + &quot; &quot; + ip + &quot;人&quot; + &quot; &quot;;
                break;
            case &quot;sp&quot;:
                resString += &quot;疑似患者&quot; + &quot; &quot; + sp + &quot;人&quot; + &quot; &quot;;
                break;
            case &quot;cure&quot;:
                resString += &quot;治愈&quot; + &quot; &quot; + cure + &quot;人&quot; + &quot; &quot;;
                break;
            case &quot;dead&quot;:
                resString += &quot;死亡&quot; + &quot; &quot; + dead + &quot;人&quot; + &quot; &quot;;
                break;
            default:
                break;
        }
    }

    return resString;
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;h2 id=&quot;section-18&quot;&gt;命令行的处理&lt;/h2&gt;
&lt;blockquote readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;HashMap&amp;lt;Integer, String&amp;gt; paramenterHashMap = new HashMap&amp;lt;Integer, String&amp;gt;(5);
paramenterHashMap.put(1, &quot;-log&quot;);
paramenterHashMap.put(2, &quot;-out&quot;);
paramenterHashMap.put(3, &quot;-date&quot;);
paramenterHashMap.put(4, &quot;-type&quot;);
paramenterHashMap.put(5, &quot;-province&quot;);

String[] paramenterStrings = new String[args.length - 1];   //存储传入的参数名、参数值
for(int i=1; i&amp;lt;args.length; i++) {
    paramenterStrings[i-1] = args[i];
}

int[] indexOfParamenterStrings = {-1, -1, -1, -1, -1, -1};
//找到参数名，并记录位置
for(int i=0; i&amp;lt;paramenterStrings.length; i++) {
    int key = OpHashTableMethods.getKey(paramenterHashMap, paramenterStrings[i]);
    if( key != -1) {   //是参数名
        indexOfParamenterStrings[key] = i;   //key对应的参数名在patamenterStrings的i下标位置,值为-1则代表无此参数名
    }
}


/**
* 初始化输入路径、输出路径、截至日期、type参数值、province参数值
*/
String directoryString = &quot;./log&quot;;   // log 日志文件目录,项目必会附带，如果没有，从项目里的log取
String outputFileNameString = &quot;./result/testOutput.txt&quot;;    //输出路径/文件名
String toDateString = GetFileMethods.getToday(); //统计到哪一天
String[] paramentersOfType = new String[10];;  //type的参数值
String[] paramentersOfProvince = new String[25];  //province的参数值
paramentersOfType[0] = &quot;null&quot;;
paramentersOfProvince[0] = &quot;null&quot;;

//接着处理每个参数名对应的参数值
for(int i=1; i&amp;lt;=5; i++) {
    if(indexOfParamenterStrings[i] != -1) { //传入了该参数名
        if(i == 1) {    // -log
            directoryString = paramenterStrings[indexOfParamenterStrings[i] + 1];    //配置log路径
        }else if(i == 2) {  //-out
            outputFileNameString = paramenterStrings[indexOfParamenterStrings[i] + 1];      //配置输出文件路径
        }else if(i == 3) {  //-date
            toDateString = paramenterStrings[indexOfParamenterStrings[i] + 1];  //统计到哪一天
        }else if(i == 4) {  //-type 可能会有多个参数
            String[] paramenterValues = new String[20]; //记录所有参数值
            int cnt = 0;
            //取得参数值，直到找到下一个参数名时停止，   当前参数名 参数值1 参数值2 ... 下一个参数名
            for(int j=indexOfParamenterStrings[i]+1; 
                j&amp;lt;paramenterStrings.length &amp;amp;&amp;amp; OpHashTableMethods.getKey(paramenterHashMap, paramenterStrings[j])==-1; j++) { 
                paramenterValues[cnt++] = paramenterStrings[j];
                paramentersOfType = paramenterValues;
            }
        }else if(i == 5) {  //-province
            String[] paramenterValues = new String[20];
            int cnt = 0;
            //取得参数值，直到找到下一个参数名时停止，   当前参数名 参数值1 参数值2 ... 下一个参数名
            for(int j=indexOfParamenterStrings[i]+1; 
                j&amp;lt;paramenterStrings.length &amp;amp;&amp;amp; OpHashTableMethods.getKey(paramenterHashMap, paramenterStrings[j])==-1; j++) { 
                paramenterValues[cnt++] = paramenterStrings[j];
                paramentersOfProvince = paramenterValues;
            }
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解释说明：&lt;/p&gt;
&lt;p&gt;用五个参数名初始化一个&lt;strong&gt;hashMap&lt;/strong&gt;，用传入的参数名、参数值初始化一个字符串数组&lt;strong&gt;paramenterStrings&lt;/strong&gt;，用-1初始化一个大小为6的int数组&lt;strong&gt;indexOfParamenterStrings&lt;/strong&gt;，遍历paramenterStrings，如果在hashMap中存在该值（该值为参数名），则将该值在hashMap中对应的键作为indexOfParamenterStrings的下标，将该值对应paramenterStrings的下标作为indexOfParamenterStrings的值&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-txt&quot;&gt;例：indexOfParamenterStrings[4] = 6 代表的是hashMap中键为4的参数名-type在paramenterStrings[6]中
indexOfParamenterStrings[4] = -1 则代表没有传入该参数
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后从下标1开始遍历indexOfParamenterStrings（初始化hashMap时从1开始的），判断是否传入了该参数名，如果存在，从paramenterStrings中为当前参数名的下一个位置开始取得参数值，直到paramenterStrings的尽头或者遇到下一个参数名，然后用取得的参数值初始化相应的变量&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-20&quot;&gt;获取字符串前的数字&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;测试用例&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/hhhqqq/1646733/o_200214001758%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%951.png&quot; alt=&quot;单元测试1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;测试结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/hhhqqq/1646733/o_200214001803%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%951-%E7%BB%93%E6%9E%9C.png&quot; alt=&quot;单元测试1-结果&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;section-21&quot;&gt;获得需要修改数据的省份&lt;/h2&gt;
&lt;blockquote readability=&quot;17&quot;&gt;
&lt;p&gt;测试数据：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public String[] testStrings = {
    &quot;福建 新增 感染患者 2人&quot; ,
    &quot;福建 新增 疑似患者 5人&quot; ,
    &quot;湖北 新增 感染患者 15人&quot; , 
    &quot;湖北 新增 疑似患者 20人&quot; , 
    &quot;湖北 感染患者 流入 福建 2人&quot; , 
    &quot;湖北 疑似患者 流入 福建 3人&quot; , 
    &quot;湖北 死亡 1人&quot; ,
    &quot;湖北 治愈 2人&quot; , 
    &quot;福建 疑似患者 确诊感染 1人&quot; ,
    &quot;湖北 排除 疑似患者 2人&quot; 
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试用例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/hhhqqq/1646733/o_200214001807%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%952.png&quot; alt=&quot;单元测试2&quot;/&gt;&lt;/p&gt;
&lt;p&gt;测试结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/hhhqqq/1646733/o_200214001811%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%952-%E7%BB%93%E6%9E%9C.png&quot; alt=&quot;单元测试2-结果&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;section-22&quot;&gt;获得最大日期&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;测试用例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/hhhqqq/1646733/o_200213081050%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95two.png&quot; alt=&quot;单元测试two&quot;/&gt;&lt;/p&gt;
&lt;p&gt;测试结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/hhhqqq/1646733/o_200213081058%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95two-%E7%BB%93%E6%9E%9C.png&quot; alt=&quot;单元测试two-结果&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;section-23&quot;&gt;获得指定日期前的所有文件&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;测试用例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/hhhqqq/1646733/o_200213092044%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%953.png&quot; alt=&quot;单元测试3&quot;/&gt;&lt;/p&gt;
&lt;p&gt;测试结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/hhhqqq/1646733/o_200213092053%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%953-%E7%BB%93%E6%9E%9C1.png&quot; alt=&quot;单元测试3-结果1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/hhhqqq/1646733/o_200213092101%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%953-%E7%BB%93%E6%9E%9C2.png&quot; alt=&quot;单元测试3-结果2&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;section-24&quot;&gt;按城市首字母排序，“全国”置顶&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;测试用例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/hhhqqq/1646733/o_200213092106%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%954.png&quot; alt=&quot;单元测试4&quot;/&gt;&lt;/p&gt;
&lt;p&gt;测试结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/hhhqqq/1646733/o_200213092111%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%954-%E7%BB%93%E6%9E%9C.png&quot; alt=&quot;单元测试4-结果&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;section-25&quot;&gt;统计省份数据&lt;/h2&gt;
&lt;blockquote readability=&quot;17&quot;&gt;
&lt;p&gt;测试数据：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public String[] testStrings = {
   &quot;福建 新增 感染患者 2人&quot; ,
   &quot;福建 新增 疑似患者 5人&quot; ,
   &quot;湖北 新增 感染患者 15人&quot; , 
   &quot;湖北 新增 疑似患者 20人&quot; , 
   &quot;湖北 感染患者 流入 福建 2人&quot; , 
   &quot;湖北 疑似患者 流入 福建 3人&quot; , 
   &quot;湖北 死亡 1人&quot; ,
   &quot;湖北 治愈 2人&quot; , 
   &quot;福建 疑似患者 确诊感染 1人&quot; ,
   &quot;湖北 排除 疑似患者 2人&quot; 
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试用例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/hhhqqq/1646733/o_200213092117%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%955.png&quot; alt=&quot;单元测试5&quot;/&gt;&lt;/p&gt;
&lt;p&gt;测试结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/hhhqqq/1646733/o_200213092124%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%955-%E7%BB%93%E6%9E%9C.png&quot; alt=&quot;单元测试5-结果&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;section-26&quot;&gt;统计全国的数据&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;测试用例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/hhhqqq/1646733/o_200213092128%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%956.png&quot; alt=&quot;单元测试6&quot;/&gt;&lt;/p&gt;
&lt;p&gt;测试结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/hhhqqq/1646733/o_200213092134%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%956-%E7%BB%93%E6%9E%9C.png&quot; alt=&quot;单元测试6-结果&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;section-27&quot;&gt;写入文件&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;测试用例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/hhhqqq/1646733/o_200213092138%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%957.png&quot; alt=&quot;单元测试7&quot;/&gt;&lt;/p&gt;
&lt;p&gt;测试结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/hhhqqq/1646733/o_200213092145%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%957-%E7%BB%93%E6%9E%9C1.png&quot; alt=&quot;单元测试7-结果1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/hhhqqq/1646733/o_200213092150%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%957-%E7%BB%93%E6%9E%9C2.png&quot; alt=&quot;单元测试7-结果2&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;hashmapvaluekey&quot;&gt;HashMap根据value获取key&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;测试用例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/hhhqqq/1646733/o_200213131747%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%958.png&quot; alt=&quot;单元测试8&quot;/&gt;&lt;/p&gt;
&lt;p&gt;测试结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/hhhqqq/1646733/o_200213131756%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%958-%E7%BB%93%E6%9E%9C.png&quot; alt=&quot;单元测试8-结果&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-29&quot;&gt;覆盖率测试&lt;/h2&gt;
&lt;blockquote&gt;
&lt;h3 id=&quot;application&quot;&gt;application覆盖测试&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/hhhqqq/1646733/o_200213163358%E9%A1%B9%E7%9B%AE%E8%A6%86%E7%9B%96%E7%8E%87.png&quot; alt=&quot;项目覆盖率&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;junit-test&quot;&gt;JUnit Test覆盖测试&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/hhhqqq/1646733/o_200213163408%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E8%A6%86%E7%9B%96%E7%8E%87.png&quot; alt=&quot;单元测试覆盖率&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;section-30&quot;&gt;性能测试&lt;/h2&gt;

&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/904566722/InfectStatistic-main/blob/master/221701419/codestyle.md&quot;&gt;https://github.com/904566722/InfectStatistic-main/blob/master/221701419/codestyle.md&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;这次的作业相较于第一次，量还是比较多的，看完第一遍之后的感受就是有许多不知道的东西，PSP、单元测试等等，触及到了我的知识盲区...然后就决定先不管，先看看《编程之法》前三章，里面提到了许多问题都是自己目前存在的，粗略列几点来提醒自己：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;技止此耳？&lt;/strong&gt; 看书的时候多思考此项技术及延伸，及时实践发现同书上的不同，技术更新总是很快&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;唯手熟尔。&lt;/strong&gt; 不断练习，把低层次常遇到的问题变成大脑的“自动操作”，才能做更高层次的随机应变&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;多测试结果&lt;/strong&gt;。多对写完的程序进行测试，多找Bug，写更好的软件、程序。写完程序我总是很懒得去测试...&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;写到这里了，这次任务就快要结束了，通过这次的学习还是收获到不少，包括旧知识的复习、新知识的学习，这次的任务涉及到了很多的知识跟技术，&lt;strong&gt;Java、GitHub、PSP、单元测试等等&lt;/strong&gt;，有一部分都是之前了解过、但不怎么使用的，通过这次的学习，回顾了Java代码的编写，进一步了解了GitHub、markdown的一些使用技巧，学习到了PSP、单元测试、覆盖率等等新的知识，以及很重要的对&lt;strong&gt;自我的反省&lt;/strong&gt;，还是很充实的，收获很多。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote readability=&quot;13.438723404255&quot;&gt;
&lt;p&gt;1.&lt;strong&gt;AndroidAllGuide&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7.56&quot;&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://github.com/904566722/AndroidAllGuide&quot;&gt;https://github.com/904566722/AndroidAllGuide&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;简介： 这是一份关于 Java、Kotlin、Dart、Android 、Flutter 的学习指南 ， 本指南以 Java &amp;amp; Kotlin &amp;amp; Dart 的基础语法知识作为开始，涵盖了大部分的语言知识点，帮助初学者入门&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2.&lt;strong&gt;Android&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8.3173076923077&quot;&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://github.com/itheima1/Android&quot;&gt;https://github.com/itheima1/Android&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;简介： 收集Android方方面面的经典知识, 最新技术. 涵盖Android方方面面的技术, 目前保持更新. 时刻与Android开发流行前沿同步.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;3.&lt;strong&gt;BGAPhotoPicker-Android&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;4.6242424242424&quot;&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://github.com/bingoogolapple/BGAPhotoPicker-Android&quot;&gt;https://github.com/bingoogolapple/BGAPhotoPicker-Android&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;简介： Android 图片选择、预览、九宫格图片控件、拖拽排序九宫格图片控件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;4.&lt;strong&gt;DDComponentForAndroid&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6.3247863247863&quot;&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://github.com/luojilab/DDComponentForAndroid&quot;&gt;https://github.com/luojilab/DDComponentForAndroid&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;简介： 一套完整有效的android组件化方案，支持组件的组件完全隔离、单独调试、集成调试、组件交互、UI跳转、动态加载卸载等功能&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;5.&lt;strong&gt;Coder&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6.6666666666667&quot;&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://github.com/CoderGuoy/Coder&quot;&gt;https://github.com/CoderGuoy/Coder&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;简介： 项目使用MVVM模式进行开发， Tablayout | 横向布局标签，TextInputLayout | 文字输入布局 ，FloatingActionButton | 悬浮按钮 等&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 14 Feb 2020 00:21:00 +0000</pubDate>
<dc:creator>索隆不喝酒</dc:creator>
<og:description>| 这个作业属于哪个课程 | &amp;quot;2020春\|S班(福州大学)&amp;quot; | | | : : | | 这个作业要求在哪里 | &amp;quot;作业要求&amp;quot; | | 这个作业的目标 |</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hhhqqq/p/12306200.html</dc:identifier>
</item>
<item>
<title>OpenCV3入门（六）图像滤波 - 啊哈彭</title>
<link>http://www.cnblogs.com/pingwen/p/12305777.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pingwen/p/12305777.html</guid>
<description>&lt;h2&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;strong&gt;、图像滤波理论&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1.1&lt;/strong&gt;&lt;strong&gt;图像滤波理论&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;图像滤波即在尽量保留图像细节特征的条件下对目标图像的噪声进行抑制，是图像预处理中不可缺少的操作。消除图像中的噪声又叫做图像滤波或平滑，滤波的目的有两个，一是突出特征以方便处理，二是抑制噪声。&lt;/p&gt;
&lt;p&gt;空间域滤波就是在图像平面上对像素进行操作。空间域滤波大体分为两类：平滑、锐化。&lt;/p&gt;
&lt;p&gt;平滑滤波：模糊处理，用于减小噪声，实际上是低通滤波，典型的滤波器是高斯滤波。&lt;/p&gt;
&lt;p&gt;锐化滤波：提取边缘突出边缘及细节、弥补平滑滤波造成的边缘模糊。实际上是高通滤波。&lt;/p&gt;
&lt;p&gt;空间域处理可由下式表示：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;g(x,y)=T[f(x,y)]&lt;/p&gt;
&lt;p&gt;式中，f(x,y)是输入图像，g(x,y)是处理后的图像，T是在点(x,y)的邻域上定义的关于f的一种算子，算子可应用于单幅图像或图像集合。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.2&lt;/strong&gt;&lt;strong&gt;邻域滤波算子&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1）空间滤波器由一个邻域（通常是一个较小的矩形）和对该邻域所包围图像像素执行的预定义操作组成。对预定义的点（x，y）为中心的领域内的像素进行计算。&lt;/p&gt;
&lt;p&gt;2）滤波产生一个新像素，用计算后的新像素值代替点（x，y）的值。&lt;/p&gt;
&lt;p&gt;3）循环步骤1和2，滤波器的中心遍历图像中的每个像素后，就生成了滤波后的图像。&lt;/p&gt;
&lt;p&gt;4）如果在图像像素上执行的是线性操作，则该滤波器称为线性空间滤波器，否则，称为非线性空间滤波器。&lt;/p&gt;
&lt;p&gt;一般来说，使用大小为 m×n的滤波器对大小为 M×N的图像进行线性空间滤波，可由下式表示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/743748/202002/743748-20200213224955385-605213430.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;strong&gt;、OpenCV&lt;/strong&gt;&lt;strong&gt;滤波方法&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;滤波处理分为两大类：线性滤波和非线性滤波。OpenCV里有这些滤波的函数，使用起来非常方便。&lt;/p&gt;
&lt;p&gt;线性滤波：&lt;/p&gt;
&lt;p&gt;1.方框滤波BoxBlur：模糊图像&lt;/p&gt;
&lt;p&gt;2.均值滤波Blur：模糊图像&lt;/p&gt;
&lt;p&gt;3.高斯滤波GaussianBlur：信号的平滑处理，去除符合正太分布的噪声&lt;/p&gt;
&lt;p&gt;非线性滤波：&lt;/p&gt;
&lt;p&gt;1.中值滤波mediaBlur：去除椒盐噪声&lt;/p&gt;
&lt;p&gt;2.双边滤波BilateralFilter：保边去噪&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;strong&gt;、线性滤波器&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;3.1平滑滤波&lt;/p&gt;
&lt;p&gt;一般来说，图像具有局部连续的性质，即相邻的像素的值相近，而噪声使得噪点处产生像素跳跃，所以通过平滑噪点可以减少噪声，去除图像中的不相关细节。&lt;/p&gt;
&lt;p&gt;方框滤波BoxBlur和均值滤波Blur都是对邻域内做平均值来滤波，属于平滑滤波。滤波的输出是包含在滤波器模板邻域内的像素的平均值，方框滤波做归一化之后就变为均值滤波，这两个滤波器都是低通滤波器。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/743748/202002/743748-20200213225052105-783307521.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;函数原型如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
CV_EXPORTS_W &lt;span&gt;void&lt;/span&gt; boxFilter( InputArray src, OutputArray dst, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; ddepth,
                             Size ksize, Point anchor&lt;/span&gt;=Point(-&lt;span&gt;1&lt;/span&gt;,-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;),
                             &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; normalize=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
                             &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; borderType=&lt;span&gt;BORDER_DEFAULT );
CV_EXPORTS_W &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; blur( InputArray src, OutputArray dst,
                          Size ksize, Point anchor&lt;/span&gt;=Point(-&lt;span&gt;1&lt;/span&gt;,-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;),
                          &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; borderType=BORDER_DEFAULT );
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.2高斯滤波&lt;/p&gt;
&lt;p&gt;高斯滤波对于图像来说就是一个低通滤波，广泛用于消除高斯噪声，高速滤波就是一种加权滤波，只不过模板中的系数由高斯分布来确定的，高斯滤波器根据高斯函数的形状来选择滤波模板权值的线性平滑滤波器。高斯平滑滤波器对于抑制服从正态分布的噪声非常有效。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
CV_EXPORTS_W &lt;span&gt;void&lt;/span&gt;&lt;span&gt; GaussianBlur( InputArray src,
                                   OutputArray dst, Size ksize,
                                   &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; sigmaX, &lt;span&gt;double&lt;/span&gt; sigmaY=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
                                   &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; borderType=BORDER_DEFAULT );
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.3测试实验&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;74&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Mat img;
Mat img1, img2, img3;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; gBoxFilterValue = &lt;span&gt;3&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; gMeanBlurValue = &lt;span&gt;3&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; gGaussianBlurValue = &lt;span&gt;3&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; OnBoxFilter(&lt;span&gt;int&lt;/span&gt; filterSz, &lt;span&gt;void&lt;/span&gt; *&lt;span&gt;)
{
    boxFilter(img, img1, &lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;, Size(filterSz +&lt;span&gt;1&lt;/span&gt;, filterSz +&lt;span&gt;1&lt;/span&gt;&lt;span&gt;));
    imshow(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;方框滤波&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, img1);
}

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; OnMeaanBlur(&lt;span&gt;int&lt;/span&gt; filterSz, &lt;span&gt;void&lt;/span&gt; *&lt;span&gt;)
{
    blur(img, img2, Size(filterSz &lt;/span&gt;+ &lt;span&gt;1&lt;/span&gt;, filterSz + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;));
    imshow(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;均值滤波&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, img2);
}

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; OnGaussinanBlur(&lt;span&gt;int&lt;/span&gt; filterSz, &lt;span&gt;void&lt;/span&gt; *&lt;span&gt;)
{
    GaussianBlur(img, img3, Size(filterSz&lt;/span&gt;*&lt;span&gt;2&lt;/span&gt; + &lt;span&gt;1&lt;/span&gt;, filterSz*&lt;span&gt;2&lt;/span&gt; + &lt;span&gt;1&lt;/span&gt;), &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
    imshow(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;高斯滤波&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, img3);
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main() {
    img &lt;/span&gt;= imread(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D:/WORK/5.OpenCV/LeanOpenCV/pic_src/pic2.bmp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    img1 &lt;/span&gt;=&lt;span&gt; img.clone();
    img2 &lt;/span&gt;=&lt;span&gt; img.clone();
    img3 &lt;/span&gt;=&lt;span&gt; img.clone();
    imshow(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;原图&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, img);

    namedWindow(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;方框滤波&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    createTrackbar(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;内核值&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;方框滤波&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &amp;amp;gBoxFilterValue, &lt;span&gt;40&lt;/span&gt;&lt;span&gt;, OnBoxFilter);
    OnBoxFilter(gBoxFilterValue, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

    namedWindow(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;均值滤波&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    createTrackbar(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;内核值&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;均值滤波&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &amp;amp;gMeanBlurValue, &lt;span&gt;40&lt;/span&gt;&lt;span&gt;, OnMeaanBlur);
    OnMeaanBlur(gMeanBlurValue, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

    namedWindow(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;高斯滤波&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    createTrackbar(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;内核值&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;高斯滤波&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &amp;amp;gGaussianBlurValue, &lt;span&gt;40&lt;/span&gt;&lt;span&gt;, OnGaussinanBlur);
    OnGaussinanBlur(gGaussianBlurValue, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
    waitKey(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果如下图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/743748/202002/743748-20200213230539188-2060304414.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;4、非线性滤波器&lt;/h2&gt;
&lt;p&gt;4.1中值滤波&lt;/p&gt;
&lt;p&gt;中值滤波属于非线性滤波，其思想用滤波模板邻域内的像素的平均值来代替像素点的灰度值。中值滤波器是一种统计排序滤波器，图像上点（x，y），中值滤波以该点为中心，领域内所有像素的统计排序中值作为此点的响应，中值滤波是非线性滤波。相比与均值滤波和高斯滤波，中值滤波可以有效的降低随机噪声，直接忽略掉噪声点，把噪声引起的模糊降到最低。线性滤波器在滤波的同时会造成图像细节模糊，中值滤波可以避免这个问题，其典型的应用就是中值滤波消除斑点噪声、椒盐噪声。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
CV_EXPORTS_W &lt;span&gt;void&lt;/span&gt; medianBlur( InputArray src, OutputArray dst, &lt;span&gt;int&lt;/span&gt; ksize );
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用中值滤波，滤除椒盐噪声例子如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
img = imread(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D:/WORK/5.OpenCV/LeanOpenCV/pic_src/pic2.bmp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    salt(img, &lt;/span&gt;&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;);

    img1 &lt;/span&gt;=&lt;span&gt; img.clone();
    img2 &lt;/span&gt;=&lt;span&gt; img.clone();
    img3 &lt;/span&gt;=&lt;span&gt; img.clone();
    imshow(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;原图&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, img);

    namedWindow(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;高斯滤波&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    createTrackbar(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;内核值&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;高斯滤波&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &amp;amp;gGaussianBlurValue, &lt;span&gt;40&lt;/span&gt;&lt;span&gt;, OnGaussinanBlur);
    OnGaussinanBlur(gGaussianBlurValue, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

    namedWindow(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;中值滤波&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    createTrackbar(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;内核值&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;中值滤波&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &amp;amp;gMedianBlurValue, &lt;span&gt;40&lt;/span&gt;&lt;span&gt;, OnMedianBlur);
    OnMedianBlur(gMedianBlurValue, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

    waitKey(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果如下图。高斯滤波在滤除噪点的同时也造成了图像模糊，如果增大内核则会造成严重模糊失真，而中值滤波对椒盐噪声有很好的抑制作用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/743748/202002/743748-20200213230315301-1909287398.png&quot; alt=&quot;&quot; width=&quot;781&quot; height=&quot;279&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.2双边滤波&lt;/p&gt;
&lt;p&gt;高斯滤波属于加权平均滤波，距离中心点越近的点越有较大权重，这种方法符合图像的平滑变化的特征，但是在边缘区域，像素值出现突变，这种方法反而会滤掉边缘轮廓，损失掉有用的边缘信息。边缘保护滤波方法，双边滤波就是最常用的边缘保护滤波方法，就是为了处理这种情况而发明的。&lt;/p&gt;
&lt;p&gt;双边滤波（Bilateral filter）是一种非线性的滤波方法，是结合图像的空间邻近度和像素值相似度的一种折衷处理，同时考虑空域信息和灰度相似性，达到保边去噪的目的。双边滤波将高斯滤波中通过各个点到中心点的空间临近度计算的各个权值进行优化，将其优化为空间临近度计算的权值和像素值相似度计算的权值的乘积，优化后的权值再与图像作卷积运算，从而达到保边去噪的效果。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
CV_EXPORTS_W &lt;span&gt;void&lt;/span&gt; bilateralFilter( InputArray src, OutputArray dst, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; d,
                                   &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; sigmaColor, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; sigmaSpace,
                                   &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; borderType = BORDER_DEFAULT );
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;InputArray src: 输入图像，可以是Mat类型，图像必须是8位或浮点型单通道、三通道的图像。&lt;/p&gt;
&lt;p&gt;OutputArray dst: 输出图像，和原图像有相同的尺寸和类型。&lt;/p&gt;
&lt;p&gt;int d: 表示在过滤过程中每个像素邻域的直径范围。如果这个值是非正数，则函数会从第五个参数sigmaSpace计算该值。&lt;/p&gt;
&lt;p&gt;double sigmaColor: 颜色空间过滤器的sigma值，这个参数的值越大，更大的值域空间影响结果。&lt;/p&gt;
&lt;p&gt;double sigmaSpace: 坐标空间中滤波器的sigma值，如果该值较大，更大的定义域空间影响结果。&lt;/p&gt;
&lt;p&gt;int borderType=BORDER_DEFAULT:边界模式，有默认值BORDER_DEFAULT.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; OnBilateralFilter(&lt;span&gt;int&lt;/span&gt; filterSz, &lt;span&gt;void&lt;/span&gt; *&lt;span&gt;)
{
    bilateralFilter(img, img3, filterSz, filterSz &lt;/span&gt;* &lt;span&gt;2&lt;/span&gt;, filterSz / &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
    imshow(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;双边滤波&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, img3);
}

namedWindow(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;双边滤波&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
createTrackbar(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;内核值&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;双边滤波&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &amp;amp;gMedianBlurValue, &lt;span&gt;40&lt;/span&gt;&lt;span&gt;, OnBilateralFilter);
OnBilateralFilter(gMedianBlurValue, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出效果如下图。双边滤波在较大的参数范围内都保持了很好的噪声抑制特性，并且没有造成边缘模糊。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/743748/202002/743748-20200213230448945-1521147649.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;5、遇到的问题medianBlur报异常&lt;/h2&gt;
&lt;p&gt;调节中值滤波的滑动条时，出现异常。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/743748/202002/743748-20200213225503474-4673743.png&quot; alt=&quot;&quot; width=&quot;223&quot; height=&quot;241&quot;/&gt;&lt;/p&gt;
&lt;p&gt;vs报错：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;未经处理的异常：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;0x00007FF835C09159 处(位于 Day1.exe 中)有未经处理的异常: Microsoft C++ 异常: cv::Exception，位于内存位置 0x000000F29FAFE138 处。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/743748/202002/743748-20200213225607451-3409111.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;中值滤波的参数ksize需要为偶数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
@param src input &lt;span&gt;1&lt;/span&gt;-, &lt;span&gt;3&lt;/span&gt;-, or &lt;span&gt;4&lt;/span&gt;-channel image; when ksize &lt;span&gt;is&lt;/span&gt; &lt;span&gt;3&lt;/span&gt; or &lt;span&gt;5&lt;/span&gt;&lt;span&gt;, the image depth should be
CV_8U, CV_16U, or CV_32F, &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; larger aperture sizes, it can only be CV_8U.
@param dst destination array of the same size and type &lt;/span&gt;&lt;span&gt;as&lt;/span&gt;&lt;span&gt; src.
@param ksize aperture linear size; it must be odd and greater than &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;for&lt;/span&gt; example: &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;7&lt;/span&gt;&lt;span&gt; ...
@sa  bilateralFilter, blur, boxFilter, GaussianBlur
 &lt;/span&gt;*/&lt;span&gt;
CV_EXPORTS_W &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; medianBlur( InputArray src, OutputArray dst, &lt;span&gt;int&lt;/span&gt; ksize );
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; OnMedianBlur(&lt;span&gt;int&lt;/span&gt; filterSz, &lt;span&gt;void&lt;/span&gt; *&lt;span&gt;)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (filterSz % &lt;span&gt;2&lt;/span&gt; == &lt;span&gt;0&lt;/span&gt;) filterSz += &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    medianBlur(img, img2, filterSz);
    imshow(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;中值滤波&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, img2);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试效果图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/743748/202002/743748-20200213230504980-673408722.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;6、参考文献&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;1、《OpenCV3 编程入门》，电子工业出版社，毛星雨著&lt;/p&gt;
&lt;p&gt;2、《学习OpenCV》，清华大学出版社，Gary Bradski， Adrian kaehler著&lt;/p&gt;
&lt;p&gt;3、OpenCV双边滤波详解及实代码实现&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_36359022/article/details/80198890&quot;&gt;https://blog.csdn.net/qq_36359022/article/details/80198890&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4、Bilateral Filtering for Gray and Color Images&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://users.soe.ucsc.edu/~manduchi/Papers/ICCV98.pdf&quot;&gt;https://users.soe.ucsc.edu/~manduchi/Papers/ICCV98.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;5、Smoothing Images&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.opencv.org/4.1.2/dc/dd3/tutorial_gausian_median_blur_bilateral_filter.html&quot;&gt;https://docs.opencv.org/4.1.2/dc/dd3/tutorial_gausian_median_blur_bilateral_filter.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;6、OpenCV图像处理之滤波&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_30815237/article/details/86690190&quot;&gt;https://blog.csdn.net/qq_30815237/article/details/86690190&lt;/a&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;3.5368421052632&quot;&gt;
&lt;p&gt;尊重原创技术文章，转载请注明。&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://www.cnblogs.com/pingwen/p/12305777.html&quot;&gt;https://www.cnblogs.com/pingwen/p/12305777.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 13 Feb 2020 15:00:00 +0000</pubDate>
<dc:creator>啊哈彭</dc:creator>
<og:description>OpenCV3入门（六）图像滤波</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/pingwen/p/12305777.html</dc:identifier>
</item>
<item>
<title>Spring基础(一)_控制反转(IOC) - 余生是你丿</title>
<link>http://www.cnblogs.com/Brilliance-Chan/p/12305752.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Brilliance-Chan/p/12305752.html</guid>
<description>&lt;h2 id=&quot;简述&quot;&gt;1、简述&lt;/h2&gt;
&lt;h3 id=&quot;依赖注入di&quot;&gt;1.1 依赖注入DI&lt;/h3&gt;
&lt;p&gt;现实开发中，每一个应用都会由两个或多个类组成，这些类之间相互协作完成特定的业务逻辑。根据传统做法，&lt;strong&gt;每个对象负责管理与自己协作的对象的引用（也就是，每个对象中使用new实例化对象的方式创建协作的对象）&lt;/strong&gt;——这将导致==高度耦合和难以测试的代码==。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ClassA{
    private ClassB b;//B类的依赖
    
    public ClassA(){
        this.b=new ClassB();//A与B紧耦合
    }
}

public class ClassB{}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;DI 的出现就是为了解决对象之间的依赖关系所带来的高耦合问题。【依赖注入 (DI，Dependency Injection)】：将&lt;strong&gt;所依赖的关系自动交给目标对象&lt;/strong&gt;，而不是让对象本身去获取依赖。依赖注入所关注的是&lt;strong&gt;已经创建好的对象如何实现它们之间的依赖关系&lt;/strong&gt;；至于这些对象怎么被创建和管理，稍后会讲述。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ClassA{
    private ClassB b;
    
    public ClassA(ClassB b){
        this.b=b;//B是被注入进来的
    }
}

public class ClassB{}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;DI&lt;/strong&gt; 的实现所带来的好处是：&lt;strong&gt;和面向接口实现松耦合&lt;/strong&gt;。一个对象通过接口来表明依赖关系，这样就可以在对象不确定的情况下，使用不同的具体实现进行替换——【松耦合】。&lt;/p&gt;
&lt;h3 id=&quot;bean&quot;&gt;1.2 Bean&lt;/h3&gt;
&lt;p&gt;在 Spring 应用中，&lt;strong&gt;一个 Bean 对象对应一个对象&lt;/strong&gt;，并存储于 Spring 容器中，&lt;strong&gt;Spring 容器负责创建对象，装配、配置对象，以及管理整个对象的生命周期，从生存到死亡&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&quot;spring容器&quot;&gt;1.2.1 Spring容器&lt;/h4&gt;
&lt;p&gt;容器是 Spring 框架的核心。Spring 容器使用 &lt;strong&gt;DI&lt;/strong&gt; 管理构成应用的组件，它会创建相互协作的组件之间的关联。Spring 自带多个容器实现，主要分为两种类型：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;bean 工厂&lt;/strong&gt;：由 &lt;code&gt;org.springframework.beans.factory.BeanFactory&lt;/code&gt; 接口定义，是最简单的容器，提供基本的 DI 支持；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;应用上下文&lt;/strong&gt;：由 &lt;code&gt;org.springframework.context.ApplicationContext&lt;/code&gt; 接口定义，基于 BeanFactory 构建，并提供应用框架级别的服务；&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;a.-使用应用上下文&quot;&gt;A. 使用应用上下文&lt;/h5&gt;
&lt;p&gt;Spring 自带了多种类型的应用上下文。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;9.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;AnnotationConfigApplication&lt;/td&gt;
&lt;td&gt;从一个或多个基于 java 的配置类中加载 Spring 应用上下文&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;AnnotationConfigWebApplicationContext&lt;/td&gt;
&lt;td&gt;从一个或多个基于 Java 的配置类中加载 Spring Web 应用上下文&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;ClasssPathXmlApplicationContext&lt;/td&gt;
&lt;td&gt;从类路径下的一个或多个 XML 配置文件中加载上下文定义，把应用上下文的定义文件作为类资源&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;FileSystemXmlApplicationContext&lt;/td&gt;
&lt;td&gt;从文件系统下的一个或多个XML配置文件中加载上下文定义&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;XmlWebApplicationContext&lt;/td&gt;
&lt;td&gt;从 Web 应用下的一个或多个 XML 配置文件中加载上下文定义&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h5 id=&quot;b.-bean的生命周期&quot;&gt;B. Bean的生命周期&lt;/h5&gt;
&lt;p&gt;Java 中通过 new 实例化的对象，其生命周期是从被创建开始，直到不再被调用，该对象就由 Java 自动进行垃圾回收。&lt;/p&gt;
&lt;p&gt;在 Spring 中，Bean 对象的生命周期相对复杂，其包含了以下过程：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Spring 对 bean 进行实例化；&lt;/li&gt;
&lt;li&gt;Spring 将值和 bean 的引用注入到 bean 对应的属性中；&lt;/li&gt;
&lt;li&gt;如果 bean 实现了以下对象，会进行相应的操作：
&lt;ul&gt;&lt;li&gt;实现 &lt;code&gt;BeanNameAware&lt;/code&gt; 接口，Spring 将 bean 的 ID 传递给 &lt;code&gt;setBeanName()&lt;/code&gt; 方法；&lt;/li&gt;
&lt;li&gt;实现 &lt;code&gt;BeanFactoryAware&lt;/code&gt; 接口，Spring 将调用 &lt;code&gt;setBeanFactory()&lt;/code&gt; 方法，将 BeanFactory 容器传入；&lt;/li&gt;
&lt;li&gt;实现 &lt;code&gt;BeanPostProcessor&lt;/code&gt; 接口，Spring 将调用 &lt;code&gt;postProcessBeforeInitialization()&lt;/code&gt; 方法；&lt;/li&gt;
&lt;li&gt;实现 &lt;code&gt;InitializingBean&lt;/code&gt; 接口，Spring 将调用 &lt;code&gt;afterPropertiesSet()&lt;/code&gt; 方法。如果 bean 使用 init-method 声明初始化方法，该方法也会被调用；&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;bean 创建完毕，可被应用使用；此时，它们一直驻留在应用上下文，直到该应用上下文被销毁；&lt;/li&gt;
&lt;li&gt;如果 bean 实现了 &lt;code&gt;DisposableBean&lt;/code&gt; 接口，Spring 将调用 &lt;code&gt;destory()&lt;/code&gt; 方法。同样，如果 bean 使用 &lt;code&gt;destory-method&lt;/code&gt; 声明了销毁方法，该方法也会被调用；&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;装配bean&quot;&gt;2、装配Bean&lt;/h2&gt;
&lt;p&gt;在 Spring 中，对象无需自己查找或创建与其所关联的其他对象。相反，容器负责把需要相互协作的对象引用赋予各个对象。&lt;strong&gt;创建应用对象之间协作关系的行为&lt;/strong&gt;称为【装配 (wiring)】。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;装配 bean 的三种机制&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;隐式的 bean 发现机制和自动装配；&lt;/li&gt;
&lt;li&gt;在 Java 中进行显示配置；&lt;/li&gt;
&lt;li&gt;在 XML 中进行显示配置&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;尽管，Spring 中提供了多种方案来配置 bean，我们在配置时可视情况进行选择合适的方式进行装配我们的 bean 对象。建议是：&lt;strong&gt;尽可能使用自动配置机制；显示配置越少越好&lt;/strong&gt;。而且，使用选择显示配置时，&lt;u&gt;JavaConfig 配置会比 XML 配置更加强大，类型更安全&lt;/u&gt;。&lt;/p&gt;
&lt;h3 id=&quot;自动化装配&quot;&gt;2.1 自动化装配&lt;/h3&gt;
&lt;p&gt;Spring 是从两个方面实现自动装配：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;组件扫描 (component Scan)&lt;/strong&gt;：Spring 会自动发现应用上下文中所创建的 bean；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;自动装配 (autowiring)&lt;/strong&gt;：Spring 自动满足 bean 之间到依赖；&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;创建组件和自动装配&quot;&gt;2.1.1 创建组件和自动装配&lt;/h4&gt;
&lt;p&gt;创建组件类时，常用的注解有：&lt;/p&gt;
&lt;ol readability=&quot;3&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;code&gt;@Component&lt;/code&gt; ：创建一个组件类，用于被 Spring 扫描并创建 Bean 对象；&lt;/p&gt;
&lt;p&gt;该注解可以为当前类设定 ID 值，&lt;code&gt;@Component(&quot;ID_value&quot;)&lt;/code&gt; 。没有设定 ID 值时，默认为&lt;strong&gt;类名的首字母为小写&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;&lt;code&gt;@Autowire&lt;/code&gt; ：自动装配，为 Bean 的属性注入对象。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Autowire&lt;/code&gt; 可以用在&lt;strong&gt;定义属性的语句上&lt;/strong&gt;、&lt;strong&gt;有参构造方法&lt;/strong&gt;以及 &lt;strong&gt;&lt;code&gt;set()&lt;/code&gt;方法&lt;/strong&gt;上。使用注解，会在 Spring 应用上下文中寻找匹配的 bean 对象。&lt;/p&gt;
&lt;p&gt;在使用 &lt;code&gt;@Autowire&lt;/code&gt; 注解时，需要注意两个问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果当前 Bean 对象的依赖关系，==没有匹配的其它 Bean==，Spring 应用上下文在创建该 Bean 时，会抛出异常；&lt;strong&gt;使用注解的属性 required=false，如果找不到匹配的 Bean，会处于未装配状态：null&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;如果当前 Bean 对象的依赖关系，==存在多个满足匹配的其它 Bean==，Spring 也将抛出异常；这涉及到 &lt;em&gt;装配的歧义性&lt;/em&gt; 。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;组件扫描&quot;&gt;2.1.2 组件扫描&lt;/h4&gt;
&lt;p&gt;上节简单讲述了如何创建一个组件类，以及如何实现自动装配依赖关系。但这并不代表：在Spring容器中创建了一个 Bean 对象。要想创建一个 Bean 对象，需要&lt;strong&gt;配置 Spring 的组件扫描，命令 Spring 寻找带 &lt;code&gt;@Component&lt;/code&gt; 注解的类，并创建 Bean&lt;/strong&gt;，因为 &lt;strong&gt;Spring 中组件扫描功能默认是不启用&lt;/strong&gt;。那么，如何启用组件扫描呢？——有两种方式：&lt;/p&gt;
&lt;ol readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;基于 Java 的配置&lt;/p&gt;
&lt;p&gt;需要创建一个配置类，该类与普通类的区别在于：&lt;strong&gt;使用注解 &lt;code&gt;@Configuration&lt;/code&gt; 修饰&lt;/strong&gt;。开启组件扫描，需要使用另一个注解 &lt;code&gt;@ComponentScan&lt;/code&gt; 。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package soundsystem;

import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;

@Configuration
@ComponentScan
public class CDPlayerConfig {

}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;XML 文件配置&lt;/p&gt;
&lt;p&gt;在 XML 中配置启用组件扫描，需要使用 &lt;strong&gt;Spring context 命名空间&lt;/strong&gt; 的 &lt;code&gt;&amp;lt;context:component-scan&amp;gt;&lt;/code&gt; 元素。&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:Context =&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&amp;gt;

    &amp;lt;Context:component-scan base-package=&quot;soundsystem&quot;/&amp;gt;
&amp;lt;/beans&amp;gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;细心的小伙伴可能发现了，在 XML 文件配置中，&lt;code&gt;base-package&lt;/code&gt; 属性是必须给定的。该属性是指定组件扫描的基础包，也就是指定哪些包是需要使用组件扫描。&lt;/p&gt;
&lt;p&gt;在 Java 配置中，&lt;code&gt;@ComponentScan&lt;/code&gt; 注解中可使用 &lt;strong&gt;basePackages 属性&lt;/strong&gt;和 &lt;strong&gt;basePackageClasses 属性&lt;/strong&gt;来指定组件扫描的基础包。前者给定值是包路径的 String 类型，后者是 &lt;code&gt;.class&lt;/code&gt; 类文件（类文件所在的包会作为基础包）。它们的值可以是单一值，也可以是复数形式。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@ComponentScan(basePackages={&quot;package1&quot;,&quot;package2&quot;,...})//使用String类型表示，是类型不安全的；当重构代码时，容易发生错误
//@ComponentScan(basePackageClasses={Xxx1.class,Xxx2.class,...})
public class CDPlayerConfig{
    
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;显式装配&quot;&gt;2.2 显式装配&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;大多数情况下，通过组件扫描和自动装配实现 Spring 的自动化配置更为推荐。但有些情况，比如：将第三方库中的组件装配到应用中，使用 &lt;code&gt;@Component&lt;/code&gt; 和 &lt;code&gt;@Autowired&lt;/code&gt; 无法进行注解，这就必须采用显式装配。显式装配的方案有：Java 和 XML。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;java-配置&quot;&gt;2.2.1 Java 配置&lt;/h4&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;在 2.1.2 组件扫描 中，已经提及如何创建一个 Java 配置类，就不在重复讲述。在配置类中，通过方法形式和注解 &lt;code&gt;@Bean&lt;/code&gt; 创建 Bean 对象。Java 配置的好处是：在创建 Bean 的过程中，可以使用 Java 代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 Java 配置类中声明 Bean，需要编写一个方法，这个方法会返回 创建所需类型的实例，然后给这个方法添加 &lt;code&gt;@Bean&lt;/code&gt; 注解；默认情况下，&lt;code&gt;@Bean&lt;/code&gt; 注解会设定与方法名一样的 ID 值，可以使用 name 属性指定不同的名字。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package cn.book.main;

import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Bean;

@Configuration
public class StudentConfig {
    
    @Bean
    //@Bean(name=&quot;stu&quot;)
    public Student getStu(){
        return new Student();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package cn.book.main;

public class Student {
    private String name;
    private int age;
    
    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public Student() {
    }
    
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个简单的例子中，通过无参构造方法创建实例，是声明 Bean 最简单的方法，因为没有为 Bean 注入依赖关系。在配置类中，实现依赖注入的方式都是&lt;strong&gt;通过有参构造方法创建&lt;/strong&gt;，只是获取要注入的 Bean 的形式有两种：&lt;/p&gt;
&lt;ol readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;引用配置类中创建 Bean 的方法；&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; @Bean
public String getStuName(){
    return &quot;Tom&quot;;
}

@Bean
public int getStuAge(){
    return 18;
}

@Bean
public Student getStu(){
    return new Student(getStuName(),getStuAge());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;只能注入配置类中的 Bean 对象；&lt;/li&gt;
&lt;li&gt;Bean 对象是单例的。方法被调用时，spring 会拦截调用的方法，如果容器中已创建该方法返回的 Bean 对象，则直接赋予，而不会再执行方法内的操作。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;通过方法参数传递；&lt;/p&gt;
&lt;p&gt;Java 或 XML 配置中创建的 Bean 对象、组件扫描发现的 Bean 对象，都可以通过方法参数传递并注入。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Bean
public Student getStu(String name,int age){
 return new Student(name,age);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;xml-配置&quot;&gt;2.2.2 XML 配置&lt;/h4&gt;
&lt;p&gt;在使用 XML 装配 Bean 之前，需要创建一个新的配置规范，这意味着要创建一个 XML 文件，并且以 &lt;code&gt;&amp;lt;beans&amp;gt;&lt;/code&gt; 元素为根。下面是最为简单的 Spring XML 配置：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans 
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context &quot;&amp;gt;

&amp;lt;/beans&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;a声明-bean&quot;&gt;A、声明 Bean&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;无参构造器声明 bean&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;XML 配置中使用 &lt;code&gt;&amp;lt;bean&amp;gt;&lt;/code&gt; 元素来声明一个 bean，该元素类似于 Java 配置中的 &lt;code&gt;@Bean&lt;/code&gt; 注解。&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;bean id=&quot;&quot; class=&quot;&quot; /&amp;gt; &amp;lt;!--这个元素将会调用类的默认构造器来创建 bean--&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;id：bean 的 ID 值；可以不指定，会默认为：&lt;strong&gt;包名.类名#0&lt;/strong&gt;。0为计数值，用来区分相同的 bean ，如果有相同的 bean ，计数值 + 1；&lt;/li&gt;
&lt;li&gt;class：指定创建 bean 的类，使用全限定类名；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;有参构造器声明 bean&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;要使用有参构造器创建 bean ，需要使用&lt;code&gt;&amp;lt;bean&amp;gt;&lt;/code&gt; 的 &lt;code&gt;&amp;lt;constructor-arg&amp;gt;&lt;/code&gt;元素，此方式在声明 bean 的同时，并注入其它依赖关系。该元素中有五个属性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;name：指定参数名称，&lt;strong&gt;与构造方法中的参数名一致&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;value：赋予参数的值；注入常量值，可以是&lt;strong&gt;基本类型和String&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;type：参数的类型&lt;/li&gt;
&lt;li&gt;index：指定参数在构造方法中的顺序号（从0开始）&lt;/li&gt;
&lt;li&gt;ref：要注入的 bean 的 ID 值；&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;bean id=&quot;&quot; class=&quot;&quot;&amp;gt;
    &amp;lt;constructor-arg name=&quot;&quot; value=&quot;&quot; type=&quot;&quot; index=&quot;&quot;/&amp;gt;
    &amp;lt;constructor-arg name=&quot;&quot; type=&quot;&quot; index=&quot;&quot; ref=&quot;&quot; /&amp;gt;
&amp;lt;/bean&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;bean&lt;/code&gt; 元素中的&lt;strong&gt;参数名称&lt;/strong&gt;要与构造方法中的参数名一致；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bean&lt;/code&gt; 元素中的&lt;strong&gt;参数顺序&lt;/strong&gt;可以与构造方法中的参数顺序不一致；&lt;strong&gt;可以使用 index 属性指定在构造方法的顺序&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;使用 type 属性时，对于&lt;strong&gt;引用类型需要使用包名+类名&lt;/strong&gt;；基本类型可以不用该属性；&lt;/li&gt;
&lt;/ol&gt;&lt;h5 id=&quot;b注入&quot;&gt;B、注入&lt;/h5&gt;
&lt;p&gt;在 XML 配置文件中，注入 bean 的方式有三种：有参构造器注入 &lt;code&gt;&amp;lt;constructor-arg&amp;gt;&lt;/code&gt;、属性注入 &lt;code&gt;&amp;lt;property&amp;gt;&lt;/code&gt; 以及自动注入 &lt;code&gt;&amp;lt;autowire&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;属性注入&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;属性注入的实质是：&lt;strong&gt;调用 &lt;code&gt;set()&lt;/code&gt; 方法&lt;/strong&gt;。在声明 bean 的元素中，使用 &lt;code&gt;&amp;lt;property&amp;gt;&lt;/code&gt; 元素。&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;bean id=&quot;&quot; class=&quot; &quot;&amp;gt;
        &amp;lt;property name=&quot;&quot; value=&quot;&quot;/&amp;gt;
        &amp;lt;property name=&quot;&quot; ref=&quot;&quot;/&amp;gt;
&amp;lt;/bean&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;自动注入&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;自动注入方式使用 &lt;code&gt;bean&lt;/code&gt; 元素中的属性 &lt;code&gt;autowire&lt;/code&gt;，该属性有三个值 &lt;code&gt;byName、byType、constructor&lt;/code&gt;，根据提供的值进行自动匹配注入。&lt;/p&gt;
&lt;ul readability=&quot;4&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;byName：在当前 XML 文件中，查找 &lt;strong&gt;bean 元素的 id 值与需要注入 bean 的属性名相同&lt;/strong&gt;的对象，进行匹配。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;byType：在当前 XML 文件中，查找 &lt;strong&gt;bean 标签的对象类型与需要注入 bean 的属性类型相同&lt;/strong&gt;的对象，进行匹配；此时，&lt;strong&gt;不需要关注 bean 标签的 id 值是否与需要注入的属性名一致&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;constructor：【1】根据&lt;strong&gt;需要注入对象的有参构造器的形参名&lt;/strong&gt;进行查找 ，找到匹配 bean 的 id 值则注入；否则，【2】根据&lt;strong&gt;需要注入对象的有参构造器的形参类型&lt;/strong&gt;进行查找，找到类型匹配的 bean 标签则注入。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;byName 和 byType&lt;/code&gt; 实际上是调用 &lt;code&gt;set()&lt;/code&gt; 方法赋值；&lt;code&gt;constructor&lt;/code&gt; 则是调用有参构造方法；&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;byName 和 byType&lt;/code&gt; 可以结合 &lt;code&gt;property&lt;/code&gt; 标签使用；可以结合 &lt;code&gt;constructor-org&lt;/code&gt; 标签使用，相当于调用多参的有参构造方法；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;c集合装配&quot;&gt;C、集合装配&lt;/h5&gt;
&lt;p&gt;Spring 中实现了对集合的装配，包括：Array、List、Set以及Map，它们对应的元素为：&lt;code&gt;&amp;lt;array&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;list&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;set&amp;gt;&lt;/code&gt; 以及&lt;code&gt;&amp;lt;map&amp;gt;&lt;/code&gt;，集合配置方式比较接近，这里举例 List 和 Map 集合的配置方式&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;list value-type=&quot;&quot;&amp;gt;&amp;lt;!--创建List，并声明存储值的类型--&amp;gt;
    &amp;lt;value type=&quot;&quot;&amp;gt;&amp;lt;/value&amp;gt;&amp;lt;!--集合包含的值，可声明数据类型--&amp;gt;
    &amp;lt;ref bean=&quot;&quot;/&amp;gt;&amp;lt;!--引用bean，使用bean的ID--&amp;gt;
&amp;lt;/list&amp;gt;

&amp;lt;map key-type=&quot;&quot; value-type=&quot;&quot;&amp;gt;&amp;lt;!--创建Map，并声明存储键-值的类型--&amp;gt;
    &amp;lt;entry key=&quot;&quot; value=&quot;&quot;/&amp;gt;&amp;lt;!--集合包含的值--&amp;gt;
    &amp;lt;entry key-ref=&quot;&quot; value-ref=&quot;&quot;/&amp;gt;&amp;lt;!--引用到键或值的bean，使用bean的ID--&amp;gt;
&amp;lt;/map&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;混合配置&quot;&gt;2.2.3 混合配置&lt;/h4&gt;
&lt;p&gt;当我们在装配 bean 时，如果同时采用 JavaConfig 和 XML 配置 bean 时，而它们的 bean 相互关联，这时，就需要将不同的配置文件组合在一起。&lt;/p&gt;
&lt;h5 id=&quot;ajavaconfig-中引用-xml-配置&quot;&gt;A、JavaConfig 中引用 XML 配置&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;多个 Java 配置组合&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用注解 &lt;code&gt;@Import&lt;/code&gt; 可以将其它 JavaConfig 配置类引入，&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//在配置类中引用另一个配置类
@Configuration
@Import(XxxConfig1.class)
public class Xxxconfig2{

}

//当然，也可以创建一个新的配置类，只用于组合配置类
@Configuration
@Import(XxxConfig1.class,XxxConfig2.class)
public class Config{
    
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;JavaConfig 配置中引用 XML 配置&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Configuration
@ImportResource(&quot;classpath:*/*/*.xml&quot;)
public class Config{

}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;bxml-配置中引用-javaconfig-配置&quot;&gt;B、XML 配置中引用 JavaConfig 配置&lt;/h5&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;bean class=&quot;*.*.Config&quot; /&amp;gt;&amp;lt;!--引入 JavaConfig 配置--&amp;gt;

&amp;lt;import resource=&quot;*/*/*.xml&quot; /&amp;gt;&amp;lt;!--引入 XML 配置--&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;高级装配&quot;&gt;3、高级装配&lt;/h3&gt;
&lt;h4 id=&quot;环境与profile&quot;&gt;3.1 环境与profile&lt;/h4&gt;
&lt;p&gt;应用中存在不同的环境，应用在不同的环境中需要配置不一样的 Bean，如果需要切换环境时，原环境的 Bean 在新环境中不一定可用，这时需要在新环境中配置新的 Bean，在 Spring 中，可以根据环境创建 Bean 或者不创建 Bean，这个就是 &lt;strong&gt;Profile 配置&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;跨环境配置的几个例子：数据库配置、加密算法以及外部系统的集成。&lt;/p&gt;
&lt;p&gt;在这里，我们不讨论如何配置不同的环境，只关注如何使用 &lt;code&gt;Profile&lt;/code&gt; 决定 Bean 的创建。现假设，我们应用中存在下面三个环境，环境名称为：dev、qa、prod。现在，我们要为指定的环境装配 Bean。&lt;/p&gt;
&lt;h5 id=&quot;配置profile&quot;&gt;3.1.1 配置Profile&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;JavaConfig 中配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;@Profile(&quot;Envionment_name&quot;)&lt;/code&gt; 注解，括号内指定环境名称，指定某个 Bean 属于哪一个 Profile。当指定的环境为激活状态时，该 Bean 被创建，否则不创建。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Configuration
//@Profile(&quot;dev&quot;)  //profile应用在类上，当环境激活时，该配置类才会被创建
public class ProfileConfig{

    @Bean(destroyMethod=&quot;shutdown&quot;) //使用在方法级别上，可以将不同环境的 Bean 放在同一配置类中
    @Profile(&quot;dev&quot;)
    public DataSource dataSource(){
        return new EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.H2)
            .addScript(&quot;classpath:schema.sql&quot;)
            .addScript(&quot;classpath:test-data.sql&quot;)
            .build();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;XML 中配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 XML 配置中，可以通过 &lt;code&gt;&amp;lt;Beans&amp;gt;&lt;/code&gt; 元素的 &lt;code&gt;profile&lt;/code&gt; 属性，在 XML 配置 Bean。下面是一个例子&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;beans profile=&quot;dev&quot;&amp;gt; &amp;lt;!--为dev配置一个 Bean--&amp;gt;
    &amp;lt;jdbc:embedded-database id=&quot;dataSource&quot; type=&quot;H2&quot;&amp;gt;
        &amp;lt;jdbc:script location=&quot;classpath:schema.sql&quot; /&amp;gt;
        &amp;lt;jdbc:script location=&quot;classpath:test-data.sql&quot; /&amp;gt;
    &amp;lt;/jdbc:embedded-database&amp;gt;
&amp;lt;/beans&amp;gt;

&amp;lt;beans profile=&quot;prod&quot;&amp;gt; &amp;lt;!--为prod配置一个 Bean--&amp;gt;
    &amp;lt;jee:jndi-lookup id=&quot;dataSource&quot;
                     lazy-init=&quot;true&quot;
                     jndi-name=&quot;jdbc/myDatabase&quot;
                     resource-ref=&quot;true&quot;
                     proxy-interface=&quot;javax.sql.DataSource&quot; /&amp;gt;
&amp;lt;/beans&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;激活profile&quot;&gt;3.1.2 激活Profile&lt;/h5&gt;
&lt;p&gt;Spring 在确定哪个 Profile 处于激活状态时，需要依赖两个独立的属性：&lt;code&gt;spring.profiles.active&lt;/code&gt; 和 &lt;code&gt;spring.profiles.default&lt;/code&gt;。前者会根据指定值来确定哪个 Profile 是激活的；后者是当没有指定 &lt;code&gt;active&lt;/code&gt; 属性的值时，默认激活的 Profile。Spring 中设置这两个属性的方式&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;作为 DispatcherServlet 的初始化参数；&lt;/li&gt;
&lt;li&gt;作为 Web 应用的上下文参数；&lt;/li&gt;
&lt;li&gt;作为 JNDI 条目；&lt;/li&gt;
&lt;li&gt;作为环境变量；&lt;/li&gt;
&lt;li&gt;作为 JVM 的系统属性；&lt;/li&gt;
&lt;li&gt;在记成测试类上，使用 &lt;code&gt;@ActiveProfiles&lt;/code&gt; 注解设置；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面的例子中，使用 DispatcherServlet 的参数将 &lt;code&gt;spring.profiles.default&lt;/code&gt; 设置 profile。在 Web 应用中，设置 &lt;code&gt;spring.profiles.default&lt;/code&gt; 的 web.xml 文件如下&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
         version=&quot;4.0&quot;&amp;gt;
    
    &amp;lt;!--为上下文设置默认的 profile--&amp;gt;
    &amp;lt;context-param&amp;gt;
        &amp;lt;param-name&amp;gt;spring.profiles.default&amp;lt;/param-name&amp;gt;
        &amp;lt;param-value&amp;gt;dev&amp;lt;/param-value&amp;gt;
    &amp;lt;/context-param&amp;gt;
    
    &amp;lt;servlet&amp;gt;
        &amp;lt;servlet-name&amp;gt;appServlet&amp;lt;/servlet-name&amp;gt;
        &amp;lt;servlet-class&amp;gt;cn.book.main.servlet.DispatcherServlet&amp;lt;/servlet-class&amp;gt;
        
        &amp;lt;!--为Servlet设置默认的 profile--&amp;gt;
        &amp;lt;init-param&amp;gt;
            &amp;lt;param-name&amp;gt;spring.profiles.default&amp;lt;/param-name&amp;gt;
            &amp;lt;param-value&amp;gt;dev&amp;lt;/param-value&amp;gt;
        &amp;lt;/init-param&amp;gt;
    &amp;lt;/servlet&amp;gt;
    &amp;lt;servlet-mapping&amp;gt;
        &amp;lt;servlet-name&amp;gt;appServlet&amp;lt;/servlet-name&amp;gt;
        &amp;lt;url-pattern&amp;gt;/appServlet&amp;lt;/url-pattern&amp;gt;
    &amp;lt;/servlet-mapping&amp;gt;
    
&amp;lt;/web-app&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;spring.profiles.active&lt;/code&gt; 和 &lt;code&gt;spring.profiles.default&lt;/code&gt; 属性中，profile 使用的是&lt;strong&gt;复数形式&lt;/strong&gt;，可以同时激活多个 Profile——通过列出多个 profile 名称，并以逗号分隔。&lt;/p&gt;
&lt;h4 id=&quot;条件化-bean&quot;&gt;3.2 条件化 Bean&lt;/h4&gt;
&lt;p&gt;如果我们定义的 bean ，但不希望它们被 Spring 容器即刻被创建，而是希望当类路径下包含某个库，或者是创建了其它 Bean，亦或者要求设置了某个特定环境变量后，该 Bean 才被创建。此时，我们就需要使用&lt;strong&gt;条件化配置&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;要实现一个条件化 Bean，在装配 Bean 的方法上( 使用&lt;code&gt;@Bean&lt;/code&gt; )，引用另一个注解 &lt;code&gt;@Conditional(*.class)&lt;/code&gt;，注意：&lt;strong&gt;括号内给定的是一个类文件&lt;/strong&gt;。该注解会根据&lt;strong&gt;括号内给定类的返回结果判断是否创建 Bean，如果为true，会创建 Bean，否则不创建&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;但是，这只是定义了一个要条件化的 Bean，该 Bean 需要满足怎样的条件，需要自己实现。上面说到，&lt;code&gt;@Conditional&lt;/code&gt; 注解需要传入一个类文件，&lt;strong&gt;该类在创建时，要实现 &lt;code&gt;Condition&lt;/code&gt; 接口，并重写 &lt;code&gt;matches()&lt;/code&gt; 方法&lt;/strong&gt;。下面是一个简单的例子&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package cn.book.main.pojo;

//Bean 类
public class TestCondition {

    public TestCondition() {
        System.out.println(&quot;Bean 被创建了&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该类实现 &lt;code&gt;Condition&lt;/code&gt; 接口，并重写 &lt;code&gt;matches()&lt;/code&gt; 方法，在方法内可以编写判断代码，并返回 boolean 值。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package cn.book.main.condition;

import org.springframework.context.annotation.Condition;
import org.springframework.context.annotation.ConditionContext;
import org.springframework.core.type.AnnotatedTypeMetadata;

public class IfCreatCondition implements Condition {
    @Override
    public boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata) {
        return false;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置类，装配 Bean。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package cn.book.resource;

import cn.book.main.condition.IfCreatCondition;
import cn.book.main.pojo.TestCondition;
import org.springframework.context.annotation.*;

@Configuration
public class HumanJobConfig {
    
    @Bean
    @Conditional(IfCreatCondition.class)
    public TestCondition getCondition(){
        return new TestCondition();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试类，如果 IfCreatCondition 类返回 true，则 Bean 被创建；否则不会被创建。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package cn.book.test;

import cn.book.resource.HumanJobConfig;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(classes=cn.book.resource.HumanJobConfig.class)
public class HumanJobTest {

    @Test
    public void Test(){

        AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(HumanJobConfig.class);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面只是演示了实现条件化 Bean 的流程，我们的条件可以再复杂。大家应该注意到了，&lt;code&gt;matches()&lt;/code&gt; 中有两个参数：&lt;code&gt;ConditionContext&lt;/code&gt; 和 &lt;code&gt;AnnotatedTypeMetadata&lt;/code&gt;。通过这两个对象，我们可以实现符合 IOC 和 DI 的条件。接下来，就来了解这两个对象：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ConditionContext&lt;/code&gt; 是一个接口，它有以下方法&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;getRegistry&lt;/td&gt;
&lt;td&gt;返回 BeanDefinitionRegistry 检查 bean 定义；&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;getBeanFactory&lt;/td&gt;
&lt;td&gt;返回 ConfigurableListableBeanFactory 检查 bean 是否存在，甚至 检查 bean 的属性；&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;getEnvironment&lt;/td&gt;
&lt;td&gt;返回 Environment 检查环境变量是否存在以及它的值是什么；&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;getResourceLoader&lt;/td&gt;
&lt;td&gt;返回 ResourceLoader 所加载的资源；&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;getClassLoader&lt;/td&gt;
&lt;td&gt;返回 ClassLoader 加载并检查类是否存在；&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;code&gt;AnnotatedTypeMetadata&lt;/code&gt; 也是一个接口，能够检查带有 &lt;code&gt;@Bean&lt;/code&gt; 注解的方法上还有什么注解。它有以下方法：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;11.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;boolean isAnnotated(String annotationType)&lt;/td&gt;
&lt;td&gt;检查带 &lt;code&gt;@Bean&lt;/code&gt; 的方法上是否存在其它特定的注解&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;Map&amp;lt;String,Object&amp;gt; getAnnotationAttributes(String annotationType)&lt;/td&gt;
&lt;td&gt;获得指定注解的 Bean&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;Map&amp;lt;String,Object&amp;gt; getAnnotationAttributes(String annotationType, boolean classValueAsString)&lt;/td&gt;
&lt;td&gt;==未了解==&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;MultiValueMap&amp;lt;String,Object&amp;gt; getAllAnnotationAttributes(String annotationType)&lt;/td&gt;
&lt;td&gt;获得指定注解的所有 Bean&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;MultiValueMap&amp;lt;String,Object&amp;gt; getAllAnnotationAttributes(String annotationType, boolean classValueAsString)&lt;/td&gt;
&lt;td&gt;==未了解==&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;处理自动装配的歧义性&quot;&gt;3.3 处理自动装配的歧义性&lt;/h4&gt;
&lt;p&gt;自动化装配中，仅当只有一个 Bean 满足时，才能装配成功。当多个 bean 满足装配时，Spring 会产生异常：&lt;code&gt;NoUniqueBeanDefinitionException&lt;/code&gt;。最常见的情况是：==当一个接口有多个实现类，调用时使用接口对象引用子类==。&lt;/p&gt;
&lt;p&gt;比如：Human接口有两个实现类：Man类和 Woman类&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package cn.book.main.entity;

public interface Human {
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package cn.book.main.entity;

import org.springframework.context.annotation.Primary;
import org.springframework.stereotype.Component;

@Component
public class Man implements Human {
    public Man() {
        System.out.println(&quot;I am man&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package cn.book.main.entity;

import org.springframework.stereotype.Component;

@Component
public class Woman implements Human {
    public Woman() {
        System.out.println(&quot;I am woman&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置类&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package cn.book.resource;

import cn.book.main.pojo.TestCondition;
import org.springframework.context.annotation.*;

@Configuration
@ComponentScan(&quot;cn.book.main.entity&quot;)
public class HumanConfig {

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试类，自动注入一个Human接口。此时，spring会产生：&lt;code&gt;NoUniqueBeanDefinitionException&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package cn.book.test;

import cn.book.main.entity.Human;
import cn.book.resource.HumanJobConfig;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(classes=cn.book.resource.HumanJobConfig.class)
public class HumanJobTest {

    @Autowired
    private Human human;

    @Test
    public void Test(){
        System.out.println(human.getClass());
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当确实发生装配的歧义性时，Spring 提供了以下方案：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;将可选 Bean 中的某一个设为首选(primary) 的 Bean；&lt;/li&gt;
&lt;li&gt;使用限定符(qualifier)限定到符合的、唯一的 Bean；&lt;/li&gt;
&lt;/ol&gt;&lt;h5 id=&quot;标示首选-bean&quot;&gt;3.3.1 标示首选 Bean&lt;/h5&gt;
&lt;p&gt;标示首选需要使用关键字 &lt;strong&gt;primary&lt;/strong&gt;，它在 JavaConfig 中是注解 &lt;code&gt;@Primary&lt;/code&gt; ，在 XML 是 &lt;code&gt;bean&lt;/code&gt; 元素中的属性 primary。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JavaConfig 配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;@Primary&lt;/code&gt; 注解配合 &lt;code&gt;@Component&lt;/code&gt; 和 &lt;code&gt;@Bean&lt;/code&gt; 注解组合使用，在需要设置为首选的&lt;strong&gt;组件类&lt;/strong&gt;和 &lt;strong&gt;Bean 对象&lt;/strong&gt;上。&lt;/p&gt;
&lt;p&gt;与 &lt;code&gt;@Component&lt;/code&gt; 注解配合使用&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Component
@Primary
public class Man{

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者，与 &lt;code&gt;@Bean&lt;/code&gt; 注解配合使用&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Configuration
public class JavaConfig{

    @Bean
    @Primary
    public Human getMan(){
        return new Man();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 XML 中设置 Bean 为首选项的配置为：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;bean id=&quot;man&quot; class=&quot;Man&quot; primary=&quot;true&quot;/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;不能设置多个首选 Bean；&lt;/li&gt;
&lt;li&gt;不够灵活，存在歧义性时，只能装配使用设置首选的Bean；&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;限定符限定装配&quot;&gt;3.3.2 限定符限定装配&lt;/h5&gt;
&lt;p&gt;限定符 &lt;code&gt;@qualifier&lt;/code&gt; 注解，主要作用是在可选的 Bean 进行缩小范围选择，直到找到满足的 Bean。它的有两个作用：&lt;/p&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;与 &lt;code&gt;@Autowired&lt;/code&gt; 和 &lt;code&gt;@Inject&lt;/code&gt; 协同使用，在注入的时候指定想要注入的是哪个 Bean；&lt;/p&gt;
&lt;p&gt;&lt;code&gt;@qualifier(&quot;&quot;)&lt;/code&gt; 括号内所设置的参数时要注入 Bean 的 ID 值。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;与 &lt;code&gt;@Component&lt;/code&gt; 和 &lt;code&gt;@Bean&lt;/code&gt; 协同使用，为 Bean 设定限定符；&lt;/p&gt;
&lt;p&gt;&lt;code&gt;@qualifier(&quot;&quot;)&lt;/code&gt; 括号内是为 Bean 设置的限定符，在注入时使用 &lt;code&gt;qualifier&lt;/code&gt; 中引用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h5 id=&quot;限定符注解&quot;&gt;3.3.3 限定符注解&lt;/h5&gt;
&lt;p&gt;如果使用注解 &lt;code&gt;@qualifier&lt;/code&gt; 限定符依旧无法解决 bean 的装配歧义性问题时，而且，在 Spring 中无法重复使用相同的 &lt;code&gt;@qualiifer&lt;/code&gt; 注解，在这种情况下，可以自定义注解来区分 bean。那么，如何自定义注解呢？&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import org.springframework.beans.factory.annotation.Qualifier;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target({ElementType.CONSTRUCTOR,ElementType.FIELD,
        ElementType.METHOD,ElementType.ANNOTATION_TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Qualifier
public @interface 注解名 {
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;自定义注解不能使用在类上；&lt;/li&gt;
&lt;li&gt;使用自定义注解时，需要同时放在 声明Bean的地方 和 注入 Bean 的地方；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;bean-作用域&quot;&gt;4、Bean 作用域&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;在默认情况下，Spring 应用上下文中所有的 Bean 都是以单例形式创建的&lt;/strong&gt;。也就是，不管一个 Bean 被注入多少次，每次注入的 Bean 都是同一个实例。&lt;/p&gt;
&lt;p&gt;如果一个实例需要保持无状态并在应用中重复使用，单例作用域是不可行且不安全的。在 Spring 定义了多种作用域，Spring 会基于这些作用域创建 Bean，这些作用域包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;单例（Singleton）&lt;/strong&gt;：在整个应用，只会创建 Bean 的一个实例；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;原型（Prototype）&lt;/strong&gt;：每次注入或通过 Spring 应用上下文获取时，都会创建一个新的 Bean 实例；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;会话（Session）&lt;/strong&gt;：在 Web 应用中，为每个会话创建一个 Bean 实例；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;请求（Request）&lt;/strong&gt;：在 Web 应用中，为每个请求创建一个 Bean 实例；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;单例是默认的作用。如果想要选择其它作用域，要使用 &lt;code&gt;@Scope&lt;/code&gt;注解&lt;/strong&gt;。注解内使用以下表示作用域的参数：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;ConfigurableBeanFactory.SCOPE_PROTUTYPE&lt;/code&gt; 或者 &lt;code&gt;&quot;prototype&quot;&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ConfigurableBeanFactory.SCOPE_SESSION&lt;/code&gt; 或者 &lt;code&gt;&quot;session&quot;&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ConfigurableBeanFactory.SCOPE_REQUEST&lt;/code&gt; 或者 &lt;code&gt;&quot;request&quot;&lt;/code&gt;；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如果使用 XML 配置，在 &lt;code&gt;&amp;lt;bean&amp;gt;&lt;/code&gt; 元素中的属性 &lt;code&gt;scope&lt;/code&gt; 设置 bean 的作用域。&lt;/p&gt;
&lt;h4 id=&quot;会话和请求作用域&quot;&gt;4.1 会话和请求作用域&lt;/h4&gt;
&lt;p&gt;==学习到 Web 部分内容再深入学习==&lt;/p&gt;
&lt;h3 id=&quot;运行时值注入&quot;&gt;5、运行时值注入&lt;/h3&gt;
&lt;p&gt;前面在装配 Bean，讲到在创建 Bean 时，将常量（比如int类型、String类型）直接给定，这是&lt;strong&gt;将值硬编码到 Bean 中&lt;/strong&gt;。有时，为了避免硬编码值，想让这些值在运行时在确定，Spring 提供了两种在运行时求值的方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;属性占位符&lt;/li&gt;
&lt;li&gt;Spring 表达式语言&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;注入外部值&quot;&gt;5.1 注入外部值&lt;/h4&gt;
&lt;p&gt;回顾一下，在我们使用 JDBC 时，会创建一个属性文件 &lt;code&gt;*.properties&lt;/code&gt; 文件放置连接数据库所需的配置参数。假设，在 Spring 中该文件依旧存在，我们如何在配置类或配置文件中解析并取值？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JavaConfig 配置类&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;通过注解 &lt;code&gt;@PropertySource&lt;/code&gt; 中的value属性设置属性文件路径；&lt;/li&gt;
&lt;li&gt;自动注入 Environment 对象；&lt;/li&gt;
&lt;li&gt;通过 Environment 对象获取属性值；&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Configuration
@PropertySource(value = &quot;classpath：/JDBC.properties&quot;)
public class JdbcConfig {

    @Autowired
    Environment env;
    
    @Bean
    public JdbcParams getJdbc(){
        return new JdbcParams(
                env.getProperty(&quot;jdbc.driver&quot;),
                env.getProperty(&quot;jdbc.url&quot;),
                env.getProperty(&quot;jdbc.username&quot;),
                env.getProperty(&quot;jdbc.password&quot;)
        );
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class JdbcParams {
    
    private String driver;
    private String url;
    private String username;
    private String password;

    public JdbcParams() {
    }

    public JdbcParams(String driver, String url, String username, String password) {
        this.driver = driver;
        this.url = url;
        this.username = username;
        this.password = password;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Environmen 接口的用法，通过 Environment 接口可以调用以下方法：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;22.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;String getProperty(String key)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;根据指定值获取属性，属性没有定义&lt;strong&gt;返回null&lt;/strong&gt;；&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;&lt;code&gt;String getProperty(String key, String defaultValue)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;根据指定值获取属性，如果没有属性值，则返回defaultValue；&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;&lt;code&gt;T getProperty(String key, Class&amp;lt;T&amp;gt; type)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;返回指定类型的属性值；type为指定类型的.class&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;6&quot;&gt;&lt;td&gt;&lt;code&gt;T getProperty(String key, Class&amp;lt;T&amp;gt; type，T defaultValue)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;返回指定类型的属性值；type为指定类型的.class，如果没有属性值，则返回defaultValue；&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;getRequiredProperty(String key)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;根据指定值获取属性，属性没有定义&lt;strong&gt;抛出异常&lt;/strong&gt;；&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;containProperty(String key)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;检查属性文件是否存在某个属性；&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;&lt;code&gt;T getPropertyAsClass(String key,Class&amp;lt;T&amp;gt; type)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;将属性文件解析为指定的类文件；&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;String[] getActiveProfiles()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;返回激活 profile 名称的数组；&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;String[] getDefaultProfiles()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;返回默认 profile 名称的数组；&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;boolean acceptsProfiles(String... profiles)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;如果 environment 支持给定的 profile 的话，就返回 true；&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;占位符注入值&quot;&gt;5.2 占位符注入值&lt;/h4&gt;
&lt;p&gt;Spring 支持将属性定义到外部的属性文件中，并使用占位符将值插入到 Bean 中。在 Spring 装配中，占位符的形式为使用 &lt;code&gt;${...}&lt;/code&gt; 包装的属性名称。&lt;/p&gt;
&lt;p&gt;为了使用占位符，需要配置一个 &lt;code&gt;PropertySourcePlaceholderConfigurer&lt;/code&gt; Bean，它能够基于 Environment 及其属性源来解析占位符。下面来看看，JavaConfig 配置和 XMl 配置中使用占位符的用法&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.PropertySource;
import org.springframework.context.support.PropertySourcesPlaceholderConfigurer;

@Configuration
//声明属性源，并将属性文件加载到Spring
@PropertySource(value = &quot;classpath:/JDBC.properties&quot;)
public class StudentCongif {

     二、
    //(1)使用占位符解析属性
    @Bean
    public JdbcParams getJdbc(
            @Value(&quot;${jdbc.driver}&quot;) String driver,
            @Value(&quot;${jdbc.url}&quot;) String url,
            @Value(&quot;${jdbc.username}&quot;) String username,
            @Value(&quot;${jdbc.password}&quot;) String password){
        return new JdbcParams(driver,url,username,password);
    }

    //(2)还需要配置一个PropertySourcesPlaceholderConfigurer 的 bean
    @Bean
    public PropertySourcesPlaceholderConfigurer placeholderConfigurer(){
        return new PropertySourcesPlaceholderConfigurer();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;!--创建 PropertySourceHolderConfigurer --&amp;gt;
&amp;lt;context:property-placeholder location=&quot;classpath:/JDBC.properties&quot;/&amp;gt;

&amp;lt;!--    使用占位符进行值注入--&amp;gt;  
&amp;lt;bean id=&quot;jdbc&quot; class=&quot;cn.book.main.valueInject.JdbcParams&quot; 
    c:driver=&quot;${jdbc.driver}&quot;
    c:url=&quot;${jdbc.url}&quot;
    c:username=&quot;${jdbc.username&quot;
    c:password=&quot;${jdbc.password}&quot;/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解析外部属性能够将值的处理推迟到运行时，但它的关注点在于根据名称解析&lt;strong&gt;来自 Spring Environment 和属性源的属性&lt;/strong&gt;。&lt;/p&gt;
</description>
<pubDate>Thu, 13 Feb 2020 14:52:00 +0000</pubDate>
<dc:creator>余生是你丿</dc:creator>
<og:description>Spring IOC 1、简述 1.1 依赖注入DI 现实开发中，每一个应用都会由两个或多个类组成，这些类之间相互协作完成特定的业务逻辑。根据传统做法， 每个对象负责管理与自己协作的对象的引用（也就是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Brilliance-Chan/p/12305752.html</dc:identifier>
</item>
<item>
<title>从原理到优化，深入浅出数据库索引 - 邴越</title>
<link>http://www.cnblogs.com/binyue/p/12305670.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/binyue/p/12305670.html</guid>
<description>&lt;p&gt;MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。&lt;br/&gt;数据库查询是数据库的最主要功能之一，我们都希望查询数据的速度能尽可能的快，因此数据库系统的设计者会从查询算法的角度进行优化，这篇文章对索引做一个系统的梳理，希望对大家有帮助。&lt;/p&gt;
&lt;h2 id=&quot;一mysql有哪些索引类型&quot;&gt;一、MySQL有哪些索引类型&lt;/h2&gt;
&lt;p&gt;索引的分类可以从多个角度进行，下面分别从数据结构，物理存储和业务逻辑三个维度进行划分。&lt;/p&gt;
&lt;h3 id=&quot;从数据结构角度&quot;&gt;1、从数据结构角度&lt;/h3&gt;
&lt;h4 id=&quot;b树索引ologn&quot;&gt;（1）B+树索引(O(log(n)))&lt;/h4&gt;
&lt;p&gt;关于B+树索引，后面会深入解析&lt;/p&gt;
&lt;h4 id=&quot;hash索引&quot;&gt;（2）hash索引&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;仅仅能满足&quot;=&quot;,&quot;IN&quot;和&quot;&amp;lt;=&amp;gt;&quot;查询，不能使用范围查询&lt;/li&gt;
&lt;li&gt;其检索效率非常高，索引的检索可以一次定位，不像B-Tree 索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问，所以 Hash 索引的查询效率要远高于 B-Tree 索引&lt;/li&gt;
&lt;li&gt;只有Memory存储引擎显示支持hash索引&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;fulltext索引&quot;&gt;（3）FULLTEXT索引&lt;/h4&gt;
&lt;p&gt;现在MyISAM和InnoDB引擎都支持了&lt;/p&gt;
&lt;h4 id=&quot;r-tree索引&quot;&gt;（4）R-Tree索引&lt;/h4&gt;
&lt;p&gt;用于对GIS数据类型创建SPATIAL索引&lt;/p&gt;
&lt;h3 id=&quot;从物理存储角度&quot;&gt;2、从物理存储角度&lt;/h3&gt;
&lt;h4 id=&quot;聚集索引clustered-index&quot;&gt;（1）聚集索引（clustered index）&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;正文内容按照一个特定维度排序存储，这个特定的维度就是聚集索引；&lt;/li&gt;
&lt;li&gt;Innodb存储引擎中行记录就是按照聚集索引维度顺序存储的，Innodb的表也称为索引表；因为行记录只能按照一个维度进行排序，所以一张表只能有一个聚集索引。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;非聚集索引non-clustered-index&quot;&gt;（2）非聚集索引（non-clustered index）&lt;/h4&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;索引是通过二叉树的数据结构来描述的，我们可以这么理解聚簇索引：索引的叶节点就是数据节点。而非聚簇索引的叶节点仍然是索引节点，只不过有一个指针指向对应的数据块。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;非聚集索引索引项顺序存储，但索引项对应的内容却是随机存储的；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;举个例子说明下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;create table student (
`id` INT UNSIGNED AUTO_INCREMENT,
`name` VARCHAR(255),
PRIMARY KEY(`id`),
KEY(`name`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该表中主键id是该表的聚集索引、name为非聚集索引；表中的每行数据都是按照聚集索引id排序存储的；比如要查找name='Arla'和name='Arle'的两个同学，他们在name索引表中位置可能是相邻的，但是实际存储位置可能差的很远。name索引表节点按照name排序，检索的是每一行数据的主键。聚集索引表按照主键id排序，检索的是每一行数据的真实内容。&lt;/p&gt;
&lt;h3 id=&quot;从逻辑角度&quot;&gt;3、从逻辑角度&lt;/h3&gt;
&lt;h4 id=&quot;主键索引&quot;&gt;（1）主键索引&lt;/h4&gt;
&lt;p&gt;主键索引是一种特殊的唯一索引，不允许有空值&lt;/p&gt;
&lt;h4 id=&quot;普通索引或者单列索引&quot;&gt;（2）普通索引或者单列索引&lt;/h4&gt;
&lt;h4 id=&quot;多列索引复合索引&quot;&gt;（3）多列索引（复合索引）&lt;/h4&gt;
&lt;p&gt;复合索引指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用复合索引时遵循最左前缀集合&lt;/p&gt;
&lt;h4 id=&quot;唯一索引或者非唯一索引&quot;&gt;（4）唯一索引或者非唯一索引&lt;/h4&gt;
&lt;h4 id=&quot;空间索引&quot;&gt;（5）空间索引&lt;/h4&gt;
&lt;p&gt;空间索引是对空间数据类型的字段建立的索引，MYSQL中的空间数据类型有4种，分别是GEOMETRY、POINT、LINESTRING、POLYGON。&lt;/p&gt;
&lt;p&gt;MYSQL使用SPATIAL关键字进行扩展，使得能够用于创建正规索引类型的语法创建空间索引。创建空间索引的列，必须将其声明为NOT NULL，空间索引只能在存储引擎为MYISAM的表中创建.&lt;/p&gt;
&lt;h2 id=&quot;二索引创建方式&quot;&gt;二、索引创建方式&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;CREATE TABLE table_name[col_name data type]
[unique|fulltext|spatial][index|key][index_name](col_name[length])[asc|desc]
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;unique|fulltext|spatial为可选参数，分别表示唯一索引、全文索引和空间索引；&lt;/li&gt;
&lt;li&gt;index和key为同义词，两者作用相同，用来指定创建索引&lt;/li&gt;
&lt;li&gt;col_name为需要创建索引的字段列，该列必须从数据表中该定义的多个列中选择；&lt;/li&gt;
&lt;li&gt;index_name指定索引的名称，为可选参数，如果不指定，MYSQL默认col_name为索引值；length为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度；&lt;/li&gt;
&lt;li&gt;asc或desc指定升序或降序的索引值存储&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;创建表时建立索引&quot;&gt;1、创建表时建立索引&lt;/h3&gt;
&lt;h4 id=&quot;创建普通索引&quot;&gt;（1）创建普通索引&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;create table table_name(
    id int(11),
    name varchar(20),
    sex boolean,
    INDEX(id)
);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看表结构&lt;/p&gt;
&lt;p&gt;show create table table_name;&lt;br/&gt;可以使 EXPLAIN 语句查看索引是否被使用&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;explain select * from table_name where id = 1\G&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;创建唯一索引&quot;&gt;（2）创建唯一索引&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;create table index2(
    id int unique,
    name varchar(20),
    unique INDEX index_2(id asc)
);&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;创建全文索引&quot;&gt;（3）创建全文索引&lt;/h4&gt;
&lt;p&gt;全文索引只能在char，varchar或者text 类型的字段上。而且，只有MyISAM 储存引擎支持全文索引。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;create table idnex3(
    id int,
    info varchar(20),
    FULLTEXT INDEX index3_info(info)
)ENGINE=MyISAM;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;创建单列索引&quot;&gt;（4）创建单列索引&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;create table index4(
    id int,
    subject varchar(255),
    index index4_st(subject(10))
);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里需要注意的，subject 的长度为255，但是index4_st索引只有10。这样做的目的还是为了提高查询速度。对于字符型的数据，可以不用查询全部信息，只查询其前面的若干字符信息。&lt;/p&gt;
&lt;h4 id=&quot;创建多列索引&quot;&gt;（5）创建多列索引&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;create table index5(
    id int,
    name varchar(20),
    sex char(4),
    index index5_ns(name.sex)
);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是我们可以看到，name 和sex字段上已经创建了index_ns索引。&lt;/p&gt;
&lt;h3 id=&quot;在已经存在的表中创建索引&quot;&gt;2、在已经存在的表中创建索引&lt;/h3&gt;
&lt;h4 id=&quot;创建普通索引-1&quot;&gt;（1）创建普通索引&lt;/h4&gt;
&lt;p&gt;在example0() 表中的id 创建名为index7_id 的索引。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;create index index7_id on example0(id);&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;创建唯一索引-1&quot;&gt;（2）创建唯一索引&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;create UNIQUE index index_name on table_name(name);&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;创建全文索引-1&quot;&gt;（3）创建全文索引&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;create FULLTEXT index index_name on table_name(info);&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;创建单列索引-1&quot;&gt;（4）创建单列索引&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;create INDEX index_name ON table_name(name(10));&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;创建多列索引-1&quot;&gt;（5）创建多列索引&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;create INDEX index_name ON table_name(name,sex);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;用alter-table-语句来创建索引&quot;&gt;3、用alter table 语句来创建索引&lt;/h3&gt;
&lt;h4 id=&quot;创建普通索引-2&quot;&gt;（1）创建普通索引&lt;/h4&gt;
&lt;p&gt;在name字段上创建名为indx_name 的索引&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;alter table table_name ADD INDEX index_name(name(20));&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;创建唯一性索引&quot;&gt;（2）创建唯一性索引&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;alter table table_name ADD UNIQUE INDEX index_name(id);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;创建全文索引-2&quot;&gt;（3）创建全文索引&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;alter table table_name ADD FULLTEXT INDEX index_name(info);&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;创建单列索引-2&quot;&gt;（4）创建单列索引&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;alter table table_name ADD INDEX index_name(name(4));&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;创建多列索引-2&quot;&gt;（5）创建多列索引&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;alter tabel table_name ADD INDEX index_name(name.sex);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;删除索引&quot;&gt;4、删除索引&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;DROP INDEX index_name ON table_name;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;三索引树是如何维护的&quot;&gt;三、索引树是如何维护的&lt;/h2&gt;
&lt;p&gt;目前大部分数据库系统及文件系统都采用B-Tree或其变种B+Tree作为索引结构，那么索引树是如何维护的？&lt;/p&gt;
&lt;h3 id=&quot;查找结构进化史&quot;&gt;1、查找结构进化史&lt;/h3&gt;
&lt;p&gt;查找是数据结构和算法中一个非常重要的概念。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;线性查找：一个个找；实现简单；太慢&lt;/li&gt;
&lt;li&gt;二分查找：有序；简单；要求是有序的，插入特别慢&lt;/li&gt;
&lt;li&gt;HASH查找：查询快；占用空间；不太适合存储大规模数据&lt;/li&gt;
&lt;li&gt;二叉查找树：插入和查询很快(log(n))；无法存大规模数据，复杂度退化&lt;/li&gt;
&lt;li&gt;平衡树：解决 BST 退化问题，树是平衡的；节点非常多的时候，依然树高很高&lt;/li&gt;
&lt;li&gt;多路查找树：一个父亲多个孩子节点（度）；节点过多树高不会特别深&lt;/li&gt;
&lt;li&gt;多路平衡查找树：B-Tree&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;b-tree&quot;&gt;2、B-Tree&lt;/h3&gt;
&lt;p&gt;B-Tree是一种多路搜索树（并不是二叉的）：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;定义任意非叶子结点最多只有M个儿子；且M&amp;gt;2；&lt;/li&gt;
&lt;li&gt;根结点的儿子数为[2, M]；&lt;/li&gt;
&lt;li&gt;除根结点以外的非叶子结点的儿子数为[M/2, M]；&lt;/li&gt;
&lt;li&gt;每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）&lt;/li&gt;
&lt;li&gt;非叶子结点的关键字个数=指向儿子的指针个数-1；&lt;/li&gt;
&lt;li&gt;非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] &amp;lt; K[i+1]；&lt;/li&gt;
&lt;li&gt;非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的&lt;br/&gt;子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；&lt;/li&gt;
&lt;li&gt;所有叶子结点位于同一层；&lt;/li&gt;
&lt;li&gt;每个k对应一个data。&lt;br/&gt;如：（M=3）相当于一个2–3树，2–3树是一个这样的一棵树， 它的每个节点要么有2个孩子和1个数据元素，要么有3个孩子和2个数据元素，叶子节点没有孩子，并且有1个或2个数据元素。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/524341/202002/524341-20200213223746665-315333060.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;B-树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点；B-Tree上查找算法的伪代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;BTree_Search(node, key) { if(node == null) return null; foreach(node.key) { if(node.key[i] == key) return node.data[i]; if(node.key[i] &amp;gt; key) return BTree_Search(point[i]-&amp;gt;node); } return BTree_Search(point[i+1]-&amp;gt;node); } data = BTree_Search(root, my_key);&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;b-树的特性&quot;&gt;（1）B-树的特性&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;关键字集合分布在整颗树中；&lt;/li&gt;
&lt;li&gt;任何一个关键字出现且只出现在一个结点中；&lt;/li&gt;
&lt;li&gt;搜索有可能在非叶子结点结束；&lt;/li&gt;
&lt;li&gt;其搜索性能等价于在关键字全集内做一次二分查找；&lt;/li&gt;
&lt;li&gt;自动层次控制；&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;b-树的自控制&quot;&gt;（2）B-树的自控制&lt;/h4&gt;
&lt;p&gt;B树中每一个内部节点会包含一定数量的键值。通常，键值的数量被选定在d和2d之间。在实际中，键值占用了节点中大部分的空间。因数2将保证节点可以被拆分或组合。如果一个内部节点有2d个键值，那么添加一个键值给此节点的过程，将会拆分2d键值为2个d键值的节点，并把此键值添加给父节点。每一个拆分的节点需要最小数目的键值。相似地，如果一个内部节点和他的邻居两者都有d个键值，那么将通过它与邻居的合并来删除一个键值。删除此键值将导致此节点拥有d-1个键值;与邻居的合并则加上d个键值，再加上从邻居节点的父节点移来的一个键值。结果为完全填充的2d个键值。&lt;/p&gt;
&lt;h4 id=&quot;b-树的构造过程&quot;&gt;（3）B-树的构造过程&lt;/h4&gt;
&lt;p&gt;下面是往B树中依次插入&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;6 10 4 14 5 11 15 3 2 12 1 7 8 8 6 3 6 21 5 15 15 6 32 23 45 65 7 8 6 5 4&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/524341/202002/524341-20200213223754491-847271087.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;btree&quot;&gt;3、B+Tree&lt;/h3&gt;
&lt;p&gt;B-Tree有许多变种，其中最常见的是B+Tree，MySQL就普遍使用B+Tree实现其索引结构。&lt;br/&gt;与B-Tree相比，B+Tree有以下不同点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;非叶子结点的子树指针与关键字个数相同；&lt;/li&gt;
&lt;li&gt;非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树（B-树是开区间）；&lt;/li&gt;
&lt;li&gt;为所有叶子结点增加一个链指针；&lt;/li&gt;
&lt;li&gt;所有关键字都在叶子结点出现；&lt;/li&gt;
&lt;li&gt;内节点不存储data，只存储key&lt;br/&gt;如：（M=3）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/524341/202002/524341-20200213223755731-753784192.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;B+的搜索与B-树也基本相同，区别是B+树只有达到叶子结点才命中（B-树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找；&lt;/p&gt;
&lt;h4 id=&quot;b的特性&quot;&gt;（1）B+的特性&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；&lt;/li&gt;
&lt;li&gt;不可能在非叶子结点命中；&lt;/li&gt;
&lt;li&gt;非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；&lt;/li&gt;
&lt;li&gt;更适合文件索引系统；&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;b树的构造过程&quot;&gt;（2）B+树的构造过程&lt;/h4&gt;
&lt;p&gt;下面是往B+树中依次插入&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;6 10 4 14 5 11 15 3 2 12 1 7 8 8 6 3 6 21 5 15 15 6 32 23 45 65 7 8 6 5 4&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/524341/202002/524341-20200213223803297-1477104075.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;索引的物理存储&quot;&gt;3、索引的物理存储&lt;/h3&gt;
&lt;p&gt;一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。&lt;/p&gt;
&lt;p&gt;这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。&lt;/p&gt;
&lt;p&gt;假如每个盘块可以正好存放一个B树的结点（正好存放2个文件名）。那么一个BTNODE结点就代表一个盘块，而子树指针就是存放另外一个盘块的地址。&lt;/p&gt;
&lt;h4 id=&quot;模拟b树查找过程&quot;&gt;（1）模拟B+树查找过程&lt;/h4&gt;
&lt;p&gt;下面，咱们来模拟下查找文件29的过程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/524341/202002/524341-20200213223805249-1512407737.jpg&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;根据根结点指针找到文件目录的根磁盘块1，将其中的信息导入内存。【磁盘IO操作 1次】&lt;/li&gt;
&lt;li&gt;此时内存中有两个文件名17、35和三个存储其他磁盘页面地址的数据。根据算法我们发现：17&amp;lt;29&amp;lt;35，因此我们找到指针p2。&lt;/li&gt;
&lt;li&gt;根据p2指针，我们定位到磁盘块3，并将其中的信息导入内存。【磁盘IO操作 2次】&lt;/li&gt;
&lt;li&gt;此时内存中有两个文件名26，30和三个存储其他磁盘页面地址的数据。根据算法我们发现：26&amp;lt;29&amp;lt;30，因此我们找到指针p2。&lt;/li&gt;
&lt;li&gt;根据p2指针，我们定位到磁盘块8，并将其中的信息导入内存。【磁盘IO操作 3次】&lt;/li&gt;
&lt;li&gt;此时内存中有两个文件名28，29。根据算法我们查找到文件名29，并定位了该文件内存的磁盘地址。&lt;br/&gt;分析上面的过程，发现需要3次磁盘IO操作和3次内存查找操作。关于内存中的文件名查找，由于是一个有序表结构，可以利用折半查找提高效率。至于IO操作是影响整个B树查找效率的决定因素。&lt;br/&gt;当然，如果我们使用平衡二叉树的磁盘存储结构来进行查找，磁盘4次，最多5次，而且文件越多，B树比平衡二叉树所用的磁盘IO操作次数将越少，效率也越高。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;btree的优点&quot;&gt;4、B+tree的优点&lt;/h3&gt;
&lt;h4 id=&quot;b-tree的磁盘读写代价更低&quot;&gt;（1）B+-tree的磁盘读写代价更低&lt;/h4&gt;
&lt;p&gt;B+-tree的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。&lt;br/&gt;举个例子，假设磁盘中的一个盘块容纳16bytes，而一个关键字2bytes，一个关键字具体信息指针2bytes。一棵9阶B-tree(一个结点最多8个关键字)的内部结点需要2个盘快。而B+&lt;br/&gt;树内部结点只需要1个盘快。当需要把内部结点读入内存中的时候，B 树就比B+树多一次盘块查找时间(在磁盘中就是盘片旋转的时间)。&lt;/p&gt;
&lt;h4 id=&quot;b-tree的查询效率更加稳定&quot;&gt;（2）B+-tree的查询效率更加稳定&lt;/h4&gt;
&lt;p&gt;由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。&lt;/p&gt;
&lt;h2 id=&quot;四索引创建有哪些原则&quot;&gt;四、索引创建有哪些原则&lt;/h2&gt;
&lt;p&gt;索引查询是数据库中重要的记录查询方法，要不要进入索引以及在那些字段上建立索引都要和实际数据库系统的查询要求结合来考虑，下面给出实际中的一些通用的原则：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在经常用作过滤器的字段上建立索引；&lt;/li&gt;
&lt;li&gt;在SQL语句中经常进行GROUP BY、ORDER BY的字段上建立索引；&lt;/li&gt;
&lt;li&gt;在不同值较少的字段上不必要建立索引，如性别字段；&lt;/li&gt;
&lt;li&gt;对于经常存取的列避免建立索引；&lt;/li&gt;
&lt;li&gt;用于联接的列（主健/外健）上建立索引；&lt;/li&gt;
&lt;li&gt;在经常存取的多个列上建立复合索引，但要注意复合索引的建立顺序要按照使用的频度来确定；&lt;/li&gt;
&lt;li&gt;缺省情况下建立的是非簇集索引，但在以下情况下最好考虑簇集索引，如：含有有限数目（不是很少）唯一的列；进行大范围的查询；充分的利用索引可以减少表扫描I/0的次数，有效的避免对整表的搜索。&lt;/li&gt;
&lt;li&gt;经常用在WHERE子句中的数据列；&lt;/li&gt;
&lt;li&gt;经常出现在关键字order by、group by、distinct后面的字段，建立索引。如果建立的是复合索引，索引的字段顺序要和这些关键字后面的字段顺序一致，否则索引不会被使用；&lt;/li&gt;
&lt;li&gt;对于那些查询中很少涉及的列，重复值比较多的列不要建立索引；&lt;/li&gt;
&lt;li&gt;对于定义为text、image和bit的数据类型的列不要建立索引；&lt;/li&gt;
&lt;li&gt;对于经常存取的列避免建立索引；&lt;/li&gt;
&lt;li&gt;限制表上的索引数目。对一个存在大量更新操作的表，所建索引的数目一般不要超过3个，最多不要超过5个。索引虽说提高了访问速度，但太多索引会影响数据的更新操作。&lt;/li&gt;
&lt;li&gt;对复合索引，按照字段在查询条件中出现的频度建立索引。在复合索引中，记录首先按照第一个字段排序。对于在第一个字段上取值相同的记录，系统再按照第二个字段的取值排序，以此类推。因此只有复合索引的第一个字段出现在查询条件中，该索引才可能被使用,因此将应用频度高的字段，放置在复合索引的前面，会使系统最大可能地使用此索引，发挥索引的作用。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;组合多个索引&quot;&gt;1、组合多个索引&lt;/h3&gt;
&lt;p&gt;一个单独的索引扫描只能用于这样的条件子句：使用被索引字段和索引操作符类中的操作符， 并且这些条件以AND连接。&lt;/p&gt;
&lt;p&gt;假设在(a, b)上有一个索引， 那么类似WHERE a = 5 AND b = 6的条件可以使用索引，但是像WHERE a = 5 OR b = 6的条件就不能直接使用索引。&lt;/p&gt;
&lt;p&gt;一个类似WHERE x =42 OR x = 47 OR x = 53 OR x = 99 这样的查询可以分解成四个在x上的独立扫描，每个扫描使用一个条件， 最后将这些扫描的结果OR 在一起，生成最终结果。&lt;/p&gt;
&lt;p&gt;另外一个例子是，如果我们在x 和y上有独立的索引，一个类似WHERE x = 5 AND y = 6 这样的查询可以分解为几个使用独立索引的子句，然后把这几个结果AND 在一起，生成最终结果。&lt;/p&gt;
&lt;h2 id=&quot;五索引失效有哪几种情况&quot;&gt;五、索引失效有哪几种情况&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;如果条件中有or，即使其中有条件带索引也不会使用(这也是为什么尽量少用or的原因)&lt;/li&gt;
&lt;li&gt;对于多列索引，不是使用的第一部分(第一个)，则不会使用索引&lt;/li&gt;
&lt;li&gt;like查询是以%开头&lt;/li&gt;
&lt;li&gt;如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引&lt;/li&gt;
&lt;li&gt;如果mysql估计使用全表扫描要比使用索引快,则不使用索引&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;联合索引失效的条件&quot;&gt;1、联合索引失效的条件&lt;/h3&gt;
&lt;p&gt;联合索引又叫复合索引。两个或更多个列上的索引被称作复合索引。&lt;/p&gt;
&lt;p&gt;对于复合索引：Mysql从左到右的使用索引中的字段，一个查询可以只使用索引中的一部份，但只能是最左侧部分。例如索引是key index （a,b,c）。 可以支持a | a,b| a,b,c 3种组合进行查找，但不支持 b,c进行查找 .当最左侧字段是常量引用时，索引就十分有效。&lt;/p&gt;
&lt;p&gt;所以说创建复合索引时，应该仔细考虑列的顺序。对索引中的所有列执行搜索或仅对前几列执行搜索时，复合索引非常有用；仅对后面的任意列执行搜索时，复合索引则没有用处。&lt;/p&gt;
&lt;h2 id=&quot;六如何查看索引的使用情况&quot;&gt;六、如何查看索引的使用情况&lt;/h2&gt;
&lt;p&gt;这里记录两种方式，分别是&lt;/p&gt;
&lt;h3 id=&quot;使用handler_read查看索引的使用情况&quot;&gt;1、使用Handler_read查看索引的使用情况&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;show status like ‘Handler_read%';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;大家可以注意：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;handler_read_key:这个值越高越好，越高表示使用索引查询到的次数&lt;/li&gt;
&lt;li&gt;handler_read_rnd_next:这个值越高，说明查询低效&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;+-----------------------+--------------+
| Variable_name         | Value        |
+-----------------------+--------------+
| Handler_read_first    | 153      |
| Handler_read_key      | 364   |
| Handler_read_next     | 425    |
| Handler_read_prev     | 598     |
| Handler_read_rnd      | 605     |
| Handler_read_rnd_next | 860571 |
+-----------------------+--------------+
6 rows in set (0.00 sec)
————————————————&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;分析这几个值，我们可以查看当前索引的使用情况：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Handler_read_first：索引中第一条被读的次数。如果较高，它表示服务器正执行大量全索引扫描；例如，SELECT col1 FROM foo，假定col1有索引（这个值越低越好）。&lt;/li&gt;
&lt;li&gt;Handler_read_key：如果索引正在工作，这个值代表一个行被索引值读的次数，如果值越低，表示索引得到的性能改善不高，因为索引不经常使用（这个值越高越好）。&lt;/li&gt;
&lt;li&gt;Handler_read_next ：按照键顺序读下一行的请求数。如果你用范围约束或如果执行索引扫描来查询索引列，该值增加。&lt;/li&gt;
&lt;li&gt;Handler_read_prev：按照键顺序读前一行的请求数。该读方法主要用于优化ORDER BY ... DESC。&lt;/li&gt;
&lt;li&gt;Handler_read_rnd ：根据固定位置读一行的请求数。如果你正执行大量查询并需要对结果进行排序该值较高。你可能使用了大量需要MySQL扫描整个表的查询或你的连接没有正确使用键。这个值较高，意味着运行效率低，应该建立索引来补救。&lt;/li&gt;
&lt;li&gt;Handler_read_rnd_next：在数据文件中读下一行的请求数。如果你正进行大量的表扫描，该值较高。通常说明你的表索引不正确或写入的查询没有利用索引。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;在sys库中查看没用的索引&quot;&gt;2、在sys库中查看没用的索引&lt;/h3&gt;
&lt;p&gt;查询 schema_unused_indexes库。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;root@localhost [sys]&amp;gt;select * from schema_unused_indexes;
+-------------------+-------------+------------+
| object_schema     | object_name | index_name |
+-------------------+-------------+------------+
| sysbench_testdata | sbtest1     | k_1        |
| sysbench_testdata | sbtest10    | k_10       |
| sysbench_testdata | sbtest3     | k_3        |
| sysbench_testdata | sbtest4     | k_4        |
| sysbench_testdata | sbtest5     | k_5        |
| sysbench_testdata | sbtest6     | k_6        |
| sysbench_testdata | sbtest7     | k_7        |
| sysbench_testdata | sbtest8     | k_8        |
| sysbench_testdata | sbtest9     | k_9        |
+-------------------+-------------+------------+
9 rows in set (0.00 sec)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;七explain解释命令查看索引是否生效&quot;&gt;七、EXPLAIN解释命令查看索引是否生效&lt;/h2&gt;
&lt;p&gt;explain显示了mysql如何使用索引来处理select语句以及连接表。可以帮助选择更好的索引和写出更优化的查询语句。&lt;/p&gt;
&lt;h3 id=&quot;一个实际例子&quot;&gt;1、一个实际例子&lt;/h3&gt;
&lt;p&gt;新建一张表，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;CREATE TABLE IF NOT EXISTS `article` (`id` int(10) unsigned NOT NULL AUTO_INCREMENT,
`author_id` int(10) unsigned NOT NULL,
`category_id` int(10) unsigned NOT NULL,
`views` int(10) unsigned NOT NULL,
`comments` int(10) unsigned NOT NULL,
`title` varbinary(255) NOT NULL,
`content` text NOT NULL,
PRIMARY KEY (`id`)
);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行查询，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;EXPLAIN
SELECT author_id
FROM `article`
WHERE category_id = 1 AND comments &amp;gt; 1
ORDER BY views DESC
LIMIT 1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;响应数据如下，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: article
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 3
        Extra: Using where; Using filesort
1 row in set (0.00 sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;type 是 ALL,即最坏的情况。Extra 里还出现了 Using filesort,也是最坏的情况。&lt;/p&gt;
&lt;h3 id=&quot;explain列的解释&quot;&gt;2、EXPLAIN列的解释：&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;table：显示这一行的数据是关于哪张表的&lt;/li&gt;
&lt;li&gt;type：这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为const、eq_reg、ref、range、indexhe和ALL&lt;/li&gt;
&lt;li&gt;possible_keys：显示可能应用在这张表中的索引。如果为空，没有可能的索引。可以为相关的域从WHERE语句中选择一个合适的语句&lt;/li&gt;
&lt;li&gt;key： 实际使用的索引。如果为NULL，则没有使用索引。很少的情况下，MYSQL会选择优化不足的索引。这种情况下，可以在SELECT语句中使用USE INDEX（indexname）来强制使用一个索引或者用IGNORE INDEX（indexname）来强制MYSQL忽略索引&lt;/li&gt;
&lt;li&gt;key_len：使用的索引的长度。在不损失精确性的情况下，长度越短越好&lt;/li&gt;
&lt;li&gt;ref：显示索引的哪一列被使用了，如果可能的话，是一个常数&lt;/li&gt;
&lt;li&gt;rows：MYSQL认为必须检查的用来返回请求数据的行数&lt;/li&gt;
&lt;li&gt;Extra：关于MYSQL如何解析查询的额外信息。将在表4.3中讨论，但这里可以看到的坏的例子是Using temporary和Using filesort，意思MYSQL根本不能使用索引，结果是检索会很慢&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;type返回结果的解释&quot;&gt;3、type返回结果的解释&lt;/h3&gt;
&lt;p&gt;MySQL 在表里找到所需行的方式。包括（由左至右，由最差到最好）：&lt;br/&gt;| All | index | range | ref | eq_ref | const,system | null |&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;system 表只有一行：system表。这是const连接类型的特殊情况&lt;/li&gt;
&lt;li&gt;const:表中的一个记录的最大值能够匹配这个查询（索引可以是主键或惟一索引）。因为只有一行，这个值实际就是常数，因为MYSQL先读这个值然后把它当做常数来对待&lt;/li&gt;
&lt;li&gt;eq_ref:在连接中，MYSQL在查询时，从前面的表中，对每一个记录的联合都从表中读取一个记录，它在查询使用了索引为主键或惟一键的全部时使用&lt;/li&gt;
&lt;li&gt;ref:这个连接类型只有在查询使用了不是惟一或主键的键或者是这些类型的部分（比如，利用最左边前缀）时发生。对于之前的表的每一个行联合，全部记录都将从表中读出。这个类型严重依赖于根据索引匹配的记录多少—越少越好&lt;/li&gt;
&lt;li&gt;range:这个连接类型使用索引返回一个范围中的行，比如使用&amp;gt;或&amp;lt;查找东西时发生的情况&lt;/li&gt;
&lt;li&gt;index: 这个连接类型对前面的表中的每一个记录联合进行完全扫描（比ALL更好，因为索引一般小于表数据）&lt;/li&gt;
&lt;li&gt;ALL:这个连接类型对于前面的每一个记录联合进行完全扫描，这一般比较糟糕，应该尽量避免&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li&gt;Distinct:一旦MYSQL找到了与行相联合匹配的行，就不再搜索了&lt;/li&gt;
&lt;li&gt;Not exists: MYSQL优化了LEFT JOIN，一旦它找到了匹配LEFT JOIN标准的行，就不再搜索了&lt;/li&gt;
&lt;li&gt;Range checked for each Record（index map:#）:没有找到理想的索引，因此对于从前面表中来的每一个行组合，MYSQL检查使用哪个索引，并用它来从表中返回行。这是使用索引的最慢的连接之一&lt;/li&gt;
&lt;li&gt;Using filesort: 看到这个的时候，查询就需要优化了。MYSQL需要进行额外的步骤来发现如何对返回的行排序。它根据连接类型以及存储排序键值和匹配条件的全部行的行指针来排序全部行&lt;/li&gt;
&lt;li&gt;Using index: 列数据是从仅仅使用了索引中的信息而没有读取实际的行动的表返回的，这发生在对表的全部的请求列都是同一个索引的部分的时候&lt;/li&gt;
&lt;li&gt;Using temporary 看到这个的时候，查询需要优化了。这里，MYSQL需要创建一个临时表来存储结果，这通常发生在对不同的列集进行ORDER BY上，而不是GROUP BY上&lt;/li&gt;
&lt;li&gt;Using where 使用了WHERE从句来限制哪些行将与下一张表匹配或者是返回给用户。如果不想返回表中的全部行，并且连接类型ALL或index，这就会发生，或者是查询有问题不同连接类型的解释（按照效率高低的顺序排序）&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;参考文档&quot;&gt;参考文档&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://mengkang.net/1124.html&quot;&gt;最官方的 mysql explain type 字段解读&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/39293940&quot;&gt;MySQL聚集索引和非聚集索引&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 13 Feb 2020 14:38:00 +0000</pubDate>
<dc:creator>邴越</dc:creator>
<og:description>MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。 数据库查询是数据库的最主要功能之一，我们都希望查询数据的速度能尽可能的快，因此数据库系统的设计者会从查询算法的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/binyue/p/12305670.html</dc:identifier>
</item>
<item>
<title>Spring框架学习笔记（9）——API接口设计相关知识及具体编码实现 - Stars-one</title>
<link>http://www.cnblogs.com/stars-one/p/12305429.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/stars-one/p/12305429.html</guid>
<description>&lt;p&gt;最近需要设计一个API服务器，想要把API接口搞得规范一下，就通过网上搜集到了一些资料，以下便是自己的一些理解以及相关的具体实现&lt;/p&gt;
&lt;p&gt;本文采用的是spring boot+maven的方案&lt;/p&gt;
&lt;h2 id=&quot;restful规范&quot;&gt;restful规范&lt;/h2&gt;
&lt;p&gt;这个规范我在这里也不打算长篇大论地讲解，怎么说呢，有人喜欢有人讨厌，我也不去争，因为我经验不多，看法和大佬有所不同。&lt;/p&gt;
&lt;p&gt;restful规范简单来说，就是通过一些关键字去定义url接口，从而让url具有更好的可读性，如下面举个例子&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 查询所有用户
http://localhost:9200/shunbang/api/user/users
# 指定id为1的用户
http://localhost:9200/shunbang/api/user/users/1
# 数据太多，只要前10
http://localhost:9200/shunbang/api/user/users?limit=10
# 从第十条数据后开始（不要前十条数据）
http://localhost:9200/shunbang/api/user/users?offset=10&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我觉得restful规范起来，url的可读性较好&lt;/p&gt;
&lt;p&gt;restful规范使用的几种方式&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;get&lt;/td&gt;
&lt;td&gt;从服务器上获取资源(select)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;put&lt;/td&gt;
&lt;td&gt;更新服务器上的资源(update)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;post&lt;/td&gt;
&lt;td&gt;将传入的资源存储在服务器上(insert)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;delete&lt;/td&gt;
&lt;td&gt;删除服务器上的资源(delete)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;url请求协议介绍&quot;&gt;url请求协议介绍&lt;/h2&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;7&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;6&quot;&gt;&lt;td&gt;application/x-www-form-urlencoded&lt;/td&gt;
&lt;td&gt;默认，客户端通过key-value键值对传递数据&lt;/td&gt;
&lt;td&gt;http://localhost:9200/shunbang/api/user/update?id=1&amp;amp;name=xx&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;application/json&lt;/td&gt;
&lt;td&gt;客户端通过body发送json数据&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;application/xml&lt;/td&gt;
&lt;td&gt;客户端通过body发送xml数据&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;application/octet-stream&lt;/td&gt;
&lt;td&gt;客户端通过body发送Binary数据（二进制文件）&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;multipart/form-data&lt;/td&gt;
&lt;td&gt;客户端通过body发送一个表单&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;api文档生成框架-smart-doc&quot;&gt;API文档生成框架 smart-doc&lt;/h2&gt;
&lt;h3 id=&quot;介绍&quot;&gt;介绍&lt;/h3&gt;
&lt;p&gt;这里，我使用了&lt;a href=&quot;https://gitee.com/sunyurepository/smart-doc&quot;&gt;smart-doc&lt;/a&gt;这款框架，可以无侵入实现API接口的注释，需要在Controller和实体类中添加注释&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1210268/202002/1210268-20200213211440260-109841987.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1210268/202002/1210268-20200213211402897-52301938.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;使用&quot;&gt;使用&lt;/h3&gt;
&lt;p&gt;使用此开源库很简单，我们只需要在maven项目中添加插件的依赖即可&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;plugin&amp;gt;
    &amp;lt;groupId&amp;gt;com.github.shalousun&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;smart-doc-maven-plugin&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.0.2&amp;lt;/version&amp;gt;
    &amp;lt;configuration&amp;gt;
        &amp;lt;!--指定生成文档的使用的配置文件,配置文件放在自己的项目中--&amp;gt;
        &amp;lt;configFile&amp;gt;./src/main/resources/smart-doc.json&amp;lt;/configFile&amp;gt;
        &amp;lt;!--指定项目名称--&amp;gt;
        &amp;lt;projectName&amp;gt;测试&amp;lt;/projectName&amp;gt;
        &amp;lt;!--smart-doc实现自动分析依赖树加载第三方依赖的源码，如果一些框架依赖库加载不到导致报错，这时请使用excludes排除掉--&amp;gt;
        &amp;lt;excludes&amp;gt;
            &amp;lt;!--格式为：groupId:artifactId;参考如下--&amp;gt;
            &amp;lt;exclude&amp;gt;com.alibaba:fastjson&amp;lt;/exclude&amp;gt;
        &amp;lt;/excludes&amp;gt;
    &amp;lt;/configuration&amp;gt;
    &amp;lt;executions&amp;gt;
        &amp;lt;execution&amp;gt;
            &amp;lt;!--如果不需要在执行编译时启动smart-doc，则将phase注释掉--&amp;gt;
            &amp;lt;phase&amp;gt;compile&amp;lt;/phase&amp;gt;
            &amp;lt;goals&amp;gt;
                &amp;lt;goal&amp;gt;html&amp;lt;/goal&amp;gt;
            &amp;lt;/goals&amp;gt;
        &amp;lt;/execution&amp;gt;
    &amp;lt;/executions&amp;gt;
&amp;lt;/plugin&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;之后，在resources文件夹中新建&lt;code&gt;smart-doc.json&lt;/code&gt;文件，进行一些配置即可&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
  &quot;outPath&quot;: &quot;Q:\\JavaWebProject\\shunbang\\target&quot;, //指定文档的输出路径
  &quot;serverUrl&quot;: &quot;http://localhost:9200/shunbang&quot;, //设置服务器地址,非必须
//  &quot;serverUrl&quot;: &quot;http://47.101.148.199:9200/shunbang&quot;, //设置服务器地址,非必须
  &quot;isStrict&quot;: false, //是否开启严格模式
  &quot;allInOne&quot;: true  //是否将文档合并到一个文件中，一般推荐为true
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我这里没开启严格模式，若是开启了严格模式，则调用插件的时候就会报错&lt;/p&gt;
&lt;p&gt;之后直接在旁边的插件找到，选择对应生成的文档&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1210268/202002/1210268-20200213211128948-188896770.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;之后就可以在输出文件夹中找到html文件了&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1210268/202002/1210268-20200213211159506-817194795.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;打开网页，就会有详细的文档了&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1210268/202002/1210268-20200213211300885-2020636640.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;补充&quot;&gt;补充&lt;/h3&gt;
&lt;h4 id=&quot;jsonignore注解&quot;&gt;JsonIgnore注解&lt;/h4&gt;
&lt;p&gt;若是存在某些敏感字段不需要被返回，在实体类的字段中添加JsonIgnore注解(&lt;strong&gt;注意：此JsonIgnore注解为spring boot内置jackson框架自带&lt;/strong&gt;)&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class JacksonAnnotation {

    /**
     * 用户名
     */

    @JsonProperty(&quot;name&quot;)
    private String username;


    /**
     * 身份证号
     */
    @JsonIgnore
    private String idCard;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Fastjson使用 @JSONField(serialize = false),起关键作用的是serialize = false&lt;/p&gt;
&lt;h4 id=&quot;mock注解&quot;&gt;mock注解&lt;/h4&gt;
&lt;p&gt;smart-doc会在生成的文档的例子中进行自动随机赋值，如下图&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1210268/202002/1210268-20200213211849332-1158707156.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果不想随机赋值，可以使用mock注解指定例子中的数据&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1210268/202002/1210268-20200213212759703-19273111.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;ignore注解&quot;&gt;ignore注解&lt;/h4&gt;
&lt;p&gt;这个是smart-doc自带的注解，写在实体类字段的注释上，生成的API文档就会忽略此字段&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1210268/202002/1210268-20200213212759703-19273111.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;更多详情，请参考&lt;a href=&quot;https://gitee.com/sunyurepository/smart-doc/wikis/smart-doc%20maven%E6%8F%92%E4%BB%B6?sort_id=1791450&quot;&gt;官方文档&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;具体编码&quot;&gt;具体编码&lt;/h2&gt;
&lt;p&gt;spring boot中其实内置了&lt;code&gt;GetMapping&lt;/code&gt;、&lt;code&gt;PostMapping&lt;/code&gt;、&lt;code&gt;PutMapping&lt;/code&gt;、&lt;code&gt;DeleteMapping&lt;/code&gt;，分别对应的不同的请求方式，如果使用了以上注解，那么发送url请求的方式也是应该相对应，否则服务器不会进行数据的返回&lt;/p&gt;
&lt;h3 id=&quot;指定id&quot;&gt;1.指定id&lt;/h3&gt;
&lt;p&gt;想要通过&lt;code&gt;http://localhost:9200/shunbang/api/user/users/1&lt;/code&gt;查询指定id用户信息&lt;/p&gt;
&lt;p&gt;使用PathVariable注解&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 查询指定id的用户信息
 *
 * @param id 用户id
 * @return 用户信息
 */
@GetMapping(&quot;{id}&quot;)
public User selectByPk(@PathVariable(&quot;id&quot;) Integer id) {
    return userMapper.selectOne(new QueryWrapper&amp;lt;User&amp;gt;().eq(&quot;user_id&quot;, id));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;limit限制&quot;&gt;2.limit限制&lt;/h3&gt;
&lt;p&gt;想要通过&lt;code&gt;http://localhost:9200/shunbang/api/user/users?limit=10&lt;/code&gt;来获得前几条记录，limit此参数是可选的，使用RequestParam注解&lt;/p&gt;
&lt;p&gt;当用户没有输入limit参数，则显示返回所有的数据，有的话则进行数据的限制，&lt;strong&gt;offset也是同理&lt;/strong&gt;，之后便不多说了&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 查询所有用户
 *
 * @return 用户列表的json
 */
@GetMapping(&quot;users&quot;)
public List&amp;lt;User&amp;gt; selectAll(@RequestParam(required = false) Integer limit) {
    if (limit == null) {
        return userMapper.selectList(null);
    } else {
        System.out.println(limit);
        return userMapper.selectList(null);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;传递实体类&quot;&gt;3.传递实体类&lt;/h3&gt;
&lt;p&gt;原本我是想要通过&lt;code&gt;http://localhost:9200/shunbang/api/user/update?jsonData=xx&lt;/code&gt;这样传递实体类的json数据，之后由后台接收json数据，并再将json数据转为实体类对象，调用update方法，进行表记录的update&lt;/p&gt;
&lt;p&gt;其实，有个方法比上面的方法更简单，使用RequestBody注解，之后进行put的请求，将json数据直接通过body传递&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@PutMapping(&quot;update&quot;)
public boolean updateUser(@RequestBody User user) {
    return user.updateById();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;java发送url请求&quot;&gt;Java发送url请求&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;HttpURLConnection conn =new URL(&quot;address&quot;).openConnection();
conn.setRequestMethod(&quot;PUT&quot;); // 可以根据需要 提交 GET、POST、DELETE、PUT等http提供的功能
conn.setRequestProperty(&quot;Content-Type&quot;, &quot; application/json&quot;);//设定 请求格式 json，也可以设定xml格式的&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述是原生的，之后我会在补充使用okhttp框架进行相关的接口申请数据&lt;/p&gt;
&lt;p&gt;我是使用的postwoman进行API的测试&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1210268/202002/1210268-20200213214715342-1497836663.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/sunyurepository/smart-doc&quot;&gt;smart-doc&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/shawWey/p/9842684.html&quot;&gt;SpringBoot RestFul风格API接口开发&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.zhihu.com/question/64312188?sort=created&quot;&gt;Post 方法参数写在body中和写在url中有什么区别？知乎严振杰回答&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 13 Feb 2020 13:53:00 +0000</pubDate>
<dc:creator>Stars-one</dc:creator>
<og:description>最近需要设计一个API服务器，想要把API接口搞得规范一下，就通过网上搜集到了一些资料，以下便是自己的一些理解以及相关的具体实现 本文采用的是spring boot+maven的方案 restful规</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/stars-one/p/12305429.html</dc:identifier>
</item>
<item>
<title>自己动手写个异步IO函数 --（基于 c# Task） - 源之缘</title>
<link>http://www.cnblogs.com/yuanchenhui/p/async-io-example.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuanchenhui/p/async-io-example.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;前言 &lt;/span&gt;  &lt;/strong&gt; 对于服务端，达到高性能、高扩展离不开异步。对于客户端，函数执行时间是1毫秒还是100毫秒差别不大，没必要为这一点点时间煞费苦心。对于异步，好多人还有误解，如： 异步就是多线程；异步就是如何利用好线程池。异步不是这么简单，否则微软没必要在异步上花费这么多心思。本文就介绍异步最新的实现方式：Task，并自己动手写一个异步IO函数。只有了解了异步函数内部实现方式，才能更好的利用它。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　对于c#，异步处理经过了多个阶段，但是对于现阶段异步就是Task，微软用Task来抽象异步操作。以后的异步函数，处理的都是Task。你会看到处处都是task的身影。为了处理Task，c#引入了两个关键词async，await。这两个关键词也可以说是一个关键词，因为async的存在是为了表明await是关键词。总而言之：两个关键词干了一件事，async关键词并不改变函数的声明。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　有人说await就是语法糖，不值得大书特书，我只能说你错了。软件开发坚持的原则为：代码要省，代码要清晰易懂！如果没有语法糖，代码的维护性大大降低。await这个语法糖做的事很多；如果不用await，处理同样的逻辑，需要多写很多代码，并导致逻辑不清晰。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Task的分类&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 　　异步分为两类 compute-base 和 IO-base。compute-base就是计算密集型，函数所有的操作都是在内存中，不涉及IO；如果运行这个函数，则单个线程利用率达100%；IO-base就是涉及到IO，IO包括文件读写，socket读写；这类异步操作底层涉及到IOCP（完成端口）。相应的，Task也分为两类。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　对于这两个区别可以举个例子来区分：一台电脑为4个线程。如果同时有4个compute-base线程运行，cpu的利用率为100%。如果同时有4个 IO-base的异步操作，cpu利用率可能远远低于100%。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　对于.net 库,有些函数会有两个版本：一个是同步操作，一个是异步操作（函数名以Async结尾，返回值为Task）。举个例子：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/245753/202002/245753-20200213182433064-574195194.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    这是WebClient类获取网址内容函数。你会问DownloadStringTaskAsync是compute-base  Task，还是 IO-base Task？我可以肯定的告诉你：只要是.net基本类库提供的异步函数基本都是IO-base Task（微软官方文档是这样要求）。其实这样要求是有道理的：对于compute-base异步，比较容易封装；再者，这样的异步是不能大规模的并发的。如果16个线程cpu，同时并发16个这样的异步操作就是上限了；如果再多，反而会有害！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　有人说，如果基本类库不提供 IO-base Task函数，我也可以封装一下，这个也不难啊！代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把一个同步操作，改造成异步&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;&lt;span&gt;byte&lt;/span&gt;[]&amp;gt; DownloadDataAsync(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; url)
{
            WebRequest request &lt;/span&gt;=&lt;span&gt; WebRequest.Create(url);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;await&lt;/span&gt; Task.Run(() =&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; response =&lt;span&gt; request.GetResponse())
                &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; responseStream =&lt;span&gt; response.GetResponseStream())
                &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; result = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MemoryStream())
                {
                    responseStream.CopyTo(result);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result.ToArray();
                }
            });
 }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　上面函数如果说是异步操作，也不错。但是，这不是“好”的异步操作！这是异步操作中夹杂着同步IO。会导致线程等待。如果有100个这样的异步操作，就需要100个线程，这些线程大部分并没在干活，而是在等待！ 对于“好”的异步IO，如果同时有100个操作，甚至几万个操作，使用的线程都是有限的，一般不超过cpu线程数。这是怎么实现的？这涉及到IOCP，说起来有些复杂，可以参考IOCP相关资料。类库提供异步IO操作，都是涉及到IOCP的。所以得到如下结论： 如果类库不提供IO异步函数，无论怎么改造，不可能改造成“好”的异步函数！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Task实现的基本原理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  Task变量状态如下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/245753/202002/245753-20200213200833693-357591371.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　状态简要分为生成、执行、执行完毕这三个阶段。如果执行完毕前获取执行后的值Task.Result，函数就会阻塞。那我怎么知道什么时候完成，而又不阻塞？有两种办法，轮询和回调通知。Task.IsCompleted属性会指示函数是否执行完毕。轮询不是一个好的办法，采用回调通知是上策！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　回调通知有个缺点：处理逻辑不直观，回调函数与异步调用函数不在一块，还有可能隔着很多行代码或不在同一个文件。如果这样的回调函数太多，对理解代码逻辑造成困难，代码不易维护。微软也考虑到了这个问题，那就用await关键词来解决。await帮你处理了回调函数的弊端，&lt;strong&gt;其实await后面的代码与await前面的代码不属于同一个函数！await后面的代码就是回调函数！&lt;/strong&gt;微软确实给我们解决了这个问题，但是又带来另一个问题。好多人不明白，明明是同一个函数，怎么实现了等待而又不阻塞当前线程！归根到底，还是要理解await背后帮你干了啥，否则就会一直困惑。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　要生成Task变量，只要理解几个关键的处理步骤就行了。TaskCompletionSource类会帮助我们生成Task。如果IO完成，设置Task的状态为完成就行了。后面，就会执行回调函数（await关键词帮我干了，你看不到回调）！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;如何写一个IO-base Task函数？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　大部分情况下不需要自己写这样的函数。但是，人是有好奇心的，如果不明白函数实现的原理，总是感觉不能释怀！再者，明白函数实现原理，就能更好的利用这类函数。下面讲解一下如何利用IOCP来实现异步函数。我没有参考.net的源码，只是根据逻辑推理应该这实现。肯定和.net源码实现有出入，我写这些代码主要为了阐明Task实现原理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;IOCP处理逻辑&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/245753/202002/245753-20200213203226877-494238280.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　对于IOCP，这里不展开来讲了，否则就跑题了。以socket读取为例子，简单总结一下：如果你要接收100个字节的数据，你告诉IOCP你要接收100个字节数据，并提供100个字节的buffer，函数立即返回；数据到达后，IOCP通知你，数据到了，数据就存在你提供的buffer里。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 　　&lt;strong&gt;实现异步IO伪代码如下：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AyncInside
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;完成端口句柄&lt;/span&gt;
        IntPtr iocpHandle =&lt;span&gt; IntPtr.Zero;

        Task&lt;/span&gt;&amp;lt;&lt;span&gt;byte&lt;/span&gt;[]&amp;gt; ReadFromSocket(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; count)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;生成此次操作需要相关数据 &lt;/span&gt;
            TaskCompletionSourceRead readInfo = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TaskCompletionSourceRead();
            readInfo.Buffer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[count];

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果没生成iocp则生成。&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (iocpHandle ==&lt;span&gt; IntPtr.Zero)
            {
                iocpHandle &lt;/span&gt;=&lt;span&gt; CreateIocp();
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 告诉iocp，要读取count字节数据。函数不会阻塞，会立即返回
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从完成端口收到数据后，会调用ReadScoketCallback
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;我们把readInfo也传给函数。当回调时，该变量会传给回调函数。&lt;/span&gt;
&lt;span&gt;            ReadFromIocp(iocpHandle, readInfo.Buffer, readInfo, ReadScoketCallback);
            
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; readInfo.Tcs.Task;
        }


        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; ReadScoketCallback(&lt;span&gt;byte&lt;/span&gt;[] buffer, &lt;span&gt;int&lt;/span&gt; readCount,&lt;span&gt;object&lt;/span&gt;&lt;span&gt; tag)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;tag就是调用ReadFromIocp时，传的readInfo
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;便于我们知道异步调用时的上下文数据。&lt;/span&gt;
            TaskCompletionSourceRead readInfo = tag &lt;span&gt;as&lt;/span&gt;&lt;span&gt; TaskCompletionSourceRead;
           
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(buffer.Length ==&lt;span&gt; readCount )
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用完SetResult后，await后面的代码就会被执行！&lt;/span&gt;
&lt;span&gt;                readInfo.Tcs.SetResult(buffer);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (buffer.Length &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
            {
                Array.Resize(&lt;/span&gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt; buffer, readCount);
                readInfo.Tcs.SetResult(buffer);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                readInfo.Tcs.TrySetException(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Exception(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;读取数据异常！socket可能已断开！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
            }
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ReadFromIocp(IntPtr iocpHandle, &lt;span&gt;byte&lt;/span&gt;[] buffer, &lt;span&gt;object&lt;/span&gt;&lt;span&gt; tag,
            Action&lt;/span&gt;&amp;lt;&lt;span&gt;byte&lt;/span&gt;[] , &lt;span&gt;int&lt;/span&gt;,&lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt; readScoketCallback)
        {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NotImplementedException();
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; IntPtr CreateIocp()
        {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NotImplementedException();
        }

    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;封装异步读取需要的数据&lt;/span&gt;
    &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TaskCompletionSourceRead
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; TaskCompletionSource&amp;lt;&lt;span&gt;byte&lt;/span&gt;[]&amp;gt; Tcs { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] Buffer { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　上述代码与实际可使用代码差距还很大，我在这里主要为了阐明原理。通过上面的代码，我们可以看到，这个异步函数并没生成新的线程；网卡驱动和IOCP配合，帮我们接收了数据。所以这种方式才是真正可扩展的异步IO。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;后记&lt;/strong&gt;&lt;/span&gt; 异步IO和可扩展服务紧密关联。对于.net core平台，你会看到很多函数都是异步的。理解和用好异步IO函数非常重要。本文通过自己对异步IO的理解，试图通过代码阐明异步IO实现原理。希望你看过此文后，能对此有更深的理解！如果此文对你有所裨益，希望您给点个赞！&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 13 Feb 2020 13:35:00 +0000</pubDate>
<dc:creator>源之缘</dc:creator>
<og:description>前言 对于服务端，达到高性能、高扩展离不开异步。对于客户端，函数执行时间是1毫秒还是100毫秒差别不大，没必要为这一点点时间煞费苦心。对于异步，好多人还有误解，如： 异步就是多线程；异步就是如何利用好</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yuanchenhui/p/async-io-example.html</dc:identifier>
</item>
<item>
<title>全卷积网络FCN - core!</title>
<link>http://www.cnblogs.com/sdu20112013/p/12303752.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sdu20112013/p/12303752.html</guid>
<description>&lt;p&gt;fcn是深度学习用于图像分割的鼻祖.后续的很多网络结构都是在此基础上演进而来.&lt;/p&gt;
&lt;p&gt;图像分割即像素级别的分类.&lt;/p&gt;
&lt;p&gt;语义分割的基本框架:&lt;br/&gt;前端fcn(以及在此基础上的segnet,deconvnet,deeplab等) + 后端crf/mrf&lt;/p&gt;
&lt;p&gt;FCN是分割网络的鼻祖,后面的很多网络都是在此基础上提出的.&lt;br/&gt;&lt;a href=&quot;https://arxiv.org/abs/1411.4038&quot;&gt;论文地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;和传统的分类网络相比,就是将传统分类网络的全连接层用反卷积层替代.得到一个和图像大小一致的feature map。本篇文章用的网络是&lt;a href=&quot;https://www.cnblogs.com/sdu20112013/p/12176304.html&quot;&gt;VGG&lt;/a&gt;.&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/583030/202002/583030-20200213193621507-373855529.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;主要关注两点&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;全连接层替换成卷积层.用反卷积的方式完成上采样&lt;/li&gt;
&lt;li&gt;不同layer的输出要做相加.用以增强feature map的表达能力.&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;反卷积deconvolutional&quot;&gt;反卷积(deconvolutional)&lt;/h2&gt;
&lt;p&gt;关于反卷积(也叫转置卷积)的详细推导,可以参考:&amp;lt;&lt;a href=&quot;https://blog.csdn.net/LoseInVain/article/details/81098502&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/LoseInVain/article/details/81098502&lt;/a&gt;＞&lt;/p&gt;
&lt;p&gt;简单滴说就是:卷积的反向操作．以4x4矩阵Ａ为例,卷积核Ｃ(3x3,stride=1),通过卷积操作得到一个2x2的矩阵B. 转置卷积即已知B,要得到A,我们要找到卷积核C,使得B相当于A通过C做正向卷积,得到B.&lt;/p&gt;
&lt;p&gt;转置卷积是一种上采样的方法.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/583030/202002/583030-20200211145933264-1331554035.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;跳连skip-layer&quot;&gt;跳连(skip layer)&lt;/h2&gt;
&lt;p&gt;如果只用特征提取部分(也就是VGG全连接层之前的部分)得到的feature map做上采样将feature map还原到图像输入的size的话,feature不够精确.所以采用不同layer的feature map做上采样再组合起来.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/583030/202002/583030-20200213161450244-902249173.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;代码解析&quot;&gt;代码解析&lt;/h2&gt;
&lt;p&gt;源码:&lt;a href=&quot;https://github.com/pochih/FCN-pytorch&quot; class=&quot;uri&quot;&gt;https://github.com/pochih/FCN-pytorch&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其中的核心代码如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class FCNs(nn.Module):

    def __init__(self, pretrained_net, n_class):
        super().__init__()
        self.n_class = n_class
        self.pretrained_net = pretrained_net
        self.relu    = nn.ReLU(inplace=True)
        self.deconv1 = nn.ConvTranspose2d(512, 512, kernel_size=3, stride=2, padding=1, dilation=1, output_padding=1)
        self.bn1     = nn.BatchNorm2d(512)
        self.deconv2 = nn.ConvTranspose2d(512, 256, kernel_size=3, stride=2, padding=1, dilation=1, output_padding=1)
        self.bn2     = nn.BatchNorm2d(256)
        self.deconv3 = nn.ConvTranspose2d(256, 128, kernel_size=3, stride=2, padding=1, dilation=1, output_padding=1)
        self.bn3     = nn.BatchNorm2d(128)
        self.deconv4 = nn.ConvTranspose2d(128, 64, kernel_size=3, stride=2, padding=1, dilation=1, output_padding=1)
        self.bn4     = nn.BatchNorm2d(64)
        self.deconv5 = nn.ConvTranspose2d(64, 32, kernel_size=3, stride=2, padding=1, dilation=1, output_padding=1)
        self.bn5     = nn.BatchNorm2d(32)
        self.classifier = nn.Conv2d(32, n_class, kernel_size=1)

    def forward(self, x):
        output = self.pretrained_net(x)
        x5 = output['x5']  # size=(N, 512, x.H/32, x.W/32)
        x4 = output['x4']  # size=(N, 512, x.H/16, x.W/16)
        x3 = output['x3']  # size=(N, 256, x.H/8,  x.W/8)
        x2 = output['x2']  # size=(N, 128, x.H/4,  x.W/4)
        x1 = output['x1']  # size=(N, 64, x.H/2,  x.W/2)

        score = self.bn1(self.relu(self.deconv1(x5)))     # size=(N, 512, x.H/16, x.W/16)
        score = score + x4                                # element-wise add, size=(N, 512, x.H/16, x.W/16)
        score = self.bn2(self.relu(self.deconv2(score)))  # size=(N, 256, x.H/8, x.W/8)
        score = score + x3                                # element-wise add, size=(N, 256, x.H/8, x.W/8)
        score = self.bn3(self.relu(self.deconv3(score)))  # size=(N, 128, x.H/4, x.W/4)
        score = score + x2                                # element-wise add, size=(N, 128, x.H/4, x.W/4)
        score = self.bn4(self.relu(self.deconv4(score)))  # size=(N, 64, x.H/2, x.W/2)
        score = score + x1                                # element-wise add, size=(N, 64, x.H/2, x.W/2)
        score = self.bn5(self.relu(self.deconv5(score)))  # size=(N, 32, x.H, x.W)
        score = self.classifier(score)                    # size=(N, n_class, x.H/1, x.W/1)

        return score  # size=(N, n_class, x.H/1, x.W/1)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;train.py中&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;vgg_model = VGGNet(requires_grad=True, remove_fc=True)
fcn_model = FCNs(pretrained_net=vgg_model, n_class=n_class)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我们重点看&lt;code&gt;FCN&lt;/code&gt;的forward函数&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    def forward(self, x):
        output = self.pretrained_net(x)
        x5 = output['x5']  # size=(N, 512, x.H/32, x.W/32)
        x4 = output['x4']  # size=(N, 512, x.H/16, x.W/16)
        x3 = output['x3']  # size=(N, 256, x.H/8,  x.W/8)
        x2 = output['x2']  # size=(N, 128, x.H/4,  x.W/4)
        x1 = output['x1']  # size=(N, 64, x.H/2,  x.W/2)

        score = self.bn1(self.relu(self.deconv1(x5)))     # size=(N, 512, x.H/16, x.W/16)
        score = score + x4                                # element-wise add, size=(N, 512, x.H/16, x.W/16)
        score = self.bn2(self.relu(self.deconv2(score)))  # size=(N, 256, x.H/8, x.W/8)
        score = score + x3                                # element-wise add, size=(N, 256, x.H/8, x.W/8)
        score = self.bn3(self.relu(self.deconv3(score)))  # size=(N, 128, x.H/4, x.W/4)
        score = score + x2                                # element-wise add, size=(N, 128, x.H/4, x.W/4)
        score = self.bn4(self.relu(self.deconv4(score)))  # size=(N, 64, x.H/2, x.W/2)
        score = score + x1                                # element-wise add, size=(N, 64, x.H/2, x.W/2)
        score = self.bn5(self.relu(self.deconv5(score)))  # size=(N, 32, x.H, x.W)
        score = self.classifier(score)                    # size=(N, n_class, x.H/1, x.W/1)

        return score  # size=(N, n_class, x.H/1, x.W/1)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可见FCN的输入为(batch_size,c,h,w),输出为(batch_size,class,h,w).&lt;br/&gt;首先是经过vgg的特征提取层,可以得到feature map. 5个max_pool后的feature map的size分别为&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        x5 = output['x5']  # size=(N, 512, x.H/32, x.W/32)
        x4 = output['x4']  # size=(N, 512, x.H/16, x.W/16)
        x3 = output['x3']  # size=(N, 256, x.H/8,  x.W/8)
        x2 = output['x2']  # size=(N, 128, x.H/4,  x.W/4)
        x1 = output['x1']  # size=(N, 64, x.H/2,  x.W/2)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;之后&lt;strong&gt;每一个pool layer的feature map都经过一次2倍上采样,并与前一个pool layer的输出进行element-wise add.(resnet也有类似操作).从而使得上采样后的feature map信息更充分更精准,模型的鲁棒性会更好.&lt;/strong&gt;&lt;br/&gt;例如以输入图片尺寸为224x224为例,pool4的输出为(,512,14,14),pool5的输出为(,512,7,7),反卷积后得到(,512,14,14),再与pool4的输出做element-wise add。得到的仍然是(,512,14,14). 对这个输出做上采样得到(,256,28,28)再与pool3的输出相加. 依次类推,最终得到(,64,112,112).&lt;/p&gt;
&lt;p&gt;此后,再做一次反卷积上采样得到(,32,224,224),之后卷积得到(,n_class,224,224)。即得到n_class张224x224的feature map。&lt;/p&gt;
&lt;p&gt;下图显示了随着上采样的进行,得到的feature map细节越来越丰富.&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/583030/202002/583030-20200213174834064-240321410.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;损失函数&quot;&gt;损失函数&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;criterion = nn.BCEWithLogitsLoss()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;损失函数采用二分类交叉熵.torch中有2个计算二分类交叉熵的函数&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;BCELoss()&lt;/li&gt;
&lt;li&gt;BCEWithLogitsLoss()&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;后者只是在前者的基础上,对输入先做一个sigmoid将输入转换到0-1之间.即BCEWithLogitsLoss = Sigmoid + BCELoss&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/583030/202002/583030-20200213192729650-52505797.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一个具体的例子可以参考:&lt;a href=&quot;https://blog.csdn.net/qq_22210253/article/details/85222093&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/qq_22210253/article/details/85222093&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 13 Feb 2020 12:32:00 +0000</pubDate>
<dc:creator>core!</dc:creator>
<og:description>全卷积网络FCN fcn是深度学习用于图像分割的鼻祖.后续的很多网络结构都是在此基础上演进而来. 图像分割即像素级别的分类. 语义分割的基本框架: 前端fcn(以及在此基础上的segnet,decon</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sdu20112013/p/12303752.html</dc:identifier>
</item>
<item>
<title>SpringMVC 进阶 - CoderJerry</title>
<link>http://www.cnblogs.com/yangyuanhu/p/12304786.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yangyuanhu/p/12304786.html</guid>
<description>&lt;p&gt;一些情况下我们可能需要对请求进行限制,比如仅允许POST,GET等...&lt;/p&gt;
&lt;p&gt;RequestMapping注解中提供了多个参数用于添加请求的限制条件&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;value 请求地址&lt;/li&gt;
&lt;li&gt;path 请求地址&lt;/li&gt;
&lt;li&gt;method 请求方法&lt;/li&gt;
&lt;li&gt;headers 请求头中必须包含指定字段&lt;/li&gt;
&lt;li&gt;params 必须包含某个请求参数&lt;/li&gt;
&lt;li&gt;consumes 接受的数据媒体类型 (与请求中的contentType匹配才处理)&lt;/li&gt;
&lt;li&gt;produce 返回的媒体类型 (与请求中的accept匹配才处理)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;案例:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RequestMapping(value = &quot;/editCourse&quot;,method = RequestMethod.POST,headers = {&quot;id&quot;},params = {&quot;name&quot;},consumes = {&quot;text/plain&quot;},produces = {&quot;text/html&quot;})
//含义:url为/editCourse 请求方法为POST hander必须包含id字段  参数必须包含name 只接受text/plain类型数据 返回数据类型为text/html&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了简化书写,MVC还提供了集合路径和方法限制的注解,包括常见的请求方法:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;PostMapping
GetMapping
DeleteMapping
PutMapping

例:
@PostMapping(&quot;/editCourse&quot;)&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;handler方法可以是三种类型的返回值,用于不同场景&lt;/p&gt;
&lt;h2 id=&quot;modelandview&quot;&gt;ModelAndView&lt;/h2&gt;
&lt;p&gt;返回值为视图和数据的包装类型,用于返回逻辑视图名称和视图需要展示的数据&lt;/p&gt;
&lt;p&gt;等同于在Request中添加了属性,然后进行了请求转发&lt;/p&gt;
&lt;p&gt;例:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RequestMapping(&quot;/test&quot;)
public ModelAndView test() {
    ModelAndView modelAndView = new ModelAndView();
    modelAndView.setViewName(&quot;index.jsp&quot;);
    modelAndView.addObject(&quot;msg&quot;, &quot;hello ssm!&quot;);
    return modelAndView;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;void&quot;&gt;void&lt;/h2&gt;
&lt;p&gt;表示handler不返回任何数据,用于当需要直接操作response完成响应的场景&lt;/p&gt;
&lt;p&gt;例:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RequestMapping(&quot;/test2&quot;)
public void test2(String name,HttpServletResponse response) throws IOException {
    response.getWriter().println(name.toUpperCase());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;string&quot;&gt;String&lt;/h2&gt;
&lt;p&gt;返回一个字符串类型的值,返回的内容可以是视图名称也可以是其他请求地址&lt;/p&gt;
&lt;p&gt;其背后采用的是请求转发的方式&lt;/p&gt;
&lt;p&gt;例:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RequestMapping(&quot;/test3&quot;)
public String test3(Model model) {
    model.addAttribute(&quot;msg&quot;,&quot;hello XXX&quot;);
    return &quot;index.jsp&quot;;
}
@RequestMapping(&quot;/test4&quot;)
public String test4() {
    return &quot;/test&quot;;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;转发和重定向&quot;&gt;转发和重定向:&lt;/h4&gt;
&lt;p&gt;也可指定对目标地址的请求是通过重定向或请求转发;&lt;/p&gt;
&lt;p&gt;例:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RequestMapping(&quot;/test5&quot;)
public String test5() {
    return &quot;forward:/index.jsp&quot;;
}
@RequestMapping(&quot;/test6&quot;)
public String test6() {
    return &quot;redirect:/index.jsp&quot;;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然了 默认就是forward所以可以省略;&lt;/p&gt;

&lt;p&gt;当下,大多数公司都会有移动端App,当我们的后台服务需要为App提供接口时,就不得不使用到json数据了,当然还有前后端分离项目中前端和后台同样采用json来交换数据;&lt;/p&gt;
&lt;p&gt;在开始前,需要导入jackson依赖,用于实现json的序列化与反序列化;&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;com.fasterxml.jackson.core&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;jackson-databind&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;2.9.9&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;返回json数据&quot;&gt;返回json数据&lt;/h2&gt;
&lt;p&gt;@ResponseBody注解用于标注一个handler方法返回的是json数据,同时方法的返回值将作为返回给前台的数据;&lt;/p&gt;
&lt;p&gt;例:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RequestMapping(&quot;/getCourseList&quot;)
@ResponseBody
public List&amp;lt;Course&amp;gt; getCourseList() {  //获取所有课程
    return courseService.selectCourses();
}
@RequestMapping(&quot;/getCourse&quot;)
@ResponseBody
public Course getCourse(Integer id) {// 根据id获取一个课程
    return courseService.selectByID(id);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ResponseBody会将响应的ContentType设置为application/json, 然后调用jackson的toJsonString将返回值转为json字符串,最后返回给客户端;&lt;/p&gt;
&lt;h3 id=&quot;restcontroller&quot;&gt;@RestController&lt;/h3&gt;
&lt;p&gt;如果需要为每一个方法添加ResponseBody的话,就显得非常麻烦,SpringMVC提供了@RestController注解,表示这是一个所有handler返回值全都是json的Controller,相当于把Controller和ResponseBody两个注解合并在一起;&lt;/p&gt;
&lt;p&gt;例:&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;@RestController
public class CourseController {.....}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;接受json数据&quot;&gt;接受json数据&lt;/h2&gt;
&lt;p&gt;SpringMVC可以帮助我们将json参数反序列化到指定的实体类型,List或Map;&lt;/p&gt;
&lt;p&gt;需要强调的是:&lt;strong&gt;客户端必须指定ContenType为application/json&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RequestMapping(&quot;/addCourse&quot;)
@ResponseBody
public Course addCourse(@RequestBody Course course) {//接收json参数映射到实体
    course.setName(&quot;接收json成功&quot;);//修改name再把数据发回去 以便查看效果
    return course;
}

@RequestMapping(&quot;/addCourses&quot;)
@ResponseBody
public List&amp;lt;Course&amp;gt; addCourse(@RequestBody List&amp;lt;Course&amp;gt; courses) {//接收json数组参数映射到list
    return courses;
}

@RequestMapping(&quot;/addData&quot;)
@ResponseBody
public Map&amp;lt;String,String&amp;gt; addData(@RequestBody Map&amp;lt;String,String&amp;gt; data) {//接收json数据映射到map
    return data;
}

@RequestMapping(&quot;/addInfo&quot;)
@ResponseBody
public String addInfo(@RequestBody String data) {//接收json数据不做任何转换
    return data;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当客户端传递的json比较复杂时可能无法直接转换到某个实体类型,这是我们可以通过Map来接收,或直接获取原始的json字符串自己处理; 就像上面的&lt;code&gt;addData&lt;/code&gt; 和&lt;code&gt;addInfo&lt;/code&gt;一样&lt;/p&gt;

&lt;p&gt;顾名思义Handler拦截器可对Handler方法进行拦截,控制Handler方法是否执行,与Servlet的过滤器非常相似&lt;/p&gt;
&lt;p&gt;但是要注意:&lt;/p&gt;
&lt;p&gt;​ Servlet的filter的执行时机是在SpringMVC之前,过滤的目标对象是请求;&lt;/p&gt;
&lt;p&gt;​ 而Handler拦截器,拦截的目标对象是Handler方法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Handler拦截器可以方便的实现,登录状态验证,操作权限验证等操作;&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;使用案例&quot;&gt;使用案例:&lt;/h2&gt;
&lt;p&gt;1.编写拦截器&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class MyInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        //在执行handler前调用   返回值将决定是否继续执行请求
        System.out.println(&quot;preHandle&quot;);
        return true;
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        //handler被真正执行了,已经拿到了handler的返回结果  但是DispatcherServlet还没有发送给前台
        System.out.println(&quot;postHandle&quot;);
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        //DispatcherServlet将视图发送给前台后的回调 (无论handler是否执行 一定有响应发给前台)
        System.out.println(&quot;afterCompletion&quot;);
      
        //Handler中出现的任何异常也会传给该方法,可以在这里进行处理
          if (ex != null){
            System.out.println(&quot;handler中出现异常了....&quot;);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.配置拦截器&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;mvc:interceptors&amp;gt;
    &amp;lt;mvc:interceptor&amp;gt;
        &amp;lt;mvc:mapping path=&quot;/**&quot;/&amp;gt;
        &amp;lt;bean class=&quot;com.kkb.interceptor.MyInterceptor&quot;/&amp;gt;
    &amp;lt;/mvc:interceptor&amp;gt;
&amp;lt;/mvc:interceptors&amp;gt;
&amp;lt;!--
* path用于指定拦截器拦截的url只有handler的url与之匹配才会被拦截  /** 表示拦截所有请求
* interceptors中可配置多个interceptor 
--&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.执行顺序&lt;/p&gt;
&lt;p&gt;拦截器的执行顺序由配置顺序来决定,拦截器也和filter一样是一个链条的形式&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1440878/202002/1440878-20200213193041178-328331379.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在请求处理完成时,会按照相反的顺序通知interceptor(即执行afterComplation),前提是这个拦截器正常放行了请求(preHandler中返回了true),否则不会收到通知;&lt;/p&gt;

&lt;p&gt;一个完整的系统必然要考虑异常情况的处理,SpringMVC提供了一种非常方便的处理方法,只需要实现HandlerExceptionResolver接口,并注册Bean至容器中即可&lt;/p&gt;
&lt;p&gt;1.编写异常处理器&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Component
public class MyExceptionHandler implements HandlerExceptionResolver {
    @Override
    public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) {
        ModelAndView modelAndView = new ModelAndView();
        modelAndView.setViewName(&quot;error.jsp&quot;);
        modelAndView.addObject(&quot;exobj&quot;,ex);
        return modelAndView;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到在处理方法的返回值为ModelAndView,我们需要在其中添加错误页面的名称和错误信息;&lt;/p&gt;
&lt;p&gt;2.注册到容器中&lt;/p&gt;
&lt;p&gt;​ 可以直接添加Component注解或是,在配置文件中注册&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;bean class=&quot;com.kkb.exceptionhandler.MyExceptionHandler&quot;/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;强调:无论是拦截器还是异常处理器都是针对handler而不是所有请求,举个例子如果请求本身就是错误的如404,是无法被异常Handler异常处理器处理的,仍需要到web.xml来进行配置&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 13 Feb 2020 11:32:00 +0000</pubDate>
<dc:creator>CoderJerry</dc:creator>
<og:description>请求限制 一些情况下我们可能需要对请求进行限制,比如仅允许POST,GET等... RequestMapping注解中提供了多个参数用于添加请求的限制条件 value 请求地址 path 请求地址 m</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yangyuanhu/p/12304786.html</dc:identifier>
</item>
<item>
<title>基于Qt的新冠肺炎疫情数据实时监控平台（开源小项目） - whik</title>
<link>http://www.cnblogs.com/whik/p/12304719.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/whik/p/12304719.html</guid>
<description>&lt;!--[if IE]&gt;
    &lt;div class=&quot;unsupported-browser&quot;&gt;
        &amp;#35813;&amp;#39029;&amp;#38754;&amp;#19981;&amp;#25903;&amp;#25345; Internet Explorer &amp;#27983;&amp;#35272;&amp;#22120;&amp;#65292;&amp;#24314;&amp;#35758;&amp;#20351;&amp;#29992;
        &lt;a href=&quot;https://www.google.cn/intl/zh-CN/chrome/&quot;&gt;Google Chrome&lt;/a&gt;,
        &lt;a href=&quot;https://www.mozilla.org/zh-CN/firefox/&quot;&gt;Firefox&lt;/a&gt; &amp;#25110;
        &lt;a href=&quot;https://www.microsoftedgeinsider.com/zh-CN/&quot;&gt;Microsoft Edge&lt;/a&gt;
    &lt;/div&gt;
&lt;![endif]--&gt;
&lt;div class=&quot;center-container &quot;&gt;
    &lt;div class=&quot;center-body card  h-sm-100&quot;&gt;
        &lt;div class=&quot;card-body&quot;&gt;
            


&lt;div class=&quot;login-top text-center&quot;&gt;
    &lt;span class=&quot;login-title&quot;&gt;博客园用户登录&lt;/span&gt;
    &lt;a href=&quot;https://www.cnblogs.com/&quot;&gt;
        &lt;svg class=&quot;login-sign&quot;&gt;&lt;use xlink:href=&quot;#icon-login-sign&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;
    &lt;p&gt;代码改变世界&lt;/p&gt;
&lt;/div&gt;
&lt;form id=&quot;loginForm&quot; method=&quot;post&quot; onsubmit=&quot;return false&quot; action=&quot;/signin?returnurl=https%3A%2F%2Fwww.cnblogs.com%2Fwhik%2Fp%2F12304719.html&quot;&gt;
    &lt;div class=&quot;form-group&quot;&gt;
        &lt;input tabindex=&quot;1&quot; class=&quot;form-control&quot; placeholder=&quot;登录用户名 / 邮箱&quot; autofocus=&quot;&quot; type=&quot;text&quot; data-val=&quot;true&quot; data-val-required=&quot;请输入登录用户名&quot; id=&quot;LoginName&quot; name=&quot;LoginName&quot; value=&quot;&quot;/&gt;&lt;span class=&quot;invalid-feedback field-validation-valid&quot; data-valmsg-for=&quot;LoginName&quot; data-valmsg-replace=&quot;true&quot;/&gt;
        &lt;a href=&quot;https://passport.cnblogs.com/GetUsername.aspx&quot; class=&quot;txt-forget-sign&quot;&gt;忘记登录用户名&lt;/a&gt;
    &lt;/div&gt;
    &lt;div class=&quot;form-group&quot;&gt;
        &lt;input tabindex=&quot;2&quot; class=&quot;form-control&quot; placeholder=&quot;密码&quot; type=&quot;password&quot; data-val=&quot;true&quot; data-val-required=&quot;请输入密码&quot; id=&quot;Password&quot; name=&quot;Password&quot;/&gt;&lt;span class=&quot;invalid-feedback field-validation-valid&quot; data-valmsg-for=&quot;Password&quot; data-valmsg-replace=&quot;true&quot;/&gt;
        &lt;a class=&quot;txt-forget-sign&quot; href=&quot;https://account.cnblogs.com/resetpassword&quot;&gt;忘记密码&lt;/a&gt;
    &lt;/div&gt;
    &lt;p&gt;
        &lt;input tabindex=&quot;3&quot; type=&quot;checkbox&quot; id=&quot;IsRemember&quot; name=&quot;IsRemember&quot; value=&quot;true&quot; class=&quot;custom-control-input&quot;/&gt;&lt;label class=&quot;custom-control-label&quot; for=&quot;IsRemember&quot;&gt;记住我&lt;/label&gt;
    &lt;/p&gt;

    &lt;button tabindex=&quot;4&quot; id=&quot;submitBtn&quot; type=&quot;submit&quot; class=&quot;btn-login btn btn-primary btn-sm ladda-button px-4&quot; data-style=&quot;slide-down&quot;&gt;
        &lt;span class=&quot;ladda-label&quot;&gt;登录&lt;/span&gt;
    &lt;/button&gt;
    &lt;div class=&quot;login-footer&quot;&gt;
        &lt;div class=&quot;ajax-error-box&quot;&gt;
            
        &lt;/div&gt;
        &lt;span&gt;没有账户，&lt;a href=&quot;https://account.cnblogs.com/signup&quot;&gt;立即注册&lt;/a&gt;&lt;/span&gt;
    &lt;/div&gt;
&lt;input name=&quot;__RequestVerificationToken&quot; type=&quot;hidden&quot; value=&quot;CfDJ8Nf-Z6tqUPlNrwu2nvfTJEgYXVGg7yBdbMT1mhkaJpSZBpcFh1i5Trp8m7mOBzsQHs1cTMvNvWOcYCq-77mcoet4mBvE5X5AYZ9ofmWgrY5EAGhQdCoeVvSG-7WWG4Bb5xRcoZDXAgqZKweIyKtd3rM&quot;/&gt;&lt;/form&gt;

&lt;input type=&quot;hidden&quot; id=&quot;PublicKey&quot; name=&quot;PublicKey&quot; value=&quot;MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCp0wHYbg/NOPO3nzMD3dndwS0MccuMeXCHgVlGOoYyFwLdS24Im2e7YyhB0wrUsyYf0/nhzCzBK8ZC9eCWqd0aHbdgOQT6CuFQBMjbyGYvlVYU2ZP7kG9Ft6YV6oc9ambuO7nPZh+bvXH0zDKfi02prknrScAKC0XhadTHT3Al0QIDAQAB&quot;/&gt;&lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Thu, 13 Feb 2020 11:04:00 +0000</pubDate>
<dc:creator>whik</dc:creator>
<dc:language>zh</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://account.cnblogs.com:443/signin?ReturnUrl=https%3A%2F%2Fwww.cnblogs.com%2Fwhik%2Fp%2F12304719.html</dc:identifier>
</item>
</channel>
</rss>