<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>将传统 WPF 程序迁移到 DotNetCore 3.0 - hippieZhou</title>
<link>http://www.cnblogs.com/hippieZhou/p/10661181.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hippieZhou/p/10661181.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/749711/201904/749711-20190410121728756-744186553.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;介绍&quot;&gt;介绍&lt;/h2&gt;
&lt;p&gt;由于历史原因，基于 &lt;strong&gt;Windows&lt;/strong&gt; 平台存在着大量的基于 &lt;strong&gt;.NetFramework&lt;/strong&gt; 开发的 &lt;em&gt;WPF&lt;/em&gt; 和 &lt;em&gt;WinForm&lt;/em&gt; 相关程序，如果将这些程序全部基于 &lt;strong&gt;DotNetCore 3.0&lt;/strong&gt; 重写一遍显然是不现实的，但是 &lt;strong&gt;DotNetCore&lt;/strong&gt; 是未来发展的趋势。所以本文通过以 &lt;em&gt;WPF&lt;/em&gt; 为例，介绍一下如何将传统 &lt;em&gt;WPF&lt;/em&gt; 迁移到 &lt;strong&gt;DotNetCore 3.0&lt;/strong&gt; 上。&lt;/p&gt;
&lt;h2 id=&quot;环境&quot;&gt;环境&lt;/h2&gt;
&lt;p&gt;我在之前的一篇文章 &lt;a href=&quot;https://www.cnblogs.com/hippieZhou/p/10637348.html&quot;&gt;DotNetCore 3.0 助力 WPF 开发&lt;/a&gt; 有提到过，如果想开发基于 &lt;strong&gt;DotNetCore 3.0&lt;/strong&gt; 的 &lt;em&gt;WPF&lt;/em&gt; 程序，我们需要安装 &lt;strong&gt;Visual Studio 2019&lt;/strong&gt; 和 &lt;strong&gt;DotNetCore 3.0 SDK&lt;/strong&gt;，这两个条件是必须具备的。同样的，我们做框架迁移，这两个条件同样也是必须的。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注：为了不必要的麻烦，建议使用 Visual Studio 2019 来进行迁移工作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;实验&quot;&gt;实验&lt;/h2&gt;
&lt;p&gt;首先，我们通过 &lt;strong&gt;Visual Studio 2019&lt;/strong&gt; 创建一个传统的基于 &lt;strong&gt;.NetFramework&lt;/strong&gt; 的 WPF 程序。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/749711/201904/749711-20190406114920611-645245674.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;项目创建完成之后，你会发现还是那个属性的味道，没有什么变化。尝试编译运行，也是没什么问题。&lt;/p&gt;
&lt;h3 id=&quot;更新-nuget&quot;&gt;更新 NuGet&lt;/h3&gt;
&lt;p&gt;在做迁移之前，我们需要确认一下我们的项目是否引用了 &lt;strong&gt;NuGet&lt;/strong&gt; 上的一些包，如果引用了，请务必更新至最新版本。虽然这不是必须的，但是却是有必要的，避免在迁移过程中出现一些未知错误。&lt;/p&gt;
&lt;p&gt;这里，我引用一下 &lt;strong&gt;Newtonsoft.Json&lt;/strong&gt; 作为示例。在 &lt;strong&gt;MainWindow.xaml.cs&lt;/strong&gt; 中尝试使用&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public partial class MainWindow : Window
{
    public MainWindow()
    {
        InitializeComponent();
    }

    protected override void OnContentRendered(EventArgs e)
    {
        var user = new User { Name = &quot;hippieZhou&quot;, Eamil = &quot;hippiezhou@outlook.com&quot; };
        var json = Newtonsoft.Json.JsonConvert.SerializeObject(user);
        Trace.WriteLine(json);

        base.OnContentRendered(e);
    }
}

public class User
{
    public string Name { get; set; }
    public string Eamil { get; set; }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;编译运行程序，可以正常编译运行和执行。控制台也输出了 User 对象也能正确序列化。&lt;/p&gt;
&lt;h3 id=&quot;使用-portability-analyzer&quot;&gt;使用 Portability Analyzer&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github-production-release-asset-2e65be.s3.amazonaws.com/143935249/438c23fe-9af2-11e8-8344-29573fa77797?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;amp;X-Amz-Credential=AKIAIWNJYAX4CSVEH53A%2F20190406%2Fus-east-1%2Fs3%2Faws4_request&amp;amp;X-Amz-Date=20190406T040612Z&amp;amp;X-Amz-Expires=300&amp;amp;X-Amz-Signature=880d2af4fd3e2697d34e774d1d70f8f6c73286cf4a026c645a5f264d8326bd9a&amp;amp;X-Amz-SignedHeaders=host&amp;amp;actor_id=13598361&amp;amp;response-content-disposition=attachment%3B%20filename%3DPortabilityAnalyzer.zip&amp;amp;response-content-type=application%2Foctet-stream&quot;&gt;.NET Portability Analyzer&lt;/a&gt; 工具是用于检测我们当前的 WPF 程序中使用的所有 API 是否支持迁移到 &lt;strong&gt;DotNetCore 3.0&lt;/strong&gt; 上。运行该工具后如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/749711/201904/749711-20190406121650470-601268427.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击 &lt;strong&gt;Browser&lt;/strong&gt; 按钮，将我们的项目目录加载进来，之后点击 &lt;strong&gt;Analyze&lt;/strong&gt;，等分享完成之后，点击 &lt;strong&gt;Open Report&lt;/strong&gt; 即可查看检测结果，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/749711/201904/749711-20190406121714289-1379097265.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图中，我们可以看到，我们的程序当前的框架为 &lt;strong&gt;.NetFramework 4.7.2&lt;/strong&gt;，当前使用的程序集 在 &lt;strong&gt;DotNetCore 3.0&lt;/strong&gt; 受支持率为 100%，这就表明我们的程序可以无缝迁移到 DotNetCore 上了。&lt;/p&gt;
&lt;h3 id=&quot;迁移-packages.config&quot;&gt;迁移 packages.config&lt;/h3&gt;
&lt;p&gt;如果我们的程序引用了 &lt;strong&gt;NuGet&lt;/strong&gt; 上的包，那么 VS 会为我们创建一个 &lt;em&gt;packages.config&lt;/em&gt;，这个文件在 DotNetCore 中不受支持，所以我们需要将它修改为受支持的类型。&lt;/p&gt;
&lt;p&gt;鼠标右键它，然后点击 &lt;strong&gt;Migrate packages.config to PackageReference&lt;/strong&gt; 即可，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/749711/201904/749711-20190406122601185-484840712.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;迁移-xxx.csproj&quot;&gt;迁移 XXX.csproj&lt;/h3&gt;
&lt;p&gt;这里，我们修改我们示例程序中的 &lt;strong&gt;WpfApp1.csproj&lt;/strong&gt;，在传统的 &lt;em&gt;.csproj&lt;/em&gt; 中会有一大堆配置，这些配置方式在 &lt;strong&gt;DotNetCore&lt;/strong&gt; 中同样不适用了。因此，我们需要将我们的内容修改一下，如下所示：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk.WindowsDesktop&quot;&amp;gt;

  &amp;lt;PropertyGroup&amp;gt;
    &amp;lt;OutputType&amp;gt;WinExe&amp;lt;/OutputType&amp;gt;
    &amp;lt;TargetFramework&amp;gt;netcoreapp3.0&amp;lt;/TargetFramework&amp;gt;
    &amp;lt;UseWPF&amp;gt;true&amp;lt;/UseWPF&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;

  &amp;lt;ItemGroup&amp;gt;
    &amp;lt;PackageReference Include=&quot;Newtonsoft.Json&quot; Version=&quot;12.0.1&quot; /&amp;gt;
  &amp;lt;/ItemGroup&amp;gt;

&amp;lt;/Project&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重新加载项目后，会如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/749711/201904/749711-20190406123459636-1646515318.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接着，我们需要删除掉项目中的 &lt;strong&gt;Properties&lt;/strong&gt;，操作完毕后尝试重新编译运行，如果不出意外的话，应该是可以正常执行的。&lt;/p&gt;
&lt;p&gt;最后，我们可以对比一下这种迁移后的项目结构和直接通过 DotNetCore 创建的项目结构之间的差别，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/749711/201904/749711-20190406124519221-1220176088.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;需要补充的一点是，目前在 VS2019 中创建 DotNetCore 3.0 的 WPF 项目时， XAML 的设计视图还是不可用的状态，所以这个需要注意一下。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DotNetCore&lt;/strong&gt; 是未来发展的趋势，由于目前还是预览版，所以我们可以先试着做一些技术储备，等待正式版出来后，我们就可以很快的迁移过来。&lt;/p&gt;
&lt;h2 id=&quot;相关参考&quot;&gt;相关参考&lt;/h2&gt;
</description>
<pubDate>Wed, 10 Apr 2019 23:49:00 +0000</pubDate>
<dc:creator>hippieZhou</dc:creator>
<og:description>介绍 由于历史原因，基于 Windows 平台存在着大量的基于 .NetFramework 开发的 WPF 和 WinForm 相关程序，如果将这些程序全部基于 DotNetCore 3.0 重写一遍</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hippieZhou/p/10661181.html</dc:identifier>
</item>
<item>
<title>Redis集群方案总结 - banananana</title>
<link>http://www.cnblogs.com/George1994/p/10687376.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/George1994/p/10687376.html</guid>
<description>&lt;p cid=&quot;n4&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;目前，Redis中目前集群有以下几种方案：&lt;/span&gt;&lt;/p&gt;
&lt;ul cid=&quot;n84&quot; mdtype=&quot;list&quot; data-mark=&quot;*&quot;&gt;&lt;li cid=&quot;n86&quot; mdtype=&quot;list_item&quot;&gt;
&lt;p cid=&quot;n87&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;主从复制&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li cid=&quot;n90&quot; mdtype=&quot;list_item&quot;&gt;
&lt;p cid=&quot;n88&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;哨兵模式&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li cid=&quot;n93&quot; mdtype=&quot;list_item&quot;&gt;
&lt;p cid=&quot;n91&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;redis cluster&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li cid=&quot;n105&quot; mdtype=&quot;list_item&quot;&gt;
&lt;p cid=&quot;n103&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;代理&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li cid=&quot;n96&quot; mdtype=&quot;list_item&quot;&gt;
&lt;p cid=&quot;n94&quot; mdtype=&quot;paragraph&quot; md-p=&quot;&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;codis&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li cid=&quot;n108&quot; mdtype=&quot;list_item&quot;&gt;
&lt;p cid=&quot;n106&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;客户端分片&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p cid=&quot;n115&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;因为目前使用大范围使用就是Codis方案，因此重点会放在理解Codis方案，其余方案只会简单介绍。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span md-inline=&quot;plain&quot;&gt;Codis&lt;/span&gt;&lt;/h2&gt;

&lt;p cid=&quot;n160&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Codis是豌豆荚公司开发的一个分布式Redis服务，对于上层调用方来说是没有感知的，可以将它是无限内存的Redis服务，有动态扩容和缩容的能力，增减Redis实例对调用方完全透明，不需要重启服务，不需要担心内存的问题；&lt;/span&gt;&lt;/p&gt;
&lt;p cid=&quot;n172&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Codis是基于proxy-base，也就是会以一个代理的身份接收请求并且使用一致性哈希算法，将请求转发到具体的redis实例，并且一个codis-group采用主从方式，包含一个master节点和多个slave节点，如果master节点出现了问题，那么一个group中的slave节点会通过选举算法推选出新的master节点，并且通知到proxy。&lt;/span&gt;&lt;/p&gt;

&lt;p cid=&quot;n158&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;https://i.loli.net/2019/04/11/5cae5cbb2dc6b.png&quot;&gt;&lt;img referrerpolicy=&quot;no-referrer&quot; src=&quot;https://i.loli.net/2019/04/11/5cae5cbb2dc6b.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p cid=&quot;n156&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Codis由几个部分组成：&lt;/span&gt;&lt;/p&gt;
&lt;ul cid=&quot;n129&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot; readability=&quot;6&quot;&gt;&lt;li cid=&quot;n130&quot; mdtype=&quot;list_item&quot; readability=&quot;0&quot;&gt;
&lt;p cid=&quot;n131&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Codis Proxy (codis-proxy)，处理客户端请求，支持Redis协议，因此客户端访问Codis Proxy跟访问原生Redis没有什么区别；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li cid=&quot;n132&quot; mdtype=&quot;list_item&quot; readability=&quot;2&quot;&gt;
&lt;p cid=&quot;n133&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Codis Dashboard (codis-config)，Codis 的管理工具，支持添加/删除 Redis 节点、添加/删除 Proxy 节点，发起数据迁移等操作。codis-config 本身还自带了一个 http server，会启动一个 dashboard，用户可以直接在浏览器上观察 Codis 集群的运行状态；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li cid=&quot;n134&quot; mdtype=&quot;list_item&quot; readability=&quot;0&quot;&gt;
&lt;p cid=&quot;n135&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Codis Redis (codis-server)，Codis 项目维护的一个 Redis 分支，基于 2.8.21 开发，加入了 slot 的支持和原子的数据迁移指令；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li cid=&quot;n136&quot; mdtype=&quot;list_item&quot; readability=&quot;0&quot;&gt;
&lt;p cid=&quot;n137&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;ZooKeeper/Etcd，Codis 依赖 ZooKeeper 来存放数据路由表和 codis-proxy 节点的元信息，codis-config 发起的命令都会通过 ZooKeeper 同步到各个存活的 codis-proxy；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li cid=&quot;n141&quot; mdtype=&quot;list_item&quot; readability=&quot;-1&quot;&gt;
&lt;p cid=&quot;n139&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Codis FE，集群管理界面；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li cid=&quot;n144&quot; mdtype=&quot;list_item&quot; readability=&quot;-1&quot;&gt;
&lt;p cid=&quot;n142&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Storage，为集群状态提供外部存储；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;span md-inline=&quot;plain&quot;&gt;其余方案&lt;/span&gt;&lt;/h2&gt;

&lt;h3&gt;&lt;span md-inline=&quot;plain&quot;&gt;Redis cluster&lt;/span&gt;&lt;/h3&gt;
&lt;p cid=&quot;n180&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;这是Redis官方提供的分布式Redis解决方案，cluster使用一致性哈希算法，每个槽对应一个node节点，将请求转发到具体的redis实例，同样的，为了集群的可访问性，每个node节点配置成主从结构，同样会利用选举算法推出一个主节点；&lt;/span&gt;&lt;/p&gt;

&lt;p cid=&quot;n195&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;https://i.loli.net/2019/04/11/5cae6dc25792a.png&quot;&gt;&lt;img referrerpolicy=&quot;no-referrer&quot; src=&quot;https://i.loli.net/2019/04/11/5cae6dc25792a.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p cid=&quot;n197&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;cluster不足点在于：&lt;/span&gt;&lt;/p&gt;
&lt;ul cid=&quot;n191&quot; mdtype=&quot;list&quot; data-mark=&quot;*&quot; readability=&quot;1&quot;&gt;&lt;li cid=&quot;n193&quot; mdtype=&quot;list_item&quot; readability=&quot;-1&quot;&gt;
&lt;p cid=&quot;n194&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;没有提供图像管理工具，对于运维来说比较复杂；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li cid=&quot;n203&quot; mdtype=&quot;list_item&quot; readability=&quot;0&quot;&gt;
&lt;p cid=&quot;n201&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;命令支持不够完整，比如批量命令mget不完整，不支持事务，不支持数据库切换；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li cid=&quot;n206&quot; mdtype=&quot;list_item&quot; readability=&quot;0&quot;&gt;
&lt;p cid=&quot;n204&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;集群管理和数据存储耦合，也就是说如果集群有bug，需要升级整个Redis版本；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote cid=&quot;n147&quot; mdtype=&quot;blockquote&quot; readability=&quot;0.083333333333334&quot;&gt;
&lt;p cid=&quot;n207&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;link&quot;&gt;&lt;a spellcheck=&quot;false&quot; href=&quot;https://github.com/CodisLabs/codis/blob/release3.2/doc/FAQ_zh.md&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;github&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p cid=&quot;n208&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;link&quot;&gt;&lt;a spellcheck=&quot;false&quot; href=&quot;https://dbaplus.cn/news-21-270-1.html&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;细说分布式Redis架构设计和那些踩过的坑&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 10 Apr 2019 22:34:00 +0000</pubDate>
<dc:creator>banananana</dc:creator>
<og:description>Redis集群方案总结 Redis集群方案总结Codis其余方案Redis cluster Redis集群方案总结Codis其余方案Redis cluster 目前，Redis中目前集群有以下几种方案</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/George1994/p/10687376.html</dc:identifier>
</item>
<item>
<title>软件项目外包给自由职业者或小型团队的注意事项（一个软件开发从业者的敬告和业内黑幕披露） - liulun</title>
<link>http://www.cnblogs.com/liulun/p/10686885.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liulun/p/10686885.html</guid>
<description>&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;你应该是一个真正的“甲方”&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;你如果是个二道贩子，&lt;br/&gt;或者你要做的项目是为了应付投资人，&lt;br/&gt;那么这篇文章里谈的很多事情，你都大可不必在意，&lt;br/&gt;甚至现在就离开这个页面，亦无不可。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;你的项目应该是一个真正的“项目”&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;你如果想搞个互联网平台自己运营，&lt;br/&gt;那么建议你还是找个技术合伙人，&lt;br/&gt;或者招聘个技术主管，&lt;br/&gt;因为这类项目是需要持续迭代的，&lt;br/&gt;要有人盯着&lt;br/&gt;很难保证项目验收后，你有新需求的时候，人家正好也有空，而且还愿意给你做；&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;猪八戒，一品威客这些平台背后的事情&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;1）企业服务商的劣势和优势一样明显&lt;br/&gt;你找企业接你的项目，你可以跟他签订合同，可以开正规的对公发票，&lt;br/&gt;但同时它也屏蔽了你对开发者的了解，&lt;br/&gt;它很可能安排了一个北大青鸟刚毕业的小伙子做你的项目，&lt;br/&gt;而且有可能做着做着中途还换了一个，&lt;br/&gt;甚至他是否分包给了其他自由职业者，你也不知道；&lt;br/&gt;现实中这种现象还是非常多的！&lt;br/&gt;&lt;img id=&quot;img1554918680095&quot; src=&quot;https://img2018.cnblogs.com/other/28932/201904/28932-20190411023201697-294363340.png&quot; alt=&quot;&quot; width=&quot;248&quot; height=&quot;177&quot;/&gt;&lt;br/&gt;2）派单特权&lt;br/&gt;对于付费的金牌服务商企业，&lt;br/&gt;这些威客平台会向他们承诺一年至少签多少单子，&lt;br/&gt;平台会把优质项目推荐给这些企业，&lt;br/&gt;这些企业是好企业吗？&lt;br/&gt;威客平台不关心的！！！&lt;br/&gt;也就是说，你作为甲方，在这些平台上发了一个项目，&lt;br/&gt;真正的威客还没看到这个项目（好多时候根本就没资格看到）&lt;br/&gt;就被这些平台推荐给他的付费服务商了&lt;br/&gt;这就是派单特权。&lt;br/&gt;这是一个恶性循环，&lt;br/&gt;金牌服务商不太关心这个项目要不要做好，&lt;br/&gt;他关心的是这个项目做的够不够快，&lt;br/&gt;威客平台也不关心这个项目要不要做好，&lt;br/&gt;他关心的是有没有更多的金牌服务商，或者要不要推出更高级的工场会员等等&lt;br/&gt;3）项目抽成&lt;br/&gt;如果你相信“猪八戒”这个平台，要在平台上完成交易，&lt;br/&gt;那就意味着开发者要拿出项目款的10%到20%给这个平台，&lt;br/&gt;这个钱你觉得是开发者出的吗？&lt;br/&gt;他肯定会给你报在预算里的。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;你不懂技术，如何判断一个开发人员的技术是否过关；&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;1）问有没有技术博客&lt;br/&gt;如果有，看看写了多少篇文章，持续写了多久，文章下面的评论多不多，文章点赞的人多不多；&lt;br/&gt;一般持续写三年以上技术博客的人，算靠谱的了；&lt;br/&gt;2）问有没有开源项目&lt;br/&gt;如果有，看看这个开源项目有多少个star（见下图）；&lt;br/&gt;&lt;img id=&quot;img1554904743488&quot; src=&quot;https://img2018.cnblogs.com/other/28932/201904/28932-20190410231111845-417565080.png&quot; alt=&quot;&quot; width=&quot;295&quot; height=&quot;34&quot;/&gt;&lt;br/&gt;一般能上500个star的，算非常不错的开源项目了；&lt;br/&gt;3）问有没有作品&lt;br/&gt;如果是在线的互联网产品，那么让他截图给你看用户访问统计数据（见下图）&lt;br/&gt;&lt;img id=&quot;img1554905077181&quot; src=&quot;https://img2018.cnblogs.com/other/28932/201904/28932-20190410231111846-43230656.png&quot; alt=&quot;&quot; width=&quot;226&quot; height=&quot;100&quot;/&gt;&lt;br/&gt;个人的项目的话，日访客数能上1000，算不错的了；&lt;br/&gt;如果作品是企业应用，那么你很有可能看不到东西，&lt;br/&gt;这很正常，此时你应该跟他聊聊，他的项目中最复杂的业务是什么，复杂在哪里了&lt;br/&gt;看能不能说个所以然出来；&lt;br/&gt;最最关键的是，所有这些东西，一定要是他自己的，&lt;br/&gt;有些人，只是打打杂，也说产品是自己做的，可恶至极！&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;如何清晰的沟通需求&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;“我要做一个类似微信的APP，你看大概要多少钱”&lt;br/&gt;“我要做一个类似京东的网站，你看多久能搞好”&lt;br/&gt;这是非常外行的沟通方式，&lt;br/&gt;有经验的开发者甚至不太愿意跟这样的甲方谈项目，&lt;br/&gt;太浪费时间了，&lt;br/&gt;你如果真要做个类似微信的APP&lt;br/&gt;那么你应该把微信的所有功能列出来，做到excel表里，&lt;br/&gt;这时你会发现，微信公众号和微信钱包，对于你来说没啥意义！&lt;br/&gt;把没意义的剔除掉之后，&lt;br/&gt;再拿着这个表格去跟开发者沟通，&lt;br/&gt;如果你不愿意做这个功能梳理的工作，打算让开发者来替你做，&lt;br/&gt;“我打算做个类似微信的APP，你能不能理个功能清单出来，咱们再商量报价”&lt;br/&gt;那么你很有可能被当成骗方案的人了&lt;br/&gt;好的办法是，找个空的时间，约着一起吃个饭，先口头聊一下，&lt;br/&gt;建立好关系，表达出诚意，后面的事就好谈了；&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;如何判断报价是否合理&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;按前面一个小节说的，你把项目的模块和功能都理清楚了，&lt;br/&gt;做一个类似这样的表格，工时那一栏，你让他来填写&lt;br/&gt;&lt;img id=&quot;img1554905471973&quot; src=&quot;https://img2018.cnblogs.com/other/28932/201904/28932-20190410231111849-3380863.png&quot; alt=&quot;&quot; width=&quot;236&quot; height=&quot;147&quot;/&gt;&lt;br/&gt;写好之后，你把工时汇总一下，比如说一共要60个人日（人日就是一个人干一天的工作量）；&lt;br/&gt;目前一线城市，找人力外包公司，包一个3年左右开发经验的人，大概是2000块左右一个人日，&lt;br/&gt;扣掉外包公司赚的那一笔钱，你按1500一个人日算，那么这个项目的成本就是9万块；&lt;br/&gt;很多不靠谱的开发者虚报工时，把工时当工期看待，&lt;br/&gt;他白天上班，就只夜里和节假日给你干活儿，也把一天算一个人日&lt;br/&gt;在跟他谈项目之前，你应该先了解一下他的工作状态，&lt;br/&gt;如果他现在在上班，给你报了60个人日，项目交付也是60天后，&lt;br/&gt;那么他报的这个工时就非常不靠谱了；&lt;br/&gt;除此之外，你还可以多找几个人报价，对比衡量一下；&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;低价意味着低质&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;便宜没好货在这个领域非常非常明显，远超你的想象，&lt;br/&gt;假设你要做一个小型的电商系统&lt;br/&gt;优秀的开发者会帮你考虑好并发购买的问题（同一时间多个顾客购买同一个库存为1的商品）&lt;br/&gt;不靠谱的开发者不会为你做这些工作，&lt;br/&gt;这可能导致你的库存变成负数（更可怖的是溢出成一个超级大的数字），&lt;br/&gt;系统里的数据和实际产生的数据对不上；&lt;br/&gt;还有很多类似的问题，&lt;br/&gt;比如：该释放的资源没有释放，会导致你的系统时不时的卡死，&lt;br/&gt;软件开发是一个经验性的学科，&lt;br/&gt;踩的坑多了，自然知道那个地方会有坑，哪个地方是坦途；&lt;br/&gt;外包项目前问问开发者的履历，是非常有必要的，&lt;br/&gt;找一个经验丰富的开发者，比找一个还没毕业的大学生要好的多；&lt;br/&gt;报价过低的开发者，值得警惕；&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;如何约定付款方式&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;按照正规做项目的逻辑：&lt;br/&gt;订金30%，交付30%，验收30%，上线10%；&lt;br/&gt;这是三三三一的付款方式；&lt;br/&gt;也可以是二三三二；&lt;br/&gt;外包给自由职业者，就可以更自由一些，&lt;br/&gt;初次合作，他怕白忙活一场，一般会向你收订金的，&lt;br/&gt;可多可少，付他项目总金额的一成也没问题；&lt;br/&gt;做完就交付给你验收，验收通过，他们就期望收到尾款；&lt;br/&gt;你压他一笔钱等着产品上线，他们往往不乐意；&lt;br/&gt;因为他们不知道你要做多久的上线筹备，中间会不会出幺蛾子；&lt;br/&gt;这时候如果验收把关牢一些，一般也没问题；&lt;br/&gt;或者直接做完就上线，由你的用户帮着验收，也没问题；&lt;br/&gt;（上线之前，自己一定要测一遍，不要相信开发者的自测能力，就算是老鸟接的活儿，也不能相信）；&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;如何验收&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;你自己有专业的测试团队，那么你可以直接问你的测试主管就好了；&lt;br/&gt;没有，就要考虑怎么测试他交付给你的东西；&lt;br/&gt;1）功能性测试，&lt;br/&gt;这你一定要亲手做；&lt;br/&gt;所有的细节都做到，所有可能有关联的业务逻辑都试一遍&lt;br/&gt;看看功能和数据是不是按你预期的方式呈现出来的；&lt;br/&gt;2）性能测试&lt;br/&gt;一般这里不太会出问题&lt;br/&gt;不过你也可以试试，把程序部署在一台配置差一点的服务器上，看程序是否能正常运转，&lt;br/&gt;3）压力测试&lt;br/&gt;多发动几个朋友，在同一段时间，测测所有的功能，看是否正常，&lt;br/&gt;有些问题，往往一个人测的时候不会暴露，多个人一起测才会暴露！&lt;br/&gt;（也只能做这么多了）&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;违约的风险&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;系统验收之后，还有一笔钱没付，反正也没签合同，不付算了；&lt;br/&gt;我劝你千万不要往这方面想，&lt;br/&gt;代码是他写的，他随便留一个后门，&lt;br/&gt;轻则导致你系统运行不了，&lt;br/&gt;重则格你服务器的盘，&lt;br/&gt;而且写这样的后门，非常非常简单，你还很难查的到，&lt;br/&gt;无论是公司，还是自由职业者，八成都会这么干，&lt;br/&gt;你不付他尾款，他跟你走法律途径解决问题，多麻烦呀，&lt;br/&gt;留个后门，十几行代码的事！&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;是否应该与开发人员保持融洽的关系&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我觉得甲方和开发者，能像朋友之间的关系最好了&lt;br/&gt;摆着甲方的架子，鼻孔朝天，颐指气使，&lt;br/&gt;这是非常不理智的，&lt;br/&gt;一个软件经常会有鸡毛蒜皮的事情冒出来，&lt;br/&gt;改个字，换个颜色之类的，&lt;br/&gt;如果是你朋友做的，&lt;br/&gt;可能用不了一分钟就给你改好了，&lt;br/&gt;而且还不收费，&lt;br/&gt;如果是你的“乙方”做的，那他很有可能“正在忙，没工夫改”&lt;br/&gt;或者直接就是“抱歉，这个改不了”。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;大型项目以何种方式外包&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;1）大型项目尽量拆解成小项目外包&lt;br/&gt;比如说拆解成多个模块，一个模块一个模块的外包，&lt;br/&gt;这样能快速的看到反馈，有什么问题也能及时纠偏，&lt;br/&gt;需要注意的就是，要搞清楚模块和模块之间的关系，&lt;br/&gt;如果你搞不清楚，&lt;br/&gt;那么就让开发者给你搞，&lt;br/&gt;把所有的业务跟他讲明白&lt;br/&gt;让他拆解，告诉他，拆解完，咱们一个一个做，一个一个结算；&lt;br/&gt;2）跟开发者直接谈人力外包&lt;br/&gt;你去人力外包公司找个人，&lt;br/&gt;不如直接找个自由职业者，&lt;br/&gt;跟他谈工时费用和工期&lt;br/&gt;如果能驻场开发，那就太好了。&lt;br/&gt;3）走招投标流程一样有风险&lt;br/&gt;那时候你就要关心“围标”、“陪标”、“串标”这些问题了&lt;/p&gt;
&lt;p&gt;看了这篇文章，你是不是怕了？&lt;br/&gt;别担心，一个优秀的开发者，是非常在意自己的名声的；&lt;br/&gt;他重视老客户，希望能从老客户手里接更多的活儿，&lt;br/&gt;希望老客户帮他介绍新客户&lt;br/&gt;而且做开发的人当中，本分、厚道的人站绝大多数；&lt;br/&gt;相对于你事业上的其他风险，&lt;br/&gt;这个领域的风险，根本不值一提！&lt;br/&gt;愿这篇文章能帮你找到合适的人...&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/liulun/p/10686885.html&quot;&gt;本文&lt;/a&gt;是是用&lt;a href=&quot;https://www.cnblogs.com/liulun/&quot;&gt;我&lt;/a&gt;开发的&lt;a href=&quot;https://github.com/xland/xiangxuema&quot;&gt;“想学吗”个人知识管理工具&lt;/a&gt;编辑完成；&lt;br/&gt;转载请务必保持文章现状，并保留本行与上一行，谢谢。&lt;/p&gt;
</description>
<pubDate>Wed, 10 Apr 2019 18:41:00 +0000</pubDate>
<dc:creator>liulun</dc:creator>
<og:description>你应该是一个真正的“甲方” 你如果是个二道贩子， 或者你要做的项目是为了应付投资人， 那么这篇文章里谈的很多事情，你都大可不必在意， 甚至现在就离开这个页面，亦无不可。 你的项目应该是一个真正的“项目</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liulun/p/10686885.html</dc:identifier>
</item>
<item>
<title>微信小程序开发笔记 - 追逐时光</title>
<link>http://www.cnblogs.com/Can-daydayup/p/10687315.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Can-daydayup/p/10687315.html</guid>
<description>&lt;h2&gt;前言：&lt;/h2&gt;
&lt;p&gt;　　因为前段时间一直在做关于微信小程序方面的项目，作为一名后端的攻城狮而言做一些简单的前端页面数据操作和管理还是比较容易快上手的，当然前提是要理解微信小程序的基本语法和请求原理。该篇博客主要记录的是在编写微信小程序时使用比较频繁，实用的一些方法和一些基本原理的概括。个人觉得把这些方法掌握好了，开发一个小型的微信小程序那是绰绰有余的啦。当然我这里并没有深入的对一些语言进行详细的概述，纯属个人总结，假如需要详细的微信小程序语法文档请移驾到：[&lt;a href=&quot;https://developers.weixin.qq.com/miniprogram/dev/&quot; target=&quot;_blank&quot;&gt;https://developers.weixin.qq.com/miniprogram/dev/&lt;/a&gt;]&lt;/p&gt;
&lt;h2&gt;知识点：&lt;/h2&gt;
&lt;h3&gt;一、向后端请求数据方法：&lt;/h3&gt;
&lt;p&gt;wx.request({})&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;wx.request({
url: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://xxx.com/api/GetData&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里填写你的接口路径,注意一定要在微信小程序中授权过得https数字加密域名&lt;/span&gt;
method: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;请求方式&lt;/span&gt;
header: { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;接口口返回的数据是什么类型，这里就体现了微信小程序的强大，直接给你解析数据，再也不用去寻找各种方法去解析json，xml等数据了&lt;/span&gt;
&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Content-Type&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;application/json&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
},
data: {&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;请求数据&lt;/span&gt;
name: &lt;span&gt;''&lt;/span&gt;&lt;span&gt;
},
success: function (res) {
 &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (res.statusCode == &lt;span&gt;200&lt;/span&gt;) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;statusCode==200表示请求成功，有数据返回
 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里就是请求成功后，进行一些函数操作&lt;/span&gt;
 console.log(res.data)&lt;span&gt;///&lt;/span&gt;&lt;span&gt;/ 服务器回包内容&lt;/span&gt;
&lt;span&gt;console.warn(res)
}},
fail: function (res) {
wx.showToast({ title: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;系统错误&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; })
},
complete: () &lt;/span&gt;=&amp;gt;&lt;span&gt; {
wx.hideLoading();
} &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;complete接口执行后的回调函数，无论成功失败都会调用&lt;/span&gt;
});
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt; 二、通过凭证进而换取用户登录态信息：&lt;/h3&gt;
&lt;p&gt;wx.login({})&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;wx.login({
success(res) {
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (res.code) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 发起网络请求&lt;/span&gt;
&lt;span&gt;wx.request({
url: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://test.com/onLogin&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
data: {
 code: res.code
},
method: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;post&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
header:{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Content-Type&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;application/json&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;},
success:function(res)
{
 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到用户openid&lt;/span&gt;
&lt;span&gt;console.log(res.openid);
}
})
} &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
console.log(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;登录失败！&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; +&lt;span&gt; res.errMsg)
}
}
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;三、小程序中三种变量声明方式（var,let,const）: &lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
var：全局变量
let： 块级变量，又称之为局部变量
const：块级作用域，当时它属于不变的常量
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;四、小程序应用生命周期：【详细概括：&lt;a href=&quot;https://www.jianshu.com/p/0078507e14d3&quot; target=&quot;_blank&quot;&gt;https://www.jianshu.com/p/0078507e14d3&lt;/a&gt;】&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1336199/201904/1336199-20190411012304011-1600426752.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
小程序初始化完成后，页面首次加载触发onLoad，只会触发一次。
当小程序进入到后台，先执行页面onHide方法再执行应用onHide方法。
当小程序从后台进入到前台，先执行应用onShow方法再执行页面onShow方法。
&lt;br/&gt;data Object 页面的初始数据 &lt;br/&gt;onLoad Function 生命周期函数--监听页面加载，首次进入会执行此方法进行数据加载，一个页面只会加载一次 &lt;br/&gt;onReady Function 生命周期函数--监听页面初次渲染完成 &lt;br/&gt;onShow Function 生命周期函数--监听页面显示，数据显示，每次打开页面都会加载一次 &lt;br/&gt;onHide Function 生命周期函数--监听页面隐藏 &lt;br/&gt;onUnload Function 生命周期函数--监听页面卸载
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;五、模块引入方式（require或者是import):&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用 import 或者 require 引入模块 &lt;/span&gt;
&lt;span&gt;1&lt;/span&gt;.import util &lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;../../../util/util.js&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;.&lt;span&gt;var&lt;/span&gt; Promise = require(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;../../../plugin/promise.js&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)   
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;六、对应方法中通过定义var that=this;来代表当前方法的上下文对象：&lt;/h3&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;strong&gt;为什么要这样做呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在javascript语言中，this代表着当前的对象，而this在微信小程序中随着执行的上下文随时会变化。所以当在一个方法里面直接使用this的话会找不到这个方法中所指定的对象值，因为对应的上下文中的data值已经改变了。自然就没有了data属性，也没有了data.itemLists属性了。解决的办法就是复制一份当前的对象。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; that=&lt;span&gt;this&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把this对象复制到临时变量that.&lt;/span&gt;
&lt;span&gt;
console.log(that.data.itemLists[res.tapIndex]);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用that.data 属性&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;七、小程序缓存的那些事:&lt;/h3&gt;
&lt;p&gt;1.wx.setStorageSync(string key, any data)&lt;/p&gt;
&lt;p&gt;2.wx.setStorage(Object object)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//本地缓存&lt;/span&gt;
&lt;span&gt;wx.setStorage({
key: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cartResult&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
data: cartResult
})

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;小程序本地缓存&lt;/span&gt;
wx.setStorageSync(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; key, any data)

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过key获取缓存中的对象值：&lt;/span&gt;
&lt;span&gt; wx.getStorage({
      key: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;cartResult&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
      success: res &lt;/span&gt;=&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (res.data.length &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;){
          &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setData({
            cartResult: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
          });}
      },
    })


&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;清空对应缓存：&lt;/span&gt;
wx.removeStorageSync(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;cartResult&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;清空小程序缓存&lt;/span&gt;
wx.clearStorageSync()
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;八、微信小程序列表渲染：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
wx：&lt;span&gt;for&lt;/span&gt; 控制属性绑定一个数组，&lt;br/&gt;wx:&lt;span&gt;for&lt;/span&gt;-&lt;span&gt;item :当前数组变量名
wx:&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;-&lt;span&gt;index 当前数组下标的一个变量名
wx:key:如果列表中项目的位置会动态改变或者有新的项目添加到列表中，并且希望列表中的项目保持自己的特征和状态（如 &lt;/span&gt;&amp;lt;input/&amp;gt; &lt;br/&gt;中的输入内容，&amp;lt;&lt;span&gt;switch&lt;/span&gt;/&amp;gt; 的选中状态），需要使用 wx:key 来指定列表中项目的唯一的标识符。
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;微信wxml列表循环：&lt;/span&gt;
&amp;lt;view wx:&lt;span&gt;for&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{{items}}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; wx:&lt;span&gt;for&lt;/span&gt;-index=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;index&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; wx:&lt;span&gt;for&lt;/span&gt;-item=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;
{{index&lt;/span&gt;+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;}}、{{item.title}}
&lt;/span&gt;&amp;lt;/view&amp;gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt;js中&lt;/span&gt;&lt;span&gt;
page({
data:{
items:[{title:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;小明&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;},{title:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;小红&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}]
}
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;九、小程序js中的数组 forEach 数据遍历：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;data:{
objIndex:[{name:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;小明&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;},{name:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;小红&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;},{name:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;小姚&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}]
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义容器&lt;/span&gt;
let ContentArray=&lt;span&gt;[];
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;索引数据拼接&lt;/span&gt;
&lt;span&gt;objIndex.forEach(function(item, index) {

ContentArray.push({name:item})

});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;十、小程序js中的数组 for 数据遍历：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
let dList=&lt;span&gt;res.data.list;
let array&lt;/span&gt;=&lt;span&gt;[];
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; dList)
{
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数组拼接&lt;/span&gt;
&lt;span&gt;array.push({
id:dList[i].Id,
menu_logo: dList[i].CoverImgId,
menu_name: dList[i].CategoryName,
price: dList[i].SalesPrice
});
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;十一、微信小程序模块化(向外暴露接口)：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;第一种方式：
fucntion sayGoodbye()
{
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;相应逻辑&lt;/span&gt;
&lt;span&gt;}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;向外暴露&lt;/span&gt;
&lt;span&gt;1&lt;/span&gt;&lt;span&gt;.module.exports{
 sayGoodbye:sayGoodbye 
}
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;.exports.sayHello=&lt;span&gt;sayHello;

第二种方式：
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;直接全部模块化&lt;/span&gt;
export &lt;span&gt;default&lt;/span&gt;=&lt;span&gt;{
function sayHello(name) {
  console.log(`Hello ${name} &lt;/span&gt;!&lt;span&gt;`)
}
function sayGoodbye(name) {
  console.log(`Goodbye ${name} &lt;/span&gt;!&lt;span&gt;`)
}
        
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;十二、小程序事件方法【bindtab,catchtap,bindconfirm,bindfocus,bindblur,bindchange,bindinput】：&lt;/h3&gt;
&lt;h4&gt;首先bindtab（相当于js中的onclick 点击事件）和catchtap的区别：&lt;/h4&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;我们都知道bindtap和catchtap都是当用户点击该组件的时候会在该页面对应的Page中找到相应的事件处理函数。但是bind事件绑定不会阻止冒泡事件向上冒泡，catch事件绑定可以阻止冒泡事件向上冒泡。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&amp;lt;view id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;outer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; bindtap=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;handleTap1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;
outer view
&lt;/span&gt;&amp;lt;view id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;middle&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; catchtap=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;handleTap2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;
middle view
&lt;/span&gt;&amp;lt;view id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;inner&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; bindtap=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;handleTap3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;
inner view
&lt;/span&gt;&amp;lt;/view&amp;gt;
&amp;lt;/view&amp;gt;&lt;span&gt;
 
Page({
    handleTap1:function(&lt;/span&gt;&lt;span&gt;event&lt;/span&gt;){  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;点击输出outer view bindtap&lt;/span&gt;
      console.log(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;outer view bindtap&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    },
    handleTap2: function (&lt;/span&gt;&lt;span&gt;event&lt;/span&gt;) {  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;点击输出middle view&lt;/span&gt;
      console.log(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;middle view catchtap&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    },
    handleTap3: function (&lt;/span&gt;&lt;span&gt;event&lt;/span&gt;) {  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;点击输出inner view bindtap  middle view catchtap&lt;/span&gt;
      console.log(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;inner view bindtap&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    },
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
bindconfirm 是点击小键盘上的搜索按钮就触发要执行的方法
bindfocus: 指当我们的输入框获得焦点时触发，也就是鼠标或者手指点击到输入框时。
bindblur: 指输入框失去焦点是触发，也就是当我们敲击回车或手机上的完成又或者是点击屏幕上的空白处时触发。 
bindchange: 这个事件官方文档中没有写，它的效果和bindblur一样，至于看名字我们可能觉得bindchange在输入框中的内容不改变时不会触发，但是亲测即使内容不改变，bindchange事件也一样会触发。 
bindinput: 每输入一个字符都会进行一次检索，通常用于实时检索。但是这种方法对数据库的要求较高。
在bindblur或bindchange事件中我们通过event.detail.value获得swiper中的事件，左右滑动的时候，滑动结束会出发这个事件。
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;十三、小程序数组的那些事（push，push.apply,concat）：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
push 遇到数组参数时，把整个数组参数作为一个元素；
concat 则是拆开数组参数，一个元素一个元素地加进去。  
push 直接改变当前数组；concat 不改变当前数组。
//在原数组的同时，添加增加一个新的数据，如js中的append
goods.push.apply(goods, data); //将页面上面的数组和最新获取到的数组进行合并
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;十四、通过bindtab点击事件，传值：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;其中data-id为自定义属性值，可以按照自己的参数名称进行定义&lt;/span&gt;

&amp;lt;button bindtab=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;getcoupons&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; data-id=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;{{id}}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; data-index=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;{{index}}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;领取&amp;lt;/button&amp;gt;

 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;js中:&lt;/span&gt;
&lt;span&gt; getcoupons(even){
 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;直接看输出&lt;/span&gt;
&lt;span&gt; console.log(even);
 &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; id=&lt;span&gt;even.currentarget.id;
 或者even.target.dataset.id
 }      &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;十五、超链接传值：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;navigator url=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/page/index?id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;调转&amp;lt;/navigator&amp;gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt;页面监听，数据加载事件&lt;/span&gt;
&lt;span&gt;onload:function(options)
{
    console.log(options.id)
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;十六、小程序页面调转的那些事：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
wx.switchTab 跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面
wx.reLaunch 关闭所有页面，打开到应用内的某个页面
wx.redirectTo 关闭当前页面，跳转到应用内的某个页面
wx.navigateTo 保留当前页面，跳转到应用内的某个页面
wx.navigateBack 关闭当前页面，返回上一页面或多级页面
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;十七、小程序自定义调转地址和背景图片的转发，分享：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  /*&lt;/span&gt;&lt;span&gt;*
   * 用户单击右上角分享
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  onShareAppMessage: function() {
    let title &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;你好&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;标题&lt;/span&gt;
    let path = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pages/home/home?fartherPhone=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+app.globalData.Phone; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;页面路径&lt;/span&gt;
    let imageUrl =&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://ad.yoweller.com/images/webimg/banner.jpg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;自定义图片地址&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
      title: title,
      path: path,
      imageUrl: imageUrl
    }
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;十八、小程序三目运算：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;view &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;set-default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;icon &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;icon&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{{item.isDefault == true ? 'success_circle' : 'circle'}}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;
    &amp;lt;text&amp;gt;默认地址&amp;lt;/text&amp;gt;
&amp;lt;/view&amp;gt;

&amp;lt;text &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;viewpager-title {{current == 0 ? 'area-selected' : ''}}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; bindtap=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;changeCurrent&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; data-current=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;{{provinceName}}&amp;lt;/text&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;十九、小程序常用的弹窗提示：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;loading加载&lt;/span&gt;
&lt;span&gt;wx.showToast({
     title: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;加载中&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
     icon:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;loading&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
     duration:&lt;/span&gt;&lt;span&gt;10000&lt;/span&gt;&lt;span&gt;
)}&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;操作成功弹窗&lt;/span&gt;
&lt;span&gt;wx.showToast({
     title:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;成功&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
     icon:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;success&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
     duration:&lt;/span&gt;&lt;span&gt;2000&lt;/span&gt;&lt;span&gt;
})

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;confirm 提示框&lt;/span&gt;
&lt;span&gt;wx.showModal({
      title: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;提示&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
      content: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;这是一个模态窗口&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
      showCancel:&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭取消按钮&lt;/span&gt;
&lt;span&gt;      success:function(res){
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(res.confirm){
              console.log(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;弹框后点取消&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                console.log(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;弹框后点取消&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
            }
      }
})
  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;二十、微信小程序form表单的那些事：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;form bindsubmit=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;submit&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; bindreset=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;reset&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt; 
&amp;lt;button formtype=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;submit&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;submit&amp;lt;/button&amp;gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;提交&lt;/span&gt;
&amp;lt;button formtype=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;reset&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;reset&amp;lt;/button&amp;gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重置&lt;/span&gt;
&amp;lt;/form&amp;gt;&lt;span&gt;

//首先使用form&lt;/span&gt;-type=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;submit&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;提交表单中的value数据时，需要在表单主键上加上name用作key
page({
submit:function(e)
{
    
}
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;二十一、清空对应Input文本框中的值：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//js&lt;br/&gt;Page({
  data: {
    userInput: &lt;/span&gt;&lt;span&gt;''&lt;/span&gt;&lt;span&gt;,//定义文本框中的值
  },
  clearInput: function () {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setData({
      userInput: &lt;/span&gt;&lt;span&gt;''&lt;/span&gt;&lt;span&gt;
    });
  },&lt;br/&gt;//通过检索input文本框改变事件进行及时赋值
  bindKeyInput: function(e) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setData({
      userInput: e.detail.value
    });
  }
})
&lt;br/&gt;//wxml中
&lt;/span&gt;&amp;lt;input value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{{userInput}}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; bindinput=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bindKeyInput&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/input&amp;gt;
&amp;lt;view bindtap=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;clearInput&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;点击清除输入框&amp;lt;/view&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;总结：&lt;/h2&gt;
&lt;p&gt;　　 其实接触新得技术并不可怕，可怕的是你自己不知道该怎么去认识它。认识一门新语言的第一步是先主动去了解它的一些习性和特点。上面有一部分是来自于比较好的博客和微信小程序API文档，然后我根据自己的想法和心得做了注释和改变让自己加深一遍印象。&lt;/p&gt;
</description>
<pubDate>Wed, 10 Apr 2019 17:47:00 +0000</pubDate>
<dc:creator>追逐时光</dc:creator>
<og:description>前言： 因为前段时间一直在做关于微信小程序方面的项目，作为一名后端的攻城狮而言做一些简单的前端页面数据操作和管理还是比较容易快上手的，当然前提是要理解微信小程序的基本语法和请求原理。该篇博客主要记录的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Can-daydayup/p/10687315.html</dc:identifier>
</item>
<item>
<title>记一次解脱 - 落叶虽美只活一世</title>
<link>http://www.cnblogs.com/NolaLi/p/10685422.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/NolaLi/p/10685422.html</guid>
<description>&lt;p&gt;　　时间：跨越大（2018.12至今2019.04.10）&lt;/p&gt;
&lt;p&gt;　　地点：北京朝阳区某大厦某座某层&lt;/p&gt;
&lt;p&gt;　　人物：ABC等&lt;/p&gt;
&lt;p&gt;　　事情描述：见下文&lt;/p&gt;
&lt;p&gt;　　去年年底手上开发任务已完成，暂无其他开发需求，被安排协助一个项目。看，又有个烂尾楼需要处理！（这里只属日常吐槽，没有任何褒贬含义）。&lt;/p&gt;
&lt;p&gt;　　这个项目背景如同其他项目，上一任离职了。交接给同事A的时候听说是两天就交接完了，被安排去协助说是有两个流程需要自动化处理。看了需求文档，没有想象中难，答应可以做。于是乎，信心满满地要开始干了。&lt;/p&gt;
&lt;p&gt;　　接下来的一个礼拜，先和同事A去上一个项目负责人工位用他的电脑秀一波linux命令，按照他说的上某个服务器操作一些命令。so easy！从开始加入一个对接群后，每天处于懵逼的状态。群里开发、运维、安全、客服和boss们都在，着实挺热闹。&lt;/p&gt;
&lt;p&gt;　　整理思路着手写代码吧，哒！哒！哒！写着正兴，对接群里来了一个问题，看不懂，随意看了眼，后来同事A就昂我过去一起看这个问题，当时还在想这客服提的问题怎么还需要技术解决，问题看着与技术无关，好像是上一任留下的诟病，什么问题都会找他。我们俩傻眼了，这刚接上来就要处理问题，无从下手啊！&lt;/p&gt;
&lt;p&gt;　　只见同事A打开一个一目就开始各种搜相关问题解决方案，才知道是交接文档，一个多G。Oh！My god！文档也太多了吧，可见系统是有多复杂。果真，同事A拷给了我一份，打开目录真多，年代久远啊！全盘搜索无果，同事A找第三方B求助，B熟悉这里的业务，有相关服务协议，所以，有事解决不了的尽管找B。又是一个信心满满，哦哦，原来要进行数据库操作，我说客服为什么找技术呢。&lt;/p&gt;
&lt;p&gt;　　备受打击，没数据字典，什么说明都没有，B说的什么表和一些业务方面的专业术语完全不懂啊。对我们这样的门外汉，只能说能说的再具体点吗。就相当于远程操控着我们，改那个表哪个字段，有点心累啊！看到这你是不是已经觉得心累了，这确定不是系统有bug，业务问题直接操作数据库？。？先不管什么逻辑不逻辑，解决问题首要，具体操作数据库过程就不赘述，一步一个坎。&lt;/p&gt;
&lt;p&gt;　　几天两个流程自动化代码写的差不多了，客服的问题也各种各样，都是头一次见。还是花时间把那一个多G的交接文档看看，至少有个印象。于是乎，花了两天时间，把各个文件看了一遍。看到PDM大概知道有好几个系统，服务器几十个，两天时间交接，现在看来的确是仓促了。&lt;/p&gt;
&lt;p&gt;　　剩下的几个月里，写的流程自动化程序已经完成。偶尔群里冒出几个问题需要处理，因为第三方B开发的，没有源码，只剩一堆文档陪伴着我们。年前面临一个问题，说是机房要搬迁，服务从没停过，虽然帮不上什么忙，也替运维们捏把冷汗。不过第三方的运维也会在场，最终大战一晚和一早上，所有服务启动了。这次搬迁之后，群里反馈的问题貌似就多起来，有的系统也间接性飘向北方，搬迁遗留的问题吧。&lt;/p&gt;
&lt;p&gt;　　没代码帮着解决问题，只能向B反馈，然而有个问题直接没处理，现在业务量上来，群里每天都是处理着同一个问题。忙的时候可能晚点下班，闲的时候群里没人a@你。于是乎，把技术相关的电子书看起来了，像我这种不爱看书的人，都被磨得看起书来。沉淀下我这怎么样的心，语文不好，想不到什么形容词。&lt;/p&gt;
&lt;p&gt;　　从协助这个项目，开始变成参与客服问题，同事A说不需要太卖力，想着虽然是协助，工作还是得做好吧！后面发生的事，才觉得同事A说的很对。&lt;/p&gt;
&lt;p&gt;　　后来，听说有人接手这个项目，想想还是挺开心，又可以无忧无虑的敲代码了。毕竟到现在，参与到这个项目工作，沟通占大半天，被远程操控占小半天。有时候好奇了，为什么这么操作，第三方B是不会回答的。源码没有，逻辑也不告诉你，几个月过去还是一脸懵逼~&lt;/p&gt;
&lt;p&gt;　　之前两天交接给我们，再交接给别人，幸好下一家有一个比较靠谱的，懂业务逻辑的，但是别人也不是全部都懂。交接迟迟没交接完...&lt;/p&gt;
&lt;p&gt;　　日常工作处理解决群里的问题，每月月底的对账也需要技术做，其实就是查查数据库，比对金额对不对。之前几个月数据差异小，今天查询3月份账单数据差异太大，只能找问题。与上一任负责人微信请教两天，知道今天才把错误处理步骤屡清楚，解决一大部分。还是差异很大，有点耽误了账单签字时间。于是，该项目公司C打电话问这个问题，一五一十说这个问题难度，现在仍对不上。得到的回复是，现在这边数据比第三方的多，那就按第三方的来，这样公司也少结。没来得及问，要是少呢，还是需要找问题一步步解决。&lt;/p&gt;
&lt;p&gt;　　今天，让我明天一个词——“&lt;strong&gt;事无巨细&lt;/strong&gt;”。也正如，同事A所说，不用太卖力。转眼间3个多月过去了，回想这段时间，成长了吗？学到了什么？好像人变傻了不少@。@。前几天在知乎上看到一文，说是一个人做什么事都很细心，是个完美主义者，做事非得自己觉得ok的时候才交差，还会经常情商低的说有什么问题自己担。虽然说我没，他/她这么的有责任，有担当，还是有点相似之处。&lt;/p&gt;
&lt;p&gt;　　快下班前，跟领导说了协助这个项目的日常工作与技术没多大关系，打好招呼要尽快交接。领导欣然同意。具体缘由就没过多汇报了。事实证明，如果做得工作实在难受，就痛快、大胆的说出来，因为那是浪费自己的时间和青春，谨记！！！&lt;/p&gt;


</description>
<pubDate>Wed, 10 Apr 2019 16:34:00 +0000</pubDate>
<dc:creator>落叶虽美只活一世</dc:creator>
<og:description>时间：跨越大（2018.12至今2019.04.10） 地点：北京朝阳区某大厦某座某层 人物：ABC等 事情描述：见下文 去年年底手上开发任务已完成，暂无其他开发需求，被安排协助一个项目。看，又有个烂</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/NolaLi/p/10685422.html</dc:identifier>
</item>
<item>
<title>死磕 java集合之ConcurrentHashMap源码分析（三） - 彤哥读源码</title>
<link>http://www.cnblogs.com/tong-yuan/p/ConcurrentHashMap-sourcecode.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tong-yuan/p/ConcurrentHashMap-sourcecode.html</guid>
<description>&lt;p&gt;本章接着上两章，链接直达：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/rlyoQp4ngTX8mjGDJgJIRA&quot;&gt;死磕 java集合之ConcurrentHashMap源码分析（一）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/_Bf6XcH51lssC0mdF_oW9A&quot;&gt;死磕 java集合之ConcurrentHashMap源码分析（二）&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;删除元素&quot;&gt;删除元素&lt;/h3&gt;
&lt;p&gt;删除元素跟添加元素一样，都是先找到元素所在的桶，然后采用分段锁的思想锁住整个桶，再进行操作。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public V remove(Object key) {
    // 调用替换节点方法
    return replaceNode(key, null, null);
}

final V replaceNode(Object key, V value, Object cv) {
    // 计算hash
    int hash = spread(key.hashCode());
    // 自旋
    for (Node&amp;lt;K,V&amp;gt;[] tab = table;;) {
        Node&amp;lt;K,V&amp;gt; f; int n, i, fh;
        if (tab == null || (n = tab.length) == 0 ||
                (f = tabAt(tab, i = (n - 1) &amp;amp; hash)) == null)
            // 如果目标key所在的桶不存在，跳出循环返回null
            break;
        else if ((fh = f.hash) == MOVED)
            // 如果正在扩容中，协助扩容
            tab = helpTransfer(tab, f);
        else {
            V oldVal = null;
            // 标记是否处理过
            boolean validated = false;
            synchronized (f) {
                // 再次验证当前桶第一个元素是否被修改过
                if (tabAt(tab, i) == f) {
                    if (fh &amp;gt;= 0) {
                        // fh&amp;gt;=0表示是链表节点
                        validated = true;
                        // 遍历链表寻找目标节点
                        for (Node&amp;lt;K,V&amp;gt; e = f, pred = null;;) {
                            K ek;
                            if (e.hash == hash &amp;amp;&amp;amp;
                                    ((ek = e.key) == key ||
                                            (ek != null &amp;amp;&amp;amp; key.equals(ek)))) {
                                // 找到了目标节点
                                V ev = e.val;
                                // 检查目标节点旧value是否等于cv
                                if (cv == null || cv == ev ||
                                        (ev != null &amp;amp;&amp;amp; cv.equals(ev))) {
                                    oldVal = ev;
                                    if (value != null)
                                        // 如果value不为空则替换旧值
                                        e.val = value;
                                    else if (pred != null)
                                        // 如果前置节点不为空
                                        // 删除当前节点
                                        pred.next = e.next;
                                    else
                                        // 如果前置节点为空
                                        // 说明是桶中第一个元素，删除之
                                        setTabAt(tab, i, e.next);
                                }
                                break;
                            }
                            pred = e;
                            // 遍历到链表尾部还没找到元素，跳出循环
                            if ((e = e.next) == null)
                                break;
                        }
                    }
                    else if (f instanceof TreeBin) {
                        // 如果是树节点
                        validated = true;
                        TreeBin&amp;lt;K,V&amp;gt; t = (TreeBin&amp;lt;K,V&amp;gt;)f;
                        TreeNode&amp;lt;K,V&amp;gt; r, p;
                        // 遍历树找到了目标节点
                        if ((r = t.root) != null &amp;amp;&amp;amp;
                                (p = r.findTreeNode(hash, key, null)) != null) {
                            V pv = p.val;
                            // 检查目标节点旧value是否等于cv
                            if (cv == null || cv == pv ||
                                    (pv != null &amp;amp;&amp;amp; cv.equals(pv))) {
                                oldVal = pv;
                                if (value != null)
                                    // 如果value不为空则替换旧值
                                    p.val = value;
                                else if (t.removeTreeNode(p))
                                    // 如果value为空则删除元素
                                    // 如果删除后树的元素个数较少则退化成链表
                                    // t.removeTreeNode(p)这个方法返回true表示删除节点后树的元素个数较少
                                    setTabAt(tab, i, untreeify(t.first));
                            }
                        }
                    }
                }
            }
            // 如果处理过，不管有没有找到元素都返回
            if (validated) {
                // 如果找到了元素，返回其旧值
                if (oldVal != null) {
                    // 如果要替换的值为空，元素个数减1
                    if (value == null)
                        addCount(-1L, -1);
                    return oldVal;
                }
                break;
            }
        }
    }
    // 没找到元素返回空
    return null;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（1）计算hash；&lt;/p&gt;
&lt;p&gt;（2）如果所在的桶不存在，表示没有找到目标元素，返回；&lt;/p&gt;
&lt;p&gt;（3）如果正在扩容，则协助扩容完成后再进行删除操作；&lt;/p&gt;
&lt;p&gt;（4）如果是以链表形式存储的，则遍历整个链表查找元素，找到之后再删除；&lt;/p&gt;
&lt;p&gt;（5）如果是以树形式存储的，则遍历树查找元素，找到之后再删除；&lt;/p&gt;
&lt;p&gt;（6）如果是以树形式存储的，删除元素之后树较小，则退化成链表；&lt;/p&gt;
&lt;p&gt;（7）如果确实删除了元素，则整个map元素个数减1，并返回旧值；&lt;/p&gt;
&lt;p&gt;（8）如果没有删除元素，则返回null；&lt;/p&gt;
&lt;h3 id=&quot;获取元素&quot;&gt;获取元素&lt;/h3&gt;
&lt;p&gt;获取元素，根据目标key所在桶的第一个元素的不同采用不同的方式获取元素，关键点在于find()方法的重写。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public V get(Object key) {
    Node&amp;lt;K,V&amp;gt;[] tab; Node&amp;lt;K,V&amp;gt; e, p; int n, eh; K ek;
    // 计算hash
    int h = spread(key.hashCode());
    // 如果元素所在的桶存在且里面有元素
    if ((tab = table) != null &amp;amp;&amp;amp; (n = tab.length) &amp;gt; 0 &amp;amp;&amp;amp;
            (e = tabAt(tab, (n - 1) &amp;amp; h)) != null) {
        // 如果第一个元素就是要找的元素，直接返回
        if ((eh = e.hash) == h) {
            if ((ek = e.key) == key || (ek != null &amp;amp;&amp;amp; key.equals(ek)))
                return e.val;
        }
        else if (eh &amp;lt; 0)
            // hash小于0，说明是树或者正在扩容
            // 使用find寻找元素，find的寻找方式依据Node的不同子类有不同的实现方式
            return (p = e.find(h, key)) != null ? p.val : null;

        // 遍历整个链表寻找元素
        while ((e = e.next) != null) {
            if (e.hash == h &amp;amp;&amp;amp;
                    ((ek = e.key) == key || (ek != null &amp;amp;&amp;amp; key.equals(ek))))
                return e.val;
        }
    }
    return null;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（1）hash到元素所在的桶；&lt;/p&gt;
&lt;p&gt;（2）如果桶中第一个元素就是该找的元素，直接返回；&lt;/p&gt;
&lt;p&gt;（3）如果是树或者正在迁移元素，则调用各自Node子类的find()方法寻找元素；&lt;/p&gt;
&lt;p&gt;（4）如果是链表，遍历整个链表寻找元素；&lt;/p&gt;
&lt;p&gt;（5）获取元素没有加锁；&lt;/p&gt;
&lt;h3 id=&quot;获取元素个数&quot;&gt;获取元素个数&lt;/h3&gt;
&lt;p&gt;元素个数的存储也是采用分段的思想，获取元素个数时需要把所有段加起来。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public int size() {
    // 调用sumCount()计算元素个数
    long n = sumCount();
    return ((n &amp;lt; 0L) ? 0 :
            (n &amp;gt; (long)Integer.MAX_VALUE) ? Integer.MAX_VALUE :
                    (int)n);
}

final long sumCount() {
    // 计算CounterCell所有段及baseCount的数量之和
    CounterCell[] as = counterCells; CounterCell a;
    long sum = baseCount;
    if (as != null) {
        for (int i = 0; i &amp;lt; as.length; ++i) {
            if ((a = as[i]) != null)
                sum += a.value;
        }
    }
    return sum;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（1）元素的个数依据不同的线程存在在不同的段里；（见addCounter()分析）&lt;/p&gt;
&lt;p&gt;（2）计算CounterCell所有段及baseCount的数量之和；&lt;/p&gt;
&lt;p&gt;（3）获取元素个数没有加锁；&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;（1）ConcurrentHashMap是HashMap的线程安全版本；&lt;/p&gt;
&lt;p&gt;（2）ConcurrentHashMap采用（数组 + 链表 + 红黑树）的结构存储元素；&lt;/p&gt;
&lt;p&gt;（3）ConcurrentHashMap相比于同样线程安全的HashTable，效率要高很多；&lt;/p&gt;
&lt;p&gt;（4）ConcurrentHashMap采用的锁有 synchronized，CAS，自旋锁，分段锁，volatile等；&lt;/p&gt;
&lt;p&gt;（5）ConcurrentHashMap中没有threshold和loadFactor这两个字段，而是采用sizeCtl来控制；&lt;/p&gt;
&lt;p&gt;（6）sizeCtl = -1，表示正在进行初始化；&lt;/p&gt;
&lt;p&gt;（7）sizeCtl = 0，默认值，表示后续在真正初始化的时候使用默认容量；&lt;/p&gt;
&lt;p&gt;（8）sizeCtl &amp;gt; 0，在初始化之前存储的是传入的容量，在初始化或扩容后存储的是下一次的扩容门槛；&lt;/p&gt;
&lt;p&gt;（9）sizeCtl = (resizeStamp &amp;lt;&amp;lt; 16) + (1 + nThreads)，表示正在进行扩容，高位存储扩容邮戳，低位存储扩容线程数加1；&lt;/p&gt;
&lt;p&gt;（10）更新操作时如果正在进行扩容，当前线程协助扩容；&lt;/p&gt;
&lt;p&gt;（11）更新操作会采用synchronized锁住当前桶的第一个元素，这是分段锁的思想；&lt;/p&gt;
&lt;p&gt;（12）整个扩容过程都是通过CAS控制sizeCtl这个字段来进行的，这很关键；&lt;/p&gt;
&lt;p&gt;（13）迁移完元素的桶会放置一个ForwardingNode节点，以标识该桶迁移完毕；&lt;/p&gt;
&lt;p&gt;（14）元素个数的存储也是采用的分段思想，类似于LongAdder的实现；&lt;/p&gt;
&lt;p&gt;（15）元素个数的更新会把不同的线程hash到不同的段上，减少资源争用；&lt;/p&gt;
&lt;p&gt;（16）元素个数的更新如果还是出现多个线程同时更新一个段，则会扩容段（CounterCell）；&lt;/p&gt;
&lt;p&gt;（17）获取元素个数是把所有的段（包括baseCount和CounterCell）相加起来得到的；&lt;/p&gt;
&lt;p&gt;（18）查询操作是不会加锁的，所以ConcurrentHashMap不是强一致性的；&lt;/p&gt;
&lt;p&gt;（19）ConcurrentHashMap中不能存储key或value为null的元素；&lt;/p&gt;
&lt;h2 id=&quot;彩蛋值得学习的技术&quot;&gt;彩蛋——值得学习的技术&lt;/h2&gt;
&lt;p&gt;ConcurrentHashMap中有哪些值得学习的技术呢？&lt;/p&gt;
&lt;p&gt;我认为有以下几点：&lt;/p&gt;
&lt;p&gt;（1）CAS + 自旋，乐观锁的思想，减少线程上下文切换的时间；&lt;/p&gt;
&lt;p&gt;（2）分段锁的思想，减少同一把锁争用带来的低效问题；&lt;/p&gt;
&lt;p&gt;（3）CounterCell，分段存储元素个数，减少多线程同时更新一个字段带来的低效；&lt;/p&gt;
&lt;p&gt;（4）@sun.misc.Contended（CounterCell上的注解），避免伪共享；（p.s.伪共享我们后面也会讲的^^）&lt;/p&gt;
&lt;p&gt;（5）多线程协同进行扩容；&lt;/p&gt;
&lt;p&gt;（6）你又学到了哪些呢？&lt;/p&gt;
&lt;h2 id=&quot;彩蛋不能解决的问题&quot;&gt;彩蛋——不能解决的问题&lt;/h2&gt;
&lt;p&gt;ConcurrentHashMap不能解决什么问题呢？&lt;/p&gt;
&lt;p&gt;请看下面的例子：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private static final Map&amp;lt;Integer, Integer&amp;gt; map = new ConcurrentHashMap&amp;lt;&amp;gt;();

public void unsafeUpdate(Integer key, Integer value) {
    Integer oldValue = map.get(key);
    if (oldValue == null) {
        map.put(key, value);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里如果有多个线程同时调用unsafeUpdate()这个方法，ConcurrentHashMap还能保证线程安全吗？&lt;/p&gt;
&lt;p&gt;答案是不能。因为get()之后if之前可能有其它线程已经put()了这个元素，这时候再put()就把那个线程put()的元素覆盖了。&lt;/p&gt;
&lt;p&gt;那怎么修改呢？&lt;/p&gt;
&lt;p&gt;答案也很简单，使用putIfAbsent()方法，它会保证元素不存在时才插入元素，如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void safeUpdate(Integer key, Integer value) {
    map.putIfAbsent(key, value);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么，如果上面oldValue不是跟null比较，而是跟一个特定的值比如1进行比较怎么办？也就是下面这样：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void unsafeUpdate(Integer key, Integer value) {
    Integer oldValue = map.get(key);
    if (oldValue == 1) {
        map.put(key, value);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样的话就没办法使用putIfAbsent()方法了。&lt;/p&gt;
&lt;p&gt;其实，ConcurrentHashMap还提供了另一个方法叫replace(K key, V oldValue, V newValue)可以解决这个问题。&lt;/p&gt;
&lt;p&gt;replace(K key, V oldValue, V newValue)这个方法可不能乱用，如果传入的newValue是null，则会删除元素。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void safeUpdate(Integer key, Integer value) {
    map.replace(key, 1, value);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么，如果if之后不是简单的put()操作，而是还有其它业务操作，之后才是put()，比如下面这样，这该怎么办呢？&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void unsafeUpdate(Integer key, Integer value) {
    Integer oldValue = map.get(key);
    if (oldValue == 1) {
        System.out.println(System.currentTimeMillis());
        /**
         * 其它业务操作
         */
        System.out.println(System.currentTimeMillis());
      
        map.put(key, value);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时候就没办法使用ConcurrentHashMap提供的方法了，只能业务自己来保证线程安全了，比如下面这样：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void safeUpdate(Integer key, Integer value) {
    synchronized (map) {
        Integer oldValue = map.get(key);
        if (oldValue == null) {
            System.out.println(System.currentTimeMillis());
            /**
             * 其它业务操作
             */
            System.out.println(System.currentTimeMillis());

            map.put(key, value);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样虽然不太友好，但是最起码能保证业务逻辑是正确的。&lt;/p&gt;
&lt;p&gt;当然，这里使用ConcurrentHashMap的意义也就不大了，可以换成普通的HashMap了。&lt;/p&gt;
&lt;p&gt;上面只是举一个简单的例子，我们不能听说ConcurrentHashMap是线程安全的，就认为它无论什么情况下都是线程安全的，还是那句话尽信书不如无书。&lt;/p&gt;
&lt;p&gt;这也正是我们读源码的目的之一，了解其本质，才能在我们的实际工作中少挖坑，不论是挖给别人还是挖给自己^^。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/alan-tang-tt/yuan/raw/master/%E6%AD%BB%E7%A3%95%20java%E9%9B%86%E5%90%88%E7%B3%BB%E5%88%97/resource/qrcode.jpg&quot; alt=&quot;qrcode&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 10 Apr 2019 15:42:00 +0000</pubDate>
<dc:creator>彤哥读源码</dc:creator>
<og:description>死磕 java集合之ConcurrentHashMap源码分析（三） ConcurrentHashMap查询是否也加锁？ ConcurrentHashMap有哪些值得我们学习的技术？ Concu</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tong-yuan/p/ConcurrentHashMap-sourcecode.html</dc:identifier>
</item>
<item>
<title>基于Log4Net本地日志服务简单实现 - MeetYan</title>
<link>http://www.cnblogs.com/MeetYan/p/10687029.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MeetYan/p/10687029.html</guid>
<description>&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;ol readability=&quot;3.4098360655738&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;项目开发中，我们或多或少会使用诸如NLog，Log4Net，Kafka+ELK等等日志套件；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;基于关注点分离原则，业务开发的时候不应该关注日志具体实现；并且后续能方便切换其他日志套件；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;这里先实现基于文件的日志服务，在下一篇将实现基于Kafka+ELK；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-0.57692307692308&quot;&gt;
&lt;p&gt;具体源码：&lt;a href=&quot;https://github.com/YanZhiwei/MasterChief&quot;&gt;MasterChief&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Nuget：Install-Package MasterChief.DotNet.Core.Log&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;欢迎Star，欢迎Issues；&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;日志接口定义&quot;&gt;日志接口定义&lt;/h2&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
///     日志记录接口
/// &amp;lt;/summary&amp;gt;
public interface ILogService
{
    #region Methods
 
    /// &amp;lt;summary&amp;gt;
    ///     Debug记录
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;message&quot;&amp;gt;日志信息&amp;lt;/param&amp;gt;
    void Debug(string message);
 
    /// &amp;lt;summary&amp;gt;
    ///     Debug记录
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;message&quot;&amp;gt;日志信息&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;ex&quot;&amp;gt;异常信息&amp;lt;/param&amp;gt;
    void Debug(string message, Exception ex);
 
    /// &amp;lt;summary&amp;gt;
    ///     Error记录
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;message&quot;&amp;gt;日志信息&amp;lt;/param&amp;gt;
    void Error(string message);
 
    /// &amp;lt;summary&amp;gt;
    ///     Error记录
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;message&quot;&amp;gt;日志信息&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;ex&quot;&amp;gt;异常信息&amp;lt;/param&amp;gt;
    void Error(string message, Exception ex);
 
    /// &amp;lt;summary&amp;gt;
    ///     Fatal记录
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;message&quot;&amp;gt;日志信息&amp;lt;/param&amp;gt;
    void Fatal(string message);
 
    /// &amp;lt;summary&amp;gt;
    ///     Fatal记录
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;message&quot;&amp;gt;日志信息&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;ex&quot;&amp;gt;异常信息&amp;lt;/param&amp;gt;
    void Fatal(string message, Exception ex);
 
    /// &amp;lt;summary&amp;gt;
    ///     Info记录
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;message&quot;&amp;gt;日志信息&amp;lt;/param&amp;gt;
    void Info(string message);
 
    /// &amp;lt;summary&amp;gt;
    ///     Info记录
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;message&quot;&amp;gt;日志信息&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;ex&quot;&amp;gt;异常信息&amp;lt;/param&amp;gt;
    void Info(string message, Exception ex);
 
    /// &amp;lt;summary&amp;gt;
    ///     Warn记录
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;message&quot;&amp;gt;日志信息&amp;lt;/param&amp;gt;
    void Warn(string message);
 
    /// &amp;lt;summary&amp;gt;
    ///     Warn记录
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;message&quot;&amp;gt;日志信息&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;ex&quot;&amp;gt;异常信息&amp;lt;/param&amp;gt;
    void Warn(string message, Exception ex);
 
    #endregion Methods
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;基于log4net本地文件日志服务实现&quot;&gt;基于Log4Net本地文件日志服务实现&lt;/h2&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
///     基于Log4Net的文件日志记录
/// &amp;lt;/summary&amp;gt;
public sealed class FileLogService : ILogService
{
    #region Constructors
 
    static FileLogService()
    {
        DebugLogger = LogManager.GetLogger(DebugLoggerName);
        InfoLogger = LogManager.GetLogger(InfoLoggerName);
        WarnLogger = LogManager.GetLogger(WarnLoggerName);
        ErrorLogger = LogManager.GetLogger(ErrorLoggerName);
        FatalLogger = LogManager.GetLogger(FatalLoggerName);
    }
 
    #endregion Constructors
 
    #region Fields
 
    /// &amp;lt;summary&amp;gt;
    ///     The debug logger name
    /// &amp;lt;/summary&amp;gt;
    public const string DebugLoggerName = &quot;DEBUG_FileLogger&quot;;
 
    /// &amp;lt;summary&amp;gt;
    ///     The error logger name
    /// &amp;lt;/summary&amp;gt;
    public const string ErrorLoggerName = &quot;ERROR_FileLogger&quot;;
 
    /// &amp;lt;summary&amp;gt;
    ///     The fatal logger name
    /// &amp;lt;/summary&amp;gt;
    public const string FatalLoggerName = &quot;FATAL_FileLogger&quot;;
 
    /// &amp;lt;summary&amp;gt;
    ///     The information logger name
    /// &amp;lt;/summary&amp;gt;
    public const string InfoLoggerName = &quot;INFO_FileLogger&quot;;
 
    /// &amp;lt;summary&amp;gt;
    ///     The warn logger name
    /// &amp;lt;/summary&amp;gt;
    public const string WarnLoggerName = &quot;WARN_FileLogger&quot;;
 
    /// &amp;lt;summary&amp;gt;
    ///     The debug logger
    /// &amp;lt;/summary&amp;gt;
    public static readonly ILog DebugLogger;
 
    /// &amp;lt;summary&amp;gt;
    ///     The error logger
    /// &amp;lt;/summary&amp;gt;
    public static readonly ILog ErrorLogger;
 
    /// &amp;lt;summary&amp;gt;
    ///     The fatal logger
    /// &amp;lt;/summary&amp;gt;
    public static readonly ILog FatalLogger;
 
    /// &amp;lt;summary&amp;gt;
    ///     The information logger
    /// &amp;lt;/summary&amp;gt;
    public static readonly ILog InfoLogger;
 
    /// &amp;lt;summary&amp;gt;
    ///     The warn logger
    /// &amp;lt;/summary&amp;gt;
    public static readonly ILog WarnLogger;
 
    #endregion Fields
 
    #region Methods
 
    /// &amp;lt;summary&amp;gt;
    ///     Debug记录
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;message&quot;&amp;gt;日志信息&amp;lt;/param&amp;gt;
    public void Debug(string message)
    {
        if (DebugLogger.IsDebugEnabled) DebugLogger.Debug(message);
    }
 
    /// &amp;lt;summary&amp;gt;
    ///     Debug记录
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;message&quot;&amp;gt;日志信息&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;ex&quot;&amp;gt;异常信息&amp;lt;/param&amp;gt;
    public void Debug(string message, Exception ex)
    {
        if (DebugLogger.IsDebugEnabled) DebugLogger.Debug(message, ex);
    }
 
    /// &amp;lt;summary&amp;gt;
    ///     Error记录
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;message&quot;&amp;gt;日志信息&amp;lt;/param&amp;gt;
    public void Error(string message)
    {
        if (ErrorLogger.IsErrorEnabled) ErrorLogger.Error(message);
    }
 
    /// &amp;lt;summary&amp;gt;
    ///     Error记录
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;message&quot;&amp;gt;日志信息&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;ex&quot;&amp;gt;异常信息&amp;lt;/param&amp;gt;
    public void Error(string message, Exception ex)
    {
        if (ErrorLogger.IsErrorEnabled) ErrorLogger.Error(message, ex);
    }
 
    /// &amp;lt;summary&amp;gt;
    ///     Fatal记录
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;message&quot;&amp;gt;日志信息&amp;lt;/param&amp;gt;
    public void Fatal(string message)
    {
        if (FatalLogger.IsFatalEnabled) FatalLogger.Fatal(message);
    }
 
    /// &amp;lt;summary&amp;gt;
    ///     Fatal记录
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;message&quot;&amp;gt;日志信息&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;ex&quot;&amp;gt;异常信息&amp;lt;/param&amp;gt;
    public void Fatal(string message, Exception ex)
    {
        if (FatalLogger.IsFatalEnabled) FatalLogger.Fatal(message, ex);
    }
 
    /// &amp;lt;summary&amp;gt;
    ///     Info记录
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;message&quot;&amp;gt;日志信息&amp;lt;/param&amp;gt;
    public void Info(string message)
    {
        if (InfoLogger.IsInfoEnabled) InfoLogger.Info(message);
    }
 
    /// &amp;lt;summary&amp;gt;
    ///     Info记录
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;message&quot;&amp;gt;日志信息&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;ex&quot;&amp;gt;异常信息&amp;lt;/param&amp;gt;
    public void Info(string message, Exception ex)
    {
        if (InfoLogger.IsInfoEnabled) InfoLogger.Info(message, ex);
    }
 
    /// &amp;lt;summary&amp;gt;
    ///     Warn记录
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;message&quot;&amp;gt;日志信息&amp;lt;/param&amp;gt;
    public void Warn(string message)
    {
        if (WarnLogger.IsWarnEnabled) WarnLogger.Warn(message);
    }
 
    /// &amp;lt;summary&amp;gt;
    ///     Warn记录
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;message&quot;&amp;gt;日志信息&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;ex&quot;&amp;gt;异常信息&amp;lt;/param&amp;gt;
    public void Warn(string message, Exception ex)
    {
        if (WarnLogger.IsWarnEnabled) WarnLogger.Warn(message, ex);
    }
 
    #endregion Methods
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;log4net-配置文件&quot;&gt;Log4Net 配置文件&lt;/h2&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&amp;gt;
&amp;lt;configuration&amp;gt;
  &amp;lt;configSections&amp;gt;
    &amp;lt;section name=&quot;log4net&quot; type=&quot;log4net.Config.Log4NetConfigurationSectionHandler&quot; /&amp;gt;
  &amp;lt;/configSections&amp;gt;
  &amp;lt;log4net&amp;gt;
    &amp;lt;!-- FileLogger --&amp;gt;
    &amp;lt;logger name=&quot;FATAL_FileLogger&quot;&amp;gt;
      &amp;lt;level value=&quot;ALL&quot; /&amp;gt;
      &amp;lt;appender-ref ref=&quot;FATAL_FileAppender&quot; /&amp;gt;
    &amp;lt;/logger&amp;gt;
    &amp;lt;logger name=&quot;ERROR_FileLogger&quot;&amp;gt;
      &amp;lt;level value=&quot;ALL&quot; /&amp;gt;
      &amp;lt;appender-ref ref=&quot;ERROR_FileAppender&quot; /&amp;gt;
    &amp;lt;/logger&amp;gt;
    &amp;lt;logger name=&quot;WARN_FileLogger&quot;&amp;gt;
      &amp;lt;level value=&quot;ALL&quot; /&amp;gt;
      &amp;lt;appender-ref ref=&quot;WARN_FileAppender&quot; /&amp;gt;
    &amp;lt;/logger&amp;gt;
    &amp;lt;logger name=&quot;INFO_FileLogger&quot;&amp;gt;
      &amp;lt;level value=&quot;ALL&quot; /&amp;gt;
      &amp;lt;appender-ref ref=&quot;INFO_FileAppender&quot; /&amp;gt;
    &amp;lt;/logger&amp;gt;
    &amp;lt;logger name=&quot;DEBUG_FileLogger&quot;&amp;gt;
      &amp;lt;level value=&quot;ALL&quot; /&amp;gt;
      &amp;lt;appender-ref ref=&quot;DEBUG_FileAppender&quot; /&amp;gt;
    &amp;lt;/logger&amp;gt;
    &amp;lt;!-- AdoNetLogger --&amp;gt;
    &amp;lt;!--&amp;lt;logger name=&quot;AdoNetLogger&quot;&amp;gt;
      &amp;lt;level value=&quot;ALL&quot; /&amp;gt;
      &amp;lt;appender-ref ref=&quot;AdoNetAppender&quot; /&amp;gt;
    &amp;lt;/logger&amp;gt;--&amp;gt;
    &amp;lt;!-- ConsoleLogger --&amp;gt;
    &amp;lt;logger name=&quot;ConsoleLogger&quot;&amp;gt;
      &amp;lt;level value=&quot;ALL&quot; /&amp;gt;
      &amp;lt;appender-ref ref=&quot;ColoredConsoleAppender&quot; /&amp;gt;
    &amp;lt;/logger&amp;gt;
 
    &amp;lt;!--使用Rolling方式记录日志按照日来记录日志--&amp;gt;
    &amp;lt;appender name=&quot;FATAL_FileAppender&quot; type=&quot;log4net.Appender.RollingFileAppender&quot;&amp;gt;
      &amp;lt;!--文件名,可以相对路径,也可以绝对路径,这里只给定了文件夹--&amp;gt;
      &amp;lt;file value=&quot;.\log\\FATAL\\&quot; /&amp;gt;
      &amp;lt;!--是否增加文件--&amp;gt;
      &amp;lt;appendToFile value=&quot;true&quot; /&amp;gt;
      &amp;lt;maxSizeRollBackups value=&quot;5&quot; /&amp;gt;
      &amp;lt;!--日志追加类型,Date为按日期增加文件,Size为按大小--&amp;gt;
      &amp;lt;rollingStyle value=&quot;Date&quot; /&amp;gt;
      &amp;lt;!--最小锁定模型以允许多个进程可以写入同一个文件,解决文件独占问题--&amp;gt;
      &amp;lt;lockingModel type=&quot;log4net.Appender.FileAppender+MinimalLock&quot; /&amp;gt;
      &amp;lt;!--最大文件大小--&amp;gt;
      &amp;lt;maximumFileSize value=&quot;10MB&quot; /&amp;gt;
      &amp;lt;!--文件命名格式,非日期参数化要进行转义,如自定义文件后缀--&amp;gt;
      &amp;lt;datePattern value=&quot;yyyyMM\\yyyy-MM-dd&amp;amp;quot;.log&amp;amp;quot;&quot; /&amp;gt;
      &amp;lt;!--是否固定文件名--&amp;gt;
      &amp;lt;staticLogFileName value=&quot;false&quot; /&amp;gt;
      &amp;lt;layout type=&quot;log4net.Layout.PatternLayout&quot;&amp;gt;
        &amp;lt;conversionPattern value=&quot;---------------------------------------------------%newline发生时间：%date %newline事件级别：%-5level %newline事件来源：%logger%newline日志内容：%message%newline&quot; /&amp;gt;
      &amp;lt;/layout&amp;gt;
    &amp;lt;/appender&amp;gt;
    &amp;lt;appender name=&quot;ERROR_FileAppender&quot; type=&quot;log4net.Appender.RollingFileAppender&quot;&amp;gt;
      &amp;lt;!--文件名,可以相对路径,也可以绝对路径,这里只给定了文件夹--&amp;gt;
      &amp;lt;file value=&quot;.\log\\ERROR\\&quot; /&amp;gt;
      &amp;lt;!--是否增加文件--&amp;gt;
      &amp;lt;appendToFile value=&quot;true&quot; /&amp;gt;
      &amp;lt;maxSizeRollBackups value=&quot;5&quot; /&amp;gt;
      &amp;lt;!--日志追加类型,Date为按日期增加文件,Size为按大小--&amp;gt;
      &amp;lt;rollingStyle value=&quot;Date&quot; /&amp;gt;
      &amp;lt;!--最小锁定模型以允许多个进程可以写入同一个文件,解决文件独占问题--&amp;gt;
      &amp;lt;lockingModel type=&quot;log4net.Appender.FileAppender+MinimalLock&quot; /&amp;gt;
      &amp;lt;!--最大文件大小--&amp;gt;
      &amp;lt;maximumFileSize value=&quot;10MB&quot; /&amp;gt;
      &amp;lt;!--文件命名格式,非日期参数化要进行转义,如自定义文件后缀--&amp;gt;
      &amp;lt;datePattern value=&quot;yyyyMM\\yyyy-MM-dd&amp;amp;quot;.log&amp;amp;quot;&quot; /&amp;gt;
      &amp;lt;!--是否固定文件名--&amp;gt;
      &amp;lt;staticLogFileName value=&quot;false&quot; /&amp;gt;
      &amp;lt;layout type=&quot;log4net.Layout.PatternLayout&quot;&amp;gt;
        &amp;lt;conversionPattern value=&quot;---------------------------------------------------%newline发生时间：%date %newline事件级别：%-5level %newline事件来源：%logger%newline日志内容：%message%newline&quot; /&amp;gt;
      &amp;lt;/layout&amp;gt;
    &amp;lt;/appender&amp;gt;
    &amp;lt;appender name=&quot;WARN_FileAppender&quot; type=&quot;log4net.Appender.RollingFileAppender&quot;&amp;gt;
      &amp;lt;!--文件名,可以相对路径,也可以绝对路径,这里只给定了文件夹--&amp;gt;
      &amp;lt;file value=&quot;.\log\\WARN\\&quot; /&amp;gt;
      &amp;lt;!--是否增加文件--&amp;gt;
      &amp;lt;appendToFile value=&quot;true&quot; /&amp;gt;
      &amp;lt;maxSizeRollBackups value=&quot;5&quot; /&amp;gt;
      &amp;lt;!--日志追加类型,Date为按日期增加文件,Size为按大小--&amp;gt;
      &amp;lt;rollingStyle value=&quot;Date&quot; /&amp;gt;
      &amp;lt;!--最小锁定模型以允许多个进程可以写入同一个文件,解决文件独占问题--&amp;gt;
      &amp;lt;lockingModel type=&quot;log4net.Appender.FileAppender+MinimalLock&quot; /&amp;gt;
      &amp;lt;!--最大文件大小--&amp;gt;
      &amp;lt;maximumFileSize value=&quot;10MB&quot; /&amp;gt;
      &amp;lt;!--文件命名格式,非日期参数化要进行转义,如自定义文件后缀--&amp;gt;
      &amp;lt;datePattern value=&quot;yyyyMM\\yyyy-MM-dd&amp;amp;quot;.log&amp;amp;quot;&quot; /&amp;gt;
      &amp;lt;!--是否固定文件名--&amp;gt;
      &amp;lt;staticLogFileName value=&quot;false&quot; /&amp;gt;
      &amp;lt;layout type=&quot;log4net.Layout.PatternLayout&quot;&amp;gt;
        &amp;lt;conversionPattern value=&quot;---------------------------------------------------%newline发生时间：%date %newline事件级别：%-5level %newline事件来源：%logger%newline日志内容：%message%newline&quot; /&amp;gt;
      &amp;lt;/layout&amp;gt;
    &amp;lt;/appender&amp;gt;
    &amp;lt;appender name=&quot;INFO_FileAppender&quot; type=&quot;log4net.Appender.RollingFileAppender&quot;&amp;gt;
      &amp;lt;!--文件名,可以相对路径,也可以绝对路径,这里只给定了文件夹--&amp;gt;
      &amp;lt;file value=&quot;.\log\\INFO\\&quot; /&amp;gt;
      &amp;lt;!--是否增加文件--&amp;gt;
      &amp;lt;appendToFile value=&quot;true&quot; /&amp;gt;
      &amp;lt;maxSizeRollBackups value=&quot;5&quot; /&amp;gt;
      &amp;lt;!--日志追加类型,Date为按日期增加文件,Size为按大小--&amp;gt;
      &amp;lt;rollingStyle value=&quot;Date&quot; /&amp;gt;
      &amp;lt;!--最小锁定模型以允许多个进程可以写入同一个文件,解决文件独占问题--&amp;gt;
      &amp;lt;lockingModel type=&quot;log4net.Appender.FileAppender+MinimalLock&quot; /&amp;gt;
      &amp;lt;!--最大文件大小--&amp;gt;
      &amp;lt;maximumFileSize value=&quot;10MB&quot; /&amp;gt;
      &amp;lt;!--文件命名格式,非日期参数化要进行转义,如自定义文件后缀--&amp;gt;
      &amp;lt;datePattern value=&quot;yyyyMM\\yyyy-MM-dd&amp;amp;quot;.log&amp;amp;quot;&quot; /&amp;gt;
      &amp;lt;!--是否固定文件名--&amp;gt;
      &amp;lt;staticLogFileName value=&quot;false&quot; /&amp;gt;
      &amp;lt;layout type=&quot;log4net.Layout.PatternLayout&quot;&amp;gt;
        &amp;lt;conversionPattern value=&quot;---------------------------------------------------%newline发生时间：%date %newline事件级别：%-5level %newline事件来源：%logger%newline日志内容：%message%newline&quot; /&amp;gt;
      &amp;lt;/layout&amp;gt;
    &amp;lt;/appender&amp;gt;
    &amp;lt;appender name=&quot;DEBUG_FileAppender&quot; type=&quot;log4net.Appender.RollingFileAppender&quot;&amp;gt;
      &amp;lt;!--文件名,可以相对路径,也可以绝对路径,这里只给定了文件夹--&amp;gt;
      &amp;lt;file value=&quot;.\log\\DEBUG\\&quot; /&amp;gt;
      &amp;lt;!--是否增加文件--&amp;gt;
      &amp;lt;appendToFile value=&quot;true&quot; /&amp;gt;
      &amp;lt;maxSizeRollBackups value=&quot;5&quot; /&amp;gt;
      &amp;lt;!--日志追加类型,Date为按日期增加文件,Size为按大小--&amp;gt;
      &amp;lt;rollingStyle value=&quot;Date&quot; /&amp;gt;
      &amp;lt;!--最小锁定模型以允许多个进程可以写入同一个文件,解决文件独占问题--&amp;gt;
      &amp;lt;lockingModel type=&quot;log4net.Appender.FileAppender+MinimalLock&quot; /&amp;gt;
      &amp;lt;!--最大文件大小--&amp;gt;
      &amp;lt;maximumFileSize value=&quot;10MB&quot; /&amp;gt;
      &amp;lt;!--文件命名格式,非日期参数化要进行转义,如自定义文件后缀--&amp;gt;
      &amp;lt;datePattern value=&quot;yyyyMM\\yyyy-MM-dd&amp;amp;quot;.log&amp;amp;quot;&quot; /&amp;gt;
      &amp;lt;!--是否固定文件名--&amp;gt;
      &amp;lt;staticLogFileName value=&quot;false&quot; /&amp;gt;
      &amp;lt;layout type=&quot;log4net.Layout.PatternLayout&quot;&amp;gt;
        &amp;lt;conversionPattern value=&quot;---------------------------------------------------%newline发生时间：%date %newline事件级别：%-5level %newline事件来源：%logger%newline日志内容：%message%newline&quot; /&amp;gt;
      &amp;lt;/layout&amp;gt;
    &amp;lt;/appender&amp;gt;
    &amp;lt;!--使用AdoNetAppender方式记录日志按照日来记录日志--&amp;gt;
    &amp;lt;!--&amp;lt;appender name=&quot;AdoNetAppender&quot; type=&quot;log4net.Appender.AdoNetAppender&quot;&amp;gt;
      &amp;lt;bufferSize value=&quot;1&quot; /&amp;gt;
      &amp;lt;connectionType value=&quot;System.Data.SqlClient.SqlConnection, System.Data, Version=1.0.3300.0, Culture=neutral, PublicKeyToken=b77a5c561934e089&quot; /&amp;gt;
      &amp;lt;connectionString value=&quot;DATABASE=Sample;SERVER=.\SQLEXPRESS;UID=sa;PWD=sasa;Connect Timeout=15;&quot; /&amp;gt;
      &amp;lt;commandText value=&quot;INSERT INTO [Log4Net] ([Date],[Host],[Thread],[Level],[Logger],[Message],[Exception]) VALUES (@log_date, @host, @thread, @log_level, @logger, @message, @exception)&quot; /&amp;gt;
      &amp;lt;parameter&amp;gt;
        &amp;lt;parameterName value=&quot;@log_date&quot; /&amp;gt;
        &amp;lt;dbType value=&quot;DateTime&quot; /&amp;gt;
        &amp;lt;layout type=&quot;log4net.Layout.RawTimeStampLayout&quot; /&amp;gt;
      &amp;lt;/parameter&amp;gt;
      &amp;lt;parameter&amp;gt;
        &amp;lt;parameterName value=&quot;@thread&quot; /&amp;gt;
        &amp;lt;dbType value=&quot;String&quot; /&amp;gt;
        &amp;lt;size value=&quot;255&quot; /&amp;gt;
        &amp;lt;layout type=&quot;log4net.Layout.PatternLayout&quot;&amp;gt;
          &amp;lt;conversionPattern value=&quot;%thread&quot; /&amp;gt;
        &amp;lt;/layout&amp;gt;
      &amp;lt;/parameter&amp;gt;
 
      &amp;lt;parameter&amp;gt;
        &amp;lt;parameterName value=&quot;@host&quot; /&amp;gt;
        &amp;lt;dbType value=&quot;String&quot; /&amp;gt;
        &amp;lt;size value=&quot;50&quot; /&amp;gt;
        &amp;lt;layout type=&quot;log4net.Layout.PatternLayout&quot;&amp;gt;
          &amp;lt;conversionPattern value=&quot;%property{log4net:HostName}&quot; /&amp;gt;
        &amp;lt;/layout&amp;gt;
      &amp;lt;/parameter&amp;gt;
      &amp;lt;parameter&amp;gt;
        &amp;lt;parameterName value=&quot;@log_level&quot; /&amp;gt;
        &amp;lt;dbType value=&quot;String&quot; /&amp;gt;
        &amp;lt;size value=&quot;50&quot; /&amp;gt;
        &amp;lt;layout type=&quot;log4net.Layout.PatternLayout&quot;&amp;gt;
          &amp;lt;conversionPattern value=&quot;%level&quot; /&amp;gt;
        &amp;lt;/layout&amp;gt;
      &amp;lt;/parameter&amp;gt;
      &amp;lt;parameter&amp;gt;
        &amp;lt;parameterName value=&quot;@logger&quot; /&amp;gt;
        &amp;lt;dbType value=&quot;String&quot; /&amp;gt;
        &amp;lt;size value=&quot;255&quot; /&amp;gt;
        &amp;lt;layout type=&quot;log4net.Layout.PatternLayout&quot;&amp;gt;
          &amp;lt;conversionPattern value=&quot;%logger&quot; /&amp;gt;
        &amp;lt;/layout&amp;gt;
      &amp;lt;/parameter&amp;gt;
      &amp;lt;parameter&amp;gt;
        &amp;lt;parameterName value=&quot;@message&quot; /&amp;gt;
        &amp;lt;dbType value=&quot;String&quot; /&amp;gt;
        &amp;lt;size value=&quot;4000&quot; /&amp;gt;
        &amp;lt;layout type=&quot;log4net.Layout.PatternLayout&quot;&amp;gt;
          &amp;lt;conversionPattern value=&quot;%message&quot; /&amp;gt;
        &amp;lt;/layout&amp;gt;
      &amp;lt;/parameter&amp;gt;
      &amp;lt;parameter&amp;gt;
        &amp;lt;parameterName value=&quot;@exception&quot; /&amp;gt;
        &amp;lt;dbType value=&quot;String&quot; /&amp;gt;
        &amp;lt;size value=&quot;4000&quot; /&amp;gt;
        &amp;lt;layout type=&quot;log4net.Layout.ExceptionLayout&quot; /&amp;gt;
      &amp;lt;/parameter&amp;gt;
    &amp;lt;/appender&amp;gt;--&amp;gt;
    &amp;lt;!--使用ConsoleAppender方式记录日志按照日来记录日志--&amp;gt;
    &amp;lt;appender name=&quot;ColoredConsoleAppender&quot; type=&quot;log4net.Appender.ColoredConsoleAppender&quot;&amp;gt;
      &amp;lt;mapping&amp;gt;
        &amp;lt;level value=&quot;INFO&quot; /&amp;gt;
        &amp;lt;foreColor value=&quot;White, HighIntensity&quot; /&amp;gt;
        &amp;lt;backColor value=&quot;Green&quot; /&amp;gt;
      &amp;lt;/mapping&amp;gt;
      &amp;lt;mapping&amp;gt;
        &amp;lt;level value=&quot;DEBUG&quot; /&amp;gt;
        &amp;lt;foreColor value=&quot;White, HighIntensity&quot; /&amp;gt;
        &amp;lt;backColor value=&quot;Blue&quot; /&amp;gt;
      &amp;lt;/mapping&amp;gt;
      &amp;lt;mapping&amp;gt;
        &amp;lt;level value=&quot;WARN&quot; /&amp;gt;
        &amp;lt;foreColor value=&quot;Yellow, HighIntensity&quot; /&amp;gt;
        &amp;lt;backColor value=&quot;Purple&quot; /&amp;gt;
      &amp;lt;/mapping&amp;gt;
      &amp;lt;mapping&amp;gt;
        &amp;lt;level value=&quot;ERROR&quot; /&amp;gt;
        &amp;lt;foreColor value=&quot;Yellow, HighIntensity&quot; /&amp;gt;
        &amp;lt;backColor value=&quot;Red&quot; /&amp;gt;
      &amp;lt;/mapping&amp;gt;
      &amp;lt;layout type=&quot;log4net.Layout.PatternLayout&quot;&amp;gt;
        &amp;lt;conversionPattern value=&quot;---------------------------------------------------%newline发生时间：%date %newline事件级别：%-5level%newline事件来源：%logger%newline事件行号：%line%newline日志内容：%message%newline&quot; /&amp;gt;
      &amp;lt;/layout&amp;gt;
    &amp;lt;/appender&amp;gt;
    &amp;lt;appender name=&quot;UdpAppender&quot; type=&quot;log4net.Appender.UdpAppender&quot;&amp;gt;
      &amp;lt;remoteAddress value=&quot;127.0.0.1&quot; /&amp;gt;
      &amp;lt;remotePort value=&quot;7071&quot; /&amp;gt;
      &amp;lt;layout type=&quot;log4net.Layout.XmlLayoutSchemaLog4j&quot; /&amp;gt;
    &amp;lt;/appender&amp;gt;
    &amp;lt;root&amp;gt;
      &amp;lt;appender-ref ref=&quot;UdpAppender&quot; /&amp;gt;
    &amp;lt;/root&amp;gt;
  &amp;lt;/log4net&amp;gt;
&amp;lt;/configuration&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;怎么使用&quot;&gt;怎么使用&lt;/h2&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;private IKernel _kernel = null;
private ILogService _logService = null;
 
[TestInitialize]
public void SetUp()
{
    _kernel = new StandardKernel(new LogModule());
    Assert.IsNotNull(_kernel);
 
    _logService = _kernel.Get&amp;lt;ILogService&amp;gt;();
}
 
[TestMethod()]
public void DebugTest()
{
    _logService.Debug(&quot;DebugTest&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;结语&quot;&gt;结语&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;整个实现很简单，就是业务或者功能不依赖具体实现类，这也是开发中最基本原则；&lt;/li&gt;
&lt;li&gt;小弟不才，大佬轻拍；&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Wed, 10 Apr 2019 15:42:00 +0000</pubDate>
<dc:creator>MeetYan</dc:creator>
<og:description>背景 1. 项目开发中，我们或多或少会使用诸如NLog，Log4Net，Kafka+ELK等等日志套件； 2. 基于关注点分离原则，业务开发的时候不应该关注日志具体实现；并且后续能方便切换其他日志套件</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/MeetYan/p/10687029.html</dc:identifier>
</item>
<item>
<title>TypeScript 上手教程 - 刘哇勇</title>
<link>http://www.cnblogs.com/Wayou/p/typescript_starter_tutorial.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Wayou/p/typescript_starter_tutorial.html</guid>
<description>&lt;p&gt;无疑，对于大型项目来说，Vanilla Js 无法满足工程需求。早在 2016 年 Anuglar 在项目中引入 TypeScript 时，大概也是考虑到强类型约束对于大型工程的必要性，具体选型考虑可参考&lt;a href=&quot;https://vsavkin.com/writing-angular-2-in-typescript-1fa77c78d8e8&quot; rel=&quot;nofollow&quot;&gt;这篇文章&lt;/a&gt;。然后可以看到 TypeScript 在社区中逐渐升温。但凡社区中举足轻重的库，如果不是原生使用 TypeScript 编写，那么也是通过声明文件的方式对 TypeScript 提供支持，比如 React（虽然不是包含在官方仓库中，而是通过 &lt;code&gt;@types/react&lt;/code&gt;），同时官方脚手架工具（&lt;a href=&quot;https://github.com/facebook/create-react-app/releases/tag/v2.1.0&quot;&gt;v2.1.0&lt;/a&gt; 之后）也开始提供开箱即用的 TypeScript 支持，通过 &lt;code&gt;--typescript&lt;/code&gt; 参数开启。&lt;/p&gt;
&lt;p&gt;所以 TypeScript 绝对是趋势。它所带来的工程效率上的提升，是在使用 Vanilla Js 时无法体会到的。可能前期反而会因为类型约束而变得束手束脚影响效率，但这是个学习成本的问题，对于任何一门技术而言都会存在。&lt;/p&gt;
&lt;p&gt;如果你有 Java 或 C# 的基础，那 TypeScript 学起来几乎没什么成本。&lt;/p&gt;
&lt;h2&gt;安装与配置&lt;/h2&gt;
&lt;h3&gt;安装&lt;/h3&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
$ npm install -g typescript
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;#&lt;/span&gt; or&lt;/span&gt;
$ yarn global add typescript
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;安装成功后，其 cli 命令为 &lt;code&gt;tsc&lt;/code&gt;，比如查看版本，&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
$ tsc --version
Version 3.3.3333
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;常用的命令：&lt;/p&gt;
&lt;h4&gt;编译文件&lt;/h4&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot;&gt;
&lt;pre&gt;
$ tsc main.ts
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;编译时传递编译参数：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
$ tsc --target es3 main.ts
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;完整的编译参数可在官网 &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/compiler-options.html&quot; rel=&quot;nofollow&quot;&gt;Compiler Options 文档&lt;/a&gt;中查阅。&lt;/p&gt;
&lt;h4&gt;初始化配置文件&lt;/h4&gt;
&lt;p&gt;除了通过 CLI 传递编译参数控制编译的行为，也可通过创建 &lt;code&gt;tsconfig.json&lt;/code&gt; 文件指定编译参数。对于项目中使用来说，肯定是使用配置文件比较方便，而且，有些参数只支持通过配置文件来设置，比如 &lt;code&gt;path&lt;/code&gt;，&lt;code&gt;rootDirs&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
$ tsc --init
message TS6071: Successfully created a tsconfig.json file.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该命令在当前目录创建一个 &lt;code&gt;tsconfig.json&lt;/code&gt; 文件，每个配置都包含注释。完整的配置项也可在官网&lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/compiler-options.html&quot; rel=&quot;nofollow&quot;&gt;Compiler Options 文档&lt;/a&gt;中查阅，根据自己需要和项目需求进行合理配置。大部分情况下你只会因为有某个需求才会去刻意研究如何配置，比如要改变输出类型设置 &lt;code&gt;target&lt;/code&gt;，写码过程中发现 &lt;code&gt;Object.assign&lt;/code&gt; 不可用发现需要添加 &lt;code&gt;lib&lt;/code&gt; 插件。所以不必被庞大的配置参数惊吓到，只用的时候再搜索即可。&lt;/p&gt;
&lt;details readability=&quot;33.5&quot;&gt;tsconfig.json
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;72&quot;&gt;
&lt;pre&gt;
{
  &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;compilerOptions&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; {
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;/*&lt;/span&gt; Basic Options &lt;span class=&quot;pl-c&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;
    &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;target&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;es5&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;/*&lt;/span&gt; Specify ECMAScript target version: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017','ES2018' or 'ESNEXT'. &lt;span class=&quot;pl-c&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;,
    &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;module&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;commonjs&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;/*&lt;/span&gt; Specify module code generation: 'none', 'commonjs', 'amd', 'system', 'umd', 'es2015', or 'ESNext'. &lt;span class=&quot;pl-c&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;,
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;lib&quot;: [],                             /* Specify library files to be included in the compilation. */&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;allowJs&quot;: true,                       /* Allow javascript files to be compiled. */&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;checkJs&quot;: true,                       /* Report errors in .js files. */&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;jsx&quot;: &quot;preserve&quot;,                     /* Specify JSX code generation: 'preserve', 'react-native', or 'react'. */&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;declaration&quot;: true,                   /* Generates corresponding '.d.ts' file. */&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;declarationMap&quot;: true,                /* Generates a sourcemap for each corresponding '.d.ts' file. */&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;sourceMap&quot;: true,                     /* Generates corresponding '.map' file. */&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;outFile&quot;: &quot;./&quot;,                       /* Concatenate and emit output to single file. */&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;outDir&quot;: &quot;./&quot;,                        /* Redirect output structure to the directory. */&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;rootDir&quot;: &quot;./&quot;,                       /* Specify the root directory of input files. Use to control the output directory structure with --outDir. */&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;composite&quot;: true,                     /* Enable project compilation */&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;removeComments&quot;: true,                /* Do not emit comments to output. */&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;noEmit&quot;: true,                        /* Do not emit outputs. */&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;importHelpers&quot;: true,                 /* Import emit helpers from 'tslib'. */&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;downlevelIteration&quot;: true,            /* Provide full support for iterables in 'for-of', spread, and destructuring when targeting 'ES5' or 'ES3'. */&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;isolatedModules&quot;: true,               /* Transpile each file as a separate module (similar to 'ts.transpileModule'). */&lt;/span&gt;

    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;/*&lt;/span&gt; Strict Type-Checking Options &lt;span class=&quot;pl-c&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;
    &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;strict&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;/*&lt;/span&gt; Enable all strict type-checking options. &lt;span class=&quot;pl-c&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;,
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;noImplicitAny&quot;: true,                 /* Raise error on expressions and declarations with an implied 'any' type. */&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;strictNullChecks&quot;: true,              /* Enable strict null checks. */&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;strictFunctionTypes&quot;: true,           /* Enable strict checking of function types. */&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;strictBindCallApply&quot;: true,           /* Enable strict 'bind', 'call', and 'apply' methods on functions. */&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;strictPropertyInitialization&quot;: true,  /* Enable strict checking of property initialization in classes. */&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;noImplicitThis&quot;: true,                /* Raise error on 'this' expressions with an implied 'any' type. */&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;alwaysStrict&quot;: true,                  /* Parse in strict mode and emit &quot;use strict&quot; for each source file. */&lt;/span&gt;

    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;/*&lt;/span&gt; Additional Checks &lt;span class=&quot;pl-c&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;noUnusedLocals&quot;: true,                /* Report errors on unused locals. */&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;noUnusedParameters&quot;: true,            /* Report errors on unused parameters. */&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;noImplicitReturns&quot;: true,             /* Report error when not all code paths in function return a value. */&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;noFallthroughCasesInSwitch&quot;: true,    /* Report errors for fallthrough cases in switch statement. */&lt;/span&gt;

    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;/*&lt;/span&gt; Module Resolution Options &lt;span class=&quot;pl-c&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;moduleResolution&quot;: &quot;node&quot;,            /* Specify module resolution strategy: 'node' (Node.js) or 'classic' (TypeScript pre-1.6). */&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;baseUrl&quot;: &quot;./&quot;,                       /* Base directory to resolve non-absolute module names. */&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;paths&quot;: {},                           /* A series of entries which re-map imports to lookup locations relative to the 'baseUrl'. */&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;rootDirs&quot;: [],                        /* List of root folders whose combined content represents the structure of the project at runtime. */&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;typeRoots&quot;: [],                       /* List of folders to include type definitions from. */&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;types&quot;: [],                           /* Type declaration files to be included in compilation. */&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;allowSyntheticDefaultImports&quot;: true,  /* Allow default imports from modules with no default export. This does not affect code emit, just typechecking. */&lt;/span&gt;
    &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;esModuleInterop&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;/*&lt;/span&gt; Enables emit interoperability between CommonJS and ES Modules via creation of namespace objects for all imports. Implies 'allowSyntheticDefaultImports'. &lt;span class=&quot;pl-c&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;preserveSymlinks&quot;: true,              /* Do not resolve the real path of symlinks. */&lt;/span&gt;

    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;/*&lt;/span&gt; Source Map Options &lt;span class=&quot;pl-c&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;sourceRoot&quot;: &quot;&quot;,                      /* Specify the location where debugger should locate TypeScript files instead of source locations. */&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;mapRoot&quot;: &quot;&quot;,                         /* Specify the location where debugger should locate map files instead of generated locations. */&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;inlineSourceMap&quot;: true,               /* Emit a single file with source maps instead of having a separate file. */&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;inlineSources&quot;: true,                 /* Emit the source alongside the sourcemaps within a single file; requires '--inlineSourceMap' or '--sourceMap' to be set. */&lt;/span&gt;

    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;/*&lt;/span&gt; Experimental Options &lt;span class=&quot;pl-c&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;experimentalDecorators&quot;: true,        /* Enables experimental support for ES7 decorators. */&lt;/span&gt;
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;emitDecoratorMetadata&quot;: true,         /* Enables experimental support for emitting type metadata for decorators. */&lt;/span&gt;
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/details&gt;&lt;h3&gt;VS Code 上手&lt;/h3&gt;
&lt;p&gt;TS 带来的一大好处是其静态类型检查能跟编辑器很好地结合，智能健全的自动提示自不必说。推荐 &lt;a href=&quot;https://code.visualstudio.com&quot; rel=&quot;nofollow&quot;&gt;VS Code&lt;/a&gt; 作为编辑，其对 TypeScript 有原生的支持。&lt;/p&gt;
&lt;p&gt;用好这几个快捷键，更是提升效率的关键。&lt;/p&gt;
&lt;h4&gt;重命名&lt;/h4&gt;
&lt;p&gt;通过 &lt;kbd&gt;F2&lt;/kbd&gt; 对标识符重重命名。这里标识符可以是变量名，方法函数名，类名或者其他字面量。如果写代码过程中发现命名不合理想重命名，一定使用这个快捷键来操作，它的好处是，只需改一处，其他与该标识符有关的地方，将自动被批量替换成新的，甚至该标识符使用的地方不在同一个文件中，也能被正确地自动应用上变更后的名称。省去了人工替换和检查代码的麻烦。关键人工容易出错，搜索加替换的方式只是根据字符串来进行的，而该命令是通过分析代码的语法树进行的。&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://user-images.githubusercontent.com/3783096/55686721-560ae880-5997-11e9-8d74-7dfe51482e3a.gif&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/3783096/55686721-560ae880-5997-11e9-8d74-7dfe51482e3a.gif&quot; alt=&quot;使用 &amp;lt;kbd&amp;gt;F2&amp;lt;/kbd&amp;gt; 进行变量重命名的展示&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;使用 &lt;kbd&gt;F2&lt;/kbd&gt; 进行变量重命名的展示&lt;/p&gt;
&lt;h4&gt;快速跳转&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;kbd&gt;F12&lt;/kbd&gt; 跳转到定义。这应该是使用最为频繁的了。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://user-images.githubusercontent.com/3783096/55686738-894d7780-5997-11e9-86b5-188661edce21.gif&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/3783096/55686738-894d7780-5997-11e9-86b5-188661edce21.gif&quot; alt=&quot;跳转到定义&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;跳转到定义&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;kbd&gt;F7&lt;/kbd&gt; 当前文件中相同的标识符间循环切换。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://user-images.githubusercontent.com/3783096/55686747-a5511900-5997-11e9-8d88-0e5e31b4cf3a.gif&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/3783096/55686747-a5511900-5997-11e9-8d88-0e5e31b4cf3a.gif&quot; alt=&quot;标识符间的跳转切换&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;标识符间的跳转切换&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;kbd&gt;F8&lt;/kbd&gt; 在错误处循环切换。这个跳转可让你在修正代码中的错误时变得非常快捷。它直接将光标定位到错误处，修改好本处的错误后，继续 &lt;kbd&gt;F8&lt;/kbd&gt; 跳转到下一处。一个很好的应用场景是对 js 代码的迁移，将文件扩展名由 &lt;code&gt;.js&lt;/code&gt; 改为 &lt;code&gt;.ts&lt;/code&gt;，大概率你会看到满屏飘红的错误提示，通过不断地 &lt;kbd&gt;F8&lt;/kbd&gt; 来由上往下定位修改简直再顺畅不过了。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://user-images.githubusercontent.com/3783096/55686754-bef26080-5997-11e9-9a83-ba658e949e26.gif&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/3783096/55686754-bef26080-5997-11e9-9a83-ba658e949e26.gif&quot; alt=&quot;在报错处循环切换&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;在报错处循环切换&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;kbd&gt;control&lt;/kbd&gt; + &lt;kbd&gt;-&lt;/kbd&gt;/&lt;kbd&gt;=&lt;/kbd&gt; 在鼠标历史位置间来回切换。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://user-images.githubusercontent.com/3783096/55686764-d7627b00-5997-11e9-8cc0-98619c3f8a4c.gif&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/3783096/55686764-d7627b00-5997-11e9-8cc0-98619c3f8a4c.gif&quot; alt=&quot;光标位置的来回切换&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;光标位置的来回切换&lt;/p&gt;
&lt;h4&gt;命令面板&lt;/h4&gt;
&lt;p&gt;通过 &lt;kbd&gt;command&lt;/kbd&gt; + &lt;kbd&gt;shift&lt;/kbd&gt; + &lt;kbd&gt;p&lt;/kbd&gt; 打开命令面板。几乎所有功能可以通过这里的命令来完成。&lt;/p&gt;
&lt;p&gt;比如，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;代码折叠与展开&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://user-images.githubusercontent.com/3783096/55686777-f4974980-5997-11e9-9fe0-6e65db5e6910.gif&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/3783096/55686777-f4974980-5997-11e9-9fe0-6e65db5e6910.gif&quot; alt=&quot;代码折叠与展开&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;代码折叠与展开&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;主题的切换&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://user-images.githubusercontent.com/3783096/55686786-1395db80-5998-11e9-902f-d793a71720b0.gif&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/3783096/55686786-1395db80-5998-11e9-902f-d793a71720b0.gif&quot; alt=&quot;主题的切换&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;主题的切换&lt;/p&gt;
&lt;p&gt;最后，你始终可通过搜索 &lt;code&gt;keyboard shortcurt&lt;/code&gt; 来查看所有的快捷键。&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://user-images.githubusercontent.com/3783096/55686796-3aeca880-5998-11e9-802c-5bf62345f291.gif&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/3783096/55686796-3aeca880-5998-11e9-802c-5bf62345f291.gif&quot; alt=&quot;快捷键列表&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;快捷键列表&lt;/p&gt;
&lt;h3&gt;在线工具&lt;/h3&gt;
&lt;p&gt;如果本地没有环境，可通过 &lt;a href=&quot;http://www.typescriptlang.org/play/&quot; rel=&quot;nofollow&quot;&gt;Playground ・ TypeScript&lt;/a&gt; 这个在线的编辑器，编辑 TypeScript 和时实查看输出。&lt;/p&gt;
&lt;h2&gt;类型声明&lt;/h2&gt;
&lt;p&gt;TypeScript 中，通过在变量后面添加冒号指定其类型。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; fruit&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; string;
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; 🚨Variable 'fruit' is used before being assigned.&lt;/span&gt;
&lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(fruit);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当声明 &lt;code&gt;fruit&lt;/code&gt; 为字符串之后，TypeScript 会保证该变量的类型始终是字符串。但在未赋值之前，其实它真实的类型是 undefined。这种情况下，TypeScript 会报错以阻止你在未初始化之前就使用。&lt;/p&gt;
&lt;p&gt;函数的类型包含了入参的类型和返回值的类型。入参自不必说，像上面那样冒号后指定，而返回值的类型，则是通过在入参列表结束的括号后添加冒号来指定的。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;addOne&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;number&lt;/span&gt;): number {
  &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; num &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果每次写个变量或函数都需要手动指定其类型，岂不是很麻烦。所以，在一切能够推断类型的情况下，是不必手动指定的。比如声明变量并初始化，会根据初始化的值来推断变量类型。函数会根据其 return 的值来推断其返回类型。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;/**&lt;/span&gt; 推断出的函数类型为：(num: number) =&amp;gt; number &lt;span class=&quot;pl-c&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;addOne&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;number&lt;/span&gt;) {
  &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; num &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;;
}

&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;/**&lt;/span&gt; age:number &lt;span class=&quot;pl-c&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;age&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;18&lt;/span&gt;;
&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;virtualAge&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;addOne&lt;/span&gt;(age);

&lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;在下虚岁 &lt;span class=&quot;pl-s1&quot;&gt;&lt;span class=&quot;pl-pse&quot;&gt;${&lt;/span&gt;virtualAge&lt;span class=&quot;pl-pse&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;TypeScript 中的类型&lt;/h2&gt;
&lt;p&gt;JavaScript 中原生有 7 中数据类型，其中 Ojbect 为可看成数据集合，而其他 6 种（布尔，字符串，数字，&lt;code&gt;undefined&lt;/code&gt;， &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;Symbol&lt;/code&gt;），则是原始（primitive）数据类型。&lt;/p&gt;
&lt;p&gt;虽然 JavaScript 中有数据类型的概念，但它是动态的，变量的类型根据所存储的值而变化。TypeScript 作为其超集，将上面的数据类型进行了扩充，在 TypeScript 里，可以通过各种组合创建出更加复杂的数据类型。同时，TypeScript 让数据类型固定，成为静态可分析的。&lt;/p&gt;
&lt;p&gt;比如，如果一个函数的入参指定为数字，那么调用的时候传递了字符串，这个错误在写码过程中就直接可检查到并抛出。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;addOne&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;number&lt;/span&gt;) {
  &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; num &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;;
}

&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;/**&lt;/span&gt; 🚨Argument of type '&quot;blah&quot;' is not assignable to parameter of type 'number'. &lt;span class=&quot;pl-c&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;pl-en&quot;&gt;addOne&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;blah&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;JavaScript 原始类型加上扩展的几个类型（Any, Never, Void, Enum）组成了 TypeScript 中基本的类型。更加详细的信息可参考 &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/basic-types.html&quot; rel=&quot;nofollow&quot;&gt;Basic Types&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;Boolean&lt;/h3&gt;
&lt;p&gt;布尔值，其值只能是 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; isEmployee&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; boolean &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;false&lt;/span&gt;;

&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;hasPermission&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;role&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;string&lt;/span&gt;): boolean {
  &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; role &lt;span class=&quot;pl-k&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;admin&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;false&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Number&lt;/h3&gt;
&lt;p&gt;数字类型，不区分整形与浮点，所有数字均当作浮点数字对待。同时也支持二进制，八进制，十六进制数字。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; decimal&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; number &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;6&lt;/span&gt;;
&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; hex&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; number &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0xf00d&lt;/span&gt;;
&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; binary&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; number &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0b1010&lt;/span&gt;;
&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; octal&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; number &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0o744&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;String&lt;/h3&gt;
&lt;p&gt;字符串类型。TypeScript 中可使用 ES6 以之后这些还未实现的功能，所以模板字符串是可以放心使用的。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; fruit&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; string &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;Apple&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;;
&lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;My favourite fruit is &lt;span class=&quot;pl-s1&quot;&gt;&lt;span class=&quot;pl-pse&quot;&gt;${&lt;/span&gt;fruit&lt;span class=&quot;pl-pse&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Symbol&lt;/h3&gt;
&lt;p&gt;ES6 中新增，由 &lt;code&gt;Symbol()&lt;/code&gt; 返回的类型。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; sym &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;Symbol&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;foo&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
&lt;span class=&quot;pl-k&quot;&gt;typeof&lt;/span&gt; sym; &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; &quot;symbol&quot;&lt;/span&gt;
&lt;span class=&quot;pl-smi&quot;&gt;sym&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;toString&lt;/span&gt;(); &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; Symbol(foo)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意，因为是新特性，需要在 &lt;code&gt;tsconfig.json&lt;/code&gt; 中添加相应的库支持，否则编译会报错。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
{
      &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;lib&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; [&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;dom&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;,&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;es2015&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;] &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;/*&lt;/span&gt; Specify library files to be included in the compilation. &lt;span class=&quot;pl-c&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Object&lt;/h3&gt;
&lt;p&gt;除了 JavaScript 中 6 个原始类型之外的类型。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;create&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;source&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;Object&lt;/span&gt;) {
  &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;Object&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;create&lt;/span&gt;(source);
}

&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; ✅&lt;/span&gt;
&lt;span class=&quot;pl-en&quot;&gt;create&lt;/span&gt;({});
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; ✅&lt;/span&gt;
&lt;span class=&quot;pl-en&quot;&gt;create&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;window&lt;/span&gt;);

&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; 🚨Argument of type 'undefined' is not assignable to parameter of type 'Object'&lt;/span&gt;
&lt;span class=&quot;pl-en&quot;&gt;create&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;null&lt;/span&gt;);

&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; 🚨Argument of type 'undefined' is not assignable to parameter of type 'Object'.ts(2345)&lt;/span&gt;
&lt;span class=&quot;pl-en&quot;&gt;create&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;undefined&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Null 与 Undefined&lt;/h3&gt;
&lt;p&gt;两者其实是其他任意类型的子类型。比如，一个变量定义后没有初始化，此时其值自动为 &lt;code&gt;undefined&lt;/code&gt;。这说明，&lt;code&gt;undefined&lt;/code&gt; 是可以赋值给这个类型的。当我们想把变量的值取消，将其置空时，可将其设置为 &lt;code&gt;null&lt;/code&gt;，&lt;code&gt;null&lt;/code&gt; 也是可以赋值给其他类型变量的，前提是 &lt;code&gt;tsconfig.json&lt;/code&gt; 中没有开启 &lt;code&gt;strict:true&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; age&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; number;
&lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(age); &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; undefined&lt;/span&gt;

age &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;9&lt;/span&gt;;
&lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(age); &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; 9&lt;/span&gt;

age &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;null&lt;/span&gt;;
&lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(age); &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; null&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当开启 &lt;code&gt;strict:true&lt;/code&gt; 强制检查后，TypeScript 会对类型进行严格的检查。上面就不能在未初始化的情况下使用变量，同时也不能将 &lt;code&gt;null&lt;/code&gt; 赋值给 &lt;code&gt;number&lt;/code&gt; 类型。&lt;/p&gt;
&lt;p&gt;对于这两种类型，在强制检查下，除非显式对变量进行声明其可空可未初始化。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-diff&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-mi1&quot;&gt;&lt;span class=&quot;pl-mi1&quot;&gt;+&lt;/span&gt; let age: number | null | undefined;&lt;/span&gt;
console.log(age); // undefined

age = 9;
console.log(age); // 9

age = null;
console.log(age); // null
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里 &lt;code&gt;number | null | undefined&lt;/code&gt; 是一个组合类型（union type），后面会有提到。&lt;/p&gt;
&lt;p&gt;一般来说，建议开启强制检查，这样 TypeScript 能够最大化帮我们发现代码中的错误，在写码时就发现问题。&lt;/p&gt;
&lt;h3&gt;Any&lt;/h3&gt;
&lt;p&gt;表示任意类型。此时等同于普通的 JavaScript 代码，因为标记为 &lt;code&gt;any&lt;/code&gt; 后将会跳过 TypeScript 的类型检查。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; someVar&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; any;
someVar &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;饭后百步走，活到 99&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;; &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; ✅&lt;/span&gt;
someVar &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;99&lt;/span&gt;; &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; ✅&lt;/span&gt;
someVar &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;undefined&lt;/span&gt;; &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; ✅&lt;/span&gt;
someVar &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;null&lt;/span&gt;; &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; ✅&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;即便在开启强制检查的情况下，上面的操作是没有任何问题的。一般情况下，只在一些特殊情况下使用 any，比如老代码的兼容，三方库代码的引入。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
declare &lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; $&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; any;

&lt;span class=&quot;pl-smi&quot;&gt;$&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;extenfd&lt;/span&gt;({}, { foo&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;foo&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里，因为 jQuery 是没有类型的三方库代码，但我们知道页面中引入后是可以调用它上面的方法的，只是 TypeScript 不识别，所以我们通过声明一个 &lt;code&gt;any&lt;/code&gt; 类型的变量来&lt;strong&gt;快速&lt;/strong&gt;解决这个问题。不快速的办法就是自己动手为其编写类型&lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html&quot; rel=&quot;nofollow&quot;&gt;声明文件&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;Void&lt;/h3&gt;
&lt;p&gt;常见于函数没有返回值的情况。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;/**&lt;/span&gt; () =&amp;gt; void &lt;span class=&quot;pl-c&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;foo&lt;/span&gt;() {
  &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;foo works&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果将变量显式设置为 &lt;code&gt;void&lt;/code&gt;，没有多大实际意义。因为变量始终是要用来承载有用的值的，如果你发现有这种需要，可使用 &lt;code&gt;null|undefiend&lt;/code&gt; 代替。&lt;/p&gt;
&lt;h3&gt;Never&lt;/h3&gt;
&lt;p&gt;这个类型就比较有意思了，正如其名，表示永远也不会发生的类型。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;error&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;string&lt;/span&gt;): never {
  &lt;span class=&quot;pl-k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Error&lt;/span&gt;(message);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;关于 &lt;code&gt;never&lt;/code&gt; 类型，印象中最巧妙的一个示例来自 TypeScript &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/advanced-types.html&quot; rel=&quot;nofollow&quot;&gt;Advanced Types&lt;/a&gt; 文档中关于 Discriminated Unions 的描述。既然是&lt;strong&gt;高级类型&lt;/strong&gt;，下面的示例对于初学者来说如果看不懂就先跳过吧。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;interface&lt;/span&gt; Square {
  kind&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;square&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;;
  size&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; number;
}
&lt;span class=&quot;pl-k&quot;&gt;interface&lt;/span&gt; Rectangle {
  kind&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;rectangle&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;;
  width&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; number;
  height&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; number;
}
&lt;span class=&quot;pl-k&quot;&gt;interface&lt;/span&gt; Circle {
  kind&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;circle&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;;
  radius&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; number;
}

type Shape &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; Square &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; Rectangle &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; Circle;

&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;assertNever&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;never&lt;/span&gt;): never {
  &lt;span class=&quot;pl-k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Error&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;Unexpected object: &lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; x);
}

&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;area&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;Shape&lt;/span&gt;) {
  &lt;span class=&quot;pl-k&quot;&gt;switch&lt;/span&gt; (&lt;span class=&quot;pl-smi&quot;&gt;s&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;kind&lt;/span&gt;) {
    &lt;span class=&quot;pl-k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;square&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;:
      &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;s&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;s&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;size&lt;/span&gt;;
    &lt;span class=&quot;pl-k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;rectangle&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;:
      &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;s&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;height&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;s&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;width&lt;/span&gt;;
    &lt;span class=&quot;pl-k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;circle&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;:
      &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;Math&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;PI&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;s&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;radius&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;**&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;2&lt;/span&gt;;
    &lt;span class=&quot;pl-k&quot;&gt;default&lt;/span&gt;:
      &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;assertNever&lt;/span&gt;(s); &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; error here if there are missing cases&lt;/span&gt;
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里定义了三种基础的形状类型 &lt;code&gt;Square&lt;/code&gt;，&lt;code&gt;Rectangle&lt;/code&gt;，&lt;code&gt;Circle&lt;/code&gt;。同时将三种类型进行组合创建了一个联合类型 （Union Type） &lt;code&gt;Shape&lt;/code&gt;。 函数 &lt;code&gt;area&lt;/code&gt; 接收一个 &lt;code&gt;Shape&lt;/code&gt; 类型的数据并对其进行处理。因为 &lt;code&gt;Shape&lt;/code&gt; 实际上有可能是三种类型中的其中一种，并不确定，所以需要对每个类型走不同的逻辑来处理。这里通过 &lt;code&gt;never&lt;/code&gt; 实现了这样一个功能：假如后面我们又增加了一种新的形状类型，此时 &lt;code&gt;area&lt;/code&gt; 函数能够自动抛错，告诉我们新增的类型没有相应的 &lt;code&gt;case&lt;/code&gt; 分支来处理。&lt;/p&gt;
&lt;h3&gt;数组&lt;/h3&gt;
&lt;p&gt;数组本身是容器，需要上面的基本类型联合使用。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;/**&lt;/span&gt; 字符串数组 &lt;span class=&quot;pl-c&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; names&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt;string&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt;;

&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;/**&lt;/span&gt; 存放数字的数组 &lt;span class=&quot;pl-c&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; nums&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt;number&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt;;

&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;/**&lt;/span&gt; 数组中各元素类型不确定 &lt;span class=&quot;pl-c&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; data&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt;any&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;还可通过下面的方式来表示：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;/**&lt;/span&gt; 字符串数组 &lt;span class=&quot;pl-c&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; names&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; string[];

&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;/**&lt;/span&gt; 存放数字的数组 &lt;span class=&quot;pl-c&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; nums&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; number[];

&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;/**&lt;/span&gt; 数组中各元素类型不确定 &lt;span class=&quot;pl-c&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; data&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; any[];
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当数组中元数个数有限且提前知晓每个位置的类型时，可将这种数据声明成元组（tuple，如果你用过 Python 应该不会陌生）。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;12&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; point&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; [number, number] &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; [&lt;span class=&quot;pl-c1&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;5&lt;/span&gt;];
&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; formValidateResult&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; [booelan, string] &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; [&lt;span class=&quot;pl-c1&quot;&gt;false&lt;/span&gt;, &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;请输入用户名&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;];
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;枚举&lt;/h3&gt;
&lt;p&gt;枚举类型在强类型语言中是很常见的，用来标识变量可取的候选值。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;enum&lt;/span&gt; Gender {
    Male,
    Female
}

&lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;Gender&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;Female&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;===&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;); &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;枚举实质上是通过更加语义化的符号来表示数字类型的值，比如上面 &lt;code&gt;Gender.Female&lt;/code&gt; 代表的值是 &lt;code&gt;1&lt;/code&gt;，因为枚举默认从 0 开始。&lt;/p&gt;
&lt;p&gt;可通过手动指定的方式来改变默认的 0。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-diff&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
enum Gender {
&lt;span class=&quot;pl-mi1&quot;&gt;&lt;span class=&quot;pl-mi1&quot;&gt;+&lt;/span&gt;  Male = 1,&lt;/span&gt;
  Female
}

console.log(Gender.Female); // 2
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然，你也可以让枚举表示其他类型的值，而不是数字。只不过需要手动指定。如果手动指定非数字类型的值，那么枚举中的项是无法像数字那样自动自增以初始化自己，所以需要手动为每个项都显式指定一下它应该代表的值。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;enum&lt;/span&gt; Gender {
  Male &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;male&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;,
  Female &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; 🚨 Enum member must have initializer.&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;正确的做法：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;enum&lt;/span&gt; Gender {
  Male &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;male&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;,
  Female &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;female&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; ✅&lt;/span&gt;
}

&lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;Gender&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;Female&lt;/span&gt;); &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; female&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;枚举中的值也不一定都得是同一类型，所以下面这样也是可以的：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;enum&lt;/span&gt; Gender {
  Male &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;male&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;,
  Female &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; ✅also ojbk&lt;/span&gt;
}
&lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;Gender&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;Female&lt;/span&gt;); &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; 2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;函数类型&lt;/h3&gt;
&lt;p&gt;函数的类型包含了入参及返回值两部分。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot;&gt;
&lt;pre&gt;
(&lt;span class=&quot;pl-smi&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;number&lt;/span&gt;) &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; string;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看起来像其他静态类型语言比如 Java 中的抽象方法，只有声明没有实现的样子。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;14&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;interface&lt;/span&gt; Calculator {
  name&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; string;
  &lt;span class=&quot;pl-en&quot;&gt;calculate&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; (&lt;span class=&quot;pl-smi&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;number&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;number&lt;/span&gt;) &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; number;
}

&lt;span class=&quot;pl-k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Computer&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;implements&lt;/span&gt; Calculator {
  &lt;span class=&quot;pl-en&quot;&gt;constructor&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;string&lt;/span&gt;) {}
  &lt;span class=&quot;pl-en&quot;&gt;calculate&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;number&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;number&lt;/span&gt;) {
    &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; x &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; y;
  }
}

&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt; counter&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;Calculator&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; {
  name&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;counter&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;,
  &lt;span class=&quot;pl-en&quot;&gt;calculate&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; (&lt;span class=&quot;pl-smi&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;number&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;number&lt;/span&gt;) &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
    &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; x &lt;span class=&quot;pl-k&quot;&gt;-&lt;/span&gt; y;
  }
};
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;code&gt;interface&lt;/code&gt; 与 &lt;code&gt;type&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;通过上面的基本类型，可以抽象并定义对象。通过 &lt;code&gt;interface&lt;/code&gt; 或 &lt;code&gt;type&lt;/code&gt; 关键词，均可定义组合的复杂类型。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
type Role &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;manager&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;employee&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;;

&lt;span class=&quot;pl-k&quot;&gt;interface&lt;/span&gt; Person {
  name&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; string;
  age&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; number;
  role&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; Role;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过 &lt;code&gt;type&lt;/code&gt; 定义的类型，又叫 &lt;code&gt;type alias&lt;/code&gt;，除了通过它创建类型，还可方便地为现有类型创建别名，体现了其 &lt;code&gt;alias&lt;/code&gt; 的本意。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
type Name &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; string;
&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt; myName&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;Name&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;Tom&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的示例意义不大， type alias 在&lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/advanced-types.html&quot; rel=&quot;nofollow&quot;&gt;高级类型&lt;/a&gt;中的作用会非常明显，能够为复杂类型创建别名从而使用的时候只需要写别名即可。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
type Name &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; string;
type &lt;span class=&quot;pl-en&quot;&gt;NameResolver&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; () &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; string;
type NameOrResolver &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; Name &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; NameResolver;
&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;getName&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;NameOrResolver&lt;/span&gt;): Name {
  &lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;pl-k&quot;&gt;typeof&lt;/span&gt; n &lt;span class=&quot;pl-k&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;string&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;) {
    &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; n;
  } &lt;span class=&quot;pl-k&quot;&gt;else&lt;/span&gt; {
    &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;n&lt;/span&gt;();
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;两种类型在使用上，没多大差别，只是尽量在代码中保持风格统一。更加具体的差异分析可继续阅读 &lt;a href=&quot;https://github.com/wayou/wayou.github.io/issues/42&quot; data-hovercard-type=&quot;issue&quot; data-hovercard-url=&quot;/wayou/wayou.github.io/issues/42/hovercard&quot;&gt;TypeScript: type alias 与 interface&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;交叉类型与联合类型&lt;/h2&gt;
&lt;p&gt;交叉类型（Intersection Types）与联合类型（Union Types）也是属性高级类型中的内容，前面示例中有涉及到所以这里简单介绍。&lt;/p&gt;
&lt;p&gt;交叉类型是通过 &lt;code&gt;&amp;amp;&lt;/code&gt; 操作符创建的类型，表示新的类型为参与操作的这些类型的并集。它实际上是将多个类型进行合并，而不是像其名称那样取交集。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;interface&lt;/span&gt; Student {
  id&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; string;
  age&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; number;
}

&lt;span class=&quot;pl-k&quot;&gt;interface&lt;/span&gt; Employee {
  companyId&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; string;
}

type SocialMan &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; Student &lt;span class=&quot;pl-k&quot;&gt;&amp;amp;&lt;/span&gt; Employee;

&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; tom&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; SocialMan;

&lt;span class=&quot;pl-smi&quot;&gt;tom&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;age&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;5&lt;/span&gt;;
&lt;span class=&quot;pl-smi&quot;&gt;tom&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;companyId&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;CID5241&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;;
&lt;span class=&quot;pl-smi&quot;&gt;tom&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;ID3241&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当一个学生加上工人的属性，他成了一个社会人，嗯。&lt;/p&gt;
&lt;p&gt;联合类型（Union Types）正如创建这种类型所使用的操作符 &lt;code&gt;|&lt;/code&gt; 一样，他表示或的关系。新类型是个叠加态，在实际运行前，你不知道它到底所属哪种类型。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;addOne&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;string&lt;/span&gt;) {
  &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;/**&lt;/span&gt; 🚨 Operator '+' cannot be applied to types 'string | number' and '1'. &lt;span class=&quot;pl-c&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;
  &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; num &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;比如对入参加一的方法，JavaScript 中我们是可以这样干的，如果传入的是字符串，加号操作符会对其中一个做隐式转换。但结果可能不是你想要的数字加 1 而是变成了字符串相加。&lt;/p&gt;
&lt;p&gt;而 TypeScript 在此时就体现了其静态类型的优点，因为入参在这里是不确定的类型，随着输入的不同得到的结果是不可预期的，这大概率会导致 bug。而这个 bug 在 TypeScript 里被提前找了出来。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-diff&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
function addOne(num: number | string) {
  // ✅ 
&lt;span class=&quot;pl-mi1&quot;&gt;&lt;span class=&quot;pl-mi1&quot;&gt;+&lt;/span&gt;  return Number(num) + 1;&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;除了像上面入参不确定的情形，像前面示例有用到过的，将多个字符串联合，也是很常见的用法。甚至最佳实践中，建议你用联合字符串来代替枚举类型。But why? &lt;a href=&quot;https://medium.com/@martin_hotell/10-typescript-pro-tips-patterns-with-or-without-react-5799488d6680&quot; rel=&quot;nofollow&quot;&gt;参见这里&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
type Role &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;manager&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;employee&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;类型断言&lt;/h2&gt;
&lt;p&gt;某些情况下，TypeScript 无法自动推断类型，此时可人工干预，对类型进行显式转换，我们称之为类型断言（Type assertions）。通过在值的前面放置尖括号，括号中指定需要的类型。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; someValue&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; any &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;this is a string&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;;

&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; strLength&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; number &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; (&lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt;string&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt;someValue).&lt;span class=&quot;pl-c1&quot;&gt;length&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为尖括号在写 React 组件时会有问题，&lt;strong&gt;容易被错误地当成 JSX 标签&lt;/strong&gt;，所以 TypeScript 还支持另一种类型转换的操作，通过 &lt;code&gt;as&lt;/code&gt; 关键字。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; someValue&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; any &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;this is a string&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;;

&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; strLength&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; number &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; (someValue as string).&lt;span class=&quot;pl-c1&quot;&gt;length&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面看一个更加实际的情况：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;interface&lt;/span&gt; Person {
  name&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; string;
  gender&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;male&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;female&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;;
}

&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;sayName&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;person&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;Person&lt;/span&gt;) {
  &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(person);
}

&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;tom&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; {
  name&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;tom&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;,
  gender&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;male&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;
};

&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;/**&lt;/span&gt; 🚨Type 'string' is not assignable to type '&quot;male&quot; | &quot;female&quot;' &lt;span class=&quot;pl-c&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;pl-en&quot;&gt;sayName&lt;/span&gt;(tom);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里 &lt;code&gt;tom&lt;/code&gt; 没有显式指定为 &lt;code&gt;Person&lt;/code&gt; 类型，但其实因为 TypeScript 的类型约束的是数据的结构，只要是形状上兼容，就可以将 &lt;code&gt;tom&lt;/code&gt; 赋值给接收 &lt;code&gt;Person&lt;/code&gt; 类型的入参。 这种机制也类似于你声明了一个变量并赋值个数字，这个变量自动就被推断出类型为数字一样，然后可以在任何地方当作数字来用，即便你并没有显式指明。&lt;/p&gt;
&lt;p&gt;所以这个示例中，我们需要修正一下初始化 &lt;code&gt;tom&lt;/code&gt; 的对象中 &lt;code&gt;gender&lt;/code&gt; 字段的类型，然后 TypeScript 就能正确推断出 &lt;code&gt;tom&lt;/code&gt; 是个 &lt;code&gt;Person&lt;/code&gt; 类型。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;interface&lt;/span&gt; Person {
  name&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; string;
  gender&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;male&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;female&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;;
}

&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;sayName&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;person&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;Person&lt;/span&gt;) {
  &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(person);
}

&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;tom&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; {
  name&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;tom&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;,
  gender&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;male&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; as &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;male&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;female&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;
};

&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;/**&lt;/span&gt; ✅ ojbk &lt;span class=&quot;pl-c&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;pl-en&quot;&gt;sayName&lt;/span&gt;(tom);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结合前面提到的类型别名，这里可以用 &lt;code&gt;type&lt;/code&gt; 为性别创建一个别名类型，减少冗余。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-diff&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-mi1&quot;&gt;&lt;span class=&quot;pl-mi1&quot;&gt;+&lt;/span&gt; type Gender = &quot;male&quot; | &quot;female&quot;;&lt;/span&gt;

interface Person {
  name: string;
&lt;span class=&quot;pl-mi1&quot;&gt;&lt;span class=&quot;pl-mi1&quot;&gt;+&lt;/span&gt;  gender: Gender;&lt;/span&gt;
}

function sayName(person: Person) {
  console.log(person);
}

const tom = {
  name: &quot;tom&quot;,
&lt;span class=&quot;pl-mi1&quot;&gt;&lt;span class=&quot;pl-mi1&quot;&gt;+&lt;/span&gt;  gender: &quot;male&quot; as Gender&lt;/span&gt;
};


sayName(tom);
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;可选参数与可空字段&lt;/h2&gt;
&lt;p&gt;定义类型时，如果字段后跟随一个问号，表示该字段可空，此时效果相当于是该类型自动与 &lt;code&gt;undefined&lt;/code&gt; 进行了联合操作。以下两个类型是等效的。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
type Person &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; {
  name&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; string,
  age&lt;span class=&quot;pl-k&quot;&gt;?:&lt;/span&gt; number
};

type Person2 &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; {
  name&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; string,
  age&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; number &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;undefined&lt;/span&gt;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于函数入参而言，入参加上问号后，可将入参标识为可选，调用时可不传递。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;number&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;?:&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;number&lt;/span&gt;) {
  &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; x &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; (y &lt;span class=&quot;pl-k&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但此时可选的入参需要在参数列表中位于非可选的后面，像这样交换顺序后是不行的：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;/**&lt;/span&gt; 🚨 A required parameter cannot follow an optional parameter. &lt;span class=&quot;pl-c&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;?:&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;number&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;number&lt;/span&gt;) {
  &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; x &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; (y &lt;span class=&quot;pl-k&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;了解了一些基本的类型知识和写法就可以进行简单的业务编写了。你可以从官方的这个&lt;a href=&quot;https://www.typescriptlang.org/samples/&quot; rel=&quot;nofollow&quot;&gt;模板页面&lt;/a&gt;找到适合自己的技术栈作为练手的开始。&lt;/p&gt;
&lt;p&gt;然后，可以系统地浏览一遍 &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/basic-types.html&quot; rel=&quot;nofollow&quot;&gt;Handbook&lt;/a&gt;，对 TypeScript 整体有个健全的了解。&lt;/p&gt;
&lt;p&gt;其中 &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/advanced-types.html&quot; rel=&quot;nofollow&quot;&gt;Advanced Types&lt;/a&gt; 章节里可以学习到进阶的类型定义和花式玩法，高级类型对于库的作者或写通用公共模块来说很有必要去了解。&lt;/p&gt;
&lt;h2&gt;相关资源&lt;/h2&gt;
</description>
<pubDate>Wed, 10 Apr 2019 15:41:00 +0000</pubDate>
<dc:creator>刘哇勇</dc:creator>
<og:description>无疑，对于大型项目来说，Vanilla Js 无法满足工程需求。早在 2016 年 Anuglar 在项目中引入 TypeScript 时，大概也是考虑到强类型约束对于大型工程的必要性，具体选型考虑可</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Wayou/p/typescript_starter_tutorial.html</dc:identifier>
</item>
<item>
<title>设计模式-序 - 疯子·策天</title>
<link>http://www.cnblogs.com/planheaven/p/10686967.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/planheaven/p/10686967.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　一、什么是设计模式？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　“每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能一次又一次的使用该方案而不必做重复的劳动”。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　二、模式四个基本要素&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　1.模式名称 （pattern name）&lt;/strong&gt; 一个助记名，用一两个词来描述模式的问题、解决方案和效果。也便于我们与他人交流设计思想和设计结果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　2.问题（problem）&lt;/strong&gt; 描述了应该在何时使用模式。解释了设计问题和问题存在的前因后果。有时候问题部分会包括使用模式必须满足的一系列先决条件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　3.解决方案（solution）&lt;/strong&gt; 描述了设计的组成成分，它们之间的相互关系及各自的指责和协作方式。模式就像是一个模板，可以应用于多种不同的场合。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　4.效果（consequences）&lt;/strong&gt; 描述了模式应用的效果及使用模式应权衡的问题。软件大多关注时间和空间的衡量，它们也表述了语言和实现问题。因为复用是面向对象设计的要素之一，所以模式效果包括它对系统的灵活性，扩充性（扩展性）或可移植性的影响，显示的列出这些效果对理解和评价模式很有帮助。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　三、模式编目&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　按首字母顺序依次为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 　  Abstract Factory 抽象工厂模式：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Adapter 适配器模式：将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能在一起工作的那些类可以一起工作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Bridge 桥接模式：将抽象部分与它的实现部分分离，使他们都可以独立的变化。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Builder 建造者模式：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Chain of Responsibility 责任链模式： 为解除请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Command 命令模式：将请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Composite 组合模式：将对象组合成树形结构以表示 “部分-整体”的层次结构。 Composite使得客户对单个对象和复合对象的使用具有一致性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Decorator 装饰者模式：动态的给一个对象添加一些额外的职责。就扩展功能而言，Decorator模式比生成子类方式更灵活。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Facade  外观模式：为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Factory Method 工厂方法：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。Factory Method使一个类的实例化延迟到其子类。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Flyweight 享元模式： 运用共享技术有效地支持大量细粒度的对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Interpreter 解释器模式：给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Iterator  迭代器模式：提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Mediator 中介者模式：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显示地相互引用，从而使其耦合松散，而且可以独立地改变他们之间的交互。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Memento 备忘录模式：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到保存的状态。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Observer 观察者模式：定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动刷新。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Prototype 原型模式：用原型实例指定创建对象的种类，并通过拷贝这个原型来创建新的对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Proxy 代理模式：为其他对象提供一个代理以控制对这个对象的访问。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Singleton 单例模式：保证一个类仅有一个实例，并提供一个访问它的全局访问点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　State 状态模式：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它所属的类。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Strategy 策略模式：定义一系列的算法，把他们一个个封装起来，并且使他们可相互替换。本模式使得算法的变化可以独立于使用它的客户。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Template Method 模板方法：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Visitor 访问者模式：表示一个作用于某个对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　四、模式分类&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　模式分类依据两条准则：目的准则，范围准则&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　目的准则，即模式是用来完成什么工作的。模式依据其目的可以分为 &lt;strong&gt;创建型（Creational）&lt;/strong&gt;、&lt;strong&gt;结构型（Structural）&lt;/strong&gt;、和&lt;strong&gt;行为型（Behavioral）&lt;/strong&gt;三种。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　范围准则，指定模式主要用于类还是用于对象。&lt;strong&gt;类模式&lt;/strong&gt;处理类与子类之间的关系，这些关系通过继承建立，是静态的，在编译的时刻便确立下来了。&lt;strong&gt;对象模式&lt;/strong&gt;处理对象间的关系，这些关系在运行时刻是可以变化的，更具有动态性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　模式分类如下图 4-1所示&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1188576/201904/1188576-20190410232818631-33640463.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　图4-1模式的分类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 10 Apr 2019 15:29:00 +0000</pubDate>
<dc:creator>疯子&amp;#183;策天</dc:creator>
<og:description>一、什么是设计模式？ “每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能一次又一次的使用该方案而不必做重复的劳动”。 二、模式四个基本要素 1.模式名称 （p</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/planheaven/p/10686967.html</dc:identifier>
</item>
<item>
<title>WPF 通过线程使用ProcessBar - 风幻影</title>
<link>http://www.cnblogs.com/hglSV/p/10686958.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hglSV/p/10686958.html</guid>
<description>&lt;p&gt;WPF下使用进度条也是非常方便的，如果直接采用循环然后给ProcessBar赋值，理论上是没有问题的，不过这样会卡主主UI线程，我们看到的效果等全部都结束循环后才出现最后的值。&lt;/p&gt;
&lt;p&gt;所以需要采用线程或者后台方式给进度条赋值的方式，以下通过线程来触发事件触发的方式来实现给进度条赋值。这样就可以模拟我们在实际过程中处理数据的一种进度方式。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Windows;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Windows.Controls;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Windows.Data;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Windows.Documents;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Windows.Input;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Windows.Media;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Windows.Media.Imaging;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Windows.Navigation;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Windows.Shapes;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; WpfTestProcessBar
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; MainWindow.xaml 的交互逻辑
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;partial&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MainWindow : Window
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;delegate&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ProgressDelegate(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; percent);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; MainWindow()
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;            InitializeComponent();
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             ProgressEvent +=&lt;span&gt; MainWindow_ProgressEvent;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;            beginImport();
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;void&lt;/span&gt; MainWindow_ProgressEvent(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; percent)
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;             Dispatcher.Invoke(&lt;span&gt;new&lt;/span&gt; Action&amp;lt;System.Windows.DependencyProperty, &lt;span&gt;object&lt;/span&gt;&amp;gt;(Pro.SetValue), System.Windows.Threading.DispatcherPriority.Background, &lt;span&gt;new&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;[] { ProgressBar.ValueProperty, Convert.ToDouble(percent+ &lt;span&gt;1&lt;/span&gt;&lt;span&gt;) });
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             Dispatcher.Invoke(&lt;span&gt;new&lt;/span&gt; Action&amp;lt;System.Windows.DependencyProperty, &lt;span&gt;object&lt;/span&gt;&amp;gt;(label.SetValue), System.Windows.Threading.DispatcherPriority.Background, &lt;span&gt;new&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;[] { Label.ContentProperty, Convert.ToString((percent + &lt;span&gt;1&lt;/span&gt;)+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) }); 
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;event&lt;/span&gt;&lt;span&gt; ProgressDelegate ProgressEvent;
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; beginImport()
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;             Pro.Maximum = &lt;span&gt;100&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;             Pro.Value = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;             label.Content = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0%&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;             ThreadPool.QueueUserWorkItem(state =&amp;gt;
&lt;span&gt;44&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;                 Thread.Sleep(&lt;span&gt;2000&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;100&lt;/span&gt;; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (ProgressEvent != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;                        ProgressEvent(i);
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;                     Thread.Sleep(&lt;span&gt;10&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上只是一种实现方式，希望给有需要的人提供帮助。&lt;/p&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/696166/201904/696166-20190410232451533-1451188072.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 10 Apr 2019 15:27:00 +0000</pubDate>
<dc:creator>风幻影</dc:creator>
<og:description>WPF下使用进度条也是非常方便的，如果直接采用循环然后给ProcessBar赋值，理论上是没有问题的，不过这样会卡主主UI线程，我们看到的效果等全部都结束循环后才出现最后的值。 所以需要采用线程或者后</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hglSV/p/10686958.html</dc:identifier>
</item>
</channel>
</rss>