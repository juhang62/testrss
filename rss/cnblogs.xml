<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>计算机网络之应用层 - Java伴我余生</title>
<link>http://www.cnblogs.com/reminis/p/13167622.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/reminis/p/13167622.html</guid>
<description>&lt;h3 id=&quot;应用层协议&quot;&gt;应用层协议&lt;/h3&gt;
&lt;p&gt;应用层协议 (application-layer protocol) 定义了运行在不同端系统上的应用程序进程如何相互传递报文，特别是应用层协议定义了:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;交换的报文类型，例如请求报文和响应报文&lt;/li&gt;
&lt;li&gt;各种报文类型的语法，如报文中的各个字段及这些字段是如何描述的&lt;/li&gt;
&lt;li&gt;字段的语义，即这些字段中包含的信息的含义&lt;/li&gt;
&lt;li&gt;一个进程何时以及如何发送报文，对报文进行响应的规则。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;  在本文中主要是讲5种重要的应用: Web 、文件传输、电子邮件、目录服务和P2P，我们首先讨论 Web应用，不仅因为它是极为流行的应用，而且因为它的应用层协议 HTTP 相对比较简单并且易于理解。讨论完 Web ，我们简要地讨论FTP，因为它与 HTTP 形成了很好的对照 我们接下来讨论电子邮件应用，这是因特网上最早的招人喜爱的应用程序。说电子邮件比 Web更复杂，是因为它使用了多个而不是一个应用层协议。在电子邮件之后，我们讨论DNS它为因特网提供目录服务，大多数用户不直接与 DNS 打交道，而是通过其他的应用(包括Web 、文件传输和电子邮件)间接使用它，DNS 很好地说明了一种核心的网络功能(网络名字到网络地址的转换)是怎样在因特网的应用层实现的。&lt;/p&gt;
&lt;h3 id=&quot;http概况&quot;&gt;HTTP概况&lt;/h3&gt;
&lt;p&gt;  Web 的应用层协议是超文本传输协议 (HyperText Transfer Protocol , HTTP) ，它是Web的核心，HTTP 由两个程序实现:一个客户程序和一个服务器程序。客户程序和服务器程序运行在不同的端系统中，通过交换HTTP报文进行会话。 HTTP 定义了这些报文的结构以及客户和服务器进行报文交换的方式。HTTP使用TCP作为它的支撑运输协议(而不是在 UDP 上运行)。HTTP 客户首先发起一个与服务器的TCP连接，一旦连接建立，该浏览器和服务器进程就可以通过套接字接口访问TCP。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;服务器向客户发送被请求的文件，而不存储任何关于该客户的状态信息，假如某个特定的客户在短短的几秒钟内两次请求同一个对象，服务器并不会因为刚刚为该客户提供了该对象就不再做出反应，而是重新发送该对象，就像服务器已经完全忘记不久之前所做过的事一样，因为 HTTP 服务器并不保存关于客户的任何信息，所以我们说HTTP是一个&lt;span&gt;无状态协议 (stateless protocol)&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;非持续连接和持续连接&quot;&gt;非持续连接和持续连接&lt;/h4&gt;
&lt;p&gt;  在许多因特网应用程序中，客户和服务器在一个相当长的时间范围内通信，其中客户发出一系列请求并且服务器对每个请求进行响应 依据应用程序以及该应用程序的使用方式，这一系列请求可以以规则的间隔周期性地或者间断性地一个接一个发出。当这种客户-服务器的交互是经TCP进行的，应用程序的研制者就需要做一个重要决定，即每个请求/响应对是经一个单独的 TCP 连接发送，还是所有的请求及其响应经相同的TCP连接发送呢?采用前一种方法，该应用程序被称为使用&lt;span&gt;非持续连接( non- persistent connection)&lt;/span&gt; ;采用后一种方法，该应用程序被称为使用&lt;span&gt;持续连接( persistent connection)&lt;/span&gt;。尽管 HTTP在其默认方式下使用持续连接， HTTP 客户和服务器也能配置成使用非持续连接。&lt;/p&gt;&lt;p&gt;  非持续连接有一些缺点：首先，必须为每一个请求的对象建立和维护一个全新的连接。对于每个这样的连接，在客户和服务器巾都要分配 TCP 的缓冲区和保持 TCP 变量。这给 Web 服务器带来了严重的负担，因为一台 Web 服务器可能同时服务于数以百计不同的客户的请求。第二，每一个对象经受两倍 RTT 的交付时延，即一个RTT 用于创建 TCP ，另一个 RTT 用于请求和接收一个对象。在采用持续连接的情况下，服务器在发送响应后保持该 TCP 连接打开。在相同的客户与服务器之间的后续请求和响应报文能够通过相同的连接进行传送&lt;/p&gt;
&lt;h4 id=&quot;http报文格式&quot;&gt;HTTP报文格式&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;请求报文&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;      GET /somedir/page.html HTTP/l.l
      Host: www.someschool.edu
      Connection: close
      User-agent: Mozilla/5.0
      Accept-language: fr
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  我们看到该报文由5行组成，每行由一个回车和换行符结束。最后一行后再附加一个回车换行。虽然这个特定的报文仅有5行，但一个请求报文能够具有更多的行或者至少为一行。HTTP 请求报文的第一行叫做请求行 (request line) ，其后继的行叫做首部行( headerline)。请求行有3个字段:方法字段、URL字段和HTTP版本字段。方法宇段可以取几种不同的值，包括 GET、POST、HEAD、PUT和DELETE。绝大部分的 HTTP 请求报文使用GET方法，当浏览器请求一个对象时，使用 GET 方法，在 URL 字段带有请求对象的标识。在本例中，该浏览器正在请求对象/somedirl page. html 其版本字段是自解释的;在本例中，浏览器实现的是 HTTP/ l. 版本。&lt;/p&gt;&lt;p&gt;  现在我们看看本例的首部行：首部行 Host: www. someschool. edu 指明了对象所在的主机。你也许认为该首部行是不必要的，因为在该主机中已经有一条 TCP 连接存在了，但是，该首部行提供的信息是 Web 代理高速缓存所要求的，通过包含 Connection: close 首部行，该浏览器告诉服务器不希望麻烦地使用持续连接，它要求服务器在发送完被请求的对象后就关闭这条连接。User- agent: 首部行用来指明用户代理，即向服务器发送请求的浏览器的类型。这里浏览器类型是 Mozilla/5. 0，即Firefox 浏览器，这个首部行是有用的，因为服务器可以有效地为不同类型的用户代理，实际发送相同对象的不同版本 (每个版本都由相同的URL寻址)。最后Accept-language：首部行表示用户想得到该对象的法语版本(如果服务器中有这样的对象的话)；否则，服务器应当发送它的默认版本 Accept -language：首部行仅是 HTTP 中可用的众多内容协商首部之一。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202006/1975191-20200620091853369-867553146.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  HEAD方法类似于GET方法，当服务器收到使用HEAD方法的请求时，将会用一个HTTP报文进行响应，但是并不返回请求对象，应用程序开发者常用HEAD方法进行调试，跟踪PUT方法常与Web发行工具联合使用，它允许用户上传对象到指定的 Web 服务器上指定的路径(目录)。PUT方法也被那些需要向 Web 服务器上传对象的应用程序使用。DELETE 方法允许用户或者应用程序删除 Web 服务器上的对象&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;&lt;strong&gt;HTTP响应报文&lt;/strong&gt;&lt;br/&gt;下面我们提供了一条典型的HTTP响应报文 该响应报文可以是对刚刚讨论的例子中请求报文的响应：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;HTTP/ 1. 1 200 OK
Connection: close 
Date: Tue , 09 Aug 2011 15:44:04 GMT
Server: Apache/2.2.3 (CentOS)
Last-Modified: Tue , 09 Aug 2011 15:11:03 GMT
Content-Length: 6821
Content-Type: text/html 

(data data data data data ...) 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  我们仔细看一下这个响应报文 它有三个部分：一个初始状态行 (sLatus line) ，6个首部行 (header 1ine) ，然后是实体体 (enLity body) 实体体部分是报文的主要部分，即它包含了所请求的对象本身(表示为 dala dala data data ...）。 状态行有3个字段:协议版本字段、状态码和相应状态信息。在这个例子中，状态行指示服务器正在使用 HTTP/l.1，并且一切正常(即服务器已经找到并正在发送所请求的对象)。&lt;/p&gt;&lt;p&gt;  我们现在来看看首部行。服务器用 Connection: close 首部行告诉客户，发送完报文后将关闭该 TCP 连接。Date: 首部行指示服务器产生并发送该响应报文的日期和时间。值得一提的是，这个时间不是指对象创建或者最后修改的时间；而是服务器从它的文件系统中检索到该对象，插入到响应报文，并发送该响应报文的时间。Server: 首部行指示该报文是由一台 Apache Web 服务器产生的，它类似于 HTTP 请求报文中的 User- agent 首部行。Last- Modified: 首部行指示了对象创建或者最后修改的日期和时间。Lasl-Modified: 首部行对既可能在本地客户也可能在网络缓存服务器上的对象缓存来说非常重要。下面将会介绍缓存服务器(也叫代理服务器)。Content- Length: 首部行指示了被发送对象中的字节数；Conlent- Type: 首部行指示了实体体中的对象是 HTML 文本 (该对象类型应该正式地由 Conlent- Type: 首部行而不是用文件扩展名来指示。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202006/1975191-20200620093124064-999983692.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;web-缓存&quot;&gt;Web 缓存&lt;/h4&gt;
&lt;p&gt;  Web缓存器 (Web cache)也叫代理服务器 (proxy server)，它是能够代表初始 Web 服务器来满足 HTTP 请求的网络实体。Web 缓存器有自己的磁盘存储空间，并在存储空间中保存最近请求过的对象的副本 如图 2-11 所示，可以配置用户的浏览器，使得用户的所有 HTTP请求首先指向 Web 缓存器。一旦某浏览器被配置，每个对某对象的浏览器请求首先被定向到该 Web 缓存器。举例来说，假设浏览器正在请求对象 &lt;a href=&quot;http://www.someschool&quot;&gt;http://www.someschool&lt;/a&gt;. edu/ campus.giI.将会发生如下情况:&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202006/1975191-20200620094526329-1706372280.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;浏览器建立一个到Web缓存器的TCP连接，并向 Web 缓存器中的对象发送一个HTTP请求&lt;/li&gt;
&lt;li&gt;Web 缓存器进行检查，看看本地是否存储了该对象副本 如果有， Web 缓存器就向客户浏览器用 HTTP 响应报文返回该对象&lt;/li&gt;
&lt;li&gt;如果 Web 缓存器中没有该对象，它就打开一个与该对象的初始服务器(如www. someschool. edu)，TCP 连接 Web 缓存器则在这个缓存器到服务器的TCP连接上发送一个对该对象的 HTTP 请求，在收到该请求后，初始服务器向该 Web缓存器发送具有该对象的 HTTP响应&lt;/li&gt;
&lt;li&gt;当 Web 缓存器接收到该对象时，它在本地存储空间存储一份副本，并向客户的浏览器用盯TP 响应报文发送该副本(通过现有的客户浏览器和 Web 缓存器之间的TCP连接)&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;dhcp协议&quot;&gt;DHCP协议&lt;/h4&gt;
&lt;p&gt;  DHCP(Dynamic Host Configuration Protocol: 动态主机设置协议，DHCP是一个局域网协议，DHCP是应用UDP协议的应用层协议。使用UDP协议工作，主要有两个用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。&lt;br/&gt;对于一个 临时设备，是如何知道自己的IP地址的？&lt;br/&gt;  DHCP服务器监听默认端口：67，主机使用UDP协议广播DHCP发现报文，DHCP服务器发出DHCP提供报文，主机向DHCP服务器发出DHCP请求报文，DHCP服务器回应并提供IP地址。&lt;/p&gt;
&lt;h4 id=&quot;https&quot;&gt;HTTPS&lt;/h4&gt;
&lt;p&gt;  由于HTTP是明文传输的，则HTTPS(Secure)是安全的HTTP协议，默认端口为443，http(s): //&amp;lt;主机&amp;gt;:&amp;lt;端口&amp;gt;/&amp;lt;路径&amp;gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202006/1975191-20200620104935799-107034552.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202006/1975191-20200620105215603-1344728217.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;A、B是拥有一定数学关系的一组秘钥
&lt;ul&gt;&lt;li&gt;私钥：私钥自己使用，不对外公开&lt;/li&gt;
&lt;li&gt;公钥：公钥给大家使用，对外公开&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202006/1975191-20200620105337261-188472925.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;使用公钥加密，使用私钥解密。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;数字证书是可信任组织颁发给特定对象的认证&lt;/li&gt;
&lt;/ul&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;证书格式、版本号&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;证书序列号&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;签名算法&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;有效期&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;对象名称&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;对象公开秘钥&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;...&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;ul&gt;&lt;li&gt;SSL(Secure Sockets Layer: 安全套接层)
&lt;ul&gt;&lt;li&gt;数据安全和数据完整&lt;/li&gt;
&lt;li&gt;对传输层数据进行加密后传输&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;HTTPS 原理&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;客户端将它所支持的算法列表和一个用作产生密钥的随机数发送给服务器 ；&lt;/li&gt;
&lt;li&gt;服务器从算法列表中选择一种加密算法，并将它和一份包含服务器公用密钥的证书发送给客户端；该证书还包含了用于认证目的的服务器标识，服务器同时还提供了一个用作产生密钥的随机数；&lt;/li&gt;
&lt;li&gt;客户端对服务器的证书进行验证（有关验证证书，可以参考数字签名），并抽取服务器的公用密钥；然后，再产生一个称作 pre_master_secret 的随机密码串，并使用服务器的公用密钥对其进行加密（参考非对称加 / 解密），并将加密后的信息发送给服务器 ；&lt;/li&gt;
&lt;li&gt;客户端与服务器端根据 pre_master_secret 以及客户端与服务器的随机数值独立计算出加密和 MAC密钥（参考 DH密钥交换算法）；&lt;/li&gt;
&lt;li&gt;客户端将所有握手消息的 MAC 值发送给服务器；&lt;/li&gt;
&lt;li&gt;服务器将所有握手消息的 MAC 值发送给客户端&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;文件传输协议：ftp&quot;&gt;文件传输协议：FTP&lt;/h3&gt;
&lt;p&gt;  在一个典型的FTP会话中，用户坐在一台主机(本地主机)前面，向一台远程主机传输(或接收来自远程主机的)文件 为使用户能访问它的远程账户，用户必须提供一个用户标识和口令 在提供了这种授权信息后，用户就能从本地文件系统向远程主机文件系统传送文件，反之亦然 如图 2-14 所示，用户通过一个FTP用户代理与FTP交互。该用户首先提供远程主机的主机名，使本地主机的FTP客户进程建立一个到远程主机FTP服务器进程的 TCP 连接。该用户接着提供用户标识和口令，作为 FTP 命令的一部分在该 TCP连接上传送。一旦该服务器向该用户授权，用户可以将存放在本地文件系统中的一个或者多个文件复制到远程文件系统(反之亦然)。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202006/1975191-20200620101506681-1100568100.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  HTTP和FTP 都是文件传输协议，并且有很多共同的特点，例如，它们都运行在 TCP上，然而，这两个应用层协议也有一些重要的区别 其中最显著的就是FTP 使用了两个并行的 TCP 连接来传输文件，一个是&lt;span&gt;控制连接 (control connection)&lt;/span&gt; ，一个是&lt;span&gt;数据连接( data connection)&lt;/span&gt; 。控制连接用于在两主机之间传输控制信息，如用户标识、口令、改变远程目录的命令以及&quot;存放 (put) &quot;和&quot;获取 (get)&quot;文件的命令。数据连接用于实际发送一个文件，因为FTP协议使用一个独立的控制连接，所以我们也称FTP的控制信息是&lt;span&gt;带外(out-of-band)&lt;/span&gt;传送的。如你所知，HTTP协议是在传输文件的同一个 TCP 连接中发送请求和响应首部行的 因此，HTTP也可以说是带内 (in-band) 发送控制信息的。FTP协议的控制连接和数据连接如图二 15 所示：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202006/1975191-20200620102104867-1309346481.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;  当用户主机与远程主机开始一个FTP会话时，FTP的客户(用户)端首先在服务器21号端口与服务器(远程主机)端发起一个用于控制的 TCP 连接。FTP的客户端也通过该控制连接发送用户的标识和口令，发送改变远程目录的命令，当FTP的服务器端从该连接上收到一个文件传输的命令后(无论是向还是来自远程主机) ，就发起一个到客户端的 TCP 数据连接 FTP 在该数据连接上准确地传送一个文件，然后关闭该连接。在同一个会话期间，如果用户还需要传输另一个文件，FTP则打开另一个数据连接，因而对FTP传输而言，控制连接贯穿了整个用户会话期间，但是对会话中的每一次文件传输都需要建立一个新的数据连接(即数据连接是非持续的)。&lt;/p&gt;&lt;p&gt;  FTP服务器必须在整个会话期间保留用户的状态(state) 特别是，服务器必须把特定的用户账户与控制连接联系起来，随着用户在远程目录树上徘徊，服务器必须追踪用户在远程目录树上的当前位置，对每个进行中的用户会话的状态信息进行追踪，大大限制了FTP同时维持的会话总数。而另一方面，前面讲过 HTTP 是无状态的，即它不必对任何用户状态进行追踪。&lt;/p&gt;
&lt;h3 id=&quot;因特网中的电子邮件&quot;&gt;因特网中的电子邮件&lt;/h3&gt;
&lt;p&gt;  图2-16 给出了因特网电子邮件系统的总体情况，从该图中我们可以看到它有3个主要组成部分: 用户代理( user agenl) 、邮件服务器 (mail server) 简单邮件传输协议(Simple Mai] Transfer Prolocol , SMTP) 。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202006/1975191-20200620103029863-749788053.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;SMTP 是因特网电子邮件中主要的应用层协议，它使用 TCP 可靠数据传输服务，从发送方的邮件服务器向接收方的邮件服务器发送邮件，像大多数应用层协议一样， SMTP有两个部分:运行在发送方邮件服务器的客户端和运行在接收方邮件服务器的服务器端，每台邮件服务器上既运行 SMTP 的客户端也运行 SMTP 的服务器端 。当一个邮件服务器向其他邮件服务器发送邮件时，它就表现为 SMTP 的客户;当邮件服务器从其他邮件服务器上接收邮件时，它就表现为SMTP的服务器。目前有一些流行的邮件访问协议，包括第三版的邮局协议 (POSl OfficeProtocol-Version 3 , POP3)、因特网邮件访问协议 (Intemet Mail Access Protocol , IMAP)以及 HTTP。&lt;/p&gt;&lt;p&gt;总结：应用层为操作系统或网络应用程序提供访问网络服务的接口。数据传输基本单位为报文；包含的主要协议：FTP（文件传送协议）、Telnet（远程登录协议）、DNS（域名解析协议）、SMTP（邮件传送协议），POP3协议（邮局协议），HTTP协议（Hyper Text Transfer Protocol）。&lt;/p&gt;
</description>
<pubDate>Sun, 21 Jun 2020 00:31:00 +0000</pubDate>
<dc:creator>Java伴我余生</dc:creator>
<og:description>应用层协议 应用层协议 (application-layer protocol) 定义了运行在不同端系统上的应用程序进程如何相互传递报文，特别是应用层协议定义了: 交换的报文类型，例如请求报文和响应报</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/reminis/p/13167622.html</dc:identifier>
</item>
<item>
<title>个人总结 - ￥。</title>
<link>http://www.cnblogs.com/zxy2818/p/13170708.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zxy2818/p/13170708.html</guid>
<description>&lt;h2 id=&quot;一、回望4个月的软件工程实践&quot;&gt;一、回望4个月的软件工程实践&lt;/h2&gt;
&lt;h3 id=&quot;1做了哪些作业&quot;&gt;1.做了哪些作业&lt;/h3&gt;
&lt;h3 id=&quot;2给我带来的提升&quot;&gt;2.给我带来的提升&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;em&gt;学习和使用的新软件和新工具&lt;/em&gt;&lt;br/&gt;博客园&lt;br/&gt;GitHub&lt;br/&gt;ProcessOn&lt;br/&gt;墨刀&lt;/li&gt;
&lt;li&gt;&lt;em&gt;学习和掌握的新语言、新框架&lt;/em&gt;&lt;br/&gt;在实践的这段时间里，因为之前对java语言掌握的不是很好，所以在一开始的时候，我是先花了一段时间去重新学习了下java语言。后面进行团队项目的时候，在我们组长的提议下，我们的项目是使用了Spring Boot框架。但是因为这个之前也没有接触过，所以就是自己在网上找相关的资源进行学习，然后团队中学得快的就带一下学的比较慢的。由于时间等原因，我也只是略知一二，但是在之后对于Spring Boot框架还仍需继续学习。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;学习和掌握的新方法、新思维、新思想&lt;/em&gt;&lt;br/&gt;在学习的过程中，千万不能只看视频，一定要先边看边敲，到看完再敲，最后自己直接敲。如果只是纯看视频的话，就跟过眼云烟一样。只有在敲的过程中，我们才能慢慢学到东西。同时遇到问题的时候，一不能直接放弃，二不能第一时间就去求助他人帮助，一定要学会先自己尝试着去解决问题。当自己独立解决了一个问题的时候，那种感觉是很爽的，要是经过自己一番尝试后，实在还是不行的话，这时候再去请教他人，只有这样才能更好地提升自己，学习到别人解决问题的思路和方法。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;其他的提升&lt;/em&gt;&lt;br/&gt;在实践的这段时间里，除了以上的这些，对于我而言，在时间管理这方面也是一个比较大的提升。因为这门课程真的挺花时间的，需要我们合理地安排好在课余时间中其他课程的学习时间，尤其是在后期完成团队项目的时候，一定得先制定好项目计划及时间安排表，然后尽量按照计划表去执行，这样才能如期完成好项目。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;深刻的印象&lt;/em&gt;&lt;br/&gt;在完成团队项目的Beta冲刺阶段，由于大家编码水平的不同，导致大家完成各自分工的效率也随之不同，同时大家的意见有时候也不一致，但是我们并没有放慢脚步，相反我们每天都坚持开“站立式会议”，编码能力强的就会共享屏幕指导编码能力较弱的进行编码。有一次在攻克了一个难关之后，组员在会议中通过共享屏幕来向我们大家展示成果，我们在看完后都很兴奋。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;二、人月神话&quot;&gt;二、人月神话&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;对于这种团队项目类的东西，一定要注重团队协作。&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;其一是沟通。因为每个人的思维是不一样的，导致我们思考问题的角度并不都是一致的。当团队成员之间出现意见不一致的时候，一定要及时进行沟通。大家在沟通的过程中将自己的想法讲解给其他成员，在沟通的过程中来商讨出一个最佳的解决方案。所以我们在完成项目的过程中，我们都会尽量开启会议，这样在遇到问题的时候能够得到及时有效的解决。&lt;/li&gt;
&lt;li&gt;其二是任务分配。每个人的能力和擅长的方面是不一样的，这时候就需要自己主动向组长说明自身的相关情况，然后组长根据每个人的情况来进行相应的任务分配，这样才能使得每个组员都能在完成项目的过程中获得足够的参与感，同时也能相应地提高完成项目的效率。&lt;/li&gt;
&lt;li&gt;其三是集体荣誉感。对于团队项目，每个组员都应该具备集体荣誉感。对于分配给自己的任务，不能只是光做完就可以，而是应该想着如何去做到最好，时刻以高标准要求自己，一定要坚决摒弃敷衍了事的心态。只有每个组员都尽自己的最大努力去完成好任务，这样在最后按期完成好项目的几率才会更高，甚至可能在最后超出项目预期的效果。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;三、对下一届实践的建议&quot;&gt;三、对下一届实践的建议&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;合理安排好时间。对于课余时间，实践所需要花费的时间挺多的，所以一定要安排好其他课程的学习时间，并且尽量做到能早则早，别等到最后一刻才来急急忙忙赶作业。&lt;/li&gt;
&lt;li&gt;化被动为主动。要学会自己主动学习，在实践的过程中，我们会接触到很多的新鲜的东西，这时候就需要我们自己主动地去寻找资源对其进行学习。同时在遇到问题的时候，我们也应该先自己想办法去解决，而不是时刻想着依靠别人来帮忙，这样的话自己永远都得不到提升。&lt;/li&gt;
&lt;li&gt;不怕苦不怕累。在实践过程中，是紧张又刺激的，是辛苦的，但是也是难忘的。但是只要咬牙坚持下来，你会发现收获也是满满的。因为在实践的过程中，你也许会在自己独立完成编程作业后刷新对自己编程能力的认识，收获在与他人结对后一起完成作业时的喜悦，在完成团队项目时你所获得的参与感以及自己团队协作能力的提升。当回过头来看看自己写过的博客，你也许会惊叹:自己竟然真的坚持下来了，还参与了一个项目的完成全过程，自己这一刻真的做到了!&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;四、对未来的自己的期许&quot;&gt;四、对未来的自己的期许&lt;/h2&gt;
&lt;p&gt;&quot;不负韶华,只争朝夕&quot;。希望未来的自己在制定目标后，不要犹犹豫豫，也不要三分钟的热度，对于想做的事情就勇敢地去做。坚持学习，不断地去接触新鲜的事物，紧跟住时代的步伐。在今后的每一天，都是在不断地“Learning by doing”，使每天都能过的有意义，过得充实吧，这样以后在回过头来看看的时候，也能够看到自己为实现梦想所拼搏的轨迹。&lt;/p&gt;
</description>
<pubDate>Sun, 21 Jun 2020 00:26:00 +0000</pubDate>
<dc:creator>￥。</dc:creator>
<og:description>这个作业属于哪个课程 https://edu.cnblogs.com/campus/fzzcxy/SE/ 这个作业要求在哪里 https://edu.cnblogs.com/campus/fzzcxy</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zxy2818/p/13170708.html</dc:identifier>
</item>
<item>
<title>一文搞懂：Adaboost及手推算法案例 - 忽逢桃林</title>
<link>http://www.cnblogs.com/PythonLearner/p/13171284.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/PythonLearner/p/13171284.html</guid>
<description>&lt;p&gt;Boosting 算法的特点在于：&lt;strong&gt;将表现一般的弱分类器通过组合变成更好的模型&lt;/strong&gt;。代表自然就是我们的随即森林了。&lt;/p&gt;
&lt;p&gt;GBDT和Adaboost是boost算法中比较常见的两种，这里主要讲解Adaboost。&lt;/p&gt;

&lt;p&gt;Adaboost算法的核心就是&lt;strong&gt;两个权重&lt;/strong&gt;。对于数据有一个权重，权重大的数据计算的损失就大；然后对于每一个弱分类器有一个权重，这个权重就是每一个弱分类器最终投票的比重。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【先给出Adaboost关键的公式】&lt;/strong&gt;：&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\alpha_1=\frac{1}{2}ln(\frac{1-\epsilon_1}{\epsilon_1})\)&lt;/span&gt; 分类器的投票权重&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(W_i=W_ie^{-\alpha_i y_i \hat{h}(x_i)}\)&lt;/span&gt; 更新样本的权重&lt;/p&gt;
&lt;p&gt;【随即森林中最终投票每一个弱分类器的比重相同】&lt;/p&gt;
&lt;p&gt;大概流程就是，现在有一个数据集，然后每个数据的比重都相同，然后训练了好几个不同的弱分类器。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;挑选错误率最低的弱分类器，然后通过【某种算法】得到这个弱分类器最终投票的比重，然后通过【某种算法】更新每一个数据的比重；&lt;/li&gt;
&lt;li&gt;因为每一个数据的比重更新了，所以再选择一个错误率最低的弱分类器，然后通过【某种算法】得到这个弱分类器最终投票的比重，然后通过【某种算法】更新每一个数据的比重；&lt;/li&gt;
&lt;li&gt;重复这个过程。&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;p&gt;算法的流程：&lt;br/&gt;&lt;a class=&quot;wp-editor-md-post-content-link&quot; href=&quot;http://helloworld2020.net/wp-content/uploads/2020/06/wp_editor_md_dc5d09a65fb3d6613761baa36fa71cb9.jpg&quot;&gt;&lt;img src=&quot;http://helloworld2020.net/wp-content/uploads/2020/06/wp_editor_md_dc5d09a65fb3d6613761baa36fa71cb9.jpg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;这里给一个具体计算的例子：&lt;br/&gt;假设这里有10个数据：&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;wp-editor-md-post-content-link&quot; href=&quot;http://helloworld2020.net/wp-content/uploads/2020/06/wp_editor_md_d0eaaad3635a2b71847c6c49aa74c6f8.jpg&quot;&gt;&lt;img src=&quot;http://helloworld2020.net/wp-content/uploads/2020/06/wp_editor_md_d0eaaad3635a2b71847c6c49aa74c6f8.jpg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;加号和减号分别代表不同的类别。然后每个类别有5个样本。&lt;/p&gt;
&lt;p&gt;下面会给出3个弱分类器：&lt;br/&gt;&lt;a class=&quot;wp-editor-md-post-content-link&quot; href=&quot;http://helloworld2020.net/wp-content/uploads/2020/06/wp_editor_md_8fd2c323b17540637a8f7c3593bfb41e.jpg&quot;&gt;&lt;img src=&quot;http://helloworld2020.net/wp-content/uploads/2020/06/wp_editor_md_8fd2c323b17540637a8f7c3593bfb41e.jpg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;wp-editor-md-post-content-link&quot; href=&quot;http://helloworld2020.net/wp-content/uploads/2020/06/wp_editor_md_f4be14eea52abeee1fa0428659b83342.jpg&quot;&gt;&lt;img src=&quot;http://helloworld2020.net/wp-content/uploads/2020/06/wp_editor_md_f4be14eea52abeee1fa0428659b83342.jpg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;wp-editor-md-post-content-link&quot; href=&quot;http://helloworld2020.net/wp-content/uploads/2020/06/wp_editor_md_d233e95843dde57955b930348f8a9934.jpg&quot;&gt;&lt;img src=&quot;http://helloworld2020.net/wp-content/uploads/2020/06/wp_editor_md_d233e95843dde57955b930348f8a9934.jpg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这三个分类器分别是&lt;span class=&quot;math inline&quot;&gt;\(h_1(x),h_2(x),h_3(x)\)&lt;/span&gt;&lt;br/&gt;图中画圈的数据就是分类错误的数据。可以发现每个弱分类器都分错了3个。下面开始Adaboost的算法。&lt;/p&gt;
&lt;p&gt;先计算三个弱分类器的错误率，因为一开始每个样本的权重都是0.1，每个分类器又都错了3个样本，所以错误率都是0.3。这里就随机选取第一个分类器作为错误率最低的那个好了。&lt;br/&gt;我们这里通过第一个【某种算法】计算第一个弱分类器在最终的投票权重：&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\alpha_1=\frac{1}{2}ln(\frac{1-\epsilon_1}{\epsilon_1})=0.5*ln(\frac{0.7}{0.3})=0.4236\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;然后通过这个&lt;span class=&quot;math inline&quot;&gt;\(\alpha_1=0.4236\)&lt;/span&gt;来更新每一个样本的权重。这也就是上面提到的第二个【某种算法】：&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(W(i)=W(i)*e^{-\alpha y_i \hat {h}(x_i)}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这啥意思的，现在假设第一个样本+1，这个样本的权重是0.1（更新前），然后这个样本在第一个分类器中是非类正确的，所以&lt;span class=&quot;math inline&quot;&gt;\(y_i \hat{h}(x_i)=1\)&lt;/span&gt;,所以这个样本更新后的权重就是&lt;span class=&quot;math inline&quot;&gt;\(0.1e^{-0.4236}=0.0655\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;当然，对于+3这个样本，第一个分类器就分类错误，所以&lt;span class=&quot;math inline&quot;&gt;\(y_i \hat{h}(x_i)=-1\)&lt;/span&gt;，所以呢这个样本更新后的权重就是：&lt;span class=&quot;math inline&quot;&gt;\(0.1e^{0.4236}=0.1527\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;下面经过第一个分类器之后的样本的权重：&lt;br/&gt;&lt;a class=&quot;wp-editor-md-post-content-link&quot; href=&quot;http://helloworld2020.net/wp-content/uploads/2020/06/wp_editor_md_6a9cea2f4aa0814cc605b4b6e9967d0c.jpg&quot;&gt;&lt;img src=&quot;http://helloworld2020.net/wp-content/uploads/2020/06/wp_editor_md_6a9cea2f4aa0814cc605b4b6e9967d0c.jpg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;然后再计算每一个分类器的基于更新之后样本权重的错误率：&lt;br/&gt;&lt;a class=&quot;wp-editor-md-post-content-link&quot; href=&quot;http://helloworld2020.net/wp-content/uploads/2020/06/wp_editor_md_dfce6e54e349c2e4c6aa6d1cba247aa7.jpg&quot;&gt;&lt;img src=&quot;http://helloworld2020.net/wp-content/uploads/2020/06/wp_editor_md_dfce6e54e349c2e4c6aa6d1cba247aa7.jpg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这一次选的是第二个分类器，然后计算它的&lt;span class=&quot;math inline&quot;&gt;\(\alpha_2\)&lt;/span&gt;,然后再更新每一个样本的权重值：&lt;br/&gt;&lt;a class=&quot;wp-editor-md-post-content-link&quot; href=&quot;http://helloworld2020.net/wp-content/uploads/2020/06/wp_editor_md_87c3bc56c749568dc48ed0133e378024.jpg&quot;&gt;&lt;img src=&quot;http://helloworld2020.net/wp-content/uploads/2020/06/wp_editor_md_87c3bc56c749568dc48ed0133e378024.jpg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;然后是再寻找错误率最低的分类器：&lt;br/&gt;&lt;a class=&quot;wp-editor-md-post-content-link&quot; href=&quot;http://helloworld2020.net/wp-content/uploads/2020/06/wp_editor_md_7e72122cad9112e4b22631b83643ff0d.jpg&quot;&gt;&lt;img src=&quot;http://helloworld2020.net/wp-content/uploads/2020/06/wp_editor_md_7e72122cad9112e4b22631b83643ff0d.jpg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;到这一步的时候，我们已经有了&lt;span class=&quot;math inline&quot;&gt;\(\alpha_1,\alpha_2,\alpha_3\)&lt;/span&gt;,所以我们的adaboost已经得到了所有分类器的投票权重，所以最终的模型投票公式就是：&lt;br/&gt;&lt;a class=&quot;wp-editor-md-post-content-link&quot; href=&quot;http://helloworld2020.net/wp-content/uploads/2020/06/wp_editor_md_b72f27dd7d1b0c9e82d51f22eea37203.jpg&quot;&gt;&lt;img src=&quot;http://helloworld2020.net/wp-content/uploads/2020/06/wp_editor_md_b72f27dd7d1b0c9e82d51f22eea37203.jpg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;喜欢的话请关注我们的微信公众号~【你好世界炼丹师】。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;公众号主要讲统计学，数据科学，机器学习，深度学习，以及一些参加Kaggle竞赛的经验。&lt;/li&gt;
&lt;li&gt;公众号内容建议作为课后的一些相关知识的补充，饭后甜点。&lt;/li&gt;
&lt;li&gt;此外，为了不过多打扰，公众号每周推送一次，每次4~6篇精选文章。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;微信搜索公众号：你好世界炼丹师。期待您的关注。&lt;br/&gt;&lt;img src=&quot;http://helloworld2020.net/wp-content/uploads/2020/06/%E9%BB%98%E8%AE%A4%E6%A0%87%E9%A2%98_%E6%A8%AA%E7%89%88%E4%BA%8C%E7%BB%B4%E7%A0%81_2020-06-21-0-1.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 20 Jun 2020 22:44:00 +0000</pubDate>
<dc:creator>忽逢桃林</dc:creator>
<og:description>boosting Boosting 算法的特点在于：将表现一般的弱分类器通过组合变成更好的模型。代表自然就是我们的随即森林了。 GBDT和Adaboost是boost算法中比较常见的两种，这里主要讲解</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/PythonLearner/p/13171284.html</dc:identifier>
</item>
<item>
<title>Docker精华 ，超全文档！ - 死磕编程</title>
<link>http://www.cnblogs.com/dk1024/p/13168348.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dk1024/p/13168348.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;我们的口号是：再小的帆也能远航，人生不设限！！   &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;学习规划：继续上篇 《Docker入门》&lt;a href=&quot;https://www.cnblogs.com/dk1024/p/13121389.html&quot;&gt;&lt;span&gt;https://www.cnblogs.com/dk1024/p/13121389.html&lt;/span&gt;&lt;/a&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;继续讲解=========》》》》》》》》》》》》》》》》》》》》》》》》》&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1519601/202006/1519601-20200621015824062-672879476.png&quot; alt=&quot;&quot; width=&quot;647&quot; height=&quot;647&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;一、容器数据卷&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、什么是容器数据卷：Docker是将应用和环境打包成一个镜像，发布到服务器，这个跑起来的容器如果不小心删除掉，呢么数据就会全部丢失，尤其是Mysql之类的容器，name现在就有一个需求，数据持久化到本地，这就是卷技术，即：目录的挂载，将我们的容器内的目录挂载到Linux某个目录下，说白了就是一种同步的机制，就是容器的持久化和同步操作，而且容器之间也是可以共享数据的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1519601/202006/1519601-20200620134640546-1772800482.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 2、体验卷技术&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;实战：直接使用命令挂载  -v&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;87&quot;&gt;
&lt;pre readability=&quot;5&quot;&gt;
&lt;span&gt;#目的：启动centos，把容器内 /home 挂载到 /home/ceshi 下&lt;/span&gt;&lt;p&gt;&lt;span&gt;#检查Linux /home目录下是否干净&lt;/span&gt;
&lt;/p&gt;&lt;/pre&gt;
&lt;p&gt;[root@ldk ~]# cd /home/&lt;br/&gt;[root@ldk home]#&lt;/p&gt;
&lt;p&gt;[root@ldk home]# ls&lt;/p&gt;
&lt;pre&gt;
&lt;br/&gt;&lt;span&gt;#启动centos &lt;span&gt;&lt;strong&gt;容器&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;[root@ldk /]# docker run -it -v /home/ceshi:/home centos /bin/bash&lt;/p&gt;

&lt;p&gt;&lt;span&gt;#进入 &lt;span&gt;&lt;strong&gt;容器 &lt;/strong&gt;&lt;/span&gt;查看/home目录&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;[root@2ce40ff3194b /]# cd /home/&lt;br/&gt;[root@2ce40ff3194b home]# ls&lt;br/&gt;[root@2ce40ff3194b home]#&lt;/p&gt;

&lt;p&gt;&lt;span&gt;#查看 &lt;strong&gt;&lt;span&gt;宿主机目录&lt;/span&gt;&lt;/strong&gt; /home目录  发现多了个  ceshi文件夹&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;[root@ldk ~]# cd /home/&lt;br/&gt;[root@ldk home]# ls&lt;br/&gt; ceshi&lt;br/&gt;[root@ldk home]#&lt;/p&gt;

&lt;p&gt;&lt;span&gt;#在 &lt;span&gt;&lt;strong&gt;宿主机&lt;/strong&gt;&lt;/span&gt;，确认卷是否挂载成功了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;[root@ldk home]# docker ps&lt;br/&gt;CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES&lt;br/&gt;2ce40ff3194b centos &quot;/bin/bash&quot; 4 minutes ago Up 4 minutes boring_swanson&lt;br/&gt;[root@ldk home]# docker inspect 2ce40ff3194b&lt;br/&gt;[&lt;br/&gt;{&lt;br/&gt;&quot;Id&quot;: &quot;2ce40ff3194b192421024cf4b56606c6dfe3b49c504f41698f0b7ec38e49b71c&quot;,&lt;br/&gt;&quot;Created&quot;: &quot;2020-06-20T06:05:30.539438785Z&quot;,&lt;br/&gt;&quot;Path&quot;: &quot;/bin/bash&quot;,&lt;br/&gt;&quot;Args&quot;: [],&lt;br/&gt;&quot;State&quot;: {&lt;br/&gt;&quot;Status&quot;: &quot;running&quot;,&lt;br/&gt;&quot;Running&quot;: true,&lt;br/&gt;&quot;Paused&quot;: false,&lt;br/&gt;&quot;Restarting&quot;: false,&lt;br/&gt;&quot;OOMKilled&quot;: false,&lt;br/&gt;&quot;Dead&quot;: false,&lt;br/&gt;&quot;Pid&quot;: 6971,&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;&quot;Mounts&quot;: [&lt;br/&gt;{&lt;br/&gt;&quot;Type&quot;: &quot;bind&quot;,&lt;br/&gt;&lt;strong&gt;&lt;span&gt;&quot;Source&quot;: &quot;/home/ceshi&quot;,   #宿主机地址&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;&quot;Destination&quot;: &quot;/home&quot;,    #docker容器内地址&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&quot;Mode&quot;: &quot;&quot;,&lt;br/&gt;&quot;RW&quot;: true,&lt;br/&gt;&quot;Propagation&quot;: &quot;rprivate&quot;&lt;br/&gt;}&lt;br/&gt;],&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;

&lt;p&gt;&lt;span&gt;#测试挂载效果（在&lt;/span&gt; &lt;span&gt;&lt;strong&gt;&lt;span&gt;宿主机 &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;/home/ceshi 下新增ldk.java  检查是否可以映射到 &lt;span&gt;&lt;strong&gt;容器 &lt;/strong&gt;&lt;/span&gt;内的/home 目录下）&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;#宿主机&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;[root@ldk home]# cd ceshi&lt;br/&gt;[root@ldk ceshi]# ll&lt;br/&gt;total 0&lt;br/&gt;[root@ldk ceshi]# touch ldk.java&lt;br/&gt;[root@ldk ceshi]# ll&lt;br/&gt;total 0&lt;br/&gt;-rw-r--r-- 1 root root 0 Jun 20 14:17 ldk.java&lt;br/&gt;[root@ldk ceshi]#&lt;/p&gt;
&lt;p&gt;&lt;span&gt;#容器内&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;[root@2ce40ff3194b /]# cd /home/&lt;br/&gt;[root@2ce40ff3194b home]# ls&lt;br/&gt;ldk.java  　　　&lt;br/&gt;[root@2ce40ff3194b home]#&lt;/p&gt;
&lt;p&gt;&lt;span&gt;#查看发现，同步成功！ 同理，停止容器，修改 宿主机的ldk.java 文件，再重启容器，查看容器内的ldk.java，同样是可以同步成功的。只要容器存在，就可以同步成功。&lt;strong&gt;注：删除容器，宿主机的挂载目录还是存在的。这也间接说明，两份文件占用了两份存储。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;实战：Mysql 同步数据&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre readability=&quot;9&quot;&gt;
&lt;span readability=&quot;12&quot;&gt;&lt;span&gt;#获取mysql镜像&lt;/span&gt;&lt;p&gt;[root@ldk /]# docker pull mysql
Using default tag: latest
latest: Pulling from library/mysql
8559a31e96f4: Already exists 
d51ce1c2e575: Already exists 
c2344adc4858: Already exists 
fcf3ceff18fc: Already exists 
16da0c38dc5b: Already exists 
b905d1797e97: Already exists 
4b50d1c6b05c: Already exists 
c75914a65ca2: Pull complete 
1ae8042bdd09: Pull complete 
453ac13c00a3: Pull complete 
9e680cd72f08: Pull complete 
a6b5dc864b6c: Pull complete 
Digest: sha256:8b7b328a7ff6de46ef96bcf83af048cb00a1c86282bfca0cb119c84568b4caf6
Status: Downloaded newer image for mysql:latest
docker.io/library/mysql:latest&lt;/p&gt;&lt;p&gt;&lt;span&gt;#启动mysql&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-d 后台运行&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-p 端口映射&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-v 卷挂载  这边我们挂载两个目录&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-e mysql密码&lt;/span&gt;&lt;br/&gt;&lt;span&gt;--name 容器名字&lt;/span&gt;
[root@ldk /]# docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7
8126f9c18eecb4581a33c1bbab4b5b829617d25104ed7b9004fe751055a9606a
[root@ldk /]# &lt;/p&gt;&lt;p&gt;#启动并且挂载成功，按照centos容器挂载规则，查看是否挂载&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;




&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;二、具名挂载和匿名挂载&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;72&quot;&gt;
&lt;pre readability=&quot;8&quot;&gt;
&lt;span readability=&quot;10&quot;&gt;&lt;span&gt;#&lt;span&gt;匿名挂载&lt;/span&gt;  Nginx， 只指定容器内路径，不指定容器外路径&lt;/span&gt;&lt;p&gt;[root@ldk ~]# docker run -d -P --name nginx01 -v /etc/nginx nginx
9aef70a2a4a5e91687d639dc65635968c8d86e0c456be4eff9665ce2870ced94&lt;/p&gt;&lt;p&gt;&lt;span&gt;#查看所有挂载情况&lt;/span&gt;
[root@ldk ~]# docker volume ls
DRIVER              VOLUME NAME
local               9b560fb95ed9e801600ee4fc84d8566575185ff04eec984bd8b2a4bcff9459f1
local               12c2c93d2d80e10ea8545ff78fc7e3fa2eb03400bcc5a7bf475b36d64ec6f48a
local               78f7f7c39370425190946b0a29288043e2999e9f0c18078b045c89895bd57264
[root@ldk ~]# &lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;#&lt;span&gt;具名挂载&lt;/span&gt;  格式：-v 卷名：容器内目录（大多数情况都是具名方式）&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;[root@ldk ~]# docker run -d -P --name nginx02 -v &lt;strong&gt;&lt;span&gt;jumign-nginx&lt;/span&gt;&lt;/strong&gt;:/etc/nginx nginx&lt;br/&gt;709e5d31a7adfc79fa491edabfec81048a04be3df22dcbb6edf419bfd16de5fd&lt;br/&gt;[root@ldk ~]# docker volume ls&lt;br/&gt;DRIVER VOLUME NAME&lt;br/&gt;local 9b560fb95ed9e801600ee4fc84d8566575185ff04eec984bd8b2a4bcff9459f1&lt;br/&gt;local 12c2c93d2d80e10ea8545ff78fc7e3fa2eb03400bcc5a7bf475b36d64ec6f48a&lt;br/&gt;local 78f7f7c39370425190946b0a29288043e2999e9f0c18078b045c89895bd57264&lt;br/&gt;local &lt;span&gt;&lt;strong&gt;jumign-nginx&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;[root@ldk ~]#&lt;/p&gt;


&lt;pre&gt;
&lt;span&gt;&lt;span&gt;#查看inspect，所有的卷都挂载在：/var/lib/docker/volumes  下&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;[root@ldk ~]# docker volume inspect jumign-nginx&lt;br/&gt;[&lt;br/&gt;{&lt;br/&gt;&quot;CreatedAt&quot;: &quot;2020-06-20T16:53:27+08:00&quot;,&lt;br/&gt;&quot;Driver&quot;: &quot;local&quot;,&lt;br/&gt;&quot;Labels&quot;: null,&lt;br/&gt;&quot;Mountpoint&quot;: &quot;&lt;span&gt;/var/lib/docker/volumes/jumign-nginx/_data&lt;/span&gt;&quot;,&lt;br/&gt;&quot;Name&quot;: &quot;jumign-nginx&quot;,&lt;br/&gt;&quot;Options&quot;: null,&lt;br/&gt;&quot;Scope&quot;: &quot;local&quot;&lt;br/&gt;}&lt;br/&gt;]&lt;br/&gt;[root@ldk ~]#&lt;/p&gt;

&lt;pre&gt;
&lt;span&gt;&lt;span&gt;#进入宿主机，验证卷的挂载情况&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;[root@ldk ~]# cd /var/lib/docker/volumes&lt;br/&gt;[root@ldk volumes]# ll&lt;br/&gt;total 40&lt;br/&gt;drwxr-xr-x 3 root root 4096 Jun 20 16:48 12c2c93d2d80e10ea8545ff78fc7e3fa2eb03400bcc5a7bf475b36d64ec6f48a&lt;br/&gt;drwxr-xr-x 3 root root 4096 Jun 20 16:36 78f7f7c39370425190946b0a29288043e2999e9f0c18078b045c89895bd57264&lt;br/&gt;drwxr-xr-x 3 root root 4096 Jun 20 16:36 9b560fb95ed9e801600ee4fc84d8566575185ff04eec984bd8b2a4bcff9459f1&lt;br/&gt;drwxr-xr-x 3 root root 4096 Jun 20 16:53 &lt;span&gt;jumign-nginx&lt;/span&gt;&lt;br/&gt;-rw------- 1 root root 32768 Jun 20 16:53 metadata.db&lt;br/&gt;[root@ldk volumes]#&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;#继续深入查看jumign-nginx 挂载情况，看到了想要的nginx.conf配置文件&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;[root@ldk volumes]# cd jumign-nginx/_data/&lt;br/&gt;[root@ldk _data]# ll&lt;br/&gt;total 40&lt;br/&gt;drwxr-xr-x 2 root root 4096 Jun 20 16:53 conf.d&lt;br/&gt;-rw-r--r-- 1 root root 1007 May 26 23:00 fastcgi_params&lt;br/&gt;-rw-r--r-- 1 root root 2837 May 26 23:00 koi-utf&lt;br/&gt;-rw-r--r-- 1 root root 2223 May 26 23:00 koi-win&lt;br/&gt;-rw-r--r-- 1 root root 5231 May 26 23:00 mime.types&lt;br/&gt;lrwxrwxrwx 1 root root 22 May 26 23:01 modules -&amp;gt; /usr/lib/nginx/modules&lt;br/&gt;-rw-r--r-- 1 root root 643 May 26 23:01 &lt;span&gt;nginx.conf&lt;/span&gt;&lt;br/&gt;-rw-r--r-- 1 root root 636 May 26 23:00 scgi_params&lt;br/&gt;-rw-r--r-- 1 root root 664 May 26 23:00 uwsgi_params&lt;br/&gt;-rw-r--r-- 1 root root 3610 May 26 23:00 win-utf&lt;br/&gt;[root@ldk _data]#&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;#拓展：&lt;br/&gt;ro  readonly   只读：设置之后，只能通过容器外部进行改写，容器内不禁止操作，且权限不可修改&lt;br/&gt;rw  readwrite  可读可写，容器内外均可读写&lt;/span&gt;&lt;span&gt;&lt;br/&gt;docker run -d -P --name nginx02 -v &lt;strong&gt;jumign-nginx&lt;/strong&gt;:/etc/nginx:ro nginx&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;docker run -d -P --name nginx02 -v &lt;strong&gt;jumign-nginx&lt;/strong&gt;:/etc/nginx:rw nginx&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;三、数据卷之Dockerfile&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;初识Dockerfile：之前我们使用commit命令生成过镜像，我们也可以使用Dockerfile构建镜像，说白了，Dockerfile就是Docker镜像的构建文件，就是一段命令脚本！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 小试一把：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;89&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#在宿主机 /home/docker-test-volume/ 下新建一个dockerfile1的文件&lt;/span&gt;
&lt;/pre&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;span readability=&quot;2&quot;&gt;[root@ldk /]# cd /home/
[root@ldk home]# mkdir docker-test-volume
[root@ldk home]# cd docker-test-volume/
[root@ldk docker-test-volume]# ll
total 0
[root@ldk docker-test-volume]# vim dockerfile1&lt;p&gt;&lt;span&gt;#编写脚本（开头大写，分层构建）：&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;FROM centos&lt;/p&gt;
&lt;p&gt;VOLUME [&quot;volume01&quot;,&quot;volume02&quot;]&lt;/p&gt;
&lt;p&gt;CMD echo &quot;------build end------&quot;&lt;/p&gt;
&lt;p&gt;CMD /bin/bash&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;#脚本解释：准备一个基础的centos镜像；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　设置具名挂载目录为volum01和volume02，创建的时候就挂载 ；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　构建完打印：------build end------；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　默认bash控制台；&lt;/span&gt;&lt;p&gt;&lt;span&gt;#执行脚本&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;[root@ldk docker-test-volume]# docker build -f /home/docker-test-volume/dockerfile1 -t ldk/centos:1.0 .&lt;br/&gt;Sending build context to Docker daemon 2.048kB&lt;br/&gt;Step 1/4 : FROM centos&lt;br/&gt;---&amp;gt; 470671670cac&lt;br/&gt;Step 2/4 : VOLUME [&quot;volume01&quot;,&quot;volume02&quot;]&lt;br/&gt;---&amp;gt; Running in 771370c6dfef&lt;br/&gt;Removing intermediate container 771370c6dfef&lt;br/&gt;---&amp;gt; 1941426d1d91&lt;br/&gt;Step 3/4 : CMD echo &quot;------build end------&quot;&lt;br/&gt;---&amp;gt; Running in 070cbd782e00&lt;br/&gt;Removing intermediate container 070cbd782e00&lt;br/&gt;---&amp;gt; c947d804f177&lt;br/&gt;Step 4/4 : CMD /bin/bash&lt;br/&gt;---&amp;gt; Running in 817099ec4089&lt;br/&gt;Removing intermediate container 817099ec4089&lt;br/&gt;---&amp;gt; 49a84ce17460&lt;br/&gt;Successfully built 49a84ce17460&lt;br/&gt;Successfully tagged ldk/centos:1.0&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;#创建镜像成功&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;[root@ldk docker-test-volume]# docker images&lt;br/&gt;REPOSITORY TAG IMAGE ID CREATED SIZE&lt;br/&gt;&lt;span&gt;ldk/centos 1.0 49a84ce17460 6 minutes ago 237MB&lt;/span&gt;&lt;br/&gt;tomcat latest 2eb5a120304e 10 days ago 647MB&lt;br/&gt;nginx latest 2622e6cca7eb 10 days ago 132MB&lt;br/&gt;mysql 5.7 9cfcce23593a 11 days ago 448MB&lt;br/&gt;mysql latest be0dbf01a0f3 11 days ago 541MB&lt;br/&gt;centos latest 470671670cac 5 months ago 237MB&lt;br/&gt;hello-world latest bf756fb1ae65 5 months ago 13.3kB&lt;br/&gt;[root@ldk docker-test-volume]#&lt;/p&gt;


&lt;pre&gt;
&lt;span&gt;&lt;span&gt;#启动自己构建的容器&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;[root@ldk /]# docker images&lt;br/&gt;REPOSITORY TAG IMAGE ID CREATED SIZE&lt;br/&gt;ldk/centos 1.0 49a84ce17460 8 minutes ago 237MB&lt;br/&gt;tomcat latest 2eb5a120304e 10 days ago 647MB&lt;br/&gt;nginx latest 2622e6cca7eb 10 days ago 132MB&lt;br/&gt;mysql 5.7 9cfcce23593a 11 days ago 448MB&lt;br/&gt;mysql latest be0dbf01a0f3 11 days ago 541MB&lt;br/&gt;centos latest 470671670cac 5 months ago 237MB&lt;br/&gt;hello-world latest bf756fb1ae65 5 months ago 13.3kB&lt;br/&gt;[root@ldk /]# docker run -it 49a84ce17460 /bin/bash&lt;br/&gt;[root@7b0a9902dbeb /]# ls -l&lt;br/&gt;total 56&lt;br/&gt;lrwxrwxrwx 1 root root 7 May 11 2019 bin -&amp;gt; usr/bin&lt;br/&gt;drwxr-xr-x 5 root root 360 Jun 20 09:44 dev&lt;br/&gt;drwxr-xr-x 1 root root 4096 Jun 20 09:44 etc&lt;br/&gt;drwxr-xr-x 2 root root 4096 May 11 2019 home&lt;br/&gt;lrwxrwxrwx 1 root root 7 May 11 2019 lib -&amp;gt; usr/lib&lt;br/&gt;lrwxrwxrwx 1 root root 9 May 11 2019 lib64 -&amp;gt; usr/lib64&lt;br/&gt;drwx------ 2 root root 4096 Jan 13 21:48 lost+found&lt;br/&gt;drwxr-xr-x 2 root root 4096 May 11 2019 media&lt;br/&gt;drwxr-xr-x 2 root root 4096 May 11 2019 mnt&lt;br/&gt;drwxr-xr-x 2 root root 4096 May 11 2019 opt&lt;br/&gt;dr-xr-xr-x 95 root root 0 Jun 20 09:44 proc&lt;br/&gt;dr-xr-x--- 2 root root 4096 Jan 13 21:49 root&lt;br/&gt;drwxr-xr-x 11 root root 4096 Jan 13 21:49 run&lt;br/&gt;lrwxrwxrwx 1 root root 8 May 11 2019 sbin -&amp;gt; usr/sbin&lt;br/&gt;drwxr-xr-x 2 root root 4096 May 11 2019 srv&lt;br/&gt;dr-xr-xr-x 13 root root 0 Jun 20 09:31 sys&lt;br/&gt;drwxrwxrwt 7 root root 4096 Jan 13 21:49 tmp&lt;br/&gt;drwxr-xr-x 12 root root 4096 Jan 13 21:49 usr&lt;br/&gt;drwxr-xr-x 20 root root 4096 Jan 13 21:49 var&lt;br/&gt;drwxr-xr-x 2 root root 4096 Jun 20 09:44 &lt;span&gt;volume01   //这两个就是我们自动挂载的数据卷目录&lt;/span&gt;&lt;br/&gt;drwxr-xr-x 2 root root 4096 Jun 20 09:44 &lt;span&gt;volume02&lt;/span&gt;&lt;br/&gt;[root@7b0a9902dbeb /]#&lt;/p&gt;


&lt;pre readability=&quot;5&quot;&gt;
#验证是否挂载成功（在容器内部新建一个 av.txt文件，去宿主机寻找被同步的av.txt）&lt;p&gt;#&lt;span&gt;&lt;strong&gt;进入容器内&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;的挂载目录 /volum01，新建文件 av.txt&lt;/span&gt;
&lt;/p&gt;&lt;/pre&gt;
&lt;p&gt;[root@7b0a9902dbeb /]# cd volume01&lt;br/&gt;[root@7b0a9902dbeb volume01]# ls&lt;br/&gt;[root@7b0a9902dbeb volume01]# touch av.txt&lt;br/&gt;[root@7b0a9902dbeb volume01]# ls&lt;br/&gt;av.txt&lt;br/&gt;[root@7b0a9902dbeb volume01]#&lt;/p&gt;


&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;&lt;strong&gt;进入宿主机 &lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;[root@ldk ~]# docker ps&lt;br/&gt;CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES&lt;br/&gt;7b0a9902dbeb 49a84ce17460 &quot;/bin/bash&quot; 5 minutes ago Up 5 minutes serene_napier&lt;br/&gt;709e5d31a7ad nginx &quot;/docker-entrypoint.…&quot; 57 minutes ago Up 57 minutes 0.0.0.0:32769-&amp;gt;80/tcp nginx02&lt;br/&gt;9aef70a2a4a5 nginx &quot;/docker-entrypoint.…&quot; About an hour ago Up About an hour 0.0.0.0:32768-&amp;gt;80/tcp nginx01&lt;br/&gt;[root@ldk ~]# docker inspect 7b0a9902dbeb&lt;br/&gt;...&lt;br/&gt;]&lt;br/&gt;},&lt;br/&gt;&quot;GraphDriver&quot;: {&lt;br/&gt;&quot;Data&quot;: {&lt;br/&gt;&quot;LowerDir&quot;: &quot;/var/lib/docker/overlay2/11bd55866068e52271cf7f50ab7adf3fdb1eef887f0f3560810ce83d36a44fcb-init/diff:/var/lib/docker/overlay2/07e92bfd3de681a8ac6ef84545406794783f828fd4f8f0303be4f18ae4e4e198/diff&quot;,&lt;br/&gt;&quot;MergedDir&quot;: &quot;/var/lib/docker/overlay2/11bd55866068e52271cf7f50ab7adf3fdb1eef887f0f3560810ce83d36a44fcb/merged&quot;,&lt;br/&gt;&quot;UpperDir&quot;: &quot;/var/lib/docker/overlay2/11bd55866068e52271cf7f50ab7adf3fdb1eef887f0f3560810ce83d36a44fcb/diff&quot;,&lt;br/&gt;&quot;WorkDir&quot;: &quot;/var/lib/docker/overlay2/11bd55866068e52271cf7f50ab7adf3fdb1eef887f0f3560810ce83d36a44fcb/work&quot;&lt;br/&gt;},&lt;br/&gt;&quot;Name&quot;: &quot;overlay2&quot;&lt;br/&gt;},&lt;br/&gt;&quot;Mounts&quot;: [&lt;br/&gt;{&lt;br/&gt;&quot;Type&quot;: &quot;volume&quot;,&lt;br/&gt;&quot;Name&quot;: &quot;d4a5330aa541110183f279343a769ec93712ec71f6b71ebb71a76a452e3e21e2&quot;,&lt;br/&gt;&lt;strong&gt;&quot;Source&quot;: &quot;&lt;span&gt;/var/lib/docker/volumes/d4a5330aa541110183f279343a769ec93712ec71f6b71ebb71a76a452e3e21e2/_data&lt;/span&gt;&quot;,&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&quot;Destination&quot;: &quot;&lt;span&gt;volume01&lt;/span&gt;&quot;,&lt;/strong&gt;&lt;br/&gt;&quot;Driver&quot;: &quot;local&quot;,&lt;br/&gt;&quot;Mode&quot;: &quot;&quot;,&lt;br/&gt;&quot;RW&quot;: true,&lt;br/&gt;&quot;Propagation&quot;: &quot;&quot;&lt;br/&gt;},&lt;br/&gt;...&lt;br/&gt;[root@ldk ~]# cd /var/lib/docker/volumes/d4a5330aa541110183f279343a769ec93712ec71f6b71ebb71a76a452e3e21e2/_data&lt;br/&gt;[root@ldk _data]# ll&lt;br/&gt;total 0&lt;br/&gt;-rw-r--r-- 1 root root 0 Jun 20 17:50 &lt;span&gt;&lt;strong&gt;&lt;span&gt;av.txt&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;[root@ldk _data]#&lt;/p&gt;
&lt;/div&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;四、数据卷容器&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;多个mysql同步数据！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1519601/202006/1519601-20200620201638471-1831997876.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre readability=&quot;7.5&quot;&gt;
&lt;span readability=&quot;9&quot;&gt;&lt;span&gt;#启动我们自己制作的镜像（注：启动命名最后一个参数，要么填写镜像id。要么填写 镜像名称+tag，否则会报错）&lt;/span&gt;
[root@ldk /]# docker run -it --name docker01 ldk/centos:1.0
[root@8a3e0b293bf9 /]# ls
bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var  volume01    volume02
&lt;br/&gt;&lt;span&gt;#启动成功之后 退出容器（Control + P + Q）&lt;/span&gt;&lt;p&gt;[root@8a3e0b293bf9 /]# [root@ldk /]# &lt;/p&gt;&lt;p&gt;&lt;span&gt;#依赖docker01启动docker02，docker01就叫做数据卷容器&lt;/span&gt;

[root@ldk /]# docker run -it --name docker02 --volumes-from docker01 ldk/centos:1.0
[root@ee6fa31cd361 /]# ls
bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var  volume01    volume02
[root@ee6fa31cd361 /]# cd volume01
[root@ee6fa31cd361 volume01]# ls&lt;/p&gt;&lt;p&gt;&lt;span&gt;#进入docker01内部在挂载目录 volumes01下创建一个文件&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;[root@ldk /]# docker ps&lt;br/&gt;CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES&lt;br/&gt;ee6fa31cd361 ldk/centos:1.0 &quot;/bin/sh -c /bin/bash&quot; About a minute ago Up About a minute docker02&lt;br/&gt;8a3e0b293bf9 ldk/centos:1.0 &quot;/bin/sh -c /bin/bash&quot; 4 minutes ago Up 4 minutes docker01&lt;br/&gt;[root@ldk /]# docker attach 8a3e0b293bf9&lt;br/&gt;[root@8a3e0b293bf9 /]# cd volume01&lt;br/&gt;[root@8a3e0b293bf9 volume01]# ls&lt;br/&gt;[root@8a3e0b293bf9 volume01]# touch docker01&lt;br/&gt;[root@8a3e0b293bf9 volume01]# ls&lt;br/&gt;&lt;strong&gt;&lt;span&gt;docker01&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;[root@8a3e0b293bf9 volume01]#&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;#进入docker02内部在挂载目录 volumes01 查看是否有同步更新的文件&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;[root@ee6fa31cd361 volume01]# ls
&lt;span&gt;&lt;strong&gt;&lt;span&gt;docker01&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;
[root@ee6fa31cd361 volume01]# &lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;#同理：创造一个docker03依赖docker01，效果一样，时拿出docker01，docker02 和docker03 已经 &lt;strong&gt;&lt;span&gt;同步拷贝 &lt;/span&gt;&lt;/strong&gt;的文件，依然存在！&lt;/span&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1519601/202006/1519601-20200620224643939-1062804001.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;
&lt;/pre&gt;


&lt;pre&gt;
&lt;span&gt; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;五、DockerFile介绍&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1、基础介绍：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　dockerfile就是用来构建docker镜像的文件，定义了一切步骤，就是一段包含命令和参数的可执行脚本。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;构建步骤：1、编写一个dockerfile文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　    2、docker build 构建成为一个镜像&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　3、docker run 运行镜像&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　4、docker push 发布镜像（DockerHub 、阿里云镜像仓库）&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;构建过程：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;基础知识：1、每个保留关键字（指令）都必须是大写字母&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　　　　　2、从上向下执行&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　　　　　3、# 表示注释&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　　　　　4、每个指令都会创建一个新的镜像层，并提交&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1519601/202006/1519601-20200620230114602-220949841.png&quot; alt=&quot;&quot; width=&quot;771&quot; height=&quot;378&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt; 小总结：DockerFile是面向开发的，我们要发布项目，就需要制作镜像，就需要编写dockerfile文件，Docker镜像逐渐成为企业交付的标准。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　DockerFile：构建镜像的初始化文件，源代码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　DockerImages：通过DockerFile构建生成的容器，最终发布和运行的产品。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　Docker容器：容器就是镜像运行起来的服务器。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;DockerFile指令：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
FROM　　　　　　#基础镜像，一切的开始&lt;br/&gt;MANTAINER　　　#镜像作者（姓名+邮箱）&lt;br/&gt;RUN　　　　　　　#镜像构建的时候需要运行的命令&lt;br/&gt;ADD　　　　　　　#步骤中添加tomcat镜像，这个tomcat压缩包就是添加内容&lt;br/&gt;WORKDIR　　　　 #镜像的挂载目录 &lt;br/&gt;VOLUME　　　　　#挂载的目录位置&lt;br/&gt;EXPOSE　　　　　#指定暴露端口&lt;br/&gt;CMD　　　　　　　#指定这个容器启动的时候要运行的命令，&lt;span&gt;只有最后一个会生效，可被替代，如果替代之后不是命令，会报错的&lt;/span&gt;&lt;br/&gt;ENTRYPOINT　　　#指定这个容器启动的时候要运行的命令，&lt;span&gt;可以追加执行命令&lt;/span&gt;&lt;br/&gt;ONBUILD　　　　 #当构建一个被继承的DockerFile，这个时候就会运行ONBUILD 的指令，触发指令。&lt;br/&gt;COPY　　　　　　 #类似AD的，将我们的镜像拷贝到镜像中&lt;br/&gt;WNV　　　　　　　#构建的时候这只环境变量
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;2、实战：构建自己的centos&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;69&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#1、编写DockerFile文件&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;[root@ldk home]# mkdir dockerfile&lt;br/&gt;[root@ldk home]# cd dockerfile/&lt;br/&gt;[root@ldk dockerfile]# ll&lt;br/&gt;total 0&lt;br/&gt;[root@ldk dockerfile]# vim &lt;span&gt;dockerfile01&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;DockerFile文件内容：&lt;/span&gt;&lt;/strong&gt;
&lt;/pre&gt;
&lt;p&gt;FROM centos&lt;/p&gt;
&lt;p&gt;MAINTAINER ldk&amp;lt;107123456@qq.com&amp;gt;&lt;/p&gt;
&lt;p&gt;ENV MYPATH /usr/local&lt;br/&gt;WORKDIR $MYPATH&lt;/p&gt;
&lt;p&gt;RUN yum -y install vim&lt;br/&gt;RUN yum -y install net-tools&lt;/p&gt;
&lt;p&gt;EXPOSE 80&lt;/p&gt;
&lt;p&gt;CMD echo $MYPATH&lt;br/&gt;CMD echo &quot;----end----&quot;&lt;br/&gt;CMD /bin/bash&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;#2、通过这个DockerFile构建镜像&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;[root@ldk dockerfile]# docker build -f &lt;span&gt;dockerfile01&lt;/span&gt; -t ldkcentos:0.1 .&lt;br/&gt;Sending build context to Docker daemon 2.048kB&lt;br/&gt;Step 1/10 : FROM centos&lt;br/&gt;---&amp;gt; 470671670cac&lt;br/&gt;Step 2/10 : MAINTAINER ldk&amp;lt;107123456@qq.com&amp;gt;&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;---&amp;gt; Running in 58114b729de4&lt;br/&gt;Removing intermediate container 58114b729de4&lt;br/&gt;---&amp;gt; 3c797ceb67f6&lt;br/&gt;&lt;span&gt;Successfully built 3c797ceb67f6&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Successfully tagged &lt;strong&gt;ldkcentos&lt;/strong&gt;:0.1&lt;/span&gt;&lt;br/&gt;[root@ldk dockerfile]# &lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;#3、构建成功，测试运行&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;[root@ldk dockerfile]# docker images&lt;br/&gt;REPOSITORY TAG IMAGE ID CREATED SIZE&lt;br/&gt;&lt;strong&gt;&lt;span&gt;ldkcentos 0.1 3c797ceb67f6 5 minutes ago 317MB&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;ldk/centos 1.0 49a84ce17460 6 hours ago 237MB&lt;br/&gt;tomcat latest 2eb5a120304e 10 days ago 647MB&lt;br/&gt;nginx latest 2622e6cca7eb 10 days ago 132MB&lt;br/&gt;mysql 5.7 9cfcce23593a 11 days ago 448MB&lt;br/&gt;mysql latest be0dbf01a0f3 11 days ago 541MB&lt;br/&gt;centos latest 470671670cac 5 months ago 237MB&lt;br/&gt;hello-world latest bf756fb1ae65 5 months ago 13.3kB&lt;br/&gt;[root@ldk dockerfile]#&lt;/p&gt;
&lt;pre&gt;
#启动自己构建的镜像
&lt;/pre&gt;
&lt;p&gt;[root@ldk dockerfile]# docker run -it ldkcentos:0.1&lt;br/&gt;[root@b334b9f261bf local]#&lt;/p&gt;
&lt;p&gt;#我们发现进入镜像，直接进入了刚才DockerFile 设置的工作目录 /usr/local 下。&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;#4、docker history 镜像id  ：查看镜像的构建过程历史信息，可以自己试一下。&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;3、实战：DockerFile制作tomcat镜像&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;69&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#1、准备镜像文件  tomcat压缩包，jdk压缩包&lt;/span&gt;
&lt;/pre&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/1519601/202006/1519601-20200621003034022-1233637600.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;pre&gt;
&lt;br/&gt;&lt;span&gt;#2、编写dockerfile文件，官方命名：DockerFile，build会自动寻找这个文件，就不需要-f指定了&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;[root@ldk tomcat]# vim Dockerfile&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  #文件内容：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;FROM centos&lt;br/&gt;MAINTAINER ldk&amp;lt;107123456@qq.com&amp;gt;&lt;/p&gt;
&lt;p&gt;COPY readme.txt /usr/local/readme.txt&lt;/p&gt;
&lt;p&gt;ADD jdk-8u65-linux-x64.tar.gz /usr/local/&lt;br/&gt;ADD apache-tomcat-8.0.28.tar.gz /usr/local/&lt;/p&gt;
&lt;p&gt;RUN yum -y install vim&lt;/p&gt;
&lt;p&gt;ENV MYPATH /usr/local&lt;br/&gt;WORKDIR $MYPATH&lt;/p&gt;
&lt;p&gt;ENV JAVA_HOME /usr/local/jdk1.8.0.65&lt;br/&gt;ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_MOHE/lib/tools.jar&lt;br/&gt;ENV CATALINA_HOME /usr/local/apache-tomcat-8.0.28&lt;br/&gt;ENV CATLINA_BASH /usr/local/apache-tomcat-8.0.28&lt;br/&gt;ENV PATH $PATH:$JAVA_HOME/bin:$CATALIN_HOME/lib:$CATALINA_HOME/bin&lt;/p&gt;
&lt;p&gt;EXPOSE 8080&lt;/p&gt;
&lt;p&gt;CMD /usr/local/apache-tomcat-8.0.28/bin/startup.sh &amp;amp;&amp;amp; tail -F /url/local/apache-tomcat-8.0.28/bin/logs/catalina.out&lt;/p&gt;
&lt;pre&gt;
&lt;br/&gt;&lt;span&gt;3、构建镜像&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;[root@ldk tomcat]# docker build -t diytomcat .&lt;/p&gt;
&lt;p&gt;[root@ldk tomcat]# docker images&lt;br/&gt;REPOSITORY TAG IMAGE ID CREATED SIZE&lt;br/&gt;&lt;span&gt;diytomcat latest 2835818b0158 15 minutes ago 672MB&lt;/span&gt;&lt;br/&gt;ldkcentos 0.1 3c797ceb67f6 About an hour ago 317MB&lt;br/&gt;ldk/centos 1.0 49a84ce17460 7 hours ago 237MB&lt;br/&gt;tomcat latest 2eb5a120304e 10 days ago 647MB&lt;br/&gt;nginx latest 2622e6cca7eb 11 days ago 132MB&lt;br/&gt;mysql 5.7 9cfcce23593a 11 days ago 448MB&lt;br/&gt;mysql latest be0dbf01a0f3 11 days ago 541MB&lt;br/&gt;centos latest 470671670cac 5 months ago 237MB&lt;br/&gt;hello-world latest bf756fb1ae65 5 months ago 13.3kB&lt;br/&gt;[root@ldk tomcat]#&lt;/p&gt;
&lt;pre&gt;
&lt;br/&gt;&lt;span&gt;4、启动镜像&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;[root@ldk tomcat]# docker run -d -p 3310:8080 --name ldkdiytomcat -v /home/ldk/build/tomcat/test:/url/local/apache-tomcat-8.0.28/webapps/test -v /home/ldk/build/tomcat/tomcatlogs/:/url/local/apache-tomcat-8.0.28/logs diytomcat&lt;br/&gt;d29fef718ec1b522847d1be13811dcfe6bd64da753c2e887fa54fa982ce2d35f&lt;/p&gt;
&lt;p&gt;[root@ldk tomcat]# pwd&lt;br/&gt;/home/ldk/build/tomcat&lt;br/&gt;[root@ldk tomcat]# ll&lt;br/&gt;total 8&lt;br/&gt;drwxr-xr-x 2 root root 4096 Jun 21 00:54 test&lt;br/&gt;drwxr-xr-x 2 root root 4096 Jun 21 00:55 tomcatlogs&lt;br/&gt;[root@ldk tomcat]#ll&lt;/p&gt;
&lt;p&gt;total 8&lt;br/&gt;drwxr-xr-x 2 root root 4096 Jun 21 00:54 &lt;span&gt;test&lt;/span&gt;&lt;br/&gt;drwxr-xr-x 2 root root 4096 Jun 21 00:55 &lt;span&gt;tomcatlogs&lt;/span&gt;&lt;br/&gt;[root@ldk tomcat]#&lt;/p&gt;
&lt;pre&gt;
&lt;br/&gt;&lt;span&gt;5、访问测试&lt;/span&gt;
&lt;/pre&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/1519601/202006/1519601-20200621015516513-351491446.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;

&lt;pre&gt;
&lt;p&gt;&lt;span&gt;#ok,项目发布成功&lt;/span&gt;
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; 本周就暂时总结到这====》》》》&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;还剩下几个模块，&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;有兴趣的，记得留言，&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;我后期再更，&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;没有留言就不更了~&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;发布镜像到DockerHub&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;发布镜像到阿里云容器服务&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;Docker所有流程小结&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;Docker0网络详解&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;容器互联--link&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;自定义网络&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;网络连通&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 20 Jun 2020 18:03:00 +0000</pubDate>
<dc:creator>死磕编程</dc:creator>
<og:description>我们的口号是：再小的帆也能远航，人生不设限！！ 学习规划：继续上篇 《Docker入门》https://www.cnblogs.com/dk1024/p/13121389.html 继续讲解 》》》》</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/dk1024/p/13168348.html</dc:identifier>
</item>
<item>
<title>java小项目——抽奖系统 - xxmeng</title>
<link>http://www.cnblogs.com/xiao666/p/13171168.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiao666/p/13171168.html</guid>
<description>&lt;p&gt;来了来了！这不又到考试周了吗!愁人，又得复习，复习，复习！这段时间每天都在复习线代和高数！😭(说是复习，说实话其实是在预习，啊哈哈哈哈哈），得有一段时间都没有学到新的知识了，代码感觉都生疏了，惆怅😱.博客也好久都没有更新了，这不才完事。终于又可以写起来了，又可以学习新的知识了，其实说实话我写博客的主要目的就是要督促我自己学习新知识，因为自己有时候真的可懒了，再就是自己学会的知识输出出来，有的想法不对的，大家还可以一起讨论，其次也是为了帮助一些有疑难点的小白，希望你们学到同样的知识的时候，可以少走一点弯路。好啦，废话不多说，要说正事了。&lt;br/&gt;因为有几天没学新的东西了，所以我就把我学校的大作业拿了出来，就当是给有帮助的人一个参考吧！（虽然网上这些也挺多的，但是还是打算把它写出来了），有需要的抓紧收藏起来哦！！！&lt;/p&gt;
&lt;p&gt;         知识利用for、while、do-while等循环、if语句、switch语句、数组、String类之后，现在开始创建一个小型幸运抽奖系统。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;任务&lt;br/&gt;模拟注册登录幸运抽奖全过程&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;主要功能&lt;/p&gt;
&lt;p&gt;1.注册&lt;br/&gt;2.登陆&lt;br/&gt;3.抽奖&lt;/p&gt;

&lt;p&gt;阶段1 实现菜单的输出显示&lt;/p&gt;
&lt;p&gt;需求说明&lt;/p&gt;
&lt;p&gt;1.输出菜单&lt;br/&gt;2.选择菜单编号，输出菜单信息&lt;br/&gt;3.如果编号选择错误，输出“您的输入有误！”&lt;/p&gt;

&lt;p&gt;阶段2 实现菜单循环执行功能&lt;/p&gt;
&lt;p&gt;需求说明&lt;/p&gt;
&lt;p&gt;1.系统询问用户是否继续&lt;br/&gt;2.如果用户选择继续，则可以继续选择菜单，否则程序结束，退出系统&lt;/p&gt;

&lt;p&gt;阶段3 实现注册功能&lt;br/&gt;需求说明&lt;/p&gt;
&lt;p&gt;1.输入用户名和密码，系统产生4位随机数作为卡号。&lt;br/&gt;2.注册成功，显示注册信息并修改注册标识为true&lt;/p&gt;

&lt;p&gt;阶段4 实现登录功能&lt;/p&gt;
&lt;p&gt;需求说明&lt;/p&gt;
&lt;p&gt;1.输入注册时的用户名和密码，登录成功，系统提示欢迎信息&lt;br/&gt;2.如果用户名和密码输入错误，提示用户继续输入，最多有3次输入机会&lt;/p&gt;

&lt;p&gt;阶段5 实现幸运抽奖功能&lt;/p&gt;
&lt;p&gt;需求说明&lt;/p&gt;
&lt;p&gt;1.登录成功后，用户选择幸运抽奖菜单，进入幸运抽奖功能&lt;br/&gt;2.输入会员卡号，系统生成5个4位随机数作为幸运数字&lt;br/&gt;3.如果会员卡号是其中之一，则成为本日幸运会员；否则不是幸运会员&lt;/p&gt;

&lt;p&gt;以上五个阶段便实现了一个简单的幸运抽奖系统&lt;br/&gt;说明：&lt;/p&gt;
&lt;p&gt;在阶段3 注册的时候设置了在该系统中只能存储十个用户，而且注册时如果该用户名已经存在就会注册失败&lt;br/&gt;在阶段5 抽奖的时候如果没有先进行登陆便不能进行抽奖&lt;/p&gt;
&lt;p&gt;```&lt;br/&gt;源代码：&lt;/p&gt;
&lt;p&gt;package test;&lt;/p&gt;
&lt;p&gt;import java.util.Scanner;&lt;/p&gt;
&lt;p&gt;/*&lt;br/&gt; * 幸运抽奖&lt;br/&gt; * @author xxmeng&lt;br/&gt; */&lt;br/&gt;public class LuckyTwo {&lt;br/&gt; public static void main(String [] args) {&lt;br/&gt;  String input;&lt;br/&gt;  int temp=1,countx=0,county=0; //计数器&lt;br/&gt;  //注册的用户名，注册的密码，确认密码，登陆密码，会员号，幸运数&lt;br/&gt;  String username1=null,userpwd1=null,reuserpwd,username2=null,userpwd2,ID=null;&lt;br/&gt;  &lt;br/&gt;  //数组的下标不可以超过10个，也就是用户名注册的数目不可以超过10个&lt;br/&gt;  String[][] userlist=new String[10][3]; //存储用户名，密码，会员号&lt;br/&gt;  Scanner inputScanner = new Scanner(System.in);  //从键盘上进行输入&lt;br/&gt;  while(temp==1) { //循环系统&lt;br/&gt;   int temp1=1,flag=0; //计数器&lt;br/&gt;   System.out.println(&quot;******************欢迎进入xxmeng系统*******************&quot;);&lt;br/&gt;   System.out.println(&quot;    1.注册&quot;  ) ;&lt;br/&gt;   System.out.println(&quot;    2.登录&quot;  ) ;&lt;br/&gt;   System.out.println(&quot;    3.抽奖&quot;   ) ;&lt;br/&gt;   System.out.println(&quot;***********************************************************&quot;) ;&lt;br/&gt;   System.out.println(&quot;请选择菜单号&quot;) ;&lt;br/&gt;   input=inputScanner.next();&lt;br/&gt;   &lt;br/&gt;   if(input.equals(&quot;1&quot;) || input.equals(&quot;2&quot;) || input.equals(&quot;3&quot;)) {&lt;br/&gt;    switch(input) {&lt;br/&gt;    case &quot;1&quot;:    //注册&lt;br/&gt;     int flag1=1;&lt;br/&gt;     System.out.println(&quot;xxmeng系统&amp;gt;注册&quot;);&lt;br/&gt;     System.out.println(&quot;请填写个人注册信息&quot;);&lt;br/&gt;     do {//验证用户是否存在&lt;br/&gt;      System.out.print(&quot;用户名： &quot;);&lt;br/&gt;      username1 = inputScanner.next();&lt;br/&gt;      int i=0;&lt;br/&gt;      for(i=0;i&amp;lt;10;i++) {&lt;br/&gt;       if(username1.equals(userlist[i][0])) {&lt;br/&gt;        System.out.println(&quot;用户已经存在&quot;);&lt;br/&gt;        i=0;&lt;br/&gt;        break;&lt;br/&gt;       }&lt;br/&gt;      }&lt;br/&gt;      if(i!=0) {&lt;br/&gt;       flag1=0;&lt;br/&gt;      }&lt;br/&gt;     }while(flag1==1);&lt;br/&gt;     while(true) {&lt;br/&gt;      System.out.print(&quot;密码 :&quot;);&lt;br/&gt;      userpwd1=inputScanner.next();&lt;br/&gt;      System.out.print(&quot;请确认密码 :&quot;);&lt;br/&gt;      reuserpwd = inputScanner.next();&lt;br/&gt;      &lt;br/&gt;      //如果输入的密码和当初设定的密码相同&lt;br/&gt;      if(userpwd1.equals(reuserpwd)) {&lt;br/&gt;       System.out.println(&quot;  注册成功, 请记住你的会员卡号  &quot;);&lt;br/&gt;       System.out.println(&quot;  用户名  &quot; + '\t' + &quot;   密码   &quot; + '\t' + &quot;  会员卡号  &quot;);&lt;br/&gt;       &lt;br/&gt;       //进行四次循环每次随机抽取一次幸运号，一个抽取四次 且抽奖的大小在1~9之间&lt;br/&gt;       for(int i=0;i&amp;lt;4;i++) {&lt;br/&gt;        int a = (int )(1 + Math.random() *(9));&lt;br/&gt;        ID+=String.valueOf(a);&lt;br/&gt;       }&lt;br/&gt;       &lt;br/&gt;       /*&lt;br/&gt;        * 存储用户的信息&lt;br/&gt;        */&lt;br/&gt;       userlist[countx][county]=username1;//存储用户名&lt;br/&gt;       System.out.print((userlist[countx][county]) + '\t');&lt;br/&gt;       userlist[countx][++county]=userpwd1;//存储密码&lt;br/&gt;       System.out.print((userlist[countx][county]) + '\t');&lt;br/&gt;       userlist[countx][++county]=ID.substring(4); //存储会员号&lt;br/&gt;       System.out.print((userlist[countx][county]));&lt;br/&gt;       ID=null;&lt;br/&gt;       System.out.println();&lt;br/&gt;       county=0;&lt;br/&gt;       countx++;&lt;br/&gt;       System.out.println(&quot;是否继续(y/n)&quot;);&lt;br/&gt;       &lt;br/&gt;       char anserString = inputScanner.next().charAt(0);&lt;br/&gt;       //如果不继续输入了&lt;br/&gt;       if(anserString =='n') {&lt;br/&gt;        temp=0;&lt;br/&gt;        break;&lt;br/&gt;       }else {&lt;br/&gt;        break;&lt;br/&gt;       }&lt;br/&gt;       &lt;br/&gt;      }else {&lt;br/&gt;       System.out.println(&quot;两次密码不一样，请重新输入密码 &quot;);//回头再次修改&lt;br/&gt;       continue;&lt;br/&gt;      }&lt;br/&gt;     }&lt;br/&gt;     &lt;br/&gt;     //否则退出&lt;br/&gt;     break;&lt;br/&gt;     &lt;br/&gt;     &lt;br/&gt;     /*&lt;br/&gt;      *2. 登录&lt;br/&gt;      */&lt;br/&gt;    case &quot;2&quot; :&lt;br/&gt;     System.out.println(&quot; xxmeng系统&amp;gt;登录 &quot;);&lt;br/&gt;     System.out.println(&quot; 请输入用户名 : &quot;);&lt;br/&gt;     username2 = inputScanner.next();&lt;br/&gt;     for(int i=0;i&amp;lt;10;i++) {&lt;br/&gt;      flag++;&lt;br/&gt;      &lt;br/&gt;      //判断是否存在此用户&lt;br/&gt;      if(username2.equals(userlist[i][0])) {&lt;br/&gt;       while(temp1&amp;lt;4) {&lt;br/&gt;        System.out.println(&quot;请输入密码 : &quot;);&lt;br/&gt;        userpwd2=inputScanner.next();&lt;br/&gt;        &lt;br/&gt;        //判断登录密码是否正确&lt;br/&gt;        if(userpwd2.equals(userlist[i][1])) {&lt;br/&gt;         System.out.println(&quot;欢迎您         &quot; + userlist[i][0]);&lt;br/&gt;         ID=userlist[i][2];&lt;br/&gt;         temp1=4;&lt;br/&gt;        }else {&lt;br/&gt;         System.out.println(&quot;密码错误&quot;); //超过三次直接退出系统&lt;br/&gt;         temp1++;&lt;br/&gt;         if(temp1==4) {&lt;br/&gt;          temp=0;&lt;br/&gt;          i=11;&lt;br/&gt;         }&lt;br/&gt;         continue;&lt;br/&gt;        }&lt;br/&gt;       }&lt;br/&gt;      }&lt;br/&gt;     }&lt;br/&gt;     &lt;br/&gt;     if(temp1==4) {&lt;br/&gt;      break;&lt;br/&gt;     }&lt;br/&gt;     if(flag==4) {&lt;br/&gt;      System.out.println(&quot;不存在此用户&quot;);&lt;br/&gt;     }&lt;br/&gt;     &lt;br/&gt;     System.out.print(&quot;是否继续(y/n)&quot;);&lt;br/&gt;     char anserString = inputScanner.next().charAt(0);&lt;br/&gt;     if(anserString =='y') {&lt;br/&gt;      continue;&lt;br/&gt;    }&lt;br/&gt;     if(anserString =='n') {&lt;br/&gt;      temp=0;&lt;br/&gt;     }&lt;br/&gt;     break;&lt;br/&gt;     /*&lt;br/&gt;      * *&lt;br/&gt;      * 抽奖&lt;br/&gt;      */&lt;br/&gt;    case &quot;3&quot; :&lt;br/&gt;     if(ID==null) {&lt;br/&gt;      System.out.println(&quot;请先登录 &quot;);&lt;br/&gt;      continue;&lt;br/&gt;     }&lt;br/&gt;     System.out.println(&quot;xxmeng系统&amp;gt;抽奖&quot;);&lt;br/&gt;     System.out.println(&quot;您的卡号为 :    &quot;  +  ID  );&lt;br/&gt;     System.out.print(&quot;本日幸运数字为 ： &quot; );&lt;br/&gt;     String lucknums[] = new String[5];&lt;br/&gt;     String lucknumber = null;&lt;br/&gt;     for(int i=0;i&amp;lt;lucknums.length;i++) {&lt;br/&gt;      for(int j=0;j&amp;lt;4;j++) { //随机生成4个随机数字&lt;br/&gt;       int a=(int )(1 + Math.random() *(9));&lt;br/&gt;       lucknumber +=String.valueOf(a); //输入的那个数字把它转化成数字字符串&lt;br/&gt;      }&lt;br/&gt;      lucknums[i] = lucknumber.substring(4);&lt;br/&gt;      lucknumber=null;&lt;br/&gt;      System.out.println(lucknums[i] + '\t' );&lt;br/&gt;     }&lt;br/&gt;     System.out.println();&lt;br/&gt;     for(int i=0;i&amp;lt;lucknums.length;i++) {&lt;br/&gt;      if(lucknums[i].equals(ID)) {&lt;br/&gt;       System.out.println(&quot; 恭喜，您是本日的幸运会员 &quot;);&lt;br/&gt;      }&lt;br/&gt;     }&lt;br/&gt;     System.out.println(&quot; 抱歉！您不是本日的幸运会员 &quot;);&lt;br/&gt;     System.out.println(&quot;是否继续(y/n)&quot;);&lt;br/&gt;     char anserString1 =inputScanner.next().charAt(0);&lt;br/&gt;     if(anserString1 == 'n') {&lt;br/&gt;      temp=0;&lt;br/&gt;     }&lt;br/&gt;     break;&lt;br/&gt;     default:&lt;br/&gt;      System.out.println(&quot;  对不起！您的输入有误  &quot;);&lt;br/&gt;      continue;&lt;br/&gt;   }&lt;br/&gt;  }else {&lt;br/&gt;   System.out.println(&quot; 请输入正确的序号 &quot;);&lt;br/&gt;  }}&lt;br/&gt;  inputScanner.close();&lt;br/&gt;  System.out.println(&quot;   退出系统,谢谢使用！&quot;);&lt;br/&gt; }&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;```&lt;/p&gt;
&lt;p&gt;运行结果如下图所示：&lt;br/&gt;```&lt;br/&gt;******************欢迎进入奖客富翁系统*******************&lt;br/&gt;    1.注册&lt;br/&gt;    2.登录&lt;br/&gt;    3.抽奖&lt;br/&gt;***********************************************************&lt;br/&gt;请选择菜单号&lt;br/&gt;1&lt;br/&gt;奖客富翁系统&amp;gt;注册&lt;br/&gt;请填写个人注册信息&lt;br/&gt;用户名： xxmeng&lt;br/&gt;密码 :123&lt;br/&gt;请确认密码 :123&lt;br/&gt;  注册成功, 请记住你的会员卡号 &lt;br/&gt;  用户名      密码      会员卡号 &lt;br/&gt;xxmeng 123 8944&lt;br/&gt;是否继续(y/n)&lt;br/&gt;y&lt;br/&gt;******************欢迎进入奖客富翁系统*******************&lt;br/&gt;    1.注册&lt;br/&gt;    2.登录&lt;br/&gt;    3.抽奖&lt;br/&gt;***********************************************************&lt;br/&gt;请选择菜单号&lt;br/&gt;2&lt;br/&gt; 奖客富翁系统&amp;gt;登录&lt;br/&gt; 请输入用户名 :&lt;br/&gt;xxmeng&lt;br/&gt;请输入密码 :&lt;br/&gt;123&lt;br/&gt;欢迎您         xxmeng&lt;br/&gt;******************欢迎进入奖客富翁系统*******************&lt;br/&gt;    1.注册&lt;br/&gt;    2.登录&lt;br/&gt;    3.抽奖&lt;br/&gt;***********************************************************&lt;br/&gt;请选择菜单号&lt;br/&gt;3&lt;br/&gt;奖客富翁系统&amp;gt;抽奖&lt;br/&gt;您的卡号为 :    8944&lt;br/&gt;本日幸运数字为 ： 7845 &lt;br/&gt;6719 &lt;br/&gt;4573 &lt;br/&gt;4466 &lt;br/&gt;7239 &lt;/p&gt;
&lt;p&gt; 抱歉！您不是本日的幸运会员&lt;br/&gt;是否继续(y/n)&lt;br/&gt;n&lt;br/&gt;   退出系统,谢谢使用！&lt;/p&gt;
&lt;p&gt;```&lt;/p&gt;
&lt;p&gt;这就是一个小的抽奖系统，很简单易懂，没有复杂的地方，其实还可以加一些界面什么的，但是没做那么复杂的，就一个学校的作业，就当给你们做一个参考吧！&lt;/p&gt;
&lt;p&gt;明天打算更新并发，线程，进程之类的，艾玛为何感觉知识这么多，还有太多知识没有学到，学完了还忘 呜呜呜.....！&lt;/p&gt;



</description>
<pubDate>Sat, 20 Jun 2020 17:18:00 +0000</pubDate>
<dc:creator>xxmeng</dc:creator>
<og:description>来了来了！这不又到考试周了吗!愁人，又得复习，复习，复习！这段时间每天都在复习线代和高数！&amp;#128557;(说是复习，说实话其实是在预习，啊哈哈哈哈哈），得有一段时间都没有学到新的知识了，代码感觉都</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiao666/p/13171168.html</dc:identifier>
</item>
<item>
<title>【Spring注解驱动开发】如何使用@Bean注解指定初始化和销毁的方法？看这一篇就够了！！ - 冰河团队</title>
<link>http://www.cnblogs.com/binghe001/p/13171123.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/binghe001/p/13171123.html</guid>
<description>&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;blockquote readability=&quot;7.4825174825175&quot;&gt;
&lt;p&gt;在【&lt;a href=&quot;https://www.cnblogs.com/binghe001/category/1780611.html&quot;&gt;String注解驱动开发专题&lt;/a&gt;】中，前面的文章我们主要讲了有关于如何向Spring容器中注册bean的知识，大家可以到【&lt;a href=&quot;https://www.cnblogs.com/binghe001/category/1780611.html&quot;&gt;String注解驱动开发专题&lt;/a&gt;】中系统学习。接下来，我们继续肝Spring，只不过从本篇文章开始，我们就进入Spring容器中有关Bean的生命周期的学习。&lt;/p&gt;
&lt;p&gt;项目工程源码已经提交到GitHub：&lt;a href=&quot;https://github.com/sunshinelyz/spring-annotation&quot;&gt;https://github.com/sunshinelyz/spring-annotation&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;bean的生命周期&quot;&gt;Bean的生命周期&lt;/h2&gt;
&lt;p&gt;通常意义上讲的bean的名称周期，指的是bean从创建到初始化，经过一系列的流程，最终销毁的过程。只不过，在Spring中，bean的生命周期是由Spring容器来管理的。在Spring中，我们可以自己来指定bean的初始化和销毁的方法。当我们指定了bean的初始化和销毁方法时，当容器在bean进行到当前生命周期的阶段时，会自动调用我们自定义的初始化和销毁方法。&lt;/p&gt;
&lt;h2 id=&quot;如何定义初始化和销毁方法？&quot;&gt;如何定义初始化和销毁方法？&lt;/h2&gt;
&lt;p&gt;我们已经知道了由Spring管理bean的生命周期时，我们可以指定bean的初始化和销毁方法，那具体该如何定义这些初始化和销毁方法呢？接下来，我们就介绍第一种定义初始化和销毁方法的方式： &lt;strong&gt;通过@Bean注解指定初始化和销毁方法。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果是使用XML文件的方式配置bean的话，可以在标签中指定bean的初始化和销毁方法，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;bean id = &quot;person&quot; class=&quot;io.mykit.spring.plugins.register.bean.Person&quot; init-method=&quot;init&quot; destroy-method=&quot;destroy&quot;&amp;gt;
    &amp;lt;property name=&quot;name&quot; value=&quot;binghe&quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;property name=&quot;age&quot; value=&quot;18&quot;&amp;gt;&amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里，需要注意的是，在我们写的Person类中，需要存在init()方法和destroy()方法。而且Spring中规定，这里的init()方法和destroy()方法必须是无参方法，但可以抛异常。&lt;/p&gt;
&lt;p&gt;如果我们使用注解的方式，该如何实现指定bean的初始化和销毁方法呢？接下来，我们就一起来搞定它！！&lt;/p&gt;
&lt;p&gt;首先，创建一个名称为Student的类，这个类的实现比较简单，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package io.mykit.spring.plugins.register.bean;
/**
 * @author binghe
 * @version 1.0.0
 * @description 测试bean的初始化和销毁方法
 */
public class Student {
    
    public Student(){
        System.out.println(&quot;Student类的构造方法&quot;);
    }

    public void init(){
        System.out.println(&quot;初始化Student对象&quot;);
    }

    public void destroy(){
        System.out.println(&quot;销毁Student对象&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来，我们将Student类对象通过注解的方式注册到Spring容器中，具体的做法就是新建一个LifeCircleConfig类作为Spring的配置类，将Student类对象通过LifeCircleConfig类注册到Spring容器中，LifeCircleConfig类的代码如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package io.mykit.spring.plugins.register.config;

import io.mykit.spring.plugins.register.bean.Student;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * @author binghe
 * @version 1.0.0
 * @description Bean的生命周期
 */
@Configuration
public class LifeCircleConfig {
    @Bean
    public Student student(){
        return new Student();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来，我们就新建一个BeanLifeCircleTest类来测试容器中的Student对象，BeanLifeCircleTest类的部分代码如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package io.mykit.spring.test;

import io.mykit.spring.plugins.register.config.LifeCircleConfig;
import org.junit.Test;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

/**
 * @author binghe
 * @version 1.0.0
 * @description 测试bean的生命周期
 */
public class BeanLifeCircleTest {

    @Test
    public void testBeanLifeCircle01(){
        //创建IOC容器
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(LifeCircleConfig.class);
        System.out.println(&quot;容器创建完成...&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在前面的文章中，我们说过：对于单实例bean对象来说，在Spring容器创建完成后，就会对单实例bean进行实例化。那么，我们先来运行下BeanLifeCircleTest类中的testBeanLifeCircle01()方法，输出的结果信息如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;Student类的构造方法
容器创建完成...
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，在Spring容器创建完成时，自动调用单实例bean的构造方法，对单实例bean进行了实例化操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总之：对于单实例bean来说，在Spring容器启动的时候创建对象；对于多实例bean来说，在每次获取bean的时候创建对象。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;现在，我们在Student类中指定了init()方法和destroy()方法，那么，如何让Spring容器知道Student类中的init()方法是用来执行对象的初始化操作，而destroy()方法是用来执行对象的销毁操作呢？如果是使用XML文件配置的话，我们可以使用如下配置来实现。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;bean id=&quot;student&quot; class=&quot;io.mykit.spring.plugins.register.bean.Student&quot; init-method=&quot;init&quot; destroy-method=&quot;destroy&quot;&amp;gt;&amp;lt;/bean&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果我们在@Bean注解中该如何实现呢？其实就更简单了，我们来看下@Bean注解的源码，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package org.springframework.context.annotation;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

import org.springframework.beans.factory.annotation.Autowire;
import org.springframework.beans.factory.support.AbstractBeanDefinition;
import org.springframework.core.annotation.AliasFor;

@Target({ElementType.METHOD, ElementType.ANNOTATION_TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Bean {

        @AliasFor(&quot;name&quot;)
        String[] value() default {};

        @AliasFor(&quot;value&quot;)
        String[] name() default {};

        @Deprecated
        Autowire autowire() default Autowire.NO;

        boolean autowireCandidate() default true;

        String initMethod() default &quot;&quot;;

        String destroyMethod() default AbstractBeanDefinition.INFER_METHOD;

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看到@Bean注解的源码，相信小伙伴们会有种豁然开朗的感觉：没错，就是使用@Bean注解的initMethod属性和destroyMethod属性来指定bean的初始化方法和销毁方法。&lt;/p&gt;
&lt;p&gt;所以，我们在LifeCircleConfig类中的@Bean注解中指定initMethod属性和destroyMethod属性，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Bean(initMethod = &quot;init&quot;, destroyMethod = &quot;destroy&quot;)
public Student student(){
    return new Student();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时，我们再来运行BeanLifeCircleTest类中的testBeanLifeCircle01()方法，输出的结果信息如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;Student类的构造方法
初始化Student对象
容器创建完成...
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从输出结果可以看出，在Spring容器中，先是调用了Student类的构造方法来创建Student对象，接下来调用了Student对象的init()方法来进行初始化。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那小伙伴们可能会问，运行上面的代码没有打印出bean的销毁方法中的信息啊，那什么时候执行bean的销毁方法呢？&lt;/strong&gt; 这个问题问的很好， &lt;strong&gt;bean的销毁方法是在容器关闭的时候调用的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接下来，我们在BeanLifeCircleTest类中的testBeanLifeCircle01()方法中，添加关闭容器的代码，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void testBeanLifeCircle01(){
    //创建IOC容器
    AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(LifeCircleConfig.class);
    System.out.println(&quot;容器创建完成...&quot;);
    context.close();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们再来运行BeanLifeCircleTest类中的testBeanLifeCircle01()方法，输出的结果信息如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;Student类的构造方法
初始化Student对象
容器创建完成...
销毁Student对象
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，此时输出了对象的销毁方法中的信息，说明执行了对象的销毁方法。&lt;/p&gt;
&lt;h2 id=&quot;指定初始化和销毁方法的使用场景&quot;&gt;指定初始化和销毁方法的使用场景&lt;/h2&gt;
&lt;p&gt;一个典型的使用场景就是对于数据源的管理。例如，在配置数据源时，在初始化的时候，对很多的数据源的属性进行赋值操作；在销毁的时候，我们需要对数据源的连接等信息进行关闭和清理。此时，我们就可以在自定义的初始化和销毁方法中来做这些事情！&lt;/p&gt;
&lt;h2 id=&quot;初始化和销毁方法调用的时机&quot;&gt;初始化和销毁方法调用的时机&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;bean对象的初始化方法调用的时机：对象创建完成，如果对象中存在一些属性，并且这些属性也都赋值好之后，会调用bean的初始化方法。对于单实例bean来说，在Spring容器创建完成后，Spring容器会自动调用bean的初始化和销毁方法；对于单实例bean来说，在每次获取bean对象的时候，调用bean的初始化和销毁方法。&lt;/li&gt;
&lt;li&gt;bean对象的销毁方法调用的时机：对于单实例bean来说，在容器关闭的时候，会调用bean的销毁方法；对于多实例bean来说，Spring容器不会管理这个bean，也不会自动调用这个bean的销毁方法。不过，小伙伴们可以手动调用多实例bean的销毁方法。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;前面，我们已经说了单实例bean的初始化和销毁方法。接下来，我们来说下多实例bean的初始化和销毁方法。我们将Student对象变成多实例bean来验证下。接下来，我们在LifeCircleConfig类的student()方法上通过@Scope注解将Student对象设置成多实例bean，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Scope(&quot;prototype&quot;)
@Bean(initMethod = &quot;init&quot;, destroyMethod = &quot;destroy&quot;)
public Student student(){
    return new Student();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来，我们再来运行BeanLifeCircleTest类中的testBeanLifeCircle01()方法，输出的结果信息如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;容器创建完成...
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，&lt;strong&gt;当我们将Student对象设置成多实例bean，并且没有获取bean实例对象时，Spring容器并没有执行bean的构造方法、初始化方法和销毁方法。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;说到这，我们就在BeanLifeCircleTest类中的testBeanLifeCircle01()方法中添加一行获取Student对象的代码，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void testBeanLifeCircle01(){
    //创建IOC容器
    AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(LifeCircleConfig.class);
    System.out.println(&quot;容器创建完成...&quot;);
    context.getBean(Student.class);
    context.close();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时，我们再来运行BeanLifeCircleTest类中的testBeanLifeCircle01()方法，输出的结果信息如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;容器创建完成...
Student类的构造方法
初始化Student对象
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，此时，结果信息中输出了构造方法和初始化方法中的信息。但是当容器关闭时，并没有输出bean的销毁方法中的信息。&lt;/p&gt;
&lt;p&gt;这是因为 &lt;strong&gt;将bean设置成多实例时，Spring不会自动调用bean对象的销毁方法。至于多实例bean对象何时销毁，那就是程序员自己的事情了！！Spring容器不再管理多实例bean。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;好了，咱们今天就聊到这儿吧！别忘了给个在看和转发，让更多的人看到，一起学习一起进步！！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;2.3333333333333&quot;&gt;
&lt;p&gt;项目工程源码已经提交到GitHub：&lt;a href=&quot;https://github.com/sunshinelyz/spring-annotation&quot;&gt;https://github.com/sunshinelyz/spring-annotation&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;写在最后&quot;&gt;写在最后&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;如果觉得文章对你有点帮助，请微信搜索并关注「 冰河技术 」微信公众号，跟冰河学习Spring注解驱动开发。公众号回复“spring注解”关键字，领取Spring注解驱动开发核心知识图，让Spring注解驱动开发不再迷茫。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sat, 20 Jun 2020 16:35:00 +0000</pubDate>
<dc:creator>冰河团队</dc:creator>
<og:description>写在前面 在【String注解驱动开发专题】中，前面的文章我们主要讲了有关于如何向Spring容器中注册bean的知识，大家可以到【String注解驱动开发专题】中系统学习。接下来，我们继续肝Spri</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/binghe001/p/13171123.html</dc:identifier>
</item>
<item>
<title>GoAccess分析Web日志 - you-men</title>
<link>http://www.cnblogs.com/you-men/p/13171065.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/you-men/p/13171065.html</guid>
<description>&lt;h4 id=&quot;简介&quot;&gt;简介&lt;/h4&gt;
&lt;h5 id=&quot;为什么要用goaccess&quot;&gt;为什么要用GoAccess?&lt;/h5&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;GoAccess 被设计成快速的并基于终端的日志分析工具。其核心理念是不需要通过 Web 浏览器就能快速分析并实时查看 Web 服务器的统计数据(这对于需要使用 SSH 来对访问日志进行快速分析或者就是喜欢在终端环境下工作的人来说是超赞的)。&lt;/p&gt;
&lt;p&gt;终端输出仅仅是默认的输出方式，GoAccess 还支持生成完整的实时 HTML 报告(这对分析、监控以及数据可视化都是极好的)，以及 JSON 和 CSV 格式的报告。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;功能如下&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通用统计: 此面板展示了几个主要指标，比如：有效和无效请求的数量，分析这些数据所花费的时间，独立访客的情况，请求的文件，静态文件(CSS, ICO, JPG 等)的完整URL，404错误，被解析的日志文件的大小以及消耗的带宽。&lt;/li&gt;
&lt;li&gt;独立访客: 此面板按照日期展示了访问次数，独立访客数，以及累计消耗的带宽等指标。具有相同IP，相同访问时间，相同的 UserAgent 的 HTTP 请求将会被识别为独立访客。默认情况下包含了网络爬虫。&lt;br/&gt;您也可以选择使用 --date-spec=hr 参数将按照日期分析修改为按照小时，例如：05/Jun/2016:16 。这对于希望在小时级别去跟踪每日流量非常有帮助。&lt;/li&gt;
&lt;li&gt;请求的文件: 此面板展示您服务器上被请求次数最多的文件。包含访问次数，独立访客数，百分比，累计消耗带宽，使用的协议，请求方式。&lt;br/&gt;请求的静态文件: 列出请求频率最高的静态文件类型，例如： JPG, CSS, SWF, JS, GIF, 和 PNG , 以及和上一个面板一样的其他指标。 另外静态文件可以被添加到配置文件中。&lt;br/&gt;404 或者文件未找到: 展示内容与之前的面板类似，但是其数据包含了所有未找到的页面，以及俗称的 404 状态码。&lt;/li&gt;
&lt;li&gt;主机: 此面板展示主机自身的详细信息。能够很好的发现不怀好意的爬虫以及识别出是谁吃掉了你的带宽。&lt;br/&gt;扩展面板将向您展示更多信息，比如主机的反向DNS解析结果，主机所在国家和城市。如果开启了 参数，选择想查看的 IP 地址并按回车，将会显示 UserAgent 列表。&lt;/li&gt;
&lt;li&gt;操作系统: 此面板将显示主机使用的操作系统的信息。GoAccess 将尽可能尝试为每一款操作系统提供详细的信息。&lt;/li&gt;
&lt;li&gt;浏览器: 此面板将显示来访主机使用的浏览器信息。GoAccess 将尽可能尝试为每一款浏览器提供详细的信息。&lt;/li&gt;
&lt;li&gt;访问次数: 此面板按小时报告。因此将显示24个数据点，每一个均对应每一天的某一个小时。&lt;br/&gt;使用 --hour-spec=min 参数可以设定为按每十分钟报告，并将以 16:4 的格式显示时间。这对发现服务器的峰值访问时段很有帮助。&lt;/li&gt;
&lt;li&gt;虚拟主机: 此面板将显示从访问日志中解析出来的不同的虚拟主机的情况。此面板仅在日志格式中启用了 %v 参数时显示。&lt;/li&gt;
&lt;li&gt;来路URL: 如果问题主机通过其他的资源访问了你的站点，以及通过从其他主机上的链接或者跳转到你的站点，则这些来路URL将会被显示在此面板。可以在配置文件中通过 &lt;code&gt;--ignore-panel&lt;/code&gt; 开启此功能。(默认关闭)&lt;/li&gt;
&lt;li&gt;来路站点: 此面板将仅显示主机的部分，而不是完整的URL。&lt;/li&gt;
&lt;li&gt;关键字: 报告支持用在谷歌搜索，谷歌缓存，谷歌翻译上使用关键字。目前仅支持通过 HTTP 使用谷歌搜索。 可以在配置文件中通过 &lt;code&gt;--ignore-panel&lt;/code&gt; 开启此功能。(默认关闭)&lt;/li&gt;
&lt;li&gt;地理位置: 根据 IP 地址判断地理位置。统计数据按照大洲和国家分组。需要地理位置模块的支持。&lt;/li&gt;
&lt;li&gt;HTTP 状态码: 以数字表示的 HTTP 请求的状态编码。&lt;/li&gt;
&lt;li&gt;远程用户(HTTP验证) 通过 HTTP 验证来确定访问文档的权限。如果文档没有被密码保护起来，这部分将会显示为 “-”。此面板默认为开启，除非在日志格式变量中设置了参数 %e 。&lt;br/&gt;注意: 如果配置了可选项，所有面板将显示处理请求的平均时间消耗。&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;存储方式&quot;&gt;存储方式&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;GoAccess 支持三种类型的存储方式。请根据你的需要和系统环境进行选择。&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;默认哈希表&lt;br/&gt;内存哈希表可以提供较好的性能，缺点是数据集的大小受限于物理内存的大小。GoAccess 默认使用内存哈希表。如果你的内存可以装下你的数据集，那么这种模式的表现非常棒。此模式具有非常好的内存利用率和性能表现。&lt;/li&gt;
&lt;li&gt;Tokyo Cabinet 磁盘 B+ 树&lt;br/&gt;使用这种模式来处理巨大的数据集，大到不可能在内存中完成任务。当数据提交到磁盘以后，B+树数据库比任何一种哈希数据库都要慢。但是，使用 SSD 可以极大的提高性能。往后您可能需要快速载入保存的数据，那么这种方式就可以被使用。&lt;/li&gt;
&lt;li&gt;Tokyo Cabinet 内存哈希表&lt;br/&gt;作为默认哈希表的替换方案。因为使用通用类型在内存表现以及速度方面都很平均。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;部署&quot;&gt;部署&lt;/h4&gt;
&lt;h5 id=&quot;初始化环境&quot;&gt;初始化环境&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;init_security() {
systemctl stop firewalld
systemctl disable firewalld &amp;amp;&amp;gt;/dev/null
setenforce 0
sed -i '/^SELINUX=/ s/enforcing/disabled/' /etc/selinux/config
sed -i '/^GSSAPIAu/ s/yes/no/' /etc/ssh/sshd_config
sed -i '/^#UseDNS/ {s/^#//;s/yes/no/}' /etc/ssh/sshd_config
systemctl enable sshd crond &amp;amp;&amp;gt; /dev/null
echo -e &quot;\033[32m [安全配置] ==&amp;gt; OK \033[0m&quot;
}

init_yumsource() {
if [ ! -d /etc/yum.repos.d/backup ];then
mkdir /etc/yum.repos.d/backup
fi
mv /etc/yum.repos.d/* /etc/yum.repos.d/backup 2&amp;gt;/dev/null
if ! ping -c2 www.baidu.com &amp;amp;&amp;gt;/dev/null
then
echo &quot;您无法上外网，不能配置yum源&quot;
exit
fi
curl -o /etc/yum.repos.d/163.repo http://mirrors.163.com/.help/CentOS7-Base-163.repo &amp;amp;&amp;gt;/dev/null
curl -o /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo &amp;amp;&amp;gt;/dev/null
timedatectl set-timezone Asia/Shanghai
echo &quot;nameserver 114.114.114.114&quot; &amp;gt; /etc/resolv.conf
echo &quot;nameserver 8.8.8.8&quot; &amp;gt;&amp;gt; /etc/resolv.conf
chattr +i /etc/resolv.conf
echo -e &quot;\033[32m [YUM　Source] ==&amp;gt; OK \033[0m&quot;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;部署goaccess&quot;&gt;部署GoAccess&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;#安装依赖包
yum -y install glib2 glib2-devel ncurses ncurses-devel GeoIP GeoIP-devel GeoIP-data openssl-devel
wget https://tar.goaccess.io/goaccess-1.3.tar.gz

tar xf goaccess-1.3.tar.gz -C /usr/local/src/
cd goaccess-1.3
./configure --prefix=/usr/local/goaccess1.3 --enable-utf8 --enable-geoip=legacy --with-openssl


# --enable-debug  使用调试标志编译且关闭编译器优化。
# --enable-utf8   宽字符支持。依赖 Ncursesw 模块。
# --enable-geoip=&amp;lt;legacy|mmdb&amp;gt;  地理位置支持。依赖 MaxMind GeoIP 模块。 legacy 将使用原始 GeoIP 数据库。 mmdb 将使用增强版 GeoIP2 数据库。
# --enable-tcb=&amp;lt;memhash|btree&amp;gt;
# Tokyo Cabinet 存储支持。 memhash 将使用 Tokyo Cabinet 的内存哈希数据库。btree 将使用 Tokyo Cabinet 的磁盘 B+Tree 数据库。
# --disable-zlib  禁止在 B+Tree 数据库上使用 zlib 压缩。
# --disable-bzip  禁止在 B+Tree 数据库上使用 bzip2 压缩。
# --with-getline  使用动态扩展行缓冲区用来解析完整的行请求，否则将使用固定大小(4096)的缓冲区。
# --with-openssl  使 GoAccess 与其 WebSocket 服务器之间的通信能够支持 OpenSSL。

make &amp;amp;&amp;amp; make install
ln -s /usr/local/goaccess1.3/ /usr/local/goaccess

echo &quot;export PATH=/usr/local/goaccess/bin:$PATH&quot; &amp;gt;&amp;gt;/etc/profile
source /etc/profile
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;配置goaccess&quot;&gt;配置GoAccess&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;vim /usr/local/goaccess/etc/goaccess/goaccess.conf
time-format %T
date-format %d/%b/%Y
log-format %h - %^ [%d:%t %^]; &quot;%r&quot; %s %b &quot;%R&quot; - %^&quot;%u&quot; - %^ %T

# 配置文件参数说明
# -time-format
# 参数 time-format 后跟随一个空格符，指定日志的时间格式，包含普通字符与特殊格式说明符的任意组合。他们都由百分号 (%)开始。参考 man strftime。 %T 或者 %H:%M:%S.

# -date-format
# 参数 date-format 后跟随一个空格符，指定日志的日期格式，包含普通字符与特殊格式说明符的任意组合。他们都由百分号 (%)开始。参考 man strftime。

# -log-format
# 参数 log-format 后跟随一个空格符或者制表分隔符(\t)，用于指定日志字符串格式

%x 匹配 time-format 和 date-format 变量的日期和时间字段。用于使用时间戳来代替日期和时间两个独立变量的场景。
%t 匹配 time-format 变量的时间字段。
%d 匹配 date-format 变量的日期字段。
%v 根据 canonical 名称设定的服务器名称(服务区或者虚拟主机)。
%e 请求文档时由 HTTP 验证决定的用户 ID。
%h 主机(客户端IP地址，IPv4 或者 IPv6)。
%r 客户端请求的行数。这些请求使用分隔符(单引号，双引号)引用的部分可以被解析。否则，需要使用由特殊格式说明符(例如：%m, %U, %q 和 %H)组合格式去解析独立的字段。
注意: 既可以使用 %r 获取完整的请求，也可以使用 %m, %U, %q and %H 去组合你的请求，但是不能同时使用。
%m 请求的方法。
%U 请求的 URL。
注意: 如果查询字符串在 %U中，则无需使用 %q。但是，如果 URL 路径中没有包含任何查询字符串，则你可以使用 %q 查询字符串将附加在请求后面。
%q 查询字符串。
%H 请求协议。
%s 服务器回传客户端的状态码。
%b 回传客户端的对象的大小。
%R HTTP 请求的 &quot;Referer&quot; 值。
%u HTTP 请求的 &quot;UserAgent&quot; 值。
%D 处理请求的时间消耗，使用微秒计算。
%T 处理请求的时间消耗，使用带秒和毫秒计算。
%L 处理请求的时间消耗，使用十进制数表示的毫秒计算。
%^ 忽略此字段。
%~ 继续解析日志字符串直到找到一个非空字符(!isspace)。
~h 在 X-Forwarded-For (XFF) 字段中的主机(客户端 IP 地址，IPv4 或者 IPv6)。
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;部署nginx&quot;&gt;部署Nginx&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;cat /etc/yum.repos.d/nginx.repo
[nginx-stable]
name=nginx stable repo
baseurl=http://nginx.org/packages/centos/$releasever/$basearch/
gpgcheck=1
enabled=1
gpgkey=https://nginx.org/keys/nginx_signing.key
module_hotfixes=true

yum -y instal nginx


# 配置Nginx日志格式
vim /etc/nginx/nginx.conf
log_format  main  '$remote_addr - $remote_user [$time_local] &quot;$request&quot; '
                  '$status $body_bytes_sent &quot;$http_referer&quot; '
                  '&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot; $upstream_addr $request_time';

systemctl start nginx
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;使用&quot;&gt;使用&lt;/h4&gt;
&lt;h5 id=&quot;goaccess常用参数&quot;&gt;GoAccess常用参数&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;goaccess有控制台模式和html静态页面模式，这里先介绍一下控制台模式

goaccess -a -d -f logs/access_web.log -p /usr/local/goaccess/etc/goaccess/goaccess.conf

#常用参数
--addr=
# 将服务器绑定到指定 IP 地址。默认绑定到 0.0.0.0 。
通常无需指定，除非您希望将服务器绑定到主机上的其他地址。

--daemonize
# 使 GoAccess 作为守护程序运行(仅在 --real-time-html 开启下有效)。

--origin=
# E在 WebSocket 握手中确保客户端发送指定的源头。且指定的源应与浏览器发送源头字段完全相同。例如：--origin=http://goaccess.io

--port=
# 指定服务使用的端口。GoAccess 默认使用端口 7890 作为 WebSocket 服务器。请确保此端口可用。

--real-time-html
# 使能实时 HTML 报告。

--ws-url=&amp;lt;[scheme://]url[:port]&amp;gt;
# 此 URL 用于 WebSocket 服务器的回应。用于客户端侧的 WebSocket 构建器。
# 同时可以选择指定 WebSocket 的 URI 协议，比如：ws:// 用于非加密连接, 以及 wss:// 用于加密连接。示例：wss://goaccess.io
# 如果 GoAccess 运行在代理服务器的后面，您需要通过在主机名后跟随冒号加端口号的方式让客户端连接到另外一个不同的端口。示例：goaccess.io:9999
# 默认情况下，会尝试去连接生成报告的主机名。如果 GoAccess 运行在一台远程服务器上，则远程主机名也应该在 URL 中指定。当然，必须保证主机是有效的。

--fifo-in=&amp;lt;path/file&amp;gt;
# 创建一个管道(先入先出)从指定的路径/文件读取数据。

--fifo-out=&amp;lt;path/file&amp;gt;
# 创建一个管道(先入先出)往指定的路径/文件写入数据。

--ssl-cert=&amp;lt;path/cert.crt&amp;gt;
# 指定 TLS/SSL 证书的路径。使 GoAccess 支持 TLS/SSL，需要使用参数 --ssl-cert 和 --ssl-key。
# 仅在使用了参数 --with-openssl 时有效

--ssl-key=&amp;lt;path/priv.key&amp;gt;
# 指定 TLS/SSL 私钥的路径。使 GoAccess 支持 TLS/SSL，需要使用参数 --ssl-cert 和 --ssl-key。
# 仅在使用了参数 --with-openssl 时有效

1.24 FILE OPTIONS
-f --log-file=
# 指定输入日志文件的路径。如果在配置文件中指定了输入文件，则其优先级要高于在命令行中通过 -f 参数指定。

-l --log-debug=
# 发送所有调试信息到指定文件。需要指定配置选项 --enable-debug

-p --config-file=
# 指定使用自定义配置文件。如果设置了此参数，其优先级将高于全局配置文件(如果有)。

--invalid-requests=
# 记录无效请求到指定文件。

--no-global-config
# 禁止加载全局配置文件。可能的目录应该是 /usr/etc/, /etc/ 或者 /usr/local/etc/, 除非在运行 ./configure 时指定了 --sysconfdir=/dir 。


-a --agent-list
# 开启 UserAgent 列表。开启后会降低解析速度。

-d --with-output-resolver
# 输出 HTML 或者 JSON 报告时开启 IP 解析。

-e --exclude-ip &amp;lt;IP|IP-range&amp;gt;
# 排除一个 IPv4 或者 IPv6 地址。 使用连接符表示 IP 段(开始-结束)。

exclude-ip 127.0.0.1
exclude-ip 192.168.0.1-192.168.0.100
exclude-ip ::1
exclude-ip 0:0:0:0:0:ffff:808:804-0:0:0:0:0:ffff:808:808
-H --http-protocol=&amp;lt;yes|no&amp;gt;
HTTP 请求协议开关。将创建一个请求字段包含请求协议+真实请求。

-M --http-method=&amp;lt;yes|no&amp;gt;
# HTTP 请求方法开关。将创建一个请求字段包含请求方法+真实请求。

-o --output=&amp;lt;json|csv&amp;gt;
# 将给定文件重定向到标准输出，通过后缀名决定输出格式：
/path/file.csv - Comma-separated values (CSV)
/path/file.json - JSON (JavaScript Object Notation)
/path/file.html - HTML
-q --no-query-string
# 忽略请求的查询字符串。即： www.google.com/page.htm?query =&amp;gt; www.google.com/page.htm
# 注意: 去掉查询字符串将极大降低内存消耗，特别对带时间戳的请求。

-r --no-term-resolver
# 在终端输出时禁止 IP 解析。

--444-as-404
# 将非标准状态 444 作为 404 处理。

--4xx-to-unique-count
# 将 4xx 客户端错误数加到独立访客数中。

--all-static-files
# 统计包含查询字符串的静态文件。

--date-spec=&amp;lt;date|hr&amp;gt;
# 设置日期的显示格式，一种是标准日期格式(默认)，一种是日期后附加小时的格式。
# 仅在访客面板有效。对于在小时级别分析访客数据很有帮助。显示格式示例：18/Dec/2010:19

--double-decode
# 解码双重编码的值。包括 UserAgent，Request 以及 Referer。

--enable-panel=
# 开启指定面板。面板列表

控制台操作方法
F1   主帮助页面
F5   重绘主窗口
q    退出
1-15 跳转到对应编号的模块位置
o    打开当前模块的详细视图
j    当前模块向下滚动
k    当前模块向上滚动
s    对模块排序
/    在所有模块中搜索匹配
n    查找下一个出现的位置
g    移动到第一个模块顶部
G    移动到最后一个模块底部
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;配置nginx域名访问goaccess&quot;&gt;配置nginx域名访问goaccess&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 导入访问日志
goaccess -f /var/log/nginx/access.log --log-format=COMBINED -a -o /usr/local/nginx/html/index.html
vim /usr/local/nginx/conf/goaccess.conf
server  { 
        listen  7890;
        server_name 39.108.140.0;
        location / {
          root  /usr/local/nginx/html;
          try_files  $uri  $uri/  /index.html;
       }
            proxy_set_header Host $http_host;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection &quot;upgrade&quot;;
}

# 访问IP:7890,稍等片刻就会出现下面图形
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1871335/202006/1871335-20200621010025710-649601339.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;不同的输出&quot;&gt;不同的输出&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 输出到终端且生成一个可交互的报告：
# goaccess access.log

# 生成一份 HTML 报告：
# goaccess access.log -a -o report.html

# 生成一份 JSON 报告：
# goaccess access.log -a -d -o report.json

# 生成一份 CSV 文件：
# goaccess access.log --no-csv-summary -o report.csv

# GoAccess 非常灵活，支持实时解析和过滤。例如：需要通过监控实时日志来快速诊断问题：
# tail -f access.log | goaccess -

# 更厉害的是，还可以使用 tail -f 和一个模式匹配工具一起工作，比如： grep, awk, sed 等等
# tail -f access.log | grep -i --line-buffered 'firefox' | goaccess --log-format=COMBINED -

# 又或者可以在管道打开的状态下从头开始解析文件，并同时应用一个过滤器：
# tail -f -n +0 access.log | grep --line-buffered 'Firefox' | goaccess -o out.html --real-time-html -
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;实时html输出&quot;&gt;实时HTML输出&lt;/h5&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;em&gt;GoAccess 有能力在 HTML 报告中展示实时数据。您甚至可以通过电子邮件发送 HTML 报告，因为它是由没有外部文件依赖的单个文件组成，是不是很酷！&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 生成实时 HTML 报告的过程和生成静态报告的过程非常相似。实时报告仅仅需要使用参数 --real-time-html 。
# goaccess access.log -o /usr/share/nginx/html/site/report.html --real-time-html

# GoAccess 默认使用生成报告的主机名。您也可以指定 URL 用于客户端浏览器访问。参考 FAQ 上更详细的示例。
 # goaccess access.log -o report.html --real-time-html --ws-url=goaccess.io

# GoAccess 默认侦听端口 7890，如下使用其他端口可以这样操作(确保端口已经打开)：
# goaccess access.log -o report.html --real-time-html --port=9870

# 绑定 WebSocket 服务器到不同于 0.0.0.0 的另外一个地址，可以这样操作：
# goaccess access.log -o report.html --real-time-html --addr=127.0.0.1
# 注意: 如果需要在加密连接上输出实时数据，则需要使用 --ssl-cert=&amp;lt;cert.crt&amp;gt; 和 --ssl-key=&amp;lt;priv.key&amp;gt;。
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 20 Jun 2020 16:02:00 +0000</pubDate>
<dc:creator>you-men</dc:creator>
<og:description>简介 为什么要用GoAccess? GoAccess 被设计成快速的并基于终端的日志分析工具。其核心理念是不需要通过 Web 浏览器就能快速分析并实时查看 Web 服务器的统计数据(这对于需要使用 S</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/you-men/p/13171065.html</dc:identifier>
</item>
<item>
<title>容器技术之Docker-swarm - Linux-1874</title>
<link>http://www.cnblogs.com/qiuhom-1874/p/13169070.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qiuhom-1874/p/13169070.html</guid>
<description>&lt;p&gt;　　前文我聊到了docker machine的简单使用和基本原理的说明，回顾请参考&lt;a href=&quot;https://www.cnblogs.com/qiuhom-1874/p/13160915.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/qiuhom-1874/p/13160915.html&lt;/a&gt;；今天我们来聊一聊docker集群管理工具docker swarm；docker swarm是docker 官方的集群管理工具，它可以让跨主机节点来创建，管理docker 集群；它的主要作用就是可以把多个节点主机的docker环境整合成一个大的docker资源池；docker swarm面向的就是这个大的docker 资源池在上面管理容器；在前面我们都只是在单台主机上的创建，管理容器，但是在生产环境中通常一台物理机上的容器实在是不能够满足当前业务的需求，所以docker swarm提供了一种集群解决方案，方便在多个节点上创建，管理容器；接下来我们来看看docker swarm集群的搭建过程吧；&lt;/p&gt;
&lt;p&gt;　　docker swarm 在我们安装好docker时就已经安装好了，我们可以使用docker info来查看&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node1 ~]# docker info
Client:
 Debug Mode: false

Server:
 Containers: 0
  Running: 0
  Paused: 0
  Stopped: 0
 Images: 0
 Server Version: 19.03.11
 Storage Driver: overlay2
  Backing Filesystem: xfs
  Supports d_type: true
  Native Overlay Diff: true
 Logging Driver: json-file
 Cgroup Driver: cgroupfs
 Plugins:
  Volume: local
  Network: bridge host ipvlan macvlan null overlay
  Log: awslogs fluentd gcplogs gelf journald json-file local logentries splunk syslog
 Swarm: inactive
 Runtimes: runc
 Default Runtime: runc
 Init Binary: docker-init
 containerd version: 7ad184331fa3e55e52b890ea95e65ba581ae3429
 runc version: dc9208a3303feef5b3839f4323d9beb36df0a9dd
 init version: fec3683
 Security Options:
  seccomp
   Profile: default
 Kernel Version: 3.10.0-693.el7.x86_64
 Operating System: CentOS Linux 7 (Core)
 OSType: linux
 Architecture: x86_64
 CPUs: 4
 Total Memory: 3.686GiB
 Name: docker-node01
 ID: 4HXP:YJ5W:4SM5:NAPM:NXPZ:QFIU:ARVJ:BYDG:KVWU:5AAJ:77GC:X7GQ
 Docker Root Dir: /var/lib/docker
 Debug Mode: false
 Registry: https://index.docker.io/v1/
 Labels:
  provider=generic
 Experimental: false
 Insecure Registries:
  127.0.0.0/8
 Live Restore Enabled: false

[root@node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：从上面的信息可以看到，swarm是处于非活跃状态，这是因为我们还没有初始化集群，所以对应的swarm选项的值是处于inactive状态；&lt;/p&gt;
&lt;p&gt;　　初始化集群&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@docker-node01 ~]# docker swarm init --advertise-addr 192.168.0.41
Swarm initialized: current node (ynz304mbltxx10v3i15ldkmj1) is now a manager.

To add a worker to this swarm, run the following command:

    docker swarm join --token SWMTKN-1-6difxlq3wc8emlwxzuw95gp8rmvbz2oq62kux3as0e4rbyqhk3-2m9x12n102ca4qlyjpseobzik 192.168.0.41:2377

To add a manager to this swarm, run 'docker swarm join-token manager' and follow the instructions.

[root@docker-node01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：从上面反馈的信息可以看到，集群初始化成功，并且告诉我们当前节点为管理节点，如果想要其他节点加入到该集群，可以在对应节点上运行docker swarm join --token SWMTKN-1-6difxlq3wc8emlwxzuw95gp8rmvbz2oq62kux3as0e4rbyqhk3-2m9x12n102ca4qlyjpseobzik 192.168.0.41:2377 这个命令，就把对应节点当作work节点加入到该集群，如果想要以管理节点身份加入到集群，我们需要在当前终端运行docker swarm join-token manager命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@docker-node01 ~]# docker swarm join-token manager
To add a manager to this swarm, run the following command:

    docker swarm join --token SWMTKN-1-6difxlq3wc8emlwxzuw95gp8rmvbz2oq62kux3as0e4rbyqhk3-dqjeh8hp6cp99bksjc03b8yu3 192.168.0.41:2377

[root@docker-node01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：我们执行docker swarm join-token manager命令，它返回了一个命令，并告诉我们添加一个管理节点，在对应节点上执行docker swarm join --token SWMTKN-1-6difxlq3wc8emlwxzuw95gp8rmvbz2oq62kux3as0e4rbyqhk3-dqjeh8hp6cp99bksjc03b8yu3 192.168.0.41:2377命令即可；&lt;/p&gt;
&lt;p&gt;　　到此docker swarm集群就初始化完毕，接下来我们把其他节点加入到该集群&lt;/p&gt;
&lt;p&gt;　　把docker-node02以work节点身份加入集群&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node2 ~]# docker swarm join --token SWMTKN-1-6difxlq3wc8emlwxzuw95gp8rmvbz2oq62kux3as0e4rbyqhk3-2m9x12n102ca4qlyjpseobzik 192.168.0.41:2377
This node joined a swarm as a worker.
[root@node2 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：没有报错就表示加入集群成功；我们可以使用docker info来查看当前的docker 环境详细信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202006/1503305-20200620141025012-536064838.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：从上面的信息可以看到，在docker-node02这台主机上docker swarm 已经激活，并且可以看到管理节点的地址；除了以上方式可以确定docker-node02以及加入到集群；我们还可以在管理节点上运行docker node ls 查看集群节点信息；&lt;/p&gt;
&lt;p&gt;　　查看集群节点信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202006/1503305-20200620141322798-301580081.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：在管理节点上运行docker node ls 就可以列出当前集群里有多少节点已经成功加入进来；&lt;/p&gt;
&lt;p&gt;　　把docker-node03以管理节点身份加入到集群&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202006/1503305-20200620141538042-391863570.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可以看到docker-node03已经是集群的管理节点，所以可以在docker-node03这个节点执行docker node ls 命令；到此docker swarm集群就搭建好了；接下来我们来说一说docker swarm集群的常用管理&lt;/p&gt;
&lt;p&gt;　　有关节点相关管理命令&lt;/p&gt;
&lt;p&gt;　　docker node ls ：列出当前集群上的所有节点&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@docker-node01 ~]# docker node ls
ID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSION
ynz304mbltxx10v3i15ldkmj1 *   docker-node01       Ready               Active              Leader              19.03.11
tzkm0ymzjdmc1r8d54snievf1     docker-node02       Ready               Active                                  19.03.11
aeo8j7zit9qkoeeft3j0q1h0z     docker-node03       Ready               Active              Reachable           19.03.11
[root@docker-node01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：该命令只能在管理节点上执行；&lt;/p&gt;
&lt;p&gt;　　docker node inspect ：查看指定节点的详细信息；&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;90&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@docker-node01 ~]# docker node inspect docker-node01
[
    {
        &quot;ID&quot;: &quot;ynz304mbltxx10v3i15ldkmj1&quot;,
        &quot;Version&quot;: {
            &quot;Index&quot;: 9
        },
        &quot;CreatedAt&quot;: &quot;2020-06-20T05:57:17.57684293Z&quot;,
        &quot;UpdatedAt&quot;: &quot;2020-06-20T05:57:18.18575648Z&quot;,
        &quot;Spec&quot;: {
            &quot;Labels&quot;: {},
            &quot;Role&quot;: &quot;manager&quot;,
            &quot;Availability&quot;: &quot;active&quot;
        },
        &quot;Description&quot;: {
            &quot;Hostname&quot;: &quot;docker-node01&quot;,
            &quot;Platform&quot;: {
                &quot;Architecture&quot;: &quot;x86_64&quot;,
                &quot;OS&quot;: &quot;linux&quot;
            },
            &quot;Resources&quot;: {
                &quot;NanoCPUs&quot;: 4000000000,
                &quot;MemoryBytes&quot;: 3958075392
            },
            &quot;Engine&quot;: {
                &quot;EngineVersion&quot;: &quot;19.03.11&quot;,
                &quot;Labels&quot;: {
                    &quot;provider&quot;: &quot;generic&quot;
                },
                &quot;Plugins&quot;: [
                    {
                        &quot;Type&quot;: &quot;Log&quot;,
                        &quot;Name&quot;: &quot;awslogs&quot;
                    },
                    {
                        &quot;Type&quot;: &quot;Log&quot;,
                        &quot;Name&quot;: &quot;fluentd&quot;
                    },
                    {
                        &quot;Type&quot;: &quot;Log&quot;,
                        &quot;Name&quot;: &quot;gcplogs&quot;
                    },
                    {
                        &quot;Type&quot;: &quot;Log&quot;,
                        &quot;Name&quot;: &quot;gelf&quot;
                    },
                    {
                        &quot;Type&quot;: &quot;Log&quot;,
                        &quot;Name&quot;: &quot;journald&quot;
                    },
                    {
                        &quot;Type&quot;: &quot;Log&quot;,
                        &quot;Name&quot;: &quot;json-file&quot;
                    },
                    {
                        &quot;Type&quot;: &quot;Log&quot;,
                        &quot;Name&quot;: &quot;local&quot;
                    },
                    {
                        &quot;Type&quot;: &quot;Log&quot;,
                        &quot;Name&quot;: &quot;logentries&quot;
                    },
                    {
                        &quot;Type&quot;: &quot;Log&quot;,
                        &quot;Name&quot;: &quot;splunk&quot;
                    },
                    {
                        &quot;Type&quot;: &quot;Log&quot;,
                        &quot;Name&quot;: &quot;syslog&quot;
                    },
                    {
                        &quot;Type&quot;: &quot;Network&quot;,
                        &quot;Name&quot;: &quot;bridge&quot;
                    },
                    {
                        &quot;Type&quot;: &quot;Network&quot;,
                        &quot;Name&quot;: &quot;host&quot;
                    },
                    {
                        &quot;Type&quot;: &quot;Network&quot;,
                        &quot;Name&quot;: &quot;ipvlan&quot;
                    },
                    {
                        &quot;Type&quot;: &quot;Network&quot;,
                        &quot;Name&quot;: &quot;macvlan&quot;
                    },
                    {
                        &quot;Type&quot;: &quot;Network&quot;,
                        &quot;Name&quot;: &quot;null&quot;
                    },
                    {
                        &quot;Type&quot;: &quot;Network&quot;,
                        &quot;Name&quot;: &quot;overlay&quot;
                    },
                    {
                        &quot;Type&quot;: &quot;Volume&quot;,
                        &quot;Name&quot;: &quot;local&quot;
                    }
                ]
            },
            &quot;TLSInfo&quot;: {
                &quot;TrustRoot&quot;: &quot;-----BEGIN CERTIFICATE-----\nMIIBaTCCARCgAwIBAgIUeBd/eSZ7WaiyLby9o1yWpjps3gwwCgYIKoZIzj0EAwIw\nEzERMA8GA1UEAxMIc3dhcm0tY2EwHhcNMjAwNjIwMDU1MjAwWhcNNDAwNjE1MDU1\nMjAwWjATMREwDwYDVQQDEwhzd2FybS1jYTBZMBMGByqGSM49AgEGCCqGSM49AwEH\nA0IABMsYxnGoPbM4gqb23E1TvOeQcLcY56XysLuF8tYKm56GuKpeD/SqXrUCYqKZ\nHV+WSqcM0fD1g+mgZwlUwFzNxhajQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMB\nAf8EBTADAQH/MB0GA1UdDgQWBBTV64kbvS83eRHyI6hdJeEIv3GmrTAKBggqhkjO\nPQQDAgNHADBEAiBBB4hLn0ijybJWH5j5rtMdAoj8l/6M3PXERnRSlhbcawIgLoby\newMHCnm8IIrUGe7s4CZ07iHG477punuPMKDgqJ0=\n-----END CERTIFICATE-----\n&quot;,
                &quot;CertIssuerSubject&quot;: &quot;MBMxETAPBgNVBAMTCHN3YXJtLWNh&quot;,
                &quot;CertIssuerPublicKey&quot;: &quot;MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEyxjGcag9sziCpvbcTVO855BwtxjnpfKwu4Xy1gqbnoa4ql4P9KpetQJiopkdX5ZKpwzR8PWD6aBnCVTAXM3GFg==&quot;
            }
        },
        &quot;Status&quot;: {
            &quot;State&quot;: &quot;ready&quot;,
            &quot;Addr&quot;: &quot;192.168.0.41&quot;
        },
        &quot;ManagerStatus&quot;: {
            &quot;Leader&quot;: true,
            &quot;Reachability&quot;: &quot;reachable&quot;,
            &quot;Addr&quot;: &quot;192.168.0.41:2377&quot;
        }
    }
]
[root@docker-node01 ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　docker node ps ：列出指定节点上运行容器的清单&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@docker-node01 ~]# docker node ps 
ID                  NAME                IMAGE               NODE                DESIRED STATE       CURRENT STATE       ERROR               PORTS
[root@docker-node01 ~]# docker node ps docker-node01
ID                  NAME                IMAGE               NODE                DESIRED STATE       CURRENT STATE       ERROR               PORTS
[root@docker-node01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：类似docker ps 命令，我上面没有运行容器，所以看不到对应信息；默认不指定节点名称表示查看当前节点上的运行容器清单；&lt;/p&gt;
&lt;p&gt;　　docker node rm ：删除指定节点&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@docker-node01 ~]# docker node ls
ID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSION
ynz304mbltxx10v3i15ldkmj1 *   docker-node01       Ready               Active              Leader              19.03.11
tzkm0ymzjdmc1r8d54snievf1     docker-node02       Ready               Active                                  19.03.11
aeo8j7zit9qkoeeft3j0q1h0z     docker-node03       Ready               Active              Reachable           19.03.11
[root@docker-node01 ~]# docker node rm docker-node03
Error response from daemon: rpc error: code = FailedPrecondition desc = node aeo8j7zit9qkoeeft3j0q1h0z is a cluster manager and is a member of the raft cluster. It must be demoted to worker before removal
[root@docker-node01 ~]# docker node rm docker-node02
Error response from daemon: rpc error: code = FailedPrecondition desc = node tzkm0ymzjdmc1r8d54snievf1 is not down and can't be removed
[root@docker-node01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：删除节点前必须满足，被删除的节点不是管理节点，其次就是要删除的节点必须是down状态；&lt;/p&gt;
&lt;p&gt;　　docker swarm leave：离开当前集群&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@docker-node03 ~]# docker ps 
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES
e7958ffa16cd        nginx               &quot;/docker-entrypoint.…&quot;   28 seconds ago      Up 26 seconds       80/tcp              n1
[root@docker-node03 ~]# docker swarm leave 
Error response from daemon: You are attempting to leave the swarm on a node that is participating as a manager. Removing this node leaves 1 managers out of 2. Without a Raft quorum your swarm will be inaccessible. The only way to restore a swarm that has lost consensus is to reinitialize it with `--force-new-cluster`. Use `--force` to suppress this message.
[root@docker-node03 ~]# docker swarm leave -f
Node left the swarm.
[root@docker-node03 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：管理节点默认是不允许离开集群的，如果强制使用-f选项离开集群，会导致在其他管理节点无法正常管理集群；&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@docker-node01 ~]# docker node ls
Error response from daemon: rpc error: code = Unknown desc = The swarm does not have a leader. It's possible that too few managers are online. Make sure more than half of the managers are online.
[root@docker-node01 ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：我们在docker-node01上现在就不能使用docker node ls 来查看集群节点列表了；解决办法重新初始化集群；&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@docker-node01 ~]# docker node ls 
Error response from daemon: rpc error: code = Unknown desc = The swarm does not have a leader. It's possible that too few managers are online. Make sure more than half of the managers are online.
[root@docker-node01 ~]# docker swarm init --advertise-addr 192.168.0.41
Error response from daemon: This node is already part of a swarm. Use &quot;docker swarm leave&quot; to leave this swarm and join another one.
[root@docker-node01 ~]# docker swarm init --force-new-cluster 
Swarm initialized: current node (ynz304mbltxx10v3i15ldkmj1) is now a manager.

To add a worker to this swarm, run the following command:

    docker swarm join --token SWMTKN-1-6difxlq3wc8emlwxzuw95gp8rmvbz2oq62kux3as0e4rbyqhk3-2m9x12n102ca4qlyjpseobzik 192.168.0.41:2377

To add a manager to this swarm, run 'docker swarm join-token manager' and follow the instructions.

[root@docker-node01 ~]# docker node ls
ID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSION
ynz304mbltxx10v3i15ldkmj1 *   docker-node01       Ready               Active              Leader              19.03.11
tzkm0ymzjdmc1r8d54snievf1     docker-node02       Unknown             Active                                  19.03.11
aeo8j7zit9qkoeeft3j0q1h0z     docker-node03       Down                Active                                  19.03.11
rm3j7cjvmoa35yy8ckuzoay46     docker-node03       Unknown             Active                                  19.03.11
[root@docker-node01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：重新初始化集群不能使用docker swarm init --advertise-addr 192.168.0.41这种方式初始化，必须使用docker swarm init --force-new-cluster，该命令表示使用从当前状态强制创建一个集群；现在我们就可以使用docker node rm 把down状态的节点从集群删除；&lt;/p&gt;
&lt;p&gt;　　删除down状态的节点&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@docker-node01 ~]# docker node ls
ID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSION
ynz304mbltxx10v3i15ldkmj1 *   docker-node01       Ready               Active              Leader              19.03.11
tzkm0ymzjdmc1r8d54snievf1     docker-node02       Ready               Active                                  19.03.11
aeo8j7zit9qkoeeft3j0q1h0z     docker-node03       Down                Active                                  19.03.11
rm3j7cjvmoa35yy8ckuzoay46     docker-node03       Down                Active                                  19.03.11
[root@docker-node01 ~]# docker node rm aeo8j7zit9qkoeeft3j0q1h0z rm3j7cjvmoa35yy8ckuzoay46
aeo8j7zit9qkoeeft3j0q1h0z
rm3j7cjvmoa35yy8ckuzoay46
[root@docker-node01 ~]# docker node ls
ID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSION
ynz304mbltxx10v3i15ldkmj1 *   docker-node01       Ready               Active              Leader              19.03.11
tzkm0ymzjdmc1r8d54snievf1     docker-node02       Ready               Active                                  19.03.11
[root@docker-node01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　docker node promote：把指定节点提升为管理节点&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@docker-node01 ~]# docker node ls
ID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSION
ynz304mbltxx10v3i15ldkmj1 *   docker-node01       Ready               Active              Leader              19.03.11
tzkm0ymzjdmc1r8d54snievf1     docker-node02       Ready               Active                                  19.03.11
[root@docker-node01 ~]# docker node promote docker-node02
Node docker-node02 promoted to a manager in the swarm.
[root@docker-node01 ~]# docker node ls
ID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSION
ynz304mbltxx10v3i15ldkmj1 *   docker-node01       Ready               Active              Leader              19.03.11
tzkm0ymzjdmc1r8d54snievf1     docker-node02       Ready               Active              Reachable           19.03.11
[root@docker-node01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　docker node demote：把指定节点降级为work节点&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@docker-node01 ~]# docker node ls
ID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSION
ynz304mbltxx10v3i15ldkmj1 *   docker-node01       Ready               Active              Leader              19.03.11
tzkm0ymzjdmc1r8d54snievf1     docker-node02       Ready               Active              Reachable           19.03.11
[root@docker-node01 ~]# docker node demote docker-node02
Manager docker-node02 demoted in the swarm.
[root@docker-node01 ~]# docker node ls
ID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSION
ynz304mbltxx10v3i15ldkmj1 *   docker-node01       Ready               Active              Leader              19.03.11
tzkm0ymzjdmc1r8d54snievf1     docker-node02       Ready               Active                                  19.03.11
[root@docker-node01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　docker node update：更新指定节点&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@docker-node01 ~]# docker node ls
ID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSION
ynz304mbltxx10v3i15ldkmj1 *   docker-node01       Ready               Active              Leader              19.03.11
tzkm0ymzjdmc1r8d54snievf1     docker-node02       Ready               Active                                  19.03.11
[root@docker-node01 ~]# docker node update docker-node01 --availability drain 
docker-node01
[root@docker-node01 ~]# docker node ls
ID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSION
ynz304mbltxx10v3i15ldkmj1 *   docker-node01       Ready               Drain               Leader              19.03.11
tzkm0ymzjdmc1r8d54snievf1     docker-node02       Ready               Active                                  19.03.11
[root@docker-node01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：以上命令把docker-node01的availability属性更改为drain，这样更改后docker-node01的资源就不会被调度到用来运行容器；&lt;/p&gt;
&lt;p&gt;　　为docker swarm集群添加图形界面&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@docker-node01 docker]# docker run --name v1 -d -p 8888:8080 -e HOST=192.168.0.41 -e PORT=8080 -v /var/run/docker.sock:/var/run/docker.sock docker-registry.io/test/visualizer
Unable to find image 'docker-registry.io/test/visualizer:latest' locally
latest: Pulling from test/visualizer
cd784148e348: Pull complete 
f6268ae5d1d7: Pull complete 
97eb9028b14b: Pull complete 
9975a7a2a3d1: Pull complete 
ba903e5e6801: Pull complete 
7f034edb1086: Pull complete 
cd5dbf77b483: Pull complete 
5e7311667ddb: Pull complete 
687c1072bfcb: Pull complete 
aa18e5d3472c: Pull complete 
a3da1957bd6b: Pull complete 
e42dbf1c67c4: Pull complete 
5a18b01011d2: Pull complete 
Digest: sha256:54d65cbcbff52ee7d789cd285fbe68f07a46e3419c8fcded437af4c616915c85
Status: Downloaded newer image for docker-registry.io/test/visualizer:latest
3c15b186ff51848130393944e09a427bd40d2504c54614f93e28477a4961f8b6
[root@docker-node01 docker]# docker ps 
CONTAINER ID        IMAGE                                COMMAND             CREATED             STATUS                            PORTS                    NAMES
3c15b186ff51        docker-registry.io/test/visualizer   &quot;npm start&quot;         6 seconds ago       Up 5 seconds (health: starting)   0.0.0.0:8888-&amp;gt;8080/tcp   v1
[root@docker-node01 docker]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：我上面的命令是从私有仓库中下载的镜像，原因是互联网下载太慢了，所以我提前下载好，放在私有仓库中；有关私有仓库的搭建使用，请参考&lt;a href=&quot;https://www.cnblogs.com/qiuhom-1874/p/13061984.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/qiuhom-1874/p/13061984.html&lt;/a&gt;或者&lt;a href=&quot;https://www.cnblogs.com/qiuhom-1874/p/13058338.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/qiuhom-1874/p/13058338.html&lt;/a&gt;；在管理节点上运行visualizer容器后，我们就可以直接访问该管理节点地址的8888端口，就可以看到当前容器的情况；如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202006/1503305-20200620151115513-855742988.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：从上面的信息可以看到当前集群有一个管理节点和两个work节点；现目前集群里没有运行任何容器；&lt;/p&gt;
&lt;p&gt;　　在docker swarm运行服务&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@docker-node01 ~]# docker service create --name myweb docker-registry.io/test/nginx:latest
i0j6wvvtfe1360ibj04jxulmd
overall progress: 1 out of 1 tasks 
1/1: running   [==================================================&amp;gt;] 
verify: Service converged 
[root@docker-node01 ~]# docker service ls
ID                  NAME                MODE                REPLICAS            IMAGE                                  PORTS
i0j6wvvtfe13        myweb               replicated          1/1                 docker-registry.io/test/nginx:latest   
[root@docker-node01 ~]# docker service ps myweb
ID                  NAME                IMAGE                                  NODE                DESIRED STATE       CURRENT STATE            ERROR               PORTS
99y8towew77e        myweb.1             docker-registry.io/test/nginx:latest   docker-node03       Running             Running 1 minutes ago                       
[root@docker-node01 ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：docker service create 表示在当前swarm集群环境中创建一个服务；以上命令表示在swarm集群上创建一个名为myweb的服务，用docker-registry.io/test/nginx:latest镜像；默认情况下只启动一个副本；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202006/1503305-20200620152729054-1950514711.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可以看到当前集群中运行了一个myweb的容器，并且运行在docker-node03这台主机上；&lt;/p&gt;
&lt;p&gt;　　在swarm 集群上创建多个副本服务&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@docker-node01 ~]# docker service create --replicas 3 --name web docker-registry.io/test/nginx:latest
mbiap412jyugfpi4a38mb5i1k
overall progress: 3 out of 3 tasks 
1/3: running   [==================================================&amp;gt;] 
2/3: running   [==================================================&amp;gt;] 
3/3: running   [==================================================&amp;gt;] 
verify: Service converged 
[root@docker-node01 ~]# docker service ls
ID                  NAME                MODE                REPLICAS            IMAGE                                  PORTS
i0j6wvvtfe13        myweb               replicated          1/1                 docker-registry.io/test/nginx:latest   
mbiap412jyug        web                 replicated          3/3                 docker-registry.io/test/nginx:latest   
[root@docker-node01 ~]#docker service ps web
ID                  NAME                IMAGE                                  NODE                DESIRED STATE       CURRENT STATE            ERROR               PORTS
1rt0e7u4senz        web.1               docker-registry.io/test/nginx:latest   docker-node02       Running             Running 28 seconds ago                       
31ll0zu7udld        web.2               docker-registry.io/test/nginx:latest   docker-node02       Running             Running 28 seconds ago                       
l9jtbswl2x22        web.3               docker-registry.io/test/nginx:latest   docker-node03       Running             Running 32 seconds ago                       
[root@docker-node01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示:--replicas选项用来指定期望运行的副本数量,该选项会在集群上创建我们指定数量的副本,即便我们集群中有节点宕机,它始终会创建我们指定数量的容器在集群上运行着;&lt;/p&gt;
&lt;p&gt;　　测试:把docker-node03关机,看看我们运行的服务是否会迁移到节点2上呢?&lt;/p&gt;
&lt;p&gt;　　docker-node03关机前&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202006/1503305-20200620154611019-1218804757.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　docker-node03关机后&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202006/1503305-20200620154720967-1502267617.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示:从上面的截图可以看到,当节点3宕机后,节点3上跑的所有容器,会全部迁移到节点2上来;这就是创建容器时用--replicas选项的作用;总结一点,创建服务使用副本模式,该服务所在节点故障,它会把对应节点上的服务迁移到其他节点上;这里需要提醒一点的是,只要集群上的服务副本满足我们指定的replicas的数量,即便故障的节点恢复了,它是不会把服务迁移回来的;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@docker-node01 ~]# docker service ps web
ID                  NAME                IMAGE                                  NODE                DESIRED STATE       CURRENT STATE             ERROR               PORTS
1rt0e7u4senz        web.1               docker-registry.io/test/nginx:latest   docker-node02       Running             Running 15 minutes ago                        
31ll0zu7udld        web.2               docker-registry.io/test/nginx:latest   docker-node02       Running             Running 15 minutes ago                        
t3gjvsgtpuql        web.3               docker-registry.io/test/nginx:latest   docker-node02       Running             Running 6 minutes ago                         
l9jtbswl2x22         \_ web.3           docker-registry.io/test/nginx:latest   docker-node03       Shutdown            Shutdown 23 seconds ago                       
[root@docker-node01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示:我们在管理节点查看服务列表,可以看到它迁移服务就是把对应节点上的副本停掉,然后在其他节点创建一个新的副本;&lt;/p&gt;
&lt;p&gt;　　服务伸缩&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@docker-node01 ~]# docker service ls
ID                  NAME                MODE                REPLICAS            IMAGE                                  PORTS
i0j6wvvtfe13        myweb               replicated          1/1                 docker-registry.io/test/nginx:latest   
mbiap412jyug        web                 replicated          3/3                 docker-registry.io/test/nginx:latest   
[root@docker-node01 ~]# docker service scale myweb=3 web=5
myweb scaled to 3
web scaled to 5
overall progress: 3 out of 3 tasks 
1/3: running   [==================================================&amp;gt;] 
2/3: running   [==================================================&amp;gt;] 
3/3: running   [==================================================&amp;gt;] 
verify: Service converged 
overall progress: 5 out of 5 tasks 
1/5: running   [==================================================&amp;gt;] 
2/5: running   [==================================================&amp;gt;] 
3/5: running   [==================================================&amp;gt;] 
4/5: running   [==================================================&amp;gt;] 
5/5: running   [==================================================&amp;gt;] 
verify: Service converged 
[root@docker-node01 ~]# docker service ls
ID                  NAME                MODE                REPLICAS            IMAGE                                  PORTS
i0j6wvvtfe13        myweb               replicated          3/3                 docker-registry.io/test/nginx:latest   
mbiap412jyug        web                 replicated          5/5                 docker-registry.io/test/nginx:latest   
[root@docker-node01 ~]# docker service ps myweb web
ID                  NAME                IMAGE                                  NODE                DESIRED STATE       CURRENT STATE            ERROR               PORTS
j7w490h2lons        myweb.1             docker-registry.io/test/nginx:latest   docker-node02       Running             Running 12 minutes ago                       
1rt0e7u4senz        web.1               docker-registry.io/test/nginx:latest   docker-node02       Running             Running 21 minutes ago                       
99y8towew77e        myweb.1             docker-registry.io/test/nginx:latest   docker-node03       Shutdown            Shutdown 5 minutes ago                       
en5rk0jf09wu        myweb.2             docker-registry.io/test/nginx:latest   docker-node03       Running             Running 31 seconds ago                       
31ll0zu7udld        web.2               docker-registry.io/test/nginx:latest   docker-node02       Running             Running 21 minutes ago                       
h1hze7h819ca        myweb.3             docker-registry.io/test/nginx:latest   docker-node03       Running             Running 30 seconds ago                       
t3gjvsgtpuql        web.3               docker-registry.io/test/nginx:latest   docker-node02       Running             Running 12 minutes ago                       
l9jtbswl2x22         \_ web.3           docker-registry.io/test/nginx:latest   docker-node03       Shutdown            Shutdown 5 minutes ago                       
od3ti2ixpsgc        web.4               docker-registry.io/test/nginx:latest   docker-node03       Running             Running 31 seconds ago                       
n1vur8wbmkgz        web.5               docker-registry.io/test/nginx:latest   docker-node03       Running             Running 31 seconds ago                       
[root@docker-node01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示:docker service scale 命令用来指定服务的副本数量,从而实现动态伸缩;&lt;/p&gt;
&lt;p&gt;　　服务暴露&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@docker-node01 ~]# docker service ls
ID                  NAME                MODE                REPLICAS            IMAGE                                  PORTS
i0j6wvvtfe13        myweb               replicated          3/3                 docker-registry.io/test/nginx:latest   
mbiap412jyug        web                 replicated          5/5                 docker-registry.io/test/nginx:latest   
[root@docker-node01 ~]# docker service update  --publish-add 80:80 myweb 
myweb
overall progress: 3 out of 3 tasks 
1/3: running   [==================================================&amp;gt;] 
2/3: running   [==================================================&amp;gt;] 
3/3: running   [==================================================&amp;gt;] 
verify: Service converged 
[root@docker-node01 ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：docker swarm集群中的服务暴露和docker里面的端口暴露原理是一样的，都是通过iptables 规则表或LVS规则实现的；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202006/1503305-20200620215133002-113825049.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：我们可以在管理节点上看到对应80端口已经处于监听状态，并且在iptables规则表中多了一项访问本机80端口都DNAT到172.18.0.2的80上了；其实不光是在管理节点，在work节点上相应的iptables规则也都发生了变化；如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202006/1503305-20200620215706208-2092881748.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：从上面的规则来看，我们访问节点地址的80端口，都会DNAT到172.18.0.2的80；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202006/1503305-20200620222030286-1702599276.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：从上面是显示结果看，我们不难得知在docker-node02运行myweb容器的内部地址是10.0.0.7，那为什么我们访问172.18.0.2是能够访问到容器内部的服务呢？原因是10.0.0.7是ingress网络，生效范围是swarm集群里的容器，类型是overlay叠加网络；简单讲ingress网络就是一个虚拟网络，真正通信的网络是靠docker_gwbridge网络，而docker_gwbridge网络是一个桥接网络，生效范围是local，所以我们访问节点地址的80，会通过iptables规则转发到docker_gwbridge网络上，docker_gwbridge会通过内核转发，把docker_gwbridge上的流量转发给ingress网络，从而实现访问到真正提供服务的容器；而在管理节点上能够访问到容器服务的原因是通过访问本机的80，通过iptables规则把流量转发给docker_gwbridge，docker_gwbridge通过内核把流量转发给ingress网络，因为ingress生效范围是整个swarm，这意味着管理节点和work节点共享一个swarm的网络空间，所以访问管理节点的80端口，实际上通过iptables规则和内核的转发，最终流量会发送到work节点上的某一台容器上，从而访问到服务；&lt;/p&gt;
&lt;p&gt;　　测试：访问管理节点的80服务看看是否能够访问到nginx提供的页面呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@docker-node02 ~]# docker ps
CONTAINER ID        IMAGE                                  COMMAND                  CREATED             STATUS              PORTS               NAMES
b829991d6966        docker-registry.io/test/nginx:latest   &quot;/docker-entrypoint.…&quot;   About an hour ago   Up About an hour    80/tcp              myweb.1.ilhkslrlnreyo6xx5j2h9isjb
8c2965fbdc27        docker-registry.io/test/nginx:latest   &quot;/docker-entrypoint.…&quot;   2 hours ago         Up 2 hours          80/tcp              web.2.pthe8da2n45i06oee4n7h4krd
b019d663e48e        docker-registry.io/test/nginx:latest   &quot;/docker-entrypoint.…&quot;   2 hours ago         Up 2 hours          80/tcp              web.3.w26gqpoyysgplm7qwhjbgisiv
a7c1afd76f1f        docker-registry.io/test/nginx:latest   &quot;/docker-entrypoint.…&quot;   2 hours ago         Up 2 hours          80/tcp              web.1.ho0d7u3wensl0kah0ioz1lpk5
[root@docker-node02 ~]# docker exec -it myweb.1.ilhkslrlnreyo6xx5j2h9isjb  bash
root@b829991d6966:/# cd /usr/share/nginx/html/
root@b829991d6966:/usr/share/nginx/html# ls
50x.html  index.html
root@b829991d6966:/usr/share/nginx/html# echo &quot;this is docker-node02 index page&quot; &amp;gt;index.html
root@b829991d6966:/usr/share/nginx/html# cat index.html
this is docker-node02 index page
root@b829991d6966:/usr/share/nginx/html# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：以上是在docker-node02节点上对运行的nginx容器的主页进行了修改，接下我们访问管理节点的80端口，看看是否能够访问得到work节点上的容器，它们会有什么效果？是轮询？还是一直访问一个容器？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202006/1503305-20200620231905281-127039159.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可以看到我们访问管理节点的80端口，会轮询的访问到work节点上的容器；用浏览器测试可能存在缓存的问题，我们可以用curl命令测试比较准确；如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@docker-node03 ~]# docker ps
CONTAINER ID        IMAGE                                  COMMAND                  CREATED             STATUS              PORTS               NAMES
f43fdb9ec7fc        docker-registry.io/test/nginx:latest   &quot;/docker-entrypoint.…&quot;   2 hours ago         Up 2 hours          80/tcp              myweb.3.pgdjutofb5thlk02aj7387oj0
4470785f3d00        docker-registry.io/test/nginx:latest   &quot;/docker-entrypoint.…&quot;   2 hours ago         Up 2 hours          80/tcp              myweb.2.uwxbe182qzq00qgfc7odcmx87
7493dcac95ba        docker-registry.io/test/nginx:latest   &quot;/docker-entrypoint.…&quot;   2 hours ago         Up 2 hours          80/tcp              web.4.rix50fhlmg6m9txw9urk66gvw
118880d300f4        docker-registry.io/test/nginx:latest   &quot;/docker-entrypoint.…&quot;   2 hours ago         Up 2 hours          80/tcp              web.5.vo7c7vjgpf92b0ryelb7eque0
[root@docker-node03 ~]# docker exec -it myweb.2.uwxbe182qzq00qgfc7odcmx87 bash
root@4470785f3d00:/# cd /usr/share/nginx/html/
root@4470785f3d00:/usr/share/nginx/html# echo &quot;this is myweb.2 index page&quot; &amp;gt; index.html 
root@4470785f3d00:/usr/share/nginx/html# cat index.html
this is myweb.2 index page
root@4470785f3d00:/usr/share/nginx/html# exit
exit
[root@docker-node03 ~]# docker exec -it myweb.3.pgdjutofb5thlk02aj7387oj0 bash
root@f43fdb9ec7fc:/# cd /usr/share/nginx/html/
root@f43fdb9ec7fc:/usr/share/nginx/html# echo &quot;this is myweb.3 index page&quot; &amp;gt;index.html 
root@f43fdb9ec7fc:/usr/share/nginx/html# cat index.html
this is myweb.3 index page
root@f43fdb9ec7fc:/usr/share/nginx/html# exit
exit
[root@docker-node03 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：为了访问方便看得出效果，我们把myweb.2和myweb.3的主页都更改了内容&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@docker-node01 ~]# for i in {1..10} ; do curl 192.168.0.41; done
this is myweb.3 index page
this is docker-node02 index page
this is myweb.2 index page
this is myweb.3 index page
this is docker-node02 index page
this is myweb.2 index page
this is myweb.3 index page
this is docker-node02 index page
this is myweb.2 index page
this is myweb.3 index page
[root@docker-node01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：通过上面的测试，我们在使用--publish-add 暴露服务时，就相当于在管理节点创建了一个load balance；&lt;/p&gt;
</description>
<pubDate>Sat, 20 Jun 2020 15:56:00 +0000</pubDate>
<dc:creator>Linux-1874</dc:creator>
<og:description>前文我聊到了docker machine的简单使用和基本原理的说明，回顾请参考https://www.cnblogs.com/qiuhom-1874/p/13160915.html；今天我们来聊一聊d</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qiuhom-1874/p/13169070.html</dc:identifier>
</item>
<item>
<title>设计模式入门 - M-Anonymous</title>
<link>http://www.cnblogs.com/M-Anonymous/p/13171022.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/M-Anonymous/p/13171022.html</guid>
<description>&lt;p&gt;最近想学设计模式，网上说 HeadFirst 设计模式书挺好的，我来此再巩固一篇。&lt;/p&gt;
&lt;p&gt;故事是这样的：小明是一个刚毕业的小伙子，他来到了一个游戏公司实习，项目经理分配了一个实习任务给小明：&lt;/p&gt;
&lt;p&gt;设计一个游戏角色，角色属性包括(攻击力，防御力，敏捷度...等等)，以及两个召唤师技能(闪现和引燃)。&lt;/p&gt;
&lt;p&gt;小明想这么简单的吗，如是他用了一天的时间写好了如下代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; GameRole {
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; atk; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 攻击力&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; def; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 防御力&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; dex; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 敏捷度&lt;/span&gt;
    
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; flash_move() {
        System.out.println(&lt;/span&gt;&quot;指定方向瞬移一段距离&quot;&lt;span&gt;);
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ignite() {
        System.out.println(&lt;/span&gt;&quot;使其处于燃烧状态 5 s&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;项目经理看到小明这么快就完成了任务，表扬了一下小明，小明心里乐开了花。然后项目经理又布置了一项任务给小明：&lt;br/&gt;再设计两个角色，他们的召唤师技能分别为(闪现，治疗),（闪现，传送)。&lt;/p&gt;
&lt;p&gt;小明心想这难不倒我，然后他仍然只花了一天的时间就写好了如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; GameRole {
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; atk; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 攻击力&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; def; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 防御力&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; dex; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 敏捷度&lt;/span&gt;
    
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; flash_move() {
        System.out.println(&lt;/span&gt;&quot;指定方向瞬移一段距离&quot;&lt;span&gt;);
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ignite() {
        System.out.println(&lt;/span&gt;&quot;使附近100码内队友恢复30%的血量&quot;&lt;span&gt;);
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; GameRole {
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; atk; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 攻击力&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; def; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 防御力&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; dex; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 敏捷度&lt;/span&gt;
    
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; flash_move() {
        System.out.println(&lt;/span&gt;&quot;指定方向瞬移一段距离&quot;&lt;span&gt;);
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ignite() {
        System.out.println(&lt;/span&gt;&quot;传送至己方非英雄单位位置处&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;小明兴高采烈的跑去给项目经理看了，项目经理看到小明过来了，心里觉得这小伙子不错麻，这么快就做完了。&lt;/p&gt;
&lt;p&gt;然后项目经理便看了他的代码，这不看不要紧，一看便指着小明骂道：你真是一个糟糕的程序员！！！然后便让小明改代码去了。&lt;/p&gt;
&lt;p&gt;小明此时还不太明白，我功能都实现了啊，没啥毛病阿，然后小明不明所以的便问了办公室的职员，职员告诉他，你代码冗余度太高了。&lt;/p&gt;
&lt;p&gt;小明一看发现果然如此，然后便花了一天的时间改成如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; GameRole {
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; atk; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 攻击力&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; def; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 防御力&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; dex; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 敏捷度&lt;br/&gt;　　&lt;br/&gt;　　// 省略 Getter and Setter method &lt;/span&gt;
    
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; flash_move() {
        System.out.println(&lt;/span&gt;&quot;指定方向瞬移一段距离&quot;&lt;span&gt;);
    }   
    &lt;/span&gt;&lt;span&gt;public abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; skill();
}&lt;br/&gt;&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Role_One &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; GameRole {
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; skill() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        System.out.println(&quot;使其处于燃烧状态 5 s&quot;&lt;span&gt;);
    }
}&lt;br/&gt;&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Role_Two &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; GameRole {
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; skill() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        System.out.println(&quot;使附近100码内队友恢复30%的血量&quot;&lt;span&gt;);
    }
}&lt;br/&gt;&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Role_Three &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; GameRole {
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; skill() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        System.out.println(&quot;传送至己方非英雄单位位置处&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这次小明觉得冗余度确实降低了，然后便给项目经理看，项目经理看后觉得确实还行，便又分配了一个任务：&lt;br/&gt;(游戏用户希望能自由选择召唤师技能就好了)，所以任务是召唤师技能任意搭配。&lt;/p&gt;
&lt;p&gt;小明心想：我写的这种代码似乎不用改耶，可以交差了，于是小明便偷懒了两天，然后便上报给项目经理了。&lt;/p&gt;
&lt;p&gt;项目经理一看，这代码没有变化啊，便问小明，你代码就这？小明回答是的，然后小明又被骂的狗血淋头。&lt;/p&gt;
&lt;p&gt;不明所以的小明又去问问办公室的职员，你仔细想想，如果有100个(闪现，引燃)，100个(闪现，治疗),100个(传送，治疗)呢？&lt;/p&gt;
&lt;p&gt;小明突然恍然大悟，那还是有好高的冗余度啊，经过三天思考后，小明想出了最终答案：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; GameRole {&lt;br/&gt;&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; atk; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 攻击力&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; def; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 防御力&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; dex; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 敏捷度&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Skills skill_One;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Skills skill_Two;&lt;br/&gt;　　&lt;span&gt;// 省略 Getter and Setter method&lt;/span&gt;&lt;/span&gt;&lt;span&gt;
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Role_Demo &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; GameRole {
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Skills {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; skill();
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Flush_Move &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Skills {
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; skill() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        System.out.println(&quot;指定方向瞬移一段距离&quot;&lt;span&gt;);
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Ignite &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Skills {
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; skill() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        System.out.println(&quot;使其处于燃烧状态 5 s&quot;&lt;span&gt;);
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Treat &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Skills {

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; skill() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        System.out.println(&quot;使附近100码内队友恢复30%的血量&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Main {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        Role_Demo role = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Role_Demo();
        role.setSkill_One(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Flush_Move());
        role.setSkill_Two(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Ignite());
        role.getSkill_One().skill();
        role.getSkill_Two().skill();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;小明写完了，这次小明怕又被骂，便去问问职员小花了，小花说写的不错吗，于是小明胆战心惊的去交差了。&lt;/p&gt;
&lt;p&gt;项目经理看到小明过来，看着小明的囧样，内心是想笑的，然后看了看代码发现这回没啥问题了，便放心的交给它最后一个任务：&lt;/p&gt;
&lt;p&gt;给每个英雄添加四个不相同的技能：&lt;/p&gt;
&lt;p&gt;小明经过几次写代码的经历后，一天便写出来了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; GameRole {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; atk; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 攻击力&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; def; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 防御力&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; dex; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 敏捷度&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Skills skill_One;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Skills skill_Two;
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 省略 Getter and Setter method&lt;/span&gt;
    
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Skill_One();
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Skill_Two();
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Skill_Three();
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Skill_Four();
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Role_Demo &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; GameRole {

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Skill_One() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
&lt;span&gt;    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Skill_Two() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub    &lt;/span&gt;
&lt;span&gt;    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Skill_Three() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub    &lt;/span&gt;
&lt;span&gt;    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Skill_Four() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub    &lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;经过这几次任务，小明感觉写的代码更漂亮，更优雅了，腰也不酸了，背也不疼了。小明上交任务后，项目经理也露出了满意的笑容！&lt;/p&gt;
&lt;p&gt;最后，小明成功通过了实习，然而项目经理给他分配了下一项任务......&lt;/p&gt;
</description>
<pubDate>Sat, 20 Jun 2020 15:51:00 +0000</pubDate>
<dc:creator>M-Anonymous</dc:creator>
<og:description>最近想学设计模式，网上说 HeadFirst 设计模式书挺好的，我来此再巩固一篇。 故事是这样的：小明是一个刚毕业的小伙子，他来到了一个游戏公司实习，项目经理分配了一个实习任务给小明： 设计一个游戏角</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/M-Anonymous/p/13171022.html</dc:identifier>
</item>
<item>
<title>打个总结:Web性能优化 - freephp</title>
<link>http://www.cnblogs.com/freephp/p/13170991.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/freephp/p/13170991.html</guid>
<description>&lt;p&gt;前段时间优化一个公司历史老项目的Web性能，却引出了一系列的问题，让我反思良多。&lt;br/&gt;我通过Chrome的Lighthouse工具可以看出一些性能参数和问题反馈，我逐一对其进行优化。&lt;br/&gt;根据资源请求的不同，大致可以分为&lt;strong&gt;前端资源&lt;/strong&gt;性能和&lt;strong&gt;后端程序&lt;/strong&gt;性能两个方面。&lt;br/&gt;先分析一下前端资源吧：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Defer offscreen images。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Chrome给出的建议是：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Consider lazy-loading offscreen and hidden images after all critical resources have finished loading to lower time to interactive. Learn more.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;意思是可以考虑延迟加载一些图片或者隐藏一些图片在所有关键资源完成加载后再考虑加载，通过延迟加载来降低交互时间。&lt;br/&gt;lazy-load的实现方法很多，开源框架推荐：&lt;a href=&quot;https://github.com/aFarkas/lazysizes&quot;&gt;lazysizes&lt;/a&gt;。&lt;br/&gt;当然也可以使用npm方式安装：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;npm install lazysizes&lt;br/&gt;使用方式很简单，先引入lazysize到需要的页面：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;script src=&quot;lazysizes.min.js&quot; async=&quot;&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后给需要被lazyload的img标签上加新的属性，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;img
    data-sizes=&quot;auto&quot;
    data-src=&quot;image2.jpg&quot;
    data-srcset=&quot;image1.jpg 300w,
    image2.jpg 600w,
    image3.jpg 900w&quot; class=&quot;lazyload&quot; /&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;特别要注意，有时候太多background方式加载的图片也会影响性能，lazysizes也可以处理这样的图片。方法如下，使用data-bg属性即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;div class=&quot;lazyload&quot; data-bg=&quot;/path/to/image.jpg&quot;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;Reduce JavaScript execution time&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;解决这个问题方法很多，第一个想到的就是压缩资源。&lt;br/&gt;比如压缩js和css文件，可以考虑使用webpack工具或者gulp来压缩大资源文件，合并一些文件资源请求。&lt;br/&gt;还可以通过预加载来提高响应速度，可以在最重要的js资源文件的引入上加入预加载，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;link rel=&quot;preload&quot; as=&quot;style&quot; href=&quot;css/style.css&quot;&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过增加preload&lt;br/&gt;最后还可以异步加载资源，异步不会阻塞主进程，代码调整也很小：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;script src=&quot;xxx&quot; async&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;除此之外JavaScript的执行时间过长还有可能是有大量逻辑运算，有很多页面把一些逻辑判断和计算都交给前端去计算，这样也不利于渲染，建议还是把复杂逻辑和计算尽可能交给后端去处理，让前端渲染更加“轻量”。&lt;br/&gt;3. Backend response&lt;br/&gt;数据接口返回有时候也很拖累响应时间，因为一些前端结构需要根据返回的数据进行组装新的页面结构。&lt;br/&gt;这里可以考虑找到性能真正的瓶颈，到底是数据库查询导致的慢，还是业务逻辑不清晰导致的冗余，或者其他原因。&lt;br/&gt;我遇到的是因为老项目的数据库操作类不是单例，会每次产生一个数据库连接句柄，且该页面复杂又多的sql查询。&lt;br/&gt;我勇敢地修改着10多年历史的代码，编写了单例模式的操作类，然后增加了必要的缓存机制。&lt;br/&gt;然而后面我遇到了问题，首先单例类在一些特殊情形下不满足之前的代码需求，导致奇特的数据库报错，而async属性导致一些js文件无法同步加载到位，而有一些依赖这些资源的php文件执行报错。&lt;br/&gt;最终在同事的帮助下，恢复了服务，我也再一次体会到了任何一种性能提升都要谨慎，特别是对一个古老的项目。&lt;br/&gt;前人不敢动的代码，可能是深渊。&lt;/p&gt;
&lt;p&gt;PS:我的公众号 成都有娃儿会同步发布该文章，也可以关注哦！&lt;/p&gt;
</description>
<pubDate>Sat, 20 Jun 2020 15:36:00 +0000</pubDate>
<dc:creator>freephp</dc:creator>
<og:description>前段时间优化一个公司历史老项目的Web性能，却引出了一系列的问题，让我反思良多。 我通过Chrome的Lighthouse工具可以看出一些性能参数和问题反馈，我逐一对其进行优化。 根据资源请求的不同，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/freephp/p/13170991.html</dc:identifier>
</item>
</channel>
</rss>