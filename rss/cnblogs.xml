<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>恕我直言你可能真的不会java第3篇：Stream的Filter与谓词逻辑 - 字母哥博客</title>
<link>http://www.cnblogs.com/zimug/p/13155678.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zimug/p/13155678.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202006/1815316-20200618082541426-1374619301.jpg&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、基础代码准备&quot;&gt;一、基础代码准备&lt;/h2&gt;
&lt;p&gt;建立一个实体类，该实体类有五个属性。下面的代码使用了lombok的注解Data、AllArgsConstructor，这样我们就不用写get、set方法和全参构造函数了。lombok会帮助我们在编译期生成这些模式化的代码。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Data
@AllArgsConstructor
public class Employee {

   private Integer id;
   private Integer age;   //年龄
   private String gender;  //性别
   private String firstName;  
   private String lastName;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;写一个测试类，这个测试类的内容也很简单，新建十个Employee 对象&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class StreamFilterPredicate {
    
    public static void main(String[] args){
        Employee e1 = new Employee(1,23,&quot;M&quot;,&quot;Rick&quot;,&quot;Beethovan&quot;);
        Employee e2 = new Employee(2,13,&quot;F&quot;,&quot;Martina&quot;,&quot;Hengis&quot;);
        Employee e3 = new Employee(3,43,&quot;M&quot;,&quot;Ricky&quot;,&quot;Martin&quot;);
        Employee e4 = new Employee(4,26,&quot;M&quot;,&quot;Jon&quot;,&quot;Lowman&quot;);
        Employee e5 = new Employee(5,19,&quot;F&quot;,&quot;Cristine&quot;,&quot;Maria&quot;);
        Employee e6 = new Employee(6,15,&quot;M&quot;,&quot;David&quot;,&quot;Feezor&quot;);
        Employee e7 = new Employee(7,68,&quot;F&quot;,&quot;Melissa&quot;,&quot;Roy&quot;);
        Employee e8 = new Employee(8,79,&quot;M&quot;,&quot;Alex&quot;,&quot;Gussin&quot;);
        Employee e9 = new Employee(9,15,&quot;F&quot;,&quot;Neetu&quot;,&quot;Singh&quot;);
        Employee e10 = new Employee(10,45,&quot;M&quot;,&quot;Naveen&quot;,&quot;Jain&quot;);


        List&amp;lt;Employee&amp;gt; employees = Arrays.asList(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10);

        List&amp;lt;Employee&amp;gt; filtered = employees.stream()
                .filter(e -&amp;gt; e.getAge() &amp;gt; 70 &amp;amp;&amp;amp; e.getGender().equals(&quot;M&quot;))
                .collect(Collectors.toList());

        System.out.println(filtered);

    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要注意的是上面的filter传入了lambda表达式(之前的章节我们已经讲过了)，表达过滤年龄大于70并且男性的Employee员工。输出如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[Employee(id=8, age=79, gender=M, firstName=Alex, lastName=Gussin)]
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;二、什么是谓词逻辑？&quot;&gt;二、什么是谓词逻辑？&lt;/h2&gt;
&lt;p&gt;下面要说我们的重点了，通过之前的章节的讲解，我们已经知道lambda表达式表达的是一个匿名接口函数的实现。那具体到Stream.filter()中，它表达的是什么呢？看下图：可以看出它表达的是一个Predicate接口，在英语中这个单词的意思是：谓词。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202006/1815316-20200618082541718-768702662.jpg&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;什么是谓词？（百度百科）&quot;&gt;&lt;strong&gt;什么是谓词？（百度百科）&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202006/1815316-20200618082541971-1421669688.jpg&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;什么是谓词逻辑？&quot;&gt;什么是谓词逻辑？&lt;/h3&gt;
&lt;p&gt;WHERE 和 AND 限定了主语employee是什么，那么WHERE和AND语句所代表的逻辑就是谓词逻辑&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SELECT *
FROM employee
WHERE age &amp;gt; 70
AND gender = 'M'
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;三、谓词逻辑的复用&quot;&gt;三、谓词逻辑的复用&lt;/h2&gt;
&lt;p&gt;通常情况下，filter函数中lambda表达式为一次性使用的谓词逻辑。如果我们的谓词逻辑需要被多处、多场景、多代码中使用，通常将它抽取出来单独定义到它所限定的主语实体中。&lt;br/&gt;比如：将下面的谓词逻辑定义在Employee实体class中。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   public static Predicate&amp;lt;Employee&amp;gt; ageGreaterThan70 = x -&amp;gt; x.getAge() &amp;gt;70;
   public static Predicate&amp;lt;Employee&amp;gt; genderM = x -&amp;gt; x.getGender().equals(&quot;M&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;31and语法（并集）&quot;&gt;3.1.and语法（并集）&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;List&amp;lt;Employee&amp;gt; filtered = employees.stream()
        .filter(Employee.ageGreaterThan70.and(Employee.genderM))
        .collect(Collectors.toList());
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[Employee(id=8, age=79, gender=M, firstName=Alex, lastName=Gussin)]
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;32or语法（交集）&quot;&gt;3.2.or语法（交集）&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;List&amp;lt;Employee&amp;gt; filtered = employees.stream()
        .filter(Employee.ageGreaterThan70.or(Employee.genderM))
        .collect(Collectors.toList());
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出如下：实际上就是年龄大于70的和所有的男性（由于79的那位也是男性，所以就是所有的男性）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[Employee(id=1, age=23, gender=M, firstName=Rick, lastName=Beethovan), Employee(id=3, age=43, gender=M, firstName=Ricky, lastName=Martin), Employee(id=4, age=26, gender=M, firstName=Jon, lastName=Lowman), Employee(id=6, age=15, gender=M, firstName=David, lastName=Feezor), Employee(id=8, age=79, gender=M, firstName=Alex, lastName=Gussin), Employee(id=10, age=45, gender=M, firstName=Naveen, lastName=Jain)]
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;33negate语法（取反）&quot;&gt;3.3.negate语法（取反）&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;List&amp;lt;Employee&amp;gt; filtered = employees.stream()
        .filter(Employee.ageGreaterThan70.or(Employee.genderM).negate())
        .collect(Collectors.toList());
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出如下：把上一小节代码的结果取反，实际上就是所有的女性&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[Employee(id=2, age=13, gender=F, firstName=Martina, lastName=Hengis), Employee(id=5, age=19, gender=F, firstName=Cristine, lastName=Maria), Employee(id=7, age=68, gender=F, firstName=Melissa, lastName=Roy), Employee(id=9, age=15, gender=F, firstName=Neetu, lastName=Singh)]
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;欢迎关注我的博客，里面有很多精品合集&quot;&gt;欢迎关注我的博客，里面有很多精品合集&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;本文转载注明出处（必须带连接，不能只转文字）：&lt;a href=&quot;http://www.zimug.com&quot;&gt;字母哥博客&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;觉得对您有帮助的话，帮我点赞、分享！您的支持是我不竭的创作动力！&lt;/strong&gt; 。另外，笔者最近一段时间输出了如下的精品内容，期待您的关注。&lt;/p&gt;
</description>
<pubDate>Thu, 18 Jun 2020 00:26:00 +0000</pubDate>
<dc:creator>字母哥博客</dc:creator>
<og:description>一、基础代码准备 建立一个实体类，该实体类有五个属性。下面的代码使用了lombok的注解Data、AllArgsConstructor，这样我们就不用写get、set方法和全参构造函数了。lombok</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zimug/p/13155678.html</dc:identifier>
</item>
<item>
<title>03.DRF-设计方法 - 平仄平仄平平仄</title>
<link>http://www.cnblogs.com/yanadoude/p/13155645.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yanadoude/p/13155645.html</guid>
<description>&lt;h2 id=&quot;1-域名&quot;&gt;1. 域名&lt;/h2&gt;
&lt;p&gt;应该尽量将API部署在专用域名之下。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-http&quot;&gt;https://api.example.com
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-http&quot;&gt;https://example.org/api/
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;2-版本（versioning）&quot;&gt;2. 版本（Versioning）&lt;/h2&gt;
&lt;p&gt;应该将API的版本号放入URL。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-http&quot;&gt;http://www.example.com/api/1.0/foo

http://www.example.com/api/1.1/foo

http://www.example.com/api/2.0/foo
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另一种做法是，将版本号放在HTTP头信息中，但不如放入URL方便和直观。&lt;a href=&quot;https://developer.github.com/v3/media/#request-specific-version&quot;&gt;Github&lt;/a&gt;采用这种做法。&lt;/p&gt;
&lt;p&gt;因为不同的版本，可以理解成同一种资源的不同表现形式，所以应该采用同一个URL。版本号可以在HTTP请求头信息的Accept字段中进行区分（参见&lt;a href=&quot;http://www.informit.com/articles/article.aspx?p=1566460&quot;&gt;Versioning REST Services&lt;/a&gt;）：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-http&quot;&gt;Accept: vnd.example-com.foo+json; version=1.0

Accept: vnd.example-com.foo+json; version=1.1

Accept: vnd.example-com.foo+json; version=2.0
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;3-路径（endpoint）&quot;&gt;3. 路径（Endpoint）&lt;/h2&gt;
&lt;p&gt;路径又称&quot;终点&quot;（endpoint），表示API的具体网址，每个网址代表一种资源（resource）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(1) 资源作为网址，只能有名词，不能有动词，而且所用的名词往往与数据库的表名对应。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;举例来说，以下是不好的例子:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-http&quot;&gt;/getProducts
/listOrders
/retreiveClientByOrder?orderId=1
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于一个简洁结构，你应该始终用名词。 此外，利用的HTTP方法可以分离网址中的资源名称的操作。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-http&quot;&gt;GET /products ：将返回所有产品清单
POST /products ：将产品新建到集合
GET /products/4 ：将获取产品 4
PATCH（或）PUT /products/4 ：将更新产品 4
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;(2) API中的名词应该使用复数。无论子资源或者所有资源。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;举例来说，获取产品的API可以这样定义&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-http&quot;&gt;获取单个产品：http://127.0.0.1:8080/AppName/rest/products/1
获取所有产品: http://127.0.0.1:8080/AppName/rest/products
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;3-http动词&quot;&gt;3. HTTP动词&lt;/h2&gt;
&lt;p&gt;对于资源的具体操作类型，由HTTP动词表示。&lt;/p&gt;
&lt;p&gt;常用的HTTP动词有下面四个（括号里是对应的SQL命令）。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;GET（SELECT）：从服务器取出资源（一项或多项）。&lt;/li&gt;
&lt;li&gt;POST（CREATE）：在服务器新建一个资源。&lt;/li&gt;
&lt;li&gt;PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。&lt;/li&gt;
&lt;li&gt;DELETE（DELETE）：从服务器删除资源。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;还有三个不常用的HTTP动词。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;PATCH（UPDATE）：在服务器更新(更新)资源（客户端提供改变的属性）。&lt;/li&gt;
&lt;li&gt;HEAD：获取资源的元数据。&lt;/li&gt;
&lt;li&gt;OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面是一些例子。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-http&quot;&gt;GET /zoos：列出所有动物园
POST /zoos：新建一个动物园（上传文件）
GET /zoos/ID：获取某个指定动物园的信息
PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）
PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）
DELETE /zoos/ID：删除某个动物园
GET /zoos/ID/animals：列出某个指定动物园的所有动物
DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;4-过滤信息（filtering）&quot;&gt;4. 过滤信息（Filtering）&lt;/h2&gt;
&lt;p&gt;如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。&lt;/p&gt;
&lt;p&gt;下面是一些常见的参数。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-http&quot;&gt;?limit=10：指定返回记录的数量
?offset=10：指定返回记录的开始位置。
?page=2&amp;amp;per_page=100：指定第几页，以及每页的记录数。
?sortby=name&amp;amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。
?animal_type_id=1：指定筛选条件
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，GET /zoos/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。&lt;/p&gt;
&lt;h2 id=&quot;6-状态码（status-codes）&quot;&gt;6. 状态码（Status Codes）&lt;/h2&gt;
&lt;p&gt;服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;200 OK - [GET]：服务器成功返回用户请求的数据&lt;/li&gt;
&lt;li&gt;201 CREATED - [POST]：用户新建数据成功。&lt;/li&gt;
&lt;li&gt;202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）&lt;/li&gt;
&lt;li&gt;204 NO CONTENT - [DELETE]：用户删除数据成功。&lt;/li&gt;
&lt;li&gt;400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作&lt;/li&gt;
&lt;li&gt;401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。&lt;/li&gt;
&lt;li&gt;403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。&lt;/li&gt;
&lt;li&gt;404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。&lt;/li&gt;
&lt;li&gt;406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。&lt;/li&gt;
&lt;li&gt;410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。&lt;/li&gt;
&lt;li&gt;422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。&lt;/li&gt;
&lt;li&gt;500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;状态码的完全列表参见&lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html&quot;&gt;这里&lt;/a&gt;或&lt;a href=&quot;https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;7-错误处理（error-handling）&quot;&gt;7. 错误处理（Error handling）&lt;/h2&gt;
&lt;p&gt;如果状态码是4xx，服务器就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;{
    error: &quot;Invalid API key&quot;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;8-返回结果&quot;&gt;8. 返回结果&lt;/h2&gt;
&lt;p&gt;针对不同操作，服务器向用户返回的结果应该符合以下规范。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;GET /collection：返回资源对象的列表（数组）&lt;/li&gt;
&lt;li&gt;GET /collection/resource：返回单个资源对象&lt;/li&gt;
&lt;li&gt;POST /collection：返回新生成的资源对象&lt;/li&gt;
&lt;li&gt;PUT /collection/resource：返回完整的资源对象&lt;/li&gt;
&lt;li&gt;PATCH /collection/resource：返回完整的资源对象&lt;/li&gt;
&lt;li&gt;DELETE /collection/resource：返回一个空文档&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;RESTful API最好做到Hypermedia（即返回结果中提供链接，连向其他API方法），使得用户不查文档，也知道下一步应该做什么。&lt;/p&gt;
&lt;p&gt;比如，Github的API就是这种设计，访问&lt;a href=&quot;https://api.github.com/&quot;&gt;api.github.com&lt;/a&gt;会得到一个所有可用API的网址列表。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;{
&quot;current_user_url&quot;: &quot;https://api.github.com/user&quot;,
&quot;authorizations_url&quot;: &quot;https://api.github.com/authorizations&quot;,
// ...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面可以看到，如果想获取当前用户的信息，应该去访问&lt;a href=&quot;https://api.github.com/user&quot;&gt;api.github.com/user&lt;/a&gt;，然后就得到了下面结果。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;{
  &quot;message&quot;: &quot;Requires authentication&quot;,
  &quot;documentation_url&quot;: &quot;https://developer.github.com/v3&quot;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码表示，服务器给出了提示信息，以及文档的网址。&lt;/p&gt;
&lt;h2 id=&quot;10-其他&quot;&gt;10. 其他&lt;/h2&gt;
&lt;p&gt;服务器返回的数据格式，应该尽量使用JSON，避免使用XML。&lt;/p&gt;
</description>
<pubDate>Thu, 18 Jun 2020 00:00:00 +0000</pubDate>
<dc:creator>平仄平仄平平仄</dc:creator>
<og:description>RESTful设计方法 1. 域名 应该尽量将API部署在专用域名之下。 https://api.example.com 如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下。 https:/</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yanadoude/p/13155645.html</dc:identifier>
</item>
<item>
<title>webpack介绍—上 - 邹琼俊</title>
<link>http://www.cnblogs.com/jiekzou/p/13153662.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jiekzou/p/13153662.html</guid>
<description>&lt;h2&gt;6.1 webpack概念的引入&lt;/h2&gt;
&lt;p&gt;　　在网页中会引用哪些常见的静态资源？&lt;/p&gt;
&lt;p&gt;　　.js、 .jsx 、.coffee、 .ts（TypeScript 类 C# 语言）&lt;/p&gt;
&lt;p&gt;　　.css、 .less、 .sass 、.scss&lt;/p&gt;
&lt;p&gt;　　.jpg 、.png、 .gif 、.bmp 、.svg&lt;/p&gt;
&lt;ul&gt;&lt;li&gt; 字体文件（Fonts）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　.svg、 .ttf、 .eot、 .woff、 .woff2&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;  模板文件&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　.ejs 、.jade、 .vue（这是在webpack中定义组件的方式，推荐这么用）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　说明：&lt;/strong&gt;SCSS 是 Sass 3 引入新的语法，其语法完全兼容 CSS3，并且继承了 Sass 的强大功能。也就是说，任何标准的 CSS3 样式表都是具有相同语义的有效的 SCSS 文件。另外，SCSS 还能识别大部分 CSS hacks（一些 CSS 小技巧）和特定于浏览器的语法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　网页中引入的静态资源多了以后有什么问题？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;网页加载速度慢， 因为 我们要发起很多的二次请求；&lt;/li&gt;
&lt;li&gt;要处理错综复杂的依赖关系；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;　　如何解决上述两个问题？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;合并、压缩、精灵图（雪碧图）、图片的Base64编码；&lt;/li&gt;
&lt;li&gt;处理依赖关系可以使用requireJS、也可以使用webpack解决各个包之间的复杂依赖关系；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;　　对应的技术方案：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用Gulp进行压缩合并， 它是基于 task 任务的；&lt;/li&gt;
&lt;li&gt;使用Webpack， 它是基于整个项目进行构建的；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;　　说明：&lt;/strong&gt;并不是所有的图片都适合采用Base64编码，通常只有一些小图片适合这样做。&lt;/p&gt;
&lt;p&gt;　　如果我们的项目比较大的情况下，使用Gulp，会创建许多的task任务，比较麻烦。所以它通常适合一些小的模块构建。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　什么是精灵图？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　css精灵(CSS sprites)是一种网页图片应用处理技术。主要是指将网页中需要的零星的小图片集成到一个大的图片中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　什么是webpack?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　webpack 是前端的一个项目构建工具，它是基于 Node.js 开发出来的一个前端工具；借助于webpack这个前端自动化构建工具，可以完美实现资源的合并、打包、压缩、混淆等诸多功能。&lt;/p&gt;
&lt;p&gt;webpack官网地址：&lt;a href=&quot;http://webpack.github.io/&quot;&gt;http://webpack.github.io/&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;6.2 webpack-最基本的使用方式&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;　　webpack&lt;/strong&gt;&lt;strong&gt;安装的两种方式&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;运行npm i webpack -g全局安装webpack，这样就能在全局使用webpack的命令。&lt;/li&gt;
&lt;li&gt;在项目根目录中运行npm i webpack --save-dev安装到项目依赖中。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　接下来，我们通过一个隔行变色的示例来演示webpack的基本使用。首先安装webpack，然后新建一个项目，目录如下图所示：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/413851/202006/413851-20200617172259674-1732675099.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　我们经常从网上下载一些第三方的安装包的时候，也经常会看到dist目录和src目录，dist目录是编译后的文件目录，src是源码目录。main.js这是项目的核心文件，全局的配置都在这个文件里面配置，index.html是首页入口文件。&lt;/p&gt;
&lt;p&gt;　　1. 安装webpack：npm i webpack-g&lt;/p&gt;
&lt;p&gt;　　查看webpack版本：&lt;/p&gt;
&lt;p&gt;　　C:\Users\zouqi&amp;gt;webpack -v&lt;/p&gt;
&lt;p&gt;　　4.30.0&lt;/p&gt;
&lt;p&gt;　　2. 安装jquery&lt;/p&gt;
&lt;p&gt;　　npm i jquery -S&lt;/p&gt;
&lt;p&gt;　　index.html代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;冯锡范---一剑无血&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;陈近南---平生不见陈近南，便称英雄也枉然&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;胡逸之---百胜刀王&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;九难师太---独臂神尼&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;./main.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　main.js代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
import $ from 'jquery'&lt;span&gt;
$(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
  $(&lt;/span&gt;'li:odd').css('backgroundColor', 'lightblue'&lt;span&gt;)
  $(&lt;/span&gt;'li:even').css('backgroundColor', 'lightgreen'&lt;span&gt;)
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;　　注意：&lt;/strong&gt; 如果要通过路径的形式，去引入 node_modules 中相关的文件，可以直接省略 路径前面的 node_modules 这一层目录，直接写包的名称，然后后面跟上具体的文件路径。&lt;/p&gt;
&lt;p&gt;　　例如：import $ from 'jquery'等价于：&lt;/p&gt;
&lt;p&gt;　　import $ from '/node_modules/jquery/dist/jquery.js'&lt;/p&gt;
&lt;p&gt;　　此时，我们在浏览器中运行index.html，我们看下效果：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/413851/202006/413851-20200617172320307-480324677.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　我们会发现隔行变色无效，并且控制台报错了。这是因为 import xx from xx 是ES6中导入模块的方式，而 ES6的代码太高级了，浏览器解析不了，所以这一行执行会报错，如果想要浏览器能够解析ES6的代码，我们可以将其通过webpack编译为浏览器可以解析的正常js语法。&lt;/p&gt;
&lt;p&gt;　　3.运行webpack打包&lt;/p&gt;
&lt;p&gt;　　webpack ./src/main.js --output-filename ./bundle.js --mode development&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　解析：&lt;/strong&gt;通过 webpack 这么一个前端构建工具， 把 main.js 做了一下处理，生成了一个 bundle.js 的文件。&lt;/p&gt;
&lt;p&gt;　　运行结果如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
PS D:\WorkSpace\vue_book\codes\chapter6\webpack-learn&amp;gt;&lt;span&gt;
webpack .&lt;/span&gt;/src/main.js --output-filename ./bundle.js --&lt;span&gt;mode development
Hash: 57bb64f9c2f92092305b
Version: webpack &lt;/span&gt;&lt;span&gt;4.30&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
Time: 381ms
Built at: &lt;/span&gt;&lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;05&lt;/span&gt;-&lt;span&gt;08&lt;/span&gt; &lt;span&gt;20&lt;/span&gt;:&lt;span&gt;30&lt;/span&gt;:&lt;span&gt;17&lt;/span&gt;&lt;span&gt;
      Asset     Size  Chunks             Chunk Names
.&lt;/span&gt;/bundle.js  &lt;span&gt;314&lt;/span&gt;&lt;span&gt; KiB    main  [emitted]  main
Entrypoint main &lt;/span&gt;= ./&lt;span&gt;bundle.js
[.&lt;/span&gt;/src/main.js] &lt;span&gt;138&lt;/span&gt;&lt;span&gt; bytes {main} [built]
    &lt;/span&gt;+ &lt;span&gt;1&lt;/span&gt; hidden module
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　命令格式： webpack  要打包的文件的路径 打包好的输出文件的路径 打包模式（webpack4新增）&lt;/p&gt;
&lt;p&gt;　　4. 修改index.html中的js引用&lt;/p&gt;
&lt;p&gt;   &amp;lt;!-- &amp;lt;script src=&quot;./main.js&quot;&amp;gt;&amp;lt;/script&amp;gt; --&amp;gt;&lt;/p&gt;
&lt;p&gt;    &amp;lt;script src=&quot;../dist/bundle.js&quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/p&gt;
&lt;p&gt;　　运行结果如下：&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/413851/202006/413851-20200617172339207-1970384298.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　我们发现，在index.html中，我们只需要引入打包后的bundle.js这个文件，如果不采用webpack打包，我们直接在index.html页面中引入文件，至少要引入两个，一个是jquery.js，一个是main.js，而且这两个文件我们可能还要单独去进行代码压缩。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　注意：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　不推荐直接在index.html里引用任何包和任何CSS文件，而应该在main.js中通过import引用。&lt;/p&gt;
&lt;p&gt;　　每次我们修改了main.js中的代码，都需要重新运行webpack命令进行打包，代码才会生效。因为我们index.html中最终引用的是bundle.js文件。&lt;/p&gt;
&lt;p&gt;　　经过上面的示例，Webpack 可以做什么事情？&lt;/p&gt;
&lt;p&gt;　　1. webpack 能够处理 JS 文件的互相依赖关系。&lt;/p&gt;
&lt;p&gt;　　2. webpack 能够处理JS的兼容问题，把高级的、浏览器不识别的语法，转为低级的，浏览器能正常识别的语法。&lt;/p&gt;
&lt;h2&gt;6.3 webpack-最基本的配置文件的使用&lt;/h2&gt;
&lt;p&gt;       在前面的示例中，我们发现每次都要运行webpack 要打包的文件的路径 打包好的输出文件的路径 打包模式，这样执行起来非常繁琐。我们可以通过配置文件来让操作变得更加简单。&lt;/p&gt;
&lt;p&gt;       如果不做任何配置，直接运行命令webpack，会出现如下错误提示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;webpack
Insufficient number of arguments or no entry found&lt;/span&gt;.&lt;span&gt;
Alternatively&lt;/span&gt;, &lt;span&gt;run&lt;/span&gt; 'webpack(-cli) --help' &lt;span&gt;for&lt;/span&gt; usage info.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       在项目根目录下创建一个webpack.config.js(默认，可修改)文件来配置webpack。这个配置文件，其实就是一个 JS 文件，通过 Node 中的模块操作，向外暴露了一个配置对象，其代码结构如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
module.exports =&lt;span&gt; {
    entry: &lt;/span&gt;'',               &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 入口文件&lt;/span&gt;&lt;span&gt;
    output: {},              &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 出口文件&lt;/span&gt;&lt;span&gt;
    module: {},              &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 处理对应模块&lt;/span&gt;&lt;span&gt;
    plugins: [],             &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对应的插件&lt;/span&gt;&lt;span&gt;
    devServer: {},           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 开发服务器配置&lt;/span&gt;&lt;span&gt;
    mode: &lt;/span&gt;'development'      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 模式配置&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　由于运行webpack命令的时候，webpack需要指定入口文件和输出文件的路径，所以，我们需要在&lt;code&gt;webpack.config.js&lt;/code&gt;中配置这两个路径。根据项目的代码结构，我们来写一下最基本的webpack配置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 导入处理路径的模块&lt;/span&gt;&lt;span&gt;
const path &lt;/span&gt;= require(&quot;path&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 导出一个配置对象&lt;/span&gt;&lt;span&gt;
module.exports &lt;/span&gt;=&lt;span&gt; {
  entry: path.join(__dirname, &lt;/span&gt;&quot;./src/main.js&quot;), &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 项目入口文件&lt;/span&gt;&lt;span&gt;
  output: { &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 配置输出选项&lt;/span&gt;&lt;span&gt;
    path: path.join(__dirname, &lt;/span&gt;&quot;./dist&quot;), &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 配置输出的路径&lt;/span&gt;&lt;span&gt;
    filename: &lt;/span&gt;&quot;bundle.js&quot; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 配置输出的文件名&lt;/span&gt;&lt;span&gt;
  },
  mode: &lt;/span&gt;&quot;development&quot; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 模式配置&lt;/span&gt;&lt;span&gt;
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后再来运行webpack，这次，我们发现运行成功了，运行结果和前面执行：webpack ./src/main.js --output-filename ./bundle.js --mode development 命令是一样的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　思考：&lt;/strong&gt; 当我们在控制台，直接输入 webpack 命令执行的时候，webpack 做了什么？&lt;/p&gt;
&lt;p&gt;　　1. 首先，webpack 发现我们并没有通过命令的形式，给它指定入口和出口。&lt;/p&gt;
&lt;p&gt;　　2. 于是webpack 就会去项目的根目录中查找一个叫做 “webpack.config.js”的配置文件。&lt;/p&gt;
&lt;p&gt;　　3. 当找到配置文件后，webpack 会去解析执行这个配置文件，当解析执行完配置文件后，就得到了配置文件中，导出的配置对象。&lt;/p&gt;
&lt;p&gt;　　4. 当 webpack 拿到配置对象后，就拿到了配置对象中，指定的入口和出口，然后进行打包构建。&lt;/p&gt;
&lt;h2&gt;6.4 webpack-dev-server的基本使用&lt;/h2&gt;
&lt;p&gt;       假设我们每次修改了main.js中的代码，我们都需要手动运行webpack打包的命令，然后去刷新浏览器才能看到最新的代码效果，这样操作起来很麻烦，我们希望有那种“热更新”的机制，当修改代码之后，会自动进行打包构建，然后马上能够在浏览器中看到最新的运行效果。&lt;/p&gt;
&lt;p&gt;　　所谓热替换,就是在&lt;strong&gt;不刷新网页的情况下&lt;/strong&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;strong&gt;改变代码后&lt;/strong&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;strong&gt;会自动编译并更新页面内容。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　我们可以使用 webpack-dev-server 这个工具，来实现自动打包编译的功能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　安装&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　运行 npm i webpack-dev-server -D 把这个工具安装到项目的本地开发依赖。&lt;/p&gt;
&lt;p&gt;　　安装完成之后，直接在控制台运行：webpack-dev-server，会报错：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
　　webpack-dev-server : 无法将“webpack-dev-&lt;span&gt;server”项识别为 cmdlet、函数、脚本
　　文件或可运行程序的名称。请检查名称的拼写，如果包括路径，请确保路径正确，然后再试一次。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这是因为我们是在项目中进行本地安装的 webpack-dev-server ， 所以无法把它当作 脚本命令，在powershell 终端中直接运行（只有那些安装到全局-g 的工具，才能在终端中正常执行）。此时我们需要借助于&lt;code&gt;package.json&lt;/code&gt;文件中的指令，来进行运行&lt;code&gt;webpack-dev-server&lt;/code&gt;命令。&lt;/p&gt;
&lt;p&gt;　　修改package.json中scripts下面的dev节点，将&quot;webpack --mode development&quot;修改为&quot;webpack-dev-server&quot;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
  &quot;scripts&quot;&lt;span&gt;: {
    &lt;/span&gt;&quot;dev&quot;: &quot;webpack-dev-server&quot;,
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;　　注意：&lt;/strong&gt; webpack-dev-server 这个工具，如果想要正常运行，要求在本地项目中，必须安装 webpack。package.json属于json文件，而&lt;strong&gt;json&lt;/strong&gt;&lt;strong&gt;文件中是不能写注释&lt;/strong&gt;的哦。&lt;/p&gt;
&lt;p&gt;　　webpack4.x将CLI抽离出为单独的包webpack-cli,需要npm install webpack-cli -D单独全局安装不然无法进行编译。&lt;/p&gt;
&lt;p&gt;　　运行命令：&lt;code&gt;npm install webpack webpack-cli webpack-dev-server --save-dev&lt;/code&gt; 进行安装。&lt;/p&gt;
&lt;p&gt;　　执行运行：npm run dev，运行结果如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;npm run dev
&lt;/span&gt;&amp;gt; webpack-learn@&lt;span&gt;1.0&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt; dev D:\WorkSpace\vue_book\codes\chapter6\webpack-&lt;span&gt;learn
&lt;/span&gt;&amp;gt; webpack-dev-&lt;span&gt;server
i ｢wds｣: Project is running at http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:8080/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　就可以http://localhost:8080访问了，此时访问webpack-dev-server启动的&lt;code&gt;http://localhost:8080/&lt;/code&gt;网站，发现是一个文件夹的面板，需要点击到src目录下，才能打开我们的index首页，由于此时引用不到bundle.js文件，所以需要修改index.html中script的src属性为/bundle.js。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;/bundle.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　webpack-dev-server 帮我们打包生成的 bundle.js 文件，并没有存放到实际的物理磁盘上；而是直接托管到了电脑的内存中，所以，我们在项目根目录中，根本找不到这个打包好的 bundle.js;。webpack-dev-server 把打包好的文件，以一种虚拟的形式，托管到了咱们项目的根目录中，虽然我们看不到它，但是可以认为， 它和 dist、src 、node_modules 平级，只是看不见，它的文件叫做 bundle.js。&lt;/p&gt;
&lt;p&gt;　　把bundle.js放在内存中的好处是：由于需要实时打包编译，所以放在内存中速度会非常快。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;postTitle2 vertical-middle&quot;&gt;　　更多内容请移步至：&lt;/span&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2 vertical-middle&quot; href=&quot;https://www.cnblogs.com/jiekzou/p/12870676.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;《Vue.js 2.x实践指南》 已出版&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 17 Jun 2020 23:51:00 +0000</pubDate>
<dc:creator>邹琼俊</dc:creator>
<og:description>6.1 webpack概念的引入 在网页中会引用哪些常见的静态资源？ JS .js、 .jsx 、.coffee、 .ts（TypeScript 类 C# 语言） CSS .css、 .less、 .</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jiekzou/p/13153662.html</dc:identifier>
</item>
<item>
<title>小师妹学JVM之:JDK14中JVM的性能优化 - flydean</title>
<link>http://www.cnblogs.com/flydean/p/jvm-performance-enhancements.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flydean/p/jvm-performance-enhancements.html</guid>
<description>&lt;p&gt;上一篇文章我们讲到了JVM为了提升解释的性能，引入了JIT编译器，今天我们再来从整体的角度，带小师妹看看JDK14中的JVM有哪些优化的方面，并且能够从中间得到那些启发。&lt;/p&gt;
&lt;p&gt;更多精彩内容且看：&lt;/p&gt;

&lt;p&gt;小师妹:F师兄，上次你给我讲的JIT真的是受益匪浅，原来JVM中还有这么多不为人知的小故事。不知道除了JIT之外，JVM还有没有其他的性能提升的姿势呢？&lt;/p&gt;
&lt;p&gt;姿势当然有很多种，先讲一下之前提到过的，在JDK9中引入的字符串压缩。&lt;/p&gt;
&lt;p&gt;在JDK9之前，String的底层存储结构是char[],一个char需要占用两个字节的存储单位。&lt;/p&gt;
&lt;p&gt;因为大部分的String都是以Latin-1字符编码来表示的，只需要一个字节存储就够了，两个字节完全是浪费。&lt;/p&gt;
&lt;p&gt;于是在JDK9之后，字符串的底层存储变成了byte[]。&lt;/p&gt;
&lt;p&gt;目前String支持两种编码格式LATIN1和UTF16。&lt;/p&gt;
&lt;p&gt;LATIN1需要用一个字节来存储。而UTF16需要使用2个字节或者4个字节来存储。&lt;/p&gt;
&lt;p&gt;在JDK9中，字符串压缩是默认开启的。你可以使用&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt; -XX:-CompactStrings
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;来控制它。&lt;/p&gt;

&lt;p&gt;为了提升JIT的编译效率，并且满足不同层次的编译需求，引入了分层编译的概念。&lt;/p&gt;
&lt;p&gt;大概来说分层编译可以分为三层：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;第一层就是禁用C1和C2编译器，这个时候没有JIT进行。&lt;/li&gt;
&lt;li&gt;第二层就是只开启C1编译器，因为C1编译器只会进行一些简单的JIT优化，所以这个可以应对常规情况。&lt;/li&gt;
&lt;li&gt;第三层就是同时开启C1和C2编译器。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在JDK7中，你可以使用下面的命令来开启分层编译：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;-XX:+TieredCompilation
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而在JDK8之后，恭喜你，分层编译已经是默认的选项了，不用再手动开启。&lt;/p&gt;

&lt;p&gt;Code Cache就是用来存储编译过的机器码的内存空间。也就说JIT编译产生的机器码，都是存放在Code Cache中的。&lt;/p&gt;
&lt;p&gt;Code Cache是以单个heap形式组织起来的连续的内存空间。&lt;/p&gt;
&lt;p&gt;如果只是用一个code heap，或多或少的就会引起性能问题。为了提升code cache的利用效率，JVM引入了Code Cache分层技术。&lt;/p&gt;
&lt;p&gt;分层技术是什么意思呢？&lt;/p&gt;
&lt;p&gt;就是把不同类型的机器码分门别类的放好，优点嘛就是方便JVM扫描查找，减少了缓存的碎片，从而提升了效率。&lt;/p&gt;
&lt;p&gt;下面是Code Cache的三种分层：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200528225431671.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_0,text_aHR0cDovL3d3dy5mbHlkZWFuLmNvbQ==,size_35,color_8F8F8F,t_70&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;之前的文章我们介绍JIT编译器，讲的是JIT编译器是用C/C++来编写的。&lt;/p&gt;
&lt;p&gt;而新版的Graal JIT编译器则是用java来编写的。对的，你没看错，使用java编写的JIT编译器。&lt;/p&gt;
&lt;p&gt;有没有一种鸡生蛋，蛋生鸡的感觉？不过，这都不重要，重要的是Graal真的可以提升JIT的编译性能。&lt;/p&gt;
&lt;p&gt;Graal是和JDK一起发行的，作为一个内部的模块：jdk.internal.vm.compiler。&lt;/p&gt;
&lt;p&gt;Graal和JVM是通过JVMCI（JVM Compiler Interface）来进行通信的。其中JVMCI也是一个内部的模块：jdk.internal.vm.ci。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意，Graal只在Linux-64版的JVM中支持，你需要使用 -XX:+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler 来开启Graal特性。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们知道在JIT中，通常为了找到热点代码，JVM是需要等待代码执行一定的时间之后，才开始进行本地代码的编译。这样做的缺点就是需要比较长的时间。&lt;/p&gt;
&lt;p&gt;同样的，如果是重复的代码，没有被编译成为机器码，那么对性能就会有影响。&lt;/p&gt;
&lt;p&gt;而AOT（Ahead-of-time）就厉害了，看名字就知道是提前编译的意思，根本就不需要等待，而是在JVM启动之前就开始编译了。&lt;/p&gt;
&lt;p&gt;AOT提供了一个java tool，名字叫做jaotc。显示jaotc的命令格式：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;jaotc &amp;lt;options&amp;gt; &amp;lt;list of classes or jar files&amp;gt;
jaotc &amp;lt;options&amp;gt; &amp;lt;--module name&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;比如，我们可以这样提前编译AOT库，以供在后面的JVM中使用：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;jaotc --output libHelloWorld.so HelloWorld.class
jaotc --output libjava.base.so --module java.base
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码提前编译了HelloWorld和它的依赖module java.base。&lt;/p&gt;
&lt;p&gt;然后我们可以在启动HelloWorld的时候，指定对应的lib：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;java -XX:AOTLibrary=./libHelloWorld.so,./libjava.base.so HelloWorld
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样在JVM启动的时候，就回去找相应的AOTLibrary。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注意，AOT是一个 Linux-x64上面的体验功能。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;对象指针用来指向一个对象，表示对该对象的引用。通常来说在64位机子上面，一个指针占用64位，也就是8个字节。而在32位机子上面，一个指针占用32位，也就是4个字节。&lt;/p&gt;
&lt;p&gt;实时上，在应用程序中，这种对象的指针是非常非常多的，从而导致如果同样一个程序，在32位机子上面运行和在64位机子上面运行占用的内存是完全不同的。64位机子内存使用可能是32位机子的1.5倍。&lt;/p&gt;
&lt;p&gt;而压缩对象指针，就是指把64位的指针压缩到32位。&lt;/p&gt;
&lt;p&gt;怎么压缩呢？64位机子的对象地址仍然是64位的。压缩过的32位存的只是相对于heap base address的位移。&lt;/p&gt;
&lt;p&gt;我们使用64位的heap base地址+ 32位的地址位移量，就得到了实际的64位heap地址。&lt;/p&gt;
&lt;p&gt;对象指针压缩在Java SE 6u23 默认开启。在此之前，可以使用-XX:+UseCompressedOops来开启。&lt;/p&gt;

&lt;p&gt;刚刚讲到了压缩过的32位地址是基于64位的heap base地址的。而在Zero-Based 压缩指针中，64位的heap base地址是重新分配的虚拟地址0。这样就可以不用存储64位的heap base地址了。&lt;/p&gt;

&lt;p&gt;最后，要讲的是逃逸分析。什么叫逃逸分析呢？简单点讲就是分析这个线程中的对象，有没有可能会被其他对象或者线程所访问，如果有的话，那么这个对象应该在Heap中分配，这样才能让对其他的对象可见。&lt;/p&gt;
&lt;p&gt;如果没有其他的对象访问，那么完全可以在stack中分配这个对象，栈上分配肯定比堆上分配要快，因为不用考虑同步的问题。&lt;/p&gt;
&lt;p&gt;我们举个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;  public static void main(String[] args) {
    example();
  }
  public static void example() {
    Foo foo = new Foo(); //alloc
    Bar bar = new Bar(); //alloc
    bar.setFoo(foo);
  }
}

class Foo {}

class Bar {
  private Foo foo;
  public void setFoo(Foo foo) {
    this.foo = foo;
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的例子中，setFoo引用了foo对象，如果bar对象是在heap中分配的话，那么引用的foo对象就逃逸了，也需要被分配在heap空间中。&lt;/p&gt;
&lt;p&gt;但是因为bar和foo对象都只是在example方法中调用的，所以，JVM可以分析出来没有其他的对象需要引用他们，那么直接在example的方法栈中分配这两个对象即可。&lt;/p&gt;
&lt;p&gt;逃逸分析还有一个作用就是lock coarsening。&lt;/p&gt;
&lt;p&gt;为了在多线程环境中保证资源的有序访问，JVM引入了锁的概念，虽然锁可以保证多线程的有序执行，但是如果实在单线程环境中呢？是不是还需要一直使用锁呢？&lt;/p&gt;
&lt;p&gt;比如下面的例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public String getNames() {
     Vector&amp;lt;String&amp;gt; v = new Vector&amp;lt;&amp;gt;();
     v.add(&quot;Me&quot;);
     v.add(&quot;You&quot;);
     v.add(&quot;Her&quot;);
     return v.toString();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Vector是一个同步对象，如果是在单线程环境中，这个同步锁是没有意义的，因此在JDK6之后，锁只在被需要的时候才会使用。&lt;/p&gt;
&lt;p&gt;这样就能提升程序的执行效率。&lt;/p&gt;
&lt;blockquote readability=&quot;8.25&quot;&gt;
&lt;p&gt;本文作者：flydean程序那些事&lt;/p&gt;
&lt;p&gt;本文链接：&lt;a href=&quot;http://www.flydean.com/jvm-performance-enhancements/&quot;&gt;http://www.flydean.com/jvm-performance-enhancements/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文来源：flydean的博客&lt;/p&gt;
&lt;p&gt;欢迎关注我的公众号:程序那些事，更多精彩等着您！&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 17 Jun 2020 22:56:00 +0000</pubDate>
<dc:creator>flydean</dc:creator>
<og:description>简介 上一篇文章我们讲到了JVM为了提升解释的性能，引入了JIT编译器，今天我们再来从整体的角度，带小师妹看看JDK14中的JVM有哪些优化的方面，并且能够从中间得到那些启发。 更多精彩内容且看： 区</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/flydean/p/jvm-performance-enhancements.html</dc:identifier>
</item>
<item>
<title>【asp.net core 系列】10  实战之ActionFilter - 月影西下</title>
<link>http://www.cnblogs.com/c7jie/p/13155592.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/c7jie/p/13155592.html</guid>
<description>&lt;p&gt;在上一篇中，我们提到了如何创建一个UnitOfWork并通过ActionFilter设置启用。这一篇我们将简单介绍一下ActionFilter以及如何利用ActionFilter，顺便补齐一下上一篇的工具类。&lt;/p&gt;

&lt;p&gt;ActionFilter全称是ActionFilterAttribute，我们根据微软的命名规范可以看出这是一个特性类，看一下它的声明：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method, AllowMultiple = true, Inherited = true)]
public abstract class ActionFilterAttribute : Attribute, IActionFilter, IFilterMetadata, IAsyncActionFilter, IAsyncResultFilter, IOrderedFilter, IResultFilter
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是一个允许标注在类和方法上的特性类，允许多个标记，标注之后子类会继承父类的特性。然后，这个类是一个抽象类，所以我们可以通过继承ActionFilterAttribute来编写自己的ActionFilter。&lt;/p&gt;
&lt;h2 id=&quot;11-actionfilter的四个方法&quot;&gt;1.1 ActionFilter的四个方法&lt;/h2&gt;
&lt;p&gt;对于一个ActionFilter而言，最重要的是它的四个方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public virtual void OnActionExecuted(ActionExecutedContext context);
public virtual void OnActionExecuting(ActionExecutingContext context);

public virtual void OnResultExecuted(ResultExecutedContext context);
public virtual void OnResultExecuting(ResultExecutingContext context);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1266612/202006/1266612-20200618054026637-2001331197.png&quot; alt=&quot;image-20200615231334442&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图是这四个方法在一次请求中执行的顺序。在一次请求真正执行之前，想要拦截这个请求，应该使用&lt;code&gt;OnActionExecuting&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;为什么单独说这个呢？因为这个方法的出镜率很高，大多数时候都会使用这个方法进行请求过滤。&lt;/p&gt;
&lt;h2 id=&quot;12--在actionfilter中我们能做什么&quot;&gt;1.2 在ActionFilter中我们能做什么&lt;/h2&gt;
&lt;p&gt;我们来简单介绍一下，四个方法中的四种上下文类型，看一看里面有哪些我们可以利用的方法：&lt;/p&gt;
&lt;h3 id=&quot;121-actionexecutingcontext&quot;&gt;1.2.1 ActionExecutingContext&lt;/h3&gt;
&lt;p&gt;这是一个Action执行前的上下文，表示Action并未开始执行，但是已经获取到了控制器实例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public class ActionExecutingContext : FilterContext
{
    public virtual IDictionary&amp;lt;string, object&amp;gt; ActionArguments { get; }
    public virtual object Controller { get; }
    public virtual IActionResult Result { get; set; }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ActionExecutingContext继承自FilterContext，我们暂且不关注它的父类，只看一下它自己的属性。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ActionArguments 表示Action的参数列表，这里面放着各种从用户接到请求参数以及其他中间处理程序添加的参数&lt;/li&gt;
&lt;li&gt;Controller 表示执行该请求的控制器，在之前我们提过，asp.net core 对于控制器的限制很小，所以控制器什么类型都可能，故而这里使用object作为控制器类型&lt;/li&gt;
&lt;li&gt;Result 执行结果，正常情况下，在此处获取这个属性的值没有意义。但是我们可以通过修改这个属性的值，来让我们拦截请求&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;122-actionexecutedcontext&quot;&gt;1.2.2 ActionExecutedContext&lt;/h3&gt;
&lt;p&gt;ActionExecutedContext 表示Action执行完成后的上下文，这时候Action已经执行完成，我们可以通过这个获取Action执行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public class ActionExecutedContext : FilterContext
{
    public virtual bool Canceled { get; set; }
    public virtual object Controller { get; }
    public virtual Exception Exception { get; set; }
    public virtual ExceptionDispatchInfo ExceptionDispatchInfo { get; set; }
    public virtual bool ExceptionHandled { get; set; }
    public virtual IActionResult Result { get; set; }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样，继承自FilterContext，暂且忽略。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Canceled 表示是否被设置短路&lt;/li&gt;
&lt;li&gt;Controller 处理请求的控制器&lt;/li&gt;
&lt;li&gt;Exception 执行过程中是否发生异常，如果有异常则 有值，否则为Null&lt;/li&gt;
&lt;li&gt;ExceptionHandled 异常是否被处理&lt;/li&gt;
&lt;li&gt;Result 此处对Result进行修改不会屏蔽执行的ActionResult，但是可以向用户隐藏对应的实现&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;123-resultexecutingcontext&quot;&gt;1.2.3 ResultExecutingContext&lt;/h3&gt;
&lt;p&gt;这是在Result渲染之前执行的上下文，这时候Action已经执行完毕，正准备渲染Result：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public class ResultExecutingContext : FilterContext
{
    public virtual bool Cancel { get; set; }
    public virtual object Controller { get; }
    public virtual IActionResult Result { get; set; }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;Cancel 取消当前结果执行以及后续筛选器的执行&lt;/li&gt;
&lt;li&gt;Controller 控制器&lt;/li&gt;
&lt;li&gt;Result 处理结果&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;124-resultexecutedcontext&quot;&gt;1.2.4 ResultExecutedContext&lt;/h3&gt;
&lt;p&gt;Result已经执行完成了，获取执行结果上下文：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public class ResultExecutedContext : FilterContext
{
    public virtual bool Canceled { get; set; }
    public virtual object Controller { get; }
    public virtual Exception Exception { get; set; }
    public virtual ExceptionDispatchInfo ExceptionDispatchInfo { get; set; }
    public virtual bool ExceptionHandled { get; set; }
    public virtual IActionResult Result { get; }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个类与 ActionExecutedContext类似，就不做介绍了。&lt;/p&gt;
&lt;h3 id=&quot;125-filtercontext&quot;&gt;1.2.5 FilterContext&lt;/h3&gt;
&lt;p&gt;在上面的四个上下文都继承自 FilterContext，那么我们来看一下FilterContext中有哪些属性或者方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public abstract class FilterContext : ActionContext
{
    public virtual IList&amp;lt;IFilterMetadata&amp;gt; Filters { get; }
    public TMetadata FindEffectivePolicy&amp;lt;TMetadata&amp;gt;() where TMetadata : IFilterMetadata;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到FilterContext继承了另一个ActionContext的类。小伙伴们应该对这个类要有一定的概念，这个类是Action的上下文类。它完整存在于一个Action的生命周期，所以有时候可以通过ActionContext进行Action级的数据传递（不推荐）。&lt;/p&gt;
&lt;p&gt;那么，继续让我们回过头来看看ActionContext里有什么：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public class ActionContext
{
    public ActionDescriptor ActionDescriptor { get; set; }
    public HttpContext HttpContext { get; set; }
    public ModelStateDictionary ModelState { get; }
    public RouteData RouteData { get; set; }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;ActionDescriptor 执行的Action描述信息，包括Action的显示名称、一些参数等，具体用到的时候，再为大伙详细说&lt;/li&gt;
&lt;li&gt;HttpContext 可以通过这个属性获取此次请求的Request和Response对象&lt;/li&gt;
&lt;li&gt;ModelState 模型校验信息， 这部分在后续再为小伙伴们细说&lt;/li&gt;
&lt;li&gt;RouteData 路由信息，asp.net core 在处理请求时解析出来的路由信息，包括在程序中修改的路由信息&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在《【asp.net core 系列】9 实战之 UnitOfWork以及自定义代码生成》也就是上一篇中，介绍到了ActionFilter与普通特性类一致，可以通过标注控制器然后启用该ActionFilter。&lt;/p&gt;
&lt;p&gt;因为大多数情况下，一个ActionFilter并不会仅仅局限于一个控制器，而是应用于多个控制器。所以这时候，我们通常会设置一个基础控制器，在这个控制器上进行标注，然后让子类继承这个控制器。通过这种方式来实现一次声明多次使用。&lt;/p&gt;
&lt;p&gt;当然，在asp.net core 中添加了另外的一种使用ActionFilter的方式，Setup.cs中&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;默认是这样的，我们可以通过设置参数来添加一个全局应用的Filter，例如说我们上一篇中创建的 UnitOfWorkFilterAttribute：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;services.AddControllersWithViews(options=&amp;gt;
{
    options.Filters.Add&amp;lt;UnitOfWorkFilterAttribute&amp;gt;();
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过这种方式可以启用一个全局ActionFilter。如果需要使用asp.net core的默认依赖注入可以使用 AddService进行配置。（依赖注入的内容在后续会讲解）。&lt;/p&gt;

&lt;p&gt;继续上一篇遗留的内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public static void CreateEntityTypeConfig(Type type)
{
    var targetNamespace = type.Namespace.Replace(&quot;Data.Models&quot;, &quot;&quot;);
    if (targetNamespace.StartsWith(&quot;.&quot;))
    {
        targetNamespace = targetNamespace.Remove(0);
    }
    var targetDir = Path.Combine(new[] { CurrentDirect, &quot;Domain.Implements&quot;, &quot;EntityConfigures&quot; }.Concat(
        targetNamespace.Split('.')).ToArray());

    if (!Directory.Exists(targetDir))
    {
        Directory.CreateDirectory(targetDir);
    }
    var baseName = type.Name.Replace(&quot;Entity&quot;, &quot;&quot;);
    if (!string.IsNullOrEmpty(targetNamespace))
    {
        targetNamespace = $&quot;.{targetNamespace}&quot;;
    }

    var file = $&quot;using {type.Namespace};&quot; +
        $&quot;\r\nusing Microsoft.EntityFrameworkCore;&quot; +
        $&quot;\r\nusing Microsoft.EntityFrameworkCore.Metadata.Builders;&quot; +
        $&quot;\r\nnamespace Domain.Implements.EntityConfigures{targetNamespace}&quot; +
        &quot;\r\n{&quot; +
        $&quot;\r\n\tpublic class {baseName}Config : IEntityTypeConfiguration&amp;lt;{type.Name}&amp;gt;&quot; +
        &quot;\r\n\t{&quot; +
        &quot;\r\n\t\tpublic void Configure(EntityTypeBuilder&amp;lt;SysUser&amp;gt; builder)&quot; +
        &quot;\r\n\t\t{&quot; +
        $&quot;\r\n\t\t\tbuilder.ToTable(\&quot;{baseName}\&quot;);&quot; +
        $&quot;\r\n\t\t\tbuilder.HasKey(p =&amp;gt; p.Id);&quot; +
        &quot;\r\n\t\t}\r\n\t}\r\n}&quot;;
    File.WriteAllText(Path.Combine(targetDir, $&quot;{baseName}Config.cs&quot;), file);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;工具类其实本质上就是一次文件写入的方法，本身没什么难度。&lt;/p&gt;
&lt;p&gt;不过，这里还有有个小问题，每次调用都会覆盖原有的文件，还有就是这里面有很多可以优化的地方，小伙伴们可以自己试试去优化一下，让代码更好看一点。&lt;/p&gt;

&lt;p&gt;到目前为止，实战系列也有了几篇，很多小伙伴问我能提供一下源码吗？当然，能呀。不过不是现在，容我留个谜底。当主要框架功能完成之后，我就会给小伙伴们发代码的。&lt;/p&gt;
&lt;p&gt;其实也是因为现在还没个完整的，开放给小伙伴们也没啥意义。当然了，跟着一块敲，也是能实现的哈。关键地方的代码都有。&lt;/p&gt;
&lt;blockquote readability=&quot;2.1052631578947&quot;&gt;
&lt;p&gt;更多内容烦请关注&lt;a href=&quot;https://www.attachie.club&quot;&gt;我的博客《高先生小屋》&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1266612/202006/1266612-20200618054027033-1887779306.png&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 17 Jun 2020 21:40:00 +0000</pubDate>
<dc:creator>月影西下</dc:creator>
<og:description>0.前言 在上一篇中，我们提到了如何创建一个UnitOfWork并通过ActionFilter设置启用。这一篇我们将简单介绍一下ActionFilter以及如何利用ActionFilter，顺便补齐一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/c7jie/p/13155592.html</dc:identifier>
</item>
<item>
<title>redis 哨兵 - black_monkey</title>
<link>http://www.cnblogs.com/monkey-code/p/13155563.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/monkey-code/p/13155563.html</guid>
<description>&lt;h2 id=&quot;哨兵作用&quot;&gt;哨兵作用&lt;/h2&gt;
&lt;p&gt;哨兵（sentinel) 是一个分布式系统，是程序高可用性的一个保障。用于监视任意多个主服务器,以及这些主服务器属下的所有从服务器，当出现故障时通过投票机制选择新的master并将所有slave连接到新的master。&lt;/p&gt;
&lt;h3 id=&quot;监控&quot;&gt;监控&lt;/h3&gt;
&lt;p&gt;不断地检查master和slave是否正常运行 master存活检测、master与slave运行情况检测。&lt;/p&gt;
&lt;h3 id=&quot;通知&quot;&gt;通知&lt;/h3&gt;
&lt;p&gt;当被监控地服务器出现问题时，向其他（哨兵间，客户端）发送通知。&lt;/p&gt;
&lt;h3 id=&quot;自动故障转移&quot;&gt;自动故障转移&lt;/h3&gt;
&lt;p&gt;断开master与slave连接，选取一个slave作为master,将其他slave连接到新的master，并告知客户端新的服务器地址。&lt;/p&gt;
&lt;h3 id=&quot;注意&quot;&gt;注意&lt;/h3&gt;
&lt;p&gt;哨兵也是一台redis服务器，只是不提供数据服务，通常哨兵配置数量为单数&lt;/p&gt;
&lt;h2 id=&quot;启动哨兵&quot;&gt;启动哨兵&lt;/h2&gt;
&lt;h3 id=&quot;配置文件&quot;&gt;配置文件&lt;/h3&gt;
&lt;p&gt;哨兵默认的配置文件 &lt;code&gt;sentinel.conf&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;一般的以 &lt;code&gt;sentinel_port.conf&lt;/code&gt; 命名 哨兵的配置文件&lt;/p&gt;
&lt;p&gt;配置信息&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-redis&quot;&gt;port  26379  (端口号)
dir  /tmp  (哨兵运行信息存储)
monitor mymaster 127.0.0.1 6379 2
# mymaster  (master 名字 随意)
# 127.0.0.1 6379  (IP + 端口号)
# 2  (哨兵个数 //2 + 1  当有 2 个哨兵认为 master 挂了 就挂了)
down-after-milliseconds mymaster 30000 (单位 毫秒 )

parallel-syncs mymaster 1 ( 新的master 一次有多少个 slave 同步，设置的越小，完成数据同步的时间越长，响应的服务器压力越小。)
failover-timeout mymaster 180000（ 3 分钟 如果没有同步完成 就判定为同步超时）
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;启动&quot;&gt;启动&lt;/h3&gt;
&lt;p&gt;配置主从结构，以 1master 2 slave为例。&lt;/p&gt;
&lt;p&gt;1 先启动 master 和 slave&lt;/p&gt;
&lt;p&gt;&lt;em&gt;主从配置 参看 主从篇博客&lt;a href=&quot;https://www.cnblogs.com/monkey-code/p/13111453.html&quot;&gt;主从&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-redis&quot;&gt;redis-server config_6379.conf
redis-server config_6380.conf
redis-server config_6381.conf
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2 启动哨兵&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-redis&quot;&gt;redis-sentinel sentinel_26379.conf
redis-sentinel sentinel_26380.conf
redis-sentinel sentinel_26381.conf
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;sentinel-命令&quot;&gt;Sentinel 命令&lt;/h2&gt;
&lt;p&gt;PING：PONG&lt;br/&gt;SENTINEL masters ：列出所有被监视的主服务器，以及这些主服务器的当前状态。&lt;br/&gt;SENTINEL slaves ：列出给定主服务器的所有从服务器，以及这些从服务器的当前状态。&lt;br/&gt;SENTINEL get-master-addr-by-name ： 返回给定名字的主服务器的 IP 地址和端口号。 如果这个主服务器正在执行故障转移操作， 或者针对这个主服务器的故障转移操作已经完成， 那么这个命令返回新的主服务器的 IP 地址和端口号。&lt;br/&gt;SENTINEL reset ： 重置所有名字和给定模式 pattern 相匹配的主服务器。 pattern 参数是一个 Glob 风格的模式。 重置操作清楚主服务器目前的所有状态， 包括正在执行中的故障转移， 并移除目前已经发现和关联的， 主服务器的所有从服务器和 Sentinel 。&lt;br/&gt;SENTINEL failover ： 当主服务器失效时， 在不询问其他 Sentinel 意见的情况下， 强制开始一次自动故障迁移 （不过发起故障转移的 Sentinel 会向其他 Sentinel 发送一个新的配置，其他 Sentinel 会根据这个配置进行相应的更新）。&lt;/p&gt;
&lt;h2 id=&quot;初始化sentinel&quot;&gt;初始化Sentinel&lt;/h2&gt;
&lt;h3 id=&quot;初始化服务器&quot;&gt;初始化服务器&lt;/h3&gt;
&lt;p&gt;从下面启动代码可以看出启动方式由函数 &lt;code&gt;checkForSentinelMode&lt;/code&gt; 来决定,是否使用 &lt;code&gt;sentinel&lt;/code&gt; 的模式进行一个启动, 添加的指令也是用的 &lt;code&gt;sentinelcmds&lt;/code&gt; 的命令表&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C&quot;&gt;int checkForSentinelMode(int argc, char **argv) {
    int j;

    if (strstr(argv[0],&quot;redis-sentinel&quot;) != NULL) return 1;
    for (j = 1; j &amp;lt; argc; j++)
        if (!strcmp(argv[j],&quot;--sentinel&quot;)) return 1;
    return 0;
}

// 检查服务器是否以 Sentinel 模式启动
server.sentinel_mode = checkForSentinelMode(argc,argv);

// 初始化服务器
initServerConfig();  // 在第二步介绍该函数

// 如果服务器以 Sentinel 模式启动，那么进行 Sentinel 功能相关的初始化
// 并为要监视的主服务器创建一些相应的数据结构
if (server.sentinel_mode) {
    initSentinelConfig();
    initSentinel();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从源码我们可以看出哨兵的启动有两种方式&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;redis-sentinel sentinel_xxx.conf
redis-server sentinel_xxx.conf --sentinel
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;无论哪种方式启动&lt;code&gt;redis&lt;/code&gt;，都会执行 &lt;code&gt;initServerConfig&lt;/code&gt; ，不同的是 &lt;code&gt;Sentinel&lt;/code&gt; 还会 执行&lt;code&gt;initSentinelConfig&lt;/code&gt;、&lt;code&gt;initSentinel&lt;/code&gt; 两个初始化函数。接下来看看这两个函数都干了什么～ 。&lt;/p&gt;
&lt;h3 id=&quot;替换-sentinel-的专用代码&quot;&gt;替换 Sentinel 的专用代码&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;initSentinelConfig()&lt;/code&gt; 这个函数会用 &lt;code&gt;Sentinel&lt;/code&gt; 配置的属性覆盖服务器默认的属性。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;void initSentinelConfig(void) {
    server.port = REDIS_SENTINEL_PORT;//26379
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;initSentinel()&lt;/code&gt; 会进行一个命令表的加载。一个主要的查询命令 &lt;code&gt;INFO&lt;/code&gt; 也不同于普通服务器,而是使用一个特殊的版本。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;// 初始化服务器 Sentinel 服务器
void initSentinel(void) {
    int j;

    // 删除 普通 Redis 服务器的命令表（该表用于普通模式）
    dictEmpty(server.commands,NULL);

    //  添加 sentinel 模式专用的命令。
    for (j = 0; j &amp;lt; sizeof(sentinelcmds)/sizeof(sentinelcmds[0]); j++) {
        int retval;
        struct redisCommand *cmd = sentinelcmds+j;

        retval = dictAdd(server.commands, sdsnew(cmd-&amp;gt;name), cmd);
        redisAssert(retval == DICT_OK);
    }

    /* 初始化 Sentinel 的状态 这是为了故障转移阶段选取 切换执行者 记录的状态 */
    sentinel.current_epoch = 0;

    // 保存 主服务器 信息的字典 （这里记录了监测的主服务器的信息）
    sentinel.masters = dictCreate(&amp;amp;instancesDictType,NULL);

    // 初始化 TILT 模式的相关选项
    sentinel.tilt = 0;
    sentinel.tilt_start_time = 0;
    sentinel.previous_time = mstime();

    // 初始化脚本相关选项
    sentinel.running_scripts = 0;
    sentinel.scripts_queue = listCreate();
}

// sentinel 的指令集合
struct redisCommand sentinelcmds[] = {
    {&quot;ping&quot;,pingCommand,1,&quot;&quot;,0,NULL,0,0,0,0,0},
    {&quot;sentinel&quot;,sentinelCommand,-2,&quot;&quot;,0,NULL,0,0,0,0,0},
    {&quot;subscribe&quot;,subscribeCommand,-2,&quot;&quot;,0,NULL,0,0,0,0,0},
    {&quot;unsubscribe&quot;,unsubscribeCommand,-1,&quot;&quot;,0,NULL,0,0,0,0,0},
    {&quot;psubscribe&quot;,psubscribeCommand,-2,&quot;&quot;,0,NULL,0,0,0,0,0},
    {&quot;punsubscribe&quot;,punsubscribeCommand,-1,&quot;&quot;,0,NULL,0,0,0,0,0},
    {&quot;publish&quot;,sentinelPublishCommand,3,&quot;&quot;,0,NULL,0,0,0,0,0},
    {&quot;info&quot;,sentinelInfoCommand,-1,&quot;&quot;,0,NULL,0,0,0,0,0},
    {&quot;shutdown&quot;,shutdownCommand,-1,&quot;&quot;,0,NULL,0,0,0,0,0}
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;初始化-sentinel-状态&quot;&gt;初始化 Sentinel 状态&lt;/h3&gt;
&lt;p&gt;在完成命令表加载之后,紧接着会进行 &lt;code&gt;sentinelState&lt;/code&gt; 和 &lt;code&gt;sentinelRedisInstance&lt;/code&gt; 结构的一个初始化。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Sentinel&lt;/code&gt; 状态中的 &lt;code&gt;masters&lt;/code&gt; 字典记录了所有被监视的主服务器信息,键为服务器名字,值为被监视主服务器对应的&lt;code&gt;sentinel.c/sentinelRedisInstance&lt;/code&gt;结构。每个&lt;code&gt;sentinelRedisInstance&lt;/code&gt;实例结构代表监视一个&lt;code&gt;Redis&lt;/code&gt;服务器实例，这个实例可以是主服务器，也可以是从服务器，或者另外一个sentinel服务器。&lt;/p&gt;
&lt;p&gt;对于&lt;code&gt;sentinelState&lt;/code&gt;的初始化将引发对&lt;code&gt;masters&lt;/code&gt;字典的初始化，而masters字典的初始化是根据被该入的&lt;code&gt;sentinel&lt;/code&gt;配置文件(&lt;code&gt;sentinel_26379.conf&lt;/code&gt;)来进行的。主要为被监控 &lt;code&gt;master&lt;/code&gt; 的&lt;code&gt;ip&lt;/code&gt; 和 &lt;code&gt;port&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt; 这些都是有 sentinel 来维护和使用的。&lt;/p&gt;
&lt;h4 id=&quot;sentinelstate&quot;&gt;sentinelState&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;struct sentinelState {

    // 当前纪元 用做故障转移
    uint64_t current_epoch;     /* Current epoch. */

    // 保存了所有被这个 sentinel 监视的主服务器
    // 字典的键是主服务器的名字
    // 字典的值则是一个指向 sentinelRedisInstance 结构的指针,可以是主服务器,从服务器或者其他sentinel节点
    dict *masters;      /* Dictionary of master sentinelRedisInstances.
                           Key is the instance name, value is the
                           sentinelRedisInstance structure pointer. */

    // 是否进入了 TILT 模式？
    int tilt;           /* Are we in TILT mode? */

    // 目前正在执行的脚本的数量
    int running_scripts;    /* Number of scripts in execution right now. */

    // 进入 TILT 模式的时间
    mstime_t tilt_start_time;   /* When TITL started. */

    // 最后一次执行时间处理器的时间
    mstime_t previous_time;     /* Last time we ran the time handler. */

    // 一个 FIFO 队列，包含了所有需要执行的用户脚本
    list *scripts_queue;    /* Queue of user scripts to execute. */

} sentinel;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;sentinelredisinstance&quot;&gt;sentinelRedisInstance&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;name&lt;/strong&gt;&lt;br/&gt;实例的名字&lt;br/&gt;主服务器的名字由用户在配置文件中设置&lt;br/&gt;从服务器以及 Sentinel 的名字由 Sentinel 自动设置&lt;br/&gt;格式为 ip:port ，例如 &quot;127.0.0.1:26379&quot;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;runid&lt;/strong&gt;&lt;br/&gt;实例的运行 ID&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;sentinelAddr&lt;/strong&gt;&lt;br/&gt;实例的地址&lt;/p&gt;
&lt;h4 id=&quot;主服务器实例特有的属性&quot;&gt;主服务器实例特有的属性&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;sentinels&lt;/strong&gt;&lt;br/&gt;其他同样监控这个主服务器的所有 sentinel&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;slaves&lt;/strong&gt;&lt;br/&gt;如果这个实例代表的是一个主服务器&lt;br/&gt;那么这个字典保存着主服务器属下的从服务器&lt;br/&gt;字典的键是从服务器的名字，字典的值是从服务器对应的 sentinelRedisInstance 结构&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;quorum&lt;/strong&gt;&lt;br/&gt;判断这个实例为客观下线（objectively down）所需的支持投票数量&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;parallel_syncs&lt;/strong&gt;&lt;br/&gt;SENTINEL parallel-syncs 选项的值&lt;br/&gt;在执行故障转移操作时，可以同时对新的主服务器进行同步的从服务器数量&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;auth_pass&lt;/strong&gt;&lt;br/&gt;连接主服务器和从服务器所需的密码&lt;/p&gt;
&lt;p&gt;从服务器实例特有的属性&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;master_link_down_time&lt;/strong&gt;&lt;br/&gt;主从服务器连接断开的时间&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;slave_priority&lt;/strong&gt;&lt;br/&gt;从服务器优先级&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;slave_reconf_sent_time&lt;/strong&gt;&lt;br/&gt;执行故障转移操作时，从服务器发送 SLAVEOF 命令的时间&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;master&lt;/strong&gt;&lt;br/&gt;主服务器的实例（在本实例为从服务器时使用）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;slave_master_host&lt;/strong&gt;&lt;br/&gt;INFO 命令的回复中记录的主服务器 IP&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;slave_master_port&lt;/strong&gt;&lt;br/&gt;INFO 命令的回复中记录的主服务器端口号&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;slave_master_link_status&lt;/strong&gt;&lt;br/&gt;INFO 命令的回复中记录的主从服务器连接状态&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;slave_repl_offset&lt;/strong&gt;&lt;br/&gt;从服务器的复制偏移量&lt;/p&gt;
&lt;p&gt;结构中的 &lt;code&gt;sentinelAddr&lt;/code&gt; 保存着对象的 地址和端口。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;/* Address object, used to describe an ip:port pair. */
/* 地址对象，用于保存 IP 地址和端口 */
typedef struct sentinelAddr {
    char *ip;
    int port;
} sentinelAddr;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;建立连接&quot;&gt;建立连接&lt;/h2&gt;
&lt;p&gt;sentinel 会先去连接 &lt;code&gt;sentinel&lt;/code&gt; 中 &lt;code&gt;masters&lt;/code&gt; 中的每一个 &lt;code&gt;master&lt;/code&gt;，并在每一个 &lt;code&gt;master&lt;/code&gt; 和 &lt;code&gt;sentinel&lt;/code&gt;之间创建两个&lt;strong&gt;异步连接&lt;/strong&gt; 一个 &lt;code&gt;命令连接&lt;/code&gt; 一个 &lt;code&gt;订阅链接&lt;/code&gt;。此时 sentinel将成为 master 的客户端它可以向主服务器发送命令，并从命令回复中获取相关信息。&lt;/p&gt;
&lt;h3 id=&quot;命令连接&quot;&gt;命令连接&lt;/h3&gt;
&lt;p&gt;专门用于向主服务器发送命令，并接收命令回复。比如sentinel向主服务器发送&lt;code&gt;INFO&lt;/code&gt;命令。&lt;/p&gt;
&lt;h3 id=&quot;订阅连接&quot;&gt;订阅连接&lt;/h3&gt;
&lt;p&gt;专门用于订阅主服务器的 &lt;code&gt;_sentinel_:hello&lt;/code&gt;频道。 比如 &lt;code&gt;sentinel&lt;/code&gt;向主，从，其它&lt;code&gt;sentinel&lt;/code&gt;发送&lt;code&gt;sentinel&lt;/code&gt;本身和主库信息。&lt;/p&gt;
&lt;p&gt;redis在发布与订阅功能中，被发送的信息都不会保存在redis服务器中，若消息到来时，需要接收的客户端不在线或者断线，那么这个客户端就会丢失这条信息。为了不丢失&lt;code&gt;_sentinel_:hello&lt;/code&gt;频道的任何信息，&lt;code&gt;sentinel&lt;/code&gt;必须专门的用一个订阅连接来接收该频道的信息。&lt;/p&gt;
&lt;h3 id=&quot;获取主服务器信息&quot;&gt;获取主服务器信息&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Sentinel&lt;/code&gt; 默认会以每&lt;code&gt;10&lt;/code&gt;秒一次的频率向主服务器发送&lt;code&gt;INFO&lt;/code&gt;命令，通过分析命令回复来获取主服务器的当前信息。Sentinel可以获取以下两方面的信息：&lt;/p&gt;
&lt;p&gt;1主服务器本身的信息，包括服务器run_id，role的服务器角色。&lt;/p&gt;
&lt;p&gt;2 主服务器对应的&lt;code&gt;所有从服务器&lt;/code&gt;的信息(从服务器IP和端口)。&lt;/p&gt;
&lt;h3 id=&quot;获取从服务器信息&quot;&gt;获取从服务器信息&lt;/h3&gt;
&lt;p&gt;当&lt;code&gt;Sentinel&lt;/code&gt;发现有新的从服务器出现时，&lt;code&gt;Sentinel&lt;/code&gt;除了会为这个新的从服务器创建相应的实例结构(&lt;code&gt;sentinelRedisInstance&lt;/code&gt;)之外，还会创建到从服务器的&lt;code&gt;命令连接&lt;/code&gt;和&lt;code&gt;订阅连接&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Sentinel&lt;/code&gt;依然会像对待主服务器那样，每10s 发送一个&lt;code&gt;INFO&lt;/code&gt;命令来获取从服务器的当前信息。&lt;/p&gt;
&lt;p&gt;run_id、role、ip、port 、master_link_status（主从服务器的连接状态）、slave_priority（从服务器的优先级）等信息。&lt;/p&gt;
&lt;h3 id=&quot;向主从服务器发送信息&quot;&gt;向主从服务器发送信息&lt;/h3&gt;
&lt;p&gt;在默认情况下, &lt;code&gt;Sentinel&lt;/code&gt;会以每2秒一次的频率，通过命令连接向，所有被监视的主服务器和从服务器发送以下格式的命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-redis&quot;&gt;PUBLISH __sentinel__:hello &quot;&amp;lt;s_ip&amp;gt;,&amp;lt;s_port&amp;gt;,&amp;lt;s_runid&amp;gt;,&amp;lt;s_epoch&amp;gt;,&amp;lt;m_name&amp;gt;,&amp;lt;m_ip&amp;gt;,&amp;lt;m_port&amp;gt;,&amp;lt;m_epoch&amp;gt;&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这条命令向服务器的&lt;code&gt;_sentinel_:hello&lt;/code&gt;频道发送了一条信息，信息的内容由多个参数组成：&lt;/p&gt;
&lt;p&gt;(1) &lt;code&gt;s_&lt;/code&gt;开头的参数记录的是&lt;code&gt;sentinel&lt;/code&gt;本身的信息。&lt;/p&gt;
&lt;p&gt;(2) &lt;code&gt;m_&lt;/code&gt;开头的参数记录的则是主服务器的信息，如果sentinel正在监视的是主服务器，那么这些参数就是主服务器的信息，如果sentinel正在监视的是从服务器，那么这些参数记录就是从服务器正在复制的主服务器的信息。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr&gt;&lt;td&gt;S_ip&lt;/td&gt;
&lt;td&gt;Sentinel的ip地址&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;S_port&lt;/td&gt;
&lt;td&gt;Sentinel的端口号&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;S_runid&lt;/td&gt;
&lt;td&gt;Sentinel的运行ID&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;S_epoch&lt;/td&gt;
&lt;td&gt;Sentinel 的当前配置纪元&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;m_name&lt;/td&gt;
&lt;td&gt;主服务器的名字&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;M_ip&lt;/td&gt;
&lt;td&gt;主服务器的IP地址&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;M_port&lt;/td&gt;
&lt;td&gt;主服务器的端口号&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;M_epoch&lt;/td&gt;
&lt;td&gt;主服务器的当前配置纪元&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;例如&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&quot;127.0.0.1,26379,e955b4c77398ef6b5f055bc7ebfd5e828dbed4fc,0,mymaster,127.0.0.1,6379,0&quot;
# --------------------------------解释------------------------------------------
127.0.0.1  # sentinel ip 地址
26379  # sentinel 端口号
e955b4c77398ef6b5f055bc7ebfd5e828dbed4fc  # sentinel的运行 id
0 # sentinel 当前配置纪元
mymaster # sentinel 监控的 master name
127.0.0.1 # master ip 地址
6379 # master 端口号
0 # master 当前配置纪元
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;接收来自主从服务器的频道信息&quot;&gt;接收来自主从服务器的频道信息&lt;/h3&gt;
&lt;p&gt;当&lt;code&gt;Sentinel&lt;/code&gt;与一个主服务器或者从服务器建立起订阅连接之后,&lt;code&gt;Sentinel&lt;/code&gt;就会通过&lt;code&gt;订阅连接&lt;/code&gt;向服务器发送 &lt;code&gt;subscribe_sentinel_:hello&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;对于每个与 &lt;code&gt;Sentinel&lt;/code&gt; 连接的服务器，&lt;code&gt;Sentinel&lt;/code&gt;既通过命令连向服务器的&lt;code&gt;_sentinel_:hello&lt;/code&gt;频道发送信息，又通过订阅连接从服务器的&lt;code&gt;_sentinel_:hello&lt;/code&gt;频道接收信息。&lt;/p&gt;
&lt;p&gt;因此当有新的&lt;code&gt;Sentinel&lt;/code&gt; 连接进来时， 向订阅连接中发送的 &lt;code&gt;subscribe_sentinel_:hello&lt;/code&gt; 被已有的&lt;code&gt;Sentinel&lt;/code&gt; 接收（同时自己也会接受到来自自己的这条消息）。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;// 发送 PUBLISH 命令的间隔
#define SENTINEL_PUBLISH_PERIOD 2000

if ((now - ri-&amp;gt;last_pub_time) &amp;gt; SENTINEL_PUBLISH_PERIOD) {
        /* PUBLISH hello messages to all the three kinds of instances. */
        sentinelSendHello(ri);
    }

/* 接收来自主服务器和从服务器的频道信息
当 sentinel 与一个主服务器或者从服务器建立起订阅连接之后, sentinel 就会通过订阅连接,向服务器发送以下命令:
*/
SUBSCRIBE __sentinel__:hello

/* Now we subscribe to the Sentinels &quot;Hello&quot; channel. */
// 发送 SUBSCRIBE __sentinel__:hello 命令，订阅频道
retval = redisAsyncCommand(ri-&amp;gt;pc,
        sentinelReceiveHelloMessages, NULL, &quot;SUBSCRIBE %s&quot;,
        SENTINEL_HELLO_CHANNEL);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当一个&lt;code&gt;Sentinel&lt;/code&gt;从&lt;code&gt;_sentinel_:hello&lt;/code&gt;频道收到一条信息时，&lt;code&gt;Sentinel&lt;/code&gt;会对这条信息进行分析，提取出信息中 ip 、port、run_id 等8个参数，并进行以下检查：如果这条消息是自己发的，就直接忽略。如果是新进来的&lt;code&gt;Sentinel&lt;/code&gt; ， 此时Sentinel 会对 对应的主服务器实例结构进行更新，即将新加进来的 &lt;code&gt;Sentinel&lt;/code&gt; 添加到 &lt;code&gt;sentinels&lt;/code&gt; 字典中。&lt;/p&gt;
&lt;p&gt;每个&lt;code&gt;Sentinel&lt;/code&gt;都有自己的一个&lt;code&gt;sentinels&lt;/code&gt;字典，&lt;code&gt;Sentinels&lt;/code&gt;字典信息保存了除自己之外的所有&lt;code&gt;Sentinel&lt;/code&gt;信息。&lt;/p&gt;
&lt;h2 id=&quot;下线状态&quot;&gt;下线状态&lt;/h2&gt;
&lt;p&gt;对于Redis的Sentinel中关于下线有两个不同的概念：(1)主观下线(Subjectively Down， 简称 Sdown) 指的是单个 Sentinel 实例对服务器做出的下线判断，此时不会进行故障转移。(2) 客观下线（Objectively Down， 简称 Odown）指的是多个 Sentinel 实例在对同一个服务器做出 Sdown 判断，此时目标sentinel会对主服务器进行故障转移。本篇具体详细介绍。&lt;/p&gt;
&lt;h3 id=&quot;主观下线状态&quot;&gt;主观下线状态&lt;/h3&gt;
&lt;p&gt;默认的&lt;code&gt;Sentinel&lt;/code&gt;会以每秒一次的频率向所有与它创建命令连接的实例(包括主、从、其他sentinel在内)发送&lt;code&gt;PING&lt;/code&gt;命令，并通过实例回复来判断实例是否在线。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;合法的回复&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;+pong&lt;/code&gt; 、 &lt;code&gt;-loading&lt;/code&gt;、 &lt;code&gt;-masterdown&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;无效回复&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;除此之外的所有回复或者无回复都被视作无效回复。无回复指在指定的时间内没有回复就认为是无回复。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-redis&quot;&gt;down-after-milliseconds  # 指定的时间 未收到回复 视为无效
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用户设置down-after-milliseconds选项的值，不仅会被sentinel用来判断主服务器的主观下线状态，还会被用于判断主服务器下的所有从服务器，以及同样监视主服务器的其他sentinel的主观下线状态。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;-- 例如用户向sentinel设置以了下配置：
sentinel  monitor master 127.0.0.1 6379 2
sentinel  down-after-milliseconds master 50000
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的&lt;code&gt;master&lt;/code&gt;是主服务器的名称， 端口默认&lt;code&gt;6379&lt;/code&gt; ，&lt;code&gt;2&lt;/code&gt;代表&lt;code&gt;sentinel&lt;/code&gt;集群中有&lt;code&gt;2&lt;/code&gt;个&lt;code&gt;sentinel&lt;/code&gt;认为&lt;code&gt;master&lt;/code&gt; 状态下线时，才能真正认为该master已经不可用了(也就是&lt;code&gt;客观下线&lt;/code&gt;)。&lt;/p&gt;
&lt;p&gt;这50000毫秒不仅会成为&lt;code&gt;sentinel&lt;/code&gt;判断&lt;code&gt;master&lt;/code&gt;进入主观下线的标准，还会判断所有&lt;code&gt;从库&lt;/code&gt;、其它&lt;code&gt;sentinel&lt;/code&gt;进入主观下线的标准。&lt;/p&gt;
&lt;p&gt;当多个sentinel设置的主观下线时长可能不同&lt;/p&gt;
&lt;p&gt;对于多个&lt;code&gt;sentinel&lt;/code&gt;共同监视同一个主服务器时，这些&lt;code&gt;sentinel&lt;/code&gt;在配置文件&lt;code&gt;sentinle.conf&lt;/code&gt;中所设置的&lt;code&gt;down-after-milliseconds&lt;/code&gt;值也可能不同，因此当一个&lt;code&gt;sentinel&lt;/code&gt;将主服务器判断为主观下线时，其它&lt;code&gt;sentinel&lt;/code&gt;可能仍然会认为主服务器处于在线状态。只有全部的&lt;code&gt;sentine&lt;/code&gt;都判断进入了主观下线状态时，才会认为主&lt;code&gt;master&lt;/code&gt;进入了主观下线状态。&lt;/p&gt;
&lt;h3 id=&quot;客观下线状态&quot;&gt;客观下线状态&lt;/h3&gt;
&lt;p&gt;当&lt;code&gt;Sentinel&lt;/code&gt;将一个主服务器判断为主观下线之后，为了确认这个主服务器是否真的下线了，会向同样监视这一主服务器的其它&lt;code&gt;Sentinel&lt;/code&gt;进行询问，当有半数以上(看具体配置， 一般的是半数以上 例如&lt;code&gt;sentinel monitor mymaster 127.0.0.1 6379 2&lt;/code&gt; 中 就为当 &lt;code&gt;2&lt;/code&gt; 个判定下线时，就认为时客观下线了)&lt;/p&gt;
&lt;p&gt;当&lt;code&gt;master&lt;/code&gt;, 被确定客观下线之后&lt;code&gt;sentinel&lt;/code&gt; 们 会选出一个 &lt;strong&gt;决策者&lt;/strong&gt; 去执行故障转移操作。客观下线条件&lt;code&gt;只适用于主服务器&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;is-master-down-by-addr&lt;/code&gt;命令用来判断是否客观下线&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-redis&quot;&gt;sentinel is-master-down-by-addr  ip  port  current_epoch  run_id
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;sentinel&lt;/code&gt;当前的配置纪元 &lt;code&gt;current_epoch&lt;/code&gt; 用于选举 &lt;strong&gt;决策者&lt;/strong&gt; sentinel, &lt;code&gt;run_id&lt;/code&gt;可以是*或者sentinel的 运行id。&lt;/p&gt;
&lt;h3 id=&quot;决策者选取&quot;&gt;决策者选取&lt;/h3&gt;
&lt;p&gt;假设现在有4个&lt;code&gt;sentinel&lt;/code&gt; 这四个&lt;code&gt;sentinel&lt;/code&gt; 既是投票者，也是候选者(这四个必须时健康的)。&lt;/p&gt;
&lt;p&gt;1 不能有下面三个标记中的一个：SRI_S_DOWN|SRI_O_DOWN|SRI_DISCONNECTED&lt;/p&gt;
&lt;p&gt;2 ping 心跳正常&lt;/p&gt;
&lt;p&gt;3 优先级不能为 0（slave-&amp;gt;slave_priority）&lt;/p&gt;
&lt;p&gt;4 INFO 数据不能超时&lt;/p&gt;
&lt;p&gt;5 主从连接断线会时间不能超时&lt;/p&gt;
&lt;p&gt;投票的过程很简单，每个&lt;code&gt;sentinel&lt;/code&gt; 都将自己的&lt;code&gt;ip&lt;/code&gt;、 &lt;code&gt;port&lt;/code&gt;、&lt;code&gt;current_epoch&lt;/code&gt;、&lt;code&gt;run_id&lt;/code&gt; 由 &lt;code&gt;is-master-down&lt;/code&gt; 发送到 &lt;code&gt;hello&lt;/code&gt; 频道。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sentinel&lt;/code&gt; 第一个获取到谁的 &lt;code&gt;is-master-down&lt;/code&gt; 信息， 就将自己的票投给对应的&lt;code&gt;sentinel&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;一次过后 &lt;code&gt;current_epoch&lt;/code&gt; 最大的，且超过了半数以上。则被选为&lt;strong&gt;决策者&lt;/strong&gt; 否则再来一轮，每增加一轮 &lt;code&gt;current_epoch + 1&lt;/code&gt;， 直到选出为止。&lt;/p&gt;
&lt;h2 id=&quot;故障转移&quot;&gt;故障转移&lt;/h2&gt;
&lt;h3 id=&quot;选取候选slave&quot;&gt;选取候选Slave&lt;/h3&gt;
&lt;p&gt;1 在线的&lt;/p&gt;
&lt;p&gt;2 响应速度快的&lt;/p&gt;
&lt;p&gt;3 与原 master 断开连接最短的&lt;/p&gt;
&lt;p&gt;4 优先原则&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优先级&amp;gt;offset&amp;gt;runid&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最终选取出 新的 &lt;code&gt;master&lt;/code&gt; 之后向新的 &lt;code&gt;master&lt;/code&gt; 发送&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-redis&quot;&gt;slaveof no one  # 断开主从
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后声明新的&lt;code&gt;master&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-redis&quot;&gt;slaveof ip port  # 发送新的IP 和  新的port
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后将原来的 master 作为从机。当重新上线时，&lt;code&gt;sentinel&lt;/code&gt; 会发送 &lt;code&gt;salveof&lt;/code&gt; 命令使其成为从机。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;ul readability=&quot;13&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;sentinel&lt;/code&gt;只是一个运行在特殊模式下的&lt;code&gt;redis&lt;/code&gt;服务器，它使用了和普通模式不同的命令表，以及区别与普通模式下使用的命令不同。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;sentinel&lt;/code&gt;向主服务器发送&lt;code&gt;INFO&lt;/code&gt;命令来获得主服务器属下所有从服务器的地址信息，并为这些从服务器创建相应的实例结构，以及连向这些从服务器的命令连接和订阅连接。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;一般情况下，&lt;code&gt;sentinel&lt;/code&gt;以每10秒一次的频率向被监视的主服务器和从服务器发送&lt;code&gt;INFO&lt;/code&gt;命令，当主服务器处于下线状态，或者&lt;code&gt;sentinel&lt;/code&gt;正在对主服务器进行故障转移操作时，&lt;code&gt;sentinel&lt;/code&gt;向从服务器发送&lt;code&gt;INFO&lt;/code&gt;命令的频率会改为1秒一次。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;对于监视同一个主服务器和从服务器的多个&lt;code&gt;sentinel&lt;/code&gt;来说，它们会以每2秒一次的频率，通过向被监视的&lt;code&gt;_sentinel_:hello&lt;/code&gt;频道发送消息来向其他&lt;code&gt;sentinel&lt;/code&gt;宣告自己的存在。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;每个&lt;code&gt;sentinel&lt;/code&gt;也会从&lt;code&gt;_sentinel_:hello&lt;/code&gt;中频道中接收其他&lt;code&gt;sentinel&lt;/code&gt;发来的信息，并根据这些信息为其他&lt;code&gt;sentinel&lt;/code&gt;创建相应的实例结构，以及命令连接。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;sentinel&lt;/code&gt;只会与主服务器和从服务器创建命令连接和订阅连接，&lt;code&gt;sentinel&lt;/code&gt;与&lt;code&gt;sentinel&lt;/code&gt;之间则只创建命令连接。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;sentinel&lt;/code&gt;以每秒一次的频率向实例(包括主，从，其它&lt;code&gt;sentinel&lt;/code&gt;)发送&lt;code&gt;PING&lt;/code&gt;命令，并根据实例的回复来判断实例是否在线，当一个实例在指定的时长中连续向&lt;code&gt;sentinel&lt;/code&gt;发送无效回复时，&lt;code&gt;sentinel&lt;/code&gt;会将这个实例判断为主观下线。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;当&lt;code&gt;sentinel&lt;/code&gt;将一个主服务器判断为主观下线时，它会向同样的监视这个主服务器的其他&lt;code&gt;sentinel&lt;/code&gt;进行询问，看它们是否同意这个主服务器已经进入主观下线状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;当&lt;code&gt;sentinel&lt;/code&gt;收集到足够多的主观下线投票之后，它会将主服务器判断为客观下线，并发起一次针对主服务器的故障转移操作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Wed, 17 Jun 2020 18:20:00 +0000</pubDate>
<dc:creator>black_monkey</dc:creator>
<og:description>哨兵作用 哨兵（sentinel) 是一个分布式系统，是程序高可用性的一个保障。用于监视任意多个主服务器,以及这些主服务器属下的所有从服务器，当出现故障时通过投票机制选择新的master并将所有sla</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/monkey-code/p/13155563.html</dc:identifier>
</item>
<item>
<title>Java容器相关知识点整理 - 五岳</title>
<link>http://www.cnblogs.com/wuyuegb2312/p/13097198.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wuyuegb2312/p/13097198.html</guid>
<description>&lt;p&gt;结合一些文章阅读源码后整理的Java容器常见知识点。对于一些代码细节，本文不展开来讲，有兴趣可以自行阅读参考文献。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;106.22249539029&quot;&gt;
&lt;p&gt;结合一些文章阅读源码后整理的Java容器常见知识点。对于一些代码细节，本文不展开来讲，有兴趣可以自行阅读参考文献。&lt;/p&gt;

&lt;p&gt;各个容器的知识点比较分散，没有在思维导图上体现，因此看上去右半部分很像类的继承关系。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/228024/202006/228024-20200618013959684-1469122888.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;类名&lt;/th&gt;
&lt;th&gt;底层实现&lt;/th&gt;
&lt;th&gt;特征&lt;/th&gt;
&lt;th&gt;线程安全性&lt;/th&gt;
&lt;th&gt;默认迭代器实现(Itr)&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;16.5&quot;&gt;&lt;tr&gt;&lt;td&gt;ArrayList&lt;/td&gt;
&lt;td&gt;Object数组&lt;/td&gt;
&lt;td&gt;查询快，增删慢&lt;/td&gt;
&lt;td&gt;不安全，有modCount&lt;/td&gt;
&lt;td&gt;数组下标&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;LinkedList&lt;/td&gt;
&lt;td&gt;双向链表&lt;/td&gt;
&lt;td&gt;查询慢，增删快&lt;/td&gt;
&lt;td&gt;不安全，有modCount&lt;/td&gt;
&lt;td&gt;当前遍历的节点&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Vector&lt;/td&gt;
&lt;td&gt;Object数组&lt;/td&gt;
&lt;td&gt;查询快，增删慢&lt;/td&gt;
&lt;td&gt;方法使用synchronized确保安全（注1）；有modCount&lt;/td&gt;
&lt;td&gt;数组下标&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Stack&lt;/td&gt;
&lt;td&gt;Vector&lt;/td&gt;
&lt;td&gt;同Vector&lt;/td&gt;
&lt;td&gt;同Vector&lt;/td&gt;
&lt;td&gt;同Vector&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;HashSet&lt;/td&gt;
&lt;td&gt;HashMap (使用带特殊参数的构造方法则为LinkedHashMap)&lt;/td&gt;
&lt;td&gt;和HashMap一致&lt;/td&gt;
&lt;td&gt;和HashMap一致&lt;/td&gt;
&lt;td&gt;和HashMap一致&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;LinkedHashSet&lt;/td&gt;
&lt;td&gt;LinkedHashMap&lt;/td&gt;
&lt;td&gt;和LinkedHashMap一致&lt;/td&gt;
&lt;td&gt;和LinkedHashMap一致&lt;/td&gt;
&lt;td&gt;和LinkedHashMap一致&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;TreeSet&lt;/td&gt;
&lt;td&gt;TreeMap&lt;/td&gt;
&lt;td&gt;和TreeMap一致&lt;/td&gt;
&lt;td&gt;和TreeMap一致&lt;/td&gt;
&lt;td&gt;和TreeMap一致&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;td&gt;TreeMap&lt;/td&gt;
&lt;td&gt;红黑树和Comparator（注2）&lt;/td&gt;
&lt;td&gt;key和value可以为null（注2），key必须实现Comparable接口&lt;/td&gt;
&lt;td&gt;非线程安全，有modCount&lt;/td&gt;
&lt;td&gt;当前节点在中序遍历的后继&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;HashMap&lt;/td&gt;
&lt;td&gt;见第3节&lt;/td&gt;
&lt;td&gt;key和value可以为null&lt;/td&gt;
&lt;td&gt;非线程安全，有modCount&lt;/td&gt;
&lt;td&gt;HashIterator按数组索引遍历，在此基础上按Node遍历&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt;LinkedHashMap&lt;/td&gt;
&lt;td&gt;extends HahsMap （注3）, Node有前驱和后继&lt;/td&gt;
&lt;td&gt;可以按照插入顺序或访问顺序遍历（注4）&lt;/td&gt;
&lt;td&gt;非线程安全，有modCount&lt;/td&gt;
&lt;td&gt;同HshMap&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;ConcurrentHashMap&lt;/td&gt;
&lt;td&gt;见第3节&lt;/td&gt;
&lt;td&gt;key和value不能为null&lt;/td&gt;
&lt;td&gt;线程安全（注1）&lt;/td&gt;
&lt;td&gt;基于Traverser（注5）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;td&gt;Hashtable&lt;/td&gt;
&lt;td&gt;Entry数组 + Object.hashCode() + 同key的Entry形成链表&lt;/td&gt;
&lt;td&gt;key和value不允许为null&lt;/td&gt;
&lt;td&gt;线程安全， 有modCount&lt;/td&gt;
&lt;td&gt;枚举类或通过KeySet/EntrySet&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;操作的时间复杂度&quot;&gt;操作的时间复杂度&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;ArrayList下标查找O(1)，插入O(n)&lt;/li&gt;
&lt;li&gt;涉及到树，查找和插入都可以看做log(n)&lt;/li&gt;
&lt;li&gt;链表查找O(n)，插入O(1)&lt;/li&gt;
&lt;li&gt;Hash直接查找hash值为 O(1)&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;注1：关于容器的线程安全&quot;&gt;注1：关于容器的线程安全&lt;/h2&gt;
&lt;h3 id=&quot;复合操作&quot;&gt;复合操作&lt;/h3&gt;
&lt;p&gt;无论是Vetcor还是SynchronizedCollection甚至是ConcurrentHashMap，复合操作都不是线程安全的。如下面的代码&lt;sup&gt;[1]&lt;/sup&gt;在并发环境中可能会不符合预期：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;if (!vector.contains(element)) 
    vector.add(element); 
    ...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;ConcurrentHashMap&amp;lt;String, Integer&amp;gt; map = new ConcurrentHashMap();
map.put(&quot;key&quot;, 1);

// 多线程环境下执行
Integer currentVal = map.get(&quot;key&quot;);
map.put(&quot;key&quot;, currentVal + 1);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在复合操作的场景下，通用解法是对容器加锁，但这样会大幅降低性能。根据具体的场景来解决效果更好，如第二段代码的场景，可以改写为&lt;sup&gt;[1]&lt;/sup&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;ConcurrentHashMap&amp;lt;String, AtomicInteger&amp;gt; map = new ConcurrentHashMap();
// 多线程环境下执行
map.get(&quot;key&quot;).incrementAndGet();
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;modcount和迭代器iterator问题&quot;&gt;modCount和迭代器Iterator问题&lt;/h3&gt;
&lt;p&gt;modCount是大多数容器（比如ConcurrentHashMap就没有）用来检测是否发生了并发操作，从而判断是否需要抛出异常通知程序员去处理的一个简单的变量，也被称为fast-fail。&lt;br/&gt;一开始我注意到，Vector也有modCount这个属性，这个字段用来检测对于容器的操作期间是否并发地进行了其他操作，如果有会抛出并发异常。既然Vector是线程安全的，为什么还会有modCount？顺藤摸瓜，我发现虽然Vector的Iterator()方法是synchronized的，但是迭代器本身的方法并不是synchronized的。这就意味着在使用迭代器操作时，对Vector的增删等操作可能导致并发异常。&lt;br/&gt;为了避免这个问题，应该在使用Iterator时对Vector加锁。&lt;br/&gt;同理可以推广到Collecitons.synchronizedCollection()方法，可以看到这个方法创建的容器，对于迭代器和stream方法，都有一行&lt;code&gt;// Must be manually synched by user!&lt;/code&gt;的注释。&lt;/p&gt;
&lt;h2 id=&quot;注2：treemap的comparator和key&quot;&gt;注2：TreeMap的comparator和key&lt;/h2&gt;
&lt;p&gt;comparator是可以为空的，此时使用key的compare接口比较。因此，这种情况下如果key==null会抛NPE。&lt;/p&gt;
&lt;h2 id=&quot;注3：&quot;&gt;注3：&lt;/h2&gt;
&lt;p&gt;JDK8的HashMap中有afterNodeAccess()、afterNodeInsertion()、afterNodeRemoval()三个空方法，在LinkedHashMap中覆盖，用于回调。&lt;/p&gt;
&lt;h2 id=&quot;注4：linkedhashmap插入顺序和访问顺序&quot;&gt;注4：LinkedHashMap插入顺序和访问顺序&lt;/h2&gt;
&lt;p&gt;插入顺序不必解释。访问顺序指的是，每次访问一个节点，都将它插入到双向链表的末尾。&lt;/p&gt;
&lt;h2 id=&quot;注5：traverser&quot;&gt;注5：Traverser&lt;/h2&gt;
&lt;p&gt;其实现类EntryIterator的构造方法实际上是有bug的&lt;sup&gt;[5]&lt;/sup&gt;：它与子类的参数表顺序不一致。&lt;br/&gt;它能确保在扩容期间，每个节点只访问一次。这个原理比较复杂，我没有深入去看，可以参考本小节的参考文献。&lt;/p&gt;

&lt;p&gt;这是一个老生常谈的话题了，但是涉及面比较广，本节好好总结一下。&lt;br/&gt;本节不列出具体的源码，大部分直接给出结论，源码部分分析可以参考文献[7][8]。&lt;br/&gt;table表示Map的hash值桶，即每一个元素对应所有同一个hash值的key-value对。&lt;/p&gt;
&lt;h2 id=&quot;相同点&quot;&gt;相同点&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;keySet、values、entrySet()首次使用时初始化&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;差异点&quot;&gt;差异点&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;容器类型&lt;/th&gt;
&lt;th&gt;底层实现（见说明4）&lt;/th&gt;
&lt;th&gt;key的hash方法&lt;/th&gt;
&lt;th&gt;table下标计算&lt;/th&gt;
&lt;th&gt;扩容后table容量(见说明1、5)&lt;/th&gt;
&lt;th&gt;插入&lt;/th&gt;
&lt;th&gt;clone&lt;/th&gt;
&lt;th&gt;hash桶的最大容量&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;11.5&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;Hashtable&lt;/td&gt;
&lt;td&gt;hash值桶数组 + 链表&lt;/td&gt;
&lt;td&gt;hashCode()&lt;/td&gt;
&lt;td&gt;(hashCode &amp;amp; MAX_INT) % table.length&lt;/td&gt;
&lt;td&gt;origin*2+1&lt;/td&gt;
&lt;td&gt;头部插入&lt;/td&gt;
&lt;td&gt;浅拷贝&lt;/td&gt;
&lt;td&gt;MAXINT- 8&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;HashMap(1.7)&lt;/td&gt;
&lt;td&gt;hash值桶数组 + 链表&lt;/td&gt;
&lt;td&gt;String使用sun.misc.Hashing.stringHash32，其他用hashCode()后多次异或折叠(见说明2)&lt;/td&gt;
&lt;td&gt;(length-1) &amp;amp; hashCode&lt;/td&gt;
&lt;td&gt;origin*2&lt;/td&gt;
&lt;td&gt;头部插入（见说明6）&lt;/td&gt;
&lt;td&gt;浅拷贝&lt;/td&gt;
&lt;td&gt;2^30&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;HashMap(1.8)&lt;/td&gt;
&lt;td&gt;hash值桶数组 + 链表/红黑树(见说明3)&lt;/td&gt;
&lt;td&gt;hashCode()高低16位异或&lt;/td&gt;
&lt;td&gt;(length-1) &amp;amp; hashCode&lt;/td&gt;
&lt;td&gt;origin*2（见说明7）&lt;/td&gt;
&lt;td&gt;尾部插入&lt;/td&gt;
&lt;td&gt;浅拷贝&lt;/td&gt;
&lt;td&gt;2^30&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;ConcurrentHashMap(1.7)&lt;/td&gt;
&lt;td&gt;hash值桶数组 + Segment extends ReentrantLock（见说明9） + 数组&lt;/td&gt;
&lt;td&gt;String使用sun.misc.Hashing.stringHash32，其他用hashCode()后多次异或折叠和加法操作（见说明8）&lt;/td&gt;
&lt;td&gt;(length-1) &amp;amp; hashCode&lt;/td&gt;
&lt;td&gt;origin*2&lt;/td&gt;
&lt;td&gt;头部插入&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;2^30&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;ConcurrentHashMap(1.8)&lt;/td&gt;
&lt;td&gt;hash值桶数组 + 链表/红黑树（见说明10）&lt;/td&gt;
&lt;td&gt;hashCode()高低16位异或 % MAX_INT&lt;/td&gt;
&lt;td&gt;(length-1) &amp;amp; hashCode&lt;/td&gt;
&lt;td&gt;origin*2&lt;/td&gt;
&lt;td&gt;尾部插入&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;2^30&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;说明&quot;&gt;说明&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;HashMap和ConcurrentHashMap的key桶大小都是2的幂，便于将计算下标的取模操作转化为按位与操作&lt;/li&gt;
&lt;li&gt;Map的key建议使用不可变类如String、Integer等包装类型，其值是final的，这样可以防止key的hash发生变化&lt;/li&gt;
&lt;li&gt;1.8以后，链表转红黑树的阈值为8，红黑树转回链表的阈值位6。8是链表和红黑树平均查找时间(n/2和logn)的阈值，不在7转回是为了防止反复转换。&lt;/li&gt;
&lt;li&gt;1.7的HashMap的Entry和1.8中的Node几乎是一样的，区别在于：后者的equals()使用了Objects.equals()做了封装，而不是对象本身的equals()。另外链表节点Node和红黑树节点TreeNode没有关系，后者是extends LinkedHashMap的Node，通过红黑树查找算法找value。1.7的ConcurrentHashMap的Node中value、next是用volatile修饰的。&lt;strong&gt;但是&lt;/strong&gt;，1.8的ConcurrentHashMap有TreeNode&amp;lt;K,V&amp;gt; extends Node&amp;lt;K,V&amp;gt;，遍历查找值时是用Node的next进行的。&lt;/li&gt;
&lt;li&gt;扩容的依据是k-v容量&amp;gt;=扩容阈值threshold，而threshold= table数组大小 * 装载因子。扩容前后hash值没有变，但是取模(^length)变了，所以在新的table中所在桶的下标可能会变&lt;/li&gt;
&lt;li&gt;HashMap1.7的头插法在并发场景下reszie()容易导致链表循环，具体的执行场景见文献[7][9]。这一步不太好理解，我个人是用[9]的示意图自己完整在纸上推演了一遍才理解。关键点在于，被中断的线程，对同一个节点遍历了两次。虽然1.8改用了尾插法，仍然有循环引用的可能&lt;sup&gt;[10][11]&lt;/sup&gt;。&lt;/li&gt;
&lt;li&gt;1.8的HashMap在resize()时，要将节点分开，根据扩容后多计算hash的那一位是0还是1来决定放在原来的桶[i]还是桶[i+原始length]中。&lt;/li&gt;
&lt;li&gt;1.7中计算出hash值后，还会使用它计算所在的Segement&lt;/li&gt;
&lt;li&gt;put(key,value)时锁定分段锁，先用非阻塞tryLock()自旋，超过次数上限后升级为阻塞Lock()。&lt;/li&gt;
&lt;li&gt;1.8的ConcurrentHashMap抛弃了Segement，使用synchronized+CAS（使用tabAt()计算所在桶的下标，实际是用UNSAFE类计算内存偏移量）&lt;sup&gt;[12]&lt;/sup&gt;进行写入。具体来说，当桶[i]为空时，CAS写值；非空则对桶[i]加锁&lt;sup&gt;[13]&lt;/sup&gt;。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;concurrenthashmap的死锁问题&quot;&gt;ConcurrentHashMap的死锁问题&lt;/h3&gt;
&lt;h4 id=&quot;17场景&quot;&gt;1.7场景&lt;/h4&gt;
&lt;p&gt;对于跨段操作，如size()、containsValue()，是需要按Segement的下标递增逐段加锁、统计，然后按原先顺序解锁的。这样就有一个很严重的隐患：如果线程A在跨段操作时，中间的Segement[i]被&lt;br/&gt;线程B锁定，B又要去锁定Segement[j] （i&amp;gt;j），此时就发生了死锁。&lt;/p&gt;
&lt;h4 id=&quot;18场景&quot;&gt;1.8场景&lt;/h4&gt;
&lt;p&gt;由于没有段，也就没有了跨段。但是size()还是要统计各个桶的数目，仍然有跨桶的可能。如何计算？如果没有冲突发生，只将 size 的变化写入 baseCount。一旦发生冲突，就用一个数组（counterCells）来存储后续所有 size 的变化&lt;sup&gt;[14]&lt;/sup&gt;。&lt;br/&gt;而containsValue()则借助了Traverser（见第2节注5及参考文献[15]），但是返回值不是最新的&lt;/p&gt;

&lt;p&gt;没有在文中特殊标注的文章，是参考了其结构或部分内容，进行了重新组织。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/xdonx/article/details/9465489&quot;&gt;Vector 是线程安全的？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/loveqishan/java/article/details/89393122&quot;&gt;使用ConcurrentHashMap一定线程安全？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/LiaHon/p/11221634.html&quot;&gt;TreeMap原理实现及常用方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/qq_37875585/article/details/89335989&quot;&gt;Java容器常见面试题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.zijin.net/news/tech/339960.html&quot;&gt;Java高级程序员必备ConcurrentHashMap实现原理：扩容遍历与计数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/toria/p/11229063.html&quot;&gt;Java容器面试总结&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/carson_ho/article/details/79373026&quot;&gt;Java：手把手带你源码分析 HashMap 1.7&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/carson_ho/article/details/79373134&quot;&gt;Java源码分析：关于 HashMap 1.8 的重大更新&lt;/a&gt; 注：本篇的resize()源码和我本地JDK8的不一致！&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.jianshu.com/p/a1d69961141f&quot;&gt;HashMap底层详解-003-resize、并发下的安全问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/qq_33330687/article/details/101479385&quot;&gt;JDK8中HashMap依然会死循环！&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/gs_albb/article/details/88091808&quot;&gt;HashMap在jdk1.8中也会死循环&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/ty649128265/article/details/91857242&quot;&gt;ConcurrentHashMap中tabAt方法分析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_44460333/article/details/86770169&quot;&gt;HashMap？ConcurrentHashMap？相信看完这篇没人能难住你！&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/L__ear/article/details/106519200&quot;&gt;ConcurrentHashMap 1.8 计算 size 的方式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/u011392897/article/details/60479937&quot;&gt;Java集合类框架学习 5.3—— ConcurrentHashMap(JDK1.8)&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;</description>
<pubDate>Wed, 17 Jun 2020 17:42:00 +0000</pubDate>
<dc:creator>五岳</dc:creator>
<og:description>结合一些文章阅读源码后整理的Java容器常见知识点。对于一些代码细节，本文不展开来讲，有兴趣可以自行阅读参考文献。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wuyuegb2312/p/13097198.html</dc:identifier>
</item>
<item>
<title>图解MySQL索引(三)—如何正确使用索引？ - 浪人~</title>
<link>http://www.cnblogs.com/liqiangchn/p/13155536.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liqiangchn/p/13155536.html</guid>
<description>&lt;p&gt;MySQL使用了B+Tree作为底层数据结构，能够实现快速高效的数据查询功能。工作中可怕的是没有建立索引，比这更可怕的是建好了索引又没有使用到。&lt;br/&gt;本文将围绕着如何优雅的使用索引，图文并茂地和大家一起探讨索引的正确打开姿势，不谈底层原理，只求工作实战。&lt;/p&gt;
&lt;h3 id=&quot;h1&quot;&gt;&lt;span&gt;1. 索引的特点&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;page之间是双链表形式，而每个page内部的数据则是单链表形式存在。当进行数据查询时，会限定位到具体的page，然后在page中通过二分查找具体的记录。&lt;/p&gt;
&lt;img src=&quot;http://source.mycookies.cn/202006110041_610.jpg?ERROR&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;并且索引的顺序不同，数据的存储顺序则也不同。所以在开发过程中，一定要注意索引字段的先后顺序。&lt;/p&gt;
&lt;img src=&quot;http://source.mycookies.cn/202006110041_262.jpg?ERROR&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;blockquote&gt;
&lt;p&gt;最左匹配原则&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当一个索引中包含多个字段时，可以称之为组合索引。MySQL中有个很重要的规则，即最左匹配原则用来定义组合索引的命中规则，它是指在检索数据时从联合索引的最左边开始匹配。假设对用户表建立一个联合索引（a，b，c），那么条件a，（a，b），（a，b，c）都会用到索引。&lt;/p&gt;
&lt;p&gt;在匹配过程中会优先根据最左前面的字段a进行匹配，然后再判断是否用到了索引字段b，直到无法找到对应的索引字段，或者对应的索引被”破坏“（下文中会介绍）。&lt;/p&gt;
&lt;p&gt;以下是本文中操作实践用到的初始化语句，有条件的同学可以再本地执行，建议使用MySQL5.6+版本，毕竟实操才是学习的最佳途径。&lt;/p&gt;
&lt;pre readability=&quot;14.5&quot;&gt;
&lt;code class=&quot;sql language-sql hljs&quot; readability=&quot;23&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;SET&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;NAMES&lt;/span&gt; utf8mb4;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;DROP&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;IF&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;EXISTS&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;`test_table`&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;`test_table`&lt;/span&gt; (&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;`id`&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;bigint&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;) &lt;span class=&quot;hljs-keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;NULL&lt;/span&gt; AUTO_INCREMENT,&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;`a`&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;varchar&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;255&lt;/span&gt;) &lt;span class=&quot;hljs-keyword&quot;&gt;COLLATE&lt;/span&gt; utf8mb4_bin &lt;span class=&quot;hljs-keyword&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;NULL&lt;/span&gt;,&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;`b`&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;varchar&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;255&lt;/span&gt;) &lt;span class=&quot;hljs-keyword&quot;&gt;COLLATE&lt;/span&gt; utf8mb4_bin &lt;span class=&quot;hljs-keyword&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;NULL&lt;/span&gt;,&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;`c`&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;varchar&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;255&lt;/span&gt;) &lt;span class=&quot;hljs-keyword&quot;&gt;COLLATE&lt;/span&gt; utf8mb4_bin &lt;span class=&quot;hljs-keyword&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;NULL&lt;/span&gt;,&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;`d`&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;varchar&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;255&lt;/span&gt;) &lt;span class=&quot;hljs-keyword&quot;&gt;COLLATE&lt;/span&gt; utf8mb4_bin &lt;span class=&quot;hljs-keyword&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;NULL&lt;/span&gt;,&lt;br/&gt;PRIMARY &lt;span class=&quot;hljs-keyword&quot;&gt;KEY&lt;/span&gt; (&lt;span class=&quot;hljs-string&quot;&gt;`id`&lt;/span&gt;),&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;KEY&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;`idx_a_b_c`&lt;/span&gt; (&lt;span class=&quot;hljs-string&quot;&gt;`a`&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;`b`&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;`c`&lt;/span&gt;)&lt;br/&gt;) &lt;span class=&quot;hljs-keyword&quot;&gt;ENGINE&lt;/span&gt;=&lt;span class=&quot;hljs-keyword&quot;&gt;InnoDB&lt;/span&gt; AUTO_INCREMENT=&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;CHARSET&lt;/span&gt;=utf8mb4 &lt;span class=&quot;hljs-keyword&quot;&gt;COLLATE&lt;/span&gt;=utf8mb4_bin;&lt;p&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;BEGIN&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;INSERT&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;INTO&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;`test_table`&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;VALUES&lt;/span&gt; &lt;br/&gt;(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'zhangsan'&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'12222222222'&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'23'&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'aafasd'&lt;/span&gt;),&lt;br/&gt;(&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'lisi'&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'13333333333'&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'21'&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'cxvcxv'&lt;/span&gt;),&lt;br/&gt;(&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'wanger'&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'14444444444'&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'24'&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'dfdf'&lt;/span&gt;),&lt;br/&gt;(&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'liqiang'&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'18888888888'&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'18'&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'ccsdf'&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;COMMIT&lt;/span&gt;;&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h2&quot;&gt;&lt;span&gt;2. 正确创建索引&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;尽量使用自增长主键&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用自增长主键的原因笔者认为有两个。首先能有效减少页分裂，MySQL中数据是以页为单位存储的且每个页的大小是固定的（默认16kb），如果一个数据页的数据满了，则需要分成两个页来存储，这个过程就叫做页分裂。&lt;/p&gt;
&lt;p&gt;如果使用了自增主键的话，新插入的数据都会尽量的往一个数据页中写，写满了之后再申请一个新的数据页写即可（大多数情况下不需要分裂，除非父节点的容量也满了）。&lt;/p&gt;
&lt;p&gt;自增主键&lt;/p&gt;
&lt;img src=&quot;http://file.mycookies.cn/201805191537_258.gif?imageView1/JannLee/md/01&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;非自增主键&lt;/p&gt;
&lt;img src=&quot;http://file.mycookies.cn/201805191538_202.gif?imageView1/JannLee/md/01&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;其次，对于缓存友好。系统分配给MySQL的内存有限，对于数据量比较多的数据库来说，通常只有一小部分数据在内存中，而大多数数据都在磁盘中。如果使用无序的主键，则会造成随机的磁盘IO，影响系统性能。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;选择性高的列优先&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;关注索引的选择性。索引的选择性，也可称为数据的熵。在创建索引的时候通常要求将选择性高的列放在最前面，对于选择性不高的列甚至可以不创建索引。如果选择性不高，极端性情况下可能会扫描全部或者大多数索引，然后再回表，这个过程可能不如直接走主键索引性能高。&lt;/p&gt;
&lt;img src=&quot;http://source.mycookies.cn/202006160100_924.png?ERROR&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;索引列的选择往往需要根据具体的业务场景来选择，但是需要注意的是索引的区分度越高则价值就越高，意味着对于检索的性价比就高。索引的区分度等于count(distinct 具体的列) / count(*)，表示字段不重复的比例。&lt;/p&gt;
&lt;p&gt;唯一键的区分度是1，而对于一些状态值，性别等字段区分度往往比较低，在数据量比较大的情况下，甚至有无限接近0。假设一张表中用data_status来表示数据的状态，1-有效，2-删除，则数据的区分度为 1/500000。如果100万条数据中只有1条被删除，并且在查询数据时查找data_status = 0 的数据时，需要进行全表扫描。由于索引也是需要占用内存的，所以在内存较为有限的环境下，区分度不高的索引几乎没有意义。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;联合索引优先于多列独立索引&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;联合索引优先于多列独立索引， 假设有三个字段a,b,c, 索引（a）(a,b)，(a,b,c)可以使用(a,b,c)代替。MySQL中的索引并不是越多越好，各个公司的规定中往往会限制单表中的索引的个数。原因在于，索引本身也会占用一定的空间，并且维护一个索引时有一定的代码的，所以在满足需求的情况下一定要尽可能创建更少的索引。&lt;/p&gt;
&lt;p&gt;执行语句：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;sql language-sql hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;explain&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; test_table &lt;span class=&quot;hljs-keyword&quot;&gt;where&lt;/span&gt; a = &lt;span class=&quot;hljs-string&quot;&gt;&quot;zhangsan&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;explain&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; test_table &lt;span class=&quot;hljs-keyword&quot;&gt;where&lt;/span&gt; a = &lt;span class=&quot;hljs-string&quot;&gt;&quot;zhangsan&quot;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;and&lt;/span&gt; b = &lt;span class=&quot;hljs-string&quot;&gt;&quot;188466668888&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;explain&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; test_table &lt;span class=&quot;hljs-keyword&quot;&gt;where&lt;/span&gt; a = &lt;span class=&quot;hljs-string&quot;&gt;&quot;zhangsan&quot;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;and&lt;/span&gt; b = &lt;span class=&quot;hljs-string&quot;&gt;&quot;188466668888&quot;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;and&lt;/span&gt; c = &lt;span class=&quot;hljs-string&quot;&gt;&quot;23&quot;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果分析:&lt;/p&gt;
&lt;img src=&quot;https://source.mycookies.cn/202006110027_96.png?ERROR&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;img src=&quot;https://source.mycookies.cn/202006110030_151.png?ERROR&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;img src=&quot;https://source.mycookies.cn/202006110030_750.png?ERROR&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;实际上建立(a, b, c)联合索引时，其作用相当于(a), (a, b), (a, b, c) 三个索引。所以以上三种查询方式均会命中索引。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;覆盖索引避免回表&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;覆盖索引如果执行的语句是 select ID from T where k between 3 and 5，这时只需要查 ID 的值，而 ID 的值已经在 k 索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，索引 k 已经“覆盖了”我们的查询需求，我们称为覆盖索引。由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。&lt;/p&gt;
&lt;img src=&quot;http://source.mycookies.cn/202006160052_611.png?ERROR&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;img src=&quot;http://source.mycookies.cn/202006160051_191.png?ERROR&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;&lt;strong&gt;覆盖索引的查询优化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;覆盖索引同时还会影响索引的选择，对于（a，b，c）索引来说，理论上来说不满足最左匹配原则，但是实际上也会走索引。原因在于，优化器认为（a，b，c）索引的性能会高于全表扫描，实际情况也是这样的，感兴趣的小伙伴不妨分析一下上文中介绍的数据结构。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;sql language-sql hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;explain&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; a,b,c &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; test_table &lt;span class=&quot;hljs-keyword&quot;&gt;where&lt;/span&gt; b = &lt;span class=&quot;hljs-string&quot;&gt;&quot;188466668888&quot;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;and&lt;/span&gt; c = &lt;span class=&quot;hljs-string&quot;&gt;&quot;23&quot;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;img src=&quot;https://source.mycookies.cn/202006110032_687.png?ERROR&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;blockquote&gt;
&lt;p&gt;满足查询和排序&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;索引要满足查询和排序。大部分同学在创建索引时，通常第一反应是查询条件来选择索引列，需要注意的是查询和排序同样重要，我们建立的索引要同时满足查询和排序的需求.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;包含要排序的列&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;sql language-sql hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; c, d &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; test_table  &lt;span class=&quot;hljs-keyword&quot;&gt;where&lt;/span&gt; a = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;and&lt;/span&gt; b = &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;order&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;by&lt;/span&gt; c;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;虽然查询条件只使用了a,b两个字段，但是由于排序用到了c字段，我们能可以建立(a,b,c)联合索引来进行优化。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;保证索引字段顺序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如上文中的介绍，索引的字段顺序决定了索引数据的组织顺序。要想更高性能的检索数据，一定要尽可能的借助底层数据结构的特点来进行。如，索引(a, b)的默认组织形式就是先根据a排序，在a相同的情况下再根据b排序。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;考虑索引的大小&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;内存中的空间十分宝贵，而索引往往又需要在内存中。为了在有限的内存中存储更多的索引，在设计索引时往往要考虑索引的大小。比如我们常用的邮箱，xxxx@xx.com, 假设都是abc公司的，则邮箱后缀完全一致为@abc.com, 索引的区分度完全取决于@前面的字符串。&lt;/p&gt;
&lt;p&gt;针对上述情况，MySQL 是支持&lt;strong&gt;前缀索引&lt;/strong&gt;的，也就是说，你可以定义字符串的一部分作为索引。默认地，如果你创建索引的语句不指定前缀长度，那么索引就会包含整个字符串。&lt;/p&gt;
&lt;img src=&quot;http://source.mycookies.cn/202006160044_587.png?ERROR&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;如果使用的 email 整个字符串的索引结构执行顺序是这样的：从 index1 索引树找到满足索引值是’liqiang156@11.com’的这条记录，取得 id （主键）的值ID2；到主键上查到主键值是ID2的行，将这行记录加入结果集；&lt;/p&gt;
&lt;p&gt;取 email 索引树上刚刚查到的位置的下一条记录，发现已经不满足 email='liqiang156@qq.com’的条件了，循环结束。这个过程中，只需要回主键索引取一次数据，所以系统认为只扫描了一行。但是它的问题就是索引的后半部分都是重复的，浪费内存。&lt;/p&gt;
&lt;img src=&quot;http://source.mycookies.cn/202006160045_352.png?ERROR&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;这时我们可以考虑使用前缀索引，如果使用的是 index2 (email(7) 索引结构)，执行顺序是这样的：从 index2 索引树找到满足索引值是’liqiang’的记录，找到的第一个是 ID1，到主键上查到主键值是 ID1 的行，判断出 email 的值是’liqiang156@xxx.com’，加入结果集。&lt;/p&gt;
&lt;p&gt;取 index2 上刚刚查到的位置的下一条记录，发现仍然是’liqiang’，取出 ID2，再到 ID 索引上取整行然后判断，这次值仍然不对，则丢弃继续往下取。&lt;br/&gt;重复上一步，直到在 index2 上取到的值不是’liqiang’或者索引搜索完毕之后，循环结束。在这个过程中，要回主键索引取 4 次数据，也就是扫描了 4 行。通过这个对比，你很容易就可以发现，使用前缀索引后，可能会导致查询语句读数据的次数变多。&lt;/p&gt;
&lt;img src=&quot;http://source.mycookies.cn/202006160045_790.png?ERROR&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;不过方法总比困难多，我们在建立索引时可以先通过语句查看一下索引的区分度，或者提前预估余下前缀长度，对于上述问题我们可以将前缀长度调整为9即可达到效果。索引，在使用前缀索引时，一定要充分考虑数据的特征，选择合适的&lt;/p&gt;
&lt;p&gt;对于一些比较长的字段的等值查询，我们也可以采用其他方式来缩短索引的长度。比如url一般都是比较长，我们可以冗余一列&lt;strong&gt;存储其Hash值&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;sql language-sql hljs&quot;&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; field_list &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; t &lt;span class=&quot;hljs-keyword&quot;&gt;where&lt;/span&gt; id_card_crc=&lt;span class=&quot;hljs-keyword&quot;&gt;crc32&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;'input_id_card_string'&lt;/span&gt;) &lt;span class=&quot;hljs-keyword&quot;&gt;and&lt;/span&gt; id_card=&lt;span class=&quot;hljs-string&quot;&gt;'input_id_card_string'&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于我们国家的身份证号，一共 18 位，其中前 6 位是地址码，所以同一个县的人的身份证号前 6 位一般会是相同的。为了提高区分度，我们可以将身份证号码&lt;strong&gt;倒序存储&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;sql language-sql hljs&quot;&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; field_list &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; t &lt;span class=&quot;hljs-keyword&quot;&gt;where&lt;/span&gt; id_card = &lt;span class=&quot;hljs-keyword&quot;&gt;reverse&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;'input_id_card_string'&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h3&quot;&gt;&lt;span&gt;3. 正确使用索引&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;建立合适的索引是前提，想要取得理想的查询性能，还应保证能够用到索引。避免索引失效即是优化。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;不在索引上进行任何操作&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;索引上进行&lt;strong&gt;计算，函数，类型转换&lt;/strong&gt;等操作都会导致索引从当前位置（联合索引多个字段，不影响前面字段的匹配）失效，可能会进行全表扫描。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;sql language-sql hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;explain&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; test_table &lt;span class=&quot;hljs-keyword&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;upper&lt;/span&gt;(a) = &lt;span class=&quot;hljs-string&quot;&gt;&quot;ZHANGSAN&quot;&lt;/span&gt; &lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;img src=&quot;https://source.mycookies.cn/202006110033_481.png?ERROR&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;对于需要计算的字段，则一定要将计算方法放在“=”后面，否则会破坏索引的匹配，目前来说MySQL优化器不能对此进行优化。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;sql language-sql hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;explain&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; test_table &lt;span class=&quot;hljs-keyword&quot;&gt;where&lt;/span&gt; a = &lt;span class=&quot;hljs-keyword&quot;&gt;lower&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;ZHANGSAN&quot;&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;img src=&quot;https://source.mycookies.cn/202006110033_180.png?ERROR&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;&lt;strong&gt;隐式类型转换&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;需要注意的是，在查询时一定要注意字段类型问题，比如a字段时字符串类型的，而匹配参数用的是int类型，此时就会发生隐式类型转换，相当于相当于在索引上使用函数。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;sql language-sql hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;explain&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; test_table &lt;span class=&quot;hljs-keyword&quot;&gt;where&lt;/span&gt; a = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;img src=&quot;https://source.mycookies.cn/202006110033_794.png?ERROR&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;br/&gt;&lt;code&gt;a是字符串类型，然后使用int类型的1进行匹配&lt;/code&gt;,此时就发生了隐式类型转换，破坏索引的使用。

&lt;blockquote&gt;
&lt;p&gt;只查询需要的列&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在日常开发中很多同学习惯使用 select * … 来构建查询语句，这种做法也是极不推荐的。主要原因有两个，首先查询无用的列在数据传输和解析绑定过程中会增加网络IO，以及CPU的开销，尽管往往这些消耗可以被忽略，但是我们也要避免埋坑。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;sql language-sql hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;explain&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; a,b,c &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; test_table &lt;span class=&quot;hljs-keyword&quot;&gt;where&lt;/span&gt; a=&lt;span class=&quot;hljs-string&quot;&gt;&quot;zhangsan&quot;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;and&lt;/span&gt; b = &lt;span class=&quot;hljs-string&quot;&gt;&quot;188466668888&quot;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;and&lt;/span&gt; c = &lt;span class=&quot;hljs-string&quot;&gt;&quot;23&quot;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;img src=&quot;https://source.mycookies.cn/202006110033_403.png?ERROR&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;
&lt;p&gt;其次就是会使得覆盖索引&quot;失效&quot;, 这里的失效并非真正的不走索引。覆盖索引的本质就是在索引中包含所要查询的字段，而 select * 将使覆盖索引失去意义，仍然需要进行回表操作，毕竟索引通常不会包含所有的字段，这一点很重要。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;sql language-sql hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;explain&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; test_table &lt;span class=&quot;hljs-keyword&quot;&gt;where&lt;/span&gt; a=&lt;span class=&quot;hljs-string&quot;&gt;&quot;zhangsan&quot;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;and&lt;/span&gt; b = &lt;span class=&quot;hljs-string&quot;&gt;&quot;188466668888&quot;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;and&lt;/span&gt; c = &lt;span class=&quot;hljs-string&quot;&gt;&quot;23&quot;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;img src=&quot;https://source.mycookies.cn/202006110033_156.png?ERROR&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;blockquote&gt;
&lt;p&gt;不等式条件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;查询语句中只要包含不等式，负向查询一般都不会走索引，如 !=, &amp;lt;&amp;gt;, not in, not like等。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;sql language-sql hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;explain&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; test_table &lt;span class=&quot;hljs-keyword&quot;&gt;where&lt;/span&gt; a !=&lt;span class=&quot;hljs-string&quot;&gt;&quot;1222&quot;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;and&lt;/span&gt; b=&lt;span class=&quot;hljs-string&quot;&gt;&quot;12222222222&quot;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;and&lt;/span&gt; c = &lt;span class=&quot;hljs-number&quot;&gt;23&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;explain&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; test_table &lt;span class=&quot;hljs-keyword&quot;&gt;where&lt;/span&gt; a &amp;lt;&amp;gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;1222&quot;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;and&lt;/span&gt; b=&lt;span class=&quot;hljs-string&quot;&gt;&quot;12222222222&quot;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;and&lt;/span&gt; c = &lt;span class=&quot;hljs-number&quot;&gt;23&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;img src=&quot;https://source.mycookies.cn/202006110034_426.png?ERROR&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;pre&gt;
&lt;code class=&quot;sql language-sql hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;explain&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; test_table &lt;span class=&quot;hljs-keyword&quot;&gt;where&lt;/span&gt; a &lt;span class=&quot;hljs-keyword&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; (&lt;span class=&quot;hljs-string&quot;&gt;&quot;xxxx&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;img src=&quot;https://source.mycookies.cn/202006110034_841.png?ERROR&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;blockquote&gt;
&lt;p&gt;模糊匹配查询&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最左前缀在进行模糊匹配时，一般禁止使用%前导的查询，如like “%zhangsan”。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;sql language-sql hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;explain&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; test_table &lt;span class=&quot;hljs-keyword&quot;&gt;where&lt;/span&gt; a &lt;span class=&quot;hljs-keyword&quot;&gt;like&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;zhangsan&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;explain&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; test_table &lt;span class=&quot;hljs-keyword&quot;&gt;where&lt;/span&gt; a &lt;span class=&quot;hljs-keyword&quot;&gt;like&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;%zhangsan&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;explain&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; test_table &lt;span class=&quot;hljs-keyword&quot;&gt;where&lt;/span&gt; a &lt;span class=&quot;hljs-keyword&quot;&gt;like&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;zhangsan%&quot;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;img src=&quot;https://source.mycookies.cn/202006110034_78.png?ERROR&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;img src=&quot;https://source.mycookies.cn/202006110034_241.png?ERROR&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;img src=&quot;https://source.mycookies.cn/202006110034_216.png?ERROR&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;blockquote&gt;
&lt;p&gt;最左匹配原则&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;索引是有顺序的，查询条件中缺失索引列之后的其他条件都不会走索引。比如(a, b, c)索引，只使用b, c索引，就不会走索引。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;sql language-sql hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;explain&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; test_table &lt;span class=&quot;hljs-keyword&quot;&gt;where&lt;/span&gt; b = &lt;span class=&quot;hljs-string&quot;&gt;&quot;188466668888&quot;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;and&lt;/span&gt; c = &lt;span class=&quot;hljs-string&quot;&gt;&quot;23&quot;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;img src=&quot;https://source.mycookies.cn/202006110034_90.png?ERROR&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;如果索引从中间断开，索引会部分失效。这里的断开指的是缺失该字段的查询条件，或者说满足上述索引失效情况的任意一个。不过这里的仍然会使用到索引，只不过只能使用到索引的前半部分。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;sql language-sql hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;explain&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; test_table &lt;span class=&quot;hljs-keyword&quot;&gt;where&lt;/span&gt; a=&lt;span class=&quot;hljs-string&quot;&gt;&quot;zhangsan&quot;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;and&lt;/span&gt; b != &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;and&lt;/span&gt; c = &lt;span class=&quot;hljs-string&quot;&gt;&quot;23&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;img src=&quot;http://source.mycookies.cn/202006110034_491.png?ERROR&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;值得注意的是，如果使用了不等式查询条件，会导致索引完全失效。而上一个例子中即使用了不等式条件，也使用了隐式类型转换却能用到索引。&lt;/p&gt;
&lt;img src=&quot;https://source.mycookies.cn/202006110034_290.png?ERROR&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;同理，根据最左前缀匹配原则，以下如果使用b，c作为查询条件则不会使用(a, b, c)索引。&lt;/p&gt;
&lt;p&gt;执行语句：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;sql language-sql hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;explain&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; test_table &lt;span class=&quot;hljs-keyword&quot;&gt;where&lt;/span&gt; b = &lt;span class=&quot;hljs-string&quot;&gt;&quot;188466668888&quot;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;and&lt;/span&gt; c = &lt;span class=&quot;hljs-string&quot;&gt;&quot;23&quot;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;img src=&quot;https://source.mycookies.cn/202006110032_785.png?ERROR&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;&lt;strong&gt;索引下推&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在说索引下推之前，我们先执行一下SQL。&lt;/p&gt;
&lt;p&gt;执行语句：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;sql language-sql hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;explain&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; test_table &lt;span class=&quot;hljs-keyword&quot;&gt;where&lt;/span&gt; a = &lt;span class=&quot;hljs-string&quot;&gt;&quot;zhangsan&quot;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;and&lt;/span&gt; c = &lt;span class=&quot;hljs-string&quot;&gt;&quot;23&quot;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;img src=&quot;https://source.mycookies.cn/202006110033_166.png?ERROR&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;上述的最左前缀匹配原则相信大家都能很容易的理解，那么使用(a, c)条件查询能够利用(a, b, c)吗？答案是肯定的，正如上图所示。即使没有索引下推也会会根据最左匹配原则，使用到索引中的a字段。有了索引下推之后会增加查询的效率。&lt;/p&gt;
&lt;p&gt;在面试中通常会问到这样一个问题，已知有索引(a,b,c)则根据条件(a,c)查询时会不会走索引呢？答案是肯定的，但是是有版本限制的。&lt;/p&gt;
&lt;p&gt;而 MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数，是对查询的一种优化，感兴趣的同学可以看一下官方说明https://dev.mysql.com/doc/refman/8.0/en/index-condition-pushdown-optimization.html。&lt;/p&gt;
&lt;img src=&quot;http://source.mycookies.cn/202006170049_552.jpg?ERROR&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;上述是没有索引下推，每次查询完之后都会回表，取到对应的字段进行匹配。&lt;/p&gt;
&lt;img src=&quot;http://source.mycookies.cn/202006170050_191.jpg?ERROR&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;br/&gt;利用索引下推，每次尽可能在辅助索引中将不符合条件数据过滤掉。比如，索引中已经包含了name和age，索引不妨暂且忽略破坏索引匹配的条件直接匹配。

&lt;p&gt;&lt;strong&gt;查询优化-自适应索引顺序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;查询时，mysql的优化器会优化sql的执行，即使查询条件的顺序没有按照定义顺序来使用，也是可以使用索引的。但是需要注意的是优化本身也会消耗一定的性能，所以还是推荐按照索引的定义来书写sql。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;sql language-sql hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;explain&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt;  * &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; test_table &lt;span class=&quot;hljs-keyword&quot;&gt;where&lt;/span&gt; b=&lt;span class=&quot;hljs-string&quot;&gt;&quot;12222222222&quot;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;and&lt;/span&gt; a=&lt;span class=&quot;hljs-string&quot;&gt;&quot;zhangsan&quot;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;and&lt;/span&gt; c = &lt;span class=&quot;hljs-number&quot;&gt;23&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;explain&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt;  * &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; test_table &lt;span class=&quot;hljs-keyword&quot;&gt;where&lt;/span&gt; a=&lt;span class=&quot;hljs-string&quot;&gt;&quot;zhangsan&quot;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;and&lt;/span&gt; b=&lt;span class=&quot;hljs-string&quot;&gt;&quot;12222222222&quot;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;and&lt;/span&gt; c = &lt;span class=&quot;hljs-number&quot;&gt;23&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;img src=&quot;https://source.mycookies.cn/202006110034_91.png?ERROR&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;h3 id=&quot;h4&quot;&gt;&lt;span&gt;4. 总结&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;索引并不是什么高深的技术，从底层来看，不过是一个数据结构罢了。要想使用好索引，一定要先将B+Tree理解透彻，在此基础上对于日常使用和面试则是信手拈来。&lt;/p&gt;
&lt;p&gt;脱离业务的设计都是耍流氓，技术的意义在于服务业务。所以，索引的设计需要充分考虑业务的需求与设计原则之间做一些取舍，满足需求是基础。&lt;/p&gt;
&lt;p&gt;在工作中，各个公司的版本可能大不相同，会存在一些奇奇怪怪，不确定的问题。所以为了验证索引的有效性，强烈推荐把主要的查询sql都通过explain查看一下执行计划，是否会用到索引。&lt;/p&gt;
&lt;p&gt;参考资料：&lt;br/&gt;[1] 《MySQL 45讲》—极客时间&lt;br/&gt;[2] 《InnoDB存储引擎》&lt;br/&gt;[3] 《高性能MySQL》&lt;br/&gt;[4] https://dev.mysql.com/doc/refman/8.0/en/&lt;/p&gt;
</description>
<pubDate>Wed, 17 Jun 2020 17:33:00 +0000</pubDate>
<dc:creator>浪人~</dc:creator>
<og:description>MySQL使用了B+Tree作为底层数据结构，能够实现快速高效的数据查询功能。工作中可怕的是没有建立索引，比这更可怕的是建好了索引又没有使用到。本文将围绕着如何优雅的使用索引，图文并茂地和大家一起探讨</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/liqiangchn/p/13155536.html</dc:identifier>
</item>
<item>
<title>【译】Announcing Entity Framework Core 5.0 Preview 5 - MeteorSeed</title>
<link>http://www.cnblogs.com/MeteorSeed/p/13155452.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MeteorSeed/p/13155452.html</guid>
<description>&lt;p&gt;　　今天我们宣布EF Core 5.0发布第五个预览版。&lt;/p&gt;

&lt;p&gt;　　EF Core 5.0 的预览版要求  .NET Standard 2.1。这意味着：&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;EF Core 5.0 在 .NET Core 3.1 上运行，不需要 .NET 5。根据 .NET 5 计划的改变，这可能会在未来发生变化。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;EF Core 5.0 运行在其他支持 .NET Standard 2.1 的平台上。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;EF Core 5.0 将不会在 .NET Standard 2.0 平台上运行，包括 .NET Framework。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;　　使用NuGet添加，例如添加SQL Server的提供程序：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
dotnet add package Microsoft.EntityFrameworkCore.SqlServer --version &lt;span data-mce-=&quot;&quot;&gt;5.0.&lt;span data-mce-=&quot;&quot;&gt;0-preview.&lt;span data-mce-=&quot;&quot;&gt;5.20278.&lt;span data-mce-=&quot;&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　目前发布的 EF Core包包括：&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul readability=&quot;12&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Microsoft.EntityFrameworkCore – 主程序&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Microsoft.EntityFrameworkCore.SqlServer – SQL Server与SQL Azure提供者&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Microsoft.EntityFrameworkCore.Sqlite – SQLite提供者&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Microsoft.EntityFrameworkCore.Cosmos – Azure Cosmos DB提供者&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Microsoft.EntityFrameworkCore.InMemory – 内存数据库提供者&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Microsoft.EntityFrameworkCore.Tools –Visual Studio Package Manager Console的 EF Core PowerShell命令&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Microsoft.EntityFrameworkCore.Design – EF Core的设计时组件&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Microsoft.EntityFrameworkCore.SqlServer.NetTopologySuite – SQL Server 空间类型支持&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Microsoft.EntityFrameworkCore.Sqlite.NetTopologySuite – SQLite空间类型支持&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Microsoft.EntityFrameworkCore.Proxies –延迟加载与变化跟踪代理&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Microsoft.EntityFrameworkCore.Abstractions – 分离的EF Core抽象&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Microsoft.EntityFrameworkCore.Relational – 关系数据库提供程序的共享EF Core组件&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Microsoft.EntityFrameworkCore.Analyzers – EF Core的C#分析器&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Microsoft.EntityFrameworkCore.Sqlite.Core – SQLite提供者（没有打包的本机二进制文件）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　我们还发布了Microsoft.Data.Sqlite.Core ADO.NET provider的预览版。&lt;/p&gt;

&lt;p&gt;　　与EF Core 3.0和3.1一样，dotnet EF命令行工具不再包含在.NET Core SDK中。在执行EF Core的migration或scaffolding命令之前，必须将此包作为全局或本地工具安装。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/270073/202006/270073-20200618001418478-612447200.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　若要全局安装预览版工具，需要先使用以下命令卸载现有的版本：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
dotnet tool uninstall --&lt;span&gt;global&lt;/span&gt; dotnet-ef
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后，进行安装：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
dotnet tool install --&lt;span&gt;global&lt;/span&gt; dotnet-ef --version &lt;span&gt;5.0&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;-preview.&lt;span&gt;5.20278&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　可以将此新版本的dotnet ef与使用较旧版本的EF Core运行时的项目一起使用。&lt;/p&gt;

&lt;h2&gt;4.1 数据库排序规则&lt;/h2&gt;
&lt;p&gt;　　现在可以在 EF Model中指定数据库的默认排序规则。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
modelBuilder.UseCollation(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;German_PhoneBook_CI_AS&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后，Migrations将生成以下内容以在 SQL Server 上创建数据库：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CREATE DATABASE [Test]
COLLATE German_PhoneBook_CI_AS;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　也可以指定用于特定数据库列的排序规则。&lt;/p&gt;
&lt;p&gt;　　例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;modelBuilder
     .Entity&lt;/span&gt;&amp;lt;User&amp;gt;&lt;span&gt;()
     .Property(e &lt;/span&gt;=&amp;gt;&lt;span&gt; e.Name)
     .UseCollation(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;German_PhoneBook_CI_AS&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　为了那些不使用migration的人，现在，在 DbContext scaffolding时，将从数据库进行反向工程。最后，EF.Functions.Collate() 允许使用不同的排序规则进行临时查询。&lt;/p&gt;
&lt;p&gt;　　例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
context.Users.Single(e =&amp;gt; EF.Functions.Collate(e.Name, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;French_CI_AS&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Jean-Michel Jarre&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这将生成 SQL Server 的以下查询：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
SELECT TOP(&lt;span&gt;2&lt;/span&gt;&lt;span&gt;) [u].[Id], [u].[Name]
FROM [Users] AS [u]
WHERE [u].[Name] COLLATE French_CI_AS &lt;/span&gt;= N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Jean-Michel Jarre&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　请注意，临时排序规则应谨慎使用，因为它们会对数据库性能产生负面影响。&lt;/p&gt;
&lt;h2&gt;4.2 传递参数给IDesignTimeDbContextFactory&lt;/h2&gt;
&lt;p&gt;　　参数现在从命令行传入IDesignTimeDbContextFactory 的 CreateDbContext 方法。&lt;/p&gt;
&lt;p&gt;　　例如，为了指示这是开发构建，可以在命令行上传递自定义参数（例如 dev）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
dotnet ef migrations add two --verbose --dev
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后，此参数将传递到工厂：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MyDbContextFactory : IDesignTimeDbContextFactory&amp;lt;SomeDbContext&amp;gt;&lt;span&gt;
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; SomeDbContext CreateDbContext(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        &lt;/span&gt;=&amp;gt; &lt;span&gt;new&lt;/span&gt; SomeDbContext(args.Contains(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--dev&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;4.3 具有标识解析的无跟踪查询&lt;/h2&gt;
&lt;p&gt;　　现在，可以将无跟踪查询配置为执行标识解析。&lt;/p&gt;
&lt;p&gt;　　例如，以下查询将为每个Post创建新的Blog实例，即使每个Blog具有相同的主键也是如此。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
context.Posts.AsNoTracking().Include(e =&amp;gt; e.Blog).ToList();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　但是，可以更改此查询以确保只创建单个 Blog 实例，但代价通常是稍微慢一点，并且使用更多内存：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
context.Posts.AsNoTracking().PerformIdentityResolution().Include(e =&amp;gt; e.Blog).ToList();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　请注意，这仅适用于无跟踪查询，因为所有跟踪查询都已表现出此行为。&lt;/p&gt;
&lt;h2&gt;4.4 持久化计算列&lt;/h2&gt;
&lt;p&gt;　　大多数数据库允许在计算后存储计算列的值。&lt;/p&gt;
&lt;p&gt;　　虽然这占用磁盘空间，但计算列在更新时只计算一次，而不是在每次检索其值时计算。&lt;/p&gt;
&lt;p&gt;　　这还允许对某些数据库的列设置索引。&lt;/p&gt;
&lt;p&gt;　　EF Core 5.0 允许将计算列配置为存储列。&lt;/p&gt;
&lt;p&gt;　　例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;modelBuilder
    .Entity&lt;/span&gt;&amp;lt;User&amp;gt;&lt;span&gt;()
    .Property(e &lt;/span&gt;=&amp;gt;&lt;span&gt; e.SomethingComputed)
    .HasComputedColumnSql(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;my sql&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, stored: &lt;span&gt;true&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;4.5 SQLite计算列&lt;/h2&gt;
&lt;p&gt;　　EF Core 现在支持 SQLite 数据库的计算列。&lt;/p&gt;

&lt;p&gt;　　提供了以下短链接，便于参考和访问。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;　　&lt;a href=&quot;https://devblogs.microsoft.com/dotnet/announcing-entity-framework-core-5-0-preview-5/?utm_source=vs_developer_news&amp;amp;utm_medium=referral&quot; target=&quot;_blank&quot;&gt;https://devblogs.microsoft.com/dotnet/announcing-entity-framework-core-5-0-preview-5/?utm_source=vs_developer_news&amp;amp;utm_medium=referral&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 17 Jun 2020 16:30:00 +0000</pubDate>
<dc:creator>MeteorSeed</dc:creator>
<og:description>今天我们宣布EF Core 5.0发布第五个预览版。 1 先决条件 EF Core 5.0 的预览版要求 .NET Standard 2.1。这意味着： EF Core 5.0 在 .NET Core</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/MeteorSeed/p/13155452.html</dc:identifier>
</item>
<item>
<title>ZooKeeper使用入门 - ☆★傲天★☆</title>
<link>http://www.cnblogs.com/aotian/p/13155203.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/aotian/p/13155203.html</guid>
<description>&lt;h2 id=&quot;zookeeper简介&quot;&gt;ZooKeeper简介&lt;/h2&gt;
&lt;p&gt;ZooKeeper是一个分布式的，开源的分布式应用程序协调服务，是Hadoop的子项目之一。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。&lt;/p&gt;
&lt;h2 id=&quot;安装zookeeper&quot;&gt;安装ZooKeeper&lt;/h2&gt;
&lt;h3 id=&quot;操作系统要求&quot;&gt;操作系统要求&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;操作系统&lt;/th&gt;
&lt;th&gt;客户端&lt;/th&gt;
&lt;th&gt;服务端&lt;/th&gt;
&lt;th&gt;原生客户端&lt;/th&gt;
&lt;th&gt;附加组件&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;GNU/Linux&lt;/td&gt;
&lt;td&gt;开发/生产&lt;/td&gt;
&lt;td&gt;开发/生产&lt;/td&gt;
&lt;td&gt;开发/生产&lt;/td&gt;
&lt;td&gt;开发/生产&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Solaris&lt;/td&gt;
&lt;td&gt;开发/生产&lt;/td&gt;
&lt;td&gt;开发/生产&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;FreeBSD&lt;/td&gt;
&lt;td&gt;开发/生产&lt;/td&gt;
&lt;td&gt;开发/生产&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Windows&lt;/td&gt;
&lt;td&gt;开发/生产&lt;/td&gt;
&lt;td&gt;开发/生产&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Mac OS X&lt;/td&gt;
&lt;td&gt;开发&lt;/td&gt;
&lt;td&gt;开发&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;软件要求&quot;&gt;软件要求&lt;/h3&gt;
&lt;p&gt;Java 8及Java 11以上版本（Java 9和10不支持）&lt;/p&gt;
&lt;h3 id=&quot;硬件要求&quot;&gt;硬件要求&lt;/h3&gt;
&lt;p&gt;此硬件资源为官网推荐的配置，实际开发过程中不需要这么大，笔者测试1核1G内存20G硬盘的虚拟机即可运行。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;2核&lt;/li&gt;
&lt;li&gt;2G内存&lt;/li&gt;
&lt;li&gt;80G硬盘&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;下载安装并进行单点配置&quot;&gt;下载安装并进行单点配置&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;下载页面地址：&lt;a href=&quot;https://zookeeper.apache.org/releases.html&quot;&gt;https://zookeeper.apache.org/releases.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;官网只提供tar.gz格式的压缩包，windows下载后按照zip之类的解压方式可能会导致解压后的包无法使用，笔者使用Git带的命令行执行linux的解压命令解压后使用，如果没有安装Git则建议使用虚拟机安装Linux使用。以下是正确解压和错误解压后的对比。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7785516-e98ebe69d955a00a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;正确打开方式&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7785516-0ac7a83dc4d42ff3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;错误打开方式&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;解压后的ZooKeeper默认是无法执行的，需要进行配置，将 &lt;code&gt;apache-zookeeper-3.6.1/conf/zoo_sample.cfg&lt;/code&gt;复制一份并重命名为&lt;code&gt;zoo.cfg&lt;/code&gt;，没什么特殊需要里边的配置项默认即可，笔者因为是在windows下使用，所以将datadir修改了。配置文件项说明如下：&lt;/li&gt;
&lt;/ol&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;配置项&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;5.5&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;code&gt;tickTime&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ZooKeeper使用的时间，单位毫秒，一般用于心跳检测，而ZooKeeper中的最小session超时时间是此项的两倍&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;dataDir&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;保留内存数据库快照的地址，如果不单独指定，事务日志也会记录在此&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;clientPort&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;服务端监听的端口号&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;initLimit&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;集群中的follower服务器与leader服务器之间初始连接时的最大心跳数&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;syncLimit&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;集群中follower服务器与leader服务器之间通讯时的最大心跳数&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;配置完成后即可在bin目录下执行对应的文件启动了，Windows下为&lt;code&gt;zkServer.bat&lt;/code&gt;，Linux下为&lt;code&gt;zkServer.sh&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;zookeeper应用&quot;&gt;ZooKeeper应用&lt;/h2&gt;
&lt;h3 id=&quot;通过zkcli进行使用&quot;&gt;通过zkCli进行使用&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;ZooKeeper启动后，可以通过&lt;code&gt;bin&lt;/code&gt;目录下自带的客户端进行访问，Windows下为&lt;code&gt;zkCli.bat&lt;/code&gt;，Linux下为&lt;code&gt;zkCli.sh&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;启动时默认连接&lt;code&gt;localhost:2181&lt;/code&gt;，如果有需要连接远程或其他端口的情况，可以如下添加参数：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;zkCli.sh -server IP:Port
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot; readability=&quot;-0.7811320754717&quot;&gt;&lt;li readability=&quot;0.76131687242798&quot;&gt;
&lt;p&gt;进入客户端后执行&lt;code&gt;help&lt;/code&gt;(此处是一个随意的指令，只要不是zkCli支持的操作都可以)可查看其支持的操作，关于所有操作的介绍请参考官方页面：&lt;a href=&quot;https://zookeeper.apache.org/doc/current/zookeeperCLI.html&quot;&gt;https://zookeeper.apache.org/doc/current/zookeeperCLI.html&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;常用操作介绍：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;查看节点信息，节点路径不能以“/”结尾&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;ls /
ls /zookeeper
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;创建一个节点&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;create /test
create /test/testa
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;查看节点状态&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;stat /test
stat /test/testa
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;删除节点&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;# 删除单个空节点
delete /test/testa
delete /test

# 级联删除
deleteall /test
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;*退出客户端&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;quit
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;通过zookeeper客户端使用&quot;&gt;通过ZooKeeper客户端使用&lt;/h3&gt;
&lt;p&gt;因为笔者的第一开发语言是Java，这里以Java为例。常用的ZooKeeper Java客户端用zkclient和Apache Curator两种。zkclient是github上的一个开源项目，该项目在2018年10月2日后停止更新；Apache Curator是Apache基金会的开源项目，目前持续更新，推荐使用。常用的分布式RPC框架DUBBO也在2019年1月份推出的2.7.0版本中将默认的ZooKeeper客户端由zkclient切换为Apache Curator，此文中的示例也使用Apache Curator。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;创建一个Maven项目，然后在pom.xml中引用Apache Curator，以下是笔者的文件内容，除了Apache Curator外添加了测试使用的junit并设置了编译使用的java版本。&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;
    &amp;lt;groupId&amp;gt;org.example&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;apache-curator&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;!-- https://mvnrepository.com/artifact/org.apache.curator/curator-recipes --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.apache.curator&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;curator-recipes&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;4.3.0&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!-- https://mvnrepository.com/artifact/org.junit.jupiter/junit-jupiter --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.junit.jupiter&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;junit-jupiter&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;5.6.2&amp;lt;/version&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;

    &amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;maven-compiler-plugin&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;3.8.1&amp;lt;/version&amp;gt;
                &amp;lt;configuration&amp;gt;
                    &amp;lt;source&amp;gt;1.8&amp;lt;/source&amp;gt;
                    &amp;lt;target&amp;gt;1.8&amp;lt;/target&amp;gt;
                    &amp;lt;encoding&amp;gt;UTF-8&amp;lt;/encoding&amp;gt;
                &amp;lt;/configuration&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;
&amp;lt;/project&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;之后在&lt;code&gt;src\test\java\&lt;/code&gt;目录创建&lt;code&gt;com\aotian\curator\test\Tester.java&lt;/code&gt;，文件基本框架如下，主要是创建一个空的测试类&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;public class Tester {

    @Test
    public void testCurator() {
      
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;接下来就是使用Apache Curator提供的API对ZooKeeper进行访问了。首先介绍下常用的API&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;创建客户端&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 3);
CuratorFramework curatorFramework = CuratorFrameworkFactory.newClient(&quot;localhost:2181&quot;, retryPolicy);
curatorFramework.start();
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;检查节点是否存在，存在的话返回&lt;code&gt;Stat&lt;/code&gt;对象，不存在则返回&lt;code&gt;null&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;curatorFramework.checkExists().forPath(&quot;/localhost/aotian&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;创建节点，&lt;code&gt;forPath&lt;/code&gt;第二个参数可以指定节点内容，不设置时创建空节点&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;curatorFramework.create().creatingParentContainersIfNeeded().forPath(&quot;/localhost/aotian&quot;, message.getBytes());
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;设置节点内容，仅适用于已存在的节点，否则会报错&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;curatorFramework.setData().forPath(&quot;/localhost/aotian&quot;, message.getBytes());
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;获取节点信息，以下代码表示将获取的节点信息保存到&lt;code&gt;result&lt;/code&gt;对象。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Stat result = new Stat();
curatorFramework.getData().storingStatIn(result).forPath(&quot;/localhost/aotian&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;获取节点内容&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;byte[] results = curatorFramework.getData().forPath(&quot;/localhost/aotian&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;完整示例如下，结尾添加了线程睡眠的代码，可以在睡眠时间内通过&lt;code&gt;zkCli&lt;/code&gt;查看服务端中的内容。&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    @Test
    public void testCurator() {
        // 创建客户端
        RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 3);
        CuratorFramework curatorFramework = CuratorFrameworkFactory.newClient(&quot;localhost:2181&quot;, retryPolicy);
        curatorFramework.start();
        // 定义节点内容
        String message = &quot;testCurator&quot;;
        try {
            // 判断节点是否存在不存在则创建，存在则设置指定值
            Stat a = curatorFramework.checkExists().forPath(&quot;/localhost/aotian&quot;);
            if (a == null){
                curatorFramework.create()
                        .creatingParentContainersIfNeeded()
                        .forPath(&quot;/localhost/aotian&quot;, message.getBytes());
            }else{
                curatorFramework.setData().forPath(&quot;/localhost/aotian&quot;, message.getBytes());
            }

            // 获取节点信息
            Stat result = new Stat();
            curatorFramework.getData().storingStatIn(result).forPath(&quot;/localhost/aotian&quot;);
            System.out.println(result.getCtime());

            // 获取节点内容
            byte[] results = curatorFramework.getData().forPath(&quot;/localhost/aoitan&quot;);
            System.out.println(new String(results));

            // 线程睡10S，这段时间内可以通过客户端查看节点内的信息，结束后只能查看到空节点
            Thread.sleep(100000);
        } catch (Exception e) {
            e.printStackTrace();
        }finally {
            curatorFramework.close();
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;zookeeper集群搭建&quot;&gt;ZooKeeper集群搭建&lt;/h2&gt;
&lt;p&gt;ZooKeeper集群中包含两种角色：Leader和Follower，因为ZooKeeper集群是半数节以上节点正常时才会正常提供服务，所以一般ZooKeeper集群中节点数量均为奇数。我们按照最小数量算，准备三台zookeeper服务器。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;分别按照本文一开始的单机配置配置好三个ZooKeeper服务。个人联系或可以在同一台机器上部署三个ZooKeeper，只要解决端口冲突问题即可，实际生产过程中务必使用三台机器进行搭建，否则一旦机器出问题则整个集群瘫痪。&lt;/li&gt;
&lt;li&gt;准备好三台ZooKeeper服务器之后我们准备开始集群的配置，首先我们需要规划好ZooKeeper的ID，然后在&lt;code&gt;datadir&lt;/code&gt;属性对应的目录下创建一个&lt;code&gt;myid&lt;/code&gt;文件。然后在文件内写上当前服务对应的ID，笔者规划的是0、1、2，所以我需要添加的配置文件如下：&lt;/li&gt;
&lt;/ol&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;IP地址&lt;/th&gt;
&lt;th&gt;文件路径&lt;/th&gt;
&lt;th&gt;文件内容&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;192.168.142.7&lt;/td&gt;
&lt;td&gt;/tmp/zookeeper/myid&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;192.168.142.8&lt;/td&gt;
&lt;td&gt;/tmp/zookeeper/myid&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;192.168.142.9&lt;/td&gt;
&lt;td&gt;/tmp/zookeeper/myid&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;datadir&lt;/code&gt;属性默认在&lt;code&gt;/tmp&lt;/code&gt;目录下，此目录会被定期清理掉，生产环境不要使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;3、配置完以上文件后，需要配置之前的&lt;code&gt;zoo.cfg&lt;/code&gt;，在最后添加以下内容，其中&lt;code&gt;server.*&lt;/code&gt;对应&lt;code&gt;myid&lt;/code&gt;文件中的ID号，&lt;code&gt;192.168.142.7&lt;/code&gt;是IP地址，&lt;code&gt;2888&lt;/code&gt;是ZooKeeper集群的通讯端口，&lt;code&gt;3888&lt;/code&gt;是集群选取Leader使用的端口。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;server.0=192.168.142.7:2888:3888
server.1=192.168.142.8:2888:3888
server.2=192.168.142.9:2888:3888
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4、最后检查防火墙是否开放了2181、2888、3888端口，确认开放后启动ZooKeeper即可。通过执行&lt;code&gt;zkServer.sh status&lt;/code&gt;命令可以查看当前机器的状态。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@centos-server-01 bin]# ./zkServer.sh status
/usr/bin/java
ZooKeeper JMX enabled by default
Using config: /usr/apache-zookeeper-3.6.0/bin/../conf/zoo.cfg
Client port found: 2181. Client address: localhost.
Mode: follower

[root@centos-server-02 bin]# ./zkServer.sh status
/usr/bin/java
ZooKeeper JMX enabled by default
Using config: /usr/apache-zookeeper-3.6.0/bin/../conf/zoo.cfg
Client port found: 2181. Client address: localhost.
Mode: leader
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 17 Jun 2020 14:58:00 +0000</pubDate>
<dc:creator>☆★傲天★☆</dc:creator>
<og:description>ZooKeeper简介 ZooKeeper是一个分布式的，开源的分布式应用程序协调服务，是Hadoop的子项目之一。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/aotian/p/13155203.html</dc:identifier>
</item>
</channel>
</rss>