<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Java集合类-ArrayList - monkjavaer</title>
<link>http://www.cnblogs.com/tangquanbin/p/10958315.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tangquanbin/p/10958315.html</guid>
<description>&lt;h4 id=&quot;一类继承关系&quot;&gt;一、类继承关系&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;public class ArrayList&amp;lt;E&amp;gt; extends AbstractList&amp;lt;E&amp;gt;
        implements List&amp;lt;E&amp;gt;, RandomAccess, Cloneable, java.io.Serializable&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ArrayList继承AbstractList,也实现了List和RandomAccess(一个空接口，也就是标记接口。)，Cloneable(可被克隆), Serializable接口。&lt;/p&gt;
&lt;h4 id=&quot;二类属性&quot;&gt;二、类属性&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;    //默认容量
    private static final int DEFAULT_CAPACITY = 10;

    //空对象数组(initialCapacity == 0时返回)
    private static final Object[] EMPTY_ELEMENTDATA = {};

    //调用无参构造方法，返回的是该数组
    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};

    //元素数组，保存添加到ArrayList中的元素
    transient Object[] elementData;
    
    //ArrayList大小
    private int size;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;elementData是transient修饰，所以elementData不能被序列化。但是ArrayList又是可以被序列化的，这是为何？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;因为ArrayList有两个方法writeObject、readObject用于序列化和反序列化。elementData是transient修饰是为了避免ArrayList扩容（1.5倍）导致的空间浪费&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;序列化的时候elementData的数据会被写到ObjectOutputStream中&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;private void writeObject(java.io.ObjectOutputStream s)
        throws java.io.IOException{
        // Write out element count, and any hidden stuff
        int expectedModCount = modCount;
        s.defaultWriteObject();

        // Write out size as capacity for behavioural compatibility with clone()
        s.writeInt(size);

        // Write out all elements in the proper order.
        for (int i=0; i&amp;lt;size; i++) {
            s.writeObject(elementData[i]);
        }

        if (modCount != expectedModCount) {
            throw new ConcurrentModificationException();
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;反序列化的时候会从ObjectInputStream读取出来&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;private void readObject(java.io.ObjectInputStream s)
        throws java.io.IOException, ClassNotFoundException {
        elementData = EMPTY_ELEMENTDATA;

        // Read in size, and any hidden stuff
        s.defaultReadObject();

        // Read in capacity
        s.readInt(); // ignored

        if (size &amp;gt; 0) {
            // be like clone(), allocate array based upon size not capacity
            ensureCapacityInternal(size);

            Object[] a = elementData;
            // Read in all elements in the proper order.
            for (int i=0; i&amp;lt;size; i++) {
                a[i] = s.readObject();
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;三构造函数&quot;&gt;三、构造函数&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;指定容量&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;    public ArrayList(int initialCapacity) {
        if (initialCapacity &amp;gt; 0) {
            this.elementData = new Object[initialCapacity];
        } else if (initialCapacity == 0) {
            //空对象数组
            this.elementData = EMPTY_ELEMENTDATA;
        } else {
            throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+
                                               initialCapacity);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;    public ArrayList() {
        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;ArrayList(Collection&amp;lt;? extends E&amp;gt; c)&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;    public ArrayList(Collection&amp;lt;? extends E&amp;gt; c) {
        elementData = c.toArray();
        if ((size = elementData.length) != 0) {
            if (elementData.getClass() != Object[].class)
                elementData = Arrays.copyOf(elementData, size, Object[].class);
        } else {
            //空对象数组
            this.elementData = EMPTY_ELEMENTDATA;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;四arraylist如何扩容&quot;&gt;四、ArrayList如何扩容&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;    public boolean add(E e) {
        //确保elementData数组的大小
        ensureCapacityInternal(size + 1);
        //在结尾处添加元素
        elementData[size++] = e;
        return true;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面是add(E e)方法的源码，在添加元素前会调用 ensureCapacityInternal(size + 1);确保elementData数组的大小。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    private void ensureCapacityInternal(int minCapacity) {
        // 判断元素数组是否为空数组
        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
            //minCapacity最少=DEFAULT_CAPACITY=10
            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);
        }

        ensureExplicitCapacity(minCapacity);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;其中ensureCapacityInternal的源码片段首先判断elementData是否为无参构造器的空数组，如果是的话，Math.max（）取较大值赋值给minCapacity，最小是10（默认容量）。然后，调用ensureExplicitCapacity：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;    private void ensureExplicitCapacity(int minCapacity) {
        // List结构性修改加1
        modCount++;
        //minCapacity大于elementData数组长度
        if (minCapacity - elementData.length &amp;gt; 0)
            //增长
            grow(minCapacity);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;ensureExplicitCapacity中modCount记录List结构性变化次数（结构性变化，在迭代的过程中可能会造成错误结果）。&lt;/li&gt;
&lt;li&gt;紧接着，如果minCapacity大于elementData数组长度则调用 grow(minCapacity)增长函数&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;    
    private void grow(int minCapacity) {
        // overflow-conscious code
        int oldCapacity = elementData.length;
        //oldCapacity &amp;gt;&amp;gt; 1右移一位，这里相当于扩容1.5倍
        int newCapacity = oldCapacity + (oldCapacity &amp;gt;&amp;gt; 1);
        if (newCapacity - minCapacity &amp;lt; 0)
            newCapacity = minCapacity;
        if (newCapacity - MAX_ARRAY_SIZE &amp;gt; 0)
            newCapacity = hugeCapacity(minCapacity);
        // minCapacity is usually close to size, so this is a win:
        elementData = Arrays.copyOf(elementData, newCapacity);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的扩容方法中 &lt;strong&gt;oldCapacity &amp;gt;&amp;gt; 1&lt;/strong&gt; 表明elementData.length右移一位，扩容后的容量为原始容量的1.5倍&lt;/p&gt;
&lt;h4 id=&quot;五主要函数&quot;&gt;五、主要函数&lt;/h4&gt;
&lt;h5 id=&quot;remove函数&quot;&gt;remove()函数&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;    public E remove(int index) {
        rangeCheck(index);

        modCount++;
        E oldValue = elementData(index);
        //需要移动的元素个数
        int numMoved = size - index - 1;
        //删除的不是最后一个元素
        if (numMoved &amp;gt; 0)
            //index后的元素都向前移动一位
            System.arraycopy(elementData, index+1, elementData, index, numMoved);
        //size减一，释放引用，方便垃圾回收器进行垃圾回收
        elementData[--size] = null; // clear to let GC do its work

        return oldValue;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例如要删除集合中的“a”&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        Iterator&amp;lt;String&amp;gt; iterator = list.iterator();
        while (iterator.hasNext()){
            if (&quot;a&quot;.equals(iterator.next())) {
                iterator.remove();
            }
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者使用lambda表达式&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;list.removeIf(&quot;x&quot;::equals);&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;set函数会替换新值返回旧值&quot;&gt;set()函数,会替换新值，返回旧值。&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;    public E set(int index, E element) {
        //检查索引
        rangeCheck(index);

        E oldValue = elementData(index);
        elementData[index] = element;
        //返回旧值
        return oldValue;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;get函数获取元素&quot;&gt;get()函数，获取元素&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;    public E get(int index) {
        rangeCheck(index);

        return elementData(index);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;六arraylist性能相关&quot;&gt;六、ArrayList性能相关&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;在能够确定ArrayList容量大小的情况下尽量预估容量，调用构造器public ArrayList(int initialCapacity)指定大小，避免因为自动扩容带来的性能开销。&lt;/li&gt;
&lt;li&gt;使用trimToSize()使ArrayList的内部数组大小减少为实际大小，以此节省空间&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;    public void trimToSize() {
        modCount++;
        if (size &amp;lt; elementData.length) {
            elementData = (size == 0)
              ? EMPTY_ELEMENTDATA
              : Arrays.copyOf(elementData, size);
        }
    }&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 31 May 2019 23:10:00 +0000</pubDate>
<dc:creator>monkjavaer</dc:creator>
<og:description>一、类继承关系 ArrayList继承AbstractList,也实现了List和RandomAccess(一个空接口，也就是标记接口。)，Cloneable(可被克隆), Serializable接</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tangquanbin/p/10958315.html</dc:identifier>
</item>
<item>
<title>Spring IOC源码分析之-刷新前的准备工作 - c旋儿</title>
<link>http://www.cnblogs.com/cxuanBlog/p/10958307.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cxuanBlog/p/10958307.html</guid>
<description>&lt;h2 id=&quot;classpathxmlapplicationcontext的注册方式&quot;&gt;ClassPathXmlApplicationContext的注册方式&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;源码分析基于Spring4.3&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从&lt;code&gt;ClassPathXmlApplicationContext&lt;/code&gt;入口，最终都会调用到&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/*
     * 使用给定父级创建新的ClassPathXmlApplicationContext，从给定的XML文件加载定义信息。
     * 加载所有的bean 定义信息并且创建所有的单例
     * 或者，在进一步配置上下文之后手动调用刷新。
*/
public ClassPathXmlApplicationContext(String[] configLocations, boolean refresh, ApplicationContext parent)
  throws BeansException {

  super(parent);
  setConfigLocations(configLocations);
  if (refresh) {
    refresh();
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;上述注释的解释如是说：在容器的启动过程中，初始化过程中所有的bean都是单例存在的&lt;/p&gt;
&lt;p&gt;&lt;code&gt;自动刷新&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;ApplicationContext context = new ClassPathXmlApplicationContext(&quot;xxx.xml&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就等同于&lt;/p&gt;
&lt;p&gt;&lt;code&gt;手动刷新&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;ApplicationContext context = new ClassPathXmlApplicationContext();
context.register(&quot;xxx.xml&quot;);
context.refresh()；&lt;/code&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;上述一共有三条链路，下面来一一分析&lt;/p&gt;
&lt;h3 id=&quot;加载父子容器&quot;&gt;加载父子容器&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;首先是加载并初始化父容器的方法&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1515111/201906/1515111-20190601055125992-1094249825.png&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;第一个出场的是&lt;code&gt;ClassPathXmlApplicationContext&lt;/code&gt;，它是一个独立的应用程序上下文，从类路径获取上下文定义文件，能够将普通路径解析为包含包路径的类路径资源名称。它可以支持Ant-Style(路径匹配原则)，它是一站式应用程序的上下文，考虑使用GenericApplicationContext类结合XmlBeanDefinitionReader来设置更灵活的上下文配置。&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;Ant-Style 路径匹配原则，例如 &quot;mypackages/application-context.xml&quot; 可以用&quot;mypackages/*-context.xml&quot; 来替换。&lt;/p&gt;
&lt;p&gt;⚠️注意： 如果有多个上下文配置，那么之后的bean定义将覆盖之前加载的文件。这可以用来通过额外的XML文件故意覆盖某些bean定义&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;随后不紧不慢走过来的不是一个完整的somebody，&lt;code&gt;AbstractXmlApplicationContext&lt;/code&gt;, 它是为了方便ApplicationContext的实现而出现的(抽象类一个很重要的思想就是适配)。AbstractXmlApplicationContext 的最主要作用就是通过创建一个XML阅读器解析ClassPathXmlApplicationContext 注册的配置文件。它有两个最主要的方法 &lt;strong&gt;loadBeanDefinitions(DefaultListableBeanFactory beanFactory)&lt;/strong&gt; 和 &lt;strong&gt;loadBeanDefinitions(XmlBeanDefinitionReader reader)&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;下一个缓缓出场的是 &lt;code&gt;AbstractRefreshableConfigApplicationContext&lt;/code&gt; ，它就像是中间人的角色，并不作多少工作，很像古代丞相的奏折要呈递给皇上，它的作用就相当于是拿奏折的角色。它用作XML应用程序上下文实现的基类，例如ClassPathXmlApplicationContext、FileSystemXmlApplicationContext和XmlWebApplicationContext&lt;/li&gt;
&lt;li&gt;当老板的一般都比较听小秘的，那么&lt;code&gt;AbstractRefreshableApplicationContext&lt;/code&gt;就扮演了小秘的角色，它是ApplicationContext的基类，支持多次调用refresh()方法，每次都会创建一个新的内部bean factory实例。继承 AbstractRefreshableApplicationContext 需要唯一实现的方法就是&lt;strong&gt;loadBeanDefinitions&lt;/strong&gt;，在每一次调用刷新方法的时候。一个具体的实现是加载bean定义信息的&lt;strong&gt;DefaultListableBeanFactory&lt;/strong&gt;。&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;但是只有小秘给老板递交请辞不行，中间还要有技术leader 来纵览大局，向上与老板探讨公司发展计划，在下领导新人做项目打硬仗(这种男人真的很有魅力哈哈哈)，但是技术leader也不能干完所有的工作，他还需要交给手下的程序员去帮他完成具体的工作，程序员接到一项工作，看看有没有可复用的项目和开源类库，发现有可用的，直接把&quot;引用&quot;链接过去就可以了。这就是容器的初始化工作，但是这一步的流程还没有结束，你还得时刻记住你是给boss干活的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public AbstractApplicationContext(@Nullable ApplicationContext parent) {
  // 交给其他程序员去完成的工作
  this();
  // 明确自己的老板是谁
  setParent(parent);
}

public AbstractApplicationContext() {
  this.resourcePatternResolver = getResourcePatternResolver();
}

// 返回 ResourcePatternResolver 去解析资源实例中的匹配模式，默认的是 PathMatchingResourcePatternResolver 支持 Ant-Style 模式。
protected ResourcePatternResolver getResourcePatternResolver() {
  return new PathMatchingResourcePatternResolver(this);
}

// 此时的resourceLoader 就是ClassPathXmlApplicationContext 对象。
public PathMatchingResourcePatternResolver(ResourceLoader resourceLoader) {
  Assert.notNull(resourceLoader, &quot;ResourceLoader must not be null&quot;);
  this.resourceLoader = resourceLoader;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你需要一些程序员帮你做具体的编码工作，也需要明确你是公司的员工，需要听从老板的，所以你需要明确老板是谁&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Override
public void setParent(@Nullable ApplicationContext parent) {
  this.parent = parent;
  if (parent != null) {
    Environment parentEnvironment = parent.getEnvironment();
    if (parentEnvironment instanceof ConfigurableEnvironment) {
      getEnvironment().merge((ConfigurableEnvironment) parentEnvironment);
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是这个时候老板出差了，不在了(因为传过来的parent 是 null)，所以你需要自己做一些decision。至此，第一条线路就分析完成了。&lt;/p&gt;
&lt;h3 id=&quot;配置路径解析&quot;&gt;配置路径解析&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;第二条线路，&lt;code&gt;ApplicationContext&lt;/code&gt;中的 setConfigLocations(configLocations)&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 参数传过来的是可变参数，可变参数是一个数组，也就是说，你可以传递多个配置文件，用&quot;,&quot;分隔起来。
public void setConfigLocations(@Nullable String... locations) {
  if (locations != null) {
    Assert.noNullElements(locations, &quot;Config locations must not be null&quot;);
    // configlocations 是一个可为空的String数组，可以为null，为null可以进行手动注册。
    this.configLocations = new String[locations.length];
    // 解析数组中的每一个配置文件的路径。
    for (int i = 0; i &amp;lt; locations.length; i++) {
      this.configLocations[i] = resolvePath(locations[i]).trim();
    }
  }
  // 默认是直接创建了一个 ClassPathXmlApplicationContext 的无参数的构造函数，采用手动注册的方式。
  else {
    this.configLocations = null;
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关键点：路径解析方法 : &lt;code&gt;AbstractRefreshableConfigApplicationContext&lt;/code&gt; 中的 resolvePath(locations[i]).trim(); 来看看是如何进行路径解析的&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 解析给定的路径，必要时用相应的环境属性值替换占位符。应用于路径配置。
protected String resolvePath(String path) {
  return getEnvironment().resolveRequiredPlaceholders(path);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;涉及两个方法，AbstractRefreshableConfigApplicationContext 中的&lt;strong&gt;getEnvironment() 和 validateRequiredProperties()&lt;/strong&gt;，先来看第一个&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;getEnvironment()&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 以配置的形式返回此应用程序上下文的Environment，来进一步自定义
// 如果没有指定，则通过初始化默认的环境。
@Override
public ConfigurableEnvironment getEnvironment() {
  if (this.environment == null) {
    // 使用默认的环境配置
    this.environment = createEnvironment();
  }
  return this.environment;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;下面来看一下&lt;strong&gt;createEnvironment()&lt;/strong&gt;如何初始化默认的环境：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 创建并返回一个 StandardEnvironment，子类重写这个方法为了提供
// 一个自定义的 ConfigurableEnvironment 实现。
protected ConfigurableEnvironment createEnvironment() {
        // StandardEnvironment 继承AbstractEnvironment，而AbstractEnvironment
        // 实现了ConfigurableEnvironment
        return new StandardEnvironment();
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实很简单，也只是new 了一个StandardEnvironment() 的构造器而已。StandardEnvironment是什么？&lt;strong&gt;非web应用程序的Environment 的标准实现。&lt;/strong&gt;他实现了AbstractEnvironment 抽象类，下面是具体的继承树：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1515111/201906/1515111-20190601055152748-154414390.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;StandardEnvironment是AbstractEnvironment的具体实现，而AbstractEnvironment又是继承了ConfigurableEnvironment接口，提供了某些方法的具体实现，ConnfigurableEnvironment 继承了Environment，而Environment 和 ConfigurablePropertyResolver 同时继承了PropertyResolver&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;下面来看一下StandardEnvironment() 的源码：

public class StandardEnvironment extends AbstractEnvironment {

  // 系统属性资源名称
    public static final String SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME = &quot;systemEnvironment&quot;;

  // JVM系统属性资源名：
    public static final String SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME = &quot;systemProperties&quot;;

  //为标准的Java 环境 自定义合适的属性文件
    @Override
    protected void customizePropertySources(MutablePropertySources propertySources) {
        propertySources.addLast(new MapPropertySource(SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME, getSystemProperties()));
        propertySources.addLast(new SystemEnvironmentPropertySource(SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME, getSystemEnvironment()));
    }

}


现在读者就会产生疑问，不是说new出来一个标准的StandardEnvironment 实现吗，但是StandardEnvironment并没有默认的构造方法啊？这是什么回事呢？

其实StandardEnvironment 的构造方法是 AbstractEnvironment：

public AbstractEnvironment() {
  // 实现自定义属性资源的方法，也就是StandardEnvironment中customizePropertySources()
  customizePropertySources(this.propertySources);
  if (logger.isDebugEnabled()) {
    logger.debug(&quot;Initialized &quot; + getClass().getSimpleName() + &quot; with PropertySources &quot; + this.propertySources);
  }
}


上述的`customizePropertySources` 由`StandardEnvironment` 来实现，具体如下

@Override
protected void customizePropertySources(MutablePropertySources propertySources) {
  propertySources.addLast(new MapPropertySource(SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME, getSystemProperties()));
  propertySources.addLast(new SystemEnvironmentPropertySource(SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME, getSystemEnvironment()));
}


由于容器在刚起步的时候 propertySources 是null，所以添加完系统环境(systemEnvironment)和系统属性(systemProperties) 之后，会变成下图所示&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li readability=&quot;-0.5&quot;&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1515111/201906/1515111-20190601055216870-397113268.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;如何获取系统属性和如何获取系统环境没有往下跟，有兴趣的读者可以继续沿用。&lt;/p&gt;
&lt;p&gt;大致截一个图，里面大概的属性是这样&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;systemProperties&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1515111/201906/1515111-20190601055235642-847430990.png&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;systemEnvironment&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1515111/201906/1515111-20190601055247169-553441345.png&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;另外一个是 &lt;strong&gt;resolveRequiredPlaceholders&lt;/strong&gt;，它是由 &lt;code&gt;PropertyResolver&lt;/code&gt; 超顶级接口定义的方法&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 在给定的text 参数中解析${} 占位符，将其替换为getProperty 解析的相应属性值。
// 没有默认值的无法解析的占位符将导致抛出IllegalArgumentException。
String resolveRequiredPlaceholders(String text) throws IllegalArgumentException;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;25.5&quot;&gt;&lt;li readability=&quot;56.5&quot;&gt;
&lt;ul&gt;&lt;li&gt;由 &lt;code&gt;AbstractPropertyResolver&lt;/code&gt; 子类来实现，且看&lt;code&gt;AbstractPropertyResolver&lt;/code&gt; 的继承树&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;-&lt;img src=&quot;https://img2018.cnblogs.com/blog/1515111/201906/1515111-20190601055300019-1753152531.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;具体实现的方法如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 传递进来的文本就是解析过的 配置文件 SimpleName
@Override
public String resolveRequiredPlaceholders(String text) throws IllegalArgumentException {
  if (this.strictHelper == null) {
    this.strictHelper = createPlaceholderHelper(false);
  }
  return doResolvePlaceholders(text, this.strictHelper);
}

// 调用createPlaceholderHelper
private PropertyPlaceholderHelper createPlaceholderHelper(boolean ignoreUnresolvablePlaceholders) {
        return new PropertyPlaceholderHelper(this.placeholderPrefix, this.placeholderSuffix,
                this.valueSeparator, ignoreUnresolvablePlaceholders);
}

----------------------------PropertyPlaceholderHelper-------------------------------

  // PropertyPlaceholderHelper加载的时候会把下面的特殊字符放进去
  static {
        wellKnownSimplePrefixes.put(&quot;}&quot;, &quot;{&quot;);
        wellKnownSimplePrefixes.put(&quot;]&quot;, &quot;[&quot;);
        wellKnownSimplePrefixes.put(&quot;)&quot;, &quot;(&quot;);
    }

/*
    创建一个新的 PropertyPlaceholderHelper 使用提供的前缀 和 后缀
     * 参数解释：placeholderPrefix 占位符开头的前缀
     *         placeholderSuffix 占位符结尾的后缀
     *         valueSeparator 占位符变量和关联的默认值 之间的分隔符
     *         ignoreUnresolvablePlaceholders 指示是否应忽略不可解析的占位符。
*/

public PropertyPlaceholderHelper(String placeholderPrefix, String placeholderSuffix,
                                 @Nullable String valueSeparator, boolean ignoreUnresolvablePlaceholders) {

  Assert.notNull(placeholderPrefix, &quot;'placeholderPrefix' must not be null&quot;);
  Assert.notNull(placeholderSuffix, &quot;'placeholderSuffix' must not be null&quot;);
  this.placeholderPrefix = placeholderPrefix;
  this.placeholderSuffix = placeholderSuffix;
  String simplePrefixForSuffix = wellKnownSimplePrefixes.get(this.placeholderSuffix);
  if (simplePrefixForSuffix != null &amp;amp;&amp;amp; this.placeholderPrefix.endsWith(simplePrefixForSuffix)) {
    this.simplePrefix = simplePrefixForSuffix;
  }
  else {
    this.simplePrefix = this.placeholderPrefix;
  }
  this.valueSeparator = valueSeparator;
  this.ignoreUnresolvablePlaceholders = ignoreUnresolvablePlaceholders;
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解析完成占位符之后，需要做真正的解析，调用&lt;code&gt;AbstractPropertyResolver&lt;/code&gt;中的doResolvePlaceholders 方法。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private String doResolvePlaceholders(String text, PropertyPlaceholderHelper helper) {
  return helper.replacePlaceholders(text, new PropertyPlaceholderHelper.PlaceholderResolver() {
    @Override
    public String resolvePlaceholder(String placeholderName) {
      return getPropertyAsRawString(placeholderName);
    }
  });
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;PlaceholderResolver&lt;/code&gt; 是 PropertyPlaceholderHelper类的内部类，这是一种匿名内部类的写法，它真正调用的就是 &lt;code&gt;PropertyPlaceholderHelper&lt;/code&gt;中的 replacePlaceholders 方法，具体如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 将格式为 ${name} 的占位符替换为从提供 PlaceholderResolver 返回的值。
public String replacePlaceholders(String value, PlaceholderResolver placeholderResolver) {
  Assert.notNull(value, &quot;'value' must not be null&quot;);
  return parseStringValue(value, placeholderResolver, new HashSet&amp;lt;String&amp;gt;());
}


protected String parseStringValue(
            String value, PlaceholderResolver placeholderResolver, Set&amp;lt;String&amp;gt; visitedPlaceholders) {

        StringBuilder result = new StringBuilder(value);

        int startIndex = value.indexOf(this.placeholderPrefix);

    // 判断指定的占位符有无 ${ 存在，没有的话直接返回
        while (startIndex != -1) {
            int endIndex = findPlaceholderEndIndex(result, startIndex);
            if (endIndex != -1) {
                String placeholder = result.substring(startIndex + this.placeholderPrefix.length(), endIndex);
                String originalPlaceholder = placeholder;
                if (!visitedPlaceholders.add(originalPlaceholder)) {
                    throw new IllegalArgumentException(
                            &quot;Circular placeholder reference '&quot; + originalPlaceholder + &quot;' in property definitions&quot;);
                }
                // Recursive invocation, parsing placeholders contained in the placeholder key.
                placeholder = parseStringValue(placeholder, placeholderResolver, visitedPlaceholders);
                // Now obtain the value for the fully resolved key...
                String propVal = placeholderResolver.resolvePlaceholder(placeholder);
                if (propVal == null &amp;amp;&amp;amp; this.valueSeparator != null) {
                    int separatorIndex = placeholder.indexOf(this.valueSeparator);
                    if (separatorIndex != -1) {
                        String actualPlaceholder = placeholder.substring(0, separatorIndex);
                        String defaultValue = placeholder.substring(separatorIndex + this.valueSeparator.length());
                        propVal = placeholderResolver.resolvePlaceholder(actualPlaceholder);
                        if (propVal == null) {
                            propVal = defaultValue;
                        }
                    }
                }
                if (propVal != null) {
                    // Recursive invocation, parsing placeholders contained in the
                    // previously resolved placeholder value.
                    propVal = parseStringValue(propVal, placeholderResolver, visitedPlaceholders);
                    result.replace(startIndex, endIndex + this.placeholderSuffix.length(), propVal);
                    if (logger.isTraceEnabled()) {
                        logger.trace(&quot;Resolved placeholder '&quot; + placeholder + &quot;'&quot;);
                    }
                    startIndex = result.indexOf(this.placeholderPrefix, startIndex + propVal.length());
                }
                else if (this.ignoreUnresolvablePlaceholders) {
                    // Proceed with unprocessed value.
                    startIndex = result.indexOf(this.placeholderPrefix, endIndex + this.placeholderSuffix.length());
                }
                else {
                    throw new IllegalArgumentException(&quot;Could not resolve placeholder '&quot; +
                            placeholder + &quot;'&quot; + &quot; in value \&quot;&quot; + value + &quot;\&quot;&quot;);
                }
                visitedPlaceholders.remove(originalPlaceholder);
            }
            else {
                startIndex = -1;
            }
        }

        return result.toString();
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;直白一点，上述过程就是用来判断有没有 ${ 这个占位符，如果有的话就进入下面的判断逻辑，把${}&lt;/p&gt;
&lt;p&gt;中的值替换为 PlaceholderResolver 返回的值，如果没有的话，就直接返回。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;容器刷新&quot;&gt;容器刷新&lt;/h2&gt;
&lt;p&gt;​ 在经过上述的准备工作完成后，接下来就是整个IOC，DI和AOP的核心步骤了，也是Spring框架的灵魂。由于源码太多，设计范围太广，&lt;strong&gt;本篇只分析刷新预处理应该做的事&lt;/strong&gt;：我们都知道，无论你加载的是哪一种上下文环境，最终都会调用 &lt;code&gt;AbstractApplicationContext&lt;/code&gt; 的refresh()方法，此方法是一切加载、解析、注册、销毁的核心方法，采用了工厂的设计思想。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 完成IoC容器的创建及初始化工作
    @Override
    public void refresh() throws BeansException, IllegalStateException {
        synchronized (this.startupShutdownMonitor) {
      
      // 1： 刷新前的准备工作。
            prepareRefresh();

            // 告诉子类刷新内部bean 工厂。
      //  2：创建IoC容器（DefaultListableBeanFactory）,加载解析XML文件（最终存储到Document对象中）
      // 读取Document对象，并完成BeanDefinition的加载和注册工作
            ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

      //  3： 对IoC容器进行一些预处理（设置一些公共属性）
            prepareBeanFactory(beanFactory);

            try {
    
                //  4:  允许在上下文子类中对bean工厂进行后处理。
                                postProcessBeanFactory(beanFactory);

                //  5： 调用BeanFactoryPostProcessor后置处理器对BeanDefinition处理
                invokeBeanFactoryPostProcessors(beanFactory);

                //  6： 注册BeanPostProcessor后置处理器
                registerBeanPostProcessors(beanFactory);

                //  7： 初始化一些消息源（比如处理国际化的i18n等消息源）
                initMessageSource();

                //  8： 初始化应用事件多播器
                initApplicationEventMulticaster();
        
                //  9： 初始化一些特殊的bean
                onRefresh();

                //  10： 注册一些监听器
                registerListeners();

                //  11： 实例化剩余的单例bean（非懒加载方式）
        //      注意事项：Bean的IoC、DI和AOP都是发生在此步骤
                finishBeanFactoryInitialization(beanFactory);

                //  12： 完成刷新时，需要发布对应的事件
                finishRefresh();
            }

            catch (BeansException ex) {
                if (logger.isWarnEnabled()) {
                    logger.warn(&quot;Exception encountered during context initialization - &quot; +
                            &quot;cancelling refresh attempt: &quot; + ex);
                }

                // 销毁已经创建的单例避免占用资源
                destroyBeans();

                // 重置'active' 标签。
                cancelRefresh(ex);

                // 传播异常给调用者
                throw ex;
            }

            finally {

                // 重置Spring核心中的常见内省缓存，因为我们可能不再需要单例bean的元数据了...
                resetCommonCaches();
            }
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;刷新容器之刷新预处理&quot;&gt;刷新容器之刷新预处理&lt;/h3&gt;
&lt;p&gt;​ 此步骤的主要作用在于：准备刷新的上下文，设置启动的时间和active的标志作为扮演属性资源初始化的角色。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;protected void prepareRefresh() {
        this.startupDate = System.currentTimeMillis();
        this.closed.set(false);
        this.active.set(true);

        if (logger.isInfoEnabled()) {
            logger.info(&quot;Refreshing &quot; + this);
        }

        // 初始化environment 上下文中的占位符属性资源
        initPropertySources();
        // 验证标记为必需的所有属性是否可解析
        getEnvironment().validateRequiredProperties();

        // 允许收集早期的ApplicationEvents
        this.earlyApplicationEvents = new LinkedHashSet&amp;lt;&amp;gt;();
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里面有两处代码需要说明：&lt;code&gt;initPropertySources&lt;/code&gt;这个方法是需要子类进行实现的，默认是不会做任何事情的；&lt;code&gt;getEnvironment()&lt;/code&gt; 这个方法由于上述的源码分析过程中，已经默认创建了 &lt;strong&gt;createEnvironment&lt;/strong&gt;,所以这段代码是直接返回的&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Override
public ConfigurableEnvironment getEnvironment() {
  if (this.environment == null) {
    this.environment = createEnvironment();
  }
  return this.environment;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面只剩下了&lt;strong&gt;validateRequiredProperties()&lt;/strong&gt;的分析，不着急，看源码不能着急，要怀着这个世界很美好的心情去看。&lt;/p&gt;
&lt;p&gt;首先在 &lt;code&gt;ConfigurablePropertyResolver&lt;/code&gt; 接口中定义了 &lt;strong&gt;validateRequiredProperties&lt;/strong&gt; 方法&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 验证每一个被setRequiredProperties 设置的属性存在并且解析非空值，会抛出
// MissingRequiredPropertiesException 异常如果任何一个需要的属性没有被解析。
void validateRequiredProperties() throws MissingRequiredPropertiesException;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在抽象子类AbstractPropertyResolver 中被重写&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Override
public void validateRequiredProperties() {
  // 属性找不到抛出异常的对象
  MissingRequiredPropertiesException ex = new MissingRequiredPropertiesException();
  for (String key : this.requiredProperties) {
    if (this.getProperty(key) == null) {
      ex.addMissingRequiredProperty(key);
    }
  }
  if (!ex.getMissingRequiredProperties().isEmpty()) {
    throw ex;
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为在我们的源码分析中，没有看到任何操作是在对 requiredProperties 进行添加操作，也就是如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Override
public void setRequiredProperties(String... requiredProperties) {
  if (requiredProperties != null) {
    for (String key : requiredProperties) {
      this.requiredProperties.add(key);
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以，此时的 requiredProperties 这个set集合是null， 也就不存在没有解析的元素了。&lt;/p&gt;
&lt;p&gt;本篇到此就结束了，下一篇文章会进行源码分析的下一个步骤： &lt;strong&gt;创建IOC容器以及Bean的解析&lt;/strong&gt;。&lt;/p&gt;
</description>
<pubDate>Fri, 31 May 2019 21:54:00 +0000</pubDate>
<dc:creator>c旋儿</dc:creator>
<og:description>[TOC] ClassPathXmlApplicationContext的注册方式 源码分析基于Spring4.3 从 入口，最终都会调用到 上述注释的解释如是说：在容器的启动过程中，初始化过程中所有</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cxuanBlog/p/10958307.html</dc:identifier>
</item>
<item>
<title>鸟哥的Linux私房菜笔记第六章 - Johnson木木</title>
<link>http://www.cnblogs.com/Johnson-lin/p/10935051.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Johnson-lin/p/10935051.html</guid>
<description>&lt;h2 id=&quot;相对路径与绝对路径&quot;&gt;相对路径与绝对路径&lt;/h2&gt;
&lt;p&gt;上一章简单的提到绝对路径和相对路径&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;绝对路径：路径的写法一定是由根目录（/）写起的，例如：/home/user 这个目录&lt;br/&gt;相对路径：路径的写法不是由根目录（/）写起，例如：我当前所在目录 /home/user，我要切换到/home/user2 目录下。那么写法就是 cd ../user2，其实相对路径指的意思是：相对于当前目录的路径。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;目录的相关操作&quot;&gt;目录的相关操作&lt;/h2&gt;
&lt;h3 id=&quot;特殊的目录&quot;&gt;特殊的目录：&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;.   //代表当前目录
..  //代表上一次目录
-   //代表前一个工作目录（其实就是上一个操作的目录）
~   //代表当前用户的家目录，例如当前用户是user，那么user的家目录就是在/home/user下
~username   //代表用户名为username的用户的家目录。&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;常见的处理目录的指令&quot;&gt;常见的处理目录的指令&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;cd     //切换目录
pwd    //显示当前目录
mkdir  //创建目录
rmdir  //删除空目录，注意是空目录！不空的目录后面再讲&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;简单指令用法如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cd /home/user //使用绝对路径切换目录
pwd           //显示当前所在目录，只会显示绝对路径
mkdir dir     //创建一个名为dir的目录（可以理解为文件夹）
rmdir dir     //删除一个名为dir的空目录&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;执行文件路径变量path&quot;&gt;执行文件路径变量：$PATH&lt;/h2&gt;
&lt;p&gt;ls为查阅文件属性的指令，起对应完整文件名为：/bin/ls（这是绝对路径），那么为什么我们输入ls就会执行/bin/ls这个指令呢？这是因为环境变量PATH所致的。相当于我们Window下的环境变量path。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;echo $PATH   //打印PATH变量，$号后面接的是变量。
/home/vagrant/bin:/home/vagrant/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到每个目录中间用冒号（:）来隔开，每个目录都会有顺序之分。我们之所以可以执行ls命令，那是因为ls指令存在/bin目录下，我们可以看到$PATH有/bin这个目录，所以ls指令就可以直接执行啦。&lt;br/&gt;例举常用添加环境变量的两种方式，需要把/home/vagrant添加到环境变量：&lt;br/&gt;1.只对当前用户生效：&lt;br/&gt;修改家目录下的 .bashrc文件，然后在文件的最下方加入：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;export PATH=/home/vagrant:$PATH
///保存后执行
source ~/.bashrc&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.修改/etc/environment文件，直接使用vim命令在后面添加就可以了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cat /etc/environment //查看该文件
PATH=&quot;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games&quot;&lt;/code&gt;
&lt;/pre&gt;


&lt;p&gt;文件与目录的管理，其实主要就是显示属性、复制、删除、移动等操作。&lt;br/&gt;选项：&lt;/p&gt;
&lt;h2 id=&quot;文件与目录的查看ls&quot;&gt;文件与目录的查看：ls&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;ls&lt;/code&gt;可以说是最常用的指令了，而&lt;code&gt;ls&lt;/code&gt;指令一些常用的选项如下：&lt;br/&gt;-a : 列出全部文件，包括隐藏文件（开头为 . 的文件）&lt;br/&gt;-d : 仅列出目录本身，而不列出目录内的文件数据&lt;br/&gt;-l : 列出的文件或目录，一个占一行，并且显示文件的属性、权限等等数据。&lt;br/&gt;使用方式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ls -[options]&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;复制删除与移动cprmmv&quot;&gt;复制、删除与移动：cp,rm,mv&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;cp（复制文件或目录）&lt;/strong&gt;&lt;br/&gt;&lt;code&gt;cp&lt;/code&gt;指令也非常重要，因为我们也经常进行文件的复制，所以也会常常用到这个指令。如果要去复制别人的文件，我们必须有read（读）权限。一般来说复制别人的文件后，该文件的拥有者就会变成自己的啦。&lt;br/&gt;常用选项：&lt;br/&gt;-i : 若文件已经存在时，询问是否需要覆盖文件。&lt;br/&gt;-p : 把文件的属性（权限、用户、时间）一起复制过去。&lt;br/&gt;-r ：递归复制，例如复制非空的目录，就需要使用这个指令啦。&lt;/p&gt;
&lt;p&gt;使用方式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cp [-options] 源文件 目标文件
cp -i /usr/bin /tmp/bin //例子&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;rm（移除文件和目录）&lt;/strong&gt;&lt;br/&gt;选项：&lt;br/&gt;-f : 忽略不存在的文件，不会出现警告信息&lt;br/&gt;-i : 执行删除动作时会询问你是否真的需要删除&lt;br/&gt;-r : 递归删除，常用在目录的删除上，使用这命令要再三确认啊。危险！&lt;/p&gt;
&lt;p&gt;使用方式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;rm [-options] 文件或目录&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;mv（移动/更名 文件或目录）&lt;/strong&gt;&lt;br/&gt;相似于window下的剪切和重命名操作。&lt;br/&gt;选项：&lt;br/&gt;-f ：如果文件已存在，不会询问而只是直接覆盖。&lt;br/&gt;-i ：如果文件已存在，则会询问是否需要覆盖。&lt;br/&gt;-u ：如果文件已存在，且复制的文件比已存在的文件新，就会覆盖。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mv -[options] 源文件 目标文件
mv /home/vagrant /tmp/vg  //此命令就会把home下vagrant目录移动到tmp目录下，并且改名为vg啦。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;扩展：其实更名还有一个命令，叫做rename。需要详细了解的话可以 man rename看一看。&lt;/p&gt;
</description>
<pubDate>Fri, 31 May 2019 17:04:00 +0000</pubDate>
<dc:creator>Johnson木木</dc:creator>
<og:description>[toc] 目录与路径 相对路径与绝对路径 上一章简单的提到绝对路径和相对路径 绝对路径：路径的写法一定是由根目录（/）写起的，例如：/home/user 这个目录 相对路径：路径的写法不是由根目录（</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Johnson-lin/p/10935051.html</dc:identifier>
</item>
<item>
<title>分布式事务一致性问题 - junxing</title>
<link>http://www.cnblogs.com/junxing/p/10958200.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/junxing/p/10958200.html</guid>
<description>[unable to retrieve full-text content]1、事务一致性： 分布式系统中通过事务管理器或者协调器保证对数据操作前和操作后达到一致性状态，比较常见的跨行转账 一致性包括： a、强一致性：保证多个数据节点间数据完全一致，数据写入状态和读出的状态完全一致 b、弱一致性：系统在写入后，不保证能够立即读到最新的值，尽可能的保证在一定时间后到达一致性状</description>
<pubDate>Fri, 31 May 2019 16:37:00 +0000</pubDate>
<dc:creator>junxing</dc:creator>
<og:description>[toc] 目录与路径 相对路径与绝对路径 上一章简单的提到绝对路径和相对路径 绝对路径：路径的写法一定是由根目录（/）写起的，例如：/home/user 这个目录 相对路径：路径的写法不是由根目录（</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Johnson-lin/p/10935051.html</dc:identifier>
</item>
<item>
<title>简析方差、标准差与数值离散程度 - 湫Teng-L</title>
<link>http://www.cnblogs.com/qiutenglong/p/10958128.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qiutenglong/p/10958128.html</guid>
<description>&lt;p&gt;方差（variance）: 变量与其均值的差的平方和除以(变量数+1)。&lt;/p&gt;
&lt;p&gt;　　 如有一组数据: [1,2,3,4,5], 其均值就是 (1+2+3+4+5) / 5 = 3&lt;/p&gt;
&lt;p&gt;　　 所以其方差为: （(1-3)^2 + (2-3)^2 +(3-3)^2 + (4-3)^2 + (5-3)^2） /（ 5+1） = 1.6666....&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1251758/201905/1251758-20190531233105791-444337965.png&quot; alt=&quot;&quot; width=&quot;300&quot; height=&quot;71&quot;/&gt;&lt;/p&gt;

&lt;p&gt;标准差(standard deviation)：方差的算术平方根&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1251758/201905/1251758-20190531233130996-1418484246.png&quot; alt=&quot;&quot; width=&quot;283&quot; height=&quot;67&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;方差和标准差反应了一组数据的离散程度:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当方差越小时，数据的离散程度越小&lt;/p&gt;
&lt;p&gt;而当方差越大时，数据的离散程度也就越大。&lt;/p&gt;
&lt;p&gt;如有两组数据&lt;/p&gt;
&lt;p&gt;A = [1,2,3,4,5]&lt;/p&gt;
&lt;p&gt;B=[1,5,7,9,11]&lt;/p&gt;
&lt;p&gt;A 的方差为2 、B的方差为11.84 ，从方差的大小比较，var(A)&amp;lt;var(B)&lt;/p&gt;
&lt;p&gt;所以B的离散程度比A的离散程度高&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为什么方差可以体现数据的离散程度？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由公式可知:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1251758/201905/1251758-20190531234246209-2103506653.png&quot; alt=&quot;&quot; width=&quot;346&quot; height=&quot;82&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当所有的变量值都一样时，均值等于变量值&lt;/p&gt;
&lt;p&gt;所以方差为0,此时离散程度为0。当各个变量值里均值都有一定距离时&lt;/p&gt;
&lt;p&gt;方差大于0。&lt;/p&gt;

&lt;p&gt;例子:&lt;/p&gt;
&lt;p&gt;通过使用 from sklearn.datasets.samples_generator import make_blobs 围绕3个中心点来生成数据集&lt;/p&gt;
&lt;p&gt;红色的点代表 中心点&lt;/p&gt;
&lt;p&gt;蓝色的点代表 生成点&lt;/p&gt;
&lt;p&gt;通过修改make_blobs里面的cluster_std参数来控制 生成点 与 中心点之间的离散程度。而cluster_std参数&lt;/p&gt;
&lt;p&gt;对应就是标准差&lt;/p&gt;
&lt;p&gt;（1）当标准差为 0.60时:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1251758/201905/1251758-20190531235840355-565766276.png&quot; alt=&quot;&quot; width=&quot;860&quot; height=&quot;490&quot;/&gt;&lt;/p&gt;
&lt;p&gt;(2) 当标准差为 0.3时&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1251758/201905/1251758-20190531235959308-971819893.png&quot; alt=&quot;&quot; width=&quot;750&quot; height=&quot;427&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图像反映了不同标准差之间数据发布的情况&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1251758/201906/1251758-20190601000140971-1762432862.png&quot; alt=&quot;&quot; width=&quot;333&quot; height=&quot;223&quot;/&gt;   &lt;img src=&quot;https://img2018.cnblogs.com/blog/1251758/201906/1251758-20190601000221313-1617707531.png&quot; alt=&quot;&quot; width=&quot;330&quot; height=&quot;221&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由此也反映了标准差与数值离散程度之间的对应关系。&lt;/p&gt;

</description>
<pubDate>Fri, 31 May 2019 16:05:00 +0000</pubDate>
<dc:creator>湫Teng-L</dc:creator>
<og:description>方差（variance）: 变量与其均值的差的平方和除以(变量数+1)。 如有一组数据: [1,2,3,4,5], 其均值就是 (1+2+3+4+5) / 5 = 3 所以其方差为: （(1-3)^2</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qiutenglong/p/10958128.html</dc:identifier>
</item>
<item>
<title>gitlab安装/迁移/升级流程 - 曾春云</title>
<link>http://www.cnblogs.com/zengchunyun/p/10958090.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zengchunyun/p/10958090.html</guid>
<description>&lt;h4 id=&quot;安装新的gitlab&quot;&gt;安装新的gitlab&lt;/h4&gt;
&lt;h5 id=&quot;先安装基本的依赖包&quot;&gt;先安装基本的依赖包&lt;/h5&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;sudo yum install -y curl policycoreutils-python openssh-server
sudo systemctl enable sshd
sudo systemctl start sshd

sudo firewall-cmd --permanent --add-service=http
sudo systemctl reload firewalld

sudo yum install postfix
sudo systemctl enable postfix
sudo systemctl start postfix&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;获取gitlab-yum源&quot;&gt;获取gitlab yum源&lt;/h5&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;curl -sS https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.rpm.sh | sudo bash&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;##### 开始安装&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;安装前先设置hosts解析，这样就能通过域名方式访问gitlab,同时后续迁移时也不需要改动gitlab使用的数据的访问url&lt;/li&gt;
&lt;li&gt;如果非公网域名,内部的域名，如果没有dns解析，则客户端访问时，同样需要设置本机的hosts记录&lt;/li&gt;
&lt;li&gt;这里以域名git.afcat.com.cn为例，我在hosts文件中增加一行解析记录&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;vim /etc/hosts
10.24.40.134 git.afcat.com.cn&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;##### 使用yum安装&lt;br/&gt;&lt;code&gt;bash sudo EXTERNAL_URL=&quot;https://git.afcat.com.cn&quot; yum install -y gitlab-ce&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;安装完就能访问了https://git.afcat.com.cn,打开页面后，会让你设置root用户的密码。该root是页面的登陆账号的root,不是服务器系统的root账号&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;迁移到新的gitlab&quot;&gt;迁移到新的gitlab&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;迁移要保证两台gitlab版本完全一致，否则原来服务器的备份数据无法导入到新的gitlab服务器上。&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;先查看原来的gitlab版本号&quot;&gt;先查看原来的gitlab版本号&lt;/h5&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;gitlab-rake gitlab:env:info&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;假设原来的版本号为:8.8.5&lt;/li&gt;
&lt;li&gt;那么在新机器上安装命令gitlab版本时需要带上版本号&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;sudo EXTERNAL_URL=&quot;https://git.afcat.com.cn&quot; yum install -y gitlab-ce-8.8.5 --nogpgcheck&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;以下操作在原来的gitlab服务器上操作&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;创建备份文件&quot;&gt;创建备份文件&lt;/h5&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;gitlab-rake gitlab:backup:create STRATEGY=copy &lt;/code&gt;
&lt;/pre&gt;
&lt;h6 id=&quot;备份结果&quot;&gt;备份结果&lt;/h6&gt;
&lt;ul&gt;&lt;li&gt;记住下面这个文件名，还原时用的上&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;1531878574_gitlab_backup.tar&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;默认备份位置&lt;code&gt;/var/opt/gitlab/backups&lt;/code&gt;目录&lt;/li&gt;
&lt;li&gt;如果需要修改默认备份位置,可编辑&lt;code&gt;/etc/gitlab/gitlab.rb&lt;/code&gt;配置文件&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;vim /etc/gitlab/gitlab.rb&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;找到gitlab_rails['backup_path']配置&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;# 设置备份路径
gitlab_rails['backup_path'] = &quot;/var/opt/gitlab/backups&quot;
# 设置备份过期时间
gitlab_rails['backup_keep_time'] = 604800&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;改完配置必须执行下面的命令，使配置生效&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;gitlab-ctl reconfigure&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;打包配置文件&quot;&gt;打包配置文件&lt;/h5&gt;
&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;/etc/gitlab/gitlab.rb # 配置文件须备份
/etc/gitlab/gitlab-secrets.json # 该文件用于代码解密用,可以不备份，但会出现500错误，下面会有对应500错误的解决方案
/var/opt/gitlab/nginx/conf # nginx配置文件
/etc/postfix/main.cfpostfix # 邮件配置备份&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;还原备份如果是迁移则在新服务器执行&quot;&gt;还原备份/如果是迁移,则在新服务器执行&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;停止服务&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;gitlab-ctl stop unicorn
gitlab-ctl stop sidekiq&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;执行还原备份文件&lt;/li&gt;
&lt;li&gt;1531878574为1531878574_gitlab_backup.tar文件的_gitlab_backup.tar前面字符&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;gitlab-rake gitlab:backup:restore BACKUP=1531878574&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;启动服务&quot;&gt;启动服务&lt;/h5&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;gitlab-ctl start&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;gitlab升级&quot;&gt;gitlab升级&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;升级只能从小版本升到画最新的小版本，不能直接跨大版本升级，只有升级到最新的小版本，才能升级到下一个大版本，不能跳跃的最新的大版本升级&lt;/li&gt;
&lt;li&gt;如：当前的版本为8.8.5，当前的最新版本为11.3.4，当前该小版本的最新版本为8.13.4，下一个大版本为9.5.10，下一个大版本为10.8.7&lt;/li&gt;
&lt;li&gt;升级顺序：先安装8.13.4，然后安装9.5.10，再安装10.8.7，最后安装11.3.4&lt;/li&gt;
&lt;li&gt;每次安装完后记得访问一下页面，如果不正常，就需要执行下面的命令，使配置生效&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;gitlab-ctl reconfigure&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;具体的升级命令&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;sudo EXTERNAL_URL=&quot;https://git.afcat.com.cn&quot; yum install -y gitlab-ce-8.13.4 --nogpgcheck
sudo EXTERNAL_URL=&quot;https://git.afcat.com.cn&quot; yum install -y gitlab-ce-8.17.7 --nogpgcheck
sudo EXTERNAL_URL=&quot;https://git.afcat.com.cn&quot; yum install -y gitlab-ce-9.5.10 --nogpgcheck
sudo EXTERNAL_URL=&quot;https://git.afcat.com.cn&quot; yum install -y gitlab-ce-10.8.7 --nogpgcheck
sudo EXTERNAL_URL=&quot;https://git.afcat.com.cn&quot; yum install -y gitlab-ce-11.3.4 --nogpgcheck&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;遇到500错误&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;gitlab-rails runner &quot;Project.where.not(import_url:nil).each{|p|p.import_data.destroy if p.import_data}&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;[ERROR] Error executing action &lt;code&gt;run&lt;/code&gt; on resource 'ruby_block[directory resource: /var/opt/gitlab/git-data/repositories]&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;chmod -R 2770 /var/opt/gitlab/git-data&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 31 May 2019 15:48:00 +0000</pubDate>
<dc:creator>曾春云</dc:creator>
<og:description>安装新的gitlab 先安装基本的依赖包 获取gitlab yum源 开始安装 安装前先设置hosts解析，这样就能通过域名方式访问gitlab,同时后续迁移时也不需要改动gitlab使用的数据的访问</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zengchunyun/p/10958090.html</dc:identifier>
</item>
<item>
<title>设计模式之代理模式（proxy pattern） - alpha_panda</title>
<link>http://www.cnblogs.com/yssjun/p/10889022.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yssjun/p/10889022.html</guid>
<description>&lt;p&gt;代理模式的本质是一个中间件，主要目的是解耦合服务提供者和使用者。使用者通过代理间接的访问服务提供者，便于后者的封装和控制。是一种结构性模式。&lt;/p&gt;
&lt;h3&gt;1.目的&lt;/h3&gt;
&lt;p&gt;为外部调用者提供一个访问服务提供者的代理对象。&lt;/p&gt;
&lt;h3&gt;2.动机&lt;/h3&gt;
&lt;p&gt;限制对目标对象的直接访问，降低耦合度。&lt;/p&gt;
&lt;h3&gt;3.优缺点&lt;/h3&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt; &lt;/p&gt;
&lt;ul&gt;&lt;li&gt;低耦合&lt;/li&gt;
&lt;li&gt;易扩展&lt;/li&gt;
&lt;li&gt;灵活度高&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;间接访问可能会延迟请求相应&lt;/li&gt;
&lt;li&gt;增加工作量&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;4.分类&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;静态代理&lt;/li&gt;
&lt;li&gt;动态代理&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　代理类本身的实现可能并不简单，加上每一个需要代理的对象均均需要实现一个代理类，其工作量本身比较大，易出错。&lt;/p&gt;
&lt;p&gt;　　所谓动态代理（DynamicProxy）是指在程序运行时动态的生成对目标对象的访问接口。&lt;/p&gt;
&lt;p&gt;　　本文主要介绍前者，关于后者可以参考JDK自带的动态代理。&lt;/p&gt;
&lt;h3&gt;5.主要用途&lt;/h3&gt;
&lt;p&gt;代理模式在以下场景比较适用：&lt;/p&gt;
&lt;p&gt;     1、远程代理。 2、虚代理。 3、保护代理。4、智能指引代理。5、写时复制(Copy-on-Write)代理。  6、缓存代理。 7、防火墙代理。 8、同步化代理。&lt;/p&gt;
&lt;h3&gt;6.原理&lt;/h3&gt;
&lt;p&gt;下面是GoF介绍典型的代理模式UML类图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1419489/201905/1419489-20190531200018057-516317228.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Subject:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　定义RealSubject对外的接口，且这些接口必须被Proxy实现，这样外部调用proxy的接口最终都被转化为对realsubject的调用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RealSubject:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　真正的目标对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Proxy:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　目标对象的代理，负责控制和管理目标对象，并间接地传递外部对目标对象的访问。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Remote Proxy: 对本地的请求以及参数进行序列化，向远程对象发送请求，并对响应结果进行反序列化，将最终结果反馈给调用者；&lt;/li&gt;
&lt;li&gt;Virtual Proxy: 当目标对象的创建开销比较大的时候，可以使用延迟或者异步的方式创建目标对象；&lt;/li&gt;
&lt;li&gt;Protection Proxy: 细化对目标对象访问权限的控制；&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;7.实现&lt;/h3&gt;
&lt;p&gt; 下面我们使用两个例子来实际体验一下代理模式的应用&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;网络代理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于一些国内不能直接访问的网站，合法的使用的网络代理可以实现对目标网站的访问;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1419489/201905/1419489-20190531220641539-130010838.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;定义公共接口类Server:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Server{
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; visit(String url);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  代理服务器ProxyServer:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ProxyServer &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Server{
 
   &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; RealServer realServer;
 
   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ProxyServer(String serverName){
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.realServer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RealServer(serverName);
   }
 
   @Override
   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; visit(String url) {
      realServer.visit(url);
   }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  目标服务器RealServer:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; RealServer &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Server {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String serverName;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; RealServer(String serverName) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.serverName =&lt;span&gt; serverName;
        System.out.println(&lt;/span&gt;&quot;This is &quot; +&lt;span&gt; serverName);
    }
    
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; visit(String url) {
        response(url);
    }
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; response(String res) {
        System.out.println(&lt;/span&gt;&quot;This is response of &quot; + res + &quot; from server:&quot; +&lt;span&gt; serverName);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 演示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Demo {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Server server &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ProxyServer(&quot;www.google.com&quot;&lt;span&gt;);
        server.visit(&lt;/span&gt;&quot;map.google.com&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;智能指针引用计数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面使用代理模式简单的模拟指针引用计数问题&lt;/p&gt;
&lt;p&gt;接口类Obj:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Obj{
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; GetAttr();
    Obj copy();
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; delete();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  智能指针类SmartPointer:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('6890b5b3-d43f-4c61-8de8-ae1961439777')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_6890b5b3-d43f-4c61-8de8-ae1961439777&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_6890b5b3-d43f-4c61-8de8-ae1961439777&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('6890b5b3-d43f-4c61-8de8-ae1961439777',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_6890b5b3-d43f-4c61-8de8-ae1961439777&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; SmartPointer &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Obj{
 
   &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; RealObj realObj;
   &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; counter = 1&lt;span&gt;;
 
   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; SmartPointer(String objType){
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.realObj = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RealObj(objType);
   }
   
   @Override
   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; GetAttr() {
       &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(counter &amp;gt; 0&lt;span&gt;) {
           realObj.GetAttr();
       }
       System.out.println(&lt;/span&gt;&quot;Smart Ref: &quot; +&lt;span&gt; counter);
   }
       
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Obj copy() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(counter &amp;gt; 0&lt;span&gt;) {
            counter &lt;/span&gt;+= 1&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
        }
        System.out.println(&lt;/span&gt;&quot;Invalid Pointer!&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; delete() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(counter &amp;gt; 0&lt;span&gt;) {
            counter &lt;/span&gt;-= 1&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(0 ==&lt;span&gt; counter) {
                realObj &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            }
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            System.out.println(&lt;/span&gt;&quot;Invalid Pointer!&quot;&lt;span&gt;);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt; 被引用对象类RealObj:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('8a89e397-1930-43a0-a6c8-985ca7af85c6')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_8a89e397-1930-43a0-a6c8-985ca7af85c6&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_8a89e397-1930-43a0-a6c8-985ca7af85c6&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('8a89e397-1930-43a0-a6c8-985ca7af85c6',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_8a89e397-1930-43a0-a6c8-985ca7af85c6&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; RealObj &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Obj {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String objType;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; RealObj(String objType) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.objType =&lt;span&gt; objType;
        System.out.println(&lt;/span&gt;&quot;Create Obj: &quot; +&lt;span&gt; objType);
    }
    
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; GetAttr() {
        System.out.println(&lt;/span&gt;&quot;get attr of real obj &quot; +&lt;span&gt; objType);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Obj copy() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; delete() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
&lt;span&gt;        
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt; &lt;strong&gt;参考：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;GoF《Design Patterns: Elements of Reusable Object-Oriented Software》&lt;/p&gt;
&lt;p&gt;https://www.runoob.com/design-pattern/proxy-pattern.html&lt;/p&gt;
</description>
<pubDate>Fri, 31 May 2019 15:39:00 +0000</pubDate>
<dc:creator>alpha_panda</dc:creator>
<og:description>代理模式的本质是一个中间件，主要目的是解耦合服务提供者和使用者。使用者通过代理间接的访问服务提供者，便于后者的封装和控制。是一种结构性模式。 1.目的 为外部调用者提供一个访问服务提供者的代理对象。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yssjun/p/10889022.html</dc:identifier>
</item>
<item>
<title>HashMap,你知道多少？ - 玉树临枫</title>
<link>http://www.cnblogs.com/yuanfy008/p/10958041.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuanfy008/p/10958041.html</guid>
<description>&lt;p&gt;HashMap在面试中是个火热的话题，那么你能应付自如吗？下面抛出几个问题看你是否知道，如果知道那么本文对于你来说就不值一提了。&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;HashMap的内部数据结构是什么？&lt;/li&gt;
&lt;li&gt;HashMap扩容机制时什么？什么时候扩容？&lt;/li&gt;
&lt;li&gt;HashMap其长度有什么特征？为什么是这样？&lt;/li&gt;
&lt;li&gt;HashMap为什么线程不安全？并发的场景会出现什么的情况？&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;本文是基于JDK1.7.0_79版本进行研究的。&lt;/p&gt;

&lt;h3 id=&quot;2038-1559019535244&quot;&gt;1、类的继承关系&lt;/h3&gt;
&lt;div id=&quot;7634-1559032316498&quot; data-theme=&quot;default&quot; data-language=&quot;javascript&quot; readability=&quot;8.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; HashMap&amp;lt;K,V&amp;gt; &lt;span&gt;extends&lt;/span&gt; AbstractMap&amp;lt;K,V&amp;gt; &lt;span&gt;implements&lt;/span&gt; Map&amp;lt;K,V&amp;gt;, Cloneable, Serializable
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;其中继承了AbstractMap抽象类，别小看了这个抽象类哦，它实现了Map接口的许多重要方法，大大减少了实现此接口的工作量。&lt;/p&gt;
&lt;h3 id=&quot;7067-1559019535245&quot;&gt;2、属性解析&lt;/h3&gt;
&lt;h3 id=&quot;2819-1559032326377&quot;&gt;2.1、capacity：容量&lt;/h3&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;DEFAULT_INITIAL_CAPACITY&lt;/strong&gt;：默认的初始容量-必须是2的幂。为什么呢？先留个疑问在这&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * The default initial capacity - MUST be a power of two.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_INITIAL_CAPACITY = 1 &amp;lt;&amp;lt; 4; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; aka 16&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;MAXIMUM_CAPACITY&lt;/strong&gt;：最大容量为2^30。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;h3&gt;2.2 threshold：阈值&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * The next size value at which to resize (capacity * load factor).
 * &lt;/span&gt;&lt;span&gt;@serial&lt;/span&gt;
 &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; If table == EMPTY_TABLE then this is the initial capacity at which the
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; table will be created when inflated.&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; threshold;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从上面注释可以看出， 它的值是由容量和加载因子决定的。&lt;/p&gt;
&lt;h3 id=&quot;2250-1559040703119&quot;&gt;2.3 loadFactor：加载因子，默认为0.75&lt;/h3&gt;
&lt;div id=&quot;5580-1559040760760&quot; data-theme=&quot;default&quot; data-language=&quot;javascript&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * The load factor used when none specified in constructor.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; DEFAULT_LOAD_FACTOR = 0.75f;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&quot;6970-1559032487930&quot;&gt;2.4 size：键值对长度&lt;/h3&gt;
&lt;div id=&quot;7892-1559040943762&quot; data-theme=&quot;default&quot; data-language=&quot;javascript&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * The number of key-value mappings contained in this map.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;transient&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; size;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2.5 modCount：修改内部结构的次数&lt;/h3&gt;
&lt;/div&gt;
&lt;div id=&quot;5135-1559041163800&quot; data-theme=&quot;default&quot; data-language=&quot;javascript&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;transient&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; modCount;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;上面五个属性字段都很重要， 后面再分析体现其重要。&lt;/p&gt;

&lt;h3 id=&quot;3882-1559041559217&quot;&gt;3、底层数据结构&lt;/h3&gt;
&lt;div id=&quot;3050-1559041459472&quot; data-theme=&quot;default&quot; data-language=&quot;javascript&quot; readability=&quot;9&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Entry&amp;lt;?,?&amp;gt;[] EMPTY_TABLE =&lt;span&gt; {};

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * The table, resized as necessary. Length MUST Always be a power of two.
 * 这里也强调扩容时，长度必须是2的指数次幂
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;transient&lt;/span&gt; Entry&amp;lt;K,V&amp;gt;[] table = (Entry&amp;lt;K,V&amp;gt;[]) EMPTY_TABLE;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Entry内部结构如下：&lt;/p&gt;
&lt;div id=&quot;3069-1559041721372&quot; data-theme=&quot;default&quot; data-language=&quot;javascript&quot; readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Entry&amp;lt;K,V&amp;gt; &lt;span&gt;implements&lt;/span&gt; Map.Entry&amp;lt;K,V&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt;&lt;span&gt; K key;
    V value;
    Entry&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; next;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; hash;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;经分析后其数据结构为数组+链表的形式，展示图如下：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/src/AAD6BF3FCAAE4215973FA705F887CE15&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/690169/201905/690169-20190531230029537-946759634.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/src/AAD6BF3FCAAE4215973FA705F887CE15&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&quot;9613-1559043141771&quot;&gt;4、重要函数&lt;/h3&gt;
&lt;h3 id=&quot;8850-1559041200175&quot;&gt;4.1 构造函数&lt;/h3&gt;
&lt;p&gt;总共有四个构造函数， 主要分析含有两个参数的构造函数：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/690169/201905/690169-20190531230155492-424329469.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/src/F20D060F65B04A20AFD9EE2F5052A820&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;11&quot;&gt;其实这个构造函数也主要是初始化加载因子和阈值。（可能1.7的其他版本会有点不一样，会在构造函数中初始化table）
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; HashMap(&lt;span&gt;int&lt;/span&gt; initialCapacity, &lt;span&gt;float&lt;/span&gt;&lt;span&gt; loadFactor) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (initialCapacity &amp;lt; 0&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&quot;Illegal initial capacity: &quot; +&lt;span&gt;
                                           initialCapacity);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (initialCapacity &amp;gt;&lt;span&gt; MAXIMUM_CAPACITY)
        initialCapacity &lt;/span&gt;=&lt;span&gt; MAXIMUM_CAPACITY;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (loadFactor &amp;lt;= 0 ||&lt;span&gt; Float.isNaN(loadFactor))
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&quot;Illegal load factor: &quot; +&lt;span&gt;
                                           loadFactor);

    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.loadFactor =&lt;span&gt; loadFactor;
    threshold &lt;/span&gt;=&lt;span&gt; initialCapacity;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 供子类实现&lt;/span&gt;
&lt;span&gt;    init();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;h3 id=&quot;8877-1559049318185&quot;&gt;4.2 put()函数&lt;/h3&gt;
&lt;div id=&quot;3384-1559049500443&quot; data-theme=&quot;default&quot; data-language=&quot;javascript&quot; readability=&quot;16.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; V put(K key, V value) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1 如果table为空则需要初始化&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (table ==&lt;span&gt; EMPTY_TABLE) {
        inflateTable(threshold);
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2 如果key为空,则单独处理&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (key == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; putForNullKey(value);
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3 根据key获取hash值   &lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; hash =&lt;span&gt; hash(key);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 4 根据hash值和长度求取索引值。&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; i =&lt;span&gt; indexFor(hash, table.length);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 5 根据索引值获取数组下的链表进行遍历，判断元素是否存在相同的key&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (Entry&amp;lt;K,V&amp;gt; e = table[i]; e != &lt;span&gt;null&lt;/span&gt;; e =&lt;span&gt; e.next) {
        Object k;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e.hash == hash &amp;amp;&amp;amp; ((k = e.key) == key ||&lt;span&gt; key.equals(k))) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果相等，则将新值替换旧值&lt;/span&gt;
            V oldValue =&lt;span&gt; e.value;
            e.value &lt;/span&gt;=&lt;span&gt; value;
            e.recordAccess(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; oldValue;
        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 6 如果不存在重复的key, 则需要创建新的Entry，然后添加至链表中。
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 先将修改次数加一&lt;/span&gt;
    modCount++&lt;span&gt;;
    addEntry(hash, key, value, i);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;第一步：当table还没有初始化时，看下inflateTable()函数做了什么操作。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; inflateTable(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; toSize) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Find a power of 2 &amp;gt;= toSize&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; capacity =&lt;span&gt; roundUpToPowerOf2(toSize);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 其中阈值=容量*加载因子，然后再初始化数组。&lt;/span&gt;
    threshold = (&lt;span&gt;int&lt;/span&gt;) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1&lt;span&gt;);
    table &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Entry[capacity];
    initHashSeedAsNeeded(capacity);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;其中容量是根据toSize取第一个大于它的2的指数次幂的值， 如下，其中highestOneBit函数是返回其最高位的权值，用的最巧的就是(number - 1) &amp;lt;&amp;lt; 1 其实就是取number的倍数， 但综合使用却能取得&lt;span&gt;第一个大于等于该值的2的指数次幂&lt;/span&gt;。（用的牛逼）&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; roundUpToPowerOf2(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; number) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; assert number &amp;gt;= 0 : &quot;number must be non-negative&quot;;&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; number &amp;gt;=&lt;span&gt; MAXIMUM_CAPACITY
            &lt;/span&gt;?&lt;span&gt; MAXIMUM_CAPACITY
            : (number &lt;/span&gt;&amp;gt; 1) ? Integer.highestOneBit((number - 1) &amp;lt;&amp;lt; 1) : 1&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;接着看put函数的第二步：&lt;span&gt;当key为null时，会取数组下标为0的&lt;/span&gt;位置进行链表遍历，如果存在key=null，则替换值并返回。否则进入第六步（注意：索引值依然指定是0）。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div readability=&quot;9.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt;&lt;span&gt; V putForNullKey(V value) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 取数组下标为0的链表&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (Entry&amp;lt;K,V&amp;gt; e = table[0]; e != &lt;span&gt;null&lt;/span&gt;; e =&lt;span&gt; e.next) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e.key == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            V oldValue &lt;/span&gt;=&lt;span&gt; e.value;
            e.value &lt;/span&gt;=&lt;span&gt; value;
            e.recordAccess(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; oldValue;
        }
    }
    modCount&lt;/span&gt;++&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注意：索引值依然指定是0&lt;/span&gt;
    addEntry(0, &lt;span&gt;null&lt;/span&gt;, value, 0&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;第三步：根据key的hashCode求取hash值，这又是个神奇的算法，这里不做多解释。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div id=&quot;1100-1559053508612&quot; data-theme=&quot;default&quot; data-language=&quot;javascript&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; hash(Object k) {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; h =&lt;span&gt; hashSeed;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (0 != h &amp;amp;&amp;amp; k &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; String) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; sun.misc.Hashing.stringHash32((String) k);
    }
    
    h &lt;/span&gt;^=&lt;span&gt; k.hashCode();

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; This function ensures that hashCodes that differ only by
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; constant multiples at each bit position have a bounded
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; number of collisions (approximately 8 at default load factor).&lt;/span&gt;
    h ^= (h &amp;gt;&amp;gt;&amp;gt; 20) ^ (h &amp;gt;&amp;gt;&amp;gt; 12&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; h ^ (h &amp;gt;&amp;gt;&amp;gt; 7) ^ (h &amp;gt;&amp;gt;&amp;gt; 4&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;第四步：根据hash值和底层数组的长度计算索引下标。&lt;span&gt;因为数组的长度是2的幂，所以h &amp;amp; (length-1)运算其实就是h与（length-1）的取模运算&lt;/span&gt;。不得不服啊，将计算运用的如此高效。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div id=&quot;8187-1559053719547&quot; data-theme=&quot;default&quot; data-language=&quot;javascript&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; indexFor(&lt;span&gt;int&lt;/span&gt; h, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; length) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; assert Integer.bitCount(length) == 1 : &quot;length must be a non-zero power of 2&quot;;&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; h &amp;amp; (length-1&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;找个数验证下：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/690169/201905/690169-20190531230548897-32703954.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/src/A597BA97C037489BA72D5F8C5A66D717&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;第五步是验证是否有重复key,如果有则替换新值然后返回，源码很详细了就不再做解释了。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;第六步：是将值添加到entry数组中，详细看下addEntry()函数。&lt;span&gt;首先根据size和阈值判断是否需要扩容（进行两倍扩容），如果需要扩容则先扩容重新计算索引，则创建新的元素添加至数组&lt;/span&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div id=&quot;3487-1559054509957&quot; data-theme=&quot;default&quot; data-language=&quot;javascript&quot; readability=&quot;14.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; addEntry(&lt;span&gt;int&lt;/span&gt; hash, K key, V value, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; bucketIndex) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果长度大于阈值，则需要进行扩容&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; ((size &amp;gt;= threshold) &amp;amp;&amp;amp; (&lt;span&gt;null&lt;/span&gt; !=&lt;span&gt; table[bucketIndex])) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 进行2倍扩容&lt;/span&gt;
        resize(2 *&lt;span&gt; table.length);
        hash &lt;/span&gt;= (&lt;span&gt;null&lt;/span&gt; != key) ? hash(key) : 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 扩容之后因为长度变化了，需要重新计算下索引值。&lt;/span&gt;
        bucketIndex =&lt;span&gt; indexFor(hash, table.length);
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 然后进行添加元素&lt;/span&gt;
&lt;span&gt;    createEntry(hash, key, value, bucketIndex);
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; createEntry(&lt;span&gt;int&lt;/span&gt; hash, K key, V value, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; bucketIndex) {
    Entry&lt;/span&gt;&amp;lt;K,V&amp;gt; e =&lt;span&gt; table[bucketIndex];
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 往表头插入&lt;/span&gt;
    table[bucketIndex] = &lt;span&gt;new&lt;/span&gt; Entry&amp;lt;&amp;gt;&lt;span&gt;(hash, key, value, e);
    size&lt;/span&gt;++&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;10.5&quot;&gt;其中扩容机制resize()函数需要重点捞出来晒下：&lt;span&gt;newCapacity = 2 * length，理论上会进行两倍扩容但会根最大容量进行对比取最小， 创建新数组然后将就数组中的值拷贝至新数组（其中会重新计算索引下标），然后再赋值给table, 最后再重新计算阈值。&lt;/span&gt;
&lt;div class=&quot;cnblogs_code _mce_tagged_br&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; resize(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; newCapacity) {
    Entry[] oldTable &lt;/span&gt;=&lt;span&gt; table;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; oldCapacity =&lt;span&gt; oldTable.length;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 两倍容量与最大容量取最小&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (oldCapacity ==&lt;span&gt; MAXIMUM_CAPACITY) {
        threshold &lt;/span&gt;=&lt;span&gt; Integer.MAX_VALUE;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建新数组&lt;/span&gt;
    Entry[] newTable = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Entry[newCapacity];
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 拷贝数组（重新计算索引下标）&lt;/span&gt;
&lt;span&gt;    transfer(newTable, initHashSeedAsNeeded(newCapacity));
    table &lt;/span&gt;=&lt;span&gt; newTable;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 重新计算阈值&lt;/span&gt;
    threshold = (&lt;span&gt;int&lt;/span&gt;)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;　　接着看transfer()函数，多注意这个函数中循环的内容&lt;/p&gt;
&lt;div id=&quot;1533-1559224319437&quot; data-theme=&quot;default&quot; data-language=&quot;javascript&quot; readability=&quot;12.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; transfer(Entry[] newTable, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; rehash) {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; newCapacity =&lt;span&gt; newTable.length;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Entry&amp;lt;K,V&amp;gt;&lt;span&gt; e : table) {
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;null&lt;/span&gt; !=&lt;span&gt; e) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定一个next&lt;/span&gt;
            Entry&amp;lt;K,V&amp;gt; next =&lt;span&gt; e.next;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (rehash) {
                e.hash &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt; == e.key ? 0&lt;span&gt; : hash(e.key);
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 重新计算索引下标。&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; i =&lt;span&gt; indexFor(e.hash, newCapacity);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 头插法，&lt;/span&gt;
            e.next =&lt;span&gt; newTable[i];
            newTable[i] &lt;/span&gt;=&lt;span&gt; e;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 接着下个节点继续遍历&lt;/span&gt;
            e =&lt;span&gt; next;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　通过上面分析，其实put函数还是简单的，不是很绕。那么能从其中找到开头的第二和第三个问题的答案吗？下面总结下顺便回答下这两个问题：&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;1、&lt;strong&gt;数组长度不管是初始化还是扩容时，都始终保持是2的指数次幂。&lt;/strong&gt;&lt;/span&gt;为什么呢？下面我的分析：&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;能使元素均匀分布，增大空间利用率&lt;/span&gt;。put值时需要根据key的hash值与长度进行取模运算得到索引下标，如果是2的幂，那么length一定是偶数，则length-1一定是奇数，那么它对应的二进制的最后一位一定是1，所以它能保证h&amp;amp;（length-1）既能到奇数也能得到偶数，这样保证了散列的均匀性。相反如果不是2的幂，那么length-1可能是偶数，这样h&amp;amp;(length-1)得到的都是偶数，就会浪费一半的空间了。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;运算效率高效。位运算比%运算高效。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2、&lt;/span&gt;&lt;strong&gt;&lt;span&gt;重复key的值会被新值替换，允许key为空且统一放在下标为0的链表上。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、&lt;strong&gt;&lt;span&gt;当&lt;/span&gt;size大于等于阈值（容量*加载因子）时，会进行扩容&lt;/strong&gt;&lt;/span&gt;。扩容机制是：扩容量为原来数组长度的两倍，根据扩容量创建新数组然后进行数组拷贝，新元素落位需要重新计算索引下标。扩容后，阈值需要重新计算，需要插入的元素落位的索引下标也需要重新计算。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、扩容很耗时，而扩容的次数主要取决于加载因子的值，因为它决定这扩容的次数。下面讲下它的取值的重要性：&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;加载因子越小，优点：存储的冲突机会减少；缺点：扩容次数越多（消耗性能就越大）、同时浪费空间较大（很多空间还没用，就开始扩容了）&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;加载因子越大，有点：扩容次数较少，空间利用率高；缺点：冲突几率就变大了、链表（后面介绍）长度会变长，查找的效率降低。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;5、扩容时会重新计算索引下标。也就是所谓的rehash过程&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6、插入元素都是表头插入，而不是链表尾插入。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;4.3、get()函数&lt;/h3&gt;
&lt;div readability=&quot;14&quot;&gt;知道了put方法的原理，那么get方法就很简单了。
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; V get(Object key) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (key == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; getForNullKey();
    Entry&lt;/span&gt;&amp;lt;K,V&amp;gt; entry =&lt;span&gt; getEntry(key);

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt; == entry ? &lt;span&gt;null&lt;/span&gt;&lt;span&gt; : entry.getValue();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一步：如果key为空，则直接从table[0]所对应的链表中查找（应该还记得put的时候为null的key放在哪）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt;&lt;span&gt; V getForNullKey() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (size == 0&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Entry&amp;lt;K,V&amp;gt; e = table[0]; e != &lt;span&gt;null&lt;/span&gt;; e =&lt;span&gt; e.next) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e.key == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; e.value;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/src/56D65A7810904698BA57FE9097738528&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;p&gt;第二步：如果key不为空，则根据key获取hash值，然后再根据hash和length-1取模得到索引，然后再遍历索引对应的链表，存在与key相等的则返回。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/src/37AC937E5DFE4843AC4D6DC4F3F339B2&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;final&lt;/span&gt; Entry&amp;lt;K,V&amp;gt;&lt;span&gt; getEntry(Object key) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (size == 0&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; hash = (key == &lt;span&gt;null&lt;/span&gt;) ? 0&lt;span&gt; : hash(key);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Entry&amp;lt;K,V&amp;gt; e =&lt;span&gt; table[indexFor(hash, table.length)];
             e &lt;/span&gt;!= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
             e &lt;/span&gt;=&lt;span&gt; e.next) {
            Object k;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e.hash == hash &amp;amp;&amp;amp;&lt;span&gt;
                ((k &lt;/span&gt;= e.key) == key || (key != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; key.equals(k))))
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; e;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;h3 id=&quot;2656-1559228167383&quot;&gt;1、肯定不能保证数据的安全性，因为内部方法没有一个是线程安全的。&lt;/h3&gt;
&lt;h3 id=&quot;2733-1559228248142&quot;&gt;2、有时会出现死锁情况。为什么呢？下面列个场景简单分析下：&lt;/h3&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;假设当前容量为4， 有三个元素（a, b, c）都在table[2]下的链表中，另一个元素(d)在table[3]下。如图&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/690169/201905/690169-20190531231556066-169459484.png&quot; alt=&quot;&quot; width=&quot;283&quot; height=&quot;305&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/src/E76B9D80244F463FA157C2EA4212DF33&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;假设此时有A,B两个线程都要往map中put一个元素则都需要扩容，当遍历到table[2]时，假设线程B先进入循环体的第一步：e 指向a, next指向b, 如图：&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div id=&quot;3036-1559229448173&quot; data-theme=&quot;default&quot; data-language=&quot;javascript&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Entry&amp;lt;K,V&amp;gt; next = e.next;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/690169/201905/690169-20190531232401635-2108546323.png&quot; alt=&quot;&quot; width=&quot;298&quot; height=&quot;360&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/src/3C292C2CB9B947158AC05D37318DF861&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;此时线程B让出时间片，让A线程一直执行完扩容操作，最终落位同样也是落位到table[2],其链表元素已经倒序了。如图：&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/690169/201905/690169-20190531232442552-1836626201.png&quot; alt=&quot;&quot; width=&quot;394&quot; height=&quot;232&quot;/&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/src/FFC4FC998F1B454AB2F54C3EA84AA76E&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;A线程让出时间片，B线程操作：接着循环继续执行，执行到循环末尾的时候，table[2] 指向a, 同时 e 和 next 都是指向b,如图：&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div id=&quot;4848-1559229811430&quot; data-theme=&quot;default&quot; data-language=&quot;javascript&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 同理落位到2&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; i =&lt;span&gt; indexFor(e.hash, newCapacity);
e.next &lt;/span&gt;=&lt;span&gt; newTable[i];
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 指向a&lt;/span&gt;
newTable[i] =&lt;span&gt; e;
e &lt;/span&gt;= next;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/690169/201905/690169-20190531232542569-1498379744.png&quot; alt=&quot;&quot; width=&quot;390&quot; height=&quot;245&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/src/11E3688D73E146FC86F2F1F48A8B231C&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;接着第二轮循环， e = b, next = a, 进行第二轮循环后的结果是e = next 且 table[2] 指向b元素，b元素再指向a元素，如图：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/690169/201905/690169-20190531232701928-1836301490.png&quot; alt=&quot;&quot; width=&quot;410&quot; height=&quot;244&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/src/883135FA3DA4454C8694201AD817FE0A&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;接着第三轮循环， e = a, a的下个元素为null, 所以next = null，但是当执行到下面这步就改变形式了，e.next 又指向了b，此时a和b已经出现了环形。因为next = null，所以终止了循环。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div id=&quot;9663-1559230253376&quot; data-theme=&quot;default&quot; data-language=&quot;javascript&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
e.next = newTable[i];
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/690169/201905/690169-20190531232742732-424651424.png&quot; alt=&quot;&quot; width=&quot;467&quot; height=&quot;279&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/src/CC35D5AEAD1645BD90BD1B6CC1496CE4&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;此时，问题还没有直接产生。&lt;strong&gt;当调用get()函数查找一个不存在的Key，而这个Key的Hash结果恰好等于3的时候，由于位置3带有环形链表，所以程序将会进入死循环！&lt;/strong&gt;（上面图形均忽略四个元素和要插入元素的规划）&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;

&lt;div id=&quot;2042-1559228095436&quot;&gt;
&lt;ul&gt;&lt;li&gt;1、创建HashMap时，指定足够大的容量，减少扩容次数。最好为：需要存的实际个数/除以加载因子。可以使用guava包中的Maps.newHashMapWithExpectedSize()方法。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;为什么要这样指定大小呢？ 再去上面回顾下扩容时机吧&lt;/p&gt;
&lt;div id=&quot;4427-1559228807740&quot;&gt;
&lt;ul&gt;&lt;li&gt;2、不要在并发场景中使用HashMap，如硬要使用通过Collections工具类创建线程安全的map,如：Collections.synchronizedMap(new HashMap&amp;lt;String, Object&amp;gt;());&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;

</description>
<pubDate>Fri, 31 May 2019 15:33:00 +0000</pubDate>
<dc:creator>玉树临枫</dc:creator>
<og:description>一、前言 HashMap在面试中是个火热的话题，那么你能应付自如吗？下面抛出几个问题看你是否知道，如果知道那么本文对于你来说就不值一提了。 HashMap的内部数据结构是什么？ HashMap扩容机制</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yuanfy008/p/10958041.html</dc:identifier>
</item>
<item>
<title>你听过稀疏数组(sparseArray)吗？ - wanbf</title>
<link>http://www.cnblogs.com/justBobo/p/10958012.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/justBobo/p/10958012.html</guid>
<description>&lt;h2&gt;基本介绍&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;当一个数组中大部分元素为０，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;稀疏数组的处理方法是:&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;1.记录数组&lt;strong&gt;一共有几行几列，有多少个不同&lt;/strong&gt;的值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.把具有不同值的元素的行列及值记录在一个小规模的数组中，从而&lt;strong&gt;缩小程序的规模&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;稀疏数组举例：&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1653497/201905/1653497-20190531231029583-968000835.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;其中右边数组第一行 6=左边数组有多少行，7=左边数组有多少列，8=左边数组有多少个不是0的值，然后下面8行保存的是数据的坐标和值。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;实际应用&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;编写的五子棋程序中，有存盘退出和续上盘的功能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1653497/201905/1653497-20190531230639829-54947338.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1653497/201905/1653497-20190531230737724-1917796664.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分析问题&lt;/strong&gt;:因为该二维数组的很多值是默认值0, 因此记录了很多没有意义的数据，所以这时我们可以用&lt;strong&gt;稀疏数组&lt;/strong&gt;来存储；&lt;/p&gt;
&lt;p&gt;思路分析：&lt;/p&gt;
&lt;p&gt;1.使用稀疏数组，来保留类似前面的二维数组(棋盘、地图等等)&lt;/p&gt;
&lt;p&gt;2.把稀疏数组存盘，并且可以从新恢复原来的二维数组数&lt;/p&gt;
&lt;p&gt;3.整体思路分析&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1653497/201905/1653497-20190531231812497-1072474987.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.代码实现&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('63e31cb1-cfde-4152-b7d2-0519c344be9b')&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_63e31cb1-cfde-4152-b7d2-0519c344be9b&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_63e31cb1-cfde-4152-b7d2-0519c344be9b&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('63e31cb1-cfde-4152-b7d2-0519c344be9b',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_63e31cb1-cfde-4152-b7d2-0519c344be9b&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.sparseArray;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SparseArray {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建一个原始的二维数组 11 * 11
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 0: 表示没有棋子， 1 表示 黑子 2 表蓝子&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; chessArr1[][] = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[11][11&lt;span&gt;];
        chessArr1[&lt;/span&gt;1][2] = 1&lt;span&gt;;
        chessArr1[&lt;/span&gt;2][3] = 2&lt;span&gt;;
        chessArr1[&lt;/span&gt;4][5] = 2&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出原始的二维数组&lt;/span&gt;
        System.out.println(&quot;原始的二维数组~~&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] row : chessArr1) {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt;&lt;span&gt; data : row) {
                System.out.printf(&lt;/span&gt;&quot;%d\t&quot;&lt;span&gt;, data);
            }
            System.out.println();
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将二维数组 转 稀疏数组的思
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1. 先遍历二维数组 得到非0数据的个数&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; sum = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 11; i++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = 0; j &amp;lt; 11; j++&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (chessArr1[i][j] != 0&lt;span&gt;) {
                    sum&lt;/span&gt;++&lt;span&gt;;
                }
            }
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2. 创建对应的稀疏数组&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; sparseArr[][] = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[sum + 1][3&lt;span&gt;];
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 给稀疏数组赋值&lt;/span&gt;
        sparseArr[0][0] = 11&lt;span&gt;;
        sparseArr[&lt;/span&gt;0][1] = 11&lt;span&gt;;
        sparseArr[&lt;/span&gt;0][2] =&lt;span&gt; sum;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 遍历二维数组，将非0的值存放到 sparseArr中&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; count = 0; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;count 用于记录是第几个非0数据&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 11; i++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = 0; j &amp;lt; 11; j++&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (chessArr1[i][j] != 0&lt;span&gt;) {
                    count&lt;/span&gt;++&lt;span&gt;;
                    sparseArr[count][&lt;/span&gt;0] =&lt;span&gt; i;
                    sparseArr[count][&lt;/span&gt;1] =&lt;span&gt; j;
                    sparseArr[count][&lt;/span&gt;2] =&lt;span&gt; chessArr1[i][j];
                }
            }
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出稀疏数组的形式&lt;/span&gt;
&lt;span&gt;        System.out.println();
        System.out.println(&lt;/span&gt;&quot;得到稀疏数组为~~~~&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; sparseArr.length; i++&lt;span&gt;) {
            System.out.printf(&lt;/span&gt;&quot;%d\t%d\t%d\t\n&quot;, sparseArr[i][0], sparseArr[i][1], sparseArr[i][2&lt;span&gt;]);
        }
        System.out.println();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将稀疏数组 --》 恢复成 原始的二维数组&lt;/span&gt;
        &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
         *  1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组，比如上面的  chessArr2 = int [11][11]
            2. 在读取稀疏数组后几行的数据，并赋给 原始的二维数组 即可.
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组&lt;/span&gt;

        &lt;span&gt;int&lt;/span&gt; chessArr2[][] = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[sparseArr[0][0]][sparseArr[0][1&lt;span&gt;]];

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2. 在读取稀疏数组后几行的数据(从第二行开始)，并赋给 原始的二维数组 即可&lt;/span&gt;

        &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = 1; i &amp;lt; sparseArr.length; i++&lt;span&gt;) {
            chessArr2[sparseArr[i][&lt;/span&gt;0]][sparseArr[i][1]] = sparseArr[i][2&lt;span&gt;];
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出恢复后的二维数组&lt;/span&gt;
&lt;span&gt;        System.out.println();
        System.out.println(&lt;/span&gt;&quot;恢复后的二维数组&quot;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] row : chessArr2) {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt;&lt;span&gt; data : row) {
                System.out.printf(&lt;/span&gt;&quot;%d\t&quot;&lt;span&gt;, data);
            }
            System.out.println();
        }
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;代码&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/wanbofeng/DataStructureAndAlgorithms/tree/master/DataStructures/sparseArray&quot; target=&quot;_blank&quot;&gt;代码地址&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;稀疏数组能 降低数据复杂度和减少内存消耗&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 31 May 2019 15:23:00 +0000</pubDate>
<dc:creator>wanbf</dc:creator>
<og:description>稀疏数组(sparseArray) 基本介绍 当一个数组中大部分元素为０，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。 稀疏数组的处理方法是: 1.记录数组一共有几行几列，有多少个不同的值</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/justBobo/p/10958012.html</dc:identifier>
</item>
<item>
<title>Java泛型(T)与通配符？ - 爱我-中华</title>
<link>http://www.cnblogs.com/jinliang374003909/p/10949283.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jinliang374003909/p/10949283.html</guid>
<description>&lt;p&gt;前言：使用泛型的目的是利用Java编译机制，在编译过程中帮我们检测代码中不规范的有可能导致程序错误的代码。例如，我们都知道list容器可以持有任何类型的数据，所以我们可以把String类型和Integer等等同时可以放入同一个list容器中，但这种做法是极其危险的。在泛型机制中这种操作是编译不通过，会强制你修改。故帮我们减少了隐藏的bug.&lt;/p&gt;
&lt;h3&gt;一：泛型  T&lt;/h3&gt;
&lt;h4&gt;1.1  泛型用法&lt;/h4&gt;
&lt;p&gt;根据泛型使用的位置，即用在类(class)，属性(filed)和方法(method)的不同位置，我把它分别总结如下几种&lt;/p&gt;
&lt;p&gt;　　泛型类：即在类名后添加泛型标识(&amp;lt;T ....&amp;gt;)，表示该class持有的一种类型。&lt;/p&gt;
&lt;p&gt;　　泛型属性：泛型属性必须结合泛型类使用，用于接受泛型类持有的类型T&lt;/p&gt;
&lt;p&gt;　　泛型方法：即在方法的返回值前声明泛型&amp;lt;T extends ***&amp;gt;,该泛型T是对该方法的参数T的一种限定。&lt;/p&gt;
&lt;p&gt;　　备注1：如果泛型T没有被extends修饰（包含类和方法），我们称之为无界泛型，如果被extends修饰我们称之为有界泛型如下。&lt;/p&gt;
&lt;p&gt;　　备注2：如果方法参数中有泛型T，而方法的返回类型前没有泛型T，该类型不是泛型方法，而是泛型类。&lt;/p&gt;
&lt;p&gt;　　备注3：泛型方法常用在工具类中(即该方法只是一种工具)，即与类的实例对象关系(持有的方法无关)。&lt;/p&gt;
&lt;p&gt;　　备注4：当泛型方法中的泛型T与类中的泛型T同名时会产生警报，因为编译器不确定你要使用那个(方法中一个，类中也一个)持有对象。&lt;/p&gt;
&lt;h4&gt;1.2  有界泛型&lt;/h4&gt;
&lt;p&gt;　　相较于无界泛型（没有限定类型）&amp;lt;T&amp;gt;的用法，我们可以使用有界泛型&amp;lt;T extends ****&amp;gt;来限定类持有对象的范围，或泛型方法传入该方法参数的范围。以保证业务逻辑的正确执行。&lt;/p&gt;
&lt;p&gt;备注1：有界泛型只有上界(extends)，没有下界的用法(相比于通配符?)。&lt;/p&gt;
&lt;h4&gt;1.3  泛型继承&lt;/h4&gt;
&lt;p&gt;       一行代码加两幅图带你体会它与我们接口，抽象类和类的区别&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
ArrayList&amp;lt;String&amp;gt; arrayList = new ArrayList&amp;lt;&amp;gt;();
Object object = new Object();
//The method add(String) in the type ArrayList&amp;lt;String&amp;gt; is not applicable for the arguments (Object)
&lt;span&gt;arrayList.add(object)&lt;/span&gt;;//因为 ArrayList&amp;lt;String&amp;gt;不是 ArrayList&amp;lt;Object&amp;gt;的子类  。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1596007/201905/1596007-20190530151628867-1308901920.png&quot; alt=&quot;&quot; width=&quot;390&quot; height=&quot;180&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1596007/201905/1596007-20190530151650453-1909320653.png&quot; alt=&quot;&quot; width=&quot;252&quot; height=&quot;175&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;二：通配符？&lt;/h3&gt;
&lt;p&gt;     这是一段java官方对通配符的定义，In generic code, the question mark (&lt;tt&gt;?&lt;/tt&gt;), called the &lt;em&gt;wildcard&lt;/em&gt;, represents an unknown type. The wildcard can be used in a variety of situations: as the type of a parameter, field, or local variable; sometimes as a return type (though it is better programming practice to be more specific). The wildcard is never used as a type argument for a generic method invocation, a generic class instance creation, or a supertype.从这里我们可以看出通配符？是一种未知的类型。&lt;/p&gt;
&lt;p&gt;个人小结：常用在方法上(注意与泛型方法的区别，其不需要再方法的返回类型前声明)&lt;/p&gt;
&lt;h4&gt;2.1 上界通配&lt;/h4&gt;
&lt;p&gt; 　　即定义通配符的上界，用关键字extends声明，例如&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;public static void process（List &lt;/span&gt;&lt;strong&gt;&amp;lt;？extends Foo&amp;gt;&lt;/strong&gt;&lt;span&gt; list）{/ * ... * /}&lt;/span&gt;
&lt;/pre&gt;
&lt;h4&gt;2.2 无界通配&lt;/h4&gt;
&lt;p&gt;　　即不限制通配符的界限，不需要任何关键字修饰‘？’，例如&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;public static void printList（List &amp;lt;？&amp;gt; list）{/*........*/}&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;说明其功能形式 public static void printList（List &amp;lt;Object&amp;gt; list）{/*........*/}，但还是有区别的。&lt;/p&gt;
&lt;p&gt;　　注意：&lt;tt&gt;List &amp;lt;Object&amp;gt;&lt;/tt&gt;&lt;span&gt;和&lt;/span&gt;&lt;tt&gt;List &amp;lt;？&amp;gt;&lt;/tt&gt;&lt;span&gt;&lt;span&gt;是不一样的。List &amp;lt;Object&amp;gt; &lt;/span&gt;&lt;span&gt;可以插入Object&lt;/span&gt;&lt;/span&gt;&lt;span&gt;，或任何Object&lt;/span&gt;&lt;tt&gt;对象的子类&lt;/tt&gt;&lt;span&gt;，成&lt;/span&gt;&lt;tt&gt;列表&amp;lt;对象&amp;gt;&lt;/tt&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;但是你只能&lt;/span&gt;&lt;span&gt;在&lt;/span&gt;&lt;tt&gt;&lt;span&gt;List &amp;lt;？&amp;gt;中&lt;/span&gt;&lt;/tt&gt;&lt;span&gt;插入&lt;/span&gt;&lt;/span&gt;&lt;tt&gt;null()&lt;/tt&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class TestWildcard {
        public  void printList(List&amp;lt;String&amp;gt; list) {
                for (Object elem: list)
                System.out.print(elem + &quot; &quot;);
            System.out.println();
        }
        public  void printList2(List&amp;lt;?&amp;gt; list) {
            for (Object elem: list)
                System.out.print(elem + &quot; &quot;);
            System.out.println();
        }
        public static void main(String[] args) {
                TestWildcard testWildcard = new TestWildcard();
                ArrayList&amp;lt;? extends Object&amp;gt; arrayList = new ArrayList&amp;lt;&amp;gt;();
                ArrayList&amp;lt;Object&amp;gt; arrayList2 = new ArrayList&amp;lt;&amp;gt;();
                arrayList.add(null);
                //arrayList.add(testWildcard);
                arrayList2.add(null);
                arrayList2.add(&quot;2&quot;);
                
                
                List&amp;lt;Integer&amp;gt; li = Arrays.asList(1, 2, 3);
                List&amp;lt;String&amp;gt;  ls = Arrays.asList(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;);
                testWildcard.printList2(li);
                testWildcard.printList2(ls);    
                //testWildcard.printList(li);报错
                testWildcard.printList(ls);
                
        }
}　
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;2.3 下届通配&lt;/h4&gt;
&lt;p&gt;  即定义通配符的下super界，用关键字extends声明，例如&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;public static void addNumbers（List &amp;lt;？super Integer&amp;gt; list）{}&lt;/span&gt;
&lt;/pre&gt;
&lt;h4&gt;2.4 通配子类&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1596007/201905/1596007-20190531163348716-861872287.png&quot; alt=&quot;&quot;/&gt;                                 &lt;img src=&quot;https://img2018.cnblogs.com/blog/1596007/201905/1596007-20190531163356441-367972944.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;The common parent is &lt;tt&gt;List&amp;lt;?&amp;gt;&lt;/tt&gt;.                                                               A hierarchy of several generic &lt;tt&gt;List&lt;/tt&gt; class declarations.&lt;/p&gt;
&lt;h4&gt;2.5 通配捕获与辅助方法&lt;/h4&gt;
&lt;p&gt;通配捕获：即操作通配符？参数  会抛出异常，除null外，例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class WildcardError {
    void foo(List&amp;lt;?&amp;gt; i) {
        i.set(0, i.get(0));
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;分析：根据编译器推断,?是一个Object类型(故可以遍历出？所代表的对象)，但如果要操作List&amp;lt;?&amp;gt;对象,编译器会要求？代表的具体类型，而编译器通过现有的规则(真对 ？的规则)是不允许的，故会包错。&lt;/p&gt;
&lt;p&gt;解决捕获辅助方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class WildcardFixed {
    void foo(List&amp;lt;?&amp;gt; i) {
        fooHelper(i);
    }
    // Helper method created so that the wildcard can be captured
    // through type inference.
    private &amp;lt;T&amp;gt; void fooHelper(List&amp;lt;T&amp;gt; l) {
        l.set(0, l.get(0));
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　通过一个辅助方法  ***  fooHelper(List&amp;lt;T&amp;gt; l){}就解决了&lt;/p&gt;
&lt;p&gt;分析：根据规则(真对T)，编译器就知道T的具体类型，故可以安全的操作该对象。&lt;/p&gt;
&lt;p&gt;三：小结&lt;/p&gt;
&lt;p&gt;泛型与通配符区别：最根本的区别就是，java编译器，把T(泛型)推断成具体类型，而把通配符?推断成未知类型。而java编辑器只能操作具体类型，不能操作未知类型。导致如果有对参数有修改的操作就必须要使用泛型，如果仅是查看就可以使用通配符.&lt;/p&gt;
&lt;p&gt;利用以上推断，我们可以利用通配符特性设计出安全的接口，比如我在一个接口的方法定义了通配符参数，则继承该接口的所有方法，都不能修改该方法传递过来的参数。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
public interface GInterface {
        
        &amp;lt;T&amp;gt; void foo(List&amp;lt;? extends T&amp;gt; list);
}



public class GIterfaceImpl implements GInterface{

        @Override
        public &amp;lt;T&amp;gt; void foo(List&amp;lt;? extends T&amp;gt; list) {
                /**
                 * 只能遍历list，不能修改list
                 */
                for (T t : list) {
                        System.out.println(t);
                }
                //list.add(new Object());
        }
        
        public static void main(String[] args) {
                GIterfaceImpl gIterfaceImpl = new GIterfaceImpl();
                ArrayList&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
                list.add(&quot;1&quot;);
                gIterfaceImpl.foo(list);
                
        }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;四：延伸&lt;/p&gt;
&lt;p&gt;泛型与java8:&lt;/p&gt;
&lt;p&gt;参考资料：&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/generics/index.html&quot;&gt;https://docs.oracle.com/javase/tutorial/java/generics/index.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 31 May 2019 15:06:00 +0000</pubDate>
<dc:creator>爱我-中华</dc:creator>
<og:description>前言：使用泛型的目的是利用Java编译机制，在编译过程中帮我们检测代码中不规范的有可能导致程序错误的代码。例如，我们都知道list容器可以持有任何类型的数据，所以我们可以把String类型和Integ</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jinliang374003909/p/10949283.html</dc:identifier>
</item>
</channel>
</rss>