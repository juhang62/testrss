<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>jenkins手把手教你从入门到放弃03-安装Jenkins时web界面出现该jenkins实例似乎已离线 - 北京-宏哥</title>
<link>http://www.cnblogs.com/du-hong/p/10655635.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/du-hong/p/10655635.html</guid>
<description>&lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt;　　很久没有安装jenkins了，因为之前用的的服务器一直正常使用，令人郁闷的是，之前用jenkins一直没出过这个问题。&lt;/p&gt;
&lt;p&gt;令人更郁闷的是，我尝试了好多个历史版本和最新版本，甚至从之前的服务器把jenkins在跑的程序打包copy这个服务器。终究还是不行。&lt;/p&gt;
&lt;p&gt;　　启动时候，提示：该jenkins实例似乎已离线&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可以说是非常坑！！！！！！！！！！！！！！！！！！！！！！！！！！！！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　虽然可以离线安装，但是对于博主来说不解决怎么行呢？经过一番踩坑与资料查找终于解决了，这里与大家分享一下：&lt;/p&gt;
&lt;p&gt;问题如图下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201904/1232840-20190404163750216-2053226918.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;解决上述问题方法：&lt;/p&gt;
&lt;p&gt;1)    修改/var/lib/jenkins/updates/default.json&lt;/p&gt;
&lt;p&gt;jenkins在下载插件之前会先检查网络连接，其会读取这个文件中的网址。默认是：&lt;/p&gt;
&lt;p&gt;访问谷歌，这就很坑了，服务器网络又不能FQ，肯定监测失败呀，不得不说jenkins的开发者脑子锈了，所以将图下的google改为&lt;a href=&quot;http://www.baidu.com/&quot;&gt;www.baidu.com&lt;/a&gt;即可，更改完重启服务。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1235834/201807/1235834-20180723182817537-757932915.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2)    修改/var/lib/jenkins/hudson.model.UpdateCenter.xml&lt;/p&gt;
&lt;p&gt;该文件为jenkins下载插件的源地址，改地址默认jenkins默认为：&lt;a href=&quot;https://updates.jenkins.io/update-center.json&quot;&gt;https://updates.jenkins.io/update-center.json&lt;/a&gt;，就是因为https的问题，此处我们将其改为http即可，之后重启jenkins服务即可。&lt;/p&gt;
&lt;p&gt;其他国内备用地址（也可以选择使用）：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json&quot;&gt;https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mirror.esuni.jp/jenkins/updates/update-center.json&quot;&gt;http://mirror.esuni.jp/jenkins/updates/update-center.json&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; 3）安装插件那个页面，就是提示你offline的那个页面，不要动。然后打开一个新的tab，输入网址&lt;a href=&quot;https://link.jianshu.com?t=http%3A%2F%2Flocalhost%3A8080%2FpluginManager%2Fadvanced&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;http://localhost:8080/jenkins/pluginManager/advanced&lt;/a&gt;。 这里面最底下有个【升级站点】，把其中的链接改成http的就好了，&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://link.jianshu.com?t=http%3A%2F%2Fupdates.jenkins.io%2Fupdate-center.json&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;http://updates.jenkins.io/update-center.json&lt;/a&gt;。 然后在服务列表中关闭jenkins，再启动，这样就能正常联网了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201904/1232840-20190404164648213-1597658731.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在修复完之后，我们发现离线问题已经解决，如图下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201904/1232840-20190409091022844-1176970967.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样我们就可以愉快地安装插件了。&lt;/p&gt;
</description>
<pubDate>Thu, 30 May 2019 15:56:00 +0000</pubDate>
<dc:creator>北京-宏哥</dc:creator>
<og:description>简介 很久没有安装jenkins了，因为之前用的的服务器一直正常使用，令人郁闷的是，之前用jenkins一直没出过这个问题。 令人更郁闷的是，我尝试了好多个历史版本和最新版本，甚至从之前的服务器把je</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/du-hong/p/10655635.html</dc:identifier>
</item>
<item>
<title>ubuntu16.04安装CUDA 8.0（很详尽，包括一些坑的解决方法） - left4back</title>
<link>http://www.cnblogs.com/left4back/p/10952845.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/left4back/p/10952845.html</guid>
<description>&lt;p&gt;每次配置环境都头疼得要死，总是会遇到各种各样的问题，这次决心一劳永逸地解决这个问题，踩最多的坑，装最稳的环境。&lt;/p&gt;
&lt;p&gt;先介绍用于测试的电脑：操作系统是在清华镜像上下载的ubuntu16.04LTS，内核版本是4.15.0-29-generic，电脑是联想Y430P，显卡我没记错的话是GTX850M。&lt;/p&gt;
&lt;p&gt;本篇绝大部分操作需要管理员权限，即sudo，也许不把cuda安装到/usr/lib而是自己的home目录下可以不用sudo权限，但我没有尝试，有兴趣的可以自己尝试一下。&lt;/p&gt;
&lt;p&gt;一、更换内核&lt;/p&gt;
&lt;p&gt;CUDA8.0最高仅支持4.4版本内核，因此第一步工作就是更换系统内核。如你的内核不高于4.4，可以跳过整个该步骤。&lt;/p&gt;
&lt;p&gt;先介绍两个命令，一个是sudo dpkg --get-selections|grep linux-image，该命令会检查apt下载的所有linux-image开头的包，也就是内核；另外一个命令是uname -r，该命令返回结果是当前系统所用内核版本。&lt;/p&gt;
&lt;p&gt;在我自己的电脑上，命令行敲入sudo dpkg --get-selections|grep linux-image并执行，返回了四个结果，分别为：&lt;/p&gt;
&lt;p&gt;linux-image-4.15.0-29-generic&lt;/p&gt;
&lt;p&gt;linux-image-4.4.0-148-generic&lt;/p&gt;
&lt;p&gt;linux-image-generic&lt;/p&gt;
&lt;p&gt;linux-image-generic-hwe-16.04&lt;/p&gt;
&lt;p&gt;执行uname -r返回的结果是linux-image-4.15.0-29-generic，说明我当前使用的内核版本是第一个。&lt;/p&gt;
&lt;p&gt;关于内核操作的详细解释，请参考附录1，为保证正文简洁，只记录如何更换内核。&lt;/p&gt;
&lt;p&gt;首先用grep menuentry /boot/grub/grub.cfg命令查看有哪些内核，如没有需要的内核可以用apt-get下载（这个我没有尝试，因为系统自带了一个4.4）。我执行这个命令后显式如下图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1598080/201905/1598080-20190530235350939-1827505529.png&quot; alt=&quot;&quot; width=&quot;1063&quot; height=&quot;598&quot;/&gt;&lt;/p&gt;

&lt;p&gt;我想要将linux-image-4.15.0-29-generic修改为linux-image-4.4.0-148-generic，执行sudo vim /etc/default/grub，打开grub设置文件，将GRUB_DEFAULT=0改为GRUB_DEFAULT='Advanced options for Ubuntu&amp;gt;Ubuntu, with Linux 4.4.0-148-generic'。随后执行sudo update-grub，如无错误提示，即意味着/boot/grub/grub.cfg修改成功，然后sudo reboot重启电脑。注意，重启电脑后，本来光标默认位置应该在Ubuntu，现在光标位置默认在Ubuntu的下一行，即Advanced options for Ubuntu，直接回车进入，下一个界面光标的默认位置应该在Ubuntu, with Linux 4.4.0-148-generic，直接回车即可。进入界面，uname -r检查显示更改内核成功。&lt;/p&gt;
&lt;p&gt;这里我本来是希望可以直接登入Ubuntu即是更改后的内核，但尝试了很多方法，最终都必须通过Advanced options for Ubuntu修改加载内核，如果有高手搞定了，还请不吝赐教。&lt;/p&gt;
&lt;p&gt;此外，如果你是强迫症患者，但又不知道如何处理这种情况，可以选择将Kernel 4.15直接删掉，但我个人认为这个方法不够优雅，因此不列出了。&lt;/p&gt;
&lt;p&gt;二、禁用nouveau&lt;/p&gt;
&lt;p&gt;简单介绍一下nouveau，简单来说它和nvidia系列有冲突，不禁用的话可能会导致黑屏或循环登陆，因此一定要禁掉。&lt;/p&gt;
&lt;p&gt;这里提供一个不太一样的禁用方法，这种方法不需要重启电脑。&lt;/p&gt;
&lt;p&gt;分为四部：1.首先ctrl+alt+f1切换到命令行界面，输入账号密码登录；2.然后sudo service lightdm stop关闭图形界面；3.sudo modprobe -r nouveau将nouveau彻底干掉；4.执行lsmod | grep nouveau返回空说明nouveau已经清理干净。&lt;/p&gt;
&lt;p&gt;modeprobe是内核模块管理一个很好用的工具，这里不做具体介绍了，详情请参考鸟哥的linux私房菜19章。&lt;/p&gt;
&lt;p&gt;三、安装CUDA&lt;/p&gt;
&lt;p&gt;终于到了安装CUDA的步骤了，在禁用nouveau后，不要急着启用lightdm，转到cuda安装文件所在目录，用sudo命令进行安装，我的cuda安装文件名为cuda_8.0.61_375.26_linux.run，记得要禁用opengl，所以我的命令就是sudo ./cuda_8.0.61_375.26_linux.run --no-opengl-lib，禁用opengl据说是为了防止和系统原有的opengl冲突。其余默认安装即可。&lt;/p&gt;
&lt;p&gt;四、测试CUDA是否安装成功&lt;/p&gt;
&lt;p&gt;转到sample保存目录，像我在安装过程中用的默认保存位置，因此它们在我的~/NVIDIA_CUDA-8.0_Samples/目录下，在这个目录下，进入./1_Utilities/deviceQuery/，在这个目录下make然后执行./deviceQuery。如果出现如下画面说明CUDA安装成功。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1598080/201905/1598080-20190530235238255-2025167843.png&quot; alt=&quot;&quot; width=&quot;951&quot; height=&quot;535&quot;/&gt;&lt;/p&gt;


&lt;p&gt;五、其他坑&lt;/p&gt;
&lt;p&gt;说点其他比较零碎的坑。&lt;/p&gt;
&lt;p&gt;1.首当其冲就是安装CUDA结束时，安装程序提醒一切就绪，但是测试不通过，nvidia-smi也无法执行，但是nvcc -V显示结果无误。&lt;/p&gt;
&lt;p&gt;这个问题的解决方法是我误打误撞试出来的，具体为什么我也不清楚，搜了很久也没找到答案。解决方法是这样的，用sudo apt-get install nvidia-375安装显卡驱动，然后重启两遍（对的，重启一遍没用，绝望之下我又重启了一遍），一切问题消失，出现了测试结果中的截图，nvidia-smi也能正确工作了。&lt;/p&gt;
&lt;p&gt;2.用blacklist方式禁用nouveau的时候，禁用掉的是4.15核的nouveau，禁不掉4.4核的，所以我一怒之下，直接把nouveau干掉了，问题解决。&lt;/p&gt;
&lt;p&gt;至此CUDA已经顺利安装，后续会尝试在另一台电脑上安装CUDA，并在这个帖子更新安装结果。此外还会在下一篇文章尝试不用sudo安装caffe的其他依赖。&lt;/p&gt;

&lt;p&gt;附录1：内核操作的详细解释（由鸟哥的linux私房菜（基础篇）19章部分内容总结）&lt;/p&gt;
&lt;p&gt;先简单介绍一下系统启动流程：1.加载BIOS的硬件信息并进行自我检查，并根据设置读取第一个可启动的设备；2.读取并执行第一个启动设备内MBR的启动引导程序（linux的启动引导程序一般为grub或grub2）；3.根据启动引导程序的设置加载Kernel，Kernel会开始检测硬件并加载驱动程序；4.余下部分主要是systemd部分，暂且不提。其中启动引导程序又被称为boot loader，主要提供三个功能：1.提供选项，是多重引导的重要功能；2.加载内核文件；3.转交其他loader，是实现linux和win双系统的重要功能。&lt;/p&gt;
&lt;p&gt;借由boot loader读取内核文件，内核开始从BIOS手中接管硬件，一般来说内核文件保存在/boot目录下，以vmlinuz开头，比如我的内核文件绝对路径为/boot/vmlinuz-4.15.0-29-generic。除kernel以外，boot loader还会读取initrd（虚拟文件系统），这里暂不表。&lt;/p&gt;
&lt;p&gt;boot loader分为两个阶段：1.执行boot loader主程序，没有安装loader的相关配置文件；2.主程序加载配置文件，一般都在/boot/grub/（或/boot/grub2/，我的系统是/boot/grub/目录）目录下。其中最重要的就是配置文件grub.cfg。官方不建议手动修改grub.cfg文件，而是通过grub-mkconfig（grub2-mkconfig）命令产生新的grub.cfg文件。配置文件的内容简介详情见鸟哥的linux私房菜（基础篇）19章。&lt;/p&gt;

&lt;p&gt;参考文献：&lt;/p&gt;
&lt;p&gt;https://www.linkedin.com/pulse/installing-nvidia-cuda-80-ubuntu-1604-linux-gpu-new-victor 这篇文章介绍了很多安装CUDA中常见的坑，囿于自身水平，其中部分方法在我这里是失效的，但我不知道原因。&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/yhaolpz/article/details/71375762 这是一篇特别详尽的介绍安装caffe的博客&lt;/p&gt;
&lt;p&gt;鸟哥的linux私房菜&lt;/p&gt;
</description>
<pubDate>Thu, 30 May 2019 15:55:00 +0000</pubDate>
<dc:creator>left4back</dc:creator>
<og:description>每次配置环境都头疼得要死，总是会遇到各种各样的问题，这次决心一劳永逸地解决这个问题，踩最多的坑，装最稳的环境。 先介绍用于测试的电脑：操作系统是在清华镜像上下载的ubuntu16.04LTS，内核版本</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/left4back/p/10952845.html</dc:identifier>
</item>
<item>
<title>WebAssembly 上手 - 刘哇勇</title>
<link>http://www.cnblogs.com/Wayou/p/webassembly_quick_start.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Wayou/p/webassembly_quick_start.html</guid>
<description>&lt;h2&gt;环境配置&lt;/h2&gt;
&lt;p&gt;通过官方 &lt;a href=&quot;https://webassembly.org/getting-started/developers-guide/&quot; rel=&quot;nofollow&quot;&gt;WebAssembly - Developer’s Guide&lt;/a&gt; 提供的安装配置步骤进行环境相关设置。这里以 macOS 为例。&lt;/p&gt;
&lt;h3&gt;下载工具链&lt;/h3&gt;
&lt;p&gt;通过 clone emscripten 仓库到本地进行工具链（toolchain）的下载安装。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
$ git clone https://github.com/emscripten-core/emsdk.git
$ &lt;span class=&quot;pl-c1&quot;&gt;cd&lt;/span&gt; emsdk
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;安装及配置&lt;/h3&gt;
&lt;p&gt;执行安装：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ ./emsdk install latest
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;激活工具链，生成相应环境配置：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
$ ./emsdk activate latest
&lt;/pre&gt;&lt;/div&gt;
&lt;details readability=&quot;7&quot;&gt;`./emsdk activate latest` 命令的输出
&lt;pre&gt;
&lt;code&gt;$ ./emsdk activate latest
Writing .emscripten configuration file to user home directory /Users/wayou/
The Emscripten configuration file /Users/wayou/.emscripten has been rewritten with the following contents:

import os
LLVM_ROOT = '/Users/wayou/dev/emsdk/fastcomp/fastcomp/bin'
BINARYEN_ROOT = '/Users/wayou/dev/emsdk/fastcomp'
NODE_JS = '/Users/wayou/dev/emsdk/node/8.9.1_64bit/bin/node'
SPIDERMONKEY_ENGINE = ''
V8_ENGINE = ''
TEMP_DIR = '/var/folders/qr/dlqjq3zj10xgf2xfx3mybn500000gn/T'
COMPILER_ENGINE = NODE_JS
JS_ENGINES = [NODE_JS]

To conveniently access the selected set of tools from the command line, consider adding the following directories to PATH, or call 'source ./emsdk_env.sh' to do this for you.

   /Users/wayou/dev/emsdk:/Users/wayou/dev/emsdk/fastcomp/emscripten:/Users/wayou/dev/emsdk/node/8.9.1_64bit/bin
Set the following tools as active:
   releases-fastcomp-3b8cff670e9233a6623563add831647e8689a86b-64bit
   node-8.9.1-64bit
&lt;/code&gt;
&lt;/pre&gt;&lt;/details&gt;&lt;p&gt;&lt;strong&gt;小贴士&lt;/strong&gt;：其中 install 过程会从 &lt;code&gt;https://chromium.googlesource.com&lt;/code&gt;，&lt;code&gt;https://storage.googleapis.com&lt;/code&gt; 及 &lt;code&gt;https://s3.amazonaws.com&lt;/code&gt; 域下载东西，所以最好在命令行配置相应代理，否则安装会失败。&lt;/p&gt;
&lt;h3&gt;环境变量&lt;/h3&gt;
&lt;p&gt;通过执行以下命令添加相应命令及目录到环境变量以方便调用：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
$ &lt;span class=&quot;pl-c1&quot;&gt;source&lt;/span&gt; ./emsdk_env.sh --build=Release
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果进行到这一步发生如下错误：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
$ &lt;span class=&quot;pl-c1&quot;&gt;source&lt;/span&gt; ./emsdk_env.sh --build=Release
./emsdk_env.sh (line 19): Missing end to balance this &lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; statement
&lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; [ &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;$SRC&lt;/span&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; ]&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;then&lt;/span&gt;
^
from sourcing file ./emsdk_env.sh
    called on standard input

source: Error &lt;span class=&quot;pl-k&quot;&gt;while&lt;/span&gt; reading file &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;./emsdk_env.sh&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这多半是因为你用的 shell 是 &lt;a href=&quot;https://fishshell.com&quot; rel=&quot;nofollow&quot;&gt;fish&lt;/a&gt; 语法不兼容的原因。&lt;/p&gt;
&lt;p&gt;两个解决办法：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot;&gt;
&lt;pre&gt;
$ bash ./emsdk_env.sh
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;因为其也提供了对应的 &lt;code&gt;.fish&lt;/code&gt; 脚本，所以，也可以直接选择运行该 fish 脚本来解决上面语法报错的问题：&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
$ &lt;span class=&quot;pl-c1&quot;&gt;source&lt;/span&gt; ./emsdk_env.fish
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行成功的输出：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
$ &lt;span class=&quot;pl-c1&quot;&gt;source&lt;/span&gt; ./emsdk_env.fish
Adding directories to PATH:
PATH += /Users/wayou/dev/emsdk

Setting environment variables:
EMSDK = /Users/wayou/dev/emsdk
EM_CONFIG = /Users/wayou/.emscripten
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;检查安装&lt;/h3&gt;
&lt;p&gt;完成上面步骤后，可通过运行 &lt;code&gt;emcc --version&lt;/code&gt; 命令查看是否安装成功：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot;&gt;
&lt;pre&gt;
$ emcc --version
&lt;/pre&gt;&lt;/div&gt;
&lt;details readability=&quot;2.5&quot;&gt;`emcc --version` 命令的输出
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
$ emcc --version
cache:INFO: generating system asset: is_vanilla.txt... (this will be cached &lt;span class=&quot;pl-k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;/Users/wayou/.emscripten_cache/is_vanilla.txt&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;for&lt;/span&gt; subsequent builds)
cache:INFO:  - ok
emcc (Emscripten gcc/clang-like replacement) 1.38.33 (commit 0490c5f7aaf0e61aafd3b4cfe22cc56b803026b1)
Copyright (C) 2014 the Emscripten authors (see AUTHORS.txt)
This is free and open &lt;span class=&quot;pl-c1&quot;&gt;source&lt;/span&gt; software under the MIT license.
There is NO warranty&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt; not even &lt;span class=&quot;pl-k&quot;&gt;for&lt;/span&gt; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
&lt;/pre&gt;&lt;/div&gt;
&lt;/details&gt;&lt;p&gt;&lt;strong&gt;小贴士&lt;/strong&gt;：新开命令行窗口或重启命令行后，需要重新执行 &lt;code&gt;source&lt;/code&gt; 命令，可将其添加到你所使用的命令行的配置文件中，&lt;code&gt;.bash_profile&lt;/code&gt;，&lt;code&gt;.zshrc&lt;/code&gt;，或 &lt;code&gt;.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;以 fish 为例：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;~/.config/fish/config.fish.fish&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-c1&quot;&gt;source&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;/Users/wayou/dev/emsdk/emsdk_env.fish&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样每次启动命令行后 &lt;code&gt;emcc&lt;/code&gt; 都是可用状态。&lt;/p&gt;
&lt;h2&gt;编译及运行&lt;/h2&gt;
&lt;p&gt;安装配置完成后，便可以尝试编译并运行一个简单的 demo 程序了。&lt;/p&gt;
&lt;p&gt;一些注意点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;运行 &lt;code&gt;emcc&lt;/code&gt; 时需要指定 &lt;code&gt;-s WASM=1&lt;/code&gt; 参数，否则情况下其输出为 &lt;code&gt;asm.js&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;除了生成 Wasm 二进制文件及对应的 JavaScript 封装，如果还想要生成一个可直接查看的 HTML 页面，可在输出时指定一个后缀为 &lt;code&gt;.html&lt;/code&gt; 的文件。&lt;/li&gt;
&lt;li&gt;实际运行时不能直接打开这个生成的 HTML 文件，因为 &lt;code&gt;file:///&lt;/code&gt; 协议不支持跨域，所以需要本地启一个服务器来查看。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;编写 Hello World&lt;/h3&gt;
&lt;p&gt;创建 &lt;code&gt;hello.c&lt;/code&gt; 文件并输出以下内容：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;hello.c&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-c&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
#&lt;span class=&quot;pl-k&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&amp;lt;&lt;/span&gt;stdio.h&lt;span class=&quot;pl-pds&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;main&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;pl-k&quot;&gt;char&lt;/span&gt; ** argv) {
  &lt;span class=&quot;pl-c1&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;Hello, world!&lt;span class=&quot;pl-cce&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;编译&lt;/h3&gt;
&lt;p&gt;执行以下命令进行编译：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
$ emcc hello.c -s WASM=1 -o hello.html
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;运行&lt;/h3&gt;
&lt;p&gt;通过工具链中提供的 &lt;code&gt;smrun&lt;/code&gt; 来开启一个本地服务器以查看刚刚生成的程序：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
$ emrun --no_browser --port 8080 &lt;span class=&quot;pl-c1&quot;&gt;.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然，使用其他任意 server 也是可以的，比如 Python 的：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
$ python -m http.server 8080
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;启动成功后浏览器访问 &lt;a rel=&quot;nofollow&quot; href=&quot;http://localhost:8080/hello.html&quot;&gt;http://localhost:8080/hello.html&lt;/a&gt;。不出意外你会看到页面中 Emscripten 的控制台展示了 &lt;code&gt;Hello, world!&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://user-images.githubusercontent.com/3783096/58644777-8e45fc00-8334-11e9-81cb-b4d27945df56.png&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/3783096/58644777-8e45fc00-8334-11e9-81cb-b4d27945df56.png&quot; alt=&quot;WebAssembly Hello Wrold 运行效果&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;WebAssembly Hello Wrold 运行效果&lt;/p&gt;
&lt;h2&gt;相关资源&lt;/h2&gt;
</description>
<pubDate>Thu, 30 May 2019 15:49:00 +0000</pubDate>
<dc:creator>刘哇勇</dc:creator>
<og:description>环境配置 通过官方 WebAssembly Developer’s Guide 提供的安装配置步骤进行环境相关设置。这里以 macOS 为例。 下载工具链 通过 clone emscripten 仓库</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Wayou/p/webassembly_quick_start.html</dc:identifier>
</item>
<item>
<title>无聊吗？写个【飞机大战】来玩吧（下篇） - web前端talk</title>
<link>http://www.cnblogs.com/migufe/p/10952822.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/migufe/p/10952822.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIwMjIwNDU2Mw==&amp;amp;mid=2651586340&amp;amp;idx=1&amp;amp;sn=1fb41264fbb9d0fdb2d4df3dff36ec7a&amp;amp;chksm=8d1d6bd8ba6ae2ceac4a62080b2fef8a1abca9981705ae5c73a9cb572a87c958639cc495f82a&amp;amp;token=1297427883&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;上一篇&lt;/a&gt;介绍了如何使用cocos creator开发游戏，此篇是详细介绍功能点以及如何部署打包至微信小游戏体验。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;资源管理制作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、准备工具&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;cocos creatorv2.0.5官方最新版本、sublime tetx3或vscode、texturePackerGUI、微信小程序开发工具&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、sprite，图集资源制作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1）图集列表类似于UI里的瀑布流图，将所有的.png .jpg .jpeg图片合并压缩为一个图集资源。&lt;/p&gt;

&lt;p&gt;（2）使用texturePackerGUI工具，打开工具，将本机示例图片文件夹下所有.jpg拖入至左处empty...&lt;/p&gt;

&lt;p&gt;左图为未拖入图片的，右图为已拖入图片&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1683421/201905/1683421-20190530234131874-786337046.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Data file是设置cocos图集.plist文件保存路径，texture file是.png保存路径，max size是设置最大尺寸&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1683421/201905/1683421-20190530234145401-848641077.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击publish sprite sheet保存文件，由于系统的图片较大，max size设置为3072之后才能publish，生成后的.png文件巨大，不建议每个图片文件超过100kb以上进行合并。再从cocos creator工具中查看，图集atlas制作完毕&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1683421/201905/1683421-20190530234205397-1622116483.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、动画animationClip制作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1）准备多个静态图，在层级下新增一个空节点，添加sprite、animation组件，sprite拖入一个静止时的背景图，选中当前节点，选择下方动画编辑器，新建clip文件，保存在animation文件夹下，此时文件夹下多了一个textAni，点击红框内编辑动画。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1683421/201905/1683421-20190530234240191-964485861.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;属性列表中选择cc.Sprite.spriteFrame，是插入帧图片属性，比如每0.1间隔插入一帧图片，每帧图片所展示的效果渐渐呈现，线性时间内播放动画。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1683421/201905/1683421-20190530234252336-1952985782.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Animation组件有
position，x，y，
scale，scaleX，scaleY，rotation，
width，height，color，opacity，
anchorX，anchorY，skewX，skewY，
cc.Sprite.spriteFrame、
cc.Sprite.fillType，
cc.Sprite.fillCenter，
cc.Sprite.fillStart，
cc.Sprite.fillRange，
这些属性都将影响到动画帧效果。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（2）将textAni Clip拖入至对应节点&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1683421/201905/1683421-20190530234445912-1882488685.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、prefab制作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1）创建空节点拖入至资源管理器的prefab文件夹，点击该prefab，右侧可添加任意组件，例如：渲染组件-&amp;gt;Label，修改string为“hello world！！！”&lt;/p&gt;
&lt;p&gt;（2）如何获取prefab，新增命名为test的JavaScript脚本，编辑脚本，在properties申明&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
testPrefab: cc.Prefab,
btn: cc.Node,
bg: cc.Node,
_num:&lt;/span&gt;1&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1683421/201905/1683421-20190530234527531-1696369517.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在onload函数中创建对象池this.pipePool = new cc.NodePool();申明createPre函数，用于挂载在开始游戏button节点，按钮每点击一次从对象池拿出prefab对象，重新计算并给定y轴位置，渲染到bg节点。&lt;/p&gt;
&lt;p&gt;关键代码：this.pipePool.put(tPrefab);&lt;/p&gt;
&lt;p&gt;官方说法是向缓冲池中存入一个不再需要的节点对象。这个函数会自动将目标节点从父节点上移除，但是不会进行 cleanup 操作；如果想让节点一直存在，则不使用该方法（当生成的节点过多时，占用内存过大，导致性能问题，需要及时释放）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1683421/201905/1683421-20190530234549665-811028860.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5、audioClip&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;音乐资源，和图片一样直接拖入到sound下即可，一般以.mp3文件为准&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;游戏部署&lt;/strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、准备工作：微信小游戏appid，微信小游戏开发权限（公众号，或小程序上可申请），可https访问的服务器管理权限；&lt;/p&gt;
&lt;p&gt;2、cocos creator2.0以上提供了构建打包至多平台功能，可以直接打包成微信小游戏包，选择工具菜单栏-&amp;gt;项目-&amp;gt;构建发布，根据打包环境要求，选择发布平台，这里选择wechat game，初始场景为游戏加载时第一场景展示，填写微信小游戏appid，填写远程resource服务器地址，也可不填。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1683421/201905/1683421-20190530234630208-103360844.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;构建打包成功之后，打开微信小程序开发工具，选择小游戏，点击+选中刚打包后的项目路径；&lt;/p&gt;
&lt;p&gt;由于微信小游戏打包发布，代码体积被限制4M之内，我们不得不优化。唯一能动的是res资源文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1683421/201905/1683421-20190530234647958-1134069827.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;先关闭微信小游戏项目，将资源文件夹res移除，上传res文件夹到远程服务器下，可通过https访问到即可，再重新打开微信小程序开发工具，设置game.js。&lt;/p&gt;
&lt;p&gt;wxDownloader.REMOTE_SERVER_ROOT = ‘你的远程服务器res绝对路径’;这样打包体积就缩小一半以上。点击右上角上传，显示为体验版，点击确定，填写发布信息后上传。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1683421/201905/1683421-20190530234706266-1777727021.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;游戏体验&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、在游戏未正式发布前，无法直接通过小程序搜索进行游戏，需要添加体验号。&lt;/p&gt;
&lt;p&gt;2、由于开发者本人就是管理员，可以直接进行游戏&lt;/p&gt;
&lt;p&gt;3、微信游戏体验预览图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1683421/201905/1683421-20190530234729272-1673719789.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 30 May 2019 15:48:00 +0000</pubDate>
<dc:creator>web前端talk</dc:creator>
<og:description>上一篇介绍了如何使用cocos creator开发游戏，此篇是详细介绍功能点以及如何部署打包至微信小游戏体验。 资源管理制作 1、准备工具 cocos creatorv2.0.5官方最新版本、subl</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/migufe/p/10952822.html</dc:identifier>
</item>
<item>
<title>SQL高级查询 - 十五小哥哥</title>
<link>http://www.cnblogs.com/wanghj-15/p/10952746.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wanghj-15/p/10952746.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;本文主要是对下图的查询方式的条件判断进行讲解：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1697796/201905/1697796-20190530222958715-18485424.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果还有更多的查询条件，只要在下面方法中加入相对应的字段，然后添加相应的get和set方法，最后在&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;getQueryCondition方法中加入相对应的条件判断语句if就可以了。&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SqlCondition {
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;职位：用于查询的条件判断&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String  title;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;职位类型：用于查询的条件判断&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer positiontype;
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; SqlCondition() {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getTitle() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; title;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setTitle(String title) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.title =&lt;span&gt; title;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer getPositiontype() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; positiontype;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setPositiontype(Integer positiontype) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.positiontype =&lt;span&gt; positiontype;
    }
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 查询语句的条件判断
     * 方法一（推荐使用）：
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getQueryCondition_01(){
        String whereSql&lt;/span&gt;=&quot;&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(title !=&lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !&quot;&quot;&lt;span&gt;.equals(title)){
            whereSql &lt;/span&gt;+= &quot; and title like '%&quot;+title+&quot;%'&quot;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(positiontype!=&lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !&quot;&quot;&lt;span&gt;.equals(positiontype)){
            whereSql&lt;/span&gt;+=&quot; and positiontype = &quot;+&lt;span&gt;positiontype;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;replace:替换；First:第一个&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; whereSql.replaceFirst(&quot;and&quot;, &quot;where&quot;&lt;span&gt;);
    }
        
     &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 查询语句的条件判断
     * 方法二（不推荐使用）： where 1==1 会影响查询的性能
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getQueryCondition_02(){
        String  whereSql &lt;/span&gt;= &quot;where 1==1&quot;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(title != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !&quot;&quot;&lt;span&gt;.equals(title)){
            whereSql&lt;/span&gt;+= &quot;and title like '%&quot;+title+&quot;%'&quot;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(positiontype !=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            whereSql &lt;/span&gt;+= &quot;and positiontype = &quot; +&lt;span&gt;positiontype;
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; whereSql;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 查询语句的条件判断
     * 方法三（准备一个标识(即一个flag)
         如果标识是true,条件前就加where,如果是false，条件前就加and）：
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getQueryCondition_03(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;标识：flag&lt;/span&gt;
        &lt;span&gt;boolean&lt;/span&gt; flag = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        String whereSql &lt;/span&gt;= &quot;&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;title不为null,并且不为空字符串&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(title!=&lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !&quot;&quot;&lt;span&gt;.equals(title)){
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(flag){
                whereSql&lt;/span&gt;+= &quot; where &quot;&lt;span&gt;;
                flag &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                whereSql&lt;/span&gt;+= &quot; and &quot;&lt;span&gt;;
            }
            whereSql &lt;/span&gt;+= &quot; title like '%&quot;+title+&quot;%' &quot;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(positiontype!=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(flag){
                whereSql&lt;/span&gt;+= &quot; where &quot;&lt;span&gt;;
                flag &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                whereSql&lt;/span&gt;+= &quot; and &quot;&lt;span&gt;;
            }
            whereSql &lt;/span&gt;+= &quot; positiontype = &quot;+&lt;span&gt;positiontype;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; whereSql;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 查询语句的条件判断
     * 方法四（准备一个集合）：
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getQueryCondition_04(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;准备一个集合(里面会装咱们的所有条件)&lt;/span&gt;
        List&amp;lt;String&amp;gt; sqlList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();

        String whereSql &lt;/span&gt;= &quot;&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;title不为null,并且不为空字符串&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(title!=&lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !&quot;&quot;&lt;span&gt;.equals(title)){
            sqlList.add(&lt;/span&gt;&quot; title like '%&quot;+title+&quot;%' &quot;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(positiontype!=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            sqlList.add(&lt;/span&gt;&quot; positiontype = &quot;+&lt;span&gt;positiontype);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;查询条件加多了，只要在这加if语句就可以了
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历这个集合&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; sqlList.size(); i++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(i==0&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一次循环，前面肯定是加where&lt;/span&gt;
                whereSql += &quot; where &quot;&lt;span&gt;;
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第2-n次循环，前面肯定是加and&lt;/span&gt;
                whereSql += &quot; and &quot;&lt;span&gt;;
            }
            whereSql &lt;/span&gt;+=&lt;span&gt; sqlList.get(i);
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; whereSql;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后在需要的SQL语句中引入条件判断方法即可。&lt;/p&gt;

&lt;p&gt;四种方法特点分析：&lt;/p&gt;
&lt;p&gt;　　方法一：比较简单，容易看懂，不会影响查询性能，推荐使用。&lt;/p&gt;
&lt;p&gt;　　方法二：虽然比方法一少了几个代码，但 where == 1在sql查询中会影响查询性能,不建议使用。&lt;/p&gt;
&lt;p&gt;　　方法三：代码比较多，容易写错。&lt;/p&gt;
&lt;p&gt;　　方法四：比较难理解，使用相对其它几个方法比较麻烦。&lt;/p&gt;

</description>
<pubDate>Thu, 30 May 2019 15:29:00 +0000</pubDate>
<dc:creator>十五小哥哥</dc:creator>
<og:description>本文主要是对下图的查询方式的条件判断进行讲解： 如果还有更多的查询条件，只要在下面方法中加入相对应的字段，然后添加相应的get和set方法，最后在 最后在需要的SQL语句中引入条件判断方法即可。 四种</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wanghj-15/p/10952746.html</dc:identifier>
</item>
<item>
<title>yum本地源和外网源的配置方法 - 记忆流年</title>
<link>http://www.cnblogs.com/fengdejiyixx/p/10952672.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fengdejiyixx/p/10952672.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;本地源配置方法：以光盘里rpm举例（这里使用虚拟机演示）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1、挂载一个iso的镜像&lt;/p&gt;
&lt;p&gt;把光盘挂载到一个目录里，然后进入/etc/yum.reps.d/目录下，创建一个以 .repo结尾的文件，内容如下：（此文件为最简写法）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1279547/201905/1279547-20190530230824514-1450891325.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;YUM: Yellowdog Update Modifier，rpm的前端程序，可解决软件包相关依赖性，可在多个库之间定位软件包，up2date的替代工具&lt;/p&gt;
&lt;p&gt;yum repository: yum repo，存储了众多rpm包，以及包的相关的元数据&lt;br/&gt;文件（放置于特定目录repodata下）&lt;br/&gt;文件服务器：&lt;br/&gt;http://&lt;br/&gt;https://&lt;br/&gt;ftp://&lt;br/&gt;file://&lt;br/&gt;&lt;span&gt;&lt;strong&gt;yum配置文件内容格式如下：&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt; yum客户端配置文件：&lt;br/&gt;/etc/yum.conf：此目录为所有仓库提供公共配置&lt;br/&gt;/etc/yum.repos.d/*.repo：为仓库的指向提供配置&lt;br/&gt;仓库指向的定义：&lt;br/&gt;[repositoryID]&lt;br/&gt;name=Some name for this repository&lt;br/&gt;baseurl=url://path/to/repository/&lt;br/&gt;enabled={1|0}      &lt;br/&gt;gpgcheck={1|0}&lt;br/&gt;gpgkey=URL&lt;br/&gt;enablegroups={1|0}&lt;br/&gt;failovermethod={roundrobin|priority}&lt;br/&gt;roundrobin：意为随机挑选，默认值&lt;br/&gt;priority:按顺序访问&lt;br/&gt;cost= 默认为1000&lt;/p&gt;
&lt;p&gt;配置完后紧接着使用命令 yum clean all 和 yum repolist  生成元数据后即可使用本地源&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;外网源的配置方法：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 网易（163）yum源是国内最好的yum源之一 ，无论是速度还是软件版本，都非常的不错，将yum源设置为163yum，可以提升软件包安装和更新的速度，同时避免一些常见软件版本无法找到。具体设置方法如下：&lt;/p&gt;
&lt;p&gt;1、首先进入yum源的配置目录&lt;br/&gt;cd  /etc/yum.repos.d/         默认会带有官方的yum源，因为这些地址都是国外的源下载时候速度会慢很多，下面给它替换成163的源&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1279547/201905/1279547-20190530222554433-1691158800.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2，先备份系统自带的yum源&lt;br/&gt;mv  *.repo  repo_backup/&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1279547/201905/1279547-20190530223210770-619253422.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3、在当前目录执行面的命令，直接下载163网易的yum源：&lt;/p&gt;
&lt;p&gt;wget http://mirrors.163.com/.help/CentOS7-Base-163.repo&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1279547/201905/1279547-20190530223505913-632761572.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下完后会有一个以repo结尾的163yum源配置文件，直接就可以使用&lt;/p&gt;
&lt;p&gt;避免受之前源的影响，先清空一下yum的缓存记录，&lt;/p&gt;
&lt;p&gt;yum clean all   清空yum缓存&lt;/p&gt;
&lt;p&gt;yum repolist      查看yum的源列表兵自动下载一些元数据存到本地&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1279547/201905/1279547-20190530224034036-904224460.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4、配置完之后就可以使用了  yum install  +软件名称&lt;/p&gt;
&lt;p&gt; 5、除了网易之外，国内还有其他不错的yum源，比如中科大和搜狐的，大家可以根据自己需求下载&lt;/p&gt;
&lt;p&gt;&lt;em&gt;中科大&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;wget &lt;a href=&quot;http://centos.ustc.edu.cn/CentOS-Base.repo&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;http://centos.ustc.edu.cn/CentOS-Base.repo&lt;/a&gt;   （不知道什么原因，目前好像不能使用了）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;sohu的yum源&lt;br/&gt;wget &lt;a href=&quot;http://mirrors.sohu.com/help/CentOS-Base-sohu.repo&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;http://mirrors.sohu.com/help/CentOS-Base-sohu.repo&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;理论上讲，这些yum源redhat系统以及fedora也是可以用 的，但是没有经过测试，需要的可以自己测试一下。&lt;/p&gt;

&lt;p&gt;希望上面的演示的实例可以帮助到你，对你有帮助的话可以关注一下小编哦！  非常感谢&lt;/p&gt;

</description>
<pubDate>Thu, 30 May 2019 15:17:00 +0000</pubDate>
<dc:creator>记忆流年</dc:creator>
<og:description>本地源配置方法：以光盘里rpm举例（这里使用虚拟机演示） 1、挂载一个iso的镜像 把光盘挂载到一个目录里，然后进入/etc/yum.reps.d/目录下，创建一个以 .repo结尾的文件，内容如下：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/fengdejiyixx/p/10952672.html</dc:identifier>
</item>
<item>
<title>可落地的DDD(3)-如何利用DDD进行微服务的划分 - stoneFang</title>
<link>http://www.cnblogs.com/stoneFang/p/10952658.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/stoneFang/p/10952658.html</guid>
<description>&lt;p&gt;前面两篇介绍了DDD的目标管理、DDD的工程结构调整。这篇讨论微服务的划分。微服务是目前后端比较流行的架构体系了，那么如何做好一个微服务的划分？一个微服务的粒度应该是多大呢？这篇主要介绍如何结合DDD进行领域划分。&lt;/p&gt;

&lt;p&gt;上篇介绍了&lt;a href=&quot;https://wx.qq.com/cgi-bin/mmwebwx-bin/webwxcheckurl?requrl=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI4NjI3MDc1NA%3D%3D%26mid%3D2247483882%26idx%3D1%26sn%3D5ea0bb86670de3edf161bb440a5d6f35%26chksm%3Debde35a7dca9bcb19204b7d1daf39a6afa122c0ac99dababf3d30f07a6d57fd67dd708bd9eb0%26mpshare%3D1%26scene%3D1%26srcid%3D%23rd&amp;amp;skey=%40crypt_3392a498_7eed1ff58f481a3fb4731694587c8f6d&amp;amp;deviceid=e834483582038654&amp;amp;pass_ticket=WINhPMPav3JcIa%252FwUZb4jYynPpZAXN%252FgtSq4FXk24VkHfnNTcPEau%252F6luYx7UKwB&amp;amp;opcode=2&amp;amp;scene=1&amp;amp;username=@cb2237d2dcbe8022e657797ad32bba90cbf7da3311de867600b86e70e6ee3c56&quot;&gt;可落地的DDD的(2)-为什么说MVC工程架构已经过时&lt;/a&gt;&lt;br/&gt;很多朋友留言说，有没有sample code，要不然太湿了，不是很明白。这里写了个sample。&lt;/p&gt;
&lt;p&gt;就以一个博客网站为例&lt;br/&gt;&lt;strong&gt;page1:博客列表页：&lt;/strong&gt; 展示所有用户发表的博客&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190530213118160.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mYW5nemhhbmcuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;strong&gt;page2:&lt;/strong&gt; 个人介绍页：有个人简介和博客列表&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190530213124130.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mYW5nemhhbmcuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;page3：博客详情页.&lt;/p&gt;
&lt;p&gt;不同的业务展示的用户/博客的字段不一致&lt;/p&gt;
&lt;h3 id=&quot;建模&quot;&gt;建模&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190530214146280.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mYW5nemhhbmcuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;后期应该会有用户和博客交互的需求。这期只有用户创建博客这层关联关系。&lt;/p&gt;
&lt;h3 id=&quot;mvc架构&quot;&gt;MVC架构&lt;/h3&gt;
&lt;p&gt;使用mvc模式写出来的代码，就是一路到底。&lt;br/&gt;具体代码见&lt;a href=&quot;https://github.com/FS1360472174/ddd/tree/master/ddd-old&quot;&gt;mvc-structure&lt;/a&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190530220841499.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mYW5nemhhbmcuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;ddd&quot;&gt;DDD&lt;/h3&gt;
&lt;p&gt;使用DDD写出来的工程结构就是，blog和user的交互只有一个地方，OpenXXXService&lt;br/&gt;具体代码见&lt;a href=&quot;https://github.com/FS1360472174/ddd/tree/master/ddd-example&quot;&gt;DDD structure&lt;/a&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190530221100784.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mYW5nemhhbmcuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MVC VS DDD&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从两张依赖图可以看出，DDD的依赖图清晰了，user和blog这两个领域之间的交互变的清晰了，user这个领域不用管blog领域发生了什么变更。只依赖OpenBlogService，而MVC模式呢，user和blog之间的交互太多了，如果再增加其他功能，这些模块之间就是够筹交错，理不清楚。&lt;/p&gt;
&lt;p&gt;不同领域之间的交互多了，意味着一旦发生变更，需要修改逻辑了，那么需要修改的地方就是几何倍数的相关类。&lt;/p&gt;
&lt;p&gt;比如业务发生了变更，统计【个人中心】的博客计数是用户已发表的文章。而这个已发表的可能随着业务的发展，包含多重含义&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;用户写完了，对外开放了，&lt;/li&gt;
&lt;li&gt;运营审核通过&lt;/li&gt;
&lt;li&gt;博客未被软删除的。&lt;br/&gt;这些逻辑都会影响相关的查询，而这些逻辑的实现可能在数据库层面做，可能在redis中做，或者其他的方式。以MVC的写法，需要的需要修改的地方很多，以DDD的方式，不管这个逻辑怎么变，其他领域不需要知道，只有blog领域知道，只用更改blog领域的代码。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;初版&quot;&gt;初版&lt;/h3&gt;
&lt;p&gt;确定了以DDD作为我们领域划分的指导原则后，我们首先按照领域对我们的业务进行了全面的分析，区分出哪些领域。然后按照如下标准进行了微服务的拆分&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;一个领域一个服务的规则&lt;/strong&gt;去拆分，&lt;/li&gt;
&lt;li&gt;同时为了保证领域的纯洁性，我们区分了&lt;strong&gt;领域服务，和前台服务&lt;/strong&gt;。领域服务就是领域逻辑，不直接对前端暴露。前台服务组装各个领域服务，暴露给前端。&lt;/li&gt;
&lt;li&gt;同时&lt;strong&gt;为了保持扩展&lt;/strong&gt;，我们预留了一个微服务作为服务孵化器。对于领域不清晰的（比如大部分的新的业务），放在这个服务里面孵化，然后等领域足够大的时候再拆分出去。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如下图&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190530224610821.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mYW5nemhhbmcuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;前台应用：&lt;br/&gt;pc: pc端的页面展示&lt;br/&gt;mobile: 移动端的页面展示&lt;br/&gt;mini：小程序的页面展示&lt;/p&gt;
&lt;p&gt;领域服务：&lt;br/&gt;blog: 博客领域&lt;br/&gt;user: 用户领域&lt;br/&gt;growth: 领域孵化器&lt;/p&gt;
&lt;p&gt;按照这样的标准去拆分后，一段时间后，很多问题暴露了。&lt;/p&gt;
&lt;ul readability=&quot;4&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;服务热点问题&lt;br/&gt;我们是一个新的业务，在业务迭代的过程中，大部分新需求都是领域不清晰，不知道能不能迭代下去的。所以按照之前的标准，都往growth服务里面去写代码，这样导致几乎团队里面的所有的人都在开发这一个项目，失去了拆分微服务的意义。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;服务依赖太严重&lt;br/&gt;无论写什么需求，都需要写多个应用，领域服务1个，前台如果有pc,需要在pc服务上开发，移动端要展示，要在mobile服务开发。服务之间的调用需要写rpc client接口，需要发版本，因为同时开发的人多，经常发生版本混乱，依赖问题。服务上线也很头疼，改一个小需求，需要部署多个服务。微服务一个很重要的点是去耦合，可独立部署。多了一层UI层作为微服务显然不是很合适。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;领域划分有问题&lt;br/&gt;一个领域一个服务，粒度太小，有些东西不知道放在哪个服务里面，比如用户收藏博客，是放在用户服务里面，还是放在博客领域呢。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不拆分单体应用不知道，一拆分问题一大堆。那么我们是怎么解决的呢？下期再见。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;相关阅读&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI4NjI3MDc1NA==&amp;amp;mid=2247483876&amp;amp;idx=1&amp;amp;sn=5e752da408d06feb6a89b1e364d1cc83&amp;amp;pass_ticket=WINhPMPav3JcIa%2FwUZb4jYynPpZAXN%2FgtSq4FXk24VkHfnNTcPEau%2F6luYx7UKwB&quot;&gt;可落地的DDD(1)-目标讨论&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI4NjI3MDc1NA==&amp;amp;mid=2247483882&amp;amp;idx=1&amp;amp;sn=5ea0bb86670de3edf161bb440a5d6f35&amp;amp;chksm=ebde35a7dca9bcb19204b7d1daf39a6afa122c0ac99dababf3d30f07a6d57fd67dd708bd9eb0&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=&amp;amp;pass_ticket=WINhPMPav3JcIa%2FwUZb4jYynPpZAXN%2FgtSq4FXk24VkHfnNTcPEau%2F6luYx7UKwB#rd&quot;&gt;可落地的DDD的(2)-为什么说MVC工程架构已经过时&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关注【方丈的寺院】，第一时间收到文章的更新，与方丈一起开始技术修行之路&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190418000000125.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mYW5nemhhbmcuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 30 May 2019 15:13:00 +0000</pubDate>
<dc:creator>stoneFang</dc:creator>
<og:description>摘要 前面两篇介绍了DDD的目标管理、DDD的工程结构调整。这篇讨论微服务的划分。微服务是目前后端比较流行的架构体系了，那么如何做好一个微服务的划分？一个微服务的粒度应该是多大呢？这篇主要介绍如何结合</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/stoneFang/p/10952658.html</dc:identifier>
</item>
<item>
<title>python强大的绘图模块matplotlib示例讲解 - bainianminguo</title>
<link>http://www.cnblogs.com/bainianminguo/p/10952586.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bainianminguo/p/10952586.html</guid>
<description>[unable to retrieve full-text content]Matplotlib 是 Python 的绘图库。作为程序员，经常需要进行绘图，在我自己的工作中，如果需要绘图，一般都是将数据导入到excel中，然后通过excel生成图表，这样操作起来还是比较繁琐的，所以最近学习了一下Matplotlib模块，将该模块的常用的绘图手段和大家分享一下，提高大家在工作</description>
<pubDate>Thu, 30 May 2019 14:57:00 +0000</pubDate>
<dc:creator>bainianminguo</dc:creator>
<dc:identifier>https://www.cnblogs.com/bainianminguo/p/10952586.html</dc:identifier>
</item>
<item>
<title>LinkedList 基本示例及源码解析 - c旋儿</title>
<link>http://www.cnblogs.com/cxuanBlog/p/10952578.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cxuanBlog/p/10952578.html</guid>
<description>&lt;h3 id=&quot;一javadoc-简介&quot;&gt;一、JavaDoc 简介&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;LinkedList双向链表，实现了List的 双向队列接口，实现了所有list可选择性操作，允许存储任何元素(包括null值)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;所有的操作都可以表现为双向性的，遍历的时候会从首部到尾部进行遍历，直到找到最近的元素位置&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;注意这个实现不是线程安全的,&lt;/strong&gt; 如果多个线程并发访问链表，并且至少其中的一个线程修改了链表的结构，那么这个链表必须进行外部加锁。(结构化的操作指的是任何添加或者删除至少一个元素的操作，仅仅对已有元素的值进行修改不是结构化的操作)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;List list = Collections.synchronizedList(new LinkedList(…)),&lt;/strong&gt;可以用这种链表做同步访问，但是最好在创建的时间就这样做，避免意外的非同步对链表的访问&lt;/li&gt;
&lt;li&gt;迭代器返回的iterators 和 listIterator方法会造成&lt;strong&gt;fail-fast&lt;/strong&gt;机制：如果链表在生成迭代器之后被结构化的修改了，&lt;strong&gt;除了使用iterator独有的remove方法外，都会抛出并发修改的异常。&lt;/strong&gt;因此，在面对并发修改的时候，这个迭代器能够快速失败，从而避免非确定性的问题&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;二linkedlist-继承接口和实现类介绍&quot;&gt;二、LinkedList 继承接口和实现类介绍&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;java.util.LinkedList&lt;/strong&gt; 继承了 &lt;strong&gt;AbstractSequentialList&lt;/strong&gt; 并实现了&lt;strong&gt;List , Deque , Cloneable&lt;/strong&gt; 接口，以及&lt;strong&gt;Serializable&lt;/strong&gt; 接口&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class LinkedList&amp;lt;E&amp;gt;
    extends AbstractSequentialList&amp;lt;E&amp;gt;
    implements List&amp;lt;E&amp;gt;, Deque&amp;lt;E&amp;gt;, Cloneable, java.io.Serializable {}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;类之间的继承体系如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1515111/201905/1515111-20190530225258916-188181914.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面就对继承树中的部分节点进行大致介绍：&lt;/p&gt;
&lt;blockquote readability=&quot;19&quot;&gt;
&lt;p&gt;AbstractSequentialList 介绍：&lt;br/&gt;这个接口是List一系列子类接口的核心接口，以求最大限度的减少实现此接口的工作量，由顺序访问数据存储(例如链接链表)支持。对于随机访问的数据(像是数组)，AbstractList 应该优先被使用这个接口可以说是与AbstractList类相反的，它实现了随机访问方法，提供了get(int index),set(int index,E element), add(int index,E element) and remove(int index)方法&lt;/p&gt;
&lt;p&gt;对于程序员来说：&lt;/p&gt;
&lt;p&gt;要实现一个列表，程序员只需要扩展这个类并且提供listIterator 和 size方法即可。&lt;br/&gt;对于不可修改的列表来说， 程序员需要实现列表迭代器的 hasNext(), next(), hasPrevious(),&lt;br/&gt;previous 和 index 方法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;AbstractList 介绍：&lt;/p&gt;
&lt;p&gt;这个接口也是List继承类层次的核心接口，以求最大限度的减少实现此接口的工作量，由顺序访问&lt;br/&gt;数据存储(例如链接链表)支持。对于顺序访问的数据(像是链表)，AbstractSequentialList 应该优先被使用，&lt;br/&gt;如果需要实现不可修改的list，程序员需要扩展这个类，list需要实现get(int) 方法和List.size()方法&lt;br/&gt;如果需要实现可修改的list，程序员必须额外重写set(int,Object) set(int,E)方法(否则会抛出&lt;br/&gt;UnsupportedOperationException的异常)，如果list是可变大小的，程序员必须额外重写add(int,Object) , add(int, E) and remove(int) 方法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;AbstractCollection 介绍：&lt;/p&gt;
&lt;p&gt;这个接口是Collection接口的一个核心实现，尽量减少实现此接口所需的工作量&lt;br/&gt;为了实现不可修改的collection，程序员应该继承这个类并提供呢iterator和size 方法&lt;br/&gt;为了实现可修改的collection，程序团需要额外重写类的add方法，iterator方法返回的Iterator迭代器也必须实现remove方法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;三linkedlist-基本方法介绍&quot;&gt;三、LinkedList 基本方法介绍&lt;/h3&gt;
&lt;p&gt;上面看完了LinkedList 的继承体系之后，来看看LinkedList的基本方法说明&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;添加
    add():
    ----&amp;gt; 1. add(E e) :  直接在'末尾'处添加元素
  ----&amp;gt; 2. add(int index,E element) : 在'指定索引处添'加元素
  ----&amp;gt; 3. addAll(Collections&amp;lt;? extends E&amp;gt; c) : 在'末尾'处添加一个collection集合
  ----&amp;gt; 4. addAll(int index,Collections&amp;lt;? extends E&amp;gt; c)：在'指定位置'添加一个collection集合
  ----&amp;gt; 5. addFirst(E e): 在'头部'添加指定元素
  ----&amp;gt; 6. addLast(E e): 在'尾部'添加指定元素
  
  offer():
  ----&amp;gt; 1. offer(E e)： 在链表'末尾'添加元素
  ----&amp;gt; 2. offerFirst(E e): 在'链表头'添加指定元素
  ----&amp;gt; 3. offerLast(E e): 在'链表尾'添加指定元素
  
  push(E e): 在'头部'压入元素
  
移除
  
  poll()：
  ----&amp;gt; 1. poll(): 访问并移除'首部'元素
  ----&amp;gt; 2. pollFirst(): 访问并移除'首部'元素
  ----&amp;gt; 3. pollLast(): 访问并移除'尾部'元素
  
  pop(): 从列表代表的堆栈中弹出元素，从'头部'弹出
  
  remove(): 
  ----&amp;gt; 1. remove(): 移除并返回'首部'元素
  ----&amp;gt; 2. remove(int index) : 移除'指定索引'处的元素
  ----&amp;gt; 3. remove(Object o): 移除指定元素
  ----&amp;gt; 4. removeFirst(): 移除并返回'第一个'元素
  ----&amp;gt; 5. removeFirstOccurrence(Object o): 从头到尾遍历，移除'第一次'出现的元素
  ----&amp;gt; 6. removeLast(): 移除并返回'最后一个'元素
  ----&amp;gt; 7. removeLastOccurrence(Object o): 从头到尾遍历，移除'最后一次'出现的元素
  
  clear(): 清空所有元素
  
访问

    peek(): 
  ----&amp;gt; 1. peek(): 只访问，不移除'首部'元素
  ----&amp;gt; 2. peekFirst(): 只访问，不移除'首部'元素，如果链表不包含任何元素，则返回null
  ----&amp;gt; 3. peekLast(): 只访问，不移除'尾部'元素，如果链表不包含任何元素，返回null
  
  element(): 只访问，不移除'头部'元素
    
  get():
  ----&amp;gt; 1. get(int index): 返回'指定索引'处的元素
  ----&amp;gt; 2. getFirst(): 返回'第一个'元素
  ----&amp;gt; 3. getLast(): 返回'最后一个'元素

  indexOf(Object o): 检索某个元素'第一次'出现所在的位置
  LastIndexOf(Object o): 检索某个元素'最后一次'出现的位置
  
 其他
 
    clone() : 返回一个链表的拷贝，返回值为Object 类型
  contains(Object o): 判断链表是否包含某个元素
  descendingIterator(): 返回一个迭代器，里面的元素是倒叙返回的
  listIterator(int index) : 在指定索引处创建一个'双向遍历迭代器'
    set(int index, E element): 替换某个位置处的元素
  size() : 返回链表的长度
  spliterator(): 创建一个后期绑定并快速失败的元素
  toArray(): 将链表转变为数组返回
  
  
    &lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;四linkedlist-基本方法使用&quot;&gt;四、LinkedList 基本方法使用&lt;/h3&gt;
&lt;p&gt;学以致用，熟悉了上面基本方法之后，来简单做一个demo测试一下上面的方法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/** 
 * 此方法描述
 * LinedList 集合的基本使用
 */
public class LinkedListTest {

    public static void main(String[] args) {

        LinkedList&amp;lt;String&amp;gt; list = new LinkedList&amp;lt;&amp;gt;();
        list.add(&quot;111&quot;);
        list.add(&quot;222&quot;);
        list.add(&quot;333&quot;);
        list.add(1,&quot;123&quot;);

        // 分别在头部和尾部添加元素
        list.addFirst(&quot;top&quot;);
        list.addLast(&quot;bottom&quot;);
        System.out.println(list);

        // 数组克隆
        Object listClone = list.clone();
        System.out.println(listClone);

        // 创建一个首尾互换的迭代器
        Iterator&amp;lt;String&amp;gt; it = list.descendingIterator();
        while (it.hasNext()){
            System.out.print(it.next() + &quot; &quot;);
        }
        System.out.println();
        list.clear();
        System.out.println(&quot;list.contains('111') ? &quot; + list.contains(&quot;111&quot;));

        Collection&amp;lt;String&amp;gt; collec = Arrays.asList(&quot;123&quot;,&quot;213&quot;,&quot;321&quot;);
        list.addAll(collec);
        System.out.println(list);
        System.out.println(&quot;list.element = &quot; + list.element());
        System.out.println(&quot;list.get(2) = &quot; + list.get(2));
        System.out.println(&quot;list.getFirst() = &quot; + list.getFirst());
        System.out.println(&quot;list.getLast() = &quot; + list.getLast());

        // 检索指定元素出现的位置
        System.out.println(&quot;list.indexOf(213) = &quot; + list.indexOf(&quot;213&quot;));
        list.add(&quot;123&quot;);
        System.out.println(&quot;list.lastIndexOf(123) = &quot; + list.lastIndexOf(&quot;123&quot;));
        // 在首部和尾部添加元素
        list.offerFirst(&quot;first&quot;);
        list.offerLast(&quot;999&quot;);
        System.out.println(&quot;list = &quot; + list);
        list.offer(&quot;last&quot;);
        // 只访问，不移除指定元素
        System.out.println(&quot;list.peek() = &quot; + list.peek());
        System.out.println(&quot;list.peekFirst() = &quot; + list.peekFirst());
        System.out.println(&quot;list.peekLast() = &quot; + list.peekLast());

        // 访问并移除元素
        System.out.println(&quot;list.poll() = &quot; + list.poll());
        System.out.println(&quot;list.pollFirst() = &quot; + list.pollFirst());
        System.out.println(&quot;list.pollLast() = &quot; + list.pollLast());
        System.out.println(&quot;list = &quot; + list);
        // 从首部弹出元素
        list.pop();
        // 压入元素
        list.push(&quot;123&quot;);
        System.out.println(&quot;list.size() = &quot; + list.size());
        System.out.println(&quot;list = &quot; + list);

        // remove操作
        System.out.println(list.remove());
        System.out.println(list.remove(1));
        System.out.println(list.remove(&quot;999&quot;));
        System.out.println(list.removeFirst());
        System.out.println(&quot;list = &quot; + list);

        list.addAll(collec);
        list.addFirst(&quot;123&quot;);
        list.addLast(&quot;123&quot;);
        System.out.println(&quot;list = &quot; + list);
        list.removeFirstOccurrence(&quot;123&quot;);
        list.removeLastOccurrence(&quot;123&quot;);
        list.removeLast();
        System.out.println(&quot;list = &quot; + list);
        list.addFirst(&quot;top&quot;);
        list.addLast(&quot;bottom&quot;);
        list.set(2,&quot;321&quot;);
        System.out.println(&quot;list = &quot; + list);
        System.out.println(&quot;--------------------------&quot;);

        // 创建一个list的双向链表
        ListIterator&amp;lt;String&amp;gt; listIterator = list.listIterator();
        while(listIterator.hasNext()){
            // 移到list的末端
            System.out.println(listIterator.next());
        }
        System.out.println(&quot;--------------------------&quot;);
        while (listIterator.hasPrevious()){
            // 移到list的首端
            System.out.println(listIterator.previous());
        }   
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Console:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;-------1------- [top, 111, 123, 222, 333, bottom]
-------2-------[top, 111, 123, 222, 333, bottom]
bottom 333 222 123 111 top 
list.contains('111') ? false
[123, 213, 321]
list.element = 123
list.get(2) = 321
list.getFirst() = 123
list.getLast() = 321
list.indexOf(213) = 1
list.lastIndexOf(123) = 3
-------4------- [first, 123, 213, 321, 123, 999]
list.peek() = first
list.peekFirst() = first
list.peekLast() = last
list.poll() = first
list.pollFirst() = 123
list.pollLast() = last
-------5------- [213, 321, 123, 999]
list.size() = 4
-------6------- [123, 321, 123, 999]
123
123
true
321
-------7------- []
-------8------- [123, 123, 213, 321, 123]
list = [123, 213]
-------9------- [top, 123, 321, bottom]
--------------------------
top
123
321
bottom
--------------------------
bottom
321
123
top&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;五linkedlist-内部结构以及基本元素声明&quot;&gt;五、LinkedList 内部结构以及基本元素声明&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;LinkedList内部结构是一个双向链表，&lt;/strong&gt;具体示意图如下&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1515111/201905/1515111-20190530230420117-1509500427.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每一个链表都是一个Node节点，由三个元素组成&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private static class Node&amp;lt;E&amp;gt; {
        // Node节点的元素
        E item;
        // 指向下一个元素
        Node&amp;lt;E&amp;gt; next;
        // 指向上一个元素
        Node&amp;lt;E&amp;gt; prev;

        // 节点构造函数
        Node(Node&amp;lt;E&amp;gt; prev, E element, Node&amp;lt;E&amp;gt; next) {
            this.item = element;
            this.next = next;
            this.prev = prev;
        }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;first 节点也是头节点， last节点也是尾节点&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;LinkedList 中有三个元素，分别是&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;transient int size = 0; // 链表的容量

transient Node&amp;lt;E&amp;gt; first; // 指向第一个节点

transient Node&amp;lt;E&amp;gt; last; // 指向最后一个节点&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;LinkedList 有两个构造函数，一个是空构造函数，不添加任何元素，一种是创建的时候就接收一个Collection集合。&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    /**
     * 空构造函数
     */
    public LinkedList() {}

    /**
     * 创建一个包含指定元素的构造函数
     */
    public LinkedList(Collection&amp;lt;? extends E&amp;gt; c) {
      this();
      addAll(c);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;六linkedlist-具体源码分析&quot;&gt;六、LinkedList 具体源码分析&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;前言: 此源码是作者根据上面的代码示例一步一步跟进去的，如果有哪些疑问或者讲的不正确的地方，请与作者联系。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;添加&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;添加的具体流程示意图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1515111/201905/1515111-20190530225744662-1646911093.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;包括方法有：&lt;/p&gt;
&lt;ul readability=&quot;0.84065934065934&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;strong&gt;add&lt;/strong&gt;(&lt;a href=&quot;https://www.cnblogs.com/java/util/LinkedList.html&quot;&gt;E&lt;/a&gt; e)&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;add&lt;/strong&gt;(int index, &lt;a href=&quot;https://www.cnblogs.com/java/util/LinkedList.html&quot;&gt;E&lt;/a&gt; element)&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-0.66666666666667&quot;&gt;
&lt;p&gt;&lt;strong&gt;addAll&lt;/strong&gt;(&lt;a href=&quot;https://www.cnblogs.com/java/util/Collection.html&quot;&gt;Collection&lt;/a&gt;&amp;lt;? extends &lt;a href=&quot;https://www.cnblogs.com/java/util/LinkedList.html&quot;&gt;E&lt;/a&gt;&amp;gt; c)&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;addAll&lt;/strong&gt;(int index, &lt;a href=&quot;https://www.cnblogs.com/java/util/Collection.html&quot;&gt;Collection&lt;/a&gt;&amp;lt;? extends &lt;a href=&quot;https://www.cnblogs.com/java/util/LinkedList.html&quot;&gt;E&lt;/a&gt;&amp;gt; c)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;addFirst&lt;/strong&gt;(&lt;a href=&quot;https://www.cnblogs.com/java/util/LinkedList.html&quot;&gt;E&lt;/a&gt; e)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;addLast&lt;/strong&gt;(&lt;a href=&quot;https://www.cnblogs.com/java/util/LinkedList.html&quot;&gt;E&lt;/a&gt; e)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;offer&lt;/strong&gt;(&lt;a href=&quot;https://www.cnblogs.com/java/util/LinkedList.html&quot;&gt;E&lt;/a&gt; e)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;offerFirst&lt;/strong&gt;(&lt;a href=&quot;https://www.cnblogs.com/java/util/LinkedList.html&quot;&gt;E&lt;/a&gt; e)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;offerLast&lt;/strong&gt;(&lt;a href=&quot;https://www.cnblogs.com/java/util/LinkedList.html&quot;&gt;E&lt;/a&gt; e)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面对这些方法逐个分析其源码：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;add(E e) ：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    // 添加指定元素至list末尾
    public boolean add(E e) {
          linkLast(e);
          return true;
    }

    // 真正添加节点的操作
    void linkLast(E e) {
      final Node&amp;lt;E&amp;gt; l = last;
        // 生成一个Node节点
      final Node&amp;lt;E&amp;gt; newNode = new Node&amp;lt;&amp;gt;(l, e, null);
      last = newNode;
        // 如果l = null，代表的是第一个节点，所以这个节点即是头节点
        // 又是尾节点
      if (l == null)
          first = newNode;
      else
        // 如果不是的话，那么就让该节点的next 指向新的节点
          l.next = newNode;
      size++;
      modCount++;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;比如第一次添加的是111，此时链表中还没有节点，所以此时的尾节点last 为null, 生成新的节点，所以 此时的尾节点也就是111，所以这个 111 也是头节点，再进行扩容，修改次数对应增加&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第二次添加的是 222， 此时链表中已经有了一个节点，新添加的节点会添加到尾部，刚刚添加的111 就当作头节点来使用，222被添加到111的节点后面。&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;add(int index,E e) :&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    /**
      *在指定位置插入指定的元素
      */
    public void add(int index, E element) {
        // 下标检查
        checkPositionIndex(index);

        if (index == size)
            // 如果需要插入的位置和链表的长度相同，就在链表的最后添加
            linkLast(element);
        else
            // 否则就链接在此位置的前面
            linkBefore(element, node(index));
    }

    
    // 越界检查
    private void checkPositionIndex(int index) {
          if (!isPositionIndex(index))
              throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
    }

    // 判断参数是否是有效位置(对于迭代或者添加操作来说)
    private boolean isPositionIndex(int index) {
        return index &amp;gt;= 0 &amp;amp;&amp;amp; index &amp;lt;= size;
    }

        // linkLast 上面已经介绍过

    // 查找索引所在的节点
    Node&amp;lt;E&amp;gt; node(int index) {
        // assert isElementIndex(index);

        if (index &amp;lt; (size &amp;gt;&amp;gt; 1)) {
            Node&amp;lt;E&amp;gt; x = first;
            for (int i = 0; i &amp;lt; index; i++)
                x = x.next;
            return x;
        } else {
            Node&amp;lt;E&amp;gt; x = last;
            for (int i = size - 1; i &amp;gt; index; i--)
                x = x.prev;
            return x;
        }
    }

    // 在非空节点插入元素
    void linkBefore(E e, Node&amp;lt;E&amp;gt; succ) {
        // assert succ != null;
        // succ 即是插入位置的节点
            // 查找该位置处的前面一个节点
        final Node&amp;lt;E&amp;gt; pred = succ.prev;
        final Node&amp;lt;E&amp;gt; newNode = new Node&amp;lt;&amp;gt;(pred, e, succ);
        succ.prev = newNode;
        if (pred == null)
            first = newNode;
        else
            pred.next = newNode;
        size++;
        modCount++;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;例如在位置为1处添加值为123 的元素，首先对下标进行越界检查，判断这个位置是否等于链表的长度，如果与链表长度相同，就往最后插入，如果不同的话，就在索引的前面插入。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;下标为1 处并不等于索引的长度，所以在索引前面插入，首先对查找 1 这个位置的节点是哪个，并获取这个节点的前面一个节点，在判断这个位置的前一个节点是否为null，如果是null，那么这个此处位置的元素就被当作头节点，如果不是的话，头节点的next 节点就指向123&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;addFirst(E e) :&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    // 在头节点插入元素
    public void addFirst(E e) {
        linkFirst(e);
    }

        
    private void linkFirst(E e) {
        // 先找到first 节点
        final Node&amp;lt;E&amp;gt; f = first;
        final Node&amp;lt;E&amp;gt; newNode = new Node&amp;lt;&amp;gt;(null, e, f);
        first = newNode;
        if (f == null)
            // f 为null，也就代表着没有头节点
            last = newNode;
        else
            f.prev = newNode;
        size++;
        modCount++;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;例如要添加top 元素至链表的首部，需要先找到first节点，如果first节点为null，也就说明没有头节点，如果不为null，则头节点的prev节点是新插入的节点。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;addLast(E e) :&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;                
    public void addLast(E e) {
        linkLast(e);
    }
        
    // 链接末尾处的节点
    void linkLast(E e) {
        final Node&amp;lt;E&amp;gt; l = last;
        final Node&amp;lt;E&amp;gt; newNode = new Node&amp;lt;&amp;gt;(l, e, null);
        last = newNode;
        if (l == null)
            first = newNode;
        else
            l.next = newNode;
        size++;
        modCount++;
    }
        &lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;方法逻辑与在头节点插入基本相同&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;addAll(Collections&amp;lt;? extends E&amp;gt; c) :&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    /**
    * 在链表中批量添加数据
    */
    public boolean addAll(Collection&amp;lt;? extends E&amp;gt; c) {
        return addAll(size, c);
    }

    public boolean addAll(int index, Collection&amp;lt;? extends E&amp;gt; c) {
      // 越界检查
        checkPositionIndex(index);
                
        // 把集合转换为数组
        Object[] a = c.toArray();
        int numNew = a.length;
        if (numNew == 0)
            return false;

        Node&amp;lt;E&amp;gt; pred, succ;
        // 直接在末尾添加，所以index = size
        if (index == size) {
            succ = null;
            pred = last;
        } else {
            succ = node(index);
            pred = succ.prev;
        }
                
        // 遍历每个数组
        for (Object o : a) {
            @SuppressWarnings(&quot;unchecked&quot;) E e = (E) o;
            // 先对应生成节点，再进行节点的链接
            Node&amp;lt;E&amp;gt; newNode = new Node&amp;lt;&amp;gt;(pred, e, null);
            if (pred == null)
                first = newNode;
            else
                pred.next = newNode;
            pred = newNode;
        }

        if (succ == null) {
            last = pred;
        } else {
            pred.next = succ;
            succ.prev = pred;
        }

        size += numNew;
        modCount++;
        return true;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Collection&amp;lt;String&amp;gt; collec = Arrays.asList(&quot;123&quot;,&quot;213&quot;,&quot;321&quot;);
list.addAll(collec);&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;例如要插入一个Collection为123,213,321 的集合，没有指定插入元素的位置，默认是向链表的尾部进行链接，首先会进行数组越界检查，然后会把集合转换为数组，在判断数组的大小是否为0，为0返回，不为0，继续下面操作&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;因为是直接向链尾插入，所以index = size，然后遍历每个数组，首先生成对应的节点，在对节点进行链接，因为succ 是null，此时last 节点 = pred，这个时候的pred节点就是遍历数组完成后的最后一个节点&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;然后再扩容数组，增加修改次数&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;addAll(Collections&amp;lt;? extends E&amp;gt; c) :&lt;/strong&gt; 这个方法的源码同上&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;offer也是对元素进行添加操作，源码和add方法相同&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;offerFirst(E e)和addFirst(E e) 源码相同&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;offerLast(E e)和addLast(E e) 源码相同)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;push(E e) 和addFirst(E e) 源码相同&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;取出元素&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;包括方法有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;peek&lt;/strong&gt;()&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;peekFirst&lt;/strong&gt;()&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;peekLast&lt;/strong&gt;()&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;element&lt;/strong&gt;()&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;get&lt;/strong&gt;(int index)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;getFirst&lt;/strong&gt;()&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;getLast&lt;/strong&gt;()&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;indexOf&lt;/strong&gt;(&lt;a href=&quot;https://www.cnblogs.com/java/lang/Object.html&quot;&gt;Object&lt;/a&gt; o)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;lastIndexOf&lt;/strong&gt;(&lt;a href=&quot;https://www.cnblogs.com/java/lang/Object.html&quot;&gt;Object&lt;/a&gt; o)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;peek()&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    /**
    *   只是访问，但是不移除链表的头元素
    */
    public E peek() {
        final Node&amp;lt;E&amp;gt; f = first;
        return (f == null) ? null : f.item;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;peek() 源码比较简单，直接找到链表的第一个节点，判断是否为null，如果为null，返回null，否则返回链首的元素&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;peekFirst() ： 源码和peek() 相同&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;peekLast():&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    /**
    * 访问，但是不移除链表中的最后一个元素
    * 或者返回null如果链表是空链表
    */
    public E peekLast() {
        final Node&amp;lt;E&amp;gt; l = last;
        return (l == null) ? null : l.item;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;源码也比较好理解&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;element() :&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    /**
    * 只是访问，但是不移除链表的第一个元素
    */
    public E element() {
        return getFirst();
    }

    public E getFirst() {
        final Node&amp;lt;E&amp;gt; f = first;
        if (f == null)
            throw new NoSuchElementException();
        return f.item;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;与peek()相同的地方都是访问链表的第一个元素，不同是element元素在链表为null的时候会报空指针异常&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;****get&lt;strong&gt;(int index) :&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    /*
    * 返回链表中指定位置的元素
    */ 
    public E get(int index) {
        checkElementIndex(index);
        return node(index).item;
    }

    // 返回指定索引下的元素的非空节点
    Node&amp;lt;E&amp;gt; node(int index) {
        // assert isElementIndex(index);

        if (index &amp;lt; (size &amp;gt;&amp;gt; 1)) {
            Node&amp;lt;E&amp;gt; x = first;
            for (int i = 0; i &amp;lt; index; i++)
                x = x.next;
            return x;
        } else {
            Node&amp;lt;E&amp;gt; x = last;
            for (int i = size - 1; i &amp;gt; index; i--)
                x = x.prev;
            return x;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;get(int index)源码也是比较好理解，首先对下标进行越界检查，没有越界的话直接找到索引位置对应的node节点，进行返回&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;getFirst() ：源码和element()相同&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;getLast(): 直接找到最后一个元素进行返回，和getFist几乎相同&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;indexOf(Object o) :&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    /*
    * 返回第一次出现指定元素的位置，或者-1如果不包含指定元素。
    */
    public int indexOf(Object o) {
        int index = 0;
        if (o == null) {
            for (Node&amp;lt;E&amp;gt; x = first; x != null; x = x.next) {
                if (x.item == null)
                    return index;
                index++;
            }
        } else {
            for (Node&amp;lt;E&amp;gt; x = first; x != null; x = x.next) {
                if (o.equals(x.item))
                    return index;
                index++;
            }
        }
        return -1;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;两种情况：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;如果需要检索的元素是null，对元素链表进行遍历，返回x的元素为空的位置&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如果需要检索的元素不是null，对元素的链表遍历，直到找到相同的元素，返回元素下标&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;lastIndexOf(Object o) :&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    /*
    * 返回最后一次出现指定元素的位置，或者-1如果不包含指定元素。
    */
    public int lastIndexOf(Object o) {
        int index = size;
        if (o == null) {
            for (Node&amp;lt;E&amp;gt; x = last; x != null; x = x.prev) {
                index--;
                if (x.item == null)
                    return index;
            }
        } else {
            for (Node&amp;lt;E&amp;gt; x = last; x != null; x = x.prev) {
                index--;
                if (o.equals(x.item))
                    return index;
            }
        }
        return -1;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;从IndexOf(Object o)源码反向理解&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;删除&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;删除节点的示意图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1515111/201905/1515111-20190530225451674-1105611196.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;包括的方法有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;poll&lt;/strong&gt;()&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;pollFirst&lt;/strong&gt;()&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;pollLast&lt;/strong&gt;()&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;pop&lt;/strong&gt;()&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;remove&lt;/strong&gt;()&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;remove&lt;/strong&gt;(int index)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;remove&lt;/strong&gt;(&lt;a href=&quot;https://www.cnblogs.com/java/lang/Object.html&quot;&gt;Object&lt;/a&gt; o)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;removeFirst&lt;/strong&gt;()&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;removeFirstOccurrence&lt;/strong&gt;(&lt;a href=&quot;https://www.cnblogs.com/java/lang/Object.html&quot;&gt;Object&lt;/a&gt; o)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;removeLast&lt;/strong&gt;()&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;removeLastOccurrence&lt;/strong&gt;(&lt;a href=&quot;https://www.cnblogs.com/java/lang/Object.html&quot;&gt;Object&lt;/a&gt; o)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;clear&lt;/strong&gt;()&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;poll() :&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    /*
    * 访问并移除链表中指定元素
    */
    public E poll() {
        final Node&amp;lt;E&amp;gt; f = first;
        return (f == null) ? null : unlinkFirst(f);
    }

    // 断开第一个非空节点
    private E unlinkFirst(Node&amp;lt;E&amp;gt; f) {
        // assert f == first &amp;amp;&amp;amp; f != null;
        final E element = f.item;
        final Node&amp;lt;E&amp;gt; next = f.next;
        f.item = null;
        f.next = null; // help GC
        first = next;
        if (next == null)
            last = null;
        else
            next.prev = null;
        size--;
        modCount++;
        return element;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;poll()方法也比较简单直接，首先通过Node方法找到第一个链表头，然后把链表的元素和链表头指向的next元素置空，再把next节点的元素变为头节点的元素&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;pollFirst() : 与poll() 源码相同&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;pollLast(): 与poll() 源码很相似，不再解释&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;pop()&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;            
    /*
        * 弹出链表的指定元素，换句话说，移除并返回链表中第一个元素
      */
    public E removeFirst() {
      final Node&amp;lt;E&amp;gt; f = first;
      if (f == null)
        throw new NoSuchElementException();
      return unlinkFirst(f);
    }

    // unlinkFirst 源码上面👆有&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;removeFirst源码就多了如果首部元素为null，就直接抛出异常的操作&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;remove&lt;/strong&gt;(int index):&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    /*
    * 移除链表指定位置的元素
    */
    public E remove(int index) {
        checkElementIndex(index);
        // 找到index 的节点，断开指定节点
        return unlink(node(index));
    }

    // 断开指定节点
    E unlink(Node&amp;lt;E&amp;gt; x) {
        // 找到链接节点的元素，next节点和prev节点
        final E element = x.item;
        final Node&amp;lt;E&amp;gt; next = x.next;
        final Node&amp;lt;E&amp;gt; prev = x.prev;

        if (prev == null) {
            first = next;
        } else {
            prev.next = next;
            x.prev = null;
        }

        if (next == null) {
            last = prev;
        } else {
            next.prev = prev;
            x.next = null;
        }

        x.item = null;
        size--;
        modCount++;
        return element;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;remove&lt;/strong&gt;(&lt;a href=&quot;https://www.cnblogs.com/java/lang/Object.html&quot;&gt;Object&lt;/a&gt; o)&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    /*
    * 移除列表中第一次出现的指定元素，如果存在的话。如果列表不包含指定元素，则不会改变，
    * 更进一步来说，移除索引最小的元素，前提是(o == null ? get(i) == null : o.equals(get(i)))
    */
    public boolean remove(Object o) {
        // 如果o为null
        if (o == null) {
            for (Node&amp;lt;E&amp;gt; x = first; x != null; x = x.next) {
                // 匹配null对象，删除控对象，返回true
                if (x.item == null) {
                    unlink(x);
                    return true;
                }
            }
        } else {
            // 如果不为null
            for (Node&amp;lt;E&amp;gt; x = first; x != null; x = x.next) {
                // 匹配对应节点，返回true
                if (o.equals(x.item)) {
                    unlink(x);
                    return true;
                }
            }
        }
        return false;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;removeFirst() 和remove() 源码相同&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;removeFirstOccurrence&lt;/strong&gt;(&lt;a href=&quot;https://www.cnblogs.com/java/lang/Object.html&quot;&gt;Object&lt;/a&gt; o)和 &lt;strong&gt;remove&lt;/strong&gt;(&lt;a href=&quot;https://www.cnblogs.com/java/lang/Object.html&quot;&gt;Object&lt;/a&gt; o) 源码相同&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;removeLast&lt;/strong&gt;() 和 pollLast() 相同&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;removeLastOccurrence&lt;/strong&gt;(&lt;a href=&quot;https://www.cnblogs.com/java/lang/Object.html&quot;&gt;Object&lt;/a&gt; o) 和 &lt;strong&gt;removeFirstOccurrence&lt;/strong&gt;(&lt;a href=&quot;https://www.cnblogs.com/java/lang/Object.html&quot;&gt;Object&lt;/a&gt; o) 相似&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;clear()&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;        
    /*
    * 清空所有元素
    */
    public void clear() {
        // 遍历元素，把元素的值置为null
        for (Node&amp;lt;E&amp;gt; x = first; x != null; ) {
            Node&amp;lt;E&amp;gt; next = x.next;
            x.item = null;
            x.next = null;
            x.prev = null;
            x = next;
        }
        first = last = null;
        size = 0;
        modCount++;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;clear()方法，先找到链表头，循环遍历每一项，把每一项的prev，item，next属性置空，最后再清除first和last节点，注意源码有一点，x = next ，这行代码是向后遍历的意思，根据next的元素再继续向后查找&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;其他方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;链表最常用的方法就是添加、查找、删除，下面来介绍一下其他的方法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;clone&lt;/strong&gt;()&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    /*
    * 链表复制
    */
    public Object clone() {
        // 此处的clone 
        LinkedList&amp;lt;E&amp;gt; clone = superClone();

        // Put clone into &quot;virgin&quot; state
        clone.first = clone.last = null;
        clone.size = 0;
        clone.modCount = 0;

        // Initialize clone with our elements
        for (Node&amp;lt;E&amp;gt; x = first; x != null; x = x.next)
            clone.add(x.item);

        return clone;
    }

    private LinkedList&amp;lt;E&amp;gt; superClone() {
        try {
            return (LinkedList&amp;lt;E&amp;gt;) super.clone();
        } catch (CloneNotSupportedException e) {
            throw new InternalError(e);
        }
    }
        // 本地方法
        protected native Object clone() throws CloneNotSupportedException;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;clone() 方法调用superClone()能够获取拷贝过后的值，但是为什么要把first和last置为null，debug的时候就发现clone对象所有的值都为null了，而且为什么又要循环遍历链表再添加一遍？&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;contains&lt;/strong&gt;(&lt;a href=&quot;https://www.cnblogs.com/java/lang/Object.html&quot;&gt;Object&lt;/a&gt; o) : 和index源码几乎相同&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;set&lt;/strong&gt;(int index, &lt;a href=&quot;https://www.cnblogs.com/java/util/LinkedList.html&quot;&gt;E&lt;/a&gt; element)&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;        
    /*
    * 在指定位置替换指定元素
    */
    public E set(int index, E element) {
            // 越界检查
        checkElementIndex(index);
        // 找到索引元素所在的位置
        Node&amp;lt;E&amp;gt; x = node(index);
        // 元素替换操作，返回替换之前的元素
        E oldVal = x.item;
        x.item = element;
        return oldVal;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;descendingIterator&lt;/strong&gt;()&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;        
    public Iterator&amp;lt;E&amp;gt; descendingIterator() {
        return new DescendingIterator();
    }

    private class DescendingIterator implements Iterator&amp;lt;E&amp;gt; {
        private final ListItr itr = new ListItr(size());
        public boolean hasNext() {
            return itr.hasPrevious();
        }
        public E next() {
            return itr.previous();
        }
        public void remove() {
            itr.remove();
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;descendingIterator 就相当于创建了一个倒置的Iterator，倒叙遍历&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;listIterator&lt;/strong&gt;(int index) :&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;        
    /*
    * 在指定位置上返回一个列表的迭代器，这个list-Iterator是有快速失败机制的
    * 可以参见我的另一篇文章 ArrayList 源码解析
    */
    public ListIterator&amp;lt;E&amp;gt; listIterator(int index) {
        checkPositionIndex(index);
        return new ListItr(index);
    }

        // ListItr 是LinkedList的一个内部类
        private class ListItr implements ListIterator&amp;lt;E&amp;gt; {
        // 上一个被返回的节点
        private Node&amp;lt;E&amp;gt; lastReturned;
        // 下一个节点
        private Node&amp;lt;E&amp;gt; next;
        // 下一个下标
        private int nextIndex;
        // 期望的修改次数 = 修改次数，用于判断并发情况
        private int expectedModCount = modCount;

        // 在指定位置创建一个迭代器
        ListItr(int index) {
            next = (index == size) ? null : node(index);
            nextIndex = index;
        }
                
        // 判断是否有下一个元素
        // 判断的标准是下一个索引的值 &amp;lt; size ,说明当前位置最大 = 链表的容量
        public boolean hasNext() {
            return nextIndex &amp;lt; size;
        }

        // 查找下一个元素
        public E next() {
            checkForComodification();
            if (!hasNext())
                throw new NoSuchElementException();
                        
            lastReturned = next;
            // 指向下一个元素
            next = next.next;
            nextIndex++;
            return lastReturned.item;
        }
                
        // 是否有之前的元素
        public boolean hasPrevious() {
            // 通过元素索引是否等于0，来判断是否达到开头。
            return nextIndex &amp;gt; 0;
        }
                
        // 遍历之前的元素
        public E previous() {
            checkForComodification();
            if (!hasPrevious())
                throw new NoSuchElementException();
                         // next指向链表的上一个元素
            lastReturned = next = (next == null) ? last : next.prev;
            nextIndex--;
            return lastReturned.item;
        }
                
        // 下一个索引
        public int nextIndex() {
            return nextIndex;
        }

        // 上一个索引
        public int previousIndex() {
            return nextIndex - 1;
        }

        // 移除元素，有fail-fast机制
        public void remove() {
            checkForComodification();
            if (lastReturned == null)
                throw new IllegalStateException();

            Node&amp;lt;E&amp;gt; lastNext = lastReturned.next;
            unlink(lastReturned);
            if (next == lastReturned)
                next = lastNext;
            else
                nextIndex--;
            lastReturned = null;
            expectedModCount++;
        }
                
        // 设置当前节点为e，有fail-fast机制
        public void set(E e) {
            if (lastReturned == null)
                throw new IllegalStateException();
            checkForComodification();
            lastReturned.item = e;
        }
                
        // 将e添加到当前节点的前面，也有fail-fast机制
        public void add(E e) {
            checkForComodification();
            lastReturned = null;
            if (next == null)
                linkLast(e);
            else
                linkBefore(e, next);
            nextIndex++;
            expectedModCount++;
        }
                
        // jdk1.8引入，用于快速遍历链表元素
        public void forEachRemaining(Consumer&amp;lt;? super E&amp;gt; action) {
            Objects.requireNonNull(action);
            while (modCount == expectedModCount &amp;amp;&amp;amp; nextIndex &amp;lt; size) {
                action.accept(next.item);
                lastReturned = next;
                next = next.next;
                nextIndex++;
            }
            checkForComodification();
        }

        // 判断 “modCount和expectedModCount是否相等”，依次来实现fail-fast机制
        final void checkForComodification() {
            if (modCount != expectedModCount)
                throw new ConcurrentModificationException();
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;toArray&lt;/strong&gt;()&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    
    /*
    * 返回LinkedList的Object[]数组
    */
    public Object[] toArray() {
        Object[] result = new Object[size];
        int i = 0;
        //将链表中所有节点的数据都添加到Object[]数组中
        for (Node&amp;lt;E&amp;gt; x = first; x != null; x = x.next)
          result[i++] = x.item;
        return result;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;toArray&lt;/strong&gt;(T[] a)&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    /*
    * 返回LinkedList的模板数组。所谓模板数组，即可以将T设为任意的数据类型
    */
    public &amp;lt;T&amp;gt; T[] toArray(T[] a) {
        // 若数组a的大小 &amp;lt; LinkedList的元素个数(意味着数组a不能容纳LinkedList中全部元素)
        // 则新建一个T[]数组，T[]的大小为LinkedList大小，并将该T[]赋值给a。
        if (a.length &amp;lt; size)
            a = (T[])java.lang.reflect.Array.newInstance(
                                a.getClass().getComponentType(), size);
        //将链表中所有节点的数据都添加到数组a中
        int i = 0;
        Object[] result = a;
        for (Node&amp;lt;E&amp;gt; x = first; x != null; x = x.next)
            result[i++] = x.item;

        if (a.length &amp;gt; size)
            a[size] = null;

        return a;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;后记 : 笔者才疏学浅，如果有哪处错误产生误导，请及时与笔者联系更正，一起共建积极向上的it氛围&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;文章参考：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/skywang12345/p/3308807.html&quot;&gt;Java 集合系列05之 LinkedList详细介绍(源码解析)和使用示例&lt;/a&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1515111/201905/1515111-20190530230235939-272331703.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 30 May 2019 14:56:00 +0000</pubDate>
<dc:creator>c旋儿</dc:creator>
<og:description>/Users/mr.l/Downloads/Unsplash/二维码.png</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cxuanBlog/p/10952578.html</dc:identifier>
</item>
<item>
<title>【原创】基于.NET的轻量级高性能 ORM - XFramework - 田乃翔</title>
<link>http://www.cnblogs.com/yiting/p/10952302.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yiting/p/10952302.html</guid>
<description>[unable to retrieve full-text content]【前言】 接上一篇《【原创】打造基于Dapper的数据访问层》，Dapper在应付多表自由关联、分组查询、匿名查询等应用场景时不免显得吃力，经常要手写SQL语句（或者用工具生成SQL配置文件）。试想一下，项目中整个DAL层都塞满了SQL语句，对于后期维护来说无异于天灾人祸，这个坑谁踩谁知道。本框架在</description>
<pubDate>Thu, 30 May 2019 14:03:00 +0000</pubDate>
<dc:creator>田乃翔</dc:creator>
<dc:identifier>https://www.cnblogs.com/yiting/p/10952302.html</dc:identifier>
</item>
</channel>
</rss>