<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>算法工程师想进一步提高竞争力？向TensorFlow开源社区贡献你的代码吧 - DeepLearningStack</title>
<link>http://www.cnblogs.com/deep-learning-stacks/p/10424914.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/deep-learning-stacks/p/10424914.html</guid>
<description>&lt;p&gt;[作者：&lt;a href=&quot;https://www.cnblogs.com/deep-learning-stacks&quot; target=&quot;_blank&quot;&gt;DeepLearningStack&lt;/a&gt;，阿里巴巴算法工程师，开源TensorFlow Contributor]&lt;/p&gt;
&lt;p&gt;“做算法的人要熟悉算法框架源码吗？算法工程师难道不应该会使用框架建模就可以了吗？如何成为具有一定竞争力的算法工程师？”...&lt;/p&gt;
&lt;p&gt;我经常被不同的人问类似这样的问题。坦白地说从我个人经验来看，身边算法做的不错的人对算法框架源码普遍熟悉，而且算法建模这件事在当前来看还并不能纯粹的与底层隔离，因为你会经常与计算性能，算法实现原理打交道。当然，我也见过一些比较浮躁的从业者，认为算法工程师应该只做建模不碰源码，这些人一般都只是根据网上教程跑通了个MNIST，ImageNet的例子就认为自己可以胜任算法工程师的工作了，&lt;strong&gt;这种人其实不是想做算法，而是不想写代码而已&lt;/strong&gt;。算法门槛表面上在降低，可其实是不断升高的。一方面，学术界算法创新竞争越来越激烈，主要表现在AI相关的顶会变多，accept的paper也越来越多，多到根本看不过来，你现在所想到的模型创新，没准在另一家公司或者学校已经走到实验验证阶段了；另一方面，性能优化和定制的功能开发等工程能力越来越重要。现在来看，市场上做想要算法的人非常多，但到面试通过的概率很低，这也侧面说明了竞争门槛其实是比较高的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;但这也是机会&lt;/strong&gt;。如果你是做算法的，请趁此机会提升自己的工程能力和算法领域内的影响力。How？其实很简单——为算法领域的知名开源软件贡献代码。因为我个人是TensorFlow的contributor，所以我以TensorFlow为例为大家介绍。&lt;/p&gt;

&lt;h2&gt;第一步 Fork！&lt;/h2&gt;
&lt;p&gt;首先，进入TensorFlow的GitHub页面，地址如下：&lt;a href=&quot;https://github.com/tensorflow/tensorflow&quot; target=&quot;_blank&quot;&gt;https://github.com/tensorflow/tensorflow&lt;/a&gt; ，可以看到如下页面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1437153/201902/1437153-20190223215203741-1955328077.png&quot; alt=&quot;&quot; width=&quot;819&quot; height=&quot;359&quot;/&gt;&lt;/p&gt;
&lt;p&gt;红色框内表示当前TensorFlow这个开源项目已经有1844个人贡献过代码，想要加入这个行列的coder们请努力吧，这并没有想象中那么难。因为我们无法直接对开源项目clone开发，而只能在我们自己的仓库中开发，所以我们需要点击Fork按钮，将该项目Fork到自己的GitHub仓库名下，然后我们就可以在我们自己的仓库中看到这个项目。&lt;/p&gt;
&lt;h2&gt;第二步 Clone自己的仓库&lt;/h2&gt;
&lt;p&gt;成功Fork之后，我们就可以将它Clone下来进行开发了。每次开发之前最好切出一个分支出来，避免直接在master上做修改。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1437153/201902/1437153-20190223220119488-181616471.png&quot; alt=&quot;&quot; width=&quot;743&quot; height=&quot;301&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;第三步 与Fork之前的开源master建立联系&lt;/h2&gt;
&lt;p&gt;自从我们Fork新项目起，我们自己仓库的master将不再与开源master有任何联系，也就是说我们自己仓库的master代码将不再随着开源master自动更新。那么如何及时更新自己的仓库呢？这需要为我们clone下来的项目添加upstream，即上游远程仓库。这非常简单，只需要一句命令即可搞定。我们需要将开源master的git地址复制下来然后添加到当前项目的，对于TensorFlow来说执行下面命令即可。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
git remote add upstream git@github.com:tensorflow/tensorflow.git
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样就与开源社区master建立起了联系，我们可以看到配置文件.git/config文件中确实添加了upstream。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1437153/201902/1437153-20190223221621276-534738317.png&quot; alt=&quot;&quot; width=&quot;436&quot; height=&quot;222&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;第四步 编写代码，提交到我们的仓库中&lt;/h2&gt;
&lt;p&gt;这一步比较常规，在本地切出开发分支，编写代码，提交到我们自己的仓库中。&lt;/p&gt;
&lt;h2&gt;第五步 生成Pull Request&lt;/h2&gt;
&lt;p&gt;当我们将自己的commit提交到自己的GitHub仓库之后，就可以向Fork源master提交Pull Request（简称PR）申请了。首先进入自己的GitHub仓库页面，点击New pull request按钮。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1437153/201902/1437153-20190223222241054-74265114.png&quot; alt=&quot;&quot; width=&quot;523&quot; height=&quot;338&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击后进入Comparing页面，我们选择需要往Fork源merge的分支，如下所示。由于我当前这个分支已经提交了PR，但还处于review期间，所以生成的页面不太一样。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1437153/201902/1437153-20190223222514890-2030624599.png&quot; alt=&quot;&quot; width=&quot;729&quot; height=&quot;311&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;第六步 填写代码贡献说明&lt;/h2&gt;
&lt;p&gt;这是最后一步，需要在生成的页面中填写自己要贡献这段代码的原因，然后引入相关的reviewer进行讨论。不得不说，这一部分非常关键，因为大部分reviewer只会review代码规范，而这段代码的作用本身需要大家自己解释清楚。如果你曾经在该项目中贡献过代码，那么会显示Contributor字样。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1437153/201902/1437153-20190223223141854-902934839.png&quot; alt=&quot;&quot; width=&quot;523&quot; height=&quot;239&quot;/&gt;&lt;/p&gt;
&lt;p&gt;自此，你成功的向开源社区提交了一个PR，离成为Contributor走进了一步。&lt;/p&gt;

&lt;p&gt;一般情况下，TensorFlow的reviewer响应都是比较快的，而且他们对于技术讨论非常开放，也非常愿意社区积极贡献代码。Reviewer会在你的PR上提出各种Comments，在不断的代码refine之后，代码将最终成功merge到开源master中，从状态上看你的PR将会显示紫色的Merged。如果到了这一步，那么恭喜你，成功成为了TensorFlow社区的Contributor！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1437153/201902/1437153-20190223223601609-2116110236.png&quot; alt=&quot;&quot; width=&quot;737&quot; height=&quot;376&quot;/&gt;&lt;/p&gt;

&lt;p&gt;TensorFlow社区master每天都会更新，所以建议每天做一次代码同步，非常简单，两行git命令就能搞定。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;git pull upstream master
git push origin master&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;分别是将upstream（也就是Fork源）代码更新到本地，向origin（自己的仓库远端）更新代码。&lt;/p&gt;

&lt;p&gt;因为你的贡献让TensorFlow更加完善，所以在之后的发布通告中会出现你的名字。下面的这段发布通告来自于TensorFlow 1.13.0 RC2，其实你可以从描述中看到，在1800+名Contributor中，绝大部分是Google内部的人，所以Google外部的Contributor非常少。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1437153/201902/1437153-20190223224442144-1795769662.png&quot; alt=&quot;&quot; width=&quot;488&quot; height=&quot;318&quot;/&gt;&lt;/p&gt;

&lt;p&gt;其实非常多。TensorFlow一大特点是通用性，希望能够在各种场景下均能够变得成熟。但是这个目的工程量浩大，不免存在Bug，设计不完善，性能不理想，功能不全面等情况。其实在使用TensorFlow建模时就会遇到他们，而且概率还真不小。当然你可以遇到问题选择绕开它们，但这可能也意味着你错失了一个提PR的机会。提PR的前提是你必须对源码有所了解，所以算法工程师们在读paper读累了的时候不妨换换思路，每天看一点TensorFlow源码多提升一些工程素养。&lt;/p&gt;

&lt;p&gt;TensorFlow是Google重要的算法军火库，Google围绕着TensorFlow本身还做了其他子项目，他们也非常重要。另外，也可以加入讨论组。&lt;/p&gt;
&lt;h2&gt;TensorFlow生态中的其他子项目&lt;/h2&gt;
&lt;p&gt;TensorFlow生态中子项目相当丰富，有前端TensorBoard，有易用性框架Estimator等等。这些子项目也同样需要社区贡献力量。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1437153/201902/1437153-20190223225959379-439305894.png&quot; alt=&quot;&quot; width=&quot;674&quot; height=&quot;514&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;TensorFlow 2.0的标准制定项目——Community&lt;/h2&gt;
&lt;p&gt;Community子项目其实就是TensorFlow的RFC文档，它是TensorFlow 2.0的标准，里面含有一些模块和接口的设计。为什么要关注RFC文档？这是因为TensorFlow的发展比较快，经常出现某些模块被弃用，某些新模块将要大力发展的情况。这些信息对于开发者非常重要，如果你想共享一段代码，但它与社区的发展标准背道而驰，那么将是无用功，所以RFC文档对于避免虚工是非常有用的。但一个标准的提出也需要经过社区的审核和讨论，所以如果有自己的想法，可以在Community中提出自己的comments，引入更多的人参与讨论。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1437153/201902/1437153-20190223231018820-1277909006.png&quot; alt=&quot;&quot; width=&quot;557&quot; height=&quot;296&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;扩展——与TensorFlow有关的项目&lt;/h2&gt;
&lt;p&gt;从TensorFlow项目这一个点出发，我们可以不怎么费力气地学习到更多的开源项目，而且TensorFlow架构和源码设计足够复杂，这使得我们在看其他相关项目时变得相对轻松。比如当你对TensorFlow使用单机多卡GPU通信感兴趣时，可以参考NCCL。当你对多机分布式感兴趣时，你或许可以看看Uber开源的Horovod。当你想要研究不同框架之间的差异时，你也许可以看看Pytorch，caffe2和MXNet。这种辐射式的积累会让我们学习更多的软件设计哲学。&lt;/p&gt;

&lt;p&gt;由于本人也是算法工程师，工作中不仅是TensorFlow的用户，也在自己所任职的公司参与TensorFlow的定制开发与性能优化。从我个人角度来看，算法工程师这个职位不得不说是含有大量水分的，一方面真正懂算法能够在AI顶会发一些高质量paper的人占比并不高，另一方面，在算法工程上理解较深的人也并不多，而在算法和工程两方面都比较强的人就更少了。现在属于算法领域较热的时段，这方面的油水，薪资竞争力和需求量都很大，所以市场上存在很多想要进入这个领域的人，这是好事。但是如果一个人自己跑几个模型例子就声称自己可以做算法并且十分反感写代码的话，那他在算法领域也不会有很好的发展。除非，你是一个算法造诣非常高的天才并且能够胜任&lt;strong&gt;算法科学家&lt;/strong&gt;的人。否则，请不要欺骗自己，认真培养你的&lt;strong&gt;算法能力&lt;/strong&gt;和&lt;strong&gt;工程能力，&lt;/strong&gt;毕竟你的目标还是一个合格的算法工程师。&lt;/p&gt;

</description>
<pubDate>Sat, 23 Feb 2019 15:47:00 +0000</pubDate>
<dc:creator>DeepLearningStack</dc:creator>
<og:description>算法工程师为什么也要向社区贡献代码？ [作者：DeepLearningStack，阿里巴巴算法工程师，开源TensorFlow Contributor] “做算法的人要熟悉算法框架源码吗？算法工程师难</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/deep-learning-stacks/p/10424914.html</dc:identifier>
</item>
<item>
<title>Django中CBV(Class Base Views)模型源码分析 - 伍萬磊</title>
<link>http://www.cnblogs.com/wanlei/p/10403476.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wanlei/p/10403476.html</guid>
<description>&lt;h2 id=&quot;在view文件中编写一个类并配置好路由&quot;&gt;在view文件中编写一个类，并配置好路由&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;class Test(View):
    def get(self, request, *args, **kwargs):
        return HttpResponse('cbv_get')

    def post(self, request, *args, **kwargs):
        return HttpResponse('cbv_post')&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;url(r'test/',views.Test.as_view()),&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;通过as_view进入查看源码&quot;&gt;通过as_view()进入查看源码&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1442172/201902/1442172-20190223233530795-1544475473.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;实际上views.test.as_view是存的一个内存地址加括号被调用执行了as_view方法里的view方法具体看下图&quot;&gt;实际上views.Test.as_view()是存的一个内存地址，加括号被调用，执行了as_view方法里的view方法，具体看下图：&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1442172/201902/1442172-20190223233544464-1611326783.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;核心是dispatch方法在dispatch方法中完成了分发功能&quot;&gt;核心是dispatch方法，在dispatch方法中完成了分发功能。&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1442172/201902/1442172-20190223233556545-1741343158.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;若要在test类中自定义dispatch方法代码如下&quot;&gt;若要在Test类中自定义dispatch方法，代码如下：&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;class Test(View):
    def dispatch(self, request, *args, **kwargs):
        # 加代码
        obj = super().dispatch(self, request, *args, **kwargs)
        # 加代码
        # 实现了一个类似装饰器的效果，比如post请求，如果是json，手动从request里body取出来 再转一下
        # 或者走的时候加点cookie
        return obj
    
    def get(self, request, *args, **kwargs):
        return HttpResponse('cbv_get')

    def post(self, request, *args, **kwargs):
        return HttpResponse('cbv_post')&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;流程总结&quot;&gt;流程总结：&lt;/h2&gt;
&lt;h4 id=&quot;cbv模型&quot;&gt;CBV模型&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;在views中写一个类,继承View,里面写get方法,post方法&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;在路由中配置: url(r'^test/', views.Test.as_view()),实际上第二个参数位置,放的还是一个函数内存地址&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;当请求来了,就会执行第二个参数(request,参数),本质上执行view()&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;view内部调用了dispatch()方法&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;dispatch分发方法,根据请求方式不同,执行的方法不同&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sat, 23 Feb 2019 15:45:00 +0000</pubDate>
<dc:creator>伍萬磊</dc:creator>
<og:description>在view文件中编写一个类，并配置好路由 通过as_view()进入查看源码 实际上views.Test.as_view()是存的一个内存地址，加括号被调用，执行了as_view方法里的view方法，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wanlei/p/10403476.html</dc:identifier>
</item>
<item>
<title>四种途径提高RabbitMQ传输数据的可靠性（二） - JJian</title>
<link>http://www.cnblogs.com/jian0110/p/10424927.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jian0110/p/10424927.html</guid>
<description>&lt;blockquote readability=&quot;9.4014084507042&quot;&gt;
&lt;p&gt;上一篇&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/jian0110/p/10419013.html&quot;&gt;四种途径提高RabbitMQ传输消息数据的可靠性（一）&lt;/a&gt;已经介绍了两种方式提高数据可靠性传输的方法，本篇针对上一篇中提出的问题（1）与问题（2）提出解决常用的方法。&lt;/p&gt;
&lt;p&gt;本文其实也就是结合以上四个方面进行讲解的，主要参考《RabbitMQ实战指南》（有需要PDF电子书的可以评论或者私信我），本文截图也来自其中，另外可以对一些RabbitMQ的概念的认识可以参考我的另外两篇博文&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl01_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/jian0110/p/10389780.html&quot;&gt;认识RabbitMQ交换机模型&lt;/a&gt;、&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/jian0110/p/10389986.html&quot;&gt;RabbitMQ是如何运转的？&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr/&gt;

&lt;p&gt;&lt;strong&gt;针对问题（1），我们可以通过生产者的确认消息机制来解决，主要分为两种：第一是事务机制、第二是发送方确认机制&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;1、事务机制&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　与事务机制相关的有三种方法，&lt;strong&gt;分别是channel.txSelect设置当前信道为事务模式、channel.txCommit提交事务和channel.txRollback事务回滚。如果事务提交成功，则消息一定是到达了RabbitMQ中，如果事务提交之前由于发送异常或者其他原因，捕获后可以进行channel.txRollback回滚。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将信道设置为事务模式，开启事务&lt;/span&gt;
&lt;span&gt;channel.txSelect(); 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 发送持久化消息&lt;/span&gt;
channel.basicPublish(EXCHANGE_NAME, ROUTING_KEY, MessageProperties.PERSISTENT_TEXT_PLAIN, &quot;transaction messages&quot;&lt;span&gt;.getBytes()); 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 事务提交&lt;/span&gt;
channel.txCommit();
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;发生异常之后事务回滚&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
    　　channel.txSelect();
       channel.basicPublish(exchange, routingKey, MessageProperties.PERSISTENT_TEXT_PLAIN, &lt;/span&gt;&quot;transaction messages&quot;&lt;span&gt;.getBytes());
       channel.txCommit();
　　} &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e){
       e.printStackTrace();
       channel.txRollback();
   }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;strong&gt;2、确认机制&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　&lt;span&gt;　&lt;span&gt;&lt;strong&gt;生产者将信道设置为confirm确认模式，确认之后所有在信道上的消息将会被指派一个唯一的从1开始的ID，一旦消息被正确匹配到所有队列后，RabbitMQ就会发送一个确认Basic.Ack给生产者（包含消息的唯一ID），生产者便知晓消息是否正确到达目的地了。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;　　　　　　　　　　　　　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1352849/201902/1352849-20190223221457597-1239923675.png&quot; alt=&quot;&quot; width=&quot;712&quot; height=&quot;315&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　消息如果是持久化的，那么确认消息会在消息写入磁盘之后发出。RabbitMQ中的deliveryTag包含了确认消息序号，还可以设置multiple参数，表示到这个序号之前的所有消息都已经得到处理。&lt;/span&gt;&lt;span&gt;确认机制相对事务机制来说，相比较代码来说比较复杂，但会经常使用，主要有单条确认、批量确认、异步批量确认三种方式。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;　　2.1 单条确认&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　此种方式比较简单，一般都是一条条的发送，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
    Connection connection &lt;/span&gt;=&lt;span&gt; connectionFactory.newConnection();
    Channel channel &lt;/span&gt;=&lt;span&gt; connection.createChannel();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;set channel publisher confirm mode &lt;/span&gt;
&lt;span&gt;    channel.confirmSelect();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; publish message&lt;/span&gt;
    channel.basicPublish(&quot;exchange&quot;, &quot;routingkey&quot;, &lt;span&gt;null&lt;/span&gt;, &quot;publisher confirm test&quot;&lt;span&gt;.getBytes());
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;channel.waitForConfirms()) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; publisher confirm failed handle&lt;/span&gt;
        System.out.println(&quot;send message failed!&quot;&lt;span&gt;);
    }
} &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
    e.printStackTrace();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;strong&gt;　　2.2 批量确认&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;　　问：&lt;/strong&gt;批量确认comfirm需要解决&lt;strong&gt;&lt;span&gt;出现返回的Basic.Nack或者超时情况的话，客户需要将这一批次消息全部重发，那么采用什么样的存储结构才能合适地将这些消息动态筛选出来。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;最好是需要增加一个缓存，将发送成功并且确认Ack之后的消息去除，剩下Nack或者超时的消息，改进之后的代码如下：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; take ArrayList or BlockingQueue as a cache&lt;/span&gt;
List&amp;lt;Object&amp;gt; cache = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; set channel publisher confirm mode&lt;/span&gt;
&lt;span&gt;channel.confirmSelect();
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=0; i &amp;lt; 20; i++&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; publish message&lt;/span&gt;
    String message = &quot;publisher message[&quot;+ i +&quot;]&quot;&lt;span&gt;;
    cache.add(message);
    channel.basicPublish(&lt;/span&gt;&quot;exchange&quot;, &quot;routingkey&quot;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;, message.getBytes());
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (channel.waitForConfirms()) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; remove message publisher confirm&lt;/span&gt;
&lt;span&gt;        cache.remove(i);
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO handle Nack message：republish&lt;/span&gt;
&lt;span&gt;}
} &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
　　e.printStackTrace();
　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO handle Nack message：republish&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;strong&gt;      2.3 异步批量确认&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　异步确认方式通过在客户端addConfirmListener增加ConfirmListener回调接口，包括handleAck与handleNack处理方法：&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;每次发送消息confirmSet集合元素加1，当消息被确认ack进入handleAck方法时，“unconfirm”集合中删除响应的一条（multiple设置为false时）或者多条记录（multiple设置为true时），其中存储缓存最好采用SortedSet数据结构&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
    Connection connection &lt;/span&gt;=&lt;span&gt; connectionFactory.newConnection();
    Channel channel &lt;/span&gt;=&lt;span&gt; connection.createChannel();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; take  as a cache&lt;/span&gt;
    SortedSet cache = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TreeSet();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; set channel publisher confirm mode&lt;/span&gt;
&lt;span&gt;    channel.confirmSelect();
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 20; i++&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; publish message&lt;/span&gt;
        &lt;span&gt;long&lt;/span&gt; nextSeqNo =&lt;span&gt; channel.getNextPublishSeqNo();
        String message &lt;/span&gt;= &quot;publisher message[&quot; + i + &quot;]&quot;&lt;span&gt;;
        cache.add(message);
        channel.basicPublish(&lt;/span&gt;&quot;exchange&quot;, &quot;routingkey&quot;&lt;span&gt;, MessageProperties.PERSISTENT_TEXT_PLAIN, message.getBytes());
        cache.add(nextSeqNo);

    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; add confirmCalback: handleAck, handleNack&lt;/span&gt;
    channel.addConfirmListener(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConfirmListener() {
        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; handleAck(&lt;span&gt;long&lt;/span&gt; deliveryTag, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; multiple) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (multiple) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; batch remove ack message&lt;/span&gt;
                cache.headSet(deliveryTag - 1&lt;span&gt;).clear();
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; remove ack message&lt;/span&gt;
&lt;span&gt;                cache.remove(deliveryTag);
            }
        }
        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; handleNack(&lt;span&gt;long&lt;/span&gt; deliveryTag, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; multiple) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO handle Nack message：republish&lt;/span&gt;
&lt;span&gt;        }
    });

} &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
    e.printStackTrace();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO handle Nack message：republish&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3、总结比较&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;　　1）是确认机制好呢？还是事务机制？两者可以共存吗？&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;确认机制相对于事务机制，最大的好处就是可以异步处理提高吞吐量，不需要额外等待消耗资源。但是两者时候不能同时共存的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　&lt;strong&gt;2）那么确认机制的三种方式之间呢？实际产生环境是推荐哪一种呢？（其实毫无疑问当然是推荐异步批量确认方式）&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;批量确认的最大问题就是在于返回的Nack消息需要重新发送，以上普通单条确认、批量确认、批量异步确认三种方法，在实际生产环境中强烈推荐使用批量异步确认方式。&lt;/p&gt;
&lt;/blockquote&gt;


&lt;p&gt;&lt;strong&gt;针对的问题（2），我们可以通过增加队列与消息的持久化来实现。&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;1、交换器的持久化&lt;/h2&gt;
&lt;p&gt;　　交换器的持久化是通过声明队列durable参数为true实现的，&lt;span&gt;&lt;strong&gt;如果交换器不设置持久化，那么在RabbitMQ服务器重启之后，相关的交换器元数据会丢失，消息不会丢失，只是不能将消息发送到这个交换器中&lt;/strong&gt;&lt;/span&gt;。因此，都是建议将其置为持久化。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
channel.exchangeDeclare(EXCHANGE_NAME, &quot;direct&quot;, &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt; 2、队列的持久化&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;队列持久化同理与交换器持久化，只是RabbitMQ服务器重启之后，相关的元数据会丢失，数据也会跟着丢失，消息也自然丢失。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
 channel.queueDeclare(QUEUE_NAME, &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3、消息的持久化&lt;/h2&gt;
&lt;p&gt;　　队列的持久化不能保证内存存储的消息不会丢失，&lt;span&gt;&lt;strong&gt;要确保消息不会丢失，需要将其通过设置BasicProperties中的deliveryMode属性为2可实现消息的持久化（PERSISTENT_TEXT_PLAIN实际上已经封装了这个属性），也就是说只有实现了队列与消息的持久化，才能保证消息不会丢失。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 其中的2就是投递模式&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Class &lt;span&gt;final&lt;/span&gt; BasicProperties_PERSISTENT_TEXT_PLAIN = &lt;br/&gt;&lt;span&gt;new&lt;/span&gt; BasicProperties(&quot;text/plain&quot;, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;, 2, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;4、消息丢失的几种情况&lt;/h2&gt;
&lt;p&gt;　　但实际上不是设置了交换器、队列、消息持久化就能一定保证消息不会被丢失，以下几种情况是可能丢失的，比如：&lt;/p&gt;
&lt;p&gt;　　1）&lt;span&gt;&lt;strong&gt;设置autoAck为true，消费者收到消息后，还没处理就宕机了，这样也算数据丢失，解决办法是设置为false，之后手动确认。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/span&gt;2）在设置了持久化后消息存入RabbitMQ之后，还需要一段时间才能存入磁盘之中（虽然很短，但不能忽视），RabbitMQ并不会为每条消息都今次那个同步存盘，可能只会保存到操作系统缓存之中而不是物理磁盘中&lt;span&gt;&lt;strong&gt;，&lt;span&gt;如果RabbitMQ这个时间段内宕机、异常、重启等情况，消息也会丢失，解决办法是引入RabbitMQ的镜像队列机制（类似于集群，Master挂了切换到Slave）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　没有完全十全十美的方式能保证数据能100%不丢失，并且最大效率节约性能消耗等，两篇博文虽然已经提出常用的四种方式，当实际环境中整个RabbitMQ环境在搭建没有结合实际的生产业务环境的话，也会发生消息丢失的等情况，解决这样的问题无非就完善消息备份，健全RabbitMQ集群..........&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 23 Feb 2019 15:41:00 +0000</pubDate>
<dc:creator>JJian</dc:creator>
<og:description>前言 上一篇四种途径提高RabbitMQ传输消息数据的可靠性（一）已经介绍了两种方式提高数据可靠性传输的方法，本篇针对上一篇中提出的问题（1）与问题（2）提出解决常用的方法。 本文其实也就是结合以上四</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jian0110/p/10424927.html</dc:identifier>
</item>
<item>
<title>iptables 指南 - -Finley-</title>
<link>http://www.cnblogs.com/Finley/p/10424842.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Finley/p/10424842.html</guid>
<description>&lt;p&gt;iptables 是 Linux 内核集成的防火墙系统, 几乎所有 Linux 发行版都会内置 iptables。&lt;/p&gt;
&lt;p&gt;iptables 对进出的 IP 数据报进行处理和过滤, 过滤规则(rule)存储在4个表(table)中, 表中的规则又组成了数条完整的规则链(chain)。&lt;/p&gt;
&lt;p&gt;iptables 可以追踪数据包所属的连接(TCP/UCP/ICMP协议)及其状态，允许根据连接状态进行处理和过滤。&lt;/p&gt;

&lt;p&gt;iptables 中有四张表, 优先级从高到低是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;raw: 某个链上一旦使用了raw表将会跳过 NAT 和连接跟踪处理。&lt;/li&gt;
&lt;li&gt;mangle: 用于修改数据包的内容&lt;/li&gt;
&lt;li&gt;nat: 用于网络地址转换，可以修改数据包的源地址或目标地址&lt;/li&gt;
&lt;li&gt;filter: iptables 的默认表, 可以抛弃或接受数据包&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;表中的规则构成了链:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;PREROUTING: 来自网络接口(网卡)的数据包首先会经过 PREROUTING 链，经过 raw, mangle, nat 表中规则的处理然后进行路由判断。
&lt;ul&gt;&lt;li&gt;若数据包的目的地址为本机则会进入INPUT链&lt;/li&gt;
&lt;li&gt;若数据包的目的地址为其它地址则进入FORWARD链进行转发&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;INPUT: 处理目标为本机的数据包, 经过 mangle,filter 表中规则的处理然后发给 nginx、mysql等上层进程处理 (此处存疑: nat 表中似乎也包括INPUT链, 望大佬指正)&lt;/li&gt;
&lt;li&gt;FORWARD: 处理转发的数据包，经过 mangle, filter 表中规则处理后进入POSTROUTING链&lt;/li&gt;
&lt;li&gt;OUTPUT: 处理本地进程发出的数据包, 经过 raw, mangle, nat, filter 表中规则的处理然后进入POSTROUTING链&lt;/li&gt;
&lt;li&gt;POSTROUTING: 处理来自 FORWARD 和 OUTPUT 链的数据包并发送给网络接口发出，可在 raw, mangle, nat 表中配置规则&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在运行中 iptables 可能处理三种场景:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;入站数据流: 网络接口 -&amp;gt; PREROUTING -&amp;gt; INPUT -&amp;gt; 本地&lt;/li&gt;
&lt;li&gt;转发数据流: 网络接口 -&amp;gt; PREROUTING -&amp;gt; FORWARD -&amp;gt; POSTROUTING -&amp;gt; 网络接口&lt;/li&gt;
&lt;li&gt;出站数据流: 本地 -&amp;gt; OUTPUT -&amp;gt; POSTROUTING -&amp;gt; 网络接口&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;虽然我们通常将 iptables 视为单个实体， 但实际上它由两部分组成: 执行数据包过滤处理的内核模块 netfilter 和运行于用户空间的过滤规则配置工具 iptables。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;iptables 是有状态的防火墙，使用 ip_conntrack 模块进行连接跟踪。ip_conntrack 可以实时追踪本机的 ICMP/TCP/UDP 流并保存在内存中。&lt;/p&gt;
&lt;p&gt;根据数据包在连接中的角色，将数据包分为四种状态:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;NEW: 连接的第一个包比如TCP的SYN包&lt;/li&gt;
&lt;li&gt;ESTABLISHED: 只要连接被回复那么连接的状态就是 ESTABLISHED, 比如TCP中第一个回答 ACK/SYN 包&lt;/li&gt;
&lt;li&gt;RELATED: 当包和某个 ESTABLISHED 状态有关系时即处于 RELATED 状态。 比如 FTP-Data 会被标记为与 FTP-control 有关。&lt;/li&gt;
&lt;li&gt;INVALID: 无法识别包所属的连接或没有任何状态，通常会丢弃这些包&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;连接追踪允许我们根据包的连接状态进行过滤。比如我们只允许本地 80 端口的 HTTP 服务器进行响应而不允许通过 80 端口主动向外请求，那么在本地 80 端口的出方向上只允许 ESTABLISHED 状态的包不允许 NEW 状态数据包即可。(通常情况下 HTTP 服务器进程是可以主动向外请求的，但是本地地址不会是 80 端口)&lt;/p&gt;
&lt;p&gt;入站数据流和转发数据流是在 PREROUTING 链中进行连接追踪的(即标记所属连接和状态), 出站数据流在 OUTPUT 链中进行状态追踪。使用 RAW 表可以配置数据流绕过状态追踪。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;iptables -h&lt;/code&gt; 可以查看 iptables 自带的帮助手册。&lt;/p&gt;
&lt;p&gt;我们将 iptables 命令分解为几部分:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;iptables -t &amp;lt;table&amp;gt; &amp;lt;cmd&amp;gt; &amp;lt;pattern&amp;gt; &amp;lt;action&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;-t &amp;lt;table&amp;gt;&lt;/code&gt; 或 &lt;code&gt;--table &amp;lt;table&amp;gt;&lt;/code&gt; 选项用来指定要查看或修改的表(raw, mangle, nat, filter)。&lt;/p&gt;
&lt;p&gt;常用的 iptables 命令选项(上文中的&lt;code&gt;&amp;lt;cmd&amp;gt;&lt;/code&gt;部分)包括:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;-L &amp;lt;chain&amp;gt;&lt;/code&gt; / &lt;code&gt;--list &amp;lt;chain&amp;gt;&lt;/code&gt;: 列出某条规则链中所有规则, 不指定 &lt;code&gt;chain&lt;/code&gt; 参数则列出指定表中所有链上的规则。iptables 会按照列出的顺序依次尝试匹配规则并执行匹配的动作。规则可用链上的序号来描述，第一条规则的序号为1（不是编程语言常见的0）。
&lt;ul&gt;&lt;li&gt;&lt;code&gt;-L -V&lt;/code&gt; / &lt;code&gt;-L --verbose&lt;/code&gt; 会显示更详细的内容&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-A &amp;lt;chain&amp;gt;&lt;/code&gt; / &lt;code&gt;--append &amp;lt;chain&amp;gt;&lt;/code&gt;: 在规则链的末尾添加规则, 规则的内容由后面的匹配选项&lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt;和动作&lt;code&gt;&amp;lt;action&amp;gt;&lt;/code&gt;两部分来描述&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-I &amp;lt;chain&amp;gt; &amp;lt;index&amp;gt;&lt;/code&gt; / &lt;code&gt;--insert &amp;lt;chain&amp;gt; &amp;lt;index&amp;gt;&lt;/code&gt;: 在规则链的指定位置插入规则。&lt;code&gt;-i INPUT 2&lt;/code&gt;会在INPUT链第2个位置插入一条规则，原第2条及以后的规则均后移一位&lt;/li&gt;
&lt;li&gt;&lt;code&gt;- R &amp;lt;chain&amp;gt; &amp;lt;index&amp;gt; /&lt;/code&gt; / &lt;code&gt;--replace &amp;lt;chain&amp;gt; &amp;lt;index&amp;gt;&lt;/code&gt;: 替换规则链指定位置上的规则&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-D &amp;lt;chain&amp;gt;&lt;/code&gt; / &lt;code&gt;--delete &amp;lt;chain&amp;gt;&lt;/code&gt;: 删除链上某条规则，可以使用序号指定某条规则或者使用匹配和动作完整描述规则进行删除&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-F &amp;lt;chain&amp;gt;&lt;/code&gt; / &lt;code&gt;--flush &amp;lt;chain&amp;gt;&lt;/code&gt;: 删除链上的全部规则&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-P &amp;lt;chain&amp;gt; &amp;lt;action&amp;gt;&lt;/code&gt; / &lt;code&gt;--policy &amp;lt;chain&amp;gt; &amp;lt;action&amp;gt;&lt;/code&gt;: 修改某条链的默认策略, 示例&lt;code&gt;iptables -P filter ACCEPT&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;iptables 的规则(&lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt;)包含匹配条件和动作两部分。可以根据网络接口、地址、协议等进行匹配:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;-i&lt;/code&gt; / &lt;code&gt;--in-interface&lt;/code&gt;: 进入的网络接口，如以太网eth, 本地回环lo。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-o&lt;/code&gt; / &lt;code&gt;--out-interface&lt;/code&gt;: 输出的网络接口&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-s&lt;/code&gt; / &lt;code&gt;--source&lt;/code&gt;: 输入IP地址, 格式为 &lt;code&gt;address[/mask]&lt;/code&gt;, 如&lt;code&gt;192.168.1.1&lt;/code&gt;, &lt;code&gt;192.168.1.0/24&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-d&lt;/code&gt; / &lt;code&gt;--destination&lt;/code&gt;: 目标IP地址&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-p&lt;/code&gt;/ &lt;code&gt;---proto&lt;/code&gt;: 协议类型, 包括TCP/UCP/ICMP等&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--sport&lt;/code&gt;: 源端口号&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--dport&lt;/code&gt;: 目标端口号&lt;/li&gt;
&lt;li&gt;&lt;code&gt;–-state&lt;/code&gt;: 连接跟踪状态, 需要&lt;code&gt;-m state&lt;/code&gt;启动连接跟踪模块。示例: &lt;code&gt;--state NEW,ESTABLISHED&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;ifconfig&lt;/code&gt; 命令可以查看本机可用的网络接口&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;iptables 常用规则的动作(&lt;code&gt;&amp;lt;action&amp;gt;&lt;/code&gt;)包括:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ACCEPT: 允许数据包通过，进入下一条规则&lt;/li&gt;
&lt;li&gt;REJECT: 拦截数据包并发送回执数据包通知发送方，可用的回执有: &lt;code&gt;ICMP port-unreachable&lt;/code&gt;, &lt;code&gt;ICMP echo-reply&lt;/code&gt;, &lt;code&gt;tcp-reset&lt;/code&gt;&lt;br/&gt;示例: &lt;code&gt;iptables -A INPUT -p TCP --dport 22 -j REJECT --reject-with tcp-reset&lt;/code&gt; 拒绝22端口的tcp连接&lt;/li&gt;
&lt;li&gt;DROP: 丢弃数据包不返回回执，不继续执行过滤&lt;/li&gt;
&lt;li&gt;SNAT: 源地址转换(Source Network Address Translation), 将包的源地址改写为指定地址。完成此动作后将直接跳往下一条规则链(如POSTROUTING)&lt;br/&gt;示例: &lt;code&gt;iptables -t nat -A POSTROUTING -s 192.168.2.0/24 -j SNAT --to-source 192.168.1.1-192.168.1.100:2000-3000&lt;/code&gt;&lt;br/&gt;连接跟踪功能会使连接后续的应答数据包送达发送者&lt;/li&gt;
&lt;li&gt;MASQUERADE: 将数据包的源地址改写为防火墙的地址但可以指定端口号, 与SNAT相比更适合防火墙工作在 DHCP 等动态地址网络环境中的情况。完成此动作后将直接跳往下一条规则链(如POSTROUTING)&lt;br/&gt;示例: &lt;code&gt;iptables -t nat -A POSTROUTING -s 192.168.2.0/24 -j MASQUERADE --to-ports 2000-3000&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;DNAT: 目的地址转换, 将包目的地址改写到指定地址,完成此动作后将直接跳往下一条规则链。此功能可以为其它服务进行反向代理&lt;br/&gt;示例: &lt;code&gt;iptables -t nat -A PREROUTING -s 192.168.1.10 --sport 80 -j DNAT --to-destination 192.168.1.11:80&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;REDIRECT: 重定向到另一个端口，可以为本地服务提供反向代理&lt;br/&gt;示例: &lt;code&gt;iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-ports 8080&lt;/code&gt; 将对本地80端口的数据包重定向到8080&lt;/li&gt;
&lt;li&gt;MIRROR: 回声, 将源地址与目的地址对换位置后发送给原发送者&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;保存规则&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;iptables 命令修改后规则只存在于内存中, 使用&lt;code&gt;service iptables save&lt;/code&gt;保存规则到配置文件。&lt;/p&gt;
&lt;p&gt;默认配置文件地址一般为&lt;code&gt;/etc/sysconfig/iptables&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;修改&lt;code&gt;/etc/sysconfig/iptables-config&lt;/code&gt;中的配置项:&lt;br/&gt;&lt;code&gt;IPTABLES_SAVE_ON_STOP=yes&lt;/code&gt;在 iptables 服务停止时存储规则。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;iptables-save&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;iptables -L&lt;/code&gt; 只能逐表查看规则，&lt;code&gt;iptables-save&lt;/code&gt; 命令将 netfilter 内核模块中的规则导出到标准输出。&lt;/p&gt;
&lt;p&gt;我们可以使用 iptables-save 查看所有规则, 或将其备份到文件中。&lt;/p&gt;
&lt;p&gt;iptables-save 命令执行读取操作，不会更改 iptables 配置请放心使用。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;iptables-save -t &amp;lt;table&amp;gt;&lt;/code&gt; 仅导出指定表的内容。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;iptables-save -c&lt;/code&gt; 将会导出字节计数器和包计数器的值。&lt;/p&gt;
&lt;h2 id=&quot;示例&quot;&gt;示例&lt;/h2&gt;
&lt;p&gt;查看规则:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;iptables -L&lt;/code&gt; 列出默认表 filter 所有链上的规则。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iptables -t nat -L&lt;/code&gt; 列出 nat 表中所有链上的规则&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iptables -t nat -L PREROUTING&lt;/code&gt; 列出 nat 表中 PREROUTING 链上的规则&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;拦截特定流量:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;iptables -t filter -A INPUT -s 11.11.11.11 -j DROP&lt;/code&gt; 拦截来自特定 IP 地址(11.11.11.11)对本地服务全部流量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iptables -t filter -D INPUT -s 11.11.11.11 -j DROP&lt;/code&gt; 删除上一条拦截规则&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iptables -t filter -A INPUT -p tcp -sport 445 -j DROP&lt;/code&gt; 封锁特定端口(TCP 445)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iptables -t filter -A INPUT -p icmp --icmp-type echo-request -j REJECT ---reject-with icmp-host-prohibited&lt;/code&gt; 禁止 ICMP (ping)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iptables -t filter -A OUTPUT -p tcp --dport 80 -m state --state NEW -j DROP&lt;/code&gt; 禁止从80端口发起新的TCP连接但允许80端口响应TCP连接&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;作为网关提供NAT服务:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;iptables -t nat -A POSTROUTING -s 192.168.2.0/24 -j SNAT --to-source 192.168.1.1&lt;/code&gt; 将来自192.168.2.0/24子网数据包源地址改写为192.168.1.1&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iptables -t nat -A POSTROUTING -s 192.168.2.0/24 -j MASQUERADE&lt;/code&gt; 将来自192.168.2.0/24子网数据包源地址改写为防火墙地址&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iptables -t nat -A PREROUTING -d 192.168.1.1/24 --dport 80 -j DNAT --to-destination 192.168.1.11:80&lt;/code&gt; 将对192.168.1.1:80的数据包发送到192.168.1.11:80&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-ports 8080&lt;/code&gt;将对本地80端口的数据包重定向到8080&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sat, 23 Feb 2019 15:18:00 +0000</pubDate>
<dc:creator>-Finley-</dc:creator>
<og:description>iptables 原理、操作、连接追踪与示例</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Finley/p/10424842.html</dc:identifier>
</item>
<item>
<title>玩转Spring Cloud之熔断降级（Hystrix）与监控 - 梦在旅途</title>
<link>http://www.cnblogs.com/zuowj/p/10418932.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zuowj/p/10418932.html</guid>
<description>&lt;p&gt;为了防止服务消费链（多级服务之间的调用）上因某个服务出现故障，而导致级联故障，进而造成整个系统不可用（简称为：雪崩效应），推出了熔断、降级的处理方式：Hystrix断路器（类似生活中电路保险丝）来解决这些潜在问题。&lt;/p&gt;
&lt;p&gt;熔断、降级是两个概念，网上也有很多相关的说明，我这里简单通俗说明一下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;熔断&lt;/strong&gt;：当服务消费链上，下游服务因访问压力过大而出现响应变慢或失败不可用，上游服务为了保护系统整体的可用性（避免无效重试及长时等待等情况），可以暂时切断对下游服务的调用，直接快速返回错误的响应信息，当检测到该下游服务节点调用响应正常后再恢复消费链路。这个过程可以通过如下图形象说明：（图片来自&lt;a href=&quot;http://www.ityouknow.com/springcloud/2017/05/16/springcloud-hystrix.html&quot; target=&quot;_blank&quot;&gt;http://www.ityouknow.com/springcloud/2017/05/16/springcloud-hystrix.html&lt;/a&gt;，文中也有说明）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/458152/201902/458152-20190223145915061-968819568.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;熔断关闭状态（Closed）：服务没有故障时，熔断器所处的状态，对调用方的调用不做任何限制。&lt;/p&gt;
&lt;p&gt;熔断开启状态（Open）：在固定时间窗口内（Hystrix默认是10秒），接口调用出错比率达到一个阈值（Hystrix默认为50%），会进入熔断开启状态。进入熔断状态后，后续对该服务接口的调用不再经过网络，直接执行本地的fallback方法。&lt;/p&gt;
&lt;p&gt;半熔断（半开启）状态（Half-Open）：在进入熔断开启状态一段时间之后（Hystrix默认是5秒），熔断器会进入半熔断状态。所谓半熔断就是尝试恢复服务调用，允许有限的流量调用该服务，并监控调用成功率。如果成功率达到预期，则说明服务已恢复，进入熔断关闭状态；如果成功率仍旧很低，则重新进入熔断关闭状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;降级&lt;/strong&gt;：降低服务标准以满足核心重要服务正常运转，详情的说明请参见：&lt;a href=&quot;https://blog.51cto.com/8132260/2133705&quot; target=&quot;_blank&quot;&gt;https://blog.51cto.com/8132260/2133705&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Hystrix是什么，具体工作原理请参见：&lt;a href=&quot;https://ken.io/note/netflix-hystrix-intro-principle&quot; target=&quot;_blank&quot;&gt;Netflix Hystrix断路器简介与工作原理&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7.5245901639344&quot;&gt;
&lt;p&gt;Tips：我们在项目中经常需要添加很多的maven依赖，依赖组件（或称类库）的名字可能各不相同，我们可以通过如下方式查询相关的maven依赖包及其依赖包本身的内部依赖详情&lt;/p&gt;
&lt;p&gt;通过官网：&lt;a href=&quot;http://mvnrepository.com/&quot; target=&quot;_blank&quot;&gt;http://mvnrepository.com/&lt;/a&gt;，或者：&lt;a href=&quot;https://search.maven.org/&quot; target=&quot;_blank&quot;&gt;https://search.maven.org/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;一、搭建服务消费者项目，并集成 Hystrix环境&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　请参见上篇《&lt;a href=&quot;https://www.cnblogs.com/zuowj/p/10408221.html&quot; target=&quot;_blank&quot;&gt;玩转Spring Cloud之服务注册发现（eureka）及负载均衡消费（ribbon、feign）&lt;/a&gt;》搭建注册中心，服务提供者，服务消费者，本文仍然使用上篇文章中所创建的服务消费者demo项目：eurekaclientconsumer&lt;/p&gt;
&lt;p&gt;　　1.1.在POM XML中添加Hystrix依赖(spring-cloud-starter-netflix-hystrix)，配置如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 这里dependencyManagement附带贴出来，目的是说明如果不输version，想实现依赖继承，就需要这个，如果PMO中已经有则可不必再重复添加&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;    
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependencyManagement&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-cloud-dependencies&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;${spring-cloud.version}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;pom&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;import&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependencyManagement&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-cloud-starter-netflix-hystrix&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　1.2.&lt;strong&gt;采用Ribbon + Hystrix的方式&lt;/strong&gt;，在spring boot启动类(EurekaclientconsumerApplication)上添加@EnableHystrix，并修改远程服务调用类（HelloService），在相应的方法中添加@HystrixCommand注解并配置相关参数，具体实现代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;spring boot启动类：&lt;/span&gt;

&lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.zuowenjun.cloud;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.SpringApplication;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.autoconfigure.SpringBootApplication;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cloud.client.discovery.EnableDiscoveryClient;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cloud.client.loadbalancer.LoadBalanced;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cloud.netflix.hystrix.EnableHystrix;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cloud.openfeign.EnableFeignClients;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Bean;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.client.RestTemplate;

@EnableHystrix
@EnableDiscoveryClient
@SpringBootApplication
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; EurekaclientconsumerApplication {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        SpringApplication.run(EurekaclientconsumerApplication.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, args);
    }

    @LoadBalanced
    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; RestTemplate restTemplate(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;  &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RestTemplate();
    }

}


&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;HelloService:远程服务调用类&lt;/span&gt;

&lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.zuowenjun.cloud.service;


&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.netflix.hystrix.contrib.javanica.annotation.HystrixProperty;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Value;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Service;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.client.RestTemplate;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.HashMap;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Map;

@Service
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HelloService {

    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; RestTemplate restTemplate;

    @Value(&lt;/span&gt;&quot;${spring.application.helloServiceProvider}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String  helloServiceName;

    @HystrixCommand(fallbackMethod &lt;/span&gt;= &quot;multiplyFallback&quot;&lt;span&gt;,
            commandProperties &lt;/span&gt;=&lt;span&gt;{
                    @HystrixProperty(name &lt;/span&gt;= &quot;execution.isolation.strategy&quot;, value = &quot;SEMAPHORE&quot;&lt;span&gt;),
                    @HystrixProperty(name &lt;/span&gt;= &quot;execution.isolation.semaphore.maxConcurrentRequests&quot;, value = &quot;3&quot;&lt;span&gt;)
            } )
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object multiply(&lt;span&gt;int&lt;/span&gt; a,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; b){
        String url&lt;/span&gt;=&quot;http://&quot;+ helloServiceName +&quot;/multiply/&quot; + a +&quot;/&quot; +&lt;span&gt; b;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; restTemplate.getForObject(url,String.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        throw new RuntimeException(&quot;consumer exception&quot;);&lt;/span&gt;
&lt;span&gt;    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;  Object multiplyFallback(&lt;span&gt;int&lt;/span&gt; x,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; y,Throwable e){

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;TODO:额外增加的Throwable e，以便可以根据throwable的不同执行不同的逻辑&lt;/span&gt;
        Map&amp;lt;String,Object&amp;gt; result=&lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String, Object&amp;gt;&lt;span&gt;();
        result.put(&lt;/span&gt;&quot;from&quot;,&quot;multiply Fallback method&quot;&lt;span&gt;);
        result.put(&lt;/span&gt;&quot;a&quot;&lt;span&gt;,x);
        result.put(&lt;/span&gt;&quot;b&quot;&lt;span&gt;,y);
        result.put(&lt;/span&gt;&quot;ex&quot;&lt;span&gt;,e.getMessage());

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;  result;

    }


}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上代码，我先屏蔽掉了有关Feign的相关配置及代码（其实可以兼容并存，这里只是为了大家好理解才去掉的），然后启动类添加了@EnableHystrix、远程服务类相关方法添加@HystrixCommand，并设置相关参数，其中fallbackMethod是比较重要的，它指示当出现熔断后降级回调的方法名（注意该方法需与被标注@HystrixCommand接口方法签名相同，但如果需要根据异常情况执行不同的降级处理逻辑则可如demo中multiplyFallback额外添加一个Throwable 参数），commandProperties是比较复杂的，可以包含很多的设置，如代码中设置了资源隔离方式为信号量并指定并发请求数，更多参数配置说明可参见：&lt;a href=&quot;https://blog.csdn.net/tongtong_use/article/details/78611225&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/tongtong_use/article/details/78611225&lt;/a&gt;，资源隔离策略说明参见：&lt;a href=&quot;https://blog.csdn.net/liuchuanhong1/article/details/73718794&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/liuchuanhong1/article/details/73718794&lt;/a&gt;，有信号量、线程池两种隔离方式，默认是线程池隔离，两者的区别如下图示：（图片来源：前面给出的链接文章，这里重点贴出说明）&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/458152/201902/458152-20190223154908959-626786650.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后直接启动运行，如访问：http://localhost:8666/x?a=23&amp;amp;b=56&lt;/p&gt;
&lt;p&gt;当注册中心、服务提供者都正常情况下，能正常返回结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/458152/201902/458152-20190223155453510-1748626547.png&quot; alt=&quot;&quot; width=&quot;529&quot; height=&quot;64&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当注册中心（消费者无法从注册中心获取服务实例信息时）或服务提供者关闭掉，模拟网络不可达，服务不可用的情况，再次请求，返回熔断降级回调方法的结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/458152/201902/458152-20190223155701053-417246882.png&quot; alt=&quot;&quot; width=&quot;360&quot; height=&quot;78&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1.3.&lt;strong&gt;采用Feign + Hystrix方式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　1.3.1首先定义一个实现自被@FeignClient标注的远程调用服务接口类（HelloRemoteService）的Hystrix降级回调实现类：HelloRemoteServiceFallbackImpl，实现接口里的相关方法，这里的方法是与接口里的同名方法有本质不同，接口里的方法是映射请求远程服务，而降级回调类中的方法是当接口中的同名方法调用失败后触发降级回调这些方法，所以这些是对应接口的降级方法。然后在远程调用服务接口类（HelloRemoteService）的@FeignClient注解中添加相关的参数配置，其中很重要的依然是：fallback，这个是指定Hystrix降级回调实现类（即：HelloRemoteServiceFallbackImpl），最后确保spring boot启动类上添加了@EnableFeignClients（这个是上篇就说过的，要想启用Feign就得添加），具体代码实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;HelloRemoteServiceFallbackImpl 降级回调实现类：&lt;/span&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.zuowenjun.cloud.service;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.PathVariable;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.HashMap;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Map;

@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; HelloRemoteServiceFallbackImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; HelloRemoteService{

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object multiply(@PathVariable(&quot;a&quot;) &lt;span&gt;int&lt;/span&gt; x, @PathVariable(&quot;b&quot;) &lt;span&gt;int&lt;/span&gt;&lt;span&gt; y) {
        Map&lt;/span&gt;&amp;lt;String,Object&amp;gt; result=&lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;&lt;span&gt;();
        result.put(&lt;/span&gt;&quot;from&quot;,&quot;multiply Fallback method&quot;&lt;span&gt;);
        result.put(&lt;/span&gt;&quot;a&quot;&lt;span&gt;,x);
        result.put(&lt;/span&gt;&quot;b&quot;&lt;span&gt;,y);

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;  result;
    }
}


&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;HelloRemoteService远程调用服务类：&lt;/span&gt;

&lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.zuowenjun.cloud.service;


&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cloud.openfeign.FeignClient;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.PathVariable;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RequestMapping;


@FeignClient(name&lt;/span&gt;= &quot;helloservice&quot;,fallback =HelloRemoteServiceFallbackImpl.&lt;span&gt;class&lt;/span&gt;&lt;span&gt; )
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; HelloRemoteService {

    @RequestMapping(&lt;/span&gt;&quot;/multiply/{a}/{b}&quot;&lt;span&gt;)
    Object  multiply(@PathVariable(&lt;/span&gt;&quot;a&quot;) &lt;span&gt;int&lt;/span&gt; x, @PathVariable(&quot;b&quot;) &lt;span&gt;int&lt;/span&gt;&lt;span&gt; y);

}


&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;spring boot启动类：&lt;/span&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.zuowenjun.cloud;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.SpringApplication;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.autoconfigure.SpringBootApplication;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cloud.client.discovery.EnableDiscoveryClient;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cloud.client.loadbalancer.LoadBalanced;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cloud.netflix.hystrix.EnableHystrix;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cloud.openfeign.EnableFeignClients;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Bean;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.client.RestTemplate;


@EnableDiscoveryClient
@SpringBootApplication
@EnableFeignClients(basePackages &lt;/span&gt;= &quot;cn.zuowenjun.cloud.service&quot;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果启动类不在根目录需要指定basePackages，否则不需要&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; EurekaclientconsumerApplication {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        SpringApplication.run(EurekaclientconsumerApplication.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, args);
    }


}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;1.3.2.Feign虽然集成了Hystrix，但默认并未开启，需要在配置文件中显示配置开启，application.yml配置如下：（当然我这里依然如1.2一样改变了默认的资源隔离方为信号量）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;server:
  port: 8666

spring:
  application:
    name: ribbonclient
    helloServiceProvider: helloservice #自定义配置，指定访问远程服务名称，当然也可以写死在代码中

eureka:
  client:
    serviceUrl:
      defaultZone: http://localhost:8800/eureka/ #指向eureka server


feign:
  hystrix:
    enabled: true #启用hystrix
    command:
      default:
        execution:
          isolation:
            strategy: #默认是THREAD,这里演示改成了信号量隔离模式
              semaphore:
                maxConcurrentRequests: 3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过如上两步即完成了&lt;strong&gt;Feign集成Hystrix，&lt;/strong&gt;启动项目，如在注册中心、服务提供者都正常的情况下访问：http://localhost:8666/multiply/66/88，就能得到正常结果，否则当注册中心（消费者无法从注册中心获取服务实例信息时）、服务提供者任意节点出问题，则会执行降级回调方法，如下图示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/458152/201902/458152-20190223162946718-319936953.png&quot; alt=&quot;&quot;/&gt; 、&lt;img src=&quot;https://img2018.cnblogs.com/blog/458152/201902/458152-20190223163033823-1029819244.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;虽然当服务提供者不可用时，通过fallback能够直接熔断降级回调相关的方法，但有时如果我们需要根据不同的异常执行不同的降级处理逻辑呢，该如何办？这个时候可以使用fallbackFactory来实现自定义的降级回调实例创建过程，从而可以在create降级回调实现类时增加额外逻辑。实现步骤是：先创建实现自FallbackFactory的自定义降级回调工厂类：HystrixClientFallbackFactory,然后@FeignClient注解的fallbackFactory参数指向HystrixClientFallbackFactory.class即可，具体实现代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.zuowenjun.cloud.service;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; feign.hystrix.FallbackFactory;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.HashMap;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Map;

@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; HystrixClientFallbackFactory &lt;span&gt;implements&lt;/span&gt; FallbackFactory&amp;lt;HelloRemoteService&amp;gt;&lt;span&gt; {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; HelloRemoteService create(Throwable throwable) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;TODO:这里可以根据throwable的不同生成不同的HelloRemoteService的Fallback的实例&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;  &lt;span&gt;new&lt;/span&gt; HelloRemoteService() {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里是匿名实现接口，也可以用lambda表达式或具体的接口实现类，如：HelloRemoteServiceFallbackImpl&lt;/span&gt;
&lt;span&gt;
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object multiply(&lt;span&gt;int&lt;/span&gt; x, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; y) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;TODO:这里可以根据throwable的不同执行不同的逻辑&lt;/span&gt;
                Map&amp;lt;String,Object&amp;gt; result=&lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;&lt;span&gt;();
                result.put(&lt;/span&gt;&quot;from&quot;,&quot;multiply FallbackFactory method&quot;&lt;span&gt;);
                result.put(&lt;/span&gt;&quot;a&quot;&lt;span&gt;,x);
                result.put(&lt;/span&gt;&quot;b&quot;&lt;span&gt;,y);
                result.put(&lt;/span&gt;&quot;ex&quot;&lt;span&gt;,throwable.getMessage());
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;  result;
            }
        };
    }
}



&lt;/span&gt;&lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.zuowenjun.cloud.service;


&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cloud.openfeign.FeignClient;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.PathVariable;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RequestMapping;



&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;@FeignClient(name= &quot;helloservice&quot;,fallback =HelloRemoteServiceFallbackImpl.class )&lt;/span&gt;
@FeignClient(name= &quot;helloservice&quot;,fallbackFactory = HystrixClientFallbackFactory.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; HelloRemoteService {

    @RequestMapping(&lt;/span&gt;&quot;/multiply/{a}/{b}&quot;&lt;span&gt;)
    Object  multiply(@PathVariable(&lt;/span&gt;&quot;a&quot;) &lt;span&gt;int&lt;/span&gt; x, @PathVariable(&quot;b&quot;) &lt;span&gt;int&lt;/span&gt;&lt;span&gt; y);

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后重新启动项目，并仍然访问：http://localhost:8666/multiply/66/88，正常情况都是OK的，当服务提供者不可用时，则会通过HystrixClientFallbackFactory工厂类创建降级回调实现类，并执行对应的降级方法，这里可以看到Throwable是create方法的入参，我们可以根据入参创建不同的降级回调实现类或实现不同的处理逻辑，这里DEMO演示的降级回调结果如下图示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/458152/201902/458152-20190223164846566-1896772652.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二、集成Hystrix-dashboard熔断监控面板&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 　　如上第一部份演示效果，通过在服务消费者项目中集成Hystrix可以做到依赖隔离、熔断、降级处理等操作，但如果没有有效的监控途径，那么我们就无法及时发现问题，及早预防，及早处理，只能等到出现大量的服务熔断降级后才知道问题，然后就是漫漫排查路。这样显然是不行的，故有了Hystrix Dashboard组件为我们解决这个监控的问题。集成Hystrix Dashboard很简单，我们在第一节服务消费者项目的基础上按照如下步骤操作，即可实现：&lt;/p&gt;
&lt;p&gt;　　2.1.在POM XML中添加Hystrix Dashboard依赖、actuator依赖，具体如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-actuator&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-cloud-starter-netflix-hystrix-dashboard&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2.2.在spring boot启动类上再添加：@EnableHystrixDashboard注解，然后添加注册HystrixMetricsStreamServlet的方法（servletRegistrationBean）,并指定映射URL为：/actuator/hystrix.stream，如果不指定就会导致报：Unable to connect to Command Metric Stream，因为http://hystrix-app:port/actuator/hystrix.stream无法访问404，代码如下：（注意这里面同时包含了使用：ribbon、FeignClient两种消费方式）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.zuowenjun.cloud;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.netflix.hystrix.contrib.metrics.eventstream.HystrixMetricsStreamServlet;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.SpringApplication;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.autoconfigure.SpringBootApplication;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.web.servlet.ServletRegistrationBean;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cloud.client.discovery.EnableDiscoveryClient;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cloud.client.loadbalancer.LoadBalanced;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cloud.netflix.hystrix.EnableHystrix;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cloud.netflix.hystrix.dashboard.EnableHystrixDashboard;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cloud.openfeign.EnableFeignClients;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Bean;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.client.RestTemplate;

@EnableHystrixDashboard
@EnableHystrix
@EnableDiscoveryClient
@SpringBootApplication
@EnableFeignClients(basePackages &lt;/span&gt;= &quot;cn.zuowenjun.cloud.service&quot;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果启动类不在根目录需要指定basePackages，否则不需要&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; EurekaclientconsumerApplication {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        SpringApplication.run(EurekaclientconsumerApplication.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, args);
    }

    @LoadBalanced
    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; RestTemplate restTemplate(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;  &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RestTemplate();
    }


    @Bean(name &lt;/span&gt;= &quot;hystrixRegistrationBean&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ServletRegistrationBean servletRegistrationBean() {
        ServletRegistrationBean registration &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServletRegistrationBean(
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; HystrixMetricsStreamServlet(), &quot;/actuator/hystrix.stream&quot;&lt;span&gt;);
        registration.setName(&lt;/span&gt;&quot;HystrixMetricsStreamServlet&quot;&lt;span&gt;);
        registration.setLoadOnStartup(&lt;/span&gt;1&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; registration;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;完成上述2步后，重新启动项目，然后访问：http://localhost:8666/hystrix，出现如下画面即为成功：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/458152/201902/458152-20190223190022795-413932035.png&quot; alt=&quot;&quot; width=&quot;802&quot; height=&quot;430&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们按照提示（查看单个服务项目），输入：http://localhost:8666/actuator/hystrix.stream，然后点击Monitor Stream按钮，即可进入监控查看界面，刚进行可能没有数据只是loading...，当通过ribbon、FeignClient两种方式进行服务消费后（即：请求远程服务API），则监控面板的数据会实时更新，效果如下图示：(至于具体参数各代表什么意思请上网查看相关资料，有很多介绍的)&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/458152/201902/458152-20190223190933365-168595622.png&quot; alt=&quot;&quot; width=&quot;481&quot; height=&quot;263&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.3.除了在服务消费者项目中集成Hystrix Dashboard外，如果我们需要专门搞一个项目来查看各个服务消者，是否可以单独搭建呢？答案是肯定的，我们可以搭建一个专门用于查询每个项目监控数据的项目（直接使用spring initializer，然后只添加eureka client、Hystrix Dashboard即可），然后仍然按照搭建服务消费者的方式添加相关依赖，但不需要编写服务消费代码（比如：上文中的HelloService,HelloRemoteService），因为我们只需要保证能够与注册中心、服务提供者通讯并开启Hystrix Dashboard即可。我这里就做了一个演示DEMO，完整依赖如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('84f88016-0967-4bdd-a486-bfbd65b59829')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_84f88016-0967-4bdd-a486-bfbd65b59829&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_84f88016-0967-4bdd-a486-bfbd65b59829&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('84f88016-0967-4bdd-a486-bfbd65b59829',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_84f88016-0967-4bdd-a486-bfbd65b59829&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;project &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://maven.apache.org/POM/4.0.0&quot;&lt;/span&gt;&lt;span&gt; xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt;
         xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;modelVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;4.0.0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;modelVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;parent&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-parent&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2.1.3.RELEASE&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;relativePath&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt; &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; lookup parent from repository &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;parent&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;cn.zuowenjun.cloud&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;hystrixdashboard&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;0.0.1-SNAPSHOT&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;hystrixdashboard&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;http://www.zuowenjun.cn&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;description&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Demo project for Spring Boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;description&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;java.version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.8&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;java.version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;spring-cloud.version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Greenwich.RELEASE&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;spring-cloud.version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-actuator&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-cloud-starter-netflix-eureka-client&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-cloud-starter-netflix-hystrix-dashboard&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-test&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;test&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependencyManagement&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-cloud-dependencies&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;${spring-cloud.version}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;pom&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;import&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependencyManagement&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;build&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;plugins&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;plugin&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-maven-plugin&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;plugin&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;plugins&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;build&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;repositories&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;repository&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-milestones&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Spring Milestones&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;https://repo.spring.io/milestone&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;repository&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;repositories&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;project&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;然后在spring boot启动类添加如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('a55ff2be-f05a-492a-9df6-ff57ccbf38d0')&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_a55ff2be-f05a-492a-9df6-ff57ccbf38d0&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_a55ff2be-f05a-492a-9df6-ff57ccbf38d0&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('a55ff2be-f05a-492a-9df6-ff57ccbf38d0',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_a55ff2be-f05a-492a-9df6-ff57ccbf38d0&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.zuowenjun.cloud.dashboard;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.netflix.hystrix.contrib.metrics.eventstream.HystrixMetricsStreamServlet;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.SpringApplication;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.autoconfigure.SpringBootApplication;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.web.servlet.ServletRegistrationBean;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cloud.client.discovery.EnableDiscoveryClient;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cloud.netflix.hystrix.dashboard.EnableHystrixDashboard;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Bean;


@EnableHystrixDashboard
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;@EnableDiscoveryClient&lt;/span&gt;
&lt;span&gt;@SpringBootApplication
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HystrixdashboardApplication {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        SpringApplication.run(HystrixdashboardApplication.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, args);
    }


    @Bean(name &lt;/span&gt;= &quot;hystrixRegistrationBean&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ServletRegistrationBean servletRegistrationBean() {
        ServletRegistrationBean registration &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServletRegistrationBean(
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; HystrixMetricsStreamServlet(), &quot;/actuator/hystrix.stream&quot;&lt;span&gt;);
        registration.setName(&lt;/span&gt;&quot;hystrixServlet&quot;&lt;span&gt;);
        registration.setLoadOnStartup(&lt;/span&gt;1&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; registration;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;最后在application.yml添加如下配置即可：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('fdee9a7a-b307-417e-ba17-82e7bc8b4104')&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_fdee9a7a-b307-417e-ba17-82e7bc8b4104&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_fdee9a7a-b307-417e-ba17-82e7bc8b4104&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('fdee9a7a-b307-417e-ba17-82e7bc8b4104',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_fdee9a7a-b307-417e-ba17-82e7bc8b4104&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;server:
  port: 8999

spring:
  application:
    name: hystrixdashboard

eureka:
  client:
    serviceUrl:
      defaultZone: http://localhost:8800/eureka/ #指向eureka server


feign:
  hystrix:
    enabled: true #启用hystrix&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;访问：http://localhost:8999/hystrix，熟悉的界面又出来了，这时就可以输入其它某个服务消费者的项目：http://localhost:8666/actuator/hystrix.stream，点击Monitor Stream按钮即可正常查看监控。这里就不在贴图了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;三、通过引入Turbine聚合熔断监控数据以便统一集中查看&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 在这里我基于上面2.3单独搭建的监控面板项目（hystrixdashboard） 基础上按如下简单的几个步骤，即完成聚合熔断监控数据了。&lt;/p&gt;
&lt;p&gt; 3.1.在POM XML添加如下turbine依赖：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-cloud-starter-netflix-turbine&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.2 在spring boot启动类上标注@EnableTurbine，并再添加注册HystrixMetricsStreamServlet的方法（如：servletTurbineRegistrationBean），这里映射URL为：/turbine.stream&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.zuowenjun.cloud.dashboard;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.netflix.hystrix.contrib.metrics.eventstream.HystrixMetricsStreamServlet;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.SpringApplication;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.autoconfigure.SpringBootApplication;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.web.servlet.ServletRegistrationBean;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cloud.client.discovery.EnableDiscoveryClient;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cloud.netflix.hystrix.dashboard.EnableHystrixDashboard;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cloud.netflix.turbine.EnableTurbine;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Bean;


@EnableHystrixDashboard
&lt;/span&gt;&lt;span&gt;@EnableDiscoveryClient&lt;/span&gt;
&lt;span&gt;@EnableTurbine
@SpringBootApplication
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HystrixdashboardApplication {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        SpringApplication.run(HystrixdashboardApplication.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, args);
    }


    @Bean(name &lt;/span&gt;= &quot;hystrixRegistrationBean&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ServletRegistrationBean servletRegistrationBean() {
        ServletRegistrationBean registration &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServletRegistrationBean(
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; HystrixMetricsStreamServlet(), &quot;/actuator/hystrix.stream&quot;&lt;span&gt;);
        registration.setName(&lt;/span&gt;&quot;hystrixServlet&quot;&lt;span&gt;);
        registration.setLoadOnStartup(&lt;/span&gt;1&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; registration;
    }

    @Bean(name &lt;/span&gt;= &quot;hystrixForTurbineRegistrationBean&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ServletRegistrationBean servletTurbineRegistrationBean() {
        ServletRegistrationBean registration &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServletRegistrationBean(
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; HystrixMetricsStreamServlet(), &quot;/turbine.stream&quot;&lt;span&gt;);
        registration.setName(&lt;/span&gt;&quot;hystrixForTurbineServlet&quot;&lt;span&gt;);
        registration.setLoadOnStartup(&lt;/span&gt;1&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; registration;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.3.在application.yml配置中增加turbine相关的参数设置，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;server:
  port: 8999

spring:
  application:
    name: hystrixdashboard

eureka:
  client:
    serviceUrl:
      defaultZone: http://localhost:8800/eureka/ #指向eureka server


turbine:
  app-config: helloservice #指定需要监控的servicename，多个service以,间隔
  cluster-name-expression: new String(&quot;default&quot;) #指定集群名称，默认为default，当设立了多个集群时，可以在Hystrix指定集群名称来查看监控
  combine-host-port: true #合并同一个host多个端口的数据&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 完成上面3个步骤后即OK，启动项目，然后访问：http://localhost:8999/hystrix，如果配置OK就又出现监控主界面，然后这里根据提示输入集群的监控查询URL，如：http://localhost:8999/turbine.stream，然后点击Monitor Stream按钮即可正常查看集群中各服务的监控实时数据了。这里就不在贴图了。&lt;/p&gt;
&lt;p&gt;好了本文就总结到这里，若有不足之处欢迎指出，谢谢！&lt;/p&gt;
</description>
<pubDate>Sat, 23 Feb 2019 15:05:00 +0000</pubDate>
<dc:creator>梦在旅途</dc:creator>
<og:description>为了防止服务消费链（多级服务之间的调用）上因某个服务出现故障，而导致级联故障，进而造成整个系统不可用（简称为：雪崩效应），推出了熔断、降级的处理方式：Hystrix断路器（类似生活中电路保险丝）来解决</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zuowj/p/10418932.html</dc:identifier>
</item>
<item>
<title>Java——异常 - SakuraOne</title>
<link>http://www.cnblogs.com/myworld7/p/10424737.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/myworld7/p/10424737.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;Java中使用异常机制去处理程序错误，减少了错误处理代码的复杂度。不必在程序每个可能出现错误的地方都进行检查并添加错误处理代码，从而显得程序主要结构混乱。异常机制会捕获错误，并且在&lt;code&gt;异常处理程序&lt;/code&gt;中处理错误，使得程序代码和错误处理代码分离，使得代码结构更清晰明了。下面将介绍Java中的异常分类、如何创建异常处理程序以及自定义异常等。&lt;/p&gt;
&lt;h2 id=&quot;异常分类&quot;&gt;异常分类&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1099419/201902/1099419-20190223224359493-257629791.png&quot; width=&quot;480&quot; height=&quot;600&quot;/&gt;&lt;br/&gt;Java中的所有异常都继承自Throwable。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Throwable&lt;/code&gt;：被用来表示任何可以作为异常被抛出的类。有两个重要的子类Exception和Eerror。二者都是Java异常处理的重要子类，并且二者也包含许多重要的子类。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Error&lt;/code&gt;：&lt;strong&gt;该类层次结构描述了Java运行时系统内部错误和资源耗尽错误&lt;/strong&gt;，总之是&lt;strong&gt;与Java虚拟机有关的运行错误&lt;/strong&gt;。也是&lt;strong&gt;应用程序无法处理的&lt;/strong&gt;。这些错误是不可查的，因为它们在应用程序的控制和处理能力之 外，而且绝大多数是程序运行时不允许出现的状况。对于设计合理的应用程序来说，&lt;strong&gt;即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状况&lt;/strong&gt;。在 Java中，错误通过Error的子类描述。一般不需要你关心。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Exception&lt;/code&gt;： 是程序本身可以处理的异常，是需要程序员关心的异常类。&lt;/p&gt;
&lt;p&gt;Java中的异常又可分为&lt;code&gt;可检查异常&lt;/code&gt;（checked exceptions）和&lt;code&gt;不可检查异常&lt;/code&gt;（unchecked exceptions）。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;可检查异常：&lt;strong&gt;编译器要求必须处理的异常&lt;/strong&gt;。在Exception类及其子类中，除了RuntimeException类及其子类外，其余都是可检查异常。这种异常编译器会强制要求处理它，需要使用try-catch语句去捕获处理或者使用trhrow子句抛出该异常让其他地方去处理它，否则编译器会不允许编译通过。&lt;/li&gt;
&lt;li&gt;不可检查异常：&lt;strong&gt;编译器不强制要求处理的异常&lt;/strong&gt;。该异常分来包括：运行时异常（RuntimeException）及其子类和错误（Error）及其子类。这种异常即使不使用try-catch子句捕获和throw子句抛出，编译器也会使得编译通过。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Exception异常只有RuntimeException及其子类是不可查的异常，其余异常都是可查异常。于是，Excepption异常分类就可以分为&lt;strong&gt;运行时异常&lt;/strong&gt;和&lt;strong&gt;非运行时异常（编译时异常）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;运行时异常如NullPointerException(空指针异常)、ArrayIndexOutOfBoundException(数组下标越界异常)编译器不强制要求处理 。这些异常一般是由于程序逻辑错误引起，程序应该从逻辑角度避免这种异常的发生。非运行时异常则需要强制要求处理，否则编译不予通过。&lt;/p&gt;
&lt;p&gt;下面再附上一张比较完整的Java异常类图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1099419/201902/1099419-20190223224630614-346698576.png&quot; width=&quot;800&quot; height=&quot;650&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;异常处理&quot;&gt;异常处理&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Java程序中的异常处理机制为：抛出异常，捕获异常&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;抛出异常&quot;&gt;抛出异常&lt;/h3&gt;
&lt;p&gt;异常情形（exceptionanl condiition）是指阻止当前方法或作用域继续执行的问题。需要与普通问题区分开：普通问题指的是在当前环境下能够得到足够的信息，总能够处理这个问题；异常情形就是，程序不能执行下去了，在当前环境下无法获必要的信息来解决问题。&lt;strong&gt;需要做的就是从当前环境中跳出，并把问题交给上一级环境让它去处理&lt;/strong&gt;。这就是抛出异常所发生的事情。&lt;/p&gt;
&lt;p&gt;例如：除法问题。若是事先没有对除数为0进行判断，那么遇见除数为0时，就是一个异常情况。当然的环境不知道如何处理这个情况，于是就将异常抛出。&lt;/p&gt;
&lt;p&gt;Java中抛出异常的实现方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用new在堆上创建异常对象。&lt;/li&gt;
&lt;li&gt;当前的执行路径被终止，并从当期环境中使用&lt;code&gt;throw&lt;/code&gt;关键字弹出异常对象的引用&lt;/li&gt;
&lt;li&gt;异常处理机制接管程序，并开始寻找一个恰当的地方来继续执行程序。恰当的地方就是指&lt;strong&gt;异常处理程序&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;异常处理程序将程序从错误状态中恢复，以使程序能要么换一种方式运行，那么继续原来的程序执行。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;举一个例子：一个引用t为null时，创建一个异常从当前环境中抛出，把错误传播到更大的环境中去处理。这个例子只为举例说明，实际不这样用。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;if(t == null){
    throw new NullPointerException();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;异常允许我们强制程序停止运行，并告诉我们出现了什么问题，或者（理想状况下）强制程序处理问题，并返回到稳定状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;异常参数&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;与使用Java中其他对象一样，我们使用new在对上创建异常对象，这也伴随着存储空间的分配和构造器的调用。所有标准异常都有两个构造器：一个默认构造器和一个以字符串作为参数的构造器。带参构造器可以将一些信息放入构造器中。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;throw new NullPionterException(&quot; t = null&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将这个字符串信息提取出来的方式有许多种，稍后介绍。&lt;/p&gt;
&lt;p&gt;对于不同类型的错误，要抛出相应的异常。错误信息可以保存在异常对象的内部或者使用异常类的名称来暗示。上一层环境通过这些异常信息来决定如何处理这些异常。通常，异常对象中仅有的信息就是异常类型，除此之外不包含任何有意义的内容。&lt;/p&gt;
&lt;h3 id=&quot;捕获异常try-catch&quot;&gt;捕获异常try-catch&lt;/h3&gt;
&lt;p&gt;要理解异常是如何被捕获的，需要先理解&lt;code&gt;监控区域(guarded region)&lt;/code&gt;的概念。它是一段可能产生异常的代码，并且后面跟着处理这些异常的代码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;try块&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果在方法内部抛出了异常（或者该方法内部调用的其他方法抛出了异常），那么这个方法将在抛出异常的过程中结束，方法中后续代码将不能运行。如果不希望刚发就此结束，可以在方法内部设置一个特殊的块来捕获异常。因为在这个快里“尝试”各种（可能产生异常的）方法调用，所以称为try块。它是跟在try关键字后的普通代码块：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;try{
    //可能会抛出异常的代码
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于不支持异常处理的程序语言，想要仔细检查错误，就需要在每个方法调用的前后设置错误检查代码。但是有了异常处理机制，就可以&lt;strong&gt;把所有动作都可以放在tty块中，然后只需要在一个地方就捕获所有异常&lt;/strong&gt;。这也是前面说的，异常处理机制将完成任务的代码和错误检查的代码分离，使得程序结构清晰易于阅读。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;异常处理程序&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;抛出的异常必须在某个地方得到处理，这个地方就是我们前面说的异常处理程序。针对每个要捕获的异常，需要准备相应的处理程序。异常程序紧跟在try块之后，以关键字&lt;code&gt;catch&lt;/code&gt;表示。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;try{
    //可能会抛出异常的代码
}catch(ExceptionType1 id1){
    //处理类型为ExceptionType1异常的代码
}catch(ExceptionType2 id2){
    //处理类型为ExceptionType2异常的代码
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;catch子句就是异常处理程序，看起来像是接收指定的异常类型参数的方法。异常处理程序必须紧跟在try块之后。&lt;strong&gt;当异常被抛出时，异常处理机制将负责搜寻参数与抛出异常类相匹配的第一个处理程序&lt;/strong&gt;。然后进入catch子句执行，此时就认为异常得到了处理。一旦catch子句结束，则处理程序的查找过程结束。&lt;/p&gt;
&lt;p&gt;在try块内部，许多不同的方法调用可能会产生相同类型的异常，而你只需要提供一个针对此类型的异常处理程序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;异常处理的两种模型：终止模型和恢复模型&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;异常处理周期理论上有两种模型：终止模型和恢复模型。Java支持&lt;strong&gt;终止模型&lt;/strong&gt;（Java、C++等大多数语言支持的模型）。在这种模型中，将假设错误非常关键，以至于程序无法返回到异常经常发生的地方继续执行。一旦异常被抛出，就表明错误已经无法挽回，也不可以继续回来执行。&lt;strong&gt;恢复模型&lt;/strong&gt;则指异常处理程序的工作是修正错误，然后重新尝试调用出问题的方法，并认为第二次可以成功。对于恢复模型，通常希望异常被处理之后能继续执行程序。&lt;/p&gt;
&lt;p&gt;虽然恢复模型很吸引人，但是不是很实用。其中主要的原因可能是它所导致的耦合：恢复性的处理程序需要了解异常抛出的地点，这势必要包含依赖于抛出位置的非通用性代码。这增加了代码编写和维护的困难。&lt;/p&gt;
&lt;p&gt;如果想要使Java实现类似恢复的行为，那么在遇见错误的时候就不能抛出异常，而是调用方法来修正该错误。或者，把try-catch块放在while循环里，这样就可以不断地进入try块，直到得到满意的结果然后退出。例如：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;boolean exit = false;
while(!exit){
    try{
        //编写可能会出异常的代码或者调用可能会出异常的方法
        f();
        //...  
        boolean = true;
    }catch(ExceptionType e){//捕获相应类型异常进行处理
        //异常处理
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;创建自定义异常&quot;&gt;创建自定义异常&lt;/h2&gt;
&lt;p&gt;Java提供提供的异常体系可能不会完全包含我们遇见的错误，所以允许我们可以自定义异常。自己要自定义异常必须已知的异常继承，最好是选择意思相近的异常类继承。建立新的异常最简单的方法就是让编译器为你产生默认的构造器，可以较少写的代码量。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//自定义异常继承自Exception
class SimpleException extends Exception{}

public class InheritingException {
    //thorws关键字说明该方法会产生SimpleException异常
    public void f() throws SimpleException{
        System.out.println(&quot;从f()中抛出SimpleException异常&quot;);
        throw new SimpleException();  //使用thorw关键字抛出SimpleException异常
    }
    
    public static void main(String[] args) {
        InheritingException ie = new InheritingException();
        try {
            //调用可能会抛出异常的方法
            ie.f();
        }catch(SimpleException e) {
            System.out.println(&quot;捕获了SimpleException异常&quot;);
//          System.err.println(&quot;捕获了SimpleException异常&quot;);
        }
    }
}
/*
output:
从f()中抛出SimpleException异常
捕获了SimpleException异常
*/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;编译器创建了默认构造器，它将自动调用基类的默认构造器。可以将错误信息发送到标准错误流，这样更能引起用户注意。&lt;/p&gt;
&lt;p&gt;也可以为异常类定义一个接受字符串参数的构造器：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class MyException extends Exception{
    public MyException() {}
    //增加含参构造器
    public MyException(String msg) {
        super(msg);
    }
}

public class FullConstructors {
    public static void f() throws MyException{
        System.out.println(&quot;从f()中抛出异常&quot;);
        throw new MyException();
    }
    
    public static void g() throws MyException{
        System.out.println(&quot;从g()中抛出异常&quot;);
        throw new MyException(&quot;从g()中产生&quot;);
    }
    
    public static void main(String[] args) {
        try {
            f();
        }catch(MyException e) {
            e.printStackTrace(System.out);
        }
        
        try {
            g();
        }catch(MyException e) {
            e.printStackTrace(System.out);
        }
    }
}
/*
output:
从f()中抛出异常
blogTest.MyException
    at blogTest.FullConstructors.f(FullConstructors.java:17)
    at blogTest.FullConstructors.main(FullConstructors.java:27)
从g()中抛出异常
blogTest.MyException: 从g()中产生
    at blogTest.FullConstructors.g(FullConstructors.java:22)
    at blogTest.FullConstructors.main(FullConstructors.java:33)
*/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;两个构造器定义了创建MyException类对象的创建方式。对于第二个构造器，使用super关键字明确调用了其基类构造器，它接受一个字符串作为参数。&lt;/p&gt;
&lt;p&gt;在异常处理程序中，调用了在Throwable类中声明的printStackTrace()方法，它将打印“从方法调用处直到异常抛出处”的方法调用序列。这里，信息将被发送到System.out中，并自动地被捕获和显示在输出中。若是调用printStackTrace()原始版本&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;e.printStackTrace();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;则信息将被输出到标准错误流。&lt;/p&gt;
&lt;h2 id=&quot;异常说明&quot;&gt;异常说明&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Java提供了相应语法，是你可以告知客户端程序员某个方法可能会抛出什么异常，然后客户端程序员就可以对可能出现的异常进行处理&lt;/strong&gt;。这就是&lt;code&gt;异常说明&lt;/code&gt;，属于方法声明的一部分，紧跟在形式参数列表之后。就如上代码中：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//thorws关键字说明该方法会产生SimpleException异常
    public void f() throws SimpleException{
        System.out.println(&quot;从f()中抛出SimpleException异常&quot;);
        throw new SimpleException();  
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;代码必须和异常说明一致。&lt;/strong&gt; &lt;strong&gt;若是方法中产生了异常（抛出异常）&lt;/strong&gt;，那么编译器就会发现并提醒你：&lt;strong&gt;要么在这个方法中处理这个异常，要么在异常说明里表明此方法会产生该异常。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们需要注意：虽然产生异常如果不处理就必须要进行说明，但是我们却可以&lt;strong&gt;说明异常但实际不抛出&lt;/strong&gt;。编译器相信了这个声明，并强制此方法的用户像真的抛出这种异常那样使用这个方法。这样做的好处在于：为异常先占一个位置，以后就可以抛出这种异常而不用修改已有的代码。&lt;strong&gt;在定义抽象类基类和接口时这种能力特别重要，这样派生类或接口实现就能够抛出这些预先声明的异常&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;exception异常及一些异常类的方法&quot;&gt;Exception异常及一些异常类的方法&lt;/h2&gt;
&lt;h3 id=&quot;捕获所有异常&quot;&gt;捕获所有异常&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;若要只写一个异常捕获所有类型的异常，那就通过捕获异常类型的基类Exception实现&lt;/strong&gt;。（实际上有其他基类，但是Exception是同编程活动相关的基类。）&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;catch(Exception e){
    // 异常处理代码
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面这段代码将捕获所有异常，做好将其放到处理程序列表末尾，以防止它抢在其他处理程序之间先将异常捕获。因为基类异常可以捕获子类异常。&lt;/p&gt;
&lt;p&gt;从API文档可以看出异常基类Exception没有含有太多的具体信息，从文档也可以它的基类Throwable含了不少方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1099419/201902/1099419-20190223224838397-1971678222.png&quot; width=&quot;600&quot; height=&quot;200&quot;/&gt;&lt;br/&gt;&lt;/p&gt;
&lt;center&gt;Exception类自身没有含有任何方法&lt;/center&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1099419/201902/1099419-20190223224948479-1604819274.png&quot; width=&quot;600&quot; height=&quot;550&quot;/&gt;&lt;br/&gt;&lt;/p&gt;
&lt;center&gt;Throwable类所含方法&lt;/center&gt;
&lt;p&gt;所以我们可以利用从Throwable基类继承来到方法：&lt;strong&gt;&lt;span&gt;String getMessage()、String getLocalizedMessage()&lt;/span&gt;&lt;/strong&gt;来获取详细信息或用本地语言表示的详细信息。&lt;br/&gt;&lt;strong&gt;&lt;span&gt;String toString()&lt;/span&gt;&lt;/strong&gt;返回对Throwable的简单描述。&lt;br/&gt;&lt;strong&gt;&lt;span&gt;void printStackTrace()、void printStackTrace(PrintStream s)、 void printStackTrace(PrintWriter s)&lt;/span&gt;&lt;/strong&gt;打印Throwable和Throwable的调用轨迹。调用栈显示了“把你带到异常抛出地点”的方法调用序列。第一个版本输出到标准错误，后两个版本允许选择要输出的流。&lt;br/&gt;&lt;strong&gt;&lt;span&gt;Throwable fillInStackTrace()&lt;/span&gt;&lt;/strong&gt;用于在Throwable对象的内部记录栈帧的当前状态。这在程序重新抛出错误或异常时很有用。&lt;/p&gt;
&lt;h3 id=&quot;栈轨迹&quot;&gt;栈轨迹&lt;/h3&gt;
&lt;p&gt;printStackTrace()方法所提供的信息可以通过&lt;strong&gt;&lt;span&gt;StackTraceElement[] getStackTrace()&lt;/span&gt;&lt;/strong&gt;方法来直接访问。这个方法返回一个由栈轨迹中的元素所构成的数组，其中的每一个元素都表示栈中的一帧。元素0是栈顶元素，并且是调用序列的最后一个方法调用（即这个Throwable被创建和抛出之处）。数组最后一个元素即栈底元素是调用序列中的第一个方法调用。举一小例：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class WhoCalled {
    public static void f() {
        try {
            throw new Exception();
        }catch(Exception e) {
            for(StackTraceElement ste : e.getStackTrace()) {
                System.out.println(ste.getMethodName());    //打印方法名
            }
        }
    }
    public static void g() {f();}
    
    public static void main(String[] args) {
        f();
        System.out.println(&quot;-------------&quot;);
        g();
    }
}
/*
output:
f
main
-------------
f
g
main
*/&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;重新抛出异常&quot;&gt;重新抛出异常&lt;/h3&gt;
&lt;p&gt;重新抛出异常会把异常给上一级环境中的异常处理程序，同一个try块后面的catch子句将被忽略。被抛出的异常的信息要保持，这样上一级的异常处理程序才可以得到该异常的所有信息。&lt;strong&gt;若只是将异常简单重新抛出那么printStackTrace()显示的将仍然是原来异常抛出点的调用栈信息，不是当前抛出点的信息&lt;/strong&gt;。&lt;strong&gt;若是想要更新信息，可以调用fillInStackTrace()方法，这个方法将返回一个Throwable对象，它是通过把当前调用栈信息填入原来那个异常对象而建立的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1099419/201902/1099419-20190223225026425-559158718.png&quot; width=&quot;700&quot; height=&quot;670&quot;/&gt;&lt;br/&gt;从样例输出可以看出单纯抛出异常，调用栈信息确实没有改变。使用fillInStack()方法，异常的发生地就改变了。&lt;/p&gt;
&lt;p&gt;有可能在捕获异常之后抛出另外一种异常，那么有关原来异常发生点的信息就会丢失，剩下的全是与与新抛出点有关的信息。前一个异常对象因为是在堆上面创建的，所以垃圾回收器会自动将它们清理掉，不必担心。&lt;/p&gt;
&lt;h3 id=&quot;异常链&quot;&gt;异常链&lt;/h3&gt;
&lt;p&gt;若是想在捕获一个异常之后抛出新的异常，并且希望把原来的异常信息保存下来，这就是&lt;code&gt;异常链&lt;/code&gt;。如何实现呢？&lt;/p&gt;
&lt;p&gt;Throwable的子类构造器中可以接受一个cause（因由）对象作为参数。这个cause就用来表示原始异常，于是这样就可以把原始异常传递给新的异常，使用新的异常就可以跟踪到原始异常。但是，在Throwable的子类中只有三种基本异常类提供了带cause参数的构造器，它们是Error、Exception以及RuntimeException。若是把其他类型异常链接起来，就应该使用&lt;strong&gt;&lt;span&gt;initCasue()&lt;/span&gt;&lt;/strong&gt;方法而不是构造器。&lt;/p&gt;
&lt;h2 id=&quot;使用finally进行清理&quot;&gt;使用finally进行清理&lt;/h2&gt;
&lt;p&gt;对于一些代码，我们希望无论try块当中的异常是否抛出，这些代码都可以得到执行。这通常适用于内存回收之外的情况（内存回收是Java虚拟机完成），比如当异常抛出时关闭打开的文件资源。为了达到这个效果，可以在异常处理程序后面加上finally子句。&lt;/p&gt;
&lt;h3 id=&quot;try-catch-finally&quot;&gt;try-catch-finally&lt;/h3&gt;
&lt;p&gt;所以完整的异常处理程序看起来像是这样：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;try{
    //可能会抛出异常的代码
}catch(ExceptionType1 id1){
    //处理类型为ExceptionType1异常的代码
}catch(ExceptionType2 id2){
    //处理类型为ExceptionType2异常的代码
}finally{
    //无论异常是否发生都可以被执行
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class FianllyTest {
    public static void main(String[] args) {
        try {
            throw new Exception();
        }catch(Exception e) {
            System.out.println(&quot;捕获Exception异常&quot;);
        }finally {
            System.out.println(&quot;当异常发生时，finally子句1&quot;);
        }
        
        try {
            int i = 0;
        }catch(Exception e) {
            System.out.println(&quot;捕获Exception异常&quot;);
        }finally {
            System.out.println(&quot;当异常没有发生时,finally子句2&quot;);
        }
    }
}
/*
output:
捕获Exception异常
当异常发生时，finally子句1
当异常没有发生时,finally子句2
*/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从输出可看出无论异常是否被抛出，finally子句总是能够被执行。&lt;/p&gt;
&lt;h3 id=&quot;finally的用处&quot;&gt;finally的用处&lt;/h3&gt;
&lt;p&gt;对于没有垃圾回收机制和析构函数自动调用机制的程序语言来说，finally非常重要。它能使程序员保证：无论try块里面发生什么，内存总能得到释放。但是Java拥有垃圾回收机制，内存释放不再是问题。那么，Java在什么情况下使用finally呢？&lt;strong&gt;当要把除内存之外的资源恢复到它们的初始状态时，就需要用到finally子句&lt;/strong&gt;。这种需要清理的资源包括：已经打开的文件或者网络连接，在屏幕上显示到图形，甚至是外部世界的某个开关等。&lt;/p&gt;
&lt;h3 id=&quot;在return中使用finally&quot;&gt;在return中使用finally&lt;/h3&gt;
&lt;p&gt;因为finally子句总会被执行，所以在一个方法中可以从多个点返回，并且可以保证重要的清理工作仍旧会执行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1099419/201902/1099419-20190223225123252-910635380.png&quot; width=&quot;600&quot; height=&quot;480&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;注意异常丢失&quot;&gt;注意：异常丢失&lt;/h3&gt;
&lt;p&gt;异常作为程序出错的标志，决不应该被忽略，但是还是不免会被忽视掉。比如使用特殊的方式使用finally子句，就会导致异常丢失：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1099419/201902/1099419-20190223225232399-241142689.png&quot; width=&quot;600&quot; height=&quot;480&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为try块后面可以直接跟finally块。所以可以导致在VeryImportantException异常还没有处理的情况下就抛出另外一个异常，导致这个异常丢失。如果要避免这种情况就需要在每个异常抛出后都需要紧跟异常处理程序。&lt;/p&gt;
&lt;p&gt;还有一种更简单的异常丢失方法是从finally子句中直接返回：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ExceptionSilencer{
    public static void main(String args[]){
        try{
            throw new RuntimeException();
        }finally{
            return;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个程序即使抛出了异常，也不会有任何输出。所以要注意这些特殊的finally的使用方法！&lt;/p&gt;
&lt;h3 id=&quot;finally子句不会被执行的情况&quot;&gt;finally子句不会被执行的情况&lt;/h3&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在finally子句中产生了异常&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在前面的代码中用了System.exit()退出程序&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;程序所在的线程死亡&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关闭CPU&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;介绍了Java中异常类的分类，按异常发生类型分和按可检查和不可检查分。其次介绍了Java中如何抛出一个异常以及如何捕获一个异常，即try-catch语句块的使用。如何自定义一个异常，我们需要注意Java中的异常类已经涵盖了大部分会出现的异常，除非特殊情况，一般不需要去自定义异常。throws异常声明的使用。然后介绍异常类中的常用方法（用蓝色标记的方法），几乎都是继承自Throwable类。最后介绍了finally子句，要注意使用finally，避免出现异常丢失！&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;Java异常继承关系：&lt;a href=&quot;http://www.benchresources.net/exception-hierarchy-in-java/&quot; class=&quot;uri&quot;&gt;http://www.benchresources.net/exception-hierarchy-in-java/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;深入理解java异常处理机制: &lt;a href=&quot;https://blog.csdn.net/hguisu/article/details/6155636&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/hguisu/article/details/6155636&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;《Java编程思想》第四版&lt;/p&gt;
</description>
<pubDate>Sat, 23 Feb 2019 15:01:00 +0000</pubDate>
<dc:creator>SakuraOne</dc:creator>
<og:description>前言 Java中使用异常机制去处理程序错误，减少了错误处理代码的复杂度。不必在程序每个可能出现错误的地方都进行检查并添加错误处理代码，从而显得程序主要结构混乱。异常机制会捕获错误，并且在 中处理错误，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/myworld7/p/10424737.html</dc:identifier>
</item>
<item>
<title>对自动变速器的控制器建模 - MATLAB基于模型的设计</title>
<link>http://www.cnblogs.com/52geek/p/10424708.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/52geek/p/10424708.html</guid>
<description>&lt;p&gt;此示例说明如何使用 Simulink® 对汽车传动系统建模。Stateflow® 通过表示变速器控制逻辑来增强 Simulink 模型。Simulink 为动态系统和过程的建模和仿真提供了强大的环境。但在许多系统中，更改模式或调用新增益规律等监管功能必须响应可能发生的事件以及随时间发展变化的情况。因此，环境需要一种能够管理这些多重模式和不断发展变化的情况的语言。在以下示例中，Stateflow 通过在自动变速中执行挡位选择功能来展示其在这一能力方面的优势。通过在 Simulink 模块图中合并 Stateflow 模块，此功能与传动系统动态自然且直观地结合在一起。&lt;/p&gt;&lt;div readability=&quot;132.68415696031&quot;&gt;
&lt;h3 id=&quot;d120e4560&quot; class=&quot;title&quot;&gt;分析和物理原理&lt;span id=&quot;sldemo_autotrans-1&quot; class=&quot;anchor_target&quot;/&gt;&lt;/h3&gt;
&lt;p&gt;图 1 显示了典型汽车传动系统中的功率流。几个非线性常微分方程对发动机、四速自动变速器和车辆进行建模。此示例中讨论的模型直接将图 1 中的模块实现为模块化 Simulink 子系统。另一方面，变速器控制单元 (TCU) 中的逻辑和决策不适合用广为接受的方程表示。TCU 更适用于 Stateflow 表示。Stateflow 监视与系统中的重要关系相对应的事件，并在事件发生时采取适当的措施。&lt;/p&gt;



&lt;p&gt;&lt;span class=&quot;emphasis bold&quot;&gt;图 1：传动系统的通用模块图&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;节气门开度是发动机的输入之一。发动机与液力变矩器的泵轮相联，并通过液力变矩器与变速器耦合（参见方程 1）。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;emphasis bold&quot;&gt;方程 1&lt;/span&gt;&lt;/p&gt;




&lt;p&gt;液力变矩器的输入-输出特征可以表示为发动机转速和涡轮转速的函数。在此示例中，功率流的方向始终假定为从泵轮到涡轮（参见方程 2）。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;emphasis bold&quot;&gt;方程 2&lt;/span&gt;&lt;/p&gt;




&lt;p&gt;变速器模型通过静态齿轮比实现（假定换挡时间短）（参见方程 3）。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;emphasis bold&quot;&gt;方程 3&lt;/span&gt;&lt;/p&gt;





&lt;p&gt;主减速比、转动惯量和动态变化的负载，共同构建了整车动力学模型。（参见方程 4）&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;emphasis bold&quot;&gt;方程 4&lt;/span&gt;&lt;/p&gt;





&lt;p&gt;负载扭矩包括道路负载和制动扭矩。道路负载是摩擦损失和空气动力损失之和（参见方程 5）。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;emphasis bold&quot;&gt;方程 5&lt;/span&gt;&lt;/p&gt;




&lt;p&gt;模型根据图 2 所示的规律设定变速器的换挡点。对于给定挡位下的给定节气门，升挡时具有唯一的车辆速度。降挡时类似。&lt;/p&gt;



&lt;p&gt;&lt;span class=&quot;emphasis bold&quot;&gt;图 2：换挡规律&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;d120e4704&quot; class=&quot;title&quot;&gt;建模&lt;span id=&quot;sldemo_autotrans-2&quot; class=&quot;anchor_target&quot;/&gt;&lt;/h3&gt;
&lt;p&gt;要&lt;a target=&quot;_blank&quot;&gt;打开&lt;/a&gt;此模型，请在 MATLAB® 终端中键入 &lt;code class=&quot;literal&quot;&gt;sldemo_autotrans&lt;/code&gt;。初始条件在模型工作区中设置。&lt;/p&gt;
&lt;p&gt;该模型的顶层图如图 3 所示。要运行仿真，请按模型窗口中的工具栏上的 Play 按钮。请注意，模型将相关数据以名为 &lt;code class=&quot;literal&quot;&gt;sldemo_autotrans_output&lt;/code&gt; 的数据结构体记录到 MATLAB 工作区中。记录的信号具有蓝色指示标记（参见图 3）。在运行仿真后，您可以通过在 MATLAB 命令行窗口中输入 &lt;code class=&quot;literal&quot;&gt;sldemo_autotrans_output&lt;/code&gt; 来查看数据结构体的组成。另请注意，单位显示在子系统图标和信号线上。要了解有关 Simulink 中的单位的详细信息，请参阅 &lt;a target=&quot;_blank&quot;&gt;Simulink 单位&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;emphasis bold&quot;&gt;图 3：模型图和采样仿真结果（超车动作）&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;d120e4735&quot; class=&quot;title&quot;&gt;建模&lt;span id=&quot;sldemo_autotrans-4&quot; class=&quot;anchor_target&quot;/&gt;&lt;/h3&gt;
&lt;p&gt;图 3 所示的 Simulink 模型由代表发动机、变速器和车辆的模块组成，并且额外有一个换挡逻辑模块，用于控制变速器的传动比。模型的用户输入由节气门（以百分比给出）和制动扭矩（以 ft-lb 为单位给出）组成，通过 ManeuversGUI 界面可以输入节气门和制动扭矩。&lt;/p&gt;
&lt;p&gt;Engine 子系统包含一个二维表，该二维表对发动机扭矩与节气门和发动机转速的关系进行插值。图 4 显示了复合的 Engine 子系统。在模型中双击此子系统可查看其结构。&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;emphasis bold&quot;&gt;图 4：Engine 子系统&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;TorqueConverter 和 TransmissionRatio 模块构成了 Transmission 子系统，如图 5 所示。在模型窗口中双击 Transmission 子系统可查看其组件。&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;emphasis bold&quot;&gt;图 5：Transmission 子系统&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;TorqueConverter 是一个封装子系统，它实现了方程 2。要打开此子系统，请右键点击它，然后从下拉菜单中选择 Mask &amp;gt; Look Under Mask。封装需要速度比 (&lt;code class=&quot;literal&quot;&gt;Nin/Ne&lt;/code&gt;) 向量以及 K 系数 (&lt;code class=&quot;literal&quot;&gt;f2&lt;/code&gt;) 和扭矩比 (&lt;code class=&quot;literal&quot;&gt;f3&lt;/code&gt;) 的向量。图 6 显示了 TorqueConverter 子系统的实现。&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;emphasis bold&quot;&gt;图 6：液力变矩器子系统&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;变速器速比模块根据表 1 确定传动比，并根据方程 3 计算出变速器的输出扭矩和输入转速，如图 7 所示的子系统模型在扭矩和转速方面体现了传动比。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;emphasis bold&quot;&gt;表 1：变速器齿轮比&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;code_responsive&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;programlisting&quot;&gt;
gear     Rtr = Nin/Ne
 1         2.393
 2         1.450
 3         1.000
 4         0.677
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span class=&quot;emphasis bold&quot;&gt;图 7：变速器齿轮比子系统&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;标记为 ShiftLogic 的 Stateflow 模块实现变速器的挡位选择。在模型窗口中双击 ShiftLogic 可打开 Stateflow 图。利用 Model Explorer 将输入定义为节气门和车辆速度，将输出定义为所需的挡位数。两个用虚线围起来的 AND 状态跟踪挡位状态和挡位选择过程的状态。整体图作为一个离散时间系统执行，每 40 毫秒采样一次。图 8 所示的 Stateflow 图展示了模块的功能。&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;emphasis bold&quot;&gt;图 8：变速器换挡逻辑的 Stateflow 图&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;可以在仿真期间通过启用 Stateflow 调试器中的动画来观察换挡逻辑行为。&lt;code class=&quot;literal&quot;&gt;selection_state&lt;/code&gt;（始终处于活动状态）通过执行其 &lt;code class=&quot;literal&quot;&gt;during&lt;/code&gt; 函数所示的计算来开始。该模型根据挡位和节气门的瞬时值计算升挡和降挡速度阈值。在处于 steady_state 时，模型将这些值与当前车辆速度进行比较以确定是否需要换挡。如果需要，它将进入确认状态之一（&lt;code class=&quot;literal&quot;&gt;upshifting&lt;/code&gt; 或 &lt;code class=&quot;literal&quot;&gt;downshifting&lt;/code&gt;），该状态会记录进入该状态的时间。&lt;/p&gt;
&lt;p&gt;如果车辆速度不再满足换挡条件，当处于确认状态时，模型将忽略换挡并转移回 &lt;code class=&quot;literal&quot;&gt;steady_state&lt;/code&gt;。这样可以防止外部噪声情况导致的换挡。如果换挡条件在 &lt;code class=&quot;literal&quot;&gt;TWAIT&lt;/code&gt; 个时刻的持续时间内保持有效，模型将通过下联接点转移，并且根据当前挡位，将广播换挡事件。随后，模型在通过一个中央联接点转移后再次激活 &lt;code class=&quot;literal&quot;&gt;steady_state&lt;/code&gt;。广播到 &lt;code class=&quot;literal&quot;&gt;gear_selection&lt;/code&gt; 状态的换挡事件将激活到适当新挡位的转移。&lt;/p&gt;
&lt;p&gt;例如，如果车辆以 25% 的节气门开度在第二挡行进，状态 &lt;code class=&quot;literal&quot;&gt;second&lt;/code&gt; 在 &lt;code class=&quot;literal&quot;&gt;gear_state&lt;/code&gt; 内处于活动状态，&lt;code class=&quot;literal&quot;&gt;steady_state&lt;/code&gt; 在 &lt;code class=&quot;literal&quot;&gt;selection_state&lt;/code&gt; 中处于活动状态。后者的 &lt;code class=&quot;literal&quot;&gt;during&lt;/code&gt; 函数会发现应在车辆超过 30 mph 时升挡。在满足此条件的时刻，模型进入 &lt;code class=&quot;literal&quot;&gt;upshifting&lt;/code&gt; 状态。在此状态下，如果车辆速度在 &lt;code class=&quot;literal&quot;&gt;TWAIT&lt;/code&gt; 个时刻内保持 30 mph 以上，模型将满足引至右下联接点的转移条件。这也满足在从这里转移至 &lt;code class=&quot;literal&quot;&gt;steady_state&lt;/code&gt; 时的条件 [|gear == 2|]，因此模型此时会从 &lt;code class=&quot;literal&quot;&gt;upshifting&lt;/code&gt; 整体转移至 &lt;code class=&quot;literal&quot;&gt;steady_state&lt;/code&gt;，并将事件 &lt;code class=&quot;literal&quot;&gt;UP&lt;/code&gt; 广播为转移操作。最终，在 &lt;code class=&quot;literal&quot;&gt;gear_state&lt;/code&gt; 中从二挡转移到三挡，从而完成换挡逻辑。&lt;/p&gt;
&lt;p&gt;Vehicle 子系统（图 9）使用净扭矩来计算加速度，并对其积分以计算车辆速度（根据方程 4 和方程 5）。Vehicle 子系统为封装子系统。要查看 Vehicle 模块的结构，请右键点击它，然后从下拉菜单中选择 Mask &amp;gt; Look Under Mask。在封装菜单中输入的参数，包括主减速比、摩擦阻力系数和空气动力阻力系数、车轮半径、整车惯量以及初始变速器输出转速。&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;emphasis bold&quot;&gt;图 9：Vehicle 子系统（封装）&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;d120e4886&quot; class=&quot;title&quot;&gt;结果&lt;span id=&quot;sldemo_autotrans-12&quot; class=&quot;anchor_target&quot;/&gt;&lt;/h3&gt;
&lt;p&gt;仿真中使用的发动机扭矩图和液力变矩器特性如图 10 和图 11 所示。&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;emphasis bold&quot;&gt;图 10：发动机扭矩图&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;emphasis bold&quot;&gt;图 11：液力变矩器特性（参见图 5 和方程 2）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;第一个仿真（超车动作）使用表 2 中给出的节气门规律（此数据经过线性插值）。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;emphasis bold&quot;&gt;表 2：第一个仿真（超车动作）的节气门规律&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;code_responsive&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;programlisting&quot;&gt;
Time (sec)    Throttle (%)
  0             60
 14.9           40
 15            100
100              0
200              0
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一列对应的是时间；第二列对应的是节气门开度（百分比）。在这种情况下，未施加制动（制动扭矩为零）。车辆速度从零开始，发动机转速从 1000 RPM 开始。图 12 显示了使用默认参数的基准结果图。如果驾驶员在 &lt;code class=&quot;literal&quot;&gt;t=0&lt;/code&gt; 时节气门开度给到 60%，发动机会立即以超过其双倍转速的方式予以响应。这会在液力变矩器上产生低转速比，从而得到大扭矩比（参见图 6 和图 11）。车辆快速加速（没有对轮胎滑移进行建模），并且发动机和车辆会一直提速直至大约 &lt;code class=&quot;literal&quot;&gt;t = 2 sec&lt;/code&gt; 时，此时将从 1 挡升至 2 挡。发动机转速特性曲线骤降，然后恢复加速。2 挡升至 3 挡和 3 挡升至 4 挡分别在大约 4 秒钟和 8 秒钟时发生。请注意，由于整车惯量较大，车辆速度要平滑得多。&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;emphasis bold&quot;&gt;图 12：超车动作仿真时间历史记录&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在 &lt;code class=&quot;literal&quot;&gt;t=15sec&lt;/code&gt; 时，驾驶员将节气门开度给到 100%，这可能是超车动作的典型情况。变速器降至 3 挡，发动机转速从大约 2600 RPM 跳至大约 3700 RPM。因此，发动机扭矩会略微增加，变速器的机械效益也会略微增大。在持续重节气门下，车辆加速至大约 100 mph，然后在大约 &lt;code class=&quot;literal&quot;&gt;t = 21 sec&lt;/code&gt; 换挡至超速挡。在仿真的其余部分，车辆以第四挡位行驶。双击 ManeuversGUI 模块并使用图形界面更改节气门和制动历史记录。&lt;/p&gt;
&lt;h3 id=&quot;d120e4941&quot; class=&quot;title&quot;&gt;关闭模型&lt;span id=&quot;sldemo_autotrans-17&quot; class=&quot;anchor_target&quot;/&gt;&lt;/h3&gt;
&lt;p&gt;关闭模型并清除生成的数据。&lt;/p&gt;
&lt;h3 id=&quot;d120e4947&quot; class=&quot;title&quot;&gt;结论&lt;span id=&quot;sldemo_autotrans-18&quot; class=&quot;anchor_target&quot;/&gt;&lt;/h3&gt;
&lt;p&gt;此基本系统可以通过模块化的方式轻松增强，例如将发动机或变速器替换为更复杂的模型。因此，我们可以在此结构内通过渐进式优化来构建大型系统。Stateflow 控制逻辑与 Simulink 信号处理的无缝集成使我们能够构造高效且直观的模型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关注公众号： MATLAB基于模型的设计 （ID：xaxymaker） ，每天推送MATLAB学习最常见的问题，&lt;/strong&gt;每天进步一点点，业精于勤荒于嬉。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1082605/201812/1082605-20181216183156624-877634862.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 打开微信扫一扫哦！&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Sat, 23 Feb 2019 14:46:00 +0000</pubDate>
<dc:creator>MATLAB基于模型的设计</dc:creator>
<og:description>此示例说明如何使用 Simulink® 对汽车传动系统建模。Stateflow® 通过表示变速器控制逻辑来增强 Simulink 模型。Simulink 为动态系统和过程的建模和仿</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/52geek/p/10424708.html</dc:identifier>
</item>
<item>
<title>EF Core 快速上手——EF Core的三种主要关系类型 - 戎&quot;码&quot;一生</title>
<link>http://www.cnblogs.com/lucky_hu/p/10424676.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lucky_hu/p/10424676.html</guid>
<description>&lt;hr/&gt;&lt;h2 id=&quot;系列文章&quot;&gt;系列文章&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI0MzM1NjUyMQ==&amp;amp;mid=2247483778&amp;amp;idx=1&amp;amp;sn=3238d3b8d6f52bd4afbdde0b801ed23d&amp;amp;chksm=e96f0784de188e92fa195dd35e8dd46f6ddda1dfb9ea1f3d2c0f034706a4d10fb61ef99a94ba&amp;amp;token=620898132&amp;amp;lang=zh_CN#rd&quot;&gt;EF Core 快速上手——EF Core 入门&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;本节导航&quot;&gt;本节导航&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;三种数据库关系类型建模&lt;/li&gt;
&lt;li&gt;Migration方式创建和习修改数据库&lt;/li&gt;
&lt;li&gt;定义和创建应用DbContext&lt;/li&gt;
&lt;li&gt;
&lt;h2 id=&quot;将复杂查询拆分为子查询&quot;&gt;将复杂查询拆分为子查询&lt;/h2&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;  本章主要介绍如何使用EF Core进行数据库读取,俗称查询。您将创建一个数据库,它包含EFCore中三种主要数据库关系类型。在这个过程当中,你将学会使用EF Core 创建和改变数据库的结构。&lt;/p&gt;
&lt;p&gt;  接下来你将学习到如何使用EF Core访问数据库并从数据库表中获取数据。在查看用主数据加载相关数据的各种方法之前,你将了解EF Core查询的基本格式。例如,第一章中加载与书关联的作者。&lt;/p&gt;
&lt;p&gt;  在学习加载关联数据之后,你将着手构建更加复杂的查询,而这些是图书售卖网站运行起来所必须的。这将涉及到排序,过滤,和分页,以及将这些单独的查询命令组合在一起以创建一个复合数据库查询。&lt;/p&gt;
&lt;h5 id=&quot;场景设定我们的图书销售网站&quot;&gt;2.1 场景设定——我们的图书销售网站&lt;/h5&gt;
&lt;p&gt;  本章,你将开始构建一个图书销售网站,我们称之为&lt;em&gt;Book APP&lt;/em&gt;。这个应用示例提供了一个非常好的工具来查看查询中的关系。本节介绍数据库、各种类以及Book App 访问数据库所需的EF Core 部分。&lt;/p&gt;
&lt;blockquote readability=&quot;2.8333333333333&quot;&gt;
&lt;p&gt;note:你可以在线访问book app&lt;br/&gt;&lt;a href=&quot;http://efcoreinaction.com/&quot; class=&quot;uri&quot;&gt;http://efcoreinaction.com/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;book-app-相关的数据库&quot;&gt;2.1.1 Book App 相关的数据库&lt;/h5&gt;
&lt;p&gt;  尽管我们可以把一本书相关的信息,它的作者,评论都创建在一张表中,但是在关系型数据库中那样做不会运行良好,尤其是评论字段的长度是课变的。关系型数据库范式会将重复数据拆分(比如,authors表)。&lt;/p&gt;
&lt;p&gt;  我们有几种方式可以把图书的数据各个部分在数据库中分类(存储),但是对于本例，数据库具有EF-Core关系中每种主要关系类型中的一种。这三种类型是:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一对一关系:PriceOffer to a Book&lt;/li&gt;
&lt;li&gt;一对多关系:Reviews to a Book&lt;/li&gt;
&lt;li&gt;多对多关系:Books to Authors&lt;/li&gt;
&lt;/ul&gt;&lt;h6 id=&quot;一对一关系priceoffer-to-a-book&quot;&gt;一对一关系:PriceOffer to a Book&lt;/h6&gt;
&lt;p&gt;  一本书会有一个促销价格。这是通过在&lt;strong&gt;PriceOffer&lt;/strong&gt;*实体类增加一个可选字段实现的,这是一个一对一关心的例子(从技术上讲,它是一对零或一关系,但是EF Core对它们的处理时一样的)。请看图2.1&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pepper.img.zhikestreet.com/one-too-zero-one.png&quot; alt=&quot;使用场景&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  为了计算这本你图书的最终价格,你需要检查&lt;strong&gt;PriceOffer&lt;/strong&gt;表的一行数据,它们是通过外键关联的。如果这行被查到有数据,&lt;strong&gt;NewPrice&lt;/strong&gt;字段的数据将被查到的价格替代,&lt;strong&gt;PromotionalText&lt;/strong&gt;的值将会在屏幕上显示,比如:&lt;br/&gt;&lt;em&gt;$40 $30 Our summertime price special, for this week only!&lt;/em&gt;&lt;/p&gt;
&lt;h6 id=&quot;一对多关系reviews-to-a-book&quot;&gt;一对多关系:Reviews TO A Book&lt;/h6&gt;
&lt;p&gt;  你允许用户对图书予以评论。他们可以给书评星级并能随意评论。因为一本书可以有零个或多个(不限制数量)评论,你需要创建一个表来存储上这些数据。本示例中,这张表可以命名为&lt;strong&gt;Review&lt;/strong&gt;。&lt;strong&gt;Books&lt;/strong&gt;表相对于&lt;strong&gt;Review&lt;/strong&gt;表是一对多的关系。如下图2.2所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pepper.img.zhikestreet.com/one-to-many.png&quot; alt=&quot;使用场景&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  你需要在摘要显示中，您需要计算评论的数量并计算出平均星级，以显示摘要。例如,这里有一个典型的屏幕显示,你可能从这一对多的关系中产生,如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Votes 4.5 by 2 customers&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;多对多关系: BOOKS TO AUTHORS&lt;/p&gt;
&lt;p&gt;  图书可以被一名或者多名写作,一个作者可以些一本或多本图书。因此,需要一张Books表来存储书本数据,另一张表Authors存储作者数据。Books表和Authors表之间链接的表称为链接表。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pepper.img.zhikestreet.com/many-to-manuy.png&quot; alt=&quot;使用场景&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  此关系的典型屏幕显示如下&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;by Dino Esposito, Andrea Saltarello&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;本章未涉及的其他关系类型&quot;&gt;2.1.2 本章未涉及的其他关系类型&lt;/h5&gt;
&lt;p&gt;  在EF Core中,你可以定义一个实体类,而这个是实体类继承自另一个实体类。例如,你可以定义PriceOffer继承至BooK.那样会获得和此前一对一关系一样的结果。EFCore通过每个层次结构一个表(TPH)的模式实现,这个在第七章会涉及到。&lt;/p&gt;
&lt;p&gt;  另外i一种关系类型是分层关系:一组数据项通过层次结构相互关联。一个典型的实例是Employee类。它有一个指向员工经理的关系，而经理反过来又是员工(注:这种关系可能叫自关联)。&lt;/p&gt;
&lt;p&gt;  EF Core使用与一对一和一对多相同的方法来提供层次关系。在第七章,我会更多谈论这个关系,在那里,我会解释如何配置。&lt;/p&gt;
&lt;h5 id=&quot;最终的数据库展示所有表&quot;&gt;2.1.3 最终的数据库展示所有表&lt;/h5&gt;
&lt;p&gt;  图2.4 展示了Book App的数据库,这个数据库将用于本章和第三章的实例。它包含所有已描述的表，包括完整的books表中所有列的定义&lt;/p&gt;
&lt;p&gt;NOTE:&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;这个数据库关系图使用了和第一章相同的布局和术语。PK表示主键,FK表示外键。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://pepper.img.zhikestreet.com/manytomany.png&quot; alt=&quot;使用场景&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  为了帮助你理解这个数据库,图2.5展示了输出到屏幕的图书列表,但是请将目光聚焦到一本书上。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pepper.img.zhikestreet.com/singlebooklist.png&quot; alt=&quot;使用场景&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;ef-core映射到数据库的类&quot;&gt;2.1.4 EF Core映射到数据库的类&lt;/h5&gt;
&lt;p&gt;  我创建了5个能够映射到数据库中五个表的类。它们是Book,PriceOffer,Review , Author,BookAuthor是多对多关系表。&lt;/p&gt;
&lt;p&gt;  这些类被称为实体类,以表明它们被EF Core映射到了数据库。从软件视角,这些类没有什么特别之处。它们是常规的.NET类,有时被称为简单传统 CLR 对象(Plain Old CLR Object / POCO）。实体类标志着这个类是EF Core映射到数据库的类。&lt;/p&gt;
&lt;p&gt;  主实体类是Book类,如下展示。你可以看到,它关联了一个实体类PriceOffer,一个Review实体类的集合和BookAuthor实体类的集合。BooKAuthor将Book类链接到一个或多个Author.&lt;/p&gt;
&lt;p&gt;  为了简单起见，我们使用ef core的契约配置方法对数据库建模。我们使用EF Core按照惯例来命名实体类的主键和外键的属性。此外,.net 的导航属性,例如ICollection Reviews,定义了我们想要的关系类型。例如,Reviews属性的类型是ICollection,这个关系是一对多关系。第6章和第7章描述了其它方式来定义EF Core的数据库模型。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pepper.img.zhikestreet.com/Book.png&quot; alt=&quot;使用场景&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;  《Entity Framework Core In Action》&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://pepper.img.zhikestreet.com/ZhiKeCode.jpg&quot; alt=&quot;使用场景&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 23 Feb 2019 14:40:00 +0000</pubDate>
<dc:creator>戎&amp;quot;码&amp;quot;一生</dc:creator>
<og:description>系列文章 'EF Core 快速上手——EF Core 入门' 本节导航 三种数据库关系类型建模 Migration方式创建和习修改数据库 定义和创建应用DbContext 将复杂查询拆分为子查询 &amp;</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lucky_hu/p/10424676.html</dc:identifier>
</item>
<item>
<title>SpringBoot进阶教程(二十九)整合Redis 发布订阅 - 请叫我头头哥</title>
<link>http://www.cnblogs.com/toutou/p/redis_pub_sub.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/toutou/p/redis_pub_sub.html</guid>
<description>&lt;div class=&quot;bodyCustomClass&quot; readability=&quot;31.259541984733&quot;&gt;
&lt;blockquote readability=&quot;11.610687022901&quot;&gt;
&lt;p&gt;SUBSCRIBE, UNSUBSCRIBE 和 PUBLISH 实现了 发布/订阅消息范例，发送者 (publishers) 不用编程就可以向特定的接受者发送消息 (subscribers). Rather, 发布的消息进入通道，不需要知道有没有订阅者. 订阅者发表感兴趣的一个或多个通道，并且只接受他们感兴趣的消息，不管发布者是不是存在. 发布者和订阅者的解耦可以允许更大的伸缩性和更多动态的网络拓扑。&lt;/p&gt;
&lt;p&gt;关于发布订阅(消息队列)之前也过一篇&lt;a title=&quot;请叫我头头哥&quot; href=&quot;https://www.cnblogs.com/toutou/p/springboot_rabbitmq.html&quot; target=&quot;_blank&quot;&gt;《SpringBoot进阶教程(二十二)集成RabbitMQ---MQ实战演练》&lt;/a&gt;。感兴趣的可以看看。今天说的发布订阅，是基于Redis的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;h2 id=&quot;_nav_0&quot; class=&quot;blogCustomTitleStyle&quot;&gt;&lt;span class=&quot;blogCustomTitleIco&quot;&gt;v&lt;/span&gt;准备工作&lt;/h2&gt;
&lt;p&gt;学习本章节之前，建议依次阅读以下文章，更好的串联全文内容，如已掌握以下列出知识点，请跳过：&lt;/p&gt;
&lt;h2 id=&quot;_nav_1&quot; class=&quot;blogCustomTitleStyle&quot;&gt;&lt;span class=&quot;blogCustomTitleIco&quot;&gt;v&lt;/span&gt;命令行操作发布订阅&lt;/h2&gt;
&lt;p&gt;下面实例中，图中左侧窗口视为客户端1，右侧窗口视为客户端2.&lt;/p&gt;
&lt;p&gt;1.1 客户端1中订阅频道chatDemo&lt;/p&gt;
&lt;p&gt;&lt;code&gt;subscribe chatDemo&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201902/506684-20190222145417567-192981819.png&quot; alt=&quot;SpringBoot进阶教程(二十九)整合Redis 发布订阅&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1.2 客户端2向频道chatDemo中发送两次消息，客户端1中会实时接收这两次消息。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;publish chatDemo &quot;Hello World.&quot;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;publish chatDemo &quot;Hello Demo.&quot;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201902/506684-20190222145424441-1197546482.png&quot; alt=&quot;SpringBoot进阶教程(二十九)整合Redis 发布订阅&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1.3 在客户端1中退订频道，或者Ctrl+C退出redis连接模式。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;unsubscribe chatDemo&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201902/506684-20190222145434095-463834161.png&quot; alt=&quot;SpringBoot进阶教程(二十九)整合Redis 发布订阅&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上例子中主要介绍了订阅频道、向指定的频道发布消息、然后消息推送到订阅者以及取消订阅。&lt;/p&gt;
&lt;h2 id=&quot;_nav_2&quot; class=&quot;blogCustomTitleStyle&quot;&gt;&lt;span class=&quot;blogCustomTitleIco&quot;&gt;v&lt;/span&gt;项目中操作发布订阅&lt;/h2&gt;
&lt;p&gt;2.1 消息监听类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.demo.common;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Created by toutou on 2019/2/23.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RedisReceiver {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; receiveMessage(String message) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO 这里是收到通道的消息之后执行的方法&lt;/span&gt;
&lt;span&gt;        System.out.println(message);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.2 Redis消息订阅配置类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.demo.Redis;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.demo.common.RedisReceiver;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cache.annotation.EnableCaching;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Bean;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Configuration;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.data.redis.connection.RedisConnectionFactory;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.data.redis.core.StringRedisTemplate;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.data.redis.listener.PatternTopic;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.data.redis.listener.RedisMessageListenerContainer;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.data.redis.listener.adapter.MessageListenerAdapter;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Created by toutou on 2019/1/20.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Configuration
@EnableCaching
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RedisCacheConfig {
    @Bean
    RedisMessageListenerContainer container(RedisConnectionFactory connectionFactory,
                                            MessageListenerAdapter listenerAdapter) {

        RedisMessageListenerContainer container &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RedisMessageListenerContainer();
        container.setConnectionFactory(connectionFactory);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 可以添加多个 messageListener，配置不同的交换机&lt;/span&gt;
        container.addMessageListener(listenerAdapter, &lt;span&gt;new&lt;/span&gt; PatternTopic(&quot;channel:test&quot;&lt;span&gt;));

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; container;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 消息监听器适配器，绑定消息处理器，利用反射技术调用消息处理器的业务方法
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; receiver
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Bean
    MessageListenerAdapter listenerAdapter(RedisReceiver receiver) {
        System.out.println(&lt;/span&gt;&quot;消息适配器1&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; MessageListenerAdapter(receiver, &quot;receiveMessage&quot;&lt;span&gt;);
    }

    @Bean
    StringRedisTemplate template(RedisConnectionFactory connectionFactory) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringRedisTemplate(connectionFactory);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.3 测试接口&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.demo.controller;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; lombok.extern.slf4j.Slf4j;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.data.redis.core.StringRedisTemplate;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RequestMapping;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RestController;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Date;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Created by toutou on 2019/1/20.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@RestController
@Slf4j
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RedisController {
    @Autowired
    StringRedisTemplate template;

    @RequestMapping(value &lt;/span&gt;= &quot;/syncmessage&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String SyncMessage(){
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = 1; i &amp;lt;= 5; i++&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 为了模拟消息，sleep一下。&lt;/span&gt;
                Thread.sleep(2000&lt;span&gt;);
            }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(InterruptedException ex){}
            template.convertAndSend(&lt;/span&gt;&quot;channel:test&quot;, String.format(&quot;我是消息{%d}号: %tT&quot;, i, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date()));
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;5&quot;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.4 项目目录结构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201902/506684-20190222145623316-271981154.png&quot; alt=&quot;SpringBoot进阶教程(二十九)整合Redis 发布订阅&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.5 运行效果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201902/506684-20190222145631238-1059359164.png&quot; alt=&quot;SpringBoot进阶教程(二十九)整合Redis 发布订阅&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;_nav_3&quot; class=&quot;blogCustomTitleStyle&quot;&gt;&lt;span class=&quot;blogCustomTitleIco&quot;&gt;v&lt;/span&gt;源码地址&lt;/h2&gt;
&lt;p&gt;&lt;a title=&quot;请叫我头头哥&quot; href=&quot;https://github.com/toutouge/javademo/tree/master/hellospringboot&quot; target=&quot;_blank&quot;&gt;https://github.com/toutouge/javademo/tree/master/hellospringboot&lt;/a&gt;&lt;/p&gt;
&lt;div id=&quot;MySignature&quot; readability=&quot;9.0030211480363&quot;&gt;
&lt;p id=&quot;PSignature&quot;&gt;&lt;br/&gt;作　　者：&lt;strong&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/toutou/&quot; target=&quot;_blank&quot;&gt;请叫我头头哥&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;出　　处：&lt;a href=&quot;http://www.cnblogs.com/toutou/&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/toutou/&lt;/a&gt;&lt;br/&gt;关于作者：专注于基础平台的项目开发。如有问题或建议，请多多赐教！&lt;br/&gt;版权声明：本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接。&lt;br/&gt;特此声明：所有评论和私信都会在第一时间回复。也欢迎园子的大大们指正错误，共同进步。或者&lt;a href=&quot;http://msg.cnblogs.com/msg/send/%E8%AF%B7%E5%8F%AB%E6%88%91%E5%A4%B4%E5%A4%B4%E5%93%A5&quot;&gt;直接私信&lt;/a&gt;我&lt;br/&gt;声援博主：如果您觉得文章对您有帮助，可以点击文章右下角&lt;strong&gt;&lt;span&gt;【&lt;a id=&quot;post-up&quot; href=&quot;javascript:void(0);&quot;&gt;推荐&lt;/a&gt;】&lt;/span&gt;&lt;/strong&gt;一下。您的鼓励是作者坚持原创和持续写作的最大动力！&lt;br/&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Sat, 23 Feb 2019 14:31:00 +0000</pubDate>
<dc:creator>请叫我头头哥</dc:creator>
<og:description>SUBSCRIBE, UNSUBSCRIBE 和 PUBLISH 实现了 发布/订阅消息范例，发送者 (publishers) 不用编程就可以向特定的接受者发送消息 (subscribers). Ra</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/toutou/p/redis_pub_sub.html</dc:identifier>
</item>
<item>
<title>连载《一个程序猿的生命周期》-《发展篇》- 25.论一个非正式项目经理的自我修养 - 一个程序猿的生命周期</title>
<link>http://www.cnblogs.com/blog470130547/p/10424535.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/blog470130547/p/10424535.html</guid>
<description>&lt;p&gt;&lt;span&gt;       准备了一个多月的文章，现在仍然无从下笔。是因为涉及的内容比较多，理不清思路；亦或事情比较多，不想动脑子。今天想起稻盛和夫写的《活法》中有一个公式：工作的结果=思维方式X热情X能力，思维方式有正负之分，热情和能力没有负值，最终思维方式决定了做事的结果。认知水平决定了思维方式在特定场景处理事物的合理性，认知又涉及到唯物论和唯心论，又上升到哲学问题，哲学对于普通生活来讲需要艺术感。生活中有很多角色，平民、老公、父亲、员工、部门经理、项目经理......，一个人成熟的标准是在众多角色之间平滑转换，就像开车换档没有顿挫感。但是，很难界定众多角色中哪个是主角，而每个角色又要尽可能到位，所以这篇文章的标题叫《论一个非正式**的自我修养》。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      人的贪婪在于欲想得到和控制一切，但受限于认知与思维方式而不可得，最终陷于无限的抑郁和痛苦这中。无限的自己挖坑自己跳，有的人爬不出来了，重复这个循环，却不自醒；有的人爬出来了，继续前行。对于这个项目的举步维艰，我总是说胎带来的。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;strong&gt;不知道，项目发展到如此地步&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;      项目执行了两个多月，最终用户急了。（1）项目整体管控流程很不规范，项目不交底、项目连续性差；（2）人员组织不固定，整体涣散，没有打杖的凝聚力；（3）调研纵向不够深、横向不够广，整体不够细；（4）项目现场工作远程指挥，头绪多；（5）与用户人员结合不紧密，无法很好共同成长；（6）项目执行的工作方式和思维方式不够严紧，走很多弯路；（7）项目成员浮躁，用户不踏实；（8）用户让怎么做就怎么做，公司直接干外包好啦。用户叫来公司高层一起开会，定人、定措施、定计划，公司高层给用户理论技术协议与需求内容的差异，在中国神州大地上，貌似行不通。我们要的不是对抗，而是共生共存共赢，化干戈为玉帛，用《刷新》一书中说的是“同理心”。不管是高层关系、低层关系，都需要把产品做好、把项目执行好。往往公司高层与基层执行员工之间不搭界，而造成项目执行困难。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      我常说经验主义害死人，经验本来受限于时间和空间，事物却在发展，拿经验判断现在或未来是愚蠢的行为，而只能是借鉴。和原来定的项目负责人交流，他却说在原来公司做项目，和用户交流很好，项目执行的也很好，那我只能骂他一顿了。骂的有道理，是起作用的，思维方式在转变，做事也更合理了。难道只有基层员工有这个问题嘛，众多公司高层同样如此，不得不让人哭笑不得，以为掌控了宇宙却是蝼蚁之躯。学习和认知不是让自己更有知识，而是让自己更无知，知耻而后进，现在大多人“无耻”，所以谦卑之心无从寻找。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      事已至此，项目只能重新调整思路，定人、定措施、定计划，走上了用户规定的路线。我们怪用户太强势吗？不是，是用户各方面的水平确实比较高，与之交往需要高智商和高情商。我们应该考虑一个问题：这才是1000万的项目，如果是1个亿的项目，又该当如何呢？！用户是试金石，要不怎么知道公司或个人是否有真本事呢。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;strong&gt;不知道，怎么就让我“负责”项目了&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;      我是有预见性，有一次来现场调研，回京的路上给用户发了信息，大意：感受到了你们的务实的精神......期待与之合作。人要先知先觉，对于负责这个项目有些思想准备。但是我十分不情愿干这样的工作，半路出家力挽狂澜吗？只怕只有费力不讨好。为什么做事的思维和方式方法如此混乱，不忍心在群里参与讨论。但是由于各种原因，我始终没有答应当项目经理，只是从技术层面推动这个项目。因为：（1）这本身不是我的“能力”范围，有销售人员、有原来的负责人员，我无意争抢他们的位置。人做事总是要给其他人留有余地，我只负责干活，功劳任由其他人拿走，用客户的话说是：你怎么无欲无求呢。我本身是好意，他们是否能够理解另当别论。（2）因为项目体系较大，根本就不是一个人能盯的过来的，需要N多个支点，是一种强合作有关系。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     主席说世界上有两种困难：（1）自然界的困难；（2）人的困难。对于这个项目，我们面对的就是人的困难。从人员组织结构就能够看出来是否能够打硬杖，类似看人的面相一样，所谓尽人事听天命。尽管人员结构定了，但是仍然是松散组织，并且需要磨合。以至于项目重新开始的几天都没有睡好觉，思考了太多问题。刚到用户现场正式开展工作时，初见大领导就问我的简历。过了一关又一关，需求分析打翻身战、基本设计打攻坚战、现在的开发和上线该打持久战了......，真正塑造人格的是挫折与苦难，金一南写《苦难的辉煌》用意在此。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      项目开始逐步开始走向正轨，已然过去将来三个月的时间，我的心态依然很平静。平静的迎接将要降生的二宝，老婆独自30+周带着大宝。是的，人生有很多角色，没有主角，又要做好。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;strong&gt;不知道，传言就流传开了&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;       传言说：只有谁和谁能和用户对接......。我始终认为这句话有毒，难道是逃避的理由吗？难道是负责的理由吗？大部分人容易极端化，看到对手想一拳过去就把对方KO，发现没有成功之后，自己却怂了。犹如中国社会极*左和极*右势力一直很庞大，真正是成熟是避免极端。我一直对此话不以为然，是因为我想保持自我的认知。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      本质上来讲，我不需要任何人批评我、夸我，目标就是把事情做成，我就是我。我可能去“求”人或同事进行合作，是为了达成目标，犹如我做农业的时候，去找志同道合的人一样。所以，我是主要负责也好，辅助工作也好，对于我来讲没有本质区别，肯定会实现我个人目标。对于流言，更不会左右我的心境和目标。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;strong&gt;不知道，项目怎么继续走下去&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;      昨天我问同事：项目最困难的时候过去了吧？同事回答：还在后面...... 。是这样的，只是过了需求和设计，部署了一个独系统，其他的系统还有开发、测试、部署、联调、完善、运维，步步惊心。昨天同事和我说：一开始就没有规划、交流好，现在返工......。领导却认为，这些不是很好做嘛，原来有基础，为什么还要加人，可能这是大部分公司领导的一惯作风。家里开发需要人盯和协调，现场执行需要人盯和协调，除非把公司人员组织在一起，否则至少需要两个支点，还不算各业务系统开发负责人员。要说项目怎么继续下去？人员组织也好，激励机制也好，总之就是熬。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      项目如何走到现在，我也不知道。看似不知道，不在掌控之中，冥冥之中又在掌控之中。听说，2019年是未来10年中最好的一年，对于我来讲，是值得期待的一年。&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;hr/&gt;&lt;div&gt;
&lt;div&gt;
&lt;div&gt;
&lt;div readability=&quot;6.241134751773&quot;&gt;
&lt;div readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一个程序猿的生命周期 微信平台&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;口   号：职业交流，职业规划；面对现实，用心去交流、感悟。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;公众号：iterlifetime&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;strong&gt;百木-ITer职业交流奋斗 群：141588103&lt;/strong&gt;   &lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二维码：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/691334/201606/691334-20160618075950167-974887453.jpg&quot; alt=&quot;&quot; width=&quot;120&quot; height=&quot;120&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Sat, 23 Feb 2019 14:13:00 +0000</pubDate>
<dc:creator>一个程序猿的生命周期</dc:creator>
<og:description>准备了一个多月的文章，现在仍然无从下笔。是因为涉及的内容比较多，理不清思路；亦或事情比较多，不想动脑子。今天想起稻盛和夫写的《活法》中有一个公式：工作的结果=思维方式X热情X能力，思维方式有正负之分，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/blog470130547/p/10424535.html</dc:identifier>
</item>
</channel>
</rss>