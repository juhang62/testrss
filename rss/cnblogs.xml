<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>jvm垃圾回收算法 - 五色花的博客</title>
<link>http://www.cnblogs.com/luao/p/10646236.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/luao/p/10646236.html</guid>
<description>&lt;h2&gt;1、标记 - 清除算法 (Mark-sweep算法) 最基础的收集算法&lt;/h2&gt;
&lt;h3&gt;两个阶段：&lt;/h3&gt;
&lt;p&gt;分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。&lt;/p&gt;
&lt;h3&gt;两个不足：&lt;/h3&gt;
&lt;p&gt;1、效率问题，标记和清除两个过程的效率都不高。&lt;br/&gt;2、空间问题，标记清除之后会产生大量的不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大的对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1613061/201904/1613061-20190402233338996-1823246286.png&quot; alt=&quot;&quot; width=&quot;539&quot; height=&quot;423&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2、复制算法（Copying）为了解决效率问题&lt;/h2&gt;
&lt;h3&gt;原理&lt;/h3&gt;
&lt;p&gt;它将可用内存按容量划分为大小相等的两块，每次之使用其中的一块。当这一块内存用完了，就将还存活这着的对象复制到另外一块上面，然后再把已使用过的内存空间一次性清理掉。这样使得每次都对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。&lt;/p&gt;
&lt;h3&gt;缺点&lt;/h3&gt;
&lt;p&gt;将内存缩小为原来的一半，代价太高。&lt;/p&gt;
&lt;h3&gt;应用&lt;/h3&gt;
&lt;p&gt;将内存分为一块较大的Eden（新生代）空间和两块较小的Survivor（幸存者区）空间，每次使用Eden和其中一块Survivor。回收时，将Eden与Survivor中还存活的对象一次性地复制到另一块Survivor空上，最后清理掉Eden和刚才用过的Survivor空间。 HotSpot虚拟机默认Eden与Survivor的比例8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80% + 10%），只有10% 的内存会被浪费。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1613061/201904/1613061-20190402233543968-460265768.png&quot; alt=&quot;&quot; width=&quot;557&quot; height=&quot;439&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;3、标记 - 整理算法（Mark-Compact）&lt;/h2&gt;
&lt;p&gt;适用于老年代，将所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存&lt;/p&gt;
&lt;h3&gt;标记-复制算法的缺点&lt;/h3&gt;
&lt;p&gt;1、复制算法在对象存活率较高时就要进行较多的复制操作，效率就会变低。&lt;br/&gt;2、如果不想浪费50%的空间，就需要额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况。所以，老年代一般不能直接使用这种算法。&lt;/p&gt;
&lt;h3&gt;标记-整理算法原理&lt;/h3&gt;
&lt;p&gt;标记过程仍然与“标记 - 清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1613061/201904/1613061-20190402233901904-174836171.png&quot; alt=&quot;&quot; width=&quot;535&quot; height=&quot;421&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;4、分代收集算法（Generational Collention 算法）新生代、老年代&lt;/h2&gt;
&lt;p&gt;1、当前商业虚拟机的垃圾收集器都采用“分代收集”（generational collection）算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同，将内存划分为几块。&lt;br/&gt;2、一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。&lt;br/&gt;3、在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。&lt;br/&gt;4、而老年代中因为对象存活率高，没有额外空间对他进行分配担保，就必须使用“标记 - 清除”算法，或“标记 - 整理”算法来进行回收。&lt;/p&gt;
</description>
<pubDate>Tue, 02 Apr 2019 15:37:00 +0000</pubDate>
<dc:creator>五色花的博客</dc:creator>
<og:description>1、标记 - 清除算法 (Mark-sweep算法) 最基础的收集算法 两个阶段： 分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。 两个不足： 1</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/luao/p/10646236.html</dc:identifier>
</item>
<item>
<title>C语言实现将日期、时间保存到文本文件中 - 逆夏的流年</title>
<link>http://www.cnblogs.com/wychen5/p/10646237.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wychen5/p/10646237.html</guid>
<description>&lt;p&gt;今天突然兴起，看来一下C语言的文件操作，以前在学习的时候，总是一带而过，觉得没有什么用处；但是现在看来，还真的没有什么用处，最后，我现在还有用到，当然这只是我的个人认为，并不能说明什么，在此我将自己写的一段代码附上，希望能和大家一同学习&lt;/p&gt;
&lt;p&gt;1、打开一个文本文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; FILE *fopen( &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; * filename, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; * mode );
&lt;/pre&gt;&lt;/div&gt;
&lt;div id=&quot;1143-1554211676983&quot; data-theme=&quot;default&quot; data-language=&quot;javascript&quot; readability=&quot;41.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;linux文件路径：
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; linux：fopen(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/tmp/test.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;w+&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; 
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;windows文件路径：
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; windows:fopen(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;E:/Desktop/cyuyan_sz/vs2010/one/jiguoti/temp/a.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;w+&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;模式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1603360/201904/1603360-20190402232148276-1627424877.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果处理的是二进制文件，则需使用下面的访问模式来取代上面的访问模式：&lt;/p&gt;
&lt;div readability=&quot;11.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;rb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ab&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;rb+&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;r+b&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wb+&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;w+b&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ab+&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a+b&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;、
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2、写入文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; fputc( &lt;span&gt;int&lt;/span&gt; c, FILE *&lt;span&gt;fp );
c:写入的字符    fp:打开的文件流&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div readability=&quot;18&quot;&gt;3、读取文件
&lt;div id=&quot;3274-1554212788807&quot; data-theme=&quot;default&quot; data-language=&quot;javascript&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; fgetc( FILE * fp );
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;fgetc() 函数从 fp 所指向的输入文件中读取一个字符。返回值是读取的字符，如果发生错误则返回 EOF。下面的函数允许您从流中读取一个字符串&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt; 
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;char&lt;/span&gt; *fgets( &lt;span&gt;char&lt;/span&gt; *buf, &lt;span&gt;int&lt;/span&gt; n, FILE *fp );
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;函数 fgets() 从 fp 所指向的输入流中读取 n - 1 个字符。它会把读取的字符串复制到缓冲区 buf，并在最后追加一个 null 字符来终止字符串。&lt;/p&gt;
&lt;p&gt;如果这个函数在读取最后一个字符之前就遇到一个换行符 '\n' 或文件的末尾 EOF，则只会返回读取到的字符，包括换行符。您也可以使用 int fscanf(FILE *fp, const char *format, ...) 函数来从文件中读取字符串，但是在遇到第一个空格字符时，它会停止读取。&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;4、关闭文件&lt;/p&gt;
&lt;div&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
fclose( FILE *fp );
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;div readability=&quot;8.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #include &amp;lt;stdio.h&amp;gt;
&lt;span&gt; 2&lt;/span&gt; #include &amp;lt;&lt;span&gt;string&lt;/span&gt;.h&amp;gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     FILE *fp =&lt;span&gt; NULL;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     fp = fopen(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;E:/Desktop/cyuyan_sz/vs2010/one/jiguoti/temp/a.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;w+&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     fprintf(fp,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello word......\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     fputs(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello word......\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,fp);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    fclose(fp);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    getchar();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;所示代码运行结果为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1603360/201904/1603360-20190402232345027-934069898.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;下面进入正题：&lt;/p&gt;
&lt;p&gt;如何将日期、时间存储到记事本文件中,&lt;/p&gt;
&lt;p&gt;1、如何获取日期、时间（time.h）&lt;/p&gt;
&lt;p&gt;2、如何保存&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;vs2010在编译生成程序之后，dos界面会出现闪退的情况，
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;解决办法:
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;1.在源程序后面添加getchar();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;2.添加头文件#include之后在main函数结尾前写上system(&quot;pause&quot;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; #include &amp;lt;stdio.h&amp;gt;
&lt;span&gt; 8&lt;/span&gt; #include &amp;lt;&lt;span&gt;string&lt;/span&gt;.h&amp;gt;
&lt;span&gt; 9&lt;/span&gt; #include &amp;lt;time.h&amp;gt;
&lt;span&gt;10&lt;/span&gt; #include &amp;lt;Windows.h&amp;gt;
&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     FILE *fp =&lt;span&gt; NULL;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;char&lt;/span&gt; *s=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;adasdsadasd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    time_t timep;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;struct&lt;/span&gt; tm *&lt;span&gt;p;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     fp = fopen(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;E:/Desktop/cyuyan_sz/vs2010/one/jiguoti/temp/a.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         time(&amp;amp;&lt;span&gt;timep);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         p=gmtime(&amp;amp;&lt;span&gt;timep);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;   
&lt;span&gt;25&lt;/span&gt;         fputs(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;日期:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,fp);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         fprintf(fp,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,p-&amp;gt;tm_year+&lt;span&gt;1900&lt;/span&gt;);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取年&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;         fputs(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,fp);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         fprintf(fp,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,p-&amp;gt;tm_mon+&lt;span&gt;1&lt;/span&gt;);        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取月&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;         fputs(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,fp);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         fprintf(fp,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,p-&amp;gt;tm_mday);        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取日&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt;         fputs(&lt;span&gt;&quot;&lt;/span&gt;      &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,fp);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         fputs(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;时间:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,fp);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         fprintf(fp,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,p-&amp;gt;tm_hour+&lt;span&gt;8&lt;/span&gt;);        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取时&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;         fputs(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,fp);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         fprintf(fp,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,p-&amp;gt;tm_min);            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取分&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;         fputs(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,fp);
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         fprintf(fp,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,p-&amp;gt;tm_sec);            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取秒&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt; 
&lt;span&gt;40&lt;/span&gt;         fputs(&lt;span&gt;&quot;&lt;/span&gt;      &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,fp);
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;         fputs(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;今天是今年的第 &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,fp);
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;         fprintf(fp,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,p-&amp;gt;tm_yday);        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取今年的第几天&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt;         fputs(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; 天\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,fp);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;换行&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt;         
&lt;span&gt;45&lt;/span&gt;         fputs(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,fp);
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;         Sleep(&lt;span&gt;1000&lt;/span&gt;);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1s保存一次&lt;/span&gt;
&lt;span&gt;47&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;    fclose(fp);
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;    getchar();
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;运行结果如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1603360/201904/1603360-20190402232722509-271509134.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 有问题可在下方评论，希望能共同学习&lt;/p&gt;












&lt;/div&gt;
</description>
<pubDate>Tue, 02 Apr 2019 15:37:00 +0000</pubDate>
<dc:creator>逆夏的流年</dc:creator>
<og:description>今天突然兴起，看来一下C语言的文件操作，以前在学习的时候，总是一带而过，觉得没有什么用处；但是现在看来，还真的没有什么用处，最后，我现在还有用到，当然这只是我的个人认为，并不能说明什么，在此我将自己写</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wychen5/p/10646237.html</dc:identifier>
</item>
<item>
<title>python3 对拉勾数据进行可视化分析 - Max_Lyu</title>
<link>http://www.cnblogs.com/lyuzt/p/10643941.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lyuzt/p/10643941.html</guid>
<description>&lt;p&gt;　　上回说到我们如何如何把拉勾的数据抓取下来的，既然获取了数据，就别放着不动，把它拿出来分析一下，看看这些数据里面都包含了什么信息。（本次博客源码地址：&lt;a href=&quot;https://github.com/MaxLyu/Lagou_Analyze&quot; target=&quot;_blank&quot;&gt;https://github.com/MaxLyu/Lagou_Analyze&lt;/a&gt;）&lt;/p&gt;
&lt;h2&gt;一、前期准备&lt;/h2&gt;
&lt;p&gt;　　由于上次抓的数据里面包含有 ID 这样的信息，我们需要将它去掉，并且查看描述性统计，确认是否存在异常值或者确实值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
read_file = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;analyst.csv&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 读取文件获得数据&lt;/span&gt;
data = pd.read_csv(read_file, encoding=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gbk&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 去除数据中无关的列&lt;/span&gt;
data = data[:].drop([&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ID&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;], axis=1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 描述性统计&lt;/span&gt;
data.describe()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;             　　　　　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1458123/201904/1458123-20190402165417438-1122664711.png&quot; alt=&quot;&quot; width=&quot;323&quot; height=&quot;171&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　结果中的 unique 表示的是在该属性列下面存在的不同值个数，以学历要求为例子，它包含【本科、大专、硕士、不限】这4个不同的值，top 则表示数量最多的值为【本科】，freq 表示出现的频率为 387。由于薪资的 unique 比较多，我们查看一下存在什么值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;(data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;学历要求&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;].unique())
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;工作经验&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;].unique())
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;薪资&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;].unique())
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;                 &lt;img src=&quot;https://img2018.cnblogs.com/blog/1458123/201904/1458123-20190402170318027-1505235912.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;二、预处理&lt;/h2&gt;
&lt;p&gt;　　从上述两张图可以看到，学历要求和工作经验的值比较少且没有缺失值与异常值，可以直接进行分析；但薪资的分布比较多，总计有75种，为了更好地进行分析，我们要对薪资做一个预处理。根据其分布情况，可以将它分成【5k 以下、5k-10k、10k-20k、20k-30k、30k-40k、40k 以上】，为了更加方便我们分析，取每个薪资范围的中位数，并划分到我们指定的范围内。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 对薪资进行预处理&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; pre_salary(data):
    salarys &lt;/span&gt;= data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;薪资&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;].values
    salary_dic &lt;/span&gt;=&lt;span&gt; {}
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; salary &lt;span&gt;in&lt;/span&gt;&lt;span&gt; salarys:
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 根据'-'进行分割并去掉'k',分别将两端的值转换成整数&lt;/span&gt;
        min_sa = int(salary.split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)[0][:-1&lt;span&gt;])
        max_sa &lt;/span&gt;= int(salary.split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)[1][:-1&lt;span&gt;])
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 求中位数&lt;/span&gt;
        median_sa = (min_sa + max_sa) / 2
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 判断其值并划分到指定范围&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; median_sa &amp;lt; 5&lt;span&gt;:
            salary_dic[u&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;5k以下&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = salary_dic.get(u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;5k以下&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 0) + 1
        &lt;span&gt;elif&lt;/span&gt; median_sa &amp;gt; 5 &lt;span&gt;and&lt;/span&gt; median_sa &amp;lt; 10&lt;span&gt;:
            salary_dic[u&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;5k-10k&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = salary_dic.get(u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;5k-10k&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 0) + 1
        &lt;span&gt;elif&lt;/span&gt; median_sa &amp;gt; 10 &lt;span&gt;and&lt;/span&gt; median_sa &amp;lt; 20&lt;span&gt;:
            salary_dic[u&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;10k-20k&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = salary_dic.get(u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;10k-20k&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 0) + 1
        &lt;span&gt;elif&lt;/span&gt; median_sa &amp;gt; 20 &lt;span&gt;and&lt;/span&gt; median_sa &amp;lt; 30&lt;span&gt;:
            salary_dic[u&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;20k-30k&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = salary_dic.get(u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;20k-30k&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 0) + 1
        &lt;span&gt;elif&lt;/span&gt; median_sa &amp;gt; 30 &lt;span&gt;and&lt;/span&gt; median_sa &amp;lt; 40&lt;span&gt;:
            salary_dic[u&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;30k-40k&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = salary_dic.get(u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;30k-40k&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 0) + 1
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            salary_dic[u&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;40以上&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = salary_dic.get(u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;40以上&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 0) + 1
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(salary_dic)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; salary_dic
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　对【薪资】进行预处理之后，还要对【任职要求】的文本进行预处理。因为要做成词云图，需要对文本进行分割并去除掉一些出现频率较多但没有意义的词，我们称之为停用词，所以我们用 jieba 库进行处理。jieba 是一个python实现的分词库，对中文有着很强大的分词能力。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; jieba
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; cut_text(text):
    stopwords &lt;/span&gt;=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;熟悉&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;技术&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;职位&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;相关&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;工作&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;开发&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;使用&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;能力&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;优先&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;描述&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;任职&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;经验&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;经验者&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;具有&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;具备&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;以上&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;善于&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;一种&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;以及&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;一定&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;进行&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;能够&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;我们&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; stopword &lt;span&gt;in&lt;/span&gt;&lt;span&gt; stopwords:
        jieba.del_word(stopword)
    
    words &lt;/span&gt;=&lt;span&gt; jieba.lcut(text)
    content &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.join(words)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; content
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　预处理完成之后，就可以进行可视化分析了。&lt;/p&gt;
&lt;h2&gt;三、可视化分析&lt;/h2&gt;
&lt;p&gt;　　我们先绘制环状图和柱状图，然后将数据传进去就行了，环状图的代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; draw_pie(dic):
    labels &lt;/span&gt;=&lt;span&gt; []
    count &lt;/span&gt;=&lt;span&gt; []
    
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; key, value &lt;span&gt;in&lt;/span&gt;&lt;span&gt; dic.items():
        labels.append(key)
        count.append(value)
        
    fig, ax &lt;/span&gt;= plt.subplots(figsize=(8, 6), subplot_kw=dict(aspect=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;equal&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 绘制饼状图，wedgeprops 表示每个扇形的宽度&lt;/span&gt;
    wedges, texts = ax.pie(count, wedgeprops=dict(width=0.5), startangle=&lt;span&gt;0)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 文本框设置&lt;/span&gt;
    bbox_props = dict(boxstyle=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;square,pad=0.9&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, fc=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ec=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;k&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, lw=&lt;span&gt;0)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 线与箭头设置&lt;/span&gt;
    kw = dict(xycoords=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;data&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, textcoords=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;data&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, arrowprops=dict(arrowstyle=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
              bbox&lt;/span&gt;=bbox_props, zorder=0, va=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;center&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i, p &lt;span&gt;in&lt;/span&gt;&lt;span&gt; enumerate(wedges):
        ang &lt;/span&gt;= (p.theta2 - p.theta1)/2. +&lt;span&gt; p.theta1
        y &lt;/span&gt;=&lt;span&gt; np.sin(np.deg2rad(ang))
        x &lt;/span&gt;=&lt;span&gt; np.cos(np.deg2rad(ang))
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置文本框在扇形的哪一侧&lt;/span&gt;
        horizontalalignment = {-1: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;right&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, 1: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;left&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}[int(np.sign(x))]
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 用于设置箭头的弯曲程度&lt;/span&gt;
        connectionstyle = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;angle,angleA=0,angleB={}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(ang)
        kw[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;arrowprops&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].update({&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;connectionstyle&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: connectionstyle})
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; annotate()用于对已绘制的图形做标注，text是注释文本，含 'xy' 的参数跟坐标点有关&lt;/span&gt;
        text = labels[i] + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + str(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%.2f&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %((count[i])/sum(count)*100)) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        ax.annotate(text, size&lt;/span&gt;=13, xy=(x, y), xytext=(1.35*np.sign(x), 1.4*&lt;span&gt;y),
                     horizontalalignment&lt;/span&gt;=horizontalalignment, **&lt;span&gt;kw)
    plt.show()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　柱状图的代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; draw_workYear(data):
    workyears &lt;/span&gt;= list(data[u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;工作经验&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;].values)
    wy_dic &lt;/span&gt;=&lt;span&gt; {}
    labels &lt;/span&gt;=&lt;span&gt; []
    count &lt;/span&gt;=&lt;span&gt; []
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 得到工作经验对应的数目并保存到count中&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; workyear &lt;span&gt;in&lt;/span&gt;&lt;span&gt; workyears:
        wy_dic[workyear] &lt;/span&gt;= wy_dic.get(workyear, 0) + 1
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(wy_dic)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; wy_series = pd.Series(wy_dic)&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 分别得到 count 的 key 和 value&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; key, value &lt;span&gt;in&lt;/span&gt;&lt;span&gt; wy_dic.items():
        labels.append(key)
        count.append(value)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 生成 keys 个数的数组&lt;/span&gt;
    x = np.arange(len(labels)) + 1
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将 values 转换成数组&lt;/span&gt;
    y =&lt;span&gt; np.array(count)
    
    fig, axes &lt;/span&gt;= plt.subplots(figsize=(10, 8&lt;span&gt;))
    axes.bar(x, y, color&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#1195d0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    plt.xticks(x, labels, size&lt;/span&gt;=13, rotation=&lt;span&gt;0)
    plt.xlabel(u&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;工作经验&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, fontsize=15&lt;span&gt;)
    plt.ylabel(u&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;数量&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, fontsize=15&lt;span&gt;)
    
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 根据坐标将数字标在图中，ha、va 为对齐方式&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; a, b &lt;span&gt;in&lt;/span&gt;&lt;span&gt; zip(x, y):
        plt.text(a, b&lt;/span&gt;+1, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;%.0f&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; % b, ha=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;center&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, va=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;bottom&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, fontsize=12&lt;span&gt;)
    plt.show()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我们再把学历要求和薪资的数据稍微处理一下变成字典形式，传进绘制好的环状图函数就行了。另外，我们还要对【任职要求】的文本进行可视化。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; wordcloud &lt;span&gt;import&lt;/span&gt;&lt;span&gt; WordCloud
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 绘制词云图&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; draw_wordcloud(content):
    
    wc &lt;/span&gt;=&lt;span&gt; WordCloud(
        font_path &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;c:\\Windows\Fonts\msyh.ttf&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        background_color &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;white&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        max_font_size&lt;/span&gt;=150,  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 字体最大值&lt;/span&gt;
        min_font_size=24,  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 字体最小值&lt;/span&gt;
        random_state=800, &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 随机数&lt;/span&gt;
        collocations=False, &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 避免重复单词&lt;/span&gt;
        width=1600,height=1200,margin=35, &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 图像宽高，字间距&lt;/span&gt;
&lt;span&gt;    )
    wc.generate(content)

    plt.figure(dpi&lt;/span&gt;=160) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 放大或缩小&lt;/span&gt;
    plt.imshow(wc, interpolation=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;catrom&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,vmax=1000&lt;span&gt;)
    plt.axis(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;off&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 隐藏坐标&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;四、成果与总结&lt;/h2&gt;
&lt;p&gt;　　　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1458123/201904/1458123-20190402231238392-1018757486.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　python数据分析师的学历大部分要求是本科，占了86%。&lt;/p&gt;
&lt;p&gt;　　　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1458123/201904/1458123-20190402231330654-1250769002.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　从柱状图可以看出，python数据分析师的工作经验绝大部分要求1-5年。&lt;/p&gt;
&lt;p&gt;　　　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1458123/201904/1458123-20190402231403027-1243117984.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　由此可以得出python数据分析的工资为10k-20k的比较多，40以上的也不少，工资高估计要求会比较高，所以我们看一下职位要求。&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1458123/201904/1458123-20190402231507525-48851779.png&quot; alt=&quot;&quot; width=&quot;731&quot; height=&quot;523&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　从词云图可看出，数据分析肯定要对数据比较敏感，并且对统计学、excel、python、数据挖掘、hadoop等也有一定的要求。不仅如此，还要求具有一定的抗压能力、解决问题的能力、良好的表达能力、思维能力等。&lt;/p&gt;

</description>
<pubDate>Tue, 02 Apr 2019 15:21:00 +0000</pubDate>
<dc:creator>Max_Lyu</dc:creator>
<og:description>上回说到我们如何如何把拉勾的数据抓取下来的，既然获取了数据，就别放着不动，把它拿出来分析一下，看看这些数据里面都包含了什么信息。（本次博客源码地址：https://github.com/MaxLyu/</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lyuzt/p/10643941.html</dc:identifier>
</item>
<item>
<title>《从0开始学架构》——学习笔记（基础篇、高性能篇、高可用篇和可扩展篇） - 姜小泮</title>
<link>http://www.cnblogs.com/jpcflyer/p/10645872.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jpcflyer/p/10645872.html</guid>
<description>&lt;p&gt;&lt;span&gt;       继去年写完&quot;&lt;a href=&quot;https://www.cnblogs.com/jpcflyer/p/9194679.html&quot; target=&quot;_blank&quot;&gt;《从0开始学架构》——学习笔记（基础篇和高性能篇）&lt;/a&gt;&quot;之后，一直忙于项目的开发中，无暇顾及后面的篇章。最近一段时间，忙碌的项目工作已经接近尾声，突然想起来，之前与大家约好的《从0开始学架构》学习笔记的高可用和可扩展篇还未写，于是，这几天整理了一下，把最新的成果给大家分享一下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       请尊重作者劳动成果，转载请标明原文链接：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: 《从0开始学架构》——学习笔记（基础篇和高性能篇）&quot; href=&quot;https://www.cnblogs.com/jpcflyer/p/9194679.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/jpcflyer/p/9194679.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       首先，还是让我们用一张图把精华总结一下吧。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/364723/201904/364723-20190402222409919-2069117525.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/364723/201904/364723-20190402222409919-2069117525.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/364723/201904/364723-20190402222409919-2069117525.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;       然后简单的总结一下：架构设计的核心就是围绕高性能、高可用和可扩展等方面，针对不同的设计复杂度和关键点，进行架构方案的设计和取舍。图中对各方面的基本概念、场景分类和不同架构的优缺点进行了总结，总结的非常全面。大家在看图的时候，一定要结合自己在实际工作的场景分析，哪些场景是否用了各自场景的架构方案，如果没有，那是为什么？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       《从0开始学构架》整体来说面向的是无架构基础的开发人员，概念丰富，而且通俗易懂。但对于经验丰富的开发人员，则本篇的知识还不够深入。后面准备继续深入阅读李智慧的《大型网站技术架构-核心原理与案例分析》，从更深入全面的角度对架构进行分析，让更多的读者能够与我一起学习到架构的乐趣，敬请期待吧。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;       &lt;span&gt;搜索关注微信公众号“程序员姜小白”，获取更新精彩内容哦。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 02 Apr 2019 14:43:00 +0000</pubDate>
<dc:creator>姜小泮</dc:creator>
<og:description>继去年写完&quot;《从0开始学架构》——学习笔记（基础篇和高性能篇）&quot;之后，一直忙于项目的开发中，无暇顾及后面的篇章。最近一段时间，忙碌的项目工作已经接近尾声，突然想起来，之前与大家约好</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jpcflyer/p/10645872.html</dc:identifier>
</item>
<item>
<title>进行API开发选gRPC还是HTTP APIs? - 依乐祝</title>
<link>http://www.cnblogs.com/yilezhu/p/10645804.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yilezhu/p/10645804.html</guid>
<description>&lt;p&gt;上一篇文章我带着大家体验了一把《&lt;a href=&quot;https://www.cnblogs.com/yilezhu/p/10631420.html&quot;&gt;ASP.NET Core 3.0 上的gRPC服务模板初体验(多图)&lt;/a&gt;》，如果有兴趣的可以点击链接进行查看，相信跟着做的你，也是可以跑起来的。这篇文章我们将一起来探讨下gRPC服务如何与HTTP APIs进行比较。用于为应用程序提供API的技术是一个重要的选择，与HTTP API相比，gRPC提供了独特的优势。本文从gRPC的优缺点出发，并推荐了一些建议使用gRPC服务以及不建议使用gRPC服务的场景。&lt;/p&gt;
&lt;blockquote readability=&quot;2.0987654320988&quot;&gt;
&lt;p&gt;作者：依乐祝&lt;br/&gt;原文链接：&lt;a href=&quot;https://www.cnblogs.com/yilezhu/p/10645804.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/yilezhu/p/10645804.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;开始之前先看一下gRPC与带有j'son的HTTP APIs对比表格&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201904/1377250-20190402221115154-1611563738.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;grpc的优势&quot;&gt;gRPC的优势&lt;/h2&gt;
&lt;h3 id=&quot;性能&quot;&gt;性能&lt;/h3&gt;
&lt;p&gt;gRPC消息使用一种有效的二进制消息格式protobuf进行序列化。Protobuf在服务器和客户机上的序列化非常快。Protobuf序列化后的消息体积很小，能够有效负载，在移动应用程序等有限带宽场景中显得很重要。&lt;/p&gt;
&lt;p&gt;gRPC是为HTTP/2而设计的，它是HTTP的一个主要版本，与HTTP 1.x相比具有显著的性能优势：：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;二进制框架和压缩。HTTP/2协议在发送和接收方面都很紧凑和高效。&lt;/li&gt;
&lt;li&gt;通过单个TCP连接复用多个HTTP/2调用。多路复用消除了&lt;a href=&quot;https://en.wikipedia.org/wiki/Head-of-line_blocking&quot;&gt;线头阻塞&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;代码生成&quot;&gt;代码生成&lt;/h3&gt;
&lt;p&gt;所有gRPC框架都为代码生成提供了一流的支持。gRPC开发的核心文件是&lt;code&gt;*.proto&lt;/code&gt;文件 ，它定义了gRPC服务和消息的约定。根据这个文件，gRPC框架将生成服务基类，消息和完整的客户端代码。&lt;/p&gt;
&lt;p&gt;通过在服务器和客户端之间共享&lt;code&gt;*.proto&lt;/code&gt;文件，可以从端到端生成消息和客户端代码。客户端的代码生成消除了客户端和服务器上的重复消息，并为您创建了一个强类型的客户端。无需编写客户端代码，可在具有许多服务的应用程序中节省大量开发时间。&lt;/p&gt;
&lt;h3 id=&quot;严格的规范&quot;&gt;严格的规范&lt;/h3&gt;
&lt;p&gt;不存在具有JSON的HTTP API的正式规范。开发人员不需要讨论URL，HTTP动词和响应代码的最佳格式。（想想，是用Post还是Get好？使用Get还是用Put好？一想到有选择恐惧症的你是不是又开了纠结，然后浪费了大量的时间）&lt;/p&gt;
&lt;p&gt;该&lt;a href=&quot;https://github.com/gRPC/gRPC/blob/master/doc/PROTOCOL-HTTP2.md&quot;&gt;gRPC规范&lt;/a&gt;是规定有关gRPC服务必须遵循的格式。gRPC消除了争论并节省了开发人员的时间，因为gPRC在各个平台和实现之间是一致的。&lt;/p&gt;
&lt;h3 id=&quot;流&quot;&gt;流&lt;/h3&gt;
&lt;p&gt;HTTP/2为长期的实时通信流提供了基础。gRPC通过HTTP/2为流媒体提供一流的支持。&lt;/p&gt;
&lt;p&gt;gRPC服务支持所有流组合：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一元（没有流媒体）&lt;/li&gt;
&lt;li&gt;服务器到客户端流&lt;/li&gt;
&lt;li&gt;客户端到服务器流&lt;/li&gt;
&lt;li&gt;双向流媒体&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;截至时间超时和取消&quot;&gt;截至时间/超时和取消&lt;/h3&gt;
&lt;p&gt;gRPC允许客户端指定他们愿意等待RPC完成的时间。该&lt;a href=&quot;https://gRPC.io/blog/deadlines&quot;&gt;期限&lt;/a&gt;被发送到服务端，服务端可以决定在超出了限期时采取什么行动。例如，服务器可能会在超时时取消正在进行的gRPC / HTTP /数据库请求。&lt;/p&gt;
&lt;p&gt;通过子gRPC调用截至时间和取消操作有助于实施资源使用限制。&lt;/p&gt;
&lt;h2 id=&quot;推荐使用grpc的场景&quot;&gt;推荐使用gRPC的场景&lt;/h2&gt;
&lt;p&gt;gRPC非常适合以下场景：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;微服务&lt;/strong&gt; - gRPC设计为低延迟和高吞吐量通信。gRPC非常适用于效率至关重要的轻型微服务。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;点对点实时通信&lt;/strong&gt; - gRPC对双向流媒体提供出色的支持。gRPC服务可以实时推送消息而无需轮询。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;多语言混合开发环境&lt;/strong&gt; - gRPC工具支持所有流行的开发语言，使gRPC成为多语言开发环境的理想选择。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;网络受限环境&lt;/strong&gt; - 使用Protobuf（一种轻量级消息格式）序列化gRPC消息。gRPC消息始终小于等效的JSON消息。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;grpc的弱点&quot;&gt;gRPC的弱点&lt;/h2&gt;
&lt;h3 id=&quot;浏览器支持有限&quot;&gt;浏览器支持有限&lt;/h3&gt;
&lt;p&gt;当下，不可能直接从浏览器调用gRPC服务。gRPC大量使用HTTP/2功能，没有浏览器提供支持gRPC客户机的Web请求所需的控制级别。例如，浏览器不允许调用者要求使用的HTTP/2，或者提供对底层HTTP/2框架的访问。&lt;/p&gt;
&lt;p&gt;gRPC Web是gRPC团队的一项附加技术，它在浏览器中提供有限的gRPC支持。gRPC Web由两部分组成：支持所有现代浏览器的JavaScript客户端和服务器上的gRPC Web代理。gRPC Web客户端调用代理，代理将在gRPC请求上转发到gRPC服务器。&lt;/p&gt;
&lt;p&gt;gRPC Web并非支持所有gRPC功能。不支持客户端和双向流，并且对服务器流的支持有限。&lt;/p&gt;
&lt;h3 id=&quot;不是人类可读的&quot;&gt;不是人类可读的&lt;/h3&gt;
&lt;p&gt;HTTP API请求以文本形式发送，可以由人读取和创建。&lt;/p&gt;
&lt;p&gt;默认情况下，gRPC消息使用protobuf编码。虽然protobuf的发送和接收效率很高，但它的二进制格式是不可读的。protobuf需要在*.proto文件中指定的消息接口描述才能正确反序列化。需要额外的工具来分析线路上的Protobuf有效负载，并手工编写请求。&lt;/p&gt;
&lt;p&gt;存在诸如服务器反射和gRPC命令行工具等功能，以帮助处理二进制protobuf消息。另外，Protobuf消息支持与JSON之间的转换。内置的JSON转换提供了一种有效的方法，可以在调试时将Protobuf消息转换为可读的形式。&lt;/p&gt;
&lt;h2 id=&quot;不建议使用grpc的场景&quot;&gt;不建议使用gRPC的场景&lt;/h2&gt;
&lt;p&gt;在以下场景中，建议使用其他框架而不是gRPC：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;浏览器可访问的API&lt;/strong&gt; - &lt;strong&gt;浏览器&lt;/strong&gt;不完全支持gRPC。gRPC-Web可以提供浏览器支持，但它有局限性并引入了服务器代理。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;广播实时通信&lt;/strong&gt; - gRPC支持通过流媒体进行实时通信，但不存在向已注册连接广播消息的概念。例如，在应该将新聊天消息发送到聊天室中的所有客户端的聊天室场景中，需要每个gRPC呼叫以单独地将新的聊天消息流传输到客户端。对于这种场景，&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/signalr/introduction?view=aspnetcore-3.0&quot;&gt;SignalR&lt;/a&gt;是这种情况的有用框架。SignalR具有持久连接的概念和对广播消息的内置支持。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;进程间通信&lt;/strong&gt; - 进程必须承载HTTP/2服务才能接受传入的gRPC调用。对于Windows，进程间通信&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/standard/io/pipe-operations&quot;&gt;管道&lt;/a&gt;是一种快速，轻量级的通信方法。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;继上一篇介绍了《&lt;a href=&quot;https://www.cnblogs.com/yilezhu/p/10631420.html&quot;&gt;ASP.NET Core 3.0 上的gRPC服务模板初体验(多图)&lt;/a&gt;》后，我们又一起来探讨了一下gRPC服务的优缺点并给出了gRPC的一些使用场景以及非适用场景，希望对大家的使用有所帮助。最后感谢大家的阅读。另外，文中大多内容来自于https://docs.microsoft.com/en-us/aspnet/core/gRPC/comparison?view=aspnetcore-3.0 有兴趣的小伙伴可以阅读原文进行查看。&lt;/p&gt;
</description>
<pubDate>Tue, 02 Apr 2019 14:32:00 +0000</pubDate>
<dc:creator>依乐祝</dc:creator>
<og:description>上一篇文章我带着大家体验了一把《 'ASP.NET Core 3.0 上的gRPC服务模板初体验(多图)' 》，如果有兴趣的可以点击链接进行查看，相信跟着做的你，也是可以跑起来的。这篇文章我们将一起来</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yilezhu/p/10645804.html</dc:identifier>
</item>
<item>
<title>xamarin.forms之使用CarouselView插件模仿网易新闻导航 - 社会主义接班人</title>
<link>http://www.cnblogs.com/5ishare/p/10645766.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/5ishare/p/10645766.html</guid>
<description>&lt;p&gt;在APP中基本都能见到类似网易、今日头条等上边横向导航条，下边是左右滑动的页面，之前做iOS的时候模仿实现过，https://github.com/ywcui/ViewPagerndicator，在做xamarin.forms的时候看到xamarin.form自带的有左右滑动的CarouselPage和CarouselView，想着实现今日头条导航会容易些，当自己尝试实现的时候发现CarouselPage页面无法设置顶部导航的部分，子控件需要是page，CarouselView可以设置顶部导航部分但左右滑动没有找到触发的事件，这个问题在开始做APP的时候就一直在思考。今天下午和小伙伴讨论这个功能时临时起意尝试使用第三方插件CarouselView.FormsPlugin来实现，这个插件之前也尝试用过，不过当时没解决，经过小伙伴一提醒没想到实现了，这里记录一下实现方法。&lt;/p&gt;
&lt;p&gt;一、Nuget引入第三方&lt;/p&gt;
&lt;p&gt;这里使用了第三方的插件CarouselView.FormsPlugin(&lt;a href=&quot;https://github.com/alexrainman/CarouselView&quot;&gt;https://github.com/alexrainman/CarouselView&lt;/a&gt;)和面包屑Toast，CarouselView.FormsPlugin主要是实现左右滑动视图，Toast面包屑主要是用来显示当前视图的索引。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733213/201904/733213-20190402211826023-716992837.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;二、使用CarouselView.FormsPlugin&lt;/p&gt;
&lt;p&gt;这个插件直接也了解过，当时直接把github上的demo下载下来，尝试复制粘贴完事，可demo上没有，这就尴尬了，想复制粘贴没有。今天和小伙伴讨论之后又打开github详细查看了下使用说明，找到下面这句话和demo，于是就动手尝试了下CarouselView设置不同的Views。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733213/201904/733213-20190402211916167-665965971.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1.安卓项目引入CarouselView.FormsPlugin&lt;/p&gt;
&lt;p&gt;只需通过nuget上引入并在MainActivity.cs中如下代码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;global&lt;/span&gt;::Xamarin.Forms.Forms.Init(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, savedInstanceState);
            CarouselViewRenderer.Init();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.在page页面使用CarouselView.FormsPlugin&lt;/p&gt;
&lt;p&gt;这里在xamarin.forms的MainPage中引入使用，需要在页面的ContentPage节点设置属性。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
xmlns:controls=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;clr-namespace:CarouselView.FormsPlugin.Abstractions;assembly=CarouselView.FormsPlugin.Abstractions&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后使用起来也比较简单，直接设置CarouselViewControl即可，然后在cs类中设置它的ItemsSource。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; encoding=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ?&amp;gt;
&amp;lt;ContentPage xmlns=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://xamarin.com/schemas/2014/forms&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
             xmlns:x&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://schemas.microsoft.com/winfx/2009/xaml&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
             xmlns:local&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;clr-namespace:ViewPagerndicator&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
             x:Class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ViewPagerndicator.MainPage&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
             xmlns:controls&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;clr-namespace:CarouselView.FormsPlugin.Abstractions;assembly=CarouselView.FormsPlugin.Abstractions&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
             &amp;gt;
    &amp;lt;StackLayout&amp;gt;
        &amp;lt;StackLayout Orientation=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Horizontal&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Padding=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Margin=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
            &amp;lt;Button Margin=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Padding=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Clicked=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BtnDemo_Clicked&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Text=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;推荐&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; FontSize=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/Button&amp;gt;
            &amp;lt;Button Margin=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Padding=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Clicked=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BtnDemo_Clicked&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Text=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;热点&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; FontSize=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/Button&amp;gt;
            &amp;lt;Button Margin=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Padding=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Clicked=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BtnDemo_Clicked&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Text=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;抖音&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; FontSize=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/Button&amp;gt;
            &amp;lt;Button Margin=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Padding=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Clicked=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BtnDemo_Clicked&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Text=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;国内&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; FontSize=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/Button&amp;gt;
        &amp;lt;/StackLayout&amp;gt;
        &amp;lt;controls:CarouselViewControl Position=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; x:Name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;carouselView&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;  VerticalOptions=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;FillAndExpand&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; HorizontalOptions=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;FillAndExpand&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;
    &amp;lt;/StackLayout&amp;gt;
&amp;lt;/ContentPage&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;CarouselViewControl有PositionSelected事件，在事件中可以获取到当前页面的索引，这里使用Toast将索引值弹出。同时又设置了几个按钮来模拟横向导航栏的点击事件。而在点击按钮时也可以设置CarouselViewControl的Position改变视图。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Plugin.Toast;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Xamarin.Forms;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; ViewPagerndicator
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;partial&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MainPage : ContentPage
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; MainPage()
        {
            InitializeComponent();
            carouselView.ItemsSource &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; List&amp;lt;DataTemplate&amp;gt;&lt;span&gt;(){
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; DataTemplate(() =&amp;gt; { &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PageA().Content; }),
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; DataTemplate(() =&amp;gt; { &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PageB().Content; }),
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; DataTemplate(() =&amp;gt; { &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PageC().Content; }),
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; DataTemplate(() =&amp;gt; { &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PageC().Content; })
            };
            carouselView.PositionSelected &lt;/span&gt;+=&lt;span&gt; CarouselView_PositionSelected;
        }
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; CarouselView_PositionSelected(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, CarouselView.FormsPlugin.Abstractions.PositionSelectedEventArgs e)
        {
            CrossToastPopUp.Current.ShowToastSuccess(e.NewValue.ToString());
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BtnDemo_Clicked(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e)
        {
            Button btn &lt;/span&gt;=&lt;span&gt; (Button)sender;
            List&lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; arr = &lt;span&gt;new&lt;/span&gt; List&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;推荐&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;热点&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;抖音&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;国内&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; index = arr.ToList&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;().LastIndexOf(btn.Text);
            carouselView.Position &lt;/span&gt;=&lt;span&gt; index;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为了测试导航栏部分是否影响page页面渲染，这里在app类中还加了导航栏。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
MainPage =&lt;span&gt;new&lt;/span&gt; NavigationPage( &lt;span&gt;new&lt;/span&gt; MainPage());
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;三、测试&lt;/p&gt;
&lt;p&gt;这里先贴几个页面，当页面左右滑动时会弹出当前页面的索引值，顶部按钮点击时下面的页面也会联动。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733213/201904/733213-20190402214043295-483023258.png&quot; alt=&quot;&quot; width=&quot;347&quot; height=&quot;528&quot;/&gt;&lt;/p&gt;
&lt;p&gt;四、优化&lt;/p&gt;
&lt;p&gt;目前只是实现了底部页面左右滑动以及顶部按钮点击切换页面，还有需要优化的地方，和人一样，需要不断优化，改掉缺点，补足短板。后续可以把顶部导航的使用横向列表来实现，这样就可以左右滑动，动态配置参数。这个功能实现之后好几个页面都能实现了，甚至自己都可以爬虫不同新闻客户端的内容，实现新闻聚合。&lt;/p&gt;
&lt;p&gt;五、瞎扯淡&lt;/p&gt;
&lt;p&gt;最近俺们村里的微信群都已经有使用区块链的热点来拉投资的了，而且33天就能回本，忽悠手段日益更新。目前在创业公司，自己也快三十而立，最近也一直在思考创业的事情，假如未来创业我需要在这几年做哪些准备，方向是什么，to be or not to be，that's a question。快清明放假了，也给大家分享一个很有前景的创业项目，而且支付宝的技术人员十几年都未解决的技术难题，现在都是无现金社会了，就是清明节烧纸钱能否也实现无现金转账，就是不知道怎么转过去，收款人账户是多少。&lt;/p&gt;

</description>
<pubDate>Tue, 02 Apr 2019 14:06:00 +0000</pubDate>
<dc:creator>社会主义接班人</dc:creator>
<og:description>在APP中基本都能见到类似网易、今日头条等上边横向导航条，下边是左右滑动的页面，之前做iOS的时候模仿实现过，https://github.com/ywcui/ViewPagerndicator，在做</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/5ishare/p/10645766.html</dc:identifier>
</item>
<item>
<title>headfirst设计模式（9）—模板方法模式 - 纷飞丶</title>
<link>http://www.cnblogs.com/skyseavae/p/10633729.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/skyseavae/p/10633729.html</guid>
<description>&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;这一章的模板方法模式，个人感觉它是一个简单，并且实用的设计模式，先说说它的定义：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;模板方法模式定义了一个算法的步骤，并允许子类别为一个或多个步骤提供其实践方式。让子类别在不改变算法架构的情况下，重新定义算法中的某些步骤&lt;/strong&gt;&lt;span&gt;。（百度百科）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;额， 这段定义呢，如果说我在不了解这个设计模式的时候，我看着反正是云里雾里的，毕竟定义嘛，就是用一堆看不懂的名词把一个看不懂的名词描述出来，但是学了这个设计模式，反过来看，又会觉得它的定义很正确。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;模板方法模式的关键点有3个：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;1，有一个由多个步骤构成的方法（模板方法）&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;2，子类可以自行实现其中的一个或多个步骤（模板方法中的步骤）&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;3，架构允许的情况下，子类可以重新定义某些步骤&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;话说，这不就是上面那段话吗？列成3点以后咋感觉越看越玄了呢？难道这就是传说中的玄学编程？&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;列出来的目的是，后面的例子里面会依次讲到这3点，话不多说，代码在idea里面已经蓄势待发！&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;模板方法模式基本实现&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;1，故事背景&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;在实现之前呢，需要有一个历史背景，不然不知道来龙去脉，容易印象不深刻，headfirst里面是这样的一个例子：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;在一个店里面，有2种饮料，它们的冲泡步骤是这样的：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;1，咖啡：把水煮沸，用沸水冲泡咖啡，倒进杯子，加糖和牛奶&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;2，茶：把水煮沸，用沸水浸泡茶叶，倒进杯子，加柠檬&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;当然，本着没有专业的自动化酿造技术的咖啡店不是一个好的科技公司，这段逻辑当然得用代码来实现了啊，然后就进入大家最喜欢的贴代码环节：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 咖啡
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Coffee {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 准备
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; prepare() {
        boilWater();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把水煮沸&lt;/span&gt;
        brewCoffeeGrinds();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;冲泡咖啡&lt;/span&gt;
        pourInCup();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;倒进杯子&lt;/span&gt;
        addSugarAndMilk();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加糖和牛奶&lt;/span&gt;
&lt;span&gt;    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 把水煮沸
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; boilWater() {
        System.out.println(&lt;/span&gt;&quot;把水煮沸&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 冲泡咖啡
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; brewCoffeeGrinds() {
        System.out.println(&lt;/span&gt;&quot;用沸水冲泡咖啡&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 倒进杯子
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; pourInCup() {
        System.out.println(&lt;/span&gt;&quot;倒进杯子&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 添加糖和牛奶
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addSugarAndMilk() {
        System.out.println(&lt;/span&gt;&quot;添加糖和牛奶&quot;&lt;span&gt;);
    }
}

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 茶
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Tea {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 准备
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; prepare() {
        boilWater();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把水煮沸&lt;/span&gt;
        steepTeaBag();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;泡茶&lt;/span&gt;
        pourInCup();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;倒进杯子&lt;/span&gt;
        addLemon();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加柠檬&lt;/span&gt;
&lt;span&gt;    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 把水煮沸
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; boilWater() {
        System.out.println(&lt;/span&gt;&quot;把水煮沸&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 泡茶
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; steepTeaBag() {
        System.out.println(&lt;/span&gt;&quot;用沸水浸泡茶叶&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 倒进杯子
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; pourInCup() {
        System.out.println(&lt;/span&gt;&quot;倒进杯子&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 加柠檬
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addLemon() {
        System.out.println(&lt;/span&gt;&quot;添加柠檬&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;上面贴了咖啡和茶的实现，对外提供的public方法是prepare()方法，其他的内部方法，都是private（不需要的方法不要提供出去，外面的世界锅太多，它们还小，经不住那么多的打击），按道理来说，上面两段代码，思路清晰，注释完整，代码整洁。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;但是，boilWater()，pourInCup()两个方法，其实内容是一模一样的，对于一个程序来说，有2段一模一样的代码的时候，就应该思考，是不是有什么地方不对。因为，有2段就表示要改2个同样的地方，有10段，就要改10个同样的地方，System.out.println()当然能改啊。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;逻辑一多咋办？逻辑一多当然也能改啊，毕竟总所周知，程序员是只需要3个键(Ctrl，C，V)就能正常工作的。但是，还有键盘在别人手上啊，他们写在什么地方的知道不？&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;2，逻辑抽象第一版&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;逻辑上来说，这个地方就会被抽象出一个公共类：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 咖啡因的饮料(将烧水和倒进杯子两个方法抽象出来)
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CaffeineBeverage {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; prepare();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;子类必须要有一个准备饮料的方法&lt;/span&gt;

    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 把水煮沸
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; boilWater() {
        System.out.println(&lt;/span&gt;&quot;把水煮沸&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 倒进杯子
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; pourInCup() {
        System.out.println(&lt;/span&gt;&quot;倒进杯子&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;咖啡和茶的实现就会变成下面这样：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 咖啡
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Coffee &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; CaffeineBeverage{

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 准备
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; prepare() {
        boilWater();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把水煮沸&lt;/span&gt;
        brewCoffeeGrinds();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;冲泡咖啡&lt;/span&gt;
        pourInCup();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;倒进杯子&lt;/span&gt;
        addSugarAndMilk();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加糖和牛奶&lt;/span&gt;
&lt;span&gt;    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 冲泡咖啡
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; brewCoffeeGrinds() {
        System.out.println(&lt;/span&gt;&quot;用沸水冲泡咖啡&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 添加糖和牛奶
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addSugarAndMilk() {
        System.out.println(&lt;/span&gt;&quot;添加糖和牛奶&quot;&lt;span&gt;);
    }
}

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 茶
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Tea &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; CaffeineBeverage{

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 准备
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; prepare() {
        boilWater();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把水煮沸&lt;/span&gt;
        steepTeaBag();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;泡茶&lt;/span&gt;
        pourInCup();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;倒进杯子&lt;/span&gt;
        addLemon();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加柠檬&lt;/span&gt;
&lt;span&gt;    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 泡茶
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; steepTeaBag() {
        System.out.println(&lt;/span&gt;&quot;用沸水浸泡茶叶&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 加柠檬
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addLemon() {
        System.out.println(&lt;/span&gt;&quot;添加柠檬&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;一般来说，实际业务中，抽象到这个地方，已经比复制粘贴的时候好很多了。但是，很多时候，不能只看表面，还需要总结更加深层次的东西，让业务的实现变得更加简单。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;比如在这个例子中，prepare()方法中的步骤还可以总结，抽象。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;原来的冲泡步骤：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;1，咖啡：把水煮沸，用沸水冲泡咖啡，倒进杯子，加糖和牛奶&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;2，茶：把水煮沸，用沸水浸泡茶叶，倒进杯子，加柠檬&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;抽象后：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;咖啡/茶：把水煮沸，用沸水 【冲泡咖啡/浸泡茶叶】，倒进杯子，加 【糖和牛奶/柠檬】&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;第2步和第4步，还可以抽象成，冲泡，加调味品&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;3，模板方法模式抽象&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;那么抽象类的代码就会变成这样：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 咖啡因的饮料(模板方法模式)
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CaffeineBeverage {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 准备（构造成final方法，防止子类重写算法）
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; prepare() {
        boilWater();
        brew();
        pourInCup();
        addCondiments();
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 冲泡
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; brew();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 添加调料
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addCondiments();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 把水煮沸
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; boilWater() {
        System.out.println(&lt;/span&gt;&quot;把水煮沸&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 倒进杯子
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; pourInCup() {
        System.out.println(&lt;/span&gt;&quot;倒进杯子&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;咖啡和茶的实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 咖啡
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Coffee &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; CaffeineBeverage {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 冲泡咖啡
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; brew() {
        System.out.println(&lt;/span&gt;&quot;用沸水冲泡咖啡&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 添加糖和牛奶
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addCondiments() {
        System.out.println(&lt;/span&gt;&quot;添加糖和牛奶&quot;&lt;span&gt;);
    }
}

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 茶
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Tea &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; CaffeineBeverage {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 泡茶
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; brew() {
        System.out.println(&lt;/span&gt;&quot;用沸水浸泡茶叶&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 加柠檬
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addCondiments() {
        System.out.println(&lt;/span&gt;&quot;添加柠檬&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 测试类
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {
 
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Tea tea &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Tea();
        Coffee coffee &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Coffee();
        System.out.println(&lt;/span&gt;&quot;泡茶...&quot;&lt;span&gt;);
        tea.prepare();
        System.out.println(&lt;/span&gt;&quot;冲咖啡...&quot;&lt;span&gt;);
        coffee.prepare();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试结果：&lt;/p&gt;
&lt;pre class=&quot;md-fences md-end-block ty-contain-cm modeLoaded&quot;&gt;
&lt;span&gt;泡茶...&lt;br/&gt;&lt;span&gt;把水煮沸&lt;br/&gt;&lt;span&gt;用沸水浸泡茶叶&lt;br/&gt;&lt;span&gt;倒进杯子&lt;br/&gt;&lt;span&gt;添加柠檬&lt;br/&gt;&lt;span&gt;冲咖啡...&lt;br/&gt;&lt;span&gt;把水煮沸&lt;br/&gt;&lt;span&gt;用沸水冲泡咖啡&lt;br/&gt;&lt;span&gt;倒进杯子&lt;br/&gt;&lt;span&gt;添加糖和牛奶&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;这个就是一个模板方法模式比较通用的一个实现了，中间就有模板方法模式的2个要点：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;（1），有一个由多个步骤构成的方法，这里就是prepare()，由4个步骤构成的一个模板方法&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;（2），子类可以自行实现其中的一个或多个步骤，咖啡和茶分别都实现了brew()，addCondiments()&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;其实到这个地方呢，模板方法模式的一般逻辑就大概讲完了，一般来说，实现也就是上面的那个样子，但是，还是有很多时候，会出现各种各样的其他实现方式，毕竟抽象这个东西，对于不同的业务，不同的逻辑，那简直就是多种多样，只要不违背设计原则，简单易用，那么总会有意识无意识的用到模板方法模式。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;接下来就介绍几种常见的操作。&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;模板方法模式的常见操作&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;1，空实现&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;比如说，在把水煮沸前有一个前置步骤，有的饮料需要，但是有的饮料不需要，那么就可以在模板方法里面，给它留一个位置，让子类去选择性的覆盖实现&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 咖啡因的饮料(模板方法模式，空实现)
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CaffeineBeverage {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 准备（构造成final方法，防止子类重写算法）
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; prepare() {
        beforeBoilWater();
        boilWater();
        brew();
        pourInCup();
        addCondiments();
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 烧水前置操作
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; beforeBoilWater(){

    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;其他方法省略...&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;2，默认实现&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;比如说，加调味品这个步骤其实是可选的，加不加调味品，每种饮料加不加调味品，模板方法可以交给子类自己去控制。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 咖啡因的饮料(模板方法模式，默认实现)
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CaffeineBeverage {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 准备（构造成final方法，防止子类重写算法）
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; prepare() {
        boilWater();
        brew();
        pourInCup();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(needCondiments()){
            addCondiments();
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 是否需要调味品
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; needCondiments(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;其他方法省略...&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;这既是模板方法模式的第3个要点，&lt;span&gt;&lt;strong&gt;架构允许&lt;/strong&gt;&lt;span&gt;的情况下，子类可以重新定义某些步骤，只要模板方法可以定义添加或者移除某个，某些步骤，那么子类就可以根据自己的实际情况来选择实现整个方法的逻辑步骤。这个也就是这个设计模式中常说的一种叫钩子方法。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;模板方法模式，其实就是，在抽象类中定义一个操作中的算法的步骤，而将一些步骤的实现延迟到子类中。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;这里有一个建议是，尽量在抽象的时候，保证仅存在父类的方法去调用子类的方法，而不要同时存在子类的方法去调用父类的方法。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;个人觉得，这样做的原因有几点：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;1，贯彻这个建议后，整个逻辑会显得很简单易懂，反正没有实现的，在子类就能找到实现&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;2，相互依赖调来调去的后果就是在系统越来越复杂以后，最后就没人能看懂了&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;3，防止抽象类的方法变动引起子类的改动，这个其实不算原因，因为一般来说，抽象类是比较稳定的，而且，子类可以调的抽象类方法在修改时肯定要考量子类的，不允许子类调用的方法肯定都处理过了，一般肯定是调不到的（诶，反射你凑过来干嘛？）&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;strong&gt;最后的最后，总结一下模板方法模式的优缺点吧&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;优点：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;1，代码复用便于维护，子类可扩展&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;2，行为由父类控制，子类只需要关心自己所需要的步骤即可，开发难度低&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;缺点：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;1，每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;所以，如果发现子类很多，是不是要想想是不是设计模式用错了，去隔壁找找其他的设计模式吧&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 02 Apr 2019 13:42:00 +0000</pubDate>
<dc:creator>纷飞丶</dc:creator>
<og:description>前言 这一章的模板方法模式，个人感觉它是一个简单，并且实用的设计模式，先说说它的定义： 模板方法模式定义了一个算法的步骤，并允许子类别为一个或多个步骤提供其实践方式。让子类别在不改变算法架构的情况下，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/skyseavae/p/10633729.html</dc:identifier>
</item>
<item>
<title>老兵的十年职场之路(二) - 美码师</title>
<link>http://www.cnblogs.com/littleatp/p/10645408.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/littleatp/p/10645408.html</guid>
<description>&lt;p&gt;在上一篇文章&lt;a href=&quot;https://www.cnblogs.com/littleatp/p/10587932.html&quot;&gt;老兵的十年职场之路(一)&lt;/a&gt; 里头，讲述了我在初入职场时的一些经历，从自己个人的感受来说并不是特别的美好，既没有职位上的屌丝逆袭、也没有令人兴奋的意外成长，但也许这也是很多人所经历过的，毕竟我们都是&quot;平凡&quot;的人，一旦平凡就只能是&lt;strong&gt;&quot;抱着不平凡的梦中度过这平凡的一生&quot;&lt;/strong&gt;...&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201904/242916-20190402211246571-1825247857.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么，在接下来的这段职业中，我又经历了什么？相比第一段经历，会有什么样的波澜起伏？ 下面让我一一道来...&lt;/p&gt;
&lt;p&gt;第二家公司，是慕名而去的，之所以这么说，主要还是平时里头同事聊天时听来的。&lt;br/&gt;那时候的微博、微信都还在襁褓之中，我们所能获取信息的手段其实很有限，除了百度和上目标企业的官网上看看介绍之外，更多的就是街头巷闻。&lt;br/&gt;当然，这家企业在移动互联网领域的扩张非常快，连我原来公司的老板都会拿来给我们当做学习的榜样...&lt;br/&gt;真是不错，直到后面离职时我也毫不避讳的告知了他我的选择，然后是除了祝福的话之外，恍惚中仿佛看到了一丝黯淡。&lt;/p&gt;
&lt;h3 id=&quot;别具一格的面试&quot;&gt;别具一格的面试&lt;/h3&gt;
&lt;p&gt;记得是在清明节过两天之后，我第一次去到新公司面试，除了前台MM很热情之外，还有就是对那办公室布满的公仔和亮堂的灯光令我印象深刻。&lt;br/&gt;相比之前所在的死气沉沉的写字楼，感官上的差异非常的大。&lt;br/&gt;面试我的是一个穿着沙滩花裤的&quot;年轻人“，一上来也没有问我什么，更多的是唠一些工作经历。&lt;br/&gt;中间我觉得无趣，多问了一句：听说这里牛人很多，是真的吗？&lt;br/&gt;他笑了笑，故作镇静的说道：我们都是&quot;普通&quot;人而已...&lt;br/&gt;冷场十秒钟后，又唠了一些兴趣爱好，然后是聊到陈奕迅的歌，我随兴唱了一小段之后，大家都满意的结束了面试。&lt;/p&gt;
&lt;p&gt;之后，我一直觉得比较忐忑，这样的面试是不是不大合适？但最终反正是通过了(花裤男是那部门的老大)，&lt;br/&gt;后来给我的体会就是有些事情不能老按常理去揣测。&lt;/p&gt;
&lt;h3 id=&quot;新气象&quot;&gt;新气象&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201904/242916-20190402211309202-1949311950.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;入职之后，自然是很多新气象，有许多东西都是第一次接触，由于我的求知欲盖过了压力，所以那段时光只是一味感觉到轻松且愉快的。&lt;br/&gt;成长期的互联网公司充满了开放和创新的气氛，这话不假。也就是到了这里才知道原来除了Java 和 ssh 三大框架之外，还有那么多人在使用其他的编程技术比如 Php 的 Lamp，Python 等等，数据库除了Oracle 之外，还有那么多人在用 MySQL.Memcache 这些开源的数据库中间件，而之前还曾天真的认为数据库是 Oracle 等商业数据库的天下，MySQL 只是学生才用的玩意，真觉得自己像个井底之蛙。&lt;/p&gt;
&lt;p&gt;所有的这些现象大概已经告示了公司的技术流派：&lt;strong&gt;拥抱开源！&lt;/strong&gt;&lt;br/&gt;没错，一切都是用的开源技术，这也包括了部门在使用的各种协同系统，基本上都是免费的开源系统搭建出来的，所以长的千奇百怪的不足为奇。&lt;br/&gt;但是开源协同系统的弊端也很明显，除了长的丑之外，bug 也很多，要修复就得吃透整个项目的源码，后来管事的觉得这样下去不是办法，于是启动了一个的内部协同系统项目(基于Java开发)，希望把这些千奇百怪的开源系统给替换了。&lt;br/&gt;这里为什么会提到新协同系统？因为当时我一开始是参与了这个项目的，但只是由于项目比较乏味，基本上就是用的 ssh 那一套，于是我很快就申请转岗去干了别的…&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编程语言之争&lt;/strong&gt;&lt;br/&gt;前面提到编程语言的多样性，的确，互联网项目习惯于野蛮式的生长，基本上也都是用自己最熟悉的。于是在项目变多了以后这却成了一件棘手的事情，比如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;人力资源难以调动，比如让做 php 的去写c++不合适&lt;/li&gt;
&lt;li&gt;代码质量参差不齐，一种语言就需要一套规范，而有些语言也很难找到规范&lt;/li&gt;
&lt;li&gt;新人培养上成本太高，甚至很多人并不是很想尝试太多新的东西&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;于是乎，就有了各种关于编程语言的讨论，到底要采用哪个作为主流的技术，当时在内部社群也争论的很激烈，貌似最后也是没什么结果（编程语言之争一直就没停歇过），到后来从项目技术的覆盖面上看，Java 是占了绝大优势的。&lt;/p&gt;
&lt;p&gt;我一开始所在的小组大多是 Java 技术老鸟，老丁是队里的老专家，在每次代码评审后也总会这么说：&lt;br/&gt;&quot;这点代码怎么会写不好阿，Java 简单阿，无非就是些增删改查嘛！&quot;&lt;br/&gt;从当时的项目看也的确如此，对于协同系统更多的就是理解好业务流程，定义好实体类，然后一通增删改查…&lt;br/&gt;然后是&lt;strong&gt;过了一年后，我从内心里就完全推翻了这个想法。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;修罗战场&quot;&gt;修罗战场&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201904/242916-20190402211333993-571295317.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为对手头上工作没有半点兴趣，没过多久后我就申请到了一个新部门，主要做社区类的平台产品，而后者是就是所谓的自负盈亏部门，&lt;br/&gt;这里除了程序员之外，还有产品经理，运营妹子，运维大汉…传说中的鄙视链现象也时不时在这里出现，只是程序员和产品的关系似乎没那么糟糕，这可能跟产品团队都是妹子有极大关系，现在想想当时的人力资源团队还是很有智慧的。&lt;/p&gt;
&lt;p&gt;在新项目中，我遇到了许多未曾遇到的挑战，也就是在这里个人的技术视野和能力都快速的提升了。所谓屁股决定脑袋不是没有道理的，当你做的事情让你感到自己像个小白时，你才能拥有巨大的提升空间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;项目的挑战&lt;/strong&gt;&lt;br/&gt;社区平台是一套的 Php 代码实现的，一开始呢功能很简单，但经过一年半的演进已经变得臃肿不堪。而随着运营同学的努力，用户量也达到了几千万，整个系统开发维护效率极为低下，很容易动一发则牵动全身。另外一旦到了业务高峰期总会时不时的出现一些性能问题。&lt;br/&gt;好了，这是系统的背景，接下来的事情就是&lt;strong&gt;重构！把一个庞然大物变成许多只小飞象！&lt;/strong&gt;&lt;br/&gt;这里听着有点像是服务拆分的意思，但那会没有微服务的概念，就是做成分布式系统，一些原则和理念跟现在的微服务理念也基本是一样的，诸如服务发现 隔离，业务降级，关注性能...&lt;br/&gt;当时技术选型方面用的是Java ，Web 通信框架则是由开源项目改造而来的，底层是封装了Netty 用来实现 NIO高性能吞吐，然后是基于业务的特性实现了一套应用层的分库分表框架，这主要是用来支持 MySQL 的水平扩展。除此之外，为进一步提高性能，框架也集成了开箱即用的缓存能力(对接Redis集群)，这样的配合基本上已经做到极致了，于是后来这套技术组合也逐渐统一了大大小小的项目。&lt;br/&gt;由于Java 掌握能力上的优势以及自身的求知欲，我很快就把这套框架的源码给摸透了，当然这些实现并没有包括之前用的 ssh 框架，这是一个非常轻量级的开发栈，风格上更像是Ruby on rails。里面抛弃了许多 J2EE 的东西，对 Restful 的支持非常好，而且在当时Restful也是许多大平台的首选，比如新浪微博开放接口...总之用起来是非常清爽的。&lt;br/&gt;然后说因为对技术框架比较熟练，于是会经常帮同事解决一些问题，慢慢的就成了项目骨干。再后来就是陆陆续续负责一些核心业务的开发，重大问题攻关以及做一些框架规范化管理类的东西。&lt;/p&gt;
&lt;p&gt;这里说到规范，不得不提关于代码注释的事情，团队&lt;strong&gt;在注释的要求上是非常严格的&lt;/strong&gt;。大家基本上都认同的一点是：&lt;br/&gt;&quot;自解释代码根本不存在！所以不要因为觉得代码写的好就可以不写注释！&quot;&lt;br/&gt;超哥是同事里的老专家，写了十多年代码仍然能坚持把注释做到极致的清晰，足见对于工作严谨的态度。&lt;/p&gt;
&lt;h3 id=&quot;影响深刻的事情&quot;&gt;影响深刻的事情&lt;/h3&gt;
&lt;p&gt;在一段快速成长的经历里面，必然会有那么几个时刻，让人始终记忆犹新。&lt;/p&gt;
&lt;h4 id=&quot;a.-怎么样都写不好的文档&quot;&gt;A. 怎么样都写不好的文档&lt;/h4&gt;
&lt;p&gt;有一次主管让我为一个自动化框架编写一个用户手册，我不以，花了一上午加一个小时给整好了。发到工作群里后被一阵痛批：&lt;br/&gt;“这是给别人看到还是你自己看的？“&lt;br/&gt;“Api请求头说明到哪去啦？“&lt;br/&gt;“把全部错误码放到一个表格不好吗？“&lt;br/&gt;...&lt;br/&gt;也就是从那件事之后，我开始认真对待我的每一篇文档博客，直到有一天，某位大师跟我讲：&lt;br/&gt;“嘿，我觉得你小伙子不错！”&lt;br/&gt;“为啥？“&lt;br/&gt;“因为我看过你的文章！“&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201904/242916-20190402211408917-1332325522.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;b.-突如其来的救火&quot;&gt;B. 突如其来的救火&lt;/h4&gt;
&lt;p&gt;有一次系统上线了一个紧急补丁，结果由于并发性能问题直接导致系统局部宕机，我在快速攻关后定位到了根因。在问题重现到代码修复足足花费了两个小时。这时已经超过了维护时间窗口，如果再进行测试时间将导致问题出现一再延迟，更严重单事情就是用户流失。&lt;br/&gt;记得那会大家都非常焦急的时候，一直很平静的主管突然对我吼了一句：&quot;能不能保证质量！&quot;&lt;br/&gt;他的音量很大以至于周围的人都惊诧了，然后是我硬着头皮说 &quot;能...&quot;（当时也只好这么说...）于是在没有测试的情况下有惊无险的上线了新补丁。&lt;/p&gt;
&lt;p&gt;“工作就是打仗，互联网行业里用户为王，用户就是上帝”&lt;br/&gt;这是我所得到的体会。&lt;/p&gt;
&lt;h4 id=&quot;c.-群猿的通宵夜&quot;&gt;C. 群猿的通宵夜&lt;/h4&gt;
&lt;p&gt;一次平台的重大升级变更中，我们团队和运维的大汉兄弟们进行了紧密的协作。因为版本变更太大属于架构级别的变化，所以大家都是不敢懈怠的，运维和开发的两两配对，每一步的操作都要另一个人二次确认。&lt;br/&gt;尽管如此，期间还是问题不断，比如脏缓存问题，dns出错等等，整个变更和保障花了整48小时，吃睡也都在小黑屋..&lt;br/&gt;可以想象当时空气中弥漫的那种宿醉的异味。&lt;br/&gt;当然这些异味不是重点，而是，在完成升级之后的凌晨，产品经理和运营经理都来找我们质问，&lt;br/&gt;&quot;为什么系统中断了半个小时，不是说好平滑的吗...&quot;&lt;/p&gt;
&lt;p&gt;你所认为的很值得骄傲的事情，在别人看来可能不屑一提，因为大家的想要的东西并不一样。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201904/242916-20190402211442135-418491895.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;其他的事&quot;&gt;其他的事&lt;/h2&gt;
&lt;p&gt;如果读过我的一篇文章的朋友可能还记得，在我第一家公司里头发生了许多八卦的事情。然而在这里，我几乎一点花边新闻没有收到，为什么？原因可能有这么几点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;公司处于快速的上升调整期，高管似乎都把心思放在了事业上面&lt;/li&gt;
&lt;li&gt;身边的同事，包括我都扎进技术里头了，对这类事情并不关注&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;唯一会听到的小道消息可能就是诸如某某跳槽去了某游戏公司，薪资翻倍什么的之类，但是听多了会懂得这个就是常态的东西。&lt;br/&gt;而更多的时间里就是大家都在为项目或是自我提升而持续的奋斗着。记得当时的主管讲过一句话：&lt;br/&gt;&quot;最恐怖的是，比你牛的人比你还要努力！&quot;&lt;br/&gt;这话一点没错的，团队呈现出来的特点只有努力两个字了。同事里不乏能力强又谦逊的，有些至今已成为了业界里有影响力的技术专家。&lt;/p&gt;
&lt;p&gt;总体来说，我算是在一个比较好的时期加入了这家公司，在团队规模上恰到好处。同时管理层是技术出身，其对于开放，创新文化非常的重视。&lt;br/&gt;所以，很重要的一点是，很少会碰到如大企业各种繁杂的流程，勾心斗角之类的事情。&lt;br/&gt;公司是移动互联网领域的佼佼者，我所在的两年半里规模扩张了一倍不止，在阿里收购之际，我也离开了公司。顺带还拿到了一点期权回购的钱，尽管那点钱其实很少，但却在我最困难的时候成了我的救命稻草！&lt;/p&gt;
&lt;p&gt;曾经一位前辈跟我讲过，只要你一直在学习，当你做了五六年之后会达到一个小高峰。&lt;br/&gt;的确是这样的，当时的我觉得自己技术还不错，几乎什么系统都可以去做，甚至觉得很多事情好像都很容易。&lt;br/&gt;那个阶段是移动互联网的风口，各种互联网人创业成功的故事也是满天飞，在这样的环境中，我在一次偶然的机会下选择离职创业，又开始了下一段旅程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201904/242916-20190402211456378-1077595542.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;(未完待续)&lt;/p&gt;
</description>
<pubDate>Tue, 02 Apr 2019 13:16:00 +0000</pubDate>
<dc:creator>美码师</dc:creator>
<og:description>在上一篇文章 '老兵的十年职场之路(一)' 里头，讲述了我在初入职场时的一些经历，从自己个人的感受来说并不是特别的美好，既没有职位上的屌丝逆袭、也没有令人兴奋的意外成长，但也许这也是很多人所经历过的，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/littleatp/p/10645408.html</dc:identifier>
</item>
<item>
<title>java ReentrantLock - jihite</title>
<link>http://www.cnblogs.com/kaituorensheng/p/10645276.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kaituorensheng/p/10645276.html</guid>
<description>&lt;h3&gt;介绍&lt;/h3&gt;
&lt;p&gt;ReentrantLock称为重入锁，比内部锁synchonized拥有更强大的功能，它可中断、可定时、设置公平锁&lt;/p&gt;
&lt;p&gt;【注】使用ReentrantLock时，一定要释放锁，一般释放放到finnal里写。&lt;/p&gt;
&lt;h3&gt;提供以下重要的方法&lt;/h3&gt;
&lt;p&gt;lock():获得锁，如果锁已被占用，则等待&lt;/p&gt;
&lt;p&gt;lockInterruptibly():获得锁，但有限响应中断&lt;/p&gt;
&lt;p&gt;unlock():释放锁&lt;/p&gt;
&lt;p&gt;tryLock():尝试获取锁。如果获得，返回true；否则返回false&lt;/p&gt;
&lt;p&gt;tryLock(long time, TimeUnit unit):在给定时间内获得锁。如果获得返回true；否则返回false&lt;/p&gt;
&lt;h3&gt;示例&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;例子1&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.locks.ReentrantLock;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ReentrantLockTest {
    ReentrantLock lock;

    ReentrantLockTest(ReentrantLock lock) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.lock =&lt;span&gt; lock;
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Runnable getRunnable() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {&lt;/span&gt;
                        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (lock.tryLock()) {
                            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                                System.out.println(&lt;/span&gt;&quot;Locked:&quot; +&lt;span&gt; Thread.currentThread().getName());
                                Thread.sleep(&lt;/span&gt;800&lt;span&gt;);
                            } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                                lock.unlock();
                                System.out.println(&lt;/span&gt;&quot;UnLocked:&quot; +&lt;span&gt; Thread.currentThread().getName());
                            }
                            System.out.println(&lt;/span&gt;&quot;break before&quot;&lt;span&gt;);
                            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;System.out.println(&quot;Unable to lock &quot; + Thread.currentThread().getName());&lt;/span&gt;
&lt;span&gt;                        }

                    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e){
                        System.out.println(Thread.currentThread() &lt;/span&gt;+ &quot; is Interupted&quot;&lt;span&gt;);
                        e.printStackTrace();
                    }
                }
            }
        };
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        ReentrantLock lock &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReentrantLock();
        ReentrantLockTest test &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReentrantLockTest(lock);
        ReentrantLockTest test2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReentrantLockTest(lock);
        Thread thread1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(test.getRunnable(), &quot;firstThread&quot;&lt;span&gt;);
        Thread thread2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(test2.getRunnable(), &quot;secondThread&quot;&lt;span&gt;);

        thread1.start();
        thread2.start();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            Thread.sleep(&lt;/span&gt;300&lt;span&gt;);
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(&lt;/span&gt;&quot;interupt begin&quot;&lt;span&gt;);
        thread2.interrupt();
        System.out.println(&lt;/span&gt;&quot;interupt end&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一次执行结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
Locked:firstThread
interupt begin
interupt end
UnLocked:firstThread
break before
Locked:secondThread
UnLocked:secondThread
Thread[secondThread,5,main] is Interupted
&lt;span&gt;java.lang.InterruptedException: sleep interrupted
        at java.lang.Thread.sleep(Native Method)
        at com.jihite.templet.JavaBase.ReentrantLockTest$1.run(ReentrantLockTest.java:23)
        at java.lang.Thread.run(Thread.java:748)&lt;/span&gt;
Locked:secondThread
UnLocked:secondThread
break before
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;分析：firstThread执行，secondThread不停的判断是否可以获得锁，当firstThread执行完，secondThread执行后被打断&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;例子2&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.TimeUnit;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.locks.ReentrantLock;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ReentrantLockTest {
    ReentrantLock lock;

    ReentrantLockTest(ReentrantLock lock) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.lock =&lt;span&gt; lock;
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Runnable getRunnable() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (lock.tryLock(700&lt;span&gt;, TimeUnit.MILLISECONDS)) {
                            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                                System.out.println(&lt;/span&gt;&quot;Locked:&quot; +&lt;span&gt; Thread.currentThread().getName());
                                Thread.sleep(&lt;/span&gt;800&lt;span&gt;);
                            } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                                lock.unlock();
                                System.out.println(&lt;/span&gt;&quot;UnLocked:&quot; +&lt;span&gt; Thread.currentThread().getName());
                            }
                            System.out.println(&lt;/span&gt;&quot;break before&quot;&lt;span&gt;);
                            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;System.out.println(&quot;Unable to lock &quot; + Thread.currentThread().getName());&lt;/span&gt;
&lt;span&gt;                        }

                    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e){
                        System.out.println(Thread.currentThread() &lt;/span&gt;+ &quot; is Interupted&quot;&lt;span&gt;);
                        e.printStackTrace();
                    }
                }
            }
        };
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        ReentrantLock lock &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReentrantLock();
        ReentrantLockTest test &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReentrantLockTest(lock);
        ReentrantLockTest test2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReentrantLockTest(lock);
        Thread thread1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(test.getRunnable(), &quot;firstThread&quot;&lt;span&gt;);
        Thread thread2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(test2.getRunnable(), &quot;secondThread&quot;&lt;span&gt;);

        thread1.start();
        thread2.start();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            Thread.sleep(&lt;/span&gt;300&lt;span&gt;);
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(&lt;/span&gt;&quot;interupt begin&quot;&lt;span&gt;);
        thread2.interrupt();
        System.out.println(&lt;/span&gt;&quot;interupt end&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一次执行结果&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
Locked:firstThread
interupt begin
interupt end
Thread[secondThread,5,main] is Interupted
&lt;span&gt;java.lang.InterruptedException
        at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireNanos(AbstractQueuedSynchronizer.java:936)
        at java.util.concurrent.locks.AbstractQueuedSynchronizer.tryAcquireNanos(AbstractQueuedSynchronizer.java:1247)
        at java.util.concurrent.locks.ReentrantLock.tryLock(ReentrantLock.java:442)
        at com.jihite.templet.JavaBase.ReentrantLockTest$1.run(ReentrantLockTest.java:19)
        at java.lang.Thread.run(Thread.java:748)&lt;/span&gt;
Locked:secondThread
UnLocked:firstThread
break before
UnLocked:secondThread
break before
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;分析：firstThread执行，secondThread等待，等待过程被打断。打断后firstThread执行结束了，secondThread得到锁，继续执行&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;例子3&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.locks.ReentrantLock;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ReentrantLockTest2 {
    ReentrantLock lock;

    ReentrantLockTest2(ReentrantLock lock) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.lock =&lt;span&gt; lock;
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Runnable getRunnable() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                            lock.lock();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                            lock.lockInterruptibly();&lt;/span&gt;
                            System.out.println(&quot;Locked:&quot; +&lt;span&gt; Thread.currentThread().getName());
                            Thread.sleep(&lt;/span&gt;800&lt;span&gt;);
                            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                            lock.unlock();
                            System.out.println(&lt;/span&gt;&quot;UnLocked:&quot; +&lt;span&gt; Thread.currentThread().getName());
                        }
                    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        };
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        ReentrantLock lock &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReentrantLock();
        ReentrantLockTest2 test &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReentrantLockTest2(lock);
        ReentrantLockTest2 test2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReentrantLockTest2(lock);
        Thread thread1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(test.getRunnable(), &quot;firstThread&quot;&lt;span&gt;);
        Thread thread2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(test2.getRunnable(), &quot;secondThread&quot;&lt;span&gt;);

        thread1.start();
        thread2.start();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            Thread.sleep(&lt;/span&gt;600&lt;span&gt;);
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(&lt;/span&gt;&quot;interupt begin&quot;&lt;span&gt;);
        thread2.interrupt();
        System.out.println(&lt;/span&gt;&quot;interupt end&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一次执行结果&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
Locked:firstThread
interupt begin
interupt end
UnLocked:firstThread
Locked:secondThread
UnLocked:secondThread
&lt;span&gt;java.lang.InterruptedException: sleep interrupted
        at java.lang.Thread.sleep(Native Method)
        at com.jihite.templet.JavaBase.ReentrantLockTest2$1.run(ReentrantLockTest2.java:22)
        at java.lang.Thread.run(Thread.java:748)&lt;/span&gt;
Locked:secondThread
UnLocked:secondThread
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;分析：firstThread先获得锁执行，secondThread在等待，此时中断并未打断等待。firstThread执行完，secondThread获取后被打断&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;例子4&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ReentrantLockTest2 {
    ReentrantLock lock;

    ReentrantLockTest2(ReentrantLock lock) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.lock =&lt;span&gt; lock;
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Runnable getRunnable() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                            lock.lock();&lt;/span&gt;
&lt;span&gt;                            lock.lockInterruptibly();
                            System.out.println(&lt;/span&gt;&quot;Locked:&quot; +&lt;span&gt; Thread.currentThread().getName());
                            Thread.sleep(&lt;/span&gt;800&lt;span&gt;);
                            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                            lock.unlock();
                            System.out.println(&lt;/span&gt;&quot;UnLocked:&quot; +&lt;span&gt; Thread.currentThread().getName());
                        }
                    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        };
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        ReentrantLock lock &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReentrantLock();
        ReentrantLockTest2 test &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReentrantLockTest2(lock);
        ReentrantLockTest2 test2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReentrantLockTest2(lock);
        Thread thread1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(test.getRunnable(), &quot;firstThread&quot;&lt;span&gt;);
        Thread thread2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(test2.getRunnable(), &quot;secondThread&quot;&lt;span&gt;);

        thread1.start();
        thread2.start();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            Thread.sleep(&lt;/span&gt;600&lt;span&gt;);
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(&lt;/span&gt;&quot;interupt begin&quot;&lt;span&gt;);
        thread2.interrupt();
        System.out.println(&lt;/span&gt;&quot;interupt end&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一次执行结果&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
Locked:firstThread
interupt begin
interupt end
&lt;span&gt;Exception in thread &quot;secondThread&quot; java.lang.IllegalMonitorStateException
        at java.util.concurrent.locks.ReentrantLock$Sync.tryRelease(ReentrantLock.java:151)
        at java.util.concurrent.locks.AbstractQueuedSynchronizer.release(AbstractQueuedSynchronizer.java:1261)
        at java.util.concurrent.locks.ReentrantLock.unlock(ReentrantLock.java:457)
        at com.jihite.templet.JavaBase.ReentrantLockTest2$1.run(ReentrantLockTest2.java:25)
        at java.lang.Thread.run(Thread.java:748)
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;分析：lock.lockInterruptibly();在执行过程中可以响应中断时间&lt;/p&gt;
</description>
<pubDate>Tue, 02 Apr 2019 12:57:00 +0000</pubDate>
<dc:creator>jihite</dc:creator>
<og:description>介绍 ReentrantLock称为重入锁，比内部锁synchonized拥有更强大的功能，它可中断、可定时、设置公平锁 【注】使用ReentrantLock时，一定要释放锁，一般释放放到finnal</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kaituorensheng/p/10645276.html</dc:identifier>
</item>
<item>
<title>小程序开发初体验~ - 渴望成为大牛的男人</title>
<link>http://www.cnblogs.com/bai1218/p/10645269.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bai1218/p/10645269.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;朋友们，很久不见，甚是想念~&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;前段时间因公司业务需求要开发小程序，大概做了有十天左右，在此将我使用小程序的一点心得拿出来给大家分享一下~&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;　接触小程序的第一感觉：&lt;/h2&gt;
&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt;　　第一次写小程序会有点小激动，第一次嘛，你懂的~&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　翻开小程序的文档你会发现，我透，这简直就是神物啊，各种组件应有尽有，轮播图swiper，滚动容器scroll-view，等等好用的组件(还有map地图组件，你敢信？)，还有无穷无尽的小程序自带的API，连上拉加载下拉刷新都已经给你封装好了，它还有自带的模板template以及自定义组件component等等让你享不尽的荣华富贵，我只有一个字，爱了~&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　由于我开发小程序也就开发了差不多十天左右的样子，此篇仅作为记录我在开发过程中的一些体验以及遇到的一些问题，比如说像怎么用开发者工具去新建一个项目，如何跑一个基本的项目等等这些在此我就不做解释了，所以会有点粗鲁~&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;　一、小程序的目录结构&lt;/h2&gt;
&lt;p&gt;　&lt;span&gt;　先说一下小程序的一个基本目录结构以及每个文件的基本作用吧：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　   &lt;img src=&quot;https://img2018.cnblogs.com/blog/1459233/201904/1459233-20190402182752714-47156061.png&quot; alt=&quot;&quot; width=&quot;251&quot; height=&quot;304&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;38&quot;&gt;
&lt;p&gt;&lt;span&gt;新建的一个处子小程序基本是长这样的，接下来我们一层一层的剥开它的衣服&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先你要掌握以下知识点：①.json为配置文件②.wxml 为模板文件，也就相当于我们的HTML模板③.wxss 为样式文件，相当于HTML的CSS样式表④.js 为JS脚本逻辑文件，相当于HTML的js脚本&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;别急，接下来就让我们一层一层的脱下它的衣服&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　①app.js文件：这里面放的是一些小程序逻辑，要注意：App()必须在app.js文件中注册，并且不能注册多个！我们可以在别的页面去调用getApp()，然后去拿我们需要的一些东西(比如我们自己定义的globalData)，在此不做过多介绍，文档里面都有~&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　②app.json文件：这里面放的是一些小程序的公共配置，比如每个页面都需要在这个文件中进行注册，小程序的主题风格，导航栏的背景色等等的一些公共配置&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　③app.wxss文件：这里面放的是一些小程序的公共样式表，在这个文件中写的样式是一个作为公共样式以供每个页面都去使用的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　④project.config.json文件：项目的配置文件，&lt;span&gt;在“微信开发者工具”上做的任何配置都会写入到这个文件，&lt;span&gt;这个文件中会有一些针对各自喜好做的一些个性化配置，例如界面颜色、编译配置、appid等等；所以我们在开发一个项目的时候，这个文件是非常重要的，它决定着你的小程序项目的一生啊~&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　⑤pages文件夹：你会发现这里面还有两个文件夹，一个是index一个是logs，这个pages文件夹下面其实就是放着你的每一个页面，每个页面对应一个文件夹，然后每个文件夹下面会有四个基本文件：也就是我刚开始说的那四个知识点。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　⑥utils文件夹：这个文件夹就是一个共用的逻辑库，也就是我们的一些共用的逻辑文件可以统一放在这个文件夹下面，可以看到现在这个文件夹下面有一个util.js文件，里面放的是一个格式化时间的函数~&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt; 　二、小程序的开发思想：&lt;/h2&gt;
&lt;blockquote readability=&quot;10.192364170338&quot;&gt;
&lt;p&gt;　　&lt;span&gt;以我个人开发过程中的体验以及之前对vue和react框架的使用来说，我个人理解小程序的开发思想也是基于MVVM的开发思想去进行开发的(其实本来就是这样的:))，都是用数据去驱动，大概说一下我怼MVVM思想的理解吧：其实就是M模型、V视图、VM视图模型，VM也就是视图模型层，当Model层改变的时候会引起视图模型层的改变，视图层也就会响应式的发生改变，会自动去更新DOM的状态，也会让开发者从频繁的DOM操作中解脱出来~&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不熟悉MVVM思想的同学可以戳这个链接，讲的挺好的：&lt;a href=&quot;https://www.cnblogs.com/xueduanyang/p/3601471.html&quot;&gt;https://www.cnblogs.com/xueduanyang/p/3601471.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;　三、小程序的一生&lt;/h2&gt;
&lt;blockquote readability=&quot;18.545765611634&quot;&gt;
&lt;p&gt;&lt;span&gt;　　小程序也是人，它也有自己的一生，也有属于自己的一套生命周期&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1. 小程序的生命周期是在app.js文件中里面去调用的，&lt;code&gt;App(Object)&lt;/code&gt;函数用来注册一个小程序，接受一个 &lt;code&gt;Object&lt;/code&gt; 参数，指定其小程序的生命周期回调；onLaunch会在小程序初始化的时候触发并且只触发一次，onShow会在小程序启动的时候或者从后台进入前台的时候触发，onHide会在小程序从前台进入后台时触发等等&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1459233/201904/1459233-20190402193346106-2118302329.png&quot; alt=&quot;&quot; width=&quot;854&quot; height=&quot;415&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;　2. 页面的生命周期：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1459233/201904/1459233-20190402194536771-1222479780.png&quot; alt=&quot;&quot; width=&quot;605&quot; height=&quot;462&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这两张图都是从小程序开发者文档上面扒下来的，最好的理解办法就是自己去打印一遍看一下每个方法都是在哪个阶段去执行的，在此我就不做打印给大家证明了，建议大家自己打印着去理解一下，其实本人目前对小程序的生命周期还不是特别的熟悉，因为项目中用到的不多，等我后期做的时间长了给大家补一篇小程序生命周期的详解~&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　正如官网所说，&lt;a href=&quot;https://developers.weixin.qq.com/miniprogram/dev/guide/framework/page-life-cycle.html&quot;&gt;https://developers.weixin.qq.com/miniprogram/dev/guide/framework/page-life-cycle.html&lt;/a&gt;，嗯~待我再练十年，应该会学会这门武功的&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;　四、 目前用到的小程序的一些货(因为本人最近也在搞vue，所以会觉得小程序的一些东西会和vue比较像)&lt;/h2&gt;
&lt;blockquote readability=&quot;48.5&quot;&gt;
&lt;p&gt;　　&lt;span&gt;1. template：小程序有自己的模板，当我们的dom结构比较类似的时候，可以使用template模板去写一套公用的模板，减少代码的冗余度，非常方便&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2. 小程序自定义组件：有时候模板可能会满足不了我们的需求，但是小程序可以写自定义组件，每个自定义组件可以写properties去接受传进来的参数，observers里面去写监听某个值的改变(类似于vue中的计算属性)，也可以自己去定义自己的数据data，还可以在methods里面写一些方法，通过this.triggerEvent去发送给父组件一些信息(类似于vue中的$emit)，等等等等，相信我，小程序的自定义组件，你会爱上它的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3. 小程序路由：小程序的路由其实很简单，和vue差不多，可以通过组件navigator去直接进行跳转，也可以写成编程式导航去进行跳转，这是本人在学习过程中做的一些很基本的总结(http://note.youdao.com/noteshare?id=14e2651402bbb641738af242447c8ea1)，或者大家直接去开发者文档看就行，有页面之间的跳转、传参等等，反正你需要的文档中都有的~&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　4. rich-text富文本组件：当你想要像使用vue中的v-html那种可以解析html字符串的功能的时候，可以考虑来看看它，它就在原地等你~&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　5. view、text、scroll-view组件等：小程序里面是没有div、p、span这种标签的，他们使用的是自己的组件，类似于原生的那种，就像本人在RN的时候那样，目前本人基本也就用用view和text组件了~&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　6. 小程序的一些API：获取dom节点的一些信息&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
wx.createSelectorQuery().select('#the-id').boundingClientRect(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (rect) {
      rect.id &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 节点的ID&lt;/span&gt;
      rect.dataset &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 节点的dataset&lt;/span&gt;
      rect.left &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 节点的左边界坐标&lt;/span&gt;
      rect.right &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 节点的右边界坐标&lt;/span&gt;
      rect.top &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 节点的上边界坐标&lt;/span&gt;
      rect.bottom &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 节点的下边界坐标&lt;/span&gt;
      rect.width &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 节点的宽度&lt;/span&gt;
      rect.height &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 节点的高度&lt;/span&gt;
    }).exec()
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　　还有获取wx.request，类似于localstorage那种的本地存储功能wx.setStorage以及wx.getStorage，还有一些路由跳转的API等等，打电话wx.makePhoneCall，获取当前地理位置wx.getLocation，获取系统信息wx.getSystemInfo，等等等等~反正你需要的，它都有，就是这么的帅气，，，不用记，开发者文档在手，需要哪个找哪个，妈妈再也不用担心我学不好小程序啦&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　7. 小程序中的wx:if，wx:el，wx:for，wx:。。。。。。。。。，和vue都差不多，用起来也挺好用的，小程序也是在两个花括号{{}}中去写变量的，但是花括号中不支持一些函数比如数字类型转换啊等等，期待小程序后期会支持吧~&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　8. 要&lt;span&gt;注意小程序中模块只有通过 module.exports 或者 exports 才能对外暴露接口&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　9. 小程序中的data以及setData：小程序中的data值可以通过setData({})去进行相应，setData支持传入第二个参数，传一个回调函数，可以在里面拿到更新后的data，类似于react中的setState的那一个套路&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　10. 小程序中绑定事件用bind:tap，还有很多什么冒泡啊捕获啊，这些都直接翻文档就行，用到哪个找哪个，美得很~&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　11. 好吧，其实也没用到太多东西，未完待续~~~~~&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt; 　五、在小程序中遇到的一些坑：&lt;/h2&gt;
&lt;blockquote readability=&quot;29&quot;&gt;
&lt;p&gt;&lt;span&gt;　　俗话说的好，没踩过坑的人不是好人，嗯，我是个大好人~~~，记录下我在开发小程序的过程中遇到的一些坑：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1. 注意小程序中的背景图片只能用线上的，不能使用本地图片当背景图&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2. 相信我，当你感觉自己的代码没错，逻辑没错，什么都没错的时候，看看你用的是不是text组件，是的话就换成view组件试试，你会回来赞我的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3. 在我使用rich-text的时候，就很纳闷，怎么到我这就解析不了html了呢，好吧，看了文档才发现，它不支持view和text组件，它居然要写div和span这种标签类型的，嗯，蒂花之秀~&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　4. 注意，小程序的组件和vue的组件不一样，vue解析出来就是你组件中的结构，小程序的最外层会有一个你的组件，这个组件是不能加样式的~&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　5. 有时候你如果感觉是很奇葩的bug，打开手机，真机调试，你会发现其实是正常的，有些东西小程序开发者工具解析是有问题的，或者尝试把组件换成view试试也行~&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　6. 当你跳转路由的时候，如果跳转的页面他不是一个纯纯的男孩儿，比如他是底部tabbar的页面，你会发现，根本跳不过去，这个时候你可以使用wx.switchtab的方式去进行跳转，不成功我吃屎好吧~&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　目前遇到的坑暂时这么些，有的想不起来了，等我，后续我会回来继续补坑的~&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;　六、个人的一些看法：&lt;/h2&gt;
&lt;blockquote readability=&quot;18&quot;&gt;
&lt;p&gt;&lt;span&gt;　　1. 小程序中没有类似于vuex那种配套的状态管理，不过可以把类似于redux或者mox这样的状态管理库接入小程序，期待小程序能出一套自身的状态管理，要不然数据的存储和流动有时候还是很不方便的，需要借助外部的力量，你懂的，我只想用你自己，答应我别让我用别人的东西好吗，求你了小程序~&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2. 自定义组件用着没有想vue中组件用着方便~&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3. 小程序不支持sass，我们需要通过像gulp这样的东西去编译sass然后解析打包才能解析成小程序支持的wxss&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　4. 希望能出一个类似于vue中的computed计算属性这样的东西，要不然数据的处理有时候会很恶心很恶心&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　以上只是我自己的一些使用后的想法而已，还是好评的(畏惧脸)~&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;　七、写在最后：&lt;/h2&gt;
&lt;blockquote readability=&quot;14&quot;&gt;
&lt;p&gt;&lt;span&gt;　　因为本人目前对小程序的开发还只是刚开始，待以后有时间了使用多了以后会回来更新这篇文章的，整体来说在使用的过程中还是挺顺手的，包括它的思想啊，绑定事件的套路，生命周期，组件等等，只不过有的地方可能是因为第一次用所以会觉得不好用，还有一些坑需要继续去踩~&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　最后，答应我，作为一个程序员不要总是熬夜好吗，要不然会像我一样头发越来越多的，没事多喝喝酒多抽抽烟，做一个自律的程序员，一切都会好起来的~&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 　　这篇文章后期使用小程序多了以后我会回来继续添加内容的，等我~&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 02 Apr 2019 12:56:00 +0000</pubDate>
<dc:creator>渴望成为大牛的男人</dc:creator>
<og:description>朋友们，很久不见，甚是想念~ 前段时间因公司业务需求要开发小程序，大概做了有十天左右，在此将我使用小程序的一点心得拿出来给大家分享一下~ 接触小程序的第一感觉： 第一次写小程序会有点小激动，第一次嘛，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bai1218/p/10645269.html</dc:identifier>
</item>
</channel>
</rss>