<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>用户需求与市场分析 - 小毛驴</title>
<link>http://www.cnblogs.com/wcLT/p/12677677.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wcLT/p/12677677.html</guid>
<description>&lt;p&gt;用户需求与市场分析：目标用户群是谁？用户有没有需求？用户有那些需求痛点没满足？用户规模？&lt;/p&gt;
&lt;p&gt;带着问题更容易发现问题的本质。不然缘木求鱼，会偏的太多，被社会毒打。&lt;/p&gt;
&lt;p&gt;提出差异化解决方案：基于用户需求提出差异化解决方案以及提炼出带给用户的价值&lt;/p&gt;
&lt;p&gt;传递用户价值的市场渠道分析：送到用户？价值传递？什么地方用？用户在哪里？怎么使用？&lt;/p&gt;
&lt;p&gt;盈亏平衡分析：成本收入&lt;/p&gt;
&lt;p&gt;需求管理与产品交互设计：需求分析与管理及产品交互&lt;/p&gt;
&lt;p&gt;基于数据分析的产品迭代与调优化：根据用户反馈和数据分析，不断迭代优化&lt;/p&gt;
&lt;p&gt;竞争壁垒分析&lt;/p&gt;
&lt;p&gt;强有力的团队管理：强有力的制度和文化支撑！团队集体进步，优秀的团队一定做成优秀的产品。&lt;/p&gt;
</description>
<pubDate>Sat, 11 Apr 2020 00:53:00 +0000</pubDate>
<dc:creator>小毛驴</dc:creator>
<og:description>用户需求与市场分析：目标用户群是谁？用户有没有需求？用户有那些需求痛点没满足？用户规模？ 带着问题更容易发现问题的本质。不然缘木求鱼，会偏的太多，被社会毒打。 提出差异化解决方案：基于用户需求提出差异</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wcLT/p/12677677.html</dc:identifier>
</item>
<item>
<title>掌握使用gitlab ci构建Android包的正确方式 - 布道师玄柯</title>
<link>http://www.cnblogs.com/zhouliweiblog/p/12677635.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhouliweiblog/p/12677635.html</guid>
<description>&lt;p&gt;最近公司在做移动端的项目，自然而然的需要搭建打包的环境。本来计划用Jenkins的，但是发现在gitlab上创建完项目后，提示去配置pipeline，于是决定用gitlab去尝试下，毕竟我觉得Jenkins的配置过于复杂了。&lt;/p&gt;
&lt;h2 id=&quot;gitlab-runner&quot;&gt;gitlab-runner&lt;/h2&gt;
&lt;p&gt;在gitlab中，gitlab-runner相当于Jenkins中的slave的概念，所以首先需要给项目配置一个runner。gitlab-runner分为三种：Shared Runner、Group Runner、Specific Runner。其中：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Shared Runner相当于全局的runner，所有的项目都可以使用。&lt;/li&gt;
&lt;li&gt;Group Runner相当于给一个分组设置runner，因此，分组中所有的项目都可以使用。&lt;/li&gt;
&lt;li&gt;Specific Runner顾名思义，就是项目特有的runner。只有这一个项目才能使用。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;个人建议使用Group Runner，你可以根据不同种类的项目，创建不同的分组，比如：Android、IOS、服务端等，然后针对每个分组创建对应的Group Runner，这样相互之间不会有影响，同时又不需要为每个工程单独创建runner。&lt;/p&gt;
&lt;h3 id=&quot;安装gitlab-runner&quot;&gt;安装gitlab-runner&lt;/h3&gt;
&lt;p&gt;需要在你的打包机器上安装gitlab-runner，在不同的平台上，安装gitlab-runner的方式不一致，可以参考官方文档：&lt;a href=&quot;https://docs.gitlab.com/runner/install/%E3%80%82%E8%BF%99%E9%87%8C%E4%BB%A5mac%E4%B8%BA%E4%BE%8B%EF%BC%9A&quot;&gt;https://docs.gitlab.com/runner/install/。这里以mac为例：&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# 下载文件
$ sudo curl --output /usr/local/bin/gitlab-runner https://gitlab-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-runner-darwin-amd64
# 配置权限
sudo chmod +x /usr/local/bin/gitlab-runner
# 启动gitlab runner
gitlab-runner install
gitlab-runner start
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;注册gitlab-runner&quot;&gt;注册gitlab-runner&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;[root@app3 ~]# sudo gitlab-runner register
Runtime platform                                    arch=amd64 os=linux pid=6324 revision=1b659122 version=12.8.0
Running in system-mode.
Please enter the gitlab-ci coordinator URL (e.g. https://gitlab.com/):
http://192.168.4.194/
Please enter the gitlab-ci token for this runner:
rbLy6bwsNbTuzD_6Bma4
Please enter the gitlab-ci description for this runner:
[app3]: testandroid
Please enter the gitlab-ci tags for this runner (comma separated):
testandroid
Registering runner... succeeded                     runner=rbLy6bws
Please enter the executor: parallels, docker-ssh+machine, custom, docker-ssh, shell, ssh, virtualbox, docker+machine, kubernetes, docker:
docker
Please enter the default Docker image (e.g. ruby:2.6):
jangrewe/gitlab-ci-android
Runner registered successfully. Feel free to start it, but if it's running already the config should be automatically reloaded!
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行上面的命令，就能将gitlab-runner注册到gitlab中，需要说明下执行命令时输入的几个参数，其中gitlab-ci coordinator URL和gitlab-ci token可以从项目（Group需要master权限）的Settings—&amp;gt;CI/CD—&amp;gt;Runners中查看，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/367944/202004/367944-20200411083415725-1835087040.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;gitlab-ci description是对runner的描述，根据情况填写即可。&lt;/p&gt;
&lt;p&gt;gitlab-ci tags 是runner的标签，在后面的配置文件中会用到。&lt;/p&gt;
&lt;p&gt;enter the executor是配置runner使用的执行器，可以是shell，如果你需要执行shell脚本的话。我们这里使用的是docker，使用了一个包含Android环境的容器：jangrewe/gitlab-ci-android。&lt;/p&gt;
&lt;p&gt;另外，需要注意，在gitlab所在服务器的/etc/gitlab-runner/config.toml配置文件中也可以对gitlab-runner的注册信息进行修改。&lt;/p&gt;
&lt;h3 id=&quot;重启gitlab-runner&quot;&gt;重启gitlab-runner&lt;/h3&gt;
&lt;p&gt;需要注意的是，往gitlab注册一个新的runner之后，需要将gitlab-runner进行重启，这样，注册的runner才能生效。我在操作的时候，因为没有重启，花了好多时间解决出现的问题。其实只要重启即可解决。&lt;/p&gt;
&lt;h3 id=&quot;检查gitlab-runner的状态&quot;&gt;检查gitlab-runner的状态&lt;/h3&gt;
&lt;p&gt;配置好之后，可以在项目的settings—&amp;gt;CI/CD中查看新增的runner是否是running状态，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/367944/202004/367944-20200411083436252-407825447.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;配置android工程&quot;&gt;配置Android工程&lt;/h2&gt;
&lt;p&gt;runner配置好后，接下来的工作就是配置Android项目，只需要在工程目录下创建.gitlab-ci.yml配置文件，然后往里面填充你想要实现的步骤即可，有点类似Jenkins中的pipeline脚本。不过，感觉gitlab ci的配置更加简单一些。我项目中的配置文件如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;image: gitlab-ci-android:V2 # 用来编译 android 项目的镜像

variables:
  GRADLE_OPTS: &quot;-Dorg.gradle.daemon=false&quot; # 禁用 gradle 守护进程

before_script:
  #  配置 gradle 的缓存目录
  - export GRADLE_USER_HOME=/cache/.gradle
  #  获取权限
  - chmod +x ./gradlew
  - chmod +x ./update-version-code.sh

stages:
  - build

# 提交代码自动编译
build:
  stage: build
  only:
    - master
  script: 
    - ./gradlew assembleDebug
  tags:
    - android

# 构建测试包
qa:
  stage: build
  only:
    - qa
  script:
    - ./gradlew assembleDebug
    - sh -x /cache/deploy-android.sh
  artifacts:
    paths:
      - app/build/outputs/apk/debug/
  tags:
    - android
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面配置的大致意思是：当开发往qa分支提交代码时，会触发构建测试包，打包完成后，会将包上传到一个文件服务器上，方便下载安装。&lt;/p&gt;
&lt;p&gt;最后上一个gitlab的效果图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/367944/202004/367944-20200411083457613-1906520628.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/367944/202004/367944-20200411083506272-1873802110.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;整体来看，是不是挺简单的，大家可以直接在gitlab上玩ci/cd，大大降低了成本。所以如果大家现在还没有将CI/CD做起来的，大家可以考虑直接用gitlab来玩。&lt;/p&gt;
</description>
<pubDate>Sat, 11 Apr 2020 00:36:00 +0000</pubDate>
<dc:creator>布道师玄柯</dc:creator>
<og:description>最近公司在做移动端的项目，自然而然的需要搭建打包的环境。本来计划用Jenkins的，但是发现在gitlab上创建完项目后，提示去配置pipeline，于是决定用gitlab去尝试下，毕竟我觉得Jenk</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhouliweiblog/p/12677635.html</dc:identifier>
</item>
<item>
<title>ArrayList源码分析 - 高传威</title>
<link>http://www.cnblogs.com/aweicy-1/p/12677597.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/aweicy-1/p/12677597.html</guid>
<description>&lt;!--[if IE]&gt;
    &lt;div class=&quot;unsupported-browser&quot;&gt;
        &amp;#35813;&amp;#39029;&amp;#38754;&amp;#19981;&amp;#25903;&amp;#25345; Internet Explorer &amp;#27983;&amp;#35272;&amp;#22120;&amp;#65292;&amp;#24314;&amp;#35758;&amp;#20351;&amp;#29992;
        &lt;a href=&quot;https://www.google.cn/intl/zh-CN/chrome/&quot;&gt;Google Chrome&lt;/a&gt;,
        &lt;a href=&quot;https://www.mozilla.org/zh-CN/firefox/&quot;&gt;Firefox&lt;/a&gt; &amp;#25110;
        &lt;a href=&quot;https://www.microsoftedgeinsider.com/zh-CN/&quot;&gt;Microsoft Edge&lt;/a&gt;
    &lt;/div&gt;
&lt;![endif]--&gt;
    &lt;div class=&quot;center-container &quot;&gt;
        &lt;div class=&quot;center-body card  h-sm-100&quot;&gt;
            &lt;div class=&quot;card-body&quot;&gt;
                


&lt;div class=&quot;login-top text-center&quot;&gt;
    &lt;span class=&quot;login-title&quot;&gt;博客园用户登录&lt;/span&gt;
    &lt;a href=&quot;https://www.cnblogs.com/&quot;&gt;
        &lt;svg class=&quot;login-sign&quot;&gt;&lt;use xlink:href=&quot;#icon-login-sign&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;
    &lt;p&gt;代码改变世界&lt;/p&gt;
&lt;/div&gt;
&lt;form id=&quot;loginForm&quot; method=&quot;post&quot; onsubmit=&quot;return false&quot;&gt;
    
        &lt;div class=&quot;form-group&quot;&gt;
            &lt;input tabindex=&quot;1&quot; class=&quot;form-control&quot; placeholder=&quot;登录用户名 / 邮箱&quot; autofocus=&quot;&quot; type=&quot;text&quot; data-val=&quot;true&quot; data-val-required=&quot;请输入登录用户名&quot; id=&quot;LoginName&quot; name=&quot;LoginName&quot; value=&quot;&quot;/&gt;&lt;span class=&quot;invalid-feedback field-validation-valid&quot; data-valmsg-for=&quot;LoginName&quot; data-valmsg-replace=&quot;true&quot;/&gt;
            &lt;a class=&quot;txt-forget-sign&quot; href=&quot;https://account.cnblogs.com/forgotloginname&quot;&gt;忘记登录用户名&lt;/a&gt;
        &lt;/div&gt;
        &lt;div class=&quot;form-group&quot;&gt;
            &lt;input tabindex=&quot;2&quot; class=&quot;form-control&quot; placeholder=&quot;密码&quot; type=&quot;password&quot; data-val=&quot;true&quot; data-val-required=&quot;请输入密码&quot; id=&quot;Password&quot; name=&quot;Password&quot;/&gt;&lt;span class=&quot;invalid-feedback field-validation-valid&quot; data-valmsg-for=&quot;Password&quot; data-valmsg-replace=&quot;true&quot;/&gt;
            &lt;a class=&quot;txt-forget-sign&quot; href=&quot;https://account.cnblogs.com/resetpassword&quot;&gt;忘记密码&lt;/a&gt;
        &lt;/div&gt;
        &lt;p&gt;
            &lt;input tabindex=&quot;3&quot; type=&quot;checkbox&quot; id=&quot;IsRemember&quot; name=&quot;IsRemember&quot; value=&quot;true&quot; class=&quot;custom-control-input&quot;/&gt;&lt;label class=&quot;custom-control-label&quot; for=&quot;IsRemember&quot;&gt;记住我&lt;/label&gt;
        &lt;/p&gt;

        &lt;button tabindex=&quot;4&quot; id=&quot;submitBtn&quot; type=&quot;submit&quot; class=&quot;btn-login btn btn-primary btn-sm ladda-button px-4&quot; data-style=&quot;slide-down&quot;&gt;
            &lt;span class=&quot;ladda-label&quot;&gt;登录&lt;/span&gt;
        &lt;/button&gt;
        &lt;div class=&quot;login-footer&quot;&gt;
            &lt;div class=&quot;ajax-error-box&quot;&gt;
                
            &lt;/div&gt;
            &lt;span&gt;没有账户，&lt;a href=&quot;https://account.cnblogs.com/signup&quot;&gt;立即注册&lt;/a&gt;&lt;/span&gt;
        &lt;/div&gt;
    
&lt;input name=&quot;__RequestVerificationToken&quot; type=&quot;hidden&quot; value=&quot;CfDJ8AfmEq8Ax7NLvwJFFi7-x5LILAPwgGYheooRDPabmMpd77YON-TYQQJ5ifGsFB-gZJbbXp032obUgBPFTNajwaPNM-IrnEcTEIloWyc84vwhxSw-Go3sglNZz-t_DEnzDhhPRWPeaUJotEF59_biPQ4&quot;/&gt;&lt;/form&gt;

&lt;input type=&quot;hidden&quot; id=&quot;PublicKey&quot; name=&quot;PublicKey&quot; value=&quot;MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCp0wHYbg/NOPO3nzMD3dndwS0MccuMeXCHgVlGOoYyFwLdS24Im2e7YyhB0wrUsyYf0/nhzCzBK8ZC9eCWqd0aHbdgOQT6CuFQBMjbyGYvlVYU2ZP7kG9Ft6YV6oc9ambuO7nPZh+bvXH0zDKfi02prknrScAKC0XhadTHT3Al0QIDAQAB&quot;/&gt;&lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    </description>
<pubDate>Sat, 11 Apr 2020 00:18:00 +0000</pubDate>
<dc:creator>高传威</dc:creator>
<dc:language>zh</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://account.cnblogs.com/signin?ReturnUrl=https://www.cnblogs.com/aweicy-1/p/12677597.html</dc:identifier>
</item>
<item>
<title>mySQL基础入门 - friedCoder</title>
<link>http://www.cnblogs.com/friedCoder/p/12677592.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/friedCoder/p/12677592.html</guid>
<description>&lt;h2 id=&quot;安装&quot;&gt;安装&lt;/h2&gt;
&lt;h3 id=&quot;windows&quot;&gt;windows&lt;/h3&gt;
&lt;p&gt;windows &lt;a href=&quot;https://www.runoob.com/mysql/mysql-install.html&quot;&gt;https://www.runoob.com/mysql/mysql-install.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;mysqld --initialize --console 报错 -- 出现Failed to find valid data directory.&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/github_38832708/article/details/83037241&quot;&gt;https://blog.csdn.net/github_38832708/article/details/83037241&lt;/a&gt;&lt;br/&gt;&lt;code&gt;mysqld --initialize --console&lt;/code&gt;初始化数据库：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mysqld --initialize-insecure&lt;/code&gt;&lt;br/&gt;程序会在动MySQL文件夹下创建data文件夹以及对应的文件&lt;/p&gt;
&lt;p&gt;登录&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql -h 主机名 -u 用户名 -p
mysql -u root -p

-h : 指定客户端所要登录的 MySQL 主机名, 登录本机(localhost 或 127.0.0.1)该参数可以省略;
-u : 登录的用户名;
-p : 告诉服务器将会使用一个密码来登录, 如果所要登录的用户名密码为空, 可以忽略此选项。

输入 exit 或 quit 退出登录
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动 &lt;code&gt;mysqld --console&lt;/code&gt;&lt;br/&gt;关闭 &lt;code&gt;mysqladmin -uroot shutdown&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;mysql服务&lt;br/&gt;移除 mysqld -remove MySQL&lt;br/&gt;关闭 net stop MySQL&lt;br/&gt;开启 net start MySQL&lt;/p&gt;
&lt;p&gt;图形界面下载&lt;br/&gt;&lt;a href=&quot;https://downloads.mysql.com/archives/workbench/&quot;&gt;https://downloads.mysql.com/archives/workbench/&lt;/a&gt;&lt;br/&gt;mysql workBench, 最新版好像和win10不兼容&lt;/p&gt;
&lt;h3 id=&quot;ubuntu&quot;&gt;ubuntu&lt;/h3&gt;
&lt;h4 id=&quot;安装-2&quot;&gt;安装&lt;/h4&gt;
&lt;p&gt;sudo apt-get install mysql-server / 密码：123&lt;br/&gt;sudo apt-get install mysql-client&lt;br/&gt;sudo apt-get install libmysqlclient-dev&lt;/p&gt;
&lt;h4 id=&quot;启动&quot;&gt;启动&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;mysql -uroot -p&lt;/code&gt; / 123&lt;/p&gt;
&lt;h4 id=&quot;设置远程访问&quot;&gt;设置远程访问&lt;/h4&gt;
&lt;p&gt;参考 &lt;a href=&quot;https://blog.csdn.net/james_nan/article/details/82053430&quot;&gt;https://blog.csdn.net/james_nan/article/details/82053430&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;sudo vi /etc/mysql/mysql.conf.d/mysqld.cnf
修改bind-address

mysql&amp;gt; grant all privileges on *.* to root@&quot;%&quot; identified by &quot;password&quot; with grant option;

*.*，表示数据库.表，也就是指所有数据库下的所有表。%表示任意的ip地址。password为root账号的密码。

service mysql restart
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;192.168.157.139&lt;br/&gt;&lt;code&gt;ip addr&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;关闭&quot;&gt;关闭&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;关闭目前运行的 MySQL 服务器&lt;/strong&gt;, 你可以执行以下命令:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;root@host# cd /usr/bin
./mysqladmin -u root -p shutdown
Enter password: ******
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;用户设置&quot;&gt;用户设置&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;需要添加 MySQL 用户，你只需要在 mysql 数据库中的 user 表添加新用户即可。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;root@host# mysql -u root -p
Enter password:*******
mysql&amp;gt; use mysql;
Database changed

mysql&amp;gt; INSERT INTO user 
          (host, user, password, 
           select_priv, insert_priv, update_priv) 
           VALUES ('localhost', 'guest', 
           PASSWORD('guest123'), 'Y', 'Y', 'Y');
Query OK, 1 row affected (0.20 sec)

mysql&amp;gt; FLUSH PRIVILEGES;
Query OK, 1 row affected (0.01 sec)

mysql&amp;gt; SELECT host, user, password FROM user WHERE user = 'guest';
+-----------+---------+------------------+
| host      | user    | password         |
+-----------+---------+------------------+
| localhost | guest | 6f8c114b58f2ce9e |
+-----------+---------+------------------+
1 row in set (0.00 sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在添加用户时，请注意使用MySQL提供的 PASSWORD() 函数来对密码进行加密。 你可以在以上实例看到用户密码加密后为： 6f8c114b58f2ce9e.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;在 MySQL5.7 中 user 表的 password 已换成了&lt;strong&gt;authentication_string&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;password() 加密函数已经在 8.0.11 中移除了，可以使用 MD5() 函数代替。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;在注意需要执行 &lt;strong&gt;FLUSH PRIVILEGES&lt;/strong&gt; 语句。 这个命令执行后会重新载入授权表。&lt;/p&gt;
&lt;p&gt;如果你不使用该命令，你就无法使用新创建的用户来连接mysql服务器，除非你重启mysql服务器。&lt;/p&gt;
&lt;p&gt;你可以在创建用户时，为用户指定权限，在对应的权限列中，在插入语句中设置为 'Y' 即可&lt;/p&gt;
&lt;h2 id=&quot;管理mysql&quot;&gt;管理MySQL&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;USE 数据库名&lt;/strong&gt; :&lt;br/&gt;&lt;strong&gt;选择要操作的Mysql数据库&lt;/strong&gt;，使用该命令后所有Mysql命令都只针对该数据库。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SHOW DATABASES:&lt;/strong&gt;&lt;br/&gt;列出 MySQL 数据库管理系统的数据库列表。（&lt;strong&gt;所有数据库&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SHOW TABLES:&lt;/strong&gt;&lt;br/&gt;显示指定数据库的所有表(&lt;strong&gt;所有关系，即所有表格&lt;/strong&gt;)，使用该命令前需要使用 use 命令来选择要操作的数据库。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SHOW COLUMNS FROM 数据表:&lt;/strong&gt;&lt;br/&gt;显示&lt;strong&gt;数据表的属性&lt;/strong&gt;，属性类型，主键信息 ，是否为 NULL，默认值等其他信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SHOW INDEX FROM 数据表:&lt;/strong&gt;&lt;br/&gt;显示数据表的详细索引信息，包括PRIMARY KEY（&lt;strong&gt;主键&lt;/strong&gt;）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SHOW TABLE STATUS [FROM db_name] [LIKE 'pattern'] \G:&lt;/strong&gt;&lt;br/&gt;该命令将输出Mysql数据库管理系统的性能及统计信息。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;mysql&amp;gt; SHOW TABLE STATUS  FROM RUNOOB;   # 显示数据库 RUNOOB 中所有表的信息

mysql&amp;gt; SHOW TABLE STATUS from RUNOOB LIKE 'runoob%';     # 表名以runoob开头的表的信息
mysql&amp;gt; SHOW TABLE STATUS from RUNOOB LIKE 'runoob%'\G;   # 加上 \G，查询结果按列打印
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;数据库的增删&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;CREATE DATABASE 数据库名;

drop database &amp;lt;数据库名&amp;gt;;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;数据类型&quot;&gt;数据类型&lt;/h2&gt;
&lt;h3 id=&quot;数值类型&quot;&gt;数值类型&lt;/h3&gt;
&lt;p&gt;MySQL支持所有标准SQL数值数据类型。这些类型包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL和NUMERIC)，以及近似数值数据类型(FLOAT、REAL和DOUBLE PRECISION)。&lt;/p&gt;
&lt;p&gt;关键字INT是INTEGER的同义词，关键字DEC是DECIMAL的同义词。BIT数据类型保存位字段值，并且支持MyISAM、MEMORY、InnoDB和BDB表。&lt;/p&gt;
&lt;p&gt;作为SQL标准的扩展，MySQL也支持整数类型TINYINT、MEDIUMINT和BIGINT。下面的表显示了需要的每个整数类型的存储和范围。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;大小&lt;/th&gt;
&lt;th&gt;范围（有符号）&lt;/th&gt;
&lt;th&gt;范围（无符号）&lt;/th&gt;
&lt;th&gt;用途&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;13&quot;&gt;&lt;tr&gt;&lt;td&gt;TINYINT&lt;/td&gt;
&lt;td&gt;1 byte&lt;/td&gt;
&lt;td&gt;(-128，127)&lt;/td&gt;
&lt;td&gt;(0，255)&lt;/td&gt;
&lt;td&gt;小整数值&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;SMALLINT&lt;/td&gt;
&lt;td&gt;2 bytes&lt;/td&gt;
&lt;td&gt;(-32 768，32 767)&lt;/td&gt;
&lt;td&gt;(0，65 535)&lt;/td&gt;
&lt;td&gt;大整数值&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;MEDIUMINT&lt;/td&gt;
&lt;td&gt;3 bytes&lt;/td&gt;
&lt;td&gt;(-8 388 608，8 388 607)&lt;/td&gt;
&lt;td&gt;(0，16 777 215)&lt;/td&gt;
&lt;td&gt;大整数值&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;INT或INTEGER&lt;/td&gt;
&lt;td&gt;4 bytes&lt;/td&gt;
&lt;td&gt;(-2 147 483 648，2 147 483 647)&lt;/td&gt;
&lt;td&gt;(0，4 294 967 295)&lt;/td&gt;
&lt;td&gt;大整数值&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;10&quot;&gt;&lt;td&gt;BIGINT&lt;/td&gt;
&lt;td&gt;8 bytes&lt;/td&gt;
&lt;td&gt;(-9,223,372,036,854,775,808，9 223 372 036 854 775 807)&lt;/td&gt;
&lt;td&gt;(0，18 446 744 073 709 551 615)&lt;/td&gt;
&lt;td&gt;极大整数值&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;FLOAT&lt;/td&gt;
&lt;td&gt;4 bytes&lt;/td&gt;
&lt;td&gt;(-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)&lt;/td&gt;
&lt;td&gt;0，(1.175 494 351 E-38，3.402 823 466 E+38)&lt;/td&gt;
&lt;td&gt;单精度 浮点数值&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;DOUBLE&lt;/td&gt;
&lt;td&gt;8 bytes&lt;/td&gt;
&lt;td&gt;(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)&lt;/td&gt;
&lt;td&gt;0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)&lt;/td&gt;
&lt;td&gt;双精度 浮点数值&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;DECIMAL&lt;/td&gt;
&lt;td&gt;对DECIMAL(M,D) ，如果M&amp;gt;D，为M+2否则为D+2&lt;/td&gt;
&lt;td&gt;依赖于M和D的值。&lt;code&gt;DECIMAL&lt;/code&gt;数据类型用于在数据库中存储精确的数值。&lt;/td&gt;
&lt;td&gt;依赖于M和D的值&lt;/td&gt;
&lt;td&gt;小数值&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;对于decimal, &lt;strong&gt;整数的位数必须小于等于m-d，不然报错。小数的位数可以大于d位。多出d位时会做四舍五入，截取到d位&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;日期和时间类型&quot;&gt;日期和时间类型&lt;/h3&gt;
&lt;p&gt;表示时间值的日期和时间类型为DATETIME、DATE、TIMESTAMP、TIME和YEAR。&lt;/p&gt;
&lt;p&gt;每个时间类型有一个有效值范围和一个&quot;零&quot;值，当指定不合法的MySQL不能表示的值时使用&quot;零&quot;值。&lt;/p&gt;
&lt;p&gt;TIMESTAMP类型有专有的自动更新特性，将在后面描述。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;大小 ( bytes)&lt;/th&gt;
&lt;th&gt;范围&lt;/th&gt;
&lt;th&gt;格式&lt;/th&gt;
&lt;th&gt;用途&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3.5&quot;&gt;&lt;tr&gt;&lt;td&gt;DATE&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;1000-01-01/9999-12-31&lt;/td&gt;
&lt;td&gt;YYYY-MM-DD&lt;/td&gt;
&lt;td&gt;日期值&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;TIME&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;'-838:59:59'/'838:59:59'&lt;/td&gt;
&lt;td&gt;HH:MM:SS&lt;/td&gt;
&lt;td&gt;时间值或持续时间&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;YEAR&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1901/2155&lt;/td&gt;
&lt;td&gt;YYYY&lt;/td&gt;
&lt;td&gt;年份值&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;DATETIME&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;1000-01-01 00:00:00/9999-12-31 23:59:59&lt;/td&gt;
&lt;td&gt;YYYY-MM-DD HH:MM:SS&lt;/td&gt;
&lt;td&gt;混合日期和时间值&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;TIMESTAMP&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;1970-01-01 00:00:00/2038结束时间是第 &lt;strong&gt;2147483647&lt;/strong&gt; 秒，北京时间 &lt;strong&gt;2038-1-19 11:14:07&lt;/strong&gt;，格林尼治时间 2038年1月19日 凌晨 03:14:07&lt;/td&gt;
&lt;td&gt;YYYYMMDD HHMMSS&lt;/td&gt;
&lt;td&gt;混合日期和时间值，时间戳&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;字符串类型&quot;&gt;字符串类型&lt;/h3&gt;
&lt;p&gt;字符串类型指CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。该节描述了这些类型如何工作以及如何在查询中使用这些类型。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;大小&lt;/th&gt;
&lt;th&gt;用途&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr&gt;&lt;td&gt;CHAR&lt;/td&gt;
&lt;td&gt;0-255 bytes&lt;/td&gt;
&lt;td&gt;定长字符串&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;VARCHAR&lt;/td&gt;
&lt;td&gt;0-65535 bytes&lt;/td&gt;
&lt;td&gt;变长字符串&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;TINYBLOB&lt;/td&gt;
&lt;td&gt;0-255 bytes&lt;/td&gt;
&lt;td&gt;不超过 255 个字符的二进制字符串&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;TINYTEXT&lt;/td&gt;
&lt;td&gt;0-255 bytes&lt;/td&gt;
&lt;td&gt;短文本字符串&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;BLOB&lt;/td&gt;
&lt;td&gt;0-65 535 bytes&lt;/td&gt;
&lt;td&gt;二进制形式的长文本数据&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;TEXT&lt;/td&gt;
&lt;td&gt;0-65 535 bytes&lt;/td&gt;
&lt;td&gt;长文本数据&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;MEDIUMBLOB&lt;/td&gt;
&lt;td&gt;0-16 777 215 bytes&lt;/td&gt;
&lt;td&gt;二进制形式的中等长度文本数据&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;MEDIUMTEXT&lt;/td&gt;
&lt;td&gt;0-16 777 215 bytes&lt;/td&gt;
&lt;td&gt;中等长度文本数据&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;LONGBLOB&lt;/td&gt;
&lt;td&gt;0-4 294 967 295 bytes&lt;/td&gt;
&lt;td&gt;二进制形式的极大文本数据&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;LONGTEXT&lt;/td&gt;
&lt;td&gt;0-4 294 967 295 bytes&lt;/td&gt;
&lt;td&gt;极大文本数据&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：char(n) 和 varchar(n) 中括号中 n 代表字符的个数，并不代表字节个数，比如 CHAR(30) 就可以存储 30 个字符。&lt;/p&gt;
&lt;p&gt;CHAR 和 VARCHAR 类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。&lt;/p&gt;
&lt;p&gt;BINARY 和 VARBINARY 类似于 CHAR 和 VARCHAR，不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。&lt;/p&gt;
&lt;p&gt;BLOB 是一个二进制大对象，可以容纳可变数量的数据。有 4 种 BLOB 类型：TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。它们区别在于可容纳存储范围不同。&lt;/p&gt;
&lt;p&gt;有 4 种 TEXT 类型：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。对应的这 4 种 BLOB 类型，可存储的最大长度不同，可根据实际情况选择。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MySQL 5.0 以上的版本：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;1、一个汉字占多少长度与编码有关：&lt;br/&gt;&lt;strong&gt;UTF－8&lt;/strong&gt;：一个汉字＝3个字节&lt;br/&gt;&lt;strong&gt;GBK&lt;/strong&gt;：一个汉字＝2个字节&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;2、varchar(n) 表示 n 个字符，无论汉字和英文，Mysql 都能存入 n 个字符，仅是实际字节长度有所区别&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;char、varchar 与 text&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;关于 char、varchar 与 text 平时没有太在意，一般来说，可能现在大家都是用 varchar。但是当要存储的内容比较大时，究竟是选择 varchar 还是 text 呢？&lt;/p&gt;
&lt;p&gt;这三种类型比较：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;（1）&lt;strong&gt;char&lt;/strong&gt;: char 不用多说了，它是定长格式的，但是长度范围是 0~255. &lt;strong&gt;当你想要储存一个长度不足 255 的字符时，Mysql 会用空格来填充剩下的字符&lt;/strong&gt;。因此在读取数据时，char 类型的数据要进行处理，把后面的空格去除。&lt;/li&gt;
&lt;li&gt;（2）&lt;strong&gt;varchar&lt;/strong&gt;: 关于 varchar，有的说最大长度是 255，也有的说是 65535，查阅很多资料后发现是这样的：varchar 类型在 5.0.3 以下的版本中的最大长度限制为 255，而在 5.0.3 及以上的版本中，varchar 数据类型的长度支持到了 65535，也就是说可以存放 65532 个字节（注意是字节而不是字符！！！）的数据（起始位和结束位占去了3个字节），也就是说，在 5.0.3 以下版本中需要使用固定的 TEXT 或 BLOB 格式存放的数据可以在高版本中使用可变长的 varchar 来存放，这样就能有效的减少数据库文件的大小。&lt;/li&gt;
&lt;li&gt;（3）&lt;strong&gt;text&lt;/strong&gt;: 与 char 和 varchar 不同的是，text 不可以有默认值，其最大长度是 2 的 16 次方-1&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;总结起来，有几点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;经常变化的字段用 varchar&lt;/li&gt;
&lt;li&gt;知道固定长度的用 char&lt;/li&gt;
&lt;li&gt;尽量用 varchar&lt;/li&gt;
&lt;li&gt;超过 255 字符的只能用 varchar 或者 text&lt;/li&gt;
&lt;li&gt;能用 varchar 的地方不用 text&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;按照查询速度： char最快， varchar次之，text最慢。&lt;/p&gt;
&lt;h2 id=&quot;数据表&quot;&gt;数据表&lt;/h2&gt;
&lt;h3 id=&quot;创建数据表&quot;&gt;创建数据表&lt;/h3&gt;
&lt;p&gt;以下为创建MySQL数据表的SQL通用语法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;CREATE TABLE table_name (column_name column_type);

CREATE TABLE IF NOT EXISTS `runoob_tbl`(
   `runoob_id` INT UNSIGNED AUTO_INCREMENT,
   `runoob_title` VARCHAR(100) NOT NULL,
   `runoob_author` VARCHAR(40) NOT NULL,
   `submission_date` DATE,
   PRIMARY KEY ( `runoob_id` )
)ENGINE=InnoDB DEFAULT CHARSET=utf8;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;如果你不想字段为 &lt;strong&gt;NULL&lt;/strong&gt; 可以设置字段的属性为 &lt;strong&gt;NOT NULL&lt;/strong&gt;， 在操作数据库时如果输入该字段的数据为&lt;strong&gt;NULL&lt;/strong&gt; ，就会报错。&lt;/li&gt;
&lt;li&gt;AUTO_INCREMENT定义列为自增的属性，一般用于主键，数值会自动加1。&lt;/li&gt;
&lt;li&gt;PRIMARY KEY关键字用于定义列为主键。 您可以使用多列来定义主键，列间以逗号分隔。&lt;/li&gt;
&lt;li&gt;ENGINE 设置存储引擎，CHARSET 设置编码。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;查看数据表&lt;/p&gt;
&lt;p&gt;&lt;code&gt;desc 数据表名称;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MySQL 字段属性应该尽量设置为 NOT NULL&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;除非你有一个很特别的原因去使用 NULL 值，你应该总是让你的字段保持 NOT NULL。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、&lt;/strong&gt;首先，我们要搞清楚空值 &lt;strong&gt;&quot;&quot;&lt;/strong&gt; 和 &lt;strong&gt;NULL&lt;/strong&gt; 的概念：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1）空值是不占用空间的&lt;/li&gt;
&lt;li&gt;2）MySQL中的NULL其实是占用空间的&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所谓的 NULL 就是什么都没有，连 &lt;strong&gt;\0&lt;/strong&gt; 都没有，&lt;strong&gt;\0&lt;/strong&gt; 在字符串中是结束符，但是在物理内存是占空间的，等于一个字节，而 NULL 就是连这一个字节都没有。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、&lt;/strong&gt;其次，在数据库里是严格区分的，&lt;strong&gt;任何数跟 NULL 进行运算都是 NULL, 判断值是否等于 NULL，不能简单用 =，而要用 IS NULL关键字&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、&lt;/strong&gt;数据库的字段 col1 设为 NOT NULL, 仅仅说明该字段不能为 NULL, 也就是说只有在:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;INSERT INTO table1(col1) VALUES(NULL);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种情况下数据库会报错，而:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;INSERT INTO table1(col1) VALUES('');
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不会报错。&lt;/p&gt;
&lt;p&gt;（如果字段是自增ID，第一句不会报错，这不能说明是可以为NULL,而是 数据库系统会根据ID设的缺省值填充，或者如果是自增字段就自动加一等缺省操作。）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、&lt;/strong&gt; &lt;strong&gt;含有空值的列很难进行查询优化&lt;/strong&gt;，而且对表索引时不会存储 NULL 值的，所以如果索引的字段可以为 NULL，索引的效率会下降很多。因为它们使得索引、索引的统计信息以及比较运算更加复杂。&lt;strong&gt;你应该用 0、一个特殊的值或者一个空串代替空值。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5、&lt;/strong&gt;联表查询的时候，例如 LEFT JOIN table2，若没有记录，则查找出的 table2 字段都是 null。假如 table2 有些字段本身可以是 null，那么除非把 table2 中 not null 的字段查出来，否则就难以区分到底是没有关联记录还是其他情况。&lt;/p&gt;
&lt;h3 id=&quot;删除数据表&quot;&gt;删除数据表&lt;/h3&gt;
&lt;p&gt;针对 表结构，innodb 和 MyISAM有4种级别的删除。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;DROP TABLE table_name;
删除表全部数据和表结构，立刻释放磁盘空间，不管是 Innodb 和 MyISAM;


truncate table table_name;
删除表全部数据，保留表结构，立刻释放磁盘空间 ，不管是 Innodb 和 MyISAM;


delete from table_name;
删除表全部数据，表结构不变，对于 MyISAM 会立刻释放磁盘空间，InnoDB 不会释放磁盘空间;


delete from table_name where xxx : 带条件的删除，表结构不变，不管是 innodb 还是 MyISAM 都不会释放磁盘空间;
实例，删除学生表中姓名为 &quot;张三&quot; 的数据：
delete from student where T_name = &quot;张三&quot;;
delete 操作以后，使用 optimize table table_name 会立刻释放磁盘空间，不管是 innodb 还是 myisam;

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;MySQL 数据库删除数据的三种方式：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;delete from table where&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;直接删除表中的某一行数据，并且同时将该行的删除操作作为事务&lt;strong&gt;记录在日志中&lt;/strong&gt;保存以便进行进行回滚操作。所以 &lt;strong&gt;delete 相比较 truncate 更加占用资源，数据空间不释放，因为需回滚。对 table 和 view 都能操作。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;truncate table&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一次性地从表中删除所有的数据(释放存储表数据所用的数据页来删除数据)并&lt;strong&gt;不把单独的删除操作记录记入日志保存(只在事务日志中记录 页的释放)，因此也不能回滚&lt;/strong&gt;，不能恢复数据，在删除的过程中不会激活与表有关的删除触发器，占用资源更加少，速度更快。数据空间会释放，这个表和索引所占用的空间会恢复到初始大小。只能操作没有关联视图的 table。&lt;/p&gt;
&lt;p&gt;truncate table 不能用于参与了索引视图的表。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;drop table&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;删除的是整个表，包括表的结构，数据，定义。永久抹去，空间释放。对 table 和 view 都能操作。由于 TRUNCATE TABLE 不记录在日志中，所以它不能激活触发器，&lt;strong&gt;对于外键（foreignkey ）约束引用的表，不能使用 truncate table，而应使用不带 where 子句的 delete 语句。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;增删改查&quot;&gt;增删改查&lt;/h2&gt;
&lt;h3 id=&quot;增&quot;&gt;增&lt;/h3&gt;
&lt;p&gt;以下为向MySQL数据表插入数据通用的 &lt;strong&gt;INSERT INTO&lt;/strong&gt; SQL语法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;INSERT INTO table_name ( field1, field2,...fieldN )
                       VALUES
                       ( value1, value2,...valueN );
                       
INSERT INTO table_name  (field1, field2,...fieldN)  VALUES  (valueA1,valueA2,...valueAN),(valueB1,valueB2,...valueBN),(valueC1,valueC2,...valueCN)......;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果所有的列都要添加数据可以不规定列进行添加数据&lt;br/&gt;如果数据是字符型，必须使用单引号或者双引号，如：&quot;value&quot;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;mysql&amp;gt; INSERT INTO runoob_tbl 
    -&amp;gt; (runoob_title, runoob_author, submission_date)
    -&amp;gt; VALUES
    -&amp;gt; (&quot;学习 PHP&quot;, &quot;菜鸟教程&quot;, NOW());
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们并没有提供 runoob_id 的数据，因为该字段我们在创建表的时候已经设置它为 AUTO_INCREMENT(自动增加) 属性。 所以，该字段会自动递增而不需要我们去设置。实例中 NOW() 是一个 MySQL 函数，该函数返回日期和时间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;读取表的数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;select * from runoob_tbl;&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;查&quot;&gt;查&lt;/h3&gt;
&lt;p&gt;以下为在MySQL数据库中查询数据通用的 SELECT 语法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;SELECT column_name,column_name
FROM table_name
[WHERE Clause]
[LIMIT N][ OFFSET M]
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;查询语句中你&lt;strong&gt;可以使用一个或者多个表&lt;/strong&gt;，表之间使用逗号(,)分割，并使用&lt;strong&gt;WHERE语句来设定查询条件&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;SELECT 命令可以读取一条或者多条记录。&lt;/li&gt;
&lt;li&gt;你可以使用星号（*）来代替其他字段，SELECT语句会返回表的所有字段数据&lt;/li&gt;
&lt;li&gt;你可以使用 WHERE 语句来包含任何条件。&lt;/li&gt;
&lt;li&gt;你可以使用 &lt;strong&gt;LIMIT 属性来设定返回的记录数&lt;/strong&gt;。&lt;strong&gt;limit N,M&lt;/strong&gt; : 相当于 &lt;strong&gt;limit M offset N&lt;/strong&gt; , 从第 N 条记录开始, 返回 M 条记录 (-1表最后)&lt;/li&gt;
&lt;li&gt;你可以通过OFFSET指定SELECT语句开始查询的数据偏移量。默认情况下偏移量为0。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;where&quot;&gt;where&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;SELECT field1, field2,...fieldN FROM table_name1, table_name2...
[WHERE condition1 [AND [OR]] condition2.....
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;查询语句中你可以使用一个或者多个表，表之间使用逗号&lt;strong&gt;,&lt;/strong&gt; 分割，并使用WHERE语句来设定查询条件。&lt;/li&gt;
&lt;li&gt;你可以在 WHERE 子句中指定任何条件。&lt;/li&gt;
&lt;li&gt;你可以使用 AND 或者 OR 指定一个或多个条件。&lt;/li&gt;
&lt;li&gt;WHERE 子句也可以运用于 SQL 的 DELETE 或者 UPDATE 命令。&lt;/li&gt;
&lt;li&gt;WHERE 子句类似于程序语言中的 if 条件，根据 MySQL 表中的字段值来读取指定的数据。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;使用主键来作为 WHERE 子句的条件查询是非常快速的。&lt;br/&gt;如果给定的条件在表中没有任何匹配的记录，那么查询不会返回任何数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;MySQL 的 WHERE 子句的字符串比较是不区分大小写的。 你可以使用 BINARY 关键字来设定 WHERE 子句的字符串比较是区分大小写的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mysql&amp;gt; SELECT * from runoob_tbl WHERE BINARY runoob_author='runoob.com';&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;like&quot;&gt;like&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;类似正则匹配&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;LIKE 子句中使用百分号 &lt;strong&gt;%&lt;/strong&gt;字符来表示任意字符，类似于UNIX或正则表达式中的星号 *****。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;SELECT field1, field2,...fieldN 
FROM table_name
WHERE field1 LIKE condition1 [AND [OR]] filed2 = 'somevalue'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;like 匹配/模糊匹配，会与 &lt;strong&gt;%&lt;/strong&gt; 和 &lt;strong&gt;_&lt;/strong&gt; 结合使用。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;'%a'     //以a结尾的数据
'a%'     //以a开头的数据
'%a%'    //含有a的数据
'_a_'    //三位且中间字母是a的
'_a'     //两位且结尾字母是a的
'a_'     //两位且开头字母是a的
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 where like 的条件查询中，SQL 提供了四种匹配方式。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;%&lt;/strong&gt;：表示任意 0 个或多个字符。可匹配任意类型和长度的字符，有些情况下若是中文，请使用两个百分号（%%）表示。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;_&lt;/strong&gt;：表示任意单个字符。匹配单个任意字符，它常用来限制表达式的字符长度语句。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;[]&lt;/strong&gt;：表示括号内所列字符中的一个（类似正则表达式）。指定一个字符、字符串或范围，要求所匹配对象为它们中的任一个。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;[^]&lt;/strong&gt; ：表示不在括号所列之内的单个字符。其取值和 [] 相同，但它要求所匹配对象为指定字符以外的任一个字符。&lt;/li&gt;
&lt;li&gt;查询内容包含通配符时,由于通配符的缘故，导致我们查询特殊字符 “%”、“_”、“[” 的语句无法正常实现，而把特殊字符用 “[ ]” 括起便可正常查询。&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;正则&quot;&gt;正则&lt;/h4&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;模式&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;15.5&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;^&lt;/td&gt;
&lt;td&gt;匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 '\n' 或 '\r' 之后的位置。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;$&lt;/td&gt;
&lt;td&gt;匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 '\n' 或 '\r' 之前的位置。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;.&lt;/td&gt;
&lt;td&gt;匹配除 &quot;\n&quot; 之外的任何单个字符。要匹配包括 '\n' 在内的任何字符，请使用象 '[.\n]' 的模式。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;[...]&lt;/td&gt;
&lt;td&gt;字符集合。匹配所包含的任意一个字符。例如， '[abc]' 可以匹配 &quot;plain&quot; 中的 'a'。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;[^...]&lt;/td&gt;
&lt;td&gt;负值字符集合。匹配未包含的任意字符。例如， '[^abc]' 可以匹配 &quot;plain&quot; 中的'p'。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;p1|p2|p3&lt;/td&gt;
&lt;td&gt;匹配 p1 或 p2 或 p3。例如，'z|food' 能匹配 &quot;z&quot; 或 &quot;food&quot;。'(z|f)ood' 则匹配 &quot;zood&quot; 或 &quot;food&quot;。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;匹配前面的子表达式零次或多次。例如，zo* 能匹配 &quot;z&quot; 以及 &quot;zoo&quot;。* 等价于{0,}。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 &quot;zo&quot; 以及 &quot;zoo&quot;，但不能匹配 &quot;z&quot;。+ 等价于 {1,}。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;{n}&lt;/td&gt;
&lt;td&gt;n 是一个非负整数。匹配确定的 n 次。例如，'o{2}' 不能匹配 &quot;Bob&quot; 中的 'o'，但是能匹配 &quot;food&quot; 中的两个 o。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;{n,m}&lt;/td&gt;
&lt;td&gt;m 和 n 均为非负整数，其中n &amp;lt;= m。最少匹配 n 次且最多匹配 m 次。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;查找name字段中以元音字符开头或以'ok'字符串结尾的所有数据：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;mysql&amp;gt; SELECT name FROM person_tbl WHERE name REGEXP '^[aeiou]|ok$';
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;改&quot;&gt;改&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;UPDATE table_name SET field1=new-value1, field2=new-value2
[WHERE Clause]
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;你可以同时更新一个或多个字段。&lt;/li&gt;
&lt;li&gt;你可以在 WHERE 子句中指定任何条件。&lt;/li&gt;
&lt;li&gt;你可以在一个单独表中同时更新数据。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当我们需要将字段中的特定字符串批量修改为其他字符串时，可已使用以下操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;UPDATE table_name SET field=REPLACE(field, 'old-string', 'new-string') 
[WHERE Clause]
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;删&quot;&gt;删&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;DELETE FROM table_name [WHERE Clause]
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;如果没有指定 WHERE 子句，MySQL 表中的所有记录将被删除。&lt;/li&gt;
&lt;li&gt;你可以在 WHERE 子句中指定任何条件&lt;/li&gt;
&lt;li&gt;您可以在单个表中一次性删除记录。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;执行的速度上，&lt;strong&gt;drop&amp;gt;truncate&amp;gt;delete&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;union&quot;&gt;union&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;SELECT expression1, expression2, ... expression_n
FROM tables
[WHERE conditions]
UNION [ALL | DISTINCT]
SELECT expression1, expression2, ... expression_n
FROM tables
[WHERE conditions];
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有点自然连接的意思，但是select的属性必须相同&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;expression1, expression2, ... expression_n&lt;/strong&gt;: 要检索的列。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;tables:&lt;/strong&gt; 要检索的数据表。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;WHERE conditions:&lt;/strong&gt; 可选， 检索条件。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DISTINCT:&lt;/strong&gt; 可选，删除结果集中重复的数据。默认情况下 UNION 操作符已经删除了重复数据，所以 DISTINCT 修饰符对结果没啥影响。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ALL:&lt;/strong&gt; 可选，返回所有结果集，包含重复数据。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;实例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面的 SQL 语句从 &quot;Websites&quot; 和 &quot;apps&quot; 表中选取所有&lt;strong&gt;不同的&lt;/strong&gt;country（只有不同的值）：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;SELECT country FROM Websites
UNION
SELECT country FROM apps
ORDER BY country;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;排序&quot;&gt;排序&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;SELECT field1, field2,...fieldN FROM table_name1, table_name2...
ORDER BY field1 [ASC [DESC][默认 ASC]], [field2...] [ASC [DESC][默认 ASC]]
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;你可以使用任何字段来作为排序的条件，从而返回排序后的查询结果。&lt;/li&gt;
&lt;li&gt;你可以设定多个字段来排序。&lt;/li&gt;
&lt;li&gt;你可以使用 &lt;strong&gt;ASC 或 DESC 关键字来设置查询结果是按升序或降序排列。 默认情况下，它是按升序排列。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;你可以添加 WHERE...LIKE 子句来设置条件。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;MySQL 拼音排序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果字符集采用的是 gbk(汉字编码字符集)，直接在查询语句后边添加 ORDER BY：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;SELECT * 
FROM runoob_tbl
ORDER BY runoob_title;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果字符集采用的是 utf8(万国码)，需要先对字段进行转码convert然后排序：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;SELECT * 
FROM runoob_tbl
ORDER BY CONVERT(runoob_title using gbk);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;分组&quot;&gt;分组&lt;/h2&gt;
&lt;p&gt;GROUP BY 语句根据一个或多个列对结果集进行分组。&lt;strong&gt;相同的分一组&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在分组的列上我们可以使用 COUNT, SUM, AVG,等函数。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;SELECT column_name, function(column_name)
FROM table_name
WHERE column_name operator value
GROUP BY column_name;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用 GROUP BY 语句 将数据表按名字进行分组，并统计每个人有多少条记录：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;mysql&amp;gt; SELECT name, COUNT(*) FROM   employee_tbl GROUP BY name;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;with-rollup&quot;&gt;WITH ROLLUP&lt;/h3&gt;
&lt;p&gt;WITH ROLLUP 可以实现在分组统计数据基础上再进行相同的统计（SUM,AVG,COUNT…）。&lt;/p&gt;
&lt;p&gt;例如我们将以上的数据表按名字进行分组，再统计每个人登录的次数：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;mysql&amp;gt; SELECT name, SUM(singin) as singin_count FROM  employee_tbl GROUP BY name WITH ROLLUP;
+--------+--------------+
| name   | singin_count |
+--------+--------------+
| 小丽 |            2 |
| 小明 |            7 |
| 小王 |            7 |
| NULL   |           16 |
+--------+--------------+
4 rows in set (0.00 sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中记录 NULL 表示所有人的登录次数。&lt;/p&gt;
&lt;p&gt;我们可以使用 coalesce 来设置一个可以取代 NUll 的名称，coalesce 语法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;select coalesce(a,b,c);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数说明：如果a=null,则选择b；如果b=null,则选择c；如果a!=null,则选择a；如果a b c 都为null ，则返回为null（没意义）。&lt;/p&gt;
&lt;p&gt;以下实例中如果名字为空我们使用总数代替：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; SELECT coalesce(name, '总数'), SUM(singin) as singin_count FROM  employee_tbl GROUP BY name WITH ROLLUP;
+--------------------------+--------------+
| coalesce(name, '总数') | singin_count |
+--------------------------+--------------+
| 小丽                   |            2 |
| 小明                   |            7 |
| 小王                   |            7 |
| 总数                   |           16 |
+--------------------------+--------------+
4 rows in set (0.01 sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;SELECT c.*
FROM (
    SELECT IFNULL(b.城市,&quot;总计&quot;) AS 城市,SUM(IF(b.年月=201607,b.金额,NULL)) AS 7月金额,SUM(IF(b.年月=201608,b.金额,NULL)) AS 8月金额,SUM(IF(b.年月=201609,b.金额,NULL)) AS 9月金额
    FROM (
        SELECT IFNULL(city,'空城市') AS 城市,DATE_FORMAT(order_time,&quot;%Y%m&quot;) AS 年月,SUM(pay_money) AS 金额
        FROM test_a03order AS a
        GROUP BY city,DATE_FORMAT(order_time,&quot;%Y%m&quot;)
    ) AS b
    GROUP BY b.城市 WITH ROLLUP
) AS c
ORDER BY FIELD(城市,'总计'),c.9月金额 DESC
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;连接&quot;&gt;连接&lt;/h2&gt;
&lt;p&gt;你可以在 SELECT, UPDATE 和 DELETE 语句中使用 Mysql 的 JOIN 来联合多表查询。&lt;/p&gt;
&lt;p&gt;JOIN 按照功能大致分为如下三类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;INNER JOIN（内连接,或等值连接）&lt;/strong&gt;：获取两个表中字段匹配关系的记录。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;LEFT JOIN（左连接）：&lt;/strong&gt;获取左表所有记录，即使右表没有对应匹配的记录。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RIGHT JOIN（右连接）：&lt;/strong&gt; 与 LEFT JOIN 相反，用于获取右表所有记录，即使左表没有对应匹配的记录。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;mysql&amp;gt; SELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a INNER JOIN tcount_tbl b ON a.runoob_author = b.runoob_author;

mysql&amp;gt; SELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a, tcount_tbl b WHERE a.runoob_author = b.runoob_author;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;left join 与 join 有所不同。 MySQL LEFT JOIN 会读取左边数据表的全部数据，即便右边表无对应数据。&lt;/p&gt;
&lt;p&gt;尝试以下实例，以 &lt;strong&gt;runoob_tbl&lt;/strong&gt; 为左表，&lt;strong&gt;tcount_tbl&lt;/strong&gt; 为右表，理解 MySQL LEFT JOIN 的应用：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;mysql&amp;gt; SELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a LEFT JOIN tcount_tbl b ON a.runoob_author = b.runoob_author;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;用集合去理解&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;null&quot;&gt;NULL&lt;/h2&gt;
&lt;p&gt;MySQL 使用 SQL SELECT 命令及 WHERE 子句来读取数据表中的数据,但是当提供的查询条件字段为 NULL 时，该命令可能就无法正常工作。&lt;/p&gt;
&lt;p&gt;为了处理这种情况，MySQL提供了三大运算符:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;IS NULL:&lt;/strong&gt; 当列的值是 NULL,此运算符返回 true。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;IS NOT NULL:&lt;/strong&gt; 当列的值不为 NULL, 运算符返回 true。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&amp;lt;=&amp;gt;:&lt;/strong&gt; 比较操作符（不同于 = 运算符），当比较的的两个值相等或者都为 NULL 时返回 true。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;关于 NULL 的条件比较运算是比较特殊的。你不能使用 = NULL 或 != NULL 在列中查找 NULL 值 。在 MySQL 中，NULL 值与任何其它值的比较（即使是 NULL）永远返回 NULL，即 NULL = NULL 返回 NULL 。&lt;/p&gt;
&lt;p&gt;MySQL 中处理 NULL 使用 IS NULL 和 IS NOT NULL 运算符。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;select * , columnName1+ifnull(columnName2,0) from tableName;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;columnName1，columnName2 为 int 型，当 columnName2 中，有值为 null 时，columnName1+columnName2=null， ifnull(columnName2,0) 把 columnName2 中 null 值转为 0。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mysql&amp;gt; SELECT * from runoob_test_tbl WHERE runoob_count IS NOT NULL;&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;事务&quot;&gt;事务&lt;/h2&gt;
&lt;p&gt;MySQL 事务主要用于处理&lt;strong&gt;操作量大，复杂度高&lt;/strong&gt;的数据。比如说，在人员管理系统中，你删除一个人员，你既需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。&lt;/li&gt;
&lt;li&gt;事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。&lt;/li&gt;
&lt;li&gt;事务用来管理 insert,update,delete 语句&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一般来说，事务是必须满足4个条件（ACID）：：原子性（&lt;strong&gt;A&lt;/strong&gt;tomicity，或称不可分割性）、一致性（&lt;strong&gt;C&lt;/strong&gt;onsistency）、隔离性（&lt;strong&gt;I&lt;/strong&gt;solation，又称独立性）、持久性（&lt;strong&gt;D&lt;/strong&gt;urability）。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;原子性：&lt;/strong&gt;一个事务（transaction）中的所有操作，&lt;strong&gt;要么全部完成，要么全部不完成&lt;/strong&gt;，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一致性：&lt;/strong&gt;在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;隔离性：&lt;/strong&gt;数据库&lt;strong&gt;允许多个并发事务同时对其数据进行读写和修改的能力&lt;/strong&gt;，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;持久性：&lt;/strong&gt;事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;在 MySQL 命令行的默认设置下，事务都是自动提交的，即执行 SQL 语句后就会马上执行 COMMIT 操作。因此&lt;strong&gt;要显式地开启一个事务务须使用命令 BEGIN 或 START TRANSACTION，或者执行命令 SET AUTOCOMMIT=0，用来禁止使用当前会话的自动提交。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;事务控制语句&quot;&gt;事务控制语句&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;BEGIN 或 START TRANSACTION 显式地开启一个事务；&lt;/li&gt;
&lt;li&gt;COMMIT 也可以使用 COMMIT WORK，不过二者是等价的。COMMIT 会提交事务，并使已对数据库进行的所有修改成为永久性的；&lt;/li&gt;
&lt;li&gt;ROLLBACK 也可以使用 ROLLBACK WORK，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改；&lt;/li&gt;
&lt;li&gt;SAVEPOINT identifier，SAVEPOINT 允许&lt;strong&gt;在事务中创建一个保存点&lt;/strong&gt;，一个事务中可以有多个 SAVEPOINT；&lt;/li&gt;
&lt;li&gt;RELEASE SAVEPOINT identifier 删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常；&lt;/li&gt;
&lt;li&gt;ROLLBACK TO identifier 把事务回滚到标记点；&lt;/li&gt;
&lt;li&gt;SET TRANSACTION 用来&lt;strong&gt;设置事务的隔离级别&lt;/strong&gt;。InnoDB 存储引擎提供事务的隔离级别有READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ 和 SERIALIZABLE。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;mysql-事务处理&quot;&gt;MYSQL 事务处理&lt;/h3&gt;
&lt;p&gt;1、用 BEGIN, ROLLBACK, COMMIT来实现&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;BEGIN&lt;/strong&gt; 开始一个事务&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ROLLBACK&lt;/strong&gt; 事务回滚&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;COMMIT&lt;/strong&gt; 事务确认&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;2、直接用 SET 来改变 MySQL 的自动提交模式:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;SET AUTOCOMMIT=0&lt;/strong&gt; 禁止自动提交&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SET AUTOCOMMIT=1&lt;/strong&gt; 开启自动提交&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;表的修改&quot;&gt;表的修改&lt;/h2&gt;
&lt;h3 id=&quot;alter&quot;&gt;alter&lt;/h3&gt;
&lt;p&gt;当我们需要修改数据表名或者修改数据表字段时，就需要使用到MySQL ALTER命令。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;删&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如下命令使用了 ALTER 命令及 DROP 子句来删除以上创建表的 i 字段：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;mysql&amp;gt; ALTER TABLE testalter_tbl  DROP i;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果数据表中只剩余一个字段则无法使用DROP来删除字段。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;增&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MySQL 中使用 ADD 子句来向数据表中添加列，如下实例在表 testalter_tbl 中添加 i 字段，并定义数据类型:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;mysql&amp;gt; ALTER TABLE testalter_tbl ADD i INT;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行以上命令后，i 字段会自动添加到数据表字段的末尾。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;移位&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你需要指定新增字段的位置，可以使用MySQL提供的关键字 FIRST (设定位第一列)， AFTER 字段名（设定位于某个字段之后）。&lt;/p&gt;
&lt;p&gt;尝试以下 ALTER TABLE 语句, 在执行成功后，使用 SHOW COLUMNS 查看表结构的变化：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ALTER TABLE testalter_tbl DROP i;
ALTER TABLE testalter_tbl ADD i INT FIRST;
ALTER TABLE testalter_tbl DROP i;
ALTER TABLE testalter_tbl ADD i INT AFTER c;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;FIRST 和 AFTER 关键字可用于 ADD 与 MODIFY 子句，所以如果你想重置数据表字段的位置就需要先使用 DROP 删除字段然后使用 ADD 来添加字段并设置位置。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;删除外键约束&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;keyName是外键别名&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;alter table tableName drop foreign key keyName;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;修改名称和类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果需要修改字段类型及名称, 你可以在ALTER命令中使用 MODIFY 或 CHANGE 子句 。&lt;/p&gt;
&lt;p&gt;例如，把字段 c 的类型从 CHAR(1) 改为 CHAR(10)，可以执行以下命令:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;mysql&amp;gt; ALTER TABLE testalter_tbl MODIFY c CHAR(10);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用 CHANGE 子句, 语法有很大的不同。 在 CHANGE 关键字之后，紧跟着的是你要修改的字段名，然后指定新字段名及类型。尝试如下实例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;mysql&amp;gt; ALTER TABLE testalter_tbl CHANGE i j BIGINT;
mysql&amp;gt; ALTER TABLE testalter_tbl CHANGE j j INT;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Null 值和默认值的影响&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当你修改字段时，你可以指定是否包含值或者是否设置默认值。&lt;/p&gt;
&lt;p&gt;以下实例，指定字段 j 为 NOT NULL 且默认值为100 。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;mysql&amp;gt; ALTER TABLE testalter_tbl 
    -&amp;gt; MODIFY j BIGINT NOT NULL DEFAULT 100;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你不设置默认值，MySQL会自动设置该字段默认为 NULL。&lt;/p&gt;
&lt;p&gt;使用 ALTER 来修改字段的默认值，尝试以下实例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;mysql&amp;gt; ALTER TABLE testalter_tbl ALTER i SET DEFAULT 1000;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用 ALTER 命令及 DROP子句来删除字段的默认值，如下实例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;mysql&amp;gt; ALTER TABLE testalter_tbl ALTER i DROP DEFAULT;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;数据表类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;修改数据表类型，可以使用 ALTER 命令及 TYPE 子句来完成。尝试以下实例，我们将表 testalter_tbl 的类型修改为 MYISAM ：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;查看数据表类型可以使用 SHOW TABLE STATUS 语句。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;mysql&amp;gt; ALTER TABLE testalter_tbl ENGINE = MYISAM;
mysql&amp;gt;  SHOW TABLE STATUS LIKE 'testalter_tbl'\G
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;修改表名&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果需要修改数据表的名称，可以在 ALTER TABLE 语句中使用 RENAME 子句来实现。&lt;/p&gt;
&lt;p&gt;尝试以下实例将数据表 testalter_tbl 重命名为 alter_tbl：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;mysql&amp;gt; ALTER TABLE testalter_tbl RENAME TO alter_tbl;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;索引&quot;&gt;索引&lt;/h2&gt;
&lt;p&gt;索引分单列索引和组合索引。单列索引，即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引。组合索引，即一个索引包含多个列。&lt;/p&gt;
&lt;p&gt;创建索引时，你需要确保该索引是应用在 SQL 查询语句的条件(一般作为 WHERE 子句的条件)。&lt;/p&gt;
&lt;p&gt;实际上，索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录。&lt;/p&gt;
&lt;p&gt;上面都在说使用索引的好处，但过多的使用索引将会造成滥用。因此索引也会有它的缺点：&lt;strong&gt;虽然索引大大提高了查询速度，同时却会降低更新表的速度&lt;/strong&gt;，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，&lt;strong&gt;还要保存一下索引文件&lt;/strong&gt;。建立索引会占用磁盘空间的索引文件。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;普通索引&quot;&gt;普通索引&lt;/h3&gt;
&lt;h4 id=&quot;创建&quot;&gt;创建&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;CREATE INDEX indexName ON mytable(username(length)); 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定 length。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;创建表的时候直接指定&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;CREATE TABLE mytable(  
ID INT NOT NULL,   
username VARCHAR(16) NOT NULL,  
INDEX [indexName] (username(length))  
);  
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;添加&quot;&gt;添加&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;ALTER table tableName ADD INDEX indexName(columnName)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;删除&quot;&gt;删除&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;DROP INDEX [indexName] ON mytable; 
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;唯一索引&quot;&gt;唯一索引&lt;/h3&gt;
&lt;p&gt;它与前面的普通索引类似，不同的就是：&lt;strong&gt;索引列的值必须唯一&lt;/strong&gt;，但允许有空值。如果是组合索引，则列值的组合必须唯一。&lt;/p&gt;
&lt;h4 id=&quot;创建索引&quot;&gt;创建索引&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;CREATE UNIQUE INDEX indexName ON mytable(username(length)) 
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;修改表结构&quot;&gt;修改表结构&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;ALTER table mytable ADD UNIQUE [indexName] (username(length))
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;创建表的时候直接指定&quot;&gt;创建表的时候直接指定&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;CREATE TABLE mytable(  
 
ID INT NOT NULL,   
 
username VARCHAR(16) NOT NULL,  
 
UNIQUE [indexName] (username(length))  
 
);  
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;使用alter-命令添加和删除索引&quot;&gt;使用ALTER 命令添加和删除索引&lt;/h3&gt;
&lt;p&gt;有四种方式来添加数据表的索引：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;ALTER TABLE tbl_name ADD PRIMARY KEY (column_list):&lt;/strong&gt;该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ALTER TABLE tbl_name ADD UNIQUE index_name (column_list):&lt;/strong&gt; 这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ALTER TABLE tbl_name ADD INDEX index_name (column_list):&lt;/strong&gt; 添加普通索引，索引值可出现多次。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list):&lt;/strong&gt;该语句指定了索引为 FULLTEXT ，用于全文索引。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以下实例为在表中添加索引。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; ALTER TABLE testalter_tbl ADD INDEX (c);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你还可以在 ALTER 命令中使用 DROP 子句来删除索引。尝试以下实例删除索引:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; ALTER TABLE testalter_tbl DROP INDEX c;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;使用-alter-命令添加和删除主键&quot;&gt;使用 ALTER 命令添加和删除主键&lt;/h3&gt;
&lt;p&gt;主键只能作用于一个列上，添加主键索引时，你需要确保该主键默认不为空（NOT NULL）。实例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; ALTER TABLE testalter_tbl MODIFY i INT NOT NULL;
mysql&amp;gt; ALTER TABLE testalter_tbl ADD PRIMARY KEY (i);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你也可以使用 ALTER 命令删除主键：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; ALTER TABLE testalter_tbl DROP PRIMARY KEY;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;删除主键时只需指定PRIMARY KEY，但在删除索引时，你必须知道索引名。&lt;/p&gt;
&lt;h3 id=&quot;显示索引&quot;&gt;显示索引&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; SHOW INDEX FROM table_name; \G
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;表操作&quot;&gt;表操作&lt;/h2&gt;
&lt;h3 id=&quot;临时表&quot;&gt;临时表&lt;/h3&gt;
&lt;p&gt;MySQL 临时表在我们需要保存一些临时数据时是非常有用的。临时表只在当前连接可见，当关闭连接时，Mysql会自动删除表并释放所有空间。&lt;/p&gt;
&lt;p&gt;如果你使用了其他MySQL客户端程序连接MySQL数据库服务器来创建临时表，那么只有在关闭客户端程序时才会销毁临时表，当然你也可以手动销毁。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;mysql&amp;gt; CREATE TEMPORARY TABLE SalesSummary (
    -&amp;gt; product_name VARCHAR(50) NOT NULL
    -&amp;gt; , total_sales DECIMAL(12,2) NOT NULL DEFAULT 0.00
    -&amp;gt; , avg_unit_price DECIMAL(7,2) NOT NULL DEFAULT 0.00
    -&amp;gt; , total_units_sold INT UNSIGNED NOT NULL DEFAULT 0
);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当你使用 &lt;strong&gt;SHOW TABLES&lt;/strong&gt;命令显示数据表列表时，你将无法看到 SalesSummary表。&lt;/p&gt;
&lt;p&gt;如果你退出当前MySQL会话，再使用 &lt;strong&gt;SELECT&lt;/strong&gt;命令来读取原先创建的临时表数据，那你会发现数据库中没有该表的存在，因为在你退出时该临时表已经被销毁了。&lt;/p&gt;
&lt;p&gt;用 &lt;strong&gt;DROP TABLE&lt;/strong&gt; 命令来手动删除临时表。&lt;/p&gt;
&lt;p&gt;用查询直接创建临时表的方式：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;CREATE TEMPORARY TABLE 临时表名 AS
(
    SELECT *  FROM 旧的表名
    LIMIT 0,10000
);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;复制表&quot;&gt;复制表&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;使用 &lt;strong&gt;SHOW CREATE TABLE&lt;/strong&gt; 命令获取创建数据表(&lt;strong&gt;CREATE TABLE&lt;/strong&gt;) 语句，该语句包含了原数据表的结构，索引等。&lt;/li&gt;
&lt;li&gt;复制以下命令显示的SQL语句，修改数据表名，并执行SQL语句，通过以上命令 将完全的复制数据表结构。&lt;/li&gt;
&lt;li&gt;如果你想复制表的内容，你就可以使用 &lt;strong&gt;INSERT INTO ... SELECT&lt;/strong&gt; 语句来实现。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;mysql&amp;gt; SHOW CREATE TABLE runoob_tbl \G;
*************************** 1. row ***************************
       Table: runoob_tbl
Create Table: CREATE TABLE `runoob_tbl` (
  `runoob_id` int(11) NOT NULL auto_increment,
  `runoob_title` varchar(100) NOT NULL default '',
  `runoob_author` varchar(40) NOT NULL default '',
  `submission_date` date default NULL,
  PRIMARY KEY  (`runoob_id`),
  UNIQUE KEY `AUTHOR_INDEX` (`runoob_author`)
) ENGINE=InnoDB 
1 row in set (0.00 sec)

ERROR:
No query specified



mysql&amp;gt; CREATE TABLE `clone_tbl` (
  -&amp;gt; `runoob_id` int(11) NOT NULL auto_increment,
  -&amp;gt; `runoob_title` varchar(100) NOT NULL default '',
  -&amp;gt; `runoob_author` varchar(40) NOT NULL default '',
  -&amp;gt; `submission_date` date default NULL,
  -&amp;gt; PRIMARY KEY  (`runoob_id`),
  -&amp;gt; UNIQUE KEY `AUTHOR_INDEX` (`runoob_author`)
-&amp;gt; ) ENGINE=InnoDB;
Query OK, 0 rows affected (1.80 sec)



mysql&amp;gt; INSERT INTO clone_tbl (runoob_id,
    -&amp;gt;                        runoob_title,
    -&amp;gt;                        runoob_author,
    -&amp;gt;                        submission_date)
    -&amp;gt; SELECT runoob_id,runoob_title,
    -&amp;gt;        runoob_author,submission_date
    -&amp;gt; FROM runoob_tbl;
Query OK, 3 rows affected (0.07 sec)
Records: 3  Duplicates: 0  Warnings: 0
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另一种完整复制表的方法:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;CREATE TABLE targetTable LIKE sourceTable;  
只复制表结构到新表

INSERT INTO targetTable SELECT * FROM sourceTable;
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;复制表结构及数据到新表
create table 新表 select * from 旧表 
# 有*号没AS
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以拷贝一个表中其中的一些字段:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;CREATE TABLE newadmin AS
(
    SELECT username, password FROM admin
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以将新建的表的字段改名:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;CREATE TABLE newadmin AS
(  
    SELECT id, username AS uname, password AS pass FROM admin
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以在创建表的同时定义表中的字段信息:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;CREATE TABLE newadmin
(
    id INTEGER NOT NULL AUTO_INCREMENT PRIMARY KEY
)
AS
(
    SELECT * FROM admin
)  
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;序列&quot;&gt;序列&lt;/h2&gt;
&lt;h3 id=&quot;auto_increment&quot;&gt;AUTO_INCREMENT&lt;/h3&gt;
&lt;p&gt;MySQL 序列是一组整数：1, 2, 3, ...，由于一张数据表只能有一个字段自增主键， 如果你想实现其他字段也实现自动增加，就可以使用MySQL序列来实现。&lt;/p&gt;
&lt;p&gt;MySQL 中最简单使用序列的方法就是使用 MySQL AUTO_INCREMENT 来定义列。&lt;/p&gt;
&lt;p&gt;在MySQL的客户端中你可以使用 SQL中的LAST_INSERT_ID( ) 函数来获取最后的插入表中的自增列的值。&lt;/p&gt;
&lt;h3 id=&quot;uuid&quot;&gt;UUID&lt;/h3&gt;
&lt;p&gt;在mysql5.0之前，如果是多个master复制的环境，无法用自增主键，因为可能重复。在5.0以及之后的版本通过配置自增偏移量解决了整个问题。&lt;/p&gt;
&lt;p&gt;uuid全球唯一。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么情况下我们希望用uuid&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;避免重复&lt;/strong&gt;，便于scale，这就是我们做cloud service的时候选择uuid的主要原因&lt;/li&gt;
&lt;li&gt;入库之前可以知道id&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;相对安全，不能简单的从uuid获取信息&lt;/strong&gt;，但是如果自增，则容易暴露信息，如果一个客户id是123456，很容易猜到有客户id是123456.&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;在我们实际到项目中会碰到问题，历史数据表的主键id会与数据表的id重复，两张自增id做主键的表合并时，id一定会有冲突，但如果各自的id还关联了其他表，这就很不好操作。&lt;/p&gt;
&lt;p&gt;如果使用UUID，生成的ID不仅是表独立的，而且是库独立的。对以后的数据操作很有好处，可以说一劳永逸。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;UUID有什么问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.uuid有16个字节，比int（4 byte）和bigint（8 byte）占用更多存储空间&lt;/p&gt;
&lt;p&gt;2.由于size和无序性，&lt;strong&gt;可能引起性能问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;缺点:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;影响插入速度&lt;/strong&gt;， 并且造成硬盘使用率低&lt;/li&gt;
&lt;li&gt;uuid之间比较大小相对数字慢不少， &lt;strong&gt;影响查询速度&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;uuid占空间大， 如果你&lt;strong&gt;建的索引越多， 影响越严重&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;优点：出现数据拆分、合并存储的时候，能达到全局的唯一性&lt;/p&gt;
&lt;h4 id=&quot;uuid-与-自增主键&quot;&gt;uuid 与 自增主键&lt;/h4&gt;
&lt;p&gt;InnoDB主索引：&lt;strong&gt;叶节点包含了完整的数据记录。这种索引叫做聚集索引&lt;/strong&gt;。InnoDB 的索引能提供一种非常快速的主键查找性能。不过，它的&lt;strong&gt;辅助索引也会包含主键列&lt;/strong&gt;，所以，如果主键定义的比较大，其他索引也将很大。如果想在表上定义 、很多索引，则&lt;strong&gt;争取尽量把主键定义得小一些&lt;/strong&gt;。InnoDB 不会压缩索引&lt;/p&gt;
&lt;p&gt;聚集索引这种实现方式使得按主键的搜索十分高效，但是&lt;strong&gt;辅助索引搜索需要检索两遍索引&lt;/strong&gt;：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。&lt;/p&gt;
&lt;p&gt;(1).如果InnoDB表的数据写入顺序能和B+树索引的叶子节点顺序一致的话，这时候存取效率是最高的。&lt;strong&gt;为了存储和查询性能应该使用自增长id做主键。&lt;/strong&gt; （如果自增索引作为主键构造B+树，那B+树的创建过程将会很“均匀”，每层铺满才会下一层）&lt;/p&gt;
&lt;p&gt;(2).对于InnoDB的主索引，数据会按照主键进行排序，&lt;strong&gt;由于UUID的无序性，InnoDB会产生巨大的IO压力&lt;/strong&gt;，此时不适合使用UUID做物理主键，可以把它作为逻辑主键，物理主键依然使用自增ID。&lt;strong&gt;为了全局的唯一性，应该用uuid做索引关联其他表或做外键。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果是uuid的形式，频繁的插入会使innodb频繁地移动磁盘块，写入性能就比较低了。&lt;/p&gt;
&lt;h3 id=&quot;重置序列&quot;&gt;重置序列&lt;/h3&gt;
&lt;p&gt;如果你删除了数据表中的多条记录，并希望对剩下数据的AUTO_INCREMENT列进行重新排列，那么你可以通过删除自增的列，然后重新添加来实现。 不过该操作要非常小心，&lt;strong&gt;如果在删除的同时又有新记录添加，有可能会出现数据混乱&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;mysql&amp;gt; ALTER TABLE insect DROP id;
mysql&amp;gt; ALTER TABLE insect
    -&amp;gt; ADD id INT UNSIGNED NOT NULL AUTO_INCREMENT FIRST,
    -&amp;gt; ADD PRIMARY KEY (id);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;设置序列的开始值&quot;&gt;设置序列的开始值&lt;/h3&gt;
&lt;p&gt;一般情况下序列的开始值为1，但如果你需要指定一个开始值100，那我们可以通过以下语句来实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;mysql&amp;gt; CREATE TABLE insect
    -&amp;gt; (
    -&amp;gt; id INT UNSIGNED NOT NULL AUTO_INCREMENT,
    -&amp;gt; PRIMARY KEY (id),
    -&amp;gt; name VARCHAR(30) NOT NULL, 
    -&amp;gt; date DATE NOT NULL,
    -&amp;gt; origin VARCHAR(30) NOT NULL
)engine=innodb auto_increment=100 charset=utf8;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者你也可以在表创建成功后，通过以下语句来实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;mysql&amp;gt; ALTER TABLE t AUTO_INCREMENT = 100;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;处理重复数据&quot;&gt;处理重复数据&lt;/h2&gt;
&lt;h3 id=&quot;防止表中出现重复数据&quot;&gt;防止表中出现重复数据&lt;/h3&gt;
&lt;p&gt;你可以在 MySQL 数据表中设置指定的字段为 PRIMARY KEY（主键） 或者 UNIQUE（唯一） 索引来保证数据的唯一性。&lt;/p&gt;
&lt;p&gt;如果你设置了双主键，那么那个键的默认值不能为 NULL，可设置为 NOT NULL。如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;CREATE TABLE person_tbl
(
   first_name CHAR(20) NOT NULL,
   last_name CHAR(20) NOT NULL,
   sex CHAR(10),
   PRIMARY KEY (last_name, first_name)
);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;INSERT IGNORE INTO 与 INSERT INTO 的区别就是 &lt;strong&gt;INSERT IGNORE 会忽略数据库中已经存在的数据&lt;/strong&gt;，如果数据库没有数据，就插入新的数据，如果有数据的话就跳过这条数据。这样就可以保留数据库中已经存在数据，达到在间隙中插入数据的目的。&lt;/p&gt;
&lt;p&gt;以下实例使用了 INSERT IGNORE INTO，执行后不会出错，也不会向数据表中插入重复数据：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;mysql&amp;gt; INSERT IGNORE INTO person_tbl (last_name, first_name)
    -&amp;gt; VALUES( 'Jay', 'Thomas');
Query OK, 1 row affected (0.00 sec)
mysql&amp;gt; INSERT IGNORE INTO person_tbl (last_name, first_name)
    -&amp;gt; VALUES( 'Jay', 'Thomas');
Query OK, 0 rows affected (0.00 sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;INSERT IGNORE INTO 当插入数据时，在设置了记录的唯一性后，如果插入重复数据，将不返回错误，只以警告形式返回。 而 &lt;strong&gt;REPLACE INTO 如果存在 primary 或 unique 相同的记录，则先删除掉。再插入新记录。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;另一种设置数据的唯一性方法是添加一个 UNIQUE 索引，如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;CREATE TABLE person_tbl
(
   first_name CHAR(20) NOT NULL,
   last_name CHAR(20) NOT NULL,
   sex CHAR(10),
   UNIQUE (last_name, first_name)
);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;统计重复数据&quot;&gt;统计重复数据&lt;/h3&gt;
&lt;p&gt;以下我们将统计表中 first_name 和 last_name的重复记录数：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;mysql&amp;gt; SELECT COUNT(*) as repetitions, last_name, first_name
    -&amp;gt; FROM person_tbl
    -&amp;gt; GROUP BY last_name, first_name
    -&amp;gt; HAVING repetitions &amp;gt; 1;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上查询语句将返回 person_tbl 表中重复的记录数。 一般情况下，查询重复的值，请执行以下操作：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;确定哪一列包含的值可能会重复。&lt;/li&gt;
&lt;li&gt;在列选择列表使用COUNT(*)列出的那些列。&lt;/li&gt;
&lt;li&gt;在GROUP BY子句中列出的列。&lt;/li&gt;
&lt;li&gt;HAVING子句设置重复数大于1。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;过滤重复数据&quot;&gt;过滤重复数据&lt;/h3&gt;
&lt;p&gt;如果你需要读取不重复的数据可以在 SELECT 语句中使用 DISTINCT 关键字来过滤重复数据。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;mysql&amp;gt; SELECT DISTINCT last_name, first_name
    -&amp;gt; FROM person_tbl;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你也可以使用 GROUP BY 来读取数据表中不重复的数据：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;mysql&amp;gt; SELECT last_name, first_name
    -&amp;gt; FROM person_tbl
    -&amp;gt; GROUP BY (last_name, first_name);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;删除重复数据&quot;&gt;删除重复数据&lt;/h3&gt;
&lt;p&gt;如果你想删除数据表中的重复数据，你可以使用以下的SQL语句：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;mysql&amp;gt; CREATE TABLE tmp SELECT last_name, first_name, sex FROM person_tbl  GROUP BY (last_name, first_name, sex);
mysql&amp;gt; DROP TABLE person_tbl;
mysql&amp;gt; ALTER TABLE tmp RENAME TO person_tbl;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然你也可以在数据表中添加 INDEX（索引） 和 PRIMAY KEY（主键）这种简单的方法来删除表中的重复记录。方法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;mysql&amp;gt; ALTER IGNORE TABLE person_tbl
    -&amp;gt; ADD PRIMARY KEY (last_name, first_name);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;导出入数据&quot;&gt;导出/入数据&lt;/h2&gt;
&lt;h3 id=&quot;select--into-outfile-语句导出数据&quot;&gt;SELECT ... INTO OUTFILE 语句导出数据&lt;/h3&gt;
&lt;p&gt;以下实例中我们将数据表 runoob_tbl 数据导出到 /tmp/runoob.txt 文件中:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;mysql&amp;gt; SELECT * FROM runoob_tbl 
    -&amp;gt; INTO OUTFILE '/tmp/runoob.txt';
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你可以通过命令选项来设置数据输出的指定格式，以下实例为导出 CSV 格式：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;mysql&amp;gt; SELECT * FROM passwd INTO OUTFILE '/tmp/runoob.txt'
    -&amp;gt; FIELDS TERMINATED BY ',' ENCLOSED BY '&quot;'
    -&amp;gt; LINES TERMINATED BY '\r\n';
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在下面的例子中，生成一个文件，各值用逗号隔开。这种格式可以被许多程序使用。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;SELECT a,b,a+b INTO OUTFILE '/tmp/result.text'
FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '&quot;'
LINES TERMINATED BY '\n'
FROM test_table;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;mysqldump导出表&quot;&gt;mysqldump导出表&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;mysqldump&lt;/strong&gt; 是 mysql 用于转存储数据库的实用程序。它主要产生一个 SQL 脚本，其中包含从头重新创建数据库所必需的命令 CREATE TABLE INSERT 等。&lt;/p&gt;
&lt;p&gt;使用 &lt;strong&gt;mysqldump&lt;/strong&gt; 导出数据需要使用 &lt;strong&gt;--tab&lt;/strong&gt; 选项来指定导出文件指定的目录，该目标必须是可写的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;以下实例将数据表 runoob_tbl 导出到 /tmp 目录中
$ mysqldump -u root -p --no-create-info \
            --tab=/tmp RUNOOB runoob_tbl
password ******


导出 SQL 格式的数据到指定文件
$ mysqldump -u root -p RUNOOB runoob_tbl &amp;gt; dump.txt
password ******


需要备份所有数据库，可以使用以下命令：
$ mysqldump -u root -p --all-databases &amp;gt; database_dump.txt
password ******
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;导入表&quot;&gt;导入表&lt;/h3&gt;
&lt;p&gt;如果你需要将备份的数据库导入到MySQL服务器中，可以使用以下命令，使用以下命令你需要确认数据库已经创建：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;$ mysql -u root -p database_name &amp;lt; dump.txt
password *****
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用 mysql 命令导入语法格式为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;mysql -u用户名    -p密码    &amp;lt;  要导入的数据库数据(runoob.sql)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;MySQL 中提供了LOAD DATA INFILE语句来插入数据。 以下实例中将从当前目录中读取文件 dump.txt ，将该文件中的数据插入到当前数据库的 mytbl 表中。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;mysql&amp;gt; LOAD DATA LOCAL INFILE 'dump.txt' INTO TABLE mytbl;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　如果指定LOCAL关键词，则表明从客户主机上按路径读取文件。如果没有指定，则文件在服务器上按路径读取文件。&lt;/p&gt;
&lt;p&gt;如果用户指定一个 FIELDS 子句，它的子句 （TERMINATED BY、[OPTIONALLY] ENCLOSED BY 和 ESCAPED BY) 也是可选的，不过，用户必须至少指定它们中的一个。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;mysql&amp;gt; LOAD DATA LOCAL INFILE 'dump.txt' INTO TABLE mytbl
  -&amp;gt; FIELDS TERMINATED BY ':'
  -&amp;gt; LINES TERMINATED BY '\r\n';
  
  
mysql&amp;gt; LOAD DATA LOCAL INFILE 'dump.txt' 
  -&amp;gt; INTO TABLE mytbl (b, c, a);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;mysqlimport&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;函数&quot;&gt;函数&lt;/h2&gt;
&lt;p&gt;含义：一组预先编译好的SQL语句的集合，理解成批处理语句&lt;/p&gt;
&lt;p&gt;函数：有且仅有1 个返回，合适做处理数据后返回一个结果 做查询一个值&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;注意：
1.参数列表包含两部分：参数名 参数类型
2.函数体：肯定会有return语句，如果没有会报错
如果return语句放在函数的最后也不报错，但不建议
3.函数题中仅有一句话，则可以省略begin end
4.使用 delimter语句设置结束标记






#二、调用语法
SELECT 函数名(参数列表)
执行函数中所有语句 函数中有显示的语句他也能显示 有插入修改也能做，执行完把显示值返回出来
CREATE FUNCTION myf1() RETURNS INT
BEGIN
        DECLARE c INT DEFAULT 0;#定义局部变量
        SELECT COUNT(*) INTO c #赋值与c
        FROM employees;    
        RETURN c;
END$&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 11 Apr 2020 00:11:00 +0000</pubDate>
<dc:creator>friedCoder</dc:creator>
<og:description>mySQL 安装 windows windows mysqld initialize console 报错 出现Failed to find valid data directory. 初始化数据库：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/friedCoder/p/12677592.html</dc:identifier>
</item>
<item>
<title>【Redis】集群NetCore实战 - WilsonPan</title>
<link>http://www.cnblogs.com/WilsonPan/p/12677478.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/WilsonPan/p/12677478.html</guid>
<description>&lt;p class=&quot;ws-title&quot;&gt;环境准备&lt;/p&gt;
&lt;div class=&quot;ws-content&quot; readability=&quot;38.042718446602&quot;&gt;
&lt;p&gt;1. Redis集群（&lt;a href=&quot;https://www.cnblogs.com/WilsonPan/p/12643221.html&quot; target=&quot;_blank&quot;&gt;Windows集群搭建&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;启动Redis集群，给每个节点加上Title&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
start &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Redis - 6379&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /min redis-server.exe redis.&lt;span&gt;6379&lt;/span&gt;&lt;span&gt;.conf
start &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Redis - 6380&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /min redis-server.exe redis.&lt;span&gt;6380&lt;/span&gt;&lt;span&gt;.conf
start &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Redis - 6381&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /min redis-server.exe redis.&lt;span&gt;6381&lt;/span&gt;&lt;span&gt;.conf
start &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Redis - 6382&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /min redis-server.exe redis.&lt;span&gt;6382&lt;/span&gt;&lt;span&gt;.conf
start &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Redis - 6383&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /min redis-server.exe redis.&lt;span&gt;6383&lt;/span&gt;&lt;span&gt;.conf
start &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Redis - 6384&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /min redis-server.exe redis.&lt;span&gt;6384&lt;/span&gt;.conf
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2. 安装StackExchange.Redis包&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
dotnet add package StackExchange.Redis
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p class=&quot;ws-title&quot;&gt;连接Redis&lt;/p&gt;
&lt;div class=&quot;ws-content&quot; readability=&quot;52.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; configString = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;127.0.0.1:6379&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; options =&lt;span&gt; ConfigurationOptions.Parse(configString);
options.ReconnectRetryPolicy &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ExponentialRetry(&lt;span&gt;5000&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; client = ConnectionMultiplexer.Connect(options);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里只需要提供一个节点就能访问整个集群&lt;/p&gt;
&lt;p&gt;ConnectionMultiplexer 连接Redis可以使用ConfigurationOptions，或者直接字符串初始化（里面实现也是调用ConfigurationOptions.Parse转换）&lt;/p&gt;
&lt;p&gt;这里要说一下是他的重连重试机制，在第一次创建连接的时候，StackExchange.Redis会创建一个心跳检测&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;internal&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; IDisposable Create(ConnectionMultiplexer connection)
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; token = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TimerToken(connection);
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; timer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Timer(Heartbeat, token, MillisecondsPerHeartbeat, MillisecondsPerHeartbeat);
    token.SetTimer(timer);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; timer;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用System.Threading.Timer每秒钟检查一次。&lt;/p&gt;
&lt;p&gt;StackExchange.Redis 实现两种重试策略，当然我们也可以实现自己的重现策略，实现IReconnectRetryPolicy接口&lt;/p&gt;
&lt;ul&gt;&lt;li&gt; ExponentialRetry（指数）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　　根据指定时间，根据重试次数不断增大随机数范围&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;LinearRetry（线性）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　　根据指定时间固定时间间隔重试&lt;/p&gt;
&lt;/div&gt;
&lt;p class=&quot;ws-title&quot;&gt;常用数据结构操作&lt;/p&gt;
&lt;div class=&quot;ws-content&quot; readability=&quot;64.5&quot;&gt;
&lt;p&gt;&lt;strong&gt;字符串(String)操作&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; RedisStringOperation(ConnectionMultiplexer client)
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; db =&lt;span&gt; client.GetDatabase();

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;单个Key操作&lt;/span&gt;
    db.StringSet(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Key&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Wilson&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Get Key : {db.StringGet(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;Key&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    db.StringSet(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Nums&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    db.StringIncrement(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Nums&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Get Nums : {db.StringGet(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;Nums&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    db.StringDecrement(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Nums&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Get Nums : {db.StringGet(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;Nums&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;多个Key操作&lt;/span&gt;
    db.StringSet(&lt;span&gt;new&lt;/span&gt; KeyValuePair&amp;lt;RedisKey, RedisValue&amp;gt;&lt;span&gt;[]
    {
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; KeyValuePair&amp;lt;RedisKey, RedisValue&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{user}Name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Wilson&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; KeyValuePair&amp;lt;RedisKey, RedisValue&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{user}Age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;30&lt;/span&gt;&lt;span&gt;)
    });

    &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; value &lt;span&gt;in&lt;/span&gt; db.StringGet(&lt;span&gt;new&lt;/span&gt; RedisKey[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{user}Name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{user}Age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; }))
    {
        Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{value}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;哈希(Hash)操作&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; RedisHashOperation(ConnectionMultiplexer client)
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; db =&lt;span&gt; client.GetDatabase();

    db.HashSet(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;person&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Wilson&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    Console.WriteLine(db.HashGet(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;person&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));

    db.HashSet(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;person&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HashEntry[]
    {
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; HashEntry(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Wilson&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; HashEntry(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
    });
    Console.WriteLine(&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;.Join(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, db.HashGet(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;person&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; RedisValue[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; })));

    Console.WriteLine(&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;.Join(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, db.HashGetAll(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;person&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)));
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;列表(List) 操作&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; RedisListOperation(ConnectionMultiplexer client)
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; db =&lt;span&gt; client.GetDatabase();

    db.ListLeftPush(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;&lt;span&gt;);
    db.ListLeftPush(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;200&lt;/span&gt;&lt;span&gt;);
    db.ListLeftPush(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;300&lt;/span&gt;&lt;span&gt;);
    db.ListRightPush(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;400&lt;/span&gt;&lt;span&gt;);
    db.ListRightPush(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;500&lt;/span&gt;&lt;span&gt;);

    Console.WriteLine(db.ListLeftPop(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
    Console.WriteLine(db.ListRightPop(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
    Console.WriteLine(&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;.Join(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\t&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, db.ListRange(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)));
    Console.WriteLine(db.ListLength(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;集合(Set)&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; RedisSetOperation(ConnectionMultiplexer client)
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; db =&lt;span&gt; client.GetDatabase();

    db.SetAdd(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Wilson&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    db.SetAdd(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Wilson&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    db.SetAdd(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Alice&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    Console.WriteLine(db.SetLength(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
    Console.WriteLine(db.SetPop(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
    Console.WriteLine(&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;.Join(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, db.SetMembers(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)));
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;有序集合(Sorted Set)&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; RedisSortedSetOperation(ConnectionMultiplexer client)
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; db =&lt;span&gt; client.GetDatabase();

    db.KeyDelete(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    db.SortedSetAdd(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Wilson&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;90&lt;/span&gt;&lt;span&gt;);
    db.SortedSetAdd(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Alice&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;85&lt;/span&gt;&lt;span&gt;);
    db.SortedSetAdd(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Trenary&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;12&lt;/span&gt;&lt;span&gt;);
    db.SortedSetAdd(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Nixon&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;30&lt;/span&gt;&lt;span&gt;);

    Console.WriteLine(db.SortedSetLength(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
    Console.WriteLine(db.SortedSetRemove(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Wilson&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
    Console.WriteLine(&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;.Join(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, db.SortedSetRangeByRank(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)));
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;div class=&quot;ws-content&quot; readability=&quot;6.6031746031746&quot;&gt;
&lt;p&gt;参考文章&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://stackexchange.github.io/StackExchange.Redis/&quot; target=&quot;_blank&quot;&gt;StackExchange.Redis | General purpose redis client&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Fri, 10 Apr 2020 19:01:00 +0000</pubDate>
<dc:creator>WilsonPan</dc:creator>
<og:description>介绍NetCore如何使用Redis集群</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/WilsonPan/p/12677478.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core WEB API 使用element-ui文件上传组件el-upload执行手动文件文件，并在文件上传后清空文件 - 追逐时光</title>
<link>http://www.cnblogs.com/Can-daydayup/p/12676870.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Can-daydayup/p/12676870.html</guid>
<description>&lt;h2&gt;前言：&lt;/h2&gt;
&lt;p&gt;　　从开始学习Vue到使用element-ui-admin已经有将近快两年的时间了，在之前的开发中使用element-ui上传组件el-upload都是直接使用文件选取后立即选择上传，今天刚好做了一个和之前类似的文件选择上传的需求，不过这次是需要手动点击按钮把文件上传到服务器中进行数据导入，而且最多只能够选择一个文件进行上传，上传成功后需要对file-list中的文件列表数据进行清空操作，在这里服务端使用的是ASP.NET Core WEB API来进行文件流数据接收和保存。&lt;/p&gt;
&lt;h2&gt;一、简单概述el-upload文件上传组件：&lt;/h2&gt;
&lt;h3&gt;el-upload组件详情，查看官方解释：&lt;/h3&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://element.eleme.cn/#/zh-CN/component/upload&quot;&gt;https://element.eleme.cn/#/zh-CN/component/upload&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;常用的基本属性：&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;可选值&lt;/th&gt;
&lt;th&gt;默认值&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;24.83844911147&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;action&lt;/td&gt;
&lt;td&gt;必选参数，上传的地址&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;—&lt;/td&gt;
&lt;td&gt;—&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;headers&lt;/td&gt;
&lt;td&gt;设置上传的请求头部&lt;/td&gt;
&lt;td&gt;object&lt;/td&gt;
&lt;td&gt;—&lt;/td&gt;
&lt;td&gt;—&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;multiple&lt;/td&gt;
&lt;td&gt;是否支持多选文件&lt;/td&gt;
&lt;td&gt;boolean&lt;/td&gt;
&lt;td&gt;—&lt;/td&gt;
&lt;td&gt;—&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;data&lt;/td&gt;
&lt;td&gt;上传时附带的额外参数&lt;/td&gt;
&lt;td&gt;object&lt;/td&gt;
&lt;td&gt;—&lt;/td&gt;
&lt;td&gt;—&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;name&lt;/td&gt;
&lt;td&gt;上传的文件字段名&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;—&lt;/td&gt;
&lt;td&gt;file&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;with-credentials&lt;/td&gt;
&lt;td&gt;支持发送 cookie 凭证信息&lt;/td&gt;
&lt;td&gt;boolean&lt;/td&gt;
&lt;td&gt;—&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;show-file-list&lt;/td&gt;
&lt;td&gt;是否显示已上传文件列表&lt;/td&gt;
&lt;td&gt;boolean&lt;/td&gt;
&lt;td&gt;—&lt;/td&gt;
&lt;td&gt;true&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;drag&lt;/td&gt;
&lt;td&gt;是否启用拖拽上传&lt;/td&gt;
&lt;td&gt;boolean&lt;/td&gt;
&lt;td&gt;—&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.7446808510638&quot;&gt;&lt;td&gt;accept&lt;/td&gt;
&lt;td&gt;接受上传的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#attr-accept&quot;&gt;文件类型&lt;/a&gt;（thumbnail-mode 模式下此参数无效）&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;—&lt;/td&gt;
&lt;td&gt;—&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;on-preview&lt;/td&gt;
&lt;td&gt;点击文件列表中已上传的文件时的钩子&lt;/td&gt;
&lt;td&gt;function(file)&lt;/td&gt;
&lt;td&gt;—&lt;/td&gt;
&lt;td&gt;—&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;on-remove&lt;/td&gt;
&lt;td&gt;文件列表移除文件时的钩子&lt;/td&gt;
&lt;td&gt;function(file, fileList)&lt;/td&gt;
&lt;td&gt;—&lt;/td&gt;
&lt;td&gt;—&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;on-success&lt;/td&gt;
&lt;td&gt;文件上传成功时的钩子&lt;/td&gt;
&lt;td&gt;function(response, file, fileList)&lt;/td&gt;
&lt;td&gt;—&lt;/td&gt;
&lt;td&gt;—&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;on-error&lt;/td&gt;
&lt;td&gt;文件上传失败时的钩子&lt;/td&gt;
&lt;td&gt;function(err, file, fileList)&lt;/td&gt;
&lt;td&gt;—&lt;/td&gt;
&lt;td&gt;—&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;on-progress&lt;/td&gt;
&lt;td&gt;文件上传时的钩子&lt;/td&gt;
&lt;td&gt;function(event, file, fileList)&lt;/td&gt;
&lt;td&gt;—&lt;/td&gt;
&lt;td&gt;—&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;on-change&lt;/td&gt;
&lt;td&gt;文件状态改变时的钩子，添加文件、上传成功和上传失败时都会被调用&lt;/td&gt;
&lt;td&gt;function(file, fileList)&lt;/td&gt;
&lt;td&gt;—&lt;/td&gt;
&lt;td&gt;—&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;before-upload&lt;/td&gt;
&lt;td&gt;上传文件之前的钩子，参数为上传的文件，若返回 false 或者返回 Promise 且被 reject，则停止上传。&lt;/td&gt;
&lt;td&gt;function(file)&lt;/td&gt;
&lt;td&gt;—&lt;/td&gt;
&lt;td&gt;—&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;before-remove&lt;/td&gt;
&lt;td&gt;删除文件之前的钩子，参数为上传的文件和文件列表，若返回 false 或者返回 Promise 且被 reject，则停止删除。&lt;/td&gt;
&lt;td&gt;function(file, fileList)&lt;/td&gt;
&lt;td&gt;—&lt;/td&gt;
&lt;td&gt;—&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;list-type&lt;/td&gt;
&lt;td&gt;文件列表的类型&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;text/picture/picture-card&lt;/td&gt;
&lt;td&gt;text&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;auto-upload&lt;/td&gt;
&lt;td&gt;是否在选取文件后立即进行上传&lt;/td&gt;
&lt;td&gt;boolean&lt;/td&gt;
&lt;td&gt;—&lt;/td&gt;
&lt;td&gt;true&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;file-list&lt;/td&gt;
&lt;td&gt;上传的文件列表, 例如: [{name: 'food.jpg', url: 'https://xxx.cdn.com/xxx.jpg'}]&lt;/td&gt;
&lt;td&gt;array&lt;/td&gt;
&lt;td&gt;—&lt;/td&gt;
&lt;td&gt;[]&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;http-request&lt;/td&gt;
&lt;td&gt;覆盖默认的上传行为，可以自定义上传的实现&lt;/td&gt;
&lt;td&gt;function&lt;/td&gt;
&lt;td&gt;—&lt;/td&gt;
&lt;td&gt;—&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;disabled&lt;/td&gt;
&lt;td&gt;是否禁用&lt;/td&gt;
&lt;td&gt;boolean&lt;/td&gt;
&lt;td&gt;—&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;limit&lt;/td&gt;
&lt;td&gt;最大允许上传个数&lt;/td&gt;
&lt;td&gt;number&lt;/td&gt;
&lt;td&gt;—&lt;/td&gt;
&lt;td&gt;—&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2&gt;二、需要实现的效果：&lt;/h2&gt;
&lt;p&gt;　　通过单击文件上传按钮，能够弹窗一个Dialog文件选择框，通过点击选取文件按钮选择需要导入的Excel文件，然后手动点击数据导入按钮将Excel文件流通过Post请求传输到ASP.NET Core后台服务中，并进行数据保存操作。&lt;/p&gt;
&lt;p&gt;弹出框效果如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1336199/202004/1336199-20200410230142542-1982757713.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt; 三、代码实现：&lt;/h2&gt;
&lt;h3&gt;前端Vue代码实现：&lt;/h3&gt;
&lt;h4&gt;&lt;strong&gt;注意，清空已上传的文件列表：&lt;/strong&gt;&lt;/h4&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;需要ref=&quot;upload&quot;和file-list=&quot;fileList&quot;这两个属性同时存在，否则即使调用this.$refs.upload.clearFiles();该方法也无效&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;&lt;strong&gt;Template代码：&lt;/strong&gt;&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
     &amp;lt;el-dialog title=&quot;数据导入&quot; :visible.sync=&quot;dialogVisible&quot; width=&quot;30%&quot; :before-close=&quot;handleClose&quot;&amp;gt;
      &amp;lt;el-upload
        class=&quot;upload-demo&quot;
        ref=&quot;upload&quot;
        :action=&quot;actionRequestUrl&quot;
        :on-preview=&quot;handlePreview&quot;
        :on-remove=&quot;handleRemove&quot;
        :on-success=&quot;fileUploadSuccess&quot;
        :on-error=&quot;fileUploadFail&quot;
        :on-change=&quot;fileChange&quot;
        :file-list=&quot;fileList&quot;
        :limit=&quot;1&quot;
        :auto-upload=&quot;false&quot;
        :headers=&quot;headers&quot;&amp;gt;
        &amp;lt;el-button slot=&quot;trigger&quot; size=&quot;small&quot; type=&quot;primary&quot;&amp;gt;选取文件&amp;lt;/el-button&amp;gt;
        &amp;lt;el-button size=&quot;small&quot; @click=&quot;downloadTemplate&quot;&amp;gt;导入模板下载&amp;lt;/el-button&amp;gt;
        &amp;lt;div slot=&quot;tip&quot; class=&quot;el-upload__tip&quot;&amp;gt;请按照导入模板中的数据格式导入&amp;lt;/div&amp;gt;
      &amp;lt;/el-upload&amp;gt;
      &amp;lt;span slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&amp;gt;
        &amp;lt;el-button @click=&quot;dialogVisible = false&quot;&amp;gt;取 消&amp;lt;/el-button&amp;gt;
        &amp;lt;!-- &amp;lt;el-button type=&quot;primary&quot; @click=&quot;dialogVisible = false&quot;&amp;gt;确 定&amp;lt;/el-button&amp;gt; --&amp;gt;
        &amp;lt;el-button style=&quot;margin-left: 10px;&quot; type=&quot;success&quot; @click=&quot;submitUpload&quot;&amp;gt;数据导入&amp;lt;/el-button&amp;gt;
        &amp;lt;!-- &amp;lt;div slot=&quot;tip&quot; class=&quot;el-upload__tip&quot;&amp;gt;只能上传jpg/png文件，且不超过500kb&amp;lt;/div&amp;gt; --&amp;gt;
      &amp;lt;/span&amp;gt;
    &amp;lt;/el-dialog&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;&lt;strong&gt;Js中代码：&lt;/strong&gt;&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;58&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&amp;lt;script&amp;gt;
 data() {
    return {
      fileList: [], //文件列表
      dialogVisible: false,//Dialog显示状态
      headers: { &quot;X-Token&quot;: jwtToken }//设置上传的请求头部
      fileDownloadUrl：'www.xxxx.com',//文件下载地址
      actionRequestUrl:'www.xxxx.com/fileUpload'//请求服务器接口地址
      }},
     //执行相关的方法
     methods: {
     //打开导入弹窗
    openImporDialog() {
      this.dialogVisible = true;
    },
    //关闭弹窗
    handleClose() {
      this.dialogVisible = false;
    },
    //上传到服务器
    submitUpload() {
      console.log(this.fileList);
      if (this.fileList.length &amp;lt;= 0) {
        this.$message.error(&quot;请先选择需要上传的文件！&quot;);
        return false;
      }
      this.$refs.upload.submit();
    },
    //文件上传服务端失败时的钩子
    fileUploadFail: function(err, file, fileList) {
      console.log(&quot;文件上传失败&quot;, file, fileList);
    },
    //  文件上传服务端成功时的钩子
    fileUploadSuccess: function(response, file, fileList) {
      console.log(&quot;上传成功&quot;);
      console.log(response);
      //清空已上传的文件列表
      this.$refs.upload.clearFiles();
      if (response.result) {
        this.dialogVisible = false;
        this.$message({
          message: response.message,
          type: &quot;success&quot;
        });
      } else {
        this.$message.error(response.message);
      }
    },
    //文件状态改变时的钩子，添加文件、上传成功和上传失败时都会被调用
    fileChange(file, fileList) {
      //解决无法判断el-upload是否上传过文件问题
      this.fileList = fileList;
      console.log(&quot;选择文件上传成功后显示的内容》&quot;, file, fileList);
    },
    //文件列表移除文件时的钩子
    handleRemove(file, fileList) {
      this.fileList = [];
      // return this.$confirm(`确定移除 ${file.name}？`);
    },&lt;br/&gt;//点击文件列表中已上传的文件时的钩子
    handlePreview(file) {
      console.log(file);
    },
    //导入模板下载
    downloadTemplate() {
      window.location.href =this.fileDownloadUrl+&quot;/xxxExcel导入模板.xlsx&quot;;
    }
    }
&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;服务端ASP.NET Core WEB API来进行文件流数据接收和保存：　　&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.IO;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Hosting;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Http;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Mvc;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; FileUploadManage.Controllers
{
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 图片，视频，音频，文档等相关文件通用上传服务类
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FileUploadController : Controller
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; IHostingEnvironment _hostingEnvironment;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; FileUploadController(IHostingEnvironment hostingEnvironment)
        {
            _hostingEnvironment &lt;/span&gt;=&lt;span&gt; hostingEnvironment;
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Form表单之单文件上传
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;formFile&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;form表单文件流信息&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; JsonResult FormSingleFileUpload(IFormFile formFile)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; currentDate =&lt;span&gt; DateTime.Now;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; webRootPath = _hostingEnvironment.WebRootPath;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;相当于HttpContext.Current.Server.MapPath(&quot;&quot;) &lt;/span&gt;

            &lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; filePath = $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/UploadFile/{currentDate:yyyyMMdd}/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建每日存储文件夹&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (!Directory.Exists(webRootPath +&lt;span&gt; filePath))
                {
                    Directory.CreateDirectory(webRootPath &lt;/span&gt;+&lt;span&gt; filePath);
                }

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (formFile != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文件后缀&lt;/span&gt;
                    &lt;span&gt;var&lt;/span&gt; fileExtension = Path.GetExtension(formFile.FileName);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取文件格式，拓展名

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断文件大小&lt;/span&gt;
                    &lt;span&gt;var&lt;/span&gt; fileSize =&lt;span&gt; formFile.Length;

                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (fileSize &amp;gt; &lt;span&gt;1024&lt;/span&gt; * &lt;span&gt;1024&lt;/span&gt; * &lt;span&gt;10&lt;/span&gt;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;10M TODO:(1mb=1024X1024b)&lt;/span&gt;
&lt;span&gt;                    {
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; JsonResult(&lt;span&gt;new&lt;/span&gt; { isSuccess = &lt;span&gt;false&lt;/span&gt;, resultMsg = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;上传的文件不能大于10M&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; });
                    }

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存的文件名称(以名称和保存时间命名)&lt;/span&gt;
                    &lt;span&gt;var&lt;/span&gt; saveName = formFile.FileName.Substring(&lt;span&gt;0&lt;/span&gt;, formFile.FileName.LastIndexOf(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + currentDate.ToString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HHmmss&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) +&lt;span&gt; fileExtension;

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文件保存&lt;/span&gt;
                    &lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; fs = System.IO.File.Create(webRootPath + filePath +&lt;span&gt; saveName))
                    {
                        formFile.CopyTo(fs);
                        fs.Flush();
                    }

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;完整的文件路径&lt;/span&gt;
                    &lt;span&gt;var&lt;/span&gt; completeFilePath =&lt;span&gt; Path.Combine(filePath, saveName);

                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; JsonResult(&lt;span&gt;new&lt;/span&gt; { isSuccess = &lt;span&gt;true&lt;/span&gt;, returnMsg = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;上传成功&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, completeFilePath =&lt;span&gt; completeFilePath });
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; JsonResult(&lt;span&gt;new&lt;/span&gt; { isSuccess = &lt;span&gt;false&lt;/span&gt;, resultMsg = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;上传失败，未检测上传的文件信息~&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; });
                }

            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; JsonResult(&lt;span&gt;new&lt;/span&gt; { isSuccess = &lt;span&gt;false&lt;/span&gt;, resultMsg = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;文件保存失败，异常信息为：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; ex.Message });
            }

        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Fri, 10 Apr 2020 18:40:00 +0000</pubDate>
<dc:creator>追逐时光</dc:creator>
<og:description>前言： 从开始学习Vue到使用element-ui-admin已经有将近快两年的时间了，在之前的开发中使用element-ui上传组件el-upload都是直接使用文件选取后立即选择上传，今天刚好做了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Can-daydayup/p/12676870.html</dc:identifier>
</item>
<item>
<title>深入解读ES6系列（四） - DDDZ</title>
<link>http://www.cnblogs.com/Three-Z/p/12677455.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Three-Z/p/12677455.html</guid>
<description>&lt;ul&gt;&lt;li&gt;哈喽小伙伴们，爱说‘废’话的Z又回来了，欢迎来到Super IT曾的博客时间，上一节说了字符串，面向对象以及json的知识，这一节我们继续我们知识的海洋，一起奋斗不秃头！不足的欢迎提问留言。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200409215916725.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;我发誓我真的没有P图😂，没想到这个系列被小编看上了，从发布这个系列起就都上热门了，怪害羞的，哈哈让人老脸一红的既视感，既然如此！我会认真把这个系列做完的，然后带你们搞项目搞框架！我们一起搞事情！那现在我们就开始吧！这一节是es6结局哦，下节就要说es789....的啦哈哈哈。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200409220705543.gif#pic_center&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li&gt;老曾英语教学开始，promise是什么，是承诺，我可是一言九鼎的人啊，别说四匹马，四十匹马都拉不回来我，那么解释起来promise就是这件事我肯定会做，至于多久做嘛~反正肯定会做的对吧！那么promise和我们es6有什么关系呢？我们先卖个关子。&lt;/li&gt;
&lt;li&gt;这里就要先提到两个东西了，相信有一定基础的小伙伴一定知道我想说啥，对就是异步和同步。&lt;/li&gt;
&lt;/ul&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;两步&lt;/th&gt;
&lt;th&gt;特点1&lt;/th&gt;
&lt;th&gt;特点2&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;异步&lt;/td&gt;
&lt;td&gt;操作之间没啥关系，可同时进行多个操作&lt;/td&gt;
&lt;td&gt;代码更复杂&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;同步&lt;/td&gt;
&lt;td&gt;同时只能做一件事&lt;/td&gt;
&lt;td&gt;代码简单&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;那么你肯定又想问异步和同步项目中怎么应用的？我拿它来干嘛？我打个比方：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200410000914179.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1oyNjk1NzE2Mjc=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;这里的图片数据文字数据等等都不是写死的吧，都需要从后台去拿，如果你使用异步，这时候就好比这种代码，也叫回调地狱，这种好吓人哦，要是上百条数据上千条那怎么遭得住，不知道你们遭得住不，反正我是遭不住。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;//callback-hell 回调地狱
getFileContent('a.json',data =&amp;gt; {
    console.log(&quot;data&quot;,data)
    getFileContent(data.next, data2 =&amp;gt;{
        console.log('data2',data2)
        getFileContent(data2.next, data3 =&amp;gt;{
            console.log('data3',data3)
        })
    })
})
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个时候就要请出我们的Promise了，它的作用就是用来消除异步操作，它具体是怎么的呢？一句话概括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;用同步的方式，书写异步的代码&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;promise到底怎么用&quot;&gt;Promise到底怎么用&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;我们以一个ajax示例来看，你说你不知道ajax怎么办，没关系，你跟着看，以我对你的了解你看得懂哈哈，至少不影响代码阅读，跟着看了之后，回头自己个儿再看一下&lt;a href=&quot;https://www.w3school.com.cn/ajax/index.asp&quot;&gt;ajax教程&lt;/a&gt;你就完全懂了，废话暂时到这，先看目录结构：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200410193349551.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200410193408187.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200410193417383.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/li&gt;
&lt;li&gt;现在，问题来了，我要在index里面ajax请求这两个json文件，成功打印出里面json内容，失败则弹出失败，想想怎么做？提示一点，Promise.all的使用：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200410193635283.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;script src=&quot;https://cdn.bootcss.com/jquery/3.4.1/jquery.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
        &amp;lt;script&amp;gt;
                let p1 = new Promise((resolve, reject) =&amp;gt;{
                        //异步代码
                        $.ajax({
                                url: 'dataA.text',
                                dataType: 'json',
                                success(arr) {
                                        resolve(arr)
                                },
                                error(err) {
                                        reject(err)
                                }
                        })
                })
                
                let p2 = new Promise((resolve, reject) =&amp;gt;{
                        $.ajax({
                                url: 'dataB.text',
                                dataType: 'json',
                                success(arr) {
                                        resolve(arr)
                                },
                                error(err) {
                                        reject(err)
                                }
                        })
                })
                
                Promise.all([
                        p1,p2
                ]).then((arr) =&amp;gt;{
                        let [resA,resB] = arr
                        alert(&quot;all success&quot;)
                        console.log(resA,resB)
                },(err) =&amp;gt;{
                        alert(&quot;fails&quot;)
                        console.log(err)
                })
        &amp;lt;/script&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;光看代码有没有理解一点呢，别急代码会继续优化，我们先来解析代码，使用箭头函数和解构赋值的地方都是我们前面博客说过的咯，忘记的童鞋就自己翻看一下老曾之前的博文啦，当然我也是贴心大暖男，放图来给你注释解析：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;有道翻译 resolve--解决了,reject--拒绝了&lt;/li&gt;
&lt;li&gt;那拿到我们这里就明明白白了,resolve成功,reject失败&lt;br/&gt;图一，对应请求成功失败的执行以及返回：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200410194749583.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1oyNjk1NzE2Mjc=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/li&gt;
&lt;li&gt;Promise对应成功失败的执行以及返回，绿字对绿框，紫字对紫框，红字对红框，顺便一提，无论是请求或是什么，有失败的函数一定要执行养成良好的习惯，我之前就不爱写失败的返回，蜜汁自信有没有哈哈哈，就会导致有时候不知道错误原因。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200410203737704.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1oyNjk1NzE2Mjc=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;这样我怕你还不知道p1,p2，我给你打印一下可好？😋毕竟自己的粉自己疼p1,p2，console的代码中间有个逗号哈，只不过被线遮住了，看图就发现是promise对象：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200410210713851.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1oyNjk1NzE2Mjc=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;现在来简化代码，我说过，我是个懒人，虽说p1和p2直接ctrl c+ctrl v再改改一个字母代码就好了，但我都懒得复制粘贴，两大坨代码看着就emm那啥，我们一个函数封装一下嘛：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;script&amp;gt;
        function createPromise(url){
                return new Promise((resolve, reject) =&amp;gt;{
                        $.ajax({
                                url: url,
                                dataType: 'json',
                                success(arr) {
                                        resolve(arr)
                                },
                                error(err) {
                                        reject(err)
                                }
                        })

                })
        }
        let p1 = createPromise(&quot;dataA.text&quot;)
        let p2 = createPromise(&quot;dataB.text&quot;)
        Promise.all([
                p1,p2
        ]).then((arr) =&amp;gt;{
                let [resA,resB] = arr
                alert(&quot;all success&quot;)
                console.log(resA,resB)
        },(err) =&amp;gt;{
                alert(&quot;fails&quot;)
                console.log(err)
        })
&amp;lt;/script&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样就清爽的多了有没有，当然这远远不够，你还能像到更优化的吗？不能的话就跟着来，看看代码打印出啥？&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;let p = $.ajax({url:'dataA.text',dataTape:'json'})
console.log(p)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200410205528223.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1oyNjk1NzE2Mjc=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;发现没jQuery返回的本身就有promise对象，所以我们不用自己用p1,p2接收一个promise，现在直接用就好了：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;script&amp;gt;
        Promise.all([
                $.ajax({url:&quot;dataA.text&quot;,dataType:'json'}),
                $.ajax({url:'dataB.text',dataTape:'json'})      
        ]).then((arr) =&amp;gt;{
                console.log(&quot;success&quot;,arr)
        },(err) =&amp;gt;{
                console.log('fail',err)
        })
&amp;lt;/script&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样是不是爽多了有没有！！！！&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200410211030510.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1oyNjk1NzE2Mjc=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;这才是Promise的完美用法，Promise.all是必须全部成功才执行成功，更像‘与’有没有，这里我们提一下另外一个，Promise.race，这个的话意思就是那个来了就先执行哪个，有一个成功都会执行成功的函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;generator的基本功能&quot;&gt;generator的基本功能&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;这是个啥？英语不好不存在哇搜一搜，翻译过来就是生成器。那这个有啥用？通俗易懂的来对比一下。&lt;/li&gt;
&lt;li&gt;普通函数：一路到底 —— 高铁火车&lt;/li&gt;
&lt;li&gt;generator函数：随叫随停 —— 出租车&lt;br/&gt;那么我们就来看看这个generator和普通函数有啥不同？瞅瞅看打印出来是啥？猜猜？说实话我最开始也不知道哈哈哈😄，这里提示一下yield翻译过来是放弃的意思，我们这里把他理解为暂时放弃。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;script&amp;gt;
        function *show(){
                alert('a');
                yield;
                alert('b')
        }
        show()
&amp;lt;/script&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你是不是觉得会弹出一个a，没想到吧，啥也没有，控制台也不报错，这时候咋办呢？&lt;code&gt;alert(show())&lt;/code&gt;，同时&lt;code&gt;console.log(show())&lt;/code&gt;一下，查看一下呢？&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200410215542579.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;alert出来的倒没啥，就告诉你执行出来是个生成器对象，但是当我们看他里面的时候就会发现里面有一个next方法，这个就很重要了。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200410220102959.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1oyNjk1NzE2Mjc=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;那我们就来&lt;code&gt;show().next();&lt;/code&gt;执行一下看看是个啥？&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020041023250529.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;那如果既要显示a又要显示b呢？我们试试这样写：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-JavaScript&quot;&gt; let obj = show()
        obj.next();
        obj.next();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200410234748291.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;这样a，b就都出来了，这里只放了b，所以next给人的感觉就是踹一步走一下的感觉对吧。那你要问老曾老曾这个generator的原理是怎么实现走走停停的呢？你猜我给你说不说哈哈，当然要说。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;generator的基本原理在这里就是把原来的*show()函数划分为了两个小函数，当然你是看不见的，这里就相当于划分为了show1和show2，各自执行alert('a')和alert('b')。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;细说yield&quot;&gt;细说yield&lt;/h2&gt;
&lt;h3 id=&quot;yield传参&quot;&gt;yield传参&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;上一个小点我们刚说了，yield是暂时放弃的意思，同时也对Promise有了一个基本的了解，那来看看这段代码你能猜对执行结果嘛？&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;script&amp;gt;
        function *show(){
                alert('a');
                let a = yield;
                alert('b');
                alert(a);
        }
        let gen = show();
        gen.next(12);
        gen.next(5);
&amp;lt;/script&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200411001602523.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200411001612142.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;注意重点来了！&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200411001623243.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;5？？？有没有怀疑人生？哈哈我很懵逼啊表示，来来来我们来分析一下两个next分别执行的是*show的哪两段代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200411002059654.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1oyNjk1NzE2Mjc=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;第一次next是不是应该是白框框的代码，碰到yield暂停了嘛，第二次next就是黄框框的代码。所以&lt;code&gt;gen.next(5);&lt;/code&gt;是给谁传递的值，看黄框框，是不是就是给&lt;code&gt;let a&lt;/code&gt;传递的值，这样不难理解吧。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;那你说如果想给上面白框框alert值怎么办？&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;function *show(num1,num2){
                alert(`${num1} ${num2}`)
                alert('a');
                
                let a = yield;
                
                alert('b');
                alert(a);
        }
        let gen = show(9,99);
        gen.next(12);
        gen.next(5);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020041100283730.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;这样就可以了嘛，所以也可以看出第一个next对于yield传参是废的，是没有用的好吧。&lt;/p&gt;
&lt;h3 id=&quot;yield返回&quot;&gt;yield返回&lt;/h3&gt;
&lt;p&gt;*来来来，yield传参玩完了我们来说说返回，一样一样来猜猜代码执行结果是什么？&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;script&amp;gt;
        function *show(){
                alert('a');             
                yield 12;       
                alert('b');
                return 55;
        }
        let gen = show();
        let res1 = gen.next();
        console.log(res1)       
        let res2 = gen.next();
        console.log(res2)
&amp;lt;/script&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200411003619520.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/202004110036331.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200411003937147.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;相信机智的你至少已经看出来了一点，这里的done就是是否执行完毕，那按照之前白框框和黄框框的理解，返回value是12和55能理解吗？还不能理解的话我们就来继续看~&lt;/p&gt;
&lt;h3 id=&quot;yield到底是个啥&quot;&gt;yield到底是个啥&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;这里咱就不搞代码了，咱来搞一个接地气的伪代码，你来品品：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200411005117198.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1oyNjk1NzE2Mjc=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;说白了就像是一个厨房的分工以yield隔开，各做各的事情，就这么简单，还不懂得小伙伴评论区留言哦~&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;generator的实例&quot;&gt;generator的实例&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;介绍完了generator也了解了它的基本使用，那我们不是说它也可以用来消除异步操作嘛？那具体是怎么做的呢？&lt;/li&gt;
&lt;li&gt;首先我们需要一个runner文件，我会把它放在github上，文章末尾有github链接点进去在es6的15的文件夹里就可以看到啦，没找到文件的可以私聊我😊。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200411011635251.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;script src=&quot;https://cdn.bootcss.com/jquery/3.4.1/jquery.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&quot;runner.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
        runner(function *(){
                let data1 = yield $.ajax({url:'dataA.text',dataType:'json'})
                let data2 = yield $.ajax({url:'dataB.text',dataType:'json'})
                let data3 = yield $.ajax({url:'dataC.text',dataType:'json'})
                console.log(data1,data2,data3)
        })
&amp;lt;/script&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对应的dataA,B,C就有了，这里要注意一点就是我们第一个$.ajax返回的promise返回给了谁，我们这里其实返回给了runner去处理然后yield暂停，处理完了后就会回到data1继续执行，完了第二个ajax就会给data2，依次data3。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020041101171222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1oyNjk1NzE2Mjc=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;回调&quot;&gt;回调&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;//回调
$.ajax({
  url: xxx,
  dataType: 'json'
  success(data1){
    $.ajax({
      url: xxx,
      dataType: 'json'
      success(data2){
        $.ajax({
          url: xxx,
          dataType: 'json'
          success(data3){
            //完事儿
          },
          error(){
            alert('错了');
          }
        });
      },
      error(){
        alert('错了');
      }
    });
  },
  error(){
    alert('错了');
  }
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;promise-2&quot;&gt;Promise&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;//Promise
Promise.all([
  $.ajax({url: xxx, dataType: 'json'}),
  $.ajax({url: xxx, dataType: 'json'}),
  $.ajax({url: xxx, dataType: 'json'})
]).then(results=&amp;gt;{
  //完事儿
}, err=&amp;gt;{
  alert('错了');
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;generator-2&quot;&gt;generator&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;//generator
runner(function *(){
  let data1=yield $.ajax({url: xxx, dataType: 'json'});
  let data2=yield $.ajax({url: xxx, dataType: 'json'});
  let data3=yield $.ajax({url: xxx, dataType: 'json'});
  //完事儿
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;promise的缺点&quot;&gt;Promise的缺点&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;光看上面的11.2和11.3是不是感觉两个差别不大，确实，但是如果promise带逻辑，就比如一个用户登录了是vip怎么怎么样，不是VIP又怎么怎么样？这个时候我们的代码是什么样子的呢？&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;//带逻辑-Promise
Promise.all([
  $.ajax({url: 'getUserData', dataType: 'json'})
]).then(results=&amp;gt;{
  let userData=results[0];
  if(userData.type=='VIP'){
    Promise.all([
      $.ajax({url: 'getVIPItems', dataType: 'json'})
    ]).then(results=&amp;gt;{
      let items=results[0];
      //生成列表、显示...
    }, err=&amp;gt;{
      alert('错了');
    });
  }else{
    Promise.all([
      $.ajax({url: 'getItems', dataType: 'json'})
    ]).then(results=&amp;gt;{
      let items=results[0];
      //生成列表、显示...
    }, err=&amp;gt;{
      alert('错了');
    });
  }
}, err=&amp;gt;{
  alert('失败');
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我的天一大堆，来看看普通回调，这个时候说实话我还不如用普通回调。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;//带逻辑-普通回调
$.ajax({url: 'getUserData', dataType: 'json', success(userData){
  if(userData.type=='VIP'){
    $.ajax({url: 'getVIPItems', dataType: 'json', success(items){
      //生成列表、显示...
    }, error(err){
      alert('错了');
    }});
  }else{
    $.ajax({url: 'getItems', dataType: 'json', success(items){
      //生成列表、显示...
    }, error(err){
      alert('错了');
    }});
  }
}, error(err){
  alert('错了');
}});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;普通回调都比Promise好对吧，但是有了generator，来看看它怎么写？&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;//带逻辑-generator
runner(function *(){
  let userData=yield $.ajax({url: 'getUserData', dataType: 'json'});
  if(userData.type=='VIP'){
    let items=yield $.ajax({url: 'getVIPItems', dataType: 'json'});
  }else{
    let items=yield $.ajax({url: 'getItems', dataType: 'json'});
  }
  //生成、...
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个时候是不是感觉他的优势一下子就显现出来了，就和我们平时的普通函数执行一样，简单粗暴。&lt;/p&gt;
&lt;p&gt;好了到这里我们的ES6说的就差不多了！！！！！！！！四个系列终于说完。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200411014029258.gif#pic_center&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;———————————————————————分割线——————&lt;br/&gt;都看到这里了，只能说明一点，咱俩真的真的真的很有缘分啊！不点个赞再走嘛，😊😀，顺手加个关注嘛，偷偷收藏我博文的小可爱我后台看得到的嘛，点个赞给老曾支持支持，不出意外接下来我一直都在哈哈哈，学知识写博客不着急，基础打好，项目直接上手6到飞起。&lt;/p&gt;
&lt;p&gt;下节说ES7，及之后版本的内容&lt;/p&gt;
&lt;p&gt;放上我的，主要博客&lt;a href=&quot;https://www.cnblogs.com/Three-Z&quot;&gt;博客园&lt;/a&gt;，&lt;a href=&quot;https://blog.csdn.net/Z269571627&quot;&gt;CSDN&lt;/a&gt;，&lt;a href=&quot;https://github.com/269571627/MyGit/tree/web&quot;&gt;GitHub&lt;/a&gt;，&lt;a href=&quot;http://pipe.b3log.org/blogs/DDDZ&quot;&gt;pipe&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 10 Apr 2020 17:45:00 +0000</pubDate>
<dc:creator>DDDZ</dc:creator>
<og:description>来自老曾es6的前言： 哈喽小伙伴们，爱说‘废’话的Z又回来了，欢迎来到Super IT曾的博客时间，上一节说了字符串，面向对象以及json的知识，这一节我们继续我们知识的海洋，一起奋斗不秃头！不足的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Three-Z/p/12677455.html</dc:identifier>
</item>
<item>
<title>Python多线程同步、互斥锁、死锁 - 白加黑呀</title>
<link>http://www.cnblogs.com/congyiwei/p/12677359.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/congyiwei/p/12677359.html</guid>
<description>&lt;p&gt;接着上篇多线程继续讲，上篇最后的多线程共享全局变量对变量的处理值出错在本文中给出解决方案。&lt;/p&gt;
&lt;p&gt;出现这个情况的原因是在python解释器中GIL全局解释器锁。&lt;/p&gt;
&lt;p&gt; GIL:全局解释器锁，每个线程在执行的过程都需要先获取GIL，保证同一时刻只有一个线程而已执行代码&lt;/p&gt;
&lt;p&gt;线程释放GIL锁的情况：在IO操作等呃能会引起阻塞的system call之前，可以暂时释放GIL&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但在执行完毕后，必须重新获取GIL， Python3中使用计时器（执行时间打到阀值后，当前线程释放GIL）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;python使用多线程是并发 可以使用多线程利用多核的CPU资源&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;cpu密集型：也成为计算密集型，任务的特点是要进行大量的计算，消耗cpu资源，比如计算圆周率、对视频进行高清解码等等&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;全靠cpu的运算能力 这个时候单线程快&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;io密集型：涉及到网络、磁盘IO的任务都是IO密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成，因为 IO的速度远远低于CPU和内存的速度 这个时候多线程快。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么如何解决多线程共享全局变量数据错误的问题呢，引入锁。&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; threading

a &lt;/span&gt;= 100


&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func1():
    &lt;/span&gt;&lt;span&gt;global&lt;/span&gt;&lt;span&gt; a
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(1000000&lt;span&gt;):
        meta.acquire()  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 上锁&lt;/span&gt;
        a += 1&lt;span&gt;
        meta.release()  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 释放锁&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(a)


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func2():
    &lt;/span&gt;&lt;span&gt;global&lt;/span&gt;&lt;span&gt; a
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(1000000&lt;span&gt;):
        meta.acquire()
        a &lt;/span&gt;+= 1&lt;span&gt;
        meta.release()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(a)


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建锁&lt;/span&gt;
meta =&lt;span&gt; threading.Lock()


t1 &lt;/span&gt;= threading.Thread(target=&lt;span&gt;func1)  
t2 &lt;/span&gt;= threading.Thread(target=&lt;span&gt;func2)
t1.start()
t2.start()
t1.join()
t2.join()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(a)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;至于锁的原理在下方粗略的画一张草图以供参考&lt;img src=&quot;https://img2020.cnblogs.com/blog/1845338/202004/1845338-20200411005009143-1836806566.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 使用锁让每个线程有序的切换执行，不会出现数据混乱。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;但是在使用锁的时候要注意不要写出死锁代码，附死锁代码参考，总结一句就是互相持有对方线程所需要的锁，造成死锁&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; threading

a &lt;/span&gt;= 100


&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func1():
    &lt;/span&gt;&lt;span&gt;global&lt;/span&gt;&lt;span&gt; a
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(1000000&lt;span&gt;):
        meta_A.acquire()  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 上锁&lt;/span&gt;
        meta_B.acquire()  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 上多把锁 产生了死锁 看下面代码&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-------------1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        a &lt;/span&gt;+= 1&lt;span&gt;
        meta_B.release()
        meta_A.release()  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 释放锁&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(a)


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func2():
    &lt;/span&gt;&lt;span&gt;global&lt;/span&gt;&lt;span&gt; a
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(1000000&lt;span&gt;):
        meta_B.acquire()
        meta_A.acquire()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;------------2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        a &lt;/span&gt;+= 1&lt;span&gt;
        meta_A.release()
        meta_B.release()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(a)


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建锁&lt;/span&gt;
meta_A =&lt;span&gt; threading.Lock()
meta_B &lt;/span&gt;=&lt;span&gt; threading.Lock()


t1 &lt;/span&gt;= threading.Thread(target=&lt;span&gt;func1) 
t2 &lt;/span&gt;= threading.Thread(target=&lt;span&gt;func2)
t1.start()
t2.start()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;今天就写到这里，下一篇写一下队列&lt;/p&gt;
</description>
<pubDate>Fri, 10 Apr 2020 16:30:00 +0000</pubDate>
<dc:creator>白加黑呀</dc:creator>
<og:description>接着上篇多线程继续讲，上篇最后的多线程共享全局变量对变量的处理值出错在本文中给出解决方案。 出现这个情况的原因是在python解释器中GIL全局解释器锁。 GIL:全局解释器锁，每个线程在执行的过程都</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/congyiwei/p/12677359.html</dc:identifier>
</item>
<item>
<title>常用数据结构 - Pam_sh</title>
<link>http://www.cnblogs.com/pam-sh/p/12664175.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pam-sh/p/12664175.html</guid>
<description>&lt;h2&gt;1 数组、字符串【Array、String】&lt;/h2&gt;
&lt;h3&gt;1.1 字符串转化&lt;/h3&gt;
&lt;p&gt;数组和字符串是最基本的数据结构，在很多编程语言中都有着十分相似的性质，而围绕着它们的算法面试题也是最多的。&lt;/p&gt;
&lt;p&gt;很多时候，在分析字符串相关面试题的过程中，我们往往要针对字符串当中的每一个字符进行分析和处理，甚至有时候我们得先&lt;strong&gt;把给定的字符串转换成字符数组&lt;/strong&gt;之后再进行分析和处理。&lt;/p&gt;
&lt;p&gt;举例：翻转字符串“algorithm”。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://s0.lgstatic.com/i/image2/M01/90/CA/CgoB5l2IRiCATj5LAGJa69BtQRA357.gif&quot; alt=&quot;&quot; width=&quot;469&quot; height=&quot;220&quot;/&gt;&lt;/p&gt;
&lt;p&gt;解法：用两个指针，一个指向字符串的第一个字符a，一个指向它的最后一个字符m，然后互相交换。交换之后，两个指针向中央一步步地靠拢并相互交换字符，直到两个指针相遇。这是一种比较快速和直观的方法。...&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
//翻转字符串“algorithm”
int main()
{
    char temp,a[] = &quot;algorithm&quot;;
    int i,j,length = strlen(a);
    temp = NULL;
    i = 0;
    j = length - 1;
    while(i != j)
    {
        temp = a[i];
        a[i] = a[j];
        a[j] = temp;
        i++;
        j--;
    }
    for(i = 0;i &amp;lt; length;i++)
    {
        printf(&quot;%c\t&quot;,a[i]);
    }
    return 0;
}
&lt;/pre&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/1928790/202004/1928790-20200408123437247-1435782644.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;h3&gt;1.2数组的优缺点　　&lt;/h3&gt;
&lt;p&gt;数组的优点在于：&lt;/p&gt;
&lt;p&gt;　　构建非常简单&lt;/p&gt;
&lt;p&gt;　　能在O(1)的时间里根据数组的下标（index）查询某个元素&lt;/p&gt;
&lt;p&gt;而数组的缺点在于：&lt;/p&gt;
&lt;p&gt;　　构建时必须分配一段连续的空间&lt;/p&gt;
&lt;p&gt;　　查询某个元素是否存在时需要遍历整个数组，耗费 O(n) 的时间（其中，n 是元素的个数）&lt;/p&gt;
&lt;p&gt;　　删除和添加某个元素时，同样需要耗费 O(n) 的时间&lt;/p&gt;
&lt;h3&gt;1.3【242】有效的字母异位词&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1928790/202004/1928790-20200408123805656-168609185.png&quot; alt=&quot;&quot; width=&quot;482&quot; height=&quot;421&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字母异位词：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;也就是两个字符串中的相同字符的数量要对应相等。例如，s等于“anagram”，t等于“nagaram”，s和t就互为字母异位词。因为它们都包含有三个字符a，一个字符g，一个字符 m，一个字符 n，以及一个字符 r。而当 s 为 “rat”，t 为 “car”的时候，s 和 t 不互为字母异位词。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解题思路：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个重要的前提“假设两个字符串只包含小写字母”，小写字母一共也就26个，因此：&lt;/p&gt;
&lt;p&gt;知识点：&lt;a href=&quot;https://www.cnblogs.com/pam-sh/p/12663952.html&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;哈希映射&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　可以利用两个长度都为26的字符数组来统计每个字符串中小写字母出现的次数，然后再对比是否相等；&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

int isAnagram(char * s, char * t)
{
    //判断两个字符串长度是否相等，不相等则直接返回 false
    if(strlen(s) != strlen(t))
        return 0;
    //若相等，则初始化 26 个字母哈希表，遍历字符串 s 和 t
    int A[26] = {0},B[26] = {0};  //哈希映射
    int i;
    while(*s != '\0')
    {
        A[*s - 'a']++;
        B[*t - 'a']++;
        s++;
        t++;
    }
    //判断两个表是否相同
    for(i = 0; i &amp;lt; 26; i++)
    {
        if(A[i] != B[i])
            return 0;
    }
    return 1;
}
int main()
{
    char b[] = &quot;nagaram&quot;,a[] = &quot;anagram&quot;;
    if(isAnagram(a,b) != 0)
        printf(&quot;True&quot;);
    else
        printf(&quot;False&quot;);
    return 0;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　可以只利用一个长度为 26 的字符数组，将出现在字符串 s 里的字符个数加 1，而出现在字符串 t 里的字符个数减 1，最后判断每个小写字母的个数是否都为 0。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

int isAnagram(char * s, char * t)
{
    //判断两个字符串长度是否相等，不相等则直接返回 false
    if(strlen(s) != strlen(t))
        return 0;
    //若相等，则初始化 26 个字母哈希表，遍历字符串 s 和 t
    int A[26] = {0};  //哈希映射
    int i;
    while(*s != '\0\)
    {
        //s 负责在对应位置增加，t 负责在对应位置减少
        A[*s - 'a']++;
        A[*t - 'a']--;
        s++;
        t++;
    }
    //如果哈希表的值都为 0，则二者是字母异位词
    for(i = 0; i &amp;lt; 26; i++)
    {
        if(A[i] != 0)
            return 0;
    }
    return 1;
}
int main()
{
    char b[] = &quot;nagaram&quot;,a[] = &quot;anagram&quot;;
    if(isAnagram(a,b) != 0)
        printf(&quot;True&quot;);
    else
        printf(&quot;False&quot;);
    return 0;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2 链表（LinkedList）&lt;/h2&gt;
&lt;p&gt;单链表：链表中的每个元素实际上是一个单独的对象，而所有对象都通过每个元素中的引用字段链接在一起。&lt;/p&gt;
&lt;p&gt;双链表：与单链表不同的是，双链表的每个结点中都含有两个引用字段。&lt;/p&gt;
&lt;h3&gt;2.1链表的优缺点&lt;/h3&gt;
&lt;p&gt;链表的优点如下：&lt;/p&gt;
&lt;p&gt;　　链表能灵活地分配内存空间；&lt;/p&gt;
&lt;p&gt;　　能在O(1)时间内删除或者添加元素，前提是该元素的前一个元素已知，当然也取决于是单链表还是双链表，在双链表中，如果已知该元素的后一个元素，同样可以在 O(1) 时间内删除或者添加该元素。&lt;/p&gt;
&lt;p&gt;链表的缺点是：&lt;/p&gt;
&lt;p&gt;　　不像数组能通过下标迅速读取元素，每次都要从链表头开始一个一个读取；&lt;/p&gt;
&lt;p&gt;　　查询第 k 个元素需要 O(k) 时间。&lt;/p&gt;
&lt;h3&gt;2.2 应用场景&lt;/h3&gt;
&lt;p&gt;如果要解决的问题里面需要很多快速查询，链表可能并不适合；如果遇到的问题中，数据的元素个数不确定，而且需要经常进行数据的添加和删除，那么链表会比较合适。而如果数据元素大小确定，删除插入的操作并&lt;/p&gt;
&lt;p&gt;不多，那么数组可能更适合。&lt;/p&gt;
&lt;h3&gt;2.3 经典解法&lt;/h3&gt;
&lt;h4&gt;2.3.1 利用快慢指针（有时候需要用到三个指针）&lt;/h4&gt;
&lt;p&gt;典型题目例如：链表的翻转，寻找倒数第k个元素，寻找链表中间位置的元素，判断链表是否有环等等。&lt;/p&gt;
&lt;h4&gt;2.3.2 .构建一个虚假的链表头&lt;/h4&gt;
&lt;p&gt;一般用在要返回新的链表的题目中，比如，给定两个排好序的链表，要求将它们整合在一起并排好序。又比如，将一个链表中的奇数和偶数按照原定的顺序分开后重新组合成一个新的链表，链表的头一半是奇数，后一半是偶数。&lt;/p&gt;
&lt;p&gt;在这类问题里，如果不用一个虚假的链表头，那么在创建新链表的第一个元素时，我们都得要判断一下链表的头指针是否为空，也就是要多写一条ifelse语句。比较简洁的写法是创建一个空的链表头，直接往其后面&lt;/p&gt;
&lt;p&gt;添加元素即可，最后返回这个空的链表头的下一个节点即可。&lt;/p&gt;

&lt;p&gt;建议：在解决链表的题目时，可以在纸上或者白板上画出节点之间的相互关系，然后画出修改的方法&lt;/p&gt;
&lt;h3&gt;2.4 【25】K个一组翻转链表&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1928790/202004/1928790-20200408233644353-1212285334.png&quot; alt=&quot;&quot; width=&quot;498&quot; height=&quot;496&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解题思路：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考：&lt;a href=&quot;https://leetcode-cn.com/problems/reverse-nodes-in-k-group/solution/kge-yi-zu-fan-zhuan-lian-biao-by-powcai/&quot;&gt;https://leetcode-cn.com/problems/reverse-nodes-in-k-group/solution/kge-yi-zu-fan-zhuan-lian-biao-by-powcai/&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这道题考察了两个知识点：&lt;/p&gt;
&lt;p&gt;　　对链表翻转算法是否熟悉&lt;/p&gt;
&lt;p&gt;　　对递归算法的理解是否清晰&lt;/p&gt;
&lt;p&gt;在翻转链表的时候，可以借助三个指针：prev、curr、next，分别代表前一个节点、当前节点和下一个节点，实现过程如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://s0.lgstatic.com/i/image2/M01/90/E9/CgotOV2IRJ2AYlnUACToKJcAldQ867.gif&quot; alt=&quot;&quot; width=&quot;623&quot; height=&quot;227&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;【递归】方法1：&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;1、找到待翻转的k个节点（注意：若剩余数量小于k的话，则不需要反转，因此直接返回待翻转部分的头结点即可）。&lt;/li&gt;
&lt;li&gt;2、对其进行翻转。并返回翻转后的头结点（注意：翻转为左闭又开区间，所以本轮操作的尾结点其实就是下一轮操作的头结点）。&lt;/li&gt;
&lt;li&gt;3、对下一轮k个节点也进行翻转操作。&lt;/li&gt;
&lt;li&gt;4、将上一轮翻转后的尾结点指向下一轮翻转后的头节点，即将每一轮翻转的k的节点连接起来。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1928790/202004/1928790-20200409193956071-90841611.png&quot; alt=&quot;&quot; width=&quot;623&quot; height=&quot;746&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;47&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

typedef struct slist
{
    int data;
    struct slist *next;
};
struct slist *reverse(struct slist *head,struct slist *tail)
{
    struct slist *pre = NULL;
    struct slist *next = NULL;
    while(head != tail)
    {
        next = head -&amp;gt;next;
        head -&amp;gt;next = pre;
        pre = head;
        head = next;
    }
    return pre;
}
struct slist *reverseKGroup(struct slist* head, int k)
{
    if(head == NULL || head -&amp;gt;next == NULL)
        return head;
    struct slist *newHead,*tail = head;
    int i;
    for(i = 0;i &amp;lt; k;i++)
    {
        //剩余数量小于k的话，不需要反转
        if(tail == NULL)
            return head;
        tail = tail -&amp;gt;next;
    }
    //反转前K个元素
    newHead = reverse(head,tail);
    //下一轮的开始的地方就是tail
    head -&amp;gt;next = reverseKGroup(tail,k);

    return newHead;
}

void input(struct slist *head)
{
    struct slist *p = head -&amp;gt;next; //p是工作指针
    while(p != NULL)
    {
        printf(&quot;%d\t&quot;,p -&amp;gt;data);
        p = p -&amp;gt;next;
    }
}
void create(struct slist *head)
{
    //尾插法建立单链表
    struct slist *r,*temp; //r是尾指针，temp是临时结点
    int i,x;
    r = head;
    printf(&quot;请输入元素：\n&quot;);
    scanf(&quot;%d&quot;,&amp;amp;x);
    while(x != 9999)
    {
        temp = (struct slist *)malloc(sizeof(struct slist));
        temp -&amp;gt;data = x;
        temp -&amp;gt;next = r -&amp;gt;next;
        r -&amp;gt;next = temp;
        r = temp;
        scanf(&quot;%d&quot;,&amp;amp;x);
    }
}
int main()
{
    struct slist *head;//head是头结点

    head = (struct slist *)malloc(sizeof(struct slist));
    head -&amp;gt;next = NULL;
    create(head);
    input(head);

    int k;
    printf(&quot;\n请输入K：&quot;);
    scanf(&quot;%d&quot;,&amp;amp;k);
    head -&amp;gt;next= reverseKGroup(head -&amp;gt;next,k);
    input(head);

    return 0;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;【递归】方法2：&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1928790/202004/1928790-20200409205845693-1967729373.png&quot; alt=&quot;&quot; width=&quot;785&quot; height=&quot;334&quot;/&gt;　&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;44&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

typedef struct slist
{
    int data;
    struct slist *next;
};
struct slist *reverseKGroup(struct slist* head, int k)
{
    struct slist *cur = head;
    int count = 0;
    // 找到待翻转的k个节点
    while(cur != NULL &amp;amp;&amp;amp; count != k)
    {
        cur = cur -&amp;gt;next;
        count++;
    }
    if(count == k)
    {
        cur = reverseKGroup(cur,k);
        while(count != 0)
        {
            count--;
            struct slist *tmp = head -&amp;gt;next;
            head -&amp;gt;next = cur;
            cur = head;
            head = tmp;
        }
        head = cur;
    }
    //若剩余数量小于k的话，则不需要反转，因此直接返回待翻转部分的头结点即可
    return head;  //head为头指针
}

void input(struct slist *head)
{
    struct slist *p = head -&amp;gt;next; //p是工作指针
    while(p != NULL)
    {
        printf(&quot;%d\t&quot;,p -&amp;gt;data);
        p = p -&amp;gt;next;
    }
}
void create(struct slist *head)
{
    //尾插法建立单链表
    struct slist *r,*temp; //r是尾指针，temp是临时结点
    int i,x;
    r = head;
    printf(&quot;请输入元素：\n&quot;);
    scanf(&quot;%d&quot;,&amp;amp;x);
    while(x != 9999)
    {
        temp = (struct slist *)malloc(sizeof(struct slist));
        temp -&amp;gt;data = x;
        temp -&amp;gt;next = r -&amp;gt;next;
        r -&amp;gt;next = temp;
        r = temp;
        scanf(&quot;%d&quot;,&amp;amp;x);
    }
}
int main()
{
    struct slist *head;//head是头结点

    head = (struct slist *)malloc(sizeof(struct slist));
    head -&amp;gt;next = NULL;
    create(head);
    input(head);

    int k;
    printf(&quot;\n请输入K：&quot;);
    scanf(&quot;%d&quot;,&amp;amp;k);
    head -&amp;gt;next= reverseKGroup(head -&amp;gt;next,k);
    input(head);

    return 0;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3 栈（Stack）&lt;/h2&gt;
&lt;h3&gt;3.1 特点&lt;/h3&gt;
&lt;p&gt;栈的最大特点就是后进先出（LIFO）。对于栈中的数据来说，所有操作都是在栈的顶部完成的，只可以查看栈顶部的元素，只能够向栈的顶部压⼊数据，也只能从栈的顶部弹出数据。&lt;/p&gt;
&lt;h3&gt;3.2 实现&lt;/h3&gt;
&lt;p&gt;利用一个单链表来实现栈的数据结构。而且，因为我们都只针对栈顶元素进行操作，所以借用单链表的头就能让所有栈的操作在O(1)的时间内完成。&lt;/p&gt;
&lt;h3&gt;3.3 应用场景&lt;/h3&gt;
&lt;p&gt;在解决某个问题的时候，只要求关心最近一次的操作，并且在操作完成了之后，需要向前查找到更前一次的操作。&lt;/p&gt;
&lt;p&gt;如果打算用一个数组外加一个指针来实现相似的效果，那么，一旦数组的长度发生了改变，哪怕只是在最后添加一个新的元素，时间复杂度都不再是 O(1)，而且，空间复杂度也得不到优化。&lt;/p&gt;
&lt;h3&gt;3.4&lt;span&gt;【&lt;span&gt;20】有效的括号&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1928790/202004/1928790-20200409211600163-1043789629.png&quot; alt=&quot;&quot; width=&quot;553&quot; height=&quot;549&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;解题思路&lt;/h4&gt;
&lt;p&gt;利用一个栈，不断地往里压左括号，一旦遇上了一个右括号，我们就把栈顶的左括号弹出来，表示这是一个合法的组合，以此类推，直到最后判断栈里还有没有左括号剩余。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://s0.lgstatic.com/i/image2/M01/90/C9/CgoB5l2IRLSATKk3AMg-Ag7s3RA865.gif&quot; alt=&quot;&quot; width=&quot;798&quot; height=&quot;374&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#define Max 20
#define Stack char
int isValid(char * p)
{
    int len=strlen(p);

    if(len == 1)
        return 0;
    int top=1,i;
    Stack s[Max];  //堆栈存储
    for(i=0; i&amp;lt;len; i++)
    {
        switch(p[i])
        {
        case '(':
        case '[':
        case '{':
            s[top++]=p[i];  //进栈
            break;
        case ')':
            if(s[top-1]=='(')
                top--;  //出栈
            else return 0;
            break;
        case ']':
            if(s[top-1]=='[')
                top--;  //出栈
            else return 0;
            break;
        case '}':
            if(s[top-1]=='{')
                top--;//出栈
            else return 0;
            break;
        }
    }
    if(top==0)
        return 1;  //输出1表示匹配成功
    else
        return 0;   //输出0表示匹配失败
}
int main()
{
    char s[Max];
    printf(&quot;请输入括号:&quot;);
    scanf(&quot;%s&quot;,s);

    if(isValid(s) != 0)
        printf(&quot;true&quot;);
    else
        printf(&quot;false&quot;);
    return 0;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.5【739】每日温度&lt;/h3&gt;
&lt;h3&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1928790/202004/1928790-20200410183137532-1010954102.png&quot; alt=&quot;&quot; width=&quot;622&quot; height=&quot;351&quot;/&gt;&lt;/h3&gt;
&lt;h4&gt;方法一：从左到右依次遍历  O(n^2)&lt;/h4&gt;
&lt;p&gt;针对每个温度值 &lt;strong&gt;向后进行依次搜索&lt;/strong&gt; ，找到比当前温度更高的值，这是最容易想到的办法。&lt;/p&gt;
&lt;p&gt;其原理：&lt;span&gt;从左到右除了最后一个数其他所有的数都遍历一次&lt;/span&gt;，最后一个数据对应的结果肯定是 0，就不需要计算。&lt;/p&gt;
&lt;p&gt;遍历的时候，每个数都去向后数，直到找到比它大的数，数的次数就是对应输出的值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;48&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

void dailyTemperatures(int* T, int TSize){
    int i,j,result[TSize];
    for(i = 0;i &amp;lt; TSize;i++)
    {
        int cur = T[i];
        if(cur &amp;lt; 100)
        {
            for(j = i+1;j &amp;lt; TSize;j++)
            {
                if(T[j] &amp;gt; cur)
                {
                    result[i] = j - i;
                    break;
                }
            }
            if(j == TSize)
                result[i] = 0;
        }
    }
    for(i = 0;i &amp;lt; TSize;i++)
    {
        printf(&quot;%d\t&quot;,result[i]);
    }
}
int main()
{
    int length,T[] = {73, 65, 85, 71, 69, 72, 76, 79};
    length = sizeof(T) / sizeof(T[0]);
    dailyTemperatures(T,length);
    return 0;
}
&lt;/pre&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/1928790/202004/1928790-20200410202730134-1408501246.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
//LeetCode可以通过，但超时，因为时间复杂度为O(2^2)
int* dailyTemperatures(int* T, int TSize,int* returnSize){
    int i,j;
    int *result = malloc(sizeof(int)*TSize);  //动态数组
    *returnSize = TSize;
    for(i = 0;i &amp;lt; TSize;i++)
    {
        int cur = T[i];
        if(cur &amp;lt;= 100)
        {
            for(j = i+1;j &amp;lt; TSize;j++)
            {
                if(T[j] &amp;gt; cur)
                {
                    result[i] = j - i;
                    break;
                }
            } 
            //若之后不再升高，则为0
            if(j == TSize)
                result[i] = 0;
        }
    }
    return result;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;方法二：从右到左依次遍历&lt;/h4&gt;
&lt;p&gt;关键是要减少为每个数寻找值遍历次数。如下图所示，绿色部分区域会给多次遍历，&lt;span&gt;如果我们能减少这部分区域的遍历次数，就能整体提高运算效率。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1928790/202004/1928790-20200410234025481-1547971815.png&quot; alt=&quot;&quot; width=&quot;644&quot; height=&quot;288&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果我们先从计算右边，那么我们计算过的位置就不需要重复计算，如图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1928790/202004/1928790-20200410234104945-451405599.png&quot; alt=&quot;&quot; width=&quot;528&quot; height=&quot;192&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 当前我们需要计算 7575 位置，然后向右遍历到 7171，因为我们已经计算好了 7171 位置对应的值为 22，那么我们就可以直接跳 22 为在进行比较，利用了已经有的结果，减少了遍历的次数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;47&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

void dailyTemperatures(int* T, int TSize)
{
    int i,j;
    int *result = malloc(sizeof(int)*TSize);  //动态数组
    //从右向左遍历
    result[TSize - 1] = 0; //最后一个一定为0
    for(i = TSize - 2; i &amp;gt;= 0; i--)
    {
        // j+= result[j]是利用已经有的结果进行跳跃
        for(j = i+1; j &amp;lt; TSize; j+=result[j])
        {
            if(T[j] &amp;gt; T[i])
            {
                result[i] = j - i;
                break;
            }
            //遇到0表示后面不会有更大的值，那当然当前值就应该也为0
            else if(result[j] == 0)
            {
                result[i] = 0;
                break;
            }
        }
    }
    for(i = 0; i &amp;lt; TSize; i++)
    {
        printf(&quot;%d\t&quot;,result[i]);
    }
}
int main()
{
    int length,T[] = {73, 65, 85, 71, 69, 72, 76, 79};
    length = sizeof(T) / sizeof(T[0]);
    dailyTemperatures(T,length);
    return 0;
}&lt;br/&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;方法三：堆栈    O(n)&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;可以运用一个堆栈 stack 来快速地知道需要经过多少天就能等到温度升高。从头到尾扫描一遍给定的数组 T，如果当天的温度比堆栈 stack 顶端所记录的那天温度还要高，那么就能得到结果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://s0.lgstatic.com/i/image2/M01/90/C9/CgoB5l2IRMSAYv0mAJhTnwV5DmQ777.gif&quot; alt=&quot;&quot; width=&quot;734&quot; height=&quot;344&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对第一个温度23度，堆栈为空，把它的下标压入堆栈；&lt;/li&gt;
&lt;li&gt;下一个温度24度，高于23度高，因此23度温度升高只需1天时间，把23度下标从堆栈里弹出，把24度下标压入；&lt;/li&gt;
&lt;li&gt;同样，从24度只需要1天时间升高到25度；&lt;/li&gt;
&lt;li&gt;21度低于25度，直接把21度下标压入堆栈；&lt;/li&gt;
&lt;li&gt;19度低于21度，压入堆栈；&lt;/li&gt;
&lt;li&gt;22度高于19度，从19度升温只需1天从 21 度升温需要 2 天；&lt;/li&gt;
&lt;li&gt;由于堆栈里保存的是下标，能很快计算天数；&lt;/li&gt;
&lt;li&gt;22 度低于 25 度，意味着尚未找到 25 度之后的升温，直接把 22 度下标压入堆栈顶端；&lt;/li&gt;
&lt;li&gt;后面的温度与此同理。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;该方法只需要对数组进行一次遍历，每个元素最多被压入和弹出堆栈一次，算法复杂度是 O(n)。&lt;/p&gt;

&lt;p&gt; 利用堆栈，还可以解决如下常见问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;求解算术表达式的结果（LeetCode 224、227、772、770)&lt;/li&gt;
&lt;li&gt;求解直方图里最大的矩形区域（LeetCode 84）&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;　&lt;/h3&gt;







</description>
<pubDate>Fri, 10 Apr 2020 15:53:00 +0000</pubDate>
<dc:creator>Pam_sh</dc:creator>
<og:description>1 数组、字符串【Array、String】 1.1&amp;#160;字符串转化 数组和字符串是最基本的数据结构，在很多编程语言中都有着十分相似的性质，而围绕着它们的算法面试题也是最多的。 很多时候，在分析</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/pam-sh/p/12664175.html</dc:identifier>
</item>
<item>
<title>【高并发】学好并发编程，关键是要理解这三个核心问题 - 冰河团队</title>
<link>http://www.cnblogs.com/binghe001/p/12676927.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/binghe001/p/12676927.html</guid>
<description>&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;写在前面&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;写【高并发专题】有一段时间了，一些读者朋友留言说，并发编程很难，学习了很多的知识，但是在实际工作中却无从下手。对于一个线上产生的并发问题，又不知产生这个问题的原因究竟是什么。对于并发编程，感觉上似乎是掌握了，但是真正用起来却不是那么回事！&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p md-focus&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;其实，造成这种现象的本质原因就是没有透彻的理解并发编程的精髓，而学好并发编程的关键是需要弄懂三个核心问题：&lt;span class=&quot;md-html-inline md-expand&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span class=&quot;md-plain&quot;&gt;分工、同步和互斥&lt;/span&gt;&lt;/strong&gt;&lt;span class=&quot;md-plain&quot;&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;分工&lt;/span&gt;&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;比较官方的解释为：分工就是将一个比较大的任务，拆分成多个大小合适的任务，交给合适的线程去完成，强调的是性能。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;如果你还不能够理解什么是分工，这里，我们可以做一个假设。假设你是一个XXX上市公司的CEO，你的工作是如何管理好你的公司。但是，就如何管理好公司而言，涉及到的任务就比较多了，我们可以将其看做一个很大的任务，这个很大的任务，细看的话可以包括：人员招聘和管理、产品设计和开发、运营和推广、公司税务等等。那细化后这么多的任务交给你一个人去做，想必你一定是崩溃的。即使你能够挺住，估计你一个人把这所有的任务完成，那黄花菜也就凉了！到时，估计你就会偷偷的躲在角落里唱“凉凉”了。。。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;所以，如果你真的想管理好你的公司，你就需要将这些任务分解，分工细化，将人员招聘和管理的任务交给人力资源部门去完成，将产品的设计交给设计部门去完成，将产品的开发交给开发部门去完成，将运营和推广交给运营和市场部门去完成，将公司税务交给财务部门去完成。此时，你的任务就是及时了解各个部门的工作情况，统筹并协调各部门的工作，并思考如何规划公司的未来。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;其实，这里你将管理公司的任务拆解、细化分工之后，你会发现，其实各部门之间的工作是并行执行的。比如：人力资源部门在管理员工的绩效考核时，同时产品设计和开发部门正在设计和开发公司的产品，与此同时，公司的运营正在和设计与开发沟通如何更好的完善公司的产品，而推广部门正在加大力度宣传和推广公司的产品。而财务部门正在统计和计算公司的各种财务报表等。一切都是那么的有条不紊！&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;F:\MySelf\专栏更新\高并发\多线程\images\bumen_20200322.jpg&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1729473/202004/1729473-20200410230712036-1326146955.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;所以，安排合适的人去做合适的事情，在实际工作中是非常重要的。映射到并发编程领域也是同样的道理。如果将所有的任务交给一个线程执行，就好比将公司的所有事情交给你一个人去做一样。等到把事情做完了，黄花菜也凉了。所以，在并发编程中，我们同样需要将任务进行拆解，分工给合适的线程去完成。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;F:\MySelf\专栏更新\高并发\多线程\images\task_fenjie_20200322.jpg&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1729473/202004/1729473-20200410230735307-243223290.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;在并发编程领域，还需要注意一个问题就是：&lt;span&gt;&lt;strong&gt;&lt;span class=&quot;md-plain&quot;&gt;分工给合适的线程去做。&lt;/span&gt;&lt;/strong&gt;&lt;span class=&quot;md-plain&quot;&gt;也就是说，&lt;span&gt;&lt;strong&gt;&lt;span class=&quot;md-plain&quot;&gt;应该主线程执行的任务不要交给子线程去做，否则，是解决不了问题的&lt;/span&gt;&lt;/strong&gt;&lt;span class=&quot;md-plain&quot;&gt;。这就好比一家公司的CEO将如何规划公司的未来交给一个产品开发人员去做一样，这不仅不能规划好公司的未来，甚至会与公司的价值观背道而驰。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span class=&quot;md-plain&quot;&gt;在JavaSDK中的：Executor、Fork/Join和Future都是实现分工的一种方式。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;同步&lt;/span&gt;&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;在并发编程中的同步，主要指的是一个线程执行完任务后，如何通知其他的线程继续执行，强调的是性能。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;将任务拆分，并且合理的分工给了每个人，接下来就是如何同步每个人的任务了。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;假设小明是一名前端开发人员，他渲染页面的数据需要等待小刚的接口完成，而小刚写接口又需要等待小李的服务开发完成。也就是说，&lt;span&gt;&lt;strong&gt;&lt;span class=&quot;md-plain&quot;&gt;任务之间是存在依赖关系的，前面的任务完成后，才能进行后面的任务。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;对于实际工作中，这种任务的同步，大多数靠的是人与人之间的沟通，小李的服务写完了，告诉小刚，小刚则马上进行接口开发，等小刚的接口开发完成后，又告诉了小明，小明马上调用接口将返回的数据渲染在页面上。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;F:\MySelf\专栏更新\高并发\多线程\images\renyuan_tongbu_20200322.jpg&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1729473/202004/1729473-20200410230757329-2090528907.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;这种同步机制映射到并发编程领域，就是&lt;span&gt;&lt;strong&gt;&lt;span class=&quot;md-plain&quot;&gt;一个线程的任务执行完毕之后，通知其他的后续线程执行任务。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;对于这种线程之间的同步，我们可以使用下面的 &lt;span&gt;&lt;strong&gt;&lt;span class=&quot;md-plain&quot;&gt;if&lt;/span&gt;&lt;/strong&gt; &lt;span class=&quot;md-plain&quot;&gt;伪代码来表示。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(前面的任务完成){
    执行当前任务
}&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
    继续等待前面任务的执行
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;如果为了更能够及时的判断出前面的任务是否已经完成，我们也可以使用 &lt;span&gt;&lt;strong&gt;&lt;span class=&quot;md-plain&quot;&gt;while&lt;/span&gt;&lt;/strong&gt; &lt;span class=&quot;md-plain&quot;&gt;伪代码来表示。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;while&lt;/span&gt;&lt;span&gt;(前面的任务未完成){
    继续等待前面任务的执行
}
执行当前任务&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;上述伪代码表示的意义是相同的：&lt;span&gt;&lt;strong&gt;&lt;span class=&quot;md-plain&quot;&gt;当线程执行的条件不满足时，线程需要继续等待，一旦条件满足，就需要唤醒等待的线程继续执行。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;在并发编程领域，一个典型的场景就是生产者-消费者模型。当队列满时，生产者线程需要等待，队列不满时，需要唤醒生产者线程；当队列为空时，消费者线程需要等待，队列不空时，需要唤醒消费者。我们可以使用下面的伪代码来表示生产者-消费者模型。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;while&lt;/span&gt;&lt;span&gt;(队列已满){
    生产者线程等待
}
唤醒生产者&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;while&lt;/span&gt;&lt;span&gt;(队列为空){
    消费者等待
}
唤醒消费者&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span class=&quot;md-plain&quot;&gt;在Java的SDK中，提供了一些实现线程之间同步的工具类，比如说：CountDownLatch、 CyclicBarrier 等。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;互斥&lt;/span&gt;&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;同一时刻，只允许一个线程访问共享变量，强调的是线程执行任务的正确性。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;在并发编程领域，分工和同步强调的是执行任务的性能，而线程之间的互斥则强调的是线程执行任务的正确性，也就是&lt;span&gt;&lt;strong&gt;&lt;span class=&quot;md-plain&quot;&gt;线程的安全问题&lt;/span&gt;&lt;/strong&gt;&lt;span class=&quot;md-plain&quot;&gt;。如果多个线程同时访问同一个共享变量，则可能会发生意想不到的后果，而这种意想不到的后果主要是由线程的&lt;span&gt;&lt;strong&gt;&lt;span class=&quot;md-plain&quot;&gt;可见性、原子性和有序性&lt;/span&gt;&lt;/strong&gt;&lt;span class=&quot;md-plain&quot;&gt;问题产生的。而解决可见性、原子性和有序性问题的核心，就是互斥。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;关于互斥，我们可以用现实中的一个场景来描述：多个岔路口的车辆需要汇入一条道路中，而这条道路一次只能允许通过一辆车，此时，车辆就需要排队依次进入路口。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span class=&quot;md-plain&quot;&gt;Java中提供的synchronized、Lock、ThreadLocal、final关键字等都可以解决互斥的问题。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;例如，我们以synchronized为例来说明如何进行线程间的互斥，伪代码如下所示。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;修饰方法&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; xxx(){
    
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;修饰代码块&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; xxx(){
    &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt;(obj){
        
    }
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;修饰代码块&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; xxx(){
    &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;(XXX.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;){
        
    }
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;修饰静态方法&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; xxx(){
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;总结&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;并发编程旨在最大限度的利用计算机的资源，提高程序执行的性能，这需要线程之间的分工和同步来实现，在保证性能的同时，又需要保证线程的安全，这就又需要保证线程之间的互斥性。而并发编程的难点问题，往往又是由可见性、原子性和有序性问题导致的。所以，我们在学习并发编程时，一定要先弄懂线程之间的分工、同步和互斥。&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;写在最后&lt;/span&gt;&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;如果觉得文章对你有点帮助，请微信搜索并关注「 &lt;span&gt;&lt;strong&gt;&lt;span class=&quot;md-plain&quot;&gt;冰河技术&lt;/span&gt;&lt;/strong&gt; &lt;span class=&quot;md-plain&quot;&gt;」微信公众号，跟冰河学习高并发编程技术。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;最后，附上并发编程需要掌握的核心技能知识图，祝大家在学习并发编程时，少走弯路。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;F:\MySelf\专栏更新\高并发\多线程\images\sandahexin_20200322.jpg&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1729473/202004/1729473-20200410230941733-2031414148.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 10 Apr 2020 15:12:00 +0000</pubDate>
<dc:creator>冰河团队</dc:creator>
<og:description>写在前面 写【高并发专题】有一段时间了，一些读者朋友留言说，并发编程很难，学习了很多的知识，但是在实际工作中却无从下手。对于一个线上产生的并发问题，又不知产生这个问题的原因究竟是什么。对于并发编程，感</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/binghe001/p/12676927.html</dc:identifier>
</item>
</channel>
</rss>