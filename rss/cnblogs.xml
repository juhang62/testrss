<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>开源推荐 - CoDo开源一站式DevOps平台 - 运维咖啡吧</title>
<link>http://www.cnblogs.com/37Y37/p/10947434.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/37Y37/p/10947434.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;一群有梦想的年轻人开源了一个云管理平台，他们的口号是：让天下没有996的运维&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有幸参与到CoDo项目的开发，这是一个非常棒的一站式开源运维平台，分享给大家&lt;/p&gt;
&lt;h2 id=&quot;平台介绍&quot;&gt;平台介绍&lt;/h2&gt;
&lt;p&gt;CODO是一款为用户提供企业多混合云、自动化运维、完全开源的云管理平台。&lt;/p&gt;
&lt;p&gt;CODO前端基于Vue iview开发、为用户提供友好的操作界面，增强用户体验。&lt;/p&gt;
&lt;p&gt;CODO后端基于Python Tornado开发，其优势为轻量、简洁清晰、异步非阻塞。&lt;/p&gt;
&lt;p&gt;CODO开源多云管理平台将为用户提供多功能：ITSM、基于RBAC权限系统、Web Terminnal登陆日志审计、录像回放、强大的作业调度系统、CMDB、监控报警系统、DNS管理、配置中心等&lt;/p&gt;
&lt;h3 id=&quot;产品架构&quot;&gt;产品架构&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/opendevops-cn/opendevops/raw/master/docs/source/_static/images/project_arch.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;产品功能&quot;&gt;产品功能&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/opendevops-cn/opendevops/master/docs/source/_static/images/pro_fun_3.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;模块说明&quot;&gt;模块说明&lt;/h3&gt;
&lt;ul readability=&quot;8.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;项目前端：基于Vue + Iview-Admin实现的一套后台管理系统&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;管理后端：基于Tornado实现，提供Restful风格的API，提供基于RBAC的完善权限管理，可对所有用户的操作进行审计&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;定时任务：基于Tornado实现，定时任务系统，完全兼容&lt;code&gt;Linux Crontab&lt;/code&gt;语法，且支持到秒级&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;任务调度：基于Tornado实现，系统核心调度，可分布式扩展，自由编排任务，自由定义流程，支持多种触发，支持审批审核，支持操作干预&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;资产管理：基于Tornado实现，资产管理系统，支持手动添加资产，同时也支持从AWS/阿里云/腾讯云自动获取资产信息&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;配置中心：基于Tornado实现，可基于不同项目、环境管理配置，支持语法高亮、历史版本差异对比、快速回滚，并提供Restful风格的API&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;域名管理：基于Tornado实现，支持多区域智能解析、可视化Bind操作、操作日志记录&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;运维工具：基于Tornado实现，运维场景中常用的加密解密、事件、故障、项目记录、提醒、报警等&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;在线体验&quot;&gt;在线体验&lt;/h3&gt;
&lt;p&gt;CoDo提供了在线Demo供使用者体验，Demo账号只有部分权限&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/opendevops-cn/opendevops/raw/master/docs/source/_static/images/codo_index.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;推荐理由&quot;&gt;推荐理由&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;团队出品：&lt;/strong&gt; github上有很多开源的devops工具，几乎全部都由个人发布维护，代码质量、版本进度以及可持续性都无法保障，陷入不能用或不敢用的尴尬境地，CoDo非个人项目，由一个团队负责开发维护，有幸我也是团队中一员，参与贡献了部分代码，所以在稳定性和持续性方面更有保证&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;生产实践：&lt;/strong&gt; CoDo核心代码贡献者全部来自于一线运维团队，团队成员从运维需求出发，致力于解决运维痛点，更了解运维的需求，且核心代码经过了多年生产实践，并非实验产品，运行稳定&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;功能齐全：&lt;/strong&gt; CoDo采用微服务的理念构建，模块化开发，目前已有资产管理、定时任务、任务调度、配置中心、域名管理、运维工具几大模块，支持持续集成、持续部署、代码审查、数据库审核与优化建议等众多功能，覆盖大部分的运维场景，让你不再费心劳神在多个系统间奔波，一个平台全搞定&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;完善支持：&lt;/strong&gt; CoDo除了提供专业的文档支持外，还同时开始录制一些基础的部署使用视频帮助初学者快速上手，如果你觉得这些还不够，我们也提供QQ或微信远程支持，助你顺利部署使用&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;开源免费：&lt;/strong&gt; 这是一个开源项目，所有功能均可免费使用，源码托管在GitHub&lt;/p&gt;
&lt;h2 id=&quot;项目地址&quot;&gt;项目地址&lt;/h2&gt;
&lt;p&gt;官网：&lt;a href=&quot;http://www.opendevops.cn&quot; class=&quot;uri&quot;&gt;http://www.opendevops.cn&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;GitHub：&lt;a href=&quot;https://github.com/opendevops-cn&quot; class=&quot;uri&quot;&gt;https://github.com/opendevops-cn&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文档地址：&lt;a href=&quot;http://docs.opendevops.cn/zh/latest&quot; class=&quot;uri&quot;&gt;http://docs.opendevops.cn/zh/latest&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安装视频：&lt;a href=&quot;https://www.bilibili.com/video/av53446517&quot; class=&quot;uri&quot;&gt;https://www.bilibili.com/video/av53446517&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最后欢迎大家使用，如有任何意见和建议都可以通过ISSUE或者QQ群反馈给我们，我们会进行持续的更新和优化&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;http://blz.nos.netease.com/sre/oa.qrcode.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;相关文章推荐阅读：&lt;/p&gt;
</description>
<pubDate>Wed, 29 May 2019 23:08:00 +0000</pubDate>
<dc:creator>运维咖啡吧</dc:creator>
<og:description>一群有梦想的年轻人开源了一个云管理平台，他们的口号是：让天下没有996的运维 有幸参与到CoDo项目的开发，这是一个非常棒的一站式开源运维平台，分享给大家 平台介绍 CODO是一款为用户提供企业多混合</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/37Y37/p/10947434.html</dc:identifier>
</item>
<item>
<title>还不知道如何使用 IDEA ？教你三招快速掌握 IDEA - good_andyxu</title>
<link>http://www.cnblogs.com/goodAndyxublog/p/10947366.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/goodAndyxublog/p/10947366.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;IntelliJ IDEA 是一个非常强大的 IDE，拥有许多功能。在 IDEA 中大部分功能都可以用快捷键去完成，如果掌握了大部分快捷键，可以只使用键盘开发了。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;ps: 最近正在练习快捷键，准备尝试只使用键盘进行开发&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也许因为这些繁多的功能，对于新入手 IDEA 的开发人员，快速掌握功能与快捷键并不是很简单。幸运的是 &lt;strong&gt;Jetbrain&lt;/strong&gt; 早已考虑到该情况， 在 IDEA 有相关功能，可以快速帮助你上手。&lt;/p&gt;
&lt;h2 id=&quot;tip-of-the-day&quot;&gt;Tip of the day&lt;/h2&gt;
&lt;p&gt;首先介绍的是 &lt;strong&gt;Tip of the day&lt;/strong&gt; 。这个功能，大家应该都见过。初始安装好 IDEA，打开软件，默认就会弹出下面的窗口。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2019/png/254022/1559146186527-8444b0dd-c833-4f41-bb4e-da2661abb31e.png&quot; alt=&quot;Tip of the day&quot;/&gt;&lt;/p&gt;
&lt;p&gt;默认情况下 &lt;strong&gt;show tips on startup&lt;/strong&gt; 选项会勾选，下次打开就会该功能会继续出现。不过我相信很多人，被国内各种弹窗广告迫害，会习惯性的第一时间就会把它取消。&lt;/p&gt;
&lt;p&gt;如果你已经取消这个选项，可以在 &lt;strong&gt;HELP | Tip of the day&lt;/strong&gt; 打开。&lt;/p&gt;
&lt;p&gt;在这个窗口，会显示一个 IDEA 功能，左右切换可以查看其他功能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2019/png/254022/1559146425081-7d8fc46c-4dbe-4622-bbce-9b52513fac9e.png&quot; alt=&quot;1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2019/png/254022/1559146470415-01f00581-4e24-480c-b5fa-27102e4a6260.png&quot; alt=&quot;2&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;productivity-guide&quot;&gt;productivity guide&lt;/h2&gt;
&lt;p&gt;第二个介绍 &lt;strong&gt;productivity guide&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;上面我们提到 IDEA 中存在很多功能以及快捷键，但你知道你经常使用是那几个功能以及使用频率如何？&lt;/p&gt;
&lt;p&gt;在 IDEA 中打开 &lt;strong&gt;productivity guide&lt;/strong&gt;，在这里你不仅可以看到经常使用的功能，还会展示你从未使用的功能。&lt;/p&gt;
&lt;p&gt;我们可以在 &lt;strong&gt;Help | Productivity Guide&lt;/strong&gt; 打开。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2019/png/254022/1559146867467-ddd72b8e-1b83-4d7e-b7fa-cc8f8d7655b9.png&quot; alt=&quot;Productivity Guide&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个窗口可以看到 IDEA 统计相关功能使用情况。点击未在使用的功能，在下面的面板，会给出相关提示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2019/png/254022/1559149116615-cfb17e0f-a8c4-4a81-a4f7-397546df2abf.png&quot; alt=&quot;使用技巧&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果旁边的小伙伴也在使用 IDEA，不妨互相比较一下相关数据，也许能发现一些有趣的现象。&lt;/p&gt;
&lt;h2 id=&quot;插件-ide-features-trainer&quot;&gt;插件 IDE Features Trainer&lt;/h2&gt;
&lt;p&gt;介绍 IDEA 自带的两个功能，下面介绍一款插件。这款插件由 IDEA 官方开发，5星认证好评。&lt;/p&gt;
&lt;p&gt;在 &lt;strong&gt;setting|plugins&lt;/strong&gt; 输入 &lt;strong&gt;IDE Features Trainer&lt;/strong&gt;，就能找到这款插件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2019/png/254022/1559149216148-1125dfe1-f0f5-488e-a542-852f59df0085.png&quot; alt=&quot;IDE Features Trainer&quot;/&gt;&lt;/p&gt;
&lt;p&gt;安装之后，打开 IDEA，可以在首页看到 &lt;strong&gt;Learn Intellij IDEA&lt;/strong&gt; 选项。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2019/png/254022/1559149277956-1ae9ad53-8713-46c3-a964-72e19cc36b25.png&quot; alt=&quot;首页&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击选项会进入一个内置工程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2019/png/254022/1559149344747-9f3d2bba-cf66-410c-9b8b-de6be61c252c.png&quot; alt=&quot;内置功能&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;哈哈，目前只完成两个，正在跟着学习相关快捷键。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个插件主要教你学会五类相关功能，分别为：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Editor Basics&lt;/strong&gt;：相关的编辑技巧。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Code Completion&lt;/strong&gt;：代码提示快捷键，一些快捷完成代码的及技巧。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Refactoring&lt;/strong&gt;：代码重构的技巧。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Code Assistance&lt;/strong&gt;：代码只能提示功能，可以快速格式化以及查看方法参数等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Navigation&lt;/strong&gt;: 导航功能，可以快速搜索文件，类，方法名。这个真的不得不吹一下，IDEA 搜索功能快速且方便。&lt;/p&gt;
&lt;p&gt;相关子功能示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2019/png/254022/1559149885867-c20c8abb-ce04-49ab-99ca-e7f53ca27d7f.png&quot; alt=&quot;示例&quot;/&gt;&lt;/p&gt;
&lt;p&gt;掌握这五类技巧，可以说已经掌握 IDEA 的核心功能。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;IDEA 上手简单，但是想熟练掌握，却还是需要大量的练习。上面三个技巧只能帮助你去了解相关功能，能否掌握还得靠自己去练习。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/4/5/169ee025eadf161e?w=1250&amp;amp;h=607&amp;amp;f=png&amp;amp;s=130649&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 29 May 2019 17:36:00 +0000</pubDate>
<dc:creator>good_andyxu</dc:creator>
<og:description>趁着晚上发布的摸鱼时间，研究了下 IDEA 一些自带教程，带你快速上手 IDEA 开发。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/goodAndyxublog/p/10947366.html</dc:identifier>
</item>
<item>
<title>TypeScript 装饰器 - 刘哇勇</title>
<link>http://www.cnblogs.com/Wayou/p/typescript_decorator.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Wayou/p/typescript_decorator.html</guid>
<description>&lt;p&gt;装饰器（&lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/decorators.html&quot; rel=&quot;nofollow&quot;&gt;Decorators&lt;/a&gt;）可用来装饰类，属性，及方法，甚至是函数的参数，以改变和控制这些对象的表现，获得一些功能。&lt;/p&gt;
&lt;p&gt;装饰器以 &lt;code&gt;@expression&lt;/code&gt; 形式呈现在被装饰对象的前面或者上方，其中 &lt;code&gt;expression&lt;/code&gt; 为一个函数，根据其所装饰的对象的不同，得到的入参也不同。&lt;/p&gt;
&lt;p&gt;以下两种风格均是合法的：&lt;/p&gt;


&lt;p&gt;ES 中装饰器处于 &lt;a href=&quot;https://github.com/tc39/proposal-decorators&quot;&gt;Stage 2 阶段&lt;/a&gt; ，TypeScript 中通过开启相应编译开关来使用。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-json&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
{
  &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;compilerOptions&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;: {
    &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;target&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;: &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;ES5&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;,
    &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;experimentalDecorators&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;: &lt;span class=&quot;pl-c1&quot;&gt;true&lt;/span&gt;
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;一个简单的示例&lt;/h2&gt;
&lt;p&gt;一个简单的示例，展示了 TypeScript 中如何编写和使用装饰器。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-ts&quot; readability=&quot;13&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; log(
  &lt;span class=&quot;pl-v&quot;&gt;_target&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;any&lt;/span&gt;,
  &lt;span class=&quot;pl-v&quot;&gt;propertyKey&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;string&lt;/span&gt;,
  &lt;span class=&quot;pl-v&quot;&gt;descriptor&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;PropertyDescriptor&lt;/span&gt;
) {
  &lt;span class=&quot;pl-k&quot;&gt;&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt;&lt;/span&gt; originalMethod &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;descriptor&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;value&lt;/span&gt;;
  &lt;span class=&quot;pl-smi&quot;&gt;descriptor&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt;() {
    &lt;span class=&quot;pl-c1&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;method ${&lt;span class=&quot;pl-smi&quot;&gt;propertyKey&lt;/span&gt;} called&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&lt;/span&gt;);
    &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;originalMethod&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;apply&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;arguments&lt;/span&gt;);
  };
}

&lt;span class=&quot;pl-k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Test&lt;/span&gt; {
  @&lt;span class=&quot;pl-smi&quot;&gt;log&lt;/span&gt;
  &lt;span class=&quot;pl-k&quot;&gt;static&lt;/span&gt; sayHello() {
    &lt;span class=&quot;pl-c1&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;hello&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
  }
}

&lt;span class=&quot;pl-smi&quot;&gt;Test&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;sayHello&lt;/span&gt;();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的示例中，创建了名为 &lt;code&gt;log&lt;/code&gt; 的方法，它将作为装饰器作用于类的方法上，在方法被调用时输出一条日志。作为装饰器的 &lt;code&gt;log&lt;/code&gt; 函数其入参在后面会介绍。&lt;/p&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
method sayHello called
hello
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;装饰器的工厂方法&lt;/h2&gt;
&lt;p&gt;上面的装饰器比较呆板，设想我们想将它变得更加灵活和易于复用一些，则可以通过创建一个工厂方法来实现。因为本质上装饰器就是个普通函数，函数可通过另外的函数来创建和返回，同时装饰器的使用本质上也是一个函数调用。通过传递给工厂方法不同的参数，以获得不同表现的装饰器。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-ts&quot; readability=&quot;13&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; logFactory(&lt;span class=&quot;pl-v&quot;&gt;prefix&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;string&lt;/span&gt;) {
  &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; log(
    &lt;span class=&quot;pl-v&quot;&gt;_target&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;any&lt;/span&gt;,
    &lt;span class=&quot;pl-v&quot;&gt;propertyKey&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;string&lt;/span&gt;,
    &lt;span class=&quot;pl-v&quot;&gt;descriptor&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;PropertyDescriptor&lt;/span&gt;
  ) {
    &lt;span class=&quot;pl-k&quot;&gt;&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt;&lt;/span&gt; originalMethod &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;descriptor&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;value&lt;/span&gt;;
    &lt;span class=&quot;pl-smi&quot;&gt;descriptor&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt;() {
      &lt;span class=&quot;pl-c1&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;method ${&lt;span class=&quot;pl-smi&quot;&gt;propertyKey&lt;/span&gt;} called&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&lt;/span&gt;);
      &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;originalMethod&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;apply&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;arguments&lt;/span&gt;);
    };
  };
}

&lt;span class=&quot;pl-k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Test&lt;/span&gt; {
  @&lt;span class=&quot;pl-en&quot;&gt;logFactory&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;[debug]&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;)
  &lt;span class=&quot;pl-k&quot;&gt;static&lt;/span&gt; sayHello() {
    &lt;span class=&quot;pl-c1&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;hello&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
  }
  @&lt;span class=&quot;pl-en&quot;&gt;logFactory&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;[info]&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;)
  &lt;span class=&quot;pl-k&quot;&gt;static&lt;/span&gt; sum() {
    &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;;
  }
}

&lt;span class=&quot;pl-smi&quot;&gt;Test&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;sayHello&lt;/span&gt;();
&lt;span class=&quot;pl-smi&quot;&gt;Test&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;sum&lt;/span&gt;();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
[debug] method sayHello called
hello
[info] method sum called
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;多个装饰器&lt;/h2&gt;
&lt;p&gt;多个装饰器可同时作用于同一对象，按顺序书写出需要运用的装饰器即可。其求值（evaluate）和真正被执行（call）的顺序是反向的。即，排在前面的先求值，排在最后的先执行。&lt;/p&gt;
&lt;p&gt;譬如，&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-ts&quot; readability=&quot;14&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; f() {
  &lt;span class=&quot;pl-c1&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;f(): evaluated&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
  &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;pl-v&quot;&gt;target&lt;/span&gt;, &lt;span class=&quot;pl-v&quot;&gt;propertyKey&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;string&lt;/span&gt;, &lt;span class=&quot;pl-v&quot;&gt;descriptor&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;PropertyDescriptor&lt;/span&gt;) {
    &lt;span class=&quot;pl-c1&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;f(): called&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
  };
}

&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; g() {
  &lt;span class=&quot;pl-c1&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;g(): evaluated&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
  &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;pl-v&quot;&gt;target&lt;/span&gt;, &lt;span class=&quot;pl-v&quot;&gt;propertyKey&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;string&lt;/span&gt;, &lt;span class=&quot;pl-v&quot;&gt;descriptor&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;PropertyDescriptor&lt;/span&gt;) {
    &lt;span class=&quot;pl-c1&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;g(): called&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
  };
}

&lt;span class=&quot;pl-k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;C&lt;/span&gt; {
  @&lt;span class=&quot;pl-en&quot;&gt;f&lt;/span&gt;()
  @&lt;span class=&quot;pl-en&quot;&gt;g&lt;/span&gt;()
  method() {}
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;求值&lt;/strong&gt; 的过程就体现在装饰器可能并不直接是一个可调用的函数，而是一个工厂方法或其他表达式，只有在这个工厂方法或表达式被求值后，才得到真正被调用的装饰器。&lt;/p&gt;
&lt;p&gt;所以在这个示例中，先依次对 &lt;code&gt;f()&lt;/code&gt; &lt;code&gt;g()&lt;/code&gt; 求值，再从 &lt;code&gt;g()&lt;/code&gt; 开始执行到 &lt;code&gt;f()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-en&quot;&gt;f&lt;/span&gt;(): evaluated
&lt;span class=&quot;pl-en&quot;&gt;g&lt;/span&gt;(): evaluated
&lt;span class=&quot;pl-en&quot;&gt;g&lt;/span&gt;(): called
&lt;span class=&quot;pl-en&quot;&gt;f&lt;/span&gt;(): called
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;不同类型的装饰器&lt;/h2&gt;
&lt;h3&gt;类的装饰器&lt;/h3&gt;
&lt;p&gt;作用于类（Class）上的装饰器，用于修改类的一些属性。如果装饰器有返回值，该返回值将替换掉该类的声明而作为新的构造器使用。&lt;/p&gt;
&lt;p&gt;装饰器入参：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;类的构造器。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;示例：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-ts&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; sealed(&lt;span class=&quot;pl-v&quot;&gt;constructor&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Function&lt;/span&gt;) {
  &lt;span class=&quot;pl-c1&quot;&gt;Object&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;seal&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;constructor&lt;/span&gt;);
  &lt;span class=&quot;pl-c1&quot;&gt;Object&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;seal&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;constructor&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;prototype&lt;/span&gt;);
}

@&lt;span class=&quot;pl-smi&quot;&gt;sealed&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Greeter&lt;/span&gt; {
  greeting&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;string&lt;/span&gt;;
  &lt;span class=&quot;pl-k&quot;&gt;constructor&lt;/span&gt;(&lt;span class=&quot;pl-v&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;string&lt;/span&gt;) {
    &lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;greeting&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;message&lt;/span&gt;;
  }
  greet() {
    &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;Hello, &lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;greeting&lt;/span&gt;;
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;@sealed&lt;/code&gt; 将类进行密封，将无法再向类添加属性，同时类上属性也变成不可配置的（non-configurable）。&lt;/p&gt;
&lt;p&gt;另一个示例：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-ts&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; classDecorator&amp;lt;&lt;span class=&quot;pl-en&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;extends&lt;/span&gt; { &lt;span class=&quot;pl-k&quot;&gt;new&lt;/span&gt; (&lt;span class=&quot;pl-k&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;pl-v&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;any&lt;/span&gt;[])&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; {} }&amp;gt;(
  &lt;span class=&quot;pl-v&quot;&gt;constructor&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;T&lt;/span&gt;
) {
  &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;pl-e&quot;&gt;constructor&lt;/span&gt; {
    newProperty &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;new property&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;;
    hello &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;override&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;;
  };
}

@&lt;span class=&quot;pl-smi&quot;&gt;classDecorator&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Greeter&lt;/span&gt; {
  property &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;property&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;;
  hello&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;string&lt;/span&gt;;
  &lt;span class=&quot;pl-k&quot;&gt;constructor&lt;/span&gt;(&lt;span class=&quot;pl-v&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;string&lt;/span&gt;) {
    &lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;hello&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;m&lt;/span&gt;;
  }
}

&lt;span class=&quot;pl-c1&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Greeter&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;world&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为 &lt;code&gt;@classDecorator&lt;/code&gt; 中有返回值，这个值将替换本来类的定义，当 &lt;code&gt;new&lt;/code&gt; 的时候，使用的是装饰器中返回的构造器来创建类。&lt;/p&gt;
&lt;h3&gt;方法的装饰器&lt;/h3&gt;
&lt;p&gt;装饰器作用于类的方法时可用于观察，修改或替换该方法。如果装饰器有返回值，将替换掉被作用方法的属性描述器（&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty&quot; rel=&quot;nofollow&quot;&gt;roperty Descriptor&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;装饰器入参依次为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;作用于静态方法时为类的构造器，实例方法时为类的原型（prototype）。&lt;/li&gt;
&lt;li&gt;被作用的方法的名称。&lt;/li&gt;
&lt;li&gt;被作用对象的属性描述器。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;示例：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-ts&quot; readability=&quot;13&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; enumerable(&lt;span class=&quot;pl-v&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;boolean&lt;/span&gt;) {
  &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt;(
    &lt;span class=&quot;pl-v&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;any&lt;/span&gt;,
    &lt;span class=&quot;pl-v&quot;&gt;propertyKey&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;string&lt;/span&gt;,
    &lt;span class=&quot;pl-v&quot;&gt;descriptor&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;PropertyDescriptor&lt;/span&gt;
  ) {
    &lt;span class=&quot;pl-smi&quot;&gt;descriptor&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;enumerable&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;value&lt;/span&gt;;
  };
}

&lt;span class=&quot;pl-k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Greeter&lt;/span&gt; {
  greeting&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;string&lt;/span&gt;;
  &lt;span class=&quot;pl-k&quot;&gt;constructor&lt;/span&gt;(&lt;span class=&quot;pl-v&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;string&lt;/span&gt;) {
    &lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;greeting&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;message&lt;/span&gt;;
  }

  @&lt;span class=&quot;pl-en&quot;&gt;enumerable&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;false&lt;/span&gt;)
  greet() {
    &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;Hello, &lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;greeting&lt;/span&gt;;
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面示例中 &lt;code&gt;@enumerable&lt;/code&gt; 改变了被装饰方法的 &lt;code&gt;enumerable&lt;/code&gt; 属性，控制其是否可枚举。&lt;/p&gt;
&lt;p&gt;类的方法可以是设置器（setter）或获取器（getter）。当两者成对出现时，应当只对其中一个运用装饰器，谁先出现就用在谁身上。因为装饰器应用时是用在 &lt;code&gt;get&lt;/code&gt; 和 &lt;code&gt;set&lt;/code&gt; 两者合并的属性描述器上的。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-ts&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Test&lt;/span&gt; {
  &lt;span class=&quot;pl-k&quot;&gt;private&lt;/span&gt; _foo &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;;
  @&lt;span class=&quot;pl-en&quot;&gt;logFactory&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;[info]&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;)
  &lt;span class=&quot;pl-k&quot;&gt;get&lt;/span&gt; foo() {
    &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;_foo&lt;/span&gt;;
  }
  &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt;🚨 Decorators cannot be applied to multiple get/set accessors of the same name.ts(1207)&lt;/span&gt;
  @&lt;span class=&quot;pl-en&quot;&gt;logFactory&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;[info]&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;)
  &lt;span class=&quot;pl-k&quot;&gt;set&lt;/span&gt; foo(&lt;span class=&quot;pl-v&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;number&lt;/span&gt;) {
    &lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;_foo&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;val&lt;/span&gt;;
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;属性的装饰器&lt;/h3&gt;
&lt;p&gt;作用于类的属性时，其入参依次为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果装饰的是静态属性则为类的构造器，实例属性则为类的原型&lt;/li&gt;
&lt;li&gt;属性名&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;此时并没有提供第三个入参，即该属性的属性描述器。因为定义属性时，没有相应机制来描述该属性，同时属性初始化时也没有方式可以对其进行修改或观察。&lt;/p&gt;
&lt;p&gt;如果装饰器有返回值，将被忽略。&lt;/p&gt;
&lt;p&gt;因此，属性装饰器仅可用于观察某个属性是否被创建。&lt;/p&gt;
&lt;p&gt;一个示例：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-ts&quot; readability=&quot;18&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; logProperty(&lt;span class=&quot;pl-v&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;any&lt;/span&gt;, &lt;span class=&quot;pl-v&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;string&lt;/span&gt;) {
  &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; property value&lt;/span&gt;
  &lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; _val &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt;[&lt;span class=&quot;pl-smi&quot;&gt;key&lt;/span&gt;];

  &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; property getter&lt;/span&gt;
  &lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; getter &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt;() {
    &lt;span class=&quot;pl-c1&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;Get: ${&lt;span class=&quot;pl-smi&quot;&gt;key&lt;/span&gt;} =&amp;gt; ${&lt;span class=&quot;pl-smi&quot;&gt;_val&lt;/span&gt;}&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&lt;/span&gt;);
    &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;_val&lt;/span&gt;;
  };

  &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; property setter&lt;/span&gt;
  &lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; setter &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;pl-v&quot;&gt;newVal&lt;/span&gt;) {
    &lt;span class=&quot;pl-c1&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;Set: ${&lt;span class=&quot;pl-smi&quot;&gt;key&lt;/span&gt;} =&amp;gt; ${&lt;span class=&quot;pl-smi&quot;&gt;newVal&lt;/span&gt;}&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&lt;/span&gt;);
    &lt;span class=&quot;pl-smi&quot;&gt;_val&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;newVal&lt;/span&gt;;
  };

  &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; Delete property.&lt;/span&gt;
  &lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;pl-k&quot;&gt;delete&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt;[&lt;span class=&quot;pl-smi&quot;&gt;key&lt;/span&gt;]) {
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; Create new property with getter and setter&lt;/span&gt;
    &lt;span class=&quot;pl-c1&quot;&gt;Object&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;defineProperty&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;target&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;key&lt;/span&gt;, {
      get: &lt;span class=&quot;pl-smi&quot;&gt;getter&lt;/span&gt;,
      set: &lt;span class=&quot;pl-smi&quot;&gt;setter&lt;/span&gt;,
      enumerable: &lt;span class=&quot;pl-c1&quot;&gt;true&lt;/span&gt;,
      configurable: &lt;span class=&quot;pl-c1&quot;&gt;true&lt;/span&gt;
    });
  }
}

&lt;span class=&quot;pl-k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Person&lt;/span&gt; {
  @&lt;span class=&quot;pl-smi&quot;&gt;logProperty&lt;/span&gt;
  &lt;span class=&quot;pl-k&quot;&gt;public&lt;/span&gt; name&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;string&lt;/span&gt;;
  &lt;span class=&quot;pl-k&quot;&gt;public&lt;/span&gt; surname&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;string&lt;/span&gt;;

  &lt;span class=&quot;pl-k&quot;&gt;constructor&lt;/span&gt;(&lt;span class=&quot;pl-v&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;string&lt;/span&gt;, &lt;span class=&quot;pl-v&quot;&gt;surname&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;string&lt;/span&gt;) {
    &lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;name&lt;/span&gt;;
    &lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;surname&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;surname&lt;/span&gt;;
  }
}

&lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; p &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Person&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;remo&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;Jansen&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
&lt;span class=&quot;pl-smi&quot;&gt;p&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;Remo&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;;
&lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; n &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;p&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;name&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个示例中，通过将原属性删除，创建带设置器和获取器的同名属性，来达到对属性值变化的监听。注意此时操作的已经不是最初那个属性了。&lt;/p&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
Set: name =&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; remo
Set: name =&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; Remo
Get: name =&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; Remo
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;参数的装饰器&lt;/h3&gt;
&lt;p&gt;装饰器也可作用于方法的入参，这个方法不仅限于类的成员方法，还可以是类的构造器。装饰器的返回值会被忽略。&lt;/p&gt;
&lt;p&gt;当作用于方法的参数时，装饰器的入参依次为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果装饰的是静态方法则为类的构造器，实例方法则为类的原型。&lt;/li&gt;
&lt;li&gt;被装饰的参数名。&lt;/li&gt;
&lt;li&gt;参数在参数列表中的索引。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;比如，定义一个参数为必传的：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-ts&quot; readability=&quot;23&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;reflect-metadata&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;;

&lt;span class=&quot;pl-k&quot;&gt;&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt;&lt;/span&gt; requiredMetadataKey &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;Symbol&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;required&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);

&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; required(
  &lt;span class=&quot;pl-v&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Object&lt;/span&gt;,
  &lt;span class=&quot;pl-v&quot;&gt;propertyKey&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;symbol&lt;/span&gt;,
  &lt;span class=&quot;pl-v&quot;&gt;parameterIndex&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;number&lt;/span&gt;
) {
  &lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; existingRequiredParameters&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;number&lt;/span&gt;[] &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt;
    &lt;span class=&quot;pl-c1&quot;&gt;Reflect&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;getOwnMetadata&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;requiredMetadataKey&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;target&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;propertyKey&lt;/span&gt;) &lt;span class=&quot;pl-k&quot;&gt;||&lt;/span&gt; [];
  &lt;span class=&quot;pl-smi&quot;&gt;existingRequiredParameters&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;push&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;parameterIndex&lt;/span&gt;);
  &lt;span class=&quot;pl-c1&quot;&gt;Reflect&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;defineMetadata&lt;/span&gt;(
    &lt;span class=&quot;pl-smi&quot;&gt;requiredMetadataKey&lt;/span&gt;,
    &lt;span class=&quot;pl-smi&quot;&gt;existingRequiredParameters&lt;/span&gt;,
    &lt;span class=&quot;pl-smi&quot;&gt;target&lt;/span&gt;,
    &lt;span class=&quot;pl-smi&quot;&gt;propertyKey&lt;/span&gt;
  );
}

&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; validate(
  &lt;span class=&quot;pl-v&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;any&lt;/span&gt;,
  &lt;span class=&quot;pl-v&quot;&gt;propertyName&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;string&lt;/span&gt;,
  &lt;span class=&quot;pl-v&quot;&gt;descriptor&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;TypedPropertyDescriptor&lt;/span&gt;&amp;lt;&lt;span class=&quot;pl-en&quot;&gt;Function&lt;/span&gt;&amp;gt;
) {
  &lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; method &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;descriptor&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;value&lt;/span&gt;;
  &lt;span class=&quot;pl-smi&quot;&gt;descriptor&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt;() {
    &lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; requiredParameters&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;number&lt;/span&gt;[] &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;Reflect&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;getOwnMetadata&lt;/span&gt;(
      &lt;span class=&quot;pl-smi&quot;&gt;requiredMetadataKey&lt;/span&gt;,
      &lt;span class=&quot;pl-smi&quot;&gt;target&lt;/span&gt;,
      &lt;span class=&quot;pl-smi&quot;&gt;propertyName&lt;/span&gt;
    );
    &lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;pl-smi&quot;&gt;requiredParameters&lt;/span&gt;) {
      &lt;span class=&quot;pl-k&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;pl-k&quot;&gt;let&lt;/span&gt; parameterIndex &lt;span class=&quot;pl-k&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;requiredParameters&lt;/span&gt;) {
        &lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; (
          &lt;span class=&quot;pl-smi&quot;&gt;parameterIndex&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;arguments&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;||&lt;/span&gt;
          &lt;span class=&quot;pl-c1&quot;&gt;arguments&lt;/span&gt;[&lt;span class=&quot;pl-smi&quot;&gt;parameterIndex&lt;/span&gt;] &lt;span class=&quot;pl-k&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;undefined&lt;/span&gt;
        ) {
          &lt;span class=&quot;pl-k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Error&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;Missing required argument.&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
        }
      }
    }

    &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;method&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;apply&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;arguments&lt;/span&gt;);
  };
}

&lt;span class=&quot;pl-k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Greeter&lt;/span&gt; {
  greeting&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;string&lt;/span&gt;;

  &lt;span class=&quot;pl-k&quot;&gt;constructor&lt;/span&gt;(&lt;span class=&quot;pl-v&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;string&lt;/span&gt;) {
    &lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;greeting&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;message&lt;/span&gt;;
  }

  @&lt;span class=&quot;pl-smi&quot;&gt;validate&lt;/span&gt;
  greet(@&lt;span class=&quot;pl-smi&quot;&gt;required&lt;/span&gt; &lt;span class=&quot;pl-v&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;string&lt;/span&gt;) {
    &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;Hello &lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;, &lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;greeting&lt;/span&gt;;
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面示例中，&lt;code&gt;@required&lt;/code&gt; 将参数标记为必需，配合 &lt;code&gt;@validate&lt;/code&gt; 在调用真实的方法前进行检查。&lt;/p&gt;
&lt;h2&gt;相关资源&lt;/h2&gt;
</description>
<pubDate>Wed, 29 May 2019 17:06:00 +0000</pubDate>
<dc:creator>刘哇勇</dc:creator>
<og:description>装饰器（Decorators）可用来装饰类，属性，及方法，甚至是函数的参数，以改变和控制这些对象的表现，获得一些功能。 装饰器以 @expression 形式呈现在被装饰对象的前面或者上方，其中 ex</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Wayou/p/typescript_decorator.html</dc:identifier>
</item>
<item>
<title>MemCache与redis - 老鼠蟒蛇</title>
<link>http://www.cnblogs.com/lowbi/p/10947271.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lowbi/p/10947271.html</guid>
<description>&lt;p&gt;&lt;span&gt;以下内容为个人理解所得,如要转载,请标明出处:&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;像项目中首页的大广告和商品类目这些&lt;code&gt;不需要经常修改&lt;/code&gt;的数据，如果用户每次刷新页面的时候都要去数据库中查询，这样会&lt;code&gt;浪费资&lt;/code&gt;源和&lt;code&gt;增加数据库的压力&lt;/code&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以我们想当把这些数据添加到一个&lt;code&gt;缓存&lt;/code&gt;中，用户去访问的时候，先去&lt;code&gt;缓存中查找&lt;/code&gt;，如果命中失败，再去数据库中查询，然后把查询到的数据添加到缓存中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;目前比较主流的缓存技术有&lt;code&gt;Redis&lt;/code&gt;和&lt;code&gt;Memcached&lt;/code&gt;，单纯从缓存命中的角度来说，Memcached要高一些，可Redis和Memcache的差距其实并不大，但Redis提供的功能更加强大一些，&lt;code&gt;读写速度也很快&lt;/code&gt;。所以我们选用了Redis来缓存数据。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;redis把数据以key—value的形式缓存到内存中，并提供了多种数据存储类型（String、Hash、list、Set、SortedSet），还自身提供了&lt;code&gt;持久化功能（2种：RDB、AOF）&lt;/code&gt;，还可以把数据备份到磁盘中（redis的SAVE命令用于创建当前 redis数据库的备份），防止redis宕机时的数据丢失。（会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了&lt;code&gt;master-slave(&lt;/code&gt;&lt;code&gt;主从)同步&lt;/code&gt;）。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;1,&lt;/strong&gt;&lt;strong&gt;存储方式不同&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;memecache 把数据全部存在内存之中，数据不能超过内存大小；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;redis有部份存在硬盘上，这样能保证数据的持久性，支持数据的持久化&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;2,数据支持类型不同&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Redis支持的数据类型比memcache多的多&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Redis支持的数据类型: String、Hash、list,数组,集合&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Memcache仅仅支持简单数据类型 ，复杂数据类型需要应用自己处理&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;他们都是以key-value的类型存储数据&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.为什么&lt;/strong&gt;&lt;strong&gt;redis&lt;/strong&gt;&lt;strong&gt;比&lt;/strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;a title=&quot;Memcached&quot; href=&quot;https://www.sojson.com/tag_memcached.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;&lt;strong&gt;Memcached&lt;/strong&gt;&lt;/span&gt;&lt;/a&gt;&lt;strong&gt;要快?&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;a title=&quot;Memcached&quot; href=&quot;https://www.sojson.com/tag_memcached.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;Memcached&lt;/span&gt;&lt;/a&gt;  完全基于内存，而&lt;code&gt;Redis&lt;/code&gt; 具有持久化保存特性，即使是异步的，&lt;code&gt;Redis&lt;/code&gt; 也不可能比&lt;code&gt;Memcached&lt;/code&gt; 快。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;Memcached&lt;/code&gt;底层用的是&lt;code&gt;Libevent&lt;/code&gt;，Redis并没有选择&lt;code&gt;Libevent&lt;/code&gt; 。&lt;code&gt;Libevent&lt;/code&gt; 为了迎合通用性,使得他的底层代码庞大而Redis的底层代码还不到libevent的1/3 ,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是也牺牲了redis通用性,现在在redis的官网上,他说明了redis只能在Liuse上使用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;CAS&lt;/code&gt; 问题。&lt;code&gt;CAS&lt;/code&gt; 是&lt;code&gt;Memcached&lt;/code&gt; 中比较方便的一种防止竞争修改资源的方法。&lt;code&gt;CAS&lt;/code&gt; 实现需要为每个cache key设置一个隐藏的&lt;code&gt;cas token&lt;/code&gt; ，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;cas&lt;/code&gt; 相当&lt;code&gt;value&lt;/code&gt; 版本号，每次&lt;code&gt;set&lt;/code&gt;会&lt;code&gt;token&lt;/code&gt; 需要递增，因此带来CPU和内存的双重开销，虽然这些开销很小，&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 29 May 2019 16:31:00 +0000</pubDate>
<dc:creator>老鼠蟒蛇</dc:creator>
<og:description>以下内容为个人理解所得,如要转载,请标明出处: 像项目中首页的大广告和商品类目这些不需要经常修改的数据，如果用户每次刷新页面的时候都要去数据库中查询，这样会浪费资源和增加数据库的压力。 所以我们想当把</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lowbi/p/10947271.html</dc:identifier>
</item>
<item>
<title>WebSocket协议入门介绍 - 2Simple</title>
<link>http://www.cnblogs.com/nuccch/p/10947256.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nuccch/p/10947256.html</guid>
<description>&lt;h2 id=&quot;目录&quot;&gt;目录&lt;/h2&gt;
&lt;h2 id=&quot;websocket协议是什么&quot;&gt;WebSocket协议是什么&lt;/h2&gt;
&lt;h3 id=&quot;websocket是应用层协议&quot;&gt;WebSocket是应用层协议&lt;/h3&gt;
&lt;p&gt;WebSocket是基于TCP的应用层协议，用于在C/S架构的应用中实现双向通信，关于WebSocket协议的详细规范和定义参见&lt;a href=&quot;https://tools.ietf.org/html/rfc6455&quot;&gt;rfc6455&lt;/a&gt;。&lt;br/&gt;需要特别注意的是：虽然WebSocket协议在建立连接时会使用HTTP协议，但这并意味着WebSocket协议是基于HTTP协议实现的。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/722072/201905/722072-20190530002410619-850762459.png&quot; alt=&quot;WebSocket属于应用层协议&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;websocket与http的区别&quot;&gt;WebSocket与Http的区别&lt;/h3&gt;
&lt;p&gt;实际上，WebSocket协议与Http协议有着本质的区别：&lt;br/&gt;&lt;strong&gt;1.通信方式不同&lt;/strong&gt;&lt;br/&gt;WebSocket是双向通信模式，客户端与服务器之间只有在握手阶段是使用HTTP协议的“请求-响应”模式交互，而一旦连接建立之后的通信则使用双向模式交互，不论是客户端还是服务端都可以随时将数据发送给对方；而HTTP协议则至始至终都采用“请求-响应”模式进行通信。也正因为如此，HTTP协议的通信效率没有WebSocket高。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/722072/201905/722072-20190530002436087-2075657243.png&quot; alt=&quot;WebSocket与Http协议的交互方式对比&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.协议格式不同&lt;/strong&gt;&lt;br/&gt;WebSocket与HTTP的协议格式是完全不同的，具体来讲：&lt;br/&gt;（1）HTTP协议（参见：&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;rfc2616&lt;/a&gt;）比较臃肿，而WebSocket协议比较轻量。&lt;br/&gt;（2）对于HTTP协议来讲，一个数据包就是一条完整的消息；而WebSocket客户端与服务端通信的最小单位是帧（frame），由1个或多个帧组成一条完整的消息（message）。即：发送端将消息切割成多个帧，并发送给服务端；服务端接收消息帧，并将关联的帧重新组装成完整的消息。&lt;br/&gt;WebSocket协议格式：&lt;/p&gt;
&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt; 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-------+-+-------------+-------------------------------+
|F|R|R|R| opcode|M| Payload len |    Extended payload length    |
|I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |
|N|V|V|V|       |S|             |   (if payload len==126/127)   |
| |1|2|3|       |K|             |                               |
+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
|     Extended payload length continued, if payload len == 127  |
+ - - - - - - - - - - - - - - - +-------------------------------+
|                               |Masking-key, if MASK set to 1  |
+-------------------------------+-------------------------------+
| Masking-key (continued)       |          Payload Data         |
+-------------------------------- - - - - - - - - - - - - - - - +
:                     Payload Data continued ...                :
+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
|                     Payload Data continued ...                |
+---------------------------------------------------------------+&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;HTTP请求消息格式：&lt;/p&gt;
&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;Request-LineCRLF
general-headerCRLF
request-headerCRLF
entity-headerCRLF
CRLF
[ message-body ]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;HTTP响应消息格式：&lt;/p&gt;
&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;Status-LineCRLF
general-headerCRLF
response-headerCRLF
entity-headerCRLF
CRLF
[ message-body ]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;虽然WebSocket和HTTP是不同应用协议，但&lt;a href=&quot;https://tools.ietf.org/html/rfc6455&quot;&gt;rfc6455&lt;/a&gt;规定：“WebSocket设计为通过80和443端口工作，以及支持HTTP代理和中介”，从而使其与HTTP协议兼容。为了实现兼容性，WebSocket握手时使用HTTP Upgrade头从HTTP协议更改为WebSocket协议，参考：&lt;a href=&quot;https://zh.wikipedia.org/wiki/WebSocket&quot;&gt;WebSocket维基百科&lt;/a&gt; 。&lt;/p&gt;
&lt;h2 id=&quot;为什么要使用websocket&quot;&gt;为什么要使用WebSocket&lt;/h2&gt;
&lt;p&gt;随着Web应用的发展，特别是动态网页的普及，越来越多的场景需要实现数据动态刷新。&lt;br/&gt;在早期的时候，实现数据刷新的方式通常有如下3种：&lt;br/&gt;&lt;strong&gt;1.客户端定时查询&lt;/strong&gt;&lt;br/&gt;客户端定时查询（如：每隔10秒钟查询一次）是最原始也是最简单的实现数据刷新的方法，服务端不用做任何改动，只需要在客户端添加一个定时器即可。但是这种方式的缺点也很明显：大量的定时请求都是无效的，因为服务端的数据并没有更新，相应地也导致了大量的带宽浪费。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.长轮训机制&lt;/strong&gt;&lt;br/&gt;长轮训机制是对客户端定时查询的一种改进，即：客户端依旧保持定时发送请求给服务端，但是服务端并不立即响应，而是等到真正有数据更新的时候才发送给客户端。实际上，并不是当没有数据更新时服务端就永远都不响应客户端，而是需要在等待一个超时时间之后结束该次长轮训请求。相对于客户端定时查询方式而言，当数据更新频率不确定时长轮训机制能够很明显地减少请求数。但是，在数据更新比较频繁的场景下，长轮训方式的优势就没那么明显了。&lt;br/&gt;在Web开发中使用得最为普遍的长轮训实现方案为Comet（&lt;a href=&quot;https://zh.wikipedia.org/wiki/Comet_(web%E6%8A%80%E6%9C%AF)&quot;&gt;Comet (web技术)&lt;/a&gt;），Tomcat和Jetty都有对应的实现支持，详见：&lt;a href=&quot;https://wiki.apache.org/tomcat/WhatIsComet&quot;&gt;WhatIsComet&lt;/a&gt;，&lt;a href=&quot;https://www.eclipse.org/jetty/documentation/9.4.x/continuations.html#continuations-intro&quot;&gt;Why Asynchronous Servlets&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.HTTP Streaming&lt;/strong&gt;&lt;br/&gt;不论是长轮训机制还是传统的客户端定时查询方式，都需要客户端不断地发送请求以获取数据更新，而HTTP Streaming则试图改变这种方式，其实现机制为：客户端发送获取数据更新请求到服务端时，服务端将保持该请求的响应数据流一直打开，只要有数据更新就实时地发送给客户端。&lt;br/&gt;虽然这个设想是非常美好的，但这带来了新的问题：&lt;br/&gt;(1)HTTP Streaming的实现机制违背了HTTP协议本身的语义，使得客户端与服务端不再是“请求-响应”的交互方式，而是直接在二者建立起了一个单向的“通信管道”。&lt;br/&gt;(2)在HTTP Streaming模式下，服务端只要得到数据更新就发送给客户端，那么就需要客户端与服务端协商如何区分每一个更新数据包的开始和结尾，否则就可能出现解析数据错误的情况。&lt;br/&gt;(3)另外，处于客户端与服务端的网络中介（如：代理）可能会缓存响应数据流，这可能会导致客户端无法真正获取到服务端的更新数据，这实际上与HTTP Streaming的本意是相违背的。&lt;br/&gt;鉴于上述原因，在实际应用中HTTP Streaming并没有真正流行起来，反之使用得最多的是长轮训机制。&lt;/p&gt;
&lt;p&gt;显然，上述几种实现数据动态刷新的方式都是基于HTTP协议实现的，或多或少地存在这样那样的问题和缺陷；而&lt;strong&gt;WebSocket&lt;/strong&gt;是一个全新的应用层协议，专门用于Web应用中需要实现动态刷新的场景。&lt;br/&gt;相比起HTTP协议，WebSocket具备如下特点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;支持双向通信，实时性更强。&lt;/li&gt;
&lt;li&gt;更好的二进制支持。&lt;/li&gt;
&lt;li&gt;较少的控制开销：连接创建后，WebSockete客户端、服务端进行数据交换时，协议控制的数据包头部较小。&lt;/li&gt;
&lt;li&gt;支持扩展。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;如何使用websocket&quot;&gt;如何使用WebSocket&lt;/h2&gt;
&lt;h3 id=&quot;客户端api&quot;&gt;客户端API&lt;/h3&gt;
&lt;p&gt;在Web应用的网页中使用WebSocket，WebSocket对象提供了用于创建和管理WebSocket连接，以及可以通过该连接发送和接收数据的API。&lt;br/&gt;&lt;strong&gt;1.构造函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以使用WebSocket类的构造函数（WebSocket(url[, protocols])）实例化一个对象，如：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var url = &quot;ws://host:port/endpoint&quot;;
var ws = new WebSocket(url);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行上述语句之后，浏览器将与服务端建立一个WebSocket连接，同时返回一个WebSocket实例对象ws。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.对象属性&lt;/strong&gt;&lt;br/&gt;WebSocket实例对象具备如下属性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;WebSocket.binaryType: 返回websocket连接所传输二进制数据的类型。&lt;/li&gt;
&lt;li&gt;WebSocket.bufferedAmount：只读属性，用于返回已经被send()方法放入队列中但还没有被发送到网络中的数据的字节数。一旦队列中的所有数据被发送至网络，则该属性值将被重置为0。但是，若在发送过程中连接被关闭，则属性值不会重置为0。如果你不断地调用send()，则该属性值会持续增长。&lt;/li&gt;
&lt;li&gt;WebSocket.extensions：只读属性，返回服务器已选择的扩展值。目前，链接可以协定的扩展值只有空字符串或者一个扩展列表。&lt;/li&gt;
&lt;li&gt;WebSocket.protocol：只读属性，用于返回服务器端选中的子协议的名字；这是一个在创建WebSocket对象时，在参数protocols中指定的字符串。&lt;/li&gt;
&lt;li&gt;WebSocket.readyState：只读属性，返回当前WebSocket对象的链接状态，可能的值为WebSocket中定义的常量：WebSocket.CONNECTING，WebSocket.OPEN，WebSocket.CLOSING，WebSocket.CLOSED。&lt;/li&gt;
&lt;li&gt;WebSocket.url：只读属性，返回值为当构造函数创建WebSocket实例对象时URL的绝对路径。&lt;/li&gt;
&lt;li&gt;WebSocket.onopen：用于指定连接成功后的回调函数，当WebSocket的连接状态readyState变为“OPEN”时调用；这意味着当前连接已经准备好发送和接受数据，这个事件处理程序通过事件（建立连接时）触发。&lt;/li&gt;
&lt;li&gt;WebSocket.onclose：用于指定连接关闭后的回调函数，当WebSocket的连接状态readyState变为“CLOSED”时被调用，它接收一个名字为“close”的CloseEvent事件对象。&lt;/li&gt;
&lt;li&gt;WebSocket.onmessage：用于指定当从服务器接受到信息时的回调函数，当从服务器收到一条消息时，该回调函数将被调用，在函数中接受一命名为“message”的MessageEvent事件对象。&lt;/li&gt;
&lt;li&gt;WebSocket.onerror：用于指定连接失败后的回调函数，定义一个发生错误时执行的回调函数，此事件的事件名为&quot;error&quot;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;3.对象方法&lt;/strong&gt;&lt;br/&gt;WebSocket定义了2个方法：&lt;br/&gt;(1)WebSocket.send(data)：向服务器发送数据，将需要通过WebSocket连接传输至服务器的数据排入队列，并根据所需要传输的数据字节的大小来增加属性bufferedAmount的值 。若数据无法传输（例如数据需要缓存而缓冲区已满）时，套接字会自行关闭。&lt;br/&gt;参数data为传输至服务器的数据，它必须是以下类型之一：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;USVString：文本字符串。字符串将以UTF-8格式添加到缓冲区，并且属性bufferedAmount将加上该字符串以UTF-8格式编码时的字节数的值。&lt;/li&gt;
&lt;li&gt;ArrayBuffer：您可以使用一个有类型的数组对象发送底层二进制数据，其二进制数据内存将被缓存于缓冲区，属性bufferedAmount将加上所需字节数的值。&lt;/li&gt;
&lt;li&gt;Blob：Blob类型将队列blob中的原始数据以二进制传输，属性bufferedAmount将加上原始数据的字节数的值。&lt;/li&gt;
&lt;li&gt;ArrayBufferView：以二进制帧的形式发送任何JavaScript类数组对象，其二进制数据内容将被队列于缓冲区中，属性bufferedAmount将加上对应字节数的值。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;(2)WebSocket.close([code[, reason]])：关闭当前连接，如果连接已经关闭，则此方法不执行任何操作。&lt;br/&gt;参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;code：可选，为一个数字状态码，它解释了连接关闭的原因。如果没有传这个参数，默认使用1005。CloseEvent的允许的状态码见状&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes&quot;&gt;态码列表&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;reason：可选，一个人类可读的字符串，它解释了连接关闭的原因，这个UTF-8编码的字符串不能超过123个字节。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;异常：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;INVALID_ACCESS_ERR：一个无效的code。&lt;/li&gt;
&lt;li&gt;SYNTAX_ERR：reason字符串太长（超过123字节）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;更多WebSockete API的详细内容参见W3C的定义：&lt;a href=&quot;https://www.w3.org/TR/websockets/&quot;&gt;The WebSocket API&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;在客户端使用websocket&quot;&gt;在客户端使用WebSocket&lt;/h3&gt;
&lt;p&gt;如下为在网页中使用原生WebSocket的实现方式。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var url = &quot;ws://localhost:8080/websocket/text&quot;;
var ws = new WebSocket(url);
ws.onopen = function(event) {
    console.log(&quot;websocket connection open.&quot;);
    console.log(event);
};

ws.onmessage = function(event) {
    console.log(&quot;websocket message received.&quot;)
    console.log(event.data);
};

ws.onclose = function (event) {
    console.log(&quot;websocket connection close.&quot;);
    console.log(event.code);
};

ws.onerror = function(event) {
    console.log(&quot;websocket connection error.&quot;);
    console.log(event);
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在Web网页中使用WebSocket需要浏览器支持，不同浏览器软件版本对WebSocket的支持情况详见&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7&quot;&gt;浏览器兼容性&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;另外，WebSocket客户端除了可以在网页中使用，目前还存在一些独立的客户端组件，如：&lt;br/&gt;1.&lt;a href=&quot;https://www.eclipse.org/jetty/documentation/current/jetty-websocket-client-api.html&quot;&gt;Jetty WebSocket Client API&lt;/a&gt;&lt;br/&gt;2.&lt;a href=&quot;https://www.baeldung.com/websockets-api-java-spring-client&quot;&gt;websockets-api-java-spring-client&lt;/a&gt;&lt;br/&gt;3.&lt;a href=&quot;https://github.com/TooTallNate/Java-WebSocket&quot;&gt;Java-WebSocket&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;在服务端使用websocket&quot;&gt;在服务端使用WebSocket&lt;/h3&gt;
&lt;p&gt;在服务端使用WebSocket需要服务器组件支持，如下以在Tomcat 8.5.41（Tomcat 7之后才支持WebSocket）中使用原生WebSocket为例。&lt;br/&gt;由于在服务端使用WebSocket需要使用到WebSocket的API，因此需要添加API依赖管理：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.apache.tomcat&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;tomcat-websocket-api&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;8.5.41&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用注解方式编写WebSocket服务端：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@ServerEndpoint(value=&quot;/websocket/text&quot;)
public class WebSocketTest {
    private static final Logger logger = LoggerFactory.getLogger(WsChatAnnotation.class);
    
    private static final AtomicInteger counter = new AtomicInteger(0);                                    // 客户端计数器
    private static final Set&amp;lt;WsChatAnnotation&amp;gt; connections = new CopyOnWriteArraySet&amp;lt;WsChatAnnotation&amp;gt;(); // 客户端websocket连接集合
    private Session session = null;                                                                       // WebSocket会话对象
    private Integer number = 0;                                                                           // 客户端编号

    public WsChatAnnotation() {
        number = counter.incrementAndGet();
    }
    
    /**
     * 客户端建立websocket连接
     * @param session
     */
    @OnOpen
    public void start(Session session) {
        logger.info(&quot;on open&quot;);
        this.session = session;
        connections.add(this);
        try {
            session.getBasicRemote().sendText(new StringBuffer().append(&quot;Hello: &quot;).append(number).toString());
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    
    /**
     * 客户端断开websocket连接
     */
    @OnClose
    public void close() {
        logger.info(&quot;session close&quot;);
        try {
            this.session.close();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            connections.remove(this);
        }
    }
    
    /**
     * 接收客户端发送的消息
     * @param message
     */
    @OnMessage
    public void message(String message) {
        logger.info(&quot;message: {}&quot;, message);
        for(WsChatAnnotation client : connections) {
            synchronized (client) {
                try {
                    client.session.getBasicRemote().sendText(message);
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
    
    @OnError
    public void error(Throwable t) {
        logger.error(&quot;client: {} error&quot;, number, t.getMessage());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;反向代理对websocket的支持&quot;&gt;反向代理对WebSocket的支持&lt;/h3&gt;
&lt;p&gt;当下的Web应用架构通常都是集群化部署，前端使用反向代理或者直接部署负载均衡器，这就要求反向代理或者负载均衡器必须支持WebSocket协议。&lt;br/&gt;目前Nginx，Haporxy都已经支持WebSocket协议。&lt;/p&gt;
&lt;p&gt;如下为在使用nginx作为反向代理的场景下，配置nginx代理websocket协议。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# add websocket proxy
location ~ /ws {
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection &quot;upgrade&quot;;
    proxy_pass http://8080;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;【参考】&lt;br/&gt;&lt;a href=&quot;https://spring.io/blog/2012/05/08/spring-mvc-3-2-preview-techniques-for-real-time-updates/&quot; class=&quot;uri&quot;&gt;https://spring.io/blog/2012/05/08/spring-mvc-3-2-preview-techniques-for-real-time-updates/&lt;/a&gt; Spring MVC 3.2 Preview: Techniques for Real-time Updates&lt;br/&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&quot;&gt;https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&lt;/a&gt; WebSocket&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/chyingp/p/websocket-deep-in.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/chyingp/p/websocket-deep-in.html&lt;/a&gt; WebSocket协议：5分钟从入门到精通&lt;br/&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2017/05/websocket.html&quot; class=&quot;uri&quot;&gt;http://www.ruanyifeng.com/blog/2017/05/websocket.html&lt;/a&gt; WebSocket 教程&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/chszs/article/details/26369257&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/chszs/article/details/26369257&lt;/a&gt; Nginx担当WebSockets代理&lt;br/&gt;&lt;a href=&quot;http://blog.fens.me/nodejs-websocket-nginx/&quot; class=&quot;uri&quot;&gt;http://blog.fens.me/nodejs-websocket-nginx/&lt;/a&gt; Nginx反向代理Websocket&lt;/p&gt;
</description>
<pubDate>Wed, 29 May 2019 16:26:00 +0000</pubDate>
<dc:creator>2Simple</dc:creator>
<og:description>目录 '目录' 'WebSocket协议是什么' 'WebSocket是应用层协议' 'WebSocket与Http的区别' '为什么要使用WebSocket' '如何使用WebSocket' '客户</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/nuccch/p/10947256.html</dc:identifier>
</item>
<item>
<title>O(1)纬度减少循环次数 - 涛姐涛哥</title>
<link>http://www.cnblogs.com/taojietaoge/p/10947214.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/taojietaoge/p/10947214.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;O(1)纬度减少循环次数&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;平时看淡，不服就干。老子有句粗口话不知道当不当讲，我们公司上一次发工资时4月4号，时至今日5-30已经有57天没有发工资了，我还要继续坚持下去吗？难不成现在大家工作都TM的不在乎钱了的吗？&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用O(1)纬度减少循环次数，提高代码质量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;需要实现匹配list1 和 list2 中keyName相等的cipher，并把list1中的cipher写入list2：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.xinyan.springcloud.tjt;
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; 
&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.ArrayList;
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.HashMap;
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Map;
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; 
&lt;span&gt;  8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.commons.lang.StringUtils;
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; 
&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; lombok.Data;
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt; 
&lt;span&gt; 12&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CompareOne {
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; List&amp;lt;KeyInfo&amp;gt; list1 = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; List&amp;lt;CipherPathInfo&amp;gt; list2 = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt; 
&lt;span&gt; 16&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 17&lt;/span&gt; &lt;span&gt;     * 比较low的methodOne设计
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 19&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; methodOne() {
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 匹配list1 和 list2 中keyName相等的cipher，并把list1中的cipher写入list2：
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设计方案1:&lt;/span&gt;
&lt;span&gt; 22&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; list1.size(); i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt;             KeyInfo keyInfo =&lt;span&gt; list1.get(i);
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt;             String keyName =&lt;span&gt; keyInfo.getKeyName();
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt;             String cipher =&lt;span&gt; keyInfo.getCipher();
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = 0; j &amp;lt; list2.size(); j++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt;                 CipherPathInfo cipherPathInfo =&lt;span&gt; list2.get(j);
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt;                 String keyName2 =&lt;span&gt; cipherPathInfo.getKeyName();
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (StringUtils.equals(keyName, keyName2)) {
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt; &lt;span&gt;                    cipherPathInfo.setCipher(cipher);
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt; 
&lt;span&gt; 36&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 37&lt;/span&gt; &lt;span&gt;     * 较好的methodTwo设计
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 39&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; methodTwo() {
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 匹配list1 和 list2 中keyName相等的cipher，并把list1中的cipher写入list2：
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设计方案2:&lt;/span&gt;
&lt;span&gt; 42&lt;/span&gt;         Map&amp;lt;String, String&amp;gt; keyNameMap = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用keyNameMap缓存keyName的cipher&lt;/span&gt;
&lt;span&gt; 44&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; list1.size(); i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt;             KeyInfo keyInfo =&lt;span&gt; list1.get(i);
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt;             String keyName =&lt;span&gt; keyInfo.getKeyName();
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt;             String cipher =&lt;span&gt; keyInfo.getCipher();
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt; &lt;span&gt;            keyNameMap.put(keyName, cipher);
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据keyName的名称查keyNameMap取出cipher&lt;/span&gt;
&lt;span&gt; 51&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = 0; j &amp;lt; list2.size(); j++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt;             CipherPathInfo cipherPathInfo =&lt;span&gt; list2.get(j);
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt;             String keyName =&lt;span&gt; cipherPathInfo.getKeyName();
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;             String cipher =&lt;span&gt; keyNameMap.get(keyName);
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (StringUtils.isNotEmpty(cipher)) {
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt; &lt;span&gt;                cipherPathInfo.setCipher(cipher);
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt; 
&lt;span&gt; 61&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 62&lt;/span&gt; &lt;span&gt;     * 实体KeyInfo
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt; &lt;span&gt;     * 
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; apple
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 66&lt;/span&gt; &lt;span&gt;    @Data
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt;     &lt;span&gt;class&lt;/span&gt;&lt;span&gt; KeyInfo {
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String keyName;
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String cipher;
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt; 
&lt;span&gt; 72&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 73&lt;/span&gt; &lt;span&gt;     * 实体CipherPathInfo
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt; &lt;span&gt;     * 
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; apple
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 77&lt;/span&gt; &lt;span&gt;    @Data
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt;     &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CipherPathInfo {
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String keyName;
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String cipher;
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String path;
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt; 
&lt;span&gt; 84&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 85&lt;/span&gt; &lt;span&gt;     * 构造KeyInfo、CipherPathInfo实体信息
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 87&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; makeEntityInfo() {
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt;         KeyInfo keyInfo = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; KeyInfo();
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 构造30个keyInfo实体&lt;/span&gt;
&lt;span&gt; 90&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 30; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt;             keyInfo.setKeyName(&quot;name_&quot; +&lt;span&gt; i);
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt;             keyInfo.setCipher(&quot;cipher_&quot; +&lt;span&gt; i);
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt; &lt;span&gt;            list1.add(keyInfo);
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt;         CipherPathInfo cipherPathInfo = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CipherPathInfo();
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 构造100个ciperhPathInfo实体，其中cipher为null&lt;/span&gt;
&lt;span&gt; 97&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = 0; j &amp;lt; 100; j++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt;             cipherPathInfo.setKeyName(&quot;name_&quot; +&lt;span&gt; j);
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;             cipherPathInfo.setPath(&quot;path_&quot; +&lt;span&gt; j);
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; &lt;span&gt;            list2.add(cipherPathInfo);
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt; 
&lt;span&gt;104&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt;         CompareOne c = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CompareOne();
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt; &lt;span&gt;        c.makeEntityInfo();
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 匹配list1 和 list2 中keyName相等的cipher，并把list1中的cipher写入list2：
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设计方案1:&lt;/span&gt;
&lt;span&gt;109&lt;/span&gt; &lt;span&gt;        c.methodOne();
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 方案1设计明显不合理，很low；其中list1有30个元素，而list2有100个
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这样就会累计循环30*100次
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 可以将讲list1中获取到的keyName插入哈希中，只需要O(1)的纬度
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 方案设计2:&lt;/span&gt;
&lt;span&gt;114&lt;/span&gt; &lt;span&gt;        c.methodTwo();
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt; 
&lt;span&gt;116&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt; 
&lt;span&gt;118&lt;/span&gt; }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Wed, 29 May 2019 16:09:00 +0000</pubDate>
<dc:creator>涛姐涛哥</dc:creator>
<og:description>O(1)纬度减少循环次数 平时看淡，不服就干。老子有句粗口话不知道当不当讲，我们公司上一次发工资时4月4号，时至今日5-30已经有57天没有发工资了，我还要继续坚持下去吗？难不成现在大家工作都TM的不</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/taojietaoge/p/10947214.html</dc:identifier>
</item>
<item>
<title>贪婪算法回顾 - 牛牛的编程之路</title>
<link>http://www.cnblogs.com/hujingnb/p/10947152.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hujingnb/p/10947152.html</guid>
<description>&lt;h2 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;回顾&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;还记的贪婪算法么? 如果你不记得了, 看了下面这个例子你一定会想起来, 因为这个例子太普遍了, 几乎每个将贪婪算法的地方, 第一个例子都是它, 言归正传.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span&gt;&lt;strong&gt;问题&lt;/strong&gt;&lt;span class=&quot;md-plain&quot;&gt;: 现在有如下课程表, 要将这些课尽可能多的安排在教室A内.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;table class=&quot;md-table&quot;&gt;&lt;thead&gt;&lt;tr class=&quot;md-end-block&quot;&gt;&lt;th&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;课程名&lt;/span&gt;&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;开始时间&lt;/span&gt;&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;结束时间&lt;/span&gt;&lt;/span&gt;&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr class=&quot;md-end-block&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;语文课&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;9:00&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;10:00&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;数学课&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;9:30&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;10:30&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;音乐课&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;10:00&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;11:00&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;政治课&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;10:30&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;11:30&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;美术课&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;11:00&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;12:00&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;首先将所有课程都安排在教师A是不现实的, 因为时间上存在冲突. 那改怎么安排呢?&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;这个问题很难, 对吧. 算了, 至少我第一次看的时候, 完全没有头绪. 但看了下面的思路, 你又会发现, 啊?这么简单么?&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span&gt;&lt;strong&gt;具体思路&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;ol-list&quot; start=&quot;&quot; readability=&quot;1&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;选出结束时间最早的课程, 将它加到教室A的第一节课&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;2&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;找出在当前教室A最后一节课的结束时间之后开始, 并且结束时间最早的课程, 将其加到教室A的课表中&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;重复步骤2&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;经过上面的步骤, 得出的课表为:&lt;/span&gt;&lt;/p&gt;
&lt;table class=&quot;md-table&quot;&gt;&lt;thead&gt;&lt;tr class=&quot;md-end-block&quot;&gt;&lt;th&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;课程名&lt;/span&gt;&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;开始时间&lt;/span&gt;&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;结束时间&lt;/span&gt;&lt;/span&gt;&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr class=&quot;md-end-block&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;语文课&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;9:00&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;10:00&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;音乐课&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;10:00&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;11:00&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;美术课&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;11:00&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;12:00&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;如何, 是不是感觉这个算法太简单了, 简单到我都不敢相信最终的结果是正确的.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span&gt;&lt;strong&gt;但是&lt;/strong&gt;&lt;span class=&quot;md-plain&quot;&gt;这正是贪婪算法的优点, 简单, 容易实施.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;贪婪算法的思想就是(个人理解), 每一步都找到当前状态的最优解, 继续.&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;显然,贪婪算法并不总是能够找到最优解&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;来了, 又来了, 又是一个被用烂了的例子, 但我就是要用, 哼.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span&gt;&lt;strong&gt;问题&lt;/strong&gt;&lt;span class=&quot;md-plain&quot;&gt;: 现在有一个小偷, 带着一个可以装35kg重东西的包包, 他要将最贵重的东西带走, 那么, 贪婪算法思路如下:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;ol-list&quot; start=&quot;&quot; readability=&quot;-2&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;将可装下的最贵的东西装入背包&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;重复步骤1&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;但是, 如果物品如下:&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;ol-list&quot; start=&quot;&quot; readability=&quot;1.5&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;物品A: 价值300, 重量30kg&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;物品B: 价值200, 重量20kg&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;物品C: 价值150, 重量15kg&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;按照上面的思路, 装入的内容为: 物品A, 总价值300&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;但是, 很显然, 如果装入的是: 物品B+物品C, 总价值350&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;这时, 贪婪算法找出的就不是最优解了.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;如果换一种思路呢?&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;ol-list&quot; start=&quot;&quot; readability=&quot;-2&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;将可装下的最轻的东西装入背包&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;重复步骤2&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;你很惊喜的发现, 结果就是我们要的, 但是, 不好意思, 这只是这种情况下的满足.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;如果换一种情况呢? 如果物品A价值是500, 其它条件不变呢?&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;很显然, 在这里, 物品有价值和重量两个值需要考量, 并不能够单单拿出一个来进行判断(之前的教室问题只需要考虑时间), 需要综合考虑.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;其实我个人觉得, 这个例子举得并不恰当, 这种问题本就不适合使用贪婪算法来进行求解. 但是到处都用这个例子, 那我就用吧, 因为我也想不出更好的例子了.......&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;最终的结果虽然不是最优解, 但是也比较接近了. 主要是算法简单啊&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;总结&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;贪婪算法是不是感觉优点动态规划的意思? 没错, 贪婪算法可以说是动态规划的一种特例,也就是说, 所有使用贪婪算法能够解决的问题都可以通过动态规划来解决, 但是反过来并不成立.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;其实, 贪婪算法个人感觉并不能叫做贪婪算法, 应该叫贪婪思想, 嘿嘿. 因为它并不是一个具体的算法, 而是一种解决问题的思路:&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;每一步都寻找当前状态的最有解(局部最优解), 最终得到的就是由所有局部最优解组成的全局最优解, 或接近全局最优解的解&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;有点只顾眼前利益, 不看长远利益的感觉哈. 这种思路听起来, 简单、容易实现, 甚至简单到让人怀疑他的正确性, 你的怀疑是对的, 并不是每次局部最优解的组合就是全局最优解, 但他的优点就是简单啊, 而且对于上面第一个例子中这样的方法就很好的解决了.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;最后, 贪婪算法, 重点在于一个贪字, 哈哈, 请记住贪婪算法的精髓就是&lt;span&gt;&lt;strong&gt;贪&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 29 May 2019 15:49:00 +0000</pubDate>
<dc:creator>牛牛的编程之路</dc:creator>
<og:description>回顾 还记的贪婪算法么? 如果你不记得了, 看了下面这个例子你一定会想起来, 因为这个例子太普遍了, 几乎每个将贪婪算法的地方, 第一个例子都是它, 言归正传. 问题: 现在有如下课程表, 要将这些课</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hujingnb/p/10947152.html</dc:identifier>
</item>
<item>
<title>RN 从上手到“放弃” - adouwt</title>
<link>http://www.cnblogs.com/adouwt/p/10947047.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/adouwt/p/10947047.html</guid>
<description>&lt;h3 id=&quot;rn-从上手到放弃&quot;&gt;RN 从上手到“放弃”&lt;/h3&gt;
&lt;p&gt;前言： react-native，相对于最近🔥的飞起的flutter，不算是一个新技术，2015年Facebook 开源，到现在已经4 5 个年头，一直在维护当中，但是至今未发布 v1 版本，目前已经更新到0.59。 该技术目标： 跨平台实现原生应用。 GitHub start 数目： 77602（2019-5-29）。&lt;/p&gt;
&lt;h2 id=&quot;正文&quot;&gt;正文&lt;/h2&gt;
&lt;h3 id=&quot;项目预览&quot;&gt;1、项目预览&lt;/h3&gt;
&lt;p&gt;现在已完成的功能展示：&lt;/p&gt;
&lt;p&gt;入手demo项目，本打算模仿微信的功能做一遍。现在已经完成微信的一级界面。截图如下：&lt;br/&gt;首页：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1102860/201905/1102860-20190529232657472-2117129083.png&quot;/&gt;通信录：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1102860/201905/1102860-20190529232741994-2110244119.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;发现：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1102860/201905/1102860-20190529232756759-635462233.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1102860/201905/1102860-20190529232813172-132115920.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;朋友圈（上拉加载和下拉刷新）：&lt;br/&gt;（未完成，就是调用了接口）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1102860/201905/1102860-20190529232825579-2127487560.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;聊天界面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1102860/201905/1102860-20190529232839186-1235748673.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;摄像头拍照（安卓虚拟机）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1102860/201905/1102860-20190529232851164-2114112859.png&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;github地址： &lt;a href=&quot;https://github.com/adouwt/react-native-wx&quot;&gt;react-native-wx&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;nodejs后台：&lt;a href=&quot;https://github.com/adouwt/nodejsAPI&quot;&gt;nodejsApi&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;项目主要使用插件（库）：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;react-native-camera （调用摄像头）&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;react-native-vector-icons （图标库）&lt;/li&gt;
&lt;li&gt;react-navigation （路由导航）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;参考资料：&lt;/p&gt;
&lt;h3 id=&quot;项目运行&quot;&gt;2、项目运行&lt;/h3&gt;
&lt;p&gt;～前提： 环境搭建及相关软件、安卓或者ios 的模拟器安装， 参考官网即可，https://reactnative.cn/docs/getting-started.html&lt;/p&gt;
&lt;h4 id=&quot;git-clone-httpsgithub.comadouwtreact-native-wx.git&quot;&gt;git clone https://github.com/adouwt/react-native-wx.git&lt;/h4&gt;
&lt;h4 id=&quot;cd-react-native-wx&quot;&gt;cd react-native-wx&lt;/h4&gt;
&lt;h4 id=&quot;npm-i&quot;&gt;npm i&lt;/h4&gt;
&lt;h4 id=&quot;npm-run-and-安卓&quot;&gt;npm run and (安卓)&lt;/h4&gt;
&lt;h4 id=&quot;npm-run-ios-苹果&quot;&gt;npm run ios (苹果)&lt;/h4&gt;
&lt;p&gt;（上面的运行命令，我在package.json 做了封装，一些处理编译错误的命令，我也已经封装进去）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1102860/201905/1102860-20190529232922373-704575256.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;执行命令后，会自动弹出nodejs 执行终端界面，这个是程序运行的一个监控&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1102860/201905/1102860-20190529233008049-1921778092.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;模拟器显示：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1102860/201905/1102860-20190529233026431-1613598783.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;分步实现&quot;&gt;3、分步实现&lt;/h3&gt;
&lt;h4 id=&quot;初始化并运行项目&quot;&gt;3.1 初始化并运行项目&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;```
react-native init AwesomeProject
react-native run-ios
```&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;项目结构说明&quot;&gt;3.2 项目结构说明&lt;/h4&gt;
&lt;h4 id=&quot;新建文件夹-app接下来所有的源码文件代码将在这里&quot;&gt;3.3 新建文件夹 app，接下来所有的源码文件代码将在这里&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1102860/201905/1102860-20190529233048762-1922811017.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;目前新建 component组件、page页面、及utils 工具三个，后面会根据需要建新的文件夹。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1102860/201905/1102860-20190529233112399-1218645065.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;四个一级界面+ 聊天和朋友圈的界面&lt;/p&gt;
&lt;h4 id=&quot;安装插件做页面导航跳转&quot;&gt;3.4 安装插件做页面导航跳转&lt;/h4&gt;
&lt;h4 id=&quot;npm-install-react-navigation--s&quot;&gt;3.4.1 npm install react-navigation -S&lt;/h4&gt;
&lt;h4 id=&quot;修改项目文件下的app.js&quot;&gt;3.4.2 修改项目文件下的App.js&lt;/h4&gt;
&lt;p&gt;这是根文件，我们的页面导航写进这个组件，我项目中已经完成代码片段，这里直接使用，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import React from 'react';
import HomeScreen  from './app/page/Home'
import DiscoverScreen from './app/page/Discover'
import UserListScreen from './app/page/UserList'
import MyScreen from './app/page/My'
import CameraComponent from './app/component/camera'
import ChatScreen from './app/page/Chat'
import FriendCircle from './app/page/friendCircle'
import Icon from &quot;react-native-vector-icons/Ionicons&quot;;
import { View, Text } from 'react-native';
import { createAppContainer, createBottomTabNavigator, createStackNavigator, createDrawerNavigator } from 'react-navigation'; // Version can be specified in package.json


const HomeNav = createStackNavigator({
  Home: {
    screen: HomeScreen,
    navigationOptions:{
      headerTitle:'微信',
      headerBackTitle:null,
    }
  },
})
const UserListNav = createStackNavigator({
  UserList: {
    screen: UserListScreen,
  },
})

// 二级页面写进一级页面中
const DiscoverNav = createStackNavigator(
  {
    Discover: {
      screen: DiscoverScreen,
    },
  }
)

const MyNav = createStackNavigator(
  {
    My: MyScreen,
  }
);

let BottomNav = createBottomTabNavigator(
  // createBottomTabNavigator 两个参数，一个页面路由，一个是路由配置
  {
    微信: HomeNav,
    通讯录: UserListNav,
    发现: DiscoverNav,
    我: MyNav,
  },
  {
    defaultNavigationOptions: ({ navigation }) =&amp;gt; ({
      tabBarIcon: ({ focused, horizontal, tintColor }) =&amp;gt; {
        const { routeName } = navigation.state;
        let iconName;
        let badgeCount = 3
        switch(routeName) {
          case '微信':
            iconName = 'ios-text';
            break;
          case '通讯录':
            iconName = 'md-person-add';
            break;
          case '发现':
            iconName = 'md-compass';
            break;
          case '我':
            iconName = 'ios-person';
            break;
        }
        iconColor = `${focused ? '#1AAD19' : '#4D4D4D'}`;

        return (
          &amp;lt;View&amp;gt;
            &amp;lt;Icon name={iconName} size={18} color={iconColor}&amp;gt;&amp;lt;/Icon&amp;gt;
            { routeName === '发现' &amp;amp;&amp;amp; badgeCount &amp;gt; 0 &amp;amp;&amp;amp; (
              &amp;lt;View style={{
                // If you're using react-native &amp;lt; 0.57 overflow outside of the parent
                // will not work on Android, see https://git.io/fhLJ8
                position: 'absolute',
                right: -6,
                top: -3,
                backgroundColor: 'red',
                borderRadius: 6,
                width: 12,
                height: 12,
                justifyContent: 'center',
                alignItems: 'center',
                color: '#fff'
              }}&amp;gt;
                &amp;lt;Text style={{ color: '#fff', fontSize: 10, fontWeight: 'bold' }}&amp;gt;{badgeCount}&amp;lt;/Text&amp;gt;
              &amp;lt;/View&amp;gt;
            )}
          &amp;lt;/View&amp;gt;
        )
      },
    }),
    tabBarOptions: {
      activeTintColor: '#1AAD19',
      inactiveTintColor: '#4D4D4D',
    },
  }
);

let RootNav = createStackNavigator({
  BottomNav: {
    screen: BottomNav,
    navigationOptions: ({ navigation, screenProps }) =&amp;gt; {
      return {
        header: null,
      };
    }
  },
  Camera: {
    screen: CameraComponent
  },
  Chat: {
    screen: ChatScreen
  },
  FriendCircle: {
    screen: FriendCircle
  }
})

export default createAppContainer(RootNav);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里需要参考导航资料：&lt;a href=&quot;https://reactnavigation.org/docs/en/tab-based-navigation.html&quot;&gt;navigation&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文档讲的很明白，看看示例就知道怎么用了，我下面讲两个注意内容，这也是在这几天的学习中遇到的troubles.&lt;/p&gt;
&lt;h4 id=&quot;a创建底部导航&quot;&gt;a、创建底部导航：&lt;/h4&gt;
&lt;p&gt;createBottomTabNavigator 方法，接受两个参数，一个页面路由，一个是路由配置，&lt;br/&gt;直接看这个方法名字，就知道这个是创建底部导航的方法。&lt;br/&gt;--第一个参数，页面路由，这里你写多少tab, 底部就会呈现几个tab 均匀分布，（不要有杠精来袭，“要是有100个tab,怎么显示？”，哪有这样的设计，你要是有100个tab，你试试这样排版？）&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1102860/201905/1102860-20190529233150680-271214341.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;参数的key,就是底部显示的名称，value 就是这个页面 screen。页面screen可以单独定义引入，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1102860/201905/1102860-20190529233200363-1658898248.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以像第一个DiscoverNav，以screen定义的方式引入，也可以简略使用，如下面的MyNav&lt;/p&gt;
&lt;p&gt;-- 第二个参数，路由配置，在这里配置，底部导航的样式、图标、foucs 状态及badge等&lt;br/&gt;tabBarIcon 顾名思义，配置他的图标，我这里根据navigation.state 里的routeName 来区分页面路由，从而为他们配置不同的 icon&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1102860/201905/1102860-20190529233216751-787806361.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;b二级页面注入stack-navigator&quot;&gt;b、二级页面注入Stack Navigator&lt;/h4&gt;
&lt;p&gt;我们写的页面要注入我们的导航，这样才能访问到，我们这里采用的是react-navigation的 createStackNavigaor 的createStackNavigator方法，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1102860/201905/1102860-20190529233232689-1630378810.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;具体页面逻辑&quot;&gt;3.4.3 具体页面逻辑&lt;/h4&gt;
&lt;p&gt;这里讲两个页面，一个是静态页面，一个是调用接口的长列表的界面。&lt;/p&gt;
&lt;h5 id=&quot;静态页面-discoverscreen&quot;&gt;静态页面 discoverScreen&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;布局方式&lt;/strong&gt;： flex， 属性和web 书写不一致，语法参考这个不完全手册： https://shenbao.github.io/ishehui/html/RN%20%E5%9F%BA%E7%A1%80/React%20Native%20%E6%A0%B7%E5%BC%8F%E8%A1%A8%E6%8C%87%E5%8D%97.html&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;点击按钮封装：&lt;/strong&gt; RN 里面的点击方法只能绑定在它的button 组件上，提供的其他组件我们么办法直接绑定事件，它提供了一个封装子组件可以绑定事件的自定义按钮-Touchable 系列 （TouchableOpacity ，TouchableNativeFeedback）如下书写可以点击的item：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1102860/201905/1102860-20190529233249025-558876019.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 上面划线的位置，这个样式（flex: 1, flexDirection: 'row',）要写上。有一定的兼容问题，如果没有这个样式，在安卓上无法点击，ios上没有影响。说明在实际开发中，我们还要处理一定的平台差异问题，真正实现无差异的跨平台还是有些困难。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;页面header：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在static 里面没办法直接调用组件的方法，需要借助 navigation 来做一下中转，调用setParams将方法放进navigation里面，这样在static里面就可以使用navigation.getParams 获取这个方法了，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1102860/201905/1102860-20190529233454908-1379632168.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;过渡动画&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个方法实现的是一个 动画，我们在 写web 的时候，会用 transform transaction 这样的动画属性，RN里面也支持这样的动画，具体语法有所差异。这里我们用一个绝对定位里面的 right值 做过渡效果。&lt;br/&gt;开始定义：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1102860/201905/1102860-20190529234312904-425708425.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在点击时候，修改这个 this.state.animateRightValue 的值，实现动画效果，&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1102860/201905/1102860-20190529233553984-1457881206.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Animated有几个动画（），这里采用了timing,他接受两个参数，一个是监听的动画值，另一个是这个值的配置，配置动画方式，动画时间等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1102860/201905/1102860-20190529233617466-131025360.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个页面也没有复杂的页面逻辑，基本一看就知道怎么回事，一些语法 api 不会的话，可以上官网lou 一眼：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1102860/201905/1102860-20190529234556665-1204937439.png&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;调接口的页面-friendcircle&quot;&gt;调接口的页面 friendCircle&lt;/h5&gt;
&lt;p&gt;这个页面调用了一个分页接口，上拉加载更多，长列表的组件用的是RN 原生的 FlatList 组件，这个具体使用可以参考api 文档看看，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1102860/201905/1102860-20190529234637984-830967980.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是就个人使用之后的感觉而言，这个真正要用到生产，还得要稍微改造一下，比如loading菊花图片要改一改。&lt;br/&gt;在生命周期函数componentDidMount 里面，调用我们的接口。说道这里，我们引出了接口封装问题，用的是自带的fetch，这个fetch 底层具体我们就不考虑怎么实现的，现在我们需要对fetch 封装一下，方便后面在多处使用，fetch 封装如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let base_url = 'https://api.scampus.cn';  //服务器基本地址
// let base_url = 'http://18.10.1.115:4000';  //服务器基本地址
let token = '';   
/**
 * @param {string} url 接口地址
 * @param {string} method 请求方法：GET、POST，只能大写
 * @param {JSON} [params=''] body的请求参数，默认为空
 * @return 返回Promise
 */
const  fetchRequest = (url, method, params = '') =&amp;gt; {
    let header = {
        &quot;Content-Type&quot;: &quot;application/json;charset=UTF-8&quot;,
        &quot;accesstoken&quot;:token  //用户登陆后返回的token，某些涉及用户数据的接口需要在header中加上token
    };
    if(params == ''){   //如果网络请求中带有参数
        return new Promise(function (resolve, reject) {
            fetch(base_url + url, {
                method: method,
                headers: header
            }).then((response) =&amp;gt; response.json())
                .then((responseData) =&amp;gt; {
                    resolve(responseData);
                })
                .catch( (err) =&amp;gt; {
                    reject(err);
                });
        });
    } else{   //如果网络请求中没有参数
        return new Promise(function (resolve, reject) {
            fetch(base_url + url, {
                method: method,
                headers: header,
                body:JSON.stringify(params)   //body参数，通常需要转换成字符串后服务器才能解析
            }).then((response) =&amp;gt; response.json())
                .then((responseData) =&amp;gt; {
                    resolve(responseData);
                })
                .catch( (err) =&amp;gt; {
                    reject(err);
                });
        });
    }
}

export default fetchRequest
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用Promise 处理异步问题，将我们最后的需要的数据统统resolve 出去。封装中规中距，基本是按照文档说明 fetch 的用法，稍加修改&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1102860/201905/1102860-20190529234746290-412023186.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;使用第三方的图标&quot;&gt;4、使用第三方的图标&lt;/h3&gt;
&lt;p&gt;npm install -S react-native-vector-icons&lt;br/&gt;图标地址: https://oblador.github.io/react-native-vector-icons/ 注意这站点不是图标全部可用，滚动条快速找到中间位置，就能看到我们需要的图标。&lt;br/&gt;使用： name 值可以在上面的地址中寻找，哪个合适就用哪个，&lt;br/&gt;就个人看来，这个图标库基本够开发使用，如果不够可以继续引用字体图标库。&lt;/p&gt;
&lt;h3 id=&quot;调用手机硬件设备-摄像头&quot;&gt;5、调用手机硬件设备-摄像头&lt;/h3&gt;
&lt;p&gt;具体演示实例，拍照功能，用的第三方库，&lt;a href=&quot;https://github.com/react-native-community/react-native-camera/blob/master/docs/RNCamera.md&quot;&gt;react-native-camera&lt;/a&gt;&lt;br/&gt;安装： npm install -S react-native-camera&lt;br/&gt;使用：import { RNCamera } from 'react-native-camera';&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;View style={styles.container}&amp;gt;
    &amp;lt;RNCamera
        ref={ref =&amp;gt; {
            this.camera = ref;
        }}
        style={styles.preview}
        type={ this.state.cameraType}
        flashMode={RNCamera.Constants.FlashMode.on}
        autoFocus={RNCamera.Constants.AutoFocus.on}
        androidCameraPermissionOptions={{
            title: 'Permission to use camera',
            message: 'We need your permission to use your camera',
            buttonPositive: 'Ok',
            buttonNegative: 'Cancel',
        }}
        androidRecordAudioPermissionOptions={{
            title: 'Permission to use audio recording',
            message: 'We need your permission to use your audio',
            buttonPositive: 'Ok',
            buttonNegative: 'Cancel',
        }}
        onGoogleVisionBarcodesDetected={({ barcodes }) =&amp;gt; {
            console.log(barcodes);
        }}
    &amp;gt;
        {({ camera, status, recordAudioPermissionStatus }) =&amp;gt; {
            if (status !== 'READY') return &amp;lt;PendingView /&amp;gt;;
            return (
            &amp;lt;View style={{ flex: 1, flexDirection: 'row', justifyContent: 'space-around',marginBottom: 20 }}&amp;gt;
                &amp;lt;TouchableOpacity onPress={() =&amp;gt; this.takePicture(camera)} style={styles.capture}&amp;gt;
                    &amp;lt;Text style={{ fontSize: 14 }}&amp;gt; 拍照 &amp;lt;/Text&amp;gt;
                &amp;lt;/TouchableOpacity&amp;gt;
                &amp;lt;TouchableOpacity onPress={this.swtichCamera} style={styles.capture}&amp;gt;
                    &amp;lt;Icon name=&quot;ios-reverse-camera&quot; size={18} color=&quot;#333&quot;&amp;gt;&amp;lt;/Icon&amp;gt;
                &amp;lt;/TouchableOpacity&amp;gt;

                &amp;lt;TouchableOpacity onPress={this.lookAlbum} style={styles.imgPreview}&amp;gt;
                        &amp;lt;Image
                            style={styles.imgPreview}
                            source={{uri: this.state.currentUri || 'https://yyb.gtimg.com/aiplat/page/product/visionimgidy/img/demo6-16a47e5d31.jpg?', isStatic: true}}
                        /&amp;gt;
                    &amp;lt;/TouchableOpacity&amp;gt;
                    
                &amp;lt;/View&amp;gt;
                );
            }}
        &amp;lt;/RNCamera&amp;gt;
    &amp;lt;/View&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在组件里面可以定义照相机界面的ui，可以自定义拍照按钮，切换摄像头的按钮，拍照图片预览等，调用api 不难，问题难点在配置调用的文件，你得有权限调用原生的设备。&lt;br/&gt;1、修改android/gradle/wrapper/gradle-wrapper.properties&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    distributionUrl=https\://services.gradle.org/distributions/gradle-4.10.1-all.zip  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、修改android/app/build.gradle&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;missingDimensionStrategy 'react-native-camera', 'general'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1102860/201905/1102860-20190529235007203-2052221341.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在实际安装使用的时候会有相关的提示报错，按照报错信息去寻找解决办法，这里还是得推荐github，上面有很多类似的问题，可以耐心找找。&lt;/p&gt;
&lt;h3 id=&quot;结言&quot;&gt;6、结言&lt;/h3&gt;
&lt;p&gt;从一开始了解RN 到最后上手demo，到现在陆续修改项目，差不多十天时间，本人的技术栈是vue,react 并没有生产项目，看看文档，基本可以上手。总结而言，使用一些基本的功能，并不难，文档很全，使用的群体很大，所以遇到的问题也可以在相关社区找到合适的解决方法或者替换方案。还没有具体开发生产项目，但是我觉得我将要面临的问题，应该在体验优化上，比如过渡动画，上拉下拉刷新加载，切换视图；集成第三方库，调用硬件设备；性能优化问题等。&lt;/p&gt;
&lt;h3 id=&quot;todo&quot;&gt;7、TODO&lt;/h3&gt;
&lt;p&gt;后面有时间，继续把这个项目做下去，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;登录注册&lt;/li&gt;
&lt;li&gt;聊天，后面集成聊天机器人&lt;/li&gt;
&lt;li&gt;通讯录的人员分组，现在因为是后台接口还没有完成，只是本地造了一个数据&lt;/li&gt;
&lt;li&gt;扫码功能&lt;/li&gt;
&lt;li&gt;发动态&lt;/li&gt;
&lt;li&gt;集成地图&lt;/li&gt;
&lt;li&gt;拍照后，图像识别&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果有兴趣的同学欢迎加入一起完成。&lt;/p&gt;
&lt;p&gt;github地址： &lt;a href=&quot;https://github.com/adouwt/react-native-wx&quot;&gt;react-native-wx&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;nodejs后台：&lt;a href=&quot;https://github.com/adouwt/nodejsAPI&quot;&gt;nodejsApi&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;班门弄斧之作，若有RN 老手见到，请勿见笑，有不对不合理之处，敬请指教！我是迩伶贰！&lt;/p&gt;
&lt;h3 id=&quot;相关错误处理&quot;&gt;-1、相关错误处理&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;react-native-camera 插件的使用问题：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1102860/201905/1102860-20190529235207534-2103149828.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;解决： [解决](https://github.com/react-native-community/react-native-camera/issues/2150)&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;编译问题&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1102860/201905/1102860-20190529233845078-910593008.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    解决： cd android   &amp;amp;&amp;amp;  ./gradlew clean&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;开发中还遇到了其他问题，但是忘了做记录 ~~ RN 暂时放一段落，接下来要使用 flutter，打算两周后 出一个flutter版本。&lt;/p&gt;
</description>
<pubDate>Wed, 29 May 2019 15:39:00 +0000</pubDate>
<dc:creator>adouwt</dc:creator>
<og:description>RN 从上手到“放弃” 前言： react native，相对于最近🔥的飞起的flutter，不算是一个新技术，2015年Facebook 开源，到现在已经4 5 个年头，一直在维护当中，但是至今未</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/adouwt/p/10947047.html</dc:identifier>
</item>
<item>
<title>Spring AOP——Spring 中面向切面编程 - SharpCJ</title>
<link>http://www.cnblogs.com/joy99/p/10941543.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/joy99/p/10941543.html</guid>
<description>&lt;p&gt;前面两篇文章记录了 Spring IOC 的相关知识，本文记录 Spring 中的另一特性 AOP 相关知识。&lt;/p&gt;
&lt;blockquote readability=&quot;3.75&quot;&gt;
&lt;p&gt;部分参考资料：&lt;br/&gt;《Spring实战（第4版）》&lt;br/&gt;《轻量级 JavaEE 企业应用实战（第四版）》&lt;br/&gt;&lt;a href=&quot;https://docs.spring.io/spring/docs/5.0.6.RELEASE/spring-framework-reference/core.html#spring-core&quot;&gt;Spring 官方文档&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.w3cschool.cn/wkspring/&quot;&gt;W3CSchool Spring教程&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.yiibai.com/spring/&quot;&gt;易百教程 Spring教程&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;什么是-aop&quot;&gt;1.1 什么是 AOP&lt;/h2&gt;
&lt;p&gt;AOP （Aspect Orient Programming）,直译过来就是 面向切面编程。AOP 是一种编程思想，是面向对象编程（OOP）的一种补充。面向对象编程将程序抽象成各个层次的对象，而面向切面编程是将程序抽象成各个切面。&lt;br/&gt;从《Spring实战（第4版）》图书中扒了一张图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/758949/201905/758949-20190529225344641-152289598.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从该图可以很形象地看出，所谓切面，相当于应用对象间的横切点，我们可以将其单独抽象为单独的模块。&lt;/p&gt;
&lt;h2 id=&quot;为什么需要-aop&quot;&gt;1.2 为什么需要 AOP&lt;/h2&gt;
&lt;p&gt;想象下面的场景，开发中在多个模块间有某段重复的代码，我们通常是怎么处理的？显然，没有人会靠“复制粘贴”吧。在传统的面向过程编程中，我们也会将这段代码，抽象成一个方法，然后在需要的地方分别调用这个方法，这样当这段代码需要修改时，我们只需要改变这个方法就可以了。然而需求总是变化的，有一天，新增了一个需求，需要再多出做修改，我们需要再抽象出一个方法，然后再在需要的地方分别调用这个方法，又或者我们不需要这个方法了，我们还是得删除掉每一处调用该方法的地方。实际上涉及到多个地方具有相同的修改的问题我们都可以通过 AOP 来解决。&lt;/p&gt;
&lt;h2 id=&quot;aop-实现分类&quot;&gt;1.3 AOP 实现分类&lt;/h2&gt;
&lt;p&gt;AOP 要达到的效果是，保证开发者不修改源代码的前提下，去为系统中的业务组件添加某种通用功能。AOP 的本质是由 AOP 框架修改业务组件的多个方法的源代码，看到这其实应该明白了，AOP 其实就是前面一篇文章讲的代理模式的典型应用。&lt;br/&gt;按照 AOP 框架修改源代码的时机，可以将其分为两类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;静态 AOP 实现， AOP 框架在编译阶段对程序源代码进行修改，生成了静态的 AOP 代理类（生成的 *.class 文件已经被改掉了，需要使用特定的编译器），比如 AspectJ。&lt;/li&gt;
&lt;li&gt;动态 AOP 实现， AOP 框架在运行阶段对动态生成代理对象（在内存中以 JDK 动态代理，或 CGlib 动态地生成 AOP 代理类），如 SpringAOP。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面给出常用 AOP 实现比较&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/758949/201905/758949-20190529225400887-1590896890.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如不清楚动态代理的，可参考我前面的一篇文章，有讲解静态代理、JDK动态代理和 CGlib 动态代理。&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/joy99/p/10865391.html&quot;&gt;静态代理和动态代理 https://www.cnblogs.com/joy99/p/10865391.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;AOP 领域中的特性术语：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通知（Advice）: AOP 框架中的增强处理。通知描述了切面何时执行以及如何执行增强处理。&lt;/li&gt;
&lt;li&gt;连接点（join point）: 连接点表示应用执行过程中能够插入切面的一个点，这个点可以是方法的调用、异常的抛出。在 Spring AOP 中，连接点总是方法的调用。&lt;/li&gt;
&lt;li&gt;切点（PointCut）: 可以插入增强处理的连接点。&lt;/li&gt;
&lt;li&gt;切面（Aspect）: 切面是通知和切点的结合。&lt;/li&gt;
&lt;li&gt;引入（Introduction）：引入允许我们向现有的类添加新的方法或者属性。&lt;/li&gt;
&lt;li&gt;织入（Weaving）: 将增强处理添加到目标对象中，并创建一个被增强的对象，这个过程就是织入。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;概念看起来总是有点懵，并且上述术语，不同的参考书籍上翻译还不一样，所以需要慢慢在应用中理解。&lt;/p&gt;

&lt;h2 id=&quot;spring-aop-的特点&quot;&gt;3.1 Spring AOP 的特点&lt;/h2&gt;
&lt;p&gt;AOP 框架有很多种，1.3节中介绍了 AOP 框架的实现方式有可能不同， Spring 中的 AOP 是通过动态代理实现的。不同的 AOP 框架支持的连接点也有所区别，例如，AspectJ 和 JBoss,除了支持方法切点，它们还支持字段和构造器的连接点。而 Spring AOP 不能拦截对对象字段的修改，也不支持构造器连接点,我们无法在 Bean 创建时应用通知。&lt;/p&gt;
&lt;h2 id=&quot;spring-aop-的简单例子&quot;&gt;3.2 Spring AOP 的简单例子&lt;/h2&gt;
&lt;p&gt;下面先上代码，对着代码说比较好说，看下面这个例子：&lt;br/&gt;这个例子是基于gradle创建的，首先 build.gradle 文件添加依赖：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dependencies {
    compile 'org.springframework:spring-context:5.0.6.RELEASE'
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先创建一个接口 IBuy.java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj.aopdemo.test1;

public interface IBuy {
    String buy();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Boy 和 Gril 两个类分别实现了这个接口：&lt;br/&gt;Boy.java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj.aopdemo.test1;

import org.springframework.stereotype.Component;

@Component
public class Boy implements IBuy {
    @Override
    public String buy() {
        System.out.println(&quot;男孩买了一个游戏机&quot;);
        return &quot;游戏机&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Girl.java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj.aopdemo.test1;

import org.springframework.stereotype.Component;

@Component
public class Girl implements IBuy {
    @Override
    public String buy() {
        System.out.println(&quot;女孩买了一件漂亮的衣服&quot;);
        return &quot;衣服&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置文件, AppConfig.java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj.aopdemo;

import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;

@Configuration
@ComponentScan(basePackageClasses = {com.sharpcj.aopdemo.test1.IBuy.class})
public class AppConfig {
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试类， AppTest.java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj.aopdemo;

import com.sharpcj.aopdemo.test1.Boy;
import com.sharpcj.aopdemo.test1.Girl;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

public class AppTest {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        Boy boy = context.getBean(&quot;boy&quot;,Boy.class);
        Girl girl = (Girl) context.getBean(&quot;girl&quot;);
        boy.buy();
        girl.buy();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/758949/201905/758949-20190529225425832-1733905596.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里运用SpringIOC里的自动部署。现在需求改变了，我们需要在男孩和女孩的 buy 方法之前，需要打印出“男孩女孩都买了自己喜欢的东西”。用 Spring AOP 来实现这个需求只需下面几个步骤：&lt;br/&gt;1、 &lt;strong&gt;既然用到 Spring AOP, 首先在 &lt;code&gt;build.gralde&lt;/code&gt; 文件中引入相关依赖：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dependencies {
    compile 'org.springframework:spring-context:5.0.6.RELEASE'
    compile 'org.springframework:spring-aspects:5.0.6.RELEASE'
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、 &lt;strong&gt;定义一个切面类，BuyAspectJ.java&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj.aopdemo.test1;

import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.springframework.stereotype.Component;

@Aspect
@Component
public class BuyAspectJ {
    @Before(&quot;execution(* com.sharpcj.aopdemo.test1.IBuy.buy(..))&quot;)
    public void haha(){
        System.out.println(&quot;男孩女孩都买自己喜欢的东西&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个类，我们使用了注解 &lt;code&gt;@Component&lt;/code&gt; 表明它将作为一个Spring Bean 被装配，使用注解 &lt;code&gt;@Aspect&lt;/code&gt; 表示它是一个切面。&lt;br/&gt;类中只有一个方法 &lt;code&gt;haha&lt;/code&gt; 我们使用 &lt;code&gt;@Before&lt;/code&gt; 这个注解，表示他将在方法执行之前执行。关于这个注解后文再作解释。&lt;br/&gt;参数&lt;code&gt;(&quot;execution(* com.sharpcj.aopdemo.test1.IBuy.buy(..))&quot;)&lt;/code&gt; 声明了切点，表明在该切面的切点是&lt;code&gt;com.sharpcj.aopdemo.test1.Ibuy&lt;/code&gt;这个接口中的&lt;code&gt;buy&lt;/code&gt;方法。至于为什么这么写，下文再解释。&lt;br/&gt;3、 &lt;strong&gt;在配置文件中启用AOP切面功能&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj.aopdemo;

import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.EnableAspectJAutoProxy;

@Configuration
@ComponentScan(basePackageClasses = {com.sharpcj.aopdemo.test1.IBuy.class})
@EnableAspectJAutoProxy(proxyTargetClass = true)
public class AppConfig {
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们在配置文件类增加了&lt;code&gt;@EnableAspectJAutoProxy&lt;/code&gt;注解，启用了 AOP 功能，参数&lt;code&gt;proxyTargetClass&lt;/code&gt;的值设为了 true 。默认值是 false，两者的区别下文再解释。&lt;br/&gt;OK，下面只需测试代码,运行结果如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/758949/201905/758949-20190529225446321-1741506938.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们看到，结果与我们需求一致，我们并没有修改 Boy 和 Girl 类的 Buy 方法，也没有修改测试类的代码，几乎是完全无侵入式地实现了需求。这就是 AOP 的“神奇”之处。&lt;/p&gt;

&lt;h2 id=&quot;通过注解声明切点指示器&quot;&gt;4.1 通过注解声明切点指示器&lt;/h2&gt;
&lt;p&gt;Spring AOP 所支持的 AspectJ 切点指示器&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/758949/201905/758949-20190529225507103-314276426.png&quot;/&gt;&lt;br/&gt;在spring中尝试使用AspectJ其他指示器时，将会抛出IllegalArgumentException异常。&lt;/p&gt;
&lt;p&gt;当我们查看上面展示的这些spring支持的指示器时，注意只有execution指示器是唯一的执行匹配，而其他的指示器都是用于限制匹配的。这说明execution指示器是我们在编写切点定义时最主要使用的指示器，在此基础上，我们使用其他指示器来限制所匹配的切点。&lt;/p&gt;
&lt;p&gt;下图的切点表达式表示当Instrument的play方法执行时会触发通知。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/758949/201905/758949-20190529225530124-1714809272.png&quot;/&gt;&lt;br/&gt;我们使用execution指示器选择Instrument的play方法，方法表达式以 &lt;code&gt;*&lt;/code&gt; 号开始，标识我们不关心方法的返回值类型。然后我们指定了全限定类名和方法名。对于方法参数列表，我们使用 &lt;code&gt;..&lt;/code&gt; 标识切点选择任意的play方法，无论该方法的入参是什么。&lt;br/&gt;多个匹配之间我们可以使用链接符 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;、&lt;code&gt;||&lt;/code&gt;、&lt;code&gt;！&lt;/code&gt;来表示 “且”、“或”、“非”的关系。但是在使用 XML 文件配置时，这些符号有特殊的含义，所以我们使用 “and”、“or”、“not”来表示。&lt;/p&gt;
&lt;p&gt;举例：&lt;br/&gt;限定该切点仅匹配的包是 &lt;code&gt;com.sharpcj.aopdemo.test1&lt;/code&gt;,可以使用&lt;br/&gt;&lt;code&gt;execution(* com.sharpcj.aopdemo.test1.IBuy.buy(..)) &amp;amp;&amp;amp; within(com.sharpcj.aopdemo.test1.*)&lt;/code&gt;&lt;br/&gt;在切点中选择 bean,可以使用&lt;br/&gt;&lt;code&gt;execution(* com.sharpcj.aopdemo.test1.IBuy.buy(..)) &amp;amp;&amp;amp; bean(girl)&lt;/code&gt;&lt;br/&gt;修改 BuyAspectJ.java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj.aopdemo.test1;

import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.springframework.stereotype.Component;

@Aspect
@Component
public class BuyAspectJ {
    @Before(&quot;execution(* com.sharpcj.aopdemo.test1.IBuy.buy(..)) &amp;amp;&amp;amp; within(com.sharpcj.aopdemo.test1.*) &amp;amp;&amp;amp; bean(girl)&quot;)
    public void hehe(){
        System.out.println(&quot;男孩女孩都买自己喜欢的东西&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时，切面只会对 &lt;code&gt;Girl.java&lt;/code&gt; 这个类生效，执行结果：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/758949/201905/758949-20190529225548745-1785519580.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;细心的你，可能发现了，切面中的方法名，已经被我悄悄地从&lt;code&gt;haha&lt;/code&gt;改成了&lt;code&gt;hehe&lt;/code&gt;，丝毫没有影响结果，说明方法名没有影响。和 Spring IOC 中用 java 配置文件装配 Bean 时，用&lt;code&gt;@Bean&lt;/code&gt; 注解修饰的方法名一样，没有影响。&lt;/p&gt;
&lt;h2 id=&quot;通过注解声明-5-种通知类型&quot;&gt;4.2 通过注解声明 5 种通知类型&lt;/h2&gt;
&lt;p&gt;Spring AOP 中有 5 中通知类型，分别如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/758949/201905/758949-20190529225613898-1522094074.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面修改切面类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj.aopdemo.test1;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.*;
import org.springframework.stereotype.Component;

@Aspect
@Component
public class BuyAspectJ {
    @Before(&quot;execution(* com.sharpcj.aopdemo.test1.IBuy.buy(..))&quot;)
    public void hehe() {
        System.out.println(&quot;before ...&quot;);
    }

    @After(&quot;execution(* com.sharpcj.aopdemo.test1.IBuy.buy(..))&quot;)
    public void haha() {
        System.out.println(&quot;After ...&quot;);
    }

    @AfterReturning(&quot;execution(* com.sharpcj.aopdemo.test1.IBuy.buy(..))&quot;)
    public void xixi() {
        System.out.println(&quot;AfterReturning ...&quot;);
    }

    @Around(&quot;execution(* com.sharpcj.aopdemo.test1.IBuy.buy(..))&quot;)
    public void xxx(ProceedingJoinPoint pj) {
        try {
            System.out.println(&quot;Around aaa ...&quot;);
            pj.proceed();
            System.out.println(&quot;Around bbb ...&quot;);
        } catch (Throwable throwable) {
            throwable.printStackTrace();
        }
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了方便看效果,我们测试类中，只要 Boy 类:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj.aopdemo;

import com.sharpcj.aopdemo.test1.Boy;
import com.sharpcj.aopdemo.test1.Girl;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

public class AppTest {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        Boy boy = context.getBean(&quot;boy&quot;,Boy.class);
        Girl girl = (Girl) context.getBean(&quot;girl&quot;);
        boy.buy();
        // girl.buy();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/758949/201905/758949-20190529225633682-474468038.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;结果显而易见。指的注意的是 &lt;code&gt;@Around&lt;/code&gt; 修饰的环绕通知类型，是将整个目标方法封装起来了，在使用时，我们传入了 &lt;code&gt;ProceedingJoinPoint&lt;/code&gt; 类型的参数，这个对象是必须要有的，并且需要调用 &lt;code&gt;ProceedingJoinPoint&lt;/code&gt; 的 &lt;code&gt;proceed()&lt;/code&gt; 方法。 如果没有调用 该方法，执行结果为 ：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Around aaa ...
Around bbb ...
After ...
AfterReturning ...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可见，如果不调用该对象的 proceed() 方法，表示原目标方法被阻塞调用，当然也有可能你的实际需求就是这样。&lt;/p&gt;
&lt;h2 id=&quot;通过注解声明切点表达式&quot;&gt;4.3 通过注解声明切点表达式&lt;/h2&gt;
&lt;p&gt;如你看到的，上面我们写的多个通知使用了相同的切点表达式，对于像这样频繁出现的相同的表达式，我们可以使用 &lt;code&gt;@Pointcut&lt;/code&gt;注解声明切点表达式，然后使用表达式，修改代码如下：&lt;br/&gt;BuyAspectJ.java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj.aopdemo.test1;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.*;
import org.springframework.stereotype.Component;

@Aspect
@Component
public class BuyAspectJ {

    @Pointcut(&quot;execution(* com.sharpcj.aopdemo.test1.IBuy.buy(..))&quot;)
    public void point(){}

    @Before(&quot;point()&quot;)
    public void hehe() {
        System.out.println(&quot;before ...&quot;);
    }

    @After(&quot;point()&quot;)
    public void haha() {
        System.out.println(&quot;After ...&quot;);
    }

    @AfterReturning(&quot;point()&quot;)
    public void xixi() {
        System.out.println(&quot;AfterReturning ...&quot;);
    }

    @Around(&quot;point()&quot;)
    public void xxx(ProceedingJoinPoint pj) {
        try {
            System.out.println(&quot;Around aaa ...&quot;);
            pj.proceed();
            System.out.println(&quot;Around bbb ...&quot;);
        } catch (Throwable throwable) {
            throwable.printStackTrace();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;程序运行结果没有变化。&lt;br/&gt;这里，我们使用&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Pointcut(&quot;execution(* com.sharpcj.aopdemo.test1.IBuy.buy(..))&quot;)
public void point(){}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;声明了一个切点表达式，该方法 point 的内容并不重要，方法名也不重要，实际上它只是作为一个标识，供通知使用。&lt;/p&gt;
&lt;h2 id=&quot;通过注解处理通知中的参数&quot;&gt;4.4 通过注解处理通知中的参数&lt;/h2&gt;
&lt;p&gt;上面的例子，我们要进行增强处理的目标方法没有参数，下面我们来说说有参数的情况，并且在增强处理中使用该参数。&lt;br/&gt;下面我们给接口增加一个参数，表示购买所花的金钱。通过AOP 增强处理，如果女孩买衣服超过了 68 元，就可以赠送一双袜子。&lt;br/&gt;更改代码如下：&lt;br/&gt;IBuy.java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj.aopdemo.test1;

public interface IBuy {
    String buy(double price);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Girl.java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj.aopdemo.test1;

import org.springframework.stereotype.Component;

@Component
public class Girl implements IBuy {
    @Override
    public String buy(double price) {
        System.out.println(String.format(&quot;女孩花了%s元买了一件漂亮的衣服&quot;, price));
        return &quot;衣服&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Boy.java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj.aopdemo.test1;

import org.springframework.stereotype.Component;

@Component
public class Boy implements IBuy {
    @Override
    public String buy(double price) {
        System.out.println(String.format(&quot;男孩花了%s元买了一个游戏机&quot;, price));
        return &quot;游戏机&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再看 BuyAspectJ 类，我们将之前的通知都注释掉。用一个环绕通知来实现这个功能：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj.aopdemo.test1;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.*;
import org.springframework.stereotype.Component;

@Aspect
@Component
public class BuyAspectJ {

    /*
    @Pointcut(&quot;execution(* com.sharpcj.aopdemo.test1.IBuy.buy(..))&quot;)
    public void point(){}

    @Before(&quot;point()&quot;)
    public void hehe() {
        System.out.println(&quot;before ...&quot;);
    }

    @After(&quot;point()&quot;)
    public void haha() {
        System.out.println(&quot;After ...&quot;);
    }

    @AfterReturning(&quot;point()&quot;)
    public void xixi() {
        System.out.println(&quot;AfterReturning ...&quot;);
    }

    @Around(&quot;point()&quot;)
    public void xxx(ProceedingJoinPoint pj) {
        try {
            System.out.println(&quot;Around aaa ...&quot;);
            pj.proceed();
            System.out.println(&quot;Around bbb ...&quot;);
        } catch (Throwable throwable) {
            throwable.printStackTrace();
        }
    }
    */


    @Pointcut(&quot;execution(String com.sharpcj.aopdemo.test1.IBuy.buy(double)) &amp;amp;&amp;amp; args(price) &amp;amp;&amp;amp; bean(girl)&quot;)
    public void gif(double price) {
    }

    @Around(&quot;gif(price)&quot;)
    public String hehe(ProceedingJoinPoint pj, double price){
        try {
            pj.proceed();
            if (price &amp;gt; 68) {
                System.out.println(&quot;女孩买衣服超过了68元，赠送一双袜子&quot;);
                return &quot;衣服和袜子&quot;;
            }
        } catch (Throwable throwable) {
            throwable.printStackTrace();
        }
        return &quot;衣服&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;前文提到，当不关心方法返回值的时候，我们在编写切点指示器的时候使用了 &lt;code&gt;*&lt;/code&gt; ， 当不关心方法参数的时候，我们使用了 &lt;code&gt;..&lt;/code&gt;。现在如果我们需要传入参数，并且有返回值的时候，则需要使用对应的类型。在编写通知的时候，我们也需要声明对应的返回值类型和参数类型。&lt;/p&gt;
&lt;p&gt;测试类：AppTest.java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj.aopdemo;

import com.sharpcj.aopdemo.test1.Boy;
import com.sharpcj.aopdemo.test1.Girl;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

public class AppTest {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        Boy boy = context.getBean(&quot;boy&quot;,Boy.class);
        Girl girl = (Girl) context.getBean(&quot;girl&quot;);
        String boyBought = boy.buy(35);
        String girlBought = girl.buy(99.8);

        System.out.println(&quot;男孩买到了：&quot; + boyBought);
        System.out.println(&quot;女孩买到了：&quot; + girlBought);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试结果：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/758949/201905/758949-20190529225709155-1683416178.png&quot;/&gt;&lt;br/&gt;可以看到，我们成功通过 AOP 实现了需求，并将结果打印了出来。&lt;/p&gt;
&lt;h2 id=&quot;通过注解配置织入的方式&quot;&gt;4.5 通过注解配置织入的方式&lt;/h2&gt;
&lt;p&gt;前面还有一个遗留问题，在配置文件中，我们用注解 &lt;code&gt;@EnableAspectJAutoProxy()&lt;/code&gt; 启用Spring AOP 的时候，我们给参数 &lt;code&gt;proxyTargetClass&lt;/code&gt; 赋值为 &lt;code&gt;true&lt;/code&gt;,如果我们不写参数，默认为 false。这个时候运行程序，程序抛出异常&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/758949/201905/758949-20190529225724860-1448694025.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是一个强制类型转换异常。为什么会抛出这个异常呢？或许已经能够想到，这跟Spring AOP 动态代理的机制有关，这个 &lt;code&gt;proxyTargetClass&lt;/code&gt; 参数决定了代理的机制。当这个参数为 false 时，&lt;br/&gt;通过jdk的基于接口的方式进行织入，这时候代理生成的是一个接口对象，将这个接口对象强制转换为实现该接口的一个类，自然就抛出了上述类型转换异常。&lt;br/&gt;反之，&lt;code&gt;proxyTargetClass&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt;，则会使用 cglib 的动态代理方式。这种方式的缺点是拓展类的方法被&lt;code&gt;final&lt;/code&gt;修饰时，无法进行织入。&lt;br/&gt;测试一下，我们将 &lt;code&gt;proxyTargetClass&lt;/code&gt; 参数设为 &lt;code&gt;true&lt;/code&gt;，同时将 Girl.java 的 Buy 方法用 &lt;code&gt;final&lt;/code&gt; 修饰：&lt;br/&gt;AppConfig.java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj.aopdemo;

import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.EnableAspectJAutoProxy;

@Configuration
@ComponentScan(basePackageClasses = {com.sharpcj.aopdemo.test1.IBuy.class})
@EnableAspectJAutoProxy(proxyTargetClass = true)
public class AppConfig {
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Girl.java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj.aopdemo.test1;

import org.springframework.stereotype.Component;

@Component
public class Girl implements IBuy {
    @Override
    public final String buy(double price) {
        System.out.println(String.format(&quot;女孩花了%s元买了一件漂亮的衣服&quot;, price));
        return &quot;衣服&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时运行结果：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/758949/201905/758949-20190529225755992-1036671637.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，我们的切面并没有织入生效。&lt;/p&gt;

&lt;p&gt;前面的示例中，我们已经展示了如何通过注解配置去声明切面，下面我们看看如何在 XML 文件中声明切面。下面先列出 XML 中声明 AOP 的常用元素：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/758949/201905/758949-20190529232014979-1838628294.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们依然可以使用 &lt;code&gt;&amp;lt;aop:aspectj-autoproxy&amp;gt;&lt;/code&gt; 元素，他能够自动代理AspectJ注解的通知类。&lt;/p&gt;
&lt;h2 id=&quot;xml-配置文件中切点指示器&quot;&gt;5.1 XML 配置文件中切点指示器&lt;/h2&gt;
&lt;p&gt;在XML配置文件中，切点指示器表达式与通过注解配置的写法基本一致，区别前面有提到，即XML文件中需要使用 “and”、“or”、“not”来表示 “且”、“或”、“非”的关系。&lt;/p&gt;
&lt;h2 id=&quot;xml-文件配置-aop-实例&quot;&gt;5.2 XML 文件配置 AOP 实例&lt;/h2&gt;
&lt;p&gt;下面我们不使用任何注解改造上面的例子：&lt;br/&gt;BuyAspectJ.java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj.aopdemo.test2;

import org.aspectj.lang.ProceedingJoinPoint;

public class BuyAspectJ {

    public void hehe() {
        System.out.println(&quot;before ...&quot;);
    }

    public void haha() {
        System.out.println(&quot;After ...&quot;);
    }

    public void xixi() {
        System.out.println(&quot;AfterReturning ...&quot;);
    }

    public void xxx(ProceedingJoinPoint pj) {
        try {
            System.out.println(&quot;Around aaa ...&quot;);
            pj.proceed();
            System.out.println(&quot;Around bbb ...&quot;);
        } catch (Throwable throwable) {
            throwable.printStackTrace();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 Resource 目录下新建一个配置文件 aopdemo.xml ：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&amp;gt;

    &amp;lt;bean id=&quot;boy&quot; class=&quot;com.sharpcj.aopdemo.test2.Boy&quot;&amp;gt;&amp;lt;/bean&amp;gt;
    &amp;lt;bean id=&quot;girl&quot; class=&quot;com.sharpcj.aopdemo.test2.Girl&quot;&amp;gt;&amp;lt;/bean&amp;gt;
    &amp;lt;bean id=&quot;buyAspectJ&quot; class=&quot;com.sharpcj.aopdemo.test2.BuyAspectJ&quot;&amp;gt;&amp;lt;/bean&amp;gt;

    &amp;lt;aop:config proxy-target-class=&quot;true&quot;&amp;gt;
        &amp;lt;aop:aspect id=&quot;qiemian&quot; ref=&quot;buyAspectJ&quot;&amp;gt;
            &amp;lt;aop:before pointcut=&quot;execution(* com.sharpcj.aopdemo.test2.IBuy.buy(..))&quot; method=&quot;hehe&quot;/&amp;gt;
            &amp;lt;aop:after pointcut=&quot;execution(* com.sharpcj.aopdemo.test2.IBuy.buy(..))&quot; method=&quot;haha&quot;/&amp;gt;
            &amp;lt;aop:after-returning pointcut=&quot;execution(* com.sharpcj.aopdemo.test2.IBuy.buy(..))&quot; method=&quot;xixi&quot;/&amp;gt;
            &amp;lt;aop:around pointcut=&quot;execution(* com.sharpcj.aopdemo.test2.IBuy.buy(..))&quot; method=&quot;xxx&quot;/&amp;gt;
        &amp;lt;/aop:aspect&amp;gt;
    &amp;lt;/aop:config&amp;gt;
&amp;lt;/beans&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里分别定义了一个切面，里面包含四种类型的通知。&lt;br/&gt;测试文件中，使用&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;aopdemo.xml&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;来获取 ApplicationContext，其它代码不变。&lt;/p&gt;
&lt;h2 id=&quot;xml-文件配置声明切点&quot;&gt;5.3 XML 文件配置声明切点&lt;/h2&gt;
&lt;p&gt;对于频繁重复使用的切点表达式，我们也可以声明成切点。&lt;br/&gt;配置文件如下：aopdemo.xml&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&amp;gt;

    &amp;lt;bean id=&quot;boy&quot; class=&quot;com.sharpcj.aopdemo.test2.Boy&quot;&amp;gt;&amp;lt;/bean&amp;gt;
    &amp;lt;bean id=&quot;girl&quot; class=&quot;com.sharpcj.aopdemo.test2.Girl&quot;&amp;gt;&amp;lt;/bean&amp;gt;
    &amp;lt;bean id=&quot;buyAspectJ&quot; class=&quot;com.sharpcj.aopdemo.test2.BuyAspectJ&quot;&amp;gt;&amp;lt;/bean&amp;gt;

    &amp;lt;aop:config proxy-target-class=&quot;true&quot;&amp;gt;
        &amp;lt;aop:pointcut id=&quot;apoint&quot; expression=&quot;execution(* com.sharpcj.aopdemo.test2.IBuy.buy(..))&quot;/&amp;gt;
        &amp;lt;aop:aspect id=&quot;qiemian&quot; ref=&quot;buyAspectJ&quot;&amp;gt;
            &amp;lt;aop:before pointcut-ref=&quot;apoint&quot; method=&quot;hehe&quot;/&amp;gt;
            &amp;lt;aop:after pointcut-ref=&quot;apoint&quot; method=&quot;haha&quot;/&amp;gt;
            &amp;lt;aop:after-returning pointcut-ref=&quot;apoint&quot; method=&quot;xixi&quot;/&amp;gt;
            &amp;lt;aop:around pointcut-ref=&quot;apoint&quot; method=&quot;xxx&quot;/&amp;gt;
        &amp;lt;/aop:aspect&amp;gt;
    &amp;lt;/aop:config&amp;gt;
&amp;lt;/beans&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;xml文件配置为通知传递参数&quot;&gt;5.4 XML文件配置为通知传递参数&lt;/h2&gt;
&lt;p&gt;BuyAspectJ.java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj.aopdemo.test2;

import org.aspectj.lang.ProceedingJoinPoint;

public class BuyAspectJ {
public String hehe(ProceedingJoinPoint pj, double price){
        try {
            pj.proceed();
            if (price &amp;gt; 68) {
                System.out.println(&quot;女孩买衣服超过了68元，赠送一双袜子&quot;);
                return &quot;衣服和袜子&quot;;
            }
        } catch (Throwable throwable) {
            throwable.printStackTrace();
        }
        return &quot;衣服&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;aopdemo.xml&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&amp;gt;

    &amp;lt;bean id=&quot;boy&quot; class=&quot;com.sharpcj.aopdemo.test2.Boy&quot;&amp;gt;&amp;lt;/bean&amp;gt;
    &amp;lt;bean id=&quot;girl&quot; class=&quot;com.sharpcj.aopdemo.test2.Girl&quot;&amp;gt;&amp;lt;/bean&amp;gt;
    &amp;lt;bean id=&quot;buyAspectJ&quot; class=&quot;com.sharpcj.aopdemo.test2.BuyAspectJ&quot;&amp;gt;&amp;lt;/bean&amp;gt;

    &amp;lt;aop:config proxy-target-class=&quot;true&quot;&amp;gt;
        &amp;lt;aop:pointcut id=&quot;apoint&quot; expression=&quot;execution(String com.sharpcj.aopdemo.test2.IBuy.buy(double)) and args(price) and bean(girl)&quot;/&amp;gt;
        &amp;lt;aop:aspect id=&quot;qiemian&quot; ref=&quot;buyAspectJ&quot;&amp;gt;
            &amp;lt;aop:around pointcut-ref=&quot;apoint&quot; method=&quot;hehe&quot;/&amp;gt;
        &amp;lt;/aop:aspect&amp;gt;
    &amp;lt;/aop:config&amp;gt;
&amp;lt;/beans&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;xml-文件配置织入的方式&quot;&gt;5.5 Xml 文件配置织入的方式&lt;/h2&gt;
&lt;p&gt;同注解配置类似,&lt;br/&gt;CGlib 代理方式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;aop:config proxy-target-class=&quot;true&quot;&amp;gt; &amp;lt;/aop:config&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;JDK 代理方式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;aop:config proxy-target-class=&quot;false&quot;&amp;gt; &amp;lt;/aop:config&amp;gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;本文简单记录了 AOP 的编程思想，然后介绍了 Spring 中 AOP 的相关概念，以及通过注解方式和XML配置文件两种方式使用 Spring AOP进行编程。 相比于 AspectJ 的面向切面编程，Spring AOP 也有一些局限性，但是已经可以解决开发中的绝大多数问题了，如果确实遇到了 Spring AOP 解决不了的场景，我们依然可以在 Spring 中使用 AspectJ 来解决。&lt;/p&gt;
</description>
<pubDate>Wed, 29 May 2019 15:13:00 +0000</pubDate>
<dc:creator>SharpCJ</dc:creator>
<og:description>这篇文章简单记录了 AOP 的编程思想，然后重点有序地介绍了 Spring 中 AOP 的相关概念，以及通过注解方式和XML配置文件两种方式使用 Spring AOP进行编程。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/joy99/p/10941543.html</dc:identifier>
</item>
<item>
<title>【tf.keras】tf.keras加载AlexNet预训练模型 - wuliytTaotao</title>
<link>http://www.cnblogs.com/wuliytTaotao/p/10942877.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wuliytTaotao/p/10942877.html</guid>
<description>&lt;p&gt;tf.keras 的预训练模型都放在了'tensorflow.python.keras.applications' 目录下，在 tensorflow 1.10 版本中，预训练好的模型有：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DenseNet121, DenseNet169, DenseNet201, InceptionResNetV2, InceptionV3, MobileNet, NASNetLarge, NASNetMobile, ResNet50, VGG16, VGG19, Xception.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;找了半天，发现 keras 没有预训练好的 AlexNet。。。&lt;/p&gt;
&lt;p&gt;所以本文提供一种从其它框架（如 PyTorch）导入预训练模型的方法，下面以 AlexNet 为例。&lt;/p&gt;
&lt;h2 id=&quot;从-pytorch-中导出模型参数&quot;&gt;从 PyTorch 中导出模型参数&lt;/h2&gt;
&lt;p&gt;首先明白一点，当模型的结构一样时，我们只需要导入模型的参数即可复现模型，所以我们要做的就是从 PyTorch 中导出预训练好的模型参数，并用 keras 加载。&lt;/p&gt;
&lt;p&gt;这里要介绍一个微软的项目：&lt;a href=&quot;https://github.com/microsoft/MMdnn&quot;&gt;MMdnn&lt;/a&gt;。MMdnn 使我们可以在不同深度学习框架之间转换模型，这里我也使用 MMdnn 来转换 AlexNet（PyTorch to Keras）。&lt;/p&gt;
&lt;h3 id=&quot;第-0-步配置环境&quot;&gt;第 0 步：配置环境&lt;/h3&gt;
&lt;pre class=&quot;markdown&quot;&gt;
&lt;code&gt;必须一致配置：
- PyTorch: 0.4.0 （如果其它版本出现了问题，请退回到 0.4.0 版）

非必须一致配置：
- numpy: 1.14.5 &lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;第-1-步安装-mmdnn&quot;&gt;第 1 步：安装 MMdnn&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;$ pip3 install mmdnn&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其它安装方式请参考 &lt;a href=&quot;https://github.com/microsoft/MMdnn#installation&quot;&gt;github&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;第-2-步得到-pytorch-保存完整结构和参数的模型pth-文件&quot;&gt;第 2 步：得到 PyTorch 保存完整结构和参数的模型（pth 文件）&lt;/h3&gt;
&lt;p&gt;PyTorch 保存模型时，可以保存整个模型，也可以仅保存模型的参数，都是存放到 pth 文件中。&lt;/p&gt;
&lt;p&gt;mmdnn 操作的 pth 文件是要求含有模型结构的，具体参见 &lt;a href=&quot;https://github.com/Microsoft/MMdnn/blob/master/mmdnn/conversion/pytorch/README.md#faq&quot;&gt;FAQ&lt;/a&gt;，而在 PyTorch 中预训练 AlexNet 仅保存了参数。&lt;/p&gt;
&lt;p&gt;通过以下程序得到包含有模型结构和权重的 AlexNet 预训练模型（pth 文件）：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import torchvision

m = torchvision.models.alexnet(pretrained=True)                    
torch.save(m, './alexnet.pth')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于其它模型，如 resnet101，可以通过以下指令直接得到含有结构和权重的预训练模型：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ mmdownload -f pytorch -n resnet101 -o ./&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（不要通过上述指令得到 alexnet.pth，因为其仅仅包含权重，而不含结构，故后面一步会出现错误 &quot;AttributeError: 'collections.OrderedDict' object has no attribute 'state_dict'&quot;。）&lt;/p&gt;
&lt;h3 id=&quot;第-3-步导出-pytorch-模型的参数保存至-hdf5-文件&quot;&gt;第 3 步：导出 PyTorch 模型的参数，保存至 hdf5 文件&lt;/h3&gt;
&lt;p&gt;依次执行以下三条指令，最后会得到一个 'keras_alexnet.h5' 文件，这就是我们想要的 keras 能加载的预训练权重文件。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ mmtoir -f pytorch -d alexnet --inputShape 3,227,227 -n alexnet.pth
IR network structure is saved as [alexnet.json].
IR network structure is saved as [alexnet.pb].
IR weights are saved as [alexnet.npy].
$ mmtocode -f keras --IRModelPath alexnet.pb --IRWeightPath alexnet.npy --dstModelPath keras_alexnet.py
Using TensorFlow backend.
Parse file [alexnet.pb] with binary format successfully.
Target network code snippet is saved as [keras_alexnet.py].
$ python3 -m mmdnn.conversion.examples.keras.imagenet_test -n keras_alexnet.py -w alexnet.npy --dump keras_alexnet.h5
Using TensorFlow backend.
Keras model file is saved as [keras_alexnet.h5], generated by [keras_alexnet.py.py] and [alexnet.npy].&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;可能遇到的问题&quot;&gt;可能遇到的问题&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;AttributeError: 'Conv2d' object has no attribute 'padding_mode'&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Solution：PyTorch 版本问题，1.1.0 版会出现这个问题，回退到 0.4.0 版本即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ pip install -i https://pypi.tuna.tsinghua.edu.cn/simple --upgrade torch==0.4.0 torchvision==0.2.0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Solution：请更改 numpy 版本。&lt;/p&gt;
&lt;p&gt;Solution：pth 文件仅含模型参数而不含模型结构，在 PyTorch 中加载一下然后保存含有模型结构和参数的 pth 文件。&lt;/p&gt;
&lt;h2 id=&quot;验证从-pytorch-导出的-alexnet-预训练模型&quot;&gt;验证从 PyTorch 导出的 AlexNet 预训练模型&lt;/h2&gt;
&lt;p&gt;测试用的几张图片、代码以及生成的 keras_alexnet.h5 文件都存放到了云盘：(链接:&lt;a href=&quot;https://pan.baidu.com/s/1TCbSHn5DC7pPIk-0dnbmgg&quot; class=&quot;uri&quot;&gt;https://pan.baidu.com/s/1TCbSHn5DC7pPIk-0dnbmgg&lt;/a&gt; 密码:8njp)。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import torch
import torchvision
import cv2
import numpy as np

from torch.autograd import Variable

import tensorflow as tf
from tensorflow.keras import layers,regularizers


filename_test = 'data/dog2.png'

img = cv2.imread(filename_test)
img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)

# 数据预处理
img = cv2.resize(img, (227, 227))
img = img / 255.0
img = np.reshape(img, (1, 227, 227, 3))
# 标准化，这是 PyTorch 预训练 AlexNet 模型的预处理方式，详情请见 https://pytorch.org/docs/stable/torchvision/models.html
mean = np.array([0.485, 0.456, 0.406]).reshape([1, 1, 1, 3])
std = np.array([0.229, 0.224, 0.225]).reshape([1, 1, 1, 3])
img = (img - mean) / std

# PyTorch
# PyTorch 数据输入 channel 排列和 Keras 不一致
img_tmp = np.transpose(img, (0, 3, 1, 2))

model = torchvision.models.alexnet(pretrained=True)

# torch.save(model, './model/alexnet.pth')
model = model.double()
model.eval()

y = model(Variable(torch.tensor(img_tmp)))
# 预测的类别
print(np.argmax(y.detach().numpy()))


# Keras
def get_AlexNet(num_classes=1000, drop_rate=0.5, regularizer_rate=0.01):
    &quot;&quot;&quot;
    PyTorch 中实现的 AlexNet 预训练模型结构，filter 的深度分别为：（64，192，384，256，256）。
    返回 AlexNet 的 inputs 和 outputs
    &quot;&quot;&quot;
    inputs = layers.Input(shape=[227, 227, 3])

    conv1 = layers.Conv2D(64, (11, 11), strides=(4, 4), padding='valid', activation='relu')(inputs)

    pool1 = layers.MaxPooling2D(pool_size=(3, 3), strides=(2, 2))(conv1)

    conv2 = layers.Conv2D(192, (5, 5), strides=(1, 1), padding='same', activation='relu')(pool1)

    pool2 = layers.MaxPooling2D(pool_size=(3, 3), strides=(2, 2))(conv2)

    conv3 = layers.Conv2D(384, (3, 3), strides=(1, 1), padding='same', activation='relu')(pool2)

    conv4 = layers.Conv2D(256, (3, 3), strides=(1, 1), padding='same', activation='relu')(conv3)

    conv5 = layers.Conv2D(256, (3, 3), strides=(1, 1), padding='same', activation='relu')(conv4)

    pool3 = layers.MaxPooling2D(pool_size=(3, 3), strides=(2, 2))(conv5)

    flat = layers.Flatten()(pool3)

    dense1 = layers.Dense(4096, activation='relu', kernel_regularizer=regularizers.l2(regularizer_rate))(flat)
    dense1 = layers.Dropout(drop_rate)(dense1)
    dense2 = layers.Dense(4096, activation='relu', kernel_regularizer=regularizers.l2(regularizer_rate))(dense1)
    dense2 = layers.Dropout(drop_rate)(dense2)
    outputs = layers.Dense(num_classes, activation='softmax', kernel_regularizer=regularizers.l2(regularizer_rate))(dense2)

    return inputs, outputs

inputs, outputs = get_AlexNet()
model2 = tf.keras.Model(inputs, outputs)
model2.load_weights('./keras_alexnet.h5')
# 预测的类别
print(np.argmax(model2.predict(img)))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;预测结果代表的类别请看博客 &lt;a href=&quot;https://blog.csdn.net/weixin_41770169/article/details/80482942&quot;&gt;ImageNet图像库1000个类别名称（中文注释不断更新）&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;attentions&quot;&gt;Attentions&lt;/h2&gt;
&lt;p&gt;PyTorch 中的预训练 AlexNet 模型卷积层 filter 的个数和原论文不一致，filter 的个数分别 &lt;span class=&quot;math inline&quot;&gt;\(64，192，384，256，256\)&lt;/span&gt;。具体参见 &lt;a href=&quot;https://github.com/pytorch/vision/blob/master/torchvision/models/alexnet.py&quot;&gt;GitHub - pytorch: vision/torchvision/models/alexnet.py&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;PyTorch 给出的解释是，它的预训练 AlexNet 模型用的是论文 &lt;a href=&quot;https://arxiv.org/abs/1404.5997&quot;&gt;Krizhevsky, A. (2014). One weird trick for parallelizing convolutional neural networks. arXiv preprint arXiv:1404.5997.&lt;/a&gt; 给出的架构，但 PyTorch 的模型架构和这篇论文还是有区别，这篇论文中第四个卷积层 filter 个数为 384，而 PyTorch 为 256。&lt;/p&gt;
&lt;p&gt;而 caffe 中实现的 AlexNet 含有原始的 LRN 层，去掉 LRN 层后，个人感觉预训练的权重就不能直接拿来用了。&lt;/p&gt;
&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/microsoft/MMdnn&quot;&gt;GitHub - microsoft/MMdnn&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_41770169/article/details/80482942&quot;&gt;ImageNet图像库1000个类别名称（中文注释不断更新）-- 徐小妹&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 29 May 2019 14:49:00 +0000</pubDate>
<dc:creator>wuliytTaotao</dc:creator>
<og:description>本文介绍了如何将 PyTorch 中实现的 AlexNet 预训练模型加载到 tf.keras 中。tf.keras没有预训练好的AlexNet模型，如果我们想要在keras上用AlexNet来做迁移</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wuliytTaotao/p/10942877.html</dc:identifier>
</item>
</channel>
</rss>