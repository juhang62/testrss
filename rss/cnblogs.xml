<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>视觉有难，八方点赞。 - 上海小胖</title>
<link>http://www.cnblogs.com/moonhmily/p/10693765.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/moonhmily/p/10693765.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190412064510216.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTIzNjU4Mjg=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;昨天下午开始，视觉中国的版权问题就被直接上了热搜，那这里就给大家先普及下什么叫“视觉中国”。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190412064535463.png&quot; alt=&quot;视觉中国 官网&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图片、视频、音频的啥？交易平台。还是个上市公司。不过现在他的官网已经打不开了。&lt;/p&gt;
&lt;p&gt;你不做自媒体，不写新闻稿，可能没听过视觉中国。那么视觉中国基本就是属于自媒体界的黑洞了。&lt;/p&gt;
&lt;p&gt;他对外宣称的模式是签约摄影师，上传拍摄照片，买断版权，付费使用。这套流程还比较清楚，但是这样子赚不到钱啊，怎么办？他想了另一套操作，把自家的照片散步到各大无版权图库中去，混在无版权图库里，如果是个没经验的实习生或者粗心的设计师，用了图片，那你就等着吧，视觉不来找你，不是因为你没问题，是因为你还不够“肥”。现在告你就赚个几万块，等你“肥”了，那可是几十万的价啊！&lt;/p&gt;
&lt;p&gt;所以对于这种行为，我本身还是比较排斥的，好在我平时写文章就发发表情包，再来一个自家头像，你能拿我怎么样？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190412064548440.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTIzNjU4Mjg=,size_16,color_FFFFFF,t_70&quot; alt=&quot;你能拿我怎么样&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不过后来查了查……有点涩涩发抖，因为视觉还把别人家的logo收起来当版权图卖了……我特么……放几个微博图你们感受下……&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019041206460074.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTIzNjU4Mjg=,size_16,color_FFFFFF,t_70&quot; alt=&quot;视觉中国版权图片&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190412064608392.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTIzNjU4Mjg=,size_16,color_FFFFFF,t_70&quot; alt=&quot;视觉中国版权图片&quot;/&gt;&lt;br/&gt;关键你丫连我们国旗国徽都不放过？是不是目中无人了啊……&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190412064619487.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTIzNjU4Mjg=,size_16,color_FFFFFF,t_70&quot; alt=&quot;视觉中国 国旗国徽&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那我现在要想了，你不把我logo收录，是不是瞧不起我胖某人？我好歹也是坐拥……我怎么说在自媒体圈也是响……@视觉中国，请收录我的logo，这是我的高清无码png图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019041206462860.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTIzNjU4Mjg=,size_16,color_FFFFFF,t_70&quot; alt=&quot;视觉中国logo&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好……那话再说回来，你不收我的logo，你起码也起诉我一次啊，这样子，我才好在自媒体圈有炫耀的资本啊！“你看，你做个公众号，还没被视觉起诉过，沙雕“多丢人啊！&lt;/p&gt;
&lt;p&gt;我的微信号是shijueqingqisuwo，麻烦添加一下微信号，添加备注：视觉中国。&lt;/p&gt;
&lt;p&gt;更多有趣、好玩，欢迎关注公众号「&lt;strong&gt;Python专栏&lt;/strong&gt;」，后台回复「&lt;strong&gt;运维自动化平台&lt;/strong&gt;」，获取完整企业级自动化平台源码！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/649191/201902/649191-20190228222044609-1976101388.jpg&quot; width=&quot;300&quot; height=&quot;300&quot; alt=&quot;Python专栏二维码&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 11 Apr 2019 22:52:00 +0000</pubDate>
<dc:creator>上海小胖</dc:creator>
<og:description>昨天下午开始，视觉中国的版权问题就被直接上了热搜，那这里就给大家先普及下什么叫“视觉中国”。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/moonhmily/p/10693765.html</dc:identifier>
</item>
<item>
<title>C语言字符/字符串相关函数收藏 - 东小东</title>
<link>http://www.cnblogs.com/dongxiaodong/p/10693659.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dongxiaodong/p/10693659.html</guid>
<description>&lt;h2&gt;字符处理函数&lt;/h2&gt;
&lt;p&gt;int tolower(char ch)若ch是大写字母('A'-'Z')返回相应的小写字母('a'-'z')&lt;/p&gt;
&lt;p&gt;int toupper(char ch)若ch是小写字母('a'-'z')返回相应的大写字母('A'-'Z')&lt;/p&gt;
&lt;p&gt;int _tolower(char ch)返回ch相应的小写字母('a'-'z')&lt;/p&gt;
&lt;p&gt;int _toupper(char ch)返回ch相应的大写字母('A'-'Z')&lt;/p&gt;
&lt;p&gt;int toascii(char c)返回c相应的ASCII&lt;/p&gt;
&lt;p&gt;举个栗子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
#include&amp;lt;stdio.h&amp;gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(){
   &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; ch1=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;j&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
   printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%c\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,tolower(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;H&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出：h&lt;/span&gt;
   printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%c\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,_toupper(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;h&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出：H&lt;/span&gt;
   printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,toascii(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出：97&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;字符判断函数&lt;/h2&gt;
&lt;p&gt;int isalpha(char ch)  若ch是字母('A'-'Z','a'-'z')返回非0值,(返回1024)否则返回0&lt;/p&gt;
&lt;p&gt;int isalnum(char ch)  若ch是字母('A'-'Z','a'-'z')或数字('0'-'9')，返回非0值,否则返回0&lt;/p&gt;
&lt;p&gt;int isascii(char ch)  若ch是字符(ASCII码中的0-127)返回非0值,否则返回0&lt;/p&gt;
&lt;p&gt;int iscntrl(char ch)  若ch是作废字符(0x7F)或普通控制字符(0x00-0x1F)，返回非0值,否则返回0&lt;/p&gt;
&lt;p&gt;int isdigit(char ch) 若ch是数字('0'-'9')返回非0值,否则返回0&lt;/p&gt;
&lt;p&gt;int isgraph(char ch)  若ch是可打印字符(不含空格)(0x21-0x7E)返回非0值,否则返回0&lt;/p&gt;
&lt;p&gt;int islower(char ch)  若ch是小写字母('a'-'z')返回非0值,否则返回0&lt;/p&gt;
&lt;p&gt;int isupper(char ch)  若ch是大写字母('A'-'Z')返回非0值,否则返回0&lt;/p&gt;
&lt;p&gt;int isprint(char ch)  若ch是可打印字符(含空格)(0x20-0x7E)返回非0值,否则返回0&lt;/p&gt;
&lt;p&gt;int ispunct(char ch)  若ch是标点字符(0x00-0x1F)返回非0值,否则返回0&lt;/p&gt;
&lt;p&gt;int isspace(char ch)  若ch是空格(' '),水平制表符('\t'),回车符('\r'),走纸换行('\f'),垂直制表符('\v'),换行符('\n')  返回非0值,否则返回0&lt;/p&gt;
&lt;p&gt;int isxdigit(char ch) 若ch是16进制数('0'-'9','A'-'F','a'-'f')返回非0值,  否则返回0&lt;/p&gt;
&lt;p&gt;举个栗子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
#include&amp;lt;stdio.h&amp;gt;
&lt;span&gt;void&lt;/span&gt; main(){   &lt;span&gt;char&lt;/span&gt; ch1=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;j&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
   printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,isalpha(ch1));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出：1024&lt;/span&gt;
   printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,isalnum(ch1));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出：8&lt;/span&gt;
   printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,isdigit(ch1));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出：0:&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;类型转换&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Str-&amp;gt;double&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;头文件：stdlib.h&lt;/p&gt;
&lt;p&gt;函数原型：double strtod(const char *nptr,char **endptr);&lt;/p&gt;
&lt;p&gt;说明：nptr为原字符串，endptr原字符串转换后抛弃的后面的内容，填写NULL则不返回，原字符串数字前面只能是控制或者加减号。&lt;/p&gt;
&lt;p&gt;返回值：正负double值&lt;/p&gt;
&lt;p&gt;举个栗子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
#include&amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;stdlib.h&amp;gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(){
   &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *ch1=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;  -100.65987ffjj&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
   &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *&lt;span&gt;endss;
   printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%lf\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,strtod(ch1,NULL));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出：-100.659870&lt;/span&gt;
   printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%lf\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,strtod(ch1,&amp;amp;endss));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出：-100.659870&lt;/span&gt;
   printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,endss);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出：ffjj&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Str-&amp;gt;long int&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;头文件:stdlib.h&lt;/p&gt;
&lt;p&gt;函数原型：long int strtol(const char *str, char **endptr, int base)&lt;/p&gt;
&lt;p&gt;返回值：长整型，以base提取，然后再转换为long int 类型&lt;/p&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;p&gt;str -- 要转换为长整数的字符串。&lt;/p&gt;
&lt;p&gt;endptr -- 对类型为 char* 的对象的引用，其值由函数设置为 str 中数值后的下一个字符。&lt;/p&gt;
&lt;p&gt;base -- 基数，必须介于 2 和 36（包含）之间，或者是特殊值 0（如0x开头的自动设置为十六进制等）。&lt;/p&gt;
&lt;p&gt;举个栗子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
#include&amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;stdlib.h&amp;gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(){
   &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *ch1=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0101jjx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
   &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *&lt;span&gt;endss;
   printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%ld\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,strtol(ch1,NULL,&lt;span&gt;2&lt;/span&gt;));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出：5&lt;/span&gt;
   printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%ld\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,strtol(ch1,&amp;amp;endss,&lt;span&gt;10&lt;/span&gt;));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出：101&lt;/span&gt;
   printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,endss);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出：jjx&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Str-&amp;gt;int&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;头文件：stdlib.h&lt;/p&gt;
&lt;p&gt;原型：int atoi(const char *nptr);&lt;/p&gt;
&lt;p&gt;注意：原字符串开头必须是空格或者数字或者加减号&lt;/p&gt;
&lt;p&gt;举个栗子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
#include&amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;stdlib.h&amp;gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(){
   &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *ch1=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;  11.963xxx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
   printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,atoi(ch1));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出：11&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;str-&amp;gt;double&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;atof() 字符串转换到 double 符点数,使用方法与stoi相似&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;str-&amp;gt;long int&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;atol() 字符串转换到 long 整型，使用方法与stoi相似&lt;/p&gt;
&lt;h2&gt;字符串处理函数&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;长度计算：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;strlen()函数：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;头文件：string.h&lt;/p&gt;
&lt;p&gt;原型：int strlen(const char *str)&lt;/p&gt;
&lt;p&gt;返回值：遇到’\0’或者0就返回，返回此之前的字符串长度&lt;/p&gt;
&lt;p&gt;举个栗子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
#include&amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;.h&amp;gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(){
&lt;/span&gt;&lt;span&gt;   //&lt;/span&gt;&lt;span&gt; char ch[]={'a','b',0,'c'};&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 0或者‘\0’&lt;/span&gt;
&lt;span&gt;   char&lt;/span&gt; ch[]={&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;};
   printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;strlen为：%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,strlen(ch)); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出2&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;运算符sizeof()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;C/C++中的一个操作符（operator），返回是一个对象或者类型所占的内存字节数&lt;/p&gt;
&lt;p&gt;举个栗子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
#include&amp;lt;stdio.h&amp;gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(){
&lt;/span&gt;&lt;span&gt;char&lt;/span&gt; ch[]={&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;};
   &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; inx=&lt;span&gt;10&lt;/span&gt;&lt;span&gt;;
   printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ch===sizeof:%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;sizeof&lt;/span&gt;(ch));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出：3&lt;/span&gt;
   printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;int===sizeof:%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;sizeof&lt;/span&gt;(inx));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出：4&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;拷贝(替换)函数：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;strcpy()函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;头文件：string.h&lt;/p&gt;
&lt;p&gt;原型：char *strcpy(char *dest, const char *src);&lt;/p&gt;
&lt;p&gt;返回值：将str以’\0’或者0为截止前的字符串替换dest，返回值为dest首地址或者也可以直接访问dest获得最终结果&lt;/p&gt;
&lt;p&gt;举个栗子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
#include&amp;lt;&lt;span&gt;string&lt;/span&gt;.h&amp;gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(){
   &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; ch1[&lt;span&gt;100&lt;/span&gt;]=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123456789&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
   &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *ch2=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;abc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
   printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,strcpy(ch1,ch2));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出abc&lt;/span&gt;
   printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,ch1);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出：abc&lt;/span&gt;
   printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,ch2);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出：abc&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;strncpy()函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;头文件：string.h&lt;/p&gt;
&lt;p&gt;原型：char *strncpy(char *dest, const char *src, int n)&lt;/p&gt;
&lt;p&gt;返回值：将src以’\0’或0或者n长度为截止前的字符串替换dest，返回值为dest首地址或者也可以直接访问dest获得最终结果&lt;/p&gt;
&lt;p&gt;注意：这个n值很重要，如果拷贝到了src最后的‘\0’则如同替换效果了，如果拷贝是n的值小于或者等于strlen(),则会保留dest未使用的内容。&lt;/p&gt;
&lt;p&gt;举个栗子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
#include&amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;.h&amp;gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(){
   &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; ch1[&lt;span&gt;100&lt;/span&gt;]=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123456789&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
   &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *ch2=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;abc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
   printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,strncpy(ch1,ch2,strlen(ch2)));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出：abc456789&lt;/span&gt;
   printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,ch1);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出：abc456789&lt;/span&gt;
   printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,ch2);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出：abc&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;比较函数&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;strcmp()与strncmp()函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;头文件：string.h&lt;/p&gt;
&lt;p&gt;原型：&lt;/p&gt;
&lt;p&gt;int strcmp(const char *s1, const char *s2);&lt;/p&gt;
&lt;p&gt;int strncmp(const char *s1, const char *s2,int n);&lt;/p&gt;
&lt;p&gt;返回值：若参数s1 和s2 字符串相同则返回0，s1 若大于s2 则返回大于0 的值，s1 若小于s2 则返回小于0 的值。&lt;/p&gt;
&lt;p&gt;举个栗子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
#include&amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;.h&amp;gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(){
   &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *ch1=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BCD&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
   &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *ch2=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BCd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
   printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,strcmp(ch1,ch2)); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出：-32&lt;/span&gt;
   printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,strncmp(ch1,ch2,&lt;span&gt;2&lt;/span&gt;));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出：0&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;strcasecm()与strncasecm()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;忽略字母大小写进行比较，其他类似strcmp()函数&lt;/p&gt;
&lt;p&gt;举个栗子&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
#include&amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;.h&amp;gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(){
   &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *ch1=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;abdc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
   printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,strncasecmp(ch1,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ABC&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出：0&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;追加函数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;strcat()与strncat()函数&lt;/p&gt;
&lt;p&gt;头文件：string.h&lt;/p&gt;
&lt;p&gt;原型：&lt;/p&gt;
&lt;p&gt;char *strcat(char *dest, const char *src)&lt;/p&gt;
&lt;p&gt;char *strcat(char *dest, const char *src,int n)&lt;/p&gt;
&lt;p&gt;返回值：将src以追加的方式添加到dest中，返回值为dest首地址或者也可以直接访问dest获得最终结果&lt;/p&gt;
&lt;p&gt;举个栗子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
#include&amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;.h&amp;gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(){
   &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; ch1[&lt;span&gt;100&lt;/span&gt;]=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BCD&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
   &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *ch2=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123456&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
   printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,strcat(ch1,ch2));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出：BCD123456&lt;/span&gt;
   printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,strncat(ch1,ch2,&lt;span&gt;2&lt;/span&gt;));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出：BCD12345612&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;查找字符&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;strchr()与strrchr()函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;头文件：string.h&lt;/p&gt;
&lt;p&gt;原型：&lt;/p&gt;
&lt;p&gt;char *strchr(const char *s,char c) //从左向右&lt;/p&gt;
&lt;p&gt;char *strrchr(const char *s,char c) //从右向左&lt;/p&gt;
&lt;p&gt;返回值：返回查找到的本身位置，如果查找失败则发货NULL&lt;/p&gt;
&lt;p&gt;举个栗子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #include&amp;lt;stdio.h&amp;gt;
&lt;span&gt; 2&lt;/span&gt; #include&amp;lt;&lt;span&gt;string&lt;/span&gt;.h&amp;gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(){
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;    &lt;span&gt;char&lt;/span&gt; *ch1=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1234563221&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;    printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,strchr(ch1,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出：34563221&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;    printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,strrchr(ch1,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出：3221&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;    &lt;span&gt;if&lt;/span&gt;(!strchr(ch1,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;R&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)){
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;        printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-------------\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;成功输出此处&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;查找字符串&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;strstr()函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;头文件：string.h&lt;/p&gt;
&lt;p&gt;原型&lt;/p&gt;
&lt;p&gt;char *strstr(char *str1, const char *str2);//从左向右&lt;/p&gt;
&lt;p&gt;返回值：返回查找到的字符串中的首地址&lt;/p&gt;
&lt;p&gt;注意：strrstr()函数是不自带的，可以通过strstr()进行模拟&lt;/p&gt;
&lt;p&gt;举个栗子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
#include&amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include&amp;lt;string.h&amp;gt;
void&lt;span&gt; main(){
   char *ch1=&quot;1234562321&quot;&lt;span&gt;;
   printf(&quot;%s\n&quot;,strstr(ch1,&quot;23&quot;));//234562321
   if(!strstr(ch1,&quot;5566&quot;&lt;span&gt;)){
      printf(&quot;-------------\n&quot;);//成功输出此处
&lt;span&gt;   }
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参考：&lt;a href=&quot;https://blog.csdn.net/ayi_5788/article/details/8985544&quot;&gt;https://blog.csdn.net/ayi_5788/article/details/8985544&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 11 Apr 2019 17:34:00 +0000</pubDate>
<dc:creator>东小东</dc:creator>
<og:description>字符处理函数 int tolower(char ch)若ch是大写字母('A'-'Z')返回相应的小写字母('a'-'z') int t</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dongxiaodong/p/10693659.html</dc:identifier>
</item>
<item>
<title>sqlmap Bool型&amp;延时型 检测策略分析 - ka1n4t</title>
<link>http://www.cnblogs.com/litlife/p/10693582.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/litlife/p/10693582.html</guid>
<description>&lt;h2 id=&quot;x00-预备-querypage&quot;&gt;0x00 预备-queryPage()&lt;/h2&gt;
&lt;p&gt;首先先讲一个核心的函数：queryPage()。这个函数在以下分析中贯穿始终。其被用于请求页面， 同时具有多种返回值以适配多种检测策略，见下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190412004227140-1141072471.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面分析一下这几个return的情况。&lt;/p&gt;
&lt;p&gt;第一个return：1237行，如果传入timeBasedCompare=True，则return wasLastResponseDelayed()，这个语句会在延时型注入中用到。函数wasLastResponseDelayed()的返回值为一个布尔值，如果上次请求有延迟则为True，反之为False。这个函数的具体的实现见延时型检测策略的判断依据部分。&lt;/p&gt;
&lt;p&gt;第二个return：1249行，其中content和reponse都是函数参数传过来的，默认为False，如果为true则返回这次请求的响应体、响应头、响应码。&lt;/p&gt;
&lt;p&gt;第三个return：1252行，getRatioValue也为函数参数传来的，如果为True，则返回一个元组，两个元素分别为两个comparison函数的返回值，此元组为(布尔值, ratio)（注：ratio为两次请求的响应内容的重合率，被用作判断页面是否变化的依据）。comparison函数被应用在Bool型盲注中，其具体实现逻辑见bool型检测策略的判断依据部分。&lt;/p&gt;
&lt;p&gt;第四个return：1254行，为上一个return的else条件，直接返回ratio值。&lt;/p&gt;
&lt;h2 id=&quot;x01-bool型检测策略&quot;&gt;0x01 bool型检测策略&lt;/h2&gt;
&lt;p&gt;首先bool型检测之前，程序会提前检测页面是否稳定（checkStability()），即测试两个参数相同的请求的响应是否相同，如果不同则说明页面中有可能存在类似于时间戳的东西。如果动态内容对页面改动较大（ratio&amp;lt;0.98，ratio为调用quick_ratio的值，此函数原理下方说明），则调用findDynamicContent函数，去定位页面中动态内容的位置，并将其定位存在kb中。&lt;/p&gt;
&lt;p&gt;然后到了bool型检测代码段，先上图&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190412004342451-679414295.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先看到475行调用了queryPage函数，其payload参数位置传入了getCmpPayload()，getCmpPayload这个函数主要是根据每个payload对应的comparison标签构造CmpPayload(用于与payload标签进行比较，比如payload为1=1，那么CmpPaload就是类似为1=2)。可以看到这一步程序没有取queryPage的返回值，因为其主要作用是设置threadData中的lastPage之类的值，用于下一次True请求与之比较。紧接着就会发现476行直接把threadData的几个last变量传给了falsePage\falseHeaders\falseCode，方便下面比较。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190412004358056-55776539.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接着看到480-482行发送了True逻辑的请求，并将其响应也赋值给对应的truePage\trueHeaders\trueCode。这里queryPage的返回值赋值给了trueResult，这个函数的返回值已经在第0部分中说了，由于这里没有传入什么多余的参数，因此进入的是第四个return，即一个布尔值，代表较ori_page，这个界面是否发生了变化。&lt;/p&gt;
&lt;p&gt;然后在484行进行if判断，当true与false响应不同时进入（bool注入可能存在的基础）。进来后再次进行一次false判断用于防止误报，如果comparison返回的还是false，那就基本上确定为存在漏洞。反之，如果这次返回了True，与第一次的结果不同，那么还要进行下一次防止误报，尝试了解为什么会结果不同。&lt;br/&gt;这就来到了505行：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190412004416415-85177951.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里的防误报原理主要是提取响应中的文本内容，然后将响应内容中的纯文本内容拿出来进行单独对比（即去掉script、css、注释、html等标签），同理，如果有True响应中有而False中没有的字符串，则确认为有漏洞。&lt;/p&gt;
&lt;p&gt;然后剩下的525行之后，如果确认存在漏洞需要进行的内容，就是输出一些bool型注入的判断依据字符之类的东西，这里就不在跟进了。如下图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190412004537498-1316314563.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;判断依据&quot;&gt;判断依据&lt;/h3&gt;
&lt;p&gt;comparison()函数原理：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190412004543930-736522114.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;经查看代码可以发现，其主要调用的是_comparison()，因此下面对这个函数进行详细的分析。&lt;/p&gt;
&lt;p&gt;首先以kb.pageTamplate作为与本次请求对比的响应，这个变量是程序在初始化阶段调用checkConnection()设置的，其请求中不包含payload。&lt;br/&gt;然后在根据上面的动态内容位置，去掉kb.pageTamplate和本次请求响应中的动态内容。见89-90行&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190412004550392-885245936.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后调用difflib库的quick_ratio方法，计算两者的页面相似比率，将之赋值给ratio。见139行&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190412004559148-1311835645.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;程序事先定义了两个常量：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;LOWER_RATIO_BOUND==0.02
UPPER_RATIO_BOUND==0.98&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后设置kb.matchRatio，当ratio在两者中间时，程序会将ratio赋值给kb.matchRatio。见143-146行&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190412004605988-1253303779.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后return时，此函数分为了以下几种情况：&lt;br/&gt;1.当ratio&amp;gt;0.98时返回True，即判断为页面相同；&lt;br/&gt;2.ratio&amp;lt;0.02时判断为页面不同；&lt;br/&gt;3.return (ratio - kb.matchRatio) &amp;gt; DIFF_TOLERANCE(0.05)，kb.matchRatio是一个在0.02与0.98之间的值，在上面已经说了，是在一次请求中使用ratio赋值的。这个return的判断可以转换成ratio&amp;gt;kb.matchRatio+0.05，也就是说ratio必须大于之前的一次ratio至少0.05才行，同时如果ratio&amp;gt;0.98也是直接返回True的（第一次的条件）。&lt;/p&gt;
&lt;h3 id=&quot;quick_ratio&quot;&gt;quick_ratio()&lt;/h3&gt;
&lt;p&gt;统计字符的个数（比如字母a有29个等等），然后拿匹配的字母数*2/两个对比字符串的字符总数&lt;/p&gt;
&lt;h3 id=&quot;案例&quot;&gt;案例&lt;/h3&gt;
&lt;p&gt;下面看一下在使用正确的boundary突破边界之后，True请求和False请求的最终对比界面是什么。&lt;br/&gt;首先是一个正常请求的响应(www.test.com/index.php?id=2)：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190412004613781-1259062181.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第一个框是直接返回url中的参数值，即id=2。&lt;br/&gt;第二个框是时间戳，即保证在每次响应这一部分都是变化的。&lt;br/&gt;第三个框是“you are in”，表示可以在数据库中找到数据，看一下源码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190412004619657-880040082.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面先看一下True请求的响应。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190412004625856-69570230.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，第一个框处只有id=，没有id的值，这是因为在进行对比之前，为了避免“payload本身就是不同的”这种影响，实现就已经去掉了这些反射型的参数（类似于xss，即页面直接返回了用户可控的参数）。&lt;/p&gt;
&lt;p&gt;再False的响应。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190412004632932-1474144248.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里也没有第一个框，跟True响应的情况相同。同时这里也没有第三个框，因为这个False语句构建了一个逻辑假的SQL语句，直接导致程序无法在数据库中找到数据。&lt;/p&gt;
&lt;h2 id=&quot;x02-延时型&quot;&gt;0x02 延时型&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190412004638616-1636458341.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;598行开始进行延时型判断，600行调用queryPage函数，返回值为一个布尔值，True表示这次请求产生了延迟（见‘判断依据’部分），code为http响应码。&lt;br/&gt;接着进入603行的if语句，如果上次存在延时则进入（由于payload中使用了[SLEEPTIME]，在queryPage中将之替换成了一个值，所以如果存在漏洞则一定会有延时）。&lt;br/&gt;如果进入了这个语句块则再次进行一次时延时间为0的请求，如果还是产生时延则说明为误报。如果没有时延则在611行再进行一次有时延时间的请求，结果如果还是True（与603行结果一致），则确定为存在漏洞。&lt;/p&gt;
&lt;h3 id=&quot;判断依据-1&quot;&gt;判断依据&lt;/h3&gt;
&lt;p&gt;判断本次请求是否产生延迟调用的是wasLastResponseDelayed函数，先放个图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190412004643722-1022148537.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190412004649143-744519519.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，首先计算标准差：deviation。然后在2402行计算lowerStdLimit，值为平均数+7*标准差，以这个值看做一个阈值，作为最大延迟时间(小于0.5时看做0.5)。大于这个数的请求都看做是发生延时的请求。+-7*标准差能保证99.9999999997440%的未延时请求能落在这个区间里。&lt;/p&gt;
&lt;h3 id=&quot;使用标准差的原因&quot;&gt;使用标准差的原因&lt;/h3&gt;
&lt;p&gt;为什么不是平均值呢，因为标准差更能反映一组数据的离散程度。比如熊的平均体重是140kg，标准差为5kg，那么一只熊的重量可能在135-145kg(根据标准差计算)之间，也有可能在120-160kg(根据平均数猜测)之间。因此仅仅查看所有熊的平均重量就不可能知道单个熊的重量，但是标准差可以告诉你单个熊的可靠重量范围。这就是这里使用标准差的意义。&lt;br/&gt;&lt;strong&gt;参考:&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;https://social.technet.microsoft.com/wiki/contents/articles/237.scom-how-self-tuning-threshold-baseline-is-computed.aspx&quot;&gt;1.How Self-Tuning Threshold Baseline is Computed&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.answers.com/Q/What_is_standard_deviation&quot;&gt;2.标准差的意义&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;xff参考&quot;&gt;0xFF参考：&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://paper.seebug.org/729/#_8&quot;&gt;sqlmap 检测剖析 -- 凤雏&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/hongfei/p/sqlmap-time-based-blind.html&quot;&gt;Python：SQLMap源码精读—基于时间的盲注（time-based blind） -- 曾是土木人&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.freebuf.com/column/168112.html&quot;&gt;sqlmap time-based inject 分析 -- 美丽联合SRC&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/think_ycx/article/details/52083782&quot;&gt;sqlmap基于时间盲注判断原理 -- think_ycx&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.anquanke.com/post/id/167408&quot;&gt;Sqlmap如何检测Boolean型注入 -- lufei&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/wn314/article/details/78872828&quot;&gt;sqlmap中文手册 -- werner-wiki&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.freebuf.com/sectool/164608.html&quot;&gt;超详细SQLMap使用攻略及技巧分享&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 11 Apr 2019 16:43:00 +0000</pubDate>
<dc:creator>ka1n4t</dc:creator>
<og:description>sqlmap Bool型&amp;延时型 检测策略分析 [TOC] 0x00 预备 queryPage() 首先先讲一个核心的函数：queryPage()。这个函数在以下分析中贯穿始终。其被用于请求页面， 同</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/litlife/p/10693582.html</dc:identifier>
</item>
<item>
<title>数据结构（二）：栈 - 漫漫芜</title>
<link>http://www.cnblogs.com/sheshouxin/p/10680634.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sheshouxin/p/10680634.html</guid>
<description>&lt;p&gt;&lt;strong&gt;栈&lt;/strong&gt;：后进先出（LIFO）表。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特点&lt;/strong&gt;：只允许在顶部进行存取操作的顺序表。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基本操作&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;push：入栈，即将元素压入栈顶&lt;/li&gt;
&lt;li&gt;pop：出栈，即将栈顶元素删除&lt;/li&gt;
&lt;li&gt;top：输出栈顶元素&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;应用场景&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;平衡符号&lt;/strong&gt;：编译器中用于检查符号是否成对出现，方法为做一个空栈，读取字符，如果字符是一个开放符号如“{”、“(”、“[”等，将其压入栈中。如果字符是一个封闭符号，如“}”、“)”、“]”，此时如果栈为空，说明有字符没有成对出现；否则将栈元素弹出，如果弹出的符号不是对应的开放符号，同样说明没有成对出现；如果字符读取完毕时栈不为空，也说明字符没有成对出现。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;函数调用：&lt;/strong&gt;函数在调用的时候，需要存储所有的重要信息，如变量名、返回地址等，这些信息就是通过栈来存储，然后控制转移到新的函数，当函数返回时从栈中取出存储的信息，继续从转移前的位置往下执行。递归函数对栈的使用开销极大，而且很容易导致栈溢出，可以通过栈操作来模拟递归过程。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;栈的链表实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Node(object):
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(self, value=None, next=&lt;span&gt;None):
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         self.value =&lt;span&gt; value
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         self.next =&lt;span&gt; next
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Stack(object):
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(self, maxsize=8&lt;span&gt;):
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         self._head = Node() &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 表头，无实际意义&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         self._top =&lt;span&gt; None
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         self.maxsize =&lt;span&gt; maxsize
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         self.length =&lt;span&gt; 0
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; pop(self):
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; self.length &amp;gt;&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             node =&lt;span&gt; self._head.next
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             self._head.next =&lt;span&gt; node.next
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             self.length -= 1
&lt;span&gt;19&lt;/span&gt;             self._top =&lt;span&gt; self._head.next
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;raise&lt;/span&gt; Exception(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Empty stack&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; push(self, value):
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; self.length &amp;gt;=&lt;span&gt; self.maxsize:
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             &lt;span&gt;raise&lt;/span&gt; Exception(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Stack is full&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         node =&lt;span&gt; Node(value)
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         node.next =&lt;span&gt; self._head.next
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         self._head.next =&lt;span&gt; node
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         self.length += 1
&lt;span&gt;30&lt;/span&gt;         self._top =&lt;span&gt; self._head.next
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; top(self):
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; self.length &amp;gt;&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; self._top.value
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;             &lt;span&gt;raise&lt;/span&gt; Exception(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Stack is empty&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__len__&lt;/span&gt;&lt;span&gt;(self):
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; self.length
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;栈的数组实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; array &lt;span&gt;import&lt;/span&gt;&lt;span&gt; array
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Stack(object):
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(self, maxsize=8&lt;span&gt;):
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         self._array = array(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;i&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, range(maxsize))
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         self.maxsize =&lt;span&gt; maxsize
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         self.length =&lt;span&gt; 0
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         self.index = -1
&lt;span&gt; 9&lt;/span&gt;         self._top =&lt;span&gt; None
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; push(self, value):
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; self.length &amp;gt;=&lt;span&gt; self.maxsize:
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;raise&lt;/span&gt; Exception(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Stack is full&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         self.index += 1
&lt;span&gt;15&lt;/span&gt;         self._array[self.index] =&lt;span&gt; value
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         self.length += 1
&lt;span&gt;17&lt;/span&gt;         self._top =&lt;span&gt; value
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; pop(self):
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; self.length &amp;lt;=&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;raise&lt;/span&gt; Exception(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Stack is empty&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         self.index -= 1
&lt;span&gt;23&lt;/span&gt;         self.length -= 1
&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; self.index &amp;gt;=&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             self._top =&lt;span&gt; self._array[self.index]
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             self._top =&lt;span&gt; None
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; top(self):
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; self._top
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__len__&lt;/span&gt;&lt;span&gt;(self):
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; self.length
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Thu, 11 Apr 2019 16:39:00 +0000</pubDate>
<dc:creator>漫漫芜</dc:creator>
<og:description>数据结构栈的python实现</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sheshouxin/p/10680634.html</dc:identifier>
</item>
<item>
<title>[开源]基于Log4Net简单实现KafkaAppender - MeetYan</title>
<link>http://www.cnblogs.com/MeetYan/p/10693545.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MeetYan/p/10693545.html</guid>
<description>&lt;li readability=&quot;11&quot;&gt;
&lt;p&gt;基于Log4Net来实现与kafka通讯Appender&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt; public class KafkaAppender : AppenderSkeleton
 {
     #region Fields

     /// &amp;lt;summary&amp;gt;
     ///     Kafka 生产者
     /// &amp;lt;/summary&amp;gt;
     private Producer _kafkaProducer;

     #endregion Fields

     #region Properties

     /// &amp;lt;summary&amp;gt;
     ///     Brokers
     /// &amp;lt;/summary&amp;gt;
     public string Brokers { get; set; }

     /// &amp;lt;summary&amp;gt;
     ///     Topic
     /// &amp;lt;/summary&amp;gt;
     public string Topic { get; set; }

     #endregion Properties

     #region Methods

     /// &amp;lt;summary&amp;gt;
     ///     Initialize the appender based on the options set
     /// &amp;lt;/summary&amp;gt;
     /// &amp;lt;remarks&amp;gt;
     ///     &amp;lt;para&amp;gt;
     ///         This is part of the &amp;lt;see cref=&quot;T:log4net.Core.IOptionHandler&quot; /&amp;gt; delayed object
     ///         activation scheme. The &amp;lt;see cref=&quot;M:log4net.Appender.AppenderSkeleton.ActivateOptions&quot; /&amp;gt; method must
     ///         be called on this object after the configuration properties have
     ///         been set. Until &amp;lt;see cref=&quot;M:log4net.Appender.AppenderSkeleton.ActivateOptions&quot; /&amp;gt; is called this
     ///         object is in an undefined state and must not be used.
     ///     &amp;lt;/para&amp;gt;
     ///     &amp;lt;para&amp;gt;
     ///         If any of the configuration properties are modified then
     ///         &amp;lt;see cref=&quot;M:log4net.Appender.AppenderSkeleton.ActivateOptions&quot; /&amp;gt; must be called again.
     ///     &amp;lt;/para&amp;gt;
     /// &amp;lt;/remarks&amp;gt;
     public override void ActivateOptions()
     {
         base.ActivateOptions();
         InitKafkaProducer();
     }

     /// &amp;lt;summary&amp;gt;
     ///     Subclasses of &amp;lt;see cref=&quot;T:log4net.Appender.AppenderSkeleton&quot; /&amp;gt; should implement this method
     ///     to perform actual logging.
     /// &amp;lt;/summary&amp;gt;
     /// &amp;lt;param name=&quot;loggingEvent&quot;&amp;gt;The event to append.&amp;lt;/param&amp;gt;
     /// &amp;lt;remarks&amp;gt;
     ///     &amp;lt;para&amp;gt;
     ///         A subclass must implement this method to perform
     ///         logging of the &amp;lt;paramref name=&quot;loggingEvent&quot; /&amp;gt;.
     ///     &amp;lt;/para&amp;gt;
     ///     &amp;lt;para&amp;gt;
     ///         This method will be called by &amp;lt;see cref=&quot;M:DoAppend(LoggingEvent)&quot; /&amp;gt;
     ///         if all the conditions listed for that method are met.
     ///     &amp;lt;/para&amp;gt;
     ///     &amp;lt;para&amp;gt;
     ///         To restrict the logging of events in the appender
     ///         override the &amp;lt;see cref=&quot;M:PreAppendCheck()&quot; /&amp;gt; method.
     ///     &amp;lt;/para&amp;gt;
     /// &amp;lt;/remarks&amp;gt;
     protected override void Append(LoggingEvent loggingEvent)
     {
         try
         {
             var message = GetLogMessage(loggingEvent);
             var topic = GetTopic(loggingEvent);

             _ = _kafkaProducer.SendMessageAsync(topic, new[] {new Message(message)});
         }
         catch (Exception ex)
         {
             ErrorHandler.Error(&quot;KafkaProducer SendMessageAsync&quot;, ex);
         }
     }

     /// &amp;lt;summary&amp;gt;
     ///     Raises the Close event.
     /// &amp;lt;/summary&amp;gt;
     /// &amp;lt;remarks&amp;gt;
     ///     &amp;lt;para&amp;gt;
     ///         Releases any resources allocated within the appender such as file handles,
     ///         network connections, etc.
     ///     &amp;lt;/para&amp;gt;
     ///     &amp;lt;para&amp;gt;
     ///         It is a programming error to append to a closed appender.
     ///     &amp;lt;/para&amp;gt;
     /// &amp;lt;/remarks&amp;gt;
     protected override void OnClose()
     {
         base.OnClose();
         StopKafkaProducer();
     }

     private string GetLogMessage(LoggingEvent loggingEvent)
     {
         var builder = new StringBuilder();
         using (var writer = new StringWriter(builder))
         {
             Layout.Format(writer, loggingEvent);

             if (Layout.IgnoresException &amp;amp;&amp;amp; loggingEvent.ExceptionObject != null)
                 writer.Write(loggingEvent.GetExceptionString());

             return writer.ToString();
         }
     }

     private string GetTopic(LoggingEvent loggingEvent)
     {
         return string.IsNullOrEmpty(Topic) ? Path.GetFileNameWithoutExtension(loggingEvent.Domain) : Topic;
     }

     /// &amp;lt;summary&amp;gt;
     ///     初始化Kafka 生产者
     /// &amp;lt;/summary&amp;gt;
     private void InitKafkaProducer()
     {
         try
         {
             if (string.IsNullOrEmpty(Brokers)) Brokers = &quot;http://localhost:9200&quot;;

             if (_kafkaProducer == null)
             {
                 var brokers = new Uri(Brokers);
                 var kafkaOptions = new KafkaOptions(brokers)
                 {
                     Log = new KafkaLog()
                 };
                 _kafkaProducer = new Producer(new BrokerRouter(kafkaOptions));
             }
         }
         catch (Exception ex)
         {
             ErrorHandler.Error(&quot;InitKafkaProducer&quot;, ex);
         }
     }

     /// &amp;lt;summary&amp;gt;
     ///     停止生产者
     /// &amp;lt;/summary&amp;gt;
     private void StopKafkaProducer()
     {
         try
         {
             _kafkaProducer?.Stop();
         }
         catch (Exception ex)
         {
             ErrorHandler.Error(&quot;StopKafkaProducer&quot;, ex);
         }
     }

     #endregion Methods
 }
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;&lt;li readability=&quot;14&quot;&gt;
&lt;p&gt;基于之前定义接口，来实现kafkaLogService&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public sealed class KafkaLogService : ILogService
{
    #region Constructors

    /// &amp;lt;summary&amp;gt;
    ///     Initializes the &amp;lt;see cref=&quot;FileLogService&quot; /&amp;gt; class.
    /// &amp;lt;/summary&amp;gt;
    static KafkaLogService()
    {
        KafkaLogger = LogManager.GetLogger(KafkaLoggerName);
    }

    #endregion Constructors

    #region Fields

    /// &amp;lt;summary&amp;gt;
    ///     Kafka logger name
    /// &amp;lt;/summary&amp;gt;
    public const string KafkaLoggerName = &quot;KafkaLogger&quot;;

    /// &amp;lt;summary&amp;gt;
    ///     Kafka logger
    /// &amp;lt;/summary&amp;gt;
    public static readonly ILog KafkaLogger;

    #endregion Fields

    #region Methods

    /// &amp;lt;summary&amp;gt;
    ///     Debug记录
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;message&quot;&amp;gt;日志信息&amp;lt;/param&amp;gt;
    public void Debug(string message)
    {
        if (KafkaLogger.IsDebugEnabled) KafkaLogger.Debug(message);
    }

    /// &amp;lt;summary&amp;gt;
    ///     Debug记录
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;message&quot;&amp;gt;日志信息&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;ex&quot;&amp;gt;异常信息&amp;lt;/param&amp;gt;
    public void Debug(string message, Exception ex)
    {
        if (KafkaLogger.IsDebugEnabled) KafkaLogger.Debug(message, ex);
    }

    /// &amp;lt;summary&amp;gt;
    ///     Error记录
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;message&quot;&amp;gt;日志信息&amp;lt;/param&amp;gt;
    public void Error(string message)
    {
        if (KafkaLogger.IsErrorEnabled) KafkaLogger.Error(message);
    }

    /// &amp;lt;summary&amp;gt;
    ///     Error记录
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;message&quot;&amp;gt;日志信息&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;ex&quot;&amp;gt;异常信息&amp;lt;/param&amp;gt;
    public void Error(string message, Exception ex)
    {
        if (KafkaLogger.IsErrorEnabled) KafkaLogger.Error(message, ex);
    }

    /// &amp;lt;summary&amp;gt;
    ///     Fatal记录
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;message&quot;&amp;gt;日志信息&amp;lt;/param&amp;gt;
    public void Fatal(string message)
    {
        if (KafkaLogger.IsFatalEnabled) KafkaLogger.Fatal(message);
    }

    /// &amp;lt;summary&amp;gt;
    ///     Fatal记录
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;message&quot;&amp;gt;日志信息&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;ex&quot;&amp;gt;异常信息&amp;lt;/param&amp;gt;
    public void Fatal(string message, Exception ex)
    {
        if (KafkaLogger.IsFatalEnabled) KafkaLogger.Fatal(message, ex);
    }

    /// &amp;lt;summary&amp;gt;
    ///     Info记录
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;message&quot;&amp;gt;日志信息&amp;lt;/param&amp;gt;
    public void Info(string message)
    {
        if (KafkaLogger.IsInfoEnabled) KafkaLogger.Info(message);
    }

    /// &amp;lt;summary&amp;gt;
    ///     Info记录
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;message&quot;&amp;gt;日志信息&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;ex&quot;&amp;gt;异常信息&amp;lt;/param&amp;gt;
    public void Info(string message, Exception ex)
    {
        if (KafkaLogger.IsInfoEnabled) KafkaLogger.Info(message, ex);
    }

    /// &amp;lt;summary&amp;gt;
    ///     Warn记录
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;message&quot;&amp;gt;日志信息&amp;lt;/param&amp;gt;
    public void Warn(string message)
    {
        if (KafkaLogger.IsWarnEnabled) KafkaLogger.Warn(message);
    }

    /// &amp;lt;summary&amp;gt;
    ///     Warn记录
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;message&quot;&amp;gt;日志信息&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;ex&quot;&amp;gt;异常信息&amp;lt;/param&amp;gt;
    public void Warn(string message, Exception ex)
    {
        if (KafkaLogger.IsWarnEnabled) KafkaLogger.Warn(message, ex);
    }

    #endregion Methods
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;修改Log4Net.Config，定义Kafka的Topic以及Brokers&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;    &amp;lt;appender name=&quot;KafkaAppender&quot; type=&quot;MasterChief.DotNet.Core.KafkaLog.KafkaAppender, MasterChief.DotNet.Core.KafkaLog&quot;&amp;gt;
        &amp;lt;param name=&quot;Topic&quot; value=&quot;beats&quot; /&amp;gt;
        &amp;lt;param name=&quot;Brokers&quot; value=&quot;http://localhost:9092&quot; /&amp;gt;
        &amp;lt;layout type=&quot;log4net.Layout.PatternLayout&quot;&amp;gt;
            &amp;lt;conversionPattern value=&quot;发生时间：%date %newline事件级别：%-5level %newline事件来源：%logger%newline日志内容：%message%newline&quot; /&amp;gt;
        &amp;lt;/layout&amp;gt;
    &amp;lt;/appender&amp;gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
</description>
<pubDate>Thu, 11 Apr 2019 16:21:00 +0000</pubDate>
<dc:creator>MeetYan</dc:creator>
<og:description>背景 1. 基于之前 '基于Log4Net本地日志服务简单实现' 实现本地日志服务，但是随着项目开发演进，本地日志服务满足不了需求，譬如在预发布环境或者生产环境，不可能让开发人员登录查看本地日志文件分</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/MeetYan/p/10693545.html</dc:identifier>
</item>
<item>
<title>图解简单C程序的运行时结构 - 了不起的厂长</title>
<link>http://www.cnblogs.com/enochzzg/p/10693530.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/enochzzg/p/10693530.html</guid>
<description>&lt;p&gt;程序在内存中的存储分为三个区域，分别是动态数据区、静态数据区和代码区。函数存储在代码区，全局变量以及静态变量存储在静态数据区，而在程序执行的时候才会在动态数据区产生数据。程序执行的本质就是代码区的指令不断执行，驱使动态数据区和静态数据区产生数据变化。&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/13711841-c24671040d941697.jpg&quot; alt=&quot;图片发自简书App&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码区与动态数据区由三个寄存器控制，分别是eip、ebp和esp。eip指向代码区下一个要执行的指令，ebp与esp分别指向动态数据区的栈底和栈顶。初始情况下eip默认指向main函数的第一条指令，esp、ebp指向的位置由程序加载时内核的设置决定。&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/13711841-faf83181c96ac4f5.jpg&quot; alt=&quot;图片发自简书App&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们看一下这段代码如何执行的，在执行第一条指令时，考虑到函数调用的问题，ebp会先把当前指向的地址记录到栈中，方便以后返回来继续执行。把地址压进栈时，esp就会自动往栈顶方向移动。说到这里，为避免混淆先科普一下什么是栈顶和栈底，栈只允许在一端做插入和删除操作，这一端就叫栈顶，而另一端叫做栈底，图中下方叫栈顶，上方叫栈底。esp永远在栈顶，也就是图的最下方。&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/13711841-f03b140e2a1301b4.jpg&quot; alt=&quot;图片发自简书App&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于esp指向的地址已经被记录，那么它就被空闲出来了。现在我们开始构建main函数的栈，空闲的esp帮忙看着main函数的栈底。这个时候esp与ebp是重叠的。&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/13711841-e83b5159644af615.jpg&quot; alt=&quot;图片发自简书App&quot;/&gt;&lt;/p&gt;
&lt;p&gt;eip继续指向下一条指令，到了局部变量i的初始化，这里将i赋值为4，就将i的初始值压到栈中，esp继续往栈顶移动。下一条指令与本条相同，将局部变量j也压入栈中，如图所示。&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/13711841-ef7c1fea34aefd80.jpg&quot; alt=&quot;图片发自简书App&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来调用了fun函数，虽然fun函数是独立的函数，但是由于是在main函数中调用的，所以依然将数据压至main函数的栈中。fun函数的传入参数为i、j，但是入栈的顺序正好相反，b先入栈，然后a被压入栈中，如图所示。&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/13711841-d8d754846b2cb81f.jpg&quot; alt=&quot;图片发自简书App&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来要跳转到fun函数了，在跳转之前，我们要先给fun函数的返回值留个位置，因为要赋值给局部变量m的。然后再将fun函数的返回地址压入栈中，方便执行完fun函数后能继续往下执行。最后再把ebp当前的地址值压入栈中，此时ebp指向的是main函数的栈底（如果这里不做保存，fun函数执行完ebp就回不去了）。&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/13711841-458d4d13513dba5d.jpg&quot; alt=&quot;图片发自简书App&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来就正式进入了fun函数，像第一次保存完地址值那样，ebp又被闲置了，所以让ebp守住fun函数的栈底。而局部变量b与c的赋值就不再多说，与main函数的执行过程相同，当走到了return时，将计算出的结果赋值写入到刚空出的返回值那里。&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/13711841-f6e993a0475a0ed1.jpg&quot; alt=&quot;图片发自简书App&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时的fun函数就执行完毕了，我们要恢复main函数调用fun函数的现场，继续往下执行，要想往下执行，必须将ebp回到main函数的栈底，并且找到fun函数返回的位置，然后跳转到那里。很简单，由于刚才保存了ebp的地址值，所以将地址值赋值给ebp，ebp就指向了main函数的栈底。&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/13711841-edfb59258ebe0543.jpg&quot; alt=&quot;图片发自简书App&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ebp的地址值出栈后，esp就指向了fun函数的返回地址，通过执行ret指令，把该地址值传给eip，使eip指向fun函数执行后的返回地址。&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/13711841-5147f4bbcebdb765.jpg&quot; alt=&quot;图片发自简书App&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样就恢复了现场，然后把fun函数的返回值传递给m，此时局部变量b、a和返回值已经没有价值了，把它们清出栈，现在就剩下干干净净的栈内容了。&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/13711841-2c3ad76a5708fa9d.jpg&quot; alt=&quot;图片发自简书App&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在执行最后一步，main函数就结束了，此时局部变量i、j也没有任何作用，做清栈操作，清理出干净的栈空间。&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/13711841-b5d0155312ffafe7.jpg&quot; alt=&quot;图片发自简书App&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上便是一个简单C程序的运行时结构。本文总结于新设计团队的《编译系统透视：图解编译原理》，图侵删。&lt;/p&gt;
</description>
<pubDate>Thu, 11 Apr 2019 16:15:00 +0000</pubDate>
<dc:creator>了不起的厂长</dc:creator>
<og:description>程序在内存中的存储分为三个区域，分别是动态数据区、静态数据区和代码区。函数存储在代码区，全局变量以及静态变量存储在静态数据区，而在程序执行的时候才会在动态数据区产生数据。程序执行的本质就是代码区的指令</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/enochzzg/p/10693530.html</dc:identifier>
</item>
<item>
<title>5分钟带你读懂事务隔离性与隔离级别 - Coder编程</title>
<link>http://www.cnblogs.com/coder-programming/p/10693473.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/coder-programming/p/10693473.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;我们在上一章节中介绍过数据库的&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIwMTg3NzYyOA==&amp;amp;mid=2247483722&amp;amp;idx=1&amp;amp;sn=e8bc8bd82c559e0cfe7f35cf46100af3&amp;amp;chksm=96e67059a191f94fe8948e5b5e4ef177b77fa7707d86d945b153f67e7f2e76b83ed0c768ef27&amp;amp;token=1701970188&amp;amp;lang=zh_CN#rd&quot;&gt;带你了解数据库中事务的ACID特性&lt;/a&gt;的相关用法。本章节主要来介绍下数据库中一个非常重要的知识点&lt;code&gt;事务的隔离级别&lt;/code&gt;。如有错误还请大家及时指出~&lt;/p&gt;
&lt;p&gt;问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;事务的隔离级别有哪些？&lt;/li&gt;
&lt;li&gt;如果并发事务没有进行隔离，会出现什么问题？&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;以下都是采用mysql数据库&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在多个事务并发做数据库操作的时候，如果没有有效的避免机制，就会出现种种问题。大体上有以下问题：&lt;/p&gt;
&lt;h2 id=&quot;一引发的问题&quot;&gt;一、引发的问题&lt;/h2&gt;
&lt;p&gt;在并发事务没有进行隔离的情况下，会发生如下问题。&lt;/p&gt;
&lt;h3 id=&quot;问题一脏读&quot;&gt;问题一：脏读&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;脏读&lt;/code&gt;指一个事务读取了另外一个事务未提交的数据。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;具体看后文案例介绍&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;问题二不可重复读&quot;&gt;问题二：不可重复读&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;不可重复读&lt;/code&gt;指在一个事务内读取表中的某一行数据，多次读取结果不同。&lt;br/&gt;不可重复读和脏读的区别是，脏读是读取前一事务未提交的脏数据，不可重复读是重新读取了前一事务已提交的数据。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;具体看后文案例介绍&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;问题三幻读虚读&quot;&gt;问题三：幻读(虚读)&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;幻读(虚读)&lt;/code&gt;指在一个事务内读取到了别的事务插入的数据，导致前后读取不一致。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;具体看后文案例介绍&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;二概念&quot;&gt;二、概念&lt;/h2&gt;
&lt;h3 id=&quot;事务的隔离级别分为&quot;&gt;2.1 事务的隔离级别分为：&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;Read uncommitted(读未提交)&lt;/li&gt;
&lt;li&gt;Read Committed(读已提交)&lt;/li&gt;
&lt;li&gt;Repeatable Reads(可重复读)&lt;/li&gt;
&lt;li&gt;Serializable(串行化)&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;read-uncommitted&quot;&gt;Read uncommitted&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;读未提交&lt;/code&gt;：隔离级别最低的一种事务级别。在这种隔离级别下，会引发脏读、不可重复读和幻读。&lt;/p&gt;
&lt;h4 id=&quot;read-committed&quot;&gt;Read Committed&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;读已提交&lt;/code&gt;读到的都是别人提交后的值。这种隔离级别下，会引发不可重复读和幻读，但避免了脏读。&lt;/p&gt;
&lt;h4 id=&quot;repeatable-reads&quot;&gt;Repeatable Reads&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;可重复读&lt;/code&gt;这种隔离级别下，会引发幻读，但避免了脏读、不可重复读。&lt;/p&gt;
&lt;h4 id=&quot;serializable&quot;&gt;Serializable&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;串行化&lt;/code&gt;是最严格的隔离级别。在Serializable隔离级别下，所有事务按照次序依次执行。脏读、不可重复读、幻读都不会出现。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190411212953426.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2hhZWxfSE0=,size_16,color_FFFFFF,t_70&quot; alt=&quot;隔离级别&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;三操作&quot;&gt;三、操作&lt;/h2&gt;
&lt;h3 id=&quot;查看事务隔离级别&quot;&gt;3.1 查看事务隔离级别&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;SHOW VARIABLES LIKE 'tx_isolation';&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;查看全局的事务隔离级别&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SHOW GLOBAL VARIABLES LIKE 'tx_isolation';&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;使用系统变量查询&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SELECT @@global.tx_isolation;&lt;/code&gt;&lt;br/&gt;&lt;code&gt;SELECT @@session.tx_isolation;&lt;/code&gt;&lt;br/&gt;&lt;code&gt;SELECT @@tx_isolation;&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;设置mysql的事务隔离级别&quot;&gt;3.2 设置MysQL的事务隔离级别&lt;/h3&gt;
&lt;h4 id=&quot;语法&quot;&gt;语法&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;SET [GLOBAL | SESSION] TRANSACTION ISOLATION LEVEL
  {
       REPEATABLE READ
     | READ COMMITTED
     | READ UNCOMMITTED
     | SERIALIZABLE
   }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;GLOBAL&lt;/code&gt;：设置全局的事务隔离级别&lt;br/&gt;&lt;code&gt;SESSION&lt;/code&gt;：设置当前session的事务隔离级别，如果语句没有指定GLOBAL或SESSION，默认值为SESSION&lt;/p&gt;
&lt;h4 id=&quot;使用系统变量设置事务隔离级别&quot;&gt;使用系统变量设置事务隔离级别&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;SET GLOBAL tx_isolation='REPEATABLE-READ';&lt;/code&gt;&lt;br/&gt;&lt;code&gt;SET SESSION tx_isolation='SERIALIZABLE';&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;四案例分析&quot;&gt;四、案例分析&lt;/h2&gt;
&lt;p&gt;下面实际操作中使用到的一些并发控制语句，可看上面的&lt;strong&gt;操作&lt;/strong&gt;介绍&lt;/p&gt;
&lt;p&gt;作为演示：product表&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;xiaomi&lt;/td&gt;
&lt;td&gt;1999&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;带着上面的我们来看一下，事务在没有隔离性的情况下，会引发哪些问题？&lt;/p&gt;
&lt;p&gt;同时打开两个窗口模拟2个用户并发访问数据库&lt;/p&gt;
&lt;h3 id=&quot;事务隔离级别设置为read-uncommitted&quot;&gt;4.1 事务隔离级别设置为read uncommitted&lt;/h3&gt;
&lt;p&gt;查询事务隔离级别&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SELECT @@tx_isolation;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;设置隔离级别为&lt;strong&gt;未提交读&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注意：需要同时修改两个窗口的事务隔离级别&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以下我们以两位用户抢小米手机为例&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;7&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;T1&lt;/td&gt;
&lt;td&gt;start transaction；&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;T2&lt;/td&gt;
&lt;td&gt;select p.productName,p.productCount from product p where p.productId=1;(productCount =100)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;T3&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;start transaction；&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;T4&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;select p.productName,p.productCount from product p where p.productId=1;(productCount =100)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;T5&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;update product set productCount = 99 where productId = 1;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;T6&lt;/td&gt;
&lt;td&gt;select p.productName,p.productCount from product p where p.productId=1;(productCount =99)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;T7&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;ROLLBACK;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;T8&lt;/td&gt;
&lt;td&gt;select p.productName,p.productCount from product p where p.productId=1;(productCount =100)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;hr/&gt;&lt;p&gt;T1—— A用户开启事务，start transaction；&lt;br/&gt;T2—— A用户查询当前小米手机剩余数量，select p.productName,p.productCount from product p where p.productId=1;此时数量显示为100。&lt;br/&gt;T3——B用户开启事务，start transaction；&lt;br/&gt;T4——B用户查询当前小米手机剩余数量，select p.productName,p.productCount from product p where p.productId=1;此时数量显示为100。&lt;br/&gt;T5—— B用户购买了一台小米手机，update product set productCount = 99 where productId = 1; 此时只修改数据并未提交事务。&lt;br/&gt;T6—— A用户刷新页面，select p.productName,p.productCount from product p where p.productId=1;此时数量显示为99。&lt;br/&gt;T7—— B用户购买失败，回滚事务。&lt;br/&gt;T8—— A用户查询当前小米手机剩余数量，select p.productName,p.productCount from product p where p.productId=1;此时数量显示为100。&lt;/p&gt;
&lt;hr/&gt;&lt;h4 id=&quot;小结&quot;&gt;小结：&lt;/h4&gt;
&lt;p&gt;事务A读取了未提交的数据，事务B的回滚，导致了事务A的数据不一致，导致了事务A的&lt;code&gt;脏读&lt;/code&gt; ！&lt;/p&gt;
&lt;h3 id=&quot;事务隔离级别设置为read-committed&quot;&gt;4.2 事务隔离级别设置为Read Committed&lt;/h3&gt;
&lt;p&gt;查询事务隔离级别&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SELECT @@tx_isolation;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更改数据库隔离级别，设置隔离级别为&lt;strong&gt;提交读&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SET SESSION  TRANSACTION ISOLATION LEVEL READ COMMITTED;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注意：需要同时修改两个窗口的事务隔离级别&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;7&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;T1&lt;/td&gt;
&lt;td&gt;start transaction；&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;T2&lt;/td&gt;
&lt;td&gt;select p.productName,p.productCount from product p where p.productId=1;(productCount =100)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;T3&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;start transaction；&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;T4&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;select p.productName,p.productCount from product p where p.productId=1;(productCount =100)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;T5&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;update product set productCount = 99 where productId = 1;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;T7&lt;/td&gt;
&lt;td&gt;select p.productName,p.productCount from product p where p.productId=1;(productCount =100)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;T6&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;commit;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;T8&lt;/td&gt;
&lt;td&gt;select p.productName,p.productCount from product p where p.productId=1;(productCount =99)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;hr/&gt;&lt;p&gt;这里就不再对流程做过多赘述。&lt;/p&gt;
&lt;h5 id=&quot;小结-1&quot;&gt;小结：&lt;/h5&gt;
&lt;p&gt;可以看到避免了&lt;code&gt;脏读&lt;/code&gt;现象，但是却出现了，一个事务还没有结束，就发生了不可重复读问题，即事务A来说 productCount从 100-&amp;gt;100-&amp;gt;99。但这个过程中事务并未提交结束。&lt;/p&gt;
&lt;h3 id=&quot;事务隔离级别设置为repeatable-readmysql默认级别&quot;&gt;4.3 事务隔离级别设置为Repeatable Read（mysql默认级别）&lt;/h3&gt;
&lt;p&gt;查询事务隔离级别&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SELECT @@tx_isolation;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更改数据库隔离级别，设置隔离级别为&lt;strong&gt;可重复读&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SET SESSION  TRANSACTION ISOLATION LEVEL REPEATABLE READ;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注意：需要同时修改两个窗口的事务隔离级别&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;7&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;T1&lt;/td&gt;
&lt;td&gt;start transaction；&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;T2&lt;/td&gt;
&lt;td&gt;select p.productName,p.productCount from product p where p.productId=1;(productCount =100)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;T3&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;start transaction；&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;T4&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;select p.productName,p.productCount from product p where p.productId=1;(productCount =100)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;T5&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;update product set productCount = 99 where productId = 1;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;T7&lt;/td&gt;
&lt;td&gt;select p.productName,p.productCount from product p where p.productId=1;(productCount =100)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;T6&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;commit;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;T8&lt;/td&gt;
&lt;td&gt;select p.productName,p.productCount from product p where p.productId=1;(productCount =100)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;hr/&gt;&lt;p&gt;这里就不再对流程做过多赘述。&lt;/p&gt;
&lt;h5 id=&quot;小结-2&quot;&gt;小结：&lt;/h5&gt;
&lt;p&gt;可以看到&lt;code&gt;可重复读&lt;/code&gt;隔离级别避免了&lt;code&gt;脏读&lt;/code&gt;，&lt;code&gt;不可重复读&lt;/code&gt;的问题，但是出现了&lt;code&gt;幻读&lt;/code&gt;现象。事务A查询到的小米数量等于100，但是事务B修改了数量为99，但是事务A读取到的值还是100。当事务A去减1等于99时，是错误的，此时应该是99-1=98才对。接下来我们再提高一个事务隔离级别。&lt;/p&gt;
&lt;h3 id=&quot;事务隔离级别设置为serializable&quot;&gt;4.4 事务隔离级别设置为Serializable&lt;/h3&gt;
&lt;p&gt;查询事务隔离级别&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SELECT @@tx_isolation;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更改数据库隔离级别，设置隔离级别为&lt;strong&gt;串行化&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SET SESSION  TRANSACTION ISOLATION LEVEL REPEATABLE READ;&lt;/code&gt;
&lt;/pre&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;---&lt;/td&gt;
&lt;td&gt;---&lt;/td&gt;
&lt;td&gt;---&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;T1&lt;/td&gt;
&lt;td&gt;start transaction；&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;T2&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;start transaction；&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;T2&lt;/td&gt;
&lt;td&gt;select p.productName,p.productCount from product p where p.productId=1;(productCount =100);&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;T4&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;update product set productCount = 99 where productId = 1;（等待中..）&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;hr/&gt;&lt;p&gt;这里就不再对流程做过多赘述。&lt;/p&gt;
&lt;h5 id=&quot;小结-3&quot;&gt;小结：&lt;/h5&gt;
&lt;p&gt;在我们Serializable隔离级别中，我们可以看到事务B去做修改动作时卡主了，不能向下执行。这是因为：给事务A的select操作上了锁，所以事务B去修改值的话，就会被卡主。只有当事务A操作执行完毕，才会执行事务B的操作。这样就避免了上述三个问题了。&lt;/p&gt;
&lt;h2 id=&quot;问题本身&quot;&gt;问题本身&lt;/h2&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;回到问题的本身，其实我们并不需要将事务提到这么高。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;问题的本身就是，当我们读完了的时候，就要在上面加锁。我们不希望别人能够去读它。因为别人读到了count,就会修改count的值，并写进去。所以我们在select 操作的时候，加上for update。这时候就会把这行操作给锁掉了。那么另外一个人也进行相同的操作，也表示select 出来的count需要进行update，需要锁住。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;select p.productName,p.productCount from product p where p.productId=1 for update;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;PS: 在实际开发过程中，这样的加锁行为，是非常的耗系统性能的。下一章节我们将来介绍&lt;code&gt;悲观锁与乐观锁&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;文末&quot;&gt;文末&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;本章节主要介绍了数据库中事务的ADID特性中的&lt;code&gt;隔离性&lt;/code&gt;，在没有隔离的情况下会发生什么问题，相信大家通过本章，对数据库事务中的&lt;code&gt;隔离性&lt;/code&gt;有了一定的了解，下篇文章我们将介绍数据库中的&lt;code&gt;悲观锁与乐观锁&lt;/code&gt;。&lt;br/&gt;欢迎关注公众号：&lt;strong&gt;Coder编程&lt;/strong&gt;&lt;br/&gt;获取最新原创技术文章和相关免费学习资料，随时随地学习技术知识！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190411234814936.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2hhZWxfSE0=,size_16,color_FFFFFF,t_70&quot; alt=&quot;微信公众号&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;推荐阅读&quot;&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIwMTg3NzYyOA==&amp;amp;mid=2247483713&amp;amp;idx=1&amp;amp;sn=d61ad0aed42dc36d64d17732db352288&amp;amp;chksm=96e67052a191f9445bbe3d5825ce547ad3171c3874b571a93b97977d0668413e37a164c3e0bc&amp;amp;token=1144933717&amp;amp;lang=zh_CN#rd&quot;&gt;带你了解数据库中JOIN的用法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIwMTg3NzYyOA==&amp;amp;mid=2247483717&amp;amp;idx=1&amp;amp;sn=157a8a021c29043a10480d0294b39ca0&amp;amp;chksm=96e67056a191f940668812ebb092fe9984b22eb619a18339cc052e1051c659a7e9d907c48814&amp;amp;token=1144933717&amp;amp;lang=zh_CN#rd&quot;&gt;带你了解数据库中group by的用法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIwMTg3NzYyOA==&amp;amp;mid=2247483722&amp;amp;idx=1&amp;amp;sn=e8bc8bd82c559e0cfe7f35cf46100af3&amp;amp;chksm=96e67059a191f94fe8948e5b5e4ef177b77fa7707d86d945b153f67e7f2e76b83ed0c768ef27&amp;amp;token=1701970188&amp;amp;lang=zh_CN#rd&quot;&gt;带你了解数据库中事务的ACID特性&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/CoderMerlin/coder-programming&quot;&gt;Github个人主页目录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/573059382/coder-programming&quot;&gt;Gitee个人主页目录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;欢迎大家关注并Star~&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 11 Apr 2019 15:53:00 +0000</pubDate>
<dc:creator>Coder编程</dc:creator>
<og:description>前言 我们在上一章节中介绍过数据库的 '带你了解数据库中事务的ACID特性 ' 的相关用法。本章节主要来介绍下数据库中一个非常重要的知识点 。如有错误还请大家及时指出~ 问题： 事务的隔离级别有哪些？</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/coder-programming/p/10693473.html</dc:identifier>
</item>
<item>
<title>WebRTC 泄漏真实 IP 地址 - 陈旭华</title>
<link>http://www.cnblogs.com/chenxuhua/p/webrtc-leak-real-ip.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenxuhua/p/webrtc-leak-real-ip.html</guid>
<description>&lt;p&gt;WebRTC（网页即时通信，Web Real-Time Communication） 它允许浏览器内进行实时语音或视频对话，而无需添加额外的浏览器扩展。包括 Chrome、Firefox、Opera、Safari 均支持，并且在移动端也有支持。虽然此功能可能对某些用户有用，但它会对任何使用 VPN 的人构成威胁。&lt;strong&gt;WebRTC 漏洞的可怕之处在于，即使你用 VPN 代理上网仍然会暴露自己的真实 IP 地址。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;webrtc-漏洞原理&quot;&gt;WebRTC 漏洞原理&lt;/h2&gt;
&lt;p&gt;WebRTC 这个漏洞是在 2015 年初被发现的。通过该漏洞，网站管理员可以轻易地通过 WebRTC 看到用户的真实 IP 地址，即使用户使用 VPN 隐藏自己的 IP。 该漏洞影响支持 WebRTC 的浏览器，包括 Chrome 和 Firefox 浏览器。&lt;/p&gt;
&lt;p&gt;WebRTC 采用 STUN（Session Traversal Utilities for NAT）、TURN 和 ICE 等协议栈对 VoIP 网络中的防火墙或者 NAT 进行穿透。用户发送请求至服务器，STUN 服务器会返回用户所用系统的 IP 地址和局域网地址。&lt;/p&gt;
&lt;p&gt;返回的请求可以通过 JavaScript 获取，但由于这个过程是在正常的 XML/HTTP 请求过程之外进行的，所以在开发者控制台看不到。这意味着，这个漏洞的唯一要求就是浏览器要支持 WebRTC 和 JavaScript。&lt;/p&gt;
&lt;h2 id=&quot;检查你的浏览器是否暴露了-ip&quot;&gt;检查你的浏览器是否暴露了 IP&lt;/h2&gt;
&lt;p&gt;① 连接 VPN 代理&lt;/p&gt;
&lt;p&gt;② 访问 &lt;a href=&quot;https://ip.voidsec.com/&quot; class=&quot;uri&quot;&gt;https://ip.voidsec.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/790395/201904/790395-20190411233950590-8703927.png&quot; alt=&quot;voidsec&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果在 WebRTC 的部分看到了公网 IP 地址，则说明你已经暴露了身份信息。&lt;/p&gt;
&lt;h2 id=&quot;webrtc-漏洞防范措施&quot;&gt;WebRTC 漏洞防范措施&lt;/h2&gt;
&lt;p&gt;对于用户来说，如果不想自己的真实IP地址泄漏，可以通过禁用 WebRTC 来防止真实 IP 地址泄漏。&lt;/p&gt;
&lt;h3 id=&quot;chrome-安装扩展禁用&quot;&gt;Chrome 安装扩展禁用&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;安装「&lt;strong&gt;&lt;a href=&quot;https://chrome.google.com/webstore/detail/eiadekoaikejlgdbkbdfeijglgfdalml&quot;&gt;WebRTC Leak Prevent&lt;/a&gt;&lt;/strong&gt;」扩展&lt;/li&gt;
&lt;li&gt;将「IP handling policy」选项设置为「Disable non-proxied UDP (force proxy)」&lt;/li&gt;
&lt;li&gt;点击「Apply Settings」以应用&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;firefox-修改配置禁用&quot;&gt;Firefox 修改配置禁用&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;在浏览器地址栏输入「&lt;a href=&quot;about:config」回车&quot; class=&quot;uri&quot;&gt;about:config」回车&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;搜索「media.peerconnection.enabled」字段&lt;/li&gt;
&lt;li&gt;双击「media.peerconnection.enabled」首选项，使其值变为「false」&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;更多隐私检测&quot;&gt;更多隐私检测&lt;/h2&gt;
</description>
<pubDate>Thu, 11 Apr 2019 15:44:00 +0000</pubDate>
<dc:creator>陈旭华</dc:creator>
<og:description>WebRTC（网页即时通信，Web Real Time Communication） 它允许浏览器内进行实时语音或视频对话，而无需添加额外的浏览器扩展。包括 Chrome、Firefox、Opera、</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenxuhua/p/webrtc-leak-real-ip.html</dc:identifier>
</item>
<item>
<title>【JVM虚拟机】(7)---深入理解Class中-属性集合 - 雨点的名字</title>
<link>http://www.cnblogs.com/qdhxhz/p/10693324.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qdhxhz/p/10693324.html</guid>
<description>&lt;center&gt;

&lt;/center&gt;
&lt;p&gt;之前有关class文件已经写了两篇博客：&lt;/p&gt;
&lt;p&gt;1、&lt;a href=&quot;https://www.cnblogs.com/qdhxhz/p/10646088.html&quot;&gt;【JVM虚拟机】(5)---深入理解JVM-Class中常量池&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2、&lt;a href=&quot;https://www.cnblogs.com/qdhxhz/p/10676337.html&quot;&gt;【JVM虚拟机】(6)---深入理解Class中访问标志、类索引、父类索引、接口索引&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;那么这篇博客主要讲有关 &lt;strong&gt;字段表集合&lt;/strong&gt; 相关的理解和代码示例。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;字段表&lt;/code&gt;：用于&lt;strong&gt;描述接口或者类中声明的变量&lt;/strong&gt;,字段包括&lt;code&gt;类级(static修饰)变量&lt;/code&gt;以及&lt;code&gt;实例级变量&lt;/code&gt;，但是不包括局部变量(方法内部变量）。&lt;/p&gt;
&lt;h2 id=&quot;一概念&quot;&gt;&lt;span&gt;一、概念&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;字段表集合：包括了&lt;code&gt;字段计数器&lt;/code&gt;和&lt;code&gt;字段数据区&lt;/code&gt;如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201904/1090617-20190411231402817-449455269.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Field_info: 依次包含&lt;code&gt;访问标志&lt;/code&gt;（access_flags）、&lt;code&gt;名称索引&lt;/code&gt;（name_index）、&lt;code&gt;描述符索引&lt;/code&gt;（descriptor_index）、&lt;code&gt;属性表集合&lt;/code&gt;（attributes）几项。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201904/1090617-20190411231413546-2127494420.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;字段修饰符&lt;/code&gt;放在access_flags项目中，它与类中的access_flags项目是非常相似的，都是一个u2的数据类型．&lt;/p&gt;
&lt;p&gt;(&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201904/1090617-20190411231458127-370081870.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;跟随access_flags标志的是两项索引值：&lt;code&gt;name_index&lt;/code&gt;和&lt;code&gt;descriptor_index&lt;/code&gt;，它们都是对常量池的引用，分别代表着字段的&lt;code&gt;简单名称&lt;/code&gt;以及&lt;code&gt;字段方法和方法的描述符&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;描述符的作用&lt;/code&gt;：是用来描述字段的数据类型，方法的参数列表（包括数量，类型以及顺序）和返回值。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;描述符规则&lt;/code&gt;: 基本数据类型以及代表无返回值的void类型都用一个大写字符来表示，而对象类型则用字符加L加对象名的全限定名来表示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201904/1090617-20190411231525191-1906804832.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;数组类型&lt;/code&gt;:每一维度将使用一个前置的＂［＂字符来描述．如一个定义为＂java.lang.Stirng[ ]＂类型的二维数组，将被记录为：＂［［Ljava/lang/Stirng＂，一个整型数组＂int［］＂将被记录为＂［I＂．&lt;/p&gt;
&lt;p&gt;&lt;code&gt;用描述符来描述方法&lt;/code&gt;: 按照先参数列表，后返回值的顺序来描述，参数列表按照参数的严格顺序放在一组小括号＂（）＂之内。&lt;/p&gt;
&lt;p&gt;字段表集合中不会列出从父类或者父接口中继承而来的字段。&lt;/p&gt;
&lt;h2 id=&quot;二属性表集合-----静态field字段的初始化&quot;&gt;&lt;span&gt;二、属性表集合-----静态field字段的初始化&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;在定义&lt;strong&gt;&lt;code&gt;属性字段&lt;/code&gt;&lt;/strong&gt;的过程中，我们有时候会很自然地对 &lt;strong&gt;&lt;code&gt;属性字段&lt;/code&gt;&lt;/strong&gt; 直接赋值，如下所示：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static final int MAX=100;  
public  int count=0;  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于虚拟机而言，上述的两个&lt;strong&gt;&lt;code&gt;属性字段&lt;/code&gt;&lt;/strong&gt;赋值的时机是不同的：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;对于非静态（即无static修饰）的&lt;strong&gt;属性字段&lt;/strong&gt;的赋值将会出现在实例构造方法&lt;strong&gt;()&lt;/strong&gt;中&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;对于静态的&lt;strong&gt;属性字段&lt;/strong&gt;，有两个选择：1、在静态构造方法&lt;strong&gt;()&lt;/strong&gt;中进行；2 、使用&lt;strong&gt;ConstantValue&lt;/strong&gt;属性进行赋值。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Sun javac编译器对于 &lt;strong&gt;静态属性字段&lt;/strong&gt; 的初始化赋值策略&lt;/p&gt;
&lt;p&gt;1）、如果使用&lt;strong&gt;final&lt;/strong&gt;和&lt;strong&gt;static&lt;/strong&gt;同时修饰一个&lt;strong&gt;属性字段&lt;/strong&gt;，并且这个字段是基本类型或者&lt;strong&gt;String&lt;/strong&gt;类型的，那么编译器在编译这个字段的时候，会在对应的&lt;strong&gt;field_info&lt;/strong&gt;结构体中&lt;br/&gt;增加一个&lt;code&gt;ConstantValue&lt;/code&gt;类型的结构体，在赋值的时候使用这个&lt;code&gt;ConstantValue&lt;/code&gt;进行赋值。&lt;/p&gt;
&lt;p&gt;2）、如果该&lt;strong&gt;属性字段&lt;/strong&gt;并没有被&lt;strong&gt;final&lt;/strong&gt;修饰，或者不是基本类型或者&lt;strong&gt;String&lt;/strong&gt;类型，那么将在类构造方法&lt;strong&gt;()&lt;/strong&gt;中赋值。&lt;/p&gt;
&lt;p&gt;对于上述的&lt;strong&gt;public static final init MAX=100;&lt;/strong&gt; javac编译器在编译此&lt;strong&gt;属性字段&lt;/strong&gt;构建&lt;strong&gt;field_info&lt;/strong&gt;结构体时，除了访问标志、名称索引、描述符索引外，会增加一个&lt;strong&gt;&lt;code&gt;ConstantValue&lt;/code&gt;&lt;/strong&gt;类型的属性表。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201904/1090617-20190411231712680-1015512537.jpg&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;三示例&quot;&gt;&lt;span&gt;三、示例&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;1）先来个网上的例子，图片解释很好&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Simple {  
    private  transient static final String str =&quot;This is a test&quot;;  
}  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201904/1090617-20190411231724787-940812686.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;说明&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;1、&lt;strong&gt;字段计数器&lt;/strong&gt;中的值为&lt;strong&gt;0x0001&lt;/strong&gt;,表示这个类就定义了一个&lt;strong&gt;属性字段&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2、 &lt;strong&gt;字段的访问标志&lt;/strong&gt;是&lt;strong&gt;0x009A&lt;/strong&gt;，这个字段的标志符有：&lt;strong&gt;ACC_TRANSIENT、ACC_FINAL、ACC_STATIC、ACC_PRIVATE;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3、 &lt;strong&gt;名称索引&lt;/strong&gt;中的值为&lt;strong&gt;0x0005&lt;/strong&gt;,指向了常量池中的第&lt;strong&gt;5&lt;/strong&gt;项，为“&lt;strong&gt;str&lt;/strong&gt;”,表明这个&lt;strong&gt;属性字段&lt;/strong&gt;的名称是&lt;strong&gt;str&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;4、&lt;strong&gt;描述索引&lt;/strong&gt;中的值为&lt;strong&gt;0x0006&lt;/strong&gt;,指向了常量池中的第&lt;strong&gt;6&lt;/strong&gt;项，为&quot;&lt;strong&gt;Ljava/lang/String;&lt;/strong&gt;&quot;，表明这个&lt;strong&gt;field字段&lt;/strong&gt;的数据类型是&lt;strong&gt;java.lang.String&lt;/strong&gt;类型；&lt;/p&gt;
&lt;p&gt;5、属性表计数器&lt;strong&gt;中的值为&lt;/strong&gt;0x0001,表明&lt;strong&gt;field_info&lt;/strong&gt;还有一个属性表；&lt;/p&gt;
&lt;p&gt;6、属性表名称索引&lt;strong&gt;中的值为&lt;/strong&gt;0x0007&lt;strong&gt;,指向常量池中的第&lt;/strong&gt;7&lt;strong&gt;项，为“&lt;/strong&gt;ConstantValue”,表明这个属性表的名称是&lt;strong&gt;ConstantValue&lt;/strong&gt;，即属性表的类型是&lt;strong&gt;ConstantValue&lt;/strong&gt;类型的；&lt;/p&gt;
&lt;p&gt;7、属性长度中的值为&lt;strong&gt;0x0002&lt;/strong&gt;，因为此属性表是&lt;strong&gt;ConstantValue&lt;/strong&gt;类型，它的值固定为&lt;strong&gt;2&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;8、常量值索引 中的值为&lt;strong&gt;0x0008&lt;/strong&gt;,指向了常量池中的第&lt;strong&gt;8&lt;/strong&gt;项，为&lt;strong&gt;CONSTANT_String_info&lt;/strong&gt;类型的项，表示“&lt;strong&gt;This is a test&lt;/strong&gt;” 的常量。在对此&lt;strong&gt;field&lt;/strong&gt;赋值时，会使用此常量对&lt;strong&gt;field&lt;/strong&gt;赋值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2)自测&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.jincou.demo.domain;

public class XiaoXiao {
    public String name = &quot;小小&quot;;
    private Integer age = 3;
    public static final String sex = &quot;女&quot;;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来看16进制文件和class反编译文件&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//1、这里直接截取到访问标志服后的16进制数据,从|开始代表字段集合相关16进制
                                     00
2100 0600 0700 00|00 0300 0100 0800 0900
0000 0200 0a00 0b00 0000 1900 0c00 0900
0100 0d00 0000 0200 0e00 0100 0100 0f00
1000 0100 1100 0000 3300 0200 0100 0000
132a b700 012a 1202 b500 032a 06b8 0004
b500 05b1 0000 0001 0012 0000 000e 0003
0000 0003 0004 0004 000a 0005 0001 0013
0000 0002 0014 
                                       
//2、查看 XiaoXiao.class反编译数据信息
Constant pool:
   #1 = Methodref          #7.#21         // java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V
   #2 = String             #22            // 小小
   #3 = Fieldref           #6.#23         // com/jincou/demo/domain/XiaoXiao.name:Ljava/lang/String;
   #4 = Methodref          #24.#25        // java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
   #5 = Fieldref           #6.#26         // com/jincou/demo/domain/XiaoXiao.age:Ljava/lang/Integer;
   #6 = Class              #27            // com/jincou/demo/domain/XiaoXiao
   #7 = Class              #28            // java/lang/Object
   #8 = Utf8               name
   #9 = Utf8               Ljava/lang/String;
  #10 = Utf8               age
  #11 = Utf8               Ljava/lang/Integer;
  #12 = Utf8               sex
  #13 = Utf8               ConstantValue
  #14 = String             #29            // 女
  #15 = Utf8               &amp;lt;init&amp;gt;
  #16 = Utf8               ()V
  #17 = Utf8               Code
  #18 = Utf8               LineNumberTable
  #19 = Utf8               SourceFile
  #20 = Utf8               XiaoXiao.java
  #21 = NameAndType        #15:#16        // &quot;&amp;lt;init&amp;gt;&quot;:()V
  #22 = Utf8               小小
  #23 = NameAndType        #8:#9          // name:Ljava/lang/String;
  #24 = Class              #30            // java/lang/Integer
  #25 = NameAndType        #31:#32        // valueOf:(I)Ljava/lang/Integer;
  #26 = NameAndType        #10:#11        // age:Ljava/lang/Integer;
  #27 = Utf8               com/jincou/demo/domain/XiaoXiao
  #28 = Utf8               java/lang/Object
  #29 = Utf8               女
  #30 = Utf8               java/lang/Integer
  #31 = Utf8               valueOf
  #32 = Utf8               (I)Ljava/lang/Integer;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来我们来分析从00 03开始。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//00 03 代表示成员变量的个数，此处为3个。
1）00 01 结合上表代表第一个变量的修饰符为 public
2）00 08 找常量池第8个 name
3）00 09 找常量池第9个 String
4）00 00 用来描述该变量的属性，因为这个变量没有附加属性，所以attributes_count为0，attribute_info为空。
 //接下来直接分析第三个
1）00 19 结合上表 ACC_PUBLIC+ACC_STATIC+ACC_FINAL 刚好19
2）00 0c 找常量池第12个 sex
3）00 09 找常量池第9个 String
4）00 01 代表这个变量有一个附加属性
5）00 0d 找常量池第13个 ConstantValue
6）00 0000 02 属性长度
7）00 0e 找常量池第14个 女&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过这个例子我们注意到：&lt;br/&gt;1）、&lt;code&gt;name = &quot;小小&quot;&lt;/code&gt;中的&lt;code&gt;小小&lt;/code&gt;并没有出现，这就是上一个例子所说的,因为它不是静态变量所以不属于类，而是属于对象,所以在创建对象的时候，才会出现。&lt;br/&gt;2）、sex = &quot;女&quot; 中的&lt;code&gt;女&lt;/code&gt;出现了，因为它是静态属性字段，属于类级别的所以出现。&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;&lt;span&gt;参考&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;1、深入了解java虚拟机第2版第六章&lt;/p&gt;
&lt;p&gt;2、&lt;a href=&quot;https://blog.51cto.com/1459294/1932331&quot;&gt;深入理解JVM-Class文件属性集合&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;只要自己变优秀了，其他的事情才会跟着好起来（少将5）&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 11 Apr 2019 15:31:00 +0000</pubDate>
<dc:creator>雨点的名字</dc:creator>
<og:description>【JVM虚拟机】(7) 深入理解Class中 属性集合 之前有关class文件已经写了两篇博客： 1、 '【JVM虚拟机】(5) 深入理解JVM Class中常量池' 2、 '【JVM虚拟机】(6)</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qdhxhz/p/10693324.html</dc:identifier>
</item>
<item>
<title>校招需要看的书 巩固的知识 - Draymonder</title>
<link>http://www.cnblogs.com/Draymonder/p/10693342.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Draymonder/p/10693342.html</guid>
<description>&lt;h2 id=&quot;感想&quot;&gt;感想&lt;/h2&gt;
&lt;p&gt;听到了很多面试官说：你是科班的，那么&lt;strong&gt;操作系统&lt;/strong&gt;，&lt;strong&gt;计算机网络&lt;/strong&gt;，&lt;strong&gt;操作系统&lt;/strong&gt;，&lt;strong&gt;数据库&lt;/strong&gt; 应该没什么问题。&lt;br/&gt;听完这句话，我知道我大一大二多么愚昧，以为都是水水，考个80 90分就行的想法很蠢蛋..&lt;/p&gt;
&lt;h2 id=&quot;算法与数据结构&quot;&gt;算法与数据结构&lt;/h2&gt;
&lt;p&gt;剑指offer&lt;br/&gt;leetcode&lt;/p&gt;
&lt;h2 id=&quot;操作系统&quot;&gt;操作系统&lt;/h2&gt;
&lt;p&gt;就正常的上课用的书吧&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;知识点如下：
&lt;ul&gt;&lt;li&gt;进程和线程区别&lt;/li&gt;
&lt;li&gt;文件描述符&lt;/li&gt;
&lt;li&gt;一个文件如何组织存放到硬盘上&lt;/li&gt;
&lt;li&gt;你知道的文件系统&lt;/li&gt;
&lt;li&gt;死锁，例子，四个特征&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;还有待挖掘的很多&lt;/p&gt;
&lt;h2 id=&quot;计算机网络&quot;&gt;计算机网络&lt;/h2&gt;
&lt;p&gt;计算机网络(第6/7版) 谢希仁&lt;br/&gt;图解HTTP&lt;br/&gt;计算机网络自顶向下 （也可以，有点儿难&lt;/p&gt;
&lt;p&gt;重点还是TCP UDP IP HTTP DNS&lt;br/&gt;涉及到web的要很熟悉&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;知识点如下：
&lt;ul&gt;&lt;li&gt;OSI七层模型，五层模型，TCP/IP协议栈&lt;/li&gt;
&lt;li&gt;HTTP函数了解哪些？POST和GET的区别？&lt;/li&gt;
&lt;li&gt;传文件POST，怎么知道是不是传输完了？&lt;/li&gt;
&lt;li&gt;TCP，UDP区别&lt;/li&gt;
&lt;li&gt;请求重传机制&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;数据库&quot;&gt;数据库&lt;/h2&gt;
&lt;p&gt;高性能mysql&lt;br/&gt;redis设计与实现&lt;/p&gt;
&lt;h2 id=&quot;java&quot;&gt;Java&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;集合(看源码)&lt;/li&gt;
&lt;li&gt;网络编程&lt;/li&gt;
&lt;li&gt;并发编程(Java并发编程实战，Java并发编程的艺术)&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;笔试&quot;&gt;笔试&lt;/h2&gt;
&lt;p&gt;技术之瞳——阿里巴巴技术笔试心得&lt;/p&gt;
&lt;h2 id=&quot;项目&quot;&gt;项目&lt;/h2&gt;
&lt;p&gt;实习或者自己搞&lt;/p&gt;
</description>
<pubDate>Thu, 11 Apr 2019 15:16:00 +0000</pubDate>
<dc:creator>Draymonder</dc:creator>
<og:description>感想 听到了很多面试官说：你是科班的，那么 操作系统 ， 计算机网络 ， 操作系统 ， 数据库 应该没什么问题。 听完这句话，我知道我大一大二多么愚昧，以为都是水水，考个80 90分就行的想法很蠢蛋.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Draymonder/p/10693342.html</dc:identifier>
</item>
</channel>
</rss>