<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>如何使用24行JavaScript代码实现Redux - 小维FE</title>
<link>http://www.cnblogs.com/tangshiwei/p/11870517.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tangshiwei/p/11870517.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;作者：Yazeed Bzadough&lt;br/&gt;译者：小维FE&lt;br/&gt;原文：freecodecamp&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;为了保证文章的可读性，本文采用意译而非直译。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;90%的规约，10%的库。&lt;br/&gt;Redux是迄今为止创建的最重要的JavaScript库之一，灵感来源于以前的艺术比如&lt;a href=&quot;https://facebook.github.io/flux/&quot;&gt;Flux&lt;/a&gt;和&lt;a href=&quot;https://elm-lang.org/&quot;&gt;Elm&lt;/a&gt;，Redux通过引入一个包含三个简单要点的可伸缩体系结构，使得JavaScript函数式编程成为可能。如果你是初次接触Redux，可以考虑先阅读&lt;a href=&quot;https://redux.js.org/introduction/three-principles&quot;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;redux大多是规约&quot;&gt;1. Redux大多是规约&lt;/h2&gt;
&lt;p&gt;考虑如下这个使用了Redux架构的简单的计数器应用。如果你想跳过的话可以直接查看&lt;a href=&quot;https://github.com/yazeedb/implement-redux-counter-app&quot;&gt;Github Repo&lt;/a&gt;。&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/15/16e6f75b2466da78?w=600&amp;amp;h=278&amp;amp;f=gif&amp;amp;s=37121&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;state存储在一棵树中&quot;&gt;1.1 State存储在一棵树中&lt;/h3&gt;
&lt;p&gt;该应用程序的状态看起来如下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const initialState = { count: 0 };&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;action声明状态更改&quot;&gt;1.2 Action声明状态更改&lt;/h3&gt;
&lt;p&gt;根据Redux规约，我们不直接修改(突变)状态。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// 在Redux应用中不要做如下操作
state.count = 1;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;相反，我们创建在应用中用户可能用到的所有行为。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const actions = {
  increment: { type: 'INCREMENT' },
  decrement: { type: 'DECREMENT' }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;reducer解释行为并更新状态&quot;&gt;1.3 Reducer解释行为并更新状态&lt;/h3&gt;
&lt;p&gt;在最后一个架构部分我们叫做Reduer，其作为一个纯函数，它基于以前的状态和行为返回状态的新副本。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果&lt;code&gt;increment&lt;/code&gt;被触发，则增加&lt;code&gt;state.count&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果&lt;code&gt;decrement&lt;/code&gt;被触发，则减少&lt;code&gt;state.count&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const countReducer = (state = initialState, action) =&amp;gt; {
  switch (action.type) {
    case actions.increment.type:
      return {
        count: state.count + 1
      };

    case actions.decrement.type:
      return {
        count: state.count - 1
      };

    default:
      return state;
  }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;目前为止还没有redux&quot;&gt;1.4 目前为止还没有Redux&lt;/h3&gt;
&lt;p&gt;你注意到了吗？到目前为止我们甚至还没有接触到Redux库，我们仅仅只是创建了一些对象和函数，这就是为什么我称其为&quot;大多是规约&quot;，90%的Redux应用其实并不需要Redux。&lt;/p&gt;
&lt;h2 id=&quot;开始实现redux&quot;&gt;2. 开始实现Redux&lt;/h2&gt;
&lt;p&gt;要使用这种架构，我们必须要将它放入到一个store当中，我们将仅仅实现一个函数：&lt;code&gt;createStore&lt;/code&gt;。使用方式如下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;import { createStore } from 'redux'

const store = createStore(countReducer);

store.subscribe(() =&amp;gt; {
  console.log(store.getState());
});

store.dispatch(actions.increment);
// logs { count: 1 }

store.dispatch(actions.increment);
// logs { count: 2 }

store.dispatch(actions.decrement);
// logs { count: 1 }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面这是我们的初始化样板代码，我们需要一个监听器列表listeners和reducer提供的初始化状态。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const createStore = (yourReducer) =&amp;gt; {
    let listeners = [];
    let currentState = yourReducer(undefined, {});
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;无论何时某人订阅了我们的store，那么他将会被添加到&lt;code&gt;listeners&lt;/code&gt;数组中。这是非常重要的，因为每次当某人在派发(dispatch)一个动作(action)的时候，所有的&lt;code&gt;listeners&lt;/code&gt;都需要在此次事件循环中被通知到。调用&lt;code&gt;yourReducer&lt;/code&gt;函数并传入一个&lt;code&gt;undefined&lt;/code&gt;和一个空对象将会返回一个&lt;code&gt;initialState&lt;/code&gt;，这个值也就是我们在调用&lt;code&gt;store.getState()&lt;/code&gt;时的返回值。既然说到这里了，我们就来创建这个方法。&lt;/p&gt;
&lt;h3 id=&quot;store.getstate&quot;&gt;2.1 store.getState()&lt;/h3&gt;
&lt;p&gt;这个函数用于从store中返回最新的状态，当用户每次点击一个按钮的时候我们都需要最新的状态来更新我们的视图。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const createStore = (yourReducer) =&amp;gt; {
    let listeners = [];
    let currentState = yourReducer(undefined, {});
    
    return {
        getState: () =&amp;gt; currentState
    };
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;store.dispatch&quot;&gt;2.2 store.dispatch()&lt;/h3&gt;
&lt;p&gt;这个函数使用一个&lt;code&gt;action&lt;/code&gt;作为其入参，并且将这个&lt;code&gt;action&lt;/code&gt;和&lt;code&gt;currentState&lt;/code&gt;反馈给&lt;code&gt;yourReducer&lt;/code&gt;来获取一个新的状态，并且&lt;code&gt;dispatch&lt;/code&gt;方法还会通知到每一个订阅了当前store的监听者。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const createStore = (yourReducer) =&amp;gt; {
  let listeners = [];
  let currentState = yourReducer(undefined, {});

  return {
    getState: () =&amp;gt; currentState,
    dispatch: (action) =&amp;gt; {
      currentState = yourReducer(currentState, action);

      listeners.forEach((listener) =&amp;gt; {
        listener();
      });
    }
  };
};&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;store.subscribelistener&quot;&gt;2.3 store.subscribe(listener)&lt;/h3&gt;
&lt;p&gt;这个方法使得你在当store接收到一个&lt;code&gt;action&lt;/code&gt;的时候能够被通知到，可以在这里调用&lt;code&gt;store.getState()&lt;/code&gt;来获取最新的状态并更新UI。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const createStore = (yourReducer) =&amp;gt; {
  let listeners = [];
  let currentState = yourReducer(undefined, {});

  return {
    getState: () =&amp;gt; currentState,
    dispatch: (action) =&amp;gt; {
      currentState = yourReducer(currentState, action);

      listeners.forEach((listener) =&amp;gt; {
        listener();
      });
    },
    subscribe: (newListener) =&amp;gt; {
      listeners.push(newListener);

      const unsubscribe = () =&amp;gt; {
        listeners = listeners.filter((l) =&amp;gt; l !== newListener);
      };

      return unsubscribe;
    }
  };
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同时&lt;code&gt;subscribe&lt;/code&gt;函数返回了另一个函数&lt;code&gt;unsubscribe&lt;/code&gt;，这个函数允许你当不再对store的更新感兴趣的时候能够取消订阅。&lt;/p&gt;
&lt;h2 id=&quot;整理代码&quot;&gt;3. 整理代码&lt;/h2&gt;
&lt;p&gt;现在我们添加按钮的逻辑，来看看最后的源代码：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// 简化版createStore函数
const createStore = (yourReducer) =&amp;gt; {
  let listeners = [];
  let currentState = yourReducer(undefined, {});

  return {
    getState: () =&amp;gt; currentState,
    dispatch: (action) =&amp;gt; {
      currentState = yourReducer(currentState, action);

      listeners.forEach((listener) =&amp;gt; {
        listener();
      });
    },
    subscribe: (newListener) =&amp;gt; {
      listeners.push(newListener);

      const unsubscribe = () =&amp;gt; {
        listeners = listeners.filter((l) =&amp;gt; l !== newListener);
      };

      return unsubscribe;
    }
  };
};

// Redux的架构组成部分
const initialState = { count: 0 };

const actions = {
  increment: { type: 'INCREMENT' },
  decrement: { type: 'DECREMENT' }
};

const countReducer = (state = initialState, action) =&amp;gt; {
  switch (action.type) {
    case actions.increment.type:
      return {
        count: state.count + 1
      };

    case actions.decrement.type:
      return {
        count: state.count - 1
      };

    default:
      return state;
  }
};

const store = createStore(countReducer);

// DOM元素
const incrementButton = document.querySelector('.increment');
const decrementButton = document.querySelector('.decrement');

// 给按钮添加点击事件
incrementButton.addEventListener('click', () =&amp;gt; {
  store.dispatch(actions.increment);
});

decrementButton.addEventListener('click', () =&amp;gt; {
  store.dispatch(actions.decrement);
});

// 初始化UI视图
const counterDisplay = document.querySelector('h1');
counterDisplay.innerHTML = parseInt(initialState.count);

// 派发动作的时候跟新UI
store.subscribe(() =&amp;gt; {
  const state = store.getState();

  counterDisplay.innerHTML = parseInt(state.count);
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们再次看看最后的视图效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/15/16e6fbe887ad8547?w=600&amp;amp;h=278&amp;amp;f=gif&amp;amp;s=37121&quot;/&gt;&lt;/p&gt;
&lt;p&gt;原文: &lt;a href=&quot;https://www.freecodecamp.org/news/redux-in-24-lines-of-code/&quot; class=&quot;uri&quot;&gt;https://www.freecodecamp.org/news/redux-in-24-lines-of-code/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;交流&quot;&gt;4. 交流&lt;/h2&gt;
&lt;p&gt;本篇主要简单了解下Redux的三个架构组成部分以及如何实现一个简化版的Redux，对Redux能有进一步的了解，希望能和大家相互讨论技术，一起交流学习。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文章已同步更新至&lt;a href=&quot;https://github.com/qq591468061/xwfe&quot;&gt;Github博客&lt;/a&gt;，若觉文章尚可，欢迎前往star！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;你的一个点赞，值得让我付出更多的努力！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;逆境中成长，只有不断地学习，才能成为更好的自己，与君共勉！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/945578/201911/945578-20191116083507175-341676239.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 16 Nov 2019 00:36:00 +0000</pubDate>
<dc:creator>小维FE</dc:creator>
<og:description>作者：Yazeed Bzadough 译者：小维FE 原文：freecodecamp 为了保证文章的可读性，本文采用意译而非直译。 90%的规约，10%的库。 Redux是迄今为止创建的最重要的Jav</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tangshiwei/p/11870517.html</dc:identifier>
</item>
<item>
<title>FileStream相关知识分享 - 萌萌丶小魔王</title>
<link>http://www.cnblogs.com/xiaomowang/p/11770864.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaomowang/p/11770864.html</guid>
<description>&lt;p&gt;&lt;strong&gt;一、如何理解FIleStream&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过前3章的学些，相信大家对于Stream已经有一定的了解，但是又如何去理解FileStream呢？请看下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/799221/201910/799221-20191031135620440-1846768642.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 我们磁盘中的任何文件都是通过二进制数组组成，最为直观的就是记事本了，当我们新建一个记事本时，它的大小时0KB，我们每次输入一个数字或字母时，文件便会自动增大到4KB，可见，随着我们输入的内容越来越多，文件也会越来越大，同理，当我们删除文件内容时，文件也会相应的减小，对了，聪明的你肯定会问：谁将内容以怎样的形式放到文件中去了？&lt;/p&gt;
&lt;p&gt;好问题，还记得第一章流的概念嘛？对了，真实世界的一群鱼可以通过河流往前往各个地方，FileStream也一样，byte可以通过FileStream进行传输，这样我们便能在计算机上对任何文件进行一系列操作了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、FileStream的重要性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;FileStream顾名思义文件流，我们电脑上的文件都可以通过文件流进行操作，例如文件的复制、简介、粘贴、删除、本地文件上传、下载、等许多重要的功能都离不开文件流。所以文件流不仅在本机上非常重要，在如今的网络世界上也万万不能缺少的，想象一下我们开启虚拟机后，直接从本地复制一个文件到虚拟机上，时多么的方便，如果没有文件流，这个将难以想象。（大家别误解，文件流通过网络流将客户都安上传的文件传到服务器端接收，然后通过文件流进行处理，下载正好相反）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三、FileStream常用构造函数介绍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、FileStream(SafeFileHandle safeFileHandle,FileAccess fileAccess)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;非托管参数SafeFileHandle简单介绍&lt;/p&gt;
&lt;p&gt;SafeFileHandle：是一个文件安全句柄，这样的解释可能大家一头雾水，别急，大家先不要去理睬这深邃的含义，只要知道这个类型是C#非托管资源，也就是说它能够调用非托管资源的方法，而且不属于C#回收机制，所以我们必须使用GC手动或其他方式（Finalize或Dispose方法）进行非托管资源的回收，所以SafeFileHandle是一个默默无闻的保镖，一直暗中保护FileStream和文件的安全，为了让大家更好的理解这个保镖，请看第一段代码：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;         &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; rootPath =&lt;span&gt; Environment.CurrentDirectory;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; fileName = Path.Combine(rootPath, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TextFile1.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;@&quot;TextFile1.txt&quot;;&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;             FileStream fileStream = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileStream(fileName, FileMode.OpenOrCreate);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;            Console.ReadLine();
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;            File.Delete(fileName);
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;            Console.ReadKey();
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们运行一下，结果报错了，我看看一下错误：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/799221/201911/799221-20191101140308613-334302618.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 为什么会报错呢？其实程序被卡在了Console.ReadLine()这里，FileStream并没有被释放，系统不知道这个文件是否还有用，所以帮我们保护这个文件（那个非托管资源SafeFileHandle所使用的内存还被占用着）所以SafeFileHandle在内部保护了这个文件从而报出了这个异常，如果我们将流关闭后，这个问题就不存在了。&lt;/p&gt;
&lt;p&gt;所以，我们又回到了一个老问题上面，我们每次使用完FileStream后都必须将他关闭并释放资源。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、FileStream(string str,FileModel model)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;string 参数表示文件所在的地址，FileMode是个枚举，表示确定如何打开或创建文件 。&lt;/p&gt;
&lt;p&gt;FileModel枚举参数包含以下内容：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/799221/201911/799221-20191101151340841-125240825.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; 3、FileStream(IntPtr intPtr,FIleAccess fileAccess,Boolean ownsHandle)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;FileAccess参数也是一个枚举，表示对该文件的操作权限：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/799221/201911/799221-20191101153612240-123558720.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 参数ownsHandle：也就是类似于前面和大家介绍的SafeFileHandler，有2点必须注意：（1）对于指定的文件句柄，操作系统不允许所请求的access，例如：当access为Write或ReadWrite而文件句柄设置为只读访问的时候，会出现异常。所以ownsHandle才是老大，FileAccess的权限应该在ownsHandle的范围内。（2）FileStream假定它的句柄有独占控制权，当FileStream也持有句柄时，读取、写入或查找可能会导致数据破坏，为了数据安全，请使用句柄前调用Flush，并避免在使用完句柄后调用Close以外的任何方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、FileStream(string str,FileModel model,FileAccess,fileAccess,FileShare fileShare)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;FileShare：同样时一个枚举类型，确定文件如何由进程共享。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/799221/201911/799221-20191101154232531-1031707743.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5、FileStream(string str,FileMode mode,FileAccess fileAccess,FileShare fileShare,Int32 i,Boolean async)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Int32:这是一个缓冲区的大小，大家可以按照自己的需要定制；&lt;/p&gt;
&lt;p&gt;Boolean async：是否异步读写，告诉FileStream示例，是否采用异步读写&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6、FileStream(string str,FileMode mode,FileShare fileShare,Int32 i,FileOption fileOption)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;FileOption:这是类似于FileStream对于我呢见操作的高级选项&lt;/p&gt;
&lt;p&gt;四、FileStream常用属性介绍&lt;/p&gt;
&lt;p&gt;1、CanRead：指示FileStream是否可以读操作&lt;/p&gt;
&lt;p&gt;2、CanSeek：指示FileStream是否可以跟踪查找流操作&lt;/p&gt;
&lt;p&gt;3、IsAsync：FileStream是否同步工作还是异步工作&lt;/p&gt;
&lt;p&gt;4、Name：FileStream的名字，只读属性&lt;/p&gt;
&lt;p&gt;5、ReadTimeout：设置读取超时时间&lt;/p&gt;
&lt;p&gt;6、SafeFileHandle：文件安全句柄，只读属性&lt;/p&gt;
&lt;p&gt;7、Position：当前FileStream所在的流的位置&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;五、FileStream常用方法介绍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以下方法重写了Stream的一些虚方法&lt;/p&gt;
&lt;p&gt;1、IAsyncResult BeginRead 异步读取&lt;/p&gt;
&lt;p&gt;2、IAsyncResult BeginWrite 异步写&lt;/p&gt;
&lt;p&gt;3、void Close 关闭当前FileStream&lt;/p&gt;
&lt;p&gt;4、void EndRead 异步读取结束&lt;/p&gt;
&lt;p&gt;5、void EndWrite 异步写结束&lt;/p&gt;
&lt;p&gt;6、void Flush 立刻释放缓冲区，将数据全部导出到基础流（文件）中&lt;/p&gt;
&lt;p&gt;7、int Read 一般读取&lt;/p&gt;
&lt;p&gt;8、int ReadByte 读取单个字节&lt;/p&gt;
&lt;p&gt;9、long Seek 跟踪查找流所在的位置&lt;/p&gt;
&lt;p&gt;10、void SetLength 设置FileStream的长度&lt;/p&gt;
&lt;p&gt;11、void Write 一般写&lt;/p&gt;
&lt;p&gt;12、void WriteByte 写入单个字节&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;六、属于FileStream独有的方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、FileSecurity GetAccessControl()&lt;/p&gt;
&lt;p&gt;这个不是很常用，FileSecurity时文件安全类，直接表达当前文件的访问控制列表（ACL）的复合当前文件权限的项目，ACL大家有个了解就行，以后会单独和大家讨论下ACL方面的知识&lt;/p&gt;
&lt;p&gt;2、void Lock(long position,long length)&lt;/p&gt;
&lt;p&gt;这个Lock方法和线程中的Lock关键字很不一样，它能够锁住文件中的某一部分，非常的强悍！用了这个方法我们能够精确锁定住我们要锁住的文件的部分内容&lt;/p&gt;
&lt;p&gt;3、void SetAccessControl(FileSecurity fileSecurity)&lt;/p&gt;
&lt;p&gt;和GetAccessControl很相似，ACL技术会再以后单独介绍&lt;/p&gt;
&lt;p&gt;4、void Unlock(long position,long length)&lt;/p&gt;
&lt;p&gt;正好和lock方法相反，对于文件部分的解锁&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;七、文件的新建和拷贝（主要演示文件同步和异步操作）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先我们尝试DIY一个IFileCOnfig&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IFileConfig
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;string&lt;/span&gt; FileName { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;bool&lt;/span&gt; IsAsync { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 创建文件配置类CreateFileConfig，用于添加文件一些配置设置，实现添加文件的操作&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CreateFileConfig : IFileConfig
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 文件名称
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; FileName { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 是否异步
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; IsAsync { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 创建文件所在Url
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; CreateUrl { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;让我们定义一个文件流测试类：FileStreamTest来实现文件的操作。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 文件测试类
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; FileStreamTest
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在该类中实现一个简单的Create方法，用来同步或异步的实现添加文件，FileStream会根据配置类去选择相应的构造函数，实现异步或同步的添加方式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 添加文件方法
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;config&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Create(IFileConfig config)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;lock&lt;/span&gt;&lt;span&gt; (_lockObject)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到创建文件配置的对象&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; createFileConfig = config &lt;span&gt;as&lt;/span&gt;&lt;span&gt; CreateFileConfig;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;假设创建完文件后写入一段话，实际项目中无需这么做，这里只是演示&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;                 &lt;span&gt;char&lt;/span&gt;[] insertContent = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HellowWord&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.ToCharArray();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (createFileConfig == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;转化成byte[]&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;                 &lt;span&gt;byte&lt;/span&gt;[] byteArrayContent = Encoding.Default.GetBytes(insertContent, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, insertContent.Length);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据传入的配置文件来决定是否同步或者异步实例化Stream对象&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;                 FileStream stream =&lt;span&gt; createFileConfig.IsAsync
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                     ? &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileStream(createFileConfig.CreateUrl, FileMode.Create, FileAccess.ReadWrite, FileShare.None,
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                         &lt;span&gt;4096&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                     : &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileStream(createFileConfig.CreateUrl, FileMode.Create);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                 &lt;span&gt;using&lt;/span&gt;&lt;span&gt; (stream)
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果不注释下面代码会抛出异常，google上提示是WriteTimeOut只支持网络流
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;stream.WriteTimeout=READ_OR_WRITE_TIMEOUT;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果流是同步并且可写&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (!stream.IsAsync &amp;amp;&amp;amp;&lt;span&gt; stream.CanWrite)
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                         stream.Write(byteArrayContent, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, byteArrayContent.Length);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                     &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (stream.CanWrite)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;异步可写&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                         stream.BeginWrite(byteArrayContent, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, byteArrayContent.Length, End_CreateFileCallBack, stream);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果采用异步的方式则最后会进入End_CreateFileCallBack回调方法，result AsyncState 对象就是上图stream.BeginWrite()方法的最后一个参数。还有一点必须注意的是每一次使用BeginWrite()方法都要带上EndWrite()方法，Read方法也一样&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 异步写文件callBack方法
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;result&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; End_CreateFileCallBack(IAsyncResult result)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;从IAsyncResult对象中得到原来的FileStream&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; stream = result.AsyncState &lt;span&gt;as&lt;/span&gt;&lt;span&gt; FileStream;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;结束异步写&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (stream != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;异步创建文件地址{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, stream.Name);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;                stream.EndWrite(result);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            Console.ReadKey();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;文件复制的方式思路比较相似，首先定义复制文件配置类，由于在异步回调中用到该配置类的属性，所以新增了文件流对象和相应的字节数组&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 异步读文件方法
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;result&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; End_ReadFileCallBack(IAsyncResult result)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到先前的配置文件&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; config = result.AsyncState &lt;span&gt;as&lt;/span&gt;&lt;span&gt; CopyFileConfig;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;结束异步读&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;             config?&lt;span&gt;.OriginalFileStream.EndRead(result);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;异步读后立即写入新文件地址&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (config != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 FileStream copyStream = &lt;span&gt;new&lt;/span&gt; FileStream(config.DestinationFileUrl, FileMode.CreateNew, FileAccess.Write, FileShare.Write, &lt;span&gt;4096&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                 &lt;span&gt;using&lt;/span&gt;&lt;span&gt; (copyStream)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                     Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;异步复制原文件地址：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, config.OriginalFileStream.Name);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                     Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;复制后的新文件地址：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, config.DestinationFileUrl);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用异步写方法callBack方法为End_CreateFileCallBack，参数是copyStream&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;                     copyStream.BeginWrite(config.OriginalFileBytes, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, config.OriginalFileBytes.Length,
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;                        End_CreateFileCallBack, copyStream);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后在FileStreamTest类中新增一个Copy方法实现文件的复制功能&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 复制文件
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;config&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Copy(IFileConfig config)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;lock&lt;/span&gt;&lt;span&gt; (_lockObject)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到CopyFileConfig对象&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; copyFileConfig = config &lt;span&gt;as&lt;/span&gt;&lt;span&gt; CopyFileConfig;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (copyFileConfig == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建同步或异步流&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;                 FileStream stream =&lt;span&gt; copyFileConfig.IsAsync
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                     ? &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileStream(copyFileConfig.OriginalFileUrl, FileMode.Open, FileAccess.Read, FileShare.Read,
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                         &lt;span&gt;4096&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                     : &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileStream(copyFileConfig.OriginalFileUrl, FileMode.Open);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义一个byte数组接收从原文件读取的byte数据&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;                 &lt;span&gt;byte&lt;/span&gt;[] originalFileBytes = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[stream.Length];
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                 &lt;span&gt;using&lt;/span&gt;&lt;span&gt; (stream)
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果异步流&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (stream.IsAsync)
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将该流和流独处的byte[]数据放入配置类，在callback中可以使用&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;                         copyFileConfig.OriginalFileStream =&lt;span&gt; stream;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                         copyFileConfig.OriginalFileBytes =&lt;span&gt; originalFileBytes;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (stream.CanRead)
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;                        {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;异步开始读取，读取完后进入End_ReadFileCallBack方法，该方法接收copyFileConfig参数&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;                             stream.BeginRead(originalFileBytes, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, originalFileBytes.Length, End_ReadFileCallBack,
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;                                copyFileConfig);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;否则同步读取&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt; &lt;span&gt;                        {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (stream.CanRead)
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;                            {
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;                                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;读取原文件&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt;                                 stream.Read(originalFileBytes, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, originalFileBytes.Length);
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;                            }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;                             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义一个写流，在新位置中创建一个文件&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt;                             FileStream copyStream = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileStream(copyFileConfig.DestinationFileUrl, FileMode.CreateNew);
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;                             &lt;span&gt;using&lt;/span&gt;&lt;span&gt; (copyStream)
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;                            {
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;                                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将原文件的内容写进新文件&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt;                                 copyStream.Write(originalFileBytes, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, originalFileBytes.Length);
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;                            }
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; 
&lt;span&gt;52&lt;/span&gt; &lt;span&gt;                        Console.ReadLine();
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后，如果采用异步的方式，则会进入End_ReadFileCallBack回调函数进行异步读取和异步写操作&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 异步读文件方法
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;result&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; End_ReadFileCallBack(IAsyncResult result)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到先前的配置文件&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; config = result.AsyncState &lt;span&gt;as&lt;/span&gt;&lt;span&gt; CopyFileConfig;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;结束异步读&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;             config?&lt;span&gt;.OriginalFileStream.EndRead(result);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;异步读后立即写入新文件地址&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (config != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 FileStream copyStream = &lt;span&gt;new&lt;/span&gt; FileStream(config.DestinationFileUrl, FileMode.CreateNew, FileAccess.Write, FileShare.Write, &lt;span&gt;4096&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                 &lt;span&gt;using&lt;/span&gt;&lt;span&gt; (copyStream)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                     Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;异步复制原文件地址：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, config.OriginalFileStream.Name);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                     Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;复制后的新文件地址：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, config.DestinationFileUrl);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用异步写方法callBack方法为End_CreateFileCallBack，参数是copyStream&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;                     copyStream.BeginWrite(config.OriginalFileBytes, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, config.OriginalFileBytes.Length,
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;                        End_CreateFileCallBack, copyStream);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最有让我们在Main函数调用一下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;文件操作测试&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;             FileStreamTest test = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileStreamTest();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建文件配置类&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;             CreateFileConfig createFileConfig = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CreateFileConfig
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 CreateUrl = &lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;E:\自己的\MyTest\Word\新建的.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 IsAsync = &lt;span&gt;true&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            };
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;复制文件配置类&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;             CopyFileConfig copyFileConfig = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CopyFileConfig
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 OriginalFileUrl = &lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;E:\自己的\MyTest\Word\TextFile1.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                 DestinationFileUrl = &lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;E:\自己的\MyTest\Word\TextFile1-副本.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 IsAsync = &lt;span&gt;true&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            };
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;test.Create(createFileConfig);&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;            test.Copy(copyFileConfig);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;            Console.ReadKey();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;输出结果：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/799221/201911/799221-20191116000740682-724922616.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 好了，FileStream的相关知识就分享到这里了。&lt;/p&gt;
</description>
<pubDate>Sat, 16 Nov 2019 00:35:00 +0000</pubDate>
<dc:creator>萌萌丶小魔王</dc:creator>
<og:description>一、如何理解FIleStream 通过前3章的学些，相信大家对于Stream已经有一定的了解，但是又如何去理解FileStream呢？请看下图： 我们磁盘中的任何文件都是通过二进制数组组成，最为直观的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiaomowang/p/11770864.html</dc:identifier>
</item>
<item>
<title>数据库的增删改 - 无荨</title>
<link>http://www.cnblogs.com/twoo/p/11829684.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/twoo/p/11829684.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;--显示当前时间：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
select now();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;--创建students表(id, name, age, high, gender, cls_id)&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
    create table students (
            id int unsigned （默认：not null）  primary key  auto_increment(自增),
            name varchar(20),
            age tinyint unsigned default 0,
            high decimal(5,2),
            gender enum('男', '女', '中性', '保密') default '保密',
            cls_id int unsigned
        );　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;--查看表结构：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
    desc student;
        MariaDB [testdb]&amp;gt; desc students;
        +--------+-------------------------------------+------+-----+---------+----------------+
        | Field  | Type                                | Null | Key | Default | Extra          |
        +--------+-------------------------------------+------+-----+---------+----------------+
        | id     | tinyint(3) unsigned                 | NO   | PRI | NULL    | auto_increment |
        | name   | varchar(20)                         | NO   |     | NULL    |                |
        | age    | tinyint(3) unsigned                 | YES  |     | NULL    |                |
        | high   | decimal(5,2)                        | YES  |     | NULL    |                |
        | gender | enum('男','女','中性','保密')       | YES  |     | 中性    |                |
        | cls_id | tinyint(3) unsigned                 | YES  |     | NULL    |                |
        +--------+-------------------------------------+------+-----+---------+----------------+
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;字段的增删改：&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;-- 修改表-添加字段&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;　　--alter table 表名 add 列名 类型;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
alter table students add birthday datetime;　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;-- 修改表-修改字段:不重命名版&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;　　-- alter table 表名 modify 列名 类型及约束;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
alter table students modify birthday date;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;-- 修改表-修改字段:重命名版&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;　　-- alter table 表名 change 原名 新名 类型及约束;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
alter table students change birthday birth date;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1805569/201911/1805569-20191110134701695-1344676435.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;-- 修改表-删除字段&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;　　-- alter table 表名 drop 列名;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
alter table students drop birth;　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;-- 删除表&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;　　-- drop table 表名;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
drop table students;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;库的增删改查：&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;#查看数据库&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
show databases;　&lt;strong&gt;&lt;span&gt; 　　　　　　　&lt;/span&gt;&lt;/strong&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;#查看创建数据库状态&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
show create database testdb;　&lt;strong&gt;&lt;span&gt;　　　　　　　&lt;/span&gt;&lt;/strong&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;#使用哪个库&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
use testdb；&lt;em id=&quot;__mceDel&quot;&gt;&lt;br/&gt;&lt;/em&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;#创建数据库&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
create database test03            #默认是拉丁字符集
create database testdb character set utf8;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;#删除数据库&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
drop database testdb;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;#修改数据库默认字符集&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
alter database 库名 default character set utf8; #alter改变数据库结构/表结构&lt;em id=&quot;__mceDel&quot;&gt;&lt;strong&gt;&lt;span&gt;　　　　　　　&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;数据的增删改：&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;增加：&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;--全列插入&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;　　--insert into 表名 values (..)&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
eg：insert into students values (0（默认）,'小明',19,188.999,'男', 1);
--主键字段默认 可以用 0 null default 来站位
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1805569/201911/1805569-20191110134834112-393552341.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;--部分插入（注意约束）&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;　　--insert into 表名（字段，字段…） values (..)&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
eg：insert into students(id, name, age) values (0,'绿帽子',19);&lt;em id=&quot;__mceDel&quot;&gt;　&lt;/em&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;--部分插入(多条记录)&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
insert into students(id, name, age) values (0,'绿帽子',19),(0,'小跳蚤',21);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1805569/201911/1805569-20191110134859847-1954504924.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;修改：&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;　　--update 表名 set 列1=值1, 列2=值2... where 条件（还可以范围eg:id&amp;gt;6）;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
update students set age=100 where id=1; 
update students set age=100,cls_id=77 where id=1;

eg：update students set name='小飞',age=23 where id=9（或name='黄飞鸿2'）;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1805569/201911/1805569-20191110134913309-1309261236.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;删除：&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;　　-- delete from 表名 #清空表&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;-- 物理删除&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;　　-- delete from 表名 where 条件&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
delete from students where name='黄飞鸿';
delete from students where cls_id=88; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1805569/201911/1805569-20191110134934547-913554174.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;-- 清空表数据&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
truncate students; #无法恢复数据，并且清空自增
delete from students;   #在一定条件下可以恢复数据，不会清楚自增
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;-- 逻辑删除&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;　　-- 用一条字段来表示 这条信息是否已经不能在使用了&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;　　-- 给students表添加一个is_delete字段 bit 类型&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
alter table students add is_delete bit default 0;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;其他： &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1805569/201911/1805569-20191110135005387-1562930893.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;--default charset=utf8 默认字符集（按照库来的）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;--auto_increment(自增)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;MyISAM与InnoDB区别：&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;--两种类型最主要的区别就是InnDB支持事物处理与外键和行级锁&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　MyISAM查询机制高于InnoDB&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　InnoDB安全级别高于MyISAM&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 16 Nov 2019 00:25:00 +0000</pubDate>
<dc:creator>无荨</dc:creator>
<og:description>--显示当前时间： select now(); --创建students表(id, name, age, high, gender, cls_id) create table students ( i</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/twoo/p/11829684.html</dc:identifier>
</item>
<item>
<title>oracle直接调用web services - 王小鹏</title>
<link>http://www.cnblogs.com/wangjp-1233/p/11870486.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangjp-1233/p/11870486.html</guid>
<description>&lt;p&gt;oracle调用C#开发web services&lt;/p&gt;
&lt;p&gt;1，  去oracle官网上下载dbws-callout-utility-10131.zip&lt;/p&gt;
&lt;p&gt;地址：&lt;a href=&quot;http://www.oracle-base.com/articles/10g/utl_dbws10g.php&quot; rel=&quot;nofollow&quot; data-token=&quot;9910304f65c876e0f12a10fa6d038439&quot;&gt;https://oracle-base.com/articles/10g/utl_dbws-10g&lt;/a&gt;（注意请根据自己oracle的版本来选择下载对应的jar)&lt;/p&gt;
&lt;p&gt;2，  解压后放到oracle安装目录下的&amp;lt;oracle_install_dir&amp;gt;/sqlj/lib中；&lt;/p&gt;
&lt;p&gt;3，  在命令行中利用loadjava命令(一般安装完jdk或oracle之后就会有)将jar包导入oracle对应的用户中：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;loadjava -u user/password@oracle -r -v -f -genmissing -s -grant public dbwsclientws.jar dbwsclientdb102.jar&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;若为SYS用户，命令为：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;loadjava -u user/password -r -v -f -genmissing -s -grant public dbwsclientws.jar dbwsclientdb102.jar&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;（本人每次都会使用SYS用户权限比较大，在Win7与Win2008之后的系统开始命令行窗口的使用尽量使用“管理员模式”，安装时会产生拒绝访问的情况，有一种可能就是安装的Oracle数据库具备功能或者可以把Oracle服务关了再试试（这句有机会真的可以试试））&lt;/p&gt;
&lt;p&gt;4，  如果未发现UTL_DBWS(可以在plsql中敲入sys.若未有utl_dbws显示，则需要进行初始化)，需要运行之前下载的包中dbws-callout-utility-10131/sqlj/lib/ utl_dbws_body.sql及utl_dbws_decl.sql&lt;/p&gt;
&lt;p&gt;5，  编写sql函数并发布&lt;/p&gt;
&lt;p&gt;create or replace function FUNC_GENERATE_LOGINNAME(content VARCHAR2,cellNumber VARCHAR2,sender VARCHAR2)&lt;/p&gt;
&lt;p&gt;  return VARCHAR2 AS&lt;/p&gt;
&lt;p&gt;  l_service        sys.utl_dbws.SERVICE;&lt;/p&gt;
&lt;p&gt;  l_call           sys.utl_dbws.call;&lt;/p&gt;
&lt;p&gt;  l_result         ANYDATA;&lt;/p&gt;
&lt;p&gt;  l_wsdl_url       VARCHAR2(1024);&lt;/p&gt;
&lt;p&gt;  l_service_name   VARCHAR2(200);&lt;/p&gt;
&lt;p&gt;  l_operation_name VARCHAR2(200);&lt;/p&gt;
&lt;p&gt;  l_input_params   sys.UTL_DBWS.anydata_list;&lt;/p&gt;
&lt;p&gt;  l_xmltype_in       SYS.XMLTYPE;&lt;/p&gt;
&lt;p&gt;   l_xmltype_out      SYS.XMLTYPE;&lt;/p&gt;
&lt;p&gt;BEGIN&lt;/p&gt;
&lt;p&gt;  l_wsdl_url       := 'http://xxxx.xxxx.xxxx.xxxx:xxxx/project/axis/services.jws?wsdl';（这里一定要加?wsdl）&lt;/p&gt;
&lt;p&gt;  l_service_name   := 'servicesService';(就是我们*.asmx的那个类名)&lt;/p&gt;
&lt;p&gt;  l_operation_name := 'sendMessage';(就是我们具有WebMothed属性的方法名)&lt;/p&gt;
&lt;p&gt;  l_service        := sys.UTL_DBWS.create_service(wsdl_document_location =&amp;gt; URIFACTORY.getURI(l_wsdl_url),&lt;/p&gt;
&lt;p&gt;                                                  service_name           =&amp;gt; l_service_name);&lt;/p&gt;

&lt;p&gt;  l_call := sys.UTL_DBWS.create_call(service_handle =&amp;gt; l_service,&lt;/p&gt;
&lt;p&gt;                                     port_name      =&amp;gt; NULL,&lt;/p&gt;
&lt;p&gt;                                     operation_name =&amp;gt; l_operation_name);&lt;/p&gt;


&lt;p&gt;  l_input_params(1) := ANYDATA.ConvertVarchar2(content);&lt;/p&gt;
&lt;p&gt;  l_input_params(2) := ANYDATA.ConvertVarchar2(cellNumber);&lt;/p&gt;
&lt;p&gt;  l_input_params(3) := ANYDATA.ConvertVarchar2(sender);&lt;/p&gt;

&lt;p&gt;  l_result := sys.UTL_DBWS.invoke(call_handle  =&amp;gt; l_call,&lt;/p&gt;
&lt;p&gt;                                  input_params =&amp;gt; l_input_params);&lt;/p&gt;
&lt;p&gt;  sys.UTL_DBWS.release_call(call_handle =&amp;gt; l_call);&lt;/p&gt;
&lt;p&gt;  sys.UTL_DBWS.release_service(service_handle =&amp;gt; l_service);&lt;/p&gt;
&lt;p&gt;  RETURN ANYDATA.AccessVarchar2(l_result);&lt;/p&gt;
&lt;p&gt;EXCEPTION&lt;/p&gt;
&lt;p&gt;  WHEN OTHERS THEN&lt;/p&gt;
&lt;p&gt;    RETURN substr(sqlerrm, 0, 2000);&lt;/p&gt;
&lt;p&gt;END FUNC_GENERATE_LOGINNAME;&lt;/p&gt;


&lt;p&gt;6，看结果select func_generate_loginname('testTest','1234567','xxxxxx') from dual;&lt;/p&gt;
&lt;p&gt;7对于其中出现的异常，最可能的就是出现权限不足，可以利用如下语句解决：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;begin&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;dbms_java.grant_permission( 'DZZWPT', 'SYS:java.lang.RuntimePermission', 'getClassLoader', '' );&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;dbms_java.grant_policy_permission('DZZWPT','SYS','java.io.FileP ermission','*');&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;---dbms_java.grant_permission( 'DZZWPT','SYS:java.lang.IllegalAccessException','getClassLoader', '' );&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;dbms_java.grant_permission( 'DZZWPT', 'SYS:java.lang.RuntimePermission', 'accessClassInPackage.sun.util.calendar', '' );&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;dbms_java.grant_permission( 'DZZWPT', 'SYS:java.lang.RuntimePermission', 'setFactory', '' );&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;dbms_java.grant_permission( 'DZZWPT', 'SYS:java.util.PropertyPermission', 'HTTPClient.socket.idleTimeout', 'write' );&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;dbms_java.grant_permission( 'DZZWPT', 'SYS:java&lt;a class=&quot;replace_word&quot; title=&quot;.NET知识库&quot; href=&quot;http://lib.csdn.net/base/dotnet&quot; rel=&quot;nofollow&quot; data-token=&quot;d225a543f84cc4db9e6f9357c91e7ceb&quot;&gt;.Net&lt;/a&gt;.SocketPermission', 'localhost', 'resolve' );&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;dbms_java.grant_permission( 'DZZWPT', 'SYS:java.net.SocketPermission', '192.168.21.203:80', 'connect,resolve' );&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;dbms_java.grant_permission( 'DZZWPT', 'SYS:java.lang.RuntimePermission', 'createClassLoader', '' );&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;end;&lt;/p&gt;
8.以上为官方实例，接下来我们来试试HelloWorld
&lt;p&gt; 1).首先，我们要对自己写的WebServer做一些修改，&lt;/p&gt;
&lt;p&gt;   在WebServer类前面把Namespace设为空，且把[WebServiceBinding(ConformsTo = WsiProfiles.BasicProfile1_1)]&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog.csdn.net/saijie1983/article/details/7341607&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;根据WebServer中的说明来确定输入参数、输出参数的格式&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog.csdn.net/saijie1983/article/details/7341607&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;l_xmltype_in 的值就是&amp;lt;HelloWorld /&amp;gt;&lt;/p&gt;
&lt;p&gt;输出就是&lt;/p&gt;
&lt;p&gt;&amp;lt;HelloWorld1Response&amp;gt;&lt;br/&gt;  &amp;lt;HelloWorld1Result&amp;gt;Hello World&amp;lt;/HelloWorld1Result&amp;gt;&lt;br/&gt;&amp;lt;/HelloWorld1Response&amp;gt;&lt;/p&gt;
</description>
<pubDate>Sat, 16 Nov 2019 00:10:00 +0000</pubDate>
<dc:creator>王小鹏</dc:creator>
<og:description>oracle调用C#开发web services 1， 去oracle官网上下载dbws-callout-utility-10131.zip 地址：https://oracle-base.com/ar</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wangjp-1233/p/11870486.html</dc:identifier>
</item>
<item>
<title>深入理解java多态没有烤山药的存在，java就不香了吗？ - 宜春</title>
<link>http://www.cnblogs.com/yichunguo/p/11870464.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yichunguo/p/11870464.html</guid>
<description>&lt;p&gt;@&lt;/p&gt;
&lt;p&gt;我不想知道各位理解java多态没有烤山药的存在，java香不香的问题了，我不要你们认为，我只要我觉得 (感觉要被打....)&lt;/p&gt;
&lt;p&gt;在博主认为多态绝对是面向对象的第三大特性中让很多小白同学以及初学者难以跨越的鸿沟，因为多态有很多细节性的知识，不花点时间，还真不好理解多态。这么说吧，如果你觉得你已经完全理解了多态，你不妨做做下面的程序，如果你能全都答对，那没问题了，多态对你来说真的不是问题！如果在第四个就趴下了，那可以看看这篇文章，或许对你有所帮助，可能会让你重新见识到多态的魅力。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;package Polymorphic;
//爷爷类
class Ye {
    public String show(Sun obj) {
        return (&quot;Ye and Sun&quot;);
    }

    public String show(Ye obj) {
        return (&quot;Ye and Ye&quot;);
    }

}
//爸爸类
class Fu extends Ye {
    public String show(Fu obj) {
        return (&quot;Fu and Fu&quot;);
    }

    public String show(Ye obj) {
        return (&quot;Fu and Ye&quot;);
    }
}
//儿子类
class Zi extends Fu {

}
//孙子类
class Sun extends Fu {

}

public class PolymorphicTest {
    public static void main(String[] args) {
         Ye y = new Ye();
        Ye y2 = new Fu(); //向上
        Fu f = new Fu();
        Zi z = new Zi();
        Sun s = new Sun();


        System.out.println(&quot;第一题 &quot; + y.show(f));
        System.out.println(&quot;第二题 &quot; + y.show(z));
        System.out.println(&quot;第三题 &quot; + y.show(s));
        System.out.println(&quot;第四题 &quot; + y2.show(f));  //到这里挂了？？？
        System.out.println(&quot;第五题 &quot; + y2.show(z));
        System.out.println(&quot;第六题 &quot; + y2.show(s));
        System.out.println(&quot;第七题 &quot; + f.show(f));
        System.out.println(&quot;第八题 &quot; + f.show(z));
        System.out.println(&quot;第九题 &quot; + f.show(s));
     
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先把答案记在小本本上吧，再对照下面结果看看&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;第一题 Ye and Ye
第二题 Ye and Ye
第三题 Ye and Sun
第四题 Fu and Ye
第五题 Fu and Ye
第六题 Ye and Sun
第七题 Fu and Fu
第八题 Fu and Fu
第九题 Ye and Sun&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你对上面的结果很意外，或者不解，那么恭喜你，你又能学到新知识了，成功的向架构师前进了一步！好了，让我们一起重新见识见识多态的魅力吧！&lt;/p&gt;

&lt;p&gt;最近不是正火着吃烤山药么，学习就要走有趣化路线，毕竟兴趣永远最好的老师，咋们放开点，怎么有趣怎么来。&lt;/p&gt;
&lt;p&gt;小明妈妈的情绪非常不稳定，心情好的时候巴不得给小明花一个亿，，心情不好的时候巴不得把小明打成麻瓜，可是小明永远不知道妈妈的情绪变化。这不，今天一位老大爷在卖烤山药，边烤还边跳激光雨，嗨得不行，小明特别喜欢激光雨，马上就忍不住了，心里默默想着，刚烤的山药它不香嘛，激光雨烤的山药它不香嘛。于是忍不住对妈妈说：“妈妈，我想吃烤山药”，这个时候，来了,来了,他来了，它真的来了....你激动个锤子啊......是代码来了：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;package Polymorphic;


     class  Matcher{
        public void matcherSpeak(){
            System.out.println(&quot;想吃烤山药？&quot;);
        }
    }

     class HappyMother extends Matcher {
        public void matcherSpeak(){
            System.out.println(&quot;开心的妈妈说：吃，吃大块的，一火车够吗&quot;);
        }
    }

     class SadMother extends Matcher {
        public void matcherSpeak(){
            System.out.println(&quot;不开心的妈妈说：吃你个憨皮，看我回家扎不扎你就完事了&quot;);
        }
    }

     class VeryHappyMother extends Matcher {
        public void matcherSpeak(){
            System.out.println(&quot;异常开心的妈妈说：买买买，烤山药咱全买了，顺便把大爷也买回家，天天给你表演激光雨（大爷懵逼中）&quot;);
        }
    }

    public class UnderstandPolymorphic{
        public static void main(String[] args) {
            Matcher m = new HappyMother();
            m.matcherSpeak();

            m = new SadMother();
            m.matcherSpeak();

            m = new VeryHappyMother();
            m.matcherSpeak();

        }
    }
运行结果：

开心的妈妈说：吃，吃大块的，一火车够吗
不开心的妈妈说：吃你个憨皮，看我回家扎不扎你就完事了
异常开心的妈妈说：买买买，烤山药咱全买了，顺便把大爷也买回家，天天给你表演激光雨（大爷懵逼中）&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;妈妈听到小明想吃烤山药这同一行为，表现出不同的表现形式，这就是多态。多态专业定义则是：&lt;span&gt;程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定&lt;/span&gt;，这种情况叫做多态没错是没错就是脑壳有点大，所以我选择简单点定义多态： &lt;span&gt;&lt;strong&gt;多态指同一行为，具有多个不同表现形式&lt;/strong&gt;&lt;/span&gt;。为何会有如此微妙的变化呢，那我们就必须了解进行多态的前提了。&lt;/p&gt;

&lt;p&gt;如果多态不能满足以下三个前提条件，那还玩犊子的多态【构不成多态，缺一不可】&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;继承或者实现【二选一】&lt;/li&gt;
&lt;li&gt;方法的重写【意义体现：不重写，无意义】&lt;br/&gt;子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。&lt;/li&gt;
&lt;li&gt;父类引用指向子类对象（也可以说向上转型）【体现在格式上】&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;回过头来看烤山药例子，确实都有继承，同样都重写了&lt;code&gt;motherSpeak（）&lt;/code&gt;方法，最关键的代码则是&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt; Matcher m = new HappyMother();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也就是所谓的 父类引用指向子类对象，这其实就是向上转型！对向上转型概念不清晰没事，下面会详细讲解。&lt;/p&gt;

&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;多态体现的格式： &lt;strong&gt;父类/父接口类型 变量名 = new 子类对象&lt;/strong&gt;； &lt;strong&gt;变量名.方法名()&lt;/strong&gt;;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误 ,如果有，执行的是子类重写后的方法&lt;/strong&gt;&lt;/span&gt;，也就是向上转型时， &lt;span&gt;&lt;strong&gt;子类单独定义的方法丢失问题&lt;/strong&gt;&lt;/span&gt;。编译报错。 代码如下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;package Demo;

class  Matcher{
    public void matcherSpeak(){//=========================父类matcherSpeak()方法
        System.out.println(&quot;吃烤山药？&quot;);
    }
}

class HappyMother extends Matcher {
    public void matcherSpeak(){//=========================子类matcherSpeak()方法
        System.out.println(&quot;开心的妈妈说：吃，吃大块的，一蛇皮袋够吗&quot;);
    }

    public void fatherSpeak(){//=========================子类独有的fatherSpeak()方法
        System.out.println(&quot;开心的妈妈说：吃，吃大块的，一麻袋够吗&quot;);
    }
}
public class Test {
    public static void main(String[] args) {
        Matcher m=new HappyMother();
        m.matcherSpeak();
        m.fatherSpeak();  //编译失败，无法解析fatherSpeak方法
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;分析如下：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191009111350187.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;当然这个例子只是入门级的，接下来看个有点水平的例子&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;package Demo;

class  Matcher{
    public void matcherSpeak(){
        System.out.println(&quot;想吃烤山药？&quot;);
    }

}

class HappyMother extends Matcher {
    public void matcherSpeak(){
        System.out.println(&quot;开心的妈妈说：吃，吃大块的，一火车够吗&quot;);
    }
}
class SadMother extends HappyMother{
    public void tt(){
        System.out.println(&quot;ttttttt&quot;);
    }
}
public class Test {
    public static void main(String[] args) {
        Matcher mm=new SadMother();
        mm.matcherSpeak();
    }

运行结果：开心的妈妈说：吃，吃大块的，一火车够吗
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有了第一个基础这个相信不难理解，接着看&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;package Demo;

class  Matcher{
    public void matcherSpeak(){
        System.out.println(&quot;想吃烤山药？&quot;);
    }
}

class HappyMother extends Matcher {
    
}
class SadMother extends HappyMother{
    public void tt(){
        System.out.println(&quot;ttttttt&quot;);
    }
}
public class Test {
    public static void main(String[] args) {
        Matcher mm=new SadMother();
        mm.matcherSpeak();
    }
    
运行结果：想吃烤山药？

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到这里，再来回味下这句话：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误 ,如果有，执行的是子类重写后的方法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;你可能会说子类中都没有这些个方法啊，何来执行子类重写后的方法一说？它好像是去父类中找该方法了。事实上，子类中是有这些方法的，这个方法继承自父类，只不过没有覆盖该方法，所以没有在子类中明确写出来而已，看起来像是调用了父类中的方法，实际上调用的还是子类中的。同学继承方面的知识该补补了，可以参考下面这篇&lt;a href=&quot;https://blog.csdn.net/qq_44543508/article/details/102375196&quot;&gt;【java基础】java继承从“我爸是李刚”讲起&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;讲之前博主先来谈谈“&lt;strong&gt;绑定&lt;/strong&gt;”的概念：&lt;br/&gt;绑定指的是一个方法的调用与方法所在的类(方法主体)关联起来，大致可以理解为一个方法调用另一个方法。对java来说，绑定分为静态绑定和动态绑定；或者分别叫做前期绑定和后期绑定。&lt;/p&gt;
&lt;h4 id=&quot;静态绑定前期绑定&quot;&gt;4、1.静态绑定（前期绑定）&lt;/h4&gt;
&lt;p&gt;在程序执行前方法已经被绑定，==针对java静态绑定简单的可以理解为程序编译期的绑定==；java当中的方法只有&lt;code&gt;final&lt;/code&gt;，&lt;code&gt;static&lt;/code&gt;，&lt;code&gt;private(不会被继承)&lt;/code&gt; 和&lt;code&gt;构造方法&lt;/code&gt;是前期绑定【当然可能不止】&lt;/p&gt;
&lt;h4 id=&quot;动态绑定后期绑定&quot;&gt;4、2.&lt;span&gt;动态绑定&lt;/span&gt;（后期绑定）&lt;/h4&gt;
&lt;p&gt;后期绑定：在运行时根据具体对象的类型进行绑定。&lt;br/&gt;若一种语言实现了后期绑定，同时必须提供一些机制，可在运行期间判断对象的类型，并分别调用适当的方法。也就是说，编译器此时依然不知道对象的类型，但方法调用机制能自己去调查，找到正确的方法主体。不同的语言对后期绑定的实现方法是有所区别的。但我们至少可以这样认为：它们都要在对象中安插某些特殊类型的信息。==&lt;strong&gt;简明的说动态绑定就是指编译器在编译阶段不知道要调用哪个方法，运行期才能确定&lt;/strong&gt;==&lt;/p&gt;
&lt;h4 id=&quot;静态动态绑定本质区别&quot;&gt;4、3.静态、动态绑定本质区别&lt;/h4&gt;
&lt;p&gt;1、静态绑定是发生在编译阶段；而动态绑定是在运行阶段；&lt;br/&gt;2、静态绑定使用的是类信息，而动态绑定使用的是对象信息&lt;br/&gt;3、&lt;span&gt;&lt;strong&gt;重载方法(overloaded methods)使用的是静态绑定，而重写方法(overridden methods)使用的是动态绑定&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;静态动态绑定在程序中运行区别&quot;&gt;4、4.静态、动态绑定在程序中运行区别&lt;/h4&gt;
&lt;p&gt;这个静态绑定例子以static方法为例，代码程序如下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;package demoee;

class Father5{
    public void StaticMethod(){
        System.out.println(&quot;粑粑：我是父类粑粑静态方法&quot;);
    }
}
class Son5 extends Father5{
    public void StaticMethod(){
        System.out.println(&quot;熊孩子：我是子类熊孩砸静态方法&quot;);
    }
}
public class demooo {
    public static void main(String[] args) {
        Father5 fat=new Father5();
        Father5 son=new Son5(); //特别注意这里是向上转型  也就是多态！

        fat.StaticMethod();//同时调用StaticMethod方法！
        son.StaticMethod();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;粑粑：我是父类粑粑静态方法
熊孩子：我是子类熊孩砸静态方法&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据上面的运行结果，我们也很好理解！子类重写了父类的一个叫做&lt;code&gt;StaticMethod（）&lt;/code&gt;的方法，由于是动态绑定，因此最后执行的是子类重写后的&lt;code&gt;StaticMethod（）&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;嗯哼？为了更好的理解静态、动态绑定在程序中运行区别，我们还是得看看下面这个程序：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;class Father5{
    public static void StaticMethod(){
        System.out.println(&quot;粑粑：我是父类粑粑静态方法&quot;);
    }
}
class Son5 extends Father5{
    public static void StaticMethod(){
        System.out.println(&quot;熊孩子：我是子类熊孩砸静态方法&quot;);
    }
}
public class demooo {
    public static void main(String[] args) {
        Father5 fat=new Father5();
        Father5 son=new Son5(); //特别注意这里是向上转型  也就是多态！

        fat.StaticMethod();//同时调用StaticMethod方法！
        son.StaticMethod();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;千万注意哦，这个程序与第一个程序唯一不同之处就在于这个程序父类和子类的方法都是static的！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;粑粑：我是父类粑粑静态方法
粑粑：我是父类粑粑静态方法&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从运行结果来看，我们可以很清楚的知道，子类静态方法语法上是做到了重写的作用，但实际上并没有做到真正意义上重写作用！只因为该方法是静态绑定！&lt;/p&gt;
&lt;p&gt;OK，get到了咩？如果get到了请点个赞呗，谢谢你~&lt;/p&gt;

&lt;p&gt;虚方法出现在Java的多态特性中。&lt;/p&gt;
&lt;p&gt;父类与子类之间的多态性，对父类的函数进行重新定义。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。在Java中，子类可继承父类中的方法，而不需要重新编写相同的方法。但有时子类并不想原封不动地继承父类的方法，而是想作一定的修改，这就需要采用方法的重写。方法重写又称方法覆盖。&lt;/p&gt;
&lt;p&gt;当设计类时，被重写的方法的行为怎样影响多态性。方法的重写使得子类能够重写父类的方法。当子类对象调用重写的方法时，调用的是子类的方法，而不是父类中被重写的方法。&lt;/p&gt;
&lt;p&gt;因此简单明了的理解Java虚方法方式你可以理解为java里所有&lt;span&gt;&lt;strong&gt;父类中被重写的方法都是虚方法&lt;/strong&gt;（virtual）&lt;/span&gt;差不多的意思就是该方法不会被子类使用到，使用到的都是子类中重写父类的方法，子类中的重写方法代替了它，因此也就有种名存实亡的感觉！&lt;/p&gt;
&lt;p&gt;在JVM字节码执行引擎中，方法调用会使用invokevirtual字节码指令来调用所有的虚方法。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;小白童鞋千万需要注意虚方法和抽象方法并不是同一个概念！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;# 6、 重载属于多态吗？&lt;/p&gt;
&lt;p&gt;纵观重载与重写，重写是多态的特征体现无疑了！但是对于重载是不是多态的体现网上却议论纷纷！&lt;/p&gt;
&lt;p&gt;多态是基于对抽象方法的覆盖来实现的，用统一的对外接口来完成不同的功能。重载也是用统一的对外接口来完成不同的功能。那么两者有什么区别呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;重载&lt;/strong&gt;&lt;br/&gt;重载是指允许存在多个同名方法，而这些方法的参数不同。重载的实现是：编译器根据方法不同的参数表，对同名方法的名称做修饰。对于编译器而言，这些同名方法就成了不同的方法。它们的调用地址在编译期就绑定了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多态&lt;/strong&gt;&lt;br/&gt;多态是指子类重新定义父类的虚方法（virtual,abstract）。当子类重新定义了父类的虚方法后，父类根据赋给它的不同的子类，动态调用属于子类的该方法，这样的方法调用在编译期间是无法确定的。&lt;br/&gt;不难看出，两者的区别在于编译器何时去寻找所要调用的具体方法，对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为“早绑定”或“静态绑定”；而对于多态，只有等到方法调用的那一刻，编译器才会确定所要调用的具体方法，这称为“晚绑定”或“动态绑定”。&lt;/p&gt;
&lt;p&gt;所以，你可以大可认为重载不属于多态，多态是对父类虚函数的重定义，不改变原虚函数的参数列表。重载是函数名相同，但参数列表不同。&lt;/p&gt;
&lt;p&gt;实际上这种问题没有严格的答案，就连教材书上都没提及。严格来说或狭义来讲，重载算多态还是有点牵强，传统的多态就是指父类和子类关系，但实际开发中都是理解重载是多态。这就是一个概念 你子类拥有你很多隐式父类的功能 那么你当然能扮演它们之中的某一个角色。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;总的来说，在博主认为，重载是不是多态这个问题以及不重要了，首当其冲的重要任务我觉得还是好好保护头发，然后就是养生了....&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;向上转型：多态本身是子类类型向父类类型向上转换的过程，其中，这个过程是默认的。你可以把这个过程理解为基本类型的小类型转大类型自动转换，不需要强制转换。 当&lt;span&gt;&lt;strong&gt;父类引用指向一个子类对象时，便是向上转型&lt;/strong&gt;&lt;/span&gt;。 向上转型格式：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;父类类型 变量名 = new 子类类型(); 如：&lt;code&gt;Father f= new Son();&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;例子的话，烤山药的例子就是一个典型的向上转型例子&lt;/p&gt;

&lt;p&gt;向下转型：父类类型向子类类型向下转换的过程，这个过程是强制的。同样可以把这个过程理解为基本类型的自动转换，大类型转小类型需要强制转换。一个已经向上转型的子类对象，将父类引用转为子类引用，可以使用强制类型转换的格式，向下转使用格式：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;code&gt;Father father = new Son();&lt;/code&gt;&lt;br/&gt;子类类型 变量名 = (子类类型) 父类变量名; 如:&lt;code&gt;Son s =(Son) father;&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不知道你们有没有发现，向下转型的前提是父类对象指向的是子类对象（也就是说，在&lt;span&gt;向下转型之前，它得先向上转型&lt;/span&gt;），当然，向下转型还是有它的意义所在，下面就讲解向下转型的意义。&lt;/p&gt;
&lt;p&gt;到这里，我们讲解一下为什么要向下转型？上面已经讲到过当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误。也就是说，不能调用子类拥有，而父类没有的方法。编译都错误，更别说运行了。这也是多态给我们带来的一点&quot;小麻烦&quot;。所以，&lt;span&gt;&lt;strong&gt;想要调用子类特有的方法，必须做向下转型&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;package Demo;

class  Matcher{
    public void eat(){
        System.out.println(&quot;想吃烤山药？&quot;);
    }
}

class XiongHaiZi extends Matcher {
    public void eat(){
        System.out.println(&quot;妈妈，我想吃烤山药&quot;);
    }

    public void eatSuLi(){//============================子类特有的eatSuLi方法
        System.out.println(&quot;麻麻，我想吃酥梨，要吃麻瓜那么大的酥梨&quot;);
    }
}

public class Test {
    public static void main(String[] args) {
        
        Matcher m = new XiongHaiZi();//向上转型
        
        XiongHaiZi x = (XiongHaiZi)m;//向下转型
        
        x.eatSuLi();//执行子类特有方法

    }
    
    运行结果：麻麻，我想吃酥梨，要吃麻瓜那么大的酥梨
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;好了向下转型就讲到这里...等等，你真的以为就讲完了？肯定不行喽，向下转型还有一个要说的知识，讲之前先来看个程序先&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;package Demo;

class  Matcher{
    public void eat(){
        System.out.println(&quot;想吃烤山猪？&quot;);
    }

}

class Boy extends Matcher {
    public void eatKaoYang(){
        System.out.println(&quot;妈妈，我想吃烤山猪&quot;);
    }
}

class Girl extends Matcher {
    public void eatKaoYang(){
        System.out.println(&quot;妈妈，我想吃烤山猪2333&quot;);
    }
}

public class Test {
    public static void main(String[] args) {

        Matcher g = new Girl();//向上转型编译通过

        Boy x = (Boy)g;//向下转型

        x.eatKaoYang();//编译通过,但运行报ClassCastException

    }
    
 运行结果：  运行报ClassCastException

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码可以通过编译，但是运行时，却报出了 &lt;code&gt;ClassCastException&lt;/code&gt; ，类型转换异常！这是因为，明明创建了&lt;code&gt;Girl&lt;/code&gt;类型对象，运行时，当然不能转换成&lt;code&gt;Boy&lt;/code&gt;对象的。这两个类型并没有任何继承关系，不符合类型转换的定义。 为了避免&lt;code&gt;ClassCastException&lt;/code&gt;的发生，Java提供了 &lt;code&gt;instanceof&lt;/code&gt; 关键字，给引用变量做类型的校验。&lt;/p&gt;
&lt;h4 id=&quot;instanceof的使用&quot;&gt;8、1. instanceof的使用&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;instanceof&lt;/code&gt; 的格式：&lt;br/&gt;变量名 instanceof 数据类型&lt;/p&gt;
&lt;p&gt;&lt;code&gt;instanceof&lt;/code&gt; 的使用&lt;br/&gt;如果变量属于该数据类型，返回true。&lt;br/&gt;如果变量不属于该数据类型，返回false。&lt;/p&gt;
&lt;p&gt;所以，转换前，我们最好使用&lt;code&gt;instanceof&lt;/code&gt; 先做一个判断，代码如下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;package Demo;

class  Matcher{
    public void eat(){
        System.out.println(&quot;想吃烤山药？&quot;);
    }

}

class Boy extends Matcher {
    public void eatKaoYang(){
        System.out.println(&quot;Boy：妈妈，我想吃烤羊&quot;);
    }
}

class Girl extends Matcher {
    public void eatKaoYang(){
        System.out.println(&quot;Girl：妈妈，我想吃烤全羊2333&quot;);
    }
}

public class Test {
    public static void main(String[] args) {

        Matcher g = new Girl();//向上转型

        if(g instanceof Girl){
            Girl x = (Girl)g;//向下转型
            x.eatKaoYang();  //=====================调用Girl的eatKaoYang()方法
        }else if(g instanceof Boy){ //不执行
            Boy x = (Boy)g;//向下转型
            x.eatKaoYang();  //=====================调用Boy的eatKaoYang()方法
        }
    }
}

运行结果： Girl：妈妈，我想吃烤全羊2333&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;好了到这里，你get到了咩？&lt;/p&gt;

&lt;p&gt;看完之后是不是还是不够清晰向上向下转型？多态转型问题其实并不复杂，只要记住一句话：&lt;span&gt;&lt;strong&gt;父类引用指向子类对象&lt;/strong&gt;&lt;/span&gt;。那什么叫父类引用指向子类对象？看下面例子吧&lt;/p&gt;
&lt;p&gt;有两个类，&lt;code&gt;Father&lt;/code&gt; 是父类，&lt;code&gt;Son&lt;/code&gt; 类继承自 &lt;code&gt;Father&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;第 1 个例子：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;//  f1 引用指向一个Son对象
Father f1 = new Son();   // 这就叫 upcasting （向上转型)
// f1 还是指向 Son对象
Son s1 = (Son)f1;   // 这就叫 downcasting (向下转型)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第 2 个例子：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// f1现在指向father对象
Father f2 = new Father();
Son s2 = (Son)f2;       // 出错，子类引用不能指向父类对象&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你或许会问，第1个例子中：&lt;code&gt;Son s1 = (Son)f1&lt;/code&gt;; 为什么是正确的呢。很简单因为 &lt;code&gt;f1&lt;/code&gt; 指向一个子类对象，&lt;code&gt;Father f1 = new Son()&lt;/code&gt;; 子类 &lt;code&gt;s1&lt;/code&gt; 引用当然可以指向子类对象了。&lt;/p&gt;
&lt;p&gt;而 &lt;code&gt;f2&lt;/code&gt; 被传给了一个 &lt;code&gt;Father&lt;/code&gt; 对象，&lt;code&gt;Father f2 = new Father()&lt;/code&gt;; 子类 &lt;code&gt;s2&lt;/code&gt; 引用不能指向父类对象。&lt;/p&gt;

&lt;p&gt;直接上代码：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;package Polymorphic;

class EatKaoShanYao {
    EatKaoShanYao () {
        System.out.println(&quot;吃烤山药之前...&quot;);
        eat();
        System.out.println(&quot;吃烤山药之后(熊孩子懵逼中)....&quot;);
    }
    public void eat() {
        System.out.println(&quot;7岁半就喜欢吃烤山药&quot;);
    }
}
public class KaoShanYao extends EatKaoShanYao {
    private String Weight = &quot;110斤&quot;;
    public KaoShanYao(String Weight) {
        this.Weight = Weight;
        System.out.println(&quot;熊孩子的体重：&quot; + this.Weight);
    }

    public void eat() { // 子类覆盖父类方法
        System.out.println(&quot;熊孩子吃烤山药之前的体重是：&quot; + this.Weight);
    }

    //Main方法
    public static void main(String[] args) {
           EatKaoShanYaok = new KaoShanYao(&quot;250斤&quot;);
                      
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;童鞋们可以试想一下运行结果，再看下面的输出结果&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt; 运行结果：
                吃烤山药之前...
                熊孩子吃烤山药之前的体重是：null
                吃烤山药之后(熊孩子懵逼中)....
                熊孩子的体重：250斤&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;是不是很疑惑？结果为啥是这样？你看，熊孩子又懵逼了，Why？&lt;/p&gt;
&lt;p&gt;原因其实很简单，因为在创建子类对象时，会先去调用父类的构造器，而父类构造器中又调用了被子类覆盖的多态方法，由于父类并不清楚子类对象中的属性值是什么（先初始化父类的时候还没开始初始化子类），于是把&lt;code&gt;String&lt;/code&gt;类型的属性暂时初始化为默认值&lt;code&gt;null&lt;/code&gt;，然后再调用子类的构造器（这个时子类构造器已经初始&lt;code&gt;Weight&lt;/code&gt;属性，所以子类构造器知道熊孩子的体重&lt;code&gt;Weight&lt;/code&gt;是250）。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果有什么不理解的可以及时告诉我，楼主一直都在，还有如果楼主哪里写错了或者理解错了，请及时告诉我，一定要告诉我！！！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;讲了这么久的多态，我觉得其优点已经不明觉厉了。但是还是来聊聊多态在实际开发的过程中的优点。在实际开发中父类类型作为方法形式参数，传递子类对象给方法，进行方法的调用，更能体现出多态的扩展 性与便利。&lt;br/&gt;为了更好的对比出多态的优点，下面程序不使用多态，代码如下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;package Demo;
//父类：动物类
class Animal{
    public void eat(){
        System.out.println(&quot;eat&quot;);
    }
}
//猫类
class Cat {
    //方法重写
    public void eat(){
        System.out.println(&quot;猫吃猫骨头&quot;);
    }
    public void call(){
        System.out.println(&quot;猫叫&quot;);
    }
}
//狗类
class Dog {
    public void eat(){
        System.out.println(&quot;狗吃狗骨头&quot;);
    }
    public void call(){
        System.out.println(&quot;狗叫&quot;);
    }
}

//针对动物操作的工具类
class AnimalTool{

    private AnimalTool(){}//把工具类的构造方法私有，防止别人创建该类的对象。

    //调用猫的功能
    public static void catLife(Cat c){  //工具类，方法就写成static的，然后直接在测试类：工具类名.方法 使用。
        c.eat();
        c.call();
    }
    //调用狗的功能
    public static void dogLife(Dog d){
        d.eat();
        d.call();
    }
}

public class Test{
    public static void main(String[] args){

        Cat c= new Cat();
        AnimalTool.catLife(c);

        Dog d= new Dog();
        AnimalTool.dogLife(d);

    }
}
运行结果：
        猫吃猫骨头
        猫叫
        狗吃狗骨头
        狗叫&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里只写了两只动物，如果再来一种动物猪，则需要定义个猪类，提供猪的两个方法，再到工具类中添加对应的&lt;code&gt;XXLife&lt;/code&gt;方法，这三步都是必须要做的，而且每多一种动物就需要在工具类中添加一种一个对应的&lt;code&gt;XXLife&lt;/code&gt;方法，这样维护起来就很麻烦了，毕竟动物种类成千上万！崩溃吧，没事多态来拯救你，如下使用多态代码：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;package Demo;
//父类：动物类
class Animal{
    public void eat(){
        System.out.println(&quot;eat&quot;);
    }
    public void call(){
        System.out.println(&quot;call&quot;);
    }
}
//猫类
class Cat extends Animal {
    //方法重写
    public void eat(){
        System.out.println(&quot;猫吃猫骨头&quot;);
    }
    public void call(){
        System.out.println(&quot;猫叫&quot;);
    }
}
//狗类
class Dog extends Animal {
    public void eat(){
        System.out.println(&quot;狗吃狗骨头&quot;);
    }
    public void call(){
        System.out.println(&quot;狗叫&quot;);
    }
}

//针对动物操作的工具类
class AnimalTool{

    private AnimalTool(){}//最好把工具类的构造方法私有，防止别人创建该类的对象。该类是工具类。

    //调用所以动物的功能
    public static void animalLife(Animal a){  //工具类，方法就写成static的，然后直接在测试类：工具类名.方法 使用。
        a.eat();
        a.call();
    }

}

public class Test{
    public static void main(String[] args){

        Cat c= new Cat();
        AnimalTool.animalLife(c);

        Dog d= new Dog();
        AnimalTool.animalLife(d);
运行结果：
        猫吃猫骨头
        猫叫
        狗吃狗骨头
        狗叫
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注意： 上面动物类都继承了&lt;code&gt;animal&lt;/code&gt;父类&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个时候再分析，如果再来一种动物猪，则需要定义个猪类，提供猪的两个方法，再继承&lt;code&gt;Animal&lt;/code&gt;父类，这个时候就不需要在工具类中添加对应的&lt;code&gt;XxLife&lt;/code&gt;方法，只写一个&lt;code&gt;animalLife&lt;/code&gt;方法即可，而且每多一种动物都不需要在工具类中添加对应的&lt;code&gt;XxLife&lt;/code&gt;方法，这样维护起来就很乐观了。&lt;/p&gt;
&lt;p&gt;由于多态特性的支持，&lt;code&gt;animalLife&lt;/code&gt;方法的Animal类型，是&lt;code&gt;Cat&lt;/code&gt;和&lt;code&gt;Dog&lt;/code&gt;的父类类型，父类类型接收子类对象，当 然可以把&lt;code&gt;Cat&lt;/code&gt;对象和&lt;code&gt;Dog&lt;/code&gt;对象传递给方法。 当&lt;code&gt;eat&lt;/code&gt;和&lt;code&gt;call&lt;/code&gt;方法执行时，多态规定，执行的是子类重写的方法，那么效果自然与&lt;code&gt;Animal&lt;/code&gt;的子类中的&lt;code&gt;eat&lt;/code&gt;、&lt;code&gt;call&lt;/code&gt;方法一致， 所以&lt;code&gt;animalLife&lt;/code&gt;完全可以替代以上两方法。 不仅仅是替代，在扩展性方面，无论之后再多的子类出现，我们都不需要编写&lt;code&gt;XxLife&lt;/code&gt;方法了，直接使用 &lt;code&gt;animalLife&lt;/code&gt;就可以完成。 所以，多态的好处，体现在可以使程序编写的更简单，并有良好的扩展。&lt;/p&gt;

&lt;p&gt;看到这里，相信童鞋们多多少少都应该对多态都一定的了解了，都应该很有信心解决开篇的难题了吧，我可以很负责的告诉你，文章看到这里，你依旧解决不了这几个问题，不要问我为啥知道，你可以试着再做一遍，代码贴在下面：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;package Polymorphic;
//爷爷类
class Ye {
    public String show(Sun obj) {
        return (&quot;Ye and Sun&quot;);
    }

    public String show(Ye obj) {
        return (&quot;Ye and Ye&quot;);
    }

}
//爸爸类
class Fu extends Ye {
    public String show(Fu obj) {
        return (&quot;Fu and Fu&quot;);
    }

    public String show(Ye obj) {
        return (&quot;Fu and Ye&quot;);
    }
}
//儿子类
class Zi extends Fu {

}
//孙子类
class Sun extends Fu {

}

public class PolymorphicTest {
    public static void main(String[] args) {
         Ye y = new Ye();
        Ye y2 = new Fu(); //向上
        Fu f = new Fu();
        Zi z = new Zi();
        Sun s = new Sun();


        System.out.println(&quot;第一题 &quot; + y.show(f));
        System.out.println(&quot;第二题 &quot; + y.show(z));
        System.out.println(&quot;第三题 &quot; + y.show(s));
        System.out.println(&quot;第四题 &quot; + y2.show(f));  //到这里挂了？？？
        System.out.println(&quot;第五题 &quot; + y2.show(z));
        System.out.println(&quot;第六题 &quot; + y2.show(s));
        System.out.println(&quot;第七题 &quot; + f.show(f));
        System.out.println(&quot;第八题 &quot; + f.show(z));
        System.out.println(&quot;第九题 &quot; + f.show(s));
     
    }

打印结果：
    第一题 Ye and Ye
    第二题 Ye and Ye
    第三题 Ye and Sun
    第四题 Fu and Ye
    第五题 Fu and Ye
    第六题 Ye and Sun
    第七题 Fu and Fu
    第八题 Fu and Fu
    第九题 Ye and Sun
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;要想理解上面这个例子，童鞋们必须读懂这句话：&lt;span&gt;&lt;strong&gt;当父类对象引用变量引用子类对象时，被引用对象的类型决定了调用谁的成员方法，引用变量类型决定可调用的方法。首先会先去可调用的方法的父类中寻找，找到了就执行子类中覆盖的该方法，就算子类中有现成的该方法，它同样也会去父类中寻找，早到后未必执行子类中有现成的方法，而是执行重写在父类中找到的方法的子类方法（这里的子类也就是最后决定调用的类方法）。&lt;/strong&gt;&lt;/span&gt;你是不是晕了？读着都觉得拗口，要理解可就拗的不是口了而是拗头 ~啥玩意没听过这个词~ 咳咳，问题不大，楼主来通俗的给大家讲解，让大家理解。&lt;/p&gt;
&lt;p&gt;还记不记得楼主之前定义向上转型是怎么定义的？&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;【v8提示】 向上转型：多态本身是子类类型向父类类型向上转换的过程，其中，这个过程是默认的。你可以把这个过程理解为基本类型的小类型转大类型自动转换，不需要强制转换。 当&lt;span&gt;&lt;strong&gt;父类引用指向一个子类对象时，便是向上转型&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可是，你真的理解了咩？什么叫做父类对象引用变量引用子类对象？其实还得从下面这句话找头绪&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;向上转型定义：多态本身是子类类型向父类类型向上转换的过程，其中，这个过程是默认的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;就好比&lt;code&gt;Father f = new Son()&lt;/code&gt;；有的童鞋就会说这个f也算是父类的对象引用？如果按字面理解是子类的引用只不过该引用的类型为&lt;code&gt;Father&lt;/code&gt;类型？这时你就大错特错了。&lt;/p&gt;
&lt;p&gt;我们把向上转型定义简化一下理解一下，简化如下：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;子类类型默认向父类类型向上转换的过程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;现在明白了咩？这句话可以理解为&lt;code&gt;Father f = new Son()&lt;/code&gt;这句代码原本是&lt;code&gt;Father f = （Father ）new Son()&lt;/code&gt;这样子的只是这个转换过程是默认自动转的，总的来说也就是 &lt;code&gt;new Son()&lt;/code&gt;其实本质就是&lt;code&gt;new Father&lt;/code&gt;，所以&lt;code&gt;f&lt;/code&gt;其实就是父类对象引用！这个时候再来拆开理解下面这段话&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;当父类对象引用变量引用子类对象时&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其中&lt;span&gt;&lt;strong&gt;父类对象引用变量&lt;/strong&gt;&lt;/span&gt;指的就是&lt;code&gt;f&lt;/code&gt;，&lt;span&gt;&lt;strong&gt;子类对象&lt;/strong&gt;&lt;/span&gt;指的就是&lt;code&gt;new Son（）&lt;/code&gt;，所以加起来就是当f引用&lt;code&gt;new Son（）&lt;/code&gt;时&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;被引用对象的类型决定了调用谁的成员方法，引用变量类型决定可调用的方法。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里的 &lt;span&gt;&lt;strong&gt;被引用对象的类型&lt;/strong&gt;&lt;/span&gt;则是指&lt;code&gt;new Son（）&lt;/code&gt;对象中的&lt;code&gt;Son&lt;/code&gt;类型， &lt;span&gt;&lt;strong&gt;引用变量类型&lt;/strong&gt;&lt;/span&gt;则是指&lt;code&gt;f&lt;/code&gt;的类型&lt;code&gt;Father&lt;/code&gt;类型&lt;/p&gt;
&lt;p&gt;好了总结关联起来就是当：&lt;code&gt;f&lt;/code&gt;引用&lt;code&gt;new Son（）&lt;/code&gt;时，&lt;code&gt;Son&lt;/code&gt;决定了调用它的成员方法，&lt;code&gt;Father&lt;/code&gt;决定可调用&lt;code&gt;Father&lt;/code&gt;中的方法。所以以&lt;code&gt;Father f = new Son()&lt;/code&gt;举例，简单来说就是&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191010093700519.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191013092858645.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;

&lt;p&gt;前三个并没有涉及到多态（向上转型），所以只会调用&lt;code&gt;yeye&lt;/code&gt;本类的方法，这里只要掌握继承的知识就OK了。&lt;/p&gt;
&lt;p&gt;讲解第四题之前，你的答案是不是&lt;code&gt;&quot;Fu and Fu&quot;&lt;/code&gt;？来了喔，马上让你巅覆对多态的人生观！&lt;/p&gt;
&lt;p&gt;分析第四题，首先&lt;code&gt;Ye y2 = new Fu()&lt;/code&gt;; 向上转型了，所以首先会去&lt;code&gt;Fu&lt;/code&gt;类的父类&lt;code&gt;Ye&lt;/code&gt;类中找&lt;code&gt;show(f)&lt;/code&gt;方法，找到了&lt;code&gt;show(Ye obj)&lt;/code&gt;方法，之后回到&lt;code&gt;Fu&lt;/code&gt;类中看是否有&lt;code&gt;show(Ye obj)&lt;/code&gt;重写方法，发现&lt;code&gt;Fu&lt;/code&gt;类有&lt;code&gt;show(Ye obj)&lt;/code&gt;方法（重写），所以最后执行了&lt;code&gt;&quot;Fu and Ye&quot;&lt;/code&gt;，你get了咩？&lt;/p&gt;
&lt;p&gt;分析第五题，其实第五题和第四题基本差不多，第四题是&lt;code&gt;y2.show(f)&lt;/code&gt;；第五题是&lt;code&gt;y2.show(z)&lt;/code&gt;；只是&lt;code&gt;show&lt;/code&gt;的方法参数不同，相同的是&lt;code&gt;f&lt;/code&gt;和&lt;code&gt;z&lt;/code&gt;在&lt;code&gt;Ye&lt;/code&gt;类中找的都是&lt;code&gt;show(Ye obj)&lt;/code&gt;方法，所以，最终第四题和第五题结果一致！&lt;/p&gt;
&lt;p&gt;分析第六题，第六题其实挺有趣，首先&lt;code&gt;y2.show(s)&lt;/code&gt;，到Ye类中找到&lt;code&gt;show(Sun obj)&lt;/code&gt;，之后在子类中看有没有重写，发现并没有&lt;code&gt;show(Sun obj)&lt;/code&gt;重写方法，确定没有咩？别忘了这是继承，子类&lt;code&gt;Fu&lt;/code&gt;中默认有着父类&lt;code&gt;Ye&lt;/code&gt;的方法，只是没有表面表示出来，从另一角度出发，&lt;code&gt;Fu&lt;/code&gt;类中默认重写了一个&lt;code&gt;show(Sun obj)&lt;/code&gt;方法，就算不写也是存在的，所以运行结果为&lt;code&gt;&quot;Ye and Sun&quot;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;第七、八题就不分析了，毕竟也没有涉及到向上转型（多态）。&lt;/p&gt;
&lt;p&gt;最后分析一下第九题，有的童鞋就要打楼主了，第九题不也是没有涉及到向上转型（多态）吗，楼主你个星星（**），当然，楼主就算背着黑锅也要分析第九题~就是这么傲娇~，确实没有涉及到向上转型（多态），我要讲的原因很简单，因为我觉得还是很有必要！首先&lt;code&gt;f.show(s)&lt;/code&gt;不涉及多态，它只会调用自己类（&lt;code&gt;Fu&lt;/code&gt;）的方法，但是你会发现&lt;code&gt;Fu&lt;/code&gt;中并没有&lt;code&gt;show(s)&lt;/code&gt;，唉唉唉，我运行你重新组织下语言，又忘了？这是继承啊，它有默认父类&lt;code&gt;Ye&lt;/code&gt;中的&lt;code&gt;show(Sun obj)&lt;/code&gt;方法鸭！好了到这里，我总结出一点，你多态以及没得问题了，不过你继承方面知识薄弱啊，不行不行楼主得给你补补，还在犹豫什么鸭，快来补补继承知识！！！&lt;a href=&quot;https://blog.csdn.net/qq_44543508/article/details/102375196&quot;&gt;【java基础】java继承从“我爸是李刚”讲起&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;本文的最后，我只是个人对多态的理解，楼主只是个java小白，叫我老白也行，不一定全部正确，如果有什么错误请一定要告诉我，感激不尽感激不尽感激不尽！！！欢迎指正~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最后的最后，如果本文对你有所帮助就点个爱心支持一下吧 ~佛系报大腿~&lt;/p&gt;
&lt;p&gt;欢迎各位关注我的公众号，一起探讨技术，向往技术，追求技术...&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191028085725979.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 15 Nov 2019 23:32:00 +0000</pubDate>
<dc:creator>宜春</dc:creator>
<og:description>@[toc] 我不想知道各位理解java多态没有烤山药的存在，java香不香的问题了，我不要你们认为，我只要我觉得 (感觉要被打....) 在博主认为多态绝对是面向对象的第三大特性中让很多小白同学以及</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yichunguo/p/11870464.html</dc:identifier>
</item>
<item>
<title>C语言程序设计100例之（8）：尼科彻斯定理 - aTeacher</title>
<link>http://www.cnblogs.com/cs-whut/p/11870418.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cs-whut/p/11870418.html</guid>
<description>&lt;h4&gt;&lt;span&gt;例8    尼科彻斯定理&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;尼科彻斯定理可以叙述为：任何一个整数的立方都可以表示成一串连续的奇数的和。需要注意的是，这些奇数一定是连续的，如：1，3，5，7，9，…。&lt;/p&gt;
&lt;p&gt;例如，对于整数5，5*5*5=125=21+23+25+27+29。&lt;/p&gt;
&lt;p&gt;对于整数6，216=31+33+35+37+39+41，&lt;/p&gt;
&lt;p&gt;也可以表示为216=7+9+11+13+15+17+19+21+23+25+27+29。&lt;/p&gt;
&lt;p&gt;请你编写程序对这个定理进行验证。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个整数n（2≤n≤1000）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将n的立方表示为一串连续的奇数的和，具体格式见输出样例。若有多种表示方式，任意输出一种即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入样例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;29&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出样例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;29*29*29=24389=813+815+817+819+821+823+825+827+829+831+833+835+837+839+841+843+845+847+849+851+853+855+857+859+861+863+865+867+869&lt;/p&gt;
&lt;h5&gt;        &lt;span&gt;（1）编程思路1。&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;        先计算输入数n的立方num，然后从1（用变量i记录）开始累计和sum，累计每次j加2保证下个数也为奇数，如果累加和sum大于立方数num时，跳出本次循环，进行下一次的尝试（i=3或5、7、…开始累积和）。当找到后，记录开始位置（即i），结束位置（即j），输出。&lt;/p&gt;
&lt;p&gt;        程序写成一个嵌套的二重循环。外循环i控制累计和的起点，内循环累计i、i+2、i+4、…的和。&lt;/p&gt;
&lt;h5&gt;&lt;span&gt;      （2）源程序1。&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;#include&amp;lt;stdio.h&amp;gt;&lt;/p&gt;
&lt;p&gt;int main()&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;    int n,num,sum,i,j,k,flag;&lt;/p&gt;
&lt;p&gt;    while(1)&lt;/p&gt;
&lt;p&gt;    {&lt;/p&gt;
&lt;p&gt;         scanf(&quot;%d&quot;,&amp;amp;n);&lt;/p&gt;
&lt;p&gt;         if(n==0)  break;&lt;/p&gt;
&lt;p&gt;         num = n * n * n;&lt;/p&gt;
&lt;p&gt;         flag=0;&lt;/p&gt;
&lt;p&gt;         for(i=1; i&amp;lt;num &amp;amp;&amp;amp; flag==0; i=i+2)&lt;/p&gt;
&lt;p&gt;        {&lt;/p&gt;
&lt;p&gt;            sum=0;&lt;/p&gt;
&lt;p&gt;            for(j=i; j&amp;lt;num; j=j+2)&lt;/p&gt;
&lt;p&gt;            {&lt;/p&gt;
&lt;p&gt;               sum += j;&lt;/p&gt;
&lt;p&gt;               if(sum == num)&lt;/p&gt;
&lt;p&gt;              {&lt;/p&gt;
&lt;p&gt;                  printf(&quot;%d*%d*%d=%d=%d&quot;,n,n,n,num,i);&lt;/p&gt;
&lt;p&gt;                  for (k=i+2; k&amp;lt;=j;k+=2)&lt;/p&gt;
&lt;p&gt;                      printf(&quot;+%d&quot;,k);&lt;/p&gt;
&lt;p&gt;                  printf(&quot;\n&quot;);&lt;/p&gt;
&lt;p&gt;                  flag=1;&lt;/p&gt;
&lt;p&gt;                  break;&lt;/p&gt;
&lt;p&gt;              }&lt;/p&gt;
&lt;p&gt;              else if (sum &amp;gt; num)&lt;/p&gt;
&lt;p&gt;                  break;&lt;/p&gt;
&lt;p&gt;           }&lt;/p&gt;
&lt;p&gt;       }&lt;/p&gt;
&lt;p&gt;    }&lt;/p&gt;
&lt;p&gt;    return 0;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;h5&gt;&lt;span&gt;      （3）编程思路2。&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;        源程序1的思路是通过试探的方法来验证尼科彻斯定理，采用二重循环实现。&lt;/p&gt;
&lt;p&gt;        实际上，n的立方一定可以表示为一个等差数列的各项和，该等差数列的首项为n*n-n+1，公差为2，项数为n。&lt;/p&gt;
&lt;p&gt;        按等差数列的求和公式知该数列的和为：&lt;/p&gt;
&lt;p&gt;        [(n*n-n+1)+( n*n-n+1)+ 2 (n-1)]*n/2 =n*n*n&lt;/p&gt;
&lt;p&gt;        因此，直接用循环输出这个等差数列的各项即可。&lt;/p&gt;
&lt;h5&gt;&lt;span&gt;       （4）源程序2。&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;#include&amp;lt;stdio.h&amp;gt;&lt;/p&gt;
&lt;p&gt;int main()&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;    int n,a,i;&lt;/p&gt;
&lt;p&gt;    while(1)&lt;/p&gt;
&lt;p&gt;    {&lt;/p&gt;
&lt;p&gt;         scanf(&quot;%d&quot;,&amp;amp;n);&lt;/p&gt;
&lt;p&gt;         if(n==0)  break;&lt;/p&gt;
&lt;p&gt;        // 输出等差数列，首项为n*n-n+1，公差为2，项数为n&lt;/p&gt;
&lt;p&gt;        a=n*n-n+1;&lt;/p&gt;
&lt;p&gt;        printf(&quot;%d*%d*%d=%d=%d&quot;,n,n,n,n*n*n,a);&lt;/p&gt;
&lt;p&gt;        for (i=1; i&amp;lt;n;i++)&lt;/p&gt;
&lt;p&gt;             printf(&quot;+%d&quot;,a+i*2);&lt;/p&gt;
&lt;p&gt;        printf(&quot;\n&quot;);&lt;/p&gt;
&lt;p&gt;    }&lt;/p&gt;
&lt;p&gt;    return 0;&lt;/p&gt;
&lt;p&gt;} &lt;/p&gt;
&lt;h4&gt;&lt;span&gt;习题8&lt;/span&gt;&lt;/h4&gt;
&lt;h5&gt;&lt;span&gt;8-1  谷角猜想&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;日本数学家谷角静夫在研究自然数时发现了一个奇怪现象：对于任意一个自然数 n ，若 n 为偶数，则将其除以 2 ；若 n 为奇数，则将其乘以 3 ，然后再加 1 。如此经过有限次运算后，总可以得到自然数 1 。人们把谷角静夫的这一发现叫做“谷角猜想”。&lt;/p&gt;
&lt;p&gt;请你编写程序对这个猜想进行验证。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个自然数n。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;把 n 经过有限次运算后，最终变成自然数 1 的全过程输出。具体格式见输出样例。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入样例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;34&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出样例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;34/2=17&lt;/p&gt;
&lt;p&gt;17*3+1=52&lt;/p&gt;
&lt;p&gt;52/2=26&lt;/p&gt;
&lt;p&gt;26/2=13&lt;/p&gt;
&lt;p&gt;13*3+1=40&lt;/p&gt;
&lt;p&gt;40/2=20&lt;/p&gt;
&lt;p&gt;20/2=10&lt;/p&gt;
&lt;p&gt;10/2=5&lt;/p&gt;
&lt;p&gt;5*3+1=16&lt;/p&gt;
&lt;p&gt;16/2=8&lt;/p&gt;
&lt;p&gt;8/2=4&lt;/p&gt;
&lt;p&gt;4/2=2&lt;/p&gt;
&lt;p&gt;2/2=1&lt;/p&gt;
&lt;p&gt;         （1）编程思路。&lt;/p&gt;
&lt;p&gt;        定义迭代变量为n，按照谷角猜想的内容，可以得到两种情况下的迭代关系式：当 n 为偶数时，n=n/2 ；当 n 为奇数时， n=n*3+1 。&lt;/p&gt;
&lt;p&gt;        这就是需要计算机重复执行的迭代过程。这个迭代过程需要重复执行多少次，才能使迭代变量 n 最终变成自然数 1 ，这是我们无法计算出来的。因此，还需进一步确定用来结束迭代过程的条件。由于对任意给定的一个自然数 n ，只要经过有限次运算后，能够得到自然数 1 ，从而完成验证工作。因此，用来结束迭代过程的条件可以定义为： n==1 。&lt;/p&gt;
&lt;p&gt;       （2）源程序。&lt;/p&gt;
&lt;p&gt;#include&amp;lt;stdio.h&amp;gt;&lt;/p&gt;
&lt;p&gt;int main()&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;   unsigned int data;&lt;/p&gt;
&lt;p&gt;   scanf(&quot;%d&quot;,&amp;amp;data);&lt;/p&gt;
&lt;p&gt;   while(data!=1)&lt;/p&gt;
&lt;p&gt;   {&lt;/p&gt;
&lt;p&gt;        if((data%2==0))&lt;/p&gt;
&lt;p&gt;        {&lt;/p&gt;
&lt;p&gt;                 printf(&quot;%d/2=%d\n&quot;,data,data/2);&lt;/p&gt;
&lt;p&gt;                 data/=2;&lt;/p&gt;
&lt;p&gt;         }&lt;/p&gt;
&lt;p&gt;        else&lt;/p&gt;
&lt;p&gt;        {&lt;/p&gt;
&lt;p&gt;                printf(&quot;%d*3+1=%d\n&quot;,data,data*3+1);&lt;/p&gt;
&lt;p&gt;                data=data*3+1;&lt;/p&gt;
&lt;p&gt;        }&lt;/p&gt;
&lt;p&gt;   }&lt;/p&gt;
&lt;p&gt;   return 0;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;h5&gt;&lt;span&gt;8-2  四方定理&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数论中著名的“四方定理”是：所有自然数至多只要用四个不小于0的整数的平方和就可以表示。&lt;/p&gt;
&lt;p&gt;编写一个程序验证此定理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个自然数n。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;把自然数 n 表示为四个数的平方和。具体格式见输出样例。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入样例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;147&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出样例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;7*7+7*7+7*7+0*0=147&lt;/p&gt;
&lt;p&gt;8*8+7*7+5*5+3*3=147&lt;/p&gt;
&lt;p&gt;9*9+5*5+5*5+4*4=147&lt;/p&gt;
&lt;p&gt;9*9+7*7+4*4+1*1=147&lt;/p&gt;
&lt;p&gt;9*9+8*8+1*1+1*1=147&lt;/p&gt;
&lt;p&gt;11*11+4*4+3*3+1*1=147&lt;/p&gt;
&lt;p&gt;11*11+5*5+1*1+0*0=147&lt;/p&gt;
&lt;p&gt;12*12+1*1+1*1+1*1=147&lt;/p&gt;
&lt;p&gt;        （1）编程思路。&lt;/p&gt;
&lt;p&gt;        对于待验证的自然数n，用四个变量i、j、k、l采用试探的方法，穷举进行计算，满足要求（i *i + j * j + k * k + l * l == n）时输出计算结果。&lt;/p&gt;
&lt;p&gt;        在穷举时，不妨设i≥j≥k≥l。因此，穷举的范围可确定为：&lt;/p&gt;
&lt;p&gt;1 ≤ i ≤ n/2&lt;/p&gt;
&lt;p&gt;0 ≤ j ≤ i&lt;/p&gt;
&lt;p&gt;0 ≤ k ≤ j&lt;/p&gt;
&lt;p&gt;0 ≤ l ≤ k&lt;/p&gt;
&lt;p&gt;       （2）源程序。&lt;/p&gt;
&lt;p&gt;#include&amp;lt;stdio.h&amp;gt;&lt;/p&gt;
&lt;p&gt;int main()&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;    int n,i,j,k,l;&lt;/p&gt;
&lt;p&gt;    scanf(&quot;%d&quot;,&amp;amp;n);&lt;/p&gt;
&lt;p&gt;    for (i = 1; i &amp;lt;= n/2; i++)          // 对i，j，k，l进行穷举&lt;/p&gt;
&lt;p&gt;        for (j = 0; j &amp;lt;= i; j++)&lt;/p&gt;
&lt;p&gt;            for (k = 0; k &amp;lt;= j; k++)&lt;/p&gt;
&lt;p&gt;                for (l = 0; l &amp;lt;= k; l++)&lt;/p&gt;
&lt;p&gt;                    if (i *i + j * j + k * k + l * l == n)&lt;/p&gt;
&lt;p&gt;                     {&lt;/p&gt;
&lt;p&gt;                          printf(&quot;%d*%d+%d*%d+%d*%d+%d*%d=%d\n&quot;,i,i,j,j,k,k,l,l,n);&lt;/p&gt;
&lt;p&gt;                      } &lt;/p&gt;
&lt;p&gt;   return 0;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;h5&gt;&lt;span&gt;8-3  卡布列克运算&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;问题描述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所谓卡布列克运算，是指任意一个四位数，只要它们各个位上的数字不全相同，就有这样的规律：&lt;/p&gt;
&lt;p&gt;（1）把组成这个四位数的四个数字由大到小排列，形成由这四个数字构成的最大的四位数；&lt;/p&gt;
&lt;p&gt;（2）把组成这个四位数的四个数字由小到大排列，形成由这四个数字构成的最小的四位数（如果四个数字中含有0，则此数不足四位）；&lt;/p&gt;
&lt;p&gt;（3）求出以上两数之差，得到一个新的四位数。&lt;/p&gt;
&lt;p&gt;重复以上过程，总能得到最后的结果是 6174。&lt;/p&gt;
&lt;p&gt;例如，n= 3280，验证结果为：8320-238=8082  8820-288=8532  8532-2358=6174&lt;/p&gt;
&lt;p&gt;编写一个程序对卡布列克运算进行验证。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个各位上的数字不全相同的四位数n。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出要求&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;把 n 经过有限次卡布列克运算后，最终变成6174的全过程输出。具体格式见输出样例。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入样例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2019&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出样例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;9210-129=9081&lt;/p&gt;
&lt;p&gt;9810-189=9621&lt;/p&gt;
&lt;p&gt;9621-1269=8352&lt;/p&gt;
&lt;p&gt;8532-2358=6174&lt;/p&gt;
&lt;p&gt; YES&lt;/p&gt;
&lt;p&gt;       （1）编程思路。&lt;/p&gt;
&lt;p&gt;为实现验证程序，编写4个函数。&lt;/p&gt;
&lt;p&gt;void parse_sort(int each[],int num) 将num分解为各位数字并排序后存入数组each[]中。&lt;/p&gt;
&lt;p&gt;int minD(int each[]) 求数组each中的4个数字可组成的最大数。&lt;/p&gt;
&lt;p&gt;int maxD(int each[]) 求数组each中的4个数字可组成的最小数。&lt;/p&gt;
&lt;p&gt;int pow10_int(int n) 求10的N次方。&lt;/p&gt;
&lt;p&gt;     （2）源程序。&lt;/p&gt;
&lt;p&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/p&gt;
&lt;p&gt;#define N 4&lt;/p&gt;
&lt;p&gt;int pow10_int(int n);  // 求10的N次方&lt;/p&gt;
&lt;p&gt;void parse_sort(int each[],int num); // 把num分解各个位上的数后存入数组each[]中&lt;/p&gt;
&lt;p&gt;int minD(int each[]);  // 求数组each可组成的最大数&lt;/p&gt;
&lt;p&gt;int maxD(int each[]);  // 求数组each可组成的最小数&lt;/p&gt;
&lt;p&gt;int main()&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;    int number,max,min;&lt;/p&gt;
&lt;p&gt;    int each[N];&lt;/p&gt;
&lt;p&gt;    scanf(&quot;%d&quot;,&amp;amp;number);&lt;/p&gt;
&lt;p&gt;    while(number!=6174)&lt;/p&gt;
&lt;p&gt;    {&lt;/p&gt;
&lt;p&gt;        parse_sort(each,number);&lt;/p&gt;
&lt;p&gt;        max=maxD(each);&lt;/p&gt;
&lt;p&gt;                   min=minD(each);&lt;/p&gt;
&lt;p&gt;                   number=max-min;&lt;/p&gt;
&lt;p&gt;                   printf(&quot;%d-%d=%d\n&quot;,max,min,number);&lt;/p&gt;
&lt;p&gt;    }&lt;/p&gt;
&lt;p&gt;    printf(&quot; YES\n&quot;);&lt;/p&gt;
&lt;p&gt;    return 0;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;int pow10_int(int n)  // 求10的N次方的函数&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;    int sum=1;&lt;/p&gt;
&lt;p&gt;    for(int i=0;i&amp;lt;n;i++)&lt;/p&gt;
&lt;p&gt;         sum=sum*10;&lt;/p&gt;
&lt;p&gt;    return sum;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;void parse_sort(int each[],int num) // 把num分解各个位上的数后存入数组each[]中&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;         int m,i,j,t;&lt;/p&gt;
&lt;p&gt;          for (i=0;i&amp;lt;N;i++)&lt;/p&gt;
&lt;p&gt;                    each[i]=0;&lt;/p&gt;
&lt;p&gt;          i=0;&lt;/p&gt;
&lt;p&gt;         while(num!=0)&lt;/p&gt;
&lt;p&gt;          {&lt;/p&gt;
&lt;p&gt;               m=num%10;   num=num/10;&lt;/p&gt;
&lt;p&gt;              each[i++]=m;&lt;/p&gt;
&lt;p&gt;         }&lt;/p&gt;
&lt;p&gt;         for(i=0;i&amp;lt;N-1;i++)&lt;/p&gt;
&lt;p&gt;             for (j=0;j&amp;lt;N-1-i;j++)&lt;/p&gt;
&lt;p&gt;                     if (each[j]&amp;gt;each[j+1])&lt;/p&gt;
&lt;p&gt;                     {&lt;/p&gt;
&lt;p&gt;                              t=each[j];&lt;/p&gt;
&lt;p&gt;                              each[j]=each[j+1];&lt;/p&gt;
&lt;p&gt;                              each[j+1]=t;&lt;/p&gt;
&lt;p&gt;                     }&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;int minD(int each[])  // 求数组each可组成的最大数&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;    int sum=0,i;&lt;/p&gt;
&lt;p&gt;    for(i=0;i&amp;lt;N;i++)&lt;/p&gt;
&lt;p&gt;        sum+=each[i]*pow10_int( (N-1-i) );&lt;/p&gt;
&lt;p&gt;    return sum;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;int maxD(int each[])  // 求数组each可组成的最小数&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;    int sum=0,i;&lt;/p&gt;
&lt;p&gt;    for(i=0;i&amp;lt;N;i++)&lt;/p&gt;
&lt;p&gt;        sum=sum+each[i]*pow10_int(i);&lt;/p&gt;
&lt;p&gt;    return sum;&lt;/p&gt;
&lt;p&gt;} &lt;/p&gt;
</description>
<pubDate>Fri, 15 Nov 2019 21:33:00 +0000</pubDate>
<dc:creator>aTeacher</dc:creator>
<og:description>例8 尼科彻斯定理 题目描述 尼科彻斯定理可以叙述为：任何一个整数的立方都可以表示成一串连续的奇数的和。需要注意的是，这些奇数一定是连续的，如：1，3，5，7，9，…。 例如，对于整数5，5*5*5=</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cs-whut/p/11870418.html</dc:identifier>
</item>
<item>
<title>Python面向对象 | 静态方法 staticmethod - PythonGirl</title>
<link>http://www.cnblogs.com/Summer-skr--blog/p/11801442.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Summer-skr--blog/p/11801442.html</guid>
<description>
&lt;p&gt;&lt;span&gt;&lt;strong&gt;静态方法是类中的函数，不需要实例。静态方法主要是用来存放逻辑性的代码，逻辑上属于类，但是和类本身没有关系，也就是说在静态方法中，不会涉及到类中的属性和方法的操作。可以理解为，静态方法是个独立的、单纯的函数，它仅仅托管于某个类的名称空间中，便于使用和维护。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;譬如，我想定义一个关于时间操作的类，其中有一个获取当前时间的函数。使用了静态方法，然而方法体中并没使用（也不能使用）类或实例的属性（或方法）。若要获得当前时间的字符串时，并不一定需要实例化对象，此时对于静态方法而言，所在类更像是一种名称空间。其实，我们也可以在类外面写一个同样的函数来做这些事，但是这样做就打乱了逻辑关系，也会导致以后代码维护困难。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; TimeTest(object):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, hour, minute, second):
        self.hour &lt;/span&gt;=&lt;span&gt; hour
        self.minute &lt;/span&gt;=&lt;span&gt; minute
        self.second &lt;/span&gt;=&lt;span&gt; second

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 各种方法省略&lt;/span&gt;
&lt;span&gt;
    @staticmethod  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 静态方法&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; showTime():
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; time.strftime(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%H:%M:%S&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, time.localtime())


&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(TimeTest.showTime())

t &lt;/span&gt;= TimeTest(2, 10, 10&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(t.showTime())

&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
执行输出：
21:05:43
21:05:43
&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;看下面代码，一半是面向过程，一半是面向对象。对于完全面向对象编程而言，不允许出现面向过程的代码。完全面向对象编程。先登录后实例化。还没有一个具体的对象的时候 就要执行login方法，这样是不合理的。需要将login()变成静态方法。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt; login():&lt;span&gt;pass&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;password&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;身份 -- 实例化&lt;/span&gt;

&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Student:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(self,name):&lt;span&gt;pass&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; login(self):&lt;span&gt;pass&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;python为我们内置了函数staticmethod来把类中的函数定义成静态方法，它不需要实例化。所以，连self参数都没有。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Student:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(self,name):&lt;span&gt;pass&lt;/span&gt;&lt;span&gt;

    @staticmethod
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; login&lt;span&gt;&lt;strong&gt;()&lt;/strong&gt;&lt;/span&gt;:  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; login就是一个类中的静态方法.静态方法没有默认参数,就当成普通的函数使用即可&lt;/span&gt;
        user = input(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;user :&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; user == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Tony&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;success&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;faild&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

Student.login()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1518468/201909/1518468-20190926211146516-1859415917.png&quot; alt=&quot;&quot; width=&quot;177&quot; height=&quot;103&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;当一个方法要使用对象的属性时就是用普通的方法；&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;当一个方法要使用类中的静态属性时，就是用类方法（classmethod）；&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;当一个方法要既不使用对象的属性也不使用类中的静态属性时，就可以使用staticmethod静态方法；&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Fri, 15 Nov 2019 17:59:00 +0000</pubDate>
<dc:creator>PythonGirl</dc:creator>
<og:description>静态方法是类中的函数，不需要实例。静态方法主要是用来存放逻辑性的代码，逻辑上属于类，但是和类本身没有关系，也就是说在静态方法中，不会涉及到类中的属性和方法的操作。可以理解为，静态方法是个独立的、单纯的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Summer-skr--blog/p/11801442.html</dc:identifier>
</item>
<item>
<title>如何从 0 到 1 构建个性化推荐？ - DataFunTalk</title>
<link>http://www.cnblogs.com/datafuntalk/p/11870357.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/datafuntalk/p/11870357.html</guid>
<description>&lt;p&gt;文章作者：曾钦榜 58同城 高级技术经理&lt;/p&gt;
&lt;p&gt;编辑整理：周晓侠&lt;/p&gt;
&lt;p&gt;内容来源：58技术沙龙&lt;/p&gt;
&lt;p&gt;出品社区：DataFun&lt;/p&gt;
&lt;p&gt;注：欢迎转载，转载请在留言区内留言。&lt;/p&gt;
&lt;p&gt;导读：随着科学技术的飞速发展，互联网被广泛应用于各个领域，而以互联网为基础的招聘模式也越来越受到企业的青睐。互联网招聘具有不受地域限制、覆盖面广、招聘成本低、针对性强、方便快捷、时效性强等优点，现已得到广泛应用，其中，58招聘是互联网招聘行业中规模最大的平台。今天主要跟大家分享下58招聘如何通过个性化推荐技术服务大规模求职者和招聘企业。分享题目是从零到一构建58招聘个性化推荐，主要通过以下三方面进行介绍：&lt;/p&gt;
&lt;p&gt;招聘业务介绍&lt;/p&gt;
&lt;p&gt;个性化推荐实践&lt;/p&gt;
&lt;p&gt;心得分享与规划&lt;/p&gt;
&lt;p&gt;——招聘业务介绍——&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;58招聘业务简介&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;2018年我国全国总人口13.9亿多，其中就业人口7.7亿，招聘基数庞大。三大产业就业人口占比分别26.11%，27.57%，46.32%，其中第三大产业占比最大，部分发达国家第三大产业占比已达到70%~80%，随着经济的发展，我国未来就业市场和就业分布将发生大的变化。2019年8月城镇调查显示我国失业率为5.2%，其中25~59岁失业率4.5%，同时每年有800多万的应届生加入就职市场。58招聘作为我国互联网招聘行业之首，每天服务于千万级求职者和大中小企业，平台每天生成千万级连接，促成大量求职者求职成功。&lt;/p&gt;
&lt;p&gt;58招聘平台主要服务于求职者和招聘方，接下来主要通过求职者的角度介绍用户在整个平台流转的大致流程，具体如下：&lt;/p&gt;
&lt;p&gt;基于求职偏好搜索职位并点击查看详情。&lt;/p&gt;
&lt;p&gt;投递有意向职位，或通过平台在线微聊工具、电话与招聘方做进一步沟通。&lt;/p&gt;
&lt;p&gt;双方达成共识后，进行面试与入职。&lt;/p&gt;
&lt;p&gt;相比传统推荐系统，58招聘的业务漏斗更长更深，并且有一部分转化平台无法完全捕捉，形成了58招聘个性化推荐开展的难点及挑战。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;58招聘推荐场景类型&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;58招聘推荐场景主要面向 C 端求职者和 B 端企业，推荐内容主要包括：职位推荐、标签推荐、企业推荐、简历推荐。&lt;/p&gt;
&lt;p&gt;C 端求职者的典型推荐场景包括：&lt;/p&gt;
&lt;p&gt;App 首页招聘大类页：主要包括职位专区聚合、职位 Feed 流。&lt;/p&gt;
&lt;p&gt;类目推荐: 用户点击某个类目后，进行相关职位推荐。&lt;/p&gt;
&lt;p&gt;相似推荐: 用户点击某个具体职位后，在下方展现相似职位。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;58招聘推荐主要问题&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;58招聘推荐相对其它行业主要存在以下典型问题：&lt;/p&gt;
&lt;p&gt;海量数据计算：大多数公司都存在，此处不做详细说明。&lt;/p&gt;
&lt;p&gt;冷启动问题: 58同城服务于多业务，包括招聘、房产、黄页、二手等，求职者进入招聘板块使用招聘功能，由于当前不强制用户填写简历，导致无简历用户冷启动问题。&lt;/p&gt;
&lt;p&gt;稀疏性&amp;amp;实时性：58招聘的一部分群体为蓝领用户，他们在平台产生的行为是短时间的、连续的以及稀疏的，可能活跃两天找到工作后就不再活跃。其次，有些用户回到平台，求职意愿可能会发生变化，一部分可能想找别的工作（如之前是服务员，现在想找快递），另一部分可能是因为传统职业存在职位进阶的过程，这些都需要系统思考。&lt;/p&gt;
&lt;p&gt;资源分配问题：第一，如何有效识别（企业，求职者）的真实意图，进而合理分配资源产生有效连接，针对不良意图进行差异化对待。第二，招聘对于 C 端和 B 端都是有限的资源，招聘方招聘职位有限，求职者与招聘方交互有限，很大程度上不同于淘宝推荐，因为后者的商品是无限供应的。&lt;/p&gt;
&lt;p&gt;——招聘个性化推荐实现——&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;58招聘个性化推荐实现&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;58招聘个性化推荐的实现过程与大多数公司推荐模块基本相似，包括用户意图理解、内容召回、内容排序、内容展示四个核心模块。下面将结合业务特性，介绍每个模块实现的关键点。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如何理解用户？&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;58招聘用户理解主要通过“言”和“行”识别用户真实意图，重点关注的属性主要包括招聘领域求职意向、用户个人属性以及外在形象（如上图左边）。围绕求职者与招聘方在平台产生的内容及行为，我们构建了相应的知识图谱和用户画像。&lt;/p&gt;
&lt;p&gt;2.1 无诚意用户识别&lt;/p&gt;
&lt;p&gt;在理解用户之前，我们首先需要识别出无真实招聘/求职意图的用户，并进行差异对待。如频繁发布包含联系方式的导流信息、发布高薪诱惑等恶意虚假信息等，将用户引导至平台外进行转化。针对以上业务我们总结了一些特点，主要表现为：&lt;/p&gt;
&lt;p&gt;暴露联系方式&lt;/p&gt;
&lt;p&gt;内容不成句&lt;/p&gt;
&lt;p&gt;高薪诱惑&lt;/p&gt;
&lt;p&gt;在平台很“活跃”&lt;/p&gt;
&lt;p&gt;针对以上业务特点，我们主要的识别方法包括：&lt;/p&gt;
&lt;p&gt;传统的关键词+正则识别方法，如针对&quot;微信&quot;、&quot;QQ&quot;这类联系方式的相关关键词等。&lt;/p&gt;
&lt;p&gt;针对变形联系方式，基于拼音+滑动窗口进行识别。&lt;/p&gt;
&lt;p&gt;采用命名实体 NER 识别进行挖掘，如 BiLSTM+CRF。&lt;/p&gt;
&lt;p&gt;采用相关分类算法进行识别，如 fastText，CNN。&lt;/p&gt;
&lt;p&gt;在无诚意用户识别过程中，我们总结了以下心得：&lt;/p&gt;
&lt;p&gt;举一反三：问题用户识别是典型的对抗场景，策略构建时需要更多思考对抗能力的刻画，将一些强对抗能力的特征加入到模型中（如文字变形、文字转拼音）。&lt;/p&gt;
&lt;p&gt;刚柔并济：差异化惩处不同问题类型的用户。对平台其他用户伤害巨大的群体，结合法律手段严厉惩处；处于问题边界的，则主要通过较柔和的方式处理（如内容展示降权），减少剧烈对抗现象的产生。&lt;/p&gt;
&lt;p&gt;2.2 知识图谱构建&lt;/p&gt;
&lt;p&gt;知识图谱是一个非常复杂的系统，包括多元异构数据搜集-&amp;gt;知识获取-&amp;gt;知识融合表示-&amp;gt;知识推理-&amp;gt;知识管理多个部分，主题及时间因素，我们重点介绍下在 NER 方面的探索。招聘业务场景含有大量的文本内容，通过 NER 技术能够有效提取文本中的关键信息，进一步提高系统的结构化理解能力。&lt;/p&gt;
&lt;p&gt;NER 开展经历了两个阶段：&lt;/p&gt;
&lt;p&gt;第一阶段：基于平台已有的部分结构化实体词，以及不少半结构化组织的职位描述基础，我们采用 bootstrap 方法，快速迭代进行挖掘，并结合半人工标注，为深度学习构建更完整的样本数据集。&lt;/p&gt;
&lt;p&gt;第二阶段：将第一阶段的内容作为 input，核心采用 BiLSTM+CRF 构建实体识别深度网络，有两个优化点取得了较好效果。第一个是输入层基于字到词的优化，构建招聘领域的专有词库。第二个是采用训练样本增强技术，将相近实体词和同类实体词进行替换扩大样本集，并将模型识别的结果有选择的放回训练集重新进行迭代训练，减弱对标注数据集的依赖。目前命名实体识别仍在不断优化，识别准确率平均达到0.75+，部分准确率可达到0.9+。&lt;/p&gt;
&lt;p&gt;2.3 构建用户画像&lt;/p&gt;
&lt;p&gt;用户画像是个性化推荐系统的基础模块，决定了对用户意图理解的准确与否。基于标签传递思想，我们通过统计规则、传统分类模型和深度模型多种算法结合捕获用户行为的兴趣表达，构建长短期用户画像。&lt;/p&gt;
&lt;p&gt;基于统计规则：通过窗口形式，近实时对用户画像进行计算更新，计算时加入时间衰减因子、行为权重因子及标签置信度权重。深刻理解业务场景，进行合理数学设计是关键。如信息列表页的点击数据，在使用时要差异化处理列表页直接展示的显性标签及隐藏在详情页的兴趣标签，避免人为引入噪音。&lt;/p&gt;
&lt;p&gt;基于传统分类预测：采用分类算法，应用到用户属性填充、异常用户/行为识别及用户分类多个方面。并非所有的求职用户都会留下较详尽的简历，我们借助历史的招聘简历与用户行为组织样本，可有效预测性别、年龄段、期望工作岗位等用户信息，优化简历缺失或不完善的冷启动问题。同时，针对用户行为的聚焦情况，通过模型能够有效识别出一些异常数据、识别求职目的明确型及发散型两类求职用户，进而剔除掉部分噪音数据提高样本精度，对不同用户定制差异化策略，提升推荐整体刻画能力。&lt;/p&gt;
&lt;p&gt;基于行为序列预测：借助统计规则及传统分类，基本建设出一个可用画像，但对用户多个行为之间的信息捕获有限。我们将用户搜索浏览、简历投递、在线沟通等行为组织成行为事件序列，采用 LSTM、GRU、Attention 等训练模型预测用户兴趣，当前还在探索评估阶段。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;召回模块&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;58招聘推荐围绕个体、群体、全局三个召回不断细化演进，不同召回满足不同需要，三者结合服务于各类场景。从2016年到现在，我们先后主要经历了基于上下文内容、协同过滤、精细画像、深度召回几个阶段，演变成当前以上下文与用户画像结合的精准召回、协同过滤召回及深度向量化召回为核心策略的召回模块。&lt;/p&gt;
&lt;p&gt;3.1 基于上下文+用户画像的精准召回&lt;/p&gt;
&lt;p&gt;该策略是业内十分常用的召回方法之一，核心在于结合用户画像对请求进行丰富改写。绝大部分场景，用户主动搜索或点选的条件有限，借助用户画像中的历史兴趣及知识图谱组织的实体关系，我们对岗位、工作地、薪资、行业等多个维度进行条件扩充或必要改写，多路召回匹配用户的职位内容。&lt;/p&gt;
&lt;p&gt;该策略的主要优点：可解释性好、实现时间成本低，缺点和难点是过度依赖标签挖掘的准确性。&lt;/p&gt;
&lt;p&gt;3.2 基于业务特殊性的协同过滤算法改进&lt;/p&gt;
&lt;p&gt;协同过滤是推荐系统经典的召回方法，通过用户与物品的行为挖掘用户与用户、物品与物品之间的关联关系。招聘业务的求职者数量巨大，且是短时间的稀疏行为场景，我们采用基于物品的协同过滤，同时希望能近实时的将实时行为信息组织进服务。&lt;/p&gt;
&lt;p&gt;在技术实现过程中，我们参考了腾讯2015年发表的Paper《TencentRec: Real-time Stream Recommendation in Practice》，赋予职位点击、投递、在线沟通等不同的行为权重进行多行为融合，基于用户行为序列的长度以及用户质量设计用户惩罚因子，同时通过时间衰减因子增强近期行为的表达，这三个因子的设计与 Paper 基本一致。另外针对业务特殊性，我们改进了职位相似度的计算，加入了职位相似度控制，避免求职目标发散的用户影响职位关系的组织。算法上线后，在点击率、投递率方面都取得了正向收益，其中详情页的相关职位推荐提升超过25%。&lt;/p&gt;
&lt;p&gt;3.3 Embedding 深度召回探索&lt;/p&gt;
&lt;p&gt;协同过滤虽然取得了不错的业务收益，但其依赖于用户与物品的行为矩阵，对于行为稀疏的场景天然表达有限。而恰好，58招聘业务的流量构成中，有一部分是三四五线城市，城市越下沉数据稀疏的情况也越凸显。针对这类问题，我们希望进一步挖掘行为数据的信息，很自然的想到基于深度学习的向量化 Embedding 召回。我们核心参考了 Youtube 的 DNN 召回思想，基于业务现状做了调整优化。&lt;/p&gt;
&lt;p&gt;职位向量化：我们将求职者对职位的行为序列看作一系列上下文，利用 word2vector 思想进行向量化表达。Input 部分，包括职位特征、职位所属的企业特征和求职者反馈特征。Output 构建，业务漏斗越深的行为选择的窗口越大，并基于用户平均的行为长度作为窗口设定的参考值。针对无历史用户行为的新职位，使用职位的文本结构化信息，通过历史训练所得的标签向量表达经过 average-pooling 作为初始向量，解决冷启动。&lt;/p&gt;
&lt;p&gt;用户向量化：构建一个多分类 NN 网络，Embedding 层将用户发生行为的职位向量化直接迁移过来使用，输入用户的简历及画像信息进行向量训练。最上层理想情况是一个极限分类，以用户真实发生行为的数据作为正样本，未发生行为的数据作为负样本，构建损失函数进行最优化训练。58招聘场景有千万级别的职位，极限分类需要巨大的计算消耗，当前资源无法满足。因此在负样本选择上，我们使用降采样机制，随机从求职者关注的城市及岗位下未发生行为的职位中按一定比例抽取负样本。线上会实时的采集用户行为，以窗口形式对用户向量进行更新。&lt;/p&gt;
&lt;p&gt;线上服务：借鉴 Facebook 的 FAISS 实现，线上用户发起请求时，通过求职者的向量表达，去获取与其最相似的 TopN 职位，返回给推荐系统。&lt;/p&gt;
&lt;p&gt;Embedding 向量化召回，还处于初期探索，仍需要在样本、输入特征及网络参数调优开展大量工作，期待有更显著的业务收益进一步与大家分享。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;排序迭代历史&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;相比其他推荐场景，58招聘的漏斗更深，并且是典型的双边业务。系统不断优化提升求职者点击、投递职位的同时，还需要关注职位背后的招聘方是否反馈形成了有效双边连接，进而达到更接近求职链条的预测目的。结合不同时期的业务目标，我们先后经历了几个主要阶段。&lt;/p&gt;
&lt;p&gt;第一阶段：以提升点击规模为主要目标，从零到一构建点击率预估模型，开发模型建设的基本框架，包括特征工程、AB 实验框架及线上 CTR 服务。该阶段在较少人员的情况下，建立了排序模型及服务的大体框架，在点击层面支撑业务增长。&lt;/p&gt;
&lt;p&gt;第二阶段：业务目标深入，从点击过度到单边连接直至双边连接，在 CTR 预估模型的基础上，增加了 CVR 预估及 ROR 双边连接预估。同时在工具上开展了针对性建设，包括特征生产 Pipeline、AB 实验框架升级为可配置化中心及特征模型的可视化分析监控等，解耦算法和工程依赖，支持更多算法和工程人员的并行高效迭代。&lt;/p&gt;
&lt;p&gt;第三阶段：围绕深度学习的算法探索，wide&amp;amp;deep、DeepFM、多任务学习、强化学习等，不断提升算法对高维特征的表达能力，提高预估模型的刻画能力。预计在2020年全面落地业务，达到更为理想的迭代状态。&lt;/p&gt;
&lt;p&gt;4.1 连接转化预估模型&lt;/p&gt;
&lt;p&gt;58招聘转化预估模型是多目标学习，设计实现如上图，底层共建样本及特征，使用不同算法对 CTR 点击率预估、CVR 单边连接预估、ROR 双边连接预估进行建模，最后对多个模型进行融合支撑线上排序。&lt;/p&gt;
&lt;p&gt;整体排序实现是业务常见的方法，总结开展过程中比较关键的点：&lt;/p&gt;
&lt;p&gt;样本处理：围绕减少样本噪音，我们开展了多个优化。去除异常用户及异常数据，包括非招聘意图的用户数据、误点击数据；增加真实曝光及停留时长埋点，去除用户下拉信息流过程中非真正看见的数据，将停留时长作为样本置信权重加入到模型训练中；基于求职者维度进行采样，去除对同一职位多次正负样本的矛盾可能。&lt;/p&gt;
&lt;p&gt;特征工程：关注及监测特征显隐性的变化，尤其是信息列表展示样式的产品调整，需及时进行特征调整及模型迭代。58招聘业务的特殊性，实时类特征很重要，需要关注特征一致性方面的保障机制，避免发生特征穿越现象或线上线下特征不一致问题。&lt;/p&gt;
&lt;p&gt;模型：重视模型认知，并不是简单的关注离线 AUC 或者线上转化率 AB 对比，在特征表达上多些分析，迭代过程中重视前后模型的特征比较，能够有效提高模型实验迭代的有效性。&lt;/p&gt;
&lt;p&gt;4.2 特征生产实现&lt;/p&gt;
&lt;p&gt;特征 Pipeline 的构建，减少了大量特征工程重复工作，显著提高模型迭代效率。其核心功能是实现配置化的方式，集成了样本采样、特征变换、特征组合、特征离散化，整合后得到训练样本，一方面输送给模型进行训练评估，另一方面也输出到分析平台支持可视化分析。&lt;/p&gt;
&lt;p&gt;4.3 模型 serving 实现&lt;/p&gt;
&lt;p&gt;线上模型服务有定期更新及大量 AB 实验的要求，随着服务演进构建了当前的模型 Serving 框架，实现了对模型的定期自动更新以及模型的自动加卸载功能，同时也具备了更强的扩展性，可接入不同算法的模型实现。离线部分，样本经过特征 Pipeline 构建增量训练数据，模型训练模块会获取 Base 模型文件初始化并进行增量模型训练，模型评估无异常，系统会将模型存储至模型仓库及 HDFS 文件。线上部分，模型仓库增删改模型后，会发起模型热加载或卸载指令更新至线上服务内存；对于线上的排序请求，实时修改相应使用模型的存储生命周期，对于长期无用的模型，模型仓库将自动删除。&lt;/p&gt;
&lt;p&gt;模型 Serving 能够自动化管理线上模型，但我们也不能完全托管系统，依然需要关注模型变化。一方面在离线部分的模型评估环节，除了对 AUC 等评估指标的自动监测，也将模型内存大小、模型特征表达作为监测的一部分；另一方面线上监测业务转化指标的变化，当指标发生较大波动时发出警报，人工进行模型检查。&lt;/p&gt;
&lt;p&gt;4.4 重排序机制&lt;/p&gt;
&lt;p&gt;由于业务的特殊性，以 CTR 预估、CVR 单边连接预估、ROR 双边连接预估支撑排序仍然存在刻画能力不足的问题，体现在以下几个方面：&lt;/p&gt;
&lt;p&gt;招聘关系到个人生计及国家民生，是件极为严肃的事情，内容质量是基础保障。但连接预估模型无法有效刻画质量问题，存在一些职位连接效率很不错但属于问题职位，因此推荐系统需要增加质量相关的因子。&lt;/p&gt;
&lt;p&gt;转化率高不等同于双边匹配。线上招聘，无法很好追踪到面试及入职环节，求职者与招聘方形成的双边连接，可能是出于其他原因（如对自己或对方的错误判断）。因此，系统需要考虑匹配方面的控制。&lt;/p&gt;
&lt;p&gt;资源浪费问题，对于绝大部分用户，求职及招聘都是周期性行为，一个已经招满人的职位可能依然在线上展示。系统还需要增加职位活跃度或周期方面的刻画，减少相应的资源浪费。&lt;/p&gt;
&lt;p&gt;针对这些需要，系统增加了重排序机制，通过分段处理手段，在粗排阶段打压甚至过滤掉低质量内容，在重排序对不活跃/不匹配内容进行降权，达到保障平台质量生态、提高有效连接规模的目的。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;列表展示内容控制&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;内容展示方面，我们也结合算法做了一些工作，来提高内容的可解释性、提供更多有价值的信息来辅助用户决策。结合个性化模型挖掘亮点标签，将更深预估模型的核心特征包装成标签形式展示在列表页，如距离多远、职位的福利标签、职位的热门情况等；使用 NLG 文本生成技术，自动生成简短描述进行展示，弥补标题及其简单职位的文本信息不足。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;AB 实验配置中心&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;推荐系统包括召回、过滤、排序、展示几个核心模块，且每个模块都有长期进行实验迭代的诉求。我们搭建了 AB 实验配置中心，实现可视化配置，与线上服务及数据分析平台联动，更灵活高效地开展实验迭代工作。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;整体技术框架&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;58招聘个性化推荐经过不断演进，最终形成了如上图的技术框架。离线部分包含数据仓库层，知识图谱、用户画像、预测模型的挖掘层，知识数据存储层；线上部分包含数据服务及推荐引擎。线上产生的行为数据，实时流转至离线的计算挖掘模块，反馈到线上达到个性化体验效果。&lt;/p&gt;
&lt;p&gt;——心得分享及规划——&lt;/p&gt;
&lt;p&gt;58招聘推荐系统最近四年优化收益整理如上图，贡献大小依次是召回、特征、数据、算法、样式、工程。深入理解业务及算法、注重细节积累是做好算法工作的保证；前期在样本及特征上多下功夫，不仅能获得不错的业务增长，也是之后算法深入的基础；工具性建设尽可能先行，能够提高整体迭代效率。&lt;/p&gt;
&lt;p&gt;未来的核心工作：&lt;/p&gt;
&lt;p&gt;多任务学习、强化学习等的全面探索落地。&lt;/p&gt;
&lt;p&gt;集公司内外资源，丰富招聘数据源，提高用户画像的覆盖率，更好的支持千人千面。&lt;/p&gt;
&lt;p&gt;分享嘉宾&lt;br/&gt;▬&lt;/p&gt;
&lt;p&gt;曾钦榜&lt;/p&gt;
&lt;p&gt;58同城 | 高级技术经理&lt;br/&gt;——END——&lt;br/&gt;欢迎关注DataFunTalk同名公众号，收看第一原创技术文章。&lt;/p&gt;
</description>
<pubDate>Fri, 15 Nov 2019 17:30:00 +0000</pubDate>
<dc:creator>DataFunTalk</dc:creator>
<og:description>文章作者：曾钦榜 58同城 高级技术经理 编辑整理：周晓侠 内容来源：58技术沙龙 出品社区：DataFun 注：欢迎转载，转载请在留言区内留言。 导读：随着科学技术的飞速发展，互联网被广泛应用于各个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/datafuntalk/p/11870357.html</dc:identifier>
</item>
<item>
<title>卜时明餐|记一次项目开发经历 - fishers</title>
<link>http://www.cnblogs.com/fisherss/p/11870264.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fisherss/p/11870264.html</guid>
<description>&lt;p&gt;做了一两周，这个项目应该要告一段落了&lt;br/&gt;这几周每天肝到深夜，也挺开心的啊，和小伙伴完美配合，做出成品后还是很有成就感。&lt;br/&gt;把这学期学的数据库啊、java、&lt;del&gt;计算机网络&lt;/del&gt;都实际用到了&lt;br/&gt;简单记录一下这次项目经历。&lt;/p&gt;
&lt;h2 id=&quot;大概是这样子的&quot;&gt;大概是这样子的&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1454456/201911/1454456-20191115235759573-1558843548.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1454456/201911/1454456-20191115235839633-1579405909.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;p的视频&quot;&gt;P的视频&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/av75766523&quot;&gt;B站备份了视频,顺便骗一波三连。&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;编造的背景&quot;&gt;编造的背景&lt;/h2&gt;
&lt;p&gt;&lt;del&gt;校园餐厅 中午、晚餐吃饭学生惊人的多！&lt;/del&gt;&lt;br/&gt;&lt;del&gt;每次排队时间超长烦恼至极，心情不愉。。&lt;/del&gt;&lt;br/&gt;&lt;del&gt;校园两餐厅距离遥远，美食遥不可及，无法实时观测人数&lt;/del&gt;&lt;br/&gt;&lt;del&gt;排队浪费零碎时间&lt;/del&gt;&lt;/p&gt;
&lt;h2 id=&quot;虚构的功能&quot;&gt;虚构的功能&lt;/h2&gt;
&lt;p&gt;帮助学生和在校教师合理规划用餐时间，避开人流高峰。&lt;br/&gt;（校园餐厅各个楼层人流实时监测，实时刷新每个窗口人数，实时通过小程序查看每个窗口的用餐情况）&lt;/p&gt;
&lt;h2 id=&quot;花里胡哨的技术栈&quot;&gt;花里胡哨的技术栈&lt;/h2&gt;
&lt;p&gt;深度学习：Tensorflow + yolov3&lt;br/&gt;后端：java、SpringBoot&lt;br/&gt;前端：微信小程序&lt;br/&gt;数据库：Mysql&lt;br/&gt;服务器：ubuntu&lt;/p&gt;
&lt;h2 id=&quot;前端&quot;&gt;前端&lt;/h2&gt;
&lt;p&gt;用户端：微信小程序&lt;br/&gt;展示餐厅、热门窗口实时人数，菜谱推荐。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1454456/201911/1454456-20191115234147087-2056367192.png&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1454456/201911/1454456-20191115234207149-1898803914.png&quot;/&gt;[]&lt;/p&gt;
&lt;h2 id=&quot;深度学习算法&quot;&gt;深度学习算法&lt;/h2&gt;
&lt;p&gt;Tensorflow + yolov3物体识别&lt;br/&gt;小伙伴开发的&lt;br/&gt;二餐二楼自助餐窗口人流识别&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1454456/201911/1454456-20191115234934721-118352136.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;数据库&quot;&gt;数据库&lt;/h2&gt;
&lt;p&gt;第一次真正意义上玩linux系统，部署了mysql数据库&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/opsprobe/p/9126864.html&quot;&gt;ubuntu安装mysql的blog地址，前人经验贴，看这个操作一下就行&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;还设计了很正经的数据库ER图，真的把这学期学到的知识用上了。。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1454456/201911/1454456-20191115235300115-1982076955.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;后端&quot;&gt;后端&lt;/h2&gt;
&lt;p&gt;最后就是后端了，用java写的(也是这学期学的呀。。）&lt;br/&gt;用了SpringBoot框架 + JDBC操作数据库；&lt;br/&gt;其实和现在学的Tomcat+sevlert+JDBC一样的操作。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1454456/201911/1454456-20191115235556210-2059502333.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1454456/201911/1454456-20191115235659137-1321531499.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;架构图&quot;&gt;架构图&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1454456/201911/1454456-20191116000049852-1873566359.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;怎么把前端、后端、深度学习物体识别、数据库连接起来呢？&lt;br/&gt;首先是，摄像头记录餐厅实时视频状况，传给yolov3&lt;del&gt;物体识别服务器&lt;/del&gt;(小伙伴的笔记本)，模型识别出实时人数，（通过TCP/IP协议)连接阿里云服务器部署的数据库，写入实时数据&lt;br/&gt;然后是用户端，用户玩手机打开微信小程序，会发起Http请求给后端，后端拿到并解析Http数据报后，向服务器上的数据库获取实时人数数据，返回给微信小程序，微信小程序渲染数据就可以了。&lt;/p&gt;
&lt;h2 id=&quot;差不多就这样&quot;&gt;差不多就这样&lt;/h2&gt;
&lt;p&gt;最后放上俩小伙伴丑照，和我帅气的壁纸，留念。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1454456/201911/1454456-20191116002444941-1928203260.png&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1454456/201911/1454456-20191116002433813-574019603.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 15 Nov 2019 16:19:00 +0000</pubDate>
<dc:creator>fishers</dc:creator>
<og:description>卜时明餐：校园餐厅人流量实时监测系统 做了一两周，这个项目应该要告一段落了 这几周每天肝到深夜，也挺开心的啊，和小伙伴完美配合，做出成品后还是很有成就感。 把这学期学的数据库啊、java、~~计算机网</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/fisherss/p/11870264.html</dc:identifier>
</item>
<item>
<title>学习下ElasticSearch - palapala</title>
<link>http://www.cnblogs.com/ssskkk/p/11657465.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ssskkk/p/11657465.html</guid>
<description>&lt;h3&gt;ElasticSearch基础概念&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/xiaojianfeng/p/9435507.html&quot; target=&quot;_blank&quot;&gt;Elasticsearch的Head插件安装&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000011899522&quot; target=&quot;_blank&quot;&gt;Elasticsearch在Centos 7上的安装常见的问题&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用场景:比如分库的情况下，你想统计所有数据的报表，就把所有数据都放在ElasticSearch上&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;关系型数据库&lt;/td&gt;
&lt;td&gt;ElasticSearch&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;数据库Database&lt;/td&gt;
&lt;td&gt;索引index，支持全文检索&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;表Table&lt;/td&gt;
&lt;td&gt;类型Type&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;数据行Row&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;文档Document&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;数据列Column&lt;/td&gt;
&lt;td&gt;字段Field&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;模式Schema&lt;/td&gt;
&lt;td&gt;映射Mapping&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;用关系型数据库就会想到建立一张User表，再建字段等，&lt;/p&gt;
&lt;p&gt;而在Elasticsearch的文件存储，Elasticsearch是面向文档型数据库，一条数据在这里就是一个文档，用JSON作为文档序列化的格式&lt;/p&gt;
&lt;p&gt;在ES6.0之后，已经不允许在一个index下建不同的Type了，一个index下只有一个Type(以后版本中Type概念会去掉，可以直接把index类比成Table)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;节点Node：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　一个ElasticSearch运行的实列，集群构成的单元&lt;/p&gt;
&lt;p&gt;&lt;span&gt;集群Cluster：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　由一个或多个节点组成，对外提供服务　　&lt;/p&gt;
&lt;h3&gt;Elasticsearch实现原理-倒排索引&lt;/h3&gt;
&lt;p&gt;ElasticSearch是基于倒排索引实现的&lt;/p&gt;
&lt;p&gt;倒排索引（Inverted Index）也叫反向索引，有反向索引必有正向索引。&lt;/p&gt;
&lt;p&gt;通俗地来讲，正向索引是通过key找value，反向索引则是通过value找key。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;倒排索引—单词词典&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;单词词典(Term Dictionary)是倒排索引的重要组成部分。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;——记录所有文档的单词，一般都比较大&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;——记录单词到倒排列表的关联信息(这个单词关联了哪些文档)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;倒排索引—排序列表&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;倒排列表(Posting List)记录了单词对应文档的集合，由倒排索引项(Posting)组成&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;倒排索引项(Posting)主要包含如下信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;—文档Id，用于&lt;span&gt;获取原始信息&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;—单词频率(TF,Term Frequency)，记录该单词在文档中出现的次数，用于&lt;span&gt;后序相关算分&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;—位置(Position)，记录单词在文档中的分词位置，用于做&lt;span&gt;词语搜索&lt;/span&gt;(Phrase Query)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;—偏移(Offset)，记录单词在文档的开始和结束位置，用于&lt;span&gt;高亮显示&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1341698/201911/1341698-20191108011319179-597222496.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;分词&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;搜索引擎的核心是倒排索引，而倒排索引的基础就是分词。所谓分词可以简单理解为将一个完整的句子切割为一个个单词的过程。也可以叫文本分析，在es称为Analysis。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如文本：elasticSearch是最流行的搜索引擎&lt;/p&gt;
&lt;p&gt;分词结果：elasticSearch 流行 搜索引擎&lt;/p&gt;
&lt;p&gt;分词器是es中专门处理分词的组件，英文为Analyzer，它的组成如下&lt;/p&gt;
&lt;p&gt;Character Filters：针对原始文本特殊处理，比如除html特殊符&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Tokenizer：&lt;/span&gt;将原始文本按照一定规则切分为单词&lt;/p&gt;
&lt;p&gt;TokenFilters：针对&lt;span&gt;tokenizer&lt;/span&gt;处理的单词就行在加工，比如转小写，删除或新增处理(比如中文中的  这 呢 无实意的词)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Analyze API&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;es提供了一个测试分词的API接口，方便验证分词效果，endpoint是_analyze&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;—可以直接指定analyze测试&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;—可以直接指定索引中的字段进行测试&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;—可以自定义分词器进行测试&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;文档映射Mapping&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;Mapping类似数据库中的表结构定义，主要作用如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;—定义Index下的字段名(Field Name)&lt;/p&gt;
&lt;p&gt;—定义字段的类型，比如数值型、字符串型、布尔型等&lt;/p&gt;
&lt;p&gt;—定义倒排索引相关的配置，比如是否索引、记录position等&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Dynamic Mapping&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;es可以自动识别文档字段类型，从而降低用户使用成本&lt;/p&gt;
&lt;h3&gt;SearchAPI介绍和相关性算分&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;es中存储的数据进行查询分析，endpoint为_search&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;查询主要有两种形式&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）URI Search&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;操作简单，方便通过命令进行测试&lt;/p&gt;
&lt;p&gt;但 仅包含部分查询语法&lt;/p&gt;
&lt;p&gt;GET /indexname/_search?q=user:xx&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）Request Body Search&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;es提供的完备查询语法Query DSL(Domain Specific Language)&lt;/p&gt;
&lt;p&gt;GET /indexname/_search&lt;/p&gt;
&lt;p&gt;{&lt;br/&gt;　　&quot;query&quot;: {&lt;br/&gt;　　　　&quot;term&quot;: {&lt;br/&gt;　　　　　　&quot;user&quot;: &quot;xx&quot;&lt;br/&gt;　　　　}&lt;br/&gt;　　}&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;相关算分&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;相关算分是指文档与查询语句直接的相关度，英文为relevance&lt;/p&gt;
&lt;p&gt;　　通过倒排索引可以获取与查询语句相匹配的文档列表，那么如何将最符合用户查询的文档放到前列呢&lt;/p&gt;
&lt;p&gt;　　本质是一个排序问题，排序的依据是相关算分&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;ES目前主要有两个相关性算分模型&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　TF/IDF模型&lt;/p&gt;
&lt;p&gt;　　BM25模型 5.x之后的默认模型&lt;/p&gt;
&lt;p&gt;BM25相比TF/IDF的一大优化是降低了TF(Term Frequency单词频率)在过大时的权重&lt;/p&gt;
&lt;p&gt;&lt;span&gt;相关算分是shard与shard间是相互独立的，也就意味着一个Term的IDF等值在不同shard上是不同的。文档的相关算分和它所处的shard有关&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在文档数量不多时 会导致相关算分严重不准的情况发生&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;解决办法&lt;/p&gt;
&lt;p&gt;　　—设置分片数是一个，从根本排除问题，在文档数据量不多时可以考虑该方法，(百万到千万)&lt;/p&gt;
&lt;p&gt;　　—二是使用DFS Query Then Ftech查询方式&lt;/p&gt;
&lt;h3&gt;Elasticsearch分布式特性&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;es支持集群模式，是一个分布式系统，好处是&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;—1)增加系统容量：内存、磁盘，使es集群可以支持PB级的数据&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如何将数据分布在所有节点上&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;—引入分片 Shard解决问题&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;分片是ES支持PB级数据的基石&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　—分片存储了部分数据，可以分部在任意节点上&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　—分片数在索引创建时指定且后序不允许再更改&lt;span&gt;(即使你后面新增了也用不到)&lt;/span&gt;，默认5个&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　—分片有主分片和副本分片之分，以实现数据的高可用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;es集群由多个es实列组成&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　—不同集群通过集群名字来区分，可通过cluster.name修改，默认为elasticSearch&lt;/p&gt;
&lt;p&gt;　　—每个ES实列本质是一个JVM进程，且有自己的名字，通过node.name修改&lt;/p&gt;
&lt;p&gt;Master Node：Master节点通过集群中所有的节点选举产生，可以被选举的节点称为master-eligible节点，&lt;/p&gt;
&lt;p&gt;　　　　　　相关配置如下：node.master:true&lt;/p&gt;
&lt;p&gt;Coordinating Node：处理请求的节点为Coordinating节点，该节点为所有节点默认角色，不能取消&lt;/p&gt;
&lt;p&gt;　　　　　　　　    作用是把请求路由到正确的节点处理，比如创建索引请求到master节点&lt;/p&gt;
&lt;p&gt;Data Node：存储数据的节点即为data节点，默认节点都是data类型，相关配置如下：node.data.true&lt;/p&gt;
&lt;p&gt;&lt;span&gt;—2)提供系统可用性：即部分节点停止服务，整个集群依然可以正常服务&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;提高系统可用性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;服务可用性&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;—两个节点情况下，允许其中一个节点停止服务&lt;/span&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;数据可用性&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;span&gt;—引入副本(Replication)解决&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;span&gt;—每个节点上都有完备的数据&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;复制分片的意义在于容错性，当一个节点挂了，另一个节点上的分片可以代替挂掉节点上的分片&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;故障转移&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1341698/201911/1341698-20191115005847997-1340954266.png&quot; alt=&quot;&quot;/&gt;一：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1341698/201911/1341698-20191115010252145-1341594855.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 二：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1341698/201911/1341698-20191115010645322-122354198.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 三：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1341698/201911/1341698-20191115010550388-2033099825.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;文档到分片的映射算法&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;es通过如下公式计算文档到对应的分片 -shard=hash(routing)%number_of_primary_shards&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;hash算法保证可以将数据均匀的分散在分片中&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;routing是一个关键参数，默认是文档id，也可以自行指定&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;number_of_primary_shards是主片分数(该算法与主片分数相关，这也是分片数量一旦确定就不能修改的原因)&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;脑裂问题&lt;/h3&gt;
&lt;p&gt;在上述第一步的时候 node2和node3选举node2为master节点了时候，此时会更新&lt;span&gt;cluster state&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;此时node1节点网络恢复了，node1自己组成集群后，也会更新&lt;span&gt;cluster state&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;此时：同一个集群有两个master，而且维护不同的cluster state，网络恢复后 无法选择正确的master&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解决方案：&lt;/span&gt;仅在可选举master-eligible节点数大于等于quorum时才可以进行master选举&lt;/p&gt;
&lt;p&gt;　　　　    即使node1节点恢复了 ，可选节点数未达到quorum，不选举&lt;/p&gt;

</description>
<pubDate>Fri, 15 Nov 2019 16:13:00 +0000</pubDate>
<dc:creator>palapala</dc:creator>
<og:description>ElasticSearch基础概念 Elasticsearch的Head插件安装 Elasticsearch在Centos 7上的安装常见的问题 使用场景:比如分库的情况下，你想统计所有数据的报表，就</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ssskkk/p/11657465.html</dc:identifier>
</item>
</channel>
</rss>