<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>听说你还不懂约瑟夫环！！！ - 玄之不玄</title>
<link>http://www.cnblogs.com/wbcdmn/p/13760162.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wbcdmn/p/13760162.html</guid>
<description>&lt;p&gt;&lt;strong&gt;约瑟夫环&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;问题： N个人编号为1，2，……，N，围成一个环，依次报数，每报到M时，杀掉那个人，求最后胜利者的编号。&lt;/p&gt;
&lt;p&gt;换一下编号，现在假设有10个人编号为a,b,c,d,e,f,g,h,i,j，M=3吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aaef0a43c46a4ccfb9f298b3ff49b96f~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;杀第一个人的结果如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/983001be2d38477cb27624362c4ab2d7~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;杀第二个人的时候相当于从d开始，结果如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20f3be9276414375996c547278df0dc0~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后我们可以知道d最终存活了下来,设f(n) = x 表示有n个人时存活下来的是x,这里f(10)=d。&lt;/p&gt;
&lt;p&gt;现在我们来跟踪一下d的位置变化&lt;/p&gt;
&lt;p&gt;一开始杀第一个人时d的位置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf94c01d6d394aaaa19d81ab99ddefd3~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后杀第二个人时d的位置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/40cb43aa93d54bac8db6a220467e3791~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看到这里我想你应该什么都看不出来，如果我此时问你如果只有9个人那么那个人存活的下标是多少你应该也是看不出来的。&lt;br/&gt;这里不是说大家笨，大家都是这样子，一开始谁能反映的过来的啊。不用急听我细细道来。&lt;/p&gt;
&lt;p&gt;再看一下这个图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/40cb43aa93d54bac8db6a220467e3791~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们很容易就可以得知最后一个是一个死人，死人是不会再被数一次的，那我们就把最后一个死人删掉吧。&lt;/p&gt;
&lt;p&gt;那此时不就相当于只有9个人的情况吗&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e4f128b94cdf40dc90ae4ae0437e2546~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;虽然字母顺序对不上，但是如果只看下标的话你应该能够说出9个人的时候下标是多少的人存活下来吧也就是下标为0。&lt;/p&gt;
&lt;p&gt;而且这个下标不是随便来的，而是按照一定的规律出现的，也就是f(9) = f(10) - M,可能有人会问如果下标越界了咋办啊。那还不简单取模不就可以了。f(n)有可能会是负数，负数取模可能比较抽象，那我们转换成正数取模吧(这一步是比较顺理成章的希望没有把你困扰住） 也就是 f(10) = f(9)+M ， 为了预防越界也就是f(10) = (f(9)+M) %10; 为什么是和10取模而不是和9取模呢？这一点的是因为9个人时是由10个人通过移位再去掉最后一个死人后得到的本质上还是10个人，自然就是要和10取模，也可以通过上面的图，更好的理解这一点。&lt;/p&gt;
&lt;p&gt;通过这个例子，想必你能够简单的写出递归式子了吧，也就是f(n) = (f(n-1)+M)%n。&lt;/p&gt;
&lt;p&gt;全过程如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2046667/202010/2046667-20201001131153556-1595065769.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码很简单&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public int f(int n,int m){
        if(n==1) return 0;
        return (f(n-1,m)+m)%n;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然这题还有其他解法，数组法和链表法，这些思维量就少一些了。&lt;/p&gt;
&lt;p&gt;如果觉得有收获，不妨花个几秒钟点个赞，欢迎关注我的公众号玩&lt;strong&gt;编程地码农&lt;/strong&gt;，目前专注写数据结构与&lt;strong&gt;算法&lt;/strong&gt;和计算机基础等相关知识。&lt;/p&gt;
</description>
<pubDate>Fri, 02 Oct 2020 00:00:00 +0000</pubDate>
<dc:creator>玄之不玄</dc:creator>
<og:description>约瑟夫环 问题： N个人编号为1，2，……，N，围成一个环，依次报数，每报到M时，杀掉那个人，求最后胜利者的编号。 换一下编号，现在假设有10个人编号为a,b,c,d,e,f,g,h,i,j，M=3吧</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wbcdmn/p/13760162.html</dc:identifier>
</item>
<item>
<title>数据分析与数据挖掘 - 09邻近算法 - 马一特</title>
<link>http://www.cnblogs.com/mayite/p/13759704.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mayite/p/13759704.html</guid>
<description>&lt;h2 id=&quot;一-邻近算法的基本介绍&quot;&gt;一 邻近算法的基本介绍&lt;/h2&gt;
&lt;h3 id=&quot;1-基本说明&quot;&gt;1 基本说明&lt;/h3&gt;
&lt;p&gt;邻近算法又叫做K临近算法或者KNN(K-NearestNeighbor)，是机器学习中非常重要的一个算法，but它简单得一塌糊涂，其核心思想就是样本的类别由距离其最近的K个邻居投票来决定。现在假设我们已经有一个已经标记好的数据集，也就是说我们已经知道了数据集中每个样本所属于的类别。这个时候我们拥有一个未标记的数据样本，我们的任务是预测出来这个数据样本所属于的类别。显然邻近算法是属于监督学习(Supervised Learning)的一种，它的原理是计算这个待标记的数据样本和数据集中每个样本的距离，取其距离最近的k个样本，那么待标记的数据样本所属于的类别，就由这距离最近的k个样本投票产生。在这个过程中，有一个动作是标记数据集，这一点在企业中一般是有专门人来负责标记数据的。&lt;/p&gt;
&lt;h3 id=&quot;2-举例说明&quot;&gt;2 举例说明&lt;/h3&gt;
&lt;p&gt;为了更加直观的了解邻近算法，请看下面的例子。有两种水果长得非常像，一个是菠萝，另一个是凤梨，很长一段时间我都以为它们是同一种水果。&lt;br/&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/281865/1601485366001-073aaed0-d041-4e88-b764-8b6ffd9820cc.png#align=left&amp;amp;display=inline&amp;amp;height=890&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=WechatIMG78.png&amp;amp;originHeight=890&amp;amp;originWidth=1730&amp;amp;size=481534&amp;amp;status=done&amp;amp;style=none&amp;amp;width=1730#align=left&amp;amp;display=inline&amp;amp;height=890&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;originHeight=890&amp;amp;originWidth=1730&amp;amp;status=done&amp;amp;style=none&amp;amp;width=1730&quot; alt=&quot;WechatIMG78.png&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;菠萝与凤梨的核心区别是菠萝的叶子有刺，而凤梨的叶子没有刺。菠萝的凹槽处的颜色是黄色，而凤梨的凹槽处的颜色是绿色。首先我们把这两种水果抽取出其中的两个特点(凹槽处的颜色、叶子上是否有刺)后，放入一个直角坐标系中吧。如下图：&lt;br/&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/281865/1601485602864-f3fa262a-6760-4ccc-b36a-4d851e5ec6f6.png#align=left&amp;amp;display=inline&amp;amp;height=938&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=WechatIMG79.png&amp;amp;originHeight=938&amp;amp;originWidth=1830&amp;amp;size=248276&amp;amp;status=done&amp;amp;style=none&amp;amp;width=1830#align=left&amp;amp;display=inline&amp;amp;height=938&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;originHeight=938&amp;amp;originWidth=1830&amp;amp;status=done&amp;amp;style=none&amp;amp;width=1830&quot; alt=&quot;WechatIMG79.png&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;我们按照两种水果的特点，已经把它们放在了直角坐标系中，按照我们所说的算法原理，此时有一个未标记的样本，我们来预测这个样本到底是属于哪种水果。如下图，这个时候来了一个未标记的样本，也就是不知道是什么类别的水果。&lt;br/&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/281865/1601485814196-60606e0c-99ed-4744-8a27-a1398ae70824.png#align=left&amp;amp;display=inline&amp;amp;height=946&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=WechatIMG80.png&amp;amp;originHeight=946&amp;amp;originWidth=1806&amp;amp;size=286702&amp;amp;status=done&amp;amp;style=none&amp;amp;width=1806#align=left&amp;amp;display=inline&amp;amp;height=946&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;originHeight=946&amp;amp;originWidth=1806&amp;amp;status=done&amp;amp;style=none&amp;amp;width=1806&quot; alt=&quot;WechatIMG80.png&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;在原理中，我们说过，由其最近的K个邻居来投票决定，这个未标记的水果到底是什么水果，那么这个时候，我们把K的值设置为3，如下图:&lt;br/&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/281865/1601485965236-7cf2906c-273d-4454-b9d5-4ae6dfe7eef3.png#align=left&amp;amp;display=inline&amp;amp;height=944&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=WechatIMG81.png&amp;amp;originHeight=944&amp;amp;originWidth=1800&amp;amp;size=294430&amp;amp;status=done&amp;amp;style=none&amp;amp;width=1800#align=left&amp;amp;display=inline&amp;amp;height=944&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;originHeight=944&amp;amp;originWidth=1800&amp;amp;status=done&amp;amp;style=none&amp;amp;width=1800&quot; alt=&quot;WechatIMG81.png&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;从图片中，我们看到，在K的值为3的时候，与未标记样本最近的3个邻居其中2个为菠萝，而1个为凤梨，那么这个时候我们预测这个未知的水果为菠萝。&lt;/p&gt;
&lt;h3 id=&quot;3-伪代码说明&quot;&gt;3 伪代码说明&lt;/h3&gt;
&lt;p&gt;我们先来看一下如何用伪代码来实现这个算法，这样我们在后边的学习中才能更好的写出来这段代码。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一步，我们设x_test为待标记的数据样本，x_train为已标记的数据集。&lt;/li&gt;
&lt;li&gt;第二步，遍历x_train中的所有样本，计算每个样本与x_test的距离，并把距离保存在distance数组中。&lt;/li&gt;
&lt;li&gt;第三步，对distance数组进行排序，取距离最近的k个点，标记为x_knn。&lt;/li&gt;
&lt;li&gt;第四步，在x_knn中统计每个类别的个数，即class0(类别0)在x_knn中有几个样本，class1 (类别1)在x_knn中有几个样本。&lt;/li&gt;
&lt;li&gt;第五步，待标记样本的类别，就是x_knn中样本个数最多的那个类别。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;4-优缺点分析&quot;&gt;4 优缺点分析&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;优点：准确性高，对异常值有较高的容忍度，原因是异常值会单独分布在坐标系的一个角落，取k个邻居的时候大概率失去不到这个异常值的。&lt;/li&gt;
&lt;li&gt;缺点：计算量大，对内存的需求也大，因为它每次对一个未标记的样本进行分类的时候，都需要全部计算一下距离。&lt;/li&gt;
&lt;li&gt;关键点：k值的选取，首先k值一定是奇数，这样可以确保两个类别的投票不会一样，其次，k值越大，模型的偏差越大，对于噪声数据（错误数据或异常数据）越不敏感，k值太小就会造成模型的过拟合。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;二-邻近算法的代码练习&quot;&gt;二 邻近算法的代码练习&lt;/h2&gt;
&lt;h3 id=&quot;1-准备数据&quot;&gt;1 准备数据&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 从sklearn库中的数据集对象里导入样本生成器中的make_blobs方法帮助我们生成数据
from sklearn.datasets.samples_generator import make_blobs

# 声明三个直角坐标系中的位置
centers = [[-2, 2], [2, 2], [0, 4]]

# 生成数据,其中n_samples是生成数据的个数，centers是中心点，cluster_std是标准差，指明离散程度
x, y = make_blobs(n_samples=60, centers=centers, cluster_std=0.6)

# x是生成的数据，y是不同的数据对应所属的的类别0，1，2
print(x, y)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;2-用图形来帮助理解&quot;&gt;2 用图形来帮助理解&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import matplotlib.pyplot as plt
import numpy as np

plt.figure(figsize=(16, 10), dpi=144)
c = np.array(centers)
# x轴，y轴，c颜色  s指定点的大小
plt.scatter(x[:, 0], x[:, 1], c=y, s=100, cmap=&quot;cool&quot;)
# 画出中心点
plt.scatter(c[:, 0], c[:, 1], s=100, marker=&quot;^&quot;, c=&quot;orange&quot;)
plt.show()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;图形显示如下图所示：&lt;br/&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/281865/1601533951776-9a8cbacf-15de-4c9d-9f10-7a0c2ae3ed62.png#align=left&amp;amp;display=inline&amp;amp;height=529&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=image.png&amp;amp;originHeight=1058&amp;amp;originWidth=1492&amp;amp;size=129824&amp;amp;status=done&amp;amp;style=none&amp;amp;width=746&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;图形中显示的三个三角形的点就是中心点，围绕在它们周围的圆点就是我们随机生成的数据的点。&lt;/p&gt;
&lt;h3 id=&quot;3-knn算法对数据的训练&quot;&gt;3 KNN算法对数据的训练&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 从sklearn库中导入K邻居分类器：KNeighbosrClassifier
from sklearn.neighbors import KNeighborsClassifier

# 设定K值
k = 5

# 声明k临近分类器对象
clf = KNeighborsClassifier(n_neighbors=k)

# 训练模型
clf.fit(x, y)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;4-预测样本数据&quot;&gt;4 预测样本数据&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 定义样本数据
x_sample = [[0, 2]]
# 使用模型进预测
neighbors = clf.kneighbors(x_sample, return_distance=False)
print(neighbors)

# 输出值:[[23 39 21 47 29]]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;x_sample变量是我们要进行预测的样本，然后使用clf.kneighbors方法就可以对这个样本进行预测了。关于clf.kneighbors的参数return_distance，它决定了是否返回计算后的距离，默认是True，这里我把它修改成了False，你如果想要看一下值为True是什么样子，可以自己手动修改为True。到这里你可以有一点懵，这怎么就预测完成了呢？输出值表示的是什么意思呢？&lt;/p&gt;&lt;p&gt;输出值表示的是5个经过计算之后的位于x训练集中的索引值，它们并不是直接的位置。&lt;/p&gt;
&lt;h3 id=&quot;5-画出预测的结果&quot;&gt;5 画出预测的结果&lt;/h3&gt;
&lt;p&gt;为了能够使预测的结果更加直观，我们还需要用代码把他们画出来。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 把带预测的样本以及和其最近的5个点标记出来
plt.figure(figsize=(8, 5), dpi=144)  # dpi是像素值
plt.scatter(x[:, 0], x[:, 1], c=y, s=100, cmap='cool')  # 样本数据
plt.scatter(c[:, 0], c[:, 1], s=100, marker='^', c='k')  # 中心点

# 带预测的点
plt.scatter(x_sample[0][0], x_sample[0][1], marker='x', s=100, cmap='cool')

# 把预测点与距离最近的5个样本连成线
for i in neighbors[0]:
    plt.plot([x[i][0], x_sample[0][0]], [x[i][1], x_sample[0][1]], 'k--', linewidth=0.6)

plt.show()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;显示结果如下图所示：&lt;br/&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/281865/1601559625920-fc5a9f38-75a0-4958-a546-47dc6c567e76.png#align=left&amp;amp;display=inline&amp;amp;height=666&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=image.png&amp;amp;originHeight=1332&amp;amp;originWidth=2070&amp;amp;size=183117&amp;amp;status=done&amp;amp;style=none&amp;amp;width=1035&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;三-花卉识别项目练习&quot;&gt;三 花卉识别项目练习&lt;/h2&gt;
&lt;h3 id=&quot;1-先认识三朵花&quot;&gt;1 先认识三朵花&lt;/h3&gt;
&lt;p&gt;在这一小节我们将通过一个花卉识别项目的练习来巩固我们所讲的KNN算法，训练数据集是非常著名的鸢尾花数据集，涉及到的花的种类一共分为三种：&lt;/p&gt;&lt;p&gt;第一种花是山鸢尾，长下面这个样子&lt;br/&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/281865/1601560826570-957c7d44-3be1-4533-9735-a052d171a86c.png#align=left&amp;amp;display=inline&amp;amp;height=263&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=image.png&amp;amp;originHeight=526&amp;amp;originWidth=670&amp;amp;size=817547&amp;amp;status=done&amp;amp;style=none&amp;amp;width=335&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;第二种花是锦葵，也叫虹膜锦葵&lt;br/&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/281865/1601560900513-d7b7231e-0d12-43fc-b1a5-36332292d6ca.png#align=left&amp;amp;display=inline&amp;amp;height=300&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=image.png&amp;amp;originHeight=600&amp;amp;originWidth=976&amp;amp;size=1463645&amp;amp;status=done&amp;amp;style=none&amp;amp;width=488&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;第三种花是变色鸢尾&lt;br/&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/281865/1601560952406-e14a2b28-67d7-4ebb-8fc9-efa4d2093e18.png#align=left&amp;amp;display=inline&amp;amp;height=445&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=image.png&amp;amp;originHeight=890&amp;amp;originWidth=706&amp;amp;size=1826612&amp;amp;status=done&amp;amp;style=none&amp;amp;width=353&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-导入数据集&quot;&gt;2 导入数据集&lt;/h3&gt;
&lt;p&gt;我们可以通过sklearn库的自带数据集直接引入鸢尾花的数据集，在这个数据集中，我们可以通过花萼长度，花萼宽度，花瓣长度和花瓣宽度四个属性来预测未标记的鸢尾花属于哪个类别。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 1 导入鸢尾花数据集
from sklearn.datasets import load_iris

# 2 声明一个鸢尾花的类对象
iris = load_iris()

# 3 获取鸢尾花的数据
iris_data = iris.data

# 4 获取数据对应的种类
iris_target = iris.target

print(iris_data)
print(iris_target)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看数据后你会看到iris_data变量里每一个元素一共有4个值，这四个值就是分别对应花萼长度、花萼宽度、花瓣长度、花瓣宽度4个属性，iris_target变量对应的就是每一个花所属的类别。一共对应的是3个类别，0的意思是山鸢尾，1是虹膜锦葵，2是变色鸢尾。&lt;/p&gt;
&lt;h3 id=&quot;3-训练模型&quot;&gt;3 训练模型&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from sklearn.datasets import load_iris
from sklearn.model_selection import train_test_split  # 分割训练集和测试集
from sklearn.neighbors import KNeighborsClassifier

iris = load_iris()
iris_data = iris.data
iris_target = iris.target

# 把数据分为训练集和测试集，x表示特征值，y表示目标值，test_size=0.25表示将25%的数据用作测试集
x_train, x_test, y_train, y_test = train_test_split(iris_data, iris_target, test_size=0.25)

# 创建KNN算法实例，n_neighbors参数默认为5，后续可以通过网格搜索获取最优参数
knn = KNeighborsClassifier(n_neighbors=5)

# 训练测试集数据
knn.fit(x_train, y_train)

# 获取预测结果
y_predict = knn.predict(x_test)

# 展示预测结果
labels = ['山鸢尾', '虹膜锦葵', '变色鸢尾']
for i in range(len(y_predict)):
    print('第%d次测试：预测值：%s 真实值：%s' %((i + 1), labels[y_predict[i]], labels[y_test[i]]))
print('准确率：', knn.score(x_test, y_test))
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;4-获取k值最优参数&quot;&gt;4 获取k值最优参数&lt;/h3&gt;
&lt;p&gt;k值选取的思路是我们先来选择一个k值的范围，把这个范围中所有的误差值都获取到，然后我们再来选择误差最小的值作为k值。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from sklearn.datasets import load_iris
from sklearn.model_selection import cross_val_score
from sklearn.neighbors import KNeighborsClassifier
import matplotlib.pyplot as plt

# 中文显示
plt.rcParams[&quot;font.family&quot;] = 'Arial Unicode MS'

# 导入数据集
iris = load_iris()
x = iris.data
y = iris.target

# 限制k的取值范围
k_range = range(1, 31)

# 记录每当k值变换一次，它的错误值是多少
k_error = []


for k in k_range:
    knn = KNeighborsClassifier(n_neighbors=k)
    
    # cv参数决定数据集划分比例，这里按照5:1划分训练集和测试集
    scores = cross_val_score(knn, x, y, cv=6)
    print(scores)
    
    k_error.append(1 / scores.mean())

# 把结果画成图，直观看出k取什么值误差最小，x轴为k值，y轴为误差值
plt.plot(k_range, k_error)
plt.xlabel('k值')
plt.ylabel('误差值')
plt.show()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;图形显示结果如下图所示：&lt;br/&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/281865/1601569999884-f80f4acf-319b-417a-9fb1-852b4de9c50f.png#align=left&amp;amp;display=inline&amp;amp;height=444&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=image.png&amp;amp;originHeight=888&amp;amp;originWidth=1174&amp;amp;size=93530&amp;amp;status=done&amp;amp;style=none&amp;amp;width=587&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;根据这个图形我们就可以看得出来，k值大概是在12这个位置时，误差是最小的。这时当我们把12重新放入到之前的代码中，可能你会发现他的准确率并没有提升甚至还有可能下降了，其实是因为数据量比较小的缘故，并不影响我们解决问题的方式。&lt;/p&gt;
&lt;h2 id=&quot;四-kneighborsclassifier参数详解&quot;&gt;四 KNeighborsClassifier参数详解&lt;/h2&gt;
&lt;p&gt;通过前面的练习，相信你已经基本掌握了KNeighborsClassifier的使用方法了，最后，在这里我们会对这个方法的参数进行更细致的说明和讲解。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 查看KNeighborsClassifier源代码
NeighborsClassifier(
    n_neighbors=5,
    weights=&quot;uniform”,
    algorithm=”auto“,
    leaf_size=30,
    p=2,
    metric=&quot;minkowski&quot;,
    metric_params=None,
    n_jobs=None,
    **kwargs,
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;weights用于指定临近样本的投票权重，默认是uniform，表示所有邻近样本投票权重都是一样的。如果我们把weights的值设置成distance，表示投票权重与距离成反比，也就是说邻近样本与未知类别样本距离越远，则其权重越小，反之，权重越大。&lt;/li&gt;
&lt;li&gt;algorithm用于指定邻近样本的搜寻方法，如果值为ball_tree，表示用球树搜寻法寻找近邻样本，kd_tree就是KD树搜寻法，brute是使用暴力搜寻法。algorithm默认参数是auto，表示KNN算法会根据数据特征自动选择最佳搜寻方法。关于这些搜寻法的细节，我会在未来发布的机器学习的文章中做详细的说明，现在只需要知道我们当前用的是默认的自动帮我们选择的搜寻方法。&lt;/li&gt;
&lt;li&gt;leaf_size用于指定球树或者KD树叶子节点所包含的最小样本量，它用于控制树的生长条件，会影响查询速度，默认值是30，目前我们先不关注这个点。&lt;/li&gt;
&lt;li&gt;metric参数是用来指定距离的度量指标，默认为闵可夫斯基距离。&lt;/li&gt;
&lt;li&gt;p参数是依赖metric参数生效的，当metric为minkowski距离时，p=1表示计算点之间的曼哈顿距离，p=2表示计算点之间的欧式距离，默认值为2，计算欧式距离。&lt;/li&gt;
&lt;li&gt;metric_params是一个字典，默认值为空，它为metric参数所对应的距离指标添加关键字参数。&lt;/li&gt;
&lt;li&gt;n_jobs设置KNN算法并行计算时所需的CPU数量，默认值为1，表示仅使用一个CPU运行算法，也就是不开启并行运算。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;同样的，最后我们会有一个小的练习，请点击下方链接下载：&lt;br/&gt;&lt;a href=&quot;https://www.yuque.com/attachments/yuque/0/2020/zip/281865/1601572808915-6a64e8ce-e134-47ee-8408-fecea06dd2dc.zip?_lake_card=%7B%22uid%22%3A%221601572808757-0%22%2C%22src%22%3A%22https%3A%2F%2Fwww.yuque.com%2Fattachments%2Fyuque%2F0%2F2020%2Fzip%2F281865%2F1601572808915-6a64e8ce-e134-47ee-8408-fecea06dd2dc.zip%22%2C%22name%22%3A%22chapter9-1.zip%22%2C%22size%22%3A35458%2C%22type%22%3A%22application%2Fzip%22%2C%22ext%22%3A%22zip%22%2C%22progress%22%3A%7B%22percent%22%3A99%7D%2C%22status%22%3A%22done%22%2C%22percent%22%3A0%2C%22id%22%3A%220Y5HN%22%2C%22card%22%3A%22file%22%7D&quot;&gt;chapter9-1.zip&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 01 Oct 2020 17:23:00 +0000</pubDate>
<dc:creator>马一特</dc:creator>
<og:description>一 邻近算法的基本介绍 1 基本说明 邻近算法又叫做K临近算法或者KNN(K-NearestNeighbor)，是机器学习中非常重要的一个算法，but它简单得一塌糊涂，其核心思想就是样本的类别由距离其</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mayite/p/13759704.html</dc:identifier>
</item>
<item>
<title>Android Handler MessageQueue Looper 消息机制原理 - 柯壮</title>
<link>http://www.cnblogs.com/kezhuang/p/13759497.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kezhuang/p/13759497.html</guid>
<description>&lt;p&gt;提到Android里的消息机制，便会提到Message、Handler、Looper、MessageQueue这四个类，我先简单介绍以下这4个类&lt;br/&gt;之间的爱恨情仇。&lt;/p&gt;
&lt;h2 id=&quot;message&quot;&gt;Message&lt;/h2&gt;
&lt;p&gt;消息的封装类，里边存储了消息的详细信息，以及要传递的数据&lt;/p&gt;
&lt;h2 id=&quot;handler&quot;&gt;Handler&lt;/h2&gt;
&lt;p&gt;主要用在消息的发送上，有即时消息，有延迟消息，内部还提供了享元模式封装了消息对象池，能够有效的减少重复对象的创建，留更多的内存做其他的事，&lt;/p&gt;
&lt;h2 id=&quot;looper&quot;&gt;Looper&lt;/h2&gt;
&lt;p&gt;这个类内部持有一个MessageQueue对象，当创建Looper的时候，同时也会创建一个MessageQueue，然后Looper的主要工作就不断的轮训MessageQueue，轮到天荒地老的那种&lt;/p&gt;
&lt;h2 id=&quot;messagequeue&quot;&gt;MessageQueue&lt;/h2&gt;
&lt;p&gt;内部持有一个Message对象，采用单项链表的形式来维护消息列队。并且提供了入队，出队的基础操作&lt;/p&gt;
&lt;p&gt;举个现实中的栗子，Message就相当于包装好的快递盒子，Handler就相当于传送带，MessageQueue就相当于快递车，Looper就相当于快递员，联想一下，来个快递盒子，biu丢到传送带上，传送带很智能，直接传送到快递三轮车里，然后快递小哥送一波～，日夜交替，不分昼夜的工作，好家伙，007工作制&lt;/p&gt;
&lt;h2 id=&quot;消息机制的初始化&quot;&gt;消息机制的初始化&lt;/h2&gt;
&lt;p&gt;好，我们把这4个家伙从头到位分析一遍，要想使用Android的消息，首先要创建Looper对象，Android系统已经帮我们在UI线程内创建好了一个，我们可以看一下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public final class ActivityThread extends ClientTransactionHandler {
    /**
     * The main entry point from zygote.
     */
    public static void main(String[] args) {
        Looper.prepareMainLooper();

        ActivityThread thread = new ActivityThread();
        thread.attach(false, startSeq);

        if (sMainThreadHandler == null) {
            sMainThreadHandler = thread.getHandler();
        }

        if (false) {
            Looper.myLooper().setMessageLogging(new
                    LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;));
        }

        // End of event ActivityThreadMain.
        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
        Looper.loop();

        throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ActivityThread&lt;/code&gt;这个类大家应该不陌生吧，没错，他就是我们App的主线程管理类，我们看到他调用了 &lt;code&gt;prepareMainLooper&lt;/code&gt; 来初始化，然后 &lt;code&gt;loop&lt;/code&gt;，天荒地老的那种loop，这个&lt;code&gt;loop&lt;/code&gt;，我们最后聊&lt;/p&gt;
&lt;p&gt;我们看一下Looper内部提供的 &lt;code&gt;prepareMainLooper&lt;/code&gt; 实现&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static void prepareMainLooper() {
    prepare(false);
    synchronized (Looper.class) {
        if (sMainLooper != null) {
            throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;);
        }
        sMainLooper = myLooper();
    }
}
public static void prepare() {
    prepare(true);
}
private static void prepare(boolean quitAllowed) {
    if (sThreadLocal.get() != null) {
        throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);
    }
    sThreadLocal.set(new Looper(quitAllowed));
}
private Looper(boolean quitAllowed) {
    mQueue = new MessageQueue(quitAllowed);
    mThread = Thread.currentThread();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上边涉及到了3个方法，我都贴出来了，首先 &lt;code&gt;quitAllowed&lt;/code&gt; 这个参数代表该Looper是否可以退出，我们主线程内的Looper是不允许退出的，所以封装了 &lt;code&gt;prepareMainLooper&lt;/code&gt; 方法和 &lt;code&gt;prepare&lt;/code&gt; 方法已做区分，我们项目中平时用的都是 &lt;code&gt;prepare&lt;/code&gt; 方法，因为是子线程，所以允许退出Looper，大家在子线程内用完记得调用quit哦~&lt;br/&gt;这里我们看Looper内部是通过ThreadLocal维护的Looper对象，也就是说每个线程都是相互独立的。而且Looper做了限制，每个线程内部只能存在一个Looper对象，等同于每个线程内只能有一个MessageQueue&lt;br/&gt;最后在Looper的构造方法内，创建了一个MessageQueue对象，整个Looper的初始化就结束了&lt;/p&gt;
&lt;h2 id=&quot;创建消息&quot;&gt;创建消息&lt;/h2&gt;
&lt;p&gt;我们准备好了Looper和MessageQueue后，就可以创建消息啦，接下来我们创建一个消息吧&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//直接new对象，不推荐的方式
Message msg = new Message();
//推荐：内部是一个复用对象池
Message message = handler.obtainMessage();
message.what = 1;
message.obj = &quot;hello world&quot;;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;发送消息（入队）&quot;&gt;发送消息（入队）&lt;/h2&gt;
&lt;p&gt;我们发送消息的时候，都是会借助Handler的sendMessage就可以把消息发送到列队里了，我们往下看是如何完成的入队操作吧，首先我们平时都是创建一个Handler，然后调用&lt;code&gt;sendMessage&lt;/code&gt;就可以了&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Handler handler = new Handler();
handler.sendMessage(message);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们先看一下Handler的构造方法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public Handler() {
    this(null, false);
}
public Handler(@Nullable Callback callback, boolean async) {
    //FIND_POTENTIAL_LEAKS一直都是false，所以不用关心这个逻辑
    if (FIND_POTENTIAL_LEAKS) {
        final Class&amp;lt;? extends Handler&amp;gt; klass = getClass();
        if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;amp;&amp;amp;
                (klass.getModifiers() &amp;amp; Modifier.STATIC) == 0) {
            Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; +
                klass.getCanonicalName());
        }
    }
    //得到当前线程下的Looper对象
    mLooper = Looper.myLooper();
    if (mLooper == null) {
        throw new RuntimeException(
            &quot;Can't create handler inside thread &quot; + Thread.currentThread()
                    + &quot; that has not called Looper.prepare()&quot;);
    }
    //从Loopper内部获取一个列队
    mQueue = mLooper.mQueue;
    // 回调对象，我们平时写的时候，一般都是用类集成的方式重写 handleMessage 方法
    mCallback = callback;
    //标示当前Handler是否支持异步消息
    mAsynchronous = async;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实构造方法很简单呐，就是获取Looper对象，然后初始化列队和回调对象就完事了，我们继续看sendMessage然后看消息的入队吧&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public final boolean sendMessage(@NonNull Message msg) {
    return sendMessageDelayed(msg, 0);
}
public final boolean sendMessageDelayed(@NonNull Message msg, long delayMillis) {
    if (delayMillis &amp;lt; 0) {
        delayMillis = 0;
    }
    return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);
}
public boolean sendMessageAtTime(@NonNull Message msg, long uptimeMillis) {
    MessageQueue queue = mQueue;
    if (queue == null) {
        RuntimeException e = new RuntimeException(
                this + &quot; sendMessageAtTime() called with no mQueue&quot;);
        Log.w(&quot;Looper&quot;, e.getMessage(), e);
        return false;
    }
    return enqueueMessage(queue, msg, uptimeMillis);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过内部的重载方法，一直调用到&lt;code&gt;sendMessageAtTime&lt;/code&gt;方法，在这里得到Handler内部的&lt;code&gt;MessageQueue&lt;/code&gt;对象，然后调用了 &lt;code&gt;enqueueMessage&lt;/code&gt; 方法准备入队&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private boolean enqueueMessage(@NonNull MessageQueue queue, @NonNull Message msg,
        long uptimeMillis) {
    msg.target = this;
    msg.workSourceUid = ThreadLocalWorkSource.getUid();

    if (mAsynchronous) {
        msg.setAsynchronous(true);
    }
    return queue.enqueueMessage(msg, uptimeMillis);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里调用了MessageQueue的&lt;code&gt;enqueueMessage&lt;/code&gt;方法真正入队，我们继续看一下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;boolean enqueueMessage(Message msg, long when) {
    if (msg.target == null) {
        throw new IllegalArgumentException(&quot;Message must have a target.&quot;);
    }
    if (msg.isInUse()) {
        throw new IllegalStateException(msg + &quot; This message is already in use.&quot;);
    }

    synchronized (this) {
        //如果当前退出状态，则回收消息，并返回消息入队失败
        if (mQuitting) {
            IllegalStateException e = new IllegalStateException(
                    msg.target + &quot; sending message to a Handler on a dead thread&quot;);
            Log.w(TAG, e.getMessage(), e);
            msg.recycle();
            return false;
        }

        msg.markInUse();
        msg.when = when;
        Message p = mMessages;
        boolean needWake;
        //如果链表是空的，或者当前消息的when小于表头的when的时候，便会重新设置表头
      //这里可以得知，消息的顺序是按照延迟时间，从小往大排序的
        if (p == null || when == 0 || when &amp;lt; p.when) {
            // New head, wake up the event queue if blocked.
            msg.next = p;
            mMessages = msg;
            needWake = mBlocked;
        } else {
            // Inserted within the middle of the queue.  Usually we don't have to wake
            // up the event queue unless there is a barrier at the head of the queue
            // and the message is the earliest asynchronous message in the queue.
            needWake = mBlocked &amp;amp;&amp;amp; p.target == null &amp;amp;&amp;amp; msg.isAsynchronous();
            Message prev;
            for (;;) {
                prev = p;
                p = p.next;
                if (p == null || when &amp;lt; p.when) {
                    break;
                }
                if (needWake &amp;amp;&amp;amp; p.isAsynchronous()) {
                    needWake = false;
                }
            }
            //把msg放到链表最后
            msg.next = p; // invariant: p == prev.next
            prev.next = msg;
        }

        // We can assume mPtr != 0 because mQuitting is false.
        if (needWake) {
            nativeWake(mPtr);
        }
    }
    return true;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过这个方法，我们了解到MessageQueue是通过Message的单链结构存储的，然后每次入队的时候，都会&lt;br/&gt;通过这个&lt;code&gt;enqueueMessage&lt;/code&gt;方法向链表的最末尾添加数据。&lt;/p&gt;
&lt;p&gt;最后我们聊一下Looper下的&lt;code&gt;loop&lt;/code&gt;方法吧&lt;/p&gt;
&lt;p&gt;接下来我们看一下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static void loop() {
    final Looper me = myLooper();
    if (me == null) {
        throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn't called on this thread.&quot;);
    }
    final MessageQueue queue = me.mQueue;

    // Make sure the identity of this thread is that of the local process,
    // and keep track of what that identity token actually is.
    Binder.clearCallingIdentity();
    final long ident = Binder.clearCallingIdentity();

    // Allow overriding a threshold with a system prop. e.g.
    // adb shell 'setprop log.looper.1000.main.slow 1 &amp;amp;&amp;amp; stop &amp;amp;&amp;amp; start'
    final int thresholdOverride =
            SystemProperties.getInt(&quot;log.looper.&quot;
                    + Process.myUid() + &quot;.&quot;
                    + Thread.currentThread().getName()
                    + &quot;.slow&quot;, 0);

    boolean slowDeliveryDetected = false;

    for (;;) {
        //queue的next会阻塞
        Message msg = queue.next(); // might block
        if (msg == null) {
            // No message indicates that the message queue is quitting.
            return;
        }

        // This must be in a local variable, in case a UI event sets the logger
        final Printer logging = me.mLogging;
        if (logging != null) {
            logging.println(&quot;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; Dispatching to &quot; + msg.target + &quot; &quot; +
                    msg.callback + &quot;: &quot; + msg.what);
        }
        // Make sure the observer won't change while processing a transaction.
        final Observer observer = sObserver;

        final long traceTag = me.mTraceTag;
        long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;
        long slowDeliveryThresholdMs = me.mSlowDeliveryThresholdMs;
        if (thresholdOverride &amp;gt; 0) {
            slowDispatchThresholdMs = thresholdOverride;
            slowDeliveryThresholdMs = thresholdOverride;
        }
        final boolean logSlowDelivery = (slowDeliveryThresholdMs &amp;gt; 0) &amp;amp;&amp;amp; (msg.when &amp;gt; 0);
        final boolean logSlowDispatch = (slowDispatchThresholdMs &amp;gt; 0);

        final boolean needStartTime = logSlowDelivery || logSlowDispatch;
        final boolean needEndTime = logSlowDispatch;

        if (traceTag != 0 &amp;amp;&amp;amp; Trace.isTagEnabled(traceTag)) {
            Trace.traceBegin(traceTag, msg.target.getTraceName(msg));
        }

        final long dispatchStart = needStartTime ? SystemClock.uptimeMillis() : 0;
        final long dispatchEnd;
        Object token = null;
        if (observer != null) {
            token = observer.messageDispatchStarting();
        }
        long origWorkSource = ThreadLocalWorkSource.setUid(msg.workSourceUid);
        try {
            //派发消息，执行回调handleMessage
            msg.target.dispatchMessage(msg);
            if (observer != null) {
                observer.messageDispatched(token, msg);
            }
            dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0;
        } catch (Exception exception) {
            if (observer != null) {
                observer.dispatchingThrewException(token, msg, exception);
            }
            throw exception;
        } finally {
            ThreadLocalWorkSource.restore(origWorkSource);
            if (traceTag != 0) {
                Trace.traceEnd(traceTag);
            }
        }
        if (logSlowDelivery) {
            if (slowDeliveryDetected) {
                if ((dispatchStart - msg.when) &amp;lt;= 10) {
                    Slog.w(TAG, &quot;Drained&quot;);
                    slowDeliveryDetected = false;
                }
            } else {
                if (showSlowLog(slowDeliveryThresholdMs, msg.when, dispatchStart, &quot;delivery&quot;,
                        msg)) {
                    // Once we write a slow delivery log, suppress until the queue drains.
                    slowDeliveryDetected = true;
                }
            }
        }
        if (logSlowDispatch) {
            showSlowLog(slowDispatchThresholdMs, dispatchStart, dispatchEnd, &quot;dispatch&quot;, msg);
        }

        if (logging != null) {
            logging.println(&quot;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback);
        }

        // Make sure that during the course of dispatching the
        // identity of the thread wasn't corrupted.
        final long newIdent = Binder.clearCallingIdentity();
        if (ident != newIdent) {
            Log.wtf(TAG, &quot;Thread identity changed from 0x&quot;
                    + Long.toHexString(ident) + &quot; to 0x&quot;
                    + Long.toHexString(newIdent) + &quot; while dispatching to &quot;
                    + msg.target.getClass().getName() + &quot; &quot;
                    + msg.callback + &quot; what=&quot; + msg.what);
        }

        msg.recycleUnchecked();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Looper内的loop方法别看这么多，大多数都是日志相关的处理。其实他就两件事&lt;br/&gt;第一件事就是从列队中通过&lt;code&gt;next&lt;/code&gt;取出Message对象&lt;br/&gt;第二件事就是通过Message对象上绑定的target对象&lt;code&gt;dispatchMessage&lt;/code&gt;方法，来分发消息&lt;br/&gt;我们接下来看一下&lt;code&gt;dispatchMessage&lt;/code&gt;方法，然后在看MessageQueue的&lt;code&gt;next&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void dispatchMessage(@NonNull Message msg) {
    if (msg.callback != null) {
        handleCallback(msg);
    } else {
        if (mCallback != null) {
            if (mCallback.handleMessage(msg)) {
                return;
            }
        }
        handleMessage(msg);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;灰常简单，判断CallBack对象。然后调用handleMessage就完事了，我们的Activity就收到数据了。&lt;br/&gt;接下来我们看看MessageQueue的&lt;code&gt;next&lt;/code&gt;是怎么获取列队内的消息的把。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Message next() {
    // Return here if the message loop has already quit and been disposed.
    // This can happen if the application tries to restart a looper after quit
    // which is not supported.
    final long ptr = mPtr;
    if (ptr == 0) {
        return null;
    }

    int pendingIdleHandlerCount = -1; // -1 only during first iteration
    int nextPollTimeoutMillis = 0;
    for (;;) {
        if (nextPollTimeoutMillis != 0) {
            Binder.flushPendingCommands();
        }
        //没有消息的时候，或者有延迟消息的时候会进行睡眠
        nativePollOnce(ptr, nextPollTimeoutMillis);

        synchronized (this) {
            // Try to retrieve the next message.  Return if found.
            final long now = SystemClock.uptimeMillis();
            Message prevMsg = null;
            Message msg = mMessages;
            if (msg != null &amp;amp;&amp;amp; msg.target == null) {
                // Stalled by a barrier.  Find the next asynchronous message in the queue.
                do {
                    prevMsg = msg;
                    msg = msg.next;
                } while (msg != null &amp;amp;&amp;amp; !msg.isAsynchronous());
            }
            if (msg != null) {
                //当前时间小于消息内记录的时间，然后计算一个睡眠时间，跳出循环执行睡眠
                if (now &amp;lt; msg.when) {
                    nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);
                } else {
                    // Got a message.
                    mBlocked = false;
                    if (prevMsg != null) {
                        prevMsg.next = msg.next;
                    } else {
                        mMessages = msg.next;
                    }
                    msg.next = null;
                    if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg);
                    msg.markInUse();
                    return msg;
                }
            } else {
                // No more messages.
                nextPollTimeoutMillis = -1;
            }

            // Process the quit message now that all pending messages have been handled.
            if (mQuitting) {
                dispose();
                return null;
            }

            // If first time idle, then get the number of idlers to run.
            // Idle handles only run if the queue is empty or if the first message
            // in the queue (possibly a barrier) is due to be handled in the future.
            if (pendingIdleHandlerCount &amp;lt; 0
                    &amp;amp;&amp;amp; (mMessages == null || now &amp;lt; mMessages.when)) {
                pendingIdleHandlerCount = mIdleHandlers.size();
            }
            if (pendingIdleHandlerCount &amp;lt;= 0) {
                // No idle handlers to run.  Loop and wait some more.
                mBlocked = true;
                continue;
            }

            if (mPendingIdleHandlers == null) {
                mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];
            }
            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);
        }

        // Run the idle handlers.
        // We only ever reach this code block during the first iteration.
        for (int i = 0; i &amp;lt; pendingIdleHandlerCount; i++) {
            final IdleHandler idler = mPendingIdleHandlers[i];
            mPendingIdleHandlers[i] = null; // release the reference to the handler

            boolean keep = false;
            try {
                keep = idler.queueIdle();
            } catch (Throwable t) {
                Log.wtf(TAG, &quot;IdleHandler threw exception&quot;, t);
            }

            if (!keep) {
                synchronized (this) {
                    mIdleHandlers.remove(idler);
                }
            }
        }

        // Reset the idle handler count to 0 so we do not run them again.
        pendingIdleHandlerCount = 0;

        // While calling an idle handler, a new message could have been delivered
        // so go back and look again for a pending message without waiting.
        nextPollTimeoutMillis = 0;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先MessageQueue的消息是用单链表的形式存储，然后next函数做的事情就是死循环获取消息，&lt;br/&gt;在获取消息的时候判断一下消息是否符合执行时间，如果不符合执行时间，就进入睡眠状态等待消息。&lt;br/&gt;如果符合执行时间就直接返回Message给Looper进行分发，如果Message链表都为空。则睡眠时间是-1&lt;br/&gt;代表无休止的睡眠。在无休止睡眠的状态下，&lt;code&gt;enqueueMessage&lt;/code&gt;的&lt;code&gt;nativeWake&lt;/code&gt;方法，会进行一次唤醒，唤醒后&lt;code&gt;next&lt;/code&gt;函数继续执行，判断返回消息给Looper执行消息分发&lt;/p&gt;
</description>
<pubDate>Thu, 01 Oct 2020 15:24:00 +0000</pubDate>
<dc:creator>柯壮</dc:creator>
<og:description>提到Android里的消息机制，便会提到Message、Handler、Looper、MessageQueue这四个类，我先简单介绍以下这4个类 之间的爱恨情仇。 Message 消息的封装类，里边存</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kezhuang/p/13759497.html</dc:identifier>
</item>
<item>
<title>日志分析平台ELK之搜索引擎Elasticsearch集群 - Linux-1874</title>
<link>http://www.cnblogs.com/qiuhom-1874/p/13758006.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qiuhom-1874/p/13758006.html</guid>
<description>&lt;p&gt;　　一、简介&lt;/p&gt;
&lt;p&gt;　　什么是ELK？ELK是Elasticsearch、Logstash、Kibana这三个软件的首字母缩写；其中elasticsearch是用来做数据的存储和搜索的搜索引擎；logstash是数据收集处理平台，它能够对特定的数据做分析、切词、收集、过滤等等处理，通常用于对日志的处理；kibana是用于把处理后的数据做可视化展示，提供一个web界面，方便我们去elasticsearch中检索想要的数据；elasticsearch是一个高度可扩展的开源全文搜索和分析引擎，它可实现数据的实时全文搜索，支持分布式实现高可用，提供RUSTfull风格的API接口，可以处理大规模日志数据；&lt;/p&gt;
&lt;p&gt;　　elasticsearch是基于java语言在lucene的框架上进行开发实现；lucene是java中的一个成熟免费的开源搜索类库，本质上lucene只是提供编程API接口，要想使用lucene框架做搜索引擎，需要用户自行开发lucene的外壳，实现调用lucene的API接口实现全文检索和搜寻；elasticsearch就是以lucene为信息检索库的搜索引擎；&lt;/p&gt;
&lt;p&gt;　　elasticsearch的基本组件&lt;/p&gt;
&lt;p&gt;　　索引（index）：文档容器，具有类似属性的文档的集合。类似关系型数据库中的表的概念；在elasticsearch中索引名称必须使用小写字母；&lt;/p&gt;
&lt;p&gt;　　类型（type）：类型是索引内部的逻辑分区，其意义完全取决于用户需求。一个索引内部可定义一个或多个类型。一搬来说，类型就是拥有相同的域的文档的预定义；&lt;/p&gt;
&lt;p&gt;　　文档（document）：文档是lucene索引和搜索的原子单位，它包含了一个或多个域。是域的容器，基于JSON格式表示。一个域由一个名字，一个或多个值组成；拥有多个值得域，通常我们称为多值域；&lt;/p&gt;
&lt;p&gt;　　映射(mapping)：原始内容存储为文档之前需要事先进行分析，例如切词、过滤掉某些词等；映射用于定义此分析机制该如何实现；除此之外，ES（elasticsearch）还为映射提供了诸如将域中的内容排序等功能。&lt;/p&gt;
&lt;p&gt;　　elasticsearch集群组件&lt;/p&gt;
&lt;p&gt;　　cluster：ES的集群标识为集群名称；默认为&quot;elasticsearch&quot;。节点就是靠此名字来决定加入到哪个集群中。一个节点只能属于于一个集群。&lt;/p&gt;
&lt;p&gt;　　Node：运行了单个ES实例的主机即为节点。用于存储数据、参与集群索引及搜索操作。节点的标识靠节点名。&lt;/p&gt;
&lt;p&gt;　　Shard：将索引切割成为的物理存储组件；但每一个shard都是一个独立且完整的索引；创建索引时，ES默认将其分割为5个shard，用户也可以按需自定义，创建完成之后不可修改。shard有两种类型primary shard和replica。Replica用于数据冗余及查询时的负载均衡。每个主shard的副本数量可自定义，且可动态修改。&lt;/p&gt;
&lt;p&gt;　　ES Cluster工作过程&lt;/p&gt;
&lt;p&gt;　　启动时，通过多播(默认)或单播方式在9300/tcp查找同一集群中的其它节点，并与之建立通信。集群中的所有节点会选举出一个主节点负责管理整个集群状态，以及在集群范围内决定各shards的分布方式。站在用户角度而言，每个node均可接收并响应用户的各类请求。&lt;/p&gt;
&lt;p&gt;　　集群有状态：green, red, yellow；green表示集群状态健康，各节点上的shard和我们定义的一样；yellow表示集群状态亚健康，可能存在shard和我们定义的不一致，比如某个节点宕机了，它上面的shard也随着消失，此时集群的状态就是亚健康状态；一般yellow状态是很容易转变为green状态的；red表示集群状态不健康，比如3个节点有2个节点都宕机了，那么也就意味着这两个节点上的shard丢失，当然shard丢失，对应的数据也会随之丢失；所以red状态表示集群有丢失数据的风险；&lt;/p&gt;
&lt;p&gt;　　二、elasticsearch集群部署&lt;/p&gt;
&lt;p&gt;　　环境说明&lt;/p&gt;
&lt;p&gt;　　某个服务如果以分布式或集群的模式工作，首先我们要把各节点的时间进行同步，这是集群的基本原则；其次，一个集群的名称解析不能也不应该依赖外部的dns服务来解析，因为一旦dns服务挂掉，它会影响整个集群的通信，所以如果需要用到名称解析，我们应该首先考虑hosts文件来解析各节点名称；如果集群各节点间需要互相拷贝数据，我们应该还要做ssh 互信；以上三个条件是大多数集群的最基本条件；&lt;/p&gt;
&lt;table border=&quot;0&quot; align=&quot;left&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;ip地址&lt;/td&gt;
&lt;td&gt;端口&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;es1&lt;/td&gt;
&lt;td&gt;192.168.0.41&lt;/td&gt;
&lt;td&gt;9200/9300&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;es2&lt;/td&gt;
&lt;td&gt;192.168.0.42&lt;/td&gt;
&lt;td&gt;9200/9300&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;




&lt;p&gt;　　各节点安装jdk&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
yum install -y java-1.8.0-openjdk-devel
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：不同的es版本对jdk的版本要求也不一样，这个可以去官方文档中看，对应es版本需要用到的jdk版本；&lt;/p&gt;
&lt;p&gt;　　导出JAVA_HOME&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202010/1503305-20201001203727190-2084640865.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　验证java版本和JAVA_HOME环境变量&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202010/1503305-20201001203834930-768413087.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　下载elasticsearch rpm包&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node01 ~]# wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-6.8.12.rpm
--2020-10-01 20:44:29--  https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-6.8.12.rpm
Resolving artifacts.elastic.co (artifacts.elastic.co)... 151.101.110.222, 2a04:4e42:36::734
Connecting to artifacts.elastic.co (artifacts.elastic.co)|151.101.110.222|:443... connected.
HTTP request sent, awaiting response... 200 OK
Length: 148681336 (142M) [application/octet-stream]
Saving to: ‘elasticsearch-6.8.12.rpm’
100%[==========================================================================&amp;gt;] 148,681,336  133MB/s   in 1.1s   

2020-10-01 20:45:07 (133 MB/s) - ‘elasticsearch-6.8.12.rpm’ saved [148681336/148681336]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　安装elasticsearch rpm包&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node01 ~]# ll
total 145200
-rw-r--r-- 1 root root 148681336 Aug 18 19:38 elasticsearch-6.8.12.rpm
[root@node01 ~]# yum install ./elasticsearch-6.8.12.rpm 
Loaded plugins: fastestmirror
Examining ./elasticsearch-6.8.12.rpm: elasticsearch-6.8.12-1.noarch
Marking ./elasticsearch-6.8.12.rpm to be installed
Resolving Dependencies
--&amp;gt; Running transaction check
---&amp;gt; Package elasticsearch.noarch 0:6.8.12-1 will be installed
--&amp;gt; Finished Dependency Resolution

Dependencies Resolved

===================================================================================================================================
 Package                         Arch                     Version                    Repository                               Size
===================================================================================================================================
Installing:
 elasticsearch                   noarch                   6.8.12-1                   /elasticsearch-6.8.12                   229 M

Transaction Summary
===================================================================================================================================
Install  1 Package

Total size: 229 M
Installed size: 229 M
Is this ok [y/d/N]: y
Downloading packages:
Running transaction check
Running transaction test
Transaction test succeeded
Running transaction
Creating elasticsearch group... OK
Creating elasticsearch user... OK
  Installing : elasticsearch-6.8.12-1.noarch                                                                                   1/1 
### NOT starting on installation, please execute the following statements to configure elasticsearch service to start automatically using systemd
 sudo systemctl daemon-reload
 sudo systemctl enable elasticsearch.service
### You can start elasticsearch service by executing
 sudo systemctl start elasticsearch.service
Created elasticsearch keystore in /etc/elasticsearch
  Verifying  : elasticsearch-6.8.12-1.noarch                                                                                   1/1 

Installed:
  elasticsearch.noarch 0:6.8.12-1                                                                                                  

Complete!
[root@node01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　编辑配置文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202010/1503305-20201001210202305-1067592965.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：es的主配置文件是/etc/elasticsearch/elasticsearch.yml；其中我们需要配置cluster.name，node.name，path.data，path.log，这四项是非常重要的，cluster.name是配置的集群名称，同一集群各主机就是依赖这个配置判断是否是同一集群，所以在同一集群的其他节点的配置，这个名称必须一致；node.name是用于标识节点名称，这个名称在集群中是唯一的，也就说这个名称在同一集群的其他节点必须唯一，不能重复；path.data用于指定es存放数据的目录，建议各节点都配置同一个目录方便管理；其次这个目录还建议挂载一个存储；path.logs用于指定es的日志存放目录；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202010/1503305-20201001210904496-501761167.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：bootstrap.memory_lock: true这项配置表示启动es时，立即分配jvm.options这个文件中定义的内存大小；默认没有启用，如果要启用，我们需要主机节点内存是否够用，以及在启动脚本中指定es启动对内存无限制，同时我们也应该把elasticsearch用户的资源限制调大一些；network.host用于指定es监听的ip地址，0.0.0.0表示监听本机所有可用地址；http.port用于指定对用户提供服务的端口地址；discovery.zen.ping.unicast.hosts指定对那些主机做单播通信来发现节点；discovery.zen.minimum_master_nodes指定master节点的的最小数量；不指定默认就是1；&lt;/p&gt;
&lt;p&gt;　　完整的配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35.5&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_5c2afbdd-b7a1-4323-aae4-1e41820648a5&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_5c2afbdd-b7a1-4323-aae4-1e41820648a5&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_5c2afbdd-b7a1-4323-aae4-1e41820648a5&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
[root@node01 ~]# &lt;span&gt;cat&lt;/span&gt; /etc/elasticsearch/&lt;span&gt;elasticsearch.yml
# &lt;/span&gt;======================== Elasticsearch Configuration =========================&lt;span&gt;
#
# NOTE: Elasticsearch comes with reasonable defaults &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; most settings.
#       Before you set out to tweak and tune the configuration, &lt;/span&gt;&lt;span&gt;make&lt;/span&gt;&lt;span&gt; sure you
#       understand what are you trying to accomplish and the consequences.
#
# The primary way of configuring a node is via this &lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;. This template lists
# the most important settings you may want to configure &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; a production cluster.
#
# Please consult the documentation &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; further information on configuration options:
# https:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.elastic.co/guide/en/elasticsearch/reference/index.html&lt;/span&gt;
&lt;span&gt;#
# &lt;/span&gt;---------------------------------- Cluster -----------------------------------&lt;span&gt;
#
# Use a descriptive name &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; your cluster:
#
cluster.name: test&lt;/span&gt;-els-&lt;span&gt;cluster
#
# &lt;/span&gt;------------------------------------ Node ------------------------------------&lt;span&gt;
#
# Use a descriptive name &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; the node:
#
node.name: node01
#
# Add custom attributes to the node:
#
#node.attr.rack: r1
#
# &lt;/span&gt;----------------------------------- Paths ------------------------------------&lt;span&gt;
#
# Path to directory where to store the data (separate multiple locations by comma):
#
path.data: &lt;/span&gt;/els/&lt;span&gt;data
#
# Path to log files:
#
path.logs: &lt;/span&gt;/els/&lt;span&gt;logs
#
# &lt;/span&gt;----------------------------------- Memory -----------------------------------&lt;span&gt;
#
# Lock the memory on startup:
#
#bootstrap.memory_lock: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
#
# Make sure that the heap size is set to about half the memory available
# on the system and that the owner of the process is allowed to use this
# limit.
#
# Elasticsearch performs poorly when the system is swapping the memory.
#
# &lt;/span&gt;---------------------------------- Network -----------------------------------&lt;span&gt;
#
# Set the bind address to a specific IP (IPv4 or IPv6):
#
network.host: &lt;/span&gt;&lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;
#
# Set a custom port &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; HTTP:
#
http.port: &lt;/span&gt;&lt;span&gt;9200&lt;/span&gt;&lt;span&gt;
#
# For &lt;/span&gt;&lt;span&gt;more&lt;/span&gt;&lt;span&gt; information, consult the network module documentation.
#
# &lt;/span&gt;--------------------------------- Discovery ----------------------------------&lt;span&gt;
#
# Pass an initial list of hosts to perform discovery when new node is started:
# The default list of hosts is [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[::1]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
#
discovery.zen.&lt;/span&gt;&lt;span&gt;ping&lt;/span&gt;.unicast.hosts: [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;node01&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;node02&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
#
# Prevent the &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;split brain&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; by configuring the majority of nodes (total number of master-eligible nodes / &lt;span&gt;2&lt;/span&gt; + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;):
#
discovery.zen.minimum_master_nodes: &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
#
# For &lt;/span&gt;&lt;span&gt;more&lt;/span&gt;&lt;span&gt; information, consult the zen discovery module documentation.
#
# &lt;/span&gt;---------------------------------- Gateway -----------------------------------&lt;span&gt;
#
# Block initial recovery after a full cluster restart &lt;/span&gt;&lt;span&gt;until&lt;/span&gt;&lt;span&gt; N nodes are started:
#
#gateway.recover_after_nodes: &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
#
# For &lt;/span&gt;&lt;span&gt;more&lt;/span&gt;&lt;span&gt; information, consult the gateway module documentation.
#
# &lt;/span&gt;---------------------------------- Various -----------------------------------&lt;span&gt;
#
# Require explicit names when deleting indices:
#
#action.destructive_requires_name: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
[root@node01 &lt;/span&gt;~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　创建数据目录和日志目录，并把对应目录修改成elasticsearch属主和属组&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202010/1503305-20201001211750885-733760474.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　复制配置文件到其他节点对应位置，并修改node.name为对应节点名称，并在对应节点上创建数据目录和日志目录并把其属主和属组修改成elasticsearch&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202010/1503305-20201001212633634-759349587.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：对于node02上的es配置和node01上的配置，唯一不同的就是节点名称，其余都是一样的；&lt;/p&gt;
&lt;p&gt;　　启动node01、node02上的es，并把es设置为开机启动&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202010/1503305-20201001212955223-635275349.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可以看到node01和node02上的9200和9300都处于监听状态了；9200是用户对外提供服务的端口，9300是用于集群各节点通信端口；到此2节点的es集群就搭建好了；&lt;/p&gt;
&lt;p&gt;　　验证：访问node01和node02的9200端口，看看响应内容cluster_name和cluster_uuid是否是一样？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202010/1503305-20201001213429729-197937026.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可以看到访问node01和node02的9200端口，响应内容都响应了相同cluster_name和cluster_uuid；说明node01和node02属于同一个集群；&lt;/p&gt;
&lt;p&gt;　　查看es接口提供的cat接口&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node01 ~]# curl http://node02:9200/_cat
=^.^=
/_cat/allocation
/_cat/shards
/_cat/shards/{index}
/_cat/master
/_cat/nodes
/_cat/tasks
/_cat/indices
/_cat/indices/{index}
/_cat/segments
/_cat/segments/{index}
/_cat/count
/_cat/count/{index}
/_cat/recovery
/_cat/recovery/{index}
/_cat/health
/_cat/pending_tasks
/_cat/aliases
/_cat/aliases/{alias}
/_cat/thread_pool
/_cat/thread_pool/{thread_pools}
/_cat/plugins
/_cat/fielddata
/_cat/fielddata/{fields}
/_cat/nodeattrs
/_cat/repositories
/_cat/snapshots/{repository}
/_cat/templates
[root@node01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　查看集群node信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node01 ~]# curl http://node02:9200/_cat/nodes
192.168.0.42 19 96 1 0.00 0.05 0.05 mdi - node02
192.168.0.41 15 96 1 0.03 0.04 0.05 mdi * node01
[root@node01 ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：后面带*号的表示master节点；&lt;/p&gt;
&lt;p&gt;　　查看集群健康状态&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node01 ~]# curl http://node02:9200/_cat/health
1601559464 13:37:44 test-els-cluster green 2 2 0 0 0 0 0 0 - 100.0%
[root@node01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　查看集群索引信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node01 ~]# curl http://node02:9200/_cat/indices
[root@node01 ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：这里显示空，是因为集群里没有任何数据；&lt;/p&gt;
&lt;p&gt;　　查看集群分片信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node01 ~]# curl http://node02:9200/_cat/shards
[root@node01 ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　获取myindex索引下的test类型的1号文档信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;59&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node01 ~]# curl http://node02:9200/myindex/test/1
{&quot;error&quot;:{&quot;root_cause&quot;:[{&quot;type&quot;:&quot;index_not_found_exception&quot;,&quot;reason&quot;:&quot;no such index&quot;,&quot;resource.type&quot;:&quot;index_expression&quot;,&quot;resource.id&quot;:&quot;myindex&quot;,&quot;index_uuid&quot;:&quot;_na_&quot;,&quot;index&quot;:&quot;myindex&quot;}],&quot;type&quot;:&quot;index_not_found_exception&quot;,&quot;reason&quot;:&quot;no such index&quot;,&quot;resource.type&quot;:&quot;index_expression&quot;,&quot;resource.id&quot;:&quot;myindex&quot;,&quot;index_uuid&quot;:&quot;_na_&quot;,&quot;index&quot;:&quot;myindex&quot;},&quot;status&quot;:404}[root@node01 ~]# 
[root@node01 ~]# curl http://node02:9200/myindex/test/1?pretty
{
  &quot;error&quot; : {
    &quot;root_cause&quot; : [
      {
        &quot;type&quot; : &quot;index_not_found_exception&quot;,
        &quot;reason&quot; : &quot;no such index&quot;,
        &quot;resource.type&quot; : &quot;index_expression&quot;,
        &quot;resource.id&quot; : &quot;myindex&quot;,
        &quot;index_uuid&quot; : &quot;_na_&quot;,
        &quot;index&quot; : &quot;myindex&quot;
      }
    ],
    &quot;type&quot; : &quot;index_not_found_exception&quot;,
    &quot;reason&quot; : &quot;no such index&quot;,
    &quot;resource.type&quot; : &quot;index_expression&quot;,
    &quot;resource.id&quot; : &quot;myindex&quot;,
    &quot;index_uuid&quot; : &quot;_na_&quot;,
    &quot;index&quot; : &quot;myindex&quot;
  },
  &quot;status&quot; : 404
}
[root@node01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：?pretty表示用易读的JSON格式输出；从上面的反馈内容，它告诉我们没有找到指定的索引；&lt;/p&gt;
&lt;p&gt;　　添加一个文档到es集群的指定索引&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node01 ~]# curl -XPUT http://node01:9200/myindex/test/1 -d ' 
{&quot;name&quot;:&quot;zhangsan&quot;,&quot;age&quot;:18,&quot;gender&quot;:&quot;nan&quot;}'
{&quot;error&quot;:&quot;Content-Type header [application/x-www-form-urlencoded] is not supported&quot;,&quot;status&quot;:406}[root@node01 ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：这里向es写指定文档到指定索引下，返回不支持header头部；解决办法，手动指定头部类型；&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;46&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node01 ~]# curl -XPUT http://node01:9200/myindex/test/1  -H 'content-Type:application/json'  -d '
{&quot;name&quot;:&quot;zhangsan&quot;,&quot;age&quot;:18,&quot;gender&quot;:&quot;nan&quot;}'
{&quot;_index&quot;:&quot;myindex&quot;,&quot;_type&quot;:&quot;test&quot;,&quot;_id&quot;:&quot;1&quot;,&quot;_version&quot;:1,&quot;result&quot;:&quot;created&quot;,&quot;_shards&quot;:{&quot;total&quot;:2,&quot;successful&quot;:2,&quot;failed&quot;:0},&quot;_seq_no&quot;:0,&quot;_primary_term&quot;:1}[root@node01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　验证：查看myindex索引下的test类型的1号文档，看看是否能够查到我们刚才写的数据？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node01 ~]# curl  http://node01:9200/myindex/test/1?pretty
{
  &quot;_index&quot; : &quot;myindex&quot;,
  &quot;_type&quot; : &quot;test&quot;,
  &quot;_id&quot; : &quot;1&quot;,
  &quot;_version&quot; : 1,
  &quot;_seq_no&quot; : 0,
  &quot;_primary_term&quot; : 1,
  &quot;found&quot; : true,
  &quot;_source&quot; : {
    &quot;name&quot; : &quot;zhangsan&quot;,
    &quot;age&quot; : 18,
    &quot;gender&quot; : &quot;nan&quot;
  }
}
[root@node01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到返回了我们刚才写的文档内容；&lt;/p&gt;
&lt;p&gt;　　现在再次查看集群的索引信息和分片信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202010/1503305-20201001220416491-927729183.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可以看到现在es集群中有一个myindex的索引，其状态为green；分片信息中也可以看到有5各主分片和5个replica分片；并且每个分片都的master和replica都没有在同一个节点；&lt;/p&gt;
&lt;p&gt;　　搜索所有的索引和类型&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202010/1503305-20201001221651967-953171501.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：jq是用于以美观方式显示json数据，作用同pretty的一样；以上命令表示从所有类型所用索引中搜索，name字段为zhangsan的信息；如果命中了，就会把对应文档打印出来；未命中就告诉我们未命中；如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;57&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node01 ~]# curl http://node01:9200/_search?q=age:19|jq       
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100   135  100   135    0     0   2906      0 --:--:-- --:--:-- --:--:--  2934
{
  &quot;took&quot;: 37,
  &quot;timed_out&quot;: false,
  &quot;_shards&quot;: {
    &quot;total&quot;: 5,
    &quot;successful&quot;: 5,
    &quot;skipped&quot;: 0,
    &quot;failed&quot;: 0
  },
  &quot;hits&quot;: {
    &quot;total&quot;: 0,
    &quot;max_score&quot;: null,
    &quot;hits&quot;: []
  }
}
[root@node01 ~]# curl http://node01:9200/_search?q=age:18|jq 
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100   247  100   247    0     0  10795      0 --:--:-- --:--:-- --:--:-- 11227
{
  &quot;took&quot;: 12,
  &quot;timed_out&quot;: false,
  &quot;_shards&quot;: {
    &quot;total&quot;: 5,
    &quot;successful&quot;: 5,
    &quot;skipped&quot;: 0,
    &quot;failed&quot;: 0
  },
  &quot;hits&quot;: {
    &quot;total&quot;: 1,
    &quot;max_score&quot;: 1,
    &quot;hits&quot;: [
      {
        &quot;_index&quot;: &quot;myindex&quot;,
        &quot;_type&quot;: &quot;test&quot;,
        &quot;_id&quot;: &quot;1&quot;,
        &quot;_score&quot;: 1,
        &quot;_source&quot;: {
          &quot;name&quot;: &quot;zhangsan&quot;,
          &quot;age&quot;: 18,
          &quot;gender&quot;: &quot;nan&quot;
        }
      }
    ]
  }
}
[root@node01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：如果要在指定索引中搜索在前面的url加上指定的索引名称即可；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202010/1503305-20201001222242983-1142832567.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：如果有多个索引我们也可以根据多个索引名称的特点来使用*来匹配；如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;63&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node01 ~]# curl http://node01:9200/*/_search?q=age:18|jq
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100   247  100   247    0     0   8253      0 --:--:-- --:--:-- --:--:--  8517
{
  &quot;took&quot;: 20,
  &quot;timed_out&quot;: false,
  &quot;_shards&quot;: {
    &quot;total&quot;: 5,
    &quot;successful&quot;: 5,
    &quot;skipped&quot;: 0,
    &quot;failed&quot;: 0
  },
  &quot;hits&quot;: {
    &quot;total&quot;: 1,
    &quot;max_score&quot;: 1,
    &quot;hits&quot;: [
      {
        &quot;_index&quot;: &quot;myindex&quot;,
        &quot;_type&quot;: &quot;test&quot;,
        &quot;_id&quot;: &quot;1&quot;,
        &quot;_score&quot;: 1,
        &quot;_source&quot;: {
          &quot;name&quot;: &quot;zhangsan&quot;,
          &quot;age&quot;: 18,
          &quot;gender&quot;: &quot;nan&quot;
        }
      }
    ]
  }
}
[root@node01 ~]# curl http://node01:9200/my*/_search?q=age:18|jq
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100   247  100   247    0     0   7843      0 --:--:-- --:--:-- --:--:--  7967
{
  &quot;took&quot;: 19,
  &quot;timed_out&quot;: false,
  &quot;_shards&quot;: {
    &quot;total&quot;: 5,
    &quot;successful&quot;: 5,
    &quot;skipped&quot;: 0,
    &quot;failed&quot;: 0
  },
  &quot;hits&quot;: {
    &quot;total&quot;: 1,
    &quot;max_score&quot;: 1,
    &quot;hits&quot;: [
      {
        &quot;_index&quot;: &quot;myindex&quot;,
        &quot;_type&quot;: &quot;test&quot;,
        &quot;_id&quot;: &quot;1&quot;,
        &quot;_score&quot;: 1,
        &quot;_source&quot;: {
          &quot;name&quot;: &quot;zhangsan&quot;,
          &quot;age&quot;: 18,
          &quot;gender&quot;: &quot;nan&quot;
        }
      }
    ]
  }
}
[root@node01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　搜索指定的单个索引的指定类型&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202010/1503305-20201001222641722-517258550.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：以上就是在es集群的命令行接口常用操作，通常我们用es集群，不会在命令行中做搜索，我们会利用web界面来做；命令行只是用于测试；好了到此es集群就搭建好了；后续我们就可以用logstash收集指定地方的数据，传给es，然后再利用kibana的web界面来展示es中的数据；&lt;/p&gt;
</description>
<pubDate>Thu, 01 Oct 2020 14:51:00 +0000</pubDate>
<dc:creator>Linux-1874</dc:creator>
<og:description>一、简介 什么是ELK？ELK是Elasticsearch、Logstash、Kibana这三个软件的首字母缩写；其中elasticsearch是用来做数据的存储和搜索的搜索引擎；logstash是数</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qiuhom-1874/p/13758006.html</dc:identifier>
</item>
<item>
<title>ES 入门 - 基于词项的查询  - 以终为始</title>
<link>http://www.cnblogs.com/michael9/p/13759208.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/michael9/p/13759208.html</guid>
<description>&lt;h2 id=&quot;准备&quot;&gt;准备&lt;/h2&gt;
&lt;p&gt;首先先声明下，我这里使用的 ES 版本 5.2.0.&lt;/p&gt;
&lt;p&gt;为了便于理解，这里以如下 index 为格式，该格式是通过 PMACCT 抓取的 netflow 流量信息, 文中所涉及的到的例子，全基于此 index.&lt;/p&gt;
&lt;p&gt;本篇涉及的内容可以理解为 ES 的入门内容，主要针对词项的过滤，为基础篇。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
                &quot;_index&quot;: &quot;shflows_agg_1600358400&quot;,
                &quot;_type&quot;: &quot;shflows_agg&quot;,
                &quot;_id&quot;: &quot;node1_1600359600_0_172698718_shflows_agg_0&quot;,
                &quot;_score&quot;: 1.0,
                &quot;_source&quot;: {
                    &quot;collector&quot;: &quot;node1&quot;,
                    &quot;src_port&quot;: &quot;443&quot;,
                    &quot;timestamp&quot;: 1600359600,
                    &quot;device_ip&quot;: &quot;1.1.1.1&quot;,
                    &quot;flows&quot;: &quot;40&quot;,
                    &quot;dst_host&quot;: &quot;2.2.2.2&quot;,
                    &quot;TAG&quot;: 10001,
                    &quot;router_ip&quot;: 172698718,
                    &quot;dst_port&quot;: &quot;16384&quot;,
                    &quot;pkts&quot;: 40000,
                    &quot;bits&quot;: 320000000000,
                    &quot;src_host&quot;: &quot;3.3.3.3&quot;
                }
            },
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在正式介绍搜索前，先明确一个概念。很多人在学习 ES 查询前，容易对 Term 和全文查询进行混淆。&lt;/p&gt;
&lt;p&gt;首先，Term 是表达语义的最小单位，在搜索和利用统计语言模型时都需要处理 Term.&lt;/p&gt;
&lt;p&gt;对应在 ES 里，针对 Term 查询的输入来说，不会做任何的分词处理，会把输入作为一个整体，在 ES 的倒排索引中进行词项的匹配，然后利用算分公式将结果返回。并可以通过 Constant Score 将查询转换为一个 Filtering，避免算分，利用缓存，从而提高性能。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;虽然输入时，不做分词处理，但在搜索时，会做分词处理。这样有时就会出现无法搜索出结果的情况，比如有 name 为 ‘Jack’ 的 doc. 但如果在搜索时，输入 Jack，ES 是无法查询到的。必须改成小写的 jack 或者使用 keyword 进行查询。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Term 查询包含：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Term Query&lt;/li&gt;
&lt;li&gt;Range Query&lt;/li&gt;
&lt;li&gt;Exists Query&lt;/li&gt;
&lt;li&gt;Prefix Query&lt;/li&gt;
&lt;li&gt;Wildcard Query&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;而全文查询，是基于全文本的查询。&lt;/p&gt;
&lt;p&gt;在 ES 中，索引（输入）和搜索时都会分词。先将查询的字符串传递到合适分词器中，然后生成一个供查询的词项列表。&lt;/p&gt;
&lt;p&gt;全文查询包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Match Query&lt;/li&gt;
&lt;li&gt;Match Phrase Query&lt;/li&gt;
&lt;li&gt;Query String Query&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;而下面的例子全都是基于 Term 查询。&lt;/p&gt;
&lt;h2 id=&quot;es-搜索概述&quot;&gt;ES 搜索概述&lt;/h2&gt;
&lt;p&gt;ES 搜索 API 可以分为两大类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;基于 URL 的参数搜索, 适合简单的搜索。&lt;/li&gt;
&lt;li&gt;基于 Request Body 的搜索（DSL），适合更为复杂的搜索。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;确定查询的索引范围：&quot;&gt;确定查询的索引范围：&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;/_search&lt;/code&gt;: 集群上的所有索引&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/index1/_search&lt;/code&gt;: index1 索引&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/index1,index2/_search&lt;/code&gt;: index1 和 index2 索引&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/index*/_search&lt;/code&gt;: 以 index 开头的所有索引&lt;/p&gt;
&lt;h2 id=&quot;url-查询&quot;&gt;URL 查询&lt;/h2&gt;
&lt;h3 id=&quot;指定字段查询：&quot;&gt;指定字段查询：&lt;/h3&gt;
&lt;p&gt;使用 q 指定参数，通过KV 间键值对查询。&lt;/p&gt;
&lt;p&gt;举例1：查询设备 IP 为 &lt;code&gt;1.1.1.1&lt;/code&gt; 的相关文档信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/shflows_agg_*/_search?q=device_ip:1.1.1.1 

{
    &quot;profile&quot;: &quot;true&quot;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;profile 的意思是查看查询过程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;结果：可以看到 type 为 TermQuery，搜索时根据指定字段：&quot;device_ip:10.75.44.94&quot;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;profile&quot;: {
        &quot;shards&quot;: [
            {
                &quot;id&quot;: &quot;[e_Ac3cNJRtmVxFW9DwOwjA][shflows_agg_1600531200][0]&quot;,
                &quot;searches&quot;: [
                    {
                        &quot;query&quot;: [
                            {
                                &quot;type&quot;: &quot;TermQuery&quot;,
                                &quot;description&quot;: &quot;device_ip:1.1.1.1&quot;,
                                &quot;time&quot;: &quot;445.8407320ms&quot;,
............
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;泛查询&quot;&gt;泛查询&lt;/h3&gt;
&lt;p&gt;不明确指定查询的 key，只指定 value，会对文档中所有 key 进行匹配&lt;/p&gt;
&lt;p&gt;举例2：查询各个属性中带有 1.1.1.1 字符的文档, 比如如果 src_host 或者 dst_host 中出现 1.1.1.1，相关文档也会被查询出来。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/shflows_agg_*/_search?q=10.75.44.94

{
    &quot;profile&quot;: &quot;true&quot;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果：可以看到 description 变为 _all&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;profile&quot;: {
        &quot;shards&quot;: [
            {
                &quot;id&quot;: &quot;[e_Ac3cNJRtmVxFW9DwOwjA][shflows_agg_1600531200][0]&quot;,
                &quot;searches&quot;: [
                    {
                        &quot;query&quot;: [
                            {
                                &quot;type&quot;: &quot;TermQuery&quot;,
                                &quot;description&quot;: &quot;_all:1.1.1.1&quot;,
 ......
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;dsl-查询&quot;&gt;DSL 查询&lt;/h2&gt;
&lt;p&gt;方法：通过在 body 中，编写 json 进行更为复杂的查询&lt;/p&gt;
&lt;h3 id=&quot;查询所有文档&quot;&gt;查询所有文档&lt;/h3&gt;
&lt;p&gt;举例1：查询当前 index 所有文档：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/shflows_agg_index1/_search

{
    &quot;query&quot;: {
        &quot;match_all&quot;: {} # 返回所有 doc
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;对文档进行排序和分页&quot;&gt;对文档进行排序和分页&lt;/h3&gt;
&lt;p&gt;举例2：查询当前 index 所有文档，按照时间排序&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/shflows_agg_index1/_search

{
    &quot;from&quot;: 10,
    &quot;size&quot;: 20,
    &quot;sort&quot;: [{&quot;timestamp&quot;: &quot;desc&quot;}],
    &quot;query&quot;: {
        &quot;match_all&quot;: {} # 返回所有 doc
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;指定文档返回的参数&quot;&gt;指定文档返回的参数&lt;/h3&gt;
&lt;p&gt;举例：指定文档中，返回的仅是指定的参数&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/shflows_agg_index1/_search

{
    &quot;_source&quot;: [&quot;timestamp&quot;, &quot;device_ip&quot;],
    &quot;query&quot;: {
        &quot;match_all&quot;: {} # 返回所有 doc
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;使用脚本字段，对文档中的多个值进行脚本运算&quot;&gt;使用脚本字段，对文档中的多个值进行脚本运算&lt;/h3&gt;
&lt;p&gt;举例：将文档中的，源 ip 和源端口进行拼接，并以 ip_address 进行命名：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/shflows_agg_index1/_search

{
    &quot;script_fields&quot;: {
        &quot;ip_address&quot;:{
            &quot;script&quot;: {
                &quot;lang&quot;: &quot;painless&quot;,
                &quot;inline&quot;: &quot;params.comment + doc['device_ip'].value + ':' + doc['dst_port'].value&quot;,
                &quot;params&quot; : {
                    &quot;comment&quot; : &quot;ip address is: &quot; 
                }
            }
        }
    },
    &quot;query&quot;: {
        &quot;match_all&quot;: {} 
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果：在 fields 里多出了新的脚本拼接后的字段&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    &quot;took&quot;: 84,
    &quot;timed_out&quot;: false,
    &quot;_shards&quot;: {
        &quot;total&quot;: 10,
        &quot;successful&quot;: 10,
        &quot;failed&quot;: 0
    },
    &quot;hits&quot;: {
        &quot;total&quot;: 36248845,
        &quot;max_score&quot;: 1.0,
        &quot;hits&quot;: [
            {
                &quot;_index&quot;: &quot;shflows_agg_1600358400&quot;,
                &quot;_type&quot;: &quot;shflows_agg&quot;,
                &quot;_id&quot;: &quot;node1_1600359600_0_172698718_shflows_agg_0&quot;,
                &quot;_score&quot;: 1.0,
                &quot;fields&quot;: {
                    &quot;ip_address&quot;: [
                        &quot;ip address is: 10.75.44.94:16384&quot;
                    ]
                }
            },
            {
                &quot;_index&quot;: &quot;shflows_agg_1600358400&quot;,
                &quot;_type&quot;: &quot;shflows_agg&quot;,
                &quot;_id&quot;: &quot;node1_1600359600_0_172698718_shflows_agg_5&quot;,
                &quot;_score&quot;: 1.0,
                &quot;fields&quot;: {
                    &quot;ip_address&quot;: [
                        &quot;ip address is: 10.75.44.94:443&quot;
                    ]
                }
            },
.......
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;query-context--or-filter-context-查询&quot;&gt;Query Context OR Filter Context 查询&lt;/h3&gt;
&lt;p&gt;在 ES 中，搜索过程有 Query 和 Filter 上下文两种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Query 查询：在搜索过程中会进行相关性的算分操作&lt;/li&gt;
&lt;li&gt;Filter 查询：不需要进行算分，所以可以利用缓存，获得更好的性能&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在 Query 和 Filter 查询里可以进行：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;等值查询（term）&lt;/li&gt;
&lt;li&gt;范围查询（range）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;举例：如查询 dst_port 为 443 的 doc，并打分&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/shflows_agg_index1/_search

{
    &quot;profile&quot;: &quot;true&quot;,
    &quot;explain&quot;: true,
    &quot;query&quot;: {
        &quot;term&quot;: {&quot;dst_port&quot;: 443}
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    &quot;took&quot;: 191,
    &quot;timed_out&quot;: false,
    &quot;_shards&quot;: {
        &quot;total&quot;: 11,
        &quot;successful&quot;: 11,
        &quot;failed&quot;: 0
    },
    &quot;hits&quot;: {
        &quot;total&quot;: 3871488,
        &quot;max_score&quot;: 2.2973032,
        &quot;hits&quot;: [
            {
                &quot;_shard&quot;: &quot;[shflows_agg_1600358400][0]&quot;,
                &quot;_node&quot;: &quot;RWTixYPtTieZaRgAH0NOkQ&quot;,
                &quot;_index&quot;: &quot;shflows_agg_1600358400&quot;,
                &quot;_type&quot;: &quot;shflows_agg&quot;,
                &quot;_id&quot;: &quot;node1_1600359600_0_172698718_shflows_agg_5&quot;,
                &quot;_score&quot;: 2.2973032,  ####### 可以看到这里有计算的分数
                &quot;_source&quot;: {
                    &quot;collector&quot;: &quot;node1&quot;,
                    &quot;src_port&quot;: &quot;16384&quot;,
                    &quot;timestamp&quot;: 1600359600,
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用 filter 查询：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/shflows_agg_index1/_search

{
  &quot;profile&quot;: &quot;true&quot;,
  &quot;explain&quot;: true,
  &quot;query&quot;: {
   # 使用 constant_score 不进行算分操作
    &quot;constant_score&quot;: {
      &quot;filter&quot;: {
        &quot;term&quot;: {
          &quot;dst_port&quot;: 443
        }
      }
    }
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;hits&quot;: {
        &quot;total&quot;: 3872768,
        &quot;max_score&quot;: 1.0, # 1.0 为固定值
.....

&quot;profile&quot;: {
        &quot;shards&quot;: [
            {
                &quot;id&quot;: &quot;[e_Ac3cNJRtmVxFW9DwOwjA][shflows_agg_1600531200][0]&quot;,
                &quot;searches&quot;: [
                    {
                        &quot;query&quot;: [
                            {
                                &quot;type&quot;: &quot;ConstantScoreQuery&quot;, ## 不变分数查询
                                &quot;description&quot;: &quot;ConstantScore(dst_port:443)&quot;,
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;举例：terms 查询，查询 dst_port 为 443 和 22 doc&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/shflows_agg_index1/_search

{
  &quot;profile&quot;: &quot;true&quot;,
  &quot;explain&quot;: true,
  &quot;query&quot;: {
   # 使用 constant_score 不进行算分操作
    &quot;constant_score&quot;: {
      &quot;filter&quot;: {
        &quot;terms&quot;: {
          &quot;dst_port&quot;: [443,22]
        }
      }
    }
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;举例：数据范围查询&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    &quot;profile&quot;: &quot;true&quot;,
    &quot;explain&quot;: true,
    &quot;query&quot;: {
        &quot;constant_score&quot;: {
            &quot;filter&quot;: {
                &quot;range&quot;: {
                    &quot;timestamp&quot;: {
                        # 大于等于
                        &quot;gte&quot;: 1601049600,
                        # 小于等于
                        &quot;lte&quot;: 1601308800
                    }
                }
            }
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;bool-复合查询：多个条件进行筛选&quot;&gt;Bool 复合查询：多个条件进行筛选&lt;/h3&gt;
&lt;p&gt;在 ES 可以通过 bool 查询，将一个或者多个查询子句组合或者嵌套到一起，实现更为复杂的查询。&lt;/p&gt;
&lt;p&gt;bool 查询共包含 4 个子句：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;must：搜索的结果必须匹配，参与算分&lt;/li&gt;
&lt;li&gt;should：选择性匹配，类似于 OR，满足一个条件就可以，参与算分&lt;/li&gt;
&lt;li&gt;must_not: 必须不能匹配，属于 Filter context，不贡献算分&lt;/li&gt;
&lt;li&gt;filter：必须匹配，属于 Filter context ，不贡献算分。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;must_not 和 filter 性能更好，不需要算分。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;举例：查询时间范围在 1601171628 和 1601175228 之间，目的端口为 80，源目的 IP 在 [1.1.1.1 ,1.1.1.2, 1.1.1.3] 中任意一个的 doc 信息。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    &quot;profile&quot;: &quot;true&quot;,
    &quot;explain&quot;: true,
    &quot;query&quot;: {
        &quot;bool&quot;: {
            &quot;must&quot;: [
                {
                    &quot;range&quot;: {
                        &quot;timestamp&quot;: {
                            &quot;gte&quot;: 1601171628,
                            &quot;lte&quot;: 1601175228
                        }
                    }
                },
                {
                    &quot;term&quot;: {
                        &quot;dst_port&quot;: 80
                    }
                }，
                {
                    &quot;bool&quot;: {
                     # 注意这里 should 在 must 的数组里，如果和 must 同级，是无法影响 must 的结果的。
                    &quot;should&quot;: [
                            {
                                &quot;term&quot;: {
                                    &quot;src_host&quot;: &quot;1.1.1.1&quot;
                                }
                            },
                            {
                                &quot;term&quot;: {
                                    &quot;src_host&quot;: &quot;1.1.1.1&quot;
                                }
                            },
                            {
                                &quot;term&quot;: {
                                    &quot;src_host&quot;: &quot;1.1.1.1&quot;
                                }
                            }
                        ]
                    }
                }
            ]
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-bool-query.html&quot;&gt;ES-Bool&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 01 Oct 2020 13:43:00 +0000</pubDate>
<dc:creator>以终为始</dc:creator>
<og:description>准备 首先先声明下，我这里使用的 ES 版本 5.2.0. 为了便于理解，这里以如下 index 为格式，该格式是通过 PMACCT 抓取的 netflow 流量信息, 文中所涉及的到的例子，全基于此</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/michael9/p/13759208.html</dc:identifier>
</item>
<item>
<title>C#设计模式-适配器模式（Adapter Pattern） - Tynam.Yang</title>
<link>http://www.cnblogs.com/tynam/p/13759190.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tynam/p/13759190.html</guid>
<description>&lt;h3&gt;概念&lt;/h3&gt;
&lt;p&gt;把一个类的接口变换成客户端所期待的另一种接口，从而使原本接口不匹配而无法一起工作的两个类能够在一起工作。适配器模式有类的适配器模式和对象的适配器模式两种形式。前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。&lt;/p&gt;
&lt;h3&gt;优缺点&lt;/h3&gt;
&lt;p&gt;　　优点：&lt;/p&gt;
&lt;p&gt;　　　　1、将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，无需修改原有结构。&lt;/p&gt;
&lt;p&gt;　　　　2、增加了类的透明性和复用性，将具体的业务实现过程封装在适配者类中，对于客户端类而言是透明的，而且提高了适配者的复用性，同一适配者类可以在多个不同的系统中复用。&lt;/p&gt;
&lt;p&gt;　　　　3、灵活性和扩展性都非常好，通过使用配置文件，可以很方便的更换适配器，也可以在不修改原有代码的基础上 增加新的适配器，完全复合开闭原则。&lt;/p&gt;
&lt;p&gt;　　缺点：&lt;/p&gt;
&lt;p&gt;　　　　1、一次最多只能适配一个适配者类，不能同时适配多个适配者。&lt;/p&gt;
&lt;p&gt;　　　　2、适配者类不能为最终类，在C#中不能为sealed类&lt;/p&gt;
&lt;p&gt;　　　　3、目标抽象类只能为接口，不能为类，其使用有一定的局限性。&lt;/p&gt;
&lt;h3&gt;模式的结构&lt;/h3&gt;
&lt;p&gt;适配器模式（Adapter）包含以下主要角色。&lt;br/&gt;目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。&lt;br/&gt;适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。&lt;br/&gt;适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。&lt;/p&gt;
&lt;h3&gt;实现模式&lt;/h3&gt;
&lt;p&gt;　　假如用的是苹果手机，但是没有苹果充电线，有华为充电线，那么要使用华为充电线给苹果手机充电，此时就需要一个接口进行转换，适配器模式就是用来完成这种转换的。接下来进行具体实现：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;类的适配器模式&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
namespace&lt;span&gt; 适配器
{
    /// 华为充电线 typec   苹果充电线 Lightning

    class&lt;span&gt; Client
    {
        /// &amp;lt;summary&amp;gt;
        /// 使用华为充电线给苹果手机充电
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;args&quot;&amp;gt;&amp;lt;/param&amp;gt;
        static void Main(string&lt;span&gt;[] args)
        {
            ILightning apple = new&lt;span&gt; Apple();
            apple.Recharge();

            Console.ReadLine();

        }
    }

    /// &amp;lt;summary&amp;gt;
    /// 苹果充电线接口
    /// &amp;lt;/summary&amp;gt;
    public interface&lt;span&gt; ILightning
    {
        void&lt;span&gt; Recharge();
    
    }

    /// &amp;lt;summary&amp;gt;
    /// 华为充电线
    /// &amp;lt;/summary&amp;gt;
    public class&lt;span&gt; TypeC
    {
        public virtual void&lt;span&gt; HuaweiRecharge()
        {
            Console.WriteLine(&quot;华为手机充电&quot;&lt;span&gt;);
        }
    }

    /// &amp;lt;summary&amp;gt;
    /// 实现苹果手机充电
    /// &amp;lt;/summary&amp;gt;
    public class&lt;span&gt; Apple : TypeC, ILightning
    {
    
        public void&lt;span&gt; Recharge()
        {
            this&lt;span&gt;.HuaweiRecharge();
        }
    }
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 以上代码实现图： &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1359074/202009/1359074-20200929172233213-853915523.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 对象的适配器模式&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
namespace&lt;span&gt; 适配器
{
    class&lt;span&gt; Client
    {
        static void Main(string&lt;span&gt;[] args)
        {
            Lightning apple = new&lt;span&gt; Lightning();
            apple.Recharge();
            Console.ReadKey();
        }
    }


    public class&lt;span&gt; TypeC
    {
        public void&lt;span&gt; HuaweiRecharge()
        {
            Console.WriteLine(&quot;华为手机充电&quot;&lt;span&gt;);
        }

    }

    public class&lt;span&gt; Lightning : TypeC
    {
        public TypeC tc = new&lt;span&gt; TypeC();
        public void&lt;span&gt; Recharge()
        {
            tc.HuaweiRecharge();
        }
    }
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上代码实现图： &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1359074/202009/1359074-20200929172242312-779627542.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;应用场景&lt;/h3&gt;
&lt;p&gt;适配器模式（Adapter）通常适用于以下场景。&lt;br/&gt;1、系统需要复用现有类，而该类的接口不符合系统的需求；&lt;br/&gt;2、想要建立一个可重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作；&lt;br/&gt;3、对于对象适配器模式，在设计里需要改变多个已有子类的接口，如果使用类的适配器模式，就要针对每一个子类做一个适配器，而这不太实际。&lt;/p&gt;
&lt;h3&gt;模式的扩展&lt;/h3&gt;
&lt;p&gt;适配器模式（Adapter）可扩展为双向适配器模式，双向适配器类既可以把适配者接口转换成目标接口，也可以把目标接口转换成适配者接口，其结构图如下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1359074/202009/1359074-20200929172343723-2059492514.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 01 Oct 2020 13:36:00 +0000</pubDate>
<dc:creator>Tynam.Yang</dc:creator>
<og:description>概念 把一个类的接口变换成客户端所期待的另一种接口，从而使原本接口不匹配而无法一起工作的两个类能够在一起工作。适配器模式有类的适配器模式和对象的适配器模式两种形式。前者类之间的耦合度比后者高，且要求程</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tynam/p/13759190.html</dc:identifier>
</item>
<item>
<title>玩命学JVM（二）—类加载机制 - CleverZiv</title>
<link>http://www.cnblogs.com/cleverziv/p/13759175.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cleverziv/p/13759175.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;Java程序运行图：&lt;br/&gt;&lt;img src=&quot;https://myblog-1258060977.cos.ap-beijing.myqcloud.com/cnblog/JVM/JVM%E6%B5%81%E7%A8%8B.png&quot; alt=&quot;Alt&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上一篇&lt;a href=&quot;https://www.cnblogs.com/cleverziv/p/13751488.html&quot;&gt;玩命学JVM（一）—认识JVM和字节码文件&lt;/a&gt;我们简单认识了 JVM 和字节码文件。那JVM是如何使用字节码文件的呢？从上图清晰地可以看到，JVM 通过&lt;span&gt;类加载器&lt;/span&gt;完成了这一过程。&lt;/p&gt;
&lt;p&gt;以下是类加载机制的知识框架：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://myblog-1258060977.cos.ap-beijing.myqcloud.com/cnblog/JVM/JVM%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B62.png&quot; alt=&quot;Alt&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来我们对思维导图中重难点部分做补充。&lt;/p&gt;
&lt;h3 id=&quot;1-是什么？&quot;&gt;1. 是什么？&lt;/h3&gt;
&lt;p&gt;类的加载就是将 .class 文件的二进制数据读入到内存中，将其放在 JVM 的运行时数据区的方法区内。然后在堆区内创建一个 java.lang.Class 对象，用于封装类在方法区内的数据结构。&lt;/p&gt;
&lt;h3 id=&quot;5-双亲委派模型&quot;&gt;5. 双亲委派模型&lt;/h3&gt;
&lt;p&gt;双亲委派模型图如下：&lt;br/&gt;&lt;img src=&quot;https://myblog-1258060977.cos.ap-beijing.myqcloud.com/cnblog/JVM/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.png&quot; alt=&quot;Alt&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于“双亲委派模型”，首先需要纠正一点，“双亲”并不是说它有“两个亲”。实际上行“双亲委派模型”和“双”毫无关系，只和“亲”有关系。&lt;br/&gt;其实“双亲”是翻译的一个错误，原文出处是“parent”，被翻译成了“双亲”，在计算机领域更常见的说法是“父节点”。所以如果将“双亲委派模型”改为“父委派模型”，应该更好理解。&lt;/p&gt;
&lt;p&gt;结合实际的类加载器来说，就是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;每个类加载器都会向上找自己父类加载器尝试完成类加载；&lt;/li&gt;
&lt;li&gt;父加载器加载失败会向下找加载器尝试加载。&lt;br/&gt;如图：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://myblog-1258060977.cos.ap-beijing.myqcloud.com/cnblog/JVM/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE.png&quot; alt=&quot;Alt&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来我们从源码上来分析下 双亲委派模型&lt;br/&gt;除&lt;code&gt;Bootstrap ClassLoader&lt;/code&gt;外，其它的类加载器都是&lt;code&gt;ClassLoader&lt;/code&gt;的子类。加载类的方法为&lt;code&gt;loadClass&lt;/code&gt;，查看源码可发现，&lt;code&gt;loadClass&lt;/code&gt;在&lt;code&gt;ClassLoader&lt;/code&gt;中有具体的实现，且在各个子类中都没有被覆盖。&lt;/p&gt;
&lt;p&gt;先介绍三个重要的函数，对后续的源码阅读有帮助：&lt;br/&gt;&lt;code&gt;loadClass&lt;/code&gt;：调用父类加载器的loadClass，加载失败则调用自己的findClass方法。&lt;br/&gt;&lt;code&gt;findClass&lt;/code&gt;：根据名称读取文件存入字节数组。&lt;br/&gt;&lt;code&gt;defineClass&lt;/code&gt;：把一个字节数组转为Class对象。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;protected Class&amp;lt;?&amp;gt; loadClass(String name, boolean resolve)
        throws ClassNotFoundException
    {
        synchronized (getClassLoadingLock(name)) {
            // First, check if the class has already been loaded
            // 在JVM中查看类是否已经被加载
            Class&amp;lt;?&amp;gt; c = findLoadedClass(name);
            if (c == null) {
                long t0 = System.nanoTime();
                try {
                    if (parent != null) {
                            // 调用父类加载器的 loadClass方法，parent是该类加载器的父类，parent的值可能为 Application ClassLoader、Extension ClassLoader，当想要继续往上找 Extension ClassLoader时，由于Bootstrap ClassLoader是C/C++实现的，所以在java中是Null
                        c = parent.loadClass(name, false);
                    } else {
                            // 寻找 Bootstrap ClassLoader 加载
                        c = findBootstrapClassOrNull(name);
                    }
                } catch (ClassNotFoundException e) {
                    // ClassNotFoundException thrown if class not found
                    // from the non-null parent class loader
                }

                if (c == null) {
                    // If still not found, then invoke findClass in order
                    // to find the class.
                    long t1 = System.nanoTime();
                    // 父加载器开始尝试加载.class文件，加载成功就返回一个java.lang.Class，加载不成功就抛出一个ClassNotFoundException，给子加载器去加载
                    c = findClass(name);

                    // this is the defining class loader; record the stats
                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                    sun.misc.PerfCounter.getFindClasses().increment();
                }
            }
            if (resolve) {
            // 如果要解析这个.class文件的话，就解析一下，解析的作用主要就是将符号引用替换为直接引用的过程
                resolveClass(c);
            }
            return c;
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所谓的双亲委派模型，就是利用了&lt;code&gt;loadClass&lt;/code&gt;只在父类中实现了这一点。&lt;/p&gt;
&lt;h4 id=&quot;自定义类加载器&quot;&gt;自定义类加载器&lt;/h4&gt;
&lt;p&gt;自定义类加载主要有两种方式：&lt;/p&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;遵守双亲委派模型：继承ClassLoader，重写findClass()方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;破坏双亲委派模型：继承ClassLoader,重写loadClass()方法。 通常我们推荐采用第一种方法自定义类加载器，最大程度上的遵守双亲委派模型。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我们看一下实现步骤&lt;br/&gt;（1）创建一个类继承ClassLoader抽象类&lt;br/&gt;（2）重写findClass()方法&lt;br/&gt;（3）在findClass()方法中调用defineClass()&lt;/p&gt;
&lt;p&gt;第一步，自定义一个实体类Person.java，我把它编译后的Person.class放在D盘根目录下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.xrq.classloader;

public class Person
{
    private String name;

    public Person()
    {

    }

    public Person(String name)
    {
        this.name = name;
    }

    public String getName()
    {
        return name;
    }

    public void setName(String name)
    {
        this.name = name;
    }

    public String toString()
    {
        return &quot;I am a person, my name is &quot; + name;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二步，自定义一个类加载器，里面主要是一些IO和NIO的内容，另外注意一下 defineClass方法可以把二进制流字节组成的文件转换为一个java.lang.Class----只要二进制字节流的内容符合Class文件规 范。我们自定义的MyClassLoader继承自java.lang.ClassLoader，就像上面说的，只实现findClass方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class MyClassLoader extends ClassLoader
{
    public MyClassLoader()
    {
        
    }
    
    public MyClassLoader(ClassLoader parent)
    {
        super(parent);
    }
    
    protected Class&amp;lt;?&amp;gt; findClass(String name) throws ClassNotFoundException
    {
        File file = getClassFile(name);
        try
        {
            byte[] bytes = getClassBytes(file);
            Class&amp;lt;?&amp;gt; c = this.defineClass(name, bytes, 0, bytes.length);
            return c;
        } 
        catch (Exception e)
        {
            e.printStackTrace();
        }
        
        return super.findClass(name);
    }
    
    private File getClassFile(String name)
    {
        File file = new File(&quot;D:/Person.class&quot;);
        return file;
    }
    
    private byte[] getClassBytes(File file) throws Exception
    {
        // 这里要读入.class的字节，因此要使用字节流
        FileInputStream fis = new FileInputStream(file);
        FileChannel fc = fis.getChannel();
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        WritableByteChannel wbc = Channels.newChannel(baos);
        ByteBuffer by = ByteBuffer.allocate(1024);
        
        while (true)
        {
            int i = fc.read(by);
            if (i == 0 || i == -1)
                break;
            by.flip();
            wbc.write(by);
            by.clear();
        }
        
        fis.close();
        
        return baos.toByteArray();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第三步，Class.forName有一个三个参数的重载方法，可以指定类加载器，平时我们使用的Class.forName(&quot;XX.XX.XXX&quot;)都是使用的系统类加载器Application ClassLoader。写一个测试类：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class TestMyClassLoader
{
    public static void main(String[] args) throws Exception
    {
        MyClassLoader mcl = new MyClassLoader();
        Class&amp;lt;?&amp;gt; c1 = Class.forName(&quot;com.xrq.classloader.Person&quot;, true, mcl);
        Object obj = c1.newInstance();
        System.out.println(obj);
        System.out.println(obj.getClass().getClassLoader());
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;I am a person, my name is null&lt;br/&gt;com.xrq.classloader.MyClassLoader@5d888759&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;参考文献&quot;&gt;参考文献&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://baijiahao.baidu.com/s?id=1636309817155065432&amp;amp;wfr=spider&amp;amp;for=pc&quot;&gt;https://baijiahao.baidu.com/s?id=1636309817155065432&amp;amp;wfr=spider&amp;amp;for=pc&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/qq_44836294/article/details/105439753&quot;&gt;https://blog.csdn.net/qq_44836294/article/details/105439753&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 01 Oct 2020 13:33:00 +0000</pubDate>
<dc:creator>CleverZiv</dc:creator>
<og:description>前言 Java程序运行图： 上一篇玩命学JVM（一）—认识JVM和字节码文件我们简单认识了 JVM 和字节码文件。那JVM是如何使用字节码文件的呢？从上图清晰地可以看到，JVM 通过类加载器完成了这一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cleverziv/p/13759175.html</dc:identifier>
</item>
<item>
<title>最简单的微服务部署测试实践 - 天下技术</title>
<link>http://www.cnblogs.com/mysqlcskdpl/p/13758962.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mysqlcskdpl/p/13758962.html</guid>
<description>&lt;p&gt;微服务特别适合业务复杂，开发队伍庞大的项目。微服务可以到达化整为零，简化单个服务，降低沟通成本的效果。但微服务在性能上比单体服务低，也会有数据冗余的问题，要结合自身情况，不要盲目崇拜。&lt;br/&gt;本文介绍一种简单的微服务技术架构。帮助大家对微服务如何部署，如何开发有个初步的认识。&lt;/p&gt;
&lt;h2 id=&quot;一个简单的微服务架构&quot;&gt;一个简单的微服务架构&lt;/h2&gt;
&lt;p&gt;部署图如下&lt;br/&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xllntl/picture/2020-10-1/1601532381755-0.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;nginx：&quot;&gt;nginx：&lt;/h3&gt;
&lt;p&gt;对外统一入口，根据url将请求分发到不同微服务，用ip:port区分不同的微服务。也会直接处理一些静态资源的访问，本身就是web服务器。&lt;/p&gt;
&lt;h3 id=&quot;springbootdubbo：&quot;&gt;springboot+dubbo：&lt;/h3&gt;
&lt;p&gt;spring boot是目前最流行的开发web服务的框架（jsp，ejb，ssh这些框架过于老旧），它和微服务没有必然联系，但它结合dubbo可以开发微服务，要求就是spring boot工程要import dubbo.jar或者使用maven引入dubbo。配置dubbo-application.xml，里面写好zookeeper服务地址端口以及提供者和消费者要注册的接口方法。&lt;br/&gt;一个微服务要调用另一个微服务的方法，只需要@Autowired注册接口类的对象，用对象调用方法即可。麻烦点的是各个微服务对同一个接口方法要有一致的接口描述java文件，使用maven管理描述接口的jar包可以有效解决接口一致的问题。&lt;br/&gt;最后打jar包，java -jar ***.jar一个微服务就启动了。&lt;/p&gt;
&lt;h3 id=&quot;zookeeper：&quot;&gt;zookeeper：&lt;/h3&gt;
&lt;p&gt;springboot需要dubbo，而dubbo最推荐的服务注册中心是zookeeper，相当于一个公告板，各个微服务都可以看到上面注册的提供者和消费者的接口方法&lt;/p&gt;
&lt;h3 id=&quot;db：&quot;&gt;DB：&lt;/h3&gt;
&lt;p&gt;MySQL Oracle等&lt;/p&gt;
&lt;h3 id=&quot;redis：&quot;&gt;redis：&lt;/h3&gt;
&lt;p&gt;缓存session数据，和其它有必要缓存的业务数据&lt;/p&gt;
&lt;h3 id=&quot;tomcatdubbo-admin：&quot;&gt;tomcat+dubbo-admin：&lt;/h3&gt;
&lt;p&gt;dubbo管理系统，用于监控和排查故障，部署在tomcat下，可以在浏览器上查看各个微服务的运行情况，查看某个方法是否可以被正常调用。&lt;/p&gt;
&lt;h2 id=&quot;积分查询业务场景，帮助理解微服务。&quot;&gt;积分查询业务场景，帮助理解微服务。&lt;/h2&gt;
&lt;p&gt;B服务提供检查登陆状态功能。A服务提供查询账号积分功能。&lt;br/&gt;当用户在app点击查询积分时，nginx看见url里有查询积分关键字，会根据nginx.conf的配置将请求发送到A服务，app会有个sessionid发送给A服务，A服务远程调用B服务的检查登陆状态的接口，将sessionid传给接口，B服务接口被调用，使用sessionid到redis查用户信息，如果查询到redis有对应的用户信息，将用户信息返回，A服务接收到远程调用接口返回的用户信息userid，接下来根据用户信息到数据库DB查询积分情况。&lt;br/&gt;这就是两个微服务配合实现一个业务的例子，用到了架构图中的全部单元。查询登陆状态的要求在各个业务都存在，所以会有很多微服务需要远程调用B服务的接口。同时每个微服务可以即是提供者，又是消费者。&lt;br/&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xllntl/picture/2020-10-1/1601545765944-%E5%BE%AE%E6%9C%8D%E5%8A%A1AB%E6%97%B6%E5%BA%8F%E5%9B%BE.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;在windows下配置一套完整的微服务开发环境。&quot;&gt;在windows下配置一套完整的微服务开发环境。&lt;/h2&gt;
&lt;h3 id=&quot;nginx&quot;&gt;nginx&lt;/h3&gt;
&lt;p&gt;D:\Program Files\nginx-1.8.1&amp;gt;start nginx.exe&lt;br/&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xllntl/picture/2020-10-1/1601532457339-1.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;成功后浏览器如下&lt;br/&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xllntl/picture/2020-10-1/1601532499272-1.1.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;mysql&quot;&gt;MySQL&lt;/h3&gt;
&lt;p&gt;D:\Program Files\mysql-8.0.12-winx64\bin&amp;gt;mysqld --console&lt;br/&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xllntl/picture/2020-10-1/1601532543058-2.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;redis&quot;&gt;redis&lt;/h3&gt;
&lt;p&gt;D:\Program Files\Redis-x64-3.0.504&amp;gt;redis-server.exe redis.windows.conf&lt;br/&gt;图我忘截了&lt;/p&gt;
&lt;h3 id=&quot;zookeeper&quot;&gt;zookeeper&lt;/h3&gt;
&lt;p&gt;双击zkServer.cmd&lt;br/&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xllntl/picture/2020-10-1/1601532613158-3.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xllntl/picture/2020-10-1/1601532674474-4.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;tomcat和dubbo-admindubbo-admin&quot;&gt;tomcat和dubbo-admindubbo-admin&lt;/h3&gt;
&lt;p&gt;需要github上下载，然后单独对dubbo-admin进行编译打war包，war包放到tomcat的webapps目录下，tomcat启动时会自动解压出文件夹，如下图&lt;br/&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xllntl/picture/2020-10-1/1601532714139-4.9.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;tomcat/bin目录执行startup.bat  成功后浏览器如下&lt;br/&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xllntl/picture/2020-10-1/1601532764990-5.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;打开 &lt;a href=&quot;http://127.0.0.1:8080/dubbo-admin-2.5.8/&quot;&gt;http://127.0.0.1:8080/dubbo-admin-2.5.8/&lt;/a&gt;  （我最初打开页面卡死，后来删除tomcat/log里的全部日志后正常了）&lt;br/&gt;用户名root 密码root&lt;br/&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xllntl/picture/2020-10-1/1601532920692-6.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xllntl/picture/2020-10-1/1601532948776-6.5.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;没有启动任何微服务所以上图各项都是空的。在Intellij IDEA运行两个微服务（cmd里java -jar 启动微服务jar包也可以，但调试修改代码不太方便）&lt;br/&gt;可以看到dubbo管理系统可以看见两个服务，一个是提供者，一个是消费者。里面可以查看名称，状态，日志，对排错挺有帮助的。&lt;br/&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xllntl/picture/2020-10-1/1601533068099-10.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xllntl/picture/2020-10-1/1601533098205-11.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xllntl/picture/2020-10-1/1601533117494-12.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;测试dubug&quot;&gt;测试dubug&lt;/h3&gt;
&lt;p&gt;浏览器输入登陆的url可以看到打开登录页面。&lt;br/&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xllntl/picture/2020-10-1/1601533143824-14.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到此一个微服务系统的开发调试环境就完成了。如果只测试后端服务不关心浏览器和app界面的功能，可以使用postman工具，直接发送url给服务端，查看返回的json数据等是否达到预期要求。&lt;/p&gt;
</description>
<pubDate>Thu, 01 Oct 2020 12:15:00 +0000</pubDate>
<dc:creator>天下技术</dc:creator>
<og:description>简单的微服务部署测试说明</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mysqlcskdpl/p/13758962.html</dc:identifier>
</item>
<item>
<title>再解决不了前端加密我就吃shi - 1ndex-</title>
<link>http://www.cnblogs.com/wjrblogs/p/12850094.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wjrblogs/p/12850094.html</guid>
<description>&lt;h2 id=&quot;参考文章&quot;&gt;参考文章&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://gv7.me/articles/2018/fast-locate-the-front-end-encryption-method/&quot;&gt;快速定位前端加密方法&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_39190897/article/details/103358609&quot;&gt;渗透测试-前端加密测试&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;最近学习挖洞以来，碰到数据做了加密基本上也就放弃了。但是发现越来越多的网站都开始做前端加密了，不论是金融行业还是其他。所以趁此机会来捣鼓一下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1893076/202010/1893076-20201001161159500-2072143326.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图可以看到，网站在前端对我的账号密码做了加密处理。前端加密的好处在于防止数据被劫持后直接泄露用户信息，增加攻击者成本。虽然有https，但是也有被破解的风险。再者国内很多网站都没有设置https，所以前端加密会进一步提高用户数据的安全性&lt;/p&gt;
&lt;p&gt;但对于我这样一个菜鸡，就算是洞放在我面前我也不一定能找到，更何况是加了密。太难了。&lt;/p&gt;
&lt;h2 id=&quot;工具&quot;&gt;工具&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;phantomJS&lt;/strong&gt;:&lt;code&gt;https://phantomjs.org/download.html&lt;/code&gt;，使用方法： phantomJS.exe decrypt.js&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;jsEncrypter&lt;/strong&gt; ：&lt;code&gt;https://github.com/c0ny1/jsEncrypter&lt;/code&gt;&lt;br/&gt;简便方法：&lt;br/&gt;1）下载打包好的 jar 文件：&lt;code&gt;链接：https://pan.baidu.com/s/1gDqmTVdYRD6nH5CfoqxavA 提取码：go8h&lt;/code&gt;&lt;br/&gt;2）添加到 BURP 扩展&lt;br/&gt;3）在 jsEncrypter 下载地址里下载模板文件，即&lt;code&gt;https://github.com/c0ny1/jsEncrypter/tree/master/script&lt;/code&gt; 里的 &lt;code&gt;phantomjs_server.js&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;一般流程：&lt;br/&gt;1）寻找加密函数&lt;br/&gt;2) 编写 phantomJS 运行脚本，只需要将实现加密算法的 js 文件引入模板脚本，并在模板脚本的 js_encrypt 函数体中完成对加密函数的调用。当然也可以不引入实现加密算法的 js 文件，直接在 js_encrypt 函数体中实现加密算法，并调用&lt;br/&gt;如下是 phantomjs_server.js 里的部分内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/* 1.在这引入实现加密所有 js 文件,注意引入顺序和网页一致 */
loadScript(&quot;script-1.js&quot;);
loadScript(&quot;script-2.js&quot;);
loadScript(&quot;script-n.js&quot;);
/**********************************************/

...

function jsEncrypt(burp_payload){
        var new_payload;
        /* 2.在这里编写调用加密函数进行加密的代码,并把结果赋值给new_payload */

        /*********************************************************/
        return new_payload;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3）在终端中输入 &lt;code&gt;phantomJS.exe phantomjs_server.js&lt;/code&gt; ，然后在 burp 里操作就行了&lt;/p&gt;
&lt;h2 id=&quot;步骤演示&quot;&gt;步骤演示&lt;/h2&gt;
&lt;h3 id=&quot;在-phantomjs_serverjs-文件中导入网页中实现加密算法的-js-文件差不多就是依赖文件，方便之后直接调用加密函数&quot;&gt;在 phantomjs_server.js 文件中导入网页中实现加密算法的 js 文件(差不多就是依赖文件)，方便之后直接调用加密函数&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;/* 1.在这引入实现加密所有 js 文件,注意引入顺序和网页一致 */
loadScript(&quot;script-1.js&quot;);
loadScript(&quot;script-2.js&quot;);
loadScript(&quot;script-n.js&quot;);
/**********************************************/
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;通常来说，如果一个网站的 js 文件没有做混淆，并能轻松找到加密函数，且加密算法比较简单的话，其实是不需要导入 js 文件的&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;可以直接将加密函数复制或者自己编写即可，但是往往加密算法的实现比较复杂，需要引入许多依赖，所以还是导入较好，后续编写加密算法再调用其中的依赖&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;此时可能有人就会问了，我要是知道实现加密算法的 js 文件是那个，我还看个 JB 文章呢！&lt;br/&gt;确实，说的不错。以下提供两个解决办法&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;导入所有 js 文件&lt;br/&gt;嗯，是个好办法。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1893076/202010/1893076-20201001165014970-713928195.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;不多哈，也就亿个。&lt;/li&gt;
&lt;li&gt;通过关键字寻找 js 文件&lt;br/&gt;通过 &lt;code&gt;ctrl+shift+f&lt;/code&gt; 全局搜索 &lt;code&gt;encrypt、aes、des、md5、key、iv、rsa&lt;/code&gt; 等关键字过滤一波再导入&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1893076/202010/1893076-20201001165743221-1399757337.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;不错不错，少了 3 个😭&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;在浏览器控制台里寻找实现对应数据加密的加密函数&quot;&gt;在浏览器控制台里寻找实现对应数据加密的加密函数&lt;/h3&gt;
&lt;p&gt;Tips:在这一步，可能会碰到找不到加密函数的问题，以下有几个解决办法&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;浏览器的事件监听&lt;br/&gt;firefox:&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1893076/202010/1893076-20201001171735458-2123349992.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;chrome:&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1893076/202010/1893076-20201001171911870-1308545126.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;搜索关键词 encrypt crypt aes rsa des key iv 等等跟加密相关的&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1893076/202005/1893076-20200511132333130-7386220.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;结合各种参数、提示字符定位加密函数&lt;br/&gt;参数：source、key&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1893076/202010/1893076-20201001161159500-2072143326.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;提示字符：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1893076/202010/1893076-20201001175547267-1926808248.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;根据 url 来定位&lt;br/&gt;网站登陆常常是向某一个 api 接口发送账号密码信息，因此点击提交时，用 js 发起请求就需要提供 api 地址&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1893076/202010/1893076-20201001180031991-1866775228.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;如下是全局搜索得到的结果：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1893076/202010/1893076-20201001180036675-1384661202.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;然后就找到了加密函数&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1893076/202010/1893076-20201001181237221-367518188.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;进一步跟进查看实现算法&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1893076/202010/1893076-20201001181148748-126723342.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;可以看到通过了 aes 和 rsa 加密，因此后续也需要找到 aes 的 key、iv 以及 rsa 的 public_key&lt;br/&gt;aes 的 key 生成函数：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1893076/202010/1893076-20201001185802831-390445249.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;iv：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1893076/202010/1893076-20201001192232152-1331072648.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;rsa 的 public_key：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1893076/202010/1893076-20201001190135004-131307962.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;在-phantomjs_serverjs-中的-jsencrypt-函数内调用找到的或自己编写的加密函数&quot;&gt;在 phantomjs_server.js 中的 jsEncrypt 函数内调用找到的或自己编写的加密函数&lt;/h3&gt;
&lt;p&gt;一般来说，该函数是需要自己重新编写的&lt;br/&gt;最终结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * author: c0ny1
 * date: 2017-12-16
 * last update: 2020-03-03
 */
var fs = require('fs');
var webserver = require('webserver');
server = webserver.create();

var logfile = 'jsEncrypter.log';
var host = '127.0.0.1';
var port = '1664';

/* 1.在这引入实现加密所有js文件,注意引入顺序和网页一致 */
loadScript(&quot;aes.js&quot;);
loadScript(&quot;zero.js&quot;);
loadScript(&quot;rsa.js&quot;);
// loadScript(&quot;script-n.js&quot;);
/**********************************************/

function loadScript(scriptName) {
    var isSuccess = phantom.injectJs(scriptName);
    if(isSuccess){
        console.log(&quot;[*] load &quot; + scriptName + &quot; successful&quot;)
    }else{
        console.log(&quot;[!] load &quot; + scriptName + &quot; fail&quot;)
        console.log(&quot;[*] phantomjs server exit&quot;);
        phantom.exit();
    }
}
// 定义 des 加密函数
function encryptByDES(message, key){
    var keyHex = CryptoJS.enc.Utf8.parse(key);
    var encrypted = CryptoJS.DES.encrypt(message, keyHex, {
        mode: CryptoJS.mode.ECB,
        padding: CryptoJS.pad.Pkcs7
    });
    return encrypted.ciphertext.toString();
}
//定义 aes 加密函数
function encryptByAES(data, key, iv){
    var key  = CryptoJS.enc.Latin1.parse(key);
    var iv   = CryptoJS.enc.Latin1.parse(iv);
    var encrypted = CryptoJS.AES.encrypt(data,key,{iv:iv,mode:CryptoJS.mode.CBC,padding:CryptoJS.pad.ZeroPadding});
    return encrypted.ciphertext.toString();
}
// 定义 rsa 加密函数
function encryptByRSA(data, pub_key){
    var encrypt = new JSEncrypt();
    encrypt.setPublicKey('-----BEGIN PUBLIC KEY-----' + pub_key + '-----END PUBLIC KEY-----');
    var encrypted = encrypt.encrypt(data);
    return encrypted;
}

// 定义 aeskey 生成函数
function createAesKey() {
    var expect = 16;
    var key = Math.random().toString(36).substr(2);

    while (key.length &amp;lt; expect) {
      key += Math.random().toString(36).substr(2);
    }

    key = key.substr(0, 16);
    this.aesKey = key;
    return key;
  };
var PUBLIC_KEY = &quot;-----BEGIN PUBLIC KEY-----\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDIivtXleN3uU5AnqidOAsD/96s\nADl1RU8g8eeRfBvovhpFvTxqdjP4/aicrSLE/tP4+nctocHclxK2tCqS6758g2bk\nDrlyxcfVdFV8l9wLxciNf2eBrraKoNf85RBh8bcOT96TTpYF0dSgmJVPwMR5u8am\n+trZ5y3jtTGQ/Ht4lQIDAQAB\n-----END PUBLIC KEY-----&quot;;

function jsEncrypt(burp_payload){
        /* 2.在这里编写调用加密函数进行加密的代码,并把结果赋值给new_payload */
        var aeskey = createAesKey();
        var key = CryptoJS.enc.Utf8.parse(aesKey)
        //console.log(this.aesKey);
        /*********************************************************/
        result = {
        source: encryptByAES(burp_payload,aeskey,key),
        key: encryptByRSA(aeskey,PUBLIC_KEY)
        };
        return [result.source,aeskey,key];
        // return burp_payload;
}

console.log(&quot;[*] Phantomjs server for jsEncrypter started successfully!&quot;);
console.log(&quot;[*] address: http://&quot;+host+&quot;:&quot;+port);
console.log(&quot;[!] ^_^&quot;);

var service = server.listen(host+':'+port,function(request, response){
        try{
                if(request.method == 'POST'){
                        var payload = request.post['payload'];
                        var encrypt_payload = jsEncrypt(payload);
                        var log = payload + ':' + encrypt_payload;
                        console.log('[+] ' + log);
            fs.write(logfile,log + '\n', 'w+');
                        response.statusCode = 200;
            response.setEncoding('UTF-8');
                        response.write(encrypt_payload.toString());
                        response.close();
                }else{
                          response.statusCode = 200;
                          response.setEncoding('UTF-8');
                          response.write(&quot;^_^\n\rhello jsEncrypter!&quot;);
                          response.close();
                }
        }catch(e){
                //console.log('[Error]'+e.message+' happen '+e.line+'line');
                console.log('\n-----------------Error Info--------------------');
                var fullMessage = &quot;Message: &quot;+e.toString() + ':'+ e.line;
                for (var p in e) {
                        fullMessage += &quot;\n&quot; + p.toUpperCase() + &quot;: &quot; + e[p];
                } 
                console.log(fullMessage);
                console.log('---------------------------------------------');
        response.statusCode = 200;
        response.setEncoding('UTF-8');
        response.write(fullMessage);
        response.close();
                console.log('[*] phantomJS exit!');
                phantom.exit();
    }   
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1893076/202010/1893076-20201001194137873-2111980599.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一般网站都是 aes des ras 等方式进行加密，其依赖文件都是开源的，所以可以直接引入，因此可以省略第一步，直接自己编写函数。&lt;/strong&gt;需要用到依赖文件如下：&lt;/p&gt;
&lt;p&gt;对加密函数的实现不懂的话，可以看我&lt;a href=&quot;https://www.cnblogs.com/wjrblogs/p/13730128.html&quot;&gt;前一篇文章&lt;/a&gt;&lt;br/&gt;因为加密方式都差不多，所以引入文件可以统一写成：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/* 1.在这引入实现加密所有 js 文件,注意引入顺序和网页一致 */
loadScript(&quot;des.js&quot;);
loadScript(&quot;aes.js&quot;);
loadScript(&quot;aes填充方式.js&quot;);
loadScript(&quot;rsa.js&quot;);
/**********************************************/
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后再定义各种加密函数的实现，再调用就行了&lt;/p&gt;
</description>
<pubDate>Thu, 01 Oct 2020 11:59:00 +0000</pubDate>
<dc:creator>1ndex-</dc:creator>
<og:description>参考文章 快速定位前端加密方法 渗透测试-前端加密测试 前言 最近学习挖洞以来，碰到数据做了加密基本上也就放弃了。但是发现越来越多的网站都开始做前端加密了，不论是金融行业还是其他。所以趁此机会来捣鼓一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wjrblogs/p/12850094.html</dc:identifier>
</item>
<item>
<title>.NET 是信息技术应用创新产业重要参与者 - 张善友</title>
<link>http://www.cnblogs.com/shanyou/p/13757381.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shanyou/p/13757381.html</guid>
<description>&lt;p&gt;今天是国庆节，也是中秋节，月满中秋，举国欢庆，在这里祝各位开发者中秋国庆快乐。 放假在家就想把这几年对于.NET发展相关生态做个梳理，写一篇文章来总结一下这两年从腾讯出来自己创业，推动.NET在国内的应用的一些感想，毕竟我是一个弱小的创业者，没有大公司的资源，更多是要靠大家的共同努力，打造更加有生命力的.NET社区。&lt;/p&gt;
&lt;p&gt;首先我们处于中国这样的一个大环境之下，在中国的.NET社区发展来说，相对于微软开源.NET 的2014年之前，中国的.NET社区得到了长足的发展，涌现了大量的开源社区，其中以NCC（.NET Core Community）为代表汇聚了国内主要的开源项目，NCC的发展过程也是曲折的，不时听说有人诋毁，我们相信谣言与诽谤终将破灭，一切诋毁开源社区的行为终将被反噬。在NCC 之外还存在着有特色的社区，比如以微信开发生态发展起来的盛派开发者社区，最近他们推出了集合盛派多年开发经验的框架NCF。&lt;/p&gt;
&lt;p&gt;随着中国的发展，很多技术因为一些原因越来越受制于人，尤其是上游核心技术。在中美当前背景下为了解决这个问题，我国明确了“数字中国”建设战略，抢占数字经济产业链制高点。于是，国家提出“2+8”安全可控体系，2020-2022年是国家信息技术应用创新产业推广最重要的3年，中国IT产业从基础硬件-基础软件-行业应用软件有望迎来国产替代潮。&lt;/p&gt;
&lt;p&gt;信息技术应用创新产业（简称信创）需要在四个层面逐步实现：基础硬件设施，如芯片、服务器、存储、交换机、路由器；底层软件，包括操作系统、数据库、中间件等；应用软件，面向实际应用的不同领域；安全产品，保障边界安全、终端安全和管理安全产品。目前在安可领域，高端芯片服务器等硬件已能基本满足办公需求；基础软件正在实现国产化替代。而在信创下，应用生态便显得匮乏了。 要实现应用软件从WinIntel 联盟、双A联盟（Android + ARM）到信创产业的平滑过渡，是丰富国产应用生态、推动信创产业从“可用”走向“好用”的重要手段。国内众多应用软件开发商也正在安可这一领域展开激烈竞争。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/510/202010/510-20201001102502447-568999728.png&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/510/202010/510-20201001102503054-2048822547.png&quot; alt=&quot;image&quot; width=&quot;678&quot; height=&quot;439&quot; title=&quot;image&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在信创产业龙芯给我们做出表率，他们积极投入研发力量把OpenJDK 和 .NET 纳入信创产业来建设，龙芯支持了计算机上运行应用程序的动态虚拟机Java、Javascript、.NET三大虚拟机，龙芯还正在开发一套指令翻译系统，可以将其他指令集翻译成Loongarch指令兼容X86，ARM，MIPS。目前信创产业国内也有很多的参与方，其中ARM的鲲鹏计算推进比较快，最近我也同华为的鲲鹏生态的相关负责人沟通，他们在鲲鹏生态对.NET支持是很支持的，而不是坊间流传的不支持.NET, 我和华为云的同学一起在华为云上建立了一个生态合作伙伴论坛的&lt;a href=&quot;https://bbs.huaweicloud.com/forum/forum-1184-1.html&quot;&gt;.net技术专区&lt;/a&gt; ：&lt;a title=&quot;https://bbs.huaweicloud.com/forum/forum-1184-1.html&quot; href=&quot;https://bbs.huaweicloud.com/forum/forum-1184-1.html&quot;&gt;https://bbs.huaweicloud.com/forum/forum-1184-1.html。&lt;/a&gt; 9月份我给华为云鲲鹏计算的全国各地的产业基地的同学们分享了一次.NET 技术。&lt;/p&gt;
&lt;p&gt;在信创产业背景下的中国.NET社区的发展也正在加速，活跃的社区加上具有说服力的开源产品的不断涌现，结合.NET的性能优势，充分发挥.NET的跨平台能力，在各行各业的开发者在各自领域都可以推出有竞争力的产品，亦或是基于其他语言流行产品的.NET版本或者客户端，这里举一个例子就是看到有些人觉得国内的.NET开源项目之中大多数ORM或者Web框架之类，同质化严重，我觉得有竞争才是好事，能说服社区的产品就是要货比三家、大浪淘沙。&lt;/p&gt;
&lt;p&gt;微软是非常有诚意发展.NET社区的，通过成立类似于Apache基金会的.NET基金会来支持.NET社区和开源，旨在拓宽和加强.NET生态系统和社区。这可以通过多种方式完成，包括项目指导，指导，法律和营销帮助，技术和财务支持设置等，2014年 .NET基金会的创始成员中有六位创始人，均非微软公司员工。随着微软的收购动作，Miguel 也成了微软员工，Migel一直在努力让.NET基金会独立于微软。2014年以来已经有众多知名公司加入.NET基金会, 仅在平台项目中，.NET平台上有87％贡献者其实不在Microsoft工作。在.net conf 2019 AWS加入了支持.NET Foundation的.NET开源生态系统中越来越多的行业领导者，这些成员包括Microsoft，Google，Red Hat，JetBrains，Unity，三星，Pivotal，Insight和Telerik，AWS等公司。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/510/202010/510-20201001181626222-25648717.png&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/510/202010/510-20201001181626828-381120913.png&quot; alt=&quot;image&quot; width=&quot;688&quot; height=&quot;386&quot; title=&quot;image&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我对所有参与社区建设的人都充满敬意，也鼓励各位.NET开发者积极融入社区，去了解、参与甚至创造.NET开源项目，请不要在社区里充满了嘲讽、不屑和鄙夷（经常可以在微信群，QQ群，博客评论里见到这种言论）。 不要抱怨社区没有什么，而是想想能为社区做什么。等到.NET社区充满了战斗力，受益的最终还是整个开发群体。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/510/202010/510-20201001181627531-553463157.png&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/510/202010/510-20201001181628199-1298306497.png&quot; alt=&quot;image&quot; width=&quot;695&quot; height=&quot;390&quot; title=&quot;image&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这几年.NET社区得到了很大的发展，还是有赖于.NET 本身的技术发展，.NET技术方面的优化和升级，也是.NET发展的强劲动力，很多人在谈到.NET Core相对于.NET Framework的优点时，第一时间想到的是开源跨平台。其实跨平台只是起点而非目的。.NET Core的更大的意义在于性能的提升，以及保持与时俱进的设计甚至引领潮流。 即将在2020 dotnet conf 上发布的.NET 5 将支持所有 .NET 应用程序类型：Xamarin、ASP.NET、IoT 和桌面,将利用一个单独的基类库 (BCL)、两个独立的运行时（MonoCLR和CoreCLR，因为很难将两个截然不同的运行时单独作为源）和一个工具链（比如 dotnet CLI），结果将是行为、API 和开发人员体验之间的一致性。 .NET 的统一有很多优点。将框架、运行时和开发人员工具集统一到一个代码库中，将减少开发人员（Microsoft 和社区）需要维护和扩展的重复代码量。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/510/202010/510-20201001181628601-845405087.png&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/510/202010/510-20201001181628958-386828794.png&quot; alt=&quot;image&quot; width=&quot;694&quot; height=&quot;360&quot; title=&quot;image&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;并且所有 .NET 5 源代码都将是开放源代码，所有人都能见证和参与其中，这让全球真心热爱这个平台或C#语言的有志之士有了一个集中的交流地，也极大的促进了国内.NET的发展，这些年虽然缺少了微软中国的布道支持，国内的.NET开源社区一样发展的不错，如果有微软中国的资源投入支持，相信这个结果会更好。&lt;/p&gt;
&lt;p&gt;性能的提升直接使得很多人开始关注和学习.NET 带来的优化，例如基础库中相当多的线程安全的静态方法被优化和重写，大幅减少竞争资源的损耗；推出性能极佳的System.Text.Json基础库替代包袱沉重的Json.NET, 还有更底层的Span&amp;lt;T&amp;gt;/Memory&amp;lt;T&amp;gt;, ref struct 等的引入，让C#在高效生产力的条件下拥有C/C++的性能。从C# 7.0开始一路完善的模式匹配（当然还是有很多人对这些新特性不是很满意），以及Range/Index的切片语法等等，这些都使得基于.NET的编程体验更上一层楼。在设计上引领潮流方面来说，以ASP.NET Core最为典型---依赖注入无处不在，认证、授权、日志、配置、中间件等模块都非常值得学习，对Docker，云服务、微服务、IOT、ML等支持和持续优化，也使得.NET/C#在较前沿的工程领域占有一席之地，特别是基于WebAssembly技术的Blazor框架在前后端分离的前端框架上也是引领潮流的。&lt;/p&gt;
&lt;p&gt;回顾自2014年以来的.NET 的开源发展路程，一路发展也不是一帆风顺的，中间也有不少批评和困扰。例如在.NET Core 2.1的HttpClient 出现了一些严重的性能问题，使得很多开发者怨声载道，EF Core 3.0 不再默认使用客户端评估（&lt;a title=&quot;https://docs.microsoft.com/zh-cn/ef/core/querying/client-eval&quot; href=&quot;https://docs.microsoft.com/zh-cn/ef/core/querying/client-eval&quot;&gt;https://docs.microsoft.com/zh-cn/ef/core/querying/client-eval&lt;/a&gt;）这样的一个较大的破坏性更新，让开发者在升级项目的数据访问层代码时遭遇打击。.NET的版本升级现在也是很快，这里强烈建议大伙把项目升级到当前最新的LTS版本，以后的升级尽量避免隔代升级，比如即将到来的.NET,从3.1升级上去会比较顺滑，这里特别要提醒的是别以为.NET 4.8也可以顺滑的升级到.NET 5。 这些发展道路上的问题确实也打击了部分开发者的耐心和信心，以至于他们在当时不得不额外花费时间，承受进度压力处理问题的时候，对.NET的评论极其负面。这同时也阻挠了相当一部分人将.NET Framework项目迁移到.NET Core或升级旧版本.NET Core的信心，随着.NET Core/Framework,新旧版本之间的差距越来越大，最终造成了恶性循环，项目的老化积重难返，想找到靠谱的人维护也变得逐渐困难。&lt;/p&gt;
&lt;p&gt;但是从总体上来说，这些年.NET的在技术发展上取得的成绩是值得欣喜的，它走出的每一步都是让.NET继续焕发青春，接下来几年时间里也是国家信息技术应用创新产业发展的黄金时间，一个完全开放的.NET生态会是这里非常重要的参与者。&lt;/p&gt;
</description>
<pubDate>Thu, 01 Oct 2020 10:16:00 +0000</pubDate>
<dc:creator>张善友</dc:creator>
<og:description>今天是国庆节，也是中秋节，月满中秋，举国欢庆，在这里祝各位开发者中秋国庆快乐。 放假在家就想把这几年对于.NET发展相关生态做个梳理，写一篇文章来总结一下这两年从腾讯出来自己创业，推动.NET在国内的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/shanyou/p/13757381.html</dc:identifier>
</item>
</channel>
</rss>