<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title> Redis事务 - 昂迪梵德</title>
<link>http://www.cnblogs.com/undefined22/p/12610330.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/undefined22/p/12610330.html</guid>
<description>&lt;h3 id=&quot;redis-事务简介&quot;&gt;Redis 事务简介&lt;/h3&gt;
&lt;p&gt;Redis 事务的基本功能由 MULTI、EXEC、DISCARD 及 WATCH 等命令实现。其中，&lt;/p&gt;
&lt;p&gt;● &lt;strong&gt;MULTI&lt;/strong&gt; 命令用于启动 Redis 的事务，将客户端置为事务状态。&lt;/p&gt;
&lt;p&gt;● &lt;strong&gt;EXEC&lt;/strong&gt; 命令用于提交事务，执行从 MULTI 到此命令前面的命令队列，此时客户端变为非事务状态。&lt;/p&gt;
&lt;p&gt;● &lt;strong&gt;DISCARD&lt;/strong&gt; 命令用于取消事务，命令执行后，将会清空事务队列中的所有命令，并且客户端从事务状态中退出。你可以把它理解为事务回滚，但是 Redis 数据库并不具有事务回滚机制。&lt;/p&gt;
&lt;p&gt;● &lt;strong&gt;WATCH&lt;/strong&gt; 命令用于监视键值对，它使得 EXEC 命令需要有条件地执行，在所有被监视键都没有被修改的前提下，事务才能正常被执行。如果这个被监视的键值对发生了改变，那么事务就不会被执行。&lt;/p&gt;
&lt;p&gt;Redis事务本质是一组命令的集合，Redis服务器先序列化这一组命令，然后一次性、按顺序、排他性地串行（逐个）执行这一组命令，并且不会在执行事务的途中去执行其他客户端命令。&lt;/p&gt;
&lt;p&gt;Redis事务只能保证一个客户端请求的事务中的命令可以连续地被执行&lt;/p&gt;
&lt;p&gt;当服务器接收到客户端发送过来的命令是 MULTI、EXEC、WATCH、DISCARD 4 个命令中的任意一个时，服务器会立即执行这个命令。&lt;/p&gt;
&lt;p&gt;相反，当服务器接收到客户端发送过来的命令是 MULTI、EXEC、WATCH、DISCARD 4 个命令以外的其他命令时，服务器不会立即执行这个命令，而是将该命令放入一个事务队列中，然后返回 QUEUED 标识给客户端。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1973632/202004/1973632-20200401085601861-103216564.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每个 Redis 客户端都有自己的事务状态，而 mstate 属性就保存了这个客户端的事务状态。事务状态由一个事务队列和一个入队命令的计数器组成。其中，事务队列是一个 multiCmd 类型的结构体数组，它采用先进先出（FIFO）的方式保存入队的命令，先入队的命令将会被放到数组的前面，先执行；而后入队的命令则被放到数组的后面，后执行。这个数组中的每个 multiCmd 结构都保存了一个入队命令的信息，具体包括指向命令实现函数的指针、命令的参数及参数数量等。&lt;/p&gt;
&lt;h3 id=&quot;acid-特性&quot;&gt;ACID 特性&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;原子性&lt;/strong&gt;：当客户端使用 MULTI 命令成功开启一个事务上下文，执行 EXEC 命令，中间入队列的多个命令要不全部执行成功，要不全部失败。&lt;/p&gt;
&lt;p&gt;当客户端处于事务开启状态时，每进入一条命令，都会返回一个内容为 QUEUED 的结果回复&lt;/p&gt;
&lt;p&gt;在执行 EXEC 命令后，将会以数组的方式返回执行的结果，数组中的每个元素都是事务中的命令执行结果。结果的输出顺序与开启事务后命令进入队列的先后顺序一致。&lt;/p&gt;
&lt;p&gt;然而 Redis 数据库并不支持事务回滚。向Redis事务队列中插入命令，如果遇到命令格式错误，入队失败，则会导致整个事务执行失败。如果遇到事务中某个命令的语法格式正确，但在执行时因为类型或者键不存在而报错，那么它的整个事务也会继续执行下去，而不是终止执行，直到这个事务的所有命令执行完毕为止。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一致性&lt;/strong&gt;：事务的一致性说的是，数据库在执行事务之前是一致的，在执行事务之后，不管事务是执行成功还是执行失败，数据库中的数据也应该具有一致性。&lt;/p&gt;
&lt;p&gt;当存在错误命令，或者命令格式错误。服务器会拒绝执行入队过程中出现错误的事务，导致了事务执行失败，从而保证了数据库的一致性。&lt;/p&gt;
&lt;p&gt;当命令入队成功，但在执行过程中发生了错误。如 INCRBY username 8 命令，那么执行错误的命令会被服务器检测出来，并做相应的错误处理，所以这些执行错误的命令并不会影响其他命令的执行，也不会修改数据库，对事务的一致性并不会产生影响。&lt;/p&gt;
&lt;p&gt;当发生突发情况（如断电、服务器停机、服务器崩溃等），导致事务执行出错。此时常常会根据服务器所使用的持久化方式来保证数据库的一致性，具体如下。&lt;/p&gt;
&lt;p&gt;➢ 服务器没有开启持久化，在服务器重启时，数据库中将没有任何数据，此时可以保证数据库的一致性。&lt;/p&gt;
&lt;p&gt;➢ 服务器开启了 RDB 或 AOF 持久化，在执行事务的过程中，发生故障，不会引起数据库的不一致性。RDB 或 AOF 文件中保存了数据库数据，可以根据 RDB 或 AOF 文件来将数据还原到事务执行之前的状态。如果开启了 RDB 或 AOF 持久化方式，但是找不到 RDB 或 AOF 文件，那么在服务器重启后，数据库会是空白的，也能保证数据库的一致性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;隔离性&lt;/strong&gt;：Redis 数据库是采用单进程单线程模型实现的键值对存储数据库，它在执行事务命令及其他相关命令时，采用的就是单线程方式。在执行事务的过程中，服务器可以保证这个事务不会被中断，所以 Redis 事务总是以串行方式实现的，在上一个事务没有执行完之前，其他命令是不会被执行的，这就是 Redis 事务的隔离性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;持久性&lt;/strong&gt;：Redis 数据库是采用单进程单线程模型实现的键值对存储数据库，它在执行事务命令及其他相关命令时，采用的就是单线程方式。在执行事务的过程中，服务器可以保证这个事务不会被中断，所以 Redis 事务总是以串行方式实现的，在上一个事务没有执行完之前，其他命令是不会被执行的，这就是 Redis 事务的隔离性。&lt;/p&gt;
&lt;p&gt;●如果 Redis 服务器没有采用任何持久化方式，那么事务不具有持久性。假如服务器发生故障（如停机、断电、崩溃），将会丢失服务器上包括事务数据在内的所有数据。&lt;/p&gt;
&lt;p&gt;● 如果 Redis 服务器使用了 AOF 持久化方式：&lt;/p&gt;
&lt;p&gt;➢ 当 Redis 配置文件（redis.conf）中的 appendfsync 属性的值为 always 时，可以保证 Redis 事务具有持久性。每当服务器执行完相关命令后，包括事务命令在内，程序都会调用执行 sync 同步函数，将命令数据及时保存到系统硬盘中，这就保证了事务的持久性。&lt;/p&gt;
&lt;p&gt;➢ 当 Redis 配置文件中的 appendfsync 属性的值为 everysec 时，服务器程序会每隔 1 秒执行一次数据同步操作，并将数据保存到硬盘中。如果服务器发生停机故障，可能刚好发生在数据等待同步的那 1 秒之内，就会导致数据丢失，因此无法保证事务的持久性。&lt;/p&gt;
&lt;p&gt;➢ 当 Redis 配置文件中的 appendfsync 属性的值为 no 时，服务器命令数据同步保存到硬盘中的操作将由操作系统来控制，因此，事务数据在同步的过程中，可能会因为一些原因而丢失，这种情况也不能保证事务的持久性。后面的章节将会详细介绍 Redis 的持久化。&lt;/p&gt;
&lt;p&gt;● 如果 Redis 服务器使用了 RDB 持久化方式，那么，只有在特定的保存条件被满足时，服务器才会执行 BGSAVE 命令，实现数据的保存。而如果是异步执行 BGSAVE 命令，那么服务器并不能保证在第一时间将事务数据保存到硬盘中，因此也就不能保证事务的持久性。换句话说，RDB 持久化方式不能保证事务具有持久性。&lt;/p&gt;
&lt;h4 id=&quot;悲观锁和乐观锁&quot;&gt;悲观锁和乐观锁&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;悲观锁&lt;/strong&gt;：每次去数据库中取数据的时候都会认为别人会修改这些数据，所以它每次取数据的时候都会给这些数据加锁，不让别人使用，别人想拿这些数据就会阻塞直到它释放锁、别人获得锁为止。在传统的关系型数据库中，使用了大量的悲观锁，如行锁、表锁、读锁、写锁等&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;乐观锁&lt;/strong&gt;：每次去数据库中取数据的时候，都认为别人不会修改这些数据，所以它不会给这些数据加锁。但是它也很细心，每次在更新这些数据的时候，都会判断一下在此期间有没有别人更新过这些数据。如果别人更新过这些数据，它就会放弃本次更新；相反，如果别人没有更新过这些数据，它就会更新这些数据。乐观锁比较适用于多读的应用类型，可以提高吞吐量。（下文中WATCH 命令就是一个乐观锁）&lt;/p&gt;
&lt;h4 id=&quot;事务的-watch-命令&quot;&gt;事务的 WATCH 命令&lt;/h4&gt;
&lt;p&gt;事务的 WATCH 命令用于监视事务中的命令。有了 WATCH 命令的监视，就会使得 EXEC 命令需要有条件地执行，只有在所有被 WATCH 命令监视的数据库键都没有被修改的前提下，这个事务才能执行成功。如果所有被监视的数据库键中有任意一个数据库键被修改，那么这个事务都会执行失败。&lt;/p&gt;
&lt;p&gt;使用 UNWATCH 命令取消 WATCH 命令对数据库键的监视&lt;/p&gt;
&lt;p&gt;使用方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;WATCH name age＃WATCH 命令同时监视 name 键和 age 键
MULTI＃开启事务上下文
...
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 01 Apr 2020 00:56:00 +0000</pubDate>
<dc:creator>昂迪梵德</dc:creator>
<og:description>Redis事务 Redis 事务简介 Redis 事务的基本功能由 MULTI、EXEC、DISCARD 及 WATCH 等命令实现。其中， ● MULTI 命令用于启动 Redis 的事务，将客户端</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/undefined22/p/12610330.html</dc:identifier>
</item>
<item>
<title>单元测试实践思考(junit5+jmockit+testcontainer) - 陈晨_软件五千言</title>
<link>http://www.cnblogs.com/pluto4596/p/12610333.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pluto4596/p/12610333.html</guid>
<description>&lt;p&gt;之前整理过一篇，基于（SpringCloud+Junit5+Mockito+DataMocker）的框架整理的单元测试。当时的项目是一个编排层的服务项目，所以没有涉及到数据库或者其他中间件的复杂问题。而且是项目刚开始，代码环境不复杂，当时的架构基本上能够满足需求。&lt;br/&gt;最近在一个较老项目，现在希望加强项目的代码质量，所以开始引入单元测试框架。于是乎先按照原本的设计引入了junit5的整套框架，同时引入了h2用于数据库模拟，以及rabbitmq的mock服务。这个项目使用的是SpringCloud Alibaba框架，服务注册和配置管理使用nacos，其他没有太多特别的地方。但是实际编写的过程中，发现了一些问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Mock框架使用了Mockito和PowerMock，开发人员需要同时使用两种框架。&lt;/li&gt;
&lt;li&gt;H2的数据库和实际的Mysql数据库相比还是有一些差异，比如无法支持函数等情况。&lt;/li&gt;
&lt;li&gt;单元测试的数据准备相对比较复杂，如何能够很好的隔离不同单元测试的影响是个问题。&lt;/li&gt;
&lt;li&gt;单元测试是为了覆盖率还是为了有强度的质量保证，如何提高研发人员的单元测试质量。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;针对上述问题，我们来一条一条解决。&lt;br/&gt;首先是针对Mock框架，考察之后认为可以选择Jmockit框架，能够直接满足普通方法和静态方法，但是语法相对不如Mockito自然，学习曲线相对较高。但最终还是决定尝试以统一框架来做，降低架构的复杂度。&lt;br/&gt;其次是数据库问题，有两种方案，一种是完善H2数据库，可以用自定义的函数来支持缺失的特性，但缺点也很明确，H2始终不是真实的Mysql数据库。第二种找到了TestContainer方案，这是一个Java操作Docker的类库，可以利用Java代码直接生成Docker的镜像与容器并且运行，这样就有办法直接启动一个Mysql的容器用于单元测试，结束后直接完全销毁。这种方法的缺点在于环境问题，所有需要运行单元测试的环境都需要安装Docker支持，包含研发自己和CI环境。但是好处在于一个通用的中间件模拟方案，后续Redis、MQ或者其他的中间件都完全可以使用这样的方案来模拟了。&lt;br/&gt;数据准备，这个问题我们设定了两种数据准备的方式。第一部分是在初始化数据库的时候，导入基础脚本，这部分的脚本包含结构和数据，是公用的内容所有的单元测试都需要依赖的基础数据，比如公司、部门、员工、角色、权限等等。第二部分是在单元测试单个类初始化时，引入数据脚本，这些数据仅仅是为了单个类/方法中的单元测试使用，运行完方法后会回滚，不会影响到其他单元测试的运行。&lt;br/&gt;最后是单元测试的强度，主要还是一些规范，例如要求所有的单元测试都必须要有断言，并且断言的条件是要对数据内容字段进行合理验证的。可以参考一下这一篇&lt;a href=&quot;https://yq.aliyun.com/articles/54478&quot;&gt;写有价值的单元测试&lt;/a&gt;。&lt;br/&gt;所以最终落定的框架就是 Junit5 + Jmockit + TestContainer。&lt;/p&gt;

&lt;p&gt;在底层框架搭建之前，可以先讨论一下如何才能写出真正有价值的单元测试，而不是单纯为了绩效中的单元测试覆盖率？&lt;br/&gt;之前一段中提到的&lt;a href=&quot;https://yq.aliyun.com/articles/54478&quot;&gt;写有价值的单元测试&lt;/a&gt;和阿里Java代码规约中有提到一些点&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;引用阿里规约：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;【强制】好的单元测试必须遵守 AIR原则。&lt;br/&gt;说明：单元测试在线上运行时，感觉像空气（AIR）一样并不存在，但在测试质量的保障上，&lt;br/&gt;却是非常关键的。好的单元测试宏观上来说，具有自动化、独立性、可重复执行的特点。 A：Automatic（自动化） I：Independent（独立性） R：Repeatable（可重复）&lt;/li&gt;
&lt;li&gt;【强制】单元测试应该是全自动执行的，并且非交互式的。测试用例通常是被定期执行的，执&lt;br/&gt;行过程必须完全自动化才有意义。输出结果需要人工检查的测试不是一个好的单元测试。单元&lt;br/&gt;测试中不准使用 System.out来进行人肉验证，必须使用 assert来验证。&lt;/li&gt;
&lt;li&gt;【强制】保持单元测试的独立性。为了保证单元测试稳定可靠且便于维护，单元测试用例之间&lt;br/&gt;决不能互相调用，也不能依赖执行的先后次序。&lt;br/&gt;反例：method2需要依赖 method1的执行，将执行结果作为 method2的输入。&lt;/li&gt;
&lt;li&gt;【强制】单元测试是可以重复执行的，不能受到外界环境的影响。&lt;br/&gt;说明：单元测试通常会被放到持续集成中，每次有代码 check in时单元测试都会被执行。如&lt;br/&gt;果单测对外部环境（网络、服务、中间件等）有依赖，容易导致持续集成机制的不可用。&lt;br/&gt;正例：为了不受外界环境影响，要求设计代码时就把 SUT的依赖改成注入，在测试时用 spring&lt;br/&gt;这样的 DI框架注入一个本地（内存）实现或者 Mock实现。&lt;/li&gt;
&lt;li&gt;【强制】对于单元测试，要保证测试粒度足够小，有助于精确定位问题。单测粒度至多是类级&lt;br/&gt;别，一般是方法级别。&lt;br/&gt;说明：只有测试粒度小才能在出错时尽快定位到出错位置。单测不负责检查跨类或者跨系统的&lt;br/&gt;交互逻辑，那是集成测试的领域。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;其中有一些思想会决定我们在单元测试代码具体的实现方式。我们尝试了之后，根据上述的指导思想有两种不同的实现方式。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;单层隔离&lt;/li&gt;
&lt;li&gt;内部穿透&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;接下来我们就两种方式来进行说明。&lt;/p&gt;
&lt;h2 id=&quot;单层隔离&quot;&gt;单层隔离&lt;/h2&gt;
&lt;p&gt;正常代码分层会分为controller、service、dao等，在单层隔离的思想中，是针对每一层的代码做各自的单元测试，不向下穿透。这样的写法主要是保证单层的业务逻辑固化且正确。&lt;br/&gt;实践过程中，例如针对controller层编写的单元测试需要将对应controller类代码文件外部所有的调用全部mock，包括对应的内部/外部的service。其他层的代码也是如此。&lt;/p&gt;
&lt;p&gt;这样做的优点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;单元测试代码极其轻量，运行速度快。由于只保证单个类内部的逻辑正确，其他全部mock，所以可以放弃中间件的mock，甚至Spring的注入都可以放弃，专注在单元测试逻辑验证的编写。这样整套单元测试代码运行完成应该也是轮秒计时，相对来讲Spring容器初始化完成可能都需要20秒。&lt;/li&gt;
&lt;li&gt;真正符合了单元测试的原则，可以在断网的情况下进行运行。单层逻辑中可以屏蔽服务注册和配置管理，各种中间件的影响。&lt;/li&gt;
&lt;li&gt;单元测试质量更高。针对单层逻辑的验证和断言能够更加清晰，如果要覆盖多层，可能会忽略丢失中间的各种验证环节，如果加上可能条件规模是一个笛卡尔乘积过于复杂。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;缺点也是存在：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;单元测试的代码量比较大，因为是针对每层单独编写单元测试，而且需要mock掉的外部依赖也是比较多的。&lt;/li&gt;
&lt;li&gt;学习曲线相对较高，由于程序员的习惯针对单元测试是给定输入验证输出。所以没有了底层的输出，单纯验证过程逻辑要存在一个思维上的转变。&lt;/li&gt;
&lt;li&gt;对于低复杂度的项目比较不友好。如果你的项目大部分都是单纯的分层之后的CRUD，那单元测试其实可验证的东西不太多。但是如果是代码当中执行了复杂逻辑，这样的写法就能够起到比较好的质量保证。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在这个项目中，最终没有采用这样的方法，而是采用了穿透的方式。项目的场景、人员组成、复杂度的实际情况，我觉得用这种方式不算很合适。&lt;/p&gt;
&lt;h2 id=&quot;内部穿透&quot;&gt;内部穿透&lt;/h2&gt;
&lt;p&gt;穿透，自然就是从顶层一直调用到底层。为什么还要加上内部二字？就是除了项目内的方法可以穿透，项目外部依赖还是要mock掉的。&lt;br/&gt;实践过程中，就是单元测试针对controller层编写，但是会完整调用service、dao，最终对落地结果进行验证。&lt;/p&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;代码量相对较小，由于进行了穿透所以多层代码的覆盖仅需要从顶层的单元测试验证即可。&lt;/li&gt;
&lt;li&gt;学习曲线低，穿透的单元测试更偏向黑盒，开发人员构造输入条件，然后从落地结果中（存储，例如数据库）验证预期结果。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;整体较重，启动Spring容器，中间件mock，整体单元测试运行预计需要是需要分钟级别。所以基本是要在CI的时候来执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;敲定方案之后我们就可以进行技术实现了，这是一个Java项目，使用Maven进行依赖管理。接下来我们主要分为三部分介绍：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;依赖管理&lt;/li&gt;
&lt;li&gt;基础架构&lt;/li&gt;
&lt;li&gt;实现实例&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;依赖管理&quot;&gt;依赖管理&lt;/h2&gt;
&lt;p&gt;依赖管理中第一个注意的点，由于目前Junit4还占有较多的市场，我们要尽量去排除掉一些测试相关的依赖中包含对与4的引用。&lt;br/&gt;接下来我先贴出Pom文件中和单元测试相关的部分&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;        &amp;lt;!-- Jmockit --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.jmockit&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;jmockit&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.49&amp;lt;/version&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;!-- junit5 框架 --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.junit.jupiter&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;junit-jupiter&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;5.6.1&amp;lt;/version&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;!--  Spring Boot 测试框架 --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
            &amp;lt;!-- exclude junit 4 --&amp;gt;
            &amp;lt;exclusions&amp;gt;
                &amp;lt;exclusion&amp;gt;
                    &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
                    &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
                &amp;lt;/exclusion&amp;gt;
            &amp;lt;/exclusions&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;!--  公司内部封装的一个数据自动Mock框架，来源于Jmockdata --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;cn.vv.service.unittest&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;vv-data-mocker&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;!--  testcontainers对于mysql的封装包，当然也可以将mysql替换为testcontainers，这样直接引入底层容器包 --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.testcontainers&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;mysql&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.12.0&amp;lt;/version&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;!--  testcontainers 容器对于junit5的支持 --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.testcontainers&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;junit-jupiter&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.12.0&amp;lt;/version&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;依赖的引入基本就是这些了，其中还需要注意的是surefire的插件配置&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;maven-surefire-plugin&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;3.0.0-M4&amp;lt;/version&amp;gt;
                &amp;lt;configuration&amp;gt;
                    &amp;lt;argLine&amp;gt;-javaagent:${settings.localRepository}/org/jmockit/jmockit/1.49/jmockit-1.49.jar
                        -Dfile.encoding=UTF-8 -Xmx1024m
                    &amp;lt;/argLine&amp;gt;
                    &amp;lt;enableAssertions&amp;gt;true&amp;lt;/enableAssertions&amp;gt;
                    &amp;lt;!-- &amp;lt;useSystemClassLoader&amp;gt;true&amp;lt;/useSystemClassLoader&amp;gt;--&amp;gt;
                &amp;lt;/configuration&amp;gt;
                &amp;lt;dependencies&amp;gt;
                    &amp;lt;dependency&amp;gt;
                        &amp;lt;groupId&amp;gt;org.apache.maven.surefire&amp;lt;/groupId&amp;gt;
                        &amp;lt;artifactId&amp;gt;surefire-api&amp;lt;/artifactId&amp;gt;
                        &amp;lt;version&amp;gt;3.0.0-M4&amp;lt;/version&amp;gt;
                    &amp;lt;/dependency&amp;gt;
                &amp;lt;/dependencies&amp;gt;
            &amp;lt;/plugin&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的注意点是Jmockit需要使用javaagent来初始化JVM参数。&lt;/p&gt;
&lt;h2 id=&quot;基础架构&quot;&gt;基础架构&lt;/h2&gt;
&lt;p&gt;基础架构的部分，我想分为三点来讲：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;单元测试基类，封装了一些项目使用的基础Mock对象和公用方法&lt;/li&gt;
&lt;li&gt;单元测试配置相关&lt;/li&gt;
&lt;li&gt;TestContainer的封装&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其实这三点都是与单元测试基类相关的，分开讲各自的实现方式后，最终会给出完整的代码。&lt;/p&gt;
&lt;h3 id=&quot;封装junit5jmockit&quot;&gt;封装Junit5&amp;amp;Jmockit&lt;/h3&gt;
&lt;p&gt;首先是注解的部分Junit4到5注解有调整和变化，而且我们的项目又是基于SpringCloud的，所以最终的单元测试基类BaseTest使用了三个注解&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@SpringBootTest(classes = {OaApplication.class}, webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@Transactional
@Slf4j
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Junit5的类头部是不需要什么注解的，主要还是和Spring配合，我们使用了Boot Test提供的SpringBootTest注解，指定了入口的启动类，为了包含配置文件，获取nacos配置。&lt;br/&gt;事务注解是为了让数据操作方法都能够回滚，不影响其他单元测试。&lt;br/&gt;最后就是lombok的日志注解。&lt;/p&gt;
&lt;p&gt;接下来就是BeforeAll，AfterAll，BeforeEach，AfterEach几个注解。&lt;br/&gt;这里的思路就是使用Jmockit，对待测试业务系统内底层机制进行统一的Mock处理，例如request或者session中的头部信息。我这里的代码可能和大家各自的项目中差异比较多，只是提供一个思路。利用Jmockit来Mock我们一些静态方法获取对象时，直接返回我们设计的结果对象。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
    @BeforeAll
    protected static void beforeAll() {

        new MockUp&amp;lt;ShiroUtils&amp;gt;(ShiroUtils.class) {
            @Mock
            public EmployeeVO getEmployee() {
                EmployeeVO employeeVO = new EmployeeVO();
                employeeVO.setUserName(&quot;mock.UserName&quot;);
                employeeVO.setUserNo(&quot;mock.UserNo&quot;);
                employeeVO.setCompanyName(&quot;mock.CompanyName&quot;);
                employeeVO.setDepartmentName(&quot;mock.DepartmentName&quot;);
                return employeeVO;
            }
        };
        new MockUp&amp;lt;LogAspect&amp;gt;(LogAspect.class) {
            @Mock
            public String getIp() {
                return &quot;mock.ip&quot;;
            }
        };
    }

    @AfterAll
    protected static void destroy() {
    }

    @BeforeEach
    protected void beforeEach() {

        new MockUp&amp;lt;WebUtil&amp;gt;(WebUtil.class) {
            @Mock
            public HttpServletRequest getRequest() {
                return getRequest;
            }

            @Mock
            public VvCurrentAccount getCurrentAccount(Boolean isMustLogin) {
                VvCurrentAccount vvCurrentAccount = new VvCurrentAccount();
                vvCurrentAccount.setUserCode(&quot;mock.userCode&quot;);
                return vvCurrentAccount;
            }
        };
        new MockUp&amp;lt;ServletUtils&amp;gt;(ServletUtils.class) {
            @Mock
            public HttpServletRequest getRequest() {
                return getRequest;
            }
        };


        if (StringUtil.isNotBlank(this.getDbScript())) {
            try {
                ScriptRunner runner = new ScriptRunner(dataSource.getConnection());
                runner.setErrorLogWriter(null);
                runner.setLogWriter(null);
                runner.runScript(new FileReader(this.getClass().getResource(this.getDbScript()).getPath()));
            } catch (Exception e) {
                log.error(&quot;ScriptRunner error!&quot;, e);
            }
        }
    }

    @AfterEach
    protected void afterEach() {
    }


    protected String getDbScript() {
        return &quot;&quot;;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里有一个设计点可以讨论一下，beforeEach中调用了getDbScript，用于在单元测试方法前构建单个单元测试类中需要的数据。而且由于类都继承了事务默认回滚，所以本次操作完的数据在方法结束后都会回滚，这样把数据的影响降到了最低。&lt;br/&gt;每个单元测试类只要重写一下getDbScript方法，提供自己的数据库脚本即可。用这样的设计来进行单元测试方法级别的数据隔离。&lt;/p&gt;
&lt;h3 id=&quot;单元测试配置&quot;&gt;单元测试配置&lt;/h3&gt;
&lt;p&gt;由于本项目的框架使用了Nacos，其地址和空间都是配置在Pom文件中，在运行时指定Profile来调用不同环境的配置。正常使用时，中间件的访问地址，用户密码等信息也是保存在Nacos上，由于运行单元测试需要Mock真实中间件，所以所有信息都需要替换。&lt;br/&gt;第一个版本是使用了Nacos的本身特性，在单元测试头部使用 &lt;code&gt;@ActiveProfile(&quot;&quot;)&lt;/code&gt; 之后，会读取对应配置文件的properties来替换占位符，例如原本我们的配置是写在vv-oa.yml中，我们指定了ActiveProfile(&quot;test&quot;)，则会去加载vv-oa-test.properties文件，用于替换yml中的配置。&lt;br/&gt;通过这样的方法来达到仅仅在单元测试中替换中间件连接的目的。&lt;br/&gt;但是由于中间件的Mock方法使用了TestContainer，容器的地址实际上无法直接固定，所以这个方案就不是很合适了。就使用本地配置的形式（AutoConfiguration），新建一个配置类放在单元测试的包中。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
@Configuration
@EnableTransactionManagement
public class JunitDataSource {

    @Bean
    public DataSource dataSource() throws Exception {
        Properties properties = new Properties();
        properties.setProperty(&quot;driverClassName&quot;, System.getProperty(&quot;spring.datasource.driver-class-name&quot;));
        properties.setProperty(&quot;url&quot;, System.getProperty(&quot;spring.datasource.url&quot;));
        properties.setProperty(&quot;username&quot;, System.getProperty(&quot;spring.datasource.username&quot;));
        properties.setProperty(&quot;password&quot;, System.getProperty(&quot;spring.datasource.password&quot;));
        return DruidDataSourceFactory.createDataSource(properties);
    }

    @Bean
    public PlatformTransactionManager transactionManager() throws Exception {
        return new DataSourceTransactionManager(dataSource());
    }

}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其他中间件也使用相同的方式。&lt;/p&gt;
&lt;h3 id=&quot;testcontainer封装&quot;&gt;TestContainer封装&lt;/h3&gt;
&lt;p&gt;首先给大家提供&lt;a href=&quot;https://www.testcontainers.org/&quot;&gt;官方网站&lt;/a&gt;和他们的&lt;a href=&quot;https://github.com/testcontainers/testcontainers-java&quot;&gt;Github代码示例库&lt;/a&gt;，很多用法都是参考官方的来的。本文以Mysql的容器作为样例给大家简单介绍一下使用。&lt;/p&gt;
&lt;h4 id=&quot;官方方案&quot;&gt;官方方案&lt;/h4&gt;
&lt;p&gt;在官方文档中的&lt;a href=&quot;https://www.testcontainers.org/modules/databases/&quot;&gt;数据库容器&lt;/a&gt;章节中，介绍了两种数据库容器的使用方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;代码中启动容器&lt;/li&gt;
&lt;li&gt;通过JDBC url启动容器&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;   @Rule
    public MySQLContainer mysql = new MySQLContainer();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码中启动就是这么简单，一个最简单Mysql容器就启动了，默认的配置信息如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    public static final String NAME = &quot;mysql&quot;;
    public static final String IMAGE = &quot;mysql&quot;;
    public static final String DEFAULT_TAG = &quot;5.7.22&quot;;
    private static final String MY_CNF_CONFIG_OVERRIDE_PARAM_NAME = &quot;TC_MY_CNF&quot;;
    public static final Integer MYSQL_PORT = 3306;
    private String databaseName = &quot;test&quot;;
    private String username = &quot;test&quot;;
    private String password = &quot;test&quot;;
    private static final String MYSQL_ROOT_USER = &quot;root&quot;;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着在BeforeAll中调用 &lt;code&gt;mysql.start()&lt;/code&gt;，容器便启动了。&lt;/p&gt;
&lt;p&gt;JDBC的方式更简单，无需任何代码，直接在配置中指定驱动和url即可&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;spring.datasource.driver-class-name=org.testcontainers.jdbc.ContainerDatabaseDriver
spring.datasource.url=jdbc:tc:mysql:5.7.22:///databasename?TC_INITSCRIPT=file:src/main/resources/init_mysql.sql&amp;amp;TC_INITFUNCTION=org.testcontainers.jdbc.JDBCDriverTest::sampleInitFunction
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里要注意的几个点&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;驱动必须使用tc提供的&lt;/li&gt;
&lt;li&gt;url中mysql之后跟的时版本号，对应可以理解为是dockerhub中mysql的镜像版本号其实也是mysql的实际版本。&lt;/li&gt;
&lt;li&gt;tc提供了两种数据库初始话方式，直接指定脚本 &lt;em&gt;TC_INITSCRIPT&lt;/em&gt; ，或者指定代码初始化类 &lt;em&gt;TC_INITFUNCTION&lt;/em&gt; ，&lt;strong&gt;这两种方法是可以同时存在的&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;实际方案&quot;&gt;实际方案&lt;/h4&gt;
&lt;p&gt;项目中使用的时候上面两种使用方式实际都不是很好，MySQLContainer经过了封装可定制的内容相对较少，JDBC的方式也是同样的问题例如端口等配置都无法设定。&lt;br/&gt;为了更加灵活，我们使用了最原始的基础容器类来自己构建一个Mysql的容器。先直接给出代码。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
    @ClassRule
    public static GenericContainer mysql = new VvFixedHostPortGenericContainer(
            new ImageFromDockerfile(&quot;mysql-vv-gms&quot;)
                    .withDockerfileFromBuilder(dockerfileBuilder -&amp;gt; {
                        dockerfileBuilder.from(&quot;mysql:8.0.0&quot;)
                                .env(&quot;MYSQL_ROOT_PASSWORD&quot;, &quot;test&quot;)
                                .env(&quot;MYSQL_DATABASE&quot;, &quot;test&quot;)
                                .env(&quot;MYSQL_USER&quot;, &quot;test&quot;)
                                .env(&quot;MYSQL_PASSWORD&quot;, &quot;test&quot;)
                                .add(&quot;my.cnf&quot;, &quot;/etc/mysql/conf.d&quot;)
                                .add(&quot;db-schema.sql&quot;, &quot;/docker-entrypoint-initdb.d&quot;)
                        ;
                    })
                    .withFileFromClasspath(&quot;my.cnf&quot;, &quot;my.cnf&quot;)
                    .withFileFromClasspath(&quot;db-schema.sql&quot;, &quot;db-schema.sql&quot;)
    )
            .withFixedExposedPort(3307, 3306)
            .waitingFor(Wait.forListeningPort());
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package cn.vv.oa.init;

import lombok.NonNull;
import org.testcontainers.containers.GenericContainer;
import org.testcontainers.containers.InternetProtocol;

import java.util.concurrent.Future;

public class VvFixedHostPortGenericContainer&amp;lt;SELF extends VvFixedHostPortGenericContainer&amp;lt;SELF&amp;gt;&amp;gt; extends GenericContainer&amp;lt;SELF&amp;gt; {

    public VvFixedHostPortGenericContainer(@NonNull final Future&amp;lt;String&amp;gt; image) {
        super(image);
    }

    /**
     * Bind a fixed TCP port on the docker host to a container port
     *
     * @param hostPort a port on the docker host, which must be available
     * @param containerPort a port in the container
     * @return this container
     */
    public SELF withFixedExposedPort(int hostPort, int containerPort) {

        return withFixedExposedPort(hostPort, containerPort, InternetProtocol.TCP);
    }

    /**
     * Bind a fixed port on the docker host to a container port
     *
     * @param hostPort a port on the docker host, which must be available
     * @param containerPort a port in the container
     * @param protocol an internet protocol (tcp or udp)
     * @return this container
     */
    public SELF withFixedExposedPort(int hostPort, int containerPort, InternetProtocol protocol) {

        super.addFixedExposedPort(hostPort, containerPort, protocol);

        return self();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二个VvFixedHostPortGenericContainer其实可以不用特别关注，这个类仅仅是为了暴露出基础容器类的指定端口方法，和通过构建Dockerfile生成镜像的构造函数。关键还是看第一段声明mysql容器的部分。&lt;br/&gt;withDockerfileFromBuilder 这个方法，实际上就是指定了Dockerfile的构造方法，能够暴露出的方法都是Dockerfile能够编写的命令，如果你了解docker这是很好的定制化方式。其中add命令能够添加的文件，是需要我们后面用withFileFromClasspath来映射的。&lt;br/&gt;通过 withFixedExposedPort方法来指定暴露端口，mysql8之后会启动两个端口 3306和33060，我们目前只需要3306暴露即可。&lt;br/&gt;这里添加的两个文件也是需要了解一下。&lt;br/&gt;my.cnf文件是为了覆盖mysql的默认配置，能够解决数据库编码等底层设置问题，要注意的是add命令添加的文件路径 &lt;em&gt;/etc/mysql/conf.d&lt;/em&gt; 这样才能初始化配置。&lt;br/&gt;db-schem.sql是初始化数据库脚本，添加在容器中的 &lt;em&gt;/docker-entrypoint-initdb.d&lt;/em&gt; 路径中就会自动执行，不过注意脚本只能添加一个。&lt;br/&gt;顺便吧my.cnf也贴上来吧，可能会影响数据库的中文乱码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[mysqld]
user = mysql
datadir = /var/lib/mysql
port = 3306
#socket = /tmp/mysql.sock
skip-external-locking
key_buffer_size = 16K
max_allowed_packet = 1M
table_open_cache = 4
sort_buffer_size = 64K
read_buffer_size = 256K
read_rnd_buffer_size = 256K
net_buffer_length = 2K
skip-host-cache
skip-name-resolve
character-set-server = utf8
collation-server = utf8_general_ci

# Don't listen on a TCP/IP port at all. This can be a security enhancement,
# if all processes that need to connect to mysqld run on the same host.
# All interaction with mysqld must be made via Unix sockets or named pipes.
# Note that using this option without enabling named pipes on Windows
# (using the &quot;enable-named-pipe&quot; option) will render mysqld useless!
#
#skip-networking
#server-id = 1

# Uncomment the following if you want to log updates
#log-bin=mysql-bin

# binary logging format - mixed recommended
#binlog_format=mixed

# Causes updates to non-transactional engines using statement format to be
# written directly to binary log. Before using this option make sure that
# there are no dependencies between transactional and non-transactional
# tables such as in the statement INSERT INTO t_myisam SELECT * FROM
# t_innodb; otherwise, slaves may diverge from the master.
#binlog_direct_non_transactional_updates=TRUE

# Uncomment the following if you are using InnoDB tables
innodb_data_file_path = ibdata1:10M:autoextend
# You can set .._buffer_pool_size up to 50 - 80 %
# of RAM but beware of setting memory usage too high
innodb_buffer_pool_size = 16M
#innodb_additional_mem_pool_size = 2M
# Set .._log_file_size to 25 % of buffer pool size
innodb_log_file_size = 5M
innodb_log_buffer_size = 8M
innodb_flush_log_at_trx_commit = 1
innodb_lock_wait_timeout = 50

[mysql.server]
default-character-set=utf8
[mysql_safe]
default-character-set=utf8
[client]
default-character-set=utf8
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;完整类代码&quot;&gt;完整类代码&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package cn.vv.oa;

import cn.vv.OaApplication;
import cn.vv.fw.common.api.VvCurrentAccount;
import cn.vv.fw.common.utils.StringUtil;
import cn.vv.fw.common.utils.WebUtil;
import cn.vv.oa.api.org.vo.EmployeeVO;
import cn.vv.oa.common.aspectj.LogAspect;
import cn.vv.oa.common.filter.TokenAuthorFilters;
import cn.vv.oa.common.shiro.ShiroUtils;
import cn.vv.oa.common.utils.ServletUtils;
import cn.vv.oa.init.VvFixedHostPortGenericContainer;
import lombok.extern.slf4j.Slf4j;
import mockit.Mock;
import mockit.MockUp;
import mockit.Mocked;
import org.apache.ibatis.jdbc.ScriptRunner;
import org.apache.shiro.authz.aop.PermissionAnnotationHandler;
import org.junit.ClassRule;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.BeforeEach;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.transaction.annotation.Transactional;
import org.testcontainers.containers.GenericContainer;
import org.testcontainers.containers.wait.strategy.Wait;
import org.testcontainers.images.builder.ImageFromDockerfile;

import javax.annotation.Resource;
import javax.servlet.http.HttpServletRequest;
import javax.sql.DataSource;
import java.io.FileReader;

@SpringBootTest(classes = {OaApplication.class}, webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@Transactional
@Slf4j
public class BaseTest {

    @ClassRule
    public static GenericContainer mysql = new VvFixedHostPortGenericContainer(
            new ImageFromDockerfile(&quot;mysql-vv-gms&quot;)
                    .withDockerfileFromBuilder(dockerfileBuilder -&amp;gt; {
                        dockerfileBuilder.from(&quot;mysql:8.0.0&quot;)
                                .env(&quot;MYSQL_ROOT_PASSWORD&quot;, &quot;test&quot;)
                                .env(&quot;MYSQL_DATABASE&quot;, &quot;test&quot;)
                                .env(&quot;MYSQL_USER&quot;, &quot;test&quot;)
                                .env(&quot;MYSQL_PASSWORD&quot;, &quot;test&quot;)
                                .add(&quot;my.cnf&quot;, &quot;/etc/mysql/conf.d&quot;)
                                .add(&quot;db-schema.sql&quot;, &quot;/docker-entrypoint-initdb.d&quot;)
                        ;
                    })
                    .withFileFromClasspath(&quot;my.cnf&quot;, &quot;my.cnf&quot;)
                    .withFileFromClasspath(&quot;db-schema.sql&quot;, &quot;db-schema.sql&quot;)
    )
            .withFixedExposedPort(3307, 3306)
            .waitingFor(Wait.forListeningPort());

    @Resource
    protected DataSource dataSource;

    @Mocked
    PermissionAnnotationHandler permissionAnnotationHandler;
    @Mocked
    cn.vv.fw.boot.logger.RequestLogAspect RequestLogAspect;
    @Mocked
    TokenAuthorFilters tokenAuthorFilters;
    @Mocked
    HttpServletRequest getRequest;

    @BeforeAll
    protected static void beforeAll() {
        mysql.start();

        System.setProperty(&quot;spring.datasource.url&quot;, &quot;jdbc:mysql://&quot; + mysql.getContainerIpAddress() + &quot;:3307/test?useUnicode=true&amp;amp;characterEncoding=utf-8&amp;amp;serverTimezone=GMT%2b8&quot;);
        System.setProperty(&quot;spring.datasource.driver-class-name&quot;, &quot;com.mysql.cj.jdbc.Driver&quot;);
        System.setProperty(&quot;spring.datasource.username&quot;, &quot;test&quot;);
        System.setProperty(&quot;spring.datasource.password&quot;, &quot;test&quot;);

        new MockUp&amp;lt;ShiroUtils&amp;gt;(ShiroUtils.class) {
            @Mock
            public EmployeeVO getEmployee() {
                EmployeeVO employeeVO = new EmployeeVO();
                employeeVO.setUserName(&quot;mock.UserName&quot;);
                employeeVO.setUserNo(&quot;mock.UserNo&quot;);
                employeeVO.setCompanyName(&quot;mock.CompanyName&quot;);
                employeeVO.setDepartmentName(&quot;mock.DepartmentName&quot;);
                return employeeVO;
            }
        };
        new MockUp&amp;lt;LogAspect&amp;gt;(LogAspect.class) {
            @Mock
            public String getIp() {
                return &quot;mock.ip&quot;;
            }
        };
    }

    @AfterAll
    protected static void destroy() {
        mysql.stop();
    }

    @BeforeEach
    protected void beforeEach() {

        new MockUp&amp;lt;WebUtil&amp;gt;(WebUtil.class) {
            @Mock
            public HttpServletRequest getRequest() {
                return getRequest;
            }

            @Mock
            public VvCurrentAccount getCurrentAccount(Boolean isMustLogin) {
                VvCurrentAccount vvCurrentAccount = new VvCurrentAccount();
                vvCurrentAccount.setUserCode(&quot;mock.userCode&quot;);
                return vvCurrentAccount;
            }
        };
        new MockUp&amp;lt;ServletUtils&amp;gt;(ServletUtils.class) {
            @Mock
            public HttpServletRequest getRequest() {
                return getRequest;
            }
        };


        if (StringUtil.isNotBlank(this.getDbScript())) {
            try {
                ScriptRunner runner = new ScriptRunner(dataSource.getConnection());
                runner.setErrorLogWriter(null);
                runner.setLogWriter(null);
                runner.runScript(new FileReader(this.getClass().getResource(this.getDbScript()).getPath()));
            } catch (Exception e) {
                log.error(&quot;ScriptRunner error!&quot;, e);
            }
        }
    }

    @AfterEach
    protected void afterEach() {
    }

    protected String getDbScript() {
        return &quot;&quot;;
    }

}

&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;实现实例&quot;&gt;实现实例&lt;/h2&gt;
&lt;p&gt;以实际的公司的接口为例，我们的单元测试入口从Controller方法进入。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package cn.vv.oa.module.org.controller;

import cn.vv.fw.common.api.R;
import cn.vv.oa.BaseTest;
import cn.vv.oa.api.org.dto.CompanyDTO;
import cn.vv.oa.module.org.entity.Company;
import cn.vv.oa.module.org.repository.mapper.CompanyMapper;
import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;
import org.junit.jupiter.api.Test;

import javax.annotation.Resource;
import java.math.BigInteger;
import java.time.LocalDate;
import java.util.Arrays;
import java.util.List;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.assertEquals;

public class CompanyControllerTest extends BaseTest {

    @Resource
    CompanyController companyController;

    @Resource
    CompanyMapper companyMapper;

    @Test
    public void getList() throws Exception {
        List dtos = companyController.getList(&quot;100&quot;, &quot;&quot;).getData();
        assertEquals(((Map) (dtos.get(0))).get(&quot;companyName&quot;), &quot;VV科技集团&quot;);
    }

    @Test
    void getAllList() {
        List&amp;lt;Company&amp;gt; list = companyMapper.selectList(new LambdaQueryWrapper&amp;lt;Company&amp;gt;());
        assertEquals(list.size(), 3);
    }


    @Test
    void saveOrUpdate() throws Exception {
        CompanyDTO companyDTO = CompanyDTO.builder()
                .companyName(&quot;VV日本公司&quot;)
                .parentId(new BigInteger(&quot;100&quot;))
                .companyEmail(&quot;vvadmin@vv.co.jp&quot;)
                .companyArea(Arrays.asList(&quot;Japan&quot;))
                .regTime(LocalDate.now())
                .build();

        R r = companyController.saveOrUpdate(companyDTO);

        List&amp;lt;Company&amp;gt; list = companyMapper.selectList(new LambdaQueryWrapper&amp;lt;Company&amp;gt;());
        assertEquals(list.size(), 4);

    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个单元测试会覆盖到controller、service、dao的各层代码。可以看到由Spring负责注入的还是使用原本的方式。&lt;br/&gt;这里要注意点在于单元测试的待测试方法调用后，由于我们需要通过落地数据来验证，所以还需要注入对应的Mapper直接对数据库进行搜索。这点会有些绕或者不直接。&lt;br/&gt;这是一个穿透的例子。我们再来看一个隔离的例子。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
    @Test
    void save() {
        R&amp;lt;AccountSimpleVO&amp;gt; r = new R&amp;lt;&amp;gt;();
        AccountSimpleVO accountSimpleVO = new AccountSimpleVO();
        accountSimpleVO.setUserCode(&quot;usercode&quot;);
        r.setCode(ResultCode.SUCCESS.getCode());
        r.setData(accountSimpleVO);

        new Expectations() {{
            userMapper.selectList((Wrapper&amp;lt;User&amp;gt;) any);
            result = null;

            userClient.getUserInfo((AccountDTO) any);
            result = null;

            userClient.registered((AccountDTO) any);
            result = r;

            companyMapper.selectOne((Wrapper&amp;lt;Company&amp;gt;) any);
            Company company = new Company();
            company.setCompanyArea(&quot;中国&quot;);
            result = company;
        }};

        new MockUp&amp;lt;DictUtil&amp;gt;(DictUtil.class) {
            @Mock
            public Map&amp;lt;String, DictDTO&amp;gt; getDictNameMap(String code) {
                Map&amp;lt;String, DictDTO&amp;gt; r1 = new HashMap&amp;lt;&amp;gt;();
                DictDTO dictDTO = new DictDTO();
                dictDTO.setRemark(&quot;30&quot;);
                r1.put(&quot;美国&quot;, dictDTO);
                return r1;
            }

            @Mock
            public Map&amp;lt;String, DictDTO&amp;gt; getDictMap(String code) {
                Map&amp;lt;String, DictDTO&amp;gt; r2 = new HashMap&amp;lt;&amp;gt;();
                DictDTO dictDTO = new DictDTO();
                dictDTO.setRemark(&quot;86&quot;);
                r2.put(&quot;中国&quot;, dictDTO);
                return r2;
            }

        };

        Assertions.assertThrows(NullPointerException.class, () -&amp;gt; {
            employeeService.save(new EmployeeDTO());
        });
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个例子就是单独测试了一个service方法，可以看到mock了很多内外部的服务，包括底层的mapper都mock了，意味着数据读取返回的内容都已经完全隔离了。&lt;/p&gt;

&lt;p&gt;单元测试，大家都有共识是代码质量的最重要的手段之一，但是我们需要真正“&lt;strong&gt;有价值&lt;/strong&gt;”的单元测试。有价值意味着真正维护了项目质量，也能够让研发愿意真正花费精力来编写和维护测试用例。如果公司只看单元测试覆盖率，实际上也是很好糊弄的，这就变成面子而没有价值。研发去编写单元测试只是为了绩效，高覆盖率，没有为项目质量提升贡献力量。&lt;br/&gt;如果正在看这篇文章的你是一个Leader，那你一定是要亲身上阵，带领团队认真的实施，引导团队真正理解单元测试的写法与价值。&lt;br/&gt;我们的团队也还在进行尝试，在我们的测试中，产生有价值的单元测试，代码量是实际业务代码的2-3倍。而且在业务不稳定的时候，业务代码的维护同时还引发单元测试代码的修改，改代码的效率是写代码效率的一半，成本是很高的。&lt;/p&gt;
</description>
<pubDate>Wed, 01 Apr 2020 00:56:00 +0000</pubDate>
<dc:creator>陈晨_软件五千言</dc:creator>
<og:description>[TOC] 背景 之前整理过一篇，基于（SpringCloud+Junit5+Mockito+DataMocker）的框架整理的单元测试。当时的项目是一个编排层的服务项目，所以没有涉及到数据库或者其他</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/pluto4596/p/12610333.html</dc:identifier>
</item>
<item>
<title>类与结构体性能对比测试——以封装网络心跳包为例 - JerryMouseLi</title>
<link>http://www.cnblogs.com/JerryMouseLi/p/12610332.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JerryMouseLi/p/12610332.html</guid>
<description>&lt;p&gt;接上篇文章&lt;a href=&quot;https://www.cnblogs.com/JerryMouseLi/p/12606920.html&quot;&gt;深入浅出C#结构体——封装以太网心跳包的结构为例&lt;/a&gt;,使用结构体性能不佳，而且也说明了原因。本篇文章详细描述了以类来封装网络心跳包的优缺点，结果大大提升了解析性能。&lt;/p&gt;

&lt;h2 id=&quot;21优点&quot;&gt;2.1.优点&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;可以在类里直接new byte[]，即直接实例字节数组，然后写初始化方法或者构造函数中直接对传进来的缓存进行拷贝赋值；&lt;/li&gt;
&lt;li&gt;无需装箱拆箱；&lt;/li&gt;
&lt;li&gt;类属于引用类型，无需像结构体进行值拷贝，底层直接就是智能指针；&lt;/li&gt;
&lt;li&gt;智能指针指向同一片内存，省内存空间；&lt;/li&gt;
&lt;li&gt;可以在类里写很多方便的方法，这也就是面向对象，面向领域的基石，方便以后扩展；&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;22缺点&quot;&gt;2.2.缺点&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;存在堆里，读取性能会比栈稍差（现在PC端的计算速度很快，基本可忽略不计）；&lt;/li&gt;
&lt;li&gt;虽然类也属于GC的托管资源，但是GC什么时候进行自动回收不可控制，需要实现IDisposable接口，用完该类，手动对该类进行释放动作；&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;使用类的实际性能怎样，我们用测试数据说话，后面会放上与结构体测试的性能对比数据。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这里全部都命名成了字节数组，包括 public byte[] type=new byte[1];因为如果是byte type类型，我不知道如何去释放这一值类型，怕到时候引起内存泄露等问题。然后在构造函数里面将缓存buf拷贝到了类的各个属性中，就是这么简单。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public class TcpHeartPacketClass: BaseDisposable
    {
        private bool _disposed; //表示是否已经被回收
        public TcpHeartPacketClass(byte[] buf)
        {
            Buffer.BlockCopy(buf, 0, head, 0, 4);
            type[0] = buf[4];
            Buffer.BlockCopy(buf, 4, length, 0, 2);
            Buffer.BlockCopy(buf, 6, Mac, 0, 6);
            Buffer.BlockCopy(buf, 12, data, 0, 104);
            Buffer.BlockCopy(buf, 116, tail, 0, 4);
        }
        protected override void Dispose(bool disposing)
        {
            if (!_disposed) //如果还没有被回收
            {
                if (disposing) //如果需要回收一些托管资源
                {
                    //TODO:回收托管资源，调用IDisposable的Dispose()方法就可以
                    
                }
                //TODO：回收非托管资源，把之设置为null，等待CLR调用析构函数的时候回收
                head = null;
                type = null;
                length = null;
                Mac = null;
                data = null;
                tail = null;

                _disposed = true;

            }
            base.Dispose(disposing);//再调用父类的垃圾回收逻辑
        }

        public byte[] head=new byte[4];

        public byte[] type=new byte[1];

        public byte[] length = new byte[2];

        public byte[] Mac = new byte[6];

        public byte[] data = new byte[104];//数据体

        public byte[] tail = new byte[4];
    }  
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;用完类之后，为了主动去释放类，我封装了一个释放基类BaseDisposable。详见代码注释，有不明白的地方可以在评论区提问，我会详细作答。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public class BaseDisposable : IDisposable
    {
        ~BaseDisposable()
        {
            //垃圾回收器将调用该方法，因此参数需要为false。
            Dispose(false);
        }

        /// &amp;lt;summary&amp;gt;
        /// 是否已经调用了 Dispose(bool disposing)方法。
        ///     应该定义成 private 的，这样可以使基类和子类互不影响。
        /// &amp;lt;/summary&amp;gt;
        private bool disposed = false;

        /// &amp;lt;summary&amp;gt;
        /// 所有回收工作都由该方法完成。
        ///     子类应重写(override)该方法。
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;disposing&quot;&amp;gt;&amp;lt;/param&amp;gt;
        protected virtual void Dispose(bool disposing)
        {
            // 避免重复调用 Dispose 。
            if (!disposed) return;

            // 适应多线程环境，避免产生线程错误。
            lock (this)
            {
                if (disposing)
                {
                    // ------------------------------------------------
                    // 在此处写释放托管资源的代码
                    // (1) 有 Dispose() 方法的，调用其 Dispose() 方法。
                    // (2) 没有 Dispose() 方法的，将其设为 null。
                    // 例如：
                    //     xxDataTable.Dispose();
                    //     xxDataAdapter.Dispose();
                    //     xxString = null;
                    // ------------------------------------------------
                }

                // ------------------------------------------------
                // 在此处写释放非托管资源
                // 例如：
                //     文件句柄等
                // ------------------------------------------------
                disposed = true;
            }
        }

        /// &amp;lt;summary&amp;gt;
        /// 该方法由程序调用，在调用该方法之后对象将被终结。
        ///     该方法定义在IDisposable接口中。
        /// &amp;lt;/summary&amp;gt;
        public void Dispose()
        {
            //因为是由程序调用该方法的，因此参数为true。
            Dispose(true);
            //因为我们不希望垃圾回收器再次终结对象，因此需要从终结列表中去除该对象。
            GC.SuppressFinalize(this);
        }

        /// &amp;lt;summary&amp;gt;
        /// 调用 Dispose() 方法，回收资源。
        /// &amp;lt;/summary&amp;gt;
        public void Close()
        {
            Dispose();
        }
    }
&lt;/code&gt;
&lt;/pre&gt;

&lt;pre&gt;
&lt;code&gt;    DateTime packetClassStart = DateTime.Now;

    TcpHeartPacketClass tcpHeartPacketClass = neTcpHeartPacketClass(ReceviveBuff);

    DateTime packetClassEnd = DateTime.Now;
    TimeSpan toClassTs = packetClassEnd.Subtra(packetClassStart);
    try
    {
    tcpHeartPacketClass.head[0] = 0x11;
    
    LoggerHelper.Info(&quot;类中的包头：&quot; + BitConverteToString(tcpHeartPacketClass.head));
    Console.WriteLine(&quot;类中的包头：{0}&quot;, BitConverteToString(tcpHeartPacketClass.head));

    LoggerHelper.Info(&quot;类中的包类型：&quot; tcpHeartPacketClass.type.ToString());
    Console.WriteLine(&quot;类中的包类型：{0}&quot;tcpHeartPacketClass.type.ToString());

    LoggerHelper.Info(&quot;类中的包长度：&quot; + BitConverteToString(tcpHeartPacketClass.length));
    Console.WriteLine(&quot;类中的包长度：{0}&quot;, BitConverteToString(tcpHeartPacketClass.length));

    LoggerHelper.Info(&quot;类中的MAC地址：&quot; + BitConverteToString(tcpHeartPacketClass.Mac));
    Console.WriteLine(&quot;类中的MAC地址：{0}&quot;, BitConverteToString(tcpHeartPacketClass.Mac));

    LoggerHelper.Info(&quot;类中的注册包内容：&quot; + BitConverteToString(tcpHeartPacketClass.data));
    Console.WriteLine(&quot;类中的注册包内容：{0}&quot;BitConverter.ToString(tcpHeartPacketClass.data));

    LoggerHelper.Info(&quot;类中的包尾：&quot; + BitConverteToString(tcpHeartPacketClass.tail));
    Console.WriteLine(&quot;类中的包尾：{0}&quot;, BitConverteToString(tcpHeartPacketClass.tail));

    Console.WriteLine(&quot;字节数组类中分割总共花费{0}ms\n&quot;toClassTs.TotalMilliseconds);
    }
    finally
    {
        IDisposable disposable = tcpHeartPacketClass as IDisposable;
        if (disposable != null)
            disposable.Dispose();
    }
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;在ty...finally块执行完Dispose()方法之后，再去给类的某个属性赋值，我们看是否报错，如果报错赋值给空对象则证明释放成功。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    finally
    {
        IDisposable disposable = tcpHeartPacketClass        IDisposable;
        if (disposable != null)
            disposable.Dispose();
    }
    tcpHeartPacketClass.head[0] = 0x12;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如下报错，翻译过来意思就是对象引用没有对应的实例，也就是被我们给释放掉了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1606616/202004/1606616-20200401085512474-787217919.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1606616/202004/1606616-20200401085429862-1960747615.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过上图可以看到，上面的类解析的是微秒级别的，而文章&lt;a href=&quot;https://www.cnblogs.com/JerryMouseLi/p/12606920.html&quot;&gt;深入浅出C#结构体——封装以太网心跳包的结构为例&lt;/a&gt;解析的是几十微秒级别的，差了差不多5到10倍的性能。&lt;/p&gt;
&lt;p&gt;由此可见，在这种应用场景下，使用类来封装网络心跳包比结构体封装更合理。&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;数据长度很短，构造16字节以下的新类型，而且结构体内的子类型必须是值类型，不然没意义，其目的是为了适应栈上的高效读取；&lt;/li&gt;
&lt;li&gt;为了兼容一些来自C跟C++的库；&lt;br/&gt;避开以上两点，我认为在C#新开发的应用程序中，可以完全的用类来取代结构体（仅代表个人观点）。&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;
版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。
&lt;p&gt;本文链接：&lt;a href=&quot;https://www.cnblogs.com/JerryMouseLi/p/12610332.html&quot;&gt;https://www.cnblogs.com/JerryMouseLi/p/12610332.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 01 Apr 2020 00:56:00 +0000</pubDate>
<dc:creator>JerryMouseLi</dc:creator>
<og:description>[toc] 1.背景 接上篇文章 &amp;quot;深入浅出C 结构体——封装以太网心跳包的结构为例&amp;quot; ,使用结构体性能不佳，而且也说明了原因。本篇文章详细描述了以类来封装网络心跳包的优缺点，结果</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/JerryMouseLi/p/12610332.html</dc:identifier>
</item>
<item>
<title>我们是怎么实现gRPC CodeFirst-生成proto - RabbitYi</title>
<link>http://www.cnblogs.com/rabbityi/p/12605202.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rabbityi/p/12605202.html</guid>
<description>&lt;p&gt;&lt;strong&gt;前言:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;gRPC默认是ProtoFirst的，即先写 proto文件，再生成代码，需要人工维护proto，生成的代码也不友好，所以出现了gRPC CodeFirst，下面来说说我们是怎么实现gRPC CodeFirst&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;目录：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现和WCF一样的CodeFirst&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(1). &lt;a href=&quot;https://www.cnblogs.com/rabbityi/p/12593922.html&quot; target=&quot;_blank&quot;&gt;实现&lt;strong&gt;gRPC &lt;/strong&gt;CodeFirst, &lt;strong&gt; 简化WCF一定要抽取接口的问题&lt;/strong&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(2). &lt;a href=&quot;https://www.cnblogs.com/rabbityi/p/12605202.html&quot; target=&quot;_blank&quot;&gt;通过代码生成proto和注释，给第三方语言使用&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(3). 实现gRPC DashBoard，用于Http远程调用和管理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(4). 实现服务注册与发现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(5). 实现分布式日志跟踪&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(6). 日志监控等等&lt;/strong&gt;&lt;/p&gt;


&lt;h2&gt;&lt;strong&gt;我们是怎么实现gRPC CodeFirst-生成proto&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.怎么根据代码生成Proto，上文我们调用了GrpcMethodHelper.AutoRegisterMethod()方法，这是通过反射自动注册GrpcMethod的方法&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(1).这里面调用了一个BuildMethod方法，用于生成grpc的序列化和反序列化的委托&lt;/p&gt;
&lt;p&gt;(2).同时可以收集grpc方法和参数的信息，用于生成proto&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    ///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 生成Grpc方法（CodeFirst方式）
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;TRequest&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;TResponse&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;srv&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;methodName&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;package&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;srvName&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;mType&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Method&amp;lt;TRequest, TResponse&amp;gt; BuildMethod&amp;lt;TRequest, TResponse&amp;gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IGrpcService srv,
        &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; methodName, &lt;span&gt;string&lt;/span&gt; package = &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt; srvName = &lt;span&gt;null&lt;/span&gt;, MethodType mType =&lt;span&gt; MethodType.Unary)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; serviceName = srvName ??&lt;span&gt;
                          GrpcExtensionsOptions.Instance.GlobalService &lt;/span&gt;??&lt;span&gt;
                          srv.GetType().Name;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; pkg = package ??&lt;span&gt; GrpcExtensionsOptions.Instance.GlobalPackage;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrWhiteSpace(pkg))
        {
            serviceName &lt;/span&gt;= $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{pkg}.{serviceName}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;#region&lt;/span&gt; 为生成proto收集信息
        &lt;span&gt;if&lt;/span&gt; (!(srv &lt;span&gt;is&lt;/span&gt; IGrpcBaseService) ||&lt;span&gt; GrpcExtensionsOptions.Instance.GenBaseServiceProtoEnable)
        {
            ProtoInfo.Methods.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ProtoMethodInfo
            {
                ServiceName &lt;/span&gt;=&lt;span&gt; serviceName,
                MethodName &lt;/span&gt;=&lt;span&gt; methodName,
                RequestName &lt;/span&gt;= &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(TRequest).Name,
                ResponseName &lt;/span&gt;= &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(TResponse).Name,
                MethodType &lt;/span&gt;=&lt;span&gt; mType
            });
            ProtoGenerator.AddProto&lt;/span&gt;&amp;lt;TRequest&amp;gt;(&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(TRequest).Name);
            ProtoGenerator.AddProto&lt;/span&gt;&amp;lt;TResponse&amp;gt;(&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(TResponse).Name);
        }
        &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; request = Marshallers.Create&amp;lt;TRequest&amp;gt;((arg) =&amp;gt; ProtobufExtensions.Serialize&amp;lt;TRequest&amp;gt;(arg), data =&amp;gt; ProtobufExtensions.Deserialize&amp;lt;TRequest&amp;gt;&lt;span&gt;(data));
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; response = Marshallers.Create&amp;lt;TResponse&amp;gt;((arg) =&amp;gt; ProtobufExtensions.Serialize&amp;lt;TResponse&amp;gt;(arg), data =&amp;gt; ProtobufExtensions.Deserialize&amp;lt;TResponse&amp;gt;&lt;span&gt;(data));
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Method&amp;lt;TRequest, TResponse&amp;gt;&lt;span&gt;(mType, serviceName, methodName, request, response);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.不重复造轮子，通过protobuf-net的Serializer.GetProto()来生成请求参数和返回参数的proto&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;(1).这里简单过滤了重复的proto，但GetProto()会把依赖的类都生成proto，这样公用类就会生成多份，需要再次过滤重复即可&lt;/p&gt;
&lt;p&gt;(2).生成message非关键代码这里我就不列出来了，都是字符串拼接的活&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    /&lt;span&gt;//&lt;/span&gt;&lt;span&gt; &amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 添加proto
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; AddProto&amp;lt;TEntity&amp;gt;(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; entityName)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;ProtoMethodInfo.Protos.ContainsKey(entityName))
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; msg = Serializer.GetProto&amp;lt;TEntity&amp;gt;&lt;span&gt;(ProtoBuf.Meta.ProtoSyntax.Proto3);
            ProtoMethodInfo.Protos.TryAdd(entityName, msg.FilterHead().AddMessageComment&lt;/span&gt;&amp;lt;TEntity&amp;gt;&lt;span&gt;());
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.服务方法的proto就更简单了，直接根据方法类型拼出来即可&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 生成grpc的service的proto内容
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; GenGrpcServiceProto(&lt;span&gt;string&lt;/span&gt; msgProtoName, &lt;span&gt;string&lt;/span&gt; pkgName, &lt;span&gt;string&lt;/span&gt; srvName, List&amp;lt;ProtoMethodInfo&amp;gt; methodInfo, &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; spiltProto)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; sb = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuilder();
        sb.AppendLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;syntax = \&quot;proto3\&quot;;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrWhiteSpace(GrpcExtensionsOptions.Instance.ProtoNameSpace))
        {
            sb.AppendLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;option csharp_namespace = \&quot;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + GrpcExtensionsOptions.Instance.ProtoNameSpace.Trim() + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\&quot;;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrWhiteSpace(pkgName))
        {
            sb.AppendLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;package {pkgName.Trim()};&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (spiltProto)
        {
            sb.AppendLine(&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;import \&quot;{0}\&quot;;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, msgProtoName));
        }
        sb.AppendLine(Environment.NewLine);
        sb.AppendLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;service &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + srvName + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; template = &lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;   rpc {0}({1}) returns({2})&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        methodInfo.ForEach(q &lt;/span&gt;=&amp;gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; requestName =&lt;span&gt; q.RequestName;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; responseName =&lt;span&gt; q.ResponseName;
            &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (q.MethodType)
            {
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; Core.MethodType.Unary:
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; Core.MethodType.ClientStreaming:
                    requestName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;stream &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; requestName;
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; Core.MethodType.ServerStreaming:
                    responseName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;stream &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; responseName;
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; Core.MethodType.DuplexStreaming:
                    requestName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;stream &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; requestName;
                    responseName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;stream &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; responseName;
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
            ProtoCommentGenerator.AddServiceComment(q,sb);
            sb.AppendLine(&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;.Format(template, q.MethodName, requestName, responseName) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; Environment.NewLine);
        });

        sb.AppendLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; sb.ToString();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;4.生成 proto没有注释，第三方对接时就尴尬了，虽然命名规范，但注释还是要有的，减少沟通成本&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(1).我们通过在类和方法上加入注释，然后项目里设置生成xml注释文档&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(2).生成proto时通过扫描xml注释文档来给proto加入注释即可&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;未完，待续，欢迎评论拍砖&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这些功能早在2018年就已经实现并运行在生产，感兴趣的同学可以去 &lt;a href=&quot;https://github.com/yileicn/Grpc.Extensions&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;github(grpc.extensions) &lt;/span&gt;&lt;/a&gt;上查看，你要的都有，欢迎提issue&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 01 Apr 2020 00:47:00 +0000</pubDate>
<dc:creator>RabbitYi</dc:creator>
<og:description>前言: gRPC默认是ProtoFirst的，即先写&amp;#160;proto文件，再生成代码，需要人工维护proto，生成的代码也不友好，所以出现了gRPC CodeFirst，下面来说说我们是怎么实现</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/rabbityi/p/12605202.html</dc:identifier>
</item>
<item>
<title>设计模式-代理模式 - muggle1</title>
<link>http://www.cnblogs.com/muggle0/p/12610284.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/muggle0/p/12610284.html</guid>
<description>&lt;p&gt;代理模式的定义：由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。&lt;/p&gt;
&lt;p&gt;代理模式的主要优点有：&lt;br/&gt;代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；&lt;br/&gt;代理对象可以扩展目标对象的功能；&lt;br/&gt;代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度；&lt;/p&gt;
&lt;p&gt;其主要缺点是：&lt;br/&gt;在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；&lt;br/&gt;增加了系统的复杂度；&lt;/p&gt;
&lt;h2 id=&quot;模式结构&quot;&gt;模式结构&lt;/h2&gt;
&lt;p&gt;代理模式的主要角色如下。&lt;br/&gt;抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。&lt;br/&gt;真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。&lt;br/&gt;代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。&lt;/p&gt;
&lt;h2 id=&quot;源码导读&quot;&gt;源码导读&lt;/h2&gt;
&lt;p&gt;在代理模式中动态代理是在各个框架中使用最广泛的一种设计模式，dubbo中 feign中 mybaits中，都有使用到动态代理。在dubbo中，在接口上添加@refrence ，dubbo就会根据这个接口生成一个代理实例来供消费者用生产者。在feign中也是一样；mybatis中你只要指定包扫描的路径，就会在spring中注入一个mapper，实际上这个mapper就是根据接口和xml生成的代理对象。实际上，这种“申明式的”功能实现方式，都是通过代理模式来实现的。&lt;/p&gt;
&lt;p&gt;下面我们通过cglib来写一个“残疾缩水”版的mybatis：&lt;/p&gt;
&lt;p&gt;首先要整一个xml，我这里用properties代替&lt;/p&gt;
&lt;p&gt;test.properties:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-properties&quot;&gt;testA=select * from user where id=
testB=select * from user where username=
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再整一个接口：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;  interface Test {

    String testA(int id);
    String testB(String username);
}  

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再是代码增强处理器，这里面完成对接口的代理逻辑&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;class MyInvokationHandler implements MethodInterceptor {

    private static Map&amp;lt;String,String&amp;gt; sqlMap;

    {
        HashMap&amp;lt;String, String&amp;gt; map = new HashMap&amp;lt;&amp;gt;();



        Properties prop = new Properties();
        InputStream in = SystemMenuController.class.getClassLoader().getResourceAsStream(&quot;test.properties&quot;);
        try {
            prop.load(in);
            Iterator&amp;lt;String&amp;gt; it = prop.stringPropertyNames().iterator();
            while (it.hasNext()) {
                String key = it.next();
                map.put(key,prop.getProperty(key));
            }
            in.close();
        } catch (java.io.IOException e) {
            e.printStackTrace();
        }
        sqlMap=map;
    }


    @Override
    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
        String name = method.getName();
        String s = sqlMap.get(name);
        return s+objects[0];
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;包扫描和启动时注入容器略，数据源也略,用个main方法模拟一下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
  public static void main(String[] args) {

        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(Test.class);
        enhancer.setCallback(new MyInvokationHandler());
        Test test = (Test) enhancer.create();
        System.out.println(test.testA(1));
         System.out.println(test.testB(&quot;hhh&quot;));
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终在控制台中打印：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;select * from user where id=1
select * from user where id=hhh
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代理模式是一个很强大实用性很强的模式，动态代理大大减少了我们的开发任务，同时减少了对业务接口的依赖，降低了耦合度。代理模式的使用场景可以总结为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;远程代理，这种方式通常是为了隐藏目标对象存在于不同地址空间的事实，方便客户端访问。例如，用户申请某些网盘空间时，会在用户的文件系统中建立一个虚拟的硬盘，用户访问虚拟硬盘时实际访问的是网盘空间。&lt;/li&gt;
&lt;li&gt;虚拟代理，这种方式通常用于要创建的目标对象开销很大时。例如，下载一幅很大的图像需要很长时间，因某种计算比较复杂而短时间无法完成，这时可以先用小比例的虚拟代理替换真实的对象，消除用户对服务器慢的感觉。&lt;/li&gt;
&lt;li&gt;安全代理，这种方式通常用于控制不同种类客户对真实对象的访问权限。&lt;/li&gt;
&lt;li&gt;智能指引，主要用于调用目标对象时，代理附加一些额外的处理功能。例如，增加计算真实对象的引用次数的功能，这样当该对象没有被引用时，就可以自动释放它。&lt;/li&gt;
&lt;li&gt;延迟加载，指为了提高系统的性能，延迟对目标的加载。例如，Hibernate 中就存在属性的延迟加载和关联表的延时加载。&lt;br/&gt;&lt;a href=&quot;https://muggle.javaboy.org/2019/03/20/home/&quot;&gt;点击关注我的博客&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Wed, 01 Apr 2020 00:47:00 +0000</pubDate>
<dc:creator>muggle1</dc:creator>
<og:description>代理模式的定义：由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。 代理模式的主要优点有： 代理模式在客</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/muggle0/p/12610284.html</dc:identifier>
</item>
<item>
<title>如何用爬虫抓取招聘网站的职位并分析 - 渡码</title>
<link>http://www.cnblogs.com/duma/p/12609489.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/duma/p/12609489.html</guid>
<description>&lt;p&gt;&lt;span&gt;最近有不少程序员又开始找工作了，为了了解目前技术类各职位的数量、薪资、招聘公司、岗位职责及要求，我爬取了拉勾网北上广深4个城市的招聘数据，共3w条。职位包括：人工智能（AI）、大数据、数据分析、后端（Java、C|C++、PHP、Python）、前端、Android、iOS、嵌入式和测试。下面我将分两部分进行介绍，第一部分是数据抓取；第二部分是数据分析。如需源代码在公众号（见文末）回复关键字 &lt;span&gt;职位&lt;/span&gt; 即可。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;这里我并不是通过传统的抓网页，解析HTML代码的方式爬取数据，而是用 Charles 软件抓取拉钩APP请求数据的接口实现。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;大概的流程&lt;/strong&gt;是启动Charles -&amp;gt; 手机连接Charles代理（二者需处于同一个局域网）-&amp;gt; 打开APP请求数据-&amp;gt;观察Charles截的包，从中找到我们想要的接口&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先，找到搜索职位的接口&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/v1/entry/positionsearch/searchPosition&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这是一个 POST 请求，我们还要找到请求的 header 和 body，最关键的 header 和 body 如下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;header：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&lt;span&gt;'X-L-REQ-HEADER': '{&quot;deviceType&quot;:150,&quot;userType&quot;:0,&quot;lgId&quot;:&quot;11835BCC-8815-456A-A094-64FB2B9323EF_1585362240&quot;,&quot;reqVersion&quot;:73600,&quot;appVersion&quot;:&quot;7.36.0&quot;,&quot;userToken&quot;:&quot;xxx&quot;}'
'content-type': &quot;application/json&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;其中，userToken字段每个不一样，需要自己抓包确定&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;body&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;56&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&lt;span&gt;{&quot;tagType&quot;: &quot;&quot;, &quot;isAd&quot;: &quot;1&quot;, &quot;showId&quot;: &quot;&quot;, &quot;district&quot;: &quot;&quot;, &quot;keywordSource&quot;: 0, &quot;keyword&quot;: &quot;数据开发&quot;,
                &quot;salaryUpper&quot;: 0, &quot;hiTag&quot;: &quot;&quot;, &quot;longitudeAndLatitude&quot;: &quot;-1.000000,-1.000000&quot;, &quot;pageNo&quot;: 1, &quot;sort&quot;: 0,
                &quot;pageSize&quot;: 15, &quot;refreshHiTagList&quot;: True, &quot;lastShowCompanyId&quot;: 0, &quot;nearByKilometers&quot;: &quot;&quot;, &quot;city&quot;: &quot;北京&quot;,
                &quot;businessZone&quot;: &quot;&quot;, &quot;shieldDeliveyCompany&quot;: False, &quot;salaryLower&quot;: 0, &quot;subwayLineName&quot;: &quot;&quot;,
                &quot;subwayStation&quot;: &quot;&quot;}　　&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;其中，我们只需要关注 keyword，pageNo，pageSize字段，分别代表搜索什么职位，搜索第几页，每页搜多少条。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有了这个信息我们就可以通过程序来请求不同的职位数据，同时为了获取职位更详细的信息我们还可以查找获取职位详情页的接口，方式与此类似，这里就不再赘述了。请求职位的代码如下&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
&lt;span&gt;def get_data(self):
        for city in self.cities_conf:
            for position in self.positions_conf:

                self.position_search_body['keyword'] = position
                self.position_search_body['city'] = city

                pageNo = 1
                has_more = 1
                while has_more:
                    try:
                        self.position_search_body['pageNo'] = pageNo
                        url = 'https://gate.lagou.com/v1/entry/positionsearch/searchPosition'
                        res = requests.post(url, data=json.dumps(self.position_search_body), headers=self.headers)
                        print('成功爬取%s市-%s职位的第%d页数据！' % (city, position, pageNo))
                        item = {'city': city, 'pType': position}
                        print(res.json())
                        positionCardVos = res.json()['content']['positionCardVos']
                        self._parse_record(positionCardVos, item)

                        pageNo += 1
                        if positionCardVos is None or len(positionCardVos) &amp;lt; 15:
                            has_more = 0

                        time.sleep(random.random() * 5)
                    except Exception as e:
                        msg = '链接访问不成功，正在重试！Exception: %s' % e
                        print(msg)
                        time.sleep((1 + random.random()) * 10)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;变量 position 代表不同的职位，这里请求的时候会加随机停留时间，目的为了防止请求过于平凡。&lt;span&gt;我们抓去别人的数据应该注意这一点，不能恶意爬别人的数据。应该模拟得更像普通人一样去请求数据，如果请求过于频繁导致别人服务出现问题那真实罪大恶极。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;_parse_record 方法是解析请求的数据，并存入mongo。首先解析数据没什么好说的，就是解析json而已。&lt;/span&gt;&lt;span&gt;简单说下为什么存入mongo，第一，解析的json数据，mongo存储就是用json格式，读取和写入非常方便；第二，mongo不用提前设计表Schema，对我们这种临时性和不确定性的分析带来方便；第三，mongo可以存储海量的数据；第四，mongo会缓存热点数据，我们在后续分析时候读取会非常快。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;_parse_record 方法代码如下，为了避免啰嗦，我只保留部分字段的解析，其他的代码可以下载详细代码来看&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;45&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
&lt;span&gt;def _parse_record(self, data, item):
        if data:
            for position in data:
                item['pId'] = position.get('positionId')
                item['_id'] = '%s_%s_%d' % (item['city'], item['pType'], item['pId'])
　　　　　　　　　　# ... 省略

                try:
                    position_detail_res = requests.get(self.position_detail_url % item['pId']
                                                       , timeout=20, headers=self.headers)  # 请求详情页的数据
                    position_content = position_detail_res.json()['content']
                    item['pAdvantage'] = position_content.get('positionAdvantage')
　　　　　　　　　　　　# ...省略
　　　　　　　　　　　　
　　　　　　　　　　　　time.sleep(random.random() * 2)
　　　　　　　　　　except Exception as e: 
　　　　　　　　　　　　msg = '抓去职位%d详情页失败, Exception: %s' % (item['pId'], e) 
　　　　　　　　　　　　print(msg) 
　　　　　　　　　　　　self.db['positions'].update_one({'_id': item['_id']}, {'$set': item}, upsert=True) 
　　　　　　　　　　　　msg = '成功保存数据:{}!'.format(item) 
　　　　　　　　　　　　print(msg)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;可以看到方法中还请求了职位详情数据来丰富每一条数据的维度。&lt;/span&gt;　　&lt;/p&gt;

&lt;p&gt;&lt;span&gt;抓取数据后下面就是分析了，主要用pandas进行统计和画图。由于代码是用jupyter写的，这里不方便贴，所以我直接贴结论，感兴趣的朋友可以自行查看详细代码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、&lt;strong&gt;哪个城市目前招聘的岗位多&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PojicEpVKKnibc5DOyd4q7rtZWcJaYZYmx9QtuL3lx4aibNmKywdYaZeFpu8dvCrrEP9F8WxVfqUXovI5QMicibhIlw/640?wx_fmt=png&quot; alt=&quot;&quot; data-ratio=&quot;0.6606451612903226&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;775&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以看到，目前北京招聘的岗位最多，其次是上海和深圳，广州是最少的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、&lt;strong&gt;每个城市各岗位的需求量&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PojicEpVKKnibc5DOyd4q7rtZWcJaYZYmxjqG0XrGPOgIg9Lr6IvtIibuv1wrVhBFsfSGNlNibjVoiatHRnmeF4rnlg/640?wx_fmt=png&quot; alt=&quot;&quot; data-ratio=&quot;0.6105160662122687&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1027&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;北上广深4个城市目前招聘较多的岗位主要是后端-Java、前端、AI和测试。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、&lt;strong&gt;各岗位的平均薪资情况&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PojicEpVKKnibc5DOyd4q7rtZWcJaYZYmxRTNl9hFcnw2p3pdBiahrH5gIiaiaPJy3vUKiaQJp8XIXeSibVHPJcvL0fDQ/640?wx_fmt=png&quot; alt=&quot;&quot; data-ratio=&quot;0.6110283159463488&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;671&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;AI岗位的薪资最高，平均每个月30k以上；其次是大数据岗位，平均每个月26k左右，iOS的平均薪资比Android稍微高一些。另外，目前的前端岗位平均薪资偏低。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、&lt;strong&gt;几年工作经验比较吃香&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PojicEpVKKnibc5DOyd4q7rtZWcJaYZYmxvh8ibblicKicXbWLXkAeI8Chic8YTt4WuXDVyy3cDvq1dLb8tQUCjRoaLQ/640?wx_fmt=png&quot; alt=&quot;&quot; data-ratio=&quot;0.536745406824147&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;762&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以北京招聘数据为例，目前招聘的各岗位都是以3-5年工作经验为主，1-3年经验的需求量不大。所以，这里也要提醒职场新人，不要轻易跳槽。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其他城市的分布情况与北京类似，这里就不贴图了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5、&lt;strong&gt;什么学历比较吃香&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PojicEpVKKnibc5DOyd4q7rtZWcJaYZYmxIiaLsWkbIDHibLwlM9KqfssiacuvL2WkGbOCw8gjqCdmexkC7Jic7TDJEw/640?wx_fmt=png&quot; alt=&quot;&quot; data-ratio=&quot;0.532051282051282&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;780&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以北京为例，目前招聘的岗位除了AI需要不少的硕士甚至博士外，其他岗位以本科学历为主。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其他城市分布与北京类似。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6、&lt;strong&gt;什么规模公司对岗位需求大&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PojicEpVKKnibc5DOyd4q7rtZWcJaYZYmx4jStA476ic7N6vLicHVzpTBx5paVxCFXuIXlE83QiavASC3Bx9wKZS92A/640?wx_fmt=png&quot; alt=&quot;&quot; data-ratio=&quot;0.5525965379494008&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;751&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                                                                             北京&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PojicEpVKKnibc5DOyd4q7rtZWcJaYZYmxODIgZcPaAicAMEEcr55AlOOHyYTjh01ckHywO8M2Lb6KlrFux4qto7g/640?wx_fmt=png&quot; alt=&quot;&quot; data-ratio=&quot;0.5474934036939314&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;758&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                                                                               广州&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以看到，北京招聘的企业主要是2000人以上规模的大公司，上海和深圳的分布与北京类似。而广州在AI、前端和后端-Java几个岗位的招聘主要以50-1000人的中等规模公司为主。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;7、&lt;strong&gt;HR什么时间段更活跃&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PojicEpVKKnibc5DOyd4q7rtZWcJaYZYmx6LZKs05NoVUVtXfehvaVyGjkqlrhGNJZn40UbblCnT5UOtXFic5fsIw/640?wx_fmt=png&quot; alt=&quot;&quot; data-ratio=&quot;0.535575679172057&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;773&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以北京为例，各岗位的HR大部分在下午活跃，所以大家可以将简历的投递时间选在下午。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其他城市分布与北京类似。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;8、&lt;strong&gt;岗位的职责和要求&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;限于篇幅，我只跑了AI、后端-Java和前端这3个岗位的数据，以词云的形式展现&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PojicEpVKKnibc5DOyd4q7rtZWcJaYZYmxnt4xY2nbPNsiajN66IRbsrFy0mw3oSLMc7fvUouw9qrr9pSzXCyYXZQ/640?wx_fmt=png&quot; alt=&quot;&quot; data-ratio=&quot;0.6330578512396694&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;605&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PojicEpVKKnibc5DOyd4q7rtZWcJaYZYmxjvCKfeevOpAUnmFGhy7UeFF3XkqgBJmtsbyRRFYdoHSE7Mz5gSfibmw/640?wx_fmt=png&quot; alt=&quot;&quot; data-ratio=&quot;0.6320132013201321&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;606&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PojicEpVKKnibc5DOyd4q7rtZWcJaYZYmxM2B0s9icKvicnOFRKvibbyIWvV2JY35YlLLVFdqOW3XccuXBUd3tbWjzA/640?wx_fmt=png&quot; alt=&quot;&quot; data-ratio=&quot;0.6338259441707718&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;609&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;希望这次分析能对你有用，欢迎公众号&lt;strong&gt;「渡码」，&lt;/strong&gt;回复关键字“&lt;span&gt;职位&lt;/span&gt;”即可获取本次分析的源码。&lt;/span&gt;&lt;/p&gt;


</description>
<pubDate>Wed, 01 Apr 2020 00:45:00 +0000</pubDate>
<dc:creator>渡码</dc:creator>
<og:description>最近有不少程序员又开始找工作了，为了了解目前技术类各职位的数量、薪资、招聘公司、岗位职责及要求，我爬取了拉勾网北上广深4个城市的招聘数据，共3w条。职位包括：人工智能（AI）、大数据、数据分析、后端（</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/duma/p/12609489.html</dc:identifier>
</item>
<item>
<title>.NET Core 3 WPF MVVM框架 Prism系列之区域管理器 - RyzenAdorer</title>
<link>http://www.cnblogs.com/ryzen/p/12605347.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ryzen/p/12605347.html</guid>
<description>&lt;p&gt;本文将介绍如何在.NET Core3环境下使用MVVM框架Prism的使用区域管理器对于View的管理&lt;/p&gt;
&lt;h2 id=&quot;一区域管理器&quot;&gt;一.区域管理器&lt;/h2&gt;
&lt;p&gt;我们在之前的Prism系列构建了一个标准式Prism项目，这篇文章将会讲解之前项目中用到的利用区域管理器更好的对我们的View进行管理，同样的我们来看看官方给出的模型图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1294271/202003/1294271-20200331150607822-923107646.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在我们可以知道的是，大致一个区域管理器RegionMannager对一个控件创建区域的要点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;创建Region的控件必须包含一个RegionAdapter适配器&lt;/li&gt;
&lt;li&gt;region是依赖在具有RegionAdapter控件身上的&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其实后来我去看了下官方的介绍和源码，默认RegionAdapter是有三个，且还支持自定义RegionAdapter，因此在官方的模型图之间我做了点补充：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1294271/202003/1294271-20200331150617806-226264999.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;二区域创建与视图的注入&quot;&gt;二.区域创建与视图的注入&lt;/h2&gt;
&lt;p&gt;我们先来看看我们之前项目的区域的划分，以及如何创建区域并且把View注入到区域中：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1294271/202003/1294271-20200331150628801-1210659452.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们把整个主窗体划分了四个区域：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;ShowSearchPatientRegion&lt;/strong&gt;：注入了ShowSearchPatient视图&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PatientListRegion&lt;/strong&gt;：注入了PatientList视图&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;FlyoutRegion&lt;/strong&gt;：注入了PatientDetail和SearchMedicine视图&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ShowSearchPatientRegion&lt;/strong&gt;：注入了ShowSearchPatient视图&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在Prism中，我们有两种方式去实现区域创建和视图注入：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;ViewDiscovery&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ViewInjection&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;1viewdiscovery&quot;&gt;1.&lt;strong&gt;ViewDiscovery&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;我们截取其中&lt;strong&gt;PatientListRegion&lt;/strong&gt;的创建和视图注入的代码(更仔细的可以去观看demo源码)：&lt;/p&gt;
&lt;p&gt;MainWindow.xaml：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xaml&quot;&gt;&amp;lt;ContentControl Grid.Row=&quot;2&quot; prism:RegionManager.RegionName=&quot;PatientListRegion&quot; Margin=&quot;10&quot;/&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里相当于在后台MainWindow.cs：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;RegionManager.SetRegionName(ContentControl, &quot;PatientListRegion&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;PatientModule.cs：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt; public class PatientModule : IModule
 {
    public void OnInitialized(IContainerProvider containerProvider)
    {
         var regionManager = containerProvider.Resolve&amp;lt;IRegionManager&amp;gt;();
         //PatientList
         regionManager.RegisterViewWithRegion(RegionNames.PatientListRegion, typeof(PatientList));
         //PatientDetail-Flyout
         regionManager.RegisterViewWithRegion(RegionNames.FlyoutRegion, typeof(PatientDetail));
           
     }

    public void RegisterTypes(IContainerRegistry containerRegistry)
    {
           
    }
 }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;2viewinjection&quot;&gt;2.&lt;strong&gt;ViewInjection&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;我们在MainWindow窗体的Loaded事件中使用&lt;strong&gt;ViewInjection&lt;/strong&gt;方式注入视图PatientList&lt;/p&gt;
&lt;p&gt;MainWindow.xaml：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xaml&quot;&gt;  &amp;lt;i:Interaction.Triggers&amp;gt;
      &amp;lt;i:EventTrigger EventName=&quot;Loaded&quot;&amp;gt;
          &amp;lt;i:InvokeCommandAction Command=&quot;{Binding LoadingCommand}&quot;/&amp;gt;
       /i:EventTrigger&amp;gt;
  &amp;lt;/i:Interaction.Triggers&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;MainWindowViewModel.cs:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;      
private IRegionManager _regionManager;
private IRegion _paientListRegion;        
private PatientList _patientListView;

private DelegateCommand _loadingCommand;
public DelegateCommand LoadingCommand =&amp;gt;
     _loadingCommand ?? (_loadingCommand = new DelegateCommand(ExecuteLoadingCommand));

void ExecuteLoadingCommand()
{
     _regionManager = CommonServiceLocator.ServiceLocator.Current.GetInstance&amp;lt;IRegionManager&amp;gt;();
     _paientListRegion = _regionManager.Regions[RegionNames.PatientListRegion];
     _patientListView = CommonServiceLocator.ServiceLocator.Current.GetInstance&amp;lt;PatientList&amp;gt;();
     _paientListRegion.Add(_patientListView);

 }
      
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以明显的感觉到两种方式的不同，&lt;strong&gt;ViewDiscovery&lt;/strong&gt;方式是自动地实例化视图并且加载出来，而&lt;strong&gt;ViewInjection&lt;/strong&gt;方式则是可以手动控制注入视图和加载视图的时机(上述例子是通过Loaded事件)，官方对于两者的推荐使用场景如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ViewDiscovery&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;需要或要求自动加载视图&lt;/li&gt;
&lt;li&gt;视图的单个实例将加载到该区域中&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;ViewInjection&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;需要显式或编程控制何时创建和显示视图，或者您需要从区域中删除视图&lt;/li&gt;
&lt;li&gt;需要在区域中显示相同视图的多个实例，其中每个视图实例都绑定到不同的数据&lt;/li&gt;
&lt;li&gt;需要控制添加视图的区域的哪个实例&lt;/li&gt;
&lt;li&gt;应用程序使用导航API(后面会讲到)&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;三激活与失效视图&quot;&gt;三.激活与失效视图&lt;/h2&gt;
&lt;h3 id=&quot;activate和deactivate&quot;&gt;Activate和Deactivate&lt;/h3&gt;
&lt;p&gt;首先我们需要控制PatientList和MedicineMainContent两个视图的激活情况，上代码：&lt;/p&gt;
&lt;p&gt;MainWindow.xaml：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xaml&quot;&gt;&amp;lt;StackPanel Grid.Row=&quot;1&quot;&amp;gt;
    &amp;lt;Button  Content=&quot;Load MedicineModule&quot; FontSize=&quot;25&quot;  Margin=&quot;5&quot; Command=&quot;{Binding LoadMedicineModuleCommand}&quot;/&amp;gt;
     &amp;lt;UniformGrid Margin=&quot;5&quot;&amp;gt;
         &amp;lt;Button Content=&quot;ActivePaientList&quot; Margin=&quot;5&quot; Command=&quot;{Binding ActivePaientListCommand}&quot;/&amp;gt;
         &amp;lt;Button Content=&quot;DeactivePaientList&quot; Margin=&quot;5&quot; Command=&quot;{Binding DeactivePaientListCommand}&quot;/&amp;gt;
         &amp;lt;Button Content=&quot;ActiveMedicineList&quot; Margin=&quot;5&quot; Command=&quot;{Binding ActiveMedicineListCommand}&quot;/&amp;gt;
         &amp;lt;Button Content=&quot;DeactiveMedicineList&quot; Margin=&quot;5&quot; Command=&quot;{Binding DeactiveMedicineListCommand}&quot;/&amp;gt;
     &amp;lt;/UniformGrid&amp;gt;
&amp;lt;/StackPanel&amp;gt;

&amp;lt;ContentControl Grid.Row=&quot;2&quot; prism:RegionManager.RegionName=&quot;PatientListRegion&quot; Margin=&quot;10&quot;/&amp;gt;
&amp;lt;ContentControl Grid.Row=&quot;3&quot; prism:RegionManager.RegionName=&quot;MedicineMainContentRegion&quot;/&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;MainWindowViewModel.cs：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;  private IRegionManager _regionManager;
  private IRegion _paientListRegion;
  private IRegion _medicineListRegion;
  private PatientList _patientListView;
  private MedicineMainContent _medicineMainContentView;

  private bool _isCanExcute = false;
  public bool IsCanExcute
  {
     get { return _isCanExcute; }
     set { SetProperty(ref _isCanExcute, value); }
  }

  private DelegateCommand _loadingCommand;
  public DelegateCommand LoadingCommand =&amp;gt;
      _loadingCommand ?? (_loadingCommand = new DelegateCommand(ExecuteLoadingCommand));

  private DelegateCommand _activePaientListCommand;
  public DelegateCommand ActivePaientListCommand =&amp;gt;
      _activePaientListCommand ?? (_activePaientListCommand = new DelegateCommand(ExecuteActivePaientListCommand));

  private DelegateCommand _deactivePaientListCommand;
  public DelegateCommand DeactivePaientListCommand =&amp;gt;
      _deactivePaientListCommand ?? (_deactivePaientListCommand = new DelegateCommand(ExecuteDeactivePaientListCommand));

   private DelegateCommand _activeMedicineListCommand;
   public DelegateCommand ActiveMedicineListCommand =&amp;gt;
      _activeMedicineListCommand ?? (_activeMedicineListCommand = new DelegateCommand(ExecuteActiveMedicineListCommand).ObservesCanExecute(() =&amp;gt; IsCanExcute));

   private DelegateCommand _deactiveMedicineListCommand;
   public DelegateCommand DeactiveMedicineListCommand =&amp;gt;
       _deactiveMedicineListCommand ?? (_deactiveMedicineListCommand = new DelegateCommand(ExecuteDeactiveMedicineListCommand).ObservesCanExecute(() =&amp;gt; IsCanExcute));

   private DelegateCommand _loadMedicineModuleCommand;
   public DelegateCommand LoadMedicineModuleCommand =&amp;gt;
       _loadMedicineModuleCommand ?? (_loadMedicineModuleCommand = new DelegateCommand(ExecuteLoadMedicineModuleCommand));

 /// &amp;lt;summary&amp;gt;
 /// 窗体加载事件
 /// &amp;lt;/summary&amp;gt;
 void ExecuteLoadingCommand()
 {
      _regionManager = CommonServiceLocator.ServiceLocator.Current.GetInstance&amp;lt;IRegionManager&amp;gt;();
      _paientListRegion = _regionManager.Regions[RegionNames.PatientListRegion];
      _patientListView = CommonServiceLocator.ServiceLocator.Current.GetInstance&amp;lt;PatientList&amp;gt;();
      _paientListRegion.Add(_patientListView);
      _medicineListRegion = _regionManager.Regions[RegionNames.MedicineMainContentRegion];
 }

  /// &amp;lt;summary&amp;gt;
  /// 失效medicineMainContent视图
  /// &amp;lt;/summary&amp;gt;
  void ExecuteDeactiveMedicineListCommand()
  {
      _medicineListRegion.Deactivate(_medicineMainContentView);
  }

  /// &amp;lt;summary&amp;gt;
  /// 激活medicineMainContent视图
  /// &amp;lt;/summary&amp;gt;
  void ExecuteActiveMedicineListCommand()
  {
      _medicineListRegion.Activate(_medicineMainContentView);
  }

  /// &amp;lt;summary&amp;gt;
  /// 失效patientList视图
  /// &amp;lt;/summary&amp;gt;
  void ExecuteDeactivePaientListCommand()
  {
       _paientListRegion.Deactivate(_patientListView);
  }

  /// &amp;lt;summary&amp;gt;
  /// 激活patientList视图
  /// &amp;lt;/summary&amp;gt;
  void ExecuteActivePaientListCommand()
  {
       _paientListRegion.Activate(_patientListView);
  }
  
  /// &amp;lt;summary&amp;gt;
  /// 加载MedicineModule
  /// &amp;lt;/summary&amp;gt;
  void ExecuteLoadMedicineModuleCommand()
  {
       _moduleManager.LoadModule(&quot;MedicineModule&quot;);
       _medicineMainContentView = (MedicineMainContent)_medicineListRegion.Views.Where(t =&amp;gt; t.GetType() == typeof(MedicineMainContent)).FirstOrDefault();
       this.IsCanExcute = true;
   }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1294271/202003/1294271-20200331150701465-763264378.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;监控视图激活状态&quot;&gt;监控视图激活状态&lt;/h3&gt;
&lt;p&gt;Prism其中还支持监控视图的激活状态，是通过在View中继承IActiveAware来实现的，我们以监控其中MedicineMainContent视图的激活状态为例子：&lt;/p&gt;
&lt;p&gt;MedicineMainContentViewModel.cs:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt; public class MedicineMainContentViewModel : BindableBase,IActiveAware
 {
     public event EventHandler IsActiveChanged;

     bool _isActive;
     public bool IsActive
     {
         get { return _isActive; }
         set
         {
             _isActive = value;
             if (_isActive)
             {
                 MessageBox.Show(&quot;视图被激活了&quot;);
             }
             else
             {
                 MessageBox.Show(&quot;视图失效了&quot;);
             }
             IsActiveChanged?.Invoke(this, new EventArgs());
          }
      }

  }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1294271/202003/1294271-20200331150713576-1911934096.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;add和remove&quot;&gt;Add和Remove&lt;/h3&gt;
&lt;p&gt;上述例子用的是ContentControl，我们再用一个ItemsControl的例子，代码如下：&lt;/p&gt;
&lt;p&gt;MainWindow.xaml:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xaml&quot;&gt;  &amp;lt;metro:MetroWindow.RightWindowCommands&amp;gt;
      &amp;lt;metro:WindowCommands x:Name=&quot;rightWindowCommandsRegion&quot; /&amp;gt;
  &amp;lt;/metro:MetroWindow.RightWindowCommands&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;MainWindow.cs:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt; public MainWindow()
 {
    InitializeComponent();
    var regionManager= ServiceLocator.Current.GetInstance&amp;lt;IRegionManager&amp;gt;();
    if (regionManager != null)
    {
       SetRegionManager(regionManager, this.flyoutsControlRegion, RegionNames.FlyoutRegion);
       SetRegionManager(regionManager, this.rightWindowCommandsRegion, RegionNames.ShowSearchPatientRegion);//创建WindowCommands控件区域
    }
 }

 void SetRegionManager(IRegionManager regionManager, DependencyObject regionTarget, string regionName)
 {
     RegionManager.SetRegionName(regionTarget, regionName);
     RegionManager.SetRegionManager(regionTarget, regionManager);
 }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ShowSearchPatient.xaml：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xaml&quot;&gt;&amp;lt;StackPanel x:Class=&quot;PrismMetroSample.MedicineModule.Views.ShowSearchPatient&quot;
           xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;
           xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;
           xmlns:prism=&quot;http://prismlibrary.com/&quot;  
           xmlns:const=&quot;clr-namespace:PrismMetroSample.Infrastructure.Constants;assembly=PrismMetroSample.Infrastructure&quot;
           Orientation=&quot;Horizontal&quot;    
           xmlns:i=&quot;http://schemas.microsoft.com/expression/2010/interactivity&quot;
            prism:ViewModelLocator.AutoWireViewModel=&quot;True&quot;&amp;gt;
    &amp;lt;i:Interaction.Triggers&amp;gt;
        &amp;lt;i:EventTrigger EventName=&quot;Loaded&quot;&amp;gt;
            &amp;lt;i:InvokeCommandAction Command=&quot;{Binding ShowSearchLoadingCommand}&quot;/&amp;gt;
        &amp;lt;/i:EventTrigger&amp;gt;
    &amp;lt;/i:Interaction.Triggers&amp;gt;
    &amp;lt;CheckBox IsChecked=&quot;{Binding IsShow}&quot;/&amp;gt;
    &amp;lt;Button Command=&quot;{Binding ApplicationCommands.ShowCommand}&quot; CommandParameter=&quot;{x:Static const:FlyoutNames.SearchMedicineFlyout}&quot;&amp;gt;
        &amp;lt;StackPanel Orientation=&quot;Horizontal&quot;&amp;gt;
            &amp;lt;Image Height=&quot;20&quot; Source=&quot;pack://application:,,,/PrismMetroSample.Infrastructure;Component/Assets/Photos/按钮.png&quot;/&amp;gt;
            &amp;lt;TextBlock Text=&quot;Show&quot; FontWeight=&quot;Bold&quot; FontSize=&quot;15&quot; VerticalAlignment=&quot;Center&quot;/&amp;gt;
        &amp;lt;/StackPanel&amp;gt;
    &amp;lt;/Button&amp;gt;
&amp;lt;/StackPanel&amp;gt;

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ShowSearchPatientViewModel.cs:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt; private IApplicationCommands _applicationCommands;
 private readonly IRegionManager _regionManager;
 private ShowSearchPatient _showSearchPatientView;
 private IRegion _region;

 public IApplicationCommands ApplicationCommands
 {
      get { return _applicationCommands; }
      set { SetProperty(ref _applicationCommands, value); }
 }

 private bool _isShow=true;
 public bool IsShow
 {
      get { return _isShow=true; }
      set 
      { 
          SetProperty(ref _isShow, value);
          if (_isShow)
          {
               ActiveShowSearchPatient();
          }
          else
          {
               DeactiveShowSearchPaitent();
          }
      }
 }

 private DelegateCommand _showSearchLoadingCommand;
 public DelegateCommand ShowSearchLoadingCommand =&amp;gt;
         _showSearchLoadingCommand ?? (_showSearchLoadingCommand = new DelegateCommand(ExecuteShowSearchLoadingCommand));

 void ExecuteShowSearchLoadingCommand()
 {
        _region = _regionManager.Regions[RegionNames.ShowSearchPatientRegion];
        _showSearchPatientView = (ShowSearchPatient)_region.Views.Where(t =&amp;gt; t.GetType() == typeof(ShowSearchPatient)).FirstOrDefault();
 }


  public ShowSearchPatientViewModel(IApplicationCommands applicationCommands,IRegionManager regionManager)
  {
        this.ApplicationCommands = applicationCommands;
        _regionManager = regionManager;
  }

  /// &amp;lt;summary&amp;gt;
  /// 激活视图
  /// &amp;lt;/summary&amp;gt;
  private void ActiveShowSearchPatient()
  {
       if (!_region.ActiveViews.Contains(_showSearchPatientView))
       {
           _region.Add(_showSearchPatientView);
       }         
  }
   
  /// &amp;lt;summary&amp;gt;
  /// 失效视图
  /// &amp;lt;/summary&amp;gt;
   private async void DeactiveShowSearchPaitent()
   {
        _region.Remove(_showSearchPatientView);
        await Task.Delay(2000);
        IsShow = true;
   }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1294271/202003/1294271-20200331150729733-326316595.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里的WindowCommands 的继承链为：WindowCommands &amp;lt;-- ToolBar &amp;lt;-- HeaderedItemsControl &amp;lt;--ItemsControl，因此由于Prism默认的适配器有ItemsControlRegionAdapter,因此其子类也继承了其行为&lt;/p&gt;
&lt;p&gt;这里重点归纳一下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当进行模块化时，加载完模块才会去注入视图到区域(可参考MedicineModule视图加载顺序)&lt;/li&gt;
&lt;li&gt;ContentControl控件由于Content只能显示一个，在其区域中可以通过Activate和Deactivate方法来控制显示哪个视图，其行为是由ContentControlRegionAdapter适配器控制&lt;/li&gt;
&lt;li&gt;ItemsControl控件及其子控件由于显示一个集合视图，默认全部集合视图是激活的，这时候不能通过Activate和Deactivate方式来控制(会报错),通过Add和Remove来控制要显示哪些视图，其行为是由ItemsControlRegionAdapter适配器控制&lt;/li&gt;
&lt;li&gt;这里没讲到Selector控件，因为也是继承自ItemsControl，因此其SelectorRegionAdapter适配器和ItemsControlRegionAdapter适配器异曲同工&lt;/li&gt;
&lt;li&gt;可以通过继承IActiveAware接口来监控视图激活状态&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;四自定义区域适配器&quot;&gt;四.自定义区域适配器&lt;/h2&gt;
&lt;p&gt;我们在介绍整个区域管理器模型图中说过，Prism有三个默认的区域适配器：ItemsControlRegionAdapter，ContentControlRegionAdapter，SelectorRegionAdapter，且支持自定义区域适配器，现在我们来自定义一下适配器&lt;/p&gt;
&lt;h3 id=&quot;1创建自定义适配器&quot;&gt;1.创建自定义适配器&lt;/h3&gt;
&lt;p&gt;新建类UniformGridRegionAdapter.cs：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public class UniformGridRegionAdapter : RegionAdapterBase&amp;lt;UniformGrid&amp;gt;
{
    public UniformGridRegionAdapter(IRegionBehaviorFactory regionBehaviorFactory) : base(regionBehaviorFactory)
    {

    }

    protected override void Adapt(IRegion region, UniformGrid regionTarget)
    {
        region.Views.CollectionChanged += (s, e) =&amp;gt;
        {
          if (e.Action==System.Collections.Specialized.NotifyCollectionChangedAction.Add)
          {
              foreach (FrameworkElement element in e.NewItems)
              {
                   regionTarget.Children.Add(element);
              }
          }
        };
    }

    protected override IRegion CreateRegion()
    {
        return new AllActiveRegion();
    }
 }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;2注册映射&quot;&gt;2.注册映射&lt;/h3&gt;
&lt;p&gt;App.cs:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;protected override void ConfigureRegionAdapterMappings(RegionAdapterMappings regionAdapterMappings)
{
    base.ConfigureRegionAdapterMappings(regionAdapterMappings);
    regionAdapterMappings.RegisterMapping(typeof(UniformGrid),      Container.Resolve&amp;lt;UniformGridRegionAdapter&amp;gt;());//为UniformGrid控件注册适配器映射
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;3为控件创建区域&quot;&gt;3.为控件创建区域&lt;/h3&gt;
&lt;p&gt;MainWindow.xaml:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xaml&quot;&gt;    &amp;lt;UniformGrid Margin=&quot;5&quot; prism:RegionManager.RegionName=&quot;UniformContentRegion&quot; Columns=&quot;2&quot;&amp;gt;
        &amp;lt;Button Content=&quot;ActivePaientList&quot; Margin=&quot;5&quot; Command=&quot;{Binding ActivePaientListCommand}&quot;/&amp;gt;
        &amp;lt;Button Content=&quot;DeactivePaientList&quot; Margin=&quot;5&quot; Command=&quot;{Binding DeactivePaientListCommand}&quot;/&amp;gt;
        &amp;lt;Button Content=&quot;ActiveMedicineList&quot; Margin=&quot;5&quot; Command=&quot;{Binding ActiveMedicineListCommand}&quot;/&amp;gt;
        &amp;lt;Button Content=&quot;DeactiveMedicineList&quot; Margin=&quot;5&quot; Command=&quot;{Binding DeactiveMedicineListCommand}&quot;/&amp;gt;
     &amp;lt;/UniformGrid&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;4为区域注入视图&quot;&gt;4.为区域注入视图&lt;/h3&gt;
&lt;p&gt;这里用的是ViewInjection方式：&lt;/p&gt;
&lt;p&gt;MainWindowViewModel.cs&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;  void ExecuteLoadingCommand()
  {
         _regionManager = CommonServiceLocator.ServiceLocator.Current.GetInstance&amp;lt;IRegionManager&amp;gt;();

         var uniformContentRegion = _regionManager.Regions[&quot;UniformContentRegion&quot;];
         var regionAdapterView1 = CommonServiceLocator.ServiceLocator.Current.GetInstance&amp;lt;RegionAdapterView1&amp;gt;();
         uniformContentRegion.Add(regionAdapterView1);
         var regionAdapterView2 = CommonServiceLocator.ServiceLocator.Current.GetInstance&amp;lt;RegionAdapterView2&amp;gt;();
         uniformContentRegion.Add(regionAdapterView2); 
  }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1294271/202003/1294271-20200331150744622-1824940697.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以看到我们为UniformGrid创建区域适配器，并且注册后，也能够为UniformGrid控件创建区域，并且注入视图显示，如果没有该区域适配器，则是会报错，下一篇我们将会讲解基于区域Region的prism导航系统。&lt;/p&gt;
&lt;h2 id=&quot;五源码&quot;&gt;五.源码&lt;/h2&gt;
&lt;p&gt; 最后，附上整个demo的源代码：&lt;a href=&quot;https://github.com/ZhengDaoWang/PrismMetroSample&quot;&gt;PrismDemo源码&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 01 Apr 2020 00:33:00 +0000</pubDate>
<dc:creator>RyzenAdorer</dc:creator>
<og:description>本文将介绍如何在.NET Core3环境下使用MVVM框架Prism的使用区域管理器对于View的管理 一.区域管理器 我们在之前的Prism系列构建了一个标准式Prism项目，这篇文章将会讲解之前项</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ryzen/p/12605347.html</dc:identifier>
</item>
<item>
<title>阅读了这三篇文章，你也就基本理解了ASP.NET Core MVC框架的工作原理 - Artech</title>
<link>http://www.cnblogs.com/artech/p/asp-net-core-mvc-mini.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/artech/p/asp-net-core-mvc-mini.html</guid>
<description>&lt;div id=&quot;cnblogs_post_description&quot; readability=&quot;35&quot;&gt;&lt;img src=&quot;http://images.cnblogs.com/cnblogs_com/artech/158198/o_.netcore.png&quot; class=&quot;desc_img&quot;/&gt;《200行代码，7个对象——让你了解ASP.NET Core框架的本质》让很多读者对ASP.NET Core管道有深刻的理解，知道了ASP.NET Core框架针对每个请求的处理流程。在过去很长一段时间中，有很多人私信给我：能否按照相同的方式分析一下MVC框架。真实的MVC框架其实很复杂，所以我们依然按照类似的方式大刀阔斧地“砍掉”了很多“细枝末节”，利用一个Mini版本的模拟框架将真实ASP.NET Core MVC最核心的部分展示出来。和Mini版本的ASP.NET Core框架一样，这个Mini版的ASP.NET Core MVC框架同样采用真实框架一致的设计，并且是同样可以直接运行的。&lt;/div&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;81.640150564617&quot;&gt;
&lt;p&gt;《&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-framework.html&quot;&gt;200行代码，7个对象——让你了解ASP.NET Core框架的本质&lt;/a&gt;》让很多读者对ASP.NET Core管道有深刻的理解，知道了ASP.NET Core框架针对每个请求的处理流程。在过去很长一段时间中，有很多人私信给我：能否按照相同的方式分析一下MVC框架。真实的MVC框架其实很复杂，所以我们依然按照类似的方式大刀阔斧地“砍掉”了很多“细枝末节”，利用一个Mini版本的模拟框架将真实ASP.NET Core MVC最核心的部分展示出来。和Mini版本的ASP.NET Core框架一样，这个Mini版的ASP.NET Core MVC框架同样采用真实框架一致的设计，并且是同样可以直接运行的。为了更好的维护，我将这两个模拟框架放到了&lt;a href=&quot;https://github.com/&quot;&gt;github&lt;/a&gt;上。&lt;/p&gt;
&lt;p&gt;ASP.NET Core Mini: &lt;a title=&quot;https://github.com/jiangjinnan/AspNetCoreMini&quot; href=&quot;https://github.com/jiangjinnan/AspNetCoreMini&quot;&gt;https://github.com/jiangjinnan/AspNetCoreMini&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ASP.NET Core MVC Mini：&lt;a title=&quot;https://github.com/jiangjinnan/AspNetCoreMvcMini&quot; href=&quot;https://github.com/jiangjinnan/AspNetCoreMvcMini&quot;&gt;https://github.com/jiangjinnan/AspNetCoreMvcMini&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;整个MVC框架建立在路由中间件（《ASP.NET Core 3框架揭秘》下册具有对路由中间件的专门介绍，本书正在参加京东满&lt;span&gt;100-50&lt;/span&gt;活动，错过之前5折优惠的同学可以上车了）上。不论是面向Controller的Model-View-Controller编程模型，还是面向页面的Razor Pages编程模型，每个请求指向的都一个某个Action，所以MVC框架只需要将每个Action封装成一个路由终结点（RouteEndpoint），并通过自定义的EndpointDataSource注册到路由中间件上即可。本篇着重关注MVC框架与路由中间件的整合，所以我们将Action方法的定义作了最大的简化：Action方法都是无参方法，这样我们就不需要考虑参数绑定的问题；Action方法的返回值都是Task或者Void，所有的请求处理任务都实现在方法中。&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-mvc-01.html&quot;&gt;阅读全文&lt;/a&gt;…&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FoobarController: Controller
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Foo();
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Task BarAsync();
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ValueTask BazAsync();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们在《&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-mvc-01.html&quot;&gt;[上篇]：路由整合&lt;/a&gt;》将定义在Controller类型中的Action方法简化成只返回Task或者Void的方法，并让方法自身去完成包括对请求予以相应的所有请求处理任务，但真实的MVC框架对Action方法对返回类型没有任何的限制。一般来说，我们倾向于将Action方法的返回类型定义成IActionResult、Task&amp;lt;IActionResult&amp;gt;或者ValueTask&amp;lt;IActionResult&amp;gt;。如果Action方法返回其他类型的对象，该对象最终还是会被转换成IActionResult对象。在整个MVC框架针对请求的处理流程中，IActionResult对象主要负责针对请求的响应工作。本篇我们将对上面建立的模拟框架作进一步完善，接触针对Action方法返回类型的限制。&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-mvc-02.html&quot;&gt;阅读全文&lt;/a&gt;…&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FoobarController: Controller
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IActionResult Foo();
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Task&amp;lt;IActionResult&amp;gt;&lt;span&gt; BarAsync();   
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ValueTask&amp;lt;IActionResult&amp;gt;&lt;span&gt; BazAsync();
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Foobar Qux();
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Task&amp;lt;Foobar&amp;gt;&lt;span&gt; QuuxAsync();
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ValueTask&amp;lt;Foobar&amp;gt;&lt;span&gt; CorgeAsync();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;模拟框架到目前为止都假定Action方法是没有参数的，我们知道MVC框架对Action方法的参数并没有作限制，它可以包含任意数量和类型的参数。一旦将“零参数”的假设去除，Action方法的执行就变得没那么简单了，因为在执行目标方法之前需要绑定所有的参数。MVC框架采用一种叫做“模型绑定（Model Binding）”的机制来绑定目标Action方法的输出参数，这可以算是MVC框架针对请求执行流程中最为复杂的一个环节。本篇文章对现有框架做进步完全，通过实现模型绑定接触上面针对Action方法参数的限制。&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-mvc-03.html&quot;&gt;阅读全文&lt;/a&gt;…&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FoobarController: Controller
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IActionResult Foo(Foo foo, Bar baz);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Task&amp;lt;IActionResult&amp;gt;&lt;span&gt; BarAsync(Foo foo, Bar baz);   
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ValueTask&amp;lt;IActionResult&amp;gt;&lt;span&gt; BazAsync(Foo foo, Bar baz);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Foobar Qux(Foo foo, Bar baz);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Task&amp;lt;Foobar&amp;gt;&lt;span&gt; QuuxAsync(Foo foo, Bar baz);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ValueTask&amp;lt;Foobar&amp;gt;&lt;span&gt; CorgeAsync(Foo foo, Bar baz);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;</description>
<pubDate>Wed, 01 Apr 2020 00:27:00 +0000</pubDate>
<dc:creator>Artech</dc:creator>
<og:description>《200行代码，7个对象——让你了解ASP.NET Core框架的本质》让很多读者对ASP.NET Core管道有深刻的理解，知道了ASP.NET Core框架针对每个请求的处理流程。在过去很长一段时</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/artech/p/asp-net-core-mvc-mini.html</dc:identifier>
</item>
<item>
<title>数据源管理 | 主从库动态路由，AOP模式读写分离 - 知了一笑</title>
<link>http://www.cnblogs.com/cicada-smile/p/12610151.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cicada-smile/p/12610151.html</guid>
<description>&lt;p&gt;本文源码：&lt;a href=&quot;https://github.com/cicadasmile/data-manage-parent&quot;&gt;GitHub·点这里&lt;/a&gt; || &lt;a href=&quot;https://gitee.com/cicadasmile/data-manage-parent&quot;&gt;GitEE·点这里&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;1、基础描述&quot;&gt;1、基础描述&lt;/h2&gt;
&lt;p&gt;在相对复杂的应用服务中，配置多个数据源是常见现象，例如常见的：配置主从数据库用来写数据，再配置一个从库读数据，这种读写分离模式可以缓解数据库压力，提高系统的并发能力和稳定性，执行效率。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1691717/202004/1691717-20200401073421382-233011905.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;2、核心api&quot;&gt;2、核心API&lt;/h2&gt;
&lt;p&gt;在处理这种常见问题，要学会查询服务基础框架的API，说直白点就是查询Spring框架的API（工作几年，还没用过Spring之外的框架搭建环境），这种常用的业务模式，基本上Spring都提供了API支持。&lt;/p&gt;
&lt;p&gt;核心API：AbstractRoutingDataSource&lt;/p&gt;
&lt;p&gt;底层维护Map容器，用来保存数据源集合，提供一个抽象方法，实现自定义的路由策略。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Nullable
private Map&amp;lt;Object, DataSource&amp;gt; resolvedDataSources;
@Nullable
protected abstract Object determineCurrentLookupKey();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;补刀一句&lt;/code&gt;&lt;/strong&gt;：为何框架的原理很难通过一篇文章看明白？因为使用的不多，基本意识没有形成，熟悉框架原理的基本要求：对框架的各种功能都熟悉，经常使用，自然而然的就明白了，盐大晒的久，咸鱼才够味。&lt;/p&gt;

&lt;h2 id=&quot;1、数据源管理&quot;&gt;1、数据源管理&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;配置两个数据源&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yml&quot;&gt;spring:
  datasource:
    type: com.alibaba.druid.pool.DruidDataSource
    driverClassName: com.mysql.jdbc.Driver
    master:
      url: jdbc:mysql://localhost:3306/data_master
      username: root
      password: 123456
    slave:
      url: jdbc:mysql://localhost:3306/data_slave
      username: root
      password: 123456
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从实际开发角度，这两个数据源需要配置主从复制流程，再基于安全角度，写库可以只给写权限，读库只给读权限。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Map容器加载&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Configuration
public class DruidConfig {
    // 忽略参数加载，源码中有
    @Bean
    @Primary
    public DataSource primaryDataSource() {
        Map&amp;lt;Object, Object&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
        map.put(&quot;masterDataSource&quot;, masterDataSource());
        map.put(&quot;slaveDataSource&quot;, slaveDataSource());
        RouteDataSource routeDataSource = new RouteDataSource();
        routeDataSource.setTargetDataSources(map);
        routeDataSource.setDefaultTargetDataSource(masterDataSource());
        return routeDataSource ;
    }
    private DataSource masterDataSource() {
        return getDefDataSource(masterUrl,masterUsername,masterPassword);
    }
    private DataSource slaveDataSource() {
        return getDefDataSource(slaveUrl,slaveUsername,slavePassword);
    }
    private DataSource getDefDataSource (String url,String userName,String passWord){
        DruidDataSource datasource = new DruidDataSource();
        datasource.setDriverClassName(driverClassName);
        datasource.setUrl(url);
        datasource.setUsername(userName);
        datasource.setPassword(passWord);
        return datasource;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的Map容器管理两个key，masterDataSource和slaveDataSource代表两个不同的库，使用不同的key即加载对应的库。&lt;/p&gt;
&lt;h2 id=&quot;2、容器key管理&quot;&gt;2、容器Key管理&lt;/h2&gt;
&lt;p&gt;使用ThreadLocal管理当前会会话中线程参数，存取使用极其方便。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class RouteContext implements AutoCloseable {

    private static final ThreadLocal&amp;lt;String&amp;gt; threadLocal = new ThreadLocal&amp;lt;&amp;gt;();
    public static void setRouteKey (String key){
        threadLocal.set(key);
    }
    public static String getRouteKey() {
        String key = threadLocal.get();
        return key == null ? &quot;masterDataSource&quot; : key;
    }
    @Override
    public void close() {
        threadLocal.remove();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;3、路由key实现&quot;&gt;3、路由Key实现&lt;/h2&gt;
&lt;p&gt;获取ThreadLocal中，当前数据源的key，适配相关联的数据源。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class RouteDataSource extends AbstractRoutingDataSource {
    @Override
    protected Object determineCurrentLookupKey() {
        return RouteContext.getRouteKey();
    }
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;1、aop思维&quot;&gt;1、AOP思维&lt;/h2&gt;
&lt;p&gt;基于AOP的切面思想，不同的方法类型，去设置对应路由Key，这样就可以在业务逻辑执行之前，切换到不同的数据源。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Aspect
@Component
@Order(1)
public class ReadWriteAop {

    private static Logger LOGGER = LoggerFactory.getLogger(ReadWriteAop.class) ;

    @Before(&quot;execution(* com.master.slave.controller.*.*(..))&quot;)
    public void setReadDataSourceType() {
        HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();
        String method = request.getRequestURI() ;
        boolean rwFlag = readOrWrite(method) ;
        if (rwFlag){
            RouteContext.setRouteKey(&quot;slaveDataSource&quot;);
        } else {
            RouteContext.setRouteKey(&quot;masterDataSource&quot;);
        }
        LOGGER.info(&quot;请求方法:&quot;+method+&quot;;执行库：&quot;+RouteContext.getRouteKey());
    }

    private String[] readArr = new String[]{&quot;select&quot;,&quot;count&quot;,&quot;query&quot;,&quot;get&quot;,&quot;find&quot;} ;
    private boolean readOrWrite (String method){
        for (String readVar:readArr) {
            if (method.contains(readVar)){
                return true ;
            }
        }
        return false ;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;常见的读取方法：select、count、query、get、find等等，方法的命名要遵循自定义的路由规则。&lt;/p&gt;
&lt;h2 id=&quot;2、提供测试接口&quot;&gt;2、提供测试接口&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;控制层API&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;import com.master.slave.entity.User;
import com.master.slave.service.UserService;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import javax.annotation.Resource;

@RestController
public class UserController {

    @Resource
    private UserService userService ;

    @GetMapping(&quot;/selectById&quot;)
    public User selectById (@RequestParam(&quot;id&quot;) Integer id) {
        return userService.selectById(id) ;
    }

    @GetMapping(&quot;/insert&quot;)
    public String insert () {
        User user = new User(&quot;张三&quot;,&quot;write&quot;) ;
        userService.insert(user) ;
        return &quot;success&quot; ;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;服务实现&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Service
public class UserService {

    @Resource
    private UserMapper userMapper ;

    public User selectById (Integer id) {
        return userMapper.selectById(id) ;
    }

    public void insert (User user){
        userMapper.insert(user);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样数据源基于不同的类型方法就会一直的动态切换。&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;GitHub·地址
https://github.com/cicadasmile/data-manage-parent
GitEE·地址
https://gitee.com/cicadasmile/data-manage-parent
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1691717/201908/1691717-20190823075428183-1996768914.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 31 Mar 2020 23:47:00 +0000</pubDate>
<dc:creator>知了一笑</dc:creator>
<og:description>本文源码： &amp;quot;GitHub&amp;#183;点这里&amp;quot; || &amp;quot;GitEE&amp;#183;点这里&amp;quot; 一、多数据源应用 1、基础描述 在相对复杂的应用服务中，配置多个数据源是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cicada-smile/p/12610151.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core 奇淫技巧之伪属性注入 - 晓晨Master</title>
<link>http://www.cnblogs.com/stulzq/p/12610026.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/stulzq/p/12610026.html</guid>
<description>&lt;h2 id=&quot;一前言&quot;&gt;一.前言&lt;/h2&gt;
&lt;p&gt;开局先唠嗑一下，许久未曾更新博客，一直在调整自己的状态，去年是我的本命年，或许是应验了本命年的多灾多难，过得十分不顺，不论是生活上还是工作上。还好当我度过了所谓的本命年后，许多事情都在慢慢变好，我将会开始恢复更新博客，争取恢复到以前的速度上(因为工作比较忙，所以这个过程可能需要一段时间)。&lt;/p&gt;
&lt;h2 id=&quot;二关于属性注入&quot;&gt;二.关于属性注入&lt;/h2&gt;
&lt;p&gt;说到属性注入，我们就不得不提一下 DI(Dependency Injection)，即依赖注入，用过 ASP.NET Core 的同学相信对这个词不会陌生。ASP.NET Core 自带了一个IOC容器，且程序运行也是基于这个容器建立起来的，在 Startup 里的 &lt;code&gt;ConfigureServices&lt;/code&gt; 方法就是向容器注册类型。最直白的讲，我们在 ASP.NET Core 中，想使用某个类型的时候可以不用自己去 new，可以由容器通过构造方法来注入具体的实现类型，而我们一般在构造方法上定义的依赖类型都是接口，而不是去依赖具体的实现，这里就体现了 SOLID 原则中的依赖倒置原则(DIP)。这也是IOC（Inversion of Control），即控制反转，不直接依赖具体实现，将依赖交给容器去控制。上述几者是具有一定的关联关系的，DIP 是一种软件设计原则，IOC 是 DIP 的具体实现方式，DI 是 IOC 的一种实现方式。&lt;/p&gt;
&lt;p&gt;在依赖注入时，我们最常用的便是通过构造方法注入，还有另一种方式那便是&lt;strong&gt;属性注入&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;关于属性注入，如果在网上搜索，大部分内容都是不推荐使用，或者说慎重使用的，因为属性注入会造成类型的依赖关系隐藏，测试不友好等，我也同意这种说法，属性注入可以使用，但是要谨慎，不能盲目使用。我的原则：在封装框架（搭架子）时可以使用，但不能大范围使用，只有必须使用属性注入来达到效果的地方才会使用，用来提高使用框架时的编码效率，来达到一些便利，脱离框架层面，编写业务代码时，不得使用。&lt;/p&gt;
&lt;p&gt;在 ASP.NET Core 中，自带的容器是不支持属性注入的，但是可以通过替换容器，如：Autofac 等来实现。今天我分享的方法不是使用替换容器，而是通过&lt;strong&gt;几行代码&lt;/strong&gt;来实现属性注入的效果，我称为“&lt;strong&gt;伪属性注入&lt;/strong&gt;”。&lt;/p&gt;
&lt;h2 id=&quot;三属性注入解决的痛点&quot;&gt;三.属性注入解决的痛点&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;以下介绍的痛点是我在实际编码过程中遇到的一些，如果还有其他的，欢迎在评论和我交流&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我所遇到的痛点，我归纳为三条：&lt;/p&gt;
&lt;p&gt;1.减少&lt;strong&gt;常用&lt;/strong&gt;的类型的重复注入代码，使构造方法看起来更为简洁，提高阅读性。&lt;/p&gt;
&lt;p&gt;2.减少或消除因构造方法注入造成子类继承后的 base 调用链。&lt;/p&gt;
&lt;p&gt;3.&lt;strong&gt;并非是满足第一条或第二条就需要使用属性注入来解决，只有当第一、二条发生的情况到达一定的数量。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;第一条：&quot;&gt;第一条：&lt;/h3&gt;
&lt;p&gt;以日志 &lt;code&gt;ILogger&amp;lt;T&amp;gt;&lt;/code&gt; 为例，我们在 Controller 或者 应用服务层（Application Service）等编写业务的地方可能会常用，那么我们可能会在大部分的 Controller 或者 Application Service 的构造方法里写一句注入，例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/668104/202004/668104-20200401013227435-457592325.png&quot; alt=&quot;1585671450000&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里只是以日志来举例，我们还能遇到和日志这种相同的类型，每个 Controller 等都要注入一堆这种共同的类型，代码编写起来也比较麻烦，如果多了以后还影响代码阅读。&lt;/p&gt;
&lt;p&gt;有何解决办法，那就是定义一个基类，然后通过属性提供给子类，以 Controller 为例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/668104/202004/668104-20200401013226915-894150528.png&quot; alt=&quot;1585671766565&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;第二条：&quot;&gt;第二条：&lt;/h3&gt;
&lt;p&gt;在上面的Controller基类注入 ILogger，然后设置了 Logger 属性，这样子类就可以使用 Logger 属性来使用日志。&lt;/p&gt;
&lt;p&gt;这样做每次都要调用 base 将依赖对象传递给基类，如果继承关系有多层，将会造成更大的影响。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/668104/202004/668104-20200401013226386-1626101375.png&quot; alt=&quot;1585671919190&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;注意：本文演示只以日志来举例，如果只有一个ILogger我觉得还可以忍受，实际情况中并非只有一个，比如本地化等等。博主不提倡有上面演示情况的就用属性注入，当到达一定数量才使用，比如在 Controller 或者应用服务这种&lt;strong&gt;数量多的对象&lt;/strong&gt;以及当这些对象需要的共同的注入类型达到一定数量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;四-伪属性注入核心思想&quot;&gt;四. 伪属性注入核心思想&lt;/h2&gt;
&lt;p&gt;依托于 ASP.NET Core 自带的容器，在 Resolve Service 时，为需要“属性注入”的属性进行赋值，可以使用 自带容器提供的 &lt;code&gt;ImplementationFactory&lt;/code&gt; 来实现。&lt;/p&gt;
&lt;h2 id=&quot;五-为-controller-实现伪属性注入&quot;&gt;五. 为 Controller 实现伪属性注入&lt;/h2&gt;
&lt;p&gt;Controller 的实现较为特殊，Controller 默认是不会通过自带容器来 Resolve&amp;amp;Activate 的，是通过MVC自身管理的，但是微软提供了这样的方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;services.AddControllers().AddControllersAsServices();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以通过调用 &lt;code&gt;AddControllersAsServices()&lt;/code&gt; 方法来让 Controller 使用自带容器，其主要源代码如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/668104/202004/668104-20200401013225866-108548464.png&quot; alt=&quot;1585673407205&quot;/&gt;&lt;/p&gt;
&lt;p&gt;根据第四小节的思想，我们需要 Controller Resolve 时，来对属性进行赋值，那么我们需要改造 Controller 激活器。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;定义 Controller 基类&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/668104/202004/668104-20200401013225244-2133931778.png&quot; alt=&quot;1585673817076&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;Controller 继承基类&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/668104/202004/668104-20200401013224701-176205022.png&quot; alt=&quot;1585673605165&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;改造 Controller 激活器&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/668104/202004/668104-20200401013223429-462289742.png&quot; alt=&quot;1585673898053&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到我们改造的代码也就几行。&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;替换默认 Controller 激活器&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;services.AddControllers().AddControllersAsServices();
services.Replace(ServiceDescriptor.Transient&amp;lt;IControllerActivator, XcServiceBasedControllerActivator&amp;gt;()); //替换默认 Controller 激活器
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;运行测试&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/668104/202004/668104-20200401013220461-1730139495.png&quot; alt=&quot;1585674115498&quot;/&gt;&lt;/p&gt;
&lt;p&gt;测试正常，如需其他属性的“属性注入”，参考日志这样做就行了。&lt;/p&gt;
&lt;h2 id=&quot;六-为-application-service-实现伪属性注入&quot;&gt;六. 为 Application Service 实现伪属性注入&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;只是以 Application Service 来作为讲解，同理可举一反三到其他地方。Application Service 属于领域驱动分层架构中的一层，如不了解，可自行查找资料。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;定义应用服务&lt;strong&gt;基类接口&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public interface IAppService
{
    ILogger Logger { get; set; }
}

public class AppService:IAppService
{
    public ILogger Logger { get; set; }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;定义具体服务，以 User 服务为例&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public interface IUserAppService:IAppService
{
    void Create();
}

public class UserAppService : AppService,IUserAppService
{
    public void Create()
    {
        Logger.LogInformation(&quot;来自 Application Service 的日志&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;定义特殊的注册服务的方法，以便实现 Resolve 为 Logger 赋值&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public static class ServiceExtensions
{
    public static IServiceCollection AddApplicationService&amp;lt;TService, TImpl&amp;gt;(this IServiceCollection services) where TService:IAppService where TImpl:AppService
    {
        services.AddApplicationService(typeof(TService), typeof(TImpl));
        return services;
    }
    // 可以反射程序集调用此方法实现批量自动注册应用服务
    public static IServiceCollection AddApplicationService(this IServiceCollection services, Type serviceType,Type implType)
    {
        services.AddTransient(serviceType, sp =&amp;gt;
        {
            //获取服务实现的实例
            var implInstance = ActivatorUtilities.CreateInstance(sp, implType); ;

            if (implInstance is AppService obj)
            {
                //为 Logger 赋值
                obj.Logger= sp.GetRequiredService&amp;lt;ILoggerFactory&amp;gt;().CreateLogger(implType);
            }
            
            return implInstance;
        });
        return services;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;注册测试服务&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/668104/202004/668104-20200401013219798-1540270619.png&quot; alt=&quot;1585675259627&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;Controller 注入测试服务&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/668104/202004/668104-20200401013219194-203604995.png&quot; alt=&quot;1585675328416&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;6&quot;&gt;&lt;li&gt;运行测试&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/668104/202004/668104-20200401013218333-1240655168.png&quot; alt=&quot;1585675427275&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;七结束&quot;&gt;七.结束&lt;/h2&gt;
&lt;p&gt;其实到本文写完，我都在想，要不要封装一个组件，发布到 Nuget 来方便的使用文中我所描述的“伪属性注入”，最后反复想了想，还是觉得不做。如果要使用完全的属性注入可以替换使用第三方容器，本文所述旨在不想引入第三方容器，且想在&lt;strong&gt;部分地方&lt;/strong&gt;来达到属性注入的效果，因为属性注入这个东西也不推荐大范围使用。&lt;/p&gt;
&lt;p&gt;本文来源于我在工作中的一些灵感总结，我在看 &lt;code&gt;ControllerActivator&lt;/code&gt; 源码时的突发奇想，最近工作虽然忙，但是知识确实积攒了不少，在后面与大家一一分享。&lt;/p&gt;
&lt;p&gt;姊妹篇：&lt;a href=&quot;https://www.cnblogs.com/stulzq/p/11007770.html&quot;&gt;ASP.NET Core 奇淫技巧之动态WebApi&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 31 Mar 2020 23:41:00 +0000</pubDate>
<dc:creator>晓晨Master</dc:creator>
<og:description>一.前言 开局先唠嗑一下，许久未曾更新博客，一直在调整自己的状态，去年是我的本命年，或许是应验了本命年的多灾多难，过得十分不顺，不论是生活上还是工作上。还好当我度过了所谓的本命年后，许多事情都在慢慢变</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/stulzq/p/12610026.html</dc:identifier>
</item>
</channel>
</rss>