<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>使用消息队列规避分布式事务问题 - 杨冠标</title>
<link>http://www.cnblogs.com/yanggb/p/11818558.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yanggb/p/11818558.html</guid>
<description>&lt;p&gt;前阵子从支付宝转账10000元到余额宝，这是日常生活的一件普通小事，但作为互联网研发人员的职业病，我就思考支付宝扣除1万之后，如果系统挂掉怎么办，这时余额宝账户并没有增加10000，数据就会出现不一致状况了。这样的场景在各个类型的系统中都能找到相似的影子，比如在电商系统中，当有用户下单后，除了在订单表插入一条记录外，对应商品表的这个商品数量也必须减1；在搜索广告系统中，当用户点击某广告后，除了在点击事件表中增加一条记录外，还得去商家账户表中找到这个商家并扣除广告费等等，相信大家或多或多少都能碰到相似情景。这些问题本质上都可以抽象为当一个表数据更新后，怎么保证另一个表的数据也必须要更新成功的问题，也就是事务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;本地事务&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;事务是为了保证同一个事务中的操作同时成功或同时失败的一种机制。还是以支付宝转账余额宝为例，假设有支付宝账户表：A（id，userId，amount），余额宝账户表：B（id，userId，amount），用户的userId是1，那么可以将从支付宝转账1万块钱到余额宝的动作分为以下两步：&lt;/p&gt;
&lt;p&gt;1）支付宝表扣除1万。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;update&lt;/span&gt; A &lt;span&gt;set&lt;/span&gt; amount &lt;span&gt;=&lt;/span&gt; amount &lt;span&gt;-&lt;/span&gt; &lt;span&gt;10000&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; userId &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2）余额宝表增加1万。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;update&lt;/span&gt; B &lt;span&gt;set&lt;/span&gt; amount &lt;span&gt;=&lt;/span&gt; amount &lt;span&gt;+&lt;/span&gt; &lt;span&gt;10000&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; userId &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如何确保支付宝余额宝收支平衡呢？有人说这个很简单嘛，可以用事务解决。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Begin&lt;/span&gt; &lt;span&gt;transaction&lt;/span&gt;
    &lt;span&gt;update&lt;/span&gt; A &lt;span&gt;set&lt;/span&gt; amount &lt;span&gt;=&lt;/span&gt; amount &lt;span&gt;-&lt;/span&gt; &lt;span&gt;10000&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; userId &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;update&lt;/span&gt; B &lt;span&gt;set&lt;/span&gt; amount &lt;span&gt;=&lt;/span&gt; amount &lt;span&gt;+&lt;/span&gt; &lt;span&gt;10000&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; userId &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;End&lt;/span&gt; &lt;span&gt;transaction&lt;/span&gt;
&lt;span&gt;commit&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;非常正确！如果你使用Spring的话一个@Transaction注解就能搞定上述事务功能。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
@Transactional(rollbackFor=Exception.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; update() {
    updateATable(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 更新A表&lt;/span&gt;
    updateBTable(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 更新B表&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果系统规模较小，数据表都在一个数据库实例上，上述本地事务方式可以很好地运行，但是如果系统规模较大，比如在上面的场景中，支付宝账户表和余额宝账户表显然不会在同一个数据库实例上，他们往往分布在不同的物理节点上，这时本地事务已经失去用武之地。&lt;/p&gt;
&lt;p&gt;既然本地事务失效，分布式事务自然就登上舞台。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;分布式事务—两阶段提交协议&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;两阶段提交协议（Two-phase Commit，2PC）经常被用来实现分布式事务。一般分为协调器C和若干事务执行者Si两种角色，这里的事务执行者就是具体的数据库，协调器可以和事务执行器在一台机器上。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images0.cnblogs.com/blog2015/522490/201508/091642197846523.png&quot; alt=&quot;&quot; width=&quot;624&quot; height=&quot;262&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1.我们的应用程序（client）发起一个开始请求到TC。&lt;/p&gt;
&lt;p&gt;2.TC先将&amp;lt;prepare&amp;gt;消息写到本地日志，之后向所有的Si发起&amp;lt;prepare&amp;gt;消息。以支付宝转账到余额宝为例，TC给A的prepare消息是通知支付宝数据库相应账目扣款1w，TC给B的prepare消息是通知余额宝数据库相应账目增加1w。为什么在执行任务前需要先写本地日志，主要是为了故障后恢复用，本地日志起到现实生活中凭证的效果，如果没有本地日志（凭证），容易死无对证。&lt;/p&gt;
&lt;p&gt;3.Si收到&amp;lt;prepare&amp;gt;消息后，执行具体本机事务，但不会进行commit，如果成功返回&amp;lt;yes&amp;gt;，不成功返回&amp;lt;no&amp;gt;。同理，返回前都应把要返回的消息写到日志里，当作凭证。&lt;/p&gt;
&lt;p&gt;4.TC收集所有执行器返回的消息，如果所有执行器都返回yes，那么给所有执行器发生送commit消息，执行器收到commit后执行本地事务的commit操作；如果有任一个执行器返回no，那么给所有执行器发送abort消息，执行器收到abort消息后执行事务abort操作。&lt;/p&gt;
&lt;p&gt;要注意的是，TC或Si把发送或接收到的消息先写到日志里，主要是为了故障后恢复用。如某一Si从故障中恢复后，先检查本机的日志，如果已收到&amp;lt;commit&amp;gt;，则提交，如果&amp;lt;abort&amp;gt;则回滚。如果是&amp;lt;yes&amp;gt;，则再向TC询问一下，确定下一步。如果什么都没有，则很可能在&amp;lt;prepare&amp;gt;阶段Si就崩溃了，因此需要回滚。&lt;/p&gt;
&lt;p&gt;现如今实现基于两阶段提交的分布式事务也没那么困难了，如果使用Java，那么可以使用开源软件atomikos(&lt;a href=&quot;http://www.atomikos.com/&quot;&gt;http://www.atomikos.com/&lt;/a&gt;)来快速实现。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;两阶段提交的缺点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;只是但凡使用过的上述两阶段提交的同学都可以发现性能实在是太差，根本不适合高并发的系统。&lt;/p&gt;
&lt;p&gt;1.两阶段提交涉及多次节点间的网络通信，通信时间太长。&lt;/p&gt;
&lt;p&gt;2.事务时间相对于变长了，锁定的资源的时间也变长了，造成资源等待时间也增加很多。&lt;/p&gt;
&lt;p&gt;正是由于分布式事务存在很严重的性能问题，大部分高并发服务都在避免使用，往往通过其他途径来解决数据一致性问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;使用消息队列来避免分布式事务&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果仔细观察生活的话，生活的很多场景已经给了我们提示。比如现在去一些食店吃饭，是到一个窗口先点餐付钱，付钱的窗口给你一个凭证，然后你根据这个凭证到另一个窗口去取餐。这样的做法好处有很多，其中一个重要的好处就是能有效避免有的人吃了饭没有付钱，因为如果在取餐的窗口没有出示有效的凭证，是不会给你取餐的。&lt;/p&gt;
&lt;p&gt;还是回到我们的问题，只要有这张凭证，你最终是能吃上你花钱买的饭的。同理转账服务也是如此，当支付宝账户扣除1万后，我们只要生成一个凭证（消息）即可，这个凭证（消息）上写着【让余额宝账户增加1W】，只要这个凭证（消息）能可靠保存，我们最终是可以拿着这个凭证（消息）让余额宝账户增加1万的，即我们能依靠这个凭证（消息）完成最终一致性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;可靠保存凭证（消息）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在上面的生活例子中，如果我们把取餐的凭证弄丢了，那么我们就吃不上花钱买的饭了。同理，如果【让余额宝账户增加1W】的这个凭证没有保存下来而被丢失，那么就会造成损失。因此保证能可靠地保存凭证也就尤为重要，主要有两种方法：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;业务与消息耦合的方式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;支付宝在完成扣款的同时，同时记录消息数据，这个消息数据与业务数据保存在同一数据库实例里（消息记录表表名为message）；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Begin&lt;/span&gt; &lt;span&gt;transaction&lt;/span&gt;
    &lt;span&gt;update&lt;/span&gt; A &lt;span&gt;set&lt;/span&gt; amount &lt;span&gt;=&lt;/span&gt; amount &lt;span&gt;-&lt;/span&gt; &lt;span&gt;10000&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; userId &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; message(userId, amount, status) &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;10000&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;End&lt;/span&gt; &lt;span&gt;transaction&lt;/span&gt;
&lt;span&gt;commit&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述事务能保证只要支付宝账户里被扣了钱，消息一定能保存下来。&lt;/p&gt;
&lt;p&gt;当上述事务提交成功后，我们通过实时消息服务将此消息通知余额宝，余额宝处理成功后发送回复成功消息，支付宝收到回复后删除该条消息数据。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;业务与消息解耦方式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;上述保存消息的方式使得消息数据和业务数据紧耦合在一起，从架构上看不够优雅，而且容易诱发其他问题。为了解耦，可以采用以下方式。&lt;/p&gt;
&lt;p&gt;1.支付宝在扣款事务提交之前，向实时消息服务请求发送消息，实时消息服务只记录消息数据，而不真正发送，只有消息发送成功后才会提交事务。&lt;/p&gt;
&lt;p&gt;2.当支付宝扣款事务被提交成功后，向实时消息服务确认发送。只有在得到确认发送指令后，实时消息服务才真正发送该消息。&lt;/p&gt;
&lt;p&gt;3.当支付宝扣款事务提交失败回滚后，向实时消息服务取消发送。在得到取消发送指令后，该消息将不会被发送。&lt;/p&gt;
&lt;p&gt;4.对于那些未确认的消息或者取消的消息，需要有一个消息状态确认系统定时去支付宝系统查询这个消息的状态并进行更新。为什么需要这一步骤，举个例子：假设在第2步支付宝扣款事务被成功提交后，系统挂了，此时消息状态并未被更新为【确认发送】，从而导致消息不能被发送。&lt;/p&gt;
&lt;p&gt;优点：消息数据独立存储，降低业务系统与消息系统间的耦合。&lt;/p&gt;
&lt;p&gt;缺点：一次消息发送需要两次请求；业务处理服务需要实现消息状态回查接口。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;消息重复投递的问题&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;还有一个很严重的问题就是消息重复投递，以我们支付宝转账到余额宝为例，如果相同的消息被重复投递两次，那么我们余额宝账户将会增加2w而不是1w了。&lt;/p&gt;
&lt;p&gt;为什么相同的消息会被重复投递？比如余额宝处理完消息msg后，发送了处理成功的消息给支付宝，正常情况下支付宝应该要删除消息msg，但如果支付宝这时候悲剧的挂了，重启后一看消息msg还在，就会继续发送消息msg。&lt;/p&gt;
&lt;p&gt;解决方法很简单，在余额宝这边增加消息应用状态表（message_apply），通俗来说就是个账本，用于记录消息的消费情况，每次来一个消息，在真正执行之前，先去消息应用状态表中查询一遍，如果找到说明是重复消息，丢弃即可，如果没找到才执行，同时插入到消息应用状态表（同一事务）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt; each msg &lt;span&gt;in&lt;/span&gt;&lt;span&gt; queue
  &lt;/span&gt;&lt;span&gt;Begin&lt;/span&gt; &lt;span&gt;transaction&lt;/span&gt;
    &lt;span&gt;select&lt;/span&gt; &lt;span&gt;count&lt;/span&gt;(&lt;span&gt;*&lt;/span&gt;) &lt;span&gt;as&lt;/span&gt; cnt &lt;span&gt;from&lt;/span&gt; message_apply &lt;span&gt;where&lt;/span&gt; msg_id &lt;span&gt;= &lt;/span&gt;&lt;span&gt;msg.msg_id;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; cnt &lt;span&gt;== &lt;/span&gt;&lt;span&gt;0&lt;/span&gt; &lt;span&gt;then&lt;/span&gt;
      &lt;span&gt;update&lt;/span&gt; B &lt;span&gt;set&lt;/span&gt; amount &lt;span&gt;= &lt;/span&gt;amount &lt;span&gt;+ &lt;/span&gt;&lt;span&gt;10000&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; userId &lt;span&gt;= &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
      &lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; message_apply(msg_id) &lt;span&gt;values&lt;/span&gt;&lt;span&gt;(msg.msg_id);
  &lt;/span&gt;&lt;span&gt;End&lt;/span&gt; &lt;span&gt;transaction&lt;/span&gt;
  &lt;span&gt;commit&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Ebay的研发人员早在2008年就提出了应用消息状态确认表来解决消息重复投递的问题：&lt;a href=&quot;http://queue.acm.org/detail.cfm?id=1394128&quot;&gt;http://queue.acm.org/detail.cfm?id=1394128&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&quot;世间所有的相遇都是久别重逢，而你没有如期归来，这正是离别的意义。&quot;&lt;/p&gt;
</description>
<pubDate>Fri, 20 Dec 2019 23:54:00 +0000</pubDate>
<dc:creator>杨冠标</dc:creator>
<og:description>前阵子从支付宝转账10000元到余额宝，这是日常生活的一件普通小事，但作为互联网研发人员的职业病，我就思考支付宝扣除1万之后，如果系统挂掉怎么办，这时余额宝账户并没有增加10000，数据就会出现不一致</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yanggb/p/11818558.html</dc:identifier>
</item>
<item>
<title>软件设计的哲学： 第十章 定义不存在错误 - peida</title>
<link>http://www.cnblogs.com/peida/p/12075767.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/peida/p/12075767.html</guid>
<description>&lt;p&gt;&lt;strong&gt;异常处理是软件系统中最糟糕的复杂性来源之一&lt;/strong&gt;。处理特殊情况的代码天生就比处理正常情况的代码更难编写，而且开发人员经常在定义异常时没有考虑如何处理它们。本章讨论了异常对复杂性的不成比例的贡献，然后展示了如何简化异常处理。本章的主要教训是减少必须处理异常的地方；在许多情况下，可以修改操作的语义，使正常行为可以处理所有情况，并且不需要报告任何异常情况(这就是本章的标题)。&lt;/p&gt;
&lt;h2 id=&quot;异常增加复杂性的原因&quot;&gt;10.1 异常增加复杂性的原因&lt;/h2&gt;
&lt;p&gt;我使用术语异常来指改变程序中正常控制流的任何不寻常的情况。许多编程语言都包含一个正式的异常机制，该机制允许底层代码抛出异常并通过封装代码捕获异常。但是，即使不使用正式的异常报告机制，也可能发生异常，例如当一个方法返回一个特殊值，表明它没有完成正常行为。所有这些形式的异常都增加了复杂性。&lt;/p&gt;
&lt;p&gt;一段特定的代码可能会遇到几种不同的异常：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;调用者可能提供错误的参数或配置信息。&lt;/li&gt;
&lt;li&gt;被调用的方法可能无法完成请求的操作。例如，I/O操作可能失败，或者所需的资源可能不可用。&lt;/li&gt;
&lt;li&gt;在分布式系统中，网络数据包可能丢失或延迟，服务器可能无法及时响应，或者对等节点可能以无法预料的方式通信。&lt;/li&gt;
&lt;li&gt;代码可能会检测出bug、内部不一致或无法处理的情况。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;大型系统必须处理许多异常情况，特别是当它们是分布式的或者需要容错的时候。异常处理占系统中所有代码的很大一部分。&lt;/p&gt;
&lt;p&gt;异常处理代码天生就比正常情况下的代码更难写。异常中断了正常的代码流；它通常意味着某事没有像预期的那样工作。当异常发生时，程序员可以用两种方法处理它，每种方法都很复杂。第一种方法是向前推进并完成正在进行的工作，尽管存在例外。例如，如果一个网络数据包丢失，它可以被重发;如果数据损坏了，也许可以从冗余副本中恢复。第二种方法是中止正在进行的操作，向上报告异常。但是，中止可能很复杂，因为异常可能发生在系统状态不一致的地方(数据结构可能已经部分初始化)；异常处理代码必须恢复一致性，例如通过撤销发生异常之前所做的任何更改。&lt;/p&gt;
&lt;p&gt;此外，异常处理代码为更多的异常创造了机会。考虑重新发送丢失的网络包的情况。也许包裹实际上并没有丢失，只是被耽搁了。在这种情况下，重新发送数据包将导致重复的数据包到达对等点；这引入了一个新的异常条件，对等方必须处理。或者，考虑从冗余副本中恢复丢失的数据的情况：如果冗余副本也丢失了怎么办？在恢复期间发生的次要异常通常比主要异常更微妙和复杂。如果通过中止正在进行的操作来处理异常，则必须将此异常作为另一个异常报告给调用者。为了防止异常的无休止级联，开发人员最终必须找到一种方法来处理异常，而不引入更多的异常。&lt;/p&gt;
&lt;p&gt;对异常的语言支持往往冗长而笨拙，这使得异常处理代码难以阅读。例如，考虑以下代码，它使用Java对对象序列化和反序列化的支持从文件中读取tweet集合：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;try (
      FileInputStream fileStream =new FileInputStream(fileName);
      BufferedInputStream bufferedStream =new BufferedInputStream(fileStream);
      ObjectInputStream objectStream =new ObjectInputStream(bufferedStream);

) 
{
      for (int i = 0; i &amp;lt; tweetsPerFile; i++) {
            tweets.add((Tweet) objectStream.readObject());
      }

}
catch (FileNotFoundException e) {
      ...
}

catch (ClassNotFoundException e) {
      ...
}
catch (EOFException e) {
      // Not a problem: not all tweet files have full
      // set of tweets.
}

catch (IOException e) {
      ...
}

catch (ClassCastException e) {
      ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是，基本的try-catch样板代码比正常情况下的操作代码行数更多，甚至不考虑实际处理异常的代码。很难将异常处理代码与正常情况代码联系起来：例如，在哪里生成每个异常并不明显。另一种方法是把代码分成许多不同的try块;在极端情况下，可以尝试生成异常的每一行代码。这将使异常发生的地方变得清晰，但是try块本身会破坏代码流，使其更难读取；此外，一些异常处理代码可能会在多个try块中重复。&lt;/p&gt;
&lt;p&gt;很难确保异常处理代码真正有效。有些异常，比如I/O错误，在测试环境中很难生成，因此很难测试处理它们的代码。异常在运行的系统中不经常发生，所以很少执行异常处理代码。bug可能很长一段时间都无法检测到，当最终需要异常处理代码时，它很可能无法工作(我最喜欢的说法之一是:“未执行的代码无法工作”)。最近的一项研究发现，在分布式数据密集型系统中，超过90%的灾难性故障是由错误处理引起的。当异常处理代码失败时，很难调试问题，因为它发生的频率很低。&lt;/p&gt;
&lt;h2 id=&quot;例外情况太多&quot;&gt;10.2 例外情况太多&lt;/h2&gt;
&lt;p&gt;程序员通过定义不必要的异常而加剧了与异常处理相关的问题。大多数程序员都被告知检测和报告错误很重要；他们通常将其解释为“检测到的错误越多越好”。这导致了一种过度防御的风格，任何看起来有点可疑的东西都会被异常拒绝，这导致了不必要的异常的扩散，增加了系统的复杂性。&lt;/p&gt;
&lt;p&gt;在设计Tcl脚本语言时，我自己也犯了这个错误。Tcl包含一个未设置的命令，可用于删除变量。我定义了unset以便在变量不存在时抛出错误。当时我认为，如果有人试图删除一个不存在的变量，那么它一定是一个bug，所以Tcl应该报告它。然而，unset最常见的用途之一是清理以前操作创建的临时状态。通常很难准确地预测创建了什么状态，特别是在操作中途中止的情况下。因此，最简单的方法是删除可能已经创建的所有变量。unset的定义使得这种情况很尴尬:开发人员最终会在catch语句中封装对unset的调用，以捕获并忽略unset抛出的错误。回顾过去，unset命令的定义是我在Tcl设计中犯下的最大错误之一。&lt;/p&gt;
&lt;p&gt;使用异常来避免处理困难的情况是很有诱惑力的：与其找出一个干净的方法来处理它，不如抛出一个异常并把问题推给调用者。有些人可能会认为这种方法赋予了调用者权力，因为它允许每个调用者以不同的方式处理异常。然而，如果你在特定情况下不知道该怎么做，很有可能打电话的人也不知道该怎么做。在这种情况下生成异常只会将问题传递给其他人，并增加系统的复杂性。&lt;/p&gt;
&lt;p&gt;类抛出的异常是其接口的一部分；具有大量异常的类具有复杂的接口，并且它们比具有较少异常的类要浅。异常是接口中特别复杂的元素。它可以在被捕获之前向上传播几个堆栈级别，因此它不仅影响方法的调用者，还可能影响更高级别的调用者(及其接口)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;抛出异常很容易，处理它们很困难。因此，异常的复杂性来自于异常处理代码。减少异常处理造成的复杂性损害的最佳方法是减少必须处理异常的地方的数量。&lt;/strong&gt; 本章的其余部分将讨论减少异常处理程序数量的四种技术。&lt;/p&gt;
&lt;h2 id=&quot;定义不存在的错误&quot;&gt;10.3 定义不存在的错误&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;消除异常处理复杂性的最佳方法是定义api，这样就没有异常需要处理：定义不存在的错误。&lt;/strong&gt; 这可能看起来有些亵渎，但在实践中却非常有效。考虑前面讨论的Tcl unset命令。当unset被要求删除一个未知变量时，它应该简单地返回，而不是抛出一个错误。我应该稍微修改一下unset的定义：unset应该确保一个变量不再存在，而不是删除一个变量。对于第一个定义，如果变量不存在，unset就无法执行其任务，因此生成异常是有意义的。对于第二个定义，使用不存在的变量的名称来调用unset是非常自然的。在这种情况下，它的工作已经完成，所以它可以简单地返回。不再需要报告错误情况。&lt;/p&gt;
&lt;h2 id=&quot;示例在windows中删除文件&quot;&gt;10.4 示例：在Windows中删除文件&lt;/h2&gt;
&lt;p&gt;文件删除提供了另一个如何定义错误的例子。如果文件在进程中打开，Windows操作系统不允许删除该文件。对于开发人员和用户来说，这是一个持续的沮丧之源。为了删除正在使用的文件，用户必须在系统中搜索，找到打开该文件的进程，然后杀死该进程。有时用户会放弃并重新启动他们的系统，只是为了删除一个文件。&lt;/p&gt;
&lt;p&gt;Unix操作系统更优雅地定义了文件删除。在Unix中，如果文件在删除时打开，Unix不会立即删除该文件。&lt;/p&gt;
&lt;p&gt;它将文件标记为删除，然后删除操作成功返回。该文件名已从其目录中删除，因此其他进程无法打开旧文件，并且可以创建具有相同名称的新文件，但现有的文件数据将持续存在。已经打开文件的进程可以继续正常地读取和写入文件。一旦文件被所有访问进程关闭，它的数据就会被释放。&lt;/p&gt;
&lt;p&gt;Unix方法定义了两种不同的错误。首先，删除操作不再返回一个错误，如果文件当前正在使用；删除成功，文件最终将被删除。其次，删除正在使用的文件不会为使用该文件的进程创建异常。解决这个问题的一种可能的方法是立即删除文件，并标记所有打开的文件来禁用它们；其他进程读取或写入删除文件的任何尝试都将失败。但是，这种方法会为那些要处理的进程创建新的错误。相反，Unix允许它们继续正常地访问文件；延迟文件删除定义了不存在的错误。&lt;/p&gt;
&lt;p&gt;Unix允许进程继续读写一个命中注定的文件，这似乎有些奇怪，但我从未遇到过这种情况，它会导致严重的问题。对于开发人员和用户来说，Unix下的文件删除定义要比Windows下的定义简单得多。&lt;/p&gt;
&lt;h2 id=&quot;示例java子字符串方法&quot;&gt;10.5 示例：Java子字符串方法&lt;/h2&gt;
&lt;p&gt;最后一个例子是Java String类及其子String方法。给定一个字符串中的两个索引，substring返回从第一个索引给出的字符开始并以第二个索引之前的字符结束的子字符串。但是，如果其中一个索引超出了字符串的范围，则子字符串将抛出IndexOutOfBoundsException。此异常是不必要的，并使此方法的使用复杂化。我经常遇到这样的情况，其中一个或两个索引可能在字符串的范围之外，我希望提取字符串中与指定范围重叠的所有字符。不幸的是，这需要我检查每一个指标，把它们四舍五入到0或到字符串的末尾；一个单行的方法调用现在变成了5-10行代码。&lt;/p&gt;
&lt;p&gt;如果Java子字符串方法自动执行此调整，那么它将更容易使用，以便实现以下API:“返回索引大于或等于beginIndex而小于endIndex的字符串字符(如果有的话)。这是一个简单而自然的API，它定义了IndexOutOfBoundsException异常。即使一个或两个索引是负的，或者beginIndex大于endIndex，该方法的行为也已经定义好了。这种方法简化了方法的API，同时增加了它的功能，因此使方法更加深入。许多其他语言都采用了无错误的方法;例如，Python为超出范围的列表片返回一个空结果。&lt;/p&gt;
&lt;p&gt;当我主张定义不存在的错误时，人们有时反驳说抛出错误会捕获bug；如果错误被定义为不存在，那么这是否会导致bug生成？也许这就是为什么Java开发人员决定子字符串应该抛出异常的原因。这种错误的方法可能会捕获一些bug，但也会增加复杂性，从而导致其他bug。在错误的方法中，开发人员必须编写额外的代码来避免或忽略错误，这增加了错误的可能性；或者，他们可能忘记编写额外的代码，在这种情况下，可能会在运行时抛出意外的错误。相反，定义不存在的错误简化了api，并减少了必须编写的代码量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总的来说，减少错误的最好方法是使软件更简单。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;屏蔽异常&quot;&gt;10.6 屏蔽异常&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;减少必须处理异常的位置数量的第二种技术是异常屏蔽。&lt;/strong&gt; 使用这种方法，可以在系统的较低级别上检测和处理异常情况，这样较高级别的软件就不必知道该情况。异常屏蔽在分布式系统中特别常见。例如，在网络传输协议(如TCP)中，可以由于各种原因(如损坏和拥塞)丢弃数据包。TCP通过在其实现中重新发送丢失的包来掩盖包丢失，因此所有数据最终都能通过，而客户端并不知道丢失的包。&lt;/p&gt;
&lt;p&gt;NFS网络文件系统中出现了一个更具争议性的屏蔽示例。如果NFS文件服务器崩溃或由于任何原因没有响应，客户端会不断地向服务器重新发出请求，直到问题最终得到解决。客户机上的低级文件系统代码不向调用应用程序报告任何异常。正在进行的操作(以及应用程序)只是挂起，直到操作成功完成。如果挂起持续的时间较长，那么NFS客户机将在用户的控制台打印“NFS服务器xyzzy没有响应，仍然在尝试”的消息。&lt;/p&gt;
&lt;p&gt;NFS用户经常抱怨他们的应用程序在等待NFS服务器恢复正常操作时挂起。许多人建议，NFS应该在异常情况下中止操作，而不是挂起。然而，报告异常只会使事情变得更糟，而不是更好。如果一个应用程序失去了对其文件的访问权，那么它就无能为力了。一种可能性是应用程序重试文件操作,但这仍将把应用程序,并且更容易执行重试在NFS层在一个地方,而不是在每个文件系统调用在每个应用程序(编译器不应该担心这个)。另一种方法是应用程序中止并将错误返回给调用者。调用方也不太可能知道该做什么，所以它们也会中止，从而导致用户的工作环境崩溃。当文件服务器关闭时，用户仍然无法完成任何工作，而且一旦文件服务器恢复正常，他们将不得不重新启动所有应用程序。&lt;/p&gt;
&lt;p&gt;因此，最佳的替代方案是NFS屏蔽错误并挂起应用程序。使用这种方法，应用程序不需要任何代码来处理服务器问题，一旦服务器恢复正常，它们就可以无缝地恢复。如果用户厌倦了等待，他们总是可以手动中止应用程序。&lt;/p&gt;
&lt;p&gt;异常屏蔽并非在所有情况下都有效，但在它有效的情况下，它是一个强大的工具。它会产生更深层的类，因为它减少了类的接口(减少了用户需要注意的异常)，并以代码的形式增加了掩盖异常的功能。异常屏蔽是降低复杂性的一个例子。&lt;/p&gt;
&lt;h2 id=&quot;异常聚合&quot;&gt;10.7 异常聚合&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;第三种减少异常复杂性的技术是异常聚合。异常聚合背后的思想是用一段代码处理许多异常；与其为许多单独的异常编写不同的处理程序，不如使用单个处理程序在一个地方处理它们。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;考虑如何处理Web服务器中丢失的参数。Web服务器实现一个url集合。当服务器接收到传入的URL时，它将发送到特定于URL的服务方法来处理该URL并生成响应。URL包含用于生成响应的各种参数。每个服务方法将调用一个较低级别的方法(让我们将其称为getParameter)来从URL中提取所需的参数。如果URL不包含所需的参数，则getParameter抛出异常。&lt;/p&gt;
&lt;p&gt;当软件设计类的学生实现这样一个服务器时，他们中的许多人将每个不同的getParameter调用包装在一个单独的异常处理程序中，以捕获NoSuchParameter异常，如图10.1所示。这导致了大量的处理程序，所有的处理程序本质上都做相同的事情(生成错误响应)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/34483/201912/34483-20191221071230216-2071498139.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图10.1：顶部的代码分派给Web服务器中的几个方法中的一个，每个方法处理一个特定的URL。每个方法(底部)都使用来自传入HTTP请求的参数。在这个图中，每个对getParameter的调用都有一个单独的异常处理程序;这会导致重复的代码。&lt;/p&gt;
&lt;p&gt;更好的方法是聚合异常。不捕获各个服务方法中的异常，而是让它们向上传播到Web服务器的顶级分派方法，如图10.2所示。此方法中的单个处理程序可以捕获所有异常并为丢失的参数生成适当的错误响应。&lt;/p&gt;
&lt;p&gt;聚合方法可以在Web示例中更进一步。除了在处理Web页面时可能出现的参数丢失之外，还有许多其他错误;例如，参数可能没有正确的语法(服务方法期望的是一个整数，但是值是“xyz”)，或者用户可能没有请求操作的权限。在每种情况下，错误应该导致错误响应；错误只在响应中包含的错误消息中有所不同(“URL中不存在参数‘quantity’”或“quantity”参数的“bad value’xyz”;必须是正整数”)。因此，导致错误响应的所有条件都可以使用一个顶级异常处理程序来处理。可以在抛出异常时生成错误消息，并将其作为变量包含在异常记录中;例如，getParameter将生成“URL中不存在参数‘quantity’”消息。顶级处理程序从异常中提取消息并将其合并到错误响应中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/34483/201912/34483-20191221071245677-1927368349.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图10.2：这段代码在功能上与图10.1相同，但是异常处理已经聚合:dispatcher中的一个异常处理程序从所有url特定的方法捕获所有NoSuchParameter异常。&lt;/p&gt;
&lt;p&gt;从封装和信息隐藏的角度来看，上述聚合具有良好的特性。顶级异常处理程序封装了关于如何生成错误响应的知识，但它对特定的错误一无所知；它只使用异常中提供的错误消息。getParameter方法封装了有关如何从URL提取参数的知识，并且还知道如何以人类可读的形式描述提取错误。这两条信息是密切相关的，所以把它们放在一起是有道理的。但是，getParameter对HTTP错误响应的语法一无所知。随着新功能被添加到Web服务器，像getParameter这样的新方法可能会创建它们自己的错误。如果新方法以与getParameter相同的方式抛出异常(通过生成从相同超类继承的异常，并在每个异常中包含一条错误消息)，它们可以插入到现有的系统中，而不需要进行其他更改：顶级处理程序将自动为它们生成错误响应。&lt;/p&gt;
&lt;p&gt;此示例演示了用于异常处理的通用设计模式。如果系统处理了一系列请求，那么定义一个异常来中止当前请求、清理系统状态并继续下一个请求是很有用的。异常捕获在系统请求处理循环顶部附近的单个位置。此异常可在处理请求的任何时刻抛出，以中止请求;可以为不同的条件定义异常的不同子类。这种类型的异常应该与对整个系统致命的异常明确区分开来。&lt;/p&gt;
&lt;p&gt;如果异常在处理之前在堆栈上向上传播了几个级别，则异常聚合工作得最好;这允许在同一个地方处理来自更多方法的更多异常。这与异常掩蔽相反：掩蔽通常在用低级方法处理异常时工作得最好。对于掩蔽，低级方法通常是许多其他方法使用的库方法，因此允许异常传播将增加处理它的位置的数量。屏蔽和聚合的相似之处在于，这两种方法都将异常处理程序放置在能够捕获最多异常的位置，从而消除了许多需要创建的处理程序。&lt;/p&gt;
&lt;p&gt;另一个异常聚合的例子发生在用于崩溃恢复的RAMCloud存储系统中。RAMCloud系统由一组存储服务器组成，这些服务器保存每个对象的多个副本，因此系统可以从各种故障中恢复。例如，如果服务器崩溃并丢失了所有数据，RAMCloud将使用存储在其他服务器上的副本来重新构建丢失的数据。错误也可能在较小的范围内发生；例如，服务器可能发现某个对象已损坏。&lt;/p&gt;
&lt;p&gt;对于每种不同类型的错误，RAMCloud没有单独的恢复机制。相反，RAMCloud将许多较小的错误“提升”为较大的错误。原则上，RAMCloud可以通过从备份副本中恢复一个损坏的对象来处理这个损坏的对象。然而，它并不这样做。相反，如果它发现一个损坏的对象，它会使包含该对象的服务器崩溃。RAMCloud使用这种方法是因为崩溃恢复非常复杂，而且这种方法最小化了必须创建的不同恢复机制的数量。为崩溃的服务器创建恢复机制是不可避免的，因此RAMCloud对其他类型的恢复也使用相同的机制。这减少了必须编写的代码量，而且这还意味着服务器崩溃恢复将更频繁地被调用。因此，恢复中的bug更有可能被发现和修复。&lt;/p&gt;
&lt;p&gt;将损坏的对象升级到服务器崩溃的一个缺点是，它大大增加了恢复的成本。这在RAMCloud中不是问题，因为对象损坏非常罕见。然而，错误提升对于频繁发生的错误可能没有意义。举个例子，当一个服务器的网络数据包丢失时，它不可能崩溃。&lt;/p&gt;
&lt;p&gt;考虑异常聚合的一种方法是，它用一种能够处理多种情况的通用机制替代了几个专门用于特定情况的机制。这又一次说明了通用机制的好处。&lt;/p&gt;
&lt;h2 id=&quot;事故&quot;&gt;10.8 事故?&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;降低异常处理复杂性的第四种技术是使应用程序崩溃。&lt;/strong&gt; 在大多数应用程序中都会有一些不值得处理的错误。通常，这些错误很难或不可能处理，而且不经常发生。为响应这些错误，最简单的方法是打印诊断信息，然后中止应用程序。&lt;/p&gt;
&lt;p&gt;一个例子是在存储分配期间发生的“内存不足”错误。考虑C中的malloc函数，如果它不能分配所需的内存块，它将返回NULL。这是一种不幸的行为，因为它假设malloc的每个调用者都将检查返回值，并在没有内存时采取适当的操作。应用程序包含大量对malloc的调用，因此在每次调用后检查结果会增加很大的复杂性。如果程序员忘记了检查(这是很有可能的)，那么如果内存耗尽，应用程序将取消对空指针的引用，从而导致掩盖真正问题的崩溃。&lt;/p&gt;
&lt;p&gt;此外，当应用程序发现内存耗尽时，它也无能为力。原则上，应用程序可以寻找不需要的内存来释放，但是如果应用程序有不需要的内存，它可能已经释放了内存，这将在一开始就防止内存不足的错误。今天的系统有如此多的内存，以至于内存几乎永远不会用完；如果是，通常表示应用程序中有bug。因此，尝试处理内存不足的错误很少有意义;这造成了太多的复杂性，而得到的好处却太少。&lt;/p&gt;
&lt;p&gt;更好的方法是定义一个新的方法ckalloc，它调用malloc，检查结果，如果内存耗尽，则用错误消息中止应用程序。应用程序从不直接调用malloc；它总是调用ckalloc。&lt;/p&gt;
&lt;p&gt;在较新的语言(如c++和Java)中，如果内存耗尽，新的操作符会抛出异常。捕获这个异常没有多大意义，因为异常处理程序很可能也会尝试分配内存，这也会失败。动态分配内存是任何现代应用程序的基本元素，如果内存耗尽，应用程序继续运行是没有意义的；一旦检测到错误，最好立即崩溃。&lt;/p&gt;
&lt;p&gt;还有许多其他的错误示例，崩溃应用程序是有意义的。对于大多数程序，如果在读取或写入打开的文件时发生I/O错误(例如磁盘硬错误)，或者无法打开网络套接字，应用程序无法进行太多的恢复，因此使用明确的错误消息中止是一种明智的方法。这些错误并不常见，因此不太可能影响应用程序的整体可用性。如果应用程序遇到内部错误(如不一致的数据结构)，也可以使用错误消息中止。这样的条件可能表明程序中存在bug。&lt;/p&gt;
&lt;p&gt;崩溃是否可以接受取决于应用程序。对于复制的存储系统，由于I/O错误而中止是不合适的。相反，系统必须使用复制的数据来恢复丢失的任何信息。恢复机制将为程序增加相当大的复杂性，但是恢复丢失的数据是系统向用户提供的价值的重要组成部分。&lt;/p&gt;
&lt;h2 id=&quot;设计不存在的特殊情况&quot;&gt;10.9 设计不存在的特殊情况&lt;/h2&gt;
&lt;p&gt;定义错误使其不存在是有意义的，同样，定义其他特殊情况使其不存在也是有意义的。特殊情况会导致代码中充斥着if语句，这使得代码难以理解并导致bug。因此，应尽可能消除特殊情况。实现这一点的最佳方法是，以一种无需任何额外代码就能自动处理特殊情况的方式来设计正常情况。&lt;/p&gt;
&lt;p&gt;在第6章描述的文本编辑器项目中，学生必须实现一种选择文本和复制或删除选择的机制。大多数学生在他们的选择实现中引入了一个状态变量来表示选择是否存在。他们之所以选择这种方法，可能是因为有时在屏幕上看不到选择，所以在实现中表示这种概念似乎是很自然的。然而，这种方法导致了大量的检查来检测“无选择”条件，并对其进行特殊处理。&lt;/p&gt;
&lt;p&gt;通过消除“没有选择”的特殊情况，可以简化选择处理代码，使选择始终存在。当在屏幕上没有可见的选择时，可以用一个空的选择在内部表示它，它的起始位置和结束位置是相同的。使用这种方法，可以编写选择管理代码，而不需要检查“没有选择”。复制选择时，如果选择为空，则将在新位置插入0字节(如果实现正确，则不需要作为特殊情况检查0字节)。类似地，应该可以设计用于删除选择的代码，以便在不进行任何特殊情况检查的情况下处理空的情况。考虑在单行上进行选择。要删除所选内容，请提取所选内容之前的行部分，并将其与所选内容之后的行部分连接起来，以形成新行。如果选择为空，则此方法将重新生成原始行。&lt;/p&gt;
&lt;p&gt;这个例子也说明了第7章中“不同的层，不同的抽象”的思想。“无选择”的概念对于用户如何考虑应用程序的接口是有意义的，但这并不意味着它必须在应用程序内部显式地表示。有一个总是存在的选择，但有时是空的，因此是不可见的，结果是一个更简单的实现。&lt;/p&gt;
&lt;h2 id=&quot;做过了头&quot;&gt;10.10 做过了头&lt;/h2&gt;
&lt;p&gt;定义异常或在模块内部屏蔽异常，只有在模块外部不需要异常信息时才有意义。本章中的示例也是如此，比如cl unset命令和Java子字符串方法；在调用者关心由异常检测到的特殊情况的罕见情况下，可以通过其他方式获取此信息。&lt;/p&gt;
&lt;p&gt;然而，这种想法可能会走得太远。在一个用于网络通信的模块中，一个学生团队屏蔽了所有的网络异常：如果发生了网络错误，模块捕获它，丢弃它，然后继续处理，就好像没有问题一样。这意味着使用该模块的应用程序无法查明消息是否丢失或对等服务器是否故障；没有这些信息，就不可能构建健壮的应用程序。在这种情况下，即使异常增加了模块接口的复杂性，模块也必须公开异常。&lt;/p&gt;
&lt;p&gt;与软件设计中的许多其他领域一样，对于例外，您必须确定什么是重要的，什么是不重要的。不重要的事情应该隐藏起来，越多越好。但当某件事很重要时，它必须被曝光。&lt;/p&gt;
&lt;h2 id=&quot;结论&quot;&gt;10.11 结论&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;任何形式的特殊情况都会使代码更难理解，并增加bug的可能性。&lt;/strong&gt; 本章重点讨论异常，它是特殊情况代码最重要的来源之一，并讨论了如何减少必须处理异常的地方。&lt;strong&gt;最好的方法是重新定义语义来消除错误条件。对于无法定义的异常，您应该寻找机会在较低的层次上屏蔽它们，这样它们的影响就有限了，或者将几个特殊情况处理程序聚合到一个更通用的处理程序中。总之，这些技术可以对整个系统的复杂性产生重大影响。&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 20 Dec 2019 23:13:00 +0000</pubDate>
<dc:creator>peida</dc:creator>
<og:description>异常处理是软件系统中最糟糕的复杂性来源之一。任何形式的特殊情况都会使代码更难理解，并增加bug的可能性。最好的方法是重新定义语义来消除错误条件。对于无法定义的异常，您应该寻找机会在较低的层次上屏蔽它们</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/peida/p/12075767.html</dc:identifier>
</item>
<item>
<title>深度学习(001)-深度学习简介 - 李明宽</title>
<link>http://www.cnblogs.com/lixiao6/p/12075529.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lixiao6/p/12075529.html</guid>
<description>&lt;p&gt;一，简介：&lt;br/&gt;1.机器学习分支，人工神经网络(Artificial Neural Network, ANN)为基础&lt;/p&gt;
&lt;p&gt;二，与机器学习区别：&lt;br/&gt;1.机器学习人工进行特征抽取 深度学习自动进行特征抽取&lt;br/&gt;2.机器学习，数据少，相对效果不好 深度学习，数据多，相对效果更好&lt;/p&gt;
&lt;p&gt;三，人工神经网络：&lt;br/&gt;1.(Artificial Neural Network, ANN) 模仿生物神经网络(中枢 大脑)的结构和功能的数学模型 用于对函数惊醒估计或者近似 更好的解决问题&lt;/p&gt;
&lt;p&gt;四，神经元：&lt;br/&gt;1.神经网络中的基础，相互连接，组成神经网络&lt;br/&gt;2. T=f(W^TA+b)&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1268532/201912/1268532-20191220231802731-567455699.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;五，单层神经网络：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1268532/201912/1268532-20191221002001036-78346826.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;六，感知机：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1268532/201912/1268532-20191221001805866-1420851270.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;七，多层神经网络：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1268532/201912/1268532-20191221001602867-83477963.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;八，激活函数：&lt;br/&gt;1.作用：增加非线性分割能力 提高模型鲁棒性(稳健性 拟合另一波数据能力) 缓解梯度消失问题 加速模型收敛(模型训练更快)等&lt;br/&gt;2.例子：感知机二分不完全 添加激活函数使二分线直线变弯 增加区分的准确性(例子理解即可)&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1268532/201912/1268532-20191221005006432-1450458547.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其他：&lt;br/&gt;线性条件：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1268532/201912/1268532-20191221010302967-1805774875.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 20 Dec 2019 17:12:00 +0000</pubDate>
<dc:creator>李明宽</dc:creator>
<og:description>一，简介： 1.机器学习分支，人工神经网络(Artificial Neural Network, ANN)为基础 二，与机器学习区别： 1.机器学习人工进行特征抽取 深度学习自动进行特征抽取 2.机器</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lixiao6/p/12075529.html</dc:identifier>
</item>
<item>
<title>记录我的 python 学习历程-Day08 文件的操作 - Dylan_Yu</title>
<link>http://www.cnblogs.com/guanshou/p/12075610.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/guanshou/p/12075610.html</guid>
<description>&lt;h3 id=&quot;文件操作的初识&quot;&gt;文件操作的初识&lt;/h3&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;用 python 代码对文件进行各种操作。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;基本构成：&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;文件路径：path&lt;/li&gt;
&lt;li&gt;打开方式：读、写、追加、读写、写读……&lt;/li&gt;
&lt;li&gt;编码方式：utf-8 / gbk / gb2312……&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;f = open('文件路径或者相对路',encoding='编码方式',mode='模式') # 格式构成
cotent = f.read()
print(content)
f.close()&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;代码解释：&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;5.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;open：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​ 内置函数，open 底层调用的是操作系统的接口。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;&lt;strong&gt;f：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​ 变量，约定俗成的变量名有(f1,fh,file_handler,f_h)，这个变量还有一个名字，叫文件句柄。对亠件进行的任何操作，都得通过文件句柄加'.'的方式。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;encoding:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​ 可以不写，如果不写，默认的编码本就是系统默认的编码。&lt;/p&gt;
&lt;p&gt;​ Windows: gkb&lt;/p&gt;
&lt;p&gt;​ Linux: utf-8&lt;/p&gt;
&lt;p&gt;​ MacOS: utf-8&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;mode：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​ 就是定义你的操作方式：r 为读模式。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;f.read():&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​ 你想操作文件，比如读文件，给文件写内容，等等，都必须通过文件句柄进行操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;f.colse():&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​ 关闭文件。（必须关闭，否则会常驻内存。）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;文件操作的三个步骤：&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li&gt;
&lt;p&gt;打开文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;对文件句柄进行相应的操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;关闭文件。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 打开文件,得到文件句柄并赋值给一个变量
f = open('文件.txt', 'r', encoding='utf-8')   # 默认打开模式就为 r

# 通过句柄对文件进行操作
date = f.read()

# 关闭文件
f.close()&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;报错的原因：&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;UnicodeDecodeError：文件存储时与文件打开时编码本不一致。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;路径分隔符产生的问题：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;解决方法:在路径前加个 r
r'C:\Users\Desktop\文件.txt'&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;文件操作的读&quot;&gt;文件操作的：读&lt;/h3&gt;
&lt;p&gt;​ 文件操作的读，有四种模式（r、rb、r+、r+b），r+ 和 r+b 不常用， rb 操作的是非文本的文件，比如：图片、视频、音频。每种模式有五种方法（read()、read(n)、readline()、readlines()、for）。&lt;/p&gt;
&lt;ul readability=&quot;11&quot;&gt;&lt;li readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;r 模式&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​ 以只读方式打开文件，文件的指针将会放在文件的开头。是文件操作最常用的模式，也是默认模式，如果一个文件不设置mode，那么默认使用r模式操作文件。&lt;/p&gt;
&lt;p&gt;举例:&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;f = open('文件.txt', mode='r', encoding='utf-8')
msg = f.read()
f.close()
print(msg)&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;21.5&quot;&gt;&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;read()&lt;/strong&gt; 一次性全部读取&lt;/p&gt;
&lt;p&gt;read() 将文件中的内容全部读取出来； 弊端：如果文件很大就会非常的占用内存，容易导致内存崩溃。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;f = open('测试', mode='r', encoding='utf-8')
msg = f.read()
f.close()
print(msg)

# 输出结果:
这是一行测试
A:这是第二行
B:这是第三行
C:这是第几行
D:这是我也不知道第几行
就这么地吧.&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;read(n)&lt;/strong&gt; 指定读取到什么位置&lt;/p&gt;
&lt;p&gt;在 r 模式下,n 按照字符读取&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;f = open('测试', mode='r', encoding='utf-8')
msg = f.read(4)
f.close()
print(msg)

# 输出结果:
这是一行&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;readline()&lt;/strong&gt; 按行读取&lt;/p&gt;
&lt;p&gt;readline() 每次只读取一行,注意: readline() 读取出来的数据在后面都有一个\n,解决这个问题只需要在我们读取出来的文件后边加一个strip()就OK了&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;f = open('测试', mode='r', encoding='utf-8')
msg1 = f.readline()
msg2 = f.readline().strip()
msg3 = f.readline()
msg4 = f.readline()
f.close()
print(msg1)
print(msg2)
print(msg3)
print(msg4)

# 输出结果:
这是一行测试

A:这是第二行
B:这是第三行

C:这是第几行
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;14&quot;&gt;
&lt;p&gt;&lt;strong&gt;readlines()&lt;/strong&gt; 返回一个列表&lt;/p&gt;
&lt;p&gt;readlines() 返回一个列表，列表里面每个元素是原文件的每一行，如果文件很大，占内存，容易崩盘。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;f = open('测试', mode='r', encoding='utf-8')
print(f.readlines())    # 还可以这么写的,哈哈
f.close()

# 输出结果:
['这是一行测试\n', 'A:这是第二行\n', 'B:这是第三行\n', 'C:这是第几行\n', 'D:这是我也不知道第几行\n', '就这么地吧.']&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上面这四种都不太好，如果文件超大，内容超多，他们就很容易将内存撑爆，所以，我们还有第五种方法。&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;for 循环&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以通过for循环去读取，文件句柄是一个迭代器，他的特点就是每次循环只在内存中占一行的数据，非常节省内存。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;f = open('测试', mode='r', encoding='utf-8')
for line in f:
    print(line)     # 去掉 \n 可以这样写: print(line.strip())  
# 这种方式就是在一行一行的进行读取,它就执行了下边的功能

'''
print(f.readline())
print(f.readline())
print(f.readline())
.......
'''
# 输出结果:
这是一行测试

A:这是第二行

B:这是第三行

C:这是第几行

D:这是我也不知道第几行

就这么地吧.
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;特别注意: &lt;em&gt;读完的文件一定必须要关闭&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;12&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;rb 模式&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;rb模式：以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。记住下面讲的也是一样，带b的都是以二进制的格式操作文件，他们主要是操作非文字文件：图片，音频，视频等,&lt;strong&gt;并且如果你要是带有b的模式操作文件，那么不用声明编码方式。&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;f1 = open('图片.jpeg', mode='rb')
tu = f1.read()
f1.close()
print(tu)

# 输出结果:
b'\xff\xd8\xff\xe0\x00\x10JFIF\x00\x01\x01\x00\x00H\x00H\x00\x00\xff\xe1\x00\xb0Exif\x............后面还有.老长老长了..此处省略了.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;rb模式也有read read(n) readline(),readlines() for循环这几种方法，这里就不一一演示了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;文件操作的写&quot;&gt;文件操作的：写&lt;/h3&gt;
&lt;p&gt;​ 文件操作的写，有四种模式（w、wb、w+、w+b），w+ 和 w+b 不常用， wb 操作的是非文本的文件，比如：图片、视频、音频。操作方法是:write('要写入的内容')&lt;/p&gt;
&lt;ul readability=&quot;11&quot;&gt;&lt;li readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;w 模式&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果文件不存在，用 w 模式操作文件，它会先创建文件，然后写入内容。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;f = open('这是一个新创建的文件', encoding='utf-8', mode='w')
f.write('果然是一个新创建的文件')
f.close()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果文件存在，利用w模式操作文件，先清空原文件内容，在写入新内容。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;f = open('这是一个新创建的文件', encoding='utf-8', mode='w')
f.write('这是清空后重新写入的内容')
f.close()&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;wb 模式&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;wb模式：以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如：图片，音频，视频等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;&amp;gt;&amp;gt;举个例子 :&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我先以rb的模式将一个图片的内容以bytes类型全部读取出来，然后在以wb将全部读取出来的数据写入一个新文件，这样我就完成了类似于一个图片复制的流程。具体代码如下：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 第一步:将原图片通过 rb 模式读取出来。
f = open('图片.jpeg', mode='rb')
content = f.read()
f.close()
# 第二步:将读取出来的数据通过 wb 模式写入新文件。
f1 = open('图片1.jpeg', mode='wb')
f1.write(content)
f1.close()&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;文件操作的追加&quot;&gt;文件操作的：追加&lt;/h3&gt;
&lt;p&gt;就是在文件中追加内容。这里也有四种文件分类主要四种模式：a，ab，a+，a+b，&lt;strong&gt;我们只讲a&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;5.5&quot;&gt;&lt;li readability=&quot;14&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;a 模式&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果文件不存在，利用a模式操作文件，那么它会先创建文件，然后写入内容。&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;f = open('追加文本', encoding='utf-8', mode='a')
f.write('这个文件是没有的,我是新创建的')
f.close()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;如果文件存在，利用a模式操作文件，那么它会在文件的最后面追加内容。&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;f = open('追加文本', encoding='utf-8', mode='a')
f.write('这是己存在的文件,我是新追加的内容')
f.close()&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;文件操作的其它模式&quot;&gt;文件操作的其它模式&lt;/h3&gt;
&lt;p&gt;​ 咱们还有一种模式没有讲，就是那种带+号的模式。什么是带+的模式呢？+就是加一个功能。比如刚才讲的r模式是只读模式，在这种模式下，文件句柄只能进行类似于read的这读的操作，而不能进行write这种写的操作。所以我们想让这个文件句柄既可以进行读的操作，又可以进行写的操作，那么这个如何做呢？这就是接下来要说这样的模式：r+ 读写模式，w+写读模式,a+写读模式，r+b 以bytes类型的读写模式.........&lt;br/&gt;在这里咱们只讲一种就是&lt;strong&gt;r+&lt;/strong&gt;，其他的大同小异，自己可以练练就行了。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;#1. 打开文件的模式有(默认为文本模式)：
r，只读模式【默认模式，文件必须存在，不存在则抛出异常】
w，只写模式【不可读；不存在则创建；存在则清空内容】
a， 只追加写模式【不可读；不存在则创建；存在则只追加内容】

#2. 对于非文本文件，我们只能使用b模式，&quot;b&quot;表示以字节的方式操作（而所有文件也都是以字节的形式存储的，使用这种模式无需考虑文本文件的字符编码、图片文件的jgp格式、视频文件的avi格式）
rb 
wb
ab
注：以b方式打开时，读取到的内容是字节类型，写入时也需要提供字节类型，不能指定编码

#3,‘+’模式（就是增加了一个功能）
r+，读写【可读，可写】
w+，写读【可写，可读】
a+，写读【可写，可读】

#4，以bytes类型操作的读写，写读，写读模式
r+b，读写【可读，可写】
w+b，写读【可写，可读】
a+b，写读【可写，可读】&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;r+ 模式&lt;/em&gt;&lt;/strong&gt; 读并追加 顺序不能错&lt;/p&gt;
&lt;p&gt;r+: 打开一个文件用于读写。文件指针默认将会放在文件的开头。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;f = open('文件的读写.txt', encoding='utf-8', mode='r+')
content = f.read()
print(content)
f.write('这是新写入的内容')
f.close()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　&lt;strong&gt;注意：如果你在读写模式下，先写后读，那么文件就会出问题，因为默认光标是在文件的最开始，你要是先写，则写入的内容会讲原内容覆盖掉，直到覆盖到你写完的内容，然后在后面开始读取。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;小总结:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​ &lt;strong&gt;&lt;em&gt;三个大方向：&lt;/em&gt;&lt;/strong&gt;&lt;br/&gt;​ 读， 四种模式： r rb r+ r+b&lt;br/&gt;​ 写， 四种模式 : w,wb, w+,w+b&lt;br/&gt;​ 追加 四种模式: a, ab, a+,a+b&lt;/p&gt;
&lt;p&gt;​ &lt;strong&gt;&lt;em&gt;相应的功能：&lt;/em&gt;&lt;/strong&gt;&lt;br/&gt;​ 对文件句柄的操作：read read(n) readline() readlines() write()&lt;/p&gt;
&lt;h3 id=&quot;文件操作的其它功能&quot;&gt;文件操作的其它功能&lt;/h3&gt;
&lt;ul readability=&quot;9&quot;&gt;&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;f.tell()&lt;/em&gt;&lt;/strong&gt; 获取光标的位置 单位是:字节&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;f = open('测试', encoding='utf-8', mode='r')
print(f.tell())
content = f.read()
print(f.tell())
f.close()

# 原文件内容
这是一行测试
A:这是第二行
B:这是第三行
C:这是第几行
D:这是我也不知道第几行
就这么地吧.

# 输出结果:
0   # 开始的位置
122 # 结束的位置&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;f.seek()&lt;/em&gt;&lt;/strong&gt; 调整光标的位置 (注意:移动单位是byte , 如果是utf-8的中文部分要是3的倍数)&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;f = open('测试', encoding='utf-8', mode='r')
f.seek(9)
content = f.read()
print(content)
f.close()

# 原文件内容
这是一行测试
A:这是第二行
B:这是第三行
C:这是第几行
D:这是我也不知道第几行
就这么地吧.

# 输出结果:
行测试
A:这是第二行
B:这是第三行
C:这是第几行
D:这是我也不知道第几行
就这么地吧.&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;f.flush()&lt;/em&gt;&lt;/strong&gt; 强制刷新&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;f = open('测试', encoding='utf-8', mode='w')
f.write('fafdsfsfsadfsaf')
f.flush()
f.close()&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;打开文件的另一种方式常用的是这种&quot;&gt;打开文件的另一种方式(常用的是这种)&lt;/h3&gt;
&lt;ul readability=&quot;6&quot;&gt;&lt;li readability=&quot;15&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;with open() as ....&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 优点1:不用手动关闭文件句柄
# 利用with上下文管理这种方式，它会自动关闭文件句柄。
with open('测试', encoding='utf-8', mode='r') as f:
    print(f.read())

# 优点2:可以加多个 open 操作
# 一个with 语句可以操作多个文件，产生多个文件句柄。
with open('测试', encoding='utf-8', mode='r') as f,\
        open('测试', encoding='utf-8', mode='w') as f1:
    print(f.read())
    f1.write('kckckckckckckkck')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　&lt;strong&gt;这里要注意一个问题，虽然使用with语句方式打开文件，不用你手动关闭文件句柄，比较省事儿，但是依靠其自动关闭文件句柄，是有一段时间的，这个时间不固定，所以这里就会产生问题，如果你在with语句中通过r模式打开t1文件，那么你在下面又以a模式打开t1文件，此时有可能你第二次打开t1文件时，第一次的文件句柄还没有关闭掉，可能就会出现错误,他的解决方式只能在你第二次打开此文件前，手动关闭上一个文件句柄。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;文件的修改&quot;&gt;文件的修改&lt;/h3&gt;
&lt;p&gt;​ 文件的数据是存放于硬盘上的，因而只存在覆盖、不存在修改这么一说，我们平时看到的修改文件，都是模拟出来的效果，具体的说有两种实现方式：&lt;/p&gt;
&lt;ul readability=&quot;14.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;文件操作改的流程：&lt;/strong&gt;&lt;br/&gt;1，以读的模式打开原文件。&lt;br/&gt;2，以写的模式创建一个新文件。&lt;br/&gt;3，将原文件的内容读出来修改成新内容，写入新文件。&lt;br/&gt;4，将原文件删除。&lt;br/&gt;5，将新文件重命名成原文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;13&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;方式一：&lt;/em&gt;&lt;/strong&gt;将硬盘存放的该文件的内容全部加载到内存，在内存中是可以修改的，修改完毕后，再由内存覆盖到硬盘（word，vim，nodpad++等编辑器）&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import os   # 调用系统模块
with open('测试', encoding='utf-8') as f1,\
    open('测试.bak', encoding='utf-8',mode='w') as f2:
    old_content = f1.read() # 全部读入内存,如果文件很大,会卡死
    new_content = old_content.replace('文', 'wen')   # 在内存中完成修改
    f2.write(new_content)   # 一次性写入新文件
os.remove('测试') # 删除原文件
os.rename('测试.bak', '测试')   # 将新建的文件重命名为原文件

# 原文件内容
**文件操作改的流程：**
1，以读的模式打开原文件。
2，以写的模式创建一个新文件。
3，将原文件的内容读出来修改成新内容，写入新文件。
4，将原文件删除。
5，将新文件重命名成原文件。
# 修改后的内容
**wen件操作改的流程：**
1，以读的模式打开原wen件。
2，以写的模式创建一个新wen件。
3，将原wen件的内容读出来修改成新内容，写入新wen件。
4，将原wen件删除。
5，将新wen件重命名成原wen件。&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;12&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;方式二：&lt;/em&gt;&lt;/strong&gt;将硬盘存放的该文件的内容一行一行地读入内存，修改完毕就写入新文件，最后用新文件覆盖源文件&lt;strong&gt;(这种是常用的)&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import os
with open('测试', encoding='utf-8') as f1,\
    open('测试.bak', encoding='utf-8',mode='w') as f2:
    for line in f1: # 一行一行的改,占内存少
        new_line = line.replace('wen', '文')
        f2.write(new_line)
os.remove('测试')
os.rename('测试.bak', '测试')

# 原文件内容
**wen件操作改的流程：**
1，以读的模式打开原wen件。
2，以写的模式创建一个新wen件。
3，将原wen件的内容读出来修改成新内容，写入新wen件。
4，将原wen件删除。
5，将新wen件重命名成原wen件。

# 修改后的内容
**文件操作改的流程：**
1，以读的模式打开原文件。
2，以写的模式创建一个新文件。
3，将原文件的内容读出来修改成新内容，写入新文件。
4，将原文件删除。
5，将新文件重命名成原文件。&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Fri, 20 Dec 2019 15:56:00 +0000</pubDate>
<dc:creator>Dylan_Yu</dc:creator>
<og:description>文件操作的初识 + 用 python 代码对文件进行各种操作。 基本构成： + 文件路径：path + 打开方式：读、写、追加、读写、写读…… + 编码方式：utf 8 / gbk / gb2312…</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/guanshou/p/12075610.html</dc:identifier>
</item>
<item>
<title>【程序人生】一个IT人的立功，立言，立德三不朽 - 宋者为王</title>
<link>http://www.cnblogs.com/andy-songwei/p/12075558.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/andy-songwei/p/12075558.html</guid>
<description>&lt;p&gt;       最近几个月很忙，忙着当奶爸，忙着做加班狗，忙着补裤裆学技术……以至于快忘了要思考人生了！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201912/472002-20191220225402612-1537732582.png&quot; alt=&quot;&quot; width=&quot;183&quot; height=&quot;231&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       古人立志穷极一生追求“立德”，“立功”，“立言”，以求不朽，为万世所景仰，为后人所传颂，实现人生的意义。立德者，为生民立命，为天地立心：如周公旦，周公吐哺，天下归心；如苏武，北海牧羊、持节不屈；如诸葛亮，鞠躬尽瘁，死而后已；如周恩来，克己奉公，爱民如子。立功者，为万世开太平：如秦始皇，横扫六合，书同文，车同轨；如汉武帝，开疆扩土，大汉扬威；如唐太宗，大唐盛世，光芒万丈；如毛主席，开天辟地，恢复中华。立言者，为往圣继绝学：如老子，道法自然，创立道家；如孙武子，《孙子兵法》，名扬千古；如司马迁，一家之言，《史记》留芳。亦有诸如孔子、王阳明、曾国藩这般圣贤，三不朽均有建树。&lt;/p&gt;
&lt;p&gt;        有理想的人，眼睛是有光芒的，古人这点或许是幸运的，几千年来文明的延续，赋予了一代又一代人以天下为己任的崇高使命。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201912/472002-20191220232139460-1488379796.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       而我们IT人呢？我们的使命和人生追求又在哪里呢？我们又如何来看待IT人的“立德”、“立功”、“立言”三不朽呢？&lt;/p&gt;
&lt;p&gt;       IT人的“立功”，我想就是开发影响全人类的产品，改变人类的生活方式吧。譬如比尔·盖茨，创立了微软，让操作系统走向千家万户，为计算机的普及作出了卓越的贡献，历史教科书上把他列为第三次科技革命的代表，这是怎样的功绩？譬如乔布斯，活着就是为了改变世界，创立了世界上市值最高的公司——Apple，开创了智能手机时代。拉里·佩奇、杰夫·贝索斯、马克·扎克伯格、马化腾，雷军等都创立了自己的企业，让互联网走向世界的各个角落。还有张小龙、王坚、张志东等都通过自己的技术，开发了知名的产品，撑起了一个企业。这些人都是技术出身，最终都通过自己的技术，改变了整个世界，改变了人们的生活，我想，一个IT人的“立功”，大概应该就是这样的吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201912/472002-20191220230214487-280989655.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       IT人的“立言”，我想应该就是创立一门学问，推行一种思想吧。如冯·诺依曼，现代计算机之父，如今我们现在使用的计算机，都来源于他的设计，任何一本介绍计算机历史的书籍都绕不开这个人的名字。如图灵，计算机科学之父，人工智能之父，他的大名让全世界计算机工作者膜拜， 图灵奖以他命名，全世界很多和计算机相关的事物都想办法趁“图灵”的热度。丹尼斯·里奇（Dennis M Ritchie），C语言之父，Unix之父，不错，他通过设计了一门影响力巨大的开发语言而被封神了。李纳斯·托瓦兹（Linus Torvalds），当今世界最著名的电脑程序员、黑客，也是无人不知无人不晓，开发设计的GitHub、Linux开源为全世界所使用，深刻地影响着全世界。理查德·马修·斯托曼，提出了自由软件这一概念，通过自由软件运动，赋予了软件强大的生命力。还有一些大神通过写书也影响着无数的IT人，《人月神话》、《Java编程思想》、《代码整洁之道》、《C程序设计语言》（Dennis M. Ritchie等著）、《代码大全》等，无不是作为程序员们的《圣经》一般存在着，影响着一代又一代的程序员们。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201912/472002-20191220230433129-1203666127.png&quot; alt=&quot;&quot; width=&quot;380&quot; height=&quot;233&quot;/&gt;&lt;/p&gt;
&lt;p&gt;        IT人的“立德”，我想应该是：像信徒一样，传播着对IT的信仰；像导师一样，对后辈谆谆告诫；像上帝一样，只求付出，不求回报！古人说“大上有立德，其次有立功，其次有立言”，三不朽中，“立德”最难，所以也最难举例。这里，我想提一提几个人，李开复，时刻关心着中国大学生的成长，著名的七封《给中国学生的信》，以及创立“我学网”等事迹，应该都算得上在“立德”吧。比尔·盖茨，大慈善家，将自己累积的巨额财富又回馈给全世界，也算得上是“立德”吧。 说到这里，我特别想提一个人，张孝祥！李开复、比尔·盖茨他们的“立德”，并不是针对IT界的，而张孝祥却是全心全意在为中国的软件事业而努力着。“为千万人少走弯路而著书、为中华软件之崛起而讲课”是他的人生格言，他一直践行着这句格言，也一直在帮助着千千万万的软件人成才。虽然他的培训是收费的，但他的付出早已经超出了一个普通商人的作为，还一度恳请李开复加盟来共同完成这个愿望，总之，他是值得我们IT人尊敬的。可惜，他英年早逝了，现在时常想起当年大学时班主任给我的大量他的java教学视频，以及他的教学光盘，不免有些伤感。他是湖北公安人，是我的老乡，为这样的老乡而骄傲，但我还是希望，愿他来世不再从事软件行业！（容我贴张他的照片怀念一下他）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201912/472002-20191220230817951-616443437.png&quot; alt=&quot;&quot; width=&quot;315&quot; height=&quot;188&quot;/&gt;&lt;/p&gt;
&lt;p&gt;        所以，我一度在敲打我自己，我在追求什么？我们这样普普通通的IT人又在追求什么？我们夜以继日加班是在希望有一天也能“立功”改变世界，还是仅仅希望多拿点工资？我们勤勤恳恳写博客写书是希望“立言”传播技术，还是仅仅想着多赚点稿费？我们毫不吝啬分享自己的经历是希望“立德”以教导读者少走弯路，还是仅仅想吸几个粉？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201912/472002-20191220231301634-222861317.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       但愿我们每个IT人心中都有一个自己的答案！&lt;/p&gt;
</description>
<pubDate>Fri, 20 Dec 2019 15:31:00 +0000</pubDate>
<dc:creator>宋者为王</dc:creator>
<og:description>古人立志穷极一生追求“立德”，“立功”，“立言”，以求不朽，从而实现人生的理想和意义。那么我们IT人的三不朽呢？我们IT人的理想和追求呢？</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/andy-songwei/p/12075558.html</dc:identifier>
</item>
<item>
<title>时间轮算法（TimingWheel）是如何实现的？ - luozhiyun</title>
<link>http://www.cnblogs.com/luozhiyun/p/12075326.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/luozhiyun/p/12075326.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;我在&lt;a href=&quot;https://www.cnblogs.com/luozhiyun/p/11706171.html&quot;&gt;2. SOFAJRaft源码分析—JRaft的定时任务调度器是怎么做的？&lt;/a&gt;这篇文章里已经讲解过时间轮算法在JRaft中是怎么应用的，但是我感觉我并没有讲解清楚这个东西，导致看了这篇文章依然和没看是一样的，所以我打算重新说透时间轮算法。&lt;/p&gt;
&lt;p&gt;时间轮的应用并非 JRaft 独有，其应用场景还有很多，在 Netty、Akka、Quartz、ZooKeeper 、Kafka等组件中都存在时间轮的踪影。&lt;/p&gt;
&lt;p&gt;我们下面讲解的时间轮的实现以JRaft中的为例子进行讲解，因为JRaft这部分的代码是参考Netty的，所以大家也可以去Netty中去寻找源码实现。&lt;/p&gt;
&lt;h3 id=&quot;时间轮用来解决什么问题&quot;&gt;时间轮用来解决什么问题？&lt;/h3&gt;
&lt;p&gt;如果一个系统中存在着大量的调度任务，而大量的调度任务如果每一个都使用自己的调度器来管理任务的生命周期的话，浪费cpu的资源并且很低效。&lt;/p&gt;
&lt;p&gt;时间轮是一种高效来利用线程资源来进行批量化调度的一种调度模型。把大批量的调度任务全部都绑定到同一个的调度器上面，使用这一个调度器来进行所有任务的管理（manager），触发（trigger）以及运行（runnable）。能够高效的管理各种延时任务，周期任务，通知任务等等。&lt;/p&gt;
&lt;p&gt;不过，时间轮调度器的时间精度可能不是很高，对于精度要求特别高的调度任务可能不太适合。因为时间轮算法的精度取决于，时间段“指针”单元的最小粒度大小，比如时间轮的格子是一秒跳一次，那么调度精度小于一秒的任务就无法被时间轮所调度。&lt;/p&gt;
&lt;h3 id=&quot;时间轮结构&quot;&gt;时间轮结构&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204119/201912/1204119-20191220222352249-1733541384.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如图，JRaft中时间轮（HashedWheelTimer）是一个存储定时任务的环形队列，底层采用数组实现，数组中的每个元素可以存放一个定时任务列表（HashedWheelBucket），HashedWheelBucket是一个环形的双向链表，链表中的每一项表示的都是定时任务项（HashedWheelTimeout），其中封装了真正的定时任务（TimerTask）。&lt;/p&gt;
&lt;p&gt;时间轮由多个时间格组成，每个时间格代表当前时间轮的基本时间跨度（tickDuration）。时间轮的时间格个数是固定的，可用 wheel.length 来表示。&lt;/p&gt;
&lt;p&gt;时间轮还有一个表盘指针（tick），用来表示时间轮当前指针跳动的次数，可以用tickDuration * (tick + 1)来表示下一次到期的任务，需要处理此时间格所对应的 HashedWheelBucket 中的所有任务。&lt;/p&gt;
&lt;h3 id=&quot;时间轮运行逻辑&quot;&gt;时间轮运行逻辑&lt;/h3&gt;
&lt;p&gt;时间轮在启动的时候会记录一下当前启动的时间赋值给startTime。时间轮在添加任务的时候首先会计算延迟时间（deadline），比如一个任务的延迟时间为24ms，那么会将当前的时间（currentTime）+24ms-时间轮启动时的时间（startTime）。然后将任务封装成HashedWheelTimeout加入到timeouts队列中，作为缓存。&lt;/p&gt;
&lt;p&gt;时间轮在运行的时候会将timeouts中缓存的HashedWheelTimeout任务取10万个出来进行遍历。&lt;br/&gt;然后需要计算出几个参数值：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;HashedWheelTimeout的总共延迟的次数：将每个任务的延迟时间（deadline）/tickDuration 计算出tick需要总共跳动的次数；&lt;/li&gt;
&lt;li&gt;计算时间轮round次数：根据计算的需要走的（总次数- 当前tick数量）/ 时间格个数（wheel.length）。比如tickDuration为1ms，时间格个数为20个，那么时间轮走一圈需要20ms，那么添加进一个延时为24ms的数据，如果当前的tick为0，那么计算出的轮数为1，指针没运行一圈就会将round取出来减一，所以需要转动到第二轮之后才可以将轮数round减为0之后才会运行&lt;/li&gt;
&lt;li&gt;计算出该任务需要放置到时间轮（wheel）的槽位，然后加入到槽位链表最后&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;将timeouts中的数据放置到时间轮wheel中之后，计算出当前时针走到的槽位的位置，并取出槽位中的链表数据，将deadline和当前的时间做对比，运行过期的数据。&lt;/p&gt;
&lt;h2 id=&quot;源码分析&quot;&gt;源码分析&lt;/h2&gt;
&lt;h3 id=&quot;构造器&quot;&gt;构造器&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public HashedWheelTimer(ThreadFactory threadFactory, long tickDuration, TimeUnit unit, int ticksPerWheel,
                        long maxPendingTimeouts) {

    if (threadFactory == null) {
        throw new NullPointerException(&quot;threadFactory&quot;);
    }
    //unit = MILLISECONDS
    if (unit == null) {
        throw new NullPointerException(&quot;unit&quot;);
    }
    if (tickDuration &amp;lt;= 0) {
        throw new IllegalArgumentException(&quot;tickDuration must be greater than 0: &quot; + tickDuration);
    }
    if (ticksPerWheel &amp;lt;= 0) {
        throw new IllegalArgumentException(&quot;ticksPerWheel must be greater than 0: &quot; + ticksPerWheel);
    }

    // Normalize ticksPerWheel to power of two and initialize the wheel.
    // 创建一个HashedWheelBucket数组
    // 创建时间轮基本的数据结构，一个数组。长度为不小于ticksPerWheel的最小2的n次方
    wheel = createWheel(ticksPerWheel);
    // 这是一个标示符，用来快速计算任务应该呆的格子。
    // 我们知道，给定一个deadline的定时任务，其应该呆的格子=deadline%wheel.length.但是%操作是个相对耗时的操作，所以使用一种变通的位运算代替：
    // 因为一圈的长度为2的n次方，mask = 2^n-1后低位将全部是1，然后deadline&amp;amp;mast == deadline%wheel.length
    // java中的HashMap在进行hash之后，进行index的hash寻址寻址的算法也是和这个一样的
    mask = wheel.length - 1;

    // Convert tickDuration to nanos.
    //tickDuration传入是1的话，这里会转换成1000000
    this.tickDuration = unit.toNanos(tickDuration);

    // Prevent overflow.
    // 校验是否存在溢出。即指针转动的时间间隔不能太长而导致tickDuration*wheel.length&amp;gt;Long.MAX_VALUE
    if (this.tickDuration &amp;gt;= Long.MAX_VALUE / wheel.length) {
        throw new IllegalArgumentException(String.format(
            &quot;tickDuration: %d (expected: 0 &amp;lt; tickDuration in nanos &amp;lt; %d&quot;, tickDuration, Long.MAX_VALUE
                                                                                        / wheel.length));
    }
    //将worker包装成thread
    workerThread = threadFactory.newThread(worker);
    //maxPendingTimeouts = -1
    this.maxPendingTimeouts = maxPendingTimeouts;

    //如果HashedWheelTimer实例太多，那么就会打印一个error日志
    if (instanceCounter.incrementAndGet() &amp;gt; INSTANCE_COUNT_LIMIT
        &amp;amp;&amp;amp; warnedTooManyInstances.compareAndSet(false, true)) {
        reportTooManyInstances();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这个构造器中有几个细节需要注意：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;调用createWheel方法创建的wheel数组一定是2次方数，比如传入的ticksPerWheel是6，那么初始化的wheel长度一定是8。这样做是为了让mask &amp;amp; tick 来计算出槽位&lt;/li&gt;
&lt;li&gt;tickDuration用的是纳秒&lt;/li&gt;
&lt;li&gt;在构造里面并不会里面启动时间轮，而是要等到有第一个任务加入到时间轮的时候才启动。在构造器里面会将工作线程worker封装成workerThread&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;放入任务到时间轮中&quot;&gt;放入任务到时间轮中&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public Timeout newTimeout(TimerTask task, long delay, TimeUnit unit) {
    if (task == null) {
        throw new NullPointerException(&quot;task&quot;);
    }
    if (unit == null) {
        throw new NullPointerException(&quot;unit&quot;);
    }

    long pendingTimeoutsCount = pendingTimeouts.incrementAndGet();

    if (maxPendingTimeouts &amp;gt; 0 &amp;amp;&amp;amp; pendingTimeoutsCount &amp;gt; maxPendingTimeouts) {
        pendingTimeouts.decrementAndGet();
        throw new RejectedExecutionException(&quot;Number of pending timeouts (&quot; + pendingTimeoutsCount
                                             + &quot;) is greater than or equal to maximum allowed pending &quot;
                                             + &quot;timeouts (&quot; + maxPendingTimeouts + &quot;)&quot;);
    }
    // 如果时间轮没有启动，则启动
    start();

    // Add the timeout to the timeout queue which will be processed on the next tick.
    // During processing all the queued HashedWheelTimeouts will be added to the correct HashedWheelBucket.
    long deadline = System.nanoTime() + unit.toNanos(delay) - startTime;

    // Guard against overflow.
    //在delay为正数的情况下，deadline是不可能为负数
    //如果为负数，那么说明超过了long的最大值
    if (delay &amp;gt; 0 &amp;amp;&amp;amp; deadline &amp;lt; 0) {
        deadline = Long.MAX_VALUE;
    }
    // 这里定时任务不是直接加到对应的格子中，而是先加入到一个队列里，然后等到下一个tick的时候，
    // 会从队列里取出最多100000个任务加入到指定的格子中
    HashedWheelTimeout timeout = new HashedWheelTimeout(this, task, deadline);
    //Worker会去处理timeouts队列里面的数据
    timeouts.add(timeout);
    return timeout;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;如果时间轮没有启动，那么就调用start方法启动时间轮，启动时间轮之后会为startTime设置为当前时间&lt;/li&gt;
&lt;li&gt;计算延迟时间deadline&lt;/li&gt;
&lt;li&gt;将task任务封装到HashedWheelTimeout中，然后添加到timeouts队列中进行缓存&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;start&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private final CountDownLatch                                     startTimeInitialized   = new CountDownLatch(1);

public void start() {
    //workerState一开始的时候是0（WORKER_STATE_INIT），然后才会设置为1（WORKER_STATE_STARTED）
    switch (workerStateUpdater.get(this)) {
        case WORKER_STATE_INIT:
            //使用cas来获取启动调度的权力，只有竞争到的线程允许来进行实例启动
            if (workerStateUpdater.compareAndSet(this, WORKER_STATE_INIT, WORKER_STATE_STARTED)) {
                //如果成功设置了workerState，那么就调用workerThread线程
                workerThread.start();
            }
            break;
        case WORKER_STATE_STARTED:
            break;
        case WORKER_STATE_SHUTDOWN:
            throw new IllegalStateException(&quot;cannot be started once stopped&quot;);
        default:
            throw new Error(&quot;Invalid WorkerState&quot;);
    }

    // 等待worker线程初始化时间轮的启动时间
    // Wait until the startTime is initialized by the worker.
    while (startTime == 0) {
        try {
            //这里使用countDownLauch来确保调度的线程已经被启动
            startTimeInitialized.await();
        } catch (InterruptedException ignore) {
            // Ignore - it will be ready very soon.
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;start方法会根据当前的workerState状态来启动时间轮。并且用了startTimeInitialized来控制线程的运行，如果workerThread没有启动起来，那么newTimeout方法会一直阻塞在运行start方法中。如果不阻塞，newTimeout方法会获取不到startTime。&lt;/p&gt;
&lt;h3 id=&quot;启动时间轮&quot;&gt;启动时间轮&lt;/h3&gt;
&lt;p&gt;时间轮的启动在HashedWheelTimer的内部类Worker中。调用workerThread#start方法会调用Worker的run方法启动时间轮。&lt;/p&gt;
&lt;p&gt;下面我们看时间轮启动做了什么，下面的分析不考虑任务被取消的情况。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Worker#run&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void run() {
    // Initialize the startTime.
    startTime = System.nanoTime();
    if (startTime == 0) {
        // We use 0 as an indicator for the uninitialized value here, so make sure it's not 0 when initialized.
        startTime = 1;
    }

    //HashedWheelTimer的start方法会继续往下运行
    // Notify the other threads waiting for the initialization at start().
    startTimeInitialized.countDown();

    do {
        //返回的是当前的nanoTime- startTime
        //也就是返回的是 每 tick 一次的时间间隔
        final long deadline = waitForNextTick();
        if (deadline &amp;gt; 0) {
            //算出时间轮的槽位
            int idx = (int) (tick &amp;amp; mask);
            //移除cancelledTimeouts中的bucket
            // 从bucket中移除timeout
            processCancelledTasks();
            HashedWheelBucket bucket = wheel[idx];
            // 将newTimeout()方法中加入到待处理定时任务队列中的任务加入到指定的格子中
            transferTimeoutsToBuckets();
            bucket.expireTimeouts(deadline);
            tick++;
        }
    //    校验如果workerState是started状态，那么就一直循环
    } while (workerStateUpdater.get(HashedWheelTimer.this) == WORKER_STATE_STARTED);

    // Fill the unprocessedTimeouts so we can return them from stop() method.
    for (HashedWheelBucket bucket : wheel) {
        bucket.clearTimeouts(unprocessedTimeouts);
    }
    for (;;) {
        HashedWheelTimeout timeout = timeouts.poll();
        if (timeout == null) {
            break;
        }
        //如果有没有被处理的timeout，那么加入到unprocessedTimeouts对列中
        if (!timeout.isCancelled()) {
            unprocessedTimeouts.add(timeout);
        }
    }
    //处理被取消的任务
    processCancelledTasks();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;时间轮运行的时候首先会记录一下启动时间（startTime），然后调用startTimeInitialized释放外层的等待线程；&lt;/li&gt;
&lt;li&gt;进入dowhile循环，调用waitForNextTick睡眠等待到下一次的tick指针的跳动，并返回当前时间减去startTime作为deadline&lt;/li&gt;
&lt;li&gt;由于mask= wheel.length -1 ，wheel是2的次方数，所以可以直接用tick &amp;amp; mask 计算出此次在wheel中的槽位&lt;/li&gt;
&lt;li&gt;调用processCancelledTasks将cancelledTimeouts队列中的任务取出来，并将当前的任务从时间轮中移除&lt;/li&gt;
&lt;li&gt;调用transferTimeoutsToBuckets方法将timeouts队列中缓存的数据取出加入到时间轮中&lt;/li&gt;
&lt;li&gt;运行目前指针指向的槽位中的bucket链表数据&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;时间轮指针跳动&quot;&gt;时间轮指针跳动&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;waitForNextTick&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//sleep, 直到下次tick到来, 然后返回该次tick和启动时间之间的时长
private long waitForNextTick() {
    //tickDuration这里是100000
    //tick表示总tick数
    long deadline = tickDuration * (tick + 1);

    for (;;) {
        final long currentTime = System.nanoTime() - startTime;
        // 计算需要sleep的时间, 之所以加999999后再除10000000,前面是1所以这里需要减去1，
        // 才能计算准确，还有通过这里可以看到 其实线程是以睡眠一定的时候再来执行下一个ticket的任务的，
        //这样如果ticket的间隔设置的太小的话，系统会频繁的睡眠然后启动，
        //其实感觉影响部分的性能，所以为了更好的利用系统资源步长可以稍微设置大点
        long sleepTimeMs = (deadline - currentTime + 999999) / 1000000;
        //sleepTimeMs小于零表示走到了下一个时间轮位置
        if (sleepTimeMs &amp;lt;= 0) {
            if (currentTime == Long.MIN_VALUE) {
                return -Long.MAX_VALUE;
            } else {
                return currentTime;
            }
        }

        // Check if we run on windows, as if thats the case we will need
        // to round the sleepTime as workaround for a bug that only affect
        // the JVM if it runs on windows.
        //
        // See https://github.com/netty/netty/issues/356
        if (Platform.isWindows()) {
            sleepTimeMs = sleepTimeMs / 10 * 10;
        }

        try {
            Thread.sleep(sleepTimeMs);
        } catch (InterruptedException ignored) {
            if (workerStateUpdater.get(HashedWheelTimer.this) == WORKER_STATE_SHUTDOWN) {
                return Long.MIN_VALUE;
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以想象一下在时钟的秒钟上面秒与秒之间的时间是需要等待的，那么waitForNextTick这个方法就是根据当前的时间计算出跳动到下个时间的间隔时间，并进行sleep操作，然后返回当前时间距离时间轮启动时间的时间段。&lt;/p&gt;
&lt;h3 id=&quot;转移任务到时间轮中&quot;&gt;转移任务到时间轮中&lt;/h3&gt;
&lt;p&gt;在调用时间轮的方法加入任务的时候并没有直接加入到时间轮中，而是缓存到了timeouts队列中，所以在运行的时候需要将timeouts队列中的任务转移到时间轮数据的链表中&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;transferTimeoutsToBuckets&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private void transferTimeoutsToBuckets() {
    // transfer only max. 100000 timeouts per tick to prevent a thread to stale the workerThread when it just
    // adds new timeouts in a loop.
    // 每次tick只处理10w个任务，以免阻塞worker线程
    for (int i = 0; i &amp;lt; 100000; i++) {
        HashedWheelTimeout timeout = timeouts.poll();
        if (timeout == null) {
            // all processed
            break;
        }
        //已经被取消了；
        if (timeout.state() == HashedWheelTimeout.ST_CANCELLED) {
            // Was cancelled in the meantime.
            continue;
        }
        //calculated = tick 次数
        long calculated = timeout.deadline / tickDuration;
        // 计算剩余的轮数, 只有 timer 走够轮数, 并且到达了 task 所在的 slot, task 才会过期
        timeout.remainingRounds = (calculated - tick) / wheel.length;
        //如果任务在timeouts队列里面放久了, 以至于已经过了执行时间, 这个时候就使用当前tick, 也就是放到当前bucket, 此方法调用完后就会被执行
        final long ticks = Math.max(calculated, tick); // Ensure we don't schedule for past.
        //// 算出任务应该插入的 wheel 的 slot, slotIndex = tick 次数 &amp;amp; mask, mask = wheel.length - 1
        int stopIndex = (int) (ticks &amp;amp; mask);

        HashedWheelBucket bucket = wheel[stopIndex];
        //将timeout加入到bucket链表中
        bucket.addTimeout(timeout);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这个转移方法中，写死了一个循环，每次都只转移10万个任务。&lt;/p&gt;
&lt;p&gt;然后根据HashedWheelTimeout的deadline延迟时间计算出时间轮需要运行多少次才能运行当前的任务，如果当前的任务延迟时间大于时间轮跑一圈所需要的时间，那么就计算需要跑几圈才能到这个任务运行。&lt;/p&gt;
&lt;p&gt;最后计算出该任务在时间轮中的槽位，添加到时间轮的链表中。&lt;/p&gt;
&lt;h3 id=&quot;运行时间轮中的任务&quot;&gt;运行时间轮中的任务&lt;/h3&gt;
&lt;p&gt;当指针跳到时间轮的槽位的时间，会将槽位的HashedWheelBucket取出来，然后遍历链表，运行其中到期的任务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;expireTimeouts&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 过期并执行格子中的到期任务，tick到该格子的时候，worker线程会调用这个方法
//根据deadline和remainingRounds判断任务是否过期
public void expireTimeouts(long deadline) {
    HashedWheelTimeout timeout = head;

    // process all timeouts
    //遍历格子中的所有定时任务
    while (timeout != null) {
        // 先保存next，因为移除后next将被设置为null
        HashedWheelTimeout next = timeout.next;
        if (timeout.remainingRounds &amp;lt;= 0) {
            //从bucket链表中移除当前timeout，并返回链表中下一个timeout
            next = remove(timeout);
            //如果timeout的时间小于当前的时间，那么就调用expire执行task
            if (timeout.deadline &amp;lt;= deadline) {
                timeout.expire();
            } else {
                //不可能发生的情况，就是说round已经为0了，deadline却&amp;gt;当前槽的deadline
                // The timeout was placed into a wrong slot. This should never happen.
                throw new IllegalStateException(String.format(&quot;timeout.deadline (%d) &amp;gt; deadline (%d)&quot;,
                        timeout.deadline, deadline));
            }
        } else if (timeout.isCancelled()) {
            next = remove(timeout);
        } else {
            //因为当前的槽位已经过了，说明已经走了一圈了，把轮数减一
            timeout.remainingRounds--;
        }
        //把指针放置到下一个timeout
        timeout = next;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;HashedWheelBucket是一个链表，所以我们需要从head节点往下进行遍历。如果链表没有遍历到链表尾部那么就继续往下遍历。&lt;/p&gt;
&lt;p&gt;获取的timeout节点节点，如果剩余轮数remainingRounds大于0，那么就说明要到下一圈才能运行，所以将剩余轮数减一；&lt;/p&gt;
&lt;p&gt;如果当前剩余轮数小于等于零了，那么就将当前节点从bucket链表中移除，并判断一下当前的时间是否大于timeout的延迟时间，如果是则调用timeout的expire执行任务。&lt;/p&gt;
</description>
<pubDate>Fri, 20 Dec 2019 14:24:00 +0000</pubDate>
<dc:creator>luozhiyun</dc:creator>
<og:description>前言 我在 '2. SOFAJRaft源码分析—JRaft的定时任务调度器是怎么做的？' 这篇文章里已经讲解过时间轮算法在JRaft中是怎么应用的，但是我感觉我并没有讲解清楚这个东西，导致看了这篇文章</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/luozhiyun/p/12075326.html</dc:identifier>
</item>
<item>
<title>为什么那些将学习作为爱好的人没能成功？ - 第二座山的知识库</title>
<link>http://www.cnblogs.com/d2zs/p/12075306.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/d2zs/p/12075306.html</guid>
<description>&lt;p&gt;我有位社群会员简称尹老师，她是个英语爱好者，另外对儿童心理学也有过相关的研究，还开过铺导班。不过由于后来有了孩子就没有参加工作了，但是每天还是会坚持阅读英语，用她的话来说英语是她的爱好，从初中到大学，见到英语就起劲那种，就像有人爱跳舞有人爱美食，但是自己只是学着玩，也没人要求自己。&lt;/p&gt;
&lt;p&gt;刚认识尹老师的时候，她这么和我说，我的脑海中就会不自主的想到，这是一位原本很有潜力的朋友，但由于她只是把这些当做爱好，因此很难将自己的价值发挥到最大化，也很难长久的坚持下去。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/pashangshangpo/blog-image@image/image/20191220220559.png&quot; alt=&quot;20191220220559&quot;/&gt;&lt;/p&gt;
&lt;p&gt;就像很多早期我认识的博客主，他们总跟我说自己是因为喜欢写博客而搭建的博客，可是为什么现在一个一个的关闭了？有人说是因为个人博客的流量越来越少，当然这点无法否认，但是为什么还有些个人博客存活至今，比如国内比较有名的卢松松，他的博客从2009年一直存活到至今，为什么？很大原因是因为他的博客有一套盈利模式，因为有盈利模式因此不用考虑服务器的成本问题，另外也能多一份收入来源，所以这种情况下根本没有必要关站。而那些关站的博客主，很大原因就是需要自己承担服务器费用，另外也没有多少人气，那自然就觉得没意思，也没有必要搭建博客，所以就自然的关闭了。&lt;/p&gt;
&lt;p&gt;一个人有兴趣是好的，但是如果能把兴趣结合实际，那效果就不一样了。反而如果你只是把这件事情当做一个兴趣，那么很容易因为某些原因而懈怠，因为它不是你必须要做的事情。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/pashangshangpo/blog-image@image/image/20191220220722.png&quot; alt=&quot;20191220220722&quot;/&gt;&lt;/p&gt;
&lt;p&gt;拿英语来说，有些人学习英语只是为了出国旅游，还有些人不仅学习英语，还会将自己学习英语的过程分享给其他人，或者写成课程。他们不仅能够利用这些课程获取生活收入来源，还能不断的在这个领域深耕发芽，这才是真正把自己的兴趣融合到生活当中的人。&lt;/p&gt;
&lt;p&gt;现实生活中有很多人是为了学习而学习，而不懂得怎么将自己学到的知识结合实际生活产生价值，因此最终都难以成功。&lt;/p&gt;
&lt;p&gt;另外有些人虽然每天都在学习，但是学习并没有什么目标，属于盲目的学习。拿尹老师学习托福英语词汇来说，尹老师的目标是看完这本书，但是对于为什么要学习这些词汇以及学完之后要怎么样，并没有一个目标，所以往往是学完了这些单词就没有了然后。因此这种学习方法就不对了，有点像纯粹是背单词的，没有把学习到的知识应用到现实生活中去。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/pashangshangpo/blog-image@image/image/20191220210417.png&quot; alt=&quot;20191220210417&quot;/&gt;&lt;/p&gt;
&lt;p&gt;按照尹老师的这个英语词汇学习计划，大概需要一年以后才能学完。假设我们把时间调到一年后，尹老师把这本书顺利的阅读完了，她会是什么样的情况？会因此而觉得特别兴奋吗？我想很难，甚至可能陷入到另一场重复的学习中。所以问题不在于是否有把这本书阅读完，而在于你为什么要阅读这本书，你想阅读这本书达到什么样的目的。&lt;/p&gt;
&lt;p&gt;这里尹老师把阅读词汇量作为目标是不对的，因为它本身不能产生效益，你会100个词汇量，还是会1000个词汇量，不是最关键的。如果你不能将这些词汇运用出来，那么甚至你自己都不知道自己到底会多少个词汇，因此你就会处在一种盲目的学习状态。&lt;/p&gt;
&lt;p&gt;另外由于尹老师学习英语的目的太过于简单，只是不想因为自己现在在家带孩子而与社会脱轨，导致以后想上班的时候拉开太大的差距。而不和社会脱轨这个目标太小了，所以尹老师学习英语就不能发挥更大的作用，因为只要能够达到不和社会脱轨自己就已经满足了。&lt;/p&gt;
&lt;p&gt;还有很多将学习作为爱好的人，其实内心是茫然的。另外他们总以为只要自己把一件事当做爱好就能长久的坚持下去，其实大错特错。在现实生活中对于大部分人来说，兴趣真的不值几个钱，反倒是自己以为不会喜欢的工作，一次又一次的激励着自己向前走，而这些不仅仅只是为了应付生存，更是因为它在你每达成一个阶段的时候，给予你莫大的鼓励。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/pashangshangpo/blog-image@image/image/20191220220945.png&quot; alt=&quot;20191220220945&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以如果尹老师能够将自己学习英语的目标设定大一些，效果就会截然不一样。比如将学习英语的目标设定成我要培训300个学员，那显然学习效果是不一样的，一方面这个目标有激励作用而不是满足即可，因此自己会更想去做这件事情。另外由于这个目标是培训300个学员，因此在学英语的过程中会更有目地的制定学习计划。&lt;/p&gt;
&lt;p&gt;那后来尹老师是怎么做的？尹老师虽然现在没办法去参加工作，但是她有空就会去一些培训机构面试英语老师，而这么做的目的就是看看最近市场形势，市场需求，然后根据面试的内容，有针对性的制定学习计划。&lt;/p&gt;
&lt;p&gt;对尹老师是如何转变思维以及具体怎么做的，可以关注一下，后面会分享噢，另外如果你有什么想问尹老师的，我也可以帮忙传达。&lt;/p&gt;
&lt;p&gt;另外大家身边有没有这样的人？他们热爱学习，但是最终却没有成功。&lt;/p&gt;
</description>
<pubDate>Fri, 20 Dec 2019 14:18:00 +0000</pubDate>
<dc:creator>第二座山的知识库</dc:creator>
<og:description>我有位社群会员简称尹老师，她是个英语爱好者，另外对儿童心理学也有过相关的研究，还开过铺导班。不过由于后来有了孩子就没有参加工作了，但是每天还是会坚持阅读英语，用她的话来说英语是她的爱好，从初中到大学，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/d2zs/p/12075306.html</dc:identifier>
</item>
<item>
<title>So Easy - 在Linux服务器上部署 .NET Core App - 张子浩</title>
<link>http://www.cnblogs.com/ZaraNet/p/12064008.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ZaraNet/p/12064008.html</guid>
<description>&lt;p&gt;&lt;strong&gt;　　.NET Core&lt;/strong&gt; 是微软提供的免费、跨平台和开源的开发框架，可以构建桌面应用程序、移动端应用程序、网络应用程序、物联网应用程序和游戏应用程序等。如果你是 Windows 平台下的 dotnet 开发人员的话，使用 .NET core 可以很轻松就设置好任何 Linux 和类 Unix 操作系统下的开发环境。本文将会逐步带着大家在Linux上部署.NET Core应用程序。&lt;/p&gt;
&lt;h2&gt;一.环境准备&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;服务器:阿里云64位CentOS 7.4.1708版本;&lt;/li&gt;
&lt;li&gt;客户端:Windows 10;&lt;/li&gt;
&lt;li&gt;SFTP客户端:FileZilla;用来进行文件传输;&lt;/li&gt;
&lt;li&gt;SSH工具:Xshell 6;用来在Windows 上远程访问CentOS;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;二.在Linux上安装.NET 环境&lt;/h2&gt;
&lt;p&gt;使用如下命令注册Microsoft需要的依赖环境,该命令类似于Window上的环境变量，它指向了微软的环境源，地址中的对每个系统是不一样，所以我们要斟酌一下的Linux系统是什么，再去拉取。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
wget -q https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;packages.microsoft.com/config/ubuntu/18.04/packages-microsoft-prod.deb&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;比如你当时装了.NET Core3.0，但是呢！微软过了几天又出了.NET Core 3.1 ，这个时候就需要更新你这个配给的配置，通过以下命令。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
yum update
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;yum update命令会重新拉取下，随后重新做配置，但你的dotnet sdk不会受任何影响，随后安装dotnet sdk。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
yum install dotnet-sdk-&lt;span&gt;3.1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;安装完会出现以下截图，随后我们可以通过dotnet--info来判断是否安装成功。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1366751/201912/1366751-20191218221903983-1017198277.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时环境就运行环境就搭建完璧了~&lt;/p&gt;
&lt;h2&gt;二.使用FileZilla工具向服务器推送应用程序&lt;/h2&gt;
&lt;p&gt;值得一提的是任何服务器的ftp端口都是22，这个是必须要注意的，否则会一直连接失败。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1366751/201912/1366751-20191220221138939-556577788.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时我们向服务器传送了发布文件，如果不出意外我们可以直接在Liunx上看到。通过Ls 、Cd /完成查看。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1366751/201912/1366751-20191219212401926-1368059475.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;随后我们找到了以dll结尾并且是你解决方案的名称，随后我们直接dotnet 命令来进行启动项目。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1366751/201912/1366751-20191219212612487-1433988960.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;三.启动应用程序&lt;/h2&gt;
&lt;p&gt;　　 此时我们可以看到我们的内网是以5000端口启动的，这得益于我们直接将.NET Core直接设置原因，当然我们如果要在阿里云上公网IP的安全映射进行设置，在此之前我们要测试一下内网是否正常，常用的命令是curl，不够这个命令需要安装，在Centos和ubuntu安装命令是不一样的。具体命令如下：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;apt-get install curl  //ubuntu的命令&lt;/p&gt;
&lt;p&gt;yum  install curl   //Centos的命令&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;关于Curl这个命令很强大，这个就不这里详谈了，安装完成之后就可以使用这个命令了，最后我们测试内网看看是否正常。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1366751/201912/1366751-20191219213749929-684268527.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时发现内网已经打通，现在我们通过阿里云公网IP对内网进行映射。在阿里云中的安全组中，找到安全组规则，添加一条映射。放开所有IP，这样就ok了，具体如下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1366751/201912/1366751-20191219214100299-489507063.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　此时，试着激动的双手打开手机试着去访问....OK，Nice..&lt;/p&gt;
&lt;p&gt;.&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1366751/201912/1366751-20191219215004458-56481191.png&quot; alt=&quot;&quot; width=&quot;436&quot; height=&quot;349&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;四.进程守护　　&lt;/h2&gt;
&lt;p&gt;　　不过一个尴尬的事情出现了，我们只是通过dotnet命令启动了项目，但是我们的XShell关闭你的应用程序就会关闭，此时我们就需要进程守护了。这样就可以让你的应用程序每时每刻都可以为你服务。&lt;a href=&quot;http://supervisord.org/introduction.html#overview&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;Supervisor&lt;/a&gt;是Python做一个client/server服务，是Linux/Unix双系统下的一个进程管理工具。它可以很方便的监听、启动、停止、重启一个或多个进程。用Supervisor管理的进程，当一个进程意外被杀死，supervisort监听到进程死后，会自动将它重新拉起，很方便的做到进程自动恢复的功能，不再需要自己写shell脚本来控制。通过这里你应该就会明白我们会干什么，我们会尝试着关闭Xshell，看看它会不会帮我们去重启应用程序，如果可以正常访问，那么你的进程守护配置成功！好吧废话不多说。&lt;/p&gt;
&lt;p&gt;　　我们首先需要在Linux系统上安装 &lt;span class=&quot;cnblogs_code&quot;&gt;Supervisor&lt;/span&gt; ，在安装它之前，我们需要安装Python 包。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
yum install python-setuptools
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　随后我们在安装Supervisor，执行结果如下图。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
easy_install supervisor
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1366751/201912/1366751-20191219220619564-55772227.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　随后创建几个文件夹，包括supervisor，在这个文件夹中包含了supervisor的一切配置。包含了进程配置文件（也就是大概你想让这个进程去干什么？去执行什么命令？在什么目录下？下面我们会逐一说明下配置文件的各个节点）以及supervisor本身监听服务的配置。&lt;/p&gt;
&lt;h3&gt;4.1 在etc文件夹下新建文件夹supervisor&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
mkdir /etc/supervisor
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;4.2 在supervisor文件夹下新建文件夹conf.d&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
mkdir /etc/supervisor/conf.d
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;4.3 生成supervisord.conf 配置文件&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
echo_supervisord_conf &amp;gt; /etc/supervisor/supervisord.conf
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;4.4 定位到文件夹下修改配置文件：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
cd /etc/supervisor
vim  supervisord.conf
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　改变这个路径只是为了能够找到我们的conf.d文件夹中我们自定义的配置文件。conf.d中是我们自己创建的。所以要进行改变。我们在这个文件内容的最下面，可以看到有一个included标签，这个就是我刚才所说的。它默认是这个样子，从内容可以看出是让我们进行修改的。&lt;/p&gt;
&lt;p&gt;　　修改前的内容如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;;[include]
;files &lt;/span&gt;= relative/directory&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;ini&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　修改后的内容如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[include]
files &lt;/span&gt;= conf.d&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;.conf&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个时候supervisord的配置已经结束了，那么就剩你的应用程序级别的配置文件了。上述的步骤其实都可以通过FileZilla工具实现，这样更好的去编辑。&lt;/p&gt;
&lt;h3&gt;4.5 创建应用程序级别配置文件&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[program:AspNetCore_Cookie]
command&lt;/span&gt;=&lt;span&gt;dotnet AspNetCore_Cookie.dll
directory&lt;/span&gt;=/home/&lt;span&gt;publish
environment&lt;/span&gt;=ASPNETCORE__ENVIRONMENT=&lt;span&gt;Production
user&lt;/span&gt;=&lt;span&gt;root
stopsignal&lt;/span&gt;=&lt;span&gt;INT
autostart&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
autorestart&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
startsecs&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
stderr_logfile&lt;/span&gt;=/&lt;span&gt;var&lt;/span&gt;/log/&lt;span&gt;HelloWebApp.err.log
stdout_logfile&lt;/span&gt;=/&lt;span&gt;var&lt;/span&gt;/log/HelloWebApp.&lt;span&gt;out&lt;/span&gt;.log
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于上述的配置文件我做了如下解释，当然有错误的话可以纠正，毕竟是根据我对鸟语的理解不是很...emmm&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;command= 要执行的命令，在.NET Core 应用程序中 我们都是使用dotnet 命令来启动应用程序的&lt;br/&gt;directory= 命令执行的目录 比如你的publish 在某个文件夹  那你就写哪里&lt;br/&gt;environment= 环境变量   ASP.NET Core的环境变量 可能是有的时候需要linux管理员去访问，不过我是root，这个我是不太懂&lt;br/&gt;user= 进程执行的用户身份 这里写的root&lt;br/&gt;stopsignal=INT 这个都没人动  我也不动 emmm&lt;br/&gt;autostart= 是否自动启动 &lt;br/&gt;autorestart= 是否自动重启&lt;br/&gt;startsecs= 自动重启间隔&lt;br/&gt;stderr_logfile= 标准错误日志&lt;br/&gt;stdout_logfile= 标准输出日志&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;就现在，我们的配置已完毕，如果你是按照上方进行配置的，那么你肯定是没有问题的。&lt;/p&gt;
&lt;h3&gt;4.6 启动进程守护服务&lt;/h3&gt;
&lt;p&gt;运行 &lt;span class=&quot;cnblogs_code&quot;&gt;supervisord -c /etc/supervisor/supervisord.conf&lt;/span&gt; 看看是否包报错信息，如果没有则配置成功。随后我们直接启动Supervisord服务。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
sudo supervisorctl shutdown &amp;amp;&amp;amp; sudo supervisord -c /etc/supervisor/supervisord.conf
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;并且我们查看进程看看我们刚才的应用程序级别配置是否有效。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1366751/201912/1366751-20191220215747918-970600341.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在配置一切成功，去打开你的网站吧！，关闭你的XShell 或者 云端在线远程，这个时候再去试着访问你的网站。ok没问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1366751/201912/1366751-20191220220141769-2073862025.jpg&quot; alt=&quot;&quot; width=&quot;325&quot; height=&quot;263&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 20 Dec 2019 14:13:00 +0000</pubDate>
<dc:creator>张子浩</dc:creator>
<og:description>.NET Core&amp;#160;是微软提供的免费、跨平台和开源的开发框架，可以构建桌面应用程序、移动端应用程序、网络应用程序、物联网应用程序和游戏应用程序等。如果你是 Windows 平台下的 dotn</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ZaraNet/p/12064008.html</dc:identifier>
</item>
<item>
<title>2019 我是怎么熬过来的？ - cxuan</title>
<link>http://www.cnblogs.com/cxuanBlog/p/12075094.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cxuanBlog/p/12075094.html</guid>
<description>&lt;p&gt;&lt;strong&gt;岁月你别催，该来的我不推；岁月你别催，走远的仍要追&lt;/strong&gt;，这是《天下足球》里面的一则年度佳句，我觉得用到软件行业再合适不过了。&lt;/p&gt;
&lt;p&gt;我可以用IT行业的排比句来仿造一下这段话，那就是 &lt;strong&gt;裁员你别来，你来了给我钱；头发你别走，你走了没女友&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;2019 年我可以用5个词来形容一下我一整年：&lt;strong&gt;关注点、阈值、知识储备、写作、自省&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;热搜关键词&quot;&gt;2019 热搜关键词&lt;/h2&gt;
&lt;h3 id=&quot;关注点&quot;&gt;关注点&lt;/h3&gt;
&lt;p&gt;我是一个很普通的人，我的人生都是各种的普通，普通家庭，普通大学，普通收入，是这种一直走下去，人生不会有任何起色的人。但是我有一颗躁动的心，我不甘平庸，我不想普通，我是想在互联网激荡30年里占有一席之地的人。&lt;/p&gt;
&lt;p&gt;所以我的&lt;code&gt;关注点&lt;/code&gt;一直在变，我去年的关注点都放在了如何给公司带来价值，如何干完更多的活，如何让自己经历更多的事情上，所以不管是不是坑我都会接，不管什么难点我都会去扛。但是，事实并不是像我预料到的那样。于是，在这段时间里我只学会了如何更高效的 &lt;code&gt;CRUD&lt;/code&gt; 上。下附去年一年的下班时间，只截取了中间的一段。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1515111/201912/1515111-20191220210947448-418771144.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这段时间里，我有的时候是睡在公司外包的场所，无数次睡到了公司的行军床上，甚至凌晨3点还在找宾馆，更有的时候还睡到了开会的桌子上，睡了一会儿起来腰已经动不了了，这段时间的我痛并快乐着，而且我敢打保证我领的绝对是互联网行业&lt;code&gt;最低&lt;/code&gt;的薪水，因为我们毕竟算不上互联网。&lt;strong&gt;这时候的我仍在畅想着未来很美好&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这时候我的关注点都放在了我努力干活就能实现公司给我画的大饼上&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;事实上不是这样的，并不是你越苦你就越能往上走，并不是你干的活多你就一定能往上爬。最根本的是取决于你做事情的价值和贡献。扫地大妈不会因为一天打扫10次洗手间就能做到公司技术主管的。&lt;/p&gt;
&lt;p&gt;所以我认识到，干的活多也只能是 CRUD 的更快而已，然后我转变了策略，&lt;code&gt;一切的问题都可以加个代理来解决&lt;/code&gt;，我培养了新人，同事来问问题我都会先指派给他，如果他有疑问，再来问我，那么我们的关系就会变成下面这样。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1515111/201912/1515111-20191220210959574-1231300913.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;刚开始所有的同事都来问我问题，我的关注点都放在了如何给&lt;code&gt;每个同事&lt;/code&gt;解决问题上，这时候的我又累又得不到成长，顶多别人会说我&lt;code&gt;cxuan 人很热心肠&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;后来，我的关注点放在了培养新人，我直接指导新人问题，让他去解决同事的困难。这同时锻炼了新人的能力，也让我有更多的时间提升自己，还能把事情做的尽善尽美，何乐而不为呢？&lt;/p&gt;
&lt;p&gt;于是乎我的关注点放在了&lt;code&gt;如何提高自身技术&lt;/code&gt;上，所以我一有时间就会看书，我每天中午都会看书看到睡着。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;学习是有一种魔力的，它能拉着你往上走&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;此时的我虽然学习到了一些零散的知识，但是我还没有系统学习的过程，此刻我的关注点非常想要系统的了解一门技术或者框架上。我偶然看到了 &lt;code&gt;开课吧&lt;/code&gt; 的架构师培训班，毅然决然的报名了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1515111/201912/1515111-20191220211011300-197343200.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这段时间，我可以说是自己成长最快的时候，我了解到了互联网都需要哪些技术，都是用来做什么的，&lt;strong&gt;MyBatis 竟然还有一级缓存和二级缓存，Spring 源码竟然是这样的，我去百度面试题 Bean 的生命周期原来是这样回答，Redis 竟然还能这么玩儿等等&lt;/strong&gt;。可以说，如果没有这段时期开课吧老师的领路，我是不会有这么大的改变的。可能我现在还在 CRUD，不懂源码，处于一问三不知的阶段。&lt;/p&gt;
&lt;p&gt;今年，我回到了家乡，我知道&lt;strong&gt;持续不断的学习是我这辈子必须要经历的路&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;阈值&quot;&gt;阈值&lt;/h3&gt;
&lt;p&gt;这里先给大家普及一下什么是&lt;code&gt;阈值&lt;/code&gt;，阈值指的就是一种临界值，是指一个效应能够产生的最低值或最高值。突破了阈值你的技术和思想才能更上一层楼，所以我能做的就是尽量的吸收更多的知识，接触更多的人，和更优秀的前辈接触。&lt;/p&gt;
&lt;p&gt;就比如我要在有限的时间里学的更多，因为我大学四年荒废了四年，所以现在开始补，毫无怨言。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1515111/201912/1515111-20191220211024051-515933512.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;凌晨四点的太阳，谁没见过似的。。。不过我这里没有太阳，只有雾霾。&lt;/p&gt;
&lt;p&gt;因为我需要哄女朋友睡觉，第一个闹钟是第一开始我把女朋友哄睡了之后起床的闹钟，如果这个闹钟响了她没有睡着，我会在&lt;code&gt;凌晨2:40&lt;/code&gt; 再哄她一次，经检验这种方法并不可取。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以我现在的睡眠都是 12:00 之前睡，4:20 起，有的时候没有起来，我会一天都很懊恼&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我相信只有比别人多吸收，尽快达到阈值，才能进步更快，才能追上大佬们的脚步。&lt;/p&gt;
&lt;p&gt;这里有一片文章，&lt;a href=&quot;http://blog.thefirehoseproject.com/posts/learn-to-code-and-be-self-reliant/&quot; class=&quot;uri&quot;&gt;http://blog.thefirehoseproject.com/posts/learn-to-code-and-be-self-reliant/&lt;/a&gt; 如何提高自己的编程技能，会提到阈值的看法，希望你能认真读下来，这也是左耳朵耗子强烈推荐的。&lt;/p&gt;
&lt;p&gt;然后我开始认识各种牛逼的人，之前一直羡慕这些人为什么公众号做的这么屌，其实这都是有原因的，没有人能随随便便成功。&lt;/p&gt;
&lt;p&gt;我学习 &lt;code&gt;SpringBoot&lt;/code&gt; 认识到了纯洁的微笑、江南一点雨，偶然发现沉默王二的文章写的真有意思，学习 &lt;code&gt;SpringCloud&lt;/code&gt; 认识到了程序员DD，看 Hollis 写的优质技术文章，也认识了Java知音的文章真是精选，还有各种牛逼的公众号主，这里就不一一举例子了。&lt;strong&gt;哦对了，我还是 Java 极客技术的合伙人，我们团队还有很多优秀的人才，东、子悠、惊奇、慧权、炸鸡可乐&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这里我想说，&lt;strong&gt;你十年前的经历决定了你现在的位置。你现在的努力和方向决定着你的未来&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这里我还想说，高学历人才不一定牛逼，我在的甲方工作十年了几乎没用过 Linux，不知道 &lt;code&gt;tab&lt;/code&gt; 自动补全。在这里技术是什么？他有所谓的&lt;code&gt;能干活&lt;/code&gt;值钱吗？而且高学历人才不一定有素质，我每天中午工作的地点照样有甲方的人斗地主，外放打电话，集体开黑的情况，高分贝骂脏话的情况。但是高学历的人毕竟是不一样，从谈吐，交流，思维逻辑上就跟我这种人不一样。&lt;/p&gt;
&lt;p&gt;没有念大学的和考上清华北大的人本质上没有任何区别，高考并不是决定一生的转折点，持续改变自己，持续学习才是。与我同批培训的同学，大多转行或者回老家，在软件行业的就专注于业务，能在技术道路上一直坚持的，可能只有我了吧，想当年我还是那个因为听不懂培训课在楼道里坐了一下午没人发现的差生。真是戏谑，呵呵。&lt;/p&gt;
&lt;h3 id=&quot;知识储备&quot;&gt;知识储备&lt;/h3&gt;
&lt;p&gt;知识储备其实和阈值有很多相似的地方，也可以说知识储备是达到阈值的必经之路。只有足够的只是储备，你看问题的角度才会变。&lt;/p&gt;
&lt;p&gt;如果你不懂Java 虚拟机的构造，你就不知道产生 OOM 的原因是什么，你甚至可能还会把 OOM 的原因定位为程序计数器的原因。&lt;/p&gt;
&lt;p&gt;古人云间多才能识广，站得高才能看得远，这对于软件设计来说太重要了。如果你第一开始的图纸是按照&lt;code&gt;夏利&lt;/code&gt;来画的，后期你却想按照图纸造出一辆保时捷，那可能吗？&lt;/p&gt;
&lt;p&gt;这也是很多项目中 bug 一直在改，一直改不完的关键因素：无法定位核心问题，拆了东墙补西墙。最重要的就是你看问题的角度不一样，那怎么才能一样了呢？学习，增加知识储备。&lt;/p&gt;
&lt;p&gt;所以我的关注点就一直放在了学习上，我在地铁上在刷书，刷课，晚上下班回家就在学习，下面是我的图书角和我的图书分类&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1515111/201912/1515111-20191220211037908-1628643271.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面的书我会先浏览一遍，如果值得买我会毫不犹豫的花钱购买。虽然这些书还没有看完，但是我相信这些书看完都不是事儿。&lt;/p&gt;
&lt;p&gt;我在地铁上不会再去注意哪个妹子好看，我会在早上和晚上的地铁上各刷一篇极客时间的文章或者视频。以求得深入理解。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关注点、阈值、知识储备&lt;/strong&gt;三驾马车并驾齐驱，才能让你收获你想要的，这三个词也是我的座右铭&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1515111/201912/1515111-20191220211048348-206000528.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;写作&quot;&gt;写作&lt;/h3&gt;
&lt;p&gt;2019 年注定是不同寻常的一年，并不只是因为它是我的本命年。&lt;/p&gt;
&lt;p&gt;2019 年我觉得&lt;code&gt;最有价值&lt;/code&gt;的一件事情就是我开启了写作生涯，真正开始系统的学习，我觉得写作这件事情真的异常的有用，我在写作的时候会思考，如何把一个知识点讲明白，哪块内容是基础，哪块内容是进阶部分，哪些是难点需要深挖，哪些知识只是会了就行，而且你在思考的过程中会进行知识的梳理和外部拓展，遇到不会的地方会寻求谷歌和百度的帮助，这是一种主动学习的方式，而金字塔模型中，主动学习的有效性要高得多。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1515111/201912/1515111-20191220211057218-772741742.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而写作我觉得是包含了主动学习这三种方式。写作的时候是自己和自己讨论的过程，你会把正确的结果写到你的文章里面，也是一个从理论到实践的过程，在这个过程中，你会尽量清晰明白或者幽默搞笑的把某个知识点或技术点讲明白，这同时也是教授他人的过程。但写作有个缺点那就是闷声不响，这个其实也会打一些折扣。&lt;/p&gt;
&lt;p&gt;2019 年我是写了不少的文章，下面是我的文章分类&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1515111/201912/1515111-20191220211108306-1955761863.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我计划是要每个文件夹下都要出一个系列，事实情况做不到，有的东西确实太多太深，但是目前的我深知自己能力有限。我尽量明年能出4个系列的文章。今年写的 &lt;code&gt;Java&lt;/code&gt; 和 &lt;code&gt;Spring&lt;/code&gt; 的内容比较多，目前也在写 &lt;code&gt;kafka&lt;/code&gt; 系列内容。如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1515111/201912/1515111-20191220211119713-1958023709.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面是我的文章推荐，我觉得可取的并且坚持在写还有写完的有三个系列的文章&lt;/p&gt;
&lt;p&gt;《程序员需要了解的硬核知识》系列文章&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU2NDg0OTgyMA==&amp;amp;mid=2247484585&amp;amp;idx=1&amp;amp;sn=0d6c3ccf8cc5bec2fea80eb437213801&amp;amp;chksm=fc45f95acb32704c7dcc952a803e88e8a9b0e67c86d8c27abf4e6c776e48b1fcd770dd2dcc8d&amp;amp;token=1323660303&amp;amp;lang=zh_CN#rd&quot;&gt;程序员需要了解的硬核知识之CPU&lt;/a&gt;（强烈推荐）&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU2NDg0OTgyMA==&amp;amp;mid=2247484617&amp;amp;idx=1&amp;amp;sn=497af1daab7bba6b44ca291194c56621&amp;amp;chksm=fc45f93acb32702c5bc8575f7830f2b585952e31e62af3d73867c42360a2f538ae779452eb52&amp;amp;token=1323660303&amp;amp;lang=zh_CN#rd&quot;&gt;程序员需要了解的硬核知识之内存&lt;/a&gt;（强烈推荐）&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU2NDg0OTgyMA==&amp;amp;mid=2247484654&amp;amp;idx=1&amp;amp;sn=9b6f5aaad05a49416e8f30e6b86691ae&amp;amp;chksm=fc45f91dcb32700b683b9a13d0d94d261171d346333d73967a4d501de3ecc273d67e8251aeae&amp;amp;token=1323660303&amp;amp;lang=zh_CN#rd&quot;&gt;程序员需要了解的硬核知识之磁盘&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU2NDg0OTgyMA==&amp;amp;mid=2247484672&amp;amp;idx=1&amp;amp;sn=7de8762995227b21f35c6bbb47b22233&amp;amp;chksm=fc45f8f3cb3271e5deac7e08d5dcdbfb24e3d66a1ac431fd78252bb0e0cb3cd1c727f053211a&amp;amp;token=1323660303&amp;amp;lang=zh_CN#rd&quot;&gt;程序员需要了解的硬核知识之压缩算法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU2NDg0OTgyMA==&amp;amp;mid=2247484692&amp;amp;idx=1&amp;amp;sn=0587d38c6b4d53183f4242692c53a445&amp;amp;chksm=fc45f8e7cb3271f1705a49f45d9f88e4fee38c50769504419fd24449c8dfe3176d019df89f2f&amp;amp;token=1323660303&amp;amp;lang=zh_CN#rd&quot;&gt;程序员需要了解的硬核知识之操作系统入门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU2NDg0OTgyMA==&amp;amp;mid=2247484714&amp;amp;idx=1&amp;amp;sn=288d25ee351f83346a3aed2419804ddf&amp;amp;chksm=fc45f8d9cb3271cf6b741c4aee9156d07cfbc7c4ed76154ea95b3c29ec9d772fec6aa243c745&amp;amp;token=1323660303&amp;amp;lang=zh_CN#rd&quot;&gt;程序员需要了解的硬核知识之操作系统和应用&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU2NDg0OTgyMA==&amp;amp;mid=2247484788&amp;amp;idx=1&amp;amp;sn=8a17224cabe09d3bd564dfdf22e2ff5d&amp;amp;chksm=fc45f887cb3271914f0e688a3cce4d7e3ce9077cdde199648e72aa92ad08fba2047b4483b7e8&amp;amp;token=1323660303&amp;amp;lang=zh_CN#rd&quot;&gt;程序员需要了解的硬核知识之汇编语言(全)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU2NDg0OTgyMA==&amp;amp;mid=2247484853&amp;amp;idx=1&amp;amp;sn=83b82c31bd9bf302d478e0a8caf6f14d&amp;amp;chksm=fc45f846cb3271501f55b66d364d5496c6f89161c1128fae0894c2254a667d4d53608ed14216&amp;amp;token=1323660303&amp;amp;lang=zh_CN#rd&quot;&gt;程序员需要了解的硬核知识之控制硬件&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU2NDg0OTgyMA==&amp;amp;mid=2247484433&amp;amp;idx=1&amp;amp;sn=1d38a52711fbae448a07259af0c03669&amp;amp;chksm=fc45f9e2cb3270f4367a30def207b9c14915a1abb27e115fb8c934af6c0d70a466db19e52ea1&amp;amp;token=1323660303&amp;amp;lang=zh_CN#rd&quot;&gt;程序员需要了解的硬核知识之二进制&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;《看完你就明白的锁系列》 系列文章&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU2NDg0OTgyMA==&amp;amp;mid=2247484919&amp;amp;idx=1&amp;amp;sn=b36b9b84ad50559210b6f21901a882b9&amp;amp;chksm=fc45f804cb327112bb4301191d8f3a464244ca7cb93da73f3b1d8ff28821d6ac32e2512d66e0&amp;amp;token=1323660303&amp;amp;lang=zh_CN#rd&quot;&gt;不懂什么是锁？看看这篇你就明白了&lt;/a&gt;（强烈推荐）&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU2NDg0OTgyMA==&amp;amp;mid=2247484531&amp;amp;idx=1&amp;amp;sn=aca8142c1ca387ad276f0d2956a7e2c1&amp;amp;chksm=fc45f980cb32709667c1440b55ee6134437f6344dfd56ad1808ab36cd089b2da62b9c97cf9eb&amp;amp;token=1323660303&amp;amp;lang=zh_CN#rd&quot;&gt;看完你就应该能明白的悲观锁和乐观锁&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU2NDg0OTgyMA==&amp;amp;mid=2247484543&amp;amp;idx=1&amp;amp;sn=8be33d9dd1c1d2ce47e8882c0cf8821b&amp;amp;chksm=fc45f98ccb32709a96105b33e74405e14de8fab60268473f26aa554805a0835427801d387e11&amp;amp;token=1323660303&amp;amp;lang=zh_CN#rd&quot;&gt;看完你就明白的锁系列之自旋锁&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU2NDg0OTgyMA==&amp;amp;mid=2247484568&amp;amp;idx=1&amp;amp;sn=6d5cc341cfd017009eb12681b8d8f378&amp;amp;chksm=fc45f96bcb32707d7c416e24cfd04d74c8c91747c779713cc0ccf7c2b03b2121dde921725814&amp;amp;token=1323660303&amp;amp;lang=zh_CN#rd&quot;&gt;看完你就明白的锁系列之锁的状态&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU2NDg0OTgyMA==&amp;amp;mid=2247484630&amp;amp;idx=1&amp;amp;sn=b0590fece2315c40e87de041b9e9362a&amp;amp;chksm=fc45f925cb327033c66b9561eae46ff4fb95732bd73749d093af27c6bd27ac045aa6537ea447&amp;amp;token=1323660303&amp;amp;lang=zh_CN#rd&quot;&gt;看完你就明白的锁系列之锁的公平性&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;《Kafka 系列》系列文章&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU2NDg0OTgyMA==&amp;amp;mid=2247484570&amp;amp;idx=1&amp;amp;sn=1ad1c96bc7d47b88e976cbd045baf7d7&amp;amp;chksm=fc45f969cb32707f882c52d7434b2c0bf2ccbbc2cd854e1dc5c203deb8ae9c1831cf216e8bad&amp;amp;token=1323660303&amp;amp;lang=zh_CN#rd&quot;&gt;带你涨姿势的认识一下kafka&lt;/a&gt;（强烈推荐）&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU2NDg0OTgyMA==&amp;amp;mid=2247484768&amp;amp;idx=1&amp;amp;sn=724ebf1ecbb2e9df677242dec1ab217b&amp;amp;chksm=fc45f893cb327185db43ea9363928d71c54c62b1d9048f759671de3737d62e0e2d265289b354&amp;amp;token=1323660303&amp;amp;lang=zh_CN#rd&quot;&gt;真的，关于 Kafka 入门看这一篇就够了&lt;/a&gt;（强烈推荐）&lt;/p&gt;
&lt;p&gt;写作的路我会一直坚持的，因为这些一直是让我觉得写作和分享简直就是这世界上最快乐的事情了，尤其是自己的文章被别人阅读并且还能获得认可的时候。&lt;/p&gt;
&lt;p&gt;我还通过写作获得了别人的认可，这是阿里一个 Leader 给我发来的面试邀约，右面是我们的对话&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1515111/201912/1515111-20191220211131768-1686284136.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我相信未来会有我走近阿里的那一天的。&lt;/p&gt;
&lt;p&gt;还有一件最有价值的事第二的是注册了自己的公众号。从零做起，起步艰难。下面是我这一年来公号的文章总结。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1515111/201912/1515111-20191220211141090-113022432.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面是我这一年来关注人数分析&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1515111/201912/1515111-20191220211149729-785128381.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也是我基本上从九月份开始每天都有增长，虽然人数不多，但是开始呈现好的势头，完全是从零做起，没有任何推广渠道，只有靠文章质量吸引人，下面是我觉得个人比较好的引导关注&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1515111/201912/1515111-20191220211157570-1542227074.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;后来我同时也注册了各大博客网站，你可以在上面找到我 &lt;code&gt;cxuan&lt;/code&gt;，&lt;strong&gt;排名不分先后&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;CSDN ： &lt;a href=&quot;https://blog.csdn.net/qq_36894974&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/qq_36894974&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;博客园： &lt;a href=&quot;https://www.cnblogs.com/cxuanBlog/&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/cxuanBlog/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;思否： &lt;a href=&quot;https://segmentfault.com/u/cxuan&quot; class=&quot;uri&quot;&gt;https://segmentfault.com/u/cxuan&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;掘金：&lt;a href=&quot;https://juejin.im/user/5d8cc85d5188254d014e2b79&quot; class=&quot;uri&quot;&gt;https://juejin.im/user/5d8cc85d5188254d014e2b79&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;慕课手记： &lt;a href=&quot;https://www.imooc.com/u/index/articles&quot; class=&quot;uri&quot;&gt;https://www.imooc.com/u/index/articles&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;自己也搞了一个个人博客网站，正在备案中，还没有做好，就不贴个人主页链接了。&lt;/p&gt;
&lt;p&gt;最有价值的事情之三是我加入了一个团队，&lt;code&gt;Java 极客技术团队&lt;/code&gt;，里面有一些个方面的人才，都是作者，我们在这里分享优质文章，交流经验，互助合作。这里就相当于我的第二个职业，并且我从中赚到了一些钱，能够满足我的日常开销。&lt;strong&gt;别问我的工资呢，问就是没有&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;下面是我极客技术发表的文章汇总&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1515111/201912/1515111-20191220211207012-434864562.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最有价值事情之四是我养了一条狗，它叫 &lt;code&gt;盖饭&lt;/code&gt;，我也叫它&lt;code&gt;憨憨&lt;/code&gt;，它实在是太有趣了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1515111/201912/1515111-20191220211216359-1812966978.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;卖萌生气撒娇打架无所不能，天生演技派，之前出门打不过任何一条小狗，现在我叫它&lt;code&gt;狗霸&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;自省&quot;&gt;自省&lt;/h3&gt;
&lt;p&gt;聊了这么多，还是要说点严肃的事情，其实我文章写的并不好，有的时候参考的比较多，比如《程序员需要了解的硬核知识》就大量借鉴了 《程序是怎样跑起来的》书中的内容，虽然作者不是中国人，《看完你就明白的锁系列》也是大量参考了网络中优秀的文章，《带你涨姿势的认识一下Kafka》也是我看书，参考写出来的。但是我觉得如果有能力，还是要尽量从脑子里面蹦出来一些知识的。我觉得这样应该很难吧，自己参考 -&amp;gt; 吸收 -&amp;gt; 创作。&lt;/p&gt;
&lt;p&gt;文章中的切入点比较少，很多都是用法和总结，有的时候让人看着昏昏欲睡。明年需要提升自己文字功底。最开始写文章的时候，有很多代码示例应该要放到 &lt;code&gt;github&lt;/code&gt;下面的，但是我因为懒所以没有放，这也是个不好的习惯，做事要尽善尽美。&lt;/p&gt;
&lt;p&gt;最大的一个问题我觉得是，自己业余的时间都花在了&lt;code&gt;陪女票&lt;/code&gt;和&lt;code&gt;写作&lt;/code&gt;上面，几乎一整年没有出去和朋友外界交流，表现为&lt;code&gt;语言功能严重退化,表述能力衰竭&lt;/code&gt;。很多时候无法表述自己真实的想法，这个绝对是不行的，码农除了编码，还是要与人交流的，而且交流也是激发自己创造力的一个方式。&lt;/p&gt;
&lt;p&gt;自己在 2019年打开了不少书，但是看完的却没几本，有种三分钟热度的节奏，这个仍然是不行的，书一定要读透了才行，读书不在多，在于质量。打比方说吧：如果你能把《深入理解计算机系统》吸收了，那你不需要看任何关于计算机构造的书了，如果你能把《计算机网络：自定而下的方法》研读透了，那么网络设计网络编程对于你来说还是事儿吗？如果你能把 《TCP/IP详解》研究清楚，那么你是不是就能《吊打面试官》了？&lt;/p&gt;
&lt;p&gt;可能我的眼光有些片面，但是这确实我目前层次的理解。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;女朋友呢？女朋友都不叫最有价值的事情好吧，女朋友怎么能是有价的呢？女朋友必须是无价之宝啊&lt;/strong&gt;！所以上述的一切和女票，我还是会选她的。其实我和我家憨憨一样，都是 &lt;code&gt;舔狗&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这里希望大家多多看我的文章，我不能保证每个技术点都是对的，但是这却是我成长路上最用心的总结了，我是 cxuan。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果大家认可我，请帮我点个赞，谢谢各位了。我们下篇技术文章见&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1515111/201912/1515111-20191220211254847-444090764.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 20 Dec 2019 13:14:00 +0000</pubDate>
<dc:creator>cxuan</dc:creator>
<og:description>岁月你别催，该来的我不推；岁月你别催，走远的仍要追 ，这是《天下足球》里面的一则年度佳句，我觉得用到软件行业再合适不过了。 我可以用IT行业的排比句来仿造一下这段话，那就是 裁员你别来，你来了给我钱；</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cxuanBlog/p/12075094.html</dc:identifier>
</item>
<item>
<title>从实习到转正，2019我的技术踩坑之路！ - 浪人~</title>
<link>http://www.cnblogs.com/liqiangchn/p/12075044.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liqiangchn/p/12075044.html</guid>
<description>&lt;p&gt;2019年可以说是对我来说是特别重要的一年。正式结束了自己的学生时代，从事了一个自己不讨厌的职业，遇到了一群优秀的人，一切都还算挺好吧。&lt;/p&gt;
&lt;p&gt;从2018年7月份开始实习，至今已经过了18个月，这也意味着北漂已经刚好一年半。一路走来，踩过很多坑，犯过很多错误，与此同时对于我个人来说也有了很大的提升和改变。所以本次借着年终总结的机会，谈一谈从实习到现在自己关于学习，工作以及自我认知的一些体会，顺便讲一讲我的狗血实习经历。&lt;/p&gt;
&lt;h2 id=&quot;一狗血的实习&quot;&gt;一，狗血的实习&lt;/h2&gt;
&lt;p&gt;第一次实习在一家小型创业公司，做的是互联网金融，实习四个月就倒闭了，这可能是我犯的第一个错误。大三暑假刚开始，就一个人来到了北京，身上也没有什么钱，靠着父母的救济租了一间1500块钱一个月的房子，然后开始了自己的北漂，刚开始一切都还好(从此喜欢上了做饭)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://source.mycookies.cn/201912202008_2.jpg?ERROR&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于没有充分的准备，所以就采用了海投的方式，由于简历看着非常一般，并且错过了找实习的最佳时间，所以但回复的并不多。大概在7月8号左右，收到了两份面试邀请，并幸运的拿到了offer，一家是做铁路系统相关的软件开发，而另一家是位于环球金融中心的互联网金融公司。&lt;/p&gt;
&lt;p&gt;由于兜里没钱，在北京多待一天，感觉生活压力就越大，就想快速在北京安顿下来，所以没有再继续找工作，而是草草作出了选择。第一家在上地，每个月给3.5k，经常出差，并且从hr哪里了解到毕业后给的也不多，而第二家公司看起来相当高大上，实习给的薪资也差不多,转正之后各方面待遇都优于第一家，所以就选则了这家互联网金融公司。&lt;/p&gt;
&lt;p&gt;故事从这里正式开始，工作的第二周开始接触项目，做一些简单的工作，后来进入了所谓的封闭开发(租了两套别墅，吃喝拉撒都在这里)，每天做的都是重复的工作，效率低，质量也不高，也没有什么技术氛围，个人认为大概是因为老板不懂技术以及公司的性质决定的吧，不过待遇挺好，每天吃好喝好，所以一个月重了十几斤。&lt;/p&gt;
&lt;p&gt;2018年下半年开始，P2P接连暴雷，我们也没有幸免于难（母公司主要是做P2P）。最终在10月份，由于工资无法正常发放，许多同事陆续离职，我也在10月下旬离职了，结束了第一份实习工作。&lt;/p&gt;
&lt;p&gt;接下来就进入了狗血的讨薪之路，当时公司已经确定是黄了，拖欠了5k多的实习工资(实习期间加了一次薪)，虽然不多，但是一分钱难倒英雄汉，更何况当时在北京生活费都是借的，就等着发工资还账，工资拖欠了一个月，当时负债已经过万了，可以说相当悲惨了。在多次讨薪(去总部找公司领导，一群人将其堵在办公司的场景大家可以脑补)无果后，看领导一副死猪不怕开水烫，一副不想发工资的样子，有同事开始搬电脑了。所以我和另一个实习生一拍即合也去搬了两台电脑，这才算是吃下了一颗定心丸，自此之后的讨薪也就不关注了，反正手中有粮薪心不慌。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://source.mycookies.cn/201912202005_558.png?ERROR&quot;/&gt;&lt;/p&gt;
&lt;p&gt;经过几个月的努力，最后拖欠的工资发了，电脑也给送回去了，我也找到了另一份实习工作，也就是现在所在的公司。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://source.mycookies.cn/201912202005_211.png?ERROR&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第一份实习彻底打乱了我的计划，让我在北漂第一阶段变得十分狼狈，不过一切都过去了，除了狗血的经历也有了一些收获。认识了一些优秀的人，文轩，张鹏，安琪，少华，超哥，老薛...，每个人都有许多值得我去学习的地方。在此也要特别感谢职场第一个领导—海哥，在工作中对我十分照顾。&lt;/p&gt;
&lt;p&gt;总结一下，第一份实习是一个错误的选择，选择了一个错误的时间，使我错过了秋招；选择了错误的公司，让我实习4个月后欠了上万块，并且由于公司中途变动，还搬了两次家；几个月下来每天疲于工作(不得不吐槽一下，最恶心的就是不管你晚上加班到几点，每天早上9点还要打卡)，所以，学弟学妹们在选择实习时一定要慎重考虑，选择一家靠谱, 对自己成长有利的实习工作太重要了，能解决温饱就好，薪资没拿么重要。&lt;/p&gt;
&lt;p&gt;由于第一份实习，节奏彻乱了，幸运的是，第一家实习结束之后的第三天就找到了第二家实习，也就是现在的公司。这里也是我改变的开始，实习待遇在行业内可以说是不错了，还有各种补贴，能解决在北京的基本生活问题。扁平化的管理，弹性的工作时间，减少了在工作中一些华丽花哨的东西，总之还算符合我的预期。最让人兴奋的是刚来公司两个月就赶上了公司年会，蹭了个出国旅行，过年还给实习生带薪年假，另加1000过节费，可以说是美滋滋了。&lt;/p&gt;
&lt;p&gt;了解了一下泰国的文化和风景。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://source.mycookies.cn/201912202058_977.png?ERROR&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://source.mycookies.cn/201912202016_244.jpg?ERROR&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一切的改变都是从这里开始。&lt;/p&gt;
&lt;h2 id=&quot;一工作感悟&quot;&gt;一，工作感悟&lt;/h2&gt;
&lt;p&gt;作为一个职场新人，学校中的那套方法论运用到工作中可能就不那么好用了。所以，一年半以来感觉在工作中学到了很多东西，这些与技术无关。&lt;/p&gt;
&lt;h3 id=&quot;件件有着落事事有回音&quot;&gt;&lt;strong&gt;件件有着落，事事有回音&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;​件件有着落，事事有回音！这应该是每一个职场新人必须要知道的且必须具备的一个基本素质。对于领导的一些工作安排以及通知，要及时做出反馈，这一点很重要。&lt;/p&gt;
&lt;p&gt;首先，这是人与人之间最基本的尊重，别人跟你的交流，应当及时做出反馈，消息是否收到，是否明确通知的意思，对于交代的工作存有疑问等。&lt;/p&gt;
&lt;p&gt;第二，这是高效沟通的必要条件。想要高效地工作，高效率的沟通尤为重要，对于同事的论述与问题及时做出回应，表明是否收到了消息，get到对方的观点和想要表达的想法，即使当时不能解决对方的问题，也应当予以回复，减少沟通双方的信息差。&lt;/p&gt;
&lt;h3 id=&quot;owner意识&quot;&gt;&lt;strong&gt;owner意识&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;所谓Owner意识也就是主人翁意识，主要体现在两个方面，一是认真负责的态度二是积极主动的精神。&lt;/p&gt;
&lt;p&gt;认真负责是底线。对于交付的结果负责，对于自己的代码负责，要认真对待我们的没一行代码。代码要符合团队或公司规范，统一风格，注释要清晰，保证高质量交付任务。&lt;/p&gt;
&lt;p&gt;积极主动则是Owner的更高级的要求。对于负责的模块，要按时保证质量完成，但是也应当积极主动发现问题，暴露问题，解决问题。在开发过程中可能遇到一些遗留的问题，可能跟自己负责的模块无关，或者当前对系统的影响并不大，很多人可能会因为手头工作比较多假装看不见，选择忽略此问题，这是典型的缺乏owner意识表现，我们应当主动反馈问题，记录问题并解决问题。&lt;/p&gt;
&lt;p&gt;有时我们不仅要完成自己负责功能模块，还需要与其他同事或者跨部门沟通。我感觉作为团队中的一员应主动承担起责任，积极主动沟通，推动合作项目的进度，保证项目顺利完成。在完成本职工作后，积极主动寻求更多的工作中去，是对自己来说是为自己寻求学习与进步的机会，对于团队来说则是一个Buff。&lt;/p&gt;
&lt;h2 id=&quot;三关于学习&quot;&gt;三，关于学习&lt;/h2&gt;
&lt;p&gt;关于学习，真的有太多话要说了。从自学Java到现在已经三年多了，真的是走了太多的弯路，踩过太多的坑！&lt;/p&gt;
&lt;h3 id=&quot;做减法&quot;&gt;&lt;strong&gt;做减法&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;对于需要用到的技术首先要知道怎么用，可以根据&lt;strong&gt;官方文档的quick start快速入门&lt;/strong&gt;，或者找个相关&lt;strong&gt;学习视频&lt;/strong&gt;大体上过一遍，对于整个技术有个整体的认识。不过，在学习上一定要减法，这也是刚入职时我的导师重点强调的一件事情！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;要抵挡住技术的诱惑&lt;/strong&gt;，不知道大家是否有和我一样的问题。刚开始对于好多技术，比如某某框架，消息中间件，数据库等都想学习，今天学这个明天学那个，或者说是 看到别人在学什么东西，自己立马也要跟着学。这大概就是我前两年的学习策略了，到最后面试时才发现，&lt;strong&gt;学过再多不如精通一个&lt;/strong&gt;，因为面试时没有人回问你哪些api怎么使用，面试官关注的更多的时技术的底层实现原理。所以，对于技术的学习，个人认为&lt;strong&gt;最好一次只学一个技术，保持专注。(不要同时学习多个技术)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;深度优先&lt;/strong&gt;，保持专注的同时，一定要深挖底层实现。对于要学习的技术不仅要知道是什么，怎么用，更重要的还要知道怎么实现的。比如MySQL索引，只有知道了索引的数据结构以及索引是如何设计的，才能更好的选择和使用索引，对于索引的使用做到心中有数。技术总是可以触类旁通的，当学完MySQL之后再学习MangoDB时，你会发现他们索引的底层数据结构都是使用B+Tree，学习起来就非常轻松了。&lt;/p&gt;
&lt;h3 id=&quot;学会总结&quot;&gt;&lt;strong&gt;学会总结&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;从实习刚开始，导师就要求每周要进行一次学习总结。之前一直以为写学习总结是在浪费时间，把这项要求当作是一个任务和负担，看完一本书或者学完一门技术之后从来没有进入深入总结和思考，学过的技术过不了多久很快又还了回去。&lt;/p&gt;
&lt;p&gt;现在我把写总结当成了是一种习惯。学完一个知识点或者是定期都会进行总结，总结的内容不再是学习了什么以及做了哪些事情，而是学完了某个知识点之后&lt;strong&gt;与之前相比有哪些收获&lt;/strong&gt;，对于其&lt;strong&gt;他技术的学习有了什么样的影响&lt;/strong&gt;，以及当前技术有哪些&lt;strong&gt;缺点和优点&lt;/strong&gt;（知道缺点和优点一样重要）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;知识输出&lt;/strong&gt;，上个月开通了公众号cruder，准备把一些学习笔记梳理一下输出到公众号中。在写博客的过程中收获良多，对于一个知识点总要去查阅很多资料来确保它的正确性，同时还要尝试去把一个问题说清楚，需要去组织语言，绘图等，虽然花了很多时间，感觉还是值得的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://source.mycookies.cn/201912201934_259.png?ERROR&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到今天为止，公众号也刚好满月了。粉丝数从0页增加到了一个魔力数字222，一共输出了6篇文章，2019年还剩一个多月，500个粉丝有没有希望还是个未知数~&lt;/p&gt;
&lt;h3 id=&quot;用好8小时之外时间&quot;&gt;&lt;strong&gt;用好8小时之外时间&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;不知是否和我一样，感觉工作占用了大量的时间和精力，没有时间去学习。不过时间就像rugou，挤剂总会有的！利用好8小时之外的时间，我们可以做很多事情；比如，每天上&lt;strong&gt;下班地铁上时间读书&lt;/strong&gt;，每个月至少能看一本技术书籍！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://source.mycookies.cn/201912201904_959.png?ERROR&quot;/&gt;&lt;/p&gt;
&lt;p&gt;今年总共读了10多本技术书籍吧，基本上大多数书籍读了都不止一遍，有一部分没有列到读书记录中，而这些至少有一半是在地铁上看的。&lt;/p&gt;
&lt;p&gt;近一年来，从来没有12点之前睡觉。已经样成了习惯，每天坚持学习到一点钟（偶尔加钟），七点钟起床(取决于几点睡)。当然这个要根据自己来决定了，毕竟有些人早睡早期效率高，而有的人则是熬夜学习效率更高，不过不管怎样，&lt;strong&gt;多花点时间学习是绝对没有错&lt;/strong&gt;的。&lt;/p&gt;
&lt;h3 id=&quot;学习资源&quot;&gt;&lt;strong&gt;学习资源&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;多读书，这很重要！&lt;/strong&gt;古人云，书中自有颜如玉，书中自由黄金屋！真的太对了！非常可怕的是，前两年学习过程中，没有认真读过一本书！就是传说中啥都会，啥都不会。对于学过的技术都知道怎么使用，对于实现原理也略知一二，不过稍微深入或者扩展一点基本上就gg了。这也是自学时最坑爹的事情了，根本真不知道该学什么，该怎么学，总感觉能实现功能就够了...&lt;/p&gt;
&lt;p&gt;对于学习&lt;strong&gt;视频以及其他课程是快餐&lt;/strong&gt;，能解决问题但不是长久之计！网上各大培训机构的免费视频，或者&amp;lt;极客时间&amp;gt;里的付费课程，相信大家都能找到适合自己的。这些课程通常都是视频或者音频，适合人类阅读，也更容易被接受和吸收，所以非常&lt;strong&gt;教学视频适合快速入门一门技术&lt;/strong&gt;。不过对技术的深入学习，还需要通过书籍和官方文档等权威的资料。所以，对于技术的学习我感觉通常可以通过&lt;strong&gt;教学视频或者官方quick start入门&lt;/strong&gt;， &lt;strong&gt;然后再阅读书籍深入理解， 最后结合源码深入学习，印证自己的猜想和认知&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;对于学习资料的获取，可以说路子非常广了。没毕业时比较穷，喜欢去找一些盗版的教学视频，各大培训班免费的视频。当然现在依旧很穷，不过偶尔会花些钱支持一下正版。当然一切都是我自己摸爬滚打探索出来的，因为刚开始学习时没有人教过我，走了不少弯路，所以希望初学的小伙伴能认真读完。&lt;/p&gt;
&lt;p&gt;选对书籍，每一本技术书籍都需要花费很多时间才能阅读完，所以选对书很重要。通常可以请教一些&lt;strong&gt;靠谱的前辈&lt;/strong&gt;，毕竟好多坑他们可能替我们踩过了；其次就是到豆瓣上搜一下，看一下评分和评价，通常情况下8.0以上的技术书籍都是值得阅读的；如果是新出的书籍，可以看一下作者的来历，如果作者是一线大厂的技术专家，或者业界大佬，那买这本书准没错了。以下是我买的书，个人感觉对于Java工程师来说，这些的技术书籍都值得一读。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://source.mycookies.cn/201912201948_586.jpg?ERROR&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在网上的资料非常丰富，不仅数量多，质量也慢慢变高了，所以找一份学习资料并不难。由于版权等问题，有些视频资料获取可能会有一些小小的困难。通常我们可以在一些&lt;strong&gt;培训机构官网&lt;/strong&gt;找到一些入门的课程，如传智播客，尚硅谷等，我当时入门java就是看的风清扬的java基础课程；其次当然是&lt;strong&gt;万能的B站&lt;/strong&gt;，有很多热心的up主会上传一些不错的课程；最后则是付费课程了，如慕课网，极客时间（强烈推荐）的课程质量都还可以也不贵，至于腾讯可能，xx学院等一些什么架构师，年薪百万的课程就不推荐了（看过盗版，大多数都是收智商税的）。当然，如果没钱买正版，网上也有一些绿色资源，可以自行探索一下，或者在我公众号里留言，我帮你找找，网盘里已经存了一千多G视频了...&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://source.mycookies.cn/201912201958_60.png?ERROR&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://source.mycookies.cn/201912201958_176.png?ERROR&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然，还有一些技术社区也有很多干货。如&lt;strong&gt;博客园&lt;/strong&gt;，简书，&lt;strong&gt;掘金&lt;/strong&gt;，以及大佬们的公众号，如 &lt;strong&gt;架构师之路， Hollis&lt;/strong&gt;等，也可以关注我的渣渣公众号Cruder。&lt;/p&gt;
&lt;h2 id=&quot;四展望2020&quot;&gt;四，展望2020&lt;/h2&gt;
&lt;p&gt;2019年经历了很多事情，来回搬家，毕业，实习转正等。如果给自己的打个分的话，也就勉强及格7分吧，主要在于上半年没有进入状态。过去的都已经过去了，希望2020年能遇见更好的自己。&lt;/p&gt;
&lt;p&gt;2020年期望自己在技术上能有所进步，打牢基础知识的同时，深入研究1门技术，至于是消息中间件，还是数据库技术目前还没有确定，总之至少要学好一门。&lt;/p&gt;
&lt;p&gt;每个月至少两篇技术博客，这个比较保守，正常应该每周写一篇吧。对于学过的知识深入研究和总结，分享给别人的同时也锻炼一下自己的写作能力。&lt;/p&gt;
&lt;p&gt;读10本技术书籍，&lt;strong&gt;读书真的很重要，&lt;/strong&gt;这个flag必须要实现！同时希望公众号粉丝能够增长到四位数，让更多的人一起见证我的成长，一起进步。最后，希望能认识更多志同道合的朋友，能够一起成长的小伙伴可以关注一下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://source.mycookies.cn/201912140139_583.png?ERROR&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 20 Dec 2019 13:01:00 +0000</pubDate>
<dc:creator>浪人~</dc:creator>
<og:description>2019年可以说是对我来说是特别重要的一年。正式结束了自己的学生时代，从事了一个自己不讨厌的职业，遇到了一群优秀的人，一切都还算挺好吧。 从2018年7月份开始实习，至今已经过了18个月，这也意味着北</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/liqiangchn/p/12075044.html</dc:identifier>
</item>
</channel>
</rss>