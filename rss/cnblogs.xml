<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>celery 安装及使用 - INVOKERrrrrrr~</title>
<link>http://www.cnblogs.com/ZhangShY/p/10091480.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ZhangShY/p/10091480.html</guid>
<description>&lt;h3 id=&quot;安装pip&quot;&gt;1.1 安装pip&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;yum -y install epel-release
yum install python-pip&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;更新pip&quot;&gt;1.2 更新pip&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;pip install --upgrade pip
pip install --upgrade setuptools&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;安装celery&quot;&gt;1.3 安装celery&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;pip install -U Celery&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;中间人安装选择使用redis&quot;&gt;1.4 中间人安装，选择使用redis&lt;/h3&gt;
&lt;h4 id=&quot;安装redis&quot;&gt;1.4.1 安装redis&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;yum -y install redis
vim /etc/redis.conf
#bind 127.0.0.1     // 注释掉，使redis允许远程访问
requirepass 密码  // 修改这行，redis登录密码&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;安装额外依赖&quot;&gt;1.4.2 安装额外依赖&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;pip install -U celery[redis]&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;redis在celery下的使用配置&quot;&gt;1.4.3 redis在celery下的使用配置&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;1）使用配置，只需要设置redis的位置：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;例如：BROKER_URL = 'redis://localhost:6379/0'
格式解释：redis://:password@hostname:port/db_number&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;2）可见性超时&lt;/p&gt;&lt;p&gt;可见性超时定义了等待职程在消息分派到其他程序之前确认收到任务的秒数&lt;br/&gt;通过以下方式配置：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;BROKER_TRANSPORT_OPTIONS = {'visibility_timeout': 3600}  // 默认为1小时&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;这个时间会导致一种情况：任务循环重新执行；可以通过延长可见性时间来解决这个状况，例如&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;BROKER_TRANSPORT_OPTIONS = {'visibility_timeout': 43200}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;3）存储任务的状态和返回值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;CELERY_RESULT_BACKEND = 'redis://localhost:6379/0'          //配置这个参数&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;4）广播信息默认对所有虚拟主机可见，配置成只能被活跃的虚机接受&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;BROKER_TRANSPORT_OPTIONS = {'fanout_prefix': True}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1075630/201812/1075630-20181209154829362-1819648776.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;模块各功能&quot;&gt;2.1 模块各功能&lt;/h3&gt;
&lt;blockquote readability=&quot;26&quot;&gt;
&lt;p&gt;1）任务生产者(task producer)&lt;/p&gt;&lt;p&gt;负责生产计算任务，交给消息队列进行处理。只要是调用了celery的api，我们都可以称为是任务生产者。&lt;/p&gt;&lt;p&gt;2）任务调度器(celery beat)&lt;/p&gt;&lt;p&gt;任务调度器是以独立的进程形式存在，它会读取配置文件的内容，周期性的将任务的请求发给任务队列。celery beat是celery自带的任务生产者，系统管理员可以选择关闭或者开启它，同事一个celery系统只能有一个celery beat调度器。&lt;/p&gt;&lt;p&gt;3）任务代理(broker)&lt;/p&gt;&lt;p&gt;任务代理方负责接收任务生产者发送过来的任务处理消息，存进队列之后再进行调度，分发给任务消费方。因为任务处理是基于message的，所以一般选择使用rabbitmq或者redis等消息队列或者数据库作为celery的message boker&lt;/p&gt;&lt;p&gt;4）任务消费方(celery worker)&lt;/p&gt;&lt;p&gt;celery worker就是执行任务的一方，它负责接收任务处理中间方发来的任务处理请求，完成这些任务，并且返回任务处理的结果。可多节点部署celery worker。&lt;/p&gt;&lt;p&gt;5）结果保存&lt;/p&gt;&lt;p&gt;celery支持任务处理完之后将状态信息和结果的保存，以供查询。&lt;br/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;功能尝试&quot;&gt;2.2 功能尝试&lt;/h3&gt;
&lt;h4 id=&quot;任务生产者入口&quot;&gt;2.1.1 任务生产者入口&lt;/h4&gt;
&lt;p&gt;1）创建celery对象&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from celery import Celery
import time

app = Celery('notify_friends', backend='redis://:123123@localhost:6379/0',broker = 'redis://:123123@localhost:6379/0')

@app.task
def notify_friends(userId,newsId):
        print 'Start at task at {0}, userId: {1}, newsId: {2} .'.format(time.ctime(),userId,newsId)
        time.sleep(2)
        print 'Task notify_friends success at {0}'.format(time.ctime())
        return True
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2）启动celery worker&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;celery -A notify_friends worker --loglevel=info&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3）调用celery api&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from notify_friends import notify_friends
import time

def notify(userId,newsId):
        result = notify_friends.delay(userId,newsId)
        while not result.ready():
                time.sleep(1)
                print result.get(timeout=10)
if __name__ == '__main__':
        for i in range(10):
                notify('root',str(i))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.1.2 任务调度器入口（定时任务调用celery api）&lt;br/&gt;1）创建配置文件，定义schedule&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from datetime import timedelta

CELERYBEAT_SCHEDULE = {
        'select_popular_book':{
                'task': 'favourite_book.select_popular_book',
                'schedule': timedelta(seconds=10),
        },
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2）创建celery对象，并且加载配置文件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from celery import Celery
import time

app = Celery('select_popular_book',backend='redis://:123123@localhost:6379/0',broker = 'redis://:123123@localhost:6379/0',)
app.config_from_object('config')

@app.task
def select_popular_book():
        print 'Start at {0}'.format(time.ctime())
        time.sleep(2)
        print 'Task ... success at {0}'.format(time.ctime())
        return True
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3）启动celery worker&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;celery -A notify_friends worker --loglevel=info&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4）启动celery beat&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;celery -A favorite_book beat&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sun, 09 Dec 2018 07:49:00 +0000</pubDate>
<dc:creator>INVOKERrrrrrr~</dc:creator>
<og:description>1. centos7 下安装celery 1.1 安装pip 1.2 更新pip 1.3 安装celery 1.4 中间人安装，选择使用redis 1.4.1 安装redis 1.4.2 安装额外依赖</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ZhangShY/p/10091480.html</dc:identifier>
</item>
<item>
<title>ThreadPoolExecutor 源码分析 - 竺旭东</title>
<link>http://www.cnblogs.com/zhuxudong/p/10091400.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhuxudong/p/10091400.html</guid>
<description>&lt;h5 id=&quot;threadpoolexecutor&quot;&gt;ThreadPoolExecutor&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;线程池核心实现类&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;线程池的生命周期&quot;&gt;线程池的生命周期&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;RUNNING: 接受新任务，同时处理工作队列中的任务
SHUTDOWN: 不接受新任务，但是能处理工作队列中的任务
STOP: 不接受新任务，不处理工作队列中的任务，并且强制中断正在运行的工作者线程。
TIDYING: 所有的工作者线程都已经停止，将运行 terminated() 钩子函数。
TERMINATED: terminated() 钩子函数运行完毕&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;创建实例&quot;&gt;创建实例&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    /**
     *  低 29 位设置为线程池的工作线程数
     *  高 3 为设置为线程池的生命周期状态
     */
    private final AtomicInteger ctl = new AtomicInteger(ThreadPoolExecutor.ctlOf(ThreadPoolExecutor.RUNNING, 0));
    // 线程池的工作线程数在 int 中占用的位数
    private static final int COUNT_BITS = Integer.SIZE - 3;
    // 工作线程数掩码
    private static final int COUNT_MASK = (1 &amp;lt;&amp;lt; ThreadPoolExecutor.COUNT_BITS) - 1;
    // runState is stored in the high-order bits
    // 线程池处于运行状态：接受新任务，同时处理工作队列中的任务
    private static final int RUNNING    = -1 &amp;lt;&amp;lt; ThreadPoolExecutor.COUNT_BITS;
    // 线程池正在停止：不接受新任务，但是能处理工作队列中的任务
    private static final int SHUTDOWN   =  0 &amp;lt;&amp;lt; ThreadPoolExecutor.COUNT_BITS;
    // 线程池已经停止：不接受新任务，不处理工作队列中的任务，并且强制中断正在运行的工作者线程
    private static final int STOP       =  1 &amp;lt;&amp;lt; ThreadPoolExecutor.COUNT_BITS;
    // 线程池正在执行清理：所有的工作者线程都已经停止，将运行 terminated() 钩子函数
    private static final int TIDYING    =  2 &amp;lt;&amp;lt; ThreadPoolExecutor.COUNT_BITS;
    // 线程池已经清理完毕：terminated() 钩子函数运行完毕
    private static final int TERMINATED =  3 &amp;lt;&amp;lt; ThreadPoolExecutor.COUNT_BITS;

    /**
     *  任务队列，
     *  1）如果工作者线程允许过期，则使用 workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) 读取任务
     *  2）否则使用 workQueue.take() 读取任务
     */
    private final BlockingQueue&amp;lt;Runnable&amp;gt; workQueue;

    /**
     *  添加工作者线程、关闭线程池、读取统计数据等操作中使用的互斥锁
     */
    private final ReentrantLock mainLock = new ReentrantLock();

    /**
     *  线程池中的工作者线程集合，只有在持有 mainLock 时才能访问
     */
    private final HashSet&amp;lt;Worker&amp;gt; workers = new HashSet&amp;lt;&amp;gt;();

    /**
     *  执行 awaitTermination 操作时的条件
     */
    private final Condition termination = mainLock.newCondition();

    /**
     *  跟踪线程池同时存在的最大工作线程数
     * Accessed only under mainLock.
     */
    private int largestPoolSize;

    /**
     *  线程池完成的任务数，只在工作者线程退出时更新
     * Accessed only under mainLock.
     */
    private long completedTaskCount;

    /**
     *  任务队列，
     *  1）如果工作者线程允许过期，则使用 workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) 读取任务
     *  2）否则使用 workQueue.take() 读取任务
     */
    private final BlockingQueue&amp;lt;Runnable&amp;gt; workQueue;

    /**
     *  添加工作者线程、关闭线程池、读取统计数据等操作中使用的互斥锁
     */
    private final ReentrantLock mainLock = new ReentrantLock();

    /**
     *  线程池中的工作者线程集合，只有在持有 mainLock 时才能访问
     */
    private final HashSet&amp;lt;Worker&amp;gt; workers = new HashSet&amp;lt;&amp;gt;();

    /**
     *  执行 awaitTermination 操作时的条件
     */
    private final Condition termination = mainLock.newCondition();

    /**
     *  跟踪线程池同时存在的最大工作线程数
     * Accessed only under mainLock.
     */
    private int largestPoolSize;

    /**
     *  线程池完成的任务数，只在工作者线程退出时更新
     * Accessed only under mainLock.
     */
    private long completedTaskCount;

    /**
     *  创建工作者线程的工厂，工作者线程创建失败会导致任务丢失
     */
    private volatile ThreadFactory threadFactory;

    /**
     *  线程池满载或关闭过程中，任务被拒绝时的处理器
     */
    private volatile RejectedExecutionHandler handler;

    /**
     *  空闲工作者线程的超时时间，以纳秒为单位。
     *  1）当前工作者线程数 &amp;gt; 核心线程数
     *  2）允许核心工作者线程超时 allowCoreThreadTimeOut=true
     */
    private volatile long keepAliveTime;

    /**
     *  默认为 false，即使超时了，核心工作者线程也不会退出
     */
    private volatile boolean allowCoreThreadTimeOut;

    /**
     *  核心工作者线程数
     */
    private volatile int corePoolSize;

    /**
     *  最大工作者线程数
     */
    private volatile int maximumPoolSize;

    /**
     *  默认的拒绝处理器
     */
    private static final RejectedExecutionHandler defaultHandler =
            new AbortPolicy();

    public ThreadPoolExecutor(int corePoolSize,
            int maximumPoolSize,
            long keepAliveTime,
            TimeUnit unit,
            BlockingQueue&amp;lt;Runnable&amp;gt; workQueue) {
        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
                Executors.defaultThreadFactory(), ThreadPoolExecutor.defaultHandler);
    }

    public ThreadPoolExecutor(int corePoolSize,
            int maximumPoolSize,
            long keepAliveTime,
            TimeUnit unit,
            BlockingQueue&amp;lt;Runnable&amp;gt; workQueue,
            ThreadFactory threadFactory) {
        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
                threadFactory, ThreadPoolExecutor.defaultHandler);
    }

    public ThreadPoolExecutor(int corePoolSize,
            int maximumPoolSize,
            long keepAliveTime,
            TimeUnit unit,
            BlockingQueue&amp;lt;Runnable&amp;gt; workQueue,
            RejectedExecutionHandler handler) {
        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
                Executors.defaultThreadFactory(), handler);
    }

    /**
     *  使用指定的初始化参数创建一个 ThreadPoolExecutor 实例
     *
     * @param corePoolSize 核心工作者线程所
     * @param maximumPoolSize 最大工作者线程数
     * @param keepAliveTime 工作者线程存活时间
     * @param unit 时间单位
     * @param workQueue 工作队列
     * @param threadFactory 创建工作者线程的线程工厂
     * @param handler 拒绝处理器
     */
    public ThreadPoolExecutor(int corePoolSize,
            int maximumPoolSize,
            long keepAliveTime,
            TimeUnit unit,
            BlockingQueue&amp;lt;Runnable&amp;gt; workQueue,
            ThreadFactory threadFactory,
            RejectedExecutionHandler handler) {
        /**
         * 必须保证
         * corePoolSize &amp;gt;=0
         * maximumPoolSize &amp;gt; 0
         * maximumPoolSize &amp;gt; corePoolSize
         * keepAliveTime &amp;gt; 0 表示工作者线程可超时退出
         * keepAliveTime = 0 表示不可退出
         */
        if (corePoolSize &amp;lt; 0 ||
                maximumPoolSize &amp;lt;= 0 ||
                maximumPoolSize &amp;lt; corePoolSize ||
                keepAliveTime &amp;lt; 0) {
            throw new IllegalArgumentException();
        }
        if (workQueue == null || threadFactory == null || handler == null) {
            throw new NullPointerException();
        }
        acc = System.getSecurityManager() == null
                ? null
                        : AccessController.getContext();
        this.corePoolSize = corePoolSize;
        this.maximumPoolSize = maximumPoolSize;
        this.workQueue = workQueue;
        this.keepAliveTime = unit.toNanos(keepAliveTime);
        this.threadFactory = threadFactory;
        this.handler = handler;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;可提交的任务类型&quot;&gt;可提交的任务类型&lt;/h4&gt;
&lt;p&gt;Runnable 接口无返回值并且不能显示抛出异常。&lt;br/&gt;Callable 接口有返回值，并且能显示抛出异常。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@FunctionalInterface
public interface Runnable {
    void run();
}

@FunctionalInterface
public interface Callable&amp;lt;V&amp;gt; {
    /**
     *  计算并返回的一个结果，如果计算失败，则抛出异常
     */
    V call() throws Exception;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;执行一个-runnable-任务无返回值&quot;&gt;执行一个 Runnable 任务，无返回值&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    /**
     *  往线程池提交一个 Runnable 任务，
     *  如果线程池已满或线程池关闭则，该任务会交给拒绝处理器处理。
     */
    @Override
    public void execute(Runnable command) {
        if (command == null) {
            throw new NullPointerException();
        }
        // 读取控制变量
        int c = ctl.get();
        // 1）线程池工作线程数 &amp;lt; 核心线程数
        if (ThreadPoolExecutor.workerCountOf(c) &amp;lt; corePoolSize) {
            // 尝试创建一个新的工作者线程来处理这个任务
            if (addWorker(command, true)) {
                // 创建成功则直接返回
                return;
            }
            // 创建失败，则重新读取控制变量
            c = ctl.get();
        }
        /**
         * 2）当前工作者线程数 &amp;gt;= 核心工作者线程
         * &amp;amp;&amp;amp; 线程池处于运行状态
         * &amp;amp;&amp;amp; 尝试向工作者队列中提交任务
         */
        if (ThreadPoolExecutor.isRunning(c) &amp;amp;&amp;amp; workQueue.offer(command)) {
            // 重新读取控制变量
            final int recheck = ctl.get();
            // 1）如果线程池已经停止运行，则将目标任务从任务队列中移除，并尝试终止线程池
            if (! ThreadPoolExecutor.isRunning(recheck) &amp;amp;&amp;amp; remove(command)) {
                // 执行拒绝处理器
                reject(command);
            // 2）如果已经没有可用的工作者线程
            } else if (ThreadPoolExecutor.workerCountOf(recheck) == 0) {
                // 尝试添加一个新的工作者线程
                addWorker(null, false);
            }
        }
        /**
         * 3）当前工作者线程数 &amp;gt;= 核心工作者线程
         * &amp;amp;&amp;amp; 工作队列已满
         * &amp;amp;&amp;amp; 尝试增加一个新的工作者线程来处理该任务
         */
        else if (!addWorker(command, false)) {
            // 任务处理失败，则交给拒绝处理器处理
            reject(command);
        }
    }

    /**
     *  读取线程池的工作线程数
     */
    private static int workerCountOf(int c)  { return c &amp;amp; ThreadPoolExecutor.COUNT_MASK; }

    /**
     *  尝试增加一个核心工作者线程来处理这个任务
     */
    private boolean addWorker(Runnable firstTask, boolean core) {
        retry:
            for (int c = ctl.get();;) {
                /**
                 * 1）线程池状态在 STOP 及以上【线程池已经停止】
                 * 2）线程池正在停止，并且提交任务不为 null || 工作队列为空
                 * 则创建失败
                 */
                if (ThreadPoolExecutor.runStateAtLeast(c, ThreadPoolExecutor.SHUTDOWN)
                        &amp;amp;&amp;amp; (ThreadPoolExecutor.runStateAtLeast(c, ThreadPoolExecutor.STOP)
                                || firstTask != null
                                || workQueue.isEmpty())) {
                    return false;
                }

                for (;;) {
                    /**
                     *  1）工作者线程数已经 &amp;gt;= 核心线程数【任务队列未满时】
                     *  2）工作者线程数已经 &amp;gt;= 最大线程数【任务队列已满时】
                     *  则创建失败
                     */
                    if (ThreadPoolExecutor.workerCountOf(c)
                            &amp;gt;= ((core ? corePoolSize : maximumPoolSize) &amp;amp; ThreadPoolExecutor.COUNT_MASK)) {
                        return false;
                    }
                    // 尝试递增工作者线程数
                    if (compareAndIncrementWorkerCount(c)) {
                        // 如果计数值递增成功，则将正式添加工作者线程来处理任务
                        break retry;
                    }
                    // 如果其他线程优先递增了计数值，则重新读取计数值进行重试
                    c = ctl.get();  // Re-read ctl
                    // 线程池正在关闭，则重新进入循环后将直接退出
                    if (ThreadPoolExecutor.runStateAtLeast(c, ThreadPoolExecutor.SHUTDOWN))
                    {
                        continue retry;
                        // else CAS failed due to workerCount change; retry inner loop
                    }
                }
            }
    // 工作者线程是否已经启动
    boolean workerStarted = false;
    // 工作者线程是否已经添加到集合中
    boolean workerAdded = false;
    Worker w = null;
    try {
        // 创建工作者线程
        w = new Worker(firstTask);
        // 读取线程对象
        final Thread t = w.thread;
        if (t != null) {
            final ReentrantLock mainLock = this.mainLock;
            mainLock.lock();
            try {
                /**
                 *  Recheck while holding lock. Back out on ThreadFactory failure or if shut down before lock acquired.
                 *  读取控制变量再次进行校验
                 */
                final int c = ctl.get();
                /**
                 * 1）线程池处于运行状态
                 * 2）线程池处于关闭状态 &amp;amp;&amp;amp; 提交任务为 null
                 */
                if (ThreadPoolExecutor.isRunning(c) ||
                        ThreadPoolExecutor.runStateLessThan(c, ThreadPoolExecutor.STOP) &amp;amp;&amp;amp; firstTask == null) {
                    // 工作者线程已经启动
                    if (t.isAlive()) {
                        throw new IllegalThreadStateException();
                    }
                    // 将工作者线程添加到集合中
                    workers.add(w);
                    // 如果当前当前工作者线程数 &amp;gt; largestPoolSize，则更新它
                    final int s = workers.size();
                    if (s &amp;gt; largestPoolSize) {
                        largestPoolSize = s;
                    }
                    // 工作者线程添加成功
                    workerAdded = true;
                }
            } finally {
                mainLock.unlock();
            }
            // 如果添加成功，则启动工作者线程
            if (workerAdded) {
                t.start();
                // 工作者线程启动成功
                workerStarted = true;
            }
        }
    } finally {
        // 如果工作者线程启动失败，则进行回退和清理
        if (!workerStarted) {
            addWorkerFailed(w);
        }
    }
    return workerStarted;
    }

    // 运行状态 c 小于指定状态 s
    private static boolean runStateLessThan(int c, int s) {
        return c &amp;lt; s;
    }
    // 运行状态 c 大于等于指定状态 s
    private static boolean runStateAtLeast(int c, int s) {
        return c &amp;gt;= s;
    }

    /**
     * 尝试原子的将工作者线程数 +1
     */
    private boolean compareAndIncrementWorkerCount(int expect) {
        return ctl.compareAndSet(expect, expect + 1);
    }

    /**
     * Rolls back the worker thread creation.
     * - removes worker from workers, if present
     * - decrements worker count
     * - rechecks for termination, in case the existence of this
     *   worker was holding up termination
     */
    private void addWorkerFailed(Worker w) {
        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            // 1）从 workers 集合中移除工作者 w
            if (w != null) {
                workers.remove(w);
            }
            // 递减总工作者线程数
            decrementWorkerCount();
            // 尝试进行线程池终止
            tryTerminate();
        } finally {
            mainLock.unlock();
        }
    }

    /**
     *  将工作者线程总数递减 1
     */
    private void decrementWorkerCount() {
        ctl.addAndGet(-1);
    }

    final void tryTerminate() {
        for (;;) {
            final int c = ctl.get();
            /**
             * 1）线程池在运行状态【RUNNING】
             * 2）线程池在执行清理操作【TIDYING】
             * 3）线程池正在停止【SHUTDOWN】并且工作队列非空
             * 直接返回
             */
            if (ThreadPoolExecutor.isRunning(c) ||
                    ThreadPoolExecutor.runStateAtLeast(c, ThreadPoolExecutor.TIDYING) ||
                    ThreadPoolExecutor.runStateLessThan(c, ThreadPoolExecutor.STOP) &amp;amp;&amp;amp; ! workQueue.isEmpty()) {
                return;
            }
            /**
             * 工作者线程数不为 0，则强制中断还在运行的工作者
             */
            if (ThreadPoolExecutor.workerCountOf(c) != 0) { // Eligible to terminate
                interruptIdleWorkers(ThreadPoolExecutor.ONLY_ONE);
                return;
            }

            final ReentrantLock mainLock = this.mainLock;
            mainLock.lock();
            try {
                // 将控制变量设置为 TIDYING
                if (ctl.compareAndSet(c, ThreadPoolExecutor.ctlOf(ThreadPoolExecutor.TIDYING, 0))) {
                    try {
                        // 执行线程池的终止钩子函数
                        terminated();
                    } finally {
                        // 将控制变量设置为 TERMINATED
                        ctl.set(ThreadPoolExecutor.ctlOf(ThreadPoolExecutor.TERMINATED, 0));
                        // 唤醒在 termination 阻塞的所有线程
                        termination.signalAll();
                    }
                    return;
                }
            } finally {
                mainLock.unlock();
            }
            // else retry on failed CAS
        }
    }

    /**
     *  线程池是否在运行
     */
    private static boolean isRunning(int c) {
        return c &amp;lt; ThreadPoolExecutor.SHUTDOWN;
    }

    private void interruptIdleWorkers(boolean onlyOne) {
        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            // 遍历所有的工作者
            for (final Worker w : workers) {
                // 读取工作者驻留线程
                final Thread t = w.thread;
                // 如果其为中断，则获取锁并将线程中断
                if (!t.isInterrupted() &amp;amp;&amp;amp; w.tryLock()) {
                    try {
                        t.interrupt();
                    } catch (final SecurityException ignore) {
                    } finally {
                        w.unlock();
                    }
                }
                // 如果只中断一个工作者线程，则退出
                if (onlyOne) {
                    break;
                }
            }
        } finally {
            mainLock.unlock();
        }
    }

    /**
     *  合并工作线程数和运行状态
     */
    private static int ctlOf(int rs, int wc) { return rs | wc; }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;提交一个-runnablecallable-任务有返回值&quot;&gt;提交一个 Runnable、Callable 任务，有返回值&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public abstract class AbstractExecutorService implements ExecutorService {

    /**
     *  将 Runnable 任务和 T 封装成一个 FutureTask 实例
     */
    protected &amp;lt;T&amp;gt; RunnableFuture&amp;lt;T&amp;gt; newTaskFor(Runnable runnable, T value) {
        return new FutureTask&amp;lt;T&amp;gt;(runnable, value);
    }

    /**
     *  将一个 Callable 任务封装成一个 FutureTask 实例
     */
    protected &amp;lt;T&amp;gt; RunnableFuture&amp;lt;T&amp;gt; newTaskFor(Callable&amp;lt;T&amp;gt; callable) {
        return new FutureTask&amp;lt;T&amp;gt;(callable);
    }

    /**
     *  往线程池提交一个 Runnable 任务，无默认计算结果
     */
    @Override
    public Future&amp;lt;?&amp;gt; submit(Runnable task) {
        if (task == null) {
            throw new NullPointerException();
        }
        // 将 Runnable 任务封装成 RunnableFuture
        final RunnableFuture&amp;lt;Void&amp;gt; ftask = newTaskFor(task, null);
        // 执行任务
        execute(ftask);
        // 返回一个 Future 对象以异步读取计算结果
        return ftask;
    }

    /**
     * 往线程池提交一个 Runnable 任务，有默认计算结果
     */
    @Override
    public &amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt; submit(Runnable task, T result) {
        if (task == null) {
            throw new NullPointerException();
        }
        final RunnableFuture&amp;lt;T&amp;gt; ftask = newTaskFor(task, result);
        execute(ftask);
        return ftask;
    }

    /**
     *  往线程池提交一个 Callable 任务，自带计算结果
     */
    @Override
    public &amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt; submit(Callable&amp;lt;T&amp;gt; task) {
        if (task == null) {
            throw new NullPointerException();
        }
        final RunnableFuture&amp;lt;T&amp;gt; ftask = newTaskFor(task);
        execute(ftask);
        return ftask;
    }
}

/**
 *  可取消的异步计算类
 *  1）计算任务可以通过调用 cancel() 方法进行取消。
 *  2）如果计算未完成，则 get() 操作将一直阻塞直到计算完成。
 *  3）已经完成的计算不能取消、不能再次启动。
 */
public class FutureTask&amp;lt;V&amp;gt; implements RunnableFuture&amp;lt;V&amp;gt; {
    /**
     *  任务的状态以及可能的状态转换：
     * NEW -&amp;gt; COMPLETING -&amp;gt; NORMAL
     * NEW -&amp;gt; COMPLETING -&amp;gt; EXCEPTIONAL
     * NEW -&amp;gt; CANCELLED
     * NEW -&amp;gt; INTERRUPTING -&amp;gt; INTERRUPTED
     */
    private volatile int state;
    // 新建任务
    private static final int NEW          = 0;
    // 任务正在执行
    private static final int COMPLETING   = 1;
    // 任务正常执行完成
    private static final int NORMAL       = 2;
    // 任务异常执行完成
    private static final int EXCEPTIONAL  = 3;
    // 任务已经被取消
    private static final int CANCELLED    = 4;
    // 任务正在中断
    private static final int INTERRUPTING = 5;
    // 任务已经中断
    private static final int INTERRUPTED  = 6;

    /** 实际运行的任务载体 */
    private Callable&amp;lt;V&amp;gt; callable;
    /** 任务的计算结果或异常对象 */
    private Object outcome; 
    /** 运行 Callable 计算任务的线程 */
    private volatile Thread runner;
    /** 在当前任务上阻塞等待的线程 */
    private volatile WaitNode waiters;

    /**
     *  执行目标 Callable 任务并返回其计算结果
     */
    public FutureTask(Callable&amp;lt;V&amp;gt; callable) {
        if (callable == null) {
            throw new NullPointerException();
        }
        this.callable = callable;
        this.state = FutureTask.NEW;
    }

    /**
     *  执行目标 Runnable 任务并返回指定的计算结果 result
     */
    public FutureTask(Runnable runnable, V result) {
        this.callable = Executors.callable(runnable, result);
        // 写入任务状态
        this.state = FutureTask.NEW;       
    }

}

Executors#
    /**
     *  将 Runnable 封装成一个【执行目标 Runnable 任务并返回计算结果 null 的 Callable 实例】
     */
    public static Callable&amp;lt;Object&amp;gt; callable(Runnable task) {
        if (task == null) {
            throw new NullPointerException();
        }
        return new RunnableAdapter&amp;lt;&amp;gt;(task, null);
    }

    /**
     *  Runnable 到 Callable 的适配器
     */
    private static final class RunnableAdapter&amp;lt;T&amp;gt; implements Callable&amp;lt;T&amp;gt; {
        // 目标任务的
        private final Runnable task;
        // 固定的计算结果
        private final T result;
        RunnableAdapter(Runnable task, T result) {
            this.task = task;
            this.result = result;
        }
        /**
         * 运行目标任务并返回固定的计算结果
         * created by ZXD at 9 Dec 2018 T 12:24:43
         * @return
         */
        @Override
        public T call() {
            task.run();
            return result;
        }
        @Override
        public String toString() {
            return super.toString() + &quot;[Wrapped task = &quot; + task + &quot;]&quot;;
        }
    }

    private final class Worker
    extends AbstractQueuedSynchronizer
    implements Runnable
    {
        private static final long serialVersionUID = 6138294804551838833L;

        /** 线程池中工作者的驻留线程，创建失败时为 null */
        final Thread thread;
        /** 第一个运行的任务，可能为 null */
        Runnable firstTask;
        /** 每个驻留线程完成的任务数，在线程退出时会累加到线程池中 */
        volatile long completedTasks;

        // TODO: switch to AbstractQueuedLongSynchronizer and move
        // completedTasks into the lock word.

        /**
         *  基于指定的初始任务和线程工厂创建工作者线程
         */
        Worker(Runnable firstTask) {
                    // 禁止中断，直到工作者线程运行为止
            setState(-1); // inhibit interrupts until runWorker
            this.firstTask = firstTask;
            /**
             * Worker 本身实现了 Runnable 并且重写了 run 方法，
             * 基于 Worker 创建驻留线程，并启动运行。
             */
            thread = getThreadFactory().newThread(this);
        }

        /** 运行工作者线程 */
        @Override
        public void run() {
            runWorker(this);
        }
    }

Executors#
    /**
     * 默认的线程工厂
     */
    private static class DefaultThreadFactory implements ThreadFactory {
        // 线程池计数器
        private static final AtomicInteger poolNumber = new AtomicInteger(1);
        // 线程组
        private final ThreadGroup group;
        // 工作者线程计数器
        private final AtomicInteger threadNumber = new AtomicInteger(1);
        // 工作者线程名称前缀
        private final String namePrefix;

        DefaultThreadFactory() {
            // 读取安全管理器
            final SecurityManager s = System.getSecurityManager();
            // 读取线程组
            group = s != null ? s.getThreadGroup() :
                Thread.currentThread().getThreadGroup();
            // 写入工作者线程名称前缀，如：pool-1-thread-
            namePrefix = &quot;pool-&quot; +
                    DefaultThreadFactory.poolNumber.getAndIncrement() +
                    &quot;-thread-&quot;;
        }

        /**
         *  基于目标 Runnable 创建线程
         * created by ZXD at 9 Dec 2018 T 12:55:21
         * @param r
         * @return
         */
        @Override
        public Thread newThread(Runnable r) {
            // 创建线程
            final Thread t = new Thread(group, r,
                    namePrefix + threadNumber.getAndIncrement(),
                    0);
            // 设置为非守护线程
            if (t.isDaemon()) {
                t.setDaemon(false);
            }
            // 设置线程优先级为 Thread.NORM_PRIORITY
            if (t.getPriority() != Thread.NORM_PRIORITY) {
                t.setPriority(Thread.NORM_PRIORITY);
            }
            return t;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;工作者线程核心逻辑&quot;&gt;工作者线程核心逻辑&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    /**
     *  工作者线程的核心循环，重复的从任务队列中读取任务并执行。
     */
    final void runWorker(Worker w) {
        // 读取当前线程
        final Thread wt = Thread.currentThread();
        // 读取第一个任务
        Runnable task = w.firstTask;
        // 清理
        w.firstTask = null;
        w.unlock(); // 允许中断
        /**
         * 是否异常退出
         * 1）前置钩子函数抛出异常
         * 2）任务执行时抛出异常
         * 3）后置钩子函数抛出异常
         */
        boolean completedAbruptly = true;
        try {
            // 1）尝试从工作队列中读取任务
            while (task != null || (task = getTask()) != null) {
                w.lock();
                /**
                 *  If pool is stopping, ensure thread is interrupted; 
                 *  if not, ensure thread is not interrupted.
                 *  This requires a recheck in second case to deal with shutdownNow race while clearing interrupt
                 *  
                 *  1）如果线程池已经停止 &amp;amp;&amp;amp; 当前线程未被中断，则中断当前线程
                 *  
                 */
                if ((ThreadPoolExecutor.runStateAtLeast(ctl.get(), ThreadPoolExecutor.STOP) ||
                        Thread.interrupted() &amp;amp;&amp;amp;
                        ThreadPoolExecutor.runStateAtLeast(ctl.get(), ThreadPoolExecutor.STOP)) &amp;amp;&amp;amp;
                        !wt.isInterrupted()) {
                    wt.interrupt();
                }
                try {
                    /**
                     * 线程池钩子函数，在每个任务执行之前触发
                     */
                    beforeExecute(wt, task);
                    try {
                        task.run();
                        /**
                         * 线程池钩子函数，在每个任务执行之后或执行异常时触发
                         */
                        afterExecute(task, null);
                    } catch (final Throwable ex) {
                        afterExecute(task, ex);
                        throw ex;
                    }
                } finally {
                    // 将当前任务置空
                    task = null;
                    // 递增累积完成任务数
                    w.completedTasks++;
                    w.unlock();
                }
            }
            // 正常完成任务
            completedAbruptly = false;
        } finally {
            // 处理工作者线程退出后的统计和清理工作
            processWorkerExit(w, completedAbruptly);
        }
    }

    /**
     * 阻塞读取任务或超时读取任务。
     * 1. There are more than maximumPoolSize workers (due to
     *    a call to setMaximumPoolSize).
     * 2. The pool is stopped.
     * 3. The pool is shutdown and the queue is empty.
     * 4. This worker timed out waiting for a task, and timed-out
     *    workers are subject to termination (that is,
     *    {@code allowCoreThreadTimeOut || workerCount &amp;gt; corePoolSize})
     *    both before and after the timed wait, and if the queue is
     *    non-empty, this worker is not the last thread in the pool.
     *
     * @return task, or null if the worker must exit, in which case
     *         workerCount is decremented
     */
    private Runnable getTask() {
        // 是否是超时读取任务
        boolean timedOut = false; // Did the last poll() time out?

        for (;;) {
            // 读取控制变量
            final int c = ctl.get();

            /**
             * 1）线程池已经停止
             * 2）线程池正在停止 &amp;amp;&amp;amp; 任务队列为空
             * 都需要返回 null 以终止当前工作者线程
             */
            if (ThreadPoolExecutor.runStateAtLeast(c, ThreadPoolExecutor.SHUTDOWN)
                    &amp;amp;&amp;amp; (ThreadPoolExecutor.runStateAtLeast(c, ThreadPoolExecutor.STOP) || workQueue.isEmpty())) {
                decrementWorkerCount();
                return null;
            }
            
            // 计算当前工作者线程数
            final int wc = ThreadPoolExecutor.workerCountOf(c);

            /**
             * 是否允许当前工作者线程退出
             * 1）允许核心工作者线程退出
             * 2）当前工作者线程数 &amp;gt; 核心工作者线程数
             */
            final boolean timed = allowCoreThreadTimeOut || wc &amp;gt; corePoolSize;
            /**
             * 1）当前工作者线程数 &amp;gt; 最大工作者线程数 || 
             * 2）允许工作者线程退出 &amp;amp;&amp;amp; 当次拉取任务超时
             * 3）当前工作者线程数 &amp;gt; 1 || 任务队列为空
             */
            if ((wc &amp;gt; maximumPoolSize || timed &amp;amp;&amp;amp; timedOut)
                    &amp;amp;&amp;amp; (wc &amp;gt; 1 || workQueue.isEmpty())) {
                // 递减工作者线程数
                if (compareAndDecrementWorkerCount(c)) {
                    // 返回 null 以终止该工作者线程
                    return null;
                }
                continue;
            }

            try {
                /**
                 * 1）如果是超时模式，则尝试在 keepAliveTime 纳秒内读取任务，允许当前工作者退出
                 * 2）否则，阻塞读取任务【不允许当前工作者退出】
                 */
                final Runnable r = timed ?
                        workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
                            workQueue.take();
                        // 返回任务不为 null，则执行它
                        if (r != null) {
                            return r;
                        }
                        // 设置超时拉取标识，第二次循环中当前工作者可能退出
                        timedOut = true;
            } catch (final InterruptedException retry) {
                timedOut = false;
            }
        }
    }

    private void processWorkerExit(Worker w, boolean completedAbruptly) {
        // 如果是异常退出，则递减工作者线程数
        if (completedAbruptly) {
            decrementWorkerCount();
        }

        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            // 将当前工作者 w 完成的任务数累加到线程池已完成任务数中
            completedTaskCount += w.completedTasks;
            // 从工作者集合中删除该工作者
            workers.remove(w);
        } finally {
            mainLock.unlock();
        }
        
        // 尝试终止线程池
        tryTerminate();

        final int c = ctl.get();
        // 线程池处于 RUNNING 或 SHUTDOWN
        if (ThreadPoolExecutor.runStateLessThan(c, ThreadPoolExecutor.STOP)) {
            // 如果不是异常退出
            if (!completedAbruptly) {
                /**
                 * 计算需要保留的最小工作者线程数，如果允许核心工作者线程退出则为 0；
                 * 否则为 corePoolSize
                 */
                int min = allowCoreThreadTimeOut ? 0 : corePoolSize;
                // 任务队列不为空，则至少保留一个工作者线程
                if (min == 0 &amp;amp;&amp;amp; ! workQueue.isEmpty()) {
                    min = 1;
                }
                // 已有工作者线程 &amp;gt; 期望工作者线程数，则直接返回
                if (ThreadPoolExecutor.workerCountOf(c) &amp;gt;= min)
                {
                    return; // replacement not needed
                }
            }
            // 否则尝试新增工作者线程
            addWorker(null, false);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;工作者线程退出的情况&quot;&gt;工作者线程退出的情况&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;1）线程池前置钩子函数 beforeExecute 或后置钩子函数 afterExecute 执行抛出异常
2）任务运行过程中出现异常
3）允许核心工作者线程退出 &amp;amp;&amp;amp; 在 keepAliveTime 纳秒内没有读取到任何任务 &amp;amp;&amp;amp; (当前工作者线程数 &amp;gt; 1 || 任务队列为空)
4）当前工作者线程数 &amp;gt; 核心工作者线程数 &amp;amp;&amp;amp; 在 keepAliveTime 纳秒内没有读取到任何任务 &amp;amp;&amp;amp; (当前工作者线程数 &amp;gt; 1 || 任务队列为空)&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;线程池拒绝策略&quot;&gt;线程池拒绝策略&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    public static class CallerRunsPolicy implements RejectedExecutionHandler {
        public CallerRunsPolicy() { }

        /**
         *  如果线程池还在运行，则在任务提交线程中运行被拒绝的任务
         */
        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
            if (!e.isShutdown()) {
                r.run();
            }
        }
    }

    // 默认的拒绝执行处理器
    public static class AbortPolicy implements RejectedExecutionHandler {
        public AbortPolicy() { }

        /**
         *  不管线程池的运行状态，丢弃被拒绝的任务，并抛出 RejectedExecutionException 异常
         */
        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
            throw new RejectedExecutionException(&quot;Task &quot; + r.toString() +
                    &quot; rejected from &quot; +
                    e.toString());
        }
    }

    public static class DiscardPolicy implements RejectedExecutionHandler {
        public DiscardPolicy() { }

        /**
         *  静默丢弃被拒绝的任务
         */
        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
        }
    }

    public static class DiscardOldestPolicy implements RejectedExecutionHandler {
        public DiscardOldestPolicy() { }

        /**
         *  如果线程池还在运行，则拉取并丢弃下一个任务，并将被拒绝的任务重新提交
         */
        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
            if (!e.isShutdown()) {
                e.getQueue().poll();
                e.execute(r);
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;线程池的关闭&quot;&gt;线程池的关闭&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @Override
    public void shutdown() {
        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            // 当前线程是否允许关闭线程池
            checkShutdownAccess();
            // 将线程池状态更新为 SHUTDOWN
            advanceRunState(ThreadPoolExecutor.SHUTDOWN);
            // 中断所有空闲工作者，正在处理任务的工作者线程可以继续运行
            interruptIdleWorkers();
            // 执行钩子函数
            onShutdown(); // hook for ScheduledThreadPoolExecutor
        } finally {
            mainLock.unlock();
        }
        // 尝试终止线程池
        tryTerminate();
    }

    @Override
    public List&amp;lt;Runnable&amp;gt; shutdownNow() {
        List&amp;lt;Runnable&amp;gt; tasks;
        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            // 当前线程是否允许关闭线程池            
            checkShutdownAccess();
            // 将线程池状态更新为 STOP
            advanceRunState(ThreadPoolExecutor.STOP);
            // 强制中断所有工作者线程，包括正在执行任务的线程
            interruptWorkers();
            // 读取所有未完成的任务
            tasks = drainQueue();
        } finally {
            mainLock.unlock();
        }
        // 尝试终止线程池
        tryTerminate();
        // 返回所有未完成的任务
        return tasks;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;预启动核心工作者线程以提高响应速度&quot;&gt;预启动核心工作者线程，以提高响应速度&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    /**
     *  尝试预先启动一个核心工作者线程，阻塞等待获取任务，启动成功返回 true
     */
    public boolean prestartCoreThread() {
        return ThreadPoolExecutor.workerCountOf(ctl.get()) &amp;lt; corePoolSize &amp;amp;&amp;amp;
                addWorker(null, true);
    }

    /**
     *  预启动所有核心工作者线程，并返回实际启动的线程数
     */
    public int prestartAllCoreThreads() {
        int n = 0;
        while (addWorker(null, true)) {
            ++n;
        }
        return n;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;状态查询和参数更新&quot;&gt;状态查询和参数更新&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    /**
     *  线程池是否处于 SHUTDOWN 及以上状态
     */
    @Override
    public boolean isShutdown() {
        return ThreadPoolExecutor.runStateAtLeast(ctl.get(), ThreadPoolExecutor.SHUTDOWN);
    }

    /**
     *  线程池是否处于 STOP 及以上状态
     */
    boolean isStopped() {
        return ThreadPoolExecutor.runStateAtLeast(ctl.get(), ThreadPoolExecutor.STOP);
    }

    /**
     * 线程池是否正在停止
     */
    public boolean isTerminating() {
        final int c = ctl.get();
        return ThreadPoolExecutor.runStateAtLeast(c, ThreadPoolExecutor.SHUTDOWN) &amp;amp;&amp;amp; ThreadPoolExecutor.runStateLessThan(c, ThreadPoolExecutor.TERMINATED);
    }

    /**
     *  线程池是否已经停止
     */
    @Override
    public boolean isTerminated() {
        return ThreadPoolExecutor.runStateAtLeast(ctl.get(), ThreadPoolExecutor.TERMINATED);
    }

    /**
     *  更新核心线程数，可能导致工作线程增加或退出
     */
    public void setCorePoolSize(int corePoolSize) {
        if (corePoolSize &amp;lt; 0 || maximumPoolSize &amp;lt; corePoolSize) {
            throw new IllegalArgumentException();
        }
        // 计算增量
        final int delta = corePoolSize - this.corePoolSize;
        // 写入核心线程数
        this.corePoolSize = corePoolSize;
        // 如果旧的核心线程数比较大，则尝试中断空闲工作者
        if (ThreadPoolExecutor.workerCountOf(ctl.get()) &amp;gt; corePoolSize) {
            interruptIdleWorkers();
        } else if (delta &amp;gt; 0) {
            /**
             *  计算所需的工作者线程，最大为 delta
             */
            int k = Math.min(delta, workQueue.size());
            while (k-- &amp;gt; 0 &amp;amp;&amp;amp; addWorker(null, true)) {
                // 队列为空，则无需增加
                if (workQueue.isEmpty()) {
                    break;
                }
            }
        }
    }

    /**
     *  设置最大工作者线程数
     */
    public void setMaximumPoolSize(int maximumPoolSize) {
        if (maximumPoolSize &amp;lt;= 0 || maximumPoolSize &amp;lt; corePoolSize) {
            throw new IllegalArgumentException();
        }
        this.maximumPoolSize = maximumPoolSize;
        // 当前工作者线程数 &amp;gt; 新的最大工作者线程数
        if (ThreadPoolExecutor.workerCountOf(ctl.get()) &amp;gt; maximumPoolSize) {
            interruptIdleWorkers();
        }
    }

    /**
     *  更新空闲线程存活时间
     */
    public void setKeepAliveTime(long time, TimeUnit unit) {
        if (time &amp;lt; 0) {
            throw new IllegalArgumentException();
        }
        if (time == 0 &amp;amp;&amp;amp; allowsCoreThreadTimeOut()) {
            throw new IllegalArgumentException(&quot;Core threads must have nonzero keep alive times&quot;);
        }
        // 计算新的空闲线程存活时间
        final long keepAliveTime = unit.toNanos(time);
        // 计算增量
        final long delta = keepAliveTime - this.keepAliveTime;
        // 写入值
        this.keepAliveTime = keepAliveTime;
        if (delta &amp;lt; 0) {
            interruptIdleWorkers();
        }
    }

    /**
     *  设置拒绝执行处理器
     */
    public void setRejectedExecutionHandler(RejectedExecutionHandler handler) {
        if (handler == null) {
            throw new NullPointerException();
        }
        this.handler = handler;
    }

    /**
     *  设置工作者线程工厂
     */
    public void setThreadFactory(ThreadFactory threadFactory) {
        if (threadFactory == null) {
            throw new NullPointerException();
        }
        this.threadFactory = threadFactory;
    }

    /**
     *  设置允许核心工作者线程退出，为 true 时 keepAliveTime 必须 &amp;gt; 0
     */
    public void allowCoreThreadTimeOut(boolean value) {
        if (value &amp;amp;&amp;amp; keepAliveTime &amp;lt;= 0) {
            throw new IllegalArgumentException(&quot;Core threads must have nonzero keep alive times&quot;);
        }
        // 尝试更新值
        if (value != allowCoreThreadTimeOut) {
            allowCoreThreadTimeOut = value;
            if (value) {
                interruptIdleWorkers();
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sun, 09 Dec 2018 07:30:00 +0000</pubDate>
<dc:creator>竺旭东</dc:creator>
<og:description>ThreadPoolExecutor 线程池的生命周期 创建实例 执行一个 Runnable 任务，无返回值 工作者线程核心逻辑 工作者线程退出的情况 线程池拒绝策略 线程池的关闭 预启动核心工作者线</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhuxudong/p/10091400.html</dc:identifier>
</item>
<item>
<title>Swagger 导出API - yiluomyt</title>
<link>http://www.cnblogs.com/yiluomyt/p/10091402.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yiluomyt/p/10091402.html</guid>
<description>&lt;blockquote readability=&quot;5.6875&quot;&gt;
&lt;p&gt;这算是在博客园的第一篇博客吧，之后发的应该也会同步到博客园上。&lt;/p&gt;
&lt;p&gt;此前的博客地址: &lt;a href=&quot;https://gitbook.mytyiluo.cn/&quot; class=&quot;uri&quot;&gt;https://gitbook.mytyiluo.cn&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;swagger简介&quot;&gt;Swagger简介&lt;/h2&gt;
&lt;p&gt;Swagger是一个开源软件框架，可帮助开发人员设计，构建，记录和使用RESTful Web服务。&lt;/p&gt;
&lt;p&gt;其中，Swagger可以生成一个交互式的API控制台，以便于快速测试API。&lt;/p&gt;
&lt;p&gt;从个人角度讲，Swagger对于前后端分离的小团队来说是非常有帮助的。尤其是像我们这种平时没写文档习惯的人来说，Swagger能根据代码自动生成文档可谓是一大福音，再也不用被人追着问这API到底是怎么用的。&lt;/p&gt;
&lt;p&gt;这里，我将会具体说下最近我使用Swagger的一些心得和体会，团队的开发环境如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ASP.NET Core 2.1 (Visual Studio 2017 Community)&lt;/li&gt;
&lt;li&gt;微信小程序 (官方工具+Visual Studio Code)&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;生成swagger-api-文档&quot;&gt;生成Swagger API 文档&lt;/h2&gt;
&lt;p&gt;对于ASP.NET Core来说，生成文档这一步还是相对容易的，且对代码基本没有侵入性。只需在Startup中配置一下即可，大致步骤基本如下：&lt;/p&gt;
&lt;h3 id=&quot;添加nuget包&quot;&gt;添加NuGet包&lt;/h3&gt;
&lt;p&gt;这里，我所使用的是Swashbuckle.AspNetCore，直接用VS的NuGet包管理器下载即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://yiluoblog.blob.core.windows.net/image/Other/Swagger%E5%AF%BC%E5%87%BAAPI/NuGet-Swashbuckle.AspNetCore.jpg&quot; alt=&quot;NuGet-Swashbuckle.AspNetCore&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后在&lt;code&gt;ConfigureServices&lt;/code&gt;中配置如下:&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;services.AddSwaggerGen(c =&amp;gt;
{
    // 定义文档
    c.SwaggerDoc(&quot;v1&quot;, new Info { Title = &quot;Qincai API&quot;, Version = &quot;v1&quot; });
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;并在&lt;code&gt;Configure&lt;/code&gt;中启用该Services：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;// 使用Swagger
app.UseSwagger();
app.UseSwaggerUI(c =&amp;gt;
{
    c.SwaggerEndpoint(&quot;/swagger/v1/swagger.json&quot;, &quot;Qincai API v1&quot;);
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;随后运行，打开浏览器&lt;code&gt;host/swagger&lt;/code&gt;即可看到所生成的API文档。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://yiluoblog.blob.core.windows.net/image/Other/Swagger%E5%AF%BC%E5%87%BAAPI/Swagger%20UI.jpg&quot; alt=&quot;Swagger UI&quot;/&gt;&lt;/p&gt;
&lt;p&gt;若还有不清楚的，可以参考微软官方的&lt;a href=&quot;https://docs.microsoft.com/zh-cn/aspnet/core/tutorials/getting-started-with-swashbuckle?view=aspnetcore-2.1&amp;amp;tabs=visual-studio&quot;&gt;文档&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;完成到这里，是不是发现你和图中生成的样子有点不太一样，比如说，为什么没有注释，以及认证用的小锁，那这里我们就需要进一步配置。&lt;/p&gt;
&lt;h3 id=&quot;添加xml注释&quot;&gt;添加XML注释&lt;/h3&gt;
&lt;p&gt;如果大家有在VS中写C#经历的话，肯定会对XML注释影响深刻，通过简单的&lt;code&gt;///&lt;/code&gt;就可以自动生成规范的注释格式。那这里，我们的Swagger也正是利用了这些XML注释来标记对应的API。&lt;/p&gt;
&lt;p&gt;首先，我们需要启用VS中导出XML文档的功能，在项目属性中，生成 &amp;gt; 输出，勾选XML文档文件，并填写对应的路径，我所写的是项目根目录。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://yiluoblog.blob.core.windows.net/image/Other/Swagger%E5%AF%BC%E5%87%BAAPI/%E8%BE%93%E5%87%BAXML%E6%96%87%E6%A1%A3.jpg&quot; alt=&quot;输出XML文档&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后再到之前的&lt;code&gt;ConfigureServices&lt;/code&gt;中添加如下：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;services.AddSwaggerGen(c =&amp;gt;
{
    c.SwaggerDoc(&quot;v1&quot;, new Info { Title = &quot;Qincai API&quot;, Version = &quot;v1&quot; });

    // file 是你在项目属性中配置的相对路径
    var filePath = System.IO.Path.Combine(AppContext.BaseDirectory, file);
    c.IncludeXmlComments(filePath);
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重新生成，再运行，你可以看到Swagger中就对API以及参数添加上了注释。&lt;/p&gt;
&lt;h3 id=&quot;添加认证功能&quot;&gt;添加认证功能&lt;/h3&gt;
&lt;p&gt;在实际开发中，我们常常是需要给我们的API添加上认证功能以避免非法的访问，因此我们也就需要给Swagger中的API标识上是否需要认证，并且添加提供Token的功能，以方便在Swagger的控制台中调试。&lt;/p&gt;
&lt;p&gt;简单来说，还是在&lt;code&gt;ConfigureServies&lt;/code&gt;中，配置如下：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;services.AddSwaggerGen(c =&amp;gt;
{
    c.SwaggerDoc(&quot;v1&quot;, new Info { Title = &quot;Qincai API&quot;, Version = &quot;v1&quot; });

    var filePath = System.IO.Path.Combine(AppContext.BaseDirectory, file);
    c.IncludeXmlComments(filePath);

    // 定义认证方式
    c.AddSecurityDefinition(&quot;Bearer&quot;, new ApiKeyScheme
    {
        In = &quot;header&quot;,
        Description = &quot;请键入JWT Token，格式为'Bearer '+你的Token。&quot;,
        Name = &quot;Authorization&quot;,
        Type = &quot;apiKey&quot;
    });

    // 网上为全局API添加认证参数的方法
    // c.AddSecurityRequirement(new Dictionary&amp;lt;string, IEnumerable&amp;lt;string&amp;gt;&amp;gt; {
    //     { &quot;Bearer&quot;, Enumerable.Empty&amp;lt;string&amp;gt;() },
    // });

    // 在过滤器中为需要认证的API添加对应参数
    // 过滤器的定义见下文
    c.OperationFilter&amp;lt;AuthorizationHeaderOperationFilter&amp;gt;();
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里值得说一下的是，网上普遍都是全局添加认证参数，导致一些不需要认证的API也被打上了标识，这在Swagger 控制台中影响倒不大，但在后续的导出API时就麻烦了，所有在这里，我使用自定义过滤器的方式来只为需要认证的API添加认证参数。&lt;/p&gt;
&lt;p&gt;根据上文，我们先定义一个&lt;code&gt;AuthorizationHeaderOperationFilter&lt;/code&gt;类，它需要实现&lt;code&gt;IOperationFilter&lt;/code&gt;接口，类定义如下：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// 判断是否需要添加Authorize Header
/// &amp;lt;/summary&amp;gt;
public class AuthorizationHeaderOperationFilter : IOperationFilter
{
    /// &amp;lt;summary&amp;gt;
    /// 为需要认证的Operation添加认证参数
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;operation&quot;&amp;gt;The Swashbuckle operation.&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;context&quot;&amp;gt;The Swashbuckle operation filter context.&amp;lt;/param&amp;gt;
    public void Apply(Operation operation, OperationFilterContext context)
    {
        // 获取对应方法的过滤器描述
        // 应该也就是所添加的Attribute
        var filterPipeline = context.ApiDescription.ActionDescriptor.FilterDescriptors;
        // 判断是否添加了AuthorizeFilter
        // 也就是[Authorize]
        var isAuthorized = filterPipeline.Select(filterInfo =&amp;gt; filterInfo.Filter).Any(filter =&amp;gt; filter is AuthorizeFilter);
        // 判断是否添加了IAllowAnonymousFilter
        // 也就是[AllowAnonymous]
        var allowAnonymous = filterPipeline.Select(filterInfo =&amp;gt; filterInfo.Filter).Any(filter =&amp;gt; filter is IAllowAnonymousFilter);

        // 仅当需要认证且不是AllowAnonymous的情况下，添加认证参数
        if (isAuthorized &amp;amp;&amp;amp; !allowAnonymous)
        {
            // 若该Operation不存在认证参数的话，
            // 这个Security将是null，而不是空的List
            if (operation.Security == null)
                operation.Security = new List&amp;lt;IDictionary&amp;lt;string, IEnumerable&amp;lt;string&amp;gt;&amp;gt;&amp;gt;();

            // 添加认证参数
            operation.Security.Add(new Dictionary&amp;lt;string, IEnumerable&amp;lt;string&amp;gt;&amp;gt;
            {
                { &quot;Bearer&quot;, new string[] { } }
            });
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重新生成后运行，应该就可以看到需要认证的API都带上了一把小锁。&lt;/p&gt;
&lt;h3 id=&quot;注意事项&quot;&gt;注意事项&lt;/h3&gt;
&lt;p&gt;虽说配置并不算难，但还是需要注意一些地方。&lt;/p&gt;
&lt;ol readability=&quot;7&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;注意写好XML注释&lt;/p&gt;
&lt;p&gt;之前也说了，Swagger的注释是根据XML文档生成的，反过来说，如果你没写XML注释，Swagger上也就是不会有注释的。&lt;/p&gt;
&lt;p&gt;另外，在你启用XML文档输出之后，VS也会很贴心的为你把没有写XML注释的地方都标为Warning。╮(╯▽╰)╭，所以安心的把注释都补一遍吧。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;为参数添加数据注解&lt;/p&gt;
&lt;p&gt;Swagger是支持部分数据注解的，比如&lt;code&gt;[Required]&lt;/code&gt;之类的。&lt;/p&gt;
&lt;p&gt;结合&lt;code&gt;[ApiController]&lt;/code&gt;自带的模型验证功能，岂不美哉。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;将XML文档复制到输出目录&lt;/p&gt;
&lt;p&gt;若你在发布应用后发现XML不见了，那可能就是你没有为XML文档文件配置复制到输出目录的属性。&lt;/p&gt;
&lt;p&gt;打开资源管理器，右键对应的文件，我们在属性中可以看到有&lt;strong&gt;复制到输出目录&lt;/strong&gt;的属性，将其设置为始终复制就Ok。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://yiluoblog.blob.core.windows.net/image/Other/Swagger%E5%AF%BC%E5%87%BAAPI/XML%E6%96%87%E6%A1%A3%E5%B1%9E%E6%80%A7.jpg&quot; alt=&quot;XML文档属性&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;以上就是我最近所用到的Swagger的一些功能。&lt;/p&gt;
&lt;h2 id=&quot;导出微信小程序可用的api&quot;&gt;导出微信小程序可用的API&lt;/h2&gt;
&lt;p&gt;在一开始也说了，使用Swagger的主要目的就是方便小团队的沟通，但事实上，因为我们前端的人少（大家都是CSS鬼才），导致我们开发新API的速度往往比前端进度快，没几天前端那边就需要更新一下API的库（将小程序的CallBack封装成Promise）。&lt;/p&gt;
&lt;p&gt;因此，就有了根据Swagger自动生成Js可用的API文件的想法，其实想法的本身是来自于Abp项目的设计（真的很优秀），但出于一些方面的考虑，我们姑且还没采用Abp。&lt;/p&gt;
&lt;p&gt;随后，就是查找资料了，确实Swagger有这方面的&lt;a href=&quot;https://github.com/swagger-api/swagger-codegen&quot;&gt;支持&lt;/a&gt;，其中官方&lt;a href=&quot;https://github.com/swagger-api/swagger-js&quot;&gt;关于Js的库&lt;/a&gt;是完全动态的，但可惜不适用于小程序。然后，就发现了第三方的&lt;a href=&quot;https://github.com/wcandillon/swagger-js-codegen&quot;&gt;swagger-js-codegen&lt;/a&gt;，可用于生成静态的Js代码，且提供了自定义模板的功能。网上也不少基于这个库的其他模板，比如说&lt;code&gt;axios&lt;/code&gt;之类的，但没有适用于微信小程序的，不过问题不大，模板是基于&lt;code&gt;mustache&lt;/code&gt;的，动手撸就是了。&lt;/p&gt;
&lt;p&gt;模板代码有点长就不在这里放出了，大家还请移步&lt;a href=&quot;https://github.com/yiluomyt/swagger-wxopen-codegen-template&quot;&gt;GitHub&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;这里我就简单说下大致思路，&lt;/p&gt;
&lt;p&gt;模板本身是基于原来的nodejs模板改的，我们所需做的就是将http请求部分的代码改为使用&lt;code&gt;wx.request&lt;/code&gt;，如下简单的封装即可:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;/**
* HTTP Request
* @method
* @name {{&amp;amp;className}}#request
* @param {string} method - HTTP 请求方法
* @param {string} url - 开发者服务器接口地址
* @param {object} data - 请求的参数
* @param {object} headers - 设置请求的 header ,默认为 application/json
*/
request(method, url, parameters, data, headers){
    return new Promise((resolve, reject) =&amp;gt; {
        wx.request({
            url: url,
            data: data,
            header: headers,
            method: method,
            success: res =&amp;gt; {
                if(res.statusCode &amp;gt;= 200 &amp;amp;&amp;amp; res.statusCode &amp;lt;= 299) {
                    resolve(res.data)
                } else {
                    reject(res)
                }
            },
            fail: e =&amp;gt; reject(e)
        })
    })
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对应method的话，基本没怎么改，只根据微信小程序所有参数都是传递给data，做了点简化。&lt;/p&gt;
&lt;p&gt;对于认证部分，根据我们自己的需求，换成了这样的实现：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;new Promise((resolve, reject) =&amp;gt; {
    this.authenticate()
    .then(token =&amp;gt; {
        headers['Authorization'] = 'Bearer ' + token;
        resolve(this.request('{{method}}', domain + path, parameters, data, headers))
    })
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中&lt;code&gt;this.authenticate&lt;/code&gt;是由外部传入的&lt;code&gt;function&lt;/code&gt;，返回一个包含&lt;code&gt;Token&lt;/code&gt;的&lt;code&gt;Promise&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;导出后，在小程序中的使用就类似于:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;import API from './api.js'

api = new API('http://localhost:5000')
api.setAuthenticate(function () {
    return new Promise((resolve, reject) =&amp;gt; {
        // 你的认证逻辑
        resolve(token)
    })
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后，就可以开心地调用各种方法了。&lt;/p&gt;
&lt;p&gt;最后，再放一遍Demo的链接：&lt;a href=&quot;https://github.com/yiluomyt/swagger-wxopen-codegen-template&quot; class=&quot;uri&quot;&gt;https://github.com/yiluomyt/swagger-wxopen-codegen-template&lt;/a&gt;，发现有问题欢迎提Issue。&lt;/p&gt;
</description>
<pubDate>Sun, 09 Dec 2018 07:30:00 +0000</pubDate>
<dc:creator>yiluomyt</dc:creator>
<og:description>ASP.NET Core 使用Swagger，并导出微信小程序可用的api文件。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yiluomyt/p/10091402.html</dc:identifier>
</item>
<item>
<title>【音乐App】—— Vue2.0开发移动端音乐WebApp项目爬坑（二） - 柳洁琼Elena</title>
<link>http://www.cnblogs.com/ljq66/p/10090690.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ljq66/p/10090690.html</guid>
<description>&lt;td valign=&quot;top&quot; width=&quot;70%&quot;&gt;
&lt;table align=&quot;center&quot; width=&quot;100%&quot; height=&quot;90&quot; cellspacing=&quot;0&quot; cellpadding=&quot;5&quot; border=&quot;0&quot; bgcolor=&quot;white&quot; class=&quot;index&quot; readability=&quot;72.088997512582&quot;&gt;&lt;tr readability=&quot;144.17799502516&quot;&gt;&lt;td class=&quot;main&quot;&gt;
&lt;div id=&quot;post_detail&quot;&gt;
&lt;div class=&quot;block&quot;&gt;

&lt;div class=&quot;post&quot;&gt;
&lt;div class=&quot;postcontent&quot; readability=&quot;46.871633204521&quot;&gt;
&lt;div id=&quot;cnblogs_post_body&quot; class=&quot;blogpost-body&quot; readability=&quot;88.756922451114&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;前言：&lt;/strong&gt;&lt;a href=&quot;https://www.cnblogs.com/ljq66/p/10087103.html&quot; target=&quot;_blank&quot;&gt;上一篇&lt;/a&gt;总结了项目概况、项目准备、页面骨架搭建、推荐页面开发，这一篇重点梳理歌手页面开发、歌手详情页。项目github地址：&lt;a href=&quot;https://github.com/66Web/ljq_vue_music&quot; target=&quot;_blank&quot;&gt;https://github.com/66Web/ljq_vue_music&lt;/a&gt;，欢迎Star。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;table border=&quot;0&quot; align=&quot;center&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;一、歌手页面开发--singer&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;     &lt;/span&gt;  &lt;strong&gt;歌手页面布局与设计&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;需求：联系人列表形式、左右联动的滚动列表、顶部标题随列表滚动而改变&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;table border=&quot;0&quot; align=&quot;center&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1244398/201812/1244398-20181209151250609-1262949844.gif&quot; alt=&quot;&quot; width=&quot;189&quot; height=&quot;337&quot;/&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1244398/201812/1244398-20181209151313459-1594863897.gif&quot; alt=&quot;&quot; width=&quot;189&quot; height=&quot;337&quot;/&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;&lt;span&gt;歌手列表&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;span&gt;快速入口列表&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;     &lt;/span&gt;  &lt;strong&gt;歌手数据接口抓取&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li readability=&quot;6.5&quot;&gt;&lt;span&gt;api目录下创建 &lt;span&gt;singer.js&lt;/span&gt;  :  &lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;同recommend.js，依赖jsonp和一些公共参数&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import jsonp from '@/common/js/jsonp'&lt;span&gt;
import {commonParams, options} from &lt;/span&gt;'@/api/config'&lt;span&gt;

export &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; getSingerList() {
       const url &lt;/span&gt;= 'https://c.y.qq.com/v8/fcg-bin/v8.fcg'&lt;span&gt;

       const data &lt;/span&gt;=&lt;span&gt; Object.assign({}, commonParams, {
               channel: &lt;/span&gt;'singer'&lt;span&gt;,
               page: &lt;/span&gt;'list'&lt;span&gt;,
               key: &lt;/span&gt;'all_all_all'&lt;span&gt;,
               pagesize: &lt;/span&gt;100&lt;span&gt;,
               pagenum: &lt;/span&gt;1&lt;span&gt;,
               hostUin: &lt;/span&gt;0&lt;span&gt;,
               needNewCode: &lt;/span&gt;0&lt;span&gt;,
               platform: &lt;/span&gt;'yqq'&lt;span&gt;,
               g_tk: &lt;/span&gt;1664029744, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;会变，以实时数据为准&lt;/span&gt;
&lt;span&gt;      })

      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; jsonp(url, data, options)
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;singer.vue&lt;/span&gt; &lt;span&gt;:  &lt;/span&gt;&lt;span&gt;数据结构与需求不同，需要两层数组结构&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;&lt;span&gt;第一层数组：将所有歌手以姓名开头字母Findex——ABCD顺序排列&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;第二层数组：在每一个字母歌手数组中，按顺序再将歌手进行排列&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;热门数据：简单将前十条数据取出来&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;     &lt;/span&gt;  &lt;strong&gt;歌手数据处理和Singer类的封装&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li readability=&quot;3&quot;&gt;&lt;span&gt;&lt;span&gt;定义_normalizeSinger()方法，&lt;span&gt;规范化singer数据&lt;/span&gt;，接收参数list,即数据singers&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
const HOT_NAME = '热门'&lt;span&gt;
const HOT_SINGER_LEN &lt;/span&gt;= 10&lt;span&gt;

_normalizeSinger(list){
     let map &lt;/span&gt;=&lt;span&gt; {
           hot: {
                title: HOT_NAME,
                items: []
           }
    }

    list.forEach((item, index) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(index &amp;lt;&lt;span&gt; HOT_SINGER_LEN) {
             map.hot.items.push({
                     id: item.Fsinger_mid,
                     name: item.Fsinger_name,          &lt;br/&gt;avatar:`https:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;y.gtimg.cn/music/photo_new/T001R300x300M000${item.Fsinger_mid}.jpg?max_age=2592000`&lt;/span&gt;
&lt;span&gt;             })
          }
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据Findex作聚类&lt;/span&gt;
          const key =&lt;span&gt; item.Findex
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;map[key]) {
              map[key] &lt;/span&gt;=&lt;span&gt; {
                     title: key,
                     items: []
             }
         }
         map[key].items.push({
             id: item.Fsinger_mid,
             name: item.Fsinger_name,
             avatar:`https:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;y.gtimg.cn/music/photo_new/T001R300x300M000${item.Fsinger_mid}.jpg?max_age=2592000`&lt;/span&gt;
&lt;span&gt;        }) 
    })

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; console.log(map)&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li readability=&quot;-1&quot;&gt;&lt;span&gt;&lt;span&gt;为了得到有序列表，需要&lt;span&gt;处理map&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;let hot = [] &lt;span&gt;//&lt;/span&gt;&lt;span&gt;title是热门的歌手&lt;/span&gt;
let ret = [] &lt;span&gt;//&lt;/span&gt;&lt;span&gt;title是A-Z的歌手&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt;(let key &lt;span&gt;in&lt;/span&gt;&lt;span&gt; map){
     let val &lt;/span&gt;=&lt;span&gt; map[key]
     &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(val.title.match(/[a-zA-Z]/&lt;span&gt;)) {
        ret.push(val)
     }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(val.title ===&lt;span&gt; HOT_NAME) {
        hot.push(val)
     }
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li readability=&quot;-1.5&quot;&gt;&lt;span&gt;&lt;span&gt;为ret数组进行&lt;span&gt;A-Z排序&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;ret.sort((a, b) =&amp;gt;&lt;span&gt; {
     &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; a.title.charCodeAt(0) - b.title.charCodeAt(0&lt;span&gt;)
})&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;最后将&lt;span&gt;ret数组拼接在hot数组后返回&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;return&lt;/span&gt; hot.concat(ret)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;     &lt;/span&gt;  &lt;strong&gt;listview.vue类通讯录组件开发&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;【滚动列表实现】&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;base-&amp;gt;listview目录下：创建&lt;span&gt;listview.vue&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;引用scroll组件，在&amp;lt;scroll&amp;gt;根标签中传入data数据，当data发生变化时，强制BScroll重新计算&lt;/span&gt;&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;&lt;span&gt;&lt;span&gt;props参数：&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;props:{
    data: {
        type: Array,
        &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;: []
    }
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;0.5&quot;&gt;&lt;span&gt;&lt;span&gt;DOM布局：&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;scroll &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;listview&quot;&lt;/span&gt;&lt;span&gt; :data&lt;/span&gt;&lt;span&gt;=&quot;data&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li &lt;/span&gt;&lt;span&gt;v-for&lt;/span&gt;&lt;span&gt;=&quot;(group, index) in data&quot;&lt;/span&gt;&lt;span&gt; :key&lt;/span&gt;&lt;span&gt;=&quot;index&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;list-group&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h2 &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;list-group-title&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{group.title}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li &lt;/span&gt;&lt;span&gt;v-for&lt;/span&gt;&lt;span&gt;=&quot;(item, index) in group.items&quot;&lt;/span&gt;&lt;span&gt; :key&lt;/span&gt;&lt;span&gt;=&quot;index&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;list-group-item&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;:src&lt;/span&gt;&lt;span&gt;=&quot;item.avatar&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;avatar&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;name&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{item.name}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
             &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;scroll&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;singer.vue&lt;/span&gt;中&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li readability=&quot;-2&quot;&gt;&lt;span&gt;&lt;span&gt;引入并注册listview组件，传入参数data,绑定singers数据:&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;singer&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;listview &lt;/span&gt;&lt;span&gt;:data&lt;/span&gt;&lt;span&gt;=&quot;singers&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;listview&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;&lt;span&gt;&lt;span&gt;修改_getSingerList()中的singers为&lt;span&gt;重置数据结构后的singers&lt;/span&gt;：&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;this&lt;/span&gt;.singers = &lt;span&gt;this&lt;/span&gt;._normalizeSinger(res.data.list)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;&lt;span&gt;&lt;span&gt;优化：使用&lt;span&gt;图片懒加载技术&lt;/span&gt;处理&amp;lt;img&amp;gt;，&lt;span&gt;:src替换为v-lazy&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;v-lazy&lt;/span&gt;&lt;span&gt;=&quot;item.avatar&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;avatar&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;【右侧快速入口实现】&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li readability=&quot;-1&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;listview.vue&lt;/span&gt;中通过computed定义shortcutList()，获得title的集合数组&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;computed: {
    shortcutList() { &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到title的集合数组，‘热门’取1个字&lt;/span&gt;
          &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.data.map((group) =&amp;gt;&lt;span&gt; {
                 &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; group.title.substr(0, 1&lt;/span&gt;&lt;span&gt;&lt;span&gt;) 
          })
    }
}&lt;/span&gt; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;&lt;span&gt;&lt;span&gt;在&amp;lt;scroll&amp;gt;内层，与歌手列表同级编写布局DOM：&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;list-shortcut&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li &lt;/span&gt;&lt;span&gt;v-for&lt;/span&gt;&lt;span&gt;=&quot;(item, index) in shortcutList&quot;&lt;/span&gt;&lt;span&gt; :key&lt;/span&gt;&lt;span&gt;=&quot;index&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;item&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;{{item}}&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;&lt;span&gt;&lt;span&gt;CSS样式：&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.list-shortcut
   position: absolute //绝对定位到右侧 
   right: 0
   top: 50%&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;【点击定位实现】&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;关键: &lt;span&gt;监听touchstart事件&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;为&amp;lt;li class=&quot;item&quot;&amp;gt;扩展一个属性变量&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;:&lt;span&gt;data-index&lt;/span&gt;=&quot;index&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;&lt;span&gt;&lt;span&gt;在&lt;span&gt;dom.js&lt;/span&gt;中封装一个getData函数，得到属性data-val的值&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;export &lt;span&gt;function&lt;/span&gt;&lt;span&gt; getData(el, name, val){
       const prefix &lt;/span&gt;= 'data-'&lt;span&gt;
       name &lt;/span&gt;= prefix +&lt;span&gt; name
       &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(val){
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; el.setAttribute(name, val)
       }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; el.getAttribute(name)
       }
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;&lt;span&gt;&lt;span&gt;在 &lt;span&gt;scroll.vue&lt;/span&gt; 中扩展两个方法：&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;scrollTo() {
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 滚动到指定的位置；这里使用apply 将传入的参数，传入到this.scrollTo()&lt;/span&gt;
     &lt;span&gt;this&lt;/span&gt;.scroll &amp;amp;&amp;amp; &lt;span&gt;this&lt;/span&gt;.scroll.scrollTo.apply(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.scroll, arguments)
},
scrollToElement() {
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 滚动到指定的目标元素&lt;/span&gt;
     &lt;span&gt;this&lt;/span&gt;.scroll &amp;amp;&amp;amp; &lt;span&gt;this&lt;/span&gt;.scroll.scrollToElement.apply(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.scroll, arguments)
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;listview.vue&lt;/span&gt;中&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li readability=&quot;-2&quot;&gt;&lt;span&gt;&lt;span&gt;引入getData方法：&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import {getData} from '@/common/js/dom'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&amp;lt;scroll&amp;gt;根标签中添加引用： ref=&quot;listview&quot;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&amp;lt;li class=&quot;list-group&quot;&amp;gt;中添加引用： ref=&quot;listGroup&quot;&lt;/span&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;&lt;span&gt;&lt;span&gt;给快速入口列表 &lt;span&gt;监听touchstart事件&lt;/span&gt;：&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;list-shortcut&quot;&lt;/span&gt;&lt;span&gt; @touchstart&lt;/span&gt;&lt;span&gt;=&quot;onShortcutTouchStart&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;onShortcutTouchStart(e) {
       let anchorIndex &lt;/span&gt;= getData(e.target, 'index')&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取data-index的值 index&lt;/span&gt;
&lt;span&gt;      _scrollTo(anchorIndex)
}
_scrollTo(index){
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$refs.listview.scrollToElement(&lt;span&gt;this&lt;/span&gt;.$refs.listGroup[index], 0)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;列表滚动定位&lt;/span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;【滑动联动实现】&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;关键：&lt;span&gt;监听touchmove事件&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;需求：滑动右侧快速入口列表，左侧歌手列表随之滚动&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;坑：快速入口列表下方就是歌手列表，同样可以滚动，需要避免滑动快速入口列表时，也使歌手列表受到影响&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;解决：&lt;span&gt;阻止事件冒泡，阻止浏览器的延伸滚动&lt;/span&gt; &lt;span&gt;@touchmove.stop.prevent&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;思路：&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;&lt;span&gt;在touchstart事件触发时，记录touch处的y值y1和anchorIndex，存储到this.touch对象中&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;在touchmove事件触发时，同样记录touch处的y值y2，计算(y2-y1)/每个列表项的像素高 | 0 向下取整，&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;得到两次touch位置列表项的差值delta，使touchmove时的anchorIndex = touch对象的anchorIndex + delta&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;调用封装好的_scrollTo方法，传入anchorIndex，使歌手列表滚动到对应位置&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li readability=&quot;1.5&quot;&gt;&lt;span&gt;&lt;span&gt;实现：&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;const ANCHOR_HEIGHT = 18 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过样式设置计算得到&lt;/span&gt;
&lt;span&gt;
created() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.touch = {} &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在created中定义touch对象，而不在data或computed中定义，是因为touch对象不用进行监测&lt;/span&gt;
&lt;span&gt;}

methods: {
       onShortcutTouchStart(e) {
             let anchorIndex &lt;/span&gt;= getData(e.target, 'index')&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取data-index的值 index 得到的是字符串&lt;/span&gt;
             let firstTouch = e.touches[0&lt;span&gt;]
             &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.touch.y1 =&lt;span&gt; firstTouch.pageY
             &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.touch.anchorIndex =&lt;span&gt; anchorIndex
             &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;._scrollTo(anchorIndex)
       },
       onShortcutTouchMove(e) {
             let firstTouch &lt;/span&gt;= e.touches[0&lt;span&gt;]
             &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.touch.y2 =&lt;span&gt; firstTouch.pageY
             let delta &lt;/span&gt;= (&lt;span&gt;this&lt;/span&gt;.touch.y2 - &lt;span&gt;this&lt;/span&gt;.touch.y1) / ANCHOR_HEIGHT | 0 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取列表项差值，| 0 向下取整 = Math.floor()&lt;/span&gt;
             let anchorIndex = parseInt(&lt;span&gt;this&lt;/span&gt;.touch.anchorIndex) +&lt;span&gt; delta
             &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;._scrollTo(anchorIndex)
       },
      _scrollTo(index){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第二个参数表示：要不要滚动动画缓动时间; 0 瞬间滚动&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.$refs.listview.scrollToElement(&lt;span&gt;this&lt;/span&gt;.$refs.listGroup[index], 0)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;列表滚动定位&lt;/span&gt;
&lt;span&gt;      }
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;坑：在touchstart时通过getData获得的anchorIndex是字符串，如果直接和delta相加得到的还是字符串，这样滚动的位置就不对&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;解决：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;let anchorIndex = &lt;span&gt;parseInt&lt;/span&gt;(this.touch.anchorIndex) + delta&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;【联动效果实现】&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;需求：滚动歌手列表时，快速入口列表对应的title项高亮显示&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;&lt;span&gt;监听scroll事件，拿到pos对象，定义一个变量scrollY，「&lt;span&gt;实时记录&lt;/span&gt;」歌手列表Y轴滚动的位置pos.y,&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;监测数据data，每次发生改变时，都重新计算每个group元素的高度height，存在listHeight数组中&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;监测scrollY，保留计算高度后的listHeight数组，遍历得到每个group元素的「&lt;span&gt;高度区间&lt;/span&gt;」上限height1和下限height2,&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;对比scrollY和每个group元素的高度区间height2-height1，确定当前滚动位置「&lt;span&gt;currentIndex&lt;/span&gt;」，映射到DOM中&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;ol&gt;&lt;li readability=&quot;-1.5&quot;&gt;&lt;span&gt;&lt;span&gt;scroll.vue中&lt;/span&gt;：&lt;/span&gt;&lt;span&gt;&lt;span&gt;添加一个props参数，决定要不要&lt;span&gt;监听BScroll的滚动事件scroll&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;listenScroll: {
     type: Boolean,
     &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;&lt;span&gt;&lt;span&gt;_initScroll方法中：&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.listenScroll) {
    let me &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;箭头函数中代理this&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.scroll.on('scroll', (pos) =&amp;gt; { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;监听scroll事件&lt;/span&gt;
         me.$emit('scroll', pos) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;派发一个scroll事件，传递pos位置对象：有x和y属性&lt;/span&gt;
&lt;span&gt;   })
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;listview.vue&lt;/span&gt;中：created()中添加两个属性值&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;this&lt;/span&gt;.listenScroll = &lt;span&gt;true&lt;/span&gt;
&lt;span&gt;this&lt;/span&gt;.listHeight = []&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&amp;lt;scroll&amp;gt;根标签中传值   :listenScroll=&quot;listenScroll&quot;    监听scroll事件   &lt;span&gt;@scroll=&quot;scroll&quot;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;常见习惯：&lt;span&gt;私有方法如_scrollTo()一般放在下面，公共方法或绑定事件的方法如scroll()放在上面&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;&lt;span&gt;&lt;span&gt;data中观测两个数据:   &lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;scrollY: -1 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;实时滚动的Y轴位置&lt;/span&gt;
currentIndex: 0 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前显示的第几个title项&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;&lt;span&gt;&lt;span&gt;methods中添加scroll方法，传入接收的pos对象：&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;scroll(pos) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.scrollY = pos.y &lt;span&gt;//&lt;/span&gt;&lt;span&gt;实时获取BScroll滚动的Y轴距离&lt;/span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-0.5&quot;&gt;&lt;span&gt;&lt;span&gt;添加_calculateHeight私有方法，&lt;span&gt;计算每个group的高度height&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;_calculateHeight() {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.listHight = [] &lt;span&gt;//&lt;/span&gt;&lt;span&gt;每次重新计算每个group高度时，恢复初始值&lt;/span&gt;
    const list = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$refs.listGroup
    let height &lt;/span&gt;= 0 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始位置的height为0&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.listHeight.push(height)
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(let i=0; i&amp;lt;list.length; i++&lt;span&gt;){
         let item &lt;/span&gt;= list[i] &lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到每一个group的元素&lt;/span&gt;
         height += item.clientHeight &lt;span&gt;//&lt;/span&gt;&lt;span&gt;DOM元素可以用clientHeight获取元素高度&lt;/span&gt;
         &lt;span&gt;this&lt;/span&gt;.listHeight.push(height) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到每一个元素对应的height&lt;/span&gt;
&lt;/span&gt;&lt;span&gt;&lt;span&gt;    }
}&lt;/span&gt; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;&lt;span&gt;watch:{}监测data的变化，使用setTimeout延时调用_calculateHeight，重新计算每个group的高度；监测scrollY的变化，遍历listHeight数组得到每个group元素的高度上限height1和下限height2；&lt;/span&gt;&lt;span&gt;&lt;span&gt;对比scrollY,确定当前滚动位置对应的title项currentIndex&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;watch: {
    data() {
       setTimeout(() &lt;/span&gt;=&amp;gt; { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用setTimeout延时：因为数据的变化和DOM的变化还是间隔一些时间的&lt;/span&gt;
           &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._calculateHeight()
       }, &lt;/span&gt;20&lt;span&gt;)
    },
    scrollY(newY) {
       listHeight &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.listHeight
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当滚动到顶部，newY&amp;gt;0&lt;/span&gt;
       &lt;span&gt;if&lt;/span&gt;(newY &amp;gt; 0&lt;span&gt;) {
          &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.currentIndex = 0
          &lt;span&gt;return&lt;/span&gt;&lt;span&gt;
       }
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在中间部分滚动，遍历到最后一个元素，保证一定有下限，listHeight中的height比元素多一个&lt;/span&gt;
       &lt;span&gt;for&lt;/span&gt;(let i = 0; i &amp;lt; listHeight.length-1; i++&lt;span&gt;){
            let height1 &lt;/span&gt;=&lt;span&gt; listHeight[i]
            let height2 &lt;/span&gt;= listHeight[i+1&lt;span&gt;]
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(-newY &amp;gt;= height1 &amp;amp;&amp;amp; -newY &amp;lt;&lt;span&gt; height2) { 
                 &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.currentIndex =&lt;span&gt; i
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; console.log(this.currentIndex)&lt;/span&gt;
                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt;
            }
      }
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当滚动到底部，且-newY大于最后一个元素的上限&lt;/span&gt;
     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;currentIndex 比listHeight中的height多一个, 比元素多2个&lt;/span&gt;
     &lt;span&gt;this&lt;/span&gt;.currentIndex = listHeight.length - 2&lt;span&gt;
    }
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;&lt;span&gt;&lt;span&gt;快速入口列表的title项&amp;lt;li class=&quot;item&quot;&amp;gt;  动态绑定current class，将currentIndex映射到DOM中:&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;:class=&quot;{'current': &lt;span&gt;currentIndex === index&lt;/span&gt;}&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;&lt;span&gt;&lt;span&gt;CSS样式：&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;amp;.current
   color: $color-theme&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;坑：scroll组件中设置了probeType的默认值为1：滚动的时候会派发scroll事件，会截流，只能监听缓慢的滚动，监听不到swipe快速滚动&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;解决：需要在&amp;lt;scroll&amp;gt;中传递 &lt;span&gt;:probeType=&quot;3&quot;&lt;/span&gt;  &lt;span&gt;除了实时派发scroll事件，在swipe的情况下仍然能实时派发scroll事件&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;坑：点击快速入口列表时，歌手列表会快速滚动，但点击的列表项没有高亮显示&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;原因：高亮没有依赖点击的点，而是通过scrollY计算得到的，但目前_scrollTo中只是使列表滚动，没有派发scroll事件，改变scrollY&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li readability=&quot;-2&quot;&gt;&lt;span&gt;&lt;span&gt;解决：在_scrollTo中，&lt;span&gt;手动改变scrollY的值，为当前元素的上限height&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;this&lt;/span&gt;.scrollY = -&lt;span&gt;this&lt;/span&gt;.listHeight[index]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;坑：touch事件都是加在父元素&amp;lt;div class=&quot;list-shortcut&quot;&amp;gt;上的，点击头尾--“热”“Z”之前和之后的边缘区块，会发现也是可以点击的，但它没有对应显示的歌手列表，这个点击是没有意义的&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li readability=&quot;-2&quot;&gt;&lt;span&gt;&lt;span&gt;解决：console.log（index）得知边缘区块的index都是&lt;span&gt;null&lt;/span&gt;，在_scrollTo中设置&lt;span&gt;如果是边缘区块，不执行任何操作，直接返回&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;if&lt;/span&gt;(!index &amp;amp;&amp;amp; index !== 0&lt;span&gt;){
   &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;坑：console.log（index）时发现滑动时滑到头部以上时是一个负值，滑到尾部以下时是一个很大的值&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;原因：touchmove一直在执行，这个事件一直没有结束，它的Y值就会变大，这样算出来的delta加上之前的touch.anchorIndex得到的值就可能会超&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li readability=&quot;-1.5&quot;&gt;&lt;span&gt;&lt;span&gt;解决：在_scrollTo中&lt;span&gt;处理index的边界情况&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;if&lt;/span&gt;(index &amp;lt; 0&lt;span&gt;){
   index &lt;/span&gt;= 0&lt;span&gt;
}&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(index &amp;gt; &lt;span&gt;this&lt;/span&gt;.listHeight.length - 2&lt;span&gt;){
   index &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;.listHeight.length - 2&lt;span&gt;
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;补充：scrollToElement(this.$refs.listGroup[index], 0)中的index没有出现问题，是因为&lt;span&gt;BScroll中已经做了边界的处理&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;     &lt;/span&gt; &lt;strong&gt;滚动固定标题实现--fixed title&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;需求：当滚动到哪个歌手列表，顶部就显示当前歌手列表的title, 且固定不动，直到滚动到下一个歌手列表，再显示下一个title&lt;/span&gt;&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;&lt;span&gt;&lt;span&gt;布局DOM: 当fixedTitle不为&quot; &quot;的时候显示&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;list-fixed&quot;&lt;/span&gt;&lt;span&gt; v-show&lt;/span&gt;&lt;span&gt;=&quot;fixedTitle&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;fixed-title&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{fixedTitle}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;&lt;span&gt;&lt;span&gt;computed中计算fixedTitle:&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;fixedTitle() { 
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;.scrollY &amp;gt; 0){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断边界，‘热门’往上拉时，不显示&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; ''&lt;span&gt;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始时，data默认为空，此时this.data[this.currentIndex]为undefinded&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.data[&lt;span&gt;this&lt;/span&gt;.currentIndex] ? &lt;span&gt;this&lt;/span&gt;.data[&lt;span&gt;this&lt;/span&gt;.currentIndex].title : ''&lt;span&gt;
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;&lt;span&gt;&lt;span&gt;CSS样式：&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.list-fixed
   position: absolute //绝对定位到顶部
   top: 0
   left: 0
   width: 100%&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;span&gt;坑：只有在歌手列表的title从底部穿过fixed title后，fixed title的内容才会发生改变，两个title没有过渡效果，体验不好&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;解决：&lt;span&gt;当歌手列表的title上边界滚动到fixed title下边界时，给fixed title添加一个上移效果&lt;/span&gt;，使两个title过渡顺滑&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li readability=&quot;-2&quot;&gt;&lt;span&gt;&lt;span&gt;定义一个数据：&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;diff: -1 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;fixed title的偏移位置&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;在scrollY(newY)中实时得到diff: &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;this&lt;/span&gt;.diff = height2 +&lt;span&gt; newY
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到fixed title上边界距顶部的偏移距离 = 歌手列表title height下限 + newY（上拉为负值）&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;给&amp;lt;div class=&quot;list-fixed&quot;&amp;gt;添加引用： &lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;ref=&quot;fixedTitle&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;通过样式设置得到并定义fixed title的div高度： &lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;const TITLE_HEIGHT = 30&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;&lt;span&gt;&lt;span&gt;在watch:{}中观测diff : &lt;span&gt;判断diff范围，数据改变DOM&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;diff(newVal) {
     let fixedTop &lt;/span&gt;= (newVal&amp;gt;0 &amp;amp;&amp;amp; newVal&amp;lt;TITLE_HEIGHT) ? newVal - TITLE_HEIGHT : 0
     &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;.fixedTop ===&lt;span&gt; fixedTop){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; 
     }
     &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.fixedTop =&lt;span&gt; fixedTop
     &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$refs.fixedTitle.style.transform = `translate3d(0, ${fixedTop}px, 0&lt;span&gt;)`
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;优化：listview歌手组件也是&lt;span&gt;异步请求的数据&lt;/span&gt;，所以也&lt;span&gt;加一个loading&lt;/span&gt;，引入loading组件注册&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li readability=&quot;-2&quot;&gt;&lt;span&gt;&lt;span&gt;布局DOM: &lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;loading-container&quot;&lt;/span&gt;&lt;span&gt; v-show&lt;/span&gt;&lt;span&gt;=&quot;!data.length&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;loading&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;loading&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;&lt;span&gt;&lt;span&gt;CSS样式：&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.loading-container
    position: absolute
    width: 100%
    top: 50%
    transform: translateY(-50%)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ol&gt;&lt;table border=&quot;0&quot; align=&quot;center&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;二、歌手详情页开发--singer-detail&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;table border=&quot;0&quot; align=&quot;center&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1244398/201812/1244398-20181209151512166-647233606.gif&quot; alt=&quot;&quot; width=&quot;192&quot; height=&quot;341&quot;/&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1244398/201812/1244398-20181209151613064-474192066.gif&quot; alt=&quot;&quot; width=&quot;192&quot; height=&quot;343&quot;/&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;&lt;span&gt;歌曲列表&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;span&gt;歌曲播放&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;     &lt;/span&gt;  &lt;strong&gt;子路由配置以及转场动画实现&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;components-&amp;gt;singer-detail目录下：创建&lt;span&gt;singer-detai.vue&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;route-&amp;gt;index.js&lt;/span&gt; 中引入并配置Singer子路由SingerDetail:&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import SingerDetail from '@/components/singer-detail/singer-detail'&lt;span&gt; 

{
    path: &lt;/span&gt;'/singer'&lt;span&gt;,
    component: Singer,
    children: [
            {
                 path: &lt;/span&gt;':id'&lt;span&gt;,
                 component: SingerDetail
            }
    ]
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;singer.vue&lt;/span&gt;中：添加路由容器&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;router-view&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;router-view&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;listview.vue&lt;/span&gt; 中：&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li readability=&quot;-2&quot;&gt;&lt;span&gt;&lt;span&gt;给&amp;lt;li class=&quot;list-group-item&quot;&amp;gt;添加点击事件：&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@click=&quot;selectItem(item)&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;&lt;span&gt;&lt;span&gt;methods中定义selectItem方法，将item作为事件参数，派发出去：&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;selectItem(item){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$emit('select'&lt;span&gt;, item)
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li readability=&quot;-1.5&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;singer.vue中的&amp;lt;listview&amp;gt;监听select事件，触发selectSinger，执行业务逻辑：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@select=&quot;selectSinger&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;selectSinger(singer){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$router.push({ &lt;span&gt;//&lt;/span&gt;&lt;span&gt;动态添加路由地址&lt;/span&gt;
            path: `/singer/&lt;span&gt;${singer.id}`
    })
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;span&gt;注意：&lt;span&gt;子路由并不是一个页面，只是一个层，使用z-index将之前的层全部盖住&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;&lt;span&gt;&lt;span&gt;CSS样式:&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.singer-detail
    position: fixed
    z-index: 100
    top: 0
    bottom: 0
    left: 0
    right: 0
    background: $color-background&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;span&gt;转场动画 : 从右向左滑动&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li readability=&quot;-2&quot;&gt; &lt;span&gt;&lt;span&gt;给singer-detail添加transition:&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;transition &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;slide&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;singer-detail&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;transition&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;0.5&quot;&gt;&lt;span&gt;&lt;span&gt;CSS样式：&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.slide-enter-active, .slide-leave-active
    transition: all 0.3s
.slide-enter, .slide-leave-to
    transform: translate3d(100%, 0, 0)   &lt;span&gt;//100% 完全移动到屏幕右侧 动画开始后向左滑入&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;     &lt;/span&gt;  &lt;strong&gt;Vuex&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;问题：子路由SingerDetail需要从父路由页面Singer获取很多数据，都用参数获取内容太多&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;解决: 使用&lt;span&gt;Vuex实现路由之间参数数据的获取&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Vuex GitBook地址 : &lt;span&gt;&lt;span&gt;&lt;a href=&quot;https://vuex.vuejs.org/zh/&quot; target=&quot;_blank&quot;&gt;https://vuex.vuejs.org/zh/&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;什么是Vuex : Vuex 是一个专为 Vue.js 应用程序开发的【&lt;span&gt;状态管理模式&lt;/span&gt;】。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;&lt;span&gt;它采用集中式存储管理应用的所有组件的状态，&lt;/span&gt;&lt;span&gt;并以相应的规则保证状态以一种可预测的方式发生变化&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;适用情况：构建一个&lt;span&gt;中大型单页应用&lt;/span&gt;，考虑如何更好地在组件外部管理状态时，使用Vuex&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;     &lt;/span&gt;  &lt;strong&gt;Vuex初始化&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;安装Vuex： &lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
&lt;span&gt;npm install vuex --save&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;span&gt;src-&amp;gt;store目录下新建：&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;index.js&lt;/span&gt;：入口文件&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;state.js&lt;/span&gt; : 管理所有状态 state&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;mutations.js&lt;/span&gt; : 管理所有mutation -- &lt;span&gt;更改 Vuex 的 store 中状态state的唯一方法&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;mutation-types.js&lt;/span&gt;：管理所有mutation 事件类型（type）-- 字符串常量&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;actions.js&lt;/span&gt;：处理异步操作和修改、以及对mutation的封装&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;getters.js&lt;/span&gt;: 对获取的state 做一些映射&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;Vuex 中的 mutation 非常类似于事件：&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;&lt;span&gt;每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;这个回调函数就是我们实际进行状态更改的地方，并且它会&lt;span&gt;接受 state 作为第一个参数&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;     &lt;/span&gt;  歌手数据配置&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li readability=&quot;-2&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;state.js&lt;/span&gt; 中定义singer数据：&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;const&lt;/span&gt; state =&lt;span&gt; {
     singer: {}
}

export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; state&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;mutation-types.js&lt;/span&gt; 中定义设置singer数据的字符串常量：&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;export const SET_SINGER = 'SET_SINGER'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;mutations.js&lt;/span&gt; 中对state进行修改：引入mutation-types作关联&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import * as types from './mutation-types'&lt;span&gt;

const mutations &lt;/span&gt;=&lt;span&gt; {
   [types.SET_SINGER](state, singer){
         state.singer &lt;/span&gt;=&lt;span&gt; singer
    }
}

export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; mutations&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;getter.js&lt;/span&gt; 中对state进行包装和输出，获得state.singer：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;export const singer = state =&amp;gt;&lt;span&gt; state.singer
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;state =&amp;gt; state.singer 箭头函数的简写，state是一个function，return返回一个state.singer&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;span&gt;同步修改，只需要通过mutation修改，不需要action进行异步操作&lt;/span&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;初始化 &lt;span&gt;index.js&lt;/span&gt; 入口文件：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import Vue from 'vue'&lt;span&gt;
import Vuex from &lt;/span&gt;'vuex'

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; * as 是es6的新import语法&lt;/span&gt;
import * as actions from './actions'&lt;span&gt;
import &lt;/span&gt;* as getters from './getters'&lt;span&gt;
import state from &lt;/span&gt;'./state'&lt;span&gt;
import mutations from &lt;/span&gt;'./mutations'

&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Vuex 内置日志插件用于一般的调试&lt;/span&gt;
import createLogger from 'vuex/dist/logger'&lt;span&gt;

Vue.use(Vuex)

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;只在开发环境时启动严格模式&lt;/span&gt;
const debug = process.env.NODE_ENV !== 'production'

&lt;span&gt;//&lt;/span&gt;&lt;span&gt;工厂方法输出一个单例Vuex.Store模式&lt;/span&gt;
export &lt;span&gt;default&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vuex.Store({
          actions,
          getters,
          state,
          mutations,
          strict: debug,
          plugins: debug &lt;/span&gt;?&lt;span&gt; [createLogger()] : []
})&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;table border=&quot;0&quot; align=&quot;center&quot;&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span&gt;在严格模式下，无论何时发生了状态变更且不是由 mutation 函数引起的，将会抛出错误。
这能保证所有的状态变更都能被调试工具跟踪到。

**&lt;span&gt;不要在发布环境下启用严格模式！&lt;/span&gt;**
严格模式会深度监测状态树来检测不合规的状态变更——请确保在发布环境下关闭严格模式，以避免性能损失。&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;ul&gt;&lt;li readability=&quot;-2&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;main.js&lt;/span&gt; 中引入Store , 并在new Vue实例中注入：&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import store from './store'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;singer.vue&lt;/span&gt; 中：&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li readability=&quot;-2&quot;&gt;&lt;span&gt;&lt;span&gt;引用vuex提供的【写入数据】语法糖&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import {&lt;span&gt;mapMutations&lt;/span&gt;} from 'vuex'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;&lt;span&gt;&lt;span&gt;在methods属性中调用mapMutations作对象映射：&lt;span&gt;把mutation的修改映射为一个方法名setSinger&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;...mapMutations({
   setSinger: &lt;/span&gt;'SET_SINGER'  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;对应mutation-types中定义的常量&lt;/span&gt;
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;&lt;span&gt;&lt;span&gt;在selectSinger(singer)方法中将singer传入this.setSinger()：&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;selectSinger(singer){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$router.push({
          path: `&lt;/span&gt;/singer/&lt;span&gt;${singer.id}`
    })
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.setSinger(singer) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现对mutation的提交，向state【写入数据】&lt;/span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;singer-detail.vue&lt;/span&gt;中&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li readability=&quot;-2&quot;&gt;&lt;span&gt;&lt;span&gt;引用vuex提供的【取出数据】语法糖：&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt; import {&lt;span&gt;mapGetters&lt;/span&gt;} from 'vuex'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;&lt;span&gt;&lt;span&gt;在computed中通过mapGetters &lt;span&gt;挂载singer属性&lt;/span&gt;：&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;computed: {
   ...mapGetters([
       &lt;/span&gt;'singer' &lt;span&gt;//&lt;/span&gt;&lt;span&gt;拿到getters.js中的singer&lt;/span&gt;
&lt;/span&gt;&lt;span&gt;&lt;span&gt;   ])
}&lt;/span&gt; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;&lt;span&gt;&lt;span&gt;在created()中打印出 this.singer，查看vuex中数据的传递是否成功&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;created() {
    console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.singer)
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;     &lt;/span&gt;  &lt;strong&gt;歌手详情数据抓取&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li readability=&quot;5&quot;&gt;&lt;span&gt;&lt;span&gt;api-&amp;gt;&lt;span&gt;singer.js&lt;/span&gt;中：&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;export &lt;span&gt;function&lt;/span&gt;&lt;span&gt; gerSingerDetail(singerId) {
     const url &lt;/span&gt;= 'https://c.y.qq.com/v8/fcg-bin/fcg_v8_singer_track_cp.fcg'&lt;span&gt;

     const data &lt;/span&gt;=&lt;span&gt; Object.assign({}, commonParams, {
              hostUin: &lt;/span&gt;0&lt;span&gt;,
              needNewCode: &lt;/span&gt;0&lt;span&gt;,
              platform: &lt;/span&gt;'yqq'&lt;span&gt;,
              order: &lt;/span&gt;'listen'&lt;span&gt;,
              begin: &lt;/span&gt;0&lt;span&gt;,
              num: &lt;/span&gt;100&lt;span&gt;,
              songstatus: &lt;/span&gt;1&lt;span&gt;,
              singermid: singerId
    })

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; jsonp(url, data, options)
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;singer-detail.vue&lt;/span&gt;中：&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li readability=&quot;-2&quot;&gt;&lt;span&gt;&lt;span&gt;引入getSingerDetail方法和ERR_OK常量：&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import {getSingerDetail} from '@/api/singer'&lt;span&gt;
import {ERR_OK} from &lt;/span&gt;'@/api/config'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;&lt;span&gt;&lt;span&gt;在methods中定义_getDetail()私有方法，通过调用getSingerDetail()返回promise对象，获取singer数据&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;_getDetail() {
    getSingerDetail(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.singer.id).then((res) =&amp;gt;&lt;span&gt; {
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(res.code ===&lt;span&gt; ERR_OK){
             console.log(res.data.list)
          }
    })
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;坑：只有从singer页面选择歌手跳转到对应singer-detail路由中，才能得到singer数据；&lt;/span&gt;&lt;span&gt;在singer-detail路由页面刷新时不会得到数据，这样也是没有意义的&lt;/span&gt;&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;&lt;span&gt;&lt;span&gt;解决: 在_getDetail()中添加判断，&lt;span&gt;当获取不到singer.id时，调用this.$route.push，使页面回退到singer路由&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.singer.id){
     &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$router.push('/singer'&lt;span&gt;)
     &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;     &lt;/span&gt;  &lt;strong&gt;歌手详情数据处理和Song类的封装&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li readability=&quot;2.5&quot;&gt;&lt;span&gt;api目录下创建&lt;span&gt;song.js&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;: 使用JavaScript constructor 属性&lt;span&gt;构造一个Song类&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;export &lt;span&gt;default&lt;/span&gt;&lt;span&gt; class Song {
       constructor({id, mid, singer, name, album, duration, image, url}){
               &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将参数全部拷贝到当前实例中&lt;/span&gt;
               &lt;span&gt;this&lt;/span&gt;.id =&lt;span&gt; id 
               &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.mid =&lt;span&gt; mid
               &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.singer =&lt;span&gt; singer
               &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name
               &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.album =&lt;span&gt; album
               &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.duration =&lt;span&gt; duration
               &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.image =&lt;span&gt; image
               &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.url =&lt;span&gt; url
      }
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;span&gt;这样就可&lt;span&gt;通过遍历res.data.list数据，得到经过Song类封装的对象&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;table border=&quot;0&quot; align=&quot;center&quot;&gt;&lt;tbody readability=&quot;1.5&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;    设计为类而不是对象的好处&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;可以把代码集中的一个地方维护&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;类的扩展器比对象的扩展器强很多，而且它是一种面向对象的编程方式&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;歌手详情数据处理 : &lt;span&gt;singer-detail.vue&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt; &lt;span&gt;data中维护一个数据  songs : [ ]&lt;/span&gt;&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;&lt;span&gt;&lt;span&gt;在song.js中处理musicData数据抽象出工厂方法，返回song实例：&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;抽象出一个工厂方法：传入musicData对象参数，实例化一个Song&lt;/span&gt;
export &lt;span&gt;function&lt;/span&gt;&lt;span&gt; createSong(musicData){
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Song({
            id: musicData.songid,
            mid: musicData.songmid,
            singer: filterSinger(musicData.singer),
            name: musicData.songname,
            album: musicData.albumname,
            duration: musicData.interval, &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;歌曲时长s&lt;/span&gt;
            image: `https:&lt;span&gt;//y.gtimg.cn/music/photo_new/T002R300x300M000${musicData.album&lt;/span&gt;mid}.jpg?max_age=2592000&lt;span&gt;`,
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;url: `http://ws.stream.qqmusic.qq.com/C100${musicData.songmid}.m4a?fromtag=0&amp;amp;guid=126548448`&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;注意guid以实时数据为主&lt;/span&gt;
            url: `http:&lt;span&gt;//dl.stream.qqmusic.qq.com/C400&lt;span&gt;${musicData.songmid}&lt;/span&gt;.m4a?vkey=&lt;span&gt;${songVkey}&lt;/span&gt;&amp;amp;guid=6319873028&amp;amp;uin=0&amp;amp;fromtag=66`&lt;/span&gt;
&lt;span&gt;     })
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;格式化处理singer数据&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; filterSinger(singer){
     let ret &lt;/span&gt;=&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;     if&lt;/span&gt;(!&lt;span&gt;singer){
&lt;/span&gt;&lt;span&gt;        return&lt;/span&gt; ''&lt;span&gt;
     }
     singer.forEach((s) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
         ret.push(s.name)
     })
&lt;/span&gt;&lt;span&gt;     return&lt;/span&gt; ret.join('/'&lt;span&gt;)
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;table border=&quot;0&quot; align=&quot;center&quot;&gt;&lt;tbody readability=&quot;2.914979757085&quot;&gt;&lt;tr readability=&quot;7.7732793522267&quot;&gt;&lt;td readability=&quot;6.8016194331984&quot;&gt;
&lt;p class=&quot;title-article&quot;&gt;&lt;span&gt;    vue.js最新版获取QQ音乐播放源&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li class=&quot;title-article&quot;&gt;&lt;span&gt;问题：课程中的旧版播放源地址已经获取不到了，因此不能再用过去的方法拼接url了&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;分析正确的播放源地址：&lt;/span&gt;&lt;span&gt;http://dl.stream.qqmusic.qq.com/C400001apXAh2mHRub.m4a?&lt;/span&gt;&lt;span&gt;guid=6319873028&lt;/span&gt;&lt;span&gt;&amp;amp;vkey=6DAE080C291DECFDC9A3C532879658439F66EBA6C58&lt;/span&gt;&lt;span&gt;8813C8A1&lt;/span&gt;&lt;span&gt;C12917030F&lt;/span&gt;&lt;span&gt;A050C2352&lt;/span&gt;&lt;span&gt;C15343CCCAC8FDE731383C2489026145978797D513&lt;/span&gt;&lt;span&gt;&amp;amp;uin=0&amp;amp;fromtag=66&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;对比参数可知，正确的拼接url为：&lt;/span&gt;&lt;span&gt;http://dl.stream.qqmusic.qq.com/C400${musicData.songmid}.m4a?vkey=${&lt;span&gt;songVkey&lt;/span&gt;}&amp;amp;guid=6319873028&amp;amp;uin=0&amp;amp;fromtag=66&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;注意：guid是会变化的,以自己抓取的实际值为准，需改动的有两处：①song.js中拼接的url ②singer.js中参数guid&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;抓取详解地址：【&lt;a href=&quot;https://blog.csdn.net/qq_33026699/article/details/80777015&quot; target=&quot;_blank&quot;&gt;蚂蚁农场的博客&lt;/a&gt;】&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;ul&gt;&lt;li readability=&quot;2&quot;&gt;&lt;span&gt;&lt;span&gt;获取正确url需要反向代理的方式请求vkey : &lt;span&gt;webpack.dev.config.js&lt;/span&gt;中配置&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;app.get('/api/music', &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(req, res){
       &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; url=&quot;https://c.y.qq.com/base/fcgi-bin/fcg_music_express_mobile3.fcg&quot;&lt;span&gt;

       axios.get(url, {
           headers: { &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过node请求QQ接口，发送http请求时，修改referer和host&lt;/span&gt;
                 referer: 'https://y.qq.com/'&lt;span&gt;,
                 host: &lt;/span&gt;'c.y.qq.com'&lt;span&gt;
           },
           params: req.query &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把前端传过来的params，全部给QQ的url&lt;/span&gt;
        }).then((response) =&amp;gt;&lt;span&gt; { 
           res.json(response.data)
        }).&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;((e) =&amp;gt;&lt;span&gt; {
          console.log(e)
       })
})&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;span&gt;注意：&lt;span&gt;webpack配置完之后必须重新启动&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li readability=&quot;5.5&quot;&gt;&lt;span&gt;&lt;span&gt;在&lt;span&gt;api-&amp;gt;singer.js&lt;/span&gt; 中定义getMusic方法获取vkey：&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;export &lt;span&gt;function&lt;/span&gt;&lt;span&gt; getMusic(songmid) {
     const url &lt;/span&gt;= '/api/music'&lt;span&gt;
     const data &lt;/span&gt;=&lt;span&gt; Object.assign({}, commonParams, {
              songmid: songmid,
              filename: &lt;/span&gt;'C400' + songmid + '.m4a'&lt;span&gt;,
              guid: &lt;/span&gt;6319873028, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;会变，以实时抓取的数据为准&lt;/span&gt;
              platform: 'yqq'&lt;span&gt;,
              loginUin: &lt;/span&gt;0&lt;span&gt;,
              hostUin: &lt;/span&gt;0&lt;span&gt;,
              needNewCode: &lt;/span&gt;0&lt;span&gt;,
              cid:&lt;/span&gt;205361747&lt;span&gt;,
              uin: &lt;/span&gt;0&lt;span&gt;,
              format: &lt;/span&gt;'json'&lt;span&gt;
    })
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; axios.get(url, {
             params: data
    }).then((res) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
             &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; Promise.resolve(res.data)
    })
}&lt;/span&gt; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;methods中定义方法 _normallizeSongs(list) &lt;span&gt;按需求重新处理数据&lt;/span&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;_normallizeSongs(list){
      let ret &lt;/span&gt;= [] &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回值&lt;/span&gt;
      list.forEach((item) =&amp;gt;&lt;span&gt; {
           let {musicData} &lt;/span&gt;= item &lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到music对象&lt;/span&gt;
           &lt;span&gt;//&lt;/span&gt;&lt;span&gt; console.log(musicData)&lt;/span&gt;
           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;createSong必传两个参数&lt;/span&gt;
           &lt;span&gt;if&lt;/span&gt;(musicData.songid &amp;amp;&amp;amp;&lt;span&gt; musicData.albummid){ 
               &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; console.log(getMusic(musicData.songmid))&lt;/span&gt;
               getMusic(musicData.songmid).then((res) =&amp;gt; {  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;异步获取vkey&lt;/span&gt;
               &lt;span&gt;//&lt;/span&gt;&lt;span&gt; console.log(res)&lt;/span&gt;
                       &lt;span&gt;if&lt;/span&gt;(res.code ===&lt;span&gt; ERR_OK){
                          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; console.log(res.data)&lt;/span&gt;
                          const svkey =&lt;span&gt; res.data.items
                          const songVkey &lt;/span&gt;= svkey[0&lt;span&gt;].vkey
                          const newSong &lt;/span&gt;=&lt;span&gt; createSong(musicData, songVkey)
                          ret.push(newSong)
                       }
              })
          }
    })
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; console.log(ret)&lt;/span&gt;
   &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;&lt;span&gt;&lt;span&gt;_getDetail()中：将处理好的数据赋给songs&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;this&lt;/span&gt;.songs = &lt;span&gt;this&lt;/span&gt;._normallizeSongs(res.data.list)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;     &lt;/span&gt;  music-list组件开发&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;在components-&amp;gt;music-lict目录下：创建&lt;span&gt;music-list.vue&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li readability=&quot;-1.5&quot;&gt;&lt;span&gt;&lt;span&gt;布局DOM:&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;music-list&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;back&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;i &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;icon-back&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;i&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1 &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;title&quot;&lt;/span&gt;&lt;span&gt; v-html&lt;/span&gt;&lt;span&gt;=&quot;title&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;bg-image&quot;&lt;/span&gt;&lt;span&gt; :style&lt;/span&gt;&lt;span&gt;=&quot;bgStyle&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;filter&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;&lt;span&gt;&lt;span&gt;需要从父组件接收的props参数：&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;props: {
    bgImage: {
         type: String,
         &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;: ''&lt;span&gt;
    },
    songs: {
         type: Array,
         &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;: []
    },
    title: {
        type: String,
        &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;: ''&lt;span&gt;
   }
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;singer-detail.vue&lt;/span&gt; 中应用music-list组件：&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li readability=&quot;-2&quot;&gt;&lt;span&gt;&lt;span&gt;将&amp;lt;div class=&quot;singer-detail&quot;&amp;gt;及其样式删掉，替换为&amp;lt;music-list&amp;gt;：&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;music-list &lt;/span&gt;&lt;span&gt;:songs&lt;/span&gt;&lt;span&gt;=&quot;songs&quot;&lt;/span&gt;&lt;span&gt; :title&lt;/span&gt;&lt;span&gt;=&quot;title&quot;&lt;/span&gt;&lt;span&gt; :bg-image&lt;/span&gt;&lt;span&gt;=&quot;bgImage&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;music-list&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;&lt;span&gt;&lt;span&gt;title和bgImage数据通过computed计算得到：&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;title() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.singer.name
},
bgImage() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.singer.avatar
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li readability=&quot;-2&quot;&gt;&lt;span&gt;&lt;span&gt;music-list.vue中将获得的数据填入DOM，bgStyle样式属性通过computed计算得到：&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;bgStyle() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; `background-image: url(${&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.bgImage})`
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;span&gt;歌曲列表抽象为song-list组件：&lt;/span&gt;&lt;span&gt;base-&amp;gt;song-list目录下：创建&lt;span&gt;song-list.vue&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li readability=&quot;-0.5&quot;&gt;&lt;span&gt;&lt;span&gt;布局DOM：&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;song-list&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li &lt;/span&gt;&lt;span&gt;v-for&lt;/span&gt;&lt;span&gt;=&quot;(song, index) in songs&quot;&lt;/span&gt;&lt;span&gt; :key&lt;/span&gt;&lt;span&gt;=&quot;index&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;item&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;content&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h2 &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;name&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{song.name}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;desc&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{getDesc(song)}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
           &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;CSS样式：&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_3a547b95-29ce-4d7d-b311-7cb4571f33e3&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_3a547b95-29ce-4d7d-b311-7cb4571f33e3&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_3a547b95-29ce-4d7d-b311-7cb4571f33e3&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.song-list
   .item
      display: flex
      align-items: center
      box-sizing: border-box
      height: 64px
      font-size: $font-size-medium
      .content
           flex: 1
           line-height: 20px
           overflow: hidden
          .name
               no-wrap()
               color: $color-text
          .desc
               no-wrap()
               margin-top: 4px
               color: $color-text-d&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;&lt;span&gt;&lt;span&gt;需要从父组件接收props参数songs&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;props: {
   songs: {
       type: Array,
       &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;: []
   }
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;&lt;span&gt;&lt;span&gt;将得到的数据填入DOM，其中desc通过methods定义getDesc(song)得到：&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;methods: {
    getDesc(song){
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; `${song.singer} 。${song.album}`
    }
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;在&lt;span&gt;music-list.vue&lt;/span&gt;中应用song-list组件&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li readability=&quot;-2&quot;&gt;&lt;span&gt;&lt;span&gt;引用并注册scroll和song-list组件：&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import Scroll from '@/base/scroll/scroll'&lt;span&gt;
import SongList from &lt;/span&gt;'@/base/song-list/song-list'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;&lt;span&gt;&lt;span&gt;布局DOM：&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;scroll &lt;/span&gt;&lt;span&gt;:data&lt;/span&gt;&lt;span&gt;=&quot;songs&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;list&quot;&lt;/span&gt;&lt;span&gt; ref&lt;/span&gt;&lt;span&gt;=&quot;list&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;song-list-wrapper&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;song-list &lt;/span&gt;&lt;span&gt;:songs&lt;/span&gt;&lt;span&gt;=&quot;songs&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;song-list&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;scroll&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;CSS样式：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_6a7b04e6-6c1f-4ee8-a9ff-efb5bd010812&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_6a7b04e6-6c1f-4ee8-a9ff-efb5bd010812&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_6a7b04e6-6c1f-4ee8-a9ff-efb5bd010812&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.list
     position: fixed
     top: 0
     bottom: 0
     width: 100%
     overflow: hidden
     background: $color-background
     .song-list-wrapper
           padding: 20px 30px&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;坑：&amp;lt;scroll class=&quot;list&quot;&amp;gt;的top值不能写死，因为不同浏览器不同视口中bgImage的高度是不同的&lt;/span&gt;&lt;/li&gt;
&lt;li readability=&quot;-0.5&quot;&gt;&lt;span&gt;&lt;span&gt;解决：给bgImage和list都添加ref引用，&lt;span&gt;在mounted中得到当前加载好的bgImage的高度，动态赋值给top&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;bg-image&quot;&lt;/span&gt;&lt;span&gt; :style&lt;/span&gt;&lt;span&gt;=&quot;bgStyle&quot;&lt;/span&gt;&lt;span&gt; ref&lt;/span&gt;&lt;span&gt;=&quot;bgImage&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;scroll &lt;/span&gt;&lt;span&gt;:data&lt;/span&gt;&lt;span&gt;=&quot;songs&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;list&quot;&lt;/span&gt;&lt;span&gt; ref&lt;/span&gt;&lt;span&gt;=&quot;list&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;mounted() {
     &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$refs.list.&lt;span&gt;$el&lt;/span&gt;.style.top = `${&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$refs.bgImage.clientHeight}px`
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;     &lt;/span&gt;  &lt;strong&gt;歌手详情页交互效果&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;需求：允许列表可以往上滚动&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ol readability=&quot;-2&quot;&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;music-list.vue&lt;/span&gt; 中去掉list的样式 &lt;span&gt;：overflow: hidden&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;&lt;span&gt;&lt;span&gt;需要一个在列表文字下面的层，随着列表的滚动实现往上推&lt;/span&gt;：&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;scroll&amp;gt;前添加布局DOM:&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;bg-layer&quot;&lt;/span&gt;&lt;span&gt; ref&lt;/span&gt;&lt;span&gt;=&quot;layer&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;
&lt;p&gt;&lt;span&gt;CSS样式：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;.bg-layer
    position: relative
    height: 100% &lt;span&gt; //屏幕高度的100%&lt;/span&gt;
    background: $color-background&lt;/span&gt; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;create()中添加属性，监听滚动：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;created() {
     &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.probeType = 3
     &lt;span&gt;this&lt;/span&gt;.listenScroll = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;&lt;span&gt;&lt;span&gt;将属性传入&amp;lt;scroll&amp;gt;中，并&lt;span&gt;监听scroll事件，实时监听scroll位置&lt;/span&gt;：&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;scroll &lt;/span&gt;&lt;span&gt;:data&lt;/span&gt;&lt;span&gt;=&quot;songs&quot;&lt;/span&gt;&lt;span&gt;   class&lt;/span&gt;&lt;span&gt;=&quot;list&quot;&lt;/span&gt;&lt;span&gt;   ref&lt;/span&gt;&lt;span&gt;=&quot;list&quot;&lt;/span&gt;&lt;span&gt; 
        :probe-type&lt;/span&gt;&lt;span&gt;=&quot;probeType&quot;&lt;/span&gt;&lt;span&gt;  :listen-scroll&lt;/span&gt;&lt;span&gt;=&quot;listenScroll&quot;&lt;/span&gt;&lt;span&gt;  @scroll&lt;/span&gt;&lt;span&gt;=&quot;scroll&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;&lt;span&gt;&lt;span&gt;同歌手列表： data中维护一个&lt;span&gt;scrollY&lt;/span&gt;数据&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;data() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;{
         scrollY: &lt;/span&gt;0&lt;span&gt;
    }
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;&lt;span&gt;&lt;span&gt;在methods中定义scroll(),实时给scrollY赋值：&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;scroll(pos) {
     &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.scrollY =&lt;span&gt; pos.y
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;0.5&quot;&gt;&lt;span&gt;&lt;span&gt;watch:{}中监测scrollY，为layer添加引用，设置layer的transform：&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;watch: {
   scrollY(newY) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$refs.layer.style['transform'] = `translate3d(0, ${newY}px, 0&lt;span&gt;)`
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$refs.layer.style['webkitTransform'] = `translate3d(0, ${newY}px, 0&lt;span&gt;)`
   }
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;坑：bg-layer的高度只有屏幕高度的100%，并不能无限滚动，当超出屏幕高度后下面的内容会露出来&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;解决：&lt;span&gt;限制bg-layer的滚动位置&lt;/span&gt;，最远只能滚动到标题以下，再往上滚动列表时，bg-layer固定不再滚动&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;实现：&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li readability=&quot;-1.5&quot;&gt;&lt;span&gt;&lt;span&gt;mounted中记录imageHeight，计算得到最小滚动Y：&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;this&lt;/span&gt;.imageHeight = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$refs.bgImage.clientHeight
&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.minTranslateY = -&lt;span&gt;this&lt;/span&gt;.imageHeight + RESERVED_HEIGHT &lt;span&gt;//&lt;/span&gt;&lt;span&gt;最远滚动位置，不超过minTranslateY&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;&lt;span&gt;&lt;span&gt;定义顶部以下偏移常量：&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;const RESERVED_HEIGHT = 40 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;滚动偏移距离&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;1.5&quot;&gt;&lt;span&gt;&lt;span&gt;scrollY(newY)中&lt;span&gt;得到最大滚动量，修改transform替换newY&lt;/span&gt;：&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;watch: {
   scrollY(newY) {
       let translateY &lt;/span&gt;= Math.max(&lt;span&gt;this&lt;/span&gt;.minTranslateY, newY) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;最大滚动量&lt;/span&gt;
       &lt;span&gt;this&lt;/span&gt;.$refs.layer.style['transform'] = `translate3d(0, ${translateY}px, 0&lt;span&gt;)`
       &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$refs.layer.style['webkitTransform'] = `translate3d(0, ${translateY}px, 0&lt;/span&gt;&lt;span&gt;&lt;span&gt;)`
  }
}&lt;/span&gt; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;     &lt;/span&gt;  &lt;strong&gt;优化 -- 封装JS的prefixStyle&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;CSS中不用写prefix：vue-loader用到了&lt;span&gt;autoprefix&lt;/span&gt;插件自动添加&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;JS中没有，需要自己封装： &lt;span&gt;利用浏览器的能力检测特性&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li readability=&quot;1.5&quot;&gt;&lt;span&gt;&lt;span&gt;在&lt;span&gt;dom.js&lt;/span&gt;中扩展一个方法：&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;能力检测: 查看elementStyle支持哪些特性&lt;/span&gt;
let elementStyle = document.createElement('div'&lt;span&gt;).style

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;供应商: 遍历查找浏览器的前缀名称，返回对应的当前浏览器&lt;/span&gt;
let vendor = (() =&amp;gt;&lt;span&gt; {
    let transformNames &lt;/span&gt;=&lt;span&gt; {
        webkit: &lt;/span&gt;'webkitTransform'&lt;span&gt;,
        Moz: &lt;/span&gt;'MozTransform'&lt;span&gt;,
        O: &lt;/span&gt;'OTransform'&lt;span&gt;,
        ms: &lt;/span&gt;'msTransform'&lt;span&gt;,
        standard: &lt;/span&gt;'transform'&lt;span&gt;
    }

   &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (let key &lt;span&gt;in&lt;/span&gt;&lt;span&gt; transformNames) {
       &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(elementStyle[transformNames[key]] !==&lt;span&gt; undefined) {
           &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; key
       }
   }

   &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;
})()

export &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; prefixStyle(style) {
   &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(vendor === &lt;span&gt;false&lt;/span&gt;&lt;span&gt;){
       &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;
   }
   &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(vendor === 'standard'&lt;span&gt;){
       &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; style
   }    
   &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; vendor + style.charAt(0).toUpperCase() + style.substr(1&lt;span&gt;)
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;0.5&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;music-list.vue&lt;/span&gt;中引用prefixStyle，并&lt;span&gt;定义常量代替原始属性，删掉手动添加prefix的语句&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import {prefixStyle} from '@/common/js/dom'&lt;span&gt;

const transform &lt;/span&gt;= prefixStyle('transform'&lt;span&gt;)
const backdrop &lt;/span&gt;= prefixStyle('backdrop-filter'&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$refs.layer.style[transform] = `translate3d(0, ${translateY}px, 0&lt;span&gt;)`
&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$refs.bgImage.style[transform] =&lt;span&gt; `scale(${scale})`
&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$refs.filter.style[backdrop] = `blur(${blur}px)`&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;     &lt;/span&gt;  歌手详情页剩余功能&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li readability=&quot;-2&quot;&gt;&lt;span&gt;&lt;span&gt;返回按钮：@click=&quot;back&quot;&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;back(){
     &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$router.back() &lt;span&gt;//&lt;/span&gt;&lt;span&gt;回退到上一级路由&lt;/span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;&lt;span&gt;&lt;span&gt;随机播放全部按钮：&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;play-wrapper&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;play&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;i &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;icon-play&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;i&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;随机播放全部&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;span&gt;坑：只有当列表数据都加载完成后，播放按钮才会显示&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;解决：&lt;span&gt;设置按钮显示时机&lt;/span&gt; v-show=&quot;songs.length&amp;gt;0&quot;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;坑：当列表滚动到顶部时，播放按钮因为绝对定位还在，体验不好，应该消失&lt;/span&gt;&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;解决：给按钮添加引用ref=&quot;playBtn&quot;，在scrollY(newY)中&lt;span&gt;判断滚动到顶部时修改display为none，正常显示时重置为空&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;if&lt;/span&gt;(newY &amp;lt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.minTranslateY) {
   &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$refs.playBtn.style.display = 'none'&lt;span&gt;
}&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
   &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$refs.playBtn.style.display = ''&lt;span&gt;
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;优化：异步获取的歌曲数据显示之前，&lt;span&gt;添加loading&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;loading-container&quot;&lt;/span&gt;&lt;span&gt; v-show&lt;/span&gt;&lt;span&gt;=&quot;!songs.length&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;   
     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;loading&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;loading&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31&quot;&gt;&lt;img id=&quot;code_img_closed_c89ae117-2297-4c66-bd7a-3eb2934aab28&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c89ae117-2297-4c66-bd7a-3eb2934aab28&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c89ae117-2297-4c66-bd7a-3eb2934aab28&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.loading-container
    position: absolute
    width: 100%
    top: 50%
    transform: translateY(-50%)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;版权声明：本文原创，未经本人允许不得转载&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;



&lt;/div&gt;

&lt;/div&gt;

&lt;/div&gt;



&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;/td&gt;&lt;td width=&quot;10&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;/td&gt;
</description>
<pubDate>Sun, 09 Dec 2018 07:23:00 +0000</pubDate>
<dc:creator>柳洁琼Elena</dc:creator>
<og:description>前言：上一篇总结了项目概况、项目准备、页面骨架搭建、推荐页面开发，这一篇重点梳理歌手页面开发、歌手详情页。项目github地址：https://github.com/66Web/ljq_vue_mus</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ljq66/p/10090690.html</dc:identifier>
</item>
<item>
<title>(二)通过JAVA调用SAP接口 (增加一二级参数) - Hikari410</title>
<link>http://www.cnblogs.com/hikarisama/p/10091253.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hikarisama/p/10091253.html</guid>
<description>&lt;h2 id=&quot;toc_1&quot;&gt;一、建立sap连接&lt;/h2&gt;
&lt;p&gt;请参考我的上一篇博客&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/hikarisama/p/10090901.html&quot; target=&quot;_blank&quot;&gt;JAVA连接SAP&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;toc_2&quot;&gt;二、测试项目环境准备&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;在上一篇操作下已经建好的环境后，在上面的基础上新增类即可&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;toc_3&quot;&gt;三、源码编写及测试&lt;/h2&gt;
&lt;p&gt;首先建立用来传递数据的实体类SapData，方便直接取出数据进行下一步处理&lt;br/&gt;SapData&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Created by gang.xu01@hand-china.com on 2018/12/5
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SapData {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 列数&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; fieldCount;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 列的具体名称&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String[] fieldNames;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 全部数据&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; List&amp;lt;Map&amp;lt;String, String&amp;gt;&amp;gt;&lt;span&gt; data;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; SapData(&lt;span&gt;int&lt;/span&gt; fieldCount, String[] fieldNames, List&amp;lt;Map&amp;lt;String, String&amp;gt;&amp;gt;&lt;span&gt; data) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.fieldCount =&lt;span&gt; fieldCount;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.fieldNames =&lt;span&gt; fieldNames;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.data =&lt;span&gt; data;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; SapData() {

    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getFieldCount() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; fieldCount;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setFieldCount(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; fieldCount) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.fieldCount =&lt;span&gt; fieldCount;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String[] getFieldNames() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; fieldNames;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setFieldNames(String[] fieldNames) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.fieldNames =&lt;span&gt; fieldNames;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;Map&amp;lt;String, String&amp;gt;&amp;gt;&lt;span&gt; getData() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; data;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setData(List&amp;lt;Map&amp;lt;String, String&amp;gt;&amp;gt;&lt;span&gt; data) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.data =&lt;span&gt; data;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;SapData{&quot; +
                &quot;fieldCount=&quot; + fieldCount +
                &quot;, fieldNames=&quot; + Arrays.toString(fieldNames) +
                &quot;, data=&quot; + data +
                '}'&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后编写用来从sap连接中获取数据的工具类 MultiFromSAP&lt;/p&gt;
&lt;p&gt;编写连接类 MultiFromSAP 下面是源码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Created by gang.xu01@hand-china.com on 2018/12/4
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MultiFromSAP {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * description: 从sap获取数据的工具类
     *
     * @date 2018/12/6 10:17 AM
     * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; gang.xu01@hand-china.com
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; sapConn sap连接
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; interfaceName 接口名称
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; firstParamKey 一级参数key 用逗号分隔
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; firstParamValue 一级参数value 用逗号分隔
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; secondParamKey 二级参数key 用逗号分隔
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; secondParamValue 二级参数value 用逗号分隔
     *
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; List
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; List&amp;lt;SapData&amp;gt;&lt;span&gt; getSapData(SapConn sapConn, String interfaceName,
                                           String firstParamKey, String firstParamValue,
                                           String secondParamKey, String secondParamValue) {
        List&lt;/span&gt;&amp;lt;SapData&amp;gt; returnList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;SapData&amp;gt;&lt;span&gt;();
        JCoFunction function;
        JCoDestination destination &lt;/span&gt;=&lt;span&gt; SAPConnUtils.connect(sapConn);
        System.out.println(&lt;/span&gt;&quot;正在从SAP获取数据&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用interface函数&lt;/span&gt;
            function =&lt;span&gt; destination.getRepository().getFunction(interfaceName);



            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 遍历全部得到的table并处理&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (JCoField field : function.getTableParameterList()) {

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 按照需求可以整理出一条一条的数据以便插入数据库&lt;/span&gt;
                JCoTable responseTable =&lt;span&gt; field.getTable();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 一级参数&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt;(&quot;&quot;.equals(firstParamKey) || &quot;&quot;&lt;span&gt;.equals(firstParamValue)) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 不需要参数&lt;/span&gt;
                }&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    String[] paramKeys &lt;/span&gt;= firstParamKey.split(&quot;,&quot;&lt;span&gt;);
                    String[] paramValues &lt;/span&gt;= firstParamValue.split(&quot;,&quot;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; paramKeys.length; i++&lt;span&gt;) {
                        function.getImportParameterList().setValue(paramKeys[i],
                                &lt;/span&gt;&quot;null&quot;.equals(paramValues[i]) ? &quot;&quot;&lt;span&gt; : paramValues[i]);
                    }
                }

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 二级参数&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt;(&quot;&quot;.equals(secondParamKey) || &quot;&quot;&lt;span&gt;.equals(secondParamValue)) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 不需要参数&lt;/span&gt;
                }&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    responseTable.appendRow();
                    String[] paramKeys &lt;/span&gt;= secondParamKey.split(&quot;,&quot;&lt;span&gt;);
                    String[] paramValues &lt;/span&gt;= secondParamValue.split(&quot;,&quot;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; paramKeys.length; i++&lt;span&gt;) {
                        responseTable.setValue(paramKeys[i],
                                &lt;/span&gt;&quot;null&quot;.equals(paramValues[i]) ? &quot;&quot;&lt;span&gt; : paramValues[i]);
                    }
                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用函数得到返回结果(调用接口把值放到function中)&lt;/span&gt;
&lt;span&gt;                function.execute(destination);

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取metaData(包含表的关键信息)&lt;/span&gt;
                JCoRecordMetaData metaData =&lt;span&gt; responseTable.getRecordMetaData();
                SapData sapData &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SapData();
                sapData.setFieldCount(metaData.getFieldCount());
                String[] name &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; String[sapData.getFieldCount()];
                List&lt;/span&gt;&amp;lt;Map&amp;lt;String, String&amp;gt;&amp;gt; sapList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Map&amp;lt;String, String&amp;gt;&amp;gt;&lt;span&gt;();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取全部名称&lt;/span&gt;
                &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = 0; j &amp;lt; sapData.getFieldCount(); j++&lt;span&gt;) {
                    name[j] &lt;/span&gt;=&lt;span&gt; metaData.getName(j);
                }
                sapData.setFieldNames(name);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取全部数据&lt;/span&gt;
                &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; responseTable.getNumRows(); i++&lt;span&gt;) {
                    responseTable.setRow(i);
                    Map&lt;/span&gt;&amp;lt;String, String&amp;gt; sapMap = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String, String&amp;gt;&lt;span&gt;();
                    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (String fieldName : sapData.getFieldNames()) {
                        sapMap.put(fieldName, responseTable.getString (fieldName));
                    }
                    sapList.add(sapMap);
                }
                sapData.setData(sapList);
                returnList.add(sapData);
            }

        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
        System.out.println(&lt;/span&gt;&quot;获取成功&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; returnList;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre&gt;
&lt;span&gt;接下来编写一个简单的测试类testData&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Created by gang.xu01@hand-china.com on 2018/12/9
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; testData {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {

        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; String interfaceName = &quot;xxx&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 一级参数&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; String firstParamKey = &quot;xx&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; String firstParamValue = &quot;xx&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 二级参数&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; String secondParamKey = &quot;xx&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; String secondParamValue = &quot;xx&quot;&lt;span&gt;;

        SapConn con &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SapConn(
                &lt;/span&gt;&quot;xx&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;xx&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;xx&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;xxx&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;xxx&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;xx&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;xx&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;xx&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;xxx&quot;&lt;span&gt;
        );

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 测试数据&lt;/span&gt;
&lt;span&gt;        MultiFromSAP.getSapData(con, interfaceName, firstParamKey, firstParamValue, secondParamKey, secondParamValue);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果出现空指针或者取到了结果但是是空值，那么表明取数为空或者不成功，请检查一级参数或者二级参数是否正确。&lt;/p&gt;
&lt;p&gt;此时如果调用结果如下则表明取数成功，此时全部数据封装在实体中，直接操作实体便可以操作。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/980606/201812/980606-20181209150025625-436334152.jpg&quot; alt=&quot;&quot; width=&quot;846&quot; height=&quot;265&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 09 Dec 2018 07:05:00 +0000</pubDate>
<dc:creator>Hikari410</dc:creator>
<og:description>在建立sap连接的基础上通过使用一级二级参数调用接口以获取sap接口中的数据</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hikarisama/p/10091253.html</dc:identifier>
</item>
<item>
<title>ML.NET 0.8特性简介 - Ken.W</title>
<link>http://www.cnblogs.com/kenwoo/p/10090881.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kenwoo/p/10090881.html</guid>
<description>&lt;p&gt;本周.NET生态圈内的更新源源不断，除了.NET Core 2.2，ASP.NET Core 2.2和Entity Framework Core 2.2之外，ML.NET 0.8也一并登上舞台。&lt;/p&gt;

&lt;p&gt;ML.NET使用基于矩阵分解(Matrix Factorization)和场感知分解机(Field-aware Factorization Machine)的方法来作推荐。一般而言，场感知分解机是矩阵分解更通用的例子，它允许传入额外的元数据。&lt;/p&gt;
&lt;p&gt;在ML.NET 0.8中新加了运用矩阵分解的推荐场景。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3.1708463949843&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2.8&quot;&gt;&lt;td&gt;基于产品Id，评价，用户Id和诸如产品描述，用户特征(年龄，国家)的额外元数据的产品推荐&lt;/td&gt;
&lt;td&gt;场感知分解机&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://github.com/dotnet/machinelearning-samples/tree/master/samples/csharp/end-to-end-apps/Recommendation-MovieRecommender&quot;&gt;ML.NET 0.3&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;1.7260273972603&quot;&gt;&lt;td&gt;基于产品Id，评价，用户Id的产品推荐&lt;/td&gt;
&lt;td&gt;矩阵分解&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://github.com/dotnet/machinelearning-samples/tree/master/samples/csharp/getting-started/MatrixFactorization_MovieRecommendation&quot;&gt;ML.NET 0.7&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;1.7872340425532&quot;&gt;&lt;td&gt;基于产品Id和与其一同购买的产品Id的产品推荐&lt;/td&gt;
&lt;td&gt;One Class矩阵分解&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://github.com/dotnet/machinelearning-samples/tree/master/samples/csharp/getting-started/MatrixFactorization_ProductRecommendation&quot;&gt;ML.NET 0.8&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;在新的推荐场景中，即使没有可用的评价，也可以通过历史购买数据为用户构建&quot;经常一起购买的产品&quot;(Frequently Bought Together)的列表。&lt;/p&gt;

&lt;p&gt;在多数例子里，当开始运行你的机器学习管道(pipeline)，且加载数据时，能看到已经载入的数据是很有用的功能。尤其是在某些中间转换过程之后，需要确保数据如预期的一样发生变化。&lt;/p&gt;
&lt;p&gt;现在当你想要预览DataView的数据模式(Schema)时，可以悬停鼠标在IDataView对象上，展开它，观察它的数据模式属性。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/991496/201812/991496-20181209134044150-1654589029.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而要查看DataView中已加载的实际数据，通过以下三步可以达成目标。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在调试模式中打开观察窗口&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;输入DataView对象的变量名，调用它的Preview方法&lt;/li&gt;
&lt;li&gt;点开想看的某行，这样就能显示其中实际加载的数据&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;默认情况下，只会显示100行的数据，但可以在Preview方法里传入参数，比如Preview(500)，以获得更多的数据。&lt;/p&gt;

&lt;p&gt;为了让模型更具可解释性，ML.NET 0.8引入了新的API，用以帮助理解模型的特征重要性(整体特征重要度(Overall Feature Importance))以及创建能被其他人解释的高效模型(广义加性模型(Generalized Additive Models))。&lt;/p&gt;
&lt;p&gt;整体特征重要度用于评判在模型中哪些特性是整体上最重要的。它帮助理解哪些特征是最有价值的，从而得到更好的预测结果。例如，当预测汽车价格时，一些特性比如里程数和生产商品牌是更重要的，而其它特性，如汽车颜色，则是影响甚小。&lt;/p&gt;
&lt;p&gt;模型的整体特征重要度可以通过&quot;排列特征重要度&quot;(Permutation Feature Importance)(PFI)技术来获得。PFI借由&quot;如果特征值设为随机数，会怎样影响模型&quot;这一问题以测量特征重要度。&lt;/p&gt;
&lt;p&gt;PFI方法的好处是其与模型无关，任何模型都可以用它作评估，并且它还可以使用任意数据。&lt;/p&gt;
&lt;p&gt;使用PFI的方法如下例代码所示：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;// Compute the feature importance using PFI
var permutationMetrics = mlContext.Regression.PermutationFeatureImportance(model, data);

// Get the feature names from the training set
var featureNames = data.Schema.GetColumns()
                .Select(tuple =&amp;gt; tuple.column.Name) // Get the column names
                .Where(name =&amp;gt; name != labelName) // Drop the Label
                .ToArray();

// Write out the feature names and their importance to the model's R-squared value
for (int i = 0; i &amp;lt; featureNames.Length; i++)
  Console.WriteLine($&quot;{featureNames[i]}\t{permutationMetrics[i].rSquared:G4}&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;生成的结果包括了特征名与它的重要度。&lt;/p&gt;
&lt;pre class=&quot;plain&quot;&gt;
&lt;code&gt;Console output:

    Feature            Model Weight    Change in R - Squared
    --------------------------------------------------------
    RoomsPerDwelling      50.80             -0.3695
    EmploymentDistance   -17.79             -0.2238
    TeacherRatio         -19.83             -0.1228
    TaxRate              -8.60              -0.1042
    NitricOxides         -15.95             -0.1025
    HighwayDistance        5.37             -0.09345
    CrimesPerCapita      -15.05             -0.05797
    PercentPre40s         -4.64             -0.0385
    PercentResidental      3.98             -0.02184
    CharlesRiver           3.38             -0.01487
    PercentNonRetail      -1.94             -0.007231&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;广义加性模型拥有很好的预测可解释性。在便于理解上，它类似于线性模型，但更加灵活，并具有更佳的性能以及利于分析的可视化能力。&lt;/p&gt;

&lt;h2 id=&quot;在dataview中过滤行&quot;&gt;在DataView中过滤行&lt;/h2&gt;
&lt;p&gt;有时你会需要对数据集过滤一部分数据，比如那些离群值(outlier)。ML.NET 0.8中新加入了FilterByColumn()API可以帮助解决类似问题。&lt;/p&gt;
&lt;p&gt;使用方法如下面的代码所示：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;IDataView trainingDataView = mlContext.Data.FilterByColumn(baseTrainingDataView, &quot;FareAmount&quot;, lowerBound: 1, upperBound: 150);&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;缓存功能的api&quot;&gt;缓存功能的API&lt;/h2&gt;
&lt;p&gt;当对同一数据作多次迭代处理时，通过缓存数据可以大幅减少训练时间。&lt;/p&gt;
&lt;p&gt;以下例子可以减少50%的训练时间：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var dataProcessPipeline = mlContext.Transforms.Conversion.MapValueToKey(&quot;Area&quot;, &quot;Label&quot;)
        .Append(mlContext.Transforms.Text.FeaturizeText(&quot;Title&quot;, &quot;TitleFeaturized&quot;))
        .Append(mlContext.Transforms.Text.FeaturizeText(&quot;Description&quot;, &quot;DescriptionFeaturized&quot;))
        .Append(mlContext.Transforms.Concatenate(&quot;Features&quot;, &quot;TitleFeaturized&quot;, &quot;DescriptionFeaturized&quot;))
        //Example Caching the DataView 
        .AppendCacheCheckpoint(mlContext) 
        .Append(mlContext.BinaryClassification.Trainers.AveragedPerceptron(DefaultColumnNames.Label,                                  
                                                                          DefaultColumnNames.Features,
                                                                          numIterations: 10));&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;以idataview二进制格式保存读取数据&quot;&gt;以IDataView二进制格式保存读取数据&lt;/h2&gt;
&lt;p&gt;将经过转换的数据保存为IDataView二进制格式相较普通的文本格式，可以极大地提升效率。同时，由于此格式保留了数据模式，所以可以方便读取而不需要再指定列类型。&lt;/p&gt;
&lt;p&gt;读取与保存的API如下所示，十分简单：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;mlContext.Data.ReadFromBinary(&quot;pathToFile&quot;);
mlContext.Data.SaveAsBinary(&quot;pathToFile&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;用于时间序列问题的状态性预测引擎&quot;&gt;用于时间序列问题的状态性预测引擎&lt;/h2&gt;
&lt;p&gt;ML.NET 0.7里可以基于时间序列处理异常检查问题。然而，其预测引擎是无状态的，这意味着每次要指出最新的数据点是否是异常的，需要同时提供历史数据。&lt;br/&gt;新的引擎中可以保留时间序列的状态，所以现在只要有最新的数据点，即可以进行预测。需要改动的地方是将&lt;code&gt;CreatePredictionFunction()&lt;/code&gt;方法替换成&lt;code&gt;CreateTimeSeriesPredictionFunction()&lt;/code&gt;。&lt;/p&gt;
</description>
<pubDate>Sun, 09 Dec 2018 06:58:00 +0000</pubDate>
<dc:creator>Ken.W</dc:creator>
<og:description>本周.NET生态圈内的更新源源不断，除了.NET Core 2.2，ASP.NET Core 2.2和Entity Framework Core 2.2之外，ML.NET 0.8也一并登上舞台。 新的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kenwoo/p/10090881.html</dc:identifier>
</item>
<item>
<title>Java线上问题排查思路及Linux常用问题分析命令学习 - 一枝花算不算浪漫</title>
<link>http://www.cnblogs.com/wang-meng/p/71c2a5cba49794f5af38f243db4f70ab.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wang-meng/p/71c2a5cba49794f5af38f243db4f70ab.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;之前线上有过一两次OOM的问题，但是每次定位问题都有点手足无措的感觉，刚好利用星期天，以测试环境为模版来学习一下Linux常用的几个排查问题的命令。&lt;br/&gt;也可以帮助自己在以后的工作中快速的排查线上问题。&lt;/p&gt;
&lt;h3 id=&quot;jmap命令&quot;&gt;jmap命令&lt;/h3&gt;
&lt;p&gt;jmap -heap pid 输出当前进程 JVM 堆新生代、老年代、持久代等请情况，GC 使用的算法等信息 &lt;br/&gt;jmap -histo:live {pid} | head -n 10 输出当前进程内存中所有对象包含的大小&lt;br/&gt;jmap -dump:format=b,file=/usr/local/logs/gc/dump.hprof {pid} 以二进制输出档当前内存的堆情况，然后可以导入 MAT 等工具进行&lt;/p&gt;
&lt;h4 id=&quot;1、jmap-heappid&quot;&gt;1、 jmap -heap pid&lt;/h4&gt;
&lt;p&gt;输出当前进程JVM堆新生代、老年代、持久代等情况，GC使用的算法等信息。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/799093/201812/799093-20181209145609060-547180624.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;2、jmap-histo:live{pid}|head-n10输出当前进程内存中所有对象包含的大小&quot;&gt;2、jmap -histo:live {pid} | head -n 10 输出当前进程内存中所有对象包含的大小&lt;/h4&gt;
&lt;p&gt;输出当前进程内存中所有对象实例数 (instances) 和大小 (bytes), 如果某个业务对象实例数和大小存在异常情况，可能存在内存泄露或者业务设计方面存在不合理之处。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/799093/201812/799093-20181209145609413-1576871505.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;jmap-dump：&quot;&gt;jmap -dump：&lt;/h4&gt;
&lt;p&gt;命令如下：&lt;br/&gt;mkdir logs&lt;br/&gt;jmap -dump:format=b,file=/tmp/logs/dump.hprof {pid}&lt;/p&gt;
&lt;p&gt;-dump:formate=b,file= 以二进制输出当前内存的堆情况至相应的文件，然后可以结合 MAT 等内存分析工具深入分析当前内存情况。&lt;br/&gt;也可以通过JVM参数配置OOM时自动dump当前内存镜像文件。 -XX:+HeapDumpOnOutOfMemoryError 和-XX:HeapDumpPath所代表的含义就是当程序出现OutofMemory时，将会在相应的目录下生成一份dump文件，而如果不指定选项-XX:HeapDumpPath则在当前目录下生成dump文件。&lt;br/&gt;确保应用发生 OOM 时 JVM 能够保存并 dump 出当前的内存镜像。&lt;br/&gt;当然，如果你决定手动 dump 内存时，dump 操作占据一定 CPU 时间片、内存资源、磁盘资源等，因此会带来一定的负面影响。&lt;br/&gt;此外，dump 的文件可能比较大 , 一般我们可以考虑使用 zip 命令对文件进行压缩处理，这样在下载文件时能减少带宽的开销。&lt;br/&gt;下载 dump 文件完成之后，由于 dump 文件较大可将 dump 文件备份至制定位置或者直接删除，以释放磁盘在这块的空间占用。&lt;/p&gt;
&lt;h3 id=&quot;dump日志分析&quot;&gt;dump 日志分析&lt;/h3&gt;
&lt;p&gt;MAT(Memory Analyzer Tool)，一个基于 Eclipse 的内存分析工具，是一个快速、功能丰富的 JAVA heap 分析工具，它可以帮助我们查找内存泄漏和减少内存消耗。&lt;br/&gt;使用内存分析工具从众多的对象中进行分析，快速的计算出在内存中对象的占用大小，看看是谁阻止了垃圾收集器的回收工作，并可以通过报表直观的查看到可能造成这种结果的对象。&lt;br/&gt;具体可以参考：&lt;a href=&quot;https://blog.csdn.net/jin_kwok/article/details/80326088&quot;&gt;Java内存分析工具MAT(Memory Analyzer Tool)安装使用实例 : https://blog.csdn.net/jin_kwok/article/details/80326088&lt;/a&gt; 和 &lt;a href=&quot;https://www.jianshu.com/p/2cf7169ba1c4&quot;&gt;基于Java内存dump文件分析解决内存泄漏问题 : https://www.jianshu.com/p/2cf7169ba1c4&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;jstack命令&quot;&gt;jstack命令&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;printf '%x\n' tid --&amp;gt; 10 进制至 16 进制线程 ID(navtive 线程) %d 10 进制&lt;br/&gt;jstack pid | grep tid -C 30 --color ps -mp 8278 -o THREAD,tid,time | head -n 40&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;某 Java 进程 CPU 占用率高，我们想要定位到其中 CPU 占用率最高的线程。&lt;br/&gt;(1) 先利用top命令找到CPU占用高的进程pid&lt;br/&gt;也可以通过ps -ef | grep 应用名 来快速定位自己应用的pid&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/799093/201812/799093-20181209145609683-64030502.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;显示pid：29080&lt;br/&gt;(2) 利用 top 命令可以查出占 CPU 最高的线程 pid (先找到该pid 29080下所有的线程数据)&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/799093/201812/799093-20181209145610005-889345981.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;可以看到占用cpu资源最高的为29173&lt;/p&gt;
&lt;p&gt;(3) 占用率最高的线程 ID 为29173，将其转换为 16 进制形式 (因为 java native 线程以 16 进制形式输出)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;printf '%x\n' 29173&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/799093/201812/799093-20181209145610294-1030547865.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;(4) 利用 jstack 打印出 java 线程调用栈信息&lt;br/&gt;jstack 29080 | grep '0x71f5' -A 50 --color&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/799093/201812/799093-20181209145610646-831537750.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到这个线程是在做kafka相关的操作。因为这是测试，所以并不是因为CPU真的占用过高的情况。&lt;br/&gt;更多内容也可以参考：&lt;br/&gt;&lt;a href=&quot;https://www.jianshu.com/p/6690f7e92f27&quot;&gt;如何使用jstack分析线程状态 : https://www.jianshu.com/p/6690f7e92f27&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/kingszelda/p/9034191.html&quot;&gt;通过jstack与jmap分析一次线上故障: https://www.cnblogs.com/kingszelda/p/9034191.html&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;jinfo命令&quot;&gt;jinfo命令&lt;/h3&gt;
&lt;p&gt;jinfo可以用来查看正在运行的java运用程序的扩展参数。&lt;br/&gt;查看pid对应的JVM参数，可以到 &lt;a href=&quot;http://xxfox.perfma.com/jvm/check&quot;&gt;PerfMa : http://xxfox.perfma.com/jvm/check&lt;/a&gt; 校验参数的正确性&lt;br/&gt;jinfo -flags pid&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/799093/201812/799093-20181209145610953-1796316527.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;拿到Command line后面的配置参数到perfma中验证查询：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/799093/201812/799093-20181209145611251-430253782.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里面好多功能可以去使用。&lt;/p&gt;
&lt;h3 id=&quot;jstat命令&quot;&gt;jstat命令&lt;/h3&gt;
&lt;p&gt;jstat：Java Virtual Machine statistics monitoring tool JDK自带的一个轻量级小工具。&lt;/p&gt;
&lt;h5 id=&quot;jstat显示GC执行的情况&quot;&gt;jstat显示GC执行的情况&lt;/h5&gt;
&lt;p&gt;jstat -gc 12538 5000&lt;br/&gt;即会每5秒一次显示进程号为12538的java进成的GC情况&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/799093/201812/799093-20181209145611536-412867147.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;说明：&lt;br/&gt;S0C、S1C、S0U、S1U：Survivor 0/1区容量（Capacity）和使用量（Used）&lt;br/&gt;EC、EU：Eden区容量和使用量&lt;br/&gt;OC、OU：年老代容量和使用量&lt;br/&gt;PC、PU：永久代容量和使用量&lt;br/&gt;YGC、YGT：年轻代GC次数和GC耗时&lt;br/&gt;FGC、FGCT：Full GC次数和Full GC耗时&lt;br/&gt;GCT：GC总耗时&lt;/p&gt;
&lt;p&gt;显示内容说明如下（部分结果是通过其他其他参数显示的，暂不说明）：&lt;br/&gt;S0C：年轻代中第一个survivor（幸存区）的容量 (字节)&lt;br/&gt;S1C：年轻代中第二个survivor（幸存区）的容量 (字节)&lt;br/&gt;S0U：年轻代中第一个survivor（幸存区）目前已使用空间 (字节)&lt;br/&gt;S1U：年轻代中第二个survivor（幸存区）目前已使用空间 (字节)&lt;br/&gt;EC：年轻代中Eden（伊甸园）的容量 (字节)&lt;br/&gt;EU：年轻代中Eden（伊甸园）目前已使用空间 (字节)&lt;br/&gt;OC：Old代的容量 (字节)&lt;br/&gt;OU：Old代目前已使用空间 (字节)&lt;br/&gt;PC：Perm(持久代)的容量 (字节)&lt;br/&gt;PU：Perm(持久代)目前已使用空间 (字节)&lt;br/&gt;YGC：从应用程序启动到采样时年轻代中gc次数&lt;br/&gt;YGCT：从应用程序启动到采样时年轻代中gc所用时间(s)&lt;br/&gt;FGC：从应用程序启动到采样时old代(全gc)gc次数&lt;br/&gt;FGCT：从应用程序启动到采样时old代(全gc)gc所用时间(s)&lt;br/&gt;GCT：从应用程序启动到采样时gc用的总时间(s)&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;一般分析CPU或者内存异常情况可以通过以下几步：&lt;/p&gt;
&lt;ol class=&quot;wiz-list-level1&quot;&gt;&lt;li&gt;查看日志&lt;/li&gt;
&lt;li&gt;查看CPU情况&lt;/li&gt;
&lt;li&gt;查看TCP情况&lt;/li&gt;
&lt;li&gt;查看java线程，jstack&lt;/li&gt;
&lt;li&gt;查看java堆，jmap&lt;/li&gt;
&lt;li&gt;通过MAT分析堆文件，寻找无法被回收的对象&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;参考：&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/GitChat/article/details/79019454&quot;&gt;Java线上问题排查思路与工具使用 : https://blog.csdn.net/GitChat/article/details/79019454&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 09 Dec 2018 06:56:00 +0000</pubDate>
<dc:creator>一枝花算不算浪漫</dc:creator>
<og:description>前言 之前线上有过一两次OOM的问题，但是每次定位问题都有点手足无措的感觉，刚好利用星期天，以测试环境为模版来学习一下Linux常用的几个排查问题的命令。 也可以帮助自己在以后的工作中快速的排查线上问</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wang-meng/p/71c2a5cba49794f5af38f243db4f70ab.html</dc:identifier>
</item>
<item>
<title>Python面向对象基础2：设置对象属性 - 骏马金龙</title>
<link>http://www.cnblogs.com/f-ck-need-u/p/10091181.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-ck-need-u/p/10091181.html</guid>
<description>&lt;h2 id=&quot;用类存储数据&quot;&gt;用类存储数据&lt;/h2&gt;
&lt;p&gt;类实际上就是一个数据结构，对于python而言，它是一个类似于字典的结构。当根据类创建了对象之后，这个对象就有了一个数据结构，包含一些赋值了的属性。在这一点上，它和其它语言的struct的作用是类似的：&lt;strong&gt;存储数据并提供数据检索功能&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;例如，下面是史上最简单的类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Person: pass&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;pass关键字表示这个类没有实际的逻辑体。这里只是定义了一个类，这个类的对象初始化时不会存放任何数据。现在，构造一个对象，让它和dict一样存放一些数据：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;p = Person()    # 构造对象
p.name = &quot;longshuai&quot;  # 创建对象的属性name
p.age = 23            # 创建对象的属性age&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在，Person的实例对象p中就存放了两个属性：p.name和p.age。可以直接去检索存放在p中的数据：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;print(p.name)  # 输出&quot;longshuai&quot;
print(p.age)   # 输出23&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也可以使用dict来存储这些数据：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; d={}
&amp;gt;&amp;gt;&amp;gt; d[&quot;name&quot;]=&quot;longshuai&quot;
&amp;gt;&amp;gt;&amp;gt; d[&quot;age&quot;]=23

&amp;gt;&amp;gt;&amp;gt; print(d[&quot;name&quot;])
longshuai
&amp;gt;&amp;gt;&amp;gt; print(d[&quot;age&quot;])
23&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在数据存储方面，它们的作用是完全等价的。实际上对象/类在内部就是使用一个名为&lt;code&gt;__dict__&lt;/code&gt;的dict类型来存放它所拥有的数据的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; p.__dict__
{'name': 'longshuai', 'age': 23}&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;init__构造对象初始数据&quot;&gt;__init__()构造对象初始数据&lt;/h2&gt;
&lt;p&gt;上面的name和age属性是在构建了对象之后附加上去的，如果想要创建对象时就存放好数据，可以定义类的构造函数&lt;code&gt;__init__()&lt;/code&gt;。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Person:
    def __init__(self,name,age):
        self.name = name
        self.age = age&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后创建对象的时候，传递name参数和age参数即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; p = Person(&quot;longshuai&quot;,23)
&amp;gt;&amp;gt;&amp;gt; p.__dict__
{'name': 'longshuai', 'age': 23}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果想定义这个类公有的数据，可以将公有属性定义为类的属性。比如中国人都是黄皮肤：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Person:
    skin = &quot;yellow&quot;
    def __init__(self,name,age):
        self.name = name
        self.age = age&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样每次创建Person的对象实例时，每个对象都会有相同的肤色：yellow。但注意，这个skin属性是类属性，不是对象属性，它是存放在类的名称空间中的。当对象真的需要这个属性的时候，会临时去检索&lt;strong&gt;类的名称空间&lt;/strong&gt;来获取。看下面的&lt;code&gt;__dict__&lt;/code&gt;字典即可知道：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; p = Person(&quot;longshuai&quot;,23)
&amp;gt;&amp;gt;&amp;gt; p.__dict__
{'name': 'longshuai', 'age': 23}
&amp;gt;&amp;gt;&amp;gt; p.skin
'yellow'&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;setter和getter方法&quot;&gt;setter和getter方法&lt;/h2&gt;
&lt;p&gt;在面向对象的角度上考虑，一般是不建议直接在类的外部通过&lt;code&gt;x.name&lt;/code&gt;的方式赋值、取值的。而是定义对应的方法，通过方法来取得对应的值。这两类方法称为setter、getter方法：setter用于赋值或设置属性值，getter用于取得属性值。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Person:
    skin = &quot;yellow&quot;
    def __init__(self,name,age):
        self.name = name
        self.age = age
    def set(self,job):
        self.job = job
        return self
    def get(self):
        return self.name,self.age,self.job&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的set方法用于设置一个新属性job。get用于返回对象的3个属性。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; p = Person(&quot;longshuai&quot;,23)
&amp;gt;&amp;gt;&amp;gt; p.set(&quot;manager&quot;)
&amp;gt;&amp;gt;&amp;gt; name, age, job = p.get()
&amp;gt;&amp;gt;&amp;gt; print([name,age,job])
['longshuai', 23, 'manager']&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要注意，&lt;strong&gt;setter方法可以有多种类型的返回值&lt;/strong&gt;，常用的有4种：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;返回设置后的值&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;返回设置前的值&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;返回对象自身&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;返回布尔值，表示是否设置成功&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这4种返回值都很常见，特别是第三种用来&lt;strong&gt;串联对象方法&lt;/strong&gt;的时候非常好用。修改上面的set方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Person:
    skin = &quot;yellow&quot;
    def __init__(self,name,age):
        self.name = name
        self.age = age
    def set(self,job):
        self.job = job
        return self
    def get(self):
        return self.name,self.age,self.job&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的set()返回self对象自身。于是串联set()和get()：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; p = Person(&quot;longshuai&quot;,23)
&amp;gt;&amp;gt;&amp;gt; name,age,job = p.set(&quot;manager&quot;).get()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;无论使用何种返回值方式，都不会真正影响程序的使用。但使用合理的返回值类型，可能会简化代码的编写。另外，决定了返回值的方式后，就不要再去修改，因为很可能会牵一发而动全身。&lt;/p&gt;
&lt;p&gt;上面的getter返回了多个值，但一般来说getter只返回一个对应的属性。比如getname()返回name属性，getage()返回age属性等。这样需要定义多个getter方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def get_name(self):
    return self.name

def get_age(self):
    return self.age

def get_job(self):
    return self.job&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;合并setter和getter&quot;&gt;合并setter和getter&lt;/h2&gt;
&lt;p&gt;很多时候可以合并setter和getter方法。合并的方式是判断方法的参数，如果调用方法的时候给了参数，就表示setter，没有给定参数，就表示是getter。&lt;/p&gt;
&lt;p&gt;例如，对于job属性：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def set_get_job(self, job=None):
    if job:
        self.job = job
    else:
        return self.job&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在可以以给参数和不给参数两种不同的方式来调用set_get_job()方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;p = Person(&quot;longshuai&quot;, 23)
p.set_get_job(&quot;manager&quot;)     # 给了参数，说明是setter
job = p.set_get_job()        # 没给参数，说明是getter&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;本文介绍了各种设置对象属性的方式，&lt;strong&gt;属性其实就是数据，对象/类就是属性的容器&lt;/strong&gt;，这一点很重要。我最开始学java的面向对象时，虽然对类和对象有那些教科书式的理解，但始终没有感受到&lt;strong&gt;类/对象其实就是一种用来存储数据的数据结构&lt;/strong&gt;。直到学习了Python/Perl，我才意识到这一点，然后理解面向对象就容易的多了。&lt;/p&gt;
</description>
<pubDate>Sun, 09 Dec 2018 06:46:00 +0000</pubDate>
<dc:creator>骏马金龙</dc:creator>
<og:description>用类存储数据 类实际上就是一个数据结构，对于python而言，它是一个类似于字典的结构。当根据类创建了对象之后，这个对象就有了一个数据结构，包含一些赋值了的属性。在这一点上，它和其它语言的struct</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-ck-need-u/p/10091181.html</dc:identifier>
</item>
<item>
<title>MutationObserver DOM变化的观察 - 野兽'</title>
<link>http://www.cnblogs.com/ys-ys/p/10091137.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ys-ys/p/10091137.html</guid>
<description>&lt;p&gt;简单的给MutationObserver做个测试及总结笔记。&lt;/p&gt;
&lt;p&gt;MutationObserver，window上的一个(构造)函数，可以通过其创建的观察者(观察对象)达到观察DOM的变化的效果。&lt;/p&gt;
&lt;p&gt;可适用的需求：开发者在DOM变化过程中的debug、根据页面变化处理不同的资源、拦截网页是否被注入动态内容加载的脚本等等...&lt;/p&gt;
&lt;p&gt;简单的案例代码如下，比如观察属性变化：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;J_click&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;click&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;J_dom&quot;&lt;/span&gt;&lt;span&gt; data-num&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;hello&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; dom &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; document.getElementById(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;J_dom&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; domObservable &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MutationObserver(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (mutationRecord) {
        console.log(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;mutationRecord : &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, mutationRecord)
    });

    document.getElementById(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;J_click&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).addEventListener(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;click&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, domChange, &lt;/span&gt;&lt;span&gt;!&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    
    domObservable.observe(dom, {
        attributes: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
        attributeOldValue: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
    })

    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; domChange() {
        dom.setAttribute(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;data-num&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;(dom.getAttribute(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;data-num&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)) &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    }
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;点击&quot;click&quot;按钮，J_dom的data-num属性从0变为1。控制台输出如下MutationRecord对象列表：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/702891/201812/702891-20181209142743379-1151600742.jpg&quot; alt=&quot;&quot; width=&quot;392&quot; height=&quot;336&quot;/&gt;&lt;/p&gt;


&lt;p&gt;MutationObserver 构造函数需要传入一个回调函数用以执行观察到DOM变化后需要做的操作，回调函数以MutationRecord对象列表作为参数。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;MutationRecord对象列表&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;MutationRecord对象包含以下属性：&lt;/p&gt;
&lt;p&gt;1. type，DOM变化的类型，DOM属性变化为&quot;attributes&quot;;DOM内数据变化为&quot;characterData&quot;;子节点树结构变化为&quot;childList&quot;；&lt;/p&gt;
&lt;p&gt;2. target，如果如果type不为&quot;childList&quot;,则代表发生变化的节点;如果type为&quot;childList&quot;,则是被操作子节点(新增或删除)的父节点；&lt;/p&gt;
&lt;p&gt;3. addedNodes，被观察的DOM内新增的节点列表；&lt;/p&gt;
&lt;p&gt;4. removedNodes，被观察的DOM内移除的节点列表；&lt;/p&gt;
&lt;p&gt;5. previousSibling，被添加或移除节点之前的兄弟节点；&lt;/p&gt;
&lt;p&gt;6. nextSibling，被添加或移除节点之后的兄弟节点；&lt;/p&gt;
&lt;p&gt;7. attributeName，被修改属性的属性名；&lt;/p&gt;
&lt;p&gt;8. attributeNamespace，被修改属性的命名空间；&lt;/p&gt;
&lt;p&gt;9. oldValue，旧值，根据type而返回对应的旧属性或旧数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;观察者(观察对象)&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;观察者对象上存在3个操作方法：observe、takeRecords、disconnect。&lt;/p&gt;
&lt;p&gt;observe方法指定一个被观察的DOM，配置该节点内的哪些变化需要被观察。方法使用如下： &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; domObservable = &lt;span&gt;new&lt;/span&gt; MutationObserver(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (mutationRecord) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 变化后的处理代码&lt;/span&gt;
&lt;span&gt;});

domObservable.observe(&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 被观察的DOM &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;, &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 配置参数 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;{
    subtree: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;,  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 观察范围是否包含子节点的变化，true则包括，false则不包括&lt;/span&gt;
    childList: &lt;span&gt;false&lt;/span&gt;,  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 被观察的节点的子节点变化，true则观察，false则不观察&lt;/span&gt;
    attributes: &lt;span&gt;false&lt;/span&gt;,  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 被观察的节点的属性变化，true则观察，false则不观察&lt;/span&gt;
    attributeOldValue: &lt;span&gt;false&lt;/span&gt;,  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; MutationRecord对象上是否返回被观察的节点的属性变化之前的旧值，true则返回，false则不返回&lt;/span&gt;
    attributeFilter: [&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 指定被观察的属性列表 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;],  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; attributes为true时生效，比如设置了列表为['class']，则只观察class的变化&lt;/span&gt;
    characterData: &lt;span&gt;false&lt;/span&gt;,   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 被观察的节点的数据变化，true则观察，false则不观察&lt;/span&gt;
    characterDataOldValue: &lt;span&gt;false&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; MutationRecord对象上是否返回被观察的节点的数据变化之前的旧值，true则返回，false则不返回&lt;/span&gt;
&lt;span&gt;});
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
  * 注意：
  * 在attributes未被配置的情况下，如果attributeOldValue为true或者attributeFilter被设置，则attributes默认为true。
  * 在characterData未被配置的情况下，如果characterDataOldValue为true，则characterData默认为true。
  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;takeRecords方法返回当前操作后的MutationRecord对象列表。方法使用如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;J_takeRecords&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;take records&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;J_dom&quot;&lt;/span&gt;&lt;span&gt; data-num&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;J_words&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;J_subDom&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; value &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; operateDom &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; document.getElementById(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;J_dom&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; wordsDom &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; document.getElementById(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;J_words&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; takeRecordsBtn &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; document.getElementById(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;J_takeRecords&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);

    takeRecordsBtn.addEventListener(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;click&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, takeRecords, &lt;/span&gt;&lt;span&gt;!&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; takeRecords() {
        console.log(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%c both change attribute and subtree&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;color:blue&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
        operateDom.setAttribute(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;data-num&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;(operateDom.getAttribute(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;data-num&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)) &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
        wordsDom.innerText &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; wordsDom.innerText &lt;/span&gt;&lt;span&gt;===&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;?&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;零&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; : &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; result &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; domObservable.takeRecords();
        console.log(result);
    }

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; domObservable &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MutationObserver(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (mutationsList) {
        console.log(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;mutationsList &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, mutationsList);
    })

    domObservable.observe(operateDom, {
        subtree: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
        attributes: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
        attributeOldValue: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
        characterData: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
        characterDataOldValue: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
    });
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 点击&quot;take records&quot;按钮，J_dom的data-num属性从0变为1，J_words里的0变成零 --&amp;gt;&lt;br/&gt;&amp;lt;!-- 分别为一次attrbutes和一次characterData变化，takeRecords方法被调用返回一个包含两次变化的MutationRecord对象列表。&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;disconnect方法移除该观察者上的所有观察并清空该对象的MutationRecord对象列表。&lt;/p&gt;

&lt;p&gt;最后，MutationObserver的兼容性如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/702891/201812/702891-20181209143445521-486638478.png&quot; alt=&quot;&quot; width=&quot;751&quot; height=&quot;384&quot;/&gt;&lt;/p&gt;
&lt;p&gt;嗯，还算行...&lt;/p&gt;

</description>
<pubDate>Sun, 09 Dec 2018 06:36:00 +0000</pubDate>
<dc:creator>野兽&amp;#39;</dc:creator>
<og:description>简单的给MutationObserver做个测试及总结笔记。 MutationObserver，window上的一个(构造)函数，可以通过其创建的观察者(观察对象)达到观察DOM的变化的效果。 可适用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ys-ys/p/10091137.html</dc:identifier>
</item>
<item>
<title>墨菲定律：迷茫还会继续迷茫 - venicid</title>
<link>http://www.cnblogs.com/venicid/p/10091109.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/venicid/p/10091109.html</guid>
<description>&lt;h2 id=&quot;墨菲定律迷茫还会继续迷茫&quot;&gt;墨菲定律：迷茫还会继续迷茫&lt;/h2&gt;
&lt;h3 id=&quot;墨菲定律&quot;&gt;墨菲定律&lt;/h3&gt;
&lt;p&gt;前几天看到公众号这样说，当你意识到你处在迷茫期，或者正在堕落的时候，恭喜你，你还会继续迷茫、堕落的。这就是著名的墨菲定律。不明觉厉&lt;/p&gt;
&lt;p&gt;Anything that can go wrong will go wrong。&lt;br/&gt;墨菲定律（Murphy's Law）是什么？最简单的表达形式是越怕出事，越会出事。&lt;br/&gt;”该定律的原句是这样的：If there are two or more ways to do something，and one of those ways can result in a catastrophe，then someone will do it.（如果有两种或以上选择，其中一种将导致灾难，则必定有人会作出这种选择。）&lt;/p&gt;
&lt;p&gt;&quot;墨菲定律&quot;是一种心理学效应，是由爱德华·墨菲(Edward A. Murphy)提出的。&lt;/p&gt;
&lt;p&gt;主要内容：&lt;/p&gt;
&lt;p&gt;1.任何事都没有表面看起来那么简单&lt;/p&gt;
&lt;p&gt;2.所有的事都会比你预计的时间长&lt;/p&gt;
&lt;p&gt;3.会出错的事总会出错&lt;/p&gt;
&lt;p&gt;4.如果你担心某种情况发生，那么它就更有可能发生。&lt;/p&gt;
&lt;p&gt;墨菲定律的原句是这样的：如果有两种或两种以上的方式去做某件事情，而其中一种选择方式将导致灾难，则必定有人会做出这种选择。这句话迅速流传。&lt;/p&gt;
&lt;p&gt;墨菲定律是其作出的著名论断，亦称莫非定律、墨菲定理，是西方世界常用的俚语。&lt;/p&gt;
&lt;p&gt;墨菲定律根本是：如果事情有变坏的可能，不管这种可能性有多小，它总会发生&lt;/p&gt;
&lt;h3 id=&quot;迷茫期还在继续&quot;&gt;迷茫期还在继续&lt;/h3&gt;
&lt;p&gt;或许说，从10月4日，从家里回来的时候开始，我就处在了动乱期，每天无所事事，每天的任务再也没有完成过了。&lt;br/&gt;忘记了，alex的鸡汤，失败者人格，华尔街英语&lt;br/&gt;忘记了，向前看，我们要学习的还有很多&lt;br/&gt;忘记了，区块链，web开发，数据分析，金融量化分析，机器学习，深度学习，人工智能&lt;/p&gt;
&lt;p&gt;我们不在继续学习了，我们没有梦想了，我们得过且过了，我们也没有欲望了，我们变成了那些工作几年后的老员工了。&lt;br/&gt;可怕的是，我现在就是这样的人了&lt;/p&gt;
&lt;p&gt;还有那个令人头疼的毕业设计&lt;br/&gt;毫无创新点可言，根本就不知道，自己能够干什么&lt;br/&gt;现在根本都是人工智能的天下，还有什么可以做的呢&lt;/p&gt;
&lt;h3 id=&quot;中庸之道&quot;&gt;中庸之道&lt;/h3&gt;
&lt;p&gt;20多年以来，如果说，我们的性格是什么的话，那就只能用中庸之道来形容我们了。或者说传统，封建，道德所束缚下的我们就是，这个中国的千千万万个之一&lt;/p&gt;
&lt;p&gt;中庸，或者说，从小听话，听老师的，听父母的。&lt;br/&gt;我觉得自己已经丧失了，好多东西了&lt;br/&gt;比如创造力，自己毫无创造力，想问题的方法，永远就是书本上的那样&lt;br/&gt;比如特立独行，如果谁要找到我的话，一定就是实验室lab，宿舍，吃饭。没有娱乐活动，没有意外，一切想想就是这些&lt;br/&gt;比如爱好特长，如果说娱乐活动的话，LOL，weibo，news，A片了，好像自己就这些活动了。没有什么想要得到的，每次填写爱好特长，什么都没有&lt;br/&gt;比如学习能力，获取知识的能力。我丧失了这种能力，学习了这么长时间的python，还是在恐惧编程，还是不能够，给我个需求，自己去写出来的&lt;br/&gt;比如独立完成，觉得写论文，写代码，自己就只能找到好多资源去copy，去修改参数，20变成10，之类的。我好想丧失了这种独立写出来的能力了。&lt;/p&gt;
&lt;p&gt;和同学一起走在路上吃瓜子，他吐瓜子皮随地乱吐，我只能放在手上，他就是不被道德束缚的人，是个世俗的人，我一直是那种遵守规则的人，中庸，道德的人。但是他在活动中，面试中，与人交流中，都是那样圆滑，有创造力，优势很大的，令人羡慕有痛恨的。我于是乎，也把瓜子皮吐到了地上，吐了几次，心里深感愧疚，有吐到手上了&lt;/p&gt;
&lt;h3 id=&quot;非黑即白&quot;&gt;非黑即白&lt;/h3&gt;
&lt;p&gt;20多年的读书生涯，没有教会我太多&lt;br/&gt;不过，我知道非黑即白，0就是0,1就是1，没有创新点就没有，是别人的就是别人的&lt;br/&gt;但是这样的我活的好痛苦，买东西，逃避砍价，与人交流不懂得寒暄，只会说正事&lt;br/&gt;还有就是情商太低，实话实说&lt;br/&gt;还有的话就是面试中，与人打交道中，我始终是个弟弟&lt;br/&gt;被社会抽打的太少，被社会磨炼的太少&lt;br/&gt;我想自救，却不知如何自救&lt;/p&gt;
&lt;h3 id=&quot;想的太多读书太少&quot;&gt;想的太多，读书太少&lt;/h3&gt;
&lt;p&gt;还有的话，就是没有一直在学校&lt;br/&gt;没有好好读书，&lt;br/&gt;有人说，我们总是想的太多，读书太少&lt;br/&gt;读万卷书，后面还有行万里路&lt;br/&gt;那些每周读一本书的人&lt;br/&gt;那些公司的CEO他们，好像很有时间的样子&lt;br/&gt;我能想到的就是自己时间不知道浪费到哪里去了&lt;br/&gt;别人用B站学习，我用B站去看吃播&lt;br/&gt;移动硬盘躺了几百G的资料&lt;br/&gt;自己却不动，什么都不想学习&lt;/p&gt;
&lt;h3 id=&quot;加速这个过程&quot;&gt;加速这个过程&lt;/h3&gt;
&lt;p&gt;我能想到的办法就是逃离这个环境&lt;br/&gt;加速现在的状态&lt;br/&gt;明年就是进入社会的第一年了&lt;br/&gt;我要去外地，去逃离，去改变&lt;/p&gt;
&lt;p&gt;但是，现在的我要怎么办呢&lt;br/&gt;这是不是大家都经历过的过程呢&lt;br/&gt;这是不是我们都在尝试的过程呢&lt;/p&gt;
&lt;p&gt;还有个办法，就是去谈恋爱吧&lt;br/&gt;但是说起这个事情&lt;br/&gt;我只能说&lt;br/&gt;舔狗不得house&lt;br/&gt;哈哈哈&lt;/p&gt;
</description>
<pubDate>Sun, 09 Dec 2018 06:30:00 +0000</pubDate>
<dc:creator>venicid</dc:creator>
<og:description>墨菲定律：迷茫还会继续迷茫 墨菲定律 前几天看到公众号这样说，当你意识到你处在迷茫期，或者正在堕落的时候，恭喜你，你还会继续迷茫、堕落的。这就是著名的墨菲定律。不明觉厉 Anything that c</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/venicid/p/10091109.html</dc:identifier>
</item>
</channel>
</rss>