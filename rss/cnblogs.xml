<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>统计各个分类和标签下的文章数 - 削微寒</title>
<link>http://www.cnblogs.com/xueweihan/p/12103739.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xueweihan/p/12103739.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201908/759200-20190828185611060-1211614569.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;作者：&lt;a href=&quot;https://www.zmrenwu.com&quot;&gt;HelloGitHub-追梦人物&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;3.4666666666667&quot;&gt;
&lt;p&gt;文中所涉及的示例代码，已同步更新到 &lt;a href=&quot;https://github.com/HelloGitHub-Team/HelloDjango-blog-tutorial&quot;&gt;HelloGitHub-Team 仓库&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在我们的博客侧边栏有分类列表和标签列表，显示博客已有的全部文章分类。现在想在分类名和标签名后显示该分类或者标签下有多少篇文章，该怎么做呢？最优雅的方式就是使用 django 的 &lt;code&gt;annotate&lt;/code&gt; 方法。&lt;/p&gt;
&lt;h2 id=&quot;model-回顾&quot;&gt;Model 回顾&lt;/h2&gt;
&lt;p&gt;回顾一下我们的 model 代码，django 博客有一个 &lt;code&gt;Post&lt;/code&gt; 和 &lt;code&gt;Category&lt;/code&gt; 模型，分别表示文章和分类：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;blog/models.py

class Post(models.Model):
    title = models.CharField('标题', max_length=70)
    body = models.TextField('正文')
    category = models.ForeignKey(Category, verbose_name='分类', on_delete=models.CASCADE)
    # 其它属性...
    
    def __str__(self):
        return self.title

class Category(models.Model):
    name = models.CharField('分类名', max_length=100)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们知道从数据库取数据都是使用模型管理器 objects 的方法实现的。比如获取全部分类是：&lt;code&gt;Category.objects.all()&lt;/code&gt; ，假设有一个名为 test 的分类，那么获取该分类的方法是：&lt;code&gt;Category.objects.get(name='test')&lt;/code&gt; 。objects 除了 &lt;code&gt;all&lt;/code&gt;、&lt;code&gt;get&lt;/code&gt; 等方法外，还有很多操作数据库的方法，而其中有一个 &lt;code&gt;annotate&lt;/code&gt; 方法，该方法正可以帮我们实现本文所关注的统计分类下的文章数量的功能。&lt;/p&gt;
&lt;h2 id=&quot;数据库数据聚合&quot;&gt;数据库数据聚合&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;annotate&lt;/code&gt; 方法在底层调用了数据库的数据聚合函数，下面使用一个实际的数据库表来帮助我们理解 &lt;code&gt;annotate&lt;/code&gt; 方法的工作原理。在 &lt;code&gt;Post&lt;/code&gt; 模型中我们通过 &lt;code&gt;ForeignKey&lt;/code&gt; 把 &lt;code&gt;Post&lt;/code&gt; 和 &lt;code&gt;Category&lt;/code&gt; 关联了起来，这时候它们的数据库表结构就像下面这样：&lt;/p&gt;
&lt;p&gt;Post 表：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;post 1&lt;/td&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;post 2&lt;/td&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;post 3&lt;/td&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;post 4&lt;/td&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;Category 表：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;category 1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;category 2&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;这里前 3 篇文章属于 category 1，第 4 篇文章属于 category 2。&lt;/p&gt;
&lt;p&gt;当 Django 要查询某篇 post 对应的分类时，比如 post 1，首先查询到它分类的 id 为 1，然后 Django 再去 Category 表找到 id 为 1 的那一行，这一行就是 post 1 对应的分类。反过来，如果要查询 category 1 对应的全部文章呢？category 1 在 Category 表中对应的 id 是 1，Django 就在 Post 表中搜索哪些行的 category_id 为 1，发现前 3 行都是，把这些行取出来就是 category 1 下的全部文章了。同理，这里 &lt;code&gt;annotate&lt;/code&gt; 做的事情就是把全部 Category 取出来，然后去 Post 查询每一个 Category 对应的文章，查询完成后只需算一下每个 category id 对应有多少行记录，这样就可以统计出每个 Category 下有多少篇文章了。把这个统计数字保存到每一条 Category 的记录就可以了（当然并非保存到数据库，在 Django ORM 中是保存到 Category 的实例的属性中，每个实例对应一条记录）。&lt;/p&gt;
&lt;h2 id=&quot;使用-annotate&quot;&gt;使用 Annotate&lt;/h2&gt;
&lt;p&gt;以上是原理方面的分析，具体到 Django 中该如何用呢？在我们的博客中，获取侧边栏的分类列表的方法写在模板标签 &lt;code&gt;get_categories&lt;/code&gt; 里，因此我们修改一下这个函数，具体代码如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;blog/templatetags/blog_extras.py

from django.db.models.aggregates import Count
from blog.models import Category

@register.inclusion_tag('blog/inclusions/_categories.html', takes_context=True)
def show_categories(context):
    category_list = Category.objects.annotate(num_posts=Count('post')).filter(num_posts__gt=0)
    return {
        'category_list': category_list,
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个 &lt;code&gt;Category.objects.annotate&lt;/code&gt; 方法和 &lt;code&gt;Category.objects.all&lt;/code&gt; 有点类似，它会返回数据库中全部 Category 的记录，但同时它还会做一些额外的事情，在这里我们希望它做的额外事情就是去统计返回的 Category 记录的集合中每条记录下的文章数。代码中的 &lt;code&gt;Count&lt;/code&gt; 方法为我们做了这个事，它接收一个和 Categoty 相关联的模型参数名（这里是 &lt;code&gt;Post&lt;/code&gt;，通过 ForeignKey 关联的），然后它便会统计 Category 记录的集合中每条记录下的与之关联的 Post 记录的行数，也就是文章数，最后把这个值保存到 &lt;code&gt;num_posts&lt;/code&gt; 属性中。&lt;/p&gt;
&lt;p&gt;此外，我们还对结果集做了一个过滤，使用 &lt;code&gt;filter&lt;/code&gt; 方法把 &lt;code&gt;num_posts&lt;/code&gt; 的值小于 1 的分类过滤掉。因为 &lt;code&gt;num_posts&lt;/code&gt; 的值小于 1 表示该分类下没有文章，没有文章的分类我们不希望它在页面中显示。关于 &lt;code&gt;filter&lt;/code&gt; 函数以及查询表达式（双下划线）在之前已经讲过，具体请参考 &lt;a href=&quot;https://www.zmrenwu.com/courses/hellodjango-blog-tutorial/materials/71/&quot;&gt;分类、归档和标签页&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;同理，tags 也可以做同样的操作。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;@register.inclusion_tag('blog/inclusions/_tags.html', takes_context=True)
def show_tags(context):
    tag_list = Tag.objects.annotate(num_posts=Count('post')).filter(num_posts__gt=0)
    return {
        'tag_list': tag_list,
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;在模板中引用新增的属性&quot;&gt;在模板中引用新增的属性&lt;/h2&gt;
&lt;p&gt;现在在 Category 和 Tag 列表中每一项都新增了一个 &lt;code&gt;num_posts&lt;/code&gt; 属性记录该 Category 下的文章数量，我们就可以在模板中引用这个属性来显示分类下的文章数量了。&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;templates/blog/inclusions/_categories.html

&amp;lt;div class=&quot;widget widget-category&quot;&amp;gt;
  &amp;lt;h3 class=&quot;widget-title&quot;&amp;gt;分类&amp;lt;/h3&amp;gt;
  &amp;lt;ul&amp;gt;
    {% for category in category_list %}
      &amp;lt;li&amp;gt;
        &amp;lt;a href=&quot;{% url 'blog:category' category.pk %}&quot;&amp;gt;{{ category.name }} &amp;lt;span class=&quot;post-count&quot;&amp;gt;({{ category.num_posts }})&amp;lt;/span&amp;gt;&amp;lt;/a&amp;gt;
      &amp;lt;/li&amp;gt;
    {% empty %}
      暂无分类！
    {% endfor %}
  &amp;lt;/ul&amp;gt;
&amp;lt;/div&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;标签也是一样：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;templates/blog/inclusions/_tags.html

&amp;lt;div class=&quot;widget widget-tag-cloud&quot;&amp;gt;
  &amp;lt;h3 class=&quot;widget-title&quot;&amp;gt;标签云&amp;lt;/h3&amp;gt;
  &amp;lt;ul&amp;gt;
    {% for tag in tag_list %}
      &amp;lt;li&amp;gt;
        &amp;lt;a href=&quot;{% url 'blog:tag' tag.pk %}&quot;&amp;gt;{{ tag.name }} &amp;lt;span class=&quot;post-count&quot;&amp;gt;({{ tag.num_posts }})&amp;lt;/a&amp;gt;
      &amp;lt;/li&amp;gt;
    {% empty %}
      暂无标签！
    {% endfor %}
  &amp;lt;/ul&amp;gt;
&amp;lt;/div&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也就是在模板中通过模板变量 &lt;code&gt;{{ category.num_posts }}&lt;/code&gt; 显示 &lt;code&gt;num_posts&lt;/code&gt; 的值。开启开发服务器，可以看到分类名后正确地显示了该分类下的文章数了，而没有文章分类则不会在分类列表中出现。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;『讲解开源项目系列』&lt;/strong&gt;——让对开源项目感兴趣的人不再畏惧、让开源项目的发起者不再孤单。跟着我们的文章，你会发现编程的乐趣、使用和发现参与开源项目如此简单。欢迎留言联系我们、加入我们，让更多人爱上开源、贡献开源～&lt;/p&gt;
</description>
<pubDate>Fri, 27 Dec 2019 00:51:00 +0000</pubDate>
<dc:creator>削微寒</dc:creator>
<og:description>作者： &amp;quot;HelloGitHub 追梦人物&amp;quot; 文中所涉及的示例代码，已同步更新到 &amp;quot;HelloGitHub Team 仓库&amp;quot; 在我们的博客侧边栏有分类列表和标签</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xueweihan/p/12103739.html</dc:identifier>
</item>
<item>
<title>你的按钮到底在帮助用户还是在误导用户？ - 葡萄城技术团队</title>
<link>http://www.cnblogs.com/powertoolsteam/p/12105462.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/powertoolsteam/p/12105462.html</guid>
<description>&lt;blockquote readability=&quot;7.4759825327511&quot;&gt;
&lt;p&gt;转载请注明出处：&lt;a href=&quot;https://www.grapecity.com.cn/&quot; target=&quot;_blank&quot;&gt;葡萄城官网&lt;/a&gt;，葡萄城为开发者提供专业的开发工具、解决方案和服务，赋能开发者。&lt;/p&gt;
&lt;p&gt;原文出处：https://blog.bitsrc.io/do-your-buttons-lead-or-mislead-your-users-d5d83531238b&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;hd&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;hd&quot;&gt;按钮是UI/UX最关键的组件之一，在不同设备及平台上得到了广泛的应用。它们具有影响用户行为和体验的能力。假如按钮设计不合理，会令用户产生误解及障碍。按钮设计的目的是引导用户完成我们在交互系统中预置的用户流程得以完成，但糟糕的按钮设计则可能会是你丢失你的用户。那么，现在是时候来研究该如何设计你的按钮了！所以今天我们不聊开发相关的知识，我们来看看这个在界面中小小并且重要的元素它的设计思路是怎样的吧。&lt;/p&gt;

&lt;p class=&quot;hd&quot;&gt;当用户同时看到好几个按钮，并且按钮的意义没有清晰地表述给用户，用户就会被你的“按钮阵”所误导，从而达不到预期的效果。所以具有清晰而合理的按钮层次结构，能促进用户能够直观、即时地分辨出你设计按钮的作用是什么。下面我们来看看影响按钮层次结构的3个方面：&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;按钮类型&lt;/strong&gt;&lt;/h2&gt;
&lt;p class=&quot;hd&quot;&gt;我们先来介绍一下常用的4种类型按钮：&lt;/p&gt;
&lt;p class=&quot;hd&quot;&gt;l  立体按钮：一个具有立体效果的按钮，使它引人注目。&lt;/p&gt;
&lt;p class=&quot;hd&quot;&gt;l  平面按钮：没有任何花哨效果的常规平面按钮。&lt;/p&gt;
&lt;p class=&quot;hd&quot;&gt;l  幽灵按钮：就像它的名字一样，幽灵按钮通常是透明的(没有背景色填充，和背景是融为一体的)，唯一的区别是这个按钮有一个边框勾勒出按钮的轮廓。&lt;/p&gt;
&lt;p class=&quot;hd&quot;&gt;l  文本按钮：仅由文本组成的按钮&lt;/p&gt;
&lt;p class=&quot;hd&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/139239/201912/139239-20191227084231338-1369304937.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p class=&quot;hd&quot;&gt;一般，这几种按钮类型在同一界面中可以以下顺序确定视觉上的主次程度：&lt;/p&gt;
&lt;p class=&quot;hd&quot;&gt;立体按钮 &lt;span lang=&quot;EN-US&quot;&gt;&amp;gt; 平面按钮 &lt;span lang=&quot;EN-US&quot;&gt;&amp;gt; 幽灵按钮 &lt;span lang=&quot;EN-US&quot;&gt;&amp;gt; 文本按钮&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;hd&quot;&gt;选择哪种按钮的核心在于根据不同厂家和用户需求来确定类型，以便能够更好的引导用户。例如：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/139239/201912/139239-20191227084245813-1624390207.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p class=&quot;hd&quot;&gt;使用立体按钮或平面按钮突出显示主按钮，次要按钮则尽量使用幽灵按钮或文本按钮以突出页面中不同的层次结构。上图中的“免费注册”是主要按钮，因为引导用户注册是这个页面最重要的任务。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;相似的按钮&lt;/strong&gt;&lt;/h2&gt;
&lt;p class=&quot;hd&quot;&gt;一般外观类似的按钮可以看作是同一层次的按钮，这是因为具有类似视觉特征的元素会被认为更相关。以不同的按钮类型实现不同功能，以降低用户的理解成本，才不会误导用户，例如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/139239/201912/139239-20191227084256354-1768137683.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p class=&quot;hd&quot;&gt;如上图，右侧的“&lt;span lang=&quot;EN-US&quot;&gt;UPDATE”按钮和“&lt;span lang=&quot;EN-US&quot;&gt;more”按钮具有不同的视觉特征，用户能够很好的将它们区分开。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/139239/201912/139239-20191227084306026-1317464818.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p class=&quot;hd&quot;&gt;显然，从“&lt;span lang=&quot;EN-US&quot;&gt;Home”按钮到“&lt;span lang=&quot;EN-US&quot;&gt;More”按钮的视觉类型是相同的，处于相同的层级，“&lt;span lang=&quot;EN-US&quot;&gt;Tweet”按钮属于更高层级中的类型。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;邻近的按钮&lt;/strong&gt;&lt;/h2&gt;
&lt;p class=&quot;gm&quot;&gt;彼此紧密排列的元素往往更相关。邻近有助于你能进一步组织相似的按钮从而为用户带来相同的功能。所以邻近的重要性就像单词之间的空格和段落之间的回车一样重要。正确运用这一原则，对引导用户产生积极的影响。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/139239/201912/139239-20191227084317461-259398936.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p class=&quot;hd&quot;&gt;在按钮之间添加空行以将其分为几种类型。放在一起的按钮会让人从视觉上就任务具有类似的功能。&lt;/p&gt;
&lt;p class=&quot;hd&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/139239/201912/139239-20191227084329516-905954879.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p class=&quot;hd&quot;&gt;“&lt;span lang=&quot;EN-US&quot;&gt;More”按钮和“&lt;span lang=&quot;EN-US&quot;&gt;Settings”按钮之间的空格巧妙的将按钮分为了两组，这表明从“&lt;span lang=&quot;EN-US&quot;&gt;All”到“&lt;span lang=&quot;EN-US&quot;&gt;More”是搜索结果的分类，而“&lt;span lang=&quot;EN-US&quot;&gt;Settings”和“&lt;span lang=&quot;EN-US&quot;&gt;Tools”按钮具有其他的作用。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;hd&quot;&gt;首先，正如《&lt;span lang=&quot;EN-US&quot;&gt;Don’t make me think》一书中提到的，用户永远不会在我们网站上通过“阅读”了解内容，他们则是通过“扫视”来了解的。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;hd&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/139239/201912/139239-20191227084341755-337661866.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p class=&quot;hd&quot;&gt;如果他们错过了我们期望他们按下的按钮，我们就会错失让用户成为潜在客户的商机。所以，把按钮做的足够醒目，从而牢牢抓住用户的眼球是至关重要的！&lt;/p&gt;
&lt;p class=&quot;hd&quot;&gt;要做到这一点，通过对比来突出按钮往往是很有效的方法。无论你在什么情况下使用哪种按钮类型，只要做到以下3点，就能使你的按钮最先被用户“捕获”：&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;负空间&lt;/strong&gt;&lt;/h2&gt;
&lt;p class=&quot;hd&quot;&gt;负空间是摄影中常见的一种技巧，它通过画面中大量的留白，通过强烈的对比度来达到突出主体的目的，这个技法在网页设计中也常被用到。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;尺寸&lt;/strong&gt;&lt;/h2&gt;
&lt;p class=&quot;gm&quot;&gt;尺寸是产生对比度的最有效元素之一。大尺寸的按钮始终可以吸引用户的注意力。首先在按钮周围留出足够的负空间，以突出按钮，同时把调整按钮的大小调整到用户足以在界面上很容易关注到它们。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;颜色&lt;/strong&gt;&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;通过为按钮设置负空间和尺寸，为按钮添加颜色可以进一步增强对比度。如果可以的话，你可以在调色板中选择一个足够醒目的颜色，以使用户能下意识的点击。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/139239/201912/139239-20191227084356316-64337065.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/139239/201912/139239-20191227084400895-782735509.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p class=&quot;gm&quot;&gt;把每个按钮的作用向用户传达准确是至关重要的。如果按钮的功能显示不清晰，则会引起用户的反感，因为他们不想去猜和承担测试按钮点击后的后果。所以为了更好帮助用户理解按钮，以下三种元素可以解决你的问题：文字，图标和标签。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;文字&lt;/strong&gt;&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;按钮上的文字简明扼要，有助于用户高效获取信息，确保友好的用户体验。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/139239/201912/139239-20191227084415543-436737521.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p class=&quot;hd&quot;&gt;如上图，对于同一问题，不同用户可能会对“是”和“不是”有不同的判断。在选项中使用适当的描述，而不是单纯的“是”和“否”，能确保用户避免误解获得更好的用户体验。&lt;/p&gt;
&lt;p class=&quot;hd&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/139239/201912/139239-20191227084424983-1402221234.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p class=&quot;hd&quot;&gt;再例如上图，不用“是”和“否”， “移除”选项就足够的清晰明了。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;图标&lt;/strong&gt;&lt;/h2&gt;
&lt;p class=&quot;hd&quot;&gt;图标是一种常见的&lt;span lang=&quot;EN-US&quot;&gt;UI元素，它简洁而清晰地以可视化的形式呈现按钮功能。用户可以一目了然地分辨出各种按钮的用途。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;hd&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/139239/201912/139239-20191227084434433-1777194623.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h2&gt;&lt;strong&gt;标签&lt;/strong&gt;&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;对于具有特定或复杂功能的按钮，需要给按钮设置上标签，以简要说明其功能。显示方式为，当光标悬停在按钮上时出现。&lt;/p&gt;
&lt;p class=&quot;hd&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/139239/201912/139239-20191227084445144-422699710.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/139239/201912/139239-20191227084450399-1915112063.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p class=&quot;hd&quot;&gt;按钮在任何交互系统中都是至关重要的。因此，按钮的设计的好坏直接影响用户的体验和操作的，为能正确引导我们的用户，我们可以：&lt;/p&gt;
&lt;p class=&quot;hd&quot;&gt;l  按钮的设计富有层次&lt;/p&gt;
&lt;p class=&quot;hd&quot;&gt;l  让按钮在页面中再醒目一点&lt;/p&gt;
&lt;p class=&quot;hd&quot;&gt;l  不要让用户去猜按钮的用途&lt;/p&gt;
&lt;p class=&quot;hd&quot;&gt;在各种场景下都应该要精心为用户设计按钮，让用户找到自己需要的按钮，直观地做出选择。&lt;/p&gt;
&lt;p class=&quot;hd&quot;&gt;那么，希望这篇文章能有所帮助。请随意分享这篇文章。&lt;/p&gt;

</description>
<pubDate>Fri, 27 Dec 2019 00:48:00 +0000</pubDate>
<dc:creator>葡萄城技术团队</dc:creator>
<og:description>转载请注明出处：葡萄城官网，葡萄城为开发者提供专业的开发工具、解决方案和服务，赋能开发者。 原文出处：https://blog.bitsrc.io/do-your-buttons-lead-or-mi</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/powertoolsteam/p/12105462.html</dc:identifier>
</item>
<item>
<title>小白学 Python 爬虫（28）：自动化测试框架 Selenium 从入门到放弃（下） - 极客挖掘机</title>
<link>http://www.cnblogs.com/babycomeon/p/12105449.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/babycomeon/p/12105449.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201912/908359-20191227084427738-699498089.jpg&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;人生苦短，我用 Python&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前文传送门：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/13/3303836941/&quot;&gt;小白学 Python 爬虫（1）：开篇&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/20/2586166930/&quot;&gt;小白学 Python 爬虫（2）：前置准备（一）基本类库的安装&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/21/1005563697/&quot;&gt;小白学 Python 爬虫（3）：前置准备（二）Linux基础入门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/22/3679472340/&quot;&gt;小白学 Python 爬虫（4）：前置准备（三）Docker基础入门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/24/334078215/&quot;&gt;小白学 Python 爬虫（5）：前置准备（四）数据库基础&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/25/1881661601/&quot;&gt;小白学 Python 爬虫（6）：前置准备（五）爬虫框架的安装&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/26/1197821400/&quot;&gt;小白学 Python 爬虫（7）：HTTP 基础&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/27/101847406/&quot;&gt;小白学 Python 爬虫（8）：网页基础&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/28/1668465912/&quot;&gt;小白学 Python 爬虫（9）：爬虫基础&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/12/01/2475257648/&quot;&gt;小白学 Python 爬虫（10）：Session 和 Cookies&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/12/02/2333822325/&quot;&gt;小白学 Python 爬虫（11）：urllib 基础使用（一）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/12/03/819896244/&quot;&gt;小白学 Python 爬虫（12）：urllib 基础使用（二）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/12/04/2992515886/&quot;&gt;小白学 Python 爬虫（13）：urllib 基础使用（三）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/12/05/104488944/&quot;&gt;小白学 Python 爬虫（14）：urllib 基础使用（四）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/12/07/2788855167/&quot;&gt;小白学 Python 爬虫（15）：urllib 基础使用（五）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/12/09/1691033431/&quot;&gt;小白学 Python 爬虫（16）：urllib 实战之爬取妹子图&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/12/10/1910005577/&quot;&gt;小白学 Python 爬虫（17）：Requests 基础使用&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/12/11/1468953802/&quot;&gt;小白学 Python 爬虫（18）：Requests 进阶操作&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/12/12/3568648672/&quot;&gt;小白学 Python 爬虫（19）：Xpath 基操&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/12/13/2569867940/&quot;&gt;小白学 Python 爬虫（20）：Xpath 进阶&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/12/15/2789385418/&quot;&gt;小白学 Python 爬虫（21）：解析库 Beautiful Soup（上）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/12/16/876770087/&quot;&gt;小白学 Python 爬虫（22）：解析库 Beautiful Soup（下）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/12/17/876770088/&quot;&gt;小白学 Python 爬虫（23）：解析库 pyquery 入门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/12/18/1275791678/&quot;&gt;小白学 Python 爬虫（24）：2019 豆瓣电影排行&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/12/19/1066903974/&quot;&gt;小白学 Python 爬虫（25）：爬取股票信息&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/12/20/788803015/&quot;&gt;小白学 Python 爬虫（26）：为啥买不起上海二手房你都买不起&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/12/22/151891020/&quot;&gt;小白学 Python 爬虫（27）：自动化测试框架 Selenium 从入门到放弃（一）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201912/908359-20191227084427975-1283503945.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;ajax&quot;&gt;AJAX&lt;/h2&gt;
&lt;p&gt;在介绍交互之前，我们先简单了解一下新名词：AJAX 。&lt;/p&gt;
&lt;p&gt;AJAX 全写为 “Asynchronous Javascript And XML” （异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。&lt;/p&gt;
&lt;p&gt;AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。&lt;/p&gt;
&lt;p&gt;重点来了，我们如果在网站中使用 AJAX ，可以在整个网页不刷新的情况下，更够更新网页上的显示信息（DOM 节点），也就是 DOM 节点，这种技术被广泛的应用到各个网站之中，最开始的时候，大家都只是使用它更新部分的网页，也不知道是哪位大佬异想天开：既然 AJAX 可以更新部分网页，那么能不能用它来更新全部网页呢？这就产生了现代的前端框架：React 、 Vue 和 Angular。&lt;/p&gt;
&lt;p&gt;这种思想，现在被更加广泛的应用于各大网站之中，因为这种方式，前端页面上只有最基础的 DOM 节点，其余所有的 DOM 节点都是由 JavaScript 动态渲染出来的，而 JavaScript 都是经过打包处理的，可读性极差。&lt;/p&gt;
&lt;p&gt;那么为什么要选用前端框架呢？ HTML + CSS + JQuery 就不行么？&lt;/p&gt;
&lt;p&gt;当然不是，其实之所以现在我们需要选择框架，本质上是因为我们面临的需求变了。大家肯定都明白如果我们只写一个纯展示信息的页面，没有任何交互功能的页面，其实即便是现在，我们也是不需要选择框架的，我们只需要写几行 CSS 和 HTML 就可以完成任务。&lt;/p&gt;
&lt;p&gt;所以是因为我们面临的需求变得复杂了，我们的应用经常需要在运行时做一些交互。&lt;/p&gt;
&lt;p&gt;现代的前端开发，我们开发的应用经常需要在运行时来做一些交互，这些交互在早期只是个幻灯片或者 Tab 切换下拉菜单等一些简单的交互，这些交互用 JQuery 实现完全没什么问题。但现代的前端我们的目标是用 Web 去 PK 原生应用，去和 Native 进行 PK 。&lt;/p&gt;
&lt;p&gt;emmmmmmmmm，聊偏了，下面我们接着聊 Selenium 。&lt;/p&gt;
&lt;h2 id=&quot;等待&quot;&gt;等待&lt;/h2&gt;
&lt;p&gt;如今，大多数 Web 应用程序都在使用 AJAX 技术。当浏览器加载页面时，该页面中的元素可能会以不同的时间间隔加载。这使定位元素变得困难：如果 DOM 中尚不存在元素，则定位函数将引发 ElementNotVisibleException 异常。使用等待，我们可以解决此问题。等待在执行的动作之间提供了一定的松弛时间-主要是定位元素或对该元素进行的任何其他操作。&lt;/p&gt;
&lt;p&gt;Selenium Webdriver 提供两种类型的等待-隐式和显式。显式等待使 WebDriver 等待特定条件发生，然后再继续执行。隐式等待使 WebDriver 在尝试查找元素时轮询DOM一定时间。&lt;/p&gt;
&lt;h3 id=&quot;显式等待&quot;&gt;显式等待&lt;/h3&gt;
&lt;p&gt;我们可以使用 &lt;code&gt;time.sleep()&lt;/code&gt; 来设定等待时间，完全没有问题，但是它需要将条件设置为要等待的确切时间段。如果我们不知道准确的渲染时间，我们就无法设定一个比较合适的值。&lt;/p&gt;
&lt;p&gt;Selenium 为我们提供了 WebDriverWait 与 ExpectedCondition 来完成这件事情，看代码：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

driver = webdriver.Chrome()

driver.get(&quot;https://www.jd.com/&quot;)
try:
    element = WebDriverWait(driver, 10).until(
        EC.presence_of_element_located((By.ID, &quot;key&quot;))
    )
finally:
    driver.quit()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;&amp;lt;selenium.webdriver.remote.webelement.WebElement (session=&quot;b1baacca997d18d7d54447127c844d15&quot;, element=&quot;a472369e-3196-4456-b43e-4e1b280bf5b9&quot;)&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面我们使用了 WebDriverWait 来设置最长等待时间，这里我们选择获取 JD 首页的输入框，我们限定的等待时间为 10s ，如果它在 10s 内都无法返回结果，将会抛出 TimeoutException 。默认情况下， WebDriverWait 每 500 毫秒调用 ExpectedCondition ，直到成功返回。&lt;/p&gt;
&lt;h3 id=&quot;隐式等待&quot;&gt;隐式等待&lt;/h3&gt;
&lt;p&gt;隐式等待告诉 WebDriver 在尝试查找不立即可用的一个或多个元素时在一定时间内轮询 DOM 。默认设置为 0 。设置后，将在 WebDriver 对象的生存期内设置隐式等待。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from selenium import webdriver

driver = webdriver.Chrome()

driver.implicitly_wait(10) # seconds
driver.get(&quot;https://www.jd.com/&quot;)
key = driver.find_element_by_id(&quot;key&quot;)

print(key)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;节点交互&quot;&gt;节点交互&lt;/h2&gt;
&lt;p&gt;Selenium 为我们提供了一些节点的交互动作，如输入文字时可以用 &lt;code&gt;send_keys()&lt;/code&gt; 方法，清空文字时可以用 &lt;code&gt;clear()&lt;/code&gt; 方法，点击按钮时可以用 &lt;code&gt;click()&lt;/code&gt; 方法。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from selenium import webdriver
import time

driver = webdriver.Chrome()
driver.implicitly_wait(10)
driver.get('https://www.taobao.com/')
input = driver.find_element_by_id('q')
input.send_keys('IPad')
time.sleep(1)
input.clear()
input.send_keys('Surface Pro')
button = driver.find_element_by_class_name('btn-search')
button.click()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上面这个示例中，我们先打开淘宝网，并且开启了隐式等待，先在搜索框中输入了 IPad ，在等待 1s 后删除，再输入了 Surface Pro ，然后点击了搜索按钮，先在淘宝搜索需要用户登录才能搜索，所以我们直接跳转到了登录页。&lt;/p&gt;
&lt;h2 id=&quot;执行-javascript&quot;&gt;执行 JavaScript&lt;/h2&gt;
&lt;p&gt;对于某些 Selenium API 没有提供的操作，我们可以通过模拟运行 JavaScript 的方式来完成，用到的方法是 &lt;code&gt;execute_script()&lt;/code&gt; ，比如我们在淘宝首页将滚动条滑到底部：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from selenium import webdriver

driver = webdriver.Chrome()
driver.get('https://www.taobao.com/')
driver.execute_script('window.scrollTo(0, document.body.scrollHeight)')&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;获取信息&quot;&gt;获取信息&lt;/h2&gt;
&lt;p&gt;前面我们介绍了如何拿到 DOM 节点，那么最重要的是我们要从 DOM 节点上来获取我们需要的信息。&lt;/p&gt;
&lt;p&gt;因为我们获取的是 WebElement 类型，而 WebElement 也提供了相关的方法来提取节点信息。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from selenium import webdriver
from selenium.webdriver.chrome.options import Options

# 实例化一个启动参数对象
chrome_options = Options()
# 设置浏览器窗口大小
chrome_options.add_argument('--window-size=1366, 768')
# 启动浏览器
driver = webdriver.Chrome(chrome_options=chrome_options)
url = 'https://www.geekdigging.com/'
driver.get(url)
title = driver.find_element_by_xpath('//*[@id=&quot;text-4&quot;]/div/div/div[1]/div[2]/a')
print(title)
# 获取属性信息
print(title.get_attribute('href'))
# 获取文本信息
print(title.text)
# 获取位置
print(title.location)
# 获取大小
print(title.size)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面因为 Chrome 默认打开大小有点小，打开小编博客的时候小编选择的这个 DOM 节点正好看到，所以小编设置了一下 Chrome 浏览器打开时的大小。&lt;/p&gt;
&lt;p&gt;具体信息的提取小编列出了一部分，都加好注释了，还有一部分比较有意思的属性小编列在下面，供大家参考：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;parent：查找到此元素的WebDriver实例的内部引用。&lt;/li&gt;
&lt;li&gt;rect：具有元素大小和位置的字典。&lt;/li&gt;
&lt;li&gt;screenshot_as_base64：以 base64 编码字符串的形式获取当前元素的屏幕快照。&lt;/li&gt;
&lt;li&gt;screenshot_as_png：以二进制数据获取当前元素的屏幕截图。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;最后这两个获取元素屏幕快照，在获取验证码的时候将验证码截取出来会很好用的。&lt;/p&gt;
&lt;h2 id=&quot;前进和后退&quot;&gt;前进和后退&lt;/h2&gt;
&lt;p&gt;我们使用浏览器最上面的地方有一个前进和后退按钮，Selenium 完成这两个动作使用了 &lt;code&gt;back()&lt;/code&gt; 和 &lt;code&gt;forward()&lt;/code&gt; 这两个方法。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import time
from selenium import webdriver

browser = webdriver.Chrome()
browser.get('https://www.jd.com/')
browser.get('https://www.taobao.com/')
browser.get('https://www.geekdigging.com/')
browser.back()
time.sleep(1)
browser.forward()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个各位同学应该都看的懂，小编就不多啰嗦了。&lt;/p&gt;
&lt;h2 id=&quot;cookies&quot;&gt;Cookies&lt;/h2&gt;
&lt;p&gt;又到了一个重点内容， Cookies ，它是和服务端保持会话的一个重要元素。 Selenium 为我们提供了一些方法，让我们可以方便的对 Cookies 进行增删改查等操作。示例如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from selenium import webdriver

browser = webdriver.Chrome()
browser.get('https://www.geekdigging.com/')
# 获取 cookies
print(browser.get_cookies())
# 添加一个 cookie
browser.add_cookie({'name': 'name', 'domain': 'www.geekdigging.com', 'value': 'geekdigging'})
print(browser.get_cookies())
# 删除所有 cookie
browser.delete_all_cookies()
print(browser.get_cookies())&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Selenium 的简单介绍就到这里了，希望各位同学看完后能自己动手试一试，毕竟并不难。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201912/908359-20191227084428526-1875913960.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;示例代码&quot;&gt;示例代码&lt;/h2&gt;
&lt;p&gt;本系列的所有代码小编都会放在代码管理仓库 Github 和 Gitee 上，方便大家取用。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/meteor1993/python-learning/tree/master/python-spider/selenium-demo&quot; title=&quot;示例代码-Github&quot;&gt;示例代码-Github&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/inwsy/python-learning/tree/master/python-spider/selenium-demo&quot; title=&quot;示例代码-Gitee&quot;&gt;示例代码-Gitee&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;p&gt;https://blog.csdn.net/caoxuecheng001/article/details/81290643&lt;/p&gt;
&lt;p&gt;https://www.jianshu.com/p/02af89375b54&lt;/p&gt;
&lt;p&gt;https://cuiqingcai.com/5630.html&lt;/p&gt;
</description>
<pubDate>Fri, 27 Dec 2019 00:44:00 +0000</pubDate>
<dc:creator>极客挖掘机</dc:creator>
<og:description>人生苦短，我用 Python 前文传送门： &amp;quot;小白学 Python 爬虫（1）：开篇&amp;quot; &amp;quot;小白学 Python 爬虫（2）：前置准备（一）基本类库的安装&amp;quot; &amp;q</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/babycomeon/p/12105449.html</dc:identifier>
</item>
<item>
<title>MySQL基础篇(02)：从五个维度出发，审视表结构设计 - 知了一笑</title>
<link>http://www.cnblogs.com/cicada-smile/p/12105387.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cicada-smile/p/12105387.html</guid>
<description>&lt;blockquote readability=&quot;1.8269230769231&quot;&gt;
&lt;p&gt;本文源码：&lt;a href=&quot;https://github.com/cicadasmile/mysql-data-base&quot;&gt;GitHub·点这里&lt;/a&gt; || &lt;a href=&quot;https://github.com/cicadasmile/mysql-data-base&quot;&gt;GitEE·点这里&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;表结构简介&quot;&gt;1、表结构简介&lt;/h2&gt;
&lt;p&gt;任何工具类的东西都是为了解决某个场景下的问题，比如Redis缓存系统热点数据，ClickHouse解决海量数据的实时分析，MySQL关系型数据库存储结构化数据。数据的存储则需要设计对应的表结构，清楚的表结构，有助于快速开发业务，和理解系统。表结构的设计通常从下面几个方面考虑：业务场景、设计规范、表结构、字段属性、数据管理。&lt;/p&gt;
&lt;h2 id=&quot;用户场景&quot;&gt;2、用户场景&lt;/h2&gt;
&lt;p&gt;例如存储用户基础信息数据，通常都会下面几个相关表结构：用户信息表、单点登录表、状态管理表、支付账户表等。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;用户信息表&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;存储用户三要素相关信息：姓名，手机号，身份证，登录密码，邮箱等。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;CREATE TABLE `ms_user_center` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '用户ID',
  `user_name` varchar(20) NOT NULL COMMENT '用户名',
  `real_name` varchar(20) DEFAULT NULL COMMENT '真实姓名',
  `pass_word` varchar(32) NOT NULL COMMENT '密码',
  `phone` varchar(20) NOT NULL COMMENT '手机号',
  `email` varchar(32) DEFAULT NULL COMMENT '邮箱',
  `head_url` varchar(100) DEFAULT NULL COMMENT '用户头像URL',
  `card_id` varchar(32) DEFAULT NULL COMMENT '身份证号',
  `user_sex` int(1) DEFAULT '1' COMMENT '用户性别:0-女,1-男',
  `create_time` datetime DEFAULT NULL COMMENT '创建时间',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  `state` int(1) DEFAULT '1' COMMENT '是否可用,0-不可用,1-可用',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='用户表';&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;单点登录表&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;用意是在多个业务系统中，用户登录一次就可以访问所有相互信任的业务子系统，是聚合业务平台常用的解决方案。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;CREATE TABLE `ms_user_sso` (
  `user_id` int(11) NOT NULL COMMENT '用户ID',
  `sso_id` varchar(32) NOT NULL COMMENT '单点信息编号ID',
  `sso_code` varchar(32) NOT NULL COMMENT '单点登录码,唯一核心标识',
  `log_ip` varchar(32) DEFAULT NULL COMMENT '登录IP地址',
  `create_time` datetime DEFAULT NULL COMMENT '创建时间',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  `state` int(1) DEFAULT '1' COMMENT '是否可用,0-不可用,1-可用',
  PRIMARY KEY (`user_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='用户单点登录表';&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;状态管理表&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;系统用户在使用时候可能出现多个状态，例如账户冻结、密码锁定等，把状态聚合到一起，可以更加方便的管理和验证。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;CREATE TABLE `ms_user_status` (
  `user_id` int(11) NOT NULL COMMENT '用户ID',
  `account_status` int(1) DEFAULT '1' COMMENT '账户状态：0-冻结,1-未冻结',
  `real_name_status` int(1) DEFAULT '0' COMMENT '实名认证状态：0-未实名,1-已实名',
  `pay_pass_status` int(1) DEFAULT '0' COMMENT '支付密码是否设置：0-未设置,1-设置',
  `wallet_pass_status` int(1) DEFAULT '0' COMMENT '钱包密码是否设置：0-未设置,1-设置',
  `wallet_status` int(1) DEFAULT '1' COMMENT '钱包是否冻结:0-冻结,1-未冻结',
  `email_status` int(1) DEFAULT '0' COMMENT '邮箱状态:0-未激活,1-激活',
  `message_status` int(1) DEFAULT '1' COMMENT '短信提醒开启：0-未开启,1-开启',
  `letter_status` int(1) DEFAULT '1' COMMENT '站内信提醒开启：0-未开启,1-开启',
  `emailmsg_status` int(1) DEFAULT '0' COMMENT '邮件提醒开启：0-未开启,1-开启',
  `create_time` datetime DEFAULT NULL COMMENT '创建时间',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  `state` int(1) DEFAULT '1' COMMENT '是否可用,0-不可用,1-可用',
  PRIMARY KEY (`user_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='用户状态表';&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;支付账户表&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;用户交易的核心表，存储用户相关的账户资金信息。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;CREATE TABLE `ms_user_wallet` (
  `wallet_id` int(11) NOT NULL AUTO_INCREMENT COMMENT '钱包ID',
  `user_id` int(11) NOT NULL COMMENT '用户ID',
  `wallet_pwd` varchar(32) DEFAULT NULL COMMENT '钱包密码',
  `total_account` decimal(20,2) DEFAULT '0.00' COMMENT '账户总额',
  `usable_money` decimal(20,2) DEFAULT '0.00' COMMENT '可用余额',
  `freeze_money` decimal(20,2) DEFAULT '0.00' COMMENT '冻结金额',
  `freeze_time` datetime DEFAULT NULL COMMENT '冻结时间',
  `thaw_time` datetime DEFAULT NULL COMMENT '解冻时间',
  `create_time` datetime DEFAULT NULL COMMENT '创建时间',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  `state` int(1) DEFAULT '1' COMMENT '是否可用,0-不可用,1-可用',
  PRIMARY KEY (`wallet_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='用户钱包';&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;涉及模块&quot;&gt;1、涉及模块&lt;/h2&gt;
&lt;p&gt;通过上面几个表设计的案例，可以看到表设计关联到数据库的各个方面知识：数据类型，索引，编码，存储引擎等。表设计是一个很大的命题，不过也遵循一个基本规范：三范式。&lt;/p&gt;
&lt;h2 id=&quot;三范式&quot;&gt;2、三范式&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;基础概念&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;一范式&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;表的列的具有原子性,不可再分解，即列的信息，不能分解,关系型数据库MySQL、Oracle等自动的满足。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;二范式&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;每个事实的数据记录只会出现一次, 不会冗余, 通常设计一个主键来实现。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;三范式&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;要求一个表中不包含已经存在于其它表的非主键信息，例如部门和员工的信息，员工表包含部门表的主键ID，则可以关联获取相关信息，没必要在员工表保存相关信息。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;优缺点对比&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;范式化设计&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;范式化结构设计通常更新快，因为冗余数据较少，表结构轻巧，也更好的写入内存中。但是查询起来涉及到关联，代价非常高，非常损耗查询性能。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;反范式化设计&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;所有的数据都在一张表中，避免关联查询，索引的有效性更高，但是数据的冗余性极高。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;建议结论&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上述的两种设计方式在实际开发中都是不存在的，在实际开发中都是混合使用。比如汇总统计，缓存数据，都会基于反范式化的设计。&lt;/p&gt;

&lt;p&gt;合适的字段类型对于高性能来说非常重要，基本原则如下：简单的类型占用资源更少；在可以正确存储数据的情况下，选最小的数据类型。&lt;/p&gt;
&lt;h2 id=&quot;数据类型选择&quot;&gt;1、数据类型选择&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;整数类型&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，根据数据类型范围合理选择即可。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;实数类型&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;FLOAT、DOUBLE、DECIMAL，建议资金货币相关类型使用高精度DECIMAL存储，或者把数据成倍扩大为整数，采用BIGINT存储，不过处理相对麻烦。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;字符类型&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;CHAR、VARCHAR，长度不确定建议采用VARCHAR存储，不过VARCHAR类型需要额外开销记录字符串长度。CHAR适合存储短字符，或者定长字符串，例如MD5的加密结构。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;时间类型&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;DATETIME、TIMESTAMP，DATETIME保存大范围的值，精度秒。TIMESTAMP以时间戳的格式，范围相对较小，效率也相对较高，所以通常情况建议使用。&lt;/p&gt;
&lt;p&gt;MySQL的字段类型有很多种，可以根据数据特性选择合适的，这里只描述常见的几种类型。&lt;/p&gt;
&lt;h2 id=&quot;基础用法操作&quot;&gt;2、基础用法操作&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;数据类型&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;修改字段类型&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;ALTER TABLE ms_user_sso MODIFY state CHAR(1) DEFAULT '0' ;

ALTER TABLE ms_user_sso 
MODIFY state INT(1) DEFAULT '1' COMMENT '状态：0不可用,1可用';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;修改名称位置&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;ALTER TABLE ms_user_sso 
CHANGE log_ip login_ip VARCHAR(32) AFTER update_time ;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;索引使用&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;索引类型：主键索引，普通索引，唯一索引，组合索引，全文索引。这里演示普通索引的操作。MySQL的核心模块，后续详说。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;添加索引&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;ALTER TABLE ms_user_wallet ADD INDEX user_id_index(user_id) ;
CREATE INDEX state_index ON ms_user_wallet(state) ;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;查看索引&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;SHOW INDEX FROM ms_user_wallet;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;删除索引&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;DROP INDEX state_index ON ms_user_wallet ;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;修改索引&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;不具有真正意义上的修改，可以把原有的索引删除之后，再次添加索引。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;外键关联&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;用处：外键关联的作用保证多个数据表的数据一致性和完整性，建表时先有主表，后有从表；删除数据表，需要先删从表，再删主表。复杂场景不建议使用，实际开发中用的也不多。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;添加外键&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;ALTER TABLE ms_user_wallet 
ADD CONSTRAINT user_id_out_key FOREIGN KEY(user_id) REFERENCES ms_user_center(id) ;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;删除外键&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;ALTER TABLE ms_user_wallet DROP FOREIGN KEY user_id_out_key ;&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;查看结构&quot;&gt;1、查看结构&lt;/h2&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;DESC ms_user_status ;
SHOW CREATE TABLE ms_user_status ;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;字段结构&quot;&gt;2、字段结构&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;添加字段&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;ALTER TABLE ms_user_status 
ADD `delete_time` datetime DEFAULT NULL COMMENT '删除时间' ;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;删除字段&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;ALTER TABLE ms_user_status DROP COLUMN delete_time ;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;修改表名&quot;&gt;3、修改表名&lt;/h2&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;ALTER TABLE ms_user_center RENAME ms_user_info ;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;存储引擎&quot;&gt;4、存储引擎&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;存储引擎&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;SELECT VERSION() ; SHOW ENGINES ;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;MySQL 5.6 支持的存储引擎有InnoDB、MyISAM、Memory、Archive、CSV、BLACKHOLE等。一般默认使用InnoDB，支持事务管理。该模块MySQL核心，后续详解。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;修改引擎&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;数据量大的场景下，存储引擎修改是一个难度极大的操作，容易会导致表的特性变动，引起各种后续反应，后续会详说。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;ALTER TABLE ms_user_sso ENGINE = MyISAM ;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;修改编码&quot;&gt;5、修改编码&lt;/h2&gt;
&lt;p&gt;表字符集默认使用utf8，通用，无乱码风险，汉字3字节，英文1字节，utf8mb4是utf8的超集，有存储4字节例如表情符号时使用。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;查看编码&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;SHOW VARIABLES LIKE 'character%';&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;修改编码&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;ALTER TABLE ms_user_sso DEFAULT CHARACTER SET utf8mb4; &lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;增删改查&quot;&gt;1、增删改查&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;添加数据&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;INSERT INTO ms_user_sso (
    user_id,sso_id,sso_code,create_time,update_time,login_ip,state
)
VALUES
    (
        '1','SSO7637267','SSO78631273612',
        '2019-12-24 11:56:57','2019-12-24 11:57:01','127.0.0.1','1'
    );&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;更新数据&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;UPDATE ms_user_sso SET 
 user_id = '1',sso_id = 'SSO20191224',sso_code = 'SSO20191224',
 create_time = '2019-11-24 11:56:57',update_time = '2019-11-24 11:57:01',
 login_ip = '127.0.0.1',state = '1'
WHERE user_id = '1';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;查询数据&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;一般情况下都是禁止使用 select* 操作。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;SELECT user_id,sso_id,sso_code,create_time,update_time,login_ip,state 
FROM ms_user_sso WHERE user_id = '1';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;删除数据&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;DELETE FROM ms_user_sso WHERE user_id = '2' ;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不带where条件，就是删除全部数据。原则上不允许该操作，优化篇会详解。&lt;code&gt;TRUNCATE TABLE&lt;/code&gt;也是清空表数据，但是占用的资源相对较少。&lt;/p&gt;
&lt;h2 id=&quot;数据安全&quot;&gt;2、数据安全&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;不可逆加密&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这类加密算法，多用来做数据验证操作，比如常见的密码验证。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;SELECT MD5('cicada')='94454b1241ad2cfbd0c44efda1b6b6ba' ;
SELECT SHA('cicada')='0501746a2e4fd34e1d14015fc4d58309585edc7d';
SELECT PASSWORD('smile')='*B4FB95D86DCFC3F33A3852714DC742C77504479D' ;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;可逆加密&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;安全性要求高的系统，需要做三级等保，对数据的安全性极高，数据在存储时必须加密入库，取出时候需要解密，这些就需要可逆加密。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;SELECT DECODE(ENCODE('123456','key_salt'),'key_salt') ;
SELECT AES_DECRYPT(AES_ENCRYPT('cicada','salt123'),'salt123');&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述数据安全的管理，也可以基于应用系统的服务(代码)层进行处理，相对专业的流程是从数据生成源头处理，规避数据传递过程泄露，造成不必要的风险。&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;GitHub·地址
https://github.com/cicadasmile/mysql-data-base
GitEE·地址
https://gitee.com/cicadasmile/mysql-data-base&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1691717/201908/1691717-20190823075428183-1996768914.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 26 Dec 2019 23:56:00 +0000</pubDate>
<dc:creator>知了一笑</dc:creator>
<og:description>本文源码： &amp;quot;GitHub&amp;#183;点这里&amp;quot; || &amp;quot;GitEE&amp;#183;点这里&amp;quot; 一、数据场景 1、表结构简介 任何工具类的东西都是为了解决某个场景下的问</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cicada-smile/p/12105387.html</dc:identifier>
</item>
<item>
<title>深入剖析Windows专业版安装Docker引擎和Windows家庭版Docker引擎安装的区别 - Dearzh</title>
<link>http://www.cnblogs.com/zh94/p/12104427.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zh94/p/12104427.html</guid>
<description>&lt;p&gt;原创声明：作者：Arnold.zhao  博客园地址：&lt;a href=&quot;https://www.cnblogs.com/zh94&quot;&gt;https://www.cnblogs.com/zh94&lt;/a&gt; &lt;/p&gt;

&lt;p&gt; Windows专业版上安装Docker时，本质上是借助于Windows平台的hyper-v技术来创建一个Linux虚拟机，你所输入的所有的命令，都是借助于虚拟机中所部署的Docker引擎（服务端）进行执行的，所有Pull到本地的镜像数据，都是存储到对应的虚拟机目录里面；&lt;/p&gt;
&lt;p&gt;而这其实也恰恰符合Docker的作风，毕竟Docker在运行时分为Docker引擎（也就是服务端守护进程）和客户端工具，而我们每次敲下的Docker命令，实际上是通过Docker引擎（服务端）所提供的一组REST API来进行的交互，表面上来看我们是在和本机执行各种docker操作，而实际上一切都是在通过远程调用的方式来实现的；正是基于Docker的这种 C/S架构，Docker才可以在各种系统上无缝的运行，其在Windows上之所以能够运行的原理也是这样的；&lt;/p&gt;
&lt;p&gt;Windows本身先虚拟化一个Linux服务器，而Docker引擎的服务端，实际上就是安装于本地的Windows的Linux虚拟机上！而我们每次通过本地的PowerShell或者CMD也好，本质上也只是把所输入的docker 命令，通过https的方式发送到了我们本机的虚拟机上才产生了一系列的交互；&lt;/p&gt;
&lt;p&gt;但实际上，Docker引擎服务还是只能运行在Linux上，之所以能在Winidows本机运行，是因为Windows本机也安装了对应的Linux虚拟机程序；所以！这其中Docker是在Windows专业版上运行，还是在Windows家庭版上运行，唯一的区别和变量就是，虚拟机！这也是Windows家庭版和专业版唯一的区别所在了；&lt;/p&gt;
&lt;p&gt;由于Windows专业版上具备Hyper-V技术（windows自身的虚拟机技术），所以只要开启对应的Hyper-v后，再进行一系列的安装，便可以在Windows本地使用Docker了；而Windows家庭版是不具备Hyper-V的，所以如果要在家庭版上进行Docker的安装，其首先也需要先部署一个Linux的虚拟机程序才行，那么此处则是：Oracle VM VirtualBox（一款开源的虚拟机软件）；&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;上面所对应的阐述是很重要的哦，除了可以理解windows专业版和家庭版安装的区别，实际上更是对Docker服务引擎进一步的熟悉，因为当你理解了Docker Server和对应的Docker Client的关系后，你会发现，实际上我们后续的各种Docker的操作，Dockerfile，docker build .  copy，等都是具备client - server 的思想在里面的；（docker的命令只是客户端！真正的执行则是在Docker的服务端进行的执行）！ &lt;/strong&gt;(^_−)&lt;strong&gt;&lt;strong&gt;☆&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;原创声明：作者：Arnold.zhao  博客园地址：&lt;a href=&quot;https://www.cnblogs.com/zh94&quot;&gt;https://www.cnblogs.com/zh94&lt;/a&gt; &lt;/p&gt;

&lt;p&gt;按照对应的理解：当我们在家庭版上进行docker的安装的时候，对应的安装步骤：&lt;/p&gt;
&lt;p&gt;1、先安装 Oracle VM VritualBox&lt;/p&gt;
&lt;p&gt;2、再进行 Docker Server引擎的部署至对应的虚拟机中，&lt;/p&gt;
&lt;p&gt;3、再进行本地Windows的安装（此时的安装是将对应的Docker命令进行本地Windows的安装）使其CMD，PowerShell也好等客户端，可以识别出对应的Docker命令规范，使其在客户端执行对应的命令时，可以进行对应的识别，并将对应的命令及信息通过https发送到对应的Docker引擎上；&lt;/p&gt;
&lt;p&gt;那么我们真正的安装时，真的是这么麻烦吗？当然不是啦，真正安装时，我们只需要下载一个对应的安装包，进行无脑next next finish 就行啦；&lt;/p&gt;

&lt;p&gt;那为什么上面还扯这么多呢？&lt;strong&gt;第一：是因为明白上述的安装步骤对后续的使用具备很大的指导意义，第二：当你把所对应的安装包安装完以后，你会发现存在对应的三个应用程序，当然啦！因为一个是虚拟机，一个是客户端！一个是GUI啦！所以，在明确上述的整体过程后，实际上对所安装后所出现的应用就不会感觉到陌生了；&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Windows Docker家庭版安装包下载地址：http://mirrors.aliyun.com/docker-toolbox/windows/docker-toolbox/ （选择最新的进行下载就好啦，阿里的服务器，应该是在持续的维护当中的）&lt;/p&gt;
&lt;p&gt;安装过程中，你可能会出现一些问题，当然，每个人都会在安装的时候出现一些问题，甚至于每个人的问题应该都不一样，不过此处还是推荐一篇文章：如果是第一次安装的话，可以参考下该文章进行解决下对应的Error：&lt;a href=&quot;https://www.cnblogs.com/jimmyshan-study/p/11161428.html&quot;&gt;https://www.cnblogs.com/jimmyshan-study/p/11161428.html&lt;/a&gt;  ，我在进行对应的安装的时候，出现的问题和当前博客中所说明的问题还是不太一样的，不过凭借着基本的一些认知，最终还是顺利安装完成了；&lt;/p&gt;

&lt;p&gt; 安装完成后，一般则是会有三个服务，分别是：Oracle VM VirtualBox，docker-quickstart-terminal，Kitematic.exe，；&lt;/p&gt;
&lt;p&gt;docker-quickstart-terminal.就不用说了，这个就是你启动Docker时的应用程序（不过本人此处docker-quickstart-terminal是无效的）；&lt;/p&gt;
&lt;p&gt;此处重点说明下，对应的Oracle VM VirtualBox 和 Kitematic 应用程序；&lt;/p&gt;

&lt;p&gt;截图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1104472/201912/1104472-20191226204920821-1372779071.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 当你正常进行了docker的安装后，以及可以在cmd等控制台可以正常输出docker --version，此时说明你的Docker 服务端引擎是正常运行的状态，如上图所示，可以看到Oracle VM VirtualBox管理器，包含的&lt;/p&gt;
&lt;p&gt;第一个虚拟机实例 “default” 是不可以被删除的，因为当前 default 的Linux虚拟机实例，便是进行安装包安装时，直接部署进当前VirtualBox的默认实例，（该Linux虚拟机内所部署的Docker引擎会随着虚拟机的启动而自动启动，所以不用担心无法启动Docker引擎的问题，只要能够保证当前虚拟机实例是启动的即可）&lt;/p&gt;

&lt;p&gt;而当我们把当前Linux虚拟机实例进行暂停的时候，则会出现的现象是什么？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1104472/201912/1104472-20191226205533002-1844202349.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; 此处我们将对应的Docker虚拟机进行暂停，此时再进行 docker 的命令，会发现存在异常提示，异常内容如下：HTTPS://IP:PORT 链接没有响应，此处则充分说明了，当前的Docker引擎的实际使用方式，的确是 Client - Server 通过 REST API进行的交互方式！(^_−)&lt;/strong&gt;&lt;strong&gt;☆&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1104472/201912/1104472-20191226210217378-1881795267.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Kitematic是Docker的一款GUI工具，界面很优雅，用着很舒服，只要简单的点点点，就可以实现容器的自启，pull镜像等基本操作，并且可以进行容器的相关配置等功能，界面很暖，使用起来也是很舒服的，详情如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1104472/201912/1104472-20191226210849014-264171361.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;可参考链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/jimmyshan-study/p/11161428.html&quot;&gt;https://www.cnblogs.com/jimmyshan-study/p/11161428.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/brock0624/p/9792203.html&quot;&gt;https://www.cnblogs.com/brock0624/p/9792203.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;原创声明：作者：Arnold.zhao  博客园地址：&lt;a href=&quot;https://www.cnblogs.com/zh94&quot;&gt;https://www.cnblogs.com/zh94&lt;/a&gt; &lt;/p&gt;



</description>
<pubDate>Thu, 26 Dec 2019 23:42:00 +0000</pubDate>
<dc:creator>Dearzh</dc:creator>
<og:description>深入剖析Windows专业版安装Docker引擎和Windows家庭版Docker引擎安装的区别（Windows 专业版Docker引擎安装说明，Windows家庭版Docker引擎安装说明）</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zh94/p/12104427.html</dc:identifier>
</item>
<item>
<title>Elasticsearch系列---初识mapping - 清茶豆奶</title>
<link>http://www.cnblogs.com/huangying2124/p/12105378.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huangying2124/p/12105378.html</guid>
<description>&lt;h3 id=&quot;概要&quot;&gt;概要&lt;/h3&gt;
&lt;p&gt;本篇简单介绍一下field数据类型mapping的相关知识。&lt;/p&gt;
&lt;h3 id=&quot;mapping是什么&quot;&gt;mapping是什么？&lt;/h3&gt;
&lt;p&gt;前面几篇的实战案例，我们向Elasticsearch索引数据时，只是简单地把JSON文本放在请求体里，至于JSON里的field类型，存储到ES里是什么类型，中间是怎么做的映射，这个映射过程，就是mapping要解决的问题。&lt;/p&gt;
&lt;p&gt;mapping简单来说，就是解决JSON文本内容到field类型映射关系的定义。将时间域视为时间类型，数字视为数字类型，字符串识别为全文或精确值字符串，这个识别的过程，叫做mapping。&lt;/p&gt;
&lt;p&gt;Elasticsearch支持的简单域类型，类似于Java的基础数据类型，有如下几种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;字符串：text，keyword&lt;/li&gt;
&lt;li&gt;整数 : byte, short, integer, long&lt;/li&gt;
&lt;li&gt;浮点数: float, double&lt;/li&gt;
&lt;li&gt;布尔型: boolean&lt;/li&gt;
&lt;li&gt;日期: date&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当Elasticsearch收到JSON基本数据类型内容时，使用如下规则进行类型映射：&lt;br/&gt;| JSON type | domain type&lt;br/&gt;| :---- | :--: | -----: |&lt;br/&gt;| 布尔型: true 或者 false | boolean&lt;br/&gt;| 整数: 123 | long&lt;br/&gt;| 浮点数: 123.45 | double&lt;br/&gt;| 日期格式的字符串: 2014-09-15 | date&lt;br/&gt;| 字符串: love you | text&lt;/p&gt;
&lt;h3 id=&quot;查看映射&quot;&gt;查看映射&lt;/h3&gt;
&lt;p&gt;每个索引都可以通过/_mapping查询各个field的映射结果，ES本身有自动mapping的过程，但mapping后的结果一定要仔细检查一下。&lt;/p&gt;
&lt;p&gt;查询请求：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;GET /music/_mapping/children&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;响应结果：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;{
  &quot;music&quot;: {
    &quot;mappings&quot;: {
      &quot;children&quot;: {
        &quot;properties&quot;: {
          &quot;content&quot;: {
            &quot;type&quot;: &quot;text&quot;,
            &quot;fields&quot;: {
              &quot;keyword&quot;: {
                &quot;type&quot;: &quot;keyword&quot;,
                &quot;ignore_above&quot;: 256
              }
            }
          },
          &quot;language&quot;: {
            &quot;type&quot;: &quot;text&quot;,
            &quot;fields&quot;: {
              &quot;keyword&quot;: {
                &quot;type&quot;: &quot;keyword&quot;,
                &quot;ignore_above&quot;: 256
              }
            },
            &quot;fielddata&quot;: true
          },
          &quot;length&quot;: {
            &quot;type&quot;: &quot;long&quot;
          },
          &quot;likes&quot;: {
            &quot;type&quot;: &quot;long&quot;
          },
          &quot;name&quot;: {
            &quot;type&quot;: &quot;text&quot;,
            &quot;fields&quot;: {
              &quot;keyword&quot;: {
                &quot;type&quot;: &quot;keyword&quot;,
                &quot;ignore_above&quot;: 256
              }
            }
          }
        }
      }
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;mapping中就自动定义了每个field的数据类型，properties下面的是各个field字段的名称、类型等信息，text类型的还带一个keyword子field。&lt;/p&gt;
&lt;h3 id=&quot;数据类型的分词规则&quot;&gt;数据类型的分词规则&lt;/h3&gt;
&lt;p&gt;index在建立时或索引数据时，如果没有手动指定mapping信息，Elasticsearch会用它的规则自动为我们创建type信息，以及type对应的mapping，mapping中包含了每个field对应的数据类型，以及如何分词等设置。&lt;/p&gt;
&lt;p&gt;不同类型的field，有的是精确搜索(exact value)，有的是全文搜索(full text)。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;exact value，在建立倒排索引的时候，是将整个值一起作为一个关键词建立到倒排索引中的，并且大小写敏感；&lt;/li&gt;
&lt;li&gt;full text，会经历各种各样的处理，分词，normaliztion（时态转换，同义词转换，大小写转换），才会建立到倒排索引中。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在一个搜索请求过来的时候，对exact value field和full text field进行搜索的会与当初建立倒排索引的行为保持一致；比如说exact value搜索的时候，就是直接按照整个值进行匹配，full text query string，也会进行分词和normalization再去倒排索引中去搜索，这样才能达到预期的搜索效果。&lt;/p&gt;
&lt;p&gt;ES基本的几种field类型，除了text是使用full text，其他的都是exact value，总结来说mapping，决定了数据类型，建立倒排索引的行为，还有进行搜索的行为。&lt;/p&gt;
&lt;h3 id=&quot;自定义映射&quot;&gt;自定义映射&lt;/h3&gt;
&lt;p&gt;基本数据类型基本够用，但是有些数据可能需要自定义映射，尤其是字符串，string类型默认是full text，但是我们可以自己定义分词器，不同的分词器，会带来不一样的搜索效果，string类型最重要的属性是index和analyzer。&lt;/p&gt;
&lt;h4 id=&quot;index&quot;&gt;index&lt;/h4&gt;
&lt;p&gt;这个属性控制字符串的索引规则，有三个值可供选择：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;true：支持索引，并且依据当前类型决定是全文搜索还是精确匹配&lt;/li&gt;
&lt;li&gt;false：不索引&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;例如：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;{
    &quot;author&quot;: {
        &quot;type&quot;:     &quot;text&quot;,
        &quot;index&quot;:    true
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;analyzer&quot;&gt;analyzer&lt;/h4&gt;
&lt;p&gt;这个属性控制字符串使用的分词器，在支持中文的系统里，这个属性经常被用到，各路分词器大显身手，都需要用这个属性来指定，如：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;{
    &quot;content&quot;: {
        &quot;type&quot;:     &quot;text&quot;,
        &quot;analyzer&quot;:    &quot;aliws&quot;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;测试映射&quot;&gt;测试映射&lt;/h3&gt;
&lt;p&gt;我们在建立索引之后，可以通过测试命令来查看不同的field的映射结果，即full text类型的是否有分词， exact value的是否原样保留，text的内容可以随意输入，当把这个作用工具调试时，可以诊断的内容的分词情况，举例如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;full text类型&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;GET /music/_analyze
{
  &quot;field&quot;: &quot;content&quot;,
  &quot;text&quot;: &quot;let me sleep&quot; 
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;{
  &quot;tokens&quot;: [
    {
      &quot;token&quot;: &quot;let&quot;,
      &quot;start_offset&quot;: 0,
      &quot;end_offset&quot;: 3,
      &quot;type&quot;: &quot;&amp;lt;ALPHANUM&amp;gt;&quot;,
      &quot;position&quot;: 0
    },
    {
      &quot;token&quot;: &quot;me&quot;,
      &quot;start_offset&quot;: 4,
      &quot;end_offset&quot;: 6,
      &quot;type&quot;: &quot;&amp;lt;ALPHANUM&amp;gt;&quot;,
      &quot;position&quot;: 1
    },
    {
      &quot;token&quot;: &quot;sleep&quot;,
      &quot;start_offset&quot;: 7,
      &quot;end_offset&quot;: 12,
      &quot;type&quot;: &quot;&amp;lt;ALPHANUM&amp;gt;&quot;,
      &quot;position&quot;: 2
    }
  ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;exact value类型&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;GET /music/_analyze
{
  &quot;field&quot;: &quot;content.keyword&quot;,
  &quot;text&quot;: &quot;let me sleep&quot; 
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;{
  &quot;tokens&quot;: [
    {
      &quot;token&quot;: &quot;let me sleep&quot;,
      &quot;start_offset&quot;: 0,
      &quot;end_offset&quot;: 12,
      &quot;type&quot;: &quot;word&quot;,
      &quot;position&quot;: 0
    }
  ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意一个小细节：Elasticsearch在自动创建text类型时，为full text，但会自动建立一个keywork子field，这个子field是exact value类型的。&lt;/p&gt;
&lt;h3 id=&quot;小结&quot;&gt;小结&lt;/h3&gt;
&lt;p&gt;本篇主要介绍了一个mapping的概念，基础数据类型，以及查看映射信息和测试field映射效果的方法，测试映射效果算是一个比较有用的工具，后期实际开发中，遇到需要诊断的内容，可以用这个工具协助排查问题。&lt;/p&gt;
&lt;p&gt;专注Java高并发、分布式架构，更多技术干货分享与心得，请关注公众号：Java架构社区&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1834889/201912/1834889-20191227071606545-485639896.jpg&quot; alt=&quot;Java架构社区&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 26 Dec 2019 23:16:00 +0000</pubDate>
<dc:creator>清茶豆奶</dc:creator>
<og:description>简单介绍一下field数据类型mapping的相关知识</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/huangying2124/p/12105378.html</dc:identifier>
</item>
<item>
<title>数据库中间件DBLE学习(二) 学习配置schema.xml - BuddyYuan</title>
<link>http://www.cnblogs.com/buddy-yuan/p/12105342.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/buddy-yuan/p/12105342.html</guid>
<description>&lt;h4 id=&quot;前言&quot;&gt;前言&lt;/h4&gt;
&lt;p&gt;一边有一个经常引诱我让我“娱乐至死”的视频，还有一个不停“鞭策“我让我快点学习的大BOSS。正是有这两种&lt;code&gt;极端的爱&lt;/code&gt;才让我常常在自信中明白自己努力的方向。嗯,&quot;人间不值得&quot;！&lt;/p&gt;
&lt;h4 id=&quot;schema.xml介绍&quot;&gt;SCHEMA.XML介绍&lt;/h4&gt;
&lt;p&gt;上一篇写了：数据库中间件DBLE学习(一) 基本介绍和快速搭建，主要介绍快速安装。在安装的过程中，我们配置了schema.xml文件。schema.xml是一个比较重要的文件。该文件提供了&lt;code&gt;逻辑库&lt;/code&gt;，&lt;code&gt;逻辑表&lt;/code&gt;，&lt;code&gt;分片规则&lt;/code&gt;，&lt;code&gt;数据分片&lt;/code&gt;，&lt;code&gt;物理数据库&lt;/code&gt;等配置。它主要有以下几个标签组成。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;schema&lt;/code&gt;标签，主要是&lt;code&gt;逻辑库&lt;/code&gt;和&lt;code&gt;逻辑表&lt;/code&gt;的配置，其中&lt;code&gt;逻辑表&lt;/code&gt;又有多种类型，比如：全局表、分片表、ER分片表、非分片表等。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dataNode&lt;/code&gt;标签，主要定义了数据分片存放的节点，一个dataNode标签往往就对应着一个数据分片。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dataHost&lt;/code&gt;标签，主要定义了物理数据库及主从读写分离的配置。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;实战schema.xml配置&quot;&gt;实战SCHEMA.XML配置&lt;/h4&gt;
&lt;p&gt;接下来我们来实战一下，实战就拿经典PRODUCT表,ORDERS订单表来做实验。前面曾经介绍过&lt;code&gt;逻辑表&lt;/code&gt;拆分可以有很多种类型。首先我们先规划一下，假设我们是一家新的电商公司，在电商平台上卖自家公司生产的商品，我们的商品总共就5-6种，但挡不住客户对我们生产的商品的喜爱，款款都是爆款啊，一经发售订单量就惊人。那么我们怎么来拆分库表呢？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;PRODUCTS产品表，就卖几款爆品，我们要把它做成&lt;code&gt;全局表&lt;/code&gt;。也就是每个分片上都有这个PRODUCTS产品表的数据。这样不会有多大的消耗，毕竟这个表数据量小。也比较方便和分片表进行关联。&lt;/li&gt;
&lt;li&gt;ORDERS订单表，有上千万的订单。这个数据量比较大，我们要把ORDERS表做成&lt;code&gt;分片表&lt;/code&gt;。PRODUCTS产品表和ORDERS表存在一对多的关系。我们可以按照order_id来进行取模分片。这样不会有数据过热的问题，并且&lt;code&gt;产品表&lt;/code&gt;是小表在每个分片上都有，我们能非常方便的使用产品表和订单表进行关联。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;说这么多，不如来张图给大家看一下。&lt;br/&gt;&lt;img src=&quot;https://pic.downk.cc/item/5e04f58f76085c32897b180e.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如图所示，应用直接连接数据库中间件，操作&lt;code&gt;逻辑库&lt;/code&gt;testdb，&lt;code&gt;逻辑表&lt;/code&gt;PRODUCTS和ORDERS。而上述&lt;code&gt;逻辑库&lt;/code&gt;和&lt;code&gt;逻辑表&lt;/code&gt;对应存放在物理数据库主机A和主机B上。MySQL主机A上有分片dn1，MySQL主机B上有分片dn2。dn1上存储了全局表PRODUCTS和按order_id取模的ORDERS表1。dn2上存储了全局表PRODUCTS和按order_id取模的ORDERS表2。&lt;/p&gt;
&lt;p&gt;整个脉络理清了，这是我们的配置环境。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;DBLE服务器&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;192.168.56.185&lt;/td&gt;
&lt;td&gt;DBLE实例，数据库中间件，负责接收SQL进行路由分发&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;MySQL A服务器&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;192.168.56.181&lt;/td&gt;
&lt;td&gt;物理实例A，有db_1数据库&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;MySQL B1服务器主&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;192.168.56.182&lt;/td&gt;
&lt;td&gt;物理实例B，有db_2数据库&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;&lt;strong&gt;MySQL B2服务器从&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;192.168.56.183&lt;/td&gt;
&lt;td&gt;物理实例B的从库&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;物理mysql环境配置&quot;&gt;物理MySQL环境配置&lt;/h4&gt;
&lt;p&gt;安装MySQL服务器A和MySQL服务器B的主从环境。然后在这两套物理数据库上都创建Buddy用户。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;create user 'buddy'@'%' identified by '123456';
GRANT ALL PRIVILEGES ON *.* TO 'buddy'@'%' IDENTIFIED BY '123456';&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;配置schema标签&quot;&gt;配置schema标签&lt;/h4&gt;
&lt;p&gt;进入dble的conf文件夹下配置schema.xml文件。首先咱们配置schema标签。主要配置内容如下：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt; &amp;lt;schema name=&quot;testdb&quot;&amp;gt;
        &amp;lt;!--er tables--&amp;gt;
        &amp;lt;table name=&quot;orders&quot; primaryKey=&quot;order_id&quot; dataNode=&quot;dn1,dn2&quot; rule=&quot;rule_mod&quot;/&amp;gt;
        &amp;lt;!--global  tables--&amp;gt;
        &amp;lt;table name=&quot;products&quot; primaryKey=&quot;product_id&quot; type=&quot;global&quot; dataNode=&quot;dn1,dn2&quot;/&amp;gt;
    &amp;lt;/schema&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li readability=&quot;-2&quot;&gt;
&lt;p&gt;sehama标签&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;对逻辑库的定义，name指定了&lt;code&gt;逻辑库&lt;/code&gt;的名字。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-0.5&quot;&gt;
&lt;p&gt;table标签&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;对表的定义，name指定了表的名字，dataNode指定这张表涉及的数据节点，这里两张表都指定的是dn1,dn2。rule指定了分片的规则，这里是取模算法。如果是全局表需要在type属性列声明为global。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;配置datanode标签&quot;&gt;配置dataNode标签&lt;/h4&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dataNode name=&quot;dn1&quot; dataHost=&quot;dataHost1&quot; database=&quot;db_1&quot;/&amp;gt;
&amp;lt;dataNode name=&quot;dn2&quot; dataHost=&quot;dataHost2&quot; database=&quot;db_2&quot;/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li readability=&quot;-1.5&quot;&gt;
&lt;p&gt;dataNode标签&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;name指定的是数据分片节点名称，dataHost指定对应的数据库实例，database对在mysql物理实例中的schema。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;配置datahost标签&quot;&gt;配置dataHost标签&lt;/h4&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dataHost name=&quot;dataHost1&quot; maxCon=&quot;1000&quot; minCon=&quot;10&quot; balance=&quot;0&quot; switchType=&quot;-1&quot; slaveThreshold=&quot;100&quot;&amp;gt;
    &amp;lt;heartbeat&amp;gt;show slave status&amp;lt;/heartbeat&amp;gt;
    &amp;lt;!-- can have multi write hosts --&amp;gt;
    &amp;lt;writeHost host=&quot;hostM1&quot; url=&quot;192.168.56.181:3306&quot; user=&quot;buddy&quot; password=&quot;buddy&quot;&amp;gt;
    &amp;lt;/writeHost&amp;gt;
&amp;lt;/dataHost&amp;gt;
&amp;lt;dataHost name=&quot;dataHost2&quot; maxCon=&quot;1000&quot; minCon=&quot;10&quot; balance=&quot;0&quot; switchType=&quot;-1&quot; slaveThreshold=&quot;100&quot;&amp;gt;
    &amp;lt;heartbeat&amp;gt;show slave status&amp;lt;/heartbeat&amp;gt;
    &amp;lt;!-- can have multi write hosts --&amp;gt;
    &amp;lt;writeHost host=&quot;hostM2&quot; url=&quot;192.168.56.182:3306&quot; user=&quot;buddy&quot; password=&quot;buddy&quot;&amp;gt;
        &amp;lt;readHost host=&quot;hostS2&quot; url=&quot;192.168.56.183:3306&quot; user=&quot;buddy&quot; password=&quot;buddy&quot;/&amp;gt;
    &amp;lt;/writeHost&amp;gt;
&amp;lt;/dataHost&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li readability=&quot;-0.5&quot;&gt;
&lt;p&gt;dataHost标签&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;指定了数据库实例，这里name代表数据库实例的名称。maxCon定于了最大连接数，minCon定义了空闲时保有的最小连接数。balance是指读取操作的负载均衡模式，为0则不做均衡。switchType代表了写操作的高可用切换类型。等于-1则表示不自动切换。slaveThreshold指定了指定主从延迟的阀值，为100。该配置主要与读数据时的负载均衡有关，它会先取show slave status中的Seconds_Behind_Master值，如果该值大于slaveThreshold，则读取的时候就会过滤掉这个slave。防止读到旧的数据，影响前台的业务。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;
&lt;p&gt;heartbeat标签&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;指定心跳检测，这里心跳检测的语句是show slave status&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;
&lt;p&gt;writeHost标签&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;指定写入节点。host是写节点的名称。url指定写入节点的ip和端口号。user指定写节点数据库的用户名，password指定写节点数据库的密码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;
&lt;p&gt;readHost标签&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;指定读取节点。host是读节点的名称。url指定读取节点的ip和端口号。user指定读节点数据库的用户名，password指定读节点数据库的密码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;启动dble&quot;&gt;启动dble&lt;/h4&gt;
&lt;p&gt;上述配置完成之后，我们就可以启动dble了。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[root@mycat bin]# ./dble start
Starting dble-server...
Removed stale pid file: /dble/dble.pid&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动后查看wrapper日志居然报错了。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;INFO   | jvm 1    | 2019/12/27 00:34:15 | com.actiontech.dble.config.util.ConfigException: Illegal table conf : table [ orders ] rule function [ func_mod ] partition size : 4 &amp;gt; table datanode size : 2, please make sure table datanode size = function partition size&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里报错很明显，主要是这个取模函数默认设置对4取模，大于了我们的dataNode。需要我们在rule.xml中把func_mod函数的partitionCount给改成2.&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;function name=&quot;func_mod&quot; class=&quot;Hash&quot;&amp;gt;
    &amp;lt;property name=&quot;partitionCount&quot;&amp;gt;2&amp;lt;/property&amp;gt;
    &amp;lt;property name=&quot;partitionLength&quot;&amp;gt;1&amp;lt;/property&amp;gt;
&amp;lt;/function&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重新启动dble，能够成功启动。&lt;/p&gt;
&lt;h4 id=&quot;创建分片并验证&quot;&gt;创建分片并验证&lt;/h4&gt;
&lt;p&gt;使用管理端口登录，进行创建datanode的操作。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;[root@mysql5 ~]# mysql -uman1 -p -P9066 -h192.168.56.185 -p654321
mysql&amp;gt; create database @@dataNode='dn$1-2';
Query OK, 1 row affected (0.03 sec)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;分别登录MySQL服务器A和MySQL服务器B查看创建分片的情况。可以看到181上创建了db_1，而182上创建了db_2。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;[root@mysql5 ~]# mysql -ubuddy -p  -h192.168.56.181 -P3306 -p123456 -e &quot;show databases&quot;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| db_1               |
| mysql              |
| performance_schema |
| sys                |
+--------------------+

[root@mysql5 ~]# mysql -ubuddy -p  -h192.168.56.182 -P3306 -p123456 -e &quot;show databases&quot;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| db_2               |
| mysql              |
| performance_schema |
| sys                |
+--------------------+&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;创建表并插入数据&quot;&gt;创建表并插入数据&lt;/h4&gt;
&lt;p&gt;使用服务端口登录，进行创建表和插入数据的操作。此时我们操作的就是逻辑库和逻辑表。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;[root@mysql5 ~]# mysql -uroot -h192.168.56.185 -P8066 -p123456
mysql&amp;gt; show databases;
+----------+
| DATABASE |
+----------+
| testdb   |
+----------+
1 row in set (0.00 sec)

mysql&amp;gt; use testdb;
Database changed
mysql&amp;gt; show tables;
Empty set (0.00 sec)

mysql&amp;gt; create table if not exists products (
    -&amp;gt;   product_id int not null,
    -&amp;gt;   product_name varchar(250),
    -&amp;gt;   expire_time date,
    -&amp;gt;   primary key(product_id)
    -&amp;gt; )engine=innodb charset=utf8;
Query OK, 0 rows affected, 1 warning (0.08 sec)

mysql&amp;gt; create table if not exists orders (
    -&amp;gt;   order_id int not null,
    -&amp;gt;   product_id int not null,
    -&amp;gt;   effective_time date,
    -&amp;gt;   cust_name varchar(20),
    -&amp;gt;   cust_address varchar(200),
    -&amp;gt;   primary key(order_id)
    -&amp;gt; )engine=innodb charset=utf8;
Query OK, 0 rows affected (0.04 sec)

insert into products values(1,'Package A','2015-12-31')
insert into products values(2,'Package B','2022-07-31');
insert into products values(3,'Package C','2025-12-31');
insert into products values(4,'Package D','2028-05-31');

insert into orders values(1,1,'2019-12-25','caocao','gz');
insert into orders values(1,1,'2019-12-25','caocao','gz');
insert into orders values(2,1,'2019-12-25','liubei','sz');
insert into orders values(3,2,'2019-12-25','sunquan','sh');
insert into orders values(4,2,'2019-12-25','zhugeliang','nj');
insert into orders values(5,3,'2019-12-25','simayi','hz');
insert into orders values(6,4,'2019-12-25','caopi','wh');
insert into orders values(7,1,'2019-12-25','guanyu','cd');
insert into orders values(8,1,'2019-12-25','zhengfei','bj');
insert into orders values(9,3,'2019-12-25','zhaoyun','cd');
insert into orders values(10,1,'2019-12-25','weiyan','cq');
insert into orders values(11,4,'2019-12-25','machao','cs');
insert into orders values(12,1,'2019-12-25','lvbu','cd');
insert into orders values(13,1,'2019-12-25','diaochan','sh');
insert into orders values(14,2,'2019-12-25','huangzhong','hz');

mysql&amp;gt; insert into orders values(1,1,'2019-12-25','caocao','gz');
ERROR 1064 (HY000): bad insert sql, sharding column/joinKey:ID not provided,INSERT INTO orders&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在插入orders表的时候再次报错，报错很明显，说分片键id没提供。这是因为我们在rule.xml中columns字段不是指定的分片字段order_id。在rule.xml配置一下columns字段为order_id就可以了。&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;tableRule name=&quot;rule_mod&quot;&amp;gt;
    &amp;lt;rule&amp;gt;
        &amp;lt;columns&amp;gt;order_id&amp;lt;/columns&amp;gt;
        &amp;lt;algorithm&amp;gt;func_mod&amp;lt;/algorithm&amp;gt;
    &amp;lt;/rule&amp;gt;
&amp;lt;/tableRule&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;验证分片数据否正确&quot;&gt;验证分片数据否正确&lt;/h4&gt;
&lt;p&gt;验证db_1分片上的数据。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;[root@mysql5 ~]# mysql -ubuddy  -h192.168.56.181 -P3306 -p123456 -D db_1 -e &quot;select * from products&quot; 
+------------+--------------+-------------+
| product_id | product_name | expire_time |
+------------+--------------+-------------+
|          1 | Package A    | 2015-12-31  |
|          1 | Package B    | 2022-07-31  |
|          1 | Package C    | 2025-12-31  |
|          1 | Package D    | 2028-05-31  |
+------------+--------------+-------------+

[root@mysql5 ~]# mysql -ubuddy  -h192.168.56.181 -P3306 -p123456 -D db_1 -e &quot;select * from orders&quot;  
+----------+------------+----------------+------------+--------------+
| order_id | product_id | effective_time | cust_name  | cust_address |
+----------+------------+----------------+------------+--------------+
|        2 |          1 | 2019-12-25     | liubei     | sz           |
|        4 |          2 | 2019-12-25     | zhugeliang | nj           |
|        6 |          4 | 2019-12-25     | caopi      | wh           |
|        8 |          1 | 2019-12-25     | zhengfei   | bj           |
|       10 |          1 | 2019-12-25     | weiyan     | cq           |
|       12 |          1 | 2019-12-25     | lvbu       | cd           |
|       14 |          2 | 2019-12-25     | huangzhong | hz           |
+----------+------------+----------------+------------+--------------+&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;验证db_2分片上的数据。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;[root@mysql5 ~]# mysql -ubuddy  -h192.168.56.182 -P3306 -p123456 -D db_2 -e &quot;select * from products&quot;  
mysql: [Warning] Using a password on the command line interface can be insecure.
+------------+--------------+-------------+
| product_id | product_name | expire_time |
+------------+--------------+-------------+
|          1 | Package A    | 2015-12-31  |
|          1 | Package B    | 2022-07-31  |
|          1 | Package C    | 2025-12-31  |
|          1 | Package D    | 2028-05-31  |
+------------+--------------+-------------+

[root@mysql5 ~]# mysql -ubuddy  -h192.168.56.182 -P3306 -p123456 -D db_2 -e &quot;select * from orders&quot; 
+----------+------------+----------------+-----------+--------------+
| order_id | product_id | effective_time | cust_name | cust_address |
+----------+------------+----------------+-----------+--------------+
|        1 |          1 | 2019-12-25     | caocao    | gz           |
|        3 |          2 | 2019-12-25     | sunquan   | sh           |
|        5 |          3 | 2019-12-25     | simayi    | hz           |
|        7 |          1 | 2019-12-25     | guanyu    | cd           |
|        9 |          3 | 2019-12-25     | zhaoyun   | cd           |
|       11 |          4 | 2019-12-25     | machao    | cs           |
|       13 |          1 | 2019-12-25     | diaochan  | sh           |
+----------+------------+----------------+-----------+--------------+&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;总结&quot;&gt;总结&lt;/h4&gt;
&lt;p&gt;这篇我们学习了基本的schema.xml的配置方法，目前还是比较皮毛的。下一篇我们来介绍分片的一些算法。&lt;/p&gt;
&lt;h4 id=&quot;参考文档&quot;&gt;参考文档&lt;/h4&gt;
</description>
<pubDate>Thu, 26 Dec 2019 18:48:00 +0000</pubDate>
<dc:creator>BuddyYuan</dc:creator>
<og:description>前言 一边有一个经常引诱我让我“娱乐至死”的视频，还有一个不停“鞭策“我让我快点学习的大BOSS。正是有这两种 才让我常常在自信中明白自己努力的方向。嗯,&amp;quot;人间不值得&amp;quot;！ SCHE</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/buddy-yuan/p/12105342.html</dc:identifier>
</item>
<item>
<title>最常用的CountDownLatch, CyclicBarrier你知道多少? (Java工程师必会) - 浪人~</title>
<link>http://www.cnblogs.com/liqiangchn/p/12105295.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liqiangchn/p/12105295.html</guid>
<description>&lt;p&gt;CountdownLatch，CyclicBarrier是非常常用并发工具类，可以说是Java工程师必会技能了。不但在项目实战中经常涉及，而且在编写压测程序，多线程demo也是必不可少，所以掌握它们的用法和实现原理非常有必要。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;念念不忘，必有回响！&lt;br/&gt;点赞走一走，找到女朋友~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;等待多线程完成的countdownlatch&quot;&gt;等待多线程完成的CountDownLatch&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;CountDownLatch允许一个或多个线程等待其他线程完成操作&lt;/strong&gt;。也就是说通过使用CountDownLatch工具类，可以让一组线程等待彼此执行完毕后在共同执行下一个操作。具体流程如下图所示，箭头表示任务，矩形表示栅栏，当三个任务都到达栅栏时，栅栏后wait的任务才开始执行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://source.mycookies.cn/201912260037_709.jpg?ERROR&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CountDownLatch维护有个int型的状态码，每次调用countDown时状态值就会减1；调用wait方法的线程会阻塞，直到状态码为0时才会继续执行。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在多线程协同工作时，可能需要等待其他线程执行完毕之后，主线程才接着往下执行。首先我们可能会想到&lt;strong&gt;使用线程的join方法&lt;/strong&gt;（调用join方法的线程优先执行，该线程执行完毕后才会执行其他线程），显然这是可以完成的。&lt;/p&gt;
&lt;h3 id=&quot;使用thread.join方法实现&quot;&gt;使用Thread.join()方法实现&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class RunningRaceTest {
    public static void main(String[] args) throws InterruptedException {
        Thread runner1 = new Thread(new Runner(), &quot;1号&quot;);
        Thread runner2 = new Thread(new Runner(), &quot;2号&quot;);
        Thread runner3 = new Thread(new Runner(), &quot;3号&quot;);
        Thread runner4 = new Thread(new Runner(), &quot;4号&quot;);
        Thread runner5 = new Thread(new Runner(), &quot;5号&quot;);
        runner1.start();
        runner2.start();
        runner3.start();
        runner4.start();
        runner5.start();

        runner1.join();
        runner2.join();
        runner3.join();
        runner4.join();
        runner5.join();

        // 裁判等待5名选手准备完毕
        System.out.println(&quot;裁判：比赛开始~~&quot;);
    }
}

class Runner implements Runnable {
    @Override
    public void run() {
        try {
            int sleepMills = ThreadLocalRandom.current().nextInt(1000);
            Thread.sleep(sleepMills);
            System.out.println(Thread.currentThread().getName() + &quot; 选手已就位, 准备共用时： &quot; + sleepMills + &quot;ms&quot;);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Thread.join()完全可以实现这个需求，不过存在一个问题，&lt;strong&gt;如果调用join的线程一直存活，则当前线程则需要一直等待&lt;/strong&gt;。这显然不够灵活，并且当前线程可能会出现死等的情况。&lt;/p&gt;
&lt;h3 id=&quot;更加灵活的countdownlatch&quot;&gt;更加灵活的CountDownLatch&lt;/h3&gt;
&lt;p&gt;jdk1.5之后的并发包中提供了CountDownLatch并发工具了，也可以实现join的功能，并且功能更加强大。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 参赛选手线程
class Runner implements Runnable {
    private CountDownLatch countdownLatch;
    
    public Runner(CountDownLatch countdownLatch) {
        this.countdownLatch = countdownLatch;
    }

    @Override
    public void run() {
        try {
            int sleepMills = ThreadLocalRandom.current().nextInt(1000);
            Thread.sleep(sleepMills);
            System.out.println(Thread.currentThread().getName() + &quot; 选手已就位, 准备共用时： &quot; + sleepMills + &quot;ms&quot;);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            // 准备完毕，举手示意
            countdownLatch.countDown();
        }
    }
}

public class RunningRaceTest {
    public static void main(String[] args) throws InterruptedException {
        // 使用线程池的正确姿势
        int size = 5;
        AtomicInteger counter = new AtomicInteger();
        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(size, size, 1000, TimeUnit.SECONDS, new ArrayBlockingQueue&amp;lt;&amp;gt;(100), (r) -&amp;gt; new Thread(r, counter.addAndGet(1) + &quot; 号 &quot;), new ThreadPoolExecutor.AbortPolicy());
        
        CountDownLatch countDownLatch = new CountDownLatch(5);
        for (int i = 0; i &amp;lt; size; i++) {
            threadPoolExecutor.submit(new Runner(countDownLatch));
        }

        // 裁判等待5名选手准备完毕
        countDownLatch.await(); // 为了避免死等，也可以添加超时时间
        System.out.println(&quot;裁判：比赛开始~~&quot;);

        threadPoolExecutor.shutdownNow();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre class=&quot;nginx&quot;&gt;
&lt;code&gt;5 号  选手已就位, 准备共用时： 20ms
4 号  选手已就位, 准备共用时： 156ms
1 号  选手已就位, 准备共用时： 288ms
2 号  选手已就位, 准备共用时： 519ms
3 号  选手已就位, 准备共用时： 945ms
比赛开始~~&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;同步屏障cyclicbarrier&quot;&gt;同步屏障CyclicBarrier&lt;/h2&gt;
&lt;p&gt;CyclicBarrier可以实现CountDownLatch一样的功能，不同的是&lt;strong&gt;CountDownLatch属于一次性对象，声明后只能使用一次，而CyclicBarrier可以循环使用&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://source.mycookies.cn/201912260131_739.jpg?ERROR&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从字面意义上来看，CyclicBarrier表示循环的屏障，当一组线程全部都到达屏障时，屏障才会被移除，否则只能阻塞在屏障处。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class RunningRace {
    public static void main(String[] args) {
        // 使用线程池的正确姿势
        int size = 5;
        AtomicInteger counter = new AtomicInteger();
        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(size, size, 1000, TimeUnit.SECONDS, new ArrayBlockingQueue&amp;lt;&amp;gt;(100), (r) -&amp;gt; new Thread(r, counter.addAndGet(1) + &quot; 号 &quot;), new ThreadPoolExecutor.AbortPolicy());

        CyclicBarrier cyclicBarrier = new CyclicBarrier(5, () -&amp;gt; System.out.println(&quot;裁判：比赛开始~~&quot;));
        for (int i = 0; i &amp;lt; 10; i++) {
            threadPoolExecutor.submit(new Runner(cyclicBarrier));
        }
    }
}

class Runner implements Runnable {
    private CyclicBarrier cyclicBarrier;

    public Runner(CyclicBarrier countdownLatch) {
        this.cyclicBarrier = countdownLatch;
    }

    @Override
    public void run() {
        try {
            int sleepMills = ThreadLocalRandom.current().nextInt(1000);
            Thread.sleep(sleepMills);
            System.out.println(Thread.currentThread().getName() + &quot; 选手已就位, 准备共用时： &quot; + sleepMills + &quot;ms&quot; + cyclicBarrier.getNumberWaiting());
            cyclicBarrier.await();
        } catch (InterruptedException | BrokenBarrierException e) {
            e.printStackTrace();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于CyclicBarrier可以循环使用，所以CyclicBarrier的构造方法中可以传入一个Runnable参数，&lt;strong&gt;在每一轮执行完毕之后就会立刻执行这个Runnable任务&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;countdownlatch设计与实现&quot;&gt;CountDownLatch设计与实现&lt;/h2&gt;
&lt;p&gt;CountDownLath是基于AQS框架的一种简单实现，有两个核心的方法，即await()和countDown()，通过构造方法传入一个状态值，调用await()方法时线程会阻塞，直到状态码被修改成0时才会返回，每次调用countDown()时会将状态值减1。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://source.mycookies.cn/201912250118_712.png?ERROR&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;wait方法&lt;/strong&gt;：执行wait方法后，会尝试获取同步状态，如果为状态为0则方法继续执行，否择当前线程会被加入到同步队列中，详情可见笔者关于AQS的两篇文章。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void await() throws InterruptedException {
    sync.acquireSharedInterruptibly(1);
}
public final void acquireSharedInterruptibly(int arg)
    throws InterruptedException {
    if (Thread.interrupted())
        throw new InterruptedException();
    // 如果状态码不为0，尝试获取同步状态，如果失败则被加入到同步队列中
    if (tryAcquireShared(arg) &amp;lt; 0)
        doAcquireSharedInterruptibly(arg);
}
// 当状态码为0时返回1，否择返回-1，这个方法中参数没有任何用处
protected int tryAcquireShared(int acquires) {
    return (getState() == 0) ? 1 : -1;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;countDown&lt;/strong&gt;方法：每次执行countDown方法时，会将状态码的值减1.&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void countDown() {
    sync.releaseShared(1);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;cyclicbarrier的设计与实现&quot;&gt;CyclicBarrier的设计与实现&lt;/h2&gt;
&lt;p&gt;CyclicBarrier与CountDownLatch实现思想相同，也是基于AQS框架实现。不同的是CyclicBarrier&lt;strong&gt;内部维护一个状态值&lt;/strong&gt;， &lt;strong&gt;借助基于AQS实现的锁ReentrantLock来实现状态值的同步更新&lt;/strong&gt;，以及AQS除了同步状态之外的另一个核心概念条件队列来完成线程的阻塞。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://source.mycookies.cn/201912250142_622.png?ERROR&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;parties&lt;/strong&gt;： 和CountdownLatch中的状态值一样，用来记录每次要相互等待的线程数量，只有parties个线程同时到达屏障时，才会唤醒阻塞的线程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;count临时计数器&lt;/strong&gt;: 由于CyclicBarrier是可以循环使用的，count可以理解为是一个临时变量，每一轮执行完毕或者被打断都会重置count为parties值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Generation内部类&lt;/strong&gt;： 只有一个属性 broken表示当前这一轮执行是否被中断，如果被中断后其他线程再执行await方法会抛出异常（目的是停止本轮线程未执行线程的继续执行）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;await方法&lt;/strong&gt;： 当执行await方法时，会同步得对内部的count执行--count操作， 如果count = 0，则执行barrierCommand任务（通过构造方法传来的Runnable参数）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;reset方法&lt;/strong&gt;：中断本轮执行，重置count值，唤醒等待的线程然后开始下一轮，此时本轮正在执行的线程调用await方法会抛出异常。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// await方法实际执行的代码
private int dowait(boolean timed, long nanos)
    throws InterruptedException, BrokenBarrierException,
TimeoutException {
    final ReentrantLock lock = this.lock;
    // 加锁，保证并发操作的一致性
    lock.lock();
    try {
        // 如果当前这一轮操作被中断，抛出中断异常（该异常只是起警示作用，没有任何其他信息）
        final Generation g = generation;
        if (g.broken)
            throw new BrokenBarrierException();
        if (Thread.interrupted()) {
            breakBarrier();
            throw new InterruptedException();
        }
        // 本轮执行的计数器 数值-1
        int index = --count;
        if (index == 0) {  // 计数器值=1， 本轮线程全部到达屏障，执行barrierCommand任务
            boolean ranAction = false;
            try {
                final Runnable command = barrierCommand;
                if (command != null)
                    command.run();
                ranAction = true;
                nextGeneration();// 唤醒所有等待在条件队列上的任务
                return 0;
            } finally {
                if (!ranAction)
                    breakBarrier();
            }
        }

        // 如果状态不等于0，循环等待直到计数器值为0，本轮执行被打破，线程被中断，或者等待超时
        for (;;) {
            try {
                if (!timed)
                    // 状态码不为0，将当前线程加入到条件队列中，进入阻塞状态
                    trip.await();
                else if (nanos &amp;gt; 0L)
                    nanos = trip.awaitNanos(nanos);
            } catch (InterruptedException ie) {
                if (g == generation &amp;amp;&amp;amp; ! g.broken) {
                    breakBarrier();
                    throw ie;
                } else {
                    // We're about to finish waiting even if we had not
                    // been interrupted, so this interrupt is deemed to
                    // &quot;belong&quot; to subsequent execution.
                    Thread.currentThread().interrupt();
                }
            }

            if (g.broken)
                throw new BrokenBarrierException();

            if (g != generation)
                return index;

            if (timed &amp;amp;&amp;amp; nanos &amp;lt;= 0L) {
                breakBarrier();// 唤醒所有条件队列中的线程，重置count的值
                throw new TimeoutException();
            }
        }
    } finally {
        lock.unlock();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重置栅栏的状态&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void reset() {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        breakBarrier();   // break the current generation
        nextGeneration(); // start a new generation
    } finally {
        lock.unlock();
    }
}
/**
 * Sets current barrier generation as broken and wakes up everyone.
 * Called only while holding lock.
 */
private void breakBarrier() {
    generation.broken = true;
    count = parties;
    trip.signalAll();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当一轮执行完毕之后，既count=0后，CyclicBarrier的临时状态会重置为&lt;strong&gt;parties&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 进入下一轮
 * 唤醒所有等待线程，充值count
 */
private void nextGeneration() {
    // signal completion of last generation
    trip.signalAll();
    // set up next generation
    count = parties;
    generation = new Generation();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;CountDownLatch创建后只能使用一次，而CyclicBarrier可以循环使用，并且CyclicBarrier功能更完善。&lt;/li&gt;
&lt;li&gt;CountDownLatch内部的状态是基于AQS中的状态信息，而CyclicBarrier中的状态值是单独维护的，使用ReentrantLock加锁保证并发修改状态值的数据一致性。&lt;/li&gt;
&lt;li&gt;它们的使用场景：允许一个或多个线程等待其他线程完成操作， 即当指定数量线程执行完某个操作再继续执行下一个操作。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;http://source.mycookies.cn/201912140139_583.png?ERROR&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 26 Dec 2019 17:02:00 +0000</pubDate>
<dc:creator>浪人~</dc:creator>
<og:description>CountdownLatch，CyclicBarrier是非常常用并发工具类，可以说是Java工程师必会技能了。不但在项目实战中经常涉及，而且在编写压测程序，多线程demo也是必不可少，所以掌握它们的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/liqiangchn/p/12105295.html</dc:identifier>
</item>
<item>
<title>聊聊字符串拼接的哪一些事儿 - 程序员修炼之旅</title>
<link>http://www.cnblogs.com/xiaoXuZhi/p/XYH_String2.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaoXuZhi/p/XYH_String2.html</guid>
<description>&lt;p&gt;​        字符串对我编程人员来说是字符串时每天见面的常客，你不认识不熟悉他都不得行，字符串的拼接更是家常便饭，那么在实际开发过程中实现字符串的拼接有哪一些方式呢？咱们一起来聊聊，来交流沟通，学习一波。也许你会说，那也太简单了嘛，谁不会啊，哈哈，使用起来确实简单，但是不一定我们都使用的方式还有优秀的方式吗？&lt;/p&gt;
&lt;p&gt;    在文章前，我们先简单聊聊关于string的数据类型存储必须了解概念：&lt;/p&gt;
&lt;p&gt;    string是一个引用类型，是一个sealed类，存储在堆内存上，每一次修改都会从新创建一个新的string来存储，原始的会自动被回收。这个是不感觉是废话，人人都知道嘛，哈哈哈。&lt;/p&gt;
&lt;p&gt;    下面以c#为开发语言来说明：实现字符串的拼接常用的方式有如下四种&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;其一、直接通过+拼接&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    直接通过+拼接是我们在代码中最常见的一种方式，下面以一个简单的代码段来分析分析&lt;/p&gt;
&lt;p&gt;    string str=&quot;1&quot;;&lt;/p&gt;
&lt;p&gt;    str=str+&quot;2&quot;;&lt;/p&gt;
&lt;p&gt;    第一段代码，首先分配了一个内存空间来存储str变量，其值为“1”&lt;/p&gt;
&lt;p&gt;    第二段代码，重新分配了一个新的内存空间来存储“12”，并将str指向新地址&lt;/p&gt;
&lt;p&gt;    通过分析，其实我们不难发现，两端就简单的代码，就会有两次内存地址操作，随着拼接字符串的个数地址，分配内存地址的次数也递增，当几个简单的字符串通过该方式拼接时，其实我们还是感觉不到性能的影响，但是当字符串数量大时，你都会有感觉了，那样不仅仅造成内存的浪费，还直接影响性能。&lt;/p&gt;
&lt;p&gt;所以在实际开发工程中，通过+拼接字符串比较常见，但是如果只是见到这种方式也就不那么友好了，既然不友好，那么显然就会有比较友好的方式啦，下面我们就分析分析通过StringBuilder来实现字符串的拼接。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;其二、通过StringBuilder拼接字符串&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    StringBuilder其实内部相当于是维护的一个字符数组，是一个可以动态增加自身数据长度，其默认长度为16，当存储的字符串超出其长度是，会自动扩容2倍长度。&lt;/p&gt;
&lt;p&gt;    哈哈，说到这儿，估计你看出了问题，那就是超出长度自动扩容，自动扩容是不是也需要牺牲性能，当然在几次扩容你还感觉不到性能的影响，但是如果词数多了，你就会感觉很明显，这也是对StringBuilder的一些使用技巧。&lt;/p&gt;
&lt;p&gt;我们去看不同小伙伴的代码，你就会发现，技术老鸟，在初始化StringBuilder的时候会根据预估将要存储的字符串大小，给StringBuilder初始化一个长度，这也就是细节上的差距体现。&lt;/p&gt;
&lt;p&gt;    说了半天的废话，是不是要来的实际的代码来证明说的不是废话呢？不急不急，在文章最后，我会专门写测试代码对比分析的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;其三、string.Format不陌生吧&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;    对于一些格式的数据拼接填充，string.Format也是经常看见的，他的一个很大好处就是，看上去比较清晰&lt;/p&gt;
&lt;p&gt;    其实我们看过string的底层实现我们会发现，其底层本质还是StringBuilder来实现的&lt;/p&gt;
&lt;p&gt;    下面就是string.format的源码实现&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String Format(IFormatProvider provider, String format, &lt;span&gt;params&lt;/span&gt; Object[] args) &amp;lt;br&amp;gt;&lt;span&gt;{

　　　　&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (format == &lt;span&gt;null&lt;/span&gt; || args == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)

　　　　　　&lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArgumentNullException((format==&lt;span&gt;null&lt;/span&gt;)?&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;format&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;args&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

　　　　StringBuilder sb &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; StringBuilder(format.Length + args.Length * &lt;span&gt;8&lt;/span&gt;&lt;span&gt;);

　　　　sb.AppendFormat(provider,format,args);

　　　　&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; sb.ToString();

}
 &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;    其实string.Format使用起来很简单，我就不在啰嗦介绍了，免得大家觉得烦，哈哈哈&lt;/p&gt;
&lt;p&gt;    string result=string.Format(&quot;大家好，我叫{0}，今年{1}&quot;,&quot;程序员修炼之旅&quot;,1);&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;其四、$方式拼接字符串&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    C#6.0出现了$方式拼接字符串，其实简单说就是string.Format简化操作版，string.Format如果拼接的字符串太多，估计自己都懵逼的分不清对应关系了，不知道你们遇到过没有，反正我原来是遇到过的。$就很好的规避了该问题，那么下    面来一个例子说明一切：&lt;/p&gt;

&lt;pre class=&quot;code-snippet__js code-snippet code-snippet_nowrap&quot; data-lang=&quot;cs&quot;&gt;
&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;string name = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;程序员修炼之旅&quot;;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;​&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;int age = &lt;span class=&quot;code-snippet__number&quot;&gt;1;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;​&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;string str = &lt;span class=&quot;code-snippet__keyword&quot;&gt;string.Format(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;my name is{0}, I'm {1} years old&quot;,name,age);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;​&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;string str2 = &lt;span class=&quot;code-snippet__string&quot;&gt;$&quot;my name is&lt;span class=&quot;code-snippet__subst&quot;&gt;{name}, I'm &lt;span class=&quot;code-snippet__subst&quot;&gt;{age} years old&quot;;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;​&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    最终结果是：str=str1&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;其五，当然还有其他方式，不在此啰嗦了，后续在讨论&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;测试分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    说了半天，不拿点实际东西来测试，我知道你是不会信服的，下面就直接上测试代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Diagnostics;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; stringSplicingTest
{
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 字符串拼接练习
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 主函数入口
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;args&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 测试分别通过+ 和 StringBuilder 来连接 0 之100的数字&lt;/span&gt;
            Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;测试分别通过+ 和 StringBuilder 来连接&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;测试连接 0 - 100 的数字&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;);
            PlusString(&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;);
            StringBuilderString2(&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;);

            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;测试连接 0 - 10000 的数字&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            PlusString(&lt;/span&gt;&lt;span&gt;10000&lt;/span&gt;&lt;span&gt;);
            StringBuilderString2(&lt;/span&gt;&lt;span&gt;10000&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 下面测试一下同样是StringBuilder连接字符串，一个是定义吃指定长度，一个是不指定长度对比&lt;/span&gt;
            Console.WriteLine(&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;下面测试一下同样是StringBuilder连接字符串， 一个是定义并指定长度，一个是不指定长度对比&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;测试连接 0 - 1000000 的数字&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;不初始化长度&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            StringBuilderString(&lt;/span&gt;&lt;span&gt;1000000&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;初始化长度&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            StringBuilderString2(&lt;/span&gt;&lt;span&gt;1000000&lt;/span&gt;&lt;span&gt;);

            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;);

            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;测试连接 0 - 10000000 的数字&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;不初始化长度&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            StringBuilderString(&lt;/span&gt;&lt;span&gt;10000000&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;初始化长度&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            StringBuilderString2(&lt;/span&gt;&lt;span&gt;10000000&lt;/span&gt;&lt;span&gt;);

            Console.ReadLine();
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 通过+拼接字符串
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;totalNum&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; PlusString(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; totalNum)
        {
            &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;/ 定义一个秒表，执行获取执行时间&lt;/span&gt;
            Stopwatch st = &lt;span&gt;new&lt;/span&gt; Stopwatch();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实例化类&lt;/span&gt;
            st.Start();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开始计时&lt;/span&gt;
&lt;span&gt;
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;开始执行，通过+连接字符串：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; result = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;/ 定义一个数组&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; totalNum; i++&lt;span&gt;)
            {
                result &lt;/span&gt;= result +&lt;span&gt; i.ToString();
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;需要统计时间的代码段&lt;/span&gt;
&lt;span&gt;
            st.Stop();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;终止计时&lt;/span&gt;
            Console.WriteLine(&lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;执行完毕，通过+连接字符串！总耗时{0}毫秒&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            st.ElapsedMilliseconds.ToString()));
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 通过s拼接字符串
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;totalNum&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; StringBuilderString(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; totalNum)
        {
            &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;/ 定义一个秒表，执行获取执行时间&lt;/span&gt;
            Stopwatch st = &lt;span&gt;new&lt;/span&gt; Stopwatch();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实例化类&lt;/span&gt;
            st.Start();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开始计时&lt;/span&gt;
&lt;span&gt;
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;开始执行，通过 StringBuilder 连接字符串：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            StringBuilder result &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuilder();

            &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;/ 定义一个数组&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; totalNum; i++&lt;span&gt;)
            {
                result.Append(i.ToString());
            }

            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; result2 =&lt;span&gt; result.ToString();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;需要统计时间的代码段&lt;/span&gt;
&lt;span&gt;
            st.Stop();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;终止计时&lt;/span&gt;
            Console.WriteLine(&lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;执行完毕，通过 StringBuilder 连接字符串！总耗时{0}毫秒&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            st.ElapsedMilliseconds.ToString()));
        }


        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 通过StringBuilder拼接字符串,初始化时指定一个长度
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;totalNum&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; StringBuilderString2(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; totalNum)
        {
            &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;/ 定义一个秒表，执行获取执行时间&lt;/span&gt;
            Stopwatch st = &lt;span&gt;new&lt;/span&gt; Stopwatch();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实例化类&lt;/span&gt;
            st.Start();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开始计时&lt;/span&gt;
&lt;span&gt;
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;开始执行，通过 StringBuilder 连接字符串：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            StringBuilder result &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; StringBuilder(totalNum * &lt;span&gt;6&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;/ 定义一个数组&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; totalNum; i++&lt;span&gt;)
            {
                result.Append(i.ToString());
            }

            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; result2 =&lt;span&gt; result.ToString();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;需要统计时间的代码段&lt;/span&gt;
&lt;span&gt;
            st.Stop();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;终止计时&lt;/span&gt;
            Console.WriteLine(&lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;执行完毕，通过 StringBuilder 连接字符串！总耗时{0}毫秒&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            st.ElapsedMilliseconds.ToString()));
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class=&quot;code-snippet__js code-snippet code-snippet_nowrap&quot; data-lang=&quot;cs&quot;&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SIB9aSbJhQnGl1m8H82RPEnSPoXXfnH7qI0jxSMX766jlsaNww31bDvwNzqYhH3nJDzOHQP6gUu8xanYlDAE2w/640?wx_fmt=png&quot; alt=&quot;&quot; data-ratio=&quot;0.8256130790190735&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;734&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;结果分析总结：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;测试分两个点：&lt;/p&gt;
&lt;p&gt;其一测试的是：通过+和StringBuilder拼接字符串的性能比较哦&lt;/p&gt;
&lt;p&gt;其二测试的是：StringBuilder初始化长度和不初始化长度的性能比较&lt;/p&gt;
&lt;p&gt;大概得出以下几点结论&lt;/p&gt;
&lt;p&gt;1、在待拼接的字符串少的时，+和StringBuilder没有明显的性能差距&lt;/p&gt;
&lt;p&gt;2、当拼接的字符串多时，StringBuilder的优势越来越明显&lt;/p&gt;
&lt;p&gt;3、同样是StringBuilder拼接字符串，预估初始化长度的效率比不初始化指定长度的效率高&lt;/p&gt;
&lt;p&gt;说到此，我相信大家都知道该怎么使用了。好了，时间不早了，赶紧洗洗睡了，明天还得上班呢？&lt;/p&gt;
&lt;p&gt; END&lt;/p&gt;


&lt;p&gt;欢迎各位小伙伴关注我的公众号（程序员修炼之旅），里面会分享一些技术类干货，同时也是一个技术沟通交流平台，谢谢大家的支持。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/xiaoXuZhi/1620931/o_381957-20191212133634116-38358454.jpg&quot; alt=&quot;&quot; width=&quot;306&quot; height=&quot;306&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 26 Dec 2019 16:58:00 +0000</pubDate>
<dc:creator>程序员修炼之旅</dc:creator>
<og:description>字符串对我编程人员来说是字符串时每天见面的常客，你不认识不熟悉他都不得行，字符串的拼接更是家常便饭，那么在实际开发过程中实现字符串的拼接有哪一些方式呢？咋们一起来聊聊，来交流沟通，学习一波。也许你会说</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiaoXuZhi/p/XYH_String2.html</dc:identifier>
</item>
<item>
<title>Java的反射机制之反向抽烟 - 布尔bl</title>
<link>http://www.cnblogs.com/chenzhuantou/p/12105276.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenzhuantou/p/12105276.html</guid>
<description>&lt;blockquote readability=&quot;6.5961538461538&quot;&gt;
&lt;p&gt;show me the code and take to me,做的出来更要说的明白&lt;br/&gt;GitHub项目&lt;a href=&quot;https://github.com/buerbl/JavaHouse&quot;&gt;JavaHouse&lt;/a&gt;同步收录&lt;br/&gt;喜欢就点个赞呗! 你的支持是我分享的动力！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;引入&quot;&gt;引入&lt;/h3&gt;
&lt;p&gt;反射是一种不按套路处出牌的机制。通常我们接触的方式都是 &quot;正射&quot;，暂且起这个名字。虽然我们用的少，但是反射其实就在我们日常开发中。比如我们常见的空指针异常，或者是 Spring 的各种注解配置创建对象等等。&lt;/p&gt;
&lt;h3 id=&quot;正常操作&quot;&gt;正常操作&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;ReflectTest reflectTest = new ReflectTest();
reflectTest.setName(&quot;boolenbl公众号&quot;);
System.out.println(reflectTest.getName());&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一般我们使用上面方法创建对象以及初始化属性。并且有严格的访问规则。但是反射就反其道为之。他利用 Class、 Method、 Field等类，随意创建对象，获取公有、私有的方法，获取私有的、共有的方法。&lt;/p&gt;
&lt;h3 id=&quot;class-类&quot;&gt;Class 类&lt;/h3&gt;
&lt;p&gt;Class 类只有私有的构造方法，因此我们不能初始化该对对象，不过 Class 类也不是给我们使用的。 Class 类只能被 JVM 调用。有图有真相：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://javahouse.xyz/20191226174620.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;获取class-类&quot;&gt;获取Class 类&lt;/h3&gt;
&lt;p&gt;有三种方法可以获取到 Class 类。代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 方法1
System.out.println(ReflectTest.class);
// 方法2
System.out.println(new ReflectTest().getClass());
// 方法3  包名+类名 （JDBC那种操作） 有异常
System.out.println(Class.forName(&quot;基础.ReflectTest&quot;));
// 获取类名
System.out.println(ReflectTest.class.getName());&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;获取方法&quot;&gt;获取方法&lt;/h3&gt;
&lt;p&gt;利用该方法可以无视访问规则,获取所有的方法。代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;System.out.println(Arrays.toString(ReflectTest.class.getDeclaredMethods()));&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;获取属性&quot;&gt;获取属性&lt;/h3&gt;
&lt;p&gt;利用该方法可以无视访问规则,获取所有的属性。代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;System.out.println(Arrays.toString(ReflectTest.class.getDeclaredFields()));&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;获取构造器&quot;&gt;获取构造器&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;reflectTestClass.getConstructor();&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;从正常到异常反射操作对象&quot;&gt;从正常到异常（反射操作对象）&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Class&amp;lt;ReflectTest&amp;gt; reflectTestClass = ReflectTest.class;
Method method = reflectTestClass.getMethod(&quot;setName&quot;, String.class);
Constructor&amp;lt;ReflectTest&amp;gt; constructor = reflectTestClass.getConstructor();
reflectTest = constructor.newInstance();
method.invoke(reflectTest, &quot;公众号&quot;);
System.out.println(reflectTest.getName());&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;完整代码&quot;&gt;完整代码&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package 基础;

import lombok.Data;
import org.junit.Test;

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Arrays;

/**
 * @Description: 反射测试
 * @Author: boolean
 * @Date: 2019/12/26 17:01
 */
@Data
public class ReflectTest {
    private String name;
    private String pass;

    @Test
    public void test() throws NoSuchMethodException, ClassNotFoundException, IllegalAccessException, InvocationTargetException, InstantiationException {
        /**
         * 前提获取 Class 类
         */
        // 方法1
        System.out.println(ReflectTest.class);
        // 方法2
        System.out.println(new ReflectTest().getClass());
        // 方法3  包名+类名 （JDBC那种操作） 有异常
        System.out.println(Class.forName(&quot;基础.ReflectTest&quot;));
        // 获取类名
        System.out.println(ReflectTest.class.getName());
        // 获取方法
        System.out.println(Arrays.toString(ReflectTest.class.getDeclaredMethods()));
        // 获取属性
        System.out.println(Arrays.toString(ReflectTest.class.getDeclaredFields()));

        // 正常创建对象并初始化
        ReflectTest reflectTest = new ReflectTest();
        reflectTest.setName(&quot;boolenbl公众号&quot;);
        System.out.println(reflectTest.getName());

        // 反射创建对象并初始化
        Class&amp;lt;ReflectTest&amp;gt; reflectTestClass = ReflectTest.class;
        Constructor&amp;lt;ReflectTest&amp;gt; constructor = reflectTestClass.getConstructor();
        reflectTest = constructor.newInstance();
        Method method = reflectTestClass.getMethod(&quot;setName&quot;, String.class);
        method.invoke(reflectTest, &quot;公众号&quot;);
        System.out.println(reflectTest.getName());
    }

    public void test1(){

    }

    public void test2(){

    }

    public void test3(){

    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;运行结果&quot;&gt;运行结果&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class 基础.ReflectTest
class 基础.ReflectTest
class 基础.ReflectTest
基础.ReflectTest
[public boolean 基础.ReflectTest.equals(java.lang.Object), public java.lang.String 基础.ReflectTest.toString(), public int 基础.ReflectTest.hashCode(), public java.lang.String 基础.ReflectTest.getName(), public void 基础.ReflectTest.setName(java.lang.String), public void 基础.ReflectTest.test() throws java.lang.NoSuchMethodException,java.lang.ClassNotFoundException,java.lang.IllegalAccessException,java.lang.reflect.InvocationTargetException,java.lang.InstantiationException, protected boolean 基础.ReflectTest.canEqual(java.lang.Object), public void 基础.ReflectTest.test3(), public void 基础.ReflectTest.test2(), public void 基础.ReflectTest.test1(), public java.lang.String 基础.ReflectTest.getPass(), public void 基础.ReflectTest.setPass(java.lang.String)]
[private java.lang.String 基础.ReflectTest.name, private java.lang.String 基础.ReflectTest.pass]
boolenbl公众号
公众号&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;参考&quot;&gt;参考&lt;/h3&gt;
&lt;p&gt;https://www.cnblogs.com/chanshuyi/p/head_first_of_reflection.html&lt;br/&gt;sczyh30.com/posts/Java/java-reflection-1/&lt;br/&gt;https://juejin.im/post/598ea9116fb9a03c335a99a4&lt;/p&gt;
&lt;h3 id=&quot;关注微信公众号随时移动端阅读&quot;&gt;关注微信公众号，随时移动端阅读&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://javahouse.xyz/20191212204326.png&quot; alt=&quot;公众号.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 26 Dec 2019 16:40:00 +0000</pubDate>
<dc:creator>布尔bl</dc:creator>
<og:description>show me the code and take to me,做的出来更要说的明白 GitHub项目 &amp;quot;JavaHouse&amp;quot; 同步收录 喜欢就点个赞呗! 你的支持是我分享的动力！</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chenzhuantou/p/12105276.html</dc:identifier>
</item>
</channel>
</rss>