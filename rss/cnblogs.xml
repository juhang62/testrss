<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>20天，22小时20分，我是如何干掉这本1000页的代码大全的 - 初开</title>
<link>http://www.cnblogs.com/wchukai/p/10123507.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wchukai/p/10123507.html</guid>
<description>&lt;p class=&quot;md_block md_has_block_below md_has_block_below_ol&quot;&gt;&lt;span class=&quot;md_line md_line_start&quot;&gt;从11月24日到12月15日，20天内，投入22个小时又20分钟，从头到尾通读完了这本代码大全，每一章都按同样的标准做了笔记，共1.7w字。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md_block md_has_block_below md_has_block_below_ol&quot;&gt;&lt;span class=&quot;md_line md_line_start&quot;&gt;&lt;span class=&quot;line_char&quot;&gt;&lt;span class=&quot;md_line&quot;&gt;从本书本身的学到的倒是其次，最关键的是，我点亮了一个新技能，&lt;strong&gt;如何在一个漫长而枯燥的任务坚持下来，并保持同样的投入标准直至结束。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md_block md_has_block_below md_has_block_below_ol&quot;&gt;&lt;span class=&quot;md_line md_line_start&quot;&gt;&lt;span class=&quot;line_char&quot;&gt;&lt;span class=&quot;md_line&quot;&gt;&lt;span class=&quot;line_char&quot;&gt;&lt;span class=&quot;md_line&quot;&gt;从此以后，我的字典里不再有坚持二字，只要想做，就一定能做到，无所谓坚持和放弃。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md_block md_has_block_below md_has_block_below_ol&quot;&gt;&lt;span class=&quot;md_line md_line_start&quot;&gt;&lt;span class=&quot;line_char&quot;&gt;&lt;span class=&quot;md_line&quot;&gt;&lt;span class=&quot;line_char&quot;&gt;&lt;span class=&quot;md_line&quot;&gt;&lt;span class=&quot;line_char&quot;&gt;&lt;span class=&quot;md_line md_line_end&quot;&gt;先上成果。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li class=&quot;md_li&quot;&gt;笔记在这里：&lt;a class=&quot;md_compiled&quot; href=&quot;http://dev.chukai.pro/read/bian-cheng-ji-qiao/dai-ma-da-quan&quot;&gt;代码大全&lt;/a&gt;。&lt;/li&gt;
&lt;li class=&quot;md_li&quot;&gt;时间记录：&lt;/li&gt;
&lt;/ol&gt;&lt;p class=&quot;md_block&quot;&gt;&lt;span class=&quot;md_line md_line_dom_embed md_line_with_image md_line_start md_line_end&quot;&gt;&lt;img class=&quot;md_compiled&quot; title=&quot;&quot; src=&quot;http://img.chukai.pro/bitcron/2018-12-15-064121.jpg&quot; alt=&quot;&quot; width=&quot;208&quot; height=&quot;342&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md_block&quot;&gt;&lt;span class=&quot;md_line md_line_start&quot;&gt;为了搞定它，我做了两件事，一是自我赋能，二是定标准。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md_block&quot;&gt;&lt;span class=&quot;md_line md_line_start&quot;&gt;&lt;span class=&quot;line_char&quot;&gt;&lt;span class=&quot;md_line md_line_end&quot;&gt;下面，我们来谈谈这里面的底层原理。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;md_block&quot;&gt;&lt;span class=&quot;md_line md_line_dom_embed md_line_start&quot;&gt;&lt;strong&gt;做一件需要持续投入事情，最大的障碍不是我们没有能力，而是没能量。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md_block&quot;&gt;&lt;span class=&quot;md_line md_line_dom_embed md_line_start&quot;&gt;&lt;span class=&quot;line_char&quot;&gt;&lt;span class=&quot;md_line&quot;&gt;一般开始几天还好，后面我们就会慢慢动摇，用术语叫&lt;strong&gt;怀疑意义&lt;/strong&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md_block&quot;&gt;&lt;span class=&quot;md_line md_line_dom_embed md_line_start&quot;&gt;&lt;span class=&quot;line_char&quot;&gt;&lt;span class=&quot;md_line&quot;&gt;&lt;span class=&quot;line_char&quot;&gt;&lt;span class=&quot;md_line&quot;&gt;我们会想做这件事干嘛，又不是一定要做，去刷手机多好，搞这些有什么意义，还是算了吧。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md_block&quot;&gt;&lt;span class=&quot;md_line md_line_dom_embed md_line_start&quot;&gt;&lt;span class=&quot;line_char&quot;&gt;&lt;span class=&quot;md_line&quot;&gt;&lt;span class=&quot;line_char&quot;&gt;&lt;span class=&quot;md_line&quot;&gt;&lt;span class=&quot;line_char&quot;&gt;&lt;span class=&quot;md_line&quot;&gt;所以，首先要防止的就是这个事情，当怀疑意义时，要有东西拿出来说服自己。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md_block&quot;&gt;&lt;span class=&quot;md_line md_line_dom_embed md_line_start&quot;&gt;&lt;span class=&quot;line_char&quot;&gt;&lt;span class=&quot;md_line&quot;&gt;&lt;span class=&quot;line_char&quot;&gt;&lt;span class=&quot;md_line&quot;&gt;&lt;span class=&quot;line_char&quot;&gt;&lt;span class=&quot;md_line&quot;&gt;&lt;span class=&quot;line_char&quot;&gt;&lt;span class=&quot;md_line md_line_end&quot;&gt;在看这本书之前，我写下了这么7条意义，并且把它贴在笔记的最上方。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;toc_1&quot; class=&quot;h16&quot;&gt;意义&lt;/h2&gt;
&lt;ol&gt;&lt;li class=&quot;md_li&quot;&gt;系统性复习软件开发的知识&lt;/li&gt;
&lt;li class=&quot;md_li&quot;&gt;作为会赋能，随时可以打鸡血，懂目标管理，懂时间管理，道术器用齐活，当然能通过科学手段搞定它。&lt;/li&gt;
&lt;li class=&quot;md_li&quot;&gt;老哥这本书写得这么厚，恐怕是在刁难我，我必须证明难不倒我。&lt;/li&gt;
&lt;li class=&quot;md_li&quot;&gt;我是一名终身成长者，不可能被这本破书吓到，也就是一个小障碍而已。&lt;/li&gt;
&lt;li class=&quot;md_li&quot;&gt;1000页的专业书都看完了，以后没有看不下的书。&lt;/li&gt;
&lt;li class=&quot;md_li&quot;&gt;优化自己的阅读流程。&lt;/li&gt;
&lt;li class=&quot;md_li&quot;&gt;读完可以出去装个x。&lt;/li&gt;
&lt;/ol&gt;&lt;p class=&quot;md_block&quot;&gt;&lt;span class=&quot;md_line md_line_start md_line_end&quot;&gt;当我写下来后，意外发现第7条给我的能量最大，毕竟人是追求存在感的。所以读完后，第一件事就去朋友圈得瑟，当然这篇文章也算。&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;md_block md_has_block_below md_has_block_below_ol&quot;&gt;&lt;span class=&quot;md_line md_line_start&quot;&gt;很多时候，我们决定干一件事情后，总是只做好开头，后面就放飞自我，不了了之。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md_block md_has_block_below md_has_block_below_ol&quot;&gt;&lt;span class=&quot;md_line md_line_start&quot;&gt;&lt;span class=&quot;line_char&quot;&gt;&lt;span class=&quot;md_line&quot;&gt;比如看一本书，基本都是看序一行行看，第一章一段段看，第二章一页页看，中间一章章看，后面直接翻过去完事。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md_block md_has_block_below md_has_block_below_ol&quot;&gt;&lt;span class=&quot;md_line md_line_start&quot;&gt;&lt;span class=&quot;line_char&quot;&gt;&lt;span class=&quot;md_line&quot;&gt;&lt;span class=&quot;line_char&quot;&gt;&lt;span class=&quot;md_line&quot;&gt;这在系统思维里叫“目标侵蚀”，也就是我们对事情的标准是会随时间逐渐降低的。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md_block md_has_block_below md_has_block_below_ol&quot;&gt;&lt;span class=&quot;md_line md_line_start&quot;&gt;&lt;span class=&quot;line_char&quot;&gt;&lt;span class=&quot;md_line&quot;&gt;&lt;span class=&quot;line_char&quot;&gt;&lt;span class=&quot;md_line&quot;&gt;&lt;span class=&quot;line_char&quot;&gt;&lt;span class=&quot;md_line&quot;&gt;比如计划了早起，然后一天比一天起得晚；安排了去跑步，后面跑着跑着就不跑了。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md_block md_has_block_below md_has_block_below_ol&quot;&gt;&lt;span class=&quot;md_line md_line_start&quot;&gt;&lt;span class=&quot;line_char&quot;&gt;&lt;span class=&quot;md_line&quot;&gt;&lt;span class=&quot;line_char&quot;&gt;&lt;span class=&quot;md_line&quot;&gt;&lt;span class=&quot;line_char&quot;&gt;&lt;span class=&quot;md_line&quot;&gt;&lt;span class=&quot;line_char&quot;&gt;&lt;span class=&quot;md_line&quot;&gt;要防止这种情况，我们必须设定标准。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md_block md_has_block_below md_has_block_below_ol&quot;&gt;&lt;span class=&quot;md_line md_line_start&quot;&gt;&lt;span class=&quot;line_char&quot;&gt;&lt;span class=&quot;md_line&quot;&gt;&lt;span class=&quot;line_char&quot;&gt;&lt;span class=&quot;md_line&quot;&gt;&lt;span class=&quot;line_char&quot;&gt;&lt;span class=&quot;md_line&quot;&gt;&lt;span class=&quot;line_char&quot;&gt;&lt;span class=&quot;md_line&quot;&gt;如果实在不想搞，也按最低标准做下去，同时，也要设定最高投入标准，不能一开心就忘记时间的投入，这是不能长久的，要慢慢来，持续做。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md_block md_has_block_below md_has_block_below_ol&quot;&gt;&lt;span class=&quot;md_line md_line_start&quot;&gt;&lt;span class=&quot;line_char&quot;&gt;&lt;span class=&quot;md_line&quot;&gt;&lt;span class=&quot;line_char&quot;&gt;&lt;span class=&quot;md_line&quot;&gt;&lt;span class=&quot;line_char&quot;&gt;&lt;span class=&quot;md_line&quot;&gt;&lt;span class=&quot;line_char&quot;&gt;&lt;span class=&quot;md_line&quot;&gt;&lt;span class=&quot;line_char&quot;&gt;&lt;span class=&quot;md_line md_line_end&quot;&gt;如下，这是我看这本书前设定标准，标准适中，有上下限，不用严格执行，只要维持在一定范围波动就可以。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li class=&quot;md_li&quot;&gt;笔记标准，每章必须摘录所有标题结构、摘要和所有加粗字，有代码示例的自己写or摘抄一段，记录所有检查清单 。&lt;/li&gt;
&lt;li class=&quot;md_li&quot;&gt;阅读标准，顺序阅读，每天阅读量不超过两章。&lt;/li&gt;
&lt;li class=&quot;md_li&quot;&gt;时间标准，用番茄钟，每次阅读25分钟停下休息。&lt;/li&gt;
&lt;/ol&gt;&lt;p class=&quot;md_block&quot;&gt;&lt;span class=&quot;md_line md_line_start md_line_end&quot;&gt;做完这两手准备，打开日期，把时间往前拨20天，任务就轻松完成了。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md_block&quot;&gt;&lt;span class=&quot;md_line md_line_start md_line_end&quot;&gt;以上&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 15 Dec 2018 07:30:00 +0000</pubDate>
<dc:creator>初开</dc:creator>
<og:description>从11月24日到12月15日，20天内，投入22个小时又20分钟，从头到尾通读完了这本代码大全，每一章都按同样的标准做了笔记，共1.7w字。 从本书本身的学到的倒是其次，最关键的是，我点亮了一个新技能</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wchukai/p/10123507.html</dc:identifier>
</item>
<item>
<title>【高速接口-RapidIO】6、RapidIO核仿真与包时序分析 - jgliu</title>
<link>http://www.cnblogs.com/liujinggang/p/10123498.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liujinggang/p/10123498.html</guid>
<description>&lt;h2&gt;一、软件平台与硬件平台&lt;/h2&gt;
&lt;p&gt;　　软件平台：&lt;/p&gt;
&lt;p&gt;       　　操作系统：Windows 8.1 64-bit&lt;/p&gt;
&lt;p&gt;       　　开发套件：Vivado2015.4.2&lt;/p&gt;
&lt;p&gt;　　硬件平台：&lt;/p&gt;
&lt;p&gt;       　　评估板：ZYNQ-7 ZC706 Evaluation Board&lt;/p&gt;
&lt;h2&gt;二、介绍&lt;/h2&gt;
&lt;p&gt;　　上篇文章的最后一小节已经对例子工程进行仿真并通过命令 log_wave –r /* 记录了所有信号的波形，这篇文章主要介绍RapidIO核的仿真以及包时序的分析。&lt;/p&gt;
&lt;p&gt;       调试SRIO核时必须对包在不同接口的传输过程有一个清晰的了解，能够识别出不同接口上包的类型并正确的解析出包的内容。&lt;/p&gt;
&lt;p&gt;       本文详细的介绍了SRIO包（控制符号与数据字符）在不同接口上的组成与传输过程，并深入到逻辑层、传输层以及物理层来观察RapidIO串行物理层包的传输细节。整个包与信号分析的过程完全基于RapidIO提供的例子工程，例子工程的产生与源代码的分析已经在上一篇文章《Xilinx RapidIO核例子工程源码分析》（链接：https://www.cnblogs.com/liujinggang/p/10091216.html）提到过，这里不再赘述。最后，本文会利用RapidIO核做一个回环测试（Loopback Test）的工程在ZC706上运行，由于RapidIO是一个付费的IP核，所以生成bit文件需要License，没有License的可以在官网（https://www.xilinx.com/products/intellectual-property/ef-di-srio-gen2.html#overview）申请一个30天的评估版License试用，评估版的License生成的bit文件运行一段时间以后会自动失效，要想永久使用必须购买官方的License。&lt;/p&gt;
&lt;h2&gt;三、例子工程结构&lt;/h2&gt;
&lt;p&gt;       下图整个例子工程的结构层次&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1426240/201812/1426240-20181215145158532-9260093.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       它由一个仿真顶层的testbench和两个SRIO核顶层组成。其中顶层的testbench文件srio_sim.v连接了两个srio例子设计顶层，其中一个例子设计顶层叫做srio_example_top_primary，它代表请求方的RapidIO设备；另一个例子设计顶层叫做srio_example_top_mirror，它代表响应方的RapidIO设备。&lt;/p&gt;
&lt;p&gt;       SRIO例子工程顶层文件srio_example_top.v例化了SRIO核的所有组件以及需要在硬件上执行的必要模块。这些模块包括：&lt;/p&gt;
&lt;p&gt;       1、时钟域复位模块（srio_clk.v和srio_rst.v）&lt;/p&gt;
&lt;p&gt;       2、配置结构（cfg_fabric.v）&lt;/p&gt;
&lt;p&gt;       3、请求事务与响应事务生成模块（srio_resquest_gen.v和srio_response_gen.v）&lt;/p&gt;
&lt;p&gt;       4、维护事务生成模块（srio_quick_start.v）&lt;/p&gt;
&lt;p&gt;       顶层模块srio_example_top中例化了srio_quick_start模块，它与SRIO的维护端口相连，用来生成维护事务（Maintenance Transactions）。这个模块用来向本地（Local）或远程（Remote）的配置寄存器空间发送一组固定的指令集，用户可以编辑maintenance_list.v来添加、修改或移除维护事务。&lt;/p&gt;
&lt;p&gt;srio_request_gen在顶层模块srio_example_top进行例化，它用来产生I/O事务或消息（MESSAGE）事务，但仅仅SRIO核支持的事务类型能被产生，这个模块也存储了期望的响应事务并与实际接收到的响应事务进行对比用来确定整个事务交互过程的正确性。&lt;/p&gt;
&lt;p&gt;srio_response_gen也在顶层模块srio_example_top进行例化，它用来产生请求事务对应的响应事务。&lt;/p&gt;
&lt;p&gt;　　整个例子工程结构层次的软件框架如下图所示，其中左边的srio_example_top模块表示请求方的RapidIO设备，而右边的DUT Mirror表示响应方的RapidIO设备，它们的内部结构完全相同，区别仅仅在于一个作为请求方而另一个为响应方。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1426240/201812/1426240-20181215145222332-1527521571.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       SRIO核的原理框图以及接口如下图所示&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1426240/201812/1426240-20181215145232797-173387726.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       为了方便说明，上图每一个接口都用相应的数字标注出来。它们分别为&lt;/p&gt;
&lt;p&gt;       &lt;strong&gt;Initiator/Target IO Port&lt;/strong&gt;&lt;strong&gt;（接口1）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       例子工程中SRIO核全部为默认参数，所以端口类型默认被配置为Initiator/Target，在Initiator/Target接口类型中请求事务与响应事务在不同的AXI4-Stream通道上进行传输。SRIO核的端口类型也能被配置为Condensed I/O类型，在Condensed I/O接口类型中请求事务与响应事务在同一AXI4-Stream通道上进行传输，所以Condensed I/O相比于Initiator/Target类型来说接口更加精简。本文仍然采用默认的Initiator/Target接口类型来分析每个包的传输过程。&lt;/p&gt;
&lt;p&gt;       接口1的数据传输协议为AXI4-Stream协议，它的接口定义如下：&lt;/p&gt;
&lt;p&gt;       s_axis_ireq_* 表示Initiator请求事务的传输通道（i = initiator ,req = request）&lt;/p&gt;
&lt;p&gt;　　m_axis_iresp_* 表示Initiator响应事务的传输通道（i = initiator ,resp = response）&lt;/p&gt;
&lt;p&gt;　　m_axis_treq_* 表示Target请求事务的传输通道（t = target ,req = request）&lt;/p&gt;
&lt;p&gt;　　s_axis_iresp_* 表示Target响应事务的传输通道（t = target , resp = response）&lt;/p&gt;
&lt;p&gt;       &lt;strong&gt;Maintenance Port&lt;/strong&gt;&lt;strong&gt;（接口2）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       接口2的数据传输协议为AXI4-Lite协议，用来传输维护事务。它的接口定义如下：&lt;/p&gt;
&lt;p&gt;       s_axi_maintr_* 表示维护事务的传输端口（maintr = maintenance）&lt;/p&gt;
&lt;p&gt;       &lt;strong&gt;LOG Configuration Fabric&lt;/strong&gt;&lt;strong&gt;（接口3）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       接口3的数据传输协议为AXI4-Lite协议，它是逻辑层的配置结构端口，包括本地（Local）配置端口和远程（Remote）配置端口。它的接口定义如下：&lt;/p&gt;
&lt;p&gt;       s_axi_cfgl_* 表示本地配置端口（cfg = configuration，l = local）&lt;/p&gt;
&lt;p&gt;　　m_axi_cfgr_* 表示远程配置端口（cfg = configuration，r = remote）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　LOG Transport Interface&lt;/strong&gt;&lt;strong&gt;（接口4）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       接口4的数据传输协议为AXI4-Stream协议，它是逻辑层与Buffer的数据传输接口，包括发送和接收两个通道。它的接口定义如下：&lt;/p&gt;
&lt;p&gt;       m_axis_buft_* 表示发送端口（buf = buffer，t = transmit）&lt;/p&gt;
&lt;p&gt;　　s_axis_ bufr_* 表示接收端口（buf = buffer，r = receive）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　BUF Link Interface&lt;/strong&gt;&lt;strong&gt;（接口5）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       接口5的数据传输协议为AXI4-Stream协议，它是Buffer层与物理层的数据传输接口，包括发送和接收两个通道。它的接口定义如下：&lt;/p&gt;
&lt;p&gt;       m_axis_phyt_* 表示发送端口（phy= physical，t = transmit）&lt;/p&gt;
&lt;p&gt;　　s_axis_ phyr_* 表示接收端口（phy = physical，r = receive）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　BUF Configuration Fabric&lt;/strong&gt;&lt;strong&gt;（接口6）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       接口6的数据传输协议为AXI4-Lite协议，它是Buffer层的配置端口。它的接口定义如下：&lt;/p&gt;
&lt;p&gt;       s_axi_bcfg_* 表示Buffer层配置端口（b = buffer，cfg = configuration）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　PHY Serial Interface&lt;/strong&gt;&lt;strong&gt;（接口7）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       接口7为物理层串行链路接口，它是物理层数据与串行收发器（Serial Transceivers）数据交换通道，它的接口定义如下所示：&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;22.5&quot;&gt;&lt;tr&gt;&lt;td width=&quot;260&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;信号&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;83&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;方向&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;349&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;功能&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td width=&quot;260&quot;&gt;
&lt;p align=&quot;center&quot;&gt;gttx_data[32*LW-1 : 0]&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;83&quot;&gt;
&lt;p align=&quot;center&quot;&gt;Output&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;349&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;发送给串行收发器（Serial Transceivers）的数据&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td width=&quot;260&quot;&gt;
&lt;p align=&quot;center&quot;&gt;gttx_charisk[4*LW-1 : 0]&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;83&quot;&gt;
&lt;p align=&quot;center&quot;&gt;Output&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;349&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;gttx_data信号中有效字节指示信号。当这个信号某一位为0时，gttx_data中对应的字节为包的有效字节。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td width=&quot;260&quot;&gt;
&lt;p align=&quot;center&quot;&gt;gttx_inhibit[LW-1:0]&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;83&quot;&gt;
&lt;p align=&quot;center&quot;&gt;Output&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;349&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;串行收发器的通道使能位。如果最低位（bit-0）为1，表示发送通道0（Lane0）不使能，其余依次类推&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td width=&quot;260&quot;&gt;
&lt;p align=&quot;center&quot;&gt;gtrx_data[32*LW-1:0]&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;83&quot;&gt;
&lt;p align=&quot;center&quot;&gt;Input&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;349&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;从串行收发器（Serial Transceivers）接收的数据&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td width=&quot;260&quot;&gt;
&lt;p align=&quot;center&quot;&gt;gtrx_charisk[4*LW-1:0]&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;83&quot;&gt;
&lt;p align=&quot;center&quot;&gt;Input&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;349&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;gtrx_data信号中有效字节指示信号。当这个信号某一位为0时，gttx_data中对应的字节为包的有效字节。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td width=&quot;260&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;center&quot;&gt;gtrx_chariscomma[4*LW-1:0]&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;83&quot;&gt;
&lt;p align=&quot;center&quot;&gt;Input&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;349&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;gtrx_data信号中comma指示信号。如果最低位（bit-0）为1，表示gtrx_data[7:0]是包含comma的字符，其余依次类推&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td width=&quot;260&quot;&gt;
&lt;p align=&quot;center&quot;&gt;gtrx_disperr[4*LW-1:0]&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;83&quot;&gt;
&lt;p align=&quot;center&quot;&gt;Input&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;349&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;gtrx_data信号中不一致错误（Disparity Error）指示信号。如果最低位（bit-0）为1，表示gtrx_data[7:0]中存在不一致错误，其余依次类推&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td width=&quot;260&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;center&quot;&gt;gtrx_notintable[4*LW-1:0]&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;83&quot;&gt;
&lt;p align=&quot;center&quot;&gt;Input&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;349&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;gtrx_data信号中not-in-table错误指示信号。Table指的是8b/10b编码解码表。如果最低位（bit-0）为1，表示gtrx_data[7:0]中8b/10b解码错误，其余依次类推&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td width=&quot;260&quot;&gt;
&lt;p align=&quot;center&quot;&gt;gtrx_chanbondseq[LW-1:0]&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;83&quot;&gt;
&lt;p align=&quot;center&quot;&gt;Input&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;349&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;串行收发器每个链路的通道绑定序列（Channel Bonding Sequence）指示信号，如果最低位（bit-0）为1，表示链路0（Lane0）收到了一串通道绑定序列，其余依次类推&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td width=&quot;260&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;center&quot;&gt;gtrx_chanisaligned[LW-1:0]&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;83&quot;&gt;
&lt;p align=&quot;center&quot;&gt;Input&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;349&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;串行收发器每个链路的通道对齐（Channel Alignment）指示信号，如果最低位（bit-0）为1，表示链路0（Lane0）已经实现了通道对齐，其余依次类推&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td width=&quot;260&quot;&gt;
&lt;p align=&quot;center&quot;&gt;gtrx_chanbonden&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;83&quot;&gt;
&lt;p align=&quot;center&quot;&gt;Output&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;349&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;串行收发器通道绑定使能信号&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td width=&quot;260&quot;&gt;
&lt;p align=&quot;center&quot;&gt;gtrx_reset_req&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;83&quot;&gt;
&lt;p align=&quot;center&quot;&gt;Input&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;349&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;串行请求复位信号。例如，由于串行收发器接收通路弹性FIFO的上溢（overflow）或下溢（underflow），&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td width=&quot;260&quot;&gt;
&lt;p align=&quot;center&quot;&gt;gtrx_reset&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;83&quot;&gt;
&lt;p align=&quot;center&quot;&gt;Output&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;349&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;串行收发器的复位信号&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td width=&quot;260&quot;&gt;
&lt;p align=&quot;center&quot;&gt;gtrx_reset_done[LW-1:0]&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;83&quot;&gt;
&lt;p align=&quot;center&quot;&gt;Input&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;349&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;串行收发器每个链路的复位完成指示信号，如果最低位（bit-0）为1，表示链路0（Lane0）已经复位完成，其余依次类推&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;　　PHY Configuration Fabric&lt;/strong&gt;&lt;strong&gt;（接口8）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       接口8的数据传输协议为AXI4-Lite协议，它是物理层（Physical）的配置端口。它的接口定义如下：&lt;/p&gt;
&lt;p&gt;       s_axi_cfgp_* 表示物理层配置端口（cfg = configuration，p = physical）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　Transceiver Interface&lt;/strong&gt;&lt;strong&gt;（接口9）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       接口9为串行收发器高速数据传输接口，每条串行数据传输线均为一对差分信号。它的接口定义如下：&lt;/p&gt;
&lt;p&gt;       srio_rxpN ，srio_rxnN：N为通道号，接收链路差分对，N的值为1、2或4。&lt;/p&gt;
&lt;p&gt;       srio_txpN ，srio_txnN：N为通道号，发送链路差分对，N的值为1、2或4。&lt;/p&gt;
&lt;h2&gt;四、SRIO核包时序分析&lt;/h2&gt;
&lt;p&gt;       上篇文章《Xilinx RapidIO核例子工程源码分析》（链接：https://www.cnblogs.com/liujinggang/p/10091216.html）的最后一小节已经详细介绍了仿真的全部流程以及利用log_wave –r /*命令记录所有信号波形的方法，这里不再赘述。这一节默认大家已经仿真完毕（仿真结束大约需要20min左右时间，仿真完毕记得保存波形），并得到了仿真的波形，下面就对其中重要的波形进行分析。&lt;/p&gt;
&lt;p&gt;       在分析之前，在重新回顾一下RapidIO串行物理层的包与控制符号的格式&lt;/p&gt;
&lt;p&gt;       串行物理层的包：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1426240/201812/1426240-20181215145342167-363346442.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　控制符号：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1426240/201812/1426240-20181215145405190-215116137.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;4.1 链路初始化与控制符号&lt;/h3&gt;
&lt;p&gt;　　调试SRIO的第一步是去检测SRIO顶层模块（srio_example_top_primary）中的各个关键的控制信号是否正确切换。这些信号包括：复位信号、时钟锁定信号（clk_lock）、端口初始化信号（port_initialized）、链路初始化信号（link_initialized），端口错误信号（port_error），mode_1x信号（在2x和4x模式下，这个信号为高表示SRIO核已经被训练为1x模式，在1x模式下，这个信号一直为高，当port_initialized为高时，这个信号才有效）与端口解码错误信号（port_decode_error）等（除了这几个信号以外，其他信号也可以观察一下）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　Step1&lt;/strong&gt;、把srio_example_top_primary中的所有信号全部选中，然后直接拖到右边的波形窗口&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1426240/201812/1426240-20181215145426316-1997794651.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　Step2&lt;/strong&gt;、找到上面提到的几个关键控制信号，观察它们的波形&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1426240/201812/1426240-20181215145443873-1378245322.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       由上图可以看出，控制信号的波形均切换正确，其中最关键的两个信号是port_initialized信号与link_initialized信号，当它们为高时，分别表示端口和链路被成功初始化。&lt;/p&gt;
&lt;p&gt;       下图是时钟信号和复位信号的时序细节，显然，时钟信号与复位信号的时序均正确。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1426240/201812/1426240-20181215145456033-1523615147.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　Step3&lt;/strong&gt;、pg007_srio_gen2.pdf第119页提到，当7个连续的error free控制符号被接收，并且15个连续的符号被发送的时候，link_initialized信号才被拉高，所以接下来看看link_initialized信号拉高之前物理层是否接收了7个控制符号并发送了15个控制符号。&lt;/p&gt;
&lt;p&gt;首先选中最左边的srio_gen2_0_block_inst，然后把中间列出的以gt开头的接口7的所有信号拖到最右边的波形窗口中，如下图所示&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1426240/201812/1426240-20181215145511903-1694137278.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       在link_initialized拉高之前，观察gttx_data，gttx_charisk与gtrx_data，gtrx_charisk总线上的数据，建议把gttx_charisk与gtrx_charisk用二进制显示，当gttx_charisk与gtrx_charisk对应的位为0时，表明gttx_data与gtrx_data上的数据为有效数据（控制符号与包属于有效数据）。当gttx_charisk与gtrx_charisk对应的位为1时，gttx_data与gtrx_data上的数据为空闲序列。如下图所示，当link_initialized拉高之前gttx_data上发送了15个连续的控制符号，gtrx_data上接收了7个连续的控制符号。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1426240/201812/1426240-20181215145529620-1849639240.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       下面把控制符号波形放大观察控制符号各个字段的细节,发送与接收总线上的控制符号分别如下图所示（gttx_charisk与gtrx_charisk对应的位为0时, gttx_data与gtrx_data上的数据为控制符号）&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1426240/201812/1426240-20181215145542708-1872674206.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;       上图表明在link_initialized拉高之前，发送与接收的控制符号为80f713，控制符号80f713前面的1c是/K28.0/，表示控制符号的起始位置。由于SRIO核默认使用的是短控制符号，所以这里控制符号为24-bit。&lt;/p&gt;
&lt;p&gt;　　把80f713转化为二进制：80f713 = 1000_0000_1111_0111_0001_0011，各个字段的对应关系如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1426240/201812/1426240-20181215153821919-2139689957.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　当gttx_charisk与gtrx_charisk对应的位为1时，gttx_data与gtrx_data上的数据为/K/，/R/，/A/组成的空闲随机序列（前面几篇文章解释过这个知识点），它们分别为特殊字符/K28.5/，/K29.7/，/K27.7/，转化为16进制为bc，fd，fb，下图是它们的波形&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1426240/201812/1426240-20181215145707820-1446078116.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　整个初始化的过程着重需要关注的两个信号就是port_initialized和link_initialized，如果初始化失败（port_initialized和link_initialized没有被拉高），那么首先必须检查gttx_data与gtrx_data上是否收到了空闲序列/K28.5/，/K29.7/，/K27.7/，同时需要检查是否存在编解码错误，编解码错误的判断标志是gtrx_notintable信号，当它为1时表明存在编解码错误。&lt;/p&gt;
&lt;h3&gt;4.2 SWRITE事务&lt;/h3&gt;
&lt;p&gt;　　上篇文章已经分析过，例子工程会把instruction_list.vh中定义的事务按顺序依次发出去。其中最先发送的是37个SWRITE事务，然后是19个NWRITE_R事务、 19个NWRITE事务、26个NREAD事务，2个DOORBELL事务，最后是17个MESSAGE事务。其中第一个发送的事务是instruction_list.vh中第50行定义的SWRITE事务。如下图所示&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1426240/201812/1426240-20181215145730128-1869945271.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　下面以上图第50行的SWRITE事务为例来说明整个SWRITE事务的传输过程。这个事务表示的是利用SWRITE事务往地址36’hCD0000600发送16个字节的数据。&lt;/p&gt;
&lt;p&gt;       &lt;strong&gt;Step1&lt;/strong&gt;、选中srio_example_top_primary，把中间列出的所有信号全部拖到波形窗口中（拖到波形窗口前可以把之前波形窗口中的信号全部删掉）&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1426240/201812/1426240-20181215145742766-969252999.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       &lt;strong&gt;Step2&lt;/strong&gt;、找到请求事务的传输通道ireq，并抓出事务的波形如下图所示&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1426240/201812/1426240-20181215145800405-1792207730.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　由于仅当tvalid和tready同时为高时，tdata上的数据才为有效数据，所以这个SWRITE一共消耗了三个有效时钟周期，其中第一个时钟周期发送的是HELLO包头，后面两个时钟周期分别发送8个字节的数据（第一个时钟发送的数据是0000000000000000，第二个时钟发送的数据是0101010101010101），一共16个字节的数据，和instruction_list.vh中第50行定义完全一致，整个时序也与HELLO格式的时序完全吻合。&lt;/p&gt;
&lt;p&gt;       &lt;strong&gt;Step3&lt;/strong&gt;、对照HELLO格式解析包头。包头为006020fcd0000600，转化为二进制后与HELLO格式各个字段对应关系如下所示：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1426240/201812/1426240-20181215145818818-1664977568.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　由上图可知FTYPE字段的值为6，表明确实是一个SWRITE事务&lt;/p&gt;
&lt;p&gt;       &lt;strong&gt;Step4&lt;/strong&gt;、SWRITE事务通道ireq通道（接口1）传输给SRIO核以后进入SRIO的逻辑层，逻辑层会给包添加传输层的信息发送给Buffer（接口3），然后Buffer会把数据发送给物理层（接口5）。&lt;/p&gt;
&lt;p&gt;       选中srio_gen2_0_block_inst，把中间的buft_*通道、phyt_*通道与gttx_*通道的信号拖到右边的波形窗口中，如下图所示&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1426240/201812/1426240-20181215145839488-1468971379.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       整个从逻辑层到传输层到物理层到吉比特收发器（Gigabit Transceiver）的波形如下图所示，波形的细节这里不再展开，大家可以自己抓出来观察。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1426240/201812/1426240-20181215145855716-665160056.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       &lt;strong&gt;Step5&lt;/strong&gt;、ireq通道的SWRITE请求事务经过逻辑层，传输层和物理层到达吉比特收发器（Gigabit Transceiver），吉比特收发器的数据通道gttx_data[31:0]（接口7）波形如下图所示&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1426240/201812/1426240-20181215145908494-635136423.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　由上图可知，整个串行物理层的包为：&lt;span&gt;7c96f004&lt;/span&gt;&lt;span&gt;_b04600ad_d0000600_00000000_00000000_01010101_01010101_e8d30000_&lt;/span&gt;&lt;span&gt;7c96f203&lt;/span&gt;。（00000000和01010101的宽度为两个有效时钟）这个包的含义如下：&lt;/p&gt;
&lt;p&gt;       &lt;span&gt;7c96f004&lt;/span&gt;中的7c是特殊字符/K28.3/，它是一个包界定符（Packet Deliminator Control Symbol），96f004转化为二进制为：&lt;/p&gt;
&lt;p&gt;　　96f004 = 1001_0110_1111_0000_0000_0100&lt;/p&gt;
&lt;p&gt;　　它是一个包起始控制符号，各个字段的对应关系如下图所示&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1426240/201812/1426240-20181215150022398-411559146.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;b04600ad_d0000600_00000000_00000000_01010101_01010101_e8d30000&lt;/span&gt;是SWRITE事务串行物理层的包，把它转化为二进制后各个字段的对应关系如下图所示&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1426240/201812/1426240-20181215150048192-864191901.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　上图中data字段是传输的00000000_00000000_01010101_01010101这16个字节数据的二进制码，因为它的二进制码太长了所以我直接用data替代。由于本次传输的字节小于80个字节，所以SWRITE事务的最后面的三个字段不存在，大家可以抓一下数据量为256个字节的SWRITE包，当数据量大于了80字节，后面的三个字段也会有数据。&lt;/p&gt;
&lt;p&gt;       包最后面的&lt;span&gt;7c96f203&lt;/span&gt;中7c是特殊字符/K28.3/，它是一个包界定符（Packet Deliminator Control Symbol），96f203转化为二进制为：&lt;/p&gt;
&lt;p&gt;　　96f203= 1001_0110_1111_0010_0000_0011&lt;/p&gt;
&lt;p&gt;　　它是一个包结束控制符号，各个字段的对应关系如下图所示&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1426240/201812/1426240-20181215150150641-532173213.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　至此，SWRITE事务全部分析完毕。&lt;/p&gt;
&lt;h3&gt;4.3 NWRITE_R事务&lt;/h3&gt;
&lt;p&gt;　　本小节以instruction_list.vh中第72行定义的NWRITE_R事务为例来说明整个NWRITE_R事务的传输过程。如下图所示，这个事务表示的是利用NWRITE_R事务往地址36’ h004550002发送6（size+1）个字节的数据。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1426240/201812/1426240-20181215150207566-276786409.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       &lt;strong&gt;Step1&lt;/strong&gt;、为了方便快速的找到上图的NWRITE_R事务，建议选中srio_request_gen模块，并把request_address变量拖到波形窗口中，并把这个变量用Unsigned Decimal（无符号10进制）格式显示。看过上篇《Xilinx RapidIO核例子工程源码分析》文章的应该知道这个变量是instruction的索引值，当这个变量为37的时候就表示37（0~36）个SWRITE事务全部发送完毕，下个事务就是instruction_list.vh中第72行定义的NWRITE_R事务。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1426240/201812/1426240-20181215150219613-1203215007.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　Step2&lt;/strong&gt;、锁定request_address为37的位置，找到请求事务的传输通道ireq，并观察事务的波形如下图所示&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1426240/201812/1426240-20181215150301454-2114008386.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　由上图可知第一个有效时钟传输的HELLO格式包头数据为：2555205004550002。发送的数据是afafafafafafafaf。包头与HELLO包格式的对应关系如下图所示&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1426240/201812/1426240-20181215150314246-1832027024.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　由上图可知FTYPE = 5，TTYPE = 5，这两个字段唯一的确定了这是一个NWRITE_R事务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　Step3&lt;/strong&gt;、ireq通道的NWRITE_R请求事务经过逻辑层，传输层和物理层到达吉比特收发器（Gigabit Transceiver），吉比特收发器的数据通道gttx_data[31:0]（接口7）波形如下图所示&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1426240/201812/1426240-20181215150333633-2090633899.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　由上图可知，整个串行物理层的包为：&lt;span&gt;7c98f009&lt;/span&gt;&lt;span&gt;_d84500ad_59250455_0000afaf_afafafaf_afafad15_&lt;/span&gt;&lt;span&gt;7c17f21e&lt;/span&gt;。这个包的含义如下：&lt;/p&gt;
&lt;p&gt;       &lt;span&gt;7c98f009&lt;/span&gt;中的7c是特殊字符/K28.3/，它是一个包界定符（Packet Deliminator Control Symbol），98f009转化为二进制为：&lt;/p&gt;
&lt;p&gt;　　98f009= 1001_1000_1111_0000_0000_1001&lt;/p&gt;
&lt;p&gt;　　它是一个包起始控制符号，各个字段的对应关系如下图所示&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1426240/201812/1426240-20181215150427214-1908356688.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;d84500ad_59250455_0000afaf_afafafaf_afafad15&lt;/span&gt;是NWRITE_R事务串行物理层的包，把它转化为二进制后各个字段的对应关系如下图所示&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1426240/201812/1426240-20181215150451748-1788436060.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　上图中data字段是传输的afafafaf_afafafaf这16个字节数据的二进制码，因为它的二进制码太长了所以我直接用data替代。由于本次传输的总字节数为8字节的整数倍，所以NWRITE_R事务的后面可选的logical 0 pad（opt）没有数据。&lt;/p&gt;
&lt;p&gt;       细心的人在这里可能发现了一个奇怪的现象：在HELLO格式中，address字段为36’ h004550002，其中高两位为保留位，所以address一共只有34-bit有效位，size字段为5，表示往36’ h004550002地址中写6（size+1）个字节的数据。但是上面串行物理层的包中address字段的值为0000_0100_0101_0101_0000_0000_0000_0，发送的数据个数为8个字节（afafafaf_afafafaf）。出现这种现象的原因为：&lt;/p&gt;
&lt;p&gt;       HELLO格式address字段指向的存储空间的最小单元是1个字节，而串行物理层中的address字段指向的存储空间最小单元实际上是8个字节，address后面的xambsb字段是串行物理层的最高两位地址扩展字段，所以串行物理层的包可访问的存储空间大小为2^34=16G，这也是HELLO格式中address字段位宽为34-bit的原因（关于这部分的内容我在《RapidIO协议概述》也提到过）。正因为HELLO格式address字段与串行物理层address字段所指向的存储空间最小单元不同，所以pg007_srio_gen2.pdf中第78页才给出了一个HELLO格式size，addr与有效字节的对应关系表，如下所示&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1426240/201812/1426240-20181215150518686-1915232608.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　本例中size=5，addr[2:0] = 2，对应于上图中红框圈出来的情况。所以往36’ h004550002地址中写6（size+1）个字节的数据对串行物理层来说就是往36’ h004550000地址中写8个字节的数据，高6个字节（上图中灰色区域）为有效数据。&lt;/p&gt;
&lt;p&gt;　　包最后面的&lt;span&gt;7c17f21e&lt;/span&gt;中7c是特殊字符/K28.3/，它是一个包界定符（Packet Deliminator Control Symbol），17f21e转化为二进制为：&lt;/p&gt;
&lt;p&gt;　　17f21e = 0001_0111_1111_0010_0001_1110&lt;/p&gt;
&lt;p&gt;　　它是一个包结束控制符号，各个字段的对应关系如下图所示&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1426240/201812/1426240-20181215150545936-1024287470.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;　　Step4&lt;/strong&gt;、例子工程中例化了srio_example_top_primary与srio_example_top_mirror两个实体，srio_example_top_primary实体的srio_txp0和srio_txn0连接到srio_example_top_mirror实体的srio_rxp0和srio_rxn0。因此，srio_example_top_mirror的gtrx_data上的数据应该和上一步分析的srio_example_top_primary实体的gttx_data完全相同。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　选中srio_example_top_mirror的srio_gen2_0_block_inst,把gtrx_data与gtrx_charisk两个信号拖到右边的窗口中，如下图所示&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1426240/201812/1426240-20181215150605395-2012853254.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;       观察srio_example_top_primary的gttx_data与srio_example_top_mirror的gtrx_data，如下图所示，可以看到两者完全相同，仅仅存在一个延时。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1426240/201812/1426240-20181215150621656-2074237947.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;　　Step5&lt;/strong&gt;、srio_example_top_mirror模块的grrx_data接收到数据以后，将会把grrx_data的数据按照与发送过程完全相反的操作传到逻辑层，最终逻辑层的数据将会通过srio_example_top_mirror模块的treq接口输出。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　选中srio_example_top_mirror，把treq通道的所有信号拖到右边的波形窗口中&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1426240/201812/1426240-20181215150644806-2027253682.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　下图是srio_example_top_mirror模块treq通道的波形&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1426240/201812/1426240-20181215150702912-2027955106.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　可知treq通道的包头数据为2555205004550002，与srio_example_top_primary模块ireq通道发送的包头数据完全一样。这也证明整个链路工作正常。&lt;/p&gt;
&lt;h3&gt;4.4 NWRITE_R的响应事务&lt;/h3&gt;
&lt;p&gt;　　由于NWRITE_R事务是一个有响应的写事务，所以当发起方（Initiator）往目标方（Target）发送一个NWRITE_R事务以后，发起方（Initiator）还要接收目标方（Target）的发回响应事务。响应包的数据会出现在srio_example_top_primary模块的tresp通道，下图是srio_example_top_primary模块的tresp通道的时序图&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1426240/201812/1426240-20181215150724544-785595937.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　由上图可知iresp_tdata的数据为：25d0400000000000。与HELLO包格式的对应关系如下图所示&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1426240/201812/1426240-20181215150741236-267973624.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　由上图可知FTYPE = 13，所以这是一个响应事务，prio字段变成了2，而NWRITE_R字段的prio字段为1，这是因为响应事务的prio为请求事务的prio+1,（这个知识点前两篇文章都提到过）&lt;/p&gt;
&lt;p&gt;       事实上，响应事务的一整套传输流程为：目标方（Target）发回的响应事务被srio_example_top_primary模块的串行差分信号线接收到达Serial Transceivers，Serial Transceivers在把接收的数据通过gtrx_data通道（接口7）传到物理层，物理层把接收的包经过处理以后通过phyr_*通道（接口5）把数据发给Buffer层，Buffer层对数据进行二次处理以后把数据通过bufr_*通道（接口4）传给逻辑层，逻辑层再把数据传输给I/O端口（接口1），这样就得到了上图HELLO格式的响应包。大家可以把gtrx_data、phyr_*通道、bufr_*通道和I/O端口的波形全部抓出来观察一下，方法和上节介绍发送流程的抓取过程完全一样。这里我只抓一下gtrx_data通道的数据，并分析响应事务串行物理层包格式各个字段的含义。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　gtrx_data通道的数据如下图所示&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1426240/201812/1426240-20181215150800135-762868327.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　由上图可知，整个响应事务串行物理层的包为：&lt;span&gt;7c83f00f&lt;/span&gt;&lt;span&gt;_388dadad_00255540_&lt;/span&gt;&lt;span&gt;7c83f208&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;       &lt;span&gt;7c83f00f&lt;/span&gt;中的7c是特殊字符/K28.3/，它是一个包界定符（Packet Deliminator Control Symbol），83f00f转化为二进制为：&lt;/p&gt;
&lt;p&gt;　　83f00f = 1000_0011_1111_0000_0000_1111&lt;/p&gt;
&lt;p&gt;　　它是一个包起始控制符号，各个字段的对应关系如下图所示&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1426240/201812/1426240-20181215150851673-954633933.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　388dadad_00255540&lt;/span&gt;是NWRITE_R响应事务串行物理层的包，把它转化为二进制后各个字段的对应关系如下图所示&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1426240/201812/1426240-20181215150911821-1263942271.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　由于NWRITE_R的响应事务不带数据，所以没有data字段。target TID字段的值为16进制的25，也就是10进制的37，与发送的NWRITE_R请求事务target TID值完全相同。FTPYE字段的值为13，说明这是一个响应事务，整个响应事务的包正是NWRITE_R事务的响应包。&lt;/p&gt;
&lt;p&gt;       &lt;span&gt;7c83f208&lt;/span&gt;中的7c是特殊字符/K28.3/，它是一个包界定符（Packet Deliminator Control Symbol），83f208转化为二进制为：&lt;/p&gt;
&lt;p&gt;　　83f208= 1000_0011_1111_0010_0000_1000&lt;/p&gt;
&lt;p&gt;　　它是一个包结束控制符号，各个字段的对应关系如下图所示&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1426240/201812/1426240-20181215150936523-137828634.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;4.5 NWRITE事务&lt;/h3&gt;
&lt;p&gt;　　本小节以instruction_list.vh中第94行定义的NWRITE事务为例来说明整个NWRITE事务的传输过程。如下图所示，这个事务表示的是利用NWRITE事务往地址36’ hDE0000600发送16（size+1）个字节的数据。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1426240/201812/1426240-20181215150949355-1396998243.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　Step1&lt;/strong&gt;、为了方便快速的找到上图的NWRITE事务，建议选中srio_request_gen模块，并把request_address变量拖到波形窗口中，并把这个变量用Unsigned Decimal（无符号10进制）格式显示。看过上篇《Xilinx RapidIO核例子工程源码分析》文章的应该知道这个变量是instruction的索引值，当这个变量为56的时候就表示37（0~36）个SWRITE事务全部发送完毕，19个NWRITE_R事务也全部发送完毕，下个事务就是instruction_list.vh中第94行定义的NWRITE事务。锁定request_address为56的位置，找到请求事务的传输通道ireq，并观察事务的波形如下图所示&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1426240/201812/1426240-20181215151003090-838171138.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　由上图可知第一个有效时钟传输的HELLO格式包头数据为：385420fde0000600。后两个有效时钟发送的数据分别是c2c2c2c2c2c2c2c2和c3c3c3c3c3c3c3c3。包头与HELLO包格式的对应关系如下图所示&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1426240/201812/1426240-20181215151023553-2122707804.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　由上图可知FTYPE = 5，TTYPE = 4，这两个字段唯一的确定了这是一个NWRITE_R事务。srcTID的值为16进制的38，也就是10进制的56，与request_address的值相等，因为代码里面就是直接把request_address的值赋给了srcTID。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　Step2&lt;/strong&gt;、ireq通道的NWRITE请求事务经过逻辑层，传输层和物理层到达吉比特收发器（Gigabit Transceiver），吉比特收发器的数据通道gttx_data[31:0]（接口7）波形如下图所示&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1426240/201812/1426240-20181215151041365-397619044.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　由上图可知，NWRITE串行物理层包的数据为：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　&lt;span&gt;7c93f010&lt;span&gt;_c84500ad_4b38e000_0605c2c2_c2c2c2c2_c2c2c3c3_c3c3c3c3_c3c362a2_&lt;/span&gt;7c13f20e&lt;/span&gt;。包的各个字段解释如下：&lt;/p&gt;
&lt;p&gt;       &lt;span&gt;7c93f010&lt;/span&gt;中的7c是特殊字符/K28.3/，它是一个包界定符（Packet Deliminator Control Symbol），93f010转化为二进制为：&lt;/p&gt;
&lt;p&gt;　　93f010= 1001_0011_1111_0000_0001_0000&lt;/p&gt;
&lt;p&gt;　　它是一个包起始控制符号，各个字段的对应关系如下图所示&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1426240/201812/1426240-20181215151148551-176442093.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;c84500ad_4b38e000_0605c2c2_c2c2c2c2_c2c2c3c3_c3c3c3c3_c3c362a2&lt;/span&gt;是NWRITE事务串行物理层的包，把它转化为二进制后各个字段的对应关系如下图所示&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1426240/201812/1426240-20181215151209374-2015094394.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　细心的同学马上会发现wrsize字段的值居然为11（2进制1011，16进制b），address字段的值为e000_0600。而instruction_list.vh中第94行定义的size字段的值为15，address字段的值为36’hDE0000600。似乎逻辑层的包到达物理层以后size字段和address两个字段都出现了错误。出现这种现象的原因如下：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;       前面几篇文章也多次提到过，address后面的两个字段wdptr和xamsbs两个字段是有作用的，xamsbs字段是地址字段的高两位扩展位。由于HELLO格式address字段的有效位数是34-bit，所以在当address字段的值为36’hDE0000600，有效的address字段的值为34’h 1E0000600，当我们把串行物理层xamsbs字段的01拼接在串行物理层address字段前面得到的地址就和先前定义的地址是一致的了。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;       至于wrsize字段的值为11，这是因为后面的wdptr字段的值变成了1，RapidIO_Rev_2.2_Specification的第35页表4-4已经列出了所有wrsize与wdptr字段的组合，当wdptr=1，wrsize=11是，字节的总个数是16，这也和我们之前在instruction_list.vh中的定义是一致的。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1426240/201812/1426240-20181215151238738-370501972.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       &lt;span&gt;7c13f201&lt;/span&gt;中的7c是特殊字符/K28.3/，它是一个包界定符（Packet Deliminator Control Symbol），13f201转化为二进制为：&lt;/p&gt;
&lt;p&gt;　　13f201= 0001_0011_1111_0010_0000_0001&lt;/p&gt;
&lt;p&gt;　　它是一个包结束控制符号，各个字段的对应关系如下图所示&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1426240/201812/1426240-20181215151303199-880990188.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;4.6 NREAD事务&lt;/h3&gt;
&lt;p&gt;　　本小节以instruction_list.vh中第120行定义的NREAD事务为例来说明整个NREAD事务的传输过程。如下图所示，这个事务表示的是利用NREAD事务往地址36’ h0000023F0发送8（size+1）个字节的数据。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1426240/201812/1426240-20181215151319253-718287500.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　Step1&lt;/strong&gt;、为了方便快速的找到上图的NREAD事务，建议选中srio_request_gen模块，并把request_address变量拖到波形窗口中，并把这个变量用Unsigned Decimal（无符号10进制）格式显示。看过上篇《Xilinx RapidIO核例子工程源码分析》文章的应该知道这个变量是instruction的索引值，当这个变量为78（37+19+19+3=78）的时候就表示发送的是上图第120行的NREAD事务（之所以不选择第123行的读事务是因为它读的数据量太大了，截图的时候不方便）。锁定request_address为78的位置，找到请求事务的传输通道ireq，并观察事务的波形如下图所示&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1426240/201812/1426240-20181215151333305-1371487294.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       NREAD请求事务不带任何数据，只包含一个HELLO格式的包头，包头的数据为：4e242070000023f0。各个字段的对应关系如下图所示&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1426240/201812/1426240-20181215151342359-703917603.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　FTYPE=2，TTYPE=4,这两个字段唯一的确定了这是一个NREAD事务包。其他字段也与之前在instruction_list.vh中第120行定义的完全相同。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;       &lt;strong&gt;Step2&lt;/strong&gt;、接下来再看看NREAD事务串行物理层的包格式，这个包在155610ns的位置，下图是NREAD事务串行物理层包格式的时序图&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1426240/201812/1426240-20181215151354757-170294033.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　由上图可知，整个串行物理层的包为：7c92f014_b84200ad_4b4e0000_23f09c5a_7c92f213。这个包的含义如下：&lt;/p&gt;
&lt;p&gt;       &lt;span&gt;7c92f014&lt;/span&gt;中的7c是特殊字符/K28.3/，它是一个包界定符（Packet Deliminator Control Symbol），92f014转化为二进制为：&lt;/p&gt;
&lt;p&gt;　　92f014= 1001_0010_1111_0000_0001_0100&lt;/p&gt;
&lt;p&gt;　　它是一个包起始控制符号，各个字段的对应关系如下图所示&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1426240/201812/1426240-20181215151412193-350989416.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;b84200ad_4b4e0000_23f09c5a&lt;/span&gt;是NREAD事务串行物理层的包，把它转化为二进制后各个字段的对应关系如下图所示&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1426240/201812/1426240-20181215151429112-1543333766.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;       FTYPE = 2，TTYPE = 4，这两个值确定了这个包是一个NREAD事务包。rdsize=11（二进制的1011），wdptr=0，通过查RapidIO_Rev_2.2_Specification第34页的表可知数据量为8个字节，与instruction_list.vh中第120行定义的完全相同。wdptr与rdsize的对应关系表如下所示&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1426240/201812/1426240-20181215151439625-120621921.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　7c92f213&lt;/span&gt;中的7c是特殊字符/K28.3/，它是一个包界定符（Packet Deliminator Control Symbol），92f213转化为二进制为：&lt;/p&gt;
&lt;p&gt;　　92f213= 1001_0010_1111_0010_0001_0011&lt;/p&gt;
&lt;p&gt;　　它是一个包结束控制符号，各个字段的对应关系如下图所示&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1426240/201812/1426240-20181215151723876-985639551.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;4.7 NREAD响应事务&lt;/h3&gt;
&lt;p&gt;　　由于NREAD事务是一个有响应的事务，且响应事务中携带读到的数据。所以当发起方（Initiator）往目标方（Target）发送一个NREAD事务以后，发起方（Initiator）还要接收目标方（Target）的发回响应事务。响应事务通过gtrx_data通道接收。响应事务串行物理层包时序如下图所示，这个响应包在157370ns的位置&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1426240/201812/1426240-20181215151744008-661573327.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　由上图可知，00000000这个数据传输了2个时钟周期，所以整个响应事务串行物理层的包为：&lt;span&gt;7c8af01e&lt;span&gt;_708dadad_804e0000_00000000_0000469c_&lt;/span&gt;7c8af219&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;       &lt;span&gt;7c83f00f&lt;/span&gt;中的7c是特殊字符/K28.3/，它是一个包界定符（Packet Deliminator Control Symbol），83f00f转化为二进制为：&lt;/p&gt;
&lt;p&gt;　　83f00f = 1000_0011_1111_0000_0000_1111&lt;/p&gt;
&lt;p&gt;　　它是一个包起始控制符号，各个字段的对应关系如下图所示&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1426240/201812/1426240-20181215151823728-866396430.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;　708dadad_804e0000_00000000_0000469c&lt;/span&gt;是NREAD响应事务串行物理层的包，把它转化为二进制后各个字段的对应关系如下图所示&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1426240/201812/1426240-20181215151846549-144113072.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       FTYPE=13表示这是一个响应事务，TTYPE=8表示这个响应事务携带数据，target TID的值为16进制的4e（10进制的78），与请求事务刚好对应上，data字段是8个字节的00，由于并没有存储器，所以读出来的数据全部是0。&lt;/p&gt;
&lt;p&gt;       &lt;span&gt;7c8af219&lt;/span&gt;中的7c是特殊字符/K28.3/，它是一个包界定符（Packet Deliminator Control Symbol），8af219转化为二进制为：&lt;/p&gt;
&lt;p&gt;　　8af219= 1000_1001_1111_0010_0001_1001&lt;/p&gt;
&lt;p&gt;　　它是一个包结束控制符号，各个字段的对应关系如下图所示&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1426240/201812/1426240-20181215151910512-1631242829.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       响应事务串行物理层的包经过物理层、传输层和逻辑层到达iresp通道，iresp通道的时序如下图所示&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1426240/201812/1426240-20181215151923757-347985709.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　iresp通道一共有两个有效数据，分别为HELLO格式包头4ed8400000000000和0000000000000000。HELLO格式包头4ed8400000000000各个字段的对应关系如下图所示&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1426240/201812/1426240-20181215151952586-940232605.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       FTYPE = 13，TTYPE = 8表示这是一个携带数据的响应事务，响应事务的prio字段的值为请求事务prio字段的值加1。&lt;/p&gt;
&lt;h3&gt;4.8 MAINTENANCE事务&lt;/h3&gt;
&lt;p&gt;　　顶层模块srio_example_top.v中例化的srio_quick_start模块与SRIO IP核的维护端口相连用来产生维护事务。维护事务在maintenance_list.vh头文件中定义，用户可以通过编辑maintenance_list.vh头文件来添加、修改或移除维护事务。下图是例子工程中定义的所有维护事务&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1426240/201812/1426240-20181215152012801-593001070.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       维护事务有本地（Local）和远程（Remote）两种类型，区分这两种维护事务是通过maintr_araddr信号的高八位的值来确定的。如下图所示&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1426240/201812/1426240-20181215152025235-201486975.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　由上图可知，maintr_araddr的[31:24]位用来区分本地维护事务和远程维护事务，&lt;/p&gt;
&lt;p&gt;　　当 maintr_araddr=01xxxxxx，表示的是远程（Remote）维护事务。&lt;/p&gt;
&lt;p&gt;　　当 maintr_araddr=00xxxxxx，表示的是本地（Local）维护事务。&lt;/p&gt;
&lt;p&gt;　　maintr_araddr的[23:0]位是读操作的偏移地址。&lt;/p&gt;
&lt;p&gt;       下图是一个维护事务的时序图&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1426240/201812/1426240-20181215152047179-288305693.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　由上图可知，红色框出来的部分是一个读维护事务，由于maintr_araddr的高8位[31:24]为8’h00，所以这是一个本地（Local）读维护事务。maintr_araddr的[23:0]位为24’h000000，所以这个本地（Local）读维护事务访问的是逻辑层的能力寄存器（Capability Register Space）空间，且寄存器的偏移地址为24’h000000。&lt;/p&gt;
&lt;p&gt;　　SRIO核寄存器空间的分布如下图所示&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1426240/201812/1426240-20181215152103579-2056191698.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       下图是维护端口（接口2）和逻辑层配置端口（接口3）的时序图&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1426240/201812/1426240-20181215152118932-840023348.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　当 maintr_araddr=01000000，表示的是逻辑层的远程（Remote）维护事务。逻辑层I/O端口发起的维护事务会通过逻辑层、传输层到物理层转化为串行物理层的包通过高速串行收发器（Serial Transceiver）发出去。下图是一个远程维护事务串行物理层包的时序，这个包在96680ns的位置&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1426240/201812/1426240-20181215152134693-1467765077.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　由上图可知，维护事务串行物理层的包为：&lt;span&gt;7c82f00b&lt;span&gt;_104800ff_18010000_0060dead_beefdead_beefbe6e_&lt;/span&gt;7c82f20c&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;       &lt;span&gt;7c82f00b&lt;/span&gt;中的7c是特殊字符/K28.3/，它是一个包界定符（Packet Deliminator Control Symbol），82f00b转化为二进制为：&lt;/p&gt;
&lt;p&gt;　　82f00b = 1000_0010_1111_0000_0000_1011&lt;/p&gt;
&lt;p&gt;　　它是一个包起始控制符号，各个字段的对应关系如下图所示&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1426240/201812/1426240-20181215152224028-74167683.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　104800ff_18010000_0060dead_beefdead_beefbe6e&lt;/span&gt;是维护事务串行物理层的包，把它转化为二进制后各个字段的对应关系如下图所示&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1426240/201812/1426240-20181215152244002-1189607529.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　FTYPE = 8，TTYPE = 1，表明这是一个写请求的维护事务。上图中data字段表示的是dead_beefdead_beef这8个字节的数据。&lt;/p&gt;
&lt;p&gt;       &lt;span&gt;7c82f20c&lt;/span&gt;中的7c是特殊字符/K28.3/，它是一个包界定符（Packet Deliminator Control Symbol），82f20c转化为二进制为：&lt;/p&gt;
&lt;p&gt;　　82f20c = 1000_0010_1111_0010_0000_1100&lt;/p&gt;
&lt;p&gt;　　它是一个包结束控制符号，各个字段的对应关系如下图所示&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1426240/201812/1426240-20181215152309068-2059707445.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;4.9 DOORBELL事务与MESSAGE事务&lt;/h3&gt;
&lt;p&gt;       门铃（DOORBELL）事务与消息（MESSAGE）事务的分析方法与之前几种方法完全一样，大家可以自己按照上面的流程先找到HELLO格式的包，对照HELLO格式各个字段的定义进行分析，然后找到串行物理层的包对照串行物理层的包格式再次分析就能明白整个事务的交互过程了。其实对于用户来说，串行物理层是SRIO IP核帮我们设计好的，所以在实际项目中使用的时候只需要关注HELLO格式的包与时序就可以了。&lt;/p&gt;
&lt;h2&gt;五、（选读）SRIO核在ZC706上回环（Loopback）测试&lt;/h2&gt;
&lt;p&gt;       通过Vivado仿真以后大家应该对使用SRIO核有了一个基本了解。如果你手头有自己做的开发板并且有SRIO的License的话你可以利用SRIO在硬件上做一个回环测试。&lt;/p&gt;
&lt;p&gt;       所谓SRIO的回环测试就是把SRIO的srio_txp0和srio_rxp0在硬件上连接起来，把srio_txn0和srio_rxn0在硬件上连接起来，让SRIO的包自发自收。如下图所示&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1426240/201812/1426240-20181215152327818-699538060.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       由于我手头有一块Xilinx的ZC706评估板，所以这个回环测试我会在ZC706上完成。&lt;/p&gt;
&lt;p&gt;       ZC706上的FPGA型号为XC7Z045，它的上面BANK109、BANK110、BANK111和BANK112为MGT BANK，如下图所示&lt;/p&gt;
&lt;p&gt;其中BANK112与PCIe接口相连（后面有空会写PCIe接口），所以RapidIO不能使用这个BANK。BANK109与BANK110与FMC接口相连，无法使用同轴线或光纤环回，所以这两个BANK也不能使用。因此RapidIO只剩下BANK111可用，而且BANK111有一个通道已经通过C653和C652环回上了，这样就省去了自己用光纤或同轴线去环回。接下来最重要的就是给BANK111输入一个125MHz的参考时钟。&lt;/p&gt;
&lt;p&gt;这个125MHz的时钟可以从临近的BANK“借”一个，比如可以通过软件配置SI5324产生一个125MHz时钟，尽管SI5324输出的时钟并不在BANK111上，但是这个125MHz仍然可以被BANK111“借”用。但是这种方法需要写软件配置SI5324，比较麻烦，所以不推荐。&lt;/p&gt;
&lt;p&gt;下面介绍另外一种得到这个125MHz时钟的方法：由于BANK111上有一路时钟是连接到SMA接口上的，所以这个125MHz时钟可以用外部的信号源接入，但是如果你没有信号源的话也没事，这个125MHz时钟可以通过FPGA内部的Clocking Wizard产生。&lt;/p&gt;
&lt;p&gt;       ZC706评估板的结构图如下图所示&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1426240/201812/1426240-20181215152425154-501751809.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　可以看到上图用红色椭圆圈出来的9号和10号两个SMA接口对，10号SMA接口就是连接到BANK111上的一个参考时钟，所以我们只需要用FPGA中的Clocking Wizard IP核用ZC706的200MHz系统时钟得到125MHz的时钟输出到9号SMA接口对，然后用同轴线把9号SMA接口对和10号接口对相连就可以了。由于Clocking Wizard IP核输出的时钟是单端时钟，所以还必须用OBUFDS原语把这个125MHz单端时钟变成差分时钟输出到9号SMA接口对。&lt;/p&gt;
&lt;p&gt;　　有了125MHz的参考时钟以后，接下来就只需要修改例子工程的顶层srio_example_top_srio_gen2_0代码，添加9号SMA接口对的引脚定义，修改例子工程的物理约束就可以了。还有一个信号就是srio_example_top_srio_gen2_0顶层代码中的sim_train_en在硬件上执行时必须置0。修改完成以后就可以生成bit文件下载到ZC706上观察现象了，还可以用ILA抓一下I/O通道的波形，没有问题的话抓出来的波形和之前仿真的波形是完全一样的。&lt;/p&gt;
&lt;h2&gt;六、总结&lt;/h2&gt;
&lt;p&gt;       整个RapidIO系列博客到此就全部写完了，最后提供两个仿真的建议：&lt;/p&gt;
&lt;p&gt;       1、上文我抓的包传输数据量都比较少，主要是方便我截图，传输的数据量比较大的时候，整个包的总字节数会超过80个字节，在数据量超过80字节的情况下包中会出来两个循环冗余校验码（CRC码），这个在《RapidIO串行物理层的包与控制符号》提到过，大家可以自己把包的数据量改的大一点观察一下数据量大于80字节的情况。&lt;/p&gt;
&lt;p&gt;       2、由于例子工程中测试的比较全面，所以一共发了很多包，这样导致找包的时候非常难找，这里提供一个小技巧，你只需要把srio_request_gen_srio_gen2_0.v模块中的第359行instruction的索引值request_address改成一个固定的数，那么就只会连续不断的发一种包，看波形的时候就会非常方便，缺点是每修改一次就需要重新仿真，所以比较耗费时间。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1426240/201812/1426240-20181215152446566-1742305039.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;七、参考资料&lt;/h2&gt;
&lt;p&gt;       1、Xilinx_Answer_50166。下载链接：https://china.xilinx.com/Attachment/Xilinx_Answer_50166_SRIO_Debugging_Packet_Analysis_Guide_ver1.pdf&lt;a href=&quot;https://china.xilinx.com/Attachment/Xilinx_Answer_50166_SRIO_Debugging_Packet_Analysis_Guide_ver1.pdf&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　2、&lt;span class=&quot;fontstyle0&quot;&gt;RapidIO&lt;span class=&quot;fontstyle0&quot;&gt;™ &lt;span class=&quot;fontstyle0&quot;&gt;Interconnect Specification，下载链接 https://pan.baidu.com/s/1ek-3AAhetLAcxTuOE2IyMg&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　3、pg007_&lt;span class=&quot;fontstyle0&quot;&gt;srio_gen2，下载地址 https://china.xilinx.com/support/documentation/ip_documentation/srio_gen2/v4_0/pg007_srio_gen2.pdf&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 15 Dec 2018 07:28:00 +0000</pubDate>
<dc:creator>jgliu</dc:creator>
<og:description>提示：本文的所有图片如果不清晰，请在浏览器的新建标签中打开或保存到本地打开 一、软件平台与硬件平台 软件平台： 操作系统：Windows 8.1 64-bit 开发套件：Vivado2015.4.2</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liujinggang/p/10123498.html</dc:identifier>
</item>
<item>
<title>8分钟学会Consul集群搭建及微服务概念 - 张子浩</title>
<link>http://www.cnblogs.com/ZaraNet/p/10123291.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ZaraNet/p/10123291.html</guid>
<description>&lt;p&gt;&lt;span&gt;Consul介绍：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;Consul 是由 HashiCorp 公司推出的开源软件，用于实现分布式系统的服务发现与配置。与其他分布式服务注册与发现的方案，Consul 的方案更“一站式”，内置了服务注册与发现框 架、分布一致性协议实现、健康检查、Key/Value 存储、多数据中心方案，不再需要依赖其他工具（比如 ZooKeeper 等），使用起来也较为简单。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;Consul的如何实现的？&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;Consul 用 Golang 实现，因此具有天然可移植性（支持 Linux、windows 和 Mac OS X )，它的安装包仅包含一个可执行文件，方便部署，与 Docker 等轻量级容器可无缝配合。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;微服务概念：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1366751/201812/1366751-20181215142317907-656492414.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;&lt;span&gt;微服务是一种架构风格，一个大型复杂软件应用由一个或多个微服务组成。系统中的各个微服务可被独立部署，各个微服务之间是松耦合的。每个微服务仅关注于完成一件任务并很好地完成该任务。在所有情况下，每个任务代表着一个小的业务能力。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;尽管“微服务”这种架构风格没有精确的定义，但其具有一些共同的特性，如围绕业务能力组织服务、自动化部署、智能端点、对语言及数据的“去集中化”控制等等。简而言之，微服务架构风格是一种将单个应用程序开发为一套小型服务的方法，每个小型服务都在自己的流程中运行，并与轻量级机制（通常是HTTP资源API）进行通信。这些服务围绕业务功能构建，可通过全自动部署机制独立部署。这些服务至少集中管理，可以用不同的编程语言编写，并使用不同的数据存储技术。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt; Consul的安装与配置&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;我们需要去下载Consul ，下载很简单，直接去：https://www.consul.io/downloads.html 选择对应的平台即可，如果你的是Mac OS x 那么直接双击那个可执行文件即可，我的平台是windows10 ，那么相对于MacOsX是比较困难的，即配置环境变量，将文件的位置放到你的path中就可以了，其目的就是为了在Cmd终端中能够键入执行Consul命令，如果你的环境变量已经配置成功，请在Cmd中敲击consul，如果结果如下，那么恭喜您，你成功进入Consul大门。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1366751/201812/1366751-20181215143939849-1949417622.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 名词解释&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;Client : Consul 的 Client模式，就是客户端模式。是 Consul 节点的一种模式，这种模式下，所有注册到当前节点的服务会被转发到 Server，本身是不持久化这些信息。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Server :Consul 的 Server 模式，表明这个 Consul 是个 Server ，这种模式下，功能和 Client 都一样，唯一不同的是，它会把所有的信息持久化的本地，这样遇到故障，信息是可以被保留的。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Server-Leader：  Server 是它们的老大，它和其它 Server 不一样的一点是，它需要负责同步注册的信息给其它的 Server ，同时也要负责各个节点的健康监测。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;raft: Server 节点之间的数据一致性保证协议使用的是 raft，而 zookeeper 用的 paxos，etcd采用的也是raft&lt;/span&gt;&lt;br/&gt;&lt;span&gt;服务发现协议:Consul 采用 http 和 DNS 协议，etcd 只支持 http 。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;服务注册:Consul 支持两种方式实现服务注册，一种是通过 Consul 的服务注册 Http API，由服务自己调用 API 实现注册，另一种方式是通过 json 格式的配置文件实现注册，将需要注册的服务以 json 格式的配置文件给出。Consul 官方建议使用第二种方式。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;启动Consul&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果是在单机情况下使用开发模式启动，在终端中输入：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&lt;span&gt;~ » consul agent -dev
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;开启Consul 集群&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先创建Server-Leader，即老大，那么在终端上输入以下命令：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&lt;span&gt;//Server
consul agent -server -ui -bootstrap-expect=2 -data-dir=/tmp/consul -node=con
sul-server-1 -client=0.0.0.0 -bind=10.211.55.2 -datacenter=dc1
//Client
 consul agent -client -bind 0.0.0.0  本机ip -data-dir=\tmp\consul -node 节点名 -join 随意一个服务器的地址&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;其中：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;consul agent -server 表示以服务器模式启动代理。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-bootstrap-expect=2 表示节点个数为2个。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-node=consul-server-1 表示节点名称&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-client=0.0.0.0 表示客户端 IP&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-bind=10.211.55.2 表示服务端 IP&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-datacenter=dc1 数据中心名称&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;需要注意的是,如果你启动的Server模式的话，你一定要注意node名不要相同，否则将会替换你的项。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么Server-Leader已经创建了，需要别的服务器去进行连接了，如果是Server模式，输入以下命令，只不过是拼接了-join id.&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&lt;span&gt;consul agent -server -ui -bootstrap-expect=2 -data-dir=/tmp/consul -node=con
sul-server-2 -client=0.0.0.0 -bind=10.211.55.4 -datacenter=dc1 -join 10.211.
55.2
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;-data-dir=/tmp/consul 表示临时数据存储路径&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;-join 10.211.55.2 表示加入 10.211.55.2 所在的集群&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;这个时候如果出现Consul agent Running!!还有一大堆东西。那么说明你已经集群成功了，你可以去自己的通过Consul提供的UI去看节点状况，地址为 你自己的id+8500端口，即192.168.10.6:8500或者你的子节点均可，但是如果说你的节点个数是4个，你还有几个节点没有放上去，那么UI是出不来了（有可能会报500错）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么除了UI查看节点以外，还可以通过终端输入指令来查看我们的节点状态。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&lt;span&gt;consul members 
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如果我们希望得到更为详细的信息，可以使用指令来查看&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&lt;span&gt;consul operator raft list-peers &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如果说你没有服务器集群，那么输入以上命令就会出现以下结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1366751/201812/1366751-20181215150539090-1932166361.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 创建.NET Core API 并注册服务&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果你的 Consul Cluster 已经搭建完成，那么可以接下来创建一个.NET Core API 来实现服务的注册。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们创建一个空的解决方案，添加解决方案文件夹 “服务注册”，创建Api项目。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1366751/201812/1366751-20181215151107964-2143532883.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;修改启动配置文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在launchSettings.json中修改启动ip和端口。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&lt;span&gt;{
  &quot;profiles&quot;: {
    &quot;BasicPlatformService&quot;: {
      &quot;commandName&quot;: &quot;Project&quot;,
      &quot;applicationUrl&quot;: &quot;http://192.168.43.174:8080&quot;,
      &quot;environmentVariables&quot;: {
        &quot;ASPNETCORE_ENVIRONMENT&quot;: &quot;Development&quot;
      }
    }
  }
}
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;添加健康检查控制器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在项目中添加一个名为  HealthController 的 API 控制器，用于在将服务注册到 Consul 后的健康检查。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&lt;span&gt;    [Route(&quot;api/[controller]&quot;)]
    [ApiController]
    public class HealthController : ControllerBase
    {
        /// &amp;lt;summary&amp;gt;
        /// 服务健康检测 ⽅方法
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        [HttpGet]
        public IActionResult Get() =&amp;gt; Ok(&quot; health check ok&quot;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　在项目中添加Consul，或者键入命令，这当然，由你选择。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&lt;span&gt;install-package Consul&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 注册Consul中间件,修改Startup.cs文件，这里使用的是 Consul 的服务注册 Http API。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;45&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&lt;span&gt; public void Configure(IApplicationBuilder app, IHostingEnvironment env, IApplicationLifetime life)
        {
            if (env.IsDevelopment())
            {
                app.UseDeveloperExceptionPage();
            }

            app.UseMvc();

            using (ConsulClient client = new ConsulClient(x =&amp;gt; x.Address = new Uri(&quot;http://192.168.43.174:8500&quot;)))
            {
                var httpCheck = new AgentServiceCheck()
                {
                    DeregisterCriticalServiceAfter = TimeSpan.FromSeconds(5),
                    Interval = TimeSpan.FromSeconds(10),
                    HTTP = $&quot;http://192.168.43.174:8080/api/health&quot;,
                    Timeout = TimeSpan.FromSeconds(5)
                };
                var registration = new AgentServiceRegistration()
                {
                    Checks = new[] { httpCheck },
                    ID = &quot;MicroService.Service&quot;,
                    Name = &quot;MicroService.Service&quot;,
                    Address = &quot;192.168.43.174&quot;,
                    Port = 8080,
                    Tags = new[] { &quot;urlprefix-/MicroService.Chanpter01.Service&quot; }
                };
                // 服务启动时注册，内部实现是使⽤用 Consul API 进⾏行行注册（HttpClient发起）
                client.Agent.ServiceRegister(registration).Wait();
                // 当服务停⽌止时，取消注册
                life.ApplicationStopping.Register(() =&amp;gt;
                {
                    // 服务停⽌止时取消注册
                    client.Agent.ServiceDeregister(registration.ID).Wait();
                });
            }
        } 
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　完成后，启动项目，此时已成功注册。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 15 Dec 2018 07:19:00 +0000</pubDate>
<dc:creator>张子浩</dc:creator>
<og:description>Consul介绍： Consul 是由 HashiCorp 公司推出的开源软件，用于实现分布式系统的服务发现与配置。与其他分布式服务注册与发现的方案，Consul 的方案更“一站式”，内置了服务注册与</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ZaraNet/p/10123291.html</dc:identifier>
</item>
<item>
<title>C++中 sort 函数的使用详解 - 詹晴天</title>
<link>http://www.cnblogs.com/satchel/p/10123420.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/satchel/p/10123420.html</guid>
<description>&lt;p&gt;STL主要包含&lt;strong&gt;容器&lt;/strong&gt;，&lt;strong&gt;迭代器&lt;/strong&gt;，&lt;strong&gt;算法&lt;/strong&gt;三块内容，用户可以对容器进行一系列的操作，比如遍历和计算，而STL提供的迭代器和容器完美地提供了这样的接口。其中std::vector是最常用的容器之一，vector是一个模板类，定义在命名空间namespace下，使用vector需要在包含相关头文件。今天主要讲解对vector的排序的使用。&lt;/p&gt;
&lt;p&gt;常见的排序算法有快速排序、冒泡排序、归并排序等。STL中sort函数的实现跟STL的版本有关，而往往sort函数是由多种排序算法混合而成的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1. vector元素为内置数据类型&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;STL中sort函数的使用方法如下，默认对容器进行从小到大的排序。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
#include &amp;lt;vector&amp;gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; std::vector&lt;/span&gt;
#include &amp;lt;algorithm&amp;gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; std::sort&lt;/span&gt;

&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main(){

    std::vector&lt;/span&gt;&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; vi{&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;&lt;span&gt;};
    std::sort(vi.begin(), vi.end());&lt;br/&gt;　　 // 相当于 std::sort(vi.begin(), vi.end(), std::less&amp;lt;int&amp;gt;());

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; vi.size(); ++&lt;span&gt;i) {
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, vi[i]);
    }

    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; output: 0 1 1 1 2 2 5 8&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;当然也可以指定对容器进行从大到小的排序：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
#include &amp;lt;vector&amp;gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; std::vector&lt;/span&gt;
#include &amp;lt;algorithm&amp;gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; std::sort&lt;/span&gt;

&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main(){

    std::vector&lt;/span&gt;&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; vi{&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;&lt;span&gt;};
    std::sort(vi.begin(), vi.end(), std::greater&lt;/span&gt;&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt;());

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; vi.size(); ++&lt;span&gt;i) {
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, vi[i]);
    }

    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; output: 8 5 2 2 1 1 1 0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2. vector元素为用户自定义数据类型&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如果vector内的元素为用户自定义类型，并且用户想要按照自定义类型的某些组合特性进行排序。先来看看sort函数的定义：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
template &amp;lt;&lt;span&gt;class&lt;/span&gt; RandomAccessIterator, &lt;span&gt;class&lt;/span&gt; Compare&amp;gt;
  &lt;span&gt;void&lt;/span&gt; sort (RandomAccessIterator first, RandomAccessIterator last, Compare comp);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其中前两个参数为迭代器类型，第三个参数为比较函数。下面的例子中，类Character拥有两个属性，age_ 和 name_，这里为了简单起见，变量均为public。现在需要对一个元素类型为Character的vector进行按照Character的 age_ 从小打到进行排序。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Character {
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    Character(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; s) : age_(n), name_(s) {}
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; age_;
    &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt; name_;
};

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Compare {
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; &lt;span&gt;operator&lt;/span&gt;() (Character* ca, Character*&lt;span&gt; cb) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ca-&amp;gt;age_ &amp;lt; cb-&amp;gt;&lt;span&gt;age_;
    }
};


&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main(){
    vector&lt;/span&gt;&amp;lt;Character*&amp;gt; vc{&lt;span&gt;new&lt;/span&gt; Character(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sasaki&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), &lt;span&gt;new&lt;/span&gt; Character(&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;nozomi&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), &lt;span&gt;new&lt;/span&gt; Character(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;satchel&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), &lt;span&gt;new&lt;/span&gt; Character(&lt;span&gt;6&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;qingtian&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)};

    sort(vc.begin(), vc.end(), Compare());

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; vc.size(); ++&lt;span&gt;i) {
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, vc[i]-&amp;gt;&lt;span&gt;name_.c_str());
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span readability=&quot;2&quot;&gt;;
}&lt;p&gt;// output: sasaki satchel nozomi qingtian&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;对于sort的第三个函数，用户可以自己定义任何类型的比较方式，但是需要满足 &lt;strong&gt;strict weak ordering&lt;/strong&gt; 的条件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;X    a;
X    b;

Condition:                  Test              Result
a &lt;/span&gt;&lt;span&gt;is&lt;/span&gt; equivalent to b:       Compare(a, b)     &lt;span&gt;false&lt;br/&gt;&lt;/span&gt;                            Compare(b, a)     &lt;span&gt;false&lt;/span&gt;&lt;span&gt;

a &lt;/span&gt;&lt;span&gt;is&lt;/span&gt; less than b            Compare(a, b)     &lt;span&gt;true&lt;/span&gt;                            &lt;br/&gt;Compare(b, a)     &lt;span&gt;false&lt;/span&gt;&lt;span&gt;

b &lt;/span&gt;&lt;span&gt;is&lt;/span&gt; less than a            Compare(a, b)     &lt;span&gt;false&lt;/span&gt;                            &lt;br/&gt;Compare(b, a)     &lt;span&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上述例子中的 Compare 函数基于 Character 对象的 age_ 变量值进行比较。根据 strict weak ordering 的条件，对 vector 按照某种条件进行排序就比较好理解了。&lt;/p&gt;
&lt;p&gt;对于 vector 的两个元素 a, b，如果 a 必须排在 b 前面，需要满足下面的条件：Compare(a, b) = true, Compare(b, a) = false; 如果满足 Compare(a, b) = false &amp;amp; Compare(b, a) = false，则说明两个元素是相等的；&lt;/p&gt;

&lt;p&gt;拓展：对 vector 中的元素进行排序，使得 age_ 为 1 的元素排在前面，age_ != 1的元素排在后面；&lt;/p&gt;
&lt;p&gt;分析：这种情况下 Character 被分为两类，age_ ==1 和 age_ != 1；对于任意两个 Character 对象 a, b：&lt;/p&gt;
&lt;p&gt;1. 相等（a == b）：a-&amp;gt;age_ == 1 &amp;amp;&amp;amp; b-&amp;gt;age_ ==1，或者 a-&amp;gt;age_ != 1 &amp;amp;&amp;amp; b-&amp;gt;age_ != 1；&lt;/p&gt;
&lt;p&gt;2. 小于（a &amp;lt; b）：a-&amp;gt;age_ == 1 &amp;amp;&amp;amp; b-&amp;gt;age_ != 1；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Compare {
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; &lt;span&gt;operator&lt;/span&gt;() (Character* ca, Character*&lt;span&gt; cb) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ca-&amp;gt;age_ == &lt;span&gt;1&lt;/span&gt; &amp;amp;&amp;amp; cb-&amp;gt;age_ == &lt;span&gt;1&lt;/span&gt; ||&lt;span&gt;
            ca&lt;/span&gt;-&amp;gt;age_ != &lt;span&gt;1&lt;/span&gt; &amp;amp;&amp;amp; cb-&amp;gt;age_ != &lt;span&gt;1&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ca-&amp;gt;age_ == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    }
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;完整的测试代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Character {
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    Character(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; s) : age_(n), name_(s) {}
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; age_;
    &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt; name_;
};

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Compare {
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; &lt;span&gt;operator&lt;/span&gt;() (Character* ca, Character*&lt;span&gt; cb) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ca-&amp;gt;age_ == &lt;span&gt;1&lt;/span&gt; &amp;amp;&amp;amp; cb-&amp;gt;age_ == &lt;span&gt;1&lt;/span&gt; ||&lt;span&gt;
            ca&lt;/span&gt;-&amp;gt;age_ != &lt;span&gt;1&lt;/span&gt; &amp;amp;&amp;amp; cb-&amp;gt;age_ != &lt;span&gt;1&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ca-&amp;gt;age_ == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    }
};


&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main() {
    vector&lt;/span&gt;&amp;lt;Character*&amp;gt; vc{ &lt;span&gt;new&lt;/span&gt; Character(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sasaki&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), &lt;span&gt;new&lt;/span&gt; Character(&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;nozomi&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), &lt;span&gt;new&lt;/span&gt; Character(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;satchel&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), &lt;span&gt;new&lt;/span&gt; Character(&lt;span&gt;6&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;qingtian&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) };

    sort(vc.begin(), vc.end(), Compare());

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; vc.size(); ++&lt;span&gt;i) {
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, vc[i]-&amp;gt;&lt;span&gt;name_.c_str());
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span readability=&quot;2&quot;&gt;;
}&lt;p&gt;// output: sasaki satchel nozomi qingtian&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Reference:&lt;/p&gt;
&lt;p&gt;1. &lt;a href=&quot;https://en.cppreference.com/w/cpp/algorithm/sort&quot; target=&quot;_blank&quot;&gt;std::sort&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2. &lt;a href=&quot;https://stackoverflow.com/questions/979759/operator-and-strict-weak-ordering&quot; target=&quot;_blank&quot;&gt;comparator&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3. &lt;a href=&quot;https://en.wikipedia.org/wiki/Weak_ordering#Strict_weak_orderings&quot; target=&quot;_blank&quot;&gt;strict weak order&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 15 Dec 2018 07:01:00 +0000</pubDate>
<dc:creator>詹晴天</dc:creator>
<og:description>STL主要包含容器，迭代器，算法三块内容，用户可以对容器进行一系列的操作，比如遍历和计算，而STL提供的迭代器和容器完美地提供了这样的接口。其中std::vector是最常用的容器之一，vector是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/satchel/p/10123420.html</dc:identifier>
</item>
<item>
<title>Egret(白鹭引擎)——“TypeError: Cannot read property 'asCom' of null” - FannieGirl</title>
<link>http://www.cnblogs.com/ifannie/p/10123405.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ifannie/p/10123405.html</guid>
<description>&lt;p&gt;前言&lt;/p&gt;
&lt;p&gt;　　相信我，这个错误新手都不陌生：&lt;strong&gt;TypeError: Cannot read property 'asCom' of null&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　还有，一定要看我上一篇，哦不（人家应该是报了这个错，才找到看到这篇文章的）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;错误描述&lt;/p&gt;
&lt;p&gt;　　项目背景：Egret+fairyGui&lt;/p&gt;
&lt;p&gt;　　1.官方案例我可以跑通&lt;/p&gt;
&lt;p&gt;　　2.一替换成自己的素材，就报这个错&lt;/p&gt;
&lt;p&gt;分析&lt;/p&gt;
&lt;p&gt;　　1.你真的替换成功了吗？&lt;/p&gt;
&lt;p&gt;　　2.该改的地方，你都改了吗？&lt;/p&gt;
&lt;p&gt;实操&lt;/p&gt;
&lt;p&gt;　　1.把官方实例的素材，替换成你的素材&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1003225/201812/1003225-20181215144216792-1656015480.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　你从fairygui 发布，一定要选择二进制格式，不然最新的Egret 会报错哦&lt;/p&gt;
&lt;p&gt;　　一定要注意 .fui 格式的正确引用 如图所示&lt;/p&gt;

&lt;p&gt;　　2.找到  src/Main.ts  文件 （修改包名）&lt;/p&gt;
&lt;p&gt;　　　　Egret 创建游戏场景，需要加载的包&lt;/p&gt;
&lt;p&gt;　　　　这时候 ，你要根据你的fairygui 的包名来哦&lt;/p&gt;
&lt;p&gt;　　　　这张图是 Egret&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1003225/201812/1003225-20181215144600671-1083577275.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　这张图是 fairygui&lt;/p&gt;
&lt;p&gt;　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1003225/201812/1003225-20181215144644302-773088375.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　3.找到文件 src/MainPanel.ts&lt;/p&gt;
&lt;p&gt;　　　　注释不要的东西&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1003225/201812/1003225-20181215144907700-148423108.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　这个文件主要是实例里面 写的有些操作方法，因为是官方实例啊，你没有这些按钮啊，图片啊 等等等&lt;/p&gt;
&lt;p&gt;　　　　你要改成你自己的东西 ，这些玩意 ，你肯定不需要，只要保留 fairygui的引用即可&lt;/p&gt;
&lt;p&gt;　　　　还有啊！不要杠，先跑通demo再说，后面什么事件 对着官方api 写就好了&lt;/p&gt;
&lt;p&gt;　　　　再次注意，我画的两个框，第一个是包名，第二个是你想要加载fairygui哪一个组件，这你一一对应fairygui就好了&lt;/p&gt;

&lt;p&gt;　　　　现在你就可以调试了~要是还有其他的错误（那我不管了，另找高明吧）&lt;/p&gt;
&lt;p&gt;　　　　成功跑通案例的（自己家的素材）&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1003225/201812/1003225-20181215153020558-117544555.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;总结&lt;/p&gt;
&lt;p&gt;　　我就记录一下我遇到的坑啊&lt;/p&gt;
&lt;p&gt;　　这个是我手把手摸出来&lt;/p&gt;
&lt;p&gt;　　也许是我太笨，但是网上我找了很久都没有这些步骤的记载，（我打开的方式不对么）　&lt;/p&gt;
&lt;p&gt;　　我也是第一次使用Egret 以及fairygui（但是后面 我要用这个完成我们公司的业务需求，等待我后续的文章吧 一定会有不少价值的）&lt;/p&gt;
&lt;p&gt;　　没有我这样详细的介绍吧~ 官网这么潦草的概括过去了（还是我要被淘汰了啊~要求如此之高了，啊 我的发际线啊~）　&lt;/p&gt;
&lt;p&gt;　　emmm，戏多了&lt;/p&gt;

&lt;p&gt;　　希望对看到的人有所帮助，溜了&lt;/p&gt;

</description>
<pubDate>Sat, 15 Dec 2018 06:57:00 +0000</pubDate>
<dc:creator>FannieGirl</dc:creator>
<og:description>前言 相信我，这个错误新手都不陌生：TypeError: Cannot read property 'asCom' of null 还有，一定要看我上一篇，哦不（人家应该是报了这个错，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ifannie/p/10123405.html</dc:identifier>
</item>
<item>
<title>【工利其器】Source Insight 学习笔记 - 宋者为王</title>
<link>http://www.cnblogs.com/andy-songwei/p/10123294.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/andy-songwei/p/10123294.html</guid>
<description>&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;        &lt;/strong&gt;“Source Insight（以下简称SI）是世界上最好的编辑器”，说这句话不知道会不会出门被打呢？-_- 中国古话说得好，“文无第一，武无第二”，所以不敢说SI是最好的，但是说是“最好的之一”绝对是妥妥的。它以丰富的语言支持、便捷的功能、快速的源码导航、实时的上下文显示、独立的符号数据库等众多优点，在全世界范围内广受程序员们的欢迎。本文将结合笔者的实际操作和学习，基于SI3.5做一些使用记录。另外，笔者对SI的使用，主要是用于阅读源码，本文介绍的功能也是基于阅读方面的。&lt;/p&gt;
&lt;p&gt;        本文的主要内容如下：&lt;/p&gt;

&lt;p&gt;       &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201812/472002-20181215140505951-292831144.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一、SI简介&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       SI是一款面向项目开发的程序编辑器和代码浏览器，它提供了一个视图将分散在各个地方的代码汇合在一起形成一个虚拟的整体，供开发者方便地阅读和编辑，如下图所示。&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201811/472002-20181113185535538-682678704.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;Body&quot;&gt;        Source Insight was designed to enhance your ability to understand and modify your program. Our company mission is to increase programming team productivity by clarifying source code, presenting information in a useful way, and allowing programmers to modify software in large, complex projects. ……Source Insight acts as an information server that surrounds your project’s source code. With it, you can have instant access to symbolic and textual information in your program.&lt;/p&gt;
&lt;p class=&quot;Body&quot;&gt;       该段英文摘自SI官方帮助文档，从这里可以看出SI的设计宗旨就是方便开发者查看和修改项目源码。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二、SI的优势&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        SI是如今最好用的语言编辑器之一，具有很多其他编辑器无法比拟的优点，比如下面几点。&lt;/p&gt;
&lt;p&gt;  1、支持语言种类多。&lt;/p&gt;
&lt;p&gt;        SI几乎支持所有的语言，如C、C++、C#、JAVA、ASM、PAS、ASP、HTML等，而其它编辑器往往只支持其中某类或某几种语言，丰富性远不及SI。&lt;/p&gt;
&lt;p&gt;  2、拥有自己的数据库。&lt;/p&gt;
&lt;p&gt;        SI自动传创建并维护他自己高性能的符号数据库，包括包名、函数、method、全局变量、结构、类、注释和功能源文件里定义的其它类型的符号等。我们可以通俗地理解为缓存，当需要再次查找某个符号时，就可以直接从数据库中查找，而不用在整个源码库中搜索，极大提高了效率。&lt;/p&gt;
&lt;p&gt;  3、显示丰富的程序相关信息。&lt;/p&gt;
&lt;p&gt;       SI提供了丰富多彩的窗口，为被选中的代码提供丰富的信息，如reference trees、class inheritance diagrams、call tress，symbol windows等。后面会专门介绍这些窗口的使用。&lt;/p&gt;
&lt;p&gt;  4、实时显示上下文信息。&lt;/p&gt;
&lt;p&gt;       SI提供了Context Window，当鼠标选择代码中的某个符号时，该window会实时显示选中符号的上下文信息。在下文中的Context Window会详细讲到。甚至在你编辑的时候，SI同时分析你的源码，提供实时的信息并进行分析。 &lt;/p&gt;
&lt;p&gt;  5、快速。&lt;/p&gt;
&lt;p&gt;        提供了快速和革新的访问源代码和源信息的能力，能以最快的速度对源代码导航和提供任何程序编辑器的源信息。&lt;/p&gt;
&lt;p&gt;  参考资料：&lt;a href=&quot;https://baike.baidu.com/item/source%20insight/1833181&quot; target=&quot;_blank&quot;&gt;Source Insight 百度百科&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三、创建项目&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;        &lt;/strong&gt;在SI窗口的顶部工具栏上依次点击 Project &amp;gt; New Project，即可开始创建一个新的项目了。之所以要特别介绍项目的创建过程，除了这是一个极常用的操作外，还有就是创建过程中有一些注意事项需要留心，笔者在使用过程中就曾经走过不少弯路，在这里特别记录一下。&lt;/p&gt;
&lt;p&gt;  1、项目命名及设置项目存储路径&lt;/p&gt;
&lt;p&gt;        &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201811/472002-20181114215934809-765846843.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  2、项目设置&lt;/p&gt;
&lt;p&gt;        如下图，在红框部分选择需要打开的源码所在的路径，笔者最初使用的时候，就忽略了这里，导致在后面的步骤中，找不到源码，一度以为是SI版本异常了，所以这里特别提醒一下。其它的选项这里就按照默认的选择就可以了，笔者就是这么做的。当然，这个要根据用户自己需要来选择了，看个人喜好。&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201811/472002-20181119182139740-2120943195.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;  3、添加/删除项目文件&lt;/p&gt;
&lt;p&gt;       在这个界面上，可以看到左侧“Directory”这一栏的根节点，就是第二步“项目设置”中咱们选择的源码路径所在的盘符，如果你要添加的源文件不在这个盘符，就没法找到了。在该盘符下选择想要添加的文件，如蓝色部分“Android-8.0.0_r1”，这是Android 系统源码根目录，因为这里选择的是文件夹，所以点击右边的“Add Tree”来添加整个目录。如果选择的是文件，多个文件就选择“Add All”，单个文件就选择“Add”&lt;/p&gt;
&lt;p&gt;        &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201811/472002-20181114220334280-829319168.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       添加时会给出对话框，表示正在添加。笔者添加的源码目录有4G以上，所以这时需要等待好几分钟的时间。&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201811/472002-20181114220434437-231551695.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       添加完成以后，可以看到对话框提示，点击“确定”即可，此时可以继续添加项目文件。&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201811/472002-20181114221351408-1110464047.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  4、完成项目创建&lt;/p&gt;
&lt;p&gt;      当不需要再添加文件了，点击“Close”按钮关闭该界面，即完成了项目的创建。此时显示的界面如下，左下区域显示的就是新建的项目，列表显示了项目中文件。&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201811/472002-20181115193743389-665289277.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;四、常用窗口&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       SI的用户接口主要包含如下几种类型：（1）顶部主要菜单和工具栏；（2）用于编辑的源文件窗口；（3）可停放或浮动的工具窗口。由于SI是一个MDI（Multiple Document Interface，多文档接口），这意味着每一个你打开的源文件都拥有它自己的子窗口。在这一节中，将主要介绍主要菜单和最常用到的9个应用窗口。下图展示了主界面常用窗口概貌：&lt;/p&gt;
&lt;p&gt;        &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201811/472002-20181119223714805-67853940.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;                                                                                                        SI概貌图&lt;/p&gt;
&lt;p&gt;  1、主菜单（Main Menu）&lt;/p&gt;
&lt;p&gt;       和其他所有编辑器一样，主菜单栏包含了所有编辑器功能的入口。每一类功能又都分类到某个子菜单中，这一点自然不用多说，地球人都知道，就不一一展示每个子菜单和功能点界面了，一些常用和重要的操作，咱们后文详细介绍。&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201811/472002-20181117212639980-81626933.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       从上图可以看到，分类其实是非常简洁和明确的，看子菜单名称大概就能知道其中包含了哪些功能，很方便查找。这里笔者着重推荐一下“Help”子菜单。无疑，官方的帮助文档，是最权威，最全面的，如果英文不是太差，对某些功能不是太明白的话，完全可以从这个文档中去查找，笔者看过其中不少说明，其实还是很容易看懂的。如下为官方帮助文档概貌，内容还是比较全面的：&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201811/472002-20181117214200849-976544355.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  2、工具栏（Toolbars）&lt;/p&gt;
&lt;p&gt;       工具栏列出了不少比较常用的一些功能快捷按键，这个也是地球人都知道的吧。如下显示了SI设置的所有快捷工具图标。&lt;/p&gt;
&lt;p&gt;        &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201811/472002-20181117215755998-901723728.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    （1）显示/隐藏工具栏&lt;/p&gt;
&lt;p&gt;       点击菜单栏View子菜单栏，点开Toolbars，就可以看到工具栏显示选择界面，可以在这里选择显示/隐藏哪些工具，如下图所示。也可以右键点击SI窗口顶部或工具栏空白处，也可以显示下图界面。&lt;/p&gt;
&lt;p&gt;        &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201811/472002-20181119181949709-76597617.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    （2）工具栏工具简介&lt;/p&gt;
&lt;p&gt;       把鼠标停留在工具栏的图标上，会简单说明该工具的作用。咱们下面简单看看工具栏都包含了哪些功能，做到心中有数，这有助于以后快速定位到某些功能的入口而不用每次都到菜单栏中去找，少走一些弯路。&lt;/p&gt;
&lt;p&gt;        1）标准工具栏（Standard Toolbar）：包含了基本的文件操作&lt;/p&gt;
&lt;p&gt;          &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201811/472002-20181117223302184-1060442402.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;        2）编辑工具栏（Edit Toolbar）：包含一些基本的编辑操作&lt;/p&gt;
&lt;p&gt;         &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201811/472002-20181117223347041-1487705163.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;        3）搜索工具栏（Search Toolbar）：包含了一些搜索命令&lt;/p&gt;
&lt;p&gt;            &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201811/472002-20181117223702229-392750206.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;        4）导航工具栏（Navigation Toolbar）：包含了一些界面导航功能。&lt;/p&gt;
&lt;p&gt;        &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201811/472002-20181117223941820-1490219216.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;             a）Go To Previous Link / Go To Next Link：在搜索结果界面，用于跳转到前一个/后一个结果的链接。&lt;/p&gt;
&lt;p&gt;             b）Go Back/Go Forward：回到上个/下个操作界面；&lt;/p&gt;
&lt;p&gt;             c）Go To Line：跳转到某一行&lt;/p&gt;
&lt;p&gt;             d）Bookmarks：添加书签，或定位到书签处。鼠标光标停留在编辑窗口的某一行，点击该按钮，会显示如下界面。可以选择在“Name”处输入书签名并点击“Set”按钮，新增一个书签；也可以在“Marks”处显示的书签列表中选择一个书签，双击或者点击“Go To”按钮，就可以跳转到该书签对应的代码处了。对于要经常查看某处代码，这个工具算是相当给力了。&lt;/p&gt;
&lt;p&gt;              &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201811/472002-20181117224601720-1523538823.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;        5）符号工具栏（Symbol Toolbar）：用于访问一些符号信息（这里说的符号，前面第二大点第2小点讲过其含义了，不明白的可以返回去看看）。&lt;/p&gt;
&lt;p&gt;          &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201811/472002-20181117231118974-712762198.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;          a）Jump To Definition：跳转到选中的某个符号定义的地方。其实当在编辑器中用鼠标选择某个符号，如果打开了“Contex Window”的话，可以在“Context Window”中实时看到该符号的定义处，这个后面讲到该窗口时再详细讲，这里不赘述。&lt;/p&gt;
&lt;p&gt;          b）Symbol Info：弹出对话，显示选择的符号的相关信息，以及一些操作按钮，如下图所示。可以看到上面“Jump To Definition”是这里的一个小功能。&lt;/p&gt;
&lt;p&gt;          &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201811/472002-20181117231343702-996272178.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;          c）Browser Project Symbols：可以查看整个项目中的符号列表。&lt;/p&gt;
&lt;p&gt;          d）Look up References：显示该符号被引用的地方。会弹出一个对话框，根据选择的搜索条件进行搜索，显示一个搜索结果窗口列出这些引用信息（由于该该窗口尺寸原因，这里不好显示，就不贴图了）。其实在“Relation Window”中，也会实时显示这些应用列表的，这个后面在讲该窗口时会详细讲，这里就不赘述了。&lt;/p&gt;
&lt;p&gt;          &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201811/472002-20181117234540183-115243164.png&quot; alt=&quot;&quot;/&gt;    &lt;/p&gt;
&lt;p&gt;          &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201811/472002-20181117234503654-780419654.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;        6）窗口工具栏（ Window Toolbar）：用于控制窗口的排列&lt;/p&gt;
&lt;p&gt;          &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201811/472002-20181118010229208-609794729.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;        7）帮助工具栏（Help Toolbar）：访问帮助文档。&lt;/p&gt;
&lt;p&gt;          &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201811/472002-20181118010334157-663466002.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;            点击“Help Mode”后会出现一个“?”，将其拖到你想寻求帮助的地方，就会显示该处相关的帮助文档。&lt;/p&gt;
&lt;p&gt;        8）视图工具栏（View Toolbar）：开启/隐藏常用的几个窗口，后面会专门对这几个窗口做介绍。&lt;/p&gt;
&lt;p&gt;           &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201811/472002-20181118010848515-371330584.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;        9）构建工具栏（Build Toolbar）：运行和编译项目。&lt;/p&gt;
&lt;p&gt;           &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201811/472002-20181118011015250-436821844.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;        10）版本控制工具栏（Source Control Toolbar）：包含了操作版本控制的相关工具。&lt;/p&gt;
&lt;p&gt;          &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201811/472002-20181118011100412-434677852.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  3、源文件窗口（Source File Windows）&lt;/p&gt;
&lt;p&gt;       源文件窗口，可以称作是SI的主角了，因为源码都显示在这个窗口，可编辑，可同时打开多个窗口，在左上角红框处显示了源文件文件名和路径。&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201811/472002-20181119224420021-1183469534.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       在源文件窗口选中某个符号并点击右键，会显示一个功能菜单，可以对源文件进行操作，如下图所示：&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201811/472002-20181119185704464-1594654754.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       这些功能有些是基本操作，有些是“见名思义”，一看就知道功能，有些在前面介绍工具栏的时候介绍过，这里就不再一一说明了，仅选择性简单介绍几个：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Highlight Word 将文件中所有所选单词高亮显示，再次点击会取消高亮。比如截图中选择“reason”并高亮，文件中的所有“reason”这个单词都高亮了。另外，这个功能对注释区无效。&lt;/li&gt;
&lt;li&gt;Special Window Color/Remove Special Window Color 设置和取消编辑窗口的背景颜色。&lt;/li&gt;
&lt;li&gt;Keyword List 显示当前文件所有的的关键字列表。&lt;/li&gt;
&lt;li&gt;Style Properties&lt;/li&gt;
&lt;li&gt;Document Options 设置编辑区文字颜色、大小、间隔等属性。&lt;/li&gt;
&lt;li&gt;Language Properties&lt;/li&gt;
&lt;li&gt;Edit Condition&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;  4、符号窗口（Symbol Windows）&lt;/p&gt;
&lt;p&gt;       符号的概念前面第二大节第2小点解释过，不清楚的可以往前翻看。该窗口和源文件窗口相依相存，同时出现或隐藏，它显示在源文件窗口的左边，展示了当前文件中的所有符号列表。如下图所示：&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201811/472002-20181119230116842-1981897512.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       顶部显示了文件名；搜索栏中输入要查找的符号可以快速找到要找的符号；中间部分显示了符号列表，每一项前面都有一个符号，这些符号表示不同的符号类型；底部为工具栏，主要用于显示符号排序方式，决定显示哪些内容，字体颜色和大小等。（Tips：如果在操作过程中，发现该窗口为空白了，可以点击工具栏中的排序方式选择按钮，相当于刷新了一下，即可正常显示了，最开始笔者碰到这种情况的时候，曾经蒙圈过...）&lt;/p&gt;
&lt;p&gt;       在窗口区域内点击右键，会显示一个菜单栏，显示针对该窗口的一些操作功能，如下图所示：&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201811/472002-20181120084816905-1950394013.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       值得注意的是，菜单栏中Cut~Select Symbol，操作对象是整个符号所代表的代码块，而不是符号所代表的字符串。比如鼠标选中某个方法符号，点击“Copy Symbol”后复制的就是整个方法了。这里有个比较生僻的功能——“Duplicate Symbol”，表示重复符号，将符号复制并粘贴，功能上看就相当于“Copy Symbol”和“Paste Symbol”一次组合使用了。菜单中剩余的功能基本上就是Window面板中搜索栏和工具栏中的功能，这里不赘述。&lt;/p&gt;
&lt;p&gt;  5、项目窗口（Project Window）&lt;/p&gt;
&lt;p&gt;       项目窗口显示了项目的相关信息，可以在SI顶部“View &amp;gt; Project Window”或者Toolbar中“Project Window”按钮来控制该窗口的显示/隐藏。&lt;/p&gt;
&lt;p&gt;    （1）概貌&lt;/p&gt;
&lt;p&gt;       如下图所示，为项目默认窗口的概貌图，我们可以看到，它显示了项目名称，快速搜索栏，中间的内容显示区和底部的工具栏，当然还有右上角的最大/最小化和关闭按钮。&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201811/472002-20181120104758045-706310279.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    （2）内容显示区&lt;/p&gt;
&lt;p&gt;       这个区域会根据“快速搜索栏”输入的关键字过滤出文件名或路径包含该关键字的匹配列表，上图中还显示了文件大小，和修改时间。这个区域的内容也会随着工具栏中的按钮的切换而变化显示内容。后面讲工具栏时会再讲到。双击某一项或者在某一项上点击右键调出的菜单中点击“Open”就可以快速进入到对应的源文件。&lt;/p&gt;
&lt;p&gt;    （3）工具栏&lt;/p&gt;
&lt;p&gt;       默认选择是显示，也可以通过在该项目窗口点击右键后显示的菜单栏“Toolbar”选项来显示/隐藏工具栏。窗口工具栏中黄框部分按钮用于切换内容显示区的显示内容；蓝框部分会根据黄框部分按钮的选择而有所变动，主要用于跳转到某些界面；绿框部分为项目窗口属性设置按钮，包括字体大小、颜色、背景色等。把鼠标指针放置在按钮上，会显示该按钮功能。&lt;/p&gt;
&lt;p&gt;      1）黄框中按钮功能如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Project File List：项目文件列表。默认选择为该项，在“内容显示区”显示当前项目中的所有文件列表，并降序排列，如概貌图中所示。Tips：这里可以在搜索栏中灵活使用通配符，比如输入“*.java”再按“Enter”按键，可以筛选出所有的java文件；如果再输入“*”并“Enter”，则取消前面通配符效果，也可以理解是“*”表示显示所有。&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;Project File Browser：项目文件浏览器，以目录树的形式显示。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;          &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201811/472002-20181120113855740-612919923.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Project Document Types：按照文件的文档类型来分类显示。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;          &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201811/472002-20181120114107434-1339181469.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Project Symbol List：显示项目中符号列表。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;         &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201811/472002-20181120135506923-1470413695.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;         注意：这里工具栏中黄色边框中的按钮，与其他几个界面有所不同了。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Project Symbol Classes：按照符号的类型进行分类显示。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;         &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201811/472002-20181120135803674-234721025.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      2）黄框中&lt;/p&gt;
&lt;p&gt;       前面也提到了，蓝框中的按钮是变化的。当左边切换到“Project Symbol List”或“Project Symbol Classes”这两个显示Symbol的界面时，蓝框中显示了4个按钮，这里的4个按钮和SI整体窗口顶部的工具栏中符号工具栏（Symbol Toolbar）一样，这里不赘述，不清楚的可以查看前面“工具栏”这一节。当选择的是其他3种界面时，显示的是概貌图中界面：Open Project、Add or Remove Project Files 和 Project Report。Project Report，生成当前项目中的统计数据，如下图(1)所示，可以选择一些统计项，点击“OK”按钮，会生成一个统计报告文件如下图(2)所示。&lt;/p&gt;
&lt;p&gt;        &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201811/472002-20181120144315242-349954627.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;                                                   图(1)&lt;/p&gt;
&lt;p&gt;        &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201811/472002-20181120144235717-901492087.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;                                                                                                                               图(2)&lt;/p&gt;
&lt;p&gt;      3）绿框中&lt;/p&gt;
&lt;p&gt;        绿框中按钮的功能是设置项目窗口的界面信息，如下图所示，可以设置显示内容，字体/颜色/大小等。&lt;/p&gt;
&lt;p&gt;         &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201811/472002-20181120145919793-1260770392.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    （4）右键菜单栏&lt;/p&gt;
&lt;p&gt;        在该窗口中点击右键，可以调起项目窗口的功能菜单栏，如下图所示。前面黄框部分按钮在切换显示内容是文件或符号的时候，菜单栏会有一点不同，但也是大同小异，这里不单独贴图了。这里单独提一下“Synchronize Files”，同步项目中的所有修改，其他功能或在工具栏中讲到过，或见名思义，就不赘述了。&lt;/p&gt;
&lt;p&gt;        &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201811/472002-20181120150318950-1273029096.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  6、关联窗口（Relation Window）&lt;/p&gt;
&lt;p&gt;       Relation Window也是SI的一个创新点，用于显示当前被选中的Symbol和外界的联系，比如被哪些地方引用，被哪些地方调用等。它和后面要讲到的Context Window一样，都是跟踪选中的Symbol而自动实时地变化。&lt;/p&gt;
&lt;p&gt;    （1）开关位置&lt;/p&gt;
&lt;p&gt;       可以在SI顶部菜单栏选择/取消“View &amp;gt; Relation Window”，或者在顶部Toolbar中点击“Relation Window”快捷按钮来显示/隐藏该窗口。&lt;/p&gt;
&lt;p&gt;    （2）窗口内容&lt;/p&gt;
&lt;p&gt;       当鼠标光标停留在某个Symbol上时，该窗口中会立即显示设置的关联内容，该窗口基本内容如下图所示：&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201812/472002-20181206183443708-811166227.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;                                                         图4.6.1&lt;/p&gt;
&lt;p&gt;       顶部“References”表示该窗口显示的内容与当前光标所在的Symbol是引用关系，这个关系可以在设置中选中，还有“Calls”、Contains等关系，后面会讲到。中间内容区显示了引用当前Symbol的地方，该例子中就是表示变量“_isFaceIDSwitchOpen”被当前类KeyguardUpdateMonitor中isFaceIDSwitchOpen()方法的第2760、2764、2769行引用。点击每一行会在Context Window中实时显示上下文。底部是该窗口的快捷工具箱。&lt;/p&gt;
&lt;p&gt;    （3）Toolbar各功能简介&lt;/p&gt;
&lt;p&gt;      从左往功能依次为&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Jump To Definition：将光标移动到所选项被定义的地方，可能是某个方法，或者某个类等。&lt;/li&gt;
&lt;li&gt;Symbol Info：弹出一个popup window，显示Relation Window中被选项的定义。&lt;/li&gt;
&lt;li&gt;Lookup Reference：搜索指定或者选中字段的应用情况，后面讲搜索的时候会详细讲到。&lt;/li&gt;
&lt;li&gt;Lock Relation Window：选中后表示锁住当前窗口，不会实时改变内容。&lt;/li&gt;
&lt;li&gt;Refresh Relation Window：刷新窗口。&lt;/li&gt;
&lt;li&gt;View Relation Outline：以大纲的形式显示内容，如图4.6.2所示。&lt;/li&gt;
&lt;li&gt;View Relation Horizonal Graph：水平显示内容，如图4.6.3所示。&lt;/li&gt;
&lt;li&gt;View Relation Vertical Graph：垂直显示内容，如图4.6.1所示。&lt;/li&gt;
&lt;li&gt;Relation Window Properties：窗口属性设置，里面功能点比较多，这里单独划出一个小节详细说明。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;       &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201812/472002-20181206193915984-341982364.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;                                            图4.6.2&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201812/472002-20181206183041429-344011506.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;                                                                     图4.6.3&lt;/p&gt;
&lt;p&gt;    （4）Relation Window Properties&lt;/p&gt;
&lt;p&gt;       该对话框除了能设置字体，颜色等外观属性外，还能设置内容与光标选项的关系等多种内在联系。&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201812/472002-20181206201044309-1304861028.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;                                             图4.6.4&lt;/p&gt;
&lt;p&gt;      1）Automatic Symbol Tracking&lt;/p&gt;
&lt;p&gt;       设置Symbol自动跟踪相关属性，如下图所示。如果不希望自动跟踪Symbol，选择“Off”或者在Toolbar中选择“Lock Relation Window”即可。&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201812/472002-20181207170902184-69882119.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       这些选项字面意思比较简单，这里就不啰嗦了。&lt;/p&gt;
&lt;p&gt;      2）Automatic Expansion Option&lt;/p&gt;
&lt;p&gt;        Expand duplicate branches：是否展开重复的分支。&lt;/p&gt;
&lt;p&gt;        Level：展开分支的层级。比如设置为“2”，那么被Calls的函数，以及该函数再调用的函数都会显示。&lt;/p&gt;
&lt;p&gt;      3）View Relationship&lt;/p&gt;
&lt;p&gt;        单独设置被选中的Symbol类型与Relaiton Window中显示内容的关系，选中的类型不同，关系也不一样。该处列出了“Type”、“Functions”、“Variables/Constants”、“Classes”、“Files”五种类型，以及可以设置的关系。例如，如图4.6.4中，给“Functions”设置的是“Calls”关系，那么当鼠标选中某个函数，那么当前Relation Window中就会显示被该函数“Calls”的信息。&lt;/p&gt;
&lt;p&gt;        这些Relation可以分为3类，不同的类型匹配的速度也不一样，从快到慢依次为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Contains：显示当前symbol的内容。&lt;/li&gt;
&lt;li&gt;Calls：被当前symbol调用的其他symbol。比如选中了函数，则会显示被该函数调用的其他函数。&lt;/li&gt;
&lt;li&gt;References：显示有哪些symbol调用了当前symbol，作用范围仅在当前文件。比如，选中了某个函数，则会显示当前文件中调用了该函数的函数。在比较大的项目中，这项关系的匹配是比较耗时的。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;       对于“Group multiple references into one item” 以及“Columns”，其中的有些功能还没太明白，以后搞明白了再补上。&lt;/p&gt;
&lt;p&gt;      4）Graph按钮（最右边一列中的按钮）&lt;/p&gt;
&lt;p&gt;        该对话框主要用于设置关系图的外观，这个比较简单，不多说了。&lt;/p&gt;
&lt;p&gt;        &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201812/472002-20181212101229082-456801495.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;    （5）右键菜单栏&lt;/p&gt;
&lt;p&gt;       该菜单栏中的功能有的在前面讲到过，有的比较简单，就不一一列举。这里说一下“New Relation Window”，同一个窗口中可以同时打开多个Relation Window。开发者可以同时打开“Calls”关系窗口和“References”关系窗口，根据自己的需求决定，非常便利。&lt;/p&gt;
&lt;p&gt;        &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201812/472002-20181206200826720-1907441571.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  7、剪贴板窗口（Clip Window）&lt;/p&gt;
&lt;p&gt;       剪贴板窗口是一个浮动窗口，可以随意拖动和停留在界面中。它类似于剪贴板，但相比于剪贴板只能保存最近一次的剪切外，该窗口可以保留多个剪贴记录。&lt;/p&gt;
&lt;p&gt;    （1）开关位置&lt;/p&gt;
&lt;p&gt;        可以在SI界面顶部的Toolbar中点击“Clip Window”开关，或在顶部菜单栏“View &amp;gt; Clip Window”选择/取消来显示/隐藏该窗口。&lt;/p&gt;
&lt;p&gt;    （2）窗口内容&lt;/p&gt;
&lt;p&gt;       该窗口的显示信息如下图。每一个clip项都包含一clip名称和该clip的内容。&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201811/472002-20181127190155217-1200098656.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;     （3）Toolbar各功能简介&lt;/p&gt;
&lt;p&gt;       上图中最底部的Toolbar，从左往右功能如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;New Clip：创建一个新的clip。&lt;/li&gt;
&lt;li&gt;Delete Clip：删除选中的clip。&lt;/li&gt;
&lt;li&gt;Edit Clip：编辑选中的clip的内容。&lt;/li&gt;
&lt;li&gt;Cut To Clip：在“Source File Window”选中某字符串，点击该按钮，所选择部分将被剪切并弹出对话框创建一个新的clip，被剪内容将作为新clip的内容，clip名称需要自定义。&lt;/li&gt;
&lt;li&gt;Copy To Clip：与“Cut To Clip”类似，不同的是，该功能是复制选中的部分。&lt;/li&gt;
&lt;li&gt;Paste From Clip：选中某条clip，如果光标在“Source File Window”内，点击该功能按钮，会把clip内容粘贴在光标处。双击选中的clip也有同样的效果。&lt;/li&gt;
&lt;li&gt;Clip Window Properties：设置该窗口的一些属性&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;    （4）右键菜单栏&lt;/p&gt;
&lt;p&gt;       在该窗口内点击右键，会显示如下菜单栏。其中功能上面基本都介绍了，这里不赘述，只简单补充一下“Show Clipboard”。当选中某个clip，并点击“Show Clipboard”，会弹出一个窗口显示该clip的内容，和点击“Edit Clip”非常类似，只是无法编辑。&lt;/p&gt;
&lt;p&gt;        &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201811/472002-20181127195016988-1503742866.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  8、搜索窗口（Search Results Window）&lt;/p&gt;
&lt;p&gt;        搜索功能绝对是一个最常用的功能之一了，使用十分频繁，下面对搜索功能及搜索结果窗口做一些基本的介绍。&lt;/p&gt;
&lt;p&gt;    （1）搜索功能入口&lt;/p&gt;
&lt;p&gt;        开发者可以点击顶部主菜单栏中“Search”选择搜索子功能，如下图4.8.1所示；或者在顶部Toolbar快捷工具栏中点击相应的快捷按钮进行搜索，如下图4.8.2红框部分；或者使用快捷键调出对应的搜索功能窗口，如下图4.8.1所示。&lt;/p&gt;
&lt;p&gt;        &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201812/472002-20181204195434915-872454406.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;                                    图4.8.1&lt;/p&gt;
&lt;p&gt;        &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201812/472002-20181204201258867-599999657.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;                                                        图4.8.2&lt;/p&gt;
&lt;p&gt;    （2）Search&lt;/p&gt;
&lt;p&gt;       该功能主要在当前文件范围内进行搜索，根据自身的需要添加搜索条件，一般选择默认就可以了。&lt;/p&gt;
&lt;p&gt;        &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201812/472002-20181205100651946-245997547.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;                                                     图4.8.3&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Find：需要搜索的字符串，点击右边倒三角可以查看并选择历史搜索记录。&lt;/li&gt;
&lt;li&gt;Case Sensitive：大小写敏感。&lt;/li&gt;
&lt;li&gt;Use Regular Expressions：使用正则表达式。&lt;/li&gt;
&lt;li&gt;Wrap Arround：（还没清楚其作用）&lt;/li&gt;
&lt;li&gt;Select When Found：找到该字符串时，该字符串被选中。&lt;/li&gt;
&lt;li&gt;Whole Words Only：只包含整个要搜索的字符串。如果不选中，则包含欲搜索字符串的字符串都会被搜索到。&lt;/li&gt;
&lt;li&gt;Forward/Backward 以当前文件中鼠标光标所在处为参照点，向前/向后搜索。与图4.8.1或图4.8.2中“Search Forward”/“Search Backward”功能一致。&lt;/li&gt;
&lt;li&gt;Selection 在当前文件可见范围内搜索。&lt;/li&gt;
&lt;li&gt;Whole File （截图红框①处）：在当前整个文件内搜索。&lt;/li&gt;
&lt;li&gt;Search（截图红框②处）：如果能搜索到，鼠标只会定位到满足条件的某一个搜索结果处。&lt;/li&gt;
&lt;li&gt;Whole File（截图红框③处）：点击该按钮，会在当前整个文件中进行搜索，如果有多个搜索结果，会显示一个搜索结果列表，如下图4.8.4所示。&lt;/li&gt;
&lt;li&gt;Files（截图红框④处）：点击该按钮，会跳转到“Search Files”功能界面，下面会详细介绍。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;       &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201812/472002-20181205101458515-1307612192.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;                                                                                                       图4.8.4&lt;/p&gt;
&lt;p&gt;    （3）Search Files&lt;/p&gt;
&lt;p&gt;       与“Search”功能相比，这里用于在多个文件中进行搜索。如下图所示，为其功能界面，以下将对该功能进行简单介绍。&lt;/p&gt;
&lt;p&gt;        &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201812/472002-20181205102800195-55581200.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;                                                           图4.8.5&lt;/p&gt;
&lt;p&gt;        1）先看“Options”（上图红框②处）中各选项的含义（在“Search”功能中讲到过的选项含义，这里不再赘述）：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Project Wide：在整个项目范围内的所有文件中进行搜索。&lt;/li&gt;
&lt;li&gt;Include Subdirectories：在图4.8.5红框①处如果选中的是目录，该选项用于选择是否要在该目录的子目录中进行递归搜索。&lt;/li&gt;
&lt;li&gt;Find Non-Matching：&lt;/li&gt;
&lt;li&gt;Skip Inactive Code：跳过无效代码查找。&lt;/li&gt;
&lt;li&gt;Skip Comments：跳过注释查找。&lt;/li&gt;
&lt;li&gt;Search Only Comments：仅在注释中查找。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;       2）Find：在“Search”功能中讲过，这里不赘述。&lt;/p&gt;
&lt;p&gt;       3）File Name：制定查找范围，可以是具体的某个文件，也可以是某个文件夹。可以图4.8.5红框①处中选择，也可以在截图右下角点击“Browser”按钮进行选择。左边的倒三角点击后，显示历史记录列表。&lt;/p&gt;
&lt;p&gt;       4）图4.8.5红框①区：该区域会显示具体的文件或者目录。点击③处“Show Dirs”，该按钮显示的文字会在“Show Dirs”/“Show Files”之间换号，①区内容也会随之变化。在②区选择“Project Wide”也会显示所有文件，选择“Include Subdirectories”则会显示目录。&lt;/p&gt;
&lt;p&gt;       5）Search Results：④区中的选项为设置搜索结果需要显示哪些内容，如图4.8.4所示。&lt;/p&gt;
&lt;p&gt;       值得注意的是：在选择源文件的时候，不是硬盘中所有的文件都能显示，这里和前文介绍新建项目时所选择的源码路径所在盘符有关。&lt;/p&gt;
&lt;p&gt;    （4）Search Project/Lookup Reference&lt;/p&gt;
&lt;p&gt;       “Search Project“和”Lookup Reference”功能界面除了左上角标题栏不同外，其它一模一样，这里就以“Lookup Reference”为例，如下图所示。&lt;/p&gt;
&lt;p&gt;        &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201812/472002-20181205153608764-418343457.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;        1）Search Method：这里有四个选项&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Simple String：最普通的形式，把搜索项作为字符串，可以查找文件中出现的任意字符或者字符串，当工程比较大的时候查找比价慢。&lt;/li&gt;
&lt;li&gt;Regular Expression：正则表达式方式搜索。可以参考：&lt;a href=&quot;https://bbs.csdn.net/topics/330208990&quot; target=&quot;_blank&quot;&gt;【Source Insight搜索正则表达式使用技巧】&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Keyword Expression/Lookup Reference：这两种方式查找的结果基本相同，只是显示方式略有差异。有些文章中说，这两种方式都是使用SI预先建立的数据库，查找起来速度相当快，但通常这种速度只在查找标识符时有明显效果，且强烈建议像函数名、变量名等的查找，用这两种方式进行查找。这里笔者声明一下，笔者暂时还没体验到这里说的快速，在浩瀚的源码中搜索某个函数或变量时，都很费事，所以这里不敢打包票。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;        2）Lines of Context：每一条结果项显示的行数。前面我们可以看到，不同方式的搜索结果种，有的只显示一行，有的显示多行，就和这里有关。有的行数可以编辑，而有的不能编辑。&lt;/p&gt;
&lt;p&gt;        3）Search In：指定搜索范围。&lt;/p&gt;
&lt;p&gt;        4）Find Reference To：这个lable会根据“Search Method”中方式的选择而变化。其中的内容为搜索项，点击倒三角会显示搜索记录列表。&lt;/p&gt;
&lt;p&gt;    （5）Search Result Window&lt;/p&gt;
&lt;p&gt;        其实前面已经讲到过该窗口了，当搜索完后，会展示一个窗口用于显示搜索结果，如下图所示，红色框中显示了有多少个匹配项，多少个文件。主内容区也显示文件名，所在行数等信息。&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201812/472002-20181205090322853-2131378146.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;                                                                  图4.8.10                                   &lt;/p&gt;
&lt;p&gt;       下图是一个完整的搜索结果及其它窗口交互界面。当选择“Search Result Window”中某一项时，会在“Context Window”中实时显示其上下文内容，如下图中④去所示。在搜索结果项前都有一个红色按钮，如③区所示。点击对应项该按钮，会显示其对应的“Source File Window”及所搜索字段所在位置，且也有一个红色按钮，如下图②区所示，点击这些按钮，界面会在“Source File Window”和“Search Result Window”之前来回切换。下图①区显示的Toolbar按钮，我们在前面讲Toolbar的时候介绍过，是&quot;Go To Previous Link / Go To Next Link&quot;，此时点击这两个按钮会跳转到前一个/后一个搜索结果链接。&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201812/472002-20181205141954914-1974307573.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;                                                                 图4.8.11&lt;/p&gt;
&lt;p&gt;    （6）其他&lt;/p&gt;
&lt;p&gt;        在图4.8.1中“Search”子菜单中还有很多选项，有的比较简单，有的前文中陆陆续续介绍过，这里就不赘述了。&lt;/p&gt;
&lt;p&gt;  9、上下文窗口（Context Window）&lt;/p&gt;
&lt;p&gt;       上下文窗口是SI中一个革新功能，在用户浏览或者编辑源码过程中，会实时自动显示鼠标点击或选中部分的相关信息，可以简单地看做是预览功能。&lt;/p&gt;
&lt;p&gt;    （1）开关位置&lt;/p&gt;
&lt;p&gt;       上下文窗口的显示/隐藏开关位于菜单栏“View &amp;gt; Context Window” 或 Toolbar中“Context Window”按钮。&lt;/p&gt;
&lt;p&gt;    （2）窗口内容显示&lt;/p&gt;
&lt;p&gt;         上下文窗口位于前面SI概貌图的左下角，其显示内容，会根据鼠标所选取或点击的内容的类型而有很大差别。下表总结了不同的鼠标行为与相应的上下文窗口显示结果（摘自SI官方帮助文档）：&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201811/472002-20181121085816145-1254654121.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       1）在源文件窗口操作时&lt;/p&gt;
&lt;p&gt;       如果选中的是源文件窗口中的符号或局部变量，参数等，该窗口会显示选中内容被定义（如果是方法、类或结构体等，下同）或声明（如果是全局变量或引用等，下同）的上下文信息。如下图显示的是在源文件窗口中选中“reason”时的结果：顶部显示了选中的内容“reason”，类型“Locol Variable”，所在文件名“SystemServer.java”，所在文件路径等；中间显示区高亮显示了“reason”的定义处，以及它所在的上下文信息——函数performPendingShutdown()内；底部为工具栏，这个后面单独讲到。&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201811/472002-20181120195724087-334168505.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       如果在源文件窗口中输入信息，如果以这个字符串开头的符号有多个，则会在上下文窗口中显示匹配的符号列表。如下图显示的就是在源码文件中输入“star”字符串后该窗口的表现。&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201811/472002-20181121095444164-1741437940.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      2）在Project Window操作时&lt;/p&gt;
&lt;p&gt;        如果当前Project Window显示的是文件，且鼠标选中了其中一个文件，Context Window中显示的则是文件内容。&lt;/p&gt;
&lt;p&gt;        如果当前Project Window显示的是符号，鼠标选中后，Context Window中则会显示符号的声明或这定义的上下文代码。&lt;/p&gt;
&lt;p&gt;      3）在Clip Window操作时&lt;/p&gt;
&lt;p&gt;       当鼠标选中Clip Window列表中的某一项Clip时，Context Window顶部会显示当前内容类型为“Clip”，Clip名称为“Reason”，内容来源为“Text from Typing”，Clip内容为“Text Clip in Context Window”，当双击Clip内容时，会弹出一个编辑窗口，编辑其内容。&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201811/472002-20181121202631438-55834270.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      4）在Symbol Window操作时&lt;/p&gt;
&lt;p&gt;       如果当期鼠标选中的是Symbol中的某一个符号，那Context Window显示的是对符号的定义或声明。&lt;/p&gt;
&lt;p&gt;      5）在Relation Window操作时&lt;/p&gt;
&lt;p&gt;       如果当前鼠标选中的是Relation Window中的内容时，Context Window中显示的是该引用项所在的位置。如下图中，Relation Window显示的是SystemServer.java类中performPendingShutdown()方法中的局部变量reason的应用者列表，当鼠标点击最后一条时，Context Window就定位并高亮显示了该引用项的位置。&lt;/p&gt;
&lt;p&gt;        &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201811/472002-20181121210212294-1077998667.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201811/472002-20181121210259836-624703853.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    （3）底部工具栏&lt;/p&gt;
&lt;p&gt;       下图为Context Wiindow中底部的工具栏，黄框部分功能参考SI顶部Toolbar中部分，这里不赘述。蓝框部分功能为：Complete Symbol、Lock Context Window、Context Window Properties&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201811/472002-20181121211356671-106052490.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Complete Symbol：自动补全符号功能。即当用户在Source File Window区域输入字符串时，点击该按钮可以显示以该字符串开头的符号列表，供用户选择自动补全。如下图所示：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;         &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201811/472002-20181121212747171-1898954117.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Lock Context Window：上下文窗口锁。选中该按钮后，上下文窗口内容就会被锁住，不会实时变化；再次点击，则取消锁功能。&lt;/li&gt;
&lt;li&gt;Context Window Properties：上下文窗口属性。设置上下文窗口的字体类型/大小/颜色，背景色，跟踪属性，显示内容等特性。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;        &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201811/472002-20181121213341422-1656578952.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    （4）右键菜单栏&lt;/p&gt;
&lt;p&gt;      在Context Window上点击右键调出功能菜单如下所所示，除了红框中“Project-Wide Rename（顾名思义：项目范围内对选中项重命名）”外其他都在前面讲过了，这里不赘述。&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201811/472002-20181121213704820-1689630146.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;五、帮助功能&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;       &lt;/strong&gt;正如大多数软件及开发工具包一样，官方提供的帮助文档就是最好的教程，SI也不例外。当然这需要读者有一定的英文文档阅读基本功，因为这类文档都是英文版的。从笔者的经验来看，语法什么的其实不那么复杂，关键的生僻单词可以查词典，也不是难事，反而是阅读的耐心才是阅读英文文档的关键。下面简单介绍一下SI的帮助相关的功能。&lt;/p&gt;
&lt;p&gt;  1、功能入口&lt;/p&gt;
&lt;p&gt;       点击SI顶部菜单栏“Help”子菜单栏，即可显示“帮助”相关的子功能&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201812/472002-20181215101622791-1329501260.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  2、帮助文档&lt;/p&gt;
&lt;p&gt;      点击列表中的“Help”或者快捷键F1，会调出官方帮助文档来，如下图所示：&lt;/p&gt;
&lt;p&gt;      &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201812/472002-20181215102633835-186501273.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      该部分提供了“目录”、“索引”、“搜索”、“书签”等搜索方式，搜索起来非常方便。从上面截图可以看到“Window Tour”，是不是似曾相识？没错，笔者前文将到的常用窗口功能，就有一部分是取材于该帮助文档。该文档的使用还是比较简单的，这里就不啰嗦了。&lt;/p&gt;
&lt;p&gt;  2、Help Mode&lt;/p&gt;
&lt;p&gt;      点击该项后，会在界面上出现一个鼠标箭头+“？”的符号，随着鼠标移动，只要在SI界面上点击某个窗口或按钮，就会调出帮助文档，并显示点击处相关的帮助信息。&lt;/p&gt;
&lt;p&gt;  3、HTML Help/SDK Help&lt;/p&gt;
&lt;p&gt;       用于加载本地的一些帮助文档。&lt;/p&gt;
&lt;p&gt;  4、Create Key List&lt;/p&gt;
&lt;p&gt;        会弹出如下文档，记录了SI的功能点，以及对应的快捷键。开发者可以在其中增、删、改、查快捷键。&lt;/p&gt;
&lt;p&gt;        &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201812/472002-20181215104958902-379381302.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  5、Create Command List &lt;/p&gt;
&lt;p&gt;       形式上类似于上面的“Create Key List”，功能上显示了SI的功能点以及对该功能点的描述。&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201812/472002-20181215110333232-72152001.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  6、Toolbar帮助快捷按钮&lt;/p&gt;
&lt;p&gt;       在前文讲“Toolbar”的时候讲到过，这里再提一下。SI顶部Toolbar上有两个帮助相关的快捷按钮，如下图所示&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201811/472002-20181118010334157-663466002.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       这两个功能前面也都提到了，这里不赘述。&lt;/p&gt;
&lt;p&gt;  7、Other&lt;/p&gt;
&lt;p&gt;       菜单栏中还有“Serial Number”、“Source Insight Web Site”、“About Source Insight”功能，比较简单，主要用于显示一些SI的基本信息，这里也不啰嗦了。&lt;/p&gt;
&lt;p&gt;       笔者之所以特地用一个章节来写“Help”这个用法很简单的功能，是因为笔者在学习SI时，就极大地收益于该帮助文档。该文章中的不少内容也是取材于该文档。与此同时，从使用其他软件和SDK的经历来看，对官方帮助文档的作用有着深切的体会。所以笔者在以后的开发和学习中，会更加加强对官方文档的阅读，这一节也是用于勉励自己，也建议读者也能够养成阅读官方文档的好习惯。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;六、宏（Marco）的使用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;      介绍SI，就不得不提到宏。宏是SI的一个强大的功能，有的人甚至认为是SI中最强大最有趣的功能。用户可以通过编写宏来实现自定义功能，极大地提高效率。笔者以前在网上找到过一个这方面写得挺好的教程，作者非常用心，笔者这里就不重复造这个轮子了（当然笔者在这方面经验和水平都有限-_-），这里把该教程分享出来：&lt;/p&gt;
&lt;p&gt;       链接: &lt;a href=&quot;https://pan.baidu.com/s/1-Xi41nwnX94_PrawvXq1fA&quot; target=&quot;_blank&quot;&gt;https://pan.baidu.com/s/1-Xi41nwnX94_PrawvXq1fA&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;       提取码: ijpw&lt;/p&gt;
&lt;p&gt;       该教程介绍了当前广受欢迎的三个宏：Quicker、Code Review、Chnchar的使用，配置等方面的内容。如果下载有问题，可以和笔者联系：476526447@qq.com。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;七、常用技巧&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;     本节主要记录一些比较实用且比较零散的使用技巧。&lt;/p&gt;
&lt;p&gt;  1、查看最近打开的文件列表。&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201812/472002-20181215133725120-818320299.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       可以结合Toolbar中的“Go Back/Go Forward”快捷键使用。&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201811/472002-20181117223941820-1490219216.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  2、自定义快捷键&lt;/p&gt;
&lt;p&gt;       开发者可以根据自己习惯，自行定义快捷键。功能路径为：Menu &amp;gt; Options &amp;gt; Key Assigments&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201812/472002-20181215134914442-685838539.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       选择要修改的功能项，点击“Assign New Key”会弹出上图底部的操作说明，按照操作进行即可自定义快捷键。如果想恢复默认，点击“Reset”按钮即可。&lt;/p&gt;

&lt;p&gt;       SI的功能太多了，笔者不可能全部能写出来，这里先从整体上做介绍并打好框架，后续笔者会根据自己的使用情况，慢慢完善。由于经验和水平有限，难免有描述错误或者不妥之处，请读者多多指教！&lt;/p&gt;
</description>
<pubDate>Sat, 15 Dec 2018 06:20:00 +0000</pubDate>
<dc:creator>宋者为王</dc:creator>
<og:description>Source Insight是当前世界上最好的程序编辑器之一，几乎支持所有的语言，拥有丰富且便捷的功能，快捷的源码导航能力，实时显示的上下文信息，独立的符号数据库等特点，使得它在世界范围内广受程序员和</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/andy-songwei/p/10123294.html</dc:identifier>
</item>
<item>
<title>MyBatis实战之解析与运行 - 挑战者V</title>
<link>http://www.cnblogs.com/youcong/p/10046806.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/youcong/p/10046806.html</guid>
<description>&lt;p&gt;本次所谈的原理仅仅只涉及基本的框架和核心代码，并不会全部都说到，比如关于MyBatis是如何解析XML文件和其他配置文件从而的到内容，还有就是JDBC如何使用，关于JDBC如何使用，可以参考我的这篇博客:&lt;a id=&quot;post_title_link_7841994&quot; href=&quot;https://www.cnblogs.com/youcong/p/7841994.html&quot;&gt;单例模式和JDBC&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;还有就是关于Java基础方面的内容，个人建议大家抽空看看《Java编程思想》这本书，这本书可以作为一本参考书来看，不要从头开始看，有选择的阅读是最好的，从头开始看，别说看懂问题，估计你看的都想睡觉了。另外最好的话还是可以通过知识付费看看人家是怎么讲Java的，通过知识付费获取的Java相关知识，应该是不错的，比如在极客时间这个APP中看到的杨晓峰《Java核心技术36讲》，口碑目前还不错，不过建议朋友们最好还是自己时不时根据一些参考书或者官网再加上自己工作用到时刻复习一下，总结一下。这样还是有很大好处的。&lt;/p&gt;
&lt;p&gt;MyBatis的运行分为两大部分，第一部分是读取配置文件缓存到Configuration对象，用以创建SqlSessionFactory，第二部分是SqlSession的执行过程。相对而言，SqlSessionFactory的创建比较容易理解，而SqlSession的执行过程远远不是那么简单了，它将包括许多复杂的技术，我们需要讨论反射技术和动态代理技术，这是揭示MyBatis底层架构的基础。&lt;/p&gt;

&lt;p&gt;当我们掌握了MyBatis的运行原理，我们就可以知道MyBatis是怎么运行的，同时当我们在深入理解MyBatis相关的源码和涉及到的设计模式后，我们也许就能像MyBatis-Plus的开发者那样，开发出一个比MyBatis或者MyBatis-Plus还要好的持久层框架。&lt;/p&gt;

&lt;p&gt;一、涉及的技术难点简介&lt;/p&gt;
&lt;p&gt;Mapper仅仅只是一个接口，而不是一个包含逻辑的实现类。我们知道一个接口是没有办法去执行的，那么它是怎么运行的呢?这不是违反教科书上说的接口不能运行的道理吗?相信不少初学者会对此有疑惑。&lt;/p&gt;
&lt;p&gt;答案就是动态代理。&lt;/p&gt;

&lt;p&gt;首先，什么是代理模式？所谓的代理模式就是在原有的服务商多加以占位，通过这个占位去控制服务的访问。这句话不太容易理解，举例而言，假设你是一个公司的工程师，能提供一些技术服务，公司的客服就一个美女，她不懂技术。而我是一个客户需要你们公司提供技术服务。显然，我只会找到你们的客服，和客服沟通，而不是找你沟通。客服会根据公司的规章制度和业务规则来决定找不找你服务。那么这个时候客服就等同于你的一个代理，她通过和我的交流来控制对你的访问，当然她也可以提供一些你们公司对外的服务。而我只能通过她的代理访问你。对我而言，根本不需要认识你，只需要认识客服就可以了。事实上，站在我的角度，我会认为客服就代表你们公司，而不管真正为我服务的你是怎么样的。&lt;/p&gt;
&lt;p&gt;其次，为什么要使用代理模式?通过代理，一方面可以控制如何访问真正的服务对象，提供额外服务。另外一方面有机会通过重写一些类来满足特定的需要，正如客服也可以根据公司的业务规则，提供一些服务，这个时候就不需要劳你大驾。&lt;/p&gt;
&lt;p&gt;动态代理示意图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1255290/201812/1255290-20181202202828189-935911869.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 一般而言，动态代理分为两种，一种是JDK反射机制提供的代理，另一种是CGLIB代理。在JDK提供的代理，我们必须要提供接口，而CGLIB则不需要提供接口，在MyBatis里面两种动态代理技术都已经使用了。但是在此之前我们需要学习的技术就是反射。&lt;/p&gt;

&lt;p&gt;1.反射技术&lt;/p&gt;
&lt;p&gt;关于反射技术详细可以参考我的这篇博客:&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/youcong/p/8723177.html&quot;&gt;MyBatis之反射技术+JDK动态代理+cglib代理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;不过在此基础上，我还是要说说什么是反射?&lt;/p&gt;
&lt;p&gt;JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。&lt;/p&gt;
&lt;div class=&quot;para&quot; readability=&quot;12.745098039216&quot;&gt;JAVA反射（放射）机制：“程序运行时，允许改变程序结构或变量类型，这种语言称为&lt;a href=&quot;https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E8%AF%AD%E8%A8%80&quot; target=&quot;_blank&quot;&gt;动态语言&lt;/a&gt;”。从这个观点看，Perl，Python，Ruby是动态语言，C++，Java，C#不是动态语言。但是JAVA有着一个非常突出的动态相关机制：Reflection，用在Java身上指的是我们可以于运行时加载、探知、使用编译期间完全未知的classes。换句话说，Java程序可以加载一个运行时才得知名称的class，获悉其完整构造（但不包括methods定义），并生成其对象实体、或对其fields设值、或唤起其methods。&lt;/div&gt;

&lt;p&gt;2.JDK动态代理&lt;/p&gt;
&lt;p&gt;JDK的动态代理，是由JDK的java.lang,reflect.*包提供支持的，我们需要完成这么几个步骤?&lt;/p&gt;
&lt;p&gt;(1)编写服务类和接口，这个是真正的服务提供者，在JDK代理中接口是必须的;&lt;/p&gt;
&lt;p&gt;(2)编写代理类，提供绑定和代理的方法;&lt;/p&gt;
&lt;p&gt;JDK的代理最大的缺点是需要提供接口，而MyBatis的Mapper就是一个接口，它采用的就是JDK的动态代理。&lt;/p&gt;



&lt;p&gt;3.CGLIB动态代理&lt;/p&gt;
&lt;p&gt;JDK提供的动态代理存在一个缺陷，就是你必须提供接口才可以使用，为了克服这个缺陷，我们可以使用开源框架-CGLIB，它是一种流行的动态代理。&lt;/p&gt;



&lt;p&gt;二、构建SqlSessionFactory过程&lt;/p&gt;
&lt;p&gt;SqlSessionFactory是MyBatis的核心类之一，其最重要的功能就是提供创建MyBatis的核心接口SqlSession，所以我们需要先创建SqlSessionFactory，为此我们需要提供配置文件和相关的参数。而MyBatis是一个复杂的系统，采用构造模式去创建SqlSessionFactory，我们可以通过SqlSessionFactoryBeanBuilder去构建。构建分为两步:&lt;/p&gt;

&lt;p&gt;第一步，通过org.apache.ibatis.builder.xml.XMLConfigBuilder解析配置的XML文件，读出配置参数，并将读取的数据存入这个org.apache.ibatis.session.Configuration类中。注意，MyBatis几乎所有的配置都是存在这里的。&lt;/p&gt;

&lt;p&gt;第二步，使用Configuration对象去创建SqlSessionFactory。MyBatis中的SqlSessionFactory是一个接口，而不是实现类，为此MyBatis提供了一个默认的SqlSessionFactory实现类，我们一般都会使用它org.apache.ibatis.session.defaults.DefaultSqlSessionFactory。注意，在大部分情况下我们都没有必要自己去创建新的SqlSessionFactory的实现类。&lt;/p&gt;

&lt;p&gt;这种创建的方式就是一种Builder模式。对于复杂的对象而已，直接使用构造方法构建是有困难的，这会导致大量的逻辑放在构造方法中，由于对象的复杂性，在构建的时候，我们更希望一步一步有秩序的来构建它，从而降低其复杂性。这个时候使用一个参数类总领全局。例如，Configuration类，然后分布构建，例如，DefaultSqlSessionFactory类，就可以构建一个复杂的对象，例如SqlSessionFactory，这种方式值得我们在工作中学习和使用。&lt;/p&gt;

&lt;p&gt;1.构建Configuration&lt;/p&gt;
&lt;p&gt;在SqlSessionFactory构建中，Configuration是最重要的，它的作用如下:&lt;/p&gt;
&lt;p&gt;(1)读取配置文件，包括基础配置的XML和映射器的XML文件;&lt;/p&gt;
&lt;p&gt;(2)初始化基础配置，比如MyBatis的别名等，一些重要的类对象，例如插件、映射器、ObjectFactory和typeHandler对象;&lt;/p&gt;
&lt;p&gt;(3)提供单例，为后续创建SessionFactory服务并提供配置的参数;&lt;/p&gt;
&lt;p&gt;(4)执行一些重要的对象方法，初始化配置信息;&lt;/p&gt;

&lt;p&gt;显然Configuration不会是一个很简单的类，MyBatis的配置信息都会来自于此。有兴趣的朋友可以读读源码，几乎所有的配置都可以在这里找到踪影。&lt;/p&gt;

&lt;p&gt;Configuration是通过XMLConfigBuilder去构建。首先，MyBatis会读出所有的XML配置的信息。然后，将这些信息保存到Configuration类的单例中。它会做如下初始化。&lt;/p&gt;
&lt;p&gt;a.properties全局参数;&lt;/p&gt;
&lt;p&gt;b.settings设置;&lt;/p&gt;
&lt;p&gt;c.typeAliases别名：&lt;/p&gt;
&lt;p&gt;d.typeHandler类型处理器;&lt;/p&gt;
&lt;p&gt;e.ObjectFactory对象;&lt;/p&gt;
&lt;p&gt;f.plugin插件&lt;/p&gt;
&lt;p&gt;g.environment环境;&lt;/p&gt;
&lt;p&gt;h.DatabaseIdProvier数据库标识;&lt;/p&gt;
&lt;p&gt;i.Mapper映射器;&lt;/p&gt;


&lt;p&gt;2.映射器的内部组成&lt;/p&gt;

&lt;p&gt;一般而言，一个映射器是由3个部分组成:&lt;/p&gt;
&lt;p&gt;(1)MappedStatement，它保存映射器的一个节点。包括许多我们配置的SQL、SQL的id、缓存信息、resultMap、parameterType、resultType、languageDriver等重要配置内容；&lt;/p&gt;

&lt;p&gt;(2)SqlSource，它是提供BoundSql对象的地方，它是MappedStatement的一个属性；&lt;/p&gt;

&lt;p&gt;(3)BoundSql，它是建立SQL和参数的地方。它有3个常用的属性:SQL、parameterObject、parameterMappings；&lt;/p&gt;

&lt;p&gt;这些都是映射器的重要内容，也是MyBatis的核心内容。在插件的应用中常常会用到它们。映射器的解析过程是比较复杂的，但是在大部分的情况下，我们并不需要去理会解析和组装SQL的规则，因为大部分的插件只要做很小的改变即可，无需做很大的改变。大的改变可能导致重写这些内容。所以我们主要关注参数和SQL。&lt;/p&gt;

&lt;div class=&quot;para&quot; readability=&quot;144.5&quot;&gt;映射器的组成部分，如图所示:&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1255290/201812/1255290-20181202212301328-1585989928.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;注意，这张图并没有将所有的方法和属性都列举出来，只列举了主要的属性和方法。&lt;/p&gt;
&lt;p&gt;MappedStatement对象涉及的东西较多，我们一般都不去修改它，因为容易产生不必要的错误。SqlSource是一个接口，它的主要作用是根据参数和其他的规则组装SQL。这些都是很复杂的东西，好在MyBatis本身已经实现了它，一般也不需要去修改它。对于参数和SQL而言，主要的规则都反映在BoundSql类对象上，在插件中往往需要拿到它进而可以拿到当前运行的SQL的参数以及参数规则，做出适当的修改，来满足我们特殊的需求。&lt;/p&gt;
&lt;p&gt;BoundSql会提供3个主要的属性:parameterMappings、paramterObject和sql。&lt;/p&gt;
&lt;p&gt;(1)其中parameterObject为参数本身，前面我们说到过，参数可以是简单对象，Pojo、Map或者@Param注解的参数，由于它在插件中相当常用，后面我们有必要讨论一下它的规则;&lt;/p&gt;
&lt;p&gt;(2)传递简对象(包括int、String、float、double等),比如当我们传递int类型时，MyBatis会把参数变为Integer对象传递，类似的long、String、float、double也是如此;&lt;/p&gt;
&lt;p&gt;(3)如果我们传递的是Pojo或者Map，那么这个parameterObject就是你传入的Pojo或者Map不变;&lt;/p&gt;
&lt;p&gt;(4)当然我们也可以传递多个参数，如果没有@Param注解，那么MyBatis就会把parameterObject变为一个Map&amp;lt;String,Object&amp;gt;对象，其键值的关系是按顺序来规划的；&lt;/p&gt;
&lt;p&gt;(5)如果我们使用@Param注解，那么MyBatis就会把parameterObject变为一个Map&amp;lt;String,Object&amp;gt;对象，类似于没有@Param注解，只是把其数字的键值对应置换为@Param注解的键值;&lt;/p&gt;
&lt;p&gt;(6)parameterMappings，它是一个List，每个元素都是ParameterMapping的对象。这个对象会描述我们的参数。参数包括属性、名称、表达式、javaType、jdbcType、typeHandler等重要信息，我们一般不需要去改变它。通过它可以实现参数和SQL的结合，以便PreparedStatement能够通过它找到parameterObject对象的属性并设置参数，使得程序准确运行;&lt;/p&gt;
&lt;p&gt;(7)sql属性就是我们书写在映射器里面的一条SQL，在大多数时候无需修改它，只有在插件的情况下，我们可以根据需要进行改写。改写SQL将是一件危险的事情，请务必慎重行事;&lt;/p&gt;

&lt;p&gt;3.构建SqlSessionFactory&lt;/p&gt;
&lt;p&gt;有了Configuration对象构建SqlSessionFactory就很简单了，我们只要写很简短的代码便可以了。&lt;/p&gt;
&lt;p&gt;例如:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
  sqlSessionFactory = &lt;span&gt;new&lt;/span&gt; SqlSessionFactoryBuilder().build(Resources.getResourceAsStream(resource));
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;MyBatis会根据Configuration的配置读取所配置的信息，构建SqlSessionFactory对象。&lt;/p&gt;


&lt;p&gt;三、SqlSession运行过程&lt;/p&gt;
&lt;p&gt;SqlSession的运行过程是整个MyBatis最难以理解的部分。SqlSession是一个接口，使用它并不复杂。我们构建SqlSessionFactory就可以轻易地拿到SqlSession了。SqlSession给出了查询、插入、更新、删除的方法，在旧版本的MyBatis或iBatis中常常使用这些接口方法，而在新版的MyBatis中我们建议使用Mapper，所以它就是MyBatis最为常用和重要的接口之一。&lt;/p&gt;
&lt;p&gt;SqlSession内部并没有那么容易，因为它的内部实现相当复杂。&lt;/p&gt;

&lt;p&gt;1.映射器的动态代理&lt;/p&gt;
&lt;p&gt;Mapper映射是通过动态代理来实现的，我们来看看代码清单:&lt;/p&gt;
&lt;p&gt;MapperProxyFactory源码如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 *    Copyright 2009-2015 the original author or authors.
 *
 *    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *       &lt;/span&gt;&lt;span&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/span&gt;&lt;span&gt;
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; org.apache.ibatis.binding;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Method;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Proxy;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Map;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.ConcurrentHashMap;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.ibatis.session.SqlSession;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Lasse Voss
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MapperProxyFactory&amp;lt;T&amp;gt;&lt;span&gt; {

  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Class&amp;lt;T&amp;gt;&lt;span&gt; mapperInterface;
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Map&amp;lt;Method, MapperMethod&amp;gt; methodCache = &lt;span&gt;new&lt;/span&gt; ConcurrentHashMap&amp;lt;Method, MapperMethod&amp;gt;&lt;span&gt;();

  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; MapperProxyFactory(Class&amp;lt;T&amp;gt;&lt;span&gt; mapperInterface) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.mapperInterface =&lt;span&gt; mapperInterface;
  }

  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Class&amp;lt;T&amp;gt;&lt;span&gt; getMapperInterface() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; mapperInterface;
  }

  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Map&amp;lt;Method, MapperMethod&amp;gt;&lt;span&gt; getMethodCache() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; methodCache;
  }

  @SuppressWarnings(&lt;/span&gt;&quot;unchecked&quot;&lt;span&gt;)
  &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; T newInstance(MapperProxy&amp;lt;T&amp;gt;&lt;span&gt; mapperProxy) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Class[] { mapperInterface }, mapperProxy);
  }

  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; T newInstance(SqlSession sqlSession) {
    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; MapperProxy&amp;lt;T&amp;gt; mapperProxy = &lt;span&gt;new&lt;/span&gt; MapperProxy&amp;lt;T&amp;gt;&lt;span&gt;(sqlSession, mapperInterface, methodCache);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; newInstance(mapperProxy);
  }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这里我们可以看到动态代理对接口的绑定，它的作用就是生成动态代理对象(占位)。&lt;/p&gt;
&lt;p&gt;而代理的方法则被放到MapperProxy类中。&lt;/p&gt;
&lt;p&gt;MapperProxy源码如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 *    Copyright 2009-2017 the original author or authors.
 *
 *    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *       &lt;/span&gt;&lt;span&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/span&gt;&lt;span&gt;
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; org.apache.ibatis.binding;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.Serializable;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.invoke.MethodHandles;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Constructor;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.InvocationHandler;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Method;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Modifier;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Map;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.ibatis.lang.UsesJava7;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.ibatis.reflection.ExceptionUtil;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.ibatis.session.SqlSession;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Clinton Begin
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Eduardo Macarron
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MapperProxy&amp;lt;T&amp;gt; &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; InvocationHandler, Serializable {

  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; serialVersionUID = -6424540398559729838L&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; SqlSession sqlSession;
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Class&amp;lt;T&amp;gt;&lt;span&gt; mapperInterface;
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Map&amp;lt;Method, MapperMethod&amp;gt;&lt;span&gt; methodCache;

  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; MapperProxy(SqlSession sqlSession, Class&amp;lt;T&amp;gt; mapperInterface, Map&amp;lt;Method, MapperMethod&amp;gt;&lt;span&gt; methodCache) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sqlSession =&lt;span&gt; sqlSession;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.mapperInterface =&lt;span&gt; mapperInterface;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.methodCache =&lt;span&gt; methodCache;
  }

  @Override
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object invoke(Object proxy, Method method, Object[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Object.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.equals(method.getDeclaringClass())) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; method.invoke(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, args);
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isDefaultMethod(method)) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; invokeDefaultMethod(proxy, method, args);
      }
    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable t) {
      &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; ExceptionUtil.unwrapThrowable(t);
    }
    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; MapperMethod mapperMethod =&lt;span&gt; cachedMapperMethod(method);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; mapperMethod.execute(sqlSession, args);
  }

  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; MapperMethod cachedMapperMethod(Method method) {
    MapperMethod mapperMethod &lt;/span&gt;=&lt;span&gt; methodCache.get(method);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mapperMethod == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
      mapperMethod &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MapperMethod(mapperInterface, method, sqlSession.getConfiguration());
      methodCache.put(method, mapperMethod);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; mapperMethod;
  }

  @UsesJava7
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Object invokeDefaultMethod(Object proxy, Method method, Object[] args)
      &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Constructor&amp;lt;MethodHandles.Lookup&amp;gt; constructor = MethodHandles.Lookup.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;
        .getDeclaredConstructor(Class.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;constructor.isAccessible()) {
      constructor.setAccessible(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Class&amp;lt;?&amp;gt; declaringClass =&lt;span&gt; method.getDeclaringClass();
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; constructor
        .newInstance(declaringClass,
            MethodHandles.Lookup.PRIVATE &lt;/span&gt;|&lt;span&gt; MethodHandles.Lookup.PROTECTED
                &lt;/span&gt;| MethodHandles.Lookup.PACKAGE |&lt;span&gt; MethodHandles.Lookup.PUBLIC)
        .unreflectSpecial(method, declaringClass).bindTo(proxy).invokeWithArguments(args);
  }

  &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
   * Backport of java.lang.reflect.Method#isDefault()
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isDefaultMethod(Method method) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (method.getModifiers()
        &lt;/span&gt;&amp;amp; (Modifier.ABSTRACT | Modifier.PUBLIC | Modifier.STATIC)) ==&lt;span&gt; Modifier.PUBLIC
        &lt;/span&gt;&amp;amp;&amp;amp;&lt;span&gt; method.getDeclaringClass().isInterface();
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 上面运用了invoke方法。一旦mapper是一个代理对象，那么它就会运行到invoke方法里面，invoke首先判断它是否是一个类，显然这里Mapper是一个接口而不是类，所以判定失败。那么就会生成MapperMethod对象，它是通过cachedMapperMethod方法对其初始化的，然后执行execute方法，把sqlSession和当前运行的参数传递进去。&lt;/p&gt;
&lt;p&gt;这个exexute方法的源码如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;105&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 *    Copyright 2009-2017 the original author or authors.
 *
 *    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *       &lt;/span&gt;&lt;span&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/span&gt;&lt;span&gt;
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; org.apache.ibatis.binding;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.ibatis.annotations.Flush;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.ibatis.annotations.MapKey;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.ibatis.cursor.Cursor;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.ibatis.mapping.MappedStatement;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.ibatis.mapping.SqlCommandType;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.ibatis.mapping.StatementType;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.ibatis.reflection.MetaObject;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.ibatis.reflection.ParamNameResolver;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.ibatis.reflection.TypeParameterResolver;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.ibatis.session.Configuration;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.ibatis.session.ResultHandler;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.ibatis.session.RowBounds;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.ibatis.session.SqlSession;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Array;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Method;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.ParameterizedType;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Type;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; java.util.*&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Clinton Begin
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Eduardo Macarron
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Lasse Voss
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MapperMethod {

  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; SqlCommand command;
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; MethodSignature method;

  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; MapperMethod(Class&amp;lt;?&amp;gt;&lt;span&gt; mapperInterface, Method method, Configuration config) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.command = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SqlCommand(config, mapperInterface, method);
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.method = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MethodSignature(config, mapperInterface, method);
  }

  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object execute(SqlSession sqlSession, Object[] args) {
    Object result;
    &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (command.getType()) {
      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; INSERT: {
      Object param &lt;/span&gt;=&lt;span&gt; method.convertArgsToSqlCommandParam(args);
        result &lt;/span&gt;=&lt;span&gt; rowCountResult(sqlSession.insert(command.getName(), param));
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
      }
      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; UPDATE: {
        Object param &lt;/span&gt;=&lt;span&gt; method.convertArgsToSqlCommandParam(args);
        result &lt;/span&gt;=&lt;span&gt; rowCountResult(sqlSession.update(command.getName(), param));
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
      }
      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; DELETE: {
        Object param &lt;/span&gt;=&lt;span&gt; method.convertArgsToSqlCommandParam(args);
        result &lt;/span&gt;=&lt;span&gt; rowCountResult(sqlSession.delete(command.getName(), param));
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
      }
      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; SELECT:
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (method.returnsVoid() &amp;amp;&amp;amp;&lt;span&gt; method.hasResultHandler()) {
          executeWithResultHandler(sqlSession, args);
          result &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (method.returnsMany()) {
          result &lt;/span&gt;=&lt;span&gt; executeForMany(sqlSession, args);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (method.returnsMap()) {
          result &lt;/span&gt;=&lt;span&gt; executeForMap(sqlSession, args);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (method.returnsCursor()) {
          result &lt;/span&gt;=&lt;span&gt; executeForCursor(sqlSession, args);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
          Object param &lt;/span&gt;=&lt;span&gt; method.convertArgsToSqlCommandParam(args);
          result &lt;/span&gt;=&lt;span&gt; sqlSession.selectOne(command.getName(), param);
        }
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; FLUSH:
        result &lt;/span&gt;=&lt;span&gt; sqlSession.flushStatements();
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
      &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BindingException(&quot;Unknown execution method for: &quot; +&lt;span&gt; command.getName());
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (result == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; method.getReturnType().isPrimitive() &amp;amp;&amp;amp; !&lt;span&gt;method.returnsVoid()) {
      &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BindingException(&quot;Mapper method '&quot; +&lt;span&gt; command.getName() 
          &lt;/span&gt;+ &quot; attempted to return null from a method with a primitive return type (&quot; + method.getReturnType() + &quot;).&quot;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
  }

  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Object rowCountResult(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; rowCount) {
    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt;&lt;span&gt; Object result;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (method.returnsVoid()) {
      result &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (Integer.&lt;span&gt;class&lt;/span&gt;.equals(method.getReturnType()) ||&lt;span&gt; Integer.TYPE.equals(method.getReturnType())) {
      result &lt;/span&gt;=&lt;span&gt; rowCount;
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (Long.&lt;span&gt;class&lt;/span&gt;.equals(method.getReturnType()) ||&lt;span&gt; Long.TYPE.equals(method.getReturnType())) {
      result &lt;/span&gt;= (&lt;span&gt;long&lt;/span&gt;&lt;span&gt;)rowCount;
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (Boolean.&lt;span&gt;class&lt;/span&gt;.equals(method.getReturnType()) ||&lt;span&gt; Boolean.TYPE.equals(method.getReturnType())) {
      result &lt;/span&gt;= rowCount &amp;gt; 0&lt;span&gt;;
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BindingException(&quot;Mapper method '&quot; + command.getName() + &quot;' has an unsupported return type: &quot; +&lt;span&gt; method.getReturnType());
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
  }

  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; executeWithResultHandler(SqlSession sqlSession, Object[] args) {
    MappedStatement ms &lt;/span&gt;=&lt;span&gt; sqlSession.getConfiguration().getMappedStatement(command.getName());
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;StatementType.CALLABLE.equals(ms.getStatementType())
        &lt;/span&gt;&amp;amp;&amp;amp; &lt;span&gt;void&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;.equals(ms.getResultMaps().get(0&lt;span&gt;).getType())) {
      &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BindingException(&quot;method &quot; +&lt;span&gt; command.getName()
          &lt;/span&gt;+ &quot; needs either a @ResultMap annotation, a @ResultType annotation,&quot;
          + &quot; or a resultType attribute in XML so a ResultHandler can be used as a parameter.&quot;&lt;span&gt;);
    }
    Object param &lt;/span&gt;=&lt;span&gt; method.convertArgsToSqlCommandParam(args);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (method.hasRowBounds()) {
      RowBounds rowBounds &lt;/span&gt;=&lt;span&gt; method.extractRowBounds(args);
      sqlSession.select(command.getName(), param, rowBounds, method.extractResultHandler(args));
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      sqlSession.select(command.getName(), param, method.extractResultHandler(args));
    }
  }

  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &amp;lt;E&amp;gt;&lt;span&gt; Object executeForMany(SqlSession sqlSession, Object[] args) {
    List&lt;/span&gt;&amp;lt;E&amp;gt;&lt;span&gt; result;
    Object param &lt;/span&gt;=&lt;span&gt; method.convertArgsToSqlCommandParam(args);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (method.hasRowBounds()) {
      RowBounds rowBounds &lt;/span&gt;=&lt;span&gt; method.extractRowBounds(args);
      result &lt;/span&gt;= sqlSession.&amp;lt;E&amp;gt;&lt;span&gt;selectList(command.getName(), param, rowBounds);
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      result &lt;/span&gt;= sqlSession.&amp;lt;E&amp;gt;&lt;span&gt;selectList(command.getName(), param);
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; issue #510 Collections &amp;amp; arrays support&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;method.getReturnType().isAssignableFrom(result.getClass())) {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (method.getReturnType().isArray()) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; convertToArray(result);
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; convertToDeclaredCollection(sqlSession.getConfiguration(), result);
      }
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
  }

  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &amp;lt;T&amp;gt; Cursor&amp;lt;T&amp;gt;&lt;span&gt; executeForCursor(SqlSession sqlSession, Object[] args) {
    Cursor&lt;/span&gt;&amp;lt;T&amp;gt;&lt;span&gt; result;
    Object param &lt;/span&gt;=&lt;span&gt; method.convertArgsToSqlCommandParam(args);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (method.hasRowBounds()) {
      RowBounds rowBounds &lt;/span&gt;=&lt;span&gt; method.extractRowBounds(args);
      result &lt;/span&gt;= sqlSession.&amp;lt;T&amp;gt;&lt;span&gt;selectCursor(command.getName(), param, rowBounds);
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      result &lt;/span&gt;= sqlSession.&amp;lt;T&amp;gt;&lt;span&gt;selectCursor(command.getName(), param);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
  }

  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &amp;lt;E&amp;gt; Object convertToDeclaredCollection(Configuration config, List&amp;lt;E&amp;gt;&lt;span&gt; list) {
    Object collection &lt;/span&gt;=&lt;span&gt; config.getObjectFactory().create(method.getReturnType());
    MetaObject metaObject &lt;/span&gt;=&lt;span&gt; config.newMetaObject(collection);
    metaObject.addAll(list);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; collection;
  }

  @SuppressWarnings(&lt;/span&gt;&quot;unchecked&quot;&lt;span&gt;)
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &amp;lt;E&amp;gt; Object convertToArray(List&amp;lt;E&amp;gt;&lt;span&gt; list) {
    Class&lt;/span&gt;&amp;lt;?&amp;gt; arrayComponentType =&lt;span&gt; method.getReturnType().getComponentType();
    Object array &lt;/span&gt;=&lt;span&gt; Array.newInstance(arrayComponentType, list.size());
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (arrayComponentType.isPrimitive()) {
      &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; list.size(); i++&lt;span&gt;) {
        Array.set(array, i, list.get(i));
      }
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; array;
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; list.toArray((E[])array);
    }
  }

  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &amp;lt;K, V&amp;gt; Map&amp;lt;K, V&amp;gt;&lt;span&gt; executeForMap(SqlSession sqlSession, Object[] args) {
    Map&lt;/span&gt;&amp;lt;K, V&amp;gt;&lt;span&gt; result;
    Object param &lt;/span&gt;=&lt;span&gt; method.convertArgsToSqlCommandParam(args);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (method.hasRowBounds()) {
      RowBounds rowBounds &lt;/span&gt;=&lt;span&gt; method.extractRowBounds(args);
      result &lt;/span&gt;= sqlSession.&amp;lt;K, V&amp;gt;&lt;span&gt;selectMap(command.getName(), param, method.getMapKey(), rowBounds);
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      result &lt;/span&gt;= sqlSession.&amp;lt;K, V&amp;gt;&lt;span&gt;selectMap(command.getName(), param, method.getMapKey());
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
  }

  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ParamMap&amp;lt;V&amp;gt; &lt;span&gt;extends&lt;/span&gt; HashMap&amp;lt;String, V&amp;gt;&lt;span&gt; {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; serialVersionUID = -2212268410512043556L&lt;span&gt;;

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; V get(Object key) {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.containsKey(key)) {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BindingException(&quot;Parameter '&quot; + key + &quot;' not found. Available parameters are &quot; +&lt;span&gt; keySet());
      }
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.get(key);
    }

  }

  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SqlCommand {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; String name;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; SqlCommandType type;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; SqlCommand(Configuration configuration, Class&amp;lt;?&amp;gt;&lt;span&gt; mapperInterface, Method method) {
      &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; String methodName =&lt;span&gt; method.getName();
      &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Class&amp;lt;?&amp;gt; declaringClass =&lt;span&gt; method.getDeclaringClass();
      MappedStatement ms &lt;/span&gt;=&lt;span&gt; resolveMappedStatement(mapperInterface, methodName, declaringClass,
          configuration);
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ms == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (method.getAnnotation(Flush.&lt;span&gt;class&lt;/span&gt;) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
          name &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
          type &lt;/span&gt;=&lt;span&gt; SqlCommandType.FLUSH;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
          &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BindingException(&quot;Invalid bound statement (not found): &quot;
              + mapperInterface.getName() + &quot;.&quot; +&lt;span&gt; methodName);
        }
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        name &lt;/span&gt;=&lt;span&gt; ms.getId();
        type &lt;/span&gt;=&lt;span&gt; ms.getSqlCommandType();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (type ==&lt;span&gt; SqlCommandType.UNKNOWN) {
          &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BindingException(&quot;Unknown execution method for: &quot; +&lt;span&gt; name);
        }
      }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; SqlCommandType getType() {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; type;
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; MappedStatement resolveMappedStatement(Class&amp;lt;?&amp;gt;&lt;span&gt; mapperInterface, String methodName,
        Class&lt;/span&gt;&amp;lt;?&amp;gt;&lt;span&gt; declaringClass, Configuration configuration) {
      String statementId &lt;/span&gt;= mapperInterface.getName() + &quot;.&quot; +&lt;span&gt; methodName;
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (configuration.hasStatement(statementId)) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; configuration.getMappedStatement(statementId);
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (mapperInterface.equals(declaringClass)) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
      }
      &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Class&amp;lt;?&amp;gt;&lt;span&gt; superInterface : mapperInterface.getInterfaces()) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (declaringClass.isAssignableFrom(superInterface)) {
          MappedStatement ms &lt;/span&gt;=&lt;span&gt; resolveMappedStatement(superInterface, methodName,
              declaringClass, configuration);
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ms != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ms;
          }
        }
      }
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
  }

  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MethodSignature {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; returnsMany;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; returnsMap;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; returnsVoid;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; returnsCursor;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Class&amp;lt;?&amp;gt;&lt;span&gt; returnType;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; String mapKey;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; Integer resultHandlerIndex;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; Integer rowBoundsIndex;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; ParamNameResolver paramNameResolver;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; MethodSignature(Configuration configuration, Class&amp;lt;?&amp;gt;&lt;span&gt; mapperInterface, Method method) {
      Type resolvedReturnType &lt;/span&gt;=&lt;span&gt; TypeParameterResolver.resolveReturnType(method, mapperInterface);
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (resolvedReturnType &lt;span&gt;instanceof&lt;/span&gt; Class&amp;lt;?&amp;gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.returnType = (Class&amp;lt;?&amp;gt;&lt;span&gt;) resolvedReturnType;
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (resolvedReturnType &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; ParameterizedType) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.returnType = (Class&amp;lt;?&amp;gt;&lt;span&gt;) ((ParameterizedType) resolvedReturnType).getRawType();
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.returnType =&lt;span&gt; method.getReturnType();
      }
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.returnsVoid = &lt;span&gt;void&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;.equals(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.returnType);
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.returnsMany = configuration.getObjectFactory().isCollection(&lt;span&gt;this&lt;/span&gt;.returnType) || &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.returnType.isArray();
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.returnsCursor = Cursor.&lt;span&gt;class&lt;/span&gt;.equals(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.returnType);
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.mapKey =&lt;span&gt; getMapKey(method);
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.returnsMap = &lt;span&gt;this&lt;/span&gt;.mapKey != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.rowBoundsIndex = getUniqueParamIndex(method, RowBounds.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.resultHandlerIndex = getUniqueParamIndex(method, ResultHandler.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.paramNameResolver = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ParamNameResolver(configuration, method);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object convertArgsToSqlCommandParam(Object[] args) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; paramNameResolver.getNamedParams(args);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; hasRowBounds() {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; rowBoundsIndex != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; RowBounds extractRowBounds(Object[] args) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; hasRowBounds() ? (RowBounds) args[rowBoundsIndex] : &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; hasResultHandler() {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; resultHandlerIndex != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ResultHandler extractResultHandler(Object[] args) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; hasResultHandler() ? (ResultHandler) args[resultHandlerIndex] : &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getMapKey() {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; mapKey;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Class&amp;lt;?&amp;gt;&lt;span&gt; getReturnType() {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; returnType;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; returnsMany() {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; returnsMany;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; returnsMap() {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; returnsMap;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; returnsVoid() {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; returnsVoid;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; returnsCursor() {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; returnsCursor;
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Integer getUniqueParamIndex(Method method, Class&amp;lt;?&amp;gt;&lt;span&gt; paramType) {
      Integer index &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
      &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Class&amp;lt;?&amp;gt;[] argTypes =&lt;span&gt; method.getParameterTypes();
      &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; argTypes.length; i++&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (paramType.isAssignableFrom(argTypes[i])) {
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (index == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            index &lt;/span&gt;=&lt;span&gt; i;
          } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BindingException(method.getName() + &quot; cannot have multiple &quot; + paramType.getSimpleName() + &quot; parameters&quot;&lt;span&gt;);
          }
        }
      }
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; index;
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String getMapKey(Method method) {
      String mapKey &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Map.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.isAssignableFrom(method.getReturnType())) {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; MapKey mapKeyAnnotation = method.getAnnotation(MapKey.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mapKeyAnnotation != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
          mapKey &lt;/span&gt;=&lt;span&gt; mapKeyAnnotation.value();
        }
      }
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; mapKey;
    }
  }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

MapperMethod采用命令模式运行，根据上下文跳转，它可能跳转到许多方法中，我们不需要全部明白。我们可以看到里面的exexuteForMany方法，再看看它的实现，实际上它最后就是通过sqlSession对象去运行对象的SQL。&lt;/div&gt;


&lt;p&gt;至此，大家已经了解了MyBatis为什么只用Mapper接口便能够运行SQL，因为映射器的XML文件的命名空间对应的便是这个接口的全路径，那么它根据全路径和方法名便能够绑定起来，通过动态代理技术，让这个接口跑起来。而后采用命令模式，最后还是使用SqlSession接口的方法使得它能够执行查询，有了这层封装我们便可以使用接口编程，这样编程就更简单了。&lt;/p&gt;


&lt;p&gt;2.SqlSession下的四大对象&lt;/p&gt;
&lt;p&gt;我们已经知道了映射器其实就是一个动态代理对象，进入到了MapperMethod的execute方法。它经过简单判断就进入了SqlSession的删除、更新、插入、选择等方法，那么这些方法如何执行呢?这是我们需要关注的问题，也是正确编写插件的根本。&lt;/p&gt;

&lt;p&gt;显然通过类名和方法名字匹配到我们配置的SQL，我们不需要去关心细节，我们关心的是设计框架。Mapper执行的过程是通过Executor、StatementHandler、ParameterHandler和ResultHandler来完成数据库操作和结果返回。&lt;/p&gt;

&lt;p&gt;(1)Executor代表执行器，由它来调度StatementHandler、ParameterHandler和ResultHandle等来执行对应的SQL；&lt;/p&gt;
&lt;p&gt;(2)StatementHandler的作用是使用数据库的Statement(PreparedStatement)执行操作，它是四大对象的核心，起到承上启下的作用;&lt;/p&gt;
&lt;p&gt;(3)ParameterHandler用于SQL对参数的处理;&lt;/p&gt;
&lt;p&gt;(4)ResultHandler是进行最后数据集(ResultSet)的封装返回处理的;&lt;/p&gt;

&lt;p&gt;3.SqlSession运行总结&lt;/p&gt;
&lt;p&gt;SqlSession的运行原理十分重要，它是插件的基础，这里我们对一次查询胡总更新进行总结以加深对MyBatis内部运行的掌握。SqlSession内部运行图，如图所示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1255290/201812/1255290-20181215140125868-306621502.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; SqlSession是通过Executor构建StatementHandler来运行的，而StatementHandler要经过下面三步。&lt;/p&gt;
&lt;p&gt;(1)prepared预编译SQL；&lt;/p&gt;
&lt;p&gt;(2)parameterize设置参数；&lt;/p&gt;
&lt;p&gt;(3)query/update执行SQL；&lt;/p&gt;
&lt;p&gt;其中parameterize是调用parameterHandler的方法去设置的，而参数是根据类型处理器typeHandler去处理的。query/update方法是通过resultHandler进行处理结果的封装，如果是update的语句，它就返回整数，否则它就通过typeHandler处理结果类型，然后用ObjectFactory提供的规则组装对象，返回给调用者。这便是SqlSession执行的过程，我们清楚四大对象是如何运作的，同时也更好地理解了typeHandler和ObjectFactory在MyBatis中的应用。&lt;/p&gt;


&lt;p&gt; 小结:&lt;/p&gt;
&lt;div class=&quot;para&quot; readability=&quot;8&quot;&gt;本文主要参考了《深入浅出MyBatis技术原理与实战》，希望能够对大家有所帮助。
&lt;/div&gt;

</description>
<pubDate>Sat, 15 Dec 2018 06:10:00 +0000</pubDate>
<dc:creator>挑战者V</dc:creator>
<og:description>本次所谈的原理仅仅只涉及基本的框架和核心代码，并不会全部都说到，比如关于MyBatis是如何解析XML文件和其他配置文件从而的到内容，还有就是JDBC如何使用，关于JDBC如何使用，可以参考我的这篇博</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/youcong/p/10046806.html</dc:identifier>
</item>
<item>
<title>对后端返回的数据进行适配 - 追梦子</title>
<link>http://www.cnblogs.com/pssp/p/10123189.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pssp/p/10123189.html</guid>
<description>&lt;h2 id=&quot;为什么要做接口适配&quot;&gt;为什么要做接口适配&lt;/h2&gt;
&lt;p&gt;同一个功能，后端返回的数据结构经常变动，导致前端写的逻辑也得相应的修改，而接口适配就是为了解决此问题，不管后端接口怎么变动，前端只需要调整适配的数据部分，而不会对页面已有逻辑造成影响。&lt;/p&gt;
&lt;h2 id=&quot;请求接口的适配&quot;&gt;请求接口的适配&lt;/h2&gt;
&lt;p&gt;拿登录功能来说，有账号密码字段。&lt;/p&gt;
&lt;p&gt;请求登录（以前）&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;export const Login = data =&amp;gt; {
    return ajax.post('/sso/login', {
        username: data.username,
        password: data.password
    })
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;export const Login = data =&amp;gt; {
    return ajax.post('/sso/login', data)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;请求登录（现在）&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;export const Login = data =&amp;gt; {
    return ajax.post('/sso/login', {
        username: data.name,
        password: data.password
    })
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以前的写法和现在的写法，它们的差别在于以前获取的页面数据字段都是按照后端要求的数据结构写的，而现在的做法只是在请求登录时，对传递的数据进行调整。&lt;/p&gt;
&lt;p&gt;这样做的好处在于页面中的逻辑，数据结构可以根据自己来定义，而不会限制于后端的数据结构，另外也就不必等后端接口实现好了再写相关逻辑，因为所有的数据结构都是自己来定义的。&lt;/p&gt;
&lt;h2 id=&quot;响应数据的适配&quot;&gt;响应数据的适配&lt;/h2&gt;
&lt;p&gt;还是拿登录功能来说&lt;/p&gt;
&lt;p&gt;现在&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;export const Login = data =&amp;gt; {
    return ajax.post('/sso/login', {
        userName: data.name,
        password: data.password
    }).then(res =&amp;gt; {
        let data = res.data
        
        return {
            token: data.token,
            name: data.userName,
            sex: data.userSex,
            mobile: data.userMobile
        }
    })
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;页面中&lt;/p&gt;
&lt;pre class=&quot;vue&quot;&gt;
&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;姓名：{{user.name}}&amp;lt;/div&amp;gt;
  &amp;lt;div&amp;gt;性别：{{user.sex}}&amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
    import { Login } from '$api'
    
    export default {
        data() {
            return {
                name: '',
                sex: ''
            }
        },
        created() {
            Login({
                name: '张三',
                password: '123456'
            }).then(res =&amp;gt; {
                this.name = res.name
                this.sex = res.sex
            })
        }
    }
&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以前&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;export const Login = data =&amp;gt; {
    return ajax.post('/sso/login', {
        userName: data.userName,
        password: data.password
    })
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;页面中&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;姓名：{{user.userName}}&amp;lt;/div&amp;gt;
  &amp;lt;div&amp;gt;性别：{{user.userSex}}&amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
    import { Login } from '$api'
    
    export default {
        data() {
            return {
                userName: '',
                userSex: ''
            }
        },
        created() {
            Login({
                userName: '张三',
                password: '123456'
            }).then(res =&amp;gt; {
                this.userName = res.userName
                this.userSex = res.userSex
            })
        }
    }
&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到以前我们总是按后端返回的数据结构，原样的写在页面里面，然而一旦后端数据结构发生了变更，我们就要找到所有使用此接口的页面，并调整相应参数。&lt;/p&gt;
&lt;p&gt;现在的做法虽然看似代码变多了，但你会发现，页面中的数据结构是按照我们自己写的，所以后端的数据结构怎么改变，都不怎么需要改动页面中的参数和逻辑。&lt;/p&gt;
&lt;h2 id=&quot;结语&quot;&gt;结语&lt;/h2&gt;
&lt;p&gt;尽管接口适配可以避免重新调整页面既有逻辑，但不管如何还是需要后端提前提供接口文档的，因为最终的数据是由后端来提供的，如果期望的接口并没有返回指定数据，而这些数据需要另一个接口来获取，从而导致页面中的逻辑与现有数据不一致。&lt;/p&gt;
&lt;p&gt;也就是说，尽管我们可以对接口进行适配，但还是有必要提前了解一下后端返回的数据和所需的数据。&lt;/p&gt;
</description>
<pubDate>Sat, 15 Dec 2018 06:02:00 +0000</pubDate>
<dc:creator>追梦子</dc:creator>
<og:description>为什么要做接口适配 同一个功能，后端返回的数据结构经常变动，导致前端写的逻辑也得相应的修改，而接口适配就是为了解决此问题，不管后端接口怎么变动，前端只需要调整适配的数据部分，而不会对页面已有逻辑造成影</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pssp/p/10123189.html</dc:identifier>
</item>
<item>
<title>PHP的会话控制 - 东小东</title>
<link>http://www.cnblogs.com/dongxiaodong/p/10123103.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dongxiaodong/p/10123103.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;页面数据的作用域：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;当前页共享数据：变量、常量&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;两个页面间传递数据：get，post&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;跟踪用户的多页面数据共享（会话）：session、cookie&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;全局数据共享：文件、数据库、memcached&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;Cookie：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;数据存储在浏览器文件中&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;数据通过请求头携带信息（Cookie:）进行页面cookie数据传递&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;em&gt;&lt;strong&gt;基本使用：&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置cookie 参数（键，值，时间）
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;//时间不写或者为0，则会保存至关闭浏览器程序
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;//时间其他值为xx秒&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;setcookie&lt;/span&gt;(&quot;dong&quot;,&quot;dongxiaodong&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存一天,时间参数：当前时间戳+24小时*60分*60秒&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;setcookie&lt;/span&gt;(&quot;xiao1&quot;,&quot;wa wa wa&quot;,&lt;span&gt;time&lt;/span&gt;()+24*60*60&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;数组数据
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;//获取：echo $_COOKIE[&quot;dong&quot;][&quot;d1&quot;];
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;//数组键若留空，不可自动增长&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;setcookie&lt;/span&gt;(&quot;dong[d1]&quot;,&quot;dong11111&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;若cookie为第一次设置，则不可在当前页得到值
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;//以下为下一页内容
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;//-----------------------------
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;//打印所有&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;print_r&lt;/span&gt;(&lt;span&gt;$_COOKIE&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;$_COOKIE&lt;/span&gt;[&quot;xiao1&quot;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;$_COOKIE&lt;/span&gt;[&quot;dong&quot;][&quot;d1&quot;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除cookie
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;//当前页第一次设置不可使用，时间小于当前时间则过期无效&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;setcookie&lt;/span&gt;(&quot;dong&quot;,&quot;&quot;,&lt;span&gt;time&lt;/span&gt;()-10);
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;Session:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;数据默认保存在服务器文件中&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;&lt;em&gt;基本使用：&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;开启session
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;//将会向客户端发送一个sessionID,保存在客户端cookie中&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;session_start&lt;/span&gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到sessionID的键&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;session_name&lt;/span&gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到sessionID的值
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;//echo session_id();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;//保存数据&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;$_SESSION&lt;/span&gt;[&quot;dong&quot;]=&quot;dongxiaodong123&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;可在当前页获取数据&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;$_SESSION&lt;/span&gt;[&quot;dong&quot;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;清除某个数据&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;unset&lt;/span&gt;(&lt;span&gt;$_SESSION&lt;/span&gt;[&quot;dong&quot;&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;清除所有数据&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;$_SESSION&lt;/span&gt;=&lt;span&gt;array&lt;/span&gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;销毁session，删除服务器保存的session文件&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;session_destroy&lt;/span&gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;自动保存的sessionID
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;//以下为下一页内容
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;//---------------------------------------------
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;//得到本地保存的sessionID
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;//echo $_COOKIE[&quot;PHPSESSID&quot;];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;服务器中Session保存位置：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485202/201812/1485202-20181215132108957-1368718988.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;内容查看：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485202/201812/1485202-20181215132128872-1392173530.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;strong&gt;解决客户端浏览器禁用Cookie&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;当客户端浏览器禁用cookie后服务器在客户端对应cookie中没有保存sessionID,所以当客户端页面刷新或者跳转时会重新生成session数据，即每次都会产生不同的sessionID,所以其数据可认为不能被共享。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;解决方法是使用常量SID判断客户端的cookie是否被禁用，而自动匹配数据传递&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;起始页代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;session_start&lt;/span&gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;$_SESSION&lt;/span&gt;[&quot;dong&quot;]=&quot;dongxiaodong1233&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;页面跳转携带使用SID可动态更加客户端有没有设置禁止cookie传递参数&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;echo&lt;/span&gt; &quot;&amp;lt;a href='wan11.php?&quot;.SID.&quot;'&amp;gt;tiaotiao&amp;lt;/a&amp;gt;&quot;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第二页：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;手动设置sessionID
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;//cookie被禁用时使用get传递sessionID时使用&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;empty&lt;/span&gt;(&lt;span&gt;$_GET&lt;/span&gt;[&lt;span&gt;session_name&lt;/span&gt;&lt;span&gt;()])){
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置sessionID&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;session_id&lt;/span&gt;(&lt;span&gt;$_GET&lt;/span&gt;[&lt;span&gt;session_name&lt;/span&gt;&lt;span&gt;()]);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;session_start&lt;/span&gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取sessionID对应的数据&lt;/span&gt;
&lt;span&gt;9&lt;/span&gt; &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;$_SESSION&lt;/span&gt;[&quot;dong&quot;];
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;&lt;strong&gt;使用memcache对session进行高效缓存：&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;第一步：管理员运行cmd,打开memcache服务器&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1485202/201812/1485202-20181215132902202-539467910.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;第二步：设置保存方式为memcache&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485202/201812/1485202-20181215132915779-220574546.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;第三步：设置连接地址&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485202/201812/1485202-20181215132930022-556335447.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第四步：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; 重启web服务器，即可常规使用session即可 &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;&lt;span&gt;JSON数据的编码与解码：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;编码json：$字符串名=json_encode($数组名);&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;解码json1：$对象=json_decode($json字符串)；访问为$对象-&amp;gt;原数组下标&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;解码json2：$数组=json_decode($json字符串，true);访问为$数组[‘数组下标’]&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;&lt;span&gt;页面跳转：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;立即跳转
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;//header(&quot;Location:main.php&quot;);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;//echo '&amp;lt;script&amp;gt;location=&quot;main.php&quot;&amp;lt;/script&amp;gt;';
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;//3秒后跳转
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;//echo '&amp;lt;script&amp;gt;setTimeout(\'location=&quot;main.php&quot;\',3000)&amp;lt;/script&amp;gt;';
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;//提示后跳转&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;echo&lt;/span&gt; &quot;&amp;lt;script&amp;gt;alert('确定跳转页面');window.location.href='main.php';&amp;lt;/script&amp;gt;&quot;;
&lt;/pre&gt;&lt;/div&gt;

&lt;hr/&gt;&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
</description>
<pubDate>Sat, 15 Dec 2018 05:32:00 +0000</pubDate>
<dc:creator>东小东</dc:creator>
<og:description>页面数据的作用域： 当前页共享数据：变量、常量 两个页面间传递数据：get，post 跟踪用户的多页面数据共享（会话）：session、cookie 全局数据共享：文件、数据库、memcached C</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dongxiaodong/p/10123103.html</dc:identifier>
</item>
<item>
<title>springboot+jwt做api的token认证 - 神牛003</title>
<link>http://www.cnblogs.com/wangrudong003/p/10122706.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangrudong003/p/10122706.html</guid>
<description>&lt;p&gt;本篇和大家分享jwt(json web token)的使用，她主要用来生成接口访问的token和验证，其单独结合springboot来开发api接口token验证很是方便，由于jwt的token中存储有用户的信息并且有加密，所以适用于分布式，这样直接吧信息存储在用户本地减速了服务端存储sessiion或token的压力；如下快速使用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;!--jwt--&amp;gt;
&lt;span&gt; 2&lt;/span&gt; &amp;lt;dependency&amp;gt;
&lt;span&gt; 3&lt;/span&gt;     &amp;lt;groupId&amp;gt;io.jsonwebtoken&amp;lt;/groupId&amp;gt;
&lt;span&gt; 4&lt;/span&gt;     &amp;lt;artifactId&amp;gt;jjwt&amp;lt;/artifactId&amp;gt;
&lt;span&gt; 5&lt;/span&gt;     &amp;lt;version&amp;gt;&lt;span&gt;0.9&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;&amp;lt;/version&amp;gt;
&lt;span&gt; 6&lt;/span&gt; &amp;lt;/dependency&amp;gt;
&lt;span&gt; 7&lt;/span&gt; &amp;lt;!--阿里 FastJson依赖--&amp;gt;
&lt;span&gt; 8&lt;/span&gt; &amp;lt;dependency&amp;gt;
&lt;span&gt; 9&lt;/span&gt;     &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt;
&lt;span&gt;10&lt;/span&gt;     &amp;lt;artifactId&amp;gt;fastjson&amp;lt;/artifactId&amp;gt;
&lt;span&gt;11&lt;/span&gt;     &amp;lt;version&amp;gt;&lt;span&gt;1.2&lt;/span&gt;.&lt;span&gt;44&lt;/span&gt;&amp;lt;/version&amp;gt;
&lt;span&gt;12&lt;/span&gt; &amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一般使用jwt来达到3种结果：&lt;/p&gt;
&lt;ul&gt;&lt;li data-spm-anchor-id=&quot;a2c4e.11153940.blogcont679572.i4.279f77f9OswQ6C&quot;&gt;生成token&lt;/li&gt;
&lt;li data-spm-anchor-id=&quot;a2c4e.11153940.blogcont679572.i5.279f77f9OswQ6C&quot;&gt;验证token是否有效&lt;/li&gt;
&lt;li data-spm-anchor-id=&quot;a2c4e.11153940.blogcont679572.i6.279f77f9OswQ6C&quot;&gt;获取token中jwt信息（主要用户信息）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;引入了jjwt依赖后，要生成token很方便；对于一个token来说，代表的是唯一并且不可逆的，因此我们在生成时需要增加一些唯一数据进去，比如下面的id：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; currentTime =&lt;span&gt; System.currentTimeMillis();
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Jwts.builder()
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;        .setId(UUID.randomUUID().toString())
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         .setIssuedAt(&lt;span&gt;new&lt;/span&gt; Date(currentTime))  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;签发时间&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         .setSubject(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;system&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;说明&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         .setIssuer(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;shenniu003&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;签发者信息&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         .setAudience(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;custom&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;接收用户&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         .compressWith(CompressionCodecs.GZIP)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据压缩方式&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;         .signWith(SignatureAlgorithm.HS256, encryKey) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;加密方式&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         .setExpiration(&lt;span&gt;new&lt;/span&gt; Date(currentTime + secondTimeOut * &lt;span&gt;1000&lt;/span&gt;))  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;过期时间戳&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;         .addClaims(claimMaps) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;cla信息&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;         .compact();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过uuid来标记唯一id信息；当然在对token加密时需要用到秘钥，jwt很是方便她支持了很多中加密方式如：HS256，HS265，Md5等复杂及常用的加密方式；&lt;/p&gt;
&lt;p&gt;jwt生成的token中内容分为3个部分：head信息，payload信息，sign信息，通常我们要做的是往payload增加一些用户信息（比如：账号，昵称，权限等，但不包含密码）；在对jwt的token有一定了解后，我们来看下真实生成的token值：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; eyJhbGciOiJIUzI1NiIsInppcCI6IkdaSVAifQ.H4sIAAAAAAAAAFWMTQ7CIBSE7_LWkPDzaEsP4QnYINCIptX4INE0vbtg4sLlfPPN7HAtGWbwg1BKL4GrcbEcIwpujZF8iiEpjXFapAAG2ReYpUEcR2VxYED13Nb0ppLW3hP1eEnblqsQuiFfY0OhUrl3I70evweU_aFSejZhd7DlcDv5NTmYHUilHTD3rf_hAccHRTv--7YAAAA.i4xwoQtaWI0-dwHWN8uZ4DBm-vfli5bavYU9lRYxU5E
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;token生成的时都会伴随者有一个失效的时间，在这我们可以通过setExpiration函数设置过期时间，记住jwt的有效时间不是滑动的，也就是说不做任何处理时，当到达第一次设置的失效时间时，就基本没用了，要获取token是否过期可以使用如下方式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; boolean isExpiration(String token, String encryKey) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; getClaimsBody(token, encryKey)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;                .getExpiration()
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;                 .before(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date());
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ExpiredJwtException ex) {
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里使用了date的before来用获取的过期时间和当前时间对比，判断是否继续有效，需要注意的是如果在token失效后再通过getClaimsBody(token, encryKey)获取信息，此时会报ExpiredJwtException错误，我们即可认为过期。&lt;/p&gt;

&lt;p&gt;通常我们要把登录用户信息存储在jwt生成的token中，这里可以通过 &lt;span class=&quot;cnblogs_code&quot;&gt;addClaims(claimMaps)&lt;/span&gt; 传递map来设置信息，反过来要获取token中的用户信息，我们需要这样做：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Jwts.parser()
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;        .setSigningKey(encryKey)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;        .parseClaimsJws(token)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         .getBody();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时body获取出来是Claims类型，我们需要从中获取到用户信息，需要注意的是在addClaims存储信息的时候如果存储的map值没做过出来，那完整的实体对象存储进去后会映射成一个LinkHasMap类型，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://yqfile.alicdn.com/992ec36d6483937d18e1fe623981a9f50f455dcd.png&quot; alt=&quot;&quot; width=&quot;518&quot; height=&quot;200&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因此通常会在存储的时候json化，如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; claimMaps.forEach((key, val) -&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    claimMaps.put(key, JSON.toJSONString(val));
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再来就是通过get方法获取我们存储进去的信息，并json反序列化：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;* 获取body某个值
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;*
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;* @param token
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;* @param encryKey
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;* @param key
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;* @return
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Object getVal(String token, String encryKey, String key) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; getJws(token, encryKey).getBody().&lt;span&gt;get&lt;/span&gt;&lt;span&gt;(key);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt; * 获取body某个值，json字符转实体
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt; *
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt; * @param token
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt; * @param encryKey
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt; * @param key
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt; * @param tClass
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt; * @param &amp;lt;T&amp;gt;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt; * @return
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; T getValByT(String token, String encryKey, String key, Class&amp;lt;T&amp;gt;&lt;span&gt; tClass) {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         String strJson =&lt;span&gt; getVal(token, encryKey, key).toString();
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; JSON.parseObject(strJson, tClass);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex) {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;来到这里一个Jwt的Util代码基本就完成了，下面给出完整的代码例子，仅供参考：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('fb150d1b-99ea-4c7f-8f3c-72f119f13fcf')&quot; readability=&quot;49&quot;&gt;&lt;img id=&quot;code_img_closed_fb150d1b-99ea-4c7f-8f3c-72f119f13fcf&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_fb150d1b-99ea-4c7f-8f3c-72f119f13fcf&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('fb150d1b-99ea-4c7f-8f3c-72f119f13fcf',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_fb150d1b-99ea-4c7f-8f3c-72f119f13fcf&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;93&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; JwtUtil {
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; 
&lt;span&gt;  3&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;     * 获取token - json化 map信息
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; &lt;span&gt;     * @param claimMaps
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;     * @param encryKey
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; &lt;span&gt;     * @param secondTimeOut
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;     * @return
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 11&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String getTokenByJson(Map&amp;lt;String, Object&amp;gt; claimMaps, String encryKey, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; secondTimeOut) {
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; getToken(claimMaps, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;, encryKey, secondTimeOut);
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt; 
&lt;span&gt; 15&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt; &lt;span&gt;     * 获取token
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt; &lt;span&gt;     * @param claimMaps
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt; &lt;span&gt;     * @param isJsonMpas
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; &lt;span&gt;     * @param encryKey
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt; &lt;span&gt;     * @param secondTimeOut
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt; &lt;span&gt;     * @return
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 24&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String getToken(Map&amp;lt;String, Object&amp;gt; claimMaps, boolean isJsonMpas, String encryKey, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; secondTimeOut) {
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt; 
&lt;span&gt; 26&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isJsonMpas) {
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt;             claimMaps.forEach((key, val) -&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt; &lt;span&gt;                claimMaps.put(key, JSON.toJSONString(val));
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt;         &lt;span&gt;long&lt;/span&gt; currentTime =&lt;span&gt; System.currentTimeMillis();
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Jwts.builder()
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt; &lt;span&gt;                .setId(UUID.randomUUID().toString())
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;                 .setIssuedAt(&lt;span&gt;new&lt;/span&gt; Date(currentTime))  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;签发时间&lt;/span&gt;
&lt;span&gt; 35&lt;/span&gt;                 .setSubject(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;system&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;说明&lt;/span&gt;
&lt;span&gt; 36&lt;/span&gt;                 .setIssuer(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;shenniu003&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;签发者信息&lt;/span&gt;
&lt;span&gt; 37&lt;/span&gt;                 .setAudience(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;custom&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;接收用户&lt;/span&gt;
&lt;span&gt; 38&lt;/span&gt;                 .compressWith(CompressionCodecs.GZIP)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据压缩方式&lt;/span&gt;
&lt;span&gt; 39&lt;/span&gt; 
&lt;span&gt; 40&lt;/span&gt;                 .signWith(SignatureAlgorithm.HS256, encryKey) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;加密方式&lt;/span&gt;
&lt;span&gt; 41&lt;/span&gt;                 .setExpiration(&lt;span&gt;new&lt;/span&gt; Date(currentTime + secondTimeOut * &lt;span&gt;1000&lt;/span&gt;))  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;过期时间戳&lt;/span&gt;
&lt;span&gt; 42&lt;/span&gt;                 .addClaims(claimMaps) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;cla信息&lt;/span&gt;
&lt;span&gt; 43&lt;/span&gt; &lt;span&gt;                .compact();
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt; 
&lt;span&gt; 46&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt; &lt;span&gt;     * 获取token中的claims信息
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt; &lt;span&gt;     * @param token
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt; &lt;span&gt;     * @param encryKey
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt; &lt;span&gt;     * @return
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 53&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Jws&amp;lt;Claims&amp;gt;&lt;span&gt; getJws(String token, String encryKey) {
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Jwts.parser()
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt; &lt;span&gt;                .setSigningKey(encryKey)
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt; &lt;span&gt;                .parseClaimsJws(token);
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt; 
&lt;span&gt; 59&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; String getSignature(String token, String encryKey) {
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; getJws(token, encryKey).getSignature();
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex) {
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; 
&lt;span&gt; 67&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt; &lt;span&gt;     * 获取token中head信息
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt; &lt;span&gt;     * @param token
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt; &lt;span&gt;     * @param encryKey
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt; &lt;span&gt;     * @return
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 74&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; JwsHeader getHeader(String token, String encryKey) {
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; getJws(token, encryKey).getHeader();
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex) {
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt; 
&lt;span&gt; 82&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt; &lt;span&gt;     * 获取payload body信息
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt; &lt;span&gt;     * @param token
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt; &lt;span&gt;     * @param encryKey
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt; &lt;span&gt;     * @return
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 89&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Claims getClaimsBody(String token, String encryKey) {
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; getJws(token, encryKey).getBody();
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt; 
&lt;span&gt; 93&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt; &lt;span&gt;     * 获取body某个值
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt; &lt;span&gt;     * @param token
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt; &lt;span&gt;     * @param encryKey
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt; &lt;span&gt;     * @param key
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt; &lt;span&gt;     * @return
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;101&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Object getVal(String token, String encryKey, String key) {
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; getJws(token, encryKey).getBody().&lt;span&gt;get&lt;/span&gt;&lt;span&gt;(key);
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt; 
&lt;span&gt;105&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt; &lt;span&gt;     * 获取body某个值，json字符转实体
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt; &lt;span&gt;     * @param token
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt; &lt;span&gt;     * @param encryKey
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt; &lt;span&gt;     * @param key
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt; &lt;span&gt;     * @param tClass
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt; &lt;span&gt;     * @param &amp;lt;T&amp;gt;
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt; &lt;span&gt;     * @return
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;115&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; T getValByT(String token, String encryKey, String key, Class&amp;lt;T&amp;gt;&lt;span&gt; tClass) {
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt;             String strJson =&lt;span&gt; getVal(token, encryKey, key).toString();
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; JSON.parseObject(strJson, tClass);
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex) {
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt; 
&lt;span&gt;124&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt; &lt;span&gt;     * 是否过期
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt; &lt;span&gt;     * @param token
&lt;/span&gt;&lt;span&gt;128&lt;/span&gt; &lt;span&gt;     * @param encryKey
&lt;/span&gt;&lt;span&gt;129&lt;/span&gt; &lt;span&gt;     * @return
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;131&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; boolean isExpiration(String token, String encryKey) {
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; getClaimsBody(token, encryKey)
&lt;/span&gt;&lt;span&gt;134&lt;/span&gt; &lt;span&gt;                    .getExpiration()
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt;                     .before(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date());
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ExpiredJwtException ex) {
&lt;/span&gt;&lt;span&gt;137&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;138&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;139&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;140&lt;/span&gt; 
&lt;span&gt;141&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; String getSubject(String token, String encryKey) {
&lt;/span&gt;&lt;span&gt;142&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;143&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; getClaimsBody(token, encryKey).getSubject();
&lt;/span&gt;&lt;span&gt;144&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex) {
&lt;/span&gt;&lt;span&gt;145&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;146&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;147&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;148&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;有了基本的JwtUtil工具，我们需要用到springboot项目中，一般来说对于登录授权token验证可以通过过滤器来操作，这里创建一个AuthenFilter，用于对post请求过来的token做验证：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AuthenFilter implements Filter {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;         HttpServletRequest rq =&lt;span&gt; (HttpServletRequest) servletRequest;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         HttpServletResponse rp =&lt;span&gt; (HttpServletResponse) servletResponse;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         RpBase rpBase = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RpBase();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;只接受post&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!rq.getMethod().equalsIgnoreCase(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;post&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;                filterChain.doFilter(servletRequest, servletResponse);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;             String token = rq.getHeader(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;token&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (StringUtils.isEmpty(token)) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                 rpBase.setMsg(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;无token&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;jwt验证&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;             MoUser moUser = JwtUtil.getValByT(token, WebConfig.Token_EncryKey, WebConfig.Login_User, MoUser.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (moUser == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                 rpBase.setMsg(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;token已失效&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;             System.&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;token用户：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; moUser.getNickName());
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;            filterChain.doFilter(servletRequest, servletResponse);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex) {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;StringUtils.isEmpty(rpBase.getMsg())) {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;                 rp.setCharacterEncoding(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;                rpBase.setCode(HttpStatus.BAD_REQUEST.value());
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;                rp.getWriter().write(JSON.toJSONString(rpBase));
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;要是自定义过滤器AuthenFilter生效，还需要把她注册到容器中，这里通过编码方式，当然还可以通过@WebFilter注解来加入到容器中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Configuration
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WebFilterConfig {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; FilterRegistrationBean setFilter() {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;         FilterRegistrationBean registrationBean = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FilterRegistrationBean();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         registrationBean.setFilter(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; AuthenFilter());
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         registrationBean.addUrlPatterns(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/api/*&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        registrationBean.setOrder(FilterRegistrationBean.LOWEST_PRECEDENCE);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; registrationBean;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意addUrlPatterns匹配的是过滤器作用的url连接，根据需求而定；为了验证效果，这里我创建了两个接口getToken和t0，分别是获取token和post查询接口，代码如是：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@RestController
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestController {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;     @PostMapping(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/api/t0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String t0() throws MyException {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; UUID.randomUUID().toString();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     @GetMapping(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/token/{userName}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getToken(@PathVariable String userName) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;         MoUser moUser = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MoUser();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        moUser.setUserName(userName);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        moUser.setNickName(userName);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;         Map&amp;lt;String, Object&amp;gt; map = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        map.put(WebConfig.Login_User, moUser);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; JwtUtil.getTokenByJson(map,
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;                WebConfig.Token_EncryKey,
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;                WebConfig.Token_SecondTimeOut);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最终要获通过head传递token值来访问t01接口，得到如下结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://yqfile.alicdn.com/a56ebc67751acfafa35455c491cda1aeddcb4c25.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;token在有效时间后访问直接失败，从新获取token并访问t01接口，得到成功的信息：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://yqfile.alicdn.com/8fa1bc12f6b69fa35612f835ec7d305fa2e45f5b.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 15 Dec 2018 05:05:00 +0000</pubDate>
<dc:creator>神牛003</dc:creator>
<og:description>本篇和大家分享jwt(json web token)的使用，她主要用来生成接口访问的token和验证，其单独结合springboot来开发api接口token验证很是方便，由于jwt的token中存储</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wangrudong003/p/10122706.html</dc:identifier>
</item>
</channel>
</rss>