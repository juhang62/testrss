<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>ios下，微信小程序scrollview组件中的fixed元素抖得和帕金森病人一样 - 韩子卢</title>
<link>http://www.cnblogs.com/vvjiang/p/11265206.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/vvjiang/p/11265206.html</guid>
<description>&lt;h2 id=&quot;问题现象&quot;&gt;问题现象&lt;/h2&gt;
&lt;p&gt;这个问题是最近在优化小程序代码时发现的。&lt;/p&gt;
&lt;p&gt;在ios环境下，微信小程序的scrollview组件包裹着一个position：fixed的view。&lt;/p&gt;
&lt;p&gt;当在scrollview组件上滑动时，这个view会疯狂抖动。&lt;/p&gt;
&lt;p&gt;直接上图吧：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/746209/201907/746209-20190729151321558-2033002447.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面是简化后的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;view class=&quot;main&quot;&amp;gt;
  &amp;lt;scroll-view scroll-y=&quot;{{true}}&quot; bindscroll=&quot;handleScroll&quot; style=&quot;height:100%;&quot; &amp;gt;
    &amp;lt;view&amp;gt;
        &amp;lt;view class=&quot;weui-navbar navbar-fixed&quot;&amp;gt;
          我是头部fixed元素
        &amp;lt;/view&amp;gt;
        &amp;lt;view&amp;gt;
          这里是一大段test文字，用于占位
        &amp;lt;/view&amp;gt;
    &amp;lt;/view&amp;gt;
  &amp;lt;/scroll-view&amp;gt;
&amp;lt;/view&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;猜测与验证&quot;&gt;猜测与验证&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;原生组件？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个现象在没有简化代码前，我以为我是哪里用了什么原生组件。&lt;/p&gt;
&lt;p&gt;因为原生组件在ios下的定位缓慢，导致了这个问题的出现。&lt;/p&gt;
&lt;p&gt;但是当我的代码简化到上面这一步的时候，发现并没有应用原生组件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ios下橡皮筋功能的影响？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;问题在于我去掉了scroll-view后，滚动得不错，这个头部fixed的元素并没有抖动。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;确定是scroll-view组件下fixed元素随着滑动就会抖动&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;到这一步我就确定了问题的原因，所以当然我是要先百度一下答案的。&lt;/p&gt;
&lt;p&gt;于是我果然发现了一堆难兄难弟：&lt;a href=&quot;https://developers.weixin.qq.com/community/develop/doc/00040655bf00981e85b71f3f256400?_at=1559134533150&quot;&gt;ios下scroll-view中fixed元素无法固定&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;貌似他们遇到的问题比我还严重啊，都像一条咸鱼一样跟着滚了，而我的只是得了帕金森。&lt;/p&gt;
&lt;h2 id=&quot;简单场景解决方案&quot;&gt;简单场景解决方案&lt;/h2&gt;
&lt;p&gt;上面的问题还没有官方人员回答。&lt;/p&gt;
&lt;p&gt;不过最好的解决方案其实就是将fixed元素移出scroll-view，这个没什么好多说的。&lt;/p&gt;
&lt;p&gt;元素都fixed了，没道理还要放在scroll-view中是吧？&lt;/p&gt;
&lt;h2 id=&quot;复杂场景解决方案&quot;&gt;复杂场景解决方案&lt;/h2&gt;
&lt;p&gt;既然说了上面是简单场景，那么就肯定有复杂场景嘛。&lt;/p&gt;
&lt;p&gt;我元素都fixed了，确实是没道理要放在一个scroll-view元素中包裹着。&lt;/p&gt;
&lt;p&gt;但是有的事就是这么没道理啊。&lt;/p&gt;
&lt;p&gt;就比如我的微信小程序肯定没有示例这么简单，里面这个fixed元素不能移出去。&lt;/p&gt;
&lt;p&gt;因为这个元素的fixed状态并不是固定的，最开始他需要跟随页面一起滚动，当和顶部贴紧后，它就变成fixed了。&lt;/p&gt;
&lt;p&gt;废话少说，现在就说一下我的解决方案的思路：&lt;/p&gt;
&lt;p&gt;既然要随着页面一起滚动，那么肯定是要保证这个元素在scroll-view中的。&lt;/p&gt;
&lt;p&gt;而scroll-view中的fixed元素肯定会抖，所以这个元素又一定要放在scroll-view外。&lt;/p&gt;
&lt;p&gt;看似鱼与熊掌不可兼得，实际上我们搞两个人一人取鱼，一人取熊掌就好了嘛。&lt;/p&gt;
&lt;p&gt;我们可以在scroll-view外设置一个同样的元素，并将其设置为fixed，并且隐藏。&lt;/p&gt;
&lt;p&gt;当scroll-view内部的元素贴紧顶部后，将内部的元素隐藏，再显示外部的元素即可。&lt;/p&gt;
&lt;p&gt;以下是实现代码：&lt;/p&gt;
&lt;p&gt;index.wxml:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;view class=&quot;main&quot;&amp;gt;
  &amp;lt;view class=&quot;navbar navbar-fixed&quot; hidden=&quot;{{scrollTop&amp;lt;=initTop}}&quot;&amp;gt;
    我是头部fixed元素
  &amp;lt;/view&amp;gt;
  &amp;lt;scroll-view scroll-y=&quot;{{true}}&quot; bindscroll=&quot;handleScroll&quot; style=&quot;height:100%;&quot; &amp;gt;
    &amp;lt;view&amp;gt;
        &amp;lt;view&amp;gt;
          这里是一大段test文字，用于占位
        &amp;lt;/view&amp;gt;
        &amp;lt;view id=&quot;navbar&quot; class=&quot;weui-navbar navbar-fixed&quot; hidden=&quot;{{scrollTop&amp;gt;initTop}}&quot;&amp;gt;
          我是头部fixed元素
        &amp;lt;/view&amp;gt;
        &amp;lt;view&amp;gt;
          这里是一大段test文字，用于占位
        &amp;lt;/view&amp;gt;
    &amp;lt;/view&amp;gt;
  &amp;lt;/scroll-view&amp;gt;
&amp;lt;/view&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;index.js:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Page({
  data: {
    initTop: 0,
    scrollTop: 0,
  },
  onLoad: function (options) {
    let query = wx.createSelectorQuery()
    query.select('#navbar').boundingClientRect()
    query.exec((res) =&amp;gt; {
      this.setData({
        initTop: res[0].top
      })
    })
  },
  handleScroll: function (e) {
    this.setData({ scrollTop: e.detail.scrollTop })
  }
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;index.wxss:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;.navbar-fixed {
  position:fixed;
  width:100%;
  top:0;
  left:0;
  z-index:100;
}
.navbar{
  height:80rpx;
  line-height: 80rpx;
  background:red;
  text-align: center;
  color: #fff;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;隐藏bug与修复&quot;&gt;隐藏BUG与修复&lt;/h2&gt;
&lt;p&gt;以上代码如果快速滑动是没有问题，但是当红色头部元素快要贴紧顶部时慢速滑动就会出现一个很诡异的现象：&lt;/p&gt;
&lt;p&gt;红色头部元素往下弹动，始终不能贴紧顶部。&lt;/p&gt;
&lt;p&gt;而实际上不是红色头部元素往下弹动，而是红色头部元素贴紧顶部后，此时内部头部元素隐藏，那么scrollTop立刻变小。&lt;/p&gt;
&lt;p&gt;因为scrollTop变小，小于了initTop，那么内部头部元素再次出现，于是就这样不断循环。&lt;/p&gt;
&lt;p&gt;我们这里需要明白hidden实际上是一个display：none的效果，所以这里我们对内部元素的隐藏不能用hidden，而是用visibility：hidden。&lt;/p&gt;
&lt;p&gt;这样的话，这个内部元素就只是看不见了而已，并且页面上显示为背景色（这里我们假设是白色），但是还是占用了那么多的空间。&lt;/p&gt;
&lt;p&gt;那么scrollTop就不会突然间变小，也就不会造成BUG。&lt;/p&gt;
&lt;p&gt;同时，外部的元素会在内部元素变成白色矩形时直接出现，覆盖在内部元素上面，那么内部元素隐藏所造成的白色区域实际上就被外部元素遮挡住了。&lt;/p&gt;
&lt;p&gt;当用户在使用时，完全不会感知到内部元素这个白色区域的存在。&lt;/p&gt;
&lt;p&gt;好了，这里我们给出修改后的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;view class=&quot;main&quot;&amp;gt;
  &amp;lt;view class=&quot;navbar navbar-fixed&quot; hidden=&quot;{{scrollTop&amp;lt;=initTop}}&quot;&amp;gt;
    我是头部fixed元素
  &amp;lt;/view&amp;gt;
  &amp;lt;scroll-view scroll-y=&quot;{{true}}&quot; bindscroll=&quot;handleScroll&quot; style=&quot;height:100%;&quot; &amp;gt;
    &amp;lt;view&amp;gt;
        &amp;lt;view&amp;gt;
          这里是一大段test文字，用于占位
        &amp;lt;/view&amp;gt;
        &amp;lt;view id=&quot;navbar&quot; class=&quot;weui-navbar navbar-fixed&quot; style=&quot;visibility:{{scrollTop&amp;gt;initTop?'hidden':'initial'}}&quot;&amp;gt;
          我是头部fixed元素
        &amp;lt;/view&amp;gt;
        &amp;lt;view&amp;gt;
          这里是一大段test文字，用于占位
        &amp;lt;/view&amp;gt;
    &amp;lt;/view&amp;gt;
  &amp;lt;/scroll-view&amp;gt;
&amp;lt;/view&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;方法蠢是蠢了点，但是好用啊。&lt;/p&gt;
&lt;p&gt;而且万一哪天微信小程序修复了这个问题，咱们的方案不会出问题，替换起来也很简单。&lt;/p&gt;
</description>
<pubDate>Tue, 30 Jul 2019 00:39:00 +0000</pubDate>
<dc:creator>韩子卢</dc:creator>
<og:description>问题现象 这个问题是最近在优化小程序代码时发现的。 在ios环境下，微信小程序的scrollview组件包裹着一个position：fixed的view。 当在scrollview组件上滑动时，这个v</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/vvjiang/p/11265206.html</dc:identifier>
</item>
<item>
<title>从一次线下读书会获得的收获 - 溪源More</title>
<link>http://www.cnblogs.com/xiyuanMore/p/11267830.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiyuanMore/p/11267830.html</guid>
<description>&lt;blockquote class=&quot;ql-long-20597952&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span class=&quot;ql-author-20597952&quot;&gt;——请问大家最近读书了吗？一年大概读了多少本书。 有超过20本，超过30本，超过50本吗？&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-20597952&quot;&gt;&lt;span class=&quot;ql-author-20597952&quot;&gt;在7月14日由长沙互联网活动基地和长沙.NET技术社区组织的小型社区活动，《开发者爱读书•线下读书会》上，长沙.NET技术社区的专家、资深Java开发者、架构师郭德强问了大家这样一系列问题。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-20597952&quot;&gt;&lt;span class=&quot;ql-author-20597952&quot;&gt;读书会其实对我们技术社区来说，是一种比较独特的形式，作为一个以“不搭讪，不闲聊，不吹水，只讨论技术”为口号的线上社区，在长沙这样的城市，本身就有点“奇葩”，因为愿意静下心来学习新技术、读书的开发者，或许并没有那么多，更何况是读书会这种奇怪的形式。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-20597952&quot;&gt;&lt;span class=&quot;ql-author-20597952&quot;&gt;所以活动通知发出去之后，报名人数并不多，计划20人，实际上只报名了12人，但是出席率看起来还不错，来了十一位，接近百分之百。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-20597952&quot;&gt;&lt;span class=&quot;ql-author-20597952&quot;&gt;事实上，读书在现代人的生活节奏中，也越来越成为最奇怪的一种学习方式，尤其是对于享受996福报的开发者来说，更是如此。沉迷于工作不可自拔的开发者们，下班回家之后已经十点了，大概很少有时间读书，而且碎片时间也被各类app充分发掘，是头条系应用们的业务增长点，所以能在炎炎夏日之下，这么多开发者来到现场，实属一股清流。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-20597952&quot;&gt;&lt;span class=&quot;ql-author-20597952&quot;&gt;回到那个问题，显然不太可能真的读过这么多书的人，大家普遍回答说一年大概一两本，基本上也很难能够读这么多的书。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote class=&quot;ql-long-20597952&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span class=&quot;ql-author-20597952&quot;&gt;---德强哥说他一年大概能读三十到五十本，这是一个非常厉害的成绩，溪源认为今年看了不少书，也才7本书，他为什么能读下这么多书？&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-20597952&quot;&gt;&lt;span class=&quot;ql-author-20597952&quot;&gt;德强哥分享了他的经验，他说读书本身就需要一些方法，并非每一本书都值得精读，他推荐了一本书《如何阅读一本书》，他说读书首先应该从阅读序开始，体会作者写书的背景和心境，然后在根据目录再按章节先略读一遍，有的书，看一遍就会体会到这些书中有价值的点，然后再结合这些点，逐步的开展剧情。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-20597952&quot;&gt;&lt;span class=&quot;ql-author-20597952&quot;&gt;德强哥说，作为程序员往往习惯于看技术书，例如教大家怎么用工具的书和某些语言的技能书，但是有时候也应该看一些非技术的书，例如思考人性的书，心理学的书，倒也不是说一切程序皆玄学，而是因为在软件开发的过程中，实际上依然是人与人之间沟通的过程，而每个人说的话，做的事，实际上都有其动机和想法，思考对方的想法，更有利于开发者们对功能的实现。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-20597952&quot;&gt;&lt;span class=&quot;ql-author-20597952&quot;&gt;如果始终站在自我为中心的角度，思考在某些场景下，数据驱动行为，本身就容易陷入误区。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote class=&quot;ql-long-20597952&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span class=&quot;ql-author-20597952&quot;&gt;既然数据驱动设计有毛病，那采用测试驱动设计？还是领域驱动设计？还是行为驱动设计？&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-20597952&quot;&gt;&lt;span class=&quot;ql-author-20597952&quot;&gt;德强哥说，其实是人性驱动设计。在看似风口迭起的IT行业，似乎大家的身边有许多程序员，但实际上真正全世界范围来看，依然只有两千万程序员，从中国范围来看，也就两三百万程序员，所以看似原本跟计算机打交道的枯燥无味的软件开发，依然是人类群体活动的一个环节。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-20597952&quot;&gt;&lt;span class=&quot;ql-author-20597952&quot;&gt;所以程序员不是孤立存在的现代行业，阅读一些社会心理学的书，更有利于发掘需求的意义。尤其是面向特定的行业人群，更需要站在行业人群的教育背景、人际交往、爱好等领域去思考，这更需要我们阅读更多的书，即便是许多产品，其实是抄袭竞品出来的，同样也需要了解行业背景做出独特的特色，才能在市场上立于不败之地。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-20597952&quot;&gt;&lt;span class=&quot;ql-author-20597952&quot;&gt;学习软件架构，有时候阅读一些建筑学的书，反而能产生不错的触动效果，“他山之石可以攻玉”，建筑业其实和软件行业具有更多的共同性，有很多重要的架构思想，其实也是从建筑架构体系中发散出来的。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-20597952&quot;&gt;&lt;span class=&quot;ql-author-20597952&quot;&gt;阅读管理学的书，则让我们能够具有同理心，想想老板是如何将问题分下来的，或许有利于我们更好的解决问题。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-20597952&quot;&gt;&lt;span class=&quot;ql-author-20597952&quot;&gt;如果要学习Redis这个工具的用法，单纯只看Redis的书，难免会有点片面，但是如果你把其他类似的NoSql相关的技术体系，都看一遍，那反而能更加深入的了解redis这种技术的独特之处了，而且还会产生附加效应，例如哪天有一个别的Nosql技术火起来了，至少知识体系是一同百通的。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-20597952&quot;&gt;&lt;span class=&quot;ql-author-20597952&quot;&gt;在过程中还聊到了其他内容，一些看似无关的概念，如彼得原理。彼得原理是西方管理学的一个重要理论，他说的是，在各种组织中，由于习惯于对在某个等级上称职的人员进行晋升提拔，因而雇员总是趋向于被晋升到其不称职的地位。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-20597952&quot;&gt;&lt;span class=&quot;ql-author-20597952&quot;&gt;彼得原理有时也被称为“向上爬”理论，这种现象在现实生活中无处不在。例如每个开发者的职场生涯，总有一个阶段感觉进步很快，但很快就到了瓶颈期，所以需要晋升到更高级的岗位，或改变自己的学习方法，让自己的技能进一步提升。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-20597952&quot;&gt;&lt;span class=&quot;ql-author-20597952&quot;&gt;其实企业发展同样受这个理论的掌控，如果一家组织如果发展得很快，那么到了一个阶段，例如两百人的规模，就容易陷入内卷化，需要引入新的管理方法才或许能再进一步。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote class=&quot;ql-long-20597952&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span class=&quot;ql-author-20597952&quot;&gt;到场的996的开发者们说上班太忙了，有时候想学一些新知识，都没有足够的时间，或者就算挤出了时间，也感觉学不进什么，除了遗忘曲线本身外，还有其他原因么？&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-20597952&quot;&gt;&lt;span class=&quot;ql-author-20597952&quot;&gt;溪源说大概是因为有输入没输出造成的，例如，最常见的一种输出，就是做项目，通过做项目能够快速的沉淀我们的技能，让我们快速成长，这也是我们在参加工作的前三年感觉技能突飞猛进的一个原因。但是随着我们的技能逐渐成长，原来做项目的模式带来的成长效果其实也越来越差。其主要原因是项目中使用的技术虽然很多，为了解决眼前问题，我们往往更倾向于越快越好，这就让我们可能掌握了许多技术，但是都不精通。所以随着经验的增长，需要一些其他的方式来进一步沉淀我们的技能。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote class=&quot;ql-long-20597952&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span class=&quot;ql-author-20597952&quot;&gt;写博客其实是一种方式，写书也是一种方式。 还有一种方式是做技术分享。优秀开发者都善于用输出倒逼输入。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-20597952&quot;&gt;&lt;span class=&quot;ql-author-20597952&quot;&gt;周尹老师说，优秀开发者都善于用输出倒逼输入。哪怕你是一个自律的人，有时候也难免会陷入自以为是的怪圈，这时候，通过外力来逼迫，促使你沉下心来认真的学习，反而能让输入产生更好的效果。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-20597952&quot;&gt;&lt;span class=&quot;ql-author-20597952&quot;&gt;溪源深有同感。曾经跟咕泡学院创始人、校长蒋孟枝蒋总有过交流，他曾在大众点评担任高级架构师。他说他最大的爱好不仅仅是解决问题带来的快乐，而是把自己的知识分享出去，让更多人了解这些知识，这让他得以获得更大的满足，也促使他学习更多的新技术，同时也让他认识了许多朋友，这也是他得以成功创立咕泡学院的一个很重要的因素。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-20597952&quot;&gt;&lt;span class=&quot;ql-author-20597952&quot;&gt;现场还有人提出了一个问题：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote class=&quot;ql-long-20597952&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span class=&quot;ql-author-20597952&quot;&gt;不要妄想用技术改变世界，技术是没什么用的，因为我们学的技术都在被新技术取代。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-20597952&quot;&gt;&lt;span class=&quot;ql-author-20597952&quot;&gt;必须承认，在长沙的软件公司，似乎大部分技术体系都没有那么先进，许多.NET企业，其实还是在用三层架构。但是这也只是公司当前的形态而已，大部分的IT公司都对新技术有兴趣，只是限于当前的业务发展状况，寻求稳定的技术是必然选择。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-20597952&quot;&gt;&lt;span class=&quot;ql-author-20597952&quot;&gt;学习新技术也正是开发者们立足于世界的根本之一，只有不断的学习新技术，我们的技术体系才不至于落后。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-20597952&quot;&gt;&lt;span class=&quot;ql-author-20597952&quot;&gt;虽然真正改变世界的企业，其实只有那么几家，但头部玩家所引领的时代潮流，已经逐步改变了我们的生活。一切知识往往都是有用的，要么是真的没有用起来，要么是我们还不够熟练。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-20597952&quot;&gt;&lt;span class=&quot;ql-author-20597952&quot;&gt;这是我们第一次组织读书会这种形式，从2点半开始，到5点20结束，持续了将近3个小时的时间，实际上交流的点非常多，当然还有更多思想碰撞，例如：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote class=&quot;ql-long-20597952&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span class=&quot;ql-author-20597952&quot;&gt;为什么项目老是延迟？&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote class=&quot;ql-long-20597952&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span class=&quot;ql-author-20597952&quot;&gt;为什么长沙的那些老项目管理者，找工作总是很不如意？&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote class=&quot;ql-long-20597952&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span class=&quot;ql-author-20597952&quot;&gt;为什么需求总是做不完？&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote class=&quot;ql-long-20597952&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span class=&quot;ql-author-20597952&quot;&gt;外包项目值不值得做？&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote class=&quot;ql-long-20597952&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span class=&quot;ql-author-20597952&quot;&gt;看了那么多书，怎么用？有用吗？&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-20597952&quot;&gt;&lt;span class=&quot;ql-author-20597952&quot;&gt;限于时间缘故，溪源只能记录五点，请大家见谅（典型的捡了芝麻，丢了西瓜）。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-align-center ql-text-indent-1 ql-long-20597952&quot; align=&quot;center&quot;&gt;&lt;span class=&quot;ql-author-20597952&quot;&gt;&lt;img src=&quot;https://uploader.shimo.im/f/JN9ZelFMYj4ZBAmJ.png!thumbnail&quot; alt=&quot;&quot; width=&quot;1440&quot; height=&quot;auto&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-20597952&quot;&gt;&lt;span class=&quot;ql-author-20597952&quot;&gt;通过这种方式，大家可以从线上走下线下，进一步打开自己的圈子，也能跟其他开发者一起交流、效果还是非常不错的，尤其是目前大家主要学习形式依然是借助于自学或公司的安排，并非每家公司都有比较不错的分享氛围。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-20597952&quot;&gt;&lt;span class=&quot;ql-author-20597952&quot;&gt;这样的读书会，能够面对面的与比我们年长的开发者、架构师们交流，更有利于年轻开发者们对于方向的把握，所以长沙.NET技术社区计划把这种形式固定下去（每月一次），欢迎大家持续关注。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 30 Jul 2019 00:36:00 +0000</pubDate>
<dc:creator>溪源More</dc:creator>
<og:description>读了多少书？怎么读书？ 读了多少书？怎么读书？ ——请问大家最近读书了吗？一年大概读了多少本书。 有超过20本，超过30本，超过50本吗？ 在7月14日由长沙互联网活动基地和长沙.NET技术社区组织的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiyuanMore/p/11267830.html</dc:identifier>
</item>
<item>
<title>Vue事件修饰符详解 - Jacob98</title>
<link>http://www.cnblogs.com/Jacob98/p/11267399.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Jacob98/p/11267399.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;整体学习Vue时看到Vue文档中有事件修饰符的描述，但是看了之后并没有理解是什么意思，于是查阅了资料，现在记录下来与大家分享&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;先给大家画一个示意图理解一下冒泡和捕获&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/Jacob98/1513503/o_1564415635638.png&quot; alt=&quot;1564415635638&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;stop修饰符&quot;&gt;(1) &lt;code&gt;.stop&lt;/code&gt;修饰符&lt;/h3&gt;
&lt;p&gt;请看如下代码&lt;/p&gt;
&lt;pre class=&quot;vue&quot;&gt;
&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;div class=&quot;about&quot;&amp;gt;
    &amp;lt;div @click=&quot;test1&quot;&amp;gt;
      &amp;lt;div @click=&quot;test2&quot;&amp;gt;
        测试
      &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
export default {
  methods:{
    test1(){
      console.log('test1')
    },
    test2(){
      console.log('test2')
    }
  }
}
&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由以上代码可以看到我们有一个嵌套的div，每一个div都绑定着一个事件，如果我们点击div的话是按什么顺序触发这两个事件的呢。其实是默认按照冒泡的方式触发的，简单来说就是由内而外，如果还是不明白请看上面的解析图。&lt;/p&gt;
&lt;p&gt;此Vue文件最终生成的界面是这个样子的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/Jacob98/1513503/o_1564415745516.png&quot; alt=&quot;1564415745516&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当我们点击的时候默认按照冒泡方式触发函数，控制台打印结果如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/Jacob98/1513503/o_1564415856979.png&quot; alt=&quot;1564415856979&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;现在就是&lt;code&gt;.stop&lt;/code&gt;发挥作用的时候了&lt;/strong&gt;，修改代码如下&lt;/p&gt;
&lt;pre class=&quot;vue&quot;&gt;
&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;div class=&quot;about&quot;&amp;gt;
    &amp;lt;div @click=&quot;test1&quot;&amp;gt;
      &amp;lt;div @click.stop=&quot;test2&quot;&amp;gt;
        测试
      &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样我们在点击之后控制台打印结果如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/Jacob98/1513503/o_1564415967890.png&quot; alt=&quot;1564415967890&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由这个结果我们可以看到，这个修饰符的作用就是阻止事件冒泡，不让他向外去执行函数，到此为止&lt;/p&gt;
&lt;h3 id=&quot;prevent修饰符&quot;&gt;(2)&lt;code&gt;.prevent&lt;/code&gt;修饰符&lt;/h3&gt;
&lt;p&gt;这个时候我们再来说一下.prevent修饰符，其作用就是阻止组件本来应该发生的事件，转而去执行自己定义的事件&lt;/p&gt;
&lt;pre class=&quot;vue&quot;&gt;
&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;div class=&quot;about&quot;&amp;gt;
    &amp;lt;a href=&quot;https://www.cnblogs.com/Jacob98/&quot; @click=&quot;test2&quot;&amp;gt;跳转&amp;lt;/a&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
export default {
  methods:{
    test2(){
      console.log('test2')
    }
  }
}
&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述代码我们并没有添加.prevent修饰符，接下来的结果我们应该可以想到，点击之后会跳转到我写的网址中(也就是我的博客😎)，当时当我们对这个代码稍作修改&lt;/p&gt;
&lt;pre class=&quot;vue&quot;&gt;
&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;div class=&quot;about&quot;&amp;gt;
    &amp;lt;a href=&quot;https://www.cnblogs.com/Jacob98/&quot; @click.prevent=&quot;test2&quot;&amp;gt;跳转&amp;lt;/a&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;点击之后就不会跳转到相应的网址，而是去执行我写的函数&lt;/p&gt;
&lt;h3 id=&quot;capture修饰符&quot;&gt;(3)&lt;code&gt;.capture&lt;/code&gt;修饰符&lt;/h3&gt;
&lt;p&gt;其实这个的理解就很简单，就想我们第一节所说，网页是默认按照冒泡方式去触发函数的，但是当我们使用.capture修饰符时，网页就会按照捕获的方式触发函数，也就是从外向内执行，&lt;strong&gt;但是这个时候一定要注意，.capture修饰符一定要写在外层才能生效&lt;/strong&gt;，原因大家应该能自己想清楚。&lt;/p&gt;
&lt;pre class=&quot;vue&quot;&gt;
&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;div class=&quot;about&quot;&amp;gt;
    &amp;lt;div @click.capture=&quot;test1&quot;&amp;gt;
      &amp;lt;div @click.stop=&quot;test2&quot;&amp;gt;
        测试
      &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;控制台打印结果如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/Jacob98/1513503/o_1564416984007.png&quot; alt=&quot;1564416984007&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;once修饰符&quot;&gt;(4)&lt;code&gt;.once&lt;/code&gt;修饰符&lt;/h3&gt;
&lt;p&gt;这个理解起来就更加简单了，加上此修饰符之后相应的函数只能触发一次，无论你点击多少下，函数就只触发一次。这个有一个用途就是防止用户多次点击造成应用数据错误。比如说用户点击支付按钮，由于客户机器比较卡顿，点击一下之后没有立即反应就又点了一下，这个时候有可能就会造成多次扣费，降低用户体验。&lt;/p&gt;
&lt;h3 id=&quot;self修饰符&quot;&gt;(5)&lt;code&gt;.self&lt;/code&gt;修饰符&lt;/h3&gt;
&lt;p&gt;当前元素自身时触发处理函数时才会触发函数，原理：是根据event.target确定是否当前元素本身，来决定是否触发的事件/函数&lt;br/&gt;实例：如果点击内部点击2，冒泡不会执行gett方法，因为event.target指的是内部点击2的dom元素，不是外部点击1的，所以不会触发自己的点击事件&lt;/p&gt;
&lt;pre class=&quot;vue&quot;&gt;
&lt;code&gt;&amp;lt;div v-on:click.self=&quot;test1&quot;&amp;gt;
    test1
    &amp;lt;div v-on:click=&quot;test2&quot;&amp;gt;
        test2
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/Jacob98/1513503/o_1564415967890.png&quot; alt=&quot;1564417031353&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 30 Jul 2019 00:34:00 +0000</pubDate>
<dc:creator>Jacob98</dc:creator>
<og:description>整体学习Vue时看到Vue文档中有事件修饰符的描述，但是看了之后并没有理解是什么意思，于是查阅了资料，现在记录下来与大家分享 先给大家画一个示意图理解一下冒泡和捕获 (1) 修饰符 请看如下代码 由以</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Jacob98/p/11267399.html</dc:identifier>
</item>
<item>
<title>.net持续集成sonarqube篇之 sonarqube与jenkins集成(命令模式) - 周国通</title>
<link>http://www.cnblogs.com/tylerzhou/p/11267627.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tylerzhou/p/11267627.html</guid>
<description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/tylerzhou/p/11204826.html&quot;&gt;系列目录&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;sonarqube结合jenkins与常见问题&quot;&gt;Sonarqube结合Jenkins与常见问题&lt;/h2&gt;
&lt;p&gt;我们引入sonarqube组件的最终目的是要为整个Ci环境服务的,如果不能集成于当前的Jenkins CI,那么我们做的很多关于sonarqube的工作都将是徒劳的.然而这一点几乎不用担心,因为我们从前面的讲解可以看到我们的构建操作都是通过命令行来进进行的,从这一点来看应该是可以无缝的集成到jenkins环境,然而我们把命令原封搬到Jenkins上发现,事情并不像想像的那么简单,而是有各种各样的坑存在.&lt;/p&gt;
&lt;p&gt;我们运行以下前面章节运行过的代码,看看会出现什么问题:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;MSBuild.SonarQube.Runner.exe begin /k:&quot;mytest&quot; /n:&quot;mytest&quot; /v:&quot;v8.0&quot; /d:sonar.cs.opencover.reportsPaths=&quot;%CD%\testcover.xml&quot;

msbuild.exe

&quot;E:\personalproject\newTest2018\ConsoleApp1\packages\OpenCover.4.6.519\tools\OpenCover.Console.exe&quot; -output:&quot;%CD%\testcover.xml&quot; -register:user -target:&quot;C:\Program Files (x86)\Microsoft Visual Studio\2017\Enterprise\Common7\IDE\CommonExtensions\Microsoft\TestWindow\vstest.console.exe&quot; -targetargs:&quot;%CD%\bin\Debug\NunitTest.dll&quot;

MSBuild.SonarQube.Runner.exe end&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行以上命令根据可能会出现以下问题:&lt;/p&gt;
&lt;h2 id=&quot;问题1-命令找不到&quot;&gt;问题1 命令找不到&lt;/h2&gt;
&lt;p&gt;可能会有童鞋遇到&lt;code&gt;MSBuild.SonarQube.Runner.exe&lt;/code&gt; is not recognized as an internal or external command,operable program or batch file.&lt;/p&gt;
&lt;p&gt;当然可能有些童鞋不会遇到这个问题,这主要取决于环境变量path的设置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201907/811801-20190730080433963-1421764696.png&quot; alt=&quot;avatar&quot;/&gt;&lt;br/&gt;可以看到这个界面有两个地方可以设置path,上面是用户级别的,下面是系统级别的,如果你是在上面用户级别设置的path,则Jenkins无法读取到(这里仅仅是指默认情况下)当前用户变量的,因为Jenkins执行用户和当前用户并不是同一个用户.(大家可以在jenkins里执行whoami来看下jenkins里的执行用户).这里有两个解决办法:第一种办法就是指定可执行文件&lt;code&gt;MSBuild.SonarQube.Runner.exe&lt;/code&gt;的完整路径(其它可执行文件也一样),第二,把环境变量添加到全局配置里.加到全局变量里虽然方便了,但是全局变量的总长度是有限制的,如果配置的过多很容易超出限制,还有一点问题就是像mono在安装的时候全自动添加很多环境变量,如果用户装了mono,使用全局的msbuild编译有时候会造成编译的结果和指定完整路径的编译结果不一致,这一点请用户自己斟酌.&lt;/p&gt;
&lt;h2 id=&quot;问题2-相对路径问题&quot;&gt;问题2 相对路径问题&lt;/h2&gt;
&lt;p&gt;以上代码中我们使用了&lt;code&gt;%CD%&lt;/code&gt;,我们前面的示例都是在工程目录下执行的,%CD%即为当前目录,而在Jenkins环境中,当前目录是&lt;code&gt;Jenkins\workspace\项目名&lt;/code&gt;,如果处理不当,会导致编译错误.&lt;/p&gt;
&lt;p&gt;第二段&lt;code&gt;msbuild.exe&lt;/code&gt;也是一样问题,它必须在工程目录下的时候才不需要指定要编译的项目名,如果当前目录下没有sln或者csproj文件,则需要显式指定项项目文件的完整路径如&lt;code&gt;msbuild.exe &quot;E:\personalproject\newTest2018\ConsoleApp1\NunitTest\NunitTest.csproj&quot;&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;问题3-路径是否需要加引号&quot;&gt;问题3 路径是否需要加引号&lt;/h2&gt;
&lt;p&gt;这其实是一个常见的问题,我们会发现有时候路径不带引号不会出现问题,有时候会出现问题,就笔者的经验,如果路径中没有空格则不用加引号,如果有则需要加引号.因此为了避免不必要的麻烦,建议的最佳实践是路径都加上引号.&lt;/p&gt;
&lt;h2 id=&quot;问题4-默认jenkins账户无法编译sonarqube项目&quot;&gt;问题4 默认Jenkins账户无法编译Sonarqube项目&lt;/h2&gt;
&lt;p&gt;我们把所有的问题都解决完之后,会发现Jenkins仍然构建失败,提示信息如下&lt;code&gt;Running the Scanner for MSBuild under Local System or Network Service account is not supported. Please, use a local or domain user account instead.&lt;/code&gt;&lt;br/&gt;以上错误明确提出,Sonarqube MSbuild 扫描器不支持本地系统账户或者网络服务账户,需要使用普通账户登陆.下面我们讲一下如何处理这个问题.&lt;/p&gt;
&lt;p&gt;我们打开windows cmd执行whoami查看一下当前用户:&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201907/811801-20190730080426335-1373056251.png&quot; alt=&quot;avatar&quot;/&gt;&lt;/p&gt;
&lt;p&gt;右击&lt;code&gt;我的电脑&lt;/code&gt;选择&lt;code&gt;管理&lt;/code&gt;然后从管理界面里面找到&lt;code&gt;服务&lt;/code&gt;或者在cmd界面输入&lt;code&gt;services.msc&lt;/code&gt;来打开服务管理界面,从服务管理界面找到&lt;code&gt;jenkins&lt;/code&gt;服务,右键点击&lt;code&gt;属性&lt;/code&gt;,在弹出的对话框中切换到&lt;code&gt;登陆&lt;/code&gt;标签,如果没有登陆则是本地败,我们选择&lt;code&gt;此账户&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201907/811801-20190730080418928-1121848500.png&quot; alt=&quot;avatar&quot;/&gt;&lt;br/&gt;然后输入账户和密码点击确定.&lt;/p&gt;
&lt;p&gt;完成以上操作以后重新启动jenkins服务然后再执行脚本,就可以编译通过了.&lt;/p&gt;
</description>
<pubDate>Tue, 30 Jul 2019 00:06:00 +0000</pubDate>
<dc:creator>周国通</dc:creator>
<og:description>'系列目录' Sonarqube结合Jenkins与常见问题 我们引入sonarqube组件的最终目的是要为整个Ci环境服务的,如果不能集成于当前的Jenkins CI,那么我们做的很多关于sonar</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tylerzhou/p/11267627.html</dc:identifier>
</item>
<item>
<title>性能测试-服务端瓶颈分析思路 - 飞天小子</title>
<link>http://www.cnblogs.com/Zfc-Cjk/p/11262924.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Zfc-Cjk/p/11262924.html</guid>
<description>&lt;h2&gt;概述&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;性能测试中，对服务端的指标监控也是很重要的一个环节。通过对各项服务器性能指标的监控分析，可以定位到性能瓶颈。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;后端性能指标有CPU，内存，网络，I/O等等&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;分析思路&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;整体系统CPU利用率&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;内存利用率&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;磁盘I/O的利用率和延迟&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;网络利用率&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;CPU定位分析&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;CPU利用率大于50%，需要注意；大于70%，需要密切关注；高于90%，情况比较严重。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;监控命令：vmstat、sar、dstat、mpstat、top、ps&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;2&quot; cellspacing=&quot;3&quot; cellpadding=&quot;3&quot; align=&quot;left&quot;&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;类型&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;度量方法&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;衡量标准&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;利用率&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;1、vmstat 统计&lt;span&gt;&lt;strong&gt;1-%idle&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、sar -u 统计1-%idle&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、dstat 统计1-%idl&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、mpstat -P ALL 统计1-%idle&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;&lt;span&gt; &lt;/span&gt;
&lt;p&gt;&lt;span&gt;注意&amp;gt;=50%&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;告警&amp;gt;=70%&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;严重&amp;gt;=90%&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;满载&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;8&quot;&gt; 
&lt;p&gt;&lt;span&gt;1、vmstat的&lt;span&gt;&lt;strong&gt;r&lt;/strong&gt;&lt;/span&gt;值&amp;gt; cpu逻辑颗数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、sar -q ,“&lt;strong&gt;&lt;span&gt;runq-sz&lt;/span&gt;&lt;/strong&gt;”&amp;gt;cpu逻辑颗数&lt;/span&gt;&lt;/p&gt;

&lt;/td&gt;
&lt;td&gt;&lt;span&gt; 运行队列大于1时，证明已经有一定的负载&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
















&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;内存定位分析&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;当物理内存不够时，会使用swap分区，所以性能测试过程中需要关注swap和mem的使用情况。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;物理内存不够，大量的内存置换到swap空间，可能导致CPU和I/O的瓶颈。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;监控命令：vmstat、sar、dstat、free、top、ps等&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;2&quot; align=&quot;left&quot;&gt;&lt;tbody readability=&quot;4.5&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;类型&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;度量方法&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;衡量标注&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;&lt;span&gt;占用率&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;1、free 查看使用情况&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、vmstat&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、sar -r&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、ps&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;注意&amp;gt;=50%&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;告警&amp;gt;=70%&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;严重&amp;gt;=80%&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;10&quot;&gt;&lt;td&gt;&lt;span&gt;满载&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;1、vmstat的si/so比例，swapd占比&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、sar -W 查看次缺页数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、dmesg | grep killed&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span&gt;1、so数值大，且swapd已经占比很高，内存已经饱和&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、sar命令次缺页多意味内存已经饱和&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、内存不够用会触发内核的OOM机制&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;












&lt;h2&gt;网络定位分析&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;监控命令：sar、ifconfig、netstat，以及查看net的dev速率。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过查看发现收发包的吞吐率达到网卡的最大上限，网络数据报文有因为这类原因而引起的丢包、阻塞等现象都证明当前网络可能存在瓶颈。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了减小网络对性能测试的影响，一般我们都在局域网中进行测试执行。&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;2&quot; align=&quot;left&quot;&gt;&lt;tbody readability=&quot;5.5&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;类型&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;度量方法&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;衡量标准&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;10&quot;&gt;&lt;td&gt;&lt;span&gt;使用情况&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;span&gt;1、sar -n DEV 的收发计数大于网卡上限&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、ifconfig RX/TX宽带超过网卡上限&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、cat /proc/net/dev的速率超过上限&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、nicstat的util基本满负荷&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;1、收发包的吞吐率达到网卡上限&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、有延迟&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、有丢包&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、有阻塞&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;&lt;span&gt;满载&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span&gt;1、ifconfig dropped 有计数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、netstat -s &quot;segments retransmited&quot;有计数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、sar -n EDEV，rxdrop/s  txdrop/s有计数&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;&lt;span&gt;有丢包统计&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt;&lt;span&gt;错误&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;span&gt;1、ifconfig，“errors”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、netstat -i，RX-ERR TX-ERR&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、sar -n EDEV，rxerr/s   txerr/s &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、ip -s link， “errors”&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;&lt;span&gt;错误有计数   &lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;


















&lt;h2&gt;IO定位分析&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;I/O读写频繁的时候，如果I/O得不到满足会导致应用的阻塞。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;需要考虑I/O的TPS、平均I/O数据、平均队列长度、平均服务时间、平均等待时间、IO利用率（磁盘Busy Time%）等指标&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;监控命令：sar、iostat、iotop&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;2&quot; align=&quot;left&quot;&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;类型&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;度量方法&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;衡量标准&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;&lt;span&gt;使用情况&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;1、iostat -xz，“%util”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、sar -d，“%util”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、cat /proc/pid/sched | grep iowait&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;注意&amp;gt;=40%&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;告警&amp;gt;=60%&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;严重&amp;gt;=80%&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;span&gt;满载&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;1、iostat -xnz，“avgqu-sz ”&amp;gt;1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、iostat await&amp;gt;70&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;&lt;span&gt;IO疑似满载&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;错误&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;1、dmseg 查看io错误&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、smartctl /dev/sda&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;&lt;span&gt;有错误信息&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</description>
<pubDate>Mon, 29 Jul 2019 22:05:00 +0000</pubDate>
<dc:creator>飞天小子</dc:creator>
<og:description>概述 性能测试中，对服务端的指标监控也是很重要的一个环节。通过对各项服务器性能指标的监控分析，可以定位到性能瓶颈。 后端性能指标有CPU，内存，网络，I/O等等 分析思路 整体系统CPU利用率 内存利</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Zfc-Cjk/p/11262924.html</dc:identifier>
</item>
<item>
<title>SpringBoot Admin 使用指南 - SpringForAll</title>
<link>http://www.cnblogs.com/springforall/p/11267442.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/springforall/p/11267442.html</guid>
<description>&lt;div readability=&quot;90.135933467164&quot;&gt;
&lt;p&gt;&lt;img class=&quot;lazyload inited loaded&quot; title=&quot;&quot; src=&quot;http://ww3.sinaimg.cn/large/006tNc79ly1g5h6jqpgs9j30u00gwdhe.jpg&quot; alt=&quot;&quot; data-src=&quot;http://ww3.sinaimg.cn/large/006tNc79ly1g5h6jqpgs9j30u00gwdhe.jpg&quot; data-width=&quot;800&quot; data-height=&quot;600&quot;/&gt;&lt;/p&gt;
&lt;h3 data-id=&quot;heading-0&quot;&gt;什么是 SpringBoot Admin？&lt;/h3&gt;
&lt;p&gt;Spring Boot Admin 是一个管理和监控你的 Spring Boot 应用程序的应用程序。这些应用程序通过 Spring Boot Admin Client（通过 HTTP）注册或者使用 Spring Cloud（例如 Eureka）发现。UI只是 Spring Boot Actuator 端点上的一个 AngularJs 应用程序。&lt;/p&gt;
&lt;h3 data-id=&quot;heading-1&quot;&gt;快速开始&lt;/h3&gt;
&lt;p&gt;首先在 IDEA 创建一个 SpringBoot 项目，把它当作 server 端，工程如下：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;lazyload inited loaded&quot; title=&quot;&quot; src=&quot;http://ww2.sinaimg.cn/large/006tNc79ly1g5h6k6639gj30db0g70tk.jpg&quot; alt=&quot;&quot; data-src=&quot;http://ww2.sinaimg.cn/large/006tNc79ly1g5h6k6639gj30db0g70tk.jpg&quot; data-width=&quot;800&quot; data-height=&quot;600&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后在 pom.xml 中引入依赖：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;copyable&quot;&gt;&amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;de.codecentric&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-admin-server&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.5.6&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;de.codecentric&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-admin-server-ui&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.5.6&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;span class=&quot;copy-code-btn&quot;&gt;复制代码&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;继续在启动类 SpringbootAdminApplication.java 中引入注解 &lt;strong&gt;@EnableAdminServer&lt;/strong&gt;，然后运行项目：&lt;/p&gt;
&lt;p&gt;访问 http://localhost:8084/ 即可：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;lazyload inited loaded&quot; title=&quot;&quot; src=&quot;http://ww2.sinaimg.cn/large/006tNc79ly1g5h6kkorbzj30u006y3zi.jpg&quot; alt=&quot;&quot; data-src=&quot;http://ww2.sinaimg.cn/large/006tNc79ly1g5h6kkorbzj30u006y3zi.jpg&quot; data-width=&quot;800&quot; data-height=&quot;600&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时会发现没有任何应用程序的信息。&lt;/p&gt;
&lt;p&gt;接下来我们新建一个 SpringBoot 项目，把它当作客户端程序，工程如下：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;lazyload inited loaded&quot; title=&quot;&quot; src=&quot;http://ww4.sinaimg.cn/large/006tNc79ly1g5h6kt54enj30cu0g7dgp.jpg&quot; alt=&quot;&quot; data-src=&quot;http://ww4.sinaimg.cn/large/006tNc79ly1g5h6kt54enj30cu0g7dgp.jpg&quot; data-width=&quot;800&quot; data-height=&quot;600&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在 pom.xml 中添加依赖：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;copyable&quot;&gt;&amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;de.codecentric&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-admin-starter-client&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.5.6&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;span class=&quot;copy-code-btn&quot;&gt;复制代码&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在 application.yml 中设置：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;lazyload inited loaded&quot; title=&quot;img&quot; src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot; alt=&quot;img&quot; data-src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot; data-width=&quot;800&quot; data-height=&quot;600&quot;/&gt;&lt;/p&gt;
&lt;p&gt;spring.boot.admin.url=http:localhost:8094 用于将当前应用注册到 Spring Boot Admin。&lt;/p&gt;
&lt;p&gt;还可以设置，spring.boot.admin.client.name: （应用程序的名字）不设置的话会有默认的名字&lt;/p&gt;
&lt;p&gt;此时把两个项目运行起来：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;lazyload inited loaded&quot; title=&quot;&quot; src=&quot;http://ww2.sinaimg.cn/large/006tNc79ly1g5h6l4bzekj30u00o0di6.jpg&quot; alt=&quot;&quot; data-src=&quot;http://ww2.sinaimg.cn/large/006tNc79ly1g5h6l4bzekj30u00o0di6.jpg&quot; data-width=&quot;800&quot; data-height=&quot;600&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击图中的 &lt;strong&gt;detail&lt;/strong&gt; 按钮：可以看到应用程序的健康值、内存、JVM、GC 等信息。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;lazyload inited loaded&quot; title=&quot;&quot; src=&quot;http://ww3.sinaimg.cn/large/006tNc79ly1g5h6lda8b6j30u00cegn7.jpg&quot; alt=&quot;&quot; data-src=&quot;http://ww3.sinaimg.cn/large/006tNc79ly1g5h6lda8b6j30u00cegn7.jpg&quot; data-width=&quot;800&quot; data-height=&quot;600&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;metrics&lt;/strong&gt; 信息：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;lazyload inited loaded&quot; title=&quot;&quot; src=&quot;http://ww4.sinaimg.cn/large/006tNc79ly1g5h6lm3gm0j30u00okgot.jpg&quot; alt=&quot;&quot; data-src=&quot;http://ww4.sinaimg.cn/large/006tNc79ly1g5h6lm3gm0j30u00okgot.jpg&quot; data-width=&quot;800&quot; data-height=&quot;600&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;环境&lt;/strong&gt; 信息：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;lazyload inited loaded&quot; title=&quot;&quot; src=&quot;http://ww1.sinaimg.cn/large/006tNc79ly1g5h6ltjf5uj30ty10ggqq.jpg&quot; alt=&quot;&quot; data-src=&quot;http://ww1.sinaimg.cn/large/006tNc79ly1g5h6ltjf5uj30ty10ggqq.jpg&quot; data-width=&quot;800&quot; data-height=&quot;600&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;log&lt;/strong&gt; 信息：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;lazyload inited loaded&quot; title=&quot;&quot; src=&quot;http://ww3.sinaimg.cn/large/006tNc79ly1g5h6ma06k8j30tn0nfdka.jpg&quot; alt=&quot;&quot; data-src=&quot;http://ww3.sinaimg.cn/large/006tNc79ly1g5h6ma06k8j30tn0nfdka.jpg&quot; data-width=&quot;800&quot; data-height=&quot;600&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JMX&lt;/strong&gt; 信息：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;lazyload inited loaded&quot; title=&quot;&quot; src=&quot;http://ww3.sinaimg.cn/large/006tNc79ly1g5h6mht0iij30t20z978s.jpg&quot; alt=&quot;&quot; data-src=&quot;http://ww3.sinaimg.cn/large/006tNc79ly1g5h6mht0iij30t20z978s.jpg&quot; data-width=&quot;800&quot; data-height=&quot;600&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;线程&lt;/strong&gt; 信息：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;lazyload inited loaded&quot; title=&quot;&quot; src=&quot;http://ww1.sinaimg.cn/large/006tNc79ly1g5h6mpegg8j30tt10rgrn.jpg&quot; alt=&quot;&quot; data-src=&quot;http://ww1.sinaimg.cn/large/006tNc79ly1g5h6mpegg8j30tt10rgrn.jpg&quot; data-width=&quot;800&quot; data-height=&quot;600&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Trace&lt;/strong&gt; 追踪信息：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;lazyload inited loaded&quot; title=&quot;&quot; src=&quot;http://ww1.sinaimg.cn/large/006tNc79ly1g5h6mzc0ixj30tn10mq7o.jpg&quot; alt=&quot;&quot; data-src=&quot;http://ww1.sinaimg.cn/large/006tNc79ly1g5h6mzc0ixj30tn10mq7o.jpg&quot; data-width=&quot;800&quot; data-height=&quot;600&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还可以下载 Heapdump 文件。&lt;/p&gt;
&lt;p&gt;刚才首页的应用列表后面有个红色的 ×，我们可以将注册上去的应用移除，但是只要你不把程序停掉，它立马又会注册上去。&lt;/p&gt;
&lt;p&gt;还有就是应用列表的 version 和 info 上面的图中为空，下面看看怎么把它变出来：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;copyable&quot;&gt;info.groupId: @project.groupId@info.artifactId: @project.artifactId@info.version: @project.version@&lt;span class=&quot;copy-code-btn&quot;&gt;复制代码&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img class=&quot;lazyload inited loaded&quot; title=&quot;&quot; src=&quot;http://ww3.sinaimg.cn/large/006tNc79ly1g5h6n8n9inj30u00omgod.jpg&quot; alt=&quot;&quot; data-src=&quot;http://ww3.sinaimg.cn/large/006tNc79ly1g5h6n8n9inj30u00omgod.jpg&quot; data-width=&quot;800&quot; data-height=&quot;600&quot;/&gt;&lt;/p&gt;
&lt;p&gt;重新运行客户端程序，刷新页面可以发现：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;lazyload inited loaded&quot; title=&quot;&quot; src=&quot;http://ww1.sinaimg.cn/large/006tNc79ly1g5h6ns8hatj30u006pdgj.jpg&quot; alt=&quot;&quot; data-src=&quot;http://ww1.sinaimg.cn/large/006tNc79ly1g5h6ns8hatj30u006pdgj.jpg&quot; data-width=&quot;800&quot; data-height=&quot;600&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还可以查询应用程序的事件变化：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;lazyload inited loaded&quot; title=&quot;&quot; src=&quot;http://ww2.sinaimg.cn/large/006tNc79ly1g5h6o2p16ij30u00p8dke.jpg&quot; alt=&quot;&quot; data-src=&quot;http://ww2.sinaimg.cn/large/006tNc79ly1g5h6o2p16ij30u00p8dke.jpg&quot; data-width=&quot;800&quot; data-height=&quot;600&quot;/&gt;&lt;/p&gt;
&lt;h3 data-id=&quot;heading-2&quot;&gt;客户端应用程序&lt;/h3&gt;

&lt;h4 data-id=&quot;heading-3&quot;&gt;JMX bean管理&lt;/h4&gt;
&lt;p&gt;要在管理界面中与JMX-beans进行交互，您必须在客户端应用程序中包含 Jolokia,&lt;/p&gt;
&lt;p&gt;pom.xml 加入依赖：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;copyable&quot;&gt;        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.jolokia&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;jolokia-core&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
&lt;span class=&quot;copy-code-btn&quot;&gt;复制代码&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重启客户端程序后，就可以在这里与 JMX 做交互了：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;lazyload inited loaded&quot; title=&quot;&quot; src=&quot;http://ww1.sinaimg.cn/large/006tNc79ly1g5h6opv06sj30tn10ogpj.jpg&quot; alt=&quot;&quot; data-src=&quot;http://ww1.sinaimg.cn/large/006tNc79ly1g5h6opv06sj30tn10ogpj.jpg&quot; data-width=&quot;800&quot; data-height=&quot;600&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还有很多 SpringBoot Admin 客户端配置选项：&lt;/p&gt;
&lt;p&gt;http://codecentric.github.io/spring-boot-admin/1.5.6/#spring-boot-admin-client&lt;/p&gt;
&lt;h3 data-id=&quot;heading-4&quot;&gt;服务端程序&lt;/h3&gt;
&lt;p&gt;也有些 SpringBoot Admin 服务端程序配置选项：&lt;/p&gt;
&lt;p&gt;http://codecentric.github.io/spring-boot-admin/1.5.6/#spring-boot-admin-server&lt;/p&gt;
&lt;p&gt;官方文档里面还有些关于服务下线消息通知的知识，想了解的可以查看：&lt;/p&gt;
&lt;p&gt;http://codecentric.github.io/spring-boot-admin/1.5.6/#_notifications&lt;/p&gt;
&lt;h3 data-id=&quot;heading-5&quot;&gt;参考文章&lt;/h3&gt;
&lt;p&gt;http://codecentric.github.io/spring-boot-admin/1.5.6/&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;推荐阅读：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;《深入理解 Java 内存模型》读书笔记&quot; href=&quot;https://link.juejin.im?target=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzU0MDEwMjgwNA%3D%3D%26mid%3D2247485768%26idx%3D1%26sn%3Dbaeb6e3e6ce1c22b8b87bbcd1e968152%26chksm%3Dfb3f10b3cc4899a51205e06df69bab0632636f13217062eaa6dbe678bc9fe1db883e5f54fe63%26scene%3D21%23wechat_redirect&quot; rel=&quot;nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;《深入理解 Java 内存模型》读书笔记&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;面试-基础篇&quot; href=&quot;https://link.juejin.im?target=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzU0MDEwMjgwNA%3D%3D%26mid%3D2247485764%26idx%3D1%26sn%3D418a946e30a9dc1d3166da3d83a90d8d%26chksm%3Dfb3f10bfcc4899a92d510f7d2c612536626ead30d4e0ace82e89c50210d4fd09ce48fd924c37%26scene%3D21%23wechat_redirect&quot; rel=&quot;nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;面试-基础篇&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;Spring Boot 2.0 迁移指南&quot; href=&quot;https://link.juejin.im?target=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzU0MDEwMjgwNA%3D%3D%26mid%3D2247485754%26idx%3D1%26sn%3D9158ea22e664aad9972f2582e66a215c%26chksm%3Dfb3f10c1cc4899d7ec106aa0c1e7ef4e7217fdf91dd852d5a34b0f3f88c321cf36e03a55c6ec%26scene%3D21%23wechat_redirect&quot; rel=&quot;nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Spring Boot 2.0 迁移指南&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;SpringBoot使用Docker快速部署项目&quot; href=&quot;https://link.juejin.im?target=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzU0MDEwMjgwNA%3D%3D%26mid%3D2247485741%26idx%3D1%26sn%3Db048dfa7110ac22b09319af5806a8307%26chksm%3Dfb3f10d6cc4899c0338be7ba5c7b63688a8d8c0ce3d2a56d2db387636f9939c2a951f8280c60%26scene%3D21%23wechat_redirect&quot; rel=&quot;nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;SpringBoot使用Docker快速部署项目&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么选择 Spring 作为 Java 框架？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SpringBoot RocketMQ 整合使用和监控&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;Spring Boot 面试的十个问题&quot; href=&quot;https://link.juejin.im?target=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzU0MDEwMjgwNA%3D%3D%26mid%3D2247485788%26idx%3D1%26sn%3D29aa0c17d493704803cebfc7ce78260d%26chksm%3Dfb3f10a7cc4899b193cdd2e116caf0520e24cd72f17896a6d0cb6fe8963554d9a5ce37ae90fb%26scene%3D21%23wechat_redirect&quot; rel=&quot;nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Spring Boot 面试的十个问题&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;上篇好文：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;使用 Spring Framework 时常犯的十大错误&quot; href=&quot;https://link.juejin.im?target=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzU0MDEwMjgwNA%3D%3D%26mid%3D2247485793%26idx%3D1%26sn%3Dd832f0318916628b8867df21a030adf1%26chksm%3Dfb3f109acc48998ced40390c8e01a33c37cb96a06c90b96ba34f81fd51a5aa70ce3792a6847d%26scene%3D21%23wechat_redirect&quot; rel=&quot;nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;使用 Spring Framework 时常犯的十大错误&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;右上角按钮分享给更多人哦~&lt;/strong&gt;&lt;strong&gt;&lt;img class=&quot;lazyload inited loaded&quot; title=&quot;img&quot; src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot; alt=&quot;img&quot; data-src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot; data-width=&quot;800&quot; data-height=&quot;600&quot;/&gt;&lt;/strong&gt;&lt;strong&gt;&lt;img class=&quot;lazyload inited loaded&quot; title=&quot;img&quot; src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot; alt=&quot;img&quot; data-src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot; data-width=&quot;800&quot; data-height=&quot;600&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;lazyload inited loaded&quot; title=&quot;&quot; src=&quot;http://ww3.sinaimg.cn/large/006tNc79ly1g5g3i5s8iwj30u00un7e3.jpg&quot; alt=&quot;&quot; data-src=&quot;http://ww3.sinaimg.cn/large/006tNc79ly1g5g3i5s8iwj30u00un7e3.jpg&quot; data-width=&quot;800&quot; data-height=&quot;600&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;&lt;p&gt;
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。&lt;/p&gt;</description>
<pubDate>Mon, 29 Jul 2019 16:46:00 +0000</pubDate>
<dc:creator>SpringForAll</dc:creator>
<og:description>什么是 SpringBoot Admin？ Spring Boot Admin 是一个管理和监控你的 Spring Boot 应用程序的应用程序。这些应用程序通过 Spring Boot Admin</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/springforall/p/11267442.html</dc:identifier>
</item>
<item>
<title>消费端如何保证消息队列MQ的有序消费 - OKevin</title>
<link>http://www.cnblogs.com/yulinfeng/p/11254925.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yulinfeng/p/11254925.html</guid>
<description>&lt;h2 id=&quot;消息无序产生的原因&quot;&gt;消息无序产生的原因&lt;/h2&gt;
&lt;p&gt;消息队列，既然是队列就能保证消息在进入队列，以及出队列的时候保证消息的有序性，显然这是在消息的生产端(Producer)，但是往往在生产环境中有多个消息的消费端(Consumer)，尽管消费端在拉取消息时是有序的，但各个消息由于网络等方面原因无法保证在各个消费端中处理时有序。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/630246/201907/630246-20190727142609837-1782813288.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;场景分析&quot;&gt;场景分析&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;先后两次修改了商品信息，消息A和消息B先后同步写入MySQL，接着异步写入消息队列中发送消息，此时消息队列生产端（Producer）按时序先后发出了A和B两条消息(消息A先发出，消息B后发出)。按业务逻辑，商品信息的最终状态需要以消息A和消息B综合为准。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看似一个比较常见的同步写数据库，异步发送消息的场景，但实际上需要保证消息的有序消费。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;假设1：消息A只包含修改的&lt;strong&gt;商品名称&lt;/strong&gt;，消息B只包含修改的&lt;strong&gt;商品重量&lt;/strong&gt;，此时消息队列的消费端实际上&lt;strong&gt;不需要关注消息时序&lt;/strong&gt;，消息队列消费端（Consumer）只管消费即可。&lt;/li&gt;
&lt;li&gt;假设2：消息A包含修改的&lt;strong&gt;商品名称、重量&lt;/strong&gt;，消息B包含修改的&lt;strong&gt;商品名称&lt;/strong&gt;，此时消费端首先接收到消息B，后接收到消息A，那么消息B的修改就会被覆盖。此时消息队列的消费端实际上又&lt;strong&gt;需要关注消息时序&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;可见，你无法保证消息中包含什么信息，此时必须保证消息的有序消费。&lt;/p&gt;
&lt;h2 id=&quot;业务角度如何保证消息有序消费&quot;&gt;业务角度如何保证消息有序消费&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;生产端&lt;/strong&gt;在发送消息时，始终保证消息是全量信息。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;消费端&lt;/strong&gt;在接收消息时，通过缓存时间戳的方式，消费消息时判断消息产生的时间是否最新，如果不是则丢弃，如果是则执行下一步。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面通过伪代码的方式描述：&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;strong&gt;生产端伪代码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;insertWare(ware); #插入数据到数据库，通常在插入数据库时我们只会update修改的字段，而不会全量插入&lt;/p&gt;
&lt;p&gt;ware = selectWareById(ware.getId); #获取商品的全量信息（此时是最新的），用于将它放入到消息队列中&lt;/p&gt;
&lt;p&gt;syncMq(ware); #异步发送mq消息A&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;strong&gt;消费端伪代码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ware = fetchWare(); #获取消息&lt;/p&gt;
&lt;p&gt;if (isLasted(ware)) #通过商品的修改时间戳判断是否是最新的修改&lt;/p&gt;
&lt;p&gt;​ TODO #执行下一步业务逻辑&lt;/p&gt;
&lt;p&gt;else&lt;/p&gt;
&lt;p&gt;​ return #丢弃该消息&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;重点在于消费端如何判断该消息是否是最新的修改也就是&lt;code&gt;isLasted&lt;/code&gt;方法。&lt;/p&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;&lt;strong&gt;isLasted方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Long modified = getCacheById(ware.getId); #获取缓存中该条商品的最新修改时间&lt;/p&gt;
&lt;p&gt;If (ware.getModified &amp;gt; modified) { #如果消息中商品修改时间大于缓存中的时间，说明是最新操作&lt;/p&gt;
&lt;p&gt;​ setCacheById(ware); #将该条消息的商品修改时间戳写入到缓存中&lt;/p&gt;
&lt;p&gt;​ return true;&lt;br/&gt;} else #如果消息中的商品修改时间&lt;strong&gt;小于&lt;/strong&gt;缓存中的时间，说明该条消息属于“历史操作”，不对其更新&lt;/p&gt;
&lt;p&gt;​ return false;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以上就是通过伪代码的方式，描述如何通过业务手段保证消息有序消费，重点在于&lt;strong&gt;全量发送信息和缓存时间戳&lt;/strong&gt;。在其中还有一些技术实现细节。&lt;/p&gt;
&lt;p&gt;例如：消费端消费消息B，执行到&lt;strong&gt;获取时间戳缓存之后，并在重新设置新的缓存之前&lt;/strong&gt;，此时另一个消费端恰好也正在消费B它也正执行到&lt;strong&gt;获取时间戳缓存&lt;/strong&gt;，由于消息A此时并没有更新缓存，消息A拿到的缓存仍然是旧的缓存，这时就会存在两个消费端都认为自己所消费的消息时最新的，造成该丢弃的消息没丢。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/630246/201907/630246-20190727142452468-1440208731.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;显然，这是&lt;strong&gt;分布式线程安全&lt;/strong&gt;问题，分布式锁通常使用Redis或者ZooKeeper，加锁后的执行时序如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/630246/201907/630246-20190727142518231-309564141.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是从业务角度保证消息在消费端有序消费。通过在消息发送端全量发送消息以及在消息消费端缓存时间戳就可以保证消息的有序消费。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;在上述场景中是先同步写入MySQL，再获取商品全量数据，接着再异步发送消息。这一系列的步骤可以通过接MySQL的binlog实现，在同步写入MySQL后，MySQL发送binlog变更，通过阿里巴巴Canal中间件接收MySQL的binlog变更再发送消息到消息队列。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;这是一个能给程序员加buff的公众号 （CoderBuff）&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/630246/201907/630246-20190717223740465-1981496921.png&quot;/&gt;&lt;/div&gt;
</description>
<pubDate>Mon, 29 Jul 2019 16:15:00 +0000</pubDate>
<dc:creator>OKevin</dc:creator>
<og:description>消息无序产生的原因 消息队列，既然是队列就能保证消息在进入队列，以及出队列的时候保证消息的有序性，显然这是在消息的生产端(Producer)，但是往往在生产环境中有多个消息的消费端(Consumer)</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yulinfeng/p/11254925.html</dc:identifier>
</item>
<item>
<title>Win10系统下安装labelme，json文件批量转化 - apan008</title>
<link>http://www.cnblogs.com/apan008/p/11267203.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/apan008/p/11267203.html</guid>
<description>
&lt;p&gt;&lt;strong&gt;一、&lt;/strong&gt;&lt;strong&gt;安装环境：windows10&lt;/strong&gt;&lt;strong&gt;，anaconda3&lt;/strong&gt;&lt;strong&gt;，python3.6&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;       &lt;/strong&gt; 由于框架maskrcnn需要json数据集，在没安装labelme环境和跑深度学习之前，我安装的是anaconda3，其中pyhton是3.7版本的，经网上查阅资料，经过一番查找资料，发现，原来在2019年，TensorFlow还不支持python3.7，所以，迫于无奈，我只能乖乖把python的版本退回到3.6版本，具体步骤也很简单。就是打开anaconda prompt ,然后输入conda install python=3.6，然后等待提示（y/n），输入y，等待十几分钟，就会提示done，这样的话，就表示python3.7已经退回到python3.6了。(&lt;span&gt;经过尝试这种方法在我这里没有行得通，可能跟网速有关，又尝试了另一种方法,有兴趣的可以尝试一下。)&lt;span&gt;索性就把labelme安装到3.6中了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、安装过程：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;      1、管理员身份打开 anaconda prompt&lt;/p&gt;

&lt;p&gt;      2、输入命令：conda create --name=labelme python=3.6&lt;/p&gt;

&lt;p&gt;      3、输入命令：activate labelme&lt;/p&gt;

&lt;p&gt;      4、输入命令：pip install pyqt5，pip install pyside2(自己刚开始没有安装pyside2,运行 \anaconda安装目录\envs\labelme\Scripts\label_json_to_dataset.exe 会出现module &quot;pyside&quot;缺失错误)&lt;/p&gt;

&lt;p&gt;      5、输入命令：pip install labelme（由于网络原因或者库的地址，经常运行一半出现错误，不要气馁，多执行几次）&lt;/p&gt;

&lt;p&gt;      6、输入命令：labelme   即可打开labelme。如下：&lt;/p&gt;
&lt;p&gt;   &lt;img src=&quot;https://img2018.cnblogs.com/blog/761956/201907/761956-20190729231125009-1729789472.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;安装完成后，需要使用再次启动labelme。则需要重新打开anaconda prompt，输入activate labelme，进入labelme环境。再输 入命令: labelme 即可&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;三、&lt;/strong&gt;&lt;strong&gt;用labelme&lt;/strong&gt;&lt;strong&gt;标注完图片后，会生成json&lt;/strong&gt;&lt;strong&gt;文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;  以小猫为例：点击保存会在自己的图片目录下生成json文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/761956/201907/761956-20190729231440131-1265072460.png&quot; alt=&quot;&quot;/&gt;点点&lt;/p&gt;
&lt;p&gt; 生成的json文件并不能直接用，我们需要对他进行批处理才能成为maskrcnn需要的数据集，批量转化如下：&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;abelme标注工具再转化&lt;span lang=&quot;EN-US&quot;&gt;.json文件有一个缺陷，一次只能转换一个&lt;span lang=&quot;EN-US&quot;&gt;.json文件，然而深度学习的项目通常需要大量的数据，那么转换&lt;span lang=&quot;EN-US&quot;&gt;.json文件就是一个比较耗时的工作；因此，对&lt;span lang=&quot;EN-US&quot;&gt;labelme做出了改进，可以实现批量转换&lt;span lang=&quot;EN-US&quot;&gt;.json文件。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;在安装Anaconda中找到json_to_dataset.py文件如果未找到可以在计算机中搜索，将该文件代码修改为以下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; argparse
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; base64
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; json
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; os
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; os.path as osp
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; warnings

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; PIL.Image
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; yaml

&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; labelme &lt;span&gt;import&lt;/span&gt;&lt;span&gt; utils


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; main():
    warnings.warn(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;This script is aimed to demonstrate how to convert the\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
                  &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;JSON file to a single image dataset, and not to handle\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
                  &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;multiple JSON files to generate a real-use dataset.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

    parser &lt;/span&gt;=&lt;span&gt; argparse.ArgumentParser()
    parser.add_argument(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;json_file&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    parser.add_argument(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-o&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;--out&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, default=&lt;span&gt;None)
    args &lt;/span&gt;=&lt;span&gt; parser.parse_args()

    json_file &lt;/span&gt;=&lt;span&gt; args.json_file

    alist &lt;/span&gt;=&lt;span&gt; os.listdir(json_file)
    


    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(0,len(alist)):
        path &lt;/span&gt;=&lt;span&gt; os.path.join(json_file,alist[i])
        data &lt;/span&gt;=&lt;span&gt; json.load(open(path))

        out_dir &lt;/span&gt;= osp.basename(path).replace(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;_&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        out_dir &lt;/span&gt;=&lt;span&gt; osp.join(osp.dirname(path), out_dir)

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; osp.exists(out_dir):
            os.mkdir(out_dir)

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;imageData&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]:
            imageData &lt;/span&gt;= data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;imageData&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            imagePath &lt;/span&gt;= os.path.join(os.path.dirname(path), data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;imagePath&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
            with open(imagePath, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;rb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) as f:
                imageData &lt;/span&gt;=&lt;span&gt; f.read()
                imageData &lt;/span&gt;= base64.b64encode(imageData).decode(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

        img &lt;/span&gt;=&lt;span&gt; utils.img_b64_to_arr(imageData)

        label_name_to_value &lt;/span&gt;= {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;_background_&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: 0}
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; shape &lt;span&gt;in&lt;/span&gt; data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;shapes&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]:
            label_name &lt;/span&gt;= shape[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; label_name &lt;span&gt;in&lt;/span&gt;&lt;span&gt; label_name_to_value:
                label_value &lt;/span&gt;=&lt;span&gt; label_name_to_value[label_name]
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                label_value &lt;/span&gt;=&lt;span&gt; len(label_name_to_value)
                label_name_to_value[label_name] &lt;/span&gt;=&lt;span&gt; label_value

        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; label_values must be dense&lt;/span&gt;
        label_values, label_names =&lt;span&gt; [], []
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; ln, lv &lt;span&gt;in&lt;/span&gt; sorted(label_name_to_value.items(), key=&lt;span&gt;lambda&lt;/span&gt; x: x[1&lt;span&gt;]):
            label_values.append(lv)
            label_names.append(ln)
        &lt;/span&gt;&lt;span&gt;assert&lt;/span&gt; label_values ==&lt;span&gt; list(range(len(label_values)))

        lbl &lt;/span&gt;= utils.shapes_to_label(img.shape, data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;shapes&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;], label_name_to_value)

        captions &lt;/span&gt;= [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;{}: {}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(lv, ln)
                    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; ln, lv &lt;span&gt;in&lt;/span&gt;&lt;span&gt; label_name_to_value.items()]
        lbl_viz &lt;/span&gt;=&lt;span&gt; utils.draw_label(lbl, img, captions)

        PIL.Image.fromarray(img).save(osp.join(out_dir, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;img.png&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
        utils.lblsave(osp.join(out_dir, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;label.png&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;), lbl)
        PIL.Image.fromarray(lbl_viz).save(osp.join(out_dir, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;label_viz.png&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))

        with open(osp.join(out_dir, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;label_names.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;), &lt;span&gt;'&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) as f:
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; lbl_name &lt;span&gt;in&lt;/span&gt;&lt;span&gt; label_names:
                f.write(lbl_name &lt;/span&gt;+ &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

        warnings.warn(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;info.yaml is being replaced by label_names.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        info &lt;/span&gt;= dict(label_names=&lt;span&gt;label_names)
        with open(osp.join(out_dir, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;info.yaml&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;), &lt;span&gt;'&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) as f:
            yaml.safe_dump(info, f, default_flow_style&lt;/span&gt;=&lt;span&gt;False)

        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Saved to: %s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; out_dir)


&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    main()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;操作命令如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/761956/201907/761956-20190729232138701-19762358.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;生成效果如下：每张图片生成五个文件 ，这就是我们所需要的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/761956/201907/761956-20190729232309526-2127814097.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 29 Jul 2019 15:26:00 +0000</pubDate>
<dc:creator>apan008</dc:creator>
<og:description>一、安装环境：windows10，anaconda3，python3.6 由于框架maskrcnn需要json数据集，在没安装labelme环境和跑深度学习之前，我安装的是anaconda3，其中py</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/apan008/p/11267203.html</dc:identifier>
</item>
<item>
<title>2019前端面试系列——Vue面试题 - 奔跑的瓜牛</title>
<link>http://www.cnblogs.com/chenwenhao/p/11258895.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenwenhao/p/11258895.html</guid>
<description>&lt;h3 id=&quot;vue-双向绑定原理&quot;&gt;Vue 双向绑定原理&lt;/h3&gt;
&lt;p&gt;       mvvm 双向绑定，采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty()来劫持各个属性的 setter、getter，在数据变动时发布消息给订阅者，触发相应的监听回调。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8560482-d18d5fe20c1ade5c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/730/format/webp&quot; alt=&quot;图片&quot;/&gt;&lt;br/&gt;&lt;strong&gt;几个要点：&lt;/strong&gt;&lt;br/&gt;1、实现一个数据监听器 Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者&lt;br/&gt;2、实现一个指令解析器 Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数&lt;br/&gt;3、实现一个 Watcher，作为连接 Observer 和 Compile 的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图&lt;br/&gt;4、mvvm 入口函数，整合以上三者&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;具体步骤：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;需要 observe 的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter 和 getter&lt;br/&gt;这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化&lt;/li&gt;
&lt;li&gt;compile 解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图&lt;/li&gt;
&lt;li&gt;Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁，主要做的事情是:
&lt;ul&gt;&lt;li&gt;在自身实例化时往属性订阅器(dep)里面添加自己&lt;/li&gt;
&lt;li&gt;自身必须有一个 update() 方法&lt;/li&gt;
&lt;li&gt;待属性变动 dep.notice() 通知时，能调用自身的 update() 方法，并触发 Compile 中绑定的回调，则功成身退。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;MVVM 作为数据绑定的入口，整合 Observer、Compile 和 Watcher 三者，通过Observer来监听自己的 model 数据变化，通过 Compile 来解析编译模板指令，最终利用 Watcher 搭起 Observer 和 Compile 之间的通信桥梁，达到数据变化 -&amp;gt; 视图更新；视图交互变化(input) -&amp;gt; 数据 model 变更的双向绑定效果。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;描述下-vue-从初始化页面--修改数据--刷新页面-ui-的过程&quot;&gt;描述下 vue 从初始化页面--修改数据--刷新页面 UI 的过程？&lt;/h3&gt;
&lt;p&gt;      当 Vue 进入初始化阶段时，一方面 Vue 会遍历 data 中的属性，并用 Object.defineProperty 将它转化成 getter/setter 的形式，实现数据劫持(暂不谈 Vue3.0 的 Proxy)；另一方面，Vue 的指令编译器 Compiler 对元素节点的各个指令进行解析，初始化视图，并订阅 Watcher 来更新试图，此时 Watcher 会将自己添加到消息订阅器 Dep 中，此时初始化完毕。&lt;br/&gt;      当数据发生变化时，触发 Observer 中 setter 方法，立即调用 Dep.notify(),Dep 这个数组开始遍历所有的订阅者，并调用其 update 方法，Vue 内部再通过 diff 算法，patch 相应的更新完成对订阅者视图的改变。&lt;/p&gt;
&lt;h3 id=&quot;vue-的生命周期&quot;&gt;Vue 的生命周期&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5c6d48e36fb9a049eb3c84ff&quot;&gt;vue生命周期详解&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;beforeCreate&lt;/code&gt;和&lt;code&gt;created&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;beforeMount&lt;/code&gt;和&lt;code&gt;mounted&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;beforeUpdate&lt;/code&gt;和&lt;code&gt;updated&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;beforeDestory&lt;/code&gt;和&lt;code&gt;destoryed&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;activated&lt;/code&gt;和&lt;code&gt;deactivated&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;vue-组件间通信有哪些方式&quot;&gt;Vue 组件间通信有哪些方式&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5cde0b43f265da03867e78d3&quot;&gt;Vue 组件间通信六种方式&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;props/$emit&lt;/li&gt;
&lt;li&gt;$emit/$on&lt;/li&gt;
&lt;li&gt;vuex&lt;/li&gt;
&lt;li&gt;$attrs/$listeners&lt;/li&gt;
&lt;li&gt;provide/inject&lt;/li&gt;
&lt;li&gt;$parent/$children 与 ref&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;watchmethods-和-计算属性的区别&quot;&gt;watch、methods 和 计算属性的区别&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;watch 为了监听某个响应数据的变化。计算属性是自动&lt;strong&gt;监听依赖值&lt;/strong&gt;的变化，从而动态返回内容，主要目的是简化模板内的复杂运算。所以区别来源于用法，只是需要动态值，那就用计算属性；需要知道值的改变后执行业务逻辑，才用 watch。&lt;/li&gt;
&lt;li&gt;methods是一个方法，它可以接受参数，而computed 不能，computed 是可以缓存的，methods 不会。computed 可以依赖其他 computed，甚至是其他组件的 data。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;vue中怎么重置data&quot;&gt;vue中怎么重置data&lt;/h3&gt;
&lt;p&gt;使用Object.assign()，vm.$data可以获取当前状态下的data，vm.$options.data可以获取到组件初始化状态下的data。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Object.assign(this.$data, this.$options.data())&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;组件中写-name-选项有什么作用&quot;&gt;组件中写 name 选项有什么作用？&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;项目使用 keep-alive 时，可搭配组件 name 进行缓存过滤&lt;/li&gt;
&lt;li&gt;DOM 做递归组件时需要调用自身 name&lt;/li&gt;
&lt;li&gt;vue-devtools 调试工具里显示的组见名称是由vue中组件name决定的&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;vue-router-有哪些钩子函数&quot;&gt;vue-router 有哪些钩子函数&lt;/h3&gt;
&lt;p&gt;官方文档：&lt;a href=&quot;https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E5%85%A8%E5%B1%80%E5%89%8D%E7%BD%AE%E5%AE%88%E5%8D%AB&quot;&gt;vue-router钩子函数&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;全局前置守卫 &lt;code&gt;router.beforeEach&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;全局解析守卫 &lt;code&gt;router.beforeResolve&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;全局后置钩子 &lt;code&gt;router.afterEach&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;路由独享的守卫 &lt;code&gt;beforeEnter&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;组件内的守卫 &lt;code&gt;beforeRouteEnter&lt;/code&gt;、&lt;code&gt;beforeRouteUpdate&lt;/code&gt;、&lt;code&gt;beforeRouteLeave&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5b10b46df265da6e2a08a724&quot;&gt;前端路由简介以及vue-router实现原理&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;route-和-router-的区别是什么&quot;&gt;&lt;code&gt;route&lt;/code&gt; 和 &lt;code&gt;router&lt;/code&gt; 的区别是什么？&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;route&lt;/code&gt;是“路由信息对象”，包括&lt;code&gt;path&lt;/code&gt;,&lt;code&gt;params&lt;/code&gt;,&lt;code&gt;hash&lt;/code&gt;,&lt;code&gt;query&lt;/code&gt;,&lt;code&gt;fullPath&lt;/code&gt;,&lt;code&gt;matched&lt;/code&gt;,&lt;code&gt;name&lt;/code&gt;等路由信息参数。&lt;br/&gt;&lt;code&gt;router&lt;/code&gt;是“路由实例对象”，包括了路由的跳转方法(&lt;code&gt;push&lt;/code&gt;、&lt;code&gt;replace&lt;/code&gt;)，钩子函数等。&lt;/p&gt;
&lt;h3 id=&quot;说一下-vue-和-react-的认识做一个简单的对比&quot;&gt;说一下 Vue 和 React 的认识，做一个简单的对比&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1.监听数据变化的实现原理不同&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Vue 通过 getter/setter 以及一些函数的劫持，能精确快速的计算出 Virtual DOM 的差异。这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。&lt;/li&gt;
&lt;li&gt;React 默认是通过比较引用的方式进行的，如果不优化，每当应用的状态被改变时，全部子组件都会重新渲染，可能导致大量不必要的 VDOM 的重新渲染。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;      Vue 不需要特别的优化就能达到很好的性能，而对于 React 而言，需要通过 PureComponent/shouldComponentUpdate 这个生命周期方法来进行控制。如果你的应用中，交互复杂，需要处理大量的 UI 变化，那么使用 Virtual DOM 是一个好主意。如果你更新元素并不频繁，那么 Virtual DOM 并不一定适用，性能很可能还不如直接操控 DOM。&lt;/p&gt;
&lt;p&gt;      为什么 React 不精确监听数据变化呢？这是因为 Vue 和 React 设计理念上的区别，Vue 使用的是可变数据，而 React 更强调数据的不可变。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.数据流的不同&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190601094122147.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva2tpXw==,size_16,color_FFFFFF,t_70&quot; alt=&quot;cmd-markdown-logo&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Vue 中默认支持双向绑定，组件与 DOM 之间可以通过 v-model 双向绑定。但是，父子组件之间，props 在 2.x 版本是单向数据流&lt;/li&gt;
&lt;li&gt;React 一直提倡的是单向数据流，他称之为 onChange/setState()模式。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;      不过由于我们一般都会用 Vuex 以及 Redux 等单向数据流的状态管理框架，因此很多时候我们感受不到这一点的区别了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.模板渲染方式的不同&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在表层上， 模板的语法不同&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;React 是通过 JSX 渲染模板&lt;/li&gt;
&lt;li&gt;而 Vue 是通过一种拓展的 HTML 语法进行渲染&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在深层上，模板的原理不同，这才是他们的本质区别：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;React 是在组件 JS 代码中，通过原生 JS 实现模板中的常见语法，比如插值，条件，循环等，都是通过 JS 语法实现的&lt;/li&gt;
&lt;li&gt;Vue 是在和组件 JS 代码分离的单独的模板中，通过指令来实现的，比如条件语句就需要 v-if 来实现&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;      对这一点，我个人比较喜欢 React 的做法，因为他更加纯粹更加原生，而 Vue 的做法显得有些独特，会把 HTML 弄得很乱。举个例子，说明 React 的好处：react 中 render 函数是支持闭包特性的，所以我们 import 的组件在 render 中可以直接调用。但是在 Vue 中，由于模板中使用的数据都必须挂在 this 上进行一次中转，所以我们 import 一个组件完了之后，还需要在 components 中再声明下，这样显然是很奇怪但又不得不这样的做法。&lt;/p&gt;
&lt;h3 id=&quot;vue-的-nexttick-的原理是什么&quot;&gt;Vue 的 nextTick 的原理是什么？&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1. 为什么需要 nextTick&lt;/strong&gt;&lt;br/&gt;      Vue 是异步修改 DOM 的并且不鼓励开发者直接接触 DOM，但有时候业务需要必须对数据更改--刷新后的 DOM 做相应的处理，这时候就可以使用 Vue.nextTick(callback)这个 api 了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 理解原理前的准备&lt;/strong&gt;&lt;br/&gt;      首先需要知道事件循环中宏任务和微任务这两个概念(这其实也是面试常考点)。请阅大佬文章--&lt;a href=&quot;https://juejin.im/post/5c947bca5188257de704121d&quot;&gt;彻底搞懂浏览器 Event-loop&lt;/a&gt;&lt;br/&gt;常见的宏任务有 script, setTimeout, setInterval, setImmediate, I/O, UI rendering&lt;br/&gt;常见的微任务有 process.nextTick(Nodejs),Promise.then(), MutationObserver;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 理解 nextTick&lt;/strong&gt;&lt;br/&gt;      而 nextTick 的原理正是 vue 通过异步队列控制 DOM 更新和 nextTick 回调函数先后执行的方式。如果大家看过这部分的源码，会发现其中做了很多 isNative()的判断，因为这里还存在兼容性优雅降级的问题。可见 Vue 开发团队的深思熟虑，对性能的良苦用心。&lt;br/&gt;如果你比较了解了前面的事件循环原理，推荐你看看这篇文章 请阅大佬文章--&lt;a href=&quot;https://mp.weixin.qq.com/s/mCcW4OYj3p3471ghMBylBw&quot;&gt;全面解析 Vue.nextTick 实现原理&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;vuex有哪几种属性&quot;&gt;Vuex有哪几种属性&lt;/h3&gt;
&lt;p&gt;有五种，分别是 &lt;code&gt;State&lt;/code&gt;、&lt;code&gt;Getter&lt;/code&gt;、&lt;code&gt;Mutation&lt;/code&gt;、&lt;code&gt;Action&lt;/code&gt;、&lt;code&gt;Module&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;vue-cli-替我们做了哪些工作&quot;&gt;vue-cli 替我们做了哪些工作？&lt;/h3&gt;
&lt;p&gt;      首先需要知道 vue-cli 是什么？它是基于 Vue.js 进行快速开发的完整系统，也可以理解成是很多 npm 包的集合。其次，vue-cli 完成的功能有哪些？&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;.vue 文件 --&amp;gt; .js 文件&lt;br/&gt;ES6 语法 --&amp;gt; ES5 语法&lt;br/&gt;Sass,Less,Stylus --&amp;gt; CSS&lt;br/&gt;对 jpg,png,font 等静态资源的处理&lt;br/&gt;热更新&lt;br/&gt;定义环境变量，区分 dev 和 production 模式&lt;br/&gt;...&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果开发者需要补充或修改默认设置，需要在 package.json 同级下新建一个 vue.config.js 文件&lt;/p&gt;
&lt;p&gt;最后送上一份大礼：&lt;a href=&quot;https://juejin.im/post/5d153267e51d4510624f9809?tdsourcetag=s_pctim_aiomsg&quot;&gt;vue 248个知识点（面试题）为你保驾护航&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 29 Jul 2019 15:12:00 +0000</pubDate>
<dc:creator>奔跑的瓜牛</dc:creator>
<og:description>Vue 双向绑定原理        mvvm 双向绑定，采用数据劫持结合发布者 订阅者模式的方式，通过 Object.definePrope</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chenwenhao/p/11258895.html</dc:identifier>
</item>
<item>
<title>NLP（十二）依存句法分析的可视化及图分析 - jclian91</title>
<link>http://www.cnblogs.com/jclian91/p/11267126.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jclian91/p/11267126.html</guid>
<description>&lt;p&gt;  依存句法分析的效果虽然没有像分词、NER的效果来的好，但也有其使用价值，在日常的工作中，我们免不了要和其打交道。笔者这几天一直在想如何分析依存句法分析的结果，一个重要的方面便是其可视化和它的图分析。&lt;br/&gt;  我们使用的NLP工具为jieba和LTP，其中jieba用于分词，LTP用于词性标注和句法分析，需要事件下载&lt;code&gt;pos.model&lt;/code&gt;和&lt;code&gt;parser.model&lt;/code&gt;文件。&lt;br/&gt;  本文使用的示例句子为：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;2018年7月26日，华为创始人任正非向5G极化码（Polar码）之父埃尔达尔教授举行颁奖仪式，表彰其对于通信领域做出的贡献。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;  首先，让我们来看一下没有可视化效果之前的句法分析结果。Python代码如下:&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# -*- coding: utf-8 -*-

import os
import jieba
from pyltp import  Postagger, Parser

sent = '2018年7月26日，华为创始人任正非向5G极化码（Polar码）之父埃尔达尔教授举行颁奖仪式，表彰其对于通信领域做出的贡献。'

jieba.add_word('Polar码')
jieba.add_word('5G极化码')
jieba.add_word('埃尔达尔')
jieba.add_word('之父')
words = list(jieba.cut(sent))

print(words)

# 词性标注
pos_model_path = os.path.join(os.path.dirname(__file__), 'data/pos.model')
postagger = Postagger()
postagger.load(pos_model_path)
postags = postagger.postag(words)

# 依存句法分析
par_model_path = os.path.join(os.path.dirname(__file__), 'data/parser.model')
parser = Parser()
parser.load(par_model_path)
arcs = parser.parse(words, postags)

rely_id = [arc.head for arc in arcs]  # 提取依存父节点id
relation = [arc.relation for arc in arcs]  # 提取依存关系
heads = ['Root' if id == 0 else words[id-1] for id in rely_id]  # 匹配依存父节点词语

for i in range(len(words)):
    print(relation[i] + '(' + words[i] + ', ' + heads[i] + ')')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;['2018', '年', '7', '月', '26', '日', '，', '华为', '创始人', '任正非', '向', '5G极化码', '（', 'Polar码', '）', '之父', '埃尔达尔', '教授', '举行', '颁奖仪式', '，', '表彰', '其', '对于', '通信', '领域', '做出', '的', '贡献', '。']
ATT(2018, 年)
ATT(年, 日)
ATT(7, 月)
ATT(月, 日)
ATT(26, 日)
ADV(日, 举行)
WP(，, 日)
ATT(华为, 创始人)
ATT(创始人, 任正非)
SBV(任正非, 举行)
ADV(向, 举行)
ATT(5G极化码, 之父)
WP(（, Polar码)
COO(Polar码, 5G极化码)
WP(）, Polar码)
ATT(之父, 埃尔达尔)
ATT(埃尔达尔, 教授)
POB(教授, 向)
HED(举行, Root)
VOB(颁奖仪式, 举行)
WP(，, 举行)
COO(表彰, 举行)
ATT(其, 贡献)
ADV(对于, 做出)
ATT(通信, 领域)
POB(领域, 对于)
ATT(做出, 贡献)
RAD(的, 做出)
VOB(贡献, 表彰)
WP(。, 举行)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们得到了该句子的依存句法分析的结果，但是其可视化效果却不好。&lt;br/&gt;  我们使用Graphviz工具来得到上述依存句法分析的可视化结果，代码（接上述代码）如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from graphviz import Digraph

g = Digraph('测试图片')

g.node(name='Root')
for word in words:
    g.node(name=word)

for i in range(len(words)):
    if relation[i] not in ['HED']:
        g.edge(words[i], heads[i], label=relation[i])
    else:
        if heads[i] == 'Root':
            g.edge(words[i], 'Root', label=relation[i])
        else:
            g.edge(heads[i], 'Root', label=relation[i])

g.view()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;得到的依存句法分析的可视化图片如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1219272/201907/1219272-20190729230714572-462011323.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这张图片中，我们有了对依存句法分析结果的直观感觉，效果也非常好，但是遗憾的是，我们并不能对上述可视化结果形成的图（Graph）进行图分析，因为Graphviz仅仅只是一个可视化工具。那么，我们该用什么样的工具来进行图分析呢？&lt;br/&gt;  答案就是NetworkX。以下是笔者对于NetworkX应用于依存句法分析的可视化和图分析的展示，其中图分析展示了两个节点之间的最短路径。示例的Python代码如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 利用networkx绘制句法分析结果
import networkx as nx
import matplotlib.pyplot as plt
from pylab import mpl

mpl.rcParams['font.sans-serif'] = ['Arial Unicode MS']  # 指定默认字体


G = nx.Graph()  # 建立无向图G

# 添加节点
for word in words:
    G.add_node(word)

G.add_node('Root')

# 添加边
for i in range(len(words)):
    G.add_edge(words[i], heads[i])

source = '5G极化码'
target1 = '任正非'
distance1 = nx.shortest_path_length(G, source=source, target=target1)
print(&quot;'%s'与'%s'在依存句法分析图中的最短距离为:  %s&quot; % (source, target1, distance1))

target2 = '埃尔达尔'
distance2 = nx.shortest_path_length(G, source=source, target=target2)
print(&quot;'%s'与'%s'在依存句法分析图中的最短距离为:  %s&quot; % (source, target2, distance2))

nx.draw(G, with_labels=True)
plt.savefig(&quot;undirected_graph.png&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;得到的可视化图片如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1219272/201907/1219272-20190729230659824-1829334361.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输出的结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;'5G极化码'与'任正非'在依存句法分析图中的最短距离为:  6
'5G极化码'与'埃尔达尔'在依存句法分析图中的最短距离为:  2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  本次到此结束，希望这篇简短的文章能够给读者带来一些启发～&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：不妨了解下笔者的微信公众号： Python爬虫与算法（微信号为：easy_web_scrape）， 欢迎大家关注~&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 29 Jul 2019 15:08:00 +0000</pubDate>
<dc:creator>jclian91</dc:creator>
<og:description>NLP（十二）依存句法分析的可视化及图分析</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jclian91/p/11267126.html</dc:identifier>
</item>
</channel>
</rss>