<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>超易懂！原来SOLID原则要这么理解！ - 陈树义</title>
<link>http://www.cnblogs.com/chanshuyi/p/how-to-understand-solid-principle.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chanshuyi/p/how-to-understand-solid-principle.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://shuyi-tech-blog.oss-cn-shenzhen.aliyuncs.com/halo_blog_system_file/image_1612833858857.png&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;说到 SOLID 原则，相信有过几年工作经验的朋友都有个大概印象，但就是不知道它具体是什么。甚至有些工作了十几年的朋友，它们对 SOLID 原则的理解也停留在表面。今天我们就来聊聊 SOLID 原则以及它们之间的关系。&lt;/p&gt;
&lt;h2 id=&quot;什么是solid原则&quot;&gt;什么是SOLID原则&lt;/h2&gt;
&lt;p&gt;SOLID 原则其实是用来指导软件设计的，它一共分为五条设计原则，分别是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;单一职责原则（SRP）&lt;/li&gt;
&lt;li&gt;开闭原则（OCP）&lt;/li&gt;
&lt;li&gt;里氏替换原则（LSP）&lt;/li&gt;
&lt;li&gt;接口隔离原则（ISP）&lt;/li&gt;
&lt;li&gt;依赖倒置原则（DIP）&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;单一职责原则（srp）&quot;&gt;单一职责原则（SRP）&lt;/h3&gt;
&lt;p&gt;单一职责原则（Single Responsibility Principle），它的定义是：应该有且仅有一个原因引起类的变更。&lt;strong&gt;简单地说：接口职责应该单一，不要承担过多的职责。&lt;/strong&gt; 用生活中肯德基的例子来举例：负责前台收银的服务员，就不要去餐厅收盘子。负责餐厅收盘子的就不要去做汉堡。&lt;/p&gt;
&lt;p&gt;单一职责适用于接口、类，同时也适用于方法。例如我们需要修改用户密码，有两种方式可以实现，一种是用「修改用户信息接口」实现修改密码，一种是新起一个接口来实现修改密码功能。在单一职责原则的指导下，一个方法只承担一个职能，所以我们应该新起一个接口来实现修改密码的功能。&lt;/p&gt;
&lt;p&gt;单一职责原则的重点在于职责的划分，很多时候并不是一成不变的，需要根据实际情况而定。单一职责能够使得类复杂性降低、类之间职责清晰、代码可读性提高、更加容易维护。但它的缺点也很明显，就是对技术人员要求高，有些时候职责难以区分。&lt;/p&gt;
&lt;p&gt;我们在设计一个类的时候，可以先从粗粒度的类开始设计，等到业务发展到一定规模，我们发现这个粗粒度的类方法和属性太多，且经常修改的时候，我们就可以对这个类进行重构了，将这个类拆分成粒度更细的类，这就是所谓的持续重构。&lt;/p&gt;
&lt;h3 id=&quot;开闭原则（ocp）&quot;&gt;开闭原则（OCP）&lt;/h3&gt;
&lt;p&gt;开闭原则（Open Closed Principle），它的定义是：一个软件实体，如类、模块和函数应该对扩展开放，对修改关闭。&lt;strong&gt;简单地说：就是当别人要修改软件功能的时候，使得他不能修改我们原有代码，只能新增代码实现软件功能修改的目的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这听着有点玄乎，我来举个例子吧。&lt;/p&gt;
&lt;p&gt;这段代码模拟的是对于水果剥皮的处理程序。如果是苹果，那么是一种拨皮方法；如果是香蕉，则是另一种剥皮方法。如果以后还需要处理其他水果，那么就会在后面加上很多 if else 语句，最终会让整个方法变得又臭又长。如果恰好这个水果中的不同品种有不同的剥皮方法，那么这里面又会有很多层嵌套。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if(type == apple){
    //deal with apple 
} else if (type == banana){
    //deal with banana
} else if (type == ......){
    //......
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看得出来，上面这样的代码并没有满足「对拓展开放，对修改封闭」的原则。每次需要新增一种水果，都可以直接在原来的代码上进行修改。久而久之，整个代码块就会变得又臭又长。&lt;/p&gt;
&lt;p&gt;如果我们对剥水果皮这件事情做一个抽象，剥苹果皮是一个具体的实现，剥香蕉皮是一个具体的实现，那么写出的代码会是这样的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public interface PeelOff {
    void peelOff();
}

public class ApplePeelOff implement PeelOff{
    void peelOff(){
                //deal with apple
    }
}

public class BananaPeelOff implement PeelOff{
    void peelOff(){
                //deal with banan
    }
}

public class PeelOffFactory{
    private Map&amp;lt;String, PeelOff&amp;gt; map = new HashMap();

    private init(){
        //init all the Class that implements PeelOff interface 
          }
}

.....

public static void main(){
    String type = &quot;apple&quot;;
    PeelOff peelOff = PeelOffFactory.getPeelOff(type);  //get ApplePeelOff Class Instance.
    peelOff.pealOff();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面这种实现方式使得别人无法修改我们的代码，为什么？&lt;/p&gt;
&lt;p&gt;因为当需要对西瓜剥皮的时候，他会发现他只能新增一个类实现 PeelOff 接口，而无法再原来的代码上修改。这样就实现了「对拓展开放，对修改封闭」的原则。&lt;/p&gt;
&lt;h3 id=&quot;里氏替换原则（lsp）&quot;&gt;里氏替换原则（LSP）&lt;/h3&gt;
&lt;p&gt;里氏替换原则（LSP）的定义是：所有引用基类的地方必须能透明地使用其子类的对象。&lt;strong&gt;简单地说：所有父类能出现的地方，子类就可以出现，并且替换了也不会出现任何错误。&lt;/strong&gt; 例如下面 Parent 类出现的地方，可以替换成 Son 类，其中 Son 是 Parent 的子类。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Parent obj = new Son();
等价于
Son son  = new Son();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样的例子在 Java 语言中是非常常见的，但其核心要点是：替换了也不会出现任何的错误。&lt;strong&gt;这就要求子类的所有相同方法，都必须遵循父类的约定，否则当父类替换为子类时就会出错。&lt;/strong&gt; 这样说可能还是有点抽象，我举个例子。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Parent{
    // 定义只能扔出空指针异常
    public void hello throw NullPointerException(){
    }
}
public class Son extends Parent{
    public void hello throw NullPointerException(){
        // 子类实现时却扔出所有异常
        throw Exception;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码中，父类对于 hello 方法的定义是只能扔出空指针异常，但子类覆盖父类的方法时，却扔出了其他异常，违背了父类的约定。那么当父类出现的地方，换成了子类，那么必然会出错。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;其实这个例子举得不是很好，因为这个在编译层面可能就有错误。但表达的意思应该是到位了。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;而这里的父类的约定，不仅仅指的是语法层面上的约定，还包括实现上的约定。有时候父类会在类注释、方法注释里做了相关约定的说明，当你要覆写父类的方法时，需要弄懂这些约定，否则可能会出现问题。例如子类违背父类声明要实现的功能。比如父类某个排序方法是从小到大来排序，你子类的方法竟然写成了从大到小来排序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;里氏替换原则 LSP 重点强调：对使用者来说，能够使用父类的地方，一定可以使用其子类，并且预期结果是一致的。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;接口隔离原则（isp）&quot;&gt;接口隔离原则（ISP）&lt;/h3&gt;
&lt;p&gt;接口隔离原则（Interface Segregation Principle）的定义是：类间的依赖关系应该建立在最小的接口上。&lt;strong&gt;简单地说：接口的内容一定要尽可能地小，能有多小就多小。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;举个例子来说，我们经常会给别人提供服务，而服务调用方可能有很多个。很多时候我们会提供一个统一的接口给不同的调用方，但有些时候调用方 A 只使用 1、2、3 这三个方法，其他方法根本不用。调用方 B 只使用 4、5 两个方法，其他都不用。接口隔离原则的意思是，你应该把 1、2、3 抽离出来作为一个接口，4、5 抽离出来作为一个接口，这样接口之间就隔离开来了。&lt;/p&gt;
&lt;p&gt;那么为什么要这么做呢？&lt;strong&gt;我想这是为了隔离变化吧！&lt;/strong&gt; 想想看，如果我们把 1、2、3、4、5 放在一起，那么当我们修改了 A 调用方才用到 的 1 方法，此时虽然 B 调用方根本没用到 1 方法，但是调用方 B 也会有发生问题的风险。而如果我们把 1、2、3 和 4、5 隔离成两个接口了，我修改 1 方法，绝对不会影响到 4、5 方法。&lt;/p&gt;
&lt;p&gt;除了改动导致的变化风险之外，其实还会有其他问题，例如：调用方 A 抱怨，为什么我只用 1、2、3 方法，你还要写上 4、5 方法，增加我的理解成本。调用方 B 同样会有这样的困惑。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在软件设计中，ISP 提倡不要将一个大而全的接口扔给使用者，而是将每个使用者关注的接口进行隔离。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;依赖倒置原则（dip）&quot;&gt;依赖倒置原则（DIP）&lt;/h3&gt;
&lt;p&gt;依赖倒置原则（Dependence Inversion Principle）的定义是：高层模块不应该依赖底层模块，两者都应该依赖其抽象。抽象不应该依赖细节，即接口或抽象类不依赖于实现类。细节应该依赖抽象，即实现类不应该依赖于接口或抽象类。&lt;strong&gt;简单地说，就是说我们应该面向接口编程。通过抽象成接口，使各个类的实现彼此独立，实现类之间的松耦合。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果我们每个人都能通过接口编程，那么我们只需要约定好接口定义，我们就可以很好地合作了。&lt;strong&gt;软件设计的 DIP 提倡使用者依赖一个抽象的服务接口，而不是去依赖一个具体的服务执行者，从依赖具体实现转向到依赖抽象接口，倒置过来。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;solid-原则的本质&quot;&gt;SOLID 原则的本质&lt;/h2&gt;
&lt;p&gt;我们总算把 SOLID 原则中的五个原则说完了。&lt;strong&gt;但说了这么一通，好像是懂了，但是好像什么都没记住。&lt;/strong&gt; 那么我们就来盘一盘他们之间的关系。ThoughtWorks 上有一篇文章说得挺不错，它说：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;单一职责是所有设计原则的基础，开闭原则是设计的终极目标。&lt;/li&gt;
&lt;li&gt;里氏替换原则强调的是子类替换父类后程序运行时的正确性，它用来帮助实现开闭原则。&lt;/li&gt;
&lt;li&gt;而接口隔离原则用来帮助实现里氏替换原则，同时它也体现了单一职责。&lt;/li&gt;
&lt;li&gt;依赖倒置原则是过程式编程与面向对象编程的分水岭，同时它也被用来指导接口隔离原则。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://shuyi-tech-blog.oss-cn-shenzhen.aliyuncs.com/halo_blog_system_file/16108948449641.jpg&quot; alt=&quot;图片l来自ThoughtWorks&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简单地说：依赖倒置原则告诉我们要面向接口编程。当我们面向接口编程之后，接口隔离原则和单一职责原则又告诉我们要注意职责的划分，不要什么东西都塞在一起。当我们职责捋得差不多的时候，里氏替换原则告诉我们在使用继承的时候，要注意遵守父类的约定。而上面说的这四个原则，它们的最终目标都是为了实现开闭原则。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
</description>
<pubDate>Wed, 10 Feb 2021 00:29:00 +0000</pubDate>
<dc:creator>陈树义</dc:creator>
<og:description>说到 SOLID 原则，相信有过几年工作经验的朋友都有个大概印象，但就是不知道它具体是什么。甚至有些工作了十几年的朋友，它们对 SOLID 原则的理解也停留在表面。今天我们就来聊聊 SOLID 原则以</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chanshuyi/p/how-to-understand-solid-principle.html</dc:identifier>
</item>
<item>
<title>设计模式（二十一）——解释器模式(Spring 框架中SpelExpressionParser源码分析） - 十四lin</title>
<link>http://www.cnblogs.com/linzm14/p/14393523.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/linzm14/p/14393523.html</guid>
<description>&lt;h2&gt;1 四则运算问题&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;通过解释器模式来实现四则运算，如计算&lt;/span&gt; a+b-c 的值，具体要求&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;1) &lt;span&gt;先输入表达式的形式，比如&lt;/span&gt; a+b+c-d+e,  要求表达式的字母不能重复&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;2) &lt;span&gt;在分别输入&lt;/span&gt; a ,b, c, d, e 的值&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;3) 最后求出结果：如图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2257481/202102/2257481-20210209170559849-897966774.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;Section0&quot; readability=&quot;22&quot;&gt;
&lt;h2&gt;2 传统方案解决四则运算问题分析&lt;/h2&gt;
&lt;p class=&quot;16&quot;&gt;1) 编写一个方法，接收表达式的形式，然后根据用户输入的数值进行解析，得到结果&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;2) &lt;span&gt;问题分析：如果加入新的运算符，比如&lt;/span&gt; * / ( &lt;span&gt;等等，不利于扩展，另外让一个方法来解析会造成程序结构混乱，&lt;/span&gt; &lt;span&gt;不够清晰&lt;/span&gt;.&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;3) 解决方案：可以考虑使用解释器模式&lt;span&gt;，&lt;/span&gt;  &lt;span&gt;即：&lt;/span&gt;  &lt;span&gt;表达式&lt;/span&gt;  -&amp;gt; 解释器(可以有多种) -&amp;gt; 结果&lt;/p&gt;
&lt;h2&gt;3 解释器模式基本介绍&lt;/h2&gt;
&lt;p&gt;基本介绍&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;1) 在编译原理中，一个算术表达式通过词法分析器形成词法单元，而后这些词法单元再通过语法分析器构建语法分析树，最终形成一颗抽象的语法分析树。这里的词法分析器和语法分析器都可以看做是解释器&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;2) 解释器模式（Interpreter Pattern）：是指给定一个语言&lt;strong&gt;(&lt;/strong&gt;表达式&lt;strong&gt;)&lt;/strong&gt;&lt;span&gt;，定义它的文法的一种表示，并定义一个解释器，&lt;/span&gt; &lt;span&gt;使用该解释器来解释语言中的句子&lt;/span&gt;&lt;strong&gt;(&lt;/strong&gt;表达式)&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;3) 应用场景&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;应用可以将一个需要解释执行的语言中的句子表示为一个抽象语法树&lt;/li&gt;
&lt;li&gt;一些重复出现的问题可以用一种简单的语言来表达&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;一个简单语法需要解释的场景&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;16&quot;&gt;4) 这样的例子还有，比如编译器、运算表达式计算、正则表达式、机器人等&lt;/p&gt;
&lt;h2&gt;4 解释器模式的原理类图&lt;/h2&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/2257481/202102/2257481-20210209170806611-318960108.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;Section0&quot; readability=&quot;22&quot;&gt;
&lt;ul&gt;&lt;li&gt;对原理类图的说明-即(解释器模式的角色及职责)&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;15&quot;&gt;1) Context: 是环境角色,含有解释器之外的全局信息.&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;2) AbstractExpression: &lt;span&gt;抽象表达式，&lt;/span&gt; &lt;span&gt;声明一个抽象的解释操作&lt;/span&gt;,这个方法为抽象语法树中所有的节点所共享&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;3) TerminalExpression: 为终结符表达式, 实现与文法中的终结符相关的解释操作&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;4) NonTermialExpression: 为非终结符表达式，为文法中的非终结符实现解释操作.&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;5) &lt;span&gt;说明：&lt;/span&gt; &lt;span&gt;输入&lt;/span&gt; Context he TerminalExpression  &lt;span&gt;信息通过&lt;/span&gt; Client 输入即可&lt;/p&gt;
&lt;h2&gt;5 解释器模式来实现四则&lt;/h2&gt;
&lt;p class=&quot;15&quot;&gt;1) 应用实例要求&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过解释器模式来实现四则运算，&lt;/span&gt; &lt;span&gt;如计算&lt;/span&gt; a+b-c 的值&lt;/p&gt;
&lt;/div&gt;
&lt;p class=&quot;15&quot;&gt;2) 思路分析和图解(类图)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2257481/202102/2257481-20210209170457177-881031006.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3)代码实现&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2257481/202102/2257481-20210209170913138-1489343012.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;



&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.lin.interpret;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.HashMap;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 抽象类表达式，通过 HashMap 键值对, 可以获取到变量的值
     *
     * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Administrator
     *
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Expression {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; a + b - c
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 解释公式和数值, key  就是公式(表达式) 参数[a,b,c], value 就是就是具体值
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; HashMap {a=10, b=20}&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; interpreter(HashMap&amp;lt;String, Integer&amp;gt;&lt;span&gt; var);
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.lin.interpret;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.HashMap;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 抽象运算符号解析器 这里，每个运算符号，都只和自己左右两个数字有关系， 但左右两个数字有可能也是一个解析的结果，无论何种类型，都是 Expression
     * 类的实现类
     *
     * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Administrator
     *
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; SymbolExpression &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Expression {

    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; Expression left;
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; Expression right;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; SymbolExpression(Expression left, Expression right) {

        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.left =&lt;span&gt; left;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.right =&lt;span&gt; right;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;因为 SymbolExpression  是让其子类来实现，因此 interpreter 是一个默认实现&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; interpreter(HashMap&amp;lt;String, Integer&amp;gt;&lt;span&gt; var) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.lin.interpret;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.HashMap;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; SubExpression &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; SymbolExpression {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; SubExpression(Expression left, Expression right) {

        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(left, right);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;求出 left 和 right  表达式相减后的结果&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; interpreter(HashMap&amp;lt;String, Integer&amp;gt;&lt;span&gt; var) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;.left.interpreter(var) - &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.right.interpreter(var);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.lin.interpret;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.HashMap;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 变量的解释器
     * 
     * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Administrator
     *
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; VarExpression &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Expression {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; String key; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; key=a,key=b,key=c&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; VarExpression(String key) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.key =&lt;span&gt; key;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; var 就是{a=10, b=20}
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; interpreter 根据 变量名称，返回对应值&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; interpreter(HashMap&amp;lt;String, Integer&amp;gt;&lt;span&gt; var) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; var.get(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.key);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.lin.interpret;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.HashMap;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Stack;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Calculator {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义表达式&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Expression expression;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 构造函数传参，并解析&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt; Calculator(String expStr) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; expStr = a+b
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 安排运算先后顺序&lt;/span&gt;
        Stack&amp;lt;Expression&amp;gt; stack = &lt;span&gt;new&lt;/span&gt; Stack&amp;lt;&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 表达式拆分成字符数组&lt;/span&gt;
        &lt;span&gt;char&lt;/span&gt;[] charArray = expStr.toCharArray();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [a, +, b]&lt;/span&gt;
&lt;span&gt;
        Expression left &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        Expression right &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 遍历我们的字符数组， 即遍历 [a, +, b]
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 针对不同的情况，做处理&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; charArray.length; i++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (charArray[i]) {
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; '+': &lt;span&gt;//
&lt;/span&gt;                left = stack.pop();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从 stack 取 出 left =&amp;gt; &quot;a&quot;&lt;/span&gt;
                right = &lt;span&gt;new&lt;/span&gt; VarExpression(String.valueOf(charArray[++i]));&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 取出右表达式 &quot;b&quot;&lt;/span&gt;
                stack.push(&lt;span&gt;new&lt;/span&gt; AddExpression(left, right));&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 然后根据得到 left 和 right 构建 AddExpresson 加入stack&lt;/span&gt;
                &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; '-': &lt;span&gt;//
&lt;/span&gt;                left =&lt;span&gt; stack.pop();
                right &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; VarExpression(String.valueOf(charArray[++&lt;span&gt;i]));
                stack.push(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SubExpression(left, right));
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果是一个 Var 就创建要给 VarExpression 对象，并 push 到 stack&lt;/span&gt;
                stack.push(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; VarExpression(String.valueOf(charArray[i])));

                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当遍历完整个 charArray  数组后，stack 就得到最后 Expression &lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.expression =&lt;span&gt; stack.pop();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; run(HashMap&amp;lt;String, Integer&amp;gt;&lt;span&gt; var) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最后将表达式 a+b 和 var = {a=10,b=20}
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;然后传递给 expression 的 interpreter 进行解释执行&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.expression.interpreter(var);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.lin.interpret;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.HashMap;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 加法解释器
     * 
     * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Administrator
     *
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; AddExpression &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; SymbolExpression {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; AddExpression(Expression left, Expression right) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(left, right);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;处理相加
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;var 仍然是 {a=10,b=20}..
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;一会我们 debug  源码,就 ok&lt;/span&gt;
    
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; interpreter(HashMap&amp;lt;String, Integer&amp;gt;&lt;span&gt; var) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;super.left.interpreter(var) ： 返回 left 表达式对应的值 a = 10
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;super.right.interpreter(var): 返回 right 表达式对应值 b = 20&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;.left.interpreter(var) + &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.right.interpreter(var);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.lin.interpret;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.BufferedReader;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.InputStreamReader;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.HashMap;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Client {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
        String expStr &lt;/span&gt;= getExpStr(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; a+b&lt;/span&gt;
        HashMap&amp;lt;String, Integer&amp;gt; var = getValue(expStr);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; var {a=10, b=20}&lt;/span&gt;
&lt;span&gt;
        Calculator calculator &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Calculator(expStr);
        System.out.println(&lt;/span&gt;&quot;运算结果：&quot; + expStr + &quot;=&quot; +&lt;span&gt; calculator.run(var));
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获得表达式&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String getExpStr() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
        System.out.print(&lt;/span&gt;&quot;请输入表达式：&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (&lt;span&gt;new&lt;/span&gt; BufferedReader(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; InputStreamReader(System.in))).readLine();
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获得值映射&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; HashMap&amp;lt;String, Integer&amp;gt; getValue(String expStr) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
        HashMap&lt;/span&gt;&amp;lt;String, Integer&amp;gt; map = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;&lt;span&gt;();

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;char&lt;/span&gt;&lt;span&gt; ch : expStr.toCharArray()) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ch != '+' &amp;amp;&amp;amp; ch != '-'&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;map.containsKey(String.valueOf(ch))) {
                    System.out.print(&lt;/span&gt;&quot;请输入&quot; + String.valueOf(ch) + &quot;的值：&quot;&lt;span&gt;);
                    String in &lt;/span&gt;= (&lt;span&gt;new&lt;/span&gt; BufferedReader(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; InputStreamReader(System.in))).readLine();
                    map.put(String.valueOf(ch), Integer.valueOf(in));
                }
            }
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; map;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;6 &lt;span&gt;解释器模式在&lt;/span&gt; Spring 框架应用的源码剖析&lt;/h2&gt;
&lt;p class=&quot;16&quot;&gt;1) Spring &lt;span&gt;框架中&lt;/span&gt; SpelExpressionParser 就使用到解释器模式&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;2) 代码分析&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2257481/202102/2257481-20210209171208769-2020548437.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 3)说明&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2257481/202102/2257481-20210209171229358-1767252639.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;7 解释器模式的注意事项和细节&lt;/h2&gt;
&lt;p class=&quot;15&quot;&gt;1) 当有一个语言需要解释执行，可将该语言中的句子表示为一个抽象语法树，就可以考虑使用解释器模式，让程序具有良好的扩展性&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;2) 应用场景：编译器、运算表达式计算、正则表达式、机器人等&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;3) 使用解释器可能带来的问题：解释器模式会引起类膨胀、解释器模式采用递归调用方法，将会导致调试非常复杂、效率可能降低.&lt;/p&gt;

&lt;p&gt;仅供参考，有错误还请指出！&lt;/p&gt;
&lt;p&gt;有什么想法，评论区留言，互相指教指教。&lt;/p&gt;
&lt;p&gt;觉得不错的可以点一下右边的推荐哟！&lt;/p&gt;
</description>
<pubDate>Wed, 10 Feb 2021 00:23:00 +0000</pubDate>
<dc:creator>十四lin</dc:creator>
<og:description>1&amp;#160;四则运算问题 通过解释器模式来实现四则运算，如计算 a+b-c 的值，具体要求 1)&amp;#160;先输入表达式的形式，比如 a+b+c-d+e, 要求表达式的字母不能重复 2)&amp;#160;</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/linzm14/p/14393523.html</dc:identifier>
</item>
<item>
<title>H5网页应用打包安卓App (全网最详细教程) - Khazix</title>
<link>http://www.cnblogs.com/demonxian3/p/14394907.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/demonxian3/p/14394907.html</guid>
<description>&lt;p&gt;如果你是一名 Web开发者，想把自己开发的页面打包编译成 App在手机运行，但是你对 Java 和 Android 一窍不通，&lt;/p&gt;
&lt;p&gt;那么本文章将指引你如何将Web项目走向安卓平台，去除任何浮躁，跟着本文操作起来吧&lt;/p&gt;



&lt;h3 id=&quot;项目打包&quot;&gt;项目打包&lt;/h3&gt;
&lt;p&gt;将 Vue 或者 React 使用的webpack把代码项目进行打包&lt;br/&gt;&lt;span class=&quot;red&quot;&gt;如果没玩过 MVVM框架随便什么hello world的html项目也可以，不一定非要打包只要网页能打开就行，&lt;/span&gt;&lt;br/&gt;这里以Vue+Webpack为例：打包之后生成 index.html 和 dist目录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006989/202102/1006989-20210207232304330-1025756456.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我这里的项目浏览器打开之后是移动端的html5页面，如下图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006989/202102/1006989-20210207232633433-219475762.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意这里只是页面，不是APP，移动端页面，接下来的任务就是要把这个html开发的页面打包成安卓App&lt;/p&gt;
&lt;h3 id=&quot;hbuilderx打包&quot;&gt;HbuilderX打包&lt;/h3&gt;
&lt;p&gt;打包好之后，打开 HbuilderX, 创建5+App项目&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006989/202102/1006989-20210207233049450-1580116046.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;创建后，将左侧默认文件除了 manifest其他都删掉，然后把刚刚打包好的 （我的是index.html 和 build）放到项目目录下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006989/202102/1006989-20210207233220278-1332519532.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;点击 manifest.json 进行配置&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006989/202102/1006989-20210207233417925-552858332.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;appid&quot;&gt;Appid&lt;/h3&gt;
&lt;p&gt;Appid需要去Dcloud申请一下，注册一个账号就行，申请地址如下，免费的&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://dev.dcloud.net.cn/app/index?type=0&quot; target=&quot;_blank&quot;&gt;https://dev.dcloud.net.cn/app/index?type=0&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;应用是否全屏&quot;&gt;应用是否全屏&lt;/h3&gt;
&lt;p&gt;这里的全屏是类似玩王者荣耀那样，直接占据整个屏幕，电源时间状态栏都没有的那种，这里我不勾选，&lt;/p&gt;
&lt;p&gt;接下来配置沉浸式体验，就是顶部时间电源状态栏弄成透明的那种，看起来会比较舒服&lt;/p&gt;
&lt;h3 id=&quot;图标配置&quot;&gt;图标配置&lt;/h3&gt;
&lt;p&gt;图标配置可以自动生成，也可以先不生成，后面我们可以用IDE创建自定义图标&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006989/202102/1006989-20210207233809439-337210910.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;启动配置&quot;&gt;启动配置&lt;/h3&gt;
&lt;p&gt;配置如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006989/202102/1006989-20210207233856078-1291149167.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;模块配置&quot;&gt;模块配置&lt;/h3&gt;
&lt;p&gt;我们这里简单点，全部模块都不用，下来大家可以自己尝试勾选玩一下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006989/202102/1006989-20210207233916839-121421103.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;权限配置&quot;&gt;权限配置&lt;/h3&gt;
&lt;p&gt;按照默认的选项来即可&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006989/202102/1006989-20210207234003737-1722679871.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;app其他设置&quot;&gt;App其他设置&lt;/h3&gt;
&lt;p&gt;按照默认来&lt;/p&gt;
&lt;h3 id=&quot;源码视图这里添加一个沉浸式体验全屏&quot;&gt;源码视图这里添加一个沉浸式体验全屏&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006989/202102/1006989-20210207234112795-502854945.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这里我们首先体验一下云打包App，选择云打包&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006989/202102/1006989-20210207234212957-1207803489.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;配置参考如下图，取消广告，勾选公测证书&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006989/202102/1006989-20210207234423542-1583852935.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后代码会上传到云进行打包，等待一会会跳出下载App地址&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006989/202102/1006989-20210208230914333-1163429905.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下载apk传到手机安装App就可以在手机上以App的方式运行我们写的web界面了&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006989/202102/1006989-20210208231031766-1774911916.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;虽然在线打包已经满足了我们将web应用搬运到安卓的需求，但是这里是需要上传代码，复杂一点的功能还要实名认证&lt;br/&gt;另外每次云打包都要等待一段时间后，才会返回只能下载5次的链接，非常不方便我们进行开发调试，&lt;br/&gt;所以下面演示如何使用 Android Studio 自行离线打包。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先我们在 HbuilderX 上把我们的代码打包成 App需要的src源码资源&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006989/202102/1006989-20210208230155669-1125816148.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;控制台会输出打包后资源的目录，后续的步骤会用到，这里先放着&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006989/202102/1006989-20210208230225771-558277570.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;打开下载好的 Andriod studio，这里不用另外安装java环境，Android Studio自带jdk的&lt;/p&gt;
&lt;p&gt;这里勾选即可&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006989/202102/1006989-20210208000115446-639247910.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;选择安装路径&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006989/202102/1006989-20210208000130051-1729292798.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006989/202102/1006989-20210208000142655-392341698.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;安装好后打开，选择不导入&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006989/202008/1006989-20200814142548394-822564572.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;这里点击 cancel&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006989/202008/1006989-20200814142639312-1598470511.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;此处选择自定义&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006989/202008/1006989-20200814142711026-1518243016.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;选择主题&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006989/202008/1006989-20200814142841537-1864826630.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;勾选AVD 以及选择SDK安装位置&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006989/202008/1006989-20200814142918460-503653550.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;后面一直点next或finish，点击 SDK Manager&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006989/202008/1006989-20200814143043328-198244511.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;选择 22版本，点击 apply 和 ok&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006989/202008/1006989-20200814143137174-226022806.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;回到刚刚的界面新建项目,选择空项目&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006989/202102/1006989-20210208222358769-218382581.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下图这里&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Package Name包名自己命名，一般都是颠倒域名作为，此处包名可以随便起&lt;/li&gt;
&lt;li&gt;Language选择Java&lt;/li&gt;
&lt;li&gt;Minimum API level最小支持的API我选的是20，下面说明94%的手机都支持这个API，&lt;/li&gt;
&lt;li&gt;其他默认点击Finish&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006989/202102/1006989-20210208222430608-1411061417.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;点击顶部工具栏右侧手机图标，如下图，创建AVD虚拟手机，也就是手机模拟器&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006989/202102/1006989-20210208222733032-784557564.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击创建AVD&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006989/202102/1006989-20210208222845264-686951258.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里屏幕尺寸可以随便选，也可以自定义&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006989/202102/1006989-20210208222902086-1393730240.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;模拟器安卓系统我选的是pie，可以点击download下载或直接点下一步也会下载&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006989/202102/1006989-20210208223011921-1534277181.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下载好后，这里是默认&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006989/202102/1006989-20210208223028325-105269774.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后点击Finish完成，然后点击下图得位置，可以尝试运行一下刚创建的空项目app&lt;/p&gt;
&lt;p&gt;点击工具栏手机运行按钮，顺利的话会弹出 Hello world 的App如下所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006989/202102/1006989-20210208223454564-249358614.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以看到上图蓝色框框有报错信息，这个应该是声音方面的报错，不影响我们使用，直接无视&lt;/p&gt;
&lt;p&gt;如果这里运行不起来，可以参考文档底下的踩坑问题解决方案中是否有你遇到的问题&lt;/p&gt;

&lt;h3 id=&quot;1-将本文前面准备材料里的sdk下载后的目录-android-sdk30780630_20210123sdklibs-下找到这两个文件&quot;&gt;1. 将本文前面准备材料里的SDK下载后的目录 Android-SDK@3.0.7.80630_20210123\SDK\libs 下找到这两个文件&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006989/202102/1006989-20210208232001786-1887721970.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;lib.5plus.base-release.aar&lt;/li&gt;
&lt;li&gt;android-gif-drawable-release@1.2.17.aar&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;2-然后再-android-sdk30780630_20210123sdkassetsdata-下复制下面三个文件，为方便操作和上面两个文件创建一个新的目录放在一起&quot;&gt;2. 然后再 Android-SDK@3.0.7.80630_20210123\SDK\assets\data 下复制下面三个文件，为方便操作和上面两个文件创建一个新的目录放在一起&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;dcloud_control.xml&lt;/li&gt;
&lt;li&gt;dcloud_error.html&lt;/li&gt;
&lt;li&gt;dcloud_properties.xml&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;3-将ide的文件目录试图默认是-android视图-切换成-project试图&quot;&gt;3. 将IDE的文件目录试图默认是 Android视图 切换成 Project试图&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006989/202102/1006989-20210208231743301-1328738395.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;4-然后将刚刚复制的两个sdk文件粘贴到-applibs下面&quot;&gt;4. 然后将刚刚复制的两个sdk文件粘贴到 &lt;code&gt;app/libs&lt;/code&gt;下面&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006989/202102/1006989-20210208231943053-614916642.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;5-编辑-appbuildgradle，引入lib文件&quot;&gt;5. 编辑 app/build.gradle，引入lib文件&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;implementation fileTree(dir: 'libs', include: ['*.aar', '*.jar'], exclude: [])
implementation 'com.github.bumptech.glide:glide:4.9.0' // 基座依赖
implementation 'com.android.support:support-v4:28.0.0'
implementation 'com.alibaba:fastjson:1.1.46.android'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;添加代码如下图所示，第一行 exclude可改可不改&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006989/202102/1006989-20210208232159256-1923131466.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接着 app/build.gradle 顶部，&lt;/p&gt;
&lt;p&gt;将 &lt;code&gt;compileSdkVersion&lt;/code&gt; 和 &lt;code&gt;targetSdkVersion&lt;/code&gt; 值改成28，&lt;br/&gt;将 &lt;code&gt;minSdkVersion&lt;/code&gt; 改成 22&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;applicationId为创建时的包名，compileSdkVersion为编译版本，&lt;br/&gt;minSdkVersion为兼容最小的版本号，targetSdkVersion为目标版本，&lt;br/&gt;有兴趣的可以百度一下三者之间的区别和联系。注意，&lt;br/&gt;官方文档中标注“App离线SDK minSdkVersion最低支持19，小于19在部分4.4以下机型上将无法正常使用。”&lt;br/&gt;versionCode需要设定一个数值，一般为1，&lt;br/&gt;每次更新版本时versionCode的值都要比前一个设置的值大，&lt;br/&gt;否则无法正常安装，versionName一般填写主版本号次版本号和修正号，&lt;br/&gt;如图中的“1.0”为最初版本号，其余的可以自行查阅。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;修改后点击右上角 &lt;code&gt;sync now&lt;/code&gt;进行同步&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006989/202102/1006989-20210208232555686-1590291292.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;顺利的话这里应该可以同步成功&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006989/202102/1006989-20210208232631250-44252238.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;6-在-appsrcmain-目录下创建-assetsdata-两层目录，把刚刚准备的xml和html复制到新目录下&quot;&gt;6. 在 app/src/main 目录下创建 assets/data 两层目录，把刚刚准备的xml和html复制到新目录下&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006989/202102/1006989-20210209232926860-2042316547.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;7-在-appsrcmainassets-目录下创建-apps-目录，把第5步打包的离线资源放入底下&quot;&gt;7. 在 app/src/main/assets 目录下创建 apps 目录，把第5步打包的离线资源放入底下&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006989/202102/1006989-20210208233203977-1486002444.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意，复制离线打包资源时，如下图中在上上级resources位置中，整个目录一起复制过去&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006989/202102/1006989-20210208233429339-760989036.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;复制后，如下图所示IDE会自动折叠目录变成一个域名&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006989/202102/1006989-20210209233331372-609064813.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在 app/src/main/res/values 下打开 string.xml&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006989/202102/1006989-20210208233955701-395797241.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里的应用名称，与刚刚引入本地打包资源的里的manifest.json文件进行比较&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006989/202102/1006989-20210208234109447-1227697429.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我这里两图大小写不一致，将 string.xml 改成小写，确保两个文件名称一致&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006989/202102/1006989-20210208234215713-731396924.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在 app/src/main/assets/data 下编辑 dcloud_control.xml ，确保xml的appid 与 manifest.json的appid一致&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006989/202102/1006989-20210209233844893-1008366765.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006989/202102/1006989-20210209233859246-398208640.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我这里对比一致无需更改，如果不一样的话，以manfest.json中的appid为准&lt;/p&gt;
&lt;p&gt;在 app/src/main 下编辑 AndroidManifest.xml 删除&lt;code&gt;MainActivity&lt;/code&gt;代码片段&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006989/202102/1006989-20210209231958381-638216773.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后添加以下代码到刚刚删除的位置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  &amp;lt;activity
      android:name=&quot;io.dcloud.PandoraEntry&quot;
      android:configChanges=&quot;orientation|keyboardHidden|keyboard|navigation&quot;
      android:label=&quot;@string/app_name&quot;
      android:launchMode=&quot;singleTask&quot;
      android:hardwareAccelerated=&quot;true&quot;
      android:theme=&quot;@style/TranslucentTheme&quot;
      android:screenOrientation=&quot;user&quot;
      android:windowSoftInputMode=&quot;adjustResize&quot; &amp;gt;
      &amp;lt;intent-filter&amp;gt;
          &amp;lt;action android:name=&quot;android.intent.action.MAIN&quot; /&amp;gt;
          &amp;lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&amp;gt;
      &amp;lt;/intent-filter&amp;gt;
  &amp;lt;/activity&amp;gt;
  &amp;lt;activity
      android:name=&quot;io.dcloud.PandoraEntryActivity&quot;
      android:launchMode=&quot;singleTask&quot;
      android:configChanges=&quot;orientation|keyboardHidden|screenSize|mcc|mnc|fontScale|keyboard&quot;
      android:hardwareAccelerated=&quot;true&quot;
      android:permission=&quot;com.miui.securitycenter.permission.AppPermissionsEditor&quot;
      android:screenOrientation=&quot;user&quot;
      android:theme=&quot;@style/DCloudTheme&quot;
      android:windowSoftInputMode=&quot;adjustResize&quot;&amp;gt;
      &amp;lt;intent-filter&amp;gt;
          &amp;lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&amp;gt;
          &amp;lt;category android:name=&quot;android.intent.category.BROWSABLE&quot; /&amp;gt;
          &amp;lt;action android:name=&quot;android.intent.action.VIEW&quot; /&amp;gt;
          &amp;lt;data android:scheme=&quot;h56131bcf&quot; /&amp;gt;
      &amp;lt;/intent-filter&amp;gt;
  &amp;lt;/activity&amp;gt;
  &amp;lt;!--provider节点必须添加--&amp;gt;
  &amp;lt;provider
      android:name=&quot;io.dcloud.common.util.DCloud_FileProvider&quot;
      android:authorities=&quot;${apk.applicationId}.dc.fileprovider&quot;
      android:exported=&quot;false&quot;
      android:grantUriPermissions=&quot;true&quot;&amp;gt;
      &amp;lt;meta-data
          android:name=&quot;android.support.FILE_PROVIDER_PATHS&quot;
          android:resource=&quot;@xml/dcloud_file_provider&quot; /&amp;gt;
  &amp;lt;/provider&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006989/202102/1006989-20210209232118721-890068324.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后将 provider代码段中的 ${apk.applicationId} 替换成包名，如果不知道包名是什么，可以看离线资源复制之后自动折叠的域名，如下图位置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006989/202102/1006989-20210209233637134-2105084603.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;如下右键新增资源图标&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006989/202102/1006989-20210209234039028-473745970.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里可以根据自己需要设置图标&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006989/202102/1006989-20210209234147922-2114606501.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后点击 next 和finish&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006989/202102/1006989-20210209234204922-665556619.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;到这里基本完成了，可以尝试模拟器上运行app&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006989/202102/1006989-20210209234319981-1652768168.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果顺利的话，此时弹出手机自动安装app后，就可以看到我们的web项目以app方式运行了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006989/202102/1006989-20210209235148866-1107032031.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006989/202102/1006989-20210209235310168-808670503.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然如果不顺利的话，可以参考下面的问答，或给博主留言&lt;/p&gt;

&lt;p&gt;在菜单栏中选择Build，点击Generate Signed Bundle /APK...项，进入打包页面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006989/202102/1006989-20210209235452469-1556548812.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择apk，点击next&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006989/202102/1006989-20210209235535360-467869203.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;打包需要签名认证，点击Create new...创建。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006989/202102/1006989-20210209235554232-1690898209.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如图，第一行创建自定义jks文件，并确定路径我把它设置为ips（这种其实是不符合jks格式的，&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006989/202102/1006989-20210209235735751-187694813.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后是设置密码&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006989/202102/1006989-20210209235959379-1242380322.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后生成时可能会有警告，点击OK即可，一般为&lt;em&gt;-&lt;/em&gt;-*jks，平时还是要多注意规范）。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006989/202102/1006989-20210210000051282-1746438042.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;跳转到签名界面，因为都帮我们填好了，所以点击Next即可。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006989/202102/1006989-20210210000101626-1367931488.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择release完成&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006989/202102/1006989-20210210000137340-907061445.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;直接下图编译即可&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006989/202102/1006989-20210210000311738-1280348717.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;完成后显示apk路径&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006989/202102/1006989-20210210000705874-1048936381.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006989/202102/1006989-20210210000720802-405187341.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h3 id=&quot;1-cpu没有开启虚拟化技术导致无法运行模拟器&quot;&gt;1. CPU没有开启虚拟化技术导致无法运行模拟器&lt;/h3&gt;
&lt;p&gt;在任务管理器中可以查看CPU是否开启虚拟化技术&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006989/202102/1006989-20210208223919567-363841224.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果没有开启，需要在BIOS中开启，这个可以百度一下，不同电脑启动虚拟化方式不一样&lt;/p&gt;
&lt;h3 id=&quot;2-cpu是amd的，运行手机模拟器时弹框推荐安装-haxm-一款intel硬件加速器&quot;&gt;2. CPU是AMD的，运行手机模拟器时弹框推荐安装 HAXM 一款Intel硬件加速器&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006989/202102/1006989-20210209234522755-1066951024.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击同意下载又无法安装，如下图&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006989/202102/1006989-20210208223134970-1750847694.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击取消直接没反应，运行不了模拟器了&lt;/p&gt;
&lt;p&gt;解决步骤，每一步都是必要步骤：&lt;/p&gt;
&lt;ol readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;使用 AMD替代的加速器，取消 HAXM ，点击下图工具栏这个管理包&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006989/202102/1006989-20210208224457950-1719576866.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006989/202102/1006989-20210208224546144-1488530935.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;确保虚拟化技术有打开&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006989/202102/1006989-20210208224608960-19727844.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在启用或关闭windows功能里，取消勾选红框这两项目&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006989/202102/1006989-20210208225127794-1565772710.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;进入自己SDK目录下的extras\google\Android_Emulator_Hypervisor_Driver的文件夹下，运行silent_install.bat&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1006989/202102/1006989-20210208225305191-1745091605.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果执行结果返回是：STATE: 4 RUNNING，说明安装成功。就可以正常使用AS的模拟器了。&lt;/p&gt;

</description>
<pubDate>Tue, 09 Feb 2021 23:22:00 +0000</pubDate>
<dc:creator>Khazix</dc:creator>
<og:description>如果你是一名 Web开发者，想把自己开发的页面打包编译成 App在手机运行，但是你对 Java 和 Android 一窍不通， 那么本文章将指引你如何将Web项目走向安卓平台，去除任何浮躁，跟着本文操</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/demonxian3/p/14394907.html</dc:identifier>
</item>
<item>
<title>Python基础--核心数据类型 - 1763392456</title>
<link>http://www.cnblogs.com/cnoneblog/p/14394887.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cnoneblog/p/14394887.html</guid>
<description>&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Number 数字（整数，浮点数，复数，布尔型数）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;String 字符串&lt;/li&gt;
&lt;li&gt;List 列表&lt;/li&gt;
&lt;li&gt;Tuple 元组&lt;/li&gt;
&lt;li&gt;Dictionary 字典&lt;/li&gt;
&lt;li&gt;Set 集合&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;1. 整数（整型数）int&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;整数是指不带小数部分的数（自然数，0，负数自然数），如：-5，100，0，99999999999(python 的整数可以很大)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;整型数的字面值表示方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;十进制的表示方式：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;10, 200, -1, 9999999999999999
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;二进制的表示方式（以0b开头，后跟0-1）&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;用 bin(x) 函数将其他进制数转为二进制字符串表示&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;prism language-python&quot;&gt;&lt;span class=&quot;token number&quot;&gt;0b111

&lt;span class=&quot;token number&quot;&gt;7
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;prism language-python&quot;&gt;&lt;span class=&quot;token number&quot;&gt;0b11111000101101010111

&lt;span class=&quot;token number&quot;&gt;1018711
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;prism language-python&quot;&gt;&lt;span class=&quot;token builtin&quot;&gt;bin&lt;span class=&quot;token punctuation&quot;&gt;(&lt;span class=&quot;token number&quot;&gt;10&lt;span class=&quot;token punctuation&quot;&gt;)

&lt;span class=&quot;token string&quot;&gt;'0b1010'
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;八进制的表示方式（以0o开头，后跟0-7）&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;用 oct(x) 函数将其他进制数转换为八进制字符串表示&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;prism language-python&quot;&gt;&lt;span class=&quot;token number&quot;&gt;0o11

&lt;span class=&quot;token number&quot;&gt;9
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;prism language-python&quot;&gt;&lt;span class=&quot;token number&quot;&gt;0o177

&lt;span class=&quot;token number&quot;&gt;127
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;prism language-python&quot;&gt;&lt;span class=&quot;token builtin&quot;&gt;oct&lt;span class=&quot;token punctuation&quot;&gt;(&lt;span class=&quot;token number&quot;&gt;0b1111&lt;span class=&quot;token punctuation&quot;&gt;)

&lt;span class=&quot;token string&quot;&gt;'0o17'
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;十六进制的表示方式（以0x开头，后跟0-9&amp;amp;A-F||a-f）&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;用 hex(x) 函数将其他进制数转换为十六进制字符串表示&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;prism language-python&quot;&gt;&lt;span class=&quot;token number&quot;&gt;0x11

&lt;span class=&quot;token number&quot;&gt;17
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;prism language-python&quot;&gt;&lt;span class=&quot;token number&quot;&gt;0xFF

&lt;span class=&quot;token number&quot;&gt;255
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;prism language-python&quot;&gt;&lt;span class=&quot;token builtin&quot;&gt;hex&lt;span class=&quot;token punctuation&quot;&gt;(&lt;span class=&quot;token number&quot;&gt;0o177&lt;span class=&quot;token punctuation&quot;&gt;)

&lt;span class=&quot;token string&quot;&gt;'0x7f'
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;浮点数是带有小数部分的数字（小数部分可以是0）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;浮点数的字面值表示方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;小数表示方式&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;3.14   3.1    3.0    3.   0.14   .14
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;科学计数表示方式：&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;格式：小数 e/E(正负号) 指数（10的多少次方）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;6.18E-1    # 等同于0.618
2.9979e8   # 光速
&lt;/code&gt;
&lt;/pre&gt;

&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;分为两部分：实部（real）,虚部（image）虚部是以‘j’或‘J’结尾的数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;复数的字面值表示方式：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;1j
(2j)
1+1J
1-2j
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;4. 布尔 &lt;a title=&quot;http://www.dtmao.cc/news_show_2028405.shtml&quot; href=&quot;http://www.dtmao.cc/news_show_2028405.shtml&quot; target=&quot;_blank&quot;&gt;bool&lt;/a&gt;&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;用来表示真和假两种状态的类型&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;布尔数的字面值表示方式：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;true  表示真（条件满足或成立）
false 表示假（条件不满足或不成立）
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注：true的值是1，false的值为0&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;5. &lt;a title=&quot;http://www.dtmao.cc/news_show_2028405.shtml&quot; href=&quot;http://www.dtmao.cc/news_show_2028405.shtml&quot; target=&quot;_blank&quot;&gt;内置函数&lt;/a&gt;（1）：数值对象的构造（创建）函数&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;int(x，base=10)&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;base是进制关系,大于等于2且小于等36，默认十进制&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;用数字或字符串转换为整数，如果不给出参数，则返回0。
如果给出base参数，意思是将符合base 进制的x 字符串数字或数字，
转换成base 进制数，x 的取值范围0-9，a/A - z/Z
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;float(obj)&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;用字符串或数字转换为浮点数，如果不给出参数，则返回0.0
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;complex(r=0.0, i=0.0)&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;用数字创建一个复数（实部为r, 虚部为i）
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;用x创建一个布尔值（Ture/False）
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;bool(x) 返回假值的情况：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;None            空值
False           布尔假值
0  0.0  0j      所有的数字零
''              空字符串
[]              空列表
()              空元组
{}              空字典
set()           空集合等&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 09 Feb 2021 21:22:00 +0000</pubDate>
<dc:creator>1763392456</dc:creator>
<og:description>python 的核心数据类型： Number 数字（整数，浮点数，复数，布尔型数） String 字符串 List 列表 Tuple 元组 Dictionary 字典 Set 集合 1. 整数（整型数</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cnoneblog/p/14394887.html</dc:identifier>
</item>
<item>
<title>Linunx系统引导过程及MBR/GRUB故障 - the7主题</title>
<link>http://www.cnblogs.com/the7theme/p/14394885.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/the7theme/p/14394885.html</guid>
<description>&lt;div class=&quot;toc&quot;&gt;
&lt;h3&gt;⭐&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;a title=&quot;http://www.dtmao.cc/news_show_692396.shtml&quot; href=&quot;http://www.dtmao.cc/news_show_692396.shtml&quot; target=&quot;_blank&quot;&gt;Linunx&lt;/a&gt;系统引导过程&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;系统初始化进程&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;init进程&lt;/li&gt;
&lt;li&gt;Systemd&lt;/li&gt;
&lt;li&gt;Systemd单元类型&lt;/li&gt;
&lt;li&gt;允许级别所对应的systemd目标&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;修复MBR扇区故障&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;解决思路&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;操作&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;修复GRUB引导故障&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;解决思路&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;操作&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;


&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210209165351712.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hvdHNob3J0Z2c=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;开机自检：服务器主机开机后，将根据主板&lt;a title=&quot;http://www.dtmao.cc/news_show_692396.shtml&quot; href=&quot;http://www.dtmao.cc/news_show_692396.shtml&quot; target=&quot;_blank&quot;&gt;BIOS&lt;/a&gt;中的设置对cpu、显卡、内存、键盘等设备进行初步检测，检测成功后根据预设的 启动顺序移交系统控制权，，大多时候会移交给本机硬盘。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210209165913826.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/li&gt;
&lt;li&gt;MBR引导：当从本机硬盘中启动系统时，首先根据硬盘中第一个扇区中MBR（主引导记录）的设置，将系统控制权传递给包含操作系统引导文件的分区：或者直接根据MBR 记录中的引导信息调用启动菜单（如GRUB）。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210209170444494.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/li&gt;
&lt;li&gt;GRUB菜单：对于Linux操作系统来说，GRUB（统一启动加载器）是使用最为广泛的多系统引导器程序。系统控制权递交给GRUB以后，将会显示启动菜单给用户选择，并根据所选项或采用默认值加载Linux内核文件，然后将系统控制权交给内核。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210209171044739.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/li&gt;
&lt;li&gt;加载Linux内核：Linux内核是一个预先编译好的特殊二进制文件，介于各种硬件资源与系统程序之间，负责资源分配和调度。内核结果系统控制权之后，将完全掌控整个&lt;a title=&quot;http://www.dtmao.cc/news_show_692396.shtml&quot; href=&quot;http://www.dtmao.cc/news_show_692396.shtml&quot; target=&quot;_blank&quot;&gt;Linux&lt;/a&gt;操作系统的运行过程。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210209171554976.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/li&gt;
&lt;li&gt;init进程初始化：为了完成进一步的系统引导过程，Linux内核首先将系统中的“/sbin/init”程序加载到内存中运行（运行中的程序称为进程），init进程负责完成整个系统的初始化，最后等待用户进行登录。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210209171830292.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;系统初始化进程&lt;/h2&gt;
&lt;h3&gt;init进程&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;由&lt;a title=&quot;http://www.dtmao.cc/news_show_692396.shtml&quot; href=&quot;http://www.dtmao.cc/news_show_692396.shtml&quot; target=&quot;_blank&quot;&gt;Linux&lt;/a&gt;内核加载运行/sbin/init程序&lt;/li&gt;
&lt;li&gt;init进程是系统中的第一个进程，是所有进程的父进程&lt;/li&gt;
&lt;li&gt;init进程的PID号永远为1&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;Systemd&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;Systemd是Liunx操作系统的一种init软件&lt;/li&gt;
&lt;li&gt;&lt;a title=&quot;http://www.dtmao.cc/news_show_692396.shtml&quot; href=&quot;http://www.dtmao.cc/news_show_692396.shtml&quot; target=&quot;_blank&quot;&gt;Centos7&lt;/a&gt;中采用systemd启动方式，取代传统的sysvinit&lt;/li&gt;
&lt;li&gt;centos7中运行的第一个init进程是/lib/systemd/systemd&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;Systemd单元类型&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2021020917374920.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hvdHNob3J0Z2c=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;允许级别所对应的systemd目标&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210209174505916.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hvdHNob3J0Z2c=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;MBR位于第一块硬盘（/dev/sda）的第一个物理扇区处，总共512字节。&lt;br/&gt;前446字节是主引导记录，分区表保存在MBR扇区中的第447-510字节中。&lt;br/&gt;#####故障原因有########&lt;/li&gt;
&lt;li&gt;病毒、木马等造成的破坏&lt;/li&gt;
&lt;li&gt;不正确的分区操作、磁盘读写错误&lt;br/&gt;故障现象有&lt;/li&gt;
&lt;li&gt;找不到引导程序，启动终端&lt;/li&gt;
&lt;li&gt;无法加载操作系统，开机后黑屏&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;解决思路&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;提前做好备份文件&lt;/li&gt;
&lt;li&gt;以安装光盘引导进入急救模式&lt;/li&gt;
&lt;li&gt;从备份中恢复&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;操作&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;首先创建一个磁盘分区&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210209222512688.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210209222539452.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hvdHNob3J0Z2c=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;strong&gt;格式化，然后在根目录创建一个backup目录，并挂载到backup目录&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210209222639898.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hvdHNob3J0Z2c=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;strong&gt;MBR位于第一块硬盘（/dev/sda）的第一个物理扇区处，总共512字节&lt;br/&gt;备份MBR扇区数据到其他磁盘（/dev/sdb1）&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210210013215751.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;strong&gt;模拟破坏MBR扇区，用zero进行覆盖&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210210013455553.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;strong&gt;init6重启&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210210013626679.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hvdHNob3J0Z2c=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;strong&gt;进入急救模式，rescue a centos system&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210210013800603.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hvdHNob3J0Z2c=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;strong&gt;选1.continue&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210210013903648.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hvdHNob3J0Z2c=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;strong&gt;创建backupdir，并挂载&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210210014344848.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hvdHNob3J0Z2c=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;确认mbr.bak存在，从backupdir提取进行覆盖&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210210014625647.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;strong&gt;exit退出，会自动重启，问题解决&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;故障原因有&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;MBR中的GRUB引导程序遭到破坏&lt;/li&gt;
&lt;li&gt;grub.conf文件丢失、引导配置有错误&lt;br/&gt;故障现象有&lt;/li&gt;
&lt;li&gt;系统引导停滞，显示为“grub&amp;gt;”提示符&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;解决思路&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;尝试手动输入引导命令（较繁琐，不建议使用）&lt;/li&gt;
&lt;li&gt;进入急救模式，重写或者从备份中恢复grub.conf&lt;/li&gt;
&lt;li&gt;向MBR扇区中重建grub程序&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;操作&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;使向MBR扇区中重建grub程序的方式修复&lt;br/&gt;首先建立grub.cfg备份到opt目录并删除grub.cfg&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210210041755589.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;strong&gt;重启，出现故障&lt;/strong&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210210041837829.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hvdHNob3J0Z2c=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;strong&gt;再次重启，在读条状态esc，并选择3.cd-rom drive，就可选择进入急救界面&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210210042152101.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hvdHNob3J0Z2c=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;切换到系统根环境&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2021021004284167.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;重新将GRUB引导程序安装到第一块硬盘的MBR扇区&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210210043505357.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;重新构建GRUB菜单的配置文件&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210210043527239.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;退出chroot环境并且重启&lt;/p&gt;
</description>
<pubDate>Tue, 09 Feb 2021 21:18:00 +0000</pubDate>
<dc:creator>the7主题</dc:creator>
<og:description>⭐ Linunx系统引导过程 系统初始化进程 init进程 Systemd Systemd单元类型 允许级别所对应的systemd目标 修复MBR扇区故障 解决思路 操作 修复GRUB引导故障 解决思</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/the7theme/p/14394885.html</dc:identifier>
</item>
<item>
<title>GitHub Actions 支持 &quot;skip ci&quot; 了 - WeihanLi</title>
<link>http://www.cnblogs.com/weihanli/p/14394798.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/weihanli/p/14394798.html</guid>
<description>&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;/h2&gt;
&lt;p&gt;GitHub Actions 作为 GitHub 官方的 CI 支持，很多开源项目已经在使用 Actions 来做项目的 CI 了，但是一直以来有一个痛点，就是不支持跳过 CI，其他的 CI 大多都可以通过在 commit 信息里包含一个 &quot;skip ci&quot;/&quot;ci skip&quot; 等来告诉 CI 系统不要出发 CI build，GitHub Actions 一直都是不支持的，但是现在已经支持了&lt;/p&gt;
&lt;h2 id=&quot;use&quot;&gt;Use&lt;/h2&gt;
&lt;p&gt;在 commit 信息中只要包含了下面几个关键词就会跳过 CI，不会触发 CI Build&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;[skip ci]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[ci skip]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[no ci]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[skip actions]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[actions skip]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;sample&quot;&gt;Sample&lt;/h2&gt;
&lt;p&gt;来看一个示例吧，这个项目集成了 Github Actions 和 Azure Pipelines 两种 CI，首先来看一个不跳过 CI 的示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/489462/202102/489462-20210210010122979-686666578.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个 CI 是正常触发，没有跳过的，再来看跳过 CI 的示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/489462/202102/489462-20210210010335543-857132759.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上面可以看到并没有触发任何 CI，因为 &quot;skip ci&quot; 对于 Azure Pipelines 也是一个跳过 CI 的关键词，不仅仅是 Azure Pipelines，Travis等 CI 也是会跳过 CI 的&lt;/p&gt;
&lt;h2 id=&quot;more&quot;&gt;More&lt;/h2&gt;
&lt;p&gt;从上面的那个示例可以看的出来，Azure Pipelines 虽然没有触发 CI，但是还是可以看到记录的，只是因为跳过了，从这个角度个人觉得 Azure Pipelines 还是比 Github Actions 更合理一些&lt;/p&gt;
&lt;p&gt;更多 GitHub Actions 的 Roadmap 可以参考：&lt;a href=&quot;https://github.com/github/roadmap/projects/1?card_filter_query=actions&quot; target=&quot;_blank&quot;&gt;https://github.com/github/roadmap/projects/1?card_filter_query=actions&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
</description>
<pubDate>Tue, 09 Feb 2021 17:08:00 +0000</pubDate>
<dc:creator>WeihanLi</dc:creator>
<og:description>Github Actions 支持跳过 CI 了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/weihanli/p/14394798.html</dc:identifier>
</item>
<item>
<title>在.NET中体验GraphQL - 波多尔斯基</title>
<link>http://www.cnblogs.com/podolski/p/14394764.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/podolski/p/14394764.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;以前需要提供Web服务接口的时候，除了标准的WEBAPI形式，还考虑了OData、GraphQL等形式，虽然实现思路上有很大的区别，但对使用方来说，都是将查询的主动权让渡给了前端，让调用方能够更加自由地发挥或者符合自己要求的数据。其中，OData作为传统REST WEBAPI的拓展，对外还是WEBAPI的形式，为了照顾到和第三方对接的兼容性，我最终使用了OData作为首选技术。&lt;/p&gt;
&lt;p&gt;OData在使用上方便性不言而喻，简直爱不释手，不过逐渐也发现一个问题：Mock不方便！前端常用的比如&lt;code&gt;json-schema-faker&lt;/code&gt;无法识别OData的标记，返回的内容依旧是传统API返回的内容（无法输出@odata之类的内容）。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;P.S. 最近还非常烦恼和OData一起使用EF Core时，由于有导航属性（Navigation Property），mock框架会循环引用导致&lt;em&gt;Maximum call stack size exceeded&lt;/em&gt;的问题。一直没有找好办法，如果有朋友知道，还请不吝赐教。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;于是和调用方的扯皮一直延续，最后还是先上线了后台暂时处理了这个问题。最近有一个想法浮到水面：反正mock是不可能mock了，调用方已经要恨死我了，就干脆点直接WebAPI形式也不要了，摊牌了。&lt;/p&gt;
&lt;h2 id=&quot;graphql&quot;&gt;GraphQL&lt;/h2&gt;
&lt;p&gt;GraphQL是Facebook推出的一项提供数据API的语言，和WEBAPI相比较，它有一些自己的特点，详细介绍可以看&lt;a href=&quot;https://graphql.cn/&quot; target=&quot;_blank&quot;&gt;这里&lt;/a&gt;，最吸引我的地方，就是请求API可以一步到位，处理一些逻辑的时候，简单的一个API请求就可以得到所有的数据（当然使用OData的expand等查询也可以达到类似的效果），而且描述语言也比较简洁。这样调用方可以精确描述自己需要什么，接口返回不多不少刚刚好的数据，优雅！&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;关于GraphQL的介绍，可以查看其他文章，不是本文的重点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;体验&quot;&gt;体验&lt;/h2&gt;
&lt;p&gt;使用GraphQL，.NET支持的有很多库，比较流行的，有GraphQL.NET和HotChocolate，作为一个肥宅，我就选HotChocolate作为主要使用的库，直接使用nuget安装即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-powershell&quot;&gt;install-package HotChocolate.AspNetCore
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;新建一个新的ASP.NET CORE空项目，添加&lt;code&gt;HotChocolate.AspNetCore&lt;/code&gt;的nuget包，然后定义以下数据结构&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public class Class
{
    public string Name { get; set; }
    public Teacher Teacher{get;set;}
}
public class Student
{
    public string Realname { get; set; }

    public Class Class{get;set;}
}
public class Teacher
{
    public string Realname { get; set; }
    public bool IsSupervisor{get;set;}
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;描述一个班级，教师和学生的关系，如果是REST API的话，一般需要三个接口表述三种不同的资源。GraphQL只有一个Endpoint，这个就比较简单了。&lt;/p&gt;
&lt;p&gt;接下来定义暴露的接口：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;using System.Collections.Generic;


using System.Linq;


namespace Demo
{
    public class Query
    {
        private List&amp;lt;Student&amp;gt; GetStudents()
        {
            List&amp;lt;Student&amp;gt; students = new List&amp;lt;Student&amp;gt;();
            students.Add(new Student
            {
                Realname = &quot;ZHANGSAN&quot;,
                Class = new Class
                {
                    Name = &quot;GAOSAN&quot;,
                    Teacher = new Teacher { Realname = &quot;LISI&quot;, IsSupervisor = false }
                }
            });
            students.Add(new Student
            {
                Realname = &quot;ZHANGSAN2&quot;,
                Class = new Class
                {
                    Name = &quot;GAOSAN1&quot;,
                    Teacher = new Teacher { Realname = &quot;LISI&quot;, IsSupervisor = true }
                }
            });
            return students;
        }
        public IEnumerable&amp;lt;Student&amp;gt; StudentInfo(string name)
        {
            if(string.IsNullOrWhiteSpace(name)) return GetStudents();
            return GetStudents().Where(w=&amp;gt;w.Realname == name);
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;提供了一个StudentInfo可以对外接口。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void ConfigureServices(IServiceCollection services)
{
    services.AddGraphQLServer().AddQueryType&amp;lt;Query&amp;gt;();
}

//在configure中
app.UseEndpoints(endpoints =&amp;gt;
{
    endpoints.MapGraphQL();
})；
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后然后直接F5运行，访问HotChocolate自带的分析器地址：&lt;a href=&quot;http://localhost:5000/graphql/&quot; target=&quot;_blank&quot;&gt;http://localhost:5000/graphql/&lt;/a&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/616093/202102/616093-20210210003138839-530063676.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;直接查询即可得到结果，换一种查询条件：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/616093/202102/616093-20210210003332970-1009238575.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;可以发现，GraphQL返回的内容是可以由调用方进行定义的，你要啥它给啥，不用的字段你不写就不返回。很多时候，只要一次查询就能完成多次普通WebAPI请求才能达到的目标。（这个例子还不能表现出这个特点，有机会以后补充）。&lt;/p&gt;
&lt;h2 id=&quot;补充&quot;&gt;补充&lt;/h2&gt;
&lt;p&gt;如果调用方不会GraphQL的话，不建议轻易上这个技术，因为他们来一句“这不是标准WEBAPI或者Webservice，我们调不了。”就把你噎死了。好多歹说就算终于上了，你还需要告诉清楚他们每一个接口的请求内容，这就纯粹给自己找事，体验太不好了。&lt;/p&gt;
</description>
<pubDate>Tue, 09 Feb 2021 16:43:00 +0000</pubDate>
<dc:creator>波多尔斯基</dc:creator>
<og:description>前言 以前需要提供Web服务接口的时候，除了标准的WEBAPI形式，还考虑了OData、GraphQL等形式，虽然实现思路上有很大的区别，但对使用方来说，都是将查询的主动权让渡给了前端，让调用方能够更</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/podolski/p/14394764.html</dc:identifier>
</item>
<item>
<title>固执的推荐引擎 - dagis</title>
<link>http://www.cnblogs.com/dagis/p/14394610.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dagis/p/14394610.html</guid>
<description>&lt;p&gt;一直认为推荐引擎可以是很简单AI应用，也可以是最有潜力做复杂的。&lt;/p&gt;
&lt;p&gt;数字化时代之前的推荐是怎么做的。试想一个初次当家的小姑娘跑进百货商店，和售货员阿姨说:&quot;我想买一块香皂，阿姨有什么推荐的吗?”售货价上一共只有三款香皂，售货员阿姨根据记忆，嗯，这么大的小姑娘一般都是选这款，于是就推荐了这款。这个过程数字化之后，就是最简单的推荐引擎。&lt;/p&gt;
&lt;p&gt;随着物资越来越丰富，香皂选项可能上升到几千种，香皂的属性从只有价格和香味扩展为功能，成分，产地等几十上百个属性后，每个人的需求也更加精细化，那售货员阿姨的推荐就没那么简单了。这也是一般购物网站的推荐引擎需要实现的功能，从琳琅满目的商品中做推荐。每个用户都用一个矢量来表示，其中每个元素都对应一个用户属性，比如说性别，年龄，区域，终端设备，访问时间，消费级别，购物欲…,你可能会质疑，用户终端设备信息有什么用，用户的购物欲是怎么得到。因为本文是讲推荐引擎，所以不跑题去讨论这个了，有兴趣的可以参考之前的一篇文章&amp;lt;最了解你的人是谁----是他是她还是它&amp;gt;。有了这个用户属性后，要在顾客数据库里找出最相近的那个用户或一组用户，把他们的选择推荐出去就好啦。&lt;/p&gt;
&lt;p&gt;可能你还是会觉得这很简单。但仔细一想，很容易就会发现两个问题。&lt;/p&gt;
&lt;p&gt;问题一，当你的数据库客户有几个million，用户属性增多后，实时的找出最相似的用户，计算量相当惊人。而作为在线推荐，据实验统计，时延的增加会直接降低点击率。&lt;/p&gt;
&lt;p&gt;问题二，根据相似客户的选择做推荐，会使得新上架产品永远没有机会出现在推荐当中。&lt;/p&gt;
&lt;p&gt;对于问题一，很自然的大家会想到clustering之类的离线计算来降低在线计算的压力。不过在某些情况下会降低推荐的效果。&lt;/p&gt;
&lt;p&gt;对于问题二，我觉得吴恩达的&amp;lt;机器学习&amp;gt;课程当中举的例子可以很好的解决这个问题。就是商品的属性也矢量化，匹配用户的结果并不是直接targe到某个商品，而是target某组属性的商品，只要新上架的商品满足属性，就在推荐范围之内。建立这个数学模型和求解应该不是个难题。在推荐引擎技术领域，称之为从用户协同过滤，转换到用户内容混合协同过滤。&lt;/p&gt;
&lt;p&gt;之前提到，用户的各种属性可以根据商家们长期积累的收集数据手段，应该不难解决。那商品的属性呢，特别是像电影，音乐，书籍之类的推荐，仅仅仅靠类属，年份，拍摄地等硬属性，是远远不够的。于是很多推荐引擎会去网上爬数据，针对某部电影或某个音乐通过自然语言处理做情感分析。比如说Spotify会从博客上收集用户对歌手和歌曲评论的关键词，然后收取top的一些评论语作为内容属性。(配图来自网络)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/D0eG4IpZIN45ibC4K6t1jgXFMLNzOAR0hy8yXKPjhmd8fHetoH1ZL1PibtSG1W59TDIC6iafZcibtvgnd5oYvAoovQ/640?wx_fmt=png&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;Image&quot; width=&quot;594&quot; data-ratio=&quot;0.48956884561891517&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/D0eG4IpZIN45ibC4K6t1jgXFMLNzOAR0hy8yXKPjhmd8fHetoH1ZL1PibtSG1W59TDIC6iafZcibtvgnd5oYvAoovQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;719&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上的讨论我们没有提及到客户在某个网站已经有了购买记录。实际上，商家们常常会根据用户已经购买过的商品做推荐，这就是比较有名的”猜你喜欢”推荐。亚马逊称自己的推荐算法就是不做用户协同过滤，而是完全依赖用户的已购买选项来推荐。通过商品之间的相似度，来推销相近商品。而商品与商品之间是否相近很大取决于历史上客户的购买组合，并不是物理上的相似度。举个例子，如果你买了打印机，那可能相似度最高的是打印纸和墨水，而不是另一款类似打印机。这个算法的很大优势是，由于商品属性在短时间内较为稳定，所以大部分的计算量可离线完成。同时，将必要组合商品推荐给用户，很大的提高了用户体验。&lt;/p&gt;
&lt;p&gt;文中开始提到推荐引擎是很有潜力做复杂的。用户的品味不仅仅是商品的硬属性决定的。对于软属性，除了网上公开评论的情感分析，对于音乐本身的分析也是一个相当大的领域可以钻研，同理与电影，书籍或其他和taste关系比较大的商品。对此，Spotify的推荐引擎引入了音乐模型来分析音乐本身，这也使得新上榜的音乐有同等的机会出现在推荐列表里。&lt;/p&gt;
&lt;p&gt;之前一个朋友转过一篇文章，分析AI为什么不能超越人类创作出最好的曲子，论点是人类对于某个歌曲的喜好，不仅仅是歌曲本身，歌曲相关的故事，超越自我的创作都是歌曲能够惊世的重要因素，是AI无法做到的。同理，对于主观非常强的内容推荐，AI是难以做到突破性的推荐。这也类属于推荐引擎比较纠结的经典问题，多样性Diversity。&lt;/p&gt;
&lt;p&gt;我有在Medium上看blog的习惯，如果我看了一两篇和python visualization的文章，接下来的日子我的medium主页就充满了这类文章，非常的烦人，不如不推荐。瑞典本土听书软件storytel，估计非常自信与自己的推荐引擎，所以分类浏览做得很简陋。由于冷启动问题，初次用户费很大精力找到自己感兴趣的书，之后由于推荐缺乏多样性，就被锁定在你看过的书的类属里。一个朋友很明确的告诉我，就是很不满它的推荐，所以不听了。相比之下，Spotify就做得比较好，可能也不一定做得比较好，而是由于人们对于歌曲的喜好的风格比较执着，换来换去，只要风格一致，还是比较喜欢听，不容易腻。歌曲可以反复听，文章，书或电影一般不会反复看。&lt;/p&gt;
&lt;p&gt;在开始写这篇文章之前，一直想着一个问题，推荐引擎到底是商家受益更多还是用户收益更多，商家提高推荐引擎推荐质量的动力在哪里?然后我又想起了电商还不普及的那个年代，经常在超市拿起一件你经常用的商品放进购物篮，就会有推销阿姨过来，把你的选择刺裸裸的鄙视了一番，之后极力推荐自己的商品。利益驱动之下，怎么防止商家把这个功能做进推荐引擎呢。就比如搜索引擎，怎么确保放在最前面的搜索结果不是收了最多钱的。用户的确就是羔羊。好在和推荐引擎技术相关的论文或文章中，单纯的工程师们，要致力提高的还是点击率购买率以及推算出来的用户满意度。&lt;/p&gt;
&lt;p&gt;去年夏天看过一本书，叫做&amp;lt;nudge&amp;gt;。作者提到，很好的选择架构，选择人会受益很大。比如说菜单的菜品顺序摆放，会极大的影响顾客是选择健康的沙拉，还是油炸垃圾食品。推荐功能从这个角度来说，不仅是nudge，甚至是push。做一个良心的推荐引擎对用户来说有多重要。&lt;/p&gt;

&lt;p&gt;部分引用: &lt;/p&gt;
&lt;p&gt;https://medium.com/datadriveninvestor/behind-spotify-recommendation-engine-a9b5a27a935&lt;/p&gt;
&lt;p&gt;https://www.cs.umd.edu/~samir/498/Amazon-Recommendations.pdf&lt;/p&gt;
&lt;p&gt;https://marutitech.com/recommendation-engine-benefits/&lt;/p&gt;

&lt;p&gt;作者微信公众号:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/D0eG4IpZIN45ibC4K6t1jgXFMLNzOAR0h1bvicMVLnFPO9MJCoXtc3GOpXTwuPydfxEKx0TGrg30epUJlkx2qscw/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;Image&quot; class=&quot;rich_pages&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/D0eG4IpZIN45ibC4K6t1jgXFMLNzOAR0h1bvicMVLnFPO9MJCoXtc3GOpXTwuPydfxEKx0TGrg30epUJlkx2qscw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 09 Feb 2021 15:32:00 +0000</pubDate>
<dc:creator>dagis</dc:creator>
<og:description>推荐引擎杂谈。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/dagis/p/14394610.html</dc:identifier>
</item>
<item>
<title>C语言之库函数的模拟与使用 - guguguhuha</title>
<link>http://www.cnblogs.com/guguguhuha/p/14393955.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/guguguhuha/p/14393955.html</guid>
<description>


&lt;p&gt;&lt;span&gt;在我们学习C语言的过程中，难免会遇到这样的一种情况：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们通常实现一个功能的时候，费尽心血的写出来，却有着满满的错，这时却有人来告诉你说：这个功能可以用相应的库函数来实现。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这时你的心里充满着***。但这并不算坏事，至少加深了你对它的认识与记忆。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;所以，今天来漫谈一下 &lt;strong&gt;某些库函数的模拟与实现。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;而这篇我们主要来介绍一些处理字符和字符串的库函数的使用和注意事项&lt;/p&gt;
&lt;p&gt;内容大致如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;p&gt;&lt;span&gt;1.求字符串长度 strlen&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.长度不受限制的字符串函数 strcpy strcat strcmp&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.长度受限制的字符串函数介绍 strncpy strncat strncmp&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.字符串查找 strstr strtok&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.错误信息报告 strerror perror&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6.字符操作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;7.内存操作函数&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;memcpy memmove memset memcmp&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;h2&gt;1.求字符串长度--strlen&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2230905/202102/2230905-20210209155820152-754372047.png&quot; alt=&quot;&quot; width=&quot;975&quot; height=&quot;417&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt;正如所介绍那样，此函数的功能就是求一个字符串的长度。而我们所需要做的就是传一个字符指针进去。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;.h&amp;gt;

&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main ()
{
  &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; szInput[&lt;span&gt;256&lt;/span&gt;&lt;span&gt;];
  printf (&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Enter a sentence: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
  gets (szInput);
  printf (&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;The sentence entered is %u characters long.\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,(unsigned)strlen(szInput));
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;结果：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2230905/202102/2230905-20210209160549073-1190407615.png&quot; alt=&quot;&quot; width=&quot;883&quot; height=&quot;48&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在此函数的使用过程中我们需要注意以下几点：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;.字符串已经 &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; 作为结束标志&lt;br/&gt;&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;.strlen函数返回的是在字符串中 &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; 前面出现的字符个数（不包含 &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; )。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;.参数指向的字符串必须要以 &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; 结束。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;.注意函数的返回值为size_t，是无符号的（ 易错 ）
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们来看一个对于第四点的例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdio.h&amp;gt;&lt;span&gt; 
#include&lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;.h&amp;gt;
&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;* str1 = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;abcdef&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;; 
    &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;* str2 = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bbb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;; 
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (strlen(str2) - strlen(str1) &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
    {
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;str2&amp;gt;str1\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    {
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;srt1&amp;gt;str2\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个结果会是什么呢？&lt;/p&gt;
&lt;p&gt;相信会有人给出&lt;span&gt;srt1&amp;gt;str2&lt;/span&gt;的结果，可编译器给出的结果却是：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2230905/202102/2230905-20210209162318706-1837149439.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 为什么呢？&lt;/p&gt;
&lt;p&gt;我们原以为 3-6=-3 这个式子没错啊，-3&amp;lt;0 执行 else 的结果&lt;/p&gt;
&lt;p&gt;但 因为strlen的返回类型是一个&lt;strong&gt;unsigned&lt;/strong&gt;形，所以相减之后的那个数会变为一个很大很大的数。&lt;/p&gt;

&lt;p&gt;我们来模拟实现一下此函数&lt;/p&gt;
&lt;h3&gt;1.计数器方式&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; my_strlen(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; str)
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; count = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (*&lt;span&gt;str)
    {
        count&lt;/span&gt;++&lt;span&gt;; 
        str&lt;/span&gt;++&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; count;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2.递归实现&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; my_strlen(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; str)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (*str == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; + my_strlen(str + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.指针-指针 实现&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;MsoNormal&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; my_strlen(&lt;span&gt;char&lt;/span&gt;*&lt;span&gt; s)
{
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;* p =&lt;span&gt; s;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (*p != &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        p&lt;/span&gt;++&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; p -&lt;span&gt; s;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;2.&lt;img width=&quot;6&quot; height=&quot;6&quot;/&gt;&lt;span&gt;长度不受限制的字符串函数&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;1.strcpy&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;这个函数可谓是见名知意，字符串的拷贝函数，我们来看看介绍：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2230905/202102/2230905-20210209163557396-856464327.png&quot; alt=&quot;&quot; width=&quot;861&quot; height=&quot;452&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实例：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;.h&amp;gt;

&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; str1[] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Sample string&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; str2[&lt;span&gt;40&lt;/span&gt;&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; str3[&lt;span&gt;40&lt;/span&gt;&lt;span&gt;];
    strcpy(str2, str1);
    strcpy(str3, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;copy successful&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;str1: %s\nstr2: %s\nstr3: %s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, str1, str2, str3);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述代码干了一个什么事呢？&lt;/p&gt;
&lt;p&gt;将str1中的内容拷贝到str2中&lt;/p&gt;
&lt;p&gt;又将 copy successful  拷贝到str3中&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结果：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2230905/202102/2230905-20210209164014848-485400065.png&quot; alt=&quot;&quot; width=&quot;786&quot; height=&quot;99&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;同样注意以下几点：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
Copies the C &lt;span&gt;string&lt;/span&gt; pointed by source into the array pointed by destination, including the terminating &lt;span&gt;null&lt;/span&gt;&lt;span&gt; character (and stopping at that point).&lt;br/&gt;源字符串必须以 &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; 结束。&lt;br/&gt;会将源字符串中的 &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; 拷贝到目标空间。&lt;br/&gt;目标空间必须足够大，以确保能存放源字符串。目标空间必须可变。&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;模拟实现strcpy&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
#include&amp;lt;assert.h&amp;gt;
&lt;span&gt;char&lt;/span&gt;* my_strcpy(&lt;span&gt;char&lt;/span&gt;* dest, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; src)
{
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;* ret =&lt;span&gt; dest;
    assert(dest &lt;/span&gt;!= NULL); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;断言保证dest不为空指针&lt;/span&gt;
    assert(src != NULL);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;断言保证src不为空指针&lt;/span&gt;

    &lt;span&gt;while&lt;/span&gt; ((*dest++ = *src++&lt;span&gt;))
    {
        ;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2.strcat-连接两个字符串&lt;/h3&gt;
&lt;p&gt;介绍如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2230905/202102/2230905-20210209165131782-34685810.png&quot; alt=&quot;&quot; width=&quot;1008&quot; height=&quot;531&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; 实例：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;.h&amp;gt;

&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; str[&lt;span&gt;80&lt;/span&gt;&lt;span&gt;];
    strcpy(str, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;these &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    strcat(str, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;strings &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    strcat(str, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;are &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    strcat(str, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;concatenated.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    puts(str);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;作用：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先将 these 复制到 str 中，在逐次将 strings 、are、concatenated 连接到str上&lt;/p&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2230905/202102/2230905-20210209165553212-661314943.png&quot; alt=&quot;&quot; width=&quot;1031&quot; height=&quot;33&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; 注意：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
Appends a copy of the source &lt;span&gt;string&lt;/span&gt; to the destination &lt;span&gt;string&lt;/span&gt;. The terminating &lt;span&gt;null&lt;/span&gt; character &lt;span&gt;in&lt;/span&gt; destination &lt;span&gt;is&lt;/span&gt; overwritten by the ﬁrst character of source, and a &lt;span&gt;null&lt;/span&gt;-character &lt;span&gt;is&lt;/span&gt; included at the end of the &lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; formed by the concatenation of both &lt;span&gt;in&lt;/span&gt;&lt;span&gt; destination.

1.源字符串必须以 &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; 结束。

2.目标空间必须有足够的大，能容纳下源字符串的内容。目标空间必须可修改。&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;还值得注意的一点就是：若自己追加自己将会“永无休止”的循环下去，为什么呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2230905/202102/2230905-20210209172359360-949477525.png&quot; alt=&quot;&quot; width=&quot;977&quot; height=&quot;507&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;h4&gt;模拟实现&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
#include&amp;lt;assert.h&amp;gt;
&lt;span&gt;char&lt;/span&gt;* my_strcat(&lt;span&gt;char&lt;/span&gt;* dest, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; src)
{
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;* ret =&lt;span&gt; dest; 
    assert(dest &lt;/span&gt;!=&lt;span&gt; NULL); 
    assert(src &lt;/span&gt;!=&lt;span&gt; NULL); 
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (*dest)            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;找到\0的位置&lt;/span&gt;
&lt;span&gt;    {
        dest&lt;/span&gt;++&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; ((*dest++ = *src++))&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在此\0位置上覆盖新的内容&lt;/span&gt;
&lt;span&gt;    {
        ;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;3.strcmp-字符串比较函数&lt;/h3&gt;
&lt;p&gt;切记：&lt;strong&gt;不能用 == 来判断两个字符串是否相等&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;介绍：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2230905/202102/2230905-20210209173732053-835029705.png&quot; alt=&quot;&quot; width=&quot;1000&quot; height=&quot;642&quot; loading=&quot;lazy&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; 实例：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;.h&amp;gt;

&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; key[] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;apple&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; buffer[&lt;span&gt;80&lt;/span&gt;&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Guess my favorite fruit? &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        fflush(stdout);
        scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%79s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, buffer);
    } &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (strcmp(key, buffer) != &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
    puts(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Correct answer!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;strong&gt;作用：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义一个key来表示自己喜欢的水果，&lt;/p&gt;
&lt;p&gt;让用户不断来输入，&lt;/p&gt;
&lt;p&gt;直到用户输入所指定内容&lt;/p&gt;
&lt;p&gt;最后输出 correct answer&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 结果：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2230905/202102/2230905-20210209174349311-870607313.png&quot; alt=&quot;&quot; width=&quot;888&quot; height=&quot;121&quot; loading=&quot;lazy&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; 注意：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
This function starts comparing the ﬁrst character of each &lt;span&gt;string&lt;/span&gt;. If they are equal to each other, it continues with the following pairs until the characters diﬀer or until a terminating &lt;span&gt;null&lt;/span&gt;-character &lt;span&gt;is&lt;/span&gt;&lt;span&gt; reached.

标准规定：
第一个字符串大于第二个字符串，则返回大于0的数字
第一个字符串等于第二个字符串，则返回0
第一个字符串小于第二个字符串，则返回小于0的数字&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;比较是比的相应字符的ASCII码值，如果相等，则比较下一个以此类推.....&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; 模拟实现：&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; my_strcmp(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;* src, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; dest)
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; ret = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    assert(src &lt;/span&gt;!=&lt;span&gt; NULL); 
    assert(dest &lt;/span&gt;!=&lt;span&gt; NULL);
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (!(ret = *(unsigned &lt;span&gt;char&lt;/span&gt;*)src - *(unsigned &lt;span&gt;char&lt;/span&gt;*)dest) &amp;amp;&amp;amp; *dest)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;dest不为空，且如果相减结果为0，就继续循环&lt;/span&gt;
&lt;span&gt;    {
        &lt;/span&gt;++src, ++&lt;span&gt;dest;

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ret &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
            ret &lt;/span&gt;= -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;; 
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (ret &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
            ret &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

    }
    
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;(ret);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
#include&amp;lt;assert.h&amp;gt;
&lt;span&gt;int&lt;/span&gt; my_strcmp(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;*s1, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;*&lt;span&gt;s2)
{
    assert(s1 &lt;/span&gt;&amp;amp;&amp;amp;&lt;span&gt; s2);
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (*s1 == *&lt;span&gt;s2)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (*s1 == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        s1&lt;/span&gt;++&lt;span&gt;;
        s2&lt;/span&gt;++&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; *s1 - *&lt;span&gt;s2;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;3.长度受限制的字符串函数介绍&lt;/h2&gt;
&lt;h3&gt;1.strncpy-从原始串复制自定义个字符到新串中&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;介绍：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2230905/202102/2230905-20210209181520742-1348995289.png&quot; alt=&quot;&quot; width=&quot;991&quot; height=&quot;595&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; 实例：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;
#include &lt;/span&gt;&amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;.h&amp;gt;

&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main ()
{
  &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; str1[]= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;To be or not to be&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; str2[&lt;span&gt;40&lt;/span&gt;&lt;span&gt;];
  &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; str3[&lt;span&gt;40&lt;/span&gt;&lt;span&gt;];

  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; copy to sized buffer (overflow safe): &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  strncpy ( str2, str1, &lt;/span&gt;&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(str2) );

  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; partial copy (only 5 chars): &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  strncpy ( str3, str2, &lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt; );
  str3[&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;;   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; null character manually added &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

  puts (str1);
  puts (str2);
  puts (str3);

  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;作用：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将str1中所有的字符复制到str2中&lt;/p&gt;
&lt;p&gt;将str1中的前五个字符复制到str3中&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结果：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2230905/202102/2230905-20210209183507087-1173113208.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; 注意：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
Copies the first num characters of source to destination. If the end of the source C &lt;span&gt;string&lt;/span&gt; (which &lt;span&gt;is&lt;/span&gt;&lt;span&gt;
signaled by a &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;-character) &lt;span&gt;is&lt;/span&gt; found before num characters have been copied, destination &lt;span&gt;is&lt;/span&gt;&lt;span&gt; padded
with zeros until a total of num characters have been written to it.&lt;br/&gt;拷贝num个字符从源字符串到目标空间。

如果源字符串的长度小于num，则拷贝完源字符串之后，在目标的后边追加0，直到num个。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;模拟实现：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;char&lt;/span&gt;* my_strncpy(&lt;span&gt;char&lt;/span&gt;* destination, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; source, size_t num)
{
    assert(destination &lt;/span&gt;&amp;amp;&amp;amp;&lt;span&gt; source);
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;* ret =&lt;span&gt; destination;
    destination[num] &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (num--&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (*source == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;*destination = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;*destination++ = *source++&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;2.strncat--从原始串取自定义个字符连接到新串中&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;介绍：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2230905/202102/2230905-20210209203558127-2062282671.png&quot; alt=&quot;&quot; width=&quot;877&quot; height=&quot;493&quot; loading=&quot;lazy&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt; 示例：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;.h&amp;gt;

&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; str1[&lt;span&gt;20&lt;/span&gt;&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; str2[&lt;span&gt;20&lt;/span&gt;&lt;span&gt;];
    strcpy(str1, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;To be &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    strcpy(str2, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;or not to be&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    strncat(str1, str2, &lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;);
    puts(str1);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;作用：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将str2中的前6个字符连接到str1后面&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结果：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2230905/202102/2230905-20210209204311730-740057715.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
Appends the first num characters of source to destination, plus a terminating &lt;span&gt;null&lt;/span&gt;-&lt;span&gt;character.
If the length of the C &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; source &lt;span&gt;is&lt;/span&gt; less than num, only the content up to the terminating nullcharacter &lt;span&gt;is&lt;/span&gt; copied.
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt; 模拟实现：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;char&lt;/span&gt;* my_strncat(&lt;span&gt;char&lt;/span&gt;* destination, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; source, size_t num)
{
    assert(destination &lt;/span&gt;&amp;amp;&amp;amp;&lt;span&gt; source);
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;* ret =&lt;span&gt; destination;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (*destination);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;找到\0&lt;/span&gt;
    destination[num] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;放置\0&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt; (num--&lt;span&gt;)
    {
        &lt;/span&gt;*destination++ = *source++&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (*source == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;*destination = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;strong&gt;3.strncmp-自定义个字符比较&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;比较方式与strcmp相同&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;介绍：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2230905/202102/2230905-20210209205925861-266389950.png&quot; alt=&quot;&quot; width=&quot;940&quot; height=&quot;583&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt; 示例：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;.h&amp;gt;

&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; str[][&lt;span&gt;5&lt;/span&gt;] = { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;R2D2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; , &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C3PO&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; , &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;R2A6&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n;
    puts(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Looking for R2 astromech droids...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (n = &lt;span&gt;0&lt;/span&gt;; n &amp;lt; &lt;span&gt;3&lt;/span&gt;; n++&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (strncmp(str[n], &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;R2xx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;) == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
        {
            printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;found %s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, str[n]);
        }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;作用：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比较各字符串的前两个字符是否为R2，如果相同，则输出&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结果：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2230905/202102/2230905-20210209210310754-919686105.png&quot; alt=&quot;&quot; width=&quot;546&quot; height=&quot;127&quot; loading=&quot;lazy&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt; 注意：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
比较到出现另个字符不一样或者一个字符串结束或者num个字符全部比较完。
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;模拟实现：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;.h&amp;gt;

&lt;span&gt;int&lt;/span&gt; my_strncmp(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;* str1, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; str2, size_t num)
{
    assert(str1 &lt;/span&gt;&amp;amp;&amp;amp;&lt;span&gt; str2);
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (num--&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((*str1 != *&lt;span&gt;str2))
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; *str1 - *&lt;span&gt;str2;
        }
        str1&lt;/span&gt;++&lt;span&gt;;
        str2&lt;/span&gt;++&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;4.字符串查找函数&lt;/h2&gt;
&lt;h3&gt;1.strstr-在一个字符串中查找另一个字符串是否存在并返回相应的地址&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;介绍：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2230905/202102/2230905-20210209213629871-74758896.png&quot; alt=&quot;&quot; width=&quot;958&quot; height=&quot;619&quot; loading=&quot;lazy&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt; 示例：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;.h&amp;gt;

&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; str[] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;This is a simple string&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;*&lt;span&gt; pch;
    pch &lt;/span&gt;= strstr(str, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;simple&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (pch !=&lt;span&gt; NULL)
        strncpy(pch, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sample&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;&lt;span&gt;);
    puts(pch);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;作用：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在str中查找simple是否存在&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结果：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2230905/202102/2230905-20210209214116345-1596845772.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt; 注意：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
Returns a pointer to the first occurrence of str2 &lt;span&gt;in&lt;/span&gt; str1, or a &lt;span&gt;null&lt;/span&gt; pointer &lt;span&gt;if&lt;/span&gt; str2 &lt;span&gt;is&lt;/span&gt; not part of str1.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;模拟实现：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;.h&amp;gt;

&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;* my_strstr(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;* str1, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; str2)
{
    assert(str1 &lt;/span&gt;&amp;amp;&amp;amp;&lt;span&gt; str2);
    &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;* start =&lt;span&gt; str1;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (*&lt;span&gt;start)
    {
        &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;* e1 =&lt;span&gt; start;
        &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;* e2 =&lt;span&gt; str2;
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; ((*e1 == *e2) &amp;amp;&amp;amp; (*e1) &amp;amp;&amp;amp; (*&lt;span&gt;e2))
        {
            e1&lt;/span&gt;++&lt;span&gt;;
            e2&lt;/span&gt;++&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (*e2 == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (&lt;span&gt;char&lt;/span&gt;*&lt;span&gt;)start;
        }
        start&lt;/span&gt;++&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NULL;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2.strtok-字符串分割函数&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;介绍：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2230905/202102/2230905-20210209221513500-146857043.png&quot; alt=&quot;&quot; width=&quot;945&quot; height=&quot;834&quot; loading=&quot;lazy&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt; 实例：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;.h&amp;gt;

&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; str[] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;EG:- This, a sample string.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;*&lt;span&gt; pch;
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Splitting string \&quot;%s\&quot; into tokens:\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, str);
    pch &lt;/span&gt;= strtok(str, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ,.-&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (pch !=&lt;span&gt; NULL)
    {
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, pch);
        pch &lt;/span&gt;= strtok(NULL, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ,.-&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;作用：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将所给字符串用所给分隔符分割开；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结果：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2230905/202102/2230905-20210209221856322-196627876.png&quot; alt=&quot;&quot; width=&quot;695&quot; height=&quot;158&quot; loading=&quot;lazy&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt; 注意：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;char&lt;/span&gt; * strtok ( &lt;span&gt;char&lt;/span&gt; * str, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *&lt;span&gt; sep );&lt;br/&gt;sep参数是个字符串，定义了用作分隔符的字符集合&lt;br/&gt;第一个参数指定一个字符串，它包含了0个或者多个由sep字符串中一个或者多个分隔符分割的标记。&lt;br/&gt;strtok函数找到str中的下一个标记，并将其用 \&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt; 结尾，返回一个指向这个标记的指针。（注：strtok函数会改
变被操作的字符串，所以在使用strtok函数切分的字符串一般都是临时拷贝的内容并且可修改。）&lt;br/&gt;strtok函数的第一个参数不为 NULL ，函数将找到str中第一个标记，strtok函数将保存它在字符串中的位置。&lt;br/&gt;strtok函数的第一个参数为 NULL ，函数将在同一个字符串中被保存的位置开始，查找下一个标记。&lt;br/&gt;如果字符串中不存在更多的标记，则返回 NULL 指针。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;strong&gt;5.错误信息报告&lt;/strong&gt;&lt;/h2&gt;



&lt;h3&gt; 1.strerror-返回错误码，所对应的错误信息。&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;介绍：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2230905/202102/2230905-20210209223201713-575538022.png&quot; alt=&quot;&quot; width=&quot;972&quot; height=&quot;471&quot; loading=&quot;lazy&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt; 示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;errno.h&amp;gt;//必须包含的头文件

&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    FILE&lt;/span&gt;*&lt;span&gt; pFile;
    pFile &lt;/span&gt;= fopen(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;unexist.ent&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (pFile ==&lt;span&gt; NULL)
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Error opening file unexist.ent: %s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, strerror(errno));
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;结果：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2230905/202102/2230905-20210209223421060-1538520544.png&quot; alt=&quot;&quot; width=&quot;945&quot; height=&quot;61&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt; 注意：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
使用时必须包含头文件：errno.h
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2.perror-打印对应的错误信息&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2230905/202102/2230905-20210209223631944-841754965.png&quot; alt=&quot;&quot; width=&quot;901&quot; height=&quot;601&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt; 示例：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdio.h&amp;gt;

&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    FILE&lt;/span&gt;*&lt;span&gt; pFile;
    pFile &lt;/span&gt;= fopen(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;unexist.ent&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;rb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (pFile ==&lt;span&gt; NULL)
        perror(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;The following error occurred&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        fclose(pFile);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;结果：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2230905/202102/2230905-20210209223924991-192275970.png&quot; alt=&quot;&quot; width=&quot;871&quot; height=&quot;54&quot; loading=&quot;lazy&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;



&lt;h3&gt;6.字符分类函数：&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2230905/202102/2230905-20210209224140925-831217830.png&quot; alt=&quot;&quot; width=&quot;784&quot; height=&quot;478&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt; 注意：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;比较时，是一个一个字符的去比较&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例及结果：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;ctype.h&amp;gt;
&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main ()
{
  &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i;
  &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; str[]=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;c3po...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
  i&lt;/span&gt;=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (isalnum(str[i])) i++&lt;span&gt;;
  printf (&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;The first %d characters are alphanumeric.\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,i);
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2230905/202102/2230905-20210209224527752-2106697564.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;



&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;ctype.h&amp;gt;
&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; str[] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C++&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (str[i])
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isalpha(str[i])) 
            printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;character %c is alphabetic\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, str[i]);
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; 
            printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;character %c is not alphabetic\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, str[i]);
        i&lt;/span&gt;++&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2230905/202102/2230905-20210209224635534-947050675.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;



&lt;h2&gt;7.内存操作函数&lt;/h2&gt;
&lt;p&gt;内存操作函数不仅可以处理字符串，还可以处理结构体，整形数组等。&lt;/p&gt;
&lt;h3&gt;1.memcpy--以字节为单位复制&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;介绍：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2230905/202102/2230905-20210209224837856-2001680636.png&quot; alt=&quot;&quot; width=&quot;992&quot; height=&quot;643&quot; loading=&quot;lazy&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt; 示例：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;.h&amp;gt;

&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; name[&lt;span&gt;40&lt;/span&gt;&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;
} person, person_copy;

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; myname[] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Pierre de Fermat&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; using memcpy to copy string: &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    memcpy(person.name, myname, strlen(myname) &lt;/span&gt;+ &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    person.age &lt;/span&gt;= &lt;span&gt;46&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; using memcpy to copy structure: &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    memcpy(&lt;/span&gt;&amp;amp;person_copy, &amp;amp;person, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(person));

    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;person_copy: %s, %d \n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, person_copy.name, person_copy.age);

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;结果：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2230905/202102/2230905-20210209225240752-837087627.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt; 注意：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre readability=&quot;4.5&quot;&gt;
&lt;span readability=&quot;3&quot;&gt;void * memcpy ( void * destination, const void * source, size_t num );&lt;p&gt;函数memcpy从source的位置开始向后复制num个字节的数据到destination的内存位置。&lt;br/&gt;这个函数在遇到 &lt;/p&gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; 的时候并不会停下来。&lt;br/&gt;如果source和destination有任何的重叠，复制的结果都是未定义的&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;模拟实现：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt;* my_memcpy(&lt;span&gt;void&lt;/span&gt;* destination, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;*&lt;span&gt; source, size_t num)
{
    assert(destination &lt;/span&gt;&amp;amp;&amp;amp;&lt;span&gt; source);
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;* ret =&lt;span&gt; destination;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (num--&lt;span&gt;)
    {
        &lt;/span&gt;*((&lt;span&gt;char&lt;/span&gt;*)destination)++ = *((&lt;span&gt;char&lt;/span&gt;*)source)++&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2.memmove&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;介绍：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2230905/202102/2230905-20210209230559698-749383790.png&quot; alt=&quot;&quot; width=&quot;1014&quot; height=&quot;675&quot; loading=&quot;lazy&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt; 示例：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;.h&amp;gt;

&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main ()
{
  &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; str[] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;memmove can be very useful......&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
  memmove (str&lt;/span&gt;+&lt;span&gt;20&lt;/span&gt;,str+&lt;span&gt;15&lt;/span&gt;,&lt;span&gt;11&lt;/span&gt;&lt;span&gt;);
  puts (str);
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;结果：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2230905/202102/2230905-20210209230755279-1071686672.png&quot; alt=&quot;&quot; width=&quot;655&quot; height=&quot;42&quot; loading=&quot;lazy&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; 注意：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;memmove和memcpy的差别就是memmove函数处理的源内存块和目标内存块是可以重叠的。

如果源空间和目标空间出现重叠，就得使用memmove函数处理。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;模拟实现：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt;* my_memmove(&lt;span&gt;void&lt;/span&gt;* dest, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;*&lt;span&gt;src, size_t count)
{
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;* ret =&lt;span&gt; dest;
    assert(dest &lt;/span&gt;&amp;amp;&amp;amp;&lt;span&gt; src);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (dest &amp;lt;&lt;span&gt; src)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;前-&amp;gt;后&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt; (count--&lt;span&gt;)
        {
            &lt;/span&gt;*(&lt;span&gt;char&lt;/span&gt;*)dest = *(&lt;span&gt;char&lt;/span&gt;*&lt;span&gt;)src;
            &lt;/span&gt;++(&lt;span&gt;char&lt;/span&gt;*&lt;span&gt;)dest;
            &lt;/span&gt;++(&lt;span&gt;char&lt;/span&gt;*&lt;span&gt;)src;
        }
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;后-&amp;gt;前&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt; (count--&lt;span&gt;)
        {
            &lt;/span&gt;*((&lt;span&gt;char&lt;/span&gt;*)dest + count) = *((&lt;span&gt;char&lt;/span&gt;*)src +&lt;span&gt; count);
        }
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.memset&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;介绍：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2230905/202102/2230905-20210209231144072-575927592.png&quot; alt=&quot;&quot; width=&quot;864&quot; height=&quot;451&quot; loading=&quot;lazy&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; 示例：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;.h&amp;gt;

&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main ()
{
  &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; str[] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;almost every programmer should know memset!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
  memset (str,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;&lt;span&gt;);
  puts (str);
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;结果：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2230905/202102/2230905-20210209231327908-457058706.png&quot; alt=&quot;&quot; width=&quot;834&quot; height=&quot;52&quot; loading=&quot;lazy&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; 模拟实现：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; * Memset(&lt;span&gt;void&lt;/span&gt;* src, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; ch, size_t count)
{
    assert(src &lt;/span&gt;!=&lt;span&gt; NULL);
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;* start =&lt;span&gt; src;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (count--&lt;span&gt;)
    {
        &lt;/span&gt;*(&lt;span&gt;char&lt;/span&gt;*)src = (&lt;span&gt;char&lt;/span&gt;&lt;span&gt;)ch;
        src &lt;/span&gt;= (&lt;span&gt;char&lt;/span&gt;*)src + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; start;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;4.memcmp&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;介绍：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2230905/202102/2230905-20210209231609020-167881257.png&quot; alt=&quot;&quot; width=&quot;731&quot; height=&quot;492&quot; loading=&quot;lazy&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; 示例：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;.h&amp;gt;

&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main ()
{
  &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; buffer1[] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DWgaOtP12df0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; buffer2[] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DWGAOTP12DF0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

  &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n;

  n&lt;/span&gt;=memcmp ( buffer1, buffer2, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(buffer1) );

  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (n&amp;gt;&lt;span&gt;0&lt;/span&gt;) printf (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;'%s' is greater than '%s'.\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,buffer1,buffer2);
  &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (n&amp;lt;&lt;span&gt;0&lt;/span&gt;) printf (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;'%s' is less than '%s'.\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,buffer1,buffer2);
  &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; printf (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;'%s' is the same as '%s'.\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,buffer1,buffer2);

  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;结果：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2230905/202102/2230905-20210209231740156-168512151.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; 注意：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比较从ptr1和ptr2指针开始的num个字节&lt;/p&gt;
&lt;p&gt;返回值同strcmp&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;模拟实现：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; my_memcmp(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;* p1, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;* p2, size_t count)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;方法1&lt;/span&gt;
&lt;span&gt;{
    assert(p1);
    assert(p2);
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;* dest = (&lt;span&gt;char&lt;/span&gt;*&lt;span&gt;)p1;
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;* src = (&lt;span&gt;char&lt;/span&gt;*&lt;span&gt;)p2;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (count-- &amp;amp;&amp;amp; (*dest++ == *src++&lt;span&gt;))
    {
        ;
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (count == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; *dest - *&lt;span&gt;src;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;&lt;strong&gt;若有有错之处，还望大家多多指点！！！&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;本次讲解就到这了，&lt;/h3&gt;
&lt;h3&gt;如果大家对于函数的模拟实现都能掌握，那么大家肯定对于上述函数有了深刻的理解。&lt;/h3&gt;

</description>
<pubDate>Tue, 09 Feb 2021 15:26:00 +0000</pubDate>
<dc:creator>guguguhuha</dc:creator>
<og:description>一些库函数的模拟与使用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/guguguhuha/p/14393955.html</dc:identifier>
</item>
<item>
<title>在Blazor Server 项目中使用 EF Core Sqlite - kqw</title>
<link>http://www.cnblogs.com/kqw/p/14394564.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kqw/p/14394564.html</guid>
<description>&lt;p&gt;按照教程创建了一个 Blazor Server 项目&lt;/p&gt;



&lt;p&gt;首页在启动时，从MenuService  获取菜谱列表&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
menus = &lt;span&gt;await&lt;/span&gt; Mmservise.GetMenuAsync(DateTime.Now);
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;做组件时候，MenuService是这样写的&lt;/p&gt;
&lt;div readability=&quot;23.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MenuService
    {
 
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;  Task&amp;lt; List&amp;lt;Menu&amp;gt; &amp;gt;&lt;span&gt; GetMenuAsync(DateTime startDate)
        {
 
            List&lt;/span&gt;&amp;lt;Menu&amp;gt; meuns = &lt;span&gt;new&lt;/span&gt; List&amp;lt;Menu&amp;gt;&lt;span&gt;();
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;[] days = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2021-02-06&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2021-02-07&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2021-02-08&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; rng = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Random();
 
            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt; daystr &lt;span&gt;in&lt;/span&gt;&lt;span&gt; days)
            {
                Menu a &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Menu { ID = Guid.NewGuid(), Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;红烧鱼&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, MenuDay = Convert.ToDateTime(daystr), DefaultNamber = &lt;span&gt;1&lt;/span&gt;, Price = rng.Next(&lt;span&gt;5&lt;/span&gt;, &lt;span&gt;30&lt;/span&gt;), Type = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;午餐&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
                Menu b &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Menu { ID = Guid.NewGuid(), Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;大盘鸡&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, MenuDay = Convert.ToDateTime(daystr), DefaultNamber = &lt;span&gt;1&lt;/span&gt;, Price = rng.Next(&lt;span&gt;5&lt;/span&gt;, &lt;span&gt;30&lt;/span&gt;), Type = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;午餐&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
                Menu c &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Menu { ID = Guid.NewGuid(), Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;烤肉&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, MenuDay = Convert.ToDateTime(daystr), DefaultNamber = &lt;span&gt;1&lt;/span&gt;, Price = rng.Next(&lt;span&gt;5&lt;/span&gt;, &lt;span&gt;30&lt;/span&gt;), Type = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;午餐&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
                Menu d &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Menu { ID = Guid.NewGuid(), Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;油条豆浆&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, MenuDay = Convert.ToDateTime(daystr), DefaultNamber = &lt;span&gt;1&lt;/span&gt;, Price = rng.Next(&lt;span&gt;5&lt;/span&gt;, &lt;span&gt;30&lt;/span&gt;), Type = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;早餐&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
                Menu e &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Menu { ID = Guid.NewGuid(), Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;炸酱面&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, MenuDay = Convert.ToDateTime(daystr), DefaultNamber = &lt;span&gt;1&lt;/span&gt;, Price = rng.Next(&lt;span&gt;5&lt;/span&gt;, &lt;span&gt;30&lt;/span&gt;), Type = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;晚餐&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
 
                meuns.Add(a);
                meuns.Add(b);
                meuns.Add(c);
                meuns.Add(d);
                meuns.Add(e);
            }
 
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Task.FromResult(meuns);
 
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;在 陈超超 的教程里，是新建立了  WebAPI接口 给 APP 提供后台支持， 我想着既然已经是 Blazor Server 项目了，能不能直接在 Server 用 EF 呢。&lt;/p&gt;

&lt;p&gt;尝试过程：&lt;/p&gt;
&lt;p&gt;1） 创建 DbContext&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BlazorApp0206Context: DbContext
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DbSet&amp;lt;Menu&amp;gt; Menus { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
 
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnConfiguring(DbContextOptionsBuilder options)
            &lt;/span&gt;=&amp;gt; options.UseSqlite(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Data Source=BlazorApp0206.db&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;2）迁移数据库&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Install-&lt;span&gt;Package Microsoft.EntityFrameworkCore.Tools
Add&lt;/span&gt;-&lt;span&gt;Migration InitialCreate0209
Update&lt;/span&gt;-Database
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt; 3）修改 MenuService&lt;/p&gt;

&lt;div readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MenuService
    {
 
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;  Task&amp;lt; List&amp;lt;Menu&amp;gt; &amp;gt;&lt;span&gt; GetMenuAsync(DateTime startDate)
        {
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; db = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BlazorApp0206Context())
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; meuns = db.Menus.ToList&amp;lt;Menu&amp;gt;&lt;span&gt;();
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Task.FromResult(meuns);
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;4） 工作目录不一致 的问题，直接照抄文档：&lt;/p&gt;
&lt;div readability=&quot;8.7677725118483&quot;&gt;运行 .NET Core 控制台应用时，Visual Studio 使用不一致的工作目录。 （请参阅 &lt;a href=&quot;https://github.com/dotnet/project-system/issues/3619&quot;&gt;dotnet/project-system#3619&lt;/a&gt;）这会导致引发异常： 无此类表格：博客 。 更新工作目录：&lt;/div&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;右键单击项目，并选择“编辑项目文件”&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;p&gt;在 TargetFramework 属性下方，添加以下内容：&lt;/p&gt;
&lt;p&gt;XML&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;&amp;lt;StartWorkingDirectory&amp;gt;$(MSBuildProjectDirectory)&amp;lt;/StartWorkingDirectory&amp;gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;p&gt;保存该文件&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;现在可以运行应用：&lt;/p&gt;
&lt;p&gt;“调试”&amp;gt;“开始执行(不调试)”&lt;/p&gt;

&lt;p&gt;最后来个截图&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/28621/202102/28621-20210209230937407-788509432.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/div&gt;

&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;https://docs.microsoft.com/zh-cn/aspnet/core/blazor/blazor-server-ef-core?view=aspnetcore-5.0&lt;/p&gt;
&lt;p&gt;https://docs.microsoft.com/zh-cn/ef/core/get-started/overview/first-app?tabs=visual-studio&lt;/p&gt;
&lt;p&gt;https://www.cnblogs.com/MSReactor/p/14380219.html&lt;/p&gt;

</description>
<pubDate>Tue, 09 Feb 2021 15:15:00 +0000</pubDate>
<dc:creator>kqw</dc:creator>
<og:description>按照教程创建了一个&amp;#160;Blazor Server 项目 教程地址：&amp;#160;https://docs.microsoft.com/zh-cn/aspnet/core/tutorials/bu</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kqw/p/14394564.html</dc:identifier>
</item>
</channel>
</rss>