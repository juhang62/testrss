<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>玩转 SpringBoot 2 之整合 JWT 上篇 - 桌前明月</title>
<link>http://www.cnblogs.com/jerry126/p/11621352.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jerry126/p/11621352.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;该文主要带你了解什么是 JWT，以及JWT 定义和先关概念的介绍，并通过简单Demo 带你了解如何使用 SpringBoot 2 整合 JWT。&lt;br/&gt;介绍前在这里我们来探讨一下如何学习一门新的技术，我个人总结为 &lt;strong&gt;RSA&lt;/strong&gt;。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;R：read 去读官方文档 。&lt;/li&gt;
&lt;li&gt;S：search 谷歌或百度先关技术文章或 github 去搜索先关信息。&lt;/li&gt;
&lt;li&gt;A：ask 可以向技术大牛请教或和自己的同事同学进行探讨。&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;关于 &lt;strong&gt;RSA&lt;/strong&gt; 仅仅代码个人的学习观点，只是给读者一个不成熟的小建议哈&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;jwt-介绍&quot;&gt;JWT 介绍&lt;/h2&gt;
&lt;p&gt;官网介绍如下：&lt;/p&gt;
&lt;blockquote readability=&quot;10.887755102041&quot;&gt;
&lt;p&gt;What is JSON Web Token?&lt;br/&gt;JSON Web Token (JWT) is an open standard (&lt;a href=&quot;https://tools.ietf.org/html/rfc7519&quot;&gt;RFC 7519&lt;/a&gt;) that defines a compact and self-contained way for securely transmitting information between parties as a JSON object. This information can be verified and trusted because it is digitally signed. JWTs can be signed using a secret (with the &lt;strong&gt;HMAC&lt;/strong&gt; algorithm) or a public/private key pair using &lt;strong&gt;RSA&lt;/strong&gt; or &lt;strong&gt;ECDSA&lt;/strong&gt;.&lt;br/&gt;Although JWTs can be encrypted to also provide secrecy between parties, we will focus on &lt;em&gt;signed&lt;/em&gt; tokens. Signed tokens can verify the &lt;em&gt;integrity&lt;/em&gt; of the claims contained within it, while encrypted tokens &lt;em&gt;hide&lt;/em&gt; those claims from other parties. When tokens are signed using public/private key pairs, the signature also certifies that only the party holding the private key is the one that signed it.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;中文翻译：&lt;br/&gt;JSON Web令牌（JWT）是一个开放标准（RFC 7519），它定义了一种紧凑的、自包含的方式，用于在各方之间作为JSON对象安全地传输信息。该信息可以被验证和信任，因为它是数字签名的。JWTS可以使用秘密（使用HMAC算法）或公钥/私钥对使用RSA或ECDSA来签名。&lt;br/&gt;虽然JWTS可以加密，但也提供保密各方之间，我们将重点放在签名令牌。签名的令牌可以验证包含在其中的声明的完整性，而加密的令牌隐藏这些声明以防其他各方。当令牌使用公钥/私钥对签名时，签名也证明只有持有私钥的方才是签名的方。&lt;/p&gt;
&lt;h2 id=&quot;jwt-先关概念介绍&quot;&gt;JWT 先关概念介绍&lt;/h2&gt;
&lt;p&gt;使用 JWT 前需要先了解三块内容：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;头部信息&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;载荷信息&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;签名信息&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;头部信息&quot;&gt;头部信息&lt;/h3&gt;
&lt;p&gt; 头部信息由2部分组成&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;令牌的类型，即 JWT&lt;/li&gt;
&lt;li&gt;使用的签名算法 ，例如HMACSHA256或RSA。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;头部信息 JSON 代码如下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;{
  &quot;alg&quot;: &quot;HS256&quot;,
  &quot;typ&quot;: &quot;JWT&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后，这个JSON被编码为 &lt;strong&gt;Base64Url&lt;/strong&gt;，形成 JWT 的第一部分。&lt;/p&gt;
&lt;h3 id=&quot;载荷信息&quot;&gt;载荷信息&lt;/h3&gt;
&lt;p&gt;其中包含声明（claims），声明可以存放实体（通常是用户）和其他数据的声明，声明包括3种类型&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;已注册声明&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;公开声明&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;私有声明&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;已注册声明&lt;/strong&gt;&lt;br/&gt;这些是一组预定义声明，不是强制性的，但建议使用，以提供一组有用的，可互操作的声明。其中一些是：&lt;strong&gt; iss&lt;/strong&gt;（发行人），&lt;strong&gt; exp&lt;/strong&gt;（到期时间），&lt;strong&gt;sub&lt;/strong&gt;（主题），&lt;strong&gt; aud&lt;/strong&gt;（观众）&lt;a href=&quot;https://tools.ietf.org/html/rfc7519#section-4.1&quot;&gt;等&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;公开声明&lt;/strong&gt;&lt;br/&gt;可以参考 IANA JSON Web令牌注册表https://www.iana.org/assignments/jwt/jwt.xhtml) 查看公共的声明&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;私有声明&lt;/strong&gt;&lt;br/&gt;根据根据自己的业务需要自定义的一些数据格式。&lt;br/&gt;示例有效负载可以是：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;{

&quot;sub&quot;: &quot;1234567890&quot;,

&quot;name&quot;: &quot;John Doe&quot;,

&quot;admin&quot;: true

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/836175/201910/836175-20191004085455066-1563972116.gif&quot; alt=&quot;图片&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;签名信息&quot;&gt;签名信息&lt;/h3&gt;
&lt;p&gt; 这个部分需要 base64 加密后的 头部信息（header） 和 base64 加密后的载荷信息（payload），使用连接组成的字符串，然后通过头部信息（header）中声明的加密方式进行加盐 secret 组合在加密，然后就构成了 JWT 的第三部分。&lt;br/&gt;例如，如果要使用HMAC SHA256算法，将按以下方式创建签名：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;HMACSHA256(base64UrlEncode(header) + &quot;.&quot; +base64UrlEncode(payload),secret)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;jwt-简单实用演示介绍&quot;&gt;JWT 简单实用演示介绍&lt;/h2&gt;
&lt;p&gt;首先去 JWT 官网一探究竟，访问 &lt;a href=&quot;https://jwt.io&quot; class=&quot;uri&quot;&gt;https://jwt.io&lt;/a&gt; 进入 JWT 官网。接下来我们开始学习如果使用JWT，通过点击上图中 &lt;strong&gt;LEARN MORE ABOUT JW&lt;/strong&gt;T 显示如下图：然后点击&lt;strong&gt;START USING THE TOOL。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/836175/201910/836175-20191004085455374-1129217648.png&quot; alt=&quot;图片&quot;/&gt;[图片]&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/836175/201910/836175-20191004085455738-345550510.png&quot; alt=&quot;图片&quot;/&gt;[图片]&lt;/p&gt;
&lt;p&gt;如下图所示 选择对应的语言的 JWT 使用教程。我们这里介绍是是 标注有：&lt;strong&gt;maven:com.auth0 java-jwt&lt;/strong&gt; 的版本。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/836175/201910/836175-20191004085456096-163373836.png&quot; alt=&quot;图片&quot;/&gt;&lt;/p&gt;
&lt;p&gt;查看 JWT GitHub 示例教程和源码。 &lt;a href=&quot;https://github.com/auth0/java-jwt&quot; class=&quot;uri&quot;&gt;https://github.com/auth0/java-jwt&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/836175/201910/836175-20191004085456388-822447213.png&quot; alt=&quot;图片&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在README.md 文件中有使用介绍和示例程序。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/836175/201910/836175-20191004085456763-625396289.png&quot; alt=&quot;图片&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/836175/201910/836175-20191004085457136-1547557210.png&quot; alt=&quot;图片&quot;/&gt;&lt;/p&gt;
&lt;p&gt;GitHub 上的示例相对简单些，接下来我带大家写一个相对详细的Demo。&lt;/p&gt;
&lt;p&gt;第一步在SpringBoot 应用中引入JWT 依赖到pom.xml中&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.auth0&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;java-jwt&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;3.4.1&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们通过三个方法来演示如何使用JWT&lt;/p&gt;
&lt;ol readability=&quot;-2&quot;&gt;&lt;li&gt;createToken() 创建不携带自定义信息的 token&lt;/li&gt;
&lt;li&gt;createTokenWithClaim() 创建携带自定义信息的 token&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;verifyToken() 验证我们的token信息并解析token中的内容&lt;/p&gt;
&lt;h3 id=&quot;生成不携带自定义信息-jwt-token&quot;&gt;生成不携带自定义信息 JWT token&lt;/h3&gt;
第一步：构建头部信息&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Map&amp;lt;String, Object&amp;gt; map = new HashMap&amp;lt;String, Object&amp;gt;();
map.put(&quot;alg&quot;, &quot;HS256&quot;);
map.put(&quot;typ&quot;, &quot;JWT&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二步：构建密钥信息 &lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Algorithm algorithm = Algorithm.HMAC256(&quot;secret&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt; 第三步：我们通过定义注册和自定义声明 并组合头部信息和密钥信息生成jwt token&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;String token = JWT.create()
   .withHeader(map)// 设置头部信息 Header 
   .withIssuer(&quot;SERVICE&quot;)//设置 载荷 签名是有谁生成 例如 服务器
   .withSubject(&quot;this is test token&quot;)//设置 载荷 签名的主题
   // .withNotBefore(new Date())//设置 载荷 定义在什么时间之前，该jwt都是不可用的.
   .withAudience(&quot;APP&quot;)//设置 载荷 签名的观众 也可以理解谁接受签名的
   .withIssuedAt(nowDate) //设置 载荷 生成签名的时间
   .withExpiresAt(expireDate)//设置 载荷 签名过期的时间
   .sign(algorithm);//签名 Signature&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;详细代码如下：&lt;br/&gt;```java&lt;br/&gt;@Test&lt;br/&gt;public void createToken() {&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    String secret = &quot;secret&quot;;// token 密钥
    Algorithm algorithm = Algorithm.HMAC256(&quot;secret&quot;);

    // 头部信息
    Map&amp;lt;String, Object&amp;gt; map = new HashMap&amp;lt;String, Object&amp;gt;();
    map.put(&quot;alg&quot;, &quot;HS256&quot;);
    map.put(&quot;typ&quot;, &quot;JWT&quot;);

    Date nowDate = new Date();
    Date expireDate = getAfterDate(nowDate, 0, 0, 0, 2, 0, 0);// 2小过期
    
    String token = JWT.create()
        .withHeader(map)// 设置头部信息 Header 
        .withIssuer(&quot;SERVICE&quot;)//设置 载荷 签名是有谁生成 例如 服务器
        .withSubject(&quot;this is test token&quot;)//设置 载荷 签名的主题
        // .withNotBefore(new Date())//设置 载荷 定义在什么时间之前，该jwt都是不可用的.
        .withAudience(&quot;APP&quot;)//设置 载荷 签名的观众 也可以理解谁接受签名的
        .withIssuedAt(nowDate) //设置 载荷 生成签名的时间
        .withExpiresAt(expireDate)//设置 载荷 签名过期的时间
        .sign(algorithm);//签名 Signature
    Assert.assertTrue(token.length() &amp;gt; 0);
}
```&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;生成携带自定义信息-jwt-token&quot;&gt;生成携带自定义信息 JWT token&lt;/h2&gt;
&lt;p&gt;自定义信息通过 withClaim 方法进行添加，具体操作如下：&lt;br/&gt;&lt;code&gt;java JWT.create() .withHeader(map) .withClaim(&quot;loginName&quot;, &quot;zhuoqianmingyue&quot;) .withClaim(&quot;userName&quot;, &quot;张三&quot;) .withClaim(&quot;deptName&quot;, &quot;技术部&quot;)&lt;/code&gt;&lt;br/&gt;生成携带自定义信息 JWT token 详细代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @Test
    public String createTokenWithChineseClaim() {

        Date nowDate = new Date();
        Date expireDate = getAfterDate(nowDate, 0, 0, 0, 2, 0, 0);// 2小过期

        Map&amp;lt;String, Object&amp;gt; map = new HashMap&amp;lt;String, Object&amp;gt;();
        map.put(&quot;alg&quot;, &quot;HS256&quot;);
        map.put(&quot;typ&quot;, &quot;JWT&quot;);

        Algorithm algorithm = Algorithm.HMAC256(&quot;secret&quot;);
        String token = JWT.create().withHeader(map)
                /* 设置 载荷 Payload */
                .withClaim(&quot;loginName&quot;, &quot;zhuoqianmingyue&quot;).withClaim(&quot;userName&quot;, &quot;张三&quot;).withClaim(&quot;deptName&quot;, &quot;技术部&quot;)
                .withIssuer(&quot;SERVICE&quot;)// 签名是有谁生成 例如 服务器
                .withSubject(&quot;this is test token&quot;)// 签名的主题
                // .withNotBefore(new Date())//定义在什么时间之前，该jwt都是不可用的
                .withAudience(&quot;APP&quot;)// 签名的观众 也可以理解谁接受签名的
                .withIssuedAt(nowDate) // 生成签名的时间
                .withExpiresAt(expireDate)// 签名过期的时间
                /* 签名 Signature */
                .sign(algorithm);
        
        Assert.assertTrue(token.length() &amp;gt; 0);
        return token;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;验证-jwt-token&quot;&gt;验证 JWT Token&lt;/h2&gt;
&lt;p&gt;第一步：构建密钥信息&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; Algorithm algorithm = Algorithm.HMAC256(&quot;secret&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt; 第二步：通过密钥信息和签名的发布者的信息生成JWTVerifier (JWT验证类) &lt;br/&gt;&lt;code&gt;java JWTVerifier verifier = JWT.require(algorithm) .withIssuer(&quot;SERVICE&quot;) .build(); Algorithm algorithm = Algorithm.HMAC256(&quot;secret&quot;);&lt;/code&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;不添加 .withIssuer(&quot;SERVICE&quot;) 也是可以获取 JWTVerifier 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;第三步：通过JWTVerifier 的verify获取 token中的信息。 &lt;br/&gt;&lt;code&gt;java DecodedJWT jwt = verifier.verify(token);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如下面代码所示就可以获取到我们之前生成 token 的 签名的主题，观众 和自定义的声明信息。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;String subject = jwt.getSubject();
List&amp;lt;String&amp;gt; audience = jwt.getAudience();
Map&amp;lt;String, Claim&amp;gt; claims = jwt.getClaims();
for (Entry&amp;lt;String, Claim&amp;gt; entry : claims.entrySet()) {
   String key = entry.getKey();
   Claim claim = entry.getValue();
   System.out.println(&quot;key:&quot;+key+&quot; value:&quot;+claim.asString());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;验证 JWT Token 详细代码如下：&lt;br/&gt;```java&lt;br/&gt;@Test&lt;br/&gt;public void verifyToken() throws UnsupportedEncodingException {&lt;br/&gt;String token = createTokenWithChineseClaim2();&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    Algorithm algorithm = Algorithm.HMAC256(&quot;secret&quot;);
    JWTVerifier verifier = JWT.require(algorithm).withIssuer(&quot;SERVICE&quot;).build(); // Reusable verifier instance
    DecodedJWT jwt = verifier.verify(token);
    
    String subject = jwt.getSubject();
    List&amp;lt;String&amp;gt; audience = jwt.getAudience();
    Map&amp;lt;String, Claim&amp;gt; claims = jwt.getClaims();
    for (Entry&amp;lt;String, Claim&amp;gt; entry : claims.entrySet()) {
        String key = entry.getKey();
        Claim claim = entry.getValue();
        log.info(&quot;key:&quot; + key + &quot; value:&quot; + claim.asString());
    }
    Claim claim = claims.get(&quot;loginName&quot;);

    log.info(claim.asString());
    log.info(subject);
    log.info(audience.get(0));

}
public String createTokenWithChineseClaim2() throws UnsupportedEncodingException {

    Date nowDate = new Date();
    Date expireDate = getAfterDate(nowDate, 0, 0, 0, 2, 0, 0);// 2小过期

    Map&amp;lt;String, Object&amp;gt; map = new HashMap&amp;lt;String, Object&amp;gt;();
    map.put(&quot;alg&quot;, &quot;HS256&quot;);
    map.put(&quot;typ&quot;, &quot;JWT&quot;);

    User user = new User();
    user.setUserNaem(&quot;张三&quot;);
    user.setDeptName(&quot;技术部&quot;);
    Gson gson = new Gson();
    String userJson = gson.toJson(user);

    String userJsonBase64 = BaseEncoding.base64().encode(userJson.getBytes());

    Algorithm algorithm = Algorithm.HMAC256(&quot;secret&quot;);
    String token = JWT.create().withHeader(map)

            .withClaim(&quot;loginName&quot;, &quot;zhuoqianmingyue&quot;).withClaim(&quot;user&quot;, userJsonBase64).withIssuer(&quot;SERVICE&quot;)// 签名是有谁生成
            .withSubject(&quot;this is test token&quot;)// 签名的主题
            // .withNotBefore(new Date())//该jwt都是不可用的时间
            .withAudience(&quot;APP&quot;)// 签名的观众 也可以理解谁接受签名的
            .withIssuedAt(nowDate) // 生成签名的时间
            .withExpiresAt(expireDate)// 签名过期的时间
            .sign(algorithm);//签名 Signature

    return token;
}
```&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;JWT 就是一个生成 Token 的工具，如果不使用 JWT 我们也可以根据自己加密规则生成 Token。只不过 JWT 规范了生成 Token 定义了一个标准而已。JWT 的核心的功能就是:生成Token、解析Token。在 玩转 SpringBoot 2 之整合 JWT 下篇中将带大家通过一个接口登录的案例简单介绍 JWT 实战操作。&lt;/p&gt;
&lt;h2 id=&quot;代码示例&quot;&gt;代码示例&lt;/h2&gt;
&lt;p&gt;具体代码示例请查看我的GitHub 仓库 springbootexamples 中的 spring-boot-2.x-jwt 下 src/test/java JWTDemo.java文件。&lt;/p&gt;
&lt;p&gt;GitHub：https://github.com/zhuoqianmingyue/springbootexamples&lt;/p&gt;
&lt;h2 id=&quot;参考文献&quot;&gt;参考文献&lt;/h2&gt;
&lt;p&gt;https://jwt.io/introduction/&lt;br/&gt;https://github.com/auth0/java-jwt&lt;/p&gt;
</description>
<pubDate>Fri, 04 Oct 2019 00:55:00 +0000</pubDate>
<dc:creator>桌前明月</dc:creator>
<og:description>前言 该文主要带你了解什么是 JWT，以及JWT 定义和先关概念的介绍，并通过简单Demo 带你了解如何使用 SpringBoot 2 整合 JWT。 介绍前在这里我们来探讨一下如何学习一门新的技术，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jerry126/p/11621352.html</dc:identifier>
</item>
<item>
<title>玩转 SpringBoot 2 快速整合拦截器 - 桌前明月</title>
<link>http://www.cnblogs.com/jerry126/p/11621350.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jerry126/p/11621350.html</guid>
<description>&lt;h2 id=&quot;概述&quot;&gt;概述&lt;/h2&gt;
&lt;p&gt;首先声明一下，这里所说的拦截器是 SpringMVC 的拦截器 HandlerInterceptor。使用SpringMVC 拦截器需要做如下操作：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;创建拦截器类需要实现 HandlerInterceptor&lt;/li&gt;
&lt;li&gt;在 xml 配置文件中配置该拦截器，具体配置代码如下：&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;mvc:interceptors&amp;gt;
    &amp;lt;mvc:interceptor&amp;gt;
    &amp;lt;!-- /test/** 这个是拦截路径以/test开头的所有的URL--&amp;gt;
    &amp;lt;mvc:mapping path=&quot;/**&quot;/&amp;gt;&amp;lt;!—这个是拦截说有的路径--&amp;gt;
    &amp;lt;!-- 配置拦截器类路径--&amp;gt;
    &amp;lt;bean class=&quot;cn.ljk.springmvc.controller.MyInterceptor&quot;&amp;gt;&amp;lt;/bean&amp;gt;
    &amp;lt;!-- 配置不拦截器URL路径--&amp;gt;
    &amp;lt;mvc:exclude-mapping path=&quot;/fore/**&quot;/&amp;gt;
    &amp;lt;/mvc:interceptor&amp;gt;
&amp;lt;/mvc:interceptors&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为在SpringBoot 中没有 xml 文件，所以SpringBoot 为我们提供 Java Config 的方式来配置拦截器。配置方式有2种：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;继承 WebMvcConfigurerAdapter （官方已经不建议使用）&lt;/li&gt;
&lt;li&gt;实现 WebMvcConfigurer&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;接下来开始 SpringBoot 整合拦截器操作详细介绍！&lt;/p&gt;
&lt;h2 id=&quot;整合拦截器实战操作&quot;&gt;整合拦截器实战操作&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;第一步：声明拦截器类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过实现 HandlerInterceptor 来完成。具体代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class LoginInterceptor implements HandlerInterceptor{}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;第二步：实现 HandlerInterceptor 3 个拦截方法&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;preHandle：Controller逻辑执行之前进行拦截&lt;/li&gt;
&lt;li&gt;postHandle：Controller逻辑执行完毕但是视图解析器还为进行解析之前进行拦截&lt;/li&gt;
&lt;li&gt;afterCompletion：Controller逻辑和视图解析器执行完毕进行拦截&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;实际开发中 preHandle使用频率比较高，postHandle 和 afterCompletion操作相对比较少。&lt;/p&gt;
&lt;p&gt;在下面的代码中 preHandle 方法中定义拦截所有访问项目 URL并进行日志信息记录。postHandle 中在视图解析前进行拦截，通过 Model 在次添加数据Request域中。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;afterCompletion 暂时没有想到使用场景，如果有使用过的场景可以在下面评论区中进行评论。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;拦截器详细代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class LoginInterceptor implements HandlerInterceptor{
    
    private Logger log = LoggerFactory.getLogger(LoginInterceptor.class);
    
    //ControllerController逻辑执行之前
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        log.info(&quot;preHandle....&quot;);
        String uri = request.getRequestURI();
        log.info(&quot;uri：&quot;+ uri);
        if (handler instanceof HandlerMethod) {
            HandlerMethod handlerMethod = (HandlerMethod) handler;
            log.info(&quot;拦截 Controller：&quot;+ handlerMethod.getBean().getClass().getName());
            log.info(&quot;拦截方法：&quot;+handlerMethod.getMethod().getName());
        }
        
        return true;
    }
    
    //Controller逻辑执行完毕但是视图解析器还为进行解析之前
    @Override
    public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception {
        log.info(&quot;postHandle....&quot;);
        Map&amp;lt;String,Object&amp;gt;map=modelAndView.getModel();
        map.put(&quot;msg&quot;,&quot;postHandle add msg&quot;);
    }
    
    //Controller逻辑和视图解析器执行完毕
    @Override
    public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception {
        log.info(&quot;afterCompletion....&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;第三步：Java Config 的方式来配置拦截器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;继承 WebMvcConfigurerAdapter 方式&lt;/p&gt;
&lt;p&gt;通过继承 WebMvcConfigurerAdapter并重写 addInterceptors方法，通过其参数 InterceptorRegistry将拦截器注入到 Spring的上下文中。&lt;/p&gt;
&lt;p&gt;另外拦截路径和不拦截的路径通过InterceptorRegistry 的 addPathPatterns和 excludePathPatterns方法进行设置。&lt;/p&gt;
&lt;p&gt;这种方式官方已经不建议使用，因为官方已将 WebMvcConfigurerAdapter 标记为@Deprecated 了。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Deprecated
public abstract class WebMvcConfigurerAdapter implements WebMvcConfigurer {&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;继承 WebMvcConfigurerAdapter 方式具体代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Configuration
    public class InterceptorConfigByExtendsWebMvcConfigurerAdapter extends  WebMvcConfigurerAdapter{

    @Bean
        public LoginInterceptor loginInterceptor(){
                return new LoginInterceptor();
        }

        public void addInterceptors(InterceptorRegistry registry) {
                registry.addInterceptor(loginInterceptor()).addPathPatterns(&quot;/**&quot;).excludePathPatterns(&quot;/*.html&quot;);
        }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实现 WebMvcConfigurer 方式&lt;/p&gt;
&lt;p&gt;通过实现 WebMvcConfigurer 接口并实现 addInterceptors方法，其他操作和继承 WebMvcConfigurerAdapter方式一样。具体代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;```java
@Configuration
public class InterceptorConfigByImplWebMvcConfigurer implements WebMvcConfigurer{
    
    @Bean
    public LoginInterceptor loginInterceptor(){
        return new LoginInterceptor();
    }
     @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(loginInterceptor()).addPathPatterns(&quot;/**&quot;).excludePathPatterns(&quot;/*.html&quot;);
    }
}
```&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;测试&quot;&gt;测试&lt;/h2&gt;
&lt;p&gt;编写普通Controller，具体代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Controller
public class IndexController {
    
    @GetMapping(&quot;/index&quot;)
    public String index(ModelAndView modelAndView){
        
        return &quot;index&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 src/main/resource 下的 templates目录下创建 IndexController访问页面 index.ftl， 代码如下：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;h1&amp;gt;${msg}&amp;lt;/h1&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于我这里使用的是 Freemarker当页面使用，说以需要引入 Freemarker starter依赖，具体点如下：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-freemarker&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过游览器访问 localhost:8080/sbe/index，具体访问效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/836175/201910/836175-20191004085234652-881468879.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如上图所示在视图解析前通过 Model在次添加数据到 Request域中的msg 成功显示出来了！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;日志输出信息如下：拦截地址和拦截Controller 和具体方法进行日志输出&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;2019-09-24 15:53:04.144  INFO 7732 --- [nio-8080-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/sbe]    : Initializing Spring DispatcherServlet 'dispatcherServlet'
2019-09-24 15:53:04.145  INFO 7732 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : Initializing Servlet 'dispatcherServlet'
2019-09-24 15:53:04.153  INFO 7732 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : Completed initialization in 8 ms
2019-09-24 15:53:04.155  INFO 7732 --- [nio-8080-exec-1] c.lijunkui.interceptor.LoginInterceptor  : preHandle....
2019-09-24 15:53:04.155  INFO 7732 --- [nio-8080-exec-1] c.lijunkui.interceptor.LoginInterceptor  : uri：/sbe/index
2019-09-24 15:53:04.155  INFO 7732 --- [nio-8080-exec-1] c.lijunkui.interceptor.LoginInterceptor  : 拦截 Controller：cn.lijunkui.controller.IndexController
2019-09-24 15:53:04.155  INFO 7732 --- [nio-8080-exec-1] c.lijunkui.interceptor.LoginInterceptor  : 拦截方法：index
2019-09-24 15:53:04.156  INFO 7732 --- [nio-8080-exec-1] c.lijunkui.interceptor.LoginInterceptor  : postHandle....
2019-09-24 15:53:04.161  INFO 7732 --- [nio-8080-exec-1] c.lijunkui.interceptor.LoginInterceptor  : afterCompletion....&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;SpringBoot 2 整合拦截器和整合 Filter的操作很像，都是通过一个注册类将其注入到Spring的上下文中，只不过Filter使用的是 FilterRegistrationBean 而 拦截器使用的是 InterceptorRegistry。&lt;/p&gt;
&lt;p&gt;个人觉得比使用 xml 配置的方式更为简单了，如果你还没有在 SpringBoot 项目中使用过拦截器，赶快来操作一下吧！&lt;/p&gt;
&lt;h2 id=&quot;代码示例&quot;&gt;代码示例&lt;/h2&gt;
&lt;p&gt;具体代码示例请在我的GitHub 仓库 springbootexamples 中模块名为 spring-boot-2.x-interceptor 项目中进行查看&lt;/p&gt;
&lt;p&gt;GitHub：https://github.com/zhuoqianmingyue/springbootexamples&lt;/p&gt;
</description>
<pubDate>Fri, 04 Oct 2019 00:53:00 +0000</pubDate>
<dc:creator>桌前明月</dc:creator>
<og:description>概述 首先声明一下，这里所说的拦截器是 SpringMVC 的拦截器 HandlerInterceptor。使用SpringMVC 拦截器需要做如下操作： 1. 创建拦截器类需要实现 HandlerI</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jerry126/p/11621350.html</dc:identifier>
</item>
<item>
<title>玩转 SpringBoot 2 之整合 JWT 下篇 - 桌前明月</title>
<link>http://www.cnblogs.com/jerry126/p/11621338.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jerry126/p/11621338.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;在&lt;a href=&quot;https://blog.csdn.net/ljk126wy/article/details/82751787&quot;&gt;《玩转 SpringBoot 2 之整合 JWT 上篇》&lt;/a&gt; 中介绍了关于 JWT 相关概念和JWT 基本使用的操作方式。本文为 SpringBoot 整合 JWT 的下篇，通过解决 App 用户登录 Session 问题的实战操作，带你更深入理解 JWT。通过本文你还可以了解到如下内容：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;SpringBoot 使用拦截器的实际应用&lt;/li&gt;
&lt;li&gt;SpringBoot 统一异常处理&lt;/li&gt;
&lt;li&gt;SpringBoot 快速搭建 RESTful Api&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;2.0512820512821&quot;&gt;
&lt;p&gt;关于生成JWT 操作请参考 &lt;a href=&quot;https://blog.csdn.net/ljk126wy/article/details/82751787&quot;&gt;《玩转 SpringBoot 2 之整合 JWT 上篇》&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;实战操作&quot;&gt;实战操作&lt;/h2&gt;
&lt;h3 id=&quot;登录操作&quot;&gt;登录操作&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;登录操作流程图：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/836175/201910/836175-20191004084907380-1626023013.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;登录操作流程介绍：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;App 根据用户名和密码访问登录接口。&lt;/li&gt;
&lt;li&gt;如果用户名和密码错误则提示 App 用户密码输入错误。&lt;/li&gt;
&lt;li&gt;如果用户名和密码正确则获取用户信息（表示登录成功）并根据用户信息生成 Token 并将其存入ServletContext 中。&lt;/li&gt;
&lt;li&gt;将生成的 Token 返回给 App。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;登录操作具体代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RestController
public class LoginController {
    Logger log = LoggerFactory.getLogger(LoginController.class);
    @Autowired
    private JWTService jwtService;
    
    @RequestMapping(&quot;/login&quot;)
    public ReturnMessage&amp;lt;Object&amp;gt; login(String loginName,String password,HttpServletRequest request) {
        if(valid(loginName,password)) {
            ReturnMessageUtil.error(CodeEnum.LOGINNAMEANDPWDERROR);
        }
        
        Map&amp;lt;String,String&amp;gt; userInfo = createUserInfoMap(loginName,password);
        String token = jwtService.createToken(userInfo, 1);
        
        ServletContext context = request.getServletContext();
        context.setAttribute(token, token);
        log.info(&quot;token:&quot;+token);
        return ReturnMessageUtil.sucess(token);
    }
} 

    private Map&amp;lt;String,String&amp;gt; createUserInfoMap(String loginName, String password) {
        Map&amp;lt;String,String&amp;gt; userInfo = new HashMap&amp;lt;String,String&amp;gt;();
        userInfo.put(&quot;loginName&quot;, loginName);
        userInfo.put(&quot;password&quot;, password);
        return userInfo;
    }

    private boolean valid(String loginName, String password) {
        if(Objects.equal(&quot;ljk&quot;, loginName) &amp;amp;&amp;amp; Objects.equal(&quot;123456&quot;, password) ) {
            return true;
        }
        return false;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;拦截操作&quot;&gt;拦截操作&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;拦截操作流程图：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/836175/201910/836175-20191004084907569-988623447.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;拦截操作流程介绍：&lt;/strong&gt;&lt;/p&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li&gt;服务器获取 （App访问具体的Api 时携带的 Token）Token，如果 Token 为空则提示 App Token不能为空。&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果 Token 不为空则从 ServletContext 中获取 Token，如果不存在则提示 App 该Token为非法 Token ！&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果 Token 不为空并且 ServletContext 中存在该Token，需要判断 Token 是否过期。如果未过期则放开拦截。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如果Token 已经过期则提示 App Token已经过期，需要重新登录。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;拦截操作具体代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class LoginInterceptor implements HandlerInterceptor{
    
    Logger log = LoggerFactory.getLogger(LoginInterceptor.class);
    
    private JWTService jwtService;
    
    public LoginInterceptor(JWTService jwtService) {
        this.jwtService = jwtService;
    }
    
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object o) throws Exception {
        
        log.info(&quot;Token Checkout processing&quot;);
        String token = request.getParameter(&quot;token&quot;);
        
        if (StringUtils.isEmpty(token)) {
            throw new JKException(CodeEnum.TOKENISEMPTY);
        }
        
        String tokenInServletContext = (String)request.getServletContext().getAttribute(token);
        if(StringUtils.isEmpty(tokenInServletContext)) {
            throw new JKException(CodeEnum.ILLEGALTOKEN);
        }
        
        try {
             jwtService.verifyToken(token);
        } catch (AlgorithmMismatchException  e) {
            log.error(&quot;Token Checkout processing AlgorithmMismatchException 异常！&quot;+e.getLocalizedMessage());
            throw new JKException(CodeEnum.ILLEGALTOKEN);
        }catch (TokenExpiredException  e) {
            log.info(&quot;token已经过期&quot;);
            throw new JKException(CodeEnum.EXPIRETOKEN);
        }catch (SignatureVerificationException  e) {
            log.error(&quot;Token Checkout processing SignatureVerificationException 异常！&quot;+e.getLocalizedMessage());
            throw new JKException(CodeEnum.ILLEGALTOKEN);
         }catch (Exception e) {
            log.error(&quot;Token Checkout processing 未知异常！&quot;+e.getLocalizedMessage());
            throw e;
        }
        
        return true;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;退出操作&quot;&gt;退出操作&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;退出操作流程介绍：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;访问退出接口并传递登录生成的 Token，然后将 ServletContext中的 Token 删除。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;退出操作具体代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @GetMapping(&quot;/logout&quot;)
    public ReturnMessage&amp;lt;?&amp;gt; logout(String token,String issuer,HttpServletRequest request) {
        ServletContext context = request.getServletContext();
        context.removeAttribute(token);
        return ReturnMessageUtil.sucess();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;公共代码&quot;&gt;公共代码&lt;/h3&gt;
&lt;p&gt;IndexController App 访问测试Api，具体代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RestController
public class IndexController {
    
    @GetMapping(&quot;index&quot;)
    public ReturnMessage index() {
        return ReturnMessageUtil.sucess();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;统一异常次处理的 Handle&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RestControllerAdvice
public class ExceptionHandle {
    private final static Logger logger = LoggerFactory.getLogger(ExceptionHandle.class);
    @ExceptionHandler(value = Exception.class)
    //@ResponseBody
    public ReturnMessage&amp;lt;Object&amp;gt; handle(HttpServletResponse response, Exception exception) {
         response.setCharacterEncoding(&quot;utf-8&quot;);
        if(exception instanceof JKException) {
            JKException sbexception = (JKException)exception;
            return ReturnMessageUtil.error(sbexception.getCode(), sbexception.getMessage());
        }else {
            logger.error(&quot;系统异常 {}&quot;,exception);
            return ReturnMessageUtil.error(-1, &quot;未知异常&quot;+exception.getMessage());
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;JWTService 工具类 代码可以在我的GitHub上进行查看，具体地址请查看下面代码示例章节。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;测试&quot;&gt;测试&lt;/h2&gt;
&lt;p&gt;这里使用PostMan 进行测试，当然你也可以选用你顺手的工具进行测试哈！&lt;/p&gt;
&lt;p&gt;访问 http://localhost:8080/sbe/login?loginName=ljk&amp;amp;password=123456 进行登录获取Token，如下图所示date字段的值就是登录成功后生成的 Token。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/836175/201910/836175-20191004084907747-1189884888.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;访问 http://localhost:8080/sbe/index?token=具体token值，如下图所示访问成功！&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/836175/201910/836175-20191004084907910-1221277334.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果不携带 Token 会提示Token不能为空，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/836175/201910/836175-20191004084908294-946132348.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果输入不存在的 Token 则提示 非法Token！，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/836175/201910/836175-20191004084908436-521629782.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;http://localhost:8080/sbe/logout?token=具体token值 进行退出，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/836175/201910/836175-20191004084908854-1432619467.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;退出后再次使用已经退出的Token 访问，会提示非法Token 如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/836175/201910/836175-20191004084909303-809599314.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;登录操作通过 JWT 生成Token 返回给App，拦截操作（也可以理解成校验操作）通过拦截器（HandlerInterceptor）来进行实现。最后退出操作是通过将Token 保存ServletContent 中，退出其实就是将 Token 从 ServletContent 中删除。&lt;/p&gt;
&lt;p&gt;本文主旨是通过简单实现，带你了解 App 认证过程处理方式，对于拦截部分你也可以通过 Filter 或 Aop 来进行实现。Token 存储也可以考虑使用Redis来实现，还有一个问题就是：JWT 续期问题本文并没有实现（JWT 过期时间延期问题）。这个部分就当成一个作业，欢迎大家在评论区说说你的解决方案？&lt;/p&gt;
&lt;h2 id=&quot;代码示例&quot;&gt;代码示例&lt;/h2&gt;
&lt;p&gt;本文并没有对 JWTService 工具类、统一异常处理、拦截器使用搭建进行详细介绍，如果你想直接查看本文全部源码，请在我的GitHub 仓库 SpringbootExamples 中的 spring-boot-2.x-jwt 模块进行查看。&lt;/p&gt;
&lt;p&gt;GitHub：&lt;a href=&quot;https://github.com/zhuoqianmingyue/springbootexamples&quot; class=&quot;uri&quot;&gt;https://github.com/zhuoqianmingyue/springbootexamples&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;同时你也可以通过查看我关于拦截器、统一异常处理、搭建 RESTful Api 详细教程总结自己完成相关的实现：&lt;/p&gt;
</description>
<pubDate>Fri, 04 Oct 2019 00:49:00 +0000</pubDate>
<dc:creator>桌前明月</dc:creator>
<og:description>前言 在 '《玩转 SpringBoot 2 之整合 JWT 上篇》' 中介绍了关于 JWT 相关概念和JWT 基本使用的操作方式。本文为 SpringBoot 整合 JWT 的下篇，通过解决 App</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jerry126/p/11621338.html</dc:identifier>
</item>
<item>
<title>Python爬虫（一）：爬虫伪装 - 程序员野客</title>
<link>http://www.cnblogs.com/ityard/p/11621311.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ityard/p/11621311.html</guid>
<description>&lt;h2&gt;1 简介&lt;/h2&gt;
&lt;p&gt;对于一些有一定规模或盈利性质比较强的网站，几乎都会做一些防爬措施，防爬措施一般来说有两种：一种是做身份验证，直接把虫子挡在了门口，另一种是在网站设置各种反爬机制，让虫子知难而返。&lt;/p&gt;
&lt;h2&gt;2 伪装策略&lt;/h2&gt;
&lt;p&gt;我们知道即使是一些规模很小的网站通常也会对来访者的身份做一下检查，如验证请求 Headers，而对于那些上了一定规模的网站就更不用说了。因此，为了让我们的爬虫能够成功爬取所需数据信息，我们需要让爬虫进行伪装，简单来说就是让爬虫的行为变得像普通用户访问一样。&lt;/p&gt;
&lt;h3&gt;2.1 Request Headers问题&lt;/h3&gt;
&lt;p&gt;为了演示我使用百度搜索 163邮箱&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1497257/201910/1497257-20191004080221931-1245358228.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用 F12 工具看一下请求信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1497257/201910/1497257-20191004080247732-685750355.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在上图中，我们可以看到 Request Headers 中包含 Referer 和 User-Agent 两个属性信息，Referer 的作用是告诉服务器该网页是从哪个页面链接过来的，User-Agent 中文是用户代理，它是一个特殊字符串头，作用是让服务器能够识别用户使用的操作系统、CPU 类型、浏览器等信息。通常的处理策略是：1）对于要检查 Referer 的网站就加上；2）对于每个 request 都添加 User-Agent。&lt;/p&gt;
&lt;h3&gt;2.2 IP限制问题&lt;/h3&gt;
&lt;p&gt;有时我们可能会对一些网站进行长期或大规模的爬取，而我们在爬取时基本不会变换 IP，有的网站可能会监控一个 IP 的访问频率和次数，一但超过这个阈值，就可能认作是爬虫，从而对其进行了屏蔽，对于这种情况，我们要采取间歇性访问的策略。&lt;/p&gt;
&lt;p&gt;通常我们爬取是不会变换 IP 的，但有时可能会有一些特殊情况，要长时间不间断对某网站进行爬取，这时我们就可能需要采用 IP 代理的方式，但这种方式一般会增加我们开销，也就是可能要多花钱。&lt;/p&gt;
&lt;h2&gt;3 总结&lt;/h2&gt;
&lt;p&gt;有些时候我们进行爬取时 Request Headers 什么的已经做好了伪装，却并未得到如愿以偿的结果，可能会出现如下几种情况：得到的信息不完整、得到不相关的信息、得不到信息，这种情况我们就需要研究网站的防爬机制，对其进行详细分析了。常见的几种我列一下：&lt;/p&gt;
&lt;p&gt;1）不规则信息：网址上会有一些没有规则的一长串信息，这种情况通常采用 selenium（模拟浏览器，效率会低一些） 解决；&lt;br/&gt;2）动态校验码：比如根据时间及一些其他自定义规则生成，这种情况我们就需要找到其规则进行破解了；&lt;br/&gt;3）动态交互：需要与页面进行交互才能通过验证，可以采用 selenium 解决；&lt;br/&gt;4）分批次异步加载：这种情况获取的信息可能不完整，可以采用 selenium 解决。&lt;/p&gt;
</description>
<pubDate>Fri, 04 Oct 2019 00:34:00 +0000</pubDate>
<dc:creator>程序员野客</dc:creator>
<og:description>1 简介 对于一些有一定规模或盈利性质比较强的网站，几乎都会做一些防爬措施，防爬措施一般来说有两种：一种是做身份验证，直接把虫子挡在了门口，另一种是在网站设置各种反爬机制，让虫子知难而返。 2 伪装策</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ityard/p/11621311.html</dc:identifier>
</item>
<item>
<title>Golang 接口与反射知识要点 - 黄挤挤</title>
<link>http://www.cnblogs.com/guangze/p/11621277.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/guangze/p/11621277.html</guid>
<description>&lt;p&gt;这篇文章以 Go 官方经典博客 &lt;a href=&quot;https://blog.golang.org/laws-of-reflection&quot;&gt;The Laws of Reflection&lt;/a&gt; 为基础，详细介绍文中涉及的知识点，并有所扩展。&lt;/p&gt;
&lt;h2 id=&quot;接口类型变量&quot;&gt;1. 接口类型变量&lt;/h2&gt;
&lt;p&gt;首先，我们谈谈接口类型的内存布局（memory layout），其他基础类型、Struct、Slice、Map、指针类型的内存布局会在以后单独分析。接口变量的值包含两部分内容：赋值给接口类型变量的实际值（concrete value），实际值的类型信息（type descriptor）。两部分在一起构成接口的值（interface value）。&lt;/p&gt;
&lt;p&gt;接口变量的这两部分内容由两个字来存储（假设是 32 位系统，那么一个字就是 32 位），第一个字指向 itable (interface table)。itable 表示 interface 和实际类型的转换信息。itable 开头是一个存储了变量&lt;strong&gt;实际类型的描述信息&lt;/strong&gt;，接着是一个由函数指针组成的列表。注意 &lt;strong&gt;itable 中的函数和接口类型相对应，而不是和动态类型&lt;/strong&gt;。例如下面例子，itable 只关联了 Stringer 中定义的 String 方法，而 Binary 中定义的 Get 方法则不在其中。对于每个 interface 和实际类型，只要在代码中存在引用关系， go 就会在运行时为这一对具体的 &amp;lt;Interface, Type&amp;gt; 生成 itable 信息。&lt;/p&gt;
&lt;p&gt;第二个字称为 data，指向实际的数据。例子中，赋值语句 var s Stringer = b 实际上&lt;strong&gt;对b做了拷贝，而不是对b进行引用&lt;/strong&gt;。存放在接口变量中的数据大小可能任意，但接口只提供了一个字来专门存储真实数据，所以&lt;strong&gt;赋值语句在堆上分配了一块内存，并将该字设置为对这块内存的引用&lt;/strong&gt;。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;type Stringer interface {
    String() string
}

type Binary uint64

func (i Binary) String() string {
    return strconv.Uitob64(i.Get(), 2)
}

func (i Binary) Get() uint64 {
    return uint64(i)
}

b := Binary(200)
var s Stringer = b&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/409355/201910/409355-20191004034641930-544963758.png&quot; alt=&quot;Golang Interface Memory Layout&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Go 是静态类型语言（statically typed）。一个接口类型的不同变量总是有同样静态类型，尽管在运行时，接口变量的保存的实际值会改变。下面例子中，无论 r 被赋予的什么实际值，r 的类型总是 io.Reader。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;var r io.Reader
r = os.Stdin
r = bufio.NewReader(r)
r = new(bytes.Buffer)
// and so on&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;类型断言&quot;&gt;2. 类型断言&lt;/h2&gt;
&lt;p&gt;类型断言是一个使用在接口变量上的操作。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;var r io.Reader
tty, err := os.OpenFile(&quot;/dev/tty&quot;, os.O_RDWR, 0)
if err != nil {
    return nil, err
}
r = tty&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这个例子中，r 被赋予了 tty 的&lt;strong&gt;一个拷贝&lt;/strong&gt;，所以实际值是 tty。而实际类型是 *os.File。需要注意到，*os.File 类型自身还实现了除接口方法 Read 以外的方法。尽管接口变量只能访问 Read 方法，但接口的 data 字部分里携带了实际值的全部信息。因此我们可以有如下操作：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;var w io.Writer
w = r.(io.Writer)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该赋值语句后边是一个类型断言。它断言的是 r 变量携带的元素，同时是 io.Writer 接口的实现，所以我们才能把 r 赋值给 w。赋值后的 w 可以访问 Write 方法，但无法访问 Read 方法了。&lt;/p&gt;
&lt;h2 id=&quot;鸭子类型&quot;&gt;3. 鸭子类型&lt;/h2&gt;
&lt;p&gt;鸭子类型（duck typing）是动态类型和某些静态语言用到的一种对象推断风格。一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由&quot;当前方法和属性的集合&quot;决定。这个概念也可以表述为：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;鸭子类型像多态一样工作，但是没有继承。在鸭子类型中，关注点在于对象的行为，能作什么；而不是关注对象所属的类型。在常规类型中，我们能否在一个特定场景中使用某个对象取决于这个对象的类型，而在鸭子类型中，则取决于这个对象是否具有某种属性或者方法 —— 即只要具备特定的属性或方法，能通过鸭子类型测试，就可以使用。鸭子类型的缺点是没有任何静态检查，如类型检查、属性检查、方法签名检查等。&lt;/p&gt;
&lt;p&gt;Go 语言虽然是静态语言，但在接口类型中使用了鸭子类型。&lt;strong&gt;不同于其他鸭子类型语言的是，它实现了在编译时进行静态检查&lt;/strong&gt;，比如变量是否实现接口方法、调用接口方法时参数个数是否相符，同时也不失鸭子类型带来的灵活和自由。&lt;/p&gt;
&lt;h2 id=&quot;反射机制&quot;&gt;4. 反射机制&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;什么是反射机制？&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;在计算机科学中，反射是指计算机程序在运行时（Run time）可以访问、检测和修改它本身状态或行为的一种能力。用比喻来说，反射就是程序在运行的时候能够“观察”并且修改自己的行为。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单来说，&lt;strong&gt;反射只是一种机制，在程序运行时获得对象类型信息和内存结构&lt;/strong&gt;。通常高级语言借助反射机制来解决，编译时无法知道变量具体类型，而只有等到运行时才能检查值和类型的问题。不同语言的反射模型不尽相同，有些语言还不支持反射。对于低级语言，比如汇编语言，由于自身可以直接和内存打交道，所以无需反射机制。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用反射的场景？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Go 语言中使用反射的场景：有时候需要根据某些条件决定调用哪个函数，比如根据用户的输入来决定，但事先无法不知道接受到的参数是什么类型，全部以 interface{} 类型接受。这时就需要对函数的参数进行反射，在运行期间动态地执行函数。感兴趣的读者可以参考 fmt.Sprint(a ...interface{}) 方法的源码。&lt;/p&gt;
&lt;h2 id=&quot;reflect-包&quot;&gt;5. reflect 包&lt;/h2&gt;
&lt;h3 id=&quot;typeofvalueof&quot;&gt;TypeOf()、ValueOf()&lt;/h3&gt;
&lt;p&gt;reflect 包封装了很多简单的方法（reflect.TypeOf 和 reflect.ValueOf）来动态获得类型信息和实际值（reflect.Type，reflect.Value）。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;var x float64 = 3.4
fmt.Println(&quot;type:&quot;, reflect.TypeOf(x))  // 打印 type: float64

var r io.Reader = strings.NewReader(&quot;Hello&quot;)
fmt.Println(&quot;type:&quot;, reflect.TypeOf(r))  // 打印 type: *strings.Reader&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;reflect.TypeOf 方法的函数签名是 func TypeOf(i interface{}) Type 。它接受任意类型的变量。当我们调用 reflect.TypeOf(x) 时，x 首先存储在一个空接口类型中，作为传参。reflect.TypeOf 解析空接口，恢复 x 的类型信息。而调用 reflect.ValueOf 则可以恢复 x 实际值。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;var x float64 = 3.4
fmt.Println(&quot;value:&quot;, reflect.ValueOf(x).String()) // 打印 value: &amp;lt;float64 Value&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;typekind&quot;&gt;Type()、Kind()&lt;/h3&gt;
&lt;p&gt;reflect.Type 和 reflect.Value 都提供了很多方法支持来操作他们。1. reflect.Value 的 Type() 方法返回实际类型信息；2. reflect.Type 和 reflect.Value 都有 Kind() 方法，来获得实际值的底层类型，结果对应的是 reflect 包中定义的常量；3. reflect.Value 的那些以类型名为方法名的方法，比如 Int()、Float()，能获得实际值。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;var x float64 = 3.4
v := reflect.ValueOf(x)
fmt.Println(&quot;type:&quot;, v.Type())
fmt.Println(&quot;kind is float64:&quot;, v.Kind() == reflect.Float64)
fmt.Println(&quot;value:&quot;, v.Float())&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打印结果：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;shell script type: float64 kind is float64: true value: 3.4&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;有一点需要注意的是，&lt;strong&gt;Kind() 方法返回的是反射对象的底层类型，而不是静态类型&lt;/strong&gt;。比如，如果反射对象接受一个用户定义的整数型变量：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func main() {
    type MyInt int
    var x MyInt = 7
    v := reflect.ValueOf(x)
    fmt.Println(&quot;type:&quot;, v.Type())
    fmt.Println(&quot;kind is int:&quot;, v.Kind() == reflect.Int)
    fmt.Println(&quot;value:&quot;, v.Int())
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打印结果：&lt;br/&gt;&lt;code&gt;shell script type: main.MyInt kind is int: true value: 7&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;v 调用 Kind() 仍是 reflect.Int，即使 x 的静态类型是 MyInt 而不是 int。&lt;strong&gt;总而言之，Kind() 方法无法区分来自 MyInt 的整数型和 int 型，但 Type() 方法可以&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;interface&quot;&gt;Interface()&lt;/h3&gt;
&lt;p&gt;Interface() 方法能从 reflect.Value 变量中恢复接口值，是 ValueOf() 的逆向。注意的是，Interface() 方法返回总是静态类型 interface{}。&lt;/p&gt;
&lt;h2 id=&quot;反射对象的可设置性&quot;&gt;6. 反射对象的可设置性&lt;/h2&gt;
&lt;h3 id=&quot;setxxx-canset&quot;&gt;SetXXX(), CanSet()&lt;/h3&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;var x float64 = 3.4
v := reflect.ValueOf(x)
v.SetFloat(7.1)  // will panic: reflect.Value.SetFloat using unaddressable value&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行上面的例子，我们可以发现 v 不可修改（settable）。可设置性（Settability）是 reflect.Value 的一个特性，但不是所有的 Value 都有。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;var x float64 = 3.4
v := reflect.ValueOf(x)
fmt.Println(&quot;settability of v:&quot;, v.CanSet())  // settability of v: false&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;elem&quot;&gt;Elem()&lt;/h3&gt;
&lt;p&gt;由于是 x 的一个拷贝传入 reflect.ValueOf，所以 reflect.ValueOf 创建的接口值也是 x 的一个拷贝，不是原 x 本身。因此修改反射对象，无法修改 x，反射对象不具有可设置性。&lt;/p&gt;
&lt;p&gt;显然，要使反射对象具有可设置性。传入 reflect.ValueOf 的参数应该是 x 的地址，即 &amp;amp;x。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;var x float64 = 3.4
p := reflect.ValueOf(&amp;amp;x) // Note: take the address of x.
fmt.Println(&quot;type of p:&quot;, p.Type())  // type of p: *float64
fmt.Println(&quot;settability of p:&quot;, p.CanSet())  // settability of p: false&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;反射对象 p 仍是不可设置的，因为我们不是要设置 p，而是 p 所指向的内容。使用 Elem 方法获取。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;// Elem returns the value that the interface v contains
// or that the pointer v points to.
// It panics if v's Kind is not Interface or Ptr.
// It returns the zero Value if v is nil.
func (v Value) Elem() Value&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;v := p.Elem()
fmt.Println(&quot;settability of v:&quot;, v.CanSet())  // settability of v: true

v.SetFloat(7.1)
fmt.Println(v.Interface())  // 7.1
fmt.Println(x)  // 7.1&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;struct-的反射&quot;&gt;7. Struct 的反射&lt;/h2&gt;
&lt;h3 id=&quot;numfield-type.fieldi-int&quot;&gt;NumField(), Type.Field(i int)&lt;/h3&gt;
&lt;p&gt;我们用 struct 的地址来创建反射对象，这样后续我们可以修改这个 struct：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;type T struct {
    A int
    B string
}

t := T{23, &quot;skidoo&quot;}
s := reflect.ValueOf(&amp;amp;t).Elem()
typeOfT := s.Type()

for i := 0; i &amp;lt; s.NumField(); i++ {
    f := s.Field(i)
    fmt.Printf(&quot;%d: %s %s = %v\n&quot;, i,
        typeOfT.Field(i).Name, f.Type(), f.Interface())
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Type.Field(i int) 方法返回字段信息，一个 StructField 类型的对象，包含字段名等。&lt;/p&gt;
&lt;p&gt;打印结果：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;0: A int = 23
1: B string = skidoo&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;value.fieldi-int&quot;&gt;Value.Field(i int)&lt;/h3&gt;
&lt;p&gt;T 的字段必须是首字母大写的才可以设置，因为&lt;strong&gt;只有暴露的 struct 字段，才具有可设置性&lt;/strong&gt;。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;s.Field(0).SetInt(77)
s.Field(1).SetString(&quot;Sunset Strip&quot;)
fmt.Println(&quot;t is now&quot;, t) // t is now {77 Sunset Strip}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Value.Field(i int) 返回 struct s 的字段实际值，所以可以用来设置操作。&lt;strong&gt;注意 Type.Field(i int) 和 Value.Field(i int) 的用途区别：前者总是负责和实际类型信息获取相关的操作，后者是与实际值相关的操作&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;参考文档&quot;&gt;参考文档&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.golang.org/laws-of-reflection&quot;&gt;The Laws of Reflection&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://research.swtch.com/interfaces&quot;&gt;Go Data Structures: Interfaces&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/d646297f6f1a&quot;&gt;Go 语言的数据结构：Interfaces&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://studygolang.com/articles/19571?fr=sidebar&quot;&gt;浅析 Golang Interface 实现原理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/qcrao-2018/p/10822655.html&quot;&gt;深度解密Go语言之反射&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 03 Oct 2019 19:48:00 +0000</pubDate>
<dc:creator>黄挤挤</dc:creator>
<og:description>[toc] Golang 接口与反射知识要点 这篇文章以 Go 官方经典博客 'The Laws of Reflection' 为基础，详细介绍文中涉及的知识点，并有所扩展。 1. 接口类型变量 首先</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/guangze/p/11621277.html</dc:identifier>
</item>
<item>
<title>使用.NET Core创建Windows服务（一） -  使用官方推荐方式 - LamondLu</title>
<link>http://www.cnblogs.com/lwqlun/p/11621186.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lwqlun/p/11621186.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;原文：Creating Windows Services In .NET Core – Part 1 – The “Microsoft” Way&lt;br/&gt;作者：Dotnet Core Tutorials&lt;br/&gt;译者：Lamond Lu&lt;br/&gt;译文：使用.NET Core创建Windows服务（一） - 使用官方推荐方式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201910/65831-20191004000549189-2066312828.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;创建Windows服务来运行批处理任务或者运行后台任务，是一种非常常见的模式，但是由于云服务（Amazon Lambda, Azure WebJobs以及Azure Functions）的激增，你可能不会经常使用Windows服务了。个人而言，我非常喜欢使用Azure WebJobs, 因为我可以直接编写一个控制台程序，而不需要考虑如何云中运行它，一个批处理文件可以将其装换成一个自动化任务，并且可以保证7*24小时的运行。&lt;/p&gt;
&lt;p&gt;但是也许你还没有使用云服务，或者你有一堆要作为Windows服务运行的旧版应用程序需要转换为.NET Core, 但是不能完全将他们转换为“无服务器”(serverless)应用。 那么这边文章就是适合你的。&lt;/p&gt;
&lt;p&gt;在许多方面，.NET Core中的Windows服务和.NET Framework中的Windows服务完全相同。但是，在编写服务的时候，你可能会遇到一些小问题。此外，本文中，我们仅介绍“Microsoft”方式的Windows服务创建，在后续，我会继续介绍如何使用第三方库&lt;code&gt;TopShelf&lt;/code&gt;来简化这该过程。&lt;/p&gt;

&lt;p&gt;由于Visual Studio没有提供创建Windows服务的模板，所以我们需要通过创建控制台程序的方式来创建一个Windows服务。&lt;/p&gt;
&lt;p&gt;创建完成之后，我们需要安装一个Nuget程序包，这个程序包会将一些Windows特定的API添加到.NET Core中，这些API实际上已经在完整框架中提供了，但是其中许多是Windows特有的，例如Windows服务。因此, 它们并没有包含在.NET Core的基础库中，但是可以通过将Nuget程序包的方式引入到.NET Core中。&lt;br/&gt;下面我们就可以在Package Manager Console中输入以下命令。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Install-Package Microsoft.Windows.Compatibility&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;以上引入的Nuget程序包中，最让我们感兴趣的是&lt;code&gt;ServiceBase&lt;/code&gt;类。这是一个用于编写Windows服务的基类，它提供了一系列的事件钩子，包含服务启动、结束、暂停等。&lt;/p&gt;
&lt;p&gt;下面呢，我们将在代码中创建一个类，这个类负责将一些简单的日志输出到一个临时文件中。我们将使用这个例子来了解其中的原理。我们的代码如下：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;class LoggingService : ServiceBase
{
    private const string _logFileLocation = @&quot;C:\temp\servicelog.txt&quot;;
 
    private void Log(string logMessage)
    {
        Directory.CreateDirectory(Path.GetDirectoryName(_logFileLocation));
        File.AppendAllText(_logFileLocation, DateTime.UtcNow.ToString() + &quot; : &quot; + logMessage + Environment.NewLine);
    }
 
    protected override void OnStart(string[] args)
    {
        Log(&quot;Starting&quot;);
        base.OnStart(args);
    }
 
    protected override void OnStop()
    {
        Log(&quot;Stopping&quot;);
        base.OnStop();
    }
 
    protected override void OnPause()
    {
        Log(&quot;Pausing&quot;);
        base.OnPause();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以这里你会注意到，我们的类是继承了&lt;code&gt;ServiceBase&lt;/code&gt;类，并且我们重写了几个事件方法，输出了一些日志。在服务启动时，会触发&lt;code&gt;OnStart&lt;/code&gt;事件，在服务终止的时候，会触发&lt;code&gt;OnStop&lt;/code&gt;事件。这里我们不应该将过于繁重的任务放置在&lt;code&gt;OnStart&lt;/code&gt;事件中来处理。&lt;/p&gt;
&lt;p&gt;如果我们想从&lt;code&gt;Main&lt;/code&gt;方式中启动这个服务，代码非常的简单。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;static void Main(string[] args)
{
    ServiceBase.Run(new LoggingService());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上就是全部代码。&lt;/p&gt;

&lt;p&gt;在发布服务的时候，我们不可能仅依靠Visual Studio来构建我们所需要的服务，我们还需要专门针对Windows运行时进行构建。为此，我们需要在项目根目录的命令提示符下运行以下命令。注意，这里我们传入了一个&lt;code&gt;-r&lt;/code&gt;标记来告诉它要构建那个平台。&lt;/p&gt;
&lt;pre class=&quot;powershell&quot;&gt;
&lt;code&gt;dotnet publish -r win-x64 -c Release&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;命令运行完毕之后，我们可以检查以下&lt;code&gt;/bin/release/netcoreappX.X/publish&lt;/code&gt;目录，我们可以找到所有的发布代码，但是最重要的是，这里我们可以得到一个可执行的exe文件。如果我们不指定运行时，我们只会获得一个.NET Core的dll程序集，使用这个程序集，我们是没有办法创建Windows服务的。&lt;/p&gt;
&lt;p&gt;现在我们可以将这个发布目录移动带其他的任何地方，但是现在我们就暂时使用当前的发布目录。&lt;/p&gt;
&lt;p&gt;下一步，我们需要使用管理员角色打开一个命令提示符，然后输入一下命令。&lt;/p&gt;
&lt;pre class=&quot;powershell&quot;&gt;
&lt;code&gt;sc create TestService BinPath=C:\full\path\to\publish\dir\WindowsServiceExample.exe&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;SC&lt;/code&gt;命令是一个标准的Windows命令（与.NET Core无关），它可以用来安装Windows服务。这里我们将我们的测试服务命名为&lt;code&gt;TestService&lt;/code&gt;，更重要的是，我们通过&lt;code&gt;BinPath&lt;/code&gt;参数指定了可执行exe文件。&lt;/p&gt;
&lt;p&gt;运行之后，我们应该会得到以下结果。&lt;/p&gt;
&lt;pre class=&quot;powershell&quot;&gt;
&lt;code&gt;[SC] CreateService SUCCESS&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们要做的就是启动服务。&lt;/p&gt;
&lt;pre class=&quot;powershell&quot;&gt;
&lt;code&gt;sc start TestService&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在我们可以查看一下我们的日志文件，查看服务的运行情况。&lt;/p&gt;
&lt;p&gt;如果想要停止并删除服务，我们可以使用一下命令。&lt;/p&gt;
&lt;pre class=&quot;powershell&quot;&gt;
&lt;code&gt;sc stop TestService
sc delete TestService&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;在这里，我真的认为，使用&quot;Microsoft&quot;的方式注定会失败。因为调试服务实在是太繁琐了。&lt;/p&gt;
&lt;p&gt;首先，我们将&lt;code&gt;ServiceBase&lt;/code&gt;中重写的方法设置为受保护，这意味着我们无法在类之外访问它们，这使得调试它们变得更加困难。这里我发现最好的方法是为每个事件提供一个public方法, 并在受保护方法中调用这些public方法来完成功能，这虽然有点混乱，&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public void OnStartPublic(string[] args)
{
    Log(&quot;Starting&quot;);
}
 
protected override void OnStart(string[] args)
{
    OnStartPublic(args);
    base.OnStart(args);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是至少我们可以做如下了事情了。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;static void Main(string[] args)
{
    var loggingService = new LoggingService();
    if (true)   //Some check to see if we are in debug mode (Either #IF Debug etc or an app setting)
    {
        loggingService.OnStartPublic(new string[0]);
        while(true)
        {
            //Just spin wait here. 
            Thread.Sleep(1000);
        }
        //Call stop here etc. 
    }
    else
    {
        ServiceBase.Run(new LoggingService());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你的另一个选择是，在调试模式下进行项目发布，安装服务，然后附加调试器。实际上，这是Microsoft建议你使用的方式，但是我认为这简直一团糟。&lt;/p&gt;

&lt;p&gt;实际上，我们可以在这里做一些其他非常有用的事情， 比如我们可以通过创建一个install.bat批处理文件来为我们运行SC Create命令。但我认为，上面我们看到的调试问题，已经让我不再想使用这种方式了。 幸运的是，有一个名为&lt;code&gt;Topshelf&lt;/code&gt;的库可以帮助我们减轻很多麻烦，在本系列的下一部分中，我们将研究如何它。&lt;/p&gt;
</description>
<pubDate>Thu, 03 Oct 2019 16:07:00 +0000</pubDate>
<dc:creator>LamondLu</dc:creator>
<og:description>原文：Creating Windows Services In .NET Core – Part 1 – The “Microsoft” Way 作者：Dotnet Core Tutorials 译者</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lwqlun/p/11621186.html</dc:identifier>
</item>
<item>
<title>详解es6 class语法糖中constructor方法和super的作用 - 一颗小石子激起的浪花</title>
<link>http://www.cnblogs.com/thomas-yang-github/p/11621067.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/thomas-yang-github/p/11621067.html</guid>
<description>&lt;p&gt;       大多数面向对象的编程语言都支持类和类继承的特性，而JS却不支持这些特性，只能通过其他方法定义并关联多个相似的对象，这种状态一直延续到了ES5。由于类似的库层出不穷，最终还是在ECMAScript 6中引入了类的特性。本文将详细介绍ES6中的类，ES6 的 &lt;code&gt;class&lt;/code&gt; 属于一种“语法糖”，所以只是写法更加优雅，更加像面对对象的编程，其思想和 ES5 是一致的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function Point(x, y) {
  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.x =&lt;span&gt; x;
  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.y =&lt;span&gt; y;
}
 
Point.prototype.toString &lt;/span&gt;=&lt;span&gt; function() {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + &lt;span&gt;this&lt;/span&gt;.x + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + &lt;span&gt;this&lt;/span&gt;.y + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;等同于&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
class Point {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
 
  toString() {
    return '(' + this.x + ',' + this.y + ')';
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中 &lt;strong&gt;constructor&lt;/strong&gt; 方法是类的构造函数，是一个默认方法，通过 new 命令创建对象实例时，自动调用该方法。一个类必须有 constructor 方法，如果没有显式定义，一个默认的 consructor 方法会被默认添加。所以即使你没有添加构造函数，也是会有一个默认的构造函数的。一般 constructor 方法返回实例对象 this ，但是也可以指定 constructor 方法返回一个全新的对象，让返回的实例对象不是该类的实例。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;下面好好分析一下 &lt;code&gt;super&lt;/code&gt; 关键字的作用&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;super&lt;/code&gt; 这个关键字，既可以当做函数使用，也可以当做对象使用。这两种情况下，它的用法完全不用。&lt;/p&gt;
&lt;p&gt;1. 当做函数使用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; A {}
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; B extends A {
  constructor() {
    super();  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ES6 要求，子类的构造函数必须执行一次 super 函数，否则会报错。&lt;/span&gt;
&lt;span&gt;  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注：在 constructor 中必须调用 super 方法，因为子类没有自己的 this 对象，而是继承父类的 this 对象，然后对其进行加工,而 super 就代表了父类的构造函数。super 虽然代表了父类 A 的构造函数，但是返回的是子类 B 的实例，即 super 内部的 this 指的是 B，因此 super() 在这里相当于 ```A.prototype.constructor.call(this, props)``。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; A {
  constructor() {
    console.log(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;.target.name); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; new.target 指向当前正在执行的函数&lt;/span&gt;
&lt;span&gt;  }
}
 
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; B extends A {
  constructor() {
    super();
  }
}
 
&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; A(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; A&lt;/span&gt;
&lt;span&gt;new&lt;/span&gt; B(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; B&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到，在 &lt;code&gt;super()&lt;/code&gt; 执行时，它指向的是 子类 B 的构造函数，而不是父类 A 的构造函数。也就是说，&lt;code&gt;super()&lt;/code&gt; 内部的 &lt;code&gt;this&lt;/code&gt; 指向的是 B。&lt;/p&gt;
&lt;p&gt;2. 当做对象使用&lt;/p&gt;
&lt;p&gt;在普通方法中，指向父类的原型对象；在静态方法中，指向父类。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
class A {
  c() {
    return 2;
  }
}
 
class B extends A {
  constructor() {
    super();
    console.log(super.c()); // 2
  }
}
 
let b = new B();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面代码中，子类 B 当中的 &lt;code&gt;super.c()&lt;/code&gt;，就是将 &lt;code&gt;super&lt;/code&gt; 当作一个对象使用。这时，&lt;code&gt;super&lt;/code&gt; 在普通方法之中，指向 &lt;code&gt;A.prototype&lt;/code&gt;，所以 &lt;code&gt;super.c()&lt;/code&gt; 就相当于 &lt;code&gt;A.prototype.c()&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;通过 &lt;code&gt;super&lt;/code&gt; 调用父类的方法时，&lt;code&gt;super&lt;/code&gt; 会绑定子类的 &lt;code&gt;this&lt;/code&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; A {
  constructor() {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.x = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
  }
  s() {
    console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.x);
  }
}
 
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; B extends A {
  constructor() {
    super();
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.x = &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
  }
  m() {
    super.s();
  }
}
 
let b &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; B();
b.m(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面代码中，super.s() 虽然调用的是 A.prototytpe.s()，但是 A.prototytpe.s()会绑定子类 B 的 this，导致输出的是 2，而不是 1。也就是说，实际上执行的是 super.s.call(this)。&lt;/p&gt;

&lt;p&gt;由于绑定子类的 this，所以如果通过 super 对某个属性赋值，这时 super 就是 this，赋值的属性会变成子类实例的属性。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; A {
  constructor() {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.x = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
  }
}
 
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; B extends A {
  constructor() {
    super();
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.x = &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
    super.x &lt;/span&gt;= &lt;span&gt;3&lt;/span&gt;&lt;span&gt;;
    console.log(super.x); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; undefined&lt;/span&gt;
    console.log(&lt;span&gt;this&lt;/span&gt;.x); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;
&lt;span&gt;  }
}
 
let b &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; B();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面代码中，&lt;code&gt;super.x&lt;/code&gt; 赋值为 3，这时等同于对 &lt;code&gt;this.x&lt;/code&gt; 赋值为 3。而当读取 &lt;code&gt;super.x&lt;/code&gt; 的时候，调用的是 &lt;code&gt;A.prototype.x&lt;/code&gt;，但并没有 &lt;code&gt;x&lt;/code&gt; 方法，所以返回 undefined。&lt;/p&gt;

&lt;p&gt;注意，使用 &lt;code&gt;super&lt;/code&gt; 的时候，必须显式指定是作为函数，还是作为对象使用，否则会报错。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; A {}
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; B extends A {
  constructor() {
    super();
    console.log(super); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 报错&lt;/span&gt;
&lt;span&gt;  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面代码中，console.log(super); 的当中的 super，无法看出是作为函数使用，还是作为对象使用，所以 JavaScript 引擎解析代码的时候就会报错。这是，如果能清晰的表明 super 的数据类型，就不会报错。&lt;/p&gt;
&lt;p&gt;最后，由于对象总是继承其他对象的，所以可以在任意一个对象中，使用 super 关键字。&lt;/p&gt;
&lt;p&gt;结语：&lt;br/&gt;ES6 的 class 毕竟是一个“语法糖”，所以只要理解了 JavaScript 中对象的概念和面向对象的思想，class 就不难理解啦。&lt;/p&gt;
</description>
<pubDate>Thu, 03 Oct 2019 15:04:00 +0000</pubDate>
<dc:creator>一颗小石子激起的浪花</dc:creator>
<og:description>大多数面向对象的编程语言都支持类和类继承的特性，而JS却不支持这些特性，只能通过其他方法定义并关联多个相似的对象，这种状态一直延续到了ES5。由于类似的库层出不穷，最终还是在ECMAScript 6中</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/thomas-yang-github/p/11621067.html</dc:identifier>
</item>
<item>
<title>关于.NET HttpClient方式获取微信小程序码（二维码） - 白云任去留</title>
<link>http://www.cnblogs.com/ang/p/11620940.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ang/p/11620940.html</guid>
<description>&lt;p&gt;随着微信小程序的火热应用，市面上有关小程序开发的需求也多了起来。近来分析了一项生成有关生成微信小程序码的需求——要求扫码跳转到小程序指定页面（带参数）；看了下小程序官方文档，以及网上的例子，未看到多少有价值的采用C#调用小程序接口生成小程序码的例子，于是拾起多年前的代码，略作分析尝试，在此分享给有需要的人，并以此抛砖引玉。&lt;/p&gt;
&lt;p&gt;此文以HttpClient方式示例，当然采用老旧的HttpWebRequest也可以，在此不作分析。&lt;br/&gt;生成微信小程序码（二维码）的接口主要有三个：&lt;/p&gt;
&lt;p&gt;在此仅针对&lt;span&gt;createwxaqrcode（二维码）和get（小程序码/葵花码）讲解，&lt;/span&gt;&lt;span&gt;getUnlimited原理同；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;两者的接口地址分别如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;https://api.weixin.qq.com/cgi-bin/wxaapp/createwxaqrcode?access_token=ACCESS_TOKEN&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;https://api.weixin.qq.com/wxa/getwxacode?access_token=ACCESS_TOKEN&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;由于请求小程序接口，其返回的是图片二进制流，采用&lt;/span&gt;&lt;/span&gt;HttpClient方式时务必针对二进制数据进行处理；不多说，直接上关键代码，简要示例如下：&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;44&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
public class HttpClientHelper
    {
public static bool DownloadBufferImage(string requestUri, /*HttpContent httpContent,*/string filePath, string jsonString, string webapiBaseUrl = &quot;&quot;)
        {
            try
            {
                HttpContent httpContent = new StringContent(jsonString);
                httpContent.Headers.ContentType = new MediaTypeHeaderValue(&quot;application/json&quot;);
               
                using (HttpClient httpClient = new HttpClient())
                {                   
                    if (!string.IsNullOrWhiteSpace(webapiBaseUrl))
                    {
                        httpClient.BaseAddress = new Uri(webapiBaseUrl);
                    }
                    bool result = false;
                    httpClient.PostAsync(requestUri, httpContent).ContinueWith(
                       (requestTask) =&amp;gt;
                       {
                           HttpResponseMessage response = requestTask.Result;

                           response.EnsureSuccessStatusCode();

                           var data = response.Content.ReadAsByteArrayAsync().Result;
                        
                           using (FileStream fs = new FileStream(filePath, FileMode.Create, FileAccess.Write))
                           {
                               fs.Write(data, 0, data.Length);
                               fs.Flush();
                               fs.Close();
                           }

                           result = true;

                       }).Wait(30000);
                 
                    return result;
                }
            }
            catch
            {
                return false;
            }
        }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;一共4个参数：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;requestUri请求的接口URL；&lt;/li&gt;
&lt;li&gt;filePath小程序码（二维码）存储的绝对路径；&lt;/li&gt;
&lt;li&gt;jsonString提交的json数据对象；&lt;/li&gt;
&lt;li&gt;webapiBaseUrl接口根路径（可忽略）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;由于腾讯接口要求，提交数据必须json对象，因此&lt;span&gt;&lt;strong&gt;httpContent.Headers.ContentType = new MediaTypeHeaderValue(&quot;application/json&quot;)，&lt;/strong&gt;此处尤为重要，不能像提交form表单一样以字典方式提交；其次，处理二进制数据流采用以下形式处理并保存图片；此处不赘述。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
var data = response.Content.ReadAsByteArrayAsync().Result;
                        
                           using (FileStream fs = new FileStream(filePath, FileMode.Create, FileAccess.Write))
                           {
                               fs.Write(data, 0, data.Length);
                               fs.Flush();
                               fs.Close();
                           }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;简要封装及调用示例如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
public bool GetQrCode(string filePath, string path = &quot;pages/default/default&quot;, int width = 430)
         {
             string postUrl = string.Format(&quot;https://api.weixin.qq.com/wxa/getwxacode?access_token={0}&quot;, AccessToken);         

             var data = new
            {
                path = path,
                width = width
            };
             var result = HttpClientHelper.DownloadBufferImage(postUrl, filePath, Newtonsoft.Json.JsonConvert.SerializeObject(data));

             return result;
         } 
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
new NameSpace.GetQrCode(@&quot;D:\QrCode.jpg&quot;, path: &quot;pages/index/index&quot;);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;filePath为保存小程序码（二维码）图片的绝对路径，如Server.MapPath(savePath)；path（小程序页面地址）和width（二维码宽度，默认430）均为可选参数，具体参见接口文档；&lt;span&gt;AccessToken为接口调用凭证；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;注：由于腾讯限制，如果接口调用成功，会直接返回图片二进制内容，如果请求失败，会返回 JSON 格式的数据；方法里仅对返回二进制流作处理，其他可根据需求自行完善。&lt;/p&gt;

</description>
<pubDate>Thu, 03 Oct 2019 14:07:00 +0000</pubDate>
<dc:creator>白云任去留</dc:creator>
<og:description>随着微信小程序的火热应用，市面上有关小程序开发的需求也多了起来。近来分析了一项生成有关生成微信小程序码的需求——要求扫码跳转到小程序指定页面（带参数）；看了下小程序官方文档，以及网上的例子，未看到多少</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ang/p/11620940.html</dc:identifier>
</item>
<item>
<title>Android开发——Toolbar常用设置 - Stars-one</title>
<link>http://www.cnblogs.com/kexing/p/11620853.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kexing/p/11620853.html</guid>
<description>&lt;p&gt;本篇笔记用来记录常用的Toolbar设置，如Toolbar颜色设置，显示返回按钮，显示右边三个点按钮&lt;/p&gt;
&lt;p&gt;之前Android 使用的ActionBar，Android5.0开始，谷歌官方推荐使用Toolbar来代替ActionBar&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最近慢慢开始使用上kotlin了，贴出的代码可能是kotlin的代码，见谅，如果有Java基础的，其实还蛮简单上手的，可以参考一下我的kotlin学习笔记&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/kexing/category/1363690.html&quot;&gt;Kotlin学习笔记&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;我们首先将主题设置为NoActionBar，之后在布局xml文件添加ToolBar&lt;/p&gt;
&lt;p&gt;由Android Manifest文件进入Theme，修改Theme&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1210268/201910/1210268-20191003205423220-2087998881.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!-- Base application theme. --&amp;gt;
&amp;lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&amp;gt;
    &amp;lt;!-- Customize your theme here. --&amp;gt;
    &amp;lt;item name=&quot;colorPrimary&quot;&amp;gt;@color/colorPrimary&amp;lt;/item&amp;gt;
    &amp;lt;item name=&quot;colorPrimaryDark&quot;&amp;gt;@color/colorPrimaryDark&amp;lt;/item&amp;gt;
    &amp;lt;item name=&quot;colorAccent&quot;&amp;gt;@color/colorAccent&amp;lt;/item&amp;gt;
&amp;lt;/style&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;布局xml文件，添加Toolbar&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;android.support.constraint.ConstraintLayout
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:fitsSystemWindows=&quot;true&quot;
    android:layout_height=&quot;match_parent&quot;
    tools:context=&quot;com.wan.noveldownloader.activity.MainActivity&quot;&amp;gt;
    &amp;lt;android.support.v7.widget.Toolbar
        android:id=&quot;@+id/toolbar&quot;
        app:titleTextColor=&quot;@color/white&quot;
        android:background=&quot;@color/colorPrimary&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;/&amp;gt;
&amp;lt;/android.support.constraint.ConstraintLayout&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;之后，在Activity代码中，使用setSupportToolbar，把toolbar设置进去&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;setContentView(R.layout.activity_main);
//findviewbyid找到toolbar实例
setSupportToolbar(toolbar);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;之后运行就可以看到结果了&lt;/p&gt;
&lt;h2 id=&quot;修改标题文字&quot;&gt;2.修改标题文字&lt;/h2&gt;
&lt;p&gt;默认的Toolbar显示的文字其实就是你当前APP项目的label，我们到AndroidManifest文件修改Activity的label属性，就可以达到修改文字的效果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1210268/201910/1210268-20191003210139877-1599736954.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图中，我的APP有两个Activity，其中，MainActivity中的toolbar没有定义label属性，所以，默认label属性等于项目名，所有显示的是“星之小说下载器”&lt;/p&gt;
&lt;p&gt;而另外的那个SettingActivity则有label属性，所有，显示的文字就是“设置”&lt;/p&gt;
&lt;p&gt;PS:如果不想要显示文字，则通过&lt;code&gt;getSupportActionBar().setDisplayShowTitleEnabled(false)&lt;/code&gt;实现(在setSupportToolbar方法之后)&lt;/p&gt;
&lt;h2 id=&quot;修改颜色&quot;&gt;3.修改颜色&lt;/h2&gt;
&lt;h3 id=&quot;修改背景色&quot;&gt;修改背景色&lt;/h3&gt;
&lt;p&gt;修改背景颜色通过修改toolbar的&lt;code&gt;background&lt;/code&gt;属性达到效果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;android.support.v7.widget.Toolbar
    android:id=&quot;@+id/toolbar&quot;
    android:background=&quot;@color/colorPrimary&quot;
    android:layout_height=&quot;wrap_content&quot;/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;修改标题文字颜色&quot;&gt;修改标题文字颜色&lt;/h3&gt;
&lt;p&gt;修改&lt;code&gt;titleTextColor&lt;/code&gt;属性，需要引入app命名空间&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;android.support.v7.widget.Toolbar
    android:id=&quot;@+id/toolbar&quot;
    app:titleTextColor=&quot;@color/white&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;wrap_content&quot;/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;显示左边返回按钮&quot;&gt;4.显示左边返回按钮&lt;/h2&gt;
&lt;p&gt;通过代码的方式显示左边的返回按钮&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;setSupportActionBar(toolbar)
getSupportActionBar().setHomeButtonEnabled(true)
getSupportActionBar().setDisplayHomeAsUpEnabled(true)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Activity中还需要重写&lt;code&gt;onOptionsItemSelected&lt;/code&gt;方法，点击返回按钮达到返回的效果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;override fun onOptionsItemSelected(item: MenuItem?): Boolean {
    if(item.itemId == android.R.id.home){
        finish()
    }
    return super.onOptionsItemSelected(item)
}&lt;/code&gt;
&lt;/pre&gt;


&lt;p&gt;在res目录下创建一个menu的文件夹，之后在menu文件夹中新建一个&lt;code&gt;menu.xml&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
      xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&amp;gt;
    &amp;lt;item android:title=&quot;设置&quot; android:id=&quot;@+id/menu_setting&quot; app:showAsAction=&quot;always&quot; android:icon=&quot;@drawable/icon_setting&quot;/&amp;gt;
&amp;lt;/menu&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;title 标题&lt;/li&gt;
&lt;li&gt;icon 图标&lt;/li&gt;
&lt;li&gt;showAsAction&lt;br/&gt;此属性有几个选择
&lt;ol&gt;&lt;li&gt;&lt;code&gt;always&lt;/code&gt;：这个值会使菜单项一直显示在Action Bar上。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ifRoom&lt;/code&gt;：如果有足够的空间，这个值会使菜单项显示在Action Bar上。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;never&lt;/code&gt;：这个值使菜单项永远都不出现在Action Bar上。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;withText&lt;/code&gt;：这个值使菜单项和它的图标，菜单文本一起显示。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;重写Activity中的onCreateMenu的方法，把menu.xml文件装载到APP中&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;override fun onCreateOptionsMenu(menu: Menu?): Boolean {
    menuInflater.inflate(R.menu.menu,menu)
    return true
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;重写opoptionselect方法&quot;&gt;3.重写opOptionSelect方法&lt;/h3&gt;
&lt;p&gt;设置每个菜单的点击事件，与设置监听器操作类似&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;override fun onOptionsItemSelected(item: MenuItem?): Boolean {
    if (item?.itemId ==R.id.menu_setting) {
        startActivity(SettingActivity::class.java)
    }
    return false
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;setsupporttoolbar&quot;&gt;4.setSupportToolbar&lt;/h3&gt;
&lt;p&gt;和之前的步骤一样&lt;/p&gt;
</description>
<pubDate>Thu, 03 Oct 2019 13:29:00 +0000</pubDate>
<dc:creator>Stars-one</dc:creator>
<og:description>本篇笔记用来记录常用的Toolbar设置，如Toolbar颜色设置，显示返回按钮，显示右边三个点按钮 之前Android 使用的ActionBar，Android5.0开始，谷歌官方推荐使用Toolb</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kexing/p/11620853.html</dc:identifier>
</item>
<item>
<title>『王霸之路』从0.1到2.0一文看尽TensorFlow奋斗史 - 小宋是呢</title>
<link>http://www.cnblogs.com/xiaosongshine/p/11620816.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaosongshine/p/11620816.html</guid>
<description>


&lt;h2&gt;0 序篇&lt;/h2&gt;
&lt;p&gt;2015年11月，Google正式发布了Tensorflow的白皮书并开源TensorFlow 0.1 版本。&lt;/p&gt;
&lt;p&gt;2017年02月，Tensorflow正式发布了1.0.0版本，同时也标志着稳定版的诞生。&lt;/p&gt;
&lt;p&gt;2019年10月，TensorFlow在经历七个多月(2019年3月1日-2019年10月1日)的 2.0 Alpha 版本的更新迭代后发布 2.0 正式版。&lt;/p&gt;
&lt;p&gt;2.0 正式版官方介绍视频&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://v.qq.com/x/page/b3003v2g8dq.html&quot; data-cke-saved-href=&quot;https://v.qq.com/x/page/b3003v2g8dq.html&quot;&gt;https://v.qq.com/x/page/b3003v2g8dq.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;虽然 2.0 正式版才刚刚发布，就已经引起了学术界与科研界广泛关注与好评：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Google深度学习科学家以及Keras的作者表示，TensorFlow 2.0 是一个新时代的机器学习平台，这将改变了一切。&lt;/li&gt;
&lt;li&gt;深度学习研究和教育者、fast.ai创始人Jeremy Howard也称赞 2.0 版本的发布是”令人兴奋的一步，与TensorFlow一代相比是一个巨大的飞跃“。&lt;/li&gt;
&lt;li&gt;目前GitHub上排名第一的NLP机器学习课程practicalAI的作者以及苹果公司AI研究员Goku Mohandas在推特上说，他们正在从PyTorch转向TensorFlow 2.0。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为什么TensorFlow 2.0 的发布能够引发了广泛的讨论和关注？下面笔者通过对于TensorFlow“奋斗史”介绍与解读来分析TensorFlow如何成就的王霸之路。&lt;/p&gt;
&lt;p&gt;TensorFlow的“奋斗史”包括三个章节：锋芒初露（0.1），中原逐鹿（1.0），王者归来（2.0）。&lt;/p&gt;

&lt;h2&gt;1 锋芒初露·源起&lt;/h2&gt;
&lt;p&gt;在2011年，Google Brain内部孵化出一个项目叫做DistBelief，它是为深度神经网络构建的一个机器学习系统。虽然这个著名的系统并没有开源，但是Google研究者有大量关于它设计的论文被大家所熟知，它也被广泛应用于Google内部的科研和商业产品中。这个项目最早可以追溯到2009年，由Geoffery Hinton带领的团队开发的一个实现了广义反向传播算法的框架，基于这个框架，Google内部可以快速试验新的深度学习算法并提高算法精度。比如在使用这套框架后，Google内部语音识别的错误率降低了25%。&lt;/p&gt;


&lt;p&gt;后来，Google决定将DistBelief打造成更加稳健、快速、通用的机器学习框架，调动了相当多的工程师和科学家投入到对DistBelief的改造，这其中就包括大名鼎鼎的Jeff Dean。有了这样的豪华开发阵容，DistBelief迅速成熟蜕变，成为一个高鲁棒和工业级的机器学习框架，这就是后来于2015年11月发布的TensorFlow 0.1 版。&lt;/p&gt;
&lt;p&gt;虽然相较于较早开源的Caffe、MXNet等优秀的机器学习框架，TensorFlow还略显年轻，但是作为Google内部的第二代机器学习框架，TensorFlow有了更加有趣的灵魂。相较于侧重于卷积的Caffe与刚从校园走出来的MXNet，TensorFlow以更加成熟完备的姿态展露锋芒。它是基于DataFlow的计算模型，算子相组合形成一个计算图，计算的过程就是数据在这个计算图的节点进行计算并流动。同时，这个计算图可以被切成不同的子图，并分配到不同的Device上，包括CPU、GPU和其他的计算设备，这样天然地对分布式友好。此外，TensorFlow从一开始就被设计成运行在多个平台上，如inference可以运行在iOS和Android设备上，训练则可以运行在不同的硬件设备上。&lt;/p&gt;
&lt;p&gt;2016年4月14日，Google发布了分布式TensorFlow，版本号为 0.8，这是TensorFlow发布之后的比较重大的版本更新。Google的博文介绍了TensorFlow在图像分类的任务中，在100个GPUs和不到65小时的训练时间下，达到了78%的正确率。在激烈的商业竞争中，更快的训练速度是人工企业的核心竞争力。而分布式TensorFlow意味着它能够真正大规模进入到人工智能产业中，产生实质性影响。&lt;/p&gt;
&lt;p&gt;在2016年6月，TensorFlow发布了新版本的早期版本，版本号为 0.9，增加了对iOS的支持。随着谷歌增加了TensorFlow对iOS的支持，应用程序将能够在更聪明的功能集成到它们的应用程序，最终使它们更聪明和能干。&lt;/p&gt;
&lt;p&gt;从 0.9 版本开始，TensorFlow 支持了多平台，并且进入高速发展时期，开始不断赶超并拉开与其他深度学习框架的距离。虽只是&lt;strong&gt;源起&lt;/strong&gt;，却锋芒毕露，初现王霸之气。&lt;/p&gt;

&lt;h2&gt;2 中原逐鹿·盛极&lt;/h2&gt;
&lt;p&gt;时间到了，2017年1月初，谷歌公布了 TensorFlow 1.0.0-alpha ，即 TensorFlow 1.0 的第一个“草稿”版本。2017年2月，TensorFlow在发布了1.0.0版本，也标志着稳定版的诞生。&lt;/p&gt;
&lt;p&gt;与已有版本相比，全新的 TensorFlow 1.0 主要有以下改进：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;更快：TensorFlow 1.0超乎想象地快！TensorFlow 1.0 为未来更多的性能改进打下了基础，而tensorflow.org 现在可提供模型优化的提示和技巧，以达到最高速度。&lt;/li&gt;
&lt;li&gt;更灵活：TensorFlow 1.0 为 TensorFlow 引进了带有 tf.layers，tf.metrics 和 tf.losses 模块的高级别应用程序界面。TensorFlow 团队引进能够与 Keras完全兼容的新 tf.keras 模块。&lt;/li&gt;
&lt;li&gt;随时就绪：TensorFlow 1.0 可确保 Python 应用程序界面的稳定性Python能够在不打破现有代码的情况下，更容易地获取新功能。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;1.0 版本不仅为 TensorFlow 机器学习函数库带来多重升级，而且为 Python 和 Java 用户使用TensorFlow 做开发降低了难度。另外，新版本的修补也得到了改善。更有意思的是，由于对TensorFlow 计算做优化的新编译器，在智能手机上运行基于 TensorFlow 的机器学习 APP 将成为可能。Tensorflow它已成为 GitHub 最受欢迎的开源项目。&lt;/p&gt;
&lt;p&gt;下图是KDnuggets网站对2018年的机器学习框架的使用做的一个调查统计，可以看出当时TensorFlow已经遥遥领先于其他竞争（Keras 是一个上层封装，底层调用的还是 TensorFlow），奠定了其深度学习霸主的地位。&lt;/p&gt;

&lt;p&gt;中国有句古话：&lt;strong&gt;盛极&lt;/strong&gt;必衰，否极泰来，这句话对于Google的 TensorFlow 也同样适用。1.x 版本在高速发展过程中，也为自己后来发展筑起一道山，TensorFlow也产生了很多被人诟病的地方，比如API的稳定性、效率和基于静态计算图的编程上的复杂性等。同时，坚持静态图模式也培养起来了足以撼动 TensorFlow 霸主地位的框架（上述图中默默无闻的第三名，后来强势崛起的PyTorch）。&lt;/p&gt;

&lt;p&gt;1.x 版本后期，TensorFlow发展由于自身原因（1. 为自己后来发展筑起一道山 2.坚持静态图模式）遭遇到瓶颈。PyTorch以动态图开发模式，统一化的模块命名方式，更加人性化的编程的方式（Pythonic），强势出道。这些优势无一不击中 TensorFlow 的痛点，不断追赶、威胁TensorFlow霸主地位。&lt;/p&gt;

&lt;p&gt;下图通过搜索全世界对机器学习和人工智能类别的兴趣(Google Interest)，采用过去六个月的平均兴趣分数，并将其与前六个月的平均兴趣分数进行了比较。可以看出，TensorFlow 的平均兴趣分数处于下降状态，PyTorch却呈上升趋势。&lt;/p&gt;


&lt;p&gt;下面谷歌的图表显示了过去一年的搜索兴趣。TensorFlow为蓝色，Keras为黄色，PyTorch为红色，fastai为绿色。可以看出TensorFlow总体呈现下降趋势，而PyTorch却呈现持续增长姿态，不断缩小与TensorFlow的距离。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;2&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://img-blog.csdnimg.cn/20191003195109633.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly94aWFvc29uZ3NoaW5lLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://img-blog.csdnimg.cn/20191003195109633.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly94aWFvc29uZ3NoaW5lLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://img-blog.csdnimg.cn/20191003195109633.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly94aWFvc29uZ3NoaW5lLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;按这样的趋势，PyTorch在用户搜索兴趣方面追赶上TensorFlow指日可待了，TensorFlow遭遇到出生以来最大的挑战（其实TensorFlow也就才三岁多）。TensorFlow会如何应对这个挑战呢？是按部就班，在1.x版本上进行小修小补，得过且过（这个词用得有些过了，之所以会用是刚好写到这里的时候听到这首歌，同时这个词语与表达笔者对上述方法的不苟同）；还是推倒重来，重新设计新版TensorFlow，涅槃重生。这个选择会关乎到以后TensorFlow数年的发展和与PyTorch竞争的成败。笔者相信，Google 并不会做选择，小孩才会做选择，大人全都要。以谷歌的巨大体量，在内部执行两个方案，最后看市场反馈推出最合适的。Google是大公司，以稳为主的策略还是很容易让人理解的。&lt;/p&gt;

&lt;h2&gt;3 王者归来·槃涅&lt;/h2&gt;
&lt;p&gt;我们都知道Google推出了后者方案，选择&lt;strong&gt;涅槃&lt;/strong&gt;重生，重塑自身。那么全新的TensorFlow 2.0 究竟新在哪里呢？TensorFlow官网给出了答复：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Keras与TensorFlow紧密集成，默认eager execution，执行Pythonic函数。官方表示，对开发者来说，TensorFlow 2.0用起来跟Python差不多；对于研究者来说，新框架也在低级API方面进行了重点投入。&lt;/li&gt;
&lt;li&gt;为了在各种平台上运行，SavedModel文件格式进行了标准化。&lt;/li&gt;
&lt;li&gt;针对高性能训练场景，可以使用Distribution Strategy API进行分布训练，且只需进行少量代码修改就能获得出色的性能。支持Keras Model.fit、自定义训练循环、多GPU等等。&lt;/li&gt;
&lt;li&gt;TensorFlow 2.0提高了在GPU上的性能表现。以ResNet-50和BERT为例，只需要几行代码，混合精度使用Volta和Turing GPU，训练表现最高可以提升3倍。&lt;/li&gt;
&lt;li&gt;新增TensorFlow Datasets，为包含大量数据类型的大型数据集提供了标准接口。&lt;/li&gt;
&lt;li&gt;虽然保留了传统的基于Session的编程模型，但官方现在建议使用eager execution进行常规的Python开发。tf.function装饰器可以把代码转换成可以远程执行、序列化、性能优化的图。在Autograph的帮助下，能把常规的Python控制流直接转成TensorFlow控制流。&lt;/li&gt;
&lt;li&gt;官方提供了TensorFlow 1.x升级2.0的迁移指南，TF2.0还有一个自动转换的脚本。&lt;/li&gt;
&lt;li&gt;TensorFlow 2.0提供了易用的API，能够灵活快速的实现新想法。模型的训练和serving也已经无缝集成在基础架构中。&lt;/li&gt;
&lt;li&gt;更多关于TensorFlow 2.0的信息，可以访问官网：&lt;a href=&quot;https://www.tensorflow.org/&quot; data-cke-saved-href=&quot;https://www.tensorflow.org/&quot;&gt;https://www.tensorflow.org/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;几乎每一条都直击TensorFlow1.x用户的痛点，广大使用TensorFlow1.x转到PyTorch的用户表示TensorFlow 2.0 真香，纷纷倒戈。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Google深度学习科学家以及Keras的作者表示，TensorFlow 2.0 是一个新时代的机器学习平台，这将改变了一切。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;深度学习研究和教育者、fast.ai创始人Jeremy Howard也称赞 2.0 版本的发布是”令人兴奋的一步，与TensorFlow一代相比是一个巨大的飞跃“。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;目前GitHub上排名第一的NLP机器学习课程practicalAI的作者以及苹果公司AI研究员Goku Mohandas在推特上说，他们正在从PyTorch转向TensorFlow 2.0。&lt;/p&gt;
&lt;/blockquote&gt;


&lt;p&gt;此后，PyTorch在与TensorFlow的争霸中将再难有胜算，TensorFlow 1.x 版本的失误给了PyTorch赶超的机会，PyTorch已尽力追赶了，但是还是没有实现赶超。Now，TensorFlow 2.0 已经补全缺点，同时具备比PyTorch更加完备的多平台支持、更成熟的部署方式与数量巨大的用户基数。如果PyTorch早出生一年，或者TensorFlow 2.0 晚发布一年，PyTorch还是有机会的，但是没有如果，Google依旧是最强大科技公司之一，很难反复给对手机会赶超。TensorFlow再次呈现对于其他框架压倒式优势，实现王者归来。&lt;/p&gt;

&lt;h2&gt;4 终章&lt;/h2&gt;
&lt;p&gt;TensorFlow从最开始 0.1 版本诞生时受到广泛关注，到 1.0 版本的全面爆发，再到今年 2.0 版本正式发布，它已趋于完美。TensorFlow的成长依托于Google的强大研发与号召力，但TensorFlow的成功更归功于设计的完备性、审时度势和适时革新。&lt;/p&gt;
&lt;p&gt;经历四年时光，TensorFlow的发展与成功离不开先天的优秀天赋（Google Brain），更有赖于后天的努力拼搏（适时革新）。有天分又有努力，TensorFlow的成功理所应当。&lt;/p&gt;

&lt;h2&gt;附&lt;/h2&gt;
&lt;p&gt;想要体验正式版本TensorFlow 2.0 可以访问=&amp;gt;『TensorFlow2.0正式版教程』极简安装TF2.0正式版（CPU&amp;amp;GPU）教程：&lt;a href=&quot;https://xiaosongshine.blog.csdn.net/article/details/101844926&quot; data-cke-saved-href=&quot;https://xiaosongshine.blog.csdn.net/article/details/101844926&quot;&gt;https://xiaosongshine.blog.csdn.net/article/details/101844926&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;喜欢我的文章欢迎访问&lt;/p&gt;
&lt;p&gt;小宋是呢 CSDN=&amp;gt; &lt;a href=&quot;https://xiaosongshine.blog.csdn.net/&quot; data-cke-saved-href=&quot;https://xiaosongshine.blog.csdn.net/&quot;&gt;https://xiaosongshine.blog.csdn.net/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;小宋是呢 知乎=&amp;gt; &lt;a href=&quot;https://www.zhihu.com/people/xiaosongshine/activities&quot; data-cke-saved-href=&quot;https://www.zhihu.com/people/xiaosongshine/activities&quot;&gt;https://www.zhihu.com/people/xiaosongshine/activities&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 03 Oct 2019 13:16:00 +0000</pubDate>
<dc:creator>小宋是呢</dc:creator>
<og:description>​ ​ 0 序篇 2015年11月，Google正式发布了Tensorflow的白皮书并开源TensorFlow 0.1 版本。 2017年02月，Tensorflow正式发布了1.0.0版本，同时也</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiaosongshine/p/11620816.html</dc:identifier>
</item>
</channel>
</rss>