<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Java学到什么程度才能叫精通？ - 手留余香·</title>
<link>http://www.cnblogs.com/yuxiang1/p/10422857.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuxiang1/p/10422857.html</guid>
<description>&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;把下面这些内容掌握以后，你就可以自诩精通Java后端了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1 计算机基础&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这部分内容是计算机相关专业同学的课程，但是非科班的小伙伴（譬如在下）就需要花时间恶补了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;特别 是计算机网络，操作系统，数据结构这三门课程。 至于编译原理，个人大概懂一点就行了，我也只看过简单的概念和状态机相关的内容，并不是特别重要。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2 Java编程&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里的Java编程部分包含了很多内容。我们可以分别看看，大概归纳一下就是这几个部分。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;Java基础&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里的Java基础包括基本语法，集合类框架，以及一些高级特性，比如反射，注解等等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;J&lt;/span&gt;&lt;span&gt;ava基础的知识点非常多，所以要真正搞懂也没有那么简单，另外，随着时间推移，一些新特性也需要得 到我们的重视，比如时下流行的JDK8。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;设计模式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我一直觉得设计模式可以和Java基础一块学，所以我也把它放在这里。当然，一些真正使用到设计模式的 地方，譬如JDK的集合类，IO流等等，也需要你足够重视。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;Java Web技术&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Java Web技术包括J2EE，以及web框架，乃至一系列常用的组件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1 J2EE主要包括的就是servlet，jsp这些比较复古的web开发组件了。虽然现在直接用它们的情况比较少， 但是我们还是需要花一些时间去掌握它们的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2 web框架常用的就是Spring了，相应的，hibernate和mybatis也需要了解一下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3 同时，JavaWeb开发时的常用类库，比如jnuit单元测试，log4j日志工具，以及构建工具maven，都属 于我们要掌握的范畴。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4 最后，要注意的是，Web相关的一些基本知识，比如HTTP协议，网络安全基础，也是我们要考虑的部 分。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;Java并发技术&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Java的并发技术泛指Java的多线程技术，以及JUC包里的并发类，比如线程池，并发工具类，阻塞队列等 等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; Java并发技术完全可以独立出来学习，是Java进阶知识的一大重点。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;Java网络编程和服务器&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这一块内容是Java中比较复杂但也很重要的一块内容。比如BIO,NIO,AIO的一些使用和原理，以及tomcat 这类web服务器，甚至是netty这种网络编程框架，都是可以去了解和学习的内容。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Jvm基础与调优&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;JVM是提供Java程序运行的一个进程，学习JVM知识，也是我们的必经之路。除了看懂《深入理解jvm虚 拟机》以外，我们还要学习的内容就是JVM调优，使用合适的工具诊断问题，最后解决问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这部分内容在面试中呈现的不仅仅是GC,内存分区，以及类加载器，也包括了我所说的JVM调优问题。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;3 Linux&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;作为后台同学，常年被面试官问linux相关的问题，所以觉得学好linux还是蛮重要的，除了基本命令以外， 最好还能了解一些shell脚本，甚至是内核相关的知识，这方面是我的一个弱项。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;4 数据相关&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在这个路线图里，数据部分囊括了非常多的数据源，我们可以来看看都有哪些是我们需要掌握的。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;关系数据库Mysq&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个不必多说，人手都要会，不管是基础的crud，索引，抑或是进阶的存储引擎，分布式方案等，我们都 需要对应掌握。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;缓存&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如Redis，memcache一类的缓存，作为后端开发者的我们也需要对应掌握，当然，它们的高级特性，以 及分布式方案，也是必备的知识点。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;搜索引擎&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;基于Lucene的solr，elasticsearch这类搜索引擎，本质上也是数据源，但是并不是后端必备的内容，不过 学一学也没有坏处啦。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;大数据&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;海量数据处理的场景越来越多，大数据技术如hadoop，storm等也越来越火，但是大数据应用一般会由专 业的大数据工程师来做，所以我们学一些基本内容也就足够了。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;5 算法和数据结构&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;算法一直是校招同学面前的一座大山，作为后端同学来讲，除了基本的数据结构算法以外，也要会一些高 级的算法，譬如dp，搜索，贪心等等。 另外，通过LeetCode等题库来刷题的方式来巩固算法也是公认的好办法了。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;6 分布式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最后一个部分，也是内容最多，覆盖面最广泛的部分了。分布式相关的技术实在太多了，我们这里也会做 一下简单的归纳。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;web架构&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先了解web架构的发展会对分布式的学习有更好的理解，毕竟架构的发展也对应着分布式技术的发展。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;分布式理论&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这部分内容包括分布式的发展演化，base理论和cap理论等等，学习分布式技术之前，最好能对这部分概 念有一定了解。 &lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;一致性问题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;强一致性的解决方案：事务和锁，弱一致性的方案：消息队列。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;分布式session&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一个常见的问题，也有多种解决方案&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;分布式缓存&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;和上面说的缓存一样，只不过这里侧重缓存的分布式方案&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;分布式数据库&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里指的数据库的分布式方案，也包括hbase这种分布式数据库。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;负载均衡&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;负载均衡也是一个值得探讨的话题，一般我们讨论的是七层和四层负载均衡&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;消息队列&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;消息队列是一个比较复杂的分布式组件，我们可以了解常用消息队列比如amq，kafka等的实现。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;服务化&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;服务化的核心包括rpc，服务注册中心等等。分布式服务相关技术也是后端同学必须掌握的内容&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;虚拟化&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;虚拟化同样不是后端同学必须掌握的内容，只不过现在越来越多的服务部署方式使用的是docker和云服务 的方式。所以了解一下也没有什么不好的。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 23 Feb 2019 07:32:00 +0000</pubDate>
<dc:creator>手留余香&amp;#183;</dc:creator>
<og:description>​ ​ 把下面这些内容掌握以后，你就可以自诩精通Java后端了。 1 计算机基础 这部分内容是计算机相关专业同学的课程，但是非科班的小伙伴（譬如在下）就需要花时间恶补了。 特别 是计算机网络，操作系统</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuxiang1/p/10422857.html</dc:identifier>
</item>
<item>
<title>OpenCV+TensorFlow实现自定义手写图像识别 - 大数据技术宅</title>
<link>http://www.cnblogs.com/followees/p/10422791.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/followees/p/10422791.html</guid>
<description>&lt;p&gt;&lt;img title=&quot;兔子红箭头引导关注&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/rS5GicKt8v7LArHIwDXUMGfhEiaDWXMEWMW95ACKibBqejJT1Ka6C4YwgTQo0g0osfUXvDOjPhFyqOKbPQDm1ia23Q/640?wx_fmt=gif&quot; alt=&quot;&quot; data-ratio=&quot;0.11875&quot; data-type=&quot;gif&quot; data-w=&quot;640&quot; data-backw=&quot;558&quot; data-backh=&quot;66&quot; data-before-oversubscription-url=&quot;https://mmbiz.qpic.cn/mmbiz_gif/rS5GicKt8v7LArHIwDXUMGfhEiaDWXMEWMW95ACKibBqejJT1Ka6C4YwgTQo0g0osfUXvDOjPhFyqOKbPQDm1ia23Q/640?wx_fmt=gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;继&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU0Mjc0NDk2OQ==&amp;amp;mid=2247483786&amp;amp;idx=1&amp;amp;sn=581ec4bb165ffc65e15ce9feb8a3fac6&amp;amp;chksm=fb17496ccc60c07a2a4ca3f5849a328b8412033a4f7d8ae5f945e301264714198dd6ba62df87&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;用TensorFlow教你做手写字识别（准确率94.09%）&lt;/a&gt;文章中，笔者给出了CNN模型的训练以及给出了一些数字图像进行效果测试，这篇文章，笔者将给出自己手写数字图像，并且对图像进行简单处理，用上一篇文章中训练的网络进行手写数字的识别。下边跟着笔者的步伐实现属于自己的数字图像识别。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;工具要求&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;工具及环境要求如下，如果大家在安装TensorFlow过程遇到问题，可以咨询笔者一起探讨。&lt;/p&gt;
&lt;ul class=&quot; list-paddingleft-2&quot;&gt;&lt;li&gt;
&lt;p&gt;Python 2.7.14&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TensorFlow 1.5&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;pip 10.0.1&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;linux环境&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;openCV 2.4.13.6&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;C++&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;数字图像素材准备&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;笔者画了两个手写字，如图1所示，读者可以自行绘制自己的手写字图像。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/rS5GicKt8v7ISvO9Gj6906mmR6Ihs7DIJAO4hX1GrMicWtyv7slH3gu1us3uubIkqzkLDCVFyc15Tue1Bx4E93qQ/640?wx_fmt=png&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.4675438596491228&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1140&quot; data-backw=&quot;558&quot; data-backh=&quot;261&quot; data-before-oversubscription-url=&quot;https://mmbiz.qpic.cn/mmbiz_png/rS5GicKt8v7ISvO9Gj6906mmR6Ihs7DIJAO4hX1GrMicWtyv7slH3gu1us3uubIkqzkLDCVFyc15Tue1Bx4E93qQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图1 手绘数字图片&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;手绘数字图像预处理&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;由于笔者训练的CNN网络的输入图像是28*28像素的，所以需要对手绘数字图像进行简单处理，转换成28*28的灰度图像。图像处理的工具用的是openCV，C++代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;C++ language-C++ hljs&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 1&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-meta-keyword&quot;&gt;include &lt;span class=&quot;hljs-meta-string&quot;&gt;&amp;lt;opencv2/core/core.hpp&amp;gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 2&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-meta-keyword&quot;&gt;include &lt;span class=&quot;hljs-meta-string&quot;&gt;&amp;lt;opencv2/highgui/highgui.hpp&amp;gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 3&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-meta-keyword&quot;&gt;include &lt;span class=&quot;hljs-meta-string&quot;&gt;&amp;lt;opencv2/imgproc/imgproc.hpp&amp;gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 4&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-meta-keyword&quot;&gt;include &lt;span class=&quot;hljs-meta-string&quot;&gt;&quot;cv.h&quot;  &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 5&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-meta-keyword&quot;&gt;include &lt;span class=&quot;hljs-meta-string&quot;&gt;&amp;lt;string&amp;gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 6&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-meta-keyword&quot;&gt;include &lt;span class=&quot;hljs-meta-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 7&lt;span class=&quot;hljs-keyword&quot;&gt;using &lt;span class=&quot;hljs-keyword&quot;&gt;namespace cv;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 8&lt;span class=&quot;hljs-keyword&quot;&gt;using &lt;span class=&quot;hljs-keyword&quot;&gt;namespace &lt;span class=&quot;hljs-built_in&quot;&gt;std;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 9&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;10cv::Mat org,dst,img,tmp;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;11&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;on_mouse&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int event,&lt;span class=&quot;hljs-keyword&quot;&gt;int x,&lt;span class=&quot;hljs-keyword&quot;&gt;int y,&lt;span class=&quot;hljs-keyword&quot;&gt;int flags,&lt;span class=&quot;hljs-keyword&quot;&gt;void *ustc)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;C++代码需要先编译，再运行，运行过程中如果遇到什么问题，欢迎读者跟笔者沟通，处理完之后图像如图2所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/rS5GicKt8v7ISvO9Gj6906mmR6Ihs7DIJN3RVrr5Nqv87Z3MmkoUfdLHQl063FxP5TtIO5durxawaaSW74Zicddw/640?wx_fmt=png&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.49514563106796117&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1133&quot; data-backw=&quot;558&quot; data-backh=&quot;277&quot; data-before-oversubscription-url=&quot;https://mmbiz.qpic.cn/mmbiz_png/rS5GicKt8v7ISvO9Gj6906mmR6Ihs7DIJN3RVrr5Nqv87Z3MmkoUfdLHQl063FxP5TtIO5durxawaaSW74Zicddw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图2 预处理后手写图像&lt;/p&gt;
&lt;p&gt;调用CNN网络对图像进行识别&lt;/p&gt;

&lt;p&gt;用上一篇文章（&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU0Mjc0NDk2OQ==&amp;amp;mid=2247483786&amp;amp;idx=1&amp;amp;sn=581ec4bb165ffc65e15ce9feb8a3fac6&amp;amp;chksm=fb17496ccc60c07a2a4ca3f5849a328b8412033a4f7d8ae5f945e301264714198dd6ba62df87&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;用TensorFlow教你做手写字识别（准确率94.09%）&lt;/a&gt;）部分，测试模型的代码，对处理过的手写图像进行识别，识别结果如图3所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/rS5GicKt8v7ISvO9Gj6906mmR6Ihs7DIJXVBxPA55XdeasBiaZeVekEkEicVQssxCSXWedSIY9UuZ0ATkjBpgPLeA/640?wx_fmt=jpeg&quot; alt=&quot;&quot; data-backh=&quot;105&quot; data-backw=&quot;558&quot; data-before-oversubscription-url=&quot;https://mmbiz.qpic.cn/mmbiz_png/rS5GicKt8v7ISvO9Gj6906mmR6Ihs7DIJOegqgVRDnO2I2Md4dialGGZ53vfY77ImdzF0Rz2cdkFTRIRQQ5Y1jPg/640?wx_fmt=png&quot; data-copyright=&quot;0&quot; data-oversubscription-url=&quot;https://mmbiz.qlogo.cn/mmbiz_jpg/rS5GicKt8v7ISvO9Gj6906mmR6Ihs7DIJXVBxPA55XdeasBiaZeVekEkEicVQssxCSXWedSIY9UuZ0ATkjBpgPLeA/0?wx_fmt=jpeg&quot; data-ratio=&quot;0.1873661670235546&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;934&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图3 手写数字是被结果&lt;/p&gt;

&lt;p&gt;通过笔者两篇手写数字识别文章的学习，相信动手尝试的读者已经对图像识别的流程有了简单的了解，在后续的图像识别系列文章中笔者会更加深入的介绍图像识别。图像识别的接下来两篇文章中笔者会用一篇讲解Faster R-CNN的原理，另一篇介绍Faster R-CNN的应用，并附上模型代码，预计要达到的效果如图4所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/rS5GicKt8v7ISvO9Gj6906mmR6Ihs7DIJCJzkZR0Nx6DorptAdic5MYicWwvCumfeYU9V3zOpwDg9Om1RKTVwbcNg/640?wx_fmt=png&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.7459807073954984&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;622&quot; data-backw=&quot;558&quot; data-backh=&quot;416&quot; data-before-oversubscription-url=&quot;https://mmbiz.qpic.cn/mmbiz_png/rS5GicKt8v7ISvO9Gj6906mmR6Ihs7DIJCJzkZR0Nx6DorptAdic5MYicWwvCumfeYU9V3zOpwDg9Om1RKTVwbcNg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图4 图像识别效果&lt;/p&gt;

&lt;p&gt;最后，笔者说一些题外话，本公众号运营到维护已经有近两个月时间，由于是笔者利用周末和业余时间所写，所以更新会比较缓慢，但笔者可以保证每周至少有一篇原创分享，并且保证本公众号不会存在任何商业行为，完全出于笔者爱好。希望想从事大数据及人工智能相关工作的读者与笔者互动交流，一块进步。&lt;/p&gt;


&lt;p&gt;持续更新ing&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;0.jpg&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/rS5GicKt8v7ISvO9Gj6906mmR6Ihs7DIJeqQdnXxXf03lApiaMMAJAKVbhYjBNLkQ8UGAM8MDS2PtxyuibgdgNXEw/640?wx_fmt=jpeg&quot; alt=&quot;&quot; data-ratio=&quot;1&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot; data-width=&quot;100%&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 23 Feb 2019 07:15:00 +0000</pubDate>
<dc:creator>大数据技术宅</dc:creator>
<og:description>【手写字识别】专题分享</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/followees/p/10422791.html</dc:identifier>
</item>
<item>
<title>#6   判断一个数是否为2的n次方 - MinuteSheep</title>
<link>http://www.cnblogs.com/minutesheep/p/10422761.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/minutesheep/p/10422761.html</guid>
<description>&lt;p&gt;&lt;strong&gt;「ALBB面试题」&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;【题目】&lt;/p&gt;
&lt;p&gt;如何判断一个数是否为2的n次方&lt;/p&gt;
&lt;p&gt;【题目分析】&lt;/p&gt;
&lt;p&gt;看到这种题，相信大家第一反应就是循环除2，这样做肯定是可以得出结果的；但是这种做法无疑大大增加了计算机的运行时间，一个非常大的数字可能会让计算机内存溢出，有没有更好的解决方式呢？有！如果你对数字2敏感，那么一定会想到二进制方法，2&lt;sup&gt;0&lt;/sup&gt;=0b1、2&lt;sup&gt;1&lt;/sup&gt;=10、2&lt;sup&gt;2&lt;/sup&gt;=0b100、2&lt;sup&gt;3&lt;/sup&gt;=0b1000......通过找规律发现，只要是2的n次方，它的二进制表示形式中1只有一个。所以本题转换为判断一个数字的二进制形式中1是否只有一个。那么该如何统计呢？&lt;/p&gt;
&lt;p&gt;方法一：将其转换为字符串，之后统计1的个数&lt;/p&gt;
&lt;p&gt;方法二：再仔细观察，2&lt;sup&gt;0&lt;/sup&gt;-1=0、2&lt;sup&gt;1&lt;/sup&gt;-1=0b01、2&lt;sup&gt;2&lt;/sup&gt;-1=0b011、2&lt;sup&gt;3&lt;/sup&gt;-1=0b0111......，得到规律：如果一个数字i为2的n次方，则 &lt;span class=&quot;cnblogs_code&quot;&gt;i&amp;amp;(i-1)=0&lt;/span&gt; &lt;span&gt;(推荐）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;【解答】&lt;/p&gt;
&lt;p&gt;方法一：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('3c3e1bcb-0a63-4033-9b6b-6a65c0fb246c')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_3c3e1bcb-0a63-4033-9b6b-6a65c0fb246c&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_3c3e1bcb-0a63-4033-9b6b-6a65c0fb246c&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('3c3e1bcb-0a63-4033-9b6b-6a65c0fb246c',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_3c3e1bcb-0a63-4033-9b6b-6a65c0fb246c&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/Users/minutesheep/.pyenv/shims/python&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; isPower(n):
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;'''&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    判断是否为2的n次方
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;'''&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         n =&lt;span&gt; str(bin(n))
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; n.count(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) == 1&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;是2的n次方&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;不是2的n次方&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;except&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;错误：只接收数字&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     test_num = 2048
&lt;span&gt;20&lt;/span&gt;     isPower(test_num)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;程序源代码&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('8f5d0581-1fec-4f1d-b036-6b06cb378aed')&quot;&gt;&lt;img id=&quot;code_img_closed_8f5d0581-1fec-4f1d-b036-6b06cb378aed&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_8f5d0581-1fec-4f1d-b036-6b06cb378aed&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('8f5d0581-1fec-4f1d-b036-6b06cb378aed',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_8f5d0581-1fec-4f1d-b036-6b06cb378aed&quot; class=&quot;cnblogs_code_hide&quot;&gt;
&lt;pre&gt;
是2的n次方
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;运行结果&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;方法二：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('0396a3d1-782c-4c6a-9942-964ef668dbb5')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_0396a3d1-782c-4c6a-9942-964ef668dbb5&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_0396a3d1-782c-4c6a-9942-964ef668dbb5&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('0396a3d1-782c-4c6a-9942-964ef668dbb5',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_0396a3d1-782c-4c6a-9942-964ef668dbb5&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/Users/minutesheep/.pyenv/shims/python&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; isPower(n):
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;'''&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    判断是否为2的n次方
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;'''&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; n&amp;amp;(n-1) ==&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;是2的n次方&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;不是2的n次方&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;except&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;错误：只接收数字&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     test_num = 2048
&lt;span&gt;19&lt;/span&gt;     isPower(test_num)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;程序源代码&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('be9e2d38-248e-434e-b512-9b42742008f3')&quot;&gt;&lt;img id=&quot;code_img_closed_be9e2d38-248e-434e-b512-9b42742008f3&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_be9e2d38-248e-434e-b512-9b42742008f3&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('be9e2d38-248e-434e-b512-9b42742008f3',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_be9e2d38-248e-434e-b512-9b42742008f3&quot; class=&quot;cnblogs_code_hide&quot;&gt;
&lt;pre&gt;
是2的n次方
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;运行结果&lt;/span&gt;&lt;/div&gt;
</description>
<pubDate>Sat, 23 Feb 2019 07:12:00 +0000</pubDate>
<dc:creator>MinuteSheep</dc:creator>
<og:description>掌握二进制的相关技巧</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/minutesheep/p/10422761.html</dc:identifier>
</item>
<item>
<title>Powershell:关于PSCustomObject你想知道的一切(译) - 周国通</title>
<link>http://www.cnblogs.com/tylerzhou/p/10421574.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tylerzhou/p/10421574.html</guid>
<description>&lt;p&gt;&lt;code&gt;PSCustomObject&lt;/code&gt;是Powershell里非常重要的一个工具,我们先从基础开始然后再循序渐进讲到一些更高级的话题.&lt;code&gt;PSCustomObject&lt;/code&gt;旨在于用简单的方法来创建结构化数据.下面的第一个例子全让你更清楚地理解这句话是什么意思.&lt;/p&gt;
&lt;h2 id=&quot;创建一个pscustomobject&quot;&gt;创建一个PSCustomObject&lt;/h2&gt;
&lt;p&gt;在Powershell编程里,我非常喜欢使用&lt;code&gt;[PSCustomObject]&lt;/code&gt;,创建一个可用的对象从来没有如此简单.因此,这里我将跳过使用其它方式来创建一个对象(仅使用&lt;code&gt;PSCustomObject&lt;/code&gt;),要注意的是,需要使用powershell 3.0或者以上的版本.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$myObject = [PSCustomObject]@{
    Name     = 'Kevin'
    Language = 'Powershell'
    State    = 'Texas'
}
$myObject = [pscustomobject]$myHashtable&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我很喜欢用原生方法创建一个对象但是有些时候我必须首先先创建一个hashtable.因为PSCustomObject的构造函数要以hashtable里的属性作为参数.有一点需要注意的是构建成PSCustomObject后,新对象的属性顺序可能与原来的hashtable不一样了(对象属性的顺序不再保留).&lt;/p&gt;
&lt;h2 id=&quot;使用传统方法创建pscustomobject&quot;&gt;使用传统方法创建PSCustomObject&lt;/h2&gt;
&lt;p&gt;你可能已经看到有人使用&lt;code&gt;New-Object&lt;/code&gt;来创建一个自定义Powershell对象.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$myHashtable = @{
    Name     = 'Kevin'
    Language = 'Powershell'
    State    = 'Texas'
}

$myObject = New-Object -TypeName PSObject -Property $myHashtable&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种方法可能效率低一些但是在早期的Powershell版本中,这可能是最好的选择了.&lt;/p&gt;
&lt;h2 id=&quot;保存到文件&quot;&gt;保存到文件&lt;/h2&gt;
&lt;p&gt;我发现把hashtable保存到文件的最简单方法是把它保存为json,然后你可以保存的json再导入转为一个&lt;code&gt;[PSCusomObject]&lt;/code&gt;对象&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$myObject | ConvertTo-Json -depth 1- | Set-Content -Path $Path
$myObject = Get-Content -Path $Path | ConvertFrom-Json&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;添加属性&quot;&gt;添加属性&lt;/h2&gt;
&lt;p&gt;你可以通过&lt;code&gt;Add-Member&lt;/code&gt;来给&lt;code&gt;PSCustomObject&lt;/code&gt;添加属性&lt;/p&gt;
&lt;p&gt;$myObject | Add-Member -MemberType NoteProperty -Name &lt;code&gt;ID&lt;/code&gt; -Value 'KevinMarquette'&lt;/p&gt;
&lt;p&gt;$myObject.ID&lt;/p&gt;
&lt;h2 id=&quot;删除属性&quot;&gt;删除属性&lt;/h2&gt;
&lt;p&gt;你也可以删除一个对象的属性&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$myObject | Get-Member -MemberType NoteProperty | Select -ExpandProperty Name&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;code&gt;psobject&lt;/code&gt;是对象的隐藏属性,用于获取底层对象的元信息&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;枚举属性名称&quot;&gt;枚举属性名称&lt;/h2&gt;
&lt;p&gt;有时候你需要获取对象的所有属性名称&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$myObject | Get-Member -MemberType NoteProperty | Select -ExpandProperty Name&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你也可以通过&lt;code&gt;psobject&lt;/code&gt;属性获取对象属性名称列表&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$myobject.psobject.properties.name&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;动态获取属性&quot;&gt;动态获取属性&lt;/h2&gt;
&lt;p&gt;我已经提到过你可以直接获取属性的值&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$myObject.Name&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你也可以使用字符串作为属性名称来获取,这仍然是有效的&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$myObject.'Name'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再进一步,我们可以存一个变量,然后使用它来获取属性值&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$property = 'Name'
$myObject.$property&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我知道这看起来有些奇怪,但是它是可以工作的.&lt;/p&gt;
&lt;h2 id=&quot;把pscustomobject转为hashtable&quot;&gt;把PsCustomObject转为hashtable&lt;/h2&gt;
&lt;p&gt;从上一节继续,你可以动态获取&lt;code&gt;pscustomobject&lt;/code&gt;对象的属性,然后用它们创建一个&lt;code&gt;hashtable&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$hashtable = @{}
foreach( $property in $myobject.psobject.properties.name )
{
    $hashtable[$property] = $myObject.$property
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;测试属性&quot;&gt;测试属性&lt;/h2&gt;
&lt;p&gt;如果你想要检测一个属性是否存在,你可以检测这个属性是否有值&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if( $null -ne $myObject.ID )&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是有时候值可能正是是$null,你仍然需要检测,你可以通过&lt;code&gt;psobject.properties&lt;/code&gt;来检测&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if( $myobject.psobject.properties.match('ID') )&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;添加对象方法&quot;&gt;添加对象方法&lt;/h2&gt;
&lt;p&gt;如果你想添加脚本方法到一个对象,你可以通过&lt;code&gt;Add-Member&lt;/code&gt;来添加一个脚本块.你需要使用&lt;code&gt;$this&lt;/code&gt;自动变量来引用当前对象.这里是一个代码块来让一个&lt;code&gt;pscustomobject&lt;/code&gt;转换为&lt;code&gt;hashtable&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ScriptBlock = {
    $hashtable = @{}
    foreach( $property in $this.psobject.properties.name )
    {
        $hashtable[$property] = $this.$property
    }
    return $hashtable
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们把它作为一个脚本属性添加到对象&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$memberParam = @{
    MemberType = &quot;ScriptMethod&quot;
    InputObject = $myobject
    Name = &quot;ToHashtable&quot;
    Value = $scriptBlock
}
Add-Member @memberParam&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们可以像以下来调用这个方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$myObject.ToHashtable()&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;对象和值类型&quot;&gt;对象和值类型&lt;/h2&gt;
&lt;p&gt;对象和值类型对变量的赋值处理方法不同.如果你把值类型变量赋值给一另个变量,仅仅是把值拷贝了一份给这个变量&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$first = 1
$second = $first
$second = 2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这里&lt;code&gt;$first&lt;/code&gt;的值是1,&lt;code&gt;$second&lt;/code&gt;的值是2&lt;/p&gt;
&lt;p&gt;对象类型变量保存了对实际对象的引用,当你把一个对象赋值给一个新变量,它们仍然引用相同的对象&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$third = [PSCustomObject]@{Key=3}
$fourth = $third
$fourth.Key = 4&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为&lt;code&gt;$third&lt;/code&gt;和&lt;code&gt;$fourth&lt;/code&gt;引用的是同一对象的实例,因此&lt;code&gt;$third.key&lt;/code&gt;和&lt;code&gt;$fourth.key&lt;/code&gt;的值都是4&lt;/p&gt;
&lt;h2 id=&quot;psobject.copy-方法&quot;&gt;psobject.copy() 方法&lt;/h2&gt;
&lt;p&gt;如果你需要一个对象的真正副本,你可以克隆它&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$third = [PSCustomObject]@{Key=3}
$fourth = $third.psobject.copy()
$fourth.Key = 4&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;克隆创建了一个对象的浅拷贝.这时候它们有了不同的实例,并且在这个示例里&lt;code&gt;$third.key&lt;/code&gt;值为3而&lt;code&gt;$fourth.Key&lt;/code&gt;的值为4&lt;/p&gt;
&lt;p&gt;我把它称作浅拷贝是因为如果对象是嵌套的(属性包含其它对象属性),仅仅顶层的值被拷贝,子对象之间仍然保持相互引用.&lt;/p&gt;
&lt;h2 id=&quot;自定义对象类型的pstypename&quot;&gt;自定义对象类型的PSTypeName&lt;/h2&gt;
&lt;p&gt;有了一个对象以后,我们仍然可以做一些看起来似乎不是很明显的事情.首先要做的是给它一个&lt;code&gt;PSTypeName&lt;/code&gt;.下面是一个普遍采用的方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$myObject.PSObject.TypeNames.Insert(0,&quot;My.Object&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最近我又发现可以使用以下内联的方法来实现&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$myObject = [PSCustomObject]@{
    PSTypeName = 'My.Object'
    Name       = 'Kevin'
    Language   = 'Powershell'
    State      = 'Texas'
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我非常喜欢这种方法.现在我们有了一个合适的类型名称,我们可以做更多的事情.&lt;/p&gt;
&lt;h2 id=&quot;使用默认对象属性集defaultpropertyset&quot;&gt;使用默认对象属性集(DefaultPropertySet)&lt;/h2&gt;
&lt;p&gt;Powershell默认情况下决定帮我们显示哪些属性(译者注:很多对象的属性有很多,展示出来的只是少部分).很多内置命令都有一个&lt;code&gt;.ps1xml&lt;/code&gt;文件来做这件事.这里还有一个直接通过powershell来达到这种效果的方法.我们可以给它一个&lt;code&gt;MemberSet&lt;/code&gt;来用&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$defaultDisplaySet = 'Name','Language'
$defaultDisplayPropertySet = New-Object System.Management.Automation.PSPropertySet(‘DefaultDisplayPropertySet’,[string[]]$defaultDisplaySet)
$PSStandardMembers = [System.Management.Automation.PSMemberInfo[]]@($defaultDisplayPropertySet)
$MyObject | Add-Member MemberSet PSStandardMembers $PSStandardMembers&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在当我们的对象展示的时候,默认情况下只会展示以上属性&lt;/p&gt;
&lt;h2 id=&quot;对默认对象属性集defaultpropertyset使用update-typedata&quot;&gt;对默认对象属性集(DefaultPropertySet)使用Update-TypeData&lt;/h2&gt;
&lt;p&gt;以上已经非常nice了,我发现有人用更nice的方法来实现这一功能,那就是使用&lt;code&gt;Update-TypeData&lt;/code&gt;来指定默认属性&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$TypeData = @{
    TypeName = 'My.Object'
    DefaultDisplayPropertySet = 'Name','Language'
}
Update-TypeData @TypeData&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在我们可以创建一个有很多属性的对象但是仍然以一种非常简洁的方法在powershell里来展示它.如果我们想查看其它的属性,它们仍然存在的&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$myObject | Format-List *&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;scriptproperty的update-typedata&quot;&gt;ScriptProperty的Update-TypeData&lt;/h2&gt;
&lt;h2 id=&quot;对脚本属性scriptproperty使用update-typedata&quot;&gt;对脚本属性(ScriptProperty)使用Update-TypeData&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;$TypeData = @{
    TypeName = 'My.Object'
    MemberType = 'ScriptProperty'
    MemberName = 'UpperCaseName'
    Value = {$this.Name.toUpper()}
}
Update-TypeData @TypeData&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你可以在对象创建之前或者之后来做这些,都是可以的.这就是与前面对脚本块使用&lt;code&gt;Add-Member&lt;/code&gt;不同的地方.当你像前面一样使用&lt;code&gt;Add-Member&lt;/code&gt;,它仅仅对对象的某一实例有效.而这里对整个对象有效.&lt;/p&gt;
&lt;h2 id=&quot;函数参数&quot;&gt;函数参数&lt;/h2&gt;
&lt;p&gt;至此你可以对函数或者脚本使用这些自定义类型.你可以在一个函数里面创建它们然后在其它函数里面使用.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;param( [PSTypeName('My.Object')]$Data )&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;powershell会要求你输入的对象类型符合你声明的类型.如果类型不符合会抛出一个验证错误.这是一个很好的让powershell做它应该做的事情&lt;/p&gt;
&lt;p&gt;函数的&lt;code&gt;OutputType&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;你可以为你的高级函数定义一个&lt;code&gt;OutputType&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function Get-MyObject
{
    [OutputType('My.Object')] 
    [CmdletBinding()]
        param
        (
            ...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;OutputType&lt;/code&gt;仅仅是一个文档注解.它并不是从函数代码中衍生,也不与函数输出结果进行比对&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;OutputType&lt;/code&gt;的主要原因是是因为元数据信息反映了你设计函数的真实意图.类似像&lt;code&gt;Get-Command&lt;/code&gt;,&lt;code&gt;Get-Help&lt;/code&gt;和你的开发环境可以利用这些元信息.&lt;/p&gt;
&lt;p&gt;也就是说,比如你使用&lt;code&gt;Pester&lt;/code&gt;(译者注,pester为一个非常流行的powershell单元测试框架)来测试你的函数.确保函数的输出对象与你的&lt;code&gt;OutputType&lt;/code&gt;对象相吻合是一个很好的做法.它能够帮你捕获本不应该出现但是出现的变量&lt;/p&gt;
&lt;h2 id=&quot;后记&quot;&gt;后记&lt;/h2&gt;
&lt;p&gt;这是一篇关于&lt;code&gt;PSCustomObject&lt;/code&gt;的博客,但是很多东西都对一般普通对象仍然适用.&lt;/p&gt;
&lt;p&gt;过去我见到过提到的大部分特征但是从来没有见到过它们完整的在一起来展示&lt;code&gt;PSCustomObject&lt;/code&gt;的特征,但是就在上周我见到一个,令我非常惊叹并非非常吃惊我从来没有看到过它.因此我决定提取它的主要主要思想放在一起写成这篇博客以其它你可以看到它更大的蓝图并且在使用到的时候有所警觉,我希望你能学到东西并且把它用到的自己的脚本里&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://powershellexplained.com/2016-10-28-powershell-everything-you-wanted-to-know-about-pscustomobject/&quot;&gt;原文地址链接&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 23 Feb 2019 06:56:00 +0000</pubDate>
<dc:creator>周国通</dc:creator>
<og:description>`PSCustomObject PSCustomObject`旨在于用简单的方法来创建结构化数据.下面的第一个例子全让你更清楚地理解这句话是什么意思. 创建一个PSCustomObject 在Powe</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tylerzhou/p/10421574.html</dc:identifier>
</item>
<item>
<title>YY的GCD - kgxpbqbyt</title>
<link>http://www.cnblogs.com/kgxw0430/p/10420841.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kgxw0430/p/10420841.html</guid>
<description>&lt;hr/&gt;&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problemnew/show/P2257&quot;&gt;Ac链接&lt;/a&gt;&lt;/p&gt;
&lt;ul readability=&quot;5&quot;&gt;&lt;li readability=&quot;10&quot;&gt;
&lt;p&gt;题目描述：神犇YY虐完数论后给傻×kAc出了一题&lt;/p&gt;
&lt;p&gt;​ 给定N, M,求1&amp;lt;=x&amp;lt;=N, 1&amp;lt;=y&amp;lt;=M且gcd(x, y)为质数的(x, y)有多少对&lt;/p&gt;
&lt;p&gt;​ kAc这种傻×必然不会了，于是向你来请教……&lt;/p&gt;
&lt;p&gt;​ 多组输入（大概也就一万组吧……）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;解决本题需要了解莫比乌斯反演的知识，所以先来普及知识点（最为枯燥的部分，但忍下去）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;莫比乌斯函数&quot;&gt;&lt;span&gt;莫比乌斯函数&lt;/span&gt;&lt;/h4&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;：莫比乌斯函数是啥啊？&lt;/p&gt;
&lt;p&gt;：（莫比乌斯是一个由容斥系数所构成的函数）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;μ（d）的定义：
&lt;ul&gt;&lt;li&gt;当d=1时，μ（d）=1；&lt;/li&gt;
&lt;li&gt;当d=&lt;span class=&quot;math inline&quot;&gt;\(\Pi_{i=1}^kp_i\)&lt;/span&gt;且&lt;span class=&quot;math inline&quot;&gt;\(p_i\)&lt;/span&gt;为互质素数时，μ（d）=&lt;span class=&quot;math inline&quot;&gt;\((-1)^k\)&lt;/span&gt;。(说直白点，就是d分解质因数后，没有幂次大于平方的质因子，此时函数值根据分解的个数决定)；&lt;/li&gt;
&lt;li&gt;只要当d含有任何质因子的幂大于等于2，则函数值为0。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;莫比乌斯函数的一些其他有趣的性质：
&lt;ul&gt;&lt;li&gt;对于任意正整数n，&lt;span class=&quot;math inline&quot;&gt;\(\sum_{d|n}μ(d)\)&lt;/span&gt;=[n=1]。&lt;strong&gt;(PS:这一条性质是莫比乌斯反演中最常用的)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;对于任意正整数n，&lt;span class=&quot;math inline&quot;&gt;\(\sum_{d|n} \frac{μ(d)}{d}\)&lt;/span&gt;=&lt;span class=&quot;math inline&quot;&gt;\(\frac{φ(n)}{n}\)&lt;/span&gt;。（这个性质很奇妙，把欧拉函数与莫比乌斯函数结合起来，下次学杜教筛会证明）。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;求莫比乌斯函数的程序实现不难，只需要在线性筛的程序上略作修改，便可以筛出μ函数。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void mu_get(){
    mu[1]=1;
    for(int i=2;i&amp;lt;=n;++i){
        if(!v[i]){
            p[++m]=i,mu[i]=-1;
        }
        for(int j=1;j&amp;lt;=m;++j){
            if(p[j]&amp;gt;v[i]||i*p[j]&amp;gt;n) break;
            v[i*p[j]]=p[j];
            if(i%p[j]) break;
            else mu[i*p[j]]=-mu[i];
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;莫比乌斯反演&quot;&gt;莫比乌斯反演&lt;/h4&gt;
&lt;ul readability=&quot;9&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;解决了莫比乌斯函数的问题后，我们就迎来了恶心的莫比乌斯反演。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;莫比乌斯反演定理：F（n）和f（n）是定义在非负整数集合上的两个函数，并且满足条件：&lt;/p&gt;
&lt;p&gt;​ &lt;span class=&quot;math display&quot;&gt;\[F(n)=\sum_{d|n}f(d)\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;那么现在存在一个结论：&lt;/p&gt;
&lt;p&gt;​ &lt;span class=&quot;math display&quot;&gt;\[f(n)=\sum_{d|n}μ(d)F(\frac{n}{d})\]&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;莫比乌斯反演的证明主要有两种方式，其中一种就是通过定义来证明；另一种利用狄利克雷卷积。先来说一说第一种证明方法：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\sum_{d|n}μ(d)F(\frac{n}{d})=\sum_{d|n}μ(d)\sum_{i|\frac{n}{d}}f(i)\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[=\sum_{i|n}f(i)\sum_{d|\frac{n}{i}}μ(d)=f(n)\]&lt;/span&gt;&lt;/p&gt;
&lt;h5 id=&quot;ps如果不知道第二部如何推导第三部可以考虑第二个式子枚举的i与d的关系发现可以调换一下枚举的方式如果不知道最后一步怎么来的可以去看一下上面莫比乌斯函数的性质1&quot;&gt;(PS:如果不知道第二部如何推导第三部，可以考虑第二个式子枚举的i与d的关系，发现可以调换一下枚举的方式。如果不知道最后一步怎么来的，可以去看一下上面莫比乌斯函数的性质1)。&lt;/h5&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;当然，莫比乌斯反演有另外的一种形式，当F（n）和f（n）满足：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[F(n)=\sum_{n|d}f(d)\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;可以推出：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[f(n)=\sum_{n|d}μ(\frac{d}{n})F(d)\]&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;感觉这个式子，可能在莫比乌斯反演中更加好用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;回到本题&quot;&gt;回到本题&lt;/h4&gt;
&lt;ul readability=&quot;19&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;显然，Ans=&lt;span class=&quot;math inline&quot;&gt;\(\sum_{p\epsilon prim}\sum_{i=1}^n\sum_{j=1}^m[gcd(i,j)=p]\)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;对于这种和gcd有关的莫比乌斯反演，我们一般另f（d）为gcd（i，j）=d的个数，即f(d)=&lt;span class=&quot;math inline&quot;&gt;\(\sum_{i=1}^n\sum_{j=1}^m[gcd(i,j)=d]\)&lt;/span&gt; 。那么F（n）为gcd（i，j）为n或者n的倍数的个数，即：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[F(n)=\sum_{n|d}f(d)=\lfloor\frac{N}{n}\rfloor\lfloor\frac{M}{m}\rfloor\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;那么根据莫比乌斯反演定理：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[f(n)=\sum_{n|d}μ(\frac{d}{n})F(d)\]&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;23&quot;&gt;
&lt;p&gt;接下来就是化简式子了！&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[Ans=\sum_{p\epsilon prim}f(p)\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[=\sum_{p\epsilon prim}\sum_{p|d}μ(\frac{d}{p})F(d)\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;换一个枚举项，枚举&lt;span class=&quot;math inline&quot;&gt;\(\lfloor\frac{d}{p}\rfloor\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\sum_{p\epsilon prim}\sum_{d=1}^{min(\lfloor\frac{n}{p}\rfloor,\lfloor\frac{m}{p}\rfloor)}μ(d)F(dp)=\sum_{p\epsilon prim}\sum_{d=1}^{min(\lfloor\frac{n}{p}\rfloor,\lfloor\frac{m}{p}\rfloor)}μ(d)\lfloor\frac{n}{dp}\rfloor\lfloor\frac{m}{dp}\rfloor\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这个dp看着很不爽，我们把它换成T&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[Ans=\sum_{T=1}^{min(n,m)}\sum_{t|T,t\epsilon prim}μ(\frac{T}{t})\lfloor\frac{n}{T}\rfloor\lfloor\frac{m}{T}\rfloor\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[Ans=\sum_{T=1}^{min(n,m)}\lfloor\frac{n}{T}\rfloor\lfloor\frac{m}{T}\rfloor\sum_{t|T,t\epsilon prim}μ(\frac{T}{t})\]&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;这样就已经可以O（n）求了。不过这道题有多组数据，所以直接O（n）求会挂。所以我们利用前缀和的思路，打一个整除分块，就可以O（n）预处理，O（&lt;span class=&quot;math inline&quot;&gt;\(\sqrt{n}\)&lt;/span&gt;）求每一组数据了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;历经磨难终于A掉了这道题，哎数学题推式子我总是看着题解一遍一遍推，还是没有感觉，弱啊……&lt;/p&gt;
&lt;h4 id=&quot;coding&quot;&gt;&lt;span&gt;Coding&lt;/span&gt;&lt;/h4&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
#define ll long long
using namespace std;
const int N=1e7+10;
int n,m,cnt,p[N],v[N],mu[N];ll sum[N],ans,g[N];
void get_mu(int a){
    mu[1]=1;
    for(int i=2;i&amp;lt;=a;++i){
        if(!v[i]){
            p[++cnt]=i;mu[i]=-1;
        }
        for(int j=1;j&amp;lt;=cnt;++j){
            if(p[j]*i&amp;gt;a) break;
            v[i*p[j]]=p[j];
            if(i%p[j]==0) break;
            else mu[i*p[j]]=-mu[i];
        }
    }
    for(int i=1;i&amp;lt;=cnt;++i){
        for(int j=1;j*p[i]&amp;lt;=a;++j) g[p[i]*j]+=mu[j];
    }
    for(int i=1;i&amp;lt;=a;++i) sum[i]=sum[i-1]+g[i];
}
int main(){
    get_mu(1e7);
    int t;scanf(&quot;%d&quot;,&amp;amp;t);
    while(t--){
        scanf(&quot;%d%d&quot;,&amp;amp;n,&amp;amp;m);
        ans=0;
        if(n&amp;gt;m) swap(n,m);
        for(int l=1,r;l&amp;lt;=n;l=r+1){
            r=min((n/(n/l)),m/(m/l));
            ans+=(sum[r]-sum[l-1])*(n/l)*(m/l);
        }
        printf(&quot;%lld\n&quot;,ans);
    }
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;感谢pengymdalao的精彩博客&quot;&gt;感谢pengymdalao的精彩博客&lt;/h5&gt;
</description>
<pubDate>Sat, 23 Feb 2019 06:46:00 +0000</pubDate>
<dc:creator>kgxpbqbyt</dc:creator>
<og:description>'Ac链接' 题目描述：神犇YY虐完数论后给傻×kAc出了一题 ​ 给定N, M,求1莫比乌斯函数 ：莫比乌斯函数是啥啊？ ：（莫比乌斯是一个由容斥系数所构成的函数）。 μ（d）的定义： 当d=1时，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kgxw0430/p/10420841.html</dc:identifier>
</item>
<item>
<title>串行口通信（二）之串行口方式0 - 一个人的朝圣</title>
<link>http://www.cnblogs.com/juzige/p/10422670.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/juzige/p/10422670.html</guid>
<description>&lt;h2 id=&quot;h&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;上一篇就已经介绍串行口通信相关概念，寄存器。对串行口通信已经有一定的了解。还介绍串行口工作方式1，这个方式所用最多，务必会用。现在来介绍工作方式0，2，3。下面来了解一下。&lt;/p&gt;
&lt;h2 id=&quot;h0&quot;&gt;串行口方式0&lt;/h2&gt;
&lt;p&gt;串行口的工作方式0为移位寄存器I/O方式，可外接移位寄存器，一扩展I/O口，也可外接同步I/O设备。&lt;br/&gt;发送操作：当执行一条“SBUF=A”指令时，启动发送操作，由TXD输出移位脉冲，由RXD串行SBUF中的数据。发送完8位数据后自动置TI=1.请求中断。要继续发送时，TI必须有指令清零。&lt;br/&gt;接收操作：REN是串行口接收允许控制位。REN=0时禁止接收；REN=1时允许接收。当软件将REN置“1”时，即开始从RXD端口以fosc/12波特率输入数据，当接收到8位数据时，将中断标志RI置“1”。再次接收数据之前，必须用软件将RI清0。&lt;br/&gt;这个方式中，RXD为数据输入输出引脚，TXD为时钟输出引脚。主要用来拓展IO口。这个方式完成时需要借用外部移位寄存器。74ls164，74ls165两个移位寄存器与串行口方式0相得益彰。下面来介绍这两个寄存器与方式0的配合。&lt;/p&gt;
&lt;h3 id=&quot;h74ls164&quot;&gt;74ls164移位寄存器&lt;/h3&gt;
&lt;h4 id=&quot;h-1&quot;&gt;概述&lt;/h4&gt;
&lt;p&gt;74LS164是8位边沿触发式移位寄存器，串行输入数据，然后并行输出。数据通过两个输入端（DSA或DSB）之一串行输入；任一输入端可以用作高电平使能端，控制另一输入端的数据输入。两个输入端或者连接在一起，或者把不用的输入端接高电平，一定不要悬空。&lt;/p&gt;
&lt;h4 id=&quot;h-2&quot;&gt;引脚功能&lt;/h4&gt;
&lt;p&gt;&lt;img title=&quot;74LS164&quot; src=&quot;https://img-blog.csdnimg.cn/20190223133840851.jpg&quot; alt=&quot;74LS164&quot;/&gt;74LS164&lt;br/&gt;DSA,DSB:数据输入端&lt;br/&gt;CP:时钟输入（低电平到高电平边沿触发）&lt;br/&gt;MR:中央复位输入（低电平有效）&lt;br/&gt;Q0~Q7:数据输出端&lt;br/&gt;GND:地&lt;br/&gt;VCC:正电源&lt;/p&gt;

&lt;h3 id=&quot;h-3&quot;&gt;真值表&lt;/h3&gt;
&lt;p&gt;&lt;img title=&quot;真值表&quot; src=&quot;https://img-blog.csdnimg.cn/20190223134438125.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQyNTU0NA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;真值表&quot;/&gt;真值表&lt;br/&gt;H = HIGH（高）电平&lt;br/&gt;h = 先于低-至-高时钟跃变一个建立时间 (set-up time) 的 HIGH（高）电平&lt;br/&gt;L = LOW（低）电平&lt;br/&gt;l = 先于低-至-高时钟跃变一个建立时间 (set-up time) 的 LOW（低）电平&lt;br/&gt;q = 小写字母代表先于低-至-高时钟跃变一个建立时间的参考输入 (referenced input) 的状态&lt;br/&gt;↑ = 低-至-高时钟跃变&lt;/p&gt;

&lt;p&gt;数据通过DSA,DSB这两个输入端之一串行输入；任一输入端可以用作高电平使能端，控制另一输入端的数据输入。当其中任意一个为低电平，则禁止新数据输入；当其中有一个为高电平，则另一个就允许输入数据。 因此两个输入端或者连接在一起，或者把不用的输入端接高电平，一定不要悬空。&lt;br/&gt;当 MR为低电平时，其它所有输入端都无效，同时所有输出端均为低电平。为高电平时，允许数据一直输出。&lt;/p&gt;
&lt;h4 id=&quot;h-4&quot;&gt;时序图&lt;/h4&gt;
&lt;p&gt;&lt;img title=&quot;时序图&quot; src=&quot;https://img-blog.csdnimg.cn/20190223135511818.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQyNTU0NA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;时序图&quot;/&gt;时序图&lt;br/&gt;MR为高电平时，数据输入端一个为高电平，另一个输入数据，时钟端一直输入时钟。输出端就移位输出数据。&lt;/p&gt;

&lt;h3 id=&quot;h-5&quot;&gt;使用&lt;/h3&gt;
&lt;p&gt;&lt;img title=&quot;接法&quot; src=&quot;https://img-blog.csdnimg.cn/2019022314041065.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQyNTU0NA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;接法&quot;/&gt;接法&lt;br/&gt;输入端接RXD,时钟端接TXD，MR随便接一控制端（P0口要上拉电阻），输出端随意，根据自己的需求。&lt;/p&gt;

&lt;pre&gt;
&lt;code class=&quot;hljs cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-meta-keyword&quot;&gt;include&lt;span class=&quot;hljs-meta-string&quot;&gt;&amp;lt;reg52.h&amp;gt;&lt;br/&gt;sbit MR=P1^&lt;span class=&quot;hljs-number&quot;&gt;7;    &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面给出简单的示范，看懂程序后就可以自行设计更复杂的程序，可以想一下用它驱动数码管。&lt;/p&gt;
&lt;h3 id=&quot;h74ls165&quot;&gt;74LS165&lt;/h3&gt;
&lt;p&gt;74LS165芯片,它是 8 位并入串出移位寄存器 (使用移位寄存器芯片可以扩展一个或多个 8 位并行 I/O 口)。&lt;/p&gt;
&lt;h4 id=&quot;h-6&quot;&gt;引脚&lt;/h4&gt;
&lt;p&gt;&lt;img title=&quot;74LS165&quot; src=&quot;https://img-blog.csdnimg.cn/20190223141618631.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQyNTU0NA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;74LS165&quot;/&gt;74LS165&lt;br/&gt;SH/LD（shift/ load 移位 /置位）：移位与置位控制端。高电平时表示移位， 低电平时表示置位。在开始移位之前，需要先从并行输入端口读入数据，这时应将 SH/LD置 0，并行口的 8 位数据将被置入 74LS165 内部的 8 个触发器，在 SH/LD 为 1时，并行输入被封锁，移位操作开始。&lt;br/&gt;INH （clock inhibit 时钟抑制）：时钟禁止端。当 INH 为低电平时，充许时钟输入。&lt;br/&gt;CLK(clock) ：时钟输入端&lt;br/&gt;D0~D7：并行输入端&lt;br/&gt;SI（serial input 串行输入）：串行输入端， 用于扩展多个 74LS165 的首尾连接端。&lt;br/&gt;SO（ serial output）：串行输出端 .&lt;br/&gt;QH：也是串行输出端，它与 SO 是反相的关系，即 QH=SO.&lt;br/&gt;VCC(16 引脚，在 proteus 中被隐藏 )：已经默认接 +5V 电源端 .&lt;br/&gt;GND(8 引脚，在 proteus中被隐藏 )：已经默认接地&lt;/p&gt;

&lt;h3 id=&quot;h-7&quot;&gt;使用&lt;/h3&gt;
&lt;p&gt;&lt;img title=&quot;接法&quot; src=&quot;https://img-blog.csdnimg.cn/20190223142250776.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQyNTU0NA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;接法&quot;/&gt;接法&lt;br/&gt;串行口输出端接RXD,时钟端接TXD,移位/置位端接控制端，时钟抑制端接地，允许时钟输出。输入端自行决定，剩下两个端口没有用到就空接。&lt;/p&gt;

&lt;pre&gt;
&lt;code class=&quot;hljs cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-meta-keyword&quot;&gt;include&lt;span class=&quot;hljs-meta-string&quot;&gt;&amp;lt;reg52.h&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;unsigned &lt;span class=&quot;hljs-keyword&quot;&gt;int date;&lt;br/&gt;sbit SH=P1^&lt;span class=&quot;hljs-number&quot;&gt;7;    &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;简单程序，看懂就行，简单入门，需要什么功能自行添加。&lt;/p&gt;
&lt;h2 id=&quot;h-8&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;串行口方式0就只有这么多内容，主要使用来拓展IO口，和外部移位寄存器一起使用。上面的程序简单易懂，主要是为了能快速看懂，当然在实战中不可能这么简单，但会用了，开发就不成问题。方式2和3只在波特率上存在区别，它们主要用在单片机的多机通讯，下一篇将详细介绍。喜欢的朋友点个关注，转发一下吧。&lt;/p&gt;
</description>
<pubDate>Sat, 23 Feb 2019 06:45:00 +0000</pubDate>
<dc:creator>一个人的朝圣</dc:creator>
<og:description>前言 上一篇就已经介绍串行口通信相关概念，寄存器。对串行口通信已经有一定的了解。还介绍串行口工作方式1，这个方式所用最多，务必会用。现在来介绍工作方式0，2，3。下面来了解一下。 串行口方式0 串行口</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/juzige/p/10422670.html</dc:identifier>
</item>
<item>
<title>SpringMVC之Controller和参数绑定 - 风沙迷了眼</title>
<link>http://www.cnblogs.com/fsmly/p/10413163.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fsmly/p/10413163.html</guid>
<description>
&lt;p&gt;　　在上一篇&lt;a href=&quot;https://www.cnblogs.com/fsmly/p/10393507.html&quot; target=&quot;_blank&quot;&gt;Spring+SpringMVC+Mybatis&lt;/a&gt;整合中说到了SSM的整合，并且在其中添加了一个简单的查询功能，目的只是将整个整合的流程进行一个梳理，下面在&lt;a href=&quot;https://www.cnblogs.com/fsmly/p/10393507.html&quot; target=&quot;_blank&quot;&gt;上一篇&lt;/a&gt;中工程的基础上再说一些关于SpringMVC的Controller的一些细节。&lt;/p&gt;
&lt;p&gt;　　首先附上整个项目结构图，附上整个代码工程的&lt;a href=&quot;https://files.cnblogs.com/files/fsmly/TestSSM2.rar&quot; target=&quot;_blank&quot;&gt;下载地址&lt;/a&gt;，下面所讲到的测试用例都是在下面这个测试项目的基础上进行的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201902/1368768-20190221145110396-274013416.png&quot; alt=&quot;&quot; width=&quot;364&quot; height=&quot;390&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　1、使用@Controller注解可以实现Controller的注解开发，然后在springmvc.xml的配置文件中配置注解扫描器，就可以使用注解形式进行Controller的开发，下面我们简单使用一个helloworld的例子进行说明&lt;/p&gt;
&lt;p&gt;　　①在springmvc.xml中配置注解扫描器&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201902/1368768-20190221145438263-73538883.png&quot; alt=&quot;&quot; width=&quot;651&quot; height=&quot;57&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　其中也当然包含springmvc所需要的处理器映射器、处理器适配器、视图解析器（这几个组件个概念可以查看&lt;a href=&quot;https://www.cnblogs.com/fsmly/p/10349361.html&quot; target=&quot;_blank&quot;&gt;SpringMvc入门&lt;/a&gt;，其中开篇说到了SpringMVC的处理流程和各个组件以及之间的关系），我们这里直接使用下面的配置方式进行配置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201902/1368768-20190221150937432-759703544.png&quot; alt=&quot;&quot; width=&quot;574&quot; height=&quot;56&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　②写一个简单的helloworld，在浏览器中请求对应的Controller，然后输出在页面上&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.test.ssm.controller;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Controller;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RequestMapping;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.servlet.ModelAndView;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;@Controller
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HelloWorldController {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     @RequestMapping(&quot;/helloWorld.do&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; ModelAndView helloWorld() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception{
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         ModelAndView modelAndView = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ModelAndView();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         modelAndView.addObject(&quot;test&quot;,&quot;HelloSSM&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         modelAndView.setViewName(&quot;/WEB-INF/items/hello.jsp&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; modelAndView;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('1b6c0f58-12c4-456e-96f2-7d19016030a2')&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_1b6c0f58-12c4-456e-96f2-7d19016030a2&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_1b6c0f58-12c4-456e-96f2-7d19016030a2&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('1b6c0f58-12c4-456e-96f2-7d19016030a2',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_1b6c0f58-12c4-456e-96f2-7d19016030a2&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;%@ page &lt;/span&gt;&lt;span&gt;contentType&lt;/span&gt;&lt;span&gt;=&quot;text/html;charset=UTF-8&quot;&lt;/span&gt;&lt;span&gt; language&lt;/span&gt;&lt;span&gt;=&quot;java&quot;&lt;/span&gt;&lt;span&gt; %&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;$Title$&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;测试Controller
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;${test}
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;hello.jsp&lt;/span&gt;&lt;/div&gt;
&lt;p&gt; ③然后在地址栏中请求http://localhost:8080/TestSSM2/helloWorld.do，输出&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201902/1368768-20190221150530867-1537090584.png&quot; alt=&quot;&quot; width=&quot;234&quot; height=&quot;42&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;　　1、使用不同的处理器映射规则&lt;/h3&gt;
&lt;p&gt;　　a、我们通过RequestMapping 可以使用不同的处理器映射规则，RequestMapping注解能够控制http请求的路径和方式（get、post......）,在同一个Controller中可以写不同的映射方法，映射浏览器不同的请求业务。&lt;/p&gt;
&lt;p&gt;　　具体的使用方式就是：@RequestMapping(value=&quot;/test.do&quot;)或@RequestMapping(&quot;/test）,其中value的值是数组，可以将多个url映射到同一个方法&lt;/p&gt;
&lt;p&gt;　　b、下面我们就在上一篇中查询列表的基础上增加查询详细信息的一个功能，通过RequestMapping注解来实现&lt;/p&gt;
&lt;p&gt;　　①首先在mapper中将ProductDemo.xml中添加查询详细信息的Sql配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;queryProductInfo&quot;&lt;/span&gt;&lt;span&gt; parameterType&lt;/span&gt;&lt;span&gt;=&quot;java.lang.Integer&quot;&lt;/span&gt;&lt;span&gt; resultType&lt;/span&gt;&lt;span&gt;=&quot;cn.test.ssm.po.ProductExtend&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        SELECT pname,shop_price FROM product WHERE pid = #{id}
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　②在mapper接口中添加上面的方法&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201902/1368768-20190221153642545-1882293598.png&quot; alt=&quot;&quot; width=&quot;503&quot; height=&quot;27&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　③在service接口中添加相应的方法和方法实现&lt;/p&gt;
&lt;p&gt;　　service接口&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201902/1368768-20190221153736663-1296287604.png&quot; alt=&quot;&quot; width=&quot;505&quot; height=&quot;35&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　接口实现类&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201902/1368768-20190221153808127-2053196160.png&quot; alt=&quot;&quot; width=&quot;537&quot; height=&quot;95&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　④在controller层中加上queryInfo方法，其中使用RequestMapping映射了两个不同请求对应的方法实现&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.test.ssm.controller;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; cn.test.ssm.po.ProductExtend;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; cn.test.ssm.service.ProductService;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Controller;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RequestMapping;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.servlet.ModelAndView;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;@Controller
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ProductController {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    @Autowired
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; ProductService productService;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;     @RequestMapping(&quot;/queryList.do&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; ModelAndView queryList() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception{
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;从service层调用方法&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;         List&amp;lt;ProductExtend&amp;gt; productExtendList = productService.findProductListByName(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回ModelandView&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;         ModelAndView modelAndView = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ModelAndView();
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        modelAndView.addObject(productExtendList);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         modelAndView.setViewName(&quot;/WEB-INF/items/itemsList.jsp&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; modelAndView;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt;     @RequestMapping(&quot;/queryInfo.do&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; ModelAndView queryInfo() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt;         ProductExtend productExtend = productService.queryProductInfo(1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         productExtend.setDesc(&quot;这是相机&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         ModelAndView modelAndView = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ModelAndView();
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;        modelAndView.addObject(productExtend);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         modelAndView.setViewName(&quot;/WEB-INF/items/editItem.jsp&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; modelAndView;
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　⑤最后在查询列表中点击查询即可查看详细信息&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201902/1368768-20190221154026719-927657386.png&quot; alt=&quot;&quot; width=&quot;453&quot; height=&quot;104&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;　　2、窄化请求映射&lt;/h3&gt;
&lt;p&gt; 　　a）为了实现不同模块之间的开发，我们可以进行这样的使用：在class上添加@RequestMapping(url)指定通用请求前缀， 限制此类下的所有方法请求url必须以请求前缀开头，通过此方法对url进行分类管理。&lt;/p&gt;
&lt;p&gt; 　　b）如下：@RequestMapping放在类名上边，设置请求前缀&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　@Controller&lt;/p&gt;
&lt;p&gt;　　@RequestMapping(&quot;/test&quot;)&lt;/p&gt;
&lt;p&gt;　　然后在方法名上边设置请求映射url：&lt;/p&gt;
&lt;p&gt;　　@RequestMapping(&quot;/queryItem &quot;) &lt;/p&gt;
&lt;p&gt;　　访问地址为：http://localhost:8080/TestSSM2/test/queryList.do&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201902/1368768-20190221154633953-482225152.png&quot; alt=&quot;&quot; width=&quot;419&quot; height=&quot;189&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;　　3、关于http请求方式限定&lt;/h3&gt;
&lt;p&gt;　　 a）限定POST方法：@RequestMapping(method = RequestMethod.&lt;em&gt;POST&lt;/em&gt;)&lt;/p&gt;
&lt;p&gt;　　如果通过Get访问则报错：HTTP Status 405 - Request method 'GET' not supported，例如&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201902/1368768-20190221155109919-1779648592.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　然后访问http://localhost:8080/TestSSM2/test/queryList.do，就会是下面的错误&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201902/1368768-20190221155302430-506146754.png&quot; alt=&quot;&quot; width=&quot;560&quot; height=&quot;131&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　b）限定GET方法：@RequestMapping(method = RequestMethod.&lt;em&gt;GET&lt;/em&gt;)&lt;/p&gt;
&lt;p&gt;　　如果通过Post访问则报错：HTTP Status 405 - Request method 'POST' not supported&lt;/p&gt;
&lt;p&gt;　　c）GET和POST都可以：@RequestMapping(method={RequestMethod.GET,RequestMethod.POST}) &lt;/p&gt;

&lt;h3&gt;　　1、返回ModelAndView&lt;/h3&gt;
&lt;p&gt;　　a）我们上面编写Controller都是以这种方式进行的，大概就是定义一个ModelAndView对象，然后填充模型（从数据库中得到的数据）和逻辑视图（指定的jsp等路径），并返回即可&lt;/p&gt;
&lt;p&gt;　　b）例如&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201902/1368768-20190221155703614-2108569673.png&quot; alt=&quot;&quot; width=&quot;413&quot; height=&quot;92&quot;/&gt;&lt;/p&gt;
&lt;h3&gt; 　　2、使用void类型&lt;/h3&gt;
&lt;p&gt;　　a）在controller方法形参上可以定义request和response，使用request或response指定响应结果：&lt;/p&gt;
&lt;p&gt;　　①使用request转向页面:request.getRequestDispatcher(&quot;页面路径&quot;).forward(request, response);&lt;/p&gt;
&lt;p&gt;　　例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    @RequestMapping(&quot;/test_void.do&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testVoid(HttpServletRequest request, HttpServletResponse response) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception{
        request.setAttribute(&lt;/span&gt;&quot;test&quot;,&quot;返回值为void类型的测试&quot;&lt;span&gt;);
        request.getRequestDispatcher(&lt;/span&gt;&quot;/WEB-INF/items/hello.jsp&quot;&lt;span&gt;).forward(request,response);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后输出结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201902/1368768-20190221162019903-1735905019.png&quot; alt=&quot;&quot; width=&quot;464&quot; height=&quot;55&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　②通过response页面重定向：response.sendRedirect(&quot;url&quot;)，实现方式同上&lt;/p&gt;
&lt;h3&gt;　　3、使用String作为返回值&lt;/h3&gt;
&lt;p&gt; 　　a）Controller中的方法形参为model，然后通过形参将数据返回到请求页面上，最后返回字符串可以指定逻辑视图名（路径信息），通过视图解析器解析为物理视图地址；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     @RequestMapping(&quot;/testString.do&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; String testString(Model model) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;其他进行的操作
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过形参model将数据返回到请求页面上   类似于返回ModelAndView中的addObject方法&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;         model.addAttribute(&quot;testString&quot;,&quot;testString&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;然后返回逻辑视图名，经过视图解析器解析为相应的jsp等路径&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &quot;test/helloWorld&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　 b）重定向：Contrller方法返回结果重定向到一个url地址，但是由于重定向之后原来的request中的数据不在，所以如果要传参数可以/item/queryItem.action后边加参数：/test/queryTest?test1Key=test1Value&amp;amp;test2Key=test2Value&lt;/p&gt;
&lt;p&gt; 　　c）转发：Controller中的方法执行后继续执行另一个controller方法，如下信息modify提交后转向到信息显示页面，修改信息的id参数可以带到修改方法中。//结果转发到update.action，request可以带过去：&lt;strong&gt;return&lt;/strong&gt; &quot;forward:update.action&quot;；forward方式相当于“request.getRequestDispatcher().forward(request,response)”，转发后浏览器地址栏还是原来的地址。转发并没有执行新的request和response，而是和转发前的请求共用一个request和response。所以转发前请求的参数在转发后仍然可以读取到。&lt;/p&gt;

&lt;h3&gt;　　1、参数绑定过程&lt;/h3&gt;
&lt;p&gt;　　 a）参数绑定：注解适配器对RequestMapping标记的方法进行适配，将从浏览器中请求的数据（key/value或者表单信息）在方法中的形参会进行参数绑定，所以在springmvc中的参数绑定是通过Controller的方法形参进行绑定的。&lt;/p&gt;
&lt;p&gt;　 　b）参数绑定所支持的默认参数类型，可以直接在Controller方法上面定义下面类型的形参，然后在方法体内直接使用&lt;/p&gt;
&lt;p&gt;　　 &lt;strong&gt;①HttpServletRequest&lt;/strong&gt;（通过request对象获取请求信息）&lt;/p&gt;
&lt;p&gt;　　 &lt;strong&gt;②HttpServletResponse&lt;/strong&gt;（通过response处理响应信息）&lt;/p&gt;
&lt;p&gt;　　 &lt;strong&gt;③HTTPSession&lt;/strong&gt;（通过session对象得到session中存放的对象）&lt;/p&gt;
&lt;p&gt;　 &lt;strong&gt;　④Model&lt;/strong&gt;（通过model向页面传递数据，然后页面通过${test.XXXX}获取item对象的属性值。如同上面Controller中方法返回值为String的情况）&lt;/p&gt;
&lt;h3&gt;　　2、RequestParam注解使用&lt;/h3&gt;
&lt;p&gt;　　 a）在没有使用注解的时候，我们在前端提交参数的key名字应该Controller中方法的形参相同，否则在request域中无法进行匹配。当我们需要将Controller方法中的形参设置为不一样的参数名时候，就需要使用这个注解&lt;/p&gt;
&lt;p&gt;　　 b）注解简介：@RequestParam用于绑定单个请求参数。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　 ①value：参数名字，即入参的请求参数名字，如value=“test_id”表示请求的参数区中的名字为test_id的参数的值将传入；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　 ②required：是否必须传入参数，默认是true，表示请求中一定要有相应的参数，否则将报HTTP Status 400 - Required Integer parameter 'XXXX' is not present&lt;/p&gt;
&lt;p&gt;　　 ③defaultValue：默认值，表示如果请求中没有同名参数时的默认值&lt;/p&gt;
&lt;p&gt;　　 比如：形参名称为id，但是这里使用value=&quot; test_id&quot;限定请求的参数名为test_id，所以页面传递参数的名必须为test_id。&lt;/p&gt;
&lt;p&gt;　　 注意：如果请求参数中没有test_id将抛出异常：HTTP Status 500 - Required Integer parameter 'test_id' is not present&lt;/p&gt;
&lt;p&gt; 　　这里通过required=true限定itest_id参数为必需传递，如果不传递则报400错误，可以使用defaultvalue设置默认值，即使required=true也可以不传item_id参数值&lt;/p&gt;
&lt;p&gt; 　　c）下面使用例子来进行说明上面的几点内容&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;①测试注解&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　测试工程如同上一篇&lt;a href=&quot;https://www.cnblogs.com/fsmly/p/10393507.html&quot; target=&quot;_blank&quot;&gt;SSM整合&lt;/a&gt;中搭建的工程，其中只有一个功能就是查询列表。然后我们在本篇最开始的时候介绍RequestMapping时候添加了查询详细信息的功能，但是其中我们没有接收前端传入的数据，全部都是用的默认值1，下面来将这个方法使用RequestParam进行改写，接收前端传入的参数进行查询。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     @RequestMapping(&quot;/queryInfo.do&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; ModelAndView queryInfo(&lt;span&gt;@RequestParam(value = &quot;id&quot;) Integer testId&lt;/span&gt;) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在没有使用注解的时候，方法形参中的参数名需要和前端请求的key名称一样，使用之后就可以自定义&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         ProductExtend productExtend =&lt;span&gt; productService.queryProductInfo(&lt;span&gt;testId&lt;/span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;         productExtend.setDesc(&quot;这是相机&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         ModelAndView modelAndView = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ModelAndView();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        modelAndView.addObject(productExtend);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         modelAndView.setViewName(&quot;/WEB-INF/items/editItem.jsp&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; modelAndView;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　 然后我们再次进行测试，首先访问http://localhost:8080/TestSSM2/test/queryList.do，然后查看id=2的信息&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201902/1368768-20190222144736990-1747226456.png&quot; alt=&quot;&quot; width=&quot;402&quot; height=&quot;25&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　 得到下面的结果&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201902/1368768-20190222144827163-648339460.png&quot; alt=&quot;&quot; width=&quot;411&quot; height=&quot;97&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　 在对比id=1的时候&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201902/1368768-20190222144851776-942152861.png&quot; alt=&quot;&quot; width=&quot;421&quot; height=&quot;23&quot;/&gt;　　&lt;/p&gt;
&lt;p&gt;　     &lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201902/1368768-20190222144905277-1508077809.png&quot; alt=&quot;&quot; width=&quot;425&quot; height=&quot;99&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　 &lt;strong&gt;②测试required&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 　　在上面的方法中加上&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201902/1368768-20190222145251664-2104244404.png&quot; alt=&quot;&quot; width=&quot;747&quot; height=&quot;24&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　 然后进行测试，输入http://localhost:8080/TestSSM2/test/queryInfo.do，不加参数，则报出下面的错误&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201902/1368768-20190222145422226-956759419.png&quot; alt=&quot;&quot; width=&quot;527&quot; height=&quot;118&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　 &lt;strong&gt;③测试defaultValue&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　当required设置为true的时候，如果没有传入key/value，当在Controller中设置defaultValue的时候也不会报出上面的异常，在Controller方法参数中改成下面这样&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201902/1368768-20190222150109250-1898732767.png&quot; alt=&quot;&quot; width=&quot;967&quot; height=&quot;29&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　然后直接输入http://localhost:8080/TestSSM2/test/queryInfo.do不加id参数，还是能够查询到默认的id=1的数据&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201902/1368768-20190222150228774-491105456.png&quot; alt=&quot;&quot; width=&quot;391&quot; height=&quot;144&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;　　3、普通POJO类型绑定&lt;/h3&gt;
&lt;p&gt; 　　a）&lt;span&gt;将pojo对象中的属性名和传递进来的属性名对应，如果传进来的参数名称和对象中的属性名称一致则将参数值设置在pojo对象中&lt;/span&gt; ，然后在Contrller方法定义： 请求的参数名称和pojo的属性名称一致，会自动将请求参数赋值给pojo的属性。&lt;/p&gt;
&lt;p&gt; 　　b）我们现在在Controller中新添加一个下面的方法,输出从页面上面提交的数据&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201902/1368768-20190222235816167-476827586.png&quot; alt=&quot;&quot; width=&quot;401&quot; height=&quot;97&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　c）在页面表单中点击提交数据&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201902/1368768-20190223000012743-1109459396.png&quot; alt=&quot;&quot; width=&quot;434&quot; height=&quot;135&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　然后后台中输出&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201902/1368768-20190223000042771-1976200277.png&quot; alt=&quot;&quot; width=&quot;458&quot; height=&quot;34&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;　　4、自定义参数绑定&lt;/h3&gt;
&lt;p&gt;　　 a）定义一个Date类型的参数绑定,首先建议里个转换器的java工具类，用来将String转换为java.util.Date类型&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.test.ssm.controller.converter;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.core.convert.converter.Converter;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.text.ParseException;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.text.SimpleDateFormat;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Date;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; StringToDateConverter &lt;span&gt;implements&lt;/span&gt; Converter&amp;lt;String, Date&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Date convert(String s) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             SimpleDateFormat simpleDateFormat = &lt;span&gt;new&lt;/span&gt; SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; simpleDateFormat.parse(s);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ParseException e) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后在springmvc.xml中配置上上面的转换器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;配置mvc:annotation代替基于注解方式的处理器映射器和适配器的配置&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mvc:annotation-driven &lt;/span&gt;&lt;span&gt;conversion-service&lt;/span&gt;&lt;span&gt;=&quot;converterService&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mvc:annotation-driven&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;converterService&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;配置转换器&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;converters&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;cn.test.ssm.controller.converter.StringToDateConverter&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　最后可以修改一下上面的查看信息方法，在后台中打印出所有提交的数据，注意下面的方法中形参createtime的类型已经设置为Date类型，在前端页面中也添加上了createtime的输入&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201902/1368768-20190223003928856-2021504343.png&quot; alt=&quot;&quot; width=&quot;383&quot; height=&quot;26&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     @RequestMapping(&quot;/printInfo.action&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; String printInfo(Product product, Date createtime) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         System.out.println(&quot;输出信息&quot;+&lt;span&gt;product);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;        System.out.println(createtime);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &quot;forward:queryList.do&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　最后在浏览器中进行如下输入测试，输入一个日期类型&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201902/1368768-20190223003544009-1969667311.png&quot; alt=&quot;&quot; width=&quot;563&quot; height=&quot;178&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　最后在后台查看打印的信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201902/1368768-20190223003517541-1728355908.png&quot; alt=&quot;&quot; width=&quot;393&quot; height=&quot;48&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;　　5、自定义包装类型&lt;/h3&gt;
&lt;p&gt;　　 a）当前天传入的参数比较复杂的时候（比如说涵盖不同数据实体类之间关联的查询或者某个实体类的扩展属性信息），这个时候我们可以在扩展类中加上额外的属性然后将其作为我们自定义的包装类的属性，然后将前台页面传入参数的name设置为包装类的&lt;span&gt;属性名.实体类属性（testExtend.name）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　 b）看下面的例子，这是一个模糊查询的简单功能实现&lt;/p&gt;
&lt;p&gt;　　 ①我们首先在实体类Product的扩展类ProductExtend中添加接受模糊查询参数的一个属性&lt;/p&gt;
&lt;p&gt;　　 &lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201902/1368768-20190223141536637-1602806374.png&quot; alt=&quot;&quot; width=&quot;287&quot; height=&quot;48&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　②然后定义一个包装类型，其中将上面的扩展类型设置为一个属性&lt;/p&gt;
&lt;p&gt;　　 &lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201902/1368768-20190223141627755-31581998.png&quot; alt=&quot;&quot; width=&quot;259&quot; height=&quot;98&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　③然后就在Controller方法中将自定义的包装类型设置为方法形参，用以进行参数绑定，并且调用service的方法进行查询&lt;/p&gt;
&lt;p&gt;　　 &lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201902/1368768-20190223141720498-2104491019.png&quot; alt=&quot;&quot; width=&quot;491&quot; height=&quot;64&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　④在前台中查看查询　&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201902/1368768-20190223142143430-1604798504.png&quot; alt=&quot;&quot; width=&quot;706&quot; height=&quot;176&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　 ⑤在debug模式中查看是否接收到前端传入的参数，发现可以接收到页面传入的参数&lt;/p&gt;
&lt;p&gt;　　 &lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201902/1368768-20190223142328937-1981976114.png&quot; alt=&quot;&quot; width=&quot;232&quot; height=&quot;178&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　并且在调用service方法之后的查询结果也为&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201902/1368768-20190223142514169-1353909357.png&quot; alt=&quot;&quot; width=&quot;706&quot; height=&quot;70&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　最终页面显示结果&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201902/1368768-20190223142609588-777217492.png&quot; alt=&quot;&quot; width=&quot;643&quot; height=&quot;98&quot;/&gt;&lt;/p&gt;
&lt;h3&gt; &lt;/h3&gt;
</description>
<pubDate>Sat, 23 Feb 2019 06:38:00 +0000</pubDate>
<dc:creator>风沙迷了眼</dc:creator>
<og:description>在上一篇Spring+SpringMVC+Mybatis整合中说到了SSM的整合，并且在其中添加了一个简单的查询功能，目的只是将整个整合的流程进行一个梳理，下面在上一篇中工程的基础上再说一些关于Spr</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fsmly/p/10413163.html</dc:identifier>
</item>
<item>
<title>cocos creator主程入门教程（七）—— MVC架构 - 五邑隐侠</title>
<link>http://www.cnblogs.com/niudanshui/p/10422307.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/niudanshui/p/10422307.html</guid>
<description>&lt;p&gt;&lt;span&gt;五邑隐侠，本名关健昌，10年游戏生涯，现隐居五邑。本系列文章以TypeScript为介绍语言。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;这一篇将介绍在游戏客户端常用的架构MVC架构。一个游戏的MVC如下划分：&lt;/p&gt;
&lt;p&gt;M：1）单例全局的数据中心World，所有游戏模块的数据在World中有入口，2）各个模块自己的数据结构。&lt;/p&gt;
&lt;p&gt;V：1）通过creator预制体制作的UI界面、场景，2）各个界面显示逻辑的ViewCtrl&lt;/p&gt;
&lt;p&gt;C：1）全局的MainCtrl，2）各个模块的业务逻辑类ModuleCtrl&lt;/p&gt;

&lt;p&gt;先介绍M部分。由于一个模块的数据，在其他模块也有访问的需求，例如好友模块，在聊天的时候也需要访问，在排行榜里需要访问。数据应该有一个单例全局的数据中心类World，所有游戏模块的数据类在World中有入口。这些数据可以在玩家登录后从服务器获取并设置。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
export class World {
    private static instance: World = null;

    private _test: TestData = null;

    /**
     * 单例模式
     */
    private constructor() {

    }

    /**
     * 获取实例
     */
    public static get inst(): World {
        if (!World.instance) {
            World.instance = new World();
        }

        return World.instance;
    }

    // FOR TEST
    public set test(val: TestData) {
        this._test = val;
    }

    public get test(): TestData {
        return this._test;
    }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这样模块间可以独立设计自己的数据结构，通过发送消息请求对应模块的ModuleCtrl更改，通过World读取。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/137210/201902/137210-20190223122745623-1581315573.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
export class TestData {
    private _text: string = null;

    public constructor() {

    }

    public set text(val: string) {
        this._text = val;
    }

    public get text(): string {
        return this._text;
    }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上一章介绍过消息分发。数据的更新时可以派发消息，界面可以监听消息做刷新。&lt;/p&gt;

&lt;p&gt;下面介绍界面和脚本代码的关联。前面篇章中介绍过，cocos creator是基于组件模式。我将每个ui界面都做成一个预制体，每个预制体都可以添加一个脚本组件，用于控制这个界面的显示逻辑。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/137210/201902/137210-20190223120704868-839057499.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/137210/201902/137210-20190223120719980-318682872.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在弹窗管理里提到我设计了一个继承cc.Component的类叫ViewCtrl，所有界面的显示逻辑类都继承ViewCtrl，并添加到对应的界面预制体。前面提到数据更新时会派发消息，ViewCtrl监听数据更新消息，刷新关联的界面。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
const {ccclass, property} = cc._decorator;

@ccclass
export default class TestViewCtrl extends ViewCtrl {
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;ViewCtrl只处理界面的显示逻辑，不处理数据业务逻辑，模块的数据业务逻辑由该模块的ModuleCtrl处理。ViewCtrl响应用户操作，派发消息，ModuleCtrl监听消息处理。大部分模块的ModuleCtrl主要做网络通信，和对本模块缓存数据的修改。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;45&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
export class TestCtrl {

    public constructor() {

    }

    public init(): void {}

    public start(): void {
        NotifyCenter.addListener(MSG_TEST_HTTP, (src: any, data: any) =&amp;gt; {
            this.testHttp();
        }, this);
    }

    public testHttp(): void {
        let data = {
            mod: 1, // 模块
            cmd: 1, // 命令
        }

        let params: HttpReq = {
            path: &quot;&quot;,
            method: HTTP_METHOD_GET
        }

        MainCtrl.inst.http.sendData(data, params, (data: NetData) =&amp;gt; {
            World.inst.test = new TestData();
            World.inst.test.text = &quot;123&quot;;
        }, (code: number, reason: string) =&amp;gt; {});
    }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;前面提到，C层还有一个全局单例的MainCtrl。该类主要负责模块注册、提供全局的操作接口（例如界面/场景的显隐）、网络通信处理。&lt;/p&gt;

&lt;p&gt;MVC架构先说到这里，下一篇我们将介绍代码组织。&lt;/p&gt;
</description>
<pubDate>Sat, 23 Feb 2019 06:37:00 +0000</pubDate>
<dc:creator>五邑隐侠</dc:creator>
<og:description>五邑隐侠，本名关健昌，10年游戏生涯，现隐居五邑。本系列文章以TypeScript为介绍语言。 这一篇将介绍在游戏客户端常用的架构MVC架构。一个游戏的MVC如下划分： M：1）单例全局的数据中心Wo</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/niudanshui/p/10422307.html</dc:identifier>
</item>
<item>
<title>k8s健康检查（七）--技术流ken - 技术流ken</title>
<link>http://www.cnblogs.com/kenken2018/p/10337471.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kenken2018/p/10337471.html</guid>
<description>
&lt;h2&gt;默认的健康检查&lt;/h2&gt;

&lt;p&gt;强大的自愈能力是 Kubernetes 这类容器编排引擎的一个重要特性。自愈的默认实现方式是自动重启发生故障的容器。除此之外，用户还可以利用 Liveness 和 Readiness 探测机制设置更精细的健康检查，进而实现如下需求：&lt;/p&gt;
&lt;ol class=&quot;list-paddingleft-2&quot; readability=&quot;-1&quot;&gt;&lt;li&gt;
&lt;p&gt;零停机部署。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;避免部署无效的镜像。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;更加安全的滚动升级。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;span&gt;每个容器启动时都会执行一个进程，此进程由 Dockerfile 的 CMD 或 ENTRYPOINT 指定。如果进程退出时返回码非零，则认为容器发生故障，Kubernetes 就会根据 restartPolicy 重启容器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一步： 下面我们模拟一个容器发生故障的场景，Pod 配置文件如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201901/1499615-20190130105135813-1015460628.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Pod 的 restartPolicy 设置为 OnFailure，默认为 Always。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;sleep 10; exit 1 模拟容器启动 10 秒后发生故障。、&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;第二步：执行 kubectl apply 创建 Pod，命名为 healthcheck。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken ~]# kubectl apply -&lt;span&gt;f healthcheck.yml
pod&lt;/span&gt;/healthcheck created
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第三步：过几分钟查看 Pod 的状态：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@ken ~]# kubectl &lt;span&gt;get&lt;/span&gt; pod -&lt;span&gt;o wide
NAME                     READY   STATUS             RESTARTS   AGE   IP            NODE    NOMINATED NODE   READINESS GATES
healthcheck              &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;     CrashLoopBackOff   &lt;span&gt;2&lt;/span&gt;          85s   &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;1.47&lt;/span&gt;   host1   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可看到容器当前已经重启了 2次。&lt;/p&gt;

&lt;p&gt;在上面的例子中，容器进程返回值非零，Kubernetes 则认为容器发生故障，需要重启。但有不少情况是发生了故障，但进程并不会退出。比如访问 &lt;span&gt;Web&lt;/span&gt; 服务器时显示 &lt;span&gt;500&lt;/span&gt; 内部错误，可能是系统超载，也可能是资源死锁，此时 &lt;span&gt;httpd&lt;/span&gt; 进程并没有异常退出，在这种情况下重启容器可能是最直接最有效的解决方案，那我们如何利用 &lt;span&gt;Health Check&lt;/span&gt; 机制来处理这类场景呢？&lt;/p&gt;

&lt;h2&gt;Liveness探测&lt;/h2&gt;

&lt;p&gt;Liveness 探测让用户可以自定义判断容器是否健康的条件。如果探测失败，Kubernetes 就会重启容器。&lt;/p&gt;

&lt;p&gt;第一步：创建如下 Pod：&lt;/p&gt;
&lt;p&gt;：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201901/1499615-20190130110037519-1732473261.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;启动进程首先创建文件 /tmp/healthy，&lt;span&gt;30&lt;/span&gt; 秒后删除，在我们的设定中，如果 &lt;span&gt;/tmp/healthy&lt;/span&gt; 文件存在，则认为容器处于正常状态，反正则发生故障。&lt;/p&gt;
&lt;p&gt;livenessProbe 部分定义如何执行 &lt;span&gt;Liveness&lt;/span&gt; 探测：&lt;/p&gt;

&lt;p&gt;探测的方法是：通过 cat 命令检查 &lt;span&gt;/tmp/healthy&lt;/span&gt; 文件是否存在。如果命令执行成功，返回值为零，&lt;span&gt;Kubernetes&lt;/span&gt; 则认为本次 &lt;span&gt;Liveness&lt;/span&gt; 探测成功；如果命令返回值非零，本次 &lt;span&gt;Liveness&lt;/span&gt; 探测失败。&lt;/p&gt;
&lt;p&gt;initialDelaySeconds: 10 指定容器启动 &lt;span&gt;10&lt;/span&gt; 之后开始执行 &lt;span&gt;Liveness&lt;/span&gt; 探测，我们一般会根据应用启动的准备时间来设置。比如某个应用正常启动要花 &lt;span&gt;30&lt;/span&gt; 秒，那么 &lt;span&gt;initialDelaySeconds&lt;/span&gt; 的值就应该大于 &lt;span&gt;30&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;periodSeconds: 5 指定每 &lt;span&gt;5&lt;/span&gt; 秒执行一次 &lt;span&gt;Liveness&lt;/span&gt; 探测。&lt;span&gt;Kubernetes&lt;/span&gt; 如果连续执行 &lt;span&gt;3&lt;/span&gt; 次 &lt;span&gt;Liveness&lt;/span&gt; 探测均失败，则会杀掉并重启容器。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;第二步：下面创建 Pod liveness：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken ~]# kubectl apply -&lt;span&gt;f healthcheck.yml
pod&lt;/span&gt;/liveness created
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;从配置文件可知，最开始的 30 秒，&lt;span&gt;/tmp/healthy&lt;/span&gt; 存在，&lt;span&gt;cat&lt;/span&gt; 命令返回 &lt;span&gt;0&lt;/span&gt;，&lt;span&gt;Liveness&lt;/span&gt; 探测成功&lt;/p&gt;

&lt;p&gt;第三步：这段时间 &lt;span&gt;kubectl describe pod liveness&lt;/span&gt; 的 &lt;span&gt;Events&lt;/span&gt;部分会显示正常的日志。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
[root@ken ~&lt;span&gt;]# kubectl describe pod liveness
...
Events:
  Type    Reason     Age   From               Message
  &lt;/span&gt;----    ------     ----  ----               -------&lt;span&gt;
  Normal  Scheduled  30s   &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;-scheduler  Successfully assigned &lt;span&gt;default&lt;/span&gt;/&lt;span&gt;liveness to host1
  Normal  Pulling    29s   kubelet, host1     pulling image &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;busybox&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  Normal  Pulled     27s   kubelet, host1     Successfully pulled image &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;busybox&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  Normal  Created    27s   kubelet, host1     Created container
  Normal  Started    27s   kubelet, host1     Started container&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第四步：35秒后再次查看日志&lt;/p&gt;
&lt;p&gt;&lt;span&gt;35 秒之后，日志会显示 /tmp/healthy 已经不存在，Liveness 探测失败。再过几十秒，几次探测都失败后，容器会被重启。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
[root@ken ~&lt;span&gt;]# kubectl describe pod liveness
...
Events:
  Type     Reason     Age                From               Message
  &lt;/span&gt;----     ------     ----               ----               -------&lt;span&gt;
  Normal   Scheduled  60s                &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;-scheduler  Successfully assigned &lt;span&gt;default&lt;/span&gt;/&lt;span&gt;liveness to host1
  Normal   Pulling    59s                kubelet, host1     pulling image &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;busybox&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  Normal   Pulled     57s                kubelet, host1     Successfully pulled image &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;busybox&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  Normal   Created    57s                kubelet, host1     Created container
  Normal   Started    57s                kubelet, host1     Started container
  Warning  Unhealthy  13s (x3 over 23s)  kubelet, host1     Liveness probe failed: cat: can&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;t open &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;/tmp/healthy&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: No such file or directory&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;第五步：查看pod&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以发现容器开始被重启&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201901/1499615-20190130111239452-776656797.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;除了 Liveness 探测，&lt;span&gt;Kubernetes Health Check&lt;/span&gt; 机制还包括 &lt;span&gt;Readiness&lt;/span&gt; 探测。&lt;/p&gt;

&lt;p&gt;用户通过 Liveness 探测可以告诉 &lt;span&gt;Kubernetes&lt;/span&gt; 什么时候通过重启容器实现自愈；&lt;span&gt;Readiness&lt;/span&gt; 探测则是告诉 &lt;span&gt;Kubernetes&lt;/span&gt; 什么时候可以将容器加入到 &lt;span&gt;Service&lt;/span&gt; 负载均衡池中，对外提供服务。&lt;/p&gt;

&lt;p&gt;第一步：Readiness 探测的配置语法与 &lt;span&gt;Liveness&lt;/span&gt; 探测完全一样&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201901/1499615-20190130111422742-1678782536.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个配置文件只是将前面例子中的 liveness 替换为了 &lt;span&gt;readiness&lt;/span&gt;，我们看看有什么不同的效果。&lt;/p&gt;

&lt;p&gt;第二步：部署&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@ken ~]# kubectl apply -&lt;span&gt;f readness.yml
pod&lt;/span&gt;/&lt;span&gt;readiness created

[root@ken &lt;/span&gt;~]# kubectl &lt;span&gt;get&lt;/span&gt;&lt;span&gt; pod readiness
NAME        READY   STATUS    RESTARTS   AGE
readiness   &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;     Running   &lt;span&gt;0&lt;/span&gt;&lt;span&gt;          17s

[root@ken &lt;/span&gt;~]# kubectl &lt;span&gt;get&lt;/span&gt;&lt;span&gt; pod readiness
NAME        READY   STATUS    RESTARTS   AGE
readiness   &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;     Running   &lt;span&gt;0&lt;/span&gt;&lt;span&gt;          18s


[root@ken &lt;/span&gt;~]# kubectl &lt;span&gt;get&lt;/span&gt;&lt;span&gt; pod readiness
NAME        READY   STATUS    RESTARTS   AGE
readiness   &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;     Running   &lt;span&gt;0&lt;/span&gt;          84s
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;Pod readiness 的 READY 状态经历了如下变化：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;刚被创建时，READY 状态为不可用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;15 秒后（initialDelaySeconds + periodSeconds），第一次进行 Readiness 探测并成功返回，设置 READY 为可用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;30 秒后，/tmp/healthy 被删除，连续 3 次 Readiness 探测均失败后，READY 被设置为不可用。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;第三步：通过 kubectl describe pod readiness 也可以看到 Readiness 探测失败的日志。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
[root@ken ~&lt;span&gt;]# kubectl describe pod readiness
...
Events:
  Type     Reason     Age                From               Message
  &lt;/span&gt;----     ------     ----               ----               -------&lt;span&gt;
  Normal   Scheduled  104s               &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;-scheduler  Successfully assigned &lt;span&gt;default&lt;/span&gt;/&lt;span&gt;readiness to host1
  Normal   Pulling    103s               kubelet, host1     pulling image &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;busybox&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  Normal   Pulled     101s               kubelet, host1     Successfully pulled image &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;busybox&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  Normal   Created    101s               kubelet, host1     Created container
  Normal   Started    100s               kubelet, host1     Started container
  Warning  Unhealthy  1s (x14 over 66s)  kubelet, host1     Readiness probe failed: cat: can&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;t open &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;/tmp/healthy&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: No such file or directory&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;下面对 Liveness 探测和 &lt;span&gt;Readiness&lt;/span&gt; 探测做个比较：&lt;/p&gt;

&lt;p&gt;Liveness 探测和 &lt;span&gt;Readiness&lt;/span&gt; 探测是两种 &lt;span&gt;Health Check&lt;/span&gt; 机制，如果不特意配置，&lt;span&gt;Kubernetes&lt;/span&gt; 将对两种探测采取相同的默认行为，即通过判断容器启动进程的返回值是否为零来判断探测是否成功。&lt;/p&gt;

&lt;p&gt;两种探测的配置方法完全一样，支持的配置参数也一样。不同之处在于探测失败后的行为：Liveness 探测是重启容器；&lt;span&gt;Readiness&lt;/span&gt; 探测则是将容器设置为不可用，不接收 &lt;span&gt;Service&lt;/span&gt; 转发的请求。&lt;/p&gt;

&lt;p&gt;Liveness 探测和 &lt;span&gt;Readiness&lt;/span&gt; 探测是独立执行的，二者之间没有依赖，所以可以单独使用，也可以同时使用。用 &lt;span&gt;Liveness&lt;/span&gt; 探测判断容器是否需要重启以实现自愈；用 &lt;span&gt;Readiness&lt;/span&gt; 探测判断容器是否已经准备好对外提供服务。&lt;/p&gt;

&lt;h2&gt;健康检测在scale up中的应用&lt;/h2&gt;

&lt;p&gt;对于多副本应用，当执行 Scale Up 操作时，新副本会作为 &lt;span&gt;backend&lt;/span&gt; 被添加到 &lt;span&gt;Service&lt;/span&gt; 的负责均衡中，与已有副本一起处理客户的请求。考虑到应用启动通常都需要一个准备阶段，比如加载缓存数据，连接数据库等，从容器启动到正真能够提供服务是需要一段时间的。我们可以通过 &lt;span&gt;Readiness&lt;/span&gt; 探测判断容器是否就绪，避免将请求发送到还没有 &lt;span&gt;ready&lt;/span&gt; 的 &lt;span&gt;backend&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;第一步：下面是示例应用的配置文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201901/1499615-20190130112933920-565633962.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;重点关注 readinessProbe 部分。这里我们使用了不同于 &lt;span&gt;exec&lt;/span&gt; 的另一种探测方法 &lt;span&gt;-- httpGet&lt;/span&gt;。&lt;span&gt;Kubernetes&lt;/span&gt; 对于该方法探测成功的判断条件是 &lt;span&gt;http&lt;/span&gt; 请求的返回代码在 &lt;span&gt;200-400&lt;/span&gt; 之间。&lt;/p&gt;

&lt;p&gt;schema 指定协议，支持 &lt;span&gt;HTTP&lt;/span&gt;（默认值）和 &lt;span&gt;HTTPS&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;path 指定访问路径。&lt;/p&gt;
&lt;p&gt;port 指定端口。&lt;/p&gt;

&lt;p&gt;上面配置的作用是：&lt;/p&gt;

&lt;p&gt;容器启动 10 秒之后开始探测。&lt;/p&gt;
&lt;p&gt;如果 http://[container_ip]:8080/healthy 返回代码不是 &lt;span&gt;200-400&lt;/span&gt;，表示容器没有就绪，不接收 &lt;span&gt;Service web-svc&lt;/span&gt; 的请求。&lt;/p&gt;
&lt;p&gt;每隔 5 秒再探测一次。&lt;/p&gt;
&lt;p&gt;直到返回代码为 200-400，表明容器已经就绪，然后将其加入到 &lt;span&gt;web-svc&lt;/span&gt; 的负责均衡中，开始处理客户请求。&lt;/p&gt;
&lt;p&gt;探测会继续以 5 秒的间隔执行，如果连续发生 &lt;span&gt;3&lt;/span&gt; 次失败，容器又会从负载均衡中移除，直到下次探测成功重新加入。&lt;/p&gt;

&lt;h2&gt;健康检测在滚动更新中的应用&lt;/h2&gt;

&lt;p&gt;现有一个正常运行的多副本应用，接下来对应用进行更新（比如使用更高版本的 image），&lt;span&gt;Kubernetes&lt;/span&gt; 会启动新副本，然后发生了如下事件：&lt;/p&gt;

&lt;p&gt;正常情况下新副本需要 10 秒钟完成准备工作，在此之前无法响应业务请求。&lt;/p&gt;
&lt;p&gt;但由于人为配置错误，副本始终无法完成准备工作（比如无法连接后端数据库）。&lt;/p&gt;
&lt;p&gt;先别继续往下看，现在请花一分钟思考这个问题：如果没有配置 Health Check，会出现怎样的情况？&lt;/p&gt;

&lt;p&gt;因为新副本本身没有异常退出，默认的 Health Check 机制会认为容器已经就绪，进而会逐步用新副本替换现有副本，其结果就是：当所有旧副本都被替换后，整个应用将无法处理请求，无法对外提供服务。如果这是发生在重要的生产系统上，后果会非常严重。&lt;/p&gt;
&lt;p&gt;如果正确配置了 Health Check，新副本只有通过了 &lt;span&gt;Readiness&lt;/span&gt; 探测，才会被添加到 &lt;span&gt;Service&lt;/span&gt;；如果没有通过探测，现有副本不会被全部替换，业务仍然正常进行。&lt;/p&gt;

&lt;p&gt;第一步：用如下配置文件 app.v1.yml 模拟一个 &lt;span&gt;10&lt;/span&gt; 副本的应用：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201901/1499615-20190130113153454-780527282.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;10 秒后副本能够通过 Readiness 探测。&lt;/p&gt;

&lt;p&gt;第二步：执行部署操作&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@ken ~]# kubectl apply -&lt;span&gt;f app.v1.yml
deployment.apps&lt;/span&gt;/&lt;span&gt;app created
[root@ken &lt;/span&gt;~]# kubectl &lt;span&gt;get&lt;/span&gt;&lt;span&gt; deployment app
NAME   READY   UP&lt;/span&gt;-TO-&lt;span&gt;DATE   AVAILABLE   AGE
app    &lt;/span&gt;&lt;span&gt;10&lt;/span&gt;/&lt;span&gt;10&lt;/span&gt;   &lt;span&gt;10&lt;/span&gt;           &lt;span&gt;10&lt;/span&gt;&lt;span&gt;          71s
[root@ken &lt;/span&gt;~]# kubectl &lt;span&gt;get&lt;/span&gt;&lt;span&gt; pod
NAME                   READY   STATUS    RESTARTS   AGE
app&lt;/span&gt;-56878b4676-45bmq   &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;     Running   &lt;span&gt;0&lt;/span&gt;&lt;span&gt;          80s
app&lt;/span&gt;-56878b4676-5w5ck   &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;     Running   &lt;span&gt;0&lt;/span&gt;&lt;span&gt;          80s
app&lt;/span&gt;-56878b4676-6mnvz   &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;     Running   &lt;span&gt;0&lt;/span&gt;&lt;span&gt;          80s
app&lt;/span&gt;-56878b4676-fb8fk   &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;     Running   &lt;span&gt;0&lt;/span&gt;&lt;span&gt;          80s
app&lt;/span&gt;-56878b4676-gvdbr   &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;     Running   &lt;span&gt;0&lt;/span&gt;&lt;span&gt;          80s
app&lt;/span&gt;-56878b4676-lppmt   &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;     Running   &lt;span&gt;0&lt;/span&gt;&lt;span&gt;          80s
app&lt;/span&gt;-56878b4676-lwr6p   &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;     Running   &lt;span&gt;0&lt;/span&gt;&lt;span&gt;          80s
app&lt;/span&gt;-56878b4676-n8l7w   &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;     Running   &lt;span&gt;0&lt;/span&gt;&lt;span&gt;          80s
app&lt;/span&gt;-56878b4676-rn68g   &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;     Running   &lt;span&gt;0&lt;/span&gt;&lt;span&gt;          80s
app&lt;/span&gt;-56878b4676-z8ltd   &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;     Running   &lt;span&gt;0&lt;/span&gt;          80s
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;第三步：接下来滚动更新应用，配置文件&lt;/span&gt; app.v2.yml &lt;span&gt;如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201901/1499615-20190130113950018-2138348844.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;很显然，由于新副本中不存在 /tmp/healthy，是无法通过 &lt;span&gt;Readiness&lt;/span&gt; 探测的。验证如下：&lt;/p&gt;

&lt;p&gt;第二步：查看探测结果、&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@ken ~]# kubectl apply -f app.v2.yml --&lt;span&gt;record
deployment.apps&lt;/span&gt;/&lt;span&gt;app configured
[root@ken &lt;/span&gt;~]# kubectl &lt;span&gt;get&lt;/span&gt;&lt;span&gt; deployment app
NAME   READY   UP&lt;/span&gt;-TO-&lt;span&gt;DATE   AVAILABLE   AGE
app    &lt;/span&gt;&lt;span&gt;8&lt;/span&gt;/&lt;span&gt;10&lt;/span&gt;    &lt;span&gt;5&lt;/span&gt;            &lt;span&gt;8&lt;/span&gt;&lt;span&gt;           4m24s
[root@ken &lt;/span&gt;~]# kubectl &lt;span&gt;get&lt;/span&gt;&lt;span&gt; deployment app
NAME   READY   UP&lt;/span&gt;-TO-&lt;span&gt;DATE   AVAILABLE   AGE
app    &lt;/span&gt;&lt;span&gt;8&lt;/span&gt;/&lt;span&gt;10&lt;/span&gt;    &lt;span&gt;5&lt;/span&gt;            &lt;span&gt;8&lt;/span&gt;&lt;span&gt;           4m34s
[root@ken &lt;/span&gt;~]# kubectl &lt;span&gt;get&lt;/span&gt;&lt;span&gt; deployment app
NAME   READY   UP&lt;/span&gt;-TO-&lt;span&gt;DATE   AVAILABLE   AGE
app    &lt;/span&gt;&lt;span&gt;8&lt;/span&gt;/&lt;span&gt;10&lt;/span&gt;    &lt;span&gt;5&lt;/span&gt;            &lt;span&gt;8&lt;/span&gt;&lt;span&gt;           4m37s
[root@ken &lt;/span&gt;~]# kubectl &lt;span&gt;get&lt;/span&gt;&lt;span&gt; pod
NAME                   READY   STATUS    RESTARTS   AGE
app&lt;/span&gt;-56878b4676-45bmq   &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;     Running   &lt;span&gt;0&lt;/span&gt;&lt;span&gt;          4m45s
app&lt;/span&gt;-56878b4676-5w5ck   &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;     Running   &lt;span&gt;0&lt;/span&gt;&lt;span&gt;          4m45s
app&lt;/span&gt;-56878b4676-fb8fk   &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;     Running   &lt;span&gt;0&lt;/span&gt;&lt;span&gt;          4m45s
app&lt;/span&gt;-56878b4676-gvdbr   &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;     Running   &lt;span&gt;0&lt;/span&gt;&lt;span&gt;          4m45s
app&lt;/span&gt;-56878b4676-lppmt   &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;     Running   &lt;span&gt;0&lt;/span&gt;&lt;span&gt;          4m45s
app&lt;/span&gt;-56878b4676-lwr6p   &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;     Running   &lt;span&gt;0&lt;/span&gt;&lt;span&gt;          4m45s
app&lt;/span&gt;-56878b4676-n8l7w   &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;     Running   &lt;span&gt;0&lt;/span&gt;&lt;span&gt;          4m45s
app&lt;/span&gt;-56878b4676-rn68g   &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;     Running   &lt;span&gt;0&lt;/span&gt;&lt;span&gt;          4m45s
app&lt;/span&gt;-84fc656775-6s88l   &lt;span&gt;0&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;     Running   &lt;span&gt;0&lt;/span&gt;&lt;span&gt;          42s
app&lt;/span&gt;-84fc656775-drg26   &lt;span&gt;0&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;     Running   &lt;span&gt;0&lt;/span&gt;&lt;span&gt;          42s
app&lt;/span&gt;-84fc656775-hjpsd   &lt;span&gt;0&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;     Running   &lt;span&gt;0&lt;/span&gt;&lt;span&gt;          42s
app&lt;/span&gt;-84fc656775-npn2t   &lt;span&gt;0&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;     Running   &lt;span&gt;0&lt;/span&gt;&lt;span&gt;          42s
app&lt;/span&gt;-84fc656775-slknn   &lt;span&gt;0&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;     Running   &lt;span&gt;0&lt;/span&gt;          42s
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;先关注 kubectl get pod 输出：&lt;/p&gt;

&lt;p&gt;从 Pod 的 &lt;span&gt;AGE&lt;/span&gt; 栏可判断，最后 &lt;span&gt;5&lt;/span&gt; 个 &lt;span&gt;Pod&lt;/span&gt; 是新副本，目前处于 &lt;span&gt;NOT READY&lt;/span&gt; 状态。&lt;/p&gt;
&lt;p&gt;旧副本从最初 10 个减少到 &lt;span&gt;8&lt;/span&gt; 个。&lt;/p&gt;
&lt;p&gt;再来看 kubectl get deployment app 的输出：&lt;/p&gt;
&lt;p&gt;DESIRED 10 表示期望的状态是 &lt;span&gt;10&lt;/span&gt; 个 &lt;span&gt;READY&lt;/span&gt; 的副本。&lt;/p&gt;
&lt;p&gt;CURRENT 13 表示当前副本的总数：即 &lt;span&gt;8&lt;/span&gt; 个旧副本 &lt;span&gt;+ 5&lt;/span&gt; 个新副本。&lt;/p&gt;
&lt;p&gt;UP-TO-DATE 5 表示当前已经完成更新的副本数：即 &lt;span&gt;5&lt;/span&gt; 个新副本。&lt;/p&gt;
&lt;p&gt;AVAILABLE 8 表示当前处于 &lt;span&gt;READY&lt;/span&gt; 状态的副本数：即 &lt;span&gt;8&lt;/span&gt;个旧副本。&lt;/p&gt;
&lt;p&gt;在我们的设定中，新副本始终都无法通过 Readiness 探测，所以这个状态会一直保持下去。&lt;/p&gt;

&lt;p&gt;上面我们模拟了一个滚动更新失败的场景。不过幸运的是：Health Check 帮我们屏蔽了有缺陷的副本，同时保留了大部分旧副本，业务没有因更新失败受到影响。&lt;/p&gt;
&lt;p&gt;接下来我们要回答：为什么新创建的副本数是 5 个，同时只销毁了 &lt;span&gt;2&lt;/span&gt; 个旧副本？&lt;/p&gt;
&lt;p&gt;原因是：滚动更新通过参数 maxSurge 和 &lt;span&gt;maxUnavailable&lt;/span&gt; 来控制副本替换的数量。&lt;/p&gt;

&lt;p&gt;maxSurge&lt;/p&gt;
&lt;p&gt;此参数控制滚动更新过程中副本总数的超过 DESIRED 的上限。&lt;span&gt;maxSurge&lt;/span&gt; 可以是具体的整数（比如 &lt;span&gt;3&lt;/span&gt;），也可以是百分百，向上取整。&lt;span&gt;maxSurge&lt;/span&gt; 默认值为 &lt;span&gt;25%&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;在上面的例子中，DESIRED 为 &lt;span&gt;10&lt;/span&gt;，那么副本总数的最大值为：&lt;/p&gt;
&lt;p&gt;roundUp(10 + 10 * 25%) = 13&lt;/p&gt;
&lt;p&gt;所以我们看到 CURRENT 就是 &lt;span&gt;13&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;maxUnavailable&lt;/p&gt;
&lt;p&gt;此参数控制滚动更新过程中，不可用的副本相占 DESIRED 的最大比例。 &lt;span&gt;maxUnavailable&lt;/span&gt; 可以是具体的整数（比如 &lt;span&gt;3&lt;/span&gt;），也可以是百分百，向下取整。&lt;span&gt;maxUnavailable&lt;/span&gt; 默认值为 &lt;span&gt;25%&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;在上面的例子中，DESIRED 为 &lt;span&gt;10&lt;/span&gt;，那么可用的副本数至少要为：&lt;/p&gt;
&lt;p&gt;10 - roundDown(10 * 25%) = 8&lt;/p&gt;
&lt;p&gt;所以我们看到 AVAILABLE 就是 &lt;span&gt;8&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;maxSurge 值越大，初始创建的新副本数量就越多；&lt;span&gt;maxUnavailable&lt;/span&gt; 值越大，初始销毁的旧副本数量就越多。&lt;/p&gt;
&lt;p&gt;理想情况下，我们这个案例滚动更新的过程应该是这样的：&lt;/p&gt;
&lt;p&gt;首先创建 3 个新副本使副本总数达到 &lt;span&gt;13&lt;/span&gt; 个。&lt;/p&gt;
&lt;p&gt;然后销毁 2 个旧副本使可用的副本数降到 &lt;span&gt;8&lt;/span&gt; 个。&lt;/p&gt;
&lt;p&gt;当这 2 个旧副本成功销毁后，可再创建 &lt;span&gt;2&lt;/span&gt; 个新副本，使副本总数保持为 &lt;span&gt;13&lt;/span&gt; 个。&lt;/p&gt;
&lt;p&gt;当新副本通过 Readiness 探测后，会使可用副本数增加，超过 &lt;span&gt;8&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;进而可以继续销毁更多的旧副本，使可用副本数回到 8。&lt;/p&gt;
&lt;p&gt;旧副本的销毁使副本总数低于 13，这样就允许创建更多的新副本。&lt;/p&gt;
&lt;p&gt;这个过程会持续进行，最终所有的旧副本都会被新副本替换，滚动更新完成。&lt;/p&gt;

&lt;h2&gt;更新失败回退&lt;/h2&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@ken ~&lt;span&gt;]# kubectl rollout history deployment app
deployment.extensions&lt;/span&gt;/&lt;span&gt;app 
REVISION  CHANGE&lt;/span&gt;-&lt;span&gt;CAUSE
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;         &amp;lt;none&amp;gt;
&lt;span&gt;2&lt;/span&gt;         kubectl apply --filename=app.v2.yml --record=&lt;span&gt;tr

[root@ken &lt;/span&gt;~]# kubectl rollout undo deployment app --to-revision=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
deployment.extensions&lt;/span&gt;/&lt;span&gt;app rolled back
[root@ken &lt;/span&gt;~]# kubectl &lt;span&gt;get&lt;/span&gt;&lt;span&gt; deployment app
NAME   READY   UP&lt;/span&gt;-TO-&lt;span&gt;DATE   AVAILABLE   AGE
app    &lt;/span&gt;&lt;span&gt;10&lt;/span&gt;/&lt;span&gt;10&lt;/span&gt;   &lt;span&gt;10&lt;/span&gt;           &lt;span&gt;10&lt;/span&gt;          10m
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果要定制 maxSurge 和 &lt;span&gt;maxUnavailable&lt;/span&gt;，可以如下配置：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201901/1499615-20190130143311743-1489967301.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 23 Feb 2019 06:07:00 +0000</pubDate>
<dc:creator>技术流ken</dc:creator>
<og:description>默认的健康检查 强大的自愈能力是 Kubernetes 这类容器编排引擎的一个重要特性。自愈的默认实现方式是自动重启发生故障的容器。除此之外，用户还可以利用 Liveness 和 Readiness</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kenken2018/p/10337471.html</dc:identifier>
</item>
<item>
<title>Java数组协变与范型不变性 - 左之了</title>
<link>http://www.cnblogs.com/tjxing/p/10419993.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tjxing/p/10419993.html</guid>
<description>&lt;p&gt;变性是OOP语言不变的大坑，Java的数组协变就是其中的一口老坑。因为最近踩到了，便做一个记录。顺便也提一下范型的变性。&lt;/p&gt;
&lt;p&gt;解释数组协变之前，先明确三个相关的概念，协变、不变和逆变。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、协变、不变、逆变&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设，我为一家餐馆写了这样一段代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt; Soup&amp;lt;T&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; add(T t) {}
}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Vegetable { }

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; Carrot &lt;span&gt;extends&lt;/span&gt; Vegetable { }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;有一个范型类Soup&amp;lt;T&amp;gt;，表示用食材T做的汤，它的方法add(T t)表示向汤中添加食材T。类Vegetable表示蔬菜，类Carrot表示胡萝卜。当然，Carrot是Vegetable的子类。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;那么问题来了，Soup&amp;lt;Vegetable&amp;gt;和Soup&amp;lt;Carrot&amp;gt;之间是什么关系呢？&lt;/p&gt;
&lt;p&gt;第一反应，Soup&amp;lt;Carrot&amp;gt;应该是Soup&amp;lt;Vegetable&amp;gt;的子类，因为胡萝卜汤显然是一种蔬菜汤。如果真是这样，那就看看下面的代码。其中Tomato表示西红柿，是Vegetable的另一个子类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Soup&amp;lt;Vegetable&amp;gt; soup = &lt;span&gt;new&lt;/span&gt; Soup&amp;lt;Carrot&amp;gt;&lt;span&gt;();
soup.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Tomato());
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一句没问题，Soup&amp;lt;Carrot&amp;gt;是Soup&amp;lt;Vegetable&amp;gt;的子类，所以可以将Soup&amp;lt;Carrot&amp;gt;的实例赋给变量soup。第二句也没问题，因为soup声明为Soup&amp;lt;Vegetable&amp;gt;类型，它的add方法接收一个Vegetable类型的参数，而Tomato是Vegetable，类型正确。&lt;/p&gt;
&lt;p&gt;但是，两句放在一起却有了问题。soup的实际类型是Soup&amp;lt;Carrot&amp;gt;，而我们给它的add方法传递了一个Tomato的实例！换言之，我们在用西红柿做胡萝卜汤，肯定做不出来。所以，把Soup&amp;lt;Carrot&amp;gt;视为Soup&amp;lt;Vegetable&amp;gt;的子类在逻辑上虽然是通顺的，在使用过程中却是有缺陷的。&lt;/p&gt;
&lt;p&gt;那么，Soup&amp;lt;Carrot&amp;gt;和Soup&amp;lt;Vegetable&amp;gt;究竟应该是什么关系呢？不同的语言有不同的理解和实现。总结起来，有三种情况。&lt;/p&gt;
&lt;p&gt;（1）如果Soup&amp;lt;Carrot&amp;gt;是Soup&amp;lt;Vegetable&amp;gt;的子类，则称泛型Soup&amp;lt;T&amp;gt;是协变的&lt;br/&gt;（2）如果Soup&amp;lt;Carrot&amp;gt;和Soup&amp;lt;Vegetable&amp;gt;是无关的两个类，则称泛型Soup&amp;lt;T&amp;gt;是不变的&lt;br/&gt;（3）如果Soup&amp;lt;Carrot&amp;gt;是Soup&amp;lt;Vegetable&amp;gt;的父类，则称泛型Soup&amp;lt;T&amp;gt;是逆变的。（不过逆变不常见）&lt;/p&gt;
&lt;p&gt;理解了协变、不变和逆变的概念，再看Java的实现。Java的一般泛型是不变的，也就是说Soup&amp;lt;Vegetable&amp;gt;和Soup&amp;lt;Carrot&amp;gt;是毫无关系的两个类，不能将一个类的实例赋值给另一个类的变量。所以，上面那段用西红柿做胡萝卜汤的代码，其实根本无法通过编译。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、数组协变&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Java中，数组是基本类型，不是泛型，不存在Array&amp;lt;T&amp;gt;这样的东西。但它和泛型很像，都是用另一个类型构建的类型。所以，数组也是要考虑变性的。&lt;/p&gt;
&lt;p&gt;与泛型的不变性不同，Java的数组是&lt;strong&gt;协变&lt;/strong&gt;的。也就是说，Carrot[]是Vegetable[]的子类。而上一节中的例子已经表明，协变有时会引发问题。比如下面这段代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Vegetable[] vegetables = &lt;span&gt;new&lt;/span&gt; Carrot[10&lt;span&gt;];
vegetables[&lt;/span&gt;0] = &lt;span&gt;new&lt;/span&gt; Tomato(); // 运行期错误
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为数组是协变的，编译器允许把Carrot[10]赋值给Vegetable[]类型的变量，所以这段代码可以顺利通过编译。只有在运行期，JVM真的试图往一堆胡萝卜中插入一个西红柿的时候，才发现大事不好。所以，上面的代码在运行期会抛出一个java.lang.ArrayStoreException类型的异常。&lt;/p&gt;
&lt;p&gt;数组协变性，是Java的著名历史包袱之一。使用数组时，千万要小心！&lt;/p&gt;
&lt;p&gt;如果把例子中的数组替换为List，情况就不同了。就像这样&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
ArrayList&amp;lt;Vegetable&amp;gt; vegetables = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Carrot&amp;gt;&lt;span&gt;(); // 编译期错误
vegetables.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Tomato());
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ArrayList是一个泛型类，它是不变的。所以，ArrayList&amp;lt;Carrot&amp;gt;和ArrayList&amp;lt;Vegetable&amp;gt;之间并无继承关系，这段代码在编译期就会报错。&lt;/p&gt;
&lt;p&gt;两段代码虽然都会报错，但通常情况下，编译期错误总比运行期错误好处理一些。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;三、当泛型也想要协变、逆变&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;泛型是不变的，但某些场景里我们还是希望它能协变起来。比如，有一个天天喝蔬菜汤减肥的小姐姐&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Girl {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; drink(Soup&amp;lt;Vegetable&amp;gt;&lt;span&gt; soup) {}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们希望drink方法可以接受各种不同的蔬菜汤，包括Soup&amp;lt;Carrot&amp;gt;和Soup&amp;lt;Tomato&amp;gt;。但受到不变性的限制，它们无法作为drink的参数。&lt;/p&gt;
&lt;p&gt;要实现这一点，应该采用一种类似于协变性的写法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; drink(Soup&amp;lt;? &lt;span&gt;extends&lt;/span&gt; Vegetable&amp;gt; soup) {}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;意思是，参数soup的类型是泛型类Soup&amp;lt;T&amp;gt;，而T是Vegetable的子类（也包括Vegetable自己）。这时，小姐姐终于可以愉快地喝上胡萝卜汤和西红柿汤了。&lt;/p&gt;
&lt;p&gt;但是，这种方法有一个限制。编译器只知道泛型参数是Vegetable的子类，却不知道它具体是什么。所以，所有非null的泛型类型参数均被视为不安全的。说起来很拗口，其实很简单。直接上代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; drink(Soup&amp;lt;? &lt;span&gt;extends&lt;/span&gt; Vegetable&amp;gt;&lt;span&gt; soup) {
    soup.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Tomato()); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 错误&lt;/span&gt;
    soup.add(&lt;span&gt;null&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 正确&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;方法内的第一句会在编译期报错。因为编译器只知道add方法的参数是Vegetable的子类，却不知道它具体是Carrot、Tomato、或者其他的什么类型。这时，传递一个具体类型的实例一律被视为不安全的。即使soup真的是Soup&amp;lt;Tomato&amp;gt;类型也不行，因为soup的具体类型信息是在运行期才能知道的，编译期并不知道。&lt;/p&gt;
&lt;p&gt;但是方法内的第二句是正确的。因为参数是null，它可以是任何合法的类型。编译器认为它是安全的。&lt;/p&gt;
&lt;p&gt;同样，也有一种类似于逆变的方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; drink(Soup&amp;lt;? &lt;span&gt;super&lt;/span&gt; Vegetable&amp;gt; soup) {}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这时，Soup&amp;lt;T&amp;gt;中的T必须是Vegetable的父类。&lt;/p&gt;
&lt;p&gt;这种情况就不存在上面的限制了，下面的代码毫无问题&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; drink(Soup&amp;lt;? &lt;span&gt;super&lt;/span&gt; Vegetable&amp;gt;&lt;span&gt; soup) {
    soup.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Tomato());
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Tomato是Vegetable的子类，自然也是Vegetable父类的子类。所以，编译期就可以确定类型是安全的。&lt;/p&gt;
</description>
<pubDate>Sat, 23 Feb 2019 05:59:00 +0000</pubDate>
<dc:creator>左之了</dc:creator>
<og:description>变性是OOP语言不变的大坑，Java的数组协变就是其中的一口老坑。因为最近踩到了，便做一个记录。顺便也提一下范型的变性。 解释数组协变之前，先明确三个相关的概念，协变、不变和逆变。 一、协变、不变、逆</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tjxing/p/10419993.html</dc:identifier>
</item>
</channel>
</rss>