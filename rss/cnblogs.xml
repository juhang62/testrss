<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Spring Cloud Ribbon负载均衡 - c旋儿</title>
<link>http://www.cnblogs.com/cxuanBlog/p/10941576.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cxuanBlog/p/10941576.html</guid>
<description>&lt;h2 id=&quot;一简介&quot;&gt;一、简介&lt;/h2&gt;
&lt;p&gt;​ &lt;code&gt;Spring Cloud Ribbon&lt;/code&gt;是一个基于HTTP 和 TCP的客户端负载工具，它基于Netflix Ribbon实现，我们可以使用它来进行&lt;code&gt;远程服务负载均衡&lt;/code&gt;的调用。它不像Zuul 和 Eureka 等可以独立部署，它虽然是一个工具类框架，&lt;strong&gt;但是几乎所有的Spring Cloud微服务架构和基础设施都离不开它，包括后面所介绍的Feign 远程调用，也是基于Ribbon实现的工具&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;二客户端负载均衡&quot;&gt;二、客户端负载均衡&lt;/h2&gt;
&lt;p&gt;​ &lt;strong&gt;负载均衡是在一个架构中非常重要，而且不得不去实施的内容。&lt;/strong&gt;因为负载均衡对系统的高可用，网络压力的缓解和处理能力扩容的重要手段之一。通常负载均衡分为两种：&lt;code&gt;硬件负载均衡&lt;/code&gt; 和 &lt;code&gt;软件负载均衡&lt;/code&gt;，硬件负载均衡一般是通过硬件来实现，在&lt;strong&gt;服务器节点之间安装特定的负载均衡设备&lt;/strong&gt;，比如F5。 而软件负载均衡是采用软件控制的手段实现的，它实在&lt;strong&gt;服务器之间安装某种特定功能的软件&lt;/strong&gt;来完成特定的请求分开工作，比如Nginx等。无论硬件负载还是软件负载，只要是服务端负载均衡都能以下图的架构方式构建起来：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1515111/201905/1515111-20190529053824017-1050946590.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​ 硬件负载均衡的设备和软件负载均衡的模块都会维护一个&lt;code&gt;下挂可用的服务清单&lt;/code&gt;，通过&lt;code&gt;心跳检测&lt;/code&gt;来&lt;code&gt;剔除故障的服务节点&lt;/code&gt;以保证清单中都是可以访问的服务端节点。当客户发送请求到负载均衡的设备时。设备按照服务负载均衡的算法(随机访问，轮询访问，权重访问，最少访问次数算法)来找到对应的服务端。&lt;/p&gt;
&lt;p&gt;​ 而客户端负载均衡和服务端负载均衡最大的不同点在于上面所提到&lt;code&gt;服务清单的存储位置&lt;/code&gt;。在客户端负载均衡中，所有客户端节点都维护着自己要访问的服务清单，而这些服务清单都来自注册中心，比如我们上一章介绍的Eureka服务端。&lt;/p&gt;
&lt;p&gt;​ 通过Spring Cloud Ribbon的封装，我们在微服务架构中使用负载均衡就比较简单，只需要下面两步：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;服务提供者&lt;/code&gt;只需要启动多个服务实例并注册到一个注册中心或是多个相关联的服务注册中心&lt;/li&gt;
&lt;li&gt;&lt;code&gt;服务消费者&lt;/code&gt;直接调用被@LoadBalanced注解修饰过的RestTemplate来实现面向服务的接口调用。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;三resttemplate详解&quot;&gt;三、RestTemplate详解&lt;/h2&gt;
&lt;p&gt;​ 在上一章中，我们已经引入了Spring Cloud Ribbon实现了客户端负载均衡的一个简单的实例，其中，我们使用了一个非常有用的对象&lt;code&gt;RestTemplate&lt;/code&gt;。该对象会使用Ribbon的自动化配置，同时通过配置&lt;code&gt;@LoadBalanced&lt;/code&gt;开启客户端&lt;code&gt;负载均衡&lt;/code&gt;。下面我们将详细介绍RestTemplate 针对几种不同的请求类型和参数类型的服务调用实现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;准备工作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在上一篇博客中，我们搭建了&lt;code&gt;一个注册中心&lt;/code&gt;，&lt;code&gt;一个服务提供者&lt;/code&gt;，&lt;code&gt;一个ribbon消费者客户端&lt;/code&gt;，现在我们也需要这三个组件来做Ribbon 服务消费&lt;/p&gt;
&lt;h3 id=&quot;get请求&quot;&gt;GET请求&lt;/h3&gt;
&lt;p&gt;在RestTemplate中，对GET请求可以通过如下两个方法进行调用实现。&lt;/p&gt;
&lt;p&gt;第一种：&lt;code&gt;getForEntity()&lt;/code&gt;函数，该方法返回的是&lt;code&gt;ResponseEntity&lt;/code&gt;，该对象是Spring对HTTP请求响应的封装，其中主要存储了HTTP的几个重要元素，比如HTTP请求状态码的枚举对象HttpStatus(常用的404，500这些错误)，在它的父类&lt;code&gt;HttpEntity&lt;/code&gt;中还存储着HTTP请求的头信息对象&lt;code&gt;HttpHeaders&lt;/code&gt;以及泛型类型集合的请求体对象。&lt;/p&gt;
&lt;p&gt;它的一般形式有三种：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/*
* url是远程服务端的路径，responseType是返回值类型，urlVariables是可变参数，给服务端传递的参数
*/
getForEntity(String url, Class&amp;lt;T&amp;gt; responseType, Object... urlVariables)
  
/*
* 可以使用Map封装参数传递给客户端
*/
getForEntity(String url, Class&amp;lt;T&amp;gt; responseType, Map&amp;lt;String, ?&amp;gt; urlVariables)
  
/*
* 也是一直接使用uri地址
*/
getForEntity(URI url, Class&amp;lt;T&amp;gt; responseType) throws RestClientException

/*
* getForObject 用法和getForEntity基本相同
*/
getForObject(String url, Class&amp;lt;T&amp;gt; responseType, Object... urlVariables) throws RestClientException

getForObject(String url, Class&amp;lt;T&amp;gt; responseType, Map&amp;lt;String, ?&amp;gt; urlVariables) throws RestClientException

getForObject(URI url, Class&amp;lt;T&amp;gt; responseType) throws RestClientException
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;strong&gt;URI 和 URL 的关系：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;URI : 统一资源&lt;/strong&gt;标志符&lt;strong&gt;:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;URL: 统一资源&lt;/strong&gt;定位符****&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;URN : 统一资源&lt;/strong&gt;名称****&lt;/p&gt;
&lt;p&gt;三者之间的关系：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;一般用法&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;getForEntity&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;Ribbon 消费者&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;        /**
     * 文章基于spring-boot-starter-parent 1.3.7 版本
     * 如果读者使用1.5.9 以上的版本，可以用GetMapping
     * @return
     */
    @RequestMapping(value = &quot;/ribbon-consumer1&quot;, method = RequestMethod.GET)
    public ResponseEntity&amp;lt;String&amp;gt; helloUser(){
      // 返回值是String类型，所以对应第一个逗号后面的类型
      // /user/{1} 中的{1}表示的是第一个参数，传的值是didi
      // 也可以用getForEntity().getBody() 方法，此时返回值就只是一个String类型
        return restTemplate.getForEntity(&quot;http://server-provider/user/{1}&quot;,String.class,&quot;didi&quot;);
    }

        
    @RequestMapping(value = &quot;/ribbon-consumer2&quot;, method = RequestMethod.GET)
    public ResponseEntity&amp;lt;User&amp;gt; helloUser2(){
        // 返回值是一个User类型
        // 多个参数之间用&amp;amp; 隔开
        return restTemplate.getForEntity(&quot;http://server-provider/user2?id=001&amp;amp;name=didi&quot;,User.class);
    }

        // 传递一个Map类型的对象
    @RequestMapping(value = &quot;/ribbon-consumer3&quot;, method = RequestMethod.GET)
    public ResponseEntity&amp;lt;String&amp;gt; helloUser3(){
        Map params = new HashMap();
        params.put(&quot;name&quot;,&quot;data&quot;);
        // {name}表示的是params中的key
        return restTemplate.getForEntity(&quot;http://server-provider/user3?name={name}&quot;, String.class,params);
    }

        // 其实最核心的就是通过uri进行调用，上面所有的写法都会转换为下面这种写法
        // 也就是说下面这种写法是最根本的。
    @RequestMapping(value = &quot;/ribbon-consumer4&quot;, method = RequestMethod.GET)
    public ResponseEntity&amp;lt;String&amp;gt; helloUser4(){
        UriComponents uriComponents = UriComponentsBuilder.fromUriString(
                &quot;http://server-provider/user4?name={name}&quot;)
                .build()
                .expand(&quot;lx&quot;)
                .encode();
        URI uri = uriComponents.toUri();
        return restTemplate.getForEntity(uri,String.class);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;User 对象&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class User {

    private Integer id;
    private String name;

    public User(){}
    public User(Integer id, String name) {
        this.id = id;
        this.name = name;
    }
        get and set...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;服务提供者&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;来看一下服务提供者的代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    // 返回的类型是String
    @RequestMapping(value = &quot;/user/{name}&quot;, method = RequestMethod.GET)
    public String helloUser(@PathVariable(&quot;name&quot;) String name){
        return &quot;Hello &quot; + name;
    }

    // 返回的类型是User
    @RequestMapping(value = &quot;/user2&quot;, method = RequestMethod.GET)
    public User helloUser(User user){
        return user;
    }

    @RequestMapping(value = &quot;/user3&quot;, method = RequestMethod.GET)
    public String helloUser1(@RequestParam(&quot;name&quot;) String name){
        return &quot;Hello &quot; + name;
    }

    @RequestMapping(value = &quot;/user4&quot;, method = RequestMethod.GET)
    public String helloUser2(@RequestParam(&quot;name&quot;) String name){
        return &quot;Hello &quot; + name;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;getForObject()&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;Ribbon 消费者&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;        @RequestMapping(value = &quot;/ribbonGet&quot;, method = RequestMethod.GET)
    public String ribbonGet(){
        // {1} 和 {2} 都是占位符，分别代表着 001 和 lx的值 
        return restTemplate.getForObject(&quot;http://server-provider/ribbon?id={1}&amp;amp;name={2}&quot;,String.class,
                new Object[]{&quot;001&quot;,&quot;lx&quot;});
    }

        // 和上面用法基本相同
    @RequestMapping(value = &quot;/ribbonGet2&quot;, method = RequestMethod.GET)
    public String ribbonGet2(){
        Map params = new HashMap();
        params.put(&quot;id&quot;,&quot;001&quot;);
        params.put(&quot;name&quot;,&quot;lx&quot;);
        return restTemplate.getForObject(&quot;http://server-provider/ribbon?id={id}&amp;amp;name={name}&quot;,String.class,
                params);
    }

    @RequestMapping(value = &quot;/ribbonGet3&quot;, method = RequestMethod.GET)
    public String ribbonGet3(){
        UriComponents uriComponents = UriComponentsBuilder.fromUriString(
                &quot;http://server-provider/ribbon?id={id}&amp;amp;name={name}&quot;)
                .build()
                .expand(&quot;001&quot;,&quot;lx&quot;)
                .encode();
        URI uri = uriComponents.toUri();
        return restTemplate.getForObject(uri,String.class);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;服务提供者&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;        // 上面所有的url共用下面一个方法
        @RequestMapping(value = &quot;/ribbon&quot;, method = RequestMethod.GET)
    public String acceptRibbon(@RequestParam(&quot;id&quot;)String id,
                               @RequestParam(&quot;name&quot;) String name){

        System.out.println(&quot;id = &quot; + id + &quot;name = &quot; + name);
        return &quot;Hello &quot; + id + &quot; World &quot; + name;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;post请求&quot;&gt;POST请求&lt;/h3&gt;
&lt;p&gt;了解完GET请求后，再来看一下POST请求：&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;RestTemplate&lt;/code&gt;中，POST请求可以用一下几种方式来实现&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// postForEntity
postForEntity(String url, Object request, Class&amp;lt;T&amp;gt; responseType, Object... uriVariables)   
postForEntity(String url, Object request, Class&amp;lt;T&amp;gt; responseType, Map&amp;lt;String, ?&amp;gt; uriVariables)
postForEntity(URI url, Object request, Class&amp;lt;T&amp;gt; responseType) throws RestClientException

// postForObject
postForObject(String url, Object request, Class&amp;lt;T&amp;gt; responseType, Object... uriVariables)
postForObject(String url, Object request, Class&amp;lt;T&amp;gt; responseType, Map&amp;lt;String, ?&amp;gt; uriVariables)
postForObject(URI url, Object request, Class&amp;lt;T&amp;gt; responseType) throws RestClientException

// postForLocation
postForLocation(String url, Object request, Object... urlVariables) throws RestClientException
postForLocation(String url, Object request, Map&amp;lt;String, ?&amp;gt; urlVariables) throws RestClientException 
postForLocation(URI url, Object request) throws RestClientException&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Ribbon服务端&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;        /**
     * 文章基于spring-boot-starter-parent 1.3.7 版本
     * 如果读者使用1.5.9 以上的版本，可以用 PostMapping
     * @return
     */
    @RequestMapping(value = &quot;/ribbonPost&quot;, method = RequestMethod.POST)
    public User ribbonPost(){
        User user = new User(001,&quot;lx&quot;);
        return restTemplate.postForEntity(&quot;http://server-provider/rpost&quot;,user,User.class)
                .getBody();
    }

    @RequestMapping(value = &quot;/ribbonPost2&quot;, method = RequestMethod.POST)
    public User ribbonPost2(){
        User user = new User(001,&quot;lx&quot;);
        UriComponents uriComponents = UriComponentsBuilder.fromUriString(&quot;http://server-provider/location&quot;)
                .build()
                .expand(user)
                .encode();
        URI uri = uriComponents.toUri();
        return restTemplate.postForEntity(uri,user,User.class).getBody();
    }

    @RequestMapping(value = &quot;/ribbonPost3&quot;, method = RequestMethod.POST)
    public String ribbonPost3(){
        User user = new User(001,&quot;lx&quot;);
        // 占位符石str, 服务端可以用 @PathVariable获取
        return restTemplate.postForEntity(&quot;http://server-provider/rbPost/{str}&quot;,user,String.class,&quot;hello&quot;)
                .getBody();
    }

    @RequestMapping(value = &quot;/ribbonPost4&quot;, method = RequestMethod.POST)
    public String ribbonPost4(){
        Map&amp;lt;String,String&amp;gt; params = new HashMap&amp;lt;&amp;gt;();
        params.put(&quot;id&quot;,&quot;001&quot;);
        params.put(&quot;name&quot;,&quot;lx&quot;);
        return restTemplate.postForEntity(&quot;http://server-provider/mapPost&quot;,params,String.class).getBody();
    }

    /**
     *  restTemplate.postForObject()方法与上面用法几乎相同
     *  postForEntity(String url, Object request, Class&amp;lt;T&amp;gt; responseType, Object... uriVariables)
     *  postForEntity(String url, Object request, Class&amp;lt;T&amp;gt; responseType, Map&amp;lt;String, ?&amp;gt; uriVariables)
     *  postForEntity(URI url, Object request, Class&amp;lt;T&amp;gt; responseType)
     *  
     *. postForLocation 也相似，这里就不再举例说明了
     */&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;服务提供者&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;     @RequestMapping(value = &quot;/rpost&quot;, method = RequestMethod.POST)
    public User accpetRibbonPost(@RequestBody User user){
        log.info(&quot;id = &quot; + user.getId() + &quot; name = &quot; + user.getName());
        return user;
    }

    @RequestMapping(value = &quot;/location&quot;, method = RequestMethod.POST)
    public User acceptRibbonPost2(@RequestBody User user){
        log.info(&quot;id = &quot; + user.getId() + &quot; name = &quot; + user.getName());
        return user;
    }

    @RequestMapping(value = &quot;/rbPost/{str}&quot;, method = RequestMethod.POST)
    public String accpetRibbonPost3(@PathVariable String str, @RequestBody User user){
        log.info(&quot;str = &quot; + str);
        log.info(&quot;id = &quot; + user.getId() + &quot; name = &quot; + user.getName());
        return str + &quot; &quot; + user.getId() + &quot; &quot; + user.getName();
    }

    @RequestMapping(value = &quot;/mapPost&quot;, method = RequestMethod.POST)
    public String acceptRibbonPost4(@RequestBody Map map){
        String id = (String)map.get(&quot;id&quot;);
        String name = (String)map.get(&quot;name&quot;);
        return &quot;id = &quot; + id + &quot; name = &quot; + name;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;put请求&quot;&gt;PUT请求&lt;/h3&gt;
&lt;p&gt;Restful中的put请求经常用来修改某些属性的值，他和POST请求相似&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一般形式&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/*
* 它的形式比较少，只有一种比较形式
*/
put(String url, Object request, Object... urlVariables) throws RestClientException
put(String url, Object request, Map&amp;lt;String, ?&amp;gt; urlVariables) throws RestClientException
put(URI url, Object request) throws RestClientException&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Ribbon服务端&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @RequestMapping(value = &quot;/putRibbon&quot;, method = RequestMethod.PUT)
  public void putRibbon(){
    restTemplate.put(&quot;http://server-provider/ribbonPut&quot;,new User(21,&quot;lx&quot;));
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;这里只采用了一种简单形式，用法和Post很相似，没有再详细说明&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PUT请求没有返回值，可以理解为只把需要的值传过去就可以，修改成功不成功与我没有关系&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;服务提供者&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    
    @RequestMapping(value = &quot;/ribbonPut&quot;, method = RequestMethod.PUT)
  public void acceptRibbonPut(@RequestBody User user){
    log.info(&quot;user.id = &quot; + user.getId() + &quot; user.name = &quot; + user.getName());
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;delete请求&quot;&gt;DELETE请求&lt;/h3&gt;
&lt;p&gt;delete请求在Restful API中一般用于根据id删除某条信息，用法也比较简单，没有返回值&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一般形式&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;delete(String url, Object... urlVariables) throws RestClientException
delete(String url, Map&amp;lt;String, ?&amp;gt; urlVariables) throws RestClientException
delete(URI url) throws RestClientException&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Ribbon服务端&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;  @RequestMapping(value = &quot;/deleteRibbon&quot;, method = RequestMethod.DELETE)
  public void deleteUser(){
    User user = new User(21,&quot;lx&quot;);
    restTemplate.delete(&quot;http://server-provider/ribbonDelete/{1}&quot;,user.getId());
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;服务提供者&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @RequestMapping(value = &quot;/ribbonDelete/{id}&quot;, method = RequestMethod.DELETE)
  public void deleteRibbon(@PathVariable Integer id){
    log.info(&quot;delete user &quot; + id);
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;https://www.jb51.net/article/138563.htm#comments&lt;/p&gt;
&lt;p&gt;《Spring Cloud 微服务实战》&lt;/p&gt;
</description>
<pubDate>Tue, 28 May 2019 21:37:00 +0000</pubDate>
<dc:creator>c旋儿</dc:creator>
<og:description>[TOC] 一、简介 ​ 是一个基于HTTP 和 TCP的客户端负载工具，它基于Netflix Ribbon实现，我们可以使用它来进行 的调用。它不像Zuul 和 Eureka 等可以独立部署，它虽然</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cxuanBlog/p/10941576.html</dc:identifier>
</item>
<item>
<title>深入V8引擎-Time核心方法之win篇(2) - 书生小龙</title>
<link>http://www.cnblogs.com/QH-Jimmy/p/10940840.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/QH-Jimmy/p/10940840.html</guid>
<description>&lt;p&gt;　　这一篇讲windows系统下TimeTicks的实现。&lt;/p&gt;
&lt;p&gt;　　对于tick，V8写了相当长的一段discussion来讨论windows系统上计数的三种实现方法以及各自的优劣，注释在time.cc的572行，这里直接简单翻译一下，不贴出来了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CPU cycle counter.(Retrieved via RDTSC)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　CPU计数器拥有最高的分辨率，消耗也是最小的。然而，在一些老的CPU上会有问题；1、每个处理器独立唯一各自的tick，并且处理器之间不会同步数据。2、计数器会因为温度、功率等原因频繁变化，有些情况甚至会停止。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;QueryPerformanceCounter (QPC)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　QPC计数法就是之前libuv用的API，分辨率也相当的高。比起CPU计数器，优点就是不存在多处理器有多个tick，保证数据的唯一。但是在老的CPU上，也会因为BIOS、HAL而出现一些问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;System Time&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　通过别的windowsAPI返回的系统时间来计数。&lt;/p&gt;

&lt;p&gt;　　上一篇Clock类的构造函数中，对TimeTicks属性的初始化也只是调用了老TimeTicks的Now方法，所以直接上Now的代码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;TimeTicks InitialTimeTicksNowFunction();

&lt;/span&gt;&lt;span&gt;using&lt;/span&gt; TimeTicksNowFunction = decltype(&amp;amp;&lt;span&gt;TimeTicks::Now);
TimeTicksNowFunction g_time_ticks_now_function &lt;/span&gt;= &amp;amp;&lt;span&gt;InitialTimeTicksNowFunction;

TimeTicks TimeTicks::Now() {
  TimeTicks ticks(g_time_ticks_now_function());
  DCHECK(&lt;/span&gt;!&lt;span&gt;ticks.IsNull());
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ticks;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　windows系统下，会预先一个初始化方法，这里的语法不用去理解，只需要知道调用InitialTimeTicksNowFunction方法后，将其返回作为参数构造一个TimeTicks对象，返回的就是硬件时间戳。&lt;/p&gt;
&lt;p&gt;　　这个方法比较简单，如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;TimeTicks InitialTimeTicksNowFunction() {
  InitializeTimeTicksNowFunctionPointer();
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; g_time_ticks_now_function();
}&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　可以看到，那个g_time_ticks_now_function又被调用了一次，但是作为一个函数指针，第二次调用的时候指向的就不是同一个方法。至于为什么特意弄一个函数指针，后面会具体解释。&lt;/p&gt;
&lt;p&gt;　　看这里的第一个方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; InitializeTimeTicksNowFunctionPointer() {
  LARGE_INTEGER ticks_per_sec &lt;/span&gt;=&lt;span&gt; {};
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!QueryPerformanceFrequency(&amp;amp;ticks_per_sec)) ticks_per_sec.QuadPart = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果windows不支持QPC或者该方法不可靠 会降级去使用低分辨率的lowB方法&lt;/span&gt;
&lt;span&gt;  TimeTicksNowFunction now_function;
  CPU cpu;
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; QPC不好使的情况&lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt; (ticks_per_sec.QuadPart &amp;lt;= &lt;span&gt;0&lt;/span&gt; || !cpu.has_non_stop_time_stamp_counter() ||&lt;span&gt;
      IsBuggyAthlon(cpu)) {
    now_function &lt;/span&gt;= &amp;amp;&lt;span&gt;RolloverProtectedNow;
  }
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 好使的情况 &lt;/span&gt;
  &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
    now_function &lt;/span&gt;= &amp;amp;&lt;span&gt;QPCNow;
  }

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里不需要担心多线程问题 因为更改的都是同一个全局变量&lt;/span&gt;
  g_qpc_ticks_per_second =&lt;span&gt; ticks_per_sec.QuadPart;
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 先不管这个 不然讲不完&lt;/span&gt;
&lt;span&gt;  ATOMIC_THREAD_FENCE(memory_order_release);
  g_time_ticks_now_function &lt;/span&gt;=&lt;span&gt; now_function;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　从几个赋值可以看到，整个函数都是围绕着函数指针now_function的指向，其实也就是g_time_ticks_now_function，根据系统对QPC的支持，来选择不同的方法实现TimeTicks。&lt;/p&gt;
&lt;p&gt;　　所以，特意用一个函数指针来控制Now方法的目的也明显了，理论上只有第一次调用会进到这个特殊函数，检测当前操作系统的QPC是否适用，然后选择对应的方法。后面再次调用的时候，就直接进入选好的方法(具体思想可以参考《JavaScript高级程序设计》高级技巧章节的惰性载入函数)。这个情况有一点像我在&lt;a href=&quot;https://www.cnblogs.com/QH-Jimmy/p/10846097.html&quot; target=&quot;_blank&quot;&gt;解析node事件轮询&lt;/a&gt;时提到的线程池初始化情形，不同的是，这里V8没有特意去加一个锁来防止多线程竞态。原因也很简单，因为此处只是对一个全局的函数指针做赋值，就算多赋值几次对后续的线程并没有任何影响，没有必要特意做锁。&lt;/p&gt;
&lt;p&gt;　　关于QueryPerformanceFrequency方法(这些函数名都好TM长)的具体用法，可以参考我&lt;a href=&quot;https://www.cnblogs.com/QH-Jimmy/p/10080857.html&quot; target=&quot;_blank&quot;&gt;别的博客&lt;/a&gt;，啥都解释写不完啦。&lt;/p&gt;
&lt;p&gt;　　存在两种情况的实现，先看支持QPC的，删掉了合法性检测宏，这些宏无处不在，太碍眼了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
TimeTicks QPCNow() { &lt;span&gt;return&lt;/span&gt; TimeTicks() +&lt;span&gt; QPCValueToTimeDelta(QPCNowRaw()); }

V8_INLINE uint64_t QPCNowRaw() {
  LARGE_INTEGER perf_counter_now &lt;/span&gt;=&lt;span&gt; {};
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; According to the MSDN documentation for QueryPerformanceCounter(), this
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; will never fail on systems that run XP or later.
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt; &lt;span&gt;https://msdn.microsoft.com/library/windows/desktop/ms644904.aspx&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里说理论上XP以后的系统都支持QPC&lt;/span&gt;
  BOOL result = ::QueryPerformanceCounter(&amp;amp;&lt;span&gt;perf_counter_now);
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; perf_counter_now.QuadPart;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; To avoid overflow in QPC to Microseconds calculations, since we multiply
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; by kMicrosecondsPerSecond, then the QPC value should not exceed
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; (2^63 - 1) / 1E6. If it exceeds that threshold, we divide then multiply.&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; constexpr int64_t kQPCOverflowThreshold = INT64_C(&lt;span&gt;0x8637BD05AF7&lt;/span&gt;&lt;span&gt;);

TimeDelta QPCValueToTimeDelta(LONGLONG qpc_value) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里的if/else逻辑见上面静态变量的注释 也可以看我下面翻译的
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 理论上的计算公式是 (qpc_count * 1e6) / qpc_count_per_second 得到微秒单位的硬件时间戳
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 但是int64类型最大只能处理2^63 - 1 而这个windowsAPI返回的数字(换算乘以1e6后)可能超过这个范围
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果数字过大 就用先除再乘的方式计算避免溢出

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 正常情况&lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt; (qpc_value &amp;lt;&lt;span&gt; TimeTicks::kQPCOverflowThreshold) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; TimeDelta::FromMicroseconds(
        qpc_value &lt;/span&gt;* TimeTicks::kMicrosecondsPerSecond /&lt;span&gt; g_qpc_ticks_per_second);
  }
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 溢出情况
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 先除得到一个秒单位的时间戳&lt;/span&gt;
  int64_t whole_seconds = qpc_value /&lt;span&gt; g_qpc_ticks_per_second;
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 计算误差&lt;/span&gt;
  int64_t leftover_ticks = qpc_value - (whole_seconds *&lt;span&gt; g_qpc_ticks_per_second);
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用当前+误差得到最终的微秒单位时间戳&lt;/span&gt;
  &lt;span&gt;return&lt;/span&gt;&lt;span&gt; TimeDelta::FromMicroseconds(
      (whole_seconds &lt;/span&gt;* TimeTicks::kMicrosecondsPerSecond) +&lt;span&gt;
      ((leftover_ticks &lt;/span&gt;* TimeTicks::kMicrosecondsPerSecond) /&lt;span&gt;
       g_qpc_ticks_per_second));
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　直接看注释就好了，不过我有一些问题，先记录下来，后面对C++深入研究后再来解释。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;按照英文注释，qpc乘以1e6后过大，再除以一个数时会溢出。但是下面的那个方法用的是1个溢出数加上1个小整数，为啥这样就不会出问题。难道加减不存在threshold？&lt;/li&gt;
&lt;li&gt;那个计算误差是我理解的，实际上如果上过小学，把上面的变量代入第二个算式，会得到leftover_ticks为0，这里的逻辑暂时没理清。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　总之，最后还是利用了QPC的两个API得到硬件时间戳，跟libuv的套路差不多。&lt;/p&gt;
&lt;p&gt;　　下面来看不支持QPC的情况，不过先过一下那个if。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CPU cpu;
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ticks_per_sec.QuadPart &amp;lt;= &lt;span&gt;0&lt;/span&gt; || !cpu.has_non_stop_time_stamp_counter() ||&lt;span&gt;
    IsBuggyAthlon(cpu)) {
  now_function &lt;/span&gt;= &amp;amp;RolloverProtectedNow;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　有三个条件表明QPC不适用。&lt;/p&gt;
&lt;p&gt;　　第一个很直白，API在当前操作系统不支持。&lt;/p&gt;
&lt;p&gt;　　第二个是通过CPU判断QPC是否可靠，具体原理十分麻烦，有兴趣单独开一篇解释吧。&lt;/p&gt;
&lt;p&gt;　　第三个就比较简单，有些牌子的CPU就是垃圾，直接根据内置API返回的参数判断是不是不支持的类型，如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;bool&lt;/span&gt; IsBuggyAthlon(&lt;span&gt;const&lt;/span&gt; CPU&amp;amp;&lt;span&gt; cpu) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; On Athlon X2 CPUs (e.g. model 15) QueryPerformanceCounter is unreliable.&lt;/span&gt;
  &lt;span&gt;return&lt;/span&gt; strcmp(cpu.vendor(), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AuthenticAMD&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) == &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; cpu.family() == &lt;span&gt;15&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　正式进入QPC不支持分支。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;union LastTimeAndRolloversState {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 完整的32位时间&lt;/span&gt;
&lt;span&gt;  int32_t as_opaque_32;

  &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 时间头8位&lt;/span&gt;
&lt;span&gt;    uint8_t last_8;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 时间重置次数&lt;/span&gt;
&lt;span&gt;    uint16_t rollovers;
  } as_values;
};

TimeTicks RolloverProtectedNow() {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 见上面的解释&lt;/span&gt;
&lt;span&gt;  LastTimeAndRolloversState state;
  DWORD now;  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; DWORD is always unsigned 32 bits.

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这是一个原子操作数 线程安全&lt;/span&gt;
  int32_t original =&lt;span&gt; g_last_time_and_rollovers.load(std::memory_order_acquire);
  &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 类型为int32位整数&lt;/span&gt;
    state.as_opaque_32 =&lt;span&gt; original;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义如下 实际上就是windowsAPI的timeGetTime
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; DWORD timeGetTimeWrapper() { return timeGetTime(); }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; DWORD (*g_tick_function)(void) = &amp;amp;timeGetTimeWrapper;&lt;/span&gt;
    now =&lt;span&gt; g_tick_function();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 移位后只获取头8位&lt;/span&gt;
    uint8_t now_8 = static_cast&amp;lt;uint8_t&amp;gt;(now &amp;gt;&amp;gt; &lt;span&gt;24&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当头8位的时间比保存的要小时 说明返回值重置了&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (now_8 &amp;lt; state.as_values.last_8) ++&lt;span&gt;state.as_values.rollovers;
    state.as_values.last_8 &lt;/span&gt;=&lt;span&gt; now_8;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当两次相同时 代表当前的值是稳定可信的 直接返回&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (state.as_opaque_32 == original) &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (g_last_time_and_rollovers.compare_exchange_weak(
            original, state.as_opaque_32, std::memory_order_acq_rel)) {
      &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
    }
  }
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回次数 * 2^32 加上 当前时间&lt;/span&gt;
  &lt;span&gt;return&lt;/span&gt; TimeTicks() +&lt;span&gt;
         TimeDelta::FromMilliseconds(
             now &lt;/span&gt;+ (static_cast&amp;lt;uint64_t&amp;gt;(state.as_values.rollovers) &amp;lt;&amp;lt; &lt;span&gt;32&lt;/span&gt;&lt;span&gt;));
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这块的内容相当多，首先需要解释一下上面的核心方法timeGetTime，官网的解释如下。&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;The timeGetTime function retrieves the system time, in milliseconds. The system time is the time elapsed since Windows was started.(检测系统启动后所经过的毫秒数)&lt;/p&gt;
&lt;p&gt;The return value wraps around to 0 every 2^32 milliseconds, which is about 49.71 days.(返回值会从0一直涨到2^32，然后又从0开始无限循环)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　上面的第二段表明了为什么要用那么复杂的处理，因为这个返回值不是无限变大，而是会重置为0。而且union这个东西也很有意思，JS里面找不到对比的数据类型，类似于struct结构体，但不同点是内存共用。拿源码中的union举例子，内存结构如下所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/858904/201905/858904-20190529024952101-2034520874.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　整个过程大概是这样的。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;每次获取timeGetTime的值，只获取头8位的值now_8。&lt;/li&gt;
&lt;li&gt;判断now_8是否小于union里面保存的last_8，如果小了(从1111...1111变成000...1)，说明时间重置了，将重置次数+1。&lt;/li&gt;
&lt;li&gt;替换last_8为新获取的now_8。&lt;/li&gt;
&lt;li&gt;判断当前整个整数是否与上一次获取时相同(涉及多线程操作)，相同的话直接返回输出结果。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　最后返回值的计算也很简单了，就是重置次数rollovers乘以重置一次的时间2^32，加上当前获取的now，得到总的硬件时间戳。&lt;/p&gt;

&lt;p&gt;　　完事了。&lt;/p&gt;
</description>
<pubDate>Tue, 28 May 2019 18:38:00 +0000</pubDate>
<dc:creator>书生小龙</dc:creator>
<og:description>这一篇讲windows系统下TimeTicks的实现。 对于tick，V8写了相当长的一段discussion来讨论windows系统上计数的三种实现方法以及各自的优劣，注释在time.cc的572行</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/QH-Jimmy/p/10940840.html</dc:identifier>
</item>
<item>
<title>百度地图JavaScript API获取用户当前经纬度并获取用户当前详细地理位置 - 追逐时光</title>
<link>http://www.cnblogs.com/Can-daydayup/p/10941470.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Can-daydayup/p/10941470.html</guid>
<description>&lt;h2&gt;前言：&lt;/h2&gt;
&lt;p&gt;　　前端时间刚好使用了百度地图的js api定位获取用户当前经纬度并获取当前详细位置的功能，为了方便下次找起来方便一些自己在这里记录一下，希望也能够帮助到有需要的童鞋们！&lt;/p&gt;
&lt;h2&gt;解决方案：&lt;/h2&gt;
&lt;h3&gt;一、引入JavaScript API v2.0 SDK&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&amp;lt;script type=&quot;text/javascript&quot; src=&quot;http://api.map.baidu.com/api?v=2.0&amp;amp;ak=您的密钥&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;二、在页面中定义一个以ID为allmap的DIV标签：&lt;/h3&gt;
&lt;p&gt;&amp;lt;div id=&quot;allmap&quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;p&gt;避免页面中出现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
Uncaught TypeError: Cannot read property 'gc' of undefined
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;三、通过SDK 辅助定位获取坐标，然后在获取当前用户详细地址&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&amp;lt;script type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/javascript&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &lt;span&gt;var&lt;/span&gt; map = &lt;span&gt;new&lt;/span&gt; BMap.Map(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;allmap&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建Map实例，注意页面中一定要有个id为allmp的div&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; point = &lt;span&gt;new&lt;/span&gt; BMap.Point(&lt;span&gt;116.331398&lt;/span&gt;,&lt;span&gt;39.897445&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建定坐标&lt;/span&gt;
    map.centerAndZoom(point,&lt;span&gt;12&lt;/span&gt;);&lt;span&gt;///&lt;/span&gt;&lt;span&gt;/ 初始化地图,设置中心点坐标和地图级别&lt;/span&gt;

    &lt;span&gt;var&lt;/span&gt; geolocation = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BMap.Geolocation();
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; gc = &lt;span&gt;new&lt;/span&gt; BMap.Geocoder();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建地理编码器
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 开启SDK辅助定位&lt;/span&gt;
&lt;span&gt;    geolocation.enableSDKLocation();
    geolocation.getCurrentPosition(function(r){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;.getStatus() ==&lt;span&gt; BMAP_STATUS_SUCCESS){
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; mk = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BMap.Marker(r.point);
            map.addOverlay(mk);
            map.panTo(r.point);
            alert(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;您的位置：&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + r.point.lng + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; +&lt;span&gt; r.point.lat);

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; pt =&lt;span&gt; r.point;   
            map.panTo(pt);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;移动地图中心点
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;alert(r.point.lng);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;X轴
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;alert(r.point.lat);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Y轴 &lt;/span&gt;
&lt;span&gt; 
            gc.getLocation(pt, function(rs){    
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; addComp =&lt;span&gt; rs.addressComponents;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;alert(addComp.city);&lt;/span&gt;
               alert(addComp.province + addComp.city + addComp.district + addComp.street +&lt;span&gt; addComp.streetNumber);    
            });  

        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            alert(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;failed&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;+&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getStatus());
        }        
    });
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;四、通过浏览器定位获取当前经纬度：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&amp;lt;script type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/javascript&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&lt;span&gt;var&lt;/span&gt; map = &lt;span&gt;new&lt;/span&gt; BMap.Map(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;allmap&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; point = &lt;span&gt;new&lt;/span&gt; BMap.Point(&lt;span&gt;116.331398&lt;/span&gt;,&lt;span&gt;39.897445&lt;/span&gt;&lt;span&gt;);
map.centerAndZoom(point,&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; geolocation = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BMap.Geolocation();
geolocation.getCurrentPosition(function(r){
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;.getStatus() ==&lt;span&gt; BMAP_STATUS_SUCCESS){
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; mk = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BMap.Marker(r.point);
        map.addOverlay(mk);
        map.panTo(r.point);
        alert(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;您的位置：&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;+r.point.lng+&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;+&lt;span&gt;r.point.lat);
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        alert(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;failed&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;+&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getStatus());
    }        
});
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;五、ip定位获取当前所在城市&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&amp;lt;script type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/javasript&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&lt;span&gt;var&lt;/span&gt; map = &lt;span&gt;new&lt;/span&gt; BMap.Map(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;allmap&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; point = &lt;span&gt;new&lt;/span&gt; BMap.Point(&lt;span&gt;116.331398&lt;/span&gt;,&lt;span&gt;39.897445&lt;/span&gt;&lt;span&gt;);
map.centerAndZoom(point,&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;&lt;span&gt;);

function myFun(result){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; cityName =&lt;span&gt; result.name;
    map.setCenter(cityName);
    alert(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;当前定位城市:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt;cityName);
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; myCity = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BMap.LocalCity();
myCity.&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;(myFun); 
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Tue, 28 May 2019 17:11:00 +0000</pubDate>
<dc:creator>追逐时光</dc:creator>
<og:description>前言： 前端时间刚好使用了百度地图的js api定位获取用户当前经纬度并获取当前详细位置的功能，为了方便下次找起来方便一些自己在这里记录一下，希望也能够帮助到有需要的童鞋们！ 解决方案： 一、引入Ja</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Can-daydayup/p/10941470.html</dc:identifier>
</item>
<item>
<title>软件架构之道的一次感悟 - 张泰峰</title>
<link>http://www.cnblogs.com/ztfjs/p/10941458.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ztfjs/p/10941458.html</guid>
<description>&lt;h2 id=&quot;w1&quot; class=&quot;wtitle&quot;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;2019悄悄溜走一半，无论是离别的忧愁，还是成长路途的艰辛，都在心中滚烫。&lt;/p&gt;
&lt;p&gt;距离上一篇文章已经很久了... 懒惰的博主不能将这一切归结于我的时间、我的规划、我的工作，只能怪自己懒......正所谓学如逆水行舟，不进则退，不进到最后就只能退了。&lt;/p&gt;
&lt;p&gt;今天突发一些关于架构的感悟，执笔记录下来。&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/893115/201905/893115-20190529005859071-757264673.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;w1&quot; class=&quot;wtitle&quot;&gt;&lt;strong&gt;软件架构的出发点&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;        软件架构是一个软件系统开发生命周期中最前端的部分，也是最关键、最核心的部分。它决定了后续代码的走向；能够决定项目的走向；有时候甚至能够决定一家公司的生死。软件架构的成功要素，有很多点，这些点的一两个或更多个，组成了不同级别的业务系统或用户系统：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;*1 可靠性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;*2  安全性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;*3 可伸缩性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;*4 可定制化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;*5 可扩展性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;*6 可维护性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;*7 用户体验&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;*8 可快速迭代性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       面向用户的系统，用户体验 、快速迭代、安全、可靠 ，这四点必不可少，这些点围绕着的基础的技术选型、管理模式、规则、流程，也就跟着对应的权重的不同去分配了。&lt;/p&gt;
&lt;p&gt;       假如公司A需要做一个工具app，xx计算器、或xx记事本。 想要获得市场认可，它的架构就需要大约 ： 30% 用户体验 、20%快速迭代、 10%可靠&lt;strong&gt;。&lt;/strong&gt;按照这个权重的分配去管理架构的技术选型、管理模式等等。一个工具app的安全性做的无懈可击，是不会得到市场认可的；一个电商网站的安全性可靠性不能保证，会被市场所抛弃。&lt;/p&gt;
&lt;p&gt;       又假如公司B有一个对内的管理系统，想要正确的结果，首先就得保证 可快速迭代性 ，业务每天都在变化，相反的用户体验、伸缩、安全、可靠，都可以相对不那么迫切。&lt;/p&gt;
&lt;p&gt;       通过&lt;strong&gt;可快速迭代性&lt;/strong&gt;迅速迭代&lt;strong&gt;可定制化需求&lt;/strong&gt;和&lt;strong&gt;可扩展性需求&lt;/strong&gt;提升了&lt;strong&gt;用户体验，&lt;/strong&gt;用户体验的提升带动用户量的增长，则对&lt;strong&gt;可靠性、可维护、安全性、可伸缩性&lt;/strong&gt;提出了更高的要求。&lt;/p&gt;
&lt;p&gt;       上面是我想要表达的，软件架构的出发点，是项目所处的市场的需求决定的。需求是什么，决定了架构是什么。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;        架构是难以更改的。&lt;/strong&gt;是的，架构是非常难以更改的，如果你的项目已经推出市场了，除非重头来过，承受彻底重构带来的阵痛。这里往往要面临更严峻的考验，例如人事处理：有很多c++开发，想要转java，或有很多php开发，想要转python；再例如架构的改弦更张势必要有加班的，埋头苦干一个月，再走一遍来时的路~&lt;/p&gt;
&lt;p&gt;        举个栗子：TDD ，TDD本质过程就是要贯穿从需求分析、设计、编码、测试、整个研发过程。它其实是需求驱动，逐个满足每个的需求。 TDD的核心就在于把需求分析,设计,质量控制量化的过程，在编写测试用例时就可以规避、重构、设计需求的架构。TDD其实就是一个以需求驱动的架构模式、开发模式。&lt;/p&gt;
&lt;p&gt;        或许你已经在做相关的架构处理了，或许你已经吃到了一些苦头，这个理论或许可以帮助你认识到，&lt;strong&gt;要根据市场需求来制定合适的架构，推导合适的架构细节&lt;/strong&gt;。要慎重。既不可以过度设计，也不可以设计不足，这把量尺是：市场需求。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/893115/201905/893115-20190529010035950-1737360160.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h2 id=&quot;w1&quot; class=&quot;wtitle&quot;&gt;&lt;strong&gt;架构&lt;/strong&gt;以人为本&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/893115/201905/893115-20190529005831980-81003864.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;     &lt;/strong&gt;&lt;/strong&gt;  架构设计必须要考虑人在其中的重要因素，合适的人做合适的事情。一个好的架构，首要的就是要考虑所在团队的人的情况，我们往往倾向于抓技术层架构，忽略了怎么将合适的人放到合适的位置，已有的团队人员能不能合理的在架构中发挥应该有的作用。&lt;/p&gt;
&lt;p&gt;        抽象的处理、框架的引进很重要的一点是，如何解决人员素质、想法、环境的不一致。框架通过封装复杂的东西，简化业务的复杂程度，让对应的人能够专注对应的事情。抽象通过可以被共同理解的概念，简化复杂的内部处理逻辑，将人的目标聚拢在一起。&lt;/p&gt;
&lt;p&gt;      软件架构应该以人为本，将最高效的人放在最高效的地方能够取得最大化的成果，架构设计也就必须考虑人的因素。&lt;/p&gt;
&lt;p&gt;      例如我们有一个5人团队做一个项目，团队成员比例大约是： 1个leader  ， 2 个核心， 2个实习，在设计这个项目的架构的时候，你必须要考虑的是，如何设计能把2个核心成员的力量放在合适的地方，如何设计能让2个实习成员能够完成既定的任务。 假如将2个核心与2个实习放在一起看待，过不了多久会出现一个情况，核心成员感觉做的东西技术含量太低，实习成员可能感觉东西难、累、赶，长此以往，项目会频繁面临人员变更。&lt;/p&gt;
&lt;p&gt;      我们倾向于集中精力做技术层架构，而不是人员层架构方面工作的主要原因，不是因为技术更重要，而是因为技术更容易做。人际交往是很复杂的，并且就效果而言从来都不会是很明晰和清楚的，但是它们比工作的任何其他方面都更重要。写代码并非只是写代码而已，而是与人有关——需要理解的东西包括那些人是谁，他们能作出什么贡献和需要什么东西，以及是多数派还是少数派等，诸如此类。“如果你把架构重点放一部分在人员安排的身上，那么就会发生更好的事情。&lt;/p&gt;
&lt;h2 id=&quot;w1&quot; class=&quot;wtitle&quot;&gt;&lt;strong&gt;从人的角度衍生出的信息的交互&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;       &lt;/strong&gt;信息的交互其实是软件开发过程中需要重点关注的事情。信息的完整性、真实性，影响着开发过程中风险的暴露。风险则决定了项目的成功与否，所以我认为它是架构其中的一部分，它常常被人忽略，因为它既不属于技术，也不属于人员，更像管理工作，但其实它也跟架构有明显的关系。&lt;/p&gt;
&lt;p&gt;       软件项目的风险无非体现在以下四个方面:需求、技术、成本和进度。任何信息的不对等都有可能导致需求完成有误、技术设计偏离、成本过大、进度延迟。怎么样规划合理的信息交互、制定合理的反馈机制是架构需要考虑的问题之一。&lt;/p&gt;

&lt;h2 id=&quot;w1&quot; class=&quot;wtitle&quot;&gt;&lt;strong&gt;总结和感悟&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;       &lt;/strong&gt;架构的目的是贴合市场需求指定合理的技术规划、人员规划、信息交互规划，架构是不仅仅局限于技术层面的。一个软件架构师，你需要统筹全局，深入了解需求，了解业务的走向，了解技术的价值所在。也需要制定或迎合人员的搭配，制定信息交互的流程。&lt;/p&gt;
&lt;p&gt;       这是我现阶段比较深刻的感悟，执笔记录，也是最近吃的教训的结果。我的观点不一定正确，感谢大家观看，如有疑问，欢迎留言。&lt;/p&gt;
</description>
<pubDate>Tue, 28 May 2019 17:02:00 +0000</pubDate>
<dc:creator>张泰峰</dc:creator>
<og:description>写在前面 2019悄悄溜走一半，无论是离别的忧愁，还是成长路途的艰辛，都在心中滚烫。 距离上一篇文章已经很久了... 懒惰的博主不能将这一切归结于我的时间、我的规划、我的工作，只能怪自己懒......</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ztfjs/p/10941458.html</dc:identifier>
</item>
<item>
<title>Aura Component Skills &amp; Tools - zero.zhang</title>
<link>http://www.cnblogs.com/zero-zyq/p/10935506.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zero-zyq/p/10935506.html</guid>
<description>&lt;p&gt;本篇参考： &lt;a href=&quot;https://trailhead.salesforce.com/content/learn/modules/lex_dev_lc_vf_fundamentals&quot;&gt;https://trailhead.salesforce.com/content/learn/modules/lex_dev_lc_vf_fundamentals&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; 不知不觉已经做了三年多的salesforce，大部分项目还是以classic为主，但是以后的salesforce的市场毕竟属于lightning，所以对lightning的学习也没法停止。因为做的lightning的项目不多，所以大部分的实践经验可能还要依托于trailhead。做或者学lightning的时候其实很多人都会发现，lightning和classic针对前台的交互真的相差蛮多的，它会要求你更多的javascript的知识，更多css以及DOM理解的知识。诚然以前的项目都会用到javascript以及CSS相关的UI处理，但是学的总是一知半解，从来没有系统性的读过一本书或者看过一个完整的教程，基本上就是了解一个大概，后期用到哪百度谷歌，倒是也不耽误开发。然而学习lightning的时候发现，如果对javascript以及CSS还是抱着之前的态度去学习，确实会变得越来越累，因为lightning很多的前台的框架机制以及写法确实好多都借鉴了javascript。所以在避免盲目学习，学玩就忘的前提下，翻了一些trailhead以后，安利一下官方提供的这个lightning aura框架下的基础学习。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一. JavaScript的学习&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Javascript对于开发人员来说不会是不可能的，但是深入学习的可能并不太多，Null, Undefined , NaN区别；基础类型以及非基础类型都包括哪些内容，有哪些具体的区别以及常用方法；严格等于(===)和常规等于区别(==)以及哪种场景下应该优先考虑哪种写法，javascript对于事件的处理机制；同步以及异步的用处场景；handler call的机制以及best practice等等。太多太多我们在项目中常用的但是总是会模糊和混淆的，所以兵欲善其事，必先利其器。想要学好lightning提供的aura框架开发也好，LWC开发也好，先将自己的javascript基础夯实起来才是王道。这里官方推荐了好几个优秀的书籍，其中有两个可以在线观看。其中 Speaking JavaScript适合0基础或者有基础但是基础薄弱的人，真正耐心读下来确实受益匪浅，锻炼了英语也夯实了javascript的基础知识。惭愧的是我目前只是浅显的读了一遍，权当抛砖引玉。&lt;/p&gt;
&lt;p&gt;Speaking JavaScript :  &lt;a href=&quot;http://speakingjs.com/es5/index.html&quot;&gt;http://speakingjs.com/es5/index.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Eloquent JavaScript ： &lt;a href=&quot;http://eloquentjavascript.net/&quot;&gt;http://eloquentjavascript.net/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二. HTML、CSS以及LDS学习&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;HTML、CSS是一个必须要打好基础的东西，往小了说好多标签的转义影响了javascript针对form中或者html中使用的不同方式取值，往大了说影响到你对DOM结构深层次的理解。所以建议有时间的小伙伴还是最好先多多了解一些HTML的基础以及CSS的深入使用。&lt;/p&gt;
&lt;p&gt;说到lighting，自然会说到官方提供的强大的LDS：&lt;a href=&quot;https://www.lightningdesignsystem.com/&quot;&gt;https://www.lightningdesignsystem.com/&lt;/a&gt; 包括了官方封装好的常用的标签的 html/css的实现以及各种适配的css样式库和一些icon等。曾经学习lightning看到这些大量的封装好的库文件确实很头疼，读起来也很费劲，也不太清楚学习的方向，基本上会用标签会查文档就好了。后来基本上用到哪个lightning封装好的标签便会看一下这个对应的html/css实现，多读多看，时间长了对于提升css能力还是有很大帮助的，感兴趣的小伙伴可以尝试。当然，因为做lightning项目比较少，有更加高效或者更加深入学习的方式，还请这方面的前辈多多指教。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三. 针对Aura 框架下的学习&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Aura框架的入门其实还是很容易的，官方提供了很多的trailhead用来学习：其中 &lt;a href=&quot;https://trailhead.salesforce.com/content/learn/modules/lex_dev_lc_basics?trail_id=lex_dev&quot;&gt;https://trailhead.salesforce.com/content/learn/modules/lex_dev_lc_basics?trail_id=lex_dev&lt;/a&gt; 基本上这个trailhead涵盖了简单的lightning的组件开发的基础东西，剩下的就要看多读官方的文档，aura框架就可以入门了。当然，看trailhead学到的永远是浅显的东西，真正的深入最好还是做项目。项目中至少在规范性以及实用性会让你学到很多东西，而且经历了坑，才会知道哪些坑是你不能再踩得，自主学习学到的永远是理想状态下的皮毛而已了。所以没做过lightning的小伙伴，快快找个lightning项目实施吧。共勉，加油。&lt;/p&gt;
</description>
<pubDate>Tue, 28 May 2019 16:17:00 +0000</pubDate>
<dc:creator>zero.zhang</dc:creator>
<og:description>本篇参考： https://trailhead.salesforce.com/content/learn/modules/lex_dev_lc_vf_fundamentals 不知不觉已经做</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zero-zyq/p/10935506.html</dc:identifier>
</item>
<item>
<title>net core 的Generic Host 之Generic Host Builder - BruceTian(晓青)</title>
<link>http://www.cnblogs.com/blue-tian/p/10941235.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/blue-tian/p/10941235.html</guid>
<description>&lt;p&gt;通用Host(Generic Host) 与 web Host 不同的地方就是通用Host解耦了Http请求管道，使得通用Host拥有更广的应用场景。比如：消息收发、后台任务以及其他非http的工作负载。这些场景都可以通过使用通用Host拥有横切（Cross-cutting）的能力，比如：配置、依赖注入和日志记录。&lt;br/&gt;***&lt;/p&gt;

&lt;p&gt;Asp net core 2.1版本推出了Generic Host Builder，但它仅仅用在了非http工作负载的场景，Generic Host Builder会在2019年发布的3.0版本中替换掉Web Host Builder。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.bluetian.net/2019/05/18/generichost/a.png&quot; alt=&quot;avatar&quot;/&gt;&lt;/p&gt;

&lt;p&gt;asp net core 2.1没有使用Generic Host Builder，那么它的使用场景是什么呢？Generic Host Builder的在非http负载的使用场景有消息收发、后台任务等。&lt;br/&gt;HostBuilder位于 Microsoft.Extensions.Hosting 命名空间下，实现了IHostBUilder接口。Net core 应用在Main()中最简单的用法如下：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public static async Task Main(string[] args)
{
   var host = new HostBuilder()
      .Build(); 

   await host.RunAsync();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Build()方法是初始化host实例，它仅仅能被调用一次，在Build()方法执行前调用ConfigureServices()方法可以用来配置host。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;var host = new HostBuilder()
   .ConfigureServices((hostContext, services) =&amp;gt;
   {
      services.Configure&amp;lt;HostOptions&amp;gt;(option =&amp;gt;
      {
         // option.SomeProperty = ...
      });
   })
   .Build();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ConfigureServices((hostContext, services) 方法有一个HostBuilderContext参数和一个依赖注入的IServiceCollection参数。你也可以通过调用Configure()设置Host的其他设置，当前HostOptions对象只有一个Shutdown Timeout 属性。&lt;br/&gt;你可以在&lt;a href=&quot;https://github.com/aspnet/Docs/blob/master/aspnetcore/fundamentals/host/generic-host/samples/2.x/GenericHostSample/Program.cs&quot;&gt;官方示例&lt;/a&gt;看到更多的配置，下面是一个其中的代码片段：&lt;/p&gt;
&lt;p&gt;Host 配置部分&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;.ConfigureHostConfiguration(configHost =&amp;gt;
{
   configHost.SetBasePath(Directory.GetCurrentDirectory());
   configHost.AddJsonFile(&quot;hostsettings.json&quot;, optional: true);
   configHost.AddEnvironmentVariables(prefix: &quot;PREFIX_&quot;);
   configHost.AddCommandLine(args);
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;应用配置部分&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;.ConfigureAppConfiguration((hostContext, configApp) =&amp;gt;
{
   configApp.AddJsonFile(&quot;appsettings.json&quot;, optional: true);
   configApp.AddJsonFile(
      $&quot;appsettings.{hostContext.HostingEnvironment.EnvironmentName}.json&quot;, 
      optional: true);
   configApp.AddEnvironmentVariables(prefix: &quot;PREFIX_&quot;);
   configApp.AddCommandLine(args);
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;依赖注入代码&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;.ConfigureServices((hostContext, services) =&amp;gt;
{
   services.AddHostedService&amp;lt;LifetimeEventsHostedService&amp;gt;();
   services.AddHostedService&amp;lt;TimedHostedService&amp;gt;();
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;日志配置代码&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;.ConfigureLogging((hostContext, configLogging) =&amp;gt;
{
   configLogging.AddConsole();
   configLogging.AddDebug();
})&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;Asp net core 3.0 中使用Generic Host Builder 替换 Web Host Builder，net core 3.0 web 应用在Main函数中简单的使用方式代码如下：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public static void Main(string[] args)
{
   CreateHostBuilder(args)
      .Build()
      .Run();
}

public static IHostBuilder CreateHostBuilder(string[] args) =&amp;gt;
   Host.CreateDefaultBuilder(args)
      ConfigureWebHostDefaults(webBuilder =&amp;gt;
      {
         webBuilder.UseStartup&amp;lt;Startup&amp;gt;();
      });&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.0版本中的CreateHostBuilder方法与2.x版本的 CreateWebHostBuilder() 方法很相似，二者最大的不同就是WebHost.CreateDefaultBuilder() 被替换成 Host.CreateDefaultBuilder()，&lt;br/&gt;还有一个不同的地方就是 Host.CreateDefaultBuilder()方法，因为新版本的host builder是一个通用的host builder，这样就要通过嗲用 CreateDefaultBuilder()方法来构建一个web app host。&lt;/p&gt;

&lt;p&gt;未来我们需要知道：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;WebHostBuilder在未来将会被弃用&lt;/li&gt;
&lt;li&gt;IWebHostBuilder接口将会被保留&lt;/li&gt;
&lt;li&gt;你不能在Startup类里面注入任何服务，IHostingEnvironment and IConfiguration除外&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/generic-host?view=aspnetcore-3.0&quot;&gt;官方文档&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://wakeupandcode.com/generic-host-builder-in-asp-net-core/&quot;&gt;Generic Host Builder in ASP .NET Core&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1324407/201905/1324407-20190529000133976-1481183239.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 28 May 2019 16:07:00 +0000</pubDate>
<dc:creator>BruceTian(晓青)</dc:creator>
<og:description>前言 通用Host(Generic Host) 与 web Host 不同的地方就是通用Host解耦了Http请求管道，使得通用Host拥有更广的应用场景。比如：消息收发、后台任务以及其他非http的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/blue-tian/p/10941235.html</dc:identifier>
</item>
<item>
<title>浅谈堆-Heap（一） - 小-欢-欢</title>
<link>http://www.cnblogs.com/blentle/p/10941119.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/blentle/p/10941119.html</guid>
<description>&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;应用场景和前置知识复习&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;排序我们都很熟悉，如冒泡排序、选择排序、希尔排序、归并排序、快速排序等，其实堆也可以用来排序，严格来说这里所说的堆是一种数据结构，排序知识它的应用场景之一&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;+&quot;&gt;&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Top N的求解&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;优先队列&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;堆得另一个重要的应用场景就是优先队列&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;我们知道普通队列是：先进先出&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;而 优先队列：出队顺序和入队顺序无关；和优先级相关&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;实际生活中有很多优先队列的场景，如医院看病，急诊病人是最优先的,虽然这一类病人可能比普通病人到的晚，但是他们可能随时有生命危险，需要及时进行治疗. 再比如 操作系统要&quot;同时&quot;执行多个任务，实际上现代操作系统都会将CPU的执行周期划分成非常小的时间片段，每个时间片段只能执行一个任务，究竟要执行哪个任务，是有每个任务的优先级决定的.每个任务都有一个优先级.操作系统动态的每一次选择一个优先级最高的任务执行.要让操作系统动态的选择优先级最高的任务去执行，就需要维护一个优先队列，也就是说所有任务都会进入这个优先队列.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;基本实现&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;首先堆是一颗二叉树，这个二叉树必须满足两个两条件&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;ol-list&quot; start=&quot;&quot; readability=&quot;1&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;2&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;这个二叉树必须是一颗完全二叉树，所谓完全二叉树就是除了最后一层外，其他层的节点的个数必须是最大值，且最后一层的节点都必须集中在左侧.即最后一层从左往右数节点必须是紧挨着的，不能是中间空出一个，右边还有兄弟节点.&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;这个二叉树必须满足 左右子树的节点值必须小于或等于自身的值（大顶堆） 或者 左右子树的节点值必须大于或等于自身的值(小顶堆)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;下图分别是一个大顶堆和小顶堆的示例&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/700414/201905/700414-20190528230753899-1043600200.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;看到这两颗二叉树，我们首先就能定义出树节点的结构：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;Class Node {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;节点本身的值&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Object value;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Node left;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Node right;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    ....getter and setter
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     
&lt;span&gt;11&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;但是这里我们利用完全二叉树的性质用数组来构建这棵树.先从上到下，自左至右的来给树的每一个节点编上号.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;以大顶堆为例&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/700414/201905/700414-20190528230937422-1308709609.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;标上编号后，我们发现每个节点的左子节点(如果存在)的序号都是其自身的2倍，右子节点(如果存在)的序号是其自身的2倍加1. 相反，如果已知某个节点的序号，父节点的序号是其自身的二分之一(计算机中整型相除，舍弃余数)&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;下面来用代码构建一个堆得骨骼&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('d2dbbd7c-76fe-4b3d-8a7a-539694b202d6')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_d2dbbd7c-76fe-4b3d-8a7a-539694b202d6&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_d2dbbd7c-76fe-4b3d-8a7a-539694b202d6&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('d2dbbd7c-76fe-4b3d-8a7a-539694b202d6',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_d2dbbd7c-76fe-4b3d-8a7a-539694b202d6&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MaxHeap {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     * 堆中有多少元素
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; count;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;     * 存放堆数据的数组
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Object[] data;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; MaxHeap(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; capacity) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;         * 因为序号是从1 开始的，我们不用下标是0的这个位置的数
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.data = &lt;span&gt;new&lt;/span&gt; Object[capacity + 1&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;     * 返回堆中有多少数据
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size()  {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; count;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;     * 堆是否还有元素
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isEmpty() {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; count == 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     
&lt;span&gt;37&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;骨骼是构建好了，乍一看堆中存放的数据是一个object类型的数据, 父子节点按节点值 无法比较，这里再调整一下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MaxHeap&amp;lt;T &lt;span&gt;extends&lt;/span&gt; Comparable&amp;lt;T&amp;gt;&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     * 堆中有多少元素
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; count;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;     * 存放堆数据的数组
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; T[] data;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; clazz 堆里放的元素的类型
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; capacity  堆的容量
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; MaxHeap(Class&amp;lt;T&amp;gt; clazz, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; capacity) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;         * 因为序号是从1 开始的，我们不用下标是0的这个位置的数
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.data = (T[]) Array.newInstance(clazz, capacity + 1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;     * 返回堆中有多少数据
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size() {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; count;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;     * 堆是否还有元素
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isEmpty() {
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; count == 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; 
&lt;span&gt;42&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; T[] getData() {
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; data;
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样骨架算是相对完好了，下面实现向堆中添加数据的过程,首先我们先把上面的二叉树的形式按标号映射成数组的形式如图对比(已经说了0号下标暂时不用)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/700414/201905/700414-20190528231154344-680307708.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;现在这个大顶堆被映射成数组，所以向堆中插入元素，相当于给数组添加元素，这里我们规定每新插入一个元素就插在当前数组最后面，也即数组最大标 + 1的位置处.对于一颗完全二叉树来说就是插在最后一层的靠左处，如果当前二叉树是一颗满二叉树，则新开辟一层，插在最后一层最左侧.但是这样插入有可能破坏堆的性质. 如插入节点45&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/700414/201905/700414-20190528231232559-1062605216.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;插入新节点后已经破坏了大顶堆的性质，因为45比父节点17大, 这里我们只要把新插入的节点45和父节点17 交换，类似依次比较与父节点的大小做交换即可&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;第一次交换:&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/700414/201905/700414-20190528231303945-1506002520.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;第二次交换:&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/700414/201905/700414-20190528231343274-548580213.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;这里我们发现经过两次交换，已经满足了堆的性质,这样我们就完成了一次插入,这个过程，我们发现待插入的元素至底向顶依次向树根上升，我们给这个过程起个名叫shiftUp,用代码实现便是:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;     * 插入元素t到堆中
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; t
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; insert(T t) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;把这个元素插入到数组的尾部,这时堆的性质可能被破坏&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         data[count + 1] =&lt;span&gt; t;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;插入一个元素，元素的个数增加1&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         count++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;移动数据,进行shiftUp操作,修正堆&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        shiftUp(count);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; shiftUp(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; (index &amp;gt; 1 &amp;amp;&amp;amp; ((data[index].compareTo(data[index &amp;gt;&amp;gt; 1]) &amp;gt; 0&lt;span&gt;))) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             swap(index, index &amp;gt;&amp;gt;&amp;gt; 1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             index &amp;gt;&amp;gt;&amp;gt;= 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;     * 这里使用引用交换，防止基本类型值传递
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; index1
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; index2
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; swap(&lt;span&gt;int&lt;/span&gt; index1, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; index2) {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         T tmp =&lt;span&gt; data[index1];
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         data[index1] =&lt;span&gt; data[index2];
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         data[index2] =&lt;span&gt; tmp;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里有一个隐藏的问题，初始化我们指定了存放数据数组的大小，随着数据不断的添加，总会有数组越界的这一天.具体体现在以上代码 data[count + 1] = t 这一行&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;    &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;     * 插入元素t到堆中
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; t
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; insert(T t) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;把这个元素插入到数组的尾部,这时堆的性质可能被破坏&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         data[count + 1] = t;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这一行会引发数组越界异常
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;插入一个元素，元素的个数增加1&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         count++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;移动数据,进行shiftUp操作,修正堆&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        shiftUp(count);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们可以考虑在插入之前判断一下容量,所以声明一个成员变量,在实例初始化时，初始化这个capacity&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; capacity;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;构造方法变成:&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; clazz 堆里放的元素的类型
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; capacity  堆的容量
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; MaxHeap(Class&amp;lt;T&amp;gt; clazz, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; capacity) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;         * 因为序号是从1 开始的，我们不用下标是0的这个位置的数
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.data = (T[]) Array.newInstance(clazz, capacity + 1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.capacity =&lt;span&gt; capacity;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;     * 插入元素t到堆中
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; t
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; insert(T t) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;插入的方法加入容量限制判断&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(count + 1 &amp;gt;&lt;span&gt; capacity)
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IndexOutOfBoundsException(&quot;can't insert a new element...&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;把这个元素插入到数组的尾部,这时堆的性质可能被破坏&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;         data[count + 1] = t;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这一行会引发数组越界异常
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;插入一个元素，元素的个数增加1&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;         count++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;移动数据,进行shiftUp操作,修正堆&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;        shiftUp(count);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;至此，整个大顶堆的插入已经还算完美了，来一波儿数据测试一下，应该不是问题&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;可能上面插入时我们看到有shiftUp这个操作，可能会想到从堆中删除元素是不是shiftDown这个操作. 没错就是shiftDown,只不过是删除堆中元素只能删除根节点元素，对于大顶堆也就是剔除最大的元素.下面我们用图说明一下.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/700414/201905/700414-20190528231750405-1657101035.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;删除掉根节点，那根节点的元素由谁来补呢. 简单，直接剁掉原来数组中最后一个元素，也就是大顶堆中最后一层最后一个元素,摘了补给根节点即可,相应的堆中元素的个数要减一&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/700414/201905/700414-20190528231815968-948292176.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;最终我们删除了大顶堆中最大的元素，也就是根节点,堆中序号最大的元素变成了根节点.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/700414/201905/700414-20190528231846048-408152744.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;此时整个堆不满足大顶堆的性质,因为根节点17比其子节点小，这时，shiftDown就管用了，只需要把自身与子节点交换即可，可是子节点有两个，与哪个交换呢，如果和右子节点30交换，30变成父节点，比左子节点45小，还是不满足大顶堆的性质.所以应该依次与左子节点最大的那个交换，直至父节点比子节点大才可.所以剔除后新被替换的根节点依次下沉，所以这个过程被称为shiftDown，最终变成&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/700414/201905/700414-20190528231915209-2008272600.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;所以移除z最大元素的方法实现:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;     * 弹出最大的元素并返回
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; T popMax() {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (count &amp;lt;= 0&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IndexOutOfBoundsException(&quot;empty heap&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         T max = data[1&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;把最后一个元素补给根节点&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         swap(1&lt;span&gt;, count);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;补完后元素个数减一&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;         count--&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;下沉操作&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;         shiftDown(1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; max;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;     * 下沉
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; index
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; shiftDown(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index) {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;只要这个index对应的节点有左子节点(完全二叉树中不存在 一个节点只有 右子节点没有左子节点)&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; (count &amp;gt;= (index &amp;lt;&amp;lt; 1&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;比较左右节点谁大，当前节点跟谁换位置
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;左子节点的inedx&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; left = index &amp;lt;&amp;lt; 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;右子节点则是&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; right = left + 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果右子节点存在,且右子节点比左子节点大,则当前节点与右子节点交换&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (right &amp;lt;=&lt;span&gt; count) {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;有右子节点&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; ((data[left].compareTo(data[right]) &amp;lt; 0&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;左子节点比右子节点小,且节点值比右子节点小&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (data[index].compareTo(data[right]) &amp;lt; 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;                        swap(index, right);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;                         index =&lt;span&gt; right;
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;                     } &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt;                         &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; 
&lt;span&gt;43&lt;/span&gt;                 } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;左子节点比右子节点大&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (data[index].compareTo(data[left]) &amp;lt; 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;                        swap(index, left);
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;                         index =&lt;span&gt; left;
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;                     } &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;49&lt;/span&gt;                         &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;右子节点不存在,只有左子节点&lt;/span&gt;
&lt;span&gt;53&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (data[index].compareTo(data[left]) &amp;lt; 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;                    swap(index, left);
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;                     index =&lt;span&gt; left;
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;                 } &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;57&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;index 的值大于左子节点，终止循环&lt;/span&gt;
&lt;span&gt;58&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;至此，大顶堆的插入和删除最大元素就都实现完了.来写个测试&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('a1e2520d-1a8e-4f36-92dc-16cb7a5b4013')&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_a1e2520d-1a8e-4f36-92dc-16cb7a5b4013&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_a1e2520d-1a8e-4f36-92dc-16cb7a5b4013&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('a1e2520d-1a8e-4f36-92dc-16cb7a5b4013',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_a1e2520d-1a8e-4f36-92dc-16cb7a5b4013&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         MaxHeap&amp;lt;Integer&amp;gt; mh = &lt;span&gt;new&lt;/span&gt; MaxHeap&amp;lt;Integer&amp;gt;(Integer.&lt;span&gt;class&lt;/span&gt;, 12&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         mh.insert(66&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         mh.insert(44&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         mh.insert(30&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         mh.insert(27&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         mh.insert(17&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         mh.insert(25&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         mh.insert(13&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         mh.insert(19&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         mh.insert(11&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         mh.insert(8&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         mh.insert(45&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         Integer[] data =&lt;span&gt; mh.getData();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 1 ; i &amp;lt;= mh.count ; i++&lt;span&gt; ) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             System.err.print(data[i] + &quot; &quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        mh.popMax();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 1 ; i &amp;lt;= mh.count ; i++&lt;span&gt; ) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             System.err.print(data[i] + &quot; &quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;嗯，还不错，结果跟上面图上对应的数组一样.结果倒是期望的一样，但总感觉上面的shiftDown的代码比shiftUp的代码要多几倍，而且看着很多类似一样的重复的代码, 看着难受.于是乎想个办法优化一下. 对我这种强迫症来说，不干这件事，晚上老是睡不着觉.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;思路: 上面我们不断的循环条件是这个index对应的节点有子节点.如果节点堆的性质破坏，最终是要用这个值与其左子节点或者右子节点的值交换，所以我们计算出了左子节点和右子节点的序号.其实不然，我们定义一个抽象的最终要和父节点交换的变量，这个变量可能是左子节点，也可能是右子节点，初始化成左子节点的序号，只有在其左子节点的值小于右子节点，且父节点的值也左子节点,父节点才可能与右子节点，这时让其这个交换的变量加1变成右子节点的序号即可，其他情况则要么和左子节点交换，要么不作交换，跳出循环,所以shiftDown简化成：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;    &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;     * 下沉
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; index
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; shiftDown(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;只要这个index对应的节点有左子节点(完全二叉树中不存在 一个节点只有 右子节点没有左子节点)&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; (count &amp;gt;= (index &amp;lt;&amp;lt; 1&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;比较左右节点谁大，当前节点跟谁换位置
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;左子节点的inedx&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; left = index &amp;lt;&amp;lt; 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;data[index]预交换的index的序号&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; t =&lt;span&gt; left;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果右子节点存在,且右子节点比左子节点大,则当前节点可能与右子节点交换&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (((t + 1) &amp;lt;= count) &amp;amp;&amp;amp; (data[t].compareTo(data[t + 1]) &amp;lt; 0&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 t += 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果index序号节点比t序号的节点小，才交换,否则什么也不作, 退出循环&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(data[index].compareTo(data[t]) &amp;gt;= 0&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;            swap(index, t);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             index =&lt;span&gt; t;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;嗯，还不错，这下完美了.简单多了.其他还有待优化的地方留在下篇讨论&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h3&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;+&quot; readability=&quot;2.5&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;首先复习了堆的应用场景，具体的应用场景代码实现留在下一篇.&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;引入堆的概念，性质和大顶堆，小顶堆的概念,实现了大顶堆的元素添加和弹出&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;根据堆的性质和弹出时下沉的规律，优化下沉方法代码.&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item md-focus-container&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;下一篇优化堆的构建，用代码实现其应用场景，如排序， topN问题，优先队列等并引入其他的堆分析及其与普通堆的性能差异&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;md-end-block md-focus&quot;&gt; &lt;/p&gt;
</description>
<pubDate>Tue, 28 May 2019 15:30:00 +0000</pubDate>
<dc:creator>小-欢-欢</dc:creator>
<og:description>应用场景和前置知识复习 堆排序 堆排序 排序我们都很熟悉，如冒泡排序、选择排序、希尔排序、归并排序、快速排序等，其实堆也可以用来排序，严格来说这里所说的堆是一种数据结构，排序知识它的应用场景之一 To</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/blentle/p/10941119.html</dc:identifier>
</item>
<item>
<title>算法导论课后习题解答 第一部分 练习1.1-1-&gt;1.1-5 - godoforange</title>
<link>http://www.cnblogs.com/godoforange/p/10940674.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/godoforange/p/10940674.html</guid>
<description>&lt;p&gt;很高兴能和大家一起共同学习算法导论这本书。笔者将在业余时间把算法导论后面的题解以博文的形式展现出来希望能得到大家的支持谢谢。如果有可能我会做一些教学视频免费的供大家观看。&lt;/p&gt;
&lt;p&gt;练习题选自算法导论中文第三版第6页中的练习。&lt;/p&gt;
&lt;h2&gt;1.1-1 给出现实生活中需要&lt;span&gt;排序&lt;/span&gt;的一个例子或者现实生活中需要&lt;span&gt;计算凸壳&lt;/span&gt;的一个例子。&lt;/h2&gt;
&lt;p&gt;这个问题有俩个子问题。我一一解答：&lt;/p&gt;
&lt;p&gt;(1) 首先是排序，日常需要排序的地方很多，例如今日微博热搜等等这个不用细说了。&lt;/p&gt;
&lt;p&gt;(2)但是关于第二个问题我需要多写一点。&lt;/p&gt;
&lt;p&gt;第一这本书的&lt;span&gt;翻译的地方有误&lt;/span&gt;，凸壳在这里指的是计算几何中的多边形凸包问题。&lt;/p&gt;
&lt;p&gt;下面摘选自百度百科。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
⒈对于一个集合D，D中任意有限个点的凸组合的全体称为D的凸包。
⒉对于一个集合D，所有包含D的凸集之交称为D的凸包。
可以证明，上述两种定义是等价的
概念
示例图（一）
示例图（一）
1 　点集Q的凸包（convex hull）是指一个最小凸多边形，满足Q中的点或者在多边形边上或者在其内。右图中由红色线段表示的多边形就是点集Q={p0,p1,...p12}的凸包。
2 　一组平面上的点，求一个包含所有点的最小的凸多边形，这就是凸包问题了。这可以形象地想成这样：在地上放置一些不可移动的木桩，用一根绳子把他们尽量紧地圈起来，并且为凸边形，这就是凸包了。
数学定义：设S为欧几里得空间  的任意子集。包含S的最小凸集称为S的凸包，记作conv(S)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1590876/201905/1590876-20190528221131266-1419770736.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 凸包问题在实际中的应用很广泛，它可以应用于冶金术、城市规划、图像处理、统计学等等多个领域。&lt;/p&gt;
&lt;h2&gt;1.1-2 除速度外，在真实环境中还可能使用哪些其他有关效率的量度？&lt;/h2&gt;
&lt;p&gt;学过高中物理的都知道有功率吧。实际生产中还有开发效率，生产效率。&lt;/p&gt;
&lt;p&gt;别的笔者暂时也想不出来。&lt;/p&gt;
&lt;h2&gt;1.1-3 选择一种你以前&lt;span&gt;已知的数据结构&lt;/span&gt;并讨论其优势和局限。&lt;/h2&gt;
&lt;p&gt;笔者在这里列举一个图的数据结构-------邻接矩阵。并以PAT练习平台中的某一道题来举例子。&lt;/p&gt;
&lt;p&gt;首先介绍一下邻接矩阵：（图画的不咋好请谅解）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1590876/201905/1590876-20190528224434574-1004524156.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这里 我们完全可以用一个矩阵来将右边的无向图的节点和节点之间的关系完美的表现出来，但是当我们的节点过多，而关系少的时候，这个邻接矩阵就显得过于臃肿了，所以我们可以总结出以下俩点：&lt;/p&gt;
&lt;p&gt;1）邻接矩阵的优势在于描述通俗易懂，算法实现起来简单，在稠密矩阵中效率依然很高。&lt;/p&gt;
&lt;p&gt;2）邻接矩阵的局限性在于在处理的节点过多的时候（即稀疏矩阵），无论是时间复杂度还是空间复杂度均过高。&lt;/p&gt;
&lt;p&gt;下面这道题是一道练手的简单题，有兴趣的朋友可以去做一下来感受一下邻接矩阵和稀疏矩阵的不同。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/problems/994805514284679168&quot; target=&quot;_blank&quot;&gt;题目链接：&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1590876/201905/1590876-20190528223558537-2026251944.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这道题如果你认真的去做了，你就会发现。虽然邻接矩阵无论是在算法实现上还是结构都很简单，但是无论如何也不能避免他在遍历的时候的时间复杂度过高，（一般都是O^2级别）。&lt;/p&gt;
&lt;p&gt;因此一般在处理稀疏矩阵的时候，我们一般选择邻接表的实现方法去替代邻接矩阵的实现方法。&lt;/p&gt;
&lt;h2&gt; 1.1-4 前面给出的最短路径与旅行商问题有哪些相似之处又有哪些不同？&lt;/h2&gt;
&lt;p&gt;旅行商问题简而言之就是选出所有可能的候选路径，而非最短路径。&lt;/p&gt;
&lt;p&gt;它们是相似的，因为每个人都必须走一个图并在其中找到一条路径。&lt;/p&gt;
&lt;p&gt;他们又是不同的，最短路径仅需要两点之间的路径，而旅行推销员需要在返回第一点的更多点之间的路径。&lt;/p&gt;
&lt;p&gt;至于如何寻找最短路径最简单的方法就是进行BFS（宽度优先遍历）。&lt;/p&gt;
&lt;p&gt;下面是摘取百度百科的介绍&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
已知图G=&lt;span&gt;(V,E)和一个源顶点s，宽度优先搜索以一种系统的方式探寻G的边，从而“发现”s所能到达的所有顶点，并计算s到所有这些顶点的距离(最少边数)，该算法同时能生成一棵根为s且包括所有可达顶点的宽度优先树。对从s可达的任意顶点v，宽度优先树中从s到v的路径对应于图G中从s到v的最短路径，即包含最小边数的路径。该算法对有向图和无向图同样适用。
之所以称之为宽度优先算法，是因为算法自始至终一直通过已找到和未找到顶点之间的边界向外扩展，就是说，算法首先搜索和s距离为k的所有顶点，然后再去搜索和S距离为k&lt;/span&gt;+l的其他顶点。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通俗点说，就是在每一次遍历的时候，将每个子节点放入一个队列中，然后再不断递归以此寻找最短路径。&lt;/p&gt;
&lt;p&gt;对于最短路径的寻找方法还有俩种最经典的。&lt;/p&gt;
&lt;div readability=&quot;16.5&quot;&gt;
&lt;div readability=&quot;28&quot;&gt;
&lt;h4&gt;1）Dijkstra（迪杰斯特拉）算法&lt;/h4&gt;
&lt;p&gt;他的算法思想是按路径长度递增的次序一步一步并入来求取，是贪心算法的一个应用，用来解决单源点到其余顶点的最短路径问题。&lt;/p&gt;
&lt;h4&gt;算法思想&lt;/h4&gt;
&lt;p&gt;首先，我们引入一个辅助向量D，它的每个分量D[i]表示当前找到的从起始节点v到终点节点vi的最短路径的长度。它的初始态为：若从节点v到节点vi有弧，则D[i]为弧上的权值，否则D[i]为∞，显然，长度为&lt;strong&gt;D[j] = Min{D[i] | vi ∈V}&lt;/strong&gt;的路径就是从v出发最短的一条路径，路径为(v, vi)。&lt;br/&gt;那么，下一条长度次短的最短路径是哪一条呢？假设次短路径的终点是vk，则可想而知，这条路径或者是(v, vk)或者是(v, vj, vk)。它的长度或者是从v到vk的弧上的权值，或者是D[j]和从vj到vk的权值之和。&lt;/p&gt;
&lt;p&gt;一般情况下，假设S为已知求得的最短路径的终点集合，则可证明：一下条最短路径（设其终点为x）或者是弧(v, x)或者是中间只经过S中的顶点而最后到达顶点x的路径。这可用反证法来证明，假设此路径上有一个顶点不在S中，则说明存在一条终点不在S中而长度比此路径短的路径。但是这是不可能的。因为，我们是按路径常度的递增次序来产生个最短路径的，故长度比此路径端的所有路径均已产生，他们的终点必定在S集合中，即假设不成立。&lt;/p&gt;
&lt;p&gt;因此下一条次短的最短路径的长度是：&lt;strong&gt;D[j] = Min{D[i] | vi ∈ V - S}&lt;/strong&gt;，其中，D[i]或者是弧(v, vi)的权值，或者是D[k](vk ∈ S)和弧(vk, vi)上权值之和。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;16&quot;&gt;
&lt;div readability=&quot;23&quot;&gt;
&lt;h4&gt;2）Floyd（弗洛伊德）算法&lt;/h4&gt;
&lt;p&gt;Floyd算法是一个经典的&lt;strong&gt;动态规划&lt;/strong&gt;算法。是解决&lt;strong&gt;任意两点间的最短路径&lt;/strong&gt;(称为多源最短路径问题)的一种算法，可以正确处理有向图或负权的最短路径问题。（动态规划算法是通过拆分问题规模，并定义问题状态与状态的关系，使得问题能够以递推（分治）的方式去解决，最终合并各个拆分的小问题的解为整个问题的解。）&lt;/p&gt;
&lt;h4&gt;算法思想&lt;/h4&gt;
&lt;p&gt;从任意节点i到任意节点j的最短路径不外乎2种可能：&lt;strong&gt;1)直接从节点i到节点j，2)从节点i经过若干个节点k到节点j&lt;/strong&gt;。所以，我们假设arcs(i,j)为节点i到节点j的最短路径的距离，对于每一个节点k，我们检查arcs(i,k) + arcs(k,j) &amp;lt; arcs(i,j)是否成立，如果成立，证明从节点i到节点k再到节点j的路径比节点i直接到节点j的路径短，我们便设置arcs(i,j) = arcs(i,k) + arcs(k,j)，这样一来，当我们遍历完所有节点k，arcs(i,j)中记录的便是节点i到节点j的最短路径的距离。（由于动态规划算法在执行过程中，需要保存大量的临时状态（即小问题的解），因此它天生适用于用矩阵来作为其数据结构，因此在本算法中，我们将不使用Guava-Graph结构，而采用邻接矩阵来作为本例的数据结构）&lt;/p&gt;
&lt;/div&gt;
这俩种算法如果以后有机会，我会将具体实现介绍给大家。&lt;/div&gt;


&lt;h2&gt;1.1-5 提供一个现实生活的问题，其中只有最佳解才行。然后提供一个问题，其中近似最佳的一个解也足够好。&lt;/h2&gt;
&lt;p&gt;这个。。。。呵呵呵呵&lt;/p&gt;

&lt;p&gt;当你考研的时候，作为理工科的你最佳选择是去麻省理工大学继续深造。&lt;/p&gt;
&lt;p&gt;最后发现只要是个大学就行。&lt;/p&gt;

&lt;p&gt;近似解。。呵呵呵&lt;/p&gt;


&lt;h3&gt;总结：这一篇的习题侧重于对于算法的启发，希望我能在空余时间，将后面的各式各样的练习题答案以博客的形式发表出来，并加上我自己的一些见解。&lt;/h3&gt;
</description>
<pubDate>Tue, 28 May 2019 15:08:00 +0000</pubDate>
<dc:creator>godoforange</dc:creator>
<og:description>很高兴能和大家一起共同学习算法导论这本书。笔者将在业余时间把算法导论后面的题解以博文的形式展现出来希望能得到大家的支持谢谢。如果有可能我会做一些教学视频免费的供大家观看。 练习题选自算法导论中文第三版</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/godoforange/p/10940674.html</dc:identifier>
</item>
<item>
<title>朱晔的互联网架构实践心得S2E7:漫谈平台架构的工作（基础架构、基础服务、基础平台、基础中间件等等） - lovecindywang</title>
<link>http://www.cnblogs.com/lovecindywang/p/10941007.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lovecindywang/p/10941007.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;程序开发毕竟还不是搬砖这种无脑体力劳动，需要事先有标准，有架构，有设计，绝对不是新公司今天创立，明天就可以开始编码的。其实很多公司在起步的时候没有财力和资源建设独立的基础架构或平台架构部门，甚至运维团队都没有，但是这不妨碍我们心中有一个蓝图知道努力的方向，本文我们就简单聊聊平台架构相关的工作内容（或者说作为一个技术管理，应该去梳理、统一、明确的部分）的蓝图。由于本文覆盖的内容比较多，只能抛砖引玉大概提一些，无法一一展开太详细的东西。图中的数字是我认为的优先级，仅供参考。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/powerzhuye/odmb3b9fsnqd2jj0r2rek32j/Framework.jpg&quot; alt=&quot;Framework.jpg-1246.5kB&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;规范&quot;&gt;规范&lt;/h2&gt;
&lt;p&gt;规范它虽然不是一个实际的代码或组件，只是一个文档，但是我觉得非常重要。没有规范，那么员工加下去任何一行新代码可能都是错的，整个研发流程也可能会因为没有规范导致很多不必要的事故产生。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;代码提交&amp;amp;分支管理规范，我们可以在gitflow基础上根据实际情况（结合运维流程，项目复杂度，团队人数，发布周期）进行细化，涉及到：
&lt;ul&gt;&lt;li&gt;有哪几个常驻分支，哪几个临时分支？&lt;/li&gt;
&lt;li&gt;分支命名规范？&lt;/li&gt;
&lt;li&gt;提交代码描述规范？&lt;/li&gt;
&lt;li&gt;分支迁出和合并的时机？&lt;/li&gt;
&lt;li&gt;哪些分支普通开发没有权限直接提交？&lt;/li&gt;
&lt;li&gt;测试用什么分支，上线又用什么分支？&lt;/li&gt;
&lt;li&gt;多版本并行开发如何提测？&lt;/li&gt;
&lt;li&gt;Hotfix如何处理分支？&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;编码规范，比如Java代码可以以阿里Java开发手册为基础，大家一起过一遍，针对项目的实际情况（时间要求，对性能要求），选择其中的一些坚决执行，然后补充一些其它的。我们也可以让大家的IDE使用（导入）统一的Code Style Template来要求一致的编码格式。因为Code Style的不一致导致提交的时候大范围的代码新增删除完全会污染提交，让大家很难看出提交的代码到底改了什么。&lt;/li&gt;
&lt;li&gt;数据库设计规范。阿里Java开发手册里包含了一小部分数据库设计规范，术业有专攻，这个还是应该请资深DBA来给出一定的规范，包括但不限于：
&lt;ul&gt;&lt;li&gt;命名（表和字段前缀后缀命名，外键字段命名、通用字段命名统一）规范&lt;/li&gt;
&lt;li&gt;字段设计类型规范&lt;/li&gt;
&lt;li&gt;字段冗余规范&lt;/li&gt;
&lt;li&gt;通用字段规范&lt;/li&gt;
&lt;li&gt;索引使用规范&lt;/li&gt;
&lt;li&gt;……。可以参考《朱晔的互联网架构实践心得S2E1：业务代码究竟难不难写？》中提到的一些内容&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;项目结构规范，对于Java Maven项目来说基本目录结构比较统一，对于其它语言的项目（比如Python），目录结构没有一定标准的话，项目源码结构会千奇百怪，最好还是对于项目结构有一个规范，包括：
&lt;ul&gt;&lt;li&gt;三层结构目录划分&lt;/li&gt;
&lt;li&gt;多环境（Profile）配置文件&lt;/li&gt;
&lt;li&gt;服务接口、服务实现、Web、Job模块命名&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;最后是项目管理流程，有一些公司会有专门的PMO，有一些初创公司研发Leader也会充当PMO的角色，虽然这个活一般和平台架构没啥关系，不管怎么样，既然是项目肯定少不了项目管理，作为技术管理角色需要关注的一个点，项目管理流程也是比较重要的：
&lt;ul&gt;&lt;li&gt;迭代周期，迭代周期中的大环节大概发生的时间点&lt;/li&gt;
&lt;li&gt;开哪些会，开会时间点是？（日站会、周例会、启动会、回顾会、复盘会、排期会、PRD预评审会、PRD评审会、测试用例评审会、上线方案讨论会）&lt;/li&gt;
&lt;li&gt;项目生命周期中每一个角色产出哪些文档？&lt;/li&gt;
&lt;li&gt;任务在哪里管理，每一个角色怎么去维护任务状态的流转？不可能任务的每一个状态的流转都由PMO来做&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;基础框架&quot;&gt;基础框架&lt;/h2&gt;
&lt;p&gt;使用一些基础框架来做应用开发是必须的，对于Java技术栈，大家所熟悉的框架有Spring Cloud全家桶、Spring Boot套件（封装的各种starters）、Mybatis等，直接使用这些框架进行开发是可以的，但是更建议的是由基础架构团队封装自己的框架，自己做一层封装，我们可以以类似Spring Boot Starter的模式，为所有的组件封装自己的Starter模块，好处是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;方便进行统一的外部依赖类库 &amp;amp; 库版本管理和约定&lt;/li&gt;
&lt;li&gt;方便针对公司内部情况做更合适的自动配置（甚至实现0配置）&lt;/li&gt;
&lt;li&gt;如果内部技术栈是异构的话，使用统一的框架有助于技术栈后端基础设施的打通&lt;/li&gt;
&lt;li&gt;为所有的模块打通监控，自动配置AOP做相应的拦截统一抓取获取监控数据&lt;/li&gt;
&lt;li&gt;模块之间可以相互整合和配合，实现1+1&amp;gt;2的效果&lt;/li&gt;
&lt;li&gt;还有很重要的一点是，我们可以提供相应的管控后台来配合框架使用，把框架的配置、管理和审计暴露在控制台上&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其实说白了，就是使用自己封装的类库占坑，哪怕只是一层浅浅的封装，也是很有好处的，不仅仅是做了各种统一（使用框架的统一，框架版本号的统一），更多的是因为占了坑（当然，要扩展做Java agent动态字节码注入的方式也是可行的，这种方式的缺点是没有办法提供API给业务使用），以后直接可以通过升级框架通过IOC组件替换+AOP直接做各种扩展（不需要再麻烦业务团队了）。&lt;/p&gt;
&lt;p&gt;我们来看看这里脑图上大概列出的一些业务开发需要用到的常见模块（可以看一下我们公司开源的框架https://github.com/ke-finance/summerframework ，当然开源出来的模块比较少，实际内部封装了这里提到的所有模块）：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Web MVC：可以基于Spring MVC进行封装，增加一些模板引擎的支持等&lt;/li&gt;
&lt;li&gt;数据访问：可以基于MyBatis或Mybatis Plus+Druid数据源进行封装，做一些额外的功能，比如敏感数据加密保存&lt;/li&gt;
&lt;li&gt;RPC服务调用或微服务：可以基于Dubbo或Spring Cloud（Feign+Eureka）进行封装，在客户端方面扩展一些更智能的LB算法，以及路由策略（比如灰度）等功能&lt;/li&gt;
&lt;li&gt;Web API：可以在Spring MVC+Swagger UI基础上实现功能，提供统一的RESTful服务端API的标准，比如规范化API版本、响应结构体自动包装（自适应）、错误包装、HATEOAS超媒体资源导航整合、数据加解密实现、Collection资源的规范化、自动的mock接口的实现等&lt;/li&gt;
&lt;li&gt;配置：可以基于携程Apollo（&lt;a href=&quot;https://github.com/ctripcorp/apollo&quot; class=&quot;uri&quot;&gt;https://github.com/ctripcorp/apollo&lt;/a&gt; ）客户端进行封装，做自动配置&lt;/li&gt;
&lt;li&gt;消息：可以封装RabbitMQ、RocketMQ的客户端实现统一的消息API，然后扩展事务消息（收发消息和业务逻辑本地事务在一个事务中处理）等功能&lt;/li&gt;
&lt;li&gt;缓存：可以基于CacheCloud（&lt;a href=&quot;https://github.com/sohutv/cachecloud&quot; class=&quot;uri&quot;&gt;https://github.com/sohutv/cachecloud&lt;/a&gt; ）提供Redis缓存服务&lt;/li&gt;
&lt;li&gt;调度：可以封装XXLJob（&lt;a href=&quot;https://github.com/xuxueli/xxl-job/&quot; class=&quot;uri&quot;&gt;https://github.com/xuxueli/xxl-job/&lt;/a&gt; ）或ElasticJob（&lt;a href=&quot;http://elasticjob.io%EF%BC%89%E6%8F%90%E4%BE%9B%E8%B0%83%E5%BA%A6%E6%9C%8D%E5%8A%A1&quot; class=&quot;uri&quot;&gt;http://elasticjob.io）提供调度服务&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;日志监控：可以基于Micrometer实现应用打点，找一个APM（Skywalking &lt;a href=&quot;https://github.com/apache/skywalking&quot; class=&quot;uri&quot;&gt;https://github.com/apache/skywalking&lt;/a&gt; 或Pinpoint &lt;a href=&quot;https://github.com/naver/pinpoint&quot; class=&quot;uri&quot;&gt;https://github.com/naver/pinpoint&lt;/a&gt; ）整合trace功能，扩展logback做日志脱敏，扩展Spring Boot Actuator Endpoint等功能&lt;/li&gt;
&lt;li&gt;锁：可以基于Redisson封装分布式锁，使用统一的API来提供内存锁和分布式锁&lt;/li&gt;
&lt;li&gt;分布式事务：主要是两块，同步2PC分布式事务处理（比如我们开源的https://github.com/ke-finance/dts ），异步的saga思想的实现，参考https://github.com/eventuate-tram/eventuate-tram-sagas 。&lt;/li&gt;
&lt;li&gt;弹性：流控+隔离+熔断，考虑基于https://github.com/alibaba/Sentinel 来实现，可以是独立的模块提供服务，也可以整合到Web API或RPC模块中去&lt;/li&gt;
&lt;li&gt;安全：可以基于Spring Security进行扩展，加入符合业务需求的风控策略进去&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;基础平台&quot;&gt;基础平台&lt;/h2&gt;
&lt;p&gt;基础平台（管理平台）需要和基础框架打配合，框架是开发的时候使用的，平台更多的是开发或运维人员做技术运营时使用的。很多开源框架都已经提供了管理后台，我们需要做的可能只是一些小修改，比如包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;打通公司内部自己的账号登录体系和权限体系&lt;/li&gt;
&lt;li&gt;根据不同的环境（开发、测试、灰度、生产）部署多份管理控制台&lt;/li&gt;
&lt;li&gt;根据需要看是否需要做多租户的改造，实现业务隔离&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;有些平台是重流程的，这些可能需要自主开发，大概介绍一下脑图上提到的这些：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;配置平台：如果使用了携程Apollo，自然就是使用Apollo的管理后台&lt;/li&gt;
&lt;li&gt;微服务管理平台：这里我列出了两个方面的工作，一个是服务中心，更多的是服务维护、管理、监控方面的功能，可以基于Spring Cloud Admin进行改造；一个是服务集市，更多的是服务标准化方面的管理，比如服务上线需要的文档，接入的监控系统，以及上线后统一的文档中心，服务集市类似于App Store的概念&lt;/li&gt;
&lt;li&gt;缓存平台，如果使用了CacheCloud，可以使用CacheCloud的管理后台&lt;/li&gt;
&lt;li&gt;日志平台，分为两块，一块是日志收集展示基本ELK已经是标准；还有一块是日志异常报警，可以自己来开发，基于Kafka消费日志异步做日志筛选+聚合结合自己公司的IM和邮件体系做报警&lt;/li&gt;
&lt;li&gt;数据库管理平台：
&lt;ul&gt;&lt;li&gt;DDL/DML工作流：开发提交申请，主管审批，自动执行，外加自动的风险检测，优化建议等&lt;/li&gt;
&lt;li&gt;DDL/DML变更通知：方便大数据以及运营团队针对感兴趣的数据库和表进行订阅，在DDL应用到各个环境（测试、生产）的时候能够第一时间得到通知可以进行人工、自动处理（类似before，after Filter的概念）&lt;/li&gt;
&lt;li&gt;数据库知识库：有一个统一的地方查看数据库的结构说明、字典枚举的定义&lt;/li&gt;
&lt;li&gt;当然数据库管理平台还可以进一步做数据库监控、慢SQL优化原因分析等功能&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;全链路追踪平台：比如如果使用Skywalking的话可以实现它提供的管理台，主要功能无非是依赖拓扑分析、Trace查看、服务性能分析等&lt;/li&gt;
&lt;li&gt;指标查看平台：分为两块，Dashboard一般可以考虑直接使用Grafana，报警的话虽然Grafana也有Alert但是还是建议在更底层（数据源头）去做，可以基于流处理去做或基于定时拉的方式去实现&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;基础中间件&quot;&gt;基础中间件&lt;/h2&gt;
&lt;p&gt;中间件是指独立部署的不具有业务逻辑耦合 的通用服务，存储服务在广义上归到中间件也不是不可以，这里大概列了几个典型：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;MQ代理（Broker，不是Proxy），比如RabbitMQ、RocketMQ、Kafka&lt;/li&gt;
&lt;li&gt;API网关，有很多开源的网关实现，比如Kong（&lt;a href=&quot;https://github.com/Kong/kong&quot; class=&quot;uri&quot;&gt;https://github.com/Kong/kong&lt;/a&gt; ）、Spring Cloud Gateway，我们也实现了一套https://github.com/ke-finance/tesla ，一般网关的主要功能是调用路由、协议转换、调用编排，然后也会以插件和过滤器形式提供很多安全、弹性方面的扩展功能&lt;/li&gt;
&lt;li&gt;DB代理，比如类似https://github.com/flike/kingshard 和https://github.com/Qihoo360/Atlas 的MySQL Proxy，实现数据库的读写分离、分表分库、故障转移、弹性处理、监控、SQL优化等功能&lt;/li&gt;
&lt;li&gt;ES集群，也可以理解为中间件，毕竟ES其实做的就是基于Lucene的分布式集群管理工作&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这些中间件虽然很多时候做的是Proxy背后的其它服务，但是节点本身很可能是有状态的，也需要考虑中间件本身的高可用性问题。&lt;/p&gt;
&lt;h2 id=&quot;基础服务&quot;&gt;基础服务&lt;/h2&gt;
&lt;p&gt;一般而言如果公司具有多个项目的话，项目之间肯定会用到一些通用的内部和外部能力，这些能力和业务逻辑没有太多关系，可以考虑把这些能力进行统一的封装独立部署以微服务形式提供出来，这样所有项目都可以快速对接。&lt;/p&gt;
&lt;p&gt;在这里把基础服务分为了两类，一类是没有业务逻辑的纯基础服务，往往是对接封装一个或多个外部服务通道，另外一类是包含一些业务的业务基础服务。对于第一类基础服务你可能会想，既然是对接外部服务通道直接使用他们的SDK或服务是不是直接在业务系统使用那些三方SDK就好了，基础服务是需要做什么呢？我觉得基础服务应该这么封装：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;封装外部服务的SDK，一般而言比如短信也好、推送也好、存储也好，都会使用多家提供的服务做备份、降级，通过我们的SDK提供统一的对内API，屏蔽不同SDK的API差异&lt;/li&gt;
&lt;li&gt;提供一个服务端，在服务端做数据落地，落地的目的有几个：
&lt;ul&gt;&lt;li&gt;方便和外部进行服务消费对账&lt;/li&gt;
&lt;li&gt;方便出错的时候查找原因&lt;/li&gt;
&lt;li&gt;方便和外部服务同步调用状态（比如短信到达）&lt;/li&gt;
&lt;li&gt;方便进行服务余额预警&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;服务端除了做数据落地，由统一的服务端做出口的好处是：
&lt;ul&gt;&lt;li&gt;做权限控制，一般而言即使是公司内部的项目进行基础服务的调用应该也是需要先申请再使用的，甚至需要做服务调用量的控制（类似在内部再实现一层SaaS）&lt;/li&gt;
&lt;li&gt;收敛调用源IP&lt;/li&gt;
&lt;li&gt;集中管理调用外部SaaS服务的密钥&lt;/li&gt;
&lt;li&gt;外部服务的降级和切换策略更换比较方便&lt;/li&gt;
&lt;li&gt;给接入方做报警&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;做一个管理后台，虽然外部服务提供方作为SaaS产品一般都会有不错的控制台（其实更多的时候，不可能把外部服务的控制台的权限放给所有人看，内部业务方看自己的基础服务控制台即可），但是我们内部做一个管理后台意义还是很大的，主要的功能一般是：
&lt;ul&gt;&lt;li&gt;统一登录&lt;/li&gt;
&lt;li&gt;账号（包括Secret）申请和分配，以及配额、限流等配置（管理员权限）&lt;/li&gt;
&lt;li&gt;调用记录（请求、结果）查看&lt;/li&gt;
&lt;li&gt;调用模板的配置（考虑一下是不是放开服务的使用，比如短信、邮件、推送一般是基于模板的，模板需要内部外部审核后才能使用）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果每一个服务都有控制台的话，可以大大方便业务方的自主接入和问题排查，这是基础服务封装非常有价值的一个点，对于大点的公司内部项目众多就更需要把基础服务在内部进行SaaS化了，而且最好对于不同的基础服务打通接入方（统一的地方来申请所有需要的基础服务）。&lt;/p&gt;
&lt;p&gt;这里脑图上大概列了一些常见的基础服务和业务服务，每一个公司根据自己的业务一般都会不尽相同，基础服务包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;短信：接入多个短信渠道，根据政策、费率、到达率等情况路由&lt;/li&gt;
&lt;li&gt;文件存储：接入多个小文件存储服务（比如七牛、腾讯云），根据存储服务提供的功能，文件大小、费率等情况路由&lt;/li&gt;
&lt;li&gt;邮件：接入内部和外部（比如SendCloud）的邮件服务，根据使用场景进行路由&lt;/li&gt;
&lt;li&gt;推送：接入多个推送渠道（比如极光、个推），并且做用户、设备的关系维护&lt;/li&gt;
&lt;li&gt;唯一ID：全局唯一ID的生成&lt;/li&gt;
&lt;li&gt;图形、滑动、点击、智能验证码：提供统一的验证码服务，可以根据场景自动选择验证码类型&lt;/li&gt;
&lt;li&gt;电子签章：接入多个电子签章服务，根据费率等因素路由&lt;/li&gt;
&lt;li&gt;地图服务：接入多个外部地图服务，根据功能以及接入方使用的地图进行服务选择&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;业务服务包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;RBAC权限控制：统一的RBAC配置后台，以及方便的SDK&lt;/li&gt;
&lt;li&gt;通用表单服务：根据后台配置的表单自动生成界面，以及表单信息的收集&lt;/li&gt;
&lt;li&gt;状态机：可以借鉴https://github.com/hekailiang/squirrel ，基于状态(State)、行为(Action)、转移(Transition)、条件(Condition)等概念，构建基于数据库的状态机平台&lt;/li&gt;
&lt;li&gt;统一支付：聚合支付，业务方可以快速接入多种支付渠道，并且统一支付可以提供统一的SDK和H5来实现统一的支付收银台&lt;/li&gt;
&lt;li&gt;工作流、爬虫、SSO……不详细说明了&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;工程效率&quot;&gt;工程效率&lt;/h2&gt;
&lt;p&gt;接下去也简单提一下工程效率和运维范畴的事情，虽然这和平台架构没啥太大关系，但是这两块是很重要的技术基建工作：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;源代码仓库：比如可以选择Gitlab或atlassian三件套的Bitbucket&lt;/li&gt;
&lt;li&gt;内部类库仓库：比如Java的Maven仓库，可以自己搭建Nexus仓库&lt;/li&gt;
&lt;li&gt;项目管理平台：可以选择SaaS产品（比如Tower、Teambition），比较有名的是atlassian三件套的Jira&lt;/li&gt;
&lt;li&gt;知识管理平台：可以选择SaaS或开源Wiki产品，比较有名的是atlassian三件套的Confluence&lt;/li&gt;
&lt;li&gt;Bug管理平台：比如可以选择禅道或直接复用Jira&lt;/li&gt;
&lt;li&gt;代码质量分析：比如可以搭建SonarQube平台&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;运维&quot;&gt;运维&lt;/h2&gt;
&lt;p&gt;这里提到的一些运维系统相关工作有的公司是架构团队来建设的，列一个大概：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;CI/CD平台：一般而言需要自己结合公司的工作流程做一套CI/CD平台（底层可以基于Jenkins（或直接SSH+脚本）封装），这个平台需要结合公司的工作流程去做，比如谁可以发起流程，每一个发布环节需要谁来审批，发布时间窗口等等&lt;/li&gt;
&lt;li&gt;DNS平台：一般会直接使用域名管理商的平台或类似DNSPod这种平台&lt;/li&gt;
&lt;li&gt;CMDB：一般都会根据自己的情况自建平台，进行运维各个层次相关资源的元数据以及配置管理&lt;/li&gt;
&lt;li&gt;监控：一般会基于Prometheus+Grafana+Zabbix等开源项目来打造运维的基础监控&lt;/li&gt;
&lt;li&gt;CDN平台：一般是用云的，比如七牛、又拍或三大云服务的CDN都可以&lt;/li&gt;
&lt;li&gt;集群配置管理：这个不是指CMDB，是指批量进行集群配置应用操作，管理操作的平台，比如Chef、Puppet、Ansible、Fabric，一般也是基于开源改造封装或直接用开源的&lt;/li&gt;
&lt;li&gt;容器编排：比如K8S平台，一般可能会基于k8s的API做一套自己的k8s管控平台或选用类似Rancher这种更好用更高层的服务，完全基于命令行的k8s运维不是很高效易用&lt;/li&gt;
&lt;li&gt;容器镜像仓库：比如Docker私有仓库Harbor&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;好吧，的确一些中大型互联网公司是有超过100个内部系统是和研发相关的，甚至需要有专门的导航网站来管理工程效率、运维、基础框架、基础服务、基础中间件、基础平台的这些网站，这些系统本身的维护工作量也是不小的，一整理就会发现原来除了业务程序还有这么多周边的东西是为研发服务的，欢迎大家针对本文的内容进行补充。&lt;/p&gt;
</description>
<pubDate>Tue, 28 May 2019 15:07:00 +0000</pubDate>
<dc:creator>lovecindywang</dc:creator>
<og:description>前言 程序开发毕竟还不是搬砖这种无脑体力劳动，需要事先有标准，有架构，有设计，绝对不是新公司今天创立，明天就可以开始编码的。其实很多公司在起步的时候没有财力和资源建设独立的基础架构或平台架构部门，甚至</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lovecindywang/p/10941007.html</dc:identifier>
</item>
<item>
<title>nginx配置SSL证书实现https服务 - 龙恩0707</title>
<link>http://www.cnblogs.com/tugenhua0707/p/10940977.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tugenhua0707/p/10940977.html</guid>
<description>&lt;p&gt;在前面一篇文章中，使用&lt;a href=&quot;https://www.cnblogs.com/tugenhua0707/p/10927722.html&quot; target=&quot;_blank&quot;&gt;openssl生成了免费证书&lt;/a&gt; 后，我们现在使用该证书来实现我们本地node服务的https服务需求。假如我现在node基本架构如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
|----&lt;span&gt;项目
&lt;/span&gt;| |---&lt;span&gt; static         # 存放html文件
&lt;/span&gt;| | |---&lt;span&gt; index.html   # index.html
&lt;/span&gt;| |---&lt;span&gt; node_modules   # 依赖包
&lt;/span&gt;| |---&lt;span&gt; app.js         # node 入口文件
&lt;/span&gt;| |---&lt;span&gt; package.json  
&lt;/span&gt;| |--- .babelrc       # 转换es6文件
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;index.html 文件代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=utf-8&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;referrer&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;never&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;nginx配置https&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;欢迎使用https来访问页面&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;app.js 代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
const Koa = require('koa'&lt;span&gt;);
const fs &lt;/span&gt;= require('fs'&lt;span&gt;);
const path &lt;/span&gt;= require('path'&lt;span&gt;);
const router &lt;/span&gt;= require('koa-router'&lt;span&gt;)();
const koaBody &lt;/span&gt;= require('koa-body'&lt;span&gt;);
const static &lt;/span&gt;= require('koa-static'&lt;span&gt;);

const app &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Koa();

router.get(&lt;/span&gt;'/', (ctx, next) =&amp;gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置头类型, 如果不设置，会直接下载该页面&lt;/span&gt;
  ctx.type = 'html'&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 读取文件&lt;/span&gt;
  const pathUrl = path.join(__dirname, '/static/index.html'&lt;span&gt;);
  ctx.body &lt;/span&gt;=&lt;span&gt; fs.createReadStream(pathUrl);
  next();
});

app.use(static(path.join(__dirname)));

app.use(router.routes());
app.use(router.allowedMethods());

app.listen(&lt;/span&gt;3001, () =&amp;gt;&lt;span&gt; {
  console.log(&lt;/span&gt;'server is listen in 3001'&lt;span&gt;);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;package.json 代码如下;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&quot;name&quot;: &quot;uploadandload&quot;&lt;span&gt;,
  &lt;/span&gt;&quot;version&quot;: &quot;1.0.0&quot;&lt;span&gt;,
  &lt;/span&gt;&quot;description&quot;: &quot;&quot;&lt;span&gt;,
  &lt;/span&gt;&quot;main&quot;: &quot;app.js&quot;&lt;span&gt;,
  &lt;/span&gt;&quot;scripts&quot;&lt;span&gt;: {
    &lt;/span&gt;&quot;dev&quot;: &quot;nodemon ./app.js&quot;&lt;span&gt;
  },
  &lt;/span&gt;&quot;author&quot;: &quot;&quot;&lt;span&gt;,
  &lt;/span&gt;&quot;license&quot;: &quot;ISC&quot;&lt;span&gt;,
  &lt;/span&gt;&quot;dependencies&quot;&lt;span&gt;: {
    &lt;/span&gt;&quot;fs&quot;: &quot;0.0.1-security&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;koa&quot;: &quot;^2.7.0&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;koa-body&quot;: &quot;^4.1.0&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;koa-router&quot;: &quot;^7.4.0&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;koa-send&quot;: &quot;^5.0.0&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;koa-static&quot;: &quot;^5.0.0&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;nodemon&quot;: &quot;^1.19.0&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;path&quot;: &quot;^0.12.7&quot;&lt;span&gt;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后我在项目的根目录下执行 npm run dev 后，就可以在浏览器下访问 http://localhost:3001 了，但是为了我想使用域名访问的话，因此我们可以在 hosts文件下绑定下域名，比如叫 xxx.abc.com . hosts文件如下绑定：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
127.0.0.1  xxx.abc.com
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因此这个时候我们使用 http://xxx.abc.com:3001/ 就可以访问页面了，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201905/561794-20190528224831920-1952060532.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上所示，我们就可以访问页面了，但是我们有没有发现，在chrome浏览器下 显示http请求是不安全的，因此这个时候我想使用https来访问就好了，网页的安全性就得到了保障，但是这个时候如果我什么都不做，直接使用https去访问的话是不行的，比如地址：https://xxx.abc.com:3001. 如下图所示：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201905/561794-20190528224905355-56510952.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们知道使用https访问的话，一般是需要安全证书的，因此我们现在的任务是需要使用nginx来配置下安全证书之类的事情，然后使用https能访问网页就能达到目标。&lt;br/&gt;如果想要学习nginx基本安装及基本知识点，请看我之前的&lt;a href=&quot;https://www.cnblogs.com/tugenhua0707/category/1205593.html&quot; target=&quot;_blank&quot;&gt;这篇文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;nginx配置https服务&lt;/strong&gt;&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 首先进入nginx目录下，使用命令：cd /usr/local/etc/nginx。然后在该目录下创建 cert文件夹，目的是存放证书文件。&lt;/strong&gt;&lt;br/&gt;使用命令：mkdir cert 如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201905/561794-20190528225102075-1020160352.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 然后我们需要把证书相关的文件，比如server.crt 和 server.key 文件复制到该 cert目录下。比如如下证书文件：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201905/561794-20190528225118292-233498278.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至于如上证书是如何生存的，可以请看我上篇文字 &lt;a href=&quot;https://www.cnblogs.com/tugenhua0707/p/10927722.html&quot; target=&quot;_blank&quot;&gt;使用openssl 生存免费证书&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;移动命令：mv server.key /usr/local/etc/nginx/cert， 比如把server.key 和 server.crt文件都移动到 /usr/local/etc/nginx/cert目录下。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201905/561794-20190528225228557-1817272601.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我们再查看下 /usr/local/etc/nginx/cert 目录下，有如下文件，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201905/561794-20190528225242820-1241232565.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. nginx的配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;nginx的配置需要加上如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;server {
  listen       &lt;/span&gt;443&lt;span&gt; ssl;
  server_name    xxx.abc.com;
  ssl on;  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 该配置项需要去掉&lt;/span&gt;
  ssl_certificate      cert/server.crt;
  ssl_certificate_key  cert/server.key;
  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
   设置ssl/tls会话缓存的类型和大小。如果设置了这个参数一般是shared，buildin可能会参数内存碎片，默认是none，和off差不多，停用缓存。如shared:SSL:10m表示我所有的nginx工作进程共享ssl会话缓存，官网介绍说1M可以存放约4000个sessions。
  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  ssl_session_cache    shared:SSL:1m;
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 客户端可以重用会话缓存中ssl参数的过期时间，内网系统默认5分钟太短了，可以设成30m即30分钟甚至4h。&lt;/span&gt;
&lt;span&gt;  ssl_session_timeout  5m;

  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
   选择加密套件，不同的浏览器所支持的套件（和顺序）可能会不同。
   这里指定的是OpenSSL库能够识别的写法，你可以通过 openssl -v cipher 'RC4:HIGH:!aNULL:!MD5'（后面是你所指定的套件加密算法） 来看所支持算法。
  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  ssl_ciphers  HIGH:&lt;/span&gt;!aNULL:!&lt;span&gt;MD5;

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置协商加密算法时，优先使用我们服务端的加密套件，而不是客户端浏览器的加密套件。&lt;/span&gt;
&lt;span&gt;  ssl_prefer_server_ciphers  on;

  location &lt;/span&gt;/&lt;span&gt; {
    proxy_pass http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:3001;&lt;/span&gt;
&lt;span&gt;  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意：如上 ssl on; 这个配置项需要去掉。假如是如上的配置后，我重新启动下nginx命令会报错，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201905/561794-20190528225352227-1003439378.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;SSL: error:06065064:digital envelope routines:EVP_DecryptFinal_ex:bad decrypt error:0906A065:PEM routines:PEM_do_header:bad decrypt 类似这样的错，然后通过百度搜索这个错误，通过如下方法可以解决：&lt;/p&gt;
&lt;p&gt;进入到该目录下：cd /usr/local/etc/nginx/cert 然后执行下面两句代码即可：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;cp server.key server.key.org
openssl rsa &lt;/span&gt;-&lt;span&gt;in&lt;/span&gt; server.key.org -out server.key
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201905/561794-20190528225446528-576585575.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看百度搜索出来的页面(&lt;a href=&quot;http://ju.outofmemory.cn/entry/17732&quot; target=&quot;_blank&quot;&gt;http://ju.outofmemory.cn/entry/17732&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;然后当我继续重启下 nginx, 发现还会报错，报错信息如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
nginx: [warn] the &quot;ssl&quot; directive is deprecated, use the &quot;listen ... ssl&quot; directive instead 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后继续把 ssl on; 这句配置项去掉就可以了，可能和nginx的版本有关系，请看这篇文章(&lt;a href=&quot;https://blog.csdn.net/ootw/article/details/81059677&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/ootw/article/details/81059677&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;现在我继续重启下nginx就ok了，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201905/561794-20190528225709122-2067543723.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是如上配置后，我们还不能直接 使用 域名 https://xxx.abc.com/ 访问了，我们还需要在浏览器下把自己之前生成的client.crt 证书安装上去，在mac系统下操作步骤如下：&lt;/p&gt;
&lt;p&gt;1. 点击如下启动台。如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201905/561794-20190528225736680-1451391708.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2. 搜索钥匙串访问，点击进去，如下所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201905/561794-20190528225751376-604474745.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3. 进入到证书页面，把我们之前的client.crt证书拖进到证书里面去即可，比如我之前生成的 client.crt证书，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201905/561794-20190528225806538-823170558.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4. 右键点击我的证书，然后点击 &quot;显示简介&quot;, 进入到证书详情页面后。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201905/561794-20190528225820938-1512273675.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5. 进入页面后，使用证书时，选择始终信任后，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201905/561794-20190528225838094-1910525499.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;6. 然后退出，可能需要输入电脑开机密码，输入完成，会自动保存。然后我们在浏览器访问该 https://xxx.abc.com/ 页面后就可以访问的到了。如下所示：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201905/561794-20190528225900582-1031374577.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我们点击继续访问即可看到页面了，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201905/561794-20190528225914584-1968422200.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上就是使用 nginx + 证书 实现 本地node https服务了。&lt;/p&gt;
&lt;p&gt;但是如上https虽然可以访问，但是https前面还是显示不安全的文案； 如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201905/561794-20190528225929265-1284631440.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可能的原因该证书是自己生成的证书，不是购买第三方的证书导致的吧。具体啥原因，目前我也不知道，至少现在我们可以使用https来访问我们的项目了。&lt;br/&gt;&lt;a href=&quot;https://github.com/tugenhua0707/web-security/tree/master/openssl&quot; target=&quot;_blank&quot;&gt;github上简单node服务启动的源码&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 28 May 2019 15:01:00 +0000</pubDate>
<dc:creator>龙恩0707</dc:creator>
<og:description>nginx配置SSL证书实现https服务</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tugenhua0707/p/10940977.html</dc:identifier>
</item>
</channel>
</rss>