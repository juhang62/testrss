<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>人工智能第二课：认知服务和机器人框架探秘 - 陈希章</title>
<link>http://www.cnblogs.com/chenxizhang/p/10080911.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenxizhang/p/10080911.html</guid>
<description>&lt;p&gt;&lt;span&gt;这是《人工智能系列笔记》的第二篇，我利用周六下午完成课程学习。这一方面是因为内容属于入门级，并且之前我已经对认知服务和机器人框架比较熟悉。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;如有兴趣，请关注该系列 https://aka.ms/learningAI &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/9072/201812/9072-20181207070824998-2138102145.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是学习这门课程还是很有收获，这篇笔记时特别加了&quot;探秘&quot;两个字，这是因为他不仅仅是介绍了微软的认知服务和机器人框架及其如何快速开始工作，更重要的是也做了很多铺垫，例如在讲文本分析服务（Text Analytics）之前，课程用了相当长的篇幅介绍了文本处理的一些技术原理，毕竟无论是微软的认知服务，还是其他厂商的服务，或者你自己尝试去实现，其内部的原理都是类似的。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/9072/201812/9072-20181207070825480-2636924.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;我将给大家分享三个部分的内容&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;文本理解和沟通&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;计算机视觉&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;对话机器人&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;第一部分：文本理解和沟通&lt;/span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在人工智能很火，花样也很多，可能大家不会想到，很早之前人类对于机器智能的研究，最主要就是在文本理解和处理这个部分，科学家们想要实现的场景主要如下&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/9072/201812/9072-20181207070825935-606450360.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;这跟人类本身的学习及成长是类似的，一旦机器掌握这些能力，其实就相当于具备了&quot;听说读写&quot;的能力。我据说微软二十年前创立研究院之处，主要的研究范围也是在这个领域，二十年过去了还在继续投资，不断优化这方面的能力，可见其作为人工智能的重要性。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/9072/201812/9072-20181207070826537-280171960.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;其实这里提到的大部分过程，可以理解为通常意义上的自然语言处理（Natual Language Processing——NLP）的研究范畴。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/9072/201812/9072-20181207070826960-2109924507.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;本次课程中使用python进行讲解，提到了一个关键的package：NLTK（Natual Language Toolkit），以及它的几个更加具体的库：freqdist 用来做字（词）频分析，stem用来做词干提取等等。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/9072/201812/9072-20181207070827484-939398024.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;下面是一些基本的用法&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/9072/201812/9072-20181207070828030-1634434311.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;也就是说，其实你用NLTK能做出绝大部分文本理解和处理的场景，当然如果你用微软的认知服务（Cognitive Service），则可以省去很多基础性的工作，而是直接专注在业务问题上。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/9072/201812/9072-20181207070828470-2138549616.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;前面三种服务都相对简单，通常你只需要开通，并且调用相关的API 即可，例如 Text Analytics 可用来检测文本语言，识别其中的实体，关键信息，以及情感分析。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/9072/201812/9072-20181207070828900-1922376260.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;而Language understanding 则相对更加复杂一点，它的全称是Language understanding intelligence service （Luis），是有一套完整的定义、训练、发布的流程。换言之，Luis允许你自定义模型，而前面三者则是利用微软已经训练好的模型立即开始工作。申请Luis服务是在Azure的门户中完成的，而要进行模型定义和训练，则需要通过 https://luis.ai 这个网站来完成。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/9072/201812/9072-20181207070829286-109099769.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;下面是我用来测试的一个模型的其中一个Intent （Luis能同时支持多种语言，甚至也能做到中英文混合文本的理解）&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/9072/201812/9072-20181207070829629-981728203.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Luis最大的一个使用场合可能是结合本文最后面提到的对话机器人来实现智能问答。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;第二部分：计算机视觉&lt;/span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;如果说文本智能是尝试学习人类的&quot;听说读写&quot;的能力，那么计算机视觉则是尝试模拟人类的眼睛，来实现&quot;看&quot;的能力。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/9072/201812/9072-20181207070829989-66288289.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;图像分析其实就是好比人类看到一个物体（或者其影像），脑电波反射过来信号，使得你意识到你看到的是什么。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/9072/201812/9072-20181207070830516-1573327161.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;这个能力用到了预先训练好的模型。这个可以通过认知服务中的Computer Vision这个组件实现。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;但是，即便是上面的模型已经包含了数以百万计的照片，但相对而言还是很小的一个集合。所以，如果你想实现自己的图像识别，可以使用认知服务中提供的Custom vision这个能力来实现。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Custom vision拥有一个同样很酷的主页：https://customvision.ai/ ，通过这个网站，你可以上传你预先收集好的照片，并且为其进行标记，通常情况下，每个标记至少需要5张照片，然后通过训练即可发布你的服务，并且用于后续的图像识别检测（例如某个图像是不是汽车，或者香蕉之类的）。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/9072/201812/9072-20181207070831076-2124652655.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;人脸识别，则是特定领域的图像识别，这个应用也是目前在人工智能领域最火的一个，而也因为脸是如此重要，所以在认知服务中，有一个专门的API，叫Face API。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/9072/201812/9072-20181207070831732-365505274.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;使用这套API，可以做出来很有意思的应用，例如&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/9072/201812/9072-20181207070832282-1294763939.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;从技术上说，图像（Image）是由一个一个有颜色的数据点构成的，这些数据点通常用RGB值表示。而视频（Video）则是由一幅一幅的图像（Image，此时称为帧）构成的。所以，计算机视觉既然能做到图像的识别和理解（虽然可能会有偏差），那么从技术上说，它也就具备了对视频进行识别和理解的能力，如果再加上之前提到的文本智能，它就能至少实现如下的场景：&lt;/span&gt;&lt;/p&gt;

&lt;ol readability=&quot;2&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;识别视频中出现的人脸，以及他们出现的时间轴。如果是名人，也会自动识别出来，如果不是，支持标记，下次也能识别出来。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;识别视频中的情感，例如从人脸看出来的高兴还是悲伤，以及欢呼声等环境音。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;文本识别（OCR）——根据图像生成文字。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;自动生成字幕，并支持翻译成其他语言。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/9072/201812/9072-20181207070832904-1726036074.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;第三部分：对话机器人&lt;/span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;我记得是在2016年的Build大会上，微软CEO Sayta 提出了一个新的概念：Conversation as a Platform, 简称CaaP，其具体的表现形式就是聊天机器人（chatbot）。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;当时的报道，请参考 https://www.businessinsider.sg/microsoft-ceo-satya-nadella-on-conversations-as-a-platform-and-chatbots-2016-3/?r=US&amp;amp;IR=T &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/9072/201812/9072-20181207070833385-2018926049.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;对话机器人这个单元，讲的就是这块内容。与人脸识别技术类似，机器人这个技术在这几年得到了长足的发展和广泛的应用，甚至到了妇孺皆知的地步。这里谈到的机器人，特指通过对话形式与用户进行交互，并且提供服务的一类机器人，广泛地应用于智能客服、聊天与陪伴、常见问题解答等场合。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;创建一个对话机器人真的很简单，如果你有一个Azure订阅的话。微软在早些时候已经将机器人框架（Bot Framework）完全地整合到了Azure平台。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/9072/201812/9072-20181207070833869-373246909.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;做一个机器人（Bot）其实真的不难，但要真的实现比较智能的体验，还真的要下一番功夫。目前比较常见的做法是，前端用Bot Framework定义和开发Bot（用来与用户交互），后台会连接Luis服务或QnA maker服务来实现智能体验，如下图所示。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;我在11月份的Microsoft 365 DevDays（开发者大会）上面专门讲解了机器人开发，有兴趣可以参考 https://github.com/chenxizhang/devdays2018-beijing 的资料。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/9072/201812/9072-20181207070834335-892393625.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;机器人框架 （Bot Framework）的一个强大之处在于，你可以实现编写一次，处处运行，它通过频道（Channel）来分发服务。目前支持的频道至少有16种。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/9072/201812/9072-20181207070834717-1568447477.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;我自己之前用过Web Chat，Microsoft Teams，以及Direct Line和Skype for Business等四种。一直对Cortana这个场景比较感兴趣，这次通过学习，终于把这个做成功了，还是挺有意思的。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;这项功能，还有一个名称：Cortana Skills，目前需要用Microsoft Account注册这个Bot）。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/9072/201812/9072-20181207070835021-670018817.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;请通过 https://aka.ms/learningAI 或者扫描下面的二维码关注本系列文章《人工智能学习笔记》&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/9072/201812/9072-20181207070835323-1141098397.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/9072/201812/9072-20181207070836321-1262413269.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/9072/201812/9072-20181207070836558-1999641964.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



</description>
<pubDate>Thu, 06 Dec 2018 23:09:00 +0000</pubDate>
<dc:creator>陈希章</dc:creator>
<og:description>这是《人工智能系列笔记》的第二篇，我利用周六下午完成课程学习。这一方面是因为内容属于入门级，并且之前我已经对认知服务和机器人框架比较熟悉。 如有兴趣，请关注该系列 https://aka.ms/lea</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenxizhang/p/10080911.html</dc:identifier>
</item>
<item>
<title>浅析libuv源码-获取精确时间 - 书生小龙</title>
<link>http://www.cnblogs.com/QH-Jimmy/p/10080857.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/QH-Jimmy/p/10080857.html</guid>
<description>&lt;p&gt;　　在Timer模块中有提到，libuv控制着延迟事件的触发，那么必须想办法精确控制时间。&lt;/p&gt;
&lt;p&gt;　　如果是JS，获取当前时间可以直接通过Date.now()得到一个时间戳，然后将两段时间戳相减得到时间差。一般情况下当然没有问题，但是这个方法并不保险，因为本地计算机时间可以修改。&lt;/p&gt;
&lt;p&gt;　　libuv显然不会用这么愚蠢的办法来计算时间，C++内部有更为精妙的方法来处理这个事。&lt;/p&gt;

&lt;p&gt;　　首先在上一节中，一个简单的事件轮询代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main() {
    uv_loop_t &lt;/span&gt;*loop =&lt;span&gt; uv_default_loop();
    uv_run(loop, UV_RUN_DEFAULT);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里的uv_default_loop会生成一个默认的静态对象，负责管理事件轮询，而这个对象有一个属性，则负责记录当前的时间，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; The current time according to the event loop. in msecs. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  uint64_t time; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　简单讲就是记录当前这一轮事件开始处理的时间，单位为毫秒。&lt;/p&gt;
&lt;p&gt;　　在初始化之后，就会执行uv_run来开始事件轮询了，因为这节只讲时间，所以省略无关代码，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; uv_run(uv_loop_t *&lt;span&gt;loop, uv_run_mode mode) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 查询是否有未处理事件&lt;/span&gt;
    r =&lt;span&gt; uv__loop_alive(loop);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;r)
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 表示处理完一轮事件 更新时间&lt;/span&gt;
&lt;span&gt;        uv_update_time(loop);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果有未处理事件&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt; (r != &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; loop-&amp;gt;stop_flag == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里也会更新时间&lt;/span&gt;
&lt;span&gt;        uv_update_time(loop);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　可见，每次轮询时都会更新时间，方法就是那个uv_update_time，源码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; uv_update_time(uv_loop_t*&lt;span&gt; loop) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回一个时间&lt;/span&gt;
    uint64_t new_time = uv__hrtime(&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 检测数据合法性并赋值&lt;/span&gt;
    assert(new_time &amp;gt;= loop-&amp;gt;&lt;span&gt;time);
    loop&lt;/span&gt;-&amp;gt;time =&lt;span&gt; new_time;
}

uint64_t uv__hrtime(&lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; scale) {
    LARGE_INTEGER counter;

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (hrtime_interval_ == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!QueryPerformanceCounter(&amp;amp;&lt;span&gt;counter)) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (uint64_t)((&lt;span&gt;double&lt;/span&gt;)counter.QuadPart * hrtime_interval_ *&lt;span&gt; scale);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面的方法通过一些计算，会返回一个类似于时间戳的长整数。&lt;/p&gt;
&lt;p&gt;　　C++的方法都比较简单，首先看一下hrtime_interval_，从名字可以看出这是一个代表频率的数字，相关的定义和设置代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Interval (in seconds) of the high-resolution clock. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; hrtime_interval_ = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
 * One-time initialization code for functionality defined in util.c.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; uv__util_init(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;) {
    LARGE_INTEGER perf_frequency;

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 加锁 不管这个 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    InitializeCriticalSection(&lt;/span&gt;&amp;amp;&lt;span&gt;process_title_lock);

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Retrieve high-resolution timer frequency
     * and precompute its reciprocal.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (QueryPerformanceFrequency(&amp;amp;&lt;span&gt;perf_frequency)) {
        hrtime_interval_ &lt;/span&gt;= &lt;span&gt;1.0&lt;/span&gt; /&lt;span&gt; perf_frequency.QuadPart;
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        hrtime_interval_ &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　该值的初始化为0，然后会通过某个计算尝试重新赋值。&lt;/p&gt;
&lt;p&gt;　　这里需要介绍一下两个windowsAPI： &lt;span class=&quot;cnblogs_code&quot;&gt;QueryPerformanceFrequency&lt;/span&gt; 与 &lt;span class=&quot;cnblogs_code&quot;&gt;QueryPerformanceCounter&lt;/span&gt; 。&lt;/p&gt;
&lt;p&gt;　　定义非常简单，字面理解一个是系统性能频率，一个是系统性能计数器，具体讲，第一个会返回当前操作系统每秒钟会统计多少次，第二个返回当前已经统计的次数（类似于时间戳从1970年开始，这个应该也有一个参照物），依赖于硬件支持，如果不支持会返回0。&lt;/p&gt;
&lt;p&gt;　　可以通过一个简单的案例来理解这两个API，测试代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main() {
    LARGE_INTEGER m;
    LARGE_INTEGER n1;
    LARGE_INTEGER n2;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取每秒钟统计的次数&lt;/span&gt;
    QueryPerformanceFrequency(&amp;amp;&lt;span&gt;m);
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;5&lt;/span&gt;; i++&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取当前的统计次数&lt;/span&gt;
        QueryPerformanceCounter(&amp;amp;&lt;span&gt;n1);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; zzz...线程等待一秒&lt;/span&gt;
        Sleep(&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取一秒后统计次数&lt;/span&gt;
        QueryPerformanceCounter(&amp;amp;&lt;span&gt;n2);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 计算sleep方法实际时间&lt;/span&gt;
        cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;过去了&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; (&lt;span&gt;double&lt;/span&gt;)(n2.QuadPart - n1.QuadPart) / (&lt;span&gt;double&lt;/span&gt;)m.QuadPart &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;秒&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　执行后输出如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/858904/201812/858904-20181207024847357-1372813042.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　可见，系统的1秒钟实际上并不十分精确。&lt;/p&gt;
&lt;p&gt;　　回到hrtime_interval_的定义：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
hrtime_interval_ = &lt;span&gt;1.0&lt;/span&gt; / perf_frequency.QuadPart;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　很容易知道这里返回的是系统每计数一次所需要的时间。&lt;/p&gt;
&lt;p&gt;　　然后可以理解uv_hrtime方法具体的返回：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
uint64_t uv__hrtime(&lt;span&gt;double&lt;/span&gt;&lt;span&gt; scale) {
    LARGE_INTEGER counter;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果硬件不支持 返回0&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (hrtime_interval_ == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获得当前计数&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (!QueryPerformanceCounter(&amp;amp;&lt;span&gt;counter)) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回当前计数所花费的时间 默认为秒scale(1000)转换为毫秒&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; (uint64_t)((&lt;span&gt;double&lt;/span&gt;)counter.QuadPart * hrtime_interval_ *&lt;span&gt; scale);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　由于 &lt;span class=&quot;cnblogs_code&quot;&gt;QueryPerformanceFrequency&lt;/span&gt;  与 &lt;span class=&quot;cnblogs_code&quot;&gt;QueryPerformanceCounter&lt;/span&gt;  并不依赖于本地时间，所以计算得到的数值可以保证绝对安全。&lt;/p&gt;
&lt;p&gt;　　不过，这个数字的计算方式，简直跟时间戳一模一样啊。&lt;/p&gt;
</description>
<pubDate>Thu, 06 Dec 2018 19:04:00 +0000</pubDate>
<dc:creator>书生小龙</dc:creator>
<og:description>在Timer模块中有提到，libuv控制着延迟事件的触发，那么必须想办法精确控制时间。 如果是JS，获取当前时间可以直接通过Date.now()得到一个时间戳，然后将两段时间戳相减得到时间差。一般情况</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/QH-Jimmy/p/10080857.html</dc:identifier>
</item>
<item>
<title>用lambda表达式树优化反射 - Fode</title>
<link>http://www.cnblogs.com/fode/p/10079630.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fode/p/10079630.html</guid>
<description>&lt;p&gt;&lt;span&gt;本节重点不讲反射机制，而是讲lambda表达式树来替代反射中常用的获取属性和方法，来达到相同的效果但却比反射高效。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;每个人都知道，用反射调用一个方法或者对属性执行SetValue和GetValue操作的时候都会比直接调用慢很多，这其中设计到CLR中内部的处理，不做深究。然而，我们在某些情况下又无法不使用反射，比如：在一个ORM框架中，你要将一个DataRow转化为一个对象，但你又不清楚该对象有什么属性，这时候你就需要写一个通用的泛型方法来处理，以下代码写得有点恶心，但不妨碍理解意思:&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　　　 //将DataReader转化为一个对象&lt;br/&gt;　　　　 private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; T GetObj&amp;lt;T&amp;gt;(SqliteDataReader reader) &lt;span&gt;where&lt;/span&gt; T : &lt;span&gt;class&lt;/span&gt;&lt;span&gt;
        {
            T obj &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; T();
            PropertyInfo[] pros &lt;/span&gt;=&lt;span&gt; obj.GetType().GetProperties();
            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (PropertyInfo item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; pros)
            {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
                {
                    Int32 Index &lt;/span&gt;=&lt;span&gt; reader.GetOrdinal(item.Name);
                    String result &lt;/span&gt;=&lt;span&gt; reader.GetString(Index);
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt;(String) ==&lt;span&gt; item.PropertyType)
                    {
                        item.SetValue(obj, result);
                        &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
                    }
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt;(DateTime) ==&lt;span&gt; item.PropertyType)
                    {
                        item.SetValue(obj, Convert.ToDateTime(result));
                        &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
                    }
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt;(Boolean) ==&lt;span&gt; item.PropertyType)
                    {
                        item.SetValue(obj, Convert.ToBoolean(result));
                        &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
                    }
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt;(Int32) ==&lt;span&gt; item.PropertyType)
                    {
                        item.SetValue(obj, Convert.ToInt32(result));
                        &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
                    }
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt;(Single) ==&lt;span&gt; item.PropertyType)
                    {
                        item.SetValue(obj, Convert.ToSingle(result));
                        &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
                    }
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt;(Single) ==&lt;span&gt; item.PropertyType)
                    {
                        item.SetValue(obj, Convert.ToSingle(result));
                        &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
                    }
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt;(Double) ==&lt;span&gt; item.PropertyType)
                    {
                        item.SetValue(obj, Convert.ToDouble(result));
                        &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
                    }
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt;(Decimal) ==&lt;span&gt; item.PropertyType)
                    {
                        item.SetValue(obj, Convert.ToDecimal(result));
                        &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
                    }
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt;(Byte) ==&lt;span&gt; item.PropertyType)
                    {
                        item.SetValue(obj, Convert.ToByte(result));
                        &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
                    }
                }
                &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ArgumentOutOfRangeException ex)
                {
                    &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
                }
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; obj;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;span&gt;对于这种情况，其执行效率是特别低下的，具体多慢在下面例子会在.Net Core平台上和.Net Framework4.0运行测试案例.对于以上我举例的情况，效率上我们还可以得到提升。但对于想在运行时修改一下属性的名称或其他操作，反射还是一项特别的神器，因此在某些情况下反射还是无法避免的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是对于只是简单的SetValue或者GetValue，包括用反射构造函数，我们可以想一个中继的方法，那就是使用表达式树。对于不理解表达式树的，可以到微软文档查看，&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/csharp/expression-trees&quot;&gt;点击我&lt;/a&gt;。表达式树很容易通过对象模型表示表达式，因此强烈建议学习。查看以下代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
        {
            Dog dog &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Dog();
            PropertyInfo propertyInfo &lt;/span&gt;= dog.GetType().GetProperty(nameof(dog.Name));  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取对象Dog的属性&lt;/span&gt;
            MethodInfo SetterMethodInfo = propertyInfo.GetSetMethod();  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取属性Name的set方法&lt;/span&gt;
&lt;span&gt;
            ParameterExpression param &lt;/span&gt;= Expression.Parameter(&lt;span&gt;typeof&lt;/span&gt;(Dog), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;param&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Expression GetPropertyValueExp &lt;/span&gt;=&lt;span&gt; Expression.Lambda(Expression.Property(param, nameof(dog.Name)), param);
            Expression&lt;/span&gt;&amp;lt;Func&amp;lt;Dog, String&amp;gt;&amp;gt; GetPropertyValueLambda = (Expression&amp;lt;Func&amp;lt;Dog, String&amp;gt;&amp;gt;&lt;span&gt;)GetPropertyValueExp;
            ParameterExpression paramo &lt;/span&gt;= Expression.Parameter(&lt;span&gt;typeof&lt;/span&gt;(Dog), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;param&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            ParameterExpression parami &lt;/span&gt;= Expression.Parameter(&lt;span&gt;typeof&lt;/span&gt;(String), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;newvalue&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            MethodCallExpression MethodCallSetterOfProperty &lt;/span&gt;=&lt;span&gt; Expression.Call(paramo, SetterMethodInfo, parami);
            Expression SetPropertyValueExp &lt;/span&gt;=&lt;span&gt; Expression.Lambda(MethodCallSetterOfProperty, paramo, parami);
            Expression&lt;/span&gt;&amp;lt;Action&amp;lt;Dog, String&amp;gt;&amp;gt; SetPropertyValueLambda = (Expression&amp;lt;Action&amp;lt;Dog, String&amp;gt;&amp;gt;&lt;span&gt;)SetPropertyValueExp;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建了属性Name的Get方法表达式和Set方法表达式,当然只是最简单的&lt;/span&gt;
            Func&amp;lt;Dog, String&amp;gt; Getter =&lt;span&gt; GetPropertyValueLambda.Compile(); 
            Action&lt;/span&gt;&amp;lt;Dog, String&amp;gt; Setter =&lt;span&gt; SetPropertyValueLambda.Compile();

            Setter&lt;/span&gt;?.Invoke(dog, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;WLJ&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;我们现在对dog这个对象的Name属性赋值&lt;/span&gt;
            String dogName = Getter?.Invoke(dog);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取属性Name的值&lt;/span&gt;
&lt;span&gt;            
            Console.WriteLine(dogName);
            Console.ReadKey();
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Dog
        {
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; &lt;span&gt;以下代码可能很难看得懂，但只要知道我们创建了属性的Get、Set这两个方法就行，其结果最后也能输出狗的名字 WLJ,拥有ExpressionTree的好处是他有一个名为Compile（）的方法，它创建一个代表表达式的代码块。现在是最有趣的部分，假设你在编译时不知道类型（在这篇文章中包含的代码我在不同的程序集上创建了一个类型）你仍然可以应用这种技术，我将对于常用的属性的set，get操作进行分装。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;       　　&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    　　&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 属性类，仿造反射中的PropertyInfo
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    　　&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Property
    {

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; PropertyGetter getter;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; PropertySetter setter;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; PropertyInfo Info { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Property(PropertyInfo propertyInfo)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (propertyInfo == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; NullReferenceException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;属性不能为空&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Name =&lt;span&gt; propertyInfo.Name;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Info =&lt;span&gt; propertyInfo;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.Info.CanRead)
            {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.getter = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PropertyGetter(propertyInfo);
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.Info.CanWrite)
            {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.setter = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PropertySetter(propertyInfo);
            }
        }


        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        　　 &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取对象的值
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        　　&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;instance&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        　　&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        　　 &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object GetValue(Object instance)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; getter?&lt;span&gt;.Invoke(instance);
        }


        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        　　 &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 赋值操作
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        　　&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;instance&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        　　&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;value&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        　　 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; SetValue(Object instance, Object value)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.setter?&lt;span&gt;.Invoke(instance, value);
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; ConcurrentDictionary&amp;lt;Type, Core.Reflection.Property[]&amp;gt; securityCache = &lt;span&gt;new&lt;/span&gt; ConcurrentDictionary&amp;lt;Type, Property[]&amp;gt;&lt;span&gt;();

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Core.Reflection.Property[] GetProperties(Type type)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; securityCache.GetOrAdd(type, t =&amp;gt; t.GetProperties().Select(p =&amp;gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Property(p)).ToArray());
        }

    }

&lt;/span&gt;&lt;span&gt;     ///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    　　&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 属性Get操作类
     &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
   　　 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; PropertyGetter
     {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; Func&amp;lt;Object, Object&amp;gt;&lt;span&gt; funcGet;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; PropertyGetter(PropertyInfo propertyInfo) : &lt;span&gt;this&lt;/span&gt;(propertyInfo?&lt;span&gt;.DeclaringType, propertyInfo.Name)
        {

        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; PropertyGetter(Type declareType, String propertyName)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (declareType == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArgumentNullException(nameof(declareType));
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (propertyName == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArgumentNullException(nameof(propertyName));
            }



            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.funcGet =&lt;span&gt; CreateGetValueDeleagte(declareType, propertyName);
        }


        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;代码核心部分&lt;/span&gt;
       　　   &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Func&amp;lt;Object, Object&amp;gt;&lt;span&gt; CreateGetValueDeleagte(Type declareType, String propertyName)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; (object instance) =&amp;gt; (object)((declaringType)instance).propertyName&lt;/span&gt;

            　　　　&lt;span&gt;var&lt;/span&gt; param_instance = Expression.Parameter(&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(Object));
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; body_objToType =&lt;span&gt; Expression.Convert(param_instance, declareType);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; body_getTypeProperty =&lt;span&gt; Expression.Property(body_objToType, propertyName);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; body_return = Expression.Convert(body_getTypeProperty, &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(Object));
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Expression.Lambda&amp;lt;Func&amp;lt;Object, Object&amp;gt;&amp;gt;&lt;span&gt;(body_return, param_instance).Compile();
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;  Object Invoke(Object instance)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.funcGet?&lt;span&gt;.Invoke(instance);
        }
    }
&lt;br/&gt;　&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; PropertySetter
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; Action&amp;lt;Object, Object&amp;gt;&lt;span&gt; setFunc;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; PropertySetter(PropertyInfo property)  
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (property == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)

            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArgumentNullException(nameof(property));
            }
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.setFunc =&lt;span&gt; CreateSetValueDelagate(property);
        }



        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Action&amp;lt;Object, Object&amp;gt;&lt;span&gt; CreateSetValueDelagate(PropertyInfo property)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; (object instance, object value) =&amp;gt; 
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     ((instanceType)instance).Set_XXX((propertyType)value)

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明方法需要的参数&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; param_instance = Expression.Parameter(&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(Object));
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; param_value = Expression.Parameter(&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(Object));

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; body_instance =&lt;span&gt; Expression.Convert(param_instance, property.DeclaringType);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; body_value =&lt;span&gt; Expression.Convert(param_value, property.PropertyType);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; body_call =&lt;span&gt; Expression.Call(body_instance, property.GetSetMethod(), body_value);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Expression.Lambda&amp;lt;Action&amp;lt;Object, Object&amp;gt;&amp;gt;&lt;span&gt;(body_call, param_instance, param_value).Compile();
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Invoke(Object instance, Object value)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.setFunc?&lt;span&gt;.Invoke(instance, value);
        }
    }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在将代码应用到实例：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
            Dog dog = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Dog();
            PropertyInfo propertyInfo &lt;/span&gt;=&lt;span&gt; dog.GetType().GetProperty(nameof(dog.Name));
            
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;反射操作&lt;/span&gt;
            propertyInfo.SetValue(dog, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;WLJ&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            String result &lt;/span&gt;= propertyInfo.GetValue(dog) &lt;span&gt;as&lt;/span&gt;&lt;span&gt; String;
            Console.WriteLine(result);
            
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;表达式树的操作&lt;/span&gt;
            Property property = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Property(propertyInfo);
            property.SetValue(dog, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;WLJ2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            String result2 &lt;/span&gt;= propertyInfo.GetValue(dog) &lt;span&gt;as&lt;/span&gt;&lt;span&gt; String;
            Console.WriteLine(result2);        &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;发现其实现的目的与反射一致，但效率却有明显的提高。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以下测试以下他们两之间的效率。测试代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
　　　　　　　Student student = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Student();
            PropertyInfo propertyInfo &lt;/span&gt;=&lt;span&gt; student.GetType().GetProperty(nameof(student.Name));
            Property ExpProperty &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Property(propertyInfo);

            Int32 loopCount &lt;/span&gt;= &lt;span&gt;1000000&lt;/span&gt;&lt;span&gt;;
            CodeTimer.Initialize();  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;测试环境初始化

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;下面该方法个执行1000000次&lt;/span&gt;
&lt;span&gt;
            CodeTimer.Time(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;基础反射&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, loopCount, () =&amp;gt;&lt;span&gt; { 
                propertyInfo.SetValue(student, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Fode&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
            });
            CodeTimer.Time(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lambda表达式树&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, loopCount, () =&amp;gt;&lt;span&gt; {
                ExpProperty.SetValue(student, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Fode&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            });
            CodeTimer.Time(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;直接赋值&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, loopCount, () =&amp;gt;&lt;span&gt; {
                student.Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Fode&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            });
            Console.ReadKey();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其.Net4.0环境下运行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1492898/201812/1492898-20181207011400903-700613590.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;.Net Core环境下运行结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1492898/201812/1492898-20181207012456124-578255456.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;从以上结果可以知道，迭代同样的次数反射需要183ms，而用表达式只要34ms，直接赋值需要7ms，在效率上，使用表达式这种方法有显著的提高，您可以看到使用此技术可以完全避免使用反射时的性能损失。反射之所以效率有点低主要取决于其加载的时候时在运行期下，而表达式则在编译期，下篇有空将会介绍用Emit技术优化反射，会比表达式略快一点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注：&lt;strong&gt;对于常用对象的属性，最好将其缓存起来，这样效率会更高。&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://pan.baidu.com/s/1SKxYoN8L5jwKojO5bwUUyA&quot;&gt;代码下载&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 06 Dec 2018 17:35:00 +0000</pubDate>
<dc:creator>Fode</dc:creator>
<og:description>本节重点不讲反射机制，而是讲lambda表达式树来替代反射中常用的获取属性和方法，来达到相同的效果但却比反射高效。 每个人都知道，用反射调用一个方法或者对属性执行SetValue和GetValue操作</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fode/p/10079630.html</dc:identifier>
</item>
<item>
<title>Go处理json数据 - 骏马金龙</title>
<link>http://www.cnblogs.com/f-ck-need-u/p/10080793.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-ck-need-u/p/10080793.html</guid>
<description>&lt;h2 id=&quot;json数据格式&quot;&gt;json数据格式&lt;/h2&gt;
&lt;p&gt;参见&lt;a href=&quot;https://www.cnblogs.com/f-ck-need-u/p/10078072.html&quot;&gt;json数据格式说明&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;如果没操作过json数据，建议先看下上面的文章，有助于理解本文后面的内容。&lt;/p&gt;
&lt;h2 id=&quot;go-json包&quot;&gt;Go json包&lt;/h2&gt;
&lt;p&gt;Marshal()：Go数据对象 -&amp;gt; json数据&lt;br/&gt;UnMarshal()：Json数据 -&amp;gt; Go数据对象&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func Marshal(v interface{}) ([]byte, error)
func Unmarshal(data []byte, v interface{}) error&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;构建json数据&quot;&gt;构建json数据&lt;/h3&gt;
&lt;p&gt;Marshal()和MarshalIndent()函数可以将数据封装成json数据。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;struct、slice、array、map都可以转换成json&lt;/strong&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;struct转换成json的时候，只有字段首字母大写的才会被转换&lt;/strong&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;map转换的时候，key必须为string&lt;/strong&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;封装的时候，如果是指针，会追踪指针指向的对象进行封装&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;例如：&lt;/p&gt;
&lt;p&gt;有一个struct结构：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;type Post struct {
    Id      int
    Content string
    Author  string
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个结构表示博客文章类型，有文章ID，文章内容，文章的提交作者。这没什么可说的，唯一需要指明的是：&lt;strong&gt;它是一个struct，struct可以封装(编码)成JSON数据&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;要将这段struct数据转换成json，只需使用Marshal()即可。如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;post := &amp;amp;Post{1, &quot;Hello World&quot;, &quot;userA&quot;}
b, err := json.Marshal(post)
if err != nil {
    fmt.Println(nil)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Marshal()返回的是一个&lt;code&gt;[]byte&lt;/code&gt;类型，现在变量b就已经存储了一段&lt;code&gt;[]byte&lt;/code&gt;类型的json数据，可以输出它：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;fmt.Println(string(b))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{&quot;Id&quot;:1,&quot;Content&quot;:&quot;Hello World&quot;,&quot;Author&quot;:&quot;userA&quot;}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以在封装成json的时候进行&quot;美化&quot;，使用MarshalIndent()即可自动添加前缀(前缀字符串一般设置为空)和缩进：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;c,err := json.MarshalIndent(post,&quot;&quot;,&quot;\t&quot;)
if err != nil {
    fmt.Println(nil)
}
fmt.Println(string(c))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    &quot;Id&quot;: 1,
    &quot;Content&quot;: &quot;Hello World&quot;,
    &quot;Author&quot;: &quot;userA&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;除了struct，array、slice、map结构都能解析成json，但是map解析成json的时候，key必须只能是string，这是json语法要求的。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// slice -&amp;gt; json
s := []string{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}
d, _ := json.MarshalIndent(s, &quot;&quot;, &quot;\t&quot;)
fmt.Println(string(d))

// map -&amp;gt; json
m := map[string]string{
    &quot;a&quot;:&quot;aa&quot;,
    &quot;b&quot;:&quot;bb&quot;,
    &quot;c&quot;:&quot;cc&quot;,
}
e,_ := json.MarshalIndent(m,&quot;&quot;,&quot;\t&quot;)
fmt.Println(string(e))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[
    &quot;a&quot;,
    &quot;b&quot;,
    &quot;c&quot;
]
{
    &quot;a&quot;: &quot;aa&quot;,
    &quot;b&quot;: &quot;bb&quot;,
    &quot;c&quot;: &quot;cc&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;使用struct-tag辅助构建json&quot;&gt;使用struct tag辅助构建json&lt;/h3&gt;
&lt;p&gt;struct能被转换的字段都是首字母大写的字段，但如果想要在json中使用小写字母开头的key，可以使用struct的tag来辅助反射。&lt;/p&gt;
&lt;p&gt;例如，Post结构增加一个首字母小写的字段createAt。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;type Post struct {
    Id      int      `json:&quot;ID&quot;`
    Content string   `json:&quot;content&quot;`
    Author  string   `json:&quot;author&quot;`
    Label   []string `json:&quot;label&quot;`
}


postp := &amp;amp;Post{
    2,
    &quot;Hello World&quot;,
    &quot;userB&quot;,
    []string{&quot;linux&quot;, &quot;shell&quot;},
    }

p, _ := json.MarshalIndent(postp, &quot;&quot;, &quot;\t&quot;)
fmt.Println(string(p))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    &quot;ID&quot;: 2,
    &quot;content&quot;: &quot;Hello World&quot;,
    &quot;author&quot;: &quot;userB&quot;,
    &quot;label&quot;: [
        &quot;linux&quot;,
        &quot;shell&quot;
    ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用struct tag的时候，几个注意点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;tag中标识的名称将称为json数据中key的值&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;tag可以设置为&lt;code&gt;`json:&quot;-&quot;`&lt;/code&gt;来表示本字段不转换为json数据，即使这个字段名首字母大写
&lt;ul&gt;&lt;li&gt;如果想要json key的名称为字符&quot;-&quot;，则可以特殊处理&lt;code&gt;`json:&quot;-,&quot;`&lt;/code&gt;，也就是加上一个逗号&lt;br/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;如果tag中带有&lt;code&gt;,omitempty&lt;/code&gt;选项，那么如果这个字段的值为0值，即false、0、&quot;&quot;、nil等，这个字段将不会转换到json中&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;如果字段的类型为bool、string、int类、float类，而tag中又带有&lt;code&gt;,string&lt;/code&gt;选项，那么这个字段的值将转换成json字符串&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;type Post struct {
    Id      int      `json:&quot;ID,string&quot;`
    Content string   `json:&quot;content&quot;`
    Author  string   `json:&quot;author&quot;`
    Label   []string `json:&quot;label,omitempty&quot;`
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;解析json数据到struct结构已知&quot;&gt;解析json数据到struct(结构已知)&lt;/h3&gt;
&lt;p&gt;json数据可以解析到struct或空接口&lt;code&gt;interface{}&lt;/code&gt;中(也可以是slice、map等)。理解了上面构建json时的tag规则，理解解析json就很简单了。&lt;/p&gt;
&lt;p&gt;例如，下面是一段json数据：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    &quot;id&quot;: 1,
    &quot;content&quot;: &quot;hello world&quot;,
    &quot;author&quot;: {
        &quot;id&quot;: 2,
        &quot;name&quot;: &quot;userA&quot;
    },
    &quot;published&quot;: true,
    &quot;label&quot;: [],
    &quot;nextPost&quot;: null,
    &quot;comments&quot;: [{
            &quot;id&quot;: 3,
            &quot;content&quot;: &quot;good post1&quot;,
            &quot;author&quot;: &quot;userB&quot;
        },
        {
            &quot;id&quot;: 4,
            &quot;content&quot;: &quot;good post2&quot;,
            &quot;author&quot;: &quot;userC&quot;
        }
    ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;分析下这段json数据：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;顶层的大括号表示是一个匿名对象，映射到Go中是一个struct，假设这个struct名称为Post&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;顶层大括号里的都是Post结构中的字段，这些字段因为都是json数据，所以必须都首字母大写，同时设置tag，tag中的名称小写&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;其中author是一个子对象，映射到Go中是另一个struct，在Post中这个字段的名称为Author，假设名称和struct名称相同，也为Author&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;label是一个数组，映射到Go中可以是slice，也可以是array，且因为json array为空，所以Go中的slice/array类型不定，比如可以是int，可以是string，也可以是&lt;code&gt;interface{}&lt;/code&gt;，对于这里的示例来说，我们知道标签肯定是string&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;nextPost是一个子对象，映射到Go中是一个struct，但因为json中这个对象为null，表示这个对象不存在，所以无法判断映射到Go中struct的类型。但对此处的示例来说，是没有下一篇文章，所以它的类型应该也是Post类型&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;comment是子对象，且是数组包围的，映射到Go中，是一个slice/array，slice/array的类型是一个struct&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;分析之后，对应地去构建struct和struct的tag就很容易了。如下，是根据上面分析构建出来的数据结构：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;type Post struct {
    ID        int64         `json:&quot;id&quot;`       
    Content   string        `json:&quot;content&quot;`  
    Author    Author        `json:&quot;author&quot;`   
    Published bool          `json:&quot;published&quot;`
    Label     []string      `json:&quot;label&quot;`    
    NextPost  *Post         `json:&quot;nextPost&quot;` 
    Comments  []*Comment    `json:&quot;comments&quot;` 
}

type Author struct {
    ID   int64  `json:&quot;id&quot;`  
    Name string `json:&quot;name&quot;`
}

type Comment struct {
    ID      int64  `json:&quot;id&quot;`     
    Content string `json:&quot;content&quot;`
    Author  string `json:&quot;author&quot;` 
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意，前面在介绍构建json数据的时候说明过，指针会进行追踪，所以这里反推出来的struct中使用指针类型是没问题的。&lt;/p&gt;
&lt;p&gt;于是，解析上面的json数据到Post类型的对象中，假设这个json数据存放在a.json文件中。代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func main() {
    // 打开json文件
    fh, err := os.Open(&quot;a.json&quot;)
    if err != nil {
        fmt.Println(err)
        return
    }
    defer fh.Close()
    // 读取json文件，保存到jsonData中
    jsonData, err := ioutil.ReadAll(fh)
    if err != nil {
        fmt.Println(err)
        return
    }
    
    var post Post
    // 解析json数据到post中
    err = json.Unmarshal(jsonData, &amp;amp;post)
    if err != nil {
        fmt.Println(err)
        return
    }
    fmt.Println(post)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{1 hello world {2 userA} true [] &amp;lt;nil&amp;gt; [0xc042072300 0xc0420723c0]}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也许你已经感受到了，从json数据反推算struct到底有多复杂，虽然逻辑不难，但如果数据复杂一点，这是件非常恶心的事情。所以，使用别人写好的工具来自动转换吧。本文后面有推荐json到数据结构的自动转换工具。&lt;/p&gt;
&lt;h3 id=&quot;解析json到interface结构未知&quot;&gt;解析json到interface(结构未知)&lt;/h3&gt;
&lt;p&gt;上面是已知json数据结构的解析方式，如果json结构是未知的或者结构可能会发生改变的情况，则解析到struct是不合理的。这时可以解析到空接口&lt;code&gt;interface{}&lt;/code&gt;或&lt;code&gt;map[string]interface{}&lt;/code&gt;类型上，这两种类型的结果是完全一致的。&lt;/p&gt;
&lt;p&gt;解析到&lt;code&gt;interface{}&lt;/code&gt;上时，Go类型和JSON类型的对应关系如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  JSON类型             Go类型                
---------------------------------------------
JSON objects    &amp;lt;--&amp;gt;  map[string]interface{} 
JSON arrays     &amp;lt;--&amp;gt;  []interface{}          
JSON booleans   &amp;lt;--&amp;gt;  bool                   
JSON numbers    &amp;lt;--&amp;gt;  float64                
JSON strings    &amp;lt;--&amp;gt;  string                 
JSON null       &amp;lt;--&amp;gt;  nil                    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func main() {
    // 读取json文件
    fh, err := os.Open(&quot;a.json&quot;)
    if err != nil {
        fmt.Println(err)
        return
    }
    defer fh.Close()
    jsonData, err := ioutil.ReadAll(fh)
    if err != nil {
        fmt.Println(err)
        return
    }
    
    // 定义空接口接收解析后的json数据
    var unknown interface{}
    // 或：map[string]interface{} 结果是完全一样的
    err = json.Unmarshal(jsonData, &amp;amp;unknown)
    if err != nil {
        fmt.Println(err)
        return
    }
    fmt.Println(unknown)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;map[nextPost:&amp;lt;nil&amp;gt; comments:[map[id:3 content:good post1
author:userB] map[id:4 content:good post2 author:userC]]
id:1 content:hello world author:map[id:2 name:userA] published:true label:[]]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面将输出map结构。这是显然的，因为类型对应关系中已经说明了，json object解析到Go interface的时候，对应的是map结构。如果将上面输出的结构进行一下格式化，得到的将是类似下面的结构：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;map[
    nextPost:&amp;lt;nil&amp;gt;
    comments:[
        map[
            id:3
            content:good post1
            author:userB
        ]
        map[
            id:4
            content:good post2
            author:userC
        ]
    ]
    id:1
    content:hello world
    author:map[
        id:2
        name:userA
    ]
    published:true
    label:[]
]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在，可以从这个map中去判断类型、取得对应的值。但是如何判断类型？可以使用类型断言：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func main() {
    // 读取json数据
    fh, err := os.Open(&quot;a.json&quot;)
    if err != nil {
        fmt.Println(err)
        return
    }
    defer fh.Close()
    jsonData, err := ioutil.ReadAll(fh)
    if err != nil {
        fmt.Println(err)
        return
    }
    
    // 解析json数据到interface{}
    var unknown interface{}
    err = json.Unmarshal(jsonData, &amp;amp;unknown)
    if err != nil {
        fmt.Println(err)
        return
    }

    // 进行断言，并switch匹配
    m := unknown.(map[string]interface{})
    for k, v := range m {
        switch vv := v.(type) {
        case string:
            fmt.Println(k, &quot;type: string\nvalue: &quot;, vv)
            fmt.Println(&quot;------------------&quot;)
        case float64:
            fmt.Println(k, &quot;type: float64\nvalue: &quot;, vv)
            fmt.Println(&quot;------------------&quot;)
        case bool:
            fmt.Println(k, &quot;type: bool\nvalue: &quot;, vv)
            fmt.Println(&quot;------------------&quot;)
        case map[string]interface{}:
            fmt.Println(k, &quot;type: map[string]interface{}\nvalue: &quot;, vv)
            for i, j := range vv {
                fmt.Println(i,&quot;: &quot;,j)
            }
            fmt.Println(&quot;------------------&quot;)
        case []interface{}:
            fmt.Println(k, &quot;type: []interface{}\nvalue: &quot;, vv)
            for key, value := range vv {
                fmt.Println(key, &quot;: &quot;, value)
            }
            fmt.Println(&quot;------------------&quot;)
        default:
            fmt.Println(k, &quot;type: nil\nvalue: &quot;, vv)
            fmt.Println(&quot;------------------&quot;)
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;comments type: []interface{}
value:  [map[id:3 content:good post1 author:userB] map[author:userC id:4 content:good post2]]
0 :  map[id:3 content:good post1 author:userB]
1 :  map[id:4 content:good post2 author:userC]
------------------
id type: float64
value:  1
------------------
content type: string
value:  hello world
------------------
author type: map[string]interface{}
value:  map[id:2 name:userA]
name :  userA
id :  2
------------------
published type: bool
value:  true
------------------
label type: []interface{}
value:  []
------------------
nextPost type: nil
value:  &amp;lt;nil&amp;gt;
------------------&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可见，从interface中解析非常复杂，而且可能因为嵌套结构而导致无法正确迭代遍历。这时候，可以使用第三方包simplejson，见后文。&lt;/p&gt;
&lt;h2 id=&quot;解析创建json流&quot;&gt;解析、创建json流&lt;/h2&gt;
&lt;p&gt;除了可以直接解析、创建json数据，还可以处理流式数据。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;type Decoder解码json到Go数据结构&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;type Encoder编码Go数据结构到json&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const jsonStream = `
    {&quot;Name&quot;: &quot;Ed&quot;, &quot;Text&quot;: &quot;Knock knock.&quot;}
    {&quot;Name&quot;: &quot;Sam&quot;, &quot;Text&quot;: &quot;Who's there?&quot;}
    {&quot;Name&quot;: &quot;Ed&quot;, &quot;Text&quot;: &quot;Go fmt.&quot;}
    {&quot;Name&quot;: &quot;Sam&quot;, &quot;Text&quot;: &quot;Go fmt who?&quot;}
    {&quot;Name&quot;: &quot;Ed&quot;, &quot;Text&quot;: &quot;Go fmt yourself!&quot;}
`
type Message struct {
    Name, Text string
}
dec := json.NewDecoder(strings.NewReader(jsonStream))
for {
    var m Message
    if err := dec.Decode(&amp;amp;m); err == io.EOF {
        break
    } else if err != nil {
        log.Fatal(err)
    }
    fmt.Printf(&quot;%s: %s\n&quot;, m.Name, m.Text)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Ed: Knock knock.
Sam: Who's there?
Ed: Go fmt.
Sam: Go fmt who?
Ed: Go fmt yourself!&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再例如，从标准输入读json数据，解码后删除名为Name的元素，最后重新编码后输出到标准输出。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func main() {
    dec := json.NewDecoder(os.Stdin)
    enc := json.NewEncoder(os.Stdout)
    for {
        var v map[string]interface{}
        if err := dec.Decode(&amp;amp;v); err != nil {
            log.Println(err)
            return
        }
        for k := range v {
            if k != &quot;Name&quot; {
                delete(v, k)
            }
        }
        if err := enc.Encode(&amp;amp;v); err != nil {
            log.Println(err)
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;json转go数据结构工具推荐&quot;&gt;json转Go数据结构工具推荐&lt;/h2&gt;
&lt;p&gt;quicktype工具，可以轻松地将json文件转换成各种语言对应的数据结构。&lt;/p&gt;
&lt;p&gt;地址：&lt;a href=&quot;https://quicktype.io&quot; class=&quot;uri&quot;&gt;https://quicktype.io&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在vscode中有相关插件&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;先在命令面板中输入&quot;set quicktype target language&quot;选择要将json转换成什么语言的数据结构(比如Go)&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;再输入&quot;open quicktype for json&quot;就可以将当前json文件转换对应的数据结构(比如struct)&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;转换后只需按实际的需求稍微修改一部分类型即可。比如为json顶级匿名对象对应的struct设定名称，还有一些无法转换成struct时因为判断数据类型而使用的&lt;code&gt;interface{}&lt;/code&gt;类型也要改一改。&lt;/p&gt;
&lt;p&gt;例如，下面是使用quicktype工具对前面示例json数据进行转换后的数据结构：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;type A struct {
    ID        int64         `json:&quot;id&quot;`       
    Content   string        `json:&quot;content&quot;`  
    Author    Author        `json:&quot;author&quot;`   
    Published bool          `json:&quot;published&quot;`
    Label     []interface{} `json:&quot;label&quot;`    
    NextPost  interface{}   `json:&quot;nextPost&quot;` 
    Comments  []Comment     `json:&quot;comments&quot;` 
}

type Author struct {
    ID   int64  `json:&quot;id&quot;`  
    Name string `json:&quot;name&quot;`
}

type Comment struct {
    ID      int64  `json:&quot;id&quot;`     
    Content string `json:&quot;content&quot;`
    Author  string `json:&quot;author&quot;` 
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中需要将&lt;code&gt;type A struct&lt;/code&gt;的A改成你自己的名称，将A中的&lt;code&gt;interface{}&lt;/code&gt;也改成合理的类型。&lt;/p&gt;
</description>
<pubDate>Thu, 06 Dec 2018 16:46:00 +0000</pubDate>
<dc:creator>骏马金龙</dc:creator>
<og:description>json数据格式 参见</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-ck-need-u/p/10080793.html</dc:identifier>
</item>
<item>
<title>实现BX的内容加上123 并把和送到寄存器AX - 粥里有勺糖</title>
<link>http://www.cnblogs.com/roseAT/p/10080746.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/roseAT/p/10080746.html</guid>
<description>&lt;p&gt;① 一条指令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;LEA&lt;/span&gt; AX,[BX+&lt;span&gt;123&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;②两条指令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;ADD&lt;/span&gt; BX,&lt;span&gt;123&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;MOV&lt;/span&gt; AX,BX
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Tips:&lt;/p&gt;
&lt;p&gt;LEA指令与MOV指令的区别:&lt;/p&gt;
&lt;p&gt;①&lt;/p&gt;
&lt;p&gt;MOV指令是 &lt;span&gt;数据        &lt;span&gt;传送&lt;/span&gt;&lt;/span&gt;指令-------传送数据&lt;/p&gt;
&lt;p&gt;LEA指令是  &lt;span&gt; 有效地址&lt;/span&gt; 传送指令-------取偏移地址&lt;/p&gt;
&lt;p&gt;②&lt;/p&gt;
&lt;p&gt;MOV OPRD1 OPRD2&lt;/p&gt;
&lt;p&gt;OPRD1: 目的操作数(寄存器,存储器,累加器)&lt;/p&gt;
&lt;p&gt;OPRD2: 源操作数(寄存器,存储器,累加器,立即数)&lt;/p&gt;
&lt;p&gt;例如:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;MOV&lt;/span&gt; DI,BX  &lt;span&gt;;&lt;/span&gt;&lt;span&gt;寄存器到寄存器之间传数&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1 MOV&lt;/span&gt; AL,23H &lt;span&gt;;&lt;/span&gt;&lt;span&gt;将立即数&quot;复制&quot;到寄存器&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;MOV&lt;/span&gt; [2000H],02H &lt;span&gt;;&lt;/span&gt;&lt;span&gt;直接地址&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意:&lt;/p&gt;
&lt;p&gt;目的操作数要与源操作数类型一致,不能一个字一个字节&lt;/p&gt;
&lt;p&gt;目的或者源操作数之一必须是要有明确的类型&lt;/p&gt;
&lt;p&gt;立即数不能作为目的操作数&lt;/p&gt;
&lt;p&gt;不能用立即寻址的方法给段寄存器传数&lt;/p&gt;
&lt;p&gt;段寄存器or存储单元之间 不能用MOV指令直接传送&lt;/p&gt;
&lt;p&gt;&lt;span&gt;----------------------------------------------我是华丽的分割线--------------------------------------------&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;LEA OPRD1,OPRD2  ;格式&lt;/p&gt;
&lt;p&gt;OPRD1: 目的操作数,可为任意一个16位的通用寄存器&lt;/p&gt;
&lt;p&gt;OPRD2:源操作数(变量名,标号,地址表达式)&lt;/p&gt;
&lt;p&gt;例如:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;LEA&lt;/span&gt; AX,[BX+&lt;span&gt;123&lt;/span&gt;] &lt;span&gt;;&lt;/span&gt;&lt;span&gt;BX的内容加上123并把它送到寄存器AX&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;LEA&lt;/span&gt; BX,data
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;LEA&lt;/span&gt; AX,[1234H] &lt;span&gt;;&lt;/span&gt;&lt;span&gt;作用是将源操作数[1234H]的偏移地址送到AX&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;;&lt;/span&gt;&lt;span&gt;等价于&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;MOV&lt;/span&gt; AX,1234H
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Thu, 06 Dec 2018 16:33:00 +0000</pubDate>
<dc:creator>粥里有勺糖</dc:creator>
<og:description>① 一条指令 ②两条指令 Tips: LEA指令与MOV指令的区别: ① MOV指令是 数据 传送指令 传送数据 LEA指令是 有效地址 传送指令 取偏移地址 ② MOV OPRD1 OPRD2 OP</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/roseAT/p/10080746.html</dc:identifier>
</item>
<item>
<title>谈谈代码中的this - Devin_n</title>
<link>http://www.cnblogs.com/zdf-xue/p/10080739.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zdf-xue/p/10080739.html</guid>
<description>&lt;p&gt;　　js中我们常常会遇到this，this的具体指向问题对于很多同学来说是很懵懂的；就想lz刚开始接触时候就是一脸的懵逼，经常被一些题目转的眼花缭乱。那么今天lz就跟大家一起交流一下这个this的指向问题！&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;背景：&lt;/strong&gt;不久前有个同事给我们发了一道有关this的题目，于是便有了今天的故事。如下题：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; D0XX {
  constructor () {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.attr =&lt;span&gt; {};
  }
  init (config) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.assign(config)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
  }
  assign (config) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.attr.afterClose =&lt;span&gt; config.afterClose;
  }
  close(){
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;typeof&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.attr.afterClose === &lt;span&gt;'&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;){
          &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.attr.afterClose();
      }
  }
}
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; T0XX{
    init(){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.openPop()
    }
    openPop(){
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; D0XX().init({
            afterClose(){
                console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;)
            }
        }).close()
    }
}
&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; T0XX().init();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;請問打印出結果是什麼？&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　一、且搁下此题目，我们先谈谈this的指向的以下几个情况；&lt;/p&gt;
&lt;p&gt;　　1.1.指向全局对象上；&lt;/p&gt;
&lt;p&gt;　　　　我们在一般的函数调用中的this是直接指向我们的全局对象的，比如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; globalThis(){
    console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;今天天氣真冷哇&lt;/span&gt;
&lt;span&gt;} 
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; name = '今天天氣真冷哇'&lt;span&gt;
globalThis();

setTimeout(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name2);
},&lt;/span&gt;1000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; name2 = '過了一秒鐘，我就更冷了'
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　这里的setTimeout里面的this是指向window对象的！&lt;/p&gt;
&lt;p&gt;　　1.2.指向上文对象&lt;/p&gt;
&lt;p&gt;　　　　通俗点就是，哪个对象看上了我，我就跟谁，比如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; foo() {
    console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.a);
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; obj =&lt;span&gt; {
    a: &lt;/span&gt;'李四'&lt;span&gt;,
    foo: foo
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; a = '張三'&lt;span&gt;;
obj.foo(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;李四  看前面是哪个对象（obj）,于是this跟obj一见钟情就好上了&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; bar =&lt;span&gt; obj.foo;
bar();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;張三 你以为的以为。。 前面说过看对象，没对象，那就只能全局对象上茫茫人海只为寻她&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　1.3.指向那个‘类’&lt;/p&gt;
&lt;p&gt;　　　　我们一般用构造函数进行调用时，会产生一个this始终是指向这个‘类’，我们复习下new 一个对象发生了什么：　&lt;/p&gt;
&lt;p&gt;　　　　　1.创建一个全新的对象。&lt;/p&gt;
&lt;p&gt;　　　　　2.这个对象会被执行[[Prototype]]连接。&lt;/p&gt;
&lt;p&gt;　　　　　3.这个新对象会绑定到函数调用的&lt;code&gt;this&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;　　　　　4.执行这个函数里的代码。&lt;/p&gt;
&lt;p&gt;　　　　　5.如果函数没有返回其他对象，则自动返回这个新对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fun() {
  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.a = 1&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.b = 2&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; instance = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; fun();
console.log(instance.a);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　1.4.箭头函数this指向当前作用域&lt;/p&gt;
&lt;p&gt;　　　　箭头函数this指向取决于外层的函数作用域或全局作用域，而且箭头函数的绑定无法修改，即使是&lt;code&gt;new&lt;/code&gt;绑定也不可以。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
document.onclick = ()=&amp;gt;&lt;span&gt;{
    console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;window&lt;/span&gt;
&lt;span&gt;}
document.onclick&lt;/span&gt;=&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;document&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　二、如何改变this的绑定关系&lt;/p&gt;
&lt;p&gt;　　　　2.1.显式绑定&lt;/p&gt;
&lt;p&gt;　　　　在此之前，相信你已经用过很多次&lt;code&gt;apply&lt;/code&gt;和&lt;code&gt;call、&lt;/code&gt;bind&lt;span&gt;函数了，使用这三个函数可以直接为你要执行的函数指定&lt;/span&gt;&lt;code&gt;this&lt;/code&gt;&lt;span&gt;，所以这种方式称为显式绑定。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; foo () {
  console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.a)
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; obj =&lt;span&gt; {
  a: &lt;/span&gt;2&lt;span&gt;
}
foo.call(obj) &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;

&lt;span&gt;function&lt;/span&gt;&lt;span&gt; foo (something) {
  console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.a, something)
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.a +&lt;span&gt; something
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; obj =&lt;span&gt; {
  a: &lt;/span&gt;2&lt;span&gt;
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; bar = foo.bind(obj); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; bind返回一个绑定到obj上的新函数&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; b = bar(3&lt;span&gt;)
console.log(b)
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; a = &quot;window's a&quot;&lt;span&gt;
foo(&lt;/span&gt;'!')
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　如上就可以通过这种显式的方法进行改变绑定关系了；&lt;/p&gt;
&lt;p&gt;　　三、回归到之前同事的题目上&lt;/p&gt;
&lt;p&gt;　　通过以上的分析，我们就能够很清楚的分析出以上的答案是指向this.attr这个对象的，别看题目里又有new字符又有return this；这些东西，很容易让人迷糊；但是如果我们能掌握住this的这几种指向情况，相信会易容反掌的多；&lt;/p&gt;
&lt;p&gt;　　四、如果改动以上的题目你还知道么？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class D0XX {
  constructor () {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.attr =&lt;span&gt; {}
  }
  init (config) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.assign(config)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;
  }
  assign (config) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.afterClose =&lt;span&gt; config.afterClose
  }
  close(){
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;typeof&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.afterClose === 'function'&lt;span&gt;){
          &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.afterClose()
      }
  }
}
class T0XX{
    init(){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.openPop()
    }
    openPop(){
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; D0XX().init({
            afterClose(){
                console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;)
            }
        }).close()
    }
}
&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; T0XX().init()
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;請問打印出結果是什麼？&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　最后，小Tip~就是之所以demo中可以使用链式调用是因为init方法中return出了this；这就跟jQuery中的链式调用有了异曲同工之妙；&lt;/p&gt;
&lt;p&gt;　　如有不妥，欢迎指教！&lt;/p&gt;





&lt;div&gt;&lt;img src=&quot;c:/Users/Administrator/AppData/Local/YNote/data/qqD222F7412CB5C3E553D7D0946C4CCAFD/495a12ce0d7b4a0c92d780c9ac6155bc/clipboard.png&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-attr-org-src-id=&quot;AB19BC08D0D54AE29F1258A849CCB685&quot;/&gt;&lt;/div&gt;

</description>
<pubDate>Thu, 06 Dec 2018 16:32:00 +0000</pubDate>
<dc:creator>Devin_n</dc:creator>
<og:description>js中我们常常会遇到this，this的具体指向问题对于很多同学来说是很懵懂的；就想lz刚开始接触时候就是一脸的懵逼，经常被一些题目转的眼花缭乱。那么今天lz就跟大家一起交流一下这个this的指向问题</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zdf-xue/p/10080739.html</dc:identifier>
</item>
<item>
<title>关于DeferredResult的思考 - 冰魄秋雨</title>
<link>http://www.cnblogs.com/skyice/p/10080612.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/skyice/p/10080612.html</guid>
<description>&lt;p&gt;使用SpringBoot搭建web程序，里面内置了tomcat，一般都不会关心内部实现机制，上来就可以写程序，并且可以跑起来。但是是思考了每次的请求是如何工作的。&lt;br/&gt;简单的来讲就是tomcat是将每次请求都将封装成一个Servlet,该Servlet来运行完业务逻辑代码，然后再有tomcat将信息返回给调用方。每个Servlet是同步的。即在该servlet的业务逻辑做完了然后才释放掉该Servlet。&lt;br/&gt;但是servlet3提供了一个异步的机制，即每次请求过来之后，可以先释放该请求，但是会保存一些信息。业务逻辑由程序其他线程来处理，处理完成后将其值设置到DeferredResult里面。然后再由容器将返回值返回给前端。&lt;br/&gt;这样做的好处：实现出现请求与业务IO分开，程序能够处理更多的请求。&lt;br/&gt;网上可以找到其他例子来学习DeferredResult是如何运行的，即在请求内部开启一个线程来处理&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@GetMapping
public DeferredResult&amp;lt;String&amp;gt; queryDevice(){
    DeferredResult&amp;lt;String&amp;gt; def = new DeferredResult&amp;lt;&amp;gt;();
    new Thread(()-&amp;gt;{
        //处理业务逻辑
        def.setResult(&quot;处理后的结果&quot;);
    }).start();
    return def;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样很好理解，但是不能这样做，为什么，因为每一次线程的创建销毁是消耗资源的，这样频繁的创建和销毁非常影响性能。这个时候，可以提使用线程池来处理，对是可以这样做的。是的，可以这样做，但是需要考虑到，在某一时刻，可能会产生几千个线程，这样是非常多的，如果加上tomcat创建的Servlet线程数，那确实挺消耗资源的。&lt;br/&gt;上面已经有了一个可行的方案，这里提供我的一个思考，该思考是Java8新特性之后常用到的一个。&lt;/p&gt;
&lt;p&gt;下面有三个类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public abstract class Actor {

  public enum ActorType {
    ITC,  /* 立刻消费. */

    BLOCKING;  /* 阻塞.*/
  }
  /**
   * actor类型.
   */
  public ActorType type;
  /**
   * actor名.
   */
  public String name;
  public Actor(ActorType type) {
    this.type = type;
    this.name = this.getClass().getSimpleName();
  }
  /**
   * 任务消费
   */
  public void future(Consumer&amp;lt;Void&amp;gt; c) {
    if (this.type.ordinal() == ActorType.BLOCKING.ordinal()) {//阻塞
      ((ActorBlocking) this).push(c);
      return;
    } else {
      Misc.exeConsumer(c, null);
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;public class ActorBlocking extends Actor {

  /**
   * 等待处理的Consumer.
   */
  private ConcurrentLinkedQueue&amp;lt;Consumer&amp;lt;Void&amp;gt;&amp;gt; cs = new ConcurrentLinkedQueue&amp;lt;&amp;gt;();
  /**
   * 拥有线程的个数
   */
  private int tc = 1;

  /**
   * cs的size
   */
  private AtomicInteger size = new AtomicInteger(0);

  /**
   * 线程忙？
   */
  public volatile boolean busy = false;

  public ActorBlocking() {
    super(ActorType.BLOCKING);
  }

  /**
   * 添加任务.
   */
  public void push(Consumer&amp;lt;Void&amp;gt; c) {
    this.cs.add(c);
    this.size.incrementAndGet();
    synchronized (this) {//通知线程消费信息
      this.notify();
    }
  }

  /**
   * 线程忙?
   */
  public boolean isBusy() {
    return this.busy;
  }

  /**
   * 队列尺寸.
   */
  public int size() {
    return this.size.get();
  }

  public int getTc() {
    return tc;
  }

  public void setTc(int tc) {
    this.tc = tc &amp;lt; 1 ? 1 : tc;
  }

  /**
   * 启动线程
   */
  protected void start() {
    ActorBlocking ab = this;
    ExecutorService ex = Executors.newFixedThreadPool(this.tc);//创建线程池
    for (int i = 0; i &amp;lt; tc; i++) {
      ex.execute(() -&amp;gt; {
        while (true) {
          ab.run();
        }
      });
    }
  }

  /**
   * 抢占式消费任务
   */
  private void run() {
    Consumer&amp;lt;Void&amp;gt; c = this.cs.poll();
    if (c == null) {
      synchronized (this) {
        try {
          this.wait();
        } catch (InterruptedException e) {
        }
      }
      c = this.cs.poll();
    }
    if (c != null) /* 抢占式. */ {
      this.size.decrementAndGet();
      this.busy = true;
      Misc.exeConsumer(c, null);
      this.busy = false;
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;@Component
public class AppActorBlocking extends ActorBlocking {
   //可以设置CPU*2的     
  private int threadSize = 4;

  public AppActorBlocking() {
    this.setTc(threadSize);//设置线程数量
    this.start();
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该方法是工具Misc类总的方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; /**
   * 执行Consumer并将异常化解在内部.
   */
  public static final &amp;lt;T&amp;gt; boolean exeConsumer(Consumer&amp;lt;T&amp;gt; c, T t) {
    try {
      c.accept(t);
      return true;
    } catch (Exception e) {
      if (logger.isWarnEnabled()) {
        logger.warn(&quot;{}&quot;, Misc.trace(new Throwable()));
      }
      if (logger.isWarnEnabled()) {
        logger.warn(&quot;t: {}, e: {}&quot;, t, Misc.trace(e));
      }
      return false;
    }
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如何调用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Autowired
public AppActorBlocking appBlocking;

public void method(){
    appBlocking.future(v-&amp;gt;{
        //处理逻辑代码
    });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码理解是所有的业务逻辑都是一个个Task,每一次请求过来，那么我就将业务逻辑代码生成一个Task，放入到队列中，然后由线程去取其中的任务来消费。&lt;br/&gt;这里仅仅是换了一个思路，不是由线程池去创建线程来处理，而是创建几个线程，然后抢占式的去消费任务，而过来的每次请求，都会放入到队列中。&lt;/p&gt;
&lt;p&gt;DeferredResult的异步处理能够提升一些服务器的性能，处理更多的连接数，但是一个WEB程序，处理连接数还与内置默认的tomcat相关（SpringBoot下还有其他容器），即tomcat默认的处理最大连接数为200,除了最大连接数，还有一个tomcat的最大处理线程数，如果该处设置小了，那么并发也一定会小，在设置这些之外，需要设置一个等待队列的大小，总有一些请求是不能被处理的，但又不能拒绝掉，否则用户体验特别不好，那么就进入到等待队列中，等tomcat有空闲的线程再来处理等待队列中的线程。&lt;/p&gt;
&lt;p&gt;至于什么时候用到该DeferredResult，如果是访问量不大的程序，如管理系统，没必要使用到这个，毕竟没有访问量，反而增大了开发量，但是如果做了很好的封装，那么就没关系了，这个就考量各自程序员的水平了。&lt;/p&gt;
</description>
<pubDate>Thu, 06 Dec 2018 16:09:00 +0000</pubDate>
<dc:creator>冰魄秋雨</dc:creator>
<og:description>使用SpringBoot搭建web程序，里面内置了tomcat，一般都不会关心内部实现机制，上来就可以写程序，并且可以跑起来。但是是思考了每次的请求是如何工作的。 简单的来讲就是tomcat是将每次请</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/skyice/p/10080612.html</dc:identifier>
</item>
<item>
<title>Windows10安装MariaDB - Jiaweit</title>
<link>http://www.cnblogs.com/jiaweit/p/10080599.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jiaweit/p/10080599.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;截至写这篇博客为止，MariaDB官方的稳定版本为，详情访问官方地址：&lt;a href=&quot;https://downloads.mariadb.org/&quot;&gt;https://downloads.mariadb.org/&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;          &lt;img src=&quot;https://img2018.cnblogs.com/blog/1540757/201812/1540757-20181206225954826-2100258009.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;安装之前先简单说一下MariaDB:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;        MariaDB由MySQL的创始人麦克尔·维德纽斯主导开发，他早前曾以10亿美元的价格，将自己创建的公司MySQL卖给了SUN，此后，随着SUN被甲骨文收购，MySQL的所有权也落入Oracle的手中。甲骨文公司收购了MySQL后，有将MySQL闭源的潜在风险,因此开源社区采用分支的方式来避开这个风险。所以说呢，MariaDB数据库管理系统是MySQL的一个分支，主要由开源社区在维护，采用GPL授权许可。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;       MariaDB跟MySQL在绝大多数方面是兼容的，&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;包括API和命令行。&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;对于开发者来说，几乎感觉不到任何不同。但MariaDB不仅仅是Mysql的一个替代品，&lt;/span&gt;&lt;span&gt;MariaDB在5.5版本以前，均依照MySQL的版本。但从2012年11月12日起发布的10.0.0版开始，不再依照MySQL的版号。10.0.x版以5.5版为基础，加上移植自MySQL 5.6版的功能和自行开发的新功能。在存储引擎方面，10.0.9版起使用XtraDB（名称代号为Aria）来代替MySQL的InnoDB。目前，新版本发布速度已经超过了Oracle官方的MySQL版本。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;进入正题：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　在MariaDB10.2.17 以前。解压后在目录下看到my-huge.ini、my-innodb-heavy-4G.ini、my-large.ini、my-medium.ini、my-small.ini 5个文件，根据机子内存大小复制一个适合自己的，然后命令为my.ini，然后通过配置环境变量，执行&quot;mysqld --install mariadb&quot;来进行安装服务，但是在&lt;/strong&gt;MariaDB10.2.17以后，已经没有&lt;strong&gt;my-huge.ini、my-innodb-heavy-4G.ini、my-large.ini、my-medium.ini、my-small.ini 5个文件了，安装也变得更简单，可以自动生成配置文件！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;      第一步：从官网下载mariadb-10.3.11-winx64.zip后，解压到自定义的目录下。&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;      第二步：配置一下环境变量（这个看个人，如果不想配也可以），打开dos窗口（不配的话，&lt;/strong&gt;&lt;strong&gt;&lt;strong&gt;dos进入到bin目录下&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;），执行 mysqld.exe --install mariadb (mariadb 为服务名，可以自定义)，然后你就会看到：Service successfully installed.&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;     第三步：启动服务：net start mariadb ，对应的关闭服务： net stop mariadb&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;     第四步：由于之前没有配置密码，执行mysql -uroot， 空密码登陆，登陆后切换数据库：use mysql ， 这个时候可以设置自己的密码了,执行命令：update user set password=password(&quot;123456&quot;) where user=&quot;root&quot;;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1540757/201812/1540757-20181206234819057-1156639985.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;   第五步：执行quit命令退出来，测试一下，可以使用刚设置的新密码登陆了&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;   第六步:  MariaDB的默认编码是latin1，插入中文会乱码，因此需要将编码改为utf8。登陆后，进入mysql数据库，执行命令：show variables like 'character%'   来查询当前mysql数据库的所有属性的字符编码，如下图：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1540757/201812/1540757-20181206235543254-791882805.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;依次执行下列命令，如果已经默认为utf-8 的则可以跳过：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1540757/201812/1540757-20181206235746281-96469974.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;设置完成后，再次执行命令： show variables like 'character%';&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1540757/201812/1540757-20181206235850215-714363844.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;至此，Windows10安装以安装完成，如果转载请注明出处！！！！！！！！！！&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 06 Dec 2018 16:05:00 +0000</pubDate>
<dc:creator>Jiaweit</dc:creator>
<og:description>截至写这篇博客为止，MariaDB官方的稳定版本为，详情访问官方地址：https://downloads.mariadb.org/ 安装之前先简单说一下MariaDB: MariaDB由MySQL的创</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jiaweit/p/10080599.html</dc:identifier>
</item>
<item>
<title>js中的同步与异步的问题 - 小纸鸢</title>
<link>http://www.cnblogs.com/jianger/p/10080542.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jianger/p/10080542.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;近来，总是忙于拿js写一些案例，因为是小白，并没有什么丰富的经验，对各个知识点把握也不是很全面，写起来真的是...一言难尽，太痛苦了= =、尤其是在写一些轮播的时候，里面需要用到定时器，而一旦用了定时器，就要考虑js中一个重要无比的知识点！没错，就是同步与异步，这问题困扰了我很长时间，经过几番波折.......还是没有把案例搞出来，哈哈，但是对这个知识点还是了解了不少，于是就有了这篇博客~下面进入正题：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;知识点罗列&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　　&lt;/strong&gt; &lt;span&gt;1、同步：js本身就是同步的，也就是说代码从上往下执行的这么一个机制。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　2、异步：每个模块执行自己的，同时执行。emmm...看起来挺难理解的，举个栗子吧，嗷..对了，这里说一下js中异步有&quot;&lt;span lang=&quot;EN-US&quot;&gt;定时器&quot;&lt;span lang=&quot;EN-US&quot;&gt;、&quot;ajax&quot;、&quot;事件的绑定&quot;&lt;span lang=&quot;EN-US&quot;&gt;、&quot;回调函数&quot;，差点忘了，哈哈。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;　　我们拿事件来简单的了解一下异步，下面是栗子的代码~：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1483927/201812/1483927-20181206234356017-1416202740.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　看完之后，我们可以先自己屡一下思路，当依次点击三个div时，console.log(j)到底会输出什么。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　需要注意的是，这个事件是写在for循环里的，而事件又是异步的，所以for循环在遍历时不会管你这个事件到底触发没触发，它都会继续向下执行代码，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;直到循环结束，而当页面加载完毕后，for循环肯定也就遍历完毕了，此时的i值为2，之后我们点击第一个div时，也就是事件元素的索引为0时，图中箭头所指的i值就是2，所以会依次输出0、1、2，与目的不符，意思就是想让0出来，但是1和2也跟着蹦出来了，所以我们一般会将外面for循环的i值存到一个自定义属性ind里，然后把箭头所指的i换为this.ind,这样两者就会相匹配，只会输出0。很恶心的...不过见多了，其实也就那个样。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　好了，听了我稀里糊涂的讲解，有没有很清晰的赶脚？/捂脸&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　就先这样吧，等我把案例敲出来了再继续补充别的。 /滑稽脸&lt;/span&gt;&lt;/p&gt;




</description>
<pubDate>Thu, 06 Dec 2018 15:57:00 +0000</pubDate>
<dc:creator>小纸鸢</dc:creator>
<og:description>前言 近来，总是忙于拿js写一些案例，因为是小白，并没有什么丰富的经验，对各个知识点把握也不是很全面，写起来真的是...一言难尽，太痛苦了= =、尤其是在写一些轮播的时候，里面需要用到定时器，而一旦用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jianger/p/10080542.html</dc:identifier>
</item>
<item>
<title>zabbix wait for 15s seconds 出现原因及调优建议 - 丁壮</title>
<link>http://www.cnblogs.com/flashBoxer/p/10074661.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flashBoxer/p/10074661.html</guid>
<description>&lt;p&gt;在监控设备的时候，在server端的日志中有时候会见到类似another network error, wait for 15s seconds的异常，今天我们看下这个问题的出现原因和解决方案:&lt;/p&gt;&lt;p&gt;问题定位到poller.c，看下下面两份代码:&lt;/p&gt;&lt;p&gt;这个get_values的部分代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;for&lt;/span&gt; (i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; num; i++&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (errcodes[i])
        {
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; SUCCEED:
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; NOTSUPPORTED:
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; AGENT_ERROR:
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (HOST_AVAILABLE_TRUE !=&lt;span&gt; last_available)
                {
                    zbx_activate_item_host(&lt;/span&gt;&amp;amp;items[i], &amp;amp;&lt;span&gt;timespec);
                    last_available &lt;/span&gt;=&lt;span&gt; HOST_AVAILABLE_TRUE;
                }
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; NETWORK_ERROR:
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; GATEWAY_ERROR:
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; TIMEOUT_ERROR:
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (HOST_AVAILABLE_FALSE !=&lt;span&gt; last_available)
                {
                    zbx_deactivate_item_host(&lt;/span&gt;&amp;amp;items[i], &amp;amp;&lt;span&gt;timespec, results[i].msg);
                    last_available &lt;/span&gt;=&lt;span&gt; HOST_AVAILABLE_FALSE;
                }
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; CONFIG_ERROR:
                &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; nothing to do &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
                &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
                zbx_error(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;unknown response code returned: %d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, errcodes[i]);
                THIS_SHOULD_NEVER_HAPPEN;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里是zbx_deactivate_item_host的代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;75&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt;    zbx_deactivate_item_host(DC_ITEM *item, zbx_timespec_t *ts, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *error)                       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   #0&lt;/span&gt;
&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;        *__function_name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zbx_deactivate_item_host&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    zbx_host_availability_t    &lt;/span&gt;&lt;span&gt;in&lt;/span&gt;, &lt;span&gt;out&lt;/span&gt;;                                                                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   #1&lt;/span&gt;
    unsigned &lt;span&gt;char&lt;/span&gt;        agent_type;                                                                          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   #2&lt;/span&gt;
&lt;span&gt;
    zabbix_log(LOG_LEVEL_DEBUG, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;In %s() hostid:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ZBX_FS_UI64 &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; itemid:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ZBX_FS_UI64 &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; type:%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   #3&lt;/span&gt;
            __function_name, item-&amp;gt;host.hostid, item-&amp;gt;itemid, (&lt;span&gt;int&lt;/span&gt;)item-&amp;gt;&lt;span&gt;type);

    zbx_host_availability_init(&lt;/span&gt;&amp;amp;&lt;span&gt;in&lt;/span&gt;, item-&amp;gt;host.hostid);                                                      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   #4&lt;/span&gt;
    zbx_host_availability_init(&amp;amp;&lt;span&gt;out&lt;/span&gt;,item-&amp;gt;host.hostid);                                                      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   #5&lt;/span&gt;

    &lt;span&gt;if&lt;/span&gt; (ZBX_AGENT_UNKNOWN == (agent_type = host_availability_agent_by_item_type(item-&amp;gt;type)))                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   #6&lt;/span&gt;
        &lt;span&gt;goto&lt;/span&gt; &lt;span&gt;out&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (FAIL == host_get_availability(&amp;amp;item-&amp;gt;host, agent_type, &amp;amp;&lt;span&gt;in&lt;/span&gt;))                                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   #7&lt;/span&gt;
        &lt;span&gt;goto&lt;/span&gt; &lt;span&gt;out&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (FAIL == DChost_deactivate(item-&amp;gt;host.hostid, agent_type, ts, &amp;amp;&lt;span&gt;in&lt;/span&gt;.agents[agent_type],                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   #8&lt;/span&gt;
            &amp;amp;&lt;span&gt;out&lt;/span&gt;&lt;span&gt;.agents[agent_type], error))
    {
        &lt;/span&gt;&lt;span&gt;goto&lt;/span&gt; &lt;span&gt;out&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (FAIL == db_host_update_availability(&amp;amp;&lt;span&gt;out&lt;/span&gt;))                                                           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   #9&lt;/span&gt;
        &lt;span&gt;goto&lt;/span&gt; &lt;span&gt;out&lt;/span&gt;&lt;span&gt;;

    host_set_availability(&lt;/span&gt;&amp;amp;item-&amp;gt;host, agent_type, &amp;amp;&lt;span&gt;out&lt;/span&gt;);                                                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   #10&lt;/span&gt;

    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;0&lt;/span&gt; == &lt;span&gt;in&lt;/span&gt;.agents[agent_type].errors_from)                                                              &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   #11&lt;/span&gt;
&lt;span&gt;    {
        zabbix_log(LOG_LEVEL_WARNING, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s item \&quot;%s\&quot; on host \&quot;%s\&quot; failed:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;                                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   #12&lt;/span&gt;
                &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; first network error, wait for %d seconds&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                zbx_agent_type_string(item&lt;/span&gt;-&amp;gt;type), item-&amp;gt;key_orig, item-&amp;gt;&lt;span&gt;host.host,
                &lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.agents[agent_type].disable_until - ts-&amp;gt;&lt;span&gt;sec);
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (HOST_AVAILABLE_FALSE != &lt;span&gt;in&lt;/span&gt;.agents[agent_type].available)                                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   #13&lt;/span&gt;
&lt;span&gt;        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (HOST_AVAILABLE_FALSE != &lt;span&gt;out&lt;/span&gt;.agents[agent_type].available)                                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   #14&lt;/span&gt;
&lt;span&gt;            {
                zabbix_log(LOG_LEVEL_WARNING, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s item \&quot;%s\&quot; on host \&quot;%s\&quot; failed:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   #15&lt;/span&gt;
                        &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; another network error, wait for %d seconds&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                        zbx_agent_type_string(item&lt;/span&gt;-&amp;gt;type), item-&amp;gt;key_orig, item-&amp;gt;&lt;span&gt;host.host,
                        &lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.agents[agent_type].disable_until - ts-&amp;gt;&lt;span&gt;sec);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                zabbix_log(LOG_LEVEL_WARNING, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;temporarily disabling %s checks on host \&quot;%s\&quot;:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;              &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   #16&lt;/span&gt;
                        &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; host unavailable&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                        zbx_agent_type_string(item&lt;/span&gt;-&amp;gt;type), item-&amp;gt;&lt;span&gt;host.host);
            }
        }
    }

    zabbix_log(LOG_LEVEL_DEBUG, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s() errors_from:%d available:%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, __function_name,
            &lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.agents[agent_type].errors_from, &lt;span&gt;out&lt;/span&gt;&lt;span&gt;.agents[agent_type].available);
&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt;:
    zbx_host_availability_clean(&lt;/span&gt;&amp;amp;&lt;span&gt;out&lt;/span&gt;&lt;span&gt;);
    zbx_host_availability_clean(&lt;/span&gt;&amp;amp;&lt;span&gt;in&lt;/span&gt;&lt;span&gt;);

    zabbix_log(LOG_LEVEL_DEBUG, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;End of %s()&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, __function_name);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面看下这里是zbx_deactivate_item_host的代码的逻辑：&lt;/p&gt;
&lt;p&gt;#0  zbx_deactivate_item_host函数接收三个参数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;1&lt;/span&gt;&lt;span&gt; 结构体指针，主机的一些综合参数
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;dbcache.h &lt;/span&gt;
            typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt;
            {
                DC_HOST            host;
                DC_INTERFACE        &lt;/span&gt;&lt;span&gt;interface&lt;/span&gt;&lt;span&gt;;
                zbx_uint64_t        itemid;
                zbx_uint64_t        lastlogsize;
                zbx_uint64_t        valuemapid;
                unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt;        type;
                unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt;        value_type;
                unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt;        state;
                unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt;        snmpv3_securitylevel;
                unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt;        authtype;
                unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt;        flags;
                unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt;        snmpv3_authprotocol;
                unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt;        snmpv3_privprotocol;
                unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt;        inventory_link;
                unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt;        status;
                unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt;        history;
                unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt;        trends;
                unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt;        follow_redirects;
                unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt;        post_type;
                unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt;        retrieve_mode;
                unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt;        request_method;
                unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt;        output_format;
                unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt;        verify_peer;
                unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt;        verify_host;
                unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt;        allow_traps;
                &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;            key_orig[ITEM_KEY_LEN * ZBX_MAX_BYTES_IN_UTF8_CHAR + &lt;span&gt;1&lt;/span&gt;], *&lt;span&gt;key;
                &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;            *&lt;span&gt;units;
                &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;            *&lt;span&gt;delay;
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;            history_sec;
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;            nextcheck;
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;            lastclock;
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;            mtime;
                &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt;            trapper_hosts[ITEM_TRAPPER_HOSTS_LEN_MAX];
                &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt;            logtimefmt[ITEM_LOGTIMEFMT_LEN_MAX];
                &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;            snmp_community_orig[ITEM_SNMP_COMMUNITY_LEN_MAX], *&lt;span&gt;snmp_community;
                &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;            snmp_oid_orig[ITEM_SNMP_OID_LEN_MAX], *&lt;span&gt;snmp_oid;
                &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;            snmpv3_securityname_orig[ITEM_SNMPV3_SECURITYNAME_LEN_MAX], *&lt;span&gt;snmpv3_securityname;
                &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;            snmpv3_authpassphrase_orig[ITEM_SNMPV3_AUTHPASSPHRASE_LEN_MAX], *&lt;span&gt;snmpv3_authpassphrase;
                &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;            snmpv3_privpassphrase_orig[ITEM_SNMPV3_PRIVPASSPHRASE_LEN_MAX], *&lt;span&gt;snmpv3_privpassphrase;
                &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt;            ipmi_sensor[ITEM_IPMI_SENSOR_LEN_MAX];
                &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;            *&lt;span&gt;params&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;            username_orig[ITEM_USERNAME_LEN_MAX], *&lt;span&gt;username;
                &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;            publickey_orig[ITEM_PUBLICKEY_LEN_MAX], *&lt;span&gt;publickey;
                &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;            privatekey_orig[ITEM_PRIVATEKEY_LEN_MAX], *&lt;span&gt;privatekey;
                &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;            password_orig[ITEM_PASSWORD_LEN_MAX], *&lt;span&gt;password;
                &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;            snmpv3_contextname_orig[ITEM_SNMPV3_CONTEXTNAME_LEN_MAX], *&lt;span&gt;snmpv3_contextname;
                &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;            jmx_endpoint_orig[ITEM_JMX_ENDPOINT_LEN_MAX], *&lt;span&gt;jmx_endpoint;
                &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;            timeout_orig[ITEM_TIMEOUT_LEN_MAX], *&lt;span&gt;timeout;
                &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;            url_orig[ITEM_URL_LEN_MAX], *&lt;span&gt;url;
                &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;            query_fields_orig[ITEM_QUERY_FIELDS_LEN_MAX], *&lt;span&gt;query_fields;
                &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;            *&lt;span&gt;posts;
                &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;            status_codes_orig[ITEM_STATUS_CODES_LEN_MAX], *&lt;span&gt;status_codes;
                &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;            http_proxy_orig[ITEM_HTTP_PROXY_LEN_MAX], *&lt;span&gt;http_proxy;
                &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;            *&lt;span&gt;headers;
                &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;            ssl_cert_file_orig[ITEM_SSL_CERT_FILE_LEN_MAX], *&lt;span&gt;ssl_cert_file;
                &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;            ssl_key_file_orig[ITEM_SSL_KEY_FILE_LEN_MAX], *&lt;span&gt;ssl_key_file;
                &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;            ssl_key_password_orig[ITEM_SSL_KEY_PASSWORD_LEN_MAX], *&lt;span&gt;ssl_key_password;
                &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;            *&lt;span&gt;error;
            }
            DC_ITEM;
        &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt; 结构体指针
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;common.h&lt;/span&gt;
            typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;    sec;    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; seconds &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
                &lt;span&gt;int&lt;/span&gt;    ns;    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; nanoseconds &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            }
            zbx_timespec_t;
            
        &lt;/span&gt;&lt;span&gt;3&lt;/span&gt; 错误信息
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;#1 定义了两个结构体数组 in 和 out&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;db.h&lt;/span&gt;
        typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; flags specifying which fields are set, see ZBX_FLAGS_AGENT_STATUS_* defines &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt;    flags;

            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; agent availability fields &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt;    available;
            &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;        *&lt;span&gt;error;
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;        errors_from;
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;        disable_until;
        }
        zbx_agent_availability_t;

        typedef &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt;
        {
            zbx_uint64_t            hostid;

            zbx_agent_availability_t    agents[ZBX_AGENT_MAX];         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里的ZBX_AGENT_MAX 为4 ，分别代表ZABBIX, SNMP, IPMI, JMX4种类型&lt;/span&gt;
&lt;span&gt;        }
        zbx_host_availability_t;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;#2 声明unsigned char agent_type，unsigned char和char的区别是char表示-128-127，unsigned char 表示0-255，这里的255会在后面遇到，所以需要255的这个表示范围&lt;/p&gt;&lt;p&gt;#3 记录DEBUG 的log，如果需要显示这份日志，需要将server端的配置文件debug等级更改为5，不过我不建议你这么做&lt;/p&gt;&lt;p&gt;#4 初始化主机IN可用性数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;dbconfig.c&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;    zbx_host_availability_init(zbx_host_availability_t *&lt;span&gt;availability, zbx_uint64_t hostid)
    {
        memset(availability, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(zbx_host_availability_t));
        availability&lt;/span&gt;-&amp;gt;hostid =&lt;span&gt; hostid;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;#5 同#4一样，只不过是OUT&lt;/p&gt;

&lt;p&gt;#6 为agent_type赋值，如果agent_type不属于#1中的四种，跳至out处&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;1&lt;/span&gt;&lt;span&gt;、host_availability_agent_by_item_type 位于poller.c，接收item的type字段，用来判断监控类型
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;poller.c&lt;/span&gt;
        &lt;span&gt;static&lt;/span&gt; unsigned &lt;span&gt;char&lt;/span&gt;    host_availability_agent_by_item_type(unsigned &lt;span&gt;char&lt;/span&gt;&lt;span&gt; type)
        {
            &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (type)
            {
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; ITEM_TYPE_ZABBIX:
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ZBX_AGENT_ZABBIX;
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; ITEM_TYPE_SNMPv1:
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; ITEM_TYPE_SNMPv2c:
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; ITEM_TYPE_SNMPv3:
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ZBX_AGENT_SNMP;
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; ITEM_TYPE_IPMI:
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ZBX_AGENT_IPMI;
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; ITEM_TYPE_JMX:
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ZBX_AGENT_JMX;
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ZBX_AGENT_UNKNOWN;
            }
        }
    &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;、ZBX_AGENT_UNKNOWN 常量 为 &lt;span&gt;255&lt;/span&gt; 对应之前的 #&lt;span&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;#7 根据agent_type来判断主机的可用性，网络设备会匹配到ZBX_AGENT_SNMP，四个值分别代表的意思是&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;poller.c&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;    host_get_availability(&lt;span&gt;const&lt;/span&gt; DC_HOST *dc_host, unsigned &lt;span&gt;char&lt;/span&gt; agent, zbx_host_availability_t *&lt;span&gt;ha)
    {
        zbx_agent_availability_t    &lt;/span&gt;*availability = &amp;amp;ha-&amp;gt;&lt;span&gt;agents[agent];

        availability&lt;/span&gt;-&amp;gt;flags =&lt;span&gt; ZBX_FLAGS_AGENT_STATUS;

        &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (agent)
        {
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; ZBX_AGENT_ZABBIX:
                availability&lt;/span&gt;-&amp;gt;available = dc_host-&amp;gt;&lt;span&gt;available;
                availability&lt;/span&gt;-&amp;gt;error = zbx_strdup(NULL, dc_host-&amp;gt;&lt;span&gt;error);
                availability&lt;/span&gt;-&amp;gt;errors_from = dc_host-&amp;gt;&lt;span&gt;errors_from;
                availability&lt;/span&gt;-&amp;gt;disable_until = dc_host-&amp;gt;&lt;span&gt;disable_until;
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; ZBX_AGENT_SNMP:
                availability&lt;/span&gt;-&amp;gt;available = dc_host-&amp;gt;snmp_available;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;主机的snmp可用状态&lt;/span&gt;
                availability-&amp;gt;error = zbx_strdup(NULL, dc_host-&amp;gt;snmp_error);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;错误信息&lt;/span&gt;
                availability-&amp;gt;errors_from = dc_host-&amp;gt;snmp_errors_from;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;错误发生时间&lt;/span&gt;
                availability-&amp;gt;disable_until = dc_host-&amp;gt;snmp_disable_until;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;下次延迟检测时间&lt;/span&gt;
                &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; ZBX_AGENT_IPMI:
                availability&lt;/span&gt;-&amp;gt;available = dc_host-&amp;gt;&lt;span&gt;ipmi_available;
                availability&lt;/span&gt;-&amp;gt;error = zbx_strdup(NULL, dc_host-&amp;gt;&lt;span&gt;ipmi_error);
                availability&lt;/span&gt;-&amp;gt;errors_from = dc_host-&amp;gt;&lt;span&gt;ipmi_errors_from;
                availability&lt;/span&gt;-&amp;gt;disable_until = dc_host-&amp;gt;&lt;span&gt;ipmi_disable_until;
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; ZBX_AGENT_JMX:
                availability&lt;/span&gt;-&amp;gt;available = dc_host-&amp;gt;&lt;span&gt;jmx_available;
                availability&lt;/span&gt;-&amp;gt;error = zbx_strdup(NULL, dc_host-&amp;gt;&lt;span&gt;jmx_error);
                availability&lt;/span&gt;-&amp;gt;disable_until = dc_host-&amp;gt;&lt;span&gt;jmx_disable_until;
                availability&lt;/span&gt;-&amp;gt;errors_from = dc_host-&amp;gt;&lt;span&gt;jmx_errors_from;
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; FAIL;
        }

        ha&lt;/span&gt;-&amp;gt;hostid = dc_host-&amp;gt;&lt;span&gt;hostid;

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; SUCCEED;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;dbcache.h&lt;/span&gt;
    typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt;
    {
        zbx_uint64_t    hostid;
        zbx_uint64_t    proxy_hostid;
        &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt;        host[HOST_HOST_LEN_MAX];
        &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;        name[HOST_NAME_LEN * ZBX_MAX_BYTES_IN_UTF8_CHAR + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
        unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt;    maintenance_status;
        unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt;    maintenance_type;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;        maintenance_from;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;        errors_from;
        unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt;    available;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;        disable_until;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;        snmp_errors_from;
        unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt;    snmp_available;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;        snmp_disable_until;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;        ipmi_errors_from;
        unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt;    ipmi_available;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;        ipmi_disable_until;
        signed &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt;    ipmi_authtype;
        unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt;    ipmi_privilege;
        &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt;        ipmi_username[HOST_IPMI_USERNAME_LEN_MAX];
        &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt;        ipmi_password[HOST_IPMI_PASSWORD_LEN_MAX];
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;        jmx_errors_from;
        unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt;    jmx_available;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;        jmx_disable_until;
        &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt;        inventory_mode;
        unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt;    status;
        unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt;    tls_connect;
        unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt;    tls_accept;
    &lt;/span&gt;&lt;span&gt;#if&lt;/span&gt; defined(HAVE_POLARSSL) || defined(HAVE_GNUTLS) || defined(HAVE_OPENSSL)
        &lt;span&gt;char&lt;/span&gt;&lt;span&gt;        tls_issuer[HOST_TLS_ISSUER_LEN_MAX];
        &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt;        tls_subject[HOST_TLS_SUBJECT_LEN_MAX];
        &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt;        tls_psk_identity[HOST_TLS_PSK_IDENTITY_LEN_MAX];
        &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt;        tls_psk[HOST_TLS_PSK_LEN_MAX];
    &lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;
        &lt;span&gt;char&lt;/span&gt;&lt;span&gt;        error[HOST_ERROR_LEN_MAX];
        &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt;        snmp_error[HOST_ERROR_LEN_MAX];
        &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt;        ipmi_error[HOST_ERROR_LEN_MAX];
        &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt;        jmx_error[HOST_ERROR_LEN_MAX];
    }
    DC_HOST;
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;db.h&lt;/span&gt;
    &lt;span&gt;#define&lt;/span&gt; ZBX_FLAGS_AGENT_STATUS_AVAILABLE    0x00000001
    &lt;span&gt;#define&lt;/span&gt; ZBX_FLAGS_AGENT_STATUS_ERROR        0x00000002
    &lt;span&gt;#define&lt;/span&gt; ZBX_FLAGS_AGENT_STATUS_ERRORS_FROM    0x00000004
    &lt;span&gt;#define&lt;/span&gt; ZBX_FLAGS_AGENT_STATUS_DISABLE_UNTIL    0x00000008
    &lt;span&gt;#define&lt;/span&gt; ZBX_FLAGS_AGENT_STATUS        (ZBX_FLAGS_AGENT_STATUS_AVAILABLE |    \&lt;span&gt;
                        ZBX_FLAGS_AGENT_STATUS_ERROR &lt;/span&gt;|&lt;span&gt;        \
                        ZBX_FLAGS_AGENT_STATUS_ERRORS_FROM &lt;/span&gt;|&lt;span&gt;    \
                        ZBX_FLAGS_AGENT_STATUS_DISABLE_UNTIL) 

     
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;common.h&lt;/span&gt;
    &lt;span&gt;#define&lt;/span&gt;    FAIL        -1
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;#8  根据agent_type 设置主机状态&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;dbconfig.c&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt;    DChost_deactivate(zbx_uint64_t hostid, unsigned &lt;span&gt;char&lt;/span&gt; agent_type, &lt;span&gt;const&lt;/span&gt; zbx_timespec_t *&lt;span&gt;ts,
            zbx_agent_availability_t &lt;/span&gt;*&lt;span&gt;in&lt;/span&gt;, zbx_agent_availability_t *&lt;span&gt;out&lt;/span&gt;, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;error_msg)
    {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;        ret =&lt;span&gt; FAIL, errors_from,disable_until;
        &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;    *&lt;span&gt;error;
        unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt;    available;
        ZBX_DC_HOST    &lt;/span&gt;*&lt;span&gt;dc_host;


        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; don't try deactivating host if the unreachable delay has not passed since the first error &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (CONFIG_UNREACHABLE_DELAY &amp;gt; ts-&amp;gt;sec - &lt;span&gt;in&lt;/span&gt;-&amp;gt;&lt;span&gt;errors_from) 
            &lt;/span&gt;&lt;span&gt;goto&lt;/span&gt; &lt;span&gt;out&lt;/span&gt;&lt;span&gt;;

        WRLOCK_CACHE;

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (NULL == (dc_host = (ZBX_DC_HOST *)zbx_hashset_search(&amp;amp;config-&amp;gt;hosts, &amp;amp;&lt;span&gt;hostid)))
            &lt;/span&gt;&lt;span&gt;goto&lt;/span&gt;&lt;span&gt; unlock;

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Don't try deactivating host if:                &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; - (server, proxy) it's not monitored any more; &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; - (server) it's monitored by proxy.            &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; ((&lt;span&gt;0&lt;/span&gt; != (program_type &amp;amp; ZBX_PROGRAM_TYPE_SERVER) &amp;amp;&amp;amp; &lt;span&gt;0&lt;/span&gt; != dc_host-&amp;gt;proxy_hostid) ||&lt;span&gt;
                HOST_STATUS_MONITORED &lt;/span&gt;!= dc_host-&amp;gt;&lt;span&gt;status)
        {
            &lt;/span&gt;&lt;span&gt;goto&lt;/span&gt;&lt;span&gt; unlock;
        }

        DChost_get_agent_availability(dc_host, agent_type, &lt;/span&gt;&lt;span&gt;in&lt;/span&gt;&lt;span&gt;);

        available &lt;/span&gt;= &lt;span&gt;in&lt;/span&gt;-&amp;gt;&lt;span&gt;available;
        error &lt;/span&gt;= &lt;span&gt;in&lt;/span&gt;-&amp;gt;&lt;span&gt;error;

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;0&lt;/span&gt; == &lt;span&gt;in&lt;/span&gt;-&amp;gt;&lt;span&gt;errors_from)
        {
            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; first error, schedule next unreachable check &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            errors_from &lt;/span&gt;= ts-&amp;gt;&lt;span&gt;sec;
            disable_until &lt;/span&gt;= ts-&amp;gt;sec +&lt;span&gt; CONFIG_UNREACHABLE_DELAY;
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        {
            errors_from &lt;/span&gt;= &lt;span&gt;in&lt;/span&gt;-&amp;gt;&lt;span&gt;errors_from;
            disable_until &lt;/span&gt;= &lt;span&gt;in&lt;/span&gt;-&amp;gt;&lt;span&gt;disable_until;

            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Check if other pollers haven't already attempted deactivating host. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; In that case should wait the initial unreachable delay before       &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; trying to make it unavailable.                                      &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (CONFIG_UNREACHABLE_DELAY &amp;lt;= ts-&amp;gt;sec -&lt;span&gt; errors_from)
            {
                &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; repeating error &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (CONFIG_UNREACHABLE_PERIOD &amp;gt; ts-&amp;gt;sec -&lt;span&gt; errors_from)
                {
                    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; leave host available, schedule next unreachable check &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
                    disable_until &lt;/span&gt;= ts-&amp;gt;sec +&lt;span&gt; CONFIG_UNREACHABLE_DELAY;
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                {
                    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; make host unavailable, schedule next unavailable check &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
                    disable_until &lt;/span&gt;= ts-&amp;gt;sec +&lt;span&gt; CONFIG_UNAVAILABLE_DELAY;
                    available &lt;/span&gt;=&lt;span&gt; HOST_AVAILABLE_FALSE;
                    error &lt;/span&gt;=&lt;span&gt; error_msg;
                }
            }
        }

        zbx_agent_availability_init(&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt;, available, error, errors_from, disable_until);
        DChost_set_agent_availability(dc_host, ts&lt;/span&gt;-&amp;gt;sec, agent_type, &lt;span&gt;out&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ZBX_FLAGS_AGENT_STATUS_NONE != &lt;span&gt;out&lt;/span&gt;-&amp;gt;&lt;span&gt;flags)
            ret &lt;/span&gt;=&lt;span&gt; SUCCEED;
    unlock:
        UNLOCK_CACHE;
    &lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;主要看下这段:&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
if (0 == in-&amp;gt;errors_from)
        {
            /* first error, schedule next unreachable check */
            errors_from = ts-&amp;gt;sec;
            disable_until = ts-&amp;gt;sec + CONFIG_UNREACHABLE_DELAY;
        }
        else
        {
            errors_from = in-&amp;gt;errors_from;
            disable_until = in-&amp;gt;disable_until;

            /* Check if other pollers haven't already attempted deactivating host. */
            /* In that case should wait the initial unreachable delay before       */
            /* trying to make it unavailable.                                      */
            if (CONFIG_UNREACHABLE_DELAY &amp;lt;= ts-&amp;gt;sec - errors_from)
            {
                /* repeating error */
                if (CONFIG_UNREACHABLE_PERIOD &amp;gt; ts-&amp;gt;sec - errors_from)
                {
                    /* leave host available, schedule next unreachable check */
                    disable_until = ts-&amp;gt;sec + CONFIG_UNREACHABLE_DELAY;
                }
                else
                {
                    /* make host unavailable, schedule next unavailable check */
                    disable_until = ts-&amp;gt;sec + CONFIG_UNAVAILABLE_DELAY;
                    available = HOST_AVAILABLE_FALSE;
                    error = error_msg;
                }
            }
        }
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;        如果错误第一次出现:
            错误发生时间=检查的&lt;span&gt;时间戳
            下次的检查时间 = &lt;span&gt;&lt;span&gt;时间戳&lt;/span&gt;&lt;/span&gt;+&lt;span&gt;15s
        否则:
            错误发生时间 = &lt;span&gt;in-&amp;gt;&lt;span&gt;errors_from
            下次检查时间 = &lt;span&gt;in-&amp;gt;&lt;span&gt;disable_until

            &lt;span&gt;检查的&lt;span&gt;时间戳&lt;/span&gt;&lt;/span&gt;-错误发生时间&amp;gt;=&lt;span&gt;15s:
                &lt;span&gt;检查的&lt;span&gt;时间戳&lt;/span&gt;&lt;/span&gt;-错误发生时间&amp;lt;&lt;span&gt; 45s:
                    下次的检查时间 = &lt;span&gt;检查的&lt;span&gt;时间戳&lt;/span&gt;&lt;/span&gt;+&lt;span&gt;15s
                否则:
                    下一次检查时间 =&lt;span&gt;检查的&lt;span&gt;时间戳&lt;/span&gt;&lt;/span&gt;+&lt;span&gt;15s
                    主机可用性为不可用
            &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  &lt;span&gt;用配置文件来解释就是: 如果由于网络等原因没有实现项目的及时监控，第一次的监控间隔为UnreachableDelay时间(15s),如果这次也失败了，那么从第一次失败到本次检查在UnreachablePeriod时间内，会再次在UnreachableDelay时间后监控&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;#9 更新数据库中的主机可用性信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; poller.c&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;    db_host_update_availability(&lt;span&gt;const&lt;/span&gt; zbx_host_availability_t *&lt;span&gt;ha)
    {
        &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;    *sql =&lt;span&gt; NULL;
        size_t    sql_alloc &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;, sql_offset = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (SUCCEED == zbx_sql_add_host_availability(&amp;amp;sql, &amp;amp;sql_alloc, &amp;amp;&lt;span&gt;sql_offset, ha))
        {
            DBbegin();
            DBexecute(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, sql);
            DBcommit();

            zbx_free(sql);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; SUCCEED;
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; FAIL;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;#10 根据agent_type设置主机可用性信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;poller.c&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;    host_set_availability(DC_HOST *dc_host, unsigned &lt;span&gt;char&lt;/span&gt; agent, &lt;span&gt;const&lt;/span&gt; zbx_host_availability_t *&lt;span&gt;ha)
    {
        &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; zbx_agent_availability_t    *availability = &amp;amp;ha-&amp;gt;&lt;span&gt;agents[agent];
        unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;            *&lt;span&gt;pavailable;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;                *perrors_from, *&lt;span&gt;pdisable_until;
        &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;                *&lt;span&gt;perror;

        &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (agent)
        {
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; ZBX_AGENT_ZABBIX:
                pavailable &lt;/span&gt;= &amp;amp;dc_host-&amp;gt;&lt;span&gt;available;
                perror &lt;/span&gt;= dc_host-&amp;gt;&lt;span&gt;error;
                perrors_from &lt;/span&gt;= &amp;amp;dc_host-&amp;gt;&lt;span&gt;errors_from;
                pdisable_until &lt;/span&gt;= &amp;amp;dc_host-&amp;gt;&lt;span&gt;disable_until;
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; ZBX_AGENT_SNMP:
                pavailable &lt;/span&gt;= &amp;amp;dc_host-&amp;gt;&lt;span&gt;snmp_available;
                perror &lt;/span&gt;= dc_host-&amp;gt;&lt;span&gt;snmp_error;
                perrors_from &lt;/span&gt;= &amp;amp;dc_host-&amp;gt;&lt;span&gt;snmp_errors_from;
                pdisable_until &lt;/span&gt;= &amp;amp;dc_host-&amp;gt;&lt;span&gt;snmp_disable_until;
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; ZBX_AGENT_IPMI:
                pavailable &lt;/span&gt;= &amp;amp;dc_host-&amp;gt;&lt;span&gt;ipmi_available;
                perror &lt;/span&gt;= dc_host-&amp;gt;&lt;span&gt;ipmi_error;
                perrors_from &lt;/span&gt;= &amp;amp;dc_host-&amp;gt;&lt;span&gt;ipmi_errors_from;
                pdisable_until &lt;/span&gt;= &amp;amp;dc_host-&amp;gt;&lt;span&gt;ipmi_disable_until;
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; ZBX_AGENT_JMX:
                pavailable &lt;/span&gt;= &amp;amp;dc_host-&amp;gt;&lt;span&gt;jmx_available;
                perror &lt;/span&gt;= dc_host-&amp;gt;&lt;span&gt;jmx_error;
                pdisable_until &lt;/span&gt;= &amp;amp;dc_host-&amp;gt;&lt;span&gt;jmx_disable_until;
                perrors_from &lt;/span&gt;= &amp;amp;dc_host-&amp;gt;&lt;span&gt;jmx_errors_from;
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; FAIL;
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;0&lt;/span&gt; != (availability-&amp;gt;flags &amp;amp;&lt;span&gt; ZBX_FLAGS_AGENT_STATUS_AVAILABLE))
            &lt;/span&gt;*pavailable = availability-&amp;gt;&lt;span&gt;available;

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;0&lt;/span&gt; != (availability-&amp;gt;flags &amp;amp;&lt;span&gt; ZBX_FLAGS_AGENT_STATUS_ERROR))
            zbx_strlcpy(perror, availability&lt;/span&gt;-&amp;gt;&lt;span&gt;error, HOST_ERROR_LEN_MAX);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;0&lt;/span&gt; != (availability-&amp;gt;flags &amp;amp;&lt;span&gt; ZBX_FLAGS_AGENT_STATUS_ERRORS_FROM))
            &lt;/span&gt;*perrors_from = availability-&amp;gt;&lt;span&gt;errors_from;

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;0&lt;/span&gt; != (availability-&amp;gt;flags &amp;amp;&lt;span&gt; ZBX_FLAGS_AGENT_STATUS_DISABLE_UNTIL))
            &lt;/span&gt;*pdisable_until = availability-&amp;gt;&lt;span&gt;disable_until;

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; SUCCEED;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;#11-16&lt;br/&gt;    如果是第一次检查：&lt;br/&gt;       　　 记录日志first network error, wait for 15 seconds&lt;br/&gt;    否则:&lt;br/&gt;       　　 如果数据库中的主机如果显示可用:&lt;br/&gt;            　　　　记录日志another network error, wait for 15 seconds&lt;br/&gt;        　　否则&lt;br/&gt;            　　　　记录日志temporarily disabling(这是前段页面的绿色图标会变为红色)&lt;/p&gt;


&lt;p&gt;从上面的代码可以看出，在三中情况下会产生network error, wait for 15s seconds的日志，分别是在poller过程中产生的网络错误，网关问题，或者是检查超时。总结下来就是:zabbix server 与zabbix agentd的连接和数据的收发不能成功或者&lt;span class=&quot;tgt&quot; data-section=&quot;2&quot; data-sentence=&quot;1&quot; data-group=&quot;2-1&quot;&gt;在取得数据的一系列处理中花费的时间超过了zabbix server 的Timeout参数情况下发生。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;tgt&quot; data-section=&quot;2&quot; data-sentence=&quot;1&quot; data-group=&quot;2-1&quot;&gt;从正常取值到出现异常的处理过程是这样的:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;tgt&quot; data-section=&quot;2&quot; data-sentence=&quot;1&quot; data-group=&quot;2-1&quot;&gt;正常取值   UnreachableDelay  UnreachableDelay   UnreachableDelay      UnnavailableDelay        恢复&lt;br/&gt;                  |                                       |                              |&lt;br/&gt;                  |                                       |                              |&lt;br/&gt;                  -----------------------UnreachablePeriod------------&lt;br/&gt;    1             2                                                              3                                4                           5&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;tgt&quot; data-section=&quot;2&quot; data-sentence=&quot;1&quot; data-group=&quot;2-1&quot;&gt;       过程                                        日志                                                               &lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li class=&quot;tgt&quot; data-section=&quot;2&quot; data-sentence=&quot;1&quot; data-group=&quot;2-1&quot;&gt;&lt;span class=&quot;tgt&quot; data-section=&quot;2&quot; data-sentence=&quot;1&quot; data-group=&quot;2-1&quot;&gt;1 获取正常监控数据&lt;br class=&quot;_mce_tagged_br&quot;/&gt;
2 发生错误                 ------------&amp;gt;&lt;span class=&quot;tgt&quot; data-section=&quot;2&quot; data-sentence=&quot;1&quot; data-group=&quot;2-1&quot;&gt;first network&lt;/span&gt;&lt;br class=&quot;_mce_tagged_br&quot;/&gt;
3 再次发生错误          &lt;span class=&quot;tgt&quot; data-section=&quot;2&quot; data-sentence=&quot;1&quot; data-group=&quot;2-1&quot;&gt;------------&amp;gt;&lt;span class=&quot;tgt&quot; data-section=&quot;2&quot; data-sentence=&quot;1&quot; data-group=&quot;2-1&quot;&gt;another network&lt;/span&gt;&lt;/span&gt;&lt;br class=&quot;_mce_tagged_br&quot;/&gt;
4 置为不可用            &lt;span class=&quot;tgt&quot; data-section=&quot;2&quot; data-sentence=&quot;1&quot; data-group=&quot;2-1&quot;&gt;&lt;span class=&quot;tgt&quot; data-section=&quot;2&quot; data-sentence=&quot;1&quot; data-group=&quot;2-1&quot;&gt;&lt;span class=&quot;tgt&quot; data-section=&quot;2&quot; data-sentence=&quot;1&quot; data-group=&quot;2-1&quot;&gt;------------&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;tgt&quot; data-section=&quot;2&quot; data-sentence=&quot;1&quot; data-group=&quot;2-1&quot;&gt;&lt;span class=&quot;tgt&quot; data-section=&quot;2&quot; data-sentence=&quot;1&quot; data-group=&quot;2-1&quot;&gt;&lt;span class=&quot;tgt&quot; data-section=&quot;2&quot; data-sentence=&quot;1&quot; data-group=&quot;2-1&quot;&gt;temporarily disabling&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br class=&quot;_mce_tagged_br&quot;/&gt;
5 恢复                        &lt;span class=&quot;tgt&quot; data-section=&quot;2&quot; data-sentence=&quot;1&quot; data-group=&quot;2-1&quot;&gt;&lt;span class=&quot;tgt&quot; data-section=&quot;2&quot; data-sentence=&quot;1&quot; data-group=&quot;2-1&quot;&gt;&lt;span class=&quot;tgt&quot; data-section=&quot;2&quot; data-sentence=&quot;1&quot; data-group=&quot;2-1&quot;&gt;------------&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;tgt&quot; data-section=&quot;2&quot; data-sentence=&quot;1&quot; data-group=&quot;2-1&quot;&gt;resuming&lt;/span&gt;&lt;br class=&quot;_mce_tagged_br&quot;/&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;日志中的15s在配置文件中对应的配置UnreachableDelay,默认为15s，在源码中的位置是server.c中的CONFIG_UNREACHABLE_DELAY，&lt;br/&gt;但注意&lt;span&gt;这个配置不会解决任何network error的问题&lt;/span&gt;，只是为计算下一个检查时间提供时间依据。还有大家应该注意到了UnreachableDelay参数和&lt;span class=&quot;tgt&quot; data-section=&quot;2&quot; data-sentence=&quot;1&quot; data-group=&quot;2-1&quot;&gt;UnreachablePeriod&lt;/span&gt;是倍数关系。我们在调优的时候需要注意下。&lt;/p&gt;&lt;p&gt;从zabbix 1.8版使用至今，根据我这几年的经验分析产生此类日志基本出现在网络设备，服务器很少出现，这与SNMP使用UDP协议有关系，但主要问题还是几方面问题:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1、网络不稳定&lt;/li&gt;
&lt;li&gt;2、设备端问题&lt;/li&gt;
&lt;li&gt;3、poller排队了&lt;/li&gt;
&lt;li&gt;4、Timeout超时了&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这四种中的Timeout和poller又是有相互联系的，关于服务器如何设置poller，我后面的文章再介绍，先暂时分别来看下这四种情况:&lt;/p&gt;&lt;p&gt;网络不稳定多出现于几种情况:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;    1、使用公网实现和IDC互连，也就是被检查设备和server不在一个IDC，这种情况建议在另一端增加proxy，使对端设备的检测都在内网进行&lt;/li&gt;
&lt;li&gt;    2、使用云端网络，使用云端的网络互连方式打通云端设备和IDC的互连，这种情况的网络对于用户来说就是一种黑盒，基本无法排障，如果你使用大厂的服务，会偶尔出现日志报错，但不会影响到使用体验&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;网络设备端问题的情况:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1、设备性能:如何判断网络设备端问题呢?可以在网络设备上debug snmp信息，看每个包是否是都回了还是报错了，这种情况可以将snmp的采取间隔加大，&lt;/li&gt;
&lt;li&gt;2、对端和server连接的端口带宽打满了&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;poller排队处理;&lt;br/&gt;    poller数量是由zabbix_server配置文件中的startpollers指定，poller.c主要做几件事:1、从队列中获取item的数据 2、获取item获取监控数据 3、把数据放入缓存&lt;br/&gt;    poller只会处理被动状态的监控项:&lt;br/&gt;        如果你是服务器出现此类日志:解决方法一种是增大poller的数量，一种是把被动模式改为主动模式，&lt;br/&gt;        如果你是网络设备:改用脚本实现，或者增大poller数量&lt;/p&gt;&lt;p&gt;关于Timeout ,这里有同学可能会说将服务器的检查时间调长为30s，这种设置如果检查设备少没关系，数量比较多我不建议这样调整，超过2s的检测项都改在agentd改用脚本实现吧&lt;/p&gt;

&lt;p&gt;以上，是我使用zabbix中关于日志报警&lt;span class=&quot;postTitle2&quot;&gt;wait for 15s seconds 的一些理解和心得，如果文章内容对你有所帮助，请点个赞吧。如果你发现文中有错误的方面，也请留言给我，谢谢！&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 06 Dec 2018 15:52:00 +0000</pubDate>
<dc:creator>丁壮</dc:creator>
<og:description>在监控设备的时候，在server端的日志中有时候会见到类似another network error, wait for 15s seconds的异常，今天我们看下这个问题的出现原因和解决方案:问题定</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/flashBoxer/p/10074661.html</dc:identifier>
</item>
</channel>
</rss>