<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>敲黑板，定积分也有换元和分部积分法 - TechFlow2019</title>
<link>http://www.cnblogs.com/techflow/p/12816757.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/techflow/p/12816757.html</guid>
<description>&lt;p&gt;本文始发于个人公众号：&lt;strong&gt;TechFlow&lt;/strong&gt;，原创不易，求个关注&lt;/p&gt;
&lt;p&gt;今天是&lt;strong&gt;高等数学的第14篇&lt;/strong&gt;文章，我们一起来看看定积分的换元法和分部积分法。&lt;/p&gt;
&lt;p&gt;我们之前在不定积分的内容当中曾经介绍过&lt;strong&gt;换元法和分部积分法&lt;/strong&gt;这两种求解不定积分的方法，今天我们来探索将这两种方法应用在定积分上。有一点需要注意，虽然不定积分和定积分只有一字之差，但是在数学上其实它们是&lt;strong&gt;两个完全不同的概念&lt;/strong&gt;。不定积分求解的是函数的原函数，而定积分则是求解的曲形的面积，也就是一个具体的值。&lt;/p&gt;
&lt;p&gt;我们用Python来举例的话，不定积分有些像是高阶函数，我们传入一个函数，得到一个函数。而定积分则就是一个计算的函数，我们传入一个函数，得到一个值。由于有了牛顿-莱布尼茨公式，我们求解定积分的时候也需要求解原函数，但这只是计算过程相似，并不是它的定义。所以不要把两者弄混淆了。&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;换元法&quot;&gt;换元法&lt;/h2&gt;
&lt;p&gt;在我们写出换元法的公式之前，我们&lt;strong&gt;先写清楚它的作用区间&lt;/strong&gt;。这个是数学的惯例，我们写一个公式或者是定理或者是式子，都需要标明适用范围。我们假设函数f(x)在区间[a, b]上连续。&lt;/p&gt;
&lt;p&gt;函数&lt;span class=&quot;math inline&quot;&gt;\(x=\phi(t)\)&lt;/span&gt;满足：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(\phi(\alpha) = a, \phi(\beta) = b\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(\phi(t)\)&lt;/span&gt;在区间&lt;span class=&quot;math inline&quot;&gt;\([\alpha, \beta]\)&lt;/span&gt;，或者&lt;span class=&quot;math inline&quot;&gt;\([\beta, \alpha]\)&lt;/span&gt;上具有连续导数，值域是[a, b]，那么：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;\[\int_a^bf(x)dx = \int_\alpha^\beta f[\phi(t)]\phi'(t)dt \]&lt;/p&gt;
&lt;p&gt;这个式子成立非常明显，但为了严谨，我们还是来证明一遍。&lt;/p&gt;
&lt;p&gt;等式的左边很简单就是我们常见的积分函数，我们假设f(x)在区间[a, b]上的原函数是F(x)，那么等式左边根据牛顿-莱布尼茨公式，可以得到：&lt;/p&gt;
&lt;p&gt;\[\int_a^b f(x)dx = F(b) - F(a) \]&lt;/p&gt;
&lt;p&gt;所以我们重点关注的是等式右边，等式右边也做类似处理，我们假设&lt;span class=&quot;math inline&quot;&gt;\(\Phi(t) = F(\phi(t))\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;我们对&lt;span class=&quot;math inline&quot;&gt;\(\Phi(t)\)&lt;/span&gt;求导，可以得到：&lt;/p&gt;
&lt;p&gt;\[\Phi'(t) = \frac{dF}{d\phi}\cdot \frac{d\phi}{dt} = f(x)\cdot \phi'(t) = f[\phi(t)]\cdot \phi'(t) \]&lt;/p&gt;
&lt;p&gt;通过求导我们可以发现，&lt;span class=&quot;math inline&quot;&gt;\(\Phi(t)\)&lt;/span&gt;是&lt;span class=&quot;math inline&quot;&gt;\(f[\phi(t)]\cdot \phi'(t)\)&lt;/span&gt;的原函数。所以：&lt;/p&gt;
&lt;p&gt;\[\begin{aligned} \int_\alpha^\beta f[\phi(t)]\phi'(t)dt &amp;amp;= \Phi(\beta) - \Phi(\alpha)\\ &amp;amp;= F[\phi(\beta)] - F[\phi(\alpha)] \\ &amp;amp;= F(b) - F(a) \end{aligned} \]&lt;/p&gt;
&lt;p&gt;所以我们就证明完了，整个证明过程并不难，比较困难的点在于我们在处理等式右边的时候是怎么想到令&lt;span class=&quot;math inline&quot;&gt;\(\Phi(t) = F(\phi(t))\)&lt;/span&gt;的呢？这是一个非常巧妙的点。想到这个不太容易，如果是我从头开始证明，我可能会往&lt;span class=&quot;math inline&quot;&gt;\(\phi(t)\)&lt;/span&gt;的原函数上想，估计不太容易想到将F(x)引入进来。&lt;/p&gt;
&lt;p&gt;我们理解了换元求解定积分的方法之后，我们一起来看一道例题来熟悉一下。这个例题还是经典的三角换元：&lt;/p&gt;
&lt;p&gt;\[\int_0^a \sqrt{a^2 - x^2}dx \quad (a&amp;gt;0) \]&lt;/p&gt;
&lt;p&gt;我们很容易想到我们可以令&lt;span class=&quot;math inline&quot;&gt;\(x = a\sin t\)&lt;/span&gt;，这样的话&lt;span class=&quot;math inline&quot;&gt;\(dx = a\cos t dt\)&lt;/span&gt;。当x=0时，t=0，当x=a时，t=&lt;span class=&quot;math inline&quot;&gt;\(\frac{\pi}{2}\)&lt;/span&gt;，我们代入原式可以得到：&lt;/p&gt;
&lt;p&gt;\[\begin{aligned} \int_0^a \sqrt{a^2 - x^2}dx &amp;amp;= a^2 \int_0^\frac{\pi}{2} \cos ^2 tdt \\ &amp;amp;= \frac{a^2}{2}\int_0^\frac{\pi}{2} (1 + \cos 2t)dt \\ &amp;amp;= \frac{a^2}{2}[t + \frac{1}{2}\sin 2t]_0 ^\frac{\pi}{2}\\ &amp;amp;= \frac{\pi a^2}{4} \end{aligned} \]&lt;/p&gt;
&lt;p&gt;明白了原理之后，我们也可以将换元公式反过来用。也就是说当我们凑到&lt;span class=&quot;math inline&quot;&gt;\(t = \phi(x)\)&lt;/span&gt;的情况时，也一样可以使用换元公式。&lt;/p&gt;
&lt;p&gt;我们再来看一个例子：&lt;/p&gt;
&lt;p&gt;\[\int_0^\frac{\pi}{2}\cos ^5 x \sin x dx \]&lt;/p&gt;
&lt;p&gt;我们很容易凑到&lt;span class=&quot;math inline&quot;&gt;\(t = \cos x\)&lt;/span&gt;时，&lt;span class=&quot;math inline&quot;&gt;\(dt = -\sin x dx\)&lt;/span&gt;，当x=0时，t=1， 当x=&lt;span class=&quot;math inline&quot;&gt;\(\frac{\pi}{2}\)&lt;/span&gt;时，t=0。我们代入原式，可以得到：&lt;/p&gt;
&lt;p&gt;\[\begin{aligned} \int_0^\frac{\pi}{2}\cos ^5 x \sin x dx &amp;amp;= -\int_1^0 t^5 dt\\ &amp;amp;= \int_0^1 t^5 dt = [\frac{t}{6}]_0^1 = \frac{1}{6} \end{aligned} \]&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;分部积分法&quot;&gt;分部积分法&lt;/h2&gt;
&lt;p&gt;不定积分的分部积分法是根据求导公式推导得出的，它在定积分当中同样适用，我们只需要稍作变形就可以推导出来：&lt;/p&gt;
&lt;p&gt;\[\begin{aligned} \int_a^b u(x)v'(x)dx &amp;amp;= [\int u(x)v'(x)dx]_a^b\\ &amp;amp;= [u(x)v(x) - \int v(x)u'(x)dx]_a^b\\ &amp;amp;= [u(x)v(x)]_a^b - \int_a^b v(x)u'(x) dx \end{aligned} \]&lt;/p&gt;
&lt;p&gt;我们把上面的式子可以简写成：&lt;span class=&quot;math inline&quot;&gt;\(\int_a^b uv' dx = [uv]_a^b - \int_a^b vu' dx\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;来看个例子：$\int_0^\pi x\cos x dx $&lt;/p&gt;
&lt;p&gt;我们令u = x, dv = &lt;span class=&quot;math inline&quot;&gt;\(\cos x\)&lt;/span&gt;，那么v = &lt;span class=&quot;math inline&quot;&gt;\(\sin x\)&lt;/span&gt;，我们代入就可以得到：&lt;/p&gt;
&lt;p&gt;\[\begin{aligned} \int_0^\pi x\cos x dx &amp;amp;= [x \sin x]_0^\pi - \int_0^\pi \sin x dx \\ &amp;amp;= 0 + [\cos x]_0^\pi \\ &amp;amp;= -2 \end{aligned} \]&lt;/p&gt;
&lt;p&gt;和不定积分一样，分部积分法和换元法可以结合使用，得到更强大的效果。我们来看个例子：$$\int_0^1 e^{\sqrt{x}} dx$$&lt;/p&gt;
&lt;p&gt;我们令&lt;span class=&quot;math inline&quot;&gt;\(t = \sqrt{x}\)&lt;/span&gt;，于是&lt;span class=&quot;math inline&quot;&gt;\(x = t^2, dx = 2tdt\)&lt;/span&gt;，并且当x=0时，t=0，当x=1时，t=1。我们代入可得：&lt;/p&gt;
&lt;p&gt;\[\int_0^1 e^{\sqrt{x}} dx = 2\int_0^1 t e^t dt = 2\int_0^1 td(e^t) \]&lt;/p&gt;
&lt;p&gt;我们使用分部积分法，令u=t, dv = &lt;span class=&quot;math inline&quot;&gt;\(e^t\)&lt;/span&gt;，所以&lt;span class=&quot;math inline&quot;&gt;\(v = e^t\)&lt;/span&gt;，代入可以得到：&lt;/p&gt;
&lt;p&gt;\[\begin{aligned} 2\int_0^1 td(e^t) &amp;amp;= 2([te^t]_0^1 - \int_0^1 e^t dt) \\ &amp;amp;= 2(e - e + 1) = 2 \end{aligned} \]&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;换元法和分部积分法是求解定积分和不定积分的&lt;strong&gt;两大最重要的方法&lt;/strong&gt;，这两个方法说起来容易，理解起来也不难，但是很容易遗忘。尤其是我们长时间不使用的情况下，经常会忘记，而在用的时候又经常会想不起来，典型的书到用时方恨少问题。所以我们经常拿出来复习回顾一下，还是很有必要的。&lt;/p&gt;
&lt;p&gt;今天的文章就到这里，原创不易，需要你&lt;strong&gt;一个关注&lt;/strong&gt;的支持~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/5/2/171d2c8a54990161?w=258&amp;amp;h=258&amp;amp;f=png&amp;amp;s=23988&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 02 May 2020 00:30:00 +0000</pubDate>
<dc:creator>TechFlow2019</dc:creator>
<og:description>本文始发于个人公众号： TechFlow ，原创不易，求个关注 今天是 高等数学的第14篇 文章，我们一起来看看定积分的换元法和分部积分法。 我们之前在不定积分的内容当中曾经介绍过 换元法和分部积分法</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/techflow/p/12816757.html</dc:identifier>
</item>
<item>
<title>vue2.x学习笔记（三十二） - 杨冠标</title>
<link>http://www.cnblogs.com/yanggb/p/12684744.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yanggb/p/12684744.html</guid>
<description>&lt;p&gt;接着前面的内容：&lt;a href=&quot;https://www.cnblogs.com/yanggb/p/12684060.html&quot;&gt;https://www.cnblogs.com/yanggb/p/12684060.html&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;深入响应式原理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;vue最独特的特性之一，是其非侵入式（耦合度低）的响应式系统：数据模型仅仅是普通的javascript对象，当你修改它们的时候，视图会自动进行更新。这一特性使得状态管理非常简单直接，不过理解其工作原理同样重要，因为这样你才可以避开一些常见的问题。因此在这里研究下vue响应式系统的底层实现细节。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;vue是如何追踪变化的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;当你把一个普通的javascript对象传入vue实例作为data选项，vue将会遍历此对象所有的属性，并使用【Object.defineProperty】把这些属性全部转为getter/setter（所谓的数据劫持）。【Object.defineProperty】是es5中一个无法shim的特性，这就是vue不支持ie8及更低版本浏览器的根本原因。&lt;/p&gt;
&lt;p&gt;这些getter/setter对于用户来说是不可见的，但是在内部它们让vue能够追踪依赖，在属性被访问和修改时通知变更。这里需要注意的是，不同浏览器在控制台打印数据对象时对geter/setter的格式化并不相同，所以建议是安装vue-devtools来获取对检查数据更加友好的用户界面。&lt;/p&gt;
&lt;p&gt;而每个组件实例都对应一个watcher实例，它会在组件渲染的过程中把&quot;接触&quot;过的数据属性记录为依赖。之后当依赖项的setter触发的时候，就会通知watcher，从而使它关联的组件重新渲染。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/842514/202004/842514-20200412115815887-69472892.png&quot; alt=&quot;&quot; width=&quot;623&quot; height=&quot;389&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;检测变化的注意事项&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;由于javascript本身的限制，vue并不能检测数组和对象的变化。尽管如此，我们还是可以想到一些别的方法来回避这些限制并保证它们的响应性。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;vue无法检测property的添加或移除。由于vue会在初始化实例的时候对属性执行getter/setter转化，所以属性必须在data对象上存在才能让vue将它转换为响应式的。例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; vm = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
  data:{
    a:&lt;/span&gt;1&lt;span&gt;
  }
})

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; vm.a是响应式的&lt;/span&gt;
&lt;span&gt;
vm.b &lt;/span&gt;= 2
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; vm.b是非响应式的&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于已经创建的实例，vue不允许动态添加根级别的响应式属性。但是，可以使用【Vue.set(object, propertyName, value)】方法向嵌套对象添加响应式属性。例如，对于：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
Vue.set(vm.someObject, 'b', 2)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另外也可以使用【vm.$set】实例方法，这也是全局【Vue.set】方法的别名：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;this&lt;/span&gt;.$set(&lt;span&gt;this&lt;/span&gt;.someObject,'b',2)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;有时你可能需要为已有的对象赋值多个新属性，比如使用【Object.assign()】或【_.extend()】。但是，这样添加到对象上的新属性不会触发更新。在这种情况下，你应该用源对象与要混合进去的对象的属性一起创建一个新对象的方式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 代替Object.assign(this.someObject, { a: 1, b: 2 })&lt;/span&gt;
&lt;span&gt;this&lt;/span&gt;.someObject = Object.assign({}, &lt;span&gt;this&lt;/span&gt;.someObject, { a: 1, b: 2 })
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;对于数组&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;vue不能检测以下数组的变动：&lt;/p&gt;
&lt;p&gt;1.当你利用索引直接设置一个数组项的时候，例如：vm.items[indexOfItem] = newValue。&lt;/p&gt;
&lt;p&gt;2.当你修改数组的长度时，例如：vm.items.length = newLength。&lt;code&gt;&lt;br/&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; vm = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
  data: {
    items: [&lt;/span&gt;'a', 'b', 'c'&lt;span&gt;]
  }
})
vm.items[&lt;/span&gt;1] = 'x' &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 不是响应性的&lt;/span&gt;
vm.items.length = 2 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 不是响应性的&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为了解决第一类问题，以下两种方式都可以实现和vm.items[indexOfItem] = newValue相同的效果，同时也将在响应式系统内触发状态更新：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Vue.set&lt;/span&gt;
&lt;span&gt;Vue.set(vm.items, indexOfItem, newValue)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; vm.$set&lt;/span&gt;
vm.$set(vm.items, indexOfItem, newValue)
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Array.prototype.splice&lt;/span&gt;
vm.items.splice(indexOfItem, 1, newValue)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而为了解决第二类问题，你可以使用splice()方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
vm.items.splice(newLength)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是因为，splice()是一个变异方法，vue对其做了相应的包裹处理。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;声明响应式属性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;由于vue并不允许动态地添加根级响应式属性，因此你必须在初始化实例前声明所有根级响应式属性，哪怕只是一个空值（一个萝卜一个坑，先占个位保平安）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; vm = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
  data: {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 声明message为一个空值字符串&lt;/span&gt;
    message: ''&lt;span&gt;
  },
  template: &lt;/span&gt;'&amp;lt;div&amp;gt;{{ message }}&amp;lt;/div&amp;gt;'&lt;span&gt;
})
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 之后设置message&lt;/span&gt;
vm.message = 'Hello!'
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果你未在data选项中声明message，vue将会警告你渲染函数正在视图访问不存在的属性。&lt;/p&gt;
&lt;p&gt;这样的限制在背后其实是有其技术原因的：它消除了在依赖项跟踪系统中的一类边界情况，也使vue实例能够更好地配合类型检查系统工作。但与此同时，在代码可维护性方面也有一点重要的考虑：data对象就像组件状态的结构（schema），提前声明所有的响应式属性，可以让组件代码在未来修改或给其他开发/维护人员阅读时更易于理解。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;异步更新队列&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;可能你还没有注意到，vue在更新dom的时候是异步执行的。只要侦听到数据变化，vue将会开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个watcher被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和dom操作是非常重要的。然后，在下一个事件循环【tick】中，vue刷新队列并执行实际（已去重）工作。vue在内部对异步队列尝试使用原生的【Promise.then】、【MutationObserver】和【setImmediate】，如果执行环境不支持，则会采用【setTimeout(fn, 0)】代替。&lt;/p&gt;
&lt;p&gt;例如，当你设置vm.someData = 'new value'，该组件不会立即重新渲染。当刷新队列的时候，组件会在下一个事件循环【tick】中更新。多数情况下，我们并不需要关心这个过程，但是如果你想要基于更新之后的dom状态来做些什么，这就可能会有点棘手。虽然vue通常鼓励开发人员使用【数据驱动】的方式思考，避免直接接触dom，但是有些时候我们是必须要这么做的。为了在数据变化之后等待vue完成更新dom的操作，可以在数据变化之后立即使用【Vue.nextTick(callback)】。这样，回调函数将会在dom更新完成之后被调用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;example&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{message}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; vm = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
  el: &lt;/span&gt;'#example'&lt;span&gt;,
  data: {
    message: &lt;/span&gt;'123'&lt;span&gt;
  }
})
vm.message &lt;/span&gt;= 'new message' &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 更改数据&lt;/span&gt;
vm.$el.textContent === 'new message' &lt;span&gt;//&lt;/span&gt;&lt;span&gt; false&lt;/span&gt;
Vue.nextTick(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
  vm.$el.textContent &lt;/span&gt;=== 'new message' &lt;span&gt;//&lt;/span&gt;&lt;span&gt; true&lt;/span&gt;
})
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而在组件内使用【vm.$nextTick()】实例方法特别方便，因为它不需要全局Vue，并且回调函数中的this将自动绑定到当前的vue实例上：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
Vue.component('example'&lt;span&gt;, {
  template: &lt;/span&gt;'&amp;lt;span&amp;gt;{{ message }}&amp;lt;/span&amp;gt;'&lt;span&gt;,
  data: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
      message: &lt;/span&gt;'未更新'&lt;span&gt;
    }
  },
  methods: {
    updateMessage: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.message = '已更新'&lt;span&gt;
      console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$el.textContent) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; '未更新'&lt;/span&gt;
      &lt;span&gt;this&lt;/span&gt;.$nextTick(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$el.textContent) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; '已更新'&lt;/span&gt;
&lt;span&gt;      })
    }
  }
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为【$nextTick()】返回的是一个Promise对象，所以你可以使用新的es207中提供的async/await语法来完成同样的事情：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;methods: {
  updateMessage: async &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.message = '已更新'&lt;span&gt;
    console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$el.textContent) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; '未更新'&lt;/span&gt;
    await &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$nextTick()
    console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$el.textContent) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; '已更新'&lt;/span&gt;
&lt;span&gt;  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里将【$nextTIck()】的执行放到了同步的环境中（await修饰符），因此后续的代码是在dom更新完成之后才执行的。&lt;/p&gt;

&lt;p&gt;&quot;我还是很喜欢你，像留白于水墨丹青，不留痕迹。&quot;&lt;/p&gt;
</description>
<pubDate>Fri, 01 May 2020 23:08:00 +0000</pubDate>
<dc:creator>杨冠标</dc:creator>
<og:description>接着前面的内容：https://www.cnblogs.com/yanggb/p/12684060.html。 深入响应式原理 vue最独特的特性之一，是其非侵入式（耦合度低）的响应式系统：数据模型仅</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yanggb/p/12684744.html</dc:identifier>
</item>
<item>
<title>（数据科学学习手札82）基于geopandas的空间数据分析——geoplot篇(上) - 费弗里</title>
<link>http://www.cnblogs.com/feffery/p/12779150.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/feffery/p/12779150.html</guid>
<description>&lt;blockquote readability=&quot;3.196261682243&quot;&gt;
&lt;p&gt;本文示例代码和数据已上传至我的&lt;code&gt;Github&lt;/code&gt;仓库&lt;a href=&quot;https://github.com/CNFeffery/DataScienceStudyNotes&quot;&gt;https://github.com/CNFeffery/DataScienceStudyNotes&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　在前面的&lt;em&gt;&lt;strong&gt;基于geopandas的空间数据分析&lt;/strong&gt;&lt;/em&gt;系列文章中，我们已经对&lt;code&gt;geopandas&lt;/code&gt;的基础知识、基础可视化，以及如何科学绘制分层设色地图展开了深入的学习，而利用&lt;code&gt;geopandas&lt;/code&gt;+&lt;code&gt;matplotlib&lt;/code&gt;进行地理可视化固然能实现常见的地图可视化，且提供了操纵图像的极高自由度，但对使用者&lt;code&gt;matplotlib&lt;/code&gt;的熟悉程度要求较高，制作一幅地图可视化作品往往需要编写较多的代码，而&lt;code&gt;geoplot&lt;/code&gt;基于&lt;code&gt;geopandas&lt;/code&gt;，提供了众多高度封装的绘图API，很大程度上简化了绘图难度，就像&lt;code&gt;seaborn&lt;/code&gt;之于&lt;code&gt;matplotlib&lt;/code&gt;。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1344061/202005/1344061-20200502015722953-615590685.png&quot; alt=&quot;图1&quot;/&gt;&lt;/center&gt;
&lt;center&gt;&lt;span&gt;图1&lt;/span&gt;&lt;/center&gt;
&lt;p&gt;　　本文是&lt;em&gt;&lt;strong&gt;基于geopandas的空间数据分析&lt;/strong&gt;&lt;/em&gt;系列文章的第6篇，通过本文你将学习&lt;code&gt;geoplot&lt;/code&gt;中的基础绘图API。&lt;/p&gt;

&lt;p&gt;　　推荐使用&lt;code&gt;conda install --channel conda-forge geoplot&lt;/code&gt;来安装&lt;code&gt;geoplot&lt;/code&gt;，可以避免很多恼人的依赖包问题。首先我们从一个简单的例子来初探一下&lt;code&gt;geoplot&lt;/code&gt;的基础使用流程：&lt;/p&gt;
&lt;h2 id=&quot;21-从一个简单的例子出发&quot;&gt;2.1 从一个简单的例子出发&lt;/h2&gt;
&lt;p&gt;　　我们下面所使用到的数据：&lt;code&gt;nyc-boroughs.geojson&lt;/code&gt;，记录了纽约的行政区域面文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Python&quot;&gt;import geopandas as gpd

%matplotlib inline

# 读入纽约行政区域面文件
nyc_boroughs = gpd.read_file('geometry/nyc-boroughs.geojson')
nyc_boroughs.head()
&lt;/code&gt;
&lt;/pre&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1344061/202005/1344061-20200502015726593-1086422628.png&quot; alt=&quot;图2&quot;/&gt;&lt;/center&gt;
&lt;center&gt;&lt;span&gt;图2&lt;/span&gt;&lt;/center&gt;
&lt;p&gt;　　以及&lt;code&gt;nyc-collision-factors.geojson&lt;/code&gt;，包含了纽约所发生的车祸记录点以及相关信息数据：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Python&quot;&gt;# 读入纽约车祸记录点文件
nyc_collision_factors = gpd.read_file('geometry/nyc-collision-factors.geojson')
nyc_collision_factors.head()
&lt;/code&gt;
&lt;/pre&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1344061/202005/1344061-20200502015729398-651726687.png&quot; alt=&quot;图3&quot;/&gt;&lt;/center&gt;
&lt;center&gt;&lt;span&gt;图3&lt;/span&gt;&lt;/center&gt;
&lt;p&gt;　　首先我们使用&lt;code&gt;geoplot&lt;/code&gt;中的&lt;code&gt;polyplot&lt;/code&gt;来绘制纽约行政区划，这里使用&lt;code&gt;geoplot&lt;/code&gt;自带的&lt;em&gt;&lt;strong&gt;Albers等面积投影&lt;/strong&gt;&lt;/em&gt;作为投影：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Python&quot;&gt;import geoplot as gplt
import geoplot.crs as gcrs
import matplotlib.pyplot as plt

ax = gplt.polyplot(df=nyc_boroughs,
                   projection=gcrs.AlbersEqualArea())

plt.savefig(&quot;图4.png&quot;, bbox_inches='tight', pad_inches=0, dpi=300)
&lt;/code&gt;
&lt;/pre&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1344061/202005/1344061-20200502015732263-1635442659.png&quot; alt=&quot;图4&quot;/&gt;&lt;/center&gt;
&lt;center&gt;&lt;span&gt;图4&lt;/span&gt;&lt;/center&gt;
&lt;p&gt;　　接着我们使用&lt;code&gt;geoplot&lt;/code&gt;中的&lt;code&gt;pointplot&lt;/code&gt;将点叠加到图4上：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Python&quot;&gt;ax = gplt.polyplot(df=nyc_boroughs,
                   projection=gcrs.AlbersEqualArea())

ax = gplt.pointplot(df=nyc_collision_factors,
                    s=2,
                    color='grey',
                    alpha=0.2,
                    linewidth=0, # 设置轮廓粗细为0
                    ax=ax)

plt.savefig(&quot;图5.png&quot;, bbox_inches='tight', pad_inches=0, dpi=300)
&lt;/code&gt;
&lt;/pre&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1344061/202005/1344061-20200502015735753-1041311219.png&quot; alt=&quot;图5&quot;/&gt;&lt;/center&gt;
&lt;center&gt;&lt;span&gt;图5&lt;/span&gt;&lt;/center&gt;
&lt;p&gt;　　为了让车祸密集的区域更突出，我们将点图层换成核密度图层：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Python&quot;&gt;ax = gplt.polyplot(df=nyc_boroughs,
                   projection=gcrs.AlbersEqualArea())

# 叠加核密度图层
ax = gplt.kdeplot(df=nyc_collision_factors,
                  cmap='Reds',
                  shade=True,
                  shade_lowest=True,
                  clip=nyc_boroughs,
                  ax=ax)

plt.savefig(&quot;图6.png&quot;, bbox_inches='tight', pad_inches=0, dpi=300)
&lt;/code&gt;
&lt;/pre&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1344061/202005/1344061-20200502015739053-2041154693.png&quot; alt=&quot;图6&quot;/&gt;&lt;/center&gt;
&lt;center&gt;&lt;span&gt;图6&lt;/span&gt;&lt;/center&gt;
&lt;p&gt;　　从这个简单的例子中我们可以大致了解到，&lt;code&gt;geoplot&lt;/code&gt;在&lt;code&gt;geopandas&lt;/code&gt;处理好的数据基础上，针对不同类型图层封装了各自不同的API，由用户自主传入对应类型的矢量数据进行图层叠加，以得到最终结果，且可以兼容&lt;code&gt;matplotlib&lt;/code&gt;，譬如上面我们最终使用&lt;code&gt;plt.savaefig()&lt;/code&gt;对图片进行保存，下面我们就来详细学习&lt;code&gt;geoplot&lt;/code&gt;的基础知识。&lt;/p&gt;
&lt;h2 id=&quot;22-geoplot绘图api&quot;&gt;2.2 geoplot绘图API&lt;/h2&gt;
&lt;p&gt;　　在&lt;code&gt;geoplot&lt;/code&gt;中内置了功能丰富的绘图API，只需要传入&lt;code&gt;GeoDataFrame&lt;/code&gt;格式的矢量数据即可进行绘图（&lt;strong&gt;但切记geoplot中传入的数据必须为WGS84地理坐标系，所有的投影转换在geoplot各绘图函数内部传参实现即可！&lt;/strong&gt;）&lt;/p&gt;
&lt;h3 id=&quot;221-pointplot&quot;&gt;2.2.1 Pointplot&lt;/h3&gt;
&lt;p&gt;　　&lt;code&gt;geoplot&lt;/code&gt;中的&lt;code&gt;pointplot&lt;/code&gt;即为散点图，其针对点数据进行可视化，其主要参数如下：&lt;/p&gt;
&lt;blockquote readability=&quot;59&quot;&gt;
&lt;p&gt;&lt;strong&gt;df&lt;/strong&gt;：传入对应的&lt;code&gt;GeoDataFrame&lt;/code&gt;对象&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;projection&lt;/strong&gt;：用于指定投影坐标系，传入&lt;code&gt;geoplot.crs&lt;/code&gt;中的对象&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;hue&lt;/strong&gt;：当需要根据&lt;strong&gt;df&lt;/strong&gt;中的某列或外部的其他序列数据来映射散点的色彩时，可传入对应&lt;strong&gt;df&lt;/strong&gt;中指定列名或外部序列数据，默认为None即不进行设色&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;cmap&lt;/strong&gt;：和&lt;code&gt;matplotlib&lt;/code&gt;中的&lt;strong&gt;cmap&lt;/strong&gt;使用方式一致，用于控制色彩映射方案&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;scheme&lt;/strong&gt;：作用类似&lt;code&gt;geopandas&lt;/code&gt;中的&lt;strong&gt;scheme&lt;/strong&gt;参数，用于控制分层设色，详见本系列文章的&lt;em&gt;&lt;strong&gt;分层设色篇&lt;/strong&gt;&lt;/em&gt;，但不同的是在&lt;code&gt;geoplot&lt;/code&gt;0.4.0版本之后此参数不再搭配分层数量&lt;em&gt;k&lt;/em&gt;共同使用，而是更新为传入&lt;code&gt;mapclassify&lt;/code&gt;分段结果对象，下文中会做具体演示&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;scale&lt;/strong&gt;：用于设定映射散点大小的序列数据，格式同&lt;strong&gt;hue&lt;/strong&gt;，默认为None即每个散点等大小&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;limits&lt;/strong&gt;：元组型，当&lt;strong&gt;scale&lt;/strong&gt;不为None时，用于设定散点大小尺寸范围，格式为&lt;code&gt;(min, max)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;s&lt;/strong&gt;：当&lt;strong&gt;scale&lt;/strong&gt;设置为None时，用于控制散点的尺寸大小&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;color&lt;/strong&gt;：当&lt;strong&gt;hue&lt;/strong&gt;设置为None时，用于控制散点的填充色彩&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;marker&lt;/strong&gt;：用于设定散点的形状&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;alpha&lt;/strong&gt;：控制全局色彩透明度&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;linewidths&lt;/strong&gt;：控制散点轮廓宽度&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;edgecolors&lt;/strong&gt;：控制散点轮廓颜色&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;legend&lt;/strong&gt;：bool型，用于控制是否显示图例&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;legend_var&lt;/strong&gt;：传入&lt;code&gt;'hue'&lt;/code&gt;或&lt;code&gt;scale&lt;/code&gt;，当设定为&lt;code&gt;hue&lt;/code&gt;时图例显示色彩映射信息，当设定为&lt;code&gt;'scale'&lt;/code&gt;时图例显示大小映射信息&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;legend_values&lt;/strong&gt;：list型，用于自定义图例显示的各个具体数值&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;legend_labels&lt;/strong&gt;：list型，用于自定义图例显示的各个具体数值对应的文字标签，与&lt;strong&gt;legend_values&lt;/strong&gt;搭配使用&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;legend_kwargs&lt;/strong&gt;：字典，在&lt;strong&gt;legend&lt;/strong&gt;参数设置为True时来传入更多微调图例属性的参数&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;extent&lt;/strong&gt;：元组型，用于传入左下角和右上角经纬度信息来设置地图空间范围，格式为&lt;code&gt;(min_longitude, min_latitude, max_longitude, max_latitude)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;figsize&lt;/strong&gt;：元组型，用于控制画幅大小，格式为&lt;code&gt;(x, y)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ax&lt;/strong&gt;：&lt;code&gt;matplotlib&lt;/code&gt;坐标轴对象，如果需要在同一个坐标轴内叠加多个图层就需要用这个参数传入先前待叠加的&lt;code&gt;ax&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　知晓了上述主要参数之后，下面我们通过实际案例来学习修改各个参数得到的效果，使用到的数据为波士顿区划面数据以及波士顿部分地区&lt;em&gt;Airbnb&lt;/em&gt;房源点数据：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1344061/202005/1344061-20200502015742003-814465985.png&quot; alt=&quot;图7&quot;/&gt;&lt;/center&gt;
&lt;center&gt;&lt;span&gt;图7&lt;/span&gt;&lt;/center&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Python&quot;&gt;# 简单绘制波士顿行政区划
ax = gplt.polyplot(df=boston_zip_codes,
                   projection=gcrs.AlbersEqualArea(),
                   edgecolor='lightgrey',
                   linewidths=0.5)

gplt.pointplot(df=boston_airbnb_listings,
               ax=ax, # 叠加图层
               s=1,
               linewidths=0.1,
               color='grey',
               alpha=0.4)

plt.savefig(&quot;图8.png&quot;, bbox_inches='tight', pad_inches=0, dpi=300)
&lt;/code&gt;
&lt;/pre&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1344061/202005/1344061-20200502015745143-273157300.png&quot; alt=&quot;图8&quot;/&gt;&lt;/center&gt;
&lt;center&gt;&lt;span&gt;图8&lt;/span&gt;&lt;/center&gt;
&lt;p&gt;　　通过这样一张简单的图我们是看不出太多信息的，只能大致看出哪些地方房源分布较多。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;映射房源价格到色彩上&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　将房源价格列作为色彩映射列，使用&lt;code&gt;mapclassify&lt;/code&gt;中的分位数法将价格区间等分成五段，并使用其他的视觉参数和自定义图例参数：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Python&quot;&gt;import mapclassify as mc

#解决中文显示问题
plt.rcParams['font.sans-serif'] = ['SimHei'] # 指定默认字体
plt.rcParams['axes.unicode_minus'] = False # 解决保存图像是负号'-'显示为方块的问题

# 简单绘制波士顿行政区划
ax = gplt.polyplot(df=boston_zip_codes,
                   projection=gcrs.AlbersEqualArea(),
                   edgecolor='lightgrey',
                   linewidths=0.5)

scheme = mc.Quantiles(boston_airbnb_listings['price'], k=5)
gplt.pointplot(df=boston_airbnb_listings,
               ax=ax, # 叠加图层
               s=1, # 散点大小
               linewidths=0.1, # 散点轮廓宽度
               hue='price', # 以price作为色彩映射列
               cmap='Reds', # 色彩方案为Reds
               scheme=scheme, # 传入mapclassify对象
               legend=True, # 开启图例
               legend_kwargs={
                   'loc': 'lower right', # 图例位置
                   'title': '价格区间', # 图例标题
                   'title_fontsize': 8, # 图例标题字体大小
                   'fontsize': 6, # 图例非标题外字体大小
                   'shadow': True, # 添加图例阴影
               },
               legend_labels=['80%-100%价格房源',
                              '60%-80%价格房源',
                              '40%-60%价格房源',
                              '20%-40%价格房源',
                              '前20%价格房源'])

plt.savefig(&quot;图9.png&quot;, bbox_inches='tight', pad_inches=0, dpi=300)
&lt;/code&gt;
&lt;/pre&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1344061/202005/1344061-20200502015748548-518661149.png&quot; alt=&quot;图9&quot;/&gt;&lt;/center&gt;
&lt;center&gt;&lt;span&gt;图9&lt;/span&gt;&lt;/center&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;映射房源价格到尺寸上&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　看完了如何映射颜色，下面我们来看看如何将值映射到散点大小上，使用&lt;code&gt;scale='price'&lt;/code&gt;来将房源价格映射到散点大小上，再配合一些相关参数进行绘图：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Python&quot;&gt;import numpy as np

# 简单绘制波士顿行政区划
ax = gplt.polyplot(df=boston_zip_codes,
                   projection=gcrs.AlbersEqualArea(),
                   edgecolor='lightgrey',
                   linewidths=0.5)

ax = gplt.pointplot(df=boston_airbnb_listings,
                    ax=ax, # 叠加图层
                    linewidths=0.2, # 散点轮廓宽度
                    scale='price', # 以price作为色彩映射列
                    color=np.array([0., 0., 0., 0.]), # 设置填充色为透明
                    edgecolor='grey', # 设置轮廓颜色
                    limits=(1, 16), # 设置散点的尺寸范围
                    legend=True, # 开启图例
                    legend_kwargs={
                        'loc': 'lower right', # 图例位置
                        'title': '价格区间', # 图例标题
                        'title_fontsize': 8, # 图例标题字体大小
                        'fontsize': 6, # 图例非标题外字体大小
                        'shadow': True, # 添加图例阴影
                        'markeredgecolor': 'grey', # 图例标记的轮廓色彩
                        'markeredgewidth': 0.2 # 图例标记的轮廓粗细
                    })

plt.savefig(&quot;图10.png&quot;, bbox_inches='tight', pad_inches=0, dpi=300)
&lt;/code&gt;
&lt;/pre&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1344061/202005/1344061-20200502015752643-76378755.png&quot; alt=&quot;图10&quot;/&gt;&lt;/center&gt;
&lt;center&gt;&lt;span&gt;图10&lt;/span&gt;&lt;/center&gt;
&lt;p&gt;　　现在我们可以一眼看出那些半径较大的圆圈对应着价格较高的房源，值得注意的是在我们映射值到散点大小上时，默认条件下会自动在图例中按照&lt;strong&gt;等间距法&lt;/strong&gt;分出5段，这样得到的图例各个圆圈大小过渡保证了均匀，当然你也可以自由地通过&lt;strong&gt;legend_values&lt;/strong&gt;和&lt;strong&gt;legeng_labels&lt;/strong&gt;这两个参数自定义图例内容。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;同时映射颜色与尺寸&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　&lt;code&gt;geoplot&lt;/code&gt;允许用户同时映射色彩和尺寸，但同一张图中的图例只能显示色彩或尺寸其中之一的信息，使用&lt;strong&gt;legend_var&lt;/strong&gt;参数来选择让哪一种映射信息显示在图例上：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Python&quot;&gt;# 简单绘制波士顿行政区划
ax = gplt.polyplot(df=boston_zip_codes,
                   projection=gcrs.AlbersEqualArea(),
                   edgecolor='lightgrey',
                   linewidths=0.5)

scheme = mc.Quantiles(boston_airbnb_listings['price'], k=5)
gplt.pointplot(df=boston_airbnb_listings,
               ax=ax, # 叠加图层
               scale='price', # 以price作为尺寸映射列
               limits=(1, 16), # 设置散点的尺寸范围
               alpha=0.6, # 设置散点透明度
               linewidths=0.1, # 散点轮廓宽度
               hue='price', # 以price作为色彩映射列
               cmap='Reds', # 色彩方案为Reds
               scheme=scheme, # 传入mapclassify对象
               legend=True, # 开启图例
               legend_kwargs={
                   'loc': 'lower right', # 图例位置
                   'title': '价格区间', # 图例标题
                   'title_fontsize': 8, # 图例标题字体大小
                   'fontsize': 6, # 图例非标题外字体大小
                   'shadow': True, # 添加图例阴影
               },
               legend_labels=['80%-100%价格房源',
                              '60%-80%价格房源',
                              '40%-60%价格房源',
                              '20%-40%价格房源',
                              '前20%价格房源'])

plt.savefig(&quot;图11.png&quot;, bbox_inches='tight', pad_inches=0, dpi=300)
&lt;/code&gt;
&lt;/pre&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1344061/202005/1344061-20200502015800448-910323056.png&quot; alt=&quot;图11&quot;/&gt;&lt;/center&gt;
&lt;center&gt;&lt;span&gt;图11&lt;/span&gt;&lt;/center&gt;
&lt;h3 id=&quot;222-polyplot&quot;&gt;2.2.2 Polyplot&lt;/h3&gt;
&lt;p&gt;　　&lt;code&gt;geoplot&lt;/code&gt;中的&lt;code&gt;polyplot&lt;/code&gt;用于绘制基础的面数据，并不像&lt;code&gt;pointplot&lt;/code&gt;那样带有值映射功能，其主要参数如下：&lt;/p&gt;
&lt;blockquote readability=&quot;31&quot;&gt;
&lt;p&gt;&lt;strong&gt;df&lt;/strong&gt;：传入对应的&lt;code&gt;GeoDataFrame&lt;/code&gt;对象&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;projection&lt;/strong&gt;：用于指定投影坐标系，传入&lt;code&gt;geoplot.crs&lt;/code&gt;中的对象&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;extent&lt;/strong&gt;：元组型，用于传入左下角和右上角经纬度信息来设置地图空间范围，格式为&lt;code&gt;(min_longitude, min_latitude, max_longitude, max_latitude)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;figsize&lt;/strong&gt;：元组型，用于控制画幅大小，格式为&lt;code&gt;(x, y)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ax&lt;/strong&gt;：&lt;code&gt;matplotlib&lt;/code&gt;坐标轴对象，如果需要在同一个坐标轴内叠加多个图层就需要用这个参数传入先前待叠加的&lt;code&gt;ax&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;alpha&lt;/strong&gt;：控制全局色彩透明度&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;linewidths&lt;/strong&gt;：控制线宽度&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;edgecolors&lt;/strong&gt;：控制线颜色&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;facecolor&lt;/strong&gt;：控制填充颜色&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;linestyle&lt;/strong&gt;：控制线样式，详情见本系列文章前作&lt;em&gt;&lt;strong&gt;基础可视化篇&lt;/strong&gt;&lt;/em&gt;图5&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;hatch&lt;/strong&gt;：控制填充阴影纹路，详情见本系列文章前作&lt;em&gt;&lt;strong&gt;基础可视化篇&lt;/strong&gt;&lt;/em&gt;图7&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　下面我们就对纽约区划面数据进行举例说明：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Python&quot;&gt;gplt.polyplot(df=nyc_boroughs,
              projection=gcrs.AlbersEqualArea(),
              figsize=(10, 10),
              linewidths=0.5,
              linestyle='-.',
              edgecolors='grey',
              facecolor='#d9c09e',
              hatch='--')

plt.savefig(&quot;图12.png&quot;, bbox_inches='tight', pad_inches=0, dpi=300)
&lt;/code&gt;
&lt;/pre&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1344061/202005/1344061-20200502015806348-610422824.png&quot; alt=&quot;图12&quot;/&gt;&lt;/center&gt;
&lt;center&gt;&lt;span&gt;图12&lt;/span&gt;&lt;/center&gt;
&lt;h3 id=&quot;223-webmap&quot;&gt;2.2.3 Webmap&lt;/h3&gt;
&lt;p&gt;　　&lt;code&gt;geoplot&lt;/code&gt;中的&lt;code&gt;webmap&lt;/code&gt;用来添加在线瓦片地图底图，使得我们可以在在线地图上图层，但目前暂时只支持叠加基于点要素的图层。值得&lt;strong&gt;注意&lt;/strong&gt;的是，因为常见在线地图如谷歌地图、OpenStreetMap、高德地图等的投影均为EPSG:3857也就是我们常说的&lt;em&gt;Web Mercator&lt;/em&gt;，所以一旦要使用&lt;code&gt;webmap&lt;/code&gt;，则投影锁死为EPSG:3857，其主要参数如下：&lt;/p&gt;
&lt;blockquote readability=&quot;23&quot;&gt;
&lt;p&gt;&lt;strong&gt;df&lt;/strong&gt;：传入对应的&lt;code&gt;GeoDataFrame&lt;/code&gt;对象&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;extent&lt;/strong&gt;：元组型，用于传入左下角和右上角经纬度信息来设置地图空间范围，格式为&lt;code&gt;(min_longitude, min_latitude, max_longitude, max_latitude)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;figsize&lt;/strong&gt;：元组型，用于控制画幅大小，格式为&lt;code&gt;(x, y)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ax&lt;/strong&gt;：&lt;code&gt;matplotlib&lt;/code&gt;坐标轴对象，如果需要在同一个坐标轴内叠加多个图层就需要用这个参数传入先前待叠加的&lt;code&gt;ax&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;zoom&lt;/strong&gt;：int型，控制在线地图底图的缩放级别，越大越清楚，同时获取瓦片地图资源从而渲染地图所耗费的时间也越多，上限由具体所使用的在线地图所决定，通常情况最大缩放级别为18&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;provider&lt;/strong&gt;：str型，用于指定在线地图底图的类型，下面会举例说明&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　下面我们将纽约车祸点数据叠加到在线地图上，这里我们选择&lt;code&gt;provider&lt;/code&gt;参数为&lt;em&gt;ST_TERRAIN_LINES&lt;/em&gt;，并设置缩放级别为11级：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Pyton&quot;&gt;ax = gplt.webmap(df=nyc_boroughs,
                 provider='ST_TERRAIN_LINES',
                 zoom=10)

ax = gplt.pointplot(df=nyc_collision_factors,
                    color='lightyellow',
                    edgecolor='yellow',
                    alpha=0.4,
                    s=1,
                    ax=ax)

plt.savefig(&quot;图13.png&quot;, bbox_inches='tight', pad_inches=0, dpi=300)
&lt;/code&gt;
&lt;/pre&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1344061/202005/1344061-20200502015813158-1054669430.png&quot; alt=&quot;图13&quot;/&gt;&lt;/center&gt;
&lt;center&gt;&lt;span&gt;图13&lt;/span&gt;&lt;/center&gt;
&lt;p&gt;　　如果想要切换底图样式，可以修改&lt;code&gt;provider&lt;/code&gt;参数的输入，目前为止所有可用的地图如下图所示：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1344061/202005/1344061-20200502015828108-461066772.png&quot; alt=&quot;图14&quot;/&gt;&lt;/center&gt;
&lt;center&gt;&lt;span&gt;图14&lt;/span&gt;&lt;/center&gt;
&lt;h2 id=&quot;23-在模仿中学习&quot;&gt;2.3 在模仿中学习&lt;/h2&gt;
&lt;p&gt;　　在本系列文章&lt;em&gt;&lt;strong&gt;基础可视化篇&lt;/strong&gt;&lt;/em&gt;的最后我们对数据可视化专家用&lt;code&gt;R&lt;/code&gt;绘制的澳大利亚火灾影响地图进行了模仿，从而加深对&lt;code&gt;geopandas&lt;/code&gt;数据可视化的融会贯通，而本文作为&lt;code&gt;geoplot&lt;/code&gt;篇的上半篇，介绍了&lt;code&gt;geoplot&lt;/code&gt;中最基本的几种数据可视化API，使得我们足以完成较为基础的数据可视化作品，而同样为了加深对上文所介绍知识的理解掌握，接下来我们再次对其他优秀的数据可视化作品进行模仿。&lt;/p&gt;
&lt;p&gt;　　这次我们要模仿的作品来自&lt;code&gt;Github&lt;/code&gt;仓库&lt;code&gt;https://github.com/Z3tt/30DayMapChallenge&lt;/code&gt;，是利用&lt;code&gt;R&lt;/code&gt;进行地理空间数据可视化的一个集锦仓库，要用&lt;code&gt;geoplot&lt;/code&gt;来模仿复现的作品如图15所示，展示了柏林所有电动汽车充电桩的分布情况：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1344061/202005/1344061-20200502015835523-265666802.png&quot; alt=&quot;图15&quot;/&gt;&lt;/center&gt;
&lt;center&gt;&lt;span&gt;图15&lt;/span&gt;&lt;/center&gt;
&lt;p&gt;　　我们主要浮现的是图15中柏林地图以及内部元素部分，使用到的数据在我的&lt;code&gt;Github&lt;/code&gt;仓库对应本文路径下的&lt;code&gt;Berlin&lt;/code&gt;文件夹中，其中&lt;code&gt;ladesaeulen_bnetza_und_be_emobil.xlsx&lt;/code&gt;记录了&lt;em&gt;EPSG:25833&lt;/em&gt;投影坐标系格式下的充电桩经纬度点信息，&lt;code&gt;gis_osm_roads_free_1.shp&lt;/code&gt;记录了柏林市OSM路网信息，&lt;code&gt;Bezirke__Berlin.shp&lt;/code&gt;记录了柏林行政区划信息。&lt;/p&gt;
&lt;p&gt;　　在分析了原图的&lt;code&gt;R&lt;/code&gt;代码之后，我们将整幅图拆解分为四个图层，1是柏林最边缘的灰色轮廓，这其实是整个柏林区域面数据向外生成缓冲区之后的效果；2是柏林各行政区区划，3是柏林内部的部分OSM路网，构成了图中依稀可见的类似纹路的要素，4是所有的充电桩点数据，即图中黄色的半透明散点，其中除路网线数据可视化以外的其他图层我们均使用&lt;code&gt;geoplot&lt;/code&gt;来实现。&lt;/p&gt;
&lt;p&gt;　　数据预处理部分分步骤代码较多，不便在文章中全盘放出，你可以到文章开头的&lt;code&gt;Github&lt;/code&gt;仓库中对应路径下查看和下载，下面只贴出绘图部分的代码以方便理解思想：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Python&quot;&gt;# 绘制最底层柏林缓冲区
ax = gplt.polyplot(df=gpd.GeoSeries([GeometryCollection(berlin_area.geometry.tolist())], crs='EPSG:4326') \
                         .buffer(0.005, resolution=100),
                   projection=gcrs.WebMercator(),
                   facecolor='grey',
                   edgecolor='None',
                   alpha=0.6)

# 绘制柏林区划
ax = gplt.polyplot(df=berlin_area,
                   facecolor='black',
                   edgecolor='white',
                   alpha=0.65,
                   ax=ax)

# 利用geopandas绘制内部OSM路网
ax = intersect_roads.plot(ax=ax, 
                          linewidth=0.1,
                          edgecolor='black',
                          alpha=0.25)

# 绘制充电桩散点
ax = gplt.pointplot(df=df_emobil,
                    ax=ax,
                    extent=berlin_area.total_bounds,
                    color='#edc00d',
                    alpha=0.3,
                    linewidth=0.2,
                    s=4.5)

# 绘制充电桩中心点
ax = gplt.pointplot(df=df_emobil,
                    ax=ax,
                    extent=berlin_area.buffer(0.01).total_bounds,
                    color='#d29c14',
                    edgecolor='#6f603e',
                    linewidth=0.01,
                    s=0.7)

plt.savefig(&quot;图16.png&quot;, bbox_inches='tight', pad_inches=0, dpi=600)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　最终得到的效果如图16所示：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1344061/202005/1344061-20200502015843753-1970694427.png&quot; alt=&quot;图16&quot;/&gt;&lt;/center&gt;
&lt;center&gt;&lt;span&gt;图16&lt;/span&gt;&lt;/center&gt;

&lt;p&gt;　　以上就是本文的全部内容，我将在下一篇文章中继续与大家一起探讨学习&lt;code&gt;geoplot&lt;/code&gt;中更高级的绘图API。如有疑问和意见，欢迎留言或在我的&lt;code&gt;Github&lt;/code&gt;仓库中发起&lt;em&gt;issues&lt;/em&gt;与我交流。&lt;/p&gt;
</description>
<pubDate>Fri, 01 May 2020 18:10:00 +0000</pubDate>
<dc:creator>费弗里</dc:creator>
<og:description>本文示例代码和数据已上传至我的 仓库 &amp;quot;https://github.com/CNFeffery/DataScienceStudyNotes&amp;quot; 1 简介 在前面的 基于geopan</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/feffery/p/12779150.html</dc:identifier>
</item>
<item>
<title>线程与同步异步 - Jscroop</title>
<link>http://www.cnblogs.com/Jscroop/p/12815466.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Jscroop/p/12815466.html</guid>
<description>&lt;h3 id=&quot;一、线程&quot;&gt;一、线程&lt;/h3&gt;
&lt;h4 id=&quot;1、什么是线程？什么是进程？两者有什么关系？&quot;&gt;1、什么是线程？什么是进程？两者有什么关系？&lt;/h4&gt;
&lt;p&gt;进程（Process）：进程代表了操作系统上运行着的一个应用程序，每个进程都有自己独立的边界，进程与进程之间不能共享资源，一个进程可以包含一个或多个线程；&lt;/p&gt;
&lt;p&gt;线程（Thread）：线程是被操作系统调度的基本单元，同一进程内的所有线程共享内存和资源，并且一个线程可以对同一进程内的其他线程进行访问或结束等操作；&lt;/p&gt;
&lt;p&gt;关系：它们是一个包含的关系，进程就像是线程的容器，且至少包含一个线程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2019059/202005/2019059-20200501234533178-982859884.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了更形象的理解该部分内容，可以参考阮一峰的 &lt;a href=&quot;http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html&quot; title=&quot;点击查看&quot;&gt;进程与线程的一个简单解释&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h4 id=&quot;2、系统是如何调用线程的？&quot;&gt;2、系统是如何调用线程的？&lt;/h4&gt;
&lt;p&gt;抢占式调度：所有的线程都在被不停地快速切换运行，使得用户感觉所有的线程都在并行运行；&lt;/p&gt;
&lt;p&gt;非抢占式调度：某个线程在运行时不会被操作系统强制暂停，它可以持续地运行直到运行告一段落并主动交出运行权；&lt;/p&gt;
&lt;p&gt;通常情况下，一些系统级别的线程采用的是非抢占式调度，而普通线程采用的是抢占式调度&lt;/p&gt;
&lt;hr/&gt;&lt;h4 id=&quot;3、调用会不会存在问题？&quot;&gt;3、调用会不会存在问题？&lt;/h4&gt;
&lt;p&gt;对于单核CPU的操作系统来说，线程在不停的切换，而每次切换线程内的数据也在被不停的搬入搬出，会在一定程度上影响性能开销；多核CPU的操作系统则可以并行的运行多个线程，理论上性能会成倍的提高。所以衍生出了多线程操作的概念&lt;/p&gt;
&lt;hr/&gt;&lt;h4 id=&quot;4、net中常见的线程对象&quot;&gt;4、.NET中常见的线程对象&lt;/h4&gt;
&lt;h5 id=&quot;4-1-多线程操作之thread对象&quot;&gt;4 .1 多线程操作之Thread对象&lt;/h5&gt;
&lt;p&gt;从.NET1.0开始，我们就可以就通过Thread对象创建、控制个线程；简单示例如下，我们创建了10个进程并调用，从结果上来看它们是多个线程并行运行的，且执行线程Id和结束的线程Id是可以对应上的；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2019059/202005/2019059-20200501234556023-2118045021.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;42-多线程操作之threadpool对象&quot;&gt;4.2 多线程操作之ThreadPool对象&lt;/h5&gt;
&lt;p&gt;上面可以看到，每次我们需要调用线程进行操作，都需要手动创建一个线程对象，执行完成后再交由GC去销毁，一定程度上会影响性能开销，而且使用起来不是很方便，所以CLR提供了一个叫“线程池(ThreadPool)”的对象&lt;/p&gt;
&lt;p&gt;线程池有以下特性：①当一个线程被使用完毕后并不会立刻被销毁，而是放入线程池中等待下一次使用；当应用程序需要一个新的线程时，就可以从线程池中直接获取一个已经存在的线程；②当线程池中的线程数小于线程池设置的下限时，线程池会创建新的线程；而当线程池中的线程数大于线程池设置的上限时，线程池将销毁多余的线程；&lt;/p&gt;
&lt;p&gt;那么我们怎么操作线程池呢，ThreadPool对象提供了几个静态方法，我们使用一个简单的，示例如下，创建一个线程池后，做与上一个示例相同的操作，可以看到3号线程被重复调用了两次（随机事件）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2019059/202005/2019059-20200501234610714-55953533.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;43-多线程操作之task对象&quot;&gt;4.3 多线程操作之Task对象&lt;/h5&gt;
&lt;p&gt;上面的示例可以看到，线程池的使用可以复用线程，一定程度上可以减少系统的开销。但是却有几个缺陷，比如：①不支持线程的挂起、取消等操作；②不支持线程的优先级设置；&lt;/p&gt;
&lt;p&gt;所以在.NET4.0又出现了Task对象，&lt;strong&gt;它是基于线程池实现的&lt;/strong&gt;，同时弥补了线程池功能上的一些不足，比如可以获取线程的状态，有完全的控制权等等，我们同样使用Task，做一个简单的示例，可以看到，任务2可以等待任务1执行完成后再执行自己的逻辑&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2019059/202005/2019059-20200501234626351-1719691625.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;44-多线程操作之parallel对象&quot;&gt;4.4 多线程操作之Parallel对象&lt;/h5&gt;
&lt;p&gt;并行Paralle内部使用的是Task对象，它提供了Parallel.Invoke, Parallel.For, Parallel.Forecah 三个方法。需要注意的是所有并行任务完成后才会返回结果，所以少量短时间任务建议不要使用Parallel。通常情况下比较适合处理密集计算的场合。我没用过就不写例子了😂，感兴趣的可以用Paralle对象的方法和for/foreach循环对比下看看。&lt;/p&gt;
&lt;hr/&gt;&lt;h4 id=&quot;5、什么是前台线程？什么是后台线程？&quot;&gt;5、什么是前台线程？什么是后台线程？&lt;/h4&gt;
&lt;p&gt;前面说明了一部分线程的概念与线程的操作，接下来我们来看看什么是前台线程，什么是后台线程。&lt;/p&gt;
&lt;p&gt;默认情况下，&lt;strong&gt;主应用程序线程和Thread对象创建的线程&lt;/strong&gt;会在前台执行；而&lt;strong&gt;线程池线程&lt;/strong&gt;和从非托管代码进入托管执行环境中的线程会在后台执行，所以ThreadPool、Task和Parallel都为后台线程。如果&lt;strong&gt;所有前台线程均已终止，后台线程不会保持运行&lt;/strong&gt;， 即所有前台线程停止后，CLR将停止所有后台线程并关闭。示例如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2019059/202005/2019059-20200501234706604-64752149.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;二、线程的数据&quot;&gt;二、线程的数据&lt;/h3&gt;
&lt;h5 id=&quot;1、线程的私有参数&quot;&gt;1、线程的&quot;私有&quot;参数&lt;/h5&gt;
&lt;p&gt;上面提到线程的一个特点是可以共享数据或资源，那么我们能定义一个参数，只供线程自己使用吗？答案是肯定的，我们可以使用线程本地存储(Thread Local Storage简称TLS)来达到这个目的。TLS是线程内部的一个结构，可以存放自己独享的数据，我们可以使用Thread.GetData和Thread.SetData来获取或设置数据。&lt;/p&gt;
&lt;p&gt;此外.NET还封装了一个叫ThreadStaticAttribute的对象，本质上它也是基于TLS实现的。&lt;/p&gt;
&lt;h5 id=&quot;2、线程的执行上下文&quot;&gt;2、线程的执行上下文&lt;/h5&gt;
&lt;p&gt;什么是线程执行上下文？它的英文是ExecutionContext，指线程执行过程中的上下文信息。每当新建一个线程，该对象就会从当前创建的线程传递至被创建的线程，以保证被创建的线程与创建的线程有部分相同的设置信息。&lt;/p&gt;
&lt;p&gt;若希望手动阻止上下文的流动，可以使用ExecutionContext类中的SuppressFlow方法&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;三、多线程同步&quot;&gt;三、多线程同步&lt;/h3&gt;
&lt;h5 id=&quot;1、什么是多线程同步？&quot;&gt;1、什么是多线程同步？&lt;/h5&gt;
&lt;p&gt;这里的同步是指数据上的同步而非线程操作上的同步，当多个线程同一时间去访问一个数据时，如何保证该数据的准确即是多线程中的重点问题之一。其实现方式都是基于锁🔒实现的，简单来说就是当一个线程访问时，将数据锁定，不允许其他线程访问，下面我们介绍一下几种类型的锁&lt;/p&gt;
&lt;h6 id=&quot;11、用户模式构造的锁&quot;&gt;1.1、用户模式构造的锁&lt;/h6&gt;
&lt;p&gt;它使用CPU指令来协调线程，速度很快。它是怎么实现同步的呢？举个例子🌰：线程1访问资源，使用用户构造模式的锁，线程2访问发现有锁后会进行等待，等待过程中会不停的去查看资源是否可用，直到资源可用为止。&lt;/p&gt;
&lt;p&gt;它的优点是速度快，一旦发现资源被释放了，就立即去访问资源；缺点就是因为它需要不停的去确认资源的状态，所以会一直占用CPU的资源，影响性能。综上，它适用于对资源占用时间短的线程同步场景。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;.NET中提供了两种用户模式锁：①Threading.Interlocked；②Thread.VolatileRead 和 Thread.VolatileWrite，它们都可以在简单数据类型上进行读写操作&lt;/em&gt;&lt;/p&gt;
&lt;h6 id=&quot;12、内核模式构造的锁&quot;&gt;1.2、内核模式构造的锁&lt;/h6&gt;
&lt;p&gt;它是对于用户模式的一个补充。它是怎么实现同步的呢？举个例子🌰：线程1访问资源，使用内核模式构造的锁，线程2访问资源发现有锁后会被系统要求进行睡眠，线程1使用完资源后通知系统，系统再唤醒线程2。&lt;/p&gt;
&lt;p&gt;它的优点是解决了不停去访问资源的情况，不会占用CPU的资源；缺点是存在用户模式下的托管代码和内核代码相互转换的过程，导致会延长处理时间。综上，它适合于需要长时间占用资源的线程同步场景。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;.NET中提供了两种内核模式锁：①基于事件的，如AutoResetEvent和ManualResetEvent；②基于信号量的，如Semaphore&lt;/em&gt;&lt;/p&gt;
&lt;h6 id=&quot;13、混合锁及其原理star&quot;&gt;1.3、混合锁及其原理⭐️&lt;/h6&gt;
&lt;p&gt;混合锁是基于两者的优点实现的，线程使用资源的时间很短，就使用用户模式构造同步，否则就升级到内核模式构造同步。常见的混合锁有SemaphoreSlim、ReadWriteLockSlim和Monitor，它们有各自适用的应用场景。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;下面我们看下经常使用的lock锁，它的本质是Monitor，微软为了开发者使用方便进行了简单的包装，即所谓的语法糖🍬，lock方法对应的主要是 Monitor的Enter和Exit方法。那么lock是怎么实现同步的呢？我们分三步看。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;①.NET在加载时就会新建一个&lt;strong&gt;同步块数组&lt;/strong&gt;，当对象&lt;strong&gt;需要被同步&lt;/strong&gt;时，.NET会为其&lt;strong&gt;分配一个同步块&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;②.NET在新建堆对象(即&lt;strong&gt;引用类型对象实例&lt;/strong&gt;)时会分配一个名为&lt;strong&gt;同步索引&lt;/strong&gt;的地址指针，初始值为-1不指向任何地址；&lt;/p&gt;
&lt;p&gt;③使用lock时， Monitor.Enter会创建或使用一个空闲的同步索引块，内部结构为混合锁结构，&lt;strong&gt;同步索引会指向同步块数组为其分配的同步块&lt;/strong&gt;；Monitor.Exit时，会将对象的同步索引重置为-1如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2019059/202005/2019059-20200501234724918-1427500418.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;再来看看经常讨论的两个问题：&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;①为什么值类型不能为lock的对象？&lt;/p&gt;
&lt;p&gt;值类型是在栈上创建的，即使装箱后变为引用类型，因每次装箱后地址不同，所以无法lock；&lt;/p&gt;
&lt;p&gt;②可以lock当前对象this吗？&lt;/p&gt;
&lt;p&gt;this为执行代码的当前对象，可以被任何人访问，会导致类型的使用者加入同步块队伍中，进而增加开销；&lt;/p&gt;
&lt;p&gt;&lt;span&gt;综上：对于实例方法的同步，一般采用私有的引用对象成员&lt;code&gt;private object 名称= new object();&lt;/code&gt;对于静态方法的同步，一般采用静态私有的引用对象成员&lt;code&gt;private static object 名称= new object();&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h5 id=&quot;2、互斥体mutex和信号量semaphore&quot;&gt;2、互斥体Mutex和信号量Semaphore&lt;/h5&gt;
&lt;h6 id=&quot;21什么是互斥体？&quot;&gt;2.1什么是互斥体？&lt;/h6&gt;
&lt;p&gt;它是指某些代码片段在任意时间内只允许一个线程进入。.NET中的Mutex类则是封装好的互斥体对象。&lt;/p&gt;
&lt;p&gt;看上去似乎和Monitor差不多，不同的是Mutex使用的是操作系统内核对象，而Monitor是在.NET下实现的，所以执行效率上Mutex会高一些；此外，Mutex可以跨应用程序域和进程，而Monitor只能同步同一应用程序域下面的线程。&lt;/p&gt;
&lt;h6 id=&quot;22、什么是信号量&quot;&gt;2.2、什么是信号量&lt;/h6&gt;
&lt;p&gt;信号量允许指定数量的线程同时访问资源，超出数量后会进行排队，知道之前的线程退出；如果Mutex是其n=1的版本，那么信号量就是n的版本。&lt;/p&gt;
&lt;p&gt;信号量适用于Web服务器高并发的场景，它接收两个参数，第一个为允许多少条线程进入(总数量)，第二个为指定多少个线程同时进入(一次进入多少个)；另外它不需要锁的持有者，所以一般声明为静态类型，比如&lt;code&gt;static Semaphore sem = new Semaphore(10, 2);&lt;/code&gt;&lt;/p&gt;
&lt;h5 id=&quot;3、开发中的多线程问题&quot;&gt;3、开发中的多线程问题&lt;/h5&gt;
&lt;h6 id=&quot;31、控件不允许跨线程访问&quot;&gt;3.1、控件不允许跨线程访问&lt;/h6&gt;
&lt;p&gt;WinForm的开发者在开发过程中使用多线程访问控件时，经常会遇到控件不允许跨线程访问的问题，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2019059/202005/2019059-20200501234748380-1358301296.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么是什么原因导致的呢？那是因为为了保证UI的线程安全，微软在GUI应用中引入了一个特殊的线程处理模型，导致控件只能访问由创建它的线程进行访问或修改。&lt;/p&gt;
&lt;h6 id=&quot;32、ui界面假死&quot;&gt;3.2、UI界面假死&lt;/h6&gt;
&lt;p&gt;在UI线程中执行耗时的计算操作，会导致UI的假死，出现该问题的原因要追溯到Windows的消息机制。&lt;/p&gt;
&lt;p&gt;Windows是基于消息机制的，GUI内部就好比是一个消息队列，GUI线程不断的循环处理消息，更新UI进行呈现，如果去处理耗时操作，GUI线程就无法处理队列中的其他消息，UI界面会处于假死状态。&lt;/p&gt;
&lt;p&gt;如下图，点击按钮2时因网络原因无法获取到对应的信息，主线程被阻塞，我们是无法点击按钮1的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2019059/202005/2019059-20200501234803149-1736251856.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h6 id=&quot;33、如何解决&quot;&gt;3.3、如何解决&lt;/h6&gt;
&lt;p&gt;不难想到的是可以使用线程，但是线程会有更新UI的问题阿，比如上面的例子我们改成可访问的网址又会出现不允许跨线程的问题，又该怎么办呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2019059/202005/2019059-20200501234815659-1965982408.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实系统已经提供了很多处理此类问题的对象，如Invoke，BeginInvoke，BackgroundWorker等，我们这边使用BeginInvoke进行示例，点击按钮2后仍然可以点击按钮1，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2019059/202005/2019059-20200501234825739-37997840.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;关于其他对象的使用可以看看&lt;span&gt;五维思考的文章 &lt;a href=&quot;https://www.cnblogs.com/zhaoshujie/p/9664915.html&quot; title=&quot;点击查看&quot;&gt;多线程总结(结合进度条)&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;四、同步异步与多线程&quot;&gt;四、同步异步与多线程&lt;/h3&gt;
&lt;h4 id=&quot;1、什么是同步？什么是异步？两者的差异是什么？&quot;&gt;1、什么是同步？什么是异步？两者的差异是什么？&lt;/h4&gt;
&lt;p&gt;同步是执行或调用一个方法时，每次都需要拿到对应的结果才会继续往后执行；异步与同步相反，它会在执行或调用一个方法后就继续往后执行，不会等待获取执行结果。&lt;span&gt;二者的区别就是处理请求发出后，是否需要等待请求结果，再去继续执行其他操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;以下图为例，红色线条为主线程，其他线条为调用的方法，上面的为同步，下面的为异步。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2019059/202005/2019059-20200501234839680-531092492.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​ (图片来源为的刘铁猛的视频—C#语言入门详解)&lt;/p&gt;
&lt;h4 id=&quot;2、阻塞非阻塞是什么意思？和同步异步有关系吗？&quot;&gt;2、阻塞非阻塞是什么意思？和同步异步有关系吗？&lt;/h4&gt;
&lt;p&gt;阻塞的概念通常会伴随着线程。阻塞是指当前执行的线程调用一个方法，在该方法没有返回值之前，当前执行的线程会被挂起，无法继续进行其他操作。非阻塞是指当前执行的线程调用一个方法，当前执行的线程不受该方法的影响，可以继续进行其他操作。&lt;/p&gt;
&lt;p&gt;看完上面的说明，再对照同步异步的说明，这不是一个意思吗？但是它们的侧重点是不同的，&lt;span&gt;同步异步强调的是是否需要等待获取结果，而阻塞非阻塞强调的是是否会影响当前线程的后续操作&lt;/span&gt;。&lt;/p&gt;
&lt;h4 id=&quot;3、各个组合的效果&quot;&gt;3、各个组合的效果&lt;/h4&gt;
&lt;p&gt;同步/异步与阻塞/非阻塞，一共有四种组合方式，知乎上有个例子举得很贴切，我截了张图，原帖地址如下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/26393784&quot; title=&quot;点击查看&quot;&gt;什么是阻塞，非阻塞，同步，异步？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2019059/202005/2019059-20200501234854168-810475474.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;4、异步与多线程有关系吗？&quot;&gt;4、异步与多线程有关系吗？&lt;/h4&gt;
&lt;p&gt;多线程是实现异步常用的一种方式，异步是目的，多线程是其实现方式之一。&lt;/p&gt;
&lt;p&gt;下面我们通过一个使用Task线程实现异步的例子，了解一下异步的执行流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2019059/202005/2019059-20200501234906180-1856274220.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到主方法的执行并没有受到AsyncMethod方法的影响，而是继续往下执行了，实现了异步的效果。&lt;/p&gt;
&lt;h4 id=&quot;5、异步编程与asyncawait&quot;&gt;5、异步编程与async/await&lt;/h4&gt;
&lt;p&gt;异步编程的模式在使用恰当的情况下，会带来不小的性能提升，微软在不同时期一共推出了三种异步编程模式，分别为APM、EAP和TAP，async/await正是基于TAP模式下实现的。&lt;/p&gt;
&lt;h6 id=&quot;51、async是什么？&quot;&gt;5.1、async是什么？&lt;/h6&gt;
&lt;p&gt;&lt;strong&gt;async&lt;/strong&gt; 是上下文关键字，用来标记异步方法，async标记方法的返回值必须是Task、Task、void之一。从C# 7.0开始，任何具有可访问的GetAwaiter方法的类型也是可以标记的。&lt;/p&gt;
&lt;h6 id=&quot;52、await是什么？&quot;&gt;5.2、await是什么？&lt;/h6&gt;
&lt;p&gt;1、 &lt;strong&gt;await&lt;/strong&gt; 用于等待异步方法的结果，await关键字可以用在async方法和Task、Task之前，用于等待异步任务执行结束；&lt;/p&gt;
&lt;p&gt;2、 &lt;strong&gt;await&lt;/strong&gt; 并不是针对于async的方法，而是针对async方法所返回给我们的Task；&lt;/p&gt;
&lt;p&gt;3、 &lt;strong&gt;await&lt;/strong&gt; 不会开启新的线程，直到遇到Async方法或自己创建Task，才会真正的去创建线程&lt;/p&gt;
&lt;h6 id=&quot;53、相关说明&quot;&gt;5.3、相关说明&lt;/h6&gt;
&lt;p&gt;1、异步方法缺少 &lt;strong&gt;await&lt;/strong&gt; 不会导致编译器错误，但是异步方法会作为同步方法执行；&lt;/p&gt;
&lt;p&gt;2、 &lt;strong&gt;await&lt;/strong&gt; 无法等待具有 void 返回类型的异步方法；&lt;/p&gt;
&lt;p&gt;③异步方法中无法声明 in、ref 或 out 参数&lt;/p&gt;
&lt;h6 id=&quot;54、了解await的基本实现&quot;&gt;5.4、了解await的基本实现&lt;/h6&gt;
&lt;p&gt;1、通过resharp可以确认，await是一个TaskAwaiter对象，而它是怎么来的呢？原来Task类在GetAwaiter方法中创建了一个TaskAwaiter对象，并将this传递，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2019059/202005/2019059-20200501234918360-845589487.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、接下来我们再分三个部分看：&lt;/p&gt;
&lt;p&gt;①await如何确认后面的异步方法执行完成了？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TaskAwaiter&lt;/strong&gt;对象存在一个&lt;strong&gt;OnCompleted&lt;/strong&gt;的方法，会等待操作完成时会执行，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2019059/202005/2019059-20200501234928776-1430619025.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;②await是怎么让主线程等待其获取异步方法结果的？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TaskAwaiter&lt;/strong&gt;对象存在一个&lt;strong&gt;GetAwaiter&lt;/strong&gt;的方法，会在操作完成时通知等待的对象(主线程)，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2019059/202005/2019059-20200501234942354-1292169270.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;③await是怎么返回结果的？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TaskAwaiter&lt;/strong&gt;对象存在一个&lt;strong&gt;GetResult&lt;/strong&gt;的方法，会结束等待并返回结果，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2019059/202005/2019059-20200501234953630-112188959.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;结论：Task通过增加一个GetAwatier()函数，同时将自身传递给TaskAwaiter类来实现了await语法糖的支持&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;说明：多线程同步异步的知识点很多，本文只是针对该部分的一个简单小结，若想深究其原理，请查看专业书籍。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;本人知识点有限，若文中有错误的地方请及时指正，方便大家更好的学习和交流。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文参考了多篇优秀的博客内容，感兴趣的朋友可以看下，地址如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;/&lt;em&gt;梦里花落知多少&lt;/em&gt;/，&lt;a href=&quot;https://www.cnblogs.com/anding/p/5301754.html&quot; title=&quot;点击查看&quot;&gt;.NET面试题解析(07)-多线程编程与线程同步&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Edison Zhou，&lt;a href=&quot;https://www.cnblogs.com/edisonchou/p/4848131.html&quot; title=&quot;点击查看&quot;&gt;.NET基础拾遗（5）多线程开发基础&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;腾飞（Jesse)，&lt;a href=&quot;https://www.cnblogs.com/jesse2013/p/async-and-await.html&quot; title=&quot;点击查看&quot;&gt;async &amp;amp; await 的前世今生&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Jonins，&lt;a href=&quot;https://www.cnblogs.com/jonins/p/9558275.html&quot; title=&quot;点击查看&quot;&gt;异步编程&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 01 May 2020 15:53:00 +0000</pubDate>
<dc:creator>Jscroop</dc:creator>
<og:description>线程与同步异步 一、线程 1、什么是线程？什么是进程？两者有什么关系？ 进程（Process）：进程代表了操作系统上运行着的一个应用程序，每个进程都有自己独立的边界，进程与进程之间不能共享资源，一个进</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Jscroop/p/12815466.html</dc:identifier>
</item>
<item>
<title>设计模式——抽象工厂模式 - shanzm</title>
<link>http://www.cnblogs.com/shanzhiming/p/12815420.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shanzhiming/p/12815420.html</guid>
<description>&lt;p&gt;抽象工厂模式（Abstract Factory Pattern）：为创建一组相关或相互依赖的对象提供一个接口，而且无须指定它们的具体类。 产品族(产品系列)：同一个具体工厂创建的不同等级的产品称为同一产品族，或是称为同一产品系列。 产品等级：又称为产品系列，指的是继承与同一个抽象产品类的所有具体产品称之为同一个产品等级&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;265.32478531937&quot;&gt;
&lt;p&gt;目录&lt;/p&gt;
&lt;p&gt;shanzm-2020年5月1日 23:20:41&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;1-模式简介&quot;&gt;1. 模式简介&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;抽象工厂模式（Abstract Factory Pattern）&lt;/strong&gt;：为创建一组相关或相互依赖的对象提供一个接口，而且无须指定它们的具体类。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;产品族(产品系列)&lt;/strong&gt;：&lt;span&gt;同一个具体工厂创建的不同等级的产品称为同一产品族，或是称为同一产品系列。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;注意：同一个产品族的产品是继承于不同的产品抽象类&lt;/p&gt;
&lt;p&gt;在抽象工厂模式中有产品族的概念，而在工厂方法模式中是没有这个概念的，因为工厂方法模式中一个具体工厂只创建一种具体产品。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;产品等级&lt;/strong&gt;：&lt;span&gt;又称为产品系列，指的是继承与同一个抽象产品类的所有具体产品称之为同一个产品等级&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;为了方便理解产品族和产品等级，举一个小栗子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1576687/202005/1576687-20200501232520134-396223213.png&quot; alt=&quot;04抽象工厂模式-产品族和产品系列&quot;/&gt;&lt;/p&gt;
&lt;p&gt;抽象工厂模式主要类：&lt;/p&gt;
&lt;ul readability=&quot;5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;AbstractProductA抽象产品A类（或是接口），派生出所有的具体产品类ConcreteProductA1、ConcreteProductA2 ……&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;AbstractProductB抽象产品B类（或是接口），派生出所有的具体产品类ConcreteProductB1、ConcreteProductB2 ……&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;AbstractFactory 抽象工厂接口，所有的具体工厂类都是实现该接口&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;ConcreteFactory1 具体工厂1，实现了IFactory接口,创建具体的产品对象ConcreteProductA1和ConcreteProductB1&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;ConcreteFactory2 具体工厂2，实现了IFactory接口,创建具体的产品对象ConcreteProductA2和ConcreteProductB2&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;注意： 两个抽象产品类可以有关系，比如：共同继承或实现一个抽象类或接口&lt;/p&gt;
&lt;p&gt;抽象工厂模式的UML：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1576687/202005/1576687-20200501233705139-2139303513.png&quot; alt=&quot;Abstract Factory Pattern UML&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注：原图片来自《设计模式实训教程-第二版》&lt;/p&gt;
&lt;br/&gt;&lt;span&gt;仔细查看UML，可以发现：当系统中只存在一个产品等级时，抽象工厂模式将退化到工厂方法模式。&lt;/span&gt;&lt;br/&gt;&lt;hr/&gt;&lt;h3 id=&quot;2-示例1-使用工厂模式实现对不同数据库的操作&quot;&gt;2. 示例1-使用工厂模式实现对不同数据库的操作&lt;/h3&gt;
&lt;h4 id=&quot;21-背景说明&quot;&gt;2.1 背景说明&lt;/h4&gt;
&lt;p&gt;在实际开发中，有可能会出现更换不同的数据库，或是一个项目就使用多个类型的数据库。&lt;br/&gt;所以为便于更换不同的数据库，我们使用工厂模式，定义不同的具体工厂创建不同数据库的操作类&lt;/p&gt;
&lt;p&gt;示例来源《大话设计模式》，假设某个项目同时具体MSSQL数据库和Oracle数据库，两个数据库只是类型不同，其中的表以及表的字段都是一样的。&lt;/p&gt;
&lt;p&gt;我们需要对两个数据库中的User表进行操作。&lt;/p&gt;
&lt;p&gt;按照工厂模式的设计思路，依次实现以下接口和类：&lt;/p&gt;
&lt;p&gt;抽象产品：&lt;code&gt;IUserService&lt;/code&gt;-声明查询和添加User表数据的方法&lt;br/&gt;具体产品：&lt;code&gt;MSSQLUserService&lt;/code&gt;、&lt;code&gt;OracleUserService&lt;/code&gt;-分别针对MSSQ和Oracle数据库的实现IUserService接口&lt;br/&gt;抽象工厂：&lt;code&gt;IDatabaseFactory&lt;/code&gt;-声明创建IUserService对象的方法&lt;br/&gt;具体工厂：&lt;code&gt;MSSQLFactory&lt;/code&gt;、&lt;code&gt;OracleFactory&lt;/code&gt;-实现IDatabaseFactory接口，分别创建MSSQLUserService对象和OracleUserService对象&lt;/p&gt;
&lt;h4 id=&quot;22-代码实现&quot;&gt;2.2 代码实现&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;①创建User类&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;public class User
{
    public int Id { get; set; }
    public string Name { get; set; }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;②创建产品总接口IUserService和具体产品MSSQLUserService、OracleUserService&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;//抽象产品
public interface IUserService
{
    void Insert(User user);
    User GetUser(int id);
}

//具体产品：模拟对MSSQL数据库中的User表的查询和添加操作
public class MSSQLUserService : IUserService
{
    public void Insert(User user)
    {
        Console.WriteLine($&quot;MSSQL数据库User表中中-添加新的用户,Id:{user.Id },Name{user.Name}&quot;);
    }
    public User GetUser(int id)
    {
        Console.WriteLine($&quot;MSSQL数据库User表中-查询到用户,Id:{id}&quot;);
        return null;
    }
}

//具体产品：模拟对Oracle数据库中的User表的查询和添加操作
public class OracleUserService : IUserService
{
    public void Insert(User user)
    {
        Console.WriteLine($&quot;Oracle数据库User表中-添加新的用户,Id:{user.Id },Name{user.Name}&quot;);
    }
    public User GetUser(int id)
    {
        Console.WriteLine($&quot;Oracle数据库User表中-查询到用户,Id:{id}&quot;);
        return null;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;③创建抽象工厂IDatabaseFactory和具体工厂MSSQLFactory、OracelFactory&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;//抽象工厂
public interface IDatabaseFactory
{
    IUserService CreateUserService();
}

//具体工厂：创建MSSQLUserService对象
public class MSSQLFactory : IDatabaseFactory
{
    public IUserService CreateUserService()
    {
        return new MSSQLUserService();
    }
}

//具体工厂：创建OracleUserService对象
public class OracleFactory : IDatabaseFactory
{
    public IUserService CreateUserService()
    {
        return new OracleUserService();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;④客户端调用&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;static void Main(string[] args)
{
    User user = new User() { Id = 0001, Name = &quot;shanzm&quot; };

    IDatabaseFactory msSQlFactory = new MSSQLFactory();
    IDatabaseFactory oracleFactory = new OracleFactory();

    //若是对MSSQL数据库中的User表操作
    IUserService msUserService = msSQlFactory.CreateUserService();
    msUserService.Insert(user);
    msUserService.GetUser(00001);//print:查询到用户,Id:00001

    //若是对Oracle数据库中User表操作
    IUserService oracleUserService = oracleFactory.CreateUserService();
    oracleUserService.Insert(user);
    oracleUserService.GetUser(00001);//print:查询到用户,Id:00001
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;23-程序类图&quot;&gt;2.3 程序类图&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1576687/202005/1576687-20200501232658733-165183093.png&quot; alt=&quot;shanzm_抽象工厂模式_示例1&quot;/&gt;&lt;/p&gt;
&lt;br/&gt;&lt;hr/&gt;&lt;h3 id=&quot;3-示例2-多数据库且多表操作&quot;&gt;3. 示例2-多数据库且多表操作&lt;/h3&gt;
&lt;h4 id=&quot;31-背景说明&quot;&gt;3.1 背景说明&lt;/h4&gt;
&lt;p&gt;在示例1中，有两个不同的数据库，每个数据库中都有一张User表，我们实现了对每个数据库的User表查询和添加数据&lt;/p&gt;
&lt;p&gt;我们使用了工厂方法模式，即有一个抽象产品接口（&lt;code&gt;IUserService&lt;/code&gt;），有2个具体产品类（&lt;code&gt;MSSQLUserService&lt;/code&gt;和&lt;code&gt;OracleUserService&lt;/code&gt;）实现该接口。&lt;/p&gt;
&lt;p&gt;有一个抽象工厂接口(&lt;code&gt;IDatabaseFactory&lt;/code&gt;)，有两个具体产品工厂类(&lt;code&gt;MSSQLFactory&lt;/code&gt;和&lt;code&gt;OracleFactory&lt;/code&gt;)实现该接口。&lt;/p&gt;
&lt;p&gt;而现在，若是在两个数据库中还有一个部门表Department表，需要对Department表操作。&lt;/p&gt;
&lt;p&gt;则需要按照以下修改和添加代码：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;添加一个抽象产品接口（&lt;code&gt;IDepService&lt;/code&gt;），和实现该接口的有两个具体产品类（&lt;code&gt;MSSQLDepService&lt;/code&gt;和&lt;code&gt;OracleDepService&lt;/code&gt;）。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;在原有的抽象工厂接口和具体工厂类中添加创建&lt;code&gt;MSSQLDepService&lt;/code&gt;对象和&lt;code&gt;OracleDepService&lt;/code&gt;对象的方法。&lt;strong&gt;注意工厂方法是在原有的工厂中进行扩展。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;32-代码实现&quot;&gt;3.2 代码实现&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;①在示例1的基础上，添加一个Department类&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;public class Department
{
    public int Id { get; set; }
    public string Name { get; set; }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;②添加一个新的抽象产品接口（&lt;code&gt;IDepService&lt;/code&gt;），和实现该接口的有两个具体产品（&lt;code&gt;MSSQLDepService&lt;/code&gt;和&lt;code&gt;OracleDepService&lt;/code&gt;）&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;//抽象产品
public interface IDepartmentService
{
    void Insert(Department dep);
    Department GetDepartment(int id);
}

//具体产品：模拟对MSSQL数据库中的Department表的查询和添加操作
public class MSSQLDepService : IDepartmentService
{
    public Department GetDepartment(int id)
    {
        Console.WriteLine($&quot;MSSQL数据库的Department表中-查询到部门,Id:{id}&quot;);
        return null;
    }
    public void Insert(Department dep)
    {
        Console.WriteLine($&quot;MSSQL数据库的Department表中-添加新的部门,Id:{dep.Id }Name:{dep.Name}&quot;);
    }
}

//具体产品：模拟对Oracle数据库中的Department表的查询和添加操作
class OracleDepService : IDepartmentService
{
    public Department GetDepartment(int id)
    {
        Console.WriteLine($&quot;Oracle数据库的Department表中-查询到部门,Id:{id}&quot;);
        return null;
    }
    public void Insert(Department dep)
    {
        Console.WriteLine($&quot;Oracle数据库的Department表中-添加新的部门,Id:{dep.Id }Name:{dep.Name}&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;③在示例1的基础上，在原有的抽象工厂接口和具体工厂类中添加创建&lt;code&gt;MSSQLDepService&lt;/code&gt;对象和&lt;code&gt;OracleDepService&lt;/code&gt;对象的方法&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;public interface IDatabaseFactory
{
    IUserService CreateUserService();
    IDepartmentService CreateDepService();//在接口中添加新的方法
}

public class MSSQLFactory : IDatabaseFactory
{
    public IDepartmentService CreateDepService()
    {
        return new MSSQLDepService();
    }
    public IUserService CreateUserService()
    {
        return new MSSQLUserService();
    }
}

public class OracleFactory : IDatabaseFactory
{
    public IDepartmentService CreateDepService()
    {
        return new OracleDepService();
    }
    public IUserService CreateUserService()
    {
        return new OracleUserService();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;④在客户端调用&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;static void Main(string[] args)
{
    User user = new User() { Id = 0001, Name = &quot;shanzm&quot; };
    Department dep = new Department() { Id = 1000, Name = &quot;Development&quot; };
   
    IDatabaseFactory DatabaseFactory = new MSSQLFactory();

    //对MSSQL数据库中的User表操作
    IUserService UserService = DatabaseFactory.CreateUserService();
    UserService.Insert(user);
    UserService.GetUser(00001);

    //对MSSQL数据库中的Del表操作
    IDepartmentService DepService = DatabaseFactory.CreateDepService();
    DepService.Insert(dep);
    DepService.GetDepartment(1000);
    Console.ReadKey();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1576687/202005/1576687-20200501232811199-1594330520.png&quot; alt=&quot;MSSQL数据库&quot;/&gt;&lt;/p&gt;
&lt;br/&gt;假如需要改换为Oracle数据库，则你只需要将创建具体工厂对象new MSSQLFactory()修改为new OracleFactory(),其他的代码无需修改
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;static void Main(string[] args)
{
    User user = new User() { Id = 0001, Name = &quot;shanzm&quot; };
    Department dep = new Department() { Id = 1000, Name = &quot;Development&quot; };
   
    IDatabaseFactory DatabaseFactory = new MSSQLFactory();

    //对MSSQL数据库中的User表操作
    IUserService UserService = DatabaseFactory.CreateUserService();
    UserService.Insert(user);
    UserService.GetUser(00001);

    //对MSSQL数据库中的Del表操作
    IDepartmentService DepService = DatabaseFactory.CreateDepService();
    DepService.Insert(dep);
    DepService.GetDepartment(1000);
    Console.ReadKey();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1576687/202005/1576687-20200501232742434-1659848949.png&quot; alt=&quot;MSSQL数据库&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;33-程序类图&quot;&gt;3.3 程序类图&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1576687/202005/1576687-20200501232831059-1912251629.png&quot; alt=&quot;shanzm_抽象工厂&quot;/&gt;&lt;/p&gt;
&lt;p&gt;【说明】：&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;MSSQLUserService&lt;/code&gt;和&lt;code&gt;MSSQLDepService&lt;/code&gt;是由同一个具体工厂&lt;code&gt;MSSQLFactory&lt;/code&gt;创建的，即二者属于同一产品族。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;OracleUserService&lt;/code&gt;和&lt;code&gt;OracleDepService&lt;/code&gt;是由同一个具体工厂&lt;code&gt;OracleFactory&lt;/code&gt;创建的，即二者属于同一产品族。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;而我们需要切换数据库的时候（即切换产品族）,只需要修改创建具体工厂对象：&lt;code&gt;MSSQLFactory&lt;/code&gt;对象或&lt;code&gt;OracleFactory&lt;/code&gt;对象。这就是抽象工厂模式的最大优点！&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;br/&gt;&lt;hr/&gt;&lt;h3 id=&quot;4-重构示例2-使用简单工厂改进抽象工厂&quot;&gt;4. 重构示例2-使用简单工厂改进抽象工厂&lt;/h3&gt;
&lt;p&gt;上述示例项目中，假如再添加一个新的表Student，添加对该表的操作类，则先需要定义一个抽象接口&lt;code&gt;IStudentService&lt;/code&gt;接口，派生针对不同数据库操作的两个类：&lt;code&gt;MSSQLStudentService&lt;/code&gt;和&lt;code&gt;OracleStudentService&lt;/code&gt;，这之后再在&lt;code&gt;IDatabaseFactory&lt;/code&gt;接口中添加一个&lt;code&gt;CreateStudentService()&lt;/code&gt;方法，接着在两个具体的工厂类中实现该接口。&lt;/p&gt;
&lt;p&gt;我们可以使用简单工厂模式实现上述的示例2中的项目：&lt;/p&gt;
&lt;p&gt;完整演示Demo代码&lt;a href=&quot;https://github.com/shanzm/DesignPatterns/tree/master/04%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F&quot;&gt;下载&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;①以下接口和类和示例2中一样&lt;/strong&gt;&lt;br/&gt;抽象产品A:&lt;code&gt;IUserService&lt;/code&gt; ，派生出具体产品：&lt;code&gt;MSSQLUserService&lt;/code&gt;和&lt;code&gt;OracleUserService&lt;/code&gt;&lt;br/&gt;抽象产品B:&lt;code&gt;IDepService&lt;/code&gt;，派生出具体产品：&lt;code&gt;MSSQLDepService&lt;/code&gt;和&lt;code&gt;OracleDepService&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;②定义简单工厂类：&lt;/strong&gt;&lt;br/&gt;因为这里有两个抽象产品，所以和之前的一般的简单工厂不同的地方就是要建立两个工厂方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;public class DatabaseFactory
{
    private static readonly string db = &quot;MSSQL&quot;;//若是需要更换数据库则将字符串改&quot;Oracle&quot;

    //针对抽象产品IUserService的工厂方法
    public static IUserService CreateUserService()
    {
        IUserService userService = null;
        switch (db)
        {
            case &quot;MSSQL&quot;:
                userService = new MSSQLUserService();
                break;
            case &quot;Oracle&quot;:
                userService = new OracleUserService();
                break;
        }
        return userService;
    }

    //针对抽象产品IDepService的工厂方法
    public static IDepartmentService CreateDeprService()
    {
        IDepartmentService depService = null;
        switch (db)
        {
            case &quot;MSSQL&quot;:
                depService = new MSSQLDepService();
                break;
            case &quot;Oracle&quot;:
                depService = new OracleDepService();
                break;
        }
        return depService;
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果需要更换数据库，则只需要简单的将 &lt;code&gt;private static readonly string db&lt;/code&gt;该字段赋值改为&lt;code&gt;&quot;Oracle&quot;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;③客户端调用&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;static void Main(string[] args)
{
    User user = new User() { Id = 0001, Name = &quot;shanzm&quot; };
    Department dep = new Department() { Id = 1000, Name = &quot;Development&quot; };

    IUserService userService = DatabaseFactory.CreateUserService();
    userService.Insert(user);

    IDepartmentService depService = DatabaseFactory.CreateDeprService();
    depService.Insert(dep);

    Console.ReadKey();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1576687/202005/1576687-20200501233418384-330550588.png&quot; alt=&quot;04抽象工厂模式-简单工厂&quot;/&gt;&lt;/p&gt;
&lt;p&gt;【说明】&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;在这里使用简单该厂模式对比使用抽象工厂模式，简化了许多的类和接口，所有的修改都可以在工厂类中进行修改添加&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;同样也实现了客户端和创建实例过程的分离&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;④程序类图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1576687/202005/1576687-20200501233058279-1753749099.png&quot; alt=&quot;使用简单工厂改进抽象工厂UML&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对比抽象工厂模式，只是将所有的抽象工厂和具体工厂全部简化为一个工厂类，该工厂类中有两个工厂方法&lt;/p&gt;
&lt;h3 id=&quot;5-重构示例2-反射简单工厂&quot;&gt;5. 重构示例2-反射+简单工厂&lt;/h3&gt;
&lt;p&gt;通过使用反射我们可以免去在工厂方法中使用switch语句，&lt;br/&gt;通过反射获取需要创建实例的对象名，然后创建该类的实例对象（&lt;strong&gt;本质上就是依赖注入&lt;/strong&gt;）&lt;br/&gt;看上去好像并没有变得更加方便，但其实是如有产品族比较多的情况下，switch语句的case语句也相应的变多&lt;br/&gt;所以使用反射，可以省略使用switch还是不错的。&lt;/p&gt;
&lt;p&gt;代码实现，在 &lt;strong&gt;4. 重构示例2-使用简单工厂改进抽象工厂&lt;/strong&gt;的基础上，修改工厂类：&lt;/p&gt;
&lt;p&gt;完整演示Demo代码&lt;a href=&quot;https://github.com/shanzm/DesignPatterns/tree/master/04%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F&quot;&gt;下载&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;public class DatabaseFactory
{
    //具体产品所在的程序集名称
    private static readonly string AssemblyName = &quot;04抽象工厂模式-多数据库连接-反射+简单工厂&quot;;
    private static readonly string db = &quot;MSSQL&quot;;//若是需要更换数据库则将字符串改为&quot;Oracle&quot;

    public static IUserService CreateUserService()
    {
        //具体产品的完全限定名
        //注意因为我们的这个项目中有特殊字符，所以程序集的名字和项目名不一致，查看程序集名和命名空间名可以右键项目属性
        string className = &quot;_04抽象工厂模式_多数据库连接_反射_简单工厂&quot; + &quot;.&quot; + db + &quot;UserService&quot;;
        return (IUserService)Assembly.Load(AssemblyName).CreateInstance(className);
      
    }
    public static IDepartmentService CreateDeprService()
    {
        string className = &quot;_04抽象工厂模式_多数据库连接_反射_简单工厂&quot; + &quot;.&quot; + db + &quot;DepService&quot;;
        return (IDepartmentService)Assembly.Load(AssemblyName).CreateInstance(className);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;6-重构示例2-反射配置文件简单工厂&quot;&gt;6. 重构示例2-反射+配置文件+简单工厂&lt;/h3&gt;
&lt;p&gt;在&lt;strong&gt;5. 重构示例2-反射+简单工厂&lt;/strong&gt;若是需更换数据，还是需要修改&lt;code&gt;private static readonly string db = &quot;MSSQL&quot;&lt;/code&gt;字段&lt;br/&gt;即任然需要修改代码后在重新编译，我们可以将需要修改的字段值放在配置文件中&lt;/p&gt;
&lt;p&gt;完整演示Demo代码&lt;a href=&quot;https://github.com/shanzm/DesignPatterns/tree/master/04%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F&quot;&gt;下载&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;修改&lt;strong&gt;5. 重构示例2-反射+简单工厂&lt;/strong&gt;如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;①首先本项目添加引用&quot;System.Configuration&quot;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;②在配置文件App.Config中添加如下配置&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;configuration&amp;gt;
  &amp;lt;appSettings&amp;gt;
    &amp;lt;add key=&quot;db&quot; value=&quot;MSSQL&quot;/&amp;gt;&amp;lt;!--更换数据则&amp;lt;add key=&quot;db&quot; value=&quot;Oracle&quot;/&amp;gt;--&amp;gt;
  &amp;lt;/appSettings&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;③修改工厂类中的db字段&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;private static readonly string db = ConfigurationManager.AppSettings[&quot;db&quot;];//db字段的值从配置文件中读取
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;【说明】：其实在所有在用到简单工厂的地方，都可以考虑使用反射技术去除去switch或if,解除分支判断带来的耦合&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;7-总结分析&quot;&gt;7. 总结分析&lt;/h3&gt;
&lt;p&gt;整个示例项目，由工厂方法模式--&amp;gt;抽象工厂模式--&amp;gt;简单工厂模式，你可以仔细的查看三个实现方式的程序类图，值得琢磨！&lt;/p&gt;
&lt;h4 id=&quot;71-优点&quot;&gt;7.1 优点&lt;/h4&gt;
&lt;p&gt;从UML类图中就可以发现：&lt;/p&gt;
&lt;ol readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;便于交换产品系列，每一个具体的工厂对象都只是在客户端中初始化时候实现一次，所以改变一个具体的工厂对象是十分简单的，所以更换一个产品序列也就变得简单了。&lt;/p&gt;
&lt;p&gt;简单的说，就是因为具体产品都是由具体的工厂创建的，所以在更换产品族的时候只需要简单的修改具体工厂对象即可&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;创建具体产品对象的过程和客户端分离（可以从UML中明显看出），客户端通过操作抽象产品接口实现操作具体产品实例，具体产品的类名不会出现在客户端中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;72-缺点&quot;&gt;7.2 缺点&lt;/h4&gt;
&lt;ol start=&quot;0&quot; readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;添加新的产品族是非常简单的，首先在相应的产品等级结构中添加新的具体产品，然后添加一个具体工厂即可。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;添加新的产品等级是非常麻烦的，首先要添加抽象产品接口，接着派生所有的具体产品，还要在抽象工厂中添加方法，以及所有的具体工厂中实现该方法。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;对比以上就明白：&lt;br/&gt;&lt;strong&gt;抽象工厂模式的扩展有一定的“开闭原则”倾斜性&lt;/strong&gt;：&lt;br/&gt;当增加一个新的产品族时只需增加一个新的具体工厂，不需要修改原代码，满足开闭原则。&lt;br/&gt;当增加一个新的产品等级时，则所有的工厂类都需要进行修改，不满足开闭原则。&lt;/p&gt;
&lt;h4 id=&quot;73-适应场合&quot;&gt;7.3 适应场合&lt;/h4&gt;
&lt;p&gt;系统中有多个产品族，但每次只使用其中的某一族产品。切换产品族只需要修改一下具体工厂对象即可。&lt;/p&gt;
&lt;p&gt;比如本文示例中，针对不同数据库操作我们可以实现不同的产品族，切换数据库只需要简单的修改具体工厂对象。&lt;/p&gt;
&lt;br/&gt;&lt;hr/&gt;&lt;h3 id=&quot;8-参考及源码&quot;&gt;8. 参考及源码&lt;/h3&gt;
&lt;/div&gt;</description>
<pubDate>Fri, 01 May 2020 15:38:00 +0000</pubDate>
<dc:creator>shanzm</dc:creator>
<og:description>抽象工厂模式（Abstract Factory Pattern）：为创建一组相关或相互依赖的对象提供一个接口，而且无须指定它们的具体类。 产品族(产品系列)：同一个具体工厂创建的不同等级的产品称为同一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/shanzhiming/p/12815420.html</dc:identifier>
</item>
<item>
<title>Docker虚拟化管理：30分钟教你学会用Docker - 夜月归途</title>
<link>http://www.cnblogs.com/guitu18/p/12815168.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/guitu18/p/12815168.html</guid>
<description>&lt;p&gt;关于Docker的官方介绍网上太多了我就不贴了，就实际体验来说&lt;strong&gt;Docker可以极大的简化环境搭建及服务部署的操作流程，大大降低部署的时间成本，解放你的双手&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;本文不会深入讲解Docker底层架构及运行原理，也不会有一堆架构图贴在这里。该篇旨在让你以最快的速度学会使用Docker，关于Docker的架构及其底层的一些知识，你可以在学会Docker的基本使用之后再去了解。开门见山讲架构聊底层有点容易让人犯迷糊，但在使用Docker之前你至少应该了解他的三大核心组件：仓库、镜像和容器，以及他们之前的关系。本文将通过一个MySQL示例带你了解并使用Docker，待你对Docker有一个基本了解后你再回头去看他的体系架构会容易理解。&lt;/p&gt;
&lt;h2 id=&quot;三大核心组件&quot;&gt;三大核心组件&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;仓库&lt;/strong&gt;：仓库是集中存储镜像的地方，我们本地安装Docker之后，需要从仓库中拉取镜像。可以类比于Maven，有公有仓库和私有仓库之分。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;镜像&lt;/strong&gt;：是一个Linux的文件系统，它里面存放着可以再Linux内核中运行的程序及其数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;容器&lt;/strong&gt;：是镜像创建的运行实例，可以把它理解为一个精简版的Linux系统，里面运行着镜像里的程序。&lt;/p&gt;
&lt;p&gt;为了更好的让你理解这三者的关系，我打一个不恰当但很形象的比方，&lt;strong&gt;镜像就相当于你weixin.exe文件，容器相当于你安装好的微信程序，微信程序（容器）需要你的weixin.exe文件（镜像）来安装（创建），那么仓库就相当于应用商店了，你可以从商店下载你要的.exe文件（镜像）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;微信程序安装完成后你可以选择运行或者关闭，Docker容器一样可以运行和停止，微信程序你可以从系统卸载，Docker容器你同样可以选择删除。&lt;/p&gt;
&lt;p&gt;但有一点不同的地方是，weixin.exe文件安装完成你就可以删除了，它和你的微信程序并没有关系，删掉安装文件不影响你微信程序的运行。但是镜像不同，如果有容器正在使用这个镜像，那么这个镜像是不能删除的（删除时会报Error不让你删）。&lt;/p&gt;
&lt;p&gt;首发地址：&lt;a href=&quot;https://www.guitu18.com/post/2020/01/20/66.html&quot;&gt;https://www.guitu18.com/post/2020/01/20/66.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;安装docker&quot;&gt;安装Docker&lt;/h2&gt;
&lt;p&gt;CentOS安装Docker要求：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;必须是64位操作系统&lt;/li&gt;
&lt;li&gt;内核版本在3.8以上&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;你可以通过&lt;code&gt;uname -r&lt;/code&gt;查看你的系统内核：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;[root@localhost ~]# uname -r
3.10.0-1062.18.1.el7.x86_64
[root@localhost ~]# 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;yum方式安装：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-she&quot;&gt;yum install docker -y
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装完成你可以通过&lt;code&gt;docker version&lt;/code&gt;查看你的docker版本信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;[root@localhost ~]# docker version
Client:
 Version:         1.13.1
 API version:     1.26
 Package version: docker-1.13.1-109.gitcccb291.el7.centos.x86_64
 Go version:      go1.10.3
 Git commit:      cccb291/1.13.1
 Built:           Tue Mar  3 17:21:24 2020
 OS/Arch:         linux/amd64

Server:
 Version:         1.13.1
 API version:     1.26 (minimum version 1.12)
 Package version: docker-1.13.1-109.gitcccb291.el7.centos.x86_64
 Go version:      go1.10.3
 Git commit:      cccb291/1.13.1
 Built:           Tue Mar  3 17:21:24 2020
 OS/Arch:         linux/amd64
 Experimental:    false
 [root@localhost ~]# 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看到如上的信息说明你的Docker安装成功，你可以用 &lt;code&gt;docker info&lt;/code&gt; 命令查看更详细的信息。&lt;/p&gt;
&lt;h2 id=&quot;配置镜像加速&quot;&gt;配置镜像加速&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;为了更愉快的使用Docker你可能还需要配置镜像加速&lt;/strong&gt;，可以类比于Maven的私服，使用国内的镜像仓库能让你更快的拉取镜像。&lt;/p&gt;
&lt;p&gt;执行&lt;code&gt;vim /etc/docker/daemon.json&lt;/code&gt;，修改为如下配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;{
    &quot;registry-mirrors&quot;:[
        &quot;https://reg-mirror.qiniu.com/&quot;,
        &quot;https://hub-mirror.c.163.com/&quot;
    ]
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重新加载配置及重启Docker服务：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-she&quot;&gt;systemctl daemon-reload
systemctl restart docker
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行&lt;code&gt;docker info&lt;/code&gt;你可以看到镜像仓库配置已经生效了。&lt;/p&gt;
&lt;h2 id=&quot;拉取镜像&quot;&gt;拉取镜像&lt;/h2&gt;
&lt;p&gt;Docker安装和配置都搞定了，现在你要从苍鹭下载镜像了，这里以 MySQL 5.7 为例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# 5.7为版本号，你也可以安装其他版本
docker pull mysql:5.7
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img.guitu18.com/markdown/e31b97e1591b8123d92f6649da532c27.png&quot; alt=&quot;拉取MySQL5.7镜像&quot;/&gt;&lt;/p&gt;
&lt;p&gt;拉取成功后通过&lt;code&gt;docker images&lt;/code&gt;命令查看本地镜像：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;[root@localhost ~]# docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
docker.io/mysql     5.7                 f965319e89de        3 hours ago         448 MB
[root@localhost ~]# 
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;创建容器&quot;&gt;创建容器&lt;/h2&gt;
&lt;p&gt;有了镜像，你需要用它创建一个容器才能运行，创建并运行MySQL容器：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;docker run -d -p 3306:3306 --name mysql -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;命令参数说明（后面会有更加详细的说明）：&lt;br/&gt;-d：后台运行&lt;br/&gt;-p：端口映射，前面的为宿主机端口，后面的为容器端口，这里我将宿主机的3306端口指向了容器的3306端口&lt;br/&gt;--name：为启动的容器命名&lt;br/&gt;-e：指定容器内的环境变量，这里指配置MySQL的Root用户密码为：123456&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;执行成功后会返回容器ID，查看已创建的容器：&lt;code&gt;docker ps -a&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;[root@localhost ~]# docker run -d -p 3306:3306 --name mysql -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7
8e1cd060075db23c61cb31cecb3a3321df92cf56ea7086476cc21e8709382d19
[root@localhost ~]# docker ps -a
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                               NAMES
8e1cd060075d        mysql:5.7           &quot;docker-entrypoint...&quot;   3 seconds ago       Up 1 second         0.0.0.0:3306-&amp;gt;3306/tcp, 33060/tcp   mysql
[root@localhost ~]# 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到刚才创建的MySQL容器已经在运行了，现在你可以通过&lt;code&gt;${IP}:3306&lt;/code&gt;连接MySQL数据库了（记得放行端口或者关闭防火墙）。&lt;/p&gt;
&lt;h2 id=&quot;挂载目录&quot;&gt;挂载目录&lt;/h2&gt;
&lt;p&gt;通过上面的步骤，你已经通过Docker运行起你的第一个容器MySQL了，而且你也能通过宿主机的端口连接到容器中的MySQL。但这样做还不是很安全，关于这个我们要先简单了解一下容器和宿主机之间的关系。&lt;/p&gt;
&lt;p&gt;容器内和宿主机的文件系统是独立的（虽然整个容器也是以文件的形式存放在宿主机的某个目录上的），包括他们之间的网络，也是独立的。刚才运行的MySQL容器有一个 &lt;code&gt;-p 3306:3306&lt;/code&gt; 的参数，这个参数就是映射宿主机和容器之间的端口的，你也可以配置成比如 &lt;code&gt;-p 1234:3306&lt;/code&gt; ，这样你通过访问宿主机的1234端口就能访问到容器的3306端口。&lt;/p&gt;
&lt;p&gt;那么再回到文件系统，容器本身也是一个精简版的Linux系统，只不过他运行在宿主机上依赖于宿主机的硬件。容器内部也是有着一套独立的文件系统的，且&lt;strong&gt;随着容器的删除，所有存在于容器内的所有文件都将被清除&lt;/strong&gt;。刚才我们创建的那个MySQL容器，只要我们删除容器，数据库里的所有数据都将清除，这显然不是我们想看到的。&lt;/p&gt;
&lt;p&gt;Docker的&lt;code&gt;run&lt;/code&gt;命令提供了一个&lt;code&gt;-v&lt;/code&gt;的参数，允许我们容器内部目录挂载为宿主机的本地目录，这样容器内的程序在操作这个目录时，其实操作的是宿主机的目录。那么&lt;strong&gt;我们可以把程序运行的关键数据挂载到宿主机上的目录，比如MySQL的数据库文件，程序运行的日志文件等等&lt;/strong&gt;。这样一来当我们在删除容器时，因为这些目录是存在于宿主机的，所以不会随着容器一起删除，从而实现了容器数据的持久化。&lt;/p&gt;
&lt;p&gt;还是以刚才的MySQL容器为例，我们先删掉刚才的容器：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# mysql为容器名称，也可以是容器ID，通过 docker ps -a 查看容器信息
docker stop mysql
docker rm mysql
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着用下面的命令创建并运行MySQL容器，增加了一个 &lt;code&gt;-v&lt;/code&gt; 参数：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# 在宿主机创建挂载目录
mkdir -p /usr/local/mysql/conf
mkdir -p /usr/local/mysql/logs
mkdir -p /usr/local/mysql/data
# 创建并运行容器
docker run -p 3306:3306 --name mysql \
-v /usr/local/mysql/conf:/etc/mysql \
-v /usr/local/mysql/logs:/var/log/mysql \
-v /usr/local/mysql/data:/var/lib/mysql \
-e MYSQL_ROOT_PASSWORD=123456 \
-d mysql:5.7
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;17&quot;&gt;
&lt;p&gt;&lt;code&gt;-v /usr/local/mysql/data:/var/lib/mysql&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;表示将宿主机的 &lt;code&gt;/usr/local/mysql/data&lt;/code&gt; 目录挂载到容器内的 &lt;code&gt;/var/lib/mysql&lt;/code&gt; 目录，那么容器内的MySQL程序操作的数据实际上是写入了宿主机的 &lt;code&gt;/usr/local/mysql/data&lt;/code&gt; 目录了，其他两项同理。&lt;/p&gt;
&lt;p&gt;这里挂载的三个目录分别为数据库运行的配置、日志和数据，也是MySQL程序最重要的数据，即便这个容器删除了，只要这些数据还在，我们就能通过重新创建容器恢复全部数据。&lt;/p&gt;
&lt;p&gt;而且这样挂载以后，我们无需进入容器，直接在宿主机操作这几个目录里的文件就能同步体现到容器内部，比如修改一些配置，导出数据之类的，不用进入容器直接在宿主机操作即可。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;用以上命令运行容器之后，在你的宿主机的&lt;code&gt;/usr/local/mysql/data&lt;/code&gt; 目录就能看到MySQL运行生成的数据库文件了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.guitu18.com/markdown/a3b47b18eb179aaa72a72008ce51fd67.png&quot; alt=&quot;容器内MySQL运行后生成的数据文件，已经挂载到宿主机上了&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Docker的数据卷挂载（我习惯称之为挂载目录）功能非常重要，我们运行的任何程序都有需要持久化的数据，如果这些数据直接放在容器内部是非常不安全的。而且&lt;strong&gt;挂载目录还可以实现直接在宿主机操作容器内的数据，也能做到容器间的数据共享&lt;/strong&gt;，用Docker一定要养成挂载重要数据到宿主机的习惯。&lt;/p&gt;
&lt;h2 id=&quot;错误排查&quot;&gt;错误排查&lt;/h2&gt;
&lt;p&gt;上面这个命令是直接后台运行容器的，如果需要调试可以把 &lt;code&gt;-d&lt;/code&gt; 参数修改为 &lt;code&gt;-it&lt;/code&gt; 参数以在前台运行，在某些情况下你很可能会遇到类似于下面这些错误（可以通过前台运行查看到）：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;chown: changing ownership of '/var/lib/mysql/': Permission denied
# 或者
mysqld: Can't create/write to file '/var/lib/mysql/is_writable' (Errcode: 13 - Permission denied)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果出现上述问题，那么你需要关闭&lt;code&gt;SELINUX&lt;/code&gt;，方法如下：&lt;/p&gt;
&lt;ol readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;临时关闭：&lt;code&gt;setenforce 0&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;永久关闭：&lt;code&gt;vim /etc/selinux/config&lt;/code&gt;，修改 &lt;code&gt;SELINUX&lt;/code&gt; 的值为 &lt;code&gt;disabled&lt;/code&gt; 然后重启机器即可，看图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.guitu18.com/markdown/7ccda45b64355c417ccc9133f4504c4d.png&quot; alt=&quot;修改SELINUX配置&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;再次运行容器就能看到成功提示了。&lt;/p&gt;
&lt;h2 id=&quot;常用命令&quot;&gt;常用命令&lt;/h2&gt;
&lt;p&gt;通过上面的示例基本已经知道了Docker是怎样工作的，下面是一些基本命令，包括最常用的目录挂载功能等命令说明：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;docker version|info
# 显示Docker信息，常用于查看Docker版本或检测Docker是否正确安装。

docker images
# 列出机器上的镜像(images)及信息：REPOSITORY、TAG、IMAGE ID、CREATED、SIZE。
# IMAGE ID列其实是缩写，要显示完整则带上--no-trunc选项。
# -a 列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层）
# -no-trunc 显示完整的镜像信息
# -q 静默模式，只显示镜像ID

docker search tomcat
# 在docker index中搜索image，搜索的范围是官方镜像和所有个人公共镜像。NAME列的 / 后面是仓库的名字。

docker pull tomcat
# 从docker registry server 中下拉image或repository。
# 语法：docker pull [OPTIONS] NAME[:TAG|@DIGEST]
# -a 拉取所有 tagged 镜像
# --disable-content-trust 忽略镜像的校验,默认开启
# 上面的命令没有指定参数，在docker v1.2版本及以前，会下载官方镜像的tomcat仓库里的所有镜像
# 而从v.13开始只会下载tag为latest的镜像，也可以明确指定具体的镜像
# 如：docker pull tomcat:8，后面的8为tomcat版本tag。

docker run -d --name tomcat -p 8081:8080 tomcat:8
# 启动容器，语法为：docker run [OPTIONS] IMAGE [COMMAND] [ARG...]
# -d 后台运行容器，并返回容器ID，不使用-d我们会看到tomcat启动日志，此时Ctrl+C容器会停止运行。
# -e 指定容器内的环境变量
# -name 指定容器的名称，如果不指定docker会帮我们取一个名字。
# -p 端口映射，宿主机端口:容器端口，上面我们就将宿主机的8081映射到容器的8080端口
#       此时我们访问宿主机的ip：8081就能访问容器内的tomcat了。
# -i 以交互模式运行容器，通常与 -t 同时使用。
# -t 为容器重新分配一个伪输入终端，通常与 -i 同时使用
# -v 目录挂载，本地目录:容器目录

docker ps
# 查看容器的信息，默认显示当前正在运行中的容器
# -a 查看所有容器
# -l 显示最新启动的一个容器（包括已停止的）

docker start|stop|restart CONTAINER_ID
# 启动/停止/重启容器，需要用到容器ID，可以使用docker ps -a 查看所有容器的ID。

docker attach CONTAINER_ID|NAME
# 进入容器，后面跟容器ID或者NANE，可以使用docker ps -a 查看所有容器的ID。
# 可以认为这是一个过时的命令，更多的docker用户会考虑使用docker exec来实现相同的功能
# 但是出于docker官方并没有删除这个命令，我们还是有必要学习一下的。
# 进入容器后输入exit命令可以退出，同时容器停止运行，如若想退出但不停止容器，可以用快捷键Ctrl+P+Q退出。

docker exec -i -t CONTAINER_ID|NAME /bin/bash
# 进入容器，推荐使用这种方式。
# 语法：docker exec [OPTIONS] CONTAINER COMMAND [ARG...]
# -i 以交互模式运行容器，通常与 -t 同时使用。
# -t 为容器重新分配一个伪输入终端，通常与 -i 同时使用
# 示例：docker exec -it mycentos /bin/sh /root/start.sh
# 上面这条命令表示在容器 mycentos 中以交互模式执行容器内 /root/start.sh 脚本

docker rm CONTAINER_ID|NAME
# 删除一个或多少容器，如：docker rm $(docker ps -a -q)，为删除所有停止的容器
# -l 移除容器间的网络连接，而非容器本身
# -v 删除与容器关联的卷
# -f 通过SIGKILL信号强制删除一个运行中的容器

docker rmi CONTAINER_ID|NAME
# 删除本地一个或多少镜像
# -f 强制删除；
# --no-prune 不移除该镜像的过程镜像，默认移除；

docker build
# 使用 Dockerfile 创建镜像，语法：docker build [OPTIONS] PATH | URL | -
# -f 指定要使用的Dockerfile路径
#  -t,--tag 指定镜像的名字及标签：name:tag或者name，可以在一次构建中为一个镜像设置多个标签
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;dockerfile&quot;&gt;Dockerfile&lt;/h2&gt;
&lt;p&gt;Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。&lt;/p&gt;
&lt;p&gt;初学者一开始可不必关注Dockerfile，待你熟悉Docker的整个体系结构及其运行方式后，再回头看这个就会一目了然了。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dockerfile&quot;&gt;FROM
# 指定基础镜像，必须为第一个命令
    FROM &amp;lt;image&amp;gt;
    FROM &amp;lt;image&amp;gt;:&amp;lt;tag&amp;gt;
    FROM &amp;lt;image&amp;gt;@&amp;lt;digest&amp;gt;
# 示例
    FROM docker.io/centos:latest
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dockerfile&quot;&gt;MAINTAINER
# 维护者信息
    MAINTAINER &amp;lt;name&amp;gt;
# 示例
    MAINTAINER guitu &quot;xianjian-mail@qq.com&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dockerfile&quot;&gt;RUN
# 用于在镜像容器中执行命令，其有以下两种命令执行方式
#shell执行
    RUN &amp;lt;command&amp;gt;
#exec执行
    RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]
#示例
    RUN apk update
    RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]
    RUN [&quot;/etc/execfile&quot;, &quot;arg1&quot;, &quot;arg1&quot;]
# RUN指令创建的中间镜像会被缓存，并会在下次构建中使用。
# 如果不想使用这些缓存镜像，可以在构建时指定--no-cache参数，如：docker build --no-cache
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dockerfile&quot;&gt;ADD 
# 将当前目录下的文件复制到容器中，tar类型文件会自动解压(网络压缩资源不会被解压)，可以访问网络资源，类似wget
    ADD &amp;lt;src&amp;gt;... &amp;lt;dest&amp;gt;
    ADD [&quot;&amp;lt;src&amp;gt;&quot;,... &quot;&amp;lt;dest&amp;gt;&quot;]
    # 第二中形式用于支持包含空格的路径
# 示例
    ADD hom* /mydir/          # 添加所有以&quot;hom&quot;开头的文件
    ADD hom?.txt /mydir/      # ? 替代一个单字符,例如：&quot;home.txt&quot;
    ADD test relativeDir/     # 添加 &quot;test&quot; 到 `WORKDIR`/relativeDir/
    ADD test /absoluteDir/    # 添加 &quot;test&quot; 到 /absoluteDir/
# &amp;lt;src&amp;gt;可以是Dockerfile所在目录的一个相对路径，也可以是一个URL，还可以是一个tar文件（会自动解压为目录）
# 如果文件或目录不与Dockerfile在同一目录会提示 no such file or directory
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dockerfile&quot;&gt;COPY
# 功能类似ADD，但是是不会自动解压文件，也不能访问网络资源
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dockerfile&quot;&gt;CMD
# 构建容器后调用，也就是在容器启动时才进行调用。
    CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] (执行可执行文件，优先)
    CMD [&quot;param1&quot;,&quot;param2&quot;] (设置了ENTRYPOINT，则直接调用ENTRYPOINT添加参数)
    CMD command param1 param2 (执行shell内部命令)
# 示例
    CMD echo &quot;This is a test.&quot; | wc -
    CMD [&quot;/usr/bin/wc&quot;,&quot;--help&quot;]
# CMD不同于RUN，CMD用于指定在容器启动时所要执行的命令，而RUN用于指定镜像构建时所要执行的命令。
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dockerfile&quot;&gt;ENTRYPOINT
# 配置容器，使其可执行化。配合CMD可省去&quot;application&quot;，只使用参数。
    ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;] (可执行文件, 优先)
    ENTRYPOINT command param1 param2 (shell内部命令)
#示例
    FROM ubuntu
    ENTRYPOINT [&quot;top&quot;, &quot;-b&quot;]
    CMD [&quot;-c&quot;]
# ENTRYPOINT与CMD非常类似，不同的是通过docker run执行的命令不会覆盖ENTRYPOINT，而docker run命令中指定的任何参数，都会被当做参数再次传递给ENTRYPOINT。
# Dockerfile中只允许有一个ENTRYPOINT命令，多指定时会覆盖前面的设置，而只执行最后的ENTRYPOINT指令。
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dockerfile&quot;&gt;LABEL
# 用于为镜像添加元数据
    LABEL &amp;lt;key&amp;gt;=&amp;lt;value&amp;gt; &amp;lt;key&amp;gt;=&amp;lt;value&amp;gt; &amp;lt;key&amp;gt;=&amp;lt;value&amp;gt; ...
# 示例
    LABEL version=&quot;1.0&quot; description=&quot;这是一个Web服务器&quot; by=&quot;IT笔录&quot;
# 使用LABEL指定元数据时，一条LABEL指定可以指定一或多条元数据，指定多条元数据时不同元数据之间通过空格分隔。
# 推荐将所有的元数据通过一条LABEL指令指定，以免生成过多的中间镜像。
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dockerfile&quot;&gt;ENV
# 设置环境变量
    ENV &amp;lt;key&amp;gt; &amp;lt;value&amp;gt;  
    # &amp;lt;key&amp;gt;之后的所有内容均会被视为其&amp;lt;value&amp;gt;的组成部分，因此，一次只能设置一个变量
    ENV &amp;lt;key&amp;gt;=&amp;lt;value&amp;gt; ...  
    # 可以设置多个变量，每个变量为一个&quot;&amp;lt;key&amp;gt;=&amp;lt;value&amp;gt;&quot;的键值对
    # 如果&amp;lt;key&amp;gt;中包含空格，可以使用\来进行转义，也可以通过&quot;&quot;来进行标示；另外，反斜线也可以用于续行
# 示例
    ENV JAVA_HOME /docker/jdk
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dockerfile&quot;&gt;VOLUME
# 用于指定持久化目录
    VOLUME [&quot;/path/to/dir&quot;]
# 示例
    VOLUME [&quot;/data&quot;]
    VOLUME [&quot;/var/www&quot;, &quot;/var/log/apache2&quot;, &quot;/etc/apache2&quot;]
# 一个卷可以存在于一个或多个容器的指定目录，该目录可以绕过联合文件系统，并具有以下功能：
    # 卷可以容器间共享和重用
    # 容器并不一定要和其它容器共享卷
    # 修改卷后会立即生效
    # 对卷的修改不会对镜像产生影响
    # 卷会一直存在，直到没有任何容器在使用它
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dockerfile&quot;&gt;WORKDIR
# 工作目录，类似于cd命令
    WORKDIR /path/to/workdir
# 示例
    WORKDIR /a  (这时工作目录为/a)
    WORKDIR b  (这时工作目录为/a/b)
    WORKDIR c  (这时工作目录为/a/b/c)
# 通过WORKDIR设置工作目录后，Dockerfile中其后的命令RUN、CMD、ENTRYPOINT、ADD、COPY等命令都会在该目录下执行。
# 在使用docker run运行容器时，可以通过-w参数覆盖构建时所设置的工作目录。
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dockerfile&quot;&gt;USER
# 指定运行容器时的用户名或 UID，后续的 RUN 也会使用指定用户。
# 使用USER指定用户时，可以使用用户名、UID或GID，或是两者的组合。
# 当服务不需要管理员权限时，可以通过该命令指定运行用户。并且可以在之前创建所需要的用户
　　USER user
　　USER user:group
　　USER uid
　　USER uid:gid
　　USER user:gid
　　USER uid:group
# 示例
　　USER www
# 使用USER指定用户后，Dockerfile中其后的命令RUN、CMD、ENTRYPOINT都将使用该用户。
# 镜像构建完成后，通过docker run运行容器时，可以通过-u参数来覆盖所指定的用户。
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dockerfile&quot;&gt;ARG
# 用于指定传递给构建运行时的变量
    ARG &amp;lt;name&amp;gt;=[&amp;lt;default value&amp;gt;]
# 示例
    ARG site
    ARG build_user=www
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dockerfile&quot;&gt;ONBUILD
# 用于设置镜像触发器
　　ONBUILD [INSTRUCTION]
# 示例
　　ONBUILD ADD . /app/src
　　ONBUILD RUN /usr/local/bin/python-build --dir /app/src
# 当所构建的镜像被用做其它镜像的基础镜像，该镜像中的触发器将会被钥触发
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;构建镜像&quot;&gt;构建镜像&lt;/h2&gt;
&lt;p&gt;了解了上面的命令之后，我们可以尝试着创建我的第一个自制镜像了，以下是我的Dockerfile示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dockerfile&quot;&gt;#使用的基础镜像
FROM docker.io/centos:latest
#作者信息
MAINTAINER guitu &quot;xianjian-mail@qq.com&quot;
#安装SVN
RUN yum install -y subversion
#添加JAVA环境，下方的文件请换成你Dockerfile目录下的文件，压缩包在构建镜像时会自动解压
ADD jdk-8u231-linux-x64.tar.gz /docker/
ADD apache-tomcat-8.0.53.tar.gz /docker/
#添加环境变量
ENV JAVA_HOME /docker/jdk1.8.0_231
ENV TOMCAT_HOME /docker/apache-tomcat-8.0.53
ENV PATH $PATH:$JAVA_HOME/bin:$TOMCAT_HOME/bin
#指定工作目录
WORKDIR /docker/apache-tomcat-8.0.53
#暴露8080端口
EXPOSE 8080
#启动时运行tomcat
CMD [&quot;bin/startup.sh &amp;amp;&amp;amp; tail -f logs/catalina.out&quot;]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过Dockerfile创建镜像：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;docker build -t mytomcat8:v0.1 .
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过Dockerfile文件构建镜像完成。&lt;/p&gt;
</description>
<pubDate>Fri, 01 May 2020 14:32:00 +0000</pubDate>
<dc:creator>夜月归途</dc:creator>
<og:description>关于Docker的官方介绍网上太多了我就不贴了，就实际体验来说 Docker可以极大的简化环境搭建及服务部署的操作流程，大大降低部署的时间成本，解放你的双手 。 本文不会深入讲解Docker底层架构及</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/guitu18/p/12815168.html</dc:identifier>
</item>
<item>
<title> java 的  四 个 基  本 特  性 ——封装 继承 多态 抽象 - IT女一枚</title>
<link>http://www.cnblogs.com/xiao666/p/12815077.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiao666/p/12815077.html</guid>
<description>&lt;h6 id=&quot;&quot;/&gt;
&lt;p&gt;赶上明天就还是五一c小长假了，准备在这几天写几篇原创文章，供大家一起学习。&lt;/p&gt;
&lt;p&gt;首先今天就来好好地唠一唠，到底java的那几个特性都是什么呢？到底怎么用呢？相信一定有一些小白对此会有些懊恼，没关系的，谁还不是从那个时候过来的呢！接下来我来一步一步的由潜到深的谈一谈我的看法，下面是我要说的内容&lt;/p&gt;
&lt;h3 id=&quot;1总体概括&quot;&gt;1.总体概括&lt;/h3&gt;
&lt;h3 id=&quot;2概念的理解&quot;&gt;2.概念的理解&lt;/h3&gt;
&lt;h3 id=&quot;3代码示例并且分析&quot;&gt;3.代码示例并且分析&lt;/h3&gt;
&lt;h3 id=&quot;4个人心得总结&quot;&gt;4.个人心得总结&lt;/h3&gt;
&lt;h3 id=&quot;1总体概括-2&quot;&gt;1.总体概括&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;sequenceDiagram
封装-&amp;gt;&amp;gt;继承: java的四个基本特性
多态-&amp;gt;&amp;gt;抽象: java的四个基本特性
&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h3 id=&quot;2概念的理解-2&quot;&gt;2.概念的理解&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;[1] 封装：&lt;/li&gt;
&lt;/ul&gt;&lt;h6 id=&quot;--在面向对象程式设计方法中，封装（英语：encapsulation）是指一种将抽象性函式接口的实现细节部份包装、隐藏起来的方法。&quot;&gt;- 在面向对象程式设计方法中，封装（英语：Encapsulation）是指一种将抽象性函式接口的实现细节部份包装、隐藏起来的方法。&lt;/h6&gt;
&lt;h6 id=&quot;封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。&quot;&gt;封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。&lt;/h6&gt;
&lt;h6 id=&quot;要访问该类的代码和数据，必须通过严格的接口控制。&quot;&gt;要访问该类的代码和数据，必须通过严格的接口控制。&lt;/h6&gt;
&lt;h6 id=&quot;封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。&quot;&gt;封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。&lt;/h6&gt;
&lt;h6 id=&quot;适当的封装可以让程式码更容易理解与维护，也加强了代码的安全性。&quot;&gt;适当的封装可以让程式码更容易理解与维护，也加强了代码的安全性。&lt;/h6&gt;
&lt;pre&gt;
&lt;code&gt;通俗一点的可以这么理解，其实生活中有很多例子的，我来打几个比方，

例如：我们都使用果QQ这个聊天软件的，那么咱们要是想要使用它的话就必须要先注册

，等注册好的时候下次我们在直接输入我们自己设定的密码就可以了，不需要进行其他的操作

这个过程其实就是把QQ里面的数据给封装起来了，防止用户随

意更改，只有程序员才可以，这样他便可以保护程序的安全性

也就是说用户不需要直到QQ他是怎么执行的，内部是怎么实现的，对用户进行隐藏起来了
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;    还有一种解释也可以说明：比如说个人计算机有很多组件——CPU 内存  磁盘  风扇  等等... 
    
    我们不需要直到他的个个组件之间是怎么联系的，只要知道他们的个个功能是如何实现的就可以了
    
    生活中的例子其实有很多很多 我就不一一说了。(要是还不明白可以私信或者评论区留言）
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;[2] 继承&lt;/li&gt;
&lt;li&gt;继承”(Inheritance)，&lt;/li&gt;
&lt;/ul&gt;&lt;h6 id=&quot;继承是指一个对度象直接使用另一对象的属性和方法。事实上，我们遇到的很多实体都有继承的含义。例如，问若把汽车看成一个实体，它可以分成多个子实答体，如：卡车、公共汽车等。这些版子实体都具有汽车的特性，权因此，汽车是它们的父亲，而这些子实体则是汽车的孩子但是孩子也会有自己新产生的特征。子类是父类的特殊化，也就是子类的实例对象一定是父类的实例-，但是反过来不一定成立比如说一个圆他一定是几何图形，但反过来几何图形他不一定就是圆呀！还会有很多的呀&quot;&gt;继承是指一个对度象直接使用另一对象的属性和方法。事实上，我们遇到的很多实体都有继承的含义。例如，问若把汽车看成一个实体，它可以分成多个子实答体，如：卡车、公共汽车等。这些版子实体都具有汽车的特性，权因此，汽车是它们的&quot;父亲&quot;，而这些子实体则是汽车的&quot;孩子&quot;(但是孩子也会有自己新产生的特征)。子类是父类的特殊化，也就是子类的实例(对象)一定是父类的实例 ，但是反过来不一定成立{比如说:一个圆他一定是几何图形，但反过来几何图形他不一定就是圆呀！还会有很多的呀}&lt;/h6&gt;
&lt;pre&gt;
&lt;code&gt;同样也说一个通俗易懂的例子：比如说，你家的家谱图，这其实就是一个很明显的一个继承关系

你的爸爸继承了你的爷爷(也就是子类继承父类)，那么你的爸爸肯定会有可你爷爷相同的特征，但是呢！ 你一定会发现你有一些特征是不同于你的爷爷的(当然也不同于你的奶奶)，你会有你自己独一无二的特征，这就是继承的关系
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;[3] 多态&lt;/li&gt;
&lt;/ul&gt;&lt;h6 id=&quot;--概念：同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果，这就是多态性。简单的说就是用父类的引用指向子类的对象变量。&quot;&gt;- 概念：同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果，这就是多态性。简单的说:就是用父类的引用指向子类的对象(变量)。&lt;/h6&gt;
&lt;p&gt;原因：我们知道，封装可以隐藏实现细节，使得代码模块化；&lt;/p&gt;
&lt;p&gt;继承可以扩展已存在的代码模块（类）；&lt;br/&gt;它们的目的都是为了代码重用。而多态除了代码的复用性外，还可以解决项目中紧偶合的问题,提高程序的可扩展性.。&lt;/p&gt;
&lt;p&gt;耦合度讲的是模块模块之间，代码代码之间的关联度，通过对系统的分析把他分解成一个一个子模块，子模块提供稳定的接口，达到降低系统耦合度的的目的，模块模块之间尽量使用模块接口访问，而不是随意引用其他模块的成员变量。&lt;/p&gt;
&lt;h6 id=&quot;有两个好处：-1-应用程序不必为每一个派生类编写功能调用，只需要对抽象基类进行处理即可。大大提高程序的可复用性。继承-2-派生类的功能可以被基类的方法或引用变量所调用，这叫向后兼容，可以提高可扩充性和可维护性。多态的真正作用，-可以用在方法的参数中-和-方法的返回类型中。-子类变量引用父类的变量&quot;&gt;有两个好处： 1. 应用程序不必为每一个派生类编写功能调用，只需要对抽象基类进行处理即可。大大提高程序的可复用性。//继承 2. 派生类的功能可以被基类的方法或引用变量所调用，这叫向后兼容，可以提高可扩充性和可维护性。//多态的真正作用， 可以用在方法的参数中 和 方法的返回类型中。 (子类变量引用父类的变量)&lt;/h6&gt;
&lt;ul&gt;&lt;li&gt;[4] 抽象：&lt;/li&gt;
&lt;/ul&gt;&lt;h6 id=&quot;就是把一个对象分析出各个属性，-来替代表达的手法-。&quot;&gt;就是把一个对象分析出各个属性， 来替代表达的手法 。&lt;/h6&gt;
&lt;h6 id=&quot;抽-就是抽离；象-，表复象。表示出来的部分&quot;&gt;抽 就是抽离；象 ，表复象。表示出来的部分&lt;/h6&gt;
&lt;pre&gt;
&lt;code&gt;比如一棵树。整个一看我们就知道是树，但是具体是为什么呢

这制样就要拿树和其它东西比出不一样的地方，这些地方就是抽象出来的。

抽象出来的东西脱离了树本身，也就变得没有意义，但是组合起来百就是树的概念。

比如一棵树，10米高，树皮粗糙，树叶是针形，树干很直，等等。这些属性组合起来会感觉是一颗松树。但是单独说 10 米，没有对象的话，就不知道这个是说的什么东西。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;编程上将对象抽象化是很有用的一个方法，能将枯燥的数据与单一度对象对应起来，这样易于理解，也便于编程。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;例如在编写学员管理系统。

学生的定义，首先要有名字，再有性别，问再有学号，等等等等。这些就是抽象出来的属性
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;3代码示例并且分析-2&quot;&gt;3.代码示例并且分析&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;[1] 多态&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public class Main {
    public static void main(String[] args) {
        // 给一个有普通收入、工资收入和享受国务院特殊津贴的小伙伴算税:
        Income[] incomes = new Income[] {
            new Income(3000),
            new Salary(7500),
            new StateCouncilSpecialAllowance(15000)
        };
        System.out.println(totalTax(incomes));
    }

    public static double totalTax(Income... incomes) {
        double total = 0;
        for (Income income: incomes) {
            total = total + income.getTax();
        }
        return total;
    }
}

class Income {
    protected double income;
//构造方法
    public Income(double income) {
        this.income = income;
    }
//定义一个方法
    public double getTax() {
        return income * 0.1; // 税率10%
    }
}
//子类Salary继承父类Income
class Salary extends Income {
        //构造方法
    public Salary(double income) {
        //super调用了继承的Salary中的构造方法
        super(income);
    }

    @Override
    public double getTax() {
        if (income &amp;lt;= 5000) {
            return 0;
        }
        return (income - 5000) * 0.2;
    }
}

class StateCouncilSpecialAllowance extends Income {
    public StateCouncilSpecialAllowance(double income) {
        super(income);
    }

    @Override
    public double getTax() {
        return 0;
    }
}

输出：800.0
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;观察totalTax()方法：利用多态,totalTax()只需和income来打交道它完全不需要知道要StateCouncilSpecialAllowance和Salary的存在，就可以完全计算出得到的税，如果我们要增加一种稿费的收入，只需要重income中派生出来，然后正确覆盖getTax方法()就可以，把新的类型传入给getTax()就可以了&lt;br/&gt;,不需要在重新修改代码&lt;/p&gt;
&lt;p&gt;可以看出:多态是一个多么强大的功能，就是允许添加更多类型的子类实现功能扩展，却不需要修改基于父类的代码&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;[2] 继承&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public class Bike {
        int speed;
        int brand;
        int colornum;
        //构造方法
        Bike(){
                System.out.println(&quot; call bike constructor&quot;);
        }
        public void speedUp() {
                speed = 0;
                System.out.println(&quot; too slow&quot;);
        }
        public void presshorn() {
                System.out.println(&quot; I am riding the bike&quot;);
        }
}

public class SpeedBike extends Bike{
        /**
         * super可以调用数据成员及其构造方法
         */
        SpeedBike(){//子类的构造方法
                super();
                super.colornum=12;//子类调用数据成员
                super.presshorn();
                System.out.println(&quot;call bike construction&quot;); 
        }
        public void ride() {
                System.out.println(&quot;I am riding the bike&quot;);
        }
        /**
         * super可以调用父类的方法
         */
        public void speedUp() {
                super.speedUp();
                speed+=10;
                System.out.println(&quot;so fasyt! ,&quot; + &quot; my speed is &quot; + speed + &quot; now&quot;);
        }
}

public class DemoBike{
        public static void main(String[] args) {
                SpeedBike aride = new SpeedBike();
                                aride.presshorn();
                                aride.speedUp();
                                aride.ride();
        }
}

输出：
call bike constructor
 I am riding the bike
call bike construction
 I am riding the bike
 too slow
so fasyt! , my speed is 10 now（这个输出代码就是覆盖重写了父类的方法)
I am riding the bike

&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;[3] 抽象&lt;br/&gt;如果一个class定义了方法，但没有具体执行代码，这个方法就是抽象方法，抽象方法用abstract来实现，因为无法执行抽象方法，因此这个类必须申请为抽象类&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;例如：Person 类定义了抽象方法run(),那么，在实现子类Student的时候，就必须覆盖run()方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Main {

        public static void main(String[] args) {
                Person p= new Student();
                p.run();
        }
}
abstract class  Person() {
        public abstract void run();
}
class Student extends Person{
        @overriding
        public void run() {
                System.out.println(&quot;Student . run&quot;);
        }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;[4] 封装&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;package com.fengzhuang;
class Car{
    private String name;//私有成员，名称
    private String color;//私有成员，颜色
    private String size;//私有成员,大小 
    //得到String类型名字的方法，最后return 返回去
    public String getName(){
        return name;
    }
    public String getColor(){
        return color;
    }
    public String getSize(){
        return size;
    }
    //因为方法名和参数名相同，所有用this
    public void setName(String name){
        this.name=name;
    }
    public void setColor(String color){
    this.color=color;
    }
    public void setSize(String size){
    this.size=size;
    }
}

package com.fengzhuang;
public class Test{
    public static void main(String[] args){
        Car b=new Car();//实例化操作
        b.setName(&quot;宝马&quot;);//赋值
        b.setColor(&quot;红色&quot;);
        b.setSize(&quot;大型&quot;);
        //很明显这些过程看不到如何实现。
        String name=b.getName();//取值
        String color=b.getColor();
        String size=b.getSize();
        //最后输出结果
        System.out.println(name+&quot;:&quot;+color+&quot;:&quot;+size);
    }
}

输出:
宝马:红色:大型

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解析:因为声名变量的时候我们已经设置他们几个为私有变量了，所以我们要是还想在访问它的话只有通过set这个建立器才可以进行访问&lt;/p&gt;
&lt;h3 id=&quot;4个人心得总结-2&quot;&gt;4.个人心得总结&lt;/h3&gt;
&lt;p&gt;前面已经说了这么写了，那我就最后说一点，总结一下这些吧！&lt;/p&gt;
&lt;h5 id=&quot;封装的优势在于定义只可以在类内部进行对属性的操作，外部无法对这些属性指手画脚，要想修改，也只能通过你定义的封装方法；&quot;&gt;封装的优势在于定义只可以在类内部进行对属性的操作，外部无法对这些属性指手画脚，要想修改，也只能通过你定义的封装方法；&lt;/h5&gt;
&lt;h5 id=&quot;继承减少了代码的冗余，省略了很多重复代码，开发者可以从父类底层定义所有子类必须有的属性和方法，以达到耦合的目的；&quot;&gt;继承减少了代码的冗余，省略了很多重复代码，开发者可以从父类底层定义所有子类必须有的属性和方法，以达到耦合的目的；&lt;/h5&gt;
&lt;h5 id=&quot;多态实现了方法的个性化，不同的子类根据具体状况可以实现不同的方法，光有父类定义的方法不够灵活，遇见特殊状况就捉襟见肘了&quot;&gt;多态实现了方法的个性化，不同的子类根据具体状况可以实现不同的方法，光有父类定义的方法不够灵活，遇见特殊状况就捉襟见肘了&lt;/h5&gt;
&lt;p&gt;这些是我对这些的理解，希望可以对大家有所帮助。——总而言之，这块真的是非常重要的，就是java语言的跟呀！大家一定要好好的理解，多琢磨琢磨，多写写代码，多思考，自然就不难了，就好比&quot;会了不难，难了不会&quot;这个道理是一样的，写这篇文章一方面是为了记录一下子知识点，另一方面也是希望可以帮助那些对这些概念，和代码的运用一知半解的朋友们，原创这篇文章真的很不容易写了好久，希望大家可以多多支持，要是有不懂的可以私信我或者在地下评论，看到了之后我会尽我所能为大家解答的，大家一起学习。(另外明后天我还会陆续连载一些原创文章的要是觉得我写的对你们有帮助的话，可以关注我一下子，方便查找 )&lt;/p&gt;

</description>
<pubDate>Fri, 01 May 2020 14:10:00 +0000</pubDate>
<dc:creator>IT女一枚</dc:creator>
<og:description>赶上明天就还是五一c小长假了，准备在这几天写几篇原创文章，供大家一起学习。 首先今天就来好好地唠一唠，到底java的那几个特性都是什么呢？到底怎么用呢？相信一定有一些小白对此会有些懊恼，没关系的，谁还</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiao666/p/12815077.html</dc:identifier>
</item>
<item>
<title>SpringCloud入门(十一)：Sleuth 与 Zipkin分布式链路跟踪 - 愚蠢的猴子</title>
<link>http://www.cnblogs.com/jiangyaxiong1990/p/12803306.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jiangyaxiong1990/p/12803306.html</guid>
<description>&lt;p&gt;　　现今业界分布式服务跟踪的理论基础主要来自于 Google 的一篇论文《Dapper, a Large-Scale Distributed Systems Tracing Infrastructure》，使用最为广泛的开源实现是 Twitter 的 Zipkin，为了实现平台无关、厂商无关的分布式服务跟踪，CNCF 发布了布式服务跟踪标准 Open Tracing。国内，淘宝的 “鹰眼”、京东的 “Hydra”、大众点评的 “CAT”、新浪的 “Watchman”、唯品会的 “Microscope”、窝窝网的 “Tracing” 都是这样的系统。&lt;/p&gt;
&lt;p&gt;　　一个分布式服务跟踪系统主要由三部分构成：数据收集、数据存储、数据展示。根据系统大小不同，每一部分的结构又有一定变化。譬如，对于大规模分布式系统，数据存储可分为实时数据和全量数据两部分，实时数据用于故障排查（Trouble Shooting），全量数据用于系统优化；数据收集除了支持平台无关和开发语言无关系统的数据收集，还包括异步数据收集（需要跟踪队列中的消息，保证调用的连贯性），以及确保更小的侵入性；数据展示又涉及到数据挖掘和分析。虽然每一部分都可能变得很复杂，但基本原理都类似。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/403345/202004/403345-20200429170341266-758974531.png&quot; alt=&quot;&quot; width=&quot;252&quot; height=&quot;239&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　服务追踪的追踪单元是从客户发起请求（request）抵达被追踪系统的边界开始，到被追踪系统向客户返回响应（response）为止的过程，称为一个 trace。每个 trace 中会调用若干个服务，为了记录调用了哪些服务，以及每次调用的消耗时间等信息，在每次调用服务时，埋入一个调用记录，称为一个 span。这样，若干个有序的 span 就组成了一个 trace。在系统向外界提供服务的过程中，会不断地有请求和响应发生，也就会不断生成 trace，把这些带有 span 的 trace 记录下来，就可以描绘出一幅系统的服务拓扑图。附带上 span 中的响应时间，以及请求成功与否等信息，就可以在发生问题的时候，找到异常的服务；根据历史数据，还可以从系统整体层面分析出哪里性能差，定位性能优化的目标。&lt;/p&gt;
&lt;p&gt;　　SpringCloud Sleuth 也为我们提供了一套完整的解决方案。Sleuth 为服务之间调用提供链路追踪，通过 Sleuth 可以很清楚的了解到一个服务请求经过了哪些服务，每个服务处理花费了多长。从而让我们可以很方便的理清各微服务间的调用关系。此外 Sleuth 可以帮助我们：&lt;br/&gt;        耗时分析：通过 Sleuth 可以很方便的了解到每个采样请求的耗时，从而分析出哪些服务调用比较耗时；&lt;br/&gt;        可视化错误：对于程序未捕捉的异常，可以通过集成 Zipkin 服务界面上看到；&lt;br/&gt;        链路优化：对于调用比较频繁的服务，可以针对这些服务实施一些优化措施。&lt;/p&gt;
&lt;p&gt;　　Spring Cloud Sleuth 的概念图，图中画圈的部分是Sleuth的标记（Annotation,一个标注可以理解成span生命周期中重要时刻的数据快照，比如一个标注中一般包含发生时刻（timestamp）、事件类型（value）、端点（endpoint）等信息）信息，分别表示：&lt;br/&gt;        客户端发送 client send：客户端已经发出请求。此标记biao描绘了跨度的开始。&lt;br/&gt;        服务器接收 server received：服务器端得到请求，将开始进行处理。&lt;br/&gt;        服务器发送 server send：在完成请求处理后（响应发送回客户端时）标记。&lt;br/&gt;        客户端接收 client received：表示跨度的结束，客户端已成功接收到服务器端的响应。&lt;/p&gt;
&lt;p&gt;　　通过这四个标记，我们可以计算出相应的四个值：&lt;br/&gt;　　请求延时=sr-cs&lt;br/&gt;　　响应延时 cr-ss&lt;br/&gt;　　服务器处理时间:ss-sr&lt;br/&gt;　　客户端请求时间:cr-cs = 请求延时+响应延时+服务器处理时间&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/403345/202004/403345-20200430233259862-431373004.png&quot; alt=&quot;&quot; width=&quot;721&quot; height=&quot;386&quot;/&gt;&lt;/p&gt;

&lt;p&gt; SpringCloud Sleuth 入门&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;!-- 1. 加入POM依赖 --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-cloud-starter-sleuth&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;!-- 2. 修改属性文件，打开sleuth日志 --&amp;gt;&lt;span&gt;
logging.level.org.springframework.cloud.sleuth&lt;/span&gt;=debug
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;启动项目后，通过consumer去调用provider观察输出的日志信息，会发现多出了：[ms-consumer-user,7d0cbb49820bbacd,551bf65184bbc971,false]，其中四个参数分别代表[微服务应用名,traceId,spanId,是否持久化]&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/403345/202005/403345-20200501201906789-412612639.png&quot; alt=&quot;&quot; width=&quot;1005&quot; height=&quot;165&quot;/&gt;&lt;/p&gt;



&lt;p&gt;Sleuth 的持久化Sleuth+zipkin&lt;/p&gt;
&lt;p&gt;　　SpringCloud Sleuth结合 Zipkin，将信息发送到 Zipkin，利用 Zipkin 的存储来存储信息，利用 Zipkin UI 来展示数据。Zipkin是Twitter 的一个开源项目，它基于 Google Dapper 实现，它致力于收集服务的定时数据，以解决微服务架构中的延迟问题，包括数据的收集、存储、查找和展现。我们可以使用它来收集各个服务器上请求链路的跟踪数据，并通过它提供的 REST API 接口来辅助我们查询跟踪数据以实现对分布式系统的监控程序，从而及时地发现系统中出现的延迟升高问题并找出系统性能瓶颈的根源。除了面向开发的 API 接口之外，它也提供了方便的 UI 组件来帮助我们直观的搜索跟踪信息和分析请求链路明细，比如：可以查询某段时间内各用户请求的处理时间等。Zipkin 提供了可插拔数据存储方式：In-Memory、MySql、Cassandra 以及 Elasticsearch，生产推荐 Elasticsearch。&lt;/p&gt;
&lt;p&gt;Zipkin 基础架构如图所示，它主要由 4 个核心组件构成：&lt;br/&gt;Collector：收集器组件，它主要用于处理从外部系统发送过来的跟踪信息，将这些信息转换为 Zipkin 内部处理的 Span 格式，以支持后续的存储、分析、展示等功能。&lt;br/&gt;Storage：存储组件，它主要对处理收集器接收到的跟踪信息，默认会将这些信息存储在内存中，我们也可以修改此存储策略，通过使用其他存储组件将跟踪信息存储到数据库中。&lt;br/&gt;RESTful API：API 组件，它主要用来提供外部访问接口。比如给客户端展示跟踪信息，或是外接系统访问以实现监控等。&lt;br/&gt;Web UI：UI 组件，基于 API 组件实现的上层应用。通过 UI 组件用户可以方便而有直观地查询和分析跟踪信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/403345/202005/403345-20200501205129191-519905036.png&quot; alt=&quot;&quot; width=&quot;600&quot; height=&quot;474&quot;/&gt;&lt;/p&gt;


&lt;p&gt; Zipkin 入门&lt;/p&gt;
&lt;p&gt;　　Zipkin 分为两端，一个是 Zipkin 服务端，一个是 Zipkin 客户端，客户端也就是微服务的应用。客户端会配置服务端的 URL 地址，一旦发生服务间的调用的时候，会被配置在微服务里面的 Sleuth 的监听器监听，并生成相应的 Trace 和 Span 信息发送给服务端。发送的方式主要有两种，一种是 HTTP 报文的方式，还有一种是消息总线的方式如 RabbitMQ。&lt;/p&gt;
&lt;p&gt;方法一 HTTP 报文的方式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;!-- 1. 加入POM依赖 --&amp;gt;
&amp;lt;dependency&amp;gt;
&amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
&amp;lt;artifactId&amp;gt;spring-cloud-starter-sleuth&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;dependency&amp;gt;
&amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
&amp;lt;artifactId&amp;gt;spring-cloud-starter-zipkin&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;!-- 2. 修改属性文件，打开sleuth日志 --&amp;gt;&lt;span&gt;
#zipkin server的地址
spring.zipkin.base&lt;/span&gt;-url=http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:9411/&lt;/span&gt;
spring.sleuth.web.client.enabled=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
#采样比例默认是0.&lt;/span&gt;1&lt;span&gt; 为1表示全部上报
spring.sleuth.sampler.probability&lt;/span&gt;=1

&amp;lt;!-- 3.启动一个Zipkin的服务端，在SpringBoot1.x我们需要手动搭建，在Springboot2.x之后我们只需去官网下载，通过java -&lt;span&gt;jar启动即可
下载链接为https:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;search.maven.org/remote_content?g=io.zipkin.java&amp;amp;a=zipkin-server&amp;amp;v=LATEST&amp;amp;c=exec --&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;启动后通过http://localhost:9411/zipkin进入界面，消费者向提供者发送请求后，zipkinUI会显示相关的调用链信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/403345/202005/403345-20200501210836869-337406140.png&quot; alt=&quot;&quot; width=&quot;1081&quot; height=&quot;338&quot;/&gt;&lt;/p&gt;

&lt;p&gt;方法二 RabbitMQ的方式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;!-- 1. 加入POM依赖 --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-cloud-stream-binder-rabbit&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;!-- 2. 修改属性文件，打开sleuth日志 --&amp;gt;&lt;span&gt;
spring.zipkin.sender.type&lt;/span&gt;=&lt;span&gt;rabbit
spring.sleuth.web.client.enabled&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
#采样比例默认是0.&lt;/span&gt;1&lt;span&gt; 为1表示全部上报
spring.sleuth.sampler.probability&lt;/span&gt;=1&lt;span&gt;
spring.rabbitmq.host&lt;/span&gt;=127.0.0.1&lt;span&gt;
spring.rabbitmq.port&lt;/span&gt;=5672&lt;span&gt;
spring.rabbitmq.password&lt;/span&gt;=&lt;span&gt;guest
spring.rabbitmq.username&lt;/span&gt;=&lt;span&gt;guest
spring.rabbitmq.virtual&lt;/span&gt;-host=/

&amp;lt;!-- 3.启动一个Zipkin的服务端，通过命令指定rabbit --&amp;gt;&lt;span&gt;
java &lt;/span&gt;-jar zipkin-server-2.12.9-exec.jar --zipkin.collector.rabbitmq.address=127.0.0.1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; Zipkin+mysql数据持久化&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&amp;lt;!-- 1. 创建一个zipkin的数据库，并执行建表语句 --&amp;gt;&lt;span&gt;
CREATE TABLE `zipkin_annotations` (
  `trace_id_high` bigint(&lt;/span&gt;20) NOT NULL DEFAULT '0' COMMENT 'If non zero, this means the trace uses 128 bit traceIds instead of 64 bit'&lt;span&gt;,
  `trace_id` bigint(&lt;/span&gt;20) NOT NULL COMMENT 'coincides with zipkin_spans.trace_id'&lt;span&gt;,
  `span_id` bigint(&lt;/span&gt;20) NOT NULL COMMENT 'coincides with zipkin_spans.id'&lt;span&gt;,
  `a_key` varchar(&lt;/span&gt;255) NOT NULL COMMENT 'BinaryAnnotation.key or Annotation.value if type == -1'&lt;span&gt;,
  `a_value` blob COMMENT &lt;/span&gt;'BinaryAnnotation.value(), which must be smaller than 64KB'&lt;span&gt;,
  `a_type` &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;(11) NOT NULL COMMENT 'BinaryAnnotation.type() or -1 if Annotation'&lt;span&gt;,
  `a_timestamp` bigint(&lt;/span&gt;20) DEFAULT NULL COMMENT 'Used to implement TTL; Annotation.timestamp or zipkin_spans.timestamp'&lt;span&gt;,
  `endpoint_ipv4` &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;(11) DEFAULT NULL COMMENT 'Null when Binary/Annotation.endpoint is null'&lt;span&gt;,
  `endpoint_ipv6` binary(&lt;/span&gt;16) DEFAULT NULL COMMENT 'Null when Binary/Annotation.endpoint is null, or no IPv6 address'&lt;span&gt;,
  `endpoint_port` smallint(&lt;/span&gt;6) DEFAULT NULL COMMENT 'Null when Binary/Annotation.endpoint is null'&lt;span&gt;,
  `endpoint_service_name` varchar(&lt;/span&gt;255) DEFAULT NULL COMMENT 'Null when Binary/Annotation.endpoint is null'&lt;span&gt;,
  UNIQUE KEY `trace_id_high` (`trace_id_high`,`trace_id`,`span_id`,`a_key`,`a_timestamp`),
  KEY `trace_id_high_2` (`trace_id_high`,`trace_id`,`span_id`),
  KEY `trace_id_high_3` (`trace_id_high`,`trace_id`),
  KEY `endpoint_service_name` (`endpoint_service_name`),
  KEY `a_type` (`a_type`),
  KEY `a_key` (`a_key`)
) ENGINE&lt;/span&gt;=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=&lt;span&gt;COMPRESSED;

&lt;/span&gt;&amp;lt;!-- 2.启动一个Zipkin的服务端，通过命令指定mysql --&amp;gt;&lt;span&gt;
zipkin server启动java &lt;/span&gt;-jar zipkin-server-2.11.1-exec.jar --STORAGE_TYPE=mysql --MYSQL_DB=zipkin --MYSQL_USER=root --MYSQL_PASS=root --MYSQL_HOST=127.0.0.1 --MYSQL_TCP_PORT=3306
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;备注：文章参考 https://windmt.com/2018/04/24/spring-cloud-12-sleuth-zipkin/&lt;/p&gt;
</description>
<pubDate>Fri, 01 May 2020 13:28:00 +0000</pubDate>
<dc:creator>愚蠢的猴子</dc:creator>
<og:description>现今业界分布式服务跟踪的理论基础主要来自于 Google 的一篇论文《Dapper, a Large-Scale Distributed Systems Tracing Infrastructure》</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jiangyaxiong1990/p/12803306.html</dc:identifier>
</item>
<item>
<title>突然地心血来潮，为 MaixPy（ k210 micropython ） 添加看门狗（WDT） C 模块的开发过程记录，给后来的人做开发参考。 - Juwan</title>
<link>http://www.cnblogs.com/juwan/p/12814895.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/juwan/p/12814895.html</guid>
<description>&lt;p&gt;事情是前几天群里有人说做个看门狗不难吧，5分钟的事情，然后我就怼了几句，后来才发现，原来真的没有看门狗模块鸭。&lt;/p&gt;
&lt;p&gt;那好吧，那我就写一下好了，今天是（2020年4月30日）想着最后一天了，不如做点什么有价值的事情贡献一下代码好了。&lt;/p&gt;
&lt;p&gt;做这个事情前吧，先思考一下模块的接口设计，可以参考一下 esp32 的设计，因为是 micropython 后来的代码，所以在设计上充分考虑了跨平台性。&lt;/p&gt;
&lt;p&gt;那么我就以如下的代码为参考开始吧。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import time
from machine import WDT

# test default wdt
wdt0 = WDT(id=0, timeout=3000)
print('into', wdt0)
time.sleep(2)
print(time.ticks_ms())
# 1.test wdt feed
wdt0.feed()
time.sleep(2)
print(time.ticks_ms())
# 2.test wdt stop
wdt0.stop()
print('stop', wdt0)
# 3.wait wdt work
while True:
    print('idle', time.ticks_ms())
    time.sleep(1)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到这是最朴素的看门狗设计，只有 new 、feed、stop 接口，这足够一般使用了。&lt;/p&gt;
&lt;p&gt;接着我在堪智的 code 的接口中注意到有一个有趣的设计，也就是如下的 &lt;a href=&quot;https://github.com/junhuanchen/MaixPy/blob/c4568e4f174de1c9eaf083506c2019ffbe8c7bf5/components/micropython/port/src/standard_lib/machine/machine_wdt.c#L156-L177&quot;&gt;C code&lt;/a&gt; 。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;#include &quot;printf.h&quot;
static int wdt0_irq(void *ctx) {
    static int s_wdt_irq_cnt = 0;
    printk(&quot;%s\n&quot;, __func__);
    s_wdt_irq_cnt ++;
    if(s_wdt_irq_cnt &amp;lt; 2)
        wdt_clear_interrupt((wdt_device_number_t)0);
    else
        while(1);
    return 0;
}

static void unit_test() {
    mp_printf(&amp;amp;mp_plat_print, &quot;wdt start!\n&quot;);
    int timeout = 0;
    plic_init();
    sysctl_enable_irq();
    mp_printf(&amp;amp;mp_plat_print, &quot;wdt time is %d ms\n&quot;, wdt_init((wdt_device_number_t)0, 4000, wdt0_irq,NULL));
    while(1) {
        vTaskDelay(1000);
        if(timeout++ &amp;lt; 3) {
            wdt_feed((wdt_device_number_t)0);
        } else {
            printf(&quot;wdt_stop\n&quot;);
            wdt_stop((wdt_device_number_t)0);
            sysctl_clock_disable(0 ? SYSCTL_CLOCK_WDT1 : SYSCTL_CLOCK_WDT0); // patch for fix stop
            while(1) 
            {
                printf(&quot;wdt_idle\n&quot;);
                sleep(1);
            }
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个已经是我测试过的底层 code 了，顺便一提的是 SDK 的 stop 没有关掉 wdt 的时钟（sysctl_clock_disable），所以 stop 接口是不工作的，关于这个已经提交 issue 了，之后就会修复上。（2020年5月1日）&lt;/p&gt;
&lt;p&gt;我们继续看到这个设计，它允许导入一个 callback 和 context 参数（上下文用途），这个我看到的时候就思考了一下，这个看门狗的使用场景可能有如下几种。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;满足一般的看门狗的基本功能，不喂狗就复位。&lt;/li&gt;
&lt;li&gt;允许接入回调函数，在即将复位之前，进入中断函数，此时由用户决定如下三种状态。
&lt;ul&gt;&lt;li&gt;没有可以处理该异常（未能成功喂狗）的方法，最终只能 pass ，这将导致硬件复位。&lt;/li&gt;
&lt;li&gt;存在解决方案，并成功解决了问题，则取消这次的复位（继续喂狗）。&lt;/li&gt;
&lt;li&gt;发现不需要看门狗了，可能手动触发复位或者是其他考虑，则关闭看门狗模块（stop）。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;综上所述，我们要能够在代码中体现的要素，配置看门狗的启动（new）、喂狗（feed）、回调（callback+context）、停止（stop）即可。&lt;/p&gt;
&lt;p&gt;则拓展处第二种代码设计为&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;
def on_wdt(self):
    print(self.context(), self)
    #self.feed()
    ## release WDT
    #self.stop()

# test callback wdt
wdt1 = WDT(id=1, timeout=4000, callback=on_wdt, context={})
print('into', wdt1)
time.sleep(2)
print(time.ticks_ms())
# 1.test wdt feed
wdt1.feed()
time.sleep(2)
print(time.ticks_ms())
# 2.test wdt stop
wdt1.stop()
print('stop', wdt1)
# 3.wait wdt work
while True:
    print('idle', time.ticks_ms())
    time.sleep(1)

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然，这都是在我写完，和测试完之后做的总结了，所以过程是省略了不少，但会挑一下重点来讲。&lt;/p&gt;
&lt;p&gt;第一个是，参考以往的代码框架，如 &lt;a href=&quot;https://github.com/micropython/micropython/blob/master/ports/esp32/machine_wdt.c&quot;&gt;esp32/machine_wdt.c&lt;/a&gt; 用来构建 wdt 的基础接口框架，如第一份代码的设计，接着因为回调的原因，这个设计类似于 timer 定时器，所以定时器的 code 也要拿来参考，如 &lt;a href=&quot;https://github.com/micropython/micropython/blob/master/ports/esp32/machine_timer.c&quot;&gt;esp32/machine_timer.c&lt;/a&gt; ，基本上就可以做出来拉，这并不难。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;不难归不难，但也不会是 5 分钟就可以写完的代码，大概也要差不多一天吧（标准8小时工作时间），如果一切顺利的话。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;注意写的流程，建议满足如下流程。&lt;/p&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;确认原始 SDK 的功能正常，符合基本的单元测试，可以确定模块的创建、启动、配置、停止、释放等要素。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;确认 micropython 的接口函数定义，可以先假定接口但不实现，主要是分离开发。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;基于前者的单元测试，丢入 Micropython 环境中执行，如配套的单元测试，确保可以在不破坏其他变量的条件下实现。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;此时确保 C 方面的基础接口符合基本的使用，准备接入 Python 代码进行单元测试，直到功能实现没有明显的死角。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;走完上述流程后，基本上第一份看门狗 CODE 就可以实现了，很简单，就 new 和 feed ，测试的 code 都不需要很复杂，只要确保不喂狗的时候复位了就好了。&lt;/p&gt;
&lt;p&gt;接下来补一点细节和思考，如何添加回调，理解 C 与 MicroPython 函数之间的回调机制关系，主要就是 C 如何调用 Python 中设计的 函数 和传递参数。&lt;/p&gt;
&lt;p&gt;这个部分看 timer.c 基本就可以搞定了,不了解的就看提交 &lt;a href=&quot;https://github.com/junhuanchen/MaixPy/commit/c4568e4f174de1c9eaf083506c2019ffbe8c7bf5&quot;&gt;MaixPy/commit/c4568e4f174de1c9eaf083506c2019ffbe8c7bf5&lt;/a&gt; ，一是绑定一个本地函数，二是通过 C 接口调用函数传递 mp_obj_t 的 Python 对象。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;
STATIC void machine_wdt_isr(void *self_in) {
    machine_wdt_obj_t *self = self_in;
    if (self-&amp;gt;callback != mp_const_none) {
        // printk(&quot;wdt id is %d\n&quot;, self-&amp;gt;id);
        if (self-&amp;gt;is_interrupt == false) {
            wdt_clear_interrupt(self-&amp;gt;id);
            self-&amp;gt;is_interrupt = true;
            mp_sched_schedule(self-&amp;gt;callback, self);
        }
        mp_hal_wake_main_task_from_isr();
    }
}

wdt_init(self-&amp;gt;id, self-&amp;gt;timeout, (plic_irq_callback_t)machine_wdt_isr, (void *)self);

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这里 machine_wdt_isr 是用来接收 WDT 的 C 中断，它将会在 WDT 即将复位之前反复重入（执行），为了在进入中断后不重入则需要清理中断的信号 wdt_clear_interrupt(self-&amp;gt;id); 。&lt;/p&gt;
&lt;p&gt;接着 mp_sched_schedule(self-&amp;gt;callback, self); 用来执行 Python 对应的函数对象，参数指为自身，我设计中的上下文通过 self.context() 来处理，这样的好处就是可以在回调函数中决定如何管理当下的看门狗模块状态。&lt;/p&gt;
&lt;p&gt;注意 mp_hal_wake_main_task_from_isr(); 是用来继续执行 MicroPython 环境的代码，可以这样理解，中断将会吃掉所有函数的执行，也包括 MicroPython 的主进程，也就是 repl 接口的（main）代码，也就是说，若是不在这里继续执行 MicroPython 环境，整个芯片将会停止工作，全部都陷入了一个空转的中断函数中。&lt;/p&gt;
&lt;p&gt;而至于我为什么加上了 is_interrupt 这是因为考虑到第二种设计所添加的标记量，它主要解决以下场景的问题。&lt;/p&gt;
&lt;p&gt;is_interrupt 会在 machine_wdt_feed 中设置为 self-&amp;gt;is_interrupt = false; 表示这个状态要撤销，结合上述的 machine_wdt_isr 逻辑来看。&lt;/p&gt;
&lt;p&gt;我们回顾回调处理的场景之一，没有可以处理该异常（未能成功喂狗）的方法，最终只能 pass ，这将导致硬件复位。&lt;/p&gt;
&lt;p&gt;第一次触发进入 is_interrupt 为防止重入则打上标记量 self-&amp;gt;is_interrupt = true; 此时在清理信号后，将正常执行 Python 中的回调函数，若回调函数什么也不做，就会进一步触发复位，从这之后若是再次进入中断后，将会反复执行 mp_hal_wake_main_task_from_isr ，直到硬件复位。&lt;/p&gt;
&lt;p&gt;此时若是在回调中 feed 喂狗重置了 is_interrupt 标记则允许重入 Python 的回调函数，从而防止进一步的看门狗复位。&lt;/p&gt;
&lt;p&gt;此时若是在回调中 stop 了，则整个模块都释放了。&lt;/p&gt;
&lt;p&gt;此时若是什么也不做，放一会就复位了。&lt;/p&gt;
&lt;p&gt;以上，就这些，想知道更多就去看提交的代码吧，会有不一定的理解的（也许？）。&lt;/p&gt;
&lt;p&gt;最后补一下单元测试 Code 。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import time
from machine import WDT

# '''
# test default wdt
wdt0 = WDT(id=0, timeout=3000)
print('into', wdt0)
time.sleep(2)
print(time.ticks_ms())
# 1.test wdt feed
wdt0.feed()
time.sleep(2)
print(time.ticks_ms())
# 2.test wdt stop
wdt0.stop()
print('stop', wdt0)
# 3.wait wdt work
while True:
    print('idle', time.ticks_ms())
    time.sleep(1)
# '''

# '''
def on_wdt(self):
    print(self.context(), self)
    #self.feed()
    ## release WDT
    #self.stop()

# test callback wdt
wdt1 = WDT(id=1, timeout=4000, callback=on_wdt, context={})
print('into', wdt1)
time.sleep(2)
print(time.ticks_ms())
# 1.test wdt feed
wdt1.feed()
time.sleep(2)
print(time.ticks_ms())
# 2.test wdt stop
wdt1.stop()
print('stop', wdt1)
# 3.wait wdt work
while True:
    print('idle', time.ticks_ms())
    time.sleep(1)
# '''

#'''
## test default and callback wdt
def on_wdt(self):
    print(self.context(), self)
    #self.feed()
    ## release WDT
    #self.stop()

wdt0 = WDT(id=0, timeout=3000, callback=on_wdt, context=[])
wdt1 = WDT(id=1, timeout=4000, callback=on_wdt, context={})
## 3.wait wdt work
while True:
    #wdt0.feed()
    print('idle', time.ticks_ms())
    time.sleep(1)
#'''
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;其实只是给我自己备份 Code 而已，2020年5月1日留。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 01 May 2020 13:23:00 +0000</pubDate>
<dc:creator>Juwan</dc:creator>
<og:description>事情是前几天群里有人说做个看门狗不难吧，5分钟的事情，然后我就怼了几句，后来才发现，原来真的没有看门狗模块鸭。 那好吧，那我就写一下好了，今天是（2020年4月30日）想着最后一天了，不如做点什么有价</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/juwan/p/12814895.html</dc:identifier>
</item>
<item>
<title>CTR学习笔记&amp;代码实现4-深度ctr模型 NFM/AFM - 风雨中的小七</title>
<link>http://www.cnblogs.com/gogoSandy/p/12814804.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gogoSandy/p/12814804.html</guid>
<description>&lt;p&gt;这一节我们总结FM另外两个远亲NFM，AFM。NFM和AFM都是针对Wide&amp;amp;Deep 中Deep部分的改造。上一章PNN用到了向量内积外积来提取特征交互信息，总共向量乘积就这几种，这不NFM就带着element-wise(hadamard) product来了。AFM则是引入了注意力机制把NFM的等权求和变成了加权求和。&lt;/p&gt;
&lt;p&gt;以下代码针对Dense输入感觉更容易理解模型结构，针对spare输入的代码和完整代码 👇&lt;br/&gt;&lt;a href=&quot;https://github.com/DSXiangLi/CTR&quot;&gt;https://github.com/DSXiangLi/CTR&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;nfm&quot;&gt;NFM&lt;/h2&gt;
&lt;p&gt;NFM的创新点是在wide&amp;amp;Deep的Deep部分，在Embedding层和全联接层之间加入了BI-Pooling层,也就是Embedding两两做element-wise乘积得到 &lt;span class=&quot;math inline&quot;&gt;\(N*(N-1)/2\)&lt;/span&gt;个 &lt;span class=&quot;math inline&quot;&gt;\(1*K\)&lt;/span&gt;的矩阵然后做sum_pooling得到最终&lt;span class=&quot;math inline&quot;&gt;\(1*k\)&lt;/span&gt;的矩阵。&lt;/p&gt;
&lt;p&gt;\[f_{BI}(V_x) = \sum_{i=1}^n\sum_{j=i+1}^n (x_iv_i) \odot (x_jv_j) \]&lt;/p&gt;
&lt;p&gt;Deep部分的模型结构如下&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;http://static.zybuluo.com/hongchenzimo/fg3x8zjl0eiotzjwvlg1tx6p/image.png&quot; width=&quot;300&quot; height=&quot;300&quot;/&gt;&lt;/p&gt;

&lt;h3 id=&quot;和其他模型的联系&quot;&gt;和其他模型的联系&lt;/h3&gt;
&lt;p&gt;NFM不接全连接层，直接weight=1输出就是FM，所以NFM可以在FM上学到更高阶的特征交互。&lt;/p&gt;
&lt;p&gt;有看到一种说法是DeepFM是FM和Deep并联，NFM是把FM和Deep串联，也是可以这么理解，但感觉本质是在学习不同的信息，把FM放在wide侧是帮助学习二阶‘记忆特征’，把FM放在Deep侧是帮助学习高阶‘泛化特征’。&lt;/p&gt;
&lt;p&gt;NFM和PNN都是用向量相乘的方式来帮助全联接层提炼特征交互信息。&lt;strong&gt;虽然一个是element-wise product一个是inner product,但区别其实只是做sum_pooling时axis的差异&lt;/strong&gt;。 IPNN是在k的axis上求和得到&lt;span class=&quot;math inline&quot;&gt;\(N^2\)&lt;/span&gt;个scaler拼接成输入， 而NFM是在&lt;span class=&quot;math inline&quot;&gt;\(N^2\)&lt;/span&gt;的axis上求和得到&lt;span class=&quot;math inline&quot;&gt;\(1*K\)&lt;/span&gt;的输入。&lt;/p&gt;
&lt;p&gt;下面这个例子可以比较直观的比较一下FM，NFM，IPNN对Embedding的处理(为了简单理解给了Embedding简单数值)&lt;/p&gt;
&lt;p&gt;\[\begin{align} &amp;amp; embedding_1 = [0.5,0.5,0.5]\\ &amp;amp; embedding_2 = [2,2,2]\\ &amp;amp; embedding_3 = [4,4,4]\\ &amp;amp; embedding_1 \odot embedding_2 = [1,1,1]\\ &amp;amp; embedding_1 \odot embedding_3 = [2,2,2]\\ &amp;amp; embedding_2 \odot embedding_3 = [8,8,8]\\ &amp;amp; IPNN = [3，6，24] \\ &amp;amp; NFM = [11，11，11]\\ &amp;amp; FM = [33]\\ \end{align} \]&lt;/p&gt;
&lt;p&gt;NFM几个想吐槽的点&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;和FNN，PNN一样对低阶特征的提炼比较有限&lt;/li&gt;
&lt;li&gt;这个sum_pooling同样会存在信息损失，不同的特征交互对Target的影响不同，等权加和一定不是最好的方法，但也算是为特征交互提供了一种新方法&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;代码实现&quot;&gt;代码实现&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;@tf_estimator_model
def model_fn_dense(features, labels, mode, params):
    dense_feature, sparse_feature = build_features()
    dense = tf.feature_column.input_layer(features, dense_feature)
    sparse = tf.feature_column.input_layer(features, sparse_feature)

    field_size = len( dense_feature )
    embedding_size = dense_feature[0].variable_shape.as_list()[-1]
    embedding_matrix = tf.reshape( dense, [-1, field_size, embedding_size] )  # batch * field_size *emb_size

    with tf.variable_scope('Linear_output'):
        linear_output = tf.layers.dense( sparse, units=1 )
        add_layer_summary( 'linear_output', linear_output )

    with tf.variable_scope('BI_Pooling'):
        sum_square = tf.pow(tf.reduce_sum(embedding_matrix, axis=1), 2)
        square_sum = tf.reduce_sum(tf.pow(embedding_matrix, 2), axis=1)
        dense = tf.subtract(sum_square, square_sum)
        add_layer_summary( dense.name, dense )

    dense = stack_dense_layer(dense, params['hidden_units'],
                              dropout_rate = params['dropout_rate'], batch_norm = params['batch_norm'],
                              mode = mode, add_summary = True)

    with tf.variable_scope('output'):
        y = linear_output + dense
        add_layer_summary( 'output', y )

    return y
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;afm&quot;&gt;AFM&lt;/h2&gt;
&lt;p&gt;AFM和NFM同样使用element-wise product来提取特征交互信息，和NFM直接等权重做pooling不同的是，AFM增加了一层Attention Layer来学习pooling的权重。&lt;/p&gt;
&lt;p&gt;Deep部分的模型结构如下&lt;/p&gt;
&lt;p&gt;\[\begin{align} f_{Att} = \sum_{i=1}^n\sum_{j=i+1}^n a_{ij}(v_ix_i) \odot (v_jx_j) \end{align} \]&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;http://static.zybuluo.com/hongchenzimo/yxwvenmx8v1a2js63fjzyqot/image.png&quot; width=&quot;450&quot; height=&quot;200&quot;/&gt;&lt;/p&gt;

&lt;p&gt;注意力部分是一个简单的全联接层，输出的是&lt;span class=&quot;math inline&quot;&gt;\(N(N-1)/2\)&lt;/span&gt;的矩阵，作为sum_pooling的权重向量，对element-wise特征交互向量进行加权求和。加权求和的向量直接连接output，不再经过全联接层。如果权重为1，那AFM和不带全联接层的NFM是一样滴。&lt;/p&gt;
&lt;p&gt;\[\begin{align} a_{ij} &amp;amp;= h^T ReLU(W (v_ix_i) \odot (v_jx_j) +b) \\ a_{ij} &amp;amp;= \frac{exp(a_{ij})}{\sum_{ij}exp(a_{ij})}\\ \end{align} \]&lt;/p&gt;
&lt;p&gt;AFM几个想吐槽的点&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;不带全联接层会导致高级特征表达有限，不过这个不重要啦，AFM更多还是为特征交互提供了Attention的新思路&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;代码实现-2&quot;&gt;代码实现&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;@tf_estimator_model
def model_fn_dense(features, labels, mode, params):
    dense_feature, sparse_feature = build_features()
    dense = tf.feature_column.input_layer(features, dense_feature) # lz linear concat of embedding
    sparse = tf.feature_column.input_layer(features, sparse_feature)

    field_size = len( dense_feature )
    embedding_size = dense_feature[0].variable_shape.as_list()[-1]
    embedding_matrix = tf.reshape( dense, [-1, field_size, embedding_size] )  # batch * field_size *emb_size

    with tf.variable_scope('Linear_part'):
        linear_output = tf.layers.dense(sparse, units=1)
        add_layer_summary( 'linear_output', linear_output )

    with tf.variable_scope('Elementwise_Interaction'):
        elementwise_list = []
        for i in range(field_size):
            for j in range(i+1, field_size):
                vi = tf.gather(embedding_matrix, indices=i, axis=1, batch_dims=0,name = 'vi') # batch * emb_size
                vj = tf.gather(embedding_matrix, indices=j, axis=1, batch_dims=0,name = 'vj')
                elementwise_list.append(tf.multiply(vi,vj)) # batch * emb_size
        elementwise_matrix = tf.stack(elementwise_list) # (N*(N-1)/2) * batch * emb_size
        elementwise_matrix = tf.transpose(elementwise_matrix, [1,0,2]) # batch * (N*(N-1)/2) * emb_size

    with tf.variable_scope('Attention_Net'):
        # 2 fully connected layer
        dense = tf.layers.dense(elementwise_matrix, units = params['attention_factor'], activation = 'relu') # batch * (N*(N-1)/2) * t
        add_layer_summary( dense.name, dense )
        attention_weight = tf.layers.dense(dense, units=1, activation = 'softmax') # batch *(N*(N-1)/2) * 1
        add_layer_summary( attention_weight.name, attention_weight)

    with tf.variable_scope('Attention_pooling'):
        interaction_output = tf.reduce_sum(tf.multiply(elementwise_matrix, attention_weight), axis=1) # batch * emb_size
        interaction_output = tf.layers.dense(interaction_output, units=1) # batch * 1

    with tf.variable_scope('output'):
        y = interaction_output + linear_output
        add_layer_summary( 'output', y )

    return y
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;CTR学习笔记&amp;amp;代码实现系列👇&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/gogoSandy/p/12501846.html&quot;&gt;CTR学习笔记&amp;amp;代码实现1-深度学习的前奏LR-&amp;gt;FFM&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/gogoSandy/p/12658051.html&quot;&gt;CTR学习笔记&amp;amp;代码实现2-深度ctr模型 MLP-&amp;gt;Wide&amp;amp;Deep&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/gogoSandy/p/12742417.html&quot;&gt;CTR学习笔记&amp;amp;代码实现3-深度ctr模型 FNN-&amp;gt;PNN-&amp;gt;DeepFM&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;资料&quot;&gt;资料&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;Jun Xiao, Hao Ye ,2017, Attentional Factorization Machines - Learning the Weight of Feature Interactions via Attention Networks&lt;/li&gt;
&lt;li&gt;Xiangnan He, Tat-Seng Chua,2017, Neural Factorization Machines for Sparse Predictive Analytics&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/86181485&quot;&gt;https://zhuanlan.zhihu.com/p/86181485&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Fri, 01 May 2020 13:00:00 +0000</pubDate>
<dc:creator>风雨中的小七</dc:creator>
<og:description>这一节我们总结FM另外两个远亲NFM，AFM。NFM和AFM都是针对Wide&amp;amp;Deep 中Deep部分的改造。上一章PNN用到了向量内积外积来提取特征交互信息，总共向量乘积就这几种，这不NFM</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/gogoSandy/p/12814804.html</dc:identifier>
</item>
</channel>
</rss>