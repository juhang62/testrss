<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>海关 实时数据  企业联调接口 开发步骤与概要 - 风浪</title>
<link>http://www.cnblogs.com/whtydn/p/10220209.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/whtydn/p/10220209.html</guid>
<description>&lt;p&gt;写这个文章前， 先呐喊几声， 一吐心中不快， 诺大的中国海关， 连个指导都没有， 写的文档与demo， 100个人有99.9个人不懂， 还有0.1个人一次能懂的都算是神童， &lt;/p&gt;

&lt;p&gt;首先， 中国海关数据中心， 经过这个接口的实现， 我感觉到政府的技术落后，不要说芯片， 就连最简单的1+1=2的程序在政府部门都写复杂又困难， 主要还没写一个使用的文档，&lt;/p&gt;

&lt;p&gt;如果中国找不到这样的人， 如果有人认得中国海关署长的， 就帮我推荐一下， 可能我技术不算顶峰高手， 但写个文档或指导教程， 绝对能让50%的人一次性看得明白。 诺大的中国海关数据中心， 连个技术指导都请不起， 可怜呀， 钱都哪去了？&lt;/p&gt;

&lt;p&gt;如果能骂人的， 我接着写， 不过还是提介文明， 就不吐了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;正题啦:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一步：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;看二个公告&lt;/p&gt;
&lt;p&gt;http://www.customs.gov.cn/customs/302249/302266/302267/2134975/index.html 165号&lt;/p&gt;
&lt;p&gt;http://www.customs.gov.cn/customs/302249/302266/302267/2155884/index.html 179号&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第二步：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下载179号公告文档， 文档包括下面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/47708/201901/47708-20190104144945914-674893022.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第三步：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;打开“海关跨境电商进口版统一信息化系统平台数据实时获取接口（试行）”， 请看1.6.1.1 这里得知， 需要写一个接口， 让海关请求带三个参数OrderNo， sessionID，serviceTime，  把这三个参数存放起来，  可以是消息队列， 可以是数据库， 总之你能再次找得到就行。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第四步： &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;既然在第三步接收到海关请求的内容也存放起来了， 总得处理并把他们想要的数据返回给海关， 这里就介绍怎得到需要返回的数据， 最关键的一步， 请看1.6.2.2， 订单，商品，支付这些数据， 可能通过OrderNo在你们电商平台得到， 最麻烦的就是CertNo, signValue这二个参数，&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;官方文档把最维得到的参数用123来代替， 我感觉到无奈。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;4.1 得去公司找到一个海关登录的IC卡，有一个读卡器， 一般有二个卡（法人卡，操作员卡），记得把操作员卡接到读卡器里， 不能是法人卡，这个十分注意。&lt;/p&gt;
&lt;p&gt;4.2 下载海关控件安装包， 打开这个网址 http://ceb1.chinaport.gov.cn/  ， 点 跨境电商进口版， 认真查找“首次登录 需要下载控件”， 点击下载 EportClientSetup_V1.5.5.exe， 请看清楚下载的文件名是不是这个， 这也是十分重要， 如果你千百次对比没错后， 请安装它， 安装完成电脑屏幕右下角会有一个控件启动提醒， 桌面也有一个快捷方式“中国电子口岸客户端控件 重新启动”。 &lt;/p&gt;
&lt;p&gt;4.3 把4.1步里面找到的读卡器接上电脑， 记得这个电脑要安装了海关控件的， 千万不要搞成， A电脑装了控件， 把这读卡器接B电脑上。 如果读卡器出现绿灯， 说明读卡器与卡都没问题， 如果是灯不亮或红灯， 不好意思， 你的卡与读卡器可能有问题了，得找另一个卡与读卡器再试。&lt;/p&gt;
&lt;p&gt;4.4 当环境设置好了， 就需要取CertNo， 证书这些， 下载这个读取编号与证书的工具： https://pan.baidu.com/s/1xo0AcZZ4QZDeAu2DHOEQjg   提取码: cfpp ， 解压打开SignTool.exe&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/47708/201901/47708-20190104150831051-875962203.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击步骤：打开卡, 如果出现打开卡成功， 恭喜你， 又前进一步，在验证口令后面的文本框输入设置的密码， 这个密码得问一下你们公司掌管卡的人，如果录入后点击 验证口令 提示 验证口令成功， 又恭喜你前进一步， 点击“获取证书”， 成功的会得到后面文本框里的一串文字， 注意这个文字好长好长， 得小心从文本框里最上方拉到最下方， 很多人没拉到底， 造成证书错误， 当你选择全部后复制出来， &lt;span&gt;用记事本原封不动的保存， 改后缀名为.cer&lt;/span&gt;， 这样就成他们口中所说的证书了， 再点击证书序列号，会得到一个证书编号。&lt;/p&gt;

&lt;p&gt;发给海关的丁鑫， 并登记企业名称， 企业联系人等信息， 总之找他就行了， 怎找呢， 看文章最后一个图。&lt;/p&gt;

&lt;p&gt;到这里， 只差一个signValue这个千奇百怪的东西了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第五步：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;誓取signValue这个海关奇怪设计失败货， 一千种方法都可以简单得到， 他们设计出一个最麻烦最不稳定的取得方法， 真的拿他们没办法， 满脸的无奈。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;5.1 首先你要看那个&quot;海关跨境电商进口版统一信息化系统平台数据实时获取接口（试行）&quot;文档， 通过OrderNo把你订单信息，商品信息，支付信息拼成这样的Json， 你也可以用这个来测试， 测试通了， 再取订单来拼接， 如果后面发送得到数据格式有误， 你就得一个字符一个字符的去对， 是否一模一样。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sessionID&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fe2374-8fnejf97-55616242&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;||&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;payExchangeInfoHead&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;guid&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;9D55BA71-55DE-41F4-8B50-C36C83B3B419&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;initalRequest&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;openapi.alipay.com/gateway.do?timestamp=2013-01-0108:08:08&amp;amp;method=alipay.trade.pay&amp;amp;app_id=13580&amp;amp;sign_type=RSA2&amp;amp;sign=ERITJKEIJKJHKKKKKKKHJEREEEEEEEEEEE&amp;amp;version=1.0&amp;amp;charset=GBK&quot;,&quot;initalResponse&quot;:&quot;ok&quot;,&quot;ebpCode&quot;:&quot;3301963K69&quot;,&quot;payCode&quot;:&quot;312226T001&quot;,&quot;payTransactionId&quot;:&quot;2018121222001354081010726129&quot;,&quot;totalAmount&quot;:100,&quot;currency&quot;:&quot;142&quot;,&quot;verDept&quot;:&quot;3&quot;,&quot;payType&quot;:&quot;1&quot;,&quot;tradingTime&quot;:&quot;20181212041803&quot;,&quot;note&quot;:&quot;批量订单，测试订单优化,生成多个so订单&quot;}&quot;||&quot;payExchangeInfoLists&quot;:&quot;[{&quot;orderNo&quot;:&quot;SO1710301150602574003&quot;,&quot;goodsInfo&quot;:[{&quot;gname&quot;:&quot;lhy-gnsku3&quot;,&quot;itemLink&quot;:&quot;&lt;/span&gt;&lt;span&gt;http://m.yunjiweidian.com/yunjibuyer/static/vue-buyer/idc/index.html&lt;/span&gt;&lt;span&gt;#/detail?itemId=999761&amp;amp;shopId=453&quot;},{&quot;gname&quot;:&quot;lhy-gnsku2&quot;,&quot;itemLink&quot;:&quot;&lt;/span&gt;&lt;span&gt;http://m.yunjiweidian.com/yunjibuyer/static/vue-buyer/idc/index.html&lt;/span&gt;&lt;span&gt;#/detail?itemId=999760&amp;amp;shopId=453&quot;}],&quot;recpAccount&quot;:&quot;OSA571908863132601&quot;,&quot;recpCode&quot;:&quot;&quot;,&quot;recpName&quot;:&quot;YUNJIHONGKONGLIMITED&quot;}]&quot;||&quot;serviceTime&quot;:&quot;1544519952469&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;得到了这段拼接字符， 就是为了得到signValue， 所以一个字符也不能出错， 不然取不到正确的加签返回值。&lt;/p&gt;

&lt;p&gt;5.2 这里最主要的就是通过websocket取得加签结果&lt;/p&gt;
&lt;p&gt;我这里写的是C#版的， Java版的我是向&lt;strong&gt;&lt;span&gt;天虹张大工程师&lt;/span&gt;&lt;/strong&gt;那得到的，在这里十分感谢天虹张， 希望大家能多去天虹商场逛逛， 并感谢他们员工的大无畏精神， 和中国海关对比， 真的是像&lt;span&gt;&lt;strong&gt;天虹浩月对中国海关的萤火&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;Java 天虹张工版下载地址: https://pan.baidu.com/s/1beifsbtA7fXmi4vJ3c2Kjw 提取码: jdev    [不知我放在这里， 天虹张工会不会介意， 如果不同意的我删掉]，  为了各电商平台能快速完成，先对张工说十分抱歉，。&lt;/p&gt;

&lt;p&gt;记得一个前提， &lt;span&gt;websocket的地址就是你装有控件，插有卡的那个电脑的IP地址&lt;/span&gt;， 例如：ws://127.0.0.1:61232， 这是我在开发时， 在我自己的电脑上装有控件插有卡， 得来的websocket地址。&lt;/p&gt;

&lt;p&gt;C# 版， 现在大家多用win7， win7不支持ClientWebSocket， 所以我使用了第三方包，WebSocket4Net， 在VS2015 NuGet上面直接安装， 最终写出最简单的明了取得加签返回值&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;57&quot;&gt;&lt;img id=&quot;code_img_closed_7584465d-a85c-46df-8975-e5b18d5ac5bd&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_7584465d-a85c-46df-8975-e5b18d5ac5bd&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_7584465d-a85c-46df-8975-e5b18d5ac5bd&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;109&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; WebSocket4Net;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; SuperSocket.ClientEngine;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; ConsoleApp
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; WebSocket websocket = &lt;span&gt;new&lt;/span&gt; WebSocket(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ws://127.0.0.1:61232&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {                
                websocket.Opened &lt;/span&gt;+= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EventHandler(websocket_Opened);
                websocket.Error &lt;/span&gt;+= &lt;span&gt;new&lt;/span&gt; EventHandler&amp;lt;ErrorEventArgs&amp;gt;&lt;span&gt;(websocket_Error);
                websocket.Closed &lt;/span&gt;+= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EventHandler(websocket_Closed);
                websocket.MessageReceived &lt;/span&gt;+= &lt;span&gt;new&lt;/span&gt; EventHandler&amp;lt;MessageReceivedEventArgs&amp;gt;&lt;span&gt;(websocket_MessageReceived);
                websocket.Open();                

                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
            {
                Console.WriteLine(ex.Message);
            }

            Console.ReadLine();
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; websocket_Opened(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e)
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;websocket opened!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; DateTime.Now.ToString());
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; websocket_Error(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, ErrorEventArgs e)
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;websocket error!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Error:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; e.Exception.Message.ToString());
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; websocket_Closed(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e)
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;websocket closed!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; DateTime.Now.ToString());
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; websocket_MessageReceived(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, MessageReceivedEventArgs e)
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;websocket message received!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; strMessaged =&lt;span&gt; e.Message.ToString().Trim();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (strMessaged.Contains(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;握手成功&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
            {
                StringBuilder PostJson &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuilder();
                PostJson.Append(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\&quot;sessionID\&quot;:\&quot;fe2374-8fnejf97-55616242\&quot;||\&quot;payExchangeInfoHead\&quot;:\&quot;{\&quot;guid\&quot;:\&quot;9D55BA71-55DE-41F4-8B50-C36C83B3B419\&quot;,\&quot;initalRequest\&quot;:\&quot;https://openapi.alipay.com/gateway.do?timestamp=2013-01-0108:08:08&amp;amp;method=alipay.trade.pay&amp;amp;app_id=13580&amp;amp;sign_type=RSA2&amp;amp;sign=ERITJKEIJKJHKKKKKKKHJEREEEEEEEEEEE&amp;amp;version=1.0&amp;amp;charset=GBK\&quot;,\&quot;initalResponse\&quot;:\&quot;ok\&quot;,\&quot;ebpCode\&quot;:\&quot;3301963K69\&quot;,\&quot;payCode\&quot;:\&quot;312226T001\&quot;,\&quot;payTransactionId\&quot;:\&quot;2018121222001354081010726129\&quot;,\&quot;totalAmount\&quot;:100,\&quot;currency\&quot;:\&quot;142\&quot;,\&quot;verDept\&quot;:\&quot;3\&quot;,\&quot;payType\&quot;:\&quot;1\&quot;,\&quot;tradingTime\&quot;:\&quot;20181212041803\&quot;,\&quot;note\&quot;:\&quot;批量订单，测试订单优化,生成多个so订单\&quot;}\&quot;||\&quot;payExchangeInfoLists\&quot;:\&quot;[{\&quot;orderNo\&quot;:\&quot;SO1710301150602574003\&quot;,\&quot;goodsInfo\&quot;:[{\&quot;gname\&quot;:\&quot;lhy-gnsku3\&quot;,\&quot;itemLink\&quot;:\&quot;http://m.yunjiweidian.com/yunjibuyer/static/vue-buyer/idc/index.html#/detail?itemId=999761&amp;amp;shopId=453\&quot;},{\&quot;gname\&quot;:\&quot;lhy-gnsku2\&quot;,\&quot;itemLink\&quot;:\&quot;http://m.yunjiweidian.com/yunjibuyer/static/vue-buyer/idc/index.html#/detail?itemId=999760&amp;amp;shopId=453\&quot;}],\&quot;recpAccount\&quot;:\&quot;OSA571908863132601\&quot;,\&quot;recpCode\&quot;:\&quot;\&quot;,\&quot;recpName\&quot;:\&quot;YUNJIHONGKONGLIMITED\&quot;}]\&quot;||\&quot;serviceTime\&quot;:\&quot;1544519952469\&quot;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; strJson =&lt;span&gt; PostJson.ToString();

                &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; strSendData0 = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{\&quot;_method\&quot;:\&quot;cus-sec_SpcSignDataAsPEM\&quot;,\&quot;_id\&quot;:1,\&quot;args\&quot;:{\&quot;inData\&quot;:\&quot;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + strJson.Replace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\&quot;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\\\&quot;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\&quot;,\&quot;passwd\&quot;:\&quot;66666666\&quot;}}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;string strSendData1 = &quot;{\&quot;_method\&quot;:\&quot;cus-sec_SpcSignDataAsPEM\&quot;,\&quot;_id\&quot;:1,\&quot;args\&quot;:{\&quot;inData\&quot;:\&quot;\\\&quot;sessionID\\\&quot;:\\\&quot;1dd44ea3-202a-43e7-87a5-6d82ca3fce4f\\\&quot;||\\\&quot;payExchangeInfoHead\\\&quot;:\\\&quot;{\\\&quot;guid\\\&quot;:\\\&quot;9D55BA71-55DE-41F4-8B50-C36C83B3B419\\\&quot;,\\\&quot;initalRequest\\\&quot;:\\\&quot;&lt;/span&gt;&lt;span&gt;https://openapi.alipay.com/gateway.do?timestamp=2013-01-0108&lt;/span&gt;&lt;span&gt;:08:08&amp;amp;method=alipay.trade.pay&amp;amp;app_id=13580&amp;amp;sign_type=RSA2&amp;amp;sign=ERITJKEIJKJHKKKKKKKHJEREEEEEEEEEEE&amp;amp;version=1.0&amp;amp;charset=GBK\\\&quot;,\\\&quot;initalResponse\\\&quot;:\\\&quot;ok\\\&quot;,\\\&quot;ebpCode\\\&quot;:\\\&quot;xxxxxxxx\\\&quot;,\\\&quot;payCode\\\&quot;:\\\&quot;312226T001\\\&quot;,\\\&quot;payTransactionId\\\&quot;:\\\&quot;2018121222001354081010726129\\\&quot;,\\\&quot;totalAmount\\\&quot;:100,\\\&quot;currency\\\&quot;:\\\&quot;142\\\&quot;,\\\&quot;verDept\\\&quot;:\\\&quot;3\\\&quot;,\\\&quot;payType\\\&quot;:\\\&quot;1\\\&quot;,\\\&quot;tradingTime\\\&quot;:\\\&quot;20181212041803\\\&quot;,\\\&quot;note\\\&quot;:\\\&quot;批量订单，测试订单优化,生成多个so订单\\\&quot;}\\\&quot;||\\\&quot;payExchangeInfoLists\\\&quot;:\\\&quot;[{\\\&quot;orderNo\\\&quot;:\\\&quot;SO1710301150602574003\\\&quot;,\\\&quot;goodsInfo\\\&quot;:[{\\\&quot;gname\\\&quot;:\\\&quot;lhy-gnsku3\\\&quot;,\\\&quot;itemLink\\\&quot;:\\\&quot;&lt;/span&gt;&lt;span&gt;http://m.yunjiweidian.com/yunjibuyer/static/vue-buyer/idc/index.html&lt;/span&gt;&lt;span&gt;#/detail?itemId=999761&amp;amp;shopId=453\\\&quot;},{\\\&quot;gname\\\&quot;:\\\&quot;lhy-gnsku2\\\&quot;,\\\&quot;itemLink\\\&quot;:\\\&quot;&lt;/span&gt;&lt;span&gt;http://m.yunjiweidian.com/yunjibuyer/static/vue-buyer/idc/index.html&lt;/span&gt;&lt;span&gt;#/detail?itemId=999760&amp;amp;shopId=453\\\&quot;}],\\\&quot;recpAccount\\\&quot;:\\\&quot;OSA571908863132601\\\&quot;,\\\&quot;recpCode\\\&quot;:\\\&quot;\\\&quot;,\\\&quot;recpName\\\&quot;:\\\&quot;YUNJIHONGKONGLIMITED\\\&quot;}]\\\&quot;||\\\&quot;serviceTime\\\&quot;:\\\&quot;1544519952469\\\&quot;\&quot;,\&quot;passwd\&quot;:\&quot;66666666\&quot;}}&quot;;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;string strSendData2 = &quot;&quot;;
                
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Console.WriteLine(strSendData0);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Console.WriteLine(&quot;------------------------------------------&quot;);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Console.WriteLine(strSendData1);&lt;/span&gt;
&lt;span&gt;                websocket.Send(strSendData0);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                Console.WriteLine(strMessaged);
            }
            websocket.Close();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;得到的返回值是如图，data就是加签的signValue， 起快把奇怪货关起来， 我在海关微信群里面， 无数工程师为了得到这个， 花上好几天还没有头绪。 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/47708/201901/47708-20190104154311292-411730264.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;用其它语言来写也行的， 只是要把websocket send的内容改为json,  但发送的内容得一模一样， 这段是张工发给我的发送给websocket加签的内容。 看清楚必须格式一模一样， 提示\\\sessionID\\\， 看清楚这个。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{\&quot;_method\&quot;:\&quot;cus-sec_SpcSignDataAsPEM\&quot;,\&quot;_id\&quot;:1,\&quot;args\&quot;:{\&quot;inData\&quot;:\&quot;\\\&quot;sessionID\\\&quot;:\\\&quot;1dd44ea3-202a-43e7-87a5-6d82ca3fce4f\\\&quot;||\\\&quot;payExchangeInfoHead\\\&quot;:\\\&quot;{\\\&quot;guid\\\&quot;:\\\&quot;9D55BA71-55DE-41F4-8B50-C36C83B3B419\\\&quot;,\\\&quot;initalRequest\\\&quot;:\\\&quot;https://openapi.alipay.com/gateway.do?timestamp=2013-01-0108:08:08&amp;amp;method=alipay.trade.pay&amp;amp;app_id=13580&amp;amp;sign_type=RSA2&amp;amp;sign=ERITJKEIJKJHKKKKKKKHJEREEEEEEEEEEE&amp;amp;version=1.0&amp;amp;charset=GBK\\\&quot;,\\\&quot;initalResponse\\\&quot;:\\\&quot;ok\\\&quot;,\\\&quot;ebpCode\\\&quot;:\\\&quot;xxxxxxxx\\\&quot;,\\\&quot;payCode\\\&quot;:\\\&quot;312226T001\\\&quot;,\\\&quot;payTransactionId\\\&quot;:\\\&quot;2018121222001354081010726129\\\&quot;,\\\&quot;totalAmount\\\&quot;:100,\\\&quot;currency\\\&quot;:\\\&quot;142\\\&quot;,\\\&quot;verDept\\\&quot;:\\\&quot;3\\\&quot;,\\\&quot;payType\\\&quot;:\\\&quot;1\\\&quot;,\\\&quot;tradingTime\\\&quot;:\\\&quot;20181212041803\\\&quot;,\\\&quot;note\\\&quot;:\\\&quot;批量订单，测试订单优化,生成多个so订单\\\&quot;}\\\&quot;||\\\&quot;payExchangeInfoLists\\\&quot;:\\\&quot;[{\\\&quot;orderNo\\\&quot;:\\\&quot;SO1710301150602574003\\\&quot;,\\\&quot;goodsInfo\\\&quot;:[{\\\&quot;gname\\\&quot;:\\\&quot;lhy-gnsku3\\\&quot;,\\\&quot;itemLink\\\&quot;:\\\&quot;http://m.yunjiweidian.com/yunjibuyer/static/vue-buyer/idc/index.html#/detail?itemId=999761&amp;amp;shopId=453\\\&quot;},{\\\&quot;gname\\\&quot;:\\\&quot;lhy-gnsku2\\\&quot;,\\\&quot;itemLink\\\&quot;:\\\&quot;http://m.yunjiweidian.com/yunjibuyer/static/vue-buyer/idc/index.html#/detail?itemId=999760&amp;amp;shopId=453\\\&quot;}],\\\&quot;recpAccount\\\&quot;:\\\&quot;OSA571908863132601\\\&quot;,\\\&quot;recpCode\\\&quot;:\\\&quot;\\\&quot;,\\\&quot;recpName\\\&quot;:\\\&quot;YUNJIHONGKONGLIMITED\\\&quot;}]\\\&quot;||\\\&quot;serviceTime\\\&quot;:\\\&quot;1544519952469\\\&quot;\&quot;,\&quot;passwd\&quot;:\&quot;11111111\&quot;}}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这里取得了加签的内容， 就可以拼凑成返回海关的报文。 记得这里只是拼接报文成功， 你还得联系海关二位员工， 张丁二将， 把上面4.4得到的证书与编号发给他们， 然后请他们帮助你设置海关测试环境。 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/47708/201901/47708-20190104152943785-623231546.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;最后说一下， 本人2003年中山大学毕业， 经过无数次亿万级的系统开发与构架，像香港证券交易， 香港电讯短信通道这些平台， 每秒都是几百几千请求，  面对这小小的不成文不成档的奇怪接口， 也曾发火几次， 希望这文章对大家有用！&lt;/p&gt;

&lt;p&gt;同时也建议， 各位开发工程师， 如果自己有接口对外的， &lt;span&gt;希望能认真写写详细的文档，&lt;/span&gt; 因为自己做的东西可以感觉很简单， 外人看来还是有复杂度的， 像这样接口， 明明涉及硬件软件， 他文档里一句不提， 最重要的signvalue得来， 居然没详细的方法， 直接用123来代替， 真的是只有中国政府才能做出这么伟大的事业， 万望各位开发工程师引以为介， 从大家做起， 不要让简单的事复杂起来。 &lt;/p&gt;

</description>
<pubDate>Fri, 04 Jan 2019 07:38:00 +0000</pubDate>
<dc:creator>风浪</dc:creator>
<og:description>写这个文章前， 先呐喊几声， 一吐心中不快， 诺大的中国海关， 连个指导都没有， 写的文档与demo， 100个人有99.9个人不懂， 还有0.1个人一次能懂的都算是神童， 首先， 中国海关数据中心，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/whtydn/p/10220209.html</dc:identifier>
</item>
<item>
<title>Python-爬虫03：urllib.request模块的使用 - Bricker666</title>
<link>http://www.cnblogs.com/haochen273/p/10220154.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/haochen273/p/10220154.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;hr/&gt;
&lt;hr/&gt;&lt;p&gt;所谓网页抓取，就是把URL地址中指定的网络资源从网络流中抓取出来。在Python中有很多库可以用来抓取网页，我们先学习urllib.request。&lt;/p&gt;
&lt;p&gt;Python模块源代码： &lt;code&gt;C:\Users\haoch\Anaconda3\Lib&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;urllib.request源代码:&lt;code&gt;C:\Users\haoch\Anaconda3\Lib\urllib\request.py&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;urlopen&quot;&gt;1.1 urlopen&lt;/h2&gt;
&lt;p&gt;我们先来看源代码&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# data没写-&amp;gt; get请求，否则是Post请求 
def urlopen(url, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
            *, cafile=None, capath=None, cadefault=False, context=None):

    global _opener
    if cafile or capath or cadefault:
        import warnings
        warnings.warn(&quot;cafile, cpath and cadefault are deprecated, use a &quot;
                      &quot;custom context instead.&quot;, DeprecationWarning, 2)
        if context is not None:
            raise ValueError(
                &quot;You can't pass both context and any of cafile, capath, and &quot;
                &quot;cadefault&quot;
            )
        if not _have_ssl:
            raise ValueError('SSL support not available')
            # 知识点1： 做SSL认证
        context = ssl.create_default_context(ssl.Purpose.SERVER_AUTH,
                                             cafile=cafile,
                                             capath=capath)
        # 知识点2： 通过HTTPS处理器创建处理器对象                                  
        https_handler = HTTPSHandler(context=context)
        # 知识点3： 将处理器对象包进去
        opener = build_opener(https_handler)
    elif context:
        https_handler = HTTPSHandler(context=context)
        opener = build_opener(https_handler)
    elif _opener is None:
        _opener = opener = build_opener()
    else:
        opener = _opener
        # 知识点4： 自定义的open方法
    return opener.open(url, data, timeout)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;用urlopen来获取网络源代码&quot;&gt;1.2. 用urlopen来获取网络源代码&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 导入urllib2 库
import urllib.request
# 向指定的url发送请求，并返回服务器响应的类文件对象
response = urllib.request.urlopen(&quot;http://www.baidu.com/&quot;)
# 类文件对象支持 文件对象的操作方法，如read()方法读取文件全部内容，返回字符串
html = response.read()
print(html)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;实际上，如果我们在浏览器上打开百度主页， 右键选择“查看源代码”，你会发现，跟我们刚才打印出来的是一模一样。也就是说，上面的4行代码就已经帮我们把百度的首页的全部代码爬了下来。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;urllib.request.request的使用&quot;&gt;1.3. urllib.request.Request的使用&lt;/h2&gt;
&lt;p&gt;如果需要执行更复杂的操作，比如增加HTTP报头，必须创建一个 Request 实例来作为urlopen()的参数；而需要访问的url地址则作为 Request 实例的参数。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import urllib.request
# url 作为Request()方法的参数，构造并返回一个Request对象
request = urllib.request.Request(&quot;http://www.baidu.com&quot;)
# Request对象作为urlopen()方法的参数，发送给服务器并接收响应
response = urllib.request.urlopen(request)
html = response.read()
print html&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不加user-agent-请求信息&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1575244/201901/1575244-20190104153118982-584661108.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;GET http://www.baidu.com/ HTTP/1.1
Accept-Encoding: identity
Host: www.baidu.com
User-Agent: Python-urllib/3.7
Connection: close&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;
&lt;hr/&gt;&lt;p&gt;上面的例子中有一个最大缺点是不能给请求添加head，不能更改User-Agent的默认值，那么urlopen中User-Agent的值是什么呢，让我们来看源代码&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class OpenerDirector:
    def __init__(self):
       # __version__ = '%d.%d' % sys.version_info[:2]---&amp;gt;sys.version[:3] = 3.7
        client_version = &quot;Python-urllib/%s&quot; % __version__
        # client_version = Python-urllib 3.7
        self.addheaders = [('User-agent', client_version)]
        # self.handlers is retained only for backward compatibility
        self.handlers = []
        # manage the individual handlers
        self.handle_open = {}
        self.handle_error = {}
        self.process_response = {}
        self.process_request = {}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;urllib2默认的 &lt;code&gt;User-Agent:Python-urllib 3.7&lt;/code&gt;，被管理员看到后，容易被封IP，应该重构我们的User-Agent&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;为什么要用user-agent&quot;&gt;2.1) 为什么要用User-Agent?&lt;/h2&gt;
&lt;p&gt;我们用一个合法的身份去请求别人网站，显然人家就是欢迎的，所以我们就应该给我们的这个代码加上一个身份，就是所谓的User-Agent头。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;浏览器 就是互联网世界上公认被允许的身份，如果我们希望我们的爬虫程序更像一个真实用户，那我们第一步就是需要伪装成一个被浏览器。用不同的浏览器在发送请求的时候，会有不同的 User-Agent 报头。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;urllib.request默认的User-Agent头为：Python-urllib/x.y （x和y 是Python 主.次 版本号，例如 Python-urllib/3.7）&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;如何添加user-agent信息到请求中去&quot;&gt;2.2) 如何添加User-Agent信息到请求中去？&lt;/h2&gt;
&lt;p&gt;首先我们用抓包工具抓取请求，在其中获取User-Agent的值&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1575244/201901/1575244-20190104153020328-2085336643.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;GET https://www.baidu.com/ HTTP/1.1
Host: www.baidu.com
Connection: keep-alive
Pragma: no-cache
Cache-Control: no-cache
Upgrade-Insecure-Requests: 1

# User-Agent 最重要的东西，必须写的东西
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36

# 获取的数据类型
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8
# 压缩方式（一定不能写的，麻烦）
Accept-Encoding: gzip, deflate, br
Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7,en-CA;q=0.6
Cookie: BAIDUID=4F583A04A0193EBE0C9849C551B9305C:FG=1; BIDUPSID=4F583A04A0193EBE0C9849C551B9305C; PSTM=1545978093; BD_UPN=12314753; BDORZ=B490B5EBF6F3CD402E515D22BCDA1598; __cfduid=d7aafabcd6ccc970c2d47e9e205fc3c851546334654; cflag=13%3A3; delPer=0; BD_HOME=0; H_PS_PSSID=1440_21082_28205_28132_27245_27509
x-hd-token: rent-your-own-vps&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们只需要复制User-Agent的值即可，代码如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# IE 9.0 的 User-Agent，包含在 user_agent里
ua_headers = {&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36&quot;}
#  url 连同 headers，一起构造Request请求，这个请求将附带 IE9.0 浏览器的User-Agent
request = urllib.request.Request(&quot;http://www.baidu.com&quot;, headers = ua_headers)
# 向服务器发送这个请求
response = urllib.request.urlopen(request)
html = response.read()
html&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;加user-agent-请求信息&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1575244/201901/1575244-20190104153133923-1663283729.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;GET http://www.baidu.com/ HTTP/1.1
Accept-Encoding: identity
Host: www.baidu.com
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36
Connection: close&lt;/code&gt;
&lt;/pre&gt;

&lt;ul&gt;&lt;li&gt;&lt;strong&gt;添加一个特定的header&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import urllib2

url = &quot;http://www.itcast.cn&quot;
#IE 9.0 的 User-Agent
user_agent = {&quot;User-Agent&quot; : &quot;Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0)&quot;} 
request = urllib2.Request(url, headers = user_agent)
#也可以通过调用Request.add_header() 添加/修改一个特定的header
request.add_header(&quot;Connection&quot;, &quot;keep-alive&quot;)
# 也可以通过调用Request.get_header()来查看header信息
# request.get_header(header_name=&quot;Connection&quot;)
response = urllib2.urlopen(request)
print response.code     #可以查看响应状态码
html = response.read()
print html&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;随机添加/修改User-Agent&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import urllib2
import random

url = &quot;http://www.itcast.cn&quot;

ua_list = [
    &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/22.0.1207.1 Safari/537.1&quot;,
    &quot;Mozilla/5.0 (X11; CrOS i686 2268.111.0) AppleWebKit/536.11 (KHTML, like Gecko) Chrome/20.0.1132.57 Safari/536.11&quot;,
    &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6&quot;,
    &quot;Mozilla/5.0 (Windows NT 6.1) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1090.0 Safari/536.6&quot;
]

user_agent = random.choice(ua_list)
request = urllib2.Request(url)
#也可以通过调用Request.add_header() 添加/修改一个特定的header
request.add_header(&quot;User-Agent&quot;, user_agent)
# get_header()的字符串参数，第一个字母大写，后面的全部小写
request.get_header(&quot;User-agent&quot;)
response = urllib2.urlopen(request)
html = response.read()
print html&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;response的其他用法&quot;&gt;1.5. Response的其他用法&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;response.read()     # 读取爬取的内容
response.getcode()  # 返回HTTP的响应码，                       200=OK
response.geturl()   # 返回数据的是具体哪个URL， 防止重定向      'http://www.baidu.com'
response.info()     # 返回服务器响应的抱头信息&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 04 Jan 2019 07:32:00 +0000</pubDate>
<dc:creator>Bricker666</dc:creator>
<og:description>[TOC] 1. urllib.request的基本使用 所谓网页抓取，就是把URL地址中指定的网络资源从网络流中抓取出来。在Python中有很多库可以用来抓取网页，我们先学习urllib.reque</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/haochen273/p/10220154.html</dc:identifier>
</item>
<item>
<title>flask中的蓝图实现模块化的应用 - 泓一似一泓清泉</title>
<link>http://www.cnblogs.com/hongyizhang/p/10220111.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hongyizhang/p/10220111.html</guid>
<description>

&lt;p&gt;&lt;span&gt;&lt;strong&gt;Blueprint&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　　　蓝图的基本设想是当它们注册到应用上时，它们记录将会被执行的操作。 当分派请求和生成从一个端点到另一个的 URL 时，Flask 会关联蓝图中的视图函数。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　简单来说，Blueprint 是一个存储操作方法的容器，这些操作在这个Blueprint 被注册到一个应用之后就 可以被调用，Flask 可以通过Blueprint来组织URL以及处理请求。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一.蓝图的简介。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Flask 用 蓝图（blueprints） 的概念来在一个应用中或跨应用制作应用组件和支持通用的模式。蓝图很好地简化了大型应用工作的方式，并提供给 Flask 扩展在应用上注册操作的核心方法。一个 Blueprint 对象与 Flask 应用对象的工作方式很像，但它确实不是一个应用，而是一个描述如何构建或扩展应用的 蓝图 。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;二.蓝图的使用场景。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　①把一个应用分解为一个蓝图的集合。适合大型应用，一个项目可以实例化一个应用对象，初始化几个扩展，并注册一集合的蓝图。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　②以 URL 前缀和/或子域名，在应用上注册一个蓝图。 URL 前缀/子域名中的参数即成为这个蓝图下的所有视图函数的共同的视图参数（默认情况下）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　③在一个应用中用不同的 URL 规则多次注册一个蓝图。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　④一个蓝图不一定要实现应用或者视图函数，还可通过蓝图提供模板过滤器、静态文件、模板和其它功能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　注：蓝图缺点，不能在应用创建后撤销注册一个蓝图而不销毁整个应用对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;三.蓝图实现模块化。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　蓝图/Blueprint对象用起来和一个应用/Flask对象差不多，最大的区别在于一个 蓝图对象没有办法独立运 行，必须将它注册到一个应用对象上才能生效。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　使用蓝图可以分为三个步骤&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　1,创建一个蓝图对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　admin=Blueprint('admin',__name__)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　2,在这个蓝图对象上进行操作,注册路由,指定静态文件夹,注册模版过滤器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　@admin.route('/')&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　def admin_home():&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　return 'admin_home'&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　3,在应用对象上注册这个蓝图对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　app.register_blueprint(admin,url\_prefix='/admin')&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　&lt;strong&gt;当这个应用启动后,通过/admin/可以访问到蓝图中定义的视图函数&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;四.运行机制。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　①蓝图是保存了一组将来可以在应用对象上执行的操作，注册路由就是一种操作　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　    ②当在应用对象上调用 route 装饰器注册路由时,这个操作将修改对象的url_map路由表 然而，蓝图对象根本没有路由表，当我们在蓝图对象上调用route装饰器注册路由时,它只是在内部 的一个延迟操作记录列表defered_functions中添加了一个项&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　     ③ 当执行应用对象的 register_blueprint() 方法时，应用对象将从蓝图对象的 defered_functions 列表中 取出每一项，并以自身作为参数执行该匿名函数，即调用应用对象的 add_url_rule() 方法，这将真 正的修改应用对象的路由表&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;五.蓝图的url前缀。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　①当我们在应用对象上注册一个蓝图时，可以指定一个url_prefix关键字参数（这个参数默认是/）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　②在应用最终的路由表 url_map中，在蓝图上注册的路由URL自动被加上了这个前缀，这个可以保证 在多个蓝图中使用相同的URL规则而不会最终引起冲突，只要在注册蓝图时将不同的蓝图挂接到 不同的自路径即可&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　例如：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  　　　　     #创建蓝图对象&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　&lt;strong&gt;passport_blu = Blueprint(&quot;passport&quot;,__name__,url_prefix=&quot;/passport&quot;)&lt;/strong&gt;#之后在使用passport_blu这个路由的url前面都会加上/passport这个前缀&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;六.注册静态路由。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　和应用对象不同，蓝图对象创建时不会默认注册静态目录的路由。需要我们在 创建时指定 static_folder 参数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　下面的示例将蓝图所在目录下的static_admin目录设置为静态目录&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;strong&gt;admin = Blueprint(&quot;admin&quot;,__name__,static_folder='static_admin')&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　　　app.register_blueprint(admin,url_prefix='/admin')&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　　　&lt;/strong&gt;现在就可以使用/admin/static_admin/ 访问static_admin目录下的静态文件了 定制静态目录URL规则 ：可 以在创建蓝图对象时使用 static_url_path 来改变静态目录的路由。下面的示例将为 static_admin 文件夹 的路由设置为 /lib&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;strong&gt;admin = Blueprint(&quot;admin&quot;,__name__,static_folder='static_admin',static_url_path='/l ib')&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　　　app.register_blueprint(admin,url_prefix='/admin')&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;七.设置模版目录&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　蓝图对象默认的模板目录为系统的模版目录，可以在创建蓝图对象时使用 template_folder 关键字参数 设置模板目录&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　admin = Blueprint('admin',__name__,template_folder='my_templates')&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;strong&gt;注：如果在 templates 中存在和 my_templates 同名文件,则系统会优先使用 templates 中的文件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;












</description>
<pubDate>Fri, 04 Jan 2019 07:28:00 +0000</pubDate>
<dc:creator>泓一似一泓清泉</dc:creator>
<og:description>Blueprint 蓝图的基本设想是当它们注册到应用上时，它们记录将会被执行的操作。 当分派请求和生成从一个端点到另一个的 URL 时，Flask 会关联蓝图中的视图函数。 简单来说，Blueprin</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hongyizhang/p/10220111.html</dc:identifier>
</item>
<item>
<title>技术年货：美团技术沙龙合辑大放送——85个演讲，70+小时视频 - 美团技术团队</title>
<link>http://www.cnblogs.com/meituantech/p/10220081.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/meituantech/p/10220081.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://tech.meituan.com/img/jishushalong/01.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;你好，2019&lt;/p&gt;
&lt;p&gt;再见，2018&lt;/p&gt;
&lt;p&gt;又到了一年辞旧迎新的时候，大家应该也和美美一样，在忙着总结回顾和展望规划吧。&lt;/p&gt;
&lt;p&gt;按老惯例，我们该献上技术年货了。今年首先出场的，是我们的技术沙龙大套餐！&lt;/p&gt;
&lt;p&gt;美团技术沙龙是由美团技术团队和美团科协主办的线下技术活动，每期沙龙邀请美团和同行公司的技术专家分享来自一线的实践经验，覆盖前端、后台、系统、数据、算法、测试、运维等技术领域。目前已在北京、上海、厦门、成都等城市成功举办了48期，吸引了超过2万名工程师报名参会。除了现场亲密交流之外，大家还在会后继续进微信群里切磋问道。&lt;/p&gt;
&lt;p&gt;我们同时也定期举办线上沙龙，有更多的朋友已经在线收听或收看过我们的直播。&lt;/p&gt;
&lt;p&gt;过去的一年里，我们一共举办了19场线下沙龙，16次线上沙龙，包括99位讲师，85个演讲，70+小时分享。除美团的几十位专家之外，还邀请了百度、蚂蚁金服、去哪儿、京东等同行。主题既有最火的AI热点——深度学习、强化学习、知识图谱，新潮技术Go、Kotlin、Flutter的落地实践，也有大规模互联网平台不可或缺的稳定性保障、高可用架构、监控体系、持续集成，还有接地气的运营系统、数据平台、配送调度的经验，更少不了CAT、mpvue、EasyReact这些火爆的开源项目……&lt;/p&gt;
&lt;p&gt;我们整理了今年所有线上线下沙龙的演讲稿和视频，分享给大家，希望能帮助大家在技术之路上继续追求卓越。&lt;/p&gt;
&lt;p&gt;还没有关注美团技术团队公众号（meituantech）的同学，赶快关注哟。&lt;/p&gt;
&lt;p&gt;现在，大家请闭眼，大餐来了～～～&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;美团线下沙龙&lt;/h2&gt;
&lt;p&gt;任意点击标题，就能直接查看视频及演讲稿&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tech Salon 048：&lt;a href=&quot;https://tech.meituan.com/salon/#/44602&quot;&gt;AI在复杂业务场景中的应用&lt;/a&gt;&lt;/strong&gt;（请在微信端打开）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;出品人|何仁清 美团研究员 2018/12/22&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dpurl.cn/1aGUjwA&quot;&gt;《深度强化学习技术在智能调度中的应用》&lt;/a&gt;王超@美团高级技术专家&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dpurl.cn/jtvI8lt&quot;&gt;《深度学习在物流配送舆情监控中的应用》&lt;/a&gt;李超@京东物流NLP方向资深算法工程师&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dpurl.cn/UxQxdqg&quot;&gt;《美团搜索中的深度学习实践》&lt;/a&gt;周翔@美团技术专家&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;Tech Salon 047：&lt;a href=&quot;https://tech.meituan.com/salon/#/44452&quot;&gt;运营效率系统架构演进之道&lt;/a&gt;&lt;/strong&gt;（请在微信端打开）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;出品人|阳纯飞 美团高级技术专家 2018/12/08&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dpurl.cn/e5FWi1r&quot;&gt;《面向O2O大促活动的高效运营系统实践》&lt;/a&gt;李力@美团高级技术专家&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dpurl.cn/umMxuem&quot;&gt;《京东物流实时数据平台性能优化实践》&lt;/a&gt;杨国斌@京东技术专家&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dpurl.cn/S9p9Rct&quot;&gt;《外卖商家菜品运营效率提升实践》&lt;/a&gt;罗震@美团高级技术专家&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dpurl.cn/C0DTDPI&quot;&gt;《外卖商户数据化运营体系建设》&lt;/a&gt;李觊@美团高级技术专家&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;Tech Salon 046：&lt;a href=&quot;https://tech.meituan.com/salon/#/44246&quot;&gt;AI在外卖配送的应用&lt;/a&gt;&lt;/strong&gt;（请在微信端打开）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;出品人|王兴星&amp;amp;郝井华 美团研究员 2018/11/25&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dpurl.cn/OG1VITL&quot;&gt;《预估模型在外卖广告的演进》&lt;/a&gt;谢乾龙@美团外卖广告算法专家&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dpurl.cn/RIA0IBE&quot;&gt;《即时配送中的运筹优化技术》&lt;/a&gt;郝井华@美团配送智能调度平台负责人&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dpurl.cn/b2demu3&quot;&gt;《即时配送中的机器学习技术》&lt;/a&gt;何仁清@美团配送AI方向负责人&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;Tech Salon 045：&lt;a href=&quot;https://tech.meituan.com/salon/#/44241&quot;&gt;如何构建高性能、稳定的后端服务系统&lt;/a&gt;&lt;/strong&gt;（请在微信端打开）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;出品人 |方建平 美团技术总监 2018/11/24&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dpurl.cn/h2tSH0d&quot;&gt;《美团度假交易稳定性建设实践》&lt;/a&gt;韩建起@美团技术专家&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dpurl.cn/1eEmiJa&quot;&gt;《美团配送智能调度系统架构演进》&lt;/a&gt;郑伟@美团技术专家&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dpurl.cn/mOM70TU&quot;&gt;《美团稳定性保障平台Rhino》&lt;/a&gt;占军@美团技术专家&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dpurl.cn/36eUWw7&quot;&gt;《美团外卖LBS服务实践》&lt;/a&gt;易奎@美团高级技术专家&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;Tech Salon 044：&lt;a href=&quot;https://tech.meituan.com/salon/#/42521&quot;&gt;千万级日活App的质量保证&lt;/a&gt;&lt;/strong&gt;（请在微信端打开）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;出品人|李永刚 美团研究员 2018/09/15&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dpurl.cn/RIA0IBE&quot;&gt;《AI语音产品测试》&lt;/a&gt;于海生@美团技术专家&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dpurl.cn/EkrvqQQ&quot;&gt;《美团外卖客户端 UI 自动化测试实践》&lt;/a&gt;刘健@美团技术专家&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dpurl.cn/9wTSjRP&quot;&gt;《客户端QA效率工具》&lt;/a&gt;赵晔@美团测试开发架构师&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;Tech Salon 043：&lt;a href=&quot;https://tech.meituan.com/salon/#/42318&quot;&gt;美团金融千万级交易系统质量保障之路&lt;/a&gt;&lt;/strong&gt;（请在微信端打开）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;出品人|赫大龙 美团高级技术专家 2018/09/01&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dpurl.cn/WBj4g1R&quot;&gt;《智能支付稳定性测试实战》&lt;/a&gt;范勋伟@美团高级测试开发工程师&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dpurl.cn/S3QC9nw&quot;&gt;《去哪儿网服务端自动化测试体系》&lt;/a&gt;郑希文@去哪儿&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dpurl.cn/bxidDmT&quot;&gt;《线上支付SDK质量保证体系》&lt;/a&gt;张朋飞@美团高级测试开发工程师&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dpurl.cn/ICnY9EY&quot;&gt;《质量运营演变之道》&lt;/a&gt;符欣@美团高级开发工程师&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;Tech Salon 042：&lt;a href=&quot;https://tech.meituan.com/salon/#/42098&quot;&gt;高效率前端与架构实战&lt;/a&gt;&lt;/strong&gt;（请在微信端打开）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;出品人|王鹤 美团高级技术专家 2018/08/26&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dpurl.cn/4zd1g7v&quot;&gt;《EH — 用黑科技打造全新的 Hybrid 体验》&lt;/a&gt; 陈禹霖@美团技术专家&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dpurl.cn/atWgFPm&quot;&gt;《mpvue小程序开发框架和最佳实践》&lt;/a&gt;胡成全@美团技术专家&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dpurl.cn/uBGnNe7&quot;&gt;《美团金融前端工程化最佳实践》&lt;/a&gt;田泱@美团高级研发工程师&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dpurl.cn/C21IwKR&quot;&gt;《前端架构师应该做的事——架构模型与技术实践》&lt;/a&gt;王鹤@美团高级技术专家&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;Tech Salon 041：&lt;a href=&quot;https://tech.meituan.com/salon/#/41922&quot;&gt;企业级前端开发360°实践&lt;/a&gt;&lt;/strong&gt;（请在微信端打开）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;出品人|任远 美团高级技术专家 2018/08/18&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dpurl.cn/6enzQ6K&quot;&gt;《浅谈流量劫持与防治》&lt;/a&gt;刘洋河@美团高级工程师&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dpurl.cn/wJLdbeB&quot;&gt;《前端高可用性保障实践》&lt;/a&gt;田泱@美团高级研发工程师&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dpurl.cn/WvMgJ22&quot;&gt;《跨容器高性能的离线化方案在美团的实践和探索》&lt;/a&gt;龙佳文@美团高级工程师&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dpurl.cn/6ea1W3X&quot;&gt;《前端遇上Go: 静态资源增量更新的新实践》&lt;/a&gt;杨义天@美团高级工程师&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;Tech Salon 040：&lt;a href=&quot;https://tech.meituan.com/salon/#/41406&quot;&gt;前端遇上黑科技，打造全新界面体验与效率&lt;/a&gt;&lt;/strong&gt;（请在微信端打开）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;出品人 | 冯湧 美团研发总监 2018/08/04&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dpurl.cn/dcUUsv7&quot;&gt;《EH——用黑科技打造的全新的 Hybrid 体验》&lt;/a&gt;陈禹霖@美团技术专家&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dpurl.cn/omiEOIh&quot;&gt;《Vix——如何打造一个高效的前端组件库》&lt;/a&gt;张胜@美团高级研发工程师&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dpurl.cn/eSbf7eY&quot;&gt;《委以重任的Node.js——百亿级访问实践》&lt;/a&gt;迪波威@百度资深软件工程师&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dpurl.cn/1NLlrH7&quot;&gt;《构建时预渲染——网页首帧优化实践》&lt;/a&gt;尚寒阳@美团资深研发工程师&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;Tech Salon 039：&lt;a href=&quot;https://tech.meituan.com/salon/#/41065&quot;&gt;新思路打造移动端高效研发体系&lt;/a&gt;&lt;/strong&gt;（请在微信端打开）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;出品人|周辉 美团资深架构师 2018/07/21&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dpurl.cn/rtXsz0X&quot;&gt;《Picasso在大众点评首页的应用》&lt;/a&gt;虞惠文@美团Android开发工程师&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dpurl.cn/gJkC96U&quot;&gt;《移动前后端开发解耦》&lt;/a&gt;林晨@美团后端技术专家&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dpurl.cn/kcEERJD&quot;&gt;《打造稳定、灵活、高效的运营配置平台》&lt;/a&gt;蒋国宝@美团后端技术架构师&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dpurl.cn/GEdFow2&quot;&gt;《移动持续集成实践》&lt;/a&gt;何智聪@美团iOS技术专家&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;Tech Salon 038：&lt;a href=&quot;https://tech.meituan.com/salon/#/40348&quot;&gt;旅游电商架构攻略指南&lt;/a&gt;&lt;/strong&gt;（请在微信端打开）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;出品人|金孟哲 美团高级技术专家 2018/07/07&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dpurl.cn/9NA3IDI&quot;&gt;《旅游度假预订系统架构演进实践》&lt;/a&gt; 金孟哲@美团高级技术专家&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dpurl.cn/pdIQztt&quot;&gt;《旅游度假多要素动态打包实践》&lt;/a&gt; 王超@美团高级技术专家&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dpurl.cn/1mx2Mhn&quot;&gt;《旅游度假商品中心架构演进》&lt;/a&gt; 徐泼@美团高级技术专家&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dpurl.cn/jUc9Krm&quot;&gt;《直连低可信系统，实现高可用服务实践》&lt;/a&gt; 郑旭@美团高级技术专家&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;Tech Salon 037：&lt;a href=&quot;https://tech.meituan.com/salon/#/39548&quot;&gt;美团外卖两千万日订单背后的客户端技术架构&lt;/a&gt;&lt;/strong&gt;（请在微信端打开）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;出品人|吴凯 美团高级技术专家 2018/06/23&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dpurl.cn/9VqeRQP&quot;&gt;《美团外卖客户端技术架构演进》&lt;/a&gt;朱瑞利@美团资深工程师&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dpurl.cn/b4BhI2i&quot;&gt;《客户端监控体系建设》&lt;/a&gt;冯天锡@美团资深工程师&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dpurl.cn/0WglRb7&quot;&gt;《客户端多端复用架构》&lt;/a&gt;郑金光@美团高级工程师&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dpurl.cn/BN8S6uV&quot;&gt;《客户端容灾能力体系》&lt;/a&gt;李富强@美团资深工程师&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;Tech Salon 036：&lt;a href=&quot;https://tech.meituan.com/salon/#/38188&quot;&gt;大前端的动态化与可用性建设&lt;/a&gt;&lt;/strong&gt;（请在微信端打开）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;出品人|洪磊 美团高级技术专家 2018/06/02&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dpurl.cn/4x8m29f&quot;&gt;《大前端高可用性建设》&lt;/a&gt;李富强@美团资深前端工程师&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dpurl.cn/aK72uB3&quot;&gt;《React fiber漫谈》&lt;/a&gt;覃俊文@蚂蚁金服前端技术专家&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dpurl.cn/uLlIi3q&quot;&gt;《小程序开发的新姿势 -mpvue 的应用和实践》&lt;/a&gt;胡成全@美团前端技术专家&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dpurl.cn/0n9ANpz&quot;&gt;《ReactNative性能优化企业级应用》&lt;/a&gt;赵宏罡@腾讯资深前端开发工程师&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;Tech Salon 035：&lt;a href=&quot;https://tech.meituan.com/salon/#/35673&quot;&gt;前端热点技术的企业级实践&lt;/a&gt;&lt;/strong&gt;（请在微信端打开）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;出品人|任远 美团高级技术专家 2018/04/21&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dpurl.cn/X8hmGar&quot;&gt;《前端遇上 Go——静态资源增量更新的新实践》&lt;/a&gt;刘洋河@美团高级前端工程师&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dpurl.cn/c2j4URx&quot;&gt;《金融扫码付 H5 迁移小程序拓荒之旅》&lt;/a&gt;陈瑶@美团前端工程师&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dpurl.cn/8VE6Q70&quot;&gt;《小程序开发的新姿势 - mpvue 开发框架和最佳实践》&lt;/a&gt;胡成全@美团技术专家&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;Tech Salon 034：&lt;a href=&quot;https://tech.meituan.com/salon/#/35161&quot;&gt;聊聊酒店系统高可用架构实践&lt;/a&gt;&lt;/strong&gt;（请在微信端打开）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;出品人|许关飞 美团研究员 2018/04/14&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dpurl.cn/KwRRM3V&quot;&gt;《高可用之中间件技术》&lt;/a&gt;吴湘@美团技术专家&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dpurl.cn/9XzOUnT&quot;&gt;《分布式开源监控系统CAT在美团点评演进》&lt;/a&gt;尤勇@美团研究员&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dpurl.cn/3FHVwpo&quot;&gt;《美团旅行住宿产品中心系统高可用实战》&lt;/a&gt;槐国涛@美团酒店CRS商品负责人&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dpurl.cn/Ynt6aVE&quot;&gt;《美团旅行酒店住宿订单系统高可用实战》&lt;/a&gt;李磊@美团资深工程师&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dpurl.cn/2gLXCnH&quot;&gt;《美团旅行直连系统高可用实战》&lt;/a&gt;秦浏杰@美团资深工程师&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;Tech Salon 033：&lt;a href=&quot;https://tech.meituan.com/salon/#/31815&quot;&gt;企业信息化建设和安全管理&lt;/a&gt;&lt;/strong&gt;（请在微信端打开）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;出品人|邓昀泽 美团企业平台研发负责人 2018/02/03&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dpurl.cn/2Cpj4tO&quot;&gt;《美团点评内部系统构建之路》&lt;/a&gt;邓昀泽@美团企业平台研发部负责人&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dpurl.cn/IGFzn0f&quot;&gt;《企业信息防护体系建设》&lt;/a&gt;陆平@美亚柏科企业电子数据取证事业部副总&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dpurl.cn/BTYUxbh&quot;&gt;《企业如何应对安全威胁》&lt;/a&gt;游兴旺@美团企业平台研发高级总监&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;Tech Salon 032：&lt;a href=&quot;https://tech.meituan.com/salon/#/31816&quot;&gt;移动开发热点技术—动态日志、监控、Hybrid、插件化&lt;/a&gt;&lt;/strong&gt;（请在微信端打开）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;出品人|方锦涛 美团高级技术专家 2018/02/03&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dpurl.cn/hi6x3tX&quot;&gt;《线上问题排查体系构建：动态日志》&lt;/a&gt; 陈潼@美团Android资深工程师&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dpurl.cn/BsmtuwJ&quot;&gt;《混合应用工程化实践》&lt;/a&gt; 李罡@美团前端工程师&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dpurl.cn/xXexGwG&quot;&gt;《Caesium iOS启动时间监控》&lt;/a&gt; 吴君阳@美团iOS工程师&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;Tech Salon 031：&lt;a href=&quot;https://tech.meituan.com/salon/#/31470&quot;&gt;线下支付千万级订单服务—前后端架构实践&lt;/a&gt;&lt;/strong&gt;（请在微信端打开）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;出品人|任远 美团高级技术专家 2018/01/27&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dpurl.cn/83yGayf&quot;&gt;《扫码付前端可用性保障实践》&lt;/a&gt; 田泱@美团高级工程师&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dpurl.cn/uQv3mVL&quot;&gt;《业务系统的建设之路》&lt;/a&gt;刘运@美团技术专家&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dpurl.cn/1HxNpDH&quot;&gt;《Web离线化加载》&lt;/a&gt; 于秋@美团技术专家&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dpurl.cn/tbNSxRx&quot;&gt;《基于WTL框架的Windows开发最佳实践》&lt;/a&gt; 钱声鹏@美团高级工程师&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;Tech Salon 030：&lt;a href=&quot;https://tech.meituan.com/salon/#/30554&quot;&gt;餐饮生态高可用系统实践&lt;/a&gt;&lt;/strong&gt;（请在微信端打开）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;出品人|温华剑 美团技术专家 2018/01/13&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dpurl.cn/i40jBTG&quot;&gt;《从“0”开始-美团收银客户端》&lt;/a&gt;聂龙羽@美团技术专家&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dpurl.cn/8qoK8Fa&quot;&gt;《美团餐饮生态大数据架构实践》&lt;/a&gt;牛江浩@美团技术专家&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dpurl.cn/u49UVD9&quot;&gt;《餐饮开放平台的高可用实践》&lt;/a&gt;朱洋波@美团技术专家&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;-&quot;&gt;美团线上沙龙&lt;/h2&gt;
&lt;p&gt;任意点击标题，就能在线观看视频或者文章&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;On-Line Salon 33：&lt;a href=&quot;https://m.lizhiweike.com/classroom/10038952&quot;&gt;美团大脑 智享生活&lt;/a&gt;&lt;/strong&gt;&lt;br/&gt;分享人：王仲远 美团点评高级研究员&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;On-Line Salon 32：&lt;a href=&quot;https://gitbook.cn/books/5bcf24b6211d0e68b1b788f0/index.html&quot;&gt;基于深度学习的计算机视觉技术在无人驾驶中的应用&lt;/a&gt;&lt;/strong&gt;&lt;br/&gt;分享人：刘宇达 美团点评资深算法工程师&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;On-Line Salon 31：&lt;a href=&quot;https://m.lizhiweike.com/classroom/9363553&quot;&gt;利用响应式来解决客户端问题&lt;/a&gt;&lt;/strong&gt;&lt;br/&gt;分享人：臧成威 美团点评前端技术专家&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;On-Line Salon 30：&lt;a href=&quot;https://gitbook.cn/books/5b927473780fdb5e97d2a3bc/index.html&quot;&gt;美团针对 Redis Rehash 机制的探索和实践&lt;/a&gt;&lt;/strong&gt;&lt;br/&gt;分享人：葛春林 美团点评资深工程师&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;On-Line Salon 29：&lt;a href=&quot;https://m.lizhiweike.com/classroom/8660084&quot;&gt;Flutter 原理与实践&lt;/a&gt;&lt;/strong&gt;&lt;br/&gt;分享人：李少杰 美团点评资深工程师&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;On-Line Salon 28：&lt;a href=&quot;https://gitbook.cn/books/5b8746c7ea7bc512755e4e36/index.html&quot;&gt;如何基于深度学习实现图像的智能审核&lt;/a&gt;&lt;/strong&gt;&lt;br/&gt;分享人：魏晓明 美团点评高级技术专家&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;On-Line Salon 27：&lt;a href=&quot;https://gitbook.cn/books/5b7e5a44a63144311b8dbf2d/index.html&quot;&gt;美团客户端响应式框架 EasyReact 开源&lt;/a&gt;&lt;/strong&gt;&lt;br/&gt;分享人：臧成威 美团点评前端技术专家&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;On-Line Salon 26：&lt;a href=&quot;https://gitbook.cn/books/5b752e45e8b81c0748e349e1/index.html&quot;&gt;移动持续集成在大众点评的实践&lt;/a&gt;&lt;/strong&gt;&lt;br/&gt;分享人：何智聪、邢轶 美团点评前端技术专家&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;On-Line Salon 25：Kotlin &lt;a href=&quot;https://gitbook.cn/books/5b6c28169f4dd1284bf82f99/index.html&quot;&gt;代码检查探索与实践&lt;/a&gt;&lt;/strong&gt;&lt;br/&gt;分享人：周佳 美团点评前端开发工程师&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;On-Line Salon 24：&lt;a href=&quot;https://gitbook.cn/books/5b67bceca51b8d5f8ecbcf79/index.html&quot;&gt;静态资源增量更新的新实践&lt;/a&gt;&lt;/strong&gt;&lt;br/&gt;分享人：刘洋河 美团点评资深工程师&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;On-Line Salon 23：&lt;a href=&quot;https://gitbook.cn/books/5b5ab5721642ed2ba79b6630/index.html&quot;&gt;点评侧用户行为检索系统&lt;/a&gt;&lt;/strong&gt;&lt;br/&gt;分享人：朱凯 美团点评资深工程师&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;On-Line Salon 22：&lt;a href=&quot;https://gitbook.cn/books/5b43fc6316959658636f059e/index.html&quot;&gt;深度学习在美团搜索广告排序的应用实践&lt;/a&gt;&lt;/strong&gt;&lt;br/&gt;分享人：薛欢、梁玉林、王新 美团点评资深工程师&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;On-Line Salon 21：&lt;a href=&quot;https://gitbook.cn/books/5ae9bcbeb02ff82d0d1b0517/index.html&quot;&gt;使用 Mpvue 开发微信小程序的最佳实践&lt;/a&gt;&lt;/strong&gt;&lt;br/&gt;分享人：胡成全 美团点评前端技术专家&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;On-Line Salon 20：&lt;a href=&quot;https://gitbook.cn/books/5ad4a60daf8f2f35290f46d5/index.html&quot;&gt;亿级用户个性化品类推荐实战解析&lt;/a&gt;&lt;/strong&gt;&lt;br/&gt;分享人：张晓宇 美团高级工程师&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;On-Line Salon 19：&lt;a href=&quot;https://gitbook.cn/books/5ac2325c9e924a1dc029c6b7/index.html&quot;&gt;MVVM 在美团点评酒旅业务中的实践&lt;/a&gt;&lt;/strong&gt;&lt;br/&gt;分享人：吴卓 美团点评技术专家&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;On-Line Salon 18：&lt;a href=&quot;https://gitbook.cn/books/5aa6850a9c3cf94d4915f97c/index.html&quot;&gt;深度学习在美团点评推荐业务中实践&lt;/a&gt;&lt;/strong&gt;&lt;br/&gt;分享人：陈文石 美团点评算法专家&lt;/p&gt;
&lt;p&gt;感恩！99位出品人和讲师，70多个小时的分享，感谢他们给我们带来一线的技术实践分享，感谢他们给我们2万多小伙伴送上技术的“饕餮盛宴”。除了美团技术团队的讲师们，我们还要特别感谢来自腾讯、蚂蚁金服、百度、京东、去哪儿、美亚柏科等公司的讲师们，感谢你们的付出和努力，我们期待新的一年会有更多的合作！&lt;br/&gt;&lt;img src=&quot;https://tech.meituan.com/img/jishushalong/02.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2018全年出品人及讲师）&lt;/p&gt;
&lt;p&gt;---------- END ----------&lt;/p&gt;
&lt;div class=&quot;hidden-mobile&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;strong&gt;发现文章有错误、对内容有疑问，都可以关注美团技术团队微信公众号（meituantech），在后台给我们留言。我们每周会挑选出一位热心小伙伴，送上一份精美的小礼品。快来扫码关注我们吧！&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;article__footer__img&quot;&gt;&lt;img src=&quot;https://tech.meituan.com/img/meituanjishutuandui.png&quot; alt=&quot;公众号二维码&quot; width=&quot;455&quot; align=&quot;center&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Fri, 04 Jan 2019 07:25:00 +0000</pubDate>
<dc:creator>美团技术团队</dc:creator>
<og:description>在过去的一年里，美团技术团队成功举办了19场线下沙龙，16次线上沙龙，包括99位讲师，85个演讲，70+小时分享。现整理所有的PPT和视频，分享与大家。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/meituantech/p/10220081.html</dc:identifier>
</item>
<item>
<title>nginx系列 3 nginx.conf介绍(1) - 花阴偷移</title>
<link>http://www.cnblogs.com/MrHSR/p/10218756.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MrHSR/p/10218756.html</guid>
<description>&lt;h3&gt;一. nginx.conf 文件结构概述&lt;/h3&gt;
&lt;p&gt;　　在第一篇中讲到nginx的安装，安装完后，默认的nginx服务器配置文件都存在安装目录conf中，主配置文件名为nginx.conf。下面是我linux系统安装nginx的目录信息：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    [root@xuegod64 nginx]# pwd
    &lt;/span&gt;/usr/local/&lt;span&gt;nginx
    [root@xuegod64 nginx]# ls
    client_body_temp  &lt;span&gt;&lt;strong&gt;conf&lt;/strong&gt;&lt;/span&gt;  fastcgi_temp  html  logs  proxy_temp  sbin  scgi_temp  uwsgi_temp&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　下面将说明nginx.conf原始文件中，各条语句的生效范围，对指令作用域有一个初步的了解。在nginx.conf文件结构中，最外层的花括号将内容整体分为两部分(event、http)。nginx.conf一共由三部分组成，分别为全局块、events块、http块。 在http块中，又包含http全局块、多个server块。每个server块中，可以包含server全局块和多个location块。在同一配置块中嵌入的配置块，各个之间不存在次序关系。&lt;/p&gt;
&lt;p&gt;　　配置文件支持大量可配置的指令，绝大多数指令不是特定属于某一块的。同一个指令放在不同层级的块中，其作用域也不同。一般情况下，高一级块中的指令可以作用于自身所在的块和此块包含的所有低层级块。 如果某个指令在两个不同层级的块中同时出现，则采用&quot;就近原则，即以较低层级的块中的配置为准。&lt;/p&gt;
&lt;p&gt;　　下面是一个nginx.conf简单的配置示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('05473c74-c81b-42d1-8584-49c9ed71d8b9')&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_05473c74-c81b-42d1-8584-49c9ed71d8b9&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_05473c74-c81b-42d1-8584-49c9ed71d8b9&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('05473c74-c81b-42d1-8584-49c9ed71d8b9',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_05473c74-c81b-42d1-8584-49c9ed71d8b9&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#user  nobody;
user nginx nginx;
worker_processes  &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

#error_log  logs&lt;/span&gt;/&lt;span&gt;error.log;
#error_log  logs&lt;/span&gt;/&lt;span&gt;error.log  notice;
#error_log  logs&lt;/span&gt;/&lt;span&gt;error.log  info;

#pid        logs&lt;/span&gt;/&lt;span&gt;nginx.pid;
#以上是全局块

events {
    worker_connections  &lt;/span&gt;&lt;span&gt;1024&lt;/span&gt;&lt;span&gt;;
}
#以上是events块

#最后是http块,里面包括location块
http {
    include       mime.types;
    default_type  application&lt;/span&gt;/octet-&lt;span&gt;stream;

    #access_log  logs&lt;/span&gt;/&lt;span&gt;access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    #keepalive_timeout  &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    keepalive_timeout  &lt;/span&gt;&lt;span&gt;65&lt;/span&gt;&lt;span&gt;;

    #gzip  on;

    server {
        listen       &lt;/span&gt;&lt;span&gt;80&lt;/span&gt;&lt;span&gt;;
        server_name  localhost;

        #charset koi8&lt;/span&gt;-&lt;span&gt;r;

        #access_log  logs&lt;/span&gt;/&lt;span&gt;host.access.log  main;

        location &lt;/span&gt;/&lt;span&gt; {
            root   html;
            index  index.html index.htm;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ($request_uri ~*&lt;span&gt; \.html$) {
                proxy_pass http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;htmlservers;&lt;/span&gt;
&lt;span&gt;           }
         &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ($request_uri ~*&lt;span&gt; \.aspx$){
               proxy_pass http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;aspxservers;&lt;/span&gt;
&lt;span&gt;           }
           proxy_pass http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;picservers;&lt;/span&gt;
&lt;span&gt;        }

        #error_page  &lt;/span&gt;&lt;span&gt;404&lt;/span&gt;              /&lt;span&gt;404&lt;/span&gt;&lt;span&gt;.html;

        # redirect server error pages to the &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; page /&lt;span&gt;50x.html
        #
        error_page   &lt;/span&gt;&lt;span&gt;500&lt;/span&gt; &lt;span&gt;502&lt;/span&gt; &lt;span&gt;503&lt;/span&gt; &lt;span&gt;504&lt;/span&gt;  /&lt;span&gt;50x.html;
        location &lt;/span&gt;= /&lt;span&gt;50x.html {
            root   html;
        }
}

      upstream  htmlservers{
          server &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;2.50&lt;/span&gt;:&lt;span&gt;80&lt;/span&gt;&lt;span&gt;;
          server &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;2.51&lt;/span&gt;:&lt;span&gt;80&lt;/span&gt;&lt;span&gt;;
      }
      upstream  aspxservers{
          server &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;2.50&lt;/span&gt;:&lt;span&gt;80&lt;/span&gt;&lt;span&gt;;
          server &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;2.51&lt;/span&gt;:&lt;span&gt;80&lt;/span&gt;&lt;span&gt;;
      }
      upstream   picservers{
          server &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;2.50&lt;/span&gt;:&lt;span&gt;80&lt;/span&gt;&lt;span&gt;;
          server &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;2.51&lt;/span&gt;:&lt;span&gt;80&lt;/span&gt;&lt;span&gt;;
      }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;　&lt;strong&gt;　1. 全局块&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　全局块是默认配置文件从开始到events块之间的一部份内容，主要设置一些影响nginx服务器整体运行的配置指令，因此这些指令作用域是nginx服务器全局。通常包括配置运行nginx服务器的用户(组),允许生成的worker process数、nginx进程pid存放路径、日志的存放路径和类型以及配置文件引入等。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;　　2. events块&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;　　&lt;span lang=&quot;EN-US&quot;&gt;events&lt;/span&gt;块涉及的指令主要影响&lt;span lang=&quot;EN-US&quot;&gt;nginx&lt;/span&gt;服务器与用户的网络连接，常用到的设置包括是否开启对多&lt;span lang=&quot;EN-US&quot;&gt;worker process&lt;/span&gt;下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型处理连接请求，每个&lt;span lang=&quot;EN-US&quot;&gt;worker process&lt;/span&gt;可以同时支持的最大连接数。这一块对&lt;span lang=&quot;EN-US&quot;&gt;nginx&lt;/span&gt;服务器的性能影响较大，应该根据实际情况灵活调整。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　&lt;strong&gt;　&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;3. http&lt;/span&gt;&lt;span&gt;块&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;span lang=&quot;EN-US&quot;&gt;http&lt;/span&gt;块是&lt;span lang=&quot;EN-US&quot;&gt;nginx&lt;/span&gt;服务器配置中重要部分，代理、缓存和日志定义等绝大多数的功能和第三方模块的配置都可以放在这个模块中。可以在&lt;span lang=&quot;EN-US&quot;&gt;http&lt;/span&gt;全局块中配置的指令包括文件引入、&lt;span lang=&quot;EN-US&quot;&gt;mime-type&lt;/span&gt;定义、日志自定义、是否使用&lt;span lang=&quot;EN-US&quot;&gt;sendfile&lt;/span&gt;转输文件、连接超时时间、单连接请求数上限等。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;4.server&lt;/span&gt;&lt;span&gt;块&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　配置虚拟主机的相关参数，一个http中可以有多个server。server块和&quot;虚拟主机&quot;的概述有密切联系，虚拟主机又称虚拟服务器或虚拟机。例如使用VMware来虚拟一个主机。对外表现为多个服务器。从用户角度来看，一台虚拟主机和一台独立的硬件主机是完全一样的。前面提过每一个&lt;span lang=&quot;EN-US&quot;&gt;http&lt;/span&gt;块可以包含多个&lt;span lang=&quot;EN-US&quot;&gt;server&lt;/span&gt;块，而每个&lt;span lang=&quot;EN-US&quot;&gt;server&lt;/span&gt;块就相当于一台虚拟主机，它内部可有多台主机联合提供服务，一起对外提供在逻辑上关系密切的一组服务&lt;span lang=&quot;EN-US&quot;&gt;(&lt;/span&gt;或网站&lt;span lang=&quot;EN-US&quot;&gt;)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　　　和&lt;span lang=&quot;EN-US&quot;&gt;http&lt;/span&gt;块相同，&lt;span lang=&quot;EN-US&quot;&gt;server&lt;/span&gt;块也可以包含自己的全局块，同时可以包含多个&lt;span lang=&quot;EN-US&quot;&gt;location&lt;/span&gt;块，在&lt;span lang=&quot;EN-US&quot;&gt;server&lt;/span&gt;全局块中，最常见的两个配置项是本虚拟主机的监听配置和本虚拟主机的名称或&lt;span lang=&quot;EN-US&quot;&gt;ip&lt;/span&gt;配置。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　&lt;strong&gt;　&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;5.  location&lt;/span&gt;&lt;span&gt;块&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　用于配置请求的路由，以及各种页面的处理情况。每个&lt;span lang=&quot;EN-US&quot;&gt;server&lt;/span&gt;块中可以包含多个&lt;span lang=&quot;EN-US&quot;&gt;location&lt;/span&gt;块，&lt;span lang=&quot;EN-US&quot;&gt;location&lt;/span&gt;是&lt;span lang=&quot;EN-US&quot;&gt;server&lt;/span&gt;块的一个指令，由于在整个&lt;span lang=&quot;EN-US&quot;&gt;nginx&lt;/span&gt;配置中起着重要的作用，而且许多功能上灵活性往往在&lt;span lang=&quot;EN-US&quot;&gt;location&lt;/span&gt;指令的配置中体现出来，所以单独列为一个&lt;span lang=&quot;EN-US&quot;&gt;&quot;&lt;/span&gt;块&lt;span lang=&quot;EN-US&quot;&gt;&quot;&lt;/span&gt;。&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt; 这些&lt;span lang=&quot;EN-US&quot;&gt;location&lt;/span&gt;块的主要作用是，基于&lt;span lang=&quot;EN-US&quot;&gt;nginx&lt;/span&gt;服务器接收到的请求字符串&lt;span lang=&quot;EN-US&quot;&gt;(&lt;/span&gt;例如：&lt;span lang=&quot;EN-US&quot;&gt;server_name &lt;/span&gt; 或 &lt;span lang=&quot;EN-US&quot;&gt;url_string)&lt;/span&gt;，对除虚拟主机名称&lt;span lang=&quot;EN-US&quot;&gt;(&lt;/span&gt;或&lt;span lang=&quot;EN-US&quot;&gt;ip)&lt;/span&gt; 之外的字符串如&lt;span lang=&quot;EN-US&quot;&gt;url_stirng&lt;/span&gt;进行匹配，对特定的请求进行处理。地址定向、数据缓存、和应答控制等功能都是在这部分实现，许多第三方模块的配置也是在&lt;span lang=&quot;EN-US&quot;&gt;location&lt;/span&gt;块中提供功能。&lt;/p&gt;

&lt;h3 class=&quot;MsoNormal&quot;&gt;&lt;span&gt;二&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.  &lt;/span&gt;&lt;span&gt;全局块指令配置&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　&lt;strong&gt;　&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;2.1&lt;/span&gt; &lt;span&gt;运行&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Nginx&lt;/span&gt;&lt;span&gt;服务器用户&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;(&lt;/span&gt;&lt;span&gt;组&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;)  user&lt;/span&gt;&lt;span&gt;指令&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/strong&gt;　　该指令配置属于全局块，在文件的第一行，默认是&lt;span lang=&quot;EN-US&quot;&gt;user nobody&lt;/span&gt;。该&lt;span lang=&quot;EN-US&quot;&gt;user&lt;/span&gt;指令的语法格式为&lt;span lang=&quot;EN-US&quot;&gt;: &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;　　　　　　　　user &lt;/span&gt; 用户&lt;span lang=&quot;EN-US&quot;&gt;  [&lt;/span&gt;用户组&lt;span lang=&quot;EN-US&quot;&gt;];&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;　　　　&lt;/span&gt;用户：是指定可以运行&lt;span lang=&quot;EN-US&quot;&gt;nginx&lt;/span&gt;服务器的用户。用户组：是可选项，指定可以运行&lt;span lang=&quot;EN-US&quot;&gt;nginx&lt;/span&gt;服务器的用户组。只有被设置的用户或者用户组成员才有权限启动&lt;span lang=&quot;EN-US&quot;&gt;nginx&lt;/span&gt;进程。如果希望所有用户可以启动&lt;span lang=&quot;EN-US&quot;&gt;Nginx&lt;/span&gt;进程，可以注释掉&lt;span lang=&quot;EN-US&quot;&gt;user&lt;/span&gt;指令。下面是&lt;span lang=&quot;EN-US&quot;&gt;user&lt;/span&gt;指令，指定&lt;span lang=&quot;EN-US&quot;&gt;nginx&lt;/span&gt;用户和&lt;span lang=&quot;EN-US&quot;&gt;nginx&lt;/span&gt;用户组。第一行&lt;span lang=&quot;EN-US&quot;&gt;#&lt;/span&gt;表示已注释，不生效。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    #user  nobody;
    user nginx nginx;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　&lt;strong&gt;&lt;span&gt;在&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;nginx.conf&lt;/span&gt;&lt;span&gt;配置文件中，每一条指令配置都必须以分号结束。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;　　2.2 允许生成的工作进程数 &lt;span lang=&quot;EN-US&quot;&gt;worker_processes&lt;/span&gt;指令&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;　　&lt;span lang=&quot;EN-US&quot;&gt;worker process&lt;/span&gt;是&lt;span lang=&quot;EN-US&quot;&gt;nginx&lt;/span&gt;服务器实现并发处理服务&lt;span lang=&quot;EN-US&quot;&gt;(&lt;/span&gt;网站&lt;span lang=&quot;EN-US&quot;&gt;)&lt;/span&gt;的关键所在。理念上讲，值越大，可以支持的并发处理量也越多。但实现受限于软件本身、操作系统资源。一般建议启动的工作进程数&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;通常设置成和&lt;span lang=&quot;EN-US&quot;&gt;cpu&lt;/span&gt;核数相等。该&lt;span lang=&quot;EN-US&quot;&gt;worker process&lt;/span&gt;指令的语法格式为&lt;span lang=&quot;EN-US&quot;&gt;:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;　　　　　　　&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;worker_processes&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;number | auto;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;　　　&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;　&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;number&lt;/span&gt;：指定&lt;span lang=&quot;EN-US&quot;&gt;nginx&lt;/span&gt;进程最多可以产生的进程数。&lt;span lang=&quot;EN-US&quot;&gt;auto&lt;/span&gt;：自动检测。下面是&lt;span lang=&quot;EN-US&quot;&gt;worker_processes&lt;/span&gt;指令，指定一个进程数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
    worker_processes  &lt;span&gt;1&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　当启动&lt;span lang=&quot;EN-US&quot;&gt;nginx&lt;/span&gt;服务器后，可以查看&lt;span lang=&quot;EN-US&quot;&gt;nginx&lt;/span&gt;服务器除了主进程&lt;span lang=&quot;EN-US&quot;&gt;master process&lt;/span&gt;之处，还生成了一个&lt;span lang=&quot;EN-US&quot;&gt;worker process:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    [root@xuegod64 nginx]# ps -ef |&lt;span&gt; grep nginx
    root       &lt;/span&gt;&lt;span&gt;5454&lt;/span&gt;      &lt;span&gt;1&lt;/span&gt;  &lt;span&gt;0&lt;/span&gt; 1月03 ?       &lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt; nginx: master process ./nginx -c /usr/local/nginx/conf/&lt;span&gt;nginx.conf
    nginx      &lt;/span&gt;&lt;span&gt;5455&lt;/span&gt;   &lt;span&gt;5454&lt;/span&gt;  &lt;span&gt;0&lt;/span&gt; 1月03 ?       &lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;&lt;span&gt; nginx: worker process
    root      &lt;/span&gt;&lt;span&gt;19141&lt;/span&gt;   &lt;span&gt;2678&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;:&lt;span&gt;34&lt;/span&gt; pts/&lt;span&gt;0&lt;/span&gt;   &lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt; grep --color=auto nginx
&lt;/pre&gt;&lt;/div&gt;

&lt;p class=&quot;MsoNormal&quot;&gt;&lt;strong&gt; 　　2.3 nginx进程存放路径 PID指令　&lt;/strong&gt;　&lt;/p&gt;
&lt;p&gt; 　　　　nginx进程作为系统的守护进程运行，需要在某文件中保存当前运行程序的主进程号。nginx支持对它的存放路径进行自定义配置。该pid指令语法格式为:&lt;/p&gt;
&lt;p&gt;　　　　　　　　&lt;span lang=&quot;EN-US&quot;&gt;pid    &lt;span lang=&quot;EN-US&quot;&gt;file;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;　　　　&lt;/span&gt;&lt;/span&gt;file：指定存放路径和文件名称。配置文件默认将此文件存放在nginx安装目录logs下，名字为nginx.pid。file可以是相对路径，注意file除了路径一定要指定文件名。下面是pid指令的配置路径存放于安装目录logs文件夹下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
    pid   logs/nginx.pid;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;　　2.4 &lt;/span&gt;&lt;/span&gt;错误日志的存放路径 error_log指令&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　&lt;/strong&gt;在全局块、http块、server块都可以对nginx服务器的日志进行相关配置。这里首先介绍全局块下日志的存放配置，另二块配置基本相同，只是作用域不同。该error_log指令语法格式为:&lt;/p&gt;
&lt;p&gt;　　　　　　　　&lt;span lang=&quot;EN-US&quot;&gt;error_log &lt;span lang=&quot;EN-US&quot;&gt;file | level [debug | info |notice |warn | error| crit | alert｜ &lt;span lang=&quot;EN-US&quot;&gt;emerg];&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;　　　　nginx服务器日志支持输出到某一固定的文件file 以及level日志级别。日志的级别是可选项，由低到高，级别越高记录的信息越少， 比如设置了warn级别后，级别为warn、error、crit、alert、emerg的日志都会被记录下来。生产场景一般是 warn | error | crit 这三个级别之一。下面看一个配置实例，也是nginx默认的日志存放路径和默认日志级别设置：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    error_log  logs/error.log  error;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　&lt;span&gt;&lt;strong&gt;　注意指定的文件对于运行&lt;span lang=&quot;EN-US&quot;&gt;nginx进程的用户具有写权限，否则在启动&lt;span lang=&quot;EN-US&quot;&gt;ningx进程时会报错&lt;span lang=&quot;EN-US&quot;&gt;(/nginx/logs/error.log permission denied)。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;三. events块指令配置　&lt;/h3&gt;

&lt;p align=&quot;left&quot;&gt;　&lt;strong&gt;　3.1  最大连接数worker_connections指令&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;　　　　该指令用来设置允许每一个worker process同时开启的最大连接数。&lt;/span&gt;number默认值是1024。这个number不仅仅包括和前端用户建立的连接数，而是包括所有可能的连接数。&lt;span lang=&quot;EN-US&quot;&gt;该worker_connections指令语法格式为:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;　　　　　　&lt;/span&gt;worker_connections number;&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;3.2 事件驱动模型 use指令&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　&lt;/strong&gt;nginx服务器提供了多种事件驱动模型来处理网络消息，可以使用user指令来指定某一事件驱动模型。后面再详细介绍。 user指令语法结构为:&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;span lang=&quot;EN-US&quot;&gt;use  select | poll | kqueue | epoll | rtsig | /dev/poll | eventport;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;　　&lt;strong&gt;3.3 &lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;是否允许同时接收多个网络连接 multi_accept 指令&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　每个nginx服务器的worker_process都有能力同时接收多个新到达的网络连接，但是这需要在配置文件中进行设置，默认是关闭。当指令默认为关闭状态，即每个worker_process一次只能接收一个新到达的网络连接。 该multi_accept 指令语法结构为:&lt;/p&gt;
&lt;p&gt;　　　　　　multi_accept  on | off&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;3.4 设置网络连接的序列化 accept_mutex指令&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　&lt;/strong&gt;这里涉及到一个名词&quot;惊群&quot;。惊群(thundering herd problem) 大意是：当某一时候只有一个网络连接到来时，多个睡眠进程会被同时叫醒，但只有一个进程可获得连接。如果每次唤醒的进程数目太多，会影响一部分系统性能。在nginx服务器的多进程下，有可能出现这样的问题。&lt;/p&gt;
&lt;p&gt;　　　　为了解决这样的问题，nginx配置中包含了这样一条指令accept_mutex。当设置为开启的时候会对多个nginx进程接收连接进行序列化，防止多个进程对连接的争抢。默认为开启状态。其语法结构为:&lt;/p&gt;
&lt;p&gt;　　　　accept_mutex   on | off;&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;　　本篇最后先展示nginx.conf配置文件的全局块和event块的指令条数示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    user nginx nginx;
    worker_processes  &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    pid   logs&lt;/span&gt;/&lt;span&gt;nginx.pid;
    error_log  logs&lt;/span&gt;/&lt;span&gt;error.log  error;  #制定日志路径，级别。这个设置可以放入全局块，http块，server块

    events {
        accept_mutex on;  #默认为on
        multi_accept on;  #默认为off
        use epoll;      #事件驱动模型
        worker_connections  &lt;/span&gt;&lt;span&gt;1024&lt;/span&gt;&lt;span&gt;;    #最大连接数
     }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;参考文献：&lt;/p&gt;
&lt;p&gt;　　Nginx高性能Web服务器详解&lt;/p&gt;

</description>
<pubDate>Fri, 04 Jan 2019 06:52:00 +0000</pubDate>
<dc:creator>花阴偷移</dc:creator>
<og:description>一. nginx.conf 文件结构概述 在第一篇中讲到nginx的安装，安装完后，默认的nginx服务器配置文件都存在安装目录conf中，主配置文件名为nginx.conf。下面是我linux系统安</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/MrHSR/p/10218756.html</dc:identifier>
</item>
<item>
<title>java使用netty的模型总结 - lgp20151222</title>
<link>http://www.cnblogs.com/ydymz/p/10219637.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ydymz/p/10219637.html</guid>
<description>&lt;p&gt;由于本人的码云太多太乱了，于是决定一个一个的整合到一个springboot项目里面。&lt;/p&gt;
&lt;p&gt;附上自己的github项目地址 &lt;a href=&quot;https://github.com/247292980/spring-boot&quot; target=&quot;_blank&quot;&gt;https://github.com/247292980/spring-boot&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;附上汇总博文地址 &lt;a href=&quot;https://www.cnblogs.com/ydymz/p/9391653.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/ydymz/p/9391653.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;以整合功能&lt;/p&gt;
&lt;p&gt;spring-boot，FusionChart，thymeleaf，vue，ShardingJdbc，mybatis-generator，微信分享授权，drools，spring-security，spring-jpa，webjars，Aspect，drools-drt，rabbitmq，zookeeper，mongodb，mysql存储过程，前端的延迟加载，netty，postgresql，树的遍历&lt;/p&gt;

&lt;p&gt;这次再次说下netty，为什么在学netty呢？因为面试一家大公司的时候，被问倒了，，，所以只好耐下心来看原理了。&lt;/p&gt;
&lt;p&gt;目前看了两本netty的书（市面上就两本 orz）第一感觉就是netty的书怎么说呢，就是demo集合，某程度还是挺好看懂的，但是过时啊。&lt;/p&gt;
&lt;p&gt;不过参考之前写drools的痛苦经验，国内大部分环境应该也是用过时的netty，不信你去技术群里问下新版netty的特性，大家一定会劝你去踩坑...&lt;/p&gt;

&lt;p&gt;而这篇文章也不介绍新特性，只是对netty的原理研究。说实话就是丢图，，，&lt;/p&gt;


&lt;p&gt;说到netty一定要知道他的基本模型。&lt;/p&gt;
&lt;h2&gt;1.先说下之前的bio-同步阻塞io&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1095725/201901/1095725-20190104101216962-945358059.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;显然有点网络基础的人都写过类似的代码。优缺点很明显&lt;/p&gt;
&lt;p&gt;缺点：性能瓶颈。每个链接一个线程，怎么保证线程的即时回收和可靠回收是一大技术问题。而该模型在遇到大量线程的时候（超过某个阈值，例如java默认的线程上限或者linux的默认线程上限之类的）性能指数性下降啊。&lt;/p&gt;
&lt;p&gt;优点：简单。所以我才说有点网络基础的人都写过类似的代码，，，除非直接起手springboot的&lt;/p&gt;

&lt;h2&gt;2.后面就是nio-同步非阻塞io&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1095725/201901/1095725-20190104102001173-1777225199.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;acceptor收到所有的连接请求&lt;/p&gt;
&lt;p&gt;acceptor上注册了selector，&lt;/p&gt;
&lt;p&gt;服务器构建对应的Channel，并在其上注册Selector&lt;/p&gt;
&lt;p&gt;selector分配请求到不同的channel，进行相应的读写处理。&lt;/p&gt;

&lt;p&gt;ps.写完发现可能有点难理解，具体代码项目里面有。&lt;/p&gt;
&lt;p&gt;其实就是selector分配请求，channel处理请求并能通过selector得到client，等处理完成后直接返回client，不走selector。&lt;/p&gt;

&lt;p&gt;优点：一个线程处理全部连接，不阻塞后面的连接。性能大提升！&lt;/p&gt;
&lt;p&gt;缺点：模型复杂，代码复杂（至少我觉得不看一下代码，很难说清）；处理半包问题&lt;/p&gt;

&lt;p&gt;ps.半包问题&lt;/p&gt;
&lt;p&gt;我们知道TCP/IP在发送消息的时候，可能会拆包。这就导致接收端无法知道什么时候收到的数据是一个完整的数据。&lt;/p&gt;
&lt;p&gt;例如:发送端分别发送了ABC,DEF,GHI三条信息，发送时被拆成了AB,CDRFG,H,I这四个包进行发送，接受端如何将其进行还原呢？在BIO模型中，当读不到数据后会阻塞，而NIO中不会!所以需要自行进行处理!说到底就是自定义网络协议，额其实这个有点基础的都写过，我也不细说了。&lt;/p&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;3.所以为了解决这问题，netty就使用了Reactor模型-bio的变种&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1095725/201901/1095725-20190104104609306-1246676183.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;具体来说这是reactor的单线程模型，可以看出和bio基本没什么差别，就是把channel的数据处理提到handler，并且统一在reactor注册了，而不用去acceptor，channel分别注册在两个地方，统一处理了。&lt;/p&gt;
&lt;p&gt;但是这玩意有个问题就是，一个client多次请求，handler中的处理特别慢，那么后续的请求就会被积压。&lt;/p&gt;

&lt;h2&gt;4.Reactor多线程模型&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1095725/201901/1095725-20190104110700289-2093369267.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;reactor将接受发送分离，client发送的请求丢到线程池中，所以后续请求不会被阻塞。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
但是当用户进一步增加的时候，Reactor会出现瓶颈！因为Reactor既要处理IO操作请求，又要响应连接请求！为了分担Reactor的负担，所以引入了主从Reactor模型!
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的这一句话是书上原话，其实我是不太赞成的，因为说到底就是一个线程的事，所以没可能是性能瓶颈，而在我看来netty使用主从reactor的主要原因是代码可读性和易于理解。&lt;/p&gt;
&lt;h2&gt;5.Reactor主从模型&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1095725/201901/1095725-20190104112212415-1244594508.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;简单明了&lt;/p&gt;
&lt;p&gt;client发送请求&lt;/p&gt;
&lt;p&gt;acceptor就是个死循环监听&lt;/p&gt;
&lt;p&gt;mainreactor分配acceptor监听到的请求到channel&lt;/p&gt;
&lt;p&gt;channel通过subreactor将请求发到handler处理，然后直接返回给client&lt;/p&gt;

&lt;p&gt;ps.注意的是mainreactor一定是单线程，多线程可能导致为client分配channel的时候，一个线程分配了一个，浪费资源；也存在一个client的请求去了两线程，而其中一个处理很久，另一个则早早完成，而此时client的等待时间是取最大等待时间的，那么早早完成的还不如一起在另一个处理很久的线程里面；&lt;/p&gt;




&lt;p&gt;Channel： 是一个客户端用来进行连接的 Channel，记录了client信息，用于io操作的交互&lt;/p&gt;
&lt;p&gt;ChannelHandler： 数据处理的容器&lt;/p&gt;
&lt;p&gt;ChannelPipeline：提供了一个容器给 ChannelHandler 链并提供了一个API 用于管理沿着链入站和出站事件的流动&lt;/p&gt;

&lt;p&gt;EventLoop： EventLoop 用于处理 Channel 的 I/O 操作。一个单一的 EventLoop通常会处理多个 Channel 事件&lt;/p&gt;
&lt;p&gt;EventLoopGroup：可以含有多于一个的 EventLoop 和 提供了一种迭代用于检索清单中的下一个&lt;/p&gt;

&lt;p&gt;ChannelFuture： ChannelFuture是netty的一个回调不管是否成功返回&lt;/p&gt;
&lt;p&gt;ChannelFutureListener：ChannelFuture通过addListener 注册。当操作完成时，可以被通知（不管成功与否）&lt;/p&gt;

&lt;p&gt;&lt;span&gt;ps.ChannelFutureListener加上了之后就可以说是实现异步。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;四 channel&lt;/p&gt;
&lt;p&gt;通常来说, 所有的 netty 的 I/O 操作都是从 Channel 开始的. 一个 channel 类似于一个 stream.&lt;/p&gt;

&lt;p&gt;Stream 和 Channel 对比&lt;/p&gt;
&lt;p&gt;我们可以在同一个 Channel 中执行读和写操作, 然而同一个 Stream 仅仅支持读或写.&lt;/p&gt;
&lt;p&gt;Channel 可以异步地读写, 而 Stream 是阻塞的同步读写.&lt;/p&gt;
&lt;p&gt;Channel 总是从 Buffer 中读取数据, 或将数据写入到 Buffer 中.&lt;/p&gt;

&lt;p&gt;Channel 类型有:&lt;/p&gt;
&lt;p&gt;FileChannel, 文件操作&lt;/p&gt;
&lt;p&gt;DatagramChannel, UDP 操作&lt;/p&gt;
&lt;p&gt;SocketChannel, TCP 操作&lt;/p&gt;
&lt;p&gt;ServerSocketChannel, TCP 操作, 使用在服务器端.&lt;/p&gt;
&lt;p&gt;五 Buffer&lt;/p&gt;
&lt;p&gt;与 Channel 进行交互时, 我们就需要使用到 Buffer, 即数据从 Buffer读取到 Channel 中, 并且从 Channel 中写入到 Buffer 中.&lt;/p&gt;
&lt;p&gt;Buffer 其实就是一块内存区域,  并提供了一些操作方法让我们能够方便地进行数据的读写.&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;Buffer 类型有:&lt;/p&gt;
&lt;p&gt;ByteBuffer，CharBuffer，DoubleBuffer，FloatBuffer，IntBuffer，LongBuffer，ShortBuffer（就是基本类型啊）&lt;/p&gt;

&lt;p&gt;六 Selector&lt;/p&gt;
&lt;p&gt;Selector 允许一个单一的线程来操作多个 Channel. 如果我们的应用程序中使用了多个 Channel, 那么使用 Selector 很方便的实现这样的目的, 但是因为在一个线程中使用了多个 Channel, 因此也会造成了每个 Channel 传输效率的降低.&lt;/p&gt;
&lt;p&gt;为了使用 Selector, 我们首先需要将 Channel 注册到 Selector 中, 随后调用 Selector 的 select()方法, 这个方法会阻塞, 直到注册在 Selector 中的 Channel 发送可读写事件. 当这个方法返回后, 当前的这个线程就可以处理 Channel 的事件了.&lt;/p&gt;

&lt;p&gt;七 Bootstrap&lt;/p&gt;
&lt;p&gt;Bootstrap 是 Netty 提供的一个便利的工厂类, 我们可以通过它来完成 Netty 的客户端或服务器端的 Netty 初始化.&lt;/p&gt;

</description>
<pubDate>Fri, 04 Jan 2019 06:24:00 +0000</pubDate>
<dc:creator>lgp20151222</dc:creator>
<og:description>一 由于本人的码云太多太乱了，于是决定一个一个的整合到一个springboot项目里面。 附上自己的github项目地址 https://github.com/247292980/spring-boo</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ydymz/p/10219637.html</dc:identifier>
</item>
<item>
<title>Vue的computed计算属性是如何实现的？源码分析 - _记忆</title>
<link>http://www.cnblogs.com/xujiazheng/p/10219601.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xujiazheng/p/10219601.html</guid>
<description>&lt;h3&gt;一个开始&lt;/h3&gt;
&lt;p&gt;有如下代码，full是一个计算属性，开始，他的值是'hello world'，1s后，msg变成了‘I like’， full的值同步变成了'I like world';其原理解析来看一下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&amp;lt;div id=&quot;app&quot;&amp;gt;
    &amp;lt;span :msg=&quot;msg&quot;&amp;gt;&amp;lt;/span&amp;gt;
    &amp;lt;div&amp;gt; {{full}}&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;script src=&quot;./vue.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
    el: &lt;/span&gt;'#app'&lt;span&gt;,
    data: {
        msg: &lt;/span&gt;'hello '&lt;span&gt;,
    },
    computed: {
        full() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.msg + 'world'&lt;span&gt;;
        },
    },
    mounted() {
        setTimeout(() &lt;/span&gt;=&amp;gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.msg = 'I like '&lt;span&gt;;
        }, &lt;/span&gt;1000&lt;span&gt;);
    }
})

&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;从入口开始&lt;/h3&gt;
&lt;p&gt;new Vue时，首先vue执行了_init方法，在这里做了vue的初始化工作，其中执行了一个initState函数，该函数进行的数据处理。&lt;/p&gt;
&lt;p&gt;函数内容如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; initState (vm) {
  vm._watchers &lt;/span&gt;=&lt;span&gt; [];
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; opts =&lt;span&gt; vm.$options;
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (opts.props) { initProps(vm, opts.props); }
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (opts.methods) { initMethods(vm, opts.methods); }
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; data数据绑定，数据驱动核心&lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (opts.data) {
    initData(vm);
  } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
    observe(vm._data &lt;/span&gt;= {}, &lt;span&gt;true&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; asRootData &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;);
  }
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 计算属性绑定&lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (opts.computed) { initComputed(vm, opts.computed); }
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (opts.watch &amp;amp;&amp;amp; opts.watch !==&lt;span&gt; nativeWatch) {
    initWatch(vm, opts.watch);
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中有两个核心流程，data绑定和computed初始化。首先来看一下计算属性初始化干了什么事。&lt;/p&gt;
&lt;h3&gt;计算属性初始化&lt;/h3&gt;
&lt;p&gt;执行initComputed时，会执行以下操作，会为每一个computed属性创建watcher并且执行defineComputed，在开始的示例中，会给full属性new一个watcher。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; initComputed (vm, computed) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建watchers对象缓存watcher&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; watchers = vm._computedWatchers = Object.create(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; key &lt;span&gt;in&lt;/span&gt;&lt;span&gt; computed) {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 计算属性的执行函数/get、set描述对象&lt;/span&gt;
      &lt;span&gt;var&lt;/span&gt; userDef =&lt;span&gt; computed[key];
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; getter = &lt;span&gt;typeof&lt;/span&gt; userDef === 'function' ?&lt;span&gt; userDef : userDef.get;
      watchers[key] &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Watcher(
        vm,
        getter &lt;/span&gt;||&lt;span&gt; noop,
        noop,
        computedWatcherOptions
      );
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!(key &lt;span&gt;in&lt;/span&gt;&lt;span&gt; vm)) {
        defineComputed(vm, key, userDef);
      }
    }
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;defineComputed做了什么呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; defineComputed (
    target,
    key,
    userDef
  ) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 只论述传入的值为函数的情况&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; userDef === 'function'&lt;span&gt;) {
      sharedPropertyDefinition.get &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt; computedGetter () {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; watcher = &lt;span&gt;this&lt;/span&gt;._computedWatchers &amp;amp;&amp;amp; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._computedWatchers[key];
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (watcher) {
          watcher.depend();
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; watcher.evaluate()
        }
      }
      sharedPropertyDefinition.set &lt;/span&gt;=&lt;span&gt; noop;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 进行了属性的描述定义。&lt;/span&gt;
&lt;span&gt;    Object.defineProperty(target, key, sharedPropertyDefinition);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;defineComputed函数会给当前的vue实例挂载计算属性，defineProperty定义其描述，其中get执行的函数如上。&lt;/p&gt;
&lt;p&gt;那么现在回到开始。开始的示例中，定义了full计算属性，并且template中使用了full属性，当模板中渲染full时，做了什么（这是vnode解析并渲染部分）？我们假设会获取full的值并且填充到模板中&lt;/p&gt;
&lt;p&gt;，因此我们会触发了full的get函数，就是以上get代码。&lt;/p&gt;
&lt;p&gt;首先获取当前vue实例中的计算属性对应的监听器Watcher，然后进行depend方法执行，然后执行evaluate()方法，接下来我们走进监听器Watcher。&lt;/p&gt;
&lt;h3&gt;Vue中的Watcher&lt;/h3&gt;
&lt;p&gt;简单介绍watcher的作用，watcher顾名思义，监听器，1.监听什么2.要干什么事，这是我们关心的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; Watcher = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; Watcher (
  vm,
  expOrFn,
  cb,
  options,
  isRenderWatcher
) {
  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.vm =&lt;span&gt; vm;
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isRenderWatcher) {
    vm._watcher &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
  }
  vm._watchers.push(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; options&lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (options) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.deep = !!&lt;span&gt;options.deep;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.computed = !!&lt;span&gt;options.computed;
  } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.deep = &lt;span&gt;this&lt;/span&gt;.user = &lt;span&gt;this&lt;/span&gt;.computed = &lt;span&gt;this&lt;/span&gt;.sync = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
  }
  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.cb =&lt;span&gt; cb;
  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.id = ++uid$1; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; uid for batching&lt;/span&gt;
  &lt;span&gt;this&lt;/span&gt;.active = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.dirty = &lt;span&gt;this&lt;/span&gt;.computed; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; for computed watchers&lt;/span&gt;
  &lt;span&gt;this&lt;/span&gt;.deps =&lt;span&gt; [];
  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.newDeps =&lt;span&gt; [];
  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.depIds = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; _Set();
  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.newDepIds = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; _Set();
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; parse expression for getter&lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; expOrFn === 'function'&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.getter =&lt;span&gt; expOrFn;
  }
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果是计算属性，执行if，如果不是执行else&lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.computed) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.value =&lt;span&gt; undefined;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.dep = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Dep();
  } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.value = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.get();
  }
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上代码是Watcher的入口，看我们关心的入参数：&lt;/p&gt;
&lt;p&gt;vm：当前vue对象&lt;/p&gt;
&lt;p&gt;expOrFn：监听器触发的函数（2.要干什么）&lt;/p&gt;
&lt;p&gt;options：其他参数&lt;/p&gt;
&lt;p&gt;计算属性在new Watcher时，会传入getter函数给expOrFn，从上面代码看，如果expOrFn是函数，就会给getter属性赋值expOrFn，这是没问题的。&lt;/p&gt;
&lt;p&gt;同时计算实行new Watcher时，传递{computed: true}给options， 从以上代码看出，如果是计算属性的watcher，会与其他watcher不同的逻辑。&lt;/p&gt;
&lt;p&gt;计算属性的Watcher会new Dep赋值给this.dep。&lt;/p&gt;
&lt;p&gt;那么Watcher到底是干嘛的，Watcher是监听器，Vue会提供观察者去订阅他，如果观察者发现需要更新某个操作，会通知Watcher，watcher会执行update进行更新。&lt;/p&gt;
&lt;p&gt;那么Dep是什么。&lt;/p&gt;
&lt;h3&gt;Vue中的Dep&lt;/h3&gt;
&lt;p&gt;Dep是个订阅器，观察者想要订阅监听器，需要订阅器Dep来实现。&lt;/p&gt;
&lt;p&gt;同时计算属性的Watcher也会有订阅器，那么他订阅什么呢？同样是其他的Watcher，比如render Watcher， 当计算属性发生变化时，他可以通知render Watcher进行view渲染。&lt;/p&gt;
&lt;h3&gt;回到主链路&lt;/h3&gt;
&lt;p&gt;现在我们知道了，计算属性初始化会new Watcher，并计算属性在渲染到视图层时会触发getter，getter中计算属性会触发自己的watcher的两个函数，depend和evaluate，&lt;/p&gt;
&lt;p&gt;depend函数会将当前的订阅对象添加到自己的订阅器中，此时的订阅对像则是render watcher，此步骤可以自己做详细了解。&lt;/p&gt;
&lt;p&gt;主要的逻辑在evaluate中，evaluate中如果是计算属性并且没有被污染则调用get方法，来看一下get方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
Watcher.prototype.get = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; get () {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将自身设置为订阅对象&lt;/span&gt;
  pushTarget(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; value;
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; vm = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.vm;
  &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
    value &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getter.call(vm, vm);
  } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (e) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.user) {
      handleError(e, vm, (&lt;/span&gt;&quot;getter for watcher \&quot;&quot; + (&lt;span&gt;this&lt;/span&gt;.expression) + &quot;\&quot;&quot;&lt;span&gt;));
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; e
    }
  } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; &quot;touch&quot; every property so they are all tracked as&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; dependencies for deep watching&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.deep) {
      traverse(value);
    }
    popTarget();
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.cleanupDeps();
  }
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; value
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;get方法中，首先，计算属性的watcher会将自己设置为订阅对象，共观察者订阅。然后执行getter，那么this.getter我们前面提到了，是我们写的计算属性函数 () {return this.msg + 'world'}；&lt;/p&gt;
&lt;p&gt;当此getter执行时，我们来想一下。this.msg触发了msg属性的get，那么我们前面提到vue启动了2个核心流程 ，那么这里computed的流程中进入到了data流程中。&lt;/p&gt;
&lt;h3&gt;initData简介&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; initData (vm) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; data =&lt;span&gt; vm.$options.data;
    data &lt;/span&gt;= vm._data = &lt;span&gt;typeof&lt;/span&gt; data === 'function'
      ?&lt;span&gt; getData(data, vm)
      : data &lt;/span&gt;||&lt;span&gt; {};
    observe(data, &lt;/span&gt;&lt;span&gt;true&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; asRootData &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;简化后，initData就做了这个事情，将data包装为观察者，observe方法中最终会针对data中每一个属性做defineReactive操作，并且递归调用。&lt;/p&gt;
&lt;p&gt;defineReactive便是我们双向数据绑定的主要部分。vue将msg属性进行defineReactive重写get／set，并且将它作为一个观察者。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Object.defineProperty(obj, key, {
      enumerable: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
      configurable: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
      get: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; reactiveGetter () {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; value = getter ?&lt;span&gt; getter.call(obj) : val;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Dep.target) {
          dep.depend();
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (childOb) {
            childOb.dep.depend();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Array.isArray(value)) {
              dependArray(value);
            }
          }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; value
      },
      set: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; reactiveSetter (newVal) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; value = getter ?&lt;span&gt; getter.call(obj) : val;
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; eslint-disable no-self-compare &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (newVal === value || (newVal !== newVal &amp;amp;&amp;amp; value !==&lt;span&gt; value)) {
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;
        }
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; eslint-enable no-self-compare &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (&quot;development&quot; !== 'production' &amp;amp;&amp;amp;&lt;span&gt; customSetter) {
          customSetter();
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (setter) {
          setter.call(obj, newVal);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
          val &lt;/span&gt;=&lt;span&gt; newVal;
        }
        childOb &lt;/span&gt;= !shallow &amp;amp;&amp;amp;&lt;span&gt; observe(newVal);
        dep.notify();
      }
    });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当我们执行this.msg， 进行msg的get时，以上get方法执行，并且此时我们说过计算属性full将自己的watcher设置为订阅对象Dep.target，因此msg的get中会执行dep.depend，depend方法中会将当前的Dep.target添加到订阅器中，因此msg的订阅列表会有full的watcher。&lt;/p&gt;
&lt;h3&gt;再次回到主链路&lt;/h3&gt;
&lt;p&gt;前面说到，计算属性在初始化时会创建一个watcher，并且计算属性会被定义为vue实例的一个属性Object.defineProperty，并且其getter会触发自身watcher的两个方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
sharedPropertyDefinition.get = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; computedGetter () {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; watcher = &lt;span&gt;this&lt;/span&gt;._computedWatchers &amp;amp;&amp;amp; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._computedWatchers[key];
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (watcher) {
          watcher.depend();
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; watcher.evaluate()
        }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;getter的返回值是watcher.evaluate();&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Watcher.prototype.evaluate = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; evaluate () {
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.dirty) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.value = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.get();
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.dirty = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
  }
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.value
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;evaluate方法返回了this.value，其实此时value就是计算好的值 hello world。计算的逻辑上面讲述了，连贯的叙述一遍：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在full计算属性getter执行时，会使用this.msg的值，触发this.msg的get，在这里，发现目前拥有被观察对象Dep.target（也就是计算属性full的监听器），msg的订阅器会添加此观察对象进行观察，msg getter返回msg的值，因此full的getter执行完毕，返回了'hello world'，这就是初始化的整个过程。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;计算属性的动态性实现&lt;/h3&gt;
&lt;p&gt;计算属性的初始化已经讲述完成了。那么在msg改变时，full怎么动态改变的呢。&lt;/p&gt;
&lt;p&gt;大概你应该明白么，前面讲到了，msg作为双向数据绑定的属性，会包装为观察者，其有订阅器会订阅监听器。当full计算属性初始化时，msg的订阅器订阅了full的watcher，&lt;/p&gt;
&lt;p&gt;那么在msg值改变时，也就是setter时，我只需要通知full的watcher同步更新就好了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Object.defineProperty(obj, key, {
    enumerable: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
    configurable: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
    get: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; reactiveGetter () {
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; value = getter ?&lt;span&gt; getter.call(obj) : val;
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Dep.target) {
        dep.depend();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (childOb) {
          childOb.dep.depend();
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Array.isArray(value)) {
            dependArray(value);
          }
        }
      }
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; value
    },
    set: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; reactiveSetter (newVal) {
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; value = getter ?&lt;span&gt; getter.call(obj) : val;
      &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; eslint-disable no-self-compare &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt; (newVal === value || (newVal !== newVal &amp;amp;&amp;amp; value !==&lt;span&gt; value)) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;
      }
      &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; eslint-enable no-self-compare &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt; (&quot;development&quot; !== 'production' &amp;amp;&amp;amp;&lt;span&gt; customSetter) {
        customSetter();
      }
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (setter) {
        setter.call(obj, newVal);
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        val &lt;/span&gt;=&lt;span&gt; newVal;
      }
      childOb &lt;/span&gt;= !shallow &amp;amp;&amp;amp;&lt;span&gt; observe(newVal);
      console.log(dep)
      dep.notify();
    }
  });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;dep.notify()执行后，会通知所有观察的watcher进行更新，因此full的watcher自然也会触发更新，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
Watcher.prototype.update = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; update () {
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;$1 = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果是计算属性，执行这里&lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.computed) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.getAndInvoke(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;$1&lt;span&gt;.dep.notify();
    });
  } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.sync) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.run();
  } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
    queueWatcher(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
  }
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;按照我们的代码走，执行到getAndInvoke。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
Watcher.prototype.getAndInvoke = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; getAndInvoke (cb) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; value = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.get();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (
      value &lt;/span&gt;!== &lt;span&gt;this&lt;/span&gt;.value ||&lt;span&gt;
      isObject(value) &lt;/span&gt;||
      &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.deep
    ) {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; set new value&lt;/span&gt;
      &lt;span&gt;var&lt;/span&gt; oldValue = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.value;
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.value =&lt;span&gt; value;
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.dirty = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.user) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
          cb.call(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.vm, value, oldValue);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (e) {
          handleError(e, &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.vm, (&quot;callback for watcher \&quot;&quot; + (&lt;span&gt;this&lt;/span&gt;.expression) + &quot;\&quot;&quot;&lt;span&gt;));
        }
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        cb.call(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.vm, value, oldValue);
      }
    }
  };&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过getAndInvoke方法，我们又一次执行了this.get,此时，msg值已经变为了'I like '，因此这里获取到了新的full值。并执行了cb，cb是什么呢，就是上一步的代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;this&lt;/span&gt;.getAndInvoke(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;$1&lt;span&gt;.dep.notify();
  });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;this$1指向计算属性full的watcher对象自己，this$1.dep是full watcher的订阅器，这段代码就是通知full watcher订阅的watcher进行update。前面说到，计算属性在初始getter时候，进行了&lt;/p&gt;
&lt;p&gt;watcher.depend并添加了订阅对象render watcher，所以在这里，计算属性通知更新的watcher也就是render watcher。 render watcher是什么，是整个vue实例的渲染watcher，承载着vnode&lt;/p&gt;
&lt;p&gt;渲染真实dom的角色。&lt;/p&gt;
&lt;h3&gt;结尾&lt;/h3&gt;
&lt;p&gt;到这里此次分析已经完成了，此次分析从computed初始化为入口，以双向数据绑定为辅助，完成的整个解析思路，以上代码片段均已删减。&lt;/p&gt;
&lt;p&gt;能力有限，源码比较庞大，有些错误的地方请指正。&lt;/p&gt;
</description>
<pubDate>Fri, 04 Jan 2019 06:21:00 +0000</pubDate>
<dc:creator>_记忆</dc:creator>
<og:description>一个开始 有如下代码，full是一个计算属性，开始，他的值是'hello world'，1s后，msg变成了‘I like’， full的值同步变成了'I like world</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xujiazheng/p/10219601.html</dc:identifier>
</item>
<item>
<title>数据的相似性和相异性我们可以怎么分析 - 蕉爷</title>
<link>http://www.cnblogs.com/Alear/p/10219513.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Alear/p/10219513.html</guid>
<description>&lt;p&gt;在数据挖掘中，在确定适用的算法模型之后，应该让我们的数据也能适用我们的算法。例如聚类，最近邻分类等算法，在这些算法中我们往往需要给我们的数据分类，相似的分为一类，不相似的分为不同类。 比如为了精准营销，商店需要建立顾客画像，得出具有类似特征（例如类似的收入，居住区域和年龄，职业等）的顾客组。也就是我们需要一个评判标准，评估对象之间比较的相似或不相似程度的标准，也就是数据的相似性和相异性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据矩阵和相异性矩阵&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;说到相似性和相异性，我们要先说说数据矩阵和相异性矩阵。&lt;/p&gt;
&lt;p&gt;数据矩阵，上个图先看下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/roPWrjQ5nUGibUbuNn04cAdSxIfrpNroQK2YD93xyyZRoiasChoXaq4El1wBKLTS22bG4oodhmnVH3ic4505jAuQg/640?wx_fmt=png&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;396&quot; data-ratio=&quot;0.5353535353535354&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也叫对象-属性结构：这种数据结构用关系表的形式或 n*p ( n 个对象 p 个属)矩阵存放 n 个数据对象，每行对应一个对象 。&lt;/p&gt;
&lt;p&gt;相异性矩阵，如图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/roPWrjQ5nUGibUbuNn04cAdSxIfrpNroQfrnjEy3YqoXKRLTSPfF8h2eK2jW7oqBG4tIqzRicxdRwIZ4xn3UYSHQ/640?wx_fmt=png&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;423&quot; data-ratio=&quot;0.4326241134751773&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也叫对象-对象结构：存放 n 个对象两两之间的邻近度。 d(i,j)是对象i和对象j之间的相异性的度量。一般来说，d(i，j是个非负数)。当i和j高度相似或‘接近’时，它的值接近于0，越不同，这个值越大。&lt;/p&gt;
&lt;p&gt;那么我们也可以由相异性度量推出相似性。例如，对于标称属性来说。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/roPWrjQ5nUGibUbuNn04cAdSxIfrpNroQ2rDxaibOCdaDHsImEnrewRibCXxicn6ciaNOzzrJdnX2yur2XS86rcrvsA/640?wx_fmt=png&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;347&quot; data-ratio=&quot;0.2017291066282421&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们了解完数据矩阵和相异性矩阵后，接下来讲讲不同数据属性的度量相异性的方法。我们在这里详细得讲了数据属性，每种属性的相异性度量是不一样的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;标称属性的临近性度量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;标称属性可以取两个或多个状态。例如color是一个标称属性它可以有5种状态：黄，红，绿，粉红，蓝。两个对象i和j之间的相异性可以根据不匹配率来计算。如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/roPWrjQ5nUGibUbuNn04cAdSxIfrpNroQJia0fJApqGictjTD9oOacWck5KtUU0ytnohWIz1hRu8EiaJRAvicXJKMAg/640?wx_fmt=png&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;272&quot; data-ratio=&quot;0.40441176470588236&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中，i,j 是对象，m 是匹配的数目(就是 i 和 j 取值相同状态的属性数)，而 p 是刻画对象的属性总数&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据属性的相异性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;度量数据属性数据的相异性，有很多种方法。被广泛应用得有欧几里得距离，曼哈顿距离，闵柯夫斯基距。&lt;/p&gt;
&lt;p&gt;计算前提是：我们应该让数据规范化。比如高度有可能是米或者寸，我们应该先统一它们的单位。规范化方法我们在数据预处理的时候会讲。这里我们知道什么是规范化就可以了。&lt;/p&gt;
&lt;p&gt;最流行的距离度量是欧几里得距离公式，如下所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/roPWrjQ5nUGibUbuNn04cAdSxIfrpNroQyibZVcdlIgMj8AaSphdF0Zyy7H8rkIfn4czXsCvg9nuOJfzaf6jxFjQ/640?wx_fmt=png&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;639&quot; data-ratio=&quot;0.14553990610328638&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中Xi1,Xi2分别是i对象的属性们，Xj1,Xj2分别是j对象的属性们。 另一个著名的度量方法是曼哈顿距离，如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/roPWrjQ5nUGibUbuNn04cAdSxIfrpNroQhOb2lOOkqzibBNQZdODtnqAoU63befvlPIe1YA3Tl7ZqpGlarqwrIIw/640?wx_fmt=png&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;608&quot; data-ratio=&quot;0.1118421052631579&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二元属性的邻近性度量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们先来讲讲对称和非对称二元属性刻画的对象间的相异性和相似度度量。那么我们怎么计算两个二元属性之间的相异性呢。&lt;/p&gt;
&lt;p&gt;前文我们说到二元属性只有两种状态：0 或 1.例如患者的属性smoker，1表示抽烟，0表示不抽烟。假如所有的二元属性都看做具有相同的权重，则我们可以得到一个行列表 如图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/roPWrjQ5nUGibUbuNn04cAdSxIfrpNroQsjbebFMOjh8ibLM7hiaPKWBCZmU0Hf2ypqTm7z89bvmticb0eo5mLHpEQ/640?wx_fmt=png&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;515&quot; data-ratio=&quot;0.48349514563106794&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图中， q 是对象 i 和 j 都取 1 的属性数，r 是在对象 i 中取 1，在对象 j 中取 0 的属性数，s 是在对象 i 中取 0，在对象 j 中取 1 的属性数,而 t 是对象 i 和对象 j 中都取 0 的属性数。属性的总数 p，&lt;/p&gt;
&lt;p&gt;其中 p=q+r+s+t。&lt;/p&gt;
&lt;p&gt;对称的二元属性，每个状态都同样重要，因此基于二元属性的相异性称作对称的二元相异性。如果对象i和j的相异性都用对称的二元属性刻画，则i和j的相异性为，如图所示 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/roPWrjQ5nUGibUbuNn04cAdSxIfrpNroQ4jMgGS6mMbD1fqfMQibiaLkpibObYn4SKOmyCP3MQQUnLh5GkqicoNSwNw/640?wx_fmt=png&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;288&quot; data-ratio=&quot;0.25&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么对于不对称的二元属性，，两个状态不是一样重要的。取值为0 的意义很小，我们可以忽略不计，我们称作非对称的二元相似性。所以i和j的相异性为，如图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/roPWrjQ5nUGibUbuNn04cAdSxIfrpNroQjhtnPNv1Ksj95SKuQ7siaLjicNRu3PTz1eLmJib47Sx0PvmRypzbFHZsQ/640?wx_fmt=png&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;273&quot; data-ratio=&quot;0.3553113553113553&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个也叫 Jaccard系数，它是比较常用的一个系数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;接下来我们来看看如何利用我们上面所说的度量方法来度量患者之间的相异性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面是一张患者记录关系表，如图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/roPWrjQ5nUGibUbuNn04cAdSxIfrpNroQg9d5ib0YBTM5NJFGdXSQ7sHic9OHgBPT9zhVP7xVhicPQ4NCyhicHO6rOA/640?wx_fmt=png&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;766&quot; data-ratio=&quot;0.20496083550913838&quot;/&gt;&lt;/p&gt;
&lt;p&gt;假如一个患者的记录表包含属性name(姓名)，gender(性别)，fever(发烧)，cough(咳嗽)，test-1，test-2，test-3，test-4。其中name是对象标识符，gender是对称属性。其它的属性都是非对称二元。&lt;/p&gt;
&lt;p&gt;对于非对称属性，值 Y (yes)和 P (positive)被设置为 1，值 N (no)被设置为 0.假设三个对象之间的距离只基于非对称属性来计算。那么三个患者 Jack,Mary,Jim 两两之间的距离 d(Jack,Jim) = ?&lt;/p&gt;
&lt;p&gt;分析：&lt;/p&gt;
&lt;p&gt;Jack和Jim之间的非对称属性&lt;strong&gt;fever(1,1),cough(0,1),test-1(1,0),test-2(0,0),test-3(0,0),test-4(0,0)&lt;/strong&gt;,根据非对称属性相异性的算法，我们不把(0,0)列入参考， q(1,1)的个数为 1, r(1,0)的个数为1，s(0，1)的个数为 1，根据非对称属性&lt;/p&gt;
&lt;p&gt;d(i,j)=（r+s）/（q+r+s） 得出&lt;/p&gt;
&lt;p&gt;d(Jack,Jim) = （1 + 1）/（1 + 1 + 1） = 0.67&lt;/p&gt;
&lt;p&gt;同理我们能得出：&lt;/p&gt;
&lt;p&gt;d(Jack,Mary)=（0 + 1）/（2 + 0 + 1） = 0.33&lt;/p&gt;
&lt;p&gt;d(Jim,Mary)= （1 + 2）/（1 + 1 + 2） = 0.75&lt;/p&gt;
&lt;p&gt;最后比较得出&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/roPWrjQ5nUGpfzIdDHgOnA7RU5EBibyicZvDOkJlMMt7wpKWR9rXSTDltm6rcMRZ6MNibOnFClPrv5BmtpzDBSFvA/640?wx_fmt=png&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.10224438902743142&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;401&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因此这些度量显示 Jim 和 Mary不大可能患类似的疾病，因此他们具有最高的相异性以及Jcak和Mary最有可能患类似的疾病。&lt;/p&gt;
&lt;p&gt;相信通过上面的介绍，我们基本对如何度量数据的相异性和相似性有一个基本的概念，这是聚类的一个基础算法，有着广泛的应用，后面我们讲聚类的时候会在提及。&lt;/p&gt;

&lt;div id=&quot;MySignature&quot; readability=&quot;7&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1011838/201812/1011838-20181206200744720-814191745.jpg&quot; alt=&quot;&quot; width=&quot;30%&quot;/&gt;&lt;p&gt;更多干货，欢迎关注公众号，哈尔的数据城堡，关注免费领取学习资料~&lt;/p&gt;
&lt;/div&gt;

</description>
<pubDate>Fri, 04 Jan 2019 06:04:00 +0000</pubDate>
<dc:creator>蕉爷</dc:creator>
<og:description>在数据挖掘中，在确定适用的算法模型之后，应该让我们的数据也能适用我们的算法。例如聚类，最近邻分类等算法，在这些算法中我们往往需要给我们的数据分类，相似的分为一类，不相似的分为不同类。 比如为了精准营销</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Alear/p/10219513.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core 微服务初探[2]：熔断降级之Polly - 雨夜朦胧</title>
<link>http://www.cnblogs.com/RainingNight/p/circuitbreaker-polly-in-asp-net-core.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/RainingNight/p/circuitbreaker-polly-in-asp-net-core.html</guid>
<description>&lt;p&gt;当我们从单体架构迁移到微服务模式时，其中一个比较大的变化就是模块（业务，服务等）间的调用方式。在以前，一个业务流程的执行在一个进程中就完成了，但是在微服务模式下可能会分散到2到10个，甚至更多的机器（微服务）上，这必然就要使用网络进行通信。而网络本身就是不可靠的，并随着每个服务都根据自身的情况进行的动态扩容，以及机器漂移等等。可以说，在微服务中，网络连接缓慢，资源繁忙，暂时不可用，服务脱机等异常情况已然变成了一种常态。因此我们必须要有一种机制来保证服务整体的稳定性，而本文要介绍的熔断降级就是一种很好的应对方案。&lt;/p&gt;
&lt;h2 id=&quot;服务熔断&quot;&gt;服务熔断&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/347047/201901/347047-20190102185912337-60852905.jpg&quot; alt=&quot;avalanche&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在介绍熔断之前，我们先来谈谈微服务中的雪崩效应。在微服务中，服务A调用服务B，服务B可能会调用服务C，服务C又可能调用服务D等等，这种情况非常常见。如果服务D出现不可用或响应时间过长，就会导致服务C原来越多的线程处于网络调用等待状态，进而影响到服务B，再到服务A等，最后会耗尽整个系统的资源，导致整体的崩溃，这就是微服务中的“雪崩效应”。&lt;/p&gt;
&lt;p&gt;而熔断机制就是应对雪崩效应的一种链路保护机制。其实，对于熔断这个词我们并不陌生，在日常生活中经常会接触到，比如：家用电力过载保护器，一旦电压过高（发生漏电等），就会立即断电，有些还会自动重试，以便在电压正常时恢复供电。再比如：股票交易中，如果股票指数过高，也会采用熔断机制，暂停股票的交易。同样，在微服务中，熔断机制就是对超时的服务进行短路，直接返回错误的响应信息，而不再浪费时间去等待不可用的服务，防止故障扩展到整个系统，并在检测到该服务正常时恢复调用链路。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/347047/201901/347047-20190102185927579-2001419240.jpg&quot; alt=&quot;IM1L漏电断路器&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;服务降级&quot;&gt;服务降级&lt;/h2&gt;
&lt;p&gt;当我们谈到服务熔断时，经常会提到服务降级，它可以看成是熔断器的一部分，因为在熔断器框架中，通常也会包含服务降级功能。&lt;/p&gt;
&lt;p&gt;降级的目的是当某个服务提供者发生故障的时候，向调用方返回一个错误响应或者替代响应。从整体负荷来考虑，某个服务熔断后，服务器将不再被调用，此时客户端可以自己准备一个本地的fallback回调，这样，虽然服务水平下降，但总比直接挂掉的要好。比如：调用联通接口服务器发送短信失败之后，改用移动短信服务器发送，如果移动短信服务器也失败，则改用电信短信服务器，如果还失败，则返回“失败”响应；再比如：在从推荐商品服务器加载数据的时候，如果失败，则改用从缓存中加载，如果缓存也加载失败，则返回一些本地替代数据。&lt;/p&gt;
&lt;p&gt;在某些情况下，我们也会采取主动降级的机制，比如双十一活动等，由于资源的有限，我们也可以把少部分不重要的服务进行降级，以保证重要服务的稳定，待度过难关，再重新开启。&lt;/p&gt;
&lt;h2 id=&quot;polly基本使用&quot;&gt;Polly基本使用&lt;/h2&gt;
&lt;p&gt;在.Net Core中有一个被.Net基金会认可的库&lt;strong&gt;Polly&lt;/strong&gt;，它一种弹性和瞬态故障处理库，可以用来简化对服务熔断降级的处理。主要包含以下功能：重试(Retry)，断路器(Circuit-breaker)，超时检测(Timeout)，舱壁隔离(Bulkhead Isolation)， 缓存（Cache），回退(FallBack)。&lt;/p&gt;
&lt;p&gt;该项目作者现已成为.NET基金会一员，一直在不停的迭代和更新，项目地址: &lt;a href=&quot;https://github.com/App-vNext/Polly&quot; class=&quot;uri&quot;&gt;https://github.com/App-vNext/Polly&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;策略&quot;&gt;策略&lt;/h3&gt;
&lt;p&gt;在Polly中，有一个重要的概念：&lt;strong&gt;Policy&lt;/strong&gt;，策略有“故障定义”和“故障恢复”两部分组成。&lt;strong&gt;故障&lt;/strong&gt;是指异常、非预期的返回值等情况，而&lt;strong&gt;动作&lt;/strong&gt;则包括重试（Retry）、熔断（Circuit-Breaker）、Fallback（降级）等。&lt;/p&gt;
&lt;h4 id=&quot;故障定义&quot;&gt;故障定义&lt;/h4&gt;
&lt;p&gt;故障也可以说是触发条件，它使用&lt;code&gt;Handle&amp;lt;T&amp;gt;&lt;/code&gt;来定义，表示在什么情况下，才对其进行处理（熔断，降级，重试等）。&lt;/p&gt;
&lt;p&gt;一个简单的异常故障定义如下：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;Policy.Handle&amp;lt;HttpRequestException&amp;gt;()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上，表示当我们的代码触发&lt;code&gt;HttpRequestException&lt;/code&gt;异常时，才进行处理。&lt;/p&gt;
&lt;p&gt;我们也可以对异常的信息进行过滤：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;Policy.Handle&amp;lt;SqlException&amp;gt;(ex =&amp;gt; ex.Number == 1205)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上，只有触发&lt;code&gt;SqlException&lt;/code&gt;异常，并且其异常号为&lt;code&gt;1205&lt;/code&gt;的时候才进行处理。&lt;/p&gt;
&lt;p&gt;如果我们希望同时处理多种异常，可以使用&lt;code&gt;Or&amp;lt;T&amp;gt;&lt;/code&gt;来实现：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;Policy.Handle&amp;lt;HttpRequestException&amp;gt;().Or&amp;lt;OperationCanceledException&amp;gt;()

Policy.Handle&amp;lt;SqlException&amp;gt;(ex =&amp;gt; ex.Number == 1205).Or&amp;lt;ArgumentException&amp;gt;(ex =&amp;gt; ex.ParamName == &quot;example&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;除此之外，我们还可以根据返回结果进行故障定义：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;Policy.HandleResult&amp;lt;HttpResponseMessage&amp;gt;(r =&amp;gt; r.StatusCode == HttpStatusCode.NotFound)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上，当返回值为&lt;code&gt;HttpResponseMessage&lt;/code&gt;，并且其&lt;code&gt;StatusCode&lt;/code&gt;为&lt;code&gt;NotFound&lt;/code&gt;时，才对其进行处理。更多用法参考：&lt;a href=&quot;https://github.com/App-vNext/Polly#usage--fault-handling-policies&quot;&gt;usage--fault-handling-policies&lt;/a&gt;。&lt;/p&gt;
&lt;h4 id=&quot;故障恢复&quot;&gt;故障恢复&lt;/h4&gt;
&lt;p&gt;当定义了故障后，要考虑便是如何对故障进行恢复了，Polly中常用的有以下几种恢复策略：&lt;/p&gt;
&lt;h3 id=&quot;重试retry策略&quot;&gt;重试(Retry)策略&lt;/h3&gt;
&lt;p&gt;重试就是指Polly在调用失败时捕获我们指定的异常，并重新发起调用，如果重试成功，那么对于调用者来说，就像没有发生过异常一样。在网络调用中经常出现瞬时故障，那么重试机制就非常重要。&lt;/p&gt;
&lt;p&gt;一个简单的重试策略定义如下：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;// 当发生HttpRequestException异常时，重试3次
var retryPolicy = Policy.Handle&amp;lt;HttpRequestException&amp;gt;().Retry(3);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有些情况下，如果故障恢复的太慢，我们重试的过快是没有任何任何意义的，这时可以指定重试的时间间隔：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;Policy.Handle&amp;lt;HttpRequestException&amp;gt;().WaitAndRetryAsync(5, retryAttempt =&amp;gt; TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上，重试五次，并且重试时间指数级增加。&lt;/p&gt;
&lt;h3 id=&quot;超时timeout策略&quot;&gt;超时(Timeout)策略&lt;/h3&gt;
&lt;p&gt;超时是我们比较常见的，比如&lt;code&gt;HttpClient&lt;/code&gt;就可以设置超时时间，如果在指定的时间内还没有返回，就触发一个&lt;code&gt;TimeoutException&lt;/code&gt;异常，而&lt;strong&gt;Polly&lt;/strong&gt;的超时机制与其类似，只不过超时时触发的是一个&lt;code&gt;TimeoutRejectedException&lt;/code&gt;异常。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;// 如果30秒种内没有执行完成，就触发`TimeoutRejectedException`异常
Policy.TimeoutAsync(30);

// 设置超时回调
Policy.TimeoutAsync(30, onTimeout: (context, timespan, task) =&amp;gt;
{
    // do something 
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于超时策略本身就是抛出一个超时异常，所以不需要设置触发条件。&lt;/p&gt;
&lt;h3 id=&quot;回退fallback策略&quot;&gt;回退(FallBack)策略&lt;/h3&gt;
&lt;p&gt;回退也称服务降级，用来指定发生故障时的备用方案。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;Policy&amp;lt;string&amp;gt;.Handle&amp;lt;HttpRequestException&amp;gt;().FallbackAsync(&quot;substitute data&quot;, (exception, context) =&amp;gt;
{
    // do something 
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上，如果触发&lt;code&gt;HttpRequestException&lt;/code&gt;异常时，就返回固定的&lt;code&gt;substitute data&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;熔断circuit-breaker策略&quot;&gt;熔断(Circuit-breaker)策略&lt;/h3&gt;
&lt;p&gt;断路器用于在服务多次不可用时，快速响应失败，保护系统故障免受过载。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;Policy.Handle&amp;lt;HttpRequestException&amp;gt;().Or&amp;lt;TimeoutException&amp;gt;()
    .CircuitBreakerAsync(
        // 熔断前允许出现几次错误
        exceptionsAllowedBeforeBreaking: 3,
        // 熔断时间
        durationOfBreak: TimeSpan.FromSeconds(100),
        // 熔断时触发
        onBreak: (ex, breakDelay) =&amp;gt;
        {
            // do something 
        },
        // 熔断恢复时触发
        onReset: () =&amp;gt;
        {
            // do something 
        },
        // 在熔断时间到了之后触发
        onHalfOpen: () =&amp;gt;
        {
            // do something 
        }
    );&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上，如果我们的业务代码连续失败3次，就触发熔断（onBreak），就不会再调用我们的业务代码，而是直接抛出&lt;code&gt;BrokenCircuitException&lt;/code&gt;异常。当熔断时间（100s）过后，切换为&lt;code&gt;HalfOpen&lt;/code&gt;状态，触发&lt;code&gt;onHalfOpen&lt;/code&gt;事件，此时会再调用一次我们的业务代码，如果调用成功，则触发&lt;code&gt;onReset&lt;/code&gt;事件，并解除熔断，恢复初始状态，否则立即切回熔断状态。&lt;/p&gt;
&lt;p&gt;更多策略的用法查看：&lt;a href=&quot;https://github.com/App-vNext/Polly#usage--general-resilience-policies&quot;&gt;usage--general-resilience-policie&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;执行&quot;&gt;执行&lt;/h3&gt;
&lt;p&gt;在上面的示例中，我们熟悉了各种策略的定义，那么接下来就是执行它。也就是使用&lt;code&gt;Polly&lt;/code&gt;包裹我们的业务代码，&lt;code&gt;Polly&lt;/code&gt;会拦截业务代码中的故障，并根据指定的策略进行恢复。&lt;/p&gt;
&lt;p&gt;最简单的策略执行方式如下：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var policy = /*策略定义*/;
var res = await policy.ExecuteAsync(/*业务代码*/);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果需要同时指定多个策略，可以使用&lt;code&gt;Policy.Wrap&lt;/code&gt;来完成：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;Policy.Wrap(retry, breaker, timeout).ExecuteAsync(/*业务代码*/);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实&lt;code&gt;Warp&lt;/code&gt;本质就是多个策略的嵌套执行，使用如下写法效果是一样的：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;fallback.Execute(() =&amp;gt; waitAndRetry.Execute(() =&amp;gt; breaker.Execute(action)));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于&lt;code&gt;Polly&lt;/code&gt;更详细的用法可以查看Polly Github上的&lt;a href=&quot;https://github.com/App-vNext/Polly/wiki&quot; class=&quot;uri&quot;&gt;https://github.com/App-vNext/Polly/wiki&lt;/a&gt;，本文就不再过多介绍。&lt;/p&gt;
&lt;h2 id=&quot;polly熔断降级实战&quot;&gt;Polly熔断降级实战&lt;/h2&gt;
&lt;p&gt;场景：轮询调用服务A和服务B，单次调用时间不得超过1s，调用失败时自动切换到另外一个服务重试一次，如果都失败，进行优雅的降级，返回模拟数据，并在2个服务都多次失败后进行熔断。&lt;/p&gt;
&lt;p&gt;首先创建一个ASP.NET Core Console程序，命名为PollyDemo。&lt;/p&gt;
&lt;p&gt;然后引入Polly的官方Nuge包：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;dotnet add package Polly&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在我们首先定义一个超时策略：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var timeoutPolicy = Policy.TimeoutAsync(1, (context, timespan, task) =&amp;gt;
{
    Console.WriteLine(&quot;It's Timeout, throw TimeoutRejectedException.&quot;);
    return Task.CompletedTask;
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以根据实际情况来设置超时时间，我这里为了方便测试，就设置为1s。&lt;/p&gt;
&lt;p&gt;然后定义重试策略：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var retryPolicy = Policy.Handle&amp;lt;HttpRequestException&amp;gt;().Or&amp;lt;TimeoutException&amp;gt;().Or&amp;lt;TimeoutRejectedException&amp;gt;()
    .WaitAndRetryAsync(
        retryCount: 2,
        sleepDurationProvider: retryAttempt =&amp;gt;
        {
            var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1));
            Console.WriteLine(DateTime.Now.ToString() + &quot;-Retry:[&quot; + retryAttempt + &quot;], wait &quot; + waitSeconds + &quot;s!&quot;);
            return waitSeconds;
        });&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再定义一个熔断策略：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var circuitBreakerPolicy = Policy.Handle&amp;lt;HttpRequestException&amp;gt;().Or&amp;lt;TimeoutException&amp;gt;().Or&amp;lt;TimeoutRejectedException&amp;gt;()
    .CircuitBreakerAsync(
        // 熔断前允许出现几次错误
        exceptionsAllowedBeforeBreaking: 2,
        // 熔断时间
        durationOfBreak: TimeSpan.FromSeconds(3),
        // 熔断时触发
        onBreak: (ex, breakDelay) =&amp;gt;
        {
            Console.WriteLine(DateTime.Now.ToString() + &quot;Breaker-&amp;gt;Breaking the circuit for &quot; + breakDelay.TotalMilliseconds + &quot;ms! Exception: &quot;, ex.Message);
        },
        // 熔断恢复时触发
        onReset: () =&amp;gt;
        {
            Console.WriteLine(DateTime.Now.ToString() + &quot;Breaker-&amp;gt;Call ok! Closed the circuit again.&quot;);
        },
        // 在熔断时间到了之后触发
        onHalfOpen: () =&amp;gt;
        {
            Console.WriteLine(DateTime.Now.ToString() + &quot;Breaker-&amp;gt;Half-open, next call is a trial.&quot;);
        }
    );&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上，连续错误2次就熔断3秒。&lt;/p&gt;
&lt;p&gt;最后，再定义一个回退策略：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var fallbackPolicy = Policy&amp;lt;string&amp;gt;.Handle&amp;lt;Exception&amp;gt;()
    .FallbackAsync(
        fallbackValue: &quot;substitute data&quot;,
        onFallbackAsync: (exception, context) =&amp;gt;
        {
            Console.WriteLine(&quot;It's Fallback,  Exception-&amp;gt;&quot; + exception.Exception.Message + &quot;, return substitute data.&quot;);
            return Task.CompletedTask;
        });&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们的业务代码如下：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;private List&amp;lt;string&amp;gt; services = new List&amp;lt;string&amp;gt; { &quot;localhost:5001&quot;, &quot;localhost:5002&quot; };
private int serviceIndex = 0;
private HttpClient client = new HttpClient();

private Task&amp;lt;string&amp;gt; HttpInvokeAsync()
{
    if (serviceIndex &amp;gt;= services.Count)
    {
        serviceIndex = 0;
    }
    var service = services[serviceIndex++];
    Console.WriteLine(DateTime.Now.ToString() + &quot;-Begin Http Invoke-&amp;gt;&quot; + service);
    return client.GetStringAsync(&quot;http://&quot; + service + &quot;/api/values&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里方便测试，直接写死了两个服务，对其轮询调用，在生产环境中可以参考上一篇《&lt;a href=&quot;https://www.cnblogs.com/RainingNight/p/servicediscovery-consul-in-asp-net-core.html&quot;&gt;服务发现之Consul&lt;/a&gt;》来实现服务发现和负载均衡。&lt;/p&gt;
&lt;p&gt;现在，我们组合这些策略来调用我们的业务代码：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;for (int i = 0; i &amp;lt; 100; i++)
{
    Console.WriteLine(DateTime.Now.ToString() + &quot;-Run[&quot; + i + &quot;]-----------------------------&quot;);
    var res = await fallbackPolicy.WrapAsync(Policy.WrapAsync(circuitBreakerPolicy, retryPolicy, timeoutPolicy)).ExecuteAsync(HttpInvokeAsync);
    Console.WriteLine(DateTime.Now.ToString() + &quot;-Run[&quot; + i + &quot;]-&amp;gt;Response&quot; + &quot;: Ok-&amp;gt;&quot; + res);
    await Task.Delay(1000);
    Console.WriteLine(&quot;--------------------------------------------------------------------------------------------------------------------&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上，循环执行100次，策略的执行是非常简单的，唯一需要注意的就是调用的顺序：如上是依次从右到左进行调用，首先是进行超时的判断，一旦超时就触发&lt;code&gt;TimeoutRejectedException&lt;/code&gt;异常，然后就进入到了重试策略中，如果重试了一次就成功了，那就直接返回，不再触发其他策略，否则就进入到熔断策略中：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/347047/201901/347047-20190102185946732-751830222.png&quot; alt=&quot;breaking&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图，服务A（localhost:5001）和服务B（localhost:5001），都没有启动，所以会一直调用失败，最后熔断器开启，并最终被降级策略拦截，返回&lt;code&gt;substitute data&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;现在我们启动服务A，可以看到服务会自动恢复，解除熔断状态：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/347047/201901/347047-20190102185959928-1634452623.png&quot; alt=&quot;reset&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;本篇首先讲解了一下微服务中熔断、降级的基本概念，然后对.Net Core中的&lt;code&gt;Polly&lt;/code&gt;框架做了一个基本介绍，最后基于&lt;code&gt;Polly&lt;/code&gt;演示了如何在.NET Core中实现熔断降级来提高服务质量。而熔断本质上只是一个保护壳，在周围出现异常的时候保全自身，从长远来看，平时定期做好压力测试才能防范于未然，降低触发熔断的次数。如果清楚的知道每个服务的承载量，并做好服务限流的控制，就能将“高压”下触发熔断的概率降到最低了。那下一篇就来介绍一下速率限制（Rate Limiting），敬请期待！&lt;/p&gt;
&lt;p&gt;附本篇示例源码地址：&lt;a href=&quot;https://github.com/RainingNight/AspNetCoreSample/tree/master/src/Microservice/CircuitBreaker/PollyDemo&quot; class=&quot;uri&quot;&gt;https://github.com/RainingNight/AspNetCoreSample/tree/master/src/Microservice/CircuitBreaker/PollyDemo&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
</description>
<pubDate>Fri, 04 Jan 2019 05:27:00 +0000</pubDate>
<dc:creator>雨夜朦胧</dc:creator>
<og:description>当我们从单体架构迁移到微服务模式时，其中一个比较大的变化就是模块（业务，服务等）间的调用方式。在以前，一个业务流程的执行在一个进程中就完成了，但是在微服务模式下可能会分散到2到10个，甚至更多的机器（</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/RainingNight/p/circuitbreaker-polly-in-asp-net-core.html</dc:identifier>
</item>
<item>
<title>Mysql高性能优化规范建议 - 听风。</title>
<link>http://www.cnblogs.com/huchong/p/10219318.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huchong/p/10219318.html</guid>
<description>&lt;ol readability=&quot;4&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;所有数据库对象名称必须使用小写字母并用下划线分割&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;所有数据库对象名称禁止使用mysql保留关键字（如果表名中包含关键字查询时，需要将其用单引号括起来）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;数据库对象的命名要能做到见名识意，并且最后不要超过32个字符&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;临时库表必须以tmp_为前缀并以日期为后缀，备份表必须以bak_为前缀并以日期(时间戳)为后缀&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;所有存储相同数据的列名和列类型必须一致（一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;所有表必须使用innodb存储引擎&quot;&gt;1. 所有表必须使用Innodb存储引擎&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;没有特殊要求（即Innodb无法满足的功能如：列存储，存储空间数据等）的情况下，所有表必须使用Innodb存储引擎（mysql5.5之前默认使用Myisam，5.6以后默认的为Innodb）
Innodb 支持事务，支持行级锁，更好的恢复性，高并发下性能更好&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;数据库和表的字符集统一使用utf8&quot;&gt;2. 数据库和表的字符集统一使用UTF8&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;兼容性更好，统一字符集可以避免由于字符集转换产生的乱码，不同的字符集进行比较前需要进行转换会造成索引失效&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;所有表和字段都需要添加注释&quot;&gt;3. 所有表和字段都需要添加注释&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;使用comment从句添加表和列的备注
从一开始就进行数据字典的维护&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;尽量控制单表数据量的大小建议控制在500万以内&quot;&gt;4. 尽量控制单表数据量的大小，建议控制在500万以内&lt;/h2&gt;
&lt;p&gt;500万并不是Mysql数据库的限制，过大会造成修改表结构，备份，恢复都会有很大的问题&lt;br/&gt;可以用历史数据归档（应用于日志数据），分库分表（应用于业务数据）等手段来控制数据量大小&lt;/p&gt;
&lt;h2 id=&quot;谨慎使用mysql分区表&quot;&gt;5. 谨慎使用Mysql分区表&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;分区表在物理上表现为多个文件，在逻辑上表现为一个表
谨慎选择分区键，跨分区查询效率可能更低
建议采用物理分表的方式管理大数据&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;尽量做到冷热数据分离减小表的宽度&quot;&gt;6. 尽量做到冷热数据分离，减小表的宽度&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;Mysql限制每个表最多存储4096列，并且每一行数据的大小不能超过65535字节

减少磁盘IO,保证热数据的内存缓存命中率（表越宽，把表装载进内存缓冲池时所占用的内存也就越大,也会消耗更多的IO）
更有效的利用缓存，避免读入无用的冷数据
经常一起使用的列放到一个表中（避免更多的关联操作）&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;禁止在表中建立预留字段&quot;&gt;7. 禁止在表中建立预留字段&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;预留字段的命名很难做到见名识义
预留字段无法确认存储的数据类型，所以无法选择合适的类型
对预留字段类型的修改，会对表进行锁定&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;禁止在数据库中存储图片文件等大的二进制数据&quot;&gt;8. 禁止在数据库中存储图片，文件等大的二进制数据&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;通常文件很大，会短时间内造成数据量快速增长，数据库进行数据库读取时，通常会进行大量的随机IO操作，文件很大时，IO操作很耗时
通常存储于文件服务器，数据库只存储文件地址信息&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;禁止在线上做数据库压力测试&quot;&gt;9. 禁止在线上做数据库压力测试&lt;/h2&gt;
&lt;h2 id=&quot;禁止从开发环境测试环境直接连接生成环境数据库&quot;&gt;10. 禁止从开发环境，测试环境直接连接生成环境数据库&lt;/h2&gt;

&lt;h2 id=&quot;优先选择符合存储需要的最小的数据类型&quot;&gt;1. 优先选择符合存储需要的最小的数据类型&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;原因是：列的字段越大，建立索引时所需要的空间也就越大，这样一页中所能存储的索引节点的数量也就越少也越少，在遍历时所需要的IO次数也就越多，
索引的性能也就越差
方法：&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;将字符串转换成数字类型存储，如：将IP地址转换成整形数据&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;mysql提供了两个方法来处理ip地址&lt;/p&gt;
&lt;p&gt;inet_aton 把ip转为无符号整型(4-8位)&lt;br/&gt;inet_ntoa 把整型的ip转为地址&lt;/p&gt;
&lt;p&gt;插入数据前，先用inet_aton把ip地址转为整型，可以节省空间&lt;br/&gt;显示数据时，使用inet_ntoa把整型的ip地址转为地址显示即可。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对于非负型的数据（如自增ID、整型IP）来说，要优先使用无符号整型来存储&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因为：无符号相对于有符号可以多出一倍的存储空间&lt;br/&gt;SIGNED INT -2147483648~2147483647&lt;br/&gt;UNSIGNED INT 0~4294967295&lt;/p&gt;
&lt;p&gt;VARCHAR(N)中的N代表的是字符数，而不是字节数&lt;br/&gt;使用UTF8存储255个汉字 Varchar(255)=765个字节&lt;/p&gt;
&lt;p&gt;过大的长度会消耗更多的内存&lt;/p&gt;
&lt;h2 id=&quot;避免使用textblob数据类型最常见的text类型可以存储64k的数据&quot;&gt;2. 避免使用TEXT、BLOB数据类型，最常见的TEXT类型可以存储64k的数据&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;建议把BLOB或是TEXT列分离到单独的扩展表中&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Mysql内存临时表不支持TEXT、BLOB这样的大数据类型，如果查询中包含这样的数据，在排序等操作时，就不能使用内存临时表，必须使用磁盘临时表进行&lt;br/&gt;而且对于这种数据，Mysql还是要进行二次查询，会使sql性能变得很差，但是不是说一定不能使用这样的数据类型&lt;/p&gt;
&lt;p&gt;如果一定要使用，建议把BLOB或是TEXT列分离到单独的扩展表中，查询时一定不要使用select * 而只需要取出必要的列，不需要TEXT列的数据时不要对该列进行查询&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;TEXT或BLOB类型只能使用前缀索引&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因为MySQL对索引字段长度是有限制的，所以TEXT类型只能使用前缀索引，并且TEXT列上是不能有默认值的&lt;/p&gt;
&lt;h2 id=&quot;避免使用enum类型&quot;&gt;3. 避免使用ENUM类型&lt;/h2&gt;
&lt;p&gt;修改ENUM值需要使用ALTER语句&lt;br/&gt;ENUM类型的ORDER BY操作效率低，需要额外操作&lt;br/&gt;禁止使用数值作为ENUM的枚举值&lt;/p&gt;
&lt;h2 id=&quot;尽可能把所有列定义为not-null&quot;&gt;4. 尽可能把所有列定义为NOT NULL&lt;/h2&gt;
&lt;p&gt;原因：&lt;br/&gt;索引NULL列需要额外的空间来保存，所以要占用更多的空间&lt;br/&gt;进行比较和计算时要对NULL值做特别的处理&lt;/p&gt;
&lt;h2 id=&quot;使用timestamp4个字节或datetime类型8个字节存储时间&quot;&gt;5. 使用TIMESTAMP（4个字节）或DATETIME类型（8个字节）存储时间&lt;/h2&gt;
&lt;p&gt;TIMESTAMP 存储的时间范围 1970-01-01 00:00:01 ~ 2038-01-19-03:14:07&lt;br/&gt;TIMESTAMP 占用4字节和INT相同，但比INT可读性高&lt;br/&gt;超出TIMESTAMP取值范围的使用DATETIME类型存储&lt;/p&gt;
&lt;p&gt;经常会有人用字符串存储日期型的数据（不正确的做法）&lt;br/&gt;缺点1：无法用日期函数进行计算和比较&lt;br/&gt;缺点2：用字符串存储日期要占用更多的空间&lt;/p&gt;
&lt;h2 id=&quot;同财务相关的金额类数据必须使用decimal类型&quot;&gt;6. 同财务相关的金额类数据必须使用decimal类型&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;非精准浮点：float,double&lt;/li&gt;
&lt;li&gt;精准浮点：decimal&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Decimal类型为精准浮点数，在计算时不会丢失精度&lt;br/&gt;占用空间由定义的宽度决定，每4个字节可以存储9位数字，并且小数点要占用一个字节&lt;br/&gt;可用于存储比bigint更大的整型数据&lt;/p&gt;

&lt;h2 id=&quot;限制每张表上的索引数量建议单张表索引不超过5个&quot;&gt;1. 限制每张表上的索引数量，建议单张表索引不超过5个&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;索引并不是越多越好！索引可以提高效率同样可以降低效率

索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率

因为mysql优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个
索引都可以用于查询，就会增加mysql优化器生成执行计划的时间，同样会降低查询性能 &lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;禁止给表中的每一列都建立单独的索引&quot;&gt;2. 禁止给表中的每一列都建立单独的索引&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;5.6版本之前，一个sql只能使用到一个表中的一个索引，5.6以后，虽然有了合并索引的优化方式，但是还是远远没有使用一个联合索引的查询方式好&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;每个innodb表必须有个主键&quot;&gt;3. 每个Innodb表必须有个主键&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;Innodb是一种索引组织表：数据的存储的逻辑顺序和索引的顺序是相同的
每个表都可以有多个索引，但是表的存储顺序只能有一种
Innodb是按照主键索引的顺序来组织表的

不要使用更新频繁的列作为主键，不适用多列主键（相当于联合索引）
不要使用UUID,MD5,HASH,字符串列作为主键（无法保证数据的顺序增长）
主键建议使用自增ID值&lt;/code&gt;
&lt;/pre&gt;

&lt;ol readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;出现在SELECT、UPDATE、DELETE语句的WHERE从句中的列&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;包含在ORDER BY、GROUP BY、DISTINCT中的字段&lt;/p&gt;
&lt;p&gt;并不要将符合1和2中的字段的列都建立一个索引， 通常将1、2中的字段建立联合索引效果更好&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多表join的关联列&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;
&lt;code&gt;建立索引的目的是：希望通过索引进行数据查找，减少随机IO，增加查询性能 ，索引能过滤出越少的数据，则从磁盘中读入的数据也就越少
 &lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;区分度最高的放在联合索引的最左侧（区分度=列中不同值的数量/列的总行数）&lt;/li&gt;
&lt;li&gt;尽量把字段长度小的列放在联合索引的最左侧（因为字段长度越小，一页能存储的数据量越大，IO性能也就越好）&lt;/li&gt;
&lt;li&gt;使用最频繁的列放到联合索引的左侧（这样可以比较少的建立一些索引）&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;
&lt;code&gt;重复索引示例：primary key(id)、index(id)、unique index(id)
冗余索引示例：index(a,b,c)、index(a,b)、index(a)&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;覆盖索引：就是包含了所有查询字段(where,select,ordery by,group by包含的字段)的索引&lt;/p&gt;
&lt;p&gt;覆盖索引的好处:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;避免Innodb表进行索引的二次查询&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Innodb是以聚集索引的顺序来存储的，对于Innodb来说，二级索引在叶子节点中所保存的是行的主键信息，&lt;br/&gt;如果是用二级索引查询数据的话，在查找到相应的键值后，还要通过主键进行二次查询才能获取我们真实所需要的数据&lt;br/&gt;而在覆盖索引中，二级索引的键值中可以获取所有的数据，避免了对主键的二次查询 ，减少了IO操作，提升了查询效率&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;可以把随机IO变成顺序IO加快查询效率&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;由于覆盖索引是按键值的顺序存储的，对于IO密集型的范围查找来说，对比随机从磁盘读取每一行的数据IO要少的多，&lt;br/&gt;因此利用覆盖索引在访问时也可以把磁盘的随机读取的IO转变成索引查找的顺序IO&lt;/p&gt;

&lt;h2 id=&quot;尽量避免使用外键约束&quot;&gt;尽量避免使用外键约束&lt;/h2&gt;
&lt;p&gt;不建议使用外键约束（foreign key），但一定要在表与表之间的关联键上建立索引&lt;br/&gt;外键可用于保证数据的参照完整性，但建议在业务端实现&lt;br/&gt;外键会影响父表和子表的写操作从而降低性能&lt;/p&gt;

&lt;h2 id=&quot;建议使用预编译语句进行数据库操作&quot;&gt;1. 建议使用预编译语句进行数据库操作&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;预编译语句可以重复使用这些计划，减少SQL编译所需要的时间，还可以解决动态SQL所带来的SQL注入的问题
只传参数，比传递SQL语句更高效
相同语句可以一次解析，多次使用，提高处理效率&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;避免数据类型的隐式转换&quot;&gt;2. 避免数据类型的隐式转换&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;隐式转换会导致索引失效
如:  select name,phone from customer where id = '111';&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;充分利用表上已经存在的索引&quot;&gt;3. 充分利用表上已经存在的索引&lt;/h2&gt;
&lt;h3 id=&quot;避免使用双号的查询条件&quot;&gt;避免使用双%号的查询条件。&lt;/h3&gt;
&lt;p&gt;如 a like '%123%'，（如果无前置%,只有后置%，是可以用到列上的索引的）&lt;/p&gt;
&lt;h3 id=&quot;一个sql只能利用到复合索引中的一列进行范围查询&quot;&gt;一个SQL只能利用到复合索引中的一列进行范围查询&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;如 有 a,b,c列的联合索引，在查询条件中有a列的范围查询，则在b,c列上的索引将不会被用到，
在定义联合索引时，如果a列要用到范围查找的话，就要把a列放到联合索引的右侧&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;使用left-join-或-not-exists-来优化not-in-操作&quot;&gt;使用left join 或 not exists 来优化not in 操作&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;因为not in 也通常会使用索引失效&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;数据库设计时应该要对以后扩展进行考虑&quot;&gt;4. 数据库设计时，应该要对以后扩展进行考虑&lt;/h2&gt;
&lt;h2 id=&quot;程序连接不同的数据库使用不同的账号进制跨库查询&quot;&gt;5. 程序连接不同的数据库使用不同的账号，进制跨库查询&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;为数据库迁移和分库分表留出余地
降低业务耦合度
避免权限过大而产生的安全风险&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;禁止使用select-必须使用select-查询&quot;&gt;6. 禁止使用SELECT * 必须使用SELECT &amp;lt;字段列表&amp;gt; 查询&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;原因：
    消耗更多的CPU和IO以网络带宽资源
    无法使用覆盖索引
    可减少表结构变更带来的影响&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;禁止使用不含字段列表的insert语句&quot;&gt;7. 禁止使用不含字段列表的INSERT语句&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;如： insert into values ('a','b','c');
应使用 insert into t(c1,c2,c3) values ('a','b','c');&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;避免使用子查询可以把子查询优化为join操作&quot;&gt;8. 避免使用子查询，可以把子查询优化为join操作&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;通常子查询在in子句中，且子查询中为简单SQL(不包含union、group by、order by、limit从句)时,才可以把子查询转化为关联查询进行优化

子查询性能差的原因：

 子查询的结果集无法使用索引，通常子查询的结果集会被存储到临时表中，不论是内存临时表还是磁盘临时表都不会存在索引，所以查询性能会受到一定的影响
 特别是对于返回结果集比较大的子查询，其对查询性能的影响也就越大
 由于子查询会产生大量的临时表也没有索引，所以会消耗过多的CPU和IO资源，产生大量的慢查询&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;避免使用join关联太多的表&quot;&gt;9. 避免使用JOIN关联太多的表&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;对于Mysql来说，是存在关联缓存的，缓存的大小可以由join_buffer_size参数进行设置
在Mysql中，对于同一个SQL多关联（join）一个表，就会多分配一个关联缓存，如果在一个SQL中关联的表越多，
所占用的内存也就越大

如果程序中大量的使用了多表关联的操作，同时join_buffer_size设置的也不合理的情况下，就容易造成服务器内存溢出的情况，
就会影响到服务器数据库性能的稳定性

同时对于关联操作来说，会产生临时表操作，影响查询效率
Mysql最多允许关联61个表，建议不超过5个&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;减少同数据库的交互次数&quot;&gt;10. 减少同数据库的交互次数&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;数据库更适合处理批量操作
合并多个相同的操作到一起，可以提高处理效率&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;对应同一列进行or判断时使用in代替or&quot;&gt;11. 对应同一列进行or判断时，使用in代替or&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;in 的值不要超过500个
in 操作可以更有效的利用索引，or大多数情况下很少能利用到索引&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;禁止使用order-by-rand-进行随机排序&quot;&gt;12. 禁止使用order by rand() 进行随机排序&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;会把表中所有符合条件的数据装载到内存中，然后在内存中对所有数据根据随机生成的值进行排序，并且可能会对每一行都生成一个随机值，如果满足条件的数据集非常大，
就会消耗大量的CPU和IO及内存资源
推荐在程序中获取一个随机值，然后从数据库中获取数据的方式&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;where从句中禁止对列进行函数转换和计算&quot;&gt;13. WHERE从句中禁止对列进行函数转换和计算&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;对列进行函数转换或计算时会导致无法使用索引

不推荐：
where date(create_time)='20190101'
推荐：
where create_time &amp;gt;= '20190101' and create_time &amp;lt; '20190102'&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;在明显不会有重复值时使用union-all-而不是union&quot;&gt;14. 在明显不会有重复值时使用UNION ALL 而不是UNION&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;UNION 会把两个结果集的所有数据放到临时表中后再进行去重操作
UNION ALL 不会再对结果集进行去重操作&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;拆分复杂的大sql为多个小sql&quot;&gt;15. 拆分复杂的大SQL为多个小SQL&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;大SQL:逻辑上比较复杂，需要占用大量CPU进行计算的SQL
MySQL 一个SQL只能使用一个CPU进行计算
SQL拆分后可以通过并行执行来提高处理效率&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;超100万行的批量写updatedeleteinsert操作要分批多次进行操作&quot;&gt;超100万行的批量写（UPDATE、DELETE、INSERT）操作，要分批多次进行操作&lt;/h2&gt;
&lt;h3 id=&quot;大批量操作可能会造成严重的主从延迟&quot;&gt;1. 大批量操作可能会造成严重的主从延迟&lt;/h3&gt;
&lt;p&gt;主从环境中,大批量操作可能会造成严重的主从延迟，大批量的写操作一般都需要执行一定长的时间，&lt;br/&gt;而只有当主库上执行完成后，才会在其他从库上执行，所以会造成主库与从库长时间的延迟情况&lt;/p&gt;
&lt;h3 id=&quot;binlog日志为row格式时会产生大量的日志&quot;&gt;2. binlog日志为row格式时会产生大量的日志&lt;/h3&gt;
&lt;p&gt;大批量写操作会产生大量日志，特别是对于row格式二进制数据而言，由于在row格式中会记录每一行数据的修改，我们一次修改的数据越多，&lt;br/&gt;产生的日志量也就会越多，日志的传输和恢复所需要的时间也就越长，这也是造成主从延迟的一个原因&lt;/p&gt;
&lt;h3 id=&quot;避免产生大事务操作&quot;&gt;3. 避免产生大事务操作&lt;/h3&gt;
&lt;p&gt;大批量修改数据，一定是在一个事务中进行的，这就会造成表中大批量数据进行锁定，从而导致大量的阻塞，阻塞会对MySQL的性能产生非常大的影响&lt;br/&gt;特别是长时间的阻塞会占满所有数据库的可用连接，这会使生产环境中的其他应用无法连接到数据库，因此一定要注意大批量写操作要进行分批&lt;/p&gt;
&lt;h2 id=&quot;对于大表使用pt-online-schema-change修改表结构&quot;&gt;对于大表使用pt-online-schema-change修改表结构&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;避免大表修改产生的主从延迟&lt;/li&gt;
&lt;li&gt;避免在对表字段进行修改时进行锁表&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;对大表数据结构的修改一定要谨慎，会造成严重的锁表操作，尤其是生产环境，是不能容忍的&lt;/p&gt;
&lt;p&gt;pt-online-schema-change它会首先建立一个与原表结构相同的新表，并且在新表上进行表结构的修改，然后再把原表中的数据复制到新表中，并在原表中增加一些触发器&lt;br/&gt;把原表中新增的数据也复制到新表中，在行所有数据复制完成之后，把新表命名成原表，并把原来的表删除掉&lt;br/&gt;把原来一个DDL操作，分解成多个小的批次进行&lt;/p&gt;
&lt;h2 id=&quot;禁止为程序使用的账号赋予super权限&quot;&gt;禁止为程序使用的账号赋予super权限&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;当达到最大连接数限制时，还运行1个有super权限的用户连接
super权限只能留给DBA处理问题的账号使用&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;对于程序连接数据库账号遵循权限最小原则&quot;&gt;对于程序连接数据库账号，遵循权限最小原则&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;程序使用数据库账号只能在一个DB下使用，不准跨库
程序使用的账号原则上不准有drop权限&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 04 Jan 2019 05:23:00 +0000</pubDate>
<dc:creator>听风。</dc:creator>
<og:description>数据库命令规范 1. 所有数据库对象名称必须使用小写字母并用下划线分割 2. 所有数据库对象名称禁止使用mysql保留关键字（如果表名中包含关键字查询时，需要将其用单引号括起来） 3. 数据库对象的命</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huchong/p/10219318.html</dc:identifier>
</item>
</channel>
</rss>