<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>MySQL8.0数据库基础教程(二)-理解&quot;关系&quot; - 路人111122233</title>
<link>http://www.cnblogs.com/JavaEdge/p/12310482.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JavaEdge/p/12310482.html</guid>
<description>&lt;p&gt;形如 Linux 哲学一切都是文件，在 SQL 领域也有这样一条至理名言&lt;/p&gt;
&lt;p&gt;&lt;code&gt;一切都是关系&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;所谓关系数据库（Relational database）是创建在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。&lt;/p&gt;
&lt;p&gt;现实世界中的各种实体以及实体之间的各种联系均用关系模型表示。现如今虽然对此模型有一些批评意见，但它还是数据存储的传统标准。标准数据查询语言SQL就是一种基于关系数据库的语言，这种语言执行对关系数据库中数据的检索和操作。&lt;/p&gt;
&lt;p&gt;关系模型由关系数据结构、关系操作集合、关系完整性约束三部分组成。&lt;/p&gt;
&lt;h2 id=&quot;数据结构&quot;&gt;2.1 数据结构&lt;/h2&gt;
&lt;p&gt;其中，使用最多、也最复杂的操作就是数据查询，具体来说包括&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;选择（Selection）&lt;/li&gt;
&lt;li&gt;投影（Projection）&lt;/li&gt;
&lt;li&gt;并集（Union）&lt;/li&gt;
&lt;li&gt;交集（Intersection）&lt;/li&gt;
&lt;li&gt;差集（exception）&lt;/li&gt;
&lt;li&gt;笛卡儿积（Cartesian product）&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;完整性约束&quot;&gt;2.3 完整性约束&lt;/h2&gt;
&lt;p&gt;完整性约束包括&lt;/p&gt;
&lt;h3 id=&quot;实体完整性entity-integrity&quot;&gt;2.3.1 实体完整性(Entity integrity)&lt;/h3&gt;
&lt;p&gt;实体完整性（是关系模型中数据库完整性三项规则的其中之一。实体完整性这项规则要求每个数据表都必须有主键，而作为主键的所有栏位，其属性必须是独一及非空值。&lt;/p&gt;
&lt;p&gt;在关系数据库中，唯一标识每一行数据的字段称为主键（Primary Key），主键字段不能为空。每个表有且只能有一个主键。&lt;/p&gt;
&lt;h3 id=&quot;参照完整性&quot;&gt;2.3.2 参照完整性&lt;/h3&gt;
&lt;p&gt;又称引用完整性，是数据的属性，用以表明引用的有效。参照的完整性不允许关系中有不存在的实体引用。参照完整性与实体完整性二者，皆是关系模型必须满足的完整性约束条件，其目的在于保证数据的一致性。&lt;/p&gt;
&lt;p&gt;外键的参照完整性。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;外键（Foreign Key）代表了两个表之间的关联关系&lt;br/&gt;比如员工属于某个部门；因此员工表中存在部门编号字段，引用了部门表中的部门编号字段。对于外键引用，被引用的数据必须存在，员工不可能属于一个不存在的部门；删除某个部门之前，也需要对部门中的员工进行相应的处理。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;用户定义完整性&quot;&gt;2.3.3 用户定义完整性&lt;/h3&gt;
&lt;p&gt;基于业务需要自定义的约束。&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;非空约束（NOT NULL）&lt;br/&gt;确保了相应的字段不会出现空值，例如员工一定要有姓名&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;唯一约束（UNIQUE）&lt;br/&gt;用于确保字段中的值不会重复，每个员工的电子邮箱必须唯一&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;检查约束（CHECK）&lt;br/&gt;可以定义更多的业务规则，例如，薪水必须大于 0 ，字符必须大写等&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;默认值（DEFAULT）&lt;br/&gt;用于向字段中插入默认的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;MySQL 中只有 InnoDB 存储引擎支持外键约束；MySQL 8.0.16 增加了对检查约束的支持。因此我们强大的 MySQL 支持以上所有约束。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;从 MySQL 5.5 开始默认使用 InnoDB 存储引擎，支持事务处理（ACID）、行级锁定、故障恢复、多版本并发控制（MVCC）以及外键约束等&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;语法特性&quot;&gt;3.1 语法特性&lt;/h2&gt;
&lt;p&gt;SQL 是一种声明性的编程语言，语法接近于自然语言（英语）。通过几个简单的英文单词，例如 SELECT、INSERT、UPDATE、CREATE、DROP 等，完成大部分的数据库操作。&lt;/p&gt;
&lt;p&gt;SQL 语句不区分大小写，但是遵循一定的规则可以让代码更容易阅读。&lt;/p&gt;
&lt;p&gt;SQL 是一种声明式的语言，声明式语言的主要思想是告诉计算机想要什么结果（what），但不指定具体怎么做。这类语言还包括 HTML、正则表达式以及函数式编程等。&lt;/p&gt;
&lt;h2 id=&quot;面向集合&quot;&gt;3.2 面向集合&lt;/h2&gt;
&lt;p&gt;对于 SQL 语句而言，它所操作的对象是一个集合（表），操作的结果也是一个集合（表）。例如以下查询：&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;SELECT emp_id, emp_name, salary
  FROM employee;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中 employee 是一个表，它是该语句查询的对象；同时，查询的结果也是一个表。所以，我们可以继续扩展该查询：&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;SELECT emp_id, emp_name, salary
  FROM (
       SELECT emp_id, emp_name, salary
         FROM employee
       ) dt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们将括号中的查询结果（取名为 dt）作为输入值，传递给了外面的查询；最终整个语句的结果仍然是一个表。&lt;/p&gt;
&lt;p&gt;SQL 中的查询可以完成各种数据操作，例如过滤转换、分组汇总、排序显示等；但是它们本质上都是针对表的操作，结果也是表。&lt;/p&gt;
&lt;p&gt;不仅仅是查询语句，SQL 中的插入、更新和删除都以集合为操作对象。我们再看一个插入数据的示例：&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;CREATE TABLE t(id INTEGER);

-- 适用于 MySQL、SQL Server 以及 PostgreSQL
INSERT INTO t(id)
VALUES (1), (2), (3);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们首先使用 CREATE TABLE 语句创建了一个表，然后使用 INSERT INTO 语句插入数据。在执行插入操作之前，会在内存中创建一个包含 3 条数据的临时集合（表），然后将该集合插入目标表中。由于我们通常一次插入一条数据，以为是按照数据行进行插入；实际上，一条数据也是一个集合，只不过它只有一个元素而已。&lt;/p&gt;
&lt;p&gt;UNION ALL 是 SQL 中的并集运算，用于将两个集合组成一个更大的集合。此外，SQL 还支持交集运算（INTERSECT）、差集运算（EXCEPT）以及笛卡儿积（Cartesian product）&lt;/p&gt;

&lt;p&gt;包含 3 个表：员工表（employee）、部门表（department）和职位表（job）。&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;结构图，也称为实体-关系图（Entity-Relational Diagram）&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1097393/202002/1097393-20200215020057633-498115276.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;关系模型中定义了一个简单的数据结构，即关系（表），用于存储数据。SQL 是关系数据库的通用标准语言，通过声明的方式执行数据定义、数据操作、访问控制等。&lt;br/&gt;记住，对于 SQL，一切都是关系（表）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
<pubDate>Fri, 14 Feb 2020 18:01:00 +0000</pubDate>
<dc:creator>路人111122233</dc:creator>
<og:description>1 SQL 的哲学 形如 Linux 哲学一切都是文件，在 SQL 领域也有这样一条至理名言 2 关系数据库 所谓关系数据库（Relational database）是创建在关系模型基础上的数据库，借</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/JavaEdge/p/12310482.html</dc:identifier>
</item>
<item>
<title>.net Core2.2 WebApi通过OAuth2.0实现微信登录 - 星火卓越</title>
<link>http://www.cnblogs.com/amylis_chen/p/12310274.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/amylis_chen/p/12310274.html</guid>
<description>&lt;h3&gt;前言&lt;/h3&gt;
&lt;p&gt;微信相关配置请参考 &lt;a href=&quot;https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;amp;id=mp1421140842&quot; rel=&quot;nofollow&quot;&gt;微信公众平台&lt;/a&gt; 的这篇文章。注意授权回调域名一定要修改正确。&lt;/p&gt;
&lt;p&gt;微信网页授权是通过OAuth2.0机制实现的，所以我们可以使用 &lt;a href=&quot;https://github.com/china-live/QQConnect&quot;&gt;https://github.com/china-live/QQConnect&lt;/a&gt; 这个开源项目提供的中间件来实现微信第三方登录的流程。&lt;/p&gt;
&lt;h3&gt;开发流程&lt;/h3&gt;
&lt;p&gt;1、新建一个.net core webapi 项目。在NuGet中查找并安装 &lt;code&gt;AspNetCore.Authentication.WeChat&lt;/code&gt; 包。&lt;/p&gt;
&lt;p&gt;2、修改 &lt;code&gt;appsettings.json&lt;/code&gt; 配置文件，增加以下配置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Authentication&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;WeChat&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;       &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AppId&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;微信AppID&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;       &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AppSecret&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;微信AppSecret&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;  },
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;   &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Logging&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LogLevel&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;       &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Debug&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;日志级别从低到高，依次为：Debug,Information,Warning,Error,None&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;       &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Microsoft.EntityFrameworkCore&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Error&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;       &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;System&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Error&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;   }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3、修改 &lt;code&gt;Startup&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; services.AddSingleton&amp;lt;IHttpContextAccessor, HttpContextAccessor&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;        services.AddAuthentication()
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;                 .AddWeChat(wechatOptions =&amp;gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;                     wechatOptions.AppId = Configuration[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Authentication:WeChat:AppId&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;                     wechatOptions.AppSecret = Configuration[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Authentication:WeChat:AppSecret&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;                     wechatOptions.UseCachedStateDataFormat = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;                 });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4、新增 &lt;code&gt;AccountController&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [Route(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api/[controller]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    [ApiController]
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AccountController : ControllerBase
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; LoginProviderKey = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LoginProvider&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Provider_WeChat = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;WeChat&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; ILogger _logger;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; IHttpContextAccessor _contextAccessor;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; AccountController(ILogger&amp;lt;AccountController&amp;gt;&lt;span&gt; logger,
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            IHttpContextAccessor contextAccessor)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             _logger =&lt;span&gt; logger;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             _contextAccessor =&lt;span&gt; contextAccessor;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 微信登录
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;redirectUrl&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;授权成功后的跳转地址&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;         [HttpGet(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LoginByWeChat&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; IActionResult LoginByWeChat(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; redirectUrl)
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; request =&lt;span&gt; _contextAccessor.HttpContext.Request;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; url = $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{request.Scheme}://{request.Host}{request.PathBase}{request.Path}Callback?provider={Provider_WeChat}&amp;amp;redirectUrl={redirectUrl}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; properties = &lt;span&gt;new&lt;/span&gt; AuthenticationProperties { RedirectUri =&lt;span&gt; url };
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             properties.Items[LoginProviderKey] =&lt;span&gt; Provider_WeChat;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Challenge(properties, Provider_WeChat);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 微信授权成功后自动回调的地址
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;provider&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;redirectUrl&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;授权成功后的跳转地址&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;         [HttpGet(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LoginByWeChatCallback&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;IActionResult&amp;gt; LoginByWeChatCallbackAsync(&lt;span&gt;string&lt;/span&gt; provider = &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt; redirectUrl = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; authenticateResult = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; _contextAccessor.HttpContext.AuthenticateAsync(provider);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!authenticateResult.Succeeded) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Redirect(redirectUrl);
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; openIdClaim =&lt;span&gt; authenticateResult.Principal.FindFirst(ClaimTypes.NameIdentifier);
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (openIdClaim == &lt;span&gt;null&lt;/span&gt; ||&lt;span&gt; openIdClaim.Value.IsNullOrWhiteSpace())
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Redirect(redirectUrl);
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;TODO 记录授权成功后的微信信息 &lt;/span&gt;
&lt;span&gt;45&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; city = authenticateResult.Principal.FindFirst(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;urn:wechat:city&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)?&lt;span&gt;.Value;
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; country = authenticateResult.Principal.FindFirst(ClaimTypes.Country)?&lt;span&gt;.Value;
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; headimgurl = authenticateResult.Principal.FindFirst(ClaimTypes.Uri)?&lt;span&gt;.Value;
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; nickName = authenticateResult.Principal.FindFirst(ClaimTypes.Name)?&lt;span&gt;.Value;
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; openId = authenticateResult.Principal.FindFirst(ClaimTypes.NameIdentifier)?&lt;span&gt;.Value;
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; privilege = authenticateResult.Principal.FindFirst(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;urn:wechat:privilege&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)?&lt;span&gt;.Value;
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; province = authenticateResult.Principal.FindFirst(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;urn:wechat:province&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)?&lt;span&gt;.Value;
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; sexClaim =&lt;span&gt; authenticateResult.Principal.FindFirst(ClaimTypes.Gender);
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; sex = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (sexClaim != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !&lt;span&gt;sexClaim.Value.IsNullOrWhiteSpace())
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;                 sex = &lt;span&gt;int&lt;/span&gt;&lt;span&gt;.Parse(sexClaim.Value);
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; unionId = authenticateResult.Principal.FindFirst(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;urn:wechat:unionid&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)?&lt;span&gt;.Value;
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;             _logger.LogDebug($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;WeChat Info=&amp;gt; openId: {openId},nickName: {nickName}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; Redirect($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{redirectUrl}?openId={openIdClaim.Value}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;5、将网站发布到外网，请求&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;你的授权域名/api/account/LoginByWeChat?redirectUrl=授权成功后要跳转的页面&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;即可调起微信授权页面。&lt;/p&gt;
&lt;h3&gt;注意&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;微信授权必须使用https&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;微信开放平台和微信公众平台都有提供网站用微信登录的接口，前者适用于任何网站，后者只适用于微信服务号的内嵌网站&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;本篇相关源码地址：&lt;a href=&quot;https://github.com/ren8179/QrF.OAuth.WeChat/tree/master&quot; target=&quot;_blank&quot;&gt;https://github.com/ren8179/QrF.OAuth.WeChat/tree/master&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 14 Feb 2020 15:47:00 +0000</pubDate>
<dc:creator>星火卓越</dc:creator>
<og:description>前言 微信相关配置请参考&amp;#160;微信公众平台&amp;#160;的这篇文章。注意授权回调域名一定要修改正确。 微信网页授权是通过OAuth2.0机制实现的，所以我们可以使用&amp;#160;https://gi</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/amylis_chen/p/12310274.html</dc:identifier>
</item>
<item>
<title>golang学习笔记（一）：包，变量，函数 - 南风sa</title>
<link>http://www.cnblogs.com/veeupup/p/12310260.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/veeupup/p/12310260.html</guid>
<description>&lt;blockquote readability=&quot;3.2352941176471&quot;&gt;
&lt;p&gt;欢迎访问我的&lt;a href=&quot;http://blog.tanweime.com/&quot;&gt;博客&lt;/a&gt;和&lt;a href=&quot;https://github.com/veeupup&quot;&gt;github&lt;/a&gt;!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;go 语言学习笔记第一弹，来自 &lt;a href=&quot;https://tour.golang.org/list&quot;&gt;gotour&lt;/a&gt; ，以后要常写笔记，把自己学习笔记记录下来，就算只是笔记也要多写。&lt;/p&gt;
&lt;p&gt;好记性不如烂笔头，也要多锻炼自己的写作能力。&lt;/p&gt;
&lt;p&gt;说实话，今天很累了，最近在折腾操作系统内核，因为原先写了个bootloader，现在想要转向 grub 来，遇到坑太多了，已经两天了😭。&lt;/p&gt;
&lt;p&gt;还是接触一点新知识简单的东西，来缓冲一下，脑子迷迷糊糊的。&lt;/p&gt;

&lt;p&gt;每个Go程序由很多包组成。&lt;/p&gt;
&lt;p&gt;程序都是从 main 包开始运行。&lt;/p&gt;
&lt;p&gt;该程序正在使用导入路径为“ fmt”和“ math / rand”的软件包。&lt;/p&gt;
&lt;p&gt;按照约定，程序包名称与导入路径的最后一个元素相同。&lt;/p&gt;
&lt;p&gt;例如，“ math / rand”包包括以语句包rand开头的文件。&lt;/p&gt;
&lt;h2 id=&quot;import&quot;&gt;import&lt;/h2&gt;
&lt;p&gt;此代码将导入分组为带括号的“分解的”导入语句。&lt;/p&gt;
&lt;p&gt;您还可以编写多个导入语句，例如：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main

import (
    &quot;fmt&quot;
    &quot;math&quot;
)

func main() {
    fmt.Println(math.Pi)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是使用分解式import语句是一种很好的样式。&lt;/p&gt;
&lt;h2 id=&quot;导出名称&quot;&gt;&lt;strong&gt;导出名称&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;在Go中，如果名称以大写字母开头，则导出该名称。&lt;/p&gt;
&lt;p&gt;例如，Pizza是一个导出的名称，Pi也是，它是从math包导出的。&lt;/p&gt;
&lt;p&gt;pizza和pi不以大写字母开头，所以它们不被导出。&lt;/p&gt;
&lt;p&gt;在导入包时，您只能引用它导出的名称。任何“未导出”的名称都不能从包外部访问。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main

import (
    &quot;fmt&quot;
    &quot;math&quot;
)

func main() {
    fmt.Println(math.Pi)
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;一个函数可以接受零个或多个参数。&lt;/p&gt;
&lt;p&gt;在此示例中，add接受两个类型为int的参数。&lt;/p&gt;
&lt;p&gt;请注意，类型位于变量名称之后。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main

import &quot;fmt&quot;

func add(x int, y int) int {
    return x + y
}

func mins(x int, y int) int {
    return x - y;
}

func main() {
    fmt.Println(add(42, 13))
    fmt.Println(mins(23, 11))
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当两个或多个连续的命名函数参数共享一个类型时，可以从除最后一个之外的所有其他参数中省略该类型。&lt;/p&gt;
&lt;p&gt;在这个例子中，我们缩短了&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;x int，y int&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;x，y int
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main

import &quot;fmt&quot;

func add(x, y int) int {
    return x + y
}

func main() {
    fmt.Println(add(42, 13))
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;多个返回值&quot;&gt;多个返回值&lt;/h2&gt;
&lt;p&gt;一个函数能返回多个返回值。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main

import &quot;fmt&quot;

func swap(a, b string) (string, string) {
    return b, a
}

func main() {
    a, b := swap(&quot;ai&quot;, &quot;ni&quot;)
    fmt.Println(a, b)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;named-return-values&quot;&gt;Named return values&lt;/h2&gt;
&lt;p&gt;Go的返回值可能会被命名。&lt;/p&gt;
&lt;p&gt;如果是，则将它们视为定义在函数顶部的变量。&lt;/p&gt;
&lt;p&gt;应该使用这些名称来记录返回值的含义。&lt;/p&gt;
&lt;p&gt;没有参数的return语句返回指定的返回值。&lt;/p&gt;
&lt;p&gt;这就是所谓的“naked” return。&lt;/p&gt;
&lt;p&gt;裸返回语句应该只在短函数中使用，如下面的示例所示。&lt;/p&gt;
&lt;p&gt;在较长的函数中，它们可能会损害可读性。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main

import &quot;fmt&quot;

func split(sum int) (x, y int) {
    x = sum * 4 / 9
    y = sum - x
    return
}


func main() {
    fmt.Println(split(17))
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;var语句声明了一个变量列表;在函数参数列表中，类型是最后一个。&lt;/p&gt;
&lt;p&gt;var语句可以是包级的，也可以是函数级的。在这个例子中我们可以看到两者。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main

import &quot;fmt&quot;

var c, python, java bool

func main() {
    var i int
    fmt.Println(i, c, python, java)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;初始化数值&quot;&gt;初始化数值&lt;/h2&gt;
&lt;p&gt;var声明可以包含初始化器，每个变量一个。&lt;/p&gt;
&lt;p&gt;如果有初始化，类型可以省略;该变量将采用初始化器的类型。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main

import &quot;fmt&quot;

var i, j int = 1, 2

func main() {
    var c, python, java = true, false, &quot;no!&quot;
    fmt.Println(i, j, c, python, java)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;短变量初始化&quot;&gt;&lt;strong&gt;短变量初始化&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;在函数内部，可以使用:= short赋值语句来代替具有隐式类型的var声明。&lt;/p&gt;
&lt;p&gt;在函数之外，每个语句都以一个关键字(var、func等)开头，因此:=结构不可用&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main

import &quot;fmt&quot;

func main() {
    var i, j int = 1, 2
    k := 3
    c, python, java := true, false, &quot;no!&quot;
    fmt.Println(a ,i, j, k, c, python, java)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;基本数据类型&quot;&gt;基本数据类型&lt;/h2&gt;
&lt;p&gt;go 语言的基本数据类型&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;bool

string

int  int8  int16  int32  int64
uint uint8 uint16 uint32 uint64 uintptr

byte // alias for uint8

rune // alias for int32
     // represents a Unicode code point

float32 float64

complex64 complex128&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该示例显示了几种类型的变量，并且与import语句一样，变量声明也可以“分解”为块。&lt;/p&gt;
&lt;p&gt;int，uint和uintptr类型通常在32位系统上为32位宽，在64位系统上为64位宽。&lt;/p&gt;
&lt;p&gt;当您需要整数值时，应该使用int，除非有特殊原因要使用大小或无符号整数类型。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main

import (
    &quot;fmt&quot;
    &quot;math/cmplx&quot;
)

var (
    ToBe   bool       = false
    MaxInt uint64     = 1&amp;lt;&amp;lt;64 - 1
    z      complex128 = cmplx.Sqrt(-5 + 12i)
)



func main() {
    fmt.Printf(&quot;Type: %T Value: %v\n&quot;, ToBe, ToBe)
    fmt.Printf(&quot;Type: %T Value: %v\n&quot;, MaxInt, MaxInt)
    fmt.Printf(&quot;Type: %T Value: %v\n&quot;, z, z)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;零值&quot;&gt;&lt;strong&gt;零值&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;声明时没有明确的初始值的变量将被赋予零值。&lt;/p&gt;
&lt;p&gt;零值为：&lt;/p&gt;
&lt;p&gt;数字类型为0，&lt;/p&gt;
&lt;p&gt;对于布尔类型为false&lt;/p&gt;
&lt;p&gt;“”（空字符串）表示字符串。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main

import &quot;fmt&quot;

func main() {
    var i int
    var f float64
    var b bool
    var s string
    fmt.Printf(&quot;%v %v %v %q\n&quot;, i, f, b, s)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;类型转换&quot;&gt;&lt;strong&gt;类型转换&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;使用 T(v) 将 v 值转换为 T 类型&lt;/p&gt;
&lt;p&gt;一些例子：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main

import &quot;fmt&quot;

func main() {
    v := 12.2 // change me!
    fmt.Printf(&quot;v is of type %T\n&quot;, v)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;与C语言不同，在Go语言中，不同类型的项目之间的分配需要显式转换。&lt;/p&gt;
&lt;h2 id=&quot;类型推断&quot;&gt;&lt;strong&gt;类型推断&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;在声明变量而不指定显式类型时（使用：=语法或var =表达式语法），将从右侧的值推断出变量的类型。&lt;/p&gt;
&lt;p&gt;键入声明的右侧时，新变量具有相同的类型：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;var i int j：= i // j是一个整数&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是，当右侧包含无类型的数字常量时，新变量可能是int，float64或complex128，具体取决于常量的精度：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;i：= 42 //整数 

f：= 3.142 // 

float64 g：= 0.867 + 0.5i //complex128&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main

import &quot;fmt&quot;

func main() {
    v := 12.2 // change me!
    fmt.Printf(&quot;v is of type %T\n&quot;, v)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;常量&quot;&gt;&lt;strong&gt;常量&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;常量像变量一样声明，但是使用const关键字。&lt;/p&gt;
&lt;p&gt;常量可以是字符，字符串，布尔值或数字值。&lt;/p&gt;
&lt;p&gt;不能使用：=语法声明常量。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main

import &quot;fmt&quot;

const Pi = 3.14

func main() {
    const World = &quot;世界&quot;
    fmt.Println(&quot;Hello&quot;, World)
    fmt.Println(&quot;Happy&quot;, Pi, &quot;Day&quot;)

    const Truth = true
    fmt.Println(&quot;Go rules?&quot;, Truth)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;数字常量&quot;&gt;&lt;strong&gt;数字常量&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;数字常数是高精度值。&lt;/p&gt;
&lt;p&gt;未说明类型的常量采用其上下文所需的类型。&lt;/p&gt;
&lt;p&gt;（一个int最多可以存储一个64位整数，有时更少。）&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main

import &quot;fmt&quot;

const (
    // 1 左移 100 位
    Big = 1 &amp;lt;&amp;lt; 100
    // 右移 99 位
    Small = Big &amp;gt;&amp;gt; 99
)

func needInt(x int) int { return x*10 + 1 }
func needFloat(x float64) float64 {
    return x * 0.1
}

func main() {
    fmt.Println(needInt(Small))
    fmt.Println(needFloat(Small))
    fmt.Println(needFloat(Big))
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;3.2352941176471&quot;&gt;
&lt;p&gt;欢迎访问我的&lt;a href=&quot;http://blog.tanweime.com/&quot;&gt;博客&lt;/a&gt;和&lt;a href=&quot;https://github.com/veeupup&quot;&gt;github&lt;/a&gt;!&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 14 Feb 2020 15:44:00 +0000</pubDate>
<dc:creator>南风sa</dc:creator>
<og:description>欢迎访问我的 &amp;quot;博客&amp;quot; 和 &amp;quot;github&amp;quot; ! go 语言学习笔记第一弹，来自 &amp;quot;gotour&amp;quot; ，以后要常写笔记，把自己学习笔记记录下来</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/veeupup/p/12310260.html</dc:identifier>
</item>
<item>
<title>Java中正确终止线程的方法 - yuanyb</title>
<link>http://www.cnblogs.com/yuanyb/p/12310153.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuanyb/p/12310153.html</guid>
<description>&lt;p&gt;Thread类中有一个已经废弃的 stop() 方法，它可以终止线程，但由于它不管三七二十一，直接终止线程，所以被废弃了。比如，当线程被停止后还需要进行一些善后操作（如，关闭外部资源），使用这个方法就无能为力了。可以通过线程中断来实现线程终止。&lt;/p&gt;

&lt;p&gt;首先来看一下Java线程中断的一些内容：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Java平台为每个线程维护了一个布尔型的中断标记，可以通过下列方法获取该标记的值：
&lt;ul&gt;&lt;li&gt;interrupt() 中断某个线程&lt;/li&gt;
&lt;li&gt;isInterrupted() 返回该线程的中断标记&lt;/li&gt;
&lt;li&gt;interrupted() 返回并重置该线程的中断标记（置为false）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;中断仅是发起线程对目标线程的一种请求，也就是说，目标线程对这种请求可以相应，也可以忽略。&lt;/li&gt;
&lt;li&gt;Java标准库中与线程阻塞相关的方法对中断的相应方式都是抛出 InterruptedException 异常，并且按照惯例，抛出异常前都会重置中断标记为false，&lt;strong&gt;因此这些方法会清空线程的中断标记&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;Java标准库中与线程阻塞相关的方法在进行阻塞前会判断中断标记是否为true，为true则抛出异常；如果在阻塞后调用中断方法的话，那么JVM会设置该线程的中断标记，然后将该线程唤醒，&lt;strong&gt;因此中断具有唤醒线程的作用&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由上面几点和第二句加粗的话可知，可以使用线程中断来实现线程终止，只要目标线程判断一下中断标记即可，即使被中断的线程正处于阻塞状态，也能把他唤醒起来终止；由第一句加粗的话可知，直接使用线程中断实现线程终止是存在风险的，因为可能调用了一些Java标准库的阻塞方法，而导致了中断标记被清空，也就无法获得中断标记了（总是false），因此需要自己创建一个中断标记配合使用。&lt;/p&gt;

&lt;p&gt;如，下面是一个可中断的任务执行器，他会在每次执行任务前，判断一下自定i的终止标记和剩余的任务数（善后）；提供的shutdown方法除了将工作线程中断外（主要作用是唤醒可能处于阻塞状态的任务），还会将终止交集 terminated 置为 true。&lt;/p&gt;

&lt;p&gt;执行 main 方法，可以发现，首先会打印出“客户端调用了 shutdown 方法”，然后过了四秒，main线程才会终止，可知shutdown方法正确地将目标线程终止了。关于“按照惯例，Java标准库中抛出InterruptedException异常的和线程相关的阻塞方法会清空中断标记”，可以将条件中的 !interminated 替换成 !Thread.currentThread().isInterrupted()，然后再执行main方法测试，可以发现main线程始终无法终止，因为 sleep() 方法清空了中断标记，所以  !Thread.currentThread().isInterrupted() 始终为true，导致工作线程始终无法终止。&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class TerminableTaskRunner {
    // 存储要执行的任务
    private final BlockingQueue&amp;lt;Runnable&amp;gt; tasks;
    // 线程终止标志
    private volatile boolean terminated;
    // 剩余的任务数
    private final AtomicInteger count;
    // 实际执行任务的线程
    private volatile Thread workThread;

    public TerminableTaskRunner(int capacity) {
        this.tasks = new LinkedBlockingDeque&amp;lt;&amp;gt;(capacity);
        this.count = new AtomicInteger(0);
        this.workThread = new WorkThread();
        workThread.start();
    }

    public void submit(Runnable task) {
        this.tasks.add(task);
        this.count.incrementAndGet();
    }

    public void shutdown() {
        terminated = true; // 线程终止标志，由于中断标志可能会被覆盖，所以需要自己创建一个标志
        if (workThread != null)
            workThread.interrupt(); // 唤醒线程
    }

    private class WorkThread extends Thread {
        @Override
        public void run() {
            Runnable task;
            try {
                while (!terminated || tasks.size() &amp;gt;= 1) {
                    task = tasks.take();
                    try {
                        task.run(); // 可能会清空当前线程的中断标记，如task.run()在内部调用的阻塞方法抛出了InterruptedException
                    } catch (Throwable e) {
                        e.printStackTrace();
                    }
                    count.decrementAndGet();
                }
            } catch (InterruptedException e) {
                // 一旦调用shutdown且tasks.take()阻塞住，就抛出该异常，没有任务要执行，直接终止
                workThread = null;
            }
        }
    }

    public static void main(String[] args) {
        TerminableTaskRunner taskRunner = new TerminableTaskRunner(4);
        for (int i = 0; i &amp;lt; 4; i++) {
            taskRunner.submit(()-&amp;gt;{
                try {
                    TimeUnit.SECONDS.sleep(1);
                } catch (InterruptedException e) {
                    System.out.println(&quot;客户端调用了 shutdown 方法&quot;);
                }
            });
        }
        taskRunner.shutdown();

    }
}
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Fri, 14 Feb 2020 15:12:00 +0000</pubDate>
<dc:creator>yuanyb</dc:creator>
<og:description>Thread类中有一个已经废弃的 stop() 方法，它可以终止线程，但由于它不管三七二十一，直接终止线程，所以被废弃了。比如，当线程被停止后还需要进行一些善后操作（如，关闭外部资源），使用这个方法就</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yuanyb/p/12310153.html</dc:identifier>
</item>
<item>
<title>DirectX11 With Windows SDK--30 计算着色器：图像模糊、索贝尔算子 - X_Jun</title>
<link>http://www.cnblogs.com/X-Jun/p/12309749.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/X-Jun/p/12309749.html</guid>
<description>&lt;p&gt;到这里计算着色器的主线学习基本结束，剩下的就是再补充两个有关图像处理方面的应用。这里面包含了龙书11的图像模糊，以及龙书12额外提到的Sobel算子进行边缘检测。主要内容源自于龙书12，项目源码也基于此进行调整。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;学习目标：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;熟悉图像处理常用的卷积&lt;/li&gt;
&lt;li&gt;熟悉高斯模糊、Sobel算子&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/X-Jun/p/9028764.html&quot;&gt;DirectX11 With Windows SDK完整目录&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/MKXJun/DirectX11-With-Windows-SDK&quot;&gt;Github项目源码&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;欢迎加入QQ群: 727623616 可以一起探讨DX11，以及有什么问题也可以在这里汇报。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在图像处理中，经常需要用到卷积，很多效果都能够通过卷积的形式来实现。针对源图像中的每一个像素&lt;span class=&quot;math inline&quot;&gt;\(P_{ij}\)&lt;/span&gt;，计算以它为中心的m×n矩阵的加权值。此加权值便是经过处理后图像中第i行、第j列的颜色，如果写成卷积的形式则为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ H_{ij}=\sum_{r=-a}^{a}\sum_{c=-b}^{b}W_{rc}P_{i-r,j-c} \]&lt;/span&gt;&lt;br/&gt;其中，&lt;span class=&quot;math inline&quot;&gt;\(m=2a+1\)&lt;/span&gt;且&lt;span class=&quot;math inline&quot;&gt;\(n=2b+1\)&lt;/span&gt;，将m与n强制为奇数，以此来保证m×n矩阵总是具有“中心”项。若a=b=r，则只需指定半径r就可以确定矩阵的大小。&lt;span class=&quot;math inline&quot;&gt;\(W_{rc}\)&lt;/span&gt;为m×n矩阵（又称内核、算子）中的权值。为了方便观察计算及编码，通常会将内核旋转180°，这样就得到了更加常用的计算公式：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ H_{ij}=\sum_{r=-a}^{a}\sum_{c=-b}^{b}W_{rc}P_{i+r,j+c} \]&lt;/span&gt;&lt;br/&gt;若内核的所有权值的和为1，则它可以用来做模糊处理；如果权值和大于0小于1，则处理后的图像会随着颜色的缺失而变暗；如果权值和大于1，则处理后的图像会随着颜色的增添而更加明亮。当然也会有权值和等于0甚至可能小于0的情况，比如索贝尔算子。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1172605/202002/1172605-20200210111651000-49188061.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在保证权值和为1的前提下，我们就能用多种不同的方法来计算它。其中就有一种广为人知的模糊运算：高斯模糊（Gaussian blur）。该算法借助高斯函数&lt;span class=&quot;math inline&quot;&gt;\(G(x)=exp(-\frac{x^2}{2\sigma^2})\)&lt;/span&gt;来获取权值。下图展示了取不同σ值时高斯函数的对应图像：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1172605/202002/1172605-20200210111907617-1620909248.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，若σ越大，则曲线越趋于平缓，给邻近点所赋予的权值也就越大。&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ G(x)=exp(-\frac{x^2}{2\sigma^2})=e^{-\frac{x^2}{2\sigma^2}} \]&lt;/span&gt;&lt;br/&gt;如果学过概率论的话应该知道它很像标准正态分布的概率密度，只不过缺了一个系数&lt;span class=&quot;math inline&quot;&gt;\(\frac{1}{\sqrt{2\pi}\;\sigma}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;现在假设我们要进行规模为1×5的高斯模糊（即在水平方向进行1D模糊），且设σ=1。分别对x=-2,-1,0,1,2求G(x)的值，可以得到：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{align}G(-2)&amp;amp;=exp(-\frac{(-2)^2}{2})=e^{-2} \\G(-1)&amp;amp;=exp(-\frac{(-1)^2}{2})=e^{-\frac{1}{2}} \\G(0)&amp;amp;=exp(0)=1 \\G(1)&amp;amp;=exp(-\frac{1^2}{2})=e^{-\frac{1}{2}} \\G(2)&amp;amp;=exp(-\frac{2^2}{2})=e^{-2}\end{align} \]&lt;/span&gt;&lt;br/&gt;但是，这些数据还不是最终的权值，因为它们的和不为1：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{align} \sum_{x=-2}^{x=2}G(x)&amp;amp;=G(-2)+G(-1)+G(0)+G(1)+G(2)\\ &amp;amp;=1+2e^{-\frac{1}{2}}+2e^{-2}\\ &amp;amp;\approx 2.48373 \end{align} \]&lt;/span&gt;&lt;br/&gt;如果将前面5个值都除以它们的和进行规格化处理，那么我们便会基于高斯函数获得总和为1的各个权值：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{align} w_{-2}&amp;amp;=\frac{G(-2)}{\sum_{x=-2}^{x=2}G(x)}\approx 0.0545\\ w_{-1}&amp;amp;=\frac{G(-1)}{\sum_{x=-2}^{x=2}G(x)}\approx 0.2442\\ w_{0}&amp;amp;=\frac{G(0)}{\sum_{x=-2}^{x=2}G(x)}\approx 0.4026\\ w_{1}&amp;amp;=\frac{G(1)}{\sum_{x=-2}^{x=2}G(x)}\approx 0.2442\\ w_{2}&amp;amp;=\frac{G(2)}{\sum_{x=-2}^{x=2}G(x)}\approx 0.0545\\ \end{align} \]&lt;/span&gt;&lt;br/&gt;对于二维的高斯函数，有&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{align} G(x, y) &amp;amp;= G(x)\cdot G(y) \\ &amp;amp;=exp(-\frac{x^2}{2\sigma^2})\cdot exp(-\frac{y^2}{2\sigma^2}) \\ &amp;amp;=e^{-\frac{x^2+y^2}{2\sigma^2}} \end{align} \]&lt;/span&gt;&lt;br/&gt;假如我们要进行3x3的高斯模糊，且设σ=1，则未经过归一化的内核为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{bmatrix} G(-1)G(-1) &amp;amp; G(-1)G(0) &amp;amp; G(-1)G(1) \\ G(0)G(-1) &amp;amp; G(0)G(0) &amp;amp; G(0)G(1) \\ G(1)G(-1) &amp;amp; G(1)G(0) &amp;amp; G(1)G(1) \\ \end{bmatrix} = \begin{bmatrix} G(-1) \\ G(0) \\ G(1) \\ \end{bmatrix}\begin{bmatrix} G(-1) &amp;amp; G(0) &amp;amp; G(1) \\ \end{bmatrix} \]&lt;/span&gt;&lt;br/&gt;由于上面的内核矩阵可以写成一个列向量乘以一个行向量的形式，因此在做模糊的时候可以将一个2D模糊过程分为两个1D模糊过程。这也就说明该内核具有&lt;strong&gt;可分离性&lt;/strong&gt;。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;通过1D横向模糊将输入的图像I进行模糊处理：&lt;span class=&quot;math inline&quot;&gt;\(I_H=Blur_H(I)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;对上一步输出的结果再次进行1D纵向模糊处理：&lt;span class=&quot;math inline&quot;&gt;\(Blur(I)=Blur_V(I_H)\)&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;因此有：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ Blur(I)=Blur_V(Blur_H(I)) \]&lt;/span&gt;&lt;br/&gt;假如模糊核为一个9×9矩阵，我们就需要对总计81个样本依次进行2D模糊运算。但通过将模糊过程分离为两个1D模糊阶段，便仅需要处理9+9=18个样本！我们常常要对纹理进行模糊处理，而对纹理采样是代价高昂的操作。因此，通过分离模糊过程来减少纹理采样操作是一种受用户欢迎的优化手段。尽管有些模糊方法不具备可分离性，但只要保证最终图像在视觉上足够精准，我们往往还是能以优化性能为目的而简化其模糊过程。&lt;/p&gt;
&lt;h2 id=&quot;实现原理&quot;&gt;实现原理&lt;/h2&gt;
&lt;p&gt;首先，假设所运用的模糊算法具有可分离性，据此将模糊操作分为两个1D模糊运算：一个横向模糊运算，一个纵向模糊运算。假定用户提供了一个纹理A作为输入（通常是作为SRV形参），以及一个纹理B作为输出（通常是作为UAV形参）。不过要考虑到有的用户希望将直接修改纹理A，将纹理A的SRV和UAV都传入。因此我们还是需要两个存储中间结果的纹理T0、T1，过程如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;给纹理A绑定SRV作为输入，并且给纹理T0绑定UAV作为输出。&lt;/li&gt;
&lt;li&gt;调度线程组进行横向模糊操作。完成后，纹理T0存储了横向模糊的结果&lt;/li&gt;
&lt;li&gt;解绑纹理T0的UAV，将它的SRV作为输入。&lt;/li&gt;
&lt;li&gt;若用户指定了UAV，并且模糊次数为1，则将该UAV作为输出；否则由于后续还需要进行混合，则将纹理T1的UAV作为输出。&lt;/li&gt;
&lt;li&gt;调度线程组进行纵向模糊操作。若当前为最后一次模糊，且用户指定了UAV，则该UAV的纹理将保存最终的结果；否则T1保存了当前模糊的结果。解绑UAV后，若仍有剩余模糊次数，则将纹理T1绑定SRV作为输入，并给纹理T0绑定UAV作为输出，回到步骤2继续；否则就再解绑SRV后结束。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;由于渲染到纹理种的场景于窗口工作区要保持着相同的分辨率，我们需要不时重新构建离屏纹理，而模糊算法用的临时纹理T也是如此。在&lt;code&gt;GameApp::OnResize&lt;/code&gt;的时候重新调整即可。&lt;/p&gt;
&lt;p&gt;假如要处理的图像宽度为w、宽度为h。对于1D纵向模糊而言，一个线程组用256个线程来处理水平方向上的线段，而且每个线程又负责图像中一个像素的模糊操作。因此，为了图像中的每个像素都能得到模糊处理，我们需要在x方向上调度&lt;span class=&quot;math inline&quot;&gt;\(ceil(\frac{w}{256})\)&lt;/span&gt;个线程组（ceil为上取整函数），且在y方向上调度h个线程组。如果w不能被256整除，则最后一次调度的线程组会存有多余的线程（见下图）。我们对于这种情况无能为力，因为线程组的大小固定。因此，我们只得把注意力放在着色器代码中越界问题的钳位检测（clamping check）上。&lt;/p&gt;
&lt;p&gt;1D纵向模糊于上述1D横向模糊的情况相似。在纵向模糊过程中，线程组就像由256个线程构成的垂直线段，每个线程只负责图像中一个像素的模糊运算。因此，为了使图像中的每个像素都能得到模糊处理，我们需要在y方向上调度&lt;span class=&quot;math inline&quot;&gt;\(ceil(\frac{h}{256})\)&lt;/span&gt;个线程组，并在x方向上调度w个线程组。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1172605/202002/1172605-20200211110406650-830953945.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在来考虑对一个28x14像素的纹理进行处理，我们所用的横向、纵向线程组的规模分别为8x1和1x8（采用X×Y的表示格式）。对于水平方向的处理过程来说，为了处理所有的像素，我们需要在x方向上调度&lt;span class=&quot;math inline&quot;&gt;\(ceil(\frac{w}{8})=ceil(\frac{28}{8})=4\)&lt;/span&gt;个线程组，并在y方向上调度14个线程组。由于28并不能被8整除，所以最右侧的线程组中会有&lt;span class=&quot;math inline&quot;&gt;\((4\times 8-28)\times 14=56\)&lt;/span&gt;个线程声明都不做。对于垂直方向的处理过程而言，为了处理所有的像素，我们需要在y方向上分派&lt;span class=&quot;math inline&quot;&gt;\(ceil(\frac{h}{8})=ceil(\frac{14}{8})=2\)&lt;/span&gt;个线程组，并在x方向上调度28个线程组。同理，由于14并不能被8整除，所以最下侧的线程组中会有&lt;span class=&quot;math inline&quot;&gt;\((2\times 8 - 14)\times 28\)&lt;/span&gt;个闲置的线程。沿用同一思路就可以将线程组扩展为256个线程的规模来处理更大的纹理。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;BlurFilter::Execute&lt;/code&gt;不仅计算出了每个方向要调度的线程组数量，还开启了计算着色器的模糊运算：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void BlurFilter::Execute(ID3D11DeviceContext* deviceContext, ID3D11ShaderResourceView* inputTex, ID3D11UnorderedAccessView* outputTex, UINT blurTimes)
{
    if (!deviceContext || !inputTex || !blurTimes)
        return;

    // 设置常量缓冲区
    D3D11_MAPPED_SUBRESOURCE mappedData;
    deviceContext-&amp;gt;Map(m_pConstantBuffer.Get(), 0, D3D11_MAP_WRITE_DISCARD, 0, &amp;amp;mappedData);
    memcpy_s(mappedData.pData, sizeof m_CBSettings, &amp;amp;m_CBSettings, sizeof m_CBSettings);
    deviceContext-&amp;gt;Unmap(m_pConstantBuffer.Get(), 0);

    deviceContext-&amp;gt;CSSetConstantBuffers(0, 1, m_pConstantBuffer.GetAddressOf());

    ID3D11UnorderedAccessView* nullUAV[1] = { nullptr };
    ID3D11ShaderResourceView* nullSRV[1] = { nullptr };
    // 第一次模糊
    // 横向模糊
    deviceContext-&amp;gt;CSSetShader(m_pBlurHorzCS.Get(), nullptr, 0);
    deviceContext-&amp;gt;CSSetShaderResources(0, 1, &amp;amp;inputTex);
    deviceContext-&amp;gt;CSSetUnorderedAccessViews(0, 1, m_pTempUAV0.GetAddressOf(), nullptr);

    deviceContext-&amp;gt;Dispatch((UINT)ceilf(m_Width / 256.0f), m_Height, 1);
    deviceContext-&amp;gt;CSSetUnorderedAccessViews(0, 1, nullUAV, nullptr);
    // 纵向模糊
    deviceContext-&amp;gt;CSSetShader(m_pBlurVertCS.Get(), nullptr, 0);
    deviceContext-&amp;gt;CSSetShaderResources(0, 1, m_pTempSRV0.GetAddressOf());
    if (blurTimes == 1 &amp;amp;&amp;amp; outputTex)
        deviceContext-&amp;gt;CSSetUnorderedAccessViews(0, 1, &amp;amp;outputTex, nullptr);
    else
        deviceContext-&amp;gt;CSSetUnorderedAccessViews(0, 1, m_pTempUAV1.GetAddressOf(), nullptr);
    deviceContext-&amp;gt;Dispatch(m_Width, (UINT)ceilf(m_Height / 256.0f), 1);
    deviceContext-&amp;gt;CSSetUnorderedAccessViews(0, 1, nullUAV, nullptr);

    // 剩余模糊次数
    while (--blurTimes)
    {
        // 横向模糊
        deviceContext-&amp;gt;CSSetShader(m_pBlurHorzCS.Get(), nullptr, 0);
        deviceContext-&amp;gt;CSSetShaderResources(0, 1, m_pTempSRV1.GetAddressOf());
        deviceContext-&amp;gt;CSSetUnorderedAccessViews(0, 1, m_pTempUAV0.GetAddressOf(), nullptr);

        deviceContext-&amp;gt;Dispatch((UINT)ceilf(m_Width / 256.0f), m_Height, 1);
        deviceContext-&amp;gt;CSSetUnorderedAccessViews(0, 1, nullUAV, nullptr);
        // 纵向模糊
        deviceContext-&amp;gt;CSSetShader(m_pBlurVertCS.Get(), nullptr, 0);
        deviceContext-&amp;gt;CSSetShaderResources(0, 1, m_pTempSRV0.GetAddressOf());
        if (blurTimes == 1 &amp;amp;&amp;amp; outputTex)
            deviceContext-&amp;gt;CSSetUnorderedAccessViews(0, 1, &amp;amp;outputTex, nullptr);
        else
            deviceContext-&amp;gt;CSSetUnorderedAccessViews(0, 1, m_pTempUAV1.GetAddressOf(), nullptr);
        deviceContext-&amp;gt;Dispatch(m_Width, (UINT)ceilf(m_Height / 256.0f), 1);

        
        deviceContext-&amp;gt;CSSetUnorderedAccessViews(0, 1, nullUAV, nullptr);
    }
    // 解除剩余绑定
    deviceContext-&amp;gt;CSSetShaderResources(0, 1, nullSRV);

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其余C++端源码则直接去项目源码看即可。&lt;/p&gt;
&lt;h2 id=&quot;hlsl代码&quot;&gt;HLSL代码&lt;/h2&gt;
&lt;p&gt;由于水平模糊与垂直模糊的实现原理相仿，这里我们只讨论水平模糊。&lt;/p&gt;
&lt;p&gt;在上面的代码中，我们可以看到调度的线程组是由256个线程构成的水平“线段”，每个线程都负责图像中一个像素的模糊操作。一种低效的实现方案是，每个线程都简单地计算出以正在处理的像素为中心的行矩阵（因为我们现在正在进行的是1D横向模糊处理，所以要针对行矩阵进行计算）的加权平均值。这种办法的缺点是需要多次拾取同一纹素。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1172605/202002/1172605-20200214110120411-218110546.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;仅考虑输入图像中的这两个相邻像素，假设模糊核为1×7。光是在对这两个像素进行模糊的过程中，8个不同的像素中就已经有6个被采集了2次，而且要考虑到访问设备内存的效率在GPU内存模型中是属于比较慢的一种。&lt;/p&gt;
&lt;p&gt;我们可以根据前面一节提到的模糊处理策略，利用共享内存来优化上述算法。这样一来，每个线程就可以在共享内存中读取或存储所需的纹素数据。待所有线程都从共享内存读取到它们所需的纹素后，就能够执行模糊运算了。不得不说，从共享内存中读取数据的速度飞快。除此之外，还有一件棘手的事情，就是利用具有n = 256个线程的线程组行模糊运算的时候，却需要n + 2R个纹素数据，这里的R就是模糊半径：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1172605/202002/1172605-20200214111551900-1507096628.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于模糊半径的原因，在处理线程组边界附近的像素时，可能会读取线程组以外存在“越界”情况的像素。解决办法其实也并不复杂。我们只需要分配出能容纳n + 2R个元素的共享内存，并且有2R个线程要各获取两个纹素数据。唯一麻烦的地方就是在共享内存时要多花心思，因为组内线程ID此时不能于共享内存中的元素一一对应了。下图演示了当R=4时，从线程到共享内存的映射过程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1172605/202002/1172605-20200214111944531-450919303.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在此例中，R = 4。最左侧的4个线程以及最右侧的4个线程，每个都要读取2个纹素数据，并将它们存于共享内存之中。而这8个线程之外的所有线程都只需要读取1个像素，并将其存于共享内存之中。这样一来，我们即可以得到以模糊半径R对N个像素进行模糊处理所需的所有纹素数据。&lt;/p&gt;
&lt;p&gt;现在要讨论的是最后一种情况，即下图中所示的最左侧于最右侧的线程组在&lt;strong&gt;索引&lt;/strong&gt;输入图像时会发生越界的情形。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1172605/202002/1172605-20200214112256687-1854513574.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;前面提到，从越界的索引处读取数据并不是非法操作，而是返回0（对越界索引处进行写入是不会执行任何操作的，即no-op）。然而，我们在读取越界数据时并不希望得到数据0，因为这意味着值为0的颜色（即黑色）会影响到边界处的模糊结果。我们此时期盼能实现出类似于&lt;strong&gt;钳位&lt;/strong&gt;（clamp）纹理寻址模式的效果，即在读取越界的数据时，能够获得一个与边界纹素相同的数据。这个方案可以通过对索引进行钳位来加以实现，在下面完整的着色器代码可以看到（这里将模糊半径调大了）：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// Blur.hlsli
cbuffer CBSettings : register(b0)
{
    int g_BlurRadius;
    
    // 最多支持19个模糊权值
    float w0;
    float w1;
    float w2;
    float w3;
    float w4;
    float w5;
    float w6;
    float w7;
    float w8;
    float w9;
    float w10;
    float w11;
    float w12;
    float w13;
    float w14;
    float w15;
    float w16;
    float w17;
    float w18;
}

Texture2D g_Input : register(t0);
RWTexture2D&amp;lt;float4&amp;gt; g_Output : register(u0);

static const int g_MaxBlurRadius = 9;

#define N 256
#define CacheSize (N + 2 * g_MaxBlurRadius)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// Blur_Horz_CS.hlsl
#include &quot;Blur.hlsli&quot;

groupshared float4 g_Cache[CacheSize];

[numthreads(N, 1, 1)]
void CS(int3 GTid : SV_GroupThreadID,
    int3 DTid : SV_DispatchThreadID)
{
    // 放在数组中以便于索引
    float g_Weights[19] =
    {
        w0, w1, w2, w3, w4, w5, w6, w7, w8, w9,
        w10, w11, w12, w13, w14, w15, w16, w17, w18
    };

    // 通过填写本地线程存储区来减少带宽的负载。若要对N个像素进行模糊处理，根据模糊半径，
    // 我们需要加载N + 2 * BlurRadius个像素
    
    // 此线程组运行着N个线程。为了获取额外的2*BlurRadius个像素，就需要有2*BlurRadius个
    // 线程都多采集一个像素数据
    if (GTid.x &amp;lt; g_BlurRadius)
    {
        // 对于图像左侧边界存在越界采样的情况进行钳位(Clamp)操作
        int x = max(DTid.x - g_BlurRadius, 0);
        g_Cache[GTid.x] = g_Input[int2(x, DTid.y)];
    }
    
    if (GTid.x &amp;gt;= N - g_BlurRadius)
    {
        // 对于图像左侧边界存在越界采样的情况进行钳位(Clamp)操作
        // 震惊的是Texture2D居然能通过属性Length访问宽高
        int x = min(DTid.x + g_BlurRadius, g_Input.Length.x - 1);   
        g_Cache[GTid.x + 2 * g_BlurRadius] = g_Input[int2(x, DTid.y)];
    }
    
    // 将数据写入Cache的对应位置
    // 针对图形边界处的越界采样情况进行钳位处理
    g_Cache[GTid.x + g_BlurRadius] = g_Input[min(DTid.xy, g_Input.Length.xy - 1)];
    
    // 等待所有线程完成任务
    GroupMemoryBarrierWithGroupSync();
    
    // 开始对每个像素进行混合
    float4 blurColor = float4(0.0f, 0.0f, 0.0f, 0.0f);
    for (int i = -g_BlurRadius; i &amp;lt;= g_BlurRadius; ++i)
    {
        int k = GTid.x + g_BlurRadius + i;
        
        blurColor += g_Weights[i + g_BlurRadius] * g_Cache[k];
    }
    
    g_Output[DTid.xy] = blurColor;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Blur_Vert_CS.hlsl&lt;/code&gt;与上面的代码类似，就不再放出。&lt;/p&gt;
&lt;p&gt;最右侧的线程组可能存有一些多余的线程，但输出的纹理中并没有与之对应的元素（意味着它们根本无需输出任何数据，见上图）。此时&lt;code&gt;DTid.xy&lt;/code&gt;即为输出纹理之外的一个越界索引。但是我们无需为此而担心，因为向越界处写入数据的效果是不进行任何操作（no-op）。&lt;/p&gt;

&lt;p&gt;索贝尔算子（Sobel Operator）用于图像的边缘检测。它会针对每一个像素估算其梯度（gradient）的大小。梯度值较大的像素则表明它与周围像素的颜色差异极大，因而此像素一定位于图像的边缘。相反，具有较小梯度的像素则意味着它与临近像素的颜色趋同，即该像素并不处于图像边沿之上。需要注意的是，索贝尔算子返回的并非是像素是否位于图像边缘的二元结果，而是一个范围在[0.0, 1.0]内表示边缘“陡峭”程度的灰度值：值为0表示非常平坦，与周围像素并没有颜色差异；值为1表示非常陡峭，与周围像素颜色差异很大。通常索贝尔逆图像(1-c)往往会更加直观有效，这时白色表示平坦且不位于图像边缘，而黑色则代表陡峭且处于图像边缘。&lt;/p&gt;
&lt;p&gt;运用索贝尔算子后的结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1172605/202002/1172605-20200214152729537-649321422.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;索贝尔算子的逆图像的结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1172605/202002/1172605-20200214152748212-1308054622.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果将原始图像与其经过索贝尔算子生成的逆图像两者间的对应颜色值相乘，我们将获得类似于卡通画或动漫书中那样，其边缘就像用黑色的笔勾描后的图片效果。哪怕待处理的图像首先经过模糊处理后已经隐去了部分细节，依旧可以恢复其相对粗犷的画风，令其边缘清晰起来。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1172605/202002/1172605-20200214154307248-1399282033.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;索贝尔算子所采用的算法是先进行加权平均，然后进行近似求导运算，计算方法如下：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ G_x = \Delta_x f(x, y) = [f(x-1,y+1)+2f(x,y+1)+f(x+1,y+1)]-[f(x-1,y-1)+2f(x,y-1)+f(x+1,y-1)] \\ G_y = \Delta_y f(x, y) = [f(x-1,y-1)+2f(x-1,y)+f(x-1,y+1)]-[f(x+1,y-1)+2f(x+1,y)+f(x+1,y+1)] \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;因此我们就得到了梯度向量&lt;span class=&quot;math inline&quot;&gt;\((\Delta_x f(x, y), \Delta_y f(x, y))\)&lt;/span&gt;，然后求出它的长度&lt;span class=&quot;math inline&quot;&gt;\(\parallel \sqrt{G_{x}^{2} + G_{y}^{2}}\parallel\)&lt;/span&gt;即为变化方向最大处的变化率。&lt;/p&gt;
&lt;h2 id=&quot;hlsl代码-1&quot;&gt;HLSL代码&lt;/h2&gt;
&lt;p&gt;索贝尔算子的HLSL代码实现如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// Sobel_CS.hlsl
Texture2D g_Input : register(t0);
RWTexture2D&amp;lt;float4&amp;gt; g_Output : register(u0);

// 将RGB色转化为灰色
float3 RGB2Gray(float3 color)
{
    return (float3) dot(color, float3(0.299f, 0.587f, 0.114f));
}

[numthreads(16, 16, 1)]
void CS(int3 DTid : SV_DispatchThreadID)
{
    // 采集当前待处理像素及相邻的八个像素
    float4 colors[3][3];
    for (int i = 0; i &amp;lt; 3; ++i)
    {
        for (int j = 0; j &amp;lt; 3; ++j)
        {
            int2 xy = DTid.xy + int2(-1 + j, -1 + i);
            colors[i][j] = g_Input[xy];
        }
    }
    
    // 针对每个颜色通道，利用索贝尔算子估算出关于x的偏导数近似值
    float4 Gx = -1.0f * colors[0][0] - 2.0f * colors[1][0] - 1.0f * colors[2][0] +
        1.0f * colors[0][2] + 2.0f * colors[1][2] + 1.0f * colors[2][2];
    
    // 针对每个颜色通道，利用索贝尔算子估算出关于y的偏导数的近似值
    float4 Gy = -1.0f * colors[2][0] - 2.0f * colors[2][1] - 1.0f * colors[2][2] +
        1.0f * colors[0][0] + 2.0f * colors[0][1] + 1.0f * colors[0][2];
    
    // 梯度向量即为(Gx, Gy)。针对每个颜色通道，计算出梯度大小（即梯度的模拟）
    // 以找到最大的变化率
    float4 mag = sqrt(Gx * Gx + Gy * Gy);
    
    // 将梯度陡峭的边缘处绘制为黑色，梯度平坦的非边缘处绘制为白色
    mag = 1.0f - float4(saturate(RGB2Gray(mag.xyz)), 0.0f);
    
    g_Output[DTid.xy] = mag;

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// VS使用Basic_VS_2D
// Composite_PS.hlsl
Texture2D g_BaseMap : register(t0); // 原纹理
Texture2D g_EdgeMap : register(t1); // 边缘纹理
SamplerState g_SamLinearWrap : register(s0); // 线性过滤+Wrap采样器
SamplerState g_SamPointClamp : register(s1); // 点过滤+Clamp采样器

float4 PS(float4 posH : SV_Position, float2 tex : TEXCOORD) : SV_Target
{
    float4 c = g_BaseMap.SampleLevel(g_SamPointClamp, tex, 0.0f);
    float4 e = g_EdgeMap.SampleLevel(g_SamPointClamp, tex, 0.0f);
    // 将原始图片与边缘图相乘
    return c * e;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在C++端的代码可以直接去源码中寻找&lt;code&gt;SobelFilter&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;本样例为高斯模糊提供了调整模糊半径、Sigma和次数的功能。模糊半径越大，模糊次数越大，帧数会越低。如果你的电脑配置承受不住，建议关掉OIT来观察模糊效果会更好一些。至于Sobel算子则无法调整。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1172605/202002/1172605-20200214212823732-1778615375.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;整个计算着色器的内容就到此结束了。&lt;/p&gt;

&lt;p&gt;该项目无法图形调试，就和DirectX SDK Samples中OIT样例一样，遇到了未知问题。如果要调试，需要把OIT相关的代码撤走才能调试。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1172605/202002/1172605-20200214210948052-1972870902.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此外，龙书12中的&lt;code&gt;Composite.hlsl&lt;/code&gt;顶点着色器用到了&lt;code&gt;SV_VertexID&lt;/code&gt;，一旦用了该系统值作为输入，就无法在最终结果选择像素观察运行过程了。因此本项目并没有使用内置于着色器的顶点数据。&lt;/p&gt;

&lt;ol readability=&quot;3&quot;&gt;&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;对图像进行模糊处理是一种昂贵的操作，它所花费的时间于待处理的图像大小息息相关。一般情况下，在把场景渲染到离屏纹理的时候，我们通常会将离屏纹理的大小设为后备缓冲区尺寸的1/4.也就是说，假如后备缓冲区的大小为800x600，则离屏纹理的尺寸将为400x300.这样一来不仅能加快离屏纹理的绘制速度（即减少了需要填充的像素数量），而且能同时提升模糊图像的处理速度（需要模糊的像素也就更少）。另外，当纹理从1/4的屏幕分辨率拉伸为完整大屏幕分辨率时，纹理放大过滤器也会执行一些额外的模糊操作。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;现在尝试修改项目，让&lt;code&gt;BlurFilter&lt;/code&gt;的分辨率为400x300，实现上述内容。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;提示：TextureRender开启mipmaps，并将mip等级为1的纹理子资源作为SRV。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;尝试添加&lt;code&gt;Composite_VS.hlsl&lt;/code&gt;，将绘制整个屏幕的6个顶点直接放在顶点着色器中，然后只使用&lt;code&gt;SV_VertexID&lt;/code&gt;作为顶点着色器的形参来绘制。&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;研究双边模糊（双边滤波器，bilateral blur）计数，并用计算着色器加以实现。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/X-Jun/p/9028764.html&quot;&gt;DirectX11 With Windows SDK完整目录&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/MKXJun/DirectX11-With-Windows-SDK&quot;&gt;Github项目源码&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;欢迎加入QQ群: 727623616 可以一起探讨DX11，以及有什么问题也可以在这里汇报。&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 14 Feb 2020 13:46:00 +0000</pubDate>
<dc:creator>X_Jun</dc:creator>
<og:description>前言 到这里计算着色器的主线学习基本结束，剩下的就是再补充两个有关图像处理方面的应用。这里面包含了龙书11的图像模糊，以及龙书12额外提到的Sobel算子进行边缘检测。主要内容源自于龙书12，项目源码</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/X-Jun/p/12309749.html</dc:identifier>
</item>
<item>
<title>LeetCode.509——斐波那契数 - 沐雨橙风~~</title>
<link>http://www.cnblogs.com/coding-996/p/12309481.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/coding-996/p/12309481.html</guid>
<description>&lt;hr/&gt;&lt;ul readability=&quot;6.5&quot;&gt;&lt;li readability=&quot;8&quot;&gt;
&lt;h2 id=&quot;问题描述&quot;&gt;问题描述：&lt;/h2&gt;
&lt;p&gt;斐波那契数，通常用 F(n) 表示，形成的序列称为斐波那契数列。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;F(0) = 0,   F(1) = 1
F(N) = F(N - 1) + F(N - 2), 其中 N &amp;gt; 1.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;给定 N，计算 F(N)。&lt;/p&gt;
&lt;p&gt;示例 ：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;输入：2
输出：1
解释：F(2) = F(1) + F(0) = 1 + 0 = 1.&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;h2 id=&quot;问题分析&quot;&gt;问题分析：&lt;/h2&gt;
&lt;p&gt;由于计算任何一个第n(n &amp;gt;= 2)项的数都需要知道其前面两个数，即需要知道n-1和n-2是多少，然后两个相加得到结果，但是问题来了，要知道n-1，就要需要知道n-2，要知道n-2就需要知道n-3，会一直这样的循环递归下去，一直到第一个数，第二个，第三个.......再反推回来。 那就很明显了，大家第一时间想到的方法便是递归，就下来实现一下：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;方法一：递归实现&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Solution {
   public int fib(int n) {
      if(n &amp;lt;= 1){
            return n;
        }
         return fib(n-1) + fib(n-2);
     }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;​ 问题分析：&lt;/p&gt;
&lt;p&gt;​ 先看一下递归图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1661566/202002/1661566-20200214204356229-1632495779.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​ 由于很多数的计算都要重复很多次，效率并不高，时间复杂度达到了 O（2^n），是斐波那契数计算中 时间复杂度最大，最不可取的方法。&lt;/p&gt;
&lt;p&gt;​ 空间复杂度：O（n）,堆栈中需要的空间与 N 成正比，堆栈会跟踪 fib(n) 的调用，随着堆栈的不断增长 如果没有足够的内存则会出现StackOverflowError异常。&lt;/p&gt;
&lt;p&gt;​ 注：定义为int型时，最大只能求到n = 46，f(46) = 1836311903, 而 f(47) = -1323752223,因为超出了int 型数值的最大范围。&lt;/p&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;9&quot;&gt;
&lt;h2 id=&quot;算法改进&quot;&gt;算法改进：&lt;/h2&gt;
&lt;p&gt;使用递归的同时，使用记忆化方式存储已经计算过的数据，减少不必要的重复计算，可以使时间复杂度降到 O(N),同时空间复杂度也是O(N)。具体的实现是使用一个数组，把每次计算过的值都存储进去，当再次使用这个数的时候，直接返回，不需要再进行递归。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;方法二：记忆化自底向上递归&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Solution {
   public int fib(int n) {
      if(n &amp;lt;= 1){
            return n;
        }
         int[] memo = new int[n+1];
         memo[1] = 1;
         for(int i = 2;i &amp;lt;= n; i++){
             //自底向上填充数组，一直到需要的那个数
             memo[i] = memo[i-1] + memo[i-2];
         }
         return memo[n];
     }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;h2 id=&quot;最后&quot;&gt;最后：&lt;/h2&gt;
&lt;p&gt;限于水平有限，斐波那契数的实现还有很多种方法，不能一一列举，当其中大部分都有类似的思想。&lt;/p&gt;
&lt;p&gt;水文中如有不准确或是错误之处，还望指出。谢谢~~~&lt;/p&gt;
&lt;p&gt;下一篇：LeetCode.62——不同路径&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Fri, 14 Feb 2020 12:44:00 +0000</pubDate>
<dc:creator>沐雨橙风~~</dc:creator>
<og:description>问题描述： 斐波那契数，通常用 F(n) 表示，形成的序列称为斐波那契数列。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： 给定 N，计算 F(N)。 示例 ： 问题分析：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/coding-996/p/12309481.html</dc:identifier>
</item>
<item>
<title>分析Ajax爬取今日头条街拍美图-崔庆才思路 - 不愿透露姓名的高杨</title>
<link>http://www.cnblogs.com/thecatcher/p/12309427.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/thecatcher/p/12309427.html</guid>
<description>&lt;p&gt;
&lt;h2 class=&quot;xsj_heading_hash xsj_heading xsj_heading_h2&quot; id=&quot;e7ab99e782b9e58886e69e90_1&quot;&gt; &lt;span class=&quot;xsj_heading_content&quot;&gt;站点分析&lt;/span&gt;&lt;/h2&gt;
&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;首先,打开头条,在搜索框输入关键字之后,在返回的页面中,勾选Perserve log,这玩意儿在页面发生变化的时候,不会清除之前的交互信息.&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;在返回的response中,我们看不到常见的HTML代码,所以初步判定,这个网站是通过ajax动态加载的.&lt;/p&gt;

&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1005685/202002/1005685-20200214203216488-788676693.png&quot; alt=&quot;&quot; title=&quot;pic-1581682361199.png&quot; name=&quot;pic-1581682361199.png&quot; data-src=&quot;./pic-1581682361199.png&quot;/&gt;&lt;p&gt;pic-1581682361199.png&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;切换到XHR过滤器,进一步查看.&lt;/p&gt;

&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1005685/202002/1005685-20200214203216791-1105440658.png&quot; alt=&quot;&quot; title=&quot;pic-1581682361200.png&quot; name=&quot;pic-1581682361200.png&quot; data-src=&quot;./pic-1581682361200.png&quot;/&gt;&lt;p&gt;pic-1581682361200.png&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;发现随着网页的滚动,会产生类似这样的的Ajax请求出来. 仔细查看内容,可以看到与网页中条目对应的title和article_url.&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;&lt;strong&gt;所以初步思路,通过article_url字段先抓取文章条目&lt;/strong&gt;&lt;br/&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1005685/202002/1005685-20200214203216962-528955525.png&quot; alt=&quot;&quot; title=&quot;pic-1581682361200.png&quot; name=&quot;pic-1581682361200.png&quot; data-src=&quot;./pic-1581682361200.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;分析json数据,可以看到,这里有&lt;code&gt;article_url&lt;/code&gt;,另外,这次要抓取的是图集形式的页面,所以要注意下这个&lt;code&gt;has_gallery&lt;/code&gt;&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;然后我们再来看具体的页面&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;在具体页面的html中,我们发现,图片的所有链接直接在网页源代码中包含了,所以,我们直接拿到源码,正则匹配一下就好了.&lt;/p&gt;

&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1005685/202002/1005685-20200214203217159-1022339373.png&quot; alt=&quot;&quot; title=&quot;pic-1581682361200.png&quot; name=&quot;pic-1581682361200.png&quot; data-src=&quot;./pic-1581682361200.png&quot;/&gt;&lt;p&gt;pic-1581682361200.png&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;至此,页面分析完成.&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;开工!&lt;/p&gt;
&lt;p&gt;
&lt;h2 class=&quot;xsj_heading_hash xsj_heading xsj_heading_h2&quot; id=&quot;e6ba90e7a081e58f8ae98187e588b0e79a84e997aee9a298_2&quot;&gt; &lt;span class=&quot;xsj_heading_content&quot;&gt;源码及遇到的问题&lt;/span&gt;&lt;/h2&gt;
&lt;/p&gt;
&lt;p&gt;
&lt;h3 class=&quot;xsj_heading_hash xsj_heading xsj_heading_h3&quot; id=&quot;e4bba3e7a081e7bb93e69e84_3&quot;&gt; &lt;span class=&quot;xsj_heading_content&quot;&gt;代码结构&lt;/span&gt;&lt;/h3&gt;
&lt;/p&gt;
&lt;p&gt;
&lt;h4 class=&quot;xsj_heading_hash xsj_heading xsj_heading_h4&quot; id=&quot;e696b9e6b395e5ae9ae4b989_4&quot;&gt; &lt;span class=&quot;xsj_heading_content&quot;&gt;方法定义&lt;/span&gt;&lt;/h4&gt;
&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;&lt;code&gt;def get_page_index(offset, keyword):&lt;/code&gt; 获取搜索结果索引页面&lt;br/&gt;&lt;code&gt;def parse_page_index(html):&lt;/code&gt; 解析索引页面,主要是解析json内容,所以需要用到json.loads方法&lt;br/&gt;&lt;code&gt;def get_page_detail(url):&lt;/code&gt; 用来获取具体图片的页面,与索引页获取差不多&lt;br/&gt;&lt;code&gt;def parse_page_details(html, url):&lt;/code&gt;解析具体图集页面&lt;br/&gt;&lt;code&gt;def save_to_mongo(result):&lt;/code&gt; 将标题,url等内容保存到mongoDB数据库. 之所以使用mongoDB数据库,因为mongoDB简单,而且是K-V方式的存储,对于字典类型很友好&lt;br/&gt;&lt;code&gt;def download_image(url):&lt;/code&gt; 下载图片&lt;br/&gt;&lt;code&gt;def save_img(content):&lt;/code&gt; 保存图片&lt;br/&gt;&lt;code&gt;def main(offset):&lt;/code&gt; 对以上各种方法的调用&lt;/p&gt;
&lt;p&gt;
&lt;h4 class=&quot;xsj_heading_hash xsj_heading xsj_heading_h4&quot; id=&quot;e99c80e8a681e79a84e5b8b8e9878f_5&quot;&gt; &lt;span class=&quot;xsj_heading_content&quot;&gt;需要的常量&lt;/span&gt;&lt;/h4&gt;
&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python hljs&quot; data-info=&quot;python&quot;&gt;MONGO_URL = &lt;span class=&quot;hljs-string&quot;&gt;'localhost'&lt;/span&gt; 
MONGO_DB = &lt;span class=&quot;hljs-string&quot;&gt;'toutiao'&lt;/span&gt;    
MONGO_TABLE = &lt;span class=&quot;hljs-string&quot;&gt;'toutiao'&lt;/span&gt;
GROUP_START = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; 
GROUP_END = &lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt; 
KEY_WORD = &lt;span class=&quot;hljs-string&quot;&gt;'街拍'&lt;/span&gt; 
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
&lt;h3 class=&quot;xsj_heading_hash xsj_heading xsj_heading_h3&quot; id=&quot;e585b3e4ba8ee59ca8e4bba3e7a081e4b8ade98187e588b0e79a84e997aee9a298_6&quot;&gt; &lt;span class=&quot;xsj_heading_content&quot;&gt;关于在代码中遇到的问题&lt;/span&gt;&lt;/h3&gt;
&lt;/p&gt;
&lt;p&gt;
&lt;h4 class=&quot;xsj_heading_hash xsj_heading xsj_heading_h4&quot; id=&quot;0120e695b0e68daee5ba93e8bf9ee68ea5_7&quot;&gt; &lt;span class=&quot;xsj_heading_content&quot;&gt;01. 数据库连接&lt;/span&gt;&lt;/h4&gt;
&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;第一次在python中使用数据库,而且用的还是MongoDB. 使用之前引入 pymongo库,数据库连接的写法比较简单. 传入url 然后在创建的client中直接指定数据库名称就可以了.&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python hljs&quot; data-info=&quot;python&quot;&gt;client = pymongo.MongoClient(MONGO_URL,connect=&lt;span class=&quot;hljs-keyword&quot;&gt;False&lt;/span&gt;)
db = client[MONGO_DB]
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
&lt;h4 class=&quot;xsj_heading_hash xsj_heading xsj_heading_h4&quot; id=&quot;02e4bb8ae697a5e5a4b4e69da1e79a84e58f8de788ace899abe69cbae588b6_8&quot;&gt; &lt;span class=&quot;xsj_heading_content&quot;&gt;02.今日头条的反爬虫机制&lt;/span&gt;&lt;/h4&gt;
&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;今日头条比较有意思,反爬虫机制不是直接给个400的回应,而是返回一些错误的 无效的代码或者json. 不明白是什么原理,是请求不对,还是怎么了. 所以针对今日头条的反爬虫机制,经过尝试之后发现需要构造get的参数和请求头.&lt;br/&gt;而且今日头条的请求头中,需要带上cookie信息. 不然返回的response还是有问题.&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;这里还要注意的就是cookie信息有时效问题,具体多长时间,我也没搞明白,几个小时应该是有的,所以在执行之前,cookie最好更新一下&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;同样的在获取详情页的时候也有这个问题存在. 而且还犯了一个被自己蠢哭的错误. headers没有传到requests方法中去.&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;24&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python hljs&quot; data-info=&quot;python&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;get_page_index&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(offset, keyword)&lt;/span&gt;:&lt;/span&gt;
    timestamp = int(time.time())
    data = {
        &lt;span class=&quot;hljs-string&quot;&gt;&quot;aid&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;24&quot;&lt;/span&gt;,
        &lt;span class=&quot;hljs-string&quot;&gt;&quot;app_name&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;web_search&quot;&lt;/span&gt;,
        &lt;span class=&quot;hljs-string&quot;&gt;&quot;offset&quot;&lt;/span&gt;: offset,
        &lt;span class=&quot;hljs-string&quot;&gt;&quot;format&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;json&quot;&lt;/span&gt;,
        &lt;span class=&quot;hljs-string&quot;&gt;&quot;keyword&quot;&lt;/span&gt;: keyword,
        &lt;span class=&quot;hljs-string&quot;&gt;&quot;autoload&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;true&quot;&lt;/span&gt;,
        &lt;span class=&quot;hljs-string&quot;&gt;&quot;count&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;20&quot;&lt;/span&gt;,
        &lt;span class=&quot;hljs-string&quot;&gt;&quot;en_qc&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;1&quot;&lt;/span&gt;,
        &lt;span class=&quot;hljs-string&quot;&gt;&quot;cur_tab&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;1&quot;&lt;/span&gt;,
        &lt;span class=&quot;hljs-string&quot;&gt;&quot;from&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;search_tab&quot;&lt;/span&gt;,
        
        &lt;span class=&quot;hljs-string&quot;&gt;&quot;timestamp&quot;&lt;/span&gt;: timestamp
    }
    headers = {
        
        &lt;span class=&quot;hljs-string&quot;&gt;'cookie'&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;'tt_webid=6791640396613223949; WEATHER_CITY=%E5%8C%97%E4%BA%AC; tt_webid=6791640396613223949; csrftoken=4a29b1b1d9ecf8b5168f1955d2110f16; s_v_web_id=k6g11cxe_fWBnSuA7_RBx3_4Mo4_9a9z_XNI0WS8B9Fja; ttcid=3fdf0861117e48ac8b18940a5704991216; tt_scid=8Z.7-06X5KIZrlZF0PA9kgiudolF2L5j9bu9g6Pdm.4zcvNjlzQ1enH8qMQkYW8w9feb; __tasessionId=ngww6x1t11581323903383'&lt;/span&gt;,
        &lt;span class=&quot;hljs-string&quot;&gt;'user-agent'&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.87 Safari/537.36'&lt;/span&gt;}
    url = &lt;span class=&quot;hljs-string&quot;&gt;'https://www.toutiao.com/api/search/content/?'&lt;/span&gt; + urlencode(data)
    response = requests.get(url, headers=headers)
    &lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt;:
        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; response.status_code == &lt;span class=&quot;hljs-number&quot;&gt;200&lt;/span&gt;:
            &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; response.text
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;None&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;except&lt;/span&gt; RequestException:
        print(&lt;span class=&quot;hljs-string&quot;&gt;'Request failed!'&lt;/span&gt;)
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;None&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
&lt;h4 class=&quot;xsj_heading_hash xsj_heading xsj_heading_h4&quot; id=&quot;0320jsone8a7a3e7a081e98187e588b0e79a84e997aee9a298_9&quot;&gt; &lt;span class=&quot;xsj_heading_content&quot;&gt;03. json解码遇到的问题&lt;/span&gt;&lt;/h4&gt;
&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;由于python和java转移字符的区别(python通过''进行转义,''本身不需要转义),但是java需要&lt;code&gt;\\&lt;/code&gt;来进行转义,也就是''本身还需要一个''来进行转义.&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;但是python的json.loads()方法和print方法在输出的时候都会对转义字符进行解释.&lt;br/&gt;所以当初在&lt;code&gt;parse_page_details()&lt;/code&gt;这个方法中 &lt;code&gt;json.loads()&lt;/code&gt;报错,说json格式错误找不到'&quot;'. 但是print出来的时候,又是一个''的样子.&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;后来在在debug的时候,看到了真实的json字符串的样子&lt;br/&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1005685/202002/1005685-20200214203217322-1451699484.png&quot; alt=&quot;&quot; title=&quot;pic-1581682361201.png&quot; name=&quot;pic-1581682361201.png&quot; data-src=&quot;./pic-1581682361201.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;所以就需要对这个json字符串进行预处理,然后再使用json.loads()进行解码.&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;&lt;code&gt;eval(repr(result.group(1)).replace('\\\\', '\\'))&lt;/code&gt;&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;插一个小话题,那就是str()方法和repr()方法的区别. 首先两者都是把对象转换成字符串,而无论print方法还是str()方法调用的都是类中的&lt;code&gt;__str__&lt;/code&gt; 而repr()方法调用的是&lt;code&gt;__repr__&lt;/code&gt; .&lt;br/&gt;简单来说,&lt;code&gt;__str__&lt;/code&gt;方法是为了满足可读性,会对输出内容做可读性处理. 比如去掉字符串两端的引号或者自动解析''等. 但是&lt;code&gt;__repr__&lt;/code&gt;会尽量保留原始数据格式,满足的是准确性需求. 所以这里,我们使用repr()方法拿到原始数据,然后将&lt;code&gt;\\&lt;/code&gt; 替换为&lt;code&gt;\&lt;/code&gt;&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;ps.&lt;code&gt;\\\\&lt;/code&gt; 是两个&lt;code&gt;\&lt;/code&gt; 转义了一下. 同理两个斜杠是一个斜杠,因为也是转义的.&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;然后就是eval方法是能把字符串转换成对应的类型.&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;29&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python hljs&quot; data-info=&quot;python&quot;&gt;
 
 &amp;gt;&amp;gt;&amp;gt;a = &lt;span class=&quot;hljs-string&quot;&gt;&quot;[[1,2], [3,4], [5,6], [7,8], [9,0]]&quot;&lt;/span&gt;
 &amp;gt;&amp;gt;&amp;gt;type(a)
 &amp;lt;type &lt;span class=&quot;hljs-string&quot;&gt;'str'&lt;/span&gt;&amp;gt;
 &amp;gt;&amp;gt;&amp;gt; b = eval(a)
 &amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;print&lt;/span&gt; b
 [[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;], [&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;], [&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;], [&lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;], [&lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]]
 &amp;gt;&amp;gt;&amp;gt; type(b)
 &amp;lt;type &lt;span class=&quot;hljs-string&quot;&gt;'list'&lt;/span&gt;&amp;gt;

&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;a = &lt;span class=&quot;hljs-string&quot;&gt;&quot;{1: 'a', 2: 'b'}&quot;&lt;/span&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;type(a)&amp;lt;type &lt;span class=&quot;hljs-string&quot;&gt;'str'&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt; b = eval(a)
&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;print&lt;/span&gt; b
{&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;'a'&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;'b'&lt;/span&gt;}&amp;gt;&amp;gt;&amp;gt; type(b)&amp;lt;type &lt;span class=&quot;hljs-string&quot;&gt;'dict'&lt;/span&gt;&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;理解repr()和eval()两个方法之后,那上面的预处理代码就好理解了,先通过repr()方法获取原始字符串,然后替换,然后再给他转换成可读的字符串. 然后在用json.loads()解码.&lt;/p&gt;
&lt;p&gt;
&lt;h4 class=&quot;xsj_heading_hash xsj_heading xsj_heading_h4&quot; id=&quot;0420e585b3e4ba8eresponsetexte5928cresponsecontente79a84e58cbae588ab_10&quot;&gt; &lt;span class=&quot;xsj_heading_content&quot;&gt;04. 关于response.text和response.content的区别&lt;/span&gt;&lt;/h4&gt;
&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;&lt;strong&gt;response.text&lt;/strong&gt; 获取文本值&lt;br/&gt;&lt;strong&gt;response.content&lt;/strong&gt; 获取二进制内容&lt;/p&gt;
&lt;p&gt;
&lt;h3 class=&quot;xsj_heading_hash xsj_heading xsj_heading_h3&quot; id=&quot;e6ba90e4bba3e7a081_11&quot;&gt; &lt;span class=&quot;xsj_heading_content&quot;&gt;源代码&lt;/span&gt;&lt;/h3&gt;
&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python hljs&quot; data-info=&quot;python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; json
&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; os
&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; re
&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; hashlib &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; md5
&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; multiprocessing &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; Pool
&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; urllib.parse &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; urlencode
&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; pymongo
&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; requests
&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; bs4 &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; BeautifulSoup
&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; requests.exceptions &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; RequestException
&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; config &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; *



client = pymongo.MongoClient(MONGO_URL,connect=&lt;span class=&quot;hljs-keyword&quot;&gt;False&lt;/span&gt;)
db = client[MONGO_DB]

&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;get_page_index&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(offset, keyword)&lt;/span&gt;:&lt;/span&gt;
    data = {
        &lt;span class=&quot;hljs-string&quot;&gt;&quot;aid&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;24&quot;&lt;/span&gt;,
        &lt;span class=&quot;hljs-string&quot;&gt;&quot;app_name&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;web_search&quot;&lt;/span&gt;,
        &lt;span class=&quot;hljs-string&quot;&gt;&quot;offset&quot;&lt;/span&gt;: offset,
        &lt;span class=&quot;hljs-string&quot;&gt;&quot;format&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;json&quot;&lt;/span&gt;,
        &lt;span class=&quot;hljs-string&quot;&gt;&quot;keyword&quot;&lt;/span&gt;: keyword,
        &lt;span class=&quot;hljs-string&quot;&gt;&quot;autoload&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;true&quot;&lt;/span&gt;,
        &lt;span class=&quot;hljs-string&quot;&gt;&quot;count&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;20&quot;&lt;/span&gt;,
        &lt;span class=&quot;hljs-string&quot;&gt;&quot;en_qc&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;1&quot;&lt;/span&gt;,
        &lt;span class=&quot;hljs-string&quot;&gt;&quot;cur_tab&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;1&quot;&lt;/span&gt;,
        &lt;span class=&quot;hljs-string&quot;&gt;&quot;from&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;search_tab&quot;&lt;/span&gt;,
        
        
    }
    headers = {
        
        &lt;span class=&quot;hljs-string&quot;&gt;'cookie'&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;'tt_webid=6791640396613223949; WEATHER_CITY=%E5%8C%97%E4%BA%AC; tt_webid=6791640396613223949; csrftoken=4a29b1b1d9ecf8b5168f1955d2110f16; s_v_web_id=k6g11cxe_fWBnSuA7_RBx3_4Mo4_9a9z_XNI0WS8B9Fja; ttcid=3fdf0861117e48ac8b18940a5704991216; tt_scid=8Z.7-06X5KIZrlZF0PA9kgiudolF2L5j9bu9g6Pdm.4zcvNjlzQ1enH8qMQkYW8w9feb; __tasessionId=ngww6x1t11581323903383'&lt;/span&gt;,
        &lt;span class=&quot;hljs-string&quot;&gt;'user-agent'&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.87 Safari/537.36'&lt;/span&gt;}
    url = &lt;span class=&quot;hljs-string&quot;&gt;'https://www.toutiao.com/api/search/content/?'&lt;/span&gt; + urlencode(data)
    response = requests.get(url, headers=headers)
    &lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt;:
        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; response.status_code == &lt;span class=&quot;hljs-number&quot;&gt;200&lt;/span&gt;:
            &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; response.text
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;None&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;except&lt;/span&gt; RequestException:
        print(&lt;span class=&quot;hljs-string&quot;&gt;'Request failed!'&lt;/span&gt;)
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;None&lt;/span&gt;

&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;parse_page_index&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(html)&lt;/span&gt;:&lt;/span&gt;
    data = json.loads(html)
    
    
    
    &lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt;:
        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; data &lt;span class=&quot;hljs-keyword&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;'data'&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; data.keys():
            &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; item &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; data.get(&lt;span class=&quot;hljs-string&quot;&gt;'data'&lt;/span&gt;):
                &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; item.get(&lt;span class=&quot;hljs-string&quot;&gt;'has_gallery'&lt;/span&gt;):
                    &lt;span class=&quot;hljs-keyword&quot;&gt;yield&lt;/span&gt; item.get(&lt;span class=&quot;hljs-string&quot;&gt;'article_url'&lt;/span&gt;)
    &lt;span class=&quot;hljs-keyword&quot;&gt;except&lt;/span&gt; TypeError:
        &lt;span class=&quot;hljs-keyword&quot;&gt;pass&lt;/span&gt;

&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;get_page_detail&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(url)&lt;/span&gt;:&lt;/span&gt;
    headers = {
        &lt;span class=&quot;hljs-string&quot;&gt;'cookie'&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;'tt_webid=6791640396613223949; WEATHER_CITY=%E5%8C%97%E4%BA%AC; tt_webid=6791640396613223949; csrftoken=4a29b1b1d9ecf8b5168f1955d2110f16; s_v_web_id=k6g11cxe_fWBnSuA7_RBx3_4Mo4_9a9z_XNI0WS8B9Fja; ttcid=3fdf0861117e48ac8b18940a5704991216; tt_scid=8Z.7-06X5KIZrlZF0PA9kgiudolF2L5j9bu9g6Pdm.4zcvNjlzQ1enH8qMQkYW8w9feb; __tasessionId=yix51k4j41581315307695'&lt;/span&gt;,
        &lt;span class=&quot;hljs-string&quot;&gt;'user-agent'&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.87 Safari/537.36'&lt;/span&gt;,
        
        
        
        
    }
    &lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt;:
        
        response = requests.get(url, headers=headers)
        
        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; response.status_code == &lt;span class=&quot;hljs-number&quot;&gt;200&lt;/span&gt;:
            &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; response.text
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;None&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;except&lt;/span&gt; RequestException:
        print(&lt;span class=&quot;hljs-string&quot;&gt;&quot;请求详情页出错!&quot;&lt;/span&gt;)
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;None&lt;/span&gt;

&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;parse_page_details&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(html, url)&lt;/span&gt;:&lt;/span&gt;
    soup = BeautifulSoup(html, &lt;span class=&quot;hljs-string&quot;&gt;'xml'&lt;/span&gt;)
    title = soup.select(&lt;span class=&quot;hljs-string&quot;&gt;'title'&lt;/span&gt;)[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;].get_text()
    
    img_pattern = re.compile(&lt;span class=&quot;hljs-string&quot;&gt;'JSON.parse\(&quot;(.*?)&quot;\),'&lt;/span&gt;, re.S)
    result = re.search(img_pattern, html)
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; result:
        
        data = json.loads(eval(repr(result.group(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)).replace(&lt;span class=&quot;hljs-string&quot;&gt;'\\\\'&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'\\'&lt;/span&gt;)))
        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; data &lt;span class=&quot;hljs-keyword&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;'sub_images'&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; data.keys():
            sub_images = data.get(&lt;span class=&quot;hljs-string&quot;&gt;'sub_images'&lt;/span&gt;)
            images = [item.get(&lt;span class=&quot;hljs-string&quot;&gt;'url'&lt;/span&gt;) &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; item &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; sub_images]
            &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; image &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; images: download_image(image)
            &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; {
                &lt;span class=&quot;hljs-string&quot;&gt;'title'&lt;/span&gt;: title,
                &lt;span class=&quot;hljs-string&quot;&gt;'url'&lt;/span&gt;: url,
                &lt;span class=&quot;hljs-string&quot;&gt;'images'&lt;/span&gt;: images
            }

&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;save_to_mongo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(result)&lt;/span&gt;:&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; db[MONGO_TABLE].insert_one(result):
        print(&lt;span class=&quot;hljs-string&quot;&gt;'存储到MongoDB成功'&lt;/span&gt;, result)
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;True&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;False&lt;/span&gt;

&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;download_image&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(url)&lt;/span&gt;:&lt;/span&gt;
    print(&lt;span class=&quot;hljs-string&quot;&gt;'正在下载'&lt;/span&gt;, url)
    &lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt;:
        response = requests.get(url)
        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; response.status_code == &lt;span class=&quot;hljs-number&quot;&gt;200&lt;/span&gt;:
            save_img(response.content)
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;None&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;except&lt;/span&gt; RequestException:
        print(&lt;span class=&quot;hljs-string&quot;&gt;'请求图片出错'&lt;/span&gt;, url)
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;None&lt;/span&gt;

&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;save_img&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(content)&lt;/span&gt;:&lt;/span&gt;
    file_path = &lt;span class=&quot;hljs-string&quot;&gt;'{0}/img_download/{1}.{2}'&lt;/span&gt;.format(os.getcwd(), md5(content).hexdigest(), &lt;span class=&quot;hljs-string&quot;&gt;'jpg'&lt;/span&gt;)
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;not&lt;/span&gt; os.path.exists(file_path):
        &lt;span class=&quot;hljs-keyword&quot;&gt;with&lt;/span&gt; open(file_path, &lt;span class=&quot;hljs-string&quot;&gt;'wb'&lt;/span&gt;) &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; f:
            f.write(content)
            f.close()

&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(offset)&lt;/span&gt;:&lt;/span&gt;
    html = get_page_index(offset, KEY_WORD)
    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; url &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; parse_page_index(html):
        html = get_page_detail(url)
        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; html:
            result = parse_page_details(html, url)
            &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; result: save_to_mongo(result)

&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; __name__ == &lt;span class=&quot;hljs-string&quot;&gt;'__main__'&lt;/span&gt;:
    groups = [x * &lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; x &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; range(GROUP_START, GROUP_END + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)]
    pool = Pool()
    pool.map(main, groups)
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Fri, 14 Feb 2020 12:32:00 +0000</pubDate>
<dc:creator>不愿透露姓名的高杨</dc:creator>
<og:description>站点分析源码及遇到的问题代码结构方法定义需要的常量关于在代码中遇到的问题01. 数据库连接02.今日头条的反爬虫机制03. json解码遇到的问题04. 关于response.text和respons</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/thecatcher/p/12309427.html</dc:identifier>
</item>
<item>
<title>Simscape Multibody 教程 —— 入门学习 - MingruiYu</title>
<link>http://www.cnblogs.com/MingruiYu/p/12305851.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MingruiYu/p/12305851.html</guid>
<description>&lt;p&gt;转载请注明出处，谢谢&lt;br/&gt;原创作者：MingruiYU&lt;br/&gt;原创链接：&lt;a href=&quot;https://www.cnblogs.com/MingruiYu/p/12305851.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/MingruiYu/p/12305851.html&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;本文要点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Simscape Multibody 简介&lt;/li&gt;
&lt;li&gt;Simscape Multibody 入门学习的推荐学习材料和学习顺序&lt;/li&gt;
&lt;li&gt;建模仿真过程中的重要知识
&lt;ul&gt;&lt;li&gt;模型的参数设置（Model Workspaces）&lt;/li&gt;
&lt;li&gt;模型求解器（Solver）的选择&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于MATLAB系列的所有产品，个人认为&lt;strong&gt;最好的学习材料&lt;/strong&gt;都是 MathWorks 公司提供的&lt;a href=&quot;https://ww2.mathworks.cn/help/index.html?s_tid=CRUX_lftnav&quot;&gt;官方文档&lt;/a&gt;，非常清晰，也非常详尽。本文的大部分内容也都是基于官方文档，我也极力推荐大家以阅读官方文档为先（阅读英文版更好）。但个人学习过程中感觉学习官方文档可能存在的问题是：文档特别多，不知道该从哪个页面入手，学习顺序应该怎样。所以在这里，我会对我探索后觉得比较合适的阅读学习顺序进行梳理。&lt;/p&gt;
&lt;p&gt;我开始学习使用Simscape Multibody的契机是最近要做一个关于线状柔性体 (Deformable Linear Object) 操作控制的项目，需要首先对柔性体进行物理建模。物理建模首选当然是找一找有没有现成的仿真平台可以使用，经过调研和查找之后，发现在 Simulink 环境中有一个叫作 Simscape 的模块，其中的 Simscape Multibody 模块似乎可以达成这个目的。于是开始学习 Simscape 和 Simscape Multibody，并探索如何使用它对线状柔性体进行简单的仿真。现在这个仿真的 demo 已经基本做出来了，如何对线状柔性体进行仿真我将会在以后的文章中进行介绍，本文用来介绍一下如何入门 Simscape Multibody 模块。&lt;/p&gt;
&lt;p&gt;对于Simulink我就不过多介绍了，进入大学，一定会使用到 MATLAB ，也一定会听说过 Simulink。Simulink 是一个超级超级强大的仿真平台，除了生孩子啥都能干（笑）。对于 Simulink 的学习，首先建议阅读 &lt;a href=&quot;https://ww2.mathworks.cn/help/simulink/index.html&quot;&gt;Simulink 官方文档&lt;/a&gt;，另外如果想深入学习 Simulink 作为以后安身立命的家伙事儿的话，可以阅读《Simulink仿真及代码生成技术入门到精通》书籍。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://ww2.mathworks.cn/products/simscape.html#mulsch&quot;&gt;Simscape&lt;/a&gt; 是 Simulink 的一个模块，而 &lt;a href=&quot;https://ww2.mathworks.cn/products/simmechanics.html&quot;&gt;Simscape Multibody&lt;/a&gt; 又是 Simscape 的一个模块。其关系如下：(官方介绍)&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Simulink&lt;/strong&gt;：一个模块图环境，用于多域仿真以及基于模型的设计。它支持系统级设计、仿真、自动代码生成以及嵌入式系统的连续测试和验证。Simulink 提供图形编辑器、可自定义的模块库以及求解器，能够进行动态系统建模和仿真。Simulink 与 MATLAB 相集成，这样您不仅能够在 Simulink 中将 MATLAB 算法融入模型，还能将仿真结果导出至 MATLAB 做进一步分析。
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Simscape&lt;/strong&gt;: 可让您在 Simulink 环境中迅速创建物理系统的模型。通过 Simscape，您可以基于物理连接直接相连模块框图建立物理组件模型。通过将基础组件依照原理图装配，为电机、桥式整流器、液压致动器和制冷系统等系统建模。Simscape 附加产品提供了更多复杂组件和分析功能。
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Simscape Multibody&lt;/strong&gt;: （前身为 SimMechanics）提供了适用于 3D 机械系统（例如机器人、汽车悬架、建筑设备和飞机起落架）的多体仿真环境。您可以使用表示刚体、关节、约束、力元件和传感器的模块对多体系统进行建模。Simscape Multibody 会建立整个机械系统的运动方程并进行求解。您可将完整的 CAD 装配件（包括质量、惯性、关节、约束和 3D 几何结构）导入到模型。您可在自动生成的 3D 动画中查看系统动态。Simscape Multibody 可帮助您开发控制系统并测试系统级性能。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;简言之，Simscape 是以非常直观的形式对物理系统进行仿真的，而 Simscape Multibody 是其中专门用来对机械系统进行仿真。官方有一个&lt;a href=&quot;https://ww2.mathworks.cn/videos/simscape-multibody-overview-117986.html&quot;&gt;视频简介&lt;/a&gt;，可以让你很直观地了解 Simscape Multibody 的作用。我感觉，它区别于 Simscape 基础模块的一个重要内容就是，它可以在三维空间进行仿真，并且可以给出渲染后的三维系统。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt; 我现在使用的 MATLAB 版本是 R2019b（最新版），在我学习的过程中发现，像 Simscape Multibody 这种比较新的工具模块，更新是比较多的。我之前用的是 R2018a，发现其中很多内容和最新的官方文档都不完全一样（例如选项的位置，机械部件的种类等）。所以，在大家学习的过程中，非常建议将自己的 MATLAB 版本更新至与官方文档一致。&lt;/p&gt;

&lt;p&gt;那么，如何来学习 Simscape Multibody 呢？我个人认为，以下的入门学习流程是比较合适的：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;通过官方文档中的例子初步了解 Simscape&lt;/li&gt;
&lt;li&gt;通过官方文档中的例子初步了解 Simscape Multibody&lt;/li&gt;
&lt;li&gt;（根据需要，阅读其它的官方文档）&lt;/li&gt;
&lt;li&gt;通过官方提供的 examples 进行学习&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;通过例子初步了解-simscape&quot;&gt;通过例子初步了解 Simscape&lt;/h3&gt;
&lt;p&gt;既然 Simscape Multibody 是 Simscape 的一个子模块，那当然要先了解一下 Simscape 了。建议通过官方文档中的一个例子来了解：&lt;a href=&quot;https://ww2.mathworks.cn/help/physmod/simscape/gs/essential-steps-for-constructing-a-physical-model.html&quot;&gt;Essential Steps for Constructing a Physical Model&lt;/a&gt;。这个例子讲了如何建立一个质点-弹簧-阻尼（Mass-Spring-Damper）系统，并对其进行 PID 控制。这个例子非常详细，即使之前完全没有用过 Simulink，也可以根据教程进行操作，非常适合用来入门，通过例子来对 Simscape 进行形象直观的了解。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1921421/202002/1921421-20200214185756593-677332335.png&quot; width=&quot;80%&quot;/&gt;&lt;/div&gt;
&lt;h3 id=&quot;通过例子初步了解-simscape-multibody&quot;&gt;通过例子初步了解 Simscape Multibody&lt;/h3&gt;
&lt;p&gt;Simscape 基础模块大概了解一下就可以了，下面直接进入对于 Simscape Multibody 的学习。还是推荐通过官方文档中的例子来了解：&lt;a href=&quot;https://ww2.mathworks.cn/help/physmod/sm/getting-started-with-simmechanics.html&quot;&gt;Getting Started with Simscape Multibody&lt;/a&gt;。这个例子分四步介绍了如何从零开始，建立一个单摆的仿真模型。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1921421/202002/1921421-20200214191014688-1034934765.png&quot; width=&quot;40%&quot;/&gt;&lt;/div&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1921421/202002/1921421-20200214191259097-1024554476.png&quot; width=&quot;80%&quot;/&gt;&lt;/div&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1921421/202002/1921421-20200214190848839-2107797052.png&quot; width=&quot;40%&quot;/&gt;&lt;/div&gt;
&lt;p&gt;通过学习该示例教程，可以简单体会 Simscape Multibody 的思想，以及建模仿真的基本流程。以后遇到更复杂的模型，都是在这种简单模型的基础上，一点点叠加构成的。所以掌握好这个例子，就可以为之后学习更复杂的例子，打下很好的基础。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt; 在跟随该教程建立了一个单摆的仿真模型后，我建议，可以直接在该模型的基础上，自己动手实践，将其升级为一个双摆模型，并进行仿真实验。以此简单检验自己的掌握程度，锻炼自己的操作水平。&lt;/p&gt;
&lt;h3 id=&quot;根据需要阅读其它的官方文档&quot;&gt;（根据需要，阅读其它的官方文档）&lt;/h3&gt;
&lt;p&gt;除了 Getting Started 之外， &lt;a href=&quot;https://ww2.mathworks.cn/help/physmod/sm/index.html?s_tid=CRUX_lftnav&quot;&gt;Simscape Multibody 的官方文档&lt;/a&gt; 还包括很多很多的内容。但是我个人感觉，其它的内容比较细致，也比较杂。按顺序阅读是不太现实的。建议等到需要用什么功能、什么模块的时候，再按需求查阅，进行学习。在官方文档页面的右上角搜索栏，输入需要搜索的内容，可以很方便的检索到相关的文档。&lt;/p&gt;
&lt;h3 id=&quot;通过官方提供的-examples-进行学习&quot;&gt;通过官方提供的 examples 进行学习&lt;/h3&gt;
&lt;p&gt;官方文档的阅读是需要不断进行的，但不动手实践，没有示例支持，学习官方文档是艰涩的。Simscape Multibody 提供了很多个 &lt;a href=&quot;https://ww2.mathworks.cn/help/physmod/sm/examples.html?s_tid=CRUX_gn_example&quot;&gt;Examples&lt;/a&gt;，个人感觉，通过这些已建立好的模型进行学习，是特别直观和有效的（就好像刷点题之后，对概念的理解会更加深入）。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1921421/202002/1921421-20200214193418923-1266227978.png&quot; width=&quot;100%&quot;/&gt;&lt;/div&gt;
&lt;p&gt;点进某一个模型后，有对这个模型的简单介绍。再点击页面右上角&lt;code&gt;View MATLAB Command&lt;/code&gt;图标，会显示该模型的命令，在MATLAB软件的命令行窗口中输入该命令，就可以直接大概该模型的Simulink界面。&lt;/p&gt;
&lt;p&gt;对官方模型的每一个细节都好好研究一番，对建立自己的模型是非常有帮助的。同时，Examples 中的模型的复杂程度也是由简入繁，适合循序渐进的学习。后面的模型已经很复杂了，大家可以根据自己的情况，研究到自己觉得够用了就可以了。&lt;/p&gt;
&lt;p&gt;自此，对于 Simscape Multibody 的入门学习基本就完成了。我学完这些内容大概用了两天时间（因为在探索怎么学，所以效率较低），相信大家的学习速度肯定会快很多。&lt;/p&gt;

&lt;p&gt;下面记录一些自己在学习建模仿真过程中，觉得比较基础也比较重要，有必要展开了详细学习的内容。我也是刚刚开始探索和学习，这也是我掌握程度不断提升的过程。&lt;/p&gt;
&lt;p&gt;这些知识的列举顺序，大概就是我在学习和实践中遇到这些问题的顺序，所以对大家应该也有些参考价值。&lt;/p&gt;
&lt;p&gt;依然是以官方文档为最高参考资料。&lt;/p&gt;
&lt;h3 id=&quot;模型中的参数设置&quot;&gt;模型中的参数设置&lt;/h3&gt;
&lt;p&gt;模型中肯定少不了参数，那么怎么对模型中的参数进行设置（或者说，模型中的参数是从哪里读取的）呢？&lt;/p&gt;
&lt;p&gt;模型中的参数是存储在 model workspaces 中的。就像 MATLAB 有工作区（Base Workspaces）一样，每一个模型也有自己的工作区。model workspaces 的相关介绍: (&lt;a href=&quot;https://ww2.mathworks.cn/help/simulink/ug/using-model-workspaces.html?lang=en&quot; class=&quot;uri&quot;&gt;https://ww2.mathworks.cn/help/simulink/ug/using-model-workspaces.html?lang=en&lt;/a&gt;)，页面下方的 Related topics 中有更详细的介绍。&lt;/p&gt;
&lt;p&gt;关于如何更改 model workspaces 中存储的 data，参考文档：(&lt;a href=&quot;https://ww2.mathworks.cn/help/simulink/ug/change-model-workspace-data.html?lang=en&quot; class=&quot;uri&quot;&gt;https://ww2.mathworks.cn/help/simulink/ug/change-model-workspace-data.html?lang=en&lt;/a&gt;)。&lt;/p&gt;
&lt;h3 id=&quot;求解器solver的设置&quot;&gt;求解器（Solver）的设置&lt;/h3&gt;
&lt;p&gt;系统的仿真，必然是需要微分方程的求解的。在 Simulink 中， 微分方程的求解是自动完成的，但是需要自己选择合适的求解器（Solver），并设置合适的求解器参数。&lt;/p&gt;
&lt;p&gt;关于如何选择合适的求解器，参考文档：(&lt;a href=&quot;https://ww2.mathworks.cn/help/simulink/gui/solver.html&quot; class=&quot;uri&quot;&gt;https://ww2.mathworks.cn/help/simulink/gui/solver.html&lt;/a&gt;)。&lt;/p&gt;
&lt;p&gt;一般来说：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;首先尝试 ode45&lt;/li&gt;
&lt;li&gt;ode45 失败或低效，则尝试 ode15s（最适合刚性问题）&lt;/li&gt;
&lt;li&gt;ode15s 难以处理的问题，可尝试 ode23t（容差较宽松的条件下，更高效）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;持续学习和更新中 ……&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 14 Feb 2020 12:22:00 +0000</pubDate>
<dc:creator>MingruiYu</dc:creator>
<og:description>本文介绍了如何对 Simscape Multibody 模块进行入门学习。本文首先简介了 Simscape Multibody 模块；之后根据个人体验，推荐了适合 Simscape Multibody</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/MingruiYu/p/12305851.html</dc:identifier>
</item>
<item>
<title>Spring Cloud第十三篇  | Spring Boot Admin服务监控 - 程序开发者社区</title>
<link>http://www.cnblogs.com/coding-farmer/p/12309272.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/coding-farmer/p/12309272.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/cZkI8M0nbCkXzTeDWepHbhwXDIFJk7sPWCvPUM49IF54sSbFp9Ce4YR69fXp4JLSACibyMfpBiaFSmhZpIXPXuLw/640?wx_fmt=gif&quot; alt=&quot;&quot; data-type=&quot;gif&quot; data-ratio=&quot;0.16176470588235295&quot; data-w=&quot;680&quot; data-backw=&quot;574&quot; data-backh=&quot;93&quot; data-before-oversubscription-url=&quot;https://mmbiz.qpic.cn/mmbiz_gif/cZkI8M0nbCkXzTeDWepHbhwXDIFJk7sPWCvPUM49IF54sSbFp9Ce4YR69fXp4JLSACibyMfpBiaFSmhZpIXPXuLw/640?wx_fmt=gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本文是Spring Cloud专栏的&lt;span&gt;第十三篇&lt;/span&gt;文章，了解&lt;span&gt;前十二篇&lt;/span&gt;文章内容有助于更好的理解本文：&lt;/p&gt;
&lt;ol class=&quot; list-paddingleft-2&quot; readability=&quot;0.15137614678899&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg4NjIzNDQyNA==&amp;amp;mid=2247484047&amp;amp;idx=1&amp;amp;sn=d13d8e41bf9476dec16d6053229e90ad&amp;amp;chksm=cf9d8ed8f8ea07ce0827d83e676ebd31e403a006023d567e49426e508e85fb886da006915e24&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;Spring Cloud第一篇 | Spring Cloud前言及其常用组件介绍概览&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg4NjIzNDQyNA==&amp;amp;mid=2247484049&amp;amp;idx=1&amp;amp;sn=376c5b50e62239852a75ded77c8b0ca0&amp;amp;chksm=cf9d8ec6f8ea07d0d4a45ac1576b2d141839debb8fd32765ae70c0f14bf5839f69d0d59162a4&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;Spring Cloud第二篇 | 使用并认识Eureka注册中心&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg4NjIzNDQyNA==&amp;amp;mid=2247484067&amp;amp;idx=1&amp;amp;sn=c607a2c96e2d084de3e2b30e184cfbf8&amp;amp;chksm=cf9d8ef4f8ea07e20c572f6a21ae49f5ba28a7906e48422cbaa8a3f65906a0b68d2213417869&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;Spring Cloud第三篇 | 搭建高可用Eureka注册中心&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg4NjIzNDQyNA==&amp;amp;mid=2247484075&amp;amp;idx=1&amp;amp;sn=fbb877838f8d92ea73bd0148805f8343&amp;amp;chksm=cf9d8efcf8ea07eacdb44bedb9d429b7c3e5aa026aa6326e8976593af15688c417e0d01dea79&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;Spring Cloud第四篇 | 客户端负载均衡Ribbon&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg4NjIzNDQyNA==&amp;amp;mid=2247484076&amp;amp;idx=1&amp;amp;sn=a5a5368a831b73393261a26dd434d1f2&amp;amp;chksm=cf9d8efbf8ea07edcb935572a5883cc67f407e5d9c8340b2b5db90d1584a029500c024733651&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;Spring Cloud第五篇 | 服务熔断Hystrix&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg4NjIzNDQyNA==&amp;amp;mid=2247484077&amp;amp;idx=1&amp;amp;sn=a8efe35a9678e61ed21c11f3903523ac&amp;amp;chksm=cf9d8efaf8ea07ec4be24b7b67094d99fee5e3863a27f9b5e863c356d4058aa30960b030e4a3&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;Spring Cloud第六篇 | Hystrix仪表盘监控Hystrix Dashboard&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg4NjIzNDQyNA==&amp;amp;mid=2247484078&amp;amp;idx=1&amp;amp;sn=4fbc7c9d9ae635412c0c3f6aa25537b0&amp;amp;chksm=cf9d8ef9f8ea07efdbbb52f179a9eea277d430d17494a43b67e0b8a37290702cc0bd3a561ec0&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;Spring Cloud第七篇 | 声明式服务调用Feign&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg4NjIzNDQyNA==&amp;amp;mid=2247484080&amp;amp;idx=1&amp;amp;sn=bfd6cb072a620595cc24dd86cc1ee745&amp;amp;chksm=cf9d8ee7f8ea07f15b01373ad00b4250f68672a0aaa9c7b56e5193ac996aca4bb93e8e46374b&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;Spring Cloud第八篇 | Hystrix集群监控Turbin&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg4NjIzNDQyNA==&amp;amp;mid=2247484104&amp;amp;idx=1&amp;amp;sn=f9234818335fbecd10a35a615865c1e4&amp;amp;chksm=cf9d8e9ff8ea0789b8d103bee952485c588ce9464dde6a178a025fa4ceca7ef72ce3ba3bc669&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;Spring Cloud第九篇 | 分布式服务跟踪Sleuth&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg4NjIzNDQyNA==&amp;amp;mid=2247484105&amp;amp;idx=1&amp;amp;sn=7794a4ad0b5d8568994fb349c43ed572&amp;amp;chksm=cf9d8e9ef8ea0788bcd08990197af0bdc341d796fd4247298e9ba0c2ad3f3034a00660a09660&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;Spring Cloud第十篇 | 分布式配置中心Config&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg4NjIzNDQyNA==&amp;amp;mid=2247484107&amp;amp;idx=1&amp;amp;sn=2b26f2c35b2a32fe50174f982b28a475&amp;amp;chksm=cf9d8e9cf8ea078ae7c2da038f37aade2ca0b480983cdda0122ce1253933d4da7ab60508f0e3&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;Spring Cloud第十一篇 | 分布式配置中心高可用&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg4NjIzNDQyNA==&amp;amp;mid=2247484107&amp;amp;idx=1&amp;amp;sn=2b26f2c35b2a32fe50174f982b28a475&amp;amp;chksm=cf9d8e9cf8ea078ae7c2da038f37aade2ca0b480983cdda0122ce1253933d4da7ab60508f0e3&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;Spring Cloud第十二篇 | 消息总线Bus&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/Ljib4So7yuWhLibicgVfBjF9kiatwh7CjCRgvHcl41pH8fpmmN04LGxrye3vfpsjQb5cwhtyiaxibZawMzg87ATIN7xg/640?wx_fmt=gif&quot; alt=&quot;&quot; data-type=&quot;gif&quot; data-ratio=&quot;0.11181102362204724&quot; data-w=&quot;635&quot; data-backw=&quot;574&quot; data-backh=&quot;64&quot; data-before-oversubscription-url=&quot;https://mmbiz.qpic.cn/mmbiz_gif/Ljib4So7yuWhLibicgVfBjF9kiatwh7CjCRgvHcl41pH8fpmmN04LGxrye3vfpsjQb5cwhtyiaxibZawMzg87ATIN7xg/640?wx_fmt=gif&quot;/&gt;&lt;/p&gt;

&lt;p&gt;    Spring Boot Admin 是一个管理和监控你的 Spring Boot 应用程序的应用程序。这些应用程序通过 Spring Boot Admin Client（通过 HTTP）注册或者使用 Spring Cloud（例如 Eureka）发现。UI只是 Spring Boot Actuator 端点上的一个 AngularJs 应用程序。&lt;/p&gt;
&lt;p&gt;    原理：Spring Boot Actuator 模块为监控Spring Boot 应用程序暴露的大量的管理端点[ENDPOINT],在Spring Boot Actuator的基础上提供简洁的可视化WEB UI，是用来管理 Spring Boot 应用程序的一个简单的界面。&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;&lt;strong&gt;Spring Boot Admin也分为server和client(普通应用程序)&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;1、搭建Admin服务端&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;1-1、创键springboot admin服务端模块(springboot-admin-server)&lt;/p&gt;
&lt;p&gt;1-2、添加springboot admin服务端依赖&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;de.codecentric&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-admin-starter-server&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2.1.0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;1-3、在主类上添加注解@EnableAdminServer&lt;/p&gt;
&lt;p&gt;1-4、在application.yml文件中添加配置，然后启动&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
server:
  port: 8788
spring:
  application:
    name: springboot-admin-server
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;strong&gt;2、搭建Admin客户端&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;2-1、创建springboot admin客户端模块(springcloud-admin-client)&lt;/p&gt;
&lt;p&gt;2-2、添加springboot admin客户端依赖&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;de.codecentric&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-admin-starter-client&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2.1.0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2-3、在application.yml文件中添加配置，然后启动&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;server:
  port: 8080
spring:
  application:
    name: springcloud-admin-client
  boot:
    admin:
      client:
      #springboot admin client连接 spring boot admin server 端点地址springboot admin client连接 spring boot admin server 端点地址
        url: http://localhost:8788
        instance:
        #默认使用的是主机名注册，改为使用ip注册
          prefer-ip: true
management:
  endpoints:
    web:
      exposure:
        #开放所有页面节点  默认只开启了health、info两个节点
        include: '*'
  endpoint:
    health:
      #显示健康具体信息  默认不会显示详细信息
      show-details: always
# 利用info端点，加入版本等信息
info:
  versin: @project.version@
  name: @project.artifactId@
  group: @project.groupId@
  description: @project.description@
  #还可以自定义信息
  author: Coding Farmer
  blog: http://www.coding-farmer.cn&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2-4、启动访问spring boot admin服务端页面http://localhost:8788，显示如下&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SvdklibTTsSELrqicuJib9vjQOoKUlkYsuicOwYTI1q7Jb8PkrTbZENmW5Krp6XBOM0p2murSrSL91gibI99mupYc8A/640?wx_fmt=png&quot; alt=&quot;&quot; data-backh=&quot;144&quot; data-backw=&quot;579&quot; data-ratio=&quot;0.24921875&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SvdklibTTsSELrqicuJib9vjQOoKUlkYsuickzBEibJmnd1x5Wfr3UCxErMfk1zibruaCM4diaAPtlH928QTAfuZcXzsA/640?wx_fmt=png&quot; alt=&quot;&quot; data-backh=&quot;294&quot; data-backw=&quot;579&quot; data-ratio=&quot;0.50859375&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;3、给Sring Boot Admin添加认证&lt;/strong&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;strong&gt;i、修改admin服务端(springboot-admin-server)模块&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;3-i-1、在生产环境中，为了数据的安全，还是需要加上安全认证的，具体的可以查看官方文档：https://codecentric.github.io/spring-boot-admin/2.1.0/#_securing_spring_boot_admin_server，相对比较简单，简单来说就是加入spring-boot-starter-security进行安全认证。&lt;/p&gt;
&lt;p&gt;3-i-2、在admin服务端(springboot-admin-server)模块添加依赖&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-security&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3-i-3、在application.yml中添加用户名、密码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;spring:
  security:
    user:
      name: coding-farmer
      password: 123456&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3-i-4、编辑SpringbootAdminServerApplication.java文件，修改为&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.springcloudlearn;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; de.codecentric.boot.admin.server.config.AdminServerProperties;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; de.codecentric.boot.admin.server.config.EnableAdminServer;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.SpringApplication;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.autoconfigure.SpringBootApplication;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Configuration;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.security.config.annotation.web.builders.HttpSecurity;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.security.web.authentication.SavedRequestAwareAuthenticationSuccessHandler;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.security.web.csrf.CookieCsrfTokenRepository;
@EnableAdminServer
@SpringBootApplication
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SpringbootAdminServerApplication {
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
    SpringApplication.run(SpringbootAdminServerApplication.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, args);
  }
  @Configuration
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; SecuritySecureConfig &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; WebSecurityConfigurerAdapter {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; String adminContextPath;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; SecuritySecureConfig(AdminServerProperties adminServerProperties) {
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.adminContextPath =&lt;span&gt; adminServerProperties.getContextPath();
    }
    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; configure(HttpSecurity http) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; @formatter:off&lt;/span&gt;
      SavedRequestAwareAuthenticationSuccessHandler successHandler = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SavedRequestAwareAuthenticationSuccessHandler();
      successHandler.setTargetUrlParameter(&lt;/span&gt;&quot;redirectTo&quot;&lt;span&gt;);
      successHandler.setDefaultTargetUrl(adminContextPath &lt;/span&gt;+ &quot;/&quot;&lt;span&gt;);
      http.authorizeRequests()
          .antMatchers(adminContextPath &lt;/span&gt;+ &quot;/assets/**&quot;&lt;span&gt;).permitAll()
          .antMatchers(adminContextPath &lt;/span&gt;+ &quot;/login&quot;&lt;span&gt;).permitAll()
          .anyRequest().authenticated()
          .and()
          .formLogin().loginPage(adminContextPath &lt;/span&gt;+ &quot;/login&quot;&lt;span&gt;).successHandler(successHandler).and()
          .logout().logoutUrl(adminContextPath &lt;/span&gt;+ &quot;/logout&quot;&lt;span&gt;).and()
          .httpBasic().and()
          .csrf()
          .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())
          .ignoringAntMatchers(
              adminContextPath &lt;/span&gt;+ &quot;/instances&quot;&lt;span&gt;,
              adminContextPath &lt;/span&gt;+ &quot;/actuator/**&quot;&lt;span&gt;
          );
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; @formatter:on&lt;/span&gt;
&lt;span&gt;    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3-i-5、访问http://localhost:8788&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SvdklibTTsSELrqicuJib9vjQOoKUlkYsuicjcI64Hak2zSuNbmeUoDicm87DGesbcibSgBL1FoE4Pch0BibPQfs3jGVQ/640?wx_fmt=png&quot; alt=&quot;&quot; data-backh=&quot;320&quot; data-backw=&quot;579&quot; data-ratio=&quot;0.5535269709543569&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1205&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;ii、修改admin客户端(springboot-admin-client)模块&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;3-ii-1、由于服务端配置了密码，客户端访问的时候需要密码，这是基于SBA访问模式，也就是所谓的直接连接springboot admin服务端模式，在application.yml文件中添加username，password&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;spring:
  application:
    name: springcloud&lt;/span&gt;-admin-&lt;span&gt;client
  boot:
    admin:
      client:
      #springboot admin client连接 spring boot admin server 端点地址springboot admin client连接 spring boot admin server 端点地址
        url: http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:8788&lt;/span&gt;
&lt;span&gt;        instance:
        #默认使用的是主机名注册，改为使用ip注册
          prefer&lt;/span&gt;-ip: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
        username: coding&lt;/span&gt;-&lt;span&gt;farmer
        password: &lt;/span&gt;123456
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3-ii-2、然后启动客户端(springboot-admin-client)模块,访问http://localhost:8788，查看客户端服务注册到了admin服务端上&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SvdklibTTsSELrqicuJib9vjQOoKUlkYsuicGviaNyupUEda4JV3yjCZzMre1nk52FAa92XcPr8ZQ7cpd313LVbMySA/640?wx_fmt=png&quot; alt=&quot;&quot; data-backh=&quot;157&quot; data-backw=&quot;579&quot; data-ratio=&quot;0.27109375&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;

&lt;p&gt;    当我们监控微服务的时候，服务数量众多，我们肯定想统一管理微服务，我可以将服务全部注册到注册中心上，admin会自己拉取Eureka上注册的应用信息，主动去注册。这也是唯一区别之前手动注册(SBA连接方式)的地方，就是client端不需要admin-client的依赖，也不需要配置admin地址了，一切全部由admin-server自己实现。这样的设计对环境变化很友好，不用改了admin-server后去改所有应用的配置了。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;1、在上面基础上继续修改Admin服务端&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;1-1、添加依赖&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-cloud-starter-netflix-eureka-client&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;1-2、在启动类上添加Eureka的注解@EnableEurekaClient&lt;/p&gt;
&lt;p&gt;1-3、修改后application.yml配置文件如下，然后启动&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;server:
  port: 8788
spring:
  application:
    name: springboot-admin-server
  security:
    user:
      name: coding-farmer
      password: 123456
eureka:
  client:
    service-url:
      defaultZone: http://localhost:8700/eureka
    #客户端每隔30秒从Eureka服务上更新一次服务信息
    registry-fetch-interval-seconds: 30
    #需要将我的服务注册到eureka上
    register-with-eureka: true
    #需要检索服务
    fetch-registry: true
  #心跳检测检测与续约时间
  instance:
    #告诉服务端，如果我10s之内没有给你发心跳，就代表我故障了，将我剔除掉，默认90s
    #Eureka服务端在收到最后一次心跳之后等待的时间上限，单位为秒，超过则剔除（客户端告诉服务端按照此规则等待自己）
    lease-expiration-duration-in-seconds: 10
    #每隔2s向服务端发送一次心跳，证明自已依然活着，默认30s
    #Eureka客户端向服务端发送心跳的时间间隔，单位为秒（客户端告诉服务端自己会按照该规则）
    lease-renewal-interval-in-seconds: 2
    # 启用ip配置 这样在注册中心列表中看见的是以ip+端口呈现的
    prefer-ip-address: true
    # 实例名称  最后呈现地址：ip:2002
    instance-id: ${spring.cloud.client.ip-address}:${server.port}
    health-check-url-path: /actuator/health
 
   #Eureka 中的 metadataMap 是专门用来存放一些自定义的数据，
   # 当注册中心或者其他服务需要此服务的某些配置时可以在 metadataMap 里取。
   # 实际上，每个 instance 都有各自的 metadataMap，map 中存放着需要用到的属性。
   # 例如，上面配置中的 eureka.instance.metadata-map.username，当这个服务成功注册到 Eureka 上，
   # Spring Boot Admin 就会取拿到这个 instance，进而拿到 metadataMap 里的属性，
   # 然后放入请求头，向此服务发送请求，访问此服务的 Actuator 开放的端点。
   #说白了，这个为了连接到自己,把密码告诉eureka，spring boot admin server 拿着密码去连接客户端应用，监控信息
    metadata-map:
      user.name: ${spring.security.user.name}
      user.password: ${spring.security.user.password}
      
#使用注册中心后，他admin也可以监控自身服务状况
management:
  endpoints:
    web:
      exposure:
        #开放所有页面节点  默认只开启了health、info两个节点
        include: '*'
  endpoint:
    health:
      #显示健康具体信息  默认不会显示详细信息
      show-details: always
# 利用info端点，加入版本等信息
info:
  versin: @project.version@
  name: @project.artifactId@
  group: @project.groupId@
  description: @project.description@
  #还可以自定义信息
  author: Coding Farmer
  blog: http://www.coding-farmer.cn&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;1-4、访问如下http://localhost:8788，使用注册中心之后他也可以监控自身服务的状况&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SvdklibTTsSELrqicuJib9vjQOoKUlkYsuicDXH3LeXhDgk6LpyQYZIicMShmnFlCuQ1DIHRF1koFMib3RiayS75bd6dQ/640?wx_fmt=png&quot; alt=&quot;&quot; data-backh=&quot;281&quot; data-backw=&quot;579&quot; data-ratio=&quot;0.48515625&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;2、在上面基础上继续修改Admin客户端&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;2-1、添加依赖&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-cloud-starter-netflix-eureka-client&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2-2、在启动类上添加注解@EnableEurekaClient&lt;/p&gt;
&lt;p&gt;2-3、启动Admin客户端，然后访问Admin服务端http://localhost:8788，你会看到还有Admin服务端已被监控了&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SvdklibTTsSELrqicuJib9vjQOoKUlkYsuicVJms1OhSuMtUxeJLb5ja7QpU51oglhTrgub48IftNoZHSGooZH2TGw/640?wx_fmt=png&quot; alt=&quot;&quot; data-ratio=&quot;0.5191555903049258&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1279&quot;/&gt;&lt;/p&gt;

&lt;p&gt;详细参考案例源码：&lt;a href=&quot;https://gitee.com/coding-farmer/spirngcloud-learn&quot; target=&quot;_blank&quot;&gt;https://gitee.com/coding-farmer/spirngcloud-learn&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz/wyice8kFQhf5geQK3gu2FUugjB8iaSGpjOakn10ODqnnrL85qpRbIIf0pKGdCjfYf9tHBwlPiaAXs0BO2ib6W54p2Q/640?wx_fmt=png&quot; alt=&quot;&quot; data-width=&quot;100%&quot; data-type=&quot;png&quot; data-ratio=&quot;0.037096774193548385&quot; data-w=&quot;620&quot; data-backw=&quot;574&quot; data-backh=&quot;21&quot; data-before-oversubscription-url=&quot;https://mmbiz.qpic.cn/mmbiz/wyice8kFQhf5geQK3gu2FUugjB8iaSGpjOakn10ODqnnrL85qpRbIIf0pKGdCjfYf9tHBwlPiaAXs0BO2ib6W54p2Q/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;undefined&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SvdklibTTsSGP7K3yjbDDFFy3jloKnZaf7fz8UKQda9QtlBOasIgyNs8r2uSEgHiaDbLXf55kNRL7yHaAxDf2zFQ/640?wx_fmt=png&quot; alt=&quot;&quot; data-backh=&quot;263&quot; data-backw=&quot;574&quot; data-before-oversubscription-url=&quot;https://mmbiz.qpic.cn/mmbiz_png/SvdklibTTsSGP7K3yjbDDFFy3jloKnZaf7fz8UKQda9QtlBOasIgyNs8r2uSEgHiaDbLXf55kNRL7yHaAxDf2zFQ/0?wx_fmt=png&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;574&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;262&quot; data-ratio=&quot;0.4578125&quot; data-type=&quot;png&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 14 Feb 2020 12:00:00 +0000</pubDate>
<dc:creator>程序开发者社区</dc:creator>
<og:description>坚持把简单的事情做好就是不简单，坚持把平凡的事情做好就是不平凡。所谓成功，就是在平凡中做出不平凡的坚持。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/coding-farmer/p/12309272.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core on K8S 入门学习系列文章目录 - EdisonZhou</title>
<link>http://www.cnblogs.com/edisonchou/p/aspnet_core_on_k8s_foundation_artcles_index.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/edisonchou/p/aspnet_core_on_k8s_foundation_artcles_index.html</guid>
<description>&lt;p&gt;　　自从2018年底离开工作了3年的M公司加入X公司之后，开始了ASP.NET Core的实践，包括微服务架构与容器化等等。我们的实践是渐进的，当我们的微服务数量到了一定值时，发现运维工作量已将增加了很多，因此容器编排引擎的需求也随之产生（虽然我们一直都知道K8S的必要性）。同时，在张队发的《&lt;a href=&quot;https://www.cnblogs.com/shanyou/p/11266491.html&quot; target=&quot;_blank&quot;&gt;.NET云原生采用情况调查&lt;/a&gt;》中已经表明，容器编排和自动化领域Kubernetes已经占据了主体地位，学习Kubernetes刻不容缓！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201907/381412-20190709182042280-2033777895.png&quot; alt=&quot;K8S&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　所以，我将K8S的入门学习放到了2019年的学习列表中，并总结了一些学习笔记和实践总结的文章并汇总在这里，希望对各位园友有帮助！&lt;/p&gt;

&lt;h2&gt;2.1 Docker基础&lt;/h2&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201807/381412-20180726221105300-1650411740.png&quot; alt=&quot;&quot; width=&quot;334&quot; height=&quot;291&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　学习K8S之前需要了解一点Docker基础，如果没有Docker基础请先补补课：&lt;/p&gt;
&lt;p&gt;　　① &lt;a href=&quot;https://www.cnblogs.com/edisonchou/p/aspnetcore_on_docker_foundation.html&quot; target=&quot;_blank&quot;&gt;Docker基础、安装与运行.NET Core应用&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　② &lt;a href=&quot;https://www.cnblogs.com/edisonchou/p/docker_registry_repository_setup_introduction.html&quot; target=&quot;_blank&quot;&gt;Docker常用流行镜像仓库的搭建&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　③ &lt;a href=&quot;https://www.cnblogs.com/edisonchou/p/docker_resource_limitation_introduction.html&quot; target=&quot;_blank&quot;&gt;Docker资源限制学习与验证&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　④ &lt;a href=&quot;https://www.cnblogs.com/edisonchou/p/docker_volumes_introduction.html&quot; target=&quot;_blank&quot;&gt;Docker数据卷学习与应用&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　⑤ &lt;a href=&quot;https://www.cnblogs.com/edisonchou/p/dockerfile_inside_introduction.html&quot; target=&quot;_blank&quot;&gt;Dockerfile详解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　⑥ Docker容器监控工具与方案：&lt;/p&gt;
&lt;p&gt;　　　⑴ &lt;a href=&quot;https://www.cnblogs.com/edisonchou/p/docker_monitor_introduction_part1.html&quot; target=&quot;_blank&quot;&gt;Docker自带监控子命令 &amp;amp; 开源监控工具Weave Scope&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　　⑵ &lt;a href=&quot;https://www.cnblogs.com/edisonchou/p/docker_monitor_introduction_part2.html&quot; target=&quot;_blank&quot;&gt;Google开发的容器监控工具cAdvisor&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　　⑶ &lt;a href=&quot;https://www.cnblogs.com/edisonchou/p/docker_monitor_introduction_part3.html&quot; target=&quot;_blank&quot;&gt;生产级强大应用监控方案Prometheus&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　⑦ Docker日志管理工具与方案：&lt;/p&gt;
&lt;p&gt;　　　⑴ &lt;a href=&quot;https://www.cnblogs.com/edisonchou/p/docker_logs_study_summary_part1.html&quot; target=&quot;_blank&quot;&gt;Docker logs &amp;amp; logging driver&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　　⑵ &lt;a href=&quot;https://www.cnblogs.com/edisonchou/p/docker_logs_study_summary_part2.html&quot; target=&quot;_blank&quot;&gt;开源日志管理三兄弟之ELK&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;2.2 Kubernetes入门初探&lt;/h2&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201907/381412-20190728213622342-1731930860.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　如果你想在Windows开发机上快速体验一把K8S，那么可以借助Docker for Windows来快速体验一下：&lt;/p&gt;
&lt;p&gt;　　① &lt;a href=&quot;https://www.cnblogs.com/edisonchou/p/aspnet_core_on_k8s_firststudy_part1.html&quot; target=&quot;_blank&quot;&gt;ASP.NET Core on K8S学习初探：单节点环境搭建&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　② &lt;a href=&quot;https://www.cnblogs.com/edisonchou/p/aspnet_core_on_k8s_firststudy_part2.html&quot; target=&quot;_blank&quot;&gt;ASP.NET Core on K8S学习初探：基本概念快速一览&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　③ &lt;a href=&quot;https://www.cnblogs.com/edisonchou/p/aspnet_core_on_k8s_firststudy_part3.html&quot; target=&quot;_blank&quot;&gt;ASP.NET Core on K8S学习初探：部署WebAPI到K8S&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　如果你嫌在Linux上搭建环境麻烦，那么可以借助K8S在线实验室玩一下快速的交互实验体验一下：&lt;/p&gt;
&lt;p&gt;　　● &lt;a href=&quot;https://www.cnblogs.com/edisonchou/p/kubernetes_quick_tutorial_chinese_notes.html&quot; target=&quot;_blank&quot;&gt;Hello Kubernetes - 快速交互实验10分钟把玩手册&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;2.3 Kubernetes基础学习&lt;/h2&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201907/381412-20190728220023781-1449016642.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　想要深入学习K8S，必须在Linux下搭建一个K8S集群，尝试学习和实践各个核心组件：&lt;/p&gt;
&lt;p&gt;　　⑴ &lt;a href=&quot;https://www.cnblogs.com/edisonchou/p/aspnet_core_on_k8s_deepstudy_part1.html&quot;&gt;ASP.NET Core on K8S深入学习（1）K8S基础知识与集群搭建&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　⑵ &lt;a href=&quot;https://www.cnblogs.com/edisonchou/p/aspnet_core_on_k8s_deepstudy_part2.html&quot; target=&quot;_blank&quot;&gt;ASP.NET Core on K8S深入学习（2）部署过程解析与部署Dashboard&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　⑶ &lt;a href=&quot;https://www.cnblogs.com/edisonchou/p/aspnet_core_on_k8s_deepstudy_part3_1.html&quot; target=&quot;_blank&quot;&gt;ASP.NET Core on K8S深入学习（3-1）Deployment&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　⑷ &lt;a href=&quot;https://www.cnblogs.com/edisonchou/p/aspnet_core_on_k8s_deepstudy_part3_2.html&quot; target=&quot;_blank&quot;&gt;ASP.NET Core on K8S深入学习（3-2）DaemonSet与Job&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　⑸ &lt;a href=&quot;https://www.cnblogs.com/edisonchou/p/aspnet_core_on_k8s_deepstudy_part4.html&quot; target=&quot;_blank&quot;&gt;ASP.NET Core on K8S深入学习（4）你必须知道的Service&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　⑸ &lt;a href=&quot;https://www.cnblogs.com/edisonchou/p/aspnet_core_on_k8s_deepstudy_part5.html&quot; target=&quot;_blank&quot;&gt;ASP.NET Core on K8S深入学习（5）Rolling Update&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　⑹ &lt;a href=&quot;https://www.cnblogs.com/edisonchou/p/aspnet_core_on_k8s_deepstudy_part6.html&quot; target=&quot;_blank&quot;&gt;ASP.NET Core on K8S深入学习（6）Health Check&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　⑺ &lt;a href=&quot;https://www.cnblogs.com/edisonchou/p/aspnet_core_on_k8s_deepstudy_part7.html&quot; target=&quot;_blank&quot;&gt;ASP.NET Core on K8S深入学习（7）Dashboard知多少&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　⑻ &lt;a href=&quot;https://www.cnblogs.com/edisonchou/p/aspnet_core_on_k8s_deepstudy_part8.html&quot; target=&quot;_blank&quot;&gt;ASP.NET Core on K8S深入学习（8）数据管理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　⑼ &lt;a href=&quot;https://www.cnblogs.com/edisonchou/p/aspnet_core_on_k8s_deepstudy_part9.html&quot; target=&quot;_blank&quot;&gt;ASP.NET Core on K8S深入学习（9）Secret &amp;amp; Configmap&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　⑽ &lt;a href=&quot;https://www.cnblogs.com/edisonchou/p/aspnet_core_on_k8s_deepstudy_part10.html&quot; target=&quot;_blank&quot;&gt;ASP.NET Core on K8S深入学习（10）K8S包管理器Helm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　⑾ &lt;a href=&quot;https://www.cnblogs.com/edisonchou/p/aspnet_core_on_k8s_deepstudy_part11.html&quot; target=&quot;_blank&quot;&gt;ASP.NET Core on K8S深入学习（11）K8S网络知多少&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　关于K8S网络的基本原理与讲解，&lt;strong&gt;强力推荐&lt;/strong&gt;参考以下文章：&lt;/p&gt;
&lt;p&gt;　　⑿ ASP.NET Core on K8S深入学习（12）Nginx Ingress&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ss2.bdstatic.com/8_V1bjqh_Q23odCf/pacific/1884224890.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　（1）常见应用的K8S部署，包括：EFK、Redis集群、RabbitMQ集群、Harbor镜像仓库、Prometheus+Grafana监控方案&lt;/p&gt;
&lt;p&gt;　　（2）基于Jenkins的K8S持续集成，通过实现Jenkins流水线脚本自动发布应用到K8S集群中&lt;/p&gt;
&lt;p&gt;　　（3）阿里云ACK服务/腾讯云TKE服务的学习使用与生产实践&lt;/p&gt;

&lt;p&gt;① CloudMan，《&lt;a href=&quot;https://item.jd.com/16936307278.html&quot; target=&quot;_blank&quot;&gt;每天5分钟玩转Docker容器技术&lt;/a&gt;》、《&lt;a href=&quot;https://item.jd.com/26225745440.html&quot; target=&quot;_blank&quot;&gt;每天5分钟玩转Kubernetes&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;② 杜宽，《&lt;a href=&quot;https://www.cnblogs.com/dukuan/p/11448217.html&quot; target=&quot;_blank&quot;&gt;再也不踩坑的Kubernetes实战指南&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;③ 李振良，《&lt;a href=&quot;https://edu.51cto.com/course/12537.html&quot; target=&quot;_blank&quot;&gt;Kubernetes入门与进阶&lt;/a&gt;》（收费课程260RMB）&lt;/p&gt;
&lt;p&gt;④ 马哥（马永亮），《&lt;a href=&quot;https://ke.qq.com/course/378107&quot; target=&quot;_blank&quot;&gt;Kubernetes快速入门》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;⑤ Jesse（刘腾飞），《&lt;a href=&quot;http://video.jessetalk.cn/my/course/6&quot; target=&quot;_blank&quot;&gt;ASP.NET Core on K8S快速入门&lt;/a&gt;》（Jesse出品，必属精品）&lt;/p&gt;

&lt;p&gt;　　为了持续输出内容，我开了一个公众号“&lt;strong&gt;恰童鞋骚年&lt;/strong&gt;”，此公众号会长期关注和分享.NET Core、微服务、云原生、DevOps 及 企业数字化转型等技术内容文章，还会与你分享个人生活成长的点滴及各类好书的读书笔记，希望能对你有所帮助，一起成长！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/202001/381412-20200121205838164-1108314605.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;div id=&quot;Copyright&quot; readability=&quot;8.1860465116279&quot;&gt;
&lt;p&gt;作者：&lt;a title=&quot;author&quot; href=&quot;https://edisonchou.cnblogs.com&quot; target=&quot;_blank&quot;&gt;周旭龙&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;出处：&lt;a href=&quot;https://edisonchou.cnblogs.com&quot; target=&quot;_blank&quot;&gt;https://edisonchou.cnblogs.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接。&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Fri, 14 Feb 2020 11:57:00 +0000</pubDate>
<dc:creator>EdisonZhou</dc:creator>
<og:description>一、关于这个系列 自从2018年底离开工作了3年的M公司加入X公司之后，开始了ASP.NET Core的实践，包括微服务架构与容器化等等。我们的实践是渐进的，当我们的微服务数量到了一定值时，发现运维工</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/edisonchou/p/aspnet_core_on_k8s_foundation_artcles_index.html</dc:identifier>
</item>
</channel>
</rss>