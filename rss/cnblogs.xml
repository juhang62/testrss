<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Java中线程与堆栈的关系 - 万猫学社</title>
<link>http://www.cnblogs.com/heihaozi/p/11741733.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/heihaozi/p/11741733.html</guid>
<description>&lt;p&gt;&lt;strong&gt;栈&lt;/strong&gt;是线程私有的，每个线程都是自己的栈，每个线程中的每个方法在执行的同时会创建一个栈帧用于存局部变量表、操作数栈、动态链接、方法返回地址等信息。每一个方法从调用到执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。其中局部变量表，存放基本类型（boolean、byte、char、short、int、float）、对象的引用等等，对象的引用不是对象实例本身，而是指向对象实例的一个指针。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;堆&lt;/strong&gt;是线程共享的，所有的对象的实例和数组都存放在堆中，任何线程都可以访问。Java的垃圾自动回收机制就是运用这个区域的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法区&lt;/strong&gt;也是线程共享的，用于存放类信息（包括类的名称、方法信息、字段信息）、常量、静态变量以及即时编译器编译后的代码等等。&lt;/p&gt;
&lt;p&gt;这么讲比较抽象，写段代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-57f5669a6d95e5ef328fbf11e84071f3_r.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当程序执行到箭头指向那一个行代码的时候，&lt;br/&gt;入参i和局部变量j都是基本类型，直接存放在栈中。&lt;br/&gt;入参str和oneMoreStudy是对象类型，在栈中只存放对象的引用。&lt;br/&gt;如下图：&lt;br/&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-1f0302b48baebd252a82ca8fb71f9e12_r.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 26 Oct 2019 00:13:00 +0000</pubDate>
<dc:creator>万猫学社</dc:creator>
<og:description>线程与堆栈的关系是什么样的？是共享的？还是私有的？</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/heihaozi/p/11741733.html</dc:identifier>
</item>
<item>
<title>本月16日SpringBoot2.2发布，有哪些变化先知晓 - 字母哥博客</title>
<link>http://www.cnblogs.com/zimug/p/11741715.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zimug/p/11741715.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1815316/201910/1815316-20191026072408015-1676800979.jpg&quot; alt=&quot;本月16日SpringBoot2.2发布了，有哪些新变化呢？我来告诉你&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本月（2019年10月16日）Spring Boot 2.2已经正式发布了!在此篇文章中，将给大家介绍一下2.2版为大家带来了哪些重要的新变化。笔者用心书写，&lt;strong&gt;希望阅读完成之后转发关注，你的支持是我不竭的创作动力！&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;一spring-bean全局延迟初始化配置&quot;&gt;一、Spring bean全局延迟初始化配置&lt;/h2&gt;
&lt;p&gt;Spring Boot 2.2引入的一项新功能是&lt;strong&gt;全局延迟bean初始化&lt;/strong&gt;的支持（默认情况下，此功能处于禁用状态）。那么如果启用全局延迟bean初始化时会如何？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;所有Spring Bean&lt;/strong&gt;及其依赖项的初始化，只有当他们被使用到的时候才被创建。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为了减少应用程序的初始化过程和启动时间，您现在可以使用以下的属性配置启用全局延迟初始化Spring bean：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;spring.main.lazy.initialization=true
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是全局延迟初始化的缺点是显而易见的，在进行任何延迟的初始化时，HTTP请求的第一次处理可能需要更长的时间。后续请求不受影响。所以应该谨慎使用。如果您不想在全局范围内使用延迟初始化Spring Bean，则可以考虑使用@Lazy注释为特定bean配置延迟初始化。&lt;/p&gt;
&lt;h2 id=&quot;二默认情况下禁用jmx&quot;&gt;二、默认情况下禁用JMX&lt;/h2&gt;
&lt;p&gt;从Spring Boot 2.2开始，默认情况下禁用JMX。这有助于缩短应用程序的启动时间，并且不会在运行时浪费大量资源。如果您依赖JMX，则可以再次启用它：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;spring.jmx.enabled=true
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;三被configurationproperties注解的类被初始化为bean&quot;&gt;三、被@ConfigurationProperties注解的类被初始化为bean&lt;/h2&gt;
&lt;p&gt;Spring Boot将为每个@ConfigurationProperties通过类路径扫描发现的配置类创建一个Bean。在之前版本的开发过程中，如果我们希望配置类被初始化为一个bean ,则需要在配置类上使用@Component注解使其成为bean。现在不需要了，只需要一个@ConfigurationProperties注解。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：如果两个注解都用，被注解的类可能会创建两个bean，所以请把@Component注解移除掉。不要两个一起用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;四java-13支持&quot;&gt;四、Java 13支持&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1815316/201910/1815316-20191026072408259-211607656.jpg&quot; alt=&quot;本月16日SpringBoot2.2发布了，有哪些新变化呢？我来告诉你&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Java 13于2019年9月17日正式发布了。&lt;/p&gt;
&lt;p&gt;Spring Framework 5.2和Spring Boot 2.2也支持Java13。LTS Java版本8和11将与Spring Boot 2.2保持兼容。&lt;/p&gt;
&lt;h2 id=&quot;五配置键更改&quot;&gt;五、配置（键）更改&lt;/h2&gt;
&lt;p&gt;Spring Boot 2.2引入了许多新的配置。还有一些不推荐使用和被删除的配置。比较重要的更改是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;logging.file属性已重命名为logging.file.name&lt;/li&gt;
&lt;li&gt;logging.path属性已重命名为logging.file.path&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1815316/201910/1815316-20191026072408396-462230603.jpg&quot; alt=&quot;本月16日SpringBoot2.2发布了，有哪些新变化呢？我来告诉你&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;六-依赖升级&quot;&gt;六、 依赖升级&lt;/h2&gt;
&lt;p&gt;Spring Boot 2.2附带了许多依赖项升级。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;与Spring相关的依赖项升级：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Spring Framework 5.2.0&lt;/li&gt;
&lt;li&gt;Spring AMQP 2.2.0&lt;/li&gt;
&lt;li&gt;Spring Batch 4.2.0&lt;/li&gt;
&lt;li&gt;Spring Data Moore RELEASE&lt;/li&gt;
&lt;li&gt;Spring HATEOAS 1.0.0&lt;/li&gt;
&lt;li&gt;Spring Integration 5.2.0&lt;/li&gt;
&lt;li&gt;Spring Kafka 2.3.0&lt;/li&gt;
&lt;li&gt;Spring Security 5.2.0&lt;/li&gt;
&lt;li&gt;Spring Session Corn&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;其他最重要的依赖项升级：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Elasticsearch 6.8.3(see breaking changes: in6.5,6.6and6.7)&lt;/li&gt;
&lt;li&gt;Flyway 6.0.6&lt;/li&gt;
&lt;li&gt;HSQLDB 2.5.0&lt;/li&gt;
&lt;li&gt;Jackson 2.10.0&lt;/li&gt;
&lt;li&gt;Jersey 2.29.1&lt;/li&gt;
&lt;li&gt;Kafka 2.3.0&lt;/li&gt;
&lt;li&gt;Kotlin 1.3.50&lt;/li&gt;
&lt;li&gt;Lombok 1.18.10&lt;/li&gt;
&lt;li&gt;Micrometer 1.3&lt;/li&gt;
&lt;li&gt;Netty 4.1.42&lt;/li&gt;
&lt;li&gt;Reactor Dysprosium&lt;/li&gt;
&lt;li&gt;Solr 8.2.0&lt;/li&gt;
&lt;li&gt;Tomcat 9.0.27&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;测试依赖项升级：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;AssertJ 3.13.2(breaking changes)&lt;/li&gt;
&lt;li&gt;Hamcrest 2.1&lt;/li&gt;
&lt;li&gt;Mockito 3.1.0&lt;/li&gt;
&lt;li&gt;Junit 5.5.2(JUnit 5’s vintage engine still support existing JUnit 4-based test classes so no breaking changes here)&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;期待您的关注&quot;&gt;期待您的关注&lt;/h2&gt;
</description>
<pubDate>Fri, 25 Oct 2019 23:24:00 +0000</pubDate>
<dc:creator>字母哥博客</dc:creator>
<og:description>本月（2019年10月16日）Spring Boot 2.2已经正式发布了!在此篇文章中，将给大家介绍一下2.2版为大家带来了哪些重要的新变化。笔者用心书写， 希望阅读完成之后转发关注，你的支持是我不</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zimug/p/11741715.html</dc:identifier>
</item>
<item>
<title>记因git规范导致的提测和发布延迟 - 三升水</title>
<link>http://www.cnblogs.com/sanshengshui/p/11741625.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sanshengshui/p/11741625.html</guid>
<description>&lt;h2 id=&quot;号外&quot;&gt;号外&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://james-1258744956.cos.ap-shanghai.myqcloud.com/git-error/git_error.jpg&quot; alt=&quot;背景图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最&lt;/strong&gt;近因为换工作的原因，我的博客和Github没有像之前那样频繁的更新了。一方面原因是投递简历和准备面试，由于之前的基础没有很扎实，需要把平时的知识点都整理一遍。这个时间段持续了20多天的样子，因为今年的互联网市场遇冷，简历反馈率都不是很好。&lt;/p&gt;
&lt;p&gt;​ 我一共投递了菜鸟网络，天猫超市，有赞，大搜车和涂鸦智能等公司，都收到了面试邀请。菜鸟网络和涂鸦智能投递的职位方向都是我比较感兴趣的IOT，有赞投递的是风控和大搜车的新零售职位，后两个都是我之前的没有接触过的领域。最后由于各方面的考虑(没面试成功和对工作以及生活的平衡)，我选择了之前没有接触过的大搜车新零售领域的职位。&lt;/p&gt;
&lt;p&gt;​ 但是今天我想说的并不是面试经历，而是我标题所描述的工作中发生的有趣的事。因为新入职一个公司，需要对工作流程和项目代码进行熟悉，同时还需要对新零售这个领域和行业需要进行了解和认识。所以拿到产品分配给我的需求，我大部分的时间都是花在了需求整理和询问同事上了，真正花在写业务需求上的时间是很少的。&lt;/p&gt;
&lt;p&gt;​ 下图是我每天记录的📒，其他的分类由于设计到公司业务所以没有展开，在工作和生活上都与涉及。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://james-1258744956.cos.ap-shanghai.myqcloud.com/git-error/%E5%A4%87%E5%BF%98%E5%BD%95.png&quot; alt=&quot;备忘录&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​ 一般我们的产品需求周期是这样的: 产品整理需求池 -&amp;gt; 交互评审 -&amp;gt; 技术评审 -&amp;gt; 联调 -&amp;gt; 提测 -&amp;gt; 预发 -&amp;gt; 发布。&lt;/p&gt;
&lt;p&gt;​ 当然我作为一个开发来说，更多关注的是需求的业务逻辑和优化、实现上。每个团队都有自己的git分支规范，我们也不例外。&lt;/p&gt;
&lt;h2 id=&quot;git分支规范&quot;&gt;Git分支规范&lt;/h2&gt;
&lt;ol readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;feature分支&lt;/p&gt;
&lt;p&gt;开发新功能时，应用从develop分支简历feature分支。命名规则时: feature/${ 建立分支时的日期，yyyyMMdd格式 }/${建立分支的人的姓名拼音首字母}/${分支后缀名}&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;建立分支的人的姓名拼音首字母: 例如，开发者是&quot;穆书伟&quot;，这里就是msw,要求全小写。&lt;/li&gt;
&lt;li&gt;建立分支时的日期: 例如，20191025。&lt;/li&gt;
&lt;li&gt;分支后缀名：如果我需要开发博客文章这个需求，可能这里我写的名称是 blog_article,要求全小写，用下划线格式。&lt;/li&gt;
&lt;li&gt;feature分支开发完毕，和前端联调时，将此分支合并到测试分支上(deploy-test)。当联调完毕，我们需要将分支合并到预发环境上(deploy-prepub)，此时我和前端需要写提测单，将需求实现内容给测试工程师进行测试(下面可能有和此雷同的内容，下面的博文我会以【上文实现】来代替)。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;bugfix分支&lt;/p&gt;
&lt;p&gt;不紧急的bug修复分支。命名规则是: bugfix/${建立分支时的日期，yyyyMMdd格式}/${建立分支的人的姓名拼音首字母}/{分支后缀名}&lt;/p&gt;
&lt;p&gt;​ 和上文实现类似。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;hotfix分支&lt;/p&gt;
&lt;p&gt;​ 紧急的bug修复分支，命名规则是：hotfix/${建立分支时的日期，yyyyMMdd格式}/${建立分支的人的姓名拼音首字母}/{分支后缀名}&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;release分支&lt;/p&gt;
&lt;p&gt;release可以比较有效的避免发布搭车的情况，这个分支目前比较少用到，因为运维是发布的master分支，使用方式为用git flow release去生产。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;错误案例&quot;&gt;错误案例&lt;/h2&gt;
&lt;p&gt;​ 本来我作为一个有三年开发经验的工程师，我本不应该犯以下的错误。但Jira(bug管理工具)不断弹出被测试提出来的bug和当时远没有现在写这篇博客时, 对公司的规范十分熟悉的情况下，我做出了十分愚蠢的举动。&lt;/p&gt;
&lt;p&gt;​ 为了尽快的看到自己写的代码是否修复bug,我不仅仅在自己的分支上修改了需求实现，而且也在deploy-test上做了改动但是没有同步到自己的分支上。当我解决完Jira上所有bug时，满心欢喜的想要把分支合并到develop上时。我一看代码，回想到了整个过程，此时，我是绝望而又懵逼的。此时电脑的时间已经走到了16:30,我抓耳挠腮，不知道怎么办了。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;此时，大家可能会注意到deploy-test上有完整的我修复的程序，因为deploy-test是联调和测试过的代码。此时很多小伙伴在我当时的情况下，会把deploy-test合并到develop上。但是deploy-test分支太过脏乱，有很多其他开发人员写的测试代码和打印日志代码。&lt;strong&gt;永远不要把deploy-test分支合并到自己的分支，也不要合并到develop和master分支上&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以前我认为钉钉是一个提高工作效率的IM软件，但是此时的它如悬在我头顶上的倒计时的💣。未读-&amp;gt;已读，短时间没有读，就会DING。未读-&amp;gt;5-10分钟没有解决，钉钉电话☎️就会打过来。&lt;/p&gt;
&lt;p&gt;此时我还是沉下心来，把之前在deploy-test上修改的部分而未同步到自己的分支上的代码移过来。以下是我的IDEA操作步骤，当然大家也可以用其他可视化工具或者命令行。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;切换到自己的分支上，利用IDEA上的可视化工具，进行版本对比。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://james-1258744956.cos.ap-shanghai.myqcloud.com/git-error/%E7%89%88%E6%9C%AC%E5%AF%B9%E6%AF%94.png&quot; alt=&quot;版本对比&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;选择远程的deploy-test分支，进行版本代码对比。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://james-1258744956.cos.ap-shanghai.myqcloud.com/git-error/%E7%BA%BF%E4%B8%8A%E5%88%86%E6%94%AF.png&quot; alt=&quot;线上分支&quot;/&gt;&lt;/p&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;选择相应的分支后，我们能看到两个版本上不同的文件。此时，我们需要根据我们的记忆，对相应的文件进行修改。&lt;img src=&quot;https://james-1258744956.cos.ap-shanghai.myqcloud.com/git-error/%E4%BB%A3%E7%A0%81%E4%B8%80%E8%A7%88.png&quot; alt=&quot;代码一览&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;文件代码对比，我们可以点击 &lt;strong&gt;&amp;gt;&amp;gt;&lt;/strong&gt;,将deploy-test上的代码挪到自己的分支上去。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://james-1258744956.cos.ap-shanghai.myqcloud.com/git-error/%E4%BB%A3%E7%A0%81%E5%AF%B9%E6%AF%94.png&quot; alt=&quot;代码对比&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​ 做了上面紧急的处理后，我又在本地运行了程序，做了简单的自测并在最后的关头给测试写了提测单。经测试无误后，发不到了线上，此时，我的心在落到了肚子里。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://james-1258744956.cos.ap-shanghai.myqcloud.com/git-error/%E5%8F%91%E5%B8%83%E6%88%90%E5%8A%9F.png&quot; alt=&quot;发布成功&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;​ 开发是个技术性工作，而团队开发是一个纪律性、团队合作性和有一定哲学性的学问。虽然上面👆的条条框框让我的开发效率变得很不好，当然这个效率是相对个人而言。因为每开发一个新需求就需要建立分支，合并代码到各种环境，对于一个不细心和急躁的工程师，光这个工作都令人烦恼了。但是对于一个团队来说，以上的条条框框对于整个团队是高效而又不会出错的。在这里，笔者有个小问题，你们团队的git工作流程又是怎么样的呢？麻烦告知一下。&lt;/p&gt;
&lt;h2 id=&quot;资源推荐&quot;&gt;资源推荐&lt;/h2&gt;
&lt;h3 id=&quot;工具推荐&quot;&gt;工具推荐&lt;/h3&gt;
&lt;ol readability=&quot;1.8573853989813&quot;&gt;&lt;li readability=&quot;2.9173553719008&quot;&gt;
&lt;p&gt;我们在每次提交代码时，都需要编写Commit Message，否则是不允许提交的。 &lt;code&gt;git commit -m first commit with userInfo service&lt;/code&gt;，编写Commit Message需要遵循一定的范式，内容应该清晰明了，指明本次提交的目的，便于日后追踪问题。 &lt;a href=&quot;https://github.com/commitizen/cz-cli&quot;&gt;&lt;strong&gt;commitizen&lt;/strong&gt;&lt;/a&gt; 就是这么样一款工具,他用来规范化我们的commit消息。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0.85777777777778&quot;&gt;
&lt;p&gt;​ 因为git的commit提交是支持emoji表情的，所以在非正式场合或者想趣味性的表达自己的提交信息，可以在调教信息中添加emoji代码，具体网址参考: &lt;a href=&quot;https://gitmoji.carloscuesta.me/&quot; class=&quot;uri&quot;&gt;https://gitmoji.carloscuesta.me/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;实际效果如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://james-1258744956.cos.ap-shanghai.myqcloud.com/git-error/git-emoji.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;快速安装&quot;&gt;快速安装&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;安装nodejs（&lt;a href=&quot;https://nodejs.org/en/&quot; class=&quot;uri&quot;&gt;https://nodejs.org/en/&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;安装commitizen，在用户目录下配置&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;cd ~&lt;/p&gt;
&lt;p&gt;npm install -g commitizen&lt;/p&gt;
&lt;p&gt;commitizen init cz-conventional-changelog --save --save-exact&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;简单使用&quot;&gt;简单使用&lt;/h3&gt;
&lt;p&gt;这里推荐阮一峰的博文：&lt;a href=&quot;http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html&quot; class=&quot;uri&quot;&gt;http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;走进git&quot;&gt;走进Git&lt;/h3&gt;
</description>
<pubDate>Fri, 25 Oct 2019 16:52:00 +0000</pubDate>
<dc:creator>三升水</dc:creator>
<og:description>号外 最 近因为换工作的原因，我的博客和Github没有像之前那样频繁的更新了。一方面原因是投递简历和准备面试，由于之前的基础没有很扎实，需要把平时的知识点都整理一遍。这个时间段持续了20多天的样子，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sanshengshui/p/11741625.html</dc:identifier>
</item>
<item>
<title>浅谈微服务架构与.Net Core - 猿来似梦</title>
<link>http://www.cnblogs.com/minghon/p/11741519.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/minghon/p/11741519.html</guid>
<description>&lt;p&gt;&lt;strong&gt;微服务&lt;/strong&gt;（microservice）这个概念是2012年出现的，2014年3月Martin Fowler在他的个人网站（&lt;a href=&quot;https://martinfowler.com/articles/microservices.html&quot; target=&quot;_blank&quot;&gt;https://martinfowler.com/articles/microservices.html&lt;/a&gt;）中是这样说到的：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;The term &quot;Microservice Architecture&quot; has sprung up over the last few years to describe a particular way of designing software applications as suites of independently deployable services. While there is no precise definition of this architectural style, there are certain common characteristics around organization around business capability, automated deployment, intelligence in the endpoints, and decentralized control of languages and data.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;&lt;em&gt;&lt;strong&gt;“&lt;/strong&gt;&lt;/em&gt;微服务架构”&lt;/strong&gt;一词在过去几年中兴起，描述的是将软件应用程序设计为可独立部署服务套件的特定方式。虽然没有对这种架构风格的精确定义，&lt;em&gt;但其具有一些共同的特性，如围绕业务能力自动化部署、智能端点、对语言及数据的“去集中化”控制等等。&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;通俗的讲，我们可以这样认为：传统系统的开发，我们将整个系统分为表示层、服务层、业务逻辑层、数据访问层进行开发，但最终我们将这所有的代码编译在一起发布，这样做也有它的优点，比如开发简单、不存在分布式管理，但这样也有缺点，比如：一个小的bug可能导致整个应用程序的崩溃、系统业务之间代码耦合度高不易于维护、开发不灵活，若有新的业务需求只能往原有代码上加逻辑，这样对开发团队成员要求高，若团队成员更替频繁，新成员必须先熟悉团队的开发框架，很难适应这种开发模式、还有随着系统业务增多，功能增加，数据量越来越大，更是无法满足高并发下的业务需求；若我们采用微服务架构，那就将我们整个系统拆分为多个业务，将每个业务做成一个服务，服务之间采用HTTP（也可以使用消息队列RoocketMQ，Kafaka）通信，而且每个服务可以采用不同的开发语言、使用不同的存储方式，根据不同业务的并发需求，我们可以单独对某个服务做集群部署，增强系统的负载能力，由于每个服务都是独立部署的，每个服务的修改和部署对其他服务没有影响，当然，微服务也有一些缺点，比如：代码的重复，某些底层功能需要被多个服务所用，为了避免将“同步耦合引入到系统中”，有时需要向不同服务添加一些代码，这就会导致代码重复；开发人员需要考虑分布式系统的问题，如网络延迟、异步机制、系统容错性、分布式事务等；另外运维开销及成本也会增加，微服务架构可能需要运行数十个独立的服务，并可能需要支持多种语言和环境，对运维人员的要求也比较高。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;小结&lt;/strong&gt;：微服务架构有很多吸引人的地方，在拥抱微服务之前，我们要根据团队的实际情况以及项目实际情况选择是否适合采用该架构。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;.NET Core&lt;/strong&gt;是适用于 windows、linux 和 macos 操作系统的免费、开源托管的计算机软件框架，是微软开发的第一个官方版本，具有跨平台 (Windows、Mac OSX、Linux) 能力的应用程序开发框架 (Application Framework)，未来也将会支持 FreeBSD 与 Alpine 平台，也是微软在一开始发展时就开源的软件平台 。&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;由于 .NET Core 的开发目标是跨平台的 .NET 平台，因此 .NET Core 会包含 .NET Framework 的类库，但与 .NET Framework 不同的是 .NET Core 采用包化 (Packages) 的管理方式，应用程序只需要获取需要的组件即可，与 .NET Framework 打包式安装的做法截然不同，同时各包亦有独立的版本线 (Version line)，不再硬性要求应用程序跟随主线版本。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;.NET Core的优势：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;.NET Core 3.0现在支持了WPF和Windows Forms的开发，同时还支持UWP，WPF和Windows Forms三者间的混合开发，这为开发人员提供了灵活性，可以将UWP的现有接口引入Windows窗体和WPF中。&lt;/p&gt;
&lt;p&gt;.NET Core 更适合跨平台的开发。 .NET Core 应用支持Windows，Linux和Mac OS。微软很受欢迎的代码编辑器 Visual Studio Code 支持Windows，Linux和Mac OS。VS Code还支持智能提示和调试，许多第三方代码编辑器（如Sublime、Emacs和VI）也都是使用.Net Core开发的。&lt;/p&gt;
&lt;p&gt;.NET Core支持微服务架构，它允许跨平台服务与.NET Core一起使用，包括使用.NET Framework、Java、Ruby或其他语言开发的服务。&lt;/p&gt;
&lt;p&gt;.NET Core的模块化，轻量级和灵活性，使在容器中部署.NET Core应用程序变得更加容易。而容器可以部署在任何平台包括云，Linux和Windows上，. Net Core在Docker和Azure Kubernetes Service上都运行良好。&lt;/p&gt;
&lt;p&gt;.NET Core每个版本之间的兼容性很好。你可以在同一台电脑上面同时运行不同版本的应用。&lt;/p&gt;


&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 25 Oct 2019 16:01:00 +0000</pubDate>
<dc:creator>猿来似梦</dc:creator>
<og:description>微服务（microservice）这个概念是2012年出现的，2014年3月Martin Fowler在他的个人网站（https://martinfowler.com/articles/microse</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/minghon/p/11741519.html</dc:identifier>
</item>
<item>
<title>HDFS概述（一） - 三秋叶</title>
<link>http://www.cnblogs.com/simon-1024/p/11741184.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/simon-1024/p/11741184.html</guid>
<description>&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;1. HDFS产出的背景及定义&lt;/span&gt;&lt;/h2&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;1.1 HDFS产生的背景&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;随着数据量越来越大，在一个操作系统存不下所有的数据，那么就分配到更多的操作系统管理的磁盘中，但是不方便管理和维护，迫切需要一种系统来管理多台机器上的文件，这就是分布式文件管理系统。HDFS只是分布式文件管理系统中的一种。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;1.2 HDFS的定义&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;HDFS（Hadoop Distributed File System），它是一个文件系统，用于存储文件，通过目录树来定位文件；其次，它是分布式的，由很多服务器联合起来实现其功能，集群中的服务器有各自的角色。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;HDFS的使用场景：适合一次写入，多次读出的场景，且不支持文件的修改。适合用来做数据分析，并不适合用来做网盘应用。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;2. HDFS的优缺点&lt;/span&gt;&lt;/h2&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;2.1 优点：&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;1). 高容错性&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;（1）数据自动保存多个副本，它通过增加数据副本的样式，提高容错性&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span&gt;     &lt;img src=&quot;https://img2018.cnblogs.com/blog/1610225/201910/1610225-20191025222017401-1153697447.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;file://c/Users/Simon/Desktop/hadoop学习笔记/images/hdfs/TIM截图20191024133154.png?lastModify=1572013113&quot; alt=&quot;&quot; data-local-refresh=&quot;true&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;（2）某一个数据副本丢失以后，它可以自动恢复&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;     &lt;img src=&quot;https://img2018.cnblogs.com/blog/1610225/201910/1610225-20191025222027189-1186606504.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;images/hdfs/TIM截图20191024133217.png&quot;&gt;&lt;img src=&quot;file://c/Users/Simon/Desktop/hadoop学习笔记/images/hdfs/TIM截图20191024133217.png?lastModify=1572013113&quot; alt=&quot;&quot; data-local-refresh=&quot;true&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p md-focus&quot;&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;2) 适合处理大数据&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;（1）数据规模：能够处理规模达到GB、TB、甚至PB的级的大数据 ；&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;3) 可构建在廉价机器上，通过多副本机制，提高可靠性。&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;2.2 缺点&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;1）不适合低时延的数据访问；&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;2）无法高效的对大量小文件进行存储：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;（1）存储大量小文件的话，它会占用NameNode大量的内存来存储文件的目录和块信息；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;（2）小文件的存储的寻址时间超过了读取时间，违反了HDFS的设计目标。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;3）不支持并发的写入、文件随机修改&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;（1）一个文件只能有一个写，不允许多个线程同时写；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;（2）仅支持数据的append(追加)，不支持文件的随机修改&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;images/hdfs/TIM截图20191024183753.png&quot;&gt;&lt;img src=&quot;file://c/Users/Simon/Desktop/hadoop学习笔记/images/hdfs/TIM截图20191024183753.png?lastModify=1572013113&quot; alt=&quot;&quot; data-local-refresh=&quot;true&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1610225/201910/1610225-20191025222055482-1501381628.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;3. HDFS的组成架构&lt;/span&gt;&lt;/h2&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;3.1 整体架构图如下:&lt;/span&gt;&lt;/h3&gt;
&lt;h4 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;       &lt;img src=&quot;https://img2018.cnblogs.com/blog/1610225/201910/1610225-20191025222113616-517116942.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;file://c/Users/Simon/Desktop/hadoop学习笔记/images/hdfs/TIM截图20191024185715.png?lastModify=1572013113&quot; alt=&quot;&quot; data-local-refresh=&quot;true&quot;/&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;3.2 HDFS架构详解&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;1）NameNode(简称：ND)：就是master,它是一个主管人员，负责管理HDFS的相关信息：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;（1）管理HDFS的名称空间；&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;（2）管理副本的策略；&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;（3）管理数据块（Block）的映射信息；&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;（4）处理客户端的读写请求。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;2）DataNode(简称：DN)：就是slave，NameNode下达指令，DataNode执行实际的操作：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;（1）存储实际的数据块；&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;（2）执行数据块的读/写操作。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;3）Client：客户端，与NameNode交互的程序，职责或功能如下：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;（1）文件切分：在上传文件至HDFS的时候，Client会将文件分切成一个个的Block上传；&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;（2）与NameNode交互，可以获取文件的位置信息（存在哪个节点上）&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;（3）Client可以通过一些命令来访问HDFS,比如增删改查操作；&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;（4）Client通过一些命令来管理HDFS，比如将NameNode格式化。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;4）SecondaryNameNode：并非是NameNode的热备。当NameNode挂掉的时候，它并不会立即替换NameNode并提供服务。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;（1）辅助NameNode,分担其工作量，比如定期合并FsImage和Edits(后边会讲到，这里不用理解)，并将合并后的FsImage.checkPoint推送给NameNode;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;（2）在紧急情况下可以辅助恢复NameNode。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;4 HDFS的文件块大小&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;1）HDFS中的文件在物理上是按照块(Block)存储的，块id大小可以通过配置参数（dfs.blocksize）来规定，默认大小在Hadoop2.x的版本中是128M，老版本的是64M。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;2）块的大小设定：文件的寻址时间应为块文件的传输时间的1%,这是比较合理的设定。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;3）思考：为什么块的大小不能设置太小，也不能设置太大？&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;（1）HDFS的块如果设置的太小，会增加寻址时间，程序长时间在寻找块的存储位置；&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;（2）如果设置太大，从磁盘传输的时间会明显大于定位这个块的起始位置所需的时间。导致在处理这个块的数据时，浪费了大量的时间在IO上。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;因此，块的大小可以根据数据量和磁盘的IO速度决定如何设置。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-plain&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 25 Oct 2019 14:32:00 +0000</pubDate>
<dc:creator>三秋叶</dc:creator>
<og:description>1. HDFS产出的背景及定义 1.1 HDFS产生的背景 随着数据量越来越大，在一个操作系统存不下所有的数据，那么就分配到更多的操作系统管理的磁盘中，但是不方便管理和维护，迫切需要一种系统来管理多台</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/simon-1024/p/11741184.html</dc:identifier>
</item>
<item>
<title>MyBatis 之源码浅读 - 赐我白日梦</title>
<link>http://www.cnblogs.com/ZhuChangwu/p/11741125.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ZhuChangwu/p/11741125.html</guid>
<description>&lt;h2 id=&quot;环境简介与入口&quot;&gt;环境简介与入口&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;记录一下尝试阅读Mybatis源码的过程,这篇笔记是我一边读,一遍记录下来的,虽然内容也不多,对Mybatis整体的架构体系也没有摸的很清楚,起码也能把这个过程整理下来,这也是我比较喜欢的一种学习方式吧&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;单独Mybatis框架搭建的环境,没有和其他框架整合&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;入口点的源码如下:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Test
public void test01() {

 try {
    this.resourceAsStream = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);
    // 2. 创建SqlSessionFactory工厂
    this.factory = new SqlSessionFactoryBuilder().build(resourceAsStream);
    // 3. 创建sqlSession
    // todo 怎么理解这个sqlSession？ 首先它是线程级别的，线程不安全， 其次它里面封装了大量的CRUD的方法
    this.sqlSession = factory.openSession();

    IUserDao mapper = this.sqlSession.getMapper(IUserDao.class);
    List&amp;lt;User&amp;gt; all = mapper.findAll();
    for (User user : all) {
        System.out.println(user);
    }
    // 事务性的操作,自动提交
    this.sqlSession.commit();
    // 6, 释放资源
    this.sqlSession.close();
    this.resourceAsStream.close();
  } catch (IOException e) {
   e.printStackTrace();
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;构建sqlsessionfactory&quot;&gt;构建SqlSessionFactory&lt;/h2&gt;
&lt;p&gt;首先跟进这个,看看如何构建&lt;code&gt;SqlSessionFactory&lt;/code&gt;对象&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; this.factory = new SqlSessionFactoryBuilder().build(resourceAsStream);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个&lt;code&gt;SqlSessionFactoryBuilder&lt;/code&gt;类的存在很简单,取名也叫他构建器,Mybatis的官网是这样解释它的,这个类可以被实例化(因为它有且仅有一个默认的无参构造),使用它的目的就是用来创建多个SqlSessionFactory实例,&lt;strong&gt;最好不要让他一直存在,进而保证所有用来解析xml的资源可以被释放&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所以跳过对这个构建器的关注,转而看的&lt;code&gt;build()&lt;/code&gt;方法&lt;/p&gt;
&lt;p&gt;首先会来到这个方法,直接可以看到存在一个XML配置解析器,这其实并不意外,毕竟现在是MyBatis是孤军一人,就算我们使用的是注解开发模式,不也得存在主配置文件不是?&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;  public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) {
    try {
      XMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties);
      return build(parser.parse());
    } catch (Exception e) {
      throw ExceptionFactory.wrapException(&quot;Error building SqlSession.&quot;, e);
    } finally {
      ErrorContext.instance().reset();
      try {
        inputStream.close();
      } catch (IOException e) {
        // Intentionally ignore. Prefer previous error.
      }
    }
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着看看&lt;code&gt;parser.parse()&lt;/code&gt;,它里面会解析主配置文件中的信息,解析哪些信息呢? 源码如下: 很清楚的看到,涵盖mybatis配置文件中的所有的标签&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; private void parseConfiguration(XNode root) {
    try {
      //issue #117 read properties first
      propertiesElement(root.evalNode(&quot;properties&quot;));
      Properties settings = settingsAsProperties(root.evalNode(&quot;settings&quot;));
      ...
      typeHandlerElement(root.evalNode(&quot;typeHandlers&quot;));
      mapperElement(root.evalNode(&quot;mappers&quot;));
    } catch (Exception e) {
      throw new BuilderException(&quot;Error parsing SQL Mapper Configuration. Cause: &quot; + e, e);
    }
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一个问题: 解析的配置信息存在哪里呢? 其实存放在一个叫&lt;code&gt;Configuration&lt;/code&gt;的封装类中, 这个上面的解析器是&lt;code&gt;XMLConfigBuilder&lt;/code&gt; 这个封装类的保存者是它的父类&lt;code&gt;BaseBuilder&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;继续跟进&lt;code&gt;build()&lt;/code&gt;方法,源码如下:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; public SqlSessionFactory build(Configuration config) {
    return new DefaultSqlSessionFactory(config);
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;小结: 至此也就完成了DefaultSqlSessionFactory()的构建,回想下,这个构建器真的太无私了,牺牲了自己,不仅仅创建了默认的SqlSessionFactory,还将配置文件的信息给了他&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;打开sqlsession&quot;&gt;打开SqlSession&lt;/h2&gt;
&lt;p&gt;创建完成SqlSession工厂的创建, 我们继续跟进&lt;code&gt;this.sqlSession = factory.openSession();&lt;/code&gt; , 从工厂中获取一个SqlSession&lt;/p&gt;
&lt;p&gt;跟进几个空壳方法,我们很快就能来到下面的方法:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;  private SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level, boolean autoCommit) {
    Transaction tx = null;
    try {
      final Environment environment = configuration.getEnvironment();
      final TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);
      tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);
      final Executor executor = configuration.newExecutor(tx, execType);
      return new DefaultSqlSession(configuration, executor, autoCommit);
    } catch (Exception e) {
      closeTransaction(tx); // may have fetched a connection so lets call close()
      throw ExceptionFactory.wrapException(&quot;Error opening session.  Cause: &quot; + e, e);
    } finally {
      ErrorContext.instance().reset();
    }
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;什么是SqlSession呢? 注释是这么说的,他是MyBatis在java中主要干活的接口,通过这个接口,你可以执行命令(它里面定义了大量的 诸如&lt;code&gt;selectList&lt;/code&gt;类似的方法),获取mapper,合并事务&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;The primary Java interface for working with MyBatis.
Through this interface you can execute commands, get mappers and manage transactions.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过上面的我贴出来的函数,大家可以看到,&lt;strong&gt;通过事务工厂实例化了一个事物&lt;code&gt;Transaction&lt;/code&gt;&lt;/strong&gt;,那么问题来了,这个&lt;code&gt;Transaction&lt;/code&gt;又是什么呢? 注释是这么解释的: Transaction 包装了一个数据库的连接,处理这个连接的生命周期,包含: 它的创建,准备 提交/回滚 和 关闭&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;紧接着创建执行器:&lt;/strong&gt;&lt;code&gt;configuration.newExecutor(tx, execType)&lt;/code&gt;,默认创建的是&lt;code&gt;CachingExecutor&lt;/code&gt;它维护了一个&lt;code&gt;SimpleExecutor&lt;/code&gt;, 这个执行器的特点是 &lt;strong&gt;在每次执行完成后都会关闭 statement 对象&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;关于mybatis的执行器,其实挺多事的,打算专门写一篇笔记&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;继续看&lt;code&gt;new DefaultSqlSession()&lt;/code&gt;我们得知,这个sqlSession的默认实现类是&lt;code&gt;DefaultSqlSession&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第三个参数autocommit为false, 这也是为什么我们如果不手动提交事务时,虽然测试会通过,但是事务不会被持久化的原因&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;小结: 当前函数是 &lt;code&gt;openSession()&lt;/code&gt;, 如果说它是打开一个session,那跟没说是一样的,通过源码我们也看到了,这一步其实是Mybatis将 数据库连接,事务,执行器进行了一下封装然后返回给程序员&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;获取mapper----maperproxy&quot;&gt;获取Mapper -- maperProxy&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;我们交给mybatis的mapper是一个接口,看看Mybatis是如何实例化我们的结果,返回给我们一个代理对象的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;跟进源码:&lt;code&gt;IUserDao mapper = this.sqlSession.getMapper(IUserDao.class);&lt;/code&gt; ,经过一个空方法,我们进入&lt;code&gt;Configuration&lt;/code&gt;类中的函数如下:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; public &amp;lt;T&amp;gt; T getMapper(Class&amp;lt;T&amp;gt; type, SqlSession sqlSession) {
    return mapperRegistry.getMapper(type, sqlSession);
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从&lt;code&gt;mapperRegistry&lt;/code&gt;中获取mapper,他是&lt;code&gt;Configuration&lt;/code&gt;属性如下: 可以看到这个&lt;code&gt;mapperRegistry&lt;/code&gt;甚至包含了&lt;code&gt;Configuration&lt;/code&gt;,甚至还多了个 &lt;code&gt;knownMappers&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;那么问题来了,这个&lt;code&gt;knownMappers&lt;/code&gt;是干啥呢? &lt;strong&gt;我直接说,这个map就是在上面解析xml配置文件时,存放程序员在&lt;code&gt;&amp;lt;mappers&amp;gt;&lt;/code&gt;标签下配置的&lt;code&gt;&amp;lt;maper&amp;gt;&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;protected final MapperRegistry mapperRegistry = new MapperRegistry(this);

// 详情:
public class MapperRegistry {
    private final Configuration config;
    private final Map&amp;lt;Class&amp;lt;?&amp;gt;, MapperProxyFactory&amp;lt;?&amp;gt;&amp;gt; knownMappers = new HashMap&amp;lt;&amp;gt;();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;继续跟进这个&lt;code&gt;getMapper()&lt;/code&gt;如下: &lt;strong&gt;并且我们在配置文件中是这样配置的&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;mappers&amp;gt;
    &amp;lt;mapper class=&quot;com.changwu.dao.IUserDao&quot;/&amp;gt;
&amp;lt;/mappers&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;  public &amp;lt;T&amp;gt; T getMapper(Class&amp;lt;T&amp;gt; type, SqlSession sqlSession) {
    final MapperProxyFactory&amp;lt;T&amp;gt; mapperProxyFactory = (MapperProxyFactory&amp;lt;T&amp;gt;) knownMappers.get(type);
    if (mapperProxyFactory == null) {
      throw new BindingException(&quot;Type &quot; + type + &quot; is not known to the MapperRegistry.&quot;);
    }
    try {
      return mapperProxyFactory.newInstance(sqlSession);
    } catch (Exception e) {
      throw new BindingException(&quot;Error getting mapper instance. Cause: &quot; + e, e);
    }
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;所以不难想象,我们肯定能获取到结果,通过上面的代码我们能看到,获取到的对象被强转成了&lt;code&gt;MapperProxyFactory&lt;/code&gt;类型,它的主要成员如下: 说白了,这个 map代理工厂是个辅助对象,它是对程序员提供的mapper结果的描述,同时内置使用jdk动态代理的逻辑为mapper创建代理对象&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class MapperProxyFactory&amp;lt;T&amp;gt; {

  private final Class&amp;lt;T&amp;gt; mapperInterface;
  private final Map&amp;lt;Method, MapperMethod&amp;gt; methodCache = new ConcurrentHashMap&amp;lt;&amp;gt;();
  ...
    protected T newInstance(MapperProxy&amp;lt;T&amp;gt; mapperProxy) {
    return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[] { mapperInterface }, mapperProxy);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;说到了为mapper创建动态代理,就不得不去看看是哪个类充当了动态代理的需要的InvoketionHandler -- 这个类是mybatis中的MapperProxy, 没错它实现了InvocationHandler接口,重写了&lt;code&gt;invoke()&lt;/code&gt;逻辑,源码如下:&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Override
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
try {
  if (Object.class.equals(method.getDeclaringClass())) {
    return method.invoke(this, args);
  } else if (isDefaultMethod(method)) {
    return invokeDefaultMethod(proxy, method, args);
  }
} catch (Throwable t) {
  throw ExceptionUtil.unwrapThrowable(t);
}
final MapperMethod mapperMethod = cachedMapperMethod(method);
return mapperMethod.execute(sqlSession, args);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;小结: 至此当前模块的获取mapper对象已经完结了,我们明明白白的看到了MyBatis为我们的mapper使用jdk的动态代理创建出来代理对象, 这也是为什么我们免去了自己写实现类的粗活&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;执行map----maperproxy&quot;&gt;执行Map -- maperProxy&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;上一个模块我们知道了Mybatis为我们创建出来了mapper接口的代理对象,那当我们获取到这个代理对象之后执行它的&lt;code&gt;mapper.findAll();&lt;/code&gt;实际上触发的是代理对象的&lt;code&gt;invoke()&lt;/code&gt;方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所以说,接着看上面的&lt;code&gt;MapperProxy&lt;/code&gt;的&lt;code&gt;invoke()&lt;/code&gt;方法:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Override
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
try {
  if (Object.class.equals(method.getDeclaringClass())) {
    return method.invoke(this, args);
  } else if (isDefaultMethod(method)) {
    return invokeDefaultMethod(proxy, method, args);
  }
} catch (Throwable t) {
  throw ExceptionUtil.unwrapThrowable(t);
}
final MapperMethod mapperMethod = cachedMapperMethod(method);
return mapperMethod.execute(sqlSession, args);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的方法我们关注两个地方,第一个地方就是&lt;code&gt;final MapperMethod mapperMethod = cachedMapperMethod(method);&lt;/code&gt;,见名知意: 缓存MapperMethod&lt;/p&gt;
&lt;p&gt;第一个问题: 这个&lt;code&gt;MapperMethod&lt;/code&gt;是什么? 它其实是Mybatis为sql命令+方法全限定名设计的封装类&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; */
public class MapperMethod {

  private final SqlCommand command;
  private final MethodSignature method;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;说白了,就是想为MapperProxy保存一份map格式的信息,key=方法全名 value=MapperMethod(command,method),存放在MapperProxy的属性methodCache中&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;comand -&amp;gt; &quot;name=com.changwu.dao.IUserDao,fingAll&quot;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;method -&amp;gt; &quot;result= public abstract java.util.List.com.changwu.dao.IUserDao.findAll()&quot;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;为什么要给这个MapperProxy保存这里呢? 很简单,它是mapper的代理对象啊,程序员使用的就是他,在这里留一份method的副本,再用的话多方便?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;完成缓存后,继续看它如何执行方法:,跟进&lt;code&gt;mapperMethod.execute(sqlSession, args)&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为我使用的是&lt;code&gt;@Select(&quot;select * from user&quot;)&lt;/code&gt;,所以一定进入下面的&lt;code&gt;result = executeForMany(sqlSession, args);&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
 public Object execute(SqlSession sqlSession, Object[] args) {
    Object result;
    switch (command.getType()) {
      case INSERT: {
        Object param = method.convertArgsToSqlCommandParam(args);
        result = rowCountResult(sqlSession.insert(command.getName(), param));
        break;
      }
      
      ..
        case SELECT:
        if (method.returnsVoid() &amp;amp;&amp;amp; method.hasResultHandler()) {
          executeWithResultHandler(sqlSession, args);
          result = null;
        } else if (method.returnsMany()) {
          result = executeForMany(sqlSession, args);
        ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以我们继续关注这个 &lt;code&gt;executeForMany(sqlSession, args);&lt;/code&gt;方法,看他的第一个参数是&lt;code&gt;sqlSession&lt;/code&gt;,也就是我们的&lt;code&gt;DefaultSqlSession&lt;/code&gt;,他里面存在两大重要对象: 1是configuration 配置对象, 2是Executor 执行器对象&lt;/p&gt;
&lt;p&gt;继续跟进:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;  private &amp;lt;E&amp;gt; Object executeForMany(SqlSession sqlSession, Object[] args) {
    List&amp;lt;E&amp;gt; result;  
    Object param = method.convertArgsToSqlCommandParam(args);
    if (method.hasRowBounds()) {
      RowBounds rowBounds = method.extractRowBounds(args);
      result = sqlSession.selectList(command.getName(), param, rowBounds);
    } else {
      result = sqlSession.selectList(command.getName(), param);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们在继续跟进这个&lt;code&gt;selectList&lt;/code&gt;方法之前,先看看这个command.getName()是啥? 其实我们上面的代码追踪中有记录: 就是&lt;code&gt;name=com.changwu.dao.IUserDao,fingAll&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;继续跟进去到下面的方法:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这个方法就比较有趣了,首先来说,下面的入参都是什么&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;statement = &quot;com.changwu.dao.IUserDao.findAll&quot;&lt;/code&gt; &lt;code&gt;parameter=null&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;第二个问题:&lt;code&gt;MappedStatement&lt;/code&gt;是什么? 它是一个对象,维护了很多很多的配置信息,但是我们关心它里面的两条信息,这其实可以理解成&lt;strong&gt;一种方法与sql之间的映射,如下图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1496926/201910/1496926-20191025220027276-287467146.png&quot; alt=&quot;mappedStatement&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;  @Override
  public &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; selectList(String statement, Object parameter, RowBounds rowBounds) {
    try {
      MappedStatement ms = configuration.getMappedStatement(statement);
      return executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);
    } catch (Exception e) {
      throw ExceptionFactory.wrapException(&quot;Error querying database.  Cause: &quot; + e, e);
    } finally {
      ErrorContext.instance().reset();
    }
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;前面阅读时,我们知道Mybatis为我们创建的默认的执行器 Executor是&lt;code&gt;CachingExecutor&lt;/code&gt;&lt;/strong&gt;,如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1496926/201910/1496926-20191025220026783-1288655888.png&quot; alt=&quot;CachingExecutor&quot;/&gt;&lt;/p&gt;
&lt;p&gt;继续跟进,主要做了下面三件事, 获取到绑定的sql,然后调用&lt;code&gt;SimpleExecutor&lt;/code&gt;缓存key,然后继续执行&lt;code&gt;query()&lt;/code&gt;方法&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; @Override
  public &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException {
    BoundSql boundSql = ms.getBoundSql(parameterObject);
    CacheKey key = createCacheKey(ms, parameterObject, rowBounds, boundSql);
    return query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着调用&lt;code&gt;SimpleExecutor&lt;/code&gt;的&lt;code&gt;query()&lt;/code&gt;方法,然后我们关注&lt;code&gt;SimpleExecutor&lt;/code&gt;的&lt;code&gt;doQuery()&lt;/code&gt;方法,源码如下&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; @Override
  public &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException {
    Statement stmt = null;
    try {
      Configuration configuration = ms.getConfiguration();
      StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);
      stmt = prepareStatement(handler, ms.getStatementLog());
      return handler.query(stmt, resultHandler);
    } finally {
      closeStatement(stmt);
    }
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;我们注意到.在SimpleExcutor中创建的了一个 XXXStatementHandler这样一个处理器, 所以我们的只管感觉就是,sql真正执行者其实并不是Executor,而是Executor会为每一条sql的执行重新new 一个 StatementHandler ,由这个handler去具体的执行sql&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关于这个StatementHandler到底是是何方神圣? 暂时了解它是Mybatis定义的一个规范接口,定义了如下功能即可&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface StatementHandler {
  // sql预编译, 构建statement对象 
  Statement prepare(Connection connection, Integer transactionTimeout)
      throws SQLException;
  // 对prepare方法构建的预编译的sql进行参数的设置
  void parameterize(Statement statement)
      throws SQLException;
  // 批量处理器
  void batch(Statement statement)
      throws SQLException;
  // create update delete
  int update(Statement statement)
      throws SQLException;
  // select
  &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; query(Statement statement, ResultHandler resultHandler)
      throws SQLException;
  
  &amp;lt;E&amp;gt; Cursor&amp;lt;E&amp;gt; queryCursor(Statement statement)
      throws SQLException;
  // 获取sql的封装对象 
  BoundSql getBoundSql();
  // 获取参数处理对象
  ParameterHandler getParameterHandler();

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;了解了这个StatementHandler是什么,下一个问题就是当前我们创建的默认的statement是谁呢? &lt;code&gt;routingStatementHandler&lt;/code&gt;如下图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1496926/201910/1496926-20191025220026439-543525632.png&quot; alt=&quot;https://img2018.cnblogs.com/blog/1496926/201910/1496926-20191025220026439-543525632.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;创建preparedstatement&quot;&gt;创建preparedStatement&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;马上马就发生了一件悄无声息的大事!!!根据现有的sql等信息,构建 PreparedStatement&lt;/strong&gt;,我们关注这个&lt;code&gt;prepareStatement(handler, ms.getStatementLog());&lt;/code&gt;方法,通过调试我们得知,&lt;code&gt;prepareStatement()&lt;/code&gt;是&lt;code&gt;RoutingStatementHandler&lt;/code&gt;的抽象方法,被&lt;code&gt;PreparedStatementHandler&lt;/code&gt;重写了,所以我们去看它如何重写的,如下:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Override
public Statement prepare(Connection connection, Integer transactionTimeout) throws SQLException {
ErrorContext.instance().sql(boundSql.getSql());
Statement statement = null;
try {
  statement = instantiateStatement(connection);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们关注这个&lt;code&gt;instantiateStatement()&lt;/code&gt;方法, 并且进入它的&lt;code&gt;connection.prepareStatement(sql);&lt;/code&gt;方法,如下图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1496926/201910/1496926-20191025220025896-1096057645.png&quot; alt=&quot;preparedStatement&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;纯洁的微笑... 见到了原生JDK, jdbc的亲人...&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;创建完事这个 preparedStatement,下一步总该执行了吧...绕这么多圈...&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们回到上面代码中的&lt;code&gt;return handler.query(stmt, resultHandler);&lt;/code&gt;准备执行,此时第一个参数就是我们的刚创建出来的PreparedStatement, 回想一下,上面创建的这个默认的statement中的代表是&lt;code&gt;PreparedStatementHandler&lt;/code&gt;,所以,我们进入到这个StatementHandler的实现类&lt;code&gt;RountingStatementHandler&lt;/code&gt;中,看他的&lt;code&gt;query()&lt;/code&gt;方法&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;  @Override
  public &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; query(Statement statement, ResultHandler resultHandler) throws SQLException {
    return delegate.query(statement, resultHandler);
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用&lt;code&gt;RountingStatementHandler&lt;/code&gt;中维护的&lt;strong&gt;代表的StatementHandler也就是&lt;code&gt;PreparedStatementHandler&lt;/code&gt;的&lt;code&gt;query()&lt;/code&gt;方法,顺势跟进去,最终会通过反射执行jdbc操作,如图, 我圈出来的对象就是我们上面创建出来的preparedStatement&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1496926/201910/1496926-20191025220024849-1862170452.png&quot; alt=&quot;执行preparedStatement&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;提交事务&quot;&gt;提交事务&lt;/h2&gt;
&lt;p&gt;跟进&lt;code&gt;conmit()&lt;/code&gt;方法,分成两步&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;清空缓存&lt;/li&gt;
&lt;li&gt;提交事务&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;清空缓存是在&lt;code&gt;CachingExecutor&lt;/code&gt;中调用了&lt;code&gt;SimpleExecutor&lt;/code&gt;简单执行器的方法&lt;code&gt;commit(required)&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;  @Override
  public void commit(boolean required) throws SQLException {
    delegate.commit(required);
    tcm.commit();
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接在&lt;code&gt;SimpleExecutor&lt;/code&gt;的父类&lt;code&gt;BaseExecutor&lt;/code&gt;中完成&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;  @Override
  public void commit(boolean required) throws SQLException {
    if (closed) {
      throw new ExecutorException(&quot;Cannot commit, transaction is already closed&quot;);
    }
    clearLocalCache();
    flushStatements();
    if (required) {
      transaction.commit();
    }
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;提交事务的操作在&lt;code&gt;tcm.commit();&lt;/code&gt;中完成&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;strong&gt;本文到这里也就行将结束了,如果您觉得挺好玩的,欢迎点赞支持,有错误的话,也欢迎批评指出&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 25 Oct 2019 14:12:00 +0000</pubDate>
<dc:creator>赐我白日梦</dc:creator>
<og:description>环境简介与入口 记录一下尝试阅读Mybatis源码的过程,这篇笔记是我一边读,一遍记录下来的,虽然内容也不多,对Mybatis整体的架构体系也没有摸的很清楚,起码也能把这个过程整理下来,这也是我比较喜</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ZhuChangwu/p/11741125.html</dc:identifier>
</item>
<item>
<title>利用Arthas定位线上问题实例 - 牛哥的博客</title>
<link>http://www.cnblogs.com/nxlhero/p/11741118.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nxlhero/p/11741118.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;Arthas是一个类似于Btrace的JVM在线调试分析工具，具体可参考我之前写的一篇博客：&lt;a href=&quot;https://www.cnblogs.com/nxlhero/p/11660854.html&quot;&gt;利用JVM在线调试工具排查线上问题&lt;/a&gt;。本文分享笔者刚遇到的一个问题，虽然不复杂，但是很典型。&lt;/p&gt;
&lt;h2 id=&quot;问题与分析过程&quot;&gt;问题与分析过程&lt;/h2&gt;
&lt;p&gt;昨天上线遇到一个问题，交易后给大数据平台异步送数，但是他们说没收到数据，因为我们没有打日志，所以没有直接的证据证明是他们的问题而不是我们的问题。&lt;/p&gt;
&lt;p&gt;送数的原理大致如下，就是交易主线程把数据放到队列里，然后异步线程从队列里把数据取出来，发送到后台。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;队列：
BlockingQueue&amp;lt;Message&amp;gt; queue = new BlockingQueue();

同步线程：
void sendMsg(Message msg) {
   queue.offer(msg);
}
异步线程：
void consume() {
   Message msg = queue.take();
   while(msg != null) {
       HttpClient.post(msg);
       msg = queue.take();
   }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体送数的代码如下( 加了行数)：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;38  public void consume(Map msg) {
39        HttpClient httpClient = new HttpClient(cm);
40        PostMethod method = new PostMethod(uri);
41        method.addRequestHeader(&quot;context-type&quot;, &quot;application/x-www-form-urlencoded&quot;);
42        JSONObject json = new JSONObject(msg);
43       NameValuePair[] params = new NameValuePair[2];
44       params[0] = new NameValuePair(&quot;topic&quot;, topic);
45       params[1] = new NameValuePair(&quot;value&quot;, json.toJSONString());
46       //System.out.println(msg.toString());
47       logger.info(&quot;BigDataHttp Send Json:&quot; + json.toJSONString());
48       method.addParameters(params);
49      try {
50
51         httpClient.executeMethod(method);
52         if(method.getStatusCode() == 200) {
53              logger.info(&quot;BigDataHttp response(Success):&quot;+ method.getResponseBodyAsString());
54         } else {
55              logger.info(&quot;BigDataHttp Response(error):&quot; + method.getResponseBodyAsString());
56         }
57     } catch(Exception e) {
58         logger.error(e.getMessage(), e);
59     } finally {
60         method.releaseConnection();
61     }
62  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在日志里没有发现try里的异常，而比较遗憾的是，我们的日志虽然开了info级别，但是因为日志量太大，所以只开了交易上送和下发报文的日志，其他的日志都关了。&lt;/p&gt;
&lt;p&gt;现在日志级别没法调，有没有办法能确定，请求返回了200，还是其他值呢？&lt;/p&gt;
&lt;p&gt;可以用在线调试工具Arthas，我们使用Arthas的trace功能，查看这个类执行的详细步骤。&lt;/p&gt;
&lt;p&gt;首先连接上这个JVM进程，pid为进程号。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;java -jar arthas-boot.jar pid &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后执行命令&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;trace xxx.util.bigDataUtil.BigDataHttpConsumer consume&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这条命令的左右就是，追踪xxx.util.bigDataUtil.BigDataHttpConsumer类里consume方法的执行过程。&lt;/p&gt;
&lt;p&gt;执行的结果如下，每一行最后的是代码行数，我们可以看一下，跟上面代码是一一对应的。&lt;br/&gt;&lt;img src=&quot;https://s1.51cto.com/images/blog/201910/25/38dd24dfec498e3f7cd0122908ad0d83.jpg?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从代码中可以看到，如果返回码是200，那么它会执行第52行，如果返回码不是200，会执行55行，因此，我们通过trace功能确定执行了哪条语句，就可以知道到底返回没返回200，从结果来看，确定返回的不是200。&lt;/p&gt;
&lt;p&gt;这样我们就有了确定的证据证明发给后台时返回非200，后台同事检查了自己的配置发现配置有误，是他们自己的问题。&lt;/p&gt;
</description>
<pubDate>Fri, 25 Oct 2019 14:11:00 +0000</pubDate>
<dc:creator>牛哥的博客</dc:creator>
<og:description>Arthas是一个类似于Btrace的JVM在线调试分析工具，具体可参考我之前写的一篇博客：[利用JVM在线调试工具排查线上问题](https://www.cnblogs.com/nxlhero/p/</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/nxlhero/p/11741118.html</dc:identifier>
</item>
<item>
<title>数据结构与算法之两种查找方法 - xbhog</title>
<link>http://www.cnblogs.com/xbhog/p/11741056.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xbhog/p/11741056.html</guid>
<description>&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;本节的内容：&lt;/span&gt;&lt;/h2&gt;
&lt;ol class=&quot;ol-list&quot; start=&quot;&quot; readability=&quot;-1&quot;&gt;&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;什么是列表查找；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;顺序查找(线性查找)；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;二分查找；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;顺序查找与二分查找比较；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;运行时间；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;增速问题&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h4 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;一：什么是查找&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;md-end-block md-p md-focus&quot;&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;查找：在一些数据元素中，通过一定的方法找出与给定的关键词相同的数据元素的过程。&lt;/span&gt;&lt;/p&gt;
&lt;h4 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;二：顺序查找(线性查找)：从列表中查找指定的元素&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;定义：从列表的第一个元素开始，顺序进行搜索，直到找到元素或搜索到列表最后一个元素为止。&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;0&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;输入：列表、带查找的元素&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;输出：元素下标（未找到元素是一般返回None/-1）&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;内置列表查找函数：index()&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;线性查找的代码实现&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;enumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;教程：https://www.runoob.com/python3/python3-func-enumerate.html&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; linear_search(li,var):
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;&lt;span&gt; index,v enumerate(li):
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; v ==&lt;span&gt; var:
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; index
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; None
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 复杂度：范围是列表（n）,一个for循环====》O(n) 从头到尾遍历每个元素
&lt;/pre&gt;&lt;/div&gt;

&lt;h4 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;三：二分查找定义&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;又叫折半查找，从有序列表(必须为有序)的初始候选区list[o:n]开始，通过对待查找的值与候选区中间值的比较，可以使候选区减少一半。(仅当列表为有序的时候，二分查找才管用)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;举例：从下面列表中查找3元素：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1775279/201910/1775279-20191025215527762-1553058673.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;首先我们需要对候选区做一个了解，这样有助于我们更好的理解，&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;在上面的列表中我们使1所在的位置为left,9所在的位置为right,这样从left-right就是候选区，&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1775279/201910/1775279-20191025215537041-1814666601.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1775279/201910/1775279-20191025215546153-1741486967.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;候选区中间值(mid) =（left-right）// 2;如果我们需要查找的值(val)大于候选区中间值(mid),则左边的值为：left = mid+1 ,right不变,候选区为：【(mid+1),right】；相反：查找的值(val)小于候选区中间值(mid)，则left不变，右边值为：right = mid - 1,候选区为【left, ( mid -1)】&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1775279/201910/1775279-20191025215555178-136259130.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1775279/201910/1775279-20191025215604907-406280267.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;然后依次进行取值，其中left、mid、right都是指的值的下标；如果最后left&amp;gt;right,则表示该范围没有所需要的值。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt; Binary_search(li,val): &lt;span&gt;#&lt;/span&gt;&lt;span&gt;li传入的列表，val所需要的值&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;'''&lt;/span&gt;&lt;span&gt;定义值&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     left =&lt;span&gt; 0
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     right = len(li) - 1
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt; left &amp;lt;= right: &lt;span&gt;#&lt;/span&gt;&lt;span&gt;候选区有值&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         mid = (right+left) // 2  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;候选区中间值&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; li[mid] ==&lt;span&gt; val:
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; mid
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;elif&lt;/span&gt; li[mid] &amp;gt; val: &lt;span&gt;#&lt;/span&gt;&lt;span&gt;带查找的值在中间值(mid)的左侧&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;             right = mid -1
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;:  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;li[mid] &amp;lt; val 带查找的值在中间值(mid)的右侧&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;             left = mid + 1
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; None
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;四：顺序查找与二分查找比较&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;我们在使用大O表示法讨论运行时间时，log指的都是log2。使用简单查找法查 找元素时，在最糟情况下需要查看每个元素。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;因此，如果列表包含8个数字，你最多需要检查8 个数字。而使用二分查找时，最多需要检查log n个元素。如果列表包含8个元素，你最多需要 检查3个元素，因为log 8 = 3（2^3 = 8）。如果列表包含1024个元素，你最多需要检查10个元素， 因为log 1024 = 10（2^10 =1024）。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;五：两者运行时间&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;选择算法的时候我们本能的选择效率最高的，以最大限度的减少运行时间或者占用空间。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;如果列表包含100个数字，顺序查找最多需要猜100次，40亿个数字，则最多需要才40亿次；顺序查找最多需要猜测的次数与列表长度相同==》运行时间线性时间。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;二分查找的话最多猜7次，40亿最多猜32（log2^32）次===&amp;gt;运行时间表示为对数时间。&lt;/span&gt;&lt;/p&gt;
&lt;h4 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;六：增速问题 (算法的运行时间以不同的速度增加 )&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;随着元素数量的增加，二分查找需要的额外时间并不多， 而顺序查找需要的额外时间却很多。因此，随着列表的增长，二分查找的速度比顺序查找快得多,但如果是无序列表，使用二分查找的话需要进行排序，两者各有优缺点，&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 25 Oct 2019 13:57:00 +0000</pubDate>
<dc:creator>xbhog</dc:creator>
<og:description>本节的内容： 什么是列表查找； 顺序查找(线性查找)； 二分查找； 顺序查找与二分查找比较； 运行时间； 增速问题 一：什么是查找 查找：在一些数据元素中，通过一定的方法找出与给定的关键词相同的数据元</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xbhog/p/11741056.html</dc:identifier>
</item>
<item>
<title>3.1 C语言_实现AVL平衡二叉树 - Kim_小星兴</title>
<link>http://www.cnblogs.com/kimalittlestar/p/11739050.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kimalittlestar/p/11739050.html</guid>
<description>&lt;p&gt;&lt;span&gt;【序】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上节我们实现了数据结构中最简单的Vector，那么来到第三章，我们需要实现一个Set&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;set的特点是 内部有序且有唯一元素值；同时各种操作的期望操作时间复杂度在O（n·logn）；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么标准的C++ STL（Standard Template Library）  容器内部使用的是什么呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;STL使用的是红黑树或者hash Tree ，由于笔者现在的水平和精力，没时间搞这个啦，于是我就&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;挑了一个稍微熟悉一点的数据结构：AVL 树；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;github：&lt;a href=&quot;https://github.com/KimAlittleStar/cstd&quot;&gt;https://github.com/KimAlittleStar/cstd&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;【1.介绍】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;AVL 树是根据二叉查找树改进延伸过来的，我们都知道二叉查找树中只有一个规则，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那就是根节点的元素一定会大于左孩子，小于右孩子；如果是随机数，那么我们二叉&lt;/span&gt;&lt;span&gt;查找树的高度无限&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接近于 logN（完全二叉树）。但是由于其策略，在反复的插入和删除后，&lt;/span&gt;&lt;span&gt;普通的二叉查找树将会非常&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;偏科（偏向右子树）如果树的高度非常大（height == N） 那么他和链表的&lt;/span&gt;&lt;span&gt;操作时间没有什么区别，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了避免普通二叉查找树的缺陷，因此引申出 AVL Tree -&amp;gt; 平衡二叉查找树；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;AVL 和普通的二叉查找树只有一个规则限制：相同节点的两个孩子的高度最大相差为1，本身节点的高度&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为两个孩子节点中大的那个高度加1；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;【2.基础数据结构】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用一个node 和 正常的tree 用于管理他的根和size；node 中有左孩子 右孩子和数据还有一个记录树的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;高度字节u8（unsigned char），为什么我们使用u8，因为假设在满足AVL的规则要求下，坏的情况树的深度为&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;deep = logn *2 +1 ； 去除一个起始位0 ,后期可能会用到的错误位 -1，那么在最差的情况下 u8 类型的高度可以存储&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;大概多少个节点呢： &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;N = 2^254 （个）而我们在tree 中 size 的类型是 u32 （unsigned int）完全够用了；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参考下图：（数据结构与算法C++.pdf）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1170684/201910/1170684-20191025165804565-1464044732.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;typedef unsigned &lt;span&gt;int&lt;/span&gt;&lt;span&gt; typeClass;

typedef &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; __SET_typeClass_node
{
    typeClass data;
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; __SET_typeClass_node *&lt;span&gt;left;
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; __SET_typeClass_node *&lt;span&gt;right;
    u8 heigh;
} SET_typeClass_node_t;

typedef &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; __SET_typeClass_t
{
    SET_typeClass_node_t &lt;/span&gt;*&lt;span&gt;root;
    u32 size;
} SET_typeClass_t;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;【3 插入】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;数据的插入还是依照我们普通的二叉树进行插入，递归判断我们的数据是否小于当前节点，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;小于，递归往左走，大于，大于递归往右走，等于，不操作，真正的基础情况是判断是发现&lt;/span&gt;&lt;span&gt;当前&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;节点为NULL 此时申请内存存储该元素；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('7939a3c0-6862-4ccb-90d7-5c286dcbc6f9')&quot; readability=&quot;38.5&quot;&gt;&lt;span&gt;&lt;img id=&quot;code_img_closed_7939a3c0-6862-4ccb-90d7-5c286dcbc6f9&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_7939a3c0-6862-4ccb-90d7-5c286dcbc6f9&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('7939a3c0-6862-4ccb-90d7-5c286dcbc6f9',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;
&lt;div id=&quot;cnblogs_code_open_7939a3c0-6862-4ccb-90d7-5c286dcbc6f9&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;72&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SET_typeClass_node_t *SET_inserttypeClass_node_t(SET_typeClass_node_t *&lt;span&gt;root,
                                                 u8 (&lt;/span&gt;*compare)(&lt;span&gt;const&lt;/span&gt; typeClass *a, &lt;span&gt;const&lt;/span&gt; typeClass *&lt;span&gt;b),
                                                 &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; typeClass *value, u32 *&lt;span&gt;size)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (root ==&lt;span&gt; NULL)
    {
        root &lt;/span&gt;= (SET_typeClass_node_t *)&lt;span&gt;malloc&lt;/span&gt;(&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(SET_typeClass_node_t));
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (root ==&lt;span&gt; NULL)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Out of space!!!&lt;/span&gt;
&lt;span&gt;        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        {
            root&lt;/span&gt;-&amp;gt;data = (*&lt;span&gt;value);
            root&lt;/span&gt;-&amp;gt;left = root-&amp;gt;right =&lt;span&gt; NULL;
            (&lt;/span&gt;*size)++&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; root;
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (compare(value, &amp;amp;root-&amp;gt;&lt;span&gt;data))
    {
        root&lt;/span&gt;-&amp;gt;left = SET_inserttypeClass_node_t(root-&amp;gt;&lt;span&gt;left, compare, value, size);
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (compare(&amp;amp;root-&amp;gt;&lt;span&gt;data, value))
    {
        root&lt;/span&gt;-&amp;gt;right = SET_inserttypeClass_node_t(root-&amp;gt;&lt;span&gt;right, compare, value, size);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; root;
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;普通二叉树插入&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当我们在做完这一切之后，还需要做的是维护&lt;/span&gt;&lt;span&gt;AVL的性质：左右节点高度相差最大为1；且需要&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;递归查询哦。&lt;/span&gt;&lt;span&gt;于是乎我们接下来第一步要&lt;/span&gt;&lt;span&gt;做的是什么呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;更新我们自己的节点的高度；&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;root-&amp;gt;heigh = SET_Max(SET_heighttypeClass(root-&amp;gt;&lt;span&gt;left),
                          SET_heighttypeClass(root&lt;/span&gt;-&amp;gt;right)) +
                  &lt;span&gt;1&lt;/span&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;更新之后节点之后我们就会发现，哎呀，有些时候（大多数时候）AVL树的规则被破坏了，那么该&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;就需要处理&lt;/span&gt;&lt;span&gt;重新符合AVL树的规则；插入之后呢可能会出现四种情况，其中两两镜像，因此我们只讨论&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;两种；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1170684/201910/1170684-20191025171422651-336764894.png&quot; alt=&quot;&quot;/&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1170684/201910/1170684-20191025171449562-1305487426.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以上两种情况分别为 LL ，LR，具体判断标准为：观察高度开始不符合的节点，8号节点和 K2节点，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里说的&lt;strong&gt;高度不符的节点表示：左右孩子的高度相差 &amp;gt;1  &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;那么他们偏离的子节点的方向分别是&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;8号：Left-&amp;gt;Left  k2-&amp;gt;Left-&amp;gt;Right;　　我们在处理LL情况的时候，只需要将&lt;/span&gt;&lt;span&gt;7号变成5号的右孩子；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;8号变成7号的右孩子即可，相当于6~7~8号顺时针旋转了一下，我们把这个&lt;strong&gt;定义&lt;/strong&gt;为&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;”左单旋“&lt;/strong&gt;，旋转后&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;变成如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1170684/201910/1170684-20191025172201178-1183155328.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;相对应的也有&lt;strong&gt; ”右单旋“&lt;/strong&gt;咯。大家自己推导啦；&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接下来看我们的LR情况，如果仅仅对K2执行一次左单旋，那么结果是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1170684/201910/1170684-20191025172406118-1442970012.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 但是这样依旧没有满足 AVL 树的性质；K2的高度会比 X大超过1；此时我们需要引进一个k1的右节点进行双旋转；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1170684/201910/1170684-20191025173213667-1476030002.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们首先把 K1 k2 B 进行一次右单旋；得到&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1170684/201910/1170684-20191025173630181-359339062.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 然后我们在将C~k2~k3进行一次左旋：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1170684/201910/1170684-20191025173713703-1850061094.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 相对应的我们也会有 RL的情况，镜像情况我们就不赘述咯；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面代码是单旋、双旋的实现：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SET_typeClass_node_t *SET_doubleRotateLefttypeClass(SET_typeClass_node_t *&lt;span&gt;s)
{
    s&lt;/span&gt;-&amp;gt;left = SET_singleRotateRighttypeClass(s-&amp;gt;&lt;span&gt;left);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; SET_singleRotateLefttypeClass(s);
}
SET_typeClass_node_t &lt;/span&gt;*SET_doubleRotateRighttypeClass(SET_typeClass_node_t *&lt;span&gt;s)
{
    s&lt;/span&gt;-&amp;gt;right = SET_singleRotateLefttypeClass(s-&amp;gt;&lt;span&gt;right);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; SET_singleRotateRighttypeClass(s);
}

SET_typeClass_node_t &lt;/span&gt;*SET_singleRotateLefttypeClass(SET_typeClass_node_t *&lt;span&gt;s)
{
    SET_typeClass_node_t &lt;/span&gt;*&lt;span&gt;s1;
    s1 &lt;/span&gt;= s-&amp;gt;&lt;span&gt;left;
    s&lt;/span&gt;-&amp;gt;left = s1-&amp;gt;&lt;span&gt;right;
    s1&lt;/span&gt;-&amp;gt;right =&lt;span&gt; s;

    s&lt;/span&gt;-&amp;gt;heigh =&lt;span&gt; SET_Max(
                   SET_heighttypeClass(s&lt;/span&gt;-&amp;gt;&lt;span&gt;left),
                   SET_heighttypeClass(s&lt;/span&gt;-&amp;gt;right)) +
               &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    s1&lt;/span&gt;-&amp;gt;heigh =&lt;span&gt; SET_Max(
                    SET_heighttypeClass(s1&lt;/span&gt;-&amp;gt;&lt;span&gt;left),
                    s&lt;/span&gt;-&amp;gt;heigh) +
                &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; s1;
}

SET_typeClass_node_t &lt;/span&gt;*SET_singleRotateRighttypeClass(SET_typeClass_node_t *&lt;span&gt;s)
{
    SET_typeClass_node_t &lt;/span&gt;*&lt;span&gt;s1;
    s1 &lt;/span&gt;= s-&amp;gt;&lt;span&gt;right;
    s&lt;/span&gt;-&amp;gt;right = s1-&amp;gt;&lt;span&gt;left;
    s1&lt;/span&gt;-&amp;gt;left =&lt;span&gt; s;

    s&lt;/span&gt;-&amp;gt;heigh =&lt;span&gt; SET_Max(
                   SET_heighttypeClass(s&lt;/span&gt;-&amp;gt;&lt;span&gt;left),
                   SET_heighttypeClass(s&lt;/span&gt;-&amp;gt;right)) +
               &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    s1&lt;/span&gt;-&amp;gt;heigh =&lt;span&gt; SET_Max(
                    SET_heighttypeClass(s1&lt;/span&gt;-&amp;gt;&lt;span&gt;right),
                    s&lt;/span&gt;-&amp;gt;heigh) +
                &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; s1;
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;综合以上，我们最后insert的代码就成了：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('115dc0b9-d5c0-4057-910e-0533a4ed8b3d')&quot; readability=&quot;40&quot;&gt;&lt;span&gt;&lt;img id=&quot;code_img_closed_115dc0b9-d5c0-4057-910e-0533a4ed8b3d&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_115dc0b9-d5c0-4057-910e-0533a4ed8b3d&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('115dc0b9-d5c0-4057-910e-0533a4ed8b3d',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;
&lt;div id=&quot;cnblogs_code_open_115dc0b9-d5c0-4057-910e-0533a4ed8b3d&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;75&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SET_typeClass_node_t *SET_inserttypeClass_node_t(SET_typeClass_node_t *&lt;span&gt;root,
                                                 u8 (&lt;/span&gt;*compare)(&lt;span&gt;const&lt;/span&gt; typeClass *a, &lt;span&gt;const&lt;/span&gt; typeClass *&lt;span&gt;b),
                                                 &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; typeClass *value, u32 *&lt;span&gt;size)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (root ==&lt;span&gt; NULL)
    {
        root &lt;/span&gt;= (SET_typeClass_node_t *)&lt;span&gt;malloc&lt;/span&gt;(&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(SET_typeClass_node_t));
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (root ==&lt;span&gt; NULL)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Out of space!!!&lt;/span&gt;
&lt;span&gt;        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        {
            root&lt;/span&gt;-&amp;gt;data = (*&lt;span&gt;value);
            root&lt;/span&gt;-&amp;gt;left = root-&amp;gt;right =&lt;span&gt; NULL;
            root&lt;/span&gt;-&amp;gt;heigh = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
            (&lt;/span&gt;*size)++&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; root;
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (compare(value, &amp;amp;root-&amp;gt;&lt;span&gt;data))
    {
        root&lt;/span&gt;-&amp;gt;left = SET_inserttypeClass_node_t(root-&amp;gt;&lt;span&gt;left, compare, value, size);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (SET_heighttypeClass(root-&amp;gt;left) - SET_heighttypeClass(root-&amp;gt;right) == &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (compare(value, &amp;amp;root-&amp;gt;left-&amp;gt;&lt;span&gt;data))
                root &lt;/span&gt;=&lt;span&gt; SET_singleRotateLefttypeClass(root);
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                root &lt;/span&gt;=&lt;span&gt; SET_doubleRotateLefttypeClass(root);
        }
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (compare(&amp;amp;root-&amp;gt;&lt;span&gt;data, value))
    {
        root&lt;/span&gt;-&amp;gt;right = SET_inserttypeClass_node_t(root-&amp;gt;&lt;span&gt;right, compare, value, size);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (SET_heighttypeClass(root-&amp;gt;right) - SET_heighttypeClass(root-&amp;gt;left) == &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (compare(&amp;amp;root-&amp;gt;right-&amp;gt;&lt;span&gt;data, value))
                root &lt;/span&gt;=&lt;span&gt; SET_singleRotateRighttypeClass(root);
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                root &lt;/span&gt;=&lt;span&gt; SET_doubleRotateRighttypeClass(root);
        }
    }
    root&lt;/span&gt;-&amp;gt;heigh = SET_Max(SET_heighttypeClass(root-&amp;gt;&lt;span&gt;left),
                          SET_heighttypeClass(root&lt;/span&gt;-&amp;gt;right)) +
                  &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; root;
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;AVL inser操作&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后我们使用 tree 将其包装，并且返回是否插入成功；插入不成功有两种情况（内存空间不足和元素已存在）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('576f6838-64cc-44d9-844d-d1aabedbd046')&quot; readability=&quot;34&quot;&gt;&lt;span&gt;&lt;img id=&quot;code_img_closed_576f6838-64cc-44d9-844d-d1aabedbd046&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_576f6838-64cc-44d9-844d-d1aabedbd046&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('576f6838-64cc-44d9-844d-d1aabedbd046',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;
&lt;div id=&quot;cnblogs_code_open_576f6838-64cc-44d9-844d-d1aabedbd046&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;u8 SET_inserttypeClass_t(SET_typeClass_t *&lt;span&gt;set&lt;/span&gt;, &lt;span&gt;const&lt;/span&gt;&lt;span&gt; typeClass ele)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;set&lt;/span&gt; == NULL || &lt;span&gt;set&lt;/span&gt;-&amp;gt;compare ==&lt;span&gt; NULL)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    u32 cursize &lt;/span&gt;= &lt;span&gt;set&lt;/span&gt;-&amp;gt;&lt;span&gt;size;
    &lt;/span&gt;&lt;span&gt;set&lt;/span&gt;-&amp;gt;root = SET_inserttypeClass_node_t(&lt;span&gt;set&lt;/span&gt;-&amp;gt;root, &lt;span&gt;set&lt;/span&gt;-&amp;gt;compare, &amp;amp;ele, &amp;amp;&lt;span&gt;set&lt;/span&gt;-&amp;gt;&lt;span&gt;size);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (cursize &amp;lt; &lt;span&gt;set&lt;/span&gt;-&amp;gt;&lt;span&gt;size);
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;AVL insert 封装&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;【4 删除】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;删除的操作呢，比插入要更加复杂一些；但是我们依旧是从基础的二叉树删除来入手；&lt;/span&gt;&lt;span&gt;普通的二叉树首先&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;递归寻找到数据，然后将数据分成两种情况：该元素&lt;strong&gt;有两个孩子&lt;/strong&gt;和该元素&lt;strong&gt;没有两个孩子；&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;没有两个孩子的逻辑就&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;很简单，判断当前左孩子是否为空，是：将元素的指针指向他的右孩子，否则指向左孩子；&lt;/span&gt;&lt;span&gt;如果两个孩子都为NULL，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;指向谁都一样；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果是有两个孩子的呢？那么我们就将这个元素下寻找到他最小的一个子辈（可能是他的孩子、孙子、曾孙、玄孙。。。）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后把他的子辈赋值给他，然后删除他的那个子辈；因为他的子辈一定是左孩子为NULL的；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以下为实现：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('6346d696-14fa-40bc-ba20-345934380baa')&quot; readability=&quot;42.5&quot;&gt;&lt;span&gt;&lt;img id=&quot;code_img_closed_6346d696-14fa-40bc-ba20-345934380baa&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_6346d696-14fa-40bc-ba20-345934380baa&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('6346d696-14fa-40bc-ba20-345934380baa',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;
&lt;div id=&quot;cnblogs_code_open_6346d696-14fa-40bc-ba20-345934380baa&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;80&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SET_typeClass_node_t *SET_removetypeClass_node_t(SET_typeClass_node_t *&lt;span&gt;root,
                                                 u8 (&lt;/span&gt;*compare)(&lt;span&gt;const&lt;/span&gt; typeClass *a, &lt;span&gt;const&lt;/span&gt; typeClass *&lt;span&gt;b),
                                                 &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; (*deleteSub)(&lt;span&gt;const&lt;/span&gt; typeClass *&lt;span&gt;ele),
                                                 &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; typeClass *value, u32 *&lt;span&gt;size)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (root ==&lt;span&gt; NULL)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; no has this value&lt;/span&gt;
&lt;span&gt;    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (compare(value, &amp;amp;root-&amp;gt;&lt;span&gt;data))
    {
        root&lt;/span&gt;-&amp;gt;left = SET_removetypeClass_node_t(root-&amp;gt;&lt;span&gt;left, compare, deleteSub, value, size);
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (compare(&amp;amp;root-&amp;gt;&lt;span&gt;data, value))
    {
        root&lt;/span&gt;-&amp;gt;right = SET_removetypeClass_node_t(root-&amp;gt;&lt;span&gt;right, compare, deleteSub, value, size);
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;real delete option&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (root-&amp;gt;right != NULL &amp;amp;&amp;amp; root-&amp;gt;left !=&lt;span&gt; NULL)
        {
            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; has two child &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            SET_typeClass_node_t &lt;/span&gt;*temp =&lt;span&gt; root;
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (temp-&amp;gt;left !=&lt;span&gt; NULL)
            {
                temp &lt;/span&gt;= temp-&amp;gt;&lt;span&gt;left;
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (deleteSub !=&lt;span&gt; NULL)
                deleteSub(&lt;/span&gt;&amp;amp;root-&amp;gt;&lt;span&gt;data);
            root&lt;/span&gt;-&amp;gt;data = temp-&amp;gt;&lt;span&gt;data;

            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; deleteSub == NULL because this min not to free ,just become root-&amp;gt;data; &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            root&lt;/span&gt;-&amp;gt;left = SET_removetypeClass_node_t(root-&amp;gt;left, compare, NULL, &amp;amp;root-&amp;gt;&lt;span&gt;data, size);
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; has only child or no child &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            SET_typeClass_node_t &lt;/span&gt;*t = (root-&amp;gt;right == NULL) ? (root-&amp;gt;left) : (root-&amp;gt;&lt;span&gt;right);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (deleteSub !=&lt;span&gt; NULL)
                deleteSub(&lt;/span&gt;&amp;amp;root-&amp;gt;&lt;span&gt;data);
            &lt;/span&gt;&lt;span&gt;free&lt;/span&gt;&lt;span&gt;(root);
            (&lt;/span&gt;*size)--&lt;span&gt;;
            root &lt;/span&gt;=&lt;span&gt; t;
        }
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; root;
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;普通二叉树remove节点&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 删除完节点之后，我们依旧需要考虑的问题是平衡的问题；删除会出现什么问题呢？&lt;/span&gt;&lt;span&gt;我们上述的删除到最后&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一定以删除一个在末梢的节点（孩子最多只有一个），因此我们只需要考虑此情况即可；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们可以换一个思路，其实删除带来的&lt;strong&gt;影响就是在树的另一边插入了一个值&lt;/strong&gt;；那么相对应的，那边高度高了我&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;就往哪边旋转就好了；&lt;/span&gt;&lt;span&gt;只不过我们判断的时候如果是删除左边，那么我们就要判断当前是不是&lt;strong&gt;右边高度-左边高度 &amp;gt; 2&lt;/strong&gt; 就好了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;嗯~很简单是不是？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;不不不&lt;/strong&gt;&lt;/span&gt;，在insert中我们判断是否需要使用双旋转的依据是：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;p&gt;&lt;span&gt;root-&amp;gt;right = SET_inserttypeClass_node_t(root-&amp;gt;right, compare, value, size);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;if (SET_heighttypeClass(root-&amp;gt;right) - SET_heighttypeClass(root-&amp;gt;left) == 2)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;{&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　if (compare(&amp;amp;root-&amp;gt;right-&amp;gt;data, value))&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　root = SET_singleRotateRighttypeClass(root);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　else&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　root = SET_doubleRotateRighttypeClass(root);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为在插入时，如果出现的不平衡，那么假设插入的值比当前root的右孩子要大，那么就会插入在右孩子的左边；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;就会出现下图所示 （插入了 14 ）&lt;/span&gt;&lt;span&gt;此时需要双旋转，是因为&lt;strong&gt;k1的右孩子高度高且右孩子的左侧比右侧要高；&lt;/strong&gt;这句话有&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;点绕口，我们分成两步，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一步：k1节点破坏了AVL树的规则且需要旋转的是&lt;strong&gt;右&lt;/strong&gt;边；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二步：在k1的右孩子k3上，虽然没有违法AVL的规则，但是他的&lt;strong&gt;左孩子&lt;/strong&gt;高度要比右孩子高度高；这就是我们所说&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;的RL情况，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以需要双旋；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1170684/201910/1170684-20191025194926213-1289951053.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1170684/201910/1170684-20191025200432569-677513889.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么在删除是，也应遵循此规则，也就是说删除的时候我们就不要比较 删除值的大小啦，因为删除完值之后，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;相当于我们需要知道另一侧的情况是不是需要双旋，这个时候怎么办呢？我们就依照上述一二步的原理，判断&lt;/span&gt;&lt;span&gt;如&lt;/span&gt;&lt;span&gt;果&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;左边高度高高于右边高度 &amp;gt;1 了，那么我就看左边孩子的两个孩子的高度是不是右边 &amp;gt; 左边，如果是-&amp;gt;双旋转,&lt;/span&gt;&lt;span&gt;如果&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不是，单旋转；由于有两个孩子的节点到最后也会是删除一个叶子节点，故不需要考虑；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以下是remove判断是否需要双旋转的代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('b585d2aa-7dd3-4456-b4a6-6cf1d429e78a')&quot; readability=&quot;35&quot;&gt;&lt;span&gt;&lt;img id=&quot;code_img_closed_b585d2aa-7dd3-4456-b4a6-6cf1d429e78a&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_b585d2aa-7dd3-4456-b4a6-6cf1d429e78a&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('b585d2aa-7dd3-4456-b4a6-6cf1d429e78a',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;
&lt;div id=&quot;cnblogs_code_open_b585d2aa-7dd3-4456-b4a6-6cf1d429e78a&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;if&lt;/span&gt; (compare(value, &amp;amp;root-&amp;gt;&lt;span&gt;data))
{
    root&lt;/span&gt;-&amp;gt;left = SET_removetypeClass_node_t(root-&amp;gt;&lt;span&gt;left, compare, deleteSub, value, size);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (SET_heighttypeClass(root-&amp;gt;right) - SET_heighttypeClass(root-&amp;gt;left) == &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (SET_heighttypeClass(root-&amp;gt;right-&amp;gt;right) &amp;gt; SET_heighttypeClass(root-&amp;gt;right-&amp;gt;&lt;span&gt;left))
            root &lt;/span&gt;=&lt;span&gt; SET_singleRotateRighttypeClass(root);
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            root &lt;/span&gt;=&lt;span&gt; SET_doubleRotateRighttypeClass(root);
    }    
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;remove是否需要双旋转&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;需要我们注意的是在删除有两个孩子的节点的时候，虽然我们是删除，但是我实际上还是调用的递归，一次我们还&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;是需要判断一次&lt;/span&gt;&lt;span&gt;平衡规则；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最后remove的代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('04569e15-6d51-417f-92a7-a137236c06c1')&quot; readability=&quot;43&quot;&gt;&lt;span&gt;&lt;img id=&quot;code_img_closed_04569e15-6d51-417f-92a7-a137236c06c1&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_04569e15-6d51-417f-92a7-a137236c06c1&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('04569e15-6d51-417f-92a7-a137236c06c1',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;
&lt;div id=&quot;cnblogs_code_open_04569e15-6d51-417f-92a7-a137236c06c1&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;81&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SET_typeClass_node_t *SET_removetypeClass_node_t(SET_typeClass_node_t *&lt;span&gt;root,
                                                 u8 (&lt;/span&gt;*compare)(&lt;span&gt;const&lt;/span&gt; typeClass *a, &lt;span&gt;const&lt;/span&gt; typeClass *&lt;span&gt;b),
                                                 &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; (*deleteSub)(&lt;span&gt;const&lt;/span&gt; typeClass *&lt;span&gt;ele),
                                                 &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; typeClass *value, u32 *&lt;span&gt;size)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (root ==&lt;span&gt; NULL)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; no has this value&lt;/span&gt;
&lt;span&gt;    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (compare(value, &amp;amp;root-&amp;gt;&lt;span&gt;data))
    {
        root&lt;/span&gt;-&amp;gt;left = SET_removetypeClass_node_t(root-&amp;gt;&lt;span&gt;left, compare, deleteSub, value, size);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (SET_heighttypeClass(root-&amp;gt;right) - SET_heighttypeClass(root-&amp;gt;left) == &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (SET_heighttypeClass(root-&amp;gt;right-&amp;gt;right) &amp;gt; SET_heighttypeClass(root-&amp;gt;right-&amp;gt;&lt;span&gt;left))
                root &lt;/span&gt;=&lt;span&gt; SET_singleRotateRighttypeClass(root);
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                root &lt;/span&gt;=&lt;span&gt; SET_doubleRotateRighttypeClass(root);
        }
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (compare(&amp;amp;root-&amp;gt;&lt;span&gt;data, value))
    {
        root&lt;/span&gt;-&amp;gt;right = SET_removetypeClass_node_t(root-&amp;gt;&lt;span&gt;right, compare, deleteSub, value, size);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (SET_heighttypeClass(root-&amp;gt;left) - SET_heighttypeClass(root-&amp;gt;right) == &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (SET_heighttypeClass(root-&amp;gt;left-&amp;gt;left) &amp;gt; SET_heighttypeClass(root-&amp;gt;left-&amp;gt;&lt;span&gt;right))
                root &lt;/span&gt;=&lt;span&gt; SET_singleRotateLefttypeClass(root);
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                root &lt;/span&gt;=&lt;span&gt; SET_doubleRotateLefttypeClass(root);
        }
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;real delete option&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (root-&amp;gt;right != NULL &amp;amp;&amp;amp; root-&amp;gt;left !=&lt;span&gt; NULL)
        {
            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; has two child &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            SET_typeClass_node_t &lt;/span&gt;*temp =&lt;span&gt; root;
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (temp-&amp;gt;left !=&lt;span&gt; NULL)
            {
                temp &lt;/span&gt;= temp-&amp;gt;&lt;span&gt;left;
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (deleteSub !=&lt;span&gt; NULL)
                deleteSub(&lt;/span&gt;&amp;amp;root-&amp;gt;&lt;span&gt;data);
            root&lt;/span&gt;-&amp;gt;data = temp-&amp;gt;&lt;span&gt;data;

            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; deleteSub == NULL because this min not to free ,just become root-&amp;gt;data; &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            root&lt;/span&gt;-&amp;gt;left = SET_removetypeClass_node_t(root-&amp;gt;left, compare, NULL, &amp;amp;root-&amp;gt;&lt;span&gt;data, size);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (SET_heighttypeClass(root-&amp;gt;right) - SET_heighttypeClass(root-&amp;gt;left) == &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (SET_heighttypeClass(root-&amp;gt;right-&amp;gt;right) &amp;gt; SET_heighttypeClass(root-&amp;gt;right-&amp;gt;&lt;span&gt;left))
                    root &lt;/span&gt;=&lt;span&gt; SET_singleRotateRighttypeClass(root);
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                    root &lt;/span&gt;=&lt;span&gt; SET_doubleRotateRighttypeClass(root);
            }
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; has only child or no child &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            SET_typeClass_node_t &lt;/span&gt;*t = (root-&amp;gt;right == NULL) ? (root-&amp;gt;left) : (root-&amp;gt;&lt;span&gt;right);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (deleteSub !=&lt;span&gt; NULL)
                deleteSub(&lt;/span&gt;&amp;amp;root-&amp;gt;&lt;span&gt;data);
            &lt;/span&gt;&lt;span&gt;free&lt;/span&gt;&lt;span&gt;(root);
            (&lt;/span&gt;*size)--&lt;span&gt;;
            root &lt;/span&gt;=&lt;span&gt; t;
        }
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (root !=&lt;span&gt; NULL)
        root&lt;/span&gt;-&amp;gt;heigh = SET_Max(SET_heighttypeClass(root-&amp;gt;&lt;span&gt;left),
                              SET_heighttypeClass(root&lt;/span&gt;-&amp;gt;right)) +
                      &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; root;
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;AVL remove 代码&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同理使用一个tree对他进行封装，同时返回是否remove成功，remove不成功只有一种可能，那就是set中不存在此元素；&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;u8 SET_removetypeClass_t(SET_typeClass_t *&lt;span&gt;set&lt;/span&gt;, &lt;span&gt;const&lt;/span&gt;&lt;span&gt; typeClass ele)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;set&lt;/span&gt; == NULL || &lt;span&gt;set&lt;/span&gt;-&amp;gt;compare ==&lt;span&gt; NULL)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    u32 cursize &lt;/span&gt;= &lt;span&gt;set&lt;/span&gt;-&amp;gt;&lt;span&gt;size;
    &lt;/span&gt;&lt;span&gt;set&lt;/span&gt;-&amp;gt;root = SET_removetypeClass_node_t(&lt;span&gt;set&lt;/span&gt;-&amp;gt;root, &lt;span&gt;set&lt;/span&gt;-&amp;gt;compare, &lt;span&gt;set&lt;/span&gt;-&amp;gt;deleteSub, &amp;amp;ele, &amp;amp;&lt;span&gt;set&lt;/span&gt;-&amp;gt;&lt;span&gt;size);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (cursize &amp;gt; &lt;span&gt;set&lt;/span&gt;-&amp;gt;&lt;span&gt;size);
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在AVL树中最重要的就是插入和删除啦；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其他的像 delete 遍历呀，find findMax之类的太简单我就不说啦。基本上就是使用遍历或者一直往右找或往左找；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最后我考虑到上文中SET_typeClass_t是一个类型，所以所有的比较都抽象化了compare函数，还有有可能在&lt;/span&gt;&lt;span&gt;删除的时候&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;需要释放SET_typeClass_t中指向的空间，所以抽象化成为函数指针deleteSub；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;【结束语】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下一节就是将我们今天所实现的这些函数变成宏，完成 STL 数据容器 SET&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;目录&lt;/p&gt;

&lt;p&gt;1.&lt;a href=&quot;https://www.cnblogs.com/kimalittlestar/p/11703214.html&quot; target=&quot;_blank&quot;&gt;引言&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/kimalittlestar/p/11704083.html&quot; target=&quot;_blank&quot;&gt;2.1 C语言_实现简单基础的vector&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/kimalittlestar/p/11716252.html&quot; target=&quot;_blank&quot;&gt;2.2 C语言_实现数据容器vector(排序功能)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/kimalittlestar/p/11739050.html&quot; target=&quot;_blank&quot;&gt;3.1 C语言_实现AVL平衡二叉树&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;3.2 C语言_实现数据容器set(基础版)&lt;/p&gt;

&lt;p&gt;4 C语言_实现简单基础的map&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; 参考资料&lt;/strong&gt; : 数据结构与算法C++实现.pdf;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 25 Oct 2019 13:16:00 +0000</pubDate>
<dc:creator>Kim_小星兴</dc:creator>
<og:description>【序】 上节我们实现了数据结构中最简单的Vector，那么来到第三章，我们需要实现一个Set set的特点是 内部有序且有唯一元素值；同时各种操作的期望操作时间复杂度在O（n&amp;#183;logn）；</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kimalittlestar/p/11739050.html</dc:identifier>
</item>
<item>
<title>造轮子了！NETCore跨平台UI框架，CPF - DSkin</title>
<link>http://www.cnblogs.com/dskin/p/11740751.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dskin/p/11740751.html</guid>
<description>&lt;p&gt;CPF(暂时命名)（Cross platform framework），模仿WPF的框架，支持NETCore的跨平台UI框架，&lt;strong&gt;暂时不够完善，只用于测试&lt;/strong&gt;，暂时只支持Windows和Mac。支持数据绑定，CSS，动画。。。&lt;/p&gt;
&lt;p&gt;可能有人会说，不是有个开源的Avalonia ，我试过，不过他的性能不行，启动速度慢，内存占用高，附带的dll一大堆，他的是Xaml来描述UI的，我的不提供Xaml，直接用C#来写，以后将出设计器直接生成C#代码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/774637/201910/774637-20191025175847264-2076108964.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;CpfObject相当于WPF里的&lt;a href=&quot;https://msdn.microsoft.com/zh-cn/library/system.windows.dependencyobject.aspx&quot;&gt;DependencyObject&lt;/a&gt;依赖对象。继承该类的对象，所有属性默认都是依赖属性&lt;/p&gt;
&lt;p&gt;属性写法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 绑定的数据上下文
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;         [PropertyMetadata(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt; DataContext
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;             &lt;span&gt;get&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt; GetValue&amp;lt;&lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt;(); }
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;             &lt;span&gt;set&lt;/span&gt;&lt;span&gt; { SetValue(value); }
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;属性上的特性可以是 PropertyMetadata或者UIPropertyMetadata 中的一个，默认值建议通过这两个特性来设置。如果不加这两个特性，那默认值就是null或者0&lt;/p&gt;
&lt;p&gt;如果是复杂属性类型默认值，可以通过重写 OnOverrideMetadata 来设置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnOverrideMetadata(OverrideMetadata overridePropertys)
        {
            &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;.OnOverrideMetadata(overridePropertys);
            overridePropertys.Override(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;StrokeStyle&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; UIPropertyMetadataAttribute(&lt;span&gt;new&lt;/span&gt; Stroke(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)));
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;附加属性：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取或设置元素行索引
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Attached&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt; RowIndex
        {
            &lt;/span&gt;&lt;span&gt;get&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt; RegisterAttached(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;); }
        }

Grid.RowIndex(control, &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用附加属性方式设置行索引&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; index = Grid.RowIndex(control);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取附加属性值&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;数据绑定：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; bind = label[nameof(Label.Text)] &amp;lt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;右到左数据绑定，数据源是DataContext的属性&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; bind = label[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] &amp;gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;左到右数据绑定，数据源是DataContext的属性&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; bind = label[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] != &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;左到右数据绑定,只传递一次 ，数据源是DataContext的属性&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; bind = label[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;双向绑定，数据源是DataContext的属性，双向绑定需要对象实现INotifyPropertyChanged&lt;/span&gt;


&lt;span&gt;var&lt;/span&gt; bind = label[nameof(Label.Text)] &amp;lt;= button[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;右到左数据绑定&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; bind = label[nameof(Label.Text)] &amp;gt;= button[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;左到右数据绑定&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; bind = label[nameof(Label.Text)] != button[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;左到右数据绑定,只传递一次&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; bind = label[nameof(Label.Text)] == button[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;双向绑定&lt;/span&gt;
&lt;span&gt;
btn.Bindings.Add(nameof(Button.Content), nameof(TextBlock.Text), &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;, BindingMode.OneWay, a =&amp;gt; a.ToString());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过Bindings属性添加绑定，建议用nameof()这样不容易写错&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;命令绑定：&lt;/p&gt;
&lt;p&gt;当事件触发或者属性变化的时候调用方法&lt;/p&gt;
&lt;p&gt;Label.Commands.Add(nameof(Window.MouseDown), nameof(Window.DragMove), Relation.Me.Parent);&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Button
    {
     　　Width &lt;/span&gt;= &lt;span&gt;20&lt;/span&gt;&lt;span&gt;,
        Height &lt;/span&gt;= &lt;span&gt;20&lt;/span&gt;&lt;span&gt;,
        MarginRight &lt;/span&gt;= &lt;span&gt;30&lt;/span&gt;&lt;span&gt;,
        MarginTop &lt;/span&gt;= &lt;span&gt;5&lt;/span&gt;&lt;span&gt;,
        Content &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        Commands &lt;/span&gt;= { { nameof(Button.MouseUp), ()=&amp;gt; { window.WindowState =&lt;span&gt; WindowState.Minimized; } } }
     }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p align=&quot;left&quot;&gt;布局系统&lt;/p&gt;
&lt;p&gt;布局流程和WPF差不多，先Measure再Arrange，如果自定义布局容器，可以参考WPF的代码&lt;/p&gt;
&lt;p&gt;元素布局，支持百分比布局，margin调整定位，默认居中。相当于CSS里中的绝对定义position: absolute;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MarginLeft&lt;/strong&gt;&lt;strong&gt;，MarginTop，MarginRight,MarginBottom&lt;/strong&gt;，一般默认值是Auto，当设置值之后固定对应边到父容器到内边距的距离&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Width&lt;/strong&gt;&lt;strong&gt;，Height&lt;/strong&gt;，一般默认值也是Auto，如果没设置，实际尺寸由内容或者子元素尺寸决定，或者由Margin决定&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;new&lt;/span&gt; Border { Width = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;100%&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Height = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;100%&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Background = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#fff&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;属性值的自动转换：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
Width = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;100%&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
Width &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Auto&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
Width &lt;/span&gt;= &lt;span&gt;100&lt;/span&gt;&lt;span&gt;;
Background &lt;/span&gt;= Color.FromRgb(&lt;span&gt;100&lt;/span&gt;,&lt;span&gt;100&lt;/span&gt;,&lt;span&gt;100&lt;/span&gt;&lt;span&gt;);
Background &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#fff&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
Background &lt;/span&gt;=image;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre&gt;
&lt;em&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/774637/201910/774637-20191025182250477-27365742.gif&quot; alt=&quot;&quot;/&gt;&lt;/em&gt;
&lt;/pre&gt;
&lt;p align=&quot;left&quot;&gt;CSS样式&lt;/p&gt;
&lt;p&gt;支持简单的选择器&lt;/p&gt;
&lt;p&gt;TextBlock { Foreground:rgb(255,0,0);} 选择所有TextBlock类型的元素&lt;/p&gt;
&lt;p&gt;.test{Foreground:rgb(255,0,0);} 选择所有包含test 类名的元素，类名通过Classes属性添加&lt;/p&gt;
&lt;p&gt;#test{Foreground:rgb(255,0,0);} 选择所有Name属性为test的元素&lt;/p&gt;
&lt;p&gt;[IsMouseOver=true]{…}   添加触发器&lt;/p&gt;
&lt;p&gt;Button TextBlock{…}   Button里的后代为TextBox的元素，只支持两层&lt;/p&gt;
&lt;p&gt;Button&amp;gt;TextBlock{…}   Button直接子元素为TextBox的元素，只支持两层&lt;/p&gt;

&lt;p&gt;触发器和动画&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;.test[IsMouseOver=true]{animation-name:myfirst;animation-duration:1s;animation-iteration-count: 1;}&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;@keyframes myfirst&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;{&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;0%   {Background: #f00;}&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;25%  {Background: #0ff;}&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;50%  {Background: #00f;}&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;100% {Background: #0f0;}&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;通过根元素的LoadStyle方法加载样式，比如Window对象&lt;/p&gt;

&lt;p&gt;控件模板：&lt;/p&gt;
&lt;p&gt;继承你要修改的控件，然后重写InitializeComponent 把定义代码写在里面，不知道怎么定义？查看内置模板代码，详细模板代码看压缩包里的文档，复制过去，自己根据需要修改&lt;/p&gt;

&lt;p&gt;对Mac开发不熟悉，Mac系统下还不能输入中文，有没有猛男赐教一下，怎么调用输入法，打开关闭输入法和控制输入法候选词位置&lt;/p&gt;
&lt;p&gt;我感觉模板设计的不够好，还有数据绑定还可以优化一下。各位有什么想法和意见说说。&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;&lt;a href=&quot;https://files.cnblogs.com/files/dskin/CPF%E8%B7%A8%E5%B9%B3%E5%8F%B0UI%E6%B5%8B%E8%AF%95.zip&quot; target=&quot;_blank&quot;&gt;CPF 下载&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 25 Oct 2019 12:37:00 +0000</pubDate>
<dc:creator>DSkin</dc:creator>
<og:description>CPF(暂时命名)（Cross platform framework），模仿WPF的框架，支持NETCore的跨平台UI框架，暂时不够完善，只用于测试，暂时只支持Windows和Mac。支持数据绑定，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/dskin/p/11740751.html</dc:identifier>
</item>
</channel>
</rss>