<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>曹工说Redis源码（4）-- 通过redis server源码来理解 listen 函数中的 backlog 参数 - 三国梦回</title>
<link>http://www.cnblogs.com/grey-wolf/p/12694767.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/grey-wolf/p/12694767.html</guid>
<description>&lt;p&gt;Redis源码系列的初衷，是帮助我们更好地理解Redis，更懂Redis，而怎么才能懂，光看是不够的，建议跟着下面的这一篇，把环境搭建起来，后续可以自己阅读源码，或者跟着我这边一起阅读。由于我用c也是好几年以前了，些许错误在所难免，希望读者能不吝指出。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12637730.html&quot;&gt;曹工说Redis源码（1）-- redis debug环境搭建，使用clion，达到和调试java一样的效果&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12682760.html&quot;&gt;曹工说Redis源码（2）-- redis server 启动过程解析及简单c语言基础知识补充&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12685918.html&quot;&gt;曹工说Redis源码（3）-- redis server 启动过程完整解析（中）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;早上，技术群里，有个同学问了个问题：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/519126/202004/519126-20200413214153521-362198562.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样看来，还是有部分同学，对backlog这个参数，不甚了解，所以，干脆本讲就讲讲这个话题。&lt;/p&gt;
&lt;p&gt;本来可以直接拿java来举例，不过这几天正好在看redis，而且 redis server就是服务端，也是对外提供监听端口的，而且其用 c 语言编写，直接调用操作系统的api，不像java那样封装了一层，我们直接拿redis server的代码来分析，就能离真相更近一点。&lt;/p&gt;
&lt;p&gt;我会拿一个例子来讲，例子里的代码，是直接从redis的源码中拷贝的，一行没改，通过这个例子，我们也能更理解redis一些。&lt;/p&gt;

&lt;h2 id=&quot;backlog参数简单讲解&quot;&gt;backlog参数简单讲解&lt;/h2&gt;
&lt;p&gt;比如我监听某端口，那么客户端可以来同该端口，建立socket连接；正常情况下，服务端（bio模式）会一直阻塞调用accept。&lt;/p&gt;
&lt;p&gt;大家想过没有，accept是怎么拿到这个新进来的socket的？其实，这中间就有个阻塞队列，当队列没有元素的时候，accept就会阻塞在这个队列的take操作中，所以，我个人感觉，accept操作，其实和队列的从队尾或队头取一个元素，是一样的。&lt;/p&gt;
&lt;p&gt;当新客户端建立连接时，完成了三次握手后，就会被放到这个队列中，这个队列，我们一般叫做：全连接队列。&lt;/p&gt;
&lt;p&gt;而这个队列的最大容量，或者说size，就是backlog这个整数的大小。&lt;/p&gt;
&lt;p&gt;正常情况下，只要服务端程序，accept不要卡壳，这个backlog队列多大多小都无所谓；如果设置大一点，就能在服务端accept速度比较慢的时候，起到削峰的作用，怎么感觉和mq有点像，哈哈。&lt;/p&gt;
&lt;p&gt;说完了，下面开始测试了，首先测试程序正常accept的情况。&lt;/p&gt;
&lt;h2 id=&quot;main测试程序&quot;&gt;main测试程序&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;
int main() {
    // 1
    char *pVoid = malloc(10);
    // 2
    int serverSocket = anetTcpServer(pVoid, 6380, NULL, 2);
    printf(&quot;listening...&quot;);
    
    while (1) {
        int fd;
        struct sockaddr_storage sa;
        socklen_t salen = sizeof(sa);
                // 3
        char* err = malloc(20);
        // 4
        if ((fd = anetGenericAccept(err, serverSocket, (struct sockaddr*)&amp;amp;sa, &amp;amp;salen)) == -1)
            return ANET_ERR;
        printf(&quot;accept...%d&quot;,fd);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;1处，我们先分配了一个10字节的内存，这个主要是存放错误信息，在c语言编程中，不能像高级语言一样抛异常，所以，返回值一般用来返回0/1，表示函数调用的成功失败；如果需要在函数内部修改什么东西，一般就会先new一个内存出来，然后把指针传进去，然后在里面就对这片内存空间进行操作，这里也是一样。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;anetTcpServer 是我们自定义的，内部会实现如下逻辑：在本机的6380端口上进行监听，backlog参数即全连接队列的size，设为2。如果出错的话，就会把错误信息，写入1处的那个内存中。&lt;/p&gt;
&lt;p&gt;这一步调用完成后，端口就起好了。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;3处，同样分配了一点内存，供accept连接出错时使用，和1处作用类似&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;4处，调用accept去从队列取连接&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;anettcpserver，监听端口&quot;&gt;anetTcpServer，监听端口&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;int anetTcpServer(char *err, int port, char *bindaddr, int backlog) {
    return _anetTcpServer(err, port, bindaddr, AF_INET, backlog);
}


static int _anetTcpServer(char *err, int port, char *bindaddr, int af, int backlog) {
    int s, rv;
    char _port[6];  /* strlen(&quot;65535&quot;) */
    struct addrinfo hints, *servinfo, *p;

    snprintf(_port, 6, &quot;%d&quot;, port);
    // 1
    memset(&amp;amp;hints, 0, sizeof(hints));
    hints.ai_family = af;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_flags = AI_PASSIVE;    /* No effect if bindaddr != NULL */
        
    // 2
    if ((rv = getaddrinfo(bindaddr, _port, &amp;amp;hints, &amp;amp;servinfo)) != 0) {
        anetSetError(err, &quot;%s&quot;, gai_strerror(rv));
        return ANET_ERR;
    }
    for (p = servinfo; p != NULL; p = p-&amp;gt;ai_next) {
        // 3
        if ((s = socket(p-&amp;gt;ai_family, p-&amp;gt;ai_socktype, p-&amp;gt;ai_protocol)) == -1)
            continue;
                // 4
        if (anetSetReuseAddr(err, s) == ANET_ERR) goto error;
        // 5
        if (anetListen(err, s, p-&amp;gt;ai_addr, p-&amp;gt;ai_addrlen, backlog) == ANET_ERR) goto error;
        goto end;
    }

    error:
        s = ANET_ERR;
    end:
        freeaddrinfo(servinfo);
    return s;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;7.7440890125174&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;1处，new一个结构体，c语言中，new一个对象比较麻烦，要先定义一个结构体类型的变量，如&lt;code&gt;struct addrinfo hints,&lt;/code&gt;，然后调用memset来初始化内存，然后设置各个属性。总体来说，这里就是new了一个ipv4的地址&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;9.5&quot;&gt;
&lt;p&gt;2处，因为一般服务器都有多网卡，多个ip地址，还有环回网卡之类的，这里的getaddrinfo，是利用我们第一步的hints，去帮助我们筛选出一个最终的网卡地址出来，然后赋值给 servinfo 变量。&lt;/p&gt;
&lt;p&gt;这里可能有不准确的地方，大家可以直接看官方文档：&lt;/p&gt;
&lt;blockquote readability=&quot;16&quot;&gt;
&lt;p&gt;int getaddrinfo(const char *node, const char *service,&lt;br/&gt;const struct addrinfo *hints,&lt;br/&gt;struct addrinfo **res);&lt;/p&gt;
&lt;p&gt;Given node and service, which identify an Internet host and a service, getaddrinfo() returns one or more addrinfo structures, each of which contains an Internet address that can be specified in a call to bind(2) or connect(2).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;3处，使用第二步拿到的地址，new一个socket&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2.9505119453925&quot;&gt;
&lt;p&gt;4处，anetSetReuseAddr，设置SO_REUSEADDR选项，我简单查了下，可参考：&lt;/p&gt;
&lt;p&gt;[&lt;a href=&quot;https://www.cnblogs.com/HKUI/p/11707170.html&quot;&gt;socket常见选项之SO_REUSEADDR,SO_REUSEPORT&lt;/a&gt;]&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;SO_REUSEADDR&lt;br/&gt;一般来说，一个端口释放后会等待两分钟之后才能再被使用，SO_REUSEADDR是让端口释放后立即就可以被再次使用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;5处，调用listen进行监听，这里用到了我们传入的backlog参数。&lt;/p&gt;
&lt;p&gt;其中，backlog参数的官方说明，如下，意思也就是说，是队列的size：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/519126/202004/519126-20200413223036729-1440191382.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其中，anetListen是我们自定义的，我们接着看：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;/*
 * 绑定并创建监听套接字
 */
static int anetListen(char *err, int s, struct sockaddr *sa, socklen_t len, int backlog) {
    // 1
    if (bind(s, sa, len) == -1) {
        anetSetError(err, &quot;bind: %s&quot;, strerror(errno));
        close(s);
        return ANET_ERR;
    }
        // 2
    if (listen(s, backlog) == -1) {
        anetSetError(err, &quot;listen: %s&quot;, strerror(errno));
        close(s);
        return ANET_ERR;
    }
    return ANET_OK;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;1处，这里进行绑定&lt;/li&gt;
&lt;li&gt;2处，这里调用操作系统的函数，进行监听，其中，第一个参数就是前面的socket file descriptor，第二个，就是backlog。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;如何运行&quot;&gt;如何运行&lt;/h2&gt;
&lt;p&gt;代码地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/ckl111/redis-3.0-annotated-cmake-in-clion/blob/master/our-redis-implementation/my_anet.c&quot;&gt;https://gitee.com/ckl111/redis-3.0-annotated-cmake-in-clion/blob/master/our-redis-implementation/my_anet.c&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/ckl111/redis-3.0-annotated-cmake-in-clion/blob/master/our-redis-implementation/my_anet.h&quot;&gt;https://gitee.com/ckl111/redis-3.0-annotated-cmake-in-clion/blob/master/our-redis-implementation/my_anet.h&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;大家把上面这两个文件，自己放到一个linux操作系统的文件夹下，然后执行以下命令，就能把这个demo启动起来：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/519126/202004/519126-20200413223654249-1404571097.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;测试&quot;&gt;测试&lt;/h2&gt;
&lt;h3 id=&quot;查看监听端口是否启动&quot;&gt;查看监听端口是否启动&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;[root@mini2 ~]# netstat -ano|grep 6380
tcp        0      0 0.0.0.0:6380            0.0.0.0:*               LISTEN      off (0.00/0/0)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;开启一个shell，连接到6380端口&quot;&gt;开启一个shell，连接到6380端口&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/519126/202004/519126-20200413223917852-794254711.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我这边开了3个shell，去连接6380端口，然后，我执行：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;[root@mini2 ~]# netstat -ano|grep 6380
tcp        0      0 0.0.0.0:6380            0.0.0.0:*               LISTEN      off (0.00/0/0)
tcp        0      0 127.0.0.1:51386         127.0.0.1:6380          ESTABLISHED off (0.00/0/0)
tcp        0      0 127.0.0.1:54442         127.0.0.1:6380          ESTABLISHED off (0.00/0/0)
tcp        0      0 127.0.0.1:51930         127.0.0.1:6380          ESTABLISHED off (0.00/0/0)
tcp        0      0 127.0.0.1:6380          127.0.0.1:51386         ESTABLISHED off (0.00/0/0)
tcp        0      0 127.0.0.1:6380          127.0.0.1:54442         ESTABLISHED off (0.00/0/0)
tcp        0      0 127.0.0.1:6380          127.0.0.1:51930         ESTABLISHED off (0.00/0/0)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，已经有3个socket，连接到6380端口了。&lt;/p&gt;
&lt;h3 id=&quot;查看端口对应的backlog队列的相关东西&quot;&gt;查看端口对应的backlog队列的相关东西&lt;/h3&gt;
&lt;p&gt;怎么看backlog那些呢？有个命令叫ss，其是netstat的升级版，执行以下命令如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;[root@mini2 ~]# ss -l |grep 6380
tcp    LISTEN     0      2       *:6380                  *:*     
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面我们查询了6380这个监听端口的状态，其中，&lt;/p&gt;
&lt;ul readability=&quot;9.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;第一列，tcp，传输协议的名称&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;第二列，状态，LISTEN&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;第三列，查阅man netstat可以看到，&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;Recv-Q
       Established: The count of bytes not copied by the user program connected to this socket.  
       Listening: Since Kernel 2.6.18 this column contains  the  current syn backlog.
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当其为Established状态时，应该是缓冲区中没被拷贝到用户程序的字节的数量；&lt;/p&gt;
&lt;p&gt;当其为LISTEN状态时，表示当前backlog这个队列，即前面说的全连接队列的，容量的大小；这里，因为我们的程序一直在accept连接，所以这里为0&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;第4列，官方文档：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;Send-Q
Established: The count of bytes not acknowledged by the remote host.    

Listening:   Since Kernel 2.6.18 this column contains the maximum size of the syn backlog.
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当其为Established时，表示我方缓冲区中还没有被对方ack的字节数量&lt;/p&gt;
&lt;p&gt;当其为Listen时，表示全连接队列的最大容量，我们是设为2的，所以这里是2。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;测试2&quot;&gt;测试2&lt;/h2&gt;
&lt;p&gt;当我们程序不去accept的时候，会怎么样呢，修改程序如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;int main() {
    char *pVoid = malloc(10);
    int serverSocket = anetTcpServer(pVoid, 6380, NULL, 2);
    printf(&quot;listening...&quot;);

    while (1){
        sleep(100000);
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们再去开启3个客户端连接，然后，最后看ss命令的情况：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;[root@mini2 ~]# ss -l |grep 6380
tcp    LISTEN     3      2       *:6380                  *:*   
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再执行netstat看看：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;[root@mini2 ~]# netstat -ano|grep 6380
tcp        0      0 127.0.0.1:50238         127.0.0.1:6380          ESTABLISHED off (0.00/0/0)
tcp        0      0 127.0.0.1:50362         127.0.0.1:6380          ESTABLISHED off (0.00/0/0)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;发现了吗，只有2个连接是ok的。因为我们的全连接队列，最大为2，现在已经full了啊，所以新连接进不来了。&lt;/p&gt;

&lt;p&gt;大家可以跟着我的demo试一下，相信理解会更深刻一点。&lt;/p&gt;
&lt;p&gt;以前我也写了一篇，大家可以参考下。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/10999342.html&quot;&gt;Linux中，Tomcat 怎么承载高并发（深入Tcp参数 backlog）&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 14 Apr 2020 00:26:00 +0000</pubDate>
<dc:creator>三国梦回</dc:creator>
<og:description>文章导航 Redis源码系列的初衷，是帮助我们更好地理解Redis，更懂Redis，而怎么才能懂，光看是不够的，建议跟着下面的这一篇，把环境搭建起来，后续可以自己阅读源码，或者跟着我这边一起阅读。由于</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/grey-wolf/p/12694767.html</dc:identifier>
</item>
<item>
<title>IO 模型知多少 - 「圣杰」</title>
<link>http://www.cnblogs.com/sheng-jie/p/how-much-you-know-about-io-models.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sheng-jie/p/how-much-you-know-about-io-models.html</guid>
<description>&lt;p&gt;同步异步I/O，阻塞非阻塞I/O是程序员老生常谈的话题了，也是自己一直以来懵懵懂懂的一个话题。比如：何为同步异步？何为阻塞与非阻塞？二者的区别在哪里？阻塞在何处？为什么会有多种IO模型，分别用来解决问题？常用的框架采用的是何种I/O模型？各种IO模型的优劣势在哪里，适用于何种应用场景？ 简而言之，对于I/O的认知，不能仅仅停留在字面上认识，了解内部玄机，才能深刻理解I/O，才能看清I/O相关问题的本质。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;180.83769633508&quot;&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/4/14/17175f9e2194835b?w=940&amp;amp;h=458&amp;amp;f=png&amp;amp;s=157256&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;同步异步I/O，阻塞非阻塞I/O是程序员老生常谈的话题了，也是自己一直以来懵懵懂懂的一个话题。比如：何为同步异步？何为阻塞与非阻塞？二者的区别在哪里？阻塞在何处？为什么会有多种IO模型，分别用来解决问题？常用的框架采用的是何种I/O模型？各种IO模型的优劣势在哪里，适用于何种应用场景？&lt;/p&gt;
&lt;p&gt;简而言之，对于I/O的认知，不能仅仅停留在字面上认识，了解内部玄机，才能深刻理解I/O，才能看清I/O相关问题的本质。&lt;/p&gt;

&lt;p&gt;I/O 的全称是Input/Output。虽常谈及I/O，但想必你也一时不能给出一个完整的定义。搜索了谷歌，发现也尽是些冗长的论述。要想厘清I/O这个概念，我们需要从不同的视角去理解它。&lt;/p&gt;
&lt;h2 id=&quot;21-计算机视角&quot;&gt;2.1. 计算机视角&lt;/h2&gt;
&lt;p&gt;冯•诺伊曼计算机的基本思想中有提到计算机硬件组成应为五大部分：控制器，运算器，存储器，输入和输出。其中输入是指将数据输入到计算机的设备，比如键盘鼠标；输出是指从计算机中获取数据的设备，比如显示器；以及既是输入又是输出设备，硬盘，网卡等。&lt;/p&gt;
&lt;p&gt;用户通过操作系统才能完成对计算机的操作。计算机启动时，第一个启动的程序是操作系统的内核，它将负责计算机的资源管理和进程的调度。换句话说：操作系统负责从输入设备读取数据并将数据写入到输出设备。&lt;/p&gt;
&lt;p&gt;所以I/O之于计算机，有两层意思：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;I/O设备&lt;/li&gt;
&lt;li&gt;对I/O设备的数据读写&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;em&gt;对于一次I/O操作，必然涉及2个参与方，一个输入端，一个输出端，而又根据参与双方的设备类型，我们又可以分为磁盘I/O，网络I/O（一次网络的请求响应，网卡）等。&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;22-程序视角&quot;&gt;2.2. 程序视角&lt;/h2&gt;
&lt;p&gt;应用程序作为一个文件保存在磁盘中，只有加载到内存到成为一个进程才能运行。应用程序运行在计算机内存中，必然会涉及到数据交换，比如读写磁盘文件，访问数据库，调用远程API等等。但我们编写的程序并不能像操作系统内核一样直接进行I/O操作。&lt;/p&gt;
&lt;p&gt;因为为了确保操作系统的安全稳定运行，操作系统启动后，将会开启保护模式：将内存分为内核空间（内核对应进程所在内存空间）和用户空间，进行内存隔离。我们构建的程序将运行在用户空间，用户空间无法操作内核空间，也就意味着用户空间的程序不能直接访问由内核管理的I/O，比如：硬盘、网卡等。&lt;/p&gt;
&lt;p&gt;但操作系统向外提供API，其由各种类型的系统调用（System Call）组成，以提供安全的访问控制。&lt;br/&gt;所以应用程序要想访问内核管理的I/O，必须通过调用内核提供的系统调用(system call）进行间接访问。&lt;/p&gt;
&lt;p&gt;所以I/O之于应用程序来说，强调的通过&lt;strong&gt;向内核发起系统调用完成对I/O的间接访问&lt;/strong&gt;。换句话说应用程序发起的一次IO操作实际包含两个阶段：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;IO调用阶段：应用程序进程向内核发起系统调用&lt;/li&gt;
&lt;li&gt;IO执行阶段：内核执行IO操作并返回&lt;br/&gt;2.1. 准备数据阶段：内核等待I/O设备准备好数据&lt;br/&gt;2.2. 拷贝数据阶段：将数据从内核缓冲区拷贝到用户空间缓冲区&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;怎么理解准备数据阶段呢？&lt;br/&gt;对于写请求：等待系统调用的完整请求数据，并写入内核缓冲区；&lt;br/&gt;对于读请求：等待系统调用的完整请求数据；（若请求数据不存在于内核缓冲区）则将外围设备的数据读入到内核缓冲区。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/4/14/17175f198660204b?w=961&amp;amp;h=455&amp;amp;f=png&amp;amp;s=16621&quot; alt=&quot;IO操作执行流程&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而应用程序进程在发起IO调用至内核执行IO返回之前，应用程序进程/线程所处状态，就是我们下面要讨论的第二个话题阻塞IO与非阻塞IO。&lt;/p&gt;

&lt;p&gt;应用程序中进程在发起IO调用后至内核执行IO操作返回结果之前，若发起系统调用的线程一直处于等待状态，则此次IO操作为阻塞IO。阻塞IO简称BIO，Blocking IO。其处理流程如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/4/14/17175f198678bcde?w=692&amp;amp;h=385&amp;amp;f=png&amp;amp;s=58079&quot; alt=&quot;BIO&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图可知当用户进程发起IO系统调用后，内核从准备数据到拷贝数据到用户空间的两个阶段期间&lt;strong&gt;用户调用线程选择阻塞等待&lt;/strong&gt;数据返回。&lt;/p&gt;
&lt;p&gt;因此BIO带来了一个问题：如果内核数据需要耗时很久才能准备好，那么用户进程将被阻塞，浪费性能。为了提升应用的性能，虽然可以通过多线程来提升性能，但线程的创建依然会借助系统调用，同时多线程会导致频繁的线程上下文的切换，同样会影响性能。所以要想解决BIO带来的问题，我们就得看到问题的本质，那就是&lt;strong&gt;阻塞&lt;/strong&gt;二字。&lt;/p&gt;

&lt;p&gt;那解决方案自然也容易想到，将阻塞变为非阻塞，那就是用户进程在发起系统调用时指定为非阻塞，内核接收到请求后，就会立即返回，然后用户进程通过轮询的方式来拉取处理结果。也就是如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/4/14/17175f198687b2b3?w=663&amp;amp;h=433&amp;amp;f=png&amp;amp;s=109263&quot; alt=&quot;NIO&quot;/&gt;&lt;/p&gt;
&lt;p&gt;应用程序中进程在发起IO调用后至内核执行IO操作返回结果之前，若发起系统调用的线程不会等待而是立即返回，则此次IO操作为非阻塞IO模型。非阻塞IO简称NIO，Non-Blocking IO。&lt;/p&gt;
&lt;p&gt;然而，非阻塞IO虽然相对于阻塞IO大幅提升了性能，但依旧不是完美的解决方案，其依然存在性能问题，也就是频繁的轮询导致频繁的系统调用，会耗费大量的CPU资源。比如当并发很高时，假设有1000个并发，那么单位时间循环内将会有1000次系统调用去轮询执行结果，而实际上可能只有2个请求结果执行完毕，这就会有998次无效的系统调用，造成严重的性能浪费。有问题就要解决，那&lt;strong&gt;NIO问题的本质就是频繁轮询导致的无效系统调用&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;解决NIO的思路就是降解无效的系统调用，如何降解呢？我们一起来看看以下几种IO多路复用的解决思路。&lt;/p&gt;
&lt;h2 id=&quot;51-io多路复用之selectpoll&quot;&gt;5.1. IO多路复用之select/poll&lt;/h2&gt;
&lt;p&gt;Select是内核提供的系统调用，它支持一次查询多个系统调用的可用状态，当任意一个结果状态可用时就会返回，用户进程再发起一次系统调用进行数据读取。换句话说，就是NIO中N次的系统调用，借助Select，只需要发起一次系统调用就够了。其IO流程如下所示：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/4/14/17175f198bf13c57?w=706&amp;amp;h=381&amp;amp;f=png&amp;amp;s=93272&quot; alt=&quot;I/O Multiplexing&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是，select有一个限制，就是存在连接数限制，针对于此，又提出了poll。其与select相比，主要是解决了连接限制。&lt;/p&gt;
&lt;p&gt;select/epoll 虽然解决了NIO重复无效系统调用用的问题，但同时又引入了新的问题。问题是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;用户空间和内核空间之间，大量的数据拷贝&lt;/li&gt;
&lt;li&gt;内核循环遍历IO状态，浪费CPU时间&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;换句话说，select/poll虽然减少了用户进程的发起的系统调用，但内核的工作量只增不减。在高并发的情况下，内核的性能问题依旧。所以select/poll的问题本质是：内核存在无效的循环遍历。&lt;/p&gt;
&lt;h2 id=&quot;52-io多路复用之epoll&quot;&gt;5.2. IO多路复用之epoll&lt;/h2&gt;
&lt;p&gt;针对select/pool引入的问题，我们把解决问题的思路转回到内核上，如何减少内核重复无效的循环遍历呢？变主动为被动，基于事件驱动来实现。其流程图如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/4/14/17175f198d29b33a?w=736&amp;amp;h=390&amp;amp;f=png&amp;amp;s=79697&quot; alt=&quot;epoll&quot;/&gt;&lt;/p&gt;
&lt;p&gt;epoll相较于select/poll，多了两次系统调用，其中epoll_create建立与内核的连接，epoll_ctl注册事件，epoll_wait阻塞用户进程，等待IO事件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/4/14/17175f198e87ddcc?w=947&amp;amp;h=344&amp;amp;f=png&amp;amp;s=127285&quot; alt=&quot;select,poll,epoll&quot;/&gt;&lt;/p&gt;
&lt;p&gt;epoll，已经大大优化了IO的执行效率，但在IO执行的第一阶段：数据准备阶段都还是被阻塞的。所以这是一个可以继续优化的点。&lt;/p&gt;

&lt;p&gt;信号驱动IO与BIO和NIO最大的区别就在于，在IO执行的数据准备阶段，不会阻塞用户进程。&lt;br/&gt;如下图所示：当用户进程需要等待数据的时候，会向内核发送一个信号，告诉内核我要什么数据，然后用户进程就继续做别的事情去了，而当内核中的数据准备好之后，内核立马发给用户进程一个信号，说”数据准备好了，快来查收“，用户进程收到信号之后，立马调用recvfrom，去查收数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/4/14/17175f19b6c42f1c?w=684&amp;amp;h=392&amp;amp;f=png&amp;amp;s=76495&quot; alt=&quot;SIGIO&quot;/&gt;&lt;/p&gt;
&lt;p&gt;乍一看，信号驱动式I/O模型有种异步操作的感觉，但是在IO执行的第二阶段，也就是将数据从内核空间复制到用户空间这个阶段，用户进程还是被阻塞的。&lt;/p&gt;
&lt;p&gt;综上，你会发现，不管是BIO还是NIO还是SIGIO，它们最终都会被阻塞在IO执行的第二阶段。&lt;br/&gt;那如果能将IO执行的第二阶段变成非阻塞，那就完美了。&lt;/p&gt;

&lt;p&gt;异步IO真正实现了IO全流程的非阻塞。用户进程发出系统调用后立即返回，内核等待数据准备完成，然后将数据拷贝到用户进程缓冲区，然后发送信号告诉用户进程&lt;strong&gt;IO操作执行完毕&lt;/strong&gt;（与SIGIO相比，一个是发送信号告诉用户进程数据准备完毕，一个是IO执行完毕）。其流程如下：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/4/14/17175f19b8e85e2b?w=651&amp;amp;h=395&amp;amp;f=png&amp;amp;s=64447&quot; alt=&quot;AIO&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以，之所以称为异步IO，取决于IO执行的第二阶段是否阻塞。因此前面讲的BIO，NIO和SIGIO均为同步IO。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/4/14/17175f19bb874153?w=604&amp;amp;h=376&amp;amp;f=png&amp;amp;s=61488&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;梳理完这些IO模型后，之前一直处于懵懂状态的阻塞，非阻塞，同步异步IO，终于算是有个概念了。同时也纠正了自己一直以来的误解，所以一路走来，愈发觉得返璞归真的重要性，只有如此，才能在快速更迭的技术演进中，以不变应万变。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;本文综合多方资料写就，难免纰漏，但只有写下来，才能得以指正。所以，烦请各位看官不吝赐教。&lt;/em&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.jianshu.com/p/fa7bdc4f3de7&quot;&gt;程序员应该这样理解IO&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.jianshu.com/p/511b9cffbdac&quot;&gt;IO复用模型同步，异步，阻塞，非阻塞及实例详解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://juejin.im/post/5ca4c044e51d4565372e47cf&quot;&gt;服务器网络编程之 IO 模型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.c-jump.com/CIS77/CPU/VonNeumann/lecture.html&quot;&gt;http://www.c-jump.com/CIS77/CPU/VonNeumann/lecture.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cllc.fun/2019/03/07/synchronous-asynchronous-io/&quot;&gt;同步I/O(阻塞I/O，非阻塞I/O)，异步I/O&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV11K4y1C7rm?p=2&quot;&gt;马士兵：权威讲解nio,epoll,多路复用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/DLUTBruceZhang/article/details/9050467&quot;&gt;Linux 内核详解以及内核缓冲区技术&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/div&gt;</description>
<pubDate>Tue, 14 Apr 2020 00:06:00 +0000</pubDate>
<dc:creator>「圣杰」</dc:creator>
<og:description>同步异步I/O，阻塞非阻塞I/O是程序员老生常谈的话题了，也是自己一直以来懵懵懂懂的一个话题。比如：何为同步异步？何为阻塞与非阻塞？二者的区别在哪里？阻塞在何处？为什么会有多种IO模型，分别用来解决问</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sheng-jie/p/how-much-you-know-about-io-models.html</dc:identifier>
</item>
<item>
<title>数据源管理 | 动态权限校验，表结构和数据迁移流程 - 知了一笑</title>
<link>http://www.cnblogs.com/cicada-smile/p/12694776.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cicada-smile/p/12694776.html</guid>
<description>&lt;p&gt;本文源码：&lt;a href=&quot;https://github.com/cicadasmile/data-manage-parent&quot;&gt;GitHub·点这里&lt;/a&gt; || &lt;a href=&quot;https://gitee.com/cicadasmile/data-manage-parent&quot;&gt;GitEE·点这里&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;1、场景描述&quot;&gt;1、场景描述&lt;/h2&gt;
&lt;p&gt;如果经常接触数据开发，会有这样一个场景，服务A提供一个数据源，假设称为动态数据源A，需要读取该数据源下的数据；服务B提供一个数据源，假设称为动态数据源B，需要写入数据到该数据源。这个场景通常描述为数据同步，或者数据搬运。&lt;/p&gt;
&lt;h2 id=&quot;2、基本流程&quot;&gt;2、基本流程&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1691717/202004/1691717-20200413230032766-1581411538.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;基于上述流程图，整体步骤如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;测试多个数据源是否连接成功，并动态管理;&lt;/li&gt;
&lt;li&gt;判断数据源提供的账号是否有操作权限，例如读写;&lt;/li&gt;
&lt;li&gt;读取数据源A的表结构，在数据源B创建表;&lt;/li&gt;
&lt;li&gt;数据读取或者分页读取，写入数据源B中;&lt;/li&gt;
&lt;li&gt;在不知道表结构情况下，还需要读取表结构，生成SQL;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;3、jdbc基础api&quot;&gt;3、JDBC基础API&lt;/h2&gt;
&lt;p&gt;Java中JDBC下执行数据库操作的一个重要接口，在已经建立数据库连接的基础上，向数据库发送要执行的SQL语句。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;PreparedStatement&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;继承Statement接口，且实现SQL预编译，可以提高批量处理效率。常应用于批量数据写入场景。&lt;/p&gt;
&lt;p&gt;存储JDBC查询结果集的对象，ResultSet接口提供从当前行检索列值的方法。&lt;/p&gt;

&lt;h2 id=&quot;1、数据源管理&quot;&gt;1、数据源管理&lt;/h2&gt;
&lt;p&gt;提供一个数据源管理的Factory，当前场景下主要管理一个读库即数据源A，和一个写库即数据源B，数据源连接验证通过，放入容器中。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Component
public class ConnectionFactory {

    private volatile Map&amp;lt;String, Connection&amp;gt; connectionMap = new HashMap&amp;lt;&amp;gt;();

    @Resource
    private JdbcConfig jdbcConfig ;

    @PostConstruct
    public void init (){
        ConnectionEntity read = new ConnectionEntity(
        &quot;MySql&quot;,&quot;jdbc:mysql://localhost:3306/data_read&quot;,&quot;user01&quot;,&quot;123&quot;);
        if (jdbcConfig.getConnection(read) != null){
            connectionMap.put(JdbcConstant.READ,jdbcConfig.getConnection(read));
        }
        ConnectionEntity write = new ConnectionEntity(
        &quot;MySql&quot;,&quot;jdbc:mysql://localhost:3306/data_write&quot;,&quot;user01&quot;,&quot;123&quot;);
        if (jdbcConfig.getConnection(write) != null){
            connectionMap.put(JdbcConstant.WRITE,jdbcConfig.getConnection(write));
        }
    }

    public Connection getByKey (final String key){
        return connectionMap.get(key) ;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;2、动态sql拼接&quot;&gt;2、动态SQL拼接&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;基础SQL管理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;主要提供SQL的基础模板，例如全表查，分页查，表结构查询。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class BaseSql {
    public static String READ_SQL = &quot;SELECT * FROM %s LIMIT 1&quot;;
    public static String WRITE_SQL = &quot;INSERT INTO %s (SELECT * FROM %s WHERE 1=0)&quot; ;
    public static String CREATE_SQL = &quot;SHOW CREATE TABLE %s&quot; ;
    public static String SELECT_SQL = &quot;SELECT * FROM %s&quot; ;
    public static String COUNT_SQL = &quot;SELECT COUNT(1) countNum FROM %s&quot; ;
    public static String PAGE_SQL = &quot;SELECT * FROM %s LIMIT %s,%s&quot; ;
    public static String STRUCT_SQL (){
        StringBuffer sql = new StringBuffer() ;
        sql.append(&quot; SELECT                     &quot;);
        sql.append(&quot;     COLUMN_NAME,           &quot;);
        sql.append(&quot;     IS_NULLABLE,           &quot;);
        sql.append(&quot;     COLUMN_TYPE,           &quot;);
        sql.append(&quot;     COLUMN_KEY,            &quot;);
        sql.append(&quot;     COLUMN_COMMENT         &quot;);
        sql.append(&quot; FROM                       &quot;);
        sql.append(&quot; information_schema.COLUMNS &quot;);
        sql.append(&quot; WHERE                      &quot;);
        sql.append(&quot; table_schema = '%s'        &quot;);
        sql.append(&quot; AND table_name = '%s'      &quot;);
        return String.valueOf(sql) ;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;SQL参数拼接&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;根据SQL模板中缺失的参数，进行动态补全，生成完成SQL语句。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class BuildSql {
    /**
     * 读权限SQL
     */
    public static String buildReadSql(String table) {
        String readSql = null ;
        if (StringUtils.isNotEmpty(table)){
            readSql = String.format(BaseSql.READ_SQL, table);
        }
        return readSql;
    }
    /**
     * 读权限SQL
     */
    public static String buildWriteSql(String table){
        String writeSql = null ;
        if (StringUtils.isNotEmpty(table)){
            writeSql = String.format(BaseSql.WRITE_SQL, table,table);
        }
        return writeSql ;
    }
    /**
     * 表创建SQL
     */
    public static String buildStructSql (String table){
        String structSql = null ;
        if (StringUtils.isNotEmpty(table)){
            structSql = String.format(BaseSql.CREATE_SQL, table);
        }
        return structSql ;
    }
    /**
     * 表结构SQL
     */
    public static String buildTableSql (String schema,String table){
        String structSql = null ;
        if (StringUtils.isNotEmpty(table)){
            structSql = String.format(BaseSql.STRUCT_SQL(), schema,table);
        }
        return structSql ;
    }
    /**
     * 全表查询SQL
     */
    public static String buildSelectSql (String table){
        String selectSql = null ;
        if (StringUtils.isNotEmpty(table)){
            selectSql = String.format(BaseSql.SELECT_SQL,table);
        }
        return selectSql ;
    }
    /**
     * 总数查询SQL
     */
    public static String buildCountSql (String table){
        String countSql = null ;
        if (StringUtils.isNotEmpty(table)){
            countSql = String.format(BaseSql.COUNT_SQL,table);
        }
        return countSql ;
    }
    /**
     * 分页查询SQL
     */
    public static String buildPageSql (String table,int offset,int size){
        String pageSql = null ;
        if (StringUtils.isNotEmpty(table)){
            pageSql = String.format(BaseSql.PAGE_SQL,table,offset,size);
        }
        return pageSql ;
    }
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;1、基础鉴权&quot;&gt;1、基础鉴权&lt;/h2&gt;
&lt;p&gt;读库尝试一次单条数据读取，写库尝试一次不成立条件的写入，如果没有权限，会抛出相应异常。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@RestController
public class CheckController {
    @Resource
    private ConnectionFactory connectionFactory ;
    // MySQLSyntaxErrorException: SELECT command denied to user
    @GetMapping(&quot;/checkRead&quot;)
    public String checkRead (){
        try {
            String sql = BuildSql.buildReadSql(&quot;rw_read&quot;) ;
            ExecuteSqlUtil.query(connectionFactory.getByKey(JdbcConstant.READ),sql) ;
            return &quot;success&quot; ;
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return &quot;fail&quot; ;
    }
    // MySQLSyntaxErrorException: INSERT command denied to user
    @GetMapping(&quot;/checkWrite&quot;)
    public String checkWrite (){
        try {
            String sql = BuildSql.buildWriteSql(&quot;rw_read&quot;) ;
            ExecuteSqlUtil.update(connectionFactory.getByKey(JdbcConstant.WRITE),sql) ;
            return &quot;success&quot; ;
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return &quot;fail&quot; ;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;2、同步表结构&quot;&gt;2、同步表结构&lt;/h2&gt;
&lt;p&gt;这里执行最简单操作，把读库表创建语句查询出来，丢到写库中执行。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@RestController
public class StructController {
    @Resource
    private ConnectionFactory connectionFactory ;
    @GetMapping(&quot;/syncStruct&quot;)
    public String syncStruct (){
        try {
            String sql = BuildSql.buildStructSql(&quot;rw_read&quot;) ;
            ResultSet resultSet = ExecuteSqlUtil.query(connectionFactory.getByKey(JdbcConstant.READ),sql) ;
            String createTableSql = null ;
            while (resultSet.next()){
                createTableSql = resultSet.getString(&quot;Create Table&quot;) ;
            }
            if (StringUtils.isNotEmpty(createTableSql)){
                ExecuteSqlUtil.update(connectionFactory.getByKey(JdbcConstant.WRITE),createTableSql) ;
            }
            return &quot;success&quot; ;
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return &quot;fail&quot; ;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;3、同步表数据&quot;&gt;3、同步表数据&lt;/h2&gt;
&lt;p&gt;读库的表数据读取，批量放入写库中。这里特别说一个方法：statement.setObject();在不知道参数个数和类型时，自动适配数据类型。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@RestController
public class DataSyncController {
    @Resource
    private ConnectionFactory connectionFactory ;
    @GetMapping(&quot;/dataSync&quot;)
    public List&amp;lt;RwReadEntity&amp;gt; dataSync (){
        List&amp;lt;RwReadEntity&amp;gt; rwReadEntities = new ArrayList&amp;lt;&amp;gt;() ;
        try {
            Connection readConnection = connectionFactory.getByKey(JdbcConstant.READ) ;
            String sql = BuildSql.buildSelectSql(&quot;rw_read&quot;) ;
            ResultSet resultSet = ExecuteSqlUtil.query(readConnection,sql) ;
            while (resultSet.next()){
                RwReadEntity rwReadEntity = new RwReadEntity() ;
                rwReadEntity.setId(resultSet.getInt(&quot;id&quot;));
                rwReadEntity.setSign(resultSet.getString(&quot;sign&quot;));
                rwReadEntities.add(rwReadEntity) ;
            }
            if (rwReadEntities.size() &amp;gt; 0){
                Connection writeConnection = connectionFactory.getByKey(JdbcConstant.WRITE) ;
                writeConnection.setAutoCommit(false);
                PreparedStatement statement = writeConnection.prepareStatement(&quot;INSERT INTO rw_read VALUES(?,?)&quot;);
                // 基于动态获取列，和statement.setObject();自动适配数据类型
                for (int i = 0 ; i &amp;lt; rwReadEntities.size() ; i++){
                    RwReadEntity rwReadEntity = rwReadEntities.get(i) ;
                    statement.setInt(1,rwReadEntity.getId()) ;
                    statement.setString(2,rwReadEntity.getSign()) ;
                    statement.addBatch();
                    if (i&amp;gt;0 &amp;amp;&amp;amp; i%2==0){
                        statement.executeBatch() ;
                    }
                }
                // 处理最后一批数据
                statement.executeBatch();
                writeConnection.commit();
            }
            return rwReadEntities ;
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return null ;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;4、分页查询&quot;&gt;4、分页查询&lt;/h2&gt;
&lt;p&gt;提供一个分页查询工具，在数据量大的情况下不能一次性读取大量的数据，避免资源占用过高。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class PageUtilEntity {
    /**
     * 分页生成方法
     */
    public static PageHelperEntity&amp;lt;Object&amp;gt; pageResult (int total, int pageSize,int currentPage, List dataList){
        PageHelperEntity&amp;lt;Object&amp;gt; pageBean = new PageHelperEntity&amp;lt;Object&amp;gt;();
        // 总页数
        int totalPage = PageHelperEntity.countTotalPage(pageSize,total) ;
        // 分页列表
        List&amp;lt;Integer&amp;gt; pageList = PageHelperEntity.pageList(currentPage,pageSize,total) ;
        // 上一页
        int prevPage = 0 ;
        if (currentPage==1){
            prevPage = currentPage ;
        } else if (currentPage&amp;gt;1&amp;amp;&amp;amp;currentPage&amp;lt;=totalPage){
            prevPage = currentPage -1 ;
        }
        // 下一页
        int nextPage =0 ;
        if (totalPage==1){
            nextPage = currentPage ;
        } else if (currentPage&amp;lt;=totalPage-1){
            nextPage = currentPage+1 ;
        }
        pageBean.setDataList(dataList);
        pageBean.setTotal(total);
        pageBean.setPageSize(pageSize);
        pageBean.setCurrentPage(currentPage);
        pageBean.setTotalPage(totalPage);
        pageBean.setPageList(pageList);
        pageBean.setPrevPage(prevPage);
        pageBean.setNextPage(nextPage);
        pageBean.initjudge();
        return  pageBean ;
    }
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;很多复杂度偏高的业务，越是需要借助基础API解决，因为复杂度高，不容易抽象化统一封装，如果数据同步这块业务，可以适配多种数据库，完全可以独立封装为中间件，开源项目中关于多方数据同步或计算的中间件也有好多，可以自行了解下，增长眼界开阔思路。&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;GitHub·地址
https://github.com/cicadasmile/data-manage-parent
GitEE·地址
https://gitee.com/cicadasmile/data-manage-parent
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1691717/201908/1691717-20190823075428183-1996768914.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 13 Apr 2020 23:47:00 +0000</pubDate>
<dc:creator>知了一笑</dc:creator>
<og:description>本文源码： &amp;quot;GitHub&amp;#183;点这里&amp;quot; || &amp;quot;GitEE&amp;#183;点这里&amp;quot; 一、数据同步简介 1、场景描述 如果经常接触数据开发，会有这样一个场景，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cicada-smile/p/12694776.html</dc:identifier>
</item>
<item>
<title>【高并发】你知道吗？大家都在使用Redisson实现分布式锁了！！ - 冰河团队</title>
<link>http://www.cnblogs.com/binghe001/p/12695168.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/binghe001/p/12695168.html</guid>
<description>&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;忘记之前在哪个群里有朋友在问：有出分布式锁的文章吗～@冰河？我的回答是：这周会有，也是【高并发】专题的。想了想，还是先发一个如何使用Redisson实现分布式锁的文章吧？为啥？因为使用Redisson实现分布式锁简单啊！Redisson框架是基于Redis实现的分布式锁，非常强大，只需要拿来使用就行了，至于分布式锁的原理啥的，后面再撸一篇文章就是了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Redisson框架十分强大，基于Redisson框架可以实现几乎你能想到的所有类型的分布式锁。这里，我就列举几个类型的分布式锁，并各自给出一个示例程序来加深大家的理解。有关分布式锁的原理细节，后续专门撸一篇文章咱们慢慢聊！&lt;/p&gt;
&lt;h2 id=&quot;1可重入锁（reentrant-lock）&quot;&gt;1.可重入锁（Reentrant Lock）&lt;/h2&gt;
&lt;p&gt;Redisson的分布式可重入锁RLock Java对象实现了java.util.concurrent.locks.Lock接口，同时还支持自动过期解锁。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void testReentrantLock(RedissonClient redisson){
        RLock lock = redisson.getLock(&quot;anyLock&quot;);
        try{
                // 1. 最常见的使用方法
                //lock.lock();
                // 2. 支持过期解锁功能,10秒钟以后自动解锁, 无需调用unlock方法手动解锁
                //lock.lock(10, TimeUnit.SECONDS);
                // 3. 尝试加锁，最多等待3秒，上锁以后10秒自动解锁
                boolean res = lock.tryLock(3, 10, TimeUnit.SECONDS);
                if(res){ //成功
                // do your business
                }
        } catch (InterruptedException e) {
                e.printStackTrace();
        } finally {
                lock.unlock();
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Redisson同时还为分布式锁提供了异步执行的相关方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void testAsyncReentrantLock(RedissonClient redisson){
        RLock lock = redisson.getLock(&quot;anyLock&quot;);
        try{
                lock.lockAsync();
                lock.lockAsync(10, TimeUnit.SECONDS);
                Future&amp;lt;Boolean&amp;gt; res = lock.tryLockAsync(3, 10, TimeUnit.SECONDS);
                if(res.get()){
                // do your business
                }
        } catch (InterruptedException e) {
                e.printStackTrace();
        } catch (ExecutionException e) {
                e.printStackTrace();
        } finally {
                lock.unlock();
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;2公平锁（fair-lock）&quot;&gt;2.公平锁（Fair Lock）&lt;/h2&gt;
&lt;p&gt;Redisson分布式可重入公平锁也是实现了java.util.concurrent.locks.Lock接口的一种RLock对象。在提供了自动过期解锁功能的同时，保证了当多个Redisson客户端线程同时请求加锁时，优先分配给先发出请求的线程。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void testFairLock(RedissonClient redisson){
        RLock fairLock = redisson.getFairLock(&quot;anyLock&quot;);
        try{
                // 最常见的使用方法
                fairLock.lock();
                // 支持过期解锁功能, 10秒钟以后自动解锁,无需调用unlock方法手动解锁
                fairLock.lock(10, TimeUnit.SECONDS);
                // 尝试加锁，最多等待100秒，上锁以后10秒自动解锁
                boolean res = fairLock.tryLock(100, 10, TimeUnit.SECONDS);
        } catch (InterruptedException e) {
                e.printStackTrace();
        } finally {
                fairLock.unlock();
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Redisson同时还为分布式可重入公平锁提供了异步执行的相关方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;RLock fairLock = redisson.getFairLock(&quot;anyLock&quot;);
fairLock.lockAsync();
fairLock.lockAsync(10, TimeUnit.SECONDS);
Future&amp;lt;Boolean&amp;gt; res = fairLock.tryLockAsync(100, 10, TimeUnit.SECONDS);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;3联锁（multilock）&quot;&gt;3.联锁（MultiLock）&lt;/h2&gt;
&lt;p&gt;Redisson的RedissonMultiLock对象可以将多个RLock对象关联为一个联锁，每个RLock对象实例可以来自于不同的Redisson实例。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void testMultiLock(RedissonClient redisson1,RedissonClient redisson2, RedissonClient redisson3){
        RLock lock1 = redisson1.getLock(&quot;lock1&quot;);
        RLock lock2 = redisson2.getLock(&quot;lock2&quot;);
        RLock lock3 = redisson3.getLock(&quot;lock3&quot;);
        RedissonMultiLock lock = new RedissonMultiLock(lock1, lock2, lock3);
        try {
                // 同时加锁：lock1 lock2 lock3, 所有的锁都上锁成功才算成功。
                lock.lock();
                // 尝试加锁，最多等待100秒，上锁以后10秒自动解锁
                boolean res = lock.tryLock(100, 10, TimeUnit.SECONDS);
        } catch (InterruptedException e) {
                e.printStackTrace();
        } finally {
                lock.unlock();
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;4红锁（redlock）&quot;&gt;4.红锁（RedLock）&lt;/h2&gt;
&lt;p&gt;Redisson的RedissonRedLock对象实现了Redlock介绍的加锁算法。该对象也可以用来将多个RLock对象关联为一个红锁，每个RLock对象实例可以来自于不同的Redisson实例。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void testRedLock(RedissonClient redisson1,RedissonClient redisson2, RedissonClient redisson3){
        RLock lock1 = redisson1.getLock(&quot;lock1&quot;);
        RLock lock2 = redisson2.getLock(&quot;lock2&quot;);
        RLock lock3 = redisson3.getLock(&quot;lock3&quot;);
        RedissonRedLock lock = new RedissonRedLock(lock1, lock2, lock3);
        try {
                // 同时加锁：lock1 lock2 lock3, 红锁在大部分节点上加锁成功就算成功。
                lock.lock();
                // 尝试加锁，最多等待100秒，上锁以后10秒自动解锁
                boolean res = lock.tryLock(100, 10, TimeUnit.SECONDS);
        } catch (InterruptedException e) {
                e.printStackTrace();
        } finally {
                lock.unlock();
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;5读写锁（readwritelock）&quot;&gt;5.读写锁（ReadWriteLock）&lt;/h2&gt;
&lt;p&gt;Redisson的分布式可重入读写锁RReadWriteLock,Java对象实现了java.util.concurrent.locks.ReadWriteLock接口。同时还支持自动过期解锁。该对象允许同时有多个读取锁，但是最多只能有一个写入锁。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;RReadWriteLock rwlock = redisson.getLock(&quot;anyRWLock&quot;);
// 最常见的使用方法
rwlock.readLock().lock();
// 或
rwlock.writeLock().lock();
// 支持过期解锁功能
// 10秒钟以后自动解锁
// 无需调用unlock方法手动解锁
rwlock.readLock().lock(10, TimeUnit.SECONDS);
// 或
rwlock.writeLock().lock(10, TimeUnit.SECONDS);
// 尝试加锁，最多等待100秒，上锁以后10秒自动解锁
boolean res = rwlock.readLock().tryLock(100, 10, TimeUnit.SECONDS);
// 或
boolean res = rwlock.writeLock().tryLock(100, 10, TimeUnit.SECONDS);
...
lock.unlock();
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;6信号量（semaphore）&quot;&gt;6.信号量（Semaphore）&lt;/h2&gt;
&lt;p&gt;Redisson的分布式信号量（Semaphore）Java对象RSemaphore采用了与java.util.concurrent.Semaphore相似的接口和用法。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;RSemaphore semaphore = redisson.getSemaphore(&quot;semaphore&quot;);
semaphore.acquire();
//或
semaphore.acquireAsync();
semaphore.acquire(23);
semaphore.tryAcquire();
//或
semaphore.tryAcquireAsync();
semaphore.tryAcquire(23, TimeUnit.SECONDS);
//或
semaphore.tryAcquireAsync(23, TimeUnit.SECONDS);
semaphore.release(10);
semaphore.release();
//或
semaphore.releaseAsync();
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;7可过期性信号量（permitexpirablesemaphore）&quot;&gt;7.可过期性信号量（PermitExpirableSemaphore）&lt;/h2&gt;
&lt;p&gt;Redisson的可过期性信号量（PermitExpirableSemaphore）实在RSemaphore对象的基础上，为每个信号增加了一个过期时间。每个信号可以通过独立的ID来辨识，释放时只能通过提交这个ID才能释放。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;RPermitExpirableSemaphore semaphore = redisson.getPermitExpirableSemaphore(&quot;mySemaphore&quot;);
String permitId = semaphore.acquire();
// 获取一个信号，有效期只有2秒钟。
String permitId = semaphore.acquire(2, TimeUnit.SECONDS);
// ...
semaphore.release(permitId);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;8闭锁（countdownlatch）&quot;&gt;8.闭锁（CountDownLatch）&lt;/h2&gt;
&lt;p&gt;Redisson的分布式闭锁（CountDownLatch）Java对象RCountDownLatch采用了与java.util.concurrent.CountDownLatch相似的接口和用法。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;RCountDownLatch latch = redisson.getCountDownLatch(&quot;anyCountDownLatch&quot;);
latch.trySetCount(1);
latch.await();
// 在其他线程或其他JVM里
RCountDownLatch latch = redisson.getCountDownLatch(&quot;anyCountDownLatch&quot;);
latch.countDown();
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;写在最后&quot;&gt;写在最后&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果觉得文章对你有点帮助，请微信搜索并关注「 &lt;strong&gt;冰河技术&lt;/strong&gt; 」微信公众号，跟冰河学习高并发编程技术。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最后，附上并发编程需要掌握的核心技能知识图，祝大家在学习并发编程时，少走弯路。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200414000106354.jpg&quot; alt=&quot;sandahexin_20200322&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 13 Apr 2020 16:04:00 +0000</pubDate>
<dc:creator>冰河团队</dc:creator>
<og:description>写在前面 忘记之前在哪个群里有朋友在问：有出分布式锁的文章吗～@冰河？我的回答是：这周会有，也是【高并发】专题的。想了想，还是先发一个如何使用Redisson实现分布式锁的文章吧？为啥？因为使用Red</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/binghe001/p/12695168.html</dc:identifier>
</item>
<item>
<title>浅谈 PCA与SVD - pxzheng</title>
<link>http://www.cnblogs.com/pxzheng/p/12690150.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pxzheng/p/12690150.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;在用数据对模型进行训练时，通常会遇到维度过高，也就是数据的特征太多的问题，有时特征之间还存在一定的相关性，这时如果还使用原数据训练模型，模型的精度会大大下降，因此要降低数据的维度，同时新数据的特征之间还要保持线性无关，这样的方法称为主成分分析（Principal component analysis，PCA），新数据的特征称为主成分，得到主成分的方法有两种：直接对协方差矩阵进行特征值分解和对数据矩阵进行奇异值分解（SVD）。&lt;/p&gt;
&lt;h2 id=&quot;一、主成分分析基本思想&quot;&gt;一、主成分分析基本思想&lt;/h2&gt;
&lt;p&gt;  &lt;strong&gt;数据X由n个特征降维到k个特征，这k个特征保留最大信息（方差）。&lt;/strong&gt;对原坐标系中的数据进行主成分分析等价于进行坐标系的旋转变化，将数据投影到新的坐标系下，新坐标系的第一坐标轴表示第一主成分，第二坐标轴表示第二主成分，以此类推。数据在每一轴上的坐标值的平方表示相应变量的方差，PCA的目标就是方差最大的变量，才能保留尽可能多的信息，因为方差越大，表示数据分散程度越大，所包含的信息也就越多。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1983544/202004/1983544-20200413161906681-951415965.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;二、pca的基本步骤&quot;&gt;二、PCA的基本步骤&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;step1：对数据进行规范化（也称为标准化），因为涉及距离计算，因此要消除量纲的影响；&lt;br/&gt;这里的数据标准化采用z-score：X = X - mean(X) / std(X)&lt;/li&gt;
&lt;li&gt;step2：对数据X进行旋转变化（前言提到的两种方法）&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;三、数学推导&quot;&gt;三、数学推导&lt;/h2&gt;
&lt;p&gt;  假设X是m*n的矩阵，&lt;span class=&quot;math inline&quot;&gt;\(x_k\)&lt;/span&gt;是投影前的数据(k=1,2,…,n)，&lt;span class=&quot;math inline&quot;&gt;\(x_k^{'}\)&lt;/span&gt;是投影后的数据，e是新的坐标轴。投影长度&lt;span class=&quot;math inline&quot;&gt;\(α_k=e^tx_k\)&lt;/span&gt;，可以将&lt;span class=&quot;math inline&quot;&gt;\(e^t\)&lt;/span&gt;看成是cosθ，新数据&lt;span class=&quot;math inline&quot;&gt;\(x_k^{'}\)&lt;/span&gt;在新坐标轴e下的坐标为&lt;span class=&quot;math inline&quot;&gt;\(α_k e\)&lt;/span&gt;，表示从原点出发，沿着e方向走了&lt;span class=&quot;math inline&quot;&gt;\(α_k\)&lt;/span&gt;距离。根据方差最大的原则，即&lt;span class=&quot;math inline&quot;&gt;\(α_k\)&lt;/span&gt;要最大，由勾股定理&lt;span class=&quot;math inline&quot;&gt;\(\alpha_k^2+\left \| x_kx_k{'}\right \|^2=\left\|o x_k\right\|^2\)&lt;/span&gt;可知，当&lt;span class=&quot;math inline&quot;&gt;\(α_k\)&lt;/span&gt;最大时，&lt;span class=&quot;math inline&quot;&gt;\(\left\|x_kx_k^{'}\right\|^2\)&lt;/span&gt;要最小，因此转换成求&lt;span class=&quot;math inline&quot;&gt;\(\left\|x_kx_k^{'}\right\|^2\)&lt;/span&gt;最小，约束条件是&lt;span class=&quot;math inline&quot;&gt;\(\left\|e\right\|=1\)&lt;/span&gt;，数学表达式为：&lt;/p&gt;
&lt;p&gt;\[\begin{cases} min J(e)=\sum_{i=1}^n\left\|x_k^{'}-x_k\right\|^2\\ s.t. \left\|e\right\|=1 \end{cases} \]&lt;/p&gt;
&lt;h3 id=&quot;1-完整的数学推导（结合第一部分的图）&quot;&gt;1. 完整的数学推导（结合第一部分的图）&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(min J(e)\\ =\sum_{i=1}^n\left\|x_k^{'}-x_k\right\|^2\\ =\sum_{i=1}^n\left\|\alpha_ke-x_k\right\|^2\\ =\sum_{i=1}^n\alpha_k^2\left\|e\right\|^2 - 2\sum_{i=1}^n\alpha_ke^tx_k + \sum_{i=1}^n\left\|x_k\right\|^2\\ =\sum_{i=1}^n\alpha_k^2-2\sum_{i=1}^n\alpha_k^2+\sum_{i=1}^n\left\|x_k\right\|^2\\ =-\sum_{i=1}^n\alpha_k^2+\sum_{i=1}^n\left\|x_k\right\|^2\\ =-\sum_{i=1}^ne^tx_kx_k^te+\sum_{i=1}^n\left\|x_k\right\|^2\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;要使&lt;span class=&quot;math inline&quot;&gt;\(-\sum_{i=1}^ne^tx_kx_k^te+\sum_{i=1}^n\left\|x_k\right\|^2\)&lt;/span&gt;最小，由于&lt;span class=&quot;math inline&quot;&gt;\(\sum_{i=1}^n\left\|x_k\right\|^2\)&lt;/span&gt;不包含e，因为转换为求&lt;span class=&quot;math inline&quot;&gt;\(\sum_{i=1}^ne^tx_kx_k^te\)&lt;/span&gt;的最大值，同时记&lt;span class=&quot;math inline&quot;&gt;\(S=\sum_{i=1}^nx_kx_k^t\)&lt;/span&gt;，实际上，S是协方差X的协方差矩阵，问题可转化为&lt;/p&gt;
&lt;p&gt;\[\begin{cases} max\quad e^tSe\\ s.t. \quad \left\|e\right\|=1 \end{cases} \]&lt;/p&gt;
&lt;p&gt;对于上述优化问题，可以用拉格朗日乘子法求解：&lt;span class=&quot;math inline&quot;&gt;\(u=e^tSe-\lambda(e^te-1),\frac{\partial u}{\partial e} = 2Se-2\lambda e=0\)&lt;/span&gt;，解得：&lt;span class=&quot;math inline&quot;&gt;\(Se = \lambda e\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;可以看出，满足条件的投影方向e(k个)是协方差矩阵S的前k大特征值对应的特征向量，因此PCA转化为求数据X的协方差矩阵的特征值，将特征值降序排序，对应的特征向量构成的矩阵就是所求的旋转矩阵&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-求旋转矩阵&quot;&gt;2. 求旋转矩阵&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;基于特征值求解&lt;/li&gt;
&lt;li&gt;基于奇异值分解SVD&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;21-基于特征值求解&quot;&gt;2.1 基于特征值求解&lt;/h4&gt;
&lt;p&gt;  就是一般的矩阵求特征值和特征向量的问题，此处不做详细介绍，需要注意的是，是对数据X的协方差矩阵&lt;span class=&quot;math inline&quot;&gt;\(X^TX\)&lt;/span&gt;求特征值和特征向量，前k个特征向量构成的矩阵P（此处默认P已经按照特征值的大小顺序进行排列，维度为n*k），那么新数据&lt;span class=&quot;math inline&quot;&gt;\(newX = X*P\)&lt;/span&gt;,则newX由X的&lt;span class=&quot;math inline&quot;&gt;\(m*n\)&lt;/span&gt;变成&lt;span class=&quot;math inline&quot;&gt;\(m*k(k&amp;lt;n)\)&lt;/span&gt;，此时数据已经降低维度了。&lt;/p&gt;
&lt;h4 id=&quot;22-基于svd求解pca&quot;&gt;2.2 基于SVD求解PCA&lt;/h4&gt;

&lt;h3 id=&quot;31-什么是奇异值分解&quot;&gt;3.1 什么是奇异值分解&lt;/h3&gt;
&lt;p&gt;  对于任意的矩阵&lt;span class=&quot;math inline&quot;&gt;\(A\in\mathbb{R}^{m*n}\)&lt;/span&gt;，都可以将A分解成三个矩阵：&lt;/p&gt;
&lt;p&gt;\[A=U\sum V^T,U\in\mathbb{R}^{m*m},\sum\in\mathbb{R}^{m*n},V\in\mathbb{R}^{n*n} \]&lt;/p&gt;
&lt;p&gt;并且U和V是正交阵，&lt;span class=&quot;math inline&quot;&gt;\(\sum\)&lt;/span&gt;是对角阵,即&lt;/p&gt;
&lt;p&gt;\[UU^T=UU^{-1}=I,VV^T=VV^{-1}=I \]&lt;/p&gt;
&lt;h3 id=&quot;32-奇异值分解的几何解释&quot;&gt;3.2 奇异值分解的几何解释&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1983544/202004/1983544-20200413220716413-1320734277.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  本质上来说，奇异值分解是一个线性变换，对矩阵A进行奇异值分解可以看成是用一组正交基先进行旋转&lt;span class=&quot;math inline&quot;&gt;\((V^T e)\)&lt;/span&gt;，再进行坐标缩放&lt;span class=&quot;math inline&quot;&gt;\((\sum V^T e)\)&lt;/span&gt;，最后再进行坐标旋转&lt;span class=&quot;math inline&quot;&gt;\((U\sum V^T e)\)&lt;/span&gt;，经过这三步操作，正交基可以变换成A，下面是一个简单的例子，用MATLAB可以对任意矩阵进行奇异值分解，并且输出三个矩阵。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1983544/202004/1983544-20200413181803074-696374178.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;33-如何求解&quot;&gt;3.3 如何求解&lt;span class=&quot;math inline&quot;&gt;\(U,\sum,V^T\)&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;  (&lt;em&gt;以下由于编辑问题，会出现几个&lt;span class=&quot;math inline&quot;&gt;\(\sum^T\)&lt;/span&gt;的T出现在&lt;span class=&quot;math inline&quot;&gt;\(\sum\)&lt;/span&gt;上面&lt;/em&gt;)&lt;/p&gt;
&lt;p&gt;  对于任意的矩阵都能进行因子分解，这显然是SVD最大的好处，但关键是如何求解三个因子矩阵呢？&lt;/p&gt;
&lt;h4 id=&quot;331-求解u&quot;&gt;3.3.1 求解U&lt;/h4&gt;
&lt;p&gt;已知&lt;span class=&quot;math inline&quot;&gt;\(A=U\sum V^T\)&lt;/span&gt;,则有&lt;/p&gt;
&lt;p&gt;\[AA^T=(U\sum V^T)(U\sum V^T)^T=U\sum V^TV\sum^TU^T=U(\sum\sum^T)U^T \]&lt;/p&gt;
&lt;p&gt;又因为U是正交阵，因此有&lt;/p&gt;
&lt;p&gt;\[U^T=U^{-1},AA^T=U(\sum\sum^T)U^{-1} \]&lt;/p&gt;
&lt;p&gt;左右各乘以&lt;span class=&quot;math inline&quot;&gt;\(U^{-1}\)&lt;/span&gt;，可以得到&lt;/p&gt;
&lt;p&gt;\[AA^TU=U(\sum\sum^T) \]&lt;/p&gt;
&lt;p&gt;也就是U是矩阵&lt;span class=&quot;math inline&quot;&gt;\(AA^T\)&lt;/span&gt;的特征向量，&lt;span class=&quot;math inline&quot;&gt;\((\sum\sum^T)\)&lt;/span&gt;是特征值。&lt;/p&gt;
&lt;h4 id=&quot;332-求解v&quot;&gt;3.3.2 求解V&lt;/h4&gt;
&lt;p&gt;与求解U类似，通过&lt;span class=&quot;math inline&quot;&gt;\(AA^T\)&lt;/span&gt;来求解，最终可以得到&lt;/p&gt;
&lt;p&gt;\[A^TAV=V(\sum^T\sum) \]&lt;/p&gt;
&lt;p&gt;也就是V是矩阵&lt;span class=&quot;math inline&quot;&gt;\(A^TA\)&lt;/span&gt;的特征向量，&lt;span class=&quot;math inline&quot;&gt;\((\sum^T\sum)\)&lt;/span&gt;是特征值&lt;/p&gt;
&lt;h4 id=&quot;333-对角矩阵&quot;&gt;3.3.3 对角矩阵&lt;span class=&quot;math inline&quot;&gt;\(\sum\)&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(\sum\)&lt;/span&gt;里的元素成为奇异值，从3.3.1和3.3.2可以看出，对角矩阵&lt;span class=&quot;math inline&quot;&gt;\(\sum\)&lt;/span&gt;的奇异值是&lt;span class=&quot;math inline&quot;&gt;\(AA^T\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(A^TA\)&lt;/span&gt;的特征值的平方根，并且奇异值一定不小于0.以下是简单的证明：&lt;br/&gt;令&lt;span class=&quot;math inline&quot;&gt;\(\lambda\)&lt;/span&gt;是&lt;span class=&quot;math inline&quot;&gt;\(A^TA\)&lt;/span&gt;的一个特征值，x是对应的特征向量，则&lt;/p&gt;
&lt;p&gt;\[\left\|Ax\right\|^2=x^TA^TAx=\lambda x^Tx=\lambda\left\|x\right\|^2 \]&lt;/p&gt;
&lt;p&gt;\[\lambda=\frac{\left\|Ax\right\|^2}{\left\|x\right\|^2}\geq0 \]&lt;/p&gt;
&lt;p&gt;而奇异值&lt;span class=&quot;math inline&quot;&gt;\(\sigma\)&lt;/span&gt;是&lt;span class=&quot;math inline&quot;&gt;\(\lambda\)&lt;/span&gt;的平方根，因此也大于等于0.&lt;/p&gt;
&lt;h4 id=&quot;334-svd与pca的关系&quot;&gt;3.3.4 SVD与PCA的关系&lt;/h4&gt;
&lt;p&gt;PCA的目标是求协方差矩阵&lt;span class=&quot;math inline&quot;&gt;\(X^TX\)&lt;/span&gt;的特征向量和特征值，而协方差矩阵的特征向量就是矩阵X奇异值分解后的右奇异向量V,用下图来说明PCA与SVD的关系&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1983544/202004/1983544-20200413232505560-2114818320.jpg&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;因此，经过PCA处理得到的新数据，&lt;strong&gt;其实就是对数据X做奇异值分解，然后乘上右奇异矩阵，或者左奇异矩阵乘上对角矩阵！&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;四、总结&quot;&gt;四、总结&lt;/h2&gt;
&lt;p&gt;  PCA是一种降维技术，主要用在特征提取。对于PCA，有两种方式：直接对数据的协方差矩阵进行特征向量的求解；对数据进行奇异值分解。实际上，后者会更优于前者。因为求解协方差矩阵的特征值以及特征向量时，有时会出现特征值为虚数，那么这时候算法会失效，而SVD求解出来的奇异值一定是非负数。除此之外，其实可以把PCA看做是对SVD的一种包装，如果实现了SVD，那么PCA也就实现了，而且更好的是，用SVD可以得到两个方向的PCA，而直接分解协方差矩阵，只能得到一个方向的PCA。&lt;/p&gt;
</description>
<pubDate>Mon, 13 Apr 2020 15:44:00 +0000</pubDate>
<dc:creator>pxzheng</dc:creator>
<og:description>前言 在用数据对模型进行训练时，通常会遇到维度过高，也就是数据的特征太多的问题，有时特征之间还存在一定的相关性，这时如果还使用原数据训练模型，模型的精度会大大下降，因此要降低数据的维度，同时新数据的特</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/pxzheng/p/12690150.html</dc:identifier>
</item>
<item>
<title>Prism+MaterialDesign+EntityFramework Core+Postgresql WPF开发总结 之 终极篇 - 走遍江湖</title>
<link>http://www.cnblogs.com/lixiaobin/p/wpfdevreport.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lixiaobin/p/wpfdevreport.html</guid>
<description>&lt;p&gt;总共分三个部分：基础篇主要争对C#初学者，巩固C#常用知识点；中级篇主要争对WPF布局与MaterialDesign美化设计，在减轻代码量的情况做出漂亮的应用；终极篇为框架应用实战，包含系统分层逻辑、MVVM框架Prism安装与使用、ORM框架EntityFramework Core配置与使用、开源数据库Postgresql配置与使用。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;211.15012061607&quot;&gt;
&lt;p&gt; 本着每天记录一点成长一点的原则，打算将目前完成的一个WPF项目相关的技术分享出来，供团队学习与总结。&lt;/p&gt;
&lt;p&gt;总共分三个部分：&lt;/p&gt;
&lt;p&gt;基础篇主要针对C#初学者，巩固C#常用知识点；&lt;/p&gt;
&lt;p&gt;中级篇主要针对WPF布局与MaterialDesign美化设计，在减轻代码量的情况做出漂亮的应用；&lt;/p&gt;
&lt;p&gt;终极篇为框架应用实战，包含系统分层、MVVM框架Prism安装与使用、ORM框架EntityFramework Core配置与使用、开源数据库Postgresql配置与使用。&lt;/p&gt;
&lt;h3&gt;目录&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/lixiaobin/p/wpfdevreportBasic.html&quot;&gt;Prism+MaterialDesign+EntityFramework Core+Postgresql WPF开发总结 之 基础篇&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/lixiaobin/p/wpfdevreportdesign.html&quot;&gt;Prism+MaterialDesign+EntityFramework Core+Postgresql WPF开发总结 之 中级篇&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/lixiaobin/p/wpfdevreport.html&quot;&gt;Prism+MaterialDesign+EntityFramework Core+Postgresql WPF开发总结 之 终极篇&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 class=&quot;pgc-h-arrow-right&quot; data-pm-slice=&quot;1 1 []&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;此篇主要介绍系统分层模型、如何安装Prism快速开发模板与MVVM框架使用、如何配置ORM框架Entity Framework Core与使用、以及Postgresql数据库配置。&lt;/p&gt;
&lt;h3&gt;系统分层&lt;/h3&gt;
&lt;p&gt;项目比较简单，大概分层模型如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;View双向绑定ViewModel；&lt;/li&gt;
&lt;li&gt;ViewModel调用Service取得DataModel业务数据；&lt;/li&gt;
&lt;li&gt;Service通过调用Repository取得Entity数据；&lt;/li&gt;
&lt;li&gt;Repository调用Entity Framework Core，自动创建Sql执行并返回Entity对象；&lt;/li&gt;
&lt;li&gt;Entity Framework Core通过驱动链接数据库。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/319628/202004/319628-20200413151058945-1599158260.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果项目功能或者对接端末比较多，最好扩展成微服务。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/319628/202004/319628-20200413182515864-194500206.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;MVVM框架之Prism&lt;/h3&gt;
&lt;p&gt;MVVM（&lt;span lang=&quot;en&quot;&gt;Model–view–viewmodel）&lt;/span&gt;是微软的WPF和Silverlight架构师之一John Gossman于2005年发布的软件架构模式。目的就是把用户界面设计与业务逻辑开发分离，方便团队开发和自动化测试。目前流行的Android开发、Web开发都在使用，具体MVVM的介绍参照个人博客：&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/lixiaobin/p/MVVMPattern.html&quot;&gt;核心框架MVVM与MVC、MVP的区别(图文详解)&lt;/a&gt;。&lt;/p&gt;
&lt;h4&gt;一、无框架的MVVM实现&lt;/h4&gt;
&lt;p&gt;设计与逻辑分离的基本就是绑定，通过发布者订阅者模式实现数据更新通知。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、属性绑定&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;默认属性为单向绑定，如果需要双向绑定需要实现INotifyPropertyChanged接口。&lt;/p&gt;
&lt;p&gt;第一步：一般是建立如下基类。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('ee21a414-5f61-4fc6-b0c6-a2b946c863f7')&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_ee21a414-5f61-4fc6-b0c6-a2b946c863f7&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_ee21a414-5f61-4fc6-b0c6-a2b946c863f7&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('ee21a414-5f61-4fc6-b0c6-a2b946c863f7',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_ee21a414-5f61-4fc6-b0c6-a2b946c863f7&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.ComponentModel;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Runtime.CompilerServices;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; MvvmDemo.Common
{
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Viewmodel基类，属性双向绑定基础
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ViewModelBase : INotifyPropertyChanged
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;event&lt;/span&gt;&lt;span&gt; PropertyChangedEventHandler PropertyChanged;

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 属性变更通知
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;propertyName&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;属性名&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; NotifyPropertyChanged([CallerMemberName] String propertyName = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (PropertyChanged != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                PropertyChanged(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PropertyChangedEventArgs(propertyName));
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;第二步：各个ViewModel继承基类。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('7c37273c-7c25-4e4b-8527-363e0a7308c5')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_7c37273c-7c25-4e4b-8527-363e0a7308c5&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_7c37273c-7c25-4e4b-8527-363e0a7308c5&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('7c37273c-7c25-4e4b-8527-363e0a7308c5',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_7c37273c-7c25-4e4b-8527-363e0a7308c5&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserViewModel : ViewModelBase
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; _userId;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; _userName;

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 用户名
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; UserId
        {
            &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _userId;
            }

            &lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;
            {
                _userId &lt;/span&gt;=&lt;span&gt; value;
                NotifyPropertyChanged();
            }
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 用户名
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; UserName
        {
            &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _userName;
            }

            &lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;
            {
                _userName &lt;/span&gt;=&lt;span&gt; value;
                NotifyPropertyChanged();
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;第三步：Xaml绑定属性，实现消息通知。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('3c4d85a8-1c11-4d52-87e3-47dd5dc1c515')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_3c4d85a8-1c11-4d52-87e3-47dd5dc1c515&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_3c4d85a8-1c11-4d52-87e3-47dd5dc1c515&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('3c4d85a8-1c11-4d52-87e3-47dd5dc1c515',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_3c4d85a8-1c11-4d52-87e3-47dd5dc1c515&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextBox &lt;/span&gt;&lt;span&gt;Text&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{Binding UserID,Mode=TwoWay}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextBox &lt;/span&gt;&lt;span&gt;Grid.Row&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt; Text&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{Binding UserName,Mode=OneWay}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;备注：通过IValueConverter可以做一些特殊绑定处理。比如，经典的就是Bool值控制Visibility。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('236dea49-0977-4b23-b0bc-32571efe76b4')&quot; readability=&quot;36.5&quot;&gt;&lt;img id=&quot;code_img_closed_236dea49-0977-4b23-b0bc-32571efe76b4&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_236dea49-0977-4b23-b0bc-32571efe76b4&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('236dea49-0977-4b23-b0bc-32571efe76b4',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_236dea49-0977-4b23-b0bc-32571efe76b4&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;68&quot;&gt;
&lt;pre&gt;
    [ValueConversion(&lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;bool&lt;/span&gt;), &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(Visibility))]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BoolToVisibiltyConverter : MarkupExtension, IValueConverter
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; Convert(&lt;span&gt;object&lt;/span&gt; value, Type targetType, &lt;span&gt;object&lt;/span&gt;&lt;span&gt; parameter, CultureInfo culture)
        {
            &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; flag = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (value &lt;span&gt;is&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt;)
            {
                flag &lt;/span&gt;= (&lt;span&gt;bool&lt;/span&gt;&lt;span&gt;)value;
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (value &lt;span&gt;is&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;?&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt;? nullable = (&lt;span&gt;bool&lt;/span&gt;?&lt;span&gt;)value;
                flag &lt;/span&gt;= nullable.HasValue ? nullable.Value : &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (flag ?&lt;span&gt; Visibility.Visible : Visibility.Collapsed);

        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; ConvertBack(&lt;span&gt;object&lt;/span&gt; value, Type targetType, &lt;span&gt;object&lt;/span&gt;&lt;span&gt; parameter, CultureInfo culture)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; value;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt; ProvideValue(IServiceProvider serviceProvider)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;Xaml绑定：头部需要引入命名空间。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
xmlns:converter=&quot;clr-namespace:WpfMvvm.Core.Converters&quot;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('3af653f5-9dc0-4ac5-8bc3-43113aeadbe6')&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_3af653f5-9dc0-4ac5-8bc3-43113aeadbe6&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_3af653f5-9dc0-4ac5-8bc3-43113aeadbe6&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('3af653f5-9dc0-4ac5-8bc3-43113aeadbe6',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_3af653f5-9dc0-4ac5-8bc3-43113aeadbe6&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button
            &lt;/span&gt;&lt;span&gt;Grid.Row&lt;/span&gt;&lt;span&gt;=&quot;2&quot;&lt;/span&gt;&lt;span&gt;
            Visibility&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{Binding ShowFlg,Converter={converter:BoolToVisibiltyConverter}}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
            Command&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{Binding AddCmd}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
            Content&lt;/span&gt;&lt;span&gt;=&quot;登录&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2、事件绑定&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;WPF提供了Command事件处理属性，想利用控件中的Command属性需要实现了ICommand接口的属性。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('6c155581-c678-4164-a628-ca0d651236a6')&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_6c155581-c678-4164-a628-ca0d651236a6&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_6c155581-c678-4164-a628-ca0d651236a6&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('6c155581-c678-4164-a628-ca0d651236a6',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_6c155581-c678-4164-a628-ca0d651236a6&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Input;

namespace MvvmDemo.Common
{
    public class DelegateCommand&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;T&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;: ICommand
    {
        /// &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;summary&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        /// 命令
        /// &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;summary&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        private Action&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;T&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt; _Command;
        /// &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;summary&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        /// 命令可否执行判断
        /// &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;summary&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        private Func&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;T&lt;/span&gt;&lt;span&gt;, bool&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt; _CanExecute;
        /// &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;summary&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        /// 可执行判断结束后通知命令执行
        /// &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;summary&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        public event EventHandler CanExecuteChanged;

        /// &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;summary&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        /// 构造函数
        /// &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;summary&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        /// &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;command&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;命令&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        public DelegateCommand(Action&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;T&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt; command):this(command,null)
        {
        }

        /// &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;summary&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        /// 构造函数
        /// &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;summary&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        /// &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;command&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;命令&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        /// &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;canexecute&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;命令可执行判断&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        public DelegateCommand(Action&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;T&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; command,Func&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;T&lt;/span&gt;&lt;span&gt;,bool&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt; canexecute)
        {
            if(command==null)
            {
                throw new ArgumentException(&quot;command&quot;);
            }
            _Command = command;
            _CanExecute = canexecute;
        }

        /// &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;summary&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        /// 命令执行判断
        /// &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;summary&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        /// &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;parameter&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;判断数据&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        /// &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;returns&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;判定结果（True：可执行，False：不可执行）&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;returns&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        public bool CanExecute(object parameter)
        {
            return _CanExecute == null ? true : _CanExecute((T)parameter);
        }

        /// &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;summary&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        /// 执行命令
        /// &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;summary&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        /// &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;parameter&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;参数&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        public void Execute(object parameter)
        {
            _Command((T)parameter);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;使用它作为事件属性的类型就可以了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('7bf47641-abb8-4796-8080-f1c23c92fa57')&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_7bf47641-abb8-4796-8080-f1c23c92fa57&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_7bf47641-abb8-4796-8080-f1c23c92fa57&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('7bf47641-abb8-4796-8080-f1c23c92fa57',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_7bf47641-abb8-4796-8080-f1c23c92fa57&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 登陆命令
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; DelegateCommand&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; LoginCommand =&amp;gt; &lt;span&gt;new&lt;/span&gt; DelegateCommand&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;(
                        s &lt;/span&gt;=&amp;gt;&lt;span&gt;
                        {
                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; todo&lt;/span&gt;
&lt;span&gt;                        },
                        s &lt;/span&gt;=&amp;gt; !&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(s)
                        );&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h4&gt;二、Prism的MVVM实现&lt;/h4&gt;
&lt;p&gt;至于Prism有很多种理由让我选择它，比如：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;支持MVVM(Binding、Notification、Command等)、微软成员维护&lt;/li&gt;
&lt;li&gt;支持Unity和DryIoc两种IOC容器&lt;/li&gt;
&lt;li&gt;支持WPF、UWP、Xamarin.Froms开发&lt;/li&gt;
&lt;li&gt;封装界面跳转&lt;/li&gt;
&lt;li&gt;封装弹出消息框&lt;/li&gt;
&lt;li&gt;自带项目模板与快速开发代码片段&lt;/li&gt;
&lt;li&gt;创建View时自动创建ViewModel&lt;/li&gt;
&lt;li&gt;默认自动绑定ViewModel到View&lt;/li&gt;
&lt;li&gt;...等等&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;1、配置Prism&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最简单的方法：安装Prism Template Pack扩展包。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/319628/202004/319628-20200413153507068-593389296.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、使用Prism&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过Prism项目模板创建项目，目前可以创建WPF(.Net Framework和.Net Core)、UWP、Xamarin.Froms等应用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/319628/202004/319628-20200413154138490-1963283970.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 以前支持四种容器，现在只支持两种IOC容器：Unity、DryIoc。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/319628/202004/319628-20200413154248792-1156946909.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;*备注：如果通过Prism模板创建项目时出现以下错误：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/319628/202004/319628-20200409115424653-209074600.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是因为Autofac已经不被支持。解决办法：regedit进入注册表HKEY_CURRENT_USER\Software\Prism，把SelectedContainer删除或者改成Unity。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/319628/202004/319628-20200409115613484-730836778.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;生成的解决方案如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/319628/202004/319628-20200413154619889-1585594266.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 亮点：解决方案中自动设置了ViewModel的IOC配置，MainWindow.xaml中ViewModel的绑定也自动设置了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/319628/202004/319628-20200413154910493-21286179.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 下面通过建立一个简单的局部界面跳转实例，体验一把Prism的高效率：cmd、propp、vs智能提示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/319628/202004/319628-20200413162134303-1426990356.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; Prism包提供的代码片段如下，要好好加以利用：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/319628/202004/319628-20200413163425182-1870447670.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 此次项目还用到了以下特性：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.1 Region Navigation&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;局部页面跳转：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;传递对象参数；&lt;/li&gt;
&lt;li&gt;跳转前确认；&lt;/li&gt;
&lt;li&gt;自定义如何处理已经显示过的页面（覆盖与否）；&lt;/li&gt;
&lt;li&gt;通过&lt;span class=&quot;pl-en&quot;&gt;IRegionNavigationJournal接口可以操作页面跳转履历（返回与前进等）&lt;/span&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如上例所示简单应用。&lt;/p&gt;
&lt;p&gt;第一步：标识显示位置。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ContentControl &lt;/span&gt;&lt;span&gt;prism:RegionManager.RegionName&lt;/span&gt;&lt;span&gt;=&quot;ContentRegion&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第二步：在App.xaml.cs注册跳转页面。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('76a40253-c84e-40c8-a75f-3f972d61cfc7')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_76a40253-c84e-40c8-a75f-3f972d61cfc7&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_76a40253-c84e-40c8-a75f-3f972d61cfc7&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('76a40253-c84e-40c8-a75f-3f972d61cfc7',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_76a40253-c84e-40c8-a75f-3f972d61cfc7&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;partial&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; App
    {
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;span&gt; Window CreateShell()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Container.Resolve&amp;lt;MainWindow&amp;gt;&lt;span&gt;();
        }

        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; RegisterTypes(IContainerRegistry containerRegistry)
        {
            containerRegistry.RegisterForNavigation&lt;/span&gt;&amp;lt;PageTwo, PageTwoViewModel&amp;gt;&lt;span&gt;();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;第三步：使用IRegionManager实现跳转。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 指定需要显示的页面名字与显示位置的ContentControl的名字&lt;/span&gt;
_manager.RequestNavigate(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ContentRegion&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;PageTwo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2.2、Modules&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果系统功能比较多最好进行分块处理，如下面订单和用户信息的分块处理。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/319628/202004/319628-20200413170700305-981547030.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;App.xaml.cs中统一各个模块数据。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('870f270e-3bcf-4dbc-a5ee-9431502585b3')&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_870f270e-3bcf-4dbc-a5ee-9431502585b3&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_870f270e-3bcf-4dbc-a5ee-9431502585b3&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('870f270e-3bcf-4dbc-a5ee-9431502585b3',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_870f270e-3bcf-4dbc-a5ee-9431502585b3&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ModuleLoader会把各个模块的IOC依赖注入数据汇总共有管理&lt;/span&gt;
        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureModuleCatalog(IModuleCatalog moduleCatalog)
        {
            moduleCatalog.AddModule&lt;/span&gt;&amp;lt;OrderModule&amp;gt;&lt;span&gt;();
            moduleCatalog.AddModule&lt;/span&gt;&amp;lt;CustomerModule&amp;gt;&lt;span&gt;();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;各个Module里面还是一样，使用到的所有Service和Repository都注册，使用IOC容器进行生命周期管理。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('a8778a0a-5068-48d9-b14f-2cc550671004')&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_a8778a0a-5068-48d9-b14f-2cc550671004&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_a8778a0a-5068-48d9-b14f-2cc550671004&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('a8778a0a-5068-48d9-b14f-2cc550671004',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_a8778a0a-5068-48d9-b14f-2cc550671004&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OrderModule : IModule
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnInitialized(IContainerProvider containerProvider)
        {

        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; RegisterTypes(IContainerRegistry containerRegistry)
        {
            containerRegistry.RegisterForNavigation&lt;/span&gt;&amp;lt;MainWin&amp;gt;&lt;span&gt;(PageDefine.Order);
            containerRegistry.Register&lt;/span&gt;&amp;lt;ISearchService, SearchService&amp;gt;&lt;span&gt;();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2.3、Dialog Service&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;自定义消息弹出框，比如警告、错误、提示等消息框。&lt;/p&gt;
&lt;p&gt;第一步：自定义消息框控件，ViewModel继承IDialogAware接口并实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('8fe6aa07-95be-4c6d-8484-fe5ecdff9151')&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_8fe6aa07-95be-4c6d-8484-fe5ecdff9151&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_8fe6aa07-95be-4c6d-8484-fe5ecdff9151&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('8fe6aa07-95be-4c6d-8484-fe5ecdff9151',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_8fe6aa07-95be-4c6d-8484-fe5ecdff9151&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; NotificationDialogViewModel : BindableBase, IDialogAware
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; DelegateCommand&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; _closeDialogCommand;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DelegateCommand&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; CloseDialogCommand =&amp;gt;&lt;span&gt;
            _closeDialogCommand &lt;/span&gt;?? (_closeDialogCommand = &lt;span&gt;new&lt;/span&gt; DelegateCommand&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;(CloseDialog));

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; _message;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; Message
        {
            &lt;/span&gt;&lt;span&gt;get&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; _message; }
            &lt;/span&gt;&lt;span&gt;set&lt;/span&gt; { SetProperty(&lt;span&gt;ref&lt;/span&gt;&lt;span&gt; _message, value); }
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; _title = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Notification&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; Title
        {
            &lt;/span&gt;&lt;span&gt;get&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; _title; }
            &lt;/span&gt;&lt;span&gt;set&lt;/span&gt; { SetProperty(&lt;span&gt;ref&lt;/span&gt;&lt;span&gt; _title, value); }
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;event&lt;/span&gt; Action&amp;lt;IDialogResult&amp;gt;&lt;span&gt; RequestClose;

        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; CloseDialog(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; parameter)
        {
            ButtonResult result &lt;/span&gt;=&lt;span&gt; ButtonResult.None;

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (parameter?.ToLower() == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                result &lt;/span&gt;=&lt;span&gt; ButtonResult.OK;
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (parameter?.ToLower() == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                result &lt;/span&gt;=&lt;span&gt; ButtonResult.Cancel;

            RaiseRequestClose(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; DialogResult(result));
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; RaiseRequestClose(IDialogResult dialogResult)
        {
            RequestClose&lt;/span&gt;?&lt;span&gt;.Invoke(dialogResult);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; CanCloseDialog()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnDialogClosed()
        {

        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnDialogOpened(IDialogParameters parameters)
        {
            Message &lt;/span&gt;= parameters.GetValue&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;message&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;第二步：App.xaml.cs中注册自定义的消息框，从而覆盖默认的消息框：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('9e48c7a7-0a07-45c8-b42e-51b5084633d2')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_9e48c7a7-0a07-45c8-b42e-51b5084633d2&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_9e48c7a7-0a07-45c8-b42e-51b5084633d2&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('9e48c7a7-0a07-45c8-b42e-51b5084633d2',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_9e48c7a7-0a07-45c8-b42e-51b5084633d2&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;partial&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; App
    {
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;span&gt; Window CreateShell()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Container.Resolve&amp;lt;MainWindow&amp;gt;&lt;span&gt;();
        }

        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; RegisterTypes(IContainerRegistry containerRegistry)
        {
            containerRegistry.RegisterDialog&lt;/span&gt;&amp;lt;NotificationDialog, NotificationDialogViewModel&amp;gt;&lt;span&gt;();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;第三步：通过IDialogService使用消息框：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('53685e7c-1b72-4b96-862e-8d19bc805ac1')&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_53685e7c-1b72-4b96-862e-8d19bc805ac1&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_53685e7c-1b72-4b96-862e-8d19bc805ac1&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('53685e7c-1b72-4b96-862e-8d19bc805ac1',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_53685e7c-1b72-4b96-862e-8d19bc805ac1&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ShowDialog()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; message = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;This is a message that should be shown in the dialog.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;using the dialog service as-is&lt;/span&gt;
            _dialogService.ShowDialog(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;NotificationDialog&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; DialogParameters($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;message={message}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), r =&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (r.Result ==&lt;span&gt; ButtonResult.None)
                    Title &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Result is None&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (r.Result ==&lt;span&gt; ButtonResult.OK)
                    Title &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Result is OK&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (r.Result ==&lt;span&gt; ButtonResult.Cancel)
                    Title &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Result is Cancel&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                    Title &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;I Don't know what you did!?&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            });
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;第四步：定义消息框显示属性：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('360e5a4f-bf6a-462a-9e99-ae3215ca6134')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_360e5a4f-bf6a-462a-9e99-ae3215ca6134&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_360e5a4f-bf6a-462a-9e99-ae3215ca6134&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('360e5a4f-bf6a-462a-9e99-ae3215ca6134',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_360e5a4f-bf6a-462a-9e99-ae3215ca6134&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;prism:Dialog.WindowStyle&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Style &lt;/span&gt;&lt;span&gt;TargetType&lt;/span&gt;&lt;span&gt;=&quot;Window&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Setter &lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;=&quot;prism:Dialog.WindowStartupLocation&quot;&lt;/span&gt;&lt;span&gt; Value&lt;/span&gt;&lt;span&gt;=&quot;CenterScreen&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Setter &lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;=&quot;ResizeMode&quot;&lt;/span&gt;&lt;span&gt; Value&lt;/span&gt;&lt;span&gt;=&quot;NoResize&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Setter &lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;=&quot;ShowInTaskbar&quot;&lt;/span&gt;&lt;span&gt; Value&lt;/span&gt;&lt;span&gt;=&quot;False&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Setter &lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;=&quot;SizeToContent&quot;&lt;/span&gt;&lt;span&gt; Value&lt;/span&gt;&lt;span&gt;=&quot;WidthAndHeight&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;prism:Dialog.WindowStyle&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/319628/202004/319628-20200413173745448-1058277559.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其他用法可以参照Prism开源库：&lt;a href=&quot;https://github.com/PrismLibrary/Prism&quot;&gt;https://github.com/PrismLibrary/Prism&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Entity Framework Core + Postgresql&lt;/h3&gt;
&lt;p&gt;EntityFrameworkCore：是对象关系映射(ORM)程序，支持语言集成查询Linq，是轻量、可扩展、开源跨平台的数据访问框架。下一个5.0版本将与.NET 5.0一起发布。EntityFrameworkCore只支持CodeFirst，EntityFramework支持DB First和Code First。之所以选择EFCore是因为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;支持CodeFirst&lt;/li&gt;
&lt;li&gt;支持Linq&lt;/li&gt;
&lt;li&gt;双向映射（linq映射成sql，结果集映射成对象）&lt;/li&gt;
&lt;li&gt;速度很快&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;PostgreSQL：是开源先进的对象-关系型数据库管理系统（ORDBMS），有些特性甚至连商业数据库都不具备。支持JSON数据存储，表之间还可以继承。&lt;/p&gt;
&lt;h4&gt;一、配置EFCore与PostgreSQL&lt;/h4&gt;
&lt;p&gt;※PostgreSQL安装参照个人博客：&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/lixiaobin/p/winsowspostgresql.html&quot;&gt;【Windows】PostgreSql安装&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;1、引入针对PostgreSQL的EFCore包&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/319628/202004/319628-20200413201033866-649241036.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、添加DB操作上下文&lt;/p&gt;
&lt;p&gt;数据库链接替换为你的链接，一般都是放配置文件管理。&lt;/p&gt;
&lt;p&gt;添加Users字段，通过EFCore将自动创建Users表。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('19516570-3a3e-4f2c-8cb0-d321022f5708')&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_19516570-3a3e-4f2c-8cb0-d321022f5708&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_19516570-3a3e-4f2c-8cb0-d321022f5708&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('19516570-3a3e-4f2c-8cb0-d321022f5708',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_19516570-3a3e-4f2c-8cb0-d321022f5708&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.EntityFrameworkCore;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; WpfMccm.Entitys;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; WpfMvvm.DataAccess
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserDbContext : DbContext
    {
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnConfiguring(DbContextOptionsBuilder optionsBuilder)
        {
            optionsBuilder.UseNpgsql(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Server=127.0.0.1;Database=HBMCS;Port=5432;User Id=test;Password=test;Ssl Mode=Prefer;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                     npgsqlOptionsAction: options &lt;/span&gt;=&amp;gt;&lt;span&gt;
                     {
                         options.CommandTimeout(&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;&lt;span&gt;);
                         options.EnableRetryOnFailure(maxRetryCount: &lt;/span&gt;&lt;span&gt;5&lt;/span&gt;, maxRetryDelay: TimeSpan.FromSeconds(&lt;span&gt;30&lt;/span&gt;), errorCodesToAdd: &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
                     });
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DbSet&amp;lt;User&amp;gt; Users { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;3、安装Microsoft.EntityFrameworkCore.Tools工具&lt;/p&gt;
&lt;p&gt;CodeFirst必备神器。进入程序包管理器控制台，输入以下命名安装EFCore设计工具：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;※必须安装在启动项目里面，不然会失败。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Install-Package Microsoft.EntityFrameworkCore.Tools
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/319628/202004/319628-20200413211219624-165237032.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 4、创建Migration&lt;/p&gt;
&lt;p&gt;程序包管理器控制台，默认项目&lt;span&gt;一定要选择DB操作上下文的项目&lt;/span&gt;，然后执行命令：InitDB是文件区分，可以任意修改。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
Add-Migration InitDB
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行成功之后，生成带InitDB区分的表定义数据文件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/319628/202004/319628-20200413215506010-213596107.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 6、生成数据库脚本（生产阶段用，开发阶段可跳过）&lt;/p&gt;
&lt;p&gt;程序包管理器控制台，执行如下命令生成SQL脚本文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
Script-Migration
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('9f320b71-225a-4e09-840b-363387f9a12d')&quot; readability=&quot;36&quot;&gt;&lt;img id=&quot;code_img_closed_9f320b71-225a-4e09-840b-363387f9a12d&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_9f320b71-225a-4e09-840b-363387f9a12d&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('9f320b71-225a-4e09-840b-363387f9a12d',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_9f320b71-225a-4e09-840b-363387f9a12d&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; &lt;span&gt;IF&lt;/span&gt; &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;EXISTS&lt;/span&gt;&lt;span&gt; &quot;__EFMigrationsHistory&quot; (
    &quot;MigrationId&quot; &lt;/span&gt;&lt;span&gt;character&lt;/span&gt; &lt;span&gt;varying&lt;/span&gt;(&lt;span&gt;150&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
    &quot;ProductVersion&quot; &lt;/span&gt;&lt;span&gt;character&lt;/span&gt; &lt;span&gt;varying&lt;/span&gt;(&lt;span&gt;32&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;CONSTRAINT&lt;/span&gt; &quot;PK___EFMigrationsHistory&quot; &lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt;&lt;span&gt; (&quot;MigrationId&quot;)
);

&lt;/span&gt;&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt; &quot;Users&quot; (
    &quot;ID&quot; &lt;/span&gt;&lt;span&gt;integer&lt;/span&gt; &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; GENERATED &lt;span&gt;BY&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;IDENTITY&lt;/span&gt;&lt;span&gt;,
    &quot;Name&quot; &lt;/span&gt;&lt;span&gt;text&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
    &quot;Age&quot; &lt;/span&gt;&lt;span&gt;integer&lt;/span&gt; &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;CONSTRAINT&lt;/span&gt; &quot;PK_Users&quot; &lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt;&lt;span&gt; (&quot;ID&quot;)
);

&lt;/span&gt;&lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt;&lt;span&gt; &quot;__EFMigrationsHistory&quot; (&quot;MigrationId&quot;, &quot;ProductVersion&quot;)
&lt;/span&gt;&lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;20200413133616_InitDB&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;3.1.3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;如果系统已经上线，安全起见则需要使用这个方法生成SQL脚本，手动执行SQL更新数据库。&lt;/p&gt;
&lt;p&gt;7、更新数据库（开发阶段用）&lt;/p&gt;
&lt;p&gt;程序包管理器控制台，执行如下命令将表定义更新到DB（按文件名的时间顺顺添加）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
Update-Database
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样我们就通过类创建了一个数据库表&lt;span&gt;Users&lt;/span&gt;，同时默认会在&lt;span&gt;__EFMigrationsHistory&lt;/span&gt;履历表添加一条合并记录。&lt;/p&gt;
&lt;p&gt;※如果__EFMigrationsHistory中记录存在则忽略本次更新。&lt;/p&gt;
&lt;h4&gt;二、使用DB上下文操作数据库&lt;/h4&gt;
&lt;p&gt;1、创建IRepository，DB操作基本接口&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('f4637a12-8804-4cbd-91ce-1e8362bf421e')&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_f4637a12-8804-4cbd-91ce-1e8362bf421e&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_f4637a12-8804-4cbd-91ce-1e8362bf421e&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('f4637a12-8804-4cbd-91ce-1e8362bf421e',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_f4637a12-8804-4cbd-91ce-1e8362bf421e&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; IRepository&amp;lt;TEntity&amp;gt; &lt;span&gt;where&lt;/span&gt; TEntity : &lt;span&gt;class&lt;/span&gt;&lt;span&gt;
    {
        Task&lt;/span&gt;&amp;lt;TEntity&amp;gt; GetAsync(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id);
        Task&lt;/span&gt;&amp;lt;&lt;span&gt;bool&lt;/span&gt;&amp;gt;&lt;span&gt; AddAsync(TEntity obj);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;2、创建UserRepository，User专用的DB操作类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('8d0263ae-5e04-4b7a-8342-84bd2910dcd5')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_8d0263ae-5e04-4b7a-8342-84bd2910dcd5&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_8d0263ae-5e04-4b7a-8342-84bd2910dcd5&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('8d0263ae-5e04-4b7a-8342-84bd2910dcd5',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_8d0263ae-5e04-4b7a-8342-84bd2910dcd5&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; UserRepository : IRepository&amp;lt;User&amp;gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; DbContext _dbContext;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; DbSet&amp;lt;User&amp;gt;&lt;span&gt; _dbSet;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; UserRepository(UserDbContext dbContext)
        {
            _dbContext &lt;/span&gt;=&lt;span&gt; dbContext;
            _dbSet &lt;/span&gt;= dbContext.Set&amp;lt;User&amp;gt;&lt;span&gt;();
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;&lt;span&gt;bool&lt;/span&gt;&amp;gt;&lt;span&gt; AddAsync(User obj)
        {
            _dbSet.Add(obj);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;await&lt;/span&gt; _dbContext.SaveChangesAsync() &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;User&amp;gt; GetAsync(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;await&lt;/span&gt;&lt;span&gt; _dbSet.FindAsync(id);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;如果需要进行事务操作，可以使用下面方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('01ef6dee-b6e0-4ad6-9026-3273e521e7a6')&quot; readability=&quot;31&quot;&gt;&lt;img id=&quot;code_img_closed_01ef6dee-b6e0-4ad6-9026-3273e521e7a6&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_01ef6dee-b6e0-4ad6-9026-3273e521e7a6&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('01ef6dee-b6e0-4ad6-9026-3273e521e7a6',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_01ef6dee-b6e0-4ad6-9026-3273e521e7a6&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
           &lt;span&gt;var&lt;/span&gt; tran=&lt;span&gt; _dbContext.Database.BeginTransaction();
           tran.Commit();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;3、Service层调用UserRepository就可以完成用户的操作。&lt;/p&gt;
&lt;h3&gt;总结&lt;/h3&gt;
&lt;p&gt;此篇量稍微有点多，非常感谢能看到这里。整体来说Prism简化了应用的设计与架构，EFCore简化了数据库操作。&lt;/p&gt;

&lt;/div&gt;</description>
<pubDate>Mon, 13 Apr 2020 15:17:00 +0000</pubDate>
<dc:creator>走遍江湖</dc:creator>
<og:description>总共分三个部分：基础篇主要争对C#初学者，巩固C#常用知识点；中级篇主要争对WPF布局与MaterialDesign美化设计，在减轻代码量的情况做出漂亮的应用；终极篇为框架应用实战，包含系统分层逻辑、</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lixiaobin/p/wpfdevreport.html</dc:identifier>
</item>
<item>
<title>原来rollup这么简单之插件篇 - 小雨小雨丶</title>
<link>http://www.cnblogs.com/xiaoyuxy/p/12694566.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaoyuxy/p/12694566.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;大家好，我是小雨小雨，致力于分享有趣的、实用的技术文章。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;内容分为翻译和原创，如果有问题，欢迎随时评论或私信，希望和大家一起进步。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;大家的支持是我创作的动力。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;计划&quot;&gt;计划&lt;/h4&gt;
&lt;p&gt;rollup系列打算一章一章的放出，内容更精简更专一更易于理解&lt;/p&gt;
&lt;p&gt;这是rollup系列的最后一篇文章，以下是所有文章链接。&lt;/p&gt;
&lt;h4 id=&quot;tldr&quot;&gt;TL;DR&lt;/h4&gt;
&lt;p&gt;rollup的插件和其他大型框架大同小异，都是提供统一的标准接口，通过约定大于配置定义公共配置，注入当前构建结果相关的属性与方法，供开发者进行增删改查操作。为稳定可持续增长提供了强而有力的铺垫！&lt;/p&gt;
&lt;p&gt;但不想webpack区分loader和plugin，rollup的plugin既可以担任loader的角色，也可以胜任传统plugin的角色。rollup提供的钩子函数是核心，比如load、transform对chunk进行解析更改，resolveFileUrl可以对加载模块进行合法解析，options对配置进行动态更新等等~&lt;/p&gt;
&lt;h4 id=&quot;注意点&quot;&gt;注意点&lt;/h4&gt;
&lt;blockquote readability=&quot;4.3333333333333&quot;&gt;
&lt;p&gt;所有的注释都在&lt;a href=&quot;https://github.com/FoxDaxian/rollup-analysis&quot;&gt;这里&lt;/a&gt;，可自行阅读&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;!!!提示 =&amp;gt; 标有TODO为具体实现细节，会视情况分析。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;!!!注意 =&amp;gt; 每一个子标题都是父标题(函数)内部实现&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;!!!强调 =&amp;gt; rollup中模块(文件)的id就是文件地址，所以类似resolveID这种就是解析文件地址的意思，我们可以返回我们想返回的文件id(也就是地址，相对路径、决定路径)来让rollup加载&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8.2941176470588&quot;&gt;
&lt;p&gt;rollup是一个核心，只做最基础的事情，比如提供&lt;a href=&quot;https://github.com/FoxDaxian/rollup-analysis/blob/master/src/utils/defaultPlugin.ts#L6&quot;&gt;默认模块(文件)加载机制&lt;/a&gt;, 比如打包成不同风格的内容，我们的插件中提供了加载文件路径，解析文件内容(处理ts，sass等)等操作，是一种插拔式的设计，和webpack类似&lt;br/&gt;插拔式是一种非常灵活且可长期迭代更新的设计，这也是一个中大型框架的核心，人多力量大嘛~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;主要通用模块以及含义&quot;&gt;主要通用模块以及含义&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;Graph: 全局唯一的图，包含入口以及各种依赖的相互关系，操作方法，缓存等。是rollup的核心&lt;/li&gt;
&lt;li&gt;PathTracker: 引用(调用)追踪器&lt;/li&gt;
&lt;li&gt;PluginDriver: 插件驱动器，调用插件和提供插件环境上下文等&lt;/li&gt;
&lt;li&gt;FileEmitter: 资源操作器&lt;/li&gt;
&lt;li&gt;GlobalScope: 全局作用局，相对的还有局部的&lt;/li&gt;
&lt;li&gt;ModuleLoader: 模块加载器&lt;/li&gt;
&lt;li&gt;NodeBase: ast各语法(ArrayExpression、AwaitExpression等)的构造基类&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;插件机制分析&quot;&gt;插件机制分析&lt;/h4&gt;
&lt;p&gt;rollup的插件其实一个普通的函数，函数返回一个对象，该对象包含一些基础属性(如name)，和不同阶段的钩子函数，像这个样子:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;function plugin(options = {}) {
  return {
    name: 'rollup-plugin',
    transform() {
      return {
        code: 'code',
        map: { mappings: '' }
      };
    }
  };
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里是官方建议遵守的&lt;a href=&quot;https://rollupjs.org/guide/en/#conventions&quot;&gt;约定&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;我们平常书写rollup插件的时候，最关注的就是钩子函数部分了，钩子函数的调用时机有三类:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;const chunks = rollup.rollup执行期间的&lt;a href=&quot;https://rollupjs.org/guide/en/#build-hooks&quot;&gt;Build Hooks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;chunks.generator(write)执行期间的&lt;a href=&quot;https://rollupjs.org/guide/en/#output-generation-hooks&quot;&gt;Output Generation Hooks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;监听文件变化并重新执行构建的rollup.watch执行期间的watchChange钩子函数&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;除了类别不同，rollup也提供了几种&lt;a href=&quot;https://github.com/FoxDaxian/rollup-analysis/blob/master/src/utils/PluginDriver.ts&quot;&gt;钩子函数&lt;/a&gt;的执行方式，每种方式都又分为同步或异步，方便内部使用：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;async: 处理promise的异步钩子，也有同步版本&lt;/li&gt;
&lt;li&gt;first: 如果多个插件实现了相同的钩子函数，那么会串式执行，从头到尾，但是，如果其中某个的返回值不是null也不是undefined的话，会直接终止掉后续插件。&lt;/li&gt;
&lt;li&gt;sequential: 如果多个插件实现了相同的钩子函数，那么会串式执行，按照使用插件的顺序从头到尾执行，如果是异步的，会等待之前处理完毕，在执行下一个插件。&lt;/li&gt;
&lt;li&gt;parallel: 同上，不过如果某个插件是异步的，其后的插件不会等待，而是并行执行。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;文字表达比较苍白，咱们看几个实现：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;钩子函数: hookFirst&lt;br/&gt;使用场景：resolveId、resolveAssetUrl等&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;function hookFirst&amp;lt;H extends keyof PluginHooks, R = ReturnType&amp;lt;PluginHooks[H]&amp;gt;&amp;gt;(
    hookName: H,
    args: Args&amp;lt;PluginHooks[H]&amp;gt;,
    replaceContext?: ReplaceContext | null,
    skip?: number | null
): EnsurePromise&amp;lt;R&amp;gt; {
    // 初始化promise
    let promise: Promise&amp;lt;any&amp;gt; = Promise.resolve();
    // this.plugins在初始化Graph的时候，进行了初始化
    for (let i = 0; i &amp;lt; this.plugins.length; i++) {
        if (skip === i) continue;
        // 覆盖之前的promise，换言之就是串行执行钩子函数
        promise = promise.then((result: any) =&amp;gt; {
            // 返回非null或undefined的时候，停止运行，返回结果
            if (result != null) return result;
            // 执行钩子函数
            return this.runHook(hookName, args as any[], i, false, replaceContext);
        });
    }
    // 最后一个promise执行的结果
    return promise;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;钩子函数: hookFirstSync&lt;br/&gt;使用场景：resolveFileUrl、resolveImportMeta等&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;// hookFirst的同步版本，也就是并行执行
function hookFirstSync&amp;lt;H extends keyof PluginHooks, R = ReturnType&amp;lt;PluginHooks[H]&amp;gt;&amp;gt;(
    hookName: H,
    args: Args&amp;lt;PluginHooks[H]&amp;gt;,
    replaceContext?: ReplaceContext
): R {
    for (let i = 0; i &amp;lt; this.plugins.length; i++) {
        // runHook的同步版本
        const result = this.runHookSync(hookName, args, i, replaceContext);
        // 返回非null或undefined的时候，停止运行，返回结果
        if (result != null) return result as any;
    }
    // 否则返回null
    return null as any;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;钩子函数: hookSeq&lt;br/&gt;使用场景：onwrite、generateBundle等&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;// 和hookFirst的区别就是不能中断
async function hookSeq&amp;lt;H extends keyof PluginHooks&amp;gt;(
    hookName: H,
    args: Args&amp;lt;PluginHooks[H]&amp;gt;,
    replaceContext?: ReplaceContext
): Promise&amp;lt;void&amp;gt; {
    let promise: Promise&amp;lt;void&amp;gt; = Promise.resolve();
    for (let i = 0; i &amp;lt; this.plugins.length; i++)
        promise = promise.then(() =&amp;gt;
            this.runHook&amp;lt;void&amp;gt;(hookName, args as any[], i, false, replaceContext)
        );
    return promise;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;钩子函数: hookParallel&lt;br/&gt;使用场景：buildStart、buildEnd、renderStart等&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;// 同步进行，利用的Promise.all
function hookParallel&amp;lt;H extends keyof PluginHooks&amp;gt;(
    hookName: H,
    args: Args&amp;lt;PluginHooks[H]&amp;gt;,
    replaceContext?: ReplaceContext
): Promise&amp;lt;void&amp;gt; {
    // 创建promise.all容器
    const promises: Promise&amp;lt;void&amp;gt;[] = [];
    // 遍历每一个plugin
    for (let i = 0; i &amp;lt; this.plugins.length; i++) {
        // 执行hook返回promise
        const hookPromise = this.runHook&amp;lt;void&amp;gt;(hookName, args as any[], i, false, replaceContext);
        // 如果没有那么不push
        if (!hookPromise) continue;
        promises.push(hookPromise);
    }
    // 返回promise
    return Promise.all(promises).then(() =&amp;gt; {});
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;钩子函数: hookReduceArg0&lt;br/&gt;使用场景: outputOptions、renderChunk等&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;// 对arg第一项进行reduce操作
function hookReduceArg0&amp;lt;H extends keyof PluginHooks, V, R = ReturnType&amp;lt;PluginHooks[H]&amp;gt;&amp;gt;(
    hookName: H,
    [arg0, ...args]: any[], // 取出传入的数组的第一个参数，将剩余的置于一个数组中
    reduce: Reduce&amp;lt;V, R&amp;gt;,
    replaceContext?: ReplaceContext //  替换当前plugin调用时候的上下文环境
) {
    let promise = Promise.resolve(arg0); // 默认返回source.code
    for (let i = 0; i &amp;lt; this.plugins.length; i++) {
        // 第一个promise的时候只会接收到上面传递的arg0
        // 之后每一次promise接受的都是上一个插件处理过后的source.code值
        promise = promise.then(arg0 =&amp;gt; {
            const hookPromise = this.runHook(hookName, [arg0, ...args], i, false, replaceContext);
            // 如果没有返回promise，那么直接返回arg0
            if (!hookPromise) return arg0;
            // result代表插件执行完成的返回值
            return hookPromise.then((result: any) =&amp;gt;
                reduce.call(this.pluginContexts[i], arg0, result, this.plugins[i])
            );
        });
    }
    return promise;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过观察上面几种钩子函数的调用方式，我们可以发现，其内部有一个调用钩子函数的方法: runHook(Sync)，该函数执行插件中提供的钩子函数。&lt;/p&gt;
&lt;p&gt;实现很简单:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;function runHook&amp;lt;T&amp;gt;(
    hookName: string,
    args: any[],
    pluginIndex: number,
    permitValues: boolean,
    hookContext?: ReplaceContext | null
): Promise&amp;lt;T&amp;gt; {
    this.previousHooks.add(hookName);
    // 找到当前plugin
    const plugin = this.plugins[pluginIndex];
    // 找到当前执行的在plugin中定义的hooks钩子函数
    const hook = (plugin as any)[hookName];
    if (!hook) return undefined as any;

    // pluginContexts在初始化plugin驱动器类的时候定义，是个数组，数组保存对应着每个插件的上下文环境
    let context = this.pluginContexts[pluginIndex];
    // 用于区分对待不同钩子函数的插件上下文
    if (hookContext) {
        context = hookContext(context, plugin);
    }
    return Promise.resolve()
        .then(() =&amp;gt; {
            // permit values allows values to be returned instead of a functional hook
            if (typeof hook !== 'function') {
                if (permitValues) return hook;
                return error({
                    code: 'INVALID_PLUGIN_HOOK',
                    message: `Error running plugin hook ${hookName} for ${plugin.name}, expected a function hook.`
                });
            }
            // 传入插件上下文和参数，返回插件执行结果
            return hook.apply(context, args);
        })
        .catch(err =&amp;gt; throwPluginError(err, plugin.name, { hook: hookName }));
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然，并不是每个人刚开始都会使用插件，所以rollup本身也提供了几个必需的钩子函数供我们使用，在Graph实例化的时候与用户自定义插件进行concat操作:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;import { getRollupDefaultPlugin } from './defaultPlugin';

this.plugins = userPlugins.concat(
    // 采用内置默认插件或者graph的插件驱动器的插件，不管怎么样，内置默认插件是肯定有的
    // basePluginDriver是上一个PluginDriver初始化的插件
    // preserveSymlinks: 软连标志
    basePluginDriver ? basePluginDriver.plugins : [getRollupDefaultPlugin(preserveSymlinks)]
);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那rollup提供了哪些必需的钩子函数呢:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;export function getRollupDefaultPlugin(preserveSymlinks: boolean): Plugin {
        return {
        // 插件名
                name: 'Rollup Core',
                // 默认的模块(文件)加载机制，内部主要使用path.resolve
                resolveId: createResolveId(preserveSymlinks) as ResolveIdHook,
        // this.pluginDriver.hookFirst('load', [id])为异步调用，readFile内部用promise包装了fs.readFile，并返回该promise
                load(id) {
                        return readFile(id);
                },
        // 用来处理通过emitFile添加的urls或文件
                resolveFileUrl({ relativePath, format }) {
                        // 不同format会返回不同的文件解析地址
                        return relativeUrlMechanisms[format](relativePath);
                },
        // 处理import.meta.url，参考地址:https://nodejs.org/api/esm.html#esm_import_meta)
                resolveImportMeta(prop, { chunkId, format }) {
                        // 改变 获取import.meta的信息 的行为
                        const mechanism = importMetaMechanisms[format] &amp;amp;&amp;amp; importMetaMechanisms[format](prop, chunkId);
                        if (mechanism) {
                                return mechanism;
                        }
                }
        };
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;过一眼发现都是最基本处理路径解析内容的钩子函数。&lt;/p&gt;
&lt;p&gt;不仅如此，rollup给钩子函数注入了context，也就是上下文环境，用来方便对chunks和其他构建信息进行增删改查。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://rollupjs.org/guide/en/#plugin-context&quot;&gt;文档&lt;/a&gt;中也写得很清楚，比如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用this.parse，调用rollup内部中的acron实例解析出ast&lt;/li&gt;
&lt;li&gt;使用this.emitFile来增加产出的文件，看这个&lt;a href=&quot;https://github.com/rollup/plugins/blob/371f4246068f3f469e046ecbe329b897eed9a692/packages/html/lib/index.js#L100&quot;&gt;例子&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们通过transform操作来简单看下，之前对ast进行transform的时候，调用了transform钩子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;
graph.pluginDriver
    .hookReduceArg0&amp;lt;any, string&amp;gt;(
        'transform',
        [curSource, id], // source.code 和 模块id
        transformReducer,
        // 第四个参数是一个函数，用来声明某些钩子上下文中需要的方法
        (pluginContext, plugin) =&amp;gt; {
            // 这一大堆是插件利用的，通过this.xxx调用
            curPlugin = plugin;
            if (curPlugin.cacheKey) customTransformCache = true;
            else trackedPluginCache = getTrackedPluginCache(pluginContext.cache);
            return {
                ...pluginContext,
                cache: trackedPluginCache ? trackedPluginCache.cache : pluginContext.cache,
                warn(warning: RollupWarning | string, pos?: number | { column: number; line: number }) {
                    if (typeof warning === 'string') warning = { message: warning } as RollupWarning;
                    if (pos) augmentCodeLocation(warning, pos, curSource, id);
                    warning.id = id;
                    warning.hook = 'transform';
                    pluginContext.warn(warning);
                },
                error(err: RollupError | string, pos?: number | { column: number; line: number }): never {
                    if (typeof err === 'string') err = { message: err };
                    if (pos) augmentCodeLocation(err, pos, curSource, id);
                    err.id = id;
                    err.hook = 'transform';
                    return pluginContext.error(err);
                },
                emitAsset(name: string, source?: string | Buffer) {
                    const emittedFile = { type: 'asset' as const, name, source };
                    emittedFiles.push({ ...emittedFile });
                    return graph.pluginDriver.emitFile(emittedFile);
                },
                emitChunk(id, options) {
                    const emittedFile = { type: 'chunk' as const, id, name: options &amp;amp;&amp;amp; options.name };
                    emittedFiles.push({ ...emittedFile });
                    return graph.pluginDriver.emitFile(emittedFile);
                },
                emitFile(emittedFile: EmittedFile) {
                    emittedFiles.push(emittedFile);
                    return graph.pluginDriver.emitFile(emittedFile);
                },
                addWatchFile(id: string) {
                    transformDependencies.push(id);
                    pluginContext.addWatchFile(id);
                },
                setAssetSource(assetReferenceId, source) {
                    pluginContext.setAssetSource(assetReferenceId, source);
                    if (!customTransformCache &amp;amp;&amp;amp; !setAssetSourceErr) {
                        try {
                            return this.error({
                                code: 'INVALID_SETASSETSOURCE',
                                message: `setAssetSource cannot be called in transform for caching reasons. Use emitFile with a source, or call setAssetSource in another hook.`
                            });
                        } catch (err) {
                            setAssetSourceErr = err;
                        }
                    }
                },
                getCombinedSourcemap() {
                    const combinedMap = collapseSourcemap(
                        graph,
                        id,
                        originalCode,
                        originalSourcemap,
                        sourcemapChain
                    );
                    if (!combinedMap) {
                        const magicString = new MagicString(originalCode);
                        return magicString.generateMap({ includeContent: true, hires: true, source: id });
                    }
                    if (originalSourcemap !== combinedMap) {
                        originalSourcemap = combinedMap;
                        sourcemapChain.length = 0;
                    }
                    return new SourceMap({
                        ...combinedMap,
                        file: null as any,
                        sourcesContent: combinedMap.sourcesContent!
                    });
                }
            };
        }
    )
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;runHook中有一句判断，就是对上下文环境的使用：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;function runHook&amp;lt;T&amp;gt;(
                hookName: string,
                args: any[],
                pluginIndex: number,
                permitValues: boolean,
                hookContext?: ReplaceContext | null
) {
    // ...
    const plugin = this.plugins[pluginIndex];
    // 获取默认的上下文环境
    let context = this.pluginContexts[pluginIndex];
    // 如果提供了，就替换
    if (hookContext) {
        context = hookContext(context, plugin);
    }
    // ...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至于rollup是什么时机调用插件提供的钩子函数的，这里就不啰嗦了，&lt;a href=&quot;https://github.com/FoxDaxian/rollup-analysis&quot;&gt;代码&lt;/a&gt;中分布很清晰，一看便知.&lt;/p&gt;
&lt;p&gt;还有 rollup 为了方便咱们变化插件，还提供了一个&lt;a href=&quot;https://github.com/rollup/plugins/blob/master/packages/pluginutils/README.md&quot;&gt;工具集&lt;/a&gt;，可以非常方便的进行模块的操作以及判断，有兴趣的自行查看。&lt;/p&gt;
&lt;h4 id=&quot;总结&quot;&gt;总结&lt;/h4&gt;
&lt;p&gt;rollup系列到此也就告一段落了，从开始阅读时的一脸懵逼，到读到依赖收集、各工具类的十脸懵逼，到现在的轻车熟路，真是一段难忘的经历~&lt;/p&gt;
&lt;p&gt;学习大佬们的操作并取其精华，去其糟粕就像打怪升级一样，你品，你细品。哈哈&lt;/p&gt;
&lt;p&gt;在这期间也是误导一些东西，看得多了，就会发现，其实套路都一样，摸索出它们的&lt;code&gt;核心框架&lt;/code&gt;，再对功能缝缝补补，不断更新迭代，或许我们也可以成为开源大作的作者。&lt;/p&gt;
&lt;p&gt;如果用几句话来描述rollup的话：&lt;/p&gt;
&lt;p&gt;读取并合并配置 -&amp;gt; 创建依赖图 -&amp;gt; 读取入口模块内容 -&amp;gt; 借用开源estree规范解析器进行源码分析，获取依赖，递归此操作 -&amp;gt; 生成模块，挂载模块对应文件相关信息 -&amp;gt; 分析ast，构建各node实例 -&amp;gt; 生成chunks -&amp;gt; 调用各node重写的render -&amp;gt; 利用magic-string进行字符串拼接和wrap操作 -&amp;gt; 写入&lt;/p&gt;
&lt;p&gt;精简一下就是:&lt;/p&gt;
&lt;p&gt;字符串 -&amp;gt; AST -&amp;gt; 字符串&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/4/13/17173eb9fa4b986b?w=228&amp;amp;h=240&amp;amp;f=png&amp;amp;s=66896&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果改系列能对你一丝丝帮忙，还请动动手指，鼓励一下~&lt;/p&gt;
&lt;p&gt;拜了个拜~&lt;/p&gt;
</description>
<pubDate>Mon, 13 Apr 2020 14:30:00 +0000</pubDate>
<dc:creator>小雨小雨丶</dc:creator>
<og:description>大家好，我是小雨小雨，致力于分享有趣的、实用的技术文章。 内容分为翻译和原创，如果有问题，欢迎随时评论或私信，希望和大家一起进步。 大家的支持是我创作的动力。 计划 rollup系列打算一章一章的放出</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiaoyuxy/p/12694566.html</dc:identifier>
</item>
<item>
<title>abp(net core)+easyui+efcore实现仓储管理系统——入库管理之八(四十四)  - DotNet菜园</title>
<link>http://www.cnblogs.com/chillsrc/p/12694244.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chillsrc/p/12694244.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;span&gt;   &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;span&gt;    在上一篇文章&lt;span&gt;&lt;a class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/chillsrc/p/12637296.html&quot;&gt;&lt;span&gt;abp(net core)+easyui+efcore实现仓储管理系统——入库管理之七(四十三)&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;中我们实现了&lt;/span&gt;&lt;span&gt;测试了入库单&lt;/span&gt;&lt;span&gt;新增功能，不过还存在一些&lt;/span&gt;BUG。今天我们来继续完善&lt;span&gt;入库单&lt;/span&gt;&lt;span&gt;信息新增功能。同时讲讲如何通过浏览器的调试功能来调整CSS样式。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;      1.在“&lt;span&gt;入库单明细&lt;/span&gt;”界面中&lt;span&gt;添加&lt;/span&gt;&lt;span&gt;相应的&lt;/span&gt;&lt;span&gt;货物&lt;/span&gt;&lt;span&gt;信息之后，&lt;/span&gt;&lt;span&gt;修改数量、长宽高等数据时，看不见原来的数据。&lt;/span&gt;&lt;span&gt;如下图。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/10343/202004/10343-20200413215239104-1075987759.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;   2.使用鼠标选中&lt;/span&gt;“数量”中的数字，才能看见数据。如下图。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        &lt;img src=&quot;https://img2020.cnblogs.com/blog/10343/202004/10343-20200413215322284-1340423197.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;          3.&lt;/span&gt;&lt;span&gt;&lt;span&gt;在数量输入框上单击鼠标右键，在弹出菜单中选择查看元素（注：我使用的是&lt;/span&gt;firefox）。如下图。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/10343/202004/10343-20200413215254111-1826322301.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;   4.在查看元素的&lt;/span&gt;css，过程中我们发现，并没有给输入框中的数字赋颜色值。如下图。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/10343/202004/10343-20200413215339800-743749534.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;   5. 我们在&lt;/span&gt;color属性中填入一个颜色值（“#100”），输入框中的数字，立马可以显示。如下图。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/10343/202004/10343-20200413215352804-1211105285.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      6.&lt;span&gt;我们找到&lt;/span&gt;“easyui-1.8\themes\bootstrap\easyui.css”文件，找到“.textbox”样式，在这个样式中添加颜色（“color:#100”&lt;span&gt;）。&lt;/span&gt;&lt;span&gt;如下图。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/10343/202004/10343-20200413215402649-35004177.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     7..我们再次，查看“入库单明细”。如下图。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/10343/202004/10343-20200413215414636-2133276735.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 13 Apr 2020 13:56:00 +0000</pubDate>
<dc:creator>DotNet菜园</dc:creator>
<og:description>在上一篇文章abp(net core)+easyui+efcore实现仓储管理系统——入库管理之七(四十三)中我们实现了测试了入库单新增功能，不过还存在一些BUG。今天我们来继续完善入库单信息新增功能</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chillsrc/p/12694244.html</dc:identifier>
</item>
<item>
<title>Git应用详解第三讲：本地分支的重要操作 - AhuntSun</title>
<link>http://www.cnblogs.com/AhuntSun-blog/p/12694197.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/AhuntSun-blog/p/12694197.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;blockquote readability=&quot;0.89041095890411&quot;&gt;
&lt;p&gt;前情提要:&lt;a href=&quot;https://www.cnblogs.com/AhuntSun-blog/p/12685415.html&quot;&gt;Git应用详解第二讲：Git删除、修改、撤销操作&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;分支是&lt;code&gt;git&lt;/code&gt;最核心的操作之一，了解分支的基本操作能够大大提高项目开发的效率。这一讲就来介绍一些分支的常见操作及其基本原理。&lt;/p&gt;
&lt;h3 id=&quot;一、分支概述&quot;&gt;一、分支概述&lt;/h3&gt;
&lt;p&gt;在开发当中，往往需要分工合作。比如：小红开发&lt;code&gt;A&lt;/code&gt;功能，小明开发&lt;code&gt;B&lt;/code&gt;功能，小刚开发&lt;code&gt;C&lt;/code&gt;功能。如何才能做到三者并行开发呢？&lt;code&gt;git&lt;/code&gt;为我们提供的分支功能就能实现这一需求，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/1.png&quot; alt=&quot;image-20200413193720239&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在实际的开发过程中，&lt;code&gt;master&lt;/code&gt;分支是用来发布项目稳定版本的。新的功能往往是在一个新建的分支上进行开发，等到新功能开发完毕并经过测试，表现稳定后，才会合并到&lt;code&gt;master&lt;/code&gt;分支上进行版本更新。这样就可以在保持一款软件发行的同时，同步进行新功能的开发。&lt;/p&gt;
&lt;p&gt;通常来说，远程仓库的&lt;code&gt;Git&lt;/code&gt;分支会有如下几种：&lt;code&gt;master&lt;/code&gt;分支、&lt;code&gt;test&lt;/code&gt;分支、&lt;code&gt;develop&lt;/code&gt;分支，除此之外可能还有紧急修复&lt;code&gt;bug&lt;/code&gt;的&lt;code&gt;hotfix&lt;/code&gt;分支；但是，本地的分支可以有很多；本文主要介绍&lt;code&gt;Git&lt;/code&gt;本地分支的内容。&lt;/p&gt;
&lt;h3 id=&quot;二、查看本地分支&quot;&gt;二、查看本地分支&lt;/h3&gt;
&lt;h4 id=&quot;1git-branch&quot;&gt;1.&lt;code&gt;git branch&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;查看当前版本库中的所有分支：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/2.png&quot; alt=&quot;image-20200310151203938&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中的 &lt;code&gt;*&lt;/code&gt; 表示当前处于的分支，可见当前处于&lt;code&gt;master&lt;/code&gt;分支；&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;git init&lt;/code&gt;初始化&lt;code&gt;git&lt;/code&gt;仓库时，&lt;code&gt;git&lt;/code&gt;会自动创建一个&lt;code&gt;master&lt;/code&gt;分支。但是，如果没有在&lt;code&gt;master&lt;/code&gt;分支上进行任何提交就切换到其他分支，那么在切换分支的时候&lt;code&gt;master&lt;/code&gt;分支会被销毁。并且，无法查看没有提交记录的分支，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/3.png&quot; alt=&quot;image-20200413115148907&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;2git-branch--a&quot;&gt;2.&lt;code&gt;git branch -a&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;查看所有本地分支，包括本地分支和本地远程分支：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/4.png&quot; alt=&quot;image-20200328164045256&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;3git-branch--v&quot;&gt;3.&lt;code&gt;git branch -v&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;查看所有本地分支上最近一次的提交记录：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/5.png&quot; alt=&quot;image-20200413122049091&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是，该指令无法查看本地远程分支：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/6.png&quot; alt=&quot;image-20200413123220561&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;4git-branch--r&quot;&gt;4.&lt;code&gt;git branch -r&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;-r&lt;/code&gt;参数用于单独查看本地远程分支：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/6.1.png&quot; alt=&quot;image-20200413174143173&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;5git-branch--av&quot;&gt;5.&lt;code&gt;git branch -av&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;该指令不仅可以显示所有的本地分支，包括本地远程分支，以及对应分支上的最新提交信息：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/7.png&quot; alt=&quot;image-20200409115958334&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;6git-branch--vv&quot;&gt;6.&lt;code&gt;git branch -vv&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;-vv&lt;/code&gt;参数表示查看所有本地分支与远程分支的关联情况。如图所示，本地&lt;code&gt;master&lt;/code&gt;分支有本地远程分支&lt;code&gt;origin/master&lt;/code&gt;与之关联，说明它已与远程&lt;code&gt;master&lt;/code&gt;分支建立了关联；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/8.png&quot; alt=&quot;image-20200410121145929&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;至于上面提到的&lt;strong&gt;本地远程分支&lt;/strong&gt;，将在下一讲中详细介绍。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;三、创建本地分支&quot;&gt;三、创建本地分支&lt;/h3&gt;
&lt;h4 id=&quot;1git-branch-branch_name&quot;&gt;1.&lt;code&gt;git branch &amp;lt;branch_name&amp;gt;&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;可通过上述命令创建新分支&lt;code&gt;new_branch&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/9.png&quot; alt=&quot;image-20200310151357642&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于是在&lt;code&gt;master&lt;/code&gt;分支上创建的&lt;code&gt;new_branch&lt;/code&gt;分支，所以&lt;strong&gt;&lt;code&gt;new_branch&lt;/code&gt;分支&lt;/strong&gt;与&lt;strong&gt;&lt;code&gt;master&lt;/code&gt;分支&lt;/strong&gt;有着部分&lt;strong&gt;共同的提交历史&lt;/strong&gt;；所以，&lt;code&gt;master&lt;/code&gt;分支上的文件，&lt;code&gt;new_branch&lt;/code&gt;分支上都有。但是，在&lt;code&gt;new_branch&lt;/code&gt;分支上添加的&lt;code&gt;new_branch&lt;/code&gt;文件，不会存在于&lt;code&gt;master&lt;/code&gt;分支上：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/10.png&quot; alt=&quot;image-20200413120006856&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时两分支的状态为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/11.png&quot; alt=&quot;image-20200413120509219&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;2git-branch--b-branch_name&quot;&gt;2.&lt;code&gt;git branch -b &amp;lt;branch_name&amp;gt;&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;通过上述命令可创建并切换到&lt;code&gt;new_branch&lt;/code&gt;分支：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/12.png&quot; alt=&quot;image-20200413120945856&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如图所示，本来所在分支为&lt;code&gt;master&lt;/code&gt;，并且没有&lt;code&gt;new_branch&lt;/code&gt;分支。执行上述命令后，创建并切换到了&lt;code&gt;new_branch&lt;/code&gt;分支上。&lt;/p&gt;
&lt;h3 id=&quot;四、切换本地分支&quot;&gt;四、切换本地分支&lt;/h3&gt;
&lt;h4 id=&quot;1git-checkout-branch_name&quot;&gt;1.&lt;code&gt;git checkout &amp;lt;branch_name&amp;gt;&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;比如切换到&lt;code&gt;new_branch&lt;/code&gt;分支：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/13.png&quot; alt=&quot;image-20200310151539203&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;2git-checkout--&quot;&gt;2.&lt;code&gt;git checkout -&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;切换回上次操作的分支：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/14.png&quot; alt=&quot;image-20200310152313013&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;五、重命名本地分支&quot;&gt;五、重命名本地分支&lt;/h3&gt;
&lt;h4 id=&quot;1git-branch--m-oldname-newname&quot;&gt;1.&lt;code&gt;git branch -m &amp;lt;oldName&amp;gt; &amp;lt;newName&amp;gt;&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;如下图所示，将本地分支&lt;code&gt;master&lt;/code&gt;重命名为&lt;code&gt;master2&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/15.png&quot; alt=&quot;image-20200311115657966&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;六、删除本地分支&quot;&gt;六、删除本地分支&lt;/h3&gt;
&lt;h4 id=&quot;1git-branch--d-new_branch&quot;&gt;1.&lt;code&gt;git branch -d new_branch&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;删除&lt;code&gt;new_branch&lt;/code&gt;分支：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/16.png&quot; alt=&quot;image-20200310163652841&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;不能删除当前所处的分支；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;当需要删除的分支上有&lt;code&gt;master&lt;/code&gt;分支没有的内容，并且删除前没有进行合并（&lt;code&gt;merge&lt;/code&gt;）时，会报错：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/17.png&quot; alt=&quot;image-20200310163934006&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时可以通过&lt;strong&gt;&lt;code&gt;git branch -D new_branch&lt;/code&gt;&lt;/strong&gt; 使用参数&lt;code&gt;D&lt;/code&gt;，在不合并的情况下强制&lt;strong&gt;删除分支&lt;/strong&gt;；&lt;/p&gt;
&lt;h3 id=&quot;七、合并分支&quot;&gt;七、合并分支&lt;/h3&gt;
&lt;p&gt;注意：这里所讲的分支指的是有公共提交节点的分支，如下图中的&lt;code&gt;dev&lt;/code&gt;与&lt;code&gt;master&lt;/code&gt;分支所示，提交节点&lt;code&gt;A&lt;/code&gt;为它们的公共提交节点：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/18.png&quot; alt=&quot;image-20200411210604441&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当两分支没有公共提交节点，如下图所示，应采用&lt;code&gt;rebase&lt;/code&gt;进行合并，后面会详细介绍：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/19.png&quot; alt=&quot;image-20200411210330211&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;1git-merge-branch_name&quot;&gt;1.&lt;code&gt;git merge &amp;lt;branch_name&amp;gt;&lt;/code&gt;&lt;/h4&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;首先，创建并切换到新分支&lt;code&gt;dev&lt;/code&gt;中，并为&lt;code&gt;test.txt&lt;/code&gt;文件添加内容&lt;code&gt;dev1&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/20.png&quot; alt=&quot;image-20200413213753822&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;要将&lt;code&gt;dev&lt;/code&gt;分支上的这一修改提交到版本库，才能进行后续合并。因为合并的是提交对象链，详情见后面讲解的合并原理：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/21.png&quot; alt=&quot;image-20200413124513814&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;然后，&lt;strong&gt;切换回&lt;code&gt;master&lt;/code&gt;分支&lt;/strong&gt;，通过&lt;code&gt;git merge dev&lt;/code&gt;指令，将&lt;code&gt;dev&lt;/code&gt;分支中的内容合并到&lt;strong&gt;当前所处&lt;/strong&gt;的&lt;code&gt;master&lt;/code&gt;分支中；合并后&lt;code&gt;master&lt;/code&gt;分支与&lt;code&gt;dev&lt;/code&gt;分支上&lt;code&gt;test.txt&lt;/code&gt;文件的内容达到了同步：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/22.png&quot; alt=&quot;image-20200413213934629&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;2分支合并的原则&quot;&gt;2.分支合并的原则&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;git&lt;/code&gt;分支的合并采用的是&lt;strong&gt;三方合并&lt;/strong&gt;的原则：找到两分支最新提交&lt;code&gt;A&lt;/code&gt;和&lt;code&gt;B&lt;/code&gt;的公共父节点&lt;code&gt;C&lt;/code&gt;，在这三个节点的基础上合并为节点&lt;code&gt;D&lt;/code&gt;。这个节点&lt;code&gt;D&lt;/code&gt;就包含了两个分支上的所有内容：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/23.png&quot; alt=&quot;image-20200407160615973&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;八、分支的本质&quot;&gt;八、分支的本质&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;分支：指向一条&lt;code&gt;commit&lt;/code&gt;对象链或一条工作记录线的指针；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;快照&lt;code&gt;A~D&lt;/code&gt;分别表示四次提交（&lt;code&gt;commit&lt;/code&gt;），注意提交的顺序为：&lt;code&gt;A -&amp;gt; B -&amp;gt; C -&amp;gt; D&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/24.png&quot; alt=&quot;image-20200408150401090&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从图中可以看到每一次提交的对象内都会保存上一次提交的&lt;code&gt;commit id&lt;/code&gt;，由此可以从后往前把所有的提交（&lt;code&gt;commit&lt;/code&gt;）串起来形成一条&lt;strong&gt;链&lt;/strong&gt;（类似单向链表），&lt;strong&gt;这条链就组成了一条完整的分支信息&lt;/strong&gt;：&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;当版本库中只有一条分支：&lt;/strong&gt;该分支的最新提交就包含了整条分支的所有内容，代表版本库的&lt;strong&gt;当前状态&lt;/strong&gt;。如上图的快照&lt;code&gt;D&lt;/code&gt;，里面包含了快照&lt;code&gt;A~C&lt;/code&gt;中的所有内容，此时快照&lt;code&gt;D&lt;/code&gt;中的内容就是整个版本库中的内容：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/25.png&quot; alt=&quot;image-20200413132342942&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;当版本库中有多条分支：&lt;/strong&gt;每条分支上的最新提交包含了所处分支的&lt;strong&gt;全部内容&lt;/strong&gt;，将各个分支的最新提交进行合并。合并的节点就包含了所有分支的内容，也就是&lt;strong&gt;现阶段的版本库本身&lt;/strong&gt;；如下图中的&lt;code&gt;d1&lt;/code&gt;、&lt;code&gt;m2&lt;/code&gt;、&lt;code&gt;t3&lt;/code&gt;分别包含了&lt;code&gt;dev&lt;/code&gt;、&lt;code&gt;master&lt;/code&gt;、&lt;code&gt;test&lt;/code&gt;分支上的所有内容：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/26.png&quot; alt=&quot;image-20200413132409178&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;1分支--指针&quot;&gt;1.分支 &lt;code&gt;==&lt;/code&gt; 指针&lt;/h4&gt;
&lt;p&gt;情景一：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/27.png&quot; alt=&quot;image-20200406131416304&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从图中可以看到：&lt;/p&gt;
&lt;p&gt;情景二：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/28.png&quot; alt=&quot;image-20200406131503784&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图中，&lt;code&gt;dev&lt;/code&gt;为&lt;code&gt;master&lt;/code&gt;分支上创建的新分支，可知：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;git&lt;/code&gt;在创建新分支时，文件本身不变化，只需要创建一个&lt;strong&gt;代表新分支，并指向当前分支的指针&lt;/strong&gt;；如图中的&lt;code&gt;dev&lt;/code&gt;与&lt;code&gt;master&lt;/code&gt;指向同一个提交，文件没有发生任何变化；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HEAD&lt;/code&gt;指向&lt;code&gt;dev&lt;/code&gt;分支，表示当前所处分支为&lt;code&gt;dev&lt;/code&gt;，相当于执行了：&lt;code&gt;git checkout -b dev&lt;/code&gt; 后的状态；&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;相信你已经发现：&lt;code&gt;HEAD&lt;/code&gt;是一个始终&lt;strong&gt;指向当前分支&lt;/strong&gt;的&lt;strong&gt;指针&lt;/strong&gt;；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;2head标识符&quot;&gt;2.&lt;code&gt;HEAD&lt;/code&gt;标识符&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;HEAD&lt;/code&gt;文件是一个指向当前所在分支的&lt;strong&gt;引用标识符&lt;/strong&gt;，也可以理解为一个&lt;strong&gt;指针&lt;/strong&gt;，它与分支之间的关系是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/29.png&quot; alt=&quot;image-20200408000947960&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;查看head&quot;&gt;查看&lt;code&gt;HEAD&lt;/code&gt;&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;HEAD&lt;/code&gt;文件中并不包含&lt;code&gt;SHA1&lt;/code&gt;值（每次提交的&lt;code&gt;commit ID&lt;/code&gt;），而是包含一个指向另外一个引用的指针。我们可以查看&lt;code&gt;.git&lt;/code&gt;目录下的&lt;code&gt;HEAD&lt;/code&gt;文件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/30.png&quot; alt=&quot;image-20200310172919110&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可见&lt;code&gt;HEAD&lt;/code&gt;指向的是当前所在的&lt;code&gt;master&lt;/code&gt;分支；&lt;/p&gt;
&lt;p&gt;当我们通过&lt;code&gt;git checkout -b dev&lt;/code&gt; 创建并切换到&lt;code&gt;dev&lt;/code&gt;分支后，再次进入&lt;code&gt;.git&lt;/code&gt;文件夹查看&lt;code&gt;HEAD&lt;/code&gt;，会发现此时&lt;code&gt;HEAD&lt;/code&gt;指向了&lt;code&gt;dev&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/31.png&quot; alt=&quot;image-20200310173205214&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由此证明了&lt;code&gt;HEAD&lt;/code&gt;始终指向当前分支；&lt;/p&gt;
&lt;p&gt;当执行&lt;code&gt;git commit&lt;/code&gt;命令时，&lt;code&gt;git&lt;/code&gt;会创建一个&lt;code&gt;commit&lt;/code&gt;对象（比如下图&lt;code&gt;D&lt;/code&gt;）。并且将这个&lt;code&gt;commit&lt;/code&gt;对象的&lt;code&gt;parent&lt;/code&gt;指针指向&lt;code&gt;HEAD&lt;/code&gt; 所指向的引用（&lt;code&gt;master&lt;/code&gt;）指向的提交（也就是&lt;code&gt;C&lt;/code&gt;），这样就能形成一条提交链：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/32.png&quot; alt=&quot;image-20200408001856063&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们对于&lt;code&gt;HEAD&lt;/code&gt;修改的任何操作，都会被&lt;code&gt;git reflog&lt;/code&gt;完整记录下来：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/33.png&quot; alt=&quot;image-20200329145707276&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是手动地修改&lt;code&gt;HEAD&lt;/code&gt;文件，这些信息就不会被记录下来，所以十分不建议手动修改&lt;code&gt;git&lt;/code&gt;相关的配置文件，而是应该尽量采用命令行的方式来修改。&lt;/p&gt;
&lt;h5 id=&quot;修改head&quot;&gt;修改&lt;code&gt;HEAD&lt;/code&gt;&lt;/h5&gt;
&lt;p&gt;实际上，我们可以通过&lt;code&gt;git&lt;/code&gt;的底层命令&lt;code&gt;symbolic-ref&lt;/code&gt;来实现对&lt;code&gt;HEAD&lt;/code&gt;文件内容的修改；&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;code&gt;git&lt;/code&gt; 中的命令可分为两类：&lt;strong&gt;高级命令&lt;/strong&gt;和&lt;strong&gt;底层命令&lt;/strong&gt;；之前介绍的&lt;code&gt;git add&lt;/code&gt; 等都是高级命令；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;读取：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/34.png&quot; alt=&quot;image-20200329150120113&quot;/&gt;&lt;/p&gt;
&lt;p&gt;写入：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/35.png&quot; alt=&quot;image-20200329150239094&quot;/&gt;&lt;/p&gt;
&lt;p&gt;要注意格式：&lt;code&gt;refs/heads/develop&lt;/code&gt;；&lt;/p&gt;
&lt;p&gt;查看&lt;code&gt;ORIG_HEAD&lt;/code&gt;文件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/36.png&quot; alt=&quot;image-20200329150514036&quot;/&gt;&lt;/p&gt;
&lt;p&gt;里面是一个&lt;code&gt;SHA1&lt;/code&gt;值，查看当前的提交信息：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/37.png&quot; alt=&quot;image-20200329150643422&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以发现，&lt;code&gt;ORIG_HEAD&lt;/code&gt;里面的&lt;code&gt;SHA1&lt;/code&gt;值就是最新一次提交的&lt;code&gt;SHA1&lt;/code&gt;值。&lt;/p&gt;
&lt;p&gt;查看&lt;code&gt;FETCH_HEAD&lt;/code&gt;文件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/38.png&quot; alt=&quot;image-20200329150904196&quot;/&gt;&lt;/p&gt;
&lt;p&gt;里面有两个信息，一个是最新提交的&lt;code&gt;commit ID&lt;/code&gt;，另一个是提交信息。&lt;/p&gt;
&lt;p&gt;所以，对于&lt;code&gt;git&lt;/code&gt;而言&lt;code&gt;commit ID&lt;/code&gt;是十分重要的信息，通过这个&lt;code&gt;SHA1&lt;/code&gt;值可以回溯或查找需要的提交。&lt;/p&gt;
&lt;h4 id=&quot;3git-merge原理&quot;&gt;3.&lt;code&gt;git merge&lt;/code&gt;原理&lt;/h4&gt;
&lt;h5 id=&quot;过程图解&quot;&gt;过程图解&lt;/h5&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;在新分支上进行提交操作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/39.png&quot; alt=&quot;image-20200406131605850&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图表示在&lt;code&gt;dev&lt;/code&gt;分支上进行了一次提交，此时：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;分支&lt;code&gt;master&lt;/code&gt;的提交记录由：&lt;code&gt;A&lt;/code&gt;、&lt;code&gt;B&lt;/code&gt;和&lt;code&gt;C&lt;/code&gt;组成；&lt;/li&gt;
&lt;li&gt;而分支&lt;code&gt;dev&lt;/code&gt;的提交历史则由：&lt;code&gt;A&lt;/code&gt;、&lt;code&gt;B&lt;/code&gt;、&lt;code&gt;C&lt;/code&gt;和&lt;code&gt;D&lt;/code&gt;组成；&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;对两分支进行合并操作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/40.png&quot; alt=&quot;image-20200406131708763&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;master&lt;/code&gt;分支上执行：&lt;code&gt;git merge dev&lt;/code&gt;将&lt;code&gt;dev&lt;/code&gt;分支的内容&lt;strong&gt;合并&lt;/strong&gt;到了&lt;code&gt;master&lt;/code&gt;分支上；这种合并方式叫做：&lt;code&gt;Fast-forward&lt;/code&gt;，&lt;strong&gt;没有冲突&lt;/strong&gt;，改变的只是&lt;code&gt;master&lt;/code&gt;指针的指向；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/41.png&quot; alt=&quot;image-20200310180632403&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;详细过程&quot;&gt;详细过程&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;在执行合并操作前：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在&lt;code&gt;master&lt;/code&gt;分支上查看该分支的提交记录：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/42.png&quot; alt=&quot;image-20200413135649151&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在&lt;code&gt;dev&lt;/code&gt;分支上查看该分支的提交记录：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/43.png&quot; alt=&quot;image-20200413135632944&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到&lt;code&gt;dev&lt;/code&gt;分支只是比&lt;code&gt;master&lt;/code&gt;分支多进行了一次提交（&lt;code&gt;dev1&lt;/code&gt;），两分支状态如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/44.png&quot; alt=&quot;image-20200413140621228&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;执行合并操作：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先切换到&lt;code&gt;master&lt;/code&gt;分支，然后执行&lt;code&gt;git merge dev&lt;/code&gt;合并&lt;code&gt;dev&lt;/code&gt;分支：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/45.png&quot; alt=&quot;image-20200413135914872&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到使用了&lt;code&gt;Fast-forward&lt;/code&gt;方式进行合并，合并后两分支状态如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/46.png&quot; alt=&quot;image-20200413140634456&quot;/&gt;&lt;/p&gt;
&lt;p&gt;合并后，&lt;code&gt;HEAD&lt;/code&gt;同时指向了&lt;code&gt;master&lt;/code&gt;和&lt;code&gt;dev&lt;/code&gt;分支；并且&lt;code&gt;master&lt;/code&gt;和&lt;code&gt;dev&lt;/code&gt;分支的提交历史完全一致；这就说明了：使用&lt;strong&gt;&lt;code&gt;Fast-forward&lt;/code&gt;（快进合并）&lt;/strong&gt;方式进行分支合并，只会改变&lt;code&gt;master&lt;/code&gt;分支指针的指向；&lt;/p&gt;
&lt;h4 id=&quot;4fast-forward&quot;&gt;4.&lt;code&gt;Fast-forward&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;默认情况下，合并分支时&lt;code&gt;git&lt;/code&gt;会使用&lt;code&gt;Fast-forward&lt;/code&gt;模式；&lt;/li&gt;
&lt;li&gt;在这种模式下，删除分支会&lt;strong&gt;丢弃&lt;/strong&gt;分支信息；&lt;/li&gt;
&lt;li&gt;进行分支合并操作时加上&lt;code&gt;--no-ff&lt;/code&gt; 参数会禁止使用&lt;code&gt;Fast-forward&lt;/code&gt;方式，这样会多出一次提交记录；&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;ff&lt;/code&gt;表示&lt;code&gt;Fast-forward&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;具体演示如下：&lt;/p&gt;
&lt;h5 id=&quot;使用fast-forward&quot;&gt;使用&lt;code&gt;Fast-forward&lt;/code&gt;&lt;/h5&gt;
&lt;p&gt;首先，查看&lt;code&gt;master&lt;/code&gt;分支上最新的&lt;code&gt;3&lt;/code&gt;次提交：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/47.png&quot; alt=&quot;image-20200413140911195&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时两分支的状态为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/48.png&quot; alt=&quot;image-20200413141208043&quot;/&gt;&lt;/p&gt;
&lt;p&gt;随后在&lt;code&gt;dev&lt;/code&gt;分支上新增一次提交：&lt;code&gt;dev2&lt;/code&gt;。查看&lt;code&gt;dev&lt;/code&gt;分支上最新的&lt;code&gt;3&lt;/code&gt;次提交：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/49.png&quot; alt=&quot;image-20200413141111031&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时两个分支的状态为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/50.png&quot; alt=&quot;image-20200413141246153&quot;/&gt;&lt;/p&gt;
&lt;p&gt;切换回&lt;code&gt;master&lt;/code&gt;分支，通过&lt;code&gt;git merge dev&lt;/code&gt;合并&lt;code&gt;dev&lt;/code&gt;分支，此时默认采用&lt;code&gt;Fast-forward&lt;/code&gt;方式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/51.png&quot; alt=&quot;image-20200413141412571&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到合并后，&lt;code&gt;master&lt;/code&gt;直接指向了&lt;code&gt;dev&lt;/code&gt;的最新提交，并没有产生新的提交。合并后两分支的状态如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/52.png&quot; alt=&quot;image-20200413141554807&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由此验证了&lt;code&gt;Fast-forward&lt;/code&gt;方式只会改变分支指针的指向。&lt;/p&gt;
&lt;h5 id=&quot;禁用fast-forward&quot;&gt;禁用&lt;code&gt;Fast-forward&lt;/code&gt;&lt;/h5&gt;
&lt;p&gt;合并时可以通过：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;git merge --no-of dev
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;禁用&lt;code&gt;Fast-forward&lt;/code&gt;模式。&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;继续在&lt;code&gt;dev&lt;/code&gt;分支新增一次提交：&lt;code&gt;dev3&lt;/code&gt;。然后查看&lt;code&gt;dev&lt;/code&gt;分支上最新的&lt;code&gt;3&lt;/code&gt;次提交：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/53.png&quot; alt=&quot;image-20200413142011002&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;不修改&lt;code&gt;master&lt;/code&gt;分支，查看其最新的&lt;code&gt;3&lt;/code&gt;次提交：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/54.png&quot; alt=&quot;image-20200413142116641&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时两个分支的状态为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/55.png&quot; alt=&quot;image-20200413142145430&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;然后，在&lt;code&gt;master&lt;/code&gt;分支上不使用&lt;code&gt;Fast-forward&lt;/code&gt;方式合并&lt;code&gt;dev&lt;/code&gt;分支。合并命令采用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;git merge --no-ff dev
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行后进入如下的&lt;code&gt;vim&lt;/code&gt;编辑器界面，要求我们填写提交注释：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/56.png&quot; alt=&quot;image-20200413142507135&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这说明不使用&lt;code&gt;Fast-forward&lt;/code&gt;方式合并分支，会触发了一次&lt;strong&gt;提交&lt;/strong&gt;。填写提交注释后完成提交操作，合并完成后，查看&lt;code&gt;master&lt;/code&gt;分支的提交记录：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/57.png&quot; alt=&quot;image-20200413142907282&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以发现禁用了&lt;code&gt;Fast-forward&lt;/code&gt;模式的合并会比&lt;code&gt;dev&lt;/code&gt;分支多产生一次提交：&lt;code&gt;Merge branch 'dev'&lt;/code&gt;，即使合并后的内容是一样的。此时两分支的状态为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/58.png&quot; alt=&quot;image-20200413144533217&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由此验证了，禁用&lt;code&gt;Fast-forward&lt;/code&gt;方式合并，会多出一个表示合并的提交记录。&lt;/p&gt;
&lt;h4 id=&quot;5合并冲突&quot;&gt;5.合并冲突&lt;/h4&gt;
&lt;p&gt;合并的两分支只有一条分支发生了改变，并且其中一分支是基于另一分支创建的。比如上述的&lt;code&gt;master&lt;/code&gt;与&lt;code&gt;dev&lt;/code&gt;分支，两分支没有分岔，此时不会出现合并冲突；&lt;code&gt;git&lt;/code&gt;会通过&lt;code&gt;Fast-forward&lt;/code&gt;方式自动完成合并操作；&lt;/p&gt;
&lt;p&gt;但是，当合并的两分支&lt;strong&gt;都发生改变时&lt;/strong&gt;，即分支出现分岔，如下图所示。此时就需要解决冲突后手动合并分支了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/59.png&quot; alt=&quot;image-20200413145058222&quot;/&gt;&lt;/p&gt;
&lt;p&gt;具体演示如下：&lt;/p&gt;
&lt;h5 id=&quot;合并前&quot;&gt;合并前&lt;/h5&gt;
&lt;p&gt;首先，分别对两分支上的&lt;code&gt;test.txt&lt;/code&gt;文件进行修改，并分别将修改&lt;strong&gt;提交&lt;/strong&gt;到各自的分支；&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在&lt;code&gt;master&lt;/code&gt;分支上进行新的提交：&lt;code&gt;mas3&lt;/code&gt;，然后查看文件&lt;code&gt;test.txt&lt;/code&gt;内容和分支提交记录：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/60.png&quot; alt=&quot;image-20200413150045837&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在&lt;code&gt;dev&lt;/code&gt;分支上进行新的提交：&lt;code&gt;dev1&lt;/code&gt;，然后查看文件&lt;code&gt;test.txt&lt;/code&gt;内容和分支提交记录：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/61.png&quot; alt=&quot;image-20200413150139932&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可见两分支的提交记录只有最新一次提交不一样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/62.png&quot; alt=&quot;image-20200413153145295&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;合并后&quot;&gt;合并后&lt;/h5&gt;
&lt;p&gt;在&lt;code&gt;master&lt;/code&gt;分支上，通过&lt;code&gt;git merge dev&lt;/code&gt;合并&lt;code&gt;dev&lt;/code&gt;分支时，会在共同修改的&lt;code&gt;test.txt&lt;/code&gt;文件中出现合并冲突，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/63.png&quot; alt=&quot;image-20200413150334009&quot;/&gt;&lt;/p&gt;
&lt;p&gt;出现冲突的原因为：两个分支都对同一个文件&lt;code&gt;test.txt&lt;/code&gt;进行了修改，&lt;code&gt;git&lt;/code&gt;合并时并不知道以哪个分支的修改为标准。所以不能采用&lt;code&gt;Fast-forward&lt;/code&gt;方式自动合并，需要解决冲突，手动合并。&lt;/p&gt;
&lt;h5 id=&quot;手动合并过程&quot;&gt;手动合并过程&lt;/h5&gt;
&lt;p&gt;手动合并操作需要分如下三步进行：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;第一步：选择需要保留的内容，手动解决合并冲突；&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;此时进入发生合并冲突的&lt;code&gt;test.txt&lt;/code&gt;文件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/64.png&quot; alt=&quot;image-20200413150400943&quot;/&gt;&lt;/p&gt;
&lt;p&gt;会出现典型的冲突呈现方式（此时&lt;code&gt;HEAD&lt;/code&gt;指向的是&lt;code&gt;master&lt;/code&gt;分支），其中：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;&amp;lt;&amp;lt;HEAD&lt;/code&gt;与&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;dev&lt;/code&gt;之间的内容表示：两分支上&lt;code&gt;test.txt&lt;/code&gt;文件的不同之处；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;&amp;lt;&amp;lt;HEAD&lt;/code&gt;与&lt;code&gt;===&lt;/code&gt;之间的内容表示：当前分支&lt;code&gt;master&lt;/code&gt;对&lt;code&gt;test.txt&lt;/code&gt;文件的修改；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;===&lt;/code&gt;与&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;dev&lt;/code&gt;之间的内容表示：&lt;code&gt;dev&lt;/code&gt;分支对&lt;code&gt;test.txt&lt;/code&gt;文件的修改；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;此时只需要在&lt;code&gt;test.txt&lt;/code&gt;中保留想要的内容即可，例如：将两分支对&lt;code&gt;test.txt&lt;/code&gt;的修改都进行保存，删除&lt;code&gt;3、5、7&lt;/code&gt;行多余的内容：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/65.png&quot; alt=&quot;image-20200413150810935&quot;/&gt;&lt;/p&gt;
&lt;p&gt;除此之外，还可以通过&lt;code&gt;git mergetool&lt;/code&gt;指令，调用&lt;code&gt;vimdiff&lt;/code&gt;工具进入&lt;code&gt;vim&lt;/code&gt;编辑器，来解决&lt;code&gt;test.txt&lt;/code&gt;文件的冲突：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/65.1.png&quot; alt=&quot;image-20200413212456463&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/65.2.png&quot; alt=&quot;image-20200413212331710&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在实际开发中，我们很少手动进行合并，而是借助于一些工具来实现。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;第二步：使用&lt;code&gt;git add test.txt&lt;/code&gt;将手动解决冲突时对&lt;code&gt;test.txt&lt;/code&gt;的修改提交到暂存区；&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;编辑完毕后，可以看到此时仍然处于合并过程中（&lt;code&gt;MERGING&lt;/code&gt;）。通过&lt;code&gt;git status&lt;/code&gt; 查看状态，发现手动解决冲突时对&lt;code&gt;test.txt&lt;/code&gt;文件的修改操作还在工作区中，需要通过&lt;code&gt;git add test.txt&lt;/code&gt;将这一修改纳入暂存区，继续进行合并：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/66.png&quot; alt=&quot;image-20200413151548133&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;第三步：通过&lt;code&gt;git commit -m '合并注释'&lt;/code&gt;将手动解决冲突时对&lt;code&gt;test.txt&lt;/code&gt;的修改进行提交，完成合并操作；&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果需要填写较多的合并注释，可以通过&lt;code&gt;git commit&lt;/code&gt;进入&lt;code&gt;vim&lt;/code&gt;编辑器编辑。提交后，完成整个手动合并过程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/67.png&quot; alt=&quot;image-20200310185125770&quot;/&gt;&lt;/p&gt;
&lt;p&gt;完成手动合并分支后，查看两分支的提交历史：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;master&lt;/code&gt;分支上的提交历史：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/68.png&quot; alt=&quot;image-20200413152813941&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;dev&lt;/code&gt;分支上的提交历史：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/69.png&quot; alt=&quot;image-20200413152928725&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以发现此时两分支转变为了可以通过&lt;code&gt;Fast forward&lt;/code&gt;方式合并的形式了，如图所示：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;手动解决冲突前：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/70.png&quot; alt=&quot;image-20200413153154756&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;&lt;strong&gt;手动解决冲突后：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/71.png&quot; alt=&quot;image-20200413153427160&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;同步两分支&quot;&gt;同步两分支&lt;/h5&gt;
&lt;p&gt;若想将&lt;code&gt;dev&lt;/code&gt;和&lt;code&gt;master&lt;/code&gt;分支上的内容进行同步，只需要在&lt;code&gt;dev&lt;/code&gt;分支中通过&lt;code&gt;git merge master&lt;/code&gt; 合并&lt;code&gt;master&lt;/code&gt;分支即可。此时就可以使用&lt;code&gt;Fast-forward&lt;/code&gt;方式进行合并了，合并结果如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/72.png&quot; alt=&quot;image-20200413153555178&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;验证：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;合并后，查看&lt;code&gt;dev&lt;/code&gt;分支的提交历史：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/73.png&quot; alt=&quot;image-20200413154132053&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到&lt;code&gt;HEAD&lt;/code&gt;同时指向&lt;code&gt;dev&lt;/code&gt;与&lt;code&gt;master&lt;/code&gt;，即三个指针都指向了最新的一次提交，符合上述分析得出的结论；&lt;/p&gt;
&lt;p&gt;经过上面的讨论，不难看出：合并分支的实质就是不同提交的合并，以及&lt;code&gt;HEAD&lt;/code&gt;和分支指针的移动；&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;以上就是今天介绍的本地分支重要操作，相信看到这里的你已经对&lt;code&gt;git&lt;/code&gt;本地分支的操作了如指掌了。在下一讲中将介绍&lt;code&gt;git&lt;/code&gt;最神奇的功能：&lt;strong&gt;版本回退&lt;/strong&gt;。俗话说得好：世上没有后悔药。但是在&lt;code&gt;git&lt;/code&gt;中，就存在所谓的&quot;&lt;strong&gt;后悔药&lt;/strong&gt;&quot;！那么我们下一节再见。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 13 Apr 2020 13:49:00 +0000</pubDate>
<dc:creator>AhuntSun</dc:creator>
<og:description>前言 前情提要: &amp;quot;Git应用详解第二讲：Git删除、修改、撤销操作&amp;quot; 分支是 最核心的操作之一，了解分支的基本操作能够大大提高项目开发的效率。这一讲就来介绍一些分支的常见操作及其</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/AhuntSun-blog/p/12694197.html</dc:identifier>
</item>
<item>
<title>对“沟通成本”模型认知的一个重新假设 - wc的一些事一些情</title>
<link>http://www.cnblogs.com/wcd144140/p/12694175.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wcd144140/p/12694175.html</guid>
<description>&lt;p&gt;&lt;span&gt;在成本管理上，我把一个软件项目的成本主要划分为“技术成本”和“沟通成本”两大部分。根据实践下来的经验，再借助“二八定律”统计支撑分析，技术成本约占两成，剩下的八成是沟通成本。其中，针对这八成的沟通成本，我再次尝试了进一步的继续细分。早在两年前，我把沟通分为内部沟通和外部沟通，还是结合自己经验和借助了“二八定律”分析，内部沟通占八成、外部沟通占两成。经过了两年的模型指导实践发现，这个沟通的划分方式有点问题，在执行过程有点吃力不讨好的反馈。既然发现了问题，下一步就是改进。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;对于沟通的归类，我重新思考、观察和学习了也有好一段时间，我还专门还重新复习了《人性的弱点》和彼得·德鲁克系列的多本书籍，也算是功夫不负有心人。特别是《人性的弱点》和《21世纪的管理挑战》这两本宝典给了我沟通模型假设的信心。我再次对沟通分类进行了假设，把沟通分为个体之间的外在沟通（简称“个体沟通”）和自我内在之间的沟通（简称“自我沟通”）。还是借助“二八定律”进行成本分析，个体沟通占两成，自我沟通占八成。有了假设模型的指导，我就知道往哪个方向去实践和努力了。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;人的精力是有限的，无论生活还是工作，战略上的模型指导非常重要，这是计划和实践的主要依据，也是一个人综合认知能力的体现。技术领域出身的自己，曾经在两成的技术成本里花费了我八成的精力，这就是我成长的试错成本。还好，曾经八成精力的付出，还是比较厚实地巩固了项目成本上那两的技术成本。让我现在可以解脱九成的精力放在沟通成本的重组上。关于个体之间的沟通成本，我可以通过完善组织架构和流程规范手段打通从内到外，再从外到内的沟通过程，以“如何做”的角度做好分工的定义，让大家更加明确自己的组织定位，尽量减少不必要的矛盾。“如何做”其实更多是“体力劳动者”的分工模式，要发挥好组织定义的分工效能，还需我们这些“知识工作者”的自我管理能力，这都是我实践和学习的进一步假设。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;在这个模型上，我找到了自己的价值。在技术上，比我强的人一抓一大把。在组织架构和项目流程上，我敢拍着胸口说，我懂得不多，因此，在我之上的人数不胜数。但这些能力在总成项目成本占比上还不算高，而且效能体现还是基于“自我沟通”的效果之上。因此，我看到自身的价值发挥点在于尝试唤醒那些装睡的人，以及扭转一些面对问题就直喊做不到和不好做的人，协助他们从“我要如何做”的传统观念，转变到“我的任务是什么”的新世纪观念上来。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;改变一个人，是几乎不可能的事。所以说，想提高点利润去赚点生活费还真不容易。《隐性亿万富翁》的Glenn说，他的创业思路只要两个要素：一个市场需要的好商品和一个好团队。虽然是综艺节目，但这种大白话还是值得参考。好的商品很重要，但我目前最迫切的还是一个好团队。有一个观点我不知道是不是受德鲁克的影响，还是自己实践得来的感知，又或者两者都有。对于人力来说，我更愿意理解为资源，而不是成本。这两种思维背后是两种完全不同的管理模式。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;把人力看作资源的改变，是需要一定的格局和胆量，这是我最需要提升的地方。思维、格局和胆量的不匹配让自己吃了不少苦头，心里看着前方，却迟迟原地踏步，甚至还往后退了退。没事，这也是一个正常的成长过程。但总的来说，无论是思维的建设还是实践的总结，这个过程所给到的信息反馈让我看到的方向还是一致的。没有太多别扭的地方，就算有，那也是我在努力去改变实践过程所带来的别扭而已。这一点难受，我还是可以区分。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;对于管理上的关注，不是因为自己有明确的管理定位，而是从当前自身能做的贡献点出发， 这个问题的解决能力成为了我当前价值提升的一个瓶颈。换句话说，也是我人生进阶的一个里程碑。本质一点讲，是我自身认知系统需要升级的地方。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;改善“自我沟通成本”难不难？这个问题是我实践的起点。首先，我不能成为第一个面对困难就说不好做或做不好的人。就这样一个起点过程的改变就很让人痛苦。当所有人都在抱怨和发飙，唯独自己决不能乌合之众，而且还要冷静、和谐、耐心和真诚沟通，站在对方的角度，用同理心为对方着想。得到别人的信任后，还需要用自身过硬的专业知识和丰富的人生阅历去引导正确。所以说，正确不是万能的，要让正确发挥正确的价值，还需要真正符合人性的正确手段。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;基于新模型的实践过程中，我发现职位很容易让人有一种“鱼和熊掌”之意。就好像做了管理，就不用学习技术；做技术的，管理跟自己无关；卖东西的，跟做东西毫无血缘关系一样。硬要把口水、文档和代码看作势不三立的对象。而且，嘴里还喷着各种诸如商业思维、管理思维以及技术思维的假装认知，作为自己不愿意学习更多的借口。 价值导向是没错，但问题就出现在用偷懒去实践价值的矛盾。无论做什么事情，本质只有一个，越往价值核心靠近，就越需要刻苦和勤奋。忽略这一点的，就是对自己人生最大的谎言。之所以说“把人力看作资源”的思维转变的难度很大，因为这是跟自身“影响力”的价值体现有关，但这又是不得不自我改变和挑战的一点，我也开始逐渐明白所谓的“21世纪的管理挑战”。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;“自我沟通”这一点成本的隐藏性还是比较高，隐藏不在于它不够透明，而在于大家都在“装睡”。哪怕这一次的沟通模型假设还是存在问题，但“自我沟通”的效能价值决不可忽视。就像德鲁克所说：“随着知识工作者及生产效率成为我们面临的关键性问题，它们必将在几十年内给现行经济体制的结构和性质带来根本性的变革”，这是我们每个人都非常值得深思的一句话。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 13 Apr 2020 13:46:00 +0000</pubDate>
<dc:creator>wc的一些事一些情</dc:creator>
<og:description>在成本管理上，我把一个软件项目的成本主要划分为“技术成本”和“沟通成本”两大部分。根据实践下来的经验，再借助“二八定律”统计支撑分析，技术成本约占两成，剩下的八成是沟通成本。其中，针对这八成的沟通成本</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wcd144140/p/12694175.html</dc:identifier>
</item>
</channel>
</rss>