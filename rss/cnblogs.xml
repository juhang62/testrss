<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>机器学习笔记(5)  KNN算法 - sdu20112013</title>
<link>http://www.cnblogs.com/sdu20112013/p/10171425.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sdu20112013/p/10171425.html</guid>
<description>&lt;p&gt;这篇其实应该作为机器学习的第一篇笔记的,但是在刚开始学习的时候,我还没有用博客记录笔记的打算.所以也就想到哪写到哪了.&lt;/p&gt;
&lt;p&gt;你在网上搜索机器学习系列文章的话,大部分都是以KNN（k nearest neighbors）作为第一篇入门的,因为这个算法实在是太简单了.简单到其实没啥可说的.&lt;/p&gt;
&lt;p&gt;                                       &lt;img src=&quot;https://img2018.cnblogs.com/blog/583030/201812/583030-20181225203204218-1963305370.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;问题：已知正方形和三角形两种分类,现在来了个圆,问：应该归到正方形更合适还是三角形更合适？&lt;/p&gt;
&lt;p&gt;算法的思想很朴素,假设我们有一个M*N的矩阵(M个样本,每个样本有N个特征).当我们来了一个新的样本test,我们要去判断这个样本属于什么类别,我们去计算test与M个样本中每一个样本的距离,选取最近的K个样本,投票出test的类别.&lt;/p&gt;

&lt;p&gt;前面说了,通过判断两个样本之间的距离(或者说N维空间中的2个点之间的距离),来判断两个样本的相似程度. &lt;span&gt;那问题来了,我们如何表达&quot;两个点之间的距离呢&quot;？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;二维空间中距离：$$\sqrt {(x^{(a)}-x^{(b)})^2+(y^{(a)}-y^{(b)})^2}$$&lt;/p&gt;
&lt;p&gt;三维空间中距离：$$\sqrt {(x^{(a)}-x^{(b)})^2+(y^{(a)}-y^{(b)})^2+(z^{(a)}-z^{(b)})^2}$$&lt;/p&gt;
&lt;p&gt;推而广之,N维空间中距离：$$\sqrt {(x_1^{(a)}-x_1^{(b)})^2+(x_2^{(a)}-x_2^{(b)})^2+…+(x_n^{(a)}-x_n^{(b)})^2} =\sqrt {\sum_{i=1}^n(x_i^{(a)}-x_i^{(b)})^2}$$&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这就是我们熟知的欧拉距离.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;实际上,如何度量距离,还有&lt;span&gt;曼哈顿距离&lt;/span&gt;,$$\sum_{i=1}^n |X_i^{(a)}-X_i^{(b)}|$$&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;欧拉距离和曼哈顿距离都可以统一表达为&lt;span&gt;明科夫斯基距离&lt;/span&gt;$$（\sum_{i=1}^n |X_i^{(a)}-X_i^{(b)}|^p）^\frac 1 p$$,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当p=1时,即是曼哈顿距离,当p=2时,即是欧拉距离.sklearn中默认的p=2.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;事实上,距离的表达不仅仅是明科夫斯基距离,还有很多种,就不一一介绍了：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Metrics intended for real-valued vector spaces:&lt;/strong&gt;&lt;/p&gt;
&lt;table class=&quot;docutils&quot; border=&quot;1&quot;&gt;&lt;colgroup&gt;&lt;col width=&quot;19%&quot;/&gt;&lt;col width=&quot;27%&quot;/&gt;&lt;col width=&quot;11%&quot;/&gt;&lt;col width=&quot;42%&quot;/&gt;&lt;/colgroup&gt;&lt;tbody valign=&quot;top&quot; readability=&quot;3&quot;&gt;&lt;tr class=&quot;row-odd&quot;&gt;&lt;td&gt;identifier&lt;/td&gt;
&lt;td&gt;class name&lt;/td&gt;
&lt;td&gt;args&lt;/td&gt;
&lt;td&gt;distance function&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;row-even&quot;&gt;&lt;td&gt;“euclidean”&lt;/td&gt;
&lt;td&gt;EuclideanDistance&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;&lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;sqrt(sum((x &lt;span class=&quot;pre&quot;&gt;- &lt;span class=&quot;pre&quot;&gt;y)^2))&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;row-odd&quot;&gt;&lt;td&gt;“manhattan”&lt;/td&gt;
&lt;td&gt;ManhattanDistance&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;&lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;sum(|x &lt;span class=&quot;pre&quot;&gt;- &lt;span class=&quot;pre&quot;&gt;y|)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;row-even&quot;&gt;&lt;td&gt;“chebyshev”&lt;/td&gt;
&lt;td&gt;ChebyshevDistance&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;&lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;max(|x &lt;span class=&quot;pre&quot;&gt;- &lt;span class=&quot;pre&quot;&gt;y|)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;row-odd&quot;&gt;&lt;td&gt;“minkowski”&lt;/td&gt;
&lt;td&gt;MinkowskiDistance&lt;/td&gt;
&lt;td&gt;p&lt;/td&gt;
&lt;td&gt;&lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;sum(|x &lt;span class=&quot;pre&quot;&gt;- &lt;span class=&quot;pre&quot;&gt;y|^p)^(1/p)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;row-even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;“wminkowski”&lt;/td&gt;
&lt;td&gt;WMinkowskiDistance&lt;/td&gt;
&lt;td&gt;p, w&lt;/td&gt;
&lt;td&gt;&lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;sum(|w &lt;span class=&quot;pre&quot;&gt;* &lt;span class=&quot;pre&quot;&gt;(x &lt;span class=&quot;pre&quot;&gt;- &lt;span class=&quot;pre&quot;&gt;y)|^p)^(1/p)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;row-odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;“seuclidean”&lt;/td&gt;
&lt;td&gt;SEuclideanDistance&lt;/td&gt;
&lt;td&gt;V&lt;/td&gt;
&lt;td&gt;&lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;sqrt(sum((x &lt;span class=&quot;pre&quot;&gt;- &lt;span class=&quot;pre&quot;&gt;y)^2 &lt;span class=&quot;pre&quot;&gt;/ &lt;span class=&quot;pre&quot;&gt;V))&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;row-even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;“mahalanobis”&lt;/td&gt;
&lt;td&gt;MahalanobisDistance&lt;/td&gt;
&lt;td&gt;V or VI&lt;/td&gt;
&lt;td&gt;&lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;sqrt((x &lt;span class=&quot;pre&quot;&gt;- &lt;span class=&quot;pre&quot;&gt;y)' &lt;span class=&quot;pre&quot;&gt;V^-1 &lt;span class=&quot;pre&quot;&gt;(x &lt;span class=&quot;pre&quot;&gt;- &lt;span class=&quot;pre&quot;&gt;y))&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;Metrics intended for integer-valued vector spaces:&lt;/strong&gt; Though intended for integer-valued vectors, these are also valid metrics in the case of real-valued vectors.&lt;/p&gt;
&lt;table class=&quot;docutils&quot; border=&quot;1&quot;&gt;&lt;colgroup&gt;&lt;col width=&quot;18%&quot;/&gt;&lt;col width=&quot;27%&quot;/&gt;&lt;col width=&quot;55%&quot;/&gt;&lt;/colgroup&gt;&lt;tbody valign=&quot;top&quot; readability=&quot;3.5&quot;&gt;&lt;tr class=&quot;row-odd&quot;&gt;&lt;td&gt;identifier&lt;/td&gt;
&lt;td&gt;class name&lt;/td&gt;
&lt;td&gt;distance function&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;row-even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;“hamming”&lt;/td&gt;
&lt;td&gt;HammingDistance&lt;/td&gt;
&lt;td&gt;&lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;N_unequal(x, &lt;span class=&quot;pre&quot;&gt;y) &lt;span class=&quot;pre&quot;&gt;/ &lt;span class=&quot;pre&quot;&gt;N_tot&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;row-odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;“canberra”&lt;/td&gt;
&lt;td&gt;CanberraDistance&lt;/td&gt;
&lt;td&gt;&lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;sum(|x &lt;span class=&quot;pre&quot;&gt;- &lt;span class=&quot;pre&quot;&gt;y| &lt;span class=&quot;pre&quot;&gt;/ &lt;span class=&quot;pre&quot;&gt;(|x| &lt;span class=&quot;pre&quot;&gt;+ &lt;span class=&quot;pre&quot;&gt;|y|))&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;row-even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;“braycurtis”&lt;/td&gt;
&lt;td&gt;BrayCurtisDistance&lt;/td&gt;
&lt;td&gt;&lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;sum(|x &lt;span class=&quot;pre&quot;&gt;- &lt;span class=&quot;pre&quot;&gt;y|) &lt;span class=&quot;pre&quot;&gt;/ &lt;span class=&quot;pre&quot;&gt;(sum(|x|) &lt;span class=&quot;pre&quot;&gt;+ &lt;span class=&quot;pre&quot;&gt;sum(|y|))&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;&lt;span&gt;知道如何计算距离了,似乎我们的KNN已经可以工作了,但是,问题又来了&lt;/span&gt;,考虑一下这个场景：我们选取K=3，然鹅,好巧不巧的,最终算出来的最近的3个距离是一样的,而这3个样本又分别属于不同的类别,这我们要怎么归类呢？如果你觉得这个例子比较极端,那考虑一下这个场景：我们通过计算找出了距离待测样本最近的3个点,假设这3个点p1,p2,p3分别属于类别A，B，B. 但是,待测样本点距离点p1的距离为1,距离p2的距离为100，距离p3的距离为50.这个时候显然待测点和p1是极为接近的,把待测样本归类到A是更合理的.而由p1,p2,p3投票的话会把待测样本归类为B。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这就引入了权重(weight)的概念.由于p1和待测样本点距离极为接近,所以我们应该把p1的投票权重提高.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;sklearn中的KNeighborsClassifier的weight参数有以下3个取值.&lt;/p&gt;
&lt;ul class=&quot;last simple&quot;&gt;&lt;li&gt;‘uniform’ : uniform weights. All points in each neighborhood are weighted equally.&lt;/li&gt;
&lt;li&gt;‘distance’ : weight points by the inverse of their distance. in this case, closer neighbors of a query point will have a greater influence than neighbors which are further away.&lt;/li&gt;
&lt;li&gt;[callable] : a user-defined function which accepts an array of distances, and returns an array of the same shape containing the weights.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;uniform 代表等权重. sklean中默认取值是uniform。&lt;/p&gt;
&lt;p&gt;distance代表用距离的倒数作为权重.&lt;/p&gt;
&lt;p&gt;callable代表用户自定义函数.&lt;/p&gt;

&lt;p&gt;以下是sklearn中KNeighborsClassifier的具体参数.&lt;/p&gt;
&lt;blockquote readability=&quot;70.902124114952&quot;&gt;
&lt;p&gt;&lt;em class=&quot;property&quot;&gt;class &lt;/em&gt;&lt;code class=&quot;descclassname&quot;&gt;sklearn.neighbors.&lt;/code&gt;&lt;code class=&quot;descname&quot;&gt;KNeighborsClassifier&lt;/code&gt;&lt;span class=&quot;sig-paren&quot;&gt;(&lt;em&gt;n_neighbors=5&lt;/em&gt;, &lt;em&gt;weights=’uniform’&lt;/em&gt;, &lt;em&gt;algorithm=’auto’&lt;/em&gt;, &lt;em&gt;leaf_size=30&lt;/em&gt;, &lt;em&gt;p=2&lt;/em&gt;, &lt;em&gt;metric=’minkowski’&lt;/em&gt;, &lt;em&gt;metric_params=None&lt;/em&gt;, &lt;em&gt;n_jobs=None&lt;/em&gt;, &lt;em&gt;**kwargs&lt;/em&gt;&lt;span class=&quot;sig-paren&quot;&gt;)&lt;a class=&quot;reference external&quot; href=&quot;https://github.com/scikit-learn/scikit-learn/blob/7389dba/sklearn/neighbors/classification.py#L23&quot;&gt;&lt;span class=&quot;viewcode-link&quot;&gt;[source]&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;n_neighbors&lt;/strong&gt; &lt;span class=&quot;classifier-delimiter&quot;&gt;: &lt;span class=&quot;classifier&quot;&gt;int, optional (default = 5)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;first last&quot;&gt;Number of neighbors to use by default for &lt;a class=&quot;reference internal&quot; title=&quot;sklearn.neighbors.KNeighborsClassifier.kneighbors&quot; href=&quot;https://scikit-learn.org/stable/modules/generated/sklearn.neighbors.KNeighborsClassifier.html#sklearn.neighbors.KNeighborsClassifier.kneighbors&quot;&gt;&lt;code class=&quot;xref py py-meth docutils literal&quot;&gt;kneighbors&lt;/code&gt;&lt;/a&gt; queries.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;weights&lt;/strong&gt; &lt;span class=&quot;classifier-delimiter&quot;&gt;: &lt;span class=&quot;classifier&quot;&gt;str or callable, optional (default = ‘uniform’)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;first&quot;&gt;weight function used in prediction. Possible values:&lt;/p&gt;
&lt;ul class=&quot;last simple&quot;&gt;&lt;li&gt;‘uniform’ : uniform weights. All points in each neighborhood are weighted equally.&lt;/li&gt;
&lt;li&gt;‘distance’ : weight points by the inverse of their distance. in this case, closer neighbors of a query point will have a greater influence than neighbors which are further away.&lt;/li&gt;
&lt;li&gt;[callable] : a user-defined function which accepts an array of distances, and returns an array of the same shape containing the weights.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;algorithm&lt;/strong&gt; &lt;span class=&quot;classifier-delimiter&quot;&gt;: &lt;span class=&quot;classifier&quot;&gt;{‘auto’, ‘ball_tree’, ‘kd_tree’, ‘brute’}, optional&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;first&quot;&gt;Algorithm used to compute the nearest neighbors:&lt;/p&gt;
&lt;ul class=&quot;simple&quot;&gt;&lt;li&gt;‘ball_tree’ will use &lt;a class=&quot;reference internal&quot; title=&quot;sklearn.neighbors.BallTree&quot; href=&quot;https://scikit-learn.org/stable/modules/generated/sklearn.neighbors.BallTree.html#sklearn.neighbors.BallTree&quot;&gt;&lt;code class=&quot;xref py py-class docutils literal&quot;&gt;BallTree&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;‘kd_tree’ will use &lt;a class=&quot;reference internal&quot; title=&quot;sklearn.neighbors.KDTree&quot; href=&quot;https://scikit-learn.org/stable/modules/generated/sklearn.neighbors.KDTree.html#sklearn.neighbors.KDTree&quot;&gt;&lt;code class=&quot;xref py py-class docutils literal&quot;&gt;KDTree&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;‘brute’ will use a brute-force search.&lt;/li&gt;
&lt;li&gt;‘auto’ will attempt to decide the most appropriate algorithm based on the values passed to &lt;a class=&quot;reference internal&quot; title=&quot;sklearn.neighbors.KNeighborsClassifier.fit&quot; href=&quot;https://scikit-learn.org/stable/modules/generated/sklearn.neighbors.KNeighborsClassifier.html#sklearn.neighbors.KNeighborsClassifier.fit&quot;&gt;&lt;code class=&quot;xref py py-meth docutils literal&quot;&gt;fit&lt;/code&gt;&lt;/a&gt;method.&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;last&quot;&gt;Note: fitting on sparse input will override the setting of this parameter, using brute force.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;leaf_size&lt;/strong&gt; &lt;span class=&quot;classifier-delimiter&quot;&gt;: &lt;span class=&quot;classifier&quot;&gt;int, optional (default = 30)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;first last&quot;&gt;Leaf size passed to BallTree or KDTree. This can affect the speed of the construction and query, as well as the memory required to store the tree. The optimal value depends on the nature of the problem.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;p&lt;/strong&gt; &lt;span class=&quot;classifier-delimiter&quot;&gt;: &lt;span class=&quot;classifier&quot;&gt;integer, optional (default = 2)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;first last&quot;&gt;Power parameter for the Minkowski metric. When p = 1, this is equivalent to using manhattan_distance (l1), and euclidean_distance (l2) for p = 2. For arbitrary p, minkowski_distance (l_p) is used.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;metric&lt;/strong&gt; &lt;span class=&quot;classifier-delimiter&quot;&gt;: &lt;span class=&quot;classifier&quot;&gt;string or callable, default ‘minkowski’&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;first last&quot;&gt;the distance metric to use for the tree. The default metric is minkowski, and with p=2 is equivalent to the standard Euclidean metric. See the documentation of the DistanceMetric class for a list of available metrics.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;metric_params&lt;/strong&gt; &lt;span class=&quot;classifier-delimiter&quot;&gt;: &lt;span class=&quot;classifier&quot;&gt;dict, optional (default = None)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;first last&quot;&gt;Additional keyword arguments for the metric function.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;n_jobs&lt;/strong&gt; &lt;span class=&quot;classifier-delimiter&quot;&gt;: &lt;span class=&quot;classifier&quot;&gt;int or None, optional (default=None)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;first last&quot;&gt;The number of parallel jobs to run for neighbors search. &lt;code class=&quot;docutils literal&quot;&gt;None&lt;/code&gt; means 1 unless in a &lt;a class=&quot;reference external&quot; title=&quot;(in joblib v0.13.0)&quot; href=&quot;https://joblib.readthedocs.io/en/latest/parallel.html#joblib.parallel_backend&quot;&gt;&lt;code class=&quot;xref py py-obj docutils literal&quot;&gt;joblib.parallel_backend&lt;/code&gt;&lt;/a&gt; context. &lt;code class=&quot;docutils literal&quot;&gt;-1&lt;/code&gt; means using all processors. See &lt;a class=&quot;reference internal&quot; href=&quot;https://scikit-learn.org/stable/glossary.html#term-n-jobs&quot;&gt;Glossary&lt;/a&gt; for more details. Doesn’t affect &lt;a class=&quot;reference internal&quot; title=&quot;sklearn.neighbors.KNeighborsClassifier.fit&quot; href=&quot;https://scikit-learn.org/stable/modules/generated/sklearn.neighbors.KNeighborsClassifier.html#sklearn.neighbors.KNeighborsClassifier.fit&quot;&gt;&lt;code class=&quot;xref py py-meth docutils literal&quot;&gt;fit&lt;/code&gt;&lt;/a&gt; method.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; X = [[0], [1], [2], [3&lt;span&gt;]]
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; y = [0, 0, 1, 1&lt;span&gt;]
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;from&lt;/span&gt; sklearn.neighbors &lt;span&gt;import&lt;/span&gt;&lt;span&gt; KNeighborsClassifier
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; neigh = KNeighborsClassifier(n_neighbors=3&lt;span&gt;)
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; neigh.fit(X, y) 
KNeighborsClassifier(...)
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;print&lt;/span&gt;(neigh.predict([[1.1&lt;span&gt;]]))
[0]
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;print&lt;/span&gt;(neigh.predict_proba([[0.9&lt;span&gt;]]))
[[&lt;/span&gt;0.66666667 0.33333333]]
&lt;/pre&gt;&lt;/div&gt;

&lt;hr/&gt;&lt;p&gt;到了这里,是不是觉得大功告成了呢？等等,还有问题...........&lt;/p&gt;
&lt;p&gt;思考下这个场景：（一时间没有想出特别合适的例子,凑合看吧）&lt;/p&gt;
&lt;p&gt;我们根据头发长度和指甲长度去判断一个人是男是女&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/583030/201812/583030-20181225224009283-234508646.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;发现什么问题没有,两列数据的量级不在一个尺度上.所以在我们计算距离时,指甲长度的影响几乎可以忽略不计了.这显然不是我们想要的结果.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里就引入了一个话题：数据的归一化.  数据归一化将所有的数据映射到同一尺度.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最值归一化&lt;/strong&gt;，既用下面的公式把所有数据映射到0-1之间：&lt;/p&gt;
&lt;p&gt;$$x_{scale} = \frac {x - x_{min}} {x_{max} - x_{min}}$$&lt;/p&gt;
&lt;p&gt;最值归一化虽然简便，但是是有一定适用范围的，那就是适用于样本数据有明显分布边界的情况，并且最值归一化太容易受异常样本点的影响了,实际并不常用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;均值方差归一化&lt;/strong&gt;，该方法就是把所有数据归一到均值为0方差为1的分布中，公式如下：&lt;/p&gt;
&lt;p&gt;$$x_{scale} = \frac {x - x_{mean}} S$$&lt;/p&gt;
&lt;p&gt;就是将每个值减去均值，然后除以方差，通过均值方差归一化后的数据不一定在0-1之间，但是他们的均值为0，方差为1。&lt;/p&gt;
&lt;p&gt;关于两种归一化的适用场景,优缺点等请戳&lt;a href=&quot;https://www.jianshu.com/p/540d56ef350f&quot; target=&quot;_blank&quot;&gt;这里.&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;至此,KNN使用时需要注意的一些点也就写的差不多了,希望对大家有所启发.&lt;/p&gt;
</description>
<pubDate>Tue, 25 Dec 2018 15:35:00 +0000</pubDate>
<dc:creator>sdu20112013</dc:creator>
<og:description>这篇其实应该作为机器学习的第一篇笔记的,但是在刚开始学习的时候,我还没有用博客记录笔记的打算.所以也就想到哪写到哪了. 你在网上搜索机器学习系列文章的话,大部分都是以KNN（k nearest nei</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sdu20112013/p/10171425.html</dc:identifier>
</item>
<item>
<title>Vuex入门 - 格子熊</title>
<link>http://www.cnblogs.com/karthuslorin/p/10169651.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/karthuslorin/p/10169651.html</guid>
<description>&lt;p&gt;在 &lt;code&gt;vue&lt;/code&gt; 开发中，组件通信一直是一大痛点。&lt;/p&gt;
&lt;p&gt;当项目是很简单的 &lt;code&gt;SPA&lt;/code&gt; 或者多入口项目时，可以靠着 &lt;code&gt;vue&lt;/code&gt; 自带的 &lt;code&gt;prop/$emit&lt;/code&gt; 进行组件通信；规模再大一些，可以搭配使用 &lt;code&gt;bus&lt;/code&gt; 总线进行兄弟组件通信；项目再大一些，出现更复杂的组件关系时，复杂的组件通信可以让你写得怀疑人生。&lt;/p&gt;
&lt;p&gt;万幸的是， &lt;code&gt;vue&lt;/code&gt; 官方出品了 &lt;code&gt;vuex&lt;/code&gt; ，通过全局式的状态管理，解决了这一痛点。&lt;/p&gt;
&lt;p&gt;虽然 &lt;code&gt;vuex&lt;/code&gt; 很好用，但是，很多小伙伴和我吐槽 &lt;code&gt;vuex&lt;/code&gt; 的文档和 &lt;code&gt;vue-ssr&lt;/code&gt; 的文档一样，让人看得一脸懵逼。&lt;/p&gt;
&lt;p&gt;好吧，下面就让我来带着大家一起入门 &lt;code&gt;vuex&lt;/code&gt; 。&lt;/p&gt;
&lt;h3 id=&quot;安装并引入&quot;&gt;安装并引入&lt;/h3&gt;
&lt;p&gt;正常情况下，我们使用 &lt;code&gt;vue-cli3&lt;/code&gt; 生成项目时，可以选择集成 &lt;code&gt;vuex&lt;/code&gt; 到项目中。此时， &lt;code&gt;vue-cli3&lt;/code&gt; 会自动安装 &lt;code&gt;vuex&lt;/code&gt; ，并在 &lt;code&gt;src&lt;/code&gt; 文件夹下生成 &lt;code&gt;store.js&lt;/code&gt; 完成 &lt;code&gt;vuex&lt;/code&gt; 的引入和配置。&lt;/p&gt;
&lt;p&gt;但是，很多同学并没有使用 &lt;code&gt;vue-cli3&lt;/code&gt; 或者生成项目时没有选择集成 &lt;code&gt;vuex&lt;/code&gt; 。此时，就只能手动安装并引入 &lt;code&gt;vuex&lt;/code&gt; 了。&lt;/p&gt;
&lt;h4 id=&quot;安装&quot;&gt;安装&lt;/h4&gt;
&lt;p&gt;由于 &lt;code&gt;vuex&lt;/code&gt; 是用于全局状态管理的，所以，它不仅仅作用于开发环境，而且还要用于生产环境。&lt;/p&gt;
&lt;p&gt;显而易见，安装 &lt;code&gt;vuex&lt;/code&gt; 应该使用 &lt;code&gt;-S&lt;/code&gt; 即 &lt;code&gt;--save&lt;/code&gt; 命令。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;npm install vuex -S&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;引入&quot;&gt;引入&lt;/h4&gt;
&lt;p&gt;类似于 &lt;code&gt;vue-cli3&lt;/code&gt; 生成的项目，我们在 &lt;code&gt;src&lt;/code&gt; 文件夹下新建 &lt;code&gt;store.js&lt;/code&gt; ，并在其中写入：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// store.js
import Vue from 'vue'
import Vuex from 'vuex'

Vue.use(Vuex)

export default new Vuex.Store({})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后，我们只需要在 &lt;code&gt;vue&lt;/code&gt; 实例中引入 &lt;code&gt;store.js&lt;/code&gt; 中的 &lt;code&gt;Vuex.Store&lt;/code&gt; 实例即可：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// main.js
import Vue from 'vue'
import App from './App.vue'
import router from './router'
import store from './store'

Vue.config.productionTip = false

new Vue({
  router,
  // 引入store
  store,
  render: h =&amp;gt; h(App)
}).$mount('#app')&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;vuex的使用&quot;&gt;Vuex的使用&lt;/h3&gt;
&lt;p&gt;完成了 &lt;code&gt;vuex&lt;/code&gt; 的安装和引入，接下来我们进入 &lt;code&gt;Vuex&lt;/code&gt; 的使用。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vuex&lt;/code&gt; 中有三要素： &lt;code&gt;state&lt;/code&gt;， &lt;code&gt;mutation&lt;/code&gt; 以及 &lt;code&gt;action&lt;/code&gt; 。它们之间的关系可以用官网那张著名的图来表示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://vuex.vuejs.org/vuex.png&quot; alt=&quot;vuex&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;state&quot;&gt;State&lt;/h4&gt;
&lt;p&gt;简单来说， &lt;code&gt;state&lt;/code&gt; 表示状态，类似于 &lt;code&gt;vue&lt;/code&gt; 中的 &lt;code&gt;data&lt;/code&gt; （其实本质上就是差不多的， &lt;code&gt;vuex&lt;/code&gt; 在 &lt;code&gt;vue&lt;/code&gt; 的 &lt;code&gt;beforeCreate&lt;/code&gt; 钩子中将 &lt;code&gt;state&lt;/code&gt; 混入进 &lt;code&gt;data&lt;/code&gt;）。但是，它们又有很大的不同： 在使用者看来， &lt;code&gt;state&lt;/code&gt; 是全局的，这得益于 &lt;code&gt;vuex&lt;/code&gt; 的设计理念——单一状态树。这些我将在后几篇文章中详细，现在我们只需要知道 &lt;code&gt;state&lt;/code&gt; 是类似于全局下的 &lt;code&gt;data&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;接下来我们通过一个简单例子来感受下 &lt;code&gt;state&lt;/code&gt; ：&lt;/p&gt;
&lt;p&gt;首先，我们需要修改 &lt;code&gt;store.js&lt;/code&gt; 文件，配置 &lt;code&gt;state&lt;/code&gt; 。可以看到，我们在生成 &lt;code&gt;Vuex.Store&lt;/code&gt; 实例时传入了实例化选项对象，对象包含一个 &lt;code&gt;state&lt;/code&gt; 属性， &lt;code&gt;state&lt;/code&gt; 对象的属性就是我们定义的全局状态。&lt;/p&gt;
&lt;p&gt;此时，我们定义了一个全局状态——&lt;code&gt;count&lt;/code&gt; ，并将其的初始值设为&lt;code&gt;1&lt;/code&gt; 。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// store.js
import Vue from 'vue'
import Vuex from 'vuex'

Vue.use(Vuex)

export default new Vuex.Store({
  // 添加state
  state: {
    count: 1
  }
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来，我们需要在组件中引用 &lt;code&gt;count&lt;/code&gt;，由于它是全局状态，我们可以在任何一个组件中使用。为了展示其威力，我们在两个不同的组件中使用它。&lt;/p&gt;
&lt;p&gt;首先我们在 &lt;code&gt;App.vue&lt;/code&gt; 中使用它：&lt;/p&gt;
&lt;p&gt;在模板中，我们使用 &lt;code&gt;$store.state.count&lt;/code&gt; 引入该全局状态，没错，使用它就是那么简单，只需要 以 &lt;code&gt;$store.state.key&lt;/code&gt; 的形式调用。&lt;/p&gt;
&lt;pre class=&quot;vue&quot;&gt;
&lt;code&gt;// App.vue
&amp;lt;template&amp;gt;
  &amp;lt;div id=&quot;app&quot;&amp;gt;
    &amp;lt;div id=&quot;nav&quot;&amp;gt;
      {{$store.state.count}}
      &amp;lt;router-link to=&quot;/&quot;&amp;gt;Home&amp;lt;/router-link&amp;gt; |
      &amp;lt;router-link to=&quot;/about&quot;&amp;gt;About&amp;lt;/router-link&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;router-view/&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以发现， &lt;code&gt;Home&lt;/code&gt; 前多出了一个 &lt;code&gt;1&lt;/code&gt; ，这代表着我们成功引入了全局状态 &lt;code&gt;count&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;接下来我们在 &lt;code&gt;Home.vue&lt;/code&gt; 的子组件 &lt;code&gt;HelloWorld.vue&lt;/code&gt; 中引入 &lt;code&gt;count&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;相同的引用方式： &lt;code&gt;$store.state.count&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;vue&quot;&gt;
&lt;code&gt;// HelloWorld.vue
&amp;lt;template&amp;gt;
  &amp;lt;div class=&quot;hello&quot;&amp;gt;
    {{$store.state.count}}
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以发现，页面中又多出了一个 &lt;code&gt;1&lt;/code&gt; ，代表着我们又一次引用成功。现在，是不是已经感受到了 &lt;code&gt;vuex&lt;/code&gt; 的威力？&lt;/p&gt;
&lt;h4 id=&quot;mutation&quot;&gt;Mutation&lt;/h4&gt;
&lt;p&gt;但是，上面的示例有个问题，那就是全局状态是静态的。如果在实际应用场景中，一般来说，会经常更改状态。&lt;/p&gt;
&lt;p&gt;有的同学会说，我们直接在方法中修改 &lt;code&gt;this.$store.state.key&lt;/code&gt; 的值不就行了吗？&lt;/p&gt;
&lt;p&gt;不好意思，当然是不行的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;state&lt;/code&gt; 和 &lt;code&gt;data&lt;/code&gt; 的另一大区别在于，你不能直接改变 &lt;code&gt;state&lt;/code&gt; 。改变 store 中的状态的唯一途径就是显式地提交 (&lt;code&gt;commit&lt;/code&gt;) &lt;code&gt;mutation&lt;/code&gt;。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。&lt;/p&gt;
&lt;p&gt;简而言之，我们把 &lt;code&gt;mutation&lt;/code&gt; 当做接收 &lt;code&gt;state&lt;/code&gt; 作为参数并修改 &lt;code&gt;state&lt;/code&gt; 的自定义事件即可，上一段所说的 &lt;code&gt;commit&lt;/code&gt; 就是触发 &lt;code&gt;mutaion&lt;/code&gt; 这个自定义事件的方法。&lt;/p&gt;
&lt;p&gt;光说不练假把式，接下来，我们对为 &lt;code&gt;vuex&lt;/code&gt; 添加上 &lt;code&gt;mutation&lt;/code&gt; ，实现 &lt;code&gt;state&lt;/code&gt; 的动态改变：&lt;/p&gt;
&lt;p&gt;首先，当然是修改生成 &lt;code&gt;Vuex.Store&lt;/code&gt; 示例的选项对象，为其添加 &lt;code&gt;mutations&lt;/code&gt; 。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;import Vue from 'vue'
import Vuex from 'vuex'

Vue.use(Vuex)

export default new Vuex.Store({
  state: {
    count: 1
  },
  // 添加mutation
  mutations: {
    increment (state) {
      state.count++
    }
  }
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上面的代码中，我们添加了一个名为 &lt;code&gt;increment&lt;/code&gt; 的 &lt;code&gt;mutation&lt;/code&gt; 。完成了自定义事件，接下来，我们只需要在组件中对 &lt;code&gt;mutation&lt;/code&gt; 进行触发即可。&lt;/p&gt;
&lt;p&gt;我们在 &lt;code&gt;HelloWorld.vue&lt;/code&gt; 添加一个按钮，每次点击触发一次 &lt;code&gt;increment&lt;/code&gt; 这个 &lt;code&gt;mutation&lt;/code&gt; 。可以发现，触发方式很简单，只需要调用 &lt;code&gt;store&lt;/code&gt; 自带的 &lt;code&gt;commit&lt;/code&gt; 方法，其中参数为需要触发的 &lt;code&gt;mutation&lt;/code&gt; 的名称。&lt;/p&gt;
&lt;pre class=&quot;vue&quot;&gt;
&lt;code&gt;// HelloWorld.vue
&amp;lt;template&amp;gt;
  &amp;lt;div class=&quot;hello&quot;&amp;gt;
    &amp;lt;div&amp;gt;{{$store.state.count}}&amp;lt;/div&amp;gt;
    &amp;lt;button @click=&quot;$store.commit('increment')&quot;&amp;gt;修改count&amp;lt;/button&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;点击页面中的按钮，你会发现，页面中的两个 &lt;code&gt;count&lt;/code&gt; 都同时增加了1，说明我们成功实现了 &lt;code&gt;state&lt;/code&gt; 的动态修改。&lt;/p&gt;
&lt;h4 id=&quot;action&quot;&gt;Action&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;action&lt;/code&gt; 类似于 &lt;code&gt;mutation&lt;/code&gt; ，也相当于一种自定义事件。只不过， &lt;code&gt;action&lt;/code&gt; 操作的是 &lt;code&gt;mutation&lt;/code&gt; 而不是 &lt;code&gt;state&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;添加 &lt;code&gt;action&lt;/code&gt; 的方法类似，在选项对象中新增 &lt;code&gt;action&lt;/code&gt; 属性即可。与 &lt;code&gt;mutation&lt;/code&gt; 的参数不同， &lt;code&gt;action&lt;/code&gt; 的参数就是当前创建的 &lt;code&gt;Vue.store&lt;/code&gt; 对象实例的上下文，一般将其命名为 &lt;code&gt;context&lt;/code&gt; 。我们需要使用其自带的 &lt;code&gt;commit&lt;/code&gt; 方法来触发 &lt;code&gt;mutation&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;下面我通过实际的例子来尝试下 &lt;code&gt;action&lt;/code&gt; ：&lt;/p&gt;
&lt;p&gt;首先，修改选项对象，使得新添加的 &lt;code&gt;action&lt;/code&gt; 可以触发之前的 &lt;code&gt;mutation&lt;/code&gt; ：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// store.js
import Vue from 'vue'
import Vuex from 'vuex'

Vue.use(Vuex)

export default new Vuex.Store({
  state: {
    count: 1
  },
  mutations: {
    increment (state) {
      state.count++
    }
  },
  actions: {
    increment ({ commit }) {
      commit('increment')
    }
  }
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于我们一般来说仅仅需要 &lt;code&gt;context&lt;/code&gt; 中的 &lt;code&gt;commit&lt;/code&gt; 方法，所以可以采用解构的方式，直接调用 &lt;code&gt;commit&lt;/code&gt; 方法，而不需要以 &lt;code&gt;context.commit&lt;/code&gt; 的方式使用它。&lt;/p&gt;
&lt;p&gt;接下来，只需要修改 &lt;code&gt;HelloWorld.vue&lt;/code&gt; ，使其能够在点击按钮时触发即可。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;action&lt;/code&gt; 的触发方式和 &lt;code&gt;mutation&lt;/code&gt; 类似，只不过调用的方法是 &lt;code&gt;dispatch&lt;/code&gt; 。&lt;/p&gt;
&lt;pre class=&quot;vue&quot;&gt;
&lt;code&gt;// HelloWorld.vue
&amp;lt;template&amp;gt;
  &amp;lt;div class=&quot;hello&quot;&amp;gt;
    &amp;lt;div&amp;gt;{{$store.state.count}}&amp;lt;/div&amp;gt;
    &amp;lt;button @click=&quot;$store.dispatch('increment')&quot;&amp;gt;修改count&amp;lt;/button&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;点击页面按钮，你会发现，实现了和之前相同的效果。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;学会了 &lt;code&gt;vuex&lt;/code&gt; 三贱客： &lt;code&gt;state&lt;/code&gt; ， &lt;code&gt;mutation&lt;/code&gt; ， &lt;code&gt;action&lt;/code&gt; ，我们再回过头看看前面的那张关系图，此时应该很容易理解了吧？&lt;/p&gt;
&lt;p&gt;组件交互触发 &lt;code&gt;action&lt;/code&gt; ， 在 &lt;code&gt;action&lt;/code&gt; 中进行异步操作（可选）并触发 &lt;code&gt;mutation&lt;/code&gt; ， &lt;code&gt;mutation&lt;/code&gt; 控制 &lt;code&gt;state&lt;/code&gt; 的变动， &lt;code&gt;state&lt;/code&gt; 修改之后，触发响应式，重新渲染组件。&lt;/p&gt;
&lt;h3 id=&quot;彩蛋&quot;&gt;彩蛋&lt;/h3&gt;
&lt;p&gt;在官方文档中，提到需要将异步操作放入 &lt;code&gt;action&lt;/code&gt; 中，而不能放在 &lt;code&gt;mutation&lt;/code&gt; 中。实际上，在 &lt;code&gt;mutation&lt;/code&gt; 中也可以进行异步操作，而且也不会导致什么奇怪的事情。&lt;/p&gt;
&lt;p&gt;但是，既然官方文档中这么说了，我们在实际开发中，一般还是老老实实地将所有异步操作放在 &lt;code&gt;action&lt;/code&gt; 中。（猥琐保平安 -_-）&lt;/p&gt;
&lt;p&gt;另外，说了这么多，其实在一些项目中，可以使用 &lt;code&gt;provide/inject&lt;/code&gt; 代替 &lt;code&gt;vuex&lt;/code&gt; 。具体的用法在此不再赘述，就当一个课后作业吧。&lt;/p&gt;
&lt;p&gt;在项目中灵活使用 &lt;code&gt;provide/inject&lt;/code&gt; ，有时可以起到出乎意料的作用哦。&lt;/p&gt;
&lt;h3 id=&quot;最后的最后&quot;&gt;最后的最后&lt;/h3&gt;
&lt;p&gt;篇幅有限，所以该篇文章只讲述了 &lt;code&gt;vuex&lt;/code&gt; 三贱客的基本用法，其他的进阶用法，如： &lt;code&gt;getter&lt;/code&gt; ， &lt;code&gt;module&lt;/code&gt; ， 简写以及 &lt;code&gt;vuex&lt;/code&gt; 项目结构优化，甚至 &lt;code&gt;vuex&lt;/code&gt; 源码解析将会在之后的文章一一讲解。&lt;/p&gt;
&lt;p&gt;如果您觉得这片文章不错的话，不如给我的 &lt;a href=&quot;https://github.com/KarthusLorin/vue-ebook&quot;&gt;gayhub&lt;/a&gt; 点个star再走呗。&lt;/p&gt;
&lt;p&gt;这个项目个人认为对很多新手在实际开发中使用 &lt;code&gt;vuex&lt;/code&gt; 还是很有启发和帮助的（手动狗头）。&lt;/p&gt;
&lt;p&gt;欢迎交流，谢谢~&lt;/p&gt;
</description>
<pubDate>Tue, 25 Dec 2018 15:31:00 +0000</pubDate>
<dc:creator>格子熊</dc:creator>
<og:description>在 开发中，组件通信一直是一大痛点。 当项目是很简单的 或者多入口项目时，可以靠着 自带的 进行组件通信；规模再大一些，可以搭配使用 总线进行兄弟组件通信；项目再大一些，出现更复杂的组件关系时，复杂的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/karthuslorin/p/10169651.html</dc:identifier>
</item>
<item>
<title>高中生的IT之路-自序 - 阿正-WEB</title>
<link>http://www.cnblogs.com/azheng007/p/10176892.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/azheng007/p/10176892.html</guid>
<description>&lt;p&gt;    近几年来越来越多的人问我关于 高中生要不要读大学、大学选择专业、毕业后的择业问题，索性我不如把我对这几方面的理解写出来，如果有幸能帮助到更多的人，那也算是个人对社会做出了一点贡献。&lt;/p&gt;

&lt;p&gt;    我高中毕业后并没有进入大学，而是直接进入到社会工作。刚进入社会的时候去餐厅当过服务员，后来又在朋友的帮助下进到一家IT公司进行实习生培训，再后来就正式进入到软件工程师的行业，从刚开始的门外汉通过自学 从实习生成为工程师、高级工程师、项目经理、技术经理，到现在在一家互联网公司任职技术经理的职位并且自己在经营一家餐饮公司。&lt;/p&gt;

&lt;p&gt;    从业九年以来，从工程师小白到技术经理，积累了一些学习心得和学习方法，后续会继续分享给大家；在整个晋升过程中也在反思当年选择不去读大学的得与失，总结来看，包括现在对那些咨询到我的人，我还是建议他们要读大学，其中缘由会在后续继续和大家沟通；在整个个人发展过程中除了发现专业技能的重要性，比如对编程领域的知识掌握，也逐渐的更加重视一个人在 高度、耐心、做人、沟通、协调、自律、时间、策略 等各个方面的对个人发展的重要性，后续也会继续和大家一起分享；以及关于个人发展以及理财等方面也被颠覆了很多观念，从小学校和社会传输给我们的许多观念也在个人发展过程中逐渐的被颠覆。其实我总结来看，进入社会的成长其实就是一个不断颠覆这个社会和学校从小就灌输给我们大脑里的那些根深蒂固的观念。&lt;/p&gt;

&lt;p&gt;    接下来，我会连载《高中生的IT之路》系列文章，把我的一些 个人经历、学习方法和心得、职场发展、个人发展等通过这个系列文章和大家一起来沟通，一起成长。&lt;/p&gt;
</description>
<pubDate>Tue, 25 Dec 2018 14:48:00 +0000</pubDate>
<dc:creator>阿正-WEB</dc:creator>
<og:description>近几年来越来越多的人问我关于 高中生要不要读大学、大学选择专业、毕业后的择业问题，索性我不如把我对这几方面的理解写出来，如果有幸能帮助到更多的人，那也算是个人对社会做出了一点贡献。 我高中毕业后并没有</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/azheng007/p/10176892.html</dc:identifier>
</item>
<item>
<title>FreeCodeCamp 题目 Profile lookup 思考 - 墨狐</title>
<link>http://www.cnblogs.com/kaluosifa/p/10176871.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kaluosifa/p/10176871.html</guid>
<description>&lt;p&gt;原题目链接：&lt;a href=&quot;https://freecodecamp.cn/challenges/profile-lookup#&quot; data-cke-saved-href=&quot;https://freecodecamp.cn/challenges/profile-lookup#&quot;&gt;https://freecodecamp.cn/challenges/profile-lookup#&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;题目&lt;/strong&gt;：&lt;/h2&gt;
&lt;p&gt;&lt;br/&gt;    我们有一个对象数组，里面存储着通讯录。 函数 lookUp 有两个预定义参数：firstName值和prop属性 。函数将会检查通讯录中是否存在一个与传入的firstName相同的联系人。 如果存在，那么还需要检查对应的联系人中是否存在 prop属性。如果它们都存在，函数返回prop属性对应的值。如果firstName 值不存在，返回 &quot;No such contact&quot;。 如果prop 属性不存在，返回 &quot;No such property&quot;。&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;个人思路&lt;/strong&gt;：&lt;/h2&gt;
&lt;p&gt;&lt;br/&gt;    循环判断有与参数 firstName值 匹配的联系人；&lt;br/&gt;        如果存在，那么继续判断是否存在参数 prop 匹配的属性；&lt;br/&gt;            如果存在，就返回该属性的值，并结束循环。&lt;br/&gt;            如果不存在，就返回&quot;No such property&quot;，并结束循环。&lt;br/&gt;    当循环到最后一个联系人却还没有匹配到时，就返回&quot;No such contact&quot;，此时循环顺势结束了。 &lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;数据测试&lt;/strong&gt;：&lt;/h2&gt;
&lt;p&gt;&lt;br/&gt;    &quot;Kristian&quot;, &quot;lastName&quot; 应该返回 &quot;Vos&quot;&lt;br/&gt;    &quot;Sherlock&quot;, &quot;likes&quot; 应该返回 [&quot;Intriguing Cases&quot;, &quot;Violin&quot;]&lt;br/&gt;    &quot;Harry&quot;,&quot;likes&quot; 应该返回一个数组&lt;br/&gt;    &quot;Bob&quot;, &quot;number&quot; 应该返回 &quot;No such contact&quot;&lt;br/&gt;    &quot;Akira&quot;, &quot;address&quot; 应该返回 &quot;No such property&quot;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;代码段&lt;/strong&gt;：&lt;em&gt;（复制到控制台即可看结果，修改最后一行的参数完成测试。）&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;如果有更好的思路，欢迎评论一起讨论！&lt;/p&gt;
</description>
<pubDate>Tue, 25 Dec 2018 14:42:00 +0000</pubDate>
<dc:creator>墨狐</dc:creator>
<og:description>原题目链接：https://freecodecamp.cn/challenges/profile-lookup# 题目： 我们有一个对象数组，里面存储着通讯录。 函数 lookUp 有两个预</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kaluosifa/p/10176871.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core 实战：构建带有版本控制的 API 接口 - 墨墨墨墨小宇</title>
<link>http://www.cnblogs.com/danvic712/p/10176823.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/danvic712/p/10176823.html</guid>
<description>&lt;h3&gt;&lt;strong&gt; 一、前言&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt; 　　在上一篇的文章中，主要是搭建了我们的开发环境，同时创建了我们的项目模板框架。在整个前后端分离的项目中，后端的 API 接口至关重要，它是前端与后端之间进行沟通的媒介，如何构建一个 “好用” 的 API 接口，是需要我们后端人员好好思考的。&lt;br/&gt;　　在系统迭代的整个过程中，不可避免的会添加新的资源，或是修改现有的资源，后端接口作为暴露给外界的服务，变动的越小，对服务的使用方造成的印象就越小，因此，如何对我们的 API 接口进行合适的版本控制，我们势必需要首先考虑。&lt;/p&gt;
&lt;p&gt;　　系列目录地址：&lt;a title=&quot;ASP.NET Core 项目实战&quot; href=&quot;https://www.cnblogs.com/danvic712/p/10124831.html&quot;&gt;ASP.NET Core 项目实战&lt;/a&gt;&lt;br/&gt;　　仓储地址：&lt;a title=&quot;https://github.com/Lanesra712/Grapefruit.VuCore&quot; href=&quot;https://github.com/Lanesra712/Grapefruit.VuCore&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;https://github.com/Lanesra712/Grapefruit.VuCore&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt; 二、Step by Step&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　项目总是在不断迭代的，某些时候，因为业务发展的需要，需要将现有的接口进行升级，而原有的接口却不能立刻停止使用。比如说，你开发了一个接口提供给爱啪啪 1.0 版本使用，后来爱啪啪的版本迭代了，需要接口返回的数据与原先 1.0 版本返回的数据不同了，这时候，接口肯定是需要升级的，可是如果直接升级原有的接口，还在使用 1.0 版本的用户不就 GG 了，因此，如何做到既可以让 1.0 版本的用户使用，也可以让 2.0 版本的用户使用就需要好好考虑了，常见的解决方案，主要有以下几种。&lt;/p&gt;
&lt;p&gt;　　a）使用不同的 API 名称&lt;/p&gt;
&lt;p&gt;　　最简单粗暴，需要变更接口逻辑时就重新起个 API 名称，新的版本调用新的 API 名称，旧的版本调用旧的 API 名称。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;https://yuiter.com/api/Secret/Login ##爱啪啪 1.0
https://yuiter.com/api/Secret/NewLogin ##爱啪啪 2.0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　b）在 Url 中标明版本号&lt;/p&gt;
&lt;p&gt;　　直接将 API 版本信息添加到请求的 Url 中，调用不同版本的 API ，就在 URL 中直接标明使用的是哪个版本。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;https://yuiter.com/api/v1/Secret/Login ##爱啪啪 1.0
https://yuiter.com/api/v2/Secret/Login ##爱啪啪 2.0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　c）请求参数中添加版本信息&lt;/p&gt;
&lt;p&gt;　　将 API 的版本信息作为请求的一个参数传递，通过指定参数值来确定请求的 API 版本。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;https://yuiter.com/api/Secret/Login?version=1 ##爱啪啪 1.0
https://yuiter.com/api/Secret/Login?version=2 ##爱啪啪 2.0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　d）在 header 中标明版本号&lt;/p&gt;
&lt;p&gt;　　前端在请求 API 接口时，在 header 中添加一个参数用来表明请求的版本信息，后端通过前端在 header 中设置的参数来判断，从而执行不同的业务逻辑分支。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;POST https://yuiter.com/api/Secret/Login
Host: yuiter.com  
api-version: v1   ##爱啪啪 1.0

POST https://yuiter.com/api/Secret/Login
Host: yuiter.com  
api-version: v2   ##爱啪啪 2.0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在 Grapefruit.VuCore 这个项目中，我选择将 API 的版本信息添加到请求的地址中，从而明确的指出当前请求的接口版本信息。&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;　　1、Swagger 集成&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;后端完成了接口之后，肯定需要告诉前端，不管是整理成 txt/excel/markdown 文档，亦或是写完一个接口就直接发微信告诉前端，总是要多做一步的事情，而 Swagger 则可以帮我们省去这一步。通过配置之后，Swagger 就可以根据我们的接口自动生成 API 的接口文档，省时，省力。&lt;span&gt;当然，如果前端小姐姐单身可撩，而你碰巧有意的话，另谈。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　Swagger 是一个可以将接口文档自动生成，同时可以对接口功能进行测试的开源框架，在 ASP.NET Core 环境下，主流的有 Swashbuckle.AspNetCore 和 NSwag 这两个开源框架帮助我们生成 Swagger documents。这里，我采用的是 &lt;a title=&quot;Swashbuckle.AspNetCore&quot; href=&quot;https://github.com/domaindrivendev/Swashbuckle.AspNetCore&quot; target=&quot;_blank&quot;&gt;Swashbuckle.AspNetCore&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;　　在使用 Swashbuckle.AspNetCore 之前，首先我们需要在 API(Grapefruit.WebApi) 项目中添加对于 Swashbuckle.AspNetCore 的引用。你可以直接右键选中 API 项目选择管理 Nuget 程序包进行加载引用，也可以通过程序包管理控制台进行添加引用，这里注意，使用程序包管理控制台时，你需要将默认的项目修改成 API(Grapefruit.WebApi) 项目。当引用添加完成后，我们就可以在项目中配置 Swagger 了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1310859/201812/1310859-20181225221555692-1341993265.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Install-Package Swashbuckle.AspNetCore
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1310859/201812/1310859-20181225221625202-216407620.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　ASP.NET Core 的本质上可以看成是一个控制台程序，在我们创建好的 ASP.NET Core Web API 项目中，存在着两个类文件：Program.cs 以及 Startup.cs。与控制台应用一样，Program 类中的 Main 方法是整个程序的入口，在这个方法中，我们将配置好的 IWebHostBuilder 对象，构建成 IWebHost 对象，并运行该 IWebHost 对象从而达到运行 Web 项目的作用。&lt;/p&gt;
&lt;p&gt;　　在框架生成的 Program 类文件中，在配置 IWebHostBuilder 的过程时，框架默认为我们添加了一些服务，当然，这里你可以注释掉默认的写法，去自己创建一个 WebHostBuilder 对象。同时，对于一个 ASP.NET Core 程序来说，Startup 类是必须的（你可以删除生成的 Startup 类，重新创建一个新的类，但是，这个新创建的类必须包含 Configure 方法，之后只需要在 UseStartup&amp;lt;Startup&amp;gt; 中将该类配置为 Startup 类即可），这里如果不指定 Startup 类会导致启动失败。&lt;/p&gt;
&lt;p&gt;　　在 Startup 类中，存在着 ConfigureServices 和 Configure 这两个方法，在 ConfigureServices 方法中，我们将自定义服务通过依赖注入的方式添加到 IServiceCollection 容器中，而这些容器中的服务，最终都可以在 Configure 方法中进行使用；而 Configure 方法则用于指定 ASP.NET Core 应用程序将如何响应每一个 HTTP 请求，我们可以在这里将我们自己创建的中间件（Middleware）绑定到 IApplicationBuilder 上，从而添加到 HTTP 请求管道中。&lt;/p&gt;
&lt;p&gt;　　这里只是很粗略的说明了 ASP.NET Core 项目的启动过程，想要仔细了解启动过程的推荐园子里的这篇文章 =》&lt;a title=&quot;ASP.NET Core 2.0 : 七.一张图看透启动背后的秘密&quot; href=&quot;https://www.cnblogs.com/FlyLolo/p/ASPNETCore2_7.html&quot; target=&quot;_blank&quot;&gt;ASP.NET Core 2.0 : 七.一张图看透启动背后的秘密&lt;/a&gt;，因为 ASP.NET Core 2.1 版本相比于 2.0 版本又有些改变，这里有一些不一样的地方需要你去注意。&lt;/p&gt;
&lt;p&gt;　　当我们简单了解了启动过程后，就可以配置我们的 Swagger 了。Swashbuckle.AspNetCore 帮我们构建好了使用 Swagger 的中间件，我们只需要直接使用即可。&lt;/p&gt;
&lt;p&gt;　　首先我们需要在 ConfigureServices 方法中，将我们的服务添加到 IServiceCollection 容器中，这里，我们需要为生成的 Swagger Document 进行一些配置。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
services.AddSwaggerGen(s =&amp;gt;&lt;span&gt;
{
    s.SwaggerDoc(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Info
    {
        Contact &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Contact
        {
            Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Danvic Wang&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            Email &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;danvic96@hotmail.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            Url &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://yuiter.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        },
        Description &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A front-background project build by ASP.NET Core 2.1 and Vue&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        Title &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Grapefruit.VuCore&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        Version &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    });
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　之后，我们就可以在 Configure 方法中启用我们的 Swagger 中间件。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;app.UseSwagger();
app.UseSwaggerUI(s &lt;/span&gt;=&amp;gt;&lt;span&gt;
{
    s.SwaggerEndpoint(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/swagger/v1/swagger.json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Grapefruit.VuCore API V1.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　此时，当你运行程序，在域名后面输入/swagger 即可访问到我们的 API 文档页面。因为项目启动时默认访问的是我们 api/values 的 GET 请求接口，这里我们可以打开 Properties 下的 launchSetting.json 文件去配置我们的程序默认打开页面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1310859/201812/1310859-20181225221909953-697366673.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　从上面的图可以看出，不管是使用 IIS 或是程序自托管，我们默认打开的 Url 都是 api/values，这里我们将两种启动方式的 launchUrl 值都修改成 swagger 之后再次运行我们的项目，可以发现，程序默认的打开页面就会变成我们的 API 文档页面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1310859/201812/1310859-20181225221929552-1700007097.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　我们使用 API 文档的目的，就是为了让前端知道请求的方法地址是什么，需要传递什么参数，而现在，并没有办法显示出我们对于参数以及方法的注释，通过查看 Swashbuckle.AspNetCore 的 github 首页可以看到，我们可以通过配置，将生成的 json 文件中包含我们对于 Controller or Action 的 Xml 注释内容，从而达到显示注释信息的功能（最终呈现的 Swagger Doc 是根据之前我们定义的这个 “/swagger/v1/swagger.json” json 文件来生成的）。&lt;/p&gt;
&lt;p&gt;　　右键我们的 API 项目，属性 =》生产，勾选上 XML 文档文件，系统会默认帮我们创建生成 XML 文件的地址，这时候，我们重新生成项目，则会发现，当前项目下会多出这个 XML 文件。在重新生成项目的过程中，你会发现，错误列表会显示很多警告信息，提示我们一些方法没有添加 XML 注释。如果你和我一样强迫症的话，可以把 1591 这个错误添加到上面的禁止显示警告中，这样就可以不再显示这个警告了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1310859/201812/1310859-20181225221956658-1986003811.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　创建好 XML 的注释文件后，我们就可以配置我们的 Swagger 文档，从而达到显示注释的功能。这里，因为我会在 Grapefruit.Application 类库中创建各种的 Dto 对象，而接口中是会调用到这些 Dto 对象的。因此，为了显示这些 Dto 上的注释信息，这里我们也需要生成 Grapefruit.Application 项目的 XML 注释文件。&lt;/p&gt;
&lt;p&gt;　　PS：这里我是将每个项目生成的注释信息 xml 文档地址都放在了程序的基础路径下，如果你将 xml 文档生成在别的位置，这里获取 xml 的方法就需要你进行修改。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
services.AddSwaggerGen(s =&amp;gt;&lt;span&gt;
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;...

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Add comments description
    &lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;    &lt;span&gt;var&lt;/span&gt; basePath = Path.GetDirectoryName(AppContext.BaseDirectory);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;get application located directory&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; apiPath = Path.Combine(basePath, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Grapefruit.WebApi.xml&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; dtoPath = Path.Combine(basePath, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Grapefruit.Application.xml&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    s.IncludeXmlComments(apiPath, &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
    s.IncludeXmlComments(dtoPath, &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1310859/201812/1310859-20181225222136421-627796562.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　当我们把 Swagger 配置完成之后，我们就可以创建具有版本控制的 API 接口了。&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;　　2、带有版本控制的 API 接口实现&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;　　在请求的 API Url 中标明版本号，我不知道你第一时间看到这个实现方式，会想到什么，对于我来说，直接在路由信息中添加版本号不就可以了。。。em，这样过于投机取巧了。。。。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[Route(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api/v1/[controller]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)]&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加版本信息为v1&lt;/span&gt;
&lt;span&gt;[ApiController]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ValuesController : ControllerBase
{
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　想了想，在 Url 中添加版本号，这个版本号是不是很像我们在 MVC 中使用的 Area。&lt;/p&gt;
&lt;p&gt;　　Area 是 MVC 中经常使用到的一个功能，我们通常会将某些小的模块拆分成一个个的 Area，而这一个个的小 Area 其实就是这个 MVC 项目中的 MVC。通过为 controller 和 action 添加另一个路由参数 area，从而达到创建具有层次路由的结构。比如，这里，我们可以创建一个 Area 叫 v1，用来存储我们 1.x 版本的 API 接口，之后如果有新的 API 版本，新增一个 Area 即可，是不是很简单，嗯，说干就干。&lt;/p&gt;
&lt;p&gt;　　右击我们的 API 项目，选择添加区域，新增的 Area 名称为 v1。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1310859/201812/1310859-20181225222255778-10300864.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　当 ASP.NET Core 的脚手架程序添加完成 Area 后，则会打开一个文件提示我们需要在 MVC 中间件中创建适用于 Area 的路由定义。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
app.UseMvc(routes =&amp;gt;&lt;span&gt;
{
  routes.MapRoute(
    name : &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;areas&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    template : &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{area:exists}/{controller=Home}/{action=Index}/{id?}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  );
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　当我们添加好路由规则定义后，我们在 Area 的 Controllers 文件夹下添加一个 WebAPI Controller。不同于 ASP.NET 中的 Area ，当我们在 ASP.NET Core 创建好一个 Area 之后，脚手架生成的文件中不再有 XXXAreaRegistration（XXX 为 Area 的名称）文件去注册这个 Area，而我们只需要在 Area 中的 Controller 中添加 Area 特性，即可告诉系统框架，这个 Controller 是在当前的 Area 下的。&lt;/p&gt;
&lt;p&gt;　　如果你有自己尝试的话，就会发现，当我们创建好一个 v1 的 Area 后，这个请求的地址并没有按照我们的想法会体现在路由信息中，我们最后还是需要在 Route 中手动指明 API 版本。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[Area(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
[Route(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api/v1/[controller]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
[ApiController]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ValuesController : ControllerBase
{
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1310859/201812/1310859-20181225222353441-1110080758.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这样的话，和最开始直接在路由信息中写死版本信息其实也就没什么差别了，上网搜了搜，发现巨硬爸爸，也早已为我们准备好了实现版本控制 API 的利器 - Microsoft.AspNetCore.Mvc.Versioning。&lt;/p&gt;
&lt;p&gt;　　和上面使用 Swashbuckle.AspNetCore 的方式相同，在我们使用 Versioning 之前，需要在我们的 API 项目中添加对于该 dll 的引用。这里需要注意下安装的版本问题，因为 Grapefruit.VuCore 这个框架距离现在搭建也有几个月的时间了，在这个月初的时候 .NET Core 2.2 也已经发布了，如果你和我一样还是采用的 .NET Core 2.1 版本的话，这里安装的 Versioning 版本最高只能到 2.3。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Install-Package Microsoft.AspNetCore.Mvc.Versioning
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　当我们安装完成之后，就可以进行配置了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
{
    services.AddApiVersioning(o &lt;/span&gt;=&amp;gt;&lt;span&gt;
    {
        o.ReportApiVersions &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;return versions in a response header&lt;/span&gt;
        o.DefaultApiVersion = &lt;span&gt;new&lt;/span&gt; ApiVersion(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;default version select &lt;/span&gt;
        o.AssumeDefaultVersionWhenUnspecified = &lt;span&gt;true&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;if not specifying an api version,show the default version&lt;/span&gt;
&lt;span&gt;    });
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　ReportApiVersions：这个配置是可选的，当我们设置为 true 时，API 会在响应的 header 中返回版本信息。&lt;/p&gt;
&lt;p&gt;　　DefaultApiVersion：指定在请求中未指明版本时要使用的默认 API 版本。这将默认版本为1.0。&lt;/p&gt;
&lt;p&gt;　　AssumeDefaultVersionWhenUnspecified：这个配置项将用于在没有指明 API 版本的情况下提供请求，默认情况下，会请求默认版本的 API，例如，这里就会请求 1.0 版本的 API。&lt;/p&gt;
&lt;p&gt;　　这里，删除我们之前的创建的 Area 和默认的 ValuesController，在 Controllers 文件夹下新增一个 v1 文件夹，将所有 v1 版本的 Controller 都建在这个目录下。新建一个 Controller，添加上 ApiVersion Attribute 指明当前的版本信息。因为我采用的方案是在 Url 中指明 API 版本，所以，我们还需要在 Route 中修改我们的路由属性以对应 API 的版本。这里的 v 只是一个默认的惯例，你也可以不添加。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[ApiVersion(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
[Route(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api/v{version:apiVersion}/[controller]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
[ApiController]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; VaulesController : ControllerBase
{
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　当我们修改好我们的 Controller 之后，运行我们的项目，你会发现，API 文档中显示的请求地址是不对的，难道是我们的配置没起作用吗？通过 Swagger 自带的 API 测试工具测试下我们的接口，原来这里请求的 Url 中已经包含了我们定义的版本信息，当我们指定错误的版本信息时，工具也会告诉我们这个版本的接口不存在。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1310859/201812/1310859-20181225222558824-840046028.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　虽然我们请求的 Url 中已经带上了版本信息，但是 API 文档上显示的请求地址却是不准确的，强迫症，不能忍。这里，需要我们修改生成 Swagger 文档的配置代码，将路由中的版本信息进行替换。重新运行我们的项目，可以发现，文档显示的 Url 地址也已经正确了，自此，我们创建带有版本控制的 API 也就完成了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
{
    services.AddSwaggerGen(s &lt;/span&gt;=&amp;gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;...

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Show the api version in url address&lt;/span&gt;
        s.DocInclusionPredicate((version, apiDescription) =&amp;gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; values =&lt;span&gt; apiDescription.RelativePath
                .Split(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
                .Select(v &lt;/span&gt;=&amp;gt; v.Replace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v{version}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, version));

            apiDescription.RelativePath &lt;/span&gt;= &lt;span&gt;string&lt;/span&gt;.Join(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, values);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        });
    });
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1310859/201812/1310859-20181225222649692-483012929.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt; 三、总结&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt; 　　本章使用了 Microsoft.AspNetCore.Mvc.Versioning 这一组件来实现我们对于 API 版本控制的功能实现，可能你会有疑问，我们直接在路由中写明版本信息不是更简单吗？在我看来，使用这一组件的目的，在于我们可以以多种的方式实现 API 版本控制的目的，如果哪天你不想在 Url 中指明版本信息后，你可以很快的使用别的形式来完成 API 的版本控制。另外，直接在路由中写上版本信息，是不是会显得我们比较 ‘low’，哈哈哈，开玩笑，最后祝大家圣诞快乐~~~&lt;/p&gt;
</description>
<pubDate>Tue, 25 Dec 2018 14:29:00 +0000</pubDate>
<dc:creator>墨墨墨墨小宇</dc:creator>
<og:description>一、前言 在上一篇的文章中，主要是搭建了我们的开发环境，同时创建了我们的项目模板框架。在整个前后端分离的项目中，后端的 API 接口至关重要，它是前端与后端之间进行沟通的媒介，如何构建一个 “好用”</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/danvic712/p/10176823.html</dc:identifier>
</item>
<item>
<title>MySQL AUTO_INCREMENT 学习总结 - H_Johnny</title>
<link>http://www.cnblogs.com/dbabd/p/10169197.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dbabd/p/10169197.html</guid>
<description>&lt;p&gt;&lt;strong&gt;正文&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;之前有碰到过开发同事指出一张InnoDB表的自增列 &lt;strong&gt;AUTO_INCREMENT&lt;/strong&gt; 值莫明的变大，由于这张表是通过mysqldump导出导入的。&lt;/p&gt;
&lt;p&gt;问题排查：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;1、首先，查看表表义的sql部分的 &lt;strong&gt;auto_increment&lt;/strong&gt; 值部分是正常，所以排除是导入表问题所引起的；&lt;br/&gt;2、最后，经过沟通了解怀疑是插入时指定自增列的值，并且值过大，随之发现自增列的值出错时又进行大量删除时引起的问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为了验证这个怀疑的准确性，同时学习下InnoDB处理 &lt;strong&gt;AUTO_INCREMENT&lt;/strong&gt; 的机制，因此在测试环境做了测试总结。&lt;/p&gt;
&lt;p&gt;本文使用的MySQL版本为官方社区版 &lt;code&gt;5.7.24&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;(root@localhost) [test] &amp;gt; select version();
+------------+
| version()  |
+------------+
| 5.7.24-log |
+------------+
1 row in set (0.00 sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试环境测试表参考官方文档：&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/innodb-auto-increment-handling.html&quot; class=&quot;uri&quot;&gt;https://dev.mysql.com/doc/refman/5.7/en/innodb-auto-increment-handling.html&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;(root@localhost) [test] &amp;gt; show create table t1\G;
*************************** 1. row ***************************
       Table: t1
Create Table: CREATE TABLE `t1` (
  `c1` int(11) NOT NULL AUTO_INCREMENT,
  `c2` varchar(10) DEFAULT NULL,
  PRIMARY KEY (`c1`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8
1 row in set (0.00 sec)

(root@localhost) [test] &amp;gt; show columns from t1;
+-------+-------------+------+-----+---------+----------------+
| Field | Type        | Null | Key | Default | Extra          |
+-------+-------------+------+-----+---------+----------------+
| c1    | int(11)     | NO   | PRI | NULL    | auto_increment |
| c2    | varchar(10) | YES  |     | NULL    |                |
+-------+-------------+------+-----+---------+----------------+
2 rows in set (0.00 sec)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;auto_increment锁模式&quot;&gt;AUTO_INCREMENT锁模式&lt;/h2&gt;
&lt;p&gt;InnoDB自增锁的模式由参数 &lt;code&gt;innodb_autoinc_lock_mode&lt;/code&gt; 在启动时指定，这是一个只读参数，并不能在实例运行中动态修改参数值。参数值选项如下：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;innodb_autoinc_lock_mode = {0|1|2}&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;InnoDB表insert语句主要可以分为三种类型：&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;Simple inserts(简单插入)&lt;/strong&gt;&lt;br/&gt;可以通过语句预先判断插入的行数。包括不包含子查询的单行、多行 &lt;strong&gt;INSERT&lt;/strong&gt; 和 &lt;strong&gt;REPLACE&lt;/strong&gt; 语句，还有语句 &lt;strong&gt;INSERT ... ON DUPLICATE KEY UPDATE&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;Bulk inserts(大量插入)&lt;/strong&gt;&lt;br/&gt;无法通过语句预先判断插入的行数。包括 &lt;strong&gt;INSERT ... SELECT&lt;/strong&gt; 、 &lt;strong&gt;REPLACE ... SELECT&lt;/strong&gt; 和 &lt;strong&gt;LOAD DATA&lt;/strong&gt; 语句。InnoDB每处理一行才会为 &lt;strong&gt;AUTO_INCREMENT&lt;/strong&gt; 列分配一个值。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;Mixed-mode inserts(混合模式插入)&lt;/strong&gt;&lt;br/&gt;在简单插入语句当中，有的行有为自增列指定值，而有的行没有为自增列指定值。例如：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;INSERT INTO t1 (c1,c2) VALUES (1,'a'), (NULL,'b'), (5,'c'), (NULL,'d'); &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中&lt;code&gt;c1&lt;/code&gt;为自增列。&lt;/p&gt;
&lt;p&gt;还有一种混合模式插入语句 &lt;strong&gt;INSERT ... ON DUPLICATE KEY UPDATE&lt;/strong&gt; ，这类语句InnoDB为自增列预分配的值有可能被使用，也有可能不被使用。&lt;/p&gt;
&lt;h3 id=&quot;传统锁模式-traditional&quot;&gt;传统锁模式 (traditional)&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;innodb_autoinc_lock_mode = &lt;em&gt;0&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在这个模式下，所有的 &lt;strong&gt;INSERT&lt;/strong&gt; 语句在插入有自增属性的列时都要获取一个特殊的 &lt;strong&gt;AUTO-INC&lt;/strong&gt; 表级锁。该锁的持有时间到语句结束(而不是到事务结束，一个事务中可能包含多条语句)，它能够确保为有自增属性列在 &lt;strong&gt;INSERT&lt;/strong&gt; 一行或者多行数据时分配连续递增的值。&lt;/p&gt;
&lt;h3 id=&quot;连续锁模式-consecutive&quot;&gt;连续锁模式 (consecutive)&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;innodb_autoinc_lock_mode = &lt;em&gt;1&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是默认的锁模式。在这个模式下，大量插入每条语句执行时都将获得特殊的表级 &lt;strong&gt;AUTO-INC&lt;/strong&gt; 锁，语句执行完成后释放。每次只有一条语句可以执行并持有 &lt;strong&gt;AUTO-INC&lt;/strong&gt; 锁。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Bulk inserts(大量插入)&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;如果大量插入的源表和目标表是不同的，则在源表第一行数据获得共享锁之后，目标表就加上 &lt;strong&gt;AUTO-INC&lt;/strong&gt; 表锁；&lt;/li&gt;
&lt;li&gt;如果大量插入的源表和目标表是同一张表，当源表选取所有行获得共享锁之后，目标表才加上 &lt;strong&gt;AUTO-INC&lt;/strong&gt; 表锁。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Simple inserts(简单插入)&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;通过 &lt;strong&gt;MUTEX(轻量级的锁)&lt;/strong&gt; 而不是 &lt;strong&gt;AUTO-INC&lt;/strong&gt;特殊表锁控制插入分配自增属性列的值；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;MUTEX&lt;/strong&gt; 只在分配值的过程中持有，而无需等到语句结束，并且性能花销更少；&lt;/li&gt;
&lt;li&gt;简单插入不持有 &lt;strong&gt;AUTO-INC&lt;/strong&gt; 锁，但如果其他事务持有，需等待其他事务释放，就像大量插入那样。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;交叉锁模式-interleaved&quot;&gt;交叉锁模式 (interleaved)&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;innodb_autoinc_lock_mode = &lt;em&gt;2&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在这种锁模式下，没有插入语句使用 &lt;strong&gt;AUTO-INC&lt;/strong&gt; 表级锁，并且多条语句可以并发执行。这是最快并且扩展性最好的锁模式，但是如果binlog使用基于语句级复制的在从库重放SQL语句时是不安全的。&lt;/p&gt;
&lt;h2 id=&quot;auto_increment锁模式使用说明&quot;&gt;AUTO_INCREMENT锁模式使用说明&lt;/h2&gt;
&lt;h3 id=&quot;用于复制&quot;&gt;用于复制&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;基于语句级别的复制，当 &lt;strong&gt;innodb_autoinc_lock_mode = &lt;em&gt;0&lt;/em&gt; | &lt;em&gt;1&lt;/em&gt;&lt;/strong&gt; 时，主从使用的是相同的自增列值。当 &lt;strong&gt;innodb_autoinc_lock_mode = &lt;em&gt;2&lt;/em&gt;&lt;/strong&gt; 或者主从使用不同的 &lt;strong&gt;innodb_autoinc_lock_mode&lt;/strong&gt; 时，主从无法保证使用相同的自增列值；&lt;/li&gt;
&lt;li&gt;基于行级别和复合模式的复制，&lt;strong&gt;innodb_autoinc_lock_mode&lt;/strong&gt; 的所有取值都是安全的，因为SQL语句执行顺序对基于行级别的复制没影响。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;自增值缺失与间隙&quot;&gt;自增值缺失与间隙&lt;/h3&gt;
&lt;p&gt;无论 &lt;strong&gt;AUTO_INCREMENT&lt;/strong&gt; 处于哪种锁模式下，即 &lt;strong&gt;innodb_autoinc_lock_mode&lt;/strong&gt; 的所有取值情况下，在一个事务当中自增列分配的值是不能被回滚的。这会导致事务回滚了，但是自增列分配的值却消失了，自增列分配的值是无法随着事务回滚而重复利用，这样就自增列上的值就产生了间隙。&lt;/p&gt;
&lt;p&gt;测试：&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;--1、 开启一个事务
(root@localhost) [test] &amp;gt; begin;
Query OK, 0 rows affected (0.00 sec)

(root@localhost) [test] &amp;gt; insert into t1(c2) values('aa');
Query OK, 1 row affected (0.00 sec)

(root@localhost) [test] &amp;gt; select * from t1;
+----+------+
| c1 | c2   |
+----+------+
|  1 | aa   |
+----+------+
1 row in set (0.00 sec)

(root@localhost) [test] &amp;gt; show create table t1\G;
*************************** 1. row ***************************
       Table: t1
Create Table: CREATE TABLE `t1` (
  `c1` int(11) NOT NULL AUTO_INCREMENT,
  `c2` varchar(10) DEFAULT NULL,
  PRIMARY KEY (`c1`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8
1 row in set (0.00 sec)

--2、事务回滚，不提交
(root@localhost) [test] &amp;gt; rollback;
Query OK, 0 rows affected (0.00 sec)

(root@localhost) [test] &amp;gt; select * from t1;
Empty set (0.00 sec)

(root@localhost) [test] &amp;gt; show create table t1\G;
*************************** 1. row ***************************
       Table: t1
Create Table: CREATE TABLE `t1` (
  `c1` int(11) NOT NULL AUTO_INCREMENT,
  `c2` varchar(10) DEFAULT NULL,
  PRIMARY KEY (`c1`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8
1 row in set (0.00 sec) 

--3、再次开启事务，插入值并提交
(root@localhost) [test] &amp;gt; begin;
Query OK, 0 rows affected (0.00 sec)

(root@localhost) [test] &amp;gt; insert into t1(c2) values('aaa');
Query OK, 1 row affected (0.02 sec)

(root@localhost) [test] &amp;gt; select * from t1;
+----+------+
| c1 | c2   |
+----+------+
|  2 | aaa  |
+----+------+
1 row in set (0.00 sec)

(root@localhost) [test] &amp;gt; commit;
Query OK, 0 rows affected (0.00 sec)

(root@localhost) [test] &amp;gt; show create table t1\G;
*************************** 1. row ***************************
       Table: t1
Create Table: CREATE TABLE `t1` (
  `c1` int(11) NOT NULL AUTO_INCREMENT,
  `c2` varchar(10) DEFAULT NULL,
  PRIMARY KEY (`c1`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8
1 row in set (0.00 sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看出自增列分配的值是不会再出现 &lt;strong&gt;c1=1&lt;/strong&gt; 的。&lt;/p&gt;
&lt;h3 id=&quot;为自增列指定null或者0&quot;&gt;为自增列指定NULL或者0&lt;/h3&gt;
&lt;p&gt;无论 &lt;strong&gt;AUTO_INCREMENT&lt;/strong&gt; 处于哪种锁模式下，如果在 &lt;strong&gt;INSERT&lt;/strong&gt; 语句为自增列指定 &lt;strong&gt;NULL&lt;/strong&gt; 或者 &lt;strong&gt;0&lt;/strong&gt; 时，InnoDB认为并没有为自增列指定值，同时也会为其分配值。&lt;/p&gt;
&lt;p&gt;测试：&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;(root@localhost) [test] &amp;gt; select * from t1;
+----+------+
| c1 | c2   |
+----+------+
|  2 | aaa  |
+----+------+
1 row in set (0.00 sec)

(root@localhost) [test] &amp;gt; insert into t1 values(NULL,'bbb'),(0,'ccc');
Query OK, 2 rows affected (0.02 sec)
Records: 2  Duplicates: 0  Warnings: 0

(root@localhost) [test] &amp;gt; select * from t1;
+----+------+
| c1 | c2   |
+----+------+
|  2 | aaa  |
|  3 | bbb  |
|  4 | ccc  |
+----+------+
3 rows in set (0.00 sec)

(root@localhost) [test] &amp;gt; show create table t1\G;
*************************** 1. row ***************************
       Table: t1
Create Table: CREATE TABLE `t1` (
  `c1` int(11) NOT NULL AUTO_INCREMENT,
  `c2` varchar(10) DEFAULT NULL,
  PRIMARY KEY (`c1`)
) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8
1 row in set (0.00 sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;为自增列指定负值&quot;&gt;为自增列指定负值&lt;/h3&gt;
&lt;p&gt;无论 &lt;strong&gt;AUTO_INCREMENT&lt;/strong&gt; 处于哪种锁模式下，自增列分配值机制不会生效，即为自增列指定负值是不影响 &lt;strong&gt;AUTO_INCREMENT&lt;/strong&gt; 值的。&lt;/p&gt;
&lt;p&gt;测试：&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;(root@localhost) [test] &amp;gt; SELECT auto_increment FROM information_schema.tables where table_schema='test' and table_name='t1';
+----------------+
| auto_increment |
+----------------+
|              5 |
+----------------+
1 row in set (0.00 sec)

(root@localhost) [test] &amp;gt; insert into t1 values(-1,'ddd');
Query OK, 1 row affected (0.01 sec)

(root@localhost) [test] &amp;gt; select * from t1;
+----+------+
| c1 | c2   |
+----+------+
| -1 | ddd  |
|  2 | aaa  |
|  3 | bbb  |
|  4 | ccc  |
+----+------+
4 rows in set (0.00 sec) 

(root@localhost) [test] &amp;gt; SELECT auto_increment FROM information_schema.tables where table_schema='test' and table_name='t1';
+----------------+
| auto_increment |
+----------------+
|              5 |
+----------------+
1 row in set (0.00 sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;自增列值大于列类型最大的整型值&quot;&gt;自增列值大于列类型最大的整型值&lt;/h3&gt;
&lt;p&gt;无论 &lt;strong&gt;AUTO_INCREMENT&lt;/strong&gt; 处于哪种锁模式下，自增列分配的值如果大于自增列所属字段类型的最大值，则自增列分配值机制就不会生效。&lt;/p&gt;
&lt;p&gt;测试：&lt;br/&gt;在MySQL当中，INT类型的最大值为 &lt;strong&gt;-2147483648~2147483647&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;(root@localhost) [test] &amp;gt; select * from t1;
+----+------+
| c1 | c2   |
+----+------+
| -1 | ddd  |
|  2 | aaa  |
|  3 | bbb  |
|  4 | ccc  |
+----+------+
4 rows in set (0.00 sec)

(root@localhost) [test] &amp;gt; SELECT auto_increment FROM information_schema.tables where table_schema='test' and table_name='t1';
+----------------+
| auto_increment |
+----------------+
|              5 |
+----------------+
1 row in set (0.00 sec)

(root@localhost) [test] &amp;gt; insert into t1 values(2147483647,'eee');
Query OK, 1 row affected (0.02 sec)

(root@localhost) [test] &amp;gt; select * from t1;
+------------+------+
| c1         | c2   |
+------------+------+
|         -1 | ddd  |
|          2 | aaa  |
|          3 | bbb  |
|          4 | ccc  |
| 2147483647 | eee  |
+------------+------+
5 rows in set (0.00 sec)

(root@localhost) [test] &amp;gt; SELECT auto_increment FROM information_schema.tables where table_schema='test' and table_name='t1';
+----------------+
| auto_increment |
+----------------+
|     2147483647 |
+----------------+
1 row in set (0.00 sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看出自增列 &lt;strong&gt;AUTO_INCREMENT&lt;/strong&gt; 并不会分配。&lt;/p&gt;
&lt;h3 id=&quot;大量插入导致的间隙&quot;&gt;大量插入导致的间隙&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;当参数值 &lt;strong&gt;innodb_autoinc_lock_mode&lt;/strong&gt; 设置为 &lt;strong&gt;0&lt;/strong&gt; 或 &lt;strong&gt;1&lt;/strong&gt; 时，每条语句生成的自增列值都是连续的，不会产生间隙。因为表级 &lt;strong&gt;AUTO-INC&lt;/strong&gt; 锁会一直持有直到语句结束，并且同一时间只有一条语句在执行；&lt;/li&gt;
&lt;li&gt;当参数值 &lt;strong&gt;innodb_autoinc_lock_mode&lt;/strong&gt; 设置为 &lt;strong&gt;2&lt;/strong&gt; 时，在大量插入时有可能会产生间隙，但是只有当并发执行 &lt;strong&gt;INSERT&lt;/strong&gt; 语句时。&lt;/li&gt;
&lt;li&gt;对于设置成 &lt;strong&gt;1&lt;/strong&gt; 或者 &lt;strong&gt;2&lt;/strong&gt; 情形下，在连续的语句之间可能产生间隙，因为对于大量插入InnoDB并不清楚每条语句所需自增量值数量。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;混合模式插入自增列值分配&quot;&gt;混合模式插入自增列值分配&lt;/h3&gt;
&lt;p&gt;测试表：&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;-- t1表：表中无数据，但自增列下一个分配值从101开始
(root@localhost) [test] &amp;gt; show create table t1\G;
*************************** 1. row ***************************
       Table: t1
Create Table: CREATE TABLE `t1` (
  `c1` int(11) NOT NULL AUTO_INCREMENT,
  `c2` varchar(10) DEFAULT NULL,
  PRIMARY KEY (`c1`)
) ENGINE=InnoDB AUTO_INCREMENT=101 DEFAULT CHARSET=utf8
1 row in set (0.00 sec)

(root@localhost) [test] &amp;gt; select count(*) from t1;
+----------+
| count(*) |
+----------+
|        0 |
+----------+
1 row in set (0.00 sec)

-- t2表：表中有100万行数据，并且自增列值是连续的
(root@localhost) [test] &amp;gt; show create table t2\G;
*************************** 1. row ***************************
       Table: t2
Create Table: CREATE TABLE `t2` (
  `c1` int(11) NOT NULL AUTO_INCREMENT,
  `c2` varchar(10) DEFAULT NULL,
  PRIMARY KEY (`c1`)
) ENGINE=InnoDB AUTO_INCREMENT=1000001 DEFAULT CHARSET=utf8
1 row in set (0.00 sec)

(root@localhost) [test] &amp;gt; select count(*) from t2;
+----------+
| count(*) |
+----------+
|  1000000 |
+----------+
1 row in set (0.22 sec)

(root@localhost) [test] &amp;gt; select min(c1),max(c1) from t2;
+---------+---------+
| min(c1) | max(c1) |
+---------+---------+
|       1 | 1000000 |
+---------+---------+
1 row in set (0.01 sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;innodb_autoinc_lock_mode-0&quot;&gt;innodb_autoinc_lock_mode = 0&lt;/h4&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;(root@localhost) [test] &amp;gt; show global variables like 'innodb_autoinc_lock_mode';
+--------------------------+-------+
| Variable_name            | Value |
+--------------------------+-------+
| innodb_autoinc_lock_mode | 0     |
+--------------------------+-------+
1 row in set (0.02 sec)

-- 1、开启session 1执行TRX1
TRX1: insert into t1(c2) select c2 from t2;

(root@localhost) [test] &amp;gt; insert into t1(c2) select c2 from t2;
Query OK, 1000000 rows affected (6.37 sec)
Records: 1000000  Duplicates: 0  Warnings: 0

-- 2、在TRX1执行期间开启session 2执行TRX2
TRX2: insert into t1 (c1,c2) values (1,'test_inc_a'), (NULL,'test_inc_b'), (5,'test_inc_c'), (0,'test_inc_d');

(root@localhost) [test] &amp;gt; insert into t1 (c1,c2) values (1,'test_inc_a'), (NULL,'test_inc_b'), (5,'test_inc_c'), (0,'test_inc_d');
Query OK, 4 rows affected (5.01 sec)
Records: 4  Duplicates: 0  Warnings: 0

-- 3、查看TRX2插入值的记录
(root@localhost) [test] &amp;gt; select * from t1 where c2 in ('test_inc_a','test_inc_b','test_inc_c','test_inc_d');
+---------+------------+
| c1      | c2         |
+---------+------------+
|       1 | test_inc_a |
|       5 | test_inc_c |
| 1000101 | test_inc_b |
| 1000102 | test_inc_d |
+---------+------------+
4 rows in set (0.34 sec)

-- 4、查看当前AUTO_INCREMENT值

(root@localhost) [test] &amp;gt; select auto_increment from information_schema.tables where table_schema='test' and table_name='t1';
+----------------+
| auto_increment |
+----------------+
|        1000103 |
+----------------+
1 row in set (0.00 sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;TRX1：持有了 &lt;strong&gt;AUTO-INC&lt;/strong&gt; 表锁，自动分配了101~1000100的自增值，并保证是连续的；&lt;/li&gt;
&lt;li&gt;TRX2：需等待 &lt;strong&gt;AUTO-INC&lt;/strong&gt; 锁的释放，自动分配了1000101~1000102的自增值。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;可以看出下一个自增列值为 &lt;strong&gt;103&lt;/strong&gt;，因为自增列的值是在每条插入语句执行时分配的，而不是一开始就分配完的。&lt;/p&gt;
&lt;h4 id=&quot;innodb_autoinc_lock_mode-1&quot;&gt;innodb_autoinc_lock_mode = 1&lt;/h4&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;(root@localhost) [test] &amp;gt; show global variables like 'innodb_autoinc_lock_mode';
+--------------------------+-------+
| Variable_name            | Value |
+--------------------------+-------+
| innodb_autoinc_lock_mode | 1     |
+--------------------------+-------+
1 row in set (0.01 sec)

-- 1、开启session 1执行TRX1
TRX1: insert into t1(c2) select c2 from t2;

(root@localhost) [test] &amp;gt; insert into t1(c2) select c2 from t2;
Query OK, 1000000 rows affected (5.88 sec)
Records: 1000000  Duplicates: 0  Warnings: 0

-- 2、在TRX1执行期间开启session 2执行TRX2
TRX2: insert into t1 (c1,c2) values (1,'test_inc_a'), (NULL,'test_inc_b'), (5,'test_inc_c'), (0,'test_inc_d');

(root@localhost) [test] &amp;gt; insert into t1 (c1,c2) values (1,'test_inc_a'), (NULL,'test_inc_b'), (5,'test_inc_c'), (0,'test_inc_d');
Query OK, 4 rows affected (4.38 sec)
Records: 4  Duplicates: 0  Warnings: 0

-- 3、查看TRX2插入值的记录
(root@localhost) [test] &amp;gt; select * from t1 where c2 in ('test_inc_a','test_inc_b','test_inc_c','test_inc_d');
+---------+------------+
| c1      | c2         |
+---------+------------+
|       1 | test_inc_a |
|       5 | test_inc_c |
| 1048661 | test_inc_b |
| 1048662 | test_inc_d |
+---------+------------+
4 rows in set (0.32 sec)

-- 4、查看当前AUTO_INCREMENT值
(root@localhost) [test] &amp;gt; select auto_increment from information_schema.tables where table_schema='test' and table_name='t1';
+----------------+
| auto_increment |
+----------------+
|        1048665 |
+----------------+
1 row in set (0.00 sec)

-- 5、查看t1表的前10行记录、后10行记录和总行数
(root@localhost) [test] &amp;gt; select * from t1 order by c1 asc limit 10;
+-----+------------+
| c1  | c2         |
+-----+------------+
|   1 | test_inc_a |
|   5 | test_inc_c |
| 101 | CwAkHbEWs  |
| 102 | re         |
| 103 | uqrQbj     |
| 104 | SQ         |
| 105 | ojyPkMA    |
| 106 | 03qNqZ     |
| 107 | G8J        |
| 108 | Uo3        |
+-----+------------+
10 rows in set (0.00 sec)

(root@localhost) [test] &amp;gt; select * from t1 order by c1 asc limit 999994,10;
+---------+------------+
| c1      | c2         |
+---------+------------+
| 1000093 | o4AzuR     |
| 1000094 | NJMJJk     |
| 1000095 | 0o5xPuDnE  |
| 1000096 | QLLtImQC   |
| 1000097 | N1Fojm     |
| 1000098 | 6aZemarPC  |
| 1000099 | 4OUGSM1JzL |
| 1000100 | l8g6J      |
| 1048661 | test_inc_b |
| 1048662 | test_inc_d |
+---------+------------+
10 rows in set (0.32 sec)

(root@localhost) [test] &amp;gt; select count(*) from t1;
+----------+
| count(*) |
+----------+
|  1000004 |
+----------+
1 row in set (0.17 sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在此模式下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;TRX1：大量插入时持有 &lt;strong&gt;AUTO-INC&lt;/strong&gt; 表锁，自增列的值是预先分配的，101~10000100，总共100万个连续值；&lt;/li&gt;
&lt;li&gt;TRX2：混合插入情况下，语句为简单 &lt;strong&gt;INSERT&lt;/strong&gt; 语句，有的行自增列有指定值，而有的行没有，这时TRX2是无须等待持有 &lt;strong&gt;AUTO-INC&lt;/strong&gt; 锁的，由于TRX1语句还在执行，InnoDB并不知道需要分配多少个自增列值，也不清楚TRX用了多少个自增列值，所以在并行执行 &lt;strong&gt;INSERT&lt;/strong&gt; 时对于未指定行的自增列值分配就会产生间隙(1000100~1048661之间的间隙)，但是语句当中分配的自增列(1048661和1048662)值依然是连续的。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;可以看出下一个自增列值为 &lt;strong&gt;1048665&lt;/strong&gt; ，因为自增列值个数在语句执行开始就已经分配了4个(1048661~1048664)，但实际语句只使用了2个。&lt;/p&gt;
&lt;h4 id=&quot;innodb_autoinc_lock_mode-2&quot;&gt;innodb_autoinc_lock_mode = 2&lt;/h4&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;(root@localhost) [test] &amp;gt; show global variables like 'innodb_autoinc_lock_mode';
+--------------------------+-------+
| Variable_name            | Value |
+--------------------------+-------+
| innodb_autoinc_lock_mode | 2     |
+--------------------------+-------+
1 row in set (0.01 sec)

-- 1、开启session 1执行TRX1
TRX1: insert into t1(c2) select c2 from t2;

(root@localhost) [test] &amp;gt; insert into t1(c2) select c2 from t2;
Query OK, 1000000 rows affected (4.67 sec)
Records: 1000000  Duplicates: 0  Warnings: 0

-- 2、在TRX1执行期间开启session 2执行TRX2
TRX2: insert into t1 (c1,c2) values (1,'test_inc_a'), (NULL,'test_inc_b'), (5,'test_inc_c'), (0,'test_inc_d');

(root@localhost) [test] &amp;gt; insert into t1 (c1,c2) values (1,'test_inc_a'), (NULL,'test_inc_b'), (5,'test_inc_c'), (0,'test_inc_d');
Query OK, 4 rows affected (0.02 sec)
Records: 4  Duplicates: 0  Warnings: 0

-- 3、查看TRX2插入值的记录
(root@localhost) [test] &amp;gt; select * from t1 where c2 in ('test_inc_a','test_inc_b','test_inc_c','test_inc_d');
+--------+------------+
| c1     | c2         |
+--------+------------+
|      1 | test_inc_a |
|      5 | test_inc_c |
| 262241 | test_inc_b |
| 262242 | test_inc_d |
+--------+------------+
4 rows in set (0.28 sec)

-- 4、查看当前AUTO_INCREMENT值
(root@localhost) [test] &amp;gt; select auto_increment from information_schema.tables where table_schema='test' and table_name='t1';
+----------------+
| auto_increment |
+----------------+
|        1048665 |
+----------------+
1 row in set (0.00 sec)

-- 5、查看t1表的前10行记录、后10行记录和总行数
(root@localhost) [test] &amp;gt; select * from t1 order by c1 asc limit 10;
+-----+------------+
| c1  | c2         |
+-----+------------+
|   1 | test_inc_a |
|   5 | test_inc_c |
| 101 | CwAkHbEWs  |
| 102 | re         |
| 103 | uqrQbj     |
| 104 | SQ         |
| 105 | ojyPkMA    |
| 106 | 03qNqZ     |
| 107 | G8J        |
| 108 | Uo3        |
+-----+------------+
10 rows in set (0.00 sec)

(root@localhost) [test] &amp;gt; select * from t1 order by c1 asc limit 999994,10;
+---------+------------+
| c1      | c2         |
+---------+------------+
| 1000095 | KHukB      |
| 1000096 | bnpyaevl79 |
| 1000097 | o4AzuR     |
| 1000098 | NJMJJk     |
| 1000099 | 0o5xPuDnE  |
| 1000100 | QLLtImQC   |
| 1000101 | N1Fojm     |
| 1000102 | 6aZemarPC  |
| 1000103 | 4OUGSM1JzL |
| 1000104 | l8g6J      |
+---------+------------+
10 rows in set (0.22 sec)

(root@localhost) [test] &amp;gt; select count(*) from t1;
+----------+
| count(*) |
+----------+
|  1000004 |
+----------+
1 row in set (0.17 sec)

-- 6、查看TRX2插入时产生间隙位置行记录
(root@localhost) [test] &amp;gt; select * from t1 where c1 between 262240 and 262250;
+--------+------------+
| c1     | c2         |
+--------+------------+
| 262240 | mNfx37     |
| 262241 | test_inc_b |
| 262242 | test_inc_d |
| 262245 | Taqi       |
| 262246 | Ojpakez    |
| 262247 | 2fKtmm6rW  |
| 262248 | AysE       |
| 262249 | wqWGs      |
| 262250 | lC         |
+--------+------------+
9 rows in set (0.00 sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在此模式下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;TRX1：因为大量插入时是不持有 &lt;strong&gt;AUTO-INC&lt;/strong&gt; 表锁，所在TRX1在执行期间，TRX2很快就插入完成并分配了自增列值。&lt;/li&gt;
&lt;li&gt;TRX2：简单插入语句时可以判断出须分配4个自增列值，但是只使用了2个，这样就造成了2个间隙(262243~262244)。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;可以看出下一个自增列值为 &lt;strong&gt;1048665&lt;/strong&gt; ，TRX1执行时因为大量插入时无法预估插入值数量，TRX2执行时分配了4个自增值，但只使用了2个(262241~262242)，造成了2个间隙，TRX1和TRX2的自增列值是交叉分配的。&lt;/p&gt;
&lt;h3 id=&quot;修改自增列当中的值&quot;&gt;修改自增列当中的值&lt;/h3&gt;
&lt;p&gt;无论 &lt;strong&gt;AUTO_INCREMENT&lt;/strong&gt; 处于哪种锁模式下，更新自增列的值都有可能会产生 &lt;strong&gt;Duplicate entry&lt;/strong&gt; 重复值错误。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;-- 测试表：

(root@localhost) [test] &amp;gt; create table t3 (c1 int not null auto_increment primary key);
Query OK, 0 rows affected (0.06 sec)

(root@localhost) [test] &amp;gt; show create table t3\G;
*************************** 1. row ***************************
       Table: t3
Create Table: CREATE TABLE `t3` (
  `c1` int(11) NOT NULL AUTO_INCREMENT,
  PRIMARY KEY (`c1`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8
1 row in set (0.00 sec)

-- 1、插入几行数据
(root@localhost) [test] &amp;gt; insert into t3 values(0),(0),(3);
Query OK, 3 rows affected (0.04 sec)
Records: 3  Duplicates: 0  Warnings: 0

(root@localhost) [test] &amp;gt; select * from t3;
+----+
| c1 |
+----+
|  1 |
|  2 |
|  3 |
+----+
3 rows in set (0.00 sec)

(root@localhost) [test] &amp;gt; select auto_increment from information_schema.tables where table_schema='test' and table_name='t3';
+----------------+
| auto_increment |
+----------------+
|              4 |
+----------------+
1 row in set (0.00 sec)

-- 2、更新c1值为5
(root@localhost) [test] &amp;gt; update t3 set c1 = 5 where c1 = 3;
Query OK, 1 row affected (0.03 sec)
Rows matched: 1  Changed: 1  Warnings: 0

(root@localhost) [test] &amp;gt; select * from t3;
+----+
| c1 |
+----+
|  1 |
|  2 |
|  5 |
+----+
3 rows in set (0.00 sec)

(root@localhost) [test] &amp;gt; select auto_increment from information_schema.tables where table_schema='test' and table_name='t3';
+----------------+
| auto_increment |
+----------------+
|              4 |
+----------------+
1 row in set (0.00 sec)

-- 3、再次插入几行数据
(root@localhost) [test] &amp;gt; insert into t3 values(0),(0),(3);
ERROR 1062 (23000): Duplicate entry '5' for key 'PRIMARY'

(root@localhost) [test] &amp;gt; select * from t3;
+----+
| c1 |
+----+
|  1 |
|  2 |
|  5 |
+----+
3 rows in set (0.00 sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看出更新了自增列的值之后产生了 &lt;strong&gt;Duplicate entry&lt;/strong&gt; 重复值错误。建议不要更新自增列的值，或是把自增列值更新为大于 &lt;strong&gt;AUTO_INCREMENT&lt;/strong&gt; 的值。&lt;/p&gt;
&lt;h2 id=&quot;auto_increment计数器的初始化&quot;&gt;AUTO_INCREMENT计数器的初始化&lt;/h2&gt;
&lt;p&gt;当为一张InnoDB表指定自增列时，此时表在数据字典中维护着一个特殊的计数器为自增列分配值，名称为 &lt;strong&gt;auto_increment&lt;/strong&gt; 计数器，这个计数器是存储中内存中，而不是在磁盘上。&lt;/p&gt;
&lt;p&gt;当服务器重启之后后，为了初始化 &lt;strong&gt;auto_increment&lt;/strong&gt; 计数器，InnoDB执行如下等效语句来确定自增列下个需要分配的值：&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;SELECT MAX(ai_col) FROM table_name FOR UPDATE;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;默认的，自增列的下一个分配值由以上语句得出的值增加 &lt;strong&gt;1&lt;/strong&gt; ，这个增加步长由参数 &lt;strong&gt;auto_increment_increment&lt;/strong&gt; 决定。如果是空表，则自增列的下一个分配值为 &lt;strong&gt;1&lt;/strong&gt; ，这个空表时默认值由参数 &lt;strong&gt;auto_increment_offset&lt;/strong&gt; 决定。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当表中指定自增列，如果没有为自增列值指定值，则由计数器分配。如果为自增列指定了值，还是插入指定的值。如果指定插入值大于计数器的值，同时计数器也会跟着调整，这样容易造成间隙。&lt;/li&gt;
&lt;li&gt;由于计数据器是运行在内存中，所以当服务器重启后，InnoDB会重新初始化计数器。&lt;/li&gt;
&lt;li&gt;服务器重启的同时也重置了之前 &lt;strong&gt;CREATE TABLE&lt;/strong&gt; 和 &lt;strong&gt;ALTER TABLE&lt;/strong&gt; 为表指定的 &lt;strong&gt;AUTO_INCREMENT&lt;/strong&gt; 值，可以再次通过语句进行指定。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/innodb-auto-increment-handling.html&quot;&gt;&lt;strong&gt;https://dev.mysql.com/doc/refman/5.7/en/innodb-auto-increment-handling.html&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;☆〖本人水平有限，文中如有错误还请留言批评指正！〗☆&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 25 Dec 2018 14:20:00 +0000</pubDate>
<dc:creator>H_Johnny</dc:creator>
<og:description>正文 之前有碰到过开发同事指出一张InnoDB表的自增列 AUTO_INCREMENT 值莫明的变大，由于这张表是通过mysqldump导出导入的。 问题排查： 1、首先，查看表表义的sql部分的 a</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dbabd/p/10169197.html</dc:identifier>
</item>
<item>
<title>前端完整学习路线 - pycmsj</title>
<link>http://www.cnblogs.com/pycmsj/p/10176691.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pycmsj/p/10176691.html</guid>
<description>&lt;h3&gt;第一阶段：&lt;/h3&gt;

&lt;p&gt;HTML+CSS:&lt;/p&gt;
&lt;p&gt;HTML进阶、CSS进阶、div+css布局、HTML+css整站开发、&lt;/p&gt;

&lt;p&gt;JavaScript基础：&lt;/p&gt;
&lt;p&gt;Js基础教程、js内置对象常用方法、常见DOM树操作大全、ECMAscript、DOM、BOM、定时器和焦点图。&lt;/p&gt;

&lt;p&gt;JS基本特效：&lt;/p&gt;
&lt;p&gt;常见特效、例如：tab、导航、整页滚动、轮播图、JS制作幻灯片、弹出层、手风琴菜单、瀑布流布局、滚动事件、滚差视图。&lt;/p&gt;

&lt;p&gt;JS高级特征：&lt;/p&gt;
&lt;p&gt;正则表达式、排序算法、递归算法、闭包、函数节流、作用域链、基于距离运动框架、面向对象基础、&lt;/p&gt;

&lt;p&gt;JQuery：基础使用&lt;/p&gt;
&lt;p&gt;悬着器、DOM操作、特效和动画、方法链、拖拽、变形、JQueryUI组件基本使用。&lt;/p&gt;

&lt;h3&gt;第二阶段：HTML5和移动Web开发&lt;/h3&gt;

&lt;p&gt;HTML5：&lt;/p&gt;
&lt;p&gt;HTML5新语义标签、HTML5表单、音频和视频、离线和本地存储、SVG、Web Socket、Canvas.&lt;/p&gt;

&lt;p&gt;CSS3:&lt;/p&gt;
&lt;p&gt;CSS3新选择器、伪元素、脸色表示法、边框、阴影、background系列属性改变、Transition、动画、景深和深透、3D效果制作、Velocity.js框架、元素进场、出场策略、炫酷CSS3网页制作。&lt;/p&gt;

&lt;p&gt;Bootstrap:&lt;/p&gt;
&lt;p&gt;响应式概念、媒体查询、响应式网站制作、删格系统、删格系统原理、Bootstrap常用模板、LESS和SASS。&lt;/p&gt;

&lt;p&gt;移动Web开发：&lt;/p&gt;
&lt;p&gt;跨终端WEB和主流设备简介、视口、流式布局、弹性盒子、rem、移动终端JavaScript事件、手机中常见JS效果制作、Zepto.js、手机聚划算页面、手机滚屏。&lt;/p&gt;

&lt;h3&gt;第三阶段：HTTP服务和AJAX编程&lt;/h3&gt;

&lt;p&gt;WEB服务器基础：&lt;/p&gt;
&lt;p&gt;服务器基础知识、Apache服务器和其他WEB服务器介绍、Apache服务器搭建、HTTP介绍。&lt;/p&gt;

&lt;p&gt;PHP基础：&lt;/p&gt;
&lt;p&gt;PHP基础语法、使用PHP处理简单的GET或者POST请求、&lt;/p&gt;

&lt;p&gt;AJAX上篇：&lt;/p&gt;
&lt;p&gt;Ajax简介和异步的概念、Ajax框架的封装、XMLHttpRequest对象详细介绍方法、兼容性处理方法、Ajax框架的封装、Ajax中缓存问题、XML介绍和使用。&lt;/p&gt;

&lt;p&gt;AJAX下篇：&lt;/p&gt;
&lt;p&gt;JSON和JSON解析、数据绑定和模板技术、JSONP、跨域技术、图片预读取和lazy-load技术、JQuery框架中的AjaxAPI、使用Ajax实现爆布流案例额。&lt;/p&gt;

&lt;h3&gt;第四阶段：面向对象进阶&lt;/h3&gt;

&lt;p&gt;面向对象终极篇：&lt;/p&gt;
&lt;p&gt;从内存角度到理解JS面向对象、基本类型、复杂类型、原型链、ES6中的面向对象、属性读写权限、设置器、访问器。&lt;/p&gt;

&lt;p&gt;面向对象三大特征：&lt;/p&gt;
&lt;p&gt;继承性、多态性、封装性、接口。&lt;/p&gt;

&lt;p&gt;设计模式：&lt;/p&gt;
&lt;p&gt;面向对象编程思维、单例模式、工厂模式、策略模式、观察者模式、模板方法模式、代理模式、装饰者模式、适配器模式、面向切面编程。&lt;/p&gt;

&lt;h3&gt;第五阶段：封装一个属于自己的框架&lt;/h3&gt;

&lt;p&gt;框架封装基础：&lt;/p&gt;
&lt;p&gt;事件流、冒泡、捕获、事件对象、事件框架、选择框架。&lt;/p&gt;

&lt;p&gt;框架封装中级：&lt;/p&gt;
&lt;p&gt;运动原理、单物体运动框架、多物体运动框架、运动框架面向对象封装。&lt;/p&gt;

&lt;p&gt;框架封装高级和补充：&lt;/p&gt;
&lt;p&gt;JQuery框架雏形、可扩展性、模块化、封装属于传智自己的框架。&lt;/p&gt;

&lt;h3&gt;第六阶段：模块化组件开发&lt;/h3&gt;

&lt;p&gt;面向组件编程：&lt;/p&gt;
&lt;p&gt;面向组件编程的方式、面向组件编程的实现原理、面向组件编程实战、基于组件化思想开发网站应用程序。&lt;/p&gt;

&lt;p&gt;面向模块编程：&lt;/p&gt;
&lt;p&gt;AMD设计规范、CMD设计规范、RequireJS，LoadJS、淘宝的SeaJS。&lt;/p&gt;

&lt;h3&gt;第七阶段：主流的流行框架&lt;/h3&gt;

&lt;p&gt;Web开发工作流：&lt;/p&gt;
&lt;p&gt;GIT/SVN、Yeoman脚手架、NPM/Bower依赖管理工具、Grunt/Gulp/Webpack。&lt;/p&gt;

&lt;p&gt;MVC/MVVM/MVW框架：&lt;/p&gt;
&lt;p&gt;Angular.js、Backbone.js、Knockout/Ember。&lt;/p&gt;

&lt;p&gt;常用库：&lt;/p&gt;
&lt;p&gt;React.js、Vue.js、Zepto.js。&lt;/p&gt;

&lt;h3&gt;第八阶段：HTML5原生移动应用开发&lt;/h3&gt;

&lt;p&gt;Cordova：&lt;/p&gt;
&lt;p&gt;WebApp/NativeApp/HybirdApp简介、Cordova简介、与PhoneGap之间的关系、开发环境搭建、Cordova实战（创建项目，配置，编译，调试，部署发布）。&lt;/p&gt;

&lt;p&gt;Ionic：&lt;/p&gt;
&lt;p&gt;Ionic简介和同类对比、模板项目解析、常见组件及使用、结合Angular构建APP、常见效果（下拉刷新，上拉加载，侧滑导航，选项卡）。&lt;/p&gt;

&lt;p&gt;React Native：&lt;/p&gt;
&lt;p&gt;React Native简介、React Native环境配置、创建项目，配置，编译，调试，部署发布、原生模块和UI组件、原生常用API。&lt;/p&gt;

&lt;p&gt;HTML5+：&lt;/p&gt;
&lt;p&gt;HTML5+中国产业联盟、HTML5 Plus Runtime环境、HBuilder开发工具、MUI框架、H5+开发和部署。&lt;/p&gt;

&lt;h3&gt;第九阶段： Node.js全栈开发：&lt;/h3&gt;

&lt;p&gt;快速入门：&lt;/p&gt;
&lt;p&gt;Node.js发展、生态圈、Io.js、Linux/Windows/OS X环境配置、REPL环境和控制台程序、异步编程，非阻塞I/O、模块概念，模块管理工具、开发流程，调试，测试。&lt;/p&gt;

&lt;p&gt;核心模块和对象：&lt;/p&gt;
&lt;p&gt;全局对象global，process，console，util、事件驱动，事件发射器、加密解密，路径操作，序列化和反序列化、文件流操作、HTTP服务端与客户端、Socket.IO。&lt;/p&gt;

&lt;p&gt;Web开发基础：&lt;/p&gt;
&lt;p&gt;HTTP协议，请求响应处理过程、关系型数据库操作和数据访问、非关系型数据库操作和数据访问、原生的Node.js开发Web应用程序、Web开发工作流、Node.js开发Blog案例。&lt;/p&gt;

&lt;p&gt;快速开发框架：&lt;/p&gt;
&lt;p&gt;Express简介+MVC简介、Express常用API、Express路由模块、Jade/Ejs模板引擎、使用Express重构Blog案例、Koa等其他常见MVC框架。&lt;/p&gt;

&lt;p&gt;Node.js开发电子商务实战：&lt;/p&gt;
&lt;p&gt;需求与设计、账户模块注册登录、会员中心模块、前台展示模块、购物车，订单结算、在线客服即时通讯模块。&lt;/p&gt;
</description>
<pubDate>Tue, 25 Dec 2018 13:50:00 +0000</pubDate>
<dc:creator>pycmsj</dc:creator>
<og:description>第一阶段： HTML+CSS: HTML进阶、CSS进阶、div+css布局、HTML+css整站开发、 JavaScript基础： Js基础教程、js内置对象常用方法、常见DOM树操作大全、ECMA</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pycmsj/p/10176691.html</dc:identifier>
</item>
<item>
<title>【web开发】docker中的数据库 - 昕-2008</title>
<link>http://www.cnblogs.com/Belter/p/10174851.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Belter/p/10174851.html</guid>
<description>&lt;p&gt;&lt;span&gt;注&lt;/span&gt;：自从开始使用docker，部署方面的事情就简单多了。使用docker构建的数据库容器不用直接安装，开启后就可以使用，也比以前方便很多。下面将一些要点记录下来。&lt;/p&gt;
&lt;p&gt;下面的例子使用以下环境：&lt;/p&gt;
&lt;p&gt;- 系统：CentOS Linux release 7.4.1708&lt;/p&gt;
&lt;p&gt;- docker：Docker version 17.12.0-ce, build c97c6d6&lt;/p&gt;
&lt;p&gt;- 数据库：MariaDB 5.5&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;启动数据库&lt;/span&gt;&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;MariaDB是MySQL的一个分支，使用起来基本上没有什么差别。在docker hub中有该数据库的官方镜像，使用下面的简单命令就可以开启一个数据库容器，开启后可以利用端口ip+端口号的方式访问该数据库。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; [belter@localhost ~]$ docker run -d -p &lt;span&gt;3301&lt;/span&gt;:&lt;span&gt;3306&lt;/span&gt; -v ~/mdbdata/mdb55:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=admin --name mdb55 mariadb:&lt;span&gt;5.5&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;c7f2cd8ed93de8ab8ab58171c375e83fb2659c2a1cdab2ec79c264cb78b1e131
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; [belter@localhost ~]$ docker &lt;span&gt;ps&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; c7f2cd8ed93d mariadb:&lt;span&gt;5.5&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;docker-entrypoint.s…&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; About a minute ago Up About a minute &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;:&lt;span&gt;3301&lt;/span&gt;-&amp;gt;&lt;span&gt;3306&lt;/span&gt;/tcp mdb55
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;使用第1行的命令，就可以开启一个数据库容器，主要参数：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;-d&lt;/span&gt;: 后台运行；&lt;/p&gt;
&lt;p&gt;&lt;span&gt;-p&lt;/span&gt;: 端口，&lt;span&gt;3301:3306&lt;/span&gt;表示host上的3301端口对于容器中3306端口；&lt;/p&gt;
&lt;p&gt;&lt;span&gt;-v&lt;/span&gt;: 表示volumes，用来设置数据文件存放的位置，&lt;span&gt;~/mdbdata/mdb55:/var/lib/mysql&lt;/span&gt;表示host中当前用户home/mdbdata/mdb55挂载于容器中的/var/lib/mysql目录，这样即使容器被删除数据文件还是可以保留；&lt;/p&gt;
&lt;p&gt;&lt;span&gt;-e&lt;/span&gt;: 表示environment，用来设置用户及密码等信息，&lt;span&gt;MYSQL_ROOT_PASSWORD=admin&lt;/span&gt;表示将root的密码设置为admin；&lt;/p&gt;
&lt;p&gt;&lt;span&gt;--name&lt;/span&gt;: 表示容器的名称，例如现在这个数据库容器的名称为mdb55&lt;/p&gt;
&lt;p&gt;命令的最后是镜像的名称，&lt;span&gt;mariadb:5.5&lt;/span&gt;表示MariaDB-5.5&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第2行是返回的容器的编号&lt;/li&gt;
&lt;li&gt;第3行的命令用来查看当前运行的容器列表，第4-5行可以看到刚刚启动的数据库容器的基本信息&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;此外可以使用下面的命令查看全部容器的状态（包括已经停止运行的容器），以及删除容器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; [belter@localhost ~]$ docker &lt;span&gt;ps&lt;/span&gt; -&lt;span&gt;a  # 查看所有的容器
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; [belter@localhost ~]$ docker &lt;span&gt;rm&lt;/span&gt; 92a1bcd89578  # 删除ID为92a1bcd89578的容器
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Mariadb在docker hub中的&lt;a href=&quot;https://hub.docker.com/_/mariadb/&quot; target=&quot;_blank&quot;&gt;官方网站&lt;/a&gt;，以及build镜像mariadb:5.5的&lt;span class=&quot;final-path&quot;&gt;&lt;a href=&quot;https://github.com/docker-library/mariadb/blob/master/5.5/Dockerfile&quot; target=&quot;_blank&quot;&gt;Dockerfile文件&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;下面测试一下刚启动的数据库容器的连接：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [belter@localhost ~]$ mysql -u root -padmin -h &lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt; -&lt;span&gt;P3301
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;Welcome to the MariaDB monitor.  Commands end with ; or \g.
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; Your MariaDB connection &lt;span&gt;id&lt;/span&gt; is &lt;span&gt;3&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; Server version: &lt;span&gt;5.5&lt;/span&gt;.&lt;span&gt;60&lt;/span&gt;-MariaDB-&lt;span&gt;1&lt;/span&gt;~&lt;span&gt;trusty mariadb.org binary distribution
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; Copyright (c) &lt;span&gt;2000&lt;/span&gt;, &lt;span&gt;2017&lt;/span&gt;&lt;span&gt;, Oracle, MariaDB Corporation Ab and others.
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; Type &lt;span&gt;'&lt;/span&gt;&lt;span&gt;help;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; or &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\h&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; help. Type &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; to &lt;span&gt;clear&lt;/span&gt;&lt;span&gt; the current input statement.
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; MariaDB [(none)]&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在已经可以正常连接该数据库了（由于这里使用了host中的mysql命令，因此需要先安装mysql才能使用）。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;注意&lt;span&gt;-padmin&lt;/span&gt;和&lt;span&gt;-P3301&lt;/span&gt;之间没有空格，一个表示user的密码，另一个表示连接的端口号；&lt;/li&gt;
&lt;li&gt;-h: 表示host的IP地址，这里连接的是本地IP+3301端口，该端口对应于容器中的3306端口；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上面使用host中的mysql来连接容器中的数据库，需要先在本地安装mysql（或MariaDB）。此外也可以直接进入容器内部连接该数据库：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [belter@localhost ~]$ docker exec -it c7f2cd8ed93d /bin/&lt;span&gt;bash
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; root@c7f2cd8ed93d:/# mysql -u root -padmin -h &lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt; -&lt;span&gt;P3306
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;Welcome to the MariaDB monitor.  Commands end with ; or \g.
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; Your MariaDB connection &lt;span&gt;id&lt;/span&gt; is &lt;span&gt;4&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; Server version: &lt;span&gt;5.5&lt;/span&gt;.&lt;span&gt;60&lt;/span&gt;-MariaDB-&lt;span&gt;1&lt;/span&gt;~&lt;span&gt;trusty mariadb.org binary distribution
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; Copyright (c) &lt;span&gt;2000&lt;/span&gt;, &lt;span&gt;2018&lt;/span&gt;&lt;span&gt;, Oracle, MariaDB Corporation Ab and others.
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; Type &lt;span&gt;'&lt;/span&gt;&lt;span&gt;help;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; or &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\h&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; help. Type &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; to &lt;span&gt;clear&lt;/span&gt;&lt;span&gt; the current input statement.
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; MariaDB [(none)]&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;使用第1行命令，进入刚才启动的数据库容器（ID为c7f2cd8ed93d）的bash；&lt;/li&gt;
&lt;li&gt;进入容器后，使用第2行命令连接容器内部的数据库，此时使用的端口号是3306.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;注：退出数据库和容器都可以使用&quot;&lt;span&gt;exit;&lt;/span&gt;&quot;&lt;/p&gt;

&lt;p&gt;为了测试修改密码以及数据文件的重用，在数据库中做了以下修改：修改root的密码，创建了一个新的数据库以及表&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;# 修改root的密码为admin1，并更新权限列表
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;SET&lt;/span&gt; PASSWORD &lt;span&gt;FOR&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;@&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; PASSWORD(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;admin1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; FLUSH &lt;span&gt;PRIVILEGES&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;# 创建数据库test，并在该数据库中创建表table1
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;DATABASE&lt;/span&gt;&lt;span&gt; test;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt; table1(
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;  col1 &lt;span&gt;VARCHAR&lt;/span&gt;(&lt;span&gt;50&lt;/span&gt;&lt;span&gt;),
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;  col2 &lt;span&gt;VARCHAR&lt;/span&gt;(&lt;span&gt;50&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;# 在表table1中插入两行记录
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; table1(col1, col2) &lt;span&gt;VALUES&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Belter&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;), (&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Merry Christmas&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;数据文件可以直接复制到另一个文件夹来备份（所有者修改为ods:ssh_keys，与原数据文件相同）&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;使用docker-compose配置数据库&lt;/span&gt;&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;利用上面的方法可以快速开启一个数据库容器，连接后就可以使用了。但是配置的参数都写在命令行中不利于后面的维护。此时可以使用docker-compose来保存配置文件：&lt;/p&gt;
&lt;p&gt;对于数据库来说，主要需要以下几方面的配置：用户及密码，数据文件存放的位置，端口，字符集。&lt;/p&gt;
&lt;p&gt;下面是我的配置文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; version: '2.2'
&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;services:
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;  db:
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     image: mariadb:5.5
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    restart: always
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    environment:
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;      - MYSQL_HOST=localhost
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;       - MYSQL_PORT=3306&lt;span&gt; # port in container
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;      - MYSQL_ROOT_HOST=%
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;      - MYSQL_DATABASE=test
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;      - MYSQL_USER=belter
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;      - TZ=Asia/Shanghai
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    volumes:
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;      - ~/mdbdata/mdb55:/var/lib/mysql
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    ports:
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;       - 3303:3306
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    command:
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;      - --character-set-server=utf8mb4
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;      - --collation-server=utf8mb4_unicode_ci
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;       - --skip-character-set-client-handshake
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;更多关于docker-compose.yml文件的介绍，可参考我的上一篇博客：&lt;a href=&quot;https://www.cnblogs.com/Belter/p/9886081.html&quot; target=&quot;_blank&quot;&gt;使用docker搭建数据分析环境&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;environment是对容器内部来说的，第10行设置为&quot;%&quot;表示允许使用root远程连接数据库，第11行指定了MYSQL_USER直接访问的数据库，MYSQL_USER需要手动添加；&lt;/li&gt;
&lt;li&gt;修改完root密码后，就不需要在environment中指定MYSQL_ROOT_PASSWORD这一参数了，该参数相当于指定了数据库初始化时的root密码；&lt;/li&gt;
&lt;li&gt;第19-21行，配置了数据库的字符集，更多可参考&lt;a href=&quot;http://ourmysql.com/archives/1402&quot; target=&quot;_blank&quot;&gt;link1&lt;/a&gt;, &lt;a href=&quot;http://blog.sina.com.cn/s/blog_6a6c136d0101ajpd.html&quot; target=&quot;_blank&quot;&gt;link2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;端口换成3303&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;停止之前运行的容器，并使用docker-compose启动上面配置好的容器：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;[belter@localhost mariadb]$ docker stop c7f2cd8ed93d
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;c7f2cd8ed93d
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; [belter@localhost mariadb]$ docker-compose up -&lt;span&gt;d
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; Creating network &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mariadb_default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; with the default driver
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; Creating mariadb_db_1 ... &lt;span&gt;done&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; [belter@localhost mariadb]$ docker-&lt;span&gt;compose logs
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;Attaching to mariadb_db_1
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; db_1  | &lt;span&gt;181225&lt;/span&gt; &lt;span&gt;18&lt;/span&gt;:&lt;span&gt;04&lt;/span&gt;:&lt;span&gt;11&lt;/span&gt; [Note] mysqld (mysqld &lt;span&gt;5.5&lt;/span&gt;.&lt;span&gt;60&lt;/span&gt;-MariaDB-&lt;span&gt;1&lt;/span&gt;~trusty) starting as process &lt;span&gt;1&lt;/span&gt;&lt;span&gt; ...
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; db_1  | &lt;span&gt;181225&lt;/span&gt; &lt;span&gt;18&lt;/span&gt;:&lt;span&gt;04&lt;/span&gt;:&lt;span&gt;11&lt;/span&gt;&lt;span&gt; InnoDB: The InnoDB memory heap is disabled
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; db_1  | &lt;span&gt;181225&lt;/span&gt; &lt;span&gt;18&lt;/span&gt;:&lt;span&gt;04&lt;/span&gt;:&lt;span&gt;11&lt;/span&gt;&lt;span&gt; InnoDB: Mutexes and rw_locks use GCC atomic builtins
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; db_1  | &lt;span&gt;181225&lt;/span&gt; &lt;span&gt;18&lt;/span&gt;:&lt;span&gt;04&lt;/span&gt;:&lt;span&gt;11&lt;/span&gt; InnoDB: Compressed tables use zlib &lt;span&gt;1.2&lt;/span&gt;.&lt;span&gt;8&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; db_1  | &lt;span&gt;181225&lt;/span&gt; &lt;span&gt;18&lt;/span&gt;:&lt;span&gt;04&lt;/span&gt;:&lt;span&gt;11&lt;/span&gt;&lt;span&gt; InnoDB: Using Linux native AIO
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; db_1  | &lt;span&gt;181225&lt;/span&gt; &lt;span&gt;18&lt;/span&gt;:&lt;span&gt;04&lt;/span&gt;:&lt;span&gt;11&lt;/span&gt; InnoDB: Initializing buffer pool, size = &lt;span&gt;256.0M&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; db_1  | &lt;span&gt;181225&lt;/span&gt; &lt;span&gt;18&lt;/span&gt;:&lt;span&gt;04&lt;/span&gt;:&lt;span&gt;11&lt;/span&gt;&lt;span&gt; InnoDB: Completed initialization of buffer pool
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; db_1  | &lt;span&gt;181225&lt;/span&gt; &lt;span&gt;18&lt;/span&gt;:&lt;span&gt;04&lt;/span&gt;:&lt;span&gt;11&lt;/span&gt; InnoDB: highest supported &lt;span&gt;file&lt;/span&gt;&lt;span&gt; format is Barracuda.
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; db_1  | &lt;span&gt;181225&lt;/span&gt; &lt;span&gt;18&lt;/span&gt;:&lt;span&gt;04&lt;/span&gt;:&lt;span&gt;11&lt;/span&gt;  InnoDB: Waiting &lt;span&gt;for&lt;/span&gt;&lt;span&gt; the background threads to start
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; db_1  | &lt;span&gt;181225&lt;/span&gt; &lt;span&gt;18&lt;/span&gt;:&lt;span&gt;04&lt;/span&gt;:&lt;span&gt;12&lt;/span&gt; Percona XtraDB (http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.percona.com) 5.5.59-MariaDB-38.11 started; log sequence number 1601918&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; db_1  | &lt;span&gt;181225&lt;/span&gt; &lt;span&gt;18&lt;/span&gt;:&lt;span&gt;04&lt;/span&gt;:&lt;span&gt;12&lt;/span&gt; [Note] Plugin &lt;span&gt;'&lt;/span&gt;&lt;span&gt;FEEDBACK&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; is disabled.
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; db_1  | &lt;span&gt;181225&lt;/span&gt; &lt;span&gt;18&lt;/span&gt;:&lt;span&gt;04&lt;/span&gt;:&lt;span&gt;12&lt;/span&gt; [Note] Server socket created on IP: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;0.0.0.0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; db_1  | &lt;span&gt;181225&lt;/span&gt; &lt;span&gt;18&lt;/span&gt;:&lt;span&gt;04&lt;/span&gt;:&lt;span&gt;12&lt;/span&gt; [Warning] &lt;span&gt;'&lt;/span&gt;&lt;span&gt;proxies_priv&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; entry &lt;span&gt;'&lt;/span&gt;&lt;span&gt;@ root@c7f2cd8ed93d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; ignored &lt;span&gt;in&lt;/span&gt; --skip-name-&lt;span&gt;resolve mode.
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; db_1  | &lt;span&gt;181225&lt;/span&gt; &lt;span&gt;18&lt;/span&gt;:&lt;span&gt;04&lt;/span&gt;:&lt;span&gt;12&lt;/span&gt; [Note] Event Scheduler: Loaded &lt;span&gt;0&lt;/span&gt;&lt;span&gt; events
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; db_1  | &lt;span&gt;181225&lt;/span&gt; &lt;span&gt;18&lt;/span&gt;:&lt;span&gt;04&lt;/span&gt;:&lt;span&gt;12&lt;/span&gt; [Note] mysqld: ready &lt;span&gt;for&lt;/span&gt;&lt;span&gt; connections.
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; db_1  | Version: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;5.5.60-MariaDB-1~trusty&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;  socket: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/var/run/mysqld/mysqld.sock&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;  port: &lt;span&gt;3306&lt;/span&gt;  mariadb.org binary distribution
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;第1行停止了之前的容器（停止后3301端口就无法访问了）；&lt;/li&gt;
&lt;li&gt;第3行从docker-compose启动了新的数据库容器；&lt;/li&gt;
&lt;li&gt;第6行查看容器开启之后的日志，第22行显示数据库以及可以正常连接了.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;使用上面的方法，连接host的3303端口：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [xiongxin@localhost mariadb]$ mysql -u root -padmin1 -h &lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt; -&lt;span&gt;P3303
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;Welcome to the MariaDB monitor.  Commands end with ; or \g.
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; Your MariaDB connection &lt;span&gt;id&lt;/span&gt; is &lt;span&gt;2&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; Server version: &lt;span&gt;5.5&lt;/span&gt;.&lt;span&gt;60&lt;/span&gt;-MariaDB-&lt;span&gt;1&lt;/span&gt;~&lt;span&gt;trusty mariadb.org binary distribution
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; Copyright (c) &lt;span&gt;2000&lt;/span&gt;, &lt;span&gt;2017&lt;/span&gt;&lt;span&gt;, Oracle, MariaDB Corporation Ab and others.
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; Type &lt;span&gt;'&lt;/span&gt;&lt;span&gt;help;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; or &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\h&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; help. Type &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; to &lt;span&gt;clear&lt;/span&gt;&lt;span&gt; the current input statement.
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; MariaDB [(none)]&amp;gt;&lt;span&gt; show databases;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; +--------------------+
&lt;span&gt;12&lt;/span&gt; | Database           |
&lt;span&gt;13&lt;/span&gt; +--------------------+
&lt;span&gt;14&lt;/span&gt; | information_schema |
&lt;span&gt;15&lt;/span&gt; | mysql              |
&lt;span&gt;16&lt;/span&gt; | performance_schema |
&lt;span&gt;17&lt;/span&gt; | test               |
&lt;span&gt;18&lt;/span&gt; +--------------------+
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;4&lt;/span&gt; rows &lt;span&gt;in&lt;/span&gt; set (&lt;span&gt;0.00&lt;/span&gt;&lt;span&gt; sec)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; MariaDB [(none)]&amp;gt; &lt;span&gt;select&lt;/span&gt; *&lt;span&gt; from test.table1;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; +------+-----------------+
&lt;span&gt;23&lt;/span&gt; | col1 | col2            |
&lt;span&gt;24&lt;/span&gt; +------+-----------------+
&lt;span&gt;25&lt;/span&gt; | &lt;span&gt;1&lt;/span&gt;    | Belter          |
&lt;span&gt;26&lt;/span&gt; | &lt;span&gt;2&lt;/span&gt;    | Merry Christmas |
&lt;span&gt;27&lt;/span&gt; +------+-----------------+
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; rows &lt;span&gt;in&lt;/span&gt; set (&lt;span&gt;0.00&lt;/span&gt;&lt;span&gt; sec)
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt; MariaDB [(none)]&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以正常连接，且之前的数据还可以查询到。&lt;/p&gt;

&lt;h3&gt;&lt;span&gt; 在另一个容器中连接数据库&lt;/span&gt;&lt;/h3&gt;
&lt;hr/&gt;
&lt;p&gt;创建另一个文件夹&quot;query-db&quot;，从另外一个镜像上开启一个新的容器，如果这个容器需要连接上面的数据库容器该怎么办呢？&lt;/p&gt;
&lt;p&gt;直接连接，即使用localhost的IP（127.0.0.1）和本地的端口（3303）无法连接。这时候需要使用docker内部自己建立的网络将这两个容器连接起来。&lt;/p&gt;
&lt;p&gt;在该文件下建立如下docker-compose.yml文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; version: '2.2'
&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;services:
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;  djangoApp:
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    image: onlybelter/django_py35_new
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    # restart: on-failure
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    command: python3 query_db.py
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    working_dir: /code
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    volumes:
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;      - ./code:/code
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;      - /etc/localtime:/etc/localtime:ro
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    environment:
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;       - PYTHONUNBUFFERED=1
&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;networks:
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;  default:
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    external:
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;       name: mariadb_default
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;并且在该文件夹下创建新的文件夹&quot;code&quot;，并将名为query_db.py的文件放到code文件夹，该文件内的代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; MySQLdb
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; q_db():
    db &lt;/span&gt;= MySQLdb.connect(host=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;db&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, port=3306, user=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                         passwd&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;admin1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, db=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
        q_queue &lt;/span&gt;= &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;SELECT a.col2 FROM table1 AS a;&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        with db.cursor() as cursor:
            cursor.execute(query&lt;/span&gt;=&lt;span&gt;q_queue)
            one_queue &lt;/span&gt;=&lt;span&gt; cursor.fetchall()
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(one_queue[0], one_queue[1], &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception as e:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(e)
    &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;:
        db.close()


&lt;/span&gt;&lt;span&gt;while&lt;/span&gt; 1&lt;span&gt;:
    q_db()
    time.sleep(&lt;/span&gt;5)
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;在上面的docker配置文件中的第7行，会执行code文件夹中名为&quot;query_db.py&quot;的Python脚本，即上面所示的Python代码；&lt;/li&gt;
&lt;li&gt;配置文件的第15-18行，添加了数据库容器中默认网络的名称&quot;mariadb_default&quot;作为自己的一个扩展网络（一般由文件夹的名称+&quot;_default&quot;）；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;可以使用下面的命令来查看当前正在运行的容器的网络：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; [belter@localhost query-db]$ docker network &lt;span&gt;ls&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;NETWORK ID          NAME                   DRIVER              SCOPE
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;1d35e7fb797c        bridge                 bridge              local
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;8a2336ca7bcc        djangopy35_default     bridge              local
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; 8d044b04d49f        mariadb_default        bridge              local
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;由于扩展网络的连接，上面的Python代码会查询之前建立的数据库容器（名称为db）的3303端口（docker的内网），然后输出数据库中的内容：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; [belter@localhost query-db]$ docker-&lt;span&gt;compose up
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; Starting querydb_djangoApp_1 ... &lt;span&gt;done&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;Attaching to querydb_djangoApp_1
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; djangoApp_1  | (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Belter&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,) (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Merry Christmas&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,) 
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; djangoApp_1  | 
&lt;span&gt;6&lt;/span&gt; djangoApp_1  | (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Belter&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,) (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Merry Christmas&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,) 
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; djangoApp_1  | 
&lt;span&gt;8&lt;/span&gt; djangoApp_1  | (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Belter&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,) (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Merry Christmas&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,) 
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt; djangoApp_1  | 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Merry Christmas!&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;Reference&lt;/span&gt;&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;https://mariadb.com/resources/blog/mariadb-and-docker-use-cases-part-1/&lt;/p&gt;






</description>
<pubDate>Tue, 25 Dec 2018 13:42:00 +0000</pubDate>
<dc:creator>昕-2008</dc:creator>
<og:description>注：自从开始使用docker，部署方面的事情就简单多了。使用docker构建的数据库容器不用直接安装，开启后就可以使用，也比以前方便很多。下面将一些要点记录下来。 下面的例子使用以下环境： - 系统：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Belter/p/10174851.html</dc:identifier>
</item>
<item>
<title>呐，你实现了你去年的计划了吗？ - 虚无境</title>
<link>http://www.cnblogs.com/xuwujing/p/10176644.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuwujing/p/10176644.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;又到了一年一度的年终总结了，相信大家估计也开始写总结，我也不例外。本篇主要是讲述去年所定下目标的完成情况和人生感悟以及明年的目标。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;去年目标以及完成情况&quot;&gt;去年目标以及完成情况&lt;/h2&gt;
&lt;h3 id=&quot;去年目标&quot;&gt;去年目标&lt;/h3&gt;
&lt;p&gt;完整的链接在这里:&lt;a href=&quot;https://www.cnblogs.com/xuwujing/p/8158716.html&quot;&gt;一个两年java程序猿的2017个人总结&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里先列举一下去年定的目标:&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;阅读2本以上的技术相关书籍，并作出相应的实践；&lt;/li&gt;
&lt;li&gt;阅读5本以上国内外有意思的书籍；&lt;/li&gt;
&lt;li&gt;阅读jdk常用类的源码，能够理解其中的涵义；&lt;/li&gt;
&lt;li&gt;能够熟练掌握3个常用的技术框架；&lt;/li&gt;
&lt;li&gt;继续坚持每天一万步，一年中最少要达到250天；&lt;/li&gt;
&lt;li&gt;每月至少一次户外运动；&lt;/li&gt;
&lt;li&gt;每天睡眠时间不低于7小时，不高于9小时，一年至少要达到300天；&lt;/li&gt;
&lt;li&gt;每个月坚持写4以上篇博客，一年所写的博客不低于40篇；&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;。。。 现在看来，去年定的目标有点多并且完成的难度还不小 o(╥﹏╥)o&lt;/p&gt;
&lt;p&gt;既然要做总结，那么还是需要看看这些是否达成了。&lt;/p&gt;
&lt;h3 id=&quot;完成情况&quot;&gt;完成情况&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;首先第一条:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;阅读2本以上的技术相关书籍，并作出相应的实践；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先是技术书籍，今年主要看完并做出实践的有:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;《编写高质量代码：改善Java程序的151个建议》&lt;/li&gt;
&lt;li&gt;《Effective Java》&lt;/li&gt;
&lt;li&gt;《阿里巴巴Java开发手册》&lt;/li&gt;
&lt;li&gt;《大话设计模式》&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;其中1、2、3这三本书对我编写代码的帮助非常大，特别是第三本，很大的程度上提升了我代码的质量。以前的我写代码仅仅只是为了应付工作，功能实现了就行，基本不管代码格式是否规范，性能是否最优，代码注释是否完整。。。 看完这三本书之后，慢慢开始在写代码的时候注意这些了，先不说代码质量写不写得好，但是起码的代码规范、参数命名、方法使用、异常处理等等已经改善了很多了，比如集合参数获取或遍历的时候，习惯先进行空指针的判断，需要关闭流的时候必须在finally中进行，if中条件过多时会抽出来并使用一个final boolean变量进行判断等等。其中改变最大的这块应该是注释这块了，在类、类属性、类方法使用Javadoc注释，方法中复杂逻辑概述使用块注释，简单的使用行注释，后续可能恢复的代码使用 &lt;code&gt;///&lt;/code&gt;注释等等。第四本 《大话设计模式》中主要学习的是设计模式思想，理解了一些并写成了相应的&lt;a href=&quot;https://www.cnblogs.com/xuwujing/category/1249313.html&quot;&gt;博客&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;从这几本书中得到的收获远远不止这些，但这里就不在细说了。&lt;/p&gt;
&lt;p&gt;看过的书并做了一些实践的有:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;《Java 编程思想》&lt;/li&gt;
&lt;li&gt;《Java 并发编程实战》&lt;/li&gt;
&lt;li&gt;《Spring Boot实战 》&lt;/li&gt;
&lt;li&gt;《SpringCloud参考指南》&lt;/li&gt;
&lt;li&gt;《分布式服务框架原理与实践》&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;很多书都是看过一些，也做过一些实践，比如学习的SpringBoot和SpringCloud技术知识就来源于这些书籍。 但是因为各种原因最后没有坚持下来-_-||，也比较可惜的，所以这里就只能简单的列举下了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二条:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;阅读5本以上国内外有意思的书籍；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今年阅读完的书籍有:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;《人性的弱点》&lt;/li&gt;
&lt;li&gt;《傲慢与偏见》&lt;/li&gt;
&lt;li&gt;《满愿》&lt;/li&gt;
&lt;li&gt;《冰菓》&lt;/li&gt;
&lt;li&gt;《愿你归来，仍是少年》&lt;/li&gt;
&lt;li&gt;《人间失格》&lt;/li&gt;
&lt;li&gt;《别输在不会表达上》&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;《傲慢与偏见》看完此书之后顺便也看了下该电影，总的来情结说在意料之中，有意思一点的是谁傲慢，谁偏见到后面才知晓 罒ω罒。&lt;/p&gt;
&lt;p&gt;《冰菓》 是以前看过的一部叫做《冰菓》的动漫，越看越好看的那种，已经看过很多次了，因此买了一整套小说在看一遍。《满愿》则是该作者写的另一本推理小说，还算比较有意思的一本小说。&lt;/p&gt;
&lt;p&gt;《人间失格》 这本书是大文豪太宰治的最后一本小说，这本书从某种方面来说过于阴暗了，可能会引起不适，因此不怎么推荐去看。从现在来说的话，这本书的主角应该是有重度抑郁症吧。。。&lt;/p&gt;
&lt;p&gt;《愿你归来，仍是少年》 这本书主要思想也就是常说的&lt;code&gt;勿忘初心&lt;/code&gt;，记载的是作者前半生的所见所闻和感想，看完之后略有感触。不过在生活中也发现了一点，越是把&lt;code&gt;勿忘初心&lt;/code&gt;挂在嘴边的，越是忘了初心。。。&lt;/p&gt;
&lt;p&gt;《人性的弱点》 这本书是同事推荐的，看完真的感触很大，可以说在这一年是对我影响最大的一本书了，里面的道理都简单容易理解，建议每个人看一看，或许发现人生又是另一种了。&lt;/p&gt;
&lt;p&gt;《别输在不会表达上》 这本书说得很对，很有道理，但是看完也就看完了，并没有留下什么。。。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第三条:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;阅读jdk常用类的源码，能够理解其中的涵义；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;emmmm，这个源码是看过一点，但是没有坚持看下去，现在也忘得差不多。&lt;br/&gt;总得来说，看过但是没啥印象了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第四条:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;能够熟练掌握3个常用的技术框架；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今年熟练掌握了springboot、netty、kafka、zookeeper这些相关的技术框架，基本都可以熟练使用了，也编写了相关博客进行记载。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第五、六、七条:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;继续坚持每天一万步，一年中最少要达到250天；&lt;/li&gt;
&lt;li&gt;每月至少一次户外运动；&lt;/li&gt;
&lt;li&gt;每天睡眠时间不低于7小时，不高于9小时，一年至少要达到300天；&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;上述这三条都可以作为保持身体指定的目标，因此放到一起说。&lt;br/&gt;首先是坚持每天一万步，大概就是每天步行7~8公里，这个到目前为止并没达到250天，实际接近200天，至于为什么没有达到，各种原因都有，这里就不找那些借口了。&lt;br/&gt;每月至少一次户外运动，这个也没有每个月都去户外运动，不过还是有一些的。&lt;br/&gt;保持良好的睡眠时间，这个基本达标，目前差不多有300天良好的睡眠了。睡眠真的很重要，良好的睡眠才能开心的工作、学习和娱乐！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第八条:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;每个月坚持写4以上篇博客，一年所写的博客不低于40篇；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;每个月坚持写4以上篇博客，这个有很多个月没有达到，不过今年所写的博客已达到40篇了。总得来说，对比去年写的博客，虽然数量要少了不少，但是今年写的博客无论是页面排版还是质量都提升了不少，这也是一个不小的进步了 (*￣︶￣) 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181225163027848.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;关于上述这些定制的目标，我做了一个简单的Excel表格进行记录。这个Excel顺便也上传了，有兴趣的话查看的话，地址在这里，&lt;a href=&quot;https://files.cnblogs.com/files/xuwujing/%E4%B8%AA%E4%BA%BA%E8%AE%A1%E5%88%92.rar&quot;&gt;2018个人计划&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;去年目标总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;按照去年所定的状态进行评估。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;阅读2本以上的技术相关书籍，并作出相应的实践； -- 超越&lt;/li&gt;
&lt;li&gt;阅读5本以上国内外有意思的书籍； -- 达标&lt;/li&gt;
&lt;li&gt;阅读jdk常用类的源码，能够理解其中的涵义； -- 未达标&lt;/li&gt;
&lt;li&gt;能够熟练掌握3个常用的技术框架； -- 达标&lt;/li&gt;
&lt;li&gt;继续坚持每天一万步，一年中最少要达到250天； -- 未达标&lt;/li&gt;
&lt;li&gt;每月至少一次户外运动； -- 未达标&lt;/li&gt;
&lt;li&gt;每天睡眠时间不低于7小时，不高于9小时，一年至少要达到300天； -- 达标&lt;/li&gt;
&lt;li&gt;每个月坚持写4以上篇博客，一年所写的博客不低于40篇；-- 达标&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;总的来说，达标的是属于刚刚达标的，未达标基本是接近完成目标，但是差一些而已，至于为什么差一些的原因，思前想后，就一个字 &lt;code&gt;懒&lt;/code&gt; ... 这块也不过多寻找原因了，不过至少是在进行，而不是都没启动。 至于哪一个唯一超越的，大概是因为比较容易达成一些吧。&lt;/p&gt;
&lt;h2 id=&quot;今年事件&quot;&gt;今年事件&lt;/h2&gt;
&lt;p&gt;今年底事件就分为几个模块来说吧。&lt;/p&gt;
&lt;h3 id=&quot;在社区&quot;&gt;在社区&lt;/h3&gt;
&lt;p&gt;主要是在博客园、CSDN、GitHub技术社区这块；&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;有不少的博文访问量破万，并且在CSDN取得了博客专家称号；&lt;/li&gt;
&lt;li&gt;在github终于有过百star的项目了；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;虽然上面的成绩对于很多大佬来说没什么，但是对于个人来说有很大的鼓励作用，起码写的博文，开源的项目不是没有用，而是能够确切的帮助到一些人的。&lt;/p&gt;
&lt;h3 id=&quot;在公司&quot;&gt;在公司&lt;/h3&gt;
&lt;p&gt;可能因为今年是本命年，所以过年后运气一直都不错 ~_~&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;运气不错在年会中了一等奖；&lt;/li&gt;
&lt;li&gt;成为了公司的核心员工；&lt;/li&gt;
&lt;li&gt;获得了技术分享奖；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在工作中，成长了许多，除了技术方面外，最大的收获就是人际之间的关系处理以及做事这方面的吧。技术方面因经常分享一些新技术框架、开源工具的使用，因此得到一个技术分享将；做事方面而言可能是因为态度比较好一些，沟通闭环执行比较到位， 做的小事情多一些，不过也可能是因为运气比较好，部门人数较少，所以成为了核心员工(实际貌似没有什么用)。。。&lt;/p&gt;
&lt;h3 id=&quot;个人&quot;&gt;个人&lt;/h3&gt;
&lt;p&gt;坚持做了一些事情，有新增了一些有益于身体的事项。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;学习了不少新知识，看了一些有趣的书籍；&lt;/li&gt;
&lt;li&gt;去参加计算机软考了，但是很可惜没过；&lt;/li&gt;
&lt;li&gt;因牙疼去拔智齿了，并坚持每年洗牙；&lt;/li&gt;
&lt;li&gt;因眼睛疼，开始佩戴防辐射眼镜(零度数)；&lt;/li&gt;
&lt;li&gt;因脖子和肩膀疼，开始去做推拿了；&lt;/li&gt;
&lt;li&gt;因手指疼，开始有意识锻炼手指了；&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;个人方面，和去年相比，在技术方面提升了不少。但是身体却不如去年了，明明在锻炼，在注意身体，但是感觉身体的确是一年不如一年。去年基本没有上述问题，但是在今年下半年尤为明显，明显的感觉到身体素质下降了，各种身体问题接踵而出。因此需要加强身体的锻炼，多运动，少久坐，多吃蔬菜水果，少吃酸辣刺激食物 ，保持良好睡眠，少熬夜 。。。 当然最重要的是少加班，只要少加班或不加班，那么上述的身体问题或许不会存在吧！&lt;/p&gt;
&lt;h2 id=&quot;明年目标&quot;&gt;明年目标&lt;/h2&gt;
&lt;p&gt;如果按照去年的我制定目标的话，可能就是以下的这些了:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;每几小时坚持远眺和活动手指;&lt;/li&gt;
&lt;li&gt;每天坚持运动锻炼身体;&lt;/li&gt;
&lt;li&gt;每周坚持去电影院看一场电影;&lt;/li&gt;
&lt;li&gt;每周坚持写一篇博客；&lt;/li&gt;
&lt;li&gt;每月坚持去做推拿保护颈椎和脖子;&lt;/li&gt;
&lt;li&gt;每月坚持户外运动；&lt;/li&gt;
&lt;li&gt;每年坚持一次洗牙保护牙齿;&lt;/li&gt;
&lt;li&gt;每年坚持写总结；&lt;/li&gt;
&lt;li&gt;。。。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;但是今年的我并不想这么做了，今年的我只想希望明年的自己完成这几个目标：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;活得开心，开心最重要；&lt;/li&gt;
&lt;li&gt;喜欢做某件事情；&lt;/li&gt;
&lt;li&gt;喜欢一个人；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;现实如此残酷，人生又如此短暂，何不活的开心一点呢？&lt;br/&gt;找到一个自己真正想做的事情，只要不触犯法律道德底线，那么就去做吧。&lt;br/&gt;找到一个喜欢的人，无论是现实的，还是非现实的。&lt;/p&gt;
&lt;h2 id=&quot;感悟&quot;&gt;感悟&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;注：以下这段只是作者无病呻吟而已，请勿见笑！&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;今年相比去年，收获很多，但是失去了也很多。收获在上述已经说了，这里就不说了。相比收获而言，失去的东西可能更多。首先，失去了喜欢的事物，如果去年说还有喜欢的东西话，我可能会说喜欢玩游戏、看动漫、看电影，但是今年真的就没有什么喜欢的事物了，玩游戏、看动漫、看电影只是个消遣罢了，可有可无了；其次，失去了感动，也就是今年好像没有被什么东西触动了，有的只剩下麻木，或许是以前感动多了吧；然后，失去了非常重要的东西，笑容，可能有人会说，笑容怎么会失去了，不是每天都在笑吗？我说的笑容是内心的笑容，而不是表面功夫的笑容，在社会接触得越多，就越发现笑容越重要，但是很多时候这种笑容只是表面而已，并非自己真正的笑容，很多时候，只是看到某人在人前的笑容，而很少知他在人后是怎样的。&lt;br/&gt;不知在哪个时间，突然发现自己的脸部很酸，可能是因为假笑多了导致，但是后来发现自己已经忘了真正的笑容了，那种表面的笑容很容易出现，但是自己真正感到开心的笑容发现没有了，无论是看搞笑的视频还是遇到有趣的事情，最多也只是脸部抽搐下而已，内心并无波澜。最后，失去了本心，或许我自己都不知道自己的本心是怎么样的了，只知道自己开始做了一些自己并不想做的事情，哪怕不喜欢做，不想做，但是还是不得不去做，从某种方面来说，或许这就是成熟吧！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;写到这里差不多该写的都写了， 本篇博文主要的目的还是让自己有个清晰的认识，并且好对未来做些规划。不过今年就从简了，收获的感悟有很多，很多，但是想来想去，发现还是高中自己写的日记中的一条感悟比较有意思，这句感悟如下:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;活着是为了更好的活着而活着！&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Tue, 25 Dec 2018 13:37:00 +0000</pubDate>
<dc:creator>虚无境</dc:creator>
<og:description>前言 又到了一年一度的年终总结了，相信大家估计也开始写总结，我也不例外。本篇主要是讲述去年所定下目标的完成情况和人生感悟以及明年的目标。 去年目标以及完成情况 去年目标 完整的链接在这里:</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xuwujing/p/10176644.html</dc:identifier>
</item>
<item>
<title>数据分析 第八篇：OLS回归分析 - 悦光阴</title>
<link>http://www.cnblogs.com/ljhdo/p/4807068.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ljhdo/p/4807068.html</guid>
<description>&lt;p&gt;变量之间存在着相关关系，比如，人的身高和体重之间存在着关系，一般来说，人高一些，体重要重一些，身高和体重之间存在的是不确定性的相关关系。回归分析是研究相关关系的一种数学工具，它能帮助我们从一个变量的取值区估计另一个变量的取值。&lt;/p&gt;
&lt;p&gt;OLS（最小二乘法）主要用于线性回归的参数估计，它的思路很简单，就是求一些使得实际值和模型估值之差的平方和达到最小的值，将其作为参数估计值。就是说，通过最小化误差的平方和寻找数据的最佳函数匹配。利用最小二乘法可以简便地求得未知的数据，并使得这些求得的数据与实际数据之间误差的平方和为最小。最小二乘法可用于曲线拟合，其他一些优化问题也可通过最小化能量或最大化熵用最小二乘法来表达。&lt;/p&gt;
&lt;h2&gt;一，OLS回归&lt;/h2&gt;
&lt;p&gt;OLS法通过一系列的预测变量来预测响应变量（也可以说是在预测变量上回归响应变量）。线性回归是指对参数β为线性的一种回归（即参数只以一次方的形式出现）模型：&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;Y&lt;sub&gt;t&lt;/sub&gt;=α+βx&lt;sub&gt;t&lt;/sub&gt;+μ&lt;sub&gt;t （t=1……n）表示观测数&lt;/sub&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;Y&lt;sub&gt;t  &lt;/sub&gt;被称作因变量&lt;/li&gt;
&lt;li&gt;x&lt;sub&gt;t  &lt;/sub&gt;被称作自变量&lt;/li&gt;
&lt;li&gt;α、β 为需要最小二乘法去确定的参数，或称回归系数&lt;/li&gt;
&lt;li&gt;μ&lt;sub&gt;t  &lt;/sub&gt;为随机误差项&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;OLS线性回归的基本原则：最优拟合曲线应该使各点到直线的距离的平方和（即残差平方和，简称RSS）最小：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/628084/201812/628084-20181225113733554-1661364960.png&quot; alt=&quot;&quot; width=&quot;553&quot; height=&quot;100&quot;/&gt;&lt;/p&gt;
&lt;p&gt;OLS线性回归的目标是通过减少响应变量的真实值与预测值的差值来获得模型参数（截距项和斜率），就是使RSS最小。&lt;/p&gt;
&lt;p&gt;为了能够恰当地解释OLS模型的系数，数据必须满足以下统计假设：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;正态性：对于固定的自变量值，因变量值成正太分布&lt;/li&gt;
&lt;li&gt;独立性：个体之间相互独立&lt;/li&gt;
&lt;li&gt;线性相关：因变量和自变量之间为线性相关&lt;/li&gt;
&lt;li&gt;同方差性：因变量的方差不随自变量的水平不同而变化，即因变量的方差是不变的&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;二，用lm()拟合回归模型&lt;/h2&gt;
&lt;p&gt;在R中，拟合回归模型最基本的函数是lm()，格式为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;lm(formula, data&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;formula中的符号注释：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;~ 分割符号，左边为因变量，右边为自变量，例如， z~x+y，表示通过x和y来预测z&lt;/li&gt;
&lt;li&gt;+ 分割预测变量&lt;/li&gt;
&lt;li&gt;: 表示预测变量的交互项，例如，z~x+y+x:y&lt;/li&gt;
&lt;li&gt;* 表示所有可能的交互项，例如，z~x*y 展开为 z~x+y+x:y&lt;/li&gt;
&lt;li&gt;^ 表示交互项的次数，例如，z ~ (x+y)^2，展开为z~x+y+x:y&lt;/li&gt;
&lt;li&gt;. 表示包含除因变量之外的所有变量，例如，如果只有三个变量x，y和z，那么代码 z~. 展开为z~x+y+x:y&lt;/li&gt;
&lt;li&gt;-1 删除截距项，强制回归的直线通过原点&lt;/li&gt;
&lt;li&gt;I() 从算术的角度来解释括号中的表达式，例如，z~y+I(x^2) 表示的拟合公式是 z=a+by+cx&lt;sup&gt;2&lt;/sup&gt;&lt;/li&gt;
&lt;li&gt;function 可以在表达式中应用数学函数，例如，log(z) ~x+y&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于拟合后的模型（lm函数返回的对象），可以应用下面的函数，得到模型的更多额外的信息。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;summary() 展示拟合模型的详细结果&lt;/li&gt;
&lt;li&gt;coefficients() 列出捏模型的参数（截距项intercept和斜率）&lt;/li&gt;
&lt;li&gt;confint() 提供模型参数的置信区间&lt;/li&gt;
&lt;li&gt;residuals() 列出拟合模型的残差值&lt;/li&gt;
&lt;li&gt;fitted() 列出拟合模型的预测值&lt;/li&gt;
&lt;li&gt;anova() 生成一个拟合模型的方差分析表&lt;/li&gt;
&lt;li&gt;predict() 用拟合模型对新的数据预测响应变量&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;例如，使用基础安装包中的数据集women（包含了年龄在30-39岁之间女性的身高和体重信息），通过身高来预测体重。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1，线性拟合&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用lm()函数来拟合模型，获得模型对象fit&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
fit &amp;lt;- lm(weight~height,data=women)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用summary()函数来查看模型的信息：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&amp;gt;&lt;span&gt; summary(fit)

Call:
lm(formula &lt;/span&gt;= weight ~ height, data =&lt;span&gt; women)

Residuals:
    Min      1Q  Median      3Q     Max 
&lt;/span&gt;-&lt;span&gt;1.7333&lt;/span&gt; -&lt;span&gt;1.1333&lt;/span&gt; -&lt;span&gt;0.3833&lt;/span&gt;  &lt;span&gt;0.7417&lt;/span&gt;  &lt;span&gt;3.1167&lt;/span&gt;&lt;span&gt; 

Coefficients:
             Estimate Std. Error t value Pr(&lt;/span&gt;&amp;gt;|t|&lt;span&gt;)    
(Intercept) &lt;/span&gt;-&lt;span&gt;87.51667&lt;/span&gt;    &lt;span&gt;5.93694&lt;/span&gt;  -&lt;span&gt;14.74&lt;/span&gt; &lt;span&gt;1.71e-09&lt;/span&gt; ***&lt;span&gt;
height        &lt;/span&gt;&lt;span&gt;3.45000&lt;/span&gt;    &lt;span&gt;0.09114&lt;/span&gt;   &lt;span&gt;37.85&lt;/span&gt; &lt;span&gt;1.09e-14&lt;/span&gt; ***
---&lt;span&gt;
Signif. codes:  &lt;/span&gt;&lt;span&gt;0&lt;/span&gt; ‘***’ &lt;span&gt;0.001&lt;/span&gt; ‘**’ &lt;span&gt;0.01&lt;/span&gt; ‘*’ &lt;span&gt;0.05&lt;/span&gt; ‘.’ &lt;span&gt;0.1&lt;/span&gt; ‘ ’ &lt;span&gt;1&lt;/span&gt;&lt;span&gt;

Residual standard error: &lt;/span&gt;&lt;span&gt;1.525&lt;/span&gt; on &lt;span&gt;13&lt;/span&gt;&lt;span&gt; degrees of freedom
Multiple R&lt;/span&gt;-squared:  &lt;span&gt;0.991&lt;/span&gt;,    Adjusted R-squared:  &lt;span&gt;0.9903&lt;/span&gt;&lt;span&gt; 
F&lt;/span&gt;-statistic:  &lt;span&gt;1433&lt;/span&gt; on &lt;span&gt;1&lt;/span&gt; and &lt;span&gt;13&lt;/span&gt; DF,  p-value: &lt;span&gt;1.091e-14&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;残差标准差（Residual standard error）：表示模型用身高来预测体重的平均误差&lt;/p&gt;
&lt;p&gt;R的平方项（Multiple R-squared）：表明模型可以解释体重99.1%的方差，是实际和预测值之间相关系数的平方。&lt;/p&gt;
&lt;p&gt;F统计量（F-statistic）：检验所有的预测变量预测响应变量是否都在某个概率水平之上，&lt;/p&gt;
&lt;p&gt;从Coefficients 组中，可以看到 Intercept（截距项）是 - 87.51667，height的系数是3.45，截距项和系数的标准差、t值和Pr(&amp;gt;|t|)，其中，Pr(&amp;gt;|t|) 表示双边检验的p值&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;注，p值的表示方法通常有p-value，或Pr，p值是概率，表示某一事件发生的可能性大小。如果P值很小，说明原假设情况的发生的概率很小，而如果出现了，根据小概率原理，我们就有理由拒绝原假设，P值越小，我们拒绝原假设的理由越充分。总之，P值越小，表明结果越显著。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因此可以得到预测等式：&lt;/p&gt;
&lt;p&gt;Weight= - 87.51667 + 3.45 * Height&lt;/p&gt;
&lt;p&gt;绘制拟合的直线：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;gt; plot(women$height, women$weight,xlab=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;height&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,ylab=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;weight&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&amp;gt; abline(fit)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/628084/201812/628084-20181225162757045-639372550.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2，多项式拟合&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用lm()，在formula参数中使用I()函数来进行多项式拟合&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&amp;gt; fit2 &amp;lt;- lm(weight~I(height^&lt;span&gt;2&lt;/span&gt;),data=&lt;span&gt;women)
&lt;/span&gt;&amp;gt; plot(women$height, women$weight,xlab=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;height&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,ylab=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;weight&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&amp;gt;&lt;span&gt; lines(women$height,fitted(fit2))
&lt;/span&gt;&amp;gt;&lt;span&gt; summary(fit2)

Call:
lm(formula &lt;/span&gt;= weight ~ I(height^&lt;span&gt;2&lt;/span&gt;), data =&lt;span&gt; women)

Residuals:
    Min      1Q  Median      3Q     Max 
&lt;/span&gt;-&lt;span&gt;1.2562&lt;/span&gt; -&lt;span&gt;0.7636&lt;/span&gt; -&lt;span&gt;0.1837&lt;/span&gt;  &lt;span&gt;0.4622&lt;/span&gt;  &lt;span&gt;2.2654&lt;/span&gt;&lt;span&gt; 

Coefficients:
             Estimate Std. Error t value Pr(&lt;/span&gt;&amp;gt;|t|&lt;span&gt;)    
(Intercept) &lt;/span&gt;&lt;span&gt;2.390e+01&lt;/span&gt;  &lt;span&gt;2.109e+00&lt;/span&gt;   &lt;span&gt;11.34&lt;/span&gt; &lt;span&gt;4.12e-08&lt;/span&gt; ***&lt;span&gt;
I(height&lt;/span&gt;^&lt;span&gt;2&lt;/span&gt;) &lt;span&gt;2.659e-02&lt;/span&gt;  &lt;span&gt;4.926e-04&lt;/span&gt;   &lt;span&gt;53.98&lt;/span&gt;  &amp;lt; 2e-&lt;span&gt;16&lt;/span&gt; ***
---&lt;span&gt;
Signif. codes:  &lt;/span&gt;&lt;span&gt;0&lt;/span&gt; ‘***’ &lt;span&gt;0.001&lt;/span&gt; ‘**’ &lt;span&gt;0.01&lt;/span&gt; ‘*’ &lt;span&gt;0.05&lt;/span&gt; ‘.’ &lt;span&gt;0.1&lt;/span&gt; ‘ ’ &lt;span&gt;1&lt;/span&gt;&lt;span&gt;

Residual standard error: &lt;/span&gt;&lt;span&gt;1.072&lt;/span&gt; on &lt;span&gt;13&lt;/span&gt;&lt;span&gt; degrees of freedom
Multiple R&lt;/span&gt;-squared:  &lt;span&gt;0.9956&lt;/span&gt;,    Adjusted R-squared:  &lt;span&gt;0.9952&lt;/span&gt;&lt;span&gt; 
F&lt;/span&gt;-statistic:  &lt;span&gt;2913&lt;/span&gt; on &lt;span&gt;1&lt;/span&gt; and &lt;span&gt;13&lt;/span&gt; DF,  p-value: &amp;lt; &lt;span&gt;2.2e-16&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;非线性模型可用nls()函数进行拟合。 &lt;/p&gt;
&lt;h2&gt; 三，回归诊断（&lt;strong&gt;标准方法&lt;/strong&gt;）&lt;/h2&gt;
&lt;p&gt; 回归诊断用于评价回归模型的拟合程度，模型返回的参数多大程度上匹配原始数据。&lt;/p&gt;
&lt;p&gt; 根据OLS回归的统计假设来评价模型的拟合情况，对于lm()拟合的模型对象，使用plot()函数生成评价模型拟合情况的四幅图形，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;gt; fit &amp;lt;- lm(weight~height,data=&lt;span&gt;women)
&lt;/span&gt;&amp;gt; par(mfrow=c(&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&amp;gt; plot(fit)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/628084/201812/628084-20181225171736094-1771878115.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;正态性：当预测变量值固定时，因变量成正态分布，则残差值也应该是一个均值为0的正态分布。正态QQ图（Normal Q-Q）是在正态分布对应的值下，标准化残差的概率图。若满足正态假设，那么图上的点应该落在呈45度角的直线上；若不是如此，那么久违反了正态假设。&lt;/p&gt;
&lt;p&gt;独立性：无法判断因变量和自变量的值是否相互独立，只能从收集的数据中来验证。&lt;/p&gt;
&lt;p&gt;线性相关性：若因变量与自变量线性相关，那么残差值与预测（拟合）值除了系统误差之外，就没有任何关联。在残差和拟合图（Residuals VS Fitted）中，可以看到一条曲线，这暗示着可能需要对拟合模型加上一个二次项。&lt;/p&gt;
&lt;p&gt;同方差性：若满足不变方差假设，那么在位置尺度图（Scale-Location）中，水平线周围的点应该随机分布。&lt;/p&gt;
&lt;p&gt;残差和杠杆图（Residuals VS Leverage）提供了特殊的单个观测点（离群点、高杠杆点、强影响点）的信息。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;离群点：表明拟合回归模型对其预测效果不佳（产生巨大的残差）&lt;/li&gt;
&lt;li&gt;高杠杆点：指自变量因子空间中的离群点（异常值），由许多异常的自变量值组合起来的，与因变量没有关系。&lt;/li&gt;
&lt;li&gt;强影响点：表明它对模型参数的估计产生的影响过大，非常不成比例。强影响点可以通过Cook距离（Cook distance）统计量来前别。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;残差和杠杆图的可读性差，不够实用。&lt;/p&gt;
&lt;p&gt;什么是高杠杆点？离群点是指对于给定的预测值 &lt;img title=&quot;&quot; src=&quot;https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D12/sign=f5ac117b6781800a6ae58d0cb3351feb/b21bb051f8198618128e077041ed2e738ad4e67d.jpg&quot; alt=&quot;&quot; width=&quot;12&quot; height=&quot;11&quot; align=&quot;absmiddle&quot;/&gt; 来说，响应值 &lt;img title=&quot;&quot; src=&quot;https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D13/sign=9ccd698148a98226bcc12f248b82abfc/3b87e950352ac65c67318d87f0f2b21193138a0a.jpg&quot; alt=&quot;&quot; width=&quot;12&quot; height=&quot;13&quot; align=&quot;absmiddle&quot;/&gt; 异常的点。相反，高杠杆(high leverage) 表示观测点 &lt;img title=&quot;&quot; src=&quot;https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D12/sign=f5ac117b6781800a6ae58d0cb3351feb/b21bb051f8198618128e077041ed2e738ad4e67d.jpg&quot; alt=&quot;&quot; width=&quot;12&quot; height=&quot;11&quot; align=&quot;absmiddle&quot;/&gt; 是异常的。例如，图1(a)左下图中的观测点41具有高杠杆值，因为它的预测变量值比其他观测点都要大。实线是对数据的最小二乘拟合，而虚线是删除观测点41后的拟合。事实上，高杠杆的观测往往对回归直线的估计有很大的影响。如果一些观测对最小二乘线有重大影响，那么它们值得特别关注，这些点出现任何问题都可能使整个拟合失效。因此找出高杠杆观测是十分重要的&lt;span class=&quot;sup--normal&quot; data-sup=&quot;2&quot;&gt; 。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/628084/201812/628084-20181225214200343-44640818.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;四，回归诊断（&lt;/strong&gt;car包）&lt;/h2&gt;
&lt;p&gt;car包提供了大量的函数，大大增强了拟合和评价回归模型的能力&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1，正态性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;qqplot()函数提供了精确的正态假设检验方法，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&amp;gt;&lt;span&gt; library(carData)
&lt;/span&gt;&amp;gt;&lt;span&gt; library(car)
&lt;/span&gt;&amp;gt; par(mfrow=c(&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&amp;gt; fit &amp;lt;- lm(weight~height,data=&lt;span&gt;women)
&lt;/span&gt;&amp;gt; qqPlot(fit,labels=row.names(women),id.method=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;identity&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,simulate=TRUE,main=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;qq-fit&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;]  &lt;span&gt;1&lt;/span&gt; &lt;span&gt;15&lt;/span&gt;
&amp;gt; fit2 &amp;lt;- lm(weight~height+I(height^&lt;span&gt;2&lt;/span&gt;),data=&lt;span&gt;women)
&lt;/span&gt;&amp;gt; qqPlot(fit2,labels=row.names(women),id.method=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;identity&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,simulate=TRUE,main=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;qq-fit2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] &lt;span&gt;13&lt;/span&gt; &lt;span&gt;15&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/628084/201812/628084-20181225180404598-1025098169.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，置信区间通过虚线划定，当绝大多数点都落在置信区间时，说明正态性假设符合的很好。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2，误差的独立性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;car包提供了durbinWatsonTest()函数，用于做Durbin-Watson检验，检测误差的序列相关性。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;gt;&lt;span&gt; durbinWatsonTest(fit)
 lag Autocorrelation D&lt;/span&gt;-W Statistic p-&lt;span&gt;value
   &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;        &lt;span&gt;0.585079&lt;/span&gt;     &lt;span&gt;0.3153804&lt;/span&gt;       &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
 Alternative hypothesis: rho &lt;/span&gt;!= &lt;span&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;p值 （p=0）不显著，误差项之间独立&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3，线性相关性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过成分残差图（component + residual plots）检查因变量和自变量之间是否呈线性关系。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
crPlots(fit)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;若图形存在非线性，则说明可能对预测变量的函数形式建模不够充分，那么需要添加一些曲线成分，比如多项式，对一个或多个变量进行变换（log(x)代替x），或用其他回归变体形式而不是线性回归。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/628084/201812/628084-20181225181108834-977343450.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4，同方差性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;判断方差是否恒定，nvcTest()函数生成一个记分检验，原假设为误方差不变，备择假设为误差方差随着拟合值水平的变化而变化。若检验显著，说明存在误方差不很定。&lt;/p&gt;
&lt;p&gt;spreadLevelPlot()函数创建了一个添加了最佳拟合曲线的散点图，展示了标准化残差绝对值与拟合值得关系。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;gt;&lt;span&gt; ncvTest(fit)
Non&lt;/span&gt;-&lt;span&gt;constant Variance Score Test 
Variance formula: &lt;/span&gt;~&lt;span&gt; fitted.values 
Chisquare &lt;/span&gt;= &lt;span&gt;0.8052115&lt;/span&gt;, Df = &lt;span&gt;1&lt;/span&gt;, p = &lt;span&gt;0.36954&lt;/span&gt;
&amp;gt;&lt;span&gt; spreadLevelPlot(fit)

Suggested power transformation:  &lt;/span&gt;-&lt;span&gt;0.8985826&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;记分检验不显著：p=0.36954，说明满足方差不变假设，也可以通过分布水平看到这一点，点在水平的最佳拟合曲线周围呈随机分布。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/628084/201812/628084-20181225181804976-317851883.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;五，回归诊断（gvlma包）&lt;/h2&gt;
&lt;p&gt;gvlma()函数，用于对线性模型假设进行综合验证，同事还能验证偏斜度，峰度和异方差的评价。从输出项中可以看出，假设检验的显著性水平是5%。如果p&amp;lt;0.05，说明违反了假设条件。从Global Stat 的Decision 栏中，可以看到数据满足OLS回归模型所有的统计假设（p=0.597）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;gt;&lt;span&gt; library(gvlma)
&lt;/span&gt;&amp;gt; gvmodel &amp;lt;-&lt;span&gt; gvlma(fit)
&lt;/span&gt;&amp;gt;&lt;span&gt; summary(gvmodel)
&lt;/span&gt;&lt;span&gt;.................
ASSESSMENT OF THE LINEAR MODEL ASSUMPTIONS
USING THE GLOBAL TEST ON &lt;/span&gt;&lt;span&gt;4&lt;/span&gt; DEGREES-OF-&lt;span&gt;FREEDOM:
Level of Significance &lt;/span&gt;=  &lt;span&gt;0.05&lt;/span&gt;&lt;span&gt; 

Call:
 gvlma(x &lt;/span&gt;=&lt;span&gt; fit) 

                     Value   p&lt;/span&gt;-&lt;span&gt;value                   Decision
Global Stat        &lt;/span&gt;&lt;span&gt;16.5866&lt;/span&gt; &lt;span&gt;0.0023251&lt;/span&gt; Assumptions NOT satisfied!&lt;span&gt;
Skewness            &lt;/span&gt;&lt;span&gt;1.5577&lt;/span&gt; &lt;span&gt;0.2119999&lt;/span&gt;&lt;span&gt;    Assumptions acceptable.
Kurtosis            &lt;/span&gt;&lt;span&gt;0.1019&lt;/span&gt; &lt;span&gt;0.7496131&lt;/span&gt;&lt;span&gt;    Assumptions acceptable.
Link Function      &lt;/span&gt;&lt;span&gt;14.1218&lt;/span&gt; &lt;span&gt;0.0001713&lt;/span&gt; Assumptions NOT satisfied!&lt;span&gt;
Heteroscedasticity  &lt;/span&gt;&lt;span&gt;0.8052&lt;/span&gt; &lt;span&gt;0.3695398&lt;/span&gt;    Assumptions acceptable.
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;参考文档：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.sina.com.cn/s/blog_17bf54ea20102x70y.html&quot; target=&quot;_blank&quot;&gt;最小二乘线性（OLS）回归模型&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 25 Dec 2018 13:32:00 +0000</pubDate>
<dc:creator>悦光阴</dc:creator>
<og:description>变量之间存在着相关关系，比如，人的身高和体重之间存在着关系，一般来说，人高一些，体重要重一些，身高和体重之间存在的是不确定性的相关关系。回归分析是研究相关关系的一种数学工具，它能帮助我们从一个变量的取</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ljhdo/p/4807068.html</dc:identifier>
</item>
</channel>
</rss>