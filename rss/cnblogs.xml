<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>IdentityServer 3.1.x 迁移到 4.x - 晓晨Master</title>
<link>http://www.cnblogs.com/stulzq/p/13818199.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/stulzq/p/13818199.html</guid>
<description>&lt;h3 id=&quot;一前言&quot;&gt;一.前言&lt;/h3&gt;
&lt;p&gt;IdentityServer4 4.x已经正式发布了，根据官方的 Release Note，3.1.x 到 4.x 的变更也是非常多，今天在将代码迁移到 4.x 遇到了一些问题在此记录下来，我使用的 IdentityServer4 的各种数据持久化，比如 ClientStore，ResourceStore 等，都是完全自定义的，非 EntityFramework，如果你是使用的 EF 那么官方提供了迁移脚本，请自行查找。&lt;/p&gt;
&lt;h2 id=&quot;二-resource-相关变化&quot;&gt;二. Resource 相关变化&lt;/h2&gt;
&lt;p&gt;ApiResource 的 Scope 正式独立出来为 &lt;code&gt;ApiScope&lt;/code&gt; 对象，开发者可能是想让用户明白 ApiResource 和 Scope 的关系，而不是把它们混为一谈，因为以前这一步都是 IdentityServer4 帮你做了，会自动以 ApiResource 的名称为 Scope，所以可能存在认为它们两个是相等的情况，实际则不然，Scope 是属于 ApiResource 的一个属性，可以包含多个 Scope。以源码来看：&lt;/p&gt;
&lt;h3 id=&quot;1apiresource-的变化&quot;&gt;1.ApiResource 的变化&lt;/h3&gt;
&lt;p&gt;3.1.x：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/668104/202010/668104-20201015000434521-725878177.png&quot; alt=&quot;image-20201014101034846&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.x:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/668104/202010/668104-20201015000434100-2078461172.png&quot; alt=&quot;image-20201014101101701&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;2inmemory-运行方式的变化&quot;&gt;2.InMemory 运行方式的变化&lt;/h3&gt;
&lt;p&gt;对于大家在学习 IdentityServer4 时熟悉的 InMemory 来说，&lt;code&gt;AddInMemoryApiResources&lt;/code&gt; 变为了 &lt;code&gt;AddInMemoryApiScopes&lt;/code&gt; 也就是变了名字，但一定要明白这里面实际的不同。&lt;/p&gt;
&lt;p&gt;3.1.x:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/668104/202010/668104-20201015000433659-1131959164.png&quot; alt=&quot;image-20201014102238481&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.x:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/668104/202010/668104-20201015000433331-1736656086.png&quot; alt=&quot;image-20201014102255505&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;3resources-的变化&quot;&gt;3.Resources 的变化&lt;/h3&gt;
&lt;p&gt;此类的构造方法变了，增加了 apiScopes 的参数，直接受影响的是 &lt;code&gt;IResourceStore&lt;/code&gt; 的实现，如果自定义了此接口的实现，那么需要注意这个问题。&lt;/p&gt;
&lt;p&gt;3.1.x：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/668104/202010/668104-20201015000432929-513700732.png&quot; alt=&quot;image-20201014102732082&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.x:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/668104/202010/668104-20201015000432538-1264052563.png&quot; alt=&quot;image-20201014102818114&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;4iresourcestore-的变化&quot;&gt;4.IResourceStore 的变化&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/668104/202010/668104-20201015000432051-99679666.png&quot; alt=&quot;image-20201014104717646&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;三publicorigin-属性被删除&quot;&gt;三.PublicOrigin 属性被删除&lt;/h2&gt;
&lt;p&gt;IdentityServerOptions 对象中 &lt;code&gt;PublicOrigin&lt;/code&gt; 属性没有了，此属性涉及到在生产环境经过nginx反向代理等设施后 configuration endpoint 获取到的地址的准确性，经过查询官方的 Issues，目前有两个解决方案：&lt;/p&gt;
&lt;p&gt;1.在中间件中调用扩展方法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;app.Use(async (ctx, next) =&amp;gt;
{
    ctx.SetIdentityServerOrigin(&quot;https://foo.com&quot;);
    await next();
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;or&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;app.Use(async (ctx, next) =&amp;gt;
{
    ctx.Request.Scheme = &quot;https&quot;;
    ctx.Request.Host = new HostString(&quot;foo.com&quot;);
    
    await next();
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.正确设置反向代理中的 &lt;code&gt;X-Forwarded-For&lt;/code&gt;、&lt;code&gt;X-Forwarded-Proto&lt;/code&gt;和&lt;code&gt;X-Forwarded-Host&lt;/code&gt;，详细设置请查看：&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/proxy-load-balancer?view=aspnetcore-3.1&amp;amp;WT.mc_id=DT-MVP-5003133&quot;&gt;Configure ASP.NET Core to work with proxy servers and load balancers&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;相关资料：&lt;/p&gt;
&lt;p&gt;关于此问题官方人员的原话：&lt;code&gt;It's gone. It was a hack - please use the forwarded headers approach in ASP.NET Core from now on.&lt;/code&gt; 我个人更推荐&lt;strong&gt;第二个方法&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;四ipersistedgrantstore-的变化&quot;&gt;四.IPersistedGrantStore 的变化&lt;/h2&gt;
&lt;p&gt;IPersistedGrantStore 接口的方法参数有变动：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/668104/202010/668104-20201015000431443-189735882.png&quot; alt=&quot;微信图片_20201014235005&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;五总结&quot;&gt;五.总结&lt;/h2&gt;
&lt;p&gt;以上就是我在 IdentityServer4 3.1.x 到 4.x 迁移所遇到的各个问题，所有问题都解决了并且成功运行。我是重度自定义接口实现，包括表都是自行设计的，非EF，自定义实现的接口如下：&lt;code&gt;IClientStore&lt;/code&gt;、&lt;code&gt;IPersistedGrantStore&lt;/code&gt;、&lt;code&gt;IProfileService&lt;/code&gt;、&lt;code&gt;IResourceOwnerPasswordValidator&lt;/code&gt;、&lt;code&gt;IResourceStore&lt;/code&gt;。3.1.x 到 4.x 确实许多 break changes，但从遇到的几个实际问题来说，开发人员在设计是已尽量兼容了老版本，希望我所遇到的问题，能帮到大家。官方开了一个 issues 记录迁移的问题，如果大家有难以解决的问题，不妨去提交：&lt;a href=&quot;https://github.com/IdentityServer/IdentityServer4/issues/4592&quot;&gt;https://github.com/IdentityServer/IdentityServer4/issues/4592&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 15 Oct 2020 00:07:00 +0000</pubDate>
<dc:creator>晓晨Master</dc:creator>
<og:description>一.前言 IdentityServer4 4.x已经正式发布了，根据官方的 Release Note，3.1.x 到 4.x 的变更也是非常多，今天在将代码迁移到 4.x 遇到了一些问题在此记录下来，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/stulzq/p/13818199.html</dc:identifier>
</item>
<item>
<title>《动物游戏》一场真正的资本主义游戏 - RioTian</title>
<link>http://www.cnblogs.com/RioTian/p/13818475.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/RioTian/p/13818475.html</guid>
<description>&lt;p&gt;从知乎有一个很有趣的问题：房间里有100个人，每人都有100元钱，如果每过一分钟，每个人都要拿出一元钱随机给另一个人，最后这100个人的财富分布是怎样的？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com//riotian/blogimage/raw/master/img/20201014210025.jpeg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个问题，可以看成一个小型实验，模拟的是规则绝对公平时，社会财富的流向。财富随机流动的话，贫富差距是否就会消失呢？&lt;br/&gt;城市数据团用程序模拟了这个过程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com//riotian/blogimage/raw/master/img/20201014210038.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com//riotian/blogimage/raw/master/img/20201014210047.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;就这样，80%的钱跑进了20%的口袋里。&lt;strong&gt;即使在最公平的规则下，世界依然展现出了残酷的一面。&lt;/strong&gt;&lt;br/&gt;更何况，真实的财富流动并不随机。&lt;/p&gt;
&lt;p&gt;这个问题让我想到了影片《动物世界》中，游轮上的游戏规则很像。都是每人随机出一张牌。只是《动物世界》的游戏规则设定更加复杂。&lt;/p&gt;
&lt;p&gt;在游轮的游戏大厅最上方的笼子里，有一只虎视眈眈的老虎，它代表了人的欲望。而下方的牌数显示器又代表着规则和结果。欲望与规则，平衡着这个资本的世界。&lt;/p&gt;
&lt;p&gt;《动物世界》里的那场游戏，是一场专属于人类社会的游戏，是一场关于资本的游戏。&lt;/p&gt;
&lt;p&gt;我们可以把12张牌当作原始资本，而星星代表的是收益。在这场游戏里，我们可以粗浅地看到一些资本世界的规则。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、赌徒最不可信&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;船上的人基本都是赌徒。债台高筑的人是，猎守者也是。在郑开司身边最不可信的就是发小李军，澳门赌红了眼，卖了家里的房子，老父亲居无定所，又打起了郑开司的主意，骗走了郑家的房子。&lt;/p&gt;
&lt;p&gt;贪念太大，道德、信用、友谊之类的东西早就被赌红了眼的李军抛弃了。&lt;/p&gt;
&lt;p&gt;赌徒无法控制自己的贪念，最后，贪念会吞噬一切。欺骗、算计、背叛的发生自然而然。&lt;/p&gt;
&lt;p&gt;避免同赌徒合作，是资本游戏的第一步。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、作弊是取胜的最快方法。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如何利用最小成本，最快取得胜利，那就是作弊。所谓“兵不厌诈”。张景坤就是这样给郑开司上的第一节课。听起来很丧吧。&lt;/p&gt;
&lt;p&gt;但是，兵不厌诈是指的对手之间，而合作者之间应该保持信任，若是已经形成合作关系而使用作弊方法使自己获益，则是打破这种信任，最终的结果会是破坏合作。作弊只使用于短线获益且作弊者会丧失掉更长远的获益的机会。&lt;/p&gt;
&lt;p&gt;当然，有些所谓的生意并不需要长期合作，比如电信诈骗、金融圈套、旅游景点宰客等都是在做一次性的买卖。&lt;/p&gt;
&lt;p&gt;所以，在资本市场下，合作时最好还是老老实实少耍心眼。不然最后坏掉的是自己的名声。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、暴力是财富易主最快捷办法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在《中产阶级如何保护自己的财富》一书中，作者提到“暴力永不为零”。 获得财富最直接的办法就是暴力。所以，富人为了守住财富，会不断的加固城墙，购买武器。动物游戏的主办方在游戏中禁止使用暴力，也就排除了暴力对市场的干扰因素。&lt;/p&gt;
&lt;p&gt;如果游戏中暴力不被禁止，那么《动物世界》则会直接变为《饥饿游戏》。所有规则直接为零。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、资本市场上永远不缺投机的人&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;郑开司在连连失利的情况下，很快想到了囤牌致富。这是一项高风险同时也是高收益的行为，就是我们俗称的“投机倒把”。&lt;/p&gt;
&lt;p&gt;优秀的投机客总是在等待，总是有耐心，等待着市场证实他们的判断。在市场本身的表现在证实自己看法之前，不要完全相信自己之前的判断。&lt;/p&gt;
&lt;p&gt;郑开司一行在囤积了石头之后，意外发现有人囤积布。所以，他们很可能被囤布的人吃掉。郑开司想办法收购了囤积的布，这本来应该是稳赢的局面。&lt;/p&gt;
&lt;p&gt;但是程咬金出现了，郑开司这样的行为触犯了张景坤的利益。最终，又被张景坤设计重新洗牌。市场的环境总是千变万化。投机可能带来丰厚的利润，也可能成为市场上的众矢之的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么样的人能在资本市场上活下来&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;大家可以算一道题，假设100个人参加动物世界的游戏的话，能够安全下船的几率是多少。这道题比较难解，但是我们可以一起来分析一下能下船的人都有哪些特点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、头脑灵活，有领导能力的人。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;郑开司，不仅能快速看清游戏漏洞，还能较为准确地预测对方的牌数。在赌局上基本可以获得较大的赢面。而且，他的领导力和谈判力也很值得称赞，灵活化解了布的囤积者的狙击局面，面对心狠手辣张景坤也能力挽狂澜。而且，他不仅可以灵活运用规则，还可以适度使用暴力。在最后面临死局的情况下，抢夺了刀疤脸的钻石，帮自己走出了小黑屋。&lt;/p&gt;
&lt;p&gt;这样的人可以获得很多追随者，很适合创业。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、心狠手辣、信奉丛林法则的人。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;张景坤欺骗、算计、作弊，各种手法轮番使用，在赌场上很是如鱼得水。但是，太过歹毒的人无法与他人合作。所以，只能单打独斗，在赌场上像是一只幽灵。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、手里有核心资源的人。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;刀疤脸深知人性的黑暗。他们团队使用出老千的方式赢得了更多的星星，那么问题是如何保证比赛结束后，其他合伙人不会卷走财富闪人。所以，最妥善的办法是虽然在弱势位置，但是手里有不可替代的核心资源，使自己在比赛结束后仍然有赎回价值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、运气好的人&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;运气好这个事情真的很无解，有些人就是锦鲤本鱼，真的是不能比。以片尾老头的智商，本来注定要去做人体实验的。但是，运气好的他遇到了郑开司，最后安全下船。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原始社会的解体导致了私有制的产生。私有制的产生又促进了市场的形成。资本市场是人类独有的产物。所以，这场动物世界的游戏，是真正属于人类的游戏。&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;在知乎上有个段子是这么说的：&lt;br/&gt;我告诉你一个一年稳赚两百万的办法……往银行里存一个亿定期，一年稳赚两百万。&lt;br/&gt;笑话归笑话，事实也确实如此，原始资本往往是积累财富最有效的方式之一。&lt;/p&gt;
&lt;p&gt;关于关于允许负债，富二代财富积累，低保+税收下的实验结果请访问原文作者：&lt;a href=&quot;http://www.sohu.com/a/159059809_167388&quot;&gt;http://www.sohu.com/a/159059809_167388&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;当然知乎上另有高人对原文作者提出了异议：这篇文章犯了一大堆概率论经典错误。他算的那个正态分布是每个个体手上的钱，原文算的是群体排序后的财富分布，根本就不是在算同一个东西。。。请访问：&lt;a href=&quot;https://www.zhihu.com/pin/877873289857478656&quot;&gt;https://www.zhihu.com/pin/877873289857478656&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;用代码模拟相应过程（不允许负债，代码来自&lt;a href=&quot;https://blog.csdn.net/xyisv&quot;&gt;徐奕学长&lt;/a&gt;）：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;ctime&amp;gt;
#include &amp;lt;iostream&amp;gt;

using namespace std;

int main() {
    int population = 0, total = 0, individual = 0, generation = 0, figure = 0,
        temp = 0;
    cout &amp;lt;&amp;lt; &quot;人数:&quot;;
    cin &amp;gt;&amp;gt; population;
    cout &amp;lt;&amp;lt; &quot;初始每人拥有的资产:&quot;;
    cin &amp;gt;&amp;gt; individual;
    cout &amp;lt;&amp;lt; &quot;迭代次数:&quot;;
    cin &amp;gt;&amp;gt; generation;
    cout &amp;lt;&amp;lt; &quot;每一代交换金额:&quot;;
    cin &amp;gt;&amp;gt; figure;
    total = population * individual;
    cout &amp;lt;&amp;lt; &quot;社会财富总量:&quot; &amp;lt;&amp;lt; total &amp;lt;&amp;lt; endl;
    cout &amp;lt;&amp;lt; &quot;start&quot; &amp;lt;&amp;lt; endl;
    srand((unsigned)time(NULL));
    int *num = new int[population];
    for (int i = 0; i &amp;lt; population; i++)
        num[i] = individual;
    while (generation &amp;gt; 0) {
        for (int i = 0; i &amp;lt; population; i++) {
            if (num[i] &amp;gt; 0) {
                num[i] -= figure;
                temp = rand() % population;
                num[temp] += figure;
            }
        }
        generation--;
    }
    total = 0;
    for (int i = 0; i &amp;lt; population; i++)
        total += num[i];
    cout &amp;lt;&amp;lt; &quot;社会财富总量:&quot; &amp;lt;&amp;lt; total &amp;lt;&amp;lt; endl;
    cout &amp;lt;&amp;lt; &quot;每个人的资产&quot; &amp;lt;&amp;lt; endl;
    sort(num, num + population);
    for (int i = 0; i &amp;lt; population; i++) {
        if ((i) % 10 == 0) cout &amp;lt;&amp;lt; endl;
        printf(&quot;%5d&quot;, num[i]);
    }
    return 0;
}
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 14 Oct 2020 23:48:00 +0000</pubDate>
<dc:creator>RioTian</dc:creator>
<og:description>从知乎有一个很有趣的问题：房间里有100个人，每人都有100元钱，如果每过一分钟，每个人都要拿出一元钱随机给另一个人，最后这100个人的财富分布是怎样的？ 这个问题，可以看成一个小型实验，模拟的是规则</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/RioTian/p/13818475.html</dc:identifier>
</item>
<item>
<title>java9系列第二篇-资源自动关闭的语法增强 - 字母哥博客</title>
<link>http://www.cnblogs.com/zimug/p/13818458.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zimug/p/13818458.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202010/1815316-20201015071901792-2057976050.png&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我计划在后续的一段时间内，写一系列关于java 9的文章，虽然java 9 不像Java 8或者Java 11那样的核心java版本，但是还是有很多的特性值得关注。期待您能关注我，我将把java 9 写成一系列的文章，大概十篇左右。&lt;/p&gt;
&lt;p&gt;在Java 9的版本中，对从JDK 7开始支持的try-with-resources语法进行了改进。虽然只是一个小小的改进，我仍希望把他介绍给你，我们一起来每天进步一点点。&lt;/p&gt;
&lt;h2 id=&quot;一、先说java7的try-with-resourcesjava9改进版在后文&quot;&gt;一、先说Java7的try-with-resources(Java9改进版在后文)&lt;/h2&gt;
&lt;p&gt;在Java 7之前没有&lt;code&gt;try-with-resources&lt;/code&gt;语法，所有的流的销毁动作，全都需要自己在finally方法中手动的写代码进行关闭。如下文中的代码，将一个字符串写入到一个文件里面。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Test
void testStream() throws IOException {
  String fileName = &quot;D:\\data\\test\\testStream.txt&quot;;

  FileOutputStream fos = new FileOutputStream(fileName);  //创建IO管道流
  OutputStreamWriter osw = new OutputStreamWriter(fos);
  BufferedWriter bw = new BufferedWriter(osw);

  try{
    bw.write(&quot;手写代码进行Stream流的关闭&quot;);
    bw.flush();
  }finally{
    bw.close();   //手动关闭IO管道流
    osw.close();
    fos.close();
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从Java 7版本开始提供了&lt;code&gt;try-with-resources&lt;/code&gt;语法，我们只需要把管道流用&lt;code&gt;try()&lt;/code&gt;包含起来，在try代码段执行完成之后，IO管道流就会自动的关闭，不需要我们手写代码去关闭，这很简洁！&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Test
void testTry() throws IOException {
  String fileName = &quot;D:\\data\\test\\testTry.txt&quot;;
  try(FileOutputStream fos = new FileOutputStream(fileName);
      OutputStreamWriter osw = new OutputStreamWriter(fos);
      BufferedWriter bw = new BufferedWriter(osw);){
    bw.write(&quot;IO管道流被自动调用close()方法&quot;);
    bw.flush();
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;二、避免走入误区&quot;&gt;二、避免走入误区&lt;/h2&gt;
&lt;p&gt;很多小伙伴在知道&lt;code&gt;try-with-resources&lt;/code&gt;语法之后，容易陷入误区&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;误区一：只有IO管道流才能使用&lt;code&gt;try-with-resources&lt;/code&gt;语法，进行自动的资源关闭&lt;/li&gt;
&lt;li&gt;误区二：所有带有close()方法的类对象，都会自动的调用close()方法进行资源关闭&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;误区一把实践范围缩小了，而误区二把实践范围夸大了。&lt;strong&gt;那么什么样的资源可以被自动关闭呢？答案就是实现了AutoCloseable或Closeable接口的类可以自动的进行资源关闭。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public interface Closeable extends AutoCloseable {
    public void close() throws IOException;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Closeable接口继承自AutoCloseable接口，二者都包含close()方法。如果你自定义的占用系统资源的类需要进行资源回收，请实现这两个接口之一，并在close()方法中进行资源回收与关闭。这样你自定义的类，也可以使用&lt;code&gt;try-with-resources&lt;/code&gt;语法进行资源回收与关闭。&lt;/p&gt;
&lt;h2 id=&quot;三、try-with-resources在java-9中的改进&quot;&gt;三、&lt;code&gt;try-with-resources&lt;/code&gt;在Java 9中的改进&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;try-with-resources&lt;/code&gt;语法在java 9 中进行了改进，&lt;code&gt;try-with-resources&lt;/code&gt;语法的&lt;code&gt;try()&lt;/code&gt;可以包含变量，多个变量用分号隔开。&lt;br/&gt;这样的改进目的是让语义更加明确，将资源创建代码与尝试资源回收的语法分离。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;语义一：尝试去执行代码段，如果抛出异常，对异常进行处理&lt;/li&gt;
&lt;li&gt;语义二：尝试去自动关闭资源，关闭谁？关闭被&lt;code&gt;try()&lt;/code&gt;包含的变量&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;
@Test
void testJava9Try() throws IOException {
  String fileName = &quot;D:\\data\\test\\testJava9Try.txt&quot;;

  FileOutputStream fos = new FileOutputStream(fileName);
  OutputStreamWriter osw = new OutputStreamWriter(fos);
  BufferedWriter bw = new BufferedWriter(osw);

  try(bw;osw;fos){  //注意这里：尝试去回收这三个对象对应的资源，和上文中的java 7代码对比
    bw.write(&quot;Java9-可以被自动调用close()方法&quot;);
    bw.flush();
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;欢迎关注我的博客，里面有很多精品合集&quot;&gt;欢迎关注我的博客，里面有很多精品合集&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;本文转载注明出处（必须带连接，不能只转文字）：&lt;a href=&quot;http://www.zimug.com&quot;&gt;字母哥博客&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;觉得对您有帮助的话，帮我点赞、分享！您的支持是我不竭的创作动力！&lt;/strong&gt; 。另外，笔者最近一段时间输出了如下的精品内容，期待您的关注。&lt;/p&gt;
</description>
<pubDate>Wed, 14 Oct 2020 23:19:00 +0000</pubDate>
<dc:creator>字母哥博客</dc:creator>
<og:description>我计划在后续的一段时间内，写一系列关于java 9的文章，虽然java 9 不像Java 8或者Java 11那样的核心java版本，但是还是有很多的特性值得关注。期待您能关注我，我将把java 9</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zimug/p/13818458.html</dc:identifier>
</item>
<item>
<title>CDH5部署三部曲之三：问题总结 - 程序员欣宸</title>
<link>http://www.cnblogs.com/bolingcavalry/p/13818455.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bolingcavalry/p/13818455.html</guid>
<description>&lt;h3 id=&quot;欢迎访问我的github&quot;&gt;欢迎访问我的GitHub&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS等；&lt;/p&gt;
&lt;h3 id=&quot;系列文章链接&quot;&gt;系列文章链接&lt;/h3&gt;
&lt;p&gt;本文是《CDH5部署三部曲》的终篇，前面两章完成了CDH5集群的部署和启动，本章将实战中遇到的问题做个总结，如果碰巧您也遇到过这些问题，希望本文能给您一些参考；&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/105340968&quot;&gt;《CDH5部署三部曲之一：准备工作》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/105341713&quot;&gt;《CDH5部署三部曲之二：部署和设置》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details//105342156&quot;&gt;《CDH5部署三部曲之三：问题总结》&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;启动集群服务报错&quot;&gt;启动集群服务报错&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;首次启动集群服务报错，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201015071630278-884102401.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;上述错误一般是对应节点的&lt;span&gt;/usr/java/default&lt;/span&gt;目录下没有JDK所致，假设已将JDK部署在&lt;span&gt;/usr/lib/jvm/jdk1.8.0_191&lt;/span&gt;，那么只需执行以下命令建立软链接即可：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;mkdir /usr/java &amp;amp;&amp;amp;ln -s /usr/lib/jvm/jdk1.8.0_191 /usr/java/default
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;点击页面上的重试按钮；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;nfs-gateway启动失败&quot;&gt;NFS Gateway启动失败&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;发现NFS Gateway服务有问题，检查日志：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201015071630774-918442075.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;日志如下，在worker1节点上，portmap和rpcbind这两个服务不存在导致的：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;No portmap or rpcbind service is running on this host. Please start portmap or rpcbind service before attempting to start the NFS Gateway role on this host.
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;于是安装所需服务：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;yum install -y nfs-utils rpcbind
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;启动服务：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;systemctl start rpcbind
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;再次启动：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201015071631512-671931147.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;等待HDFS服务重启完成后，如下图，可见NFS Gateway问题已经消失：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201015071631946-1362881005.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;hdfs副本不足的块&quot;&gt;HDFS副本不足的块&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;问题如下图绿框所示：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201015071632375-1942520078.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;目前只有一个datanode，可以增加一个，如下图，进入HDFS的实例页面，点击&quot;添加角色实例&quot;：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201015071632949-883747471.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;点击下图红框位置，增加一个DataNode：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201015071633372-2119924930.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;如下图，确保worker1和worker2都选上：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201015071633750-38845663.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;勾选后，点击红框2中的按钮，在下拉菜单中点击“启动”：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201015071634171-727758234.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;现在有了两个DataNode，所以副本数可以设置为2，如下图红框所示，按照顺序找出参数进行设置，记得点击右下角的&quot;保存更改&quot;按钮：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201015071634561-1435044651.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;上述设置完成后，新写入hdfs的文件副本数为2，如果要将之前已经写入的文件的副本数也调整为2，请SSH登录worker1节点，执行以下命令切换到&lt;span&gt;hdfs&lt;/span&gt;账号：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;su - hdfs
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;8&quot;&gt;&lt;li&gt;以hdfs账号的身份执行以下命令，即可完成副本数设置：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;hadoop fs -setrep -R 2 /
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;9&quot;&gt;&lt;li&gt;返回管理页面，可见HDFS的状态变成了健康：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201015071634982-574456514.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;hive报错&quot;&gt;Hive报错&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;如下图红框所示，Hive启动失败，日志中提示&lt;span&gt;Version information not found in metastore&lt;/span&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201015071635407-545863972.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;从上图可见Hive服务在worker2上，于是SSH登录worker2，将&lt;span&gt;/usr/share/java&lt;/span&gt;目录下的&lt;span&gt;mysql-connector-java.jar&lt;/span&gt;文件复制到这个目录下：&lt;span&gt;/opt/cloudera/parcels/CDH-5.7.6-1.cdh5.7.6.p0.6/lib/hive/lib/&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;在Hive的配置页面，搜索&quot;hive.metastore.schema.verification&quot;，如下图，确保红框3中的复选框取消勾选：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201015071635765-531308734.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;修改配置&lt;span&gt;datanucleus.autoCreateSchema&lt;/span&gt;，如下图，确保红框3中的复选框被选中：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201015071636056-2121271186.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;重启完成后，Hive状态为健康：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201015071636506-422401168.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;spark-shell执行失败&quot;&gt;spark-shell执行失败&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;在worker1或者worker2上执行spark-shell命令进入spark控制台时，会产生内存相关的错误，需要调整YARM相关的内存参数：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201015071637001-2016654202.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;在YARN的配置页面，调整&lt;span&gt;yarn.scheduler.maximum-allocation-mb&lt;/span&gt;和&lt;span&gt;yarn.nodemanager.resource.memory-mb&lt;/span&gt;这两个参数的值，原有的值都是&lt;span&gt;1G&lt;/span&gt;，现在都改成&lt;span&gt;2G&lt;/span&gt;，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201015071637318-1963956935.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;重启YARN；&lt;/li&gt;
&lt;li&gt;重启Spark；&lt;/li&gt;
&lt;li&gt;执行spark-shell命令之前，先执行命令&lt;span&gt;su - hdfs&lt;/span&gt;切换到hdfs账号；&lt;/li&gt;
&lt;li&gt;这次终于成功进入spark-shell交互模式：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201015071637767-735483789.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;hue启动失败&quot;&gt;Hue启动失败&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;Hue启动失败如下图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201015071638202-53311740.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;上述失败是由于文件夹、文件、httpd服务没有准备好导致的，执行以下命令修复此问题：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;mkdir /var/log/hue-httpd/
chown hue:hue /var/log/hue-httpd/
cd /var/log/hue-httpd/
touch error_log
chown hue:hue /var/log/hue-httpd/error_log

yum install -y httpd mod_ssl cyrus-sasl-plain  cyrus-sasl-devel  cyrus-sasl-gssapi
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;在网页上重启Hue服务，稍后可见服务已经正常：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202010/485422-20201015071638535-1020460392.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;以上就是本次实战过程中遇到的所有问题和解决方法，至此《CDH5部署三部曲》全部完成，如果您正在部署CDH，希望此系列文章能给您一些参考。&lt;/p&gt;
&lt;h3 id=&quot;欢迎关注公众号：程序员欣宸&quot;&gt;欢迎关注公众号：程序员欣宸&lt;/h3&gt;
&lt;blockquote readability=&quot;4.258064516129&quot;&gt;
&lt;p&gt;微信搜索「程序员欣宸」，我是欣宸，期待与您一同畅游Java世界...&lt;br/&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 14 Oct 2020 23:17:00 +0000</pubDate>
<dc:creator>程序员欣宸</dc:creator>
<og:description>欢迎访问我的GitHub https://github.com/zq2599/blog_demos 内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bolingcavalry/p/13818455.html</dc:identifier>
</item>
<item>
<title>通俗易懂和你聊聊寄存器那些事(精美图文) - 程序员cxuan</title>
<link>http://www.cnblogs.com/cxuanBlog/p/13818439.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cxuanBlog/p/13818439.html</guid>
<description>&lt;blockquote readability=&quot;4&quot;&gt;
&lt;p&gt;我把自己以往的文章汇总成为了 Github ，欢迎各位大佬 star&lt;br/&gt;&lt;a href=&quot;https://github.com/crisxuan/bestJavaer&quot;&gt;https://github.com/crisxuan/bestJavaer&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面我们就来介绍一下关于寄存器的相关内容。我们知道，&lt;code&gt;寄存器&lt;/code&gt;是 CPU 内部的构造，它主要用于信息的存储。除此之外，CPU 内部还有&lt;code&gt;运算器&lt;/code&gt;，负责处理数据；&lt;code&gt;控制器&lt;/code&gt;控制其他组件；&lt;code&gt;外部总线&lt;/code&gt;连接 CPU 和各种部件，进行数据传输；&lt;code&gt;内部总线&lt;/code&gt;负责 CPU 内部各种组件的数据处理。&lt;/p&gt;
&lt;p&gt;那么对于我们所了解的汇编语言来说，我们的主要关注点就是 &lt;code&gt;寄存器&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;为什么会出现寄存器？因为我们知道，程序在内存中装载，由 CPU 来运行，CPU 的主要职责就是用来处理数据。那么这个过程势必涉及到从存储器中读取和写入数据，因为它涉及通过控制总线发送数据请求并进入存储器存储单元，通过同一通道获取数据，这个过程非常的繁琐并且会涉及到大量的内存占用，而且有一些常用的内存页存在，其实是没有必要的，因此出现了寄存器，存储在 CPU 内部。&lt;/p&gt;
&lt;h2 id=&quot;认识寄存器&quot;&gt;认识寄存器&lt;/h2&gt;
&lt;p&gt;寄存器的官方叫法有很多，Wiki 上面的叫法是 &lt;code&gt;Processing Register&lt;/code&gt;， 也可以称为 &lt;code&gt;CPU Register&lt;/code&gt;，计算机中经常有一个东西多种叫法的情况，反正你知道都说的是寄存器就可以了。&lt;/p&gt;
&lt;p&gt;认识寄存器之前，我们首先先来看一下 CPU 内部的构造。&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/10/14/0IIP9P.png&quot; alt=&quot;assembly02 001&quot; border=&quot;0&quot;/&gt;&lt;p&gt;CPU 从逻辑上可以分为 3 个模块，分别是控制单元、运算单元和存储单元，这三部分由 CPU 内部总线连接起来。&lt;/p&gt;
&lt;p&gt;几乎所有的冯·诺伊曼型计算机的 CPU，其工作都可以分为5个阶段：&lt;strong&gt;取指令、指令译码、执行指令、访存取数、结果写回&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;取指令&lt;/code&gt;阶段是将内存中的指令读取到 CPU 中寄存器的过程，程序寄存器用于存储下一条指令所在的地址&lt;/li&gt;
&lt;li&gt;&lt;code&gt;指令译码&lt;/code&gt;阶段，在取指令完成后，立马进入指令译码阶段，在指令译码阶段，指令译码器按照预定的指令格式，对取回的指令进行拆分和解释，识别区分出不同的指令类别以及各种获取操作数的方法。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;执行指令&lt;/code&gt;阶段，译码完成后，就需要执行这一条指令了，此阶段的任务是完成指令所规定的各种操作，具体实现指令的功能。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;访问取数&lt;/code&gt;阶段，根据指令的需要，有可能需要从内存中提取数据，此阶段的任务是：根据指令地址码，得到操作数在主存中的地址，并从主存中读取该操作数用于运算。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;结果写回&lt;/code&gt;阶段，作为最后一个阶段，结果写回（Write Back，WB）阶段把执行指令阶段的运行结果数据写回到 CPU 的内部寄存器中，以便被后续的指令快速地存取；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;计算机架构中的寄存器&quot;&gt;计算机架构中的寄存器&lt;/h3&gt;
&lt;p&gt;寄存器是一块速度非常快的计算机内存，下面是现代计算机中具有存储功能的部件比对，可以看到，寄存器的速度是最快的，同时也是造价最高昂的。&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/10/14/0II9ht.png&quot; alt=&quot;assembly02 002&quot; border=&quot;0&quot;/&gt;&lt;p&gt;我们以 intel 8086 处理器为例来进行探讨，8086 处理器是 x86 架构的前身。在 8086 后面又衍生出来了 8088 。&lt;/p&gt;
&lt;p&gt;在 8086 CPU 中，地址总线达到 20 根，因此最大寻址能力是 2^20 次幂也就是 1MB 的寻址能力，8088 也是如此。&lt;/p&gt;
&lt;p&gt;在 8086 架构中，所有的内部寄存器、内部以及外部总线都是 16 位宽，可以存储两个字节，因为是完全的 16 位微处理器。8086 处理器有 14 个寄存器，每个寄存器都有一个特有的名称，即&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AX，BX，CX，DX，SP，BP，SI，DI，IP，FLAG，CS，DS，SS，ES&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这 14 个寄存器有可能进行具体的划分，按照功能可以分为三种&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通用寄存器&lt;/li&gt;
&lt;li&gt;控制寄存器&lt;/li&gt;
&lt;li&gt;段寄存器&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面我们分别介绍一下这几种寄存器&lt;/p&gt;
&lt;h3 id=&quot;通用寄存器&quot;&gt;通用寄存器&lt;/h3&gt;
&lt;p&gt;通用寄存器主要有四种 ，即 &lt;strong&gt;AX、BX、CX、DX&lt;/strong&gt; 同样的，这四个寄存器也是 16 位的，能存放两个字节。 AX、BX、CX、DX 这四个寄存器一般用来存放数据，也被称为 &lt;code&gt;数据寄存器&lt;/code&gt;。它们的结构如下&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/10/14/0IISAA.png&quot; alt=&quot;assembly02 003&quot; border=&quot;0&quot;/&gt;&lt;p&gt;8086 CPU 的上一代寄存器是 8080 ，它是一类 8 位的 CPU，为了保证兼容性，8086 在 8080 上做了很小的修改，8086 中的通用寄存器 AX、BX、CX、DX 都可以独立使用两个 8 位寄存器来使用。&lt;/p&gt;
&lt;p&gt;在细节方面，AX、BX、CX、DX 可以再向下进行划分&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;AX(Accumulator Register)&lt;/code&gt; ： 累加寄存器，它主要用于输入/输出和大规模的指令运算。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BX(Base Register)&lt;/code&gt;：基址寄存器，用来存储基础访问地址&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CX(Count Register)&lt;/code&gt;：计数寄存器，CX 寄存器在迭代的操作中会循环计数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DX(data Register)&lt;/code&gt;：数据寄存器，它也用于输入/输出操作。它还与 AX 寄存器以及 DX 一起使用，用于涉及大数值的乘法和除法运算。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这四种寄存器可以分为上半部分和下半部分，用作八个 8 位数据寄存器&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;AX 寄存器可以分为两个独立的 8 位的 AH 和 AL 寄存器；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;BX 寄存器可以分为两个独立的 8 位的 BH 和 BL 寄存器；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CX 寄存器可以分为两个独立的 8 位的 CH 和 CL 寄存器；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DX 寄存器可以分为两个独立的 8 位的 DH 和 DL 寄存器；&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;除了上面 AX、BX、CX、DX 寄存器以外，其他寄存器均不可以分为两个独立的 8 位寄存器&lt;/p&gt;
&lt;p&gt;如下图所示。&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/10/14/0IIptI.png&quot; alt=&quot;assembly02 004&quot; border=&quot;0&quot;/&gt;&lt;p&gt;合起来就是&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/10/14/0I5v0H.png&quot; alt=&quot;assembly02 005&quot; border=&quot;0&quot;/&gt;&lt;p&gt;AX 的低位（0 - 7）位构成了 AL 寄存器，高 8 位（8 - 15）位构成了 AH 寄存器。AH 和 AL 寄存器是可以使用的 8 位寄存器，其他同理。&lt;/p&gt;
&lt;p&gt;在认识了寄存器之后，我们通过一个示例来看一下数据的具体存储方式。&lt;/p&gt;
&lt;p&gt;比如数据 19 ，它在 16 位存储器中所存储的表示如下&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/10/14/0I5x7d.png&quot; alt=&quot;assembly02 006&quot; border=&quot;0&quot;/&gt;&lt;p&gt;寄存器的存储方式是先存储低位，如果低位满足不了就存储高位，如果低位能够满足，高位用 0 补全，在其他低位能满足的情况下，其余位也用 0 补全。&lt;/p&gt;
&lt;p&gt;8086 CPU 可以一次存储两种类型的数据&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;字节(byte)&lt;/code&gt;： 一个字节由 8 bit 组成，这是一种恒定不变的存储方式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;字(word)&lt;/code&gt;：字是由指令集或处理器硬件作为单元处理的固定大小的数据，对于 intel 来说，一个字长就是两个字节，字是计算机一个非常重要的特征，针对不同的指令集架构来说，计算机一次处理的数据也是不同的。也就是说，针对不同指令集的机器，一次能处理不用的字长，有字、双字（32位）、四字（64位）等。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;ax-寄存器&quot;&gt;AX 寄存器&lt;/h4&gt;
&lt;p&gt;我们上面探讨过，AX 的另外一个名字叫做累加寄存器或者简称为累加器，其可以分为 2 个独立的 8 位寄存器 AH 和 AL；在编写汇编程序中，AX 寄存器可以说是使用频率最高的寄存器。&lt;/p&gt;
&lt;p&gt;下面是几段汇编代码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-assembly&quot;&gt;mov ax,20          /* 将 20 送入寄存器 AX*/
mov ah,80   /* 将 80 送入寄存器 AH*/
add ax,10         /* 将寄存器 AX 中的数值加上 8 */
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;这里注意下：上面代码中出现的是 ax、ah ，而注释中确是 AX、AH ，其实含义是一样的，不区分大小写。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;AX 相比于其他通用寄存器来说，有一点比较特殊，AX 具有一种特殊功能的使用，那就是使用 DIV 和 MUL 指令式使用。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;DIV 是 8086 CPU 中的&lt;code&gt;除法&lt;/code&gt;指令。&lt;/p&gt;
&lt;p&gt;MUL 是 8086 CPU 中的&lt;code&gt;乘法&lt;/code&gt;指令。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;bx-寄存器&quot;&gt;BX 寄存器&lt;/h4&gt;
&lt;p&gt;BX 被称为数据寄存器，即表明其能够暂存一般数据。同样为了适应以前的 8 位 CPU ，而可以将 BX 当做两个独立的 8 位寄存器使用，即有 BH 和 BL。BX 除了具有暂存数据的功能外，还用于 &lt;code&gt;寻址&lt;/code&gt;，即寻找物理内存地址。BX 寄存器中存放的数据一般是用来作为&lt;code&gt;偏移地址&lt;/code&gt; 使用的，因为偏移地址当然是在基址地址上的偏移了。偏移地址是在段寄存器中存储的，关于段寄存器的介绍，我们后面再说。&lt;/p&gt;
&lt;h4 id=&quot;cx-寄存器&quot;&gt;CX 寄存器&lt;/h4&gt;
&lt;p&gt;CX 也是数据寄存器，能够暂存一般性数据。同样为了适应以前的 8 位 CPU ，而可以将 CX 当做两个独立的 8 位寄存器使用，即有 CH 和 CL。除此之外，CX 也是有其专门的用途的，CX 中的 C 被翻译为 Counting 也就是计数器的功能。当在汇编指令中使用循环 LOOP 指令时，可以通过 CX 来指定需要循环的次数，每次执行循环 LOOP 时候，CPU 会做两件事&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;一件事是计数器自动减 1&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;还有一件就是判断 CX 中的值，如果 CX 中的值为 0 则会跳出循环，而继续执行循环下面的指令，&lt;/p&gt;
&lt;p&gt;当然如果 CX 中的值不为 0 ，则会继续执行循环中所指定的指令 。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;dx-寄存器&quot;&gt;DX 寄存器&lt;/h4&gt;
&lt;p&gt;DX 也是数据寄存器，能够暂存一般性数据。同样为了适应以前的 8 位 CPU ，DX 的用途其实在前面介绍 AX 寄存器时便已经有所介绍了，那就是支持 MUL 和 DIV 指令。同时也支持数值溢出等。&lt;/p&gt;
&lt;h3 id=&quot;段寄存器&quot;&gt;段寄存器&lt;/h3&gt;
&lt;p&gt;CPU 包含四个段寄存器，用作程序指令，数据或栈的基础位置。实际上，对 IBM PC 上所有内存的引用都包含一个段寄存器作为基本位置。&lt;/p&gt;
&lt;p&gt;段寄存器主要包含&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;CS(Code Segment)&lt;/code&gt; ： 代码寄存器，程序代码的基础位置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DS(Data Segment)&lt;/code&gt;： 数据寄存器，变量的基本位置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SS(Stack Segment)&lt;/code&gt;： 栈寄存器，栈的基础位置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ES(Extra Segment)&lt;/code&gt;： 其他寄存器，内存中变量的其他基本位置。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;索引寄存器&quot;&gt;索引寄存器&lt;/h3&gt;
&lt;p&gt;索引寄存器主要包含段地址的偏移量，索引寄存器主要分为&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;BP(Base Pointer)&lt;/code&gt;：基础指针，它是栈寄存器上的偏移量，用来定位栈上变量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SP(Stack Pointer)&lt;/code&gt;: 栈指针，它是栈寄存器上的偏移量，用来定位栈顶&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SI(Source Index)&lt;/code&gt;: 变址寄存器，用来拷贝源字符串&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DI(Destination Index)&lt;/code&gt;: 目标变址寄存器，用来复制到目标字符串&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;状态和控制寄存器&quot;&gt;状态和控制寄存器&lt;/h3&gt;
&lt;p&gt;就剩下两种寄存器还没聊了，这两种寄存器是指令指针寄存器和标志寄存器：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;IP(Instruction Pointer)&lt;/code&gt;： 指令指针寄存器，它是从 Code Segment 代码寄存器处的偏移来存储执行的下一条指令&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FLAG&lt;/code&gt; : Flag 寄存器用于存储当前进程的状态，这些状态有
&lt;ul&gt;&lt;li&gt;位置 (Direction)：用于数据块的传输方向，是向上传输还是向下传输&lt;/li&gt;
&lt;li&gt;中断标志位 (Interrupt) ：1 - 允许；0 - 禁止&lt;/li&gt;
&lt;li&gt;陷入位 (Trap) ：确定每条指令执行完成后，CPU 是否应该停止。1 - 开启，0 - 关闭&lt;/li&gt;
&lt;li&gt;进位 (Carry) : 设置最后一个无符号算术运算是否带有进位&lt;/li&gt;
&lt;li&gt;溢出 (Overflow) : 设置最后一个有符号运算是否溢出&lt;/li&gt;
&lt;li&gt;符号 (Sign) : 如果最后一次算术运算为负，则设置 1 =负，0 =正&lt;/li&gt;
&lt;li&gt;零位 (Zero) : 如果最后一次算术运算结果为零，1 = 零&lt;/li&gt;
&lt;li&gt;辅助进位 (Aux Carry) ：用于第三位到第四位的进位&lt;/li&gt;
&lt;li&gt;奇偶校验 (Parity) : 用于奇偶校验&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;物理地址&quot;&gt;物理地址&lt;/h2&gt;
&lt;p&gt;我们大家都知道， CPU 访问内存时，需要知道访问内存的具体地址，内存单元是内存的基本单位，每一个内存单元在内存中都有唯一的地址，这个地址即是 &lt;code&gt;物理地址&lt;/code&gt;。而 CPU 和内存之间的交互有三条总线，即数据总线、控制总线和地址总线。&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/09/29/0ZewE8.png&quot; alt=&quot;assembly008&quot; border=&quot;0&quot;/&gt;&lt;p&gt;CPU 通过地址总线将物理地址送入存储器，那么 CPU 是如何形成的物理地址呢？这将是我们接下来的讨论重点。&lt;/p&gt;
&lt;p&gt;现在，我们先来讨论一下和 8086 CPU 有关的结构问题。&lt;/p&gt;
&lt;p&gt;cxuan 和你聊了这么久，你应该知道 8086 CPU 是 16 位的 CPU 了，那么，什么是 16 位的 CPU 呢？&lt;/p&gt;
&lt;p&gt;你可能大致听过这个回答，16 位 CPU 指的是 CPU 一次能处理的数据是 16 位的，能回答这个问题代表你的底层还不错，但是不够全面，其实，16 位的 CPU 指的是&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;CPU 内部的运算器一次最多能处理 16 位的数据&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;运算器其实就是 ALU，运算控制单元，它是 CPU 内部的三大核心器件之一，主要负责数据的运算。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;寄存器的最大宽度为 16 位&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这个寄存器的最大宽度值得就是通用寄存器能处理的二进制数的最大位数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;寄存器和运算器之间的通路为 16 位&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这个指的是寄存器和运算器之间的总线，一次能传输 16 位的数据&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;好了，现在你应该知道为什么叫做 16 位 CPU 了吧。&lt;/p&gt;
&lt;p&gt;在你知道上面这个问题的答案之后，我们下面就来聊一聊如何计算物理地址。&lt;/p&gt;
&lt;p&gt;8086 CPU 有 20 位地址总线，每一条总线都可以传输一位的地址，所以 8086 CPU 可以传送 20 位地址，也就是说，8086 CPU 可以达到 2^20 次幂的寻址能力，也就是 1MB。8086 CPU 又是 16 位的结构，从 8086 CPU 的结构看，它只能传输 16 位的地址，也就是 2^16 次幂也就是 64 KB，那么它如何达到 1MB 的寻址能力呢？&lt;/p&gt;
&lt;p&gt;原来，8086 CPU 的内部采用两个 16 位地址合成的方式来传输一个 20 位的物理地址，如下图所示&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/10/14/0I5jne.png&quot; alt=&quot;assembly02 007&quot; border=&quot;0&quot;/&gt;&lt;p&gt;叙述一下上图描述的过程&lt;/p&gt;
&lt;p&gt;CPU 中相关组件提供两个地址：段地址和偏移地址，这两个地址都是 16 位的，他们经由&lt;code&gt;地址加法器&lt;/code&gt;变为 20 位的物理地址，这个地址即是输入输出控制电路传递给内存的物理地址，由此完成物理地址的转换。&lt;/p&gt;
&lt;p&gt;地址加法器采用 &lt;strong&gt;物理地址 = 段地址 * 16 + 偏移地址&lt;/strong&gt; 的方法用段地址和偏移地址合成物理地址。&lt;/p&gt;
&lt;p&gt;下面是地址加法器的工作流程&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/10/14/0I5OXD.png&quot; alt=&quot;assembly02 008&quot; border=&quot;0&quot;/&gt;&lt;p&gt;其实段地址 * 16 ，就是左移 4 位。在上面的叙述中，物理地址 = 段地址 * 16 + 偏移地址，其实就是&lt;strong&gt;基础地址 + 偏移地址 = 物理地址&lt;/strong&gt; 寻址模式的一种具体实现方案。基础地址其实就等于段地址 * 16。&lt;/p&gt;
&lt;p&gt;你可能不太清楚 &lt;code&gt;段&lt;/code&gt; 的概念，下面我们就来探讨一下。&lt;/p&gt;
&lt;h3 id=&quot;什么是段&quot;&gt;什么是段&lt;/h3&gt;
&lt;p&gt;段这个概念经常出现在操作系统中，比如在内存管理中，操作系统会把不同的数据分成 &lt;code&gt;段&lt;/code&gt;来存储，比如 &lt;strong&gt;代码段、数据段、bss 段、rodata 段&lt;/strong&gt; 等。&lt;/p&gt;
&lt;p&gt;但是这些的划分并不是内存干的，cxuan 告诉你是谁干的，这其实是幕后 Boss CPU 搞的，内存当作了声讨的对象。&lt;/p&gt;
&lt;p&gt;其实，内存没有进行分段，分段完全是由 CPU 搞的，上面聊过的通过基础地址 + 偏移地址 = 物理地址的方式给出内存单元的物理地址，使得我们可以分段管理 CPU。&lt;/p&gt;
&lt;p&gt;如图所示&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/10/14/0I5q1K.png&quot; alt=&quot;assembly02 009&quot; border=&quot;0&quot;/&gt;&lt;p&gt;这是两个 16 KB 的程序分别被装载进内存的示意图，可以看到，这两个程序的段地址的大小都是 16380。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;这里需要注意一点， 8086 CPU 段地址的计算方式是段地址 * 16，所以，16 位的寻址能力是 2^16 次方，所以一个段的长度是 64 KB。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;段寄存器-2&quot;&gt;段寄存器&lt;/h3&gt;
&lt;p&gt;cxuan 在上面只是简单为你介绍了一下段寄存器的概念，介绍的有些浅，而且介绍段寄存器不介绍段也有&lt;strong&gt;不知庐山真面目&lt;/strong&gt;的感觉，现在为你详细的介绍一下，相信看完上面的段的概念之后，段寄存器也是手到擒来。&lt;/p&gt;
&lt;p&gt;我们在合成物理地址的那张图提到了 &lt;code&gt;相关部件&lt;/code&gt; 的概念，这个相关部件其实就是&lt;code&gt;段寄存器&lt;/code&gt;，即 &lt;strong&gt;CS、DS、SS、ES&lt;/strong&gt; 。8086 的 CPU 在访问内存时，由这四个寄存器提供内存单元的段地址。&lt;/p&gt;
&lt;h4 id=&quot;cs-寄存器&quot;&gt;CS 寄存器&lt;/h4&gt;
&lt;p&gt;要聊 CS 寄存器，那么 IP 寄存器是你绕不过去的曾经。CS 和 IP 都是 8086 CPU 非常重要的寄存器，它们指出了 CPU 当前需要读取指令的地址。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;CS 的全称是 Code Segment，即代码寄存器；而 IP 的全称是 Instruction Pointer ，即指令指针。现在知道这两个为什么一起出现了吧！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 8086 CPU 中，由 &lt;code&gt;CS:IP&lt;/code&gt; 指向的内容当作指令执行。如下图所示&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/10/14/0I5L6O.png&quot; alt=&quot;assembly02 010&quot; border=&quot;0&quot;/&gt;&lt;p&gt;说明一下上图&lt;/p&gt;
&lt;p&gt;在 CPU 内部，由 CS、IP 提供段地址，由加法器负责转换为物理地址，输入输出控制电路负责输入/输出数据，指令缓冲器负责缓冲指令，指令执行器负责执行指令。在内存中有一段连续存储的区域，区域内部存储的是机器码、外面是地址和汇编指令。&lt;/p&gt;
&lt;p&gt;上面这幅图的段地址和偏移地址分别是 2000 和 0000，当这两个地址进入地址加法器后，会由地址加法器负责将这两个地址转换为物理地址&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/10/14/0I5bp6.png&quot; alt=&quot;assembly02 011&quot; border=&quot;0&quot;/&gt;&lt;p&gt;然后地址加法器负责将指令输送到输入输出控制电路中&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/10/14/0I5okR.png&quot; alt=&quot;assembly02 012&quot; border=&quot;0&quot;/&gt;&lt;p&gt;输入输出控制电路将 20 位的地址总线送到内存中。&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/10/14/0I57fx.png&quot; alt=&quot;assembly02 013&quot; border=&quot;0&quot;/&gt;&lt;p&gt;然后取出对应的数据，也就是 &lt;strong&gt;B8、23、01&lt;/strong&gt;，图中的 B8、BB 都是操作数。&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/10/14/0I5Tt1.png&quot; alt=&quot;assembly02 014&quot; border=&quot;0&quot;/&gt;&lt;p&gt;控制输入/输出电路会将 B8 23 01 送入指令缓存器中。&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/10/14/0I540J.png&quot; alt=&quot;assembly02 015&quot; border=&quot;0&quot;/&gt;&lt;p&gt;此时这个指令就已经具备执行条件，此时 IP 也就是指令指针会自动增加。我们上面说到 IP 其实就是从 Code Segment 也就是 CS 处偏移的地址，也就是偏移地址。它会知道下一个需要读取指令的地址，如下图所示&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/10/14/0I5579.png&quot; alt=&quot;assembly02 016&quot; border=&quot;0&quot;/&gt;&lt;p&gt;在这之后，指令执行执行取出的 B8 23 01 这条指令。&lt;/p&gt;
&lt;p&gt;然后下面再把 2000 和 0003 送到地址加法器中再进行后续指令的读取。后面的指令读取过程和我们上面探讨的如出一辙，这里 cxuan 就不再赘述啦。&lt;/p&gt;
&lt;p&gt;通过对上面的描述，我们能总结一下 8086 CPU 的工作过程&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;段寄存器提供段地址和偏移地址给地址加法器&lt;/li&gt;
&lt;li&gt;由地址加法器计算出物理地址通过输入输出控制电路将物理地址送到内存中&lt;/li&gt;
&lt;li&gt;提取物理地址对应的指令，经由控制电路取回并送到指令缓存器中&lt;/li&gt;
&lt;li&gt;IP 继续指向下一条指令的地址，同时指令执行器执行指令缓冲器中的指令&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;什么是-code-segment&quot;&gt;什么是 Code Segment&lt;/h4&gt;
&lt;p&gt;Code Segment 即代码段，它就是我们上面聊到就是 CS 寄存器中存储的基础地址，也就是段地址，段地址其本质上就是一组内存单元的地址，例如上面的 &lt;strong&gt;mov ax,0123H 、mov bx, 0003H&lt;/strong&gt;。我们可以将长度为 N 的一组代码，存放在一组连续地址、其实地址为 16 的倍数的内存单元中，我们可以认为，这段内存就是用来存放代码的。&lt;/p&gt;
&lt;h4 id=&quot;ds-寄存器&quot;&gt;DS 寄存器&lt;/h4&gt;
&lt;p&gt;CPU 在读写一个内存单元的时候，需要知道这个内存单元的地址。在 8086 CPU 中，有一个 &lt;code&gt;DS 寄存器&lt;/code&gt;，通常用来存放访问数据的段地址。如果你想要读取一个 10000H 的数据，你可能会需要下面这段代码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-assembly&quot;&gt;mov bx,10000H
mov ds,bx
mov a1,[0]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面这三条指令就把 10000H 读取到了 a1 中。&lt;/p&gt;
&lt;p&gt;在上面汇编代码中，mov 指令有两种传送方式&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一种是把数据直接送入寄存器&lt;/li&gt;
&lt;li&gt;一种是将一个寄存器的内容送入另一个寄存器&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;但是不仅仅如此，mov 指令还具有下面这几种表达方式&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;举例&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr&gt;&lt;td&gt;mov 寄存器，数据&lt;/td&gt;
&lt;td&gt;比如：mov ax,8&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;mov 寄存器，寄存器&lt;/td&gt;
&lt;td&gt;比如：mov ax,bx&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;mov 寄存器，内存单元&lt;/td&gt;
&lt;td&gt;比如：mov ax,[0]&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;mov 内存单元，寄存器&lt;/td&gt;
&lt;td&gt;比如：mov[0], ax&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;mov 段寄存器，寄存器&lt;/td&gt;
&lt;td&gt;比如：mov ds,ax&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;栈&quot;&gt;栈&lt;/h4&gt;
&lt;p&gt;栈我相信大部分小伙伴已经非常熟悉了，&lt;code&gt;栈&lt;/code&gt;是一种具有特殊的访问方式的存储空间。它的特殊性就在于，先进入栈的元素，最后才出去，也就是我们常说的 &lt;code&gt;先入后出&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;它就像一个大的收纳箱，你可以往里面放相同类型的东西，比如书，最先放进收纳箱的书在最下面，最后放进收纳箱的书在最上面，如果你想拿书的话， 必须从最上面开始取，否则是无法取出最下面的书籍的。&lt;/p&gt;
&lt;p&gt;栈的数据结构就是这样，你把书籍压入收纳箱的操作叫做&lt;code&gt;压入（push）&lt;/code&gt;，你把书籍从收纳箱取出的操作叫做&lt;code&gt;弹出（pop）&lt;/code&gt;，它的模型图大概是这样&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/10/14/0I5R6U.png&quot; alt=&quot;assembly02 017&quot; border=&quot;0&quot;/&gt;&lt;p&gt;入栈相当于是增加操作，出栈相当于是删除操作，只不过叫法不一样。栈和内存不同，它不需要指定元素的地址。它的大概使用如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;// 压入数据
Push(123);
Push(456);
Push(789);

// 弹出数据
j = Pop();
k = Pop();
l = Pop();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在栈中，LIFO 方式表示栈的数组中所保存的最后面的数据（Last In）会被最先读取出来（First Out）。&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/10/14/0I5WXF.png&quot; alt=&quot;assembly02 018&quot; border=&quot;0&quot;/&gt;&lt;h4 id=&quot;栈和-ss-寄存器&quot;&gt;栈和 SS 寄存器&lt;/h4&gt;
&lt;p&gt;下面我们就通过一段汇编代码来描述一下栈的压入弹出的过程&lt;/p&gt;
&lt;p&gt;8086 CPU 提供入栈和出栈指令，最基本的两个是 &lt;code&gt;PUSH(入栈)&lt;/code&gt; 和 &lt;code&gt;POP(出栈)&lt;/code&gt;。比如 push ax 会把 ax 寄存器中的数据压入栈中，pop ax 表示从栈顶取出数据送入 ax 寄存器中。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这里注意一点：8086 CPU 中的入栈和出栈都是以字为单位进行的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我这里首先有一个初始的栈，没有任何指令和数据。&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/10/14/0I52lT.png&quot; alt=&quot;assembly02 019&quot; border=&quot;0&quot;/&gt;&lt;p&gt;然后我们向栈中 push 数据后，栈中数据如下&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/10/14/0I56f0.png&quot; alt=&quot;assembly02 020&quot; border=&quot;0&quot;/&gt;&lt;p&gt;涉及的指令有&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-assembly&quot;&gt;mov ax,2345H
push ax
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意，数据会用两个单元存放，高地址单元存放高 8 位地址，低地址单元存放低 8 位。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;再向栈中 push 数据&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/10/14/0I5skn.png&quot; alt=&quot;assembly02 021&quot; border=&quot;0&quot;/&gt;&lt;p&gt;其中涉及的指令有&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-assembly&quot;&gt;mov bx,0132H
push bx
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在栈中有两条数据，现在我们执行出栈操作&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/10/14/0I5DTs.png&quot; alt=&quot;assembly02 022&quot; border=&quot;0&quot;/&gt;&lt;p&gt;其中涉及的指令有&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-assembly&quot;&gt;pop ax
/* ax = 0132H */
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再继续取出数据&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/10/14/0I5a6S.png&quot; alt=&quot;assembly02 023&quot; border=&quot;0&quot;/&gt;&lt;p&gt;涉及的指令有&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-assembly&quot;&gt;pop bx
/* bx = */
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;完整的 push 和 pop 过程如下&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/10/14/0I50mQ.png&quot; alt=&quot;assembly02 024&quot; border=&quot;0&quot;/&gt;&lt;p&gt;现在 cxuan 问你一个问题，我们上面描述的是 10000H ~ 1000FH 这段空间来作为 push 和 pop 指令的存取单元。但是，你怎么知道这个栈单元就是 10000H ~ 1000FH 呢？也就是说，你如何选择指定的栈单元进行存取？&lt;/p&gt;
&lt;p&gt;事实上，8086 CPU 有一组关于栈的寄存器 &lt;code&gt;SS&lt;/code&gt; 和 &lt;code&gt;SP&lt;/code&gt;。SS 是段寄存器，它存储的是栈的基础位置，也就是栈顶的位置，而 SP 是栈指针，它存储的是偏移地址。在任意时刻，&lt;code&gt;SS:SP&lt;/code&gt; 都指向栈顶元素。push 和 pop 指令执行时，CPU 从 SS 和 SP 中得到栈顶的地址。&lt;/p&gt;
&lt;p&gt;现在，我们可以完整的描述一下 push 和 pop 过程了，下面 cxuan 就给你推导一下这个过程。&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/10/14/0I5hm4.png&quot; alt=&quot;assembly02 025&quot; border=&quot;0&quot;/&gt;&lt;p&gt;上面这个过程主要涉及到的关键变化如下。&lt;/p&gt;
&lt;p&gt;当使用 &lt;strong&gt;PUSH&lt;/strong&gt; 指令向栈中压入 1 个字节单元时，SP = SP - 1；即栈顶元素会发生变化；&lt;/p&gt;
&lt;p&gt;而当使用 &lt;strong&gt;PUSH&lt;/strong&gt; 指令向栈中压入 2 个字节的字单元时，SP = SP – 2 ；即栈顶元素也要发生变化；&lt;/p&gt;
&lt;p&gt;当使用 &lt;strong&gt;POP&lt;/strong&gt; 指令从栈中弹出 1 个字节单元时， SP = SP + 1；即栈顶元素会发生变化；&lt;/p&gt;
&lt;p&gt;当使用 &lt;strong&gt;POP&lt;/strong&gt; 指令从栈中弹出 2 个字节单元的字单元时， SP = SP + 2 ；即栈顶元素会发生变化；&lt;/p&gt;
&lt;h4 id=&quot;栈顶越界问题&quot;&gt;栈顶越界问题&lt;/h4&gt;
&lt;p&gt;现在我们知道，8086 CPU 可以使用 SS 和 SP 指示栈顶的地址，并且提供 PUSH 和 POP 指令实现入栈和出栈，所以，你现在知道了如何能够找到栈顶位置，但是你如何能保证栈顶的位置不会越界呢？栈顶越界会产生什么影响呢？&lt;/p&gt;
&lt;p&gt;比如如下是一个栈顶越界的示意图&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/10/14/0I5Bwj.png&quot; alt=&quot;assembly02 026&quot; border=&quot;0&quot;/&gt;&lt;p&gt;第一开始，SS：SP 寄存器指向了栈顶，然后向栈空间 push 一定数量的元素后，SS:SP 位于栈空间顶部，此时再向栈空间内部 push 元素，就会出现栈顶越界问题。&lt;/p&gt;
&lt;p&gt;栈顶越界是危险的，因为我们既然将一块区域空间安排为栈，那么在栈空间外部也可能存放了其他指令和数据，这些指令和数据有可能是其他程序的，所以如此操作会让计算机&lt;code&gt;懵逼&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;我们希望 8086 CPU 能自己解决问题，毕竟 8086 CPU 已经是个成熟的 CPU 了，要学会自己解决问题了。&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/10/14/0I5dOg.png&quot; alt=&quot;assembly02 027&quot; border=&quot;0&quot;/&gt;&lt;p&gt;然鹅（故意的），这对于 8086 CPU 来说，这可能是它一辈子的 &lt;code&gt;夙愿&lt;/code&gt; 了，真实情况是，8086 CPU 不会保证栈顶越界问题，也就是说 8086 CPU 只会告诉你栈顶在哪，并不会知道栈空间有多大，所以需要程序员自己手动去保证。。。&lt;/p&gt;
&lt;p&gt;另外，我输出了 六本 PDF，已免费提供下载，如下所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202010/1515111-20201015062847660-1920782836.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;链接: &lt;a href=&quot;https://pan.baidu.com/s/1mYAeS9hIhdMFh2rF3FDk0A&quot;&gt;https://pan.baidu.com/s/1mYAeS9hIhdMFh2rF3FDk0A&lt;/a&gt; 密码: p9rs&lt;/p&gt;
</description>
<pubDate>Wed, 14 Oct 2020 22:30:00 +0000</pubDate>
<dc:creator>程序员cxuan</dc:creator>
<og:description>我把自己以往的文章汇总成为了 Github ，欢迎各位大佬 star https://github.com/crisxuan/bestJavaer 下面我们就来介绍一下关于寄存器的相关内容。我们知道，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cxuanBlog/p/13818439.html</dc:identifier>
</item>
<item>
<title>Javascript判断数据类型的五种方式及其特殊性 - bigname22</title>
<link>http://www.cnblogs.com/bigname/p/13818425.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bigname/p/13818425.html</guid>
<description>&lt;center&gt;&lt;span&gt;Javascript判断数据类型的五种方式及区别&lt;/span&gt;&lt;/center&gt;&lt;p&gt;@&lt;/p&gt;

&lt;p&gt;&lt;span&gt;-------------人工分割线-------------&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;typeof&quot;&gt;&lt;span&gt;&lt;span&gt;typeof&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;MDN：typeof操作符返回一个字符串，表示未经计算的操作数的类型。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;span&gt;&lt;code class=&quot;language-javascript&quot;&gt;    let data = {
        number : 1,
        string : 'b',
        boolean : true,
        symbol : Symbol(),
        null : null,
        undefined : undefined,
        nan : NaN,
        function : function (){},
        object : {},
        array: [],
    };

    for(let key in data) {
        console.log(key + ':::', typeof data[key]);
    }
    // -----------  打印结果  ------------------
    number::: number
    string::: string
    boolean::: boolean
    symbol::: symbol
    null::: object          // 需要注意
    undefined::: undefined
    nan::: number           // 需要注意
    function::: function
    object::: object
    array::: object         // 需要注意
&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;null、array：打印结果都是object&lt;br/&gt;NaN：打印结果是number&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;关于null打印成object的原因：属于JS遗留bug，在一开是的JS版本种使用32位系统，为了提高性能使用低位存储变量的类型信息，所以将000 开头代表是对象，但是 null 表示为全零，所在在判断null时也会将它错误的判断为 object 。&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;instanceof&quot;&gt;&lt;span&gt;&lt;span&gt;instanceof&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;MDN：instanceof 运算符用来检测 constructor.prototype 是否存在于参数 object 的原型链上&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;span&gt;&lt;code class=&quot;language-javascript&quot;&gt;         function Animal(name) {
        this.name = name;
    }

    let cat = new Animal('cat');
    let dog = new Animal('dog');
    console.log(cat instanceof Animal);
    console.log(cat instanceof dog); // 报错：Right-hand side of 'instanceof' is not callable
    
&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;instanceof的右边要求是一个构造函数，否则报错。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;如何理解&lt;/strong&gt;：instanceof 运算符用来检测 constructor.prototype 是否存在于参数 object 的原型链上？？&lt;/span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;:::&lt;/strong&gt; 如：cat instanceof Animal：Animal.prototype是否在cat的原型链上【Animal--Object】,显然是在的，所以返回true。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;思考：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;&lt;code class=&quot;language-javascript&quot;&gt;    function Animal(name) {
        this.name = name;
    }
    let cat = new Animal('cat'); //
        // 此时将Animal.prototype指向空对象
        let A = {};
    Animal.prototype = A;
    let cat2 = new Animal('cat2');
    console.log(cat instanceof Animal);
    console.log(cat2 instanceof Animal);
&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;此时应该打印什么？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先分析cat的原型链：【Animal -- Object】&lt;br/&gt;cat2的原型链：【A --- Object】&lt;br/&gt;此时Animal.prototype指向A对象，所以A在cat2的原型链上，而不在cat上。&lt;/span&gt;&lt;/p&gt;
&lt;span&gt;&lt;span&gt;所以打印结果： false true&lt;/span&gt;&lt;/span&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;总结&lt;/strong&gt;：先找到Animal.prototype,在列出cat的原型链，如果在就true否则false。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;特殊点：&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;1：instanceof 和多全局对象(例如：多个 frame 或多个 window 之间的交互)&lt;/strong&gt;&lt;br/&gt;不同的全局环境拥有不同的全局对象，从而拥有不同的内置类型构造函数。这可能会引发一些问题。比如，表达式 [] instanceof window.frames[0].Array 会返回 false，因为 Array.prototype !== window.frames[0].Array.prototype，并且数组从前者继承。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2： String 对象和 Date 对象都属于 Object 类型和一些特殊情况&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;&lt;code class=&quot;language-javascript&quot;&gt;    let simpleStr = 'simpleStr';
    let myObj = {};
    let myNullObj = Object.create(null);
    console.log(simpleStr instanceof String); //false [检查原型链会找到 undefined]
    console.log(myObj instanceof Object);     //true
    console.log(myNullObj instanceof Object); //false [一种创建非 Object 实例的对象的方法]
&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;objectprototypetostring&quot;&gt;&lt;span&gt;&lt;span&gt;Object.prototype.toString&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;MDN:方法返回一个表示该对象的字符串。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;span&gt;&lt;code class=&quot;language-javascript&quot;&gt;// 数据源看开头的代码
 for(let key in data) {
        console.log(key + ':::', Object.prototype.toString.call(data[key]));
    }
    /*
        number::: [object Number]
        string::: [object String]
        boolean::: [object Boolean]
        symbol::: [object Symbol]
        null::: [object Null]
        undefined::: [object Undefined]
        nan::: [object Number]  // 需要注意
        function::: [object Function]
        object::: [object Object]
        array::: [object Array]
    * */
&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;为了每个对象都能通过 Object.prototype.toString() 来检测，需要以 Function.prototype.call() 或者 Function.prototype.apply() 的形式来调用，传递要检查的对象作为第一个参数，称为 thisArg。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;&lt;span&gt;Object.prototype.toString 的原理是当调用的时候, 就取值内部的 [[Class]] 属性值, 然后拼接成 '[object ' + [[Class]] + ']' 这样的字符串并返回. 然后我们使用 call 方法来获取任何值的数据类型.&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;isarray&quot;&gt;&lt;span&gt;&lt;span&gt;isArray&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;MDN：如果对象是 Array ，则返回true，否则为false。&lt;br/&gt;这个比较简单不写例子了。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;特殊性：当检测Array实例时, Array.isArray 优于 instanceof,因为Array.isArray能检测iframes.&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;&lt;code class=&quot;language-javascript&quot;&gt;var iframe = document.createElement('iframe');
document.body.appendChild(iframe);
xArray = window.frames[window.frames.length-1].Array;
var arr = new xArray(1,2,3); // [1,2,3]

// Correctly checking for Array
Array.isArray(arr);  // true
// Considered harmful, because doesn't work though iframes
arr instanceof Array; // fals
&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;iisnan&quot;&gt;&lt;span&gt;&lt;span&gt;iisNaN&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;MDN:用来确定一个值是否为NaN 。注：isNaN函数内包含一些非常有趣的规则；你也可以使用 ECMAScript 2015 中定义的 Number.isNaN() 来判断。与 JavaScript 中其他的值不同，NaN不能通过相等操作符（== 和 ===）来判断 ，因为 NaN == NaN 和 NaN === NaN 都会返回 false。 因此，isNaN 就很有必要了。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;span&gt;&lt;code class=&quot;language-javascript&quot;&gt;isNaN(NaN);       // true
isNaN(undefined); // true
isNaN({});        // true

isNaN(true);      // false
isNaN(null);      // false
isNaN(37);        // false

// strings
isNaN(&quot;37&quot;);      // false: 可以被转换成数值37
isNaN(&quot;37.37&quot;);   // false: 可以被转换成数值37.37
isNaN(&quot;37,5&quot;);    // true
isNaN('123ABC');  // true:  parseInt(&quot;123ABC&quot;)的结果是 123, 但是Number(&quot;123ABC&quot;)结果是 NaN
isNaN(&quot;&quot;);        // false: 空字符串被转换成0
isNaN(&quot; &quot;);       // false: 包含空格的字符串被转换成0

// dates
isNaN(new Date());                // false
isNaN(new Date().toString());     // true

isNaN(&quot;blabla&quot;)   // true: &quot;blabla&quot;不能转换成数值
                  // 转换成数值失败， 返回NaN
&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一个有用的特性：&lt;/strong&gt;&lt;br/&gt;有许多方式来看待isNaN()：如果isNaN(x)返回false，那么x在任何算数表达式中都不会使表达式等于NaN；如果返回true，x会使所有算数表达式返回NaN。这就意味着，在JavaScript中，isNaN(x)==true等价于x-0=NaN(在JavaScript中 x-0 == NaN 总是返回false，所以你不用去测试它)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;实际上，&lt;/em&gt; isNaN(x), isNaN(x - 0),isNaN(Number(x)), Number.isNaN(x - 0),和Number.isNaN(Number(x)) 的返回值都是一样的 并且在JavaScript中isNaN(x)是这些表达式中最短的表达。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 14 Oct 2020 19:29:00 +0000</pubDate>
<dc:creator>bigname22</dc:creator>
<og:description>Javascript判断数据类型的五种方式及区别 @(五种方式) 人工分割线 typeof MDN：typeof操作符返回一个字符串，表示未经计算的操作数的类型。 let data = { numbe</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bigname/p/13818425.html</dc:identifier>
</item>
<item>
<title>C# 范型约束 new() 你必须要知道的事 - 沉睡的木木夕</title>
<link>http://www.cnblogs.com/ms27946/p/Note-About-The-Generic-Constraint-Of-New.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ms27946/p/Note-About-The-Generic-Constraint-Of-New.html</guid>
<description>&lt;p&gt;注意：本文不会讲范型如何使用，关于范型的概念和范型约束的使用请移步谷歌。&lt;/p&gt;
&lt;p&gt;本文要讲的是关于范型约束无参构造函数 new 的一些底层细节和注意事项。写这篇文章的原因也是因为看到 github 上，以及其他地方看到的代码都是那么写的，而我一查相关的资料，发现鲜有人提到这方面的细节，所以才有了此文。&lt;/p&gt;
&lt;p&gt;这里我先直接抛出一段代码，请大家看下这段代码有什么问题？或者说能说出什么问题？&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public static T CreateInstance&amp;lt;T&amp;gt;() where T: new() =&amp;gt; new T();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先不要想这种写法的合理性（实际上很多人都会诸如此类的这么写，无非就是中间多了一些业务处理，最后还是会 &lt;code&gt;return new T()&lt;/code&gt;）。先想一下，然后在看下面的分析。&lt;/p&gt;
&lt;p&gt;假设这样的问题出现在面试上，其实能有很多要考的点。&lt;/p&gt;

&lt;p&gt;如果说我们不知道范型底下到底做了什么操作，我们也不用急，我们可以用 ILSpy 来看查看一下，代码片段如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;.method public hidebysig static 
    !!T CreateInstance&amp;lt;.ctor T&amp;gt; () cil managed 
{
    // Method begins at RVA 0x2053
    // Code size 6 (0x6)
    .maxstack 8
    
    IL_0000: call !!0 [System.Private.CoreLib]System.Activator::CreateInstance&amp;lt;!!T&amp;gt;()
    IL_0005: ret
} // end of method C::CreateInstance
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;3.2692307692308&quot;&gt;
&lt;p&gt;没有 ILSpy 的同学可以移步&lt;a href=&quot;https://sharplab.io/#v2:C4LglgNgNAJiDUAfAAgJgIwFgBQyDMABGgQMIEDeOB1RhyALAQLIAUAlBVTQL5fV+0i6AGwEAKqQBOAUwCGwaQEkAdgGdgs5QGNpAHjEA+dgQDuAC2kzxIAsuknjAXgO3749gG4c3IA=&quot;&gt;这里在线查看&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 IL_0000 就能明显看出范型约束 new() 的底层实现是通过反射来实现的。至于 &lt;code&gt;System.Activator.CreateInstance&amp;lt;T&amp;gt;&lt;/code&gt; 方法实现我在这里就不提了。只知道这里用的是它就足够了。不知道大家看到这里有没有觉得一丝惊讶，我当时是有被惊到的，因为我的第一想法就是觉得这么简单肯定是直接调用无参 .ctor，居然是用到的反射。毕竟编译器拥有在编译器就能识别具体的范型类了。现在可以马后炮的讲：&lt;strong&gt;正因为是编译器只有在编译期才确定具体范型类型，所以编译器无法事先知道要直接调用哪些无参构造函数类，所以才用到了反射。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果本文仅仅只是这样，那我肯定没有勇气写下这片文章的。因为其实已经&lt;a href=&quot;https://www.cnblogs.com/Hush/archive/2004/10/07/49674.html&quot;&gt;有人早在 04 年园子里就提到了这一点&lt;/a&gt;。但是我查到的资料也就止步于此。&lt;/p&gt;
&lt;p&gt;试想一下 ，如果你的框架中有些方法用到了无参构造函数范型约束，并且处于调用的热路径上，其实这样性能是大打折扣的，因为反射 &lt;code&gt;Activator.CreateInstance&lt;/code&gt; 性能肯定是远远不如直接调用无参构造函数的。&lt;/p&gt;
&lt;p&gt;那么有没有什么方法能够在使用范型约束这个特征的同时，又不会让编译器去用反射呢？&lt;/p&gt;
&lt;p&gt;答案肯定是有的，这点我想喜欢动手实验肯定早就知道了。其实我们可以用到&lt;strong&gt;委托来初始化类&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;如果大家对这点都知道的话，可以略过本节（在这里鼓励大家可以写出来造福大家呀，对于这点那些不知道的人（我）要花很长时间才弄清楚 -_-）。&lt;/p&gt;
&lt;p&gt;让我们把上面的例子改成如下方式：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public static Func&amp;lt;Bar&amp;gt; InstanceFactory =&amp;gt; () =&amp;gt; new Bar();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于委托的底层相信大家还是都知道的，底层是通过生成一个类 C，在这个类中直接实例化类 Bar。下面我只贴出关键的代码片段&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;.method public hidebysig specialname static 
    class [System.Private.CoreLib]System.Func`1&amp;lt;class Bar&amp;gt; get_InstanceFactory () cil managed 
{
    // Method begins at RVA 0x205a
    // Code size 32 (0x20)
    .maxstack 8

    IL_0000: ldsfld class [System.Private.CoreLib]System.Func`1&amp;lt;class Bar&amp;gt; C/'&amp;lt;&amp;gt;c'::'&amp;lt;&amp;gt;9__3_0'
    IL_0005: dup
    IL_0006: brtrue.s IL_001f

    IL_0008: pop
    IL_0009: ldsfld class C/'&amp;lt;&amp;gt;c' C/'&amp;lt;&amp;gt;c'::'&amp;lt;&amp;gt;9'
    IL_000e: ldftn instance class Bar C/'&amp;lt;&amp;gt;c'::'&amp;lt;get_InstanceFactory&amp;gt;b__3_0'()
    IL_0014: newobj instance void class [System.Private.CoreLib]System.Func`1&amp;lt;class Bar&amp;gt;::.ctor(object, native int)
    IL_0019: dup
    IL_001a: stsfld class [System.Private.CoreLib]System.Func`1&amp;lt;class Bar&amp;gt; C/'&amp;lt;&amp;gt;c'::'&amp;lt;&amp;gt;9__3_0'

    IL_001f: ret
} // end of method C::get_InstanceFactory

.method assembly hidebysig 
    instance class Bar '&amp;lt;get_InstanceFactory&amp;gt;b__3_0' () cil managed 
{
    // Method begins at RVA 0x2090
    // Code size 6 (0x6)
    .maxstack 8

    IL_0000: newobj instance void Bar::.ctor()
    IL_0005: ret
} // end of method '&amp;lt;&amp;gt;c'::'&amp;lt;get_InstanceFactory&amp;gt;b__3_0'
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;3.9655172413793&quot;&gt;
&lt;p&gt;同样我们可以通过 ILSpy 或者 &lt;a href=&quot;https://sharplab.io/#v2:CYLg1APgAgTAjAWAFBQMwAJboMLoN7LpGYZQAs6AsgBQCU+hxAvo0ayZnAGzoAqOAJwCmAQwAuQgJIA7AM5iR0gMZCAPLwB8ddAHcAFkOF8Q6aUJ3aAvBtPm+dANzs0nHlACsqgEIiBNmfKKKgBiIkpiAPYCAJ7o1uhWNmY66D4CjsgsSMguWGnIBEhMQA==&quot;&gt;在线查看示例&lt;/a&gt; 查看委托生成的代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里可以明显看出是不存在反射调用的，IL_000e 处直接调用编译器生成的类 C 的方法 &lt;code&gt;b__3_0&lt;/code&gt; ,在这个方法中就会直接调用类 Bar 的构造函数。所以性能上绝对要比上种写法要高得多。&lt;/p&gt;
&lt;p&gt;看到这里可能大家又有新问题了，众所周知，委托要在初始化时就要确定表达式。所以与此处的范型动态调用是冲突的。的确没错，委托&lt;strong&gt;必须要在初始化表达式时就要确定类型&lt;/strong&gt;。但是我们现在已经知道了委托是能够避免让编译器不用反射的，剩下的只是解决动态表达式的问题，毫无疑问表达式树该登场了。&lt;/p&gt;

&lt;p&gt;对于这部分已经知道的同学可以跳过本节。&lt;/p&gt;
&lt;p&gt;把委托改造成表达式树那是非常简单的，我们可以不假思索的写出下面代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;private static readonly Expression&amp;lt;Func&amp;lt;T&amp;gt;&amp;gt; ctorExpression = () =&amp;gt; new T();
public static T CreateInstance() where T : new() {
  var func = ctorExpression.Compile();
  return func();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到这里其实就有点”旧酒装新瓶“的意思了。不过有点要注意的是，如果单纯只是表达式树的优化，从执行效率上来看肯定是不如委托来的快，毕竟表达式树多了一层构造表达式然后编译成委托的过程。优化也是有的，再继续往下讲就有点“偏题”了。因为往后其实就是对委托，对表达式树的性能优化问题。跟范型约束倒没关系了&lt;/p&gt;

&lt;p&gt;其实如果面试真的有问到这个问题的话，其实考的就是对范型约束 new() 底层的一个熟悉程度，然后转而从反射的点来思考问题的优化方案。因为这可以散发出很多问题，比如性能优化，从直接返回 &lt;code&gt;new T()&lt;/code&gt; 到委托，因为委托无法做到动态变化，所以想到了表达式树。那么我们继而也能举一反三的知道，如果要继续优化的话，在构造表达式树时，我们可以用缓存来节省每次调用方法的构造表达式树的时间（DI 的 CallSite 实现细节就是如此）。如果我们生思熟虑之后还要选择继续优化，那么我们还可以从表达式树转到动态生成代码这一领域，通过编写 IL 代码来生成表达式树，进而缓存下来达到近乎直接调用的性能。这也是为什么我花了很长时间弄清楚这个的原因。&lt;/p&gt;

&lt;p&gt;代码地址在：&lt;a href=&quot;https://github.com/MarsonShine/Books/tree/master/WHPerformanceDotNet/src/GenericOptimization&quot;&gt;https://github.com/MarsonShine/Books/tree/master/WHPerformanceDotNet/src/GenericOptimization&lt;/a&gt;&lt;br/&gt;注意：我上传这一版是下方第一个文章给出的例子的整理之后的版本。文中有很多代码我都没贴出来，一是觉得意义不大，重要的是思考过程和实践过程，还占文章篇幅。二是还是想让不知道这些的同学能自己动手编码自己的版本，最后才看与那些大牛写的版本的差距在哪，这样才会更有收获。&lt;/p&gt;


</description>
<pubDate>Wed, 14 Oct 2020 16:18:00 +0000</pubDate>
<dc:creator>沉睡的木木夕</dc:creator>
<og:description>C# 范型约束 new() 你必须要知道的事 注意：本文不会讲范型如何使用，关于范型的概念和范型约束的使用请移步谷歌。 本文要讲的是关于范型约束无参构造函数 new 的一些底层细节和注意事项。写这篇文</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ms27946/p/Note-About-The-Generic-Constraint-Of-New.html</dc:identifier>
</item>
<item>
<title>Kubernetes K8S之存储ConfigMap详解 - 踏歌行666</title>
<link>http://www.cnblogs.com/zhanglianghhh/p/13818190.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhanglianghhh/p/13818190.html</guid>
<description>
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;K8S之存储ConfigMap概述与说明，并详解常用ConfigMap示例&lt;/p&gt;
&lt;/blockquote&gt;


&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;服务器名称(hostname)&lt;/th&gt;
&lt;th&gt;系统版本&lt;/th&gt;
&lt;th&gt;配置&lt;/th&gt;
&lt;th&gt;内网IP&lt;/th&gt;
&lt;th&gt;外网IP(模拟)&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;k8s-master&lt;/td&gt;
&lt;td&gt;CentOS7.7&lt;/td&gt;
&lt;td&gt;2C/4G/20G&lt;/td&gt;
&lt;td&gt;172.16.1.110&lt;/td&gt;
&lt;td&gt;10.0.0.110&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;k8s-node01&lt;/td&gt;
&lt;td&gt;CentOS7.7&lt;/td&gt;
&lt;td&gt;2C/4G/20G&lt;/td&gt;
&lt;td&gt;172.16.1.111&lt;/td&gt;
&lt;td&gt;10.0.0.111&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;k8s-node02&lt;/td&gt;
&lt;td&gt;CentOS7.7&lt;/td&gt;
&lt;td&gt;2C/4G/20G&lt;/td&gt;
&lt;td&gt;172.16.1.112&lt;/td&gt;
&lt;td&gt;10.0.0.112&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;ConfigMap 是一种 API 对象，用来将&lt;span&gt;非机密性的数据保存到健值对&lt;/span&gt;中。使用时可以用作&lt;span&gt;环境变量&lt;/span&gt;、&lt;span&gt;命令行参数&lt;/span&gt;或者&lt;span&gt;存储卷&lt;/span&gt;中的配置文件。&lt;/p&gt;
&lt;p&gt;ConfigMap 将环境配置信息和容器镜像解耦，便于应用配置的修改。当你需要储存机密信息时可以使用 Secret 对象。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;备注：ConfigMap 并不提供保密或者加密功能。如果你想存储的数据是机密的，请使用 Secret；或者使用其他第三方工具来保证数据的私密性，而不是用 ConfigMap。&lt;/span&gt;&lt;/p&gt;


&lt;h2 id=&quot;通过目录创建&quot;&gt;通过目录创建&lt;/h2&gt;
&lt;p&gt;配置文件目录&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [root@k8s-master storage]# &lt;span&gt;pwd&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; /root/k8s_practice/&lt;span&gt;storage
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; [root@k8s-master storage]# ll /root/k8s_practice/storage/&lt;span&gt;configmap    # 配置文件存在哪个目录下
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; total &lt;span&gt;8&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; -rw-r--r-- &lt;span&gt;1&lt;/span&gt; root root &lt;span&gt;159&lt;/span&gt; Jun  &lt;span&gt;7&lt;/span&gt; &lt;span&gt;14&lt;/span&gt;:&lt;span&gt;52&lt;/span&gt;&lt;span&gt; game.properties
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; -rw-r--r-- &lt;span&gt;1&lt;/span&gt; root root  &lt;span&gt;83&lt;/span&gt; Jun  &lt;span&gt;7&lt;/span&gt; &lt;span&gt;14&lt;/span&gt;:&lt;span&gt;53&lt;/span&gt;&lt;span&gt; ui.properties
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; [root@k8s-&lt;span&gt;master storage]# 
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; [root@k8s-master storage]# &lt;span&gt;cat&lt;/span&gt; configmap/&lt;span&gt;game.properties    # 涉及文件1
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; enemies=&lt;span&gt;aliens
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; lives=&lt;span&gt;3&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; enemies.cheat=&lt;span&gt;true&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; enemies.cheat.level=&lt;span&gt;noGoodRotten
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; secret.code.passphrase=&lt;span&gt;UUDDLRLRBABAs
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; secret.code.allowed=&lt;span&gt;true&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; secret.code.lives=&lt;span&gt;30&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; [root@k8s-&lt;span&gt;master storage]# 
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; [root@k8s-master storage]# &lt;span&gt;cat&lt;/span&gt; configmap/&lt;span&gt;ui.properties   # 涉及文件2
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; color.good=&lt;span&gt;purple
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; color.bad=&lt;span&gt;yellow
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; allow.textmode=&lt;span&gt;true&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; how.&lt;span&gt;nice&lt;/span&gt;.to.look=fairlyNice
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;创建ConfigMap并查看状态&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; [root@k8s-master storage]# kubectl create configmap game-config --from-&lt;span&gt;file&lt;/span&gt;=/root/k8s_practice/storage/&lt;span&gt;configmap
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; configmap/game-&lt;span&gt;config created
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; [root@k8s-&lt;span&gt;master storage]# 
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; [root@k8s-&lt;span&gt;master storage]# kubectl get configmap 
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;NAME          DATA   AGE
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; game-config   &lt;span&gt;2&lt;/span&gt;      14s
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;查看ConfigMap有哪些数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [root@k8s-master storage]# kubectl get configmap -&lt;span&gt;o yaml   ##### 查看方式1
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;apiVersion: v1
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;items:
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; -&lt;span&gt; apiVersion: v1
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;  data:
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     game.properties: |+   ##### 本段最后有一行空格，+&lt;span&gt; 表示保留字符串行末尾的换行
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;       enemies=&lt;span&gt;aliens
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;       lives=&lt;span&gt;3&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;       enemies.cheat=&lt;span&gt;true&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;       enemies.cheat.level=&lt;span&gt;noGoodRotten
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;       secret.code.passphrase=&lt;span&gt;UUDDLRLRBABAs
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;       secret.code.allowed=&lt;span&gt;true&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;       secret.code.lives=&lt;span&gt;30&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     ui.properties: |
&lt;span&gt;16&lt;/span&gt;       color.good=&lt;span&gt;purple
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;       color.bad=&lt;span&gt;yellow
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;       allow.textmode=&lt;span&gt;true&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;       how.&lt;span&gt;nice&lt;/span&gt;.to.look=&lt;span&gt;fairlyNice
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;  kind: ConfigMap
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;  metadata:
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     creationTimestamp: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2020-06-07T06:57:28Z&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;     name: game-&lt;span&gt;config
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    namespace: default
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     resourceVersion: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;889177&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;     selfLink: /api/v1/namespaces/default/configmaps/game-&lt;span&gt;config
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     uid: 6952ac85-ded0-4c5e-89fd-&lt;span&gt;b0c6f0546ecf
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;kind: List
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;metadata:
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;   resourceVersion: &lt;span&gt;&quot;&quot;&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;   selfLink: &lt;span&gt;&quot;&quot;&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt; [root@k8s-&lt;span&gt;master storage]# 
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; [root@k8s-master storage]# kubectl describe configmap game-&lt;span&gt;config   ##### 查看方式2
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; Name:         game-&lt;span&gt;config
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;Namespace:    default
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; Labels:       &amp;lt;none&amp;gt;
&lt;span&gt;37&lt;/span&gt; Annotations:  &amp;lt;none&amp;gt;
&lt;span&gt;38&lt;/span&gt; 
&lt;span&gt;39&lt;/span&gt; &lt;span&gt;Data
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; ====
&lt;span&gt;41&lt;/span&gt; &lt;span&gt;game.properties:
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; ----
&lt;span&gt;43&lt;/span&gt; enemies=&lt;span&gt;aliens
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; lives=&lt;span&gt;3&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt; enemies.cheat=&lt;span&gt;true&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt; enemies.cheat.level=&lt;span&gt;noGoodRotten
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; secret.code.passphrase=&lt;span&gt;UUDDLRLRBABAs
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; secret.code.allowed=&lt;span&gt;true&lt;/span&gt;
&lt;span&gt;49&lt;/span&gt; secret.code.lives=&lt;span&gt;30&lt;/span&gt;
&lt;span&gt;50&lt;/span&gt; 
&lt;span&gt;51&lt;/span&gt; 
&lt;span&gt;52&lt;/span&gt; &lt;span&gt;ui.properties:
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; ----
&lt;span&gt;54&lt;/span&gt; color.good=&lt;span&gt;purple
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; color.bad=&lt;span&gt;yellow
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; allow.textmode=&lt;span&gt;true&lt;/span&gt;
&lt;span&gt;57&lt;/span&gt; how.&lt;span&gt;nice&lt;/span&gt;.to.look=&lt;span&gt;fairlyNice
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; 
&lt;span&gt;59&lt;/span&gt; Events:  &amp;lt;none&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;通过文件创建&quot;&gt;通过文件创建&lt;/h2&gt;
&lt;p&gt;配置文件位置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [root@k8s-master storage]# &lt;span&gt;pwd&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; /root/k8s_practice/&lt;span&gt;storage
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; [root@k8s-master storage]# &lt;span&gt;cat&lt;/span&gt; /root/k8s_practice/storage/configmap/&lt;span&gt;game.properties
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; enemies=&lt;span&gt;aliens
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; lives=&lt;span&gt;3&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; enemies.cheat=&lt;span&gt;true&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; enemies.cheat.level=&lt;span&gt;noGoodRotten
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; secret.code.passphrase=&lt;span&gt;UUDDLRLRBABAs
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; secret.code.allowed=&lt;span&gt;true&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; secret.code.lives=&lt;span&gt;30&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;创建ConfigMap并查看状态&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; [root@k8s-master storage]# kubectl create configmap game-config-&lt;span&gt;2&lt;/span&gt; --from-&lt;span&gt;file&lt;/span&gt;=/root/k8s_practice/storage/configmap/&lt;span&gt;game.properties
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; configmap/game-config-&lt;span&gt;2&lt;/span&gt;&lt;span&gt; created
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; [root@k8s-&lt;span&gt;master storage]# 
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; [root@k8s-master storage]# kubectl get configmap game-config-&lt;span&gt;2&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;NAME            DATA   AGE
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; game-config-&lt;span&gt;2&lt;/span&gt;   &lt;span&gt;1&lt;/span&gt;      29s
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;查看ConfigMap有哪些数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [root@k8s-master storage]# kubectl get configmap game-config-&lt;span&gt;2&lt;/span&gt; -&lt;span&gt;o yaml   ##### 查看方式1
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;apiVersion: v1
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;data:
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;   game.properties: |+   ##### 本段最后有一行空格，+&lt;span&gt; 表示保留字符串行末尾的换行
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     enemies=&lt;span&gt;aliens
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     lives=&lt;span&gt;3&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     enemies.cheat=&lt;span&gt;true&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     enemies.cheat.level=&lt;span&gt;noGoodRotten
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     secret.code.passphrase=&lt;span&gt;UUDDLRLRBABAs
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     secret.code.allowed=&lt;span&gt;true&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     secret.code.lives=&lt;span&gt;30&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;kind: ConfigMap
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;metadata:
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;   creationTimestamp: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2020-06-07T07:05:47Z&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;   name: game-config-&lt;span&gt;2&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;  namespace: default
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;   resourceVersion: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;890437&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;   selfLink: /api/v1/namespaces/default/configmaps/game-config-&lt;span&gt;2&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;   uid: 02d99802-c23f-45ad-b4e1-&lt;span&gt;dea9bcb166d8
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; [root@k8s-&lt;span&gt;master storage]# 
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; [root@k8s-master storage]# kubectl describe configmap game-config-&lt;span&gt;2&lt;/span&gt;&lt;span&gt;    ##### 查看方式2
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; Name:         game-config-&lt;span&gt;2&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;Namespace:    default
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; Labels:       &amp;lt;none&amp;gt;
&lt;span&gt;26&lt;/span&gt; Annotations:  &amp;lt;none&amp;gt;
&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;Data
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; ====
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;game.properties:
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; ----
&lt;span&gt;32&lt;/span&gt; enemies=&lt;span&gt;aliens
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; lives=&lt;span&gt;3&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt; enemies.cheat=&lt;span&gt;true&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt; enemies.cheat.level=&lt;span&gt;noGoodRotten
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; secret.code.passphrase=&lt;span&gt;UUDDLRLRBABAs
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; secret.code.allowed=&lt;span&gt;true&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt; secret.code.lives=&lt;span&gt;30&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt; 
&lt;span&gt;40&lt;/span&gt; 
&lt;span&gt;41&lt;/span&gt; Events:  &amp;lt;none&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;通过命令行创建&quot;&gt;通过命令行创建&lt;/h2&gt;
&lt;p&gt;创建ConfigMap并查看状态&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; [root@k8s-master storage]# &lt;span&gt;pwd&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; /root/k8s_practice/&lt;span&gt;storage
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; [root@k8s-master storage]# kubectl create configmap special-config --from-literal=special.how=very --from-literal=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;special.type=charm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; configmap/special-&lt;span&gt;config created
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; [root@k8s-&lt;span&gt;master storage]# 
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; [root@k8s-master storage]# kubectl get configmap special-&lt;span&gt;config
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;NAME             DATA   AGE
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; special-config   &lt;span&gt;2&lt;/span&gt;      23s
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;查看ConfigMap有哪些数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [root@k8s-master storage]# kubectl get configmap special-config -&lt;span&gt;o yaml    ##### 查看方式1
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;apiVersion: v1
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;data:
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;  special.how: very
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;  special.type: charm
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;kind: ConfigMap
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;metadata:
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;   creationTimestamp: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2020-06-07T09:32:04Z&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;   name: special-&lt;span&gt;config
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;  namespace: default
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;   resourceVersion: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;912702&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;   selfLink: /api/v1/namespaces/default/configmaps/special-&lt;span&gt;config
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;   uid: 76698e78-&lt;span&gt;1380&lt;/span&gt;-&lt;span&gt;4826&lt;/span&gt;-b5ac-&lt;span&gt;d9c81f746eac
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; [root@k8s-&lt;span&gt;master storage]# 
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; [root@k8s-master storage]# kubectl describe configmap special-&lt;span&gt;config    ##### 查看方式2
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; Name:         special-&lt;span&gt;config
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;Namespace:    default
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; Labels:       &amp;lt;none&amp;gt;
&lt;span&gt;19&lt;/span&gt; Annotations:  &amp;lt;none&amp;gt;
&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;Data
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; ====
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;special.how:
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; ----
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;very
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;special.type:
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; ----
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;charm
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; Events:  &amp;lt;none&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;通过yaml文件创建&quot;&gt;通过yaml文件创建&lt;/h2&gt;
&lt;p&gt;yaml文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [root@k8s-master storage]# &lt;span&gt;pwd&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; /root/k8s_practice/&lt;span&gt;storage
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; [root@k8s-master storage]# &lt;span&gt;cat&lt;/span&gt;&lt;span&gt; configmap.yaml 
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;apiVersion: v1
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;kind: ConfigMap
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;metadata:
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;   name: configmap-&lt;span&gt;demo
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;data:
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;  # 类属性键；每一个键都映射到一个简单的值
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;   player_initial_lives: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;   ui_properties_file_name: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;user-interface.properties&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;  #
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;  # 类文件键
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;   game.properties: |
&lt;span&gt;15&lt;/span&gt;     enemy.types=&lt;span&gt;aliens,monsters
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     player.maximum-lives=&lt;span&gt;5&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;   user-interface.properties: |
&lt;span&gt;18&lt;/span&gt;     color.good=&lt;span&gt;purple
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     color.bad=&lt;span&gt;yellow
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     allow.textmode=&lt;span&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;创建ConfigMap并查看状态&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; [root@k8s-master storage]# kubectl apply -&lt;span&gt;f configmap.yaml
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; configmap/configmap-&lt;span&gt;demo created
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; [root@k8s-master storage]# kubectl get configmap configmap-&lt;span&gt;demo
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;NAME             DATA   AGE
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; configmap-demo   &lt;span&gt;4&lt;/span&gt;      2m59s
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;查看ConfigMap有哪些数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [root@k8s-master storage]# kubectl get configmap configmap-demo -&lt;span&gt;o yaml    ##### 查看方式1
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;apiVersion: v1
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;data:
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;   game.properties: |
&lt;span&gt; 5&lt;/span&gt;     enemy.types=&lt;span&gt;aliens,monsters
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     player.maximum-lives=&lt;span&gt;5&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;   player_initial_lives: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;   ui_properties_file_name: user-&lt;span&gt;interface.properties
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;   user-interface.properties: |
&lt;span&gt;10&lt;/span&gt;     color.good=&lt;span&gt;purple
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     color.bad=&lt;span&gt;yellow
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     allow.textmode=&lt;span&gt;true&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;kind: ConfigMap
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;metadata:
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;  annotations:
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     kubectl.kubernetes.io/&lt;span&gt;last&lt;/span&gt;-applied-configuration: |
&lt;span&gt;17&lt;/span&gt;       {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;apiVersion&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;data&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:{&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;game.properties&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;enemy.types=aliens,monsters\nplayer.maximum-lives=5\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;player_initial_lives&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ui_properties_file_name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user-interface.properties&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user-interface.properties&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;color.good=purple\ncolor.bad=yellow\nallow.textmode=true\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;},&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;kind&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ConfigMap&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;metadata&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:{&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;annotations&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:{},&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;configmap-demo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}}
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;   creationTimestamp: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2020-06-07T11:36:46Z&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;   name: configmap-&lt;span&gt;demo
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;  namespace: default
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;   resourceVersion: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;931685&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;   selfLink: /api/v1/namespaces/default/configmaps/configmap-&lt;span&gt;demo
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;   uid: fdad7000-87bd-4b72-be98-&lt;span&gt;40dd8fe6400a
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; [root@k8s-&lt;span&gt;master storage]# 
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; [root@k8s-&lt;span&gt;master storage]# 
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; [root@k8s-master storage]# kubectl describe configmap configmap-&lt;span&gt;demo     ##### 查看方式2
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; Name:         configmap-&lt;span&gt;demo
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;Namespace:    default
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; Labels:       &amp;lt;none&amp;gt;
&lt;span&gt;30&lt;/span&gt; Annotations:  kubectl.kubernetes.io/&lt;span&gt;last&lt;/span&gt;-applied-&lt;span&gt;configuration:
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                 {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;apiVersion&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;data&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:{&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;game.properties&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;enemy.types=aliens,monsters\nplayer.maximum-lives=5\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;player_initial_lives&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ui_proper...&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;Data
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; ====
&lt;span&gt;35&lt;/span&gt; &lt;span&gt;game.properties:
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; ----
&lt;span&gt;37&lt;/span&gt; enemy.types=&lt;span&gt;aliens,monsters
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; player.maximum-lives=&lt;span&gt;5&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt; 
&lt;span&gt;40&lt;/span&gt; &lt;span&gt;player_initial_lives:
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; ----
&lt;span&gt;42&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt; &lt;span&gt;ui_properties_file_name:
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; ----
&lt;span&gt;45&lt;/span&gt; user-&lt;span&gt;interface.properties
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; user-&lt;span&gt;interface.properties:
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; ----
&lt;span&gt;48&lt;/span&gt; color.good=&lt;span&gt;purple
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; color.bad=&lt;span&gt;yellow
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; allow.textmode=&lt;span&gt;true&lt;/span&gt;
&lt;span&gt;51&lt;/span&gt; 
&lt;span&gt;52&lt;/span&gt; Events:  &amp;lt;none&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如何在Pod中使用上述的ConfigMap信息。&lt;/p&gt;
&lt;h2 id=&quot;当前存在的ConfigMap&quot;&gt;当前存在的ConfigMap&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; [root@k8s-&lt;span&gt;master storage]# kubectl get configmap
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;NAME             DATA   AGE
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; configmap-demo   &lt;span&gt;4&lt;/span&gt;&lt;span&gt;      30m
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; game-config      &lt;span&gt;2&lt;/span&gt;&lt;span&gt;      5h9m
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; game-config-&lt;span&gt;2&lt;/span&gt;    &lt;span&gt;1&lt;/span&gt;&lt;span&gt;      5h1m
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; special-config   &lt;span&gt;2&lt;/span&gt;      5m48s
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;使用ConfigMap来替代环境变量&quot;&gt;使用ConfigMap来替代环境变量&lt;/h2&gt;
&lt;p&gt;yaml文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [root@k8s-master storage]# &lt;span&gt;pwd&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; /root/k8s_practice/&lt;span&gt;storage
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; [root@k8s-master storage]# &lt;span&gt;cat&lt;/span&gt;&lt;span&gt; pod_configmap_env.yaml 
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;apiVersion: v1
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;kind: Pod
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;metadata:
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;   name: pod-configmap-&lt;span&gt;env&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;spec:
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;  containers:
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;   -&lt;span&gt; name: myapp
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     image: registry.cn-beijing.aliyuncs.com/google_registry/&lt;span&gt;myapp:v1
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     command: [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/bin/sh&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-c&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;env&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    ### 引用方式1
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;env&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     -&lt;span&gt; name: SPECAIL_HOW_KEY
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;      valueFrom:
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        configMapKeyRef:
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;           name: special-&lt;span&gt;config   ### 这个name的值来自 ConfigMap
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;          key: special.how       ### 这个key的值为需要取值的键
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     -&lt;span&gt; name: SPECAIL_TPYE_KEY
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;      valueFrom:
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        configMapKeyRef:
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;           name: special-&lt;span&gt;config
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;          key: special.type
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    ### 引用方式2
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    envFrom:
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     -&lt;span&gt; configMapRef:
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         name: game-config-&lt;span&gt;2&lt;/span&gt;&lt;span&gt;   ### 这个name的值来自 ConfigMap
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     restartPolicy: Never
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;启动pod并查看状态&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; [root@k8s-master storage]# kubectl apply -&lt;span&gt;f pod_configmap_env.yaml 
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; pod/pod-configmap-&lt;span&gt;env&lt;/span&gt;&lt;span&gt; created
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; [root@k8s-&lt;span&gt;master storage]# 
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; [root@k8s-master storage]# kubectl get pod -&lt;span&gt;o wide
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;NAME                READY   STATUS      RESTARTS   AGE   IP             NODE         NOMINATED NODE   READINESS GATES
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; pod-configmap-&lt;span&gt;env&lt;/span&gt;   &lt;span&gt;0&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;     Completed   &lt;span&gt;0&lt;/span&gt;          6s    &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;2.147&lt;/span&gt;   k8s-node02   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;查看打印日志&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [root@k8s-master storage]# kubectl logs pod-configmap-&lt;span&gt;env&lt;/span&gt; 
&lt;span&gt; 2&lt;/span&gt; MYAPP_SVC_PORT_80_TCP_ADDR=&lt;span&gt;10.98&lt;/span&gt;.&lt;span&gt;57.156&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; KUBERNETES_SERVICE_PORT=&lt;span&gt;443&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; KUBERNETES_PORT=tcp:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;10.96.0.1:443&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; MYAPP_SVC_PORT_80_TCP_PORT=&lt;span&gt;80&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; HOSTNAME=pod-configmap-&lt;span&gt;env&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; SHLVL=&lt;span&gt;1&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; MYAPP_SVC_PORT_80_TCP_PROTO=&lt;span&gt;tcp
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; HOME=/&lt;span&gt;root
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; SPECAIL_HOW_KEY=&lt;span&gt;very  ### 来自ConfigMap
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; game.properties=enemies=&lt;span&gt;aliens  ### 来自ConfigMap
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; lives=&lt;span&gt;3&lt;/span&gt;&lt;span&gt;  ### 来自ConfigMap
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; enemies.cheat=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;  ### 来自ConfigMap
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; enemies.cheat.level=&lt;span&gt;noGoodRotten  ### 来自ConfigMap
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; secret.code.passphrase=&lt;span&gt;UUDDLRLRBABAs  ### 来自ConfigMap
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; secret.code.allowed=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;  ### 来自ConfigMap
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; secret.code.lives=&lt;span&gt;30&lt;/span&gt;&lt;span&gt;  ### 来自ConfigMap
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; SPECAIL_TPYE_KEY=&lt;span&gt;charm  ### 来自ConfigMap
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; MYAPP_SVC_PORT_80_TCP=tcp:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;10.98.57.156:80&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; NGINX_VERSION=&lt;span&gt;1.12&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; KUBERNETES_PORT_443_TCP_ADDR=&lt;span&gt;10.96&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/&lt;span&gt;bin
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; KUBERNETES_PORT_443_TCP_PORT=&lt;span&gt;443&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; KUBERNETES_PORT_443_TCP_PROTO=&lt;span&gt;tcp
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; MYAPP_SVC_SERVICE_HOST=&lt;span&gt;10.98&lt;/span&gt;.&lt;span&gt;57.156&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt; KUBERNETES_SERVICE_PORT_HTTPS=&lt;span&gt;443&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt; KUBERNETES_PORT_443_TCP=tcp:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;10.96.0.1:443&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt; PWD=/
&lt;span&gt;31&lt;/span&gt; KUBERNETES_SERVICE_HOST=&lt;span&gt;10.96&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt; MYAPP_SVC_SERVICE_PORT=&lt;span&gt;80&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt; MYAPP_SVC_PORT=tcp:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;10.98.57.156:80&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;使用ConfigMap设置命令行参数&quot;&gt;使用ConfigMap设置命令行参数&lt;/h2&gt;
&lt;p&gt;yaml文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [root@k8s-master storage]# &lt;span&gt;pwd&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; /root/k8s_practice/&lt;span&gt;storage
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; [root@k8s-master storage]# &lt;span&gt;cat&lt;/span&gt;&lt;span&gt; pod_configmap_cmd.yaml 
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;apiVersion: v1
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;kind: Pod
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;metadata:
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;   name: pod-configmap-&lt;span&gt;cmd
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;spec:
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;  containers:
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;   -&lt;span&gt; name: myapp
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     image: registry.cn-beijing.aliyuncs.com/google_registry/&lt;span&gt;myapp:v1
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     command: [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/bin/sh&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-c&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;echo \&quot;===$(SPECAIL_HOW_KEY)===$(SPECAIL_TPYE_KEY)===\&quot;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;env&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     -&lt;span&gt; name: SPECAIL_HOW_KEY
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;      valueFrom:
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        configMapKeyRef:
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;           name: special-&lt;span&gt;config
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;          key: special.how
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     -&lt;span&gt; name: SPECAIL_TPYE_KEY
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;      valueFrom:
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        configMapKeyRef:
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;           name: special-&lt;span&gt;config
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;          key: special.type
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;   restartPolicy: Never
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;启动pod并查看状态&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; [root@k8s-master storage]# kubectl apply -&lt;span&gt;f pod_configmap_cmd.yaml 
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; pod/pod-configmap-&lt;span&gt;cmd created
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; [root@k8s-&lt;span&gt;master storage]# 
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; [root@k8s-master storage]# kubectl get pod -&lt;span&gt;o wide
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;NAME                READY   STATUS      RESTARTS   AGE   IP             NODE         NOMINATED NODE   READINESS GATES
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; pod-configmap-cmd   &lt;span&gt;0&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;     Completed   &lt;span&gt;0&lt;/span&gt;          5s    &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;4.125&lt;/span&gt;   k8s-node01   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;查看打印日志&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; [root@k8s-master storage]# kubectl logs pod-configmap-&lt;span&gt;cmd
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; ===very===charm===
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;通过数据卷插件使用ConfigMap【推荐】&quot;&gt;通过数据卷插件使用ConfigMap【推荐】&lt;/h2&gt;
&lt;p&gt;在数据卷里面使用ConfigMap，最基本的就是将文件填入数据卷，在这个文件中，键就是文件名【第一层级的键】，键值就是文件内容。&lt;/p&gt;
&lt;p&gt;yaml文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [root@k8s-master storage]# &lt;span&gt;pwd&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; /root/k8s_practice/&lt;span&gt;storage
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; [root@k8s-master storage]# &lt;span&gt;cat&lt;/span&gt;&lt;span&gt; pod_configmap_volume.yaml 
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;apiVersion: v1
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;kind: Pod
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;metadata:
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;   name: pod-configmap-&lt;span&gt;volume
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;spec:
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;  containers:
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;   -&lt;span&gt; name: myapp
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     image: registry.cn-beijing.aliyuncs.com/google_registry/&lt;span&gt;myapp:v1
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     #command: [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/bin/sh&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-c&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ls -l /etc/config/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     command: [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/bin/sh&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-c&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sleep 600&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    volumeMounts:
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     - name: config-&lt;span&gt;volume
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;       mountPath: /etc/&lt;span&gt;config
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;  volumes:
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;   - name: config-&lt;span&gt;volume
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    configMap:
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;       name: configmap-&lt;span&gt;demo
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;   restartPolicy: Never
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;启动pod并查看状态&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; [root@k8s-master storage]# kubectl apply -&lt;span&gt;f pod_configmap_volume.yaml 
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; pod/pod-configmap-&lt;span&gt;volume created
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; [root@k8s-&lt;span&gt;master storage]#
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; [root@k8s-master storage]# kubectl get pod -&lt;span&gt;o wide
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;NAME                   READY   STATUS    RESTARTS   AGE   IP             NODE         NOMINATED NODE   READINESS GATES
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; pod-configmap-volume   &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;     Running   &lt;span&gt;0&lt;/span&gt;          5s    &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;2.153&lt;/span&gt;   k8s-node02   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;进入pod并查看&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [root@k8s-master storage]# kubectl exec -it pod-configmap-volume &lt;span&gt;sh&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; / # &lt;span&gt;ls&lt;/span&gt; /etc/&lt;span&gt;config
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; game.properties            player_initial_lives       ui_properties_file_name    user-&lt;span&gt;interface.properties
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; /&lt;span&gt; # 
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; /&lt;span&gt; # 
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; /&lt;span&gt; # 
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; / # &lt;span&gt;cat&lt;/span&gt; /etc/config/&lt;span&gt;player_initial_lives 
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;/&lt;span&gt; # 
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; /&lt;span&gt; # 
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; /&lt;span&gt; # 
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; / # &lt;span&gt;cat&lt;/span&gt; /etc/config/&lt;span&gt;ui_properties_file_name 
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; user-interface.properties/&lt;span&gt; # 
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; /&lt;span&gt; # 
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; /&lt;span&gt; # 
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; / # &lt;span&gt;cat&lt;/span&gt; /etc/config/&lt;span&gt;game.properties 
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; enemy.types=&lt;span&gt;aliens,monsters
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; player.maximum-lives=&lt;span&gt;5&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; /&lt;span&gt; # 
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; /&lt;span&gt; # 
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; / # &lt;span&gt;cat&lt;/span&gt; /etc/config/user-&lt;span&gt;interface.properties 
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; color.good=&lt;span&gt;purple
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; color.bad=&lt;span&gt;yellow
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; allow.textmode=&lt;span&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2 id=&quot;准备工作&quot;&gt;准备工作&lt;/h2&gt;
&lt;p&gt;yaml文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [root@k8s-master storage]# &lt;span&gt;pwd&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; /root/k8s_practice/&lt;span&gt;storage
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; [root@k8s-master storage]# &lt;span&gt;cat&lt;/span&gt;&lt;span&gt; pod_configmap_hot.yaml 
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;apiVersion: v1
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;kind: ConfigMap
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;metadata:
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;   name: log-&lt;span&gt;config
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;  namespace: default
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;data:
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;  log_level: INFO
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; ---
&lt;span&gt;12&lt;/span&gt; apiVersion: apps/&lt;span&gt;v1
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;kind: Deployment
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;metadata:
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;   name: myapp-&lt;span&gt;deploy
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;  namespace: default
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;spec:
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;   replicas: &lt;span&gt;2&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;  selector:
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    matchLabels:
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;      app: myapp
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;      release: v1
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;  template:
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    metadata:
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;      labels:
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        app: myapp
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        release: v1
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;env&lt;/span&gt;&lt;span&gt;: test
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;    spec:
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;      containers:
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;       -&lt;span&gt; name: myapp
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         image: registry.cn-beijing.aliyuncs.com/google_registry/&lt;span&gt;myapp:v1
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        imagePullPolicy: IfNotPresent
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;        ports:
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         - containerPort: &lt;span&gt;80&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt; &lt;span&gt;        volumeMounts:
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         - name: config-&lt;span&gt;volume
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;           mountPath: /etc/&lt;span&gt;config
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;      volumes:
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;       - name: config-&lt;span&gt;volume
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;        configMap:
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;           name: log-config
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;应用yaml文件并查看状态&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [root@k8s-master storage]# kubectl apply -&lt;span&gt;f pod_configmap_hot.yaml 
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; configmap/log-&lt;span&gt;config created
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; deployment.apps/myapp-&lt;span&gt;deploy created
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; [root@k8s-&lt;span&gt;master storage]# 
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; [root@k8s-master storage]# kubectl get configmap log-&lt;span&gt;config
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;NAME         DATA   AGE
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; log-config   &lt;span&gt;1&lt;/span&gt;&lt;span&gt;      21s
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; [root@k8s-&lt;span&gt;master storage]# 
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; [root@k8s-master storage]# kubectl get pod -&lt;span&gt;o wide
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;NAME                           READY   STATUS    RESTARTS   AGE   IP             NODE         NOMINATED NODE   READINESS GATES
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; myapp-deploy-58ff9c997-drhwk   &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;     Running   &lt;span&gt;0&lt;/span&gt;          30s   &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;2.154&lt;/span&gt;   k8s-node02   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
&lt;span&gt;12&lt;/span&gt; myapp-deploy-58ff9c997-n68j2   &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;     Running   &lt;span&gt;0&lt;/span&gt;          30s   &lt;span&gt;10.244&lt;/span&gt;.&lt;span&gt;4.126&lt;/span&gt;   k8s-node01   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;查看ConfigMap信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [root@k8s-master storage]# kubectl get configmap log-config -&lt;span&gt;o yaml
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;apiVersion: v1
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;data:
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;  log_level: INFO
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;kind: ConfigMap
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;metadata:
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;  annotations:
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     kubectl.kubernetes.io/&lt;span&gt;last&lt;/span&gt;-applied-configuration: |
&lt;span&gt; 9&lt;/span&gt;       {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;apiVersion&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;data&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:{&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;log_level&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;INFO&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;},&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;kind&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ConfigMap&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;metadata&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:{&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;annotations&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:{},&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;log-config&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}}
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;   creationTimestamp: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2020-06-07T16:08:11Z&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;   name: log-&lt;span&gt;config
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;  namespace: default
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;   resourceVersion: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;971348&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;   selfLink: /api/v1/namespaces/default/configmaps/log-&lt;span&gt;config
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;   uid: 7e78e1d7-12de-&lt;span&gt;4601&lt;/span&gt;-&lt;span&gt;9915&lt;/span&gt;-cefbc96ca305
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;查看pod中的ConfigMap信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; [root@k8s-master storage]# kubectl exec -it myapp-deploy-58ff9c997-drhwk -- &lt;span&gt;cat&lt;/span&gt; /etc/config/&lt;span&gt;log_level
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; INFO
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;热更新&quot;&gt;热更新&lt;/h2&gt;
&lt;p&gt;修改ConfigMap&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [root@k8s-master storage]# kubectl edit configmap log-&lt;span&gt;config     ### 将 INFO 改为了 DEBUG
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; # Please edit the &lt;span&gt;object&lt;/span&gt; below. Lines beginning with a &lt;span&gt;'&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; will be ignored,
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; # and an empty &lt;span&gt;file&lt;/span&gt; will abort the edit. If an error occurs &lt;span&gt;while&lt;/span&gt; saving this &lt;span&gt;file&lt;/span&gt;&lt;span&gt; will be
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;# reopened with the relevant failures.
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;#
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;apiVersion: v1
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;data:
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;  log_level: DEBUG
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;kind: ConfigMap
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;metadata:
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;  annotations:
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     kubectl.kubernetes.io/&lt;span&gt;last&lt;/span&gt;-applied-configuration: |
&lt;span&gt;13&lt;/span&gt;       {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;apiVersion&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;data&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:{&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;log_level&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DEBUG&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;},&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;kind&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ConfigMap&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;metadata&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:{&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;annotations&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:{},&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;log-config&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}}
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;   creationTimestamp: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2020-06-07T16:08:11Z&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;   name: log-&lt;span&gt;config
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;  namespace: default
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;   resourceVersion: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;971348&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;   selfLink: /api/v1/namespaces/default/configmaps/log-&lt;span&gt;config
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;   uid: 7e78e1d7-12de-&lt;span&gt;4601&lt;/span&gt;-&lt;span&gt;9915&lt;/span&gt;-cefbc96ca305
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;查看ConfigMap信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [root@k8s-master storage]# kubectl get configmap log-config -&lt;span&gt;o yaml
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;apiVersion: v1
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;data:
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;  log_level: DEBUG
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;kind: ConfigMap
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;metadata:
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;  annotations:
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     kubectl.kubernetes.io/&lt;span&gt;last&lt;/span&gt;-applied-configuration: |
&lt;span&gt; 9&lt;/span&gt;       {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;apiVersion&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;data&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:{&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;log_level&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DEBUG&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;},&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;kind&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ConfigMap&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;metadata&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:{&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;annotations&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:{},&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;log-config&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}}
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;   creationTimestamp: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2020-06-07T16:08:11Z&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;   name: log-&lt;span&gt;config
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;  namespace: default
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;   resourceVersion: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;972893&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;   selfLink: /api/v1/namespaces/default/configmaps/log-&lt;span&gt;config
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;   uid: 7e78e1d7-12de-&lt;span&gt;4601&lt;/span&gt;-&lt;span&gt;9915&lt;/span&gt;-cefbc96ca305
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;稍后10秒左右，再次查看pod中的ConfigMap信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; [root@k8s-master storage]# kubectl exec -it myapp-deploy-58ff9c997-drhwk -- &lt;span&gt;cat&lt;/span&gt; /etc/config/&lt;span&gt;log_level
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; DEBUG
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;由此可见，完成了一次热更新&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;1、&lt;a href=&quot;http://www.zhangblog.com/2020/05/17/yaml01/&quot;&gt;YAML 语言教程与使用案例&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2、&lt;a href=&quot;http://www.zhangblog.com/2020/08/05/kubernetes04/&quot;&gt;Kubernetes K8S之通过yaml创建pod与pod文件常用字段详解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3、&lt;a href=&quot;http://www.zhangblog.com/2020/09/28/kubernetes17/&quot;&gt;Kubernetes K8S之存储Secret详解&lt;/a&gt;&lt;/p&gt;

&lt;hr/&gt;

&lt;p&gt;———END———&lt;br/&gt;如果觉得不错就关注下呗 (-^O^-) ！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1395193/202010/1395193-20201015000147429-127213341.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 14 Oct 2020 16:03:00 +0000</pubDate>
<dc:creator>踏歌行666</dc:creator>
<og:description>K8S之存储ConfigMap概述与说明，并详解常用ConfigMap示例</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhanglianghhh/p/13818190.html</dc:identifier>
</item>
<item>
<title>从面试角度学完 Kafka - MageByte-借来方向</title>
<link>http://www.cnblogs.com/WeaRang/p/13818011.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/WeaRang/p/13818011.html</guid>
<description>&lt;p&gt;Kafka 是一个优秀的分布式消息中间件，许多系统中都会使用到 Kafka 来做消息通信。对分布式消息系统的了解和使用几乎成为一个后台开发人员必备的技能。今天就从常见的 Kafka 面试题入手，和大家聊聊 Kafka 的那些事儿。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;160.8564011477&quot;&gt;
&lt;p&gt;Kafka 是一个优秀的分布式消息中间件，许多系统中都会使用到 Kafka 来做消息通信。对分布式消息系统的了解和使用几乎成为一个后台开发人员必备的技能。今天&lt;code&gt;码哥字节&lt;/code&gt;就从常见的 Kafka 面试题入手，和大家聊聊 Kafka 的那些事儿。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://magebyte.oss-cn-shenzhen.aliyuncs.com/kafka/mind.png&quot; alt=&quot;思维导图&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;讲一讲分布式消息中间件&quot;&gt;讲一讲分布式消息中间件&lt;/h2&gt;
&lt;h3 id=&quot;问题&quot;&gt;问题&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;什么是分布式消息中间件？&lt;/li&gt;
&lt;li&gt;消息中间件的作用是什么？&lt;/li&gt;
&lt;li&gt;消息中间件的使用场景是什么？&lt;/li&gt;
&lt;li&gt;消息中间件选型？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://magebyte.oss-cn-shenzhen.aliyuncs.com/kafka/mq.png&quot; alt=&quot;消息队列&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;分布式消息是一种通信机制，和 RPC、HTTP、RMI 等不一样，消息中间件采用分布式中间代理的方式进行通信。如图所示，采用了消息中间件之后，上游业务系统发送消息，先存储在消息中间件，然后由消息中间件将消息分发到对应的业务模块应用（分布式生产者 - 消费者模式）。这种异步的方式，减少了服务之间的耦合程度。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://magebyte.oss-cn-shenzhen.aliyuncs.com/kafka/mq-service.png&quot; alt=&quot;架构&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;定义消息中间件：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;利用高效可靠的消息传递机制进行平台无关的数据交流&lt;/li&gt;
&lt;li&gt;基于数据通信，来进行分布式系统的集成&lt;/li&gt;
&lt;li&gt;通过提供消息传递和消息排队模型，可以在分布式环境下扩展进程间的通信&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在系统架构中引用额外的组件，必然提高系统的架构复杂度和运维的难度，那么&lt;strong&gt;在系统中使用分布式消息中间件有什么优势呢？消息中间件在系统中起的作用又是什么呢？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;解耦&lt;/li&gt;
&lt;li&gt;冗余（存储）&lt;/li&gt;
&lt;li&gt;扩展性&lt;/li&gt;
&lt;li&gt;削峰&lt;/li&gt;
&lt;li&gt;可恢复性&lt;/li&gt;
&lt;li&gt;顺序保证&lt;/li&gt;
&lt;li&gt;缓冲&lt;/li&gt;
&lt;li&gt;异步通信&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;面试时，面试官经常会关心面试者对开源组件的选型能力，这既可以考验面试者知识的广度，也可以考验面试者对某类系统的知识的认识深度，而且也可以看出面试者对系统整体把握和系统架构设计的能力。开源分布式消息系统有很多，不同的消息系统的特性也不一样，选择怎样的消息系统，不仅需要对各消息系统有一定的了解，也需要对自身系统需求有清晰的认识。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;下面是常见的几种分布式消息系统的对比：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://magebyte.oss-cn-shenzhen.aliyuncs.com/kafka/comp.jpeg&quot; alt=&quot;选择&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;答案关键字&quot;&gt;答案关键字&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;什么是分布式消息中间件？通信，队列，分布式，生产消费者模式。&lt;/li&gt;
&lt;li&gt;消息中间件的作用是什么？ 解耦、峰值处理、异步通信、缓冲。&lt;/li&gt;
&lt;li&gt;消息中间件的使用场景是什么？ 异步通信，消息存储处理。&lt;/li&gt;
&lt;li&gt;消息中间件选型？语言，协议、HA、数据可靠性、性能、事务、生态、简易、推拉模式。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;kafka-基本概念和架构&quot;&gt;Kafka 基本概念和架构&lt;/h2&gt;
&lt;h3 id=&quot;问题-2&quot;&gt;问题&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;简单讲下 Kafka 的架构？&lt;/li&gt;
&lt;li&gt;Kafka 是推模式还是拉模式，推拉的区别是什么？&lt;/li&gt;
&lt;li&gt;Kafka 如何广播消息？&lt;/li&gt;
&lt;li&gt;Kafka 的消息是否是有序的？&lt;/li&gt;
&lt;li&gt;Kafka 是否支持读写分离？&lt;/li&gt;
&lt;li&gt;Kafka 如何保证数据高可用？&lt;/li&gt;
&lt;li&gt;Kafka 中 zookeeper 的作用？&lt;/li&gt;
&lt;li&gt;是否支持事务？&lt;/li&gt;
&lt;li&gt;分区数是否可以减少？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Kafka 架构中的一般概念：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://magebyte.oss-cn-shenzhen.aliyuncs.com/kafka/arch.png&quot; alt=&quot;架构&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Producer：生产者，也就是发送消息的一方。生产者负责创建消息，然后将其发送到 Kafka。&lt;/li&gt;
&lt;li&gt;Consumer：消费者，也就是接受消息的一方。消费者连接到 Kafka 上并接收消息，进而进行相应的业务逻辑处理。&lt;/li&gt;
&lt;li&gt;Consumer Group：一个消费者组可以包含一个或多个消费者。使用多分区 + 多消费者方式可以极大提高数据下游的处理速度，同一消费组中的消费者不会重复消费消息，同样的，不同消费组中的消费者消息消息时互不影响。Kafka 就是通过消费组的方式来实现消息 P2P 模式和广播模式。&lt;/li&gt;
&lt;li&gt;Broker：服务代理节点。Broker 是 Kafka 的服务节点，即 Kafka 的服务器。&lt;/li&gt;
&lt;li&gt;Topic：Kafka 中的消息以 Topic 为单位进行划分，生产者将消息发送到特定的 Topic，而消费者负责订阅 Topic 的消息并进行消费。&lt;/li&gt;
&lt;li&gt;Partition：Topic 是一个逻辑的概念，它可以细分为多个分区，每个分区只属于单个主题。同一个主题下不同分区包含的消息是不同的，分区在存储层面可以看作一个可追加的日志（Log）文件，消息在被追加到分区日志文件的时候都会分配一个特定的偏移量（offset）。&lt;/li&gt;
&lt;li&gt;Offset：offset 是消息在分区中的唯一标识，Kafka 通过它来保证消息在分区内的顺序性，不过 offset 并不跨越分区，也就是说，Kafka 保证的是分区有序性而不是主题有序性。&lt;/li&gt;
&lt;li&gt;Replication：副本，是 Kafka 保证数据高可用的方式，Kafka 同一 Partition 的数据可以在多 Broker 上存在多个副本，通常只有主副本对外提供读写服务，当主副本所在 broker 崩溃或发生网络一场，Kafka 会在 Controller 的管理下会重新选择新的 Leader 副本对外提供读写服务。&lt;/li&gt;
&lt;li&gt;Record： 实际写入 Kafka 中并可以被读取的消息记录。每个 record 包含了 key、value 和 timestamp。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Kafka Topic Partitions Layout&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://magebyte.oss-cn-shenzhen.aliyuncs.com/kafka/kafka-topic.jpeg&quot; alt=&quot;主题&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Kafka 将 Topic 进行分区，分区可以并发读写。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Kafka Consumer Offset&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://magebyte.oss-cn-shenzhen.aliyuncs.com/kafka/offset.png&quot; alt=&quot;consumer offset&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;zookeeper&quot;&gt;zookeeper&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://magebyte.oss-cn-shenzhen.aliyuncs.com/kafka/zookeeper.png&quot; alt=&quot;zookeeper&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Broker 注册：Broker 是分布式部署并且之间相互独立，Zookeeper 用来管理注册到集群的所有 Broker 节点。&lt;/li&gt;
&lt;li&gt;Topic 注册： 在 Kafka 中，同一个 Topic 的消息会被分成多个分区并将其分布在多个 Broker 上，这些分区信息及与 Broker 的对应关系也都是由 Zookeeper 在维护&lt;/li&gt;
&lt;li&gt;生产者负载均衡：由于同一个 Topic 消息会被分区并将其分布在多个 Broker 上，因此，生产者需要将消息合理地发送到这些分布式的 Broker 上。&lt;/li&gt;
&lt;li&gt;消费者负载均衡：与生产者类似，Kafka 中的消费者同样需要进行负载均衡来实现多个消费者合理地从对应的 Broker 服务器上接收消息，每个消费者分组包含若干消费者，每条消息都只会发送给分组中的一个消费者，不同的消费者分组消费自己特定的 Topic 下面的消息，互不干扰。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;答案关键字-2&quot;&gt;答案关键字&lt;/h3&gt;
&lt;ul&gt;&lt;li readability=&quot;-2&quot;&gt;简单讲下 Kafka 的架构？
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Producer、Consumer、Consumer Group、Topic、Partition&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;Kafka 是推模式还是拉模式，推拉的区别是什么？
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Kafka Producer 向 Broker 发送消息使用 Push 模式，Consumer 消费采用的 Pull 模式。拉取模式，让 consumer 自己管理 offset，可以提供读取性能&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;Kafka 如何广播消息？
&lt;blockquote&gt;
&lt;p&gt;Consumer group&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;Kafka 的消息是否是有序的？
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Topic 级别无序，Partition 有序&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;Kafka 是否支持读写分离？
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;不支持，只有 Leader 对外提供读写服务&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;Kafka 如何保证数据高可用？
&lt;blockquote&gt;
&lt;p&gt;副本，ack，HW&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;Kafka 中 zookeeper 的作用？
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;集群管理，元数据管理&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;是否支持事务？
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;0.11 后支持事务，可以实现”exactly once“&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;分区数是否可以减少？
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;不可以，会丢失数据&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;kafka-使用&quot;&gt;Kafka 使用&lt;/h2&gt;
&lt;h3 id=&quot;问题-3&quot;&gt;问题&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;Kafka 有哪些命令行工具？你用过哪些？&lt;/li&gt;
&lt;li&gt;Kafka Producer 的执行过程？&lt;/li&gt;
&lt;li&gt;Kafka Producer 有哪些常见配置？&lt;/li&gt;
&lt;li&gt;如何让 Kafka 的消息有序？&lt;/li&gt;
&lt;li&gt;Producer 如何保证数据发送不丢失？&lt;/li&gt;
&lt;li&gt;如何提升 Producer 的性能？&lt;/li&gt;
&lt;li&gt;如果同一 group 下 consumer 的数量大于 part 的数量，kafka 如何处理？&lt;/li&gt;
&lt;li&gt;Kafka Consumer 是否是线程安全的？&lt;/li&gt;
&lt;li&gt;讲一下你使用 Kafka Consumer 消费消息时的线程模型，为何如此设计？&lt;/li&gt;
&lt;li&gt;Kafka Consumer 的常见配置？&lt;/li&gt;
&lt;li&gt;Consumer 什么时候会被踢出集群？&lt;/li&gt;
&lt;li&gt;当有 Consumer 加入或退出时，Kafka 会作何反应？&lt;/li&gt;
&lt;li&gt;什么是 Rebalance，何时会发生 Rebalance？&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;命令行工具&quot;&gt;命令行工具&lt;/h3&gt;
&lt;p&gt;Kafka 的命令行工具在 Kafka 包的&lt;code&gt;/bin&lt;/code&gt;目录下，主要包括服务和集群管理脚本，配置脚本，信息查看脚本，Topic 脚本，客户端脚本等。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;kafka-configs.sh： 配置管理脚本&lt;/li&gt;
&lt;li&gt;kafka-console-consumer.sh： kafka 消费者控制台&lt;/li&gt;
&lt;li&gt;kafka-console-producer.sh： kafka 生产者控制台&lt;/li&gt;
&lt;li&gt;kafka-consumer-groups.sh： kafka 消费者组相关信息&lt;/li&gt;
&lt;li&gt;kafka-delete-records.sh： 删除低水位的日志文件&lt;/li&gt;
&lt;li&gt;kafka-log-dirs.sh：kafka 消息日志目录信息&lt;/li&gt;
&lt;li&gt;kafka-mirror-maker.sh： 不同数据中心 kafka 集群复制工具&lt;/li&gt;
&lt;li&gt;kafka-preferred-replica-election.sh： 触发 preferred replica 选举&lt;/li&gt;
&lt;li&gt;kafka-producer-perf-test.sh：kafka 生产者性能测试脚本&lt;/li&gt;
&lt;li&gt;kafka-reassign-partitions.sh： 分区重分配脚本&lt;/li&gt;
&lt;li&gt;kafka-replica-verification.sh： 复制进度验证脚本&lt;/li&gt;
&lt;li&gt;kafka-server-start.sh： 启动 kafka 服务&lt;/li&gt;
&lt;li&gt;kafka-server-stop.sh： 停止 kafka 服务&lt;/li&gt;
&lt;li&gt;kafka-topics.sh：topic 管理脚本&lt;/li&gt;
&lt;li&gt;kafka-verifiable-consumer.sh： 可检验的 kafka 消费者&lt;/li&gt;
&lt;li&gt;kafka-verifiable-producer.sh： 可检验的 kafka 生产者&lt;/li&gt;
&lt;li&gt;zookeeper-server-start.sh： 启动 zk 服务&lt;/li&gt;
&lt;li&gt;zookeeper-server-stop.sh： 停止 zk 服务&lt;/li&gt;
&lt;li&gt;zookeeper-shell.sh：zk 客户端&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们通常可以使用&lt;code&gt;kafka-console-consumer.sh&lt;/code&gt;和&lt;code&gt;kafka-console-producer.sh&lt;/code&gt;脚本来测试 Kafka 生产和消费，&lt;code&gt;kafka-consumer-groups.sh&lt;/code&gt;可以查看和管理集群中的 Topic，&lt;code&gt;kafka-topics.sh&lt;/code&gt;通常用于查看 Kafka 的消费组情况。&lt;/p&gt;
&lt;h3 id=&quot;kafka-producer&quot;&gt;Kafka Producer&lt;/h3&gt;
&lt;p&gt;Kafka producer 的正常生产逻辑包含以下几个步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;配置生产者客户端参数常见生产者实例。&lt;/li&gt;
&lt;li&gt;构建待发送的消息。&lt;/li&gt;
&lt;li&gt;发送消息。&lt;/li&gt;
&lt;li&gt;关闭生产者实例。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Producer 发送消息的过程如下图所示，需要经过&lt;code&gt;拦截器&lt;/code&gt;，&lt;code&gt;序列化器&lt;/code&gt;和&lt;code&gt;分区器&lt;/code&gt;，最终由&lt;code&gt;累加器&lt;/code&gt;批量发送至 Broker。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://magebyte.oss-cn-shenzhen.aliyuncs.com/kafka/producer.png&quot; alt=&quot;producer&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Kafka Producer 需要以下必要参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;bootstrap.server： 指定 Kafka 的 Broker 的地址&lt;/li&gt;
&lt;li&gt;key.serializer： key 序列化器&lt;/li&gt;
&lt;li&gt;value.serializer： value 序列化器&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;常见参数：&lt;/p&gt;
&lt;h3 id=&quot;kafka-consumer&quot;&gt;Kafka Consumer&lt;/h3&gt;
&lt;p&gt;Kafka 有消费组的概念，每个消费者只能消费所分配到的分区的消息，每一个分区只能被一个消费组中的一个消费者所消费，所以同一个消费组中消费者的数量如果超过了分区的数量，将会出现有些消费者分配不到消费的分区。消费组与消费者关系如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://magebyte.oss-cn-shenzhen.aliyuncs.com/kafka/consumer-group.png&quot; alt=&quot;consumer group&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Kafka Consumer Client 消费消息通常包含以下步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;配置客户端，创建消费者&lt;/li&gt;
&lt;li&gt;订阅主题&lt;/li&gt;
&lt;li&gt;拉去消息并消费&lt;/li&gt;
&lt;li&gt;提交消费位移&lt;/li&gt;
&lt;li&gt;关闭消费者实例&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://magebyte.oss-cn-shenzhen.aliyuncs.com/kafka/consumer.png&quot; alt=&quot;过程&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为 Kafka 的 Consumer 客户端是线程不安全的，为了保证线程安全，并提升消费性能，可以在 Consumer 端采用类似 Reactor 的线程模型来消费数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://magebyte.oss-cn-shenzhen.aliyuncs.com/kafka/consumer-thread.png&quot; alt=&quot;消费模型&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;kafka-consumer-参数&quot;&gt;Kafka consumer 参数&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;bootstrap.servers： 连接 broker 地址，&lt;code&gt;host：port&lt;/code&gt; 格式。&lt;/li&gt;
&lt;li&gt;group.id： 消费者隶属的消费组。&lt;/li&gt;
&lt;li&gt;key.deserializer： 与生产者的&lt;code&gt;key.serializer&lt;/code&gt;对应，key 的反序列化方式。&lt;/li&gt;
&lt;li&gt;value.deserializer： 与生产者的&lt;code&gt;value.serializer&lt;/code&gt;对应，value 的反序列化方式。&lt;/li&gt;
&lt;li&gt;session.timeout.ms： coordinator 检测失败的时间。默认 10s 该参数是 Consumer Group 主动检测 （组内成员 comsummer) 崩溃的时间间隔，类似于心跳过期时间。&lt;/li&gt;
&lt;li&gt;auto.offset.reset： 该属性指定了消费者在读取一个没有偏移量后者偏移量无效（消费者长时间失效当前的偏移量已经过时并且被删除了）的分区的情况下，应该作何处理，默认值是 latest，也就是从最新记录读取数据（消费者启动之后生成的记录），另一个值是 earliest，意思是在偏移量无效的情况下，消费者从起始位置开始读取数据。&lt;/li&gt;
&lt;li&gt;enable.auto.commit： 否自动提交位移，如果为&lt;code&gt;false&lt;/code&gt;，则需要在程序中手动提交位移。对于精确到一次的语义，最好手动提交位移&lt;/li&gt;
&lt;li&gt;fetch.max.bytes： 单次拉取数据的最大字节数量&lt;/li&gt;
&lt;li&gt;max.poll.records： 单次 poll 调用返回的最大消息数，如果处理逻辑很轻量，可以适当提高该值。 但是&lt;code&gt;max.poll.records&lt;/code&gt;条数据需要在在 session.timeout.ms 这个时间内处理完 。默认值为 500&lt;/li&gt;
&lt;li&gt;request.timeout.ms： 一次请求响应的最长等待时间。如果在超时时间内未得到响应，kafka 要么重发这条消息，要么超过重试次数的情况下直接置为失败。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;kafka-rebalance&quot;&gt;Kafka Rebalance&lt;/h4&gt;
&lt;p&gt;rebalance 本质上是一种协议，规定了一个 consumer group 下的所有 consumer 如何达成一致来分配订阅 topic 的每个分区。比如某个 group 下有 20 个 consumer，它订阅了一个具有 100 个分区的 topic。正常情况下，Kafka 平均会为每个 consumer 分配 5 个分区。这个分配的过程就叫 rebalance。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么时候 rebalance？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这也是经常被提及的一个问题。rebalance 的触发条件有三种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;组成员发生变更（新 consumer 加入组、已有 consumer 主动离开组或已有 consumer 崩溃了——这两者的区别后面会谈到）&lt;/li&gt;
&lt;li&gt;订阅主题数发生变更&lt;/li&gt;
&lt;li&gt;订阅主题的分区数发生变更&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;如何进行组内分区分配？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Kafka 默认提供了两种分配策略：Range 和 Round-Robin。当然 Kafka 采用了可插拔式的分配策略，你可以创建自己的分配器以实现不同的分配策略。&lt;/p&gt;
&lt;h3 id=&quot;答案关键字-3&quot;&gt;答案关键字&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;Kafka 有哪些命令行工具？你用过哪些？&lt;code&gt;/bin&lt;/code&gt;目录，管理 kafka 集群、管理 topic、生产和消费 kafka&lt;/li&gt;
&lt;li&gt;Kafka Producer 的执行过程？拦截器，序列化器，分区器和累加器&lt;/li&gt;
&lt;li&gt;Kafka Producer 有哪些常见配置？broker 配置，ack 配置，网络和发送参数，压缩参数，ack 参数&lt;/li&gt;
&lt;li&gt;如何让 Kafka 的消息有序？Kafka 在 Topic 级别本身是无序的，只有 partition 上才有序，所以为了保证处理顺序，可以自定义分区器，将需顺序处理的数据发送到同一个 partition&lt;/li&gt;
&lt;li&gt;Producer 如何保证数据发送不丢失？ack 机制，重试机制&lt;/li&gt;
&lt;li&gt;如何提升 Producer 的性能？批量，异步，压缩&lt;/li&gt;
&lt;li&gt;如果同一 group 下 consumer 的数量大于 part 的数量，kafka 如何处理？多余的 Part 将处于无用状态，不消费数据&lt;/li&gt;
&lt;li&gt;Kafka Consumer 是否是线程安全的？不安全，单线程消费，多线程处理&lt;/li&gt;
&lt;li&gt;讲一下你使用 Kafka Consumer 消费消息时的线程模型，为何如此设计？拉取和处理分离&lt;/li&gt;
&lt;li&gt;Kafka Consumer 的常见配置？broker, 网络和拉取参数，心跳参数&lt;/li&gt;
&lt;li&gt;Consumer 什么时候会被踢出集群？奔溃，网络异常，处理时间过长提交位移超时&lt;/li&gt;
&lt;li&gt;当有 Consumer 加入或退出时，Kafka 会作何反应？进行 Rebalance&lt;/li&gt;
&lt;li&gt;什么是 Rebalance，何时会发生 Rebalance？topic 变化，consumer 变化&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;高可用和性能&quot;&gt;高可用和性能&lt;/h2&gt;
&lt;h3 id=&quot;问题-4&quot;&gt;问题&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;Kafka 如何保证高可用？&lt;/li&gt;
&lt;li&gt;Kafka 的交付语义？&lt;/li&gt;
&lt;li&gt;Replic 的作用？&lt;/li&gt;
&lt;li&gt;什么事 AR，ISR？&lt;/li&gt;
&lt;li&gt;Leader 和 Flower 是什么？&lt;/li&gt;
&lt;li&gt;Kafka 中的 HW、LEO、LSO、LW 等分别代表什么？&lt;/li&gt;
&lt;li&gt;Kafka 为保证优越的性能做了哪些处理？&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;分区与副本&quot;&gt;分区与副本&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://magebyte.oss-cn-shenzhen.aliyuncs.com/kafka/r-p.png&quot; alt=&quot;分区副本&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在分布式数据系统中，通常使用分区来提高系统的处理能力，通过副本来保证数据的高可用性。多分区意味着并发处理的能力，这多个副本中，只有一个是 leader，而其他的都是 follower 副本。仅有 leader 副本可以对外提供服务。 多个 follower 副本通常存放在和 leader 副本不同的 broker 中。通过这样的机制实现了高可用，当某台机器挂掉后，其他 follower 副本也能迅速”转正“，开始对外提供服务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么 follower 副本不提供读服务？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个问题本质上是对性能和一致性的取舍。试想一下，如果 follower 副本也对外提供服务那会怎么样呢？首先，性能是肯定会有所提升的。但同时，会出现一系列问题。类似数据库事务中的幻读，脏读。 比如你现在写入一条数据到 kafka 主题 a，消费者 b 从主题 a 消费数据，却发现消费不到，因为消费者 b 去读取的那个分区副本中，最新消息还没写入。而这个时候，另一个消费者 c 却可以消费到最新那条数据，因为它消费了 leader 副本。Kafka 通过 WH 和 Offset 的管理来决定 Consumer 可以消费哪些数据，已经当前写入的数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://magebyte.oss-cn-shenzhen.aliyuncs.com/kafka/kafka_high_watermark.png&quot; alt=&quot;watermark&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;只有 Leader 可以对外提供读服务，那如何选举 Leader&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;kafka 会将与 leader 副本保持同步的副本放到 ISR 副本集合中。当然，leader 副本是一直存在于 ISR 副本集合中的，在某些特殊情况下，ISR 副本中甚至只有 leader 一个副本。 当 leader 挂掉时，kakfa 通过 zookeeper 感知到这一情况，在 ISR 副本中选取新的副本成为 leader，对外提供服务。 但这样还有一个问题，前面提到过，有可能 ISR 副本集合中，只有 leader，当 leader 副本挂掉后，ISR 集合就为空，这时候怎么办呢？这时候如果设置 unclean.leader.election.enable 参数为 true，那么 kafka 会在非同步，也就是不在 ISR 副本集合中的副本中，选取出副本成为 leader。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;副本的存在就会出现副本同步问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Kafka 在所有分配的副本 (AR) 中维护一个可用的副本列表 (ISR)，Producer 向 Broker 发送消息时会根据&lt;code&gt;ack&lt;/code&gt;配置来确定需要等待几个副本已经同步了消息才相应成功，Broker 内部会&lt;code&gt;ReplicaManager&lt;/code&gt;服务来管理 flower 与 leader 之间的数据同步。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://magebyte.oss-cn-shenzhen.aliyuncs.com/kafka/sync.png&quot; alt=&quot;sync&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;性能优化&quot;&gt;性能优化&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;partition 并发&lt;/li&gt;
&lt;li&gt;顺序读写磁盘&lt;/li&gt;
&lt;li&gt;page cache：按页读写&lt;/li&gt;
&lt;li&gt;预读：Kafka 会将将要消费的消息提前读入内存&lt;/li&gt;
&lt;li&gt;高性能序列化（二进制）&lt;/li&gt;
&lt;li&gt;内存映射&lt;/li&gt;
&lt;li&gt;无锁 offset 管理：提高并发能力&lt;/li&gt;
&lt;li&gt;Java NIO 模型&lt;/li&gt;
&lt;li&gt;批量：批量读写&lt;/li&gt;
&lt;li&gt;压缩：消息压缩，存储压缩，减小网络和 IO 开销&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;partition-并发&quot;&gt;Partition 并发&lt;/h4&gt;
&lt;p&gt;一方面，由于不同 Partition 可位于不同机器，因此可以充分利用集群优势，实现机器间的并行处理。另一方面，由于 Partition 在物理上对应一个文件夹，即使多个 Partition 位于同一个节点，也可通过配置让同一节点上的不同 Partition 置于不同的 disk drive 上，从而实现磁盘间的并行处理，充分发挥多磁盘的优势。&lt;/p&gt;
&lt;h4 id=&quot;顺序读写&quot;&gt;顺序读写&lt;/h4&gt;
&lt;p&gt;Kafka 每一个 partition 目录下的文件被平均切割成大小相等（默认一个文件是 500 兆，可以手动去设置）的数据文件，&lt;br/&gt;每一个数据文件都被称为一个段（segment file）, 每个 segment 都采用 append 的方式追加数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://magebyte.oss-cn-shenzhen.aliyuncs.com/kafka/append.png&quot; alt=&quot;追加数据&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;答案关键字-4&quot;&gt;答案关键字&lt;/h3&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;0.5&quot;&gt;
&lt;p&gt;Kafka 如何保证高可用？&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;通过副本来保证数据的高可用，producer ack、重试、自动 Leader 选举，Consumer 自平衡&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;
&lt;p&gt;Kafka 的交付语义？&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;交付语义一般有&lt;code&gt;at least once&lt;/code&gt;、&lt;code&gt;at most once&lt;/code&gt;和&lt;code&gt;exactly once&lt;/code&gt;。kafka 通过 ack 的配置来实现前两种。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Replic 的作用？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;实现数据的高可用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-0.5&quot;&gt;
&lt;p&gt;什么是 AR，ISR？&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;AR：Assigned Replicas。AR 是主题被创建后，分区创建时被分配的副本集合，副本个 数由副本因子决定。&lt;br/&gt;ISR：In-Sync Replicas。Kafka 中特别重要的概念，指代的是 AR 中那些与 Leader 保 持同步的副本集合。在 AR 中的副本可能不在 ISR 中，但 Leader 副本天然就包含在 ISR 中。关于 ISR，还有一个常见的面试题目是如何判断副本是否应该属于 ISR。目前的判断 依据是：Follower 副本的 LEO 落后 Leader LEO 的时间，是否超过了 Broker 端参数 replica.lag.time.max.ms 值。如果超过了，副本就会被从 ISR 中移除。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Leader 和 Flower 是什么？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;Kafka 中的 HW 代表什么？&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;高水位值 (High watermark)。这是控制消费者可读取消息范围的重要字段。一 个普通消费者只能“看到”Leader 副本上介于 Log Start Offset 和 HW（不含）之间的 所有消息。水位以上的消息是对消费者不可见的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;0.5&quot;&gt;
&lt;p&gt;Kafka 为保证优越的性能做了哪些处理？&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;partition 并发、顺序读写磁盘、page cache 压缩、高性能序列化（二进制）、内存映射 无锁 offset 管理、Java NIO 模型&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;本文并没有深入 Kafka 的实现细节和源码分析，但 Kafka 确实是一个 优秀的开源系统，很多优雅的架构设计和源码设计都值得我们学习，十分建议感兴趣的同学更加深入的去了解一下这个开源系统，对于自身架构设计能力，编码能力，性能优化都会有很大的帮助。&lt;/p&gt;
&lt;h2 id=&quot;推荐阅读&quot;&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;以下几篇文章阅读量与读者反馈都很好，推荐大家阅读：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://magebyte.oss-cn-shenzhen.aliyuncs.com/wechat/Snip20200314_5.png&quot; alt=&quot;MageByte&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Wed, 14 Oct 2020 15:15:00 +0000</pubDate>
<dc:creator>MageByte-借来方向</dc:creator>
<og:description>Kafka 是一个优秀的分布式消息中间件，许多系统中都会使用到 Kafka 来做消息通信。对分布式消息系统的了解和使用几乎成为一个后台开发人员必备的技能。今天就从常见的 Kafka 面试题入手，和大家</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/WeaRang/p/13818011.html</dc:identifier>
</item>
<item>
<title>【译】自动发现 .NET 5 中代码的潜在错误 - MeteorSeed</title>
<link>http://www.cnblogs.com/MeteorSeed/p/13814158.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MeteorSeed/p/13814158.html</guid>
<description>&lt;p&gt;从 .NET 5 开始，我们在 C# 编译器中引入了 AnalysisLevel，以一种安全的方式为这些模式引入警告。所有针对 .NET 5 的项目的 AnalysisLevel 默认将被设置为 5，这意味着将引入更多的警告。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;362.38523182599&quot;&gt;
&lt;p&gt;　　写代码是一件令人兴奋的事情，特别是对于  .NET 开发人员来说，平台越来越智能化了。我们现在默认在 .NET SDK 中包含丰富的诊断和代码建议。在您需要安装 NuGet 包或其他独立工具来进行更多的代码分析之前。现在，您将在新的 .NET 5 SDK 中自动获得这些内容。&lt;/p&gt;
&lt;p&gt;　　过去，我们一直不愿意向 C# 添加新的警告。这是因为，对于将警告视为错误的用户来说，添加新的警告从技术上来说是一种对源代码的影响。然而，这些年来，在我们遇到的很多情况中，我们也确实想警告人们有些地方出了问题，从常见的编码错误到常见的 API 误用等等。&lt;/p&gt;
&lt;p&gt;　　从 .NET 5 开始，我们在 C# 编译器中引入了 AnalysisLevel，以一种安全的方式引入新的警告。所有针对 .NET 5 的项目的 AnalysisLevel 默认将被设置为 5，这意味着将引入更多的警告（以及修复它们的建议)。&lt;/p&gt;
&lt;p&gt;　　让我们讨论一下 AnalysisLevel 可能的值在您的项目中意味着什么。首先我们要注意的是：除非你覆盖默认值，否则 AnalysisLevel 是基于你的目标框架设置的：&lt;/p&gt;
&lt;table&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;269&quot;&gt;&lt;span&gt;&lt;strong&gt;目标框架&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;269&quot;&gt;&lt;span&gt;&lt;strong&gt;默认值&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;269&quot;&gt;net5.0&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;269&quot;&gt;5&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;269&quot;&gt;netcoreapp3.1 or lower&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;269&quot;&gt;4&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;269&quot;&gt;netstandard2.1 or lower&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;269&quot;&gt;4&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;269&quot;&gt;.NET Framework 4.8 or lower&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;269&quot;&gt;4&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;　　但是，0-3 呢?下面是对每个分析级别值含义的更详细的细分：&lt;/p&gt;
&lt;table&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;AnalysisLevel&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;对C#编译器的影响&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;高级平台API分析&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;116&quot;&gt;5&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;226&quot;&gt;获得新的编译器语言分析（详细内容如下）&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;172&quot;&gt;Yes&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;116&quot;&gt;4&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;226&quot;&gt;与之前版本中向 C# 编译器传递 -warn:4 相同&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;172&quot;&gt;No&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;116&quot;&gt;3&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;226&quot;&gt;与之前版本中向 C# 编译器传递 -warn:3 相同&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;172&quot;&gt;No&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;116&quot;&gt;2&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;226&quot;&gt;与之前版本中向 C# 编译器传递 -warn:2 相同&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;172&quot;&gt;No&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;116&quot;&gt;1&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;226&quot;&gt;与之前版本中向 C# 编译器传递 -warn:1 相同&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;172&quot;&gt;No&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;116&quot;&gt;0&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;226&quot;&gt;与之前版本中向 C# 编译器传递 -warn:0 一样，关闭所有发出警告&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;172&quot;&gt;No&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;　　由于 AnalysisLevel 与项目的目标框架绑定在一起，除非你改变了你的代码目标框架，否则你永远不会改变默认的分析级别。不过，你可以手动设置分析级别。例如，即使我们的目标是 .NET Core App 3.1 或 .NET Standard （因此 AnalysisLevel 默认为 4），你仍然可以选择更高的级别。这里有一个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;Project Sdk=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Microsoft.NET.Sdk&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;

  &amp;lt;PropertyGroup&amp;gt;
    &amp;lt;OutputType&amp;gt;Exe&amp;lt;/OutputType&amp;gt;
    &amp;lt;TargetFramework&amp;gt;netcoreapp3.&lt;span&gt;1&lt;/span&gt;&amp;lt;/TargetFramework&amp;gt;
    &amp;lt;!-- &lt;span&gt;get&lt;/span&gt; more advanced warnings &lt;span&gt;for&lt;/span&gt; &lt;span&gt;this&lt;/span&gt; project --&amp;gt;
    &amp;lt;AnalysisLevel&amp;gt;&lt;span&gt;5&lt;/span&gt;&amp;lt;/AnalysisLevel&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;

&amp;lt;/Project&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　如果你想要最高的分析级别，你可以在你的项目文件中指定 latest：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;Project Sdk=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Microsoft.NET.Sdk&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;

  &amp;lt;PropertyGroup&amp;gt;
    &amp;lt;OutputType&amp;gt;Exe&amp;lt;/OutputType&amp;gt;
    &amp;lt;TargetFramework&amp;gt;netcoreapp3.&lt;span&gt;1&lt;/span&gt;&amp;lt;/TargetFramework&amp;gt;
    &amp;lt;!-- be automatically updated to the newest stable level --&amp;gt;
    &amp;lt;AnalysisLevel&amp;gt;latest&amp;lt;/AnalysisLevel&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;

&amp;lt;/Project&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　如果你很有冒险精神，并且希望尝试实验性的编译器和平台分析，那么可以指定 preview 来获得最新的、最前沿的代码诊断。&lt;/p&gt;
&lt;p&gt;　　请注意，当您使用 latest 或 preview 时，分析结果可能会因机器而异，这取决于可用的 SDK 和它提供的最高分析级别。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;Project Sdk=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Microsoft.NET.Sdk&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;

  &amp;lt;PropertyGroup&amp;gt;
    &amp;lt;OutputType&amp;gt;Exe&amp;lt;/OutputType&amp;gt;
    &amp;lt;TargetFramework&amp;gt;netcoreapp3.&lt;span&gt;1&lt;/span&gt;&amp;lt;/TargetFramework&amp;gt;
    &amp;lt;!-- be opted into experimental code correctness warnings --&amp;gt;
    &amp;lt;AnalysisLevel&amp;gt;preview&amp;lt;/AnalysisLevel&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;

&amp;lt;/Project&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　最后，也可以设置为 none，这意味着“我不想看到任何新的警告”。在这种模式下，你不会得到任何高级 API 分析，也不会得到新的编译器警告。如果你需要更新框架，但还没有准备好接受新的警告，那么这将非常有用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;Project Sdk=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Microsoft.NET.Sdk&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;

  &amp;lt;PropertyGroup&amp;gt;
    &amp;lt;OutputType&amp;gt;Exe&amp;lt;/OutputType&amp;gt;
    &amp;lt;TargetFramework&amp;gt;net5&amp;lt;/TargetFramework&amp;gt;
    &amp;lt;!-- I am just fine thanks --&amp;gt;
    &amp;lt;AnalysisLevel&amp;gt;none&amp;lt;/AnalysisLevel&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;

&amp;lt;/Project&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　你还可以在 Visual Studio 中通过 Code Analysis 属性页配置项目的分析级别。只需从解决方案资源管理器导航到项目属性页。然后转到 Code Analysis 选项卡。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/270073/202010/270073-20201014124206382-1312270275.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在未来，我们将为 .NET 的每个版本添加一个新的分析级别。目标是确保给定的分析级别总是表示相同的默认分析集（规则及其严重性）。如果我们想在默认情况下启用现有的规则，我们将在即将到来的分析级别中这样做，而不是更改现有的级别。这确保了已有的项目/源代码总是产生相同的警告，不管 SDK 有多新（当然，除了项目使用 preview 或 latest）。&lt;/p&gt;
&lt;p&gt;　　由于所有的 .NET 5 项目都将进入分析级别 5，让我们来看看一些新的警告和建议。&lt;/p&gt;

&lt;p&gt;　　粗体部分将在 .NET 5 发布的时候进入第 5 级。剩下的是 Visual Studio 2019 16.8 预览2 中的 .NET 5 预览8 中的新警告！&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/270073/202010/270073-20201014124441216-771737059.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　第一组新的警告旨在发现潜在的错误，通常是在较大的代码库中。现在不需要额外的编译器分析就可以很容易地发现它们。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;当表达式永真或永假时发出警告&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　这种新的警告非常普遍，考虑以下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; M(DateTime dateTime)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (dateTime == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; warning CS8073&lt;/span&gt;
&lt;span&gt;    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　DateTime 是一个结构体，结构体不能为空。从 .NET 开始，我们将在 CS8073 中警告这种情况。警告信息是：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;　　Warning CS8073: The result of the expression is always ‘false’ since the value of type ‘DateTime’ is never equal to ‘null’ of type ‘DateTime?’&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　很明显，这段代码所做的事情没有意义，但是考虑到这样的检查可能发生在有多个参数要验证的方法中。要解决这个问题，你可以删除代码（因为它总是假的，它没有做任何事情），或者改变它的类型为 DateTime? 如果参数的预期值为 null。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; M(DateTime? dateTime) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; We accept a null DateTime&lt;/span&gt;
&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (dateTime == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; No Warnings&lt;/span&gt;
&lt;span&gt;    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;strong&gt;不允许在静态类型上用as、 is&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　下面是一个很好的小改进：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Fiz
{
}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; P
{
    &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; M(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; o)
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; o &lt;span&gt;is&lt;/span&gt; Fiz; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; CS7023&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　因为 Fiz 是一个静态类，所以像 o 这样的实例对象永远不可能是这种类型的实例。我们会收到这样的警告：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;　　Warning CS7023 The second operand of an ‘is’ or ‘as’ operator may not be static type ‘Fiz’&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　解决这个问题的方法是重构我们的代码（也许我们一开始就检查错类型了），或者让类 Fiz 是非静态的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Fiz
{
}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; P
{
    &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; M(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; o)
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; o &lt;span&gt;is&lt;/span&gt; Fiz; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; no error&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;strong&gt;不允许锁定非引用类型&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　锁定非引用类型（比如 int）什么也做不了，因为它们是按值传递的，所以每个堆栈帧上都有不同版本的非引用类型。在过去，对于像 lock(5) 这样简单的情况，我们会警告你对非引用类型的锁定，但是直到最近，我们对泛型方法的也支持警告：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; P
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; GetValue&amp;lt;TKey&amp;gt;&lt;span&gt;(TKey key)
    {
        &lt;/span&gt;&lt;span&gt;lock&lt;/span&gt; (key) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; CS0185&lt;/span&gt;
&lt;span&gt;        {
        }
    }

    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
    {
        GetValue(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这是一个错误，因为传入 int（在这个不受约束的泛型中允许）实际上不会正确锁定。我们会看到这个错误：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;　　Error CS0185 ‘TKey’ is not a reference type as required by the lock statement&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　要解决这个问题，我们需要指出 GetValue 方法应该只提供引用类型。我们可以使用泛型类型约束来做到这一点，where TKey : class&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; P
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; GetValue&amp;lt;TKey&amp;gt;(TKey key) &lt;span&gt;where&lt;/span&gt; TKey : &lt;span&gt;class&lt;/span&gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;lock&lt;/span&gt; (key) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; no error&lt;/span&gt;
&lt;span&gt;        {
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;strong&gt;重新抛出以保留堆栈细节&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　我们都是“优秀的”开发人员，所以我们的代码不会抛出异常，对吗？好吧，即使是最好的开发人员也需要处理异常，而新程序员常陷入的一个陷阱是：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
{
    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Exception();
}
&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; probably logging some info here...

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; rethrow now that we are done&lt;/span&gt;
    &lt;span&gt;throw&lt;/span&gt; ex; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; CA2200&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在学校里，我学到如果有人向我扔球，我接住它，我必须把球扔回去！像这样的比喻让很多人相信 throw ex 是重新抛出这个异常的正确方式。遗憾的是，这将改变原来异常中的堆栈。现在您将收到一个警告，说明正在发生这种情况。它是这样的：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;　　Warning CA2200 Re-throwing caught exception changes stack information&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　在几乎所有情况下，这里要做的正确事情是简单地使用 throw 关键字，而不提及我们捕获的异常的变量。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
{
    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Exception();
}
&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; probably logging some info here...

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; rethrow now that we are done&lt;/span&gt;
    &lt;span&gt;throw&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我们还提供了一个代码修复，可以轻松地在您的文档、项目或解决方案中一次性修复所有这些问题！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/270073/202010/270073-20201014124954149-1506689883.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;不要在值类型中使用 ReferenceEquals&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　Equality 在 .NET 中是一个棘手的话题。下一个警告试图使意外地通过引用比较一个 struct 。考虑以下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; int1 = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; int2 = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
Console.WriteLine(&lt;/span&gt;&lt;span&gt;object&lt;/span&gt;.ReferenceEquals(int1, int2)); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; warning CA2013&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这将装箱两个 int，而 ReferenceEquals 将总是返回 false 作为结果。我们将看到这个警告描述：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;　　Warning CA2013: Do not pass an argument with value type ‘int’ to ‘ReferenceEquals’. Due to value boxing, this call to ‘ReferenceEquals’ will always return ‘false’.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　解决此错误的方法是使用相等运算符 == 或 object.Equals：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; int1 = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; int2 = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
Console.WriteLine(int1 &lt;/span&gt;== int2); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; using the equality operator is fine&lt;/span&gt;
Console.WriteLine(&lt;span&gt;object&lt;/span&gt;.Equals(int1, int2));  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; so is object.Equals&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;strong&gt;跟踪跨程序集中结构的明确赋值（definite assignment）&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　很多人可能会惊讶地发现，下一个警告其实并不算是警告：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Immutable;

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; P
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; M(&lt;span&gt;out&lt;/span&gt; ImmutableArray&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; immutableArray) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; CS0177&lt;/span&gt;
&lt;span&gt;    {
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这条规则是关于明确赋值的，这是 C# 中一个有用的特性，可以确保你不会忘记给变量赋值。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;　　Warning CS0177: The out parameter ‘immutableArray’ must be assigned to before control leaves the current method&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　目前已经针对几种不同的情况发布了 CS0177，但不是前面展示的情况。这里的历史是，这个 bug 可以追溯到 C# 编译器的原始实现。以前，C# 编译器在计算明确赋值时忽略从元数据导入的值类型中的引用类型的私有字段。这个非常特殊的错误意味着像 ImmutableArray 这样的类型能够逃脱明确赋值分析。&lt;/p&gt;
&lt;p&gt;　　现在编译器将正确的显示错误，你可以修复它，只要确保它总是分配一个值，像这样：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Immutable;

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; P
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; M(&lt;span&gt;out&lt;/span&gt; ImmutableArray&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; immutableArray) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; no warning&lt;/span&gt;
&lt;span&gt;    {
        immutableArray &lt;/span&gt;= ImmutableArray&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt;.Empty;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　下面示例是关于正确使用 .NET 库的。分析级别可以防止现有的 .NET API 的不当使用，但它也会影响 .NET 库的发展。如果设计了一个有用的 API，但它有可能被误用，那么还可以在新增 API 的同时添加一个检测误用的新警告。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;不要给从 MemoryManager 的派生类定义终结器&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　当你想实现自己的 Memory&amp;lt;T&amp;gt; 类型时，MemoryManager 是一个有用的类。这不是你经常做的事情，但是当你需要它的时候，你真的需要它。这个新的警告会触发这样的情况：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt; DerivedClass &amp;lt;T&amp;gt; : MemoryManager&amp;lt;T&amp;gt;&lt;span&gt;
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; Dispose(&lt;span&gt;bool&lt;/span&gt;&lt;span&gt; disposing)
{
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (disposing)
        {
            _handle.Dispose();
        }
    }
  
    &lt;/span&gt;~DerivedClass() =&amp;gt; Dispose(&lt;span&gt;false&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; warning CA2015&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　向这种类型添加终结器可能会在垃圾收集器中引入漏洞，这是我们都希望避免的！&lt;/p&gt;
&lt;p&gt;&lt;em&gt;　　Warning CA2015 Adding a finalizer to a type derived from MemoryManager&amp;lt;T&amp;gt; may permit memory to be freed while it is still in use by a Span&amp;lt;T&amp;gt;.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　解决方法是删除这个终结器，因为它会在你的程序中导致非常细微的 bug，很难找到和修复。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt; DerivedClass &amp;lt;T&amp;gt; : MemoryManager&amp;lt;T&amp;gt;&lt;span&gt;
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; Dispose(&lt;span&gt;bool&lt;/span&gt;&lt;span&gt; disposing)
{
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (disposing)
        {
            _handle.Dispose();
        }
    }
 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; No warning, since there is no finalizer here&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;strong&gt;参数传递给 TaskCompletionSource，调用错误的构造函数&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　这个警告告诉我们，我们使用了错误的枚举。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; tcs = &lt;span&gt;new&lt;/span&gt; TaskCompletionSource(TaskContinuationOptions.RunContinuationsAsynchronously); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; warning CA2247&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　除非你已经意识到这个问题，否则你可能会在盯着它看一会儿才能发现。问题是这样的，这个构造函数不接受 TaskContinuationOptions 枚举，它接受 TaskCreationOptions 枚举。发生的事情是，我们正在调用的 TaskCompletionSource 的构造函数接受 object 类型参数！考虑到它们的名称特别相似，并且它们的值也非常相似，所以这种错误容易发生。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;　　Warning CA2247: Argument contains TaskContinuationsOptions enum instead of TaskCreationOptions enum.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　修复它只需要传递正确的枚举类型：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; tcs = &lt;span&gt;new&lt;/span&gt; TaskCompletionSource(TaskCreationOptions.RunContinuationsAsynchronously); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; no warning&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;strong&gt;当代码不能在所有平台上工作时发出警告&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　这个真是太棒了！我不会在这里详细讨论它的复杂之处（期待以后关于这个主题的博客文章）。但这里警告的目的是让您知道，您正在调用的 api 可能无法在您正在构建的所有目标上工作。&lt;/p&gt;
&lt;p&gt;　　假设我有一个同时在 Linux 和 Windows 上运行的应用程序。我有一个方法，我使用它来获得路径来创建日志文件，根据运行环境，它有不同的行为。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; GetLoggingPath()
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; appDataDirectory =&lt;span&gt; Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData);
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; loggingDirectory = Path.Combine(appDataDirectory, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Fabrikam&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AssetManagement&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Logging&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Create the directory and restrict access using Windows
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Access Control Lists (ACLs).&lt;/span&gt;

    &lt;span&gt;var&lt;/span&gt; rules = &lt;span&gt;new&lt;/span&gt; DirectorySecurity(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; CA1416&lt;/span&gt;
&lt;span&gt;    rules.AddAccessRule(
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; FileSystemAccessRule(&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;fabrikam\log-readers&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                                    FileSystemRights.Read,
                                    AccessControlType.Allow)
    );
    rules.AddAccessRule(
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; FileSystemAccessRule(&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;fabrikam\log-writers&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                                    FileSystemRights.FullControl,
                                    AccessControlType.Allow)
    );

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;OperatingSystem.IsWindows())
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Just create the directory&lt;/span&gt;
&lt;span&gt;        Directory.CreateDirectory(loggingDirectory);
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    {
        Directory.CreateDirectory(loggingDirectory, rules);
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; loggingDirectory;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我正确地使用了 OperatingSystem.IsWindows() 来检查操作系统是否是 Windows 操作系，但是实际上 if 分支之前已经使用了平台特定的 API，将不能工作在 Linux！&lt;/p&gt;
&lt;p&gt;&lt;em&gt;　　Warning CA1416: ‘DirectorySecurity’ is unsupported on ‘Linux’&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　处理这个问题的正确方法是将所有特定于平台的代码移动到 else 语句中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; GetLoggingPath()
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; appDataDirectory =&lt;span&gt; Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData);
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; loggingDirectory = Path.Combine(appDataDirectory, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Fabrikam&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AssetManagement&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Logging&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;OperatingSystem.IsWindows())
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Just create the directory&lt;/span&gt;
&lt;span&gt;        Directory.CreateDirectory(loggingDirectory);
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Create the directory and restrict access using Windows
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Access Control Lists (ACLs).&lt;/span&gt;

        &lt;span&gt;var&lt;/span&gt; rules = &lt;span&gt;new&lt;/span&gt; DirectorySecurity(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; CA1416&lt;/span&gt;
&lt;span&gt;        rules.AddAccessRule(
            &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; FileSystemAccessRule(&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;fabrikam\log-readers&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                                        FileSystemRights.Read,
                                        AccessControlType.Allow)
        );
        rules.AddAccessRule(
            &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; FileSystemAccessRule(&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;fabrikam\log-writers&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                                        FileSystemRights.FullControl,
                                        AccessControlType.Allow)
        );

        Directory.CreateDirectory(loggingDirectory, rules);
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; loggingDirectory;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　在编写高性能应用程序时，还有一些有用的警告。下面这些警告确保您不需要为这些情况牺牲安全性。&lt;/p&gt;
&lt;h2&gt;P/Invoke 时不要在 string 参数上使用 OutAttribute&lt;/h2&gt;
&lt;p&gt;　　有时你需要与本地代码进行互操作。.NET 有使用平台调用服务的概念（P/ Invoke）来简化这个过程。但是，在 .NET 中，在向本地库发送数据和从本地库发送数据方面存在一些问题。考虑以下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[DllImport(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MyLibrary&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;extern&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Goo([Out] &lt;span&gt;string&lt;/span&gt; s); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; warning CA1417&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　除非您非常熟悉 P/Invoke 的编写，否则这里的错误并不明显。通常将 OutAttribute 应用于运行时不知道的类型，以指示应该如何封送类型。OutAttribute 表示您正在按值传递数据。字符串按值传递没有意义，而且有可能导致运行时崩溃。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;　　Warning CA1417 Do not use the ‘OutAttribute’ for string parameter ‘s’ which is passed by value. If marshalling of modified data back to the caller is required, use the ‘out’ keyword to pass the string by reference instead.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　解决这个问题的方法是将其作为一个普通的 out 参数（通过引用传递）来处理。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[DllImport(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MyLibrary&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;extern&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Goo(&lt;span&gt;out&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; s); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; no warning&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　或者如果你不需要将字符串封送回调用者，你可以这样做：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[DllImport(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MyLibrary&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;extern&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Goo(&lt;span&gt;string&lt;/span&gt; s); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; no warning&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;strong&gt;在适当情况下，string 使用 AsSpan 而不是基于范围的索引器&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　这都是为了确保您不会意外地分配字符串。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; TestMethod(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; str)
    {
        ReadOnlySpan&lt;/span&gt;&amp;lt;&lt;span&gt;char&lt;/span&gt;&amp;gt; slice = str[&lt;span&gt;1&lt;/span&gt;..&lt;span&gt;3&lt;/span&gt;]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; CA1831&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在上面的代码中，开发者的意图是使用 C# 中新的基于范围的索引特性来索引一个字符串。不幸的是，这实际上会分配一个字符串，除非您首先将该字符串转换为 span。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;　　Warning CA1831 Use ‘AsSpan’ instead of the ‘System.Range’-based indexer on ‘string’ to avoid creating unnecessary data copies&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　解决方法是在这种情况下添加 AsSpan 调用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; TestMethod(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; str)
    {
        ReadOnlySpan&lt;/span&gt;&amp;lt;&lt;span&gt;char&lt;/span&gt;&amp;gt; slice = str.AsSpan()[&lt;span&gt;1&lt;/span&gt;..&lt;span&gt;3&lt;/span&gt;]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; no warning&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;strong&gt;不要在循环中使用 stackalloc&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　stackalloc 关键字非常适合于确保正在进行的操作对垃圾收集器来说比较容易。在过去，stackalloc 关键字用于不安全的代码上下文中，以便在堆栈上分配内存块。但自从 C# 8 以来，它也被允许在 unsafe 的块之外，只要这个变量被分配给一个 Span&amp;lt;T&amp;gt; 或一个 ReadOnlySpan&amp;lt;T&amp;gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; C
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; TestMethod(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; str)
    {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; length = &lt;span&gt;3&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; length; i++&lt;span&gt;)
        {
            Span&lt;/span&gt;&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; numbers = &lt;span&gt;stackalloc&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[length]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; CA2014&lt;/span&gt;
            numbers[i] =&lt;span&gt; i;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在堆栈上分配大量内存可能会导致著名的 StackOverflow 异常，即我们在堆栈上分配的内存超过了允许的范围。在循环中分配尤其危险。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;　　Warning CA2014 Potential stack overflow. Move the stackalloc out of the loop.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　解决方法是将 stackalloc 移出循环：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; C
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; TestMethod(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; str)
    {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; length = &lt;span&gt;3&lt;/span&gt;&lt;span&gt;;
        Span&lt;/span&gt;&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; numbers = &lt;span&gt;stackalloc&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[length]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; no warning&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; length; i++&lt;span&gt;)
        {
            numbers[i] &lt;/span&gt;=&lt;span&gt; i;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　现在您已经看到了这些警告的重要性，您可能永远不想回到一个没有它们的世界，对吗？我知道世界并不总是这样运转的。正如在这篇文章的开头提到的，这些都是打破源代码的改变，你应该在适合自己的时间表中完成它们。我们现在介绍这个的部分原因是为了得到两个方面的反馈：&lt;/p&gt;
&lt;ol class=&quot;list-paddingleft-2&quot; readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;我们提出的这一小部分警告是否太过破坏性&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;调整警告的机制是否足以满足您的需要&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;&lt;strong&gt;回到 .NET Core 3.1 的分析等级&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　如果你只想回到 .NET 5 之前的状态（即.NET Core 3.1 中的警告级别），你所需要做的就是在你的项目文件中将分析级别设置为4。下面是一个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;Project Sdk=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Microsoft.NET.Sdk&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;

  &amp;lt;PropertyGroup&amp;gt;
    &amp;lt;OutputType&amp;gt;Exe&amp;lt;/OutputType&amp;gt;
    &amp;lt;TargetFramework&amp;gt;net5.&lt;span&gt;0&lt;/span&gt;&amp;lt;/TargetFramework&amp;gt;
    &amp;lt;!-- &lt;span&gt;get&lt;/span&gt; the exact same warnings you used to --&amp;gt;
    &amp;lt;AnalysisLevel&amp;gt;&lt;span&gt;4&lt;/span&gt;&amp;lt;/AnalysisLevel&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;

&amp;lt;/Project&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;strong&gt;只关闭一个规则&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　如果有一个你认为不适用于你的代码库的特定警告，你可以使用一个 editorconfig 文件来关闭它。你可以通过在错误列表中将警告的严重性设置为“none”来做到这一点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/270073/202010/270073-20201014130118105-854115741.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　或者从编辑器中出现警告的灯泡菜单中选择“None”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/270073/202010/270073-20201014130157034-587742393.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;关闭警告的单个实例&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　如果你大部分时间都想使用这个警告，但在少数情况下要关闭它，你可以使用灯泡菜单中的一个：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;在源码中禁止&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/270073/202010/270073-20201014130241316-1497263452.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;　　在单独的禁止文件中禁止它&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/270073/202010/270073-20201014130410295-1111982918.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;在源码中禁用并标记一个特性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/270073/202010/270073-20201014130452842-402048481.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　我们希望你对 .NET 5 代码分析的改进感到兴奋，请给我们一些反馈。&lt;/p&gt;

&lt;p&gt;　　&lt;a href=&quot;https://devblogs.microsoft.com/dotnet/automatically-find-latent-bugs-in-your-code-with-net-5/&quot; target=&quot;_blank&quot;&gt;https://devblogs.microsoft.com/dotnet/automatically-find-latent-bugs-in-your-code-with-net-5/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/270073/202010/270073-20201014130602036-683224151.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;/div&gt;</description>
<pubDate>Wed, 14 Oct 2020 15:12:00 +0000</pubDate>
<dc:creator>MeteorSeed</dc:creator>
<og:description>从 .NET 5 开始，我们在 C# 编译器中引入了 AnalysisLevel，以一种安全的方式为这些模式引入警告。所有针对 .NET 5 的项目的 AnalysisLevel 默认将被设置为 5，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/MeteorSeed/p/13814158.html</dc:identifier>
</item>
</channel>
</rss>