<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>一周一个中间件-hbase - jack_zdl</title>
<link>http://www.cnblogs.com/smartzhang/p/14066014.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/smartzhang/p/14066014.html</guid>
<description>&lt;p&gt;hbase是大数据的生态的一部分，是高可靠性、高性能、列存储、可伸缩、实时读写的数据库系统。介于nosql和RDBMS之间。主要存储非结构化和半结构化的松散数据。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;108.58806750654&quot;&gt;
&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;hbase是大数据的生态的一部分，是高可靠性、高性能、列存储、可伸缩、实时读写的数据库系统。介于nosql和RDBMS之间。主要存储非结构化和半结构化的松散数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;海量数据存储&lt;br/&gt;快速随机访问&lt;br/&gt;大量写操作的应用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;背景&quot;&gt;背景&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;我们公司现在需要一套监控系统，并且需要存储一系列的用户访问数据，这些数据很松散，现在看起来无关紧要的数据但是确实潜在的用户行为数据。之后会帮助我们分心用户行为，为我们提供个性化数据作为依据。&lt;br/&gt;在综合现在主流的监控系统，cat，pinpoint，zikpin，SkyWalking等监控系统。我们选择了pinpoint这个基于字节码注入的调用链分析。所消耗的性能低，无代码侵入性。但是搭建pinpoint时，需要使用hbase作为存储数据的数据库。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;知识准备&quot;&gt;知识准备&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;RegionServer.理解为数据节点，存储数据的&lt;br/&gt;region服务器的内存主要服务于内部数据结构。你需要64位操作系统和使用大于4G的内存空间。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;架构图&lt;br/&gt;&lt;img src=&quot;http://output-mingbo.oss-cn-beijing.aliyuncs.com/imgs/15692828428763.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;HMater&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;HMaster是Master Server的实现，负责监控集群中的RegionServer实例，同时是所有metadata改变的接口，在集群中，通常运行在NameNode上面。master机器不需要大存储空间，不需要挂载过多的磁盘。由于master的重要性大于slalve。可以通过冗余提升硬件可用率。&lt;br/&gt;master机器要运行NameNode,SecondaryNameNode,JobTRacker和HBase Master.800TB数据推荐24G内存。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;HBase的RegionServer.slave机器要使用DataNode,TaskTracker和HBase RegionServer.800TB数据推荐24G内存以上配置。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;hbase使用的文件系统&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;本地模式： hbase可以不使用HDFS或者其他集群。使用FileSystem类连接到文件系统实现。Hadoop客户端加载并使用hadoop提供ChecksumFileSystem类直接操作本地磁盘路径来存储所有的路径。&lt;br/&gt;参数 file:///&lt;br/&gt;HDFS模式： 是默认的文件系统，Hbase选择HDFS作为文件系统。&lt;br/&gt;hdfs://😕&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;hbase集群&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;单机模式&lt;br/&gt;分布式模式&lt;br/&gt;hbase的主从架构，hmaster作为主节点，hregionServer作为从节点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;宕机分为 HMaster 宕机和 HRegisoner 宕机，如果是HRegisoner 宕机， HMaster 会将其所管理的 region 重新分布到其他活动的
 RegionServer 上.

由于数据和日志都持久在 HDFS中，该操作不会导致数据丢失。所以数据的一致性和安全性是有保障的。

如果是 HMaster 宕机， HMaster 没有单点问题.

HBase 中可以启动多个 HMaster，通过Zookeeper 的 Master Election 机制保证总有一个 Master 运行。

即 ZooKeeper 会保证总会有一个 HMaster 在对外提供服务
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;参考文献&quot;&gt;参考文献&lt;/h3&gt;
&lt;p&gt;HBase权威指南(中文版) &lt;a href=&quot;https://pan.baidu.com/s/1EGhMdGeE4GcD8VpEcKQGkw&quot;&gt;提取码: nisk&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;HBase安装包 hbase-2.2.1-bin.tar&lt;a href=&quot;https://pan.baidu.com/s/1Es3Rg0owaWdklLJZJA39Ng&quot;&gt;提取码：utts&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;安装&quot;&gt;安装&lt;/h3&gt;
&lt;blockquote readability=&quot;7.1906005221932&quot;&gt;
&lt;p&gt;单机安装和分布式安装。&lt;br/&gt;在linux服务器中指定位置 wget &lt;a href=&quot;http://mirrors.tuna.tsinghua.edu.cn/apache/hbase/2.2.1/hbase-2.2.1-src.tar.gz&quot;&gt;http://mirrors.tuna.tsinghua.edu.cn/apache/hbase/2.2.1/hbase-2.2.1-src.tar.gz&lt;/a&gt; 。&lt;br/&gt;编辑conf/hbase-env.sh文件指定运行HBase的java环境。&lt;br/&gt;export JAVA_HOME=/usr/bin/java&lt;br/&gt;export HBASE_MANAGES_ZK=true 将zookeeper设置true(true使用hbase自带的zk,false使用自己安装的zk)&lt;br/&gt;修改配置hbase-site.xml&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;configuration&amp;gt;
        &amp;lt;property&amp;gt;
       &amp;lt;name&amp;gt;hbase.rootdir&amp;lt;/name&amp;gt;
          &amp;lt;value&amp;gt;file:////root/hbase-2.2.1-Data/HbaseData&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;!-- hbase zookeeper数据存储地址 --&amp;gt;
    &amp;lt;property&amp;gt;
        &amp;lt;name&amp;gt;hbase.zookeeper.property.dataDir&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;/root/hbase-2.2.1-Data/zkData&amp;lt;/value&amp;gt;
        &amp;lt;/property&amp;gt;
        &amp;lt;property&amp;gt;
        &amp;lt;name&amp;gt;hbase.cluster.distributed&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;true&amp;lt;/value&amp;gt;
        &amp;lt;/property&amp;gt;
        &amp;lt;!-- zookeeper集群的地址 --&amp;gt;
        &amp;lt;property&amp;gt;
        &amp;lt;name&amp;gt;hbase.zookeeper.quorum&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;47.105.153.163&amp;lt;/value&amp;gt;
        &amp;lt;/property&amp;gt;
        &amp;lt;!-- zookeeper集群的端口 --&amp;gt;
        &amp;lt;property&amp;gt;
        &amp;lt;name&amp;gt;hbase.zookeeper.property.clientPort&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;2183&amp;lt;/value&amp;gt;
        &amp;lt;/property&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;执行命令行 ./start-hbase.sh &amp;gt; console.out &amp;amp;&lt;br/&gt;单机下这就已经就可以启动了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;OpenJDK 64-Bit Server VM warning: If the number of processors is expected to increase from one, then you should configure the number of parallel GC threads appropriately 
using -XX:ParallelGCThreads=N
可能因为服务器内存不足。
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;下面是介绍集群环境下的hbase的环境的安装。&lt;br/&gt;conf/hbase-site.xml指定使用HDFS的/hbase目录作为根目录。HDFS的端口9000，数据只保留一个副本。&lt;br/&gt;hbase shell是hbase的命令行脚本&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;hbase原理&quot;&gt;hbase原理&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;hbase实时查询&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;可以认为是从内存中查询的，HBase的机制就是将数据先写入内存中，当数据量到达一定的量（128m）,在写入磁盘。，在内存中，是不进行数据的更新或者合并操作，只增加数据，使得用户写操作进入内存就可以立即返回。保证hbase的I/O的高性能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;hbase合并文件&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;Compact操作。当hbase中每当memstore数据flush到硬盘，形成storefile,当storefile的数量达到一定程度后，需要将storefile文件compact操作。&lt;br/&gt;compact操作：1 合并文件 2清除过期，多版本的数据 3 提高读写数据的效率&lt;br/&gt;二种方式 minor操作。和major操作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;Minor 操作只用来做部分文件的合并操作以及包括 minVersion=0 并且设置 ttl 的过期版本清理，不做任何删除数据、多版本数据的清理工作。
Major 操作是对 Region 下的 HStore 下的所有 StoreFile 执行合并操作，最终的结果是整理合并出一个文件。简述 Hbase filter 的实现原理是什么？结合实际项目经验，写出几个使用 filter 的场景HBase 为筛选数据提供了一组过滤器，通过这个过滤器可以在 HBase 中的数据的多个维度（行，列，数据版本）上进行对数据的筛选操作，也就是说过滤器最终能够筛选的数据能够细化到具体的一个存储单元格上（由行键，列名，时间戳定位）。 RowFilter、 PrefixFilter。。。hbase的filter是通过scan设置的，所以是基于scan的查询结果进行过滤.过滤器的类型很多，但是可以分为两大类——比较过滤器，专用过滤器过滤器的作用是在服务端判断数据是否满足条件，然后只将满足条件的数据返回给客户端；如在进行订单开发的时候，我们使用rowkeyfilter过滤出某个用户的所有订单 
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;hbase机制&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;在 HBase 中无论是增加新行还是修改已有行，其内部流程都是相同的。 HBase 接到命令后存下变化信息，或者写入失败抛出异常。默认情况下，执行写入时会写到两个地方：预写式日志（write-ahead log，也称 HLog）和 MemStore。 HBase 的默认方式是把写入动作记录在这两个地方，以保证数据持久化。只有当这两个地方的变化信息都写入并确认后，才认为写动作完成。MemStore 是内存里的写入缓冲区， HBase 中数据在永久写入硬盘之前在这里累积。当MemStore 填满后，其中的数据会刷写到硬盘，生成一个 HFile。 HFile 是 HBase 使用的底层存储格式。 HFile 对应于列族，一个列族可以有多个 HFile，但一个 HFile 不能存储多个列族的数据。在集群的每个节点上，每个列族有一个 MemStore。大型分布式系统中硬件故障很常见， HBase 也不例外。设想一下，如果 MemStore 还没有刷写，服务器就崩溃了，内存中没有写入硬盘的数据就会丢失。 HBase 的应对办法是在写动作完成之前先写入 WAL。 HBase 集群中每台服务器维护一个 WAL 来记录发生的变化。WAL 是底层文件系统上的一个文件。直到 WAL 新记录成功写入后，写动作才被认为成功完成。这可以保证 HBase 和支撑它的文件系统满足持久性。大多数情况下， HBase 使用Hadoop 分布式文件系统（HDFS）来作为底层文件系统。如果 HBase 服务器宕机，没有从 MemStore 里刷写到 HFile 的数据将可以通过回放WAL 来恢复。你不需要手工执行。 Hbase 的内部机制中有恢复流程部分来处理。每台HBase 服务器有一个 WAL，这台服务器上的所有表（和它们的列族）共享这个 WAL。你可能想到，写入时跳过 WAL 应该会提升写性能。但我们不建议禁用 WAL，除非你愿意在出问题时丢失数据。如果你想测试一下，如下代码可以禁用 WAL： 注意：不写入 WAL 会在 RegionServer 故障时增加丢失数据的风险。关闭 WAL，出现故障时 HBase 可能无法恢复数据，没有刷写到硬盘的所有写入数据都会丢失。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;</description>
<pubDate>Mon, 30 Nov 2020 22:30:00 +0000</pubDate>
<dc:creator>jack_zdl</dc:creator>
<og:description>hbase是大数据的生态的一部分，是高可靠性、高性能、列存储、可伸缩、实时读写的数据库系统。介于nosql和RDBMS之间。主要存储非结构化和半结构化的松散数据。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/smartzhang/p/14066014.html</dc:identifier>
</item>
<item>
<title>微前端大赏二-singlespa实践 - 张泰峰</title>
<link>http://www.cnblogs.com/ztfjs/p/single-spa2.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ztfjs/p/single-spa2.html</guid>
<description>&lt;p class=&quot;sync-line&quot; data-line=&quot;3&quot;&gt; &lt;/p&gt;


&lt;p&gt;singleSpa是一个javascript库&lt;br/&gt;它可以让很多小页面、小的组件、不同架构的前端组件在一个页面应用程序中共存。&lt;/p&gt;
&lt;p&gt;这里有一个演示: (&lt;a href=&quot;https://single-spa.surge.sh/&quot;&gt;https://single-spa.surge.sh/&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;这个库可以让你的应用可以使用多个不同的技术栈（vue、react、angular等等）,这样我们就可以做同步开发，最后再使用一个公用的路由即可实现路由完美切换。也可以使用一样的技术栈，分不同的团队进行开发，只需要最后使用这个库把它们整合在一起，设置不用的路由名称就可以了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点:&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;敏捷&lt;br/&gt;独立开发和更快的部署周期： 开发团队可以选择自己的技术并及时更新技术栈。 一旦完成其中一项就可以部署，而不必等待所有事情完毕。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;风险下降&lt;br/&gt;降低错误和回归问题的风险，相互之间的依赖性急剧下降。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;更小单元&lt;br/&gt;更简单快捷的测试，每一个小的变化不必再触碰整个应用程序。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;持续交付&lt;br/&gt;更快交付客户价值，有助于持续集成、持续部署以及持续交付。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;配置复杂&lt;br/&gt;singlespa相对来说配置复杂，当然我们还有更简单一点的qiankun，也可以基于singlespa封装一套更适合自己的框架。&lt;/li&gt;
&lt;li&gt;一定的资源浪费&lt;br/&gt;由于核心逻辑还是在于请求manifest，拿到js文件后执行渲染，这个过程不可避免会产生一些冗余，对于C端的应用来说，这个问题比较致命，当然，对于B端来说，这个是可以接受的，在可控制的范围之内&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;sync-line&quot; data-line=&quot;32&quot;&gt; &lt;/p&gt;

&lt;p&gt;几张图可以解决singleSpa的核心逻辑&lt;br/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/ztfjs/841508/o_2011301725479072df3196964d51abc0e7f250332962.jpg&quot; alt=&quot;avatar&quot;/&gt;&lt;br/&gt;第一张图，很显然，第一步，在我们的webpack应用里生成一个manifest.json文件，这个文件内容差不多如下：&lt;/p&gt;
&lt;p class=&quot;sync-line&quot; data-line=&quot;36&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;files&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;static/js/0.chunk.js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/static/js/0.chunk.js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;static/js/0.chunk.js.map&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/static/js/0.chunk.js.map&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;static/js/1.chunk.js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/static/js/1.chunk.js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;static/js/1.chunk.js.map&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/static/js/1.chunk.js.map&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;main.js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/static/js/main.chunk.js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;main.js.map&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/static/js/main.chunk.js.map&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;runtime-main.js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/static/js/bundle.js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;runtime-main.js.map&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/static/js/bundle.js.map&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;index.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/index.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;static/media/logo.svg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/static/media/logo.103b5fa1.svg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  },
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;entrypoints&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: [
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;static/js/bundle.js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;static/js/0.chunk.js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;static/js/main.chunk.js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  ]
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;关键点在 entrypoints 这个属性，我们可以通过manifest拿到项目的依赖表并可以使用script标签动态加载出来，这个时候我们就可以实现动态加载不同的微前端应用了。&lt;/p&gt;
&lt;p class=&quot;sync-line&quot; data-line=&quot;59&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/ztfjs/841508/o_201130174007%E6%97%A0%E6%A0%87%E9%A2%98%E7%BB%98%E5%9B%BE.jpg&quot; alt=&quot;avatar&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;sync-line&quot; data-line=&quot;60&quot;&gt; &lt;/p&gt;
&lt;p&gt;第二张图，我画出了更加具体的，singlespa在渲染过程中的核心逻辑&lt;br/&gt;1、 首先我们有 main（主app） child（子app），主app只有一个，子app可以有多个&lt;br/&gt;2、 其次，主app上一般我们可以在index.html里面，写多几个空间，也就是多几个div&lt;br/&gt;例如：&lt;/p&gt;
&lt;p class=&quot;sync-line&quot; data-line=&quot;65&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=”react-app”&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=”vue-app”&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;3、然后，在我们的child上，我们要用webpack插件，生成一个带有所有需要加载的依赖文件的manifest.json&lt;br/&gt;4、主应用去加载这个manifest.json，获取到具体的js，使用script标签把它放到主应用上，进行渲染&lt;/p&gt;
&lt;p&gt;至此我们就可以完全搞清楚，为什么singlespa这么神奇了，接下来让我们搭建一个简易版的singlespa&lt;/p&gt;
&lt;p class=&quot;sync-line&quot; data-line=&quot;74&quot;&gt; &lt;/p&gt;

&lt;p class=&quot;sync-line&quot; data-line=&quot;76&quot;&gt; &lt;/p&gt;
&lt;h4 id=&quot;vue-main&quot; class=&quot;mume-header&quot;&gt;vue main&lt;/h4&gt;
&lt;p&gt;由于我们需要使用webpack配置，而最新版本的vue-cli默认只有babel，我们用这个步骤来安装一个vue版本的main&lt;br/&gt;1、装包&lt;/p&gt;
&lt;p class=&quot;sync-line&quot; data-line=&quot;79&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 npm install @vue/cli @vue/cli-init  -g
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2、创建一个项目&lt;/p&gt;
&lt;p class=&quot;sync-line&quot; data-line=&quot;84&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
vue init webpack demo-single
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;3、cd demo-single&lt;/p&gt;
&lt;p&gt;4、装包&lt;/p&gt;
&lt;p class=&quot;sync-line&quot; data-line=&quot;91&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
npm i single-spa single-spa-vue axios --save
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;5、在src目录创建一个singlespa配置文件 single-spa-config.js&lt;/p&gt;
&lt;p class=&quot;sync-line&quot; data-line=&quot;96&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; single-spa-config.js&lt;/span&gt;
    import * as singleSpa from 'single-spa'; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;导入single-spa&lt;/span&gt;
    import axios from 'axios'

    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
        runScript：
        一个promise同步方法。可以代替创建一个script标签，然后加载服务
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    const runScript &lt;/span&gt;= async (url) =&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Promise((resolve, reject) =&amp;gt;&lt;span&gt; {
            const script &lt;/span&gt;= document.createElement('script'&lt;span&gt;);
            script.src &lt;/span&gt;=&lt;span&gt; url;
            script.onload &lt;/span&gt;=&lt;span&gt; resolve;
            script.onerror &lt;/span&gt;=&lt;span&gt; reject;
            const firstScript &lt;/span&gt;= document.getElementsByTagName('script')[0&lt;span&gt;];
            firstScript.parentNode.insertBefore(script, firstScript);
        });
    };

    const getManifest &lt;/span&gt;= (url, bundle) =&amp;gt; &lt;span&gt;new&lt;/span&gt; Promise(async (resolve) =&amp;gt;&lt;span&gt; {
        const { data } &lt;/span&gt;=&lt;span&gt; await axios.get(url);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; eslint-disable-next-line no-console&lt;/span&gt;
        const { entrypoints } =&lt;span&gt; data;

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (let i = 0; i &amp;lt; entrypoints.length; i++&lt;span&gt;) {
            await runScript(&lt;/span&gt;'http://127.0.0.1:3000/' + entrypoints[i]).then(() =&amp;gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i === entrypoints.length - 1&lt;span&gt;) {
                    resolve()
                }
            })
        }
    });

    singleSpa.registerApplication( &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注册微前端服务&lt;/span&gt;
        'singleDemoVue', async () =&amp;gt;&lt;span&gt; {
            let singleVue &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            await getManifest(&lt;/span&gt;'http://127.0.0.1:3000/asset-manifest.json').then(() =&amp;gt;&lt;span&gt; {
                singleVue &lt;/span&gt;=&lt;span&gt; window.singleReact;
            });
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; singleVue;    
        },
        location &lt;/span&gt;=&amp;gt; location.pathname.startsWith('/react') &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 配置前缀&lt;/span&gt;
&lt;span&gt;    );

    singleSpa.start(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 启动&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;注： 可以看到，runScript就是个创建script标签的方法，getManifest是一个简单的获取manifest并创建script的方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;6、在main.js里引入这个文件&lt;/p&gt;
&lt;p class=&quot;sync-line&quot; data-line=&quot;146&quot;&gt; &lt;/p&gt;
&lt;pre class=&quot;language-&quot; data-role=&quot;codeBlock&quot; data-info=&quot;&quot;&gt;
&lt;code&gt;import './single-spa-config'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;7、运行&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
npm run dev
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;最终得到这样一个工程&lt;/p&gt;
&lt;p class=&quot;sync-line&quot; data-line=&quot;155&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/ztfjs/841508/o_201130181531fc277894-9970-4acc-9170-0aef2e457fd5.png&quot; alt=&quot;avatar&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;sync-line&quot; data-line=&quot;156&quot;&gt; &lt;/p&gt;
&lt;p&gt;这样我们就完成了一个入口的配置，当然它还很简单，更复杂的操作我们应该放在具体的工程上去做&lt;/p&gt;
&lt;p class=&quot;sync-line&quot; data-line=&quot;160&quot;&gt; &lt;/p&gt;

&lt;p&gt;上面的代码可以看到，我们register了一个react应用 &lt;a href=&quot;http://127.0.0.1:3000/asset-manifest.json&quot;&gt;http://127.0.0.1:3000/asset-manifest.json&lt;/a&gt; 并且访问了它的manifest文件，现在我们需要创建一个react子应用，也是直接通过几个步骤来完成，我们使用create-react-app来快速搭建：&lt;/p&gt;
&lt;p&gt;1、装包&lt;/p&gt;
&lt;p class=&quot;sync-line&quot; data-line=&quot;165&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
npm install create-react-app -g
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2、创建&lt;/p&gt;
&lt;p class=&quot;sync-line&quot; data-line=&quot;169&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
npx create-react-app my-app
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;3、创建完成后，注意我们需要对webpack做一点修改，默认create-react-app会有一个git本地分支，让我们先提交到本地仓库一下&lt;/p&gt;
&lt;p class=&quot;sync-line&quot; data-line=&quot;173&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;git status
git add .&lt;/span&gt;/&lt;span&gt;
git commit &lt;/span&gt;-m ttt
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;4、拿到webpack配置文件，create-react-app默认隐藏了webpack配置文件&lt;/p&gt;
&lt;p class=&quot;sync-line&quot; data-line=&quot;179&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
yarn eject 或 npm run eject
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;5、修改webpack文件&lt;br/&gt;修改 /config/webpack.config.js 在output增加：&lt;/p&gt;
&lt;p class=&quot;sync-line&quot; data-line=&quot;184&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;output: {
    ... 这里忽略了原有的
    library: &lt;/span&gt;'singleReact'&lt;span&gt;,
    libraryTarget: &lt;/span&gt;'window'&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/ztfjs/841508/o_2011301817110891255a-2940-44f5-a1b1-6bec5423c06d.png&quot; alt=&quot;avatar&quot;/&gt;&lt;/p&gt;
&lt;p&gt;修改 /scripts/start.js文件，在const devServer = new ...这个地方，增加一个header的设置：&lt;/p&gt;
&lt;p class=&quot;sync-line&quot; data-line=&quot;195&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
const devServer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WebpackDevServer(compiler, {
      ...serverConfig,
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里上增加的header设置&lt;/span&gt;
&lt;span&gt;      headers: {
        &lt;/span&gt;'Access-Control-Allow-Origin': '*'&lt;span&gt;,
      }
  
    });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/ztfjs/841508/o_20113018181813834fbd-2943-4980-aa4c-a0038b242b66.png&quot; alt=&quot;avatar&quot;/&gt;&lt;/p&gt;
&lt;p&gt;6、修改src/index.js&lt;br/&gt;一个是要把root改为动态渲染，一个是注册生命周期&lt;/p&gt;
&lt;p class=&quot;sync-line&quot; data-line=&quot;209&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
import React from 'react'&lt;span&gt;;
import ReactDOM from &lt;/span&gt;'react-dom'&lt;span&gt;;
import &lt;/span&gt;'./index.css'&lt;span&gt;;
import App from &lt;/span&gt;'./App'&lt;span&gt;;
import reportWebVitals from &lt;/span&gt;'./reportWebVitals'&lt;span&gt;;
import singleSpaReact, {SingleSpaContext} from &lt;/span&gt;'single-spa-react'&lt;span&gt;;

const rootComponent &lt;/span&gt;= () =&amp;gt;&lt;span&gt; {
  ReactDOM.render(
      &lt;/span&gt;&amp;lt;React.StrictMode&amp;gt;
        &amp;lt;App /&amp;gt;
      &amp;lt;/React.StrictMode&amp;gt;
&lt;span&gt;    ,
    document.getElementById(&lt;/span&gt;'react-root'&lt;span&gt;)
  );
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ReactDOM.render(&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;   ,&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;   document.getElementById('root')&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; );&lt;/span&gt;
&lt;span&gt;

const reactLifecycles &lt;/span&gt;=&lt;span&gt; singleSpaReact({
  React,
  ReactDOM,
  rootComponent,
  errorBoundary(err, info, props) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; https://reactjs.org/docs/error-boundaries.html&lt;/span&gt;
&lt;span&gt;    console.error(err)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (
      &lt;/span&gt;&amp;lt;div&amp;gt;This renders when a catastrophic error occurs&amp;lt;/div&amp;gt;
&lt;span&gt;    );
  },
});
export const bootstrap &lt;/span&gt;=&lt;span&gt; reactLifecycles.bootstrap;
export const mount &lt;/span&gt;=&lt;span&gt; reactLifecycles.mount;
export const unmount &lt;/span&gt;=&lt;span&gt; reactLifecycles.unmount;


&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; If you want to start measuring performance in your app, pass a function&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; to log results (for example: reportWebVitals(console.log))&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals&lt;/span&gt;
reportWebVitals();
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;7、运行&lt;br/&gt;npm run start&lt;/p&gt;
&lt;p&gt;8、在main的vue那里，访问/react 你会看到下面有一个react渲染和vue的一起出现，大功告成&lt;/p&gt;
&lt;p class=&quot;sync-line&quot; data-line=&quot;262&quot;&gt; &lt;/p&gt;

&lt;p&gt;生命周期函数共有4个：bootstrap、mount、unmount、update。生命周期可以传入 返回Promise的函数也可以传入 返回Promise函数的数组。&lt;br/&gt;引用一个大佬完整的说明, 非常的详细：&lt;br/&gt;&lt;a href=&quot;https://github.com/YataoZhang/my-single-spa/issues/4&quot;&gt;https://github.com/YataoZhang/my-single-spa/issues/4&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;sync-line&quot; data-line=&quot;267&quot;&gt; &lt;/p&gt;

&lt;p&gt;single spa可以给我们提供一整套方案，去搭建一套微前端集成框架，但它并不是一个开箱即用的封装，它有很多的坑等着我们去踩。&lt;br/&gt;一般情况下，我们选择使用qiankun，它的封装程度更好，api更加友好一些。待积攒足够多的使用经验，可以考虑自研一套自己的微前端框架，增加整体的前端研发效率。&lt;br/&gt;下节我将给大家带来qiankun对singlespa的封装，在具体应用中的实践。待完结框架篇后，我们可以再深入探究singlespa的实现原理以及各种概念。&lt;/p&gt;
&lt;p class=&quot;sync-line&quot; data-line=&quot;272&quot;&gt; &lt;/p&gt;

&lt;p&gt;single-spa 文档: &lt;a href=&quot;https://single-spa.js.org/docs/getting-started-overview/&quot;&gt;https://single-spa.js.org/docs/getting-started-overview/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;微前端 single-spa: &lt;a href=&quot;https://juejin.cn/post/6844903896884707342&quot;&gt;https://juejin.cn/post/6844903896884707342&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这可能是你见过最完善的微前端解决方案！: &lt;a href=&quot;https://www.infoq.cn/article/o6GxRD9iHQOplKICiDDU&quot;&gt;https://www.infoq.cn/article/o6GxRD9iHQOplKICiDDU&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;single-spa微前端: &lt;a href=&quot;http://www.soulapp.tech/2019/09/25/single-spa%E5%BE%AE%E5%89%8D%E7%AB%AF/&quot;&gt;http://www.soulapp.tech/2019/09/25/single-spa微前端/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Single-Spa + Vue Cli 微前端落地指南 (项目隔离远程加载，自动引入) : &lt;a href=&quot;https://juejin.cn/post/6844904025565954055&quot;&gt;https://juejin.cn/post/6844904025565954055&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 30 Nov 2020 21:24:00 +0000</pubDate>
<dc:creator>张泰峰</dc:creator>
<og:description>微前端大赏二-singlespa实践 微前端大赏二-singlespa实践 序 介绍singleSpa singleSpa核心逻辑 搭建环境 vue main react child 生命周期 结论</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ztfjs/p/single-spa2.html</dc:identifier>
</item>
<item>
<title>【抓取】6-DOF GraspNet 论文解读 - 时光清浅，岁月嫣然</title>
<link>http://www.cnblogs.com/hatimwen/p/6dofgraspnet.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hatimwen/p/6dofgraspnet.html</guid>
<description>&lt;p&gt;&lt;strong&gt;【注】：本文地址：&lt;a href=&quot;https://www.cnblogs.com/hatimwen/p/6dofgraspnet.html&quot;&gt;【抓取】6-DOF GraspNet 论文解读&lt;/a&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;若转载请于明显处标明出处。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;这篇关于生成抓取姿态的论文出自英伟达。我在读完该篇论文后我简单地对其进行一些概述，如有错误纰漏请指正！&lt;/p&gt;
&lt;h2 id=&quot;论文概要&quot;&gt;论文概要&lt;/h2&gt;
&lt;p&gt;生成抓握姿势是机器人物体操纵任务的关键组成部分。 在本工作中，作者提出了抓取生成问题，即使用&lt;strong&gt;变分自动编码器&lt;/strong&gt;对一组抓取进行采样，并利用&lt;strong&gt;抓取评估器模型&lt;/strong&gt;对采样抓取进行&lt;strong&gt;评估&lt;/strong&gt;和&lt;strong&gt;微调细化&lt;/strong&gt;。 抓取采样器和抓取refine网络都以深度相机观察到的&lt;strong&gt;三维点云作为输入&lt;/strong&gt;。 作者评估了在模拟和现实世界机器人实验中的方法。 其方法在具有不同外观、尺度和权重的各种常用对象上获得&lt;strong&gt;88%的成功率&lt;/strong&gt;。 作者直接在模拟环境中训练而在现实场景下进行实验测试，这其中没有任何额外的步骤。&lt;/p&gt;
&lt;h2 id=&quot;整体网络概述&quot;&gt;整体网络概述&lt;/h2&gt;
&lt;p&gt;整体网络结构如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201130231941874.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhdGltOTg=,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先，输入三维点云，通过 Grasp Sampler 也就是抓取采样网络，得到多个抓取；然后通过一个 Grasp Evaluater ，评估上一步生成的抓取的成功与否；在评估这一步中，通过 Grasp Refinement 将估计的抓取结果进行微调，使其更贴近于合理抓取，进一步地增大了抓取的成功率。&lt;/p&gt;
&lt;p&gt;下面具体来讲一下每一部分。&lt;/p&gt;
&lt;h2 id=&quot;variational-grasp-sampler&quot;&gt;Variational Grasp Sampler&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201130232015338.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhdGltOTg=,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;抓取采样网络本质上是一个VAE，也就是变分自编码器。输入 &lt;span class=&quot;math inline&quot;&gt;\(X\)&lt;/span&gt; 是对原始目标三维点云采样得到的各个视角下的目标点云， &lt;span class=&quot;math inline&quot;&gt;\(g\)&lt;/span&gt; 其实就是抓取姿态，也就是抓取器在目标坐标系下的 &lt;span class=&quot;math inline&quot;&gt;\(R\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(T\)&lt;/span&gt;。通过VAE的编码器Q，将输入编码到隐层空间，得到低维度的隐层变量 &lt;span class=&quot;math inline&quot;&gt;\(z\)&lt;/span&gt; ，使其满足&lt;strong&gt;单位高斯分布&lt;/strong&gt;；然后再通过对隐层变量 &lt;span class=&quot;math inline&quot;&gt;\(z\)&lt;/span&gt; 解码，得到与输入相近的 &lt;span class=&quot;math inline&quot;&gt;\(g\)&lt;/span&gt; 。整个VAE的训练过程就是让z尽量服从上面所说的单位高斯分布，所以在测试的时候，去掉Encoder，直接在单位高斯分布中随机取样，取代了需要编码得到的隐层变量 &lt;span class=&quot;math inline&quot;&gt;\(z\)&lt;/span&gt; ，再加上输入点云 &lt;span class=&quot;math inline&quot;&gt;\(X\)&lt;/span&gt; ，就可以得到网络所认为的绝对正确的重建抓取 &lt;span class=&quot;math inline&quot;&gt;\(\hat{g}\)&lt;/span&gt; 。在训练中，VAE的损失函数如下：&lt;/p&gt;
&lt;p&gt;\[\mathcal{L}_{\mathrm{vae}}=\sum_{z \sim Q, g \sim G^{*}} \mathcal{L}(\hat{g}, g)-\alpha \mathcal{D}_{K L}[Q(z \mid X, g), \mathcal{N}(0, I)] \]&lt;/p&gt;
&lt;p&gt;该式采用随机梯度下降优化。 对于每个mini-batch，点云 &lt;span class=&quot;math inline&quot;&gt;\(X\)&lt;/span&gt; 从随机视点观察采样。 对于采样点云 &lt;span class=&quot;math inline&quot;&gt;\(X\)&lt;/span&gt; ，抓取 &lt;span class=&quot;math inline&quot;&gt;\(g\)&lt;/span&gt; 从Ground Truth集合&lt;span class=&quot;math inline&quot;&gt;\(G^{*}\)&lt;/span&gt;采用分层采样。&lt;br/&gt;上式中的 &lt;span class=&quot;math inline&quot;&gt;\(\mathcal{L}(g, \hat{g})\)&lt;/span&gt; 具体式子如下：&lt;/p&gt;
&lt;p&gt;\[\mathcal{L}(g, \hat{g})=\frac{1}{n} \sum\|\mathcal{T}(g ; p)-\mathcal{T}(\hat{g} ; p)\|_{1} \]&lt;/p&gt;
&lt;p&gt;此式约束重建抓取与输入抓取相近。 &lt;span class=&quot;math inline&quot;&gt;\(\mathcal{T}(\cdot ; p)\)&lt;/span&gt; 是机器人夹持器上一组预定义点 &lt;span class=&quot;math inline&quot;&gt;\(p\)&lt;/span&gt; 的变换，什么意思呢？换句话说就是，在目标坐标系中，把抓取器的模型通过 &lt;span class=&quot;math inline&quot;&gt;\(R\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(T\)&lt;/span&gt; 作变换，从而转变为目标坐标系下的抓取器点云。&lt;/p&gt;
&lt;h2 id=&quot;grasp-pose-evaluation&quot;&gt;Grasp Pose Evaluation&lt;/h2&gt;
&lt;p&gt;因为前一步生成的抓取在网络看来他一定是正确的（因为他认为自己的 &lt;span class=&quot;math inline&quot;&gt;\(z\)&lt;/span&gt; 服从单位高斯分布，那么从单位高斯分布中取样重建出的 &lt;span class=&quot;math inline&quot;&gt;\(\hat{g}\)&lt;/span&gt; 一定是正确的抓取），所以实际上要想知道生成的抓取在我们看来是否可行，就还需要加一个判断。因此作者在抓取采样网络之后加了个抓取姿态评估网络。&lt;/p&gt;
&lt;p&gt;整个评估网络实质上是一个&lt;strong&gt;二分类网络&lt;/strong&gt;，输入是目标和抓取器的合成渲染点云 &lt;span class=&quot;math inline&quot;&gt;\(X \cup X_{g}\)&lt;/span&gt; ，输出是成功率 &lt;span class=&quot;math inline&quot;&gt;\(s\)&lt;/span&gt; 。利用&lt;strong&gt;交叉熵损失&lt;/strong&gt;优化抓取评价网络：&lt;/p&gt;
&lt;p&gt;\[\mathcal{L}_{\text {evaluator }}=-(y \log (s)+(1-y) \log (1-s)) \]&lt;/p&gt;
&lt;p&gt;式中 &lt;span class=&quot;math inline&quot;&gt;\(y\)&lt;/span&gt; 是抓取的Ground Truth二进制标签，1/0 代表 成功/失败。&lt;/p&gt;
&lt;p&gt;在训练中采取了hard negative mining（有翻译叫他难负例挖掘），简单俩说就是建立了一个错题集 &lt;span class=&quot;math inline&quot;&gt;\(G^{-}\)&lt;/span&gt; ：&lt;/p&gt;
&lt;p&gt;\[G^{-}=\left\{g^{-} \mid \exists g \in G^{*}: \mathcal{L}\left(g, g^{-}\right)&amp;lt;\epsilon\right\} \]&lt;/p&gt;
&lt;p&gt;在训练过程中，这个错题集中包含：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;从一组预先生成的负抓取中采样 &lt;span class=&quot;math inline&quot;&gt;\(g^{-}\)&lt;/span&gt; ;&lt;/li&gt;
&lt;li&gt;或者通过随机扰动正抓取集 &lt;span class=&quot;math inline&quot;&gt;\(G^{*}\)&lt;/span&gt; 中的 &lt;span class=&quot;math inline&quot;&gt;\(g\)&lt;/span&gt; 使夹持器的网格要么与物体网格碰撞，要么将夹持器网格远离物体。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;iterative-grasp-pose-refinement&quot;&gt;Iterative Grasp Pose Refinement&lt;/h2&gt;
&lt;p&gt;前面说完了，这一部分我觉得才是重点部分！通过前面的评估，已经得到了一些成功和失败的抓取例子，那么怎么提高成功率呢？换句话说，怎么让估计出来的抓取 &lt;span class=&quot;math inline&quot;&gt;\(g\)&lt;/span&gt; 更好呢？&lt;/p&gt;
&lt;p&gt;为了达到这个目的，作者想到了一个巧妙的办法，既然评估网络中的 &lt;span class=&quot;math inline&quot;&gt;\(s\)&lt;/span&gt; 越大代表越可能成功，那么使得这些 &lt;span class=&quot;math inline&quot;&gt;\(s\)&lt;/span&gt; 都尽可能地变大并且趋近于1也就能让抓取 &lt;span class=&quot;math inline&quot;&gt;\(g\)&lt;/span&gt; 更好了呗~&lt;/p&gt;
&lt;p&gt;实际上这就代表了能让 &lt;span class=&quot;math inline&quot;&gt;\(s\)&lt;/span&gt; 相对于 &lt;span class=&quot;math inline&quot;&gt;\(g\)&lt;/span&gt; 的函数 &lt;span class=&quot;math inline&quot;&gt;\(S\)&lt;/span&gt; 值变大的方向。这个方向就是 &lt;span class=&quot;math inline&quot;&gt;\(S\)&lt;/span&gt; 相对于 &lt;span class=&quot;math inline&quot;&gt;\(g\)&lt;/span&gt; 的梯度方向，也就得到了下面的式子：&lt;/p&gt;
&lt;p&gt;\[\Delta g=\frac{\partial S}{\partial g}=\eta \times \frac{\partial S}{\partial \mathcal{T}(g ; p)} \times \frac{\partial \mathcal{T}(g ; p)}{\partial g} \]&lt;/p&gt;
&lt;p&gt;如果上面不理解，也没关系，有点绕口。我说一个一维曲线的例子。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201201001710564.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhdGltOTg=,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，&lt;span class=&quot;math inline&quot;&gt;\(y=f(\theta x)\)&lt;/span&gt; 代表拟合出来的曲线，其中 &lt;span class=&quot;math inline&quot;&gt;\(\theta\)&lt;/span&gt; 代表 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt; 的系数（等同于网络的权重参数）。现在假如输入是 &lt;span class=&quot;math inline&quot;&gt;\(x_{1}\)&lt;/span&gt; ，输出是 &lt;span class=&quot;math inline&quot;&gt;\(y_{1}\)&lt;/span&gt;，然后我已知 &lt;span class=&quot;math inline&quot;&gt;\(y_{2}\)&lt;/span&gt; 是一个更好更大的输出值，那么我就需要改变 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt; 的值，让 &lt;span class=&quot;math inline&quot;&gt;\(x_{1}\)&lt;/span&gt; 变成 &lt;span class=&quot;math inline&quot;&gt;\(x_{2}\)&lt;/span&gt; ：&lt;/p&gt;
&lt;p&gt;\[x_{2}=x_{1}+\Delta x \]&lt;/p&gt;
&lt;p&gt;那么变化量 &lt;span class=&quot;math inline&quot;&gt;\(\Delta x\)&lt;/span&gt; 怎么得到呢？在这个例子里， &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt; 变化无非两种情况，要么变大要么变小，要想知道我们需要他变大还是变小，只需要让函数 &lt;span class=&quot;math inline&quot;&gt;\(f\)&lt;/span&gt; 对 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt; 求导就得到了斜率，斜率就指明了 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt; 变化方向。在这个例子里面 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt; 变化方向是 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt; 轴的正方向。得到了变化方向我们乘上一个步长 &lt;span class=&quot;math inline&quot;&gt;\(\eta\)&lt;/span&gt; 就得到了我们需要的变化量 &lt;span class=&quot;math inline&quot;&gt;\(\Delta x\)&lt;/span&gt; ：&lt;/p&gt;
&lt;p&gt;\[\frac{\partial f}{\partial x} \cdot \eta=\Delta x \]&lt;/p&gt;
&lt;h2 id=&quot;experiments&quot;&gt;Experiments&lt;/h2&gt;
&lt;p&gt;实验部分暂时不说了，作者说这抓取效果就是好反正。其他自对比实验也很有意义，有空再更。&lt;/p&gt;
</description>
<pubDate>Mon, 30 Nov 2020 16:39:00 +0000</pubDate>
<dc:creator>时光清浅，岁月嫣然</dc:creator>
<og:description>6-DOF GraspNet 论文解读</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hatimwen/p/6dofgraspnet.html</dc:identifier>
</item>
<item>
<title>Prometheus+Grafana+Alertmanager实现告警推送教程 ----- 图文详解 - 虚无境</title>
<link>http://www.cnblogs.com/xuwujing/p/14065740.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuwujing/p/14065740.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;本文主要介绍的是Prometheus采集数据，通过Grafana加上PromQL语句实现数据可视化以及通过Alertmanage实现告警推送功能。温馨提示，本篇文章特长，2w多的文字加上几十张图片，建议收藏观看。&lt;/p&gt;
&lt;h2 id=&quot;prometheus-介绍&quot;&gt;Prometheus 介绍&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Prometheus 是一套开源的系统监控报警框架。它启发于 Google 的 borgmon 监控系统，由工作在 SoundCloud 的 google 前员工在 2012 年创建，作为社区开源项目进行开发，并于 2015 年正式发布。2016 年，Prometheus 正式加入 Cloud Native Computing Foundation，成为受欢迎度仅次于 Kubernetes 的项目。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;作为新一代的监控框架，Prometheus 具有以下特点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;强大的多维度数据模型： 时间序列数据通过 metric 名和键值对来区分。 所有的 metrics 都可以设置任意的多维标签。&lt;/li&gt;
&lt;li&gt;数据模型更随意，不需要刻意设置为以点分隔的字符串。 可以对数据模型进行聚合，切割和切片操作。&lt;/li&gt;
&lt;li&gt;支持双精度浮点类型，标签可以设为全unicode。 灵活而强大的查询语句（PromQL）：在同一个查询语句，可以对多个 metrics进行乘法、加法、连接、取分数位等操作。&lt;/li&gt;
&lt;li&gt;易于管理： Prometheus server是一个单独的二进制文件，可直接在本地工作，不依赖于分布式存储。 高效：平均每个采样点仅占 3.5 bytes，且一个 Prometheus server 可以处理数百万的 metrics。 使用 pull模式采集时间序列数据，这样不仅有利于本机测试而且可以避免有问题的服务器推送坏的 metrics。 可以采用 push gateway 的方式把时间序列数据推送至 Prometheus server 端。 可以通过服务发现或者静态配置去获取监控的 targets。&lt;/li&gt;
&lt;li&gt;有多种可视化图形界面。 易于伸缩。 需要指出的是，由于数据采集可能会有丢失，所以 Prometheus 不适用对采集数据要 100%&lt;/li&gt;
&lt;li&gt;准确的情形。但如果用于记录时间序列数据，Prometheus 具有很大的查询优势，此外，Prometheus 适用于微服务的体系架构。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;示例图:&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201130161151142.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;prometheus的适用场景&quot;&gt;Prometheus的适用场景&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;在选择Prometheus作为监控工具前，要明确它的适用范围，以及不适用的场景。&lt;br/&gt;Prometheus在记录纯数值时间序列方面表现非常好。它既适用于以服务器为中心的监控，也适用于高动态的面向服务架构的监控。&lt;br/&gt;在微服务的监控上，Prometheus对多维度数据采集及查询的支持也是特殊的优势。&lt;br/&gt;Prometheus更强调可靠性，即使在故障的情况下也能查看系统的统计信息。权衡利弊，以可能丢失少量数据为代价确保整个系统的可用性。因此，它不适用于对数据准确率要求100%的系统，比如实时计费系统（涉及到钱）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;prometheus核心组件介绍&quot;&gt;Prometheus核心组件介绍&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Prometheus Server:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Prometheus Server是Prometheus组件中的核心部分，负责实现对监控数据的获取，存储以及查询。 Prometheus Server可以通过静态配置管理监控目标，也可以配合使用Service Discovery的方式动态管理监控目标，并从这些监控目标中获取数据。其次Prometheus Server需要对采集到的监控数据进行存储，Prometheus Server本身就是一个时序数据库，将采集到的监控数据按照时间序列的方式存储在本地磁盘当中。最后Prometheus Server对外提供了自定义的PromQL语言，实现对数据的查询以及分析。 Prometheus Server内置的Express Browser UI，通过这个UI可以直接通过PromQL实现数据的查询以及可视化。 Prometheus Server的联邦集群能力可以使其从其他的Prometheus Server实例中获取数据，因此在大规模监控的情况下，可以通过联邦集群以及功能分区的方式对Prometheus Server进行扩展。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Exporters:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Exporter将监控数据采集的端点通过HTTP服务的形式暴露给Prometheus Server，Prometheus&lt;br/&gt;Server通过访问该Exporter提供的Endpoint端点，即可获取到需要采集的监控数据。 一般来说可以将Exporter分为2类：&lt;br/&gt;直接采集：这一类Exporter直接内置了对Prometheus监控的支持，比如cAdvisor，Kubernetes，Etcd，Gokit等，都直接内置了用于向Prometheus暴露监控数据的端点。&lt;br/&gt;间接采集：间接采集，原有监控目标并不直接支持Prometheus，因此我们需要通过Prometheus提供的Client Library编写该监控目标的监控采集程序。例如： Mysql Exporter，JMX Exporter，Consul Exporter等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;PushGateway:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;在Prometheus Server中支持基于PromQL创建告警规则，如果满足PromQL定义的规则，则会产生一条告警，而告警的后续处理流程则由AlertManager进行管理。在AlertManager中我们可以与邮件，Slack等等内置的通知方式进行集成，也可以通过Webhook自定义告警处理方式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Service Discovery:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;服务发现在Prometheus中是特别重要的一个部分，基于Pull模型的抓取方式，需要在Prometheus中配置大量的抓取节点信息才可以进行数据收集。有了服务发现后，用户通过服务发现和注册的工具对成百上千的节点进行服务注册，并最终将注册中心的地址配置在Prometheus的配置文件中，大大简化了配置文件的复杂程度，&lt;br/&gt;也可以更好的管理各种服务。 在众多云平台中（AWS,OpenStack），Prometheus可以&lt;br/&gt;通过平台自身的API直接自动发现运行于平台上的各种服务，并抓取他们的信息Kubernetes掌握并管理着所有的容器以及服务信息，那此时Prometheus只需要与Kubernetes打交道就可以找到所有需要监控的容器以及服务对象.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Consul（官方推荐）等服务发现注册软件&lt;/li&gt;
&lt;li&gt;通过DNS进行服务发现&lt;/li&gt;
&lt;li&gt;通过静态配置文件（在服务节点规模不大的情况下）&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;prometheus-ui&quot;&gt;Prometheus UI&lt;/h3&gt;
&lt;p&gt;Prometheus UI是Prometheus内置的一个可视化管理界面，通过Prometheus UI用户能够轻松的了解Prometheus当前的配置，监控任务运行状态等。 通过Graph面板，用户还能直接使用&lt;strong&gt;PromQL&lt;/strong&gt;实时查询监控数据。访问ServerIP:9090/graph打开WEB页面，通过PromQL可以查询数据，可以进行基础的数据展示。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201130161210554.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如下所示，查询主机负载变化情况，可以使用关键字node_load1可以查询出Prometheus采集到的主机负载的样本数据，这些样本数据按照时间先后顺序展示，形成了主机负载随时间变化的趋势图表：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201130161230711.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;grafana介绍&quot;&gt;Grafana介绍&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;Grafana是一个跨平台的开源的度量分析和可视化工具，可以通过将采集的数据查询然后可视化的展示。Grafana提供了对prometheus的友好支持，各种工具帮助你构建更加炫酷的数据可视化。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;grafana特点&quot;&gt;&lt;strong&gt;Grafana特点&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;可视化：快速和灵活的客户端图形具有多种选项。面板插件为许多不同的方式可视化指标和日志。&lt;/li&gt;
&lt;li&gt;报警：可视化地为最重要的指标定义警报规则。Grafana将持续评估它们，并发送通知。&lt;/li&gt;
&lt;li&gt;通知：警报更改状态时，它会发出通知。接收电子邮件通知。&lt;/li&gt;
&lt;li&gt;动态仪表盘：使用模板变量创建动态和可重用的仪表板，这些模板变量作为下拉菜单出现在仪表板顶部。&lt;/li&gt;
&lt;li&gt;混合数据源：在同一个图中混合不同的数据源!可以根据每个查询指定数据源。这甚至适用于自定义数据源。&lt;/li&gt;
&lt;li&gt;注释：注释来自不同数据源图表。将鼠标悬停在事件上可以显示完整的事件元数据和标记。&lt;/li&gt;
&lt;li&gt;过滤器：过滤器允许您动态创建新的键/值过滤器，这些过滤器将自动应用于使用该数据源的所有查询。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里我们使用上面Prometheus使用关键字node_load1来使用Grafana进行可视化,点击侧边栏的加号图标，然后单击Dashboard点击创建，然后把刚刚Prometheus使用的查询语句放到Metries,点击右上角的apply即可。&lt;/p&gt;
&lt;p&gt;示例图:&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201130161311758.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;grafana-ui&quot;&gt;Grafana UI&lt;/h3&gt;
&lt;p&gt;上面的示例中我们通过prometheus+grafana通过PromQL进行了简单的服务器负载的监控可视化。我们也可以通过第三方提供可视化JSON文件来帮助我们快速实现服务器、Elasticsearch、MYSQL等等监控。这里我们在grafana提供的第三方dashboards的地址https://grafana.com/grafana/dashboards来下载对应的json文件然后导入到grafana实现服务器的监控。&lt;/p&gt;
&lt;p&gt;监控服务器的示例图:&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201130230021844.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;除了服务端的监控，可以监控应用服务。Prometheus 监控应用的方式非常简单，只需要进程暴露了一个用于获取当前监控样本数据的 HTTP 访问地址。这样的一个程序称为Exporter，Exporter 的实例称为一个 Target 。Prometheus 通过轮训的方式定时从这些 Target 中获取监控数据样本，对于应用来讲，只需要暴露一个包含监控数据的 HTTP 访问地址即可，当然提供的数据需要满足一定的格式，这个格式就是 Metrics 格式: metric name&amp;gt;{&lt;label name=&quot;&quot;&gt;=&lt;label value=&quot;&quot;&gt;, ...} 。label name是标签,label value是标签的值。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201130161748865.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;grafana监控springboot应用实现效果图：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020113023031712.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/label&gt;&lt;/label&gt;&lt;/p&gt;
&lt;h2 id=&quot;prometheusgrafanaalertmanager等安装配置&quot;&gt;Prometheus+Grafana+Alertmanager等安装配置&lt;/h2&gt;
&lt;p&gt;Prometheus以及相关组件使用的是2.x版本，Grafana使用的是7.x版本。&lt;/p&gt;
&lt;p&gt;下载地址推荐使用清华大学或华为的开源镜像站。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;下载地址:&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;https://prometheus.io/download/&quot;&gt;https://prometheus.io/download/&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://mirrors.tuna.tsinghua.edu.cn/grafana/&quot;&gt;https://mirrors.tuna.tsinghua.edu.cn/grafana/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Prometheus以及相关组件百度网盘地址：&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://pan.baidu.com/s/1btErwq8EyAzG2-34lwGO4w&quot;&gt;https://pan.baidu.com/s/1btErwq8EyAzG2-34lwGO4w&lt;/a&gt;&lt;br/&gt;提取码：4nlh&lt;/p&gt;
&lt;h3 id=&quot;prometheus安装&quot;&gt;Prometheus安装&lt;/h3&gt;
&lt;h4 id=&quot;1，文件准备&quot;&gt;1，文件准备&lt;/h4&gt;
&lt;p&gt;将下载好的Prometheus文件解压&lt;/p&gt;
&lt;p&gt;输入&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;tar -zxvf prometheus-2.19.3.linux-amd64.tar.gz
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后移动到/opt/prometheus文件夹里面，没有该文件夹则创建&lt;/p&gt;
&lt;h4 id=&quot;2，配置修改&quot;&gt;2，配置修改&lt;/h4&gt;
&lt;p&gt;在prometheus-2.19.3.linux-amd64文件夹目录下找到prometheus.yml配置文件并更改&lt;/p&gt;
&lt;p&gt;prometheus.yml文件配置如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# my global config
global:
  scrape_interval:     15s # Set the scrape interval to every 15 seconds. Default is every 1 minute.
  evaluation_interval: 15s # Evaluate rules every 15 seconds. The default is every 1 minute.
  # scrape_timeout is set to the global default (10s).

# Alertmanager configuration
alerting:
  alertmanagers:
  - static_configs:
    - targets:
       - alertmanager:9093

# Load rules once and periodically evaluate them according to the global 'evaluation_interval'.
rule_files:
  # - &quot;first_rules.yml&quot;
  # - &quot;second_rules.yml&quot;

# A scrape configuration containing exactly one endpoint to scrape:
# Here it's Prometheus itself.
scrape_configs:
  # The job name is added as a label `job=&amp;lt;job_name&amp;gt;` to any timeseries scraped from this config.
  - job_name: 'prometheus'

    # metrics_path defaults to '/metrics'
    # scheme defaults to 'http'.

    static_configs:
    - targets: ['192.168.8.181:9090']
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;3，prometheus-启动&quot;&gt;3，prometheus 启动&lt;/h4&gt;
&lt;p&gt;在/opt/prometheus/prometheus-2.19.3.linux-amd64的目录下输入:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;nohup ./prometheus   &amp;gt;/dev/null   2&amp;gt;&amp;amp;1 &amp;amp;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动成功之后，在浏览器上输入 ip+9090可以查看相关信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201130231447537.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201130231456893.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;grafana安装&quot;&gt;Grafana安装&lt;/h3&gt;
&lt;h4 id=&quot;1，文件准备-2&quot;&gt;1，文件准备&lt;/h4&gt;
&lt;p&gt;将下载下来的grafana-7.1.1-1.x86_64.rpm的文件通过apm方式安装&lt;br/&gt;输入:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; rpm -ivh grafana-7.1.1-1.x86_64.rpm
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;进行安装&lt;br/&gt;如果出现如下错误:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;error: Failed dependencies:
urw-fonts is needed by grafana-6.1.4-1.x86_64
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一个依赖包没有安装，需要先安装这个依赖包，然后再安装grafana&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# yum install -y urw-fonts
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;2，grafana-启动&quot;&gt;2，grafana 启动&lt;/h4&gt;
&lt;p&gt;root用户下启动&lt;/p&gt;
&lt;p&gt;输入:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;sudo /bin/systemctl start grafana-server.service
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动成功之后，在浏览器上输入 ip+3000可以查看相关信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201130164833434.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;alertmanager安装&quot;&gt;Alertmanager安装&lt;/h3&gt;
&lt;h4 id=&quot;1，文件准备-3&quot;&gt;1，文件准备&lt;/h4&gt;
&lt;p&gt;将下载好的Alertmanager文件解压&lt;/p&gt;
&lt;p&gt;输入&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;tar -zxvf alertmanager-0.21.0.linux-386.tar.gz
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后移动到/opt/prometheus文件夹里面，没有该文件夹则创建&lt;/p&gt;
&lt;h4 id=&quot;2，alertmanager启动&quot;&gt;2，alertmanager启动&lt;/h4&gt;
&lt;p&gt;root用户下启动&lt;/p&gt;
&lt;p&gt;输入:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;nohup ./alertmanager   &amp;gt;/dev/null   2&amp;gt;&amp;amp;1 &amp;amp;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动成功之后，在浏览器上输入 ip+9093可以查看相关信息&lt;/p&gt;
&lt;p&gt;示例图:&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201130164802949.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;pushgateway-安装&quot;&gt;Pushgateway 安装&lt;/h3&gt;
&lt;h4 id=&quot;1，文件准备-4&quot;&gt;1，文件准备&lt;/h4&gt;
&lt;p&gt;将下载好的pushgateway文件解压&lt;/p&gt;
&lt;p&gt;输入&lt;br/&gt;tar -zxvf pushgateway-1.2.0.linux-amd64.tar.gz&lt;br/&gt;然后移动到/opt/prometheus文件夹里面，没有该文件夹则创建&lt;/p&gt;
&lt;h4 id=&quot;2，启动&quot;&gt;2，启动&lt;/h4&gt;
&lt;p&gt;root用户下启动&lt;/p&gt;
&lt;p&gt;输入:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;nohup ./pushgateway   &amp;gt;/dev/null   2&amp;gt;&amp;amp;1 &amp;amp;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动成功之后，在浏览器上输入 ip+9091可以查看相关信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201130163644270.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;5，node_export安装&quot;&gt;5，Node_export安装&lt;/h3&gt;
&lt;h4 id=&quot;1，文件准备-5&quot;&gt;1，文件准备&lt;/h4&gt;
&lt;p&gt;将下载好的Node_export文件解压&lt;/p&gt;
&lt;p&gt;输入&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;tar -zxvf node_exporter-0.17.0.linux-amd64.tar.gz
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后移动到/opt/prometheus文件夹里面，没有该文件夹则创建&lt;/p&gt;
&lt;h4 id=&quot;2，启动-2&quot;&gt;2，启动&lt;/h4&gt;
&lt;p&gt;root用户下启动&lt;/p&gt;
&lt;p&gt;输入:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;nohup ./consul_exporter   &amp;gt;/dev/null   2&amp;gt;&amp;amp;1 &amp;amp;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动成功之后，在浏览器上输入 ip+9100可以查看相关信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201130163533255.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;prometheus使用教程&quot;&gt;Prometheus使用教程&lt;/h2&gt;
&lt;p&gt;Prometheus界面地址: ip+9090。&lt;br/&gt;这里我就使用图片加上注释来进行讲解。&lt;/p&gt;
&lt;h3 id=&quot;1，基本使用&quot;&gt;1，基本使用&lt;/h3&gt;
&lt;h4 id=&quot;1prometheus主界面说明&quot;&gt;1&amp;gt;,Prometheus主界面说明&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201130170534222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;2graph使用示例&quot;&gt;2&amp;gt;,Graph使用示例&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201130170547301.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;3查看运行信息&quot;&gt;3&amp;gt;,查看运行信息&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201130170618208.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;4查看命令标记值&quot;&gt;4&amp;gt;,查看命令标记值&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201130170632490.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;5查看配置信息&quot;&gt;5&amp;gt;,查看配置信息&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201130170648534.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;6查看集成的组件&quot;&gt;6,&amp;gt;查看集成的组件&lt;/h4&gt;
&lt;p&gt;集成的组件需要下载对应export服务并启动运行，并且在prometheus的配置中进行添加！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020113017070077.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;7查看服务发现&quot;&gt;7&amp;gt;,查看服务发现&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201130170708293.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;8查看告警规则&quot;&gt;8&amp;gt;,查看告警规则&lt;/h4&gt;
&lt;p&gt;first_rules.yml的配置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201130170717335.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;9查看是否触发告警&quot;&gt;9&amp;gt;,查看是否触发告警&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201130170733478.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;相关文档&lt;/strong&gt;:&lt;a href=&quot;https://prometheus.io/docs/prometheus/latest/getting_started/&quot;&gt;https://prometheus.io/docs/prometheus/latest/getting_started/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;grafana使用&quot;&gt;Grafana使用&lt;/h2&gt;
&lt;p&gt;Grafanf 界面地址: ip+3000&lt;br/&gt;初始账号密码: admin, admin&lt;br/&gt;这里我依旧用图片加注释来进行讲解，想必这样会更容易理解吧。。。&lt;/p&gt;
&lt;h3 id=&quot;1主界面信息&quot;&gt;1&amp;gt;,主界面信息&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201130170746108.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;2创建仪表盘监控实现&quot;&gt;2&amp;gt;,创建仪表盘监控实现&lt;/h3&gt;
&lt;p&gt;1.添加数据源&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020113017075825.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201130170812997.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;2.选择prometheus&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201130170827140.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.点击创建仪表盘&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020113017084420.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.点击创建&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201130170853164.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201130170904288.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020113017091413.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5.输入node_load1表示语句，填写相关信息，点击apply完成，并将名称保存为Test&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201130170925611.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;6.点击搜索Test，点击就可以查看&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201130170933518.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201130170941630.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;3使用第三方仪表盘监控实现&quot;&gt;3&amp;gt;,使用第三方仪表盘监控实现&lt;/h3&gt;
&lt;p&gt;注:需提前添加好数据源。&lt;/p&gt;
&lt;p&gt;1.点击左上角的加号，点击import&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201130170953572.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在线模式&lt;/strong&gt;&lt;br/&gt;地址:&lt;a href=&quot;https://grafana.com/grafana/dashboards&quot;&gt;https://grafana.com/grafana/dashboards&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201130171002928.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201130171018182.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;离线模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201130171031577.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;监控示例:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201130171044371.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;监控告警实现&quot;&gt;监控告警实现&lt;/h2&gt;
&lt;p&gt;监控告警实现需要依赖 Alertmanager，已经相关的组件，比如上述实例中的监控服务器应用的node_server组件。&lt;/p&gt;
&lt;h3 id=&quot;邮件告警实现&quot;&gt;邮件告警实现&lt;/h3&gt;
&lt;p&gt;需要安装Alertmanager，这里因为邮件发送比较简单，所以这里我就直接贴配置了，其中带有xxx字符的参数是需要根据情况进行更改的。下面的企业微信告警同理。&lt;br/&gt;Alertmanagers服务的&lt;strong&gt;alertmanager.yml&lt;/strong&gt;的配置如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;global:
  resolve_timeout: 5m
  smtp_from: 'xxx@qq.com'
  smtp_smarthost: 'smtp.qq.com:465'
  smtp_auth_username: 'xxx@qq.com'
  smtp_auth_password: 'xxx'
  smtp_require_tls: false
  smtp_hello: 'qq.com'
route:
  group_by: ['alertname']
  group_wait: 5s
  group_interval: 5s
  repeat_interval: 5m
  receiver: 'email'
receivers:
- name: 'email'
  email_configs:
  - to: 'xxx@qq.com'
    send_resolved: true
inhibit_rules:
  - source_match:
      severity: 'critical'
    target_match:
      severity: 'warning'
    equal: ['alertname', 'dev', 'instance']
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注: smtp_from、smtp_auth_username、to的邮箱可以填写同一个，smtp_auth_password填写鉴权码，需要开启POS3。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果不知道怎么开启POS3，可以查看我的这篇文章: &lt;a href=&quot;https://www.cnblogs.com/xuwujing/p/10945698.html&quot;&gt;https://www.cnblogs.com/xuwujing/p/10945698.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Prometheus服务的Prometheus.yml配置如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# my global config
global:
  scrape_interval:     15s # Set the scrape interval to every 15 seconds. Default is every 1 minute.
  evaluation_interval: 15s # Evaluate rules every 15 seconds. The default is every 1 minute.
  # scrape_timeout is set to the global default (10s).

# Alertmanager configuration
alerting:
  alertmanagers:
  - static_configs:
    - targets: 
      - '192.168.214.129:9093'
# Load rules once and periodically evaluate them according to the global 'evaluation_interval'.
rule_files:
   - &quot;/opt/prometheus/prometheus-2.19.3.linux-amd64/first_rules.yml&quot;
  # - &quot;second_rules.yml&quot;

# A scrape configuration containing exactly one endpoint to scrape:
# Here it's Prometheus itself.
scrape_configs:
  # The job name is added as a label `job=&amp;lt;job_name&amp;gt;` to any timeseries scraped from this config.
  - job_name: 'prometheus'

    # metrics_path defaults to '/metrics'
    # scheme defaults to 'http'.

    static_configs:
    - targets: ['192.168.214.129:9090']

  - job_name: 'server'
    static_configs:
    - targets: ['192.168.214.129:9100']
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注：targets如果有多个配置的话，在后面加上其他服务的节点即可。alertmanagers最好写服务器的ip，不然可能会出现告警数据无法发送的情况。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Error sending alert&quot; err=&quot;Post \&quot;http://alertmanager:9093/api/v1/alerts\&quot;: context deadline exceeded
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置了Prometheus.yml之后，我们还需要配置告警的规则，也就是触发条件，达到条件之后就进行触发。我们新建一个first_rules.yml，用于检测服务器挂掉的时候进行发送消息&lt;/p&gt;
&lt;p&gt;first_rules.yml告警配置:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注:job等于的服务名称填写Prometheus.yml配置对应的名称，比如这里设置的server对应Prometheus.yml配置的server。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;groups:
- name: node
  rules:
  - alert: server_status
    expr: up{job=&quot;server&quot;} == 0 
    for: 15s
    annotations:
      summary: &quot;机器{{ $labels.instance }} 挂了&quot;
      description: &quot;报告.请立即查看!&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;依次启动prometheus、altermanagers、node_server服务，查看告警，然后停止node_export服务，等待一段时间在查看。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201130233326789.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201130233339778.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201130233346360.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;企业微信告警实现&quot;&gt;企业微信告警实现&lt;/h3&gt;
&lt;p&gt;和上面的示例操作基本一致，主要是配置的区别。&lt;/p&gt;
&lt;p&gt;1.在企业微信中创建一个应用，并得到secret、corp_id和agent_id配置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201130171114948.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201130171130901.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201130171151281.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020113017120380.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;2.然后修改alertmanager.yml配置，alertmanager.yml配置如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;global:
  resolve_timeout: 5s
  wechat_api_url: 'https://qyapi.weixin.qq.com/cgi-bin/'
  wechat_api_secret: 'xxx'
  wechat_api_corp_id: 'xxx'
templates:
- '/opt/prometheus/alertmanager-0.21.0.linux-386/template/wechat.tmpl'
route:
  group_by: ['alertname']
  group_wait: 10s
  group_interval: 10s
  repeat_interval: 10s
  receiver: 'wechat'
receivers:
- name: 'wechat'
  wechat_configs:
  - send_resolved: true
    to_party: '2'
    agent_id: xxx
    corp_id: 'xxx'
    api_secret: 'xxx'
    api_url: 'https://qyapi.weixin.qq.com/cgi-bin/'
inhibit_rules:
  - source_match:
      severity: 'critical'
    target_match:
      severity: 'warning'
    equal: ['alertname', 'dev', 'instance']
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201130165020226.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;配置成功之后，操作和上述邮件发送的一致，即可在企业微信看到如下信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201130171214178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果觉得上述的示例不好友好的话，我们也可以制定告警模板。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;添加告警模板:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在alertmanagers的文件夹下创建一个template文件夹，然后在该文件夹创建一个微信告警的模板wechat.tmpl，添加如下配置:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{{ define &quot;wechat.default.message&quot; }}
{{ range .Alerts }}
========start=========
告警程序: prometheus_alert
告警级别: {{ .Labels.severity}}
告警类型: {{ .Labels.alertname }}
故障主机: {{ .Labels.instance }}
告警主题: {{ .Annotations.summary }}
告警详情: {{ .Annotations.description }}
=========end===========
{{ end }}
{{ end }}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后再到alertmanager.yml 添加如下配置:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;templates:
- '/opt/prometheus/alertmanager-0.21.0.linux-386/template/wechat.tmpl'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201130234021796.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;效果图:&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201130234033135.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;应用服务监控告警实现&quot;&gt;应用服务监控告警实现&lt;/h3&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;Prometheus 监控应用的方式非常简单，只需要进程暴露了一个用于获取当前监控样本数据的 HTTP&lt;br/&gt;访问地址。这样的一个程序称为Exporter，Exporter 的实例称为一个 Target 。Prometheus通过轮训的方式定时从这些 Target 中获取监控数据样本，对于应用来讲，只需要暴露一个包含监控数据的 HTTP访问地址即可，当然提供的数据需要满足一定的格式，这个格式就是 Metrics 格式: metric name&amp;gt;{&lt;label name=&quot;&quot;&gt;=&lt;label value=&quot;&quot;&gt;, ...} 。label name是标签,label value是标签的值。&lt;/label&gt;&lt;/label&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Springboot应用实现步骤&lt;/strong&gt;&lt;br/&gt;1.在pom文件添加&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;io.micrometer&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;micrometer-registry-prometheus&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-actuator&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.在代码中添加如下配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private Counter requestErrorCount;
    private final MeterRegistry registry;
    @Autowired
    public PrometheusCustomMonitor(MeterRegistry registry) {
        this.registry = registry;
    }
    @PostConstruct
    private void init() {
        requestErrorCount = registry.counter(&quot;requests_error_total&quot;, &quot;status&quot;, &quot;error&quot;);
    }
    public Counter getRequestErrorCount() {
        return requestErrorCount;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.在异常处理中添加如下记录:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;monitor.getRequestErrorCount().increment();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4.在prometheus的配置中添加springboot应用服务监控&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;-  job_name: 'springboot' 
     metrics_path: '/actuator/prometheus' 
     scrape_interval: 5s
     static_configs:
     - targets: ['192.168.8.45:8080'] 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;5.Prometheu.yml配置如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  - job_name: 'springboot' 
    metrics_path: '/actuator/prometheus' 
    scrape_interval: 5s
    static_configs:
    - targets: ['192.168.8.45:8080']  
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;规则文件配置如下:&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201130234644566.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;6.在prometheus监控即可查看&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201130234528701.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;企业微信告警效果图:&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201130234707687.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;监控的springboot项目地址:&lt;a href=&quot;https://github.com/xuwujing/springBoot-study&quot;&gt;https://github.com/xuwujing/springBoot-study&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;其他配置&quot;&gt;其他配置&lt;/h2&gt;
&lt;h3 id=&quot;prometheus动态加载配置&quot;&gt;prometheus动态加载配置&lt;/h3&gt;
&lt;p&gt;Prometheus数据源的配置主要分为静态配置和动态发现, 常用的为以下几类:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;static_configs: 静态服务发现&lt;/li&gt;
&lt;li&gt;file_sd_configs: 文件服务发现&lt;/li&gt;
&lt;li&gt;dns_sd_configs: DNS 服务发现&lt;/li&gt;
&lt;li&gt;kubernetes_sd_configs: Kubernetes 服务发现&lt;/li&gt;
&lt;li&gt;consul_sd_configs:Consul 服务发现（推荐使用）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;file_sd_configs的方式提供简单的接口，可以实现在单独的配置文件中配置拉取对象，并监视这些文件的变化并自动加载变化。基于这个机制，我们可以自行开发程序，监控监控对象的变化自动生成配置文件，实现监控对象的自动发现。&lt;/p&gt;
&lt;p&gt;在prometheus文件夹目录下创建targets.json文件&lt;br/&gt;配置如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[
    {
      &quot;targets&quot;: [ &quot;192.168.214.129:9100&quot;],
      &quot;labels&quot;: {
        &quot;instance&quot;: &quot;node&quot;,
        &quot;job&quot;: &quot;server-129&quot;
      }
    },
    {
        &quot;targets&quot;: [ &quot;192.168.214.134:9100&quot;],
        &quot;labels&quot;: {
          &quot;instance&quot;: &quot;node&quot;,
          &quot;job&quot;: &quot;server-134&quot;
        }
      }
  ]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在prometheus目录下新增如下配置:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; - job_name: 'file_sd'   
    file_sd_configs:
      - files:
        - targets.json  
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020113023501971.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;一些告警配置&quot;&gt;一些告警配置&lt;/h3&gt;
&lt;p&gt;这是本人整理的一些服务应用告警的配置，也欢迎大家共同讨论一些常用的相关配置。&lt;/p&gt;
&lt;p&gt;内存告警设置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;- name: test-rule
  rules:
  - alert: &quot;内存报警&quot;
    expr: 100 - ((node_memory_MemAvailable_bytes * 100) / node_memory_MemTotal_bytes) &amp;gt; 30
    for: 15s
    labels:
      severity: warning
    annotations:
      summary: &quot;服务名:{{$labels.instance}}内存使用率超过30%了&quot;
      description: &quot;业务500报警: {{ $value }}&quot;
      value: &quot;{{ $value }}&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;示例图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201130235401773.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201130235410890.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;磁盘设置:&lt;/p&gt;
&lt;p&gt;总量百分比设置:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;(node_filesystem_size_bytes {mountpoint =&quot;/&quot;} - node_filesystem_free_bytes {mountpoint =&quot;/&quot;}) / node_filesystem_size_bytes {mountpoint =&quot;/&quot;} * 100
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201130235426222.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;查看某一目录的磁盘使用百分比&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;(node_filesystem_size_bytes{mountpoint=&quot;/boot&quot;}-node_filesystem_free_bytes{mountpoint=&quot;/boot&quot;})/node_filesystem_size_bytes{mountpoint=&quot;/boot&quot;} * 100
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;正则表达式来匹配多个挂载点&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;(node_filesystem_size_bytes{mountpoint=~&quot;/|/run&quot;}-node_filesystem_free_bytes{mountpoint=~&quot;/|/run&quot;})&lt;br/&gt;/ node_filesystem_size_bytes{mountpoint=~&quot;/|/run&quot;} * 100&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;预计多长时间磁盘爆满&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;predict_linear(node_filesystem_free_bytes {mountpoint =&quot;/&quot;}[1h],&lt;br/&gt;4&lt;em&gt;3600) &amp;lt; 0 predict_linear(node_filesystem_free_bytes&lt;br/&gt;{job=&quot;node&quot;}[1h], 4&lt;/em&gt;3600) &amp;lt; 0&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;100 - (avg(irate(node_cpu_seconds_total{mode=&quot;idle&quot;}[5m])) by&lt;br/&gt;(instance) * 100)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;(node_memory_MemFree_bytes+node_memory_Cached_bytes+node_memory_Buffers_bytes)&lt;br/&gt;/ node_memory_MemTotal_bytes * 100&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;100 -&lt;br/&gt;(node_memory_MemFree_bytes+node_memory_Cached_bytes+node_memory_Buffers_bytes)&lt;br/&gt;/ node_memory_MemTotal_bytes * 100&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;100 - (node_filesystem_free_bytes{mountpoint=&quot;/&quot;,fstype=~&quot;ext4|xfs&quot;} /&lt;br/&gt;node_filesystem_size_bytes{mountpoint=&quot;/&quot;,fstype=~&quot;ext4|xfs&quot;} * 100)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;其他&quot;&gt;其他&lt;/h2&gt;
&lt;p&gt;这段时间比较忙，ELK相关得等待一段时间在进行更新，虽然发表的博客才对应去年整理的博客。。。。&lt;br/&gt;本篇文章准备了好久，边整理编写，没想到写了这么多。不过感觉这样也不错，一次写出来或许比分开一次次的写对读者而言要好上不上，毕竟不用一篇篇的去找了。&lt;/p&gt;
&lt;h3 id=&quot;音乐推荐&quot;&gt;音乐推荐&lt;/h3&gt;

&lt;p&gt;原创不易，如果感觉不错，希望给个推荐！您的支持是我写作的最大动力！&lt;br/&gt;版权声明:&lt;br/&gt;作者：虚无境&lt;br/&gt;博客园出处：&lt;a href=&quot;http://www.cnblogs.com/xuwujing&quot;&gt;http://www.cnblogs.com/xuwujing&lt;/a&gt;&lt;br/&gt;CSDN出处：&lt;a href=&quot;http://blog.csdn.net/qazwsxpcm&quot;&gt;http://blog.csdn.net/qazwsxpcm&lt;/a&gt;&lt;br/&gt;掘金出处：&lt;a href=&quot;https://juejin.im/user/5ae45d5bf265da0b8a6761e4&quot;&gt;https://juejin.im/user/5ae45d5bf265da0b8a6761e4&lt;/a&gt;　　　　&lt;br/&gt;个人博客出处：&lt;a href=&quot;http://www.panchengming.com&quot;&gt;http://www.panchengming.com&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 30 Nov 2020 16:03:00 +0000</pubDate>
<dc:creator>虚无境</dc:creator>
<og:description>前言 本文主要介绍的是Prometheus采集数据，通过Grafana加上PromQL语句实现数据可视化以及通过Alertmanage实现告警推送功能。温馨提示，本篇文章特长，2w多的文字加上几十张图</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xuwujing/p/14065740.html</dc:identifier>
</item>
<item>
<title>Windows生产力工具推荐 - 虫师</title>
<link>http://www.cnblogs.com/fnng/p/14065701.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fnng/p/14065701.html</guid>
<description>&lt;p&gt;相信大部分同学还是Windows用户，作为一个长期Windows/MacOS双系统长期用户，Windows在用的好，工作效率也很高，下面就推荐几款Windows下面的生产力工具。&lt;/p&gt;

&lt;p&gt;用过MacOS的同学一定忘不了他的 Spotlight（聚焦搜索），非常高效。&lt;/p&gt;
&lt;p&gt;当然 Windows 也有搜索，但是，他搜索能力比较一般，比如我搜索QQ关键字是找不到安装的应用的，只能搜索腾讯或者tengxun, 这其实就不太符合我的习惯了。其次，它不是显示在屏幕中心位置的，每次搜索眼睛要移到左下角也很不爽。&lt;/p&gt;
&lt;p&gt;那么utools用起来就太爽了。&lt;/p&gt;
&lt;p&gt;官网：&lt;a href=&quot;https://u.tools/docs/&quot;&gt;https://u.tools/docs/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/311516/202011/311516-20201130233311454-100109233.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;uTools 是一个极简、插件化、跨平台的现代桌面软件。通过自由选配丰富的插件，打造你得心应手的工具集合。&lt;/p&gt;
&lt;p&gt;通过快捷键（默认 alt + space ）就可以快速呼出这个搜索框。它相当聪明，你可以往输入框内粘贴文本、图片、截图、文件、文件夹等等，能够处理此内容的插件也早已准备就绪，统一的设计风格和操作方式，助你高效的得到结果。&lt;/p&gt;
&lt;p&gt;一旦你熟悉它后，除了能够为你节约大量时间，不中断、无干扰，让你可以更加专注地改变世界。&lt;/p&gt;

&lt;p&gt;windows的文件搜索总是慢，然而windows只是慢而已，而macOS文件搜索就很迷了，初用macOS的同学一定深有同感。everything简直是秒出结果，感觉我的人生都变长了。&lt;/p&gt;
&lt;p&gt;官网：&lt;a href=&quot;https://www.voidtools.com/zh-cn/&quot;&gt;https://www.voidtools.com/zh-cn/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/311516/202011/311516-20201130233524342-49344143.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Everything 是 Windows 上一款搜索引擎，它能够基于文件名快速定文件和文件夹位置。&lt;/p&gt;
&lt;p&gt;不像 Windows 内置搜索，&quot;Everything&quot; 默认显示电脑上每个文件和文件夹 (就如其名 &quot;Everything&quot;)。&lt;/p&gt;
&lt;p&gt;您在搜索框输入的关键词将会筛选显示的文件和文件夹。&lt;/p&gt;

&lt;p&gt;作为一个程序员，bash才是生产力，Linux/macOS下面有 iTerm2 这样的生产力工具，我一直在Windows下面用cmder，虽然它也还行，但还是有些不足。&lt;/p&gt;
&lt;p&gt;用了Windows Terminal 之后，感觉体验好了不少，但是比起iTerm2 还是有差距。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/311516/202011/311516-20201130234657665-1212742051.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;macOS的同学一定知道 homebrew，用它来装开发工具和库简直太方便了。那么windows下面有 scoop。&lt;/p&gt;
&lt;p&gt;官方网站：&lt;a href=&quot;https://scoop.sh/&quot;&gt;https://scoop.sh/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/311516/202011/311516-20201130235032163-1426276246.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有了这些工具的加持，相信你的编程之路一定事半功倍。&lt;/p&gt;
</description>
<pubDate>Mon, 30 Nov 2020 15:52:00 +0000</pubDate>
<dc:creator>虫师</dc:creator>
<og:description>Windows生产力工具推荐</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/fnng/p/14065701.html</dc:identifier>
</item>
<item>
<title>Java多线程中的wait/notify通信模式 - JJian</title>
<link>http://www.cnblogs.com/jian0110/p/14064934.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jian0110/p/14064934.html</guid>
<description>&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;span&gt;　　最近在看一些JUC下的源码，更加意识到想要学好Java多线程，基础是关键，比如想&lt;strong&gt;要学好ReentranLock源码，就得掌握好AQS源码，而AQS源码中又有很多Java多线程经典的一些应用；再比如看了线程池的核心源码实现，又学到了很多核心实现&lt;/strong&gt;，其实这些都可以提出来慢慢消化并变成自己的知识点，今天这个Java等待/通知模式其实是Thread.join()实现的关键，还有线城市工作线程中线程跟线程之间的通信的核心所在，故在此为了加深理解，做此记录！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;参考资料《Java并发编程艺术》（电子PDF版），有需要的朋友的可以私信或者评论&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr/&gt;

&lt;h2&gt;&lt;span&gt;1、等待/通知模式概述&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　&lt;span&gt;　首先先介绍下官方的一个正式的介绍：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　等待/通知机制，是指一个线程A调用了对象object的wait()方法进入等待状态，而另一个线程B调用了对象object的notify或者notifyAll()方法，线程A收到通知后从对象O的wait()方法返回，进而还行后续操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　而我的理解是（举例说明）：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　假设工厂里有两条流水线，某个工作流程需要这两个流水线配合完成，这两个流水线分别是A和B，其中A负责准备各种配件，B负责租装配件之后产出输出到工作台。&lt;strong&gt;B的工作需要A的配件准备充分，否则就会一直等待A准备好配件&lt;/strong&gt;，并且A准备好配件后会通过一个开头&lt;strong&gt;通知&lt;/strong&gt;告诉B我已经准备好了，你那边&lt;strong&gt;不用一直等待了&lt;/strong&gt;，可以继续执行任务了。流程A与流程B就是对应的线程A与线程B之间的通信，即可以理解为相互配合，具体也就是“”通知/等待“”机制！&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;2、需要注意的细节　　&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　那么，我们都知道超类Object有wait()方法与notify()/notifyAll()方法，在进行正式代码举例之前，应该先加深下对这三个方法的理解与一些细节（有一些细节确实容易被忽略）&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;调用wait()方法，会释放锁&lt;/span&gt;&lt;/strong&gt;（这一点我想大部分人都知道），&lt;strong&gt;&lt;span&gt;线程状态由RUNNING-&amp;gt;WAITNG&lt;/span&gt;&lt;/strong&gt;，当前线程进入对象等待队列中；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;调用notify()/notifyAll()方法不会立马释放锁&lt;/span&gt;&lt;/strong&gt;（这一点我大家人也应该知道，但是什么时候释放锁呢？--------请看下一条），notify()方法是将等待队列中的线程移到同步队列中，而notifyAll()则是全部移到同步队列中，被移出的&lt;strong&gt;&lt;span&gt;线程状态WAITING--&amp;gt;BLOCKED&lt;/span&gt;&lt;/strong&gt;;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;当前调用notify()/notifyAll()的线程释放锁了才算释放锁，才有机会唤醒wait线程返回&lt;/span&gt;&lt;/strong&gt;（为什么有才有机会返回呢？------继续看下一条）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;从wait()返回的前提是必须获得调用对象锁&lt;/span&gt;&lt;/strong&gt;，也就是说notify()与notifyAll()释放锁之后，wait()进入BLOCKED状态，如果其他线程有竞争当前锁的话，wait线程继续争取锁资格（不好理解的话，请看下面的代码举例）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;使用wait()、notify()、notifyAll()方法时需要先调对象加锁&lt;/strong&gt;&lt;/span&gt;（这可能是最容易忽视的点了，至于为什么，请先看了代码之后，看本篇博文最后补充：&lt;strong&gt;wait()、notify()、notifyAll()加锁的原因----防止线程即饥饿&lt;/strong&gt;）&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;1、结合代码理解&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;结合上述的“工厂流程装配配件并产出的例子”，我们有两个线程（流水线）WaitThread与NotifyThread、其中WaitThread是被通知的任务，完成主要的工作（组装配件完成产品），需要时刻判断标志位（开关）；NotifyThread是需要通知的任务，需要对WaitThread进行“监督通知”，两个配合才能更好完成产品的组装并输出。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WaitNotify {

    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; Object lock = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object();
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; flag = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; WaitThread(), &quot;WaitThread&quot;&lt;span&gt;).start();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            Thread.sleep(&lt;/span&gt;1000&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
            e.printStackTrace();
        }
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; NotifyThread(), &quot;NotifyThread&quot;&lt;span&gt;).start();

    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 流水线A，完成主要任务
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; WaitThread &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable{
        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取object对象锁&lt;/span&gt;
            &lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; (lock){
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 条件不满足时一直在等，等另外的线程改变该条件，并通知该wait线程&lt;/span&gt;
                &lt;span&gt;while&lt;/span&gt; (!&lt;span&gt;flag){
                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                        System.out.println(Thread.currentThread() &lt;/span&gt;+ &quot; is waiting, flag is &quot;+&lt;span&gt;flag);
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; wait()方法调用就会释放锁，当前线程进入等待队列。&lt;/span&gt;
&lt;span&gt;                        lock.wait();
                    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO 条件已经满足，不继续while，完成任务&lt;/span&gt;
                System.out.println(Thread.currentThread() + &quot; is running, flag is &quot;+&lt;span&gt;flag);
            }
        }
    }
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 流水线B，对开关进行控制，并通知流水线A
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; NotifyThread &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable{
        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取等wait线程同一个object对象锁&lt;/span&gt;
            &lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; (lock){
                flag &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通知wait线程，我已经改变了条件，你可以继续返回执行了（返回之后继续判断while）
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 但是此时通知notify()操作并立即不会释放锁，而是要等当前线程释放锁
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO 我准备好配件了，我需要通知全部的组装流水线A.....&lt;/span&gt;
&lt;span&gt;                lock.notifyAll();
                System.out.println(Thread.currentThread() &lt;/span&gt;+ &quot; hold lock, notify waitThread and flag is &quot;+&lt;span&gt;flag);
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;运行main函数，输出：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
Thread[WaitThread,5,main] is waiting, flag is &lt;span&gt;false&lt;/span&gt;&lt;span&gt;
Thread[NotifyThread,&lt;/span&gt;5,main] hold lock, notify waitThread and flag is &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
Thread[WaitThread,&lt;/span&gt;5,main] is running, flag is &lt;span&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;车床流水工作开启，流水线的开关一开始是关闭的（flag=false），&lt;/span&gt;&lt;span&gt;流水线B（NotifyThread）去开启后，开始自动唤醒流水线A（WaitThread），整个流水线开始工作了......&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;Thread[WaitThread,5,main] is waiting, flag is false： 一开始流水线A发现自己没有配件可租装，所以等流水线A准备好配件（这样是不是觉得特别傻，哈哈哈，真正的流水线不会浪费时间等的，而且会有很多条流水线B准备配件的，这里只是举例说明，望理解！）；&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;Thread[NotifyThread,5,main] hold lock, notify waitThread and flag is true：流水线B准备好了配件，开启开关（flag=ture），并通知流水线A，让流水线A开始工作；&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Thread[WaitThread,5,main] is running, flag is true，流水线B收到了通知，再次检查开关是否开启了，开启的话就开始返回继续完成工作了&lt;/span&gt;&lt;/strong&gt;。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;其实结合上述我举的例子还是很好理解的，下面是大概的一个粗略时序图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　 　　　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1352849/202011/1352849-20201130213846101-99899289.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;2、扩展理解----wait()返回的前提是获得了锁&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;上述已经表达了这个注意的细节：&lt;strong&gt;&lt;span&gt;从wait()返回的前提是必须获得调用对象锁&lt;/span&gt;，&lt;/strong&gt;我们再增加能竞争lock的同步代码块（红字部分）。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WaitNotify {

    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; Object lock = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object();
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; flag = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; WaitThread(), &quot;WaitThread&quot;&lt;span&gt;).start();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            Thread.sleep(&lt;/span&gt;1000&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
            e.printStackTrace();
        }
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; NotifyThread(), &quot;NotifyThread&quot;&lt;span&gt;).start();
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 流水线A，完成主要任务
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; WaitThread &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable{
        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取object对象锁&lt;/span&gt;
            &lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; (lock){
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 条件不满足时一直在等，等另外的线程改变该条件，并通知该wait线程&lt;/span&gt;
                &lt;span&gt;while&lt;/span&gt; (!&lt;span&gt;flag){
                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                        System.out.println(Thread.currentThread() &lt;/span&gt;+ &quot; is waiting, flag is &quot;+&lt;span&gt;flag);
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; wait()方法调用就会释放锁，当前线程进入等待队列。&lt;/span&gt;
&lt;span&gt;                        lock.wait();
                    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO 条件已经满足，不继续while，完成任务&lt;/span&gt;
                System.out.println(Thread.currentThread() + &quot; is running, flag is &quot;+&lt;span&gt;flag);
            }
        }
    }
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 流水线B，对开关进行控制，并通知流水线A
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; NotifyThread &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable{
        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取等wait线程同一个object对象锁&lt;/span&gt;
            &lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; (lock){
                flag &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通知wait线程，我已经改变了条件，你可以继续返回执行了（返回之后继续判断while）
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 但是此时通知notify()操作并立即不会释放锁，而是要等当前线程释放锁
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO 我准备好配件了，我需要通知全部的组装流水线A.....&lt;/span&gt;
&lt;span&gt;                lock.notifyAll();
                System.out.println(Thread.currentThread() &lt;/span&gt;+ &quot; hold lock, notify waitThread and flag is &quot;+&lt;span&gt;flag);
            }
            &lt;/span&gt;&lt;span&gt;// 模拟跟流水线B竞争
            synchronized (lock){
                System.out.println(Thread.currentThread() + &quot; hold lock again&quot;&lt;/span&gt;&lt;span&gt;&lt;span&gt;);
            }&lt;/span&gt;
        }
    }&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;输出结果：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
Thread[WaitThread,5,main] is waiting, flag is &lt;span&gt;false&lt;/span&gt;&lt;span&gt;
Thread[NotifyThread,&lt;/span&gt;5,main] hold lock, notify waitThread and flag is &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
Thread[NotifyThread,5,main] hold lock again
Thread[WaitThread,5,main] is running, flag is true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;其中第三条跟第四条顺序可能会反着来的，&lt;span&gt;这就是因为lock锁可能被红字部分的synchronized代码块竞争获取（这样wait()方法可能获取不到lock锁，不会返回），也可能被waitThread获取从wait()方法返回&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
Thread[WaitThread,5,main] is waiting, flag is &lt;span&gt;false&lt;/span&gt;&lt;span&gt;
Thread[NotifyThread,&lt;/span&gt;5,main] hold lock, notify waitThread and flag is &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
Thread[WaitThread,5,main] is running, flag is true
Thread[NotifyThread,5,main] hold lock again&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;span&gt;1、Thread.join()中源码应用&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;Thread.join()作用：当线程A等待thread线程终止之后才从thread.join()返回， &lt;strong&gt;&lt;span&gt;每个线程终止的前提是前驱线程终止，每个线程等待前驱线程终止后，才从join方法返回，这里涉及了等待/通知机制（等待前驱线程结束，接收前驱线程结束通知）&lt;/span&gt;&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Thread.join()源码中，使用while选好判断前驱线程是否活着，如果前驱线程还活着就一直wait等待，当然如果超时的话就直接返回。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; join(&lt;span&gt;long&lt;/span&gt;&lt;span&gt; millis)
    &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; base =&lt;span&gt; System.currentTimeMillis();
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; now = 0&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (millis &amp;lt; 0&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&quot;timeout value is negative&quot;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里的while(){wait(millis)} 就是利用等待/通知中的等待模式，只不过加上了超时设置&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (millis == 0&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; while循环,当线程还活着的时候就一直循环等待，直到线程终止&lt;/span&gt;
            &lt;span&gt;while&lt;/span&gt;&lt;span&gt; (isAlive()) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; wait等待&lt;/span&gt;
                wait(0&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 条件满足时返回&lt;/span&gt;
        } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (isAlive()) {
                &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; delay = millis -&lt;span&gt; now;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (delay &amp;lt;= 0&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                }
                wait(delay);
                now &lt;/span&gt;= System.currentTimeMillis() -&lt;span&gt; base;
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;2、其它的应用&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;&lt;strong&gt;线程池的本质是使用一个线程安全的工作队列连接工作者线程和客户端线程，客户端线程将任务放入工作队列后便返回，而工作者线程则不断地从工作队列中取出工作并执行&lt;/strong&gt;&lt;/span&gt;。那么，在这里的等待/通知模式的应用就是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;&lt;span&gt;工作队列中线程job没有的话也就是工作队列为空的情况下，等待客户端放入工作队列线程任务，并通知工作线程继续从工作队列中获取线程执行。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　注：关于线程池的应用源码这里不做介绍，因为一时也讲不完（自己也还没有完全消化），先简单介绍下应用到的地方还有概念。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　补充：其实数据库的连接池也类似线程池这种工作流程，也会涉及等待/通知模式。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;3、等待/通知范式&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　介绍了那么多应用，这种模式应该有个统一的范式来套用。对的，必然是有的：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　对于等待者（也可以称之为消费者）：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; (对象lock) {
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (条件不满足) {&lt;/span&gt;
&lt;span&gt;            对象.wait();
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO 处理逻辑&lt;/span&gt;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　对于通知者（也可以称之为生产者）：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; (对象lock) {
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (条件满足) {
            改变条件
            对象.notify();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　注意&lt;span&gt;：&lt;span&gt;实际开发中最好采用的是超时等待/通知模式&lt;/span&gt;，在thread.join()源码方法中完美体现&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;（1）其实根据wait()注意事项也能明白，&lt;strong&gt;&lt;span&gt;wait()是释放锁的，那么不加锁哪来释放锁&lt;/span&gt;&lt;/strong&gt;！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）&lt;strong&gt;&lt;span&gt;wait()与notify()或者notifyAll()必须是搭配一起使用的&lt;/span&gt;&lt;/strong&gt;，否则线程调用object.wait()之后，没有超时机制，也没有调用notify()或者notifyAll()唤醒的话，就一直处于WAITING状态，造成调用wait()的线程一直都是饥饿状态。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）由于第2条的，我们已知：即便我们使用了notify()或者notifyAll()去唤醒线程，&lt;strong&gt;&lt;span&gt;但是没有在适当的时机唤醒（比如调用wait()之前就唤醒了&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/strong&gt;，&lt;strong&gt;&lt;span&gt;那么仍然调用wait()线程处于WAITING状态&lt;/span&gt;&lt;/strong&gt;，所以我们必须保证wait()方法要么不执行，要么就执行完在被唤醒。也就是下列代码中1那里不能允许插入调用notify/notifyAll，&lt;strong&gt;&lt;span&gt;自然而然就增加synchronized关键字，保证wait()操作整体执行不被破坏&lt;/span&gt;&lt;/strong&gt;！&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; (对象lock) {
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (条件不满足) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1 这里如果先执行了notify/notifyAll方法，那么2执行之后，该线程就一直WAITING&lt;/span&gt;
            对象.wait(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;
&lt;span&gt;        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO 处理逻辑&lt;/span&gt;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;用图片展示执行顺序就是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1352849/202011/1352849-20201130234509256-1739213704.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（4）&lt;strong&gt;&lt;span&gt;注意synchronized代码块中，代码错误或者其它原因线程终止的话，没有执行到wait()方法的话，是会自动释放锁的，不必担心会死锁&lt;/span&gt;&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;





</description>
<pubDate>Mon, 30 Nov 2020 15:46:00 +0000</pubDate>
<dc:creator>JJian</dc:creator>
<og:description>前言 最近在看一些JUC下的源码，更加意识到想要学好Java多线程，基础是关键，比如想要学好ReentranLock源码，就得掌握好AQS源码，而AQS源码中又有很多Java多线程经典的一些应用；再比</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jian0110/p/14064934.html</dc:identifier>
</item>
<item>
<title>2020年的UWP(4)——UWP和等待Request的Desktop Extension - 楼上那个蜀黍</title>
<link>http://www.cnblogs.com/manupstairs/p/14065673.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/manupstairs/p/14065673.html</guid>
<description>&lt;p&gt;上一篇我们讨论了UWP和Desktop Extension交互中，Desktop Extension执行后立即退出的场景。下图是提到的四种场景分类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;执行后立即退出&lt;/li&gt;
&lt;li&gt;等待request，处理完后退出&lt;/li&gt;
&lt;li&gt;一或多个request/response周期&lt;/li&gt;
&lt;li&gt;和UWP程序相同生命周期&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/362529/202011/362529-20201130233626531-1957337161.png&quot; alt=&quot;&quot; width=&quot;577&quot; height=&quot;348&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本篇我们讨论第二种，Desktop Extension等待request后，根据传参完成操作后退出的，短生命周期场景。该类型有以下特征：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;可能存在多次的单向调用&lt;/li&gt;
&lt;li&gt;通过request接收参数&lt;/li&gt;
&lt;li&gt;不关心返回结果&lt;/li&gt;
&lt;li&gt;Desktop Extension等待request，完成操作后退出&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;该场景的示意图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/362529/202011/362529-20201130233710719-914148669.png&quot; alt=&quot;&quot; width=&quot;477&quot; height=&quot;484&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们依然以Desktop Extension启动mspaint.exe和control.exe来举例。和上一篇不同的是，这次我们会通过UWP端发起的request来传递参数。&lt;/p&gt;
&lt;p&gt;本篇Sample Code中的AppServiceHandler，以及App.xaml.cs中的OnBackgroundActivated方法。请参考《&lt;a href=&quot;https://www.cnblogs.com/manupstairs/p/13853418.html&quot; target=&quot;_blank&quot;&gt;2020年的UWP(2)——In Process App Service&lt;/a&gt;》，相同部分不再介绍。&lt;/p&gt;
&lt;p&gt;本篇新增的AppServiceConnectionConnectedEventArgs对象及Connected事件，是当AppServiceConnection通过OpenAsync方法成功连接时，传递当前活动的AppServiceConnection对象，以便调用SendMessageAsync等方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AppServiceConnectionConnectedEventArgs : EventArgs
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; AppServiceConnection Connection { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; AppServiceConnectionConnectedEventArgs(AppServiceConnection connection)
        {
            Connection &lt;/span&gt;=&lt;span&gt; connection;
        }
    }

   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;event&lt;/span&gt; EventHandler&amp;lt;AppServiceConnectionConnectedEventArgs&amp;gt; Connected;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在AppServiceHandler中的OnBackgroundActivated方法中，我们首要做的，即是通知订阅对象，有AppServiceConnection被成功Open了，请及时响应。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnBackgroundActivated(AppServiceTriggerDetails details)
        {
            Connected&lt;/span&gt;?.Invoke(&lt;span&gt;this&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AppServiceConnectionConnectedEventArgs(details.AppServiceConnection));
            Connection &lt;/span&gt;=&lt;span&gt; details.AppServiceConnection;
            Connection.RequestReceived &lt;/span&gt;+=&lt;span&gt; Connection_RequestReceived;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;订阅这个Connected事件的，一般都是Desktop Extension的发起方。比如说UWP端的某个Button。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ButtonLaunchApp_Click(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, RoutedEventArgs e)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ApiInformation.IsApiContractPresent(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Windows.ApplicationModel.FullTrustAppContract&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;))
            {
                AppServiceHandler.Instance.Connected &lt;/span&gt;+=&lt;span&gt; Instance_Connected;
                &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; FullTrustProcessLauncher.LaunchFullTrustProcessForCurrentAppAsync();
            }
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Instance_Connected(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, AppServiceConnectionConnectedEventArgs e)
        {
            AppServiceHandler.Instance.Connected &lt;/span&gt;-=&lt;span&gt; Instance_Connected;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; valueSet = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ValueSet();
            valueSet.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;FileName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, ComboBoxFileName.SelectionBoxItem);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; response = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; e.Connection.SendMessageAsync(valueSet);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;之所以需要这个Connect事件，是因为通过SendMessageAsync传参，需要依赖当前活动的AppServiceConnection对象。我们正是通过Connected事件，将AppServiceConnection对象传递给订阅者，使其能够访问SendMessageAsync等方法进行数据交互。&lt;/p&gt;
&lt;p&gt;在Instance_Connected方法中，在每次点击按钮时，均启动一个新的Desktop Extension进程。在Desktop Extension进程中，会通过OpenAsync方法来连接AppServiceConnection。之后便是由OnBackgroundActivated方法触发Connected事件，接下来就是发起request。&lt;/p&gt;
&lt;p&gt;该场景中，Desktop Extension仅需维持一个较短的生命周期，在等到request后，根据传参完成相应操作，就可以释放资源安全退出了。对整个APP而言，既不会长期占用过多资源，也不会导致UWP端无法Suspend。&lt;/p&gt;
&lt;p&gt;下图中的绿色叶子图标，在Desktop Extension运行时，是不会出现的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/362529/202011/362529-20201130234008247-876685628.png&quot; alt=&quot;&quot; width=&quot;578&quot; height=&quot;421&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同时我们要知道AppService的生命周期是不可控的，在UWP端程序最小化以后，Windows会在一段时间后停止AppService，AppServiceConnection也会被dispose。所以存储一个AppServiceConnection长期对象，用来和永不退出的Desktop Extension通讯并不是个好主意。&lt;/p&gt;
&lt;p&gt;以下是Desktop Extension端的部分代码，为了方便观察应用程序的行为，我在Sample中将Enrivonment.Exit给注释掉了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task InitializeAsync()
        {
            Connection &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AppServiceConnection();
            Connection.PackageFamilyName &lt;/span&gt;=&lt;span&gt; Package.Current.Id.FamilyName;
            Connection.AppServiceName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ParameterAppService&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            AppServiceConnectionStatus status &lt;/span&gt;= &lt;span&gt;await&lt;/span&gt;&lt;span&gt; Connection.OpenAsync();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (status !=&lt;span&gt; AppServiceConnectionStatus.Success)
            {
                Console.WriteLine(status);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                Console.WriteLine(status);
                Connection.RequestReceived &lt;/span&gt;+=&lt;span&gt; Connection_RequestReceived;
            }
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Connection_RequestReceived(AppServiceConnection sender, AppServiceRequestReceivedEventArgs args)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; content = args.Request.Message[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;FileName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;].ToString();
            Process.Start(content);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Will exit after received.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Environment.Exit(0);&lt;/span&gt;
        }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;本篇简单介绍了“等待request，处理完后退出”，这一UWP和Desktop Extension数据交互的场景。感谢看到这里的同学，单纯的文字其实很难讲清楚AppService的使用，还请参考Github上的实例代码，欢迎评论及提问。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/manupstairs/UWPSamples/tree/master/UWPSamples/DataExchangeUWP/ExitAfterHandleRequest&quot; target=&quot;_blank&quot;&gt;UWPSamples/UWPSamples/DataExchangeUWP/ExitAfterHandleRequest at master · manupstairs/UWPSamples (github.com)&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 30 Nov 2020 15:42:00 +0000</pubDate>
<dc:creator>楼上那个蜀黍</dc:creator>
<og:description>上一篇我们讨论了UWP和Desktop Extension交互中，Desktop Extension执行后立即退出的场景。下图是提到的四种场景分类： 执行后立即退出 等待request，处理完后退出</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/manupstairs/p/14065673.html</dc:identifier>
</item>
<item>
<title>数据共享-spring batch(9)上下文处理 - Mason技术记录</title>
<link>http://www.cnblogs.com/masonlee/p/14065614.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/masonlee/p/14065614.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;在 Spring Batch 中进行数据及参数传递的方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-引言&quot;&gt;1 引言&lt;/h2&gt;
&lt;p&gt;本文是 Spring Batch 系列文章的第9篇，有兴趣的可见文章：&lt;/p&gt;
&lt;p&gt;前面文章以实例的方式对 Spring Batch 进行批处理进行详细说明，相信大家对字符串、文件，关系型数据库及 NoSQL 数据库的读取，处理，写入流程已比较熟悉。有小伙伴就问，针对这个任务流程，期间有多个步骤，从任务（ Job ）启动，到作业步（ Step ）的执行，其中又包含读组件、处理组件、写组件，那么，针对这个流程，若中间需要传递自定义的数据，该如何处理？本文将对 Spring Batch 进行数据传递的方法进行描述，依然会使用代码实例的方式进行讲解。包括以下几个内容：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;基于 Mybatis-plus 集成多数据源的数据库访问&lt;/li&gt;
&lt;li&gt;使用 ExecutionContext 共享数据&lt;/li&gt;
&lt;li&gt;StepScope 动态绑定参数传递&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;2-开发环境&quot;&gt;2 开发环境&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;JDK环境: jdk1.8&lt;/li&gt;
&lt;li&gt;Spring Boot: 2.1.4.RELEASE&lt;/li&gt;
&lt;li&gt;Spring Batch:4.1.2.RELEASE&lt;/li&gt;
&lt;li&gt;开发IDE: IDEA&lt;/li&gt;
&lt;li&gt;构建工具Maven: 3.3.9&lt;/li&gt;
&lt;li&gt;日志组件logback:1.2.3&lt;/li&gt;
&lt;li&gt;lombok:1.18.6&lt;/li&gt;
&lt;li&gt;MySQL: 5.6.26&lt;/li&gt;
&lt;li&gt;Mybatis-plus: 3.4.0&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;本示例源码已放至&lt;a href=&quot;https://github.com/mianshenglee/spring-batch-example/tree/master/spring-batch-param&quot;&gt;github&lt;/a&gt;：&lt;code&gt;https://github.com/mianshenglee/spring-batch-example/tree/master/spring-batch-param&lt;/code&gt;，请结合示例代码进行阅读。&lt;/p&gt;
&lt;h2 id=&quot;3-基于-mybatis-plus-集成多数据源的数据库访问&quot;&gt;3 基于 Mybatis-plus 集成多数据源的数据库访问&lt;/h2&gt;
&lt;p&gt;本示例还是使用原来示例功能，从源数据库读取用户数据，处理数据，然后写入到目标数据库。其中会在任务启动时传递参数，并在作业步中传递参数。之前已经介绍过如何使用 beetlsql 进行多数据源配置（[便捷的数据读写-spring batch(5)结合beetlSql进行数据读写][5]），实现数据批处理。还有很多朋友使用 Mybatis 或 Mybatis-plus 进行数据库读写，因此，有必要提一下 Spring Batch 如何结合 Mybatis 或 Mybatis-plus 配置多数据源操作。本示例以 Mybatis-plus 为例。&lt;/p&gt;
&lt;p&gt;示例工程中的&lt;code&gt;sql&lt;/code&gt;目录有相应的数据库脚本，其中源数据库&lt;code&gt;mytest.sql&lt;/code&gt;脚本创建一个&lt;code&gt;test_user&lt;/code&gt;表，并有相应的测试数据。目标数据库 &lt;code&gt;my_test1.sql&lt;/code&gt; 与 &lt;code&gt;mytest.sql&lt;/code&gt;表结构一致，&lt;code&gt;spring-batch-mysql.sql&lt;/code&gt;是 Spring Batch 本身提供的数据库脚本。&lt;/p&gt;
&lt;h3 id=&quot;31-pom-文件中引入-mybatis-plus&quot;&gt;3.1 pom 文件中引入 Mybatis-plus&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;!--mybatis-plus--&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.baomidou&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;mybatis-plus-boot-starter&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;3.4.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;32-配置及使用多数据源&quot;&gt;3.2 配置及使用多数据源&lt;/h3&gt;
&lt;p&gt;本示例会涉及三个数据库，分别是 Spring Batch 本身数据库，需要批处理的源数据库，批处理的目标数据库。因此需要处理多个数据库，利用多套源策略，可以很简单就完成多套数据源的处理。简单来说主要分为以下几个步骤：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;配置多数据源连接信息&lt;/li&gt;
&lt;li&gt;根据不同数据源划分&lt;code&gt;mapper&lt;/code&gt; 包，&lt;code&gt;entity&lt;/code&gt;包，&lt;code&gt;mapper.xml&lt;/code&gt;文件包&lt;/li&gt;
&lt;li&gt;根据不同数据源配置独立的&lt;code&gt;SqlSessionFactory&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;根据不同的应用场景，使用不同的 &lt;code&gt;mapper&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;关于多数据源多套源策略的详细配置过程，可以参考我的另一篇文章《&lt;a href=&quot;https://mp.weixin.qq.com/s/0J-FLYScYtEMnj0vZToX7g&quot;&gt;搞定SpringBoot多数据源(1)：多套源策略&lt;/a&gt;》&lt;/p&gt;
&lt;h2 id=&quot;4-executioncontext-传递参数&quot;&gt;4 ExecutionContext 传递参数&lt;/h2&gt;
&lt;p&gt;关于 Spring Batch 的读数据（ ItemReader ）、处理数据（ ItemProcessor ）、写数据（ ItemWriter ）的配置流程，可以参考前面系列文章，本文不再详细描述。我们需要记住的是，当一个作业（ Job ）启动，Spring Batch 是通过作业名称（ Job name）及 作业参数（ JobParameters ）作为唯一标识来区分不同的作业。一个 Job 下可以有多个作业步（ Step ），每个 Step 中就是有具体的操作逻辑（读、处理、写）。在 Job 和 Step 下的各个操作步骤间，如何传递，，这里就需要理解 ExecutionContext 的概念。&lt;/p&gt;
&lt;h3 id=&quot;41-executioncontext-概念&quot;&gt;4.1 ExecutionContext 概念&lt;/h3&gt;
&lt;p&gt;在 Job 的运行及 Step 的运行过程中，Spring Batch 提供 ExecutionContext 进行运行数据持久化，利用它，可以根据业务进行数据共享，如用来重启的静态数据与状态数据。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/mianshenglee/datastorage/raw/master/md-photo/springbatch/springbatch-9/spring%20batch-%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92.png&quot; alt=&quot;Spring Batch 参数传递&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Execution Context 本质上来讲就是一个 &lt;code&gt;Map&amp;lt;String,Object&amp;gt;&lt;/code&gt; ，它是Spring Batch 框架提供的持久化与控制的 key/value 对，可以让开发者在 Step 运行或Job 运行过程中保存需要进行持久化的状态，它可以。分为两类，一类是Job 运行的上下文（对应数据表：BATCH_JOB_EXECUTION_CONTEXT），另一类是Step Execution的上下文（对应数据表BATCH_STEP_EXECUTION_CONTEXT）。两类上下文关系：一个 Job 运行对应一个 Job Execution 的上下文（如上图中蓝色部分的 ExecutionContext ），每个 Step 运行对应一个 Step Execution 上下文（如上图中粉色部分的 ExecutionContext ）；同一个 Job 中的 Step Execution 共用 Job Execution 的上下文。也就是说，它们的作用范围有区别。因此，如果同一个 Job 的不同 Step 间需要共享数据时，可以通过 Job Execution 的上下文共享数据。根据 ExecutionContext 的共享数据特性，则可以实现在不同步骤间传递数据。&lt;/p&gt;
&lt;h3 id=&quot;42-executioncontext-传递数据&quot;&gt;4.2 ExecutionContext 传递数据&lt;/h3&gt;
&lt;p&gt;一个 Job 启动后，会生成一个 JobExecution ，用于存放和记录 Job 运行的信息，同样，在 Step 启动后，也会有对应的 StepExecution 。如前面所说，在 JobExecution 和 StepExecution 中都会有一个 ExecutionContext ，用于存储上下文。因此，数据传递的思路就是确定数据使用范围，然后通过 ExecutionContext 传入数据，然后就可以在对应的范围内共享数据。如当前示例，需要 Job 范围内共享数据，在读组件（ ItemReader ）和写组件（ ItemWriter ）中传递读与写数据的数量（ size ），在 Job 结束时，输出读及写的数据量。实际上 Spring Batch 会自动计算读写数量，本示例仅为了显示数据共享功能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/mianshenglee/datastorage/raw/master/md-photo/springbatch/springbatch-9/spring%20batch-%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92-2.png&quot; alt=&quot;共享数据&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么，如何获取对应的 Execution ？，Spring Batch 提供了 JobExecutionListener 和 StepExecutionListener 监听器接口，通过实现监听器接口，分别可以在开启作业前（ beforeJob ）和 完成作业后（ afterJob ）afterJob ），开启作业步前（ beforeStep）及 完成作业步后（ afterStep ）获取对应的 Execution ，然后进行操作。&lt;/p&gt;
&lt;h4 id=&quot;421-实现监听器接口&quot;&gt;4.2.1 实现监听器接口&lt;/h4&gt;
&lt;p&gt;在自定义的 UserItemReader 和 UserItemWriter 中，实现 StepExecutionListener 接口，其中使用 StepExecution 作为成员，从 beforeStep 中获取。如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class UserItemWriter implements ItemWriter&amp;lt;TargetUser&amp;gt;, StepExecutionListener {
    private StepExecution stepExecution;
    //...略
    @Override
    public void beforeStep(StepExecution stepExecution) {
        this.stepExecution = stepExecution;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;读组件（ UserItemReader ）也使用同样的方式。而在作业结束后，获取参数，则可以继承 JobExecutionListenerSupport ，实现自己感兴趣的方法，也从参数中获取 JobExecution，然后获取参数进行处理。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class ParamJobEndListener extends JobExecutionListenerSupport {
    @Override
    public void afterJob(JobExecution jobExecution) {}
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;422-设置用于传递的数据&quot;&gt;4.2.2 设置用于传递的数据&lt;/h4&gt;
&lt;p&gt;由于我们需要在 Job 范围内传递参数，获取到 StepExecution 后，可以获得相应的 JobExecution ，进而获取 Job 对应的 executionContext，这样，就可以在 Job 范围内共享参数数据了。如下是在读组件中进行配置&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;ExecutionContext executionContext = stepExecution.getJobExecution().getExecutionContext();
            executionContext.put(SyncConstants.PASS_PARAM_READ_NUM, items.size());
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样在写组件中，获取到 ExecutionContext 后，可以对参数进行处理。本示例中，是通过对 ItemReader 传递的处理数目参数进行累加处理，得到结果。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Override
public void write(List&amp;lt;? extends TargetUser&amp;gt; items) {
    ExecutionContext executionContext = stepExecution.getJobExecution().getExecutionContext();
    Object currentWriteNum = executionContext.get(SyncConstants.PASS_PARAM_WRITE_NUM);
    if (Objects.nonNull(currentWriteNum)) {
        log.info(&quot;currentWriteNum:{}&quot;, currentWriteNum);
        executionContext.put(SyncConstants.PASS_PARAM_WRITE_NUM, items.size()+(Integer)currentWriteNum);
    } else {
        executionContext.put(SyncConstants.PASS_PARAM_WRITE_NUM, items.size());
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后在作业结束后，在实现 JobExecutionListenerSupport 的接口中，afterJob 函数中，对参数进行输出。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class ParamJobEndListener extends JobExecutionListenerSupport {
    @Override
    public void afterJob(JobExecution jobExecution) {
        ExecutionContext executionContext = jobExecution.getExecutionContext();
        Integer writeNum = (Integer)executionContext.get(SyncConstants.PASS_PARAM_WRITE_NUM);
        log.info(LogConstants.LOG_TAG + &quot;writeNum:{}&quot;,writeNum);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;5-stepscope-动态绑定参数传递&quot;&gt;5 StepScope 动态绑定参数传递&lt;/h2&gt;
&lt;h3 id=&quot;51-stepscope及后期绑定&quot;&gt;5.1 StepScope及后期绑定&lt;/h3&gt;
&lt;p&gt;前面说到在 Job 及 Step 范围内，使用 ExecutionContext 进行数据共享，但，如果需要在 Job 启动前设置参数，并且每次启动输入的参数是动态变化的（比如增量同步时，日期是基于上一次同步的时间或者ID），也就是说，每次运行，需要根据参数新建一个操作步骤（如 ItemReader、ItemWriter等），我们知道，由于在 Spring IOC 中加载的Bean，默认都是单例模式的，因此，需要每次运行新建，运行完销毁，新建是在运行时进行的。这就需要用到StepScope 及后期绑定技术。&lt;/p&gt;
&lt;p&gt;在之前的示例中，已出现过 StepScope，它的作用是提供了操作步骤的作用范围，某个 Spring Bean 使用注解StepScope，则表示此 Bean 在作业步（ Step ）开始的时候初始化，在 Step 结束的时候销毁，也就是说 Bean的作用范围是在 Step 这个生命周期中。而 Spring Batch 通过属性后期绑定技术，在运行期获取属性值，并使用 SPEL 的表达式进行属性绑定。而在 StepScope 中，Spring Batch 框架提供 JobParameters，JobExecutionContext，StepExecutionContext，当然也可以使用 Spring 容器中的 Bean ，如 JobExecution ，StepExecution。&lt;/p&gt;
&lt;h3 id=&quot;52-作业参数传递及动态获取-stepexecution&quot;&gt;5.2 作业参数传递及动态获取 StepExecution&lt;/h3&gt;
&lt;p&gt;一个 Job 是由 Job name 及 JobParameters 作为唯一标识的，也就是说只有 job name 和 JobParameters 不一致时，Spring Batch 才会启动一个新的 Job，一致的话就当作是同一个 Job ，若 此 Job 未执行过，则执行；若已执行过且是 FAILED 状态，则尝试重新运行此 Job ，若已执行过且是 COMPLETED 状态，则会报错。&lt;/p&gt;
&lt;p&gt;本示例中，Job 启动时输入时间参数，在 ItemReader 中使用 StepScope 注解，然后把时间参数绑定到 ItemReader 中，同时绑定 StepExecution ，以便于在 ItemReader 对时间参数及 StepExecution 进行操作。&lt;/p&gt;
&lt;h4 id=&quot;521-设置时间参数&quot;&gt;5.2.1 设置时间参数&lt;/h4&gt;
&lt;p&gt;在使用 JobLauncher 启动 Job 时，是需要输入 jobParameters 作为参数的。因此可以创建此对象，并设置参数。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;JobParameters jobParameters = new JobParametersBuilder()
                .addLong(&quot;time&quot;,timMillis)
                .toJobParameters();
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;522-动态绑定参数&quot;&gt;5.2.2 动态绑定参数&lt;/h4&gt;
&lt;p&gt;在配置 Step 时，需要创建ItemReader 的 Bean，为了使用动态参数，在 ItemReader 中设置 Map 存放参数，并设置 StepExecution 为成员，以便于后面使用 ExecutionContext。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class UserItemReader implements ItemReader&amp;lt;User&amp;gt; {
    protected Map&amp;lt;String, Object&amp;gt; params;
    private StepExecution stepExecution;

    public void setStepExecution(StepExecution stepExecution) {
        this.stepExecution = stepExecution;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用 StepScope 进行配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Bean
@StepScope
public ItemReader paramItemReader(@Value(&quot;#{stepExecution}&quot;) StepExecution stepExecution,
                                  @Value(&quot;#{jobParameters['time']}&quot;) Long timeParam) {
    UserItemReader userItemReader = new UserItemReader();
    //设置参数
    Map&amp;lt;String, Object&amp;gt; params = CollUtil.newHashMap();
    Date datetime = new Date(timeParam);
    params.put(SyncConstants.PASS_PARAM_DATETIME, datetime);
    userItemReader.setParams(params);
    userItemReader.setStepExecution(stepExecution);

    return userItemReader;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：&lt;strong&gt;此时 ItemReader 不可再使用实现 StepExecutionListener 的方式来对 stepExecution 赋值&lt;/strong&gt;，由于 ItemReader 是动态绑定的，StepExecutionListener 将不再起作用，因此需要在后期绑定中来绑定 stepExecution Bean 的方式来赋值。&lt;/p&gt;
&lt;h4 id=&quot;523-设置及传递参数&quot;&gt;5.2.3 设置及传递参数&lt;/h4&gt;
&lt;p&gt;ItemReader 获取到 StepExecution 后即可获取 ExecutionContext，然后可以像前面说的使用 ExecutionContext 方式进行数据传递。如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;ExecutionContext executionContext = stepExecution.getJobExecution().getExecutionContext();
//readNum参数
executionContext.put(SyncConstants.PASS_PARAM_READ_NUM, items.size());
//datetime参数
executionContext.put(SyncConstants.PASS_PARAM_DATETIME,params.get(SyncConstants.PASS_PARAM_DATETIME));
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;6总结&quot;&gt;6.总结&lt;/h2&gt;
&lt;p&gt;在 Job 和 Step 不同的数据范围中，可使用 ExecutionContext 共享数据。本文以传递处理数量为例，使用 Mybatis-plus，基于 ExecutionContext ，结合 StepScope及后期绑定技术，实现在 Job 启动传入参数，然后在 ItemReader、ItemProcessor、ItemWriter 及 Job 完成后的数据共享及传递。如果你在使用 Spring Batch 过程中需要进行数据共享与传递，请试试这种方式吧。&lt;/p&gt;
&lt;h2 id=&quot;往期文章&quot;&gt;往期文章&lt;/h2&gt;
&lt;p&gt;如果文章内容对你有帮助，欢迎转发分享~&lt;/p&gt;
&lt;p&gt;我的公众号（搜索&lt;code&gt;Mason技术记录&lt;/code&gt;），获取更多技术记录：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/mianshenglee/datastorage/raw/master/md-photo/myphoto/wx/wx-public.jpg&quot; alt=&quot;Mason技术记录&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 30 Nov 2020 15:28:00 +0000</pubDate>
<dc:creator>Mason技术记录</dc:creator>
<og:description>在 Spring Batch 中进行数据及参数传递的方法。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/masonlee/p/14065614.html</dc:identifier>
</item>
<item>
<title>c++11-17 模板核心知识（十）—— 区分万能引用(universal references)和右值引用 - 张雅宸</title>
<link>http://www.cnblogs.com/zhangyachen/p/14065583.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangyachen/p/14065583.html</guid>
<description>&lt;h2 id=&quot;引子&quot;&gt;引子&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt;在代码里并不总是右值引用：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;void f(Widget&amp;amp;&amp;amp; param);      // rvalue reference

Widget&amp;amp;&amp;amp; var1 = Widget();      // rvalue reference

auto&amp;amp;&amp;amp; var2 = var1;        // not rvalue reference


template&amp;lt;typename T&amp;gt;
void f(std::vector&amp;lt;T&amp;gt;&amp;amp;&amp;amp; param);      // rvalue reference


template&amp;lt;typename T&amp;gt;
void f(T&amp;amp;&amp;amp; param);     // not rvalue reference
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt;代表两种含义：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;右值引用&lt;/li&gt;
&lt;li&gt;万能引用(universal references, or forwarding references)&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;如何区分&quot;&gt;如何区分&lt;/h2&gt;
&lt;p&gt;万能引用一般出现在两个场景中：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;模板参数&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;template&amp;lt;typename T&amp;gt;
void f(T&amp;amp;&amp;amp; param); // param is a universal reference
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;auto声明&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;auto&amp;amp;&amp;amp; var2 = var1; // var2 is a universal reference
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们分别讨论下这两种场景。&lt;/p&gt;
&lt;h3 id=&quot;模板参数&quot;&gt;模板参数&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;我们注意到，涉及到万能引用的地方，都会有参数推导的过程，例如上面的T和var2. 而右值引用则没有这个过程：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;void f(Widget&amp;amp;&amp;amp; param);        // no type deduction; param is an rvalue reference

Widget&amp;amp;&amp;amp; var1 = Widget();     // no type deduction; var1 is an rvalue reference
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是即使语句设计到参数推导，也不一定就是万能引用。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;template&amp;lt;typename T&amp;gt;
void f(std::vector&amp;lt;T&amp;gt;&amp;amp;&amp;amp; param);       // param is an rvalue reference


std::vector&amp;lt;int&amp;gt; v;
f(v); // error! can't bind lvalue to rvalue reference
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这点还是比较好理解的。万能引用需要依靠表达式来初始化自己是右值引用还是左值引用，但是上面这个例子没有表现出这一点，它仅仅是推断了T的类型，但是param的类型一直都是&lt;code&gt;std::vector&amp;lt;T&amp;gt;&amp;amp;&amp;amp;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;我们再举一个vector中的例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;template&amp;lt;class T, class Allocator = allocator&amp;lt;T&amp;gt;&amp;gt; 
class vector { 
public:

void push_back(T&amp;amp;&amp;amp; x);      // rvalue reference


template &amp;lt;class... Args&amp;gt; 
void emplace_back(Args&amp;amp;&amp;amp;... args);      // universal reference
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;push_back(T&amp;amp;&amp;amp; x)&lt;/code&gt;中的T&amp;amp;&amp;amp;为右值引用，因为这个虽然是T&amp;amp;&amp;amp;，但是不涉及到参数推导。当push_back被instantiated时，实际的调用类似于：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;std::vector&amp;lt;Widget&amp;gt; v;

...
class vector&amp;lt;Widget, allocator&amp;lt;Widget&amp;gt;&amp;gt; {
public:
void push_back(Widget&amp;amp;&amp;amp; x);       // rvalue reference
…
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以很明显的看出此时没有参数推导的过程。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;template &amp;lt;class... Args&amp;gt; emplace_back(Args&amp;amp;&amp;amp;... args)&lt;/code&gt;中的&lt;code&gt;Args&amp;amp;&amp;amp;&lt;/code&gt;为万能引用。Args与T是相互独立的，所以Args有一个独立的参数推断过程。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;const-disqualify-universal-reference&quot;&gt;const disqualify universal reference&lt;/h4&gt;
&lt;p&gt;有意思的是，当参数加上const后，就一定是右值引用：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;template &amp;lt;class T&amp;gt; int f(T&amp;amp;&amp;amp; heisenreference);
template &amp;lt;class T&amp;gt; int g(const T&amp;amp;&amp;amp;);

int i;
int n1 = f(i);         // calls f&amp;lt;int&amp;amp;&amp;gt;(int&amp;amp;)
int n2 = f(0);     // calls f&amp;lt;int&amp;gt;(int&amp;amp;&amp;amp;)
int n3 = g(i); // error: would call g&amp;lt;int&amp;gt;(const int&amp;amp;&amp;amp;), which would bind an rvalue reference to an lvalue
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至于为什么会有这个规定，按照&lt;a href=&quot;https://stackoverflow.com/questions/38814939/why-adding-const-makes-the-universal-reference-as-rvalue&quot;&gt;Why adding &lt;code&gt;const&lt;/code&gt; makes the universal reference as rvalue&lt;/a&gt;的说法，大体有两点原因：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;const T&amp;amp;&amp;amp;&lt;/code&gt;允许你重载一个函数模板，它只接受右值引用。如果&lt;code&gt;const T&amp;amp;&amp;amp;&lt;/code&gt;也被当做universal reference，那么将没有办法让函数只接受右值引用。&lt;/li&gt;
&lt;li&gt;显示禁用某个函数接受右值引用：&lt;code&gt;template &amp;lt;typename T&amp;gt; void cref(const T&amp;amp;&amp;amp;) = delete;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;auto声明&quot;&gt;auto声明&lt;/h3&gt;
&lt;p&gt;对于auto的场景来说，所有的&lt;code&gt;auto&amp;amp;&amp;amp;&lt;/code&gt;都是万能引用，因为它总是有参数推导的过程。例如定义一个记录函数执行时间的lambda（C++14中允许使用auto来声明lambda的函数）：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;auto timeFuncInvocation = [](auto &amp;amp;&amp;amp;func, auto &amp;amp;&amp;amp;... params) {  
  start timer;
  std::forward&amp;lt;decltype(func)&amp;gt;(func)(                      // invoke func
      std::forward&amp;lt;decltype(params)&amp;gt;(params)...      // on params
  );
  stop timer and record elapsed time;
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（完）&lt;/p&gt;
&lt;p&gt;朋友们可以关注下我的公众号，获得最及时的更新：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1298604/202011/1298604-20201103132150036-885052821.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 30 Nov 2020 15:22:00 +0000</pubDate>
<dc:creator>张雅宸</dc:creator>
<og:description>引子 如何区分 模板参数 const disqualify universal reference auto声明 引子 T&amp;amp;amp;&amp;amp;amp;在代码里并不总是右值引用： void f(</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhangyachen/p/14065583.html</dc:identifier>
</item>
<item>
<title>基于HAL库的STM32的DSP库详解(附FFT应用) - 廖伟伟</title>
<link>http://www.cnblogs.com/lwwBKY/p/14063829.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lwwBKY/p/14063829.html</guid>
<description>&lt;p&gt;3.  打开 option for target 选择 C/C++ 标签
&lt;/p&gt;&lt;p&gt;在define后添加：__TARGET_FPU_VFP,ARM_MATH_MATRIX_CHECK,ARM_MATH_ROUNDING,ARM_MATH_CM4,__CC_ARM,由于使用HAL的库，所以前面有USE_HAL_DRIVER,STM32F429xx的全局宏定义，如果使用的不是HAL库，而是使用固件库的话，一般会有固件库的一个全局宏定义USE_STDPERIPH_DRIVER和STM32F4XXxx在里面。所以当前只需要添加&lt;/p&gt;&lt;p&gt;注意中间用英文逗号分开。其中ARM_MATH_MATRIX_CHECK是库函数的参数检查开关。ARM_MATH_ROUNDING这个是库函数在运算是是否开启四舍五入的功能，可以根据实际需要进行配置。ARM_MATH_CM4这个就非常重要，必须要配置进去，否则在编译之后，会默认使用math.h的库函数，而不会用到硬件的FPU的。__CC_ARM是不同编译器的编译配置宏定义，__CC_ARM就是代表MDK开发环境。&lt;/p&gt;&lt;div readability=&quot;95&quot;&gt; 4. 添加浮点库(.lib)文件到工程(或者添加源码库文件)。
&lt;p&gt;如果用的是 uv4，打开 C:\Keil\ARM\CMSIS\Lib\ARM 目录，复制“arm_cortexM4lf_math.lib”文件到你的工程下，并加入工程。&lt;/p&gt;
&lt;p&gt;如果用的是 uv5，打开 C:\Keil_v5\ARM\Pack\ARM\CMSIS\4.2.0\CMSIS\Lib\ARM 目录，复制“arm_cortexM4lf_math.lib”文件到工程下，并加入工程，4.2.0是库的版本，每个版本可能不一样。&lt;/p&gt;
&lt;p&gt;也可以从官方下载固件库程序包中复制也行，  \STM32F4xx_DSP_StdPeriph_Lib\Libraries\CMSIS\Lib\ARM&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1451555/202011/1451555-20201130221635873-1236051845.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/div&gt;
&lt;p&gt;如果查看DSP库的各个函数的原型，可以添加源码库文件， 则当前工程目录下的Drivers\CMSIS\DSP_Lib\Source目录可以查看，当然安装目录下也有该库源文件。&lt;/p&gt;
&lt;p&gt;BasicMathFunctions&lt;/p&gt;
&lt;p&gt;&lt;span&gt;基本数学函数：提供浮点数的各种基本运算函数，如向量加减乘除等运算。 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;CommonTables&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;arm_common_tables.c文件提供位翻转或相关参数表。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ComplexMathFunctions&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;复杂数学功能，如向量处理，求模运算的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ControllerFunctions&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;控制功能函数。包括正弦余弦，PID电机控制，矢量Clarke变换，矢量Clarke逆变换等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;FastMathFunctions&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;快速数学功能函数。提供了一种快速的近似正弦，余弦和平方根等相比CMSIS计算库要快的数学函数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;FilteringFunctions&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;滤波函数功能，主要为FIR和LMS（最小均方根）等滤波函数。 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;MatrixFunctions&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;矩阵处理函数。包括矩阵加法、矩阵初始化、矩阵反、矩阵乘法、矩阵规模、矩阵减法、矩阵转置等函数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;StatisticsFunctions&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;统计功能函数。如求平均值、最大值、最小值、计算均方根RMS、计算方差/标准差等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SupportFunctions&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;支持功能函数，如数据拷贝，Q格式和浮点格式相互转换，Q任意格式相互转换。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;TransformFunctions&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;变换功能。包括复数FFT（CFFT）/复数FFT逆运算（CIFFT）、实数FFT（RFFT）/实数FFT逆运算（RIFFT）、和DCT（离散余弦变换）和配套的初始化函数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;相关函数说明以及示例也可在安装路径Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Documentation\DSP\html下获得，自行查阅。&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;/&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;5. DSP库的FFT变换示例。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在工程的main.c文件中添加如下代码&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;说明：采样频率为1024Hz，fft点数为1024点,则频率分辨率，计算公式：分辨率=采样频率/采样点数 = 1Hz，此时能看到0Hz,1Hz,2Hz,3Hz,.....512Hz的频率分量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;FFTOutput这个数组中，下标0对应的元素就是0Hz(也就是直流分量)的幅度，下标1对应的就是1Hz的幅度，下标2对应2Hz的幅度......,依次类推。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此点非常重要，例如采样率为2048Hz,那么频率分辨率为2Hz,那么能看到0Hz,2Hz,4Hz,6Hz,.....1024Hz的频率分量&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;FFTOutput这个数组中，下标0对应的元素就是0Hz(也就是直流分量)的幅度，下标1对应的就是2Hz的幅度，下标2对应4Hz的幅度......,依次类推。此时去看1Hz,3Hz，则会出现误差比较大的情况。&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;43&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
#include &quot;arm_math.h&quot;                  //添加头文件
#define  FFT_LENGTH        1024        //FFT长度，默认是1024点FFT&lt;br/&gt;#define  SAMPLE_FREQ       1024        //采样频率
&lt;/pre&gt;
&lt;pre&gt;
float fft_inputbuf[FFT_LENGTH*2];      //FFT输入输出数组，此数组为arm_cfft_radix4_f32的输入输出数组，前一个元素为实部，后一个为虚部，每两个元素代表一个点.
float fft_outputbuf[FFT_LENGTH];    //arm_cmplx_mag_f32()幅度输出数组
arm_cfft_radix4_instance_f32 scfft; //fft变换的初始化参数
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在主函数进入while(1)之前添加如下代码&lt;/p&gt;
&lt;p&gt;说明：arm_sin_f32函数生成采样点，采样信号为DC信号，100Hz，150Hz信号的叠加，此时分辨率为1Hz，刚好能够看到DC， 100Hz，150Hz频率分量的幅度，分别对应fft幅度输出数组的下标0,100,150&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
arm_cfft_radix4_init_f32(&amp;amp;scfft,FFT_LENGTH,0,1);//初始化scfft结构体，设定FFT相关参数&lt;br/&gt;for(int i=0;i&amp;lt;FFT_LENGTH;i++)//生成信号序列&lt;br/&gt;{&lt;br/&gt;fft_inputbuf[2*i]=&lt;span&gt;&lt;strong&gt;15&lt;/strong&gt;&lt;/span&gt; + &lt;span&gt;&lt;strong&gt;10&lt;/strong&gt;&lt;/span&gt;*arm_sin_f32(2*PI*i*100/SAMPLE_FREQ) + \&lt;br/&gt;&lt;span&gt;&lt;strong&gt;                  5.5&lt;/strong&gt;&lt;/span&gt;*arm_sin_f32(2*PI*i*150/SAMPLE_FREQ); //生成实部&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;         &lt;br/&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt; fft_inputbuf[2*i+1]=0;//虚部全部为0&lt;br/&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;}&lt;br/&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;arm_cfft_radix4_f32(&amp;amp;scfft,fft_inputbuf);    //FFT计算（基4（即fft长度2&lt;sup&gt;2*n&lt;/sup&gt;），FFT长度只能为64，256，1024，4096目前测试过这几个长度,）&lt;br/&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;arm_cmplx_mag_f32(fft_inputbuf,fft_outputbuf,FFT_LENGTH);    //把运算结果复数求模得幅值&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;DC分量值为15360.001,则对应的直流分量为15360.001/FFT点数 = 15360.001/1024=15&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1451555/202011/1451555-20201130225324872-1207359962.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;100Hz分量值为5119.99658,则对应的100Hz幅度为5119.99658*2/FFT点数 = 5119.99658*2/1024=10&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1451555/202011/1451555-20201130230050960-423669324.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;__mceDel&quot;&gt;150&lt;/span&gt;Hz分量值为2815.99976,则对应的150Hz幅度为2815.99976*2/FFT点数 = 2815.99976*2/1024=5.5&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1451555/202011/1451555-20201130230025168-912185189.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其余的频率的幅度近似为0。&lt;/p&gt;
&lt;p&gt;若要查看某一频率分量的实部与虚部，则可以查看fft_inputbuf数组。下标对应乘以2,因为实部和虚部存在。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;当把采样频率改为2048Hz，生成信号频率其中一路改为151Hz,读者可以自行测试该频率分量的幅度，肯定会存在误差。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;</description>
<pubDate>Mon, 30 Nov 2020 15:16:00 +0000</pubDate>
<dc:creator>廖伟伟</dc:creator>
<og:description>1 . 建立工程，生成代码时选择包含所有库。 2. 打开 option for target 选择 Target 标签，在code generatio中，将floating point hardwar</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lwwBKY/p/14063829.html</dc:identifier>
</item>
</channel>
</rss>