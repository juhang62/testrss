<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>设计模式——搓澡模板 - 陈本布衣</title>
<link>http://www.cnblogs.com/chenbenbuyi/p/13251272.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenbenbuyi/p/13251272.html</guid>
<description>&lt;h2&gt;关于搓澡的技术演进&lt;/h2&gt;
&lt;p&gt;　　夏天到了，天气炎热，每天都是臭汗直冒；自己再怎么不爱干净，还是要坚持每天洗澡，不然婆娘肯定是不让上床的，毕竟，谁也不愿意啃一坨臭烘烘的肉。&lt;/p&gt;
&lt;p&gt;　　所以，洗澡事小，关系犹大。作为程序员，尤其是 Java 程序员，博主还煞有介事的，把每日的洗澡的步骤给记录了下来——&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Bath {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; bathing(){
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         System.out.println(&quot;入浴：更衣解带，进入浴房&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         System.out.println(&quot;洗头：一盆顶水湿全身，先抹飘油洗秃顶。。。&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         System.out.println(&quot;洗身：浴球在手，全身都有——左刷刷，右刷刷，前刷刷，后刷刷，上刷刷，下刷刷。。。&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         System.out.println(&quot;出浴：洗罢冲净，盛装出浴&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　当然，以上只是最基本的操作步骤，其实每一个步骤都还有很多不可描述的细节没有具化——毕竟，洗澡还是一个颇为复杂的系统性操作。后来，有好事者觉得步骤太过简略，向博主求问洗澡的各种实现细节，博主不堪骚扰，决定将原来的步骤进行细化。但是，如果直接在原方法步骤里面再去添加长篇大论的描述（脑补一下我在每个打印中再扩展1万字说开去），会严重影响原方法代码中洗澡步骤的连贯性和可读性，代码会显很冗余，不太好看。作为一个惯于封装的 Java 程序员，怎么可能容忍那么 low 的代码呢？所以，基于代码整洁的考虑，博主首先想到了方法抽取，将洗澡的各个步骤抽取出来成为单独的业务方法，然后再给原方法按步骤调用就行了，于是，原来的代码就变成了下面这样子——&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Bath {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; bathing(){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.enterTheBathroom();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.washThehair();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.washTheBody();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.outTheBathroom();
    }


    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; enterTheBathroom(){
        System.out.println(&lt;/span&gt;&quot;其实，对于我等屌丝来说，宽衣解带？不存在的。经常是一条裤子一挎，就已经是裸体状态了。。。（此处有1万字）&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; washThehair(){
        System.out.println(&lt;/span&gt;&quot;我不经意间摸到了自己不再茂盛的秀发，不觉有些感伤，想到自己撸码不过几年光景，头发就如秋风一扫，簌簌直掉。。。（此处有1万字）&quot;&lt;span&gt;);
    }


    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; washTheBody(){
        System.out.println(&lt;/span&gt;&quot;其实自己喜欢舒肤佳多一点，喜欢香皂在自己肌肤上滑过的细腻感。不过因为太滑，香皂总掉旁边的茅坑里，即使侥幸没掉坑里，也总怕谁冷不丁的在背后替我将肥皂捡起。。。（此处有1万字）&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; outTheBathroom(){
        System.out.println(&lt;/span&gt;&quot;洗完澡我才猛然发现，根本就没带衣服进来。。。（此处有1万字）&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　代码改完，搓澡细节展示更加生动了，博主颇感满意。某天夫人洗澡时脚滑踩蹲坑里去了，出来又对我破口大骂，无非是哪个闺蜜嫁得好人家咯，洗澡都用淋浴房而不是站在蹲坑上；哪个闺蜜家里又是专用浴缸可以泡牛奶浴咯云云，都是些陈词滥调的抱怨，自己早就听的不耐烦了，由她去。不过，这一骂倒是让自己对上面的搓澡步骤又有了新的想法。所谓人分三六九等，阶层不同，洗澡的场所、方式也就大不一样。单说洗澡的场所，有钱人进的是专用浴缸或者专门的淋浴房，而自己进的是多功能的搓澡茅房。不过也还好啦，好歹是个单间，比上不足比下有余，像我工地搬砖的表弟，就只能进可以欣赏彼此 pp 的人民澡堂。&lt;/p&gt;
&lt;p&gt;　　所以，回看自己上面的代码，就发现一个很严重的问题，那就是没有普适性，可移植性太差，因为只有自己是这样长篇大论的洗澡的，别人都不是。所以，为了通用性，很有必要将每个步骤进一步抽象。怎么抽象呢，第一直觉是，将几个搓澡方法用接口定义，然后不管是有钱人还是我这样的屌丝抑或搬砖的表弟，要洗澡，实现接口细化操作即可，似乎没什么难度。但是这里有一个问题，就是实现接口可以，但是上述搓澡的操作顺序必须要有保证，你总不能先穿衣出来然后又脱衣进去吧？所以，必须要对搓澡步骤有一个明确的定义，任何要洗澡的人，对接口进行实现的时候，都只能按照搓澡步骤来执行实现的方法，不能乱套！&lt;/p&gt;
&lt;p&gt;　　基于这种思想，博主很爽利的将上述代码改成了下面的形式——&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; BathStep {

    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; enterTheBathroom();

    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; washThehair();

    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; washTheBody();

    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; outTheBathroom();
}


&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MyBath &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; BathStep{

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; bathing(){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.enterTheBathroom();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.washThehair();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.washTheBody();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.outTheBathroom();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; enterTheBathroom(){
        System.out.println(&lt;/span&gt;&quot;其实，对于我等屌丝来说，宽衣解带？不存在的。经常是一条裤子一挎，就已经是裸体状态了。。。（此处有1万字）&quot;&lt;span&gt;);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; washThehair(){
        System.out.println(&lt;/span&gt;&quot;我不经意间摸到了自己不再茂盛的秀发，不觉有些感伤，想到自己撸码不过几年光景，头发就如秋风一扫，簌簌直掉。。。（此处有1万字）&quot;&lt;span&gt;);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; washTheBody(){
        System.out.println(&lt;/span&gt;&quot;其实自己喜欢舒肤佳多一点，喜欢香皂在自己肌肤上滑过的细腻感。不过因为太滑，香皂总掉旁边的茅坑里，即使侥幸没掉坑里，也总怕谁冷不丁的在背后替我将肥皂捡起。。。（此处有1万字）&quot;&lt;span&gt;);
    }
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; outTheBathroom(){
        System.out.println(&lt;/span&gt;&quot;洗完澡我才猛然发现，根本就没带衣服进来。。。（此处有1万字）&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这代码稍微有那么点意思了，但是细品一下还是有很大问题。第一，规范搓澡步骤的方法没有抽离出来，而是让接口的实现者去定义，这看起来很荒谬；第二，虽然将搓澡步骤都提成了接口，满足了自定义的需求，但问题恰恰在于，有些步骤并不需要自定义实现，比如washTheBody，管你谁谁谁，肯定也是差不多的要搓上搓下吧；比如出浴，也都是穿好衣服再出来吧。所以，全部定义成接口并不是最好的方式，很多时候你会为了满足一些共性操作，不得不单独定义一个适配器类来对接口中需要的共性方法做一些默认的实现，反倒是增加了复杂度（虽然Java8之后的接口已经可以默认实现了，但为了满足更大的版本兼容性，博主这里依然还采取传统一些的方式吧）。&lt;/p&gt;
&lt;p&gt;　　思来想去，既然接口不能很好的满足，那就只能抽象类了。稍以琢磨，定义抽象类倒有不少好处——&lt;/p&gt;
&lt;p&gt;　　　　一，对于不需要搓澡人自定义的步骤，直接在抽象类中功能实现即可，不用绕圈子；哪怕谁对步骤有自定义需求，子类覆盖父类方法即可（也看个人设计是否允许覆盖）；&lt;/p&gt;
&lt;p&gt;　　　　二，对于需要搓澡人自定义的步骤，定义为抽象方法，强制子类对步骤做具体的自定义实现；&lt;/p&gt;
&lt;p&gt;　　　　三，对于不可变的搓澡纲领问题，在该抽象类中可很方便的以单独的方法进行明确约束定义，同时，为防止具体的搓澡人随意更改步骤，很有必要将该约束搓澡步骤的方法定义为 final 的；&lt;/p&gt;
&lt;p&gt;　　思想进一步明确之后，博主又很爽利的将搓澡的代码改成了下面这个样子——&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Bath {
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; bathing(){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.enterTheBathroom();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.washThehair();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.washTheBody();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.outTheBathroom();
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 需要子类具体实现的步骤&lt;/span&gt;
    &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; enterTheBathroom();
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 需要子类具体实现的步骤&lt;/span&gt;
    &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; washThehair();

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; washTheBody(){
        System.out.println(&lt;/span&gt;&quot;其实自己喜欢舒肤佳多一点，喜欢香皂在自己肌肤上滑过的细腻感。不过因为太滑，香皂总掉旁边的茅坑里，即使侥幸没掉坑里，也总怕谁冷不丁的在背后替我将肥皂捡起。。。（此处有1万字）&quot;&lt;span&gt;);
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; outTheBathroom(){
        System.out.println(&lt;/span&gt;&quot;洗完澡我才猛然发现，根本就没带衣服进来。。。（此处有1万字）&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　所以，你悟出什么了吗，这就是模板方法模式啊！上面代码中的 bathing 方法，即是所谓的模板方法——&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;&lt;strong&gt;&lt;em&gt;在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中去；模板方法可以在子类不改变算法结构的情况下，重新定义算法中的某些步骤。&lt;/em&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　自此，你再带着定义再回头看看博主关于搓澡的技术演进，你应该就比较明了了——所谓的模板方法模式，也就那么回事。&lt;/p&gt;
&lt;p&gt;　　当然，上面的代码场景还是有不灵活的地方，比如步骤中搓澡才是核心功能，洗头与否，是完全看个人心情的，你这强行要求别人洗澡必洗头，怕是不太好吧？如何将决定权交给搓澡人自己呢，这也是模板方法这种模式中经常运用到的，通过添加钩子判断函数，让搓澡人根据心情去覆写改变判断逻辑，从而达到间接干预模板方法执行流的目的。模板方法都通透了，添加钩子就是易如反掌的事情了。博主就不贴代码了，让搓澡的你，自己去实现为妙！&lt;/p&gt;
&lt;h2&gt;模式生态&lt;/h2&gt;
&lt;p&gt;　　对于模板方法模式的运用，不论JDK自己的类库中还是我们常用框架的源码中，你都能很轻松的找到很多示例供你参考学习。博主试举几例，做个引子。&lt;/p&gt;
&lt;p&gt;　　比如，在JDK的源码中IO流中，你可以看到所有输入字节流的超类 InputStream是下面这样的——&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1231169/202007/1231169-20200707224253910-1649657420.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　输出字节流、以及字符流等形同此例，都是基于抽象类先提供基本的算法骨架，然后子类在进行具体的方法实现。&lt;/p&gt;
&lt;p&gt;　　 再比如，Java 程序员早已离不开的 Spring，在其帝国源码版图中，你也随处能找到形似的或神似的模板方法代码。比如下面这段在 AbstractApplicationContext 抽象类中刷新容器的代码——&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; refresh() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeansException, IllegalStateException {
        &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.startupShutdownMonitor) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Prepare this context for refreshing.&lt;/span&gt;
&lt;span&gt;            prepareRefresh();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Tell the subclass to refresh the internal bean factory.&lt;/span&gt;
            ConfigurableListableBeanFactory beanFactory =&lt;span&gt; obtainFreshBeanFactory();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Prepare the bean factory for use in this context.&lt;/span&gt;
&lt;span&gt;            prepareBeanFactory(beanFactory);

            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Allows post-processing of the bean factory in context subclasses.&lt;/span&gt;
&lt;span&gt;                postProcessBeanFactory(beanFactory);

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Invoke factory processors registered as beans in the context.&lt;/span&gt;
&lt;span&gt;                invokeBeanFactoryPostProcessors(beanFactory);

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Register bean processors that intercept bean creation.&lt;/span&gt;
&lt;span&gt;                registerBeanPostProcessors(beanFactory);

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Initialize message source for this context.&lt;/span&gt;
&lt;span&gt;                initMessageSource();

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Initialize event multicaster for this context.&lt;/span&gt;
&lt;span&gt;                initApplicationEventMulticaster();

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Initialize other special beans in specific context subclasses.&lt;/span&gt;
&lt;span&gt;                onRefresh();

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Check for listener beans and register them.&lt;/span&gt;
&lt;span&gt;                registerListeners();

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Instantiate all remaining (non-lazy-init) singletons.&lt;/span&gt;
&lt;span&gt;                finishBeanFactoryInitialization(beanFactory);

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Last step: publish corresponding event.&lt;/span&gt;
&lt;span&gt;                finishRefresh();
            }

            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (BeansException ex) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isWarnEnabled()) {
                    logger.warn(&lt;/span&gt;&quot;Exception encountered during context initialization - &quot; +
                            &quot;cancelling refresh attempt: &quot; +&lt;span&gt; ex);
                }

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Destroy already created singletons to avoid dangling resources.&lt;/span&gt;
&lt;span&gt;                destroyBeans();

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Reset 'active' flag.&lt;/span&gt;
&lt;span&gt;                cancelRefresh(ex);

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Propagate exception to caller.&lt;/span&gt;
                &lt;span&gt;throw&lt;/span&gt;&lt;span&gt; ex;
            }

            &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Reset common introspection caches in Spring's core, since we
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; might not ever need metadata for singleton beans anymore...&lt;/span&gt;
&lt;span&gt;                resetCommonCaches();
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　或许看不懂方法执行过程中每一步的意思，但其一步两步的代码走位风格，和博主搓澡步骤是何其的形似啊。还有一些常见功能如操作数据库，事务管理等，其原始操作本身就有明显的步骤先后的要求——也即模式术语所谓的算法骨架（如数据库操作要加载驱动、建立连接、预编译、执行sql、释放资源等），所以采用模板方法也是非常应景的操作手法。只不过，Spring对原始操作进行的封装和转换等处理，让你可能不是那么容易的能从繁杂的代码中观其大略的，但至少，有了这一层思想之后，你在看源码的时候，或许更能触类旁通一些东西！&lt;/p&gt;
&lt;h2&gt;布衣说法　　&lt;/h2&gt;
&lt;p&gt;　　看到这里，可能有些小伙伴会觉得博主所讲的或所举示例不是那么标准，有些形似又有些神似，完全没有搓澡的时候那么爽利啊。&lt;/p&gt;
&lt;p&gt;　　那么，关于设计模式的学习，你觉得你应该形似还是神似呢？学其形，势必要刻板的遵循定义，依葫芦画瓢，那只是没有灵魂的模仿；悟其神，参透模式背后的设计思想，才是你能灵活运用的基本前提。悟道之后，你可以发散很多撸码的思想。譬如，博主上面提到的干预模板方法执行流的钩子方法，实际运用中，我一定要定义一个钩子判断才行吗，我可以不以给方法一个空实现，不也能达到只搓澡不洗头的目的吗？譬如 Spring那个刷新容器的 refresh 方法，你会发现其方法步骤的每一步其实都在本地完成了实现，并不没有定义成抽象方法交给子类去实现。是的，人家只是要基于代码整洁的考虑，将复杂的业务通通封装成一个个单独的方法，逻辑清晰明了，代码整洁不冗余，这样的模板方法可不完全符合模板方法的定义的，但看起来爽啊！所以，你的模式学习，是不是还要那么循规蹈矩，呆板教条呢？&lt;/p&gt;
&lt;p&gt;　    自此，布衣博主版的模板方法模式，拉拉杂杂的，也算阐述完毕了。啥玩意儿？还要模式的 UML 类图，应用场景、优缺点总结？卧槽，真当写教材呢，心法口诀的教给你了，整那些学究的玩意儿干啥呢！&lt;/p&gt;
&lt;p&gt;　　 不说了，收工！&lt;/p&gt;

</description>
<pubDate>Wed, 08 Jul 2020 00:46:00 +0000</pubDate>
<dc:creator>陈本布衣</dc:creator>
<og:description>关于搓澡的技术演进 夏天到了，天气炎热，每天都是臭汗直冒；自己再怎么不爱干净，还是要坚持每天洗澡，不然婆娘肯定是不让上床的，毕竟，谁也不愿意啃一坨臭烘烘的肉。 所以，洗澡事小，关系犹大。作为程序员，尤</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chenbenbuyi/p/13251272.html</dc:identifier>
</item>
<item>
<title>Nmap常见扫描方式流量分析 - syncd</title>
<link>http://www.cnblogs.com/zhaof/p/13264836.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhaof/p/13264836.html</guid>
<description>&lt;h2 id=&quot;环境说明&quot;&gt;环境说明&lt;/h2&gt;
&lt;p&gt;扫描者：&lt;code&gt;manjaro linux&lt;/code&gt; ， IP地址：&lt;code&gt;192.168.31.160&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;被扫描者：&lt;code&gt;centos 7&lt;/code&gt;，IP地址：&lt;code&gt;192.168.31.175&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;分析工具：&lt;code&gt;wireshark&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;nmap 版本：version 7.80&lt;/p&gt;
&lt;h2 id=&quot;tcp-知识回顾&quot;&gt;TCP 知识回顾&lt;/h2&gt;
&lt;p&gt;这里对TCP的三次握手知识进行简单的回顾，方便后面理解&lt;code&gt;Nmap&lt;/code&gt;的扫描流量&lt;/p&gt;
&lt;p&gt;关于TCP协议相关内容看：&lt;a href=&quot;http://networksorcery.com/enp/default.htm&quot;&gt;http://networksorcery.com/enp/default.htm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/07/04/NxilvR.png&quot; alt=&quot;tcp_header.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Source Port&lt;/strong&gt;：源端口&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Destination Port&lt;/strong&gt;：目的端口&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Sequence Number&lt;/strong&gt;：序列号。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Acknowledgment Number&lt;/strong&gt;：确认号&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Control Bits&lt;/strong&gt;： 包含一下几种（这几个字段这里要有印象，后续关于nmap的扫描都和这里会有关系）：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;字段&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;4.5&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;URG&lt;/td&gt;
&lt;td&gt;紧急指针是否有效。如果设置1，用于通知接收数据方在处理所有数据包之前处理紧急数据包&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;ACK&lt;/td&gt;
&lt;td&gt;确认号是否有效。用于确认主机成功接收数据包。如果&lt;strong&gt;Acknowledgment Number&lt;/strong&gt;包含有效的确认号码，则设置ACK标志为。例如tcp三次握手的第二步，发送ACK=1和SYN=1 ，就是告知对方它已经收到初始包&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;PSH&lt;/td&gt;
&lt;td&gt;强制将数据压入缓冲区&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;RST&lt;/td&gt;
&lt;td&gt;连接重置&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;SYN&lt;/td&gt;
&lt;td&gt;表示建立连接&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;FIN&lt;/td&gt;
&lt;td&gt;表示关闭连接&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;下图是TCP三次握手的过程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/07/06/UiyDCF.png&quot; alt=&quot;tcp.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;syn-扫描&quot;&gt;SYN 扫描&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Nmap&lt;/code&gt; 的默认扫描方式就是SYN扫描，在&lt;code&gt;192.168.31.160&lt;/code&gt; 执行如下命令进行扫描：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;➜ sudo nmap -p22 192.168.31.175
Starting Nmap 7.80 ( https://nmap.org ) at 2020-07-04 11:45 CST
Nmap scan report for 192.168.31.175
Host is up (0.00044s latency).

PORT   STATE SERVICE
22/tcp open  ssh
MAC Address: 4C:1D:96:FC:4D:E2 (Unknown)

Nmap done: 1 IP address (1 host up) scanned in 0.38 seconds

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在&lt;code&gt;192.168.31.175&lt;/code&gt; 进行tcpdump 命令进行抓包：&lt;code&gt;tcpdump -i any -w syn_scan.pcap&lt;/code&gt;, 下面是通过wireshare分数据包分析截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/07/04/NvOWon.png&quot; alt=&quot;syn.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从获取的流量可以很容易看到，这种扫描的的方式是在三次握手的最后一步没有回复正常的ACK,而是发送了RST&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/07/06/UiIVmD.png&quot; alt=&quot;syn_2.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;nmap 利用客户端回SYN，ACK 的这个数据包其实就已经知道22这个端口是开放的，如果我们扫描一个没有开放的端口：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;➜  sudo nmap -p80 192.168.31.175 
Starting Nmap 7.80 ( https://nmap.org ) at 2020-07-06 22:08 CST
Nmap scan report for 192.168.31.175
Host is up (0.00034s latency).

PORT   STATE  SERVICE
80/tcp closed http
MAC Address: 4C:1D:96:FC:4D:E2 (Unknown)

Nmap done: 1 IP address (1 host up) scanned in 0.34 seconds

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样我们看一下在192.168.31.175 上抓的数据包的情况，被扫描主机直接恢复RST，ACK断开连接，namp从而知道被扫描端口是关闭的，数据包如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/07/06/UiTro4.png&quot; alt=&quot;syn_rst.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;全连接扫描&quot;&gt;全连接扫描&lt;/h2&gt;
&lt;p&gt;nmap也可以进行全连接扫描，也就是完成完整的三次握手，当然这种扫描方式的效率是不如SYN扫描的&lt;/p&gt;
&lt;p&gt;&lt;code&gt;nmap -sT -p端口 目标主机&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;null扫描&quot;&gt;NULL扫描&lt;/h2&gt;
&lt;blockquote readability=&quot;30&quot;&gt;
&lt;p&gt;是将一个没有设置任何标志位的数据包发送给TCP端口,在正常的通信中至少要设置一个标志位。&lt;/p&gt;
&lt;p&gt;根据FRC 793的要求,&lt;strong&gt;在端口关闭的情况&lt;/strong&gt;下,若收到一个没有设置标志位的数据字段,那么主机应该舍弃这个分段,并发送一个RST数据包,否则不会响应发起扫描的客户端计算机。&lt;/p&gt;
&lt;p&gt;也就是说,如果TCP端口处于关闭则响应一个RST数据包,若处于开放则无相应。但是应该知道理由NULL扫描要求所有的主机都符合RFC 793规定,但是windows系统主机不遵从RFC 793标准,且只要收到没有设置任何标志位的数据包时,不管端口是处于开放还是关闭都响应一个RST数据包。但是基于Unix(&lt;em&gt;nix,如Linux)遵从RFC 793标准,所以可以用NULL扫描。 经过上面的分析,我们知道NULL可以辨别某台主机运行的操作系统是什么操作系统,是为windows呢?还是&lt;/em&gt;unix/linux?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;NULL的扫描命令参数：&lt;code&gt;nmap -sN&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;➜  sudo nmap -sN -p22 192.168.31.175  
Starting Nmap 7.80 ( https://nmap.org ) at 2020-07-06 22:30 CST
Nmap scan report for 192.168.31.175
Host is up (0.00022s latency).

PORT   STATE         SERVICE
22/tcp open|filtered ssh
MAC Address: 4C:1D:96:FC:4D:E2 (Unknown)

Nmap done: 1 IP address (1 host up) scanned in 0.67 seconds
➜ sudo nmap -sN -p999 192.168.31.175
Starting Nmap 7.80 ( https://nmap.org ) at 2020-07-06 22:30 CST
Nmap scan report for 192.168.31.175
Host is up (0.00042s latency).

PORT    STATE  SERVICE
999/tcp closed garcon
MAC Address: 4C:1D:96:FC:4D:E2 (Unknown)

Nmap done: 1 IP address (1 host up) scanned in 0.34 seconds
➜  share scp root@192.168.31.175:/root/null.pcap ./     
root@192.168.31.175's password: 
null.pcap                             100% 5188    10.4MB/s   00:00 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 分别扫描了一个开放的端口22 和未开放的端口999，下面的数据包中，可以看到，发送的第一个TCP包中&lt;strong&gt;Control Bits&lt;/strong&gt;的所有Flags都没有设置，而开发的22端口没有收到任何回复，而关闭的端口，收到了一个RST数据包，nmap也是通过这种方式来判断端口是否开放。当然这种判断对于windows是不准确的了。&lt;/p&gt;
&lt;p&gt;​ null的扫描流量特征还是非常明显的，很容易通过流量分析知道正在被进行null扫描。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/07/06/UibRln.png&quot; alt=&quot;null.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;fin扫描&quot;&gt;FIN扫描&lt;/h2&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;FIN 原理：&lt;/p&gt;
&lt;p&gt;与NULL有点类似,只是FIN为指示TCP会话结束,在FIN扫描中一个设置了FIN位的数据包被发送后,若响应RST数据包,则表示端口关闭,没有响应则表示开放。此类扫描同样不能准确判断windows系统上端口开放情况。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;FIN扫描命令参数：&lt;code&gt;nmap -sF&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;➜ sudo nmap -sF -p22 192.168.31.175       
Starting Nmap 7.80 ( https://nmap.org ) at 2020-07-06 22:46 CST
Nmap scan report for 192.168.31.175
Host is up (0.00014s latency).

PORT   STATE         SERVICE
22/tcp open|filtered ssh
MAC Address: 4C:1D:96:FC:4D:E2 (Unknown)

Nmap done: 1 IP address (1 host up) scanned in 0.61 seconds
➜ sudo nmap -sF -p999 192.168.31.175
Starting Nmap 7.80 ( https://nmap.org ) at 2020-07-06 22:46 CST
Nmap scan report for 192.168.31.175
Host is up (0.00028s latency).

PORT    STATE  SERVICE
999/tcp closed garcon
MAC Address: 4C:1D:96:FC:4D:E2 (Unknown)

Nmap done: 1 IP address (1 host up) scanned in 0.36 seconds
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对比null扫描，就可以看出来，FIN扫描是发送一个设置FIN的数据包，同样的如果是linux系统，收到这个如果没有收到RST则认为端口是开放的，收到RST则表示端口没有开发，windows依然无法判断。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/07/06/UiOBex.png&quot; alt=&quot;FIN.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;xmas-tree扫描&quot;&gt;XMAS-TREE扫描&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;扫描原理：&lt;/p&gt;
&lt;p&gt;XMAS扫描原理和NULL扫描的类似,将TCP数据包中的URG、PSH、FIN标志位置1后发送给目标主机。在目标端口开放的情况下,目标主机将不返回任何信息&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;和NULL扫描正好相反，XMAS扫描会把所有的标志为都设置&lt;/p&gt;
&lt;p&gt;XMAS-TREE扫描命令参数：&lt;code&gt;nmap -sX&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sh&quot;&gt;➜ sudo nmap -sX -p22 192.168.31.175
Starting Nmap 7.80 ( https://nmap.org ) at 2020-07-06 22:53 CST
Nmap scan report for 192.168.31.175
Host is up (0.00028s latency).

PORT   STATE         SERVICE
22/tcp open|filtered ssh
MAC Address: 4C:1D:96:FC:4D:E2 (Unknown)

Nmap done: 1 IP address (1 host up) scanned in 0.55 seconds
➜ sudo nmap -sX -p999 192.168.31.175
Starting Nmap 7.80 ( https://nmap.org ) at 2020-07-06 22:54 CST
Nmap scan report for 192.168.31.175
Host is up (0.00021s latency).

PORT    STATE  SERVICE
999/tcp closed garcon
MAC Address: 4C:1D:96:FC:4D:E2 (Unknown)

Nmap done: 1 IP address (1 host up) scanned in 0.34 seconds
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还是扫描开放的22端口和未开放的999端口，可以看到Xmas扫描会发送一个FIN，PSH，URG被设置的数据包，同样如果是linux系统可以根据是否收到RST包进行判断端口是否开放，windows无法进行判断&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/07/06/Uix7bn.png&quot; alt=&quot;xmas.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;延伸阅读&quot;&gt;延伸阅读&lt;/h2&gt;
</description>
<pubDate>Wed, 08 Jul 2020 00:40:00 +0000</pubDate>
<dc:creator>syncd</dc:creator>
<og:description>环境说明 扫描者：manjaro linux ， IP地址：192.168.31.160 被扫描者：centos 7，IP地址：192.168.31.175 分析工具：wireshark nmap 版</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhaof/p/13264836.html</dc:identifier>
</item>
<item>
<title>Spring Boot读取配置文件的几种方式 - Java旅途</title>
<link>http://www.cnblogs.com/zhixie/p/13264833.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhixie/p/13264833.html</guid>
<description>&lt;p&gt;Spring Boot获取文件总的来说有三种方式，分别是@Value注解，@ConfigurationProperties注解和Environment接口。这三种注解可以配合着@PropertySource来使用，@PropertySource主要是用来指定具体的配置文件。&lt;/p&gt;
&lt;h2 id=&quot;propertysource解析&quot;&gt;@PropertySource解析&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Repeatable(PropertySources.class)
public @interface PropertySource {
    
        String name() default &quot;&quot;;

        String[] value();

        boolean ignoreResourceNotFound() default false;

        String encoding() default &quot;&quot;;

        Class&amp;lt;? extends PropertySourceFactory&amp;gt; factory() default PropertySourceFactory.class;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;value()：指定配置文件&lt;/li&gt;
&lt;li&gt;encoding()：指定编码，因为properties文件的编码默认是ios8859-1，读取出来是乱码&lt;/li&gt;
&lt;li&gt;factory()：自定义解析文件类型，因为该注解默认只会加载properties文件，如果想要指定yml等其他格式的文件需要自定义实现。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;一、value注解读取文件&quot;&gt;一、@Value注解读取文件&lt;/h2&gt;
&lt;p&gt;新建两个配置文件config.properties和configs.properties，分别写入如下内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-properties&quot;&gt;zhbin.config.web-configs.name=Java旅途
zhbin.config.web-configs.age=22
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-properties&quot;&gt;zhbin.config.web-configs.name=Java旅途
zhbin.config.web-configs.age=18
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;新增一个类用来读取配置文件&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Configuration
@PropertySource(value = {&quot;classpath:config.properties&quot;},encoding=&quot;gbk&quot;)
public class GetProperties {

    @Value(&quot;${zhbin.config.web-configs.name}&quot;)
    private String name;
    @Value(&quot;${zhbin.config.web-configs.age}&quot;)
    private String age;

    public String getConfig() {
        return name+&quot;-----&quot;+age;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果想要读取yml文件，则我们需要重写DefaultPropertySourceFactory，让其加载yml文件，然后在注解&lt;/p&gt;
&lt;p&gt;@PropertySource上自定factory。代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class YmlConfigFactory extends DefaultPropertySourceFactory {
    @Override
    public PropertySource&amp;lt;?&amp;gt; createPropertySource(String name, EncodedResource resource) throws IOException {
        String sourceName = name != null ? name : resource.getResource().getFilename();
        if (!resource.getResource().exists()) {
            return new PropertiesPropertySource(sourceName, new Properties());
        } else if (sourceName.endsWith(&quot;.yml&quot;) || sourceName.endsWith(&quot;.yaml&quot;)) {
            Properties propertiesFromYaml = loadYml(resource);
            return new PropertiesPropertySource(sourceName, propertiesFromYaml);
        } else {
            return super.createPropertySource(name, resource);
        }
    }

    private Properties loadYml(EncodedResource resource) throws IOException {
        YamlPropertiesFactoryBean factory = new YamlPropertiesFactoryBean();
        factory.setResources(resource.getResource());
        factory.afterPropertiesSet();
        return factory.getObject();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@PropertySource(value = {&quot;classpath:config.properties&quot;},encoding=&quot;gbk&quot;,factory = YmlConfigFactory.class)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;二、environment读取文件&quot;&gt;二、Environment读取文件&lt;/h2&gt;
&lt;p&gt;配置文件我们继续用上面的两个，定义一个类去读取配置文件&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Configuration
@PropertySource(value = {&quot;classpath:config.properties&quot;},encoding=&quot;gbk&quot;)
public class GetProperties {

    @Autowired
    Environment environment;

    public String getEnvConfig(){
        String name = environment.getProperty(&quot;zhbin.config.web-configs.name&quot;);
        String age = environment.getProperty(&quot;zhbin.config.web-configs.age&quot;);
        return name+&quot;-----&quot;+age;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;三、configurationproperties读取配置文件&quot;&gt;三、@ConfigurationProperties读取配置文件&lt;/h2&gt;
&lt;p&gt;@ConfigurationProperties可以将配置文件直接映射成一个实体类，然后我们可以直接操作实体类来获取配置文件相关数据。&lt;/p&gt;
&lt;p&gt;新建一个yml文件，当然properties文件也没问题&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yml&quot;&gt;zhbin:
  config:
    web-configs:
      name: Java旅途
      age: 20
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;新建实体类用来映射该配置&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Component
@ConfigurationProperties(prefix = &quot;zhbin.config&quot;)
@Data
public class StudentYml {
        
    // webConfigs务必与配置文件相对应，写为驼峰命名方式
    private WebConfigs webConfigs = new WebConfigs();

    @Data
    public static class WebConfigs {
        private String name;
        private String age;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;prefix = &quot;zhbin.config&quot;用来指定配置文件前缀&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果需要获取list集合，则做以下修改即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yml&quot;&gt;zhbin:
  config:
    web-configs:
      - name: Java旅途
        age: 20
      - name: Java旅途2
        age: 202
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Component
@ConfigurationProperties(prefix = &quot;zhbin.config&quot;)
@Data
public class StudentYml {

    private List&amp;lt;WebConfigs&amp;gt; webConfigs = new ArrayList&amp;lt;&amp;gt;();

    @Data
    public static class WebConfigs {

        private String name;
        private String age;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;经验与坑&quot;&gt;经验与坑&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;properties文件默认使用的是iso8859-1，并且不可修改&lt;/li&gt;
&lt;li&gt;yml文件的加载顺序高于properties，但是读取配置信息的时候会读取后加载的&lt;/li&gt;
&lt;li&gt;@PropertySource注解默认只会加载properties文件&lt;/li&gt;
&lt;li&gt;@PropertySource注解可以与任何一种方式联合使用&lt;/li&gt;
&lt;li&gt;简单值推荐使用@Value，复杂对象推荐使用@ConfigurationProperties&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Wed, 08 Jul 2020 00:39:00 +0000</pubDate>
<dc:creator>Java旅途</dc:creator>
<og:description>Spring Boot获取文件总的来说有三种方式，分别是@Value注解，@ConfigurationProperties注解和Environment接口。这三种注解可以配合着@PropertySou</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhixie/p/13264833.html</dc:identifier>
</item>
<item>
<title>使用@AutoConfigureBefore、After、Order调整Spring Boot自动配置顺序 - 字母哥博客</title>
<link>http://www.cnblogs.com/zimug/p/13264814.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zimug/p/13264814.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://i.iter01.com/images/e0e93c2636b332102da3eb16545db519f3920474929d25c26b8c5f89c86a6942.png&quot; alt=&quot;使用@AutoConfigureBefore调整配置顺序竟没生效？&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Spring Boot&lt;/code&gt;是Spring家族具有划时代意义的一款产品，它发展自&lt;code&gt;Spring Framework&lt;/code&gt;却又高于它，这种高于主要表现在其最重要的&lt;strong&gt;三大特性&lt;/strong&gt;，而相较于这三大特性中更为重要的便是&lt;strong&gt;Spring Boot的自动配置&lt;/strong&gt;（&lt;code&gt;AutoConfiguration&lt;/code&gt;）。与其说是自动，倒不如说是“智慧”，该框架看起来好像“更聪明”了。因此它也顺理成章的成为了构建微服务的基础设施，稳坐第一宝座。&lt;/p&gt;
&lt;p&gt;生活之道，在于取舍。程序设计何尝不是，任何决定都会是一把双刃剑，&lt;code&gt;Spring Boot&lt;/code&gt;的自动配置解决了Spring Framework使用起来的众多痛点，让开发效率可以得到&lt;strong&gt;指数级提升&lt;/strong&gt;（想一想，这不就是功德无量吗？） 。成也萧何败也萧何，也正是因为它的太智慧，倘若出了问题就会让程序设计师两眼一抹黑，无从下手。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;瑕不掩瑜，Spring Boot前进的步伐浩浩荡荡，学就完了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这不，我就在前几天收到一个“求助”，希望使用&lt;code&gt;@AutoConfigureBefore&lt;/code&gt;来&lt;strong&gt;控制配置的顺序&lt;/strong&gt;，但并未能如愿。本文就针对这个场景case稍作展开，讨论下使用&lt;code&gt;@AutoConfigureBefore、@AutoConfigureAfter、@AutoConfigureOrder&lt;/code&gt;三大注解控制自动配置执行顺序的&lt;strong&gt;正确姿势&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;提示：Spring Boot的自动配置是通过@EnableAutoConfiguration注解驱动的，预设是开启状态。你也可以通过&lt;code&gt;spring.boot.enableautoconfiguration = false&lt;/code&gt;来关闭它，回退到Spring Framework时代。显然这不是本文需要讨论的内容~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://i.iter01.com/images/4c07b7d45c9bd7a0ae403adb19fe22e4d85b43fa7f9568abb4a862ec302117ec.jpg&quot; alt=&quot;使用@AutoConfigureBefore调整配置顺序竟没生效？&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;本文将要聊的重点是Spring Boot自动配置+ 顺序控制，自动配置大家都耳熟能详，那么“首当其冲”就是知晓这个问题：配置类的执行为何需要控制顺序？&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;配置类为何需要顺序？&quot;&gt;配置类为何需要顺序？&lt;/h2&gt;
&lt;p&gt;我们已经知道Spring容器它对Bean的初始化是&lt;strong&gt;无序&lt;/strong&gt;的，我们并不能想当然的通过&lt;code&gt;@Order&lt;/code&gt;注解来控制其执行顺序。一般来说，对于容器内普通的Bean我们只需要关注依赖关系即可，而并不需要关心其绝对的顺序，而依赖关系的管理Spring的是做得很好的，这不连&lt;strong&gt;回圈依赖&lt;/strong&gt;它都可以搞定么。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;@Configuration&lt;/code&gt;配置类它也是一个Bean，但对于配置类来说，某些场景下的执行顺序是&lt;strong&gt;必须的&lt;/strong&gt;，是需要得到保证的。比如很典型的一个非A即B的case：若容器内已经存在A了，就不要再把B放进来。这种case即使用中文理解，就能知道对A的“判断”必须要放在B的前面，否则可能导致程序出问题。&lt;/p&gt;
&lt;p&gt;那么针对于配置的执行顺序，传统Spring和Spring Boot下各自是如何处理的，表现如何呢？&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;spring下控制配置执行顺序&quot;&gt;Spring下控制配置执行顺序&lt;/h3&gt;
&lt;p&gt;在传统的&lt;code&gt;Spring Framework&lt;/code&gt;里，一个&lt;code&gt;@Configuration&lt;/code&gt;注解标注的类就代表一个配置类，当存在多个&lt;code&gt;@Configuration&lt;/code&gt;时，他们的&lt;strong&gt;执行顺序&lt;/strong&gt;是由使用者靠手动指定的，就像这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 手動控制Config1 Config2的順序
ApplicationContext context = new AnnotationConfigApplicationContext(Config1.class, Config2.class);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然，你可能就疑问了说：即使在传统Spirng里，我也从没有自己使用过&lt;code&gt;AnnotationConfigApplicationContext&lt;/code&gt;来显示载入配置啊，都是使用&lt;code&gt;@Configuration&lt;/code&gt;定义好配置类后，点选&lt;code&gt;Run&lt;/code&gt;一把唆的。没错，那是因为你是在web环境下使用Spring，IoC容器是借助web容器（如Tomcat等）来驱动的，Spring对此部分封装得非常好，所以做到了对使用者几乎无感知。&lt;/p&gt;
&lt;p&gt;关于这部分的内容，此处就不深究了，毕竟本文重点不在这嘛。但可以给出给小结论：&lt;code&gt;@Configuration&lt;/code&gt;配置被载入进容器的方式大体上可分为两种：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;手动。构建&lt;code&gt;ApplicationContext&lt;/code&gt;时由构建者手动传入，可手动控制顺序&lt;/li&gt;
&lt;li&gt;自动。被&lt;code&gt;@ComponentScan&lt;/code&gt;自动扫描进去，无法控制顺序&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;绝大多数情况下我们都是使用&lt;strong&gt;自动&lt;/strong&gt;的方式，所以在Spring下对配置的顺序并无感知。其实这也是需求驱使，因为在传统Spring下我们并无此需求，所以对它无感是合乎逻辑的。另说一句，虽然我们并不能控制Bean的顺序，但是我们是可以干涉它的，比如：控制依赖关系、提升优先顺序、“间接”控制执行顺序...当然喽这是后面文章的内容，敬请关注。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;spring-boot下控制配置执行顺序&quot;&gt;Spring Boot下控制配置执行顺序&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Spring Boot&lt;/code&gt;下对&lt;strong&gt;自动配置&lt;/strong&gt;的管理对比于Spring它就是黑盒，它会根据当前容器内的情况来&lt;strong&gt;动态的&lt;/strong&gt;判断自动配置类的载入与否、以及载入的顺序，所以可以说：Spring Boot的自动配置它对顺序是有&lt;strong&gt;强要求&lt;/strong&gt;的。需求驱使，Spring Boot给我们提供了&lt;code&gt;@AutoConfigureBefore、@AutoConfigureAfter、@AutoConfigureOrder&lt;/code&gt;（下面统称这三个注解为“三大注解”）这三个注解来帮我们解决这种诉求。&lt;/p&gt;
&lt;p&gt;需要注意的是：三大注解是Spring Boot提供的而非Spring Framework。其中前两个是1.0.0就有了，&lt;code&gt;@AutoConfigureOrder&lt;/code&gt;属于1.3.0版本新增，表示绝对顺序（数字越小，优先顺序越高）。另外，这几个注解&lt;strong&gt;并不互斥&lt;/strong&gt;，可以同时标注在同一个&lt;code&gt;@Configuration&lt;/code&gt;自动配置类上。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;spring-boot内建的控制配置顺序举例&quot;&gt;Spring Boot内建的控制配置顺序举例&lt;/h2&gt;
&lt;p&gt;为方便大家理解，我列出一个Spring Boot它自己的使用作为示例学一学。以大家最为熟悉的WebMvc的自动配置场景为例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Configuration(proxyBeanMethods = false)
@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)
@AutoConfigureAfter({ DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class, ValidationAutoConfiguration.class })
public class WebMvcAutoConfiguration { ... }


@Configuration(proxyBeanMethods = false)
@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)
@AutoConfigureAfter(ServletWebServerFactoryAutoConfiguration.class)
public class DispatcherServletAutoConfiguration { ... }


@Configuration(proxyBeanMethods = false)
@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)
public class ServletWebServerFactoryAutoConfiguration { ... }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这几个配置是WebMVC的核心配置，他们之间是有顺序关系的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;WebMvcAutoConfiguration&lt;/code&gt;被载入的前提是：&lt;code&gt;DispatcherServletAutoConfiguration、TaskExecutionAutoConfiguration、ValidationAutoConfiguration&lt;/code&gt;这三个哥们都已经完成初始化&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DispatcherServletAutoConfiguration&lt;/code&gt;被载入的前提是：&lt;code&gt;ServletWebServerFactoryAutoConfiguration&lt;/code&gt;已经完成初始化&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ServletWebServerFactoryAutoConfiguration&lt;/code&gt;被载入的前提是：&lt;code&gt;@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)&lt;/code&gt;最高优先顺序，也就是说它无其它依赖，&lt;strong&gt;希望自己是最先被初始化的&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;当碰到多个配置都是最高优先顺序的时候，且互相之前没有关系的话，顺序也是不定的。但若互相之间存在依赖关系（如本利的&lt;code&gt;DispatcherServletAutoConfiguration&lt;/code&gt;和&lt;code&gt;ServletWebServerFactoryAutoConfiguration&lt;/code&gt;），那就按照相对顺序走&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://i.iter01.com/images/9479294021f45c6af0a49dec713e412581f5fd12e96e5f20dcbafc66589f41d7.png&quot; alt=&quot;使用@AutoConfigureBefore调整配置顺序竟没生效？&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;WebMvcAutoConfiguration&lt;/code&gt;载入&lt;strong&gt;后&lt;/strong&gt;，在它&lt;strong&gt;之后&lt;/strong&gt;其实还有很多配置会尝试执行，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@AutoConfigureAfter(WebMvcAutoConfiguration.class)
class FreeMarkerServletWebConfiguration extends AbstractFreeMarkerConfiguration { ... }

@AutoConfigureAfter(WebMvcAutoConfiguration.class)
public class GroovyTemplateAutoConfiguration { ... }

@AutoConfigureAfter({ WebMvcAutoConfiguration.class, WebFluxAutoConfiguration.class })
public class ThymeleafAutoConfiguration { ... }

@AutoConfigureAfter(WebMvcAutoConfiguration.class)
public class LifecycleMvcEndpointAutoConfiguration { ... }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这些都很容易理解：如果都不是Web环境，载入一些模版引擎的并无必要嘛。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;三大注解使用的误区（重要）&quot;&gt;三大注解使用的误区（重要）&lt;/h2&gt;
&lt;p&gt;根据我的切身体会，针对这三大注解，实在有太多人把它&lt;strong&gt;误用&lt;/strong&gt;了，想用但是用了却又不生效，于是就容易触发一波“骂街”操作，其实这也是我书写本文的最大动力所在：纠正你的错误使用，告诉你正确姿势。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;错误使用示例&quot;&gt;错误使用示例&lt;/h3&gt;
&lt;p&gt;我见到的非常多的小伙伴这么来使用三大注解：我这里使用“虚拟码”进行模拟&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Configuration
public class B_ParentConfig {

    B_ParentConfig() {
        System.out.println(&quot;配置類ParentConfig構造器被執行...&quot;);
    }
}

@Configuration
public class A_SonConfig {

    A_SonConfig() {
        System.out.println(&quot;配置類SonConfig構造器被執行...&quot;);
    }
}

@Configuration
public class C_DemoConfig {
    public C_DemoConfig(){
        System.out.println(&quot;我是被自動掃描的配置，初始化啦....&quot;);
    }
}

@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args).close();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过名称能知道我想要的达到的效果是：&lt;strong&gt;ParentConfig先载入，SonConfig后载入&lt;/strong&gt;。（DemoConfig作为一个参考配置，作为日志参考使用即可）&lt;/p&gt;
&lt;p&gt;启动应用，控制台列印：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;配置類SonConfig構造器被執行...
配置類ParentConfig構造器被執行...
我是被自動掃描的配置，初始化啦....
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Son优先于Parent被载入了，这明显&lt;strong&gt;不符合要求&lt;/strong&gt;。因此，我看到很多小伙伴就这么干：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@AutoConfigureBefore(A_SonConfig.class)
@Configuration
public class B_ParentConfig {

    B_ParentConfig() {
        System.out.println(&quot;配置類ParentConfig構造器被執行...&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过&lt;code&gt;@AutoConfigureBefore&lt;/code&gt;控制，表示在&lt;code&gt;A_SonConfig&lt;/code&gt;之前执行此配置。语义层面上看，貌似没有任何问题，再次启动应用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;配置類SonConfig構造器被執行...
配置類ParentConfig構造器被執行...
我是被自動掃描的配置，初始化啦....
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;what a fuck。看到没，我没骗你吧，骂街了骂街了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.iter01.com/images/7831328e81cd763b40f7513e3dd87d22f1bab1bc0e24520a9041674e0646308d.png&quot; alt=&quot;使用@AutoConfigureBefore调整配置顺序竟没生效？&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;竟然没生效？程序不会骗人，&lt;code&gt;@AutoConfigureBefore&lt;/code&gt;的语义也没有问题，而是你使用的姿势不对，下面我会给你正确姿势。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;三大注解使用的正确姿势&quot;&gt;三大注解使用的正确姿势&lt;/h2&gt;
&lt;p&gt;针对以上case，要想达到预期效果，正确姿势只需要下面两步：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;把&lt;code&gt;A_SonConfig&lt;/code&gt;和&lt;code&gt;B_ParentConfig&lt;/code&gt;挪动到Application&lt;strong&gt;扫描不到&lt;/strong&gt;的包内，切记：一定且必须是扫描不到的包内&lt;/li&gt;
&lt;li&gt;当前工程里增加配置&lt;code&gt;META-INF/spring.factories&lt;/code&gt;，内容为(配置里Son和Parent前后顺序对结果无影响)：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.fsx.autoconfig.A_SonConfig,com.fsx.autoconfig.B_ParentConfig
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再次启动应用看看，列印输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;我是被自動掃描的配置，初始化啦....
配置類ParentConfig構造器被執行...
配置類SonConfig構造器被執行...
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;完美&lt;/strong&gt;。符合预期，Parent终于在Son之前完成了初始化，也就是说我们的&lt;code&gt;@AutoConfigureBefore&lt;/code&gt;注解生效了。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;使用细节注意事项&quot;&gt;使用细节注意事项&lt;/h3&gt;
&lt;p&gt;针对此使用姿势，虽然很正确，并不是完全没有“副作用”的，有如下细节平时也需要引起注意：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;若你不用&lt;code&gt;@AutoConfigureBefore&lt;/code&gt;这个注解，单单就想依赖于spring.factories里的先后顺序的来控制实际的载入顺序，答案是&lt;strong&gt;不可以&lt;/strong&gt;，控制不了&lt;/li&gt;
&lt;li&gt;例子中有个小细节：我每次都故意输出了&lt;code&gt;我是被自動掃描的配置，初始化啦....&lt;/code&gt;这句话，可以发现被扫描进去配置例项化是在它前面（见错误示例），而通过&lt;code&gt;spring.factories&lt;/code&gt;方式进去是在它的后面（见正确姿势）&lt;/li&gt;
&lt;li&gt;从这个小细节可以衍生得到结论：&lt;code&gt;Spring Boot&lt;/code&gt;的自动配置均是通过&lt;code&gt;spring.factories&lt;/code&gt;来指定的，它的优先顺序最低（执行时机是最晚的）；通过扫描进来的一般都是你自己自定义的配置类，所以优先顺序是最高的，&lt;strong&gt;肯定在自动配置之前载入&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;从这你应该学到：若你要指定扫描的包名，请千万不要扫描到形如&lt;code&gt;org.springframework&lt;/code&gt;这种包名，否则“天下大乱”（当然喽为了防止这种情况出现，Spring Boot做了容错的。它有一个类专门检测这个case防止你配置错了，具体参见&lt;code&gt;ComponentScanPackageCheck&lt;/code&gt;预设实现）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;请尽量不要让自动配置类既被扫描到了，又放在&lt;code&gt;spring.factories&lt;/code&gt;配置了，否则后者会覆盖前者，很容易造成莫名其妙的错误&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;小总结，对于三大注解的正确使用姿势是应该是：请使用在你的&lt;strong&gt;自动配置&lt;/strong&gt;里（一般是你自定义starter时使用），而不是使用在你业务工程中的&lt;code&gt;@Configuration&lt;/code&gt;里，因为那会毫无效果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.iter01.com/images/66ae33d5cb47cd0c7f50839793f09c15fca358b757b3b4431e4a3d126a856810.jpg&quot; alt=&quot;使用@AutoConfigureBefore调整配置顺序竟没生效？&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;三大注解解析时机浅析&quot;&gt;三大注解解析时机浅析&lt;/h2&gt;
&lt;p&gt;为了更好的辅助理解，加强记忆，本文将这三大注解解析时机&lt;strong&gt;简要的&lt;/strong&gt;絮叨一下，知道了它被解析的时机，自然就很好解释为何你那么写是无效的喽。&lt;/p&gt;
&lt;p&gt;这三个注解的解析都是交给&lt;code&gt;AutoConfigurationSorter&lt;/code&gt;来排序、处理的，做法类似于&lt;code&gt;AnnotationAwareOrderComparator&lt;/code&gt;去解析排序&lt;code&gt;@Order&lt;/code&gt;注解。核心代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class AutoConfigurationSorter {
        
        // 唯一給外部呼叫的方法：返回排序好的Names，因此返回的是個List嘛（ArrayList）
        List&amp;lt;String&amp;gt; getInPriorityOrder(Collection&amp;lt;String&amp;gt; classNames) {
                ...
                // 先按照自然順序排一波
                Collections.sort(orderedClassNames);
                // 在按照@AutoConfigureBefore這三個註解排一波
                orderedClassNames = sortByAnnotation(classes, orderedClassNames);
                return orderedClassNames;
        }
        ...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此排序器被两个地方使用到：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;AutoConfigurationImportSelector&lt;/code&gt;：Spring自动配置处理器，用于载入所有的自动配置类。它实现了&lt;code&gt;DeferredImportSelector&lt;/code&gt;介面：这也顺便解释了为何自动配置是最后执行的原因~&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AutoConfigurations&lt;/code&gt;：表示自动配置@Configuration类。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这个排序的“解析/排序”过程还是比较复杂的，本文点到为止，观其大意即可。你可以简单粗暴的记住结论：&lt;code&gt;@AutoConfigureBefore、@AutoConfigureAfter、@AutoConfigureOrder&lt;/code&gt;这三个注解只能作用于&lt;strong&gt;自动配置类&lt;/strong&gt;，而不能是自定义的@Configuration配置类。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;关于Spring Boot自动配置顺序相关的三大注解&lt;code&gt;@AutoConfigureBefore、@AutoConfigureAfter、@AutoConfigureOrder&lt;/code&gt;就先介绍到这了，本文主要用意是为了帮助大家规范此些“常用注解”的使用，规避一些误区，端正使用姿势，避免犯错时又丈二和尚。&lt;/p&gt;
&lt;p&gt;我看到不少文章、生产上的程序都使用错了（估计有没有效果自己的都不知道，又或者刚好歪打正着确实是在xxx后面执行而以为生效了），希望本文能帮助到你。本文转载自：&lt;a href=&quot;https://www.yourbatman.cn/x2y/3aa2234d.html&quot;&gt;https://www.yourbatman.cn/x2y/3aa2234d.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;欢迎关注我的博客，里面有很多精品合集&quot;&gt;欢迎关注我的博客，里面有很多精品合集&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;本文转载注明出处（必须带连接，不能只转文字）：&lt;a href=&quot;http://www.zimug.com&quot;&gt;字母哥博客&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;觉得对您有帮助的话，帮我点赞、分享！您的支持是我不竭的创作动力！&lt;/strong&gt; 。另外，笔者最近一段时间输出了如下的精品内容，期待您的关注。&lt;/p&gt;
</description>
<pubDate>Wed, 08 Jul 2020 00:32:00 +0000</pubDate>
<dc:creator>字母哥博客</dc:creator>
<og:description>前言 Spring Boot是Spring家族具有划时代意义的一款产品，它发展自Spring Framework却又高于它，这种高于主要表现在其最重要的三大特性，而相较于这三大特性中更为重要的便是Sp</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zimug/p/13264814.html</dc:identifier>
</item>
<item>
<title>PowerJob 的故事开始：“玩够了，才有精力写开源啊！”  - 削微寒</title>
<link>http://www.cnblogs.com/xueweihan/p/13263086.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xueweihan/p/13263086.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;本文适合有 Java 基础知识的人群&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202007/759200-20200707204527279-2058277083.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;作者：HelloGitHub-Salieri&lt;/p&gt;
&lt;p&gt;HelloGitHub 推出的&lt;a href=&quot;https://github.com/HelloGitHub-Team/Article&quot;&gt;《讲解开源项目》&lt;/a&gt;系列。经过几番的努力和沟通，终于邀请到分布式任务调度与计算框架：PowerJob 的作者 Salieri，加入 HG 的开源讲解系列，开启了他的 PowerJob 讲解系列🎉。后续每周三将更新一篇，欢迎大家持续关注，希望你能从本系列学到真本事。&lt;/p&gt;
&lt;blockquote readability=&quot;1.5&quot;&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/KFCFans/PowerJob&quot;&gt;https://github.com/KFCFans/PowerJob&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一、缘起&quot;&gt;一、缘起&lt;/h2&gt;
&lt;p&gt;大家好我是 PowerJob 的作者 Salieri，关于 PowerJob 故事要从一年前说起了。&lt;/p&gt;
&lt;p&gt;一年前，我前往阿里巴巴集团，开启了自己的暑期实习。机缘巧合的是，我接到的第一个正式的开发类任务，就与分布式任务调度与计算紧密相关。&lt;/p&gt;
&lt;p&gt;当时，集团内部研发出了一款全新的任务调度中间件（SchedulerX 2.0，也就是 README 中提到的本框架的参考对象），需要从老版本的 DTS 迁移到 SchedulerX 2.0。而这个光荣而伟大的任务，自然也被师兄委派到了我身上。也从那时候开始我开始正式接触并使用这种分布式任务调度与计算中间件。&lt;/p&gt;
&lt;p&gt;迁移完毕后很长一段时间内，算是我和 SchedulerX 的蜜月期，不得不说 SchedulerX 的设计理念极其先进，比如通过控制台或 OpenAPI 动态传递运行时参数能让传统的任务变得非常灵活，无需更改代码即可实现不同的功能，再比如 MapReduce 处理器的存在使得开发者只需要寥寥数行代码就能实现分布式计算，解决大量数据的处理需求。然而好景不长，在即将迎来双十一之际，发生了两个比较悲伤的故事。&lt;/p&gt;
&lt;p&gt;双十一临近，由于需要处理的数据量激增，之前在 SchedulerX 上运行完美的离线任务开始频频失败，整个双十一前夕报警电话的频率甚至能超过微信提醒的频率（好吧有一部分原因是没人找我 T_T）。经过与相关开发人员的一通排查，初步断定问题的原因在于我们的应用内存占用过高，导致 SchedulerX 没有足够的内存去完成必要的任务，进而导致任务失败。这个锅，SchedulerX 显然是不背的，也很合理，不符合最低运行要求嘛，就好比你买一台 Macbook Air 装个 Windows 准备玩 PUBG 结果发现连欢迎界面都看不到，你能说什么呢？人家最低运行要求写的明明白白，达不到配置要求无法运行只能怪你自己，你能做的只有接受。最后实在没办法，只能拆东墙补西墙勉勉强强撑过了双十一。&lt;/p&gt;
&lt;p&gt;另一件事是限流。为了监控任务的运行状态，我在另一个应用单独写了轮询查询 SchedulerX 任务运行状态的逻辑，该功能一直四平八稳地运行着。直到某一天，我完成一个微小改动的发布后，本着安全生产的原则，登上在线日志平台查看应用的运行时日志。不看不知道一看吓一跳，满屏幕的 RuntimeException 甚至让我怀疑我是不是不小心删掉了某个模块，还是不小心把数据库删了，还是不小心发布错代码分支了。慌乱过后冷静下来看异常信息，才发现一直以来我调用的 SchedulerX 提供的查看任务运行状态接口报错了，被限流了。理由是双十一保障。嗯，因为需要保障双十一稳定性所以先弄挂一个虽然不在双十一圈内但好歹站在边上的应用。沟通无果，只能一顿魔改代码，自己去实现任务的状态监控。&lt;/p&gt;
&lt;p&gt;其实这两件事情呢，SchedulerX 团队确实没有什么问题。毕竟服务于整个集团所有业务线，不做一些限制任由大家肆无忌惮使用是不可能的。但是中台模式下，某些个体的需求无法得到满足也是确实存在的现象。对于大部分接入用户来说，只需要依赖个 Jar 包，写点代码，去控制台一配置，任务就能跑起来，使用体验极好。毕竟，并不是所有用户都有我们这种动辄几百万子任务的变态需求......&lt;/p&gt;
&lt;p&gt;双十一过后，实习期满，我也就从阿里离职回家，开启混吃等死模式，每天不是在打游戏就是在想怎么打游戏，对了，还有告诉自己明天一定要好好学习。&lt;/p&gt;
&lt;p&gt;浑浑噩噩过了 N 个月后，终于想起还有毕业论文这事。没办法，为了卑微的学位，我只能暂时金盆洗手，投入到论文的撰写之中去。写完论文，疫情差不多结束了，一起“送人头”的小伙伴都差不多上班去了，构成我充满打游戏欲望的条件（人数==5）被破坏，我也就彻底闲了下来。重拾自己的传统艺能——Reading。&lt;/p&gt;
&lt;p&gt;在看了很多本奇奇怪怪的书（甚至包括一本言情小说）以后，终于想起了以前一直想做但是一直被慵懒的自己所搁置的事情：自研一个 SchedulerX，万一哪天 SchedulerX 满足不了需求，至少还能自己就自己抢救一下～于是，OhMyScheduler（没错，一开始叫 OhMyScheduler），后面改名为 PowerJob 诞生了～&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202007/759200-20200707204546113-17968676.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;二、初见&quot;&gt;二、初见&lt;/h2&gt;
&lt;p&gt;实在是没事儿干了，也是时候扛起是“新一代分布式任务调度与计算框架”的大旗了（当然要走的路还很长），废话不多说接下来开始正文。&lt;/p&gt;
&lt;h3 id=&quot;21-任务调度框架&quot;&gt;2.1 任务调度框架&lt;/h3&gt;
&lt;p&gt;定时任务相信大家都接触过，比如经典的 Linux crontab。定时调度、定时执行已经渐渐成为了各个系统普遍需要依赖的中间系统。在 Java 领域，也出现了许多优秀的任务调度框架。&lt;/p&gt;
&lt;p&gt;当前市面上流行的作业调度框架有老牌的 Quartz、基于 Quartz 的 elastic-job 和原先基于 Quartz 后面移除依赖的 xxl-job，这里分别谈一些这些框架现存的缺点。&lt;/p&gt;
&lt;p&gt;Quartz 可以视为第一代任务调度框架，基本上是现有所有分布式调度框架的“祖宗”。由于历史原因，它不提供Web界面，只能通过API完成任务的配置，使用起来不够方便和灵活，同时它仅支持任务的单机执行，无法有效利用整个集群的计算能力。 同时，Quartz 需要的调度和执行耦合在同一个应用中，没有平台化服务的能力。&lt;/p&gt;
&lt;p&gt;xxl-job 可以视为第二代任务调度框架，在一定程度上解决了 Quartz 的不足，在过去几年中是个非常优秀的调度框架，不过放到今天来看，还是存在着一些不足的，具体如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数据库支持单一：仅支持 MySQL，使用其他DB需要自己魔改代码&lt;/li&gt;
&lt;li&gt;有限的分布式计算能力：仅支持静态分片，无法很好的完成复杂任务的计算&lt;/li&gt;
&lt;li&gt;不支持工作流：无法配置各个任务之间的依赖关系，不适用于任务之间存在复杂依赖的场景&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;正所谓长江后浪推前浪，在如今这个数据量日益增长、业务越来越复杂的年代，急需一款更为强大的任务调度框架来解决上诉问题，而 PowerJob 因此应运而生。&lt;/p&gt;
&lt;h3 id=&quot;22-powerjob-闪亮登场&quot;&gt;2.2 PowerJob 闪亮登场&lt;/h3&gt;
&lt;p&gt;PowerJob 可以被认为是第三代任务调度框架，在任务调度的基础上，还额外提供了分布式计算和工作流功能，其主要特性如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用简单：提供 Web 界面，允许开发者可视化地完成调度任务的管理（增、删、改、查）、任务运行状态监控和运行日志查看等功能。&lt;/li&gt;
&lt;li&gt;定时策略完善：支持 CRON 表达式、固定频率、固定延迟和API四种定时调度策略。&lt;/li&gt;
&lt;li&gt;执行模式丰富：支持单机、广播、Map、MapReduce 四种执行模式，其中 Map/MapReduce 处理器能使开发者寥寥数行代码便获得集群分布式计算的能力。&lt;/li&gt;
&lt;li&gt;工作流（workflow）支持：支持在线配置任务依赖关系，可视化得对任务进行编排，同时还支持上下游任务间的数据传递&lt;/li&gt;
&lt;li&gt;执行器支持广泛：支持 Spring Bean、内置/外置 Java 类、Shell、Python 等处理器，应用范围广。&lt;/li&gt;
&lt;li&gt;运维便捷：支持在线日志功能，执行器产生的日志可以在前端控制台页面实时显示，降低 debug 成本，极大地提高开发效率。&lt;/li&gt;
&lt;li&gt;依赖精简：最小仅依赖关系型数据库（MySQL/PostgreSQL/Oracle/MS SQLServer 等），同时支持所有 Spring Data JPA 所支持的关系型数据库。&lt;/li&gt;
&lt;li&gt;高可用&amp;amp;高性能：调度服务器经过精心设计，一改其他调度框架基于数据库锁的策略，实现了无锁化调度。部署多个调度服务器可以同时实现高可用和性能的提升（支持无限的水平扩展）。&lt;/li&gt;
&lt;li&gt;故障转移与恢复：任务执行失败后，可根据配置的重试策略完成重试，只要执行器集群有足够的计算节点，任务就能顺利完成。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;23-powerjob-适用场景&quot;&gt;2.3 PowerJob 适用场景&lt;/h3&gt;
&lt;p&gt;综上所述，PowerJob 是全新一代分布式调度与计算框架，能让您轻松完成任务的调度与繁杂任务的分布式计算。适用于各个有任务调度需求的企业，统一部署 Server 做为整个公司的公共调度平台，成为分布式调度的中间件。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;有定时执行需求的业务场景：如每天凌晨全量同步数据、生成业务报表等。&lt;/li&gt;
&lt;li&gt;有需要全部机器一同执行的业务场景：如使用广播执行模式清理集群日志。&lt;/li&gt;
&lt;li&gt;有需要分布式处理的业务场景：比如需要更新一大批数据，单机执行耗时非常长，可以使用 Map/MapReduce 处理器完成任务的分发，调动整个集群加速计算。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;三、大纲&quot;&gt;三、大纲&lt;/h2&gt;
&lt;p&gt;后面会逐步从上手使用讲到核心技术剖析，希望大家可以从中有所收获，同时欢迎小伙伴们可以贡献代码哦！大纲太长了（10+篇）简单罗列一部分：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;快速上手&lt;/li&gt;
&lt;li&gt;PowerJob 技术综述&lt;/li&gt;
&lt;li&gt;技术剖析：Akka 框架
&lt;ul&gt;&lt;li&gt;Actor模型&lt;/li&gt;
&lt;li&gt;Akka-remote 简化通讯代码&lt;/li&gt;
&lt;li&gt;Akka API 介绍&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;技术剖析：任务的调度与派发
&lt;ul&gt;&lt;li&gt;时间轮算法&lt;/li&gt;
&lt;li&gt;调度层：OmsSchedulerService&lt;/li&gt;
&lt;li&gt;派发层：DispatchService&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;技术剖析：Spring AOP 技术的应用
&lt;ul&gt;&lt;li&gt;拦截&lt;/li&gt;
&lt;li&gt;exclude&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;等等&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;四、总结与预告&quot;&gt;四、总结与预告&lt;/h2&gt;
&lt;p&gt;本章主要阐述了 PowerJob 诞生的故事，同时简单介绍了 PowerJob 这个框架的功能和适用场景，本系列的大纲。下一章节，我将会介绍 PowerJob 的快速入门，帮助大家快速熟悉并使用这款强大的分布式任务调度与计算框架。&lt;/p&gt;
&lt;p&gt;那我们下期再见喽～&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;HelloGitHub 交流群现已全面开放（作者在 Java 群），添加微信号：HelloGitHub 为好友入群，可同前端、Java、Go 等各界大佬谈笑风生、切磋技术~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202007/759200-20200706214622307-1765002891.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 08 Jul 2020 00:28:00 +0000</pubDate>
<dc:creator>削微寒</dc:creator>
<og:description>本文适合有 Java 基础知识的人群 作者：HelloGitHub-Salieri HelloGitHub 推出的《讲解开源项目》系列。经过几番的努力和沟通，终于邀请到分布式任务调度与计算框架：Pow</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xueweihan/p/13263086.html</dc:identifier>
</item>
<item>
<title>Java并发编程——为什么要用volatile关键字 - leapMie</title>
<link>http://www.cnblogs.com/leap/p/13262236.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/leap/p/13262236.html</guid>
<description>&lt;hr/&gt;&lt;p&gt;首发地址 &lt;a href=&quot;https://blog.leapmie.com/archives/66ba646f/&quot;&gt;https://blog.leapmie.com/archives/66ba646f/&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;日常编程中出现 volatile 关键字的频率并不高，大家可能对 volatile 关键字比较陌生，再深入一点也许是听闻 volatile 只能保证可见性而不能保证原子性，无法有效保证线程安全，于是更加避免使用 volatile ，简简单单加上synchronize关键字就完事了。本文稍微深入探讨 volatile 关键字，分析其作用及对应的使用场景。&lt;/p&gt;
&lt;h2 id=&quot;并发编程的几个概念简述&quot;&gt;并发编程的几个概念简述&lt;/h2&gt;
&lt;p&gt;首先简单介绍几个与并发编程相关的概念：&lt;/p&gt;
&lt;ul readability=&quot;4&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;可见性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可见性是指变量在线程之间是否可见，JVM 中默认情况下线程之间不具备可见性。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;原子性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于 a = 0 操作是属于原子操作，但 a = a + 1 则不是原子操作，因为这里涉及到要先读取原来 a 的值，然后再为 a 加 1 ，当涉及多线程同时执行该语句时，会出现值不稳定的情况，所以非原子操作在并发场景下是不安全的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;有序性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;java 内存模型中允许编译器和处理器进行指令重排优化，重排过程中不会影响单个线程的指令执行顺序，但会影响多线程环境中的运行正确性&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;指令重排&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在多核 CPU 的情况下，为了充分利用时间片，提高指令执行效率，处理器会根据一定规则对指令进行重排序，由于规则的限定，指令重排后理论上最终运行结果不变。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;volatile-的主要作用&quot;&gt;volatile 的主要作用&lt;/h2&gt;
&lt;p&gt;volatile 的主要作用是&lt;strong&gt;实现可见性&lt;/strong&gt; 和&lt;strong&gt;禁止指令重排&lt;/strong&gt;&lt;/p&gt;
&lt;ol readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;实现可见性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 JVM 内存模型中内存分为主内存和工作内存，各线程有独自的工作内存，对于要操作的数据会从主内存拷贝一份到工作内存中，默认情况下工作内存是相互独立的，也就是线程之间不可见，而 volatile 最重要的作用之一就是使变量实现可见性。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;禁止指令重排&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虽然指令重排理论上不会影响执行结果的正确性，但指令重排只能保证底层的机器语言重排序后结果正确，而对于Java高级语言，所以在没有干预的情况下并不能确保每条语句在编译对应的指令重排后与期望的执行效果一致。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;对于以下示例，由于 ready 没有指定 volatile ，当变量 ready 线程间不可见时，可能导致线程中读不到 ready 的新值，无法停止循环；如果指令重排序，可能在线程执行前变量 ready 已赋值为 true ，导致线程内容不打印。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class NoVisibility {
    private static boolean ready;
    private static int number;
    private static class ReaderThread extends Thread {
        @Override
        public void run() {
            while(!ready) {
                Thread.yield();
            }
            System.out.println(&quot;1&quot;);
        }
    }
    public static void main(String[] args) {
        new ReaderThread().start();
        ready = true;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;为什么volatile不能保证线程安全？&quot;&gt;为什么volatile不能保证线程安全？&lt;/h2&gt;
&lt;p&gt;想要线程安全必须保证原子性，可见性，有序性，而 volatile 只能保证可见性和有序性。&lt;/p&gt;
&lt;p&gt;volatile 字段主要是让线程从主内存中获取值从而保证可见性，但是CPU中还有一层高速缓存——寄存器，对于非原子性操作，在底层指令运算中还是会出现数据缓存导致运算结果不正确的情况，从而无法保证线程安全。&lt;br/&gt;简单来说，volatile 在多 cpu 环境下不能保证其它 cpu 的缓存同步刷新，因此无法保证原子性。&lt;/p&gt;
&lt;h2 id=&quot;为什么不直接用synchronized&quot;&gt;为什么不直接用synchronized&lt;/h2&gt;
&lt;p&gt;synchronized 可保证原子性、可见性、有序性，能有效保证线程安全，但是有个缺点是性能开销较大，而 volatile 是轻量级的线程安全实现方案，在某些特定场合下也能保证线程安全。由于 synchronized 的便捷性，也容易导致 synchronized 的滥用。&lt;/p&gt;
&lt;h2 id=&quot;双重检查锁&quot;&gt;双重检查锁&lt;/h2&gt;
&lt;p&gt;因为 volatile 不能简易的实现线程安全，需要有较深入的了解才能正确使用，所以 volatile也显得更为复杂，使用频率也较低，而 volatile 的一个典型使用例子是&lt;strong&gt;双重检查锁模式&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;双重检查锁通常用于单例模式或延迟赋值的场景，其代码通常如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Singleton {
    private volatile static Singleton uniqueSingleton; // 1. 为变量添加volatile修饰符

    private Singleton() {
    }

    public Singleton getInstance() {
        if (null == uniqueSingleton) { //2. 第一重检查
            synchronized (Singleton.class) { // 3. synchronized加锁
                if (null == uniqueSingleton) { // 4. 第二重检查
                    uniqueSingleton = new Singleton();
                }
            }
        }
        return uniqueSingleton;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以下是对这段代码的一些疑问及解答：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q: 为什么不在 getInstance 方法直接加 synchronized ？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A: 只有在第一次初始化时才需要加锁，如果在getInstance方法上加锁则每次获取实例时都会对整段代码块加锁，影响性能&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q: 为什么需要双重检查？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A: 如果多线程同时通过了第一次检查，其中一个线程需要通过了第二次检查才进行实例化对象，其余线程在后续等待获取到锁后则判断到变量非空，跳过赋值操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q: 为什么 uniqueSingleton 需要添加volatile关键字？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A: 对于 uniqueSingleton = new Singleton();语句，实际上可以分解成以下三个步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;分配内存空间&lt;/li&gt;
&lt;li&gt;初始化对象&lt;/li&gt;
&lt;li&gt;将对象指向刚分配的内存空间&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;但是有些编译器为了性能的原因，可能会将第二步和第三步进行重排序，顺序就成了：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;分配内存空间&lt;/li&gt;
&lt;li&gt;将对象指向刚分配的内存空间&lt;/li&gt;
&lt;li&gt;初始化对象&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;现在考虑重排序后，两个线程发生了以下调用：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Time&lt;/th&gt;
&lt;th&gt;Thread A&lt;/th&gt;
&lt;th&gt;Thread B&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;T1&lt;/td&gt;
&lt;td&gt;检查到uniqueSingleton为空&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;T2&lt;/td&gt;
&lt;td&gt;获取锁&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;T3&lt;/td&gt;
&lt;td&gt;再次检查到uniqueSingleton为空&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;T4&lt;/td&gt;
&lt;td&gt;为uniqueSingleton分配内存空间&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;T5&lt;/td&gt;
&lt;td&gt;将uniqueSingleton指向内存空间&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;T6&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;检查到uniqueSingleton不为空&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;T7&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;访问uniqueSingleton（此时对象还未完成初始化）&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;T8&lt;/td&gt;
&lt;td&gt;初始化uniqueSingleton&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;在这里添加volatile关键字主要是避免在对象未完整完成对象创建就已经被其他线程读取，造成空指针异常。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;volatile 的主要作用是实现可见性和禁止指令重排。&lt;/li&gt;
&lt;li&gt;线程安全需要满足可见性、有序性、原子性。&lt;/li&gt;
&lt;li&gt;volatile 可以保证可见性和有序性，但是无法保证原子性，所以是线程不安全的。（非原子操作可能会导致数据缓存在CPU的cache中，产生数据不一致）&lt;/li&gt;
&lt;li&gt;synchronized 关键字虽然可以保证可见性、有序性、原子性，而且用法简单，但是性能开销大。&lt;/li&gt;
&lt;li&gt;双重检查锁模式是 volatile 的典型使用场景，双重检查锁通常用于实现单例模式或延迟赋值。&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;0.64705882352941&quot;&gt;
&lt;p&gt;参考&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/zhengbin/p/5654805.html&quot;&gt;Java中Volatile关键字详解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/195ae7c77afe?from=timeline&amp;amp;isappinstalled=0&quot;&gt;java volatile关键字解惑&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/goodAndyxublog/p/11356402.html&quot;&gt;为什么双重检查锁模式需要 volatile ？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/xz816111/p/8470048.html&quot;&gt;Java中的双重检查锁（double checked locking）&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 08 Jul 2020 00:28:00 +0000</pubDate>
<dc:creator>leapMie</dc:creator>
<og:description>首发地址 https://blog.leapmie.com/archives/66ba646f/ 日常编程中出现 volatile 关键字的频率并不高，大家可能对 volatile 关键字比较陌生，再</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/leap/p/13262236.html</dc:identifier>
</item>
<item>
<title>实战SpringCloud通用请求字段拦截处理 - 清茶豆奶</title>
<link>http://www.cnblogs.com/huangying2124/p/13264753.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huangying2124/p/13264753.html</guid>
<description>&lt;h3 id=&quot;背景&quot;&gt;背景&lt;/h3&gt;
&lt;p&gt;以SpringCloud构建的微服务系统为例，使用前后端分离的架构，每个系统都会提供一些通用的请求参数，例如移动端的系统版本信息、IMEI信息，Web端的IP信息，浏览器版本信息等，这些参数可能放在header里，也可以放在参数里，如果这些参数需要在每个方法内声明定义，一来工作量太大，二是这些通用参数与业务接口方法耦合过紧，本身就是一个不好的设计。&lt;/p&gt;
&lt;p&gt;这个问题该如何优雅地解决呢？&lt;/p&gt;
&lt;h3 id=&quot;最佳实践&quot;&gt;最佳实践&lt;/h3&gt;
&lt;h4 id=&quot;实现思路&quot;&gt;实现思路&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;利用SpringMVC提供拦截器，对匹配的请求，抽取通用的header信息（假设通用字段全部放在header里）&lt;/li&gt;
&lt;li&gt;将每个请求的信息单独隔离开，互不干扰。&lt;/li&gt;
&lt;li&gt;Controller层使用时，可以将在该请求线程(http线程)里将通用的header信息提取出来使用。&lt;/li&gt;
&lt;li&gt;请求线程完成时，相应的header头信息对象需要回收销毁。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;实现方式&quot;&gt;实现方式&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;SpringMVA提供的HandlerInterceptorAdapter可以拿来使用，继承实现即可。&lt;/li&gt;
&lt;li&gt;使用ThreadLocal记录每个请求的信息，ThreadLocal有隔离线程变量的作用。&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;handlerinterceptoradapter的源码实现及注释&quot;&gt;HandlerInterceptorAdapter的源码实现及注释&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public abstract class HandlerInterceptorAdapter implements AsyncHandlerInterceptor {

        @Override
        public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
                        throws Exception {
        // 在业务接口方法处理之前被调用，可以在这里对通用的header信息进行提取
                return true;
        }

        @Override
        public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,
                        @Nullable ModelAndView modelAndView) throws Exception {
                // 这个方法在业务接口方法执行完成后，生成SpringMVC ModelAndView之前被调用
                // 今天这个案例我们不用此方法，故可以不实现。
        }
        
        @Override
        public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler,
                        @Nullable Exception ex) throws Exception {
                // 这个方法在DispatcherServlet完全处理完成后被调用，可以在这里对ThreadLocal的内容进行释放
        }

        @Override
        public void afterConcurrentHandlingStarted(HttpServletRequest request, HttpServletResponse response,
                        Object handler) throws Exception {
                // 这个方法用来处理异步主动，但也会先行调用preHandle，然后执行此方法，异步线程完成后会执行postHandle和afterCompletion两方法，这里暂时用不上。
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;threadlocal的源码主要实现及注释&quot;&gt;ThreadLocal的源码主要实现及注释&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class ThreadLocal&amp;lt;T&amp;gt; {
    
    protected T initialValue() {
        return null;
    }

    public T get() {
                // 获取当前的线程
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        if (map != null) {
            ThreadLocalMap.Entry e = map.getEntry(this);
            if (e != null) {
                @SuppressWarnings(&quot;unchecked&quot;)
                T result = (T)e.value;
                return result;
            }
        }
        return setInitialValue();
    }

    private T setInitialValue() {
        T value = initialValue();
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        if (map != null)
            map.set(this, value);
        else
            createMap(t, value);
        return value;
    }

    public void set(T value) {
                // 获取当前的线程
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        if (map != null)
            map.set(this, value);
        else
            createMap(t, value);
    }

     public void remove() {
         ThreadLocalMap m = getMap(Thread.currentThread());
         if (m != null)
             m.remove(this);
     }

    ThreadLocalMap getMap(Thread t) {
        return t.threadLocals;
    }

    void createMap(Thread t, T firstValue) {
        t.threadLocals = new ThreadLocalMap(this, firstValue);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;简单来说，ThreadLocal最关键的get()和set()方法，都是针对当前线程来操作的，调用set()方法时把值放到ThreadMap(Map的一种实现)中，以当前线程的hash值为key，get()方法则对应以当前线程作为key来取值，从而实现每个线程的数据是隔离的效果。&lt;/p&gt;
&lt;p&gt;另附上ThreadLocal类源码解读的导图，仅供参考&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/df65daca-e6f3-4463-8343-204d20928149.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;案例实战&quot;&gt;案例实战&lt;/h3&gt;
&lt;p&gt;我们对实际业务系统进行简化处理，假定header信息固定有ip，uid，deviceId三个信息，按照上文的实现思路，开始案例演示。&lt;/p&gt;
&lt;h4 id=&quot;dto定义&quot;&gt;DTO定义&lt;/h4&gt;
&lt;p&gt;通用的header信息，使用Dto对象进行封装：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Data
public class CommonHeader implements Serializable {

        private static final long serialVersionUID = -3949488282201167943L;
        
        /**
         * 真实ip
         */
        private String ip;

        /**
         * 设备id
         */
        private String deviceId;

        /**
         * 用户uid
         */
        private Long uid;
        
        // 省略getter/setter/构造器
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定义Request请求的封装类Dto，并引入ThreadLocal：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * 将公共请求头信息放在ThreadLocal中去
 */
public class RequestWrap {

        private static ThreadLocal&amp;lt;CommonHeader&amp;gt; current = new ThreadLocal&amp;lt;&amp;gt;();

    /**
         * 获取静态的ThreadLocal对象
         * @return
         */
        public static ThreadLocal&amp;lt;CommonHeader&amp;gt; getCurrent() {
                return current;
        }
        
        /**
         * 获取ip
         * @return
         */
        public static String getIp() {
                CommonHeader request = current.get();
                if (request == null) {
                        return StringUtils.EMPTY;
                }
                return request.getIp();
        }

        /**
         * 获取uid
         * @return
         */
        public static Long getUid() {
                CommonHeader request = current.get();
                if (request == null) {
                        return null;
                }
                return request.getUid();
        }

        /**
         * 获取封装对象
         * @return
         */
        public static CommonHeader getCommonReq() {
                CommonHeader request = current.get();
                if (request == null) {
                        return new CommonHeader(StringUtils.EMPTY, StringUtils.EMPTY,0L);
                }
                return request;
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;工具类&quot;&gt;工具类&lt;/h4&gt;
&lt;p&gt;这里添加一个简单的工具类，将HttpServletRequest通过getHeader方法，生成CommonHeader类：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class HttpUtil {
        /**
         * 获取请求头信息
         *
         * @param request
         * @return
         */
        public static CommonHeader getCommonHeader(HttpServletRequest request) {
                String UID = request.getHeader(&quot;uid&quot;);
                Long uid = null;
                if (StringUtils.isNotBlank(UID)) {
                        uid = Long.parseLong(UID);
                }
                return new CommonHeader(HttpUtil.getIp(request), request.getHeader(&quot;deviceId&quot;), uid);
        }

        /**
         * 获取IP
         *
         * @param request
         * @return
         */
        public static String getIp(HttpServletRequest request) {
                String ip = request.getHeader(&quot;X-Forwarded-For&quot;);

                if (null != ip &amp;amp;&amp;amp; !&quot;&quot;.equals(ip.trim()) &amp;amp;&amp;amp; !&quot;unknown&quot;.equalsIgnoreCase(ip)) {
                        int index = ip.indexOf(',');
                        if (index != -1) {
                                return ip.substring(0, index);
                        } else {
                                return ip;
                        }
                }
                ip = request.getHeader(&quot;X-Real-IP&quot;);
                if (null != ip &amp;amp;&amp;amp; !&quot;&quot;.equals(ip.trim()) &amp;amp;&amp;amp; !&quot;unknown&quot;.equalsIgnoreCase(ip)) {
                        return ip;
                }
                return request.getRemoteAddr();
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;拦截器类实现&quot;&gt;拦截器类实现&lt;/h4&gt;
&lt;p&gt;最核心的实现终于出场了，这里继承HandlerInterceptorAdapter，这里作了简化处理：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * 请求头处理
 *
 * @author yangfei
 */
@Component
public class BaseInterceptor extends HandlerInterceptorAdapter {

        private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(BaseInterceptor.class);


        @Override
        public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
                        throws Exception {
                RequestWrap.getThreadLocal().set(HttpUtil.getCommonHeader(request));
                return true;
        }

        @Override
        public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,
                        ModelAndView modelAndView) throws Exception {
        }

        @Override
        public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)
                        throws Exception {
                RequestWrap.getThreadLocal().remove();
        }

        @Override
        public void afterConcurrentHandlingStarted(HttpServletRequest request, HttpServletResponse response, Object handler)
                        throws Exception {
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上一章节描述的逻辑，在preHandle方法内将request中的ip,uid,deviceId封装到RequestWrap对象里，在afterCompletion中对该线程的ThreadLocal值进行释放。&lt;/p&gt;
&lt;h4 id=&quot;业务接口方法的使用&quot;&gt;业务接口方法的使用&lt;/h4&gt;
&lt;p&gt;在Controller类的接口方法中，如要获取uid信息，只需要调用RequestWrap.getUid()方法即可，再也不需要在每个接口上声明uid参数了，如下示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * 获取用户基础信息
 */
@PostMapping(value = &quot;/user/info&quot;)
public Response&amp;lt;UserInfo&amp;gt; getUserInfo() {
        return userManager.getUserInfo(RequestWrap.getUid());
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;这个实战的目标是解决通用header信息的在接口的重复定义问题，基于HandlerInterceptorAdapter拦截器的实现，ThreadLocal对线程访问数据的隔离来实现的，在实际生产项目应用中有很好的借鉴意义，希望对你有帮助。&lt;/p&gt;
&lt;p&gt;专注Java高并发、分布式架构，更多技术干货分享与心得，请关注公众号：Java架构社区&lt;br/&gt;可以扫左边二维码添加好友，邀请你加入Java架构社区微信群共同探讨技术&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1834889/202003/1834889-20200303074927076-1724862603.jpg&quot; alt=&quot;Java架构社区&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 07 Jul 2020 23:32:00 +0000</pubDate>
<dc:creator>清茶豆奶</dc:creator>
<og:description>背景 以SpringCloud构建的微服务系统为例，使用前后端分离的架构，每个系统都会提供一些通用的请求参数，例如移动端的系统版本信息、IMEI信息，Web端的IP信息，浏览器版本信息等，这些参数可能</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/huangying2124/p/13264753.html</dc:identifier>
</item>
<item>
<title>使用@AutoConfigureBefore调整配置顺序竟没生效？ - YourBatman</title>
<link>http://www.cnblogs.com/yourbatman/p/13264743.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yourbatman/p/13264743.html</guid>
<description>&lt;blockquote readability=&quot;7.5249406175772&quot;&gt;
&lt;p&gt;一个人的价值体现在能够帮助多少人。自己编码好，价值能得到很好的体现。若你做出来的东西能够帮助别人开发，大大减少开发的时间，那就功德无量。关注公众号【&lt;strong&gt;BAT的乌托邦&lt;/strong&gt;】开启专栏式学习，拒绝浅尝辄止。本文 &lt;a href=&quot;https://www.yourbatman.cn&quot;&gt;https://www.yourbatman.cn&lt;/a&gt; 已收录，里面一并有Spring技术栈、MyBatis、中间件等小而美的专栏供以学习哦。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200707062022385.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;各位小伙伴大家好，我是A哥。&lt;code&gt;Spring Boot&lt;/code&gt;是Spring家族具有划时代意义的一款产品，它发展自&lt;code&gt;Spring Framework&lt;/code&gt;却又高于它，这种高于主要表现在其最重要的&lt;strong&gt;三大特性&lt;/strong&gt;，而相较于这三大特性中更为重要的便是&lt;strong&gt;Spring Boot的自动配置&lt;/strong&gt;（&lt;code&gt;AutoConfiguration&lt;/code&gt;）。与其说是自动，倒不如说是“智能”，该框架看起来好像“更聪明”了。因此它也顺理成章的成为了构建微服务的基础设施，稳坐第一宝座。&lt;/p&gt;
&lt;p&gt;生活之道，在于取舍。编程何尝不是，任何决定都会是一把双刃剑，&lt;code&gt;Spring Boot&lt;/code&gt;的自动配置解决了Spring Framework使用起来的众多痛点，让开发效率可以得到&lt;strong&gt;指数级提升&lt;/strong&gt;（想一想，这不就是功德无量吗？）。成也萧何败也萧何，也正是因为它的太智能，倘若出了问题就会让程序员两眼一抹黑，无从下手。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;瑕不掩瑜，Spring Boot前进的步伐浩浩荡荡，学就完了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这不，我就在前几天收到一个“求助”，希望使用&lt;code&gt;@AutoConfigureBefore&lt;/code&gt;来&lt;strong&gt;控制配置的顺序&lt;/strong&gt;，但并未能如愿。本文就针对这个场景case稍作展开，讨论下使用&lt;code&gt;@AutoConfigureBefore、@AutoConfigureAfter、@AutoConfigureOrder&lt;/code&gt;三大注解控制自动配置执行顺序的&lt;strong&gt;正确姿势&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;提示：Spring Boot的自动配置是通过@EnableAutoConfiguration注解驱动的，默认是开启状态。你也可以通过&lt;code&gt;spring.boot.enableautoconfiguration = false&lt;/code&gt;来关闭它，回退到Spring Framework时代。显然这不是本文需要讨论的内容~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020050916181352.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;本文将要聊的重点是Spring Boot自动配置 + 顺序控制，自动配置大家都耳熟能详，那么“首当其冲”就是知晓这个问题：配置类的执行为何需要控制顺序？&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;配置类为何需要顺序？&quot;&gt;配置类为何需要顺序？&lt;/h2&gt;
&lt;p&gt;我们已经知道Spring容器它对Bean的初始化是&lt;strong&gt;无序&lt;/strong&gt;的，我们并不能想当然的通过&lt;code&gt;@Order&lt;/code&gt;注解来控制其执行顺序。一般来说，对于容器内普通的Bean我们只需要关注依赖关系即可，而并不需要关心其绝对的顺序，而依赖关系的管理Spring的是做得很好的，这不连&lt;strong&gt;循环依赖&lt;/strong&gt;它都可以搞定麽。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;@Configuration&lt;/code&gt;配置类它也是一个Bean，但对于配置类来说，某些场景下的执行顺序是&lt;strong&gt;必须的&lt;/strong&gt;，是需要得到保证的。比如很典型的一个非A即B的case：若容器内已经存在A了，就不要再把B放进来。这种case即使用中文理解，就能知道对A的“判断”必须要放在B的前面，否则可能导致程序出问题。&lt;/p&gt;
&lt;p&gt;那么针对于配置的执行顺序，传统Spring和Spring Boot下各自是如何处理的，表现如何呢？&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;spring下控制配置执行顺序&quot;&gt;Spring下控制配置执行顺序&lt;/h3&gt;
&lt;p&gt;在传统的&lt;code&gt;Spring Framework&lt;/code&gt;里，一个&lt;code&gt;@Configuration&lt;/code&gt;注解标注的类就代表一个配置类，当存在多个&lt;code&gt;@Configuration&lt;/code&gt;时，他们的&lt;strong&gt;执行顺序&lt;/strong&gt;是由使用者靠手动指定的，就像这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 手动控制Config1 Config2的顺序
ApplicationContext context = new AnnotationConfigApplicationContext(Config1.class, Config2.class);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然，你可能就疑问了说：即使在传统Spirng里，我也从没有自己使用过&lt;code&gt;AnnotationConfigApplicationContext&lt;/code&gt;来显示加载配置啊，都是使用&lt;code&gt;@Configuration&lt;/code&gt;定义好配置类后，点击&lt;code&gt;Run&lt;/code&gt;一把唆的。没错，那是因为你是在web环境下使用Spring，IoC容器是借助web容器（如Tomcat等）来驱动的，Spring对此部分封装得非常好，所以做到了对使用者几乎无感知。&lt;/p&gt;
&lt;p&gt;关于这部分的内容，此处就不深究了，毕竟本文重点不在这嘛。但可以给出给小结论：&lt;code&gt;@Configuration&lt;/code&gt;配置被加载进容器的方式大体上可分为两种：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;手动。构建&lt;code&gt;ApplicationContext&lt;/code&gt; 时由构建者手动传入，可手动控制顺序&lt;/li&gt;
&lt;li&gt;自动。被&lt;code&gt;@ComponentScan&lt;/code&gt;自动扫描进去，无法控制顺序&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;绝大多数情况下我们都是使用&lt;strong&gt;自动&lt;/strong&gt;的方式，所以在Spring下对配置的顺序并无感知。其实这也是需求驱使，因为在传统Spring下我们并无此需求，所以对它无感是合乎逻辑的。另说一句，虽然我们并不能控制Bean的顺序，但是我们是可以干涉它的，比如：控制依赖关系、提升优先级、“间接”控制执行顺序...当然喽这是后面文章的内容，敬请关注。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;spring-boot下控制配置执行顺序&quot;&gt;Spring Boot下控制配置执行顺序&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Spring Boot&lt;/code&gt;下对&lt;strong&gt;自动配置&lt;/strong&gt;的管理对比于Spring它就是黑盒，它会根据当前容器内的情况来&lt;strong&gt;动态的&lt;/strong&gt;判断自动配置类的加载与否、以及加载的顺序，所以可以说：Spring Boot的自动配置它对顺序是有&lt;strong&gt;强要求&lt;/strong&gt;的。需求驱使，Spring Boot给我们提供了&lt;code&gt;@AutoConfigureBefore、@AutoConfigureAfter、@AutoConfigureOrder&lt;/code&gt;（下面统称这三个注解为“三大注解”）这三个注解来帮我们解决这种诉求。&lt;/p&gt;
&lt;p&gt;需要注意的是：三大注解是Spring Boot提供的而非Spring Framework。其中前两个是1.0.0就有了，&lt;code&gt;@AutoConfigureOrder&lt;/code&gt;属于1.3.0版本新增，表示绝对顺序（数字越小，优先级越高）。另外，这几个注解&lt;strong&gt;并不互斥&lt;/strong&gt;，可以同时标注在同一个&lt;code&gt;@Configuration&lt;/code&gt;自动配置类上。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;spring-boot内置的控制配置顺序举例&quot;&gt;Spring Boot内置的控制配置顺序举例&lt;/h2&gt;
&lt;p&gt;为方便大家理解，我列出一个Spring Boot它自己的使用作为示例学一学。以大家最为熟悉的WebMvc的自动配置场景为例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Configuration(proxyBeanMethods = false)
@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)
@AutoConfigureAfter({ DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class, ValidationAutoConfiguration.class })
public class WebMvcAutoConfiguration { ... }


@Configuration(proxyBeanMethods = false)
@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)
@AutoConfigureAfter(ServletWebServerFactoryAutoConfiguration.class)
public class DispatcherServletAutoConfiguration { ... }


@Configuration(proxyBeanMethods = false)
@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)
public class ServletWebServerFactoryAutoConfiguration { ... }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这几个配置是WebMVC的核心配置，他们之间是有顺序关系的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;WebMvcAutoConfiguration&lt;/code&gt;被加载的前提是：&lt;code&gt;DispatcherServletAutoConfiguration、TaskExecutionAutoConfiguration、ValidationAutoConfiguration&lt;/code&gt;这三个哥们都已经完成初始化&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DispatcherServletAutoConfiguration&lt;/code&gt;被加载的前提是：&lt;code&gt;ServletWebServerFactoryAutoConfiguration&lt;/code&gt;已经完成初始化&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ServletWebServerFactoryAutoConfiguration&lt;/code&gt;被加载的前提是：&lt;code&gt;@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)&lt;/code&gt;最高优先级，也就是说它无其它依赖，&lt;strong&gt;希望自己是最先被初始化的&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;当碰到多个配置都是最高优先级的时候，且互相之前没有关系的话，顺序也是不定的。但若互相之间存在依赖关系（如本利的&lt;code&gt;DispatcherServletAutoConfiguration&lt;/code&gt;和&lt;code&gt;ServletWebServerFactoryAutoConfiguration&lt;/code&gt;），那就按照相对顺序走&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200418160820903.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Y2NDEzODU3MTI=,size_16,color_FFFFFF,t_70#x330&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;WebMvcAutoConfiguration&lt;/code&gt;加载&lt;strong&gt;后&lt;/strong&gt;，在它&lt;strong&gt;之后&lt;/strong&gt;其实还有很多配置会尝试执行，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@AutoConfigureAfter(WebMvcAutoConfiguration.class)
class FreeMarkerServletWebConfiguration extends AbstractFreeMarkerConfiguration { ... }

@AutoConfigureAfter(WebMvcAutoConfiguration.class)
public class GroovyTemplateAutoConfiguration { ... }

@AutoConfigureAfter({ WebMvcAutoConfiguration.class, WebFluxAutoConfiguration.class })
public class ThymeleafAutoConfiguration { ... }

@AutoConfigureAfter(WebMvcAutoConfiguration.class)
public class LifecycleMvcEndpointAutoConfiguration { ... }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这些都很容易理解：如果都不是Web环境，加载一些模版引擎的并无必要嘛。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;三大注解使用的误区（重要）&quot;&gt;三大注解使用的误区（重要）&lt;/h2&gt;
&lt;p&gt;根据我的切身体会，针对这三大注解，实在有太多人把它&lt;strong&gt;误用&lt;/strong&gt;了，想用但是用了却又不生效，于是就容易触发一波“骂街”操作，其实这也是我书写本文的最大动力所在：纠正你的错误使用，告诉你正确姿势。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;错误使用示例&quot;&gt;错误使用示例&lt;/h3&gt;
&lt;p&gt;我见到的非常多的小伙伴这么来使用三大注解：我这里使用“伪代码”进行模拟&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Configuration
public class B_ParentConfig {

    B_ParentConfig() {
        System.out.println(&quot;配置类ParentConfig构造器被执行...&quot;);
    }
}

@Configuration
public class A_SonConfig {

    A_SonConfig() {
        System.out.println(&quot;配置类SonConfig构造器被执行...&quot;);
    }
}

@Configuration
public class C_DemoConfig {
    public C_DemoConfig(){
        System.out.println(&quot;我是被自动扫描的配置，初始化啦....&quot;);
    }
}

@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args).close();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过名称能知道我想要的达到的效果是：&lt;strong&gt;ParentConfig先加载，SonConfig后加载&lt;/strong&gt;。（DemoConfig作为一个参考配置，作为日志参考使用即可）&lt;/p&gt;
&lt;p&gt;启动应用，控制台打印：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;配置类SonConfig构造器被执行...
配置类ParentConfig构造器被执行...
我是被自动扫描的配置，初始化啦....
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Son优先于Parent被加载了，这明显&lt;strong&gt;不符合要求&lt;/strong&gt;。因此，我看到很多小伙伴就这么干：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@AutoConfigureBefore(A_SonConfig.class)
@Configuration
public class B_ParentConfig {

    B_ParentConfig() {
        System.out.println(&quot;配置类ParentConfig构造器被执行...&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过&lt;code&gt;@AutoConfigureBefore&lt;/code&gt;控制，表示在&lt;code&gt;A_SonConfig&lt;/code&gt;之前执行此配置。语义层面上看，貌似没有任何问题，再次启动应用：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;配置类SonConfig构造器被执行...
配置类ParentConfig构造器被执行...
我是被自动扫描的配置，初始化啦....
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;what a fuck。看到没，我没骗你吧，骂街了骂街了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200509163634888.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;竟然没生效？代码不会骗人，&lt;code&gt;@AutoConfigureBefore&lt;/code&gt;的语义也没有问题，而是你使用的姿势不对，下面我会给你正确姿势。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;三大注解使用的正确姿势&quot;&gt;三大注解使用的正确姿势&lt;/h2&gt;
&lt;p&gt;针对以上case，要想达到预期效果，正确姿势只需要下面两步：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;把&lt;code&gt;A_SonConfig&lt;/code&gt;和&lt;code&gt;B_ParentConfig&lt;/code&gt;挪动到Application&lt;strong&gt;扫描不到&lt;/strong&gt;的包内，切记：一定且必须是扫描不到的包内&lt;/li&gt;
&lt;li&gt;当前工程里增加配置&lt;code&gt;META-INF/spring.factories&lt;/code&gt;，内容为(配置里Son和Parent前后顺序对结果无影响)：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.fsx.autoconfig.A_SonConfig,com.fsx.autoconfig.B_ParentConfig
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再次启动应用看看，打印输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;我是被自动扫描的配置，初始化啦....
配置类ParentConfig构造器被执行...
配置类SonConfig构造器被执行...
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;完美&lt;/strong&gt;。符合预期，Parent终于在Son之前完成了初始化，也就是说我们的&lt;code&gt;@AutoConfigureBefore&lt;/code&gt;注解生效了。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;使用细节注意事项&quot;&gt;使用细节注意事项&lt;/h3&gt;
&lt;p&gt;针对此使用姿势，虽然很正确，并不是完全没有“副作用”的，有如下细节平时也需要引起注意：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;若你不用&lt;code&gt;@AutoConfigureBefore&lt;/code&gt;这个注解，单单就想依赖于spring.factories里的先后顺序的来控制实际的加载顺序，答案是&lt;strong&gt;不可以&lt;/strong&gt;，控制不了&lt;/li&gt;
&lt;li&gt;例子中有个小细节：我每次都故意输出了&lt;code&gt;我是被自动扫描的配置，初始化啦....&lt;/code&gt;这句话，可以发现被扫描进去配置实例化是在它前面（见错误示例），而通过&lt;code&gt;spring.factories&lt;/code&gt;方式进去是在它的后面（见正确姿势）&lt;/li&gt;
&lt;li&gt;从这个小细节可以衍生得到结论：&lt;code&gt;Spring Boot&lt;/code&gt;的自动配置均是通过&lt;code&gt;spring.factories&lt;/code&gt;来指定的，它的优先级最低（执行时机是最晚的）；通过扫描进来的一般都是你自己自定义的配置类，所以优先级是最高的，&lt;strong&gt;肯定在自动配置之前加载&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;从这你应该学到：若你要指定扫描的包名，请千万不要扫描到形如&lt;code&gt;org.springframework&lt;/code&gt;这种包名，否则“天下大乱”（当然喽为了防止这种情况出现，Spring Boot做了容错的。它有一个类专门检测这个case防止你配置错了，具体参见&lt;code&gt;ComponentScanPackageCheck&lt;/code&gt;默认实现）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;请尽量不要让自动配置类既被扫描到了，又放在&lt;code&gt;spring.factories&lt;/code&gt;配置了，否则后者会覆盖前者，很容易造成莫名其妙的错误&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;小总结，对于三大注解的正确使用姿势是应该是：请使用在你的&lt;strong&gt;自动配置&lt;/strong&gt;里（一般是你自定义starter时使用），而不是使用在你业务工程中的&lt;code&gt;@Configuration&lt;/code&gt;里，因为那会毫无效果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200509165554902.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;三大注解解析时机浅析&quot;&gt;三大注解解析时机浅析&lt;/h2&gt;
&lt;p&gt;为了更好的辅助理解，加强记忆，本文将这三大注解解析时机&lt;strong&gt;简要的&lt;/strong&gt;絮叨一下，知道了它被解析的时机，自然就很好解释为何你那么写是无效的喽。&lt;/p&gt;
&lt;p&gt;这三个注解的解析都是交给&lt;code&gt;AutoConfigurationSorter&lt;/code&gt;来排序、处理的，做法类似于&lt;code&gt;AnnotationAwareOrderComparator&lt;/code&gt;去解析排序&lt;code&gt;@Order&lt;/code&gt;注解。核心代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;class AutoConfigurationSorter {
        
        // 唯一给外部调用的方法：返回排序好的Names，因此返回的是个List嘛（ArrayList）
        List&amp;lt;String&amp;gt; getInPriorityOrder(Collection&amp;lt;String&amp;gt; classNames) {
                ...
                // 先按照自然顺序排一波
                Collections.sort(orderedClassNames);
                // 在按照@AutoConfigureBefore这三个注解排一波
                orderedClassNames = sortByAnnotation(classes, orderedClassNames);
                return orderedClassNames;
        }
        ...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此排序器被两个地方使用到：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;AutoConfigurationImportSelector&lt;/code&gt;：Spring自动配置处理器，用于加载所有的自动配置类。它实现了&lt;code&gt;DeferredImportSelector&lt;/code&gt;接口：这也顺便解释了为何自动配置是最后执行的原因~&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AutoConfigurations&lt;/code&gt;：表示自动配置@Configuration类。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这个排序的“解析/排序”过程还是比较复杂的，本文点到为止，观其大意即可。你可以简单粗暴的记住结论：&lt;code&gt;@AutoConfigureBefore、@AutoConfigureAfter、@AutoConfigureOrder&lt;/code&gt;这三个注解只能作用于&lt;strong&gt;自动配置类&lt;/strong&gt;，而不能是自定义的@Configuration配置类。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;关于Spring Boot自动配置顺序相关的三大注解&lt;code&gt;@AutoConfigureBefore、@AutoConfigureAfter、@AutoConfigureOrder&lt;/code&gt;就先介绍到这了，本文主要用意是为了帮助大家规范此些“常用注解”的使用，规避一些误区，端正使用姿势，避免犯错时又丈二和尚。&lt;/p&gt;
&lt;p&gt;我看到不少文章、生产上的代码都使用错了（估计有没有效果自己的都不知道，又或者刚好歪打正着确实是在xxx后面执行而以为生效了），希望本文能帮助到你。&lt;/p&gt;
</description>
<pubDate>Tue, 07 Jul 2020 23:17:00 +0000</pubDate>
<dc:creator>YourBatman</dc:creator>
<og:description>调整配置的顺序，如是而已</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yourbatman/p/13264743.html</dc:identifier>
</item>
<item>
<title>用Kubernetes部署Springboot或Nginx，也就一个文件的事 - 南瓜慢说</title>
<link>http://www.cnblogs.com/larrydpk/p/13264516.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/larrydpk/p/13264516.html</guid>
<description>&lt;p&gt;经过《&lt;a href=&quot;https://www.pkslow.com/archives/docker-maven-plugin&quot;&gt;Maven一键部署Springboot到Docker仓库，为自动化做准备&lt;/a&gt;》，&lt;code&gt;Springboot&lt;/code&gt;的&lt;code&gt;Docker&lt;/code&gt;镜像已经准备好，也能在&lt;code&gt;Docker&lt;/code&gt;上成功运行了，是时候放上&lt;code&gt;Kubernetes&lt;/code&gt;跑一跑了。这非常简单，一个&lt;code&gt;yaml&lt;/code&gt;文件即可。&lt;/p&gt;

&lt;h2 id=&quot;21-准备yaml文件&quot;&gt;2.1 准备yaml文件&lt;/h2&gt;
&lt;p&gt;当准备好镜像文件后，要部署到&lt;code&gt;Kubernetes&lt;/code&gt;就非常容易了，只需要一个&lt;code&gt;yaml&lt;/code&gt;格式的文件即可，这个文件能描述你所需要的组件，如&lt;code&gt;Deployment&lt;/code&gt;、&lt;code&gt;Service&lt;/code&gt;、&lt;code&gt;Ingress&lt;/code&gt;等。定义如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;apiVersion: apps/v1
kind: Deployment
metadata:
  name: pkslow-springboot-deployment
spec:
  selector:
    matchLabels:
      app: springboot
  replicas: 2
  template:
    metadata:
      labels:
        app: springboot
    spec:
      containers:
        - name: springboot
          image: pkslow/springboot-mongo:0.0.6
          ports:
            - containerPort: 8080

---
apiVersion: v1
kind: Service
metadata:
  labels:
    app: springboot
  name: pkslow-springboot-service
spec:
  ports:
    - port: 8080
      name: springboot-service
      protocol: TCP
      targetPort: 8080
      nodePort: 30080
  selector:
    app: springboot
  type: NodePort
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Kind&lt;/code&gt;：类型，有&lt;code&gt;Deployment&lt;/code&gt;、&lt;code&gt;Service&lt;/code&gt;、&lt;code&gt;Pod&lt;/code&gt;、&lt;code&gt;Ingress&lt;/code&gt;等，非常丰富；&lt;/p&gt;
&lt;p&gt;&lt;code&gt;metadata&lt;/code&gt;：用于定义一些组件信息，如名字、标签等；&lt;/p&gt;
&lt;p&gt;&lt;code&gt;labels&lt;/code&gt;：标签功能，非常有用，用于选择关联；但&lt;code&gt;label&lt;/code&gt;不提供唯一性，可以使用组合来选择；&lt;/p&gt;
&lt;p&gt;&lt;code&gt;nodePort&lt;/code&gt;：对于需要给外部暴露的服务，有三种方式：&lt;code&gt;NodePorts&lt;/code&gt;、&lt;code&gt;LoadBalancer&lt;/code&gt;、&lt;code&gt;Ingress&lt;/code&gt;，这里使用&lt;code&gt;NodePorts&lt;/code&gt;；需要注意的是，默认它的端口范围是&lt;code&gt;[3000-32767]&lt;/code&gt;，需要其它范围则需要修改相关参数。&lt;/p&gt;
&lt;h2 id=&quot;22-通过kubectl命令部署&quot;&gt;2.2 通过kubectl命令部署&lt;/h2&gt;
&lt;p&gt;当&lt;code&gt;yaml&lt;/code&gt;文件准备好之后，就可以通过以下命令部署：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;$ kubectl create -f pksow-springboot.yaml 
deployment.apps/pkslow-springboot-deployment created
service/pkslow-springboot-service created
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看控制台日志则表明成功创建了&lt;code&gt;Deployment&lt;/code&gt;和&lt;code&gt;Service&lt;/code&gt;。查看&lt;code&gt;Dashboard&lt;/code&gt;如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/946674/202007/946674-20200708010834055-1199822314.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;访问&lt;code&gt;Web&lt;/code&gt;服务：&lt;a href=&quot;http://localhost:30080/user&quot;&gt;http://localhost:30080/user&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/946674/202007/946674-20200708010835216-1880113655.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过命令行检查一下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;$ kubectl get deployment
NAME                           READY   UP-TO-DATE   AVAILABLE   AGE
pkslow-springboot-deployment   2/2     2            2           8m2s

$ kubectl get service
NAME                        TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)          AGE
kubernetes                  ClusterIP   10.96.0.1        &amp;lt;none&amp;gt;        443/TCP          10m
pkslow-springboot-service   NodePort    10.102.218.119   &amp;lt;none&amp;gt;        8080:30080/TCP   8m7s

$ kubectl get pod
NAME                                            READY   STATUS    RESTARTS   AGE
pkslow-springboot-deployment-68dffc6795-874tp   1/1     Running   0          8m15s
pkslow-springboot-deployment-68dffc6795-89xww   1/1     Running   0          8m15s
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至此，我们已经成功把&lt;code&gt;Springboot&lt;/code&gt;发布到&lt;code&gt;Kubernetes&lt;/code&gt;了。&lt;/p&gt;
&lt;h2 id=&quot;23-试试杀死一个pod？&quot;&gt;2.3 试试杀死一个pod？&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Kubernetes&lt;/code&gt;最小管理元素并不是容器，而是&lt;code&gt;Pod&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/946674/202007/946674-20200708010836640-677142407.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们试着删掉一个&lt;code&gt;Pod&lt;/code&gt;，看看会发生什么？&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;$ kubectl delete pod pkslow-springboot-deployment-68dffc6795-89xww
pod &quot;pkslow-springboot-deployment-68dffc6795-89xww&quot; deleted

$ kubectl get pod
NAME                                            READY   STATUS    RESTARTS   AGE
pkslow-springboot-deployment-68dffc6795-874tp   1/1     Running   0          13m
pkslow-springboot-deployment-68dffc6795-gpw67   1/1     Running   0          46s
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以发现，删除了其它一个&lt;code&gt;Pod&lt;/code&gt;后，会自动为我们新生成一个&lt;code&gt;Pod&lt;/code&gt;，这样能提高整个服务的高可用。&lt;/p&gt;
&lt;h2 id=&quot;24-试试杀死一个容器？&quot;&gt;2.4 试试杀死一个容器？&lt;/h2&gt;
&lt;p&gt;我们再来探索一下如果杀死一个容器实例，会有什么反应。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;$ docker ps
$ docker rm -f 57869688a226
57869688a226

$ docker ps
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;经实验，杀死一个容器后，也会自动为我们重新生成一个容器实例。而&lt;code&gt;Pod&lt;/code&gt;并不会变化，也不会重新生成。&lt;/p&gt;
&lt;h2 id=&quot;25-快速扩容pod&quot;&gt;2.5 快速扩容Pod&lt;/h2&gt;
&lt;p&gt;用户请求突增，服务要撑不住了，这时需要增加&lt;code&gt;Pod&lt;/code&gt;的个数。只需要修改&lt;code&gt;yaml&lt;/code&gt;配置文件的&lt;code&gt;replicas&lt;/code&gt;，将它更新为&lt;code&gt;replicas: 4&lt;/code&gt;。然后执行以下命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;$ kubectl apply -f pksow-springboot.yaml
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看&lt;code&gt;Dashboard&lt;/code&gt;，在原有两个&lt;code&gt;Pod&lt;/code&gt;的基础上，增加了两个。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/946674/202007/946674-20200708010840221-1826070122.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;如果大家没有&lt;code&gt;Springboot&lt;/code&gt;的镜像，可以使用官方的&lt;code&gt;Nginx&lt;/code&gt;镜像，&lt;code&gt;yaml&lt;/code&gt;文件如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  selector:
    matchLabels:
      app: nginx
  replicas: 3
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
        - name: nginx
          image: nginx:1.19.0
          ports:
            - containerPort: 80

---
apiVersion: v1
kind: Service
metadata:
  labels:
    app: nginx
  name: nginx-service
spec:
  ports:
    - port: 80
      name: nginx-service1
      protocol: TCP
      targetPort: 80
      nodePort: 30000
    - port: 81
      name: nginx-service2
      protocol: TCP
      targetPort: 80
      nodePort: 30001
  selector:
    app: nginx
  type: NodePort
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行部署命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;$ kubectl apply -f nginx-deployment-scale.yaml 
deployment.apps/nginx-deployment created
service/nginx-service created
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看&lt;code&gt;Dashboard&lt;/code&gt;如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/946674/202007/946674-20200708010844138-1945459802.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;访问服务：&lt;a href=&quot;http://localhost:30000/&quot;&gt;http://localhost:30000/&lt;/a&gt; 或 &lt;a href=&quot;http://localhost:30001&quot;&gt;http://localhost:30001&lt;/a&gt; 。因为我们设置了两个。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/946674/202007/946674-20200708010845857-1724187766.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;本文以两个实例带大家感性地认识了&lt;code&gt;Kubernetes&lt;/code&gt;，这对后面深入理解概念是有很大帮助的。原理和细节方面，后续再展开谈吧。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;欢迎访问&lt;a href=&quot;https://www.pkslow.com/&quot;&gt;南瓜慢说 www.pkslow.com&lt;/a&gt;获取更多精彩文章！&lt;/p&gt;
&lt;p&gt;欢迎关注微信公众号&amp;lt;&lt;strong&gt;南瓜慢说&lt;/strong&gt;&amp;gt;，将持续为你更新...&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/946674/202007/946674-20200708010847298-40574558.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多读书，多分享；多写作，多整理。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;欢迎大家关注、转发、点赞。&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 07 Jul 2020 17:09:00 +0000</pubDate>
<dc:creator>南瓜慢说</dc:creator>
<og:description>1 前言 经过《Maven一键部署Springboot到Docker仓库，为自动化做准备》，Springboot的Docker镜像已经准备好，也能在Docker上成功运行了，是时候放上Kubernet</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/larrydpk/p/13264516.html</dc:identifier>
</item>
<item>
<title>【译】Exception Helper – Rethrown Exceptions - MeteorSeed</title>
<link>http://www.cnblogs.com/MeteorSeed/p/13264474.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MeteorSeed/p/13264474.html</guid>
<description>&lt;p&gt;　　是否曾经在异步编程时引发过异常？因为调试器没有显示异常发生的位置而感到沮丧？或者在查看具有内部异常的异常时感到沮丧？调试器不容易显示该异常来自何处。从 Visual Studio 2019 16.5 版本开始，异常帮助器现在包含了重新抛出的异常的原始调用堆栈功能。这有助于找出代码中任何重新抛出异常的根本原因。这在异步异常的情况下尤其有用，异步异常被框架代码捕获并重新抛出。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/270073/202007/270073-20200708004803013-1250029918.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　上面的截图来自一个简单的程序，该程序使用'await'模式。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
tatic &lt;span&gt;async&lt;/span&gt; Task Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
{
    &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; a();
}
&lt;/span&gt;&lt;span&gt;async&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Task&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; a()
{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;await&lt;/span&gt;&lt;span&gt; b();
}
&lt;/span&gt;&lt;span&gt;async&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Task&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; b()
{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;await&lt;/span&gt;&lt;span&gt; c();
}
&lt;/span&gt;&lt;span&gt;async&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Task&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; c()
{
    &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; s = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;await&lt;/span&gt; Task&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;.FromResult(s.ToLower());
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在本例中，异常在 s.ToLower() 处抛出，异常在 await a() 处变为“未处理”，并且由于 await 在C#中的工作方式，调试器将停止。不幸的是，所有有用的信息都回到了 c() 中。现在，随着 Visual Studio 2019 16.5 中的更改，您可以在调用堆栈中看到异常帮助器中最初抛出异常的位置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/270073/202007/270073-20200708004852674-1759712934.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在本例中，您可以单击 Program.cs，链接并导航到调用堆栈顶部ConsoleApp5.Program.c()中的源位置，然后设置一个断点，以便下次运行场景时命中。然后，当遇到断点时，您将被停止在异常产生的位置，以及您可能希望进一步的调试，并尝试修改以修复问题。&lt;/p&gt;
&lt;p&gt;　　虽然可以使用此功能导航到正确的源代码，但不能使用监视来检查应用程序的状态，就像最初抛出异常时一样。这仅仅是因为自那时起其他代码已经运行，这可能会改变应用程序的状态。但是，如果您使用的是 Visual Studio 2019 Enterprise，则还有另一个选项 IntelliTrace。&lt;/p&gt;

&lt;p&gt;　　使用 IntelliTrace，VS 将在某些点捕获应用程序的状态，包括引发异常时，您可以返回并检查以前的状态。最简单的方法是查看诊断工具窗口的&quot;事件&quot;选项卡。在事件选项卡中，您将看到每个异常的事件。在此异步示例中，每个异步方法都有相应的引发和捕获的异常事件。如果您单击其中任何一个，IntelliTrace 会将调试器带回该时间点，您可以使用监视窗口检查状态。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/270073/202007/270073-20200708004935368-1401950357.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　除了大多数例外情况外，您可能想要转到第一个实例，因为那是它第一次引发的地方。值得一提的是，并不是所有的状态都针对每个异常被捕获，诸如局部变量和参数之类。如果要在监视窗口中输入新表达式，它可能不会计算。如果要捕获应用程序的所有状态，应启用 IntelliTrace 快照功能。您可以通过访问 Tools Options -&amp;gt; IntelliTrace 并启用&quot;IntelliTrace snapshots（&lt;span&gt;managed and native&lt;/span&gt;）&quot;来执行此操作，如下所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/270073/202007/270073-20200708005037232-1914452493.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　使用 IntelliTrace 快照捕获应用程序的整个状态，您可以通过局部变量和监视窗口检查应用程序中的任何内容。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;　　&lt;a href=&quot;https://devblogs.microsoft.com/visualstudio/exception-helper-rethrown-exceptions/&quot; target=&quot;_blank&quot;&gt;https://devblogs.microsoft.com/visualstudio/exception-helper-rethrown-exceptions/&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 07 Jul 2020 16:57:00 +0000</pubDate>
<dc:creator>MeteorSeed</dc:creator>
<og:description>是否曾经在异步编程时引发过异常？因为调试器没有显示异常发生的位置而感到沮丧？或者在查看具有内部异常的异常时感到沮丧？调试器不容易显示该异常来自何处。从 Visual Studio 2019 16.5</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/MeteorSeed/p/13264474.html</dc:identifier>
</item>
</channel>
</rss>