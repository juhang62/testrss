<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>工作不到一年，做出了100k系统，老板给我升职加薪 - 龙跃十二</title>
<link>http://www.cnblogs.com/zhonglongbo/p/13587718.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhonglongbo/p/13587718.html</guid>
<description>&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看了下自己上一次发技术文还是在6月15日，算了算也是两个来月了。别怕，短暂的离开，是为了更好的相遇。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;来到新公司以后啊，发现公司的搜索业务是真的太多了，大大小小有几百个搜索业务。来了之后得先梳理、熟悉业务，才能有所产出嘛。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，在工作了大概一个月的时候，优秀的龙叔发现，这组内的系统优化空间很大啊，简直可以说巨大啊。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以说，即便是完善的大公司，机会也是有的，大家在自己的工作岗位上也要好好把握机会。在公司想要得到好的提升，主要有三方面可以发力：&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;第一、直接业务价值显著，比如具体的PV、UV值提升了多少个点；&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;第二、系统架构迭代升级或者重构，间接带来了用户体验、或者业务价值；&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;第三、技术突破，在某个领域方向上做到技术突破或者创新；&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小伙伴们，升职加薪指日可待啊...&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些系统都是历史包袱沉重啊，是不是感觉&lt;strong&gt;历史包袱&lt;/strong&gt;这个词很熟悉，对于去搞一些历史包袱很沉重的工程，我们惯用的方法是是什么呢？当然是直接&lt;strong&gt;重构&lt;/strong&gt;他&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这对于工作不满一年的龙叔来说还是蛮有挑战的，但咱不怕，去做更具挑战性的事，才能更好的锻炼我们的能力，才会意义非凡。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;反复思考，反复琢磨了几天后，向leader提出了系统重构的大致方案。一般在公司你想做什么都可以和leader提出来，互联网公司还是比较open的，但是leader会不会采纳你的方案就不一定了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，龙叔对于自己已经画了很多方案图，调查很多业务场景、做了很多讨论之后做的方案还是蛮有信心的。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1gi7xzg7droj31la0s0qb9.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;做就做好准备，不然就是浪费机会。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，接下来就不废话了，从几个方面说说这次系统设计：&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1ghva1ecihdj30rq0kuab3.jpg&quot; alt=&quot;&quot;/&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;背景介绍&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家都知道龙叔是做搜索的，所以这次的系统肯定是和搜索相关的，先和大家唠唠搜索整体链路，搜索链路主要分这几个部分，给大家画个图。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1ghvb2pqfh1j30ok150ju8.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;搜索引擎链路都包含这三部分，数据源、搜索引擎服务、搜索业务。是不是很简单，感觉搜索也没那么难。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;搜索链路确实都包括这三部分，但没我说的那么简单，每两个部分之间链路很长，业务非常复杂。举例说下数据源到搜索引擎服务的链路。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先数据源不是单一数据源、比如说个电商场景的数据源，主要有商家商品数据、用户数据、爬虫数据等多种数据源。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我这次要做的链路是从数据源到搜索引擎服务这一段，简单点就是数据源提供的数据，需要结构化之后入到搜索引擎，这样搜索引擎才能提供搜索服务。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可这数据源真的是五花八门，提供数据的方式也是五花八门的。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;设计步骤&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;背景基本就介绍到这里了，接下来就说说设计一个系统的步骤。说实话，毕竟是第一次做系统设计，当时真的是无从下手。不过帅气的龙su有法宝啊，多请教，多思考，多查资料。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在方案评审之前我已经做了很多方案设计图，这部分的努力主要是为了通过方案评审，这非常重要，通不过评审，老板不会让你做，就没有资源可以用，这项目就搁浅了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这部分主要从以下几个步骤发力：&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;旧系统摸底&lt;/strong&gt;。找出旧系统的所有不支持当前业务场景的点，有哪些是对当前业务影响较大的，哪些是对未来业务影响较大的，这些都要细细整理出来。不过这块我做起来还算轻松，旧系统在设计架构上就被我找到很多问题。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可能真的是由于历史原因吧，以前搜索是一个BU，现在只是大数据里的一个组了，这中间经历了多少改朝换代啊，历史包袱重的无法背负了，只能选择抛弃他了。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1gi8prvvqbxj30oc0v6myq.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面的架构图可以很清晰的看出来这个系统有三个严重问题：&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一个、业务层数据到达队列完全依赖于业务方上报。这本来是件无可厚非的事，你要用搜索引擎，那就得上报数据来。就好比你用数据库，你总得把数据存进去吧。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但这事在公司行不通，历史包袱太沉重。业务方完全不想上报数据，虽然勉强上报，经常增量数据丢失。这一丢失数据导致搜索出不来。最终还是咱的锅，这...&lt;/p&gt;
&lt;img src=&quot;https://i02piccdn.sogoucdn.com/591f63c264123b35&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总结下，就是业务方不想上报数据、上报数据总是丢失，锅还得搜索来背。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二个、数据处理完成直接交付给数据应用，这个问题蛮严重的。数据处理其实意味着会消耗大量的计算资源和时间，而一旦数据应用层服务挂掉或者崩溃，将会导致服务短时间无法恢复。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如1000w的数据处理需要一个24core机器处理12小时，一旦下游的solr或者RS集群崩溃，把一份全量数据恢复回来，需要数据处理系统重新计算12小时，这恢复时间谁顶的住啊？&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1gi94h6btbmj30730733yi.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于第一个问题存在，也就是数据上报容易丢失，所以必须依靠全量数据来恢复丢失的增量，我们的近200个业务基本每天都会做一次全量，这可是大把的计算资源浪费啊。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;资源浪费一点倒也还好，但是这异常情况下的数据恢复时间确实是个大问题，用户可等不及这么长时间啊。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总结下，就是计算资源浪费，数据应用层服务无法做到无状态，恢复成本高昂。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第三个、数据处理系统耦合度太高，系统太复杂，维护困难。数据处理一般包括数据清洗和业务组装，数据清洗可以算作是业务变化较少的，但是业务组装规则是灵活多变的，这部分经常会由于业务方的变动而产生开发的需求。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;业务变动频繁、业务繁多导致系统变得复杂，系统复杂耦合度还很高，导致这个系统维护和开发成本很大，日常需求开发已经成为难题了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;业务场景调查&lt;/strong&gt;。搜索有很多场景，比如电商场景，内容场景，直播场景。场景很多，公司业务形态上也是都有这些，但不是所有的场景都使用了我们的搜索服务。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要去摸底一下那些没有使用的为啥没用，没用肯定是我们做的不好，摸底的主要目标的就是搞清楚到底哪点不好。深入到业务上去了解，才能更好的设计系统。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;新系统设计&lt;/strong&gt;。前两步骤已经找到了旧系统缺陷和业务问题，新的系统首先要解决之前的问题，其次就是做一些前瞻性的设计。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;新系统设计这块包括以下几个步骤：&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;业务梳理&lt;/strong&gt; 这块其实在旧系统摸底和业务调查的时候已经做的差不多了，只需要在精细化的梳理下。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;业务抽象&lt;/strong&gt; 业务抽象指的是一系列的业务问题，抽象为一种通用的解决方案。这块蛮复杂的，在这块需要花费大量时间。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;技术调研&lt;/strong&gt; 每一种技术都有他的适用场景。举个例子，使用搜索引擎，到底是用solr还是用es、还是自研呢？这就需要你对技术方案有了解，知道这些技术方案的优缺点，最终才能找出适合业务发展的技术方案。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;方案探讨&lt;/strong&gt; 好的设计不是一蹴而就的，也不是某个人的智慧象征。好的设计是一群人智慧的结晶，是一个不断迭代的产品，所以需要多讨论。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;方案确定&lt;/strong&gt; 前面的问题解决了，基本方案差不多也该定下来了。为保证方案不会出现返工情况，你需要再拉上leader开个最终的项目方案评审会加上确定项目排期。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;架构图介绍&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说了那么多好像还没说到我的设计到底在哪里，接下里就来说说我的设计。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在整个设计中我也做了好几版的设计图，草稿就不放出来了，直接放最终的一版设计方案来说，中间解释的时候会说那些演进的点。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先我设计这个系统目标有如下：&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;&lt;strong&gt;零上报&lt;/strong&gt; 指的是数据不依赖业务方上报，有数据变更立刻感知到&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;&lt;strong&gt;准实时&lt;/strong&gt; 数据变更之后实时进入引擎，提供搜索服务&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;&lt;strong&gt;高吞吐&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;&lt;strong&gt;高容错&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;&lt;strong&gt;低耦合&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;&lt;strong&gt;易维护&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这几个目标已经完全解决了之前系统存在的问题，比如上报数据问题，资源浪费问题，紧急恢复时间长的问题。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1gi8wjg3dhkj30u01cc799.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整体上我采用了分层设计方案结合微服务的思想，把复杂的问题分层抽象，各层次之间功能单一且分明，耦合度低，维护方便。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然这样的设计会导致数据链路变得略长，会有多余的网络传输延时。现在的网卡已经够大了，网络传输在这个项目中不是不足为虑。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;自上而下，沿着数据流动的方向，逐层解释下为何这么设计：&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一层，业务数据层，这是不变的，一致存在的。目前我们共有快200个业务场景，每个业务方的数据源是不同的，同时也有交叉的，比如商品数据在类目搜索、内容搜索、订单搜索、商品推荐上都使用，他们确是不同的业务场景，数据有交叉也有不同。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但其实这里我们不必太关心业务方的数据来源，不管是何种来源最终都会有一个存储介质，只需要关心数据实际存储在哪里的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;把多种存储介质抽象出来，用一个服务去监听这些介质的数据变更行为，这就是接下来的数据监听层。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二层，数据监听层。主要负责监听变更的业务数据，把变更的数据获取到，用规定的格式输出到下游队列即可。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第三层，数据缓冲层。数据缓冲一般用在系统与系统之间，通常情况下不要让系统与系统之间直接传递数据，这样的数据传递会有很高的风险，得依赖接收端系统的稳定性。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了数据缓冲，系统之间就不直接交互数据了，系统之间没什么依赖关系，也不会互相影响。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第四层，数据处理层。这一层最终需要把零散的、不规则的数据处理为一个搜索可用的DOC数据。这块任务蛮艰巨的，当时在讨论这一层的时候，花费了很多时间。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据处理包括两部分，一部分是一些通用型处理，比如去html标签、数据格式int转string等等处理逻辑；另一部分是一些变化较多的业务部分，比如一个doc有十五个字段，其中有三个来自A业务，三个来自B业务，而这些来自都是需要实时去业务方拿结果的。再比如对DOC中的字段会进行一些计算操作，具体计算规则根据业务而定的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些操作都很依赖于业务方，变化之多，很难把控。所以这块在设计上需要很灵活。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据抽取出的这两部分特性，把&lt;strong&gt;不变的通用性较强的&lt;/strong&gt;那部分定义为数据清理，用一个单独服务处理，这里采用spark stream流去实时做数据清洗，处理完成之后输出到kafka队列。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;灵活变化的部分用一个单独服务处理，业务变更采用脚本方式动态发布，修改灵活、即时生效。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第五层，数据存储层。故名思义就是做一个存储，前面已经计算好了一个完整的DOC数据。整个计算过程已经耗费了计算资源和时间，所以必须存储起来。一旦数据应用层服务数据异常，可以很及时用这里的数据做恢复。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不需要计算，直接拿过去用，恢复起来成本够低了吧。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了存储层，既可以保证下游服务可以完全无状态，还可以保证快速恢复，同时还可以用作全量数据。龙su简直是个设计天才，前途无量啊....&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1gi988505u1g30710714qp.gif&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一边写到存储层，也会一边写到kafka队列，数据应用层需要获取kakka队列数据做增量索引。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整个分层的设计架构就是这样了，中间的业务细节就不一一讲解了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;懂搜索的朋友肯定会说了，这里的整个系统说的都是增量，那全量怎么更新。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就到点上了，全量我采用了主动触发的方式，可以想一想那些场景需要做一次全量。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一、业务发生了字段级别的变更，比如增加了一个字段，或者某个字段的全部值发生了变化。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二、第一次接进来的业务，但已经有很大一部分原始数据。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第三、有大批增量丢失，导致无法通过容错机制恢复，而且不是很确定丢失那些增量。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第四、存储层有脏数据。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第五、数据应用层有脏数据或者异常了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;两种方式做全量，一种是需要计算的，通过增量链路计算做一份全量。另一种是直接通过hbase全量数据来做全量。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;hbase有脏数据的情况下只能重新计算，或者清理脏数据。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;架构设计注意点&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整体的系统架构主要由我完成，系统开发那可是集结了全组的功力。总共用时一个Q出了第一版，目前线上已经跑了好几个业务，最高qps能达到100k，截了一个线上运行的7天业务指标图。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1gi8yqhkzx2j31rx0u0zna.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说下一些注意点，希望对大家有用。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;设计前&lt;/strong&gt;&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;对业务一定要非常熟悉，这样设计出的系统才能更好的服务业务&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;多做技术方案调查，只有见的多了你才会思考的多了，思考的多了才会有所见解&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;多沟通，很多问题自己一个人想着可能很完美，但很可能这时你钻到思维的牛角尖了，沟通能减少这样的错误&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;设计中&lt;/strong&gt;&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;多画架构图，画出来便于你更多的思考，图画更具有渲染和说服力，图片的表达能力比文字强&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;细节地方一定要画流程图，流程图画得好写代码才能轻松&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;多做项目评审会，项目评审就是一个产品迭代，只是还没做出产品就已经有迭代了&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;更多的倾听业务，系统设计是为了解决业务问题，是为业务服务的。你的系统可以不是完美的，但对于业务和用户一定是价值最大的&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;开发中&lt;/strong&gt;&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;线上系统异常处理要完善&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;测试要完善，功能测试、性能测试都得做&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;系统监控一定要完善，这个非常重要，没有监控和日志，出了问题就是两眼一抹黑&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;项目排期一定要做好，一般项目开发都是多人协同开发，不能影响整体排期&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;有风险及时暴露，这点很重要，很多人在项目中遇到问题或者风险点不敢暴露出来，害怕暴漏出来大家怀疑自己的能力，老板会给低绩效等。想着自己能很快解决，一般遇到风险都很难自己独自解决，不然也不会构成风险。暴露出来，大家群策群力，也不会拖延到项目排期。&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;上线后&lt;/strong&gt;&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;及时关注自己的服务监控指标，一般上线前都会经过测试、压测等，很多人就上线关注一会觉得没问题，就去庆功去了，别把庆功酒喝错了味道。业务是实时变化的，你要根据业务变化确定你的观察时机，正确观察几个周期无误后，才可以确定无误，以防年终奖没了。敏感业务都必须灰度很长时间做观测。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;听取反馈意见，收集反馈意见及时迭代自己的产品。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;挖掘潜在业务需求，提前布局迭代。&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;总结&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;龙su是第一次做系统性设计，两个重要的点给大家说说&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一、想清楚在做，想清楚就是指前期需要花费大量的时间去做系统架构调研、讨论，细节构思清楚。我的这个系统设计花在调研、探讨、设计上的时间占据总时间的五分之二。构思和测试的时间是最长的，开发的时间是最短的。前期想的越清楚，开发难度越小。更有甚者，开发到中途发现设计不通，再开始返工。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二、小步快跑，试错迭代，借用Pony老师的总结。现在互联网公司的项目都是要求很快速上线的，所以在开发上我们需要快速出产品，然后再不断迭代。不能一开始就做一个完美产品，这样用户是等不住的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事实上不存在一开始做出来就是完美的产品，只有手机大量用户意见，不断迭代、不断改进、不断创新的产品才有可能是好产品。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我是龙su，一个在互联网大器晚成的帅叔叔，我们下期见。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1gev88f8kfvj30p00dw0tn.jpg&quot; alt=&quot;&quot;/&gt;</description>
<pubDate>Mon, 31 Aug 2020 00:38:00 +0000</pubDate>
<dc:creator>龙跃十二</dc:creator>
<og:description>100系统设计方法总计</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhonglongbo/p/13587718.html</dc:identifier>
</item>
<item>
<title>Struts+Servlet+JDBC网上手机销售系统 - 一点教程网</title>
<link>http://www.cnblogs.com/yiidian/p/13587717.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yiidian/p/13587717.html</guid>
<description>&lt;h2 id=&quot;项目描述&quot;&gt;项目描述&lt;/h2&gt;
&lt;p&gt;Hi，大家好，今天给大家分享一个《网上手机销售系统》。本系统一共分为前台和后台两大模块，两个模块之间虽然在表面上是相互独立的，但是在对数据库的访问上是紧密相连的，各个模块访问的是同一个数据库，只是所访问的表不同而已。本项目用于毕设项目非常不错哦。&lt;/p&gt;
&lt;h3 id=&quot;1．前台系统功能模块&quot;&gt;1．前台系统功能模块&lt;/h3&gt;
&lt;p&gt;商品展台模块：通过新品上架，分页显示特价商品，商品销售排行展示网站的所有商品；&lt;br/&gt;商品查询模块：按商品的类别查询商品的相关信息；&lt;br/&gt;购物车模块：用户添加商品至购物车，查看购物车中的商品，从购物车中移除不满意的商品，清空购物车中的产品，修改所要购买的商品的数量；&lt;br/&gt;收银台模块：用户满意购物车中的产品后进行结账并填写订单信息；&lt;br/&gt;用户维护模块：为用户提供了用户注册、用户登录、用户资料修改以及找回密码的功能；&lt;br/&gt;订单查询模块：用户通过查看订单能够了解到自己的当前订单信息及历史订单记录；&lt;br/&gt;公告浏览模块：用户通过浏览公告信息，能够及时了解到网站最新的各种信息。&lt;br/&gt;留言模块：客户可以进行留言给我们提意见，我们在不断地改进中前进。&lt;/p&gt;
&lt;h3 id=&quot;2．后台系统功能模块&quot;&gt;2．后台系统功能模块&lt;/h3&gt;
&lt;p&gt;商品管理模块：按类别查看商品，对商品的信息进行维护；&lt;br/&gt;用户管理模块：为了保护用户的信息，此模块与前台用户维护的区别是管理员只能查看用户信息和删除操作；&lt;br/&gt;管理员维护模块：这是对管理员的信息进行维护，可以修改管理员的信息。&lt;br/&gt;订单管理模块：管理员查询订单，查看订单详细信息，删除订单信息，进行订单受理；&lt;br/&gt;公告管理模块：管理员公告浏览，公告信息维护；&lt;br/&gt;留言模块：管理员可以查看客户的留言，对留言进行维护。&lt;/p&gt;
&lt;h2 id=&quot;技术栈&quot;&gt;技术栈&lt;/h2&gt;
&lt;p&gt;Struts + Servlet + JDBC&lt;/p&gt;
&lt;h2 id=&quot;运行环境&quot;&gt;运行环境&lt;/h2&gt;
&lt;p&gt;Eclipse + Tomcat6以上&lt;/p&gt;
&lt;h2 id=&quot;项目截图&quot;&gt;项目截图&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1516040/202008/1516040-20200831083639059-1992154388.png&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1516040/202008/1516040-20200831083639462-1223435026.jpg&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1516040/202008/1516040-20200831083639902-796824299.jpg&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1516040/202008/1516040-20200831083640238-47607162.jpg&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1516040/202008/1516040-20200831083640498-793009890.jpg&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1516040/202008/1516040-20200831083640802-759834469.jpg&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1516040/202008/1516040-20200831083641103-856576374.jpg&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1516040/202008/1516040-20200831083641442-1664780389.jpg&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1516040/202008/1516040-20200831083641833-551305594.jpg&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1516040/202008/1516040-20200831083642133-1739964813.jpg&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1516040/202008/1516040-20200831083642486-903603885.jpg&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;下载方式&quot;&gt;下载方式&lt;/h2&gt;
&lt;p&gt;先点在看，再取源码哦，关注「一点教程」公众号，回复关键词 「xz202007」 就可以获得下载链接和提取码。如部署过程有问题，后台回复「加我」添加小助手微信。特别提醒:为了防止恶意获取，如果取消关注本公众号，即使再次关注，也将无法提供本服务！&lt;/p&gt;
&lt;blockquote readability=&quot;5.6507936507937&quot;&gt;
&lt;p&gt;欢迎关注我的公众号：：一点教程。获得独家整理的学习资源和日常干货推送。&lt;br/&gt;如果您对我的系列教程感兴趣，也可以关注我的网站：&lt;a href=&quot;http://www.yiidian.com&quot;&gt;yiidian.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 31 Aug 2020 00:37:00 +0000</pubDate>
<dc:creator>一点教程网</dc:creator>
<og:description>项目描述 Hi，大家好，今天给大家分享一个《网上手机销售系统》。本系统一共分为前台和后台两大模块，两个模块之间虽然在表面上是相互独立的，但是在对数据库的访问上是紧密相连的，各个模块访问的是同一个数据库</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yiidian/p/13587717.html</dc:identifier>
</item>
<item>
<title>[C#.NET 拾遗补漏]08：强大的LINQ - 精致码农</title>
<link>http://www.cnblogs.com/willick/p/13586024.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/willick/p/13586024.html</guid>
<description>&lt;p&gt;大家好，这是 [C#.NET 拾遗补漏] 系列的第 08 篇文章，今天讲 C# 强大的 LINQ 查询。LINQ 是我最喜欢的 C# 语言特性之一。&lt;/p&gt;
&lt;p&gt;LINQ 是 &lt;strong&gt;L&lt;/strong&gt;anguage &lt;strong&gt;IN&lt;/strong&gt;tegrated &lt;strong&gt;Q&lt;/strong&gt;uery 单词的首字母缩写，翻译过来是&lt;strong&gt;语言集成查询&lt;/strong&gt;。它为查询跨各种数据源和格式的数据提供了一致的模型，所以叫&lt;strong&gt;集成查询&lt;/strong&gt;。由于这种查询并没有制造新的语言而只是在现有的语言基础上来实现，所以叫&lt;strong&gt;语言集成查询&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;一些基础&quot;&gt;一些基础&lt;/h2&gt;
&lt;p&gt;在 C# 中，从功能上 LINQ 可分为两类：LINQ to Object 和 LINQ to XML；从语法上 LINQ 可以分为 LINQ to Object 和 LINQ 扩展方法。大多数 LINQ to Object 都可以用 LINQ 扩展方法实现等同的效果，而且平时开发中用的最多的是 LINQ 扩展方法。&lt;/p&gt;
&lt;p&gt;LINQ to Object 多用于映射数据库的查询，LINQ to XML 用于查询 XML 元素数据。使用 LINQ 查询的前提是对象必须是一个 IEnumerable 集合（注意，为了描述方便，本文说的集合都是指 IEnumerable 对象，包含字面上的 ICollection 对象）。另外，LINQ 查询大多是都是链式查询，即操作的数据源是 &lt;code&gt;IEnumerable&amp;lt;T1&amp;gt;&lt;/code&gt; 类型，返回的是 &lt;code&gt;IEnumerable&amp;lt;T2&amp;gt;&lt;/code&gt; 类型。&lt;/p&gt;
&lt;p&gt;形如下面这样的查询就是 LINQ to Object：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;var list = from user in users
  where user.Name.Contains(&quot;Wang&quot;)
  select user.Id;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;等同于使用下面的 LINQ 扩展方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;var list = users
  .Where(u =&amp;gt; user.Name.Contains(&quot;Wang&quot;))
  .Select(u =&amp;gt; u.id);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;LINQ 查询支持在语句中间根据需要定义变量，比如取出数组中平方值大于平均值的数字：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;int[] numbers = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
var result = from number in numbers
            let average = numbers.Average()
            let squared = Math.Pow(number, 2)
            where squared &amp;gt; average
            select number;
// 平均值为 4.5, result 为 { 3, 4, 5, 6, 7, 8, 9 }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中的 Select 方法接收的参数用的最多的是 &lt;code&gt;Func&amp;lt;TSource, TResult&amp;gt;&lt;/code&gt;，它还可以接收 &lt;code&gt;Func&amp;lt;TSource, int, TResult&amp;gt;&lt;/code&gt; 参数，示例:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;var collectionWithRowNumber = collection.
    .Select((item, index) =&amp;gt; new { Item = item, RowNumber =index })
    .ToList();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再来看一下 LINQ to XML 的示例。假如我们有如下 XML 文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&amp;gt;
&amp;lt;Employees&amp;gt;
  &amp;lt;Employee&amp;gt;
    &amp;lt;EmpId&amp;gt;1&amp;lt;/EmpId&amp;gt;
    &amp;lt;Name&amp;gt;Liam&amp;lt;/Name&amp;gt;
    &amp;lt;Sex&amp;gt;男&amp;lt;/Sex&amp;gt;
  &amp;lt;/Employee&amp;gt;
  &amp;lt;Employee&amp;gt;
    &amp;lt;EmpId&amp;gt;2&amp;lt;/EmpId&amp;gt;
    ...
  &amp;lt;/Employee&amp;gt;
&amp;lt;/Employees&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用 LINQ to XML 查询所有含有指定节点值的元素：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;XElement xelement = XElement.Load(&quot;Employees.xml&quot;);
var els = from el in xelement.Elements(&quot;Employee&quot;)
          where (string)el.Element(&quot;Sex&quot;) == &quot;Male&quot;
          select el;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;等同于使用 LINQ 扩展方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;var els = xelement.Elements(&quot;Employee&quot;)
    .Where(el =&amp;gt; (string)el.Element(&quot;Sex&quot;) == &quot;Male&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;LINQ to XML 操作 XML 非常方便和灵活，大家可以在具体使用的时候去探索，这里就不展开讲了。&lt;/p&gt;
&lt;p&gt;LINQ 查询有很多方法，由于篇幅原因，就不一一列举演示了，这里只选取一些强大的查询方法，这些方法若使用非 LINQ 来实现可能会比较麻烦。&lt;/p&gt;
&lt;p&gt;LINQ 之所以强大，是因为它可以轻松实现复杂的查询，下面我们来总结一下 C# LINQ 的强大之处。&lt;/p&gt;
&lt;h2 id=&quot;fist、last-和-single-等&quot;&gt;Fist、Last 和 Single 等&lt;/h2&gt;
&lt;p&gt;First、FirstOrDefault、Last、LastOrDefault、Single 和 SingleOrDefault 是快速查询集合中的第一个或最后一个元素的方法。如果集合是空的，Fist、Last 和 Single 都会报错，如果使其不报错而在空集合时使用默认值可以使用 FirstOrDefault、LastOrDefault 和 SingleOrDefault。Single/SingleOrDefault 和其它方法的区别是，它限定查询结果只有一个元素，如果查询结果集合中包含多个元素时会报错。具体看下面几个示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;new[] { &quot;a&quot;, &quot;b&quot; }.First(x =&amp;gt; x.Equals(&quot;b&quot;)); // 返回 ”b“
new[] { &quot;a&quot;, &quot;b&quot; }.First(x =&amp;gt; x.Equals(&quot;c&quot;)); // 抛出 InvalidOperationException 异常
new[] { &quot;a&quot;, &quot;b&quot; }.FirstOrDefault(x =&amp;gt; x.Equals(&quot;c&quot;)); // 返回 null

new[] { &quot;a&quot;, &quot;b&quot; }.Single(x =&amp;gt; x.Equals(&quot;b&quot;)); // 返回 ”b“
new[] { &quot;a&quot;, &quot;b&quot; }.Single(x =&amp;gt; x.Equals(&quot;c&quot;)); // 抛出 InvalidOperationException 异常
new[] { &quot;a&quot;, &quot;b&quot; }.SingleOrDefault(x =&amp;gt; x.Equals(&quot;c&quot;)); // 返回 null
new[] { &quot;a&quot;, &quot;a&quot; }.Single(); // 抛出 InvalidOperationException 异常
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在实际应用中，如果要确保查询结果的唯一性（比如通过手机号查询用户），使用 Single/SingleOrDefaut，其它情况应尽量使用 First/FirstOrDefault。虽然 FirstOrDefault 也可以根据条件判断元素是否存在，但使用 Any 更高效。&lt;/p&gt;
&lt;h2 id=&quot;except-取差集&quot;&gt;Except 取差集&lt;/h2&gt;
&lt;p&gt;LINQ 的 Except 方法用来取差集，即取出集合中与另一个集合所有元素不同的元素。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;int[] first = { 1, 2, 3, 4 };
int[] second = { 0, 2, 3, 5 };
IEnumerable&amp;lt;int&amp;gt; result = first.Except(second);
// result = { 1, 4 }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意 Except 方法会去除重复元素：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;int[] second = { 0, 2, 3, 5 };
int[] third = { 1, 1, 1, 2, 3, 4 };
IEnumerable&amp;lt;int&amp;gt; result = third.Except(second);
// result = { 1, 4 }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于简单类型（int、float、string 等）使用 Except 很简单，但对于自定义类型（或者叫复合类型，下同）的 Object 如何使用 Except 呢？此时需要将自定义类型实现&lt;code&gt;IEquatable&amp;lt;T&amp;gt;&lt;/code&gt;接口，示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;class User : IEquatable&amp;lt;User&amp;gt;
{
    public string Name { get; set; }

    public bool Equals(User other)
    {
        return Name == other.Name;
    }

    public override int GetHashCode()
    {
        return Name?.GetHashCode() ?? 0;
    }
}

class Program
{
    static void Main(string[] args)
    {
        var list1 = new List&amp;lt;User&amp;gt;
        {
            new User{ Name = &quot;User1&quot;},
            new User{ Name = &quot;User2&quot;},
        };

        var list2 = new List&amp;lt;User&amp;gt;
        {
            new User{ Name = &quot;User2&quot;},
            new User{ Name = &quot;User3&quot;},
        };

        var result = list1.Except(list2);
        result.ForEach(u =&amp;gt; Console.WriteLine(u.Name));
        // 输出：User1
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;selectmany-集合降维&quot;&gt;SelectMany 集合降维&lt;/h2&gt;
&lt;p&gt;SelectMany 可以把多维集合降维，比如把二维的集合平铺成一个一维的集合。举例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;var collection = new int[][]
{
    new int[] {1, 2, 3},
    new int[] {4, 5, 6},
};
var result = collection.SelectMany(x =&amp;gt; x);
// result = [1, 2, 3, 4, 5, 6]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再来举个更贴合实际应用的例子。例如有如下实体类（一个部门有多个员工）：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;class Department
{
    public Employee[] Employees { get; set; }
}

class Employee
{
    public string Name { get; set; }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时，我们拥有一个这样的数据集合：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;var departments = new[]
{
    new Department()
    {
        Employees = new []
        {
            new Employee { Name = &quot;Bob&quot; },
            new Employee { Name = &quot;Jack&quot; }
        }
    },
    new Department()
    {
        Employees = new []
        {
            new Employee { Name = &quot;Jim&quot; },
            new Employee { Name = &quot;John&quot; }
        }
    }
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在我们可以使用 SelectMany 把各部门的员工查询到一个结果集中：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;var allEmployees = departments.SelectMany(x =&amp;gt; x.Employees);
foreach(var emp in allEmployees)
{
    Console.WriteLine(emp.Name);
}
// 依次输出：Bob Jack Jim John
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;selectmany-迪卡尔积运算&quot;&gt;SelectMany 迪卡尔积运算&lt;/h2&gt;
&lt;p&gt;SelectMany 不光适用于单个包含多维集合对象的降维，也适用于多个集合之前的两两相互操作，比如进行迪卡尔积运算。比如我们有这样两个集合：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;var list1 = new List&amp;lt;string&amp;gt; { &quot;a1&quot;, &quot;a2&quot; };
var list2 = new List&amp;lt;string&amp;gt; { &quot;b1&quot;, &quot;b2&quot;, &quot;b3&quot; };
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在我们需要把它进行两两组合，使用普通的方法，我们需要用嵌套循环语句来实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;var result = newList&amp;lt;string&amp;gt;();
foreach (var s1 in list1)
    foreach (var s2 in list2)
        result.Add($&quot;{s1}{s2}&quot;);
// result = [&quot;a1b1&quot;, &quot;a1b2&quot;, &quot;a1b3&quot;, &quot;a2b1&quot;, &quot;a2b2&quot;, &quot;a2b3&quot;]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;改用 SelectMany 实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;var result = list1.SelectMany(x =&amp;gt; list2.Select(y =&amp;gt; $&quot;{x}{y}&quot;));
// result = [&quot;a1b1&quot;, &quot;a1b2&quot;, &quot;a1b3&quot;, &quot;a2b1&quot;, &quot;a2b2&quot;, &quot;a2b3&quot;]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具有挑战性的问题来了，如何对 N 个集合进行迪卡尔积运算呢，比如有这样的集合数据：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;var arrList = new List&amp;lt;string[]&amp;gt;
{
    new string[] { &quot;a1&quot;, &quot;a2&quot; },
    new string[] { &quot;b1&quot;, &quot;b2&quot;, &quot;b3&quot; },
    new string[] { &quot;c1&quot; },
    // ...
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如何对上面的 arrList 中的各个集合进行两两组合呢？在电商业务尤其是零售业务中的产品组合促销中这种需求很常见。&lt;/p&gt;
&lt;p&gt;下面是一个使用 SelectMany 的实现，需要用到递归：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;class Program
{
    static void Main(string[] args)
    {
        var arrList = new List&amp;lt;string[]&amp;gt;
        {
            new string[] { &quot;a1&quot;, &quot;a2&quot; },
            new string[] { &quot;b1&quot;, &quot;b2&quot;, &quot;b3&quot; },
            new string[] { &quot;c1&quot; },
            // ...
        };

        var result = Recursion(arrList, 0, new List&amp;lt;string&amp;gt;());
        result.ForEach(x =&amp;gt; Console.WriteLine(x));
    }

    static List&amp;lt;string&amp;gt; Recursion(List&amp;lt;string[]&amp;gt; list, int start, List&amp;lt;string&amp;gt; result)
    {
        if (start &amp;gt;= list.Count)
            return result;

        if (result.Count == 0)
            result = list[start].ToList();
        else
            result = result.SelectMany(x =&amp;gt; list[start].Select(y =&amp;gt; x + y)).ToList();

        result = Recursion(list, start + 1, result);

        return result;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;a1b1c1
a1b2c1
a1b3c1
a2b1c1
a2b2c1
a2b3c1
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;类似这种集合的迪卡尔积运算操作，也可以用 LINQ to Object 来代替 SelectMany 实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;result = result.SelectMany(x =&amp;gt; list[start].Select(y =&amp;gt; x + y)).ToList();
// 等同使用扩展方法：
result = (from a in result from b in list[start] select a + b).ToList();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;LINQ to Object 比扩展方法看上去易读性更好，但写起来扩展方法更方便。&lt;/p&gt;
&lt;h2 id=&quot;aggregate-聚合&quot;&gt;Aggregate 聚合&lt;/h2&gt;
&lt;p&gt;Aggregate 扩展方法可以对一个集合依次执行类似累加器的操作，就像滚雪球一样把数据逐步聚集在一起。比如实现从 1 加到 10，用 Aggregate 扩展方法就很方便：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;int[] numbers = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
int sum = numbers.Aggregate((prevSum, current) =&amp;gt; prevSum + current);
// sum = 55
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们来解析一下它的执行步骤&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一步，prevSum 取第一个元素的值，即 prevSum = 1&lt;/li&gt;
&lt;li&gt;第二步，把第一步得到的 prevSum 的值加上第二个元素，即 prevSum = prevSum + 2&lt;/li&gt;
&lt;li&gt;依此类推，第 i 步把第 i-1 得到的 prevSum 加上第 i 个元素&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;再来看一个字符串的例子加深理解：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;string[] stringList = { &quot;Hello&quot;, &quot;World&quot;, &quot;!&quot; };
string joinedString = stringList.Aggregate((prev, current) =&amp;gt; prev + &quot; &quot; + current);
// joinedString = &quot;Hello World !&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Aggregate 还有一个重载方法，可以指定累加器的初始值。我们来看一个比较综合的复杂例子。假如我们有如下 1-12 的一个数字集合：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-CS&quot;&gt;var items = new List&amp;lt;int&amp;gt; { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 };
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在我们想做如下计算：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;计算集合元素的总数个数&lt;/li&gt;
&lt;li&gt;计算值为偶数的元素个数&lt;/li&gt;
&lt;li&gt;收集每第 4 个元素&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当然通过普通的循环遍历也可以实现这三个计算，但使用 Aggregate 会更简洁，下面是 Aggregate 的实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;var result = items.Aggregate(new { Total = 0, Even = 0, FourthItems = new List&amp;lt;int&amp;gt;() },
    (accum, item) =&amp;gt;
    new
    {
        Total = accum.Total + 1,
        Even = accum.Even + (item % 2 == 0 ? 1 : 0),
        FourthItems = (accum.Total + 1) % 4 == 0 ? new List&amp;lt;int&amp;gt;(accum.FourthItems) { item } : accum.FourthItems
    }
);

// result:
// Total = 12
// Even = 6
// FourthItems = [4, 8, 12]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里为了简单起见使用匿名类型作为累加器的初始值，由于匿名类型的属性是只读的，所以在累加的过程都 new 了一个新对象。如果初始值使用的是自定义类型，那累加时就不需 new 新对象了。&lt;/p&gt;
&lt;h2 id=&quot;jion-关联查询&quot;&gt;Jion 关联查询&lt;/h2&gt;
&lt;p&gt;和 SQL 查询一样，LINQ 同样支持 Inner Join、Left Join、Right Join、Cross Join 和 Full Outer Join，有时候你可能看到不同的写法，其实是同一个意思，比如 Left Outer Join 就是 Left Join，Join 是 Inner Join 省略了 Inner 等。&lt;/p&gt;
&lt;p&gt;假设我们有下面两个集合，分别表示左边的数据和右边的数据。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;var first = new List&amp;lt;string&amp;gt;() { &quot;a&quot;,&quot;b&quot;,&quot;c&quot; }; // 左边
var second = new List&amp;lt;string&amp;gt;() { &quot;a&quot;, &quot;c&quot;, &quot;d&quot; }; // 右边
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面以此数据为例来演示各种关联查询。&lt;/p&gt;
&lt;h3 id=&quot;inner-join&quot;&gt;Inner Join&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt; var result = from f in first
              join s in second on f equals s
              select new { f, s };
// 等同使用扩展方法：
var result = first.Join(second,
    f =&amp;gt; f,
    s =&amp;gt; s,
    (f, s) =&amp;gt; new { f, s });

// result: {&quot;a&quot;,&quot;a&quot;}
//         {&quot;c&quot;,&quot;c&quot;}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;left-join&quot;&gt;Left Join&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;var result = from f in first
            join s in second on f equals s into temp
            from t in temp.DefaultIfEmpty()
            select new { First = f, Second = t };
// 或者：
var result = from f in first
            from s in second.Where(x =&amp;gt; x == f).DefaultIfEmpty()
            select new { First = f, Second = s };

// 等同使用扩展方法：
var result = first.GroupJoin(second,
        f =&amp;gt; f,
        s =&amp;gt; s,
        (f, s) =&amp;gt; new { First = f, Second = s })
    .SelectMany(temp =&amp;gt; temp.Second.DefaultIfEmpty(),
        (f, s) =&amp;gt; new { First = f.First, Second = s });

// result: {&quot;a&quot;,&quot;a&quot;}
//         {&quot;b&quot;, null}
//         {&quot;c&quot;,&quot;c&quot;}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;right-join&quot;&gt;Right Join&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;var result = from s in second
            join f in first on s equals f into temp
            from t in temp.DefaultIfEmpty()
            select new { First = t, Second = s };
// 其它和 Left Join 类似

// result: {&quot;a&quot;,&quot;a&quot;}
//         {&quot;c&quot;,&quot;c&quot;}
//         {null,&quot;d&quot;}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;cross-join&quot;&gt;Cross Join&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;var result = from f in first
            from s in second
            select new { f, s };

// result: {&quot;a&quot;,&quot;a&quot;}
//         {&quot;a&quot;,&quot;c&quot;}
//         {&quot;a&quot;,&quot;d&quot;}
//         {&quot;b&quot;,&quot;a&quot;}
//         {&quot;b&quot;,&quot;c&quot;}
//         {&quot;b&quot;,&quot;d&quot;}
//         {&quot;c&quot;,&quot;a&quot;}
//         {&quot;c&quot;,&quot;c&quot;}
//         {&quot;c&quot;,&quot;d&quot;}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;full-outer-join&quot;&gt;Full Outer Join&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;var leftJoin = from f in first
            join s in second on f equals s into temp
            from t in temp.DefaultIfEmpty()
            select new { First = f, Second = t };
var rightJoin = from s in second
            join f in first on s equals f into temp
            from t in temp.DefaultIfEmpty()
            select new { First = t, Second = s };
var fullOuterJoin = leftJoin.Union(rightJoin);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;根据多个键关联&quot;&gt;根据多个键关联&lt;/h3&gt;
&lt;p&gt;在 SQL 中，表与表进行关联查询时 on 条件可以指定多个键的逻辑判断，用 and 或 or 连接。但 C# 的 LINQ 不支持 and 关键字，若要根据多键关联，需要把要关联的键值分别以相同的属性名放到匿名对象中，然后使用 equals 比较两个匿名对象是否相等。示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;var stringProps = typeof(string).GetProperties();
var builderProps = typeof(StringBuilder).GetProperties();
var query =
    from s in stringProps
    join b in builderProps
    on new { s.Name, s.PropertyType } equals new { b.Name, b.PropertyType }
    select new
    {
        s.Name,
        s.PropertyType
    };
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上均使用两个集合做为示例，LINQ 关联查询也支持多个集合关联，就像 SQL 的多表关联，只需往后继续追加 join 操作即可，不再累述。&lt;/p&gt;
&lt;p&gt;LINQ 关联查与 SQL 相似，但使用上有很大区别。LINQ 关联查询的用法有很多，也很灵活，不用刻意去记住它们，只要熟悉简单常用的，其它的在实际用到的时候再查询相关文档。&lt;/p&gt;
&lt;h2 id=&quot;skip--take-分页&quot;&gt;Skip &amp;amp; Take 分页&lt;/h2&gt;
&lt;p&gt;Skip 扩展方法用来跳过从起始位置开始的指定数量的元素读取集合；Take 扩展方法用来从集合中只读取指定数量的元素。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;var values = new[] { 5, 4, 3, 2, 1 };
var skipTwo = values.Skip(2);  // { 3, 2, 1 }
var takeThree = values.Take(3);  // { 5, 4, 3 }
var skipOneTakeTwo = values.Skip(1).Take(2); // { 4, 3 }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Skip 与 Take 两个方法结合即可实现我们常见的分页查询：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;public IEnumerable&amp;lt;T&amp;gt; GetPage&amp;lt;T&amp;gt;(this IEnumerable&amp;lt;T&amp;gt; collection, int pageNumber, int pageSize)
{
    int startIndex = (pageNumber - 1) * pageSize;
    return collection.Skip(startIndex).Take(pageSize);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用过 EF (Core) 的同学一定很熟悉。&lt;/p&gt;
&lt;p&gt;另外，还有 &lt;strong&gt;SkipWhile&lt;/strong&gt; 和 &lt;strong&gt;TakeWhile&lt;/strong&gt; 扩展方法，它与 Skip 和 Take 不同的是，它们的参数是具体的条件。SkipWhile 从起始位置开始忽略元素，直到匹配到符合条件的元素停止忽略，往后就是要查询的结果；TakeWhile 从起始位置开始读取符合条件的元素，一旦遇到不符合条件的就停止读取，即使后面还有符合条件的也不再读取。示例：&lt;/p&gt;
&lt;p&gt;SkipWhile：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;int[] list = { 42, 42, 6, 6, 6, 42 };
var result = list.SkipWhile(i =&amp;gt; i == 42);
// result: 6, 6, 6, 42
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;TakeWhile：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;int[] list = { 1, 10, 40, 50, 44, 70, 4 };
var result = list.TakeWhile(item =&amp;gt; item &amp;lt; 50).ToList();
// result = { 1, 10, 40 }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;zip-拉链&quot;&gt;Zip 拉链&lt;/h2&gt;
&lt;p&gt;Zip 扩展方法操作的对象是两个集合，它就像拉链一样，根据位置将两个系列中的每个元素依次配对在一起。其接收的参数是一个 Func 实例，该 Func 实例允许我们成对在处理两个集合中的元素。如果两个集合中的元素个数不相等，那么多出来的将会被忽略。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;int[] numbers = { 3, 5, 7 };
string[] words = { &quot;three&quot;, &quot;five&quot;, &quot;seven&quot;, &quot;ignored&quot; };
IEnumerable&amp;lt;string&amp;gt; zip = numbers.Zip(words, (n, w) =&amp;gt; n + &quot;=&quot; + w);

foreach (string s in zip)
{
    Console.WriteLine(s);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;3=three
5=five
7=seven
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;oftype-和-cast-类型过滤与转换&quot;&gt;OfType 和 Cast 类型过滤与转换&lt;/h2&gt;
&lt;p&gt;OfType 用于筛选集合中指定类型的元素，Cast 可以把集合转换为指定类型，但要求源类型必须可以隐式转换为目标类型。假如有如下数据：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;interface IFoo { }
class Foo : IFoo { }
class Bar : IFoo { }

var item0 = new Foo();
var item1 = new Foo();
var item2 = new Bar();
var item3 = new Bar();
var collection = new IFoo[] { item0, item1, item2, item3 };
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;OfType 示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;var foos = collection.OfType&amp;lt;Foo&amp;gt;(); // result: item0, item1
var bars = collection.OfType&amp;lt;Bar&amp;gt;(); // result: item2, item3
var foosAndBars = collection.OfType&amp;lt;IFoo&amp;gt;(); // result: item0, item1, item2, item3

// 等同于使用 Where
var foos = collection.Where(item =&amp;gt; item is Foo); // result: item0, item1
var bars = collection.Where(item =&amp;gt; item is Bar); // result: item2, item3
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Cast 示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;var bars = collection.Cast&amp;lt;Bar&amp;gt;();  // InvalidCastException 异常
var foos = collection.Cast&amp;lt;Foo&amp;gt;();  // InvalidCastException 异常
var foosAndBars = collection.Cast&amp;lt;IFoo&amp;gt;();  // OK
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;tolookup-索引式查找&quot;&gt;ToLookup 索引式查找&lt;/h2&gt;
&lt;p&gt;ToLookup 扩展方法返回的是可索引查找的数据结构，它是一个 ILookup 实例，所有元素根据指定的键进行分组并可以按键进行索引。这样说有点抽象，来看具体示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;string[] array = { &quot;one&quot;, &quot;two&quot;, &quot;three&quot; };
// 根据元素字符串长度创建一个查找对象
var lookup = array.ToLookup(item =&amp;gt; item.Length);

// 查找字符串长度为 3 的元素
var result = lookup[3];
// result: one,two
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再来一个示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;int[] array = { 1,2,3,4,5,6,7,8 };
// 创建一个奇偶查找（键为 0 和 1）
var lookup = array.ToLookup(item =&amp;gt; item % 2);

// 查找偶数
var even = lookup[0];
// even: 2,4,6,8

// 查找奇数
var odd = lookup[1];
// odd: 1,3,5,7
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;distinct-去重&quot;&gt;Distinct 去重&lt;/h2&gt;
&lt;p&gt;Distinct 方法用来去除重复项，这个容易理解。示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;int[] array = { 1, 2, 3, 4, 2, 5, 3, 1, 2 };
var distinct = array.Distinct();
// distinct = { 1, 2, 3, 4, 5 }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;简单类型的集合调用 Distinct 方法使用的是默认的比较器，Distinct 方法用此比较器来判断元素是否与其它元素重复，但对于自定义类型要实现去重则需要自定义比较器。示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;public class IdEqualityComparer : IEqualityComparer&amp;lt;Person&amp;gt;
{
    public bool Equals(Person x, Person y) =&amp;gt; x.Id == y.Id;
    public int GetHashCode(Person p) =&amp;gt; p.Id;
}

public class Person
{
    public int Id { get; set; }
    public string Name { get; set; }
}

class Program
{
    static void Main(string[] args)
    {
        var people = new List&amp;lt;Person&amp;gt;();
        var distinct = people.Distinct(new IdEqualityComparer());
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;todictionary-字典转换&quot;&gt;ToDictionary 字典转换&lt;/h2&gt;
&lt;p&gt;ToDictionary 扩展方法可以把集合 &lt;code&gt;IEnumerable&amp;lt;TElement&amp;gt;&lt;/code&gt; 转换为 &lt;code&gt;Dictionary&amp;lt;TKey, TValue&amp;gt;&lt;/code&gt; 结构的字典，它接收一个 &lt;code&gt;Func&amp;lt;TSource, TKey&amp;gt;&lt;/code&gt; 参数用来返回每个元素指定的键与值。示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;IEnumerable&amp;lt;User&amp;gt; users = GetUsers();
Dictionary&amp;lt;int, User&amp;gt; usersById = users.ToDictionary(x =&amp;gt; x.Id);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果不用 ToDictionary，你需要这样写：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;IEnumerable&amp;lt;User&amp;gt; users = GetUsers();
Dictionary&amp;lt;int, User&amp;gt; usersById = new Dictionary&amp;lt;int, User&amp;gt;();
foreach (User u in users)
{
    usersById.Add(u.Id, u);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面 ToDictionary 返回的字典数据中的值是整个元素，你也可以通过它的第二个参数来自定义字典的值。示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;Dictionary&amp;lt;int, string&amp;gt; userNamesById = users.ToDictionary(x =&amp;gt; x.Id, x =&amp;gt; x.Name);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你也可以为转换的字典指定其键是否区分大小写，即自定义字典的 IComparer，示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;Dictionary&amp;lt;string, User&amp;gt; usersByCaseInsenstiveName = users.ToDictionary(x =&amp;gt;x.Name,
    StringComparer.InvariantCultureIgnoreCase);

var user1 =usersByCaseInsenstiveName[&quot;liam&quot;];
var user2 =usersByCaseInsenstiveName[&quot;LIAM&quot;];
user1 == user2; // true
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意，字典类型要求所有键不能重复，所以在使用 ToDictionary 方法时要确保作为字典的键的元素属性不能有重复值，否则会抛出异常。&lt;/p&gt;
&lt;h2 id=&quot;其它常见扩展方法&quot;&gt;其它常见扩展方法&lt;/h2&gt;
&lt;p&gt;LINQ 还有很多其它常见的扩展方法，大家在平时应该用的比较多，比如 Where、Any、All 等，这里也选几个简单举例介绍一下。&lt;/p&gt;
&lt;h3 id=&quot;range-和-repeat&quot;&gt;Range 和 Repeat&lt;/h3&gt;
&lt;p&gt;Range 和 Repeat 用于生成简单的数字或字符串系列。示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;// 生成 1-100 的数字，即结果为 [1, 2, ..., 99, 100]
var range = Enumerable.Range(1, 100);

// 生成三个重复的字符串“a”，即结果为 [&quot;a&quot;, &quot;a&quot;, &quot;a&quot;]
var repeatedValues = Enumerable.Repeat(&quot;a&quot;, 3);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;any-和-all&quot;&gt;Any 和 All&lt;/h3&gt;
&lt;p&gt;Any 用来判断集合中是否存在任一一个元素符合条件，All 用来判断集合中是否所有元素符合条件。示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;var numbers = new int[] {1, 2, 3, 4, 5 };
bool result = numbers.Any(); // true
bool result = numbers.Any(x =&amp;gt; x == 6); // false
bool result = numbers.All(x =&amp;gt; x &amp;gt; 0); // true
bool result = numbers.All(x =&amp;gt; x &amp;gt; 1); // false
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;concat-和-union&quot;&gt;Concat 和 Union&lt;/h3&gt;
&lt;p&gt;Concat 用来拼接两个集合，不会去除重复元素，示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;List&amp;lt;int&amp;gt; foo = newList&amp;lt;int&amp;gt; { 1, 2, 3 };
List&amp;lt;int&amp;gt; bar = newList&amp;lt;int&amp;gt; { 3, 4, 5 };
// 通过 Enumerable 类的静态方法
var result = Enumerable.Concat(foo, bar).ToList(); // 1,2,3,3,4,5
// 通过扩展方法
var result = foo.Concat(bar).ToList(); // 1,2,3,3,4,5
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Union 也是用来拼接两个集合，与 Concat 不同的是，它会去除重复项，示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;var result = foo.Union(bar); // 1,2,3,4,5
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;groupby-分组&quot;&gt;GroupBy 分组&lt;/h3&gt;
&lt;p&gt;GroupBy 扩展方法用来对集合进行分组，下面是一个根据奇偶进行分组的示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;var list = new List&amp;lt;int&amp;gt;() { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
var grouped = list.GroupBy(x =&amp;gt; x % 2 == 0);
// grouped: [1, 3, 5, 7, 9] 和 [2, 4, 6, 8]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还可以根据指定属性进行分组：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;public class Person
{
    public int Age { get; set; }
    public string Name { get; set; }
}

var people = new List&amp;lt;Person&amp;gt;();
var query = people
    .GroupBy(x =&amp;gt; x.Age)
    .Select(g =&amp;gt; { Age = g.Key, Count = g.Count() });
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;defaultifempty-空替换&quot;&gt;DefaultIfEmpty 空替换&lt;/h3&gt;
&lt;p&gt;在上面的关联查询中我们使用了 DefaultIfEmpty 扩展方法，它表示在没有查询到指定条件的元素时使用元素的默认值代替。其实 DefaultIfEmpty 还可以指定其它的默认值，示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;var chars = new List&amp;lt;string&amp;gt;() { &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; };
chars.Where(s =&amp;gt; s.Length &amp;gt; 1).DefaultIfEmpty().First(); // 返回 null
chars.DefaultIfEmpty(&quot;N/A&quot;).FirstOrDefault(); // 返回 &quot;a&quot;
chars.Where(s =&amp;gt; s.Length &amp;gt; 1).DefaultIfEmpty(&quot;N/A&quot;).FirstOrDefault(); // 返回 &quot;N/A&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;sequenceequal-集合相等&quot;&gt;SequenceEqual 集合相等&lt;/h3&gt;
&lt;p&gt;SequenceEqual 扩展方法用于比较集合系列各个相同位置的元素是否相等。示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;int[] a = new int[] {1, 2, 3};
int[] b = new int[] {1, 2, 3};
int[] c = new int[] {1, 3, 2};

bool result1 = a.SequenceEqual(b); // true
bool result2 = a.SequenceEqual(c); // false
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;最后&quot;&gt;最后&lt;/h2&gt;
&lt;p&gt;还有一些常用和简单的扩展方法就不举例了，比如 OrderBy（排序）、Sum（求和）、Count（计数）、Reverse（反转）等，同时欢迎大家补充本文遗漏的强大或好用的 LINQ 语法糖。&lt;/p&gt;
</description>
<pubDate>Mon, 31 Aug 2020 00:36:00 +0000</pubDate>
<dc:creator>精致码农</dc:creator>
<og:description>大家好，这是 [C#.NET 拾遗补漏] 系列的第 08 篇文章，今天讲 C# 强大的 LINQ 查询。LINQ 是我最喜欢的 C# 语言特性之一。 LINQ 是 Language INtegrate</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/willick/p/13586024.html</dc:identifier>
</item>
<item>
<title>我今天才知道：学习编程和学习编程语言是两码事 - 削微寒</title>
<link>http://www.cnblogs.com/xueweihan/p/13578261.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xueweihan/p/13578261.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202008/759200-20200828162434507-196711401.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;大多数程序员、初学者都以为自己正在学习编程，其实并不是，而是在走弯路。&lt;/p&gt;
&lt;h2 id=&quot;你可能正在学习一门编程语言，而不是编程本身&quot;&gt;你可能正在学习一门编程语言，而不是编程本身&lt;/h2&gt;
&lt;p&gt;计算机科学不是学习计算机，很震惊吧。相反，它是关于借助计算机来自动解决问题的一门学问。解决问题才是计算机科学，而不是写代码。这就是许多计算机科学专业的学生，似乎不理解他们为什么学习算法和数学的原因。&lt;/p&gt;
&lt;p&gt;如果你以前上过计算机科学的课，那么你不会对此感到惊讶。因为你会注意到编程与编程语言几乎没有关系。 &lt;strong&gt;思考一下，为什么伪代码在这些课程中如此常见。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;但大多数程序员总是会落入陷阱。我们学了十几年编程语言，才意识到自己真正需要学的是编程，而我本身就是受害者。&lt;/p&gt;
&lt;p&gt;我花了十多年的时间来学习各种编程语言。我学的编程语言越多，构建简单的东西就越困难，我感觉找不到正确的工具。但问题是，当我不知道如何下手时，我忘记了应该去探索要做什么，而不是寻找正确的工具。&lt;/p&gt;
&lt;p&gt;编程语言的奇怪之处在于它们总是在变化。编程语言几乎每天都在变化，跟进非常困难。而且大多数优秀的程序仅用到了编程语言的一小部分。&lt;/p&gt;
&lt;p&gt;优先学习编程语言的问题就像在学习木工之前学习如何使用木工锯、锤子和各种切割机。木工需要注意：想法、可行性分析、度量、测试、用户使用习惯，老木匠更关注这些。而不是锤子和钉子这些东西。在对工作进行科学研究期间，他还将花时间检查钉子、着色剂、木材等的质量。&lt;/p&gt;
&lt;h2 id=&quot;学习编程和学习编程语言有什么区别？&quot;&gt;学习编程和学习编程语言有什么区别？&lt;/h2&gt;
&lt;p&gt;“编程” 通过给出一条指令来使系统自动运行。我们每天都这样做，我们教我们的孩子、士兵、客户。我们发出或收到指令，要求自由或独立地按照规定的方式进行。你的父母不需要一直跟着你，并指导你生活中的每一步，他们已经在之前生活中的许多方面对你给予过指导（指令）。&lt;/p&gt;
&lt;p&gt;大多数学校和教育网站都会教授编程语言的语法。他们还会添加一些设计模式（而你可能恰好忽略了设计模式是什么）、一些数学计算、如何声明变量以及如何使用它们，数据类型以及如何声明和创建它们。&lt;/p&gt;
&lt;p&gt;上面说的那些编程语言的知识不会教你编程。当你发现时，你会觉得学习编程实在浪费时间，大把的时间。&lt;/p&gt;
&lt;p&gt;我们用编程来解决问题，而编程语言是帮助我们解决问题的工具。&lt;/p&gt;
&lt;p&gt;它们就像工具箱，我们称之为框架。它们可以让你的想法更有条理。&lt;/p&gt;
&lt;p&gt;如果你正在学习编程，但仍无法设计和编写一个实际的应用程序，这意味着你要花更多的时间去学习编程而不是编程语言。&lt;/p&gt;
&lt;p&gt;我们遇到过很多人，他们仍然不知道如何设计一个程序。对于程序员来说，一个程序是一个需要解决的问题。在涉及任何编程语言之前，需要先认真思考、理解问题。当你无论要解决什么问题时，其实都可以使用任何一种编程语言进行编码（重要的是思考要解决的问题）。&lt;/p&gt;
&lt;p&gt;让我们以计算平方为例。&lt;strong&gt;计算一个数的平方，对自身进行多次乘法计算&lt;/strong&gt;。我们可以用多种语言来实现它，例如：&lt;/p&gt;
&lt;h3 id=&quot;用-c-语言&quot;&gt;用 C 语言&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;function square(int * x) {
    return x * x;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;用-php&quot;&gt;用 PHP&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-php&quot;&gt;function square ($x){
    return $x * $x;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;用-javascript&quot;&gt;用 JavaScript&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;function square(x){
    return x * x
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;用-scheme（一种-lisp-方言）&quot;&gt;用 Scheme（一种 Lisp 方言）&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-scheme&quot;&gt;(define (square x) (* x x))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你会注意到，语法只决定具体实现，而解决问题的方法是相同的。这就是你几乎可以使用任何你愿意使用的语言，构建任何类型的软件的主要原因之一。&lt;/p&gt;
&lt;h2 id=&quot;通过编程更容易理解一门语言&quot;&gt;通过编程更容易理解一门语言&lt;/h2&gt;
&lt;p&gt;人类语言是个问题，因为人类语言充满局限和错误，所以机器无法直接理解。&lt;/p&gt;
&lt;p&gt;在学习编程时，你将学习新的术语和新的工具来编写逻辑，这样计算机或其他程序员也可以理解并达成共识。&lt;/p&gt;
&lt;p&gt;通常，你将从一个简单的、类似人类语言，被称作伪代码的语言开始。它是从人类语言到计算机编程语言的很好的过渡工具，这样做是为了防止你在编程语言上浪费时间。如此，你就可以完全专注于问题的本身和解决的逻辑。通过这一过程，你将发现一个好的编程工具（语言）的核心部分，你就知道那些是重要的、你所需要的（如果你需要用到锤子砸东西，就先学砸东西，钉钉子暂时用不到就先不学）。这样一来，你就会在不知不觉间就学会一门编程语言（完全掌握锤子的用法）。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202008/759200-20200828162310704-554973222.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关注 HelloGitHub 公众号&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;欢迎热爱技术和开源的小伙伴加入 HG 推出的译文亦舞系列的翻译中来，可添加微信号：HelloGitHub（备注：翻译）。​&lt;/p&gt;
</description>
<pubDate>Mon, 31 Aug 2020 00:32:00 +0000</pubDate>
<dc:creator>削微寒</dc:creator>
<og:description>原文地址：Learning programming is different from learning a programming language 原文作者：zooboole 译者：HelloGi</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xueweihan/p/13578261.html</dc:identifier>
</item>
<item>
<title>重温Java Web的技术细节 - 智慧zhuhuix</title>
<link>http://www.cnblogs.com/zhuhuix/p/13587689.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhuhuix/p/13587689.html</guid>
<description>&lt;h2 id=&quot;一、背景&quot;&gt;一、背景&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Java Servlet可以说是一项非常久远的技术了，甚至可以说是Java Web应用的起源。也就是说真正了解了这项技术的原理与实现细节，我们就掌握了Java Web的基础，也对以后能上手基于Java Servlet的框架起到事半功倍的作用。&lt;/li&gt;
&lt;li&gt;本文旨在重温与Java Servlet密切相关的一些技术细节。&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h2 id=&quot;二、请求与响应&quot;&gt;二、请求与响应&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Servlet的核心任务是处理请求&lt;kbd&gt;Request&lt;/kbd&gt;，并给出响应&lt;kbd&gt;Response&lt;/kbd&gt;，这也是Servlet存在的真正意义。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200826114905909.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pwZ3podQ==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;21、http请求&quot;&gt;2.1、Http请求&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;在Java Web应用开发中，99.999%用到的都是Http请求&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/** 
* Servlet处理HTTP GET/POST请求
*/
public class HttpServletDemo extends HttpServlet {
        
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) {
           ...
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp {
                ...
    }
 }
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;## GET和POST请求的区别

# GET请求
GET /books/?name=computer&amp;amp;num=1 HTTP/1.1
Host: www.wrox.com
User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)
Gecko/20050225 Firefox/1.0.1
Connection: Keep-Alive
# 注意最后一行是空行

# POST请求
POST /books/add HTTP/1.1
Host: www.wrox.com
User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)
Gecko/20050225 Firefox/1.0.1
Content-Type: application/x-www-form-urlencoded
Content-Length: 40
Connection: Keep-Alive
# 以下是POST请求Body
name=computer&amp;amp;num=1
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;HttpServlet类中的Service方法根据Http请求的类型&lt;kbd&gt;GET/POST&lt;/kbd&gt;分别调用doGet或doPost&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
* HttpServlet类Service方法
*/
protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        String method = req.getMethod();
        long lastModified;
        if (method.equals(&quot;GET&quot;)) {
            lastModified = this.getLastModified(req);
            if (lastModified == -1L) {
                this.doGet(req, resp);
            } else {
                long ifModifiedSince;
                try {
                    ifModifiedSince = req.getDateHeader(&quot;If-Modified-Since&quot;);
                } catch (IllegalArgumentException var9) {
                    ifModifiedSince = -1L;
                }

                if (ifModifiedSince &amp;lt; lastModified / 1000L * 1000L) {
                    this.maybeSetLastModified(resp, lastModified);
                    this.doGet(req, resp);
                } else {
                    resp.setStatus(304);
                }
            }
        } else if (method.equals(&quot;HEAD&quot;)) {
            lastModified = this.getLastModified(req);
            this.maybeSetLastModified(resp, lastModified);
            this.doHead(req, resp);
        } else if (method.equals(&quot;POST&quot;)) {
            this.doPost(req, resp);
        
        } else {
            String errMsg = lStrings.getString(&quot;http.method_not_implemented&quot;);
            Object[] errArgs = new Object[]{method};
            errMsg = MessageFormat.format(errMsg, errArgs);
            resp.sendError(501, errMsg);
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;对于Http Request请求，我们还需要理解幂等的概念：对同一个系统，使用同样的条件，一次请求和重复的多次请求对系统资源的影响是一致的。&lt;/li&gt;
&lt;li&gt;根据以上定义，我们认为GET请求一般情况下是幂等的（GET请求不会引起服务资源的变更），而POST请求是非幂等的（POST请求会提交数据并造成数据更改，造成不可逆，比如多次POST提交订单数据）。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;Servlet可以通过API获取到Http请求的相关数据&lt;/li&gt;
&lt;/ul&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;API&lt;/th&gt;
&lt;th&gt;备注&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;8&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;request.getParameter(&quot;参数名&quot;)&lt;/td&gt;
&lt;td&gt;根据参数名获取参数值（注意，只能获取一个值的参数）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;request.getParameterValue(&quot;参数名“)&lt;/td&gt;
&lt;td&gt;根据参数名获取参数值（可以获取多个值的参数）&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;request.getMethod&lt;/td&gt;
&lt;td&gt;获取Http请求方式&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;request.getHeader(&quot;User-Agent&quot;)&lt;/td&gt;
&lt;td&gt;获取用台浏览器信息&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;request.getCookies&lt;/td&gt;
&lt;td&gt;获取与请求相关的Cookies&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;request.getSession&lt;/td&gt;
&lt;td&gt;获取与用户相关的会话&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;...&lt;/td&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;22、http响应&quot;&gt;2.2、Http响应&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;响应是为了向用户发送数据，Servlet需要处理的是封装成Http响应消息的HttpServletResponse对象。&lt;/li&gt;
&lt;li&gt;Http响应一般返回给浏览器HTML页面，再由浏览器解析HTML呈现给用户。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200826140114822.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pwZ3podQ==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;但Http响应发送HTML页面并不是全部，比如用户需要通过网站下载某个文件，那Http响应需要返回字节流。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;protected void doGet(HttpServletRequest req, HttpServletResponse resp){
                // 这是一个字节流
        resp.setContentType(&quot;application/octet-stream&quot;);
        resp.setHeader(&quot;Content-disposition&quot;, &quot;attachment;filename=&quot; + filename);

        InputStream fis = this.getClass().getResourceAsStream(&quot;download.xlsx&quot;);
        OutputStream os = resp.getOutputStream();
        byte[] bis = new byte[1024];
        while (-1 != fis.read(bis)) {
            os.write(bis);
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;Servlet设置Http响应头控制浏览器的行为&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//设置refresh响应头控制浏览器每隔1秒钟刷新一次
response.setHeader(&quot;refresh&quot;, &quot;1&quot;);

//可分别通过三种方式禁止缓存当前文档内容
response.setDateHeader(&quot;expries&quot;, -1);

response.setHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;);

response.setHeader(&quot;Pragma&quot;, &quot;no-cache&quot;)

// 重定向：收到客户端请求后，通知客户端去访问另外一个web资源
protected void doPost(HttpServletRequest req, HttpServletResponse resp)  {
     // 通过sendRedirect方法实现请求重定向
     resp.sendRedirect(req.getContextPath() + &quot;/welcome.jsp&quot;);
}
// 请求分派
protected void doPost(HttpServletRequest req, HttpServletResponse resp)  {
  req.getRequestDispatcher(&quot;/result.jsp&quot;).forward(req,resp);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;Servlet与HTTP 状态码&lt;/li&gt;
&lt;/ul&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;代码&lt;/th&gt;
&lt;th&gt;消息&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr&gt;&lt;td&gt;200&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;请求成功。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;401&lt;/td&gt;
&lt;td&gt;Unauthorized&lt;/td&gt;
&lt;td&gt;所请求的页面需要授权&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;404&lt;/td&gt;
&lt;td&gt;Not Found&lt;/td&gt;
&lt;td&gt;服务器无法找到所请求的页面。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;500&lt;/td&gt;
&lt;td&gt;Internal Server Error&lt;/td&gt;
&lt;td&gt;未完成的请求。服务器遇到了一个意外的情况&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;...&lt;/td&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 返回HTTP 500状态码
protected void doPost(HttpServletRequest req, HttpServletResponse resp)  {
  resp.sendError(500);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200826145258896.png#pic_left&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;三、servletconfig&quot;&gt;三、ServletConfig&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;在每个Servlet运行时，有可能需要一些初始化&lt;strong&gt;参数&lt;/strong&gt;，比如，文件使用的编码，共享的资源信息等。&lt;/li&gt;
&lt;li&gt;这些初始化参数可以在 &lt;kbd&gt;web.xml&lt;/kbd&gt; 文件中使用一个或多个 &lt;kbd&gt;＜init-param＞&lt;/kbd&gt; 元素进行描述配置。当 容器 初始化一个 Servlet 时，会将该 Servlet 的配置信息封装，并通过 init（ServletConfig）方法将 ServletConfig 对象的引用传递给 Servlet。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200827082608464.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pwZ3podQ==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;31-测试servletconfig参数&quot;&gt;3.1 测试ServletConfig参数&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;在web.xml中进行如下配置：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
         version=&quot;4.0&quot;&amp;gt;
        &amp;lt;servlet&amp;gt;
         &amp;lt;servlet-name&amp;gt;http-demo&amp;lt;/servlet-name&amp;gt;
         &amp;lt;servlet-class&amp;gt;demo.servlet.HttpServletDemo&amp;lt;/servlet-class&amp;gt;
                  &amp;lt;!-- 设置该servlet的管理员邮箱地址 --&amp;gt;
          &amp;lt;init-param&amp;gt;
              &amp;lt;param-name&amp;gt;adminEmail&amp;lt;/param-name&amp;gt;
              &amp;lt;param-value&amp;gt;admin@163.com&amp;lt;/param-value&amp;gt;
          &amp;lt;/init-param&amp;gt;
     &amp;lt;/servlet&amp;gt;
&amp;lt;/web-app&amp;gt;
                
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;在servlet代码中进行如下调用：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class HttpServletDemo extends HttpServlet {

    // 重写Get请求方法,返回一个表单页面
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException, ServletException {
        resp.setContentType(&quot;text/html&quot;);
        resp.setCharacterEncoding(&quot;GBK&quot;);
        PrintWriter out =resp.getWriter();
        out.println(&quot;&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;&quot;);
        out.println(&quot;管理员邮箱:&quot;);
        out.println(getServletConfig().getInitParameter(&quot;adminEmail&quot;));
        out.println(&quot;&amp;lt;br&amp;gt;&quot;);
        out.println(&quot;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200827102147895.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pwZ3podQ==,size_16,color_FFFFFF,t_70#pic_left&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;四、servletcontext&quot;&gt;四、ServletContext&lt;/h2&gt;
&lt;p&gt;－web应用同样也需要一些初始化的&lt;strong&gt;参数&lt;/strong&gt;，但 相对于每一个Servlet有一个ServletConfig来说，一个Web应用（确切的说是每个JVM）仅有一个ServletContext来存放这些参数，这个ServletContext对Web应用中的每个Servlet都可用。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200827103823353.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pwZ3podQ==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;41-测试servletcontext参数&quot;&gt;4.1 测试ServletContext参数&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;在web.xml中进行如下配置：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
         version=&quot;4.0&quot;&amp;gt;
         
                &amp;lt;!-- 设置web应用的统一标题栏 --&amp;gt;
        &amp;lt;context-param&amp;gt;
            &amp;lt;param-name&amp;gt;title&amp;lt;/param-name&amp;gt;
            &amp;lt;param-value&amp;gt;My-App网站&amp;lt;/param-value&amp;gt;
        &amp;lt;/context-param&amp;gt;

        &amp;lt;servlet&amp;gt;
            &amp;lt;servlet-name&amp;gt;http-demo&amp;lt;/servlet-name&amp;gt;
            &amp;lt;servlet-class&amp;gt;demo.servlet.HttpServletDemo&amp;lt;/servlet-class&amp;gt;

            &amp;lt;init-param&amp;gt;
                &amp;lt;param-name&amp;gt;adminEmail&amp;lt;/param-name&amp;gt;
                &amp;lt;param-value&amp;gt;admin@163.com&amp;lt;/param-value&amp;gt;
            &amp;lt;/init-param&amp;gt;
        &amp;lt;/servlet&amp;gt;

        &amp;lt;servlet-mapping&amp;gt;
            &amp;lt;servlet-name&amp;gt;http-demo&amp;lt;/servlet-name&amp;gt;
            &amp;lt;url-pattern&amp;gt;/http-demo&amp;lt;/url-pattern&amp;gt;
        &amp;lt;/servlet-mapping&amp;gt;
&amp;lt;/web-app&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;在servlet代码中进行如下调用：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class HttpServletDemo extends HttpServlet {

    // 重写Get请求方法,返回一个表单页面
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException, ServletException {

        resp.setContentType(&quot;text/html&quot;);
        resp.setCharacterEncoding(&quot;GBK&quot;);
        PrintWriter out =resp.getWriter();
        out.println(&quot;&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;&quot;);
        out.println(&quot;&amp;lt;title&amp;gt;&quot;+getServletContext().getInitParameter(&quot;title&quot;)+&quot;&amp;lt;/title&amp;gt;&quot;);
        out.println(&quot;管理员邮箱:&quot;);
        out.println(getServletConfig().getInitParameter(&quot;adminEmail&quot;));
        out.println(&quot;&amp;lt;br&amp;gt;&quot;);
        out.println(&quot;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&quot;);
    }
 }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200827105115234.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pwZ3podQ==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;注意点：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 在web应用中，以下两句代码等价
getServletContext().getInitParameter(&quot;title&quot;);
getServletConfig().getServletContext().getInitParameter(&quot;title&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;42、servletcontext属性&quot;&gt;4.2、ServletContext属性&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;通过编程的方式，可以给ServletContext绑定属性，使得web应用中的Servlet对象可以使用该全局属性。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 重写Post请求方法，提交表单上的数据，并返回结果页面
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {

        String name = req.getParameter(&quot;name&quot;);
        Integer age = Integer.parseInt(req.getParameter(&quot;age&quot;));
        if (name != null &amp;amp;&amp;amp; age != null) {
            User user = new User(name, age);
            req.setAttribute(&quot;name&quot;, name);
            req.setAttribute(&quot;age&quot;, age);
            // 设置提交成功次数属性,并同步加锁，防止多线程并发异常
            synchronized (getServletContext()) {
                if (user.checkName()) {
                    Long postCount = getServletContext().getAttribute(&quot;postCount&quot;) == null ? 1L
                            : Long.parseLong(getServletContext().getAttribute(&quot;postCount&quot;).toString()) + 1L;
                    getServletContext().setAttribute(&quot;postCount&quot;, postCount);

                    req.setAttribute(&quot;result&quot;, &quot;登记成功&quot; + &quot;! 总共已有&quot; + postCount + &quot;人数登记！！&quot;);
                } else {
                    req.setAttribute(&quot;result&quot;, &quot;登记失败：名称中包含非法字符&quot;);
                }
            }
            RequestDispatcher view = req.getRequestDispatcher(&quot;/result.jsp&quot;);
            view.forward(req, resp);

        }

    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200827122142887.png#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200827122154566.png#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;属性与参数的区别&lt;/li&gt;
&lt;/ul&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;4.5&quot;&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;设置方法&lt;/td&gt;
&lt;td&gt;setAttribute(String name,Object value)&lt;/td&gt;
&lt;td&gt;只能在web.xml中设置&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;返回类型&lt;/td&gt;
&lt;td&gt;Object&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;获取方法&lt;/td&gt;
&lt;td&gt;getAttribute(String name).&lt;/td&gt;
&lt;td&gt;getInitParameter(String s)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;hr/&gt;&lt;h2 id=&quot;五、属性的作用域&quot;&gt;五、属性的作用域&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;除了ServletContext可以设置属性外，&lt;kbd&gt;HttpSession&lt;/kbd&gt;会话、&lt;kbd&gt;HttpServletRequest&lt;/kbd&gt;请求都可以设置和使用属性。但这三者的作用域是不同的，可参见下表：&lt;/li&gt;
&lt;/ul&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th&gt;属性作用域&lt;/th&gt;
&lt;th&gt;备注&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;7.5&quot;&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;ServletContext&lt;/td&gt;
&lt;td&gt;web应用存活期间都可以设置并使用属性；应用关闭上下文撤消后相应属性也会消失&lt;/td&gt;
&lt;td&gt;各个Servlet都可以使用，但线程不安全，一般适在于常量属性等，比如数据库连接&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;HttpSession&lt;/td&gt;
&lt;td&gt;HttpSession应用存活期间都可以设置并使用属性；会话超时或被人为撤消后相应属性也会消失&lt;/td&gt;
&lt;td&gt;与会话相关的都可以使用，比如电商网站的购物车属性&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;HttpServletRequest&lt;/td&gt;
&lt;td&gt;每次请求生成时可设置或使用属性，直到这个请求在service方法中消失&lt;/td&gt;
&lt;td&gt;请求中属性是线程安全的，类似于局部变量&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;hr/&gt;&lt;h2 id=&quot;六、httpsession&quot;&gt;六、HttpSession&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Session就是为了让服务器有能力分辨出不同的用户。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;客户端在第一次请求时没有携带任何sessionId，服务端Servlet容器就会给客户端创建一个HttpSession对象 存储在服务器端，然后给这个对象创建一个sessionID 作为唯一标识。同时&lt;br/&gt;这个sessionID还会放在一个cookie里，通过response返回客户端。&lt;/li&gt;
&lt;li&gt;客户端第二次发出请求，cookie中会携带sessionId，servlet容器拿着这个sessionID在服务器端查找对应的HttpSession对象，找到后就直接拿出来使用。&lt;/li&gt;
&lt;li&gt;Servlet会为不同的客户端创建不同的sessionId及session对象，代表不同的状态。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200829075930853.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pwZ3podQ==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;61-httpsession的关键方法&quot;&gt;6.1 HttpSession的关键方法&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;关键方法&lt;/li&gt;
&lt;/ul&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;4.5&quot;&gt;&lt;tr&gt;&lt;td&gt;getSession()&lt;/td&gt;
&lt;td&gt;获取Session 对象&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;setAttribute()&lt;/td&gt;
&lt;td&gt;在Session 对象中设置属性&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;getAttribute()&lt;/td&gt;
&lt;td&gt;在Session 对象中获取属性&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;removeAttribute()&lt;/td&gt;
&lt;td&gt;在Session 对象中删除属性&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;invalidate()&lt;/td&gt;
&lt;td&gt;使Session 对象失效&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;setMaxInactiveInterval()&lt;/td&gt;
&lt;td&gt;设置Session 对象最大间隔时间(在这段时间内，客户端未对这个会话有新的请求操作，该会话就会撤消)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;62-简易的购物车使用httpsession&quot;&gt;6.2 简易的购物车使用HttpSession&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
         version=&quot;4.0&quot;&amp;gt;

    &amp;lt;context-param&amp;gt;
        &amp;lt;param-name&amp;gt;title&amp;lt;/param-name&amp;gt;
        &amp;lt;param-value&amp;gt;购物网站&amp;lt;/param-value&amp;gt;
    &amp;lt;/context-param&amp;gt;

    &amp;lt;!-- 网站session失效时间为30分钟 --&amp;gt;
    &amp;lt;session-config&amp;gt;
        &amp;lt;session-timeout&amp;gt;30&amp;lt;/session-timeout&amp;gt;
    &amp;lt;/session-config&amp;gt;

    &amp;lt;!-- 登录servlet --&amp;gt;
    &amp;lt;servlet&amp;gt;
        &amp;lt;servlet-name&amp;gt;http-demo&amp;lt;/servlet-name&amp;gt;
        &amp;lt;servlet-class&amp;gt;demo.servlet.HttpServletDemo&amp;lt;/servlet-class&amp;gt;
        &amp;lt;load-on-startup&amp;gt;1&amp;lt;/load-on-startup&amp;gt;
    &amp;lt;/servlet&amp;gt;

    &amp;lt;servlet-mapping&amp;gt;
        &amp;lt;servlet-name&amp;gt;http-demo&amp;lt;/servlet-name&amp;gt;
        &amp;lt;url-pattern&amp;gt;/http-demo&amp;lt;/url-pattern&amp;gt;
    &amp;lt;/servlet-mapping&amp;gt;

    &amp;lt;!-- 购物车servlet --&amp;gt;
    &amp;lt;servlet&amp;gt;
        &amp;lt;servlet-name&amp;gt;cart&amp;lt;/servlet-name&amp;gt;
        &amp;lt;servlet-class&amp;gt;demo.servlet.CartServlet&amp;lt;/servlet-class&amp;gt;
        &amp;lt;load-on-startup&amp;gt;1&amp;lt;/load-on-startup&amp;gt;
    &amp;lt;/servlet&amp;gt;

    &amp;lt;servlet-mapping&amp;gt;
        &amp;lt;servlet-name&amp;gt;cart&amp;lt;/servlet-name&amp;gt;
        &amp;lt;url-pattern&amp;gt;/cart&amp;lt;/url-pattern&amp;gt;
    &amp;lt;/servlet-mapping&amp;gt;

&amp;lt;/web-app&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;购物网站登录页面Servlet：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * 购物网站登录页面
 *
 * @author zhuhuix
 * @date 2020-08-28
 */
public class HttpServletDemo extends HttpServlet {
    //static int i=0 ;

    // 重写Get请求方法,返回登录表单页面
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException, ServletException {
        req.setAttribute(&quot;title&quot;, getServletContext().getInitParameter(&quot;title&quot;));
        req.getRequestDispatcher(&quot;/form.jsp&quot;).forward(req, resp);

    }

    // 重写Post请求方法，进行登录，登录成功后跳车购物车页面
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {

        String name = req.getParameter(&quot;name&quot;);
        Integer password = Integer.parseInt(req.getParameter(&quot;password&quot;));
        if (name != null &amp;amp;&amp;amp; password != null) {
            req.getSession().setAttribute(&quot;name&quot;,name);
            RequestDispatcher view = req.getRequestDispatcher(&quot;/cart.jsp&quot;);
            view.forward(req, resp);
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;购物网站登录页面视图：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!--表单页面--&amp;gt;
&amp;lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&amp;gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;zh-CN&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&amp;gt;
    &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css&quot;
          integrity=&quot;sha384-HSMxcRTRxnN+Bdg0JdbxYKrThecOKuH5zCYotlSAcp1+c8xmyTe9GYg1l9a69psu&quot; crossorigin=&quot;anonymous&quot;&amp;gt;
    &amp;lt;script src=&quot;https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js&quot;
            integrity=&quot;sha384-B4gt1jrGC7Jh4AgTPSdUtOBvfO8shuf57BaghqFfPlYxofvL8/KUEfYiJOMMV+rV&quot;
            crossorigin=&quot;anonymous&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;title&amp;gt;${title}用户登录&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;div class=&quot;container&quot;&amp;gt;

    &amp;lt;form role=&quot;form&quot; method=&quot;post&quot; action=&quot;http-demo&quot; class=&quot;form-horizontal&quot;&amp;gt;
        &amp;lt;div class=&quot;form-group&quot;&amp;gt;
            &amp;lt;h4 class=&quot;col-sm-3 col-sm-offset-3&quot;&amp;gt;用户登录&amp;lt;/h4&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;div class=&quot;form-group&quot;&amp;gt;
            &amp;lt;label class=&quot;col-sm-3 control-label&quot;&amp;gt;用户名&amp;lt;/label&amp;gt;
            &amp;lt;div class=&quot;col-sm-3&quot;&amp;gt;
                &amp;lt;input name=&quot;name&quot; type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;请输入用户名&quot;&amp;gt;
            &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;div class=&quot;form-group&quot;&amp;gt;
            &amp;lt;label class=&quot;col-sm-3 control-label&quot;&amp;gt;密码&amp;lt;/label&amp;gt;
            &amp;lt;div class=&quot;col-sm-3&quot;&amp;gt;
                &amp;lt;input name=&quot;password&quot; type=&quot;password&quot; class=&quot;form-control&quot; placeholder=&quot;请输入密码&quot;&amp;gt;
            &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;

        &amp;lt;div class=&quot;form-group&quot;&amp;gt;
            &amp;lt;div class=&quot;col-sm-3 col-sm-offset-3&quot;&amp;gt;
                &amp;lt;button class=&quot;btn btn-primary&quot;&amp;gt;点击登录&amp;lt;/button&amp;gt;
            &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/form&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200829092054435.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pwZ3podQ==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;购物车页面视图：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!--表单页面--&amp;gt;
&amp;lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&amp;gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;zh-CN&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&amp;gt;
    &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css&quot;
          integrity=&quot;sha384-HSMxcRTRxnN+Bdg0JdbxYKrThecOKuH5zCYotlSAcp1+c8xmyTe9GYg1l9a69psu&quot; crossorigin=&quot;anonymous&quot;&amp;gt;
    &amp;lt;script src=&quot;https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js&quot;
            integrity=&quot;sha384-B4gt1jrGC7Jh4AgTPSdUtOBvfO8shuf57BaghqFfPlYxofvL8/KUEfYiJOMMV+rV&quot;
            crossorigin=&quot;anonymous&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;title&amp;gt;${title}购物车&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;div class=&quot;container&quot;&amp;gt;

    &amp;lt;form role=&quot;form&quot; method=&quot;post&quot; action=&quot;cart&quot; class=&quot;form-horizontal&quot;&amp;gt;
        &amp;lt;div class=&quot;form-group&quot;&amp;gt;
            &amp;lt;h4 class=&quot;col-sm-3 col-sm-offset-1&quot;&amp;gt;${name}的购物车&amp;lt;/h4&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;table class=&quot;table table-bordered table-condensed&quot; style=&quot;width: 30%&quot;&amp;gt;
            &amp;lt;thead&amp;gt;
            &amp;lt;tr&amp;gt;
                &amp;lt;td&amp;gt;货物&amp;lt;/td&amp;gt;
                &amp;lt;td&amp;gt;数量&amp;lt;/td&amp;gt;
            &amp;lt;/tr&amp;gt;
            &amp;lt;/thead&amp;gt;
            &amp;lt;tbody&amp;gt;
            &amp;lt;tr&amp;gt;
                &amp;lt;td&amp;gt;手机&amp;lt;/td&amp;gt;
                &amp;lt;td&amp;gt;&amp;lt;input type=&quot;number&quot; name=&quot;phoneNumber&quot; value=${phoneNumber}&amp;gt; &amp;lt;/td&amp;gt;
            &amp;lt;/tr&amp;gt;
            &amp;lt;tr&amp;gt;
                &amp;lt;td&amp;gt;电脑&amp;lt;/td&amp;gt;
                &amp;lt;td&amp;gt;&amp;lt;input type=&quot;number&quot; name=&quot;pcNumber&quot; value=${pcNumber}&amp;gt; &amp;lt;/td&amp;gt;
            &amp;lt;/tr&amp;gt;
            &amp;lt;tr&amp;gt;
                &amp;lt;td&amp;gt;书本&amp;lt;/td&amp;gt;
                &amp;lt;td&amp;gt;&amp;lt;input type=&quot;number&quot; name=&quot;bookNumber&quot; value=${bookNumber}&amp;gt; &amp;lt;/td&amp;gt;
            &amp;lt;/tr&amp;gt;
            &amp;lt;/tbody&amp;gt;
        &amp;lt;/table&amp;gt;

        &amp;lt;div class=&quot;form-group&quot;&amp;gt;
            &amp;lt;div class=&quot;col-sm-1 col-sm-offset-1&quot;&amp;gt;
                &amp;lt;button class=&quot;btn btn-primary&quot;&amp;gt;点击提交&amp;lt;/button&amp;gt;
            &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/form&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200829092140503.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pwZ3podQ==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;购物车的Servlet：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * 购物车Servlet
 *
 * @author zhuhuix
 * @date 2020-08-29
 */
public class CartServlet extends javax.servlet.http.HttpServlet {


    // 重写Post请求方法，提交购物车的数据，并返回结果页面
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        // 查找页面上的购物数量，并放入session中

        req.getSession().setAttribute(&quot;phoneNumber&quot;, req.getParameter(&quot;phoneNumber&quot;));
        req.getSession().setAttribute(&quot;pcNumber&quot;, req.getParameter(&quot;pcNumber&quot;));
        req.getSession().setAttribute(&quot;bookNumber&quot;, req.getParameter(&quot;bookNumber&quot;));

        RequestDispatcher view = req.getRequestDispatcher(&quot;/result.jsp&quot;);
        view.forward(req, resp);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;购物结果视图页面：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!--结果页面--&amp;gt;
&amp;lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&amp;gt;
    &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css&quot;
          integrity=&quot;sha384-HSMxcRTRxnN+Bdg0JdbxYKrThecOKuH5zCYotlSAcp1+c8xmyTe9GYg1l9a69psu&quot; crossorigin=&quot;anonymous&quot;&amp;gt;
    &amp;lt;script src=&quot;https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js&quot;
            integrity=&quot;sha384-B4gt1jrGC7Jh4AgTPSdUtOBvfO8shuf57BaghqFfPlYxofvL8/KUEfYiJOMMV+rV&quot;
            crossorigin=&quot;anonymous&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;title&amp;gt;${title}购物结果&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;div class=&quot;container&quot;&amp;gt;

    &amp;lt;div class=&quot;row&quot;&amp;gt;
        &amp;lt;h3 class=&quot;col-sm-3 col-sm-offset-1&quot;&amp;gt;${name}的购物结果&amp;lt;/h3&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;table class=&quot;table table-bordered table-condensed&quot; style=&quot;width: 30%&quot;&amp;gt;
        &amp;lt;thead&amp;gt;
        &amp;lt;tr&amp;gt;
            &amp;lt;td&amp;gt;已购货物&amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;已购数量&amp;lt;/td&amp;gt;
        &amp;lt;/tr&amp;gt;
        &amp;lt;/thead&amp;gt;
        &amp;lt;tbody&amp;gt;
        &amp;lt;tr&amp;gt;
            &amp;lt;td&amp;gt;手机&amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;${phoneNumber} &amp;lt;/td&amp;gt;
        &amp;lt;/tr&amp;gt;
        &amp;lt;tr&amp;gt;
            &amp;lt;td&amp;gt;电脑&amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;${pcNumber}&amp;lt;/td&amp;gt;
        &amp;lt;/tr&amp;gt;
        &amp;lt;tr&amp;gt;
            &amp;lt;td&amp;gt;书本&amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;${bookNumber} &amp;lt;/td&amp;gt;
        &amp;lt;/tr&amp;gt;
        &amp;lt;/tbody&amp;gt;
    &amp;lt;/table&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200829092529697.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pwZ3podQ==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;HttpSession状态测试&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;用户登录网站后在购物车页面提交购物结果：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200829092835988.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pwZ3podQ==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;用户退出网站，重新登录 后进入购物车页面，网站后台将HttpSession中的数据重新调取到页面进行显示：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/202008290930212.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pwZ3podQ==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200829093034164.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pwZ3podQ==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;在web.xml中将会话失效时间改为一分钟，并重启网站，进行购物车提交&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;  &amp;lt;!-- 网站session失效时间为1分钟 --&amp;gt;
    &amp;lt;session-config&amp;gt;
        &amp;lt;session-timeout&amp;gt;1&amp;lt;/session-timeout&amp;gt;
    &amp;lt;/session-config&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200829093454694.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pwZ3podQ==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;退出网站，超过&lt;strong&gt;一分钟后&lt;/strong&gt;重新登录，并查看购物车情况&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200829093622738.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pwZ3podQ==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;购物车已空空如也&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200829093921580.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pwZ3podQ==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h2 id=&quot;七、监听器&quot;&gt;七、监听器&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;监听器&lt;kbd&gt;Listener&lt;/kbd&gt;又称为监听者，&lt;kbd&gt;Listener&lt;/kbd&gt;的设计为开发Servlet应用程序提供了一种快捷的手段，能够方便地从另一个纵向维度控制程序和数据，正所谓&lt;strong&gt;旁观者清&lt;/strong&gt;。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200828083731307.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pwZ3podQ==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;监听器采用了观察者设计模式，监听范围包括ServletContext、HttpSession、HttpRequest。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020082809320851.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pwZ3podQ==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;71-监听器测试--在线会话数统计&quot;&gt;7.1 监听器测试--在线会话数统计&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;在web.xml中进行如下配置：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
         version=&quot;4.0&quot;&amp;gt;

        &amp;lt;context-param&amp;gt;
            &amp;lt;param-name&amp;gt;title&amp;lt;/param-name&amp;gt;
            &amp;lt;param-value&amp;gt;My-App网站&amp;lt;/param-value&amp;gt;
        &amp;lt;/context-param&amp;gt;

        &amp;lt;!-- 监听者 负责监听HttpSession创建与销毁--&amp;gt;
        &amp;lt;listener&amp;gt;
            &amp;lt;listener-class&amp;gt;demo.servlet.HttpSessionListenerDemo&amp;lt;/listener-class&amp;gt;
        &amp;lt;/listener&amp;gt;

        &amp;lt;!-- 登录servlet --&amp;gt;
        &amp;lt;servlet&amp;gt;
            &amp;lt;servlet-name&amp;gt;http-demo&amp;lt;/servlet-name&amp;gt;
            &amp;lt;servlet-class&amp;gt;demo.servlet.HttpServletDemo&amp;lt;/servlet-class&amp;gt;

            &amp;lt;load-on-startup&amp;gt;1&amp;lt;/load-on-startup&amp;gt;
        &amp;lt;/servlet&amp;gt;

        &amp;lt;servlet-mapping&amp;gt;
            &amp;lt;servlet-name&amp;gt;http-demo&amp;lt;/servlet-name&amp;gt;
            &amp;lt;url-pattern&amp;gt;/http-demo&amp;lt;/url-pattern&amp;gt;
        &amp;lt;/servlet-mapping&amp;gt;
    
&amp;lt;/web-app&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;创建监听器类：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * HttpSession监听器测试：统计当前服务器在线人数
 */
public class HttpSessionListenerDemo implements javax.servlet.http.HttpSessionListener {
    @Override
    public void sessionCreated(javax.servlet.http.HttpSessionEvent httpSessionEvent) {
        SessionStatics.increase();
    }

    @Override
    public void sessionDestroyed(javax.servlet.http.HttpSessionEvent httpSessionEvent) {
        SessionStatics.decrease();
    }
}

/**
 * 计数类
 */
public  class SessionStatics {
    private  static volatile Long count=0L;

    public static void increase(){
        synchronized (SessionStatics.class) {
            count++;
        }
    }

    public static void decrease(){
        synchronized (SessionStatics.class) {
            count--;
        }
    }

    public static Long getCount(){
        return count;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;创建用户登录的servlet代码：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * HttpServlet模拟一个登录页面
 *
 * @author zhuhuix
 * @date 2020-08-28
 */
public class HttpServletDemo extends HttpServlet {

    // 重写Get请求方法,返回一个表单页面
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException, ServletException {
        req.setAttribute(&quot;title&quot;, getServletContext().getInitParameter(&quot;title&quot;));
        req.getRequestDispatcher(&quot;/form.jsp&quot;).forward(req, resp);

    }

    // 重写Post请求方法，提交表单上的数据，并返回结果页面
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {

        String name = req.getParameter(&quot;name&quot;);
        Integer password = Integer.parseInt(req.getParameter(&quot;password&quot;));
        if (name != null &amp;amp;&amp;amp; password != null) {
            // checkUserAndPassword
            req.setAttribute(&quot;name&quot;, name);

            req.setAttribute(&quot;result&quot;,&quot;登录成功,当前在线人数:&quot;+SessionStatics.getCount());

            RequestDispatcher view = req.getRequestDispatcher(&quot;/result.jsp&quot;);
            view.forward(req, resp);
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;设计用户登录与登录结果的视图页面：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!--表单页面--&amp;gt;
&amp;lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&amp;gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;zh-CN&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&amp;gt;
    &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css&quot;
          integrity=&quot;sha384-HSMxcRTRxnN+Bdg0JdbxYKrThecOKuH5zCYotlSAcp1+c8xmyTe9GYg1l9a69psu&quot; crossorigin=&quot;anonymous&quot;&amp;gt;
    &amp;lt;script src=&quot;https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js&quot;
            integrity=&quot;sha384-B4gt1jrGC7Jh4AgTPSdUtOBvfO8shuf57BaghqFfPlYxofvL8/KUEfYiJOMMV+rV&quot;
            crossorigin=&quot;anonymous&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;title&amp;gt;${title}用户登录&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;div class=&quot;container&quot;&amp;gt;

    &amp;lt;form role=&quot;form&quot; method=&quot;post&quot; action=&quot;http-demo&quot; class=&quot;form-horizontal&quot;&amp;gt;
        &amp;lt;div class=&quot;form-group&quot;&amp;gt;
            &amp;lt;h4 class=&quot;col-sm-3 col-sm-offset-3&quot;&amp;gt;用户登录&amp;lt;/h4&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;div class=&quot;form-group&quot;&amp;gt;
            &amp;lt;label class=&quot;col-sm-3 control-label&quot;&amp;gt;用户名&amp;lt;/label&amp;gt;
            &amp;lt;div class=&quot;col-sm-3&quot;&amp;gt;
                &amp;lt;input name=&quot;name&quot; type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;请输入用户名&quot;&amp;gt;
            &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;div class=&quot;form-group&quot;&amp;gt;
            &amp;lt;label class=&quot;col-sm-3 control-label&quot;&amp;gt;密码&amp;lt;/label&amp;gt;
            &amp;lt;div class=&quot;col-sm-3&quot;&amp;gt;
                &amp;lt;input name=&quot;password&quot; type=&quot;password&quot; class=&quot;form-control&quot; placeholder=&quot;请输入密码&quot;&amp;gt;
            &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;

        &amp;lt;div class=&quot;form-group&quot;&amp;gt;
            &amp;lt;div class=&quot;col-sm-3 col-sm-offset-3&quot;&amp;gt;
                &amp;lt;button class=&quot;btn btn-primary&quot;&amp;gt;点击登录&amp;lt;/button&amp;gt;
            &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/form&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!--结果页面--&amp;gt;
&amp;lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&amp;gt;
    &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css&quot;
          integrity=&quot;sha384-HSMxcRTRxnN+Bdg0JdbxYKrThecOKuH5zCYotlSAcp1+c8xmyTe9GYg1l9a69psu&quot; crossorigin=&quot;anonymous&quot;&amp;gt;
    &amp;lt;script src=&quot;https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js&quot;
            integrity=&quot;sha384-B4gt1jrGC7Jh4AgTPSdUtOBvfO8shuf57BaghqFfPlYxofvL8/KUEfYiJOMMV+rV&quot;
            crossorigin=&quot;anonymous&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;title&amp;gt;${title}登录结果&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;div class=&quot;container&quot;&amp;gt;

    &amp;lt;div class=&quot;row&quot;&amp;gt;
        &amp;lt;h3 class=&quot;col-sm-3 col-sm-offset-3&quot;&amp;gt;登录结果&amp;lt;/h3&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;row&quot;&amp;gt;
        &amp;lt;label class=&quot;col-sm-3 col-sm-offset-3&quot;&amp;gt;姓名：${name} &amp;lt;/label&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;row&quot;&amp;gt;
        &amp;lt;label class=&quot;col-sm-3 col-sm-offset-3&quot;&amp;gt; ${result}&amp;lt;/label&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;

&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;结果演示：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200828105731199.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pwZ3podQ==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200828105752547.png#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200828105821613.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pwZ3podQ==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200828105840919.png#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;72-特殊的监听器&quot;&gt;7.2 特殊的监听器&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;HttpSessionBindingListener监听器可以JavaBean对象感知自己被绑定到Session中和从Session中删除；且该监听器不需要在web.xml声明。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class User implements javax.servlet.http.HttpSessionBindingListener {
    private String name;

    public User(String name){
        this.name=name;
    }

    @Override
    public void valueBound(HttpSessionBindingEvent httpSessionBindingEvent) {
        System.out.println(name+&quot;加入session&quot;);
    }

    @Override
    public void valueUnbound(HttpSessionBindingEvent httpSessionBindingEvent) {
        System.out.println(name+&quot;移出session&quot;);
    }
}

 @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp){
                ...
        // 测试HttpSessionBindingListener
        req.getSession().setAttribute(&quot;user&quot;,new User(name));
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200828114537285.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pwZ3podQ==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;八、过滤器&quot;&gt;八、过滤器&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;过滤器&lt;kbd&gt;Filter&lt;/kbd&gt;允许你拦截请求和响应，通过编写和配置一个过滤器，可以完成一些全局性的操作：比如安全验证、统一编 码处理、敏感字过滤等。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;Servlet API中提供了一个Filter接口，开发web应用时，如果编写的Java类实现了这个接口，则把这个java类称之为过滤器Filter。&lt;/li&gt;
&lt;li&gt;通过Filter技术，开发人员可以实现用户在访问某个目标资源之前，对访问的请求和响应进行拦截。简单说，就是可以实现web容器对某资源的访问前截获进行相关的处理，还可以在某资源向web容器返回响应前进行截获进行处理。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200830142153692.png#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;81-过滤器的使用方法&quot;&gt;8.1 过滤器的使用方法&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;定义一个类，实现接口Filter，并 重写Filter接口类的方法；&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * 过滤器例子
 */
public class FilterDemo implements Filter {
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {

    }

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        // 过滤
        System.out.println(&quot;拦截过滤...&quot;);
        // 放行请求
        filterChain.doFilter(servletRequest,servletResponse);
    }

    @Override
    public void destroy() {

    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;配置过滤器拦截路径。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;!-- web.xml --&amp;gt;
    &amp;lt;!-- 过滤器配置 --&amp;gt;
    &amp;lt;filter&amp;gt;
        &amp;lt;filter-name&amp;gt;filterDemo&amp;lt;/filter-name&amp;gt;
        &amp;lt;filter-class&amp;gt;demo.filter.FilterDemo&amp;lt;/filter-class&amp;gt;
    &amp;lt;/filter&amp;gt;

    &amp;lt;filter-mapping&amp;gt;
        &amp;lt;filter-name&amp;gt;filterDemo&amp;lt;/filter-name&amp;gt;
        &amp;lt;!-- 拦截路径 --&amp;gt;
        &amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt;
    &amp;lt;/filter-mapping&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;82-过滤器的执行流程&quot;&gt;8.2 过滤器的执行流程&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;当Web容器接受到一个对资源路径的请求时，会判断是否有过滤器与这个资源路径相关联。如果有，就把请求交给过滤器进行处理。&lt;/li&gt;
&lt;li&gt;在过滤器程序中，可以改变请求的内容，或者重新设置请求的头信息等操作，然后对请求放行发送给对应目标资源；当目标资源完成响应后，容器再次会将响应转发给过滤器，这时候可以对响应的内容进行处理，然后再将响应发送到客户端.。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200830145339333.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pwZ3podQ==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;       @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        // 前置过滤
        System.out.println(&quot;拦截过滤{pre}&quot;);
        // 放行请求
        filterChain.doFilter(servletRequest,servletResponse);
        // 后置过滤
        System.out.println(&quot;拦截过滤{post}&quot;);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200830145555889.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pwZ3podQ==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;83-过滤器的生命周期&quot;&gt;8.3 过滤器的生命周期&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;初始化&lt;kbd&gt;init&lt;/kbd&gt;：服务器启动时，进行创建Filter对象，然后调用init方法；该过程只执行一次，一般用于加载资源。&lt;/li&gt;
&lt;li&gt;拦截过滤&lt;kbd&gt;doFilter&lt;/kbd&gt;：每一次请求被都会被执行。&lt;/li&gt;
&lt;li&gt;销毁&lt;kbd&gt;destroy&lt;/kbd&gt;：服务器正常关闭时，Filter对象会被销毁。该过程只执行一次，一般用于释放资源。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;84-过滤器的拦截配置&quot;&gt;8.4 过滤器的拦截配置&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;拦截路径配置：&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;拦截具体资源：比如/index.jsp，只有访问index.jsp资源时，过滤器才会执行。&lt;/li&gt;
&lt;li&gt;拦截网站目录：/demo ，访问网站的demo目录下的资源时，过滤器才会执行。&lt;/li&gt;
&lt;li&gt;后缀名拦截：比如 *.jsp，访问所有后缀名为jsp资源时，过滤器会执行。&lt;/li&gt;
&lt;li&gt;拦截所有资源：比如/*，访问网站下所有资源时，过滤器都会执行。&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;        &amp;lt;!-- 拦截具体资源 --&amp;gt;
        &amp;lt;filter-mapping&amp;gt;
        &amp;lt;filter-name&amp;gt;filterDemo&amp;lt;/filter-name&amp;gt;
        &amp;lt;url-pattern&amp;gt;/form.jsp&amp;lt;/url-pattern&amp;gt;
    &amp;lt;/filter-mapping&amp;gt;
        &amp;lt;!-- 拦截网站目录 --&amp;gt;
    &amp;lt;filter-mapping&amp;gt;
        &amp;lt;filter-name&amp;gt;filterDemo&amp;lt;/filter-name&amp;gt;
        &amp;lt;url-pattern&amp;gt;/demo&amp;lt;/url-pattern&amp;gt;
    &amp;lt;/filter-mapping&amp;gt;
        &amp;lt;!-- 后缀名拦截 --&amp;gt;
    &amp;lt;filter-mapping&amp;gt;
        &amp;lt;filter-name&amp;gt;filterDemo&amp;lt;/filter-name&amp;gt;
        &amp;lt;url-pattern&amp;gt;*.jsp&amp;lt;/url-pattern&amp;gt;
    &amp;lt;/filter-mapping&amp;gt;
        &amp;lt;!-- 拦截所有资源 --&amp;gt;
    &amp;lt;filter-mapping&amp;gt;
        &amp;lt;filter-name&amp;gt;filterDemo&amp;lt;/filter-name&amp;gt;
        &amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt;
    &amp;lt;/filter-mapping&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;拦截方式配置：&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;REQUEST : 浏览器直接请求时，过滤器才会执行。&lt;/li&gt;
&lt;li&gt;FORWARD： 只有转发访问时，过滤器才会执行。&lt;/li&gt;
&lt;li&gt;INCLUDE：包含访问资源时，过滤器才会执行。&lt;/li&gt;
&lt;li&gt;ERROR：错误跳转资源时，过滤器才会执行。&lt;/li&gt;
&lt;li&gt;ASYNC：异步访问资源时，过滤器才会执行。&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt; &amp;lt;!-- 过滤器配置 --&amp;gt;
    &amp;lt;filter&amp;gt;
        &amp;lt;filter-name&amp;gt;filterDemo&amp;lt;/filter-name&amp;gt;
        &amp;lt;filter-class&amp;gt;demo.filter.FilterDemo&amp;lt;/filter-class&amp;gt;
    &amp;lt;/filter&amp;gt;

    &amp;lt;filter-mapping&amp;gt;
        &amp;lt;filter-name&amp;gt;filterDemo&amp;lt;/filter-name&amp;gt;
        &amp;lt;url-pattern&amp;gt;/http-demo&amp;lt;/url-pattern&amp;gt;
        &amp;lt;!-- 浏览器直接请求时，过滤器会执行 --&amp;gt;
        &amp;lt;dispatcher&amp;gt;REQUEST&amp;lt;/dispatcher&amp;gt;
        &amp;lt;!-- 转发请求时，过滤器会执行 --&amp;gt;
        &amp;lt;dispatcher&amp;gt;FORWARD&amp;lt;/dispatcher&amp;gt;
    &amp;lt;/filter-mapping&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;85-过滤器链&quot;&gt;8.5 过滤器链&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;过滤器可以链到一起，一个接一个地运行。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200830154033459.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pwZ3podQ==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;在web.xml中，哪个过滤器的filter-mapping先配置，则哪个过滤器先执行&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;!-- 过滤器配置  --&amp;gt;
    &amp;lt;filter&amp;gt;
        &amp;lt;filter-name&amp;gt;filterDemo1&amp;lt;/filter-name&amp;gt;
        &amp;lt;filter-class&amp;gt;demo.filter.FilterDemo&amp;lt;/filter-class&amp;gt;
    &amp;lt;/filter&amp;gt;
    &amp;lt;!-- 哪个过滤器的filter-mapping先配置，则哪个过滤器先执行--&amp;gt;
    &amp;lt;filter-mapping&amp;gt;
        &amp;lt;filter-name&amp;gt;filterDemo1&amp;lt;/filter-name&amp;gt;
        &amp;lt;url-pattern&amp;gt;/http-demo&amp;lt;/url-pattern&amp;gt;
    &amp;lt;/filter-mapping&amp;gt;

    &amp;lt;filter&amp;gt;
        &amp;lt;filter-name&amp;gt;filterDemo2&amp;lt;/filter-name&amp;gt;
        &amp;lt;filter-class&amp;gt;demo.filter.FilterDemo2&amp;lt;/filter-class&amp;gt;
    &amp;lt;/filter&amp;gt;
    &amp;lt;!-- 哪个过滤器的filter-mapping后配置，则哪个过滤器后执行--&amp;gt;
    &amp;lt;filter-mapping&amp;gt;
        &amp;lt;filter-name&amp;gt;filterDemo2&amp;lt;/filter-name&amp;gt;
        &amp;lt;url-pattern&amp;gt;/http-demo&amp;lt;/url-pattern&amp;gt;
    &amp;lt;/filter-mapping&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200830154924664.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pwZ3podQ==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;85-过滤器的案例--登录验证&quot;&gt;8.5 过滤器的案例--登录验证&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;项目结构&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200830162435220.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pwZ3podQ==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;web.xml配置&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
         version=&quot;4.0&quot;&amp;gt;

    &amp;lt;context-param&amp;gt;
        &amp;lt;param-name&amp;gt;title&amp;lt;/param-name&amp;gt;
        &amp;lt;param-value&amp;gt;购物网站&amp;lt;/param-value&amp;gt;
    &amp;lt;/context-param&amp;gt;

    &amp;lt;!-- 过滤器配置  --&amp;gt;
    &amp;lt;filter&amp;gt;
        &amp;lt;filter-name&amp;gt;loginFilter&amp;lt;/filter-name&amp;gt;
        &amp;lt;filter-class&amp;gt;demo.filter.FilterDemo&amp;lt;/filter-class&amp;gt;
    &amp;lt;/filter&amp;gt;
    &amp;lt;filter-mapping&amp;gt;
        &amp;lt;filter-name&amp;gt;loginFilter&amp;lt;/filter-name&amp;gt;
        &amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt;
    &amp;lt;/filter-mapping&amp;gt;


    &amp;lt;!-- 登录验证servlet --&amp;gt;
    &amp;lt;servlet&amp;gt;
        &amp;lt;servlet-name&amp;gt;loginServlet&amp;lt;/servlet-name&amp;gt;
        &amp;lt;servlet-class&amp;gt;demo.servlet.LoginServlet&amp;lt;/servlet-class&amp;gt;
        &amp;lt;load-on-startup&amp;gt;1&amp;lt;/load-on-startup&amp;gt;
    &amp;lt;/servlet&amp;gt;

    &amp;lt;servlet-mapping&amp;gt;
        &amp;lt;servlet-name&amp;gt;loginServlet&amp;lt;/servlet-name&amp;gt;
        &amp;lt;url-pattern&amp;gt;/login&amp;lt;/url-pattern&amp;gt;
    &amp;lt;/servlet-mapping&amp;gt;

    &amp;lt;!-- 购物车servlet --&amp;gt;
    &amp;lt;servlet&amp;gt;
        &amp;lt;servlet-name&amp;gt;cart&amp;lt;/servlet-name&amp;gt;
        &amp;lt;servlet-class&amp;gt;demo.servlet.CartServlet&amp;lt;/servlet-class&amp;gt;
        &amp;lt;load-on-startup&amp;gt;1&amp;lt;/load-on-startup&amp;gt;
    &amp;lt;/servlet&amp;gt;

    &amp;lt;servlet-mapping&amp;gt;
        &amp;lt;servlet-name&amp;gt;cart&amp;lt;/servlet-name&amp;gt;
        &amp;lt;url-pattern&amp;gt;/cart&amp;lt;/url-pattern&amp;gt;
    &amp;lt;/servlet-mapping&amp;gt;

&amp;lt;/web-app&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;登录程序&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * 购物网站登录页面
 *
 * @author zhuhuix
 * @date 2020-08-30
 */
public class LoginServlet extends HttpServlet {

    // 重写Get请求方法,返回一个登录页面
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException, ServletException {
        req.setAttribute(&quot;title&quot;, getServletContext().getInitParameter(&quot;title&quot;));
        req.getRequestDispatcher(&quot;/form.jsp&quot;).forward(req, resp);

    }

    // 重写Post请求方法，提交用户名与密码
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {

        String name = req.getParameter(&quot;name&quot;);
        Integer password = Integer.parseInt(req.getParameter(&quot;password&quot;));
        if (name != null &amp;amp;&amp;amp; password != null) {
            // 用户登录验证通过后，设置用户名称属性
            req.getSession().setAttribute(&quot;name&quot;,name);
            RequestDispatcher view = req.getRequestDispatcher(&quot;/cart.jsp&quot;);
            view.forward(req, resp);
        }

    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;登录页面&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!--表单页面--&amp;gt;
&amp;lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&amp;gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;zh-CN&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&amp;gt;
    &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css&quot;
          integrity=&quot;sha384-HSMxcRTRxnN+Bdg0JdbxYKrThecOKuH5zCYotlSAcp1+c8xmyTe9GYg1l9a69psu&quot; crossorigin=&quot;anonymous&quot;&amp;gt;
    &amp;lt;script src=&quot;https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js&quot;
            integrity=&quot;sha384-B4gt1jrGC7Jh4AgTPSdUtOBvfO8shuf57BaghqFfPlYxofvL8/KUEfYiJOMMV+rV&quot;
            crossorigin=&quot;anonymous&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;title&amp;gt;${title}用户登录&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;div class=&quot;container&quot;&amp;gt;

    &amp;lt;form role=&quot;form&quot; method=&quot;post&quot; action=&quot;login&quot; class=&quot;form-horizontal&quot;&amp;gt;
        &amp;lt;div class=&quot;form-group&quot;&amp;gt;
            &amp;lt;h4 class=&quot;col-sm-3 col-sm-offset-3&quot;&amp;gt;用户登录&amp;lt;/h4&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;div class=&quot;form-group&quot;&amp;gt;
            &amp;lt;label class=&quot;col-sm-3 control-label&quot;&amp;gt;用户名&amp;lt;/label&amp;gt;
            &amp;lt;div class=&quot;col-sm-3&quot;&amp;gt;
                &amp;lt;input name=&quot;name&quot; type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;请输入用户名&quot;&amp;gt;
            &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;div class=&quot;form-group&quot;&amp;gt;
            &amp;lt;label class=&quot;col-sm-3 control-label&quot;&amp;gt;密码&amp;lt;/label&amp;gt;
            &amp;lt;div class=&quot;col-sm-3&quot;&amp;gt;
                &amp;lt;input name=&quot;password&quot; type=&quot;password&quot; class=&quot;form-control&quot; placeholder=&quot;请输入密码&quot;&amp;gt;
            &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;

        &amp;lt;div class=&quot;form-group&quot;&amp;gt;
            &amp;lt;div class=&quot;col-sm-3 col-sm-offset-3&quot;&amp;gt;
                &amp;lt;button class=&quot;btn btn-primary&quot;&amp;gt;点击登录&amp;lt;/button&amp;gt;
            &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/form&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200830162635124.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pwZ3podQ==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;购物车程序&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * 购物车Servlet
 *
 * @author zhuhuix
 * @date 2020-08-29
 */
public class CartServlet extends javax.servlet.http.HttpServlet {


    // 重写Post请求方法，提交购物车的数据，并返回结果页面
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        // 查找页面上的购物数量，并放入session中

        req.getSession().setAttribute(&quot;phoneNumber&quot;, req.getParameter(&quot;phoneNumber&quot;));
        req.getSession().setAttribute(&quot;pcNumber&quot;, req.getParameter(&quot;pcNumber&quot;));
        req.getSession().setAttribute(&quot;bookNumber&quot;, req.getParameter(&quot;bookNumber&quot;));

        RequestDispatcher view = req.getRequestDispatcher(&quot;/result.jsp&quot;);
        view.forward(req, resp);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;购物车页面&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!--表单页面--&amp;gt;
&amp;lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&amp;gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;zh-CN&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&amp;gt;
    &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css&quot;
          integrity=&quot;sha384-HSMxcRTRxnN+Bdg0JdbxYKrThecOKuH5zCYotlSAcp1+c8xmyTe9GYg1l9a69psu&quot; crossorigin=&quot;anonymous&quot;&amp;gt;
    &amp;lt;script src=&quot;https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js&quot;
            integrity=&quot;sha384-B4gt1jrGC7Jh4AgTPSdUtOBvfO8shuf57BaghqFfPlYxofvL8/KUEfYiJOMMV+rV&quot;
            crossorigin=&quot;anonymous&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;title&amp;gt;${title}购物车&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;div class=&quot;container&quot;&amp;gt;

    &amp;lt;form role=&quot;form&quot; method=&quot;post&quot; action=&quot;cart&quot; class=&quot;form-horizontal&quot;&amp;gt;
        &amp;lt;div class=&quot;form-group&quot;&amp;gt;
            &amp;lt;h4 class=&quot;col-sm-3 col-sm-offset-1&quot;&amp;gt;${name}的购物车&amp;lt;/h4&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;table class=&quot;table table-bordered table-condensed&quot; style=&quot;width: 30%&quot;&amp;gt;
            &amp;lt;thead&amp;gt;
            &amp;lt;tr&amp;gt;
                &amp;lt;td&amp;gt;货物&amp;lt;/td&amp;gt;
                &amp;lt;td&amp;gt;数量&amp;lt;/td&amp;gt;
            &amp;lt;/tr&amp;gt;
            &amp;lt;/thead&amp;gt;
            &amp;lt;tbody&amp;gt;
            &amp;lt;tr&amp;gt;
                &amp;lt;td&amp;gt;手机&amp;lt;/td&amp;gt;
                &amp;lt;td&amp;gt;&amp;lt;input type=&quot;number&quot; name=&quot;phoneNumber&quot; value=${phoneNumber}&amp;gt; &amp;lt;/td&amp;gt;
            &amp;lt;/tr&amp;gt;
            &amp;lt;tr&amp;gt;
                &amp;lt;td&amp;gt;电脑&amp;lt;/td&amp;gt;
                &amp;lt;td&amp;gt;&amp;lt;input type=&quot;number&quot; name=&quot;pcNumber&quot; value=${pcNumber}&amp;gt; &amp;lt;/td&amp;gt;
            &amp;lt;/tr&amp;gt;
            &amp;lt;tr&amp;gt;
                &amp;lt;td&amp;gt;书本&amp;lt;/td&amp;gt;
                &amp;lt;td&amp;gt;&amp;lt;input type=&quot;number&quot; name=&quot;bookNumber&quot; value=${bookNumber}&amp;gt; &amp;lt;/td&amp;gt;
            &amp;lt;/tr&amp;gt;
            &amp;lt;/tbody&amp;gt;
        &amp;lt;/table&amp;gt;

        &amp;lt;div class=&quot;form-group&quot;&amp;gt;
            &amp;lt;div class=&quot;col-sm-1 col-sm-offset-1&quot;&amp;gt;
                &amp;lt;button class=&quot;btn btn-primary&quot;&amp;gt;点击提交&amp;lt;/button&amp;gt;
            &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/form&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200830162812811.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pwZ3podQ==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;程序测试&lt;/li&gt;
&lt;/ul&gt;&lt;ol readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;访问购物车页面：由于用户未登录，则会跳转到登录页面&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200830162945155.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pwZ3podQ==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;用户输入用户名和密码后进行登录，登录成功后会跳转到购物车页面。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200830163047739.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pwZ3podQ==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200830163119195.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pwZ3podQ==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;用户进行购物，并提交购物结果&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200830163152991.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pwZ3podQ==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200830163231793.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pwZ3podQ==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;退出页面，在浏览器中再次访问购物车页面，&lt;strong&gt;可以看到过滤器判断到用户会话存在，已处于登录状态，直接跳转到购物车页面&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200830163312332.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pwZ3podQ==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 31 Aug 2020 00:22:00 +0000</pubDate>
<dc:creator>智慧zhuhuix</dc:creator>
<og:description>一、背景 Java Servlet可以说是一项非常久远的技术了，甚至可以说是Java Web应用的起源。也就是说真正了解了这项技术的原理与实现细节，我们就掌握了Java Web的基础，也对以后能上手基</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhuhuix/p/13587689.html</dc:identifier>
</item>
<item>
<title>归纳从文件中读取数据的六种方法-JAVA IO基础总结第2篇 - 字母哥博客</title>
<link>http://www.cnblogs.com/zimug/p/13587663.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zimug/p/13587663.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202008/1815316-20200831075239150-983540066.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在上一篇文章中，我为大家介绍了&lt;a href=&quot;http://www.zimug.com/java/%E6%80%BB%E7%BB%93java%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%B9%B6%E5%86%99%E6%96%87%E4%BB%B6%E7%9A%84%E4%BA%94%E7%A7%8D%E6%96%B9%E5%BC%8F-java-io%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%E7%AC%AC%E4%B8%80/.html&quot;&gt;《5种创建文件并写入文件数据的方法》&lt;/a&gt;，本节我们为大家来介绍6种从文件中读取数据的方法.&lt;/p&gt;
&lt;blockquote readability=&quot;3.0955414012739&quot;&gt;
&lt;p&gt;另外为了方便大家理解，我为这一篇文章录制了对应的视频：&lt;a href=&quot;https://www.bilibili.com/video/BV1Zp4y1Y76E/&quot;&gt;总结java从文件中读取数据的6种方法-JAVA IO基础总结第二篇&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Scanner&lt;/code&gt;(Java 1.5) 按行读数据及String、Int类型等按分隔符读数据。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Files.lines&lt;/code&gt;, 返回&lt;code&gt;Stream&lt;/code&gt;(Java 8) 流式数据处理，按行读取&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Files.readAllLines&lt;/code&gt;, 返回&lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt;(Java 8)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Files.readString&lt;/code&gt;, 读取&lt;code&gt;String&lt;/code&gt;(Java 11), 文件最大 2G.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Files.readAllBytes&lt;/code&gt;, 读取&lt;code&gt;byte[]&lt;/code&gt;(Java 7), 文件最大 2G.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BufferedReader&lt;/code&gt;, 经典方式 (Java 1.1 -&amp;gt; forever)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;可以说，每一种方法都有自己的适用场景，下文中为大家来一一介绍。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果您看完我的创作，觉得您有帮助的话，请帮忙点赞，您的支持是我不竭的创作动力！&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;1scanner&quot;&gt;1.Scanner&lt;/h2&gt;
&lt;p&gt;第一种方式是Scanner，从JDK1.5开始提供的API，特点是可以按行读取、按分割符去读取文件数据，既可以读取String类型，也可以读取Int类型、Long类型等基础数据类型的数据。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Test
void testReadFile1() throws IOException {
   //文件内容：Hello World|Hello Zimug
   String fileName = &quot;D:\\data\\test\\newFile4.txt&quot;;

   try (Scanner sc = new Scanner(new FileReader(fileName))) {
      while (sc.hasNextLine()) {  //按行读取字符串
         String line = sc.nextLine();
         System.out.println(line);
      }
   }

   try (Scanner sc = new Scanner(new FileReader(fileName))) {
      sc.useDelimiter(&quot;\\|&quot;);  //分隔符
      while (sc.hasNext()) {   //按分隔符读取字符串
         String str = sc.next();
         System.out.println(str);
      }
   }

   //sc.hasNextInt() 、hasNextFloat() 、基础数据类型等等等等。
   //文件内容：1|2
   fileName = &quot;D:\\data\\test\\newFile5.txt&quot;;
   try (Scanner sc = new Scanner(new FileReader(fileName))) {
      sc.useDelimiter(&quot;\\|&quot;);  //分隔符
      while (sc.hasNextInt()) {   //按分隔符读取Int
          int intValue = sc.nextInt();
         System.out.println(intValue);
      }
   }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的方法输出结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Hello World|Hello Zimug
Hello World
Hello Zimug
1
2
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;2fileslines-java-8&quot;&gt;2.Files.lines (Java 8)&lt;/h2&gt;
&lt;p&gt;如果你是需要按行去处理数据文件的内容，这种方式是我推荐大家去使用的一种方式，代码简洁，使用java 8的Stream流将文件读取与文件处理有机融合。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Test
void testReadFile2() throws IOException {
   String fileName = &quot;D:\\data\\test\\newFile.txt&quot;;

   // 读取文件内容到Stream流中，按行读取
   Stream&amp;lt;String&amp;gt; lines = Files.lines(Paths.get(fileName));

   // 随机行顺序进行数据处理
   lines.forEach(ele -&amp;gt; {
      System.out.println(ele);
   });
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;forEach获取Stream流中的行数据不能保证顺序，但速度快。如果你想按顺序去处理文件中的行数据，可以使用forEachOrdered，但处理效率会下降。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 按文件行顺序进行处理
lines.forEachOrdered(System.out::println);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者利用CPU多和的能力，进行数据的并行处理parallel()，适合比较大的文件。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 按文件行顺序进行处理
lines.parallel().forEachOrdered(System.out::println);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也可以把&lt;code&gt;Stream&amp;lt;String&amp;gt;&lt;/code&gt;转换成&lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt;,但是要注意这意味着你要将所有的数据一次性加载到内存，要注意java.lang.OutOfMemoryError&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 转换成List&amp;lt;String&amp;gt;, 要注意java.lang.OutOfMemoryError: Java heap space
List&amp;lt;String&amp;gt; collect = lines.collect(Collectors.toList());
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;3filesreadalllines&quot;&gt;3.Files.readAllLines&lt;/h2&gt;
&lt;p&gt;这种方法仍然是java8 为我们提供的，如果我们不需要&lt;code&gt;Stream&amp;lt;String&amp;gt;&lt;/code&gt;,我们想直接按行读取文件获取到一个&lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt;，就采用下面的方法。同样的问题：这意味着你要将所有的数据一次性加载到内存，要注意java.lang.OutOfMemoryError&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Test
void testReadFile3() throws IOException {
   String fileName = &quot;D:\\data\\test\\newFile3.txt&quot;;

   // 转换成List&amp;lt;String&amp;gt;, 要注意java.lang.OutOfMemoryError: Java heap space
   List&amp;lt;String&amp;gt; lines = Files.readAllLines(Paths.get(fileName),
               StandardCharsets.UTF_8);
   lines.forEach(System.out::println);

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;4filesreadstringjdk-11&quot;&gt;4.Files.readString(JDK 11)&lt;/h2&gt;
&lt;p&gt;从 java11开始，为我们提供了一次性读取一个文件的方法。文件不能超过2G，同时要注意你的服务器及JVM内存。&lt;strong&gt;这种方法适合快速读取小文本文件。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Test
void testReadFile4() throws IOException {
   String fileName = &quot;D:\\data\\test\\newFile3.txt&quot;;

   // java 11 开始提供的方法，读取文件不能超过2G，与你的内存息息相关
   //String s = Files.readString(Paths.get(fileName));
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;5filesreadallbytes&quot;&gt;5.Files.readAllBytes()&lt;/h2&gt;
&lt;p&gt;如果你没有JDK11（readAllBytes()始于JDK7）,仍然想一次性的快速读取一个文件的内容转为String，该怎么办？先将数据读取为二进制数组，然后转换成String内容。&lt;strong&gt;这种方法适合在没有JDK11的请开给你下，快速读取小文本文件。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Test
void testReadFile5() throws IOException {
   String fileName = &quot;D:\\data\\test\\newFile3.txt&quot;;

   //如果是JDK11用上面的方法，如果不是用这个方法也很容易
   byte[] bytes = Files.readAllBytes(Paths.get(fileName));

   String content = new String(bytes, StandardCharsets.UTF_8);
   System.out.println(content);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;6经典管道流的方式&quot;&gt;6.经典管道流的方式&lt;/h2&gt;
&lt;p&gt;最后一种就是经典的管道流的方式&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Test
void testReadFile6() throws IOException {
   String fileName = &quot;D:\\data\\test\\newFile3.txt&quot;;

   // 带缓冲的流读取，默认缓冲区8k
   try (BufferedReader br = new BufferedReader(new FileReader(fileName))){
      String line;
      while ((line = br.readLine()) != null) {
         System.out.println(line);
      }
   }

   //java 8中这样写也可以
   try (BufferedReader br = Files.newBufferedReader(Paths.get(fileName))){
      String line;
      while ((line = br.readLine()) != null) {
         System.out.println(line);
      }
   }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种方式可以通过管道流嵌套的方式，组合使用，比较灵活。比如我们&lt;br/&gt;想从文件中读取java Object就可以使用下面的代码，前提是文件中的数据是ObjectOutputStream写入的数据，才可以用ObjectInputStream来读取。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;try (FileInputStream fis = new FileInputStream(fileName);
     ObjectInputStream ois = new ObjectInputStream(fis)){
   ois.readObject();
} 
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;欢迎关注我的博客，里面有很多精品合集&quot;&gt;欢迎关注我的博客，里面有很多精品合集&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;本文转载注明出处（必须带连接，不能只转文字）：&lt;a href=&quot;http://www.zimug.com&quot;&gt;字母哥博客&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;觉得对您有帮助的话，帮我点赞、分享！您的支持是我不竭的创作动力！&lt;/strong&gt; 。另外，笔者最近一段时间输出了如下的精品内容，期待您的关注。&lt;/p&gt;
</description>
<pubDate>Sun, 30 Aug 2020 23:53:00 +0000</pubDate>
<dc:creator>字母哥博客</dc:creator>
<og:description>在上一篇文章中，我为大家介绍了《5种创建文件并写入文件数据的方法》，本节我们为大家来介绍6种从文件中读取数据的方法. 另外为了方便大家理解，我为这一篇文章录制了对应的视频：总结java从文件中读取数据</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zimug/p/13587663.html</dc:identifier>
</item>
<item>
<title>我工作三年了，该懂并发了！ - 程序员cxuan</title>
<link>http://www.cnblogs.com/cxuanBlog/p/13587632.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cxuanBlog/p/13587632.html</guid>
<description>&lt;p&gt;本文的组织形式如下，主要会介绍到同步容器类，操作系统的并发工具，Java 开发工具包（只是简单介绍一下，后面会有源码分析）。同步工具类有哪些。&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/08/31/dLucNT.png&quot; alt=&quot;101&quot; border=&quot;0&quot;/&gt;&lt;p&gt;下面我们就来介绍一下 Java 并发中都涉及哪些模块，这些并发模块都是 Java 并发类库所提供的。&lt;/p&gt;
&lt;h2 id=&quot;同步容器类&quot;&gt;同步容器类&lt;/h2&gt;
&lt;p&gt;同步容器主要包括两类，一种是本来就是线程安全实现的容器，这类容器有 &lt;strong&gt;Vector、Hashtable、Stack&lt;/strong&gt;，这类容器的方法上都加了 &lt;code&gt;synchronized&lt;/code&gt; 锁，是线程安全的实现。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Vector、Hashtable、Stack 这些容器我们现在几乎都不在使用，因为这些容器在多线程环境下的效率不高。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;还有一类是由 &lt;code&gt;Collections.synchronizedxxx&lt;/code&gt; 实现的非线程安全的容器，使用 Collections.synchronized 会把它们封装起来编程线程安全的容器，举出两个例子&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Collections.synchronizedList&lt;/li&gt;
&lt;li&gt;Collections.synchronizedMap&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们可以通过 Collections 源码可以看出这些线程安全的实现&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/08/31/dLu6EV.png&quot; alt=&quot;102&quot; border=&quot;0&quot;/&gt;&lt;p&gt;要不为啥要称 Collections 为集合工具类呢？Collections 会把这些容器类的状态封装起来，并对每个同步方法进行同步，使得每次只有一个线程能够访问容器的状态。&lt;/p&gt;
&lt;p&gt;其中每个 &lt;code&gt;synchronized xxx&lt;/code&gt; 都是相当于创建了一个静态内部类。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202008/1515111-20200831071605104-921937049.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;虽然同步容器类都是线程安全的，但是在某些情况下需要额外的客户端加锁来保证一些复合操作的安全性，复合操作就是有两个及以上的方法组成的操作，比如最典型的就是 &lt;code&gt;若没有则添加&lt;/code&gt;，用伪代码表示则是&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;if(a == null){
  a = get();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;比如可以用来判断 Map 中是否有某个 key，如果没有则添加进 Map 中。这些复合操作在没有客户端加锁的情况下是线程安全的，但是当多个线程并发修改容器时，可能会表现出意料之外的行为。例如下面这段代码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class TestVector implements Runnable{

    static Vector vector = new Vector();
    static void addVector(){
        for(int i = 0;i &amp;lt; 10000;i++){
            vector.add(i);
        }
    }

    static Object getVector(){
        int index = vector.size() - 1;
        return vector.get(index);
    }

    static void removeVector(){
        int index = vector.size() - 1;
        vector.remove(index);
    }

    @Override
    public void run() {
        getVector();
    }

    public static void main(String[] args) {
        TestVector testVector = new TestVector();
        testVector.addVector();
        Thread t1 = new Thread(() -&amp;gt; {
            for(int i = 0;i &amp;lt; vector.size();i++){
                getVector();
            }
        });

        Thread t2 = new Thread(() -&amp;gt; {
            for(int i = 0;i &amp;lt; vector.size();i++){
                removeVector();
            }
        });

        t1.start();
        t2.start();
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这些方法看似没有问题，因为 Vector 能够保证线程安全性，无论多少个线程访问 Vector 也不会造成 Vector 的内部产生破坏，但是从整个系统来说，是存在线程安全性的，事实上你运行一下，也会发现报错。&lt;/p&gt;
&lt;p&gt;会出现&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/08/31/dLusH0.png&quot; alt=&quot;104&quot; border=&quot;0&quot;/&gt;&lt;p&gt;如果线程 A 在包含这么多元素的基础上调用 &lt;code&gt;getVector&lt;/code&gt; 方法，会得到一个数值，getVector 只是取得该元素，而并不是从 vector 中移除，&lt;code&gt;removeVector&lt;/code&gt; 方法是得到一个元素进行移除，这段代码的不安全因素就是，因为线程的时间片是乱序的，而且 getVector 和 removeVector 并不会保证互斥，所以在 removeVector 方法把某个值比如 6666 移除后，vector 中就不存在这个 6666 的元素，此时 getVector 方法取得 6666 ，就会抛出数组越界异常。为什么是数组越界异常呢？可以看一下 vector 的源码&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/08/31/dLuwcj.png&quot; alt=&quot;105&quot; border=&quot;0&quot;/&gt;&lt;p&gt;如果用图表示的话，则会是下面这样。&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/08/31/dLuDun.png&quot; alt=&quot;106&quot; border=&quot;0&quot;/&gt;&lt;p&gt;所以，从系统的层面来看，上面这段代码也要保证线程安全性才可以，也就是在&lt;code&gt;客户端加锁&lt;/code&gt; 实现，只要我们让复合操作使用一把锁，那么这些操作就和其他单独的操作一样都是原子性的。如下面例子所示&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;static Object getVector(){
  synchronized (vector){
    int index = vector.size() - 1;
    return vector.get(index);
  }
}

static void removeVector(){
  synchronized (vector) {
    int index = vector.size() - 1;
    vector.remove(index);
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也可以通过锁住 &lt;code&gt;.class&lt;/code&gt; 来保证原子性操作，也能达到同样的效果。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;static Object getVector(){
  synchronized (TestVector.class){
    int index = vector.size() - 1;
    return vector.get(index);
  }
}

static void removeVector(){
  synchronized (TestVector.class) {
    int index = vector.size() - 1;
    vector.remove(index);
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在调用 size 和 get 之间，Vector 的长度可能会发生变化，这种变化在对 Vector 进行排序时出现，如下所示&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;for(int i = 0;i&amp;lt; vector.size();i++){
  doSomething(vector.get(i));
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种迭代的操作正确性取决于运气，即在调用 size 和 get 之间会修改 Vector，在单线程环境中，这种假设完全成立，但是再有其他线程并发修改 Vector 时，则可能会导致麻烦。&lt;/p&gt;
&lt;p&gt;我们仍旧可以通过客户端加锁的方式来避免这种情况&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;synchronized(vector){
  for(int i = 0;i&amp;lt; vector.size();i++){
    doSomething(vector.get(i));
  }  
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种方式为客户端的可靠性提供了保证，但是牺牲了伸缩性，而且这种在遍历过程中进行加锁，也不是我们所希望看到的。&lt;/p&gt;
&lt;h3 id=&quot;fail-fast&quot;&gt;fail-fast&lt;/h3&gt;
&lt;p&gt;针对上面这种情况，很多集合类都提供了一种 &lt;code&gt;fail-fast&lt;/code&gt; 机制，因为大部分集合内部都是使用 Iterator 进行遍历，在循环中使用同步锁的开销会很大，而 Iterator 的创建是轻量级的，所以在集合内部如果有并发修改的操作，集合会进行&lt;code&gt;快速失败&lt;/code&gt;，也就是 &lt;code&gt;fail-fast&lt;/code&gt;。当他们发现容器在迭代过程中被修改时，会抛出 &lt;code&gt;ConcurrentModificationException&lt;/code&gt; 异常，这种快速失败不是一种完备的处理机制，而只是 &lt;code&gt;善意&lt;/code&gt;的捕获并发错误。&lt;/p&gt;
&lt;p&gt;如果查看过 ConcurrentModificationException 的注解，你会发现，ConcurrentModificationException 抛出的原则由两种，如下&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/08/31/dLurBq.png&quot; alt=&quot;107&quot; border=&quot;0&quot;/&gt;&lt;p&gt;造成这种异常的原因是由于多个线程在遍历集合的同时对集合类内部进行了修改，这也就是 fail-fast 机制。&lt;/p&gt;
&lt;p&gt;该注解还声明了另外一种方式&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/08/31/dLu0js.png&quot; alt=&quot;108&quot; border=&quot;0&quot;/&gt;&lt;p&gt;这个问题也是很经典的一个问题，我们使用 ArrayList 来举例子。如下代码所示&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static void main(String[] args) {
  List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
  for (int i = 0 ; i &amp;lt; 10 ; i++ ) {
    list.add(i + &quot;&quot;);
  }
  Iterator&amp;lt;String&amp;gt; iterator = list.iterator();
  int i = 0 ;
  while(iterator.hasNext()) {
    if (i == 3) {
      list.remove(3);
    }
    System.out.println(iterator.next());
    i ++;
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该段代码会发生异常，因为在 ArrayList 内部，有两个属性，一个是 &lt;code&gt;modCount&lt;/code&gt; ，一个是 &lt;code&gt;expectedModCount&lt;/code&gt; ，ArrayList 在 remove 等对集合结构的元素造成数量上的操作会有 &lt;code&gt;checkForComodification&lt;/code&gt; 的判断，如下所示，这也是这段代码的错误原因。&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/08/31/dLua9g.png&quot; alt=&quot;109&quot; border=&quot;0&quot;/&gt;&lt;h3 id=&quot;fail-safe&quot;&gt;fail-safe&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;fail-safe&lt;/code&gt; 是 Java 中的一种 &lt;code&gt;安全失败&lt;/code&gt; 机制，它表示的是在遍历时不是直接在原集合上进行访问，而是先复制原有集合内容，在拷贝的集合上进行遍历。 由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发 ConcurrentModificationException。&lt;code&gt;java.util.concurrent&lt;/code&gt; 包下的容器都是安全失败的，可以在多线程条件下使用，并发修改。&lt;/p&gt;
&lt;p&gt;比如 &lt;code&gt;CopyOnWriteArrayList&lt;/code&gt;， 它就是一种 fail-safe 机制的集合，它就不会出现异常，例如如下操作&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;List&amp;lt;Integer&amp;gt; integers = new CopyOnWriteArrayList&amp;lt;&amp;gt;();
integers.add(1);
integers.add(2);
integers.add(3);
Iterator&amp;lt;Integer&amp;gt; itr = integers.iterator();
while (itr.hasNext()) {
    Integer a = itr.next();
    integers.remove(a);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;CopyOnWriteArrayList 就是 ArrayList 的一种线程安全的变体，CopyOnWriteArrayList 中的所有可变操作比如 add 和 set 等等都是通过对数组进行全新复制来实现的。&lt;/p&gt;
&lt;h2 id=&quot;操作系统中的并发工具&quot;&gt;操作系统中的并发工具&lt;/h2&gt;
&lt;p&gt;讲到并发容器，就不得不提操作系统级别实现了哪些进程/线程间的并发容器，说白了其实就是数据结构的设计。下面我们就来一起看一下操作系统级别的并发工具&lt;/p&gt;
&lt;h3 id=&quot;信号量&quot;&gt;信号量&lt;/h3&gt;
&lt;p&gt;信号量是 E.W.Dijkstra 在 1965 年提出的一种方法，它使用一个整形变量来累计唤醒次数，以供之后使用。在他的观点中，有一个新的变量类型称作 &lt;code&gt;信号量(semaphore)&lt;/code&gt;。一个信号量的取值可以是 0 ，或任意正数。0 表示的是不需要任何唤醒，任意的正数表示的就是唤醒次数。&lt;/p&gt;
&lt;p&gt;Dijkstra 提出了信号量有两个操作，现在通常使用 &lt;code&gt;down&lt;/code&gt; 和 &lt;code&gt;up&lt;/code&gt;（分别可以用 sleep 和 wakeup 来表示）。down 这个指令的操作会检查值是否大于 0 。如果大于 0 ，则将其值减 1 ；若该值为 0 ，则进程将睡眠，而且此时 down 操作将会继续执行。检查数值、修改变量值以及可能发生的睡眠操作均为一个单一的、不可分割的 &lt;code&gt;原子操作(atomic action)&lt;/code&gt; 完成。&lt;/p&gt;
&lt;h3 id=&quot;互斥量&quot;&gt;互斥量&lt;/h3&gt;
&lt;p&gt;如果不需要信号量的计数能力时，可以使用信号量的一个简单版本，称为 &lt;code&gt;mutex(互斥量)&lt;/code&gt;。互斥量的优势就在于在一些共享资源和一段代码中保持互斥。由于互斥的实现既简单又有效，这使得互斥量在实现用户空间线程包时非常有用。&lt;/p&gt;
&lt;p&gt;互斥量是一个处于两种状态之一的共享变量：&lt;code&gt;解锁(unlocked)&lt;/code&gt; 和 &lt;code&gt;加锁(locked)&lt;/code&gt;。这样，只需要一个二进制位来表示它，不过一般情况下，通常会用一个 &lt;code&gt;整型(integer)&lt;/code&gt; 来表示。0 表示解锁，其他所有的值表示加锁，比 1 大的值表示加锁的次数。&lt;/p&gt;
&lt;p&gt;mutex 使用两个过程，当一个线程（或者进程）需要访问关键区域时，会调用 &lt;code&gt;mutex_lock&lt;/code&gt; 进行加锁。如果互斥锁当前处于解锁状态（表示关键区域可用），则调用成功，并且调用线程可以自由进入关键区域。&lt;/p&gt;
&lt;p&gt;另一方面，如果 mutex 互斥量已经锁定的话，调用线程会阻塞直到关键区域内的线程执行完毕并且调用了 &lt;code&gt;mutex_unlock&lt;/code&gt; 。如果多个线程在 mutex 互斥量上阻塞，将随机选择一个线程并允许它获得锁。&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/08/31/dLud3Q.png&quot; alt=&quot;110&quot; border=&quot;0&quot;/&gt;&lt;h4 id=&quot;futexes&quot;&gt;Futexes&lt;/h4&gt;
&lt;p&gt;随着并行的增加，有效的&lt;code&gt;同步(synchronization)&lt;/code&gt;和&lt;code&gt;锁定(locking)&lt;/code&gt; 对于性能来说是非常重要的。如果进程等待时间很短，那么&lt;code&gt;自旋锁(Spin lock)&lt;/code&gt; 是非常有效；但是如果等待时间比较长，那么这会浪费 CPU 周期。如果进程很多，那么阻塞此进程，并仅当锁被释放的时候让内核解除阻塞是更有效的方式。不幸的是，这种方式也会导致另外的问题：它可以在进程竞争频繁的时候运行良好，但是在竞争不是很激烈的情况下内核切换的消耗会非常大，而且更困难的是，预测锁的竞争数量更不容易。&lt;/p&gt;
&lt;p&gt;有一种有趣的解决方案是把两者的优点结合起来，提出一种新的思想，称为 &lt;code&gt;futex&lt;/code&gt;，或者是 &lt;code&gt;快速用户空间互斥(fast user space mutex)&lt;/code&gt;，是不是听起来很有意思？&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/08/31/dLuN4S.png&quot; alt=&quot;111&quot; border=&quot;0&quot;/&gt;&lt;p&gt;futex 是 &lt;code&gt;Linux&lt;/code&gt; 中的特性实现了基本的锁定（很像是互斥锁）而且避免了陷入内核中，因为内核的切换的开销非常大，这样做可以大大提高性能。futex 由两部分组成：&lt;strong&gt;内核服务和用户库&lt;/strong&gt;。内核服务提供了了一个 &lt;code&gt;等待队列(wait queue)&lt;/code&gt; 允许多个进程在锁上排队等待。除非内核明确的对他们解除阻塞，否则它们不会运行。&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/08/31/dLuYAf.png&quot; alt=&quot;112&quot; border=&quot;0&quot;/&gt;&lt;h4 id=&quot;pthreads-中的互斥量&quot;&gt;Pthreads 中的互斥量&lt;/h4&gt;
&lt;p&gt;Pthreads 提供了一些功能用来同步线程。最基本的机制是使用互斥量变量，可以锁定和解锁，用来保护每个关键区域。希望进入关键区域的线程首先要尝试获取 mutex。如果 mutex 没有加锁，线程能够马上进入并且互斥量能够自动锁定，从而阻止其他线程进入。如果 mutex 已经加锁，调用线程会阻塞，直到 mutex 解锁。如果多个线程在相同的互斥量上等待，当互斥量解锁时，只有一个线程能够进入并且重新加锁。这些锁并不是必须的，程序员需要正确使用它们。&lt;/p&gt;
&lt;p&gt;下面是与互斥量有关的函数调用&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/08/31/dLutN8.png&quot; alt=&quot;113&quot; border=&quot;0&quot;/&gt;&lt;p&gt;和我们想象中的一样，mutex 能够被创建和销毁，扮演这两个角色的分别是 &lt;code&gt;Phread_mutex_init&lt;/code&gt; 和 &lt;code&gt;Pthread_mutex_destroy&lt;/code&gt;。mutex 也可以通过 &lt;code&gt;Pthread_mutex_lock&lt;/code&gt; 来进行加锁，如果互斥量已经加锁，则会阻塞调用者。还有一个调用&lt;code&gt;Pthread_mutex_trylock&lt;/code&gt; 用来尝试对线程加锁，当 mutex 已经被加锁时，会返回一个错误代码而不是阻塞调用者。这个调用允许线程有效的进行忙等。最后，&lt;code&gt;Pthread_mutex_unlock&lt;/code&gt; 会对 mutex 解锁并且释放一个正在等待的线程。&lt;/p&gt;
&lt;p&gt;除了互斥量以外，&lt;code&gt;Pthreads&lt;/code&gt; 还提供了第二种同步机制： &lt;code&gt;条件变量(condition variables)&lt;/code&gt; 。mutex 可以很好的允许或阻止对关键区域的访问。条件变量允许线程由于未满足某些条件而阻塞。绝大多数情况下这两种方法是一起使用的。下面我们进一步来研究线程、互斥量、条件变量之间的关联。&lt;/p&gt;
&lt;p&gt;下面再来重新认识一下生产者和消费者问题：一个线程将东西放在一个缓冲区内，由另一个线程将它们取出。如果生产者发现缓冲区没有空槽可以使用了，生产者线程会阻塞起来直到有一个线程可以使用。生产者使用 mutex 来进行原子性检查从而不受其他线程干扰。但是当发现缓冲区已经满了以后，生产者需要一种方法来阻塞自己并在以后被唤醒。这便是条件变量做的工作。&lt;/p&gt;
&lt;p&gt;下面是一些与条件变量有关的最重要的 pthread 调用&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/08/31/dLuGHP.png&quot; alt=&quot;114&quot; border=&quot;0&quot;/&gt;&lt;p&gt;上表中给出了一些调用用来创建和销毁条件变量。条件变量上的主要属性是 &lt;code&gt;Pthread_cond_wait&lt;/code&gt; 和 &lt;code&gt;Pthread_cond_signal&lt;/code&gt;。前者阻塞调用线程，直到其他线程发出信号为止（使用后者调用）。阻塞的线程通常需要等待唤醒的信号以此来释放资源或者执行某些其他活动。只有这样阻塞的线程才能继续工作。条件变量允许等待与阻塞原子性的进程。&lt;code&gt;Pthread_cond_broadcast&lt;/code&gt; 用来唤醒多个阻塞的、需要等待信号唤醒的线程。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;需要注意的是，条件变量（不像是信号量）不会存在于内存中。如果将一个信号量传递给一个没有线程等待的条件变量，那么这个信号就会丢失，这个需要注意&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;管程&quot;&gt;管程&lt;/h3&gt;
&lt;p&gt;为了能够编写更加准确无误的程序，Brinch Hansen 和 Hoare 提出了一个更高级的同步原语叫做 &lt;code&gt;管程(monitor)&lt;/code&gt;。管程有一个很重要的特性，即在任何时候管程中只能有一个活跃的进程，这一特性使管程能够很方便的实现互斥操作。管程是编程语言的特性，所以编译器知道它们的特殊性，因此可以采用与其他过程调用不同的方法来处理对管程的调用。通常情况下，当进程调用管程中的程序时，该程序的前几条指令会检查管程中是否有其他活跃的进程。如果有的话，调用进程将被挂起，直到另一个进程离开管程才将其唤醒。如果没有活跃进程在使用管程，那么该调用进程才可以进入。&lt;/p&gt;
&lt;p&gt;进入管程中的互斥由编译器负责，但是一种通用做法是使用 &lt;code&gt;互斥量(mutex)&lt;/code&gt; 和 &lt;code&gt;二进制信号量(binary semaphore)&lt;/code&gt;。由于编译器而不是程序员在操作，因此出错的几率会大大降低。在任何时候，编写管程的程序员都无需关心编译器是如何处理的。他只需要知道将所有的临界区转换成为管程过程即可。绝不会有两个进程同时执行临界区中的代码。&lt;/p&gt;
&lt;p&gt;即使管程提供了一种简单的方式来实现互斥，但在我们看来，这还不够。因为我们还需要一种在进程无法执行被阻塞。在生产者-消费者问题中，很容易将针对缓冲区满和缓冲区空的测试放在管程程序中，但是生产者在发现缓冲区满的时候该如何阻塞呢？&lt;/p&gt;
&lt;p&gt;解决的办法是引入&lt;code&gt;条件变量(condition variables)&lt;/code&gt; 以及相关的两个操作 &lt;code&gt;wait&lt;/code&gt; 和 &lt;code&gt;signal&lt;/code&gt;。当一个管程程序发现它不能运行时（例如，生产者发现缓冲区已满），它会在某个条件变量（如 full）上执行 &lt;code&gt;wait&lt;/code&gt; 操作。这个操作造成调用进程阻塞，并且还将另一个以前等在管程之外的进程调入管程。在前面的 pthread 中我们已经探讨过条件变量的实现细节了。另一个进程，比如消费者可以通过执行 &lt;code&gt;signal&lt;/code&gt; 来唤醒阻塞的调用进程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通过临界区自动的互斥，管程比信号量更容易保证并行编程的正确性&lt;/strong&gt;。但是管程也有缺点，我们前面说到过管程是一个编程语言的概念，编译器必须要识别管程并用某种方式对其互斥作出保证。&lt;strong&gt;C、Pascal 以及大多数其他编程语言都没有管程&lt;/strong&gt;，所以不能依靠编译器来遵守互斥规则。&lt;/p&gt;
&lt;p&gt;与管程和信号量有关的另一个问题是，这些机制都是设计用来解决访问共享内存的一个或多个 CPU 上的互斥问题的。通过将信号量放在共享内存中并用 &lt;code&gt;TSL&lt;/code&gt; 或 &lt;code&gt;XCHG&lt;/code&gt; 指令来保护它们，可以避免竞争。但是如果是在分布式系统中，可能同时具有多个 CPU 的情况，并且每个 CPU 都有自己的私有内存呢，它们通过网络相连，那么这些原语将会失效。因为信号量太低级了，而管程在少数几种编程语言之外无法使用，所以还需要其他方法。&lt;/p&gt;
&lt;h3 id=&quot;消息传递&quot;&gt;消息传递&lt;/h3&gt;
&lt;p&gt;上面提到的其他方法就是 &lt;code&gt;消息传递(messaage passing)&lt;/code&gt;。这种进程间通信的方法使用两个原语 &lt;code&gt;send&lt;/code&gt; 和 &lt;code&gt;receive&lt;/code&gt; ，它们像信号量而不像管程，是系统调用而不是语言级别。示例如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;send(destination, &amp;amp;message);

receive(source, &amp;amp;message);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;send 方法用于向一个给定的目标发送一条消息，receive 从一个给定的源接收一条消息。如果没有消息，接受者可能被阻塞，直到接收一条消息或者带着错误码返回。&lt;/p&gt;
&lt;p&gt;消息传递系统现在面临着许多信号量和管程所未涉及的问题和设计难点，尤其对那些在网络中不同机器上的通信状况。例如，消息有可能被网络丢失。为了防止消息丢失，发送方和接收方可以达成一致：一旦接受到消息后，接收方马上回送一条特殊的 &lt;code&gt;确认(acknowledgement)&lt;/code&gt; 消息。如果发送方在一段时间间隔内未收到确认，则重发消息。&lt;/p&gt;
&lt;p&gt;现在考虑消息本身被正确接收，而返回给发送着的确认消息丢失的情况。发送者将重发消息，这样接受者将收到两次相同的消息。&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/08/31/dLu3nI.png&quot; alt=&quot;115&quot; border=&quot;0&quot;/&gt;&lt;p&gt;对于接收者来说，如何区分新的消息和一条重发的老消息是非常重要的。通常采用在每条原始消息中嵌入一个连续的序号来解决此问题。如果接受者收到一条消息，它具有与前面某一条消息一样的序号，就知道这条消息是重复的，可以忽略。&lt;/p&gt;
&lt;p&gt;消息系统还必须处理如何命名进程的问题，以便在发送或接收调用中清晰的指明进程。&lt;code&gt;身份验证(authentication)&lt;/code&gt; 也是一个问题，比如客户端怎么知道它是在与一个真正的文件服务器通信，从发送方到接收方的信息有可能被中间人所篡改。&lt;/p&gt;
&lt;h3 id=&quot;屏障&quot;&gt;屏障&lt;/h3&gt;
&lt;p&gt;最后一个同步机制是准备用于进程组而不是进程间的生产者-消费者情况的。在某些应用中划分了若干阶段，并且规定，除非所有的进程都就绪准备着手下一个阶段，否则任何进程都不能进入下一个阶段，可以通过在每个阶段的结尾安装一个 &lt;code&gt;屏障(barrier)&lt;/code&gt; 来实现这种行为。当一个进程到达屏障时，它会被屏障所拦截，直到所有的屏障都到达为止。屏障可用于一组进程同步，如下图所示&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/08/31/dLu8Bt.png&quot; alt=&quot;116&quot; border=&quot;0&quot;/&gt;&lt;p&gt;在上图中我们可以看到，有四个进程接近屏障，这意味着每个进程都在进行运算，但是还没有到达每个阶段的结尾。过了一段时间后，A、B、D 三个进程都到达了屏障，各自的进程被挂起，但此时还不能进入下一个阶段呢，因为进程 B 还没有执行完毕。结果，当最后一个 C 到达屏障后，这个进程组才能够进入下一个阶段。&lt;/p&gt;
&lt;h3 id=&quot;避免锁：读-复制-更新&quot;&gt;避免锁：读-复制-更新&lt;/h3&gt;
&lt;p&gt;最快的锁是根本没有锁。问题在于没有锁的情况下，我们是否允许对共享数据结构的并发读写进行访问。答案当然是不可以。假设进程 A 正在对一个数字数组进行排序，而进程 B 正在计算其平均值，而此时你进行 A 的移动，会导致 B 会多次读到重复值，而某些值根本没有遇到过。&lt;/p&gt;
&lt;p&gt;然而，在某些情况下，我们可以允许写操作来更新数据结构，即便还有其他的进程正在使用。窍门在于确保每个读操作要么读取旧的版本，要么读取新的版本，例如下面的树&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/08/31/dLuljA.png&quot; alt=&quot;117&quot; border=&quot;0&quot;/&gt;&lt;p&gt;上面的树中，读操作从根部到叶子遍历整个树。加入一个新节点 X 后，为了实现这一操作，我们要让这个节点在树中可见之前使它&quot;恰好正确&quot;：我们对节点 X 中的所有值进行初始化，包括它的子节点指针。然后通过原子写操作，使 X 称为 A 的子节点。所有的读操作都不会读到前后不一致的版本&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/08/31/dLuQcd.png&quot; alt=&quot;118&quot; border=&quot;0&quot;/&gt;&lt;p&gt;在上面的图中，我们接着移除 B 和 D。首先，将 A 的左子节点指针指向 C 。所有原本在 A 中的读操作将会后续读到节点 C ，而永远不会读到 B 和 D。也就是说，它们将只会读取到新版数据。同样，所有当前在 B 和 D 中的读操作将继续按照原始的数据结构指针并且读取旧版数据。所有操作均能正确运行，我们不需要锁住任何东西。而不需要锁住数据就能够移除 B 和 D 的主要原因就是 &lt;code&gt;读-复制-更新(Ready-Copy-Update,RCU)&lt;/code&gt;，将更新过程中的移除和再分配过程分离开。&lt;/p&gt;
&lt;h2 id=&quot;java-并发工具包&quot;&gt;Java 并发工具包&lt;/h2&gt;
&lt;p&gt;JDK 1.5 提供了许多种并发容器来改进同步容器的性能，同步容器将所有对容器状态的访问都串行化，以实现他们之间的线程安全性。这种方法的代价是严重降低了并发性能，当多个线程争抢容器锁的同时，严重降低吞吐量。&lt;/p&gt;
&lt;p&gt;下面我们就来一起认识一下 Java 中都用了哪些并发工具&lt;/p&gt;
&lt;h3 id=&quot;java-并发工具综述&quot;&gt;Java 并发工具综述&lt;/h3&gt;
&lt;p&gt;在 Java 5.0 中新增加了 &lt;code&gt;ConcurrentHashMap&lt;/code&gt; 用来替代基于散列的 Map 容器；新增加了 &lt;code&gt;CopyOnWriteArrayList&lt;/code&gt; 和 &lt;code&gt;CopyOnWriteArraySet&lt;/code&gt; 来分别替代 ArrayList 和 Set 接口实现类；还新增加了两种容器类型，分别是 &lt;code&gt;Queue&lt;/code&gt; 和 &lt;code&gt;BlockingQueue&lt;/code&gt;， Queue 是队列的意思，它有一些实现分别是传统的先进先出队列 &lt;code&gt;ConcurrentLinkedQueue&lt;/code&gt;以及并发优先级队列 &lt;code&gt;PriorityQueue&lt;/code&gt;。Queue 是一个先入先出的队列，它的操作不会阻塞，如果队列为空那么获取元素的操作会返回空值。PriorityQueue 扩展了 Queue，增加了可阻塞的插入和获取等操作。如果队列为空，那么获取元素的操作将一直阻塞，直到队列中出现一个可用的元素为止。如果队列已满，那么插入操作则一直阻塞，直到队列中有可用的空间为止。&lt;/p&gt;
&lt;p&gt;Java 6.0 还引入了 &lt;code&gt;ConcurrentSkipListMap&lt;/code&gt; 和 &lt;code&gt;ConcurrentSkipListSet&lt;/code&gt; 分别作为同步的 SortedMap 和 SortedSet 的并发替代品。下面我们就展开探讨了，设计不到底层源码，因为本篇文章主要目的就是为了描述一下有哪些东西以及用了哪些东西。&lt;/p&gt;
&lt;h3 id=&quot;concurrenthashmap&quot;&gt;ConcurrentHashMap&lt;/h3&gt;
&lt;p&gt;我们先来看一下 ConcurrentHashMap 在并发集合中的位置&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/08/31/dLuM1H.png&quot; alt=&quot;119&quot; border=&quot;0&quot;/&gt;&lt;p&gt;可以看到，ConcurrentHashMap 继承了 &lt;code&gt;AbstractMap&lt;/code&gt; 接口并实现了 ConcurrentMap 和 Serializable 接口，AbstractMap 和 ConcurrentMap 都是 Map 的实现类，只不过 AbstractMap 是抽象实现。&lt;/p&gt;
&lt;p&gt;ConcurrentHashMap 和 Hashtable 的构造非常相似，只不过 Hashtable 容器在激烈竞争的场景中会表现出效率低下的现象，这是因为所有访问 Hashtable 的线程都想获取同一把锁，如果容器里面有多把锁，并且每一把锁都只用来锁定一段数据，那么当多个线程访问不同的数据段时，就不存在竞争关系。这就是 ConcurreentHashMap 采用的 &lt;code&gt;分段锁&lt;/code&gt; 实现。在这种锁实现中，任意数量的读取线程可以并发的访问 Map，执行读取操作的线程和执行写入的线程可以并发的访问 Map，并且在读取的同时也可以并发修改 Map。&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/08/31/dLuK9e.png&quot; alt=&quot;120&quot; border=&quot;0&quot;/&gt;&lt;p&gt;ConcurrentHashMap 分段锁实现带来的结果是，在并发环境下可以实现更高的吞吐量，在单线程环境下只损失非常小的性能。&lt;/p&gt;
&lt;p&gt;你知道 HashMap 是具有 fail-fast 机制的，也就是说它是一种强一致性的集合，在数据不一致的情况下会抛出 &lt;code&gt;ConcurrentModificationException&lt;/code&gt; 异常，而 ConcurrentHashMap 是一种 &lt;code&gt;弱一致性&lt;/code&gt; 的集合，在并发修改其内部结构时，它不会抛出 ConcurrentModificationException 异常，弱一致性能够容忍并发修改。&lt;/p&gt;
&lt;p&gt;在 HashMap 中，我们一般使用的 size、empty、containsKey 等方法都是标准方法，其返回的结果是一定的，包含就是包含，不包含就是不包含，可以作为判断条件；而 ConcurrentHashMap 中的这些方法只是参考方法，它不是一个 &lt;code&gt;精确值&lt;/code&gt;，像是 size、empty 这些方法在并发场景下用处很小，因为他们的返回值总是在不断变化，所以这些操作的需求就被弱化了。&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/08/31/dLunhD.png&quot; alt=&quot;121&quot; border=&quot;0&quot;/&gt;&lt;p&gt;在 ConcurrentHashMap 中没有实现对 Map 加锁从而实现独占访问。在线程安全的 Map 实现 &lt;code&gt;Hashtable&lt;/code&gt; 和 &lt;code&gt;Collections.synchronizedMap&lt;/code&gt; 中都实现了独占访问，因此只能单个线程修改 Map 。ConcurrentHashMap 与这些 Map 容器相比，具有更多的优势和更少的劣势，只有当需要独占访问的需求时才会使用 Hashtable 或者是 Collections.synchronizedMap ，否则其他并发场景下，应该使用 ConcurrentHashMap。&lt;/p&gt;
&lt;h3 id=&quot;concurrentmap&quot;&gt;ConcurrentMap&lt;/h3&gt;
&lt;p&gt;ConcurrentMap 是一个接口，它继承了 Map 接口并提供了 Map 接口中四个新的方法，这四个方法都是 &lt;code&gt;原子性&lt;/code&gt; 方法，进一步扩展了 Map 的功能。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface ConcurrentMap&amp;lt;K, V&amp;gt; extends Map&amp;lt;K, V&amp;gt; {
 
  // 仅当 key 没有相应的映射值时才插入
  V putIfAbsent(K key, V value);
  
  // 仅当 key 被映射到 value 时才移除
  boolean remove(Object key, Object value);
  
  // 仅当 key 被映射到 value 时才移除
  V replace(K key, V value);
  
  // 仅当 key 被映射到 oldValue 时才替换为 newValue
  boolean replace(K key, V oldValue, V newValue);
  
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;concurrentnavigablemap&quot;&gt;ConcurrentNavigableMap&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;java.util.concurrent.ConcurrentNavigableMap&lt;/code&gt; 类是 &lt;code&gt;java.util.NavigableMap&lt;/code&gt; 的子类，它支持并发访问，并且允许其视图的并发访问。&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/08/31/dLumtO.png&quot; alt=&quot;122&quot; border=&quot;0&quot;/&gt;&lt;p&gt;什么是视图呢？视图就是集合中的一段数据序列，ConcurrentNavigableMap 中支持使用 &lt;code&gt;headMap&lt;/code&gt;、&lt;code&gt;subMap&lt;/code&gt;、&lt;code&gt;tailMap&lt;/code&gt; 返回的视图。与其重新解释一下 NavigableMap 中找到的所有方法，不如看一下 ConcurrentNavigableMap 中添加的方法&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;headMap 方法：headMap 方法返回一个严格小于给定键的视图&lt;/li&gt;
&lt;li&gt;tailMap 方法：tailMap 方法返回包含大于或等于给定键的视图。&lt;/li&gt;
&lt;li&gt;subMap 方法：subMap 方法返回给定两个参数的视图&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;ConcurrentNavigableMap 接口包含一些可能有用的其他方法&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;descendingKeySet()&lt;/li&gt;
&lt;li&gt;descendingMap()&lt;/li&gt;
&lt;li&gt;navigableKeySet()&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;更多关于方法的描述这里就不再赘述了，读者朋友们可自行查阅 javadoc&lt;/p&gt;
&lt;h4 id=&quot;concurrentskiplistmap&quot;&gt;ConcurrentSkipListMap&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;ConcurrentSkipListMap&lt;/code&gt; 是线程安全的有序的哈希表，适用于高并发的场景。&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/08/31/dLueAK.png&quot; alt=&quot;123&quot; border=&quot;0&quot;/&gt;&lt;p&gt;ConcurrentSkipListMap 的底层数据结构是基于&lt;code&gt;跳表&lt;/code&gt;实现的。ConcurrentSkipListMap 可以提供 Comparable 内部排序或者是 Comparator 外部排序，具体取决于使用哪个构造函数。&lt;/p&gt;
&lt;h4 id=&quot;concurrentskiplistset&quot;&gt;ConcurrentSkipListSet&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;ConcurrentSkipListSet&lt;/code&gt; 是线程安全的有序的集合，适用于高并发的场景。ConcurrentSkipListSet 底层是通过 ConcurrentNavigableMap 来实现的，它是一个有序的线程安全的集合。&lt;/p&gt;
&lt;p&gt;ConcurrentSkipListSet有序的，基于元素的自然排序或者通过比较器确定的顺序；&lt;/p&gt;
&lt;p&gt;ConcurrentSkipListSet是线程安全的；&lt;/p&gt;
&lt;h3 id=&quot;copyonwritearraylist&quot;&gt;CopyOnWriteArrayList&lt;/h3&gt;
&lt;p&gt;CopyOnWriteArrayList 是 ArrayList 的变体，在 CopyOnWriteArrayList 中，所有可变操作比如 add、set 其实都是重新创建了一个副本，通过对数组进行复制而实现的。&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/08/31/dLuV76.png&quot; alt=&quot;124&quot; border=&quot;0&quot;/&gt;&lt;p&gt;CopyOnWriteArrayList 其内部有一个指向数组的引用，数组是不会被修改的，每次并发修改 CopyOnWriteArrayList 都相当于重新创建副本，CopyOnWriteArrayList 是一种 &lt;code&gt;fail-safe&lt;/code&gt; 机制的，它不会抛出 ConcurrentModificationException 异常，并且返回元素与迭代器创建时的元素相同。&lt;/p&gt;
&lt;p&gt;每次并发写操作都会创建新的副本，这个过程存在一定的开销，所以，一般在规模很大时，读操作要远远多于写操作时，为了保证线程安全性，会使用 CopyOnWriteArrayList。&lt;/p&gt;
&lt;p&gt;类似的，CopyOnWriteArraySet 的作用也相当于替代了 Set 接口。&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/08/31/dLuE0x.png&quot; alt=&quot;125&quot; border=&quot;0&quot;/&gt;&lt;h3 id=&quot;blockingqueue&quot;&gt;BlockingQueue&lt;/h3&gt;
&lt;p&gt;BlockingQueue 译为 &lt;code&gt;阻塞队列&lt;/code&gt;，它是 JDK 1.5 添加的新的工具类，它继承于 Queue &lt;code&gt;队列&lt;/code&gt;，并扩展了 Queue 的功能。&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/08/31/dLuAn1.png&quot; alt=&quot;126&quot; border=&quot;0&quot;/&gt;&lt;p&gt;BlockingQueue 在检索元素时会等待队列变成非空，并在存储元素时会等待队列变为可用。BlockingQueue 的方法有四种实现形式，以不同的方式来处理。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一种是&lt;code&gt;抛出异常&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;特殊值&lt;/code&gt;：第二种是根据情况会返回 null 或者 false&lt;/li&gt;
&lt;li&gt;&lt;code&gt;阻塞&lt;/code&gt;：第三种是无限期的阻塞当前线程直到操作变为可用后&lt;/li&gt;
&lt;li&gt;&lt;code&gt;超时&lt;/code&gt;：第四种是给定一个最大的超时时间，超过后才会放弃&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;BlockingQueue 不允许添加 null 元素，在其实现类的方法 &lt;strong&gt;add、put 或者 offer&lt;/strong&gt; 后时添加 null 会抛出空指针异常。BlockingQueue 会有容量限制。在任意时间内，它都会有一个 remainCapacity，超过该值之前，任意 put 元素都会阻塞。&lt;/p&gt;
&lt;p&gt;BlockingQueue 一般用于实现&lt;code&gt;生产者 - 消费者&lt;/code&gt; 队列，如下图所示&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/08/31/dLuic9.png&quot; alt=&quot;127&quot; border=&quot;0&quot;/&gt;&lt;p&gt;BlockingQueue 有多种实现，下面我们一起来认识一下这些容器。&lt;/p&gt;
&lt;p&gt;其中 &lt;code&gt;LinkedBlockingQueue&lt;/code&gt; 和 &lt;code&gt;ArrayBlockingQueue&lt;/code&gt; 是 FIFO 先入先出队列，二者分别和 &lt;code&gt;LinkedList&lt;/code&gt;和 &lt;code&gt;ArrayList&lt;/code&gt; 对应，比同步 List 具有更好的并发性能。 &lt;code&gt;PriorityBlockingQueue&lt;/code&gt; 是一个优先级排序的阻塞队列，如果你希望按照某种顺序而不是 FIFO 处理元素时这个队列将非常有用。正如其他有序的容器一样，PriorityBlockingQueue 既可以按照自然顺序来比较元素，也可以使用 &lt;code&gt;Comparator&lt;/code&gt; 比较器进行外部元素比较。&lt;code&gt;SynchronousQueue&lt;/code&gt; 它维护的是一组线程而不是一组队列，实际上它不是一个队列，它的每个 insert 操作必须等待其他相关线程的 remove 方法后才能执行，反之亦然。&lt;/p&gt;
&lt;h4 id=&quot;linkedblockingqueue&quot;&gt;LinkedBlockingQueue&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;LinkedBlockingQueue&lt;/code&gt; 是一种 BlockingQueue 的实现。&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/08/31/dLuCp4.png&quot; alt=&quot;128&quot; border=&quot;0&quot;/&gt;&lt;p&gt;它是一种基于链表的构造、先入先出的有界阻塞队列。队列的 &lt;code&gt;head&lt;/code&gt; 也就是头元素是在队列中等待时间最长的元素；队列的 &lt;code&gt;tail&lt;/code&gt;也就是队尾元素是队列中等待时间最短的元素。新的元素会被插入到队尾中，检索操作将获取队列中的头部元素。链表队列通常比基于数组的队列具有更高的吞吐量，但是在大多数并发应用程序中，可预测的性能较差。&lt;/p&gt;
&lt;h4 id=&quot;arrayblockingqueue&quot;&gt;ArrayBlockingQueue&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;ArrayBlockingQueue&lt;/code&gt; 是一个用数组实现的有界队列，此队列顺序按照&lt;code&gt;先入先出&lt;/code&gt;的原则对元素进行排序。&lt;/p&gt;
&lt;p&gt;默认情况下不保证线程公平的访问队列，所谓公平访问队列指的是阻塞的线程，可以按照阻塞的先后顺序访问，即先阻塞线程先访问队列。非公平性是对先等待的线程是非公平的。有可能先阻塞的线程最后才访问队列。&lt;/p&gt;
&lt;h4 id=&quot;priorityblockingqueue&quot;&gt;PriorityBlockingQueue&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;PriorityBlockingQueue&lt;/code&gt; 是一个支持优先级的阻塞队列，默认情况下的元素采取自然顺序生序或者降序，也可以自己定义 Comparator 进行外部排序。但需要注意的是不能保证同优先级元素的顺序。&lt;/p&gt;
&lt;h4 id=&quot;delayqueue&quot;&gt;DelayQueue&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;DelayQueue&lt;/code&gt; 是一个支持延时获取元素的无阻塞队列，其中的元素只能在延迟到期后才能使用，DelayQueue 中的队列头是延迟最长时间的元素，如果没有延迟，则没有 head 头元素，poll 方法会返回 null。判断的依据就是 &lt;code&gt;getDelay(TimeUnit.NANOSECONDS)&lt;/code&gt; 方法返回一个值小于或者等于 0 就会发生过期。&lt;/p&gt;
&lt;h4 id=&quot;transferqueue&quot;&gt;TransferQueue&lt;/h4&gt;
&lt;p&gt;TransferQueue 继承于 BlockingQueue，它是一个接口，一个 BlockingQueue 是一个生产者可能等待消费者接受元素，TransferQueue 则更进一步，生产者会一直阻塞直到所添加到队列的元素被某一个消费者所消费，新添加的transfer 方法用来实现这种约束。&lt;/p&gt;
&lt;p&gt;TransferQueue 有下面这些方法：两个 &lt;code&gt;tryTransfer&lt;/code&gt; 方法，一个是非阻塞的，另一个是带有 timeout 参数设置超时时间的。还有两个辅助方法 &lt;code&gt;hasWaitingConsumer&lt;/code&gt; 和 &lt;code&gt;getWaitingConcusmerCount&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&quot;linkedtransferqueue&quot;&gt;LinkedTransferQueue&lt;/h4&gt;
&lt;p&gt;一个无界的基于链表的 TransferQueue。这个队列对任何给定的生产者进行 FIFO 排序，head 是队列中存在时间最长的元素。tail 是队列中存在时间最短的元素。&lt;/p&gt;
&lt;h3 id=&quot;blockingdeque&quot;&gt;BlockingDeque&lt;/h3&gt;
&lt;p&gt;与 BlockingQueue 相对的还有 BlockingDeque 和 Deque，它们是 JDK1.6 被提出的，分别对 Queue 和 BlockingQueue 做了扩展。&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/08/31/dLuphF.png&quot; alt=&quot;129&quot; border=&quot;0&quot;/&gt;&lt;p&gt;&lt;code&gt;Deque&lt;/code&gt; 是一个双端队列，分别实现了在队列头和队列尾的插入。Deque 的实现有 &lt;code&gt;ArrayDeque&lt;/code&gt;、&lt;code&gt;ConcurrentLinkedDeque&lt;/code&gt;，BlockingDeque 的实现有 &lt;code&gt;LinkedBlockingDeque&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;阻塞模式一般用于生产者 - 消费者队列，而双端队列适用于工作密取&lt;/strong&gt;。在工作密取的设计中，每个消费者都有各自的双端队列，如果一个消费者完成了自己双端队列的任务，就会去其他双端队列的末尾进行消费。密取方式要比传统的生产者 - 消费者队列具有更高的可伸缩性，这是因为每个工作密取的工作者都有自己的双端队列，不存在竞争的情况。&lt;/p&gt;
&lt;h4 id=&quot;arraydeque&quot;&gt;ArrayDeque&lt;/h4&gt;
&lt;p&gt;ArrayDeque 是 Deque 的可动态调整大小的数组实现，其内部没有容量限制，他们会根据需要进行增长。ArrayDeque 不是线程安全的，如果没有外部加锁的情况下，不支持多线程访问。ArrayDeque 禁止空元素，这个类作为栈使用时要比 Stack 快，作为 queue 使用时要比 LinkedList 快。&lt;/p&gt;
&lt;p&gt;除了 remove、removeFirstOccurrence、removeLastOccurrence、contains、interator.remove 外，大部分的 ArrayDeque 都以恒定的开销运行。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：ArrayDeque 是 fail-fast 的，如果创建了迭代器之后，却使用了迭代器外部的 remove 等修改方法，那么这个类将会抛出 ConcurrentModificationException 异常。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;concurrentlinkeddeque&quot;&gt;ConcurrentLinkedDeque&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;ConcurrentLinkedDeque&lt;/code&gt; 是 JDK1.7 引入的双向链表的无界并发队列。它与 ConcurrentLinkedQueue 的区别是 ConcurrentLinkedDeque 同时支持 FIFO 和 FILO 两种操作方式，即可以从队列的头和尾同时操作(插入/删除)。ConcurrentLinkedDeque 也支持 &lt;code&gt;happen-before&lt;/code&gt; 原则。ConcurrentLinkedDeque 不允许空元素。&lt;/p&gt;
&lt;h4 id=&quot;linkedblockingdeque&quot;&gt;LinkedBlockingDeque&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;LinkedBlockingDeque&lt;/code&gt; 是一个由链表结构组成的双向阻塞队列，即可以从队列的两端插入和移除元素。双向队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。LinkedBlockingDeque 把初始容量和构造函数绑定，这样能够有效过度拓展。初始容量如果没有指定，就取的是 &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;，这也是 LinkedBlockingDeque 的默认构造函数。&lt;/p&gt;
&lt;h3 id=&quot;同步工具类&quot;&gt;同步工具类&lt;/h3&gt;
&lt;p&gt;同步工具类可以是任何一个对象，只要它根据自身状态来协调线程的控制流。阻塞队列可以作为同步控制类，其他类型的同步工具类还包括 &lt;code&gt;信号量(Semaphore)&lt;/code&gt;、&lt;code&gt;栅栏(Barrier)&lt;/code&gt; 和 &lt;code&gt;闭锁(Latch)&lt;/code&gt;。下面我们就来一起认识一下这些工具类&lt;/p&gt;
&lt;h3 id=&quot;semaphore&quot;&gt;Semaphore&lt;/h3&gt;
&lt;p&gt;Semaphore 翻译过来就是 &lt;code&gt;信号量&lt;/code&gt;，信号量是什么？它其实就是一种信号，在操作系统中，也有信号量的这个概念，在进程间通信的时候，我们就会谈到信号量进行通信。还有在 Linux 操作系统采取中断时，也会向进程发出中断信号，根据进程的种类和信号的类型判断是否应该结束进程。&lt;/p&gt;
&lt;p&gt;在 Java 中，&lt;code&gt;Semaphore（信号量）&lt;/code&gt;是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。&lt;/p&gt;
&lt;p&gt;Semaphore 管理着一组&lt;code&gt;许可(permit)&lt;/code&gt;，许可的初始数量由构造函数来指定。在获取某个资源之前，应该先从信号量获取&lt;code&gt;许可(permit)&lt;/code&gt;，以确保资源是否可用。当线程完成对资源的操作后，会把它放在池中并向信号量返回一个许可，从而允许其他线程访问资源，这叫做释放许可。如果没有许可的话，那么 &lt;code&gt;acquire&lt;/code&gt; 将会阻塞直到有许可（中断或者操作超时）为止。&lt;code&gt;release&lt;/code&gt; 方法将返回一个许可信号量。&lt;/p&gt;
&lt;p&gt;Semaphore 可以用来实现流量控制，例如常用的数据库连接池，线程请求资源时，如果数据库连接池为空则阻塞线程，直接返回失败，如果连接池不为空时解除阻塞。&lt;/p&gt;
&lt;h3 id=&quot;countdownlatch&quot;&gt;CountDownLatch&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;闭锁(Latch)&lt;/code&gt; 是一种同步工具类，它可以延迟线程的进度以直到其到达终止状态。闭锁的作用相当于是一扇门，在闭锁达到结束状态前，门是一直关着的，没有任何线程能够通过。当闭锁到达结束状态后，这扇门会打开并且允许任何线程通过，然后就一直保持打开状态。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CountDownLatch&lt;/code&gt; 就是闭锁的一种实现。它可以使一个或者多个线程等待一组事件的发生。闭锁有一个计数器，闭锁需要对计数器进行初始化，表示需要等待的次数，闭锁在调用 &lt;code&gt;await&lt;/code&gt; 处进行等待，其他线程在调用 countDown 把闭锁 count 次数进行递减，直到递减为 0 ，唤醒 await。如下代码所示&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class TCountDownLatch {

    public static void main(String[] args) {
        CountDownLatch latch = new CountDownLatch(5);
        Increment increment = new Increment(latch);
        Decrement decrement = new Decrement(latch);

        new Thread(increment).start();
        new Thread(decrement).start();

        try {
            Thread.sleep(6000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
class Decrement implements Runnable {

    CountDownLatch countDownLatch;

    public Decrement(CountDownLatch countDownLatch){
        this.countDownLatch = countDownLatch;
    }

    @Override
    public void run() {
        try {

            for(long i = countDownLatch.getCount();i &amp;gt; 0;i--){
                Thread.sleep(1000);
                System.out.println(&quot;countdown&quot;);
                this.countDownLatch.countDown();
            }

        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
class Increment implements Runnable {

    CountDownLatch countDownLatch;

    public Increment(CountDownLatch countDownLatch){
        this.countDownLatch = countDownLatch;
    }

    @Override
    public void run() {
        try {
            System.out.println(&quot;await&quot;);
            countDownLatch.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(&quot;Waiter Released&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;future&quot;&gt;Future&lt;/h3&gt;
&lt;p&gt;我们常见的创建多线程的方式有两种，一种是继承 Thread 类，一种是实现 Runnable 接口。这两种方式都没有返回值。相对的，创建多线程还有其他三种方式，那就是使用 &lt;code&gt;Callable&lt;/code&gt;接口、 &lt;code&gt;Future&lt;/code&gt; 接口和 &lt;code&gt;FutureTask&lt;/code&gt; 类。Callable 我们之前聊过，这里就不再描述了，我们主要来描述一下 Future 和 FutureTask 接口。&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/08/31/dLuP1J.png&quot; alt=&quot;130&quot; border=&quot;0&quot;/&gt;&lt;p&gt;Future 就是对具体的 Runnable 或者 Callable 任务的执行结果进行一系列的操作，必要时可通过 &lt;code&gt;get&lt;/code&gt; 方法获取执行结果，这个方法会阻塞直到执行结束。Future 中的主要方法有&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface Future&amp;lt;V&amp;gt; {
    boolean cancel(boolean mayInterruptIfRunning);
    boolean isCancelled();
    boolean isDone();
    V get() throws InterruptedException, ExecutionException;
    V get(long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;cancel(boolean mayInterruptIfRunning)&lt;/code&gt; : 尝试取消任务的执行。如果任务已经完成、已经被取消或者由于某些原因而无法取消，那么这个尝试会失败。如果取消成功，或者在调用 cancel 时此任务尚未开始，那么此任务永远不会执行。如果任务已经开始，那么 mayInterruptIfRunning 参数会确定是否中断执行任务以便于尝试停止该任务。这个方法返回后，会对 &lt;code&gt;isDone&lt;/code&gt; 的后续调用也返回 true，如果 cancel 返回 true，那么后续的调用 &lt;code&gt;isCancelled&lt;/code&gt; 也会返回 true。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boolean isCancelled()&lt;/code&gt;：如果此任务在正常完成之前被取消，则返回 true。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boolean isDone()&lt;/code&gt;：如果任务完成，返回 true。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;V get() throws InterruptedException, ExecutionException&lt;/code&gt;：等待必要的计算完成，然后检索其结果&lt;/li&gt;
&lt;li&gt;&lt;code&gt;V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException&lt;/code&gt; ： 必要时最多等待给定时间以完成计算，然后检索其结果。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因为Future只是一个接口，所以是无法直接用来创建对象使用的，因此就有了下面的FutureTask。&lt;/p&gt;
&lt;h3 id=&quot;futuretask&quot;&gt;FutureTask&lt;/h3&gt;
&lt;p&gt;FutureTask 实现了 &lt;code&gt;RunnableFuture&lt;/code&gt; 接口，RunnableFuture 接口是什么呢？&lt;/p&gt;
&lt;p&gt;RunnableFuture 接口又继承了 &lt;code&gt;Runnable&lt;/code&gt; 接口和 &lt;code&gt;Future&lt;/code&gt; 接口。纳尼？在 Java 中不是只允许单继承么，是的，单继承更多的是说的类与类之间的继承关系，子类继承父类，扩展父类的接口，这个过程是单向的，就是为了解决多继承引起的过渡引用问题。而接口之间的继承是接口的扩展，在 Java 编程思想中也印证了这一点&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202008/1515111-20200831071627128-1012107928.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对 RunnableFuture 接口的解释是：成功执行的 run 方法会使 Future 接口的完成并允许访问其结果。所以它既可以作为 Runnable 被线程执行，又可以作为 Future 得到 Callable 的返回值。&lt;/p&gt;
&lt;p&gt;FutureTask 也可以用作闭锁，它可以处于以下三种状态&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;等待运行&lt;/li&gt;
&lt;li&gt;正在运行&lt;/li&gt;
&lt;li&gt;运行完成&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;FutureTask 在 &lt;code&gt;Executor&lt;/code&gt; 框架中表示异步任务，此外还可以表示一些时间较长的计算，这些计算可以在使用计算结果之前启动。&lt;/p&gt;
&lt;p&gt;FutureTask 具体的源码我后面会单独出文章进行描述。&lt;/p&gt;
&lt;h3 id=&quot;barrier&quot;&gt;Barrier&lt;/h3&gt;
&lt;p&gt;我们上面聊到了通过闭锁来启动一组相关的操作，使用闭锁来等待一组事件的执行。闭锁是一种一次性对象，一旦进入终止状态后，就不能被 &lt;code&gt;重置&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Barrier&lt;/code&gt; 的特点和闭锁也很类似，它也是阻塞一组线程直到某个事件发生。栅栏与闭锁的区别在于，所有线程必须同时到达栅栏的位置，才能继续执行，就像我们上面操作系统给出的这幅图一样。&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/08/31/dLu8Bt.png&quot; alt=&quot;dLu8Bt.png&quot; border=&quot;0&quot;/&gt;&lt;p&gt;ABCD 四条线程，必须同时到达 Barrier，然后 &lt;code&gt;手牵手&lt;/code&gt;一起走过幸福的殿堂。&lt;/p&gt;
&lt;p&gt;当线程到达 Barrier 的位置时会调用 &lt;code&gt;await&lt;/code&gt; 方法，这个方法会阻塞直到所有线程都到达 Barrier 的位置，如果所有线程都到达 Barrier 的位置，那么 Barrier 将会打开使所有线程都被释放，而 Barrier 将被重置以等待下次使用。如果调用 await 方法导致超时，或者 await 阻塞的线程被中断，那么 Barrier 就被认为被打破，所有阻塞的 await 都会抛出 &lt;code&gt;BrokenBarrierException&lt;/code&gt; 。如果成功通过栅栏后，await 方法返回一个唯一索引号，可以利用这些索引号选举一个新的 leader，来处理一下其他工作。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class TCyclicBarrier {

    public static void main(String[] args) {

        Runnable runnable = () -&amp;gt; System.out.println(&quot;Barrier 1 开始...&quot;);

        Runnable runnable2 = () -&amp;gt; System.out.println(&quot;Barrier 2 开始...&quot;);

        CyclicBarrier barrier1 = new CyclicBarrier(2,runnable);
        CyclicBarrier barrier2 = new CyclicBarrier(2,runnable2);

        CyclicBarrierRunnable b1 = new CyclicBarrierRunnable(barrier1,barrier2);
        CyclicBarrierRunnable b2 = new CyclicBarrierRunnable(barrier1,barrier2);

        new Thread(b1).start();
        new Thread(b2).start();
    }

}

class CyclicBarrierRunnable implements Runnable {

    CyclicBarrier barrier1;
    CyclicBarrier barrier2;

    public CyclicBarrierRunnable(CyclicBarrier barrier1,CyclicBarrier barrier2){
        this.barrier1 = barrier1;
        this.barrier2 = barrier2;
    }

    @Override
    public void run() {

        try {
            Thread.sleep(1000);
            System.out.println(Thread.currentThread().getName() + &quot;等待 barrier1&quot; );
            barrier1.await();

            Thread.sleep(1000);
            System.out.println(Thread.currentThread().getName() + &quot;等待 barrier2&quot; );
            barrier2.await();

        } catch (InterruptedException | BrokenBarrierException e) {
            e.printStackTrace();
        }

        System.out.println(Thread.currentThread().getName() +
                &quot; 做完了!&quot;);

    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;exchanger&quot;&gt;Exchanger&lt;/h3&gt;
&lt;p&gt;与 Barrier 相关联的还有一个工具类就是 &lt;code&gt;Exchanger&lt;/code&gt;， Exchanger 是一个用于线程间协作的工具类。Exchanger用于进行线程间的数据交换。&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/08/31/dLuFXR.png&quot; alt=&quot;131&quot; border=&quot;0&quot;/&gt;&lt;p&gt;它提供一个同步点，在这个同步点两个线程可以交换彼此的数据。这两个线程通过exchange 方法交换数据， 如果第一个线程先执行 exchange方法，它会一直等待第二个线程也执行 exchange，当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方。因此使用Exchanger 的重点是成对的线程使用 exchange() 方法，当有一对线程达到了同步点，就会进行交换数据。因此该工具类的线程对象是成对的。&lt;/p&gt;
&lt;p&gt;下面通过一段例子代码来讲解一下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class TExchanger {

    public static void main(String[] args) {

        Exchanger exchanger = new Exchanger();

        ExchangerRunnable exchangerRunnable = new ExchangerRunnable(exchanger,&quot;A&quot;);
        ExchangerRunnable exchangerRunnable2 = new ExchangerRunnable(exchanger,&quot;B&quot;);

        new Thread(exchangerRunnable).start();
        new Thread(exchangerRunnable2).start();
    }
}


class ExchangerRunnable implements Runnable {

    Exchanger exchanger;
    Object object;

    public ExchangerRunnable(Exchanger exchanger,Object object){
        this.exchanger = exchanger;
        this.object = object;
    }


    @Override
    public void run() {

        Object previous = object;

        try {
            object = this.exchanger.exchange(object);
            System.out.println(
                    Thread.currentThread().getName() + &quot;改变前是&quot; + previous + &quot;改变后是&quot; + object);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;本篇文章我们从同步容器类入手，主要讲了 &lt;code&gt;fail-fast&lt;/code&gt; 和 &lt;code&gt;fail-safe&lt;/code&gt; 机制，这两个机制在并发编程中非常重要。然后我们从操作系统的角度，聊了聊操作系统层面实现安全性的几种方式，然后从操作系统 -&amp;gt; 并发我们聊了聊 Java 中的并发工具包有哪些，以及构建并发的几种工具类。&lt;/p&gt;
&lt;p&gt;你好，我是 cxuan，我自己手写了四本 PDF，分别是 Java基础总结、HTTP 核心总结、计算机基础知识，操作系统核心总结，我已经整理成为 PDF，可以关注公众号 Java建设者 回复 PDF 领取优质资料。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202008/1515111-20200831071710331-1619543695.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 30 Aug 2020 23:18:00 +0000</pubDate>
<dc:creator>程序员cxuan</dc:creator>
<og:description>本文的组织形式如下，主要会介绍到同步容器类，操作系统的并发工具，Java 开发工具包（只是简单介绍一下，后面会有源码分析）。同步工具类有哪些。 下面我们就来介绍一下 Java 并发中都涉及哪些模块，这</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cxuanBlog/p/13587632.html</dc:identifier>
</item>
<item>
<title>Redis秒杀实战-微信抢红包-秒杀库存，附案例源码（Jmeter压测） - 陈彦斌</title>
<link>http://www.cnblogs.com/chenyanbin/p/13587508.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenyanbin/p/13587508.html</guid>
<description>&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;前二天&lt;/strong&gt;&lt;/span&gt;我&lt;span&gt;&lt;strong&gt;写&lt;/strong&gt;&lt;/span&gt;了一篇，&lt;span&gt;&lt;strong&gt;Redis高级项目实战&lt;/strong&gt;&lt;/span&gt;(&lt;a href=&quot;https://www.cnblogs.com/chenyanbin/p/13506946.html&quot; target=&quot;_blank&quot;&gt;点我直达&lt;/a&gt;)，&lt;strong&gt;&lt;span&gt;SpringBoot整合Redis附源码&lt;/span&gt;&lt;/strong&gt;(&lt;a href=&quot;https://www.cnblogs.com/chenyanbin/p/13515268.html&quot; target=&quot;_blank&quot;&gt;点我直达&lt;/a&gt;)，&lt;span&gt;&lt;strong&gt;今天&lt;/strong&gt;&lt;/span&gt;我们来&lt;span&gt;&lt;strong&gt;做&lt;/strong&gt;&lt;/span&gt;一下&lt;span&gt;&lt;strong&gt;Redis秒杀&lt;/strong&gt;&lt;/span&gt;系统的设计。当然啦，&lt;span&gt;&lt;strong&gt;Redis基础&lt;/strong&gt;&lt;/span&gt;知识&lt;span&gt;&lt;strong&gt;还不过关的&lt;/strong&gt;&lt;/span&gt;，&lt;span&gt;&lt;strong&gt;先去加强下自身内功&lt;/strong&gt;&lt;/span&gt;，然后在回来看这篇，&lt;span&gt;&lt;strong&gt;Redis基础知识&lt;/strong&gt;&lt;/span&gt;&lt;a href=&quot;https://www.cnblogs.com/chenyanbin/p/12073107.html&quot; target=&quot;_blank&quot;&gt;(点我直达&lt;/a&gt;)。为啥写这个微信抢红包项目呢，公司0202年08月22日，公司周年庆，抢了100多红包🧧，O(∩_∩)O哈哈~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200823234751230-70487411.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;业务流程分析 &lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200823231516978-1835079871.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/h2&gt;
&lt;h2&gt;功能拆解&lt;/h2&gt;
&lt;h3&gt;新建红包&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;在DB&lt;/strong&gt;&lt;/span&gt;、&lt;strong&gt;&lt;span&gt;Redis&lt;/span&gt;&lt;/strong&gt;分别&lt;span&gt;&lt;strong&gt;新增一条记录&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;抢红包(&lt;span&gt;并发&lt;/span&gt;)&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;请求Redis&lt;/strong&gt;&lt;/span&gt;，&lt;span&gt;&lt;strong&gt;红包剩余个数&lt;/strong&gt;&lt;/span&gt;，&lt;span&gt;&lt;strong&gt;大于0&lt;/strong&gt;&lt;/span&gt;才可以&lt;span&gt;&lt;strong&gt;拆&lt;/strong&gt;&lt;/span&gt;，&lt;span&gt;&lt;strong&gt;等会0&lt;/strong&gt;&lt;/span&gt;时，提示用户，&lt;span&gt;&lt;strong&gt;红包已抢完&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;拆红包(&lt;span&gt;并发&lt;/span&gt;)&lt;/h3&gt;
&lt;h4&gt;用到技术&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　Redis&lt;/strong&gt;&lt;/span&gt;中数据类型的&lt;span&gt;&lt;strong&gt;String特性&lt;/strong&gt;&lt;/span&gt;的&lt;span&gt;&lt;strong&gt;原子递减&lt;/strong&gt;&lt;span&gt;（&lt;/span&gt;&lt;strong&gt;DECR key&lt;/strong&gt;&lt;span&gt;）&lt;/span&gt;&lt;/span&gt;和&lt;span&gt;&lt;strong&gt;减少指定值&lt;/strong&gt;&lt;span&gt;（&lt;/span&gt;&lt;strong&gt;DECRBY key decrement&lt;/strong&gt;&lt;span&gt;）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;业务&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;请求Redis&lt;/span&gt;&lt;/strong&gt;，当&lt;span&gt;&lt;strong&gt;剩余红包个数大于0&lt;/strong&gt;&lt;/span&gt;，&lt;span&gt;&lt;strong&gt;红包个数&lt;/strong&gt;&lt;/span&gt;原子&lt;span&gt;&lt;strong&gt;递减&lt;/strong&gt;&lt;/span&gt;，随机&lt;span&gt;&lt;strong&gt;获取红包&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;计算金额&lt;/strong&gt;&lt;/span&gt;，当最后一个红包时，最后一个红包金额=总金额-总已抢红包金额&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;更新数据库&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;查看红包记录&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;查询DB&lt;/strong&gt;&lt;/span&gt;即可&lt;/p&gt;
&lt;h2&gt;数据库表设计&lt;/h2&gt;
&lt;p&gt;红包流水表&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt; `red_packet_info` (
 `id` &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt; AUTO_INCREMENT, 
 `red_packet_id` &lt;/span&gt;&lt;span&gt;bigint&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;红包id，采⽤
timestamp+5位随机数&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, 
 `total_amount` &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;红包总⾦额，单位分&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
 `total_packet` &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;红包总个数&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
 `remaining_amount` &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;剩余红包⾦额，单位
分&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
 `remaining_packet` &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;剩余红包个数&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
 `uid` &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;(&lt;span&gt;20&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;新建红包⽤户的⽤户标识&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
 `create_time` &lt;/span&gt;&lt;span&gt;timestamp&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;创建时间&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
 `update_time` &lt;/span&gt;&lt;span&gt;timestamp&lt;/span&gt; &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;CURRENT_TIMESTAMP&lt;/span&gt; &lt;span&gt;ON&lt;/span&gt; &lt;span&gt;UPDATE&lt;/span&gt;
&lt;span&gt;CURRENT_TIMESTAMP&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;更新时间&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
 &lt;/span&gt;&lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt;&lt;span&gt; (`id`)
) ENGINE&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;InnoDB AUTO_INCREMENT&lt;span&gt;=&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; CHARSET&lt;span&gt;=&lt;/span&gt;utf8mb4 COMMENT&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;红包信息
表，新建⼀个红包插⼊⼀条记录&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;红包记录表&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt; `red_packet_record` (
 `id` &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt; AUTO_INCREMENT, 
 `amount` &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;抢到红包的⾦额&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
 `nick_name` &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;32&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;抢到红包的⽤户的⽤户
名&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
 `img_url` &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;255&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;抢到红包的⽤户的头像&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
 `uid` &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;(&lt;span&gt;20&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;抢到红包⽤户的⽤户标识&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
 `red_packet_id` &lt;/span&gt;&lt;span&gt;bigint&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;红包id，采⽤
timestamp+5位随机数&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, 
 `create_time` &lt;/span&gt;&lt;span&gt;timestamp&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;创建时间&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
 `update_time` &lt;/span&gt;&lt;span&gt;timestamp&lt;/span&gt; &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;CURRENT_TIMESTAMP&lt;/span&gt; &lt;span&gt;ON&lt;/span&gt; &lt;span&gt;UPDATE&lt;/span&gt;
&lt;span&gt;CURRENT_TIMESTAMP&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;更新时间&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
 &lt;/span&gt;&lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt;&lt;span&gt; (`id`)
) ENGINE&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;InnoDB AUTO_INCREMENT&lt;span&gt;=&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; CHARSET&lt;span&gt;=&lt;/span&gt;utf8mb4 COMMENT&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;抢红包记
录表，抢⼀个红包插⼊⼀条记录&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200824215520831-273722339.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200824215539597-2123635438.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;发红包API&lt;/h2&gt;
&lt;h3&gt;发红包接口开发&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;新增一条红包记录&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;往mysql&lt;/strong&gt;&lt;/span&gt;里面添&lt;span&gt;&lt;strong&gt;加一条红包记录&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;往redis&lt;/strong&gt;&lt;/span&gt;里面添&lt;span&gt;&lt;strong&gt;加一条红包数量记录&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;往redis&lt;/strong&gt;&lt;/span&gt;里面添&lt;span&gt;&lt;strong&gt;加一条红包金额记录&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200825221041111-1539712425.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　注意，往db中就单纯存入一条记录，Service层和Mapper层，就简单的一条sql语句，主要是提供思路，下面会附案例源码，不要慌&lt;/p&gt;
&lt;h2&gt;抢红包API&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;抢红包&lt;/strong&gt;&lt;/span&gt;功能属于&lt;span&gt;&lt;strong&gt;原子减&lt;/strong&gt;&lt;/span&gt;操作&lt;/li&gt;
&lt;li&gt;当大小小于0时原子减失败&lt;/li&gt;
&lt;li&gt;当&lt;span&gt;&lt;strong&gt;红包个数为0&lt;/strong&gt;&lt;/span&gt;时，&lt;span&gt;&lt;strong&gt;后&lt;/strong&gt;&lt;/span&gt;面&lt;span&gt;&lt;strong&gt;进来&lt;/strong&gt;&lt;/span&gt;的用户&lt;span&gt;&lt;strong&gt;全部抢红包失败&lt;/strong&gt;&lt;/span&gt;，并不会进入拆红包环节&lt;/li&gt;
&lt;li&gt;抢红包功能设计
&lt;ul&gt;&lt;li&gt;将红包ID的请求放入请求队列中，如果发现超过红包的个数，直接返回&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;注意事项
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;抢到红包不一定能拆成功&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt; 抢红包算法拆解&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200825225651119-2111039266.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　通过&lt;span&gt;&lt;strong&gt;上图算法得出&lt;/strong&gt;&lt;/span&gt;，&lt;span&gt;&lt;strong&gt;靠前&lt;/strong&gt;&lt;/span&gt;面的人，&lt;span&gt;&lt;strong&gt;手气最佳几率小&lt;/strong&gt;&lt;/span&gt;，&lt;span&gt;&lt;strong&gt;手气最佳，往往在后面&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;发100元，共10个红包，那么平均值是10元一个，那么发出来的红包金额在0.01~20元之间波动&lt;/li&gt;
&lt;li&gt;当前面4个红包总共被领了30元时，剩下70元，总共6个红包，那么这6个红包的金额在0.01~23.3元之间波动&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;抢红包接口开发&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200826003430520-814368941.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;测试&lt;/h2&gt;
&lt;h3&gt;发红包&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200826003712834-1793224326.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;模拟高并发抢红包(&lt;span&gt;Jmeter压测工具&lt;/span&gt;)&lt;/h3&gt;
&lt;p&gt;　　因为我发了&lt;span&gt;&lt;strong&gt;10个红包&lt;/strong&gt;&lt;/span&gt;，&lt;span&gt;&lt;strong&gt;金额是20000&lt;/strong&gt;&lt;/span&gt;，使用压测工具，&lt;span&gt;&lt;strong&gt;模拟50个请求&lt;/strong&gt;&lt;/span&gt;，&lt;span&gt;&lt;strong&gt;只允许前10个请求能抢到红包&lt;/strong&gt;&lt;/span&gt;，&lt;span&gt;&lt;strong&gt;并且金额等于20000&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200826004251579-174033303.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200826010229396-1071712151.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200826010257741-1322162855.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;介绍&lt;/h2&gt;
&lt;p&gt;　　布隆过滤器是1970年由布隆提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。&lt;/p&gt;
&lt;h3&gt;优点&lt;/h3&gt;
&lt;p&gt;　　相比于其他的数据结构，布隆过滤器在空间和时间方面都有巨大的优势。布隆过滤器存储空间和插入/查询时间都是常数。另外三列函数相互之间没有关系，方便由硬件并行实现。布隆过滤器不需要存储元素本身，在某些对保密要求非常严格的场合有优势。&lt;/p&gt;
&lt;h3&gt;缺点&lt;/h3&gt;
&lt;p&gt;　　但是布隆过滤器的缺点和有点一样明显。误算率是其中之一。随着存入的元素数量增加，误算率随之增加。但是如果元素数量太少，则使用散列表足矣。&lt;/p&gt;
&lt;h2&gt;布隆过滤器有什么用？&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;黑客流量攻击：故意访问不存在的数据，导致查程序不断访问DB的数据&lt;/li&gt;
&lt;li&gt;黑客安全阻截：当黑客访问不存在的缓存时迅速返回避免缓存及DB挂掉&lt;/li&gt;
&lt;li&gt;网页爬虫对URL的去重，避免爬取相同的URL地址&lt;/li&gt;
&lt;li&gt;反垃圾邮件，从数十亿个垃圾邮件列表中判断某邮件是否垃圾邮件(同理，垃圾短信)&lt;/li&gt;
&lt;li&gt;缓存击穿，将已存在的缓存放到布隆中，当黑客访问不存在的缓存时迅速返回避免缓存及DB挂掉&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;需求&lt;/h2&gt;
&lt;p&gt;　　一个抽奖程序，只针对会员用户有效&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200829220858193-750214193.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;通过google布隆过滤器存储会员数据&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;程序启动时将数据放入内存中&lt;/li&gt;
&lt;li&gt;google自动创建布隆过滤器&lt;/li&gt;
&lt;li&gt;用户ID进来之后判断是否是会员&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;代码实现&lt;/h2&gt;
&lt;h3&gt;引入依赖&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.google.guava&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;guava&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;29.0-jre&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;数据库会员表&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt; `sys_user` (
 `id` &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) unsigned &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt; AUTO_INCREMENT,
 `&lt;/span&gt;&lt;span&gt;user_name&lt;/span&gt;` &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;CHARACTER&lt;/span&gt; &lt;span&gt;SET&lt;/span&gt; utf8mb4 &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;⽤户名&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
 `&lt;/span&gt;&lt;span&gt;image&lt;/span&gt;` &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;CHARACTER&lt;/span&gt; &lt;span&gt;SET&lt;/span&gt; utf8mb4 &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;⽤户头像&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
 &lt;/span&gt;&lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt;&lt;span&gt; (`id`)
) ENGINE&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;InnoDB AUTO_INCREMENT&lt;span&gt;=&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; CHARSET&lt;span&gt;=&lt;/span&gt;utf8;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200829224927351-1211103818.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;初始化布隆过滤器&lt;/h3&gt;
&lt;p&gt;　　dao层和dao映射文件，就单纯的一个sql查询，看核心方法，下面会附源码滴，不要慌好嘛&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200829230609455-250799074.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;控制层&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200829230349665-1488553948.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;测试 &lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200829231202897-1711665258.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;缺点&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;内存级别产部&lt;/li&gt;
&lt;li&gt;重启即失效&lt;/li&gt;
&lt;li&gt;本地内存无法用在分布式场景&lt;/li&gt;
&lt;li&gt;不支持大数据量存储&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;优点&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;可扩展性Bloom过滤器&lt;/li&gt;
&lt;li&gt;不存在重启即失效或定时任务维护的成本&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;缺点&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;需要网络IO，性能比基于内存的过滤器低&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;布隆过滤器安装&lt;/h2&gt;
&lt;h3&gt;下载&lt;/h3&gt;
&lt;p&gt;github：https://github.com/RedisBloom/RedisBloom&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
链接: https://pan.baidu.com/s/16DlKLm8WGFzGkoPpy8y4Aw  密码: 25w1
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;编译&lt;/h3&gt;
&lt;p&gt;make&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200829233530850-1719644224.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;将Rebloom加载到Redis中&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;先把Redis给停掉&lt;/strong&gt;&lt;/span&gt;！！！在redis.conf里面添加一行命令-&amp;gt;加载模块&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
loadmodule /usr/soft/RedisBloom-2.2.4/redisbloom.so
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200830001318055-1077987772.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;测试布隆过滤器&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200830003122751-732001989.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;编写两个lua脚本&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;添加数据到指定名称的布隆过滤器&lt;/li&gt;
&lt;li&gt;从指定名称的布隆过滤器获取key是否存在的脚本&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200830010432997-1454760482.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;local bloomName = KEYS[1]
local value = KEYS[2]
--bloomFilter
local result_1 = redis.call('BF.ADD',bloomName,value)
return result_1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200830010504965-1476109069.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;local bloomName = KEYS[1]
local value = KEYS[2]
--bloomFilter
local result_1 = redis.call('BF.EXISTS',bloomName,value)
return result_1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;在RedisService.java中添加2个方法&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200830010402640-1468793536.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;验证&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200830011447143-619868788.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;秒杀业务流程图&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200830020241284-1860097792.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200830020401786-2031329226.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;数据落地存储方案&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;通过分布式redis减库存&lt;/li&gt;
&lt;li&gt;DB存最终订单信息数据&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;API性能调优&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;性能瓶颈在高并发秒杀&lt;/li&gt;
&lt;li&gt;技术难题在于超卖问题&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;实现步骤&lt;/h2&gt;
&lt;p&gt;1、&lt;span&gt;&lt;strong&gt;提前将秒杀数据缓存到redis&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;set skuId_start_1 0_1554045087 --秒杀标识
set skuId_access_1 12000 --允许抢购数
set skuId_count_1 0 --抢购计数
set skuId_booked_1 0 --真实秒杀数&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;&lt;li&gt;秒杀开始前，skuId_start为0，代表活动未开始&lt;/li&gt;
&lt;li&gt;当skuId_start改为1时，活动开始，开始秒杀叭&lt;/li&gt;
&lt;li&gt;当接受下单数达到sku_count*1.2后，继续拦截所有请求，商品剩余数量为0(为啥接受抢购数为1万2呢，看业务流程图，涉及到“校验订单信息”，一般设置的值要比总数多一点，多多少自己定)&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;2、&lt;span&gt;&lt;strong&gt;利用Redis缓存加速增库存数&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&quot;skuId_booked&quot;:10000 //从0开始累加，秒杀的个数只能加到1万
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3、将&lt;span&gt;&lt;strong&gt;用户订单数据写入MQ&lt;/strong&gt;&lt;/span&gt;(异步方式)，可以看我另外一篇博客：&lt;a href=&quot;https://www.cnblogs.com/chenyanbin/p/12841966.html&quot; target=&quot;_blank&quot;&gt;点我直达&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4、&lt;span&gt;&lt;strong&gt;另外一台服务器监听mq，将订单信息写入到DB&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;好了，以上就是完整的开发步骤，下面我们开始编写代码&lt;/p&gt;
&lt;h2&gt;代码实战&lt;/h2&gt;
&lt;h3&gt;网关浏览拦截层&lt;/h3&gt;
&lt;p&gt;1、先判断秒杀是否已经开始&lt;/p&gt;
&lt;p&gt;2、利用Redis缓存incr拦截流量&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;用incr方法原子加&lt;/li&gt;
&lt;li&gt;通过原子加帕努单当前skuId_access是否达到最大值&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;订单信息校验层&lt;/h3&gt;
&lt;p&gt;1、校验当前用户是否已经买过这个商品&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;需要存储用户的uid&lt;/li&gt;
&lt;li&gt;存数据库效率太低&lt;/li&gt;
&lt;li&gt;存Redis value方式数据太大&lt;/li&gt;
&lt;li&gt;存布隆过滤器性能高且数据量小(&lt;strong&gt;&lt;span&gt;推荐&lt;/span&gt;&lt;/strong&gt;)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;2、校验通过直接返回抢购成功&lt;/p&gt;
&lt;h3&gt;开发lua脚本实现库存扣除&lt;/h3&gt;
&lt;p&gt;1、库存扣除成功，获取当前最新库存&lt;/p&gt;
&lt;p&gt;2、如果库存大于0，即马上进行库存扣除，并且访问抢购成功给用户&lt;/p&gt;
&lt;p&gt;3、考虑原子性问题&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;保证原子性的方式，采用lua脚本&lt;/li&gt;
&lt;li&gt;采用lua脚本方式保证原子性带来缺点，性能有所下降&lt;/li&gt;
&lt;li&gt;不保证原子性缺点，放入请求量可能大于预期&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;当前扣除库存场景必须保证原子性，否则会导致超卖&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;4、返回抢购结果&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;抢购成功&lt;/li&gt;
&lt;li&gt;库存没了，抢购失败&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;控制层&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200831001728354-502448448.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;Service层&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200831005825463-315453517.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;布隆过滤器&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200831002230398-1009185033.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;初始化redis缓存&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200831004622522-2143383176.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;set skuId_start_1 0_1554045087 --秒杀标识
set skuId_access_1 12000 --允许抢购数
set skuId_count_1 0 --抢购计数
set skuId_booked_1 0 --真实秒杀数&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;秒杀验证&lt;/h2&gt;
&lt;p&gt;jmeter配置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200831002356412-2109783163.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;压测秒杀验证原子性&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200831010939971-298803856.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200831011010919-1139645498.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200831011332832-1207871942.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200831011727140-1231393118.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
链接: https://pan.baidu.com/s/1hZUPRAljkqO05fYluqJBhQ  密码: 1iwr
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　演示的时候，&lt;span&gt;&lt;strong&gt;我使用的Redis单机&lt;/strong&gt;&lt;/span&gt;的，吞吐量不是很大，感兴趣的，可以自己搭建个Redis主从复制+哨兵+集群，然后再测试。&lt;/p&gt;
&lt;p&gt;　　最近比较忙，没时间完善微信抢红包秒杀的原子性。下面那个完整案例抢库存的，&lt;span&gt;&lt;strong&gt;亲自使用Jmeter压测几次，是原子性的&lt;/strong&gt;&lt;/span&gt;，可以拿来借鉴，感兴趣的同学，可以借鉴下面抢库存的代码，把微信抢红包的功能在完善下，我就不修改啦，今天先到这，有不懂的欢迎下面留言。&lt;/p&gt;
</description>
<pubDate>Sun, 30 Aug 2020 17:32:00 +0000</pubDate>
<dc:creator>陈彦斌</dc:creator>
<og:description>导读 前二天我写了一篇，Redis高级项目实战(点我直达)，SpringBoot整合Redis附源码(点我直达)，今天我们来做一下Redis秒杀系统的设计。当然啦，Redis基础知识还不过关的，先去加</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chenyanbin/p/13587508.html</dc:identifier>
</item>
<item>
<title>高可用集群之corosync+pacemaker - Linux-1874</title>
<link>http://www.cnblogs.com/qiuhom-1874/p/13585921.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qiuhom-1874/p/13585921.html</guid>
<description>&lt;p&gt;　　1、概念&lt;/p&gt;
&lt;p&gt;　　在传统Linux集群种类，主要分了三类，一类是LB集群，这类集群主要作用是对用户的流量做负载均衡，让其后端每个server都能均衡的处理一部分请求；这类集群有一个特点就是前端调度器通常是单点，后端server有很多台，即便某一台后端server挂掉，也不影响用户的请求；其次就是HA集群，所谓ha集群就是高可用集群，这类集群的主要作用是对集群中的单点做高可用，所谓高可用就是在发生故障时，能够及时的将故障转移，从而使故障修复时间最小；这类集群的特点是在多台节点上，各空闲节点会一直盯着工作节点，工作节点也会基于多播或广播的方式把自己的心跳信息发送给其他空闲节点，一旦工作节点的心跳信息在一定时间内空闲节点没有收到，那么此时就会触发资源抢占，先抢到资源的成为新的工作节点，而其他节点又会一直盯着新的工作节点，直到它挂掉，然后再次触发资源抢占；这类集群的特点就是一个节点工作，其他节点看着它工作，一旦工作节点挂了，立刻会有其他节点上来顶替它的工作；最后就是HP集群，HP集群主要用于在复杂计算中场景中，把多台server的算力综合一起，对复杂计算要求比较高的环境中使用；在生产环境中常见的LB和HA集群较多；&lt;/p&gt;
&lt;p&gt;　　2、衡量系统的可用性&lt;/p&gt;
&lt;p&gt;　　A=MTBF/(MTBF+MTTR)&lt;/p&gt;
&lt;p&gt;　　MTBF（Mean Time Between Failure）平均无故障工作时间；MTTR（Mean Time to Repair）平均修复时长；也就是说衡量一个系统的可用性是系统无故障运行时间除以系统无故障运行时间+故障修复时间；我们知道一个系统完全没有故障，这是不可能的，这也意味着A的取值是小于1；如果说一个系统的可用性为0，那么我们会认为该系统没有任何用，所以系统可用性通常是大于0小于1，通常我们用一个百分比来描述系统的可用性；从上面的公式，如果我们要提升系统的可用性我们有两种办法，第一种就是无限提升mtbf的值，让mtbf的值大到可以忽略mttr的值，当然这种方式理想中可行，在现实中，我们的系统一旦发生故障，修复的时间都不会是很少，也就说这种增大MTBF的方式，不是可行的；其次就是降低MTTR的值，降低MTTR的值就是缩短故障修复时间；通常我们降低MTTR的方式是通过冗余主机的方式；就是在容易发生故障的关键性业务上，提前给它配置好相同的服务，然后这台空闲的server就一直盯着工作的server，一旦工作server发生故障，此时空闲的server就立刻把工作的server的IP 地址给抢过来，然后把服务启动了，后端如果有共享存储，此时把共享存储挂载到自己对应的目录；如果有必要我们还需要通过某些机制让之前的server“爆头”，以免发生死灰复燃的场景；&lt;/p&gt;
&lt;p&gt;　　3、HA解决方案&lt;/p&gt;
&lt;p&gt;　　我们知道高可用的是服务，但是通常一个服务该有的多组件也会高可用，比如httpd服务，对于httpd对外它一定会有一个ip地址在对外提供服务，其次就是httpd服务自身的进程，如果业务需要，我们可能还会用到共享存储；通过上述描述，对于高可用httpd服务，我们需要在备份节点上对httpd的ip地址做高可用，服务进程，以及后端的共享存储；对于ip地址的高可用通常是在备份节点上探测到活动节点故障时，第一时间把活动节点的ip地址配置到备份节点上，通常这个ip地址是一个虚拟的ip地址，所以我们叫它vip；对应用程序进程的高可用，通常是我们在备份节点上直接把对应服务提前启动起来；后端共享存储的高可用也是通过某种机制探测活动节点发生故障后，然后把共享存储挂载到备份节点，使得整个httpd服务可用；我们把httpd从一个节点迁移到另一个节点的过程叫故障转移（failover）；这里需要注意，在发生故障转移后，之前活动节点有可能发生故障恢复的情况，此时为了不让之前活动的节点对现有的服务资源发生争用，我们在发生故障转移时，应该让其之前的节点“死”的更彻底一些，我们会让备份节点对活动节点“开一枪”，让发生故障的节点更彻底的故障；这种是为了避免资源争用而导致服务的不可用；&lt;/p&gt;
&lt;p&gt;　　vrrp协议的实现：keepalived&lt;/p&gt;
&lt;p&gt;　　基于OpenAIS规范的实现：corosync；所谓AIS（application interface standard）是指用来定义应用程序接口标准，openais就是开放的应用程序接口标准，它是有SA Forum发布的一套规范；这些规范的主要目的就是为了提高中间件可移植和应用程序的高可用；&lt;/p&gt;
&lt;p&gt;　　4、corosync+pacemaker架构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202008/1503305-20200830180504880-964701809.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　corosync的主要作用是提供messaging Layer，这个消息传递层的主要作用是，把个主机间的各状态信息，空闲信息等等一系列信息通过消息传递层互相传递，使得托管在corosync上的服务能够根据底层各主机传递的消息来决定该服务该运行到那台主机上，一旦运行的服务所在主机发生故障时，它们又能够根据消息传递层的消息来判断该把服务迁移到那台主机上运行；这样一来托管在corosync上的服务能够高可用；简单点讲，托管在corosync之上的服务对底层主机上不可见的，这也意味着托管在corosync上的服务是能够调用和理解Messaging Layer中的消息；这样一来托管在上面的服务就必须得提供接口来调用messaging Layer对外提供的接口，然后实现服务的迁移；而对于大多数程序来讲，它根本就没有这样的接口，这样一来我们要使用corosync实现服务高可用变得困难；为了解决托管在corosync的服务能够调用corosync提供的接口，我们需要开发一个中间件，让这个中间件能够向下理解和调用coroysnc提供的接口，向上能够托管服务；这个中间层就是pacemaker；它的主要作用是通过调用corosync提供的接口，来判断把集群资源该怎么分配，服务该怎么迁移和运行；同时pacemaker还提供一个管理界面，能够让管理员来管理这些集群资源；而对于pacemaker来讲，它主要有3各层次，其中CRM（cluster resource manager）的主要作用是通过调用messaging Layer提供的接口和各节点的状态信息来决策集群资源的管理；然后通过接口把决策信息传递给LRM（local resource manager）；LRM的主要作用是对本地的资源做各种管理；而对于LRM来讲，它要怎么管理本地资源呢？它通常不会自己去管理本地的资源，而是通过RA去管理，所谓RA（resource agent）就是资源代理；它会根据LRM发送的信息来对本地的资源进行管理，而这种管理通常是基于各种服务提供的起停脚本来实现的；比如，我们要把httpd服务托管在corosync+pacemaker这个架构上，首先我们得提供一个管理httpd的服务的脚本，比如centos7上的httpd.service，centos6上的/etc/init.d/httpd来实现；而这些脚本通常在我们使用yum安装都会提供，这样一来，我们要托管httpd服务就变得尤为简单，我们只需要在pacemaker上配置，把httpd识别成集群资源即可；只要配置httpd为集群的资源，此时我们就可以在各主机上迁移httpd服务来实现httpd服务的高可用；要实现httpd服务在各节点主机上迁移，我们需要要注意各主机上必须有httpd服务；对于其他服务也是同样的逻辑；简单讲corosync主要提供底层各主机消息状态，集群状态信息，而pacemaker主要对托管在其上的服务进行管理；当然pacemaker也可以通过调用corosync的接口来管理底层的主机，比如让某一台主机下线上线等等操作；&lt;/p&gt;
&lt;p&gt; 　　5、corosync集群的投票系统&lt;/p&gt;
&lt;p&gt;　　在集群发生网络分区以后，怎样确定该那一方继续代表集群工作呢？所谓集群分区就表示，集群中的某一台主机或一些主机不能检测到其他主机的心跳；当集群发生分区以后，到底哪一方能够继续代表集群工作呢？如果是2台主机组成的集群，当其中一台host不能够正常检测到另一台host的心跳时，它们都会认为对方故障了，此时就会存在一个资源争用的问题，A认为B挂了，B认为A挂了，此时集群资源就会来回在A和B上飘动，使得整个服务都不可用；为了解决这样的问题，我们必须有一个系统来来决定到底谁该代表集群工作；通常情况在一个分布式集群中，投票系统尤为重要，它决定了整个集群是否能够正常工作；假如我们的集群有3台主机组成，当其中一台主机挂掉了，那么到底谁来代表集群工作呢？如果是A那么整个集群将不可用，那么是B C，谁来当领导呢？这个时候就需要投票系统来决策了；默认情况我们的集群各host都会有选票在自己手中，当发生分区以后，各host会根据自己检测到的心跳信息发送给集群其他节点，根据选票的数量来决定谁故障了，谁能够代表集群工作，如上面的例子，如果A挂了，那么B会把对A的检测的心跳信息，发送给C，然后C也会把对A的检测心跳信息发送给B，此时投票就是A挂了2票，而整个集群总共3票，已经有过半的选票都认为A挂了，那么A此时就不会继续代表集群工作了；剩下的B和C可继续代表集群工作；我们把能够继续代表集群工作的一方叫with quorum，就是选票大于总选票一半的一方；而对于选票小于或等于总选票的一方我们称为without quorum；此时A就是without quorum一方，它会遵循no_quorum_policy指定的行为，通常no_quorum_policy默认是stop行为，意思就是without quorum一方会停止代表集群工作，当然它还有ignore、suicide、freeze行为；ignore表示忽略自己是without quorum一方的选票结果，继续代表集群工作，suicide表示自杀，就是一旦不是with quorum一方就自我毁灭，freeze表示冻结，所谓冻结就是继续服务老的请求，拒绝新的请求；B和C就是with quorum一方，它们会利用某种机制来挑选一个领导，然后根据消息传递层的消息决定把A上的资源抢过来跑在那个节点上继续代表集群工作；而对于BC来讲它们只是联系不到A，A是否真的挂了呢？如果A没有真的挂，那么BC此时把A上的ip地址抢过来，继续代表集群工作，A可能再把ip地址抢过去，这样一来集群就不能够正常工作，为了解决BC的后顾之忧，BC会通过其他机制把A干掉（比如爆头，stonith机制“shoot the other node in the head”），让A即便是存活的也让其挂掉，这样做的目的就是为了保证集群资源不再受A的干扰，正常提供服务；在corosync+pacemaker这种架构中，领导的角色称为DC（disignated coordinator指派的协调员）；DC的主要作用是接收管理员的配置信息和更新集群各状态事务信息，并指派对应节点上的LRM对其集群资源操作，并通过消息传递层把管理配置信息同步给集群其他节点；这样一来，在下一次集群发生分区以后，能够在集群其他节点上选出新的DC，从而继续代表集群工作；集群中的各状态事务、配置信息，通常保存在CIB（cluster information base）中，而对于CIB中的各状态事务信息由DC去更新，然后再同步到集群各节点中去；通常DC节点上会运行CRM、CIB、PE（policy engine）、LRM这四个组件；而非DC节点会运行CRM、CIB、LRM这三个组件；而PE的作用就是调度指挥DC把配置信息应用后的结果通过消息传递层发送给其他非DC节点并保存至各非DC节点的CIB中；&lt;/p&gt;
&lt;p&gt;　　6、资源类型&lt;/p&gt;
&lt;p&gt;　　在corosync+pacemaker架构上，最为核心的就是资源，前边说了那么多，最终目的是为了管理托管在上面的资源；而对于资源来讲资源是有类型的；简单讲就是可以用来调配的服务称为资源，比如一个httpd服务，一个ip地址，一个后端共享存储等等，这些都叫做资源；而对于一个完整的服务来讲，它是由多个单一的资源组合而成；比如一个完整的httpd服务它应该由ip地址、httpd服务进程、在特殊场景中很有可能会有后端共享存储；而这些资源在corosync+pacemaker上每个资源是有类型的，不同的类型运行方式个不相同；&lt;/p&gt;
&lt;p&gt;　　primitive：基本资源，主资源；通常仅能运行为一份，运行在单个节点上的资源；&lt;/p&gt;
&lt;p&gt;　　group：组；将一个或多个资源组织成一个可统一管理的单一单位资源；什么意思呢？默认情况托管在corosync+pacemaker上的资源会负载均衡的运行在多个主机之上，如果我们不将这些资源逻辑的关联在一起，就会存在，ip地址在A主机上，服务进程在B主机上，后端存储在C主机上，这样一来，我们托管的服务就没有办法向外提供服务，为了解决各依赖资源分散的问题，我们需要将多个有关联依赖的资源逻辑的组织成一个组，然后根据这个组为单位进行调度和管理；&lt;/p&gt;
&lt;p&gt;　　clone：克隆；一个资源可以在集群中运行多个副本，可以运行于多个节点；&lt;/p&gt;
&lt;p&gt;　　mutil-state(master/slave)：是clone类型的资源的特殊表现，可以存在多个副本，副本间存在主从关系；&lt;/p&gt;
&lt;p&gt;　　7、资源倾向性&lt;/p&gt;
&lt;p&gt;　　什么叫资源倾向性呢？我们知道一个资源托管在corosync+pacemaker上，最终都会把资源落在某一个节点上运行，而我们怎么来限制这些资源在那个或那些各节点上运行呢？这个就需要我们配置资源对节点的倾向性了；所谓倾向性就是该资源更加倾向在那个节点运行或更加讨厌在那个几点上运行；在corosync+pacemaker集群上运行资源的方式有3中，N-1、N-M、N-N，其中N表示节点数量，M表示资源数量；N-1表示N个几点上运行1各资源；这也意味这有N减1各节点上处于空先状态，这对于服务器的资源利用率有点浪费；所以对于corosync+pacemaker集群和keepalived来讲，keepalived更加轻量化；N-M表示N个几点上运行M个资源通常M小于N；这意味着有N减M个节点冗余；N-N表示N个节点上运行N个资源，没有冗余节点，这意味着一旦一个资源挂掉，那么对应就会迁移到其他节点，对于其他节点迁移到的节点只要提供的ip地址，进程，端口不冲突就不会有很大的问题，只不过相对压力要大一点；对于不同运行方式，冗余的节点数量也是不同的；而对于资源该运行到那个节点我们可以通过定义资源对节点的倾向性来决定；默认情况每个资源都能够在任意节点上运行；也就说默认情况当A资源挂掉以后，它的故障转移范围是其他节点，为了不让A服务运行到B节点，我们可以定义A资源的对B资源的倾向性为负无穷，所谓负无穷就是只要有其他节点可运行就绝不在B节点上运行；通过定义资源对节点的倾向性，从而来限制资源在那些节点上进行转移；这种限制资源对节点的倾向性我们叫做定义资源的故障转移域；除了能够定义资源对节点的倾向性，我们还可以定义资源与资源的倾向性，其逻辑都是相似的；对于资源倾向性通常我们会用分数来表示，其取值范围是真无穷到负无穷；正无穷表示无限喜欢到某个节点或资源，只要对应节点正常存在就一定在该节点上，负无穷相反；&lt;/p&gt;
&lt;p&gt;　　8、资源代理&lt;/p&gt;
&lt;p&gt;　　所谓资源代理，就是指帮助去启动一个资源的；在corosync+pacemaker集群上，资源代理就是指的是能够帮助我们去启动一个资源的脚本或程序，对于不同的资源代理，用到的脚本或程序不同；对于不同的资源在不同的系统，资源代理的类型也有不同，比如在centos6上，各服务的启动脚本通常在/etc/init.d/下，所以通常会把/etc/init.d/目录下的各脚本当作资源代理的脚本；这种资源类型叫做LSB的资源类型，通常这些脚本都支持start|stop|restart|status等等参数；对于LSB类型的资源代理，前提是代理的资源一定不能开机启动，如果开机启动对于托管corosync+pacemaker就无意义了，所以资源的启动一定要交给corosync+pacemaker来管理不能开机启动；对于centos7来说，它使用的是systemd方式来管理各服务的启动，停止；它默认的存放unit file的路径是/usr/lib/systemd/system/目录下；而对于systemd类型的资源代理，我们一定要把托管为集群的服务 enable起来，可以理解为corosync+pacemaker它会到/etc/systemd/system/目录下对应资源启动脚本；而只有把对应服务enable来以后，它才会在/etc/systemd/system/目录下存在；除了以上两种资源代理还有OCF和stonith，OCF类型资源代理类似LSB脚本，当支持start,stop,status,monitor,mata-data等参数；stonith类型的资源代理专用配置stonith设备RA；service类型，以上4种都不符合的其他类型的资源代理；&lt;/p&gt;
&lt;p&gt;　　9、corosync+pacemaker的安装配置&lt;/p&gt;
&lt;p&gt;　　前提：&lt;/p&gt;
&lt;p&gt;　　1、各host时间同步；&lt;/p&gt;
&lt;p&gt;　　2、各hosts文件能够解析其他节点的主机名；选择一各不和其他集群冲突的多播地址；&lt;/p&gt;
&lt;p&gt;　　3、有需要可配置各节点ssh互信；&lt;/p&gt;
&lt;table border=&quot;0&quot; align=&quot;left&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;主机名&lt;/td&gt;
&lt;td&gt;ip地址&lt;/td&gt;
&lt;td&gt;多播地址&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;node01&lt;/td&gt;
&lt;td&gt;192.168.0.41&lt;/td&gt;
&lt;td&gt;239.255.100.12&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;node02&lt;/td&gt;
&lt;td&gt;192.168.0.42&lt;/td&gt;
&lt;td&gt;239.255.100.12&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;



&lt;p&gt;　　验证：各主机上的时间和主机名以及hosts文件；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202008/1503305-20200830230503155-21362411.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202008/1503305-20200830230605555-1584114641.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：为这里以两主机演示特殊的两节点集群；node01和node02都把时间服务器地址指向内网192.168.0.99这个时间服务器上；有关时间服务器的配置请参考&lt;a href=&quot;https://www.cnblogs.com/qiuhom-1874/p/12079927.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/qiuhom-1874/p/12079927.html&lt;/a&gt;；有关ssh互信配置可以参考&lt;a href=&quot;https://www.cnblogs.com/qiuhom-1874/p/11783371.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/qiuhom-1874/p/11783371.html&lt;/a&gt;；&lt;/p&gt;
&lt;p&gt;　　配置好时间同步和ssh户型以及host主机名解析以后，接下来安装pacemaker&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node01 ~]# yum install pacemaker
已加载插件：fastestmirror, langpacks
base                                                                         | 3.6 kB  00:00:00     
docker-ce-stable                                                             | 3.5 kB  00:00:00     
epel                                                                         | 4.7 kB  00:00:00     
extras                                                                       | 2.9 kB  00:00:00     
updates                                                                      | 2.9 kB  00:00:00     
(1/3): epel/x86_64/updateinfo                                                | 1.0 MB  00:00:00     
(2/3): epel/x86_64/primary_db                                                | 6.9 MB  00:00:01     
(3/3): updates/7/x86_64/primary_db                                           | 4.5 MB  00:00:01     
Loading mirror speeds from cached hostfile
 * base: mirrors.aliyun.com
 * extras: mirrors.aliyun.com
 * updates: mirrors.aliyun.com
正在解决依赖关系
--&amp;gt; 正在检查事务
---&amp;gt; 软件包 pacemaker.x86_64.0.1.1.21-4.el7 将被 安装
--&amp;gt; 正在处理依赖关系 pacemaker-libs(x86-64) = 1.1.21-4.el7，它被软件包 pacemaker-1.1.21-4.el7.x86_64 需要
--&amp;gt; 正在处理依赖关系 pacemaker-cluster-libs(x86-64) = 1.1.21-4.el7，它被软件包 pacemaker-1.1.21-4.el7.x86_64 需要
--&amp;gt; 正在处理依赖关系 pacemaker-cli = 1.1.21-4.el7，它被软件包 pacemaker-1.1.21-4.el7.x86_64 需要
--&amp;gt; 正在处理依赖关系 libqb &amp;gt; 0.17.0，它被软件包 pacemaker-1.1.21-4.el7.x86_64 需要
--&amp;gt; 正在处理依赖关系 resource-agents，它被软件包 pacemaker-1.1.21-4.el7.x86_64 需要
--&amp;gt; 正在处理依赖关系 libquorum.so.5(COROSYNC_QUORUM_1.0)(64bit)，它被软件包 pacemaker-1.1.21-4.el7.x86_64 需要
--&amp;gt; 正在处理依赖关系 libcmap.so.4(COROSYNC_CMAP_1.0)(64bit)，它被软件包 pacemaker-1.1.21-4.el7.x86_64 需要
--&amp;gt; 正在处理依赖关系 libcfg.so.6(COROSYNC_CFG_0.82)(64bit)，它被软件包 pacemaker-1.1.21-4.el7.x86_64 需要
--&amp;gt; 正在处理依赖关系 corosync，它被软件包 pacemaker-1.1.21-4.el7.x86_64 需要
……省略部分内容……
依赖关系解决

====================================================================================================
 Package                         架构            版本                        源                大小
====================================================================================================
正在安装:
 pacemaker                       x86_64          1.1.21-4.el7                base             478 k
为依赖而安装:
 corosync                        x86_64          2.4.5-4.el7                 base             221 k
 corosynclib                     x86_64          2.4.5-4.el7                 base             136 k
 libqb                           x86_64          1.0.1-9.el7                 base              96 k
 pacemaker-cli                   x86_64          1.1.21-4.el7                base             362 k
 pacemaker-cluster-libs          x86_64          1.1.21-4.el7                base             163 k
 pacemaker-libs                  x86_64          1.1.21-4.el7                base             637 k
 perl-TimeDate                   noarch          1:2.30-2.el7                base              52 k
 resource-agents                 x86_64          4.1.1-46.el7_8.2            updates          455 k

事务概要
====================================================================================================
安装  1 软件包 (+8 依赖软件包)

总下载量：2.5 M
安装大小：6.5 M
Is this ok [y/d/N]: y
Downloading packages:
(1/9): corosynclib-2.4.5-4.el7.x86_64.rpm                                    | 136 kB  00:00:00     
(2/9): corosync-2.4.5-4.el7.x86_64.rpm                                       | 221 kB  00:00:00     
(3/9): libqb-1.0.1-9.el7.x86_64.rpm                                          |  96 kB  00:00:00     
(4/9): pacemaker-1.1.21-4.el7.x86_64.rpm                                     | 478 kB  00:00:00     
(5/9): pacemaker-cli-1.1.21-4.el7.x86_64.rpm                                 | 362 kB  00:00:00     
(6/9): pacemaker-libs-1.1.21-4.el7.x86_64.rpm                                | 637 kB  00:00:00     
(7/9): perl-TimeDate-2.30-2.el7.noarch.rpm                                   |  52 kB  00:00:00     
(8/9): pacemaker-cluster-libs-1.1.21-4.el7.x86_64.rpm                        | 163 kB  00:00:00     
(9/9): resource-agents-4.1.1-46.el7_8.2.x86_64.rpm                           | 455 kB  00:00:00     
----------------------------------------------------------------------------------------------------
总计                                                                2.0 MB/s | 2.5 MB  00:00:01     
Running transaction check
Running transaction test
Transaction test succeeded
Running transaction
  正在安装    : libqb-1.0.1-9.el7.x86_64                                                        1/9 
  正在安装    : corosynclib-2.4.5-4.el7.x86_64                                                  2/9 
  正在安装    : corosync-2.4.5-4.el7.x86_64                                                     3/9 
  正在安装    : pacemaker-libs-1.1.21-4.el7.x86_64                                              4/9 
  正在安装    : pacemaker-cluster-libs-1.1.21-4.el7.x86_64                                      5/9 
  正在安装    : 1:perl-TimeDate-2.30-2.el7.noarch                                               6/9 
  正在安装    : pacemaker-cli-1.1.21-4.el7.x86_64                                               7/9 
  正在安装    : resource-agents-4.1.1-46.el7_8.2.x86_64                                         8/9 
  正在安装    : pacemaker-1.1.21-4.el7.x86_64                                                   9/9 
  验证中      : pacemaker-cli-1.1.21-4.el7.x86_64                                               1/9 
  验证中      : pacemaker-libs-1.1.21-4.el7.x86_64                                              2/9 
  验证中      : libqb-1.0.1-9.el7.x86_64                                                        3/9 
  验证中      : corosynclib-2.4.5-4.el7.x86_64                                                  4/9 
  验证中      : pacemaker-1.1.21-4.el7.x86_64                                                   5/9 
  验证中      : corosync-2.4.5-4.el7.x86_64                                                     6/9 
  验证中      : pacemaker-cluster-libs-1.1.21-4.el7.x86_64                                      7/9 
  验证中      : resource-agents-4.1.1-46.el7_8.2.x86_64                                         8/9 
  验证中      : 1:perl-TimeDate-2.30-2.el7.noarch                                               9/9 

已安装:
  pacemaker.x86_64 0:1.1.21-4.el7                                                                   

作为依赖被安装:
  corosync.x86_64 0:2.4.5-4.el7                      corosynclib.x86_64 0:2.4.5-4.el7               
  libqb.x86_64 0:1.0.1-9.el7                         pacemaker-cli.x86_64 0:1.1.21-4.el7            
  pacemaker-cluster-libs.x86_64 0:1.1.21-4.el7       pacemaker-libs.x86_64 0:1.1.21-4.el7           
  perl-TimeDate.noarch 1:2.30-2.el7                  resource-agents.x86_64 0:4.1.1-46.el7_8.2      

完毕！
[root@node01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：安装pacemaker会依赖corosync这个包，所以直接安装pacemaker这一个包就可以了；对于node02也是同样的操作；&lt;/p&gt;
&lt;p&gt;　　配置corosync&lt;/p&gt;
&lt;p&gt;　　查看corosync的程序环境&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node01 ~]# rpm -ql corosync
/etc/corosync
/etc/corosync/corosync.conf.example
/etc/corosync/corosync.conf.example.udpu
/etc/corosync/corosync.xml.example
/etc/corosync/uidgid.d
/etc/dbus-1/system.d/corosync-signals.conf
/etc/logrotate.d/corosync
/etc/sysconfig/corosync
/etc/sysconfig/corosync-notifyd
/usr/bin/corosync-blackbox
/usr/bin/corosync-xmlproc
/usr/lib/systemd/system/corosync-notifyd.service
/usr/lib/systemd/system/corosync.service
/usr/sbin/corosync
/usr/sbin/corosync-cfgtool
/usr/sbin/corosync-cmapctl
/usr/sbin/corosync-cpgtool
/usr/sbin/corosync-keygen
/usr/sbin/corosync-notifyd
/usr/sbin/corosync-quorumtool
/usr/share/corosync
/usr/share/corosync/corosync
/usr/share/corosync/corosync-notifyd
/usr/share/corosync/xml2conf.xsl
/usr/share/doc/corosync-2.4.5
/usr/share/doc/corosync-2.4.5/LICENSE
/usr/share/doc/corosync-2.4.5/SECURITY
/usr/share/man/man5/corosync.conf.5.gz
/usr/share/man/man5/corosync.xml.5.gz
/usr/share/man/man5/votequorum.5.gz
/usr/share/man/man8/cmap_keys.8.gz
/usr/share/man/man8/corosync-blackbox.8.gz
/usr/share/man/man8/corosync-cfgtool.8.gz
/usr/share/man/man8/corosync-cmapctl.8.gz
/usr/share/man/man8/corosync-cpgtool.8.gz
/usr/share/man/man8/corosync-keygen.8.gz
/usr/share/man/man8/corosync-notifyd.8.gz
/usr/share/man/man8/corosync-quorumtool.8.gz
/usr/share/man/man8/corosync-xmlproc.8.gz
/usr/share/man/man8/corosync.8.gz
/usr/share/man/man8/corosync_overview.8.gz
/usr/share/snmp/mibs/COROSYNC-MIB.txt
/var/lib/corosync
/var/log/cluster
[root@node01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：/etc/corosync这个目录用来存放corosync配置文件；其中corosync.conf.example是corosync的文本格式配置文件示例；corosync.conf.example.udpu这个是corosync使用udpu方式提供服务的配置文件示例；corosync.xml.example是xml格式的配置文件示例；/usr/lib/systemd/system/corosync.service这个是corosync unit file文件；/usr/sbin/corosync二进制程序文件；/usr/sbin/corosync-keygen这个工具用于生成corosync的密钥文件；/var/lib/corosync这个目录主要存放CIB数据库文件；/var/log/cluster/目录用于存放日志相关文件；&lt;/p&gt;
&lt;p&gt;　　复制/etc/corosync/corosync.conf.example文件为/etc/corosync.conf&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node01 ~]# cp /etc/corosync/corosync.conf.example /etc/corosync/corosync.conf
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　编辑配置文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202008/1503305-20200830232328620-841348026.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：对于totem这个配置段主要用于配置totem协议的相关属性，其中version表示使用的版本，默认是2这个不用更改，保持默认就好；下面的crypto_cipher和crypto_hash这两项用于配置是否启用加密，这里默认是none，这意味这只要是在相同多播域内，它都会识别成集群成员；所以为了安全建议启用集群事务消息通信加密；默认情况crypto_cipher支持aes256, aes192, aes128 and 3des这些加密算法，随便配置一个加密算法即可；crypto_hash支持md5, sha1, sha256, sha384，sha512这些加密算法，随便选一个即可；如果启用以上两项加密，我们需要在/etc/corosync/目录下创建一个密钥文件，且权限是600或着400的权限；并且集群各节点的密钥文件必须相同；&lt;/p&gt;
&lt;p&gt;　　创建密钥文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node01 ~]# corosync-keygen 
Corosync Cluster Engine Authentication key generator.
Gathering 1024 bits for key from /dev/random.
Press keys on your keyboard to generate entropy.
Press keys on your keyboard to generate entropy (bits = 920).
Press keys on your keyboard to generate entropy (bits = 1000).
Writing corosync key to /etc/corosync/authkey.
[root@node01 ~]# ll /etc/corosync/
总用量 20
-r-------- 1 root root  128 8月  30 23:30 authkey
-rw-r--r-- 1 root root 2886 8月  30 23:30 corosync.conf
-rw-r--r-- 1 root root 2881 4月   2 21:28 corosync.conf.example
-rw-r--r-- 1 root root  767 4月   2 21:28 corosync.conf.example.udpu
-rw-r--r-- 1 root root 3278 4月   2 21:28 corosync.xml.example
drwxr-xr-x 2 root root    6 4月   2 21:28 uidgid.d
[root@node01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以现在把密钥文件复制给node02也可以待会把配置文件配置好以后一并复制给node02都行；&lt;/p&gt;
&lt;p&gt;　　继续编辑配置文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202008/1503305-20200830233243240-1895845083.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：interface配置段主要用于定义集群事务信息通信接口相关参数；其中ringnumber: 0表示第一块网卡，如果有第二卡和第三块，可以在totem配置段继续用interface配置段来指定；bindnetaddr: 192.168.0.0用于配置用于集群事务信息通信的网络地址，它默认会根据我们配置的网络地址去本地主机上找对应的网卡；当然我们也可以配置ip地址也行，通常建议使用网络地址；mcastaddr：是用来指定多播通信地址；这个如果在实验环境中可以不用该，只要在集群中的各节点都是同一个多播地址即可；在生产中一定要注意不能和其他集群的多播通信地址冲突；mcastport用于指定多播通信的端口，默认是5405，这个通常不需要更改，保持默认即可；ttl: 1这个是配置多播通信的报文生存时长，默认配置为1，是为了防止其他节点收到多播报文后再次转发；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202008/1503305-20200830234021907-1263407507.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：logging配置段主要用于定义日志相关；其中fileline: off表示不开启fileline；所谓fileline就是记录源文件和消息所在的行； to_stderr: no表示不把日志输出到标准错误控制台；to_logfile: yes表示把日志输出到文件；logfile: /var/log/cluster/corosync.log用于指定日志文件路径； to_syslog: yes是否将日志发送给syslog，默认是允许；debug: off是否关闭调试信息；默认是关闭的；timestamp: on是否加上时间戳，默认是开启；如果我们只玩syslog中发送日志，可以将这一项关闭，因为syslog会自动将时间给我们补上；logger_subsys用于定义日志子系统，subsys指子系统的名称，debug指定是否开启调试信息；上面的subsys: QUORUM 表示开启记录quorum的日志信息；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202008/1503305-20200830234744440-466125325.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：quorum用于配置投票系统相关配置，这里面默认是注释了，我们只需要打开provider： corosync_votequorum即可；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202008/1503305-20200830235643742-1638552604.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：nodelist这段配置在默认的配置文件中没有，我们加上这段配置就是告诉corosync我们期望的集群中的节点有两个，他们的ip地址是那些；这里的ip地址可以写主机名，也可以写ip地址，建议使用主机名；&lt;/p&gt;
&lt;p&gt;　　复制/etc/corosync/corosync.conf 和authkey文件到其他节点&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202008/1503305-20200831000701325-526058517.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　启动corosync&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202008/1503305-20200831000740540-1405307146.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202008/1503305-20200831000827732-326663210.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：如果启动corosync服务以后，能够看到udp的5405端口和5404端口处于监听状态和我们配置的多播地址，则说明corosync服务就配置好了；&lt;/p&gt;
&lt;p&gt;　　验证：查看corosync的日志，看看是否识别到两个节点&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202008/1503305-20200831002220425-1888378533.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：在node01上可以看到对应的集群成员有2个；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202008/1503305-20200831002427563-846516074.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：在node02的日志文件中也能看到node01加入到集群，对应集群成员有两个；&lt;/p&gt;
&lt;p&gt;　　验证：使用corosync-cfgtool命令来查看当前节点的初始化信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202008/1503305-20200831003627215-420042319.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：-s表示查看当前节点各ring上的状态信息；从上面的信息可以看到node01上节点id为1，ring0上的id为192.168.0.41，状态是活跃没有发现错误；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202008/1503305-20200831003834415-1482980191.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：同样在node02上使用corosync-cfgtool -s 可以看到当前node02上的ring0的状态信息；从上面的截图可以看到两个节点都已经处于活跃状态；&lt;/p&gt;
&lt;p&gt;　　验证：使用corosync-cmaptools查看成员&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node01 ~]# corosync-cmapctl 
config.totemconfig_reload_in_progress (u8) = 0
internal_configuration.service.0.name (str) = corosync_cmap
internal_configuration.service.0.ver (u32) = 0
internal_configuration.service.1.name (str) = corosync_cfg
internal_configuration.service.1.ver (u32) = 0
internal_configuration.service.2.name (str) = corosync_cpg
internal_configuration.service.2.ver (u32) = 0
internal_configuration.service.3.name (str) = corosync_quorum
internal_configuration.service.3.ver (u32) = 0
internal_configuration.service.4.name (str) = corosync_pload
internal_configuration.service.4.ver (u32) = 0
internal_configuration.service.5.name (str) = corosync_votequorum
internal_configuration.service.5.ver (u32) = 0
logging.debug (str) = off
logging.fileline (str) = off
logging.logfile (str) = /var/log/cluster/corosync.log
logging.logger_subsys.QUORUM.debug (str) = off
logging.logger_subsys.QUORUM.subsys (str) = QUORUM
logging.timestamp (str) = on
logging.to_logfile (str) = yes
logging.to_stderr (str) = no
logging.to_syslog (str) = yes
nodelist.local_node_pos (u32) = 0
nodelist.node.0.nodeid (u32) = 1
nodelist.node.0.ring0_addr (str) = node01.test.org
nodelist.node.1.nodeid (u32) = 2
nodelist.node.1.ring0_addr (str) = node02.test.org
quorum.provider (str) = corosync_votequorum
runtime.blackbox.dump_flight_data (str) = no
runtime.blackbox.dump_state (str) = no
runtime.config.totem.block_unlisted_ips (u32) = 1
runtime.config.totem.consensus (u32) = 1200
runtime.config.totem.downcheck (u32) = 1000
runtime.config.totem.fail_recv_const (u32) = 2500
runtime.config.totem.heartbeat_failures_allowed (u32) = 0
runtime.config.totem.hold (u32) = 180
runtime.config.totem.join (u32) = 50
runtime.config.totem.max_messages (u32) = 17
runtime.config.totem.max_network_delay (u32) = 50
runtime.config.totem.merge (u32) = 200
runtime.config.totem.miss_count_const (u32) = 5
runtime.config.totem.rrp_autorecovery_check_timeout (u32) = 1000
runtime.config.totem.rrp_problem_count_mcast_threshold (u32) = 100
runtime.config.totem.rrp_problem_count_threshold (u32) = 10
runtime.config.totem.rrp_problem_count_timeout (u32) = 2000
runtime.config.totem.rrp_token_expired_timeout (u32) = 238
runtime.config.totem.send_join (u32) = 0
runtime.config.totem.seqno_unchanged_const (u32) = 30
runtime.config.totem.token (u32) = 1000
runtime.config.totem.token_retransmit (u32) = 238
runtime.config.totem.token_retransmits_before_loss_const (u32) = 4
runtime.config.totem.window_size (u32) = 50
runtime.connections.active (u64) = 1
runtime.connections.closed (u64) = 4
runtime.connections.corosync-cmapct:4355:0x55c18dd16300.client_pid (u32) = 4355
runtime.connections.corosync-cmapct:4355:0x55c18dd16300.dispatched (u64) = 0
runtime.connections.corosync-cmapct:4355:0x55c18dd16300.flow_control (u32) = 0
runtime.connections.corosync-cmapct:4355:0x55c18dd16300.flow_control_count (u64) = 0
runtime.connections.corosync-cmapct:4355:0x55c18dd16300.invalid_request (u64) = 0
runtime.connections.corosync-cmapct:4355:0x55c18dd16300.name (str) = corosync-cmapct
runtime.connections.corosync-cmapct:4355:0x55c18dd16300.overload (u64) = 0
runtime.connections.corosync-cmapct:4355:0x55c18dd16300.queue_size (u32) = 0
runtime.connections.corosync-cmapct:4355:0x55c18dd16300.recv_retries (u64) = 0
runtime.connections.corosync-cmapct:4355:0x55c18dd16300.requests (u64) = 0
runtime.connections.corosync-cmapct:4355:0x55c18dd16300.responses (u64) = 0
runtime.connections.corosync-cmapct:4355:0x55c18dd16300.send_retries (u64) = 0
runtime.connections.corosync-cmapct:4355:0x55c18dd16300.service_id (u32) = 0
runtime.services.cfg.0.rx (u64) = 0
runtime.services.cfg.0.tx (u64) = 0
runtime.services.cfg.1.rx (u64) = 0
runtime.services.cfg.1.tx (u64) = 0
runtime.services.cfg.2.rx (u64) = 0
runtime.services.cfg.2.tx (u64) = 0
runtime.services.cfg.3.rx (u64) = 0
runtime.services.cfg.3.tx (u64) = 0
runtime.services.cfg.service_id (u16) = 1
runtime.services.cmap.0.rx (u64) = 3
runtime.services.cmap.0.tx (u64) = 2
runtime.services.cmap.service_id (u16) = 0
runtime.services.cpg.0.rx (u64) = 0
runtime.services.cpg.0.tx (u64) = 0
runtime.services.cpg.1.rx (u64) = 0
runtime.services.cpg.1.tx (u64) = 0
runtime.services.cpg.2.rx (u64) = 0
runtime.services.cpg.2.tx (u64) = 0
runtime.services.cpg.3.rx (u64) = 0
runtime.services.cpg.3.tx (u64) = 0
runtime.services.cpg.4.rx (u64) = 0
runtime.services.cpg.4.tx (u64) = 0
runtime.services.cpg.5.rx (u64) = 3
runtime.services.cpg.5.tx (u64) = 2
runtime.services.cpg.6.rx (u64) = 0
runtime.services.cpg.6.tx (u64) = 0
runtime.services.cpg.service_id (u16) = 2
runtime.services.pload.0.rx (u64) = 0
runtime.services.pload.0.tx (u64) = 0
runtime.services.pload.1.rx (u64) = 0
runtime.services.pload.1.tx (u64) = 0
runtime.services.pload.service_id (u16) = 4
runtime.services.quorum.service_id (u16) = 3
runtime.services.votequorum.0.rx (u64) = 7
runtime.services.votequorum.0.tx (u64) = 4
runtime.services.votequorum.1.rx (u64) = 0
runtime.services.votequorum.1.tx (u64) = 0
runtime.services.votequorum.2.rx (u64) = 0
runtime.services.votequorum.2.tx (u64) = 0
runtime.services.votequorum.3.rx (u64) = 0
runtime.services.votequorum.3.tx (u64) = 0
runtime.services.votequorum.service_id (u16) = 5
runtime.totem.pg.mrp.rrp.0.faulty (u8) = 0
runtime.totem.pg.mrp.srp.avg_backlog_calc (u32) = 0
runtime.totem.pg.mrp.srp.avg_token_workload (u32) = 0
runtime.totem.pg.mrp.srp.commit_entered (u64) = 2
runtime.totem.pg.mrp.srp.commit_token_lost (u64) = 0
runtime.totem.pg.mrp.srp.consensus_timeouts (u64) = 0
runtime.totem.pg.mrp.srp.continuous_gather (u32) = 0
runtime.totem.pg.mrp.srp.continuous_sendmsg_failures (u32) = 0
runtime.totem.pg.mrp.srp.firewall_enabled_or_nic_failure (u8) = 0
runtime.totem.pg.mrp.srp.gather_entered (u64) = 2
runtime.totem.pg.mrp.srp.gather_token_lost (u64) = 0
runtime.totem.pg.mrp.srp.mcast_retx (u64) = 0
runtime.totem.pg.mrp.srp.mcast_rx (u64) = 12
runtime.totem.pg.mrp.srp.mcast_tx (u64) = 13
runtime.totem.pg.mrp.srp.memb_commit_token_rx (u64) = 4
runtime.totem.pg.mrp.srp.memb_commit_token_tx (u64) = 4
runtime.totem.pg.mrp.srp.memb_join_rx (u64) = 5
runtime.totem.pg.mrp.srp.memb_join_tx (u64) = 3
runtime.totem.pg.mrp.srp.memb_merge_detect_rx (u64) = 1771
runtime.totem.pg.mrp.srp.memb_merge_detect_tx (u64) = 1771
runtime.totem.pg.mrp.srp.members.1.config_version (u64) = 0
runtime.totem.pg.mrp.srp.members.1.ip (str) = r(0) ip(192.168.0.41) 
runtime.totem.pg.mrp.srp.members.1.join_count (u32) = 1
runtime.totem.pg.mrp.srp.members.1.status (str) = joined
runtime.totem.pg.mrp.srp.members.2.config_version (u64) = 0
runtime.totem.pg.mrp.srp.members.2.ip (str) = r(0) ip(192.168.0.42) 
runtime.totem.pg.mrp.srp.members.2.join_count (u32) = 1
runtime.totem.pg.mrp.srp.members.2.status (str) = joined
runtime.totem.pg.mrp.srp.mtt_rx_token (u32) = 181
runtime.totem.pg.mrp.srp.operational_entered (u64) = 2
runtime.totem.pg.mrp.srp.operational_token_lost (u64) = 0
runtime.totem.pg.mrp.srp.orf_token_rx (u64) = 3624
runtime.totem.pg.mrp.srp.orf_token_tx (u64) = 2
runtime.totem.pg.mrp.srp.recovery_entered (u64) = 2
runtime.totem.pg.mrp.srp.recovery_token_lost (u64) = 0
runtime.totem.pg.mrp.srp.rx_msg_dropped (u64) = 0
runtime.totem.pg.mrp.srp.token_hold_cancel_rx (u64) = 0
runtime.totem.pg.mrp.srp.token_hold_cancel_tx (u64) = 0
runtime.totem.pg.msg_queue_avail (u32) = 0
runtime.totem.pg.msg_reserved (u32) = 1
runtime.votequorum.ev_barrier (u32) = 2
runtime.votequorum.highest_node_id (u32) = 2
runtime.votequorum.lowest_node_id (u32) = 1
runtime.votequorum.this_node_id (u32) = 1
runtime.votequorum.two_node (u8) = 0
totem.crypto_cipher (str) = aes256
totem.crypto_hash (str) = sha1
totem.interface.0.bindnetaddr (str) = node01.test.org
totem.interface.0.mcastaddr (str) = 239.255.100.12
totem.interface.0.mcastport (u16) = 5405
totem.interface.0.ttl (u8) = 1
totem.version (u32) = 2
[root@node01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：默认不跟任何选项表示答应当前CIB中保存的配置内容；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202008/1503305-20200831004450367-533870761.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202008/1503305-20200831004519287-1717222912.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：通过grep过滤，可以看到有两个成员，他们的ip地址分别是192.168.0.41和42；到此corosync就配置并启动成功了；&lt;/p&gt;
&lt;p&gt;　　完整的corosync.conf配置文件内容&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('5e9680ea-b356-462c-84b2-96a863ed5628')&quot; readability=&quot;32.5&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_5e9680ea-b356-462c-84b2-96a863ed5628&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_5e9680ea-b356-462c-84b2-96a863ed5628&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_5e9680ea-b356-462c-84b2-96a863ed5628&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
[root@node01 ~]# &lt;span&gt;grep&lt;/span&gt; -v &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;^[[:space:]].*#&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /etc/corosync/&lt;span&gt;corosync.conf
# Please read the corosync.conf.&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt; manual page
totem {
        version: &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;

        crypto_cipher: aes256
        crypto_hash: sha1

        interface {
                ringnumber: &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
                bindnetaddr: &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;
                mcastaddr: &lt;/span&gt;&lt;span&gt;239.255&lt;/span&gt;.&lt;span&gt;100.12&lt;/span&gt;&lt;span&gt;
                mcastport: &lt;/span&gt;&lt;span&gt;5405&lt;/span&gt;&lt;span&gt;
                ttl: &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
        }
}

logging {
        fileline: off
        to_stderr: no
        to_logfile: yes
        logfile: &lt;/span&gt;/var/log/cluster/&lt;span&gt;corosync.log
        to_syslog: yes
        debug: off
        timestamp: on
        logger_subsys {
                subsys: QUORUM
                debug: off
        }
}

quorum {
        provider: corosync_votequorum
}

nodelist {
        node {
                ring0_addr: node01.test.org
                nodeid: &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
        }
        node {
                ring0_addr: node02.test.org
                nodeid: &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
        }
}

[root@node01 &lt;/span&gt;~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　启动pacamaker服务&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202008/1503305-20200831004750444-882981015.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202008/1503305-20200831004823662-516253738.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：pacemaker默认不需要怎么配置就可以启动，启动以后，我们可以通过管理接口来配置；默认才开始启动pacemaker时都会有一个pengine的进程启动，但是通常只有DC上的pengine才会生效；&lt;/p&gt;
&lt;p&gt;　　验证：查看DC节点所在节点/集群状态信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202008/1503305-20200831005314895-631759901.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：在集群任何一个几点执行crm_mon就可以看到当前集群的状态信息；上面截图中可以看到node01.test.ort是dc节点，在线的节点有两个，分别是node01.test.org和node02.test.org；&lt;/p&gt;
&lt;p&gt;　　到此corosync+pacemaker高可用集群就搭建好了，后续我们就直接可以在上面托管服务；&lt;/p&gt;
</description>
<pubDate>Sun, 30 Aug 2020 17:25:00 +0000</pubDate>
<dc:creator>Linux-1874</dc:creator>
<og:description>1、概念 在传统Linux集群种类，主要分了三类，一类是LB集群，这类集群主要作用是对用户的流量做负载均衡，让其后端每个server都能均衡的处理一部分请求；这类集群有一个特点就是前端调度器通常是单点</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qiuhom-1874/p/13585921.html</dc:identifier>
</item>
<item>
<title>Android Weekly Notes Issue #428 - 圣骑士wind</title>
<link>http://www.cnblogs.com/mengdd/p/android-weekly-notes-issue-428.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mengdd/p/android-weekly-notes-issue-428.html</guid>
<description>&lt;p&gt;Android Weekly笔记, Issue #428.&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;197.75685879688&quot;&gt;


&lt;p&gt;这是讲协程Flow系列文章中的一篇.&lt;/p&gt;
&lt;p&gt;对于重试的两个操作符:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;retryWhen&lt;/li&gt;
&lt;li&gt;retry&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;retryWhen的使用:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;.retryWhen { cause, attempt -&amp;gt;
    if (cause is IOException &amp;amp;&amp;amp; attempt &amp;lt; 3) {
        delay(2000)
        return@retryWhen true
    } else {
        return@retryWhen false
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;retry:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;.retry(retries = 3) { cause -&amp;gt;
    if (cause is IOException) {
        delay(2000)
        return@retry true
    } else {
        return@retry false
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以把时间指数延长:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;viewModelScope.launch {
    var currentDelay = 1000L
    val delayFactor = 2
    doLongRunningTask()
        .flowOn(Dispatchers.Default)
        .retry(retries = 3) { cause -&amp;gt;
            if (cause is IOException) {
                delay(currentDelay)
                currentDelay = (currentDelay * delayFactor)
                return@retry true
            } else {
                return@retry false
            }
        }
        .catch {
            // error
        }
        .collect {
            // success
        }
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;Fragment在Android 10已经废弃, 现在不在framework中了, 只在AndroidX中有.&lt;/p&gt;
&lt;p&gt;这个&lt;a href=&quot;https://developer.android.com/jetpack/androidx/releases/fragment#1.3.0-alpha08&quot;&gt;Fragment 1.3.0-alpha08&lt;/a&gt;版本的发布, 有一些关于FragmentManager内部状态的重要更新.&lt;br/&gt;解决了很多issue, 简化了fragment的生命周期, 还提供了一个FragmentManager多个back stacks的支持.&lt;/p&gt;
&lt;p&gt;核心就是这个&lt;a href=&quot;https://cs.android.com/androidx/platform/frameworks/support/+/androidx-master-dev:fragment/fragment/src/main/java/androidx/fragment/app/FragmentStateManager.java?ss=androidx&quot;&gt;FragmentStateManager&lt;/a&gt;类.&lt;/p&gt;
&lt;p&gt;这个FragmentStateManager负责:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;转换Fragment的生命周期状态.&lt;/li&gt;
&lt;li&gt;跑动画和转场.&lt;/li&gt;
&lt;li&gt;处理延迟转换.&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;postponed-fragments&quot;&gt;Postponed fragments&lt;/h3&gt;
&lt;p&gt;关于状态的确定, 有一个case是一个难点: postponed fragments.&lt;br/&gt;这是一个以前就有的东西, 通常跟shared element transition动画有关系.&lt;/p&gt;
&lt;p&gt;postponed fragment有两个特点:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;view创建了, 但是不可见.&lt;/li&gt;
&lt;li&gt;lifecycle顶多到&lt;code&gt;STARTED&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;只有调用这个方法: &lt;code&gt;startPostponedEnterTransition()&lt;/code&gt;之后, fragment的transition才会跑, view会变成可见, fragment会移动到&lt;code&gt;RESUMED&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;所以有这个bug: &lt;a href=&quot;https://issuetracker.google.com/issues/147749580&quot;&gt;Postponed Fragments leave the Fragments and FragmentManager in an inconsistent state bug&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;这个issue相关联的还有好几个issues.&lt;/p&gt;
&lt;h3 id=&quot;在容器层面解决问题&quot;&gt;在容器层面解决问题&lt;/h3&gt;
&lt;p&gt;用一个&lt;a href=&quot;https://cs.android.com/androidx/platform/frameworks/support/+/androidx-master-dev:fragment/fragment/src/main/java/androidx/fragment/app/SpecialEffectsController.java&quot;&gt;SpecialEffectsController&lt;/a&gt;(以后名字可能会改)来处理所有动画转场相关的东西.&lt;/p&gt;
&lt;p&gt;这样FragmentManager就被解放出来, 不需要处理postponed的逻辑, 而是交给了container, 这样就避免了FragmentManager中状态不一致的问题.&lt;/p&gt;
&lt;h3 id=&quot;新的statemanager构架&quot;&gt;新的StateManager构架&lt;/h3&gt;
&lt;p&gt;原先: 一个&lt;code&gt;FragmentManager&lt;/code&gt;总管所有.&lt;/p&gt;
&lt;p&gt;现在: &lt;code&gt;FragmentManager&lt;/code&gt;和各个&lt;code&gt;FragmentStateManager&lt;/code&gt;的实例交流.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;The &lt;code&gt;FragmentManager&lt;/code&gt; only has state that applies to all fragments.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;FragmentStateManager&lt;/code&gt; manages the state at the fragment level.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;SpecialEffectsController&lt;/code&gt; manages the state at the container level.&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;总体&quot;&gt;总体&lt;/h3&gt;
&lt;p&gt;这个改动新发布, 实验阶段, 总体来说是应该没有行为改变的.&lt;/p&gt;
&lt;p&gt;如果有行为改变, 对你的程序造成了影响, 也可以暂时关闭(&lt;code&gt;FragmentManager.enableNewStateManager(false)&lt;/code&gt;), 并且报告个issue.&lt;/p&gt;

&lt;p&gt;讲了一整套的测试实践.&lt;/p&gt;
&lt;p&gt;没有用Appium, 用的UI Automator和Espresso.&lt;/p&gt;

&lt;p&gt;Kotlin协程的概念.&lt;/p&gt;

&lt;p&gt;Android Lint的介绍.&lt;/p&gt;
&lt;p&gt;创建一个Lint规则, 保证每个人都用项目自定义的ImageView, 而不是原生的ImageView.&lt;/p&gt;
&lt;p&gt;具体做法:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先从创建一个叫做&lt;code&gt;custom-lint&lt;/code&gt;的module. 需要依赖&lt;code&gt;lint-api&lt;/code&gt;和&lt;code&gt;lint-checks&lt;/code&gt;:&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;compileOnly &quot;com.android.tools.lint:lint-api:$androidToolsVersion&quot;
compileOnly &quot;com.android.tools.lint:lint-checks:$androidToolsVersion&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里用了&lt;code&gt;compileOnly&lt;/code&gt;是因为不想lint API在runtime available.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;之后创建自定义规则. 每个lint check的实现都叫一个detector. 需要继承&lt;code&gt;Detector&lt;/code&gt;, 并且利用&lt;code&gt;Scanners&lt;/code&gt;来做扫描. 报告错误需要定义Issue. 还可以创建&lt;code&gt;LintFx&lt;/code&gt;, 作为quick fix.&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;class ImageViewUsageDetector : LayoutDetector() {
  
   // Applicable elements
  
  
    override fun visitElement(context: XmlContext, element: Element) {
        context.report(
            issue = ISSUE, 
            location = context.getElementLocation(element), 
            message = REPORT_MESSAGE, 
            quickfixData = computeQuickFix() 
        )
    }

   
    private fun computeQuickFix(): LintFix {
        return LintFix.create()
            .replace().text(SdkConstants.IMAGE_VIEW)
            .with(TINTED_IMAGE_VIEW)
            .build()
    }

  // Issue, implementation, and other constants 

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;然后把定义好的自定义规则注册.&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;class Registry: IssueRegistry() {

    override val issues: List&amp;lt;Issue&amp;gt;
        get() = listOf(ImageViewUsageDetector.ISSUE)

    override val api: Int = CURRENT_API

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;创建入口, 在&lt;code&gt;build.gradle&lt;/code&gt;文件中:&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;
// Configure jar to register our lint registry
jar {
    manifest {
        attributes(&quot;Lint-Registry-v2&quot;: &quot;com.tintedimagelint.lint.Registry&quot;)
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;加上依赖和一些配置.&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;
android {
    
    // Configurations above
    lintOptions {
        lintConfig file('../analysis/lint/lint.xml')
        htmlOutput file(&quot;$project.buildDir/reports/lint/lint-reports.html&quot;)
        xmlOutput file(&quot;$project.buildDir/reports/lint/lint-reports.xml&quot;)
        abortOnError false
    }
    //Configurations below
}

dependencies {
    // Dependencies above

    // Include custom lint module as a lintCheck
    lintChecks project(&quot;:custom-lint&quot;)

    // Dependencies below
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;关于Android Game新技术的Codelabs:&lt;/p&gt;
&lt;p&gt;都是Unity的game.&lt;/p&gt;

&lt;p&gt;系列文章之六, 我的app啥时候启动的?&lt;/p&gt;
&lt;p&gt;看个结论吧:&lt;/p&gt;
&lt;p&gt;Here's how we can most accurately measure the app start time when monitoring cold start:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Up to API 24: Use the class load time of a content provider.&lt;/li&gt;
&lt;li&gt;API 24 - API 28: Use &lt;code&gt;Process.getStartUptimeMillis()&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;API 28 and beyond: Use &lt;code&gt;Process.getStartUptimeMillis()&lt;/code&gt; but filter out weird values (e.g. more than 1 min to get to &lt;code&gt;Application.onCreate()&lt;/code&gt;) and fallback to the time &lt;code&gt;ContentProvider.onCreate()&lt;/code&gt; is called.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;比较三种依赖注入的解决方案.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;手写方式.&lt;/li&gt;
&lt;li&gt;Koin.&lt;/li&gt;
&lt;li&gt;Dagger Hilt.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用Data Binding和View Binding的时候, 注意内存泄漏问题.&lt;/p&gt;
&lt;p&gt;Google&lt;a href=&quot;https://developer.android.com/topic/libraries/view-binding#fragments&quot;&gt;建议&lt;/a&gt;在Fragment中使用binding时, 要在onDestroyView中置为null:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private var _binding: ResultProfileBinding? = null
// This property is only valid between onCreateView and
// onDestroyView.
private val binding get() = _binding!!

override fun onCreateView(
    inflater: LayoutInflater,
    container: ViewGroup?,
    savedInstanceState: Bundle?
): View? {
    _binding = ResultProfileBinding.inflate(inflater, container, false)
    val view = binding.root
    return view
}

override fun onDestroyView() {
    super.onDestroyView()
    _binding = null
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有个&lt;a href=&quot;https://proandroiddev.com/make-android-view-binding-great-with-kotlin-b71dd9c87719&quot;&gt;博客&lt;/a&gt;中介绍的方法, 可以简化成这样:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private val binding: FragmentFirstBinding by viewBinding()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Fragment还有一个参数的构造, 可以传入布局id:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class FirstFragment : Fragment(R.layout.fragment_first) {

  private val binding: FragmentFirstBinding by viewBinding()
  
  override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
      super.onViewCreated(view, savedInstanceState)
      // Any code we used to do in onCreateView can go here instead
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;冷知识: DataBinding实现了ViewBinding.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public abstract class ViewDataBinding extends BaseObservable implements ViewBinding
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以ViewBinding和DataBinding方法通用.&lt;/p&gt;

&lt;p&gt;关于测试的一些anti-patterns.&lt;/p&gt;
&lt;p&gt;推荐阅读.&lt;/p&gt;

&lt;p&gt;关于这个库: &lt;a href=&quot;https://github.com/autonomousapps/dependency-analysis-android-gradle-plugin%E7%9A%84%E8%AF%B4%E6%98%8E&quot;&gt;https://github.com/autonomousapps/dependency-analysis-android-gradle-plugin的说明&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;code&quot;&gt;Code&lt;/h2&gt;
&lt;h2 id=&quot;后记&quot;&gt;后记&lt;/h2&gt;
&lt;p&gt;好久没在博客园发过这个系列.&lt;br/&gt;其实一直还有在更, 只不过写得比较散乱随意, 所以丢在了简书:&lt;br/&gt;&lt;a href=&quot;https://www.jianshu.com/c/e51d4d597637&quot;&gt;https://www.jianshu.com/c/e51d4d597637&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近有点忙, 不太有时间写博客, 积攒了好多话题都是没有完成的.&lt;br/&gt;看博客两个月没更了, 拿这篇刷一下存在感.&lt;br/&gt;是想多写点真正厉害有价值的原创的.&lt;br/&gt;先韬光养晦, 积累一下.&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Sun, 30 Aug 2020 16:59:00 +0000</pubDate>
<dc:creator>圣骑士wind</dc:creator>
<og:description>Android Weekly笔记, Issue #428.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mengdd/p/android-weekly-notes-issue-428.html</dc:identifier>
</item>
</channel>
</rss>