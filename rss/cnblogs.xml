<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>自然语言处理系列-4条件随机场（CRF）及其tensorlofw实现 - 小Dream</title>
<link>http://www.cnblogs.com/jen104/p/10549690.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jen104/p/10549690.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　前些天与一位&lt;/span&gt;NLP&lt;span&gt;大牛交流，请教其如何提升技术水平，其跟我讲务必要重视“&lt;/span&gt;&lt;strong&gt;NLP的最基本知识&lt;/strong&gt;”的掌握。掌握好最基本的模型理论，不管是对日常工作和后续论文的发表都有重要的意义。小&lt;span&gt;Dream&lt;/span&gt;&lt;span&gt;听了不禁心里一颤，那些自认为放在“历史尘埃”里的机器学习算法我都只有了解了一个大概，至于&lt;/span&gt;&lt;span&gt;NLP&lt;/span&gt;&lt;span&gt;早期的那些大作也鲜有拜读。心下便决定要好好补一补这个空缺。所以，接下来的数篇文章会相继介绍在&lt;/span&gt;&lt;span&gt;NLP&lt;/span&gt;&lt;span&gt;中应用比较多的一些机器学习模型，隐马尔科夫模型（&lt;/span&gt;&lt;span&gt;HMM&lt;/span&gt;&lt;span&gt;），条件随机场（&lt;/span&gt;&lt;span&gt;CRF&lt;/span&gt;&lt;span&gt;），朴素贝叶斯，支持向量机（&lt;/span&gt;&lt;span&gt;SVM&lt;/span&gt;&lt;span&gt;），&lt;/span&gt;EM算法&lt;span&gt;等相继都会聊到，感兴趣的朋友可以订阅我的博客，或者关注我的微信公众号，会定期更新&lt;/span&gt;NLP&lt;span&gt;相关的文章。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1243524/201903/1243524-20190317231045759-2075660311.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　好了，废话不多说，这篇博客先好好聊聊条件随机场。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;1.&lt;span&gt;条件随机场是什么？&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　条件随机场（&lt;/span&gt;Conditional Random Field&lt;span&gt;，简称&lt;/span&gt;&lt;span&gt;CRF&lt;/span&gt;&lt;span&gt;），是一种判别式无向图模型。机器学习最重要的任务，是根据一些已观察到的证据（例如训练样本）来对感兴趣的未知变量（例如类别标记）进行估计和推测。概率模型提供这样一种描述的框架，将学习任务归结于计算变量的概率分布。在概率模型中，利用已知变量推测未知变量的分布称为“推断”，其核心是如何基于可观测变量推测出未知变量的条件分布。具体来说，假定所关心的变量集合为&lt;/span&gt;&lt;span&gt;Y&lt;/span&gt;&lt;span&gt;，可观测变量集合为&lt;/span&gt;&lt;span&gt;X&lt;/span&gt;&lt;span&gt;，“生成式”模型直接通过训练样本基本联合概率分布&lt;/span&gt;&lt;span&gt;P&lt;/span&gt;&lt;span&gt;（&lt;/span&gt;&lt;span&gt;Y&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;X&lt;/span&gt;&lt;span&gt;）；“判别式”模型通过先计算条件分布&lt;/span&gt;&lt;span&gt;P&lt;/span&gt;&lt;span&gt;（&lt;/span&gt;&lt;span&gt;Y|X&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　通俗来讲，&lt;/span&gt;CRF&lt;span&gt;是在给定一组变量的情况下，求解另一组变量的条件概率的模型。设&lt;/span&gt;&lt;span&gt;X&lt;/span&gt;&lt;span&gt;与&lt;/span&gt;&lt;span&gt;Y&lt;/span&gt;&lt;span&gt;是随机变量，&lt;/span&gt;&lt;span&gt;P&lt;/span&gt;&lt;span&gt;（&lt;/span&gt;&lt;span&gt;Y|X&lt;/span&gt;&lt;span&gt;）是给定随机变量&lt;/span&gt;&lt;span&gt;X&lt;/span&gt;&lt;span&gt;情况下，随机变量&lt;/span&gt;&lt;span&gt;Y&lt;/span&gt;&lt;span&gt;的条件概率。若随机变量&lt;/span&gt;&lt;span&gt;Y&lt;/span&gt;&lt;span&gt;构成一个无向图&lt;/span&gt;&lt;span&gt;G(V,E)&lt;/span&gt;&lt;span&gt;（概率图模型，请看李航，《统计学习方法》&lt;/span&gt;&lt;span&gt;chapter10&lt;/span&gt;&lt;span&gt;），同时，&lt;/span&gt;&lt;span&gt;CRF&lt;/span&gt;&lt;span&gt;满足如下的条件，&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1243524/201903/1243524-20190317231141094-302644859.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　其中，&lt;/span&gt;v&lt;span&gt;表示&lt;/span&gt;&lt;span&gt;G&lt;/span&gt;&lt;span&gt;中的任一节点，&lt;/span&gt;&lt;span&gt;v~V&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;n(v)&lt;/span&gt;&lt;span&gt;表示与&lt;/span&gt;&lt;span&gt;v&lt;/span&gt;&lt;span&gt;有边连接的节点的集合。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;在更多的情况下，应用的都是线性链条件随机场，线性链条件随机场这样定义：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;设&lt;/span&gt;X={X&lt;sub&gt;1&lt;/sub&gt;,X&lt;sub&gt;2&lt;/sub&gt;,X&lt;sub&gt;3&lt;/sub&gt;,....X&lt;sub&gt;n&lt;/sub&gt;}&lt;span&gt;，&lt;/span&gt;&lt;span&gt;Y={Y&lt;/span&gt;&lt;sub&gt;1&lt;/sub&gt;,Y&lt;sub&gt;2&lt;/sub&gt;,Y&lt;sub&gt;3&lt;/sub&gt;,....Y&lt;sub&gt;n&lt;/sub&gt;}&lt;span&gt;均为线性链表示的随机变量序列，若在给定随机变量序列&lt;/span&gt;&lt;span&gt;X&lt;/span&gt;&lt;span&gt;的情况下，随机变量序列&lt;/span&gt;&lt;span&gt;Y&lt;/span&gt;&lt;span&gt;的条件概率&lt;/span&gt;&lt;span&gt;P&lt;/span&gt;&lt;span&gt;（&lt;/span&gt;&lt;span&gt;Y|X&lt;/span&gt;&lt;span&gt;）构成条件随机场，其满足如下的条件：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1243524/201903/1243524-20190317231238985-1099960696.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1243524/201903/1243524-20190317231307395-1083620785.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;X&lt;span&gt;和&lt;/span&gt;&lt;span&gt;Y&lt;/span&gt;&lt;span&gt;具有相同图结构的线性链条件随机场&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　从上面的定义可以看出，条件随机场很适合用于解决序列标注问题问题。例如在分词问题中，&lt;/span&gt;X&lt;span&gt;可以作为输入的句子，&lt;/span&gt;&lt;span&gt;Y&lt;/span&gt;&lt;span&gt;是分词的标注结果。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　上面应该大致讲了条件随机场是个什么样的东西，有什么样的性质。可能到目前为止，同志们应该还是有点云里雾里。反正我在第一次看到这个定义的时候，能够理解上述定义，但是总感觉不通透。后来知道，是没有跟实际结合起来，所以理解不到位。但是在将实际应用之前，还有一个东西需要介绍，就是条件随机场的参数化形式。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; 2.&lt;span&gt;条件随机场的参数化形式&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　我们先列出来&lt;/span&gt;CRF&lt;span&gt;的参数化形式吧。假设&lt;/span&gt;&lt;span&gt;P&lt;/span&gt;&lt;span&gt;（&lt;/span&gt;&lt;span&gt;Y|X&lt;/span&gt;&lt;span&gt;）是随机序列&lt;/span&gt;&lt;span&gt;Y&lt;/span&gt;&lt;span&gt;在给定随机序列&lt;/span&gt;&lt;span&gt;X&lt;/span&gt;&lt;span&gt;情况下的条件随机场，则在随机变量&lt;/span&gt;&lt;span&gt;X&lt;/span&gt;&lt;span&gt;取值为&lt;/span&gt;&lt;span&gt;x&lt;/span&gt;&lt;span&gt;的情况下，随机变量&lt;/span&gt;&lt;span&gt;Y&lt;/span&gt;&lt;span&gt;的取值&lt;/span&gt;&lt;span&gt;y&lt;/span&gt;&lt;span&gt;具有如下关系：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1243524/201903/1243524-20190317231441227-1674827441.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;　　　&lt;span&gt;其中&lt;img src=&quot;https://img2018.cnblogs.com/blog/1243524/201903/1243524-20190317231531230-1567599133.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　　　&lt;/span&gt;t&lt;sub&gt;k&lt;/sub&gt;&lt;span&gt;和&lt;/span&gt;S&lt;sub&gt;l&lt;/sub&gt;&lt;span&gt;是特征函数，&lt;/span&gt;v&lt;sub&gt;k&lt;/sub&gt;&lt;span&gt;和&lt;/span&gt;u&lt;sub&gt;l&lt;/sub&gt;&lt;span&gt;是对应的权值。　　　　&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　好的，假如我们所有的&lt;/span&gt;t&lt;sub&gt;k&lt;/sub&gt;&lt;span&gt;，&lt;/span&gt;s&lt;sub&gt;l&lt;/sub&gt;&lt;span&gt;和&lt;/span&gt;v&lt;sub&gt;k&lt;/sub&gt;&lt;span&gt;，&lt;/span&gt;u&lt;sub&gt;l&lt;/sub&gt;&lt;span&gt;都已知的情况下，我们要算的&lt;/span&gt;P&lt;span&gt;（&lt;/span&gt;&lt;span&gt;Y&lt;/span&gt;&lt;sub&gt;i&lt;/sub&gt; =y&lt;sub&gt;i&lt;/sub&gt;|X&lt;span&gt;）是不是就可以算出来啦？已知的有所谓的前向&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;后向算法。在给定随机序列&lt;/span&gt;&lt;span&gt;X&lt;/span&gt;&lt;span&gt;的情况下，计算概率最大&lt;/span&gt;&lt;span&gt;Y&lt;/span&gt;&lt;span&gt;序列可以用维特比算法，感兴趣的同学可以看李航，《统计学习方法》&lt;/span&gt;&lt;span&gt;chapter11&lt;/span&gt;&lt;span&gt;，我这里就不再赘述了。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　网上绝大部分的博客到这里就结束了，但是大家应该还有一大堆的疑问，&lt;/span&gt;t&lt;sub&gt;k&lt;/sub&gt;&lt;span&gt;，&lt;/span&gt;s&lt;sub&gt;l&lt;/sub&gt;&lt;span&gt;和&lt;/span&gt;v&lt;sub&gt;k&lt;/sub&gt;&lt;span&gt;，&lt;/span&gt;u&lt;sub&gt;l&lt;/sub&gt;&lt;span&gt;如何确定和学习？在实际中我们如何使用？小&lt;/span&gt;Dream&lt;span&gt;如果只讲到这里，就会太让大家失望了。下面我们看看在&lt;/span&gt;&lt;span&gt;tensorflow&lt;/span&gt;&lt;span&gt;里，&lt;/span&gt;&lt;span&gt;CRF&lt;/span&gt;&lt;span&gt;是怎么实现的，以及我们如何使用他，经过这一段，大家对条件随机场应该就会有一个较为完整的认识了。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;3.tensorflow&lt;span&gt;里的条件随机场&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　因为小&lt;/span&gt;Dream&lt;span&gt;之前做过一个用&lt;/span&gt;&lt;span&gt;LSTM+CRF&lt;/span&gt;&lt;span&gt;的命名实体识别项目，这一节我们以命名实体识别为例，来介绍在&lt;/span&gt;&lt;span&gt;tensorflow&lt;/span&gt;&lt;span&gt;里如何使用条件随机场&lt;/span&gt;&lt;span&gt;(CRF)&lt;/span&gt;&lt;span&gt;。命名实力识别与分词一样，是一个序列标注的问题，因为篇幅问题，这里就不展开，不清楚的同学可以出门百度一下，以后我们再找机会，好好讲一下命名实体识别的项目。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;　　LSTM+CRF&lt;span&gt;网络的主要结构如下：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1243524/201903/1243524-20190317231644616-772435749.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　其他的我们先不看，我们只用知道，自然语言的句子经过神经网络进行特征提取之后，会得到一个特征输出，将这个特征和相应的标记（&lt;/span&gt;label&lt;span&gt;）输入到条件随机场中，就可以计算损失了。我们来看看具体的代码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1243524/201903/1243524-20190317231654862-1123756236.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　这是我定义的损失层，&lt;/span&gt;project_logits&lt;span&gt;是神经网络最后一层的输出，该矩阵的&lt;/span&gt;&lt;span&gt;shape&lt;/span&gt;&lt;span&gt;为&lt;/span&gt;&lt;span&gt;[batch_size, num_steps, num_tags],&lt;/span&gt; &lt;span&gt;第一个是&lt;/span&gt;&lt;span&gt;batch size&lt;/span&gt;&lt;span&gt;，第二个是输入的句子的长度，第三个标记的个数，即命名实体识别总标记的类别数。&lt;/span&gt;&lt;span&gt;targets&lt;/span&gt;&lt;span&gt;是输入句子的&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;，即每个字的&lt;/span&gt;&lt;span&gt;laibel&lt;/span&gt;&lt;span&gt;，它的维度为&lt;/span&gt;&lt;span&gt;[batch_size, num_steps]&lt;/span&gt;&lt;span&gt;。损失层定义了一个&lt;/span&gt;&lt;span&gt;self.trans&lt;/span&gt;&lt;span&gt;矩阵，大小是&lt;/span&gt;&lt;span&gt;[num_tags+1, num_tags+1]&lt;/span&gt;&lt;span&gt;， 加&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;是因为还有一个类别是未定义。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　将&lt;/span&gt;project_logit&lt;span&gt;，&lt;/span&gt;&lt;span&gt;targets&lt;/span&gt;&lt;span&gt;以及&lt;/span&gt;&lt;span&gt;self.trans&lt;/span&gt;&lt;span&gt;交给&lt;/span&gt;&lt;span&gt;tensorflow&lt;/span&gt;&lt;span&gt;的系统函数&lt;/span&gt;&lt;span&gt;crf_log_likelihood&lt;/span&gt;&lt;span&gt;即可求得损失了。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　下面我们进一步来看看&lt;/span&gt;crf_log_likelihood&lt;span&gt;是怎么实现的。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1243524/201903/1243524-20190317231725093-892082175.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1243524/201903/1243524-20190317231751988-1696773376.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　从&lt;/span&gt;crf_sequence_score&lt;span&gt;函数的实现中，我们看出，&lt;/span&gt;&lt;span&gt;tf&lt;/span&gt;&lt;span&gt;中的损失值包括一元损失和二元损失。其中&lt;/span&gt;&lt;span&gt;unary_scores&lt;/span&gt;&lt;span&gt;表示的是标记是输入序列之间的损失，&lt;/span&gt;&lt;span&gt;unary_scores&lt;/span&gt;&lt;span&gt;表示的转化矩阵的损失值。那这两项到底是什么呢？是不是和&lt;/span&gt;&lt;span&gt;CRF&lt;/span&gt;&lt;span&gt;的参数化形式感觉有点像？我们看看相关论文&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;&lt;span&gt;是怎么说的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1243524/201903/1243524-20190317231831400-976773354.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们看一下，得分分为两项，第一项，&lt;/span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1243524/201903/1243524-20190317231908142-1378165584.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　它表示输入句子中，第&lt;/span&gt;i&lt;span&gt;个词，相应标记位置的概率。举个例子，加入输入的句子是“&lt;/span&gt;&lt;span&gt;Mark Watney visit Mars&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;相应的&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;是&lt;/span&gt;&lt;span&gt;[B-PER,E-PER,O,S-LOC]&lt;/span&gt;&lt;span&gt;，则&lt;/span&gt;&lt;span&gt;P&lt;/span&gt;&lt;sub&gt;1&lt;span&gt;，“&lt;/span&gt;&lt;span&gt;B-PER&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;/sub&gt;&lt;span&gt;表示的是第一个词的标记是&lt;/span&gt;B-PER&lt;span&gt;的概率。所以第一项会是&lt;/span&gt;P&lt;sub&gt;1&lt;span&gt;，“&lt;/span&gt;&lt;span&gt;B-PER&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;/sub&gt;+P&lt;sub&gt;2&lt;span&gt;，“&lt;/span&gt;&lt;span&gt;E-PER&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;/sub&gt;+P&lt;sub&gt;3&lt;span&gt;，“&lt;/span&gt;&lt;span&gt;O&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;/sub&gt;+P&lt;sub&gt;4&lt;span&gt;，“&lt;/span&gt;&lt;span&gt;S-LOC&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;/sub&gt;&lt;span&gt;，具体在代码中，就会取到&lt;/span&gt;project_logits&lt;span&gt;矩阵中相应的值，这一点交叉熵有点像，同学们体会一下。第二项，&lt;/span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1243524/201903/1243524-20190317231928754-37568691.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;它代表的是真个序列从一个标记转化到下一个标记的损失值，这个矩阵就是&lt;/span&gt;self.trans&lt;span&gt;，它最开始是按照我们初始化的方式初始化的，然后会随着训练的过程优化。最后再对整个序列的损失值做一个归一化，也就是执行&lt;/span&gt;&lt;span&gt;crf_log_norm&lt;/span&gt;&lt;span&gt;函数。好了，&lt;/span&gt;&lt;span&gt;tensorflow&lt;/span&gt;&lt;span&gt;中&lt;/span&gt;&lt;span&gt;crf&lt;/span&gt;&lt;span&gt;就是这么实现的，是不是有种忽然开朗的感觉？？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我们来做一个总结，&lt;/span&gt;CRF&lt;span&gt;是一个在给定某一个随机序列的情况下，求另一个随机序列的概率分布的概率图模型，在序列标注的问题中有广泛的应用。在&lt;/span&gt;&lt;span&gt;tensorflow&lt;/span&gt;&lt;span&gt;中，实现了&lt;/span&gt;&lt;span&gt;crf_log_likelihood&lt;/span&gt;&lt;span&gt;函数。在本文讲的命名实体识别项目中，自然语言经是已知的序列，自然语言经过特征提取过后的&lt;/span&gt;&lt;span&gt;logits&lt;/span&gt;&lt;span&gt;被当作是&lt;/span&gt;&lt;span&gt;t&lt;/span&gt;&lt;sub&gt;k&lt;/sub&gt;&lt;span&gt;函数，随机初始化的&lt;/span&gt;self.trans&lt;span&gt;矩阵是&lt;/span&gt;&lt;span&gt;S&lt;/span&gt;&lt;sub&gt;l&lt;/sub&gt;&lt;span&gt;函数，随着训练的过程不断的优化。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这就是条件随机场要讲的全部内容啦，欢迎各位评论。后续更新&lt;/span&gt;HMM&lt;span&gt;，&lt;/span&gt;&lt;span&gt;SVM&lt;/span&gt;&lt;span&gt;等，感兴趣的朋友可以关注我的博客或者公众号。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1243524/201903/1243524-20190317232005733-1769285330.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p align=&quot;justify&quot;&gt;[1] &lt;span&gt;周志华&lt;/span&gt;. 机器学习. 清华大学出版社&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;[2] &lt;span&gt;李航&lt;/span&gt; &lt;span&gt;统计学习方法&lt;/span&gt;.清华大学出版社&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;[3]Lample G, Ballesteros M, Subramanian S, et al. Neural architectures for named entity recognition[J]. arXiv preprint arXiv:1603.01360, 2016.&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;分享时刻：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;常常再想，人生大抵苦多乐少。每个人都有太多不想做却又不得不去做的事。那么，何不在心中忘苦常乐，就算人生命有定数，也要活的自在。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 17 Mar 2019 15:34:00 +0000</pubDate>
<dc:creator>小Dream</dc:creator>
<og:description>前些天与一位NLP大牛交流，请教其如何提升技术水平，其跟我讲务必要重视“NLP的最基本知识”的掌握。掌握好最基本的模型理论，不管是对日常工作和后续论文的发表都有重要的意义。小Dream听了不禁心里一颤</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jen104/p/10549690.html</dc:identifier>
</item>
<item>
<title>MySQL索引优化经验总结 - Jasonchan1994</title>
<link>http://www.cnblogs.com/Jasonchan1994/p/10549736.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Jasonchan1994/p/10549736.html</guid>
<description>&lt;p&gt;1.对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。&lt;/p&gt;
&lt;p&gt;2.尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描。&lt;/p&gt;
&lt;p&gt;3.应尽量避免在 where 子句中使用!=或&amp;lt;&amp;gt;操作符，否则引擎将放弃使用索引而进行全表扫描。&lt;/p&gt;
&lt;p&gt;4.应尽量避免在 where 子句中使用or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描。&lt;/p&gt;
&lt;p&gt;5.应尽量避免在 where 子句中使用in 和 not in ，否则会导致全表扫描。&lt;/p&gt;
&lt;p&gt;6.应尽量避免在 where 子句中使用like，否则会导致全表扫描。&lt;/p&gt;
&lt;p&gt;7.如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然 而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。&lt;/p&gt;
&lt;p&gt;8.应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。&lt;/p&gt;
&lt;p&gt;9.应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。&lt;/p&gt;
&lt;p&gt;10.不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。&lt;/p&gt;
&lt;p&gt;11.在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。&lt;/p&gt;
&lt;p&gt;12.并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL查询可能不会去利用索引，如一表中有字段sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。&lt;/p&gt;
&lt;p&gt;13.索引并不是越多越好，索引固然可 以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。&lt;/p&gt;
</description>
<pubDate>Sun, 17 Mar 2019 15:34:00 +0000</pubDate>
<dc:creator>Jasonchan1994</dc:creator>
<og:description>1.对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。 2.尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Jasonchan1994/p/10549736.html</dc:identifier>
</item>
<item>
<title>Linux源码编译安装nginx - Lichina</title>
<link>http://www.cnblogs.com/lichina/p/10549712.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lichina/p/10549712.html</guid>
<description>&lt;p&gt;ps:一切从简&lt;/p&gt;
&lt;p&gt;一、安装所需环境：&lt;/p&gt;
&lt;p&gt;    yum -y install gcc gcc-c++ automake pcre pcre-devel zlip zlib-devel openssl openssl-devel &lt;/p&gt;
&lt;p&gt;二、下载及安装nginx&lt;/p&gt;
&lt;p&gt;1.下载nginx：wget http://nginx.org/download/nginx-1.8.1.tar.gz&lt;/p&gt;
&lt;p&gt;2.解压nginx： tar -xzf nginx-1.8.1.tar.gz&lt;/p&gt;
&lt;p&gt;3.添加用户组：groupadd www、useradd -g www www&lt;/p&gt;
&lt;p&gt;3.编译nginx：进入解压之后的目录执行 (这里prefix为安装目录)&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;./configure \--user=www \--group=www \--prefix=/usr/local/nginx \--with-http_ssl_module \--with-http_stub_status_module \--with-http_realip_module \--with-threads&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;4.安装nginx：make &amp;amp;&amp;amp; make install&lt;/p&gt;
&lt;p&gt;(安装完成之后：make[1]: Leaving directory `/usr/local/nginx-1.8.1')  无伤大雅&lt;/p&gt;
&lt;p&gt;5.验证是否安装成功：/usr/local/nginx/sbin/nginx -V&lt;/p&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;p&gt;nginx version: nginx/1.8.1&lt;/p&gt;
&lt;p&gt;built by gcc 4.8.5 20150623 (Red Hat 4.8.5-36) (GCC)&lt;/p&gt;
&lt;p&gt;built with OpenSSL 1.0.2k-fips  26 Jan 2017&lt;/p&gt;
&lt;p&gt;TLS SNI support enabled&lt;/p&gt;
&lt;p&gt;configure arguments: --user=www --group=www --prefix=/usr/local/nginx --with-http_ssl_module --with-http_stub_status_module --with-http_realip_module --with-threads&lt;/p&gt;
&lt;p&gt;三、配置nginx&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;vi /usr/lib/systemd/system/nginx.service&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;添加如下：&lt;/p&gt;
&lt;blockquote readability=&quot;20&quot;&gt;
&lt;p&gt;[Unit]&lt;/p&gt;
&lt;p&gt;Description=nginx - high performance web server&lt;/p&gt;
&lt;p&gt;Documentation=http://nginx.org/en/docs/&lt;/p&gt;
&lt;p&gt;After=network.target remote-fs.target nss-lookup.target&lt;/p&gt;
&lt;p&gt;[Service]&lt;/p&gt;
&lt;p&gt;Type=forking&lt;/p&gt;
&lt;p&gt;PIDFile=/usr/local/nginx/logs/nginx.pid&lt;/p&gt;
&lt;p&gt;ExecStartPre=/usr/local/nginx/sbin/nginx -t -c /usr/local/nginx/conf/nginx.confExecStart=/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf&lt;/p&gt;
&lt;p&gt;ExecReload=/bin/kill -s HUP $MAINPID&lt;/p&gt;
&lt;p&gt;ExecStop=/bin/kill -s QUIT $MAINPID&lt;/p&gt;
&lt;p&gt;PrivateTmp=true [Install]WantedBy=multi-user.target&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;执行：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;启动nginx：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;systemctl start nginx&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;设置开机启动：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;systemctl enable nginx&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sun, 17 Mar 2019 15:27:00 +0000</pubDate>
<dc:creator>Lichina</dc:creator>
<og:description>ps:一切从简 一、安装所需环境： yum -y install gcc gcc-c++ automake pcre pcre-devel zlip zlib-devel openssl openss</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lichina/p/10549712.html</dc:identifier>
</item>
<item>
<title>PHP 中的Trait - 牛牛的编程之路</title>
<link>http://www.cnblogs.com/hujingnb/p/10549691.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hujingnb/p/10549691.html</guid>
<description>&lt;p&gt;在PHP中有一种代码复用的技术, 因为单继承的问题, 有些公共方法无法在父类中写出, 而 Trait可以应对这种情况, 它可以定义一些复用的方法, 然后在你需要使用的类中将其引入即可.&lt;/p&gt;
&lt;p&gt;刚开始的时候给我的感觉就是将trait代码块直接拿到类中的意思, 但后来我发现, 我太天真了. &lt;/p&gt;
&lt;p&gt;PHP中的Trait用法: &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1457859/201903/1457859-20190317223547194-34513545.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;当我第一次使用的时候, 因为之前一直使用抽象类, 或者定义内部对象, 然后调用内部对象中的方法, 所以我当时有了以下几个问题: &lt;/p&gt;
&lt;ol&gt;&lt;li&gt;能否引入多个, 如果可以的话, 同名方法如何处理&lt;/li&gt;
&lt;li&gt;引入方法与现有方法重名时, 如何解决&lt;/li&gt;
&lt;li&gt;能否定义抽象方法, 因为有些方法需要知道使用时的情况, 在抽象类中, 这种情况一般通过调用抽象方法来解决&lt;/li&gt;
&lt;li&gt;能否定义字段&lt;/li&gt;
&lt;li&gt;能否将字段或方法定义为静态&lt;/li&gt;
&lt;li&gt;能否对方法进行权限控制&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;1. Trait 可以引入多个, 多个trait中存在同名方法时, 需要指定使用哪个方法, 如下: &lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1457859/201903/1457859-20190317225340466-1876752166.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2. 引入方法与现有方法重名时, 会优先调用类中已定义的方法, 其优先级顺序为: 当前类方法&amp;gt;trait方法&amp;gt;父类方法&lt;/p&gt;
&lt;p&gt;3. trait 中可以定义抽象方法, 语法与抽象类相同&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1457859/201903/1457859-20190317225833741-234837380.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.trait 中可以定义字段, 语法与类相同&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1457859/201903/1457859-20190317230153503-828592212.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5. 可以定义静态方法与静态字段&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1457859/201903/1457859-20190317230406453-1023217692.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;6. 可以进行方法权限的控制&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1457859/201903/1457859-20190317230518653-1694630070.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;7. 另外, 在trait 代码块中还可以引入其他trait代码块, 语法与类中引入相同: &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1457859/201903/1457859-20190317230918932-253825213.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;至此, 我发现了一个新的问题, 这个 trait 与抽象类有什么区别? 说什么代码复用, 这不就是多继承么? trait与抽象类功能上有区别么? 抽象类能干的, trait都能干啊. &lt;/p&gt;
&lt;p&gt;思前想后, 我觉得区别还是有的, 虽然说他们两个看着很像, 功能相似, 但是正如抽象类与接口一样(虽然这两者不同, 接口不能定义方法), 接口更侧重于定义一组公共的方法, 一种规范, 而抽象类则侧重于将子类中公共的方法进行抽离, 提高代码的复用. &lt;/p&gt;
&lt;p&gt;trait 与抽象类的侧重点也不相同&lt;/p&gt;
&lt;p&gt;trait 侧重于定义共用的代码片段, 它并不管引用此片段的类是干什么的, 只要你需要, 就可以拿走去用, 简单说就是 trait 并不约束类的类型, 而仅仅定义方法&lt;/p&gt;
&lt;p&gt;抽象类则不同, 既然你继承我, 那你干的事情肯定跟我是一样的, 不能抽象类是去与数据库交互的, 你子类去写脚本了. 所以抽象类相对 trait 更侧重于 类型的约束. &lt;/p&gt;
&lt;p&gt;嗯, 以上就是我的初步理解, 拙见. &lt;/p&gt;

</description>
<pubDate>Sun, 17 Mar 2019 15:22:00 +0000</pubDate>
<dc:creator>牛牛的编程之路</dc:creator>
<og:description>概述 在PHP中有一种代码复用的技术, 因为单继承的问题, 有些公共方法无法在父类中写出, 而 Trait可以应对这种情况, 它可以定义一些复用的方法, 然后在你需要使用的类中将其引入即可. 刚开始的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hujingnb/p/10549691.html</dc:identifier>
</item>
<item>
<title>JavaScript DOM事件模型 - Westin-Chen</title>
<link>http://www.cnblogs.com/Westin-Chen/p/10549684.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Westin-Chen/p/10549684.html</guid>
<description>&lt;p&gt;　　早期由于浏览器厂商对于浏览器市场的争夺，各家浏览器厂商对同一功能的JavaScript的实现都不进相同，本节内容介绍JavaScript的DOM事件模型及事件处理程序的分类。&lt;/p&gt;
&lt;p&gt;　　1、DOM事件模型。DOM事件模型分为两种：事件冒泡和事件捕获。事件冒泡最初是微软提出的DOM事件流的模型，顾名思义，就是值浏览器的事件流如同冒泡一样，从最低处到最高处。最低处对应的是DOM中最具体的元素，最高处则是最外层元素，最外层元素一般就是document元素。&lt;/p&gt;
&lt;p&gt;　　a、事件冒泡模型：&lt;/p&gt;
&lt;p&gt; 　　　　如下图，当点击最底层的span元素时，在冒泡模型中触发的事件流为：span的click事件触发----&amp;gt;父级元素div的click事件触发----&amp;gt;顶层的document元素的click事件触发。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1553374/201903/1553374-20190317220100787-1853791316.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　b、事件捕获模型：&lt;/p&gt;
&lt;p&gt;　　　　如下图，当点击span元素时，在事件捕获模型中触发的事件流为：最顶层的document的click事件首先被触发----&amp;gt;子容器div（同时也是span的父容器）的click事件被触发&lt;/p&gt;
&lt;p&gt;----&amp;gt;最底层的span元素的click事件触发。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1553374/201903/1553374-20190317220459611-2035869902.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　可见，事件冒泡和事件捕获的事件触发流程是完全相反的。&lt;/p&gt;

&lt;p&gt;　　2、DOM事件处理程序的分类。DOM事件处理程序分为三种：HTML事件处理程序、DOM 0级事件处理程序、DOM 2级事件处理程序（注意：、没有DOM1级事件处理程序）。&lt;/p&gt;
&lt;p&gt;　　a、HTML事件处理程序：&lt;/p&gt;
&lt;p&gt;　　　　指的是事件绑定直接写在HTML上，如:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &amp;lt;input type=&quot;button' value=&quot;button&quot; onclick=&quot;alert('button clicked!')&quot; /&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　这里button的click事件的绑定直接写在HTML中，这种写法即是HTML事件处理程序。由于这种写法造成HTML和JavaScript的紧耦合，当需要调整JavaScript事件时，不得不调整HTML代码（就算不修改JavaScript函数名，只修改函数的内部实现，仍然不推荐使用这种语法绑定事件，会增加不必要的维护成本）。&lt;/p&gt;

&lt;p&gt; 　　b、DOM 0级事件处理程序：&lt;/p&gt;
&lt;p&gt;　　　　指的是通过给JavaScript对象的事件参数属性赋值的模式，如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &amp;lt;input id=&quot;btn&quot; type=&quot;button&quot; value=&quot;button&quot; /&amp;gt;
&lt;span&gt;2&lt;/span&gt; &amp;lt;script&amp;gt;
&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; btn = document.getElementById(&quot;btn&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     btn.onclick = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         alert(&quot;button clicked!&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　这里通过直接给btnDOM对象的onclick属性赋值的形式来绑定click事件就是DOM 0级事件处理程序，赋值可以使用匿名函数的形式，也可以使用具名函数的形式，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &amp;lt;input id=&quot;btn&quot; type=&quot;button&quot; value=&quot;button&quot; /&amp;gt;
&lt;span&gt;2&lt;/span&gt; &amp;lt;script&amp;gt;
&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; btn = document.getElementById(&quot;btn&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;    btn.onclick clickHandle;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; clickHandle(){
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         alert(&quot;something clicked!&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　如需注销，只需将该属性设置为null即可，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &amp;lt;input id=&quot;btn&quot; type=&quot;button&quot; value=&quot;button&quot; /&amp;gt;
&lt;span&gt;2&lt;/span&gt; &amp;lt;script&amp;gt;
&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; btn = document.getElementById(&quot;btn&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;    btn.onclick clickHandle;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; clickHandle(){
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         alert(&quot;something clicked!&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;     btn.onclick = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt; &amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　注意：如果绑定使用的是匿名函数的形式，通过给事件属性赋值null仍然可以注销该事件。&lt;/p&gt;

&lt;p&gt;　　c、DOM 2级事件处理程序：&lt;/p&gt;
&lt;p&gt;　　　　指的是使用 addEventListener(&quot;eventName&quot;,&quot;eventHandle&quot;,false)，其中eventName表示事件名称、eventHandle表示事件处理函数，false表示是否启用事件捕获模式，默认为false。使用addEventListener函数来给DOM元素绑定事件处理程序，如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &amp;lt;input id=&quot;btn&quot; type=&quot;button&quot; value=&quot;button&quot; /&amp;gt;
&lt;span&gt;2&lt;/span&gt; &amp;lt;script&amp;gt;
&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; btn = document.getElementById(&quot;btn&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     btn.addEventListener(&quot;click&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         alert(&quot;something clicked!&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     },&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　同样，这里既可以使用匿名函数的形式也可以使用具名函数的形式，如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &amp;lt;input id=&quot;btn&quot; type=&quot;button&quot; value=&quot;button&quot; /&amp;gt;
&lt;span&gt;2&lt;/span&gt; &amp;lt;script&amp;gt;
&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; btn = document.getElementById(&quot;btn&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     btn.addEventListener(&quot;click&quot;,clickHandle,&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; clickHandle(){
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         alert(&quot;something clicked!&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　注意：通过addEventListener绑定的事件只能通过removeEventListener来注销，不能使用DOM 0级中的方式注销事件处理程序，注销事件如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &amp;lt;input id=&quot;btn&quot; type=&quot;button&quot; value=&quot;button&quot; /&amp;gt;
&lt;span&gt;2&lt;/span&gt; &amp;lt;script&amp;gt;
&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; btn = document.getElementById(&quot;btn&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     btn.addEventListener(&quot;click&quot;,clickHandle,&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; clickHandle(){
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         alert(&quot;something clicked!&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;     btn.removeEventListener(&quot;click&quot;&lt;span&gt;,clickHandle);
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt; &amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　如果绑定时使用的是匿名函数，则注销操作比较麻烦，可以通过事件参数的callee属性获取当前正在执行的函数，但必须使用在事件绑定的函数内，如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;script&amp;gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; dom=document.getElementById(&quot;content&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; clickNum=0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     dom.addEventListener(&quot;click&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e){
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     clickNum++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     alert('你摸了我'+clickNum+'下了。最多摸2下哦'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(clickNum&amp;gt;=2&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         dom.removeEventListener(e.type,arguments.callee,&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         console.log(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;});
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　d、IE中DOM 2级事件处理程序的是通过attachevent来绑定的，语法与addEventListener完全一致。&lt;/p&gt;

&lt;p&gt;　　e、DOM 0级和DOM 2级事件处理程序的主要区别：&lt;/p&gt;
&lt;p&gt;　　　　DOM 2级事件处理程序可以给元素的事件绑定多个处理程序，如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;input id=&quot;btn&quot; type=&quot;button&quot; value=&quot;button&quot; /&amp;gt;
&lt;span&gt; 2&lt;/span&gt; &amp;lt;script&amp;gt;
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; btn = document.getElementById(&quot;btn&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     btn.addEventListener(&quot;click&quot;,clickHandle1,&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     btn.addEventListener(&quot;click&quot;,clickHandle2,&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; clickHandle1(){
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         alert(&quot;something clicked!&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; clickHandle2(){
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         alert(&quot;something clicked again!&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　此时，点击btn时将会依次触发clickHandle1、clickHandle2，注销事件处理程序也需要针对每个事件处理程序使用removeEventListener。&lt;/p&gt;
&lt;p&gt;　　　    DOM 0级事件处理程序如果以这种形式绑定事件，则后写的方法会覆盖掉之前的方法，即：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;input id=&quot;btn&quot; type=&quot;button&quot; value=&quot;button&quot; /&amp;gt;
&lt;span&gt; 2&lt;/span&gt; &amp;lt;script&amp;gt;
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; btn = document.getElementById(&quot;btn&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     btn.onclick =&lt;span&gt; clickHandle1();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     btn.onclick =&lt;span&gt; clickHandle2();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; clickHandle1(){
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         alert(&quot;something clicked!&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; clickHandle2(){
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         alert(&quot;something clicked again!&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　这里实际只会绑定clickHandle2方法，clickHandle1被后面的clickHandle2覆盖掉。&lt;/p&gt;

&lt;p&gt; 　　开发过程中推荐使用DOM 0级事件处理程序或者DOM 2级事件处理程序，如果只有一个事件处理程序DOM 0级就足够了，当然，如需绑定多个事件处理程序，则需使用DOM 2级事件处理程序。&lt;/p&gt;
&lt;p&gt;　　为了屏蔽各浏览器之间的实现差异，推荐使用一些JavaScript库来辅助完成事件绑定。推荐使用jQuery，针对不同的浏览器，可以使用统一的接口来完成这一过程。&lt;/p&gt;


&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;　　js如何移除匿名函数的事件绑定 - https://www.cnblogs.com/sichaoyun/p/6776310.html&lt;/p&gt;
</description>
<pubDate>Sun, 17 Mar 2019 15:20:00 +0000</pubDate>
<dc:creator>Westin-Chen</dc:creator>
<og:description>早期由于浏览器厂商对于浏览器市场的争夺，各家浏览器厂商对同一功能的JavaScript的实现都不进相同，本节内容介绍JavaScript的DOM事件模型及事件处理程序的分类。 1、DOM事件模型。DO</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Westin-Chen/p/10549684.html</dc:identifier>
</item>
<item>
<title>java日志规约及配置示例终极总结 - 五色花的</title>
<link>http://www.cnblogs.com/luao/p/10549610.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/luao/p/10549610.html</guid>
<description>&lt;h3&gt;目录&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;什么是日志&lt;/li&gt;
&lt;li&gt;常用日志框架&lt;/li&gt;
&lt;li&gt;日志级别详解&lt;/li&gt;
&lt;li&gt;日志的记录时机&lt;/li&gt;
&lt;li&gt;日志使用规约&lt;/li&gt;
&lt;li&gt;logback 配置示例&lt;/li&gt;
&lt;li&gt;loh4j2 配置示例&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;　　简单的说，日志就是记录程序的运行轨迹，方便查找关键信息，也方便快速定位解决问题。我们 Java 程序员在开发项目时都是依赖 Eclipse/ Idea 等开发工具的 Debug 调试功能来跟踪解决 Bug，在开发环境可以这么做，但项目发布到了测试、生产环境呢？你有可能会说可以使用远程调试，但实际并不能允许让你这么做。所以，日志的作用就是在测试、生产环境没有 Debug 调试工具时开发、测试人员定位问题的手段。日志打得好，就能根据日志的轨迹快速定位并解决线上问题，反之，日志输出不好不能定位到问题不说反而会影响系统的性能。优秀的项目都是能根据日志定位问题的，而不是在线调试，或者半天找不到有用的日志。&lt;/p&gt;

&lt;p&gt;　　log4j、Logging、commons-logging、slf4j、logback，开发的同学对这几个日志相关的技术不陌生吧，为什么有这么多日志技术，它们都是什么区别和联系呢？相信大多数人搞不清楚它们的关系，下面我将一一介绍一下，以后大家再也不用傻傻分不清楚了。&lt;/p&gt;
&lt;h3&gt;Logging 【java 自带工具】&lt;/h3&gt;
&lt;p&gt;　　这是 Java 自带的日志工具类，在 JDK 1.5 开始就已经有了，在java.util.logging 包下。&lt;/p&gt;
&lt;h3&gt;Log4j 【框架实现】&lt;/h3&gt;
&lt;p&gt;　　Log4j 是 Apache 的一个开源日志框架，也是市场占有率最多的一个框架。大多数没用过 Java Logging， 但没人敢说没用过 Log4j 吧，反正从我接触 Java 开始就是这种情况，做 Java 项目必有 Log4j 日志框架。注意：log4j 在 2015/08/05 这一天被 Apache 宣布停止维护了，用户需要切换到 Log4j2上面去。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;下面是官方宣布原文&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;On August 5, 2015 the Logging Services Project Management Committee announced that Log4j 1.x had reached end of life. For complete text of the announcement please see the Apache Blog. Users of Log4j 1 are recommended to upgrade to Apache Log4j 2.&lt;/p&gt;
&lt;h3&gt;Commons-logging 【日志接口】&lt;/h3&gt;
&lt;p&gt;　　上面介绍的 log4j 是一个具体的日志框架的实现，而 commons-logging 就是日志门面接口，它也是 apache 最早提供的日志门面接口，用户可以根据喜好选择不同的日志实现框架，而不必改动日志定义，这就是日志门面的好处，符合面向接口抽象编程。&lt;/p&gt;
&lt;h3&gt;Slf4j 【日志接口】&lt;/h3&gt;
&lt;p&gt;　　全称：Simple Logging Facade for Java，即简单日志门面接口，和 Apache 的 commons-logging是一样的概念，它们都不是具体的日志框架，你可以指定其他主流的日志实现框架。Slf4j也是现在主流的日志门面框架，使用Slf4j可以很灵活的使用占位符进行参数占位，简化代码，拥有更好的可读性，这个后面会讲到。&lt;/p&gt;
&lt;h3&gt;Logback 【框架实现】&lt;/h3&gt;
&lt;p&gt;　　Logback 是 Slf4j 的原生实现框架，同样也是出自 Log4j一个人之手，但拥有比log4j更多的优点、特性和更做强的性能，现在基本都用来代替 log4j 成为主流。&lt;/p&gt;
&lt;h3&gt;日志框架总结&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;commons-loggin、slf4j 只是一种日志抽象门面，不是具体的日志框架。&lt;/li&gt;
&lt;li&gt;log4j、logback 是具体的日志实现框架。&lt;/li&gt;
&lt;li&gt;一般首选强烈推荐使用 slf4j + logback。当然也可以使用slf4j + log4j、commons-logging + log4j 这两种日志组合框架。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;　　日志的输出都是分级别的，不同的设置不同的场合打印不同的日志。下面拿最普遍用的 Log4j 日志框架来做个日志级别的说明，这个也比较全面，其他的日志框架也都大同小异。Log4j 的级别类 org.apache.log4j.Level 里面定义了日志级别，日志输出优先级由高到底分别为以下8种。&lt;/p&gt;
&lt;h3&gt;日志级别及描述&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;ERROR：系统发生了错误事件，但仍然不影响系统的继续运行。系统需要将错误或异常细节记录ERROR日志中，方便后续人工回溯解决。&lt;/li&gt;
&lt;li&gt;WARN： 系统在业务处理时触发了异常流程(参数验证不过)，但系统可恢复到正常态，下一次业务可以正常执行。如程序调用了一个旧版本的接口，可选参数不合法，非业务预期的状态但仍可继续处理等&lt;/li&gt;
&lt;li&gt;INFO： 记录系统关键信息，旨在保留系统正常工作期间关键运行指标，开发人员可以将初始化系统配置、业务状态变化信息，或者用户业务流程中的核心处理记录到INFO日志中，方便日常运维工作以及错误回溯时上下文场景复现&lt;/li&gt;
&lt;li&gt;DEBUG： 可以将各类详细信息记录到DEBUG里，起到调试的作用，包括参数信息，调试细节信息，返回值信息等。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;日志优先级别标准顺序&lt;/h3&gt;
&lt;p&gt;　　ALL &amp;lt; TRACE &amp;lt; DEBUG &amp;lt; INFO &amp;lt; WARN &amp;lt; ERROR &amp;lt; FATAL &amp;lt; OFF&lt;/p&gt;
&lt;h3&gt;设置级别和打印级别的关系&lt;/h3&gt;
&lt;p&gt;　　如果日志级别设置 INFO，只有输出级别为 INFO、WARN，后面的日志才会正常输出。&lt;/p&gt;

&lt;h3&gt;系统初始化&lt;/h3&gt;
&lt;p&gt;　　系统初始化时会依赖一些关键配置，根据参数不同会提供不一样的服务。将系统的启动参数记录INFO日志，打印出参数以及服务启动完成状态。&lt;/p&gt;
&lt;h3&gt;业务流程与预期不符&lt;/h3&gt;
&lt;p&gt;　　系统中结果与期望不符，应当记录日志。常见的合适场景包括外部参数不正确，数据处理问题导致返回码不在合理范围内等等。&lt;/p&gt;
&lt;h3&gt;系统核心的关键动作&lt;/h3&gt;
&lt;p&gt;　　系统中核心角色触发的业务动作是需要多加关注的，是衡量系统正常运行的重要指标，建议记录INFO级别日志，比如微服务各服务节点交互等。&lt;/p&gt;
&lt;h3&gt;捕获到异常时&lt;/h3&gt;
&lt;p&gt;　　这类捕获的异常是系统告知开发人员需要加以关注的，应当记录日志，根据实际情况使用warn或者error级别。&lt;/p&gt;
&lt;h3&gt;外部接口日志&lt;/h3&gt;
&lt;p&gt;　　这类日志涉及到与外部系统的交互，事关责任问题，建议将原始数据文件内容写入日志或数据库（如mongodb），核心处理逻辑关键业务数据也尽量写入日志。如果涉及到重发，建议将处理失败的原始数据文件日志写入数据库，以便重发执行。&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;使用@SLF4J中的API进行日志打印。&lt;/li&gt;
&lt;li&gt;日志输出必须采用UTF-8字符集，推荐打印日志时输出英文，防止中文不支持而打印出乱码的情况。&lt;/li&gt;
&lt;li&gt;不允许记录日志后又抛出异常，因为这样会多次记录日志，只允许记录一次日志，应抛出异常，顶层打印一次日志。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
try {
　　// 错误 
} catch (Exception e) { 
　　log.error(&quot;xxxxxx&quot;, e);
　　throw e；
}
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;输出Exceptions的全部堆栈信息，但是不能使用e.printStackTrace()&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
// 错误例子, 丢失掉StackTrace信息 
log.error(e.getMessage()); 
// 错误例子,丢失掉StackTrace信息 
log.error(“Bad things : {}“, e.getMessage()); 
// 正确例子 
log.error(“Bad things : {}“,e); 

// e.printStackTrace()的源码
public void printStackTrace() { 
    printStackTrace(System.err); 
}
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;禁止system.out 用于日志记录。&lt;/li&gt;
&lt;li&gt;线上必须关闭 DEBUG 级别日志。&lt;/li&gt;
&lt;li&gt;非正常的情况，需要根据情况选择打印warn 或 error 日志,不能使用错误的日志级别。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
try { 
// ... 
} catch (Exception e) { 
// 错误LOG.info(&quot;XX 发生异常...&quot;, e); 
}
// 用 info 记录 error 日志，日志输出到了 info 日志文件中了，同事拼命地在 error 错误日志文件里 面找怎么能找到呢？
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;日志输出，必须使用占位符的方式，因为即使信息不打印，也会执行字符串拼接，造成资源浪费。&lt;/li&gt;
&lt;li&gt;日志中不允许出现计算或方法调用，防止在打印日志的时候报错。&lt;/li&gt;
&lt;li&gt;输出的POJO类必须重写toString方法，否则只输出对象的hashCode值，没有参考意义。&lt;/li&gt;
&lt;li&gt;不记录对于排查故障毫无意义的日志信息，日志信息一定要带有业务信息。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
//错误 
log.error(“handle failed“); 
//正确
log.error(“handle failed，id= {}“, id); 
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;禁止大量无效重复的日志输出，通常情况下在程序日志只记录一些有意义的状态数据，参考日志记录时机。&lt;/li&gt;
&lt;li&gt;不可以讲敏感业务信息记录入日志文件。&lt;/li&gt;
&lt;li&gt;严防日志占满磁盘，定期检查磁盘（确定是否有磁盘告警）。&lt;/li&gt;
&lt;li&gt;不要在千层循环中打印日志&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
for(int i=0; i&amp;lt;2000; i++){
LOG.info(&quot;XX&quot;);
}
// 这个是什么意思，如果你的框架使用了性能不高的 Log4j 框架，那就不要在上千个 for 循环中打印日志，
// 这样可能会拖垮你的应用程序，如果你的程序响应时间变慢，那要考虑是不是日志打印的过多了。
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;配置说明&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;统一使用logback.xml配置，logback.xml 文件放在 classpath 目录下。&lt;/li&gt;
&lt;li&gt;所有的jar包中不建议包含logback.xml文件，避免干扰实际的业务系统。&lt;/li&gt;
&lt;li&gt;通过在文件logback.xml中引入资源文件log.properties定义logback属性信息，log.properties根据不同的profile放置在不同位置；&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;property resource=&quot;log.properties&quot;/&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;log.properties文件&lt;/li&gt;
&lt;li&gt;属性命名推荐使用统一使用大写，以下划线分隔，参考&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
APP_NAME = yourAppName
LOG_DIR = /export/home/logs/yourSystem/yourAppName
LOG_PATTERN = [%date{yyyy-MM-dd HH:mm:ss.SSS}] %level [%mdc{invokeNo}] %C{0}:%line - %message%n
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;注意Logger间的继承关系，推荐additivity设置false;&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;子logger会默认继承父logger的appender，将它们加入到自己的Appender中；除非加上了additivity=&quot;false&quot;，则不再继承父logger的appender。&lt;/li&gt;
&lt;li&gt;子logger只在自己未定义输出级别的情况下，才会继承父logger的输出级别。&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;将日志输出到文件当中，禁止使用FileAppender，推荐使用提供自动切换功能的RollingFileAppender Log文件位置和命名，目前Log文件的位置统一放在相同目录下面。&lt;/li&gt;
&lt;/ul&gt;&lt;table border=&quot;0&quot;&gt;&lt;caption&gt; &lt;/caption&gt;
&lt;tbody readability=&quot;4&quot;&gt;&lt;tr&gt;&lt;td&gt;文件名&lt;/td&gt;
&lt;td&gt;描述&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;/export/home/logs&lt;/td&gt;
&lt;td&gt;默认日志路径（所有日志的根路径）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;/export/home/logs/${SYSTEM_NAME}/${APP_NAME}&lt;/td&gt;
&lt;td&gt;log.properties中配置的日志全路径LOG_DIR&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;${LOG_DIR}/all.log&lt;/td&gt;
&lt;td&gt;必选&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;${LOG_DIR}/ all-%d{yyyy-MM-dd}.log&lt;/td&gt;
&lt;td&gt;All历史文件命名&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;${LOG_DIR}/all_error.log&lt;/td&gt;
&lt;td&gt;必选&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;${LOG_DIR}/sql.log&lt;/td&gt;
&lt;td&gt;可选&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;ul&gt;&lt;li&gt;日志按天记录，单个日志文件最大不超过2000MB，考虑到有些bug按月规律出现，推荐历史日志保留30天。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;rollingPolicy &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;fileNamePattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;${LOG_DIR}/all-%d{yyyy-MM-dd}.log&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;fileNamePattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;maxHistory&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;30&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;maxHistory&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;timeBasedFileNamingAndTriggeringPolicy &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;maxFileSize&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2000MB&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;maxFileSize&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;timeBasedFileNamingAndTriggeringPolicy&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;rollingPolicy&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;在出现问题之后，需要立即根据日志定位问题。对于INFO及以上级别的日志，要求按照一定顺序，输出以下必要的信息。参考日志格式定义&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;encoder &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;[%date{yyyy-MM-dd HH:mm:ss.SSS}] %level 
　　[%mdc{invokeNo}] %C{0}:%line - %message%n&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;encoder&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;一个完整的Appender配置如下&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;resource&lt;/span&gt;&lt;span&gt;=&quot;log.properties&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;    
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;contextName&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;${APP_NAME}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;contextName&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;    &lt;br/&gt;　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;appender &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;console&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;ch.qos.logback.core.ConsoleAppender&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;encoder &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　　　　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;${LOG_PATTERN}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　　　&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;encoder&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;appender&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;appender &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;all&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;${LOG_DIR}/all.log&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;rollingPolicy &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;fileNamePattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;${LOG_DIR}/all-%d{yyyy-MM-dd}.%i.log&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;fileNamePattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;maxHistory&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;30&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;maxHistory&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;timeBasedFileNamingAndTriggeringPolicy &lt;br/&gt;　　　　　　&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;    
　　　　　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;maxFileSize&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2000MB&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;maxFileSize&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 每个日志文件大小不超过2GB &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
　　　　&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;timeBasedFileNamingAndTriggeringPolicy&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;rollingPolicy&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;encoder &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;${LOG_PATTERN}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;encoder&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;level&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;info&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;level&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;appender&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;appender &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;all-error&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;${LOG_DIR}/all-error.log&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;level&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;ERROR&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;level&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;onMatch&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;ACCEPT&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;onMatch&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;onMismatch&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;DENY&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;onMismatch&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;rollingPolicy &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;fileNamePattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
　　　　　　${LOG_DIR}/all-error-%d{yyyy-MM-dd}.%i.log 
　　　　&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;fileNamePattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;maxHistory&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;30&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;maxHistory&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;timeBasedFileNamingAndTriggeringPolicy&lt;br/&gt;　　　　　  &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　　　　　&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 每个日志文件大小不超过2GB &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
　　　　　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;maxFileSize&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2000MB&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;maxFileSize&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　　　&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;timeBasedFileNamingAndTriggeringPolicy&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;rollingPolicy&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;encoder &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;br/&gt;　　　　　　&lt;/span&gt;&lt;span&gt;[%date{yyyy-MM-dd HH:mm:ss.SSS}] %level [%mdc{invokeNo}] %C{0}:%line - %message%n
　　　　&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;encoder&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;appender&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;br/&gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;root &lt;/span&gt;&lt;span&gt;level&lt;/span&gt;&lt;span&gt;=&quot;debug&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;appender-ref &lt;/span&gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;=&quot;all&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;appender-ref &lt;/span&gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;=&quot;all-error&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;appender-ref &lt;/span&gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;=&quot;console&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;配置说明&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;统一使用log4j2.xml配置，log4j2.xml 文件放在 resource目录下。&lt;/li&gt;
&lt;li&gt;注意Logger间的继承关系，推荐additivity设置false：&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;子logger会默认继承父logger的appender，将它们加入到自己的Appender中；除非加上了additivity=&quot;false&quot;，则不再继承父logger的appender。&lt;/li&gt;
&lt;li&gt;子logger只在自己未定义输出级别的情况下，才会继承父logger的输出级别。&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;将日志输出到文件当中，考虑到RollingRandomAccessFile比RollingFile更灵活，推荐统一使用RollingRandomAccessFile。&lt;/li&gt;
&lt;li&gt;Log文件位置和命名，目前Log文件的位置统一放在相同目录下面。&lt;/li&gt;
&lt;/ul&gt;&lt;table border=&quot;0&quot;&gt;&lt;caption&gt; &lt;/caption&gt;
&lt;tbody readability=&quot;4&quot;&gt;&lt;tr&gt;&lt;td&gt;文件名&lt;/td&gt;
&lt;td&gt;描述 &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;/export/home/logs`&lt;/td&gt;
&lt;td&gt;默认日志路径（所有日志的根路径）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;/export/home/logs/${SYSTEM_NAME}/${APP_NAME}&lt;/td&gt;
&lt;td&gt; log.properties中配置的日志全路径LOG_DIR&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;${LOG_DIR}/all.log&lt;/td&gt;
&lt;td&gt;必选 &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;${LOG_DIR}/ all-%d{yyyy-MM-dd}.log&lt;/td&gt;
&lt;td&gt;All历史文件命名&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;${LOG_DIR}/all_error.log&lt;/td&gt;
&lt;td&gt;必选&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;${LOG_DIR}/sql.log&lt;/td&gt;
&lt;td&gt;可选 &lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;ul&gt;&lt;li&gt;日志按天记录，单个日志文件最大不超过3000MB，考虑到有些bug按周规律出现，推荐历史日志保留14天。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;RollingRandomAccessFile &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;all-append&quot;&lt;/span&gt;&lt;span&gt; immediateFlush&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt; &lt;br/&gt;　　　　fileName&lt;/span&gt;&lt;span&gt;=&quot;${LOG_DIR}/all.log&quot;&lt;/span&gt;&lt;span&gt; filePattern&lt;/span&gt;&lt;span&gt;=&quot;${LOG_DIR}/all-%d{yyyy-MM-dd}-%i.log&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Policies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;SizeBasedTriggeringPolicy &lt;/span&gt;&lt;span&gt;size&lt;/span&gt;&lt;span&gt;=&quot;3GB&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TimeBasedTriggeringPolicy &lt;/span&gt;&lt;span&gt;interval&lt;/span&gt;&lt;span&gt;=&quot;8&quot;&lt;/span&gt;&lt;span&gt; modulate&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 最多备份14天以内||日志文件大小达到50GB的日志||文件数量超过20此处为策略限制，&lt;br/&gt;　　　　Delete中可以按自己需要用正则表达式编写 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;DefaultRolloverStrategy&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Delete &lt;/span&gt;&lt;span&gt;basePath&lt;/span&gt;&lt;span&gt;=&quot;${filePath}&quot;&lt;/span&gt;&lt;span&gt; maxDepth&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;IfLastModified &lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;=&quot;14d&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
　　　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;IfAccumulatedFileSize &lt;/span&gt;&lt;span&gt;exceeds&lt;/span&gt;&lt;span&gt;=&quot;50 GB&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
　　　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;IfAccumulatedFileCount &lt;/span&gt;&lt;span&gt;exceeds&lt;/span&gt;&lt;span&gt;=&quot;20&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Delete&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;DefaultRolloverStrategy&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;在出现问题之后，需要立即根据日志定位问题。对于INFO及以上级别的日志，要求按照一定顺序，输出以下必要的信息。参考日志格式定义&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;PatternLayout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%t] %-5level [%mdc{invokeNo}] %C{2}:%L %M - %msg%n
　　&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;PatternLayout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;一个完整的Appender配置如下&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; Configuration后面的status，这个用于设置log4j2自身内部的信息输出，可以不设置，当设置成trace时，&lt;br/&gt;　　你会看到log4j2内部各种详细输出。monitorInterval：Log4j能够自动检测修改配置文件和重新配置本身，&lt;br/&gt;　　设置间隔秒数。
&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;configuration &lt;/span&gt;&lt;span&gt;status&lt;/span&gt;&lt;span&gt;=&quot;OFF&quot;&lt;/span&gt;&lt;span&gt; monitorInterval&lt;/span&gt;&lt;span&gt;=”600″&amp;gt;
&lt;/span&gt;&lt;span&gt;&amp;lt;properties&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;LOG_PATH&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;/export/home/logs/yourSystem/yourAppName&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;LOG_PATTERN&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%t] %-5level [%mdc{invokeNo}]&lt;br/&gt;　　　　　　　　 %C{2}:%L %M - %msg%n &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;EVERY_FILE_SIZE&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;3GB&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;OUTPUT_LOG_LEVEL&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;info&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;FILE_COUNT&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;20&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;ERROR_FILE_COUNT&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;3&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;先定义所有的appender&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;appenders&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;br/&gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;输出控制台的配置&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Console &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;console&quot;&lt;/span&gt;&lt;span&gt; target&lt;/span&gt;&lt;span&gt;=&quot;SYSTEM_OUT&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　　　&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch）&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
　　　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ThresholdFilter &lt;/span&gt;&lt;span&gt;level&lt;/span&gt;&lt;span&gt;=&quot;info&quot;&lt;/span&gt;&lt;span&gt; onMatch&lt;/span&gt;&lt;span&gt;=&quot;ACCEPT&quot;&lt;/span&gt;&lt;span&gt; onMismatch&lt;/span&gt;&lt;span&gt;=&quot;DENY&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
　　　　&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;输出日志的格式&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
　　　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;PatternLayout &lt;/span&gt;&lt;span&gt;pattern&lt;/span&gt;&lt;span&gt;=&quot;${LOG_PATTERN}&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Console&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 打印信息，每次大小超过size，则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，&lt;br/&gt;　　作为存档&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;RollingRandomAccessFile 
　　&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;all&quot;&lt;/span&gt;&lt;span&gt;
　　immediateFlush&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt; 
　　fileName&lt;/span&gt;&lt;span&gt;=&quot;${LOG_DIR}/all.log&quot;&lt;/span&gt;&lt;span&gt;
　　filePattern&lt;/span&gt;&lt;span&gt;=&quot;${LOG_DIR}/all-%d{yyyy-MM-dd}-%i.log&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Filters&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ThresholdFilter &lt;/span&gt;&lt;span&gt;level&lt;/span&gt;&lt;span&gt;=&quot;error&quot; &lt;/span&gt;&lt;span&gt;onMatch&lt;/span&gt;&lt;span&gt;=&quot;ACCEPT&quot; &lt;/span&gt;&lt;span&gt;onMismatch&lt;/span&gt;&lt;span&gt;=&quot;NEUTRAL&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
　　　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ThresholdFilter &lt;/span&gt;&lt;span&gt;level&lt;/span&gt;&lt;span&gt;=&quot;warn&quot;&lt;/span&gt;&lt;span&gt; onMatch&lt;/span&gt;&lt;span&gt;=&quot;ACCEPT&quot;&lt;/span&gt;&lt;span&gt; onMismatch&lt;/span&gt;&lt;span&gt;=&quot;NEUTRAL&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
　　　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ThresholdFilter &lt;/span&gt;&lt;span&gt;level&lt;/span&gt;&lt;span&gt;=&quot;info&quot;&lt;/span&gt;&lt;span&gt; onMatch&lt;/span&gt;&lt;span&gt;=&quot;ACCEPT&quot;&lt;/span&gt;&lt;span&gt; onMismatch&lt;/span&gt;&lt;span&gt;=&quot;NEUTRAL&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
　　　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ThresholdFilter &lt;/span&gt;&lt;span&gt;level&lt;/span&gt;&lt;span&gt;=&quot;trace&quot; &lt;/span&gt;&lt;span&gt;onMatch&lt;/span&gt;&lt;span&gt;=&quot;DENY&quot;&lt;/span&gt;&lt;span&gt; onMismatch&lt;/span&gt;&lt;span&gt;=&quot;DENY&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Filters&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;PatternLayout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;${LOG_PATTERN}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;PatternLayout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Policies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;SizeBasedTriggeringPolicy &lt;/span&gt;&lt;span&gt;size&lt;/span&gt;&lt;span&gt;=&quot;${EVERY_FILE_SIZE}&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TimeBasedTriggeringPolicy &lt;/span&gt;&lt;span&gt;interval&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt; modulate&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Policies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; DefaultRolloverStrategy属性如不设置，则默认为最多同一文件夹下7个文件，这里设置了20 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt; 
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;DefaultRolloverStrategy&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 最多备14 天以内||日志文件大小达到50GB的日志||文件数量超过20此处为策略限制，Delete中可以按自&lt;br/&gt;　　　　　己需要用正则表达式编写 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Delete &lt;/span&gt;&lt;span&gt;basePath&lt;/span&gt;&lt;span&gt;=&quot;${LOG_DIR}&quot;&lt;/span&gt;&lt;span&gt; maxDepth&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;IfLastModified &lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;=&quot;14d&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
　　　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;IfAccumulatedFileSize &lt;/span&gt;&lt;span&gt;exceeds&lt;/span&gt;&lt;span&gt;=&quot;50 GB&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
　　　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;IfAccumulatedFileCount &lt;/span&gt;&lt;span&gt;exceeds&lt;/span&gt;&lt;span&gt;=&quot;20&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Delete&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;DefaultRolloverStrategy&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;RollingRandomAccessFile&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;RollingRandomAccessFile 
　　&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;all-error&quot;&lt;/span&gt;&lt;span&gt;
　　immediateFlush&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt; 
　　fileName&lt;/span&gt;&lt;span&gt;=&quot;${LOG_DIR}/all-error.log&quot;&lt;/span&gt;&lt;span&gt;
　　filePattern&lt;/span&gt;&lt;span&gt;=&quot;${LOG_DIR}/all-error-%d{yyyy-MM-dd}-%i.log&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Filters&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ThresholdFilter &lt;/span&gt;&lt;span&gt;level&lt;/span&gt;&lt;span&gt;=&quot;error&quot;&lt;/span&gt;&lt;span&gt; onMatch&lt;/span&gt;&lt;span&gt;=&quot;ACCEPT&quot;&lt;/span&gt;&lt;span&gt;onMismatch&lt;/span&gt;&lt;span&gt;=&quot;NEUTRAL&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;　　　　&amp;lt;&lt;/span&gt;&lt;span&gt;ThresholdFilter &lt;/span&gt;&lt;span&gt;level&lt;/span&gt;&lt;span&gt;=&quot;warn&quot;&lt;/span&gt;&lt;span&gt; onMatch&lt;/span&gt;&lt;span&gt;=&quot;ACCEPT&quot;&lt;/span&gt;&lt;span&gt;onMismatch&lt;/span&gt;&lt;span&gt;=&quot;DENY&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;　　&amp;lt;/&lt;/span&gt;&lt;span&gt;Filters&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;PatternLayout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;${LOG_PATTERN}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;PatternLayout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Policies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;SizeBasedTriggeringPolicy &lt;/span&gt;&lt;span&gt;size&lt;/span&gt;&lt;span&gt;=&quot;${EVERY_FILE_SIZE}&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
　　　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TimeBasedTriggeringPolicy &lt;/span&gt;&lt;span&gt;interval&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt; modulate&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Policies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; DefaultRolloverStrategy属性如不设置，则默认为最多同一文件夹下7个文件，这里设置了20 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;DefaultRolloverStrategy &lt;/span&gt;&lt;span&gt;max&lt;/span&gt;&lt;span&gt;=&quot;${ERROR_FILE_COUNT}&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;RollingRandomAccessFile&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;br/&gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;appenders&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;然后定义logger，只有定义了logger并引入的appender，appender才会生效&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;loggers&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;默认的root的logger&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Logger &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;all&quot;&lt;/span&gt;&lt;span&gt; level&lt;/span&gt;&lt;span&gt;=&quot;info&quot;&lt;/span&gt;&lt;span&gt; additivity&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
　　　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;AppenderRef &lt;/span&gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;=&quot;all&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt; 
　　&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Logger&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Logger &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;all-error&quot;&lt;/span&gt;&lt;span&gt; level&lt;/span&gt;&lt;span&gt;=&quot;error&quot;&lt;/span&gt;&lt;span&gt; additivity&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;span&gt;　　　　&amp;lt;&lt;/span&gt;&lt;span&gt;AppenderRef &lt;/span&gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;=&quot;all-error&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt; 
　　&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Logger&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;root &lt;/span&gt;&lt;span&gt;level&lt;/span&gt;&lt;span&gt;=&quot;${OUTPUT_LOG_LEVEL}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;appender-ref &lt;/span&gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;=&quot;console&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;loggers&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;br/&gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Sun, 17 Mar 2019 15:05:00 +0000</pubDate>
<dc:creator>五色花的</dc:creator>
<og:description>目录 1、什么是日志？ 简单的说，日志就是记录程序的运行轨迹，方便查找关键信息，也方便快速定位解决问题。我们 Java 程序员在开发项目时都是依赖 Eclipse/ Idea 等开发工具的 Debug</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/luao/p/10549610.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core 3.0预览版体验 - LineZero</title>
<link>http://www.cnblogs.com/linezero/p/aspnetcore3preview.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/linezero/p/aspnetcore3preview.html</guid>
<description>&lt;p&gt;目前.NET Core 3.0的版本为.NET Core 3.0 Preview 3，对应ASP.NET Core 3.0 Preview 3。&lt;/p&gt;
&lt;p&gt;ASP.NET Core 3.0 之后将不再支持.NET Framework，只运行在.NET Core 上面。&lt;/p&gt;
&lt;p&gt;ASP.NET Core 3.0 现在已经出到了第三个预览版，增加和改进了很多功能。&lt;/p&gt;

&lt;p&gt;环境准备：&lt;/p&gt;
&lt;p&gt;下载最新.NET Core 3.0 Preview 3 SDK, https://dotnet.microsoft.com/download/dotnet-core/3.0。&lt;/p&gt;
&lt;p&gt;ASP.NET Core 3.0 需要VS 2019开发，或者使用VS Code，Visual Studio for Mac version 8.0 or later。&lt;/p&gt;
&lt;p&gt;Visual Studio 2019 将会在4月2日推出正式版。&lt;/p&gt;

&lt;p&gt;下面大致列举一些功能：&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;Json.NET 不在内置在框架内&lt;/strong&gt;&lt;/h3&gt;
&lt;p class=&quot;x-hidden-focus&quot;&gt;&lt;span&gt;如果要将Json.NET支持添加回ASP.NET Core 3.0项目：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;services.AddMvc()
  .AddNewtonsoftJson();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;strong&gt;HostBuilder 替换掉WebHostBuilder&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            CreateHostBuilder(args).Build().Run();
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IHostBuilder CreateHostBuilder(&lt;span&gt;string&lt;/span&gt;[] args) =&amp;gt;&lt;span&gt;
            Host.CreateDefaultBuilder(args)
                .ConfigureWebHostDefaults(webBuilder &lt;/span&gt;=&amp;gt;&lt;span&gt;
                {
                    webBuilder.UseStartup&lt;/span&gt;&amp;lt;Startup&amp;gt;&lt;span&gt;();
                });
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;strong&gt;UseRouting 中间件的增加&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    app.UseRouting(routes =&amp;gt;&lt;span&gt;
    {
        routes.MapGet(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, context =&amp;gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; context.Response.WriteAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hi there! linezero&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        });
    });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同时还增加 MapHealthChecks及RequireHost 等功能，看示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
app.UseRouting(routes =&amp;gt;&lt;span&gt;
{
    routes.MapGet(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, context =&amp;gt; context.Response.WriteAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hi linezero!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
        .RequireHost(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;linezero.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);    
    routes.MapGet(context &lt;/span&gt;=&amp;gt; context.Response.WriteAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hi zero!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
        .RequireHost(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zero.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    routes.MapHealthChecks(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/healthz&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).RequireHost(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*:8080&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Razor Components &lt;/h3&gt;
&lt;p&gt;razor 组件支持，下面实际看看这个功能点。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
dotnet &lt;span&gt;new&lt;/span&gt; razorcomponents -&lt;span&gt;o myweb

cd myweb

dotnet run&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行起来如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/443844/201903/443844-20190317221950626-1716579194.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对应组件代码Counter.razor ：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
@page &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/counter&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&amp;lt;h1&amp;gt;Counter&amp;lt;/h1&amp;gt;
&amp;lt;p&amp;gt;LineZero&amp;lt;/p&amp;gt;

&amp;lt;p&amp;gt;Current count: @currentCount&amp;lt;/p&amp;gt;

&amp;lt;button &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;btn btn-primary&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; onclick=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;@IncrementCount&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;Click me&amp;lt;/button&amp;gt;&lt;span&gt;

@functions {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; currentCount = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; IncrementCount()
    {
        currentCount&lt;/span&gt;++&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 你可以直接将组件添加到主页或其他页面，例如放到主页Index.razor：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
@page &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&amp;lt;h1&amp;gt;Hello, world!&amp;lt;/h1&amp;gt;&lt;span&gt;

Welcome to your &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; app.LineZero

&lt;/span&gt;&amp;lt;Counter /&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/443844/201903/443844-20190317222518329-1220185933.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 还可以使用 [Parameter] int IncrementSize { get; set; } = 1; 来设置参数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@functions {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; currentCount = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

    [Parameter] &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; IncrementSize { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; } = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; IncrementCount()
    {
        currentCount&lt;/span&gt;+=&lt;span&gt;IncrementSize;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样可以做到每个页面设置不同的大小，增加不同数量。&lt;/p&gt;
&lt;p&gt;如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
@page &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&amp;lt;h1&amp;gt;Hello, world!&amp;lt;/h1&amp;gt;&lt;span&gt;

Welcome to your &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; app.LineZero

&lt;/span&gt;&lt;strong&gt;&amp;lt;Counter IncrementSize=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;&lt;/strong&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;下图描述了Razor的一些原理。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code class=&quot;lang-csharp&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pun&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/443844/201903/443844-20190317222655521-1906343.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;另外，Blazor是一个实验性单页面应用程序框架，它使用基于WebAssembly的.NET运行时直接在浏览器中运行Razor Components。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;在Blazor应用程序中，Razor组件的UI更新都直接应用于DOM&lt;/span&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/443844/201903/443844-20190317223333108-2065452906.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;运行时编译&lt;/strong&gt;&lt;/h3&gt;
&lt;p class=&quot;x-hidden-focus&quot;&gt;&lt;span&gt;从.NET Core 3.0中的ASP.NET Core共享框架中删除了对运行时编译的支持，现在可以通过向应用程序添加软件包来启用它。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;要启用运行时编译：&lt;/span&gt;&lt;/p&gt;
&lt;ol readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;span&gt;添加对Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation的包引用&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;prettyprint prettyprinted&quot;&gt;
&lt;code class=&quot;xml&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;PackageReference&lt;span class=&quot;pln&quot;&gt; &lt;span class=&quot;atn&quot;&gt;Include&lt;span class=&quot;pun&quot;&gt;=&lt;span class=&quot;atv&quot;&gt;&quot;Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation&quot;&lt;span class=&quot;pln&quot;&gt; &lt;span class=&quot;atn&quot;&gt;Version&lt;span class=&quot;pun&quot;&gt;=&lt;span class=&quot;atv&quot;&gt;&quot;3.0.0-preview3-19153-02&quot;&lt;span class=&quot;pln&quot;&gt; &lt;span class=&quot;tag&quot;&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;在&lt;/span&gt;&lt;code&gt;Startup.ConfigureServices&lt;/code&gt;&lt;span&gt;加入方法&lt;/span&gt;&lt;code class=&quot;x-hidden-focus&quot;&gt;AddRazorRuntimeCompilation&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;prettyprint prettyprinted&quot;&gt;
&lt;code class=&quot;csharp&quot;&gt;&lt;span class=&quot;pln&quot;&gt;services&lt;span class=&quot;pun&quot;&gt;.&lt;span class=&quot;typ&quot;&gt;AddMvc&lt;span class=&quot;pun&quot;&gt;().&lt;span class=&quot;typ&quot;&gt;AddRazorRuntimeCompilation&lt;span class=&quot;pun&quot;&gt;();&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;&lt;strong&gt;Worker Service模板&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;此模板旨在作为运行长时间运行的后台进程的起点，例如您可以作为Windows服务或Linux守护程序运行。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;单页面应用程序模板的身份验证&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;由IdentityServer在后台提供支持&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
dotnet &lt;span&gt;new&lt;/span&gt; angular -au Individual&lt;p&gt;dotnet run
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最终运行起来，可以进行登录注册，及对API 的保护。&lt;/p&gt;
&lt;p&gt;更多可以查看官方文档：https://docs.microsoft.com/en-us/aspnet/core/security/authentication/identity-api-authorization?view=aspnetcore-3.0&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;gRPC服务模板&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
dotnet &lt;span&gt;new&lt;/span&gt; grpc
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;会生成两个项目，一个在ASP.NET Core中托管的gRPC服务，以及一个用它来测试它的控制台应用程序。&lt;/p&gt;
&lt;p&gt;这是gRPC for ASP.NET Core的第一次公开预览，并没有实现gRPC的所有功能。对应开源项目： https://github.com/grpc/grpc-dotnet&lt;/p&gt;
&lt;p&gt;gRPC 简单介绍可以参照之前文章：http://www.cnblogs.com/linezero/p/grpc.html  及 https://www.cnblogs.com/linezero/p/grpcnetcore.html&lt;/p&gt;
</description>
<pubDate>Sun, 17 Mar 2019 14:55:00 +0000</pubDate>
<dc:creator>LineZero</dc:creator>
<og:description>目前.NET Core 3.0的版本为.NET Core 3.0 Preview 3，对应ASP.NET Core 3.0 Preview 3。 ASP.NET Core 3.0 之后将不再支持.NE</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/linezero/p/aspnetcore3preview.html</dc:identifier>
</item>
<item>
<title>F#周报2019年第11期 - Ken.W</title>
<link>http://www.cnblogs.com/kenwoo/p/10549535.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kenwoo/p/10549535.html</guid>
<description>[unable to retrieve full-text content]新闻 &quot;Bolero：WebAssembly中的F &quot; &quot;尝试WebAssembly里的F &quot; &quot;JetBrains的fsharp support 2019.1&quot; &quot;ML.NET 0.11发布&quot; &quot;Outreachy内2019年5月至2019年八月的实习&quot; &quot;C 8.X引入Record&quot; &quot;基准游戏</description>
<pubDate>Sun, 17 Mar 2019 14:50:00 +0000</pubDate>
<dc:creator>Ken.W</dc:creator>
<og:description>新闻 'Bolero：WebAssembly中的F ' '尝试WebAssembly里的F ' 'JetBrains的fsharp support 2019.1' 'ML.NET 0.11发布' 'O</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kenwoo/p/10549535.html</dc:identifier>
</item>
<item>
<title>二项式定理学习笔记（详解） - Judge_Cheung</title>
<link>http://www.cnblogs.com/Judge/p/10549495.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Judge/p/10549495.html</guid>
<description>&lt;p&gt;二项式定理好难啊...学了好久 &lt;span class=&quot;math inline&quot;&gt;\(QWQ\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这篇博客写的有点杂，主要讲证明，仅供娱乐？&lt;/p&gt;

&lt;h3 id=&quot;首先我们看看这个常见的令人头疼的式子&quot;&gt;首先我们看看这个常见的令人头疼的式子：&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[(x+1)^n=\sum_{i=0}^{n} C(n,i) ~ x^i\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这个式子为什么是对的呢？&lt;/p&gt;
&lt;p&gt;我们考虑将左边的式子写成完全形式：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[(x+1)(x+1)···(x+1)\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;那么我们发现其实可以每次从这 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 个 &lt;span class=&quot;math inline&quot;&gt;\((x+1)\)&lt;/span&gt; 中选出一个 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt; 或者一个 &lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt; ，然后将 n 个选出来的数字相乘累加进 &lt;span class=&quot;math inline&quot;&gt;\(ANS\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;那么我们考虑从 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 个 &lt;span class=&quot;math display&quot;&gt;\[(x+1)\]&lt;/span&gt; 中选出 &lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; 个 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt; 的情况有多少种呢&lt;/p&gt;
&lt;p&gt;这其实就是&lt;strong&gt;组合数&lt;/strong&gt;中的 &lt;span class=&quot;math inline&quot;&gt;\(C(n,i)\)&lt;/span&gt;，于是乎我们发现原来的式子是正确的&lt;/p&gt;
&lt;h3 id=&quot;然后讲讲二项式定理的一个应用&quot;&gt;然后讲讲二项式定理的一个应用：&lt;/h3&gt;
&lt;p&gt;我们考虑从 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 个物品中选出选出 &lt;span class=&quot;math inline&quot;&gt;\(t\)&lt;/span&gt; 个物品，那么有多少种选择的方案呢？&lt;/p&gt;
&lt;p&gt;既然是二项式定理的应用，那么怎么才能将二项式定理套进去呢？&lt;/p&gt;
&lt;p&gt;先别多想，我们考虑用 &lt;span class=&quot;math inline&quot;&gt;\((x^0+x^1)\)&lt;/span&gt; 表示某样物品选或者不选（这里 &lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt; 次项就是不选，而 &lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt; 次项则是选），这两者&lt;strong&gt;相互独立&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那么我们可以根据所有物品&lt;strong&gt;两两独立&lt;/strong&gt;将它们的选择方案乘起来，就是 &lt;span class=&quot;math inline&quot;&gt;\((x^0+x^1)^n\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;考虑为什么可以这么乘？不用想那么多感性理解即可，不理解的话看到下面也能懂的&lt;/p&gt;
&lt;p&gt;那么我们考虑一下之前的问题：选出 &lt;span class=&quot;math inline&quot;&gt;\(t\)&lt;/span&gt; 个物品&lt;/p&gt;
&lt;p&gt;那么这里我们将 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 个 &lt;span class=&quot;math inline&quot;&gt;\((x^0+x^1)\)&lt;/span&gt; 相乘之后 &lt;span class=&quot;math inline&quot;&gt;\(x^t\)&lt;/span&gt; 的系数其实就是方案数了，因为在这里 &lt;span class=&quot;math inline&quot;&gt;\(x^t\)&lt;/span&gt; 只可能来自 &lt;span class=&quot;math inline&quot;&gt;\(t\)&lt;/span&gt; 个不同的 &lt;span class=&quot;math inline&quot;&gt;\((x^0+x^1)\)&lt;/span&gt;中的 &lt;span class=&quot;math inline&quot;&gt;\(x^1\)&lt;/span&gt;， 也就是说它的含义就是我们在 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 个&lt;span class=&quot;math inline&quot;&gt;\((x^0+x^1)\)&lt;/span&gt;中选择 &lt;span class=&quot;math inline&quot;&gt;\(t\)&lt;/span&gt; 个 &lt;span class=&quot;math inline&quot;&gt;\(x^1\)&lt;/span&gt; 然后每次选出一种方案就令 &lt;span class=&quot;math inline&quot;&gt;\(x^t\)&lt;/span&gt; 前的系数加一&lt;/p&gt;
&lt;p&gt;然后我们把 &lt;span class=&quot;math inline&quot;&gt;\(x^0\)&lt;/span&gt; 等价成 &lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt;，也就是二项式定理的常见形式了&lt;/p&gt;
&lt;h2 id=&quot;小插曲&quot;&gt;小插曲&lt;/h2&gt;
&lt;p&gt;我们定义组合数 &lt;span class=&quot;math inline&quot;&gt;\(C(n,m)\)&lt;/span&gt; 为 &lt;span class=&quot;math inline&quot;&gt;\(\frac{n(n-1)(n-2)···(n-m+1)}{m!}\)&lt;/span&gt; ，这样定义对于下面的证明更有帮助&lt;/p&gt;
&lt;p&gt;然后我们再考虑将原式的 求和函数的 终止条件换一下：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[(x+1)^n=\sum_{i=0}^{\infty} C(n,i) x^i \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这时候我们可以知道这个式子和之前是等价的，因为 &lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; 大于 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 的时候 &lt;span class=&quot;math inline&quot;&gt;\(C(n,i)\)&lt;/span&gt; 是等于 &lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt; 的&lt;/p&gt;
&lt;p&gt;至于为什么要这样表示看到下面你就知道了&lt;/p&gt;

&lt;p&gt;然后我们考虑一下 &lt;span class=&quot;math inline&quot;&gt;\((x+1)\)&lt;/span&gt; 的指数推广到 &lt;strong&gt;负数&lt;/strong&gt; 的情况&lt;/p&gt;
&lt;p&gt;这个时候其实也有：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[(x+1)^{-n}=\sum_{i=0}^{\infty} C(-n,i) ~ x^i=\sum_{i=0}^{\infty} (-1)^i~C(n+i-1,i)~x^i\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这时候你可能会非常的惊讶... 组合数还能有负的？！&lt;/p&gt;
&lt;p&gt;遗憾的告诉你（什么鬼），组合数可以有负的，因为这里的组合数使按之前小插曲里面的定义来的&lt;/p&gt;
&lt;p&gt;那么我们考虑怎样转移到最右边的式子：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[C(-n,m)=\frac{(-n)(-n-1)(-n-2)···(-n-m+1)}{m!}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;然后我们吧上面的式子里面所有项取反，也就是将他们的符号提取出来，就成了：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[C(-n,m)=(-1)^{(-n)-(-n-m+1)+1}\frac{n(n+1)(n+2)···(n+m-1)}{m!}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ = (-1)^{m}\frac{n(n+1)(n+2)···(n+m-1)}{m!}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ = (-1)^{m} C(n+m-1,m)\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;就是这样（或许你已经看到过上面的式子了）&lt;/p&gt;
&lt;p&gt;把上面的式子再写一遍就是： &lt;span class=&quot;math inline&quot;&gt;\((x+1)^{-n}=\sum_{i=0}^{\infty}(-1)^i C_{n+i-1}^i~x^i\)&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;（在这里我们略去 n 为负数的情况）&lt;/p&gt;
&lt;p&gt;首先的话，我们考虑将上面式子中的 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt; 取负，那么原式就变成了：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[(-x+1)^n=\sum_{i=0}^{\infty} (-1)^i~ C(n,i)~x^i\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这样写不好看，换种写法&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[(1-x)^n=\sum_{i=0}^{\infty} (-1)^i~ C(n,i)~x^i\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这个式子...（相信大家可能看到过的吧）&lt;/p&gt;
&lt;p&gt;这里的话后面的式子其实就是把 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt; 的负号提了出来，没什么特别的&lt;/p&gt;
&lt;p&gt;但是你有没有感觉这个式子有点眼熟？&lt;/p&gt;
&lt;p&gt;没错啊，这和 &lt;em&gt;指数为负的二项式定理&lt;/em&gt; 中长得有点像的，组合数前面都带着个正负号&lt;/p&gt;
&lt;p&gt;于是我们考虑一下吧这里的 n 也取负呢？&lt;/p&gt;
&lt;p&gt;那么原式就变成了：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[(1-x)^{-n} =\sum_{i=0}^{\infty} C(n+i-1,i)~x^i\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;也就是说两个正负号抵消掉了...&lt;span class=&quot;math inline&quot;&gt;\(QWQ\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这个式子其实是非常有用的，它会在你学生成函数的时候派上大用场&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（至于生成函数嘛，登博主学完之后还有时间的话可能就会写篇博客介绍一下）&lt;/p&gt;

&lt;p&gt;其实上面讲了这么多都是二项式定理的特殊形式（但其实都是比较常见+实用的）&lt;/p&gt;
&lt;p&gt;于是下面说说它的一般形式：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[(x+y)^n=\sum_{i=0}^{n} C(n,i) a^i·b^{n-i}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这个东西可以理解为有 n 堆物品，每堆里面有 x 和 y ，每堆只能选一个，要求选择的所有方案之和&lt;/p&gt;
&lt;p&gt;具体证明就毋须多言了，上面已经证了一大堆了&lt;/p&gt;

&lt;p&gt;其实广义二项式定理就是上面的那个式子，我们只要将指数 n 的定义域改成实数就好了&lt;/p&gt;
&lt;p&gt;也就是说，广义二项式定理对于实数也成立，也就是：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[(x+y)^α=\sum_{i=0}^{α} C(α,i) a^i·b^{α-i}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;而关于 &lt;span class=&quot;math inline&quot;&gt;\(C(α,i)\)&lt;/span&gt; 的值通过小插曲中组合数的定义代就好了&lt;/p&gt;

&lt;p&gt;我们看到上面的二项式定理中都出现了组合数，那么他们两者之间有什么内在联系呢？或者说我们可以通过二项式定理得出组合数的一些性质么？&lt;/p&gt;
&lt;p&gt;答案当然是肯定的啦！&lt;/p&gt;
&lt;h3 id=&quot;第一种情况&quot;&gt;第一种情况&lt;/h3&gt;
&lt;p&gt;我们考虑吧二项式定理的公式中的 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;\(y\)&lt;/span&gt; 都变成 &lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt;，那么我们会发现下面这个式子：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[(1+1)^n=\sum_{i=0}^{n} C_{n}^{i}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这能说明什么呢？很明显啊！&lt;/p&gt;
&lt;p&gt;我们考虑前面其实就是 2 的 n 次幂，后面就是 n 个物品里面选出 1~n 个的方案数之和，那么由二项式定理可以得知他们两者是相等的&lt;/p&gt;
&lt;p&gt;从另一个角度出发， n 个物品里面任意选择的方案数等于 &lt;span class=&quot;math inline&quot;&gt;\(\sum_{i=0}^nC_{n}^i\)&lt;/span&gt;，同时也等于 &lt;span class=&quot;math inline&quot;&gt;\(2^n\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;前面的式子不需要多解释，考虑后面的式子就是每个物品有选或者不选两个选择，那么总方案数等于&lt;strong&gt;所有物品选择的方案数&lt;/strong&gt;的乘积，这样一来两者的相等关系也就非常明显了&lt;/p&gt;
&lt;p&gt;那么我们再考虑一下杨辉三角，杨辉三角的第 i 行 第 j 列对应着 &lt;span class=&quot;math inline&quot;&gt;\(C_i^j\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;上面的相等关系也就说明了杨辉三角的第 i 行所有数之和等于 &lt;span class=&quot;math inline&quot;&gt;\(2^i\)&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;第二种情况&quot;&gt;第二种情况&lt;/h3&gt;
&lt;p&gt;我们再考虑把 x 变成 1， y 变成 0，这两者会产生什么样的反应呢？我们看下面的式子：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[(1-1)^n=\sum_{i=0}^{n} (-1)^i~C_{n}^{i}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（注意，不要认为等式左边恒等于 0 ！ 我们默认 &lt;span class=&quot;math inline&quot;&gt;\(x^0\)&lt;/span&gt; 为 1 ，对于任意实数！ 同时这里也可以倒过来证明 0 的 0 次幂为 1，算是吧？）&lt;/p&gt;
&lt;p&gt;那么我们发现除去 &lt;span class=&quot;math inline&quot;&gt;\(n = 0\)&lt;/span&gt; 的情况，&lt;strong&gt;&lt;span class=&quot;math inline&quot;&gt;\(C_n^i\)&lt;/span&gt; 的偶数项之和&lt;/strong&gt; 减去 &lt;strong&gt;&lt;span class=&quot;math inline&quot;&gt;\(C_n^i\)&lt;/span&gt; 的奇数项之和&lt;/strong&gt; 等于 0 ！&lt;/p&gt;
&lt;p&gt;换句话说， &lt;strong&gt;&lt;span class=&quot;math inline&quot;&gt;\(C_n^i\)&lt;/span&gt; 的偶数项之和&lt;/strong&gt; 等于 &lt;strong&gt;&lt;span class=&quot;math inline&quot;&gt;\(C_n^i\)&lt;/span&gt; 的奇数项之和&lt;/strong&gt; ！&lt;/p&gt;
&lt;p&gt;这里不知道如何解释了，只能说对于 n 为奇数的情况考虑组合数的对称性（即 &lt;span class=&quot;math inline&quot;&gt;\(C_n^i=C_n^{n-i}\)&lt;/span&gt;）&lt;/p&gt;
&lt;p&gt;然后对于 n 为偶数的情况考虑 掐头去尾，每个偶数项都对应上一行的两个相邻元素之和，不相交并且取遍了上一行的所有元素，而奇数项同理，于是两者相等&lt;/p&gt;
&lt;p&gt;那么这里上一张图你肯定就懂了(自己感受一下)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/Judge/1391474/o_%e4%ba%8c%e9%a1%b9%e5%bc%8f%e5%ae%9a%e7%90%86.png&quot; alt=&quot;二项式定理-杨辉三角&quot;/&gt;&lt;/p&gt;
&lt;p&gt;考虑一下杨辉三角，也就是说杨辉三角每一行的 &lt;strong&gt;偶数列对应的项之和&lt;/strong&gt; 等于 &lt;strong&gt;奇数列对应的项之和&lt;/strong&gt; (由上图也可以看出来)&lt;/p&gt;
&lt;p&gt;但是别忘了考虑特殊情况，我们刚刚说过 &lt;span class=&quot;math inline&quot;&gt;\(n=0\)&lt;/span&gt; 除外&lt;/p&gt;
&lt;p&gt;但其实考虑 n=0 的情况也简单，就是当 &lt;span class=&quot;math inline&quot;&gt;\(n=0\)&lt;/span&gt; 时组合数只有一项且为 1 ，然后我们把原来的式子倒过来表达：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\sum_{i=0}^{n} (-1)^i~C_{n}^{i}=[n==0]=\epsilon(n)\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其实 &lt;span class=&quot;math inline&quot;&gt;\(\epsilon\)&lt;/span&gt; 就是单位元函数&lt;/p&gt;

&lt;p&gt;二项式定理很有趣，但是看着上面的内容貌似没什么用，但等你学到深处就会发现经常会看到它的身影，到那时别忘了再翻开这篇博客，或许你会有新的收获~&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Bye~Bye~&lt;/code&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 17 Mar 2019 14:45:00 +0000</pubDate>
<dc:creator>Judge_Cheung</dc:creator>
<og:description>二项式定理好难啊...学了好久 $QWQ$ 这篇博客写的有点杂，主要讲证明，仅供娱乐？ 二项式定理的常见形式 首先我们看看这个常见的令人头疼的式子： $$(x+1)^n=\sum_{i=0}^{n}</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Judge/p/10549495.html</dc:identifier>
</item>
<item>
<title>ConsurrentDictionary并发字典知多少? - 码农阿宇</title>
<link>http://www.cnblogs.com/CoderAyu/p/10549409.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CoderAyu/p/10549409.html</guid>
<description>&lt;p&gt;在上一篇文章&lt;a href=&quot;https://www.cnblogs.com/CoderAyu/p/10360608.html&quot;&gt;你真的了解字典吗?&lt;/a&gt;一文中我介绍了Hash Function和字典的工作的基本原理.&lt;br/&gt;有网友在文章底部评论,说我的Remove和Add方法没有考虑线程安全问题.&lt;br/&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.dictionary-2?redirectedfrom=MSDN&amp;amp;view=netframework-4.7.2&quot; class=&quot;uri&quot;&gt;https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.dictionary-2?redirectedfrom=MSDN&amp;amp;view=netframework-4.7.2&lt;/a&gt;&lt;br/&gt;查阅相关资料后,发现字典.net中Dictionary本身时不支持线程安全的,如果要想使用支持线程安全的字典,那么我们就要使用ConcurrentDictionary了.&lt;br/&gt;在研究ConcurrentDictionary的源码后,我觉得在ConcurrentDictionary的线程安全的解决思路很有意思,其对线程安全的处理对对我们项目中的其他高并发场景也有一定的参考价值,在这里再次分享我的一些学习心得和体会,希望对大家有所帮助.&lt;/p&gt;

&lt;p&gt;ConcurrentDictionary是Dictionary的线程安全版本,位于System.Collections.Concurrent的命名空间下,该命名空间下除了有ConcurrentDictionary,还有以下Class都是我们常用的那些类库的线程安全版本.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.concurrent.blockingcollection-1?view=netframework-4.7.2&quot;&gt;BlockingCollection&lt;/a&gt;:为实现 &lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.concurrent.iproducerconsumercollection-1?view=netframework-4.7.2&quot;&gt;IProducerConsumerCollection&lt;/a&gt; 的线程安全集合提供阻塞和限制功能。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.concurrent.concurrentbag-1?view=netframework-4.7.2&quot;&gt;ConcurrentBag&lt;/a&gt;:表示对象的线程安全的无序集合.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.concurrent.concurrentqueue-1?view=netframework-4.7.2&quot;&gt;ConcurrentQueue&lt;/a&gt;:表示线程安全的先进先出 (FIFO) 集合。&lt;/p&gt;
&lt;p&gt;如果读过我上一篇文章&lt;a href=&quot;https://www.cnblogs.com/CoderAyu/p/10360608.html&quot;&gt;你真的了解字典吗?&lt;/a&gt;的小伙伴,对这个&lt;code&gt;ConcurrentDictionary&lt;/code&gt;的工作原理应该也不难理解,它是简简单单地在读写方法加个&lt;code&gt;lock&lt;/code&gt;吗?&lt;/p&gt;

&lt;h2 id=&quot;dictionary&quot;&gt;Dictionary&lt;/h2&gt;
&lt;p&gt;如下图所示,在字典中,数组entries用来存储数据,buckets作为桥梁,每次通过hash function获取了key的哈希值后,对这个哈希值进行取余,即&lt;code&gt;hashResult%bucketsLength=bucketIndex&lt;/code&gt;,余数作为buckets的index,而buckets的value就是这个key对应的entry所在entries中的索引,所以最终我们就可以通过这个索引在entries中拿到我们想要的数据,整个过程不需要对所有数据进行遍历,的时间复杂度为1.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/liuzhenyulive/DictionaryMini/master/Pic/hashtable1.svg?sanitize=true&quot; alt=&quot;Alt text&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;concurrentdictionary&quot;&gt;ConcurrentDictionary&lt;/h2&gt;
&lt;p&gt;ConcurrentDictionary的数据存储类似,只是buckets有个更多的职责,它除了有dictionary中的buckets的桥梁的作用外,负责了数据存储.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/liuzhenyulive/DictionaryMini/master/Pic/ConsurrentDictionary.png?sanitize=true&quot; alt=&quot;Alt text&quot;/&gt;&lt;/p&gt;
&lt;p&gt;key的哈希值与buckets的length取余后&lt;code&gt;hashResult%bucketsLength=bucketIndex&lt;/code&gt;,余数作为buckets的索引就能找到我们要的数据所存储的块,当出现两个key指向同一个块时,即上图中的John Smith和Sandra Dee他同时指向152怎么办呢?存储节点Node具有Next属性执行下个Node,上图中,node 152的Next为154,即我们从152开始找Sandra Dee,发现不是我们想要的,再到154找,即可取到所需数据.&lt;/p&gt;
&lt;p&gt;由于官方原版的源码较为复杂,理解起来有所难度,我对官方源码做了一些精简,下文将围绕这个精简版的ConcurrentDictionary展开叙述.&lt;br/&gt;&lt;a href=&quot;https://github.com/liuzhenyulive/DictionaryMini&quot; class=&quot;uri&quot;&gt;https://github.com/liuzhenyulive/DictionaryMini&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;数据结构&quot;&gt;数据结构&lt;/h2&gt;
&lt;h3 id=&quot;node&quot;&gt;Node&lt;/h3&gt;
&lt;p&gt;ConcurrentDictionary中的每个数据存储在一个Node中,它除了存储value信息,还存储key信息,以及key对应的hashcode&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;private class Node
        {
            internal TKey m_key;   //数据的key
            internal TValue m_value;  //数据值
            internal volatile Node m_next;  //当前Node的下级节点
            internal int m_hashcode;  //key的hashcode

            //构造函数
            internal Node(TKey key, TValue value, int hashcode, Node next)
            {
                m_key = key;
                m_value = value;
                m_next = next;
                m_hashcode = hashcode;
            }
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;table&quot;&gt;Table&lt;/h3&gt;
&lt;p&gt;而整个ConcurrentDictionary的数据存储在这样的一个Table中,其中m_buckets的Index负责映射key,m_locks是线程锁,下文中会有详细介绍,m_countPerLock存储每个lock锁负责的node数量.&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;
 private class Tables
        {
            internal readonly Node[] m_buckets;   //上文中提到的buckets
            internal readonly object[] m_locks;   //线程锁
            internal volatile int[] m_countPerLock;  //索格锁所管理的数据数量
            internal readonly IEqualityComparer&amp;lt;TKey&amp;gt; m_comparer;  //当前key对应的type的比较器

            //构造函数
            internal Tables(Node[] buckets, object[] locks, int[] countPerlock, IEqualityComparer&amp;lt;TKey&amp;gt; comparer)
            {
                m_buckets = buckets;
                m_locks = locks;
                m_countPerLock = countPerlock;
                m_comparer = comparer;
            }
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ConcurrentDictionary会在构造函数中创建Table,这里我对原有的构造函数进行了简化,通过默认值进行创建,其中DefaultConcurrencyLevel默认并发级别为当前计算机处理器的线程数.&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;        //构造函数
        public ConcurrentDictionaryMini() : this(DefaultConcurrencyLevel, DEFAULT_CAPACITY, true,
            EqualityComparer&amp;lt;TKey&amp;gt;.Default)
        {
        }

        /// &amp;lt;summary&amp;gt;
        ///
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;concurrencyLevel&quot;&amp;gt;并发等级,默认为CPU的线程数&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;capacity&quot;&amp;gt;默认容量,31,超过31后会自动扩容&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;growLockArray&quot;&amp;gt;时否动态扩充锁的数量&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;comparer&quot;&amp;gt;key的比较器&amp;lt;/param&amp;gt;
        internal ConcurrentDictionaryMini(int concurrencyLevel, int capacity, bool growLockArray, IEqualityComparer&amp;lt;TKey&amp;gt; comparer)
        {
            if (concurrencyLevel &amp;lt; 1)
            {
                throw new Exception(&quot;concurrencyLevel 必须为正数&quot;);
            }

            if (capacity &amp;lt; 0)
            {
                throw new Exception(&quot;capacity 不能为负数.&quot;);
            }

            if (capacity &amp;lt; concurrencyLevel)
            {
                capacity = concurrencyLevel;
            }

            object[] locks = new object[concurrencyLevel];
            for (int i = 0; i &amp;lt; locks.Length; i++)
            {
                locks[i] = new object();
            }

            int[] countPerLock = new int[locks.Length];
            Node[] buckets = new Node[capacity];
            m_tables = new Tables(buckets, locks, countPerLock, comparer);

            m_growLockArray = growLockArray;
            m_budget = buckets.Length / locks.Length;
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;方法&quot;&gt;方法&lt;/h2&gt;
&lt;p&gt;ConcurrentDictionary中较为基础重点的方法分别位Add,Get,Remove,Grow Table方法,其他方法基本上是建立在这四个方法的基础上进行的扩充.&lt;/p&gt;
&lt;h3 id=&quot;add&quot;&gt;Add&lt;/h3&gt;
&lt;p&gt;向Table中添加元素有以下亮点值得我们关注.&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;开始操作前会声明一个tables变量来存储操作开始前的m_tables,在正式开始操作后(进入lock)的时候,会检查tables在准备工作阶段是否别的线程改变,如果改变了,则重新开始准备工作并从新开始.&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;通过GetBucketAndLockNo方法获取bucket索引以及lock索引,其内部就是取余操作.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt; private void GetBucketAndLockNo(
            int hashcode, out int bucketNo, out int lockNo, int bucketCount, int lockCount)
        {
            //0x7FFFFFFF 是long int的最大值 与它按位与数据小于等于这个最大值
            bucketNo = (hashcode &amp;amp; 0x7fffffff) % bucketCount;
            lockNo = bucketNo % lockCount;
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;对数据进行操作前会从m_locks取出第lockNo个对象最为lock,操作完成后释放该lock.多个lock一定程度上减少了阻塞的可能性.&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;在对数据进行更新时,如果该Value的Type为允许原子性写入的,则直接更新该Value,否则创建一个新的node进行覆盖.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;        /// &amp;lt;summary&amp;gt;
        /// Determines whether type TValue can be written atomically
        /// &amp;lt;/summary&amp;gt;
        private static bool IsValueWriteAtomic()
        {
            Type valueType = typeof(TValue);

            //
            // Section 12.6.6 of ECMA CLI explains which types can be read and written atomically without
            // the risk of tearing.
            //
            // See http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-335.pdf
            //
            if (valueType.IsClass)
            {
                return true;
            }
            switch (Type.GetTypeCode(valueType))
            {
                case TypeCode.Boolean:
                case TypeCode.Byte:
                case TypeCode.Char:
                case TypeCode.Int16:
                case TypeCode.Int32:
                case TypeCode.SByte:
                case TypeCode.Single:
                case TypeCode.UInt16:
                case TypeCode.UInt32:
                    return true;

                case TypeCode.Int64:
                case TypeCode.Double:
                case TypeCode.UInt64:
                    return IntPtr.Size == 8;

                default:
                    return false;
            }
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该方法依据CLI规范进行编写,简单来说,32位的计算机,对32字节以下的数据类型写入时可以一次写入的而不需要移动内存指针,64位计算机对64位以下的数据可一次性写入,不需要移动内存指针.保证了写入的安全.&lt;br/&gt;详见12.6.6 &lt;a href=&quot;http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-335.pdf&quot; class=&quot;uri&quot;&gt;http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-335.pdf&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;
 private bool TryAddInternal(TKey key, TValue value, bool updateIfExists, bool acquireLock, out TValue resultingValue)
        {
            while (true)
            {
                int bucketNo, lockNo;
                int hashcode;

                //https://www.cnblogs.com/blurhkh/p/10357576.html
                //需要了解一下值传递和引用传递
                Tables tables = m_tables;
                IEqualityComparer&amp;lt;TKey&amp;gt; comparer = tables.m_comparer;
                hashcode = comparer.GetHashCode(key);

                GetBucketAndLockNo(hashcode, out bucketNo, out lockNo, tables.m_buckets.Length, tables.m_locks.Length);

                bool resizeDesired = false;
                bool lockTaken = false;

                try
                {
                    if (acquireLock)
                        Monitor.Enter(tables.m_locks[lockNo], ref lockTaken);

                    //如果表刚刚调整了大小，我们可能没有持有正确的锁，必须重试。
                    //当然这种情况很少见
                    if (tables != m_tables)
                        continue;

                    Node prev = null;
                    for (Node node = tables.m_buckets[bucketNo]; node != null; node = node.m_next)
                    {
                        if (comparer.Equals(node.m_key, key))
                        {
                            //key在字典里找到了。如果允许更新，则更新该key的值。
                            //我们需要为更新创建一个node，以支持不能以原子方式写入的TValue类型，因为free-lock 读取可能同时发生。
                            if (updateIfExists)
                            {
                                if (s_isValueWriteAtomic)
                                {
                                    node.m_value = value;
                                }
                                else
                                {
                                    Node newNode = new Node(node.m_key, value, hashcode, node.m_next);
                                    if (prev == null)
                                    {
                                        tables.m_buckets[bucketNo] = newNode;
                                    }
                                    else
                                    {
                                        prev.m_next = newNode;
                                    }
                                }

                                resultingValue = value;
                            }
                            else
                            {
                                resultingValue = node.m_value;
                            }

                            return false;
                        }

                        prev = node;
                    }

                    //key没有在bucket中找到,则插入该数据
                    Volatile.Write(ref tables.m_buckets[bucketNo], new Node(key, value, hashcode, tables.m_buckets[bucketNo]));
                    //当m_countPerLock超过Int Max时会抛出OverflowException
                    checked
                    {
                        tables.m_countPerLock[lockNo]++;
                    }

                    //
                    // 如果m_countPerLock[lockNo] &amp;gt; m_budget，则需要调整buckets的大小。
                    // GrowTable也可能会增加m_budget，但不会调整bucket table的大小。.
                    // 如果发现bucket table利用率很低，也会发生这种情况。
                    //
                    if (tables.m_countPerLock[lockNo] &amp;gt; m_budget)
                    {
                        resizeDesired = true;
                    }
                }
                finally
                {
                    if (lockTaken)
                        Monitor.Exit(tables.m_locks[lockNo]);
                }

                if (resizeDesired)
                {
                    GrowTable(tables, tables.m_comparer, false, m_keyRehashCount);
                }

                resultingValue = value;
                return true;
            }
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;get&quot;&gt;Get&lt;/h3&gt;
&lt;p&gt;从Table中获取元素的的流程与前文介绍ConcurrentDictionary工作原理时一致,但有以下亮点值得关注.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;读取bucket[i]在Volatile.Read()方法中进行,该方法会自动对读取出来的数据加锁,避免在读取的过程中,数据被其他线程remove了.&lt;/li&gt;
&lt;li&gt;Volatile读取指定字段时，在读取的内存中插入一个内存屏障，阻止处理器重新排序内存操作，如果在代码中此方法之后出现读取或写入，则处理器无法在此方法之前移动它。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;
 public bool TryGetValue(TKey key, out TValue value)
        {
            if (key == null) throw new ArgumentNullException(&quot;key&quot;);

            // We must capture the m_buckets field in a local variable. It is set to a new table on each table resize.
            Tables tables = m_tables;
            IEqualityComparer&amp;lt;TKey&amp;gt; comparer = tables.m_comparer;
            GetBucketAndLockNo(comparer.GetHashCode(key), out var bucketNo, out _, tables.m_buckets.Length, tables.m_locks.Length);

            // We can get away w/out a lock here.
            // The Volatile.Read ensures that the load of the fields of 'n' doesn't move before the load from buckets[i].
            Node n = Volatile.Read(ref tables.m_buckets[bucketNo]);

            while (n != null)
            {
                if (comparer.Equals(n.m_key, key))
                {
                    value = n.m_value;
                    return true;
                }
                n = n.m_next;
            }

            value = default(TValue);
            return false;
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;remove&quot;&gt;Remove&lt;/h3&gt;
&lt;p&gt;Remove方法实现其实也并不复杂,类似我们链表操作中移除某个Node.移除节点的同时,还要对前后节点进行链接,相信一块小伙伴们肯定很好理解.&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt; private bool TryRemoveInternal(TKey key, out TValue value, bool matchValue, TValue oldValue)
        {
            while (true)
            {
                Tables tables = m_tables;

                IEqualityComparer&amp;lt;TKey&amp;gt; comparer = tables.m_comparer;

                int bucketNo, lockNo;

                GetBucketAndLockNo(comparer.GetHashCode(key), out bucketNo, out lockNo, tables.m_buckets.Length, tables.m_locks.Length);

                lock (tables.m_locks[lockNo])
                {
                    if (tables != m_tables)
                        continue;

                    Node prev = null;
                    for (Node curr = tables.m_buckets[bucketNo]; curr != null; curr = curr.m_next)
                    {
                        if (comparer.Equals(curr.m_key, key))
                        {
                            if (matchValue)
                            {
                                bool valuesMatch = EqualityComparer&amp;lt;TValue&amp;gt;.Default.Equals(oldValue, curr.m_value);
                                if (!valuesMatch)
                                {
                                    value = default(TValue);
                                    return false;
                                }
                            }
                            if (prev == null)
                                Volatile.Write(ref tables.m_buckets[bucketNo], curr.m_next);
                            else
                            {
                                prev.m_next = curr.m_next;
                            }

                            value = curr.m_value;
                            tables.m_countPerLock[lockNo]--;
                            return true;
                        }

                        prev = curr;
                    }
                }

                value = default(TValue);
                return false;
            }
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;grow-table&quot;&gt;Grow table&lt;/h3&gt;
&lt;p&gt;当table中任何一个m_countPerLock的数量超过了设定的阈值后,会触发此操作对Table进行扩容.&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;private void GrowTable(Tables tables, IEqualityComparer&amp;lt;TKey&amp;gt; newComparer, bool regenerateHashKeys,
            int rehashCount)
        {
            int locksAcquired = 0;
            try
            {
                //首先锁住第一个lock进行resize操作.
                AcquireLocks(0, 1, ref locksAcquired);

                if (regenerateHashKeys &amp;amp;&amp;amp; rehashCount == m_keyRehashCount)
                {
                    tables = m_tables;
                }
                else
                {
                    if (tables != m_tables)
                        return;

                    long approxCount = 0;
                    for (int i = 0; i &amp;lt; tables.m_countPerLock.Length; i++)
                    {
                        approxCount += tables.m_countPerLock[i];
                    }

                    //如果bucket数组太空，则将预算加倍，而不是调整表的大小
                    if (approxCount &amp;lt; tables.m_buckets.Length / 4)
                    {
                        m_budget = 2 * m_budget;
                        if (m_budget &amp;lt; 0)
                        {
                            m_budget = int.MaxValue;
                        }

                        return;
                    }
                }

                int newLength = 0;
                bool maximizeTableSize = false;
                try
                {
                    checked
                    {
                        newLength = tables.m_buckets.Length * 2 + 1;
                        while (newLength % 3 == 0 || newLength % 5 == 0 || newLength % 7 == 0)
                        {
                            newLength += 2;
                        }
                    }
                }
                catch (OverflowException)
                {
                    maximizeTableSize = true;
                }

                if (maximizeTableSize)
                {
                    newLength = int.MaxValue;

                    m_budget = int.MaxValue;
                }

                AcquireLocks(1, tables.m_locks.Length, ref locksAcquired);

                object[] newLocks = tables.m_locks;

                //Add more locks
                if (m_growLockArray &amp;amp;&amp;amp; tables.m_locks.Length &amp;lt; MAX_LOCK_NUMBER)
                {
                    newLocks = new object[tables.m_locks.Length * 2];
                    Array.Copy(tables.m_locks, newLocks, tables.m_locks.Length);

                    for (int i = tables.m_locks.Length; i &amp;lt; newLocks.Length; i++)
                    {
                        newLocks[i] = new object();
                    }
                }

                Node[] newBuckets = new Node[newLength];
                int[] newCountPerLock = new int[newLocks.Length];

                for (int i = 0; i &amp;lt; tables.m_buckets.Length; i++)
                {
                    Node current = tables.m_buckets[i];
                    while (current != null)
                    {
                        Node next = current.m_next;
                        int newBucketNo, newLockNo;
                        int nodeHashCode = current.m_hashcode;

                        if (regenerateHashKeys)
                        {
                            //Recompute the hash from the key
                            nodeHashCode = newComparer.GetHashCode(current.m_key);
                        }

                        GetBucketAndLockNo(nodeHashCode, out newBucketNo, out newLockNo, newBuckets.Length,
                            newLocks.Length);

                        newBuckets[newBucketNo] = new Node(current.m_key, current.m_value, nodeHashCode,
                            newBuckets[newBucketNo]);
                        checked
                        {
                            newCountPerLock[newLockNo]++;
                        }

                        current = next;
                    }
                }

                if (regenerateHashKeys)
                {
                    unchecked
                    {
                        m_keyRehashCount++;
                    }
                }

                m_budget = Math.Max(1, newBuckets.Length / newLocks.Length);

                m_tables = new Tables(newBuckets, newLocks, newCountPerLock, newComparer);
            }
            finally
            {
                ReleaseLocks(0, locksAcquired);
            }
        }
&lt;/code&gt;
&lt;/pre&gt;

&lt;ul readability=&quot;29.288224956063&quot;&gt;&lt;li readability=&quot;12&quot;&gt;
&lt;p&gt;&lt;code&gt;lock[]&lt;/code&gt;:在以往的线程安全上,我们对数据的保护往往是对数据的修改写入等地方加上lock,这个lock经常上整个上下文中唯一的,这样的设计下就可能会出现多个线程,写入的根本不是一块数据,却要等待前一个线程写入完成下一个线程才能继续操作.在ConcurrentDictionary中,通过哈希算法,从数组&lt;code&gt;lock[]&lt;/code&gt;中找出key的准确lock,如果不同的key,使用的不是同一个lock,那么这多个线程的写入时互不影响的.&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;11&quot;&gt;
&lt;p&gt;写入要考虑线程安全,读取呢?不可否认,在大部分场景下,读取不必去考虑线程安全,但是在我们这样的链式读取中,需要自上而下地查找,是不是有种可能在查找个过程中,链路被修改了呢?所以ConcurrentDictionary中使用Volatile.Read来读取出数据,该方法从指定字段读取对象引用,在需要它的系统上，插入一个内存屏障，阻止处理器重新排序内存操作，如果在代码中此方法之后出现读取或写入，则处理器无法在此方法之前移动它。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;27.481086323957&quot;&gt;
&lt;p&gt;在ConcurrentDictionary的更新方法中,对数据进行更新时,会判断该数据是否可以原子写入,如果时可以原子写入的,那么就直接更新数据,如果不是,那么会创建一个新的node覆盖原有node,起初看到这里时候,我百思不得其解,不知道这么操作的目的,后面在jeo duffy的博客中&lt;a href=&quot;http://joeduffyblog.com/2006/02/07/threadsafety-torn-reads-and-the-like/&quot;&gt;Thread-safety, torn reads, and the like&lt;/a&gt;中找到了答案,这样操作时为了防止torn reads(撕裂读取),什么叫撕裂读取呢?通俗地说,就是有的数据类型写入时,要分多次写入,写一次,移动一次指针,那么就有可能写了一半,这个结果被另外一个线程读取走了.比如说我把 &lt;code&gt;刘振宇&lt;/code&gt;三个字改成&lt;code&gt;周杰伦&lt;/code&gt;的过程中,我先改把刘改成周了,正在我准备去把振改成杰的时候,另外一个线程过来读取结果了,读到的数据是&lt;code&gt;周振宇&lt;/code&gt;,这显然是不对的.所以对这种,更安全的做法是先把&lt;code&gt;周杰伦&lt;/code&gt;三个字写好在一张纸条上,然后直接替换掉&lt;code&gt;刘振宇&lt;/code&gt;.更多信息在&lt;a href=&quot;http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-335.pdf&quot;&gt;CLI规范12.6.6&lt;/a&gt;有详细介绍.&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;code&gt;checked&lt;/code&gt;和&lt;code&gt;unckecked&lt;/code&gt;关键字.非常量的运算(non-constant)运算在编译阶段和运行时下不会做溢出检查,如下这样的代码时不会抛出异常的,算错了也不会报错。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;int ten = 10;
int i2 = 2147483647 + ten;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是我们知道,int的最大值是2147483647,如果我们将上面这样的代码嵌套在&lt;code&gt;checked&lt;/code&gt;就会做溢出检查了.&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;checked
{
int ten = 10;
int i2 = 2147483647 + ten;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;相反,对于常量,编译时是会做溢出检查的,下面这样的代码在编译时就会报错的,如果我们使用&lt;code&gt;unckeck&lt;/code&gt;标签进行标记,则在编译阶段不会做移除检查.&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;int a = int.MaxValue * 2;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么问题来了,我们当然知道checked很有用,那么uncheck呢?如果我们只是需要那么一个数而已，至于溢出不溢出的关系不大，比如说生成一个对象的HashCode，比如说根据一个算法计算出一个相对随机数，这都是不需要准确结果的,ConcurrentDictionary中对于&lt;code&gt;m_keyRehashCount++&lt;/code&gt;这个运算就使用了unchecked,就是因为m_keyRehashCount是用来生成哈希值的,我们并不关心它有没有溢出.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;volatile&lt;/code&gt;关键字,表示一个字段可能是由在同一时间执行多个线程进行修改。出于性能原因，编译器\运行时系统甚至硬件可以重新排列对存储器位置的读取和写入。声明的字段volatile不受这些优化的约束。添加volatile修饰符可确保所有线程都能按照执行顺序由任何其他线程执行的易失性写入,易失性写入是一件疯狂的事情的事情:&lt;a href=&quot;https://stackoverflow.com/questions/72275/when-should-the-volatile-keyword-be-used-in-c&quot;&gt;普通玩家慎用&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;本博客锁涉及的代码都保存在github中,Take it easy to enjoy it!&lt;br/&gt;&lt;a href=&quot;https://github.com/liuzhenyulive/DictionaryMini/blob/master/DictionaryMini/DictionaryMini/ConcurrentDictionaryMini.cs&quot; class=&quot;uri&quot;&gt;https://github.com/liuzhenyulive/DictionaryMini/blob/master/DictionaryMini/DictionaryMini/ConcurrentDictionaryMini.cs&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 17 Mar 2019 14:31:00 +0000</pubDate>
<dc:creator>码农阿宇</dc:creator>
<og:description>背景 在上一篇文章 '你真的了解字典吗?' 一文中我介绍了Hash Function和字典的工作的基本原理. 有网友在文章底部评论,说我的Remove和Add方法没有考虑线程安全问题. 查阅相关资料后</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CoderAyu/p/10549409.html</dc:identifier>
</item>
</channel>
</rss>