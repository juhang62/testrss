<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>记一次博客页面美化过程,分享代码. - 炭烧生蚝</title>
<link>http://www.cnblogs.com/tanshaoshenghao/p/10801547.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tanshaoshenghao/p/10801547.html</guid>
<description>&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;注册博客园账号有一个多月了, 一直想优化一下自己的博客页面. 在首页浏览时候发现一位博主的页面挺干净整洁的, 而且他分享了制作的思路, 于是下定决心美化一番. 本文将介绍美化的思路, 并贴上所有代码, 俗话说授之以鱼也要授之以渔.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;&lt;li&gt;致谢要写在前面, 这位博主把他博客的整套CSS代码都贡献出来了, 在此基础上进行修改变得十分容易. 秉承这种精神, 文章末尾也将奉献上我的所有定制代码, 如果哪位朋友想直接体验以下, 直接复制就行了.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/hafiz/&quot;&gt;该博主的博客地址&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;markdown美化&quot;&gt;1. Markdown美化&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;首先要美化的就是&lt;code&gt;Markdown&lt;/code&gt;的显示了. 第一次接触&lt;code&gt;Markdown&lt;/code&gt;是在注册完Github创建一个新仓库的时候, 写&lt;code&gt;README&lt;/code&gt;必须得用&lt;code&gt;Markdown&lt;/code&gt;写, 当时就觉得怎么有这么好看的排版.&lt;/li&gt;
&lt;li&gt;后来在博客园上第一次用&lt;code&gt;Markdown&lt;/code&gt;写博客, 点完发布回头一看...???...&lt;/li&gt;
&lt;li&gt;当时觉得这个估计是&lt;code&gt;Markdown&lt;/code&gt;的变种, 也能凑合着用就没管了.&lt;/li&gt;
&lt;li&gt;现在知道了&lt;code&gt;Markdown&lt;/code&gt;其实是使文字通过某种&lt;code&gt;CSS&lt;/code&gt;样式美化后显示出来而已, 既然这样, 我们可以自己修改&lt;code&gt;Markdown&lt;/code&gt;的显示样式.&lt;/li&gt;
&lt;li&gt;这里贴一段简单的代码演示修改的过程, 后面会贴上带有注释的完整代码.&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;首先选中你要修改的地方, 然后在开发者工具中(谷歌浏览器快捷键F12)中直接对&lt;code&gt;CSS&lt;/code&gt;样式进行修改. (博主是后端方向, 也没记得几个CSS样式, 基本都是边查边改哈)&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190501214425835.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTM1Nzc2Nw==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/li&gt;
&lt;li&gt;修改得到满意的&lt;code&gt;CSS&lt;/code&gt;样式后, 把他复制到&lt;code&gt;页面定制CSS代码&lt;/code&gt;栏中, 可以通过&lt;code&gt;我的博客-&amp;gt;管理-&amp;gt;设置&lt;/code&gt;找到该栏.&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190501215051768.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTM1Nzc2Nw==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/li&gt;
&lt;li&gt;这样便完成了一个样式的美化&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;给博客页面加上鼠标停留响应&quot;&gt;2. 给博客页面加上鼠标停留响应&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;#header #navigator ul li {
    float: left;
    width: 13%; /*div原来的宽度为13%*/
    text-align: center;
    margin-right: 0px;
    background: #9e9e9e14;
    transition: width 0.5s; /*CSS3中引入的过渡功能, 意思是width属性将会发生变化, 变化时间为0.5秒*/
    -moz-transition: width 0.5s; /*后面几个意思一样, 多写几个为了兼容不同的浏览器*/   
    -webkit-transition: width 0.5s;
    -o-transition: width 0.5s;
}
#header #navigator ul li:hover { /*hover即为鼠标停留时的样式*/
    width: 20%; /*宽度变为20%*/
}&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;字体大小font-size发生变化&quot;&gt;Ⅱ. 字体大小&lt;code&gt;font-size&lt;/code&gt;发生变化&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/tanshaoshenghao/1426602/o_boke2.gif&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt; &lt;/p&gt;
&lt;ul&gt;&lt;li&gt;具体代码如下:&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;.postTitle, .entrylistPosttitle {
    font-family: &quot;Lato&quot;, Helvetica Neue, Helvetica, Arial, sans-serif;
    font-size: 1.8em;
    padding: 20px 20px 15px 0px;
    background: #fff;
    border-radius: 10px 10px 0px 0px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    transition: font-size 0.5s; /*这里改变的是字体的大小*/
    -moz-transition: font-size 0.5s;
    -webkit-transition: font-size 0.5s;
    -o-transition: font-size 0.5s;
}
.postTitle:hover {
    font-size: 2em; 
}&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;给容器添加阴影效果&quot;&gt;Ⅲ. 给容器添加阴影效果&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/tanshaoshenghao/1426602/o_boke3.gif&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;具体代码如下&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;.search, .newsItem, .catListPostCategory, .catListPostArchive, .catListTag, .catListView, .catListBlogRank {
    background: #fff;
    margin-bottom: 30px;
    word-wrap: break-word;
    border-radius: 10px;
    margin-top: 10px;
    border: 2px solid #9E9E9E;
    transition: box-shadow 0.5s;
    -moz-transition: box-shadow 0.5s;
    -webkit-transition: box-shadow 0.5s;
    -o-transition: box-shadow 0.5s;
}
/*添加阴影*/
.newsItem:hover, .catListPostCategory:hover, .catListPostArchive:hover, .catListTag:hover, .catListView:hover, .catListBlogRank:hover {
    /* border: 5px solid; */
    box-shadow: 10px 10px 10px #9E9E9E;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;处理一些细节&quot;&gt;3. 处理一些细节&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;让点赞图标也能旋转起来.&lt;/li&gt;
&lt;li&gt;隐藏掉文章数量显示(感觉都是写随笔, 百度了一下文章的功能, 但还是没有搞懂)&lt;/li&gt;
&lt;li&gt;修改了一些文本的颜色.&lt;/li&gt;
&lt;li&gt;在页面右上角添加&lt;code&gt;Github&lt;/code&gt;标签. (如果你打算使用这套模板, 别忘了在&lt;code&gt;CSS&lt;/code&gt;代码中把&lt;code&gt;Github&lt;/code&gt;地址修改为自己的&lt;code&gt;Github&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;


</description>
<pubDate>Wed, 01 May 2019 23:41:00 +0000</pubDate>
<dc:creator>炭烧生蚝</dc:creator>
<og:description>[TOC] 注册博客园账号有一个多月了, 一直想优化一下自己的博客页面. 在首页浏览时候发现一位博主的页面挺干净整洁的, 而且他分享了制作的思路, 于是下定决心美化一番. 本文将介绍美化的思路, 并贴</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tanshaoshenghao/p/10801547.html</dc:identifier>
</item>
<item>
<title>WebGL半透明物体的绘制 - Jeff.Zhong</title>
<link>http://www.cnblogs.com/edwardloveyou/p/10801422.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/edwardloveyou/p/10801422.html</guid>
<description>&lt;p&gt;WebGL 中当透明和半透明物体共存时，相关设置不正确的话，物体表面会出现破碎杂乱的断面，非常影响效果，我们接着就来解决这个问题。&lt;br/&gt;完成的展示Demo请看: &lt;strong&gt;&lt;a href=&quot;https://edwardzhong.github.io/sites/demo/dist/webglalpha.html&quot;&gt;半透明物体和透明物体共存&lt;/a&gt;&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/127924-07fe85ce0e09500c.gif&quot; alt=&quot;alpha混合&quot;/&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id=&quot;α-混合&quot;&gt;α 混合&lt;/h2&gt;
&lt;p&gt;让物体实现半透明效果需要用到颜色的α分量。该功能被称为a混合(alpha blending) 或 混合 blending，WebGL已经内置该功能，但需要开启，如果只设置了颜色的第四个分量 α 是看不到透明效果的，这第四分量α其实和 css 样式的 rgba / hsla 颜色模式 中的 α 是一样的，或者类似 opacity 属性。必须要执行下面两个步骤才能看到透明效果:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;开启混合功能：gl.enable(gl.BLEND)。&lt;/li&gt;
&lt;li&gt;指定混合函数：gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA)。&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;gl.blendfuncsrc_factor-dst_factor&quot;&gt;gl.blendFunc(src_factor, dst_factor)&lt;/h4&gt;
&lt;p&gt;a混合函数，指定如如何混合两者的颜色，权重因子的类型多种多样，参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;src_factor: 指定源颜色在混合颜色的权重因子，如下表所示&lt;/li&gt;
&lt;li&gt;dst_factor: 指定目标颜色在混合后颜色的权重因子，如下表所示&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;// 混合颜色计算公式： 
&amp;lt;混合后的颜色&amp;gt; = &amp;lt;源颜色&amp;gt; * src_factor + &amp;lt;目标颜色&amp;gt; * dst_factor

// 一般半透明效果常用如下形式
gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA)&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;权重因子列表&quot;&gt;权重因子列表&lt;/h4&gt;
&lt;p&gt;(Rs,Gs,Bs,As) 表示源颜色各分量， (Rd,Gd,Bd,Ad) 表示目标颜色的各分量&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;gl.ZERO&lt;/td&gt;
&lt;td&gt;0.0&lt;/td&gt;
&lt;td&gt;0.0&lt;/td&gt;
&lt;td&gt;0.0&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;gl.ONE&lt;/td&gt;
&lt;td&gt;1.0&lt;/td&gt;
&lt;td&gt;1.0&lt;/td&gt;
&lt;td&gt;1.0&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;gl.SRC_COLOR&lt;/td&gt;
&lt;td&gt;Rs&lt;/td&gt;
&lt;td&gt;Gs&lt;/td&gt;
&lt;td&gt;Bs&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;gl.ONE_MINUS_SRC_COLOR&lt;/td&gt;
&lt;td&gt;1-Rs&lt;/td&gt;
&lt;td&gt;1-Gs&lt;/td&gt;
&lt;td&gt;1-Bs&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;gl.DST_COLOR&lt;/td&gt;
&lt;td&gt;Rd&lt;/td&gt;
&lt;td&gt;Gd&lt;/td&gt;
&lt;td&gt;Bd&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;gl.ONE_MINUS_DST_COLOR&lt;/td&gt;
&lt;td&gt;1-Rd&lt;/td&gt;
&lt;td&gt;1-Gd&lt;/td&gt;
&lt;td&gt;1-Bd&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;gl.SRC_ALPHA&lt;/td&gt;
&lt;td&gt;As&lt;/td&gt;
&lt;td&gt;As&lt;/td&gt;
&lt;td&gt;As&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;gl.ONE_MINUS_SRC_ALPHA&lt;/td&gt;
&lt;td&gt;1-As&lt;/td&gt;
&lt;td&gt;1-As&lt;/td&gt;
&lt;td&gt;1-As&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;gl.DST_ALPHA&lt;/td&gt;
&lt;td&gt;Ad&lt;/td&gt;
&lt;td&gt;Ad&lt;/td&gt;
&lt;td&gt;Ad&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;gl.ONE_MINUS_DST_ALPHA&lt;/td&gt;
&lt;td&gt;1-Ad&lt;/td&gt;
&lt;td&gt;1-Ad&lt;/td&gt;
&lt;td&gt;1-Ad&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;gl.SRC_ALPHA_SATUREATE&lt;/td&gt;
&lt;td&gt;min(As,Ad)&lt;/td&gt;
&lt;td&gt;min(As,Ad)&lt;/td&gt;
&lt;td&gt;min(As,Ad)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;透明和不透明物体共存&quot;&gt;透明和不透明物体共存&lt;/h2&gt;
&lt;p&gt;实现 a 混合最简单的方式是屏蔽掉隐藏面消除功能，即去掉 gl.enable(gl.DEPTH_TEST)，但关闭隐藏面消除功能是一个粗暴的解决方案，并不能满足实际需求。其实可通过某些机制，同时实现隐藏面消除和半透明效果，步骤如下：&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;//1.开启隐藏面消除功能:
gl.enable(gl.DEPTH_TEST)。

//2.绘制所有不透明的物体(a == 1.0)

//3.锁定深度缓冲区的写入操作，使之只读 (深度缓冲区用于隐藏面消除):
gl.depthMask(false);

//4.绘制所有半透明的物体 a &amp;lt; 1.0，注意将物体按深度排序，a 最小最先绘制

//5.释放深度缓冲区，使之可读可写: 
gl.depthMask(true)&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;gl.depthmaskmask&quot;&gt;gl.depthMask(mask)&lt;/h4&gt;
&lt;p&gt;锁定或释放深度缓冲区的写入操作&lt;/p&gt;
&lt;p&gt;mask: 锁定深度缓冲区的写入操作 false，释放 true&lt;/p&gt;
&lt;h2 id=&quot;实现效果&quot;&gt;实现效果&lt;/h2&gt;
&lt;p&gt;我们写个Demo来实际演示效果，比如我要绘制8个物体，其中前面4个是非透明的物体，即 α 分量值则为1，剩余物体的 α 分量分别从 0.1至0.4不等。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;for (var i = 0; i &amp;lt; 8; i++) {
    let color = randomColor();
    color[3] = i &amp;gt; 3 ? (i - 3)/10 :1;// 透明物体 α 分量小于1，非透明物体则等于1
    
    Polygons.push({
        x: random(-9,9),
        y: random(0, 6),
        z: random(-5,5),
        color: color
    });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果是绘制的物体队列是无序的，则必须手动排序。但我这里建立图形时已经排好序，前4个为不透明物体，剩余是透明物体，所以可直接按顺序绘制，针对是否为透明物体，分别设置缓冲区写入和隐藏面删除功能。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;if(i &amp;lt; 4){ // 非透明物体
    gl.depthMask(true);
    gl.disable(gl.BLEND);
} else { //透明物体
    gl.depthMask(false);
    gl.enable(gl.BLEND);
    gl.blendFunc( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA );
}
drawBufferInfo(gl, vao);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终完成效果请看：&lt;strong&gt;&lt;a href=&quot;https://edwardzhong.github.io/sites/demo/dist/webglalpha.html&quot;&gt;半透明物体和透明物体共存&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 01 May 2019 16:48:00 +0000</pubDate>
<dc:creator>Jeff.Zhong</dc:creator>
<og:description>WebGL 中当透明和半透明物体共存时，相关设置不正确的话，物体表面会出现破碎杂乱的断面，非常影响效果，我们接着就来解决这个问题。 完成的展示Demo请看: '半透明物体和透明物体共存' &lt;! mor</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/edwardloveyou/p/10801422.html</dc:identifier>
</item>
<item>
<title>VOC数据集  目标检测 - sdu20112013</title>
<link>http://www.cnblogs.com/sdu20112013/p/10801383.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sdu20112013/p/10801383.html</guid>
<description>&lt;p&gt;最近在做与目标检测模型相关的工作,很多都要求VOC格式的数据集.&lt;/p&gt;
&lt;p&gt;PASCAL VOC挑战赛 （The PASCAL Visual Object Classes ）是一个世界级的计算机视觉挑战赛, PASCAL全称：Pattern Analysis, Statical Modeling and Computational Learning，是一个由欧盟资助的网络组织。很多模型都基于此数据集推出.比如目标检测领域的yolo,ssd等等.&lt;/p&gt;
&lt;h3 id=&quot;voc数据集结构&quot;&gt;voc数据集结构&lt;/h3&gt;
&lt;p&gt;看下目录结构&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;:~/git_projects/models/research/VOCdevkit/VOC2012$ tree -d 
.
├── Annotations
├── ImageSets
│   ├── Action
│   ├── Layout
│   ├── Main
│   └── Segmentation
├── JPEGImages
├── SegmentationClass
└── SegmentationObject
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol readability=&quot;-2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;JPEGImages&lt;br/&gt;这个目录下存放的是图片数据.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;Annotations下存放的是xml文件,描述了图片信息.&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;~/git_projects/models/research/VOCdevkit/VOC2012/Annotations$ cat 2012_004331.xml
&amp;lt;annotation&amp;gt;
    &amp;lt;filename&amp;gt;2012_004331.jpg&amp;lt;/filename&amp;gt;
    &amp;lt;folder&amp;gt;VOC2012&amp;lt;/folder&amp;gt;
    &amp;lt;object&amp;gt;
        &amp;lt;name&amp;gt;person&amp;lt;/name&amp;gt;
        &amp;lt;actions&amp;gt;
            &amp;lt;jumping&amp;gt;1&amp;lt;/jumping&amp;gt;
            &amp;lt;other&amp;gt;0&amp;lt;/other&amp;gt;
            &amp;lt;phoning&amp;gt;0&amp;lt;/phoning&amp;gt;
            &amp;lt;playinginstrument&amp;gt;0&amp;lt;/playinginstrument&amp;gt;
            &amp;lt;reading&amp;gt;0&amp;lt;/reading&amp;gt;
            &amp;lt;ridingbike&amp;gt;0&amp;lt;/ridingbike&amp;gt;
            &amp;lt;ridinghorse&amp;gt;0&amp;lt;/ridinghorse&amp;gt;
            &amp;lt;running&amp;gt;0&amp;lt;/running&amp;gt;
            &amp;lt;takingphoto&amp;gt;0&amp;lt;/takingphoto&amp;gt;
            &amp;lt;usingcomputer&amp;gt;0&amp;lt;/usingcomputer&amp;gt;
            &amp;lt;walking&amp;gt;0&amp;lt;/walking&amp;gt;
        &amp;lt;/actions&amp;gt;
        &amp;lt;bndbox&amp;gt;
            &amp;lt;xmax&amp;gt;208&amp;lt;/xmax&amp;gt;
            &amp;lt;xmin&amp;gt;102&amp;lt;/xmin&amp;gt;
            &amp;lt;ymax&amp;gt;230&amp;lt;/ymax&amp;gt;
            &amp;lt;ymin&amp;gt;25&amp;lt;/ymin&amp;gt;
        &amp;lt;/bndbox&amp;gt;
        &amp;lt;difficult&amp;gt;0&amp;lt;/difficult&amp;gt;
        &amp;lt;pose&amp;gt;Unspecified&amp;lt;/pose&amp;gt;
        &amp;lt;point&amp;gt;
            &amp;lt;x&amp;gt;155&amp;lt;/x&amp;gt;
            &amp;lt;y&amp;gt;119&amp;lt;/y&amp;gt;
        &amp;lt;/point&amp;gt;
    &amp;lt;/object&amp;gt;
    &amp;lt;segmented&amp;gt;0&amp;lt;/segmented&amp;gt;
    &amp;lt;size&amp;gt;
        &amp;lt;depth&amp;gt;3&amp;lt;/depth&amp;gt;
        &amp;lt;height&amp;gt;375&amp;lt;/height&amp;gt;
        &amp;lt;width&amp;gt;500&amp;lt;/width&amp;gt;
    &amp;lt;/size&amp;gt;
    &amp;lt;source&amp;gt;
        &amp;lt;annotation&amp;gt;PASCAL VOC2012&amp;lt;/annotation&amp;gt;
        &amp;lt;database&amp;gt;The VOC2012 Database&amp;lt;/database&amp;gt;
        &amp;lt;image&amp;gt;flickr&amp;lt;/image&amp;gt;
    &amp;lt;/source&amp;gt;
&amp;lt;/annotation&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对应的图片为&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/583030/201905/583030-20190502002827209-922017974.png&quot;/&gt;&lt;br/&gt;我们注意需要关注的就是节点下的数据,尤其是bndbox下的数据.xmin,ymin构成了boundingbox的左上角,xmax,ymax构成了boundingbox的右下角.&lt;br/&gt;啥叫boundingbox? 模型检测出目标了,会画一个框框,标定这个框框内的东西,认为是一个object.&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/583030/201905/583030-20190502002901282-1441707903.png&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;ImageSets&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;Action下存放的是人的动作（例如running、jumping等等，这也是VOC challenge的一部分）&lt;/li&gt;
&lt;li&gt;Layout下存放的是具有人体部位的数据（人的head、hand、feet等等，这也是VOC challenge的一部分）&lt;/li&gt;
&lt;li&gt;Segmentation下存放的是可用于分割的数据。&lt;/li&gt;
&lt;li&gt;Main下存放的是图像物体识别的数据，总共分为20类。&lt;br/&gt;我们主要关注Main下面的文件.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/583030/201905/583030-20190502002942618-1445922714.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一共63个文件,train.txt/val.txt/trainval.txt里面记录的是对应的数据集图片名字. 剩下60个文件=20*3. 一共20个类别,每个类别有xxx_train.txt,xxx_val.txt,xxx_trainval.txt.&lt;/p&gt;
&lt;p&gt;1代表正样本,-1代表负样本&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;看一下aeroplane_train.txt中的部分内容
2011_003177  1    //意思是2011_003177.jpg中有aeroplane
2011_003183 -1    //意思是2011_003183.jpg中没有aeroplane
2011_003184 -1
2011_003187 -1
2011_003188 -1
2011_003192 -1
2011_003194 -1
2011_003216 -1
2011_003223 -1
2011_003230 -1
2011_003236 -1
2011_003238 -1
2011_003246 -1
2011_003247 -1
2011_003253 -1
2011_003255 -1
2011_003259 -1
2011_003274 -1
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;看一下train.txt中的内容  只含图片名称
2011_003187
2011_003188
2011_003192
2011_003194
2011_003216
2011_003223
2011_003230
2011_003236
2011_003238&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;制作自己的voc数据集&quot;&gt;制作自己的voc数据集&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;数据准备&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;标定图片:生成label文件,文件内容为类别及boundingbox信息&lt;/li&gt;
&lt;li&gt;生成符合VOC格式要求的文件 主要是Annotations/.xml ImageSets/main/.txt&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;数据准备这一步,你的数据可能来自公开数据集,或者合作方的私有数据.&lt;br/&gt;数据集的标注这一步可以使用labelIImg 标注自己的图片https://github.com/tzutalin/labelImg&lt;/p&gt;
&lt;p&gt;在做数据集格式转换的过程里,不可避免的要写很多脚本,每个人的需求不同,转换前拿到的文件内的数据格式不同,需要的脚本也都有所差异.这里提供几个我自己用的脚本.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#数据集划分
import os
import random

root_dir='./park_voc/VOC2007/'

## 0.7train 0.1val 0.2test
trainval_percent = 0.8
train_percent = 0.7
xmlfilepath = root_dir+'Annotations'
txtsavepath = root_dir+'ImageSets/Main'
total_xml = os.listdir(xmlfilepath)

num = len(total_xml)  # 100
list = range(num)
tv = int(num*trainval_percent)  # 80
tr = int(tv*train_percent)  # 80*0.7=56
trainval = random.sample(list, tv)
train = random.sample(trainval, tr)

ftrainval = open(root_dir+'ImageSets/Main/trainval.txt', 'w')
ftest = open(root_dir+'ImageSets/Main/test.txt', 'w')
ftrain = open(root_dir+'ImageSets/Main/train.txt', 'w')
fval = open(root_dir+'ImageSets/Main/val.txt', 'w')

for i in list:
    name = total_xml[i][:-4]+'\n'
    if i in trainval:
        ftrainval.write(name)
        if i in train:
            ftrain.write(name)
        else:
            fval.write(name)
    else:
        ftest.write(name)

ftrainval.close()
ftrain.close()
fval.close()
ftest .close()
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;#.txt--&amp;gt;.xml
#! /usr/bin/python
# -*- coding:UTF-8 -*-
import os, sys
import glob
from PIL import Image
 
# VEDAI 图像存储位置
src_img_dir = &quot;/home/train/dataset-expand/park_voc/VOC2007/JPEGImages&quot;
# VEDAI 图像的 ground truth 的 txt 文件存放位置
src_txt_dir = &quot;/home/train/dataset-expand/label_expand&quot;
src_xml_dir = &quot;/home/train/dataset-expand/park_voc/VOC2007/Annotations&quot;
 
img_Lists = glob.glob(src_img_dir + '/*.jpg')
 
img_basenames = [] # e.g. 100.jpg
for item in img_Lists:
    img_basenames.append(os.path.basename(item))
 
img_names = [] # e.g. 100
for item in img_basenames:
    temp1, temp2 = os.path.splitext(item)
    img_names.append(temp1)
 
for img in img_names:
    im = Image.open((src_img_dir + '/' + img + '.jpg'))
    width, height = im.size
 
    # open the crospronding txt file
    gt = open(src_txt_dir + '/' + img.replace('img','label',1) + '.txt').read().splitlines()
    #gt = open(src_txt_dir + '/gt_' + img + '.txt').read().splitlines()
 
    # write in xml file
    #os.mknod(src_xml_dir + '/' + img + '.xml')
    xml_file = open((src_xml_dir + '/' + img + '.xml'), 'w')
    xml_file.write('&amp;lt;annotation&amp;gt;\n')
    xml_file.write('    &amp;lt;folder&amp;gt;VOC2007&amp;lt;/folder&amp;gt;\n')
    xml_file.write('    &amp;lt;filename&amp;gt;' + str(img) + '.jpg' + '&amp;lt;/filename&amp;gt;\n')
    xml_file.write('    &amp;lt;size&amp;gt;\n')
    xml_file.write('        &amp;lt;width&amp;gt;' + str(width) + '&amp;lt;/width&amp;gt;\n')
    xml_file.write('        &amp;lt;height&amp;gt;' + str(height) + '&amp;lt;/height&amp;gt;\n')
    xml_file.write('        &amp;lt;depth&amp;gt;3&amp;lt;/depth&amp;gt;\n')
    xml_file.write('    &amp;lt;/size&amp;gt;\n')
 
    # write the region of image on xml file
    for img_each_label in gt:
        spt = img_each_label.split(',') #这里如果txt里面是以逗号‘，’隔开的，那么就改为spt = img_each_label.split(',')。
        xml_file.write('    &amp;lt;object&amp;gt;\n')
        xml_file.write('        &amp;lt;name&amp;gt;' + str(spt[4]) + '&amp;lt;/name&amp;gt;\n')
        xml_file.write('        &amp;lt;pose&amp;gt;Unspecified&amp;lt;/pose&amp;gt;\n')
        xml_file.write('        &amp;lt;truncated&amp;gt;0&amp;lt;/truncated&amp;gt;\n')
        xml_file.write('        &amp;lt;difficult&amp;gt;0&amp;lt;/difficult&amp;gt;\n')
        xml_file.write('        &amp;lt;bndbox&amp;gt;\n')
        xml_file.write('            &amp;lt;xmin&amp;gt;' + str(spt[0]) + '&amp;lt;/xmin&amp;gt;\n')
        xml_file.write('            &amp;lt;ymin&amp;gt;' + str(spt[1]) + '&amp;lt;/ymin&amp;gt;\n')
        xml_file.write('            &amp;lt;xmax&amp;gt;' + str(spt[2]) + '&amp;lt;/xmax&amp;gt;\n')
        xml_file.write('            &amp;lt;ymax&amp;gt;' + str(spt[3]) + '&amp;lt;/ymax&amp;gt;\n')
        xml_file.write('        &amp;lt;/bndbox&amp;gt;\n')
        xml_file.write('    &amp;lt;/object&amp;gt;\n')
 
    xml_file.write('&amp;lt;/annotation&amp;gt;')&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;目标检测判断标准&quot;&gt;目标检测判断标准&lt;/h3&gt;
&lt;p&gt;今天先不写了,待补充.&lt;/p&gt;
</description>
<pubDate>Wed, 01 May 2019 16:34:00 +0000</pubDate>
<dc:creator>sdu20112013</dc:creator>
<og:description>最近在做与目标检测模型相关的工作,很多都要求VOC格式的数据集. PASCAL VOC挑战赛 （The PASCAL Visual Object Classes ）是一个世界级的计算机视觉挑战赛, P</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sdu20112013/p/10801383.html</dc:identifier>
</item>
<item>
<title>大白话5分钟带你走进人工智能-第二十节逻辑回归和Softmax多分类问题(5) - LHBlog</title>
<link>http://www.cnblogs.com/LHWorldBlog/p/10801253.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/LHWorldBlog/p/10801253.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;                                                    大白话5分钟带你走进人工智能-第二十节逻辑回归和Softmax多分类问题(5)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上一节中，我们讲解了逻辑回归的优化，本节的话我们讲解逻辑回归做多分类问题以及传统的多分类问题，我们用什么手段解决。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先看一个场景，假如我们现在的数据集有3个类别，我们想通过逻辑回归建模给它区分出来。但我们知道逻辑回归本质上是区分二分类的算法模型。难道没有解决办法了吗？办法还是有的，既然想分出3类，我们姑且称这3个类别号为0,1,2。想通过逻辑回归做二分类的话，那么我们就分别判断每一条样本数据属不属于0号类别，属不属于1号类别，属不属于2号类别去判断，这样相当于建立3个逻辑回归的模型，分别训练，既照顾了逻辑回归二分类的本质，也照顾了多分类的需求。假如我们训练出来的3个模型， 第一个模型判断是不是1号类别的概率是0.8  第二个模型判断是不是2号类别的概率是0.1  第三个模型判断是不是3号类别的概率是 0.6 ，综合来看0.8&amp;gt;0.6&amp;gt;0.1,所以我们对这条样本判别为1号类别。剩下的所有样本数据亦如此。这种用逻辑回归解决问题的方式就是&lt;strong&gt;OVR( ovr  one vs rest )&lt;/strong&gt;。这里问个问题，&lt;strong&gt;这三个模型判断出来各自的概率相加结果是1 吗？肯定不是。因为我们是对每个模型单独训练出来的。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;我们先总结一下OVR思路就是：1，修改数据的lable。2，然后训练N个逻辑回归模型。3，根据输出结果概率输出。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里需要注意一个问题就是&lt;strong&gt;样本不均衡的问题。&lt;/strong&gt;逻辑回归就怕样本不均衡，当负例比正例或者正列比负例多很多的时候，模型判断会不准确，&lt;strong&gt;逻辑回归，最喜欢的是1:1的正负例&lt;/strong&gt;。 因为假如有一个训练集只有一条正例，其它的全都是负例，那么哪怕把所有的条目都判断为负例，正确率还是99%。因为在训练过程中，我们是找了一组w带来总的预测正确率最高，但这样情况下当样本不均衡的时候就会对正例特别的不公平，因为它只追求总的预测正确率最高，不管是正例还是负例，都会对少的那一部分很不公平，它会着重的想把多的预测准确了，获得更大的收益，对它来说这个w是更好的w。所以当样本不均衡的时候不一定会不好，但是很有可能的模型会不稳定。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;怎么解决样本不均衡的问题？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;通常的办法是对多的进行降采样&lt;/strong&gt;。 比如说只有30%的正例，有70%是负例，第一对70%的负例里面进行一个降采样，不要全部的负例了。&lt;strong&gt;第二，创造一些新的正例样本，属性随机采样，就是说把正例样本的每个属性对应的值随机采取点出来，组合出一个新的正例样本来&lt;/strong&gt;，这样凡是涉及到人工创建的训练集通常不太好，但是它是没办法的办法，已经不均衡了，没有更多的训练集了。按理说用降采样，但是发现不光负例多，正例还特别少，才几十条正例这会这已经很难了，只要样本少，谁也帮不了，神仙也救不了，唯一能自救的方法就是重采样一下。适当的生成出一些新的训练集，但生成的东西并不一定能代表客观规律，这是没办法的事儿，确实少，也只能试一试。&lt;strong&gt;所以可以通过对少的样本进行重采样，通过对多的样本进行降采样，来一定程度上缓和我们样本不均衡的问题。&lt;/strong&gt;除此之外&lt;strong&gt;，使用决策树的方法。那么它对于样本不均衡，要比逻辑回归要坚固的多&lt;/strong&gt;，鲁棒性要好得多，所以换句话说，需要选择其它的算法来解决这个问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;除此之外，我们引入一种叫softmax的方式，它比OVR对样本不均衡的问题要稍好一些，而且它的分类效果更好。它其实就是一个跟逻辑回归类似的一个专门解决多分类的模型，它有自己的判别函数，也有自己的损失函数，是逻辑回归的一种拓展，&lt;strong&gt;逻辑回归是softmax的一种特例。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果现在只让用一个模型去判断一个5分类任务，这个模型要输出什么？至少得输出5个概率出来，才能判断。只输出两个概率，我怎么判断剩下3个？输出形式一定要出现5个概率。于是它特别简单，它就搞出了5组w，其实就有点神经网络的感觉了。神经网络我们还没讲，不过没关系，你先有个大体的概念。以后我们再会对神经网络里面softmax函数详细解释，因为它很重要。几乎可以说是任何多分类问题最后的一步。&lt;strong&gt;我们这里就直到softmax就是一个单层的神经网络就可以了，以下关于神经网络解释softmax的问题听不懂没关系，后面在神经网络里面会详细说的。&lt;/strong&gt;咱们说五分类，5组模型，W1，W2，W3，W4，W5，现在一个x扔进来之后，要同时交给每组W算出一个结果，得到了W1^Tx，W2^Tx，W3^Tx，W4^Tx，W5^Tx，接下来把得到的每一个结果概率化输出，为:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                                                &lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?%5Cfrac%7Be%5E%7Bw_%7B1%7D%5E%7BT%7Dx%7D%7D%7B%5Csum%20e%5E%7Bw_%7Bi%7D%5E%7BT%7Dx%7D%7D&quot; alt=&quot;\frac{e^{w_{1}^{T}x}}{\sum e^{w_{i}^{T}x}}&quot; data-cke-saved-src=&quot;https://private.codecogs.com/gif.latex?%5Cfrac%7Be%5E%7Bw_%7B1%7D%5E%7BT%7Dx%7D%7D%7B%5Csum%20e%5E%7Bw_%7Bi%7D%5E%7BT%7Dx%7D%7D&quot; data-cke-widget-data=&quot;{}&quot; data-cke-widget-upcasted=&quot;1&quot;/&gt;，&lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?%5Cfrac%7Be%5E%7Bw_%7B2%7D%5E%7BT%7Dx%7D%7D%7B%5Csum%20e%5E%7Bw_%7Bi%7D%5E%7BT%7Dx%7D%7D&quot; alt=&quot;\frac{e^{w_{2}^{T}x}}{\sum e^{w_{i}^{T}x}}&quot; data-cke-saved-src=&quot;https://private.codecogs.com/gif.latex?%5Cfrac%7Be%5E%7Bw_%7B2%7D%5E%7BT%7Dx%7D%7D%7B%5Csum%20e%5E%7Bw_%7Bi%7D%5E%7BT%7Dx%7D%7D&quot; data-cke-widget-data=&quot;{}&quot; data-cke-widget-upcasted=&quot;1&quot;/&gt;，&lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?%5Cfrac%7Be%5E%7Bw_%7B3%7D%5E%7BT%7Dx%7D%7D%7B%5Csum%20e%5E%7Bw_%7Bi%7D%5E%7BT%7Dx%7D%7D&quot; alt=&quot;\frac{e^{w_{3}^{T}x}}{\sum e^{w_{i}^{T}x}}&quot; data-cke-saved-src=&quot;https://private.codecogs.com/gif.latex?%5Cfrac%7Be%5E%7Bw_%7B3%7D%5E%7BT%7Dx%7D%7D%7B%5Csum%20e%5E%7Bw_%7Bi%7D%5E%7BT%7Dx%7D%7D&quot; data-cke-widget-data=&quot;{}&quot; data-cke-widget-upcasted=&quot;1&quot;/&gt;，&lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?%5Cfrac%7Be%5E%7Bw_%7B4%7D%5E%7BT%7Dx%7D%7D%7B%5Csum%20e%5E%7Bw_%7Bi%7D%5E%7BT%7Dx%7D%7D&quot; alt=&quot;\frac{e^{w_{4}^{T}x}}{\sum e^{w_{i}^{T}x}}&quot; data-cke-saved-src=&quot;https://private.codecogs.com/gif.latex?%5Cfrac%7Be%5E%7Bw_%7B4%7D%5E%7BT%7Dx%7D%7D%7B%5Csum%20e%5E%7Bw_%7Bi%7D%5E%7BT%7Dx%7D%7D&quot; data-cke-widget-data=&quot;{}&quot; data-cke-widget-upcasted=&quot;1&quot;/&gt;，&lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?%5Cfrac%7Be%5E%7Bw_%7B5%7D%5E%7BT%7Dx%7D%7D%7B%5Csum%20e%5E%7Bw_%7Bi%7D%5E%7BT%7Dx%7D%7D&quot; alt=&quot;\frac{e^{w_{5}^{T}x}}{\sum e^{w_{i}^{T}x}}&quot; data-cke-saved-src=&quot;https://private.codecogs.com/gif.latex?%5Cfrac%7Be%5E%7Bw_%7B5%7D%5E%7BT%7Dx%7D%7D%7B%5Csum%20e%5E%7Bw_%7Bi%7D%5E%7BT%7Dx%7D%7D&quot; data-cke-widget-data=&quot;{}&quot; data-cke-widget-upcasted=&quot;1&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在 softmax回归中，我们解决的是多分类问题（相对于 logistic 回归解决的二分类问题),类标y可以取k个不同的值（而不是两个）因此，对于训练集&lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?%5Cleft%5C%7B%5Cleft%28x%5E%7B%281%29%7D%2C%20y%5E%7B%281%29%7D%5Cright%29%2C%20%5Cldots%2C%5Cleft%28x%5E%7B%28m%29%7D%2C%20y%5E%7B%28m%29%7D%5Cright%29%5Cright%5C%7D&quot; alt=&quot;\left\{\left(x^{(1)}, y^{(1)}\right), \ldots,\left(x^{(m)}, y^{(m)}\right)\right\}&quot; data-cke-saved-src=&quot;https://private.codecogs.com/gif.latex?%5Cleft%5C%7B%5Cleft%28x%5E%7B%281%29%7D%2C%20y%5E%7B%281%29%7D%5Cright%29%2C%20%5Cldots%2C%5Cleft%28x%5E%7B%28m%29%7D%2C%20y%5E%7B%28m%29%7D%5Cright%29%5Cright%5C%7D&quot; data-cke-widget-data=&quot;{}&quot; data-cke-widget-upcasted=&quot;1&quot;/&gt;，我们有&lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?%24y%5E%7B%28i%29%7D%20%5Cin%5C%7B1%2C2%2C%20%5Cldots%2C%20k%5C%7D%24&quot; alt=&quot;$y^{(i)} \in\{1,2, \ldots, k\}$&quot; data-cke-saved-src=&quot;https://private.codecogs.com/gif.latex?%24y%5E%7B%28i%29%7D%20%5Cin%5C%7B1%2C2%2C%20%5Cldots%2C%20k%5C%7D%24&quot; data-cke-widget-data=&quot;{}&quot; data-cke-widget-upcasted=&quot;1&quot;/&gt;，（注意此处的类别下标从 1 开始，而不是 0）。对于给定的测试输入x，我们想用假设函数针对每一个类别j估算出概率值p(y=j|x),也就是说&lt;strong&gt;，我们想估计x的每一种分类结果出现的概率。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因此，我们的假设函数将要输出一个k维(k个类别)的向量来表示这k个估计的概率值。具体地说，我们的假设函数h(θ）形式如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                             &lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?h_%7B%5Ctheta%7D%5Cleft%28x%5E%7B%28i%29%7D%5Cright%29%3D%5Cleft%5B%20%5Cbegin%7Barray%7D%7Bc%7D%7Bp%5Cleft%28y%5E%7B%28i%29%7D%3D1%20%7C%20x%5E%7B%28i%29%7D%20%3B%20%5Ctheta%5Cright%29%7D%20%5C%5C%20%7Bp%5Cleft%28y%5E%7B%28i%29%7D%3D2%20%7C%20x%5E%7B%28i%29%7D%20%3B%20%5Ctheta%5Cright%29%7D%20%5C%5C%20%7B%5Cvdots%7D%20%5C%5C%20%7Bp%5Cleft%28y%5E%7B%28i%29%7D%3Dk%20%7C%20x%5E%7B%28i%29%7D%20%3B%20%5Ctheta%5Cright%29%7D%5Cend%7Barray%7D%5Cright%5D%3D%5Cfrac%7B1%7D%7B%5Csum_%7Bj%3D1%7D%5E%7Bk%7D%20e%5E%7B%5Ctheta_%7Bj%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%20%5Cleft%5B%20%5Cbegin%7Barray%7D%7Bc%7D%7Be%5E%7B%5Ctheta_%7B1%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%20%5C%5C%20%7Be%5E%7B%5Ctheta_%7B2%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%20%5C%5C%20%7B%5Cvdots%7D%20%5C%5C%20%7Be%5E%7B%5Ctheta_%7Bk%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%5Cend%7Barray%7D%5Cright%5D&quot; alt=&quot;h_{\theta}\left(x^{(i)}\right)=\left[ \begin{array}{c}{p\left(y^{(i)}=1 | x^{(i)} ; \theta\right)} \\ {p\left(y^{(i)}=2 | x^{(i)} ; \theta\right)} \\ {\vdots} \\ {p\left(y^{(i)}=k | x^{(i)} ; \theta\right)}\end{array}\right]=\frac{1}{\sum_{j=1}^{k} e^{\theta_{j}^{T} x^{(i)}}} \left[ \begin{array}{c}{e^{\theta_{1}^{T} x^{(i)}}} \\ {e^{\theta_{2}^{T} x^{(i)}}} \\ {\vdots} \\ {e^{\theta_{k}^{T} x^{(i)}}}\end{array}\right]&quot; data-cke-saved-src=&quot;https://private.codecogs.com/gif.latex?h_%7B%5Ctheta%7D%5Cleft%28x%5E%7B%28i%29%7D%5Cright%29%3D%5Cleft%5B%20%5Cbegin%7Barray%7D%7Bc%7D%7Bp%5Cleft%28y%5E%7B%28i%29%7D%3D1%20%7C%20x%5E%7B%28i%29%7D%20%3B%20%5Ctheta%5Cright%29%7D%20%5C%5C%20%7Bp%5Cleft%28y%5E%7B%28i%29%7D%3D2%20%7C%20x%5E%7B%28i%29%7D%20%3B%20%5Ctheta%5Cright%29%7D%20%5C%5C%20%7B%5Cvdots%7D%20%5C%5C%20%7Bp%5Cleft%28y%5E%7B%28i%29%7D%3Dk%20%7C%20x%5E%7B%28i%29%7D%20%3B%20%5Ctheta%5Cright%29%7D%5Cend%7Barray%7D%5Cright%5D%3D%5Cfrac%7B1%7D%7B%5Csum_%7Bj%3D1%7D%5E%7Bk%7D%20e%5E%7B%5Ctheta_%7Bj%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%20%5Cleft%5B%20%5Cbegin%7Barray%7D%7Bc%7D%7Be%5E%7B%5Ctheta_%7B1%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%20%5C%5C%20%7Be%5E%7B%5Ctheta_%7B2%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%20%5C%5C%20%7B%5Cvdots%7D%20%5C%5C%20%7Be%5E%7B%5Ctheta_%7Bk%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%5Cend%7Barray%7D%5Cright%5D&quot; data-cke-widget-data=&quot;{}&quot; data-cke-widget-upcasted=&quot;1&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中&lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?%24%5Ctheta_%7B1%7D%2C%20%5Ctheta_%7B2%7D%2C%20%5Cldots%2C%20%5Ctheta_%7Bk%7D%20%5Cin%20%5Cmathrm%7BR%7D%20%5Cmathfrak%7Be%7D%5E%7Bn&amp;amp;plus;1%7D%24&quot; alt=&quot;$\theta_{1}, \theta_{2}, \ldots, \theta_{k} \in \mathrm{R} \mathfrak{e}^{n+1}$&quot; data-cke-saved-src=&quot;https://private.codecogs.com/gif.latex?%24%5Ctheta_%7B1%7D%2C%20%5Ctheta_%7B2%7D%2C%20%5Cldots%2C%20%5Ctheta_%7Bk%7D%20%5Cin%20%5Cmathrm%7BR%7D%20%5Cmathfrak%7Be%7D%5E%7Bn&amp;amp;plus;1%7D%24&quot; data-cke-widget-data=&quot;{}&quot; data-cke-widget-upcasted=&quot;1&quot;/&gt;是模型的参数，&lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?%5Cfrac%7B1%7D%7B%5Csum_%7Bj%3D1%7D%5E%7Bk%7D%20e%5E%7B%5Ctheta_%7Bj%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D&quot; alt=&quot;\frac{1}{\sum_{j=1}^{k} e^{\theta_{j}^{T} x^{(i)}}}&quot; data-cke-saved-src=&quot;https://private.codecogs.com/gif.latex?%5Cfrac%7B1%7D%7B%5Csum_%7Bj%3D1%7D%5E%7Bk%7D%20e%5E%7B%5Ctheta_%7Bj%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D&quot; data-cke-widget-data=&quot;{}&quot; data-cke-widget-upcasted=&quot;1&quot;/&gt;这一项对概率分布进行归一化，使得所有概率之和为 1。实际上就是把一个x(i)丢在一个hθ里面要输出一组概率，比如这个例子里面要输出5个概率，每个概率实际上它的判别函数都是它们共用同一个分母，只不过分子部分不同，第一个概率就是第一组w算出来分数扔到e的上面得出来的结果，每一个都是每一组w对于同一个x(i)的运算结果，分母又是所有分子的加和，因此它们总体的加和一定是等于1的。&lt;strong&gt;这个就是softmax的判别函数。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了方便起见，我们同样使用符号θ来表示全部的模型参数，将θ用一个k*n的矩阵来表示，k个类别，n个属性值，每一类这这些属性上面都对应着一组参数。该矩阵是将每组&lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?%24%5Ctheta_%7B1%7D%2C%20%5Ctheta_%7B2%7D%2C%20%5Cldots%2C%20%5Ctheta_%7Bk%7D%24&quot; alt=&quot;$\theta_{1}, \theta_{2}, \ldots, \theta_{k}$&quot; data-cke-saved-src=&quot;https://private.codecogs.com/gif.latex?%24%5Ctheta_%7B1%7D%2C%20%5Ctheta_%7B2%7D%2C%20%5Cldots%2C%20%5Ctheta_%7Bk%7D%24&quot; data-cke-widget-data=&quot;{}&quot; data-cke-widget-upcasted=&quot;1&quot;/&gt;按照行罗列起来得到的。如下所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                                                                       &lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?%5Ctheta%3D%5Cleft%5B%20%5Cbegin%7Barray%7D%7Bc%7D%7B-%5Ctheta_%7B1%7D%5E%7BT%7D-%7D%20%5C%5C%20%7B-%5Ctheta_%7B2%7D%5E%7BT%7D-%7D%20%5C%5C%20%7B%5Cvdots%7D%20%5C%5C%20%7B-%5Ctheta_%7Bk%7D%5E%7BT%7D-%7D%5Cend%7Barray%7D%5Cright%5D&quot; alt=&quot;\theta=\left[ \begin{array}{c}{-\theta_{1}^{T}-} \\ {-\theta_{2}^{T}-} \\ {\vdots} \\ {-\theta_{k}^{T}-}\end{array}\right]&quot; data-cke-saved-src=&quot;https://private.codecogs.com/gif.latex?%5Ctheta%3D%5Cleft%5B%20%5Cbegin%7Barray%7D%7Bc%7D%7B-%5Ctheta_%7B1%7D%5E%7BT%7D-%7D%20%5C%5C%20%7B-%5Ctheta_%7B2%7D%5E%7BT%7D-%7D%20%5C%5C%20%7B%5Cvdots%7D%20%5C%5C%20%7B-%5Ctheta_%7Bk%7D%5E%7BT%7D-%7D%5Cend%7Barray%7D%5Cright%5D&quot; data-cke-widget-data=&quot;{}&quot; data-cke-widget-upcasted=&quot;1&quot;/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;有了这一组θ，我们的h(x)就可以使用了，那&lt;strong&gt;怎么得到最好的一组θ？还是通过最大似然来推导损失函数。&lt;/strong&gt;我们先来看下示性函数的表示就是1，其取值规则为：1{值为真的表达式}=1，1{值为假的表达式} =0。举例来说，表达式：1{2+2=4}的值为1 ，因为2+2=4是正确的值为真，所以1{2+2=4}的值为1。同理， 1{2+2=5}的值为 0。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;回顾下逻辑回归的损失函数：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                                                &lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?%24-%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%5Cleft%28y%5E%7B%28i%29%7D%20%5Clog%20h_%7B%5Ctheta%7D%5Cleft%28x%5E%7B%28i%29%7D%5Cright%29&amp;amp;plus;%5Cleft%281-y%5E%7B%28i%29%7D%5Cright%29%20%5Clog%20%5Cleft%281-h_%7B%5Ctheta%7D%5Cleft%28x%5E%7B%28i%29%7D%5Cright%29%5Cright%29%5Cright%29%24&quot; alt=&quot;$-\sum_{i=1}^{m}\left(y^{(i)} \log h_{\theta}\left(x^{(i)}\right)+\left(1-y^{(i)}\right) \log \left(1-h_{\theta}\left(x^{(i)}\right)\right)\right)$&quot; data-cke-saved-src=&quot;https://private.codecogs.com/gif.latex?%24-%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%5Cleft%28y%5E%7B%28i%29%7D%20%5Clog%20h_%7B%5Ctheta%7D%5Cleft%28x%5E%7B%28i%29%7D%5Cright%29&amp;amp;plus;%5Cleft%281-y%5E%7B%28i%29%7D%5Cright%29%20%5Clog%20%5Cleft%281-h_%7B%5Ctheta%7D%5Cleft%28x%5E%7B%28i%29%7D%5Cright%29%5Cright%29%5Cright%29%24&quot; data-cke-widget-data=&quot;{}&quot; data-cke-widget-upcasted=&quot;1&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个函数中，虽然每一项加和的部分是两部分yi*log h（x）+(1-yi)*log (1-h（x）)组成，但是因为yi不是0就是1，前面在后面就没了，后面在前面就没了，所以对每一条样本来说就只能存活下来一项，这个是针对二分类来说的。把其写成示性函数的表达就是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                                                &lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?-%24%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20%5Csum_%7Bj%3D0%7D%5E%7B1%7D%201%5Cleft%5C%7By%5E%7B%28i%29%7D%3Dj%5Cright%5C%7D%20%5Clog%20p%5Cleft%28y%5E%7B%28i%29%7D%3Dj%20%7C%20x%5E%7B%28i%29%7D%20%3B%20%5Ctheta%5Cright%29%24&quot; alt=&quot;-$\sum_{i=1}^{m} \sum_{j=0}^{1} 1\left\{y^{(i)}=j\right\} \log p\left(y^{(i)}=j | x^{(i)} ; \theta\right)$&quot; data-cke-saved-src=&quot;https://private.codecogs.com/gif.latex?-%24%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20%5Csum_%7Bj%3D0%7D%5E%7B1%7D%201%5Cleft%5C%7By%5E%7B%28i%29%7D%3Dj%5Cright%5C%7D%20%5Clog%20p%5Cleft%28y%5E%7B%28i%29%7D%3Dj%20%7C%20x%5E%7B%28i%29%7D%20%3B%20%5Ctheta%5Cright%29%24&quot; data-cke-widget-data=&quot;{}&quot; data-cke-widget-upcasted=&quot;1&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解释下：比如一条样本标签真实值yi是0，根据我们上面的描述yi*log h（x）+(1-yi)*log (1-h（x）)这里面只能存在一项就是后面一项。而对于示性函数来说&lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?%24%5Csum_%7Bj%3D0%7D%5E%7B1%7D%201%5Cleft%5C%7By%5E%7B%28i%29%7D%3Dj%5Cright%5C%7D%20%5Clog%20p%5Cleft%28y%5E%7B%28i%29%7D%3Dj%20%7C%20x%5E%7B%28i%29%7D%20%3B%20%5Ctheta%5Cright%29%24&quot; alt=&quot;$\sum_{j=0}^{1} 1\left\{y^{(i)}=j\right\} \log p\left(y^{(i)}=j | x^{(i)} ; \theta\right)$&quot; data-cke-saved-src=&quot;https://private.codecogs.com/gif.latex?%24%5Csum_%7Bj%3D0%7D%5E%7B1%7D%201%5Cleft%5C%7By%5E%7B%28i%29%7D%3Dj%5Cright%5C%7D%20%5Clog%20p%5Cleft%28y%5E%7B%28i%29%7D%3Dj%20%7C%20x%5E%7B%28i%29%7D%20%3B%20%5Ctheta%5Cright%29%24&quot; data-cke-widget-data=&quot;{}&quot; data-cke-widget-upcasted=&quot;1&quot;/&gt;这个里面j是累加到1，两个取值，j先为0的时候，yi=j=0为真。1{值为真的表达式}=1，所以当j为0的时候值保留下来，当j为1的时候yi=j=1≠0，1{值为假的表达式} =0，所以当j为1的时候值没有累加。因此真正每一条样本计算的就是其对应真实y的时候那一部分概率值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而对于多分类来说我们需要像推导逻辑回归损失函数一样，把每一条样本预测正确的概率连乘，使得似然最大。那多分类的每一条样本预测正确的概率就是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                                                      &lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?%5Csum_%7Bj%3D1%7D%5E%7Bk%7D%201%5Cleft%5C%7By%5E%7B%28i%29%7D%3Dj%5Cright%5C%7D%20%5Clog%20%5Cfrac%7Be%5E%7B%5Ctheta_%7Bj%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%7B%5Csum_%7Bl%3D1%7D%5E%7Bk%7D%20e%5E%7B%5Ctheta_%7Bl%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D&quot; alt=&quot;\sum_{j=1}^{k} 1\left\{y^{(i)}=j\right\} \log \frac{e^{\theta_{j}^{T} x^{(i)}}}{\sum_{l=1}^{k} e^{\theta_{l}^{T} x^{(i)}}}&quot; data-cke-saved-src=&quot;https://private.codecogs.com/gif.latex?%5Csum_%7Bj%3D1%7D%5E%7Bk%7D%201%5Cleft%5C%7By%5E%7B%28i%29%7D%3Dj%5Cright%5C%7D%20%5Clog%20%5Cfrac%7Be%5E%7B%5Ctheta_%7Bj%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%7B%5Csum_%7Bl%3D1%7D%5E%7Bk%7D%20e%5E%7B%5Ctheta_%7Bl%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D&quot; data-cke-widget-data=&quot;{}&quot; data-cke-widget-upcasted=&quot;1&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在Softmax回归中将x分类为类别j的概率为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                                            &lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?h%28%5Ctheta%29x%3Dp%5Cleft%28y%5E%7B%28i%29%7D%3Dj%20%7C%20x%5E%7B%28i%29%7D%20%3B%20%5Ctheta%5Cright%29%3D%5Cfrac%7Be%5E%7B%5Ctheta_%7Bj%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%7B%5Csum_%7Bl%3D1%7D%5E%7Bk%7D%20e%5E%7B%5Ctheta_%7Bl%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D&quot; alt=&quot;h(\theta)x=p\left(y^{(i)}=j | x^{(i)} ; \theta\right)=\frac{e^{\theta_{j}^{T} x^{(i)}}}{\sum_{l=1}^{k} e^{\theta_{l}^{T} x^{(i)}}}&quot; data-cke-saved-src=&quot;https://private.codecogs.com/gif.latex?h%28%5Ctheta%29x%3Dp%5Cleft%28y%5E%7B%28i%29%7D%3Dj%20%7C%20x%5E%7B%28i%29%7D%20%3B%20%5Ctheta%5Cright%29%3D%5Cfrac%7Be%5E%7B%5Ctheta_%7Bj%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%7B%5Csum_%7Bl%3D1%7D%5E%7Bk%7D%20e%5E%7B%5Ctheta_%7Bl%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D&quot; data-cke-widget-data=&quot;{}&quot; data-cke-widget-upcasted=&quot;1&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;举例来说，假如是3分类，这个预测就输出3个概率，也就是3个数，对每一条样本来说，其中第一个概率代表是我预测它最后类别是1的概率，第二个是代表我预测它类别为2的概率，第三个就是我预测它类别为3的概率，它实际的类别假如为1的话，我预测对了的概率是第一个数，第二个数还是第三个数？应该是第一个数。&lt;strong&gt;就从里边挑出应该预测正确的概率放在这，这就是它正确的概率，&lt;/strong&gt;因为对每一个样本来说yi只能取一个值，所以里面的加和也只会存活下来一项。每一条样本yi等于多少其对应的hθ(x)的值就留下来。比如第一个样本真实分类是0，那就保留&lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?%5Cfrac%7Be%5E%7B%5Ctheta_%7B0%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%7B%5Csum_%7Bl%3D1%7D%5E%7Bk%7D%20e%5E%7B%5Ctheta_%7Bl%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D&quot; alt=&quot;\frac{e^{\theta_{0}^{T} x^{(i)}}}{\sum_{l=1}^{k} e^{\theta_{l}^{T} x^{(i)}}}&quot; data-cke-saved-src=&quot;https://private.codecogs.com/gif.latex?%5Cfrac%7Be%5E%7B%5Ctheta_%7B0%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%7B%5Csum_%7Bl%3D1%7D%5E%7Bk%7D%20e%5E%7B%5Ctheta_%7Bl%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D&quot; data-cke-widget-data=&quot;{}&quot; data-cke-widget-upcasted=&quot;1&quot;/&gt;这一部分，第二个真实样本类别是1 ，那就保留&lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?%5Cfrac%7Be%5E%7B%5Ctheta_%7B1%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%7B%5Csum_%7Bl%3D1%7D%5E%7Bk%7D%20e%5E%7B%5Ctheta_%7Bl%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D&quot; alt=&quot;\frac{e^{\theta_{1}^{T} x^{(i)}}}{\sum_{l=1}^{k} e^{\theta_{l}^{T} x^{(i)}}}&quot; data-cke-saved-src=&quot;https://private.codecogs.com/gif.latex?%5Cfrac%7Be%5E%7B%5Ctheta_%7B1%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%7B%5Csum_%7Bl%3D1%7D%5E%7Bk%7D%20e%5E%7B%5Ctheta_%7Bl%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D&quot; data-cke-widget-data=&quot;{}&quot; data-cke-widget-upcasted=&quot;1&quot;/&gt;这一部分，第三个真实样本分类是2，那就保留&lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?%5Cfrac%7Be%5E%7B%5Ctheta_%7B2%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%7B%5Csum_%7Bl%3D1%7D%5E%7Bk%7D%20e%5E%7B%5Ctheta_%7Bl%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D&quot; alt=&quot;\frac{e^{\theta_{2}^{T} x^{(i)}}}{\sum_{l=1}^{k} e^{\theta_{l}^{T} x^{(i)}}}&quot; data-cke-saved-src=&quot;https://private.codecogs.com/gif.latex?%5Cfrac%7Be%5E%7B%5Ctheta_%7B2%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%7B%5Csum_%7Bl%3D1%7D%5E%7Bk%7D%20e%5E%7B%5Ctheta_%7Bl%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D&quot; data-cke-widget-data=&quot;{}&quot; data-cke-widget-upcasted=&quot;1&quot;/&gt;这一部分，损失函数只取决于预测对的那一项的概率，其它的概率其实损失函数角度是不关心的。所以它尽量，想让训练集上全部预测的总正确率最大，就需要把每条数据被预测正确的概率给连乘起来，求最大似然，加个log，连乘变连加，然后加个负号就得到这个损失函数了。最后推导出来的&lt;strong&gt;softmax损失函数如下：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                                                       &lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?J%28%5Ctheta%29%3D-%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20%5Csum_%7Bj%3D1%7D%5E%7Bk%7D%201%5Cleft%5C%7By%5E%7B%28i%29%7D%3Dj%5Cright%5C%7D%20%5Clog%20%5Cfrac%7Be%5E%7B%5Ctheta_%7Bj%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%7B%5Csum_%7Bl%3D1%7D%5E%7Bk%7D%20e%5E%7B%5Ctheta_%7Bl%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D&quot; alt=&quot;J(\theta)=-\sum_{i=1}^{m} \sum_{j=1}^{k} 1\left\{y^{(i)}=j\right\} \log \frac{e^{\theta_{j}^{T} x^{(i)}}}{\sum_{l=1}^{k} e^{\theta_{l}^{T} x^{(i)}}}&quot; data-cke-saved-src=&quot;https://private.codecogs.com/gif.latex?J%28%5Ctheta%29%3D-%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20%5Csum_%7Bj%3D1%7D%5E%7Bk%7D%201%5Cleft%5C%7By%5E%7B%28i%29%7D%3Dj%5Cright%5C%7D%20%5Clog%20%5Cfrac%7Be%5E%7B%5Ctheta_%7Bj%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%7B%5Csum_%7Bl%3D1%7D%5E%7Bk%7D%20e%5E%7B%5Ctheta_%7Bl%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D&quot; data-cke-widget-data=&quot;{}&quot; data-cke-widget-upcasted=&quot;1&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;可以看到，Softmax代价函数与logistic 代价函数在形式上非常类似，只是Softmax损失函数中对类标记的k个可能值进行了累加。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于J(θ)的最小化问题，当前还没有闭式解法。因此，我们使用迭代的优化算法（例如梯度下降法，或 L-BFGS）。经过求导，我们得到梯度公式如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                                            &lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?%5Cnabla_%7B%5Ctheta_%7Bj%7D%7D%20J%28%5Ctheta%29%3D-%5Cfrac%7B1%7D%7Bm%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%5Cleft%5Bx%5E%7B%28i%29%7D%5Cleft%281%5Cleft%5C%7By%5E%7B%28i%29%7D%3Dj%5Cright%5C%7D-p%5Cleft%28y%5E%7B%28i%29%7D%3Dj%20%7C%20x%5E%7B%28i%29%7D%20%3B%20%5Ctheta%5Cright%29%5Cright%29%5Cright%5D&quot; alt=&quot;\nabla_{\theta_{j}} J(\theta)=-\frac{1}{m} \sum_{i=1}^{m}\left[x^{(i)}\left(1\left\{y^{(i)}=j\right\}-p\left(y^{(i)}=j | x^{(i)} ; \theta\right)\right)\right]&quot; data-cke-saved-src=&quot;https://private.codecogs.com/gif.latex?%5Cnabla_%7B%5Ctheta_%7Bj%7D%7D%20J%28%5Ctheta%29%3D-%5Cfrac%7B1%7D%7Bm%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%5Cleft%5Bx%5E%7B%28i%29%7D%5Cleft%281%5Cleft%5C%7By%5E%7B%28i%29%7D%3Dj%5Cright%5C%7D-p%5Cleft%28y%5E%7B%28i%29%7D%3Dj%20%7C%20x%5E%7B%28i%29%7D%20%3B%20%5Ctheta%5Cright%29%5Cright%29%5Cright%5D&quot; data-cke-widget-data=&quot;{}&quot; data-cke-widget-upcasted=&quot;1&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有了上面的偏导数公式以后，我们就可以将它代入到梯度下降法等算法中，来最小化J(θ)。例如，在梯度下降法的标准实现中，每一次迭代需要进行如下更新：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                                                            &lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?%24%5Ctheta_%7Bj%7D%20%3A%3D%5Ctheta_%7Bj%7D-%5Calpha%20%5Cnabla_%7B%5Ctheta_%7Bj%7D%7D%20J%28%5Ctheta%29%28j%3D1%2C%20%5Cldots%2C%20k%29%24&quot; alt=&quot;$\theta_{j} :=\theta_{j}-\alpha \nabla_{\theta_{j}} J(\theta)(j=1, \ldots, k)$&quot; data-cke-saved-src=&quot;https://private.codecogs.com/gif.latex?%24%5Ctheta_%7Bj%7D%20%3A%3D%5Ctheta_%7Bj%7D-%5Calpha%20%5Cnabla_%7B%5Ctheta_%7Bj%7D%7D%20J%28%5Ctheta%29%28j%3D1%2C%20%5Cldots%2C%20k%29%24&quot; data-cke-widget-data=&quot;{}&quot; data-cke-widget-upcasted=&quot;1&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;得到一组θ使得模型表现最好。此时得到θ就是softmax训练出来的结果。所以不管它是什么损失函数，你总可以交给sgd或者l-bfgs进行最小化，得到一组θ使得模型表现最好。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;对于softmax，你它的本质是把好几个逻辑回归塞到一起去了，但是它判别函数又变了变，原来是1/{1+exp(-z)}，现在变成了e的z求和，有多少个z就求和多少次，加起来之后当分母，然后分子为对应部分预测的概率，这样它们输出的每个概率就都进行了归一化。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;softmax有一个有趣的特点：&lt;/strong&gt;softmax的形式是有几个分类，就有几组w向量，比如三类，最终训练出来的参数实际上就是θ1，θ2，θ3，原来逻辑回归是一组θ，现在是三组θ。你把这三组θ都减去一个相同的向量φ，比如φ全是1。 假如这θ长度为五，φ是五个1也好，五个2也好，12345也好，只要把每一个θ的向量都减去同一个φ，你就会发现他们预测结果没有任何变化。假如我拿每一个θ都减去了同一个φ，我把θj-φ当作原来的θj，即：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                                                          &lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?%5Cbegin%7Baligned%7D%20p%5Cleft%28y%5E%7B%28i%29%7D%3Dj%20%7C%20x%5E%7B%28i%29%7D%20%3B%20%5Ctheta%5Cright%29%20%26%3D%5Cfrac%7Be%5E%7B%5Cleft%28%5Ctheta_%7Bj%7D-%5Cpsi%5Cright%29%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%7B%5Csum_%7Bl%3D1%7D%5E%7Bk%7D%20e%5E%7B%5Cleft%28%5Ctheta_%7Bl%7D-%5Cpsi%5Cright%29%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%20%5C%5C%20%26%3D%5Cfrac%7Be%5E%7B%5Ctheta_%7Bj%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%20e%5E%7B-%5Cpsi%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%7D%7B%5Csum_%7Bl%3D1%7D%5E%7Bk%7D%20e%5E%7B%5Ctheta_%7Bl%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%20e%5E%7B-%5Cpsi%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%7D%20%5C%5C%20%26%3D%5Cfrac%7Be%5E%7B%5Ctheta_%7Bl%3D1%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%7B%5Csum_%7Bl%3D1%7D%5E%7Bk%7D%20e%5E%7B%5Ctheta_%7Bl%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%20%5Cend%7Baligned%7D&quot; alt=&quot;\begin{aligned} p\left(y^{(i)}=j | x^{(i)} ; \theta\right) &amp;amp;=\frac{e^{\left(\theta_{j}-\psi\right)^{T} x^{(i)}}}{\sum_{l=1}^{k} e^{\left(\theta_{l}-\psi\right)^{T} x^{(i)}}} \\ &amp;amp;=\frac{e^{\theta_{j}^{T} x^{(i)} e^{-\psi^{T} x^{(i)}}}}{\sum_{l=1}^{k} e^{\theta_{l}^{T} x^{(i)} e^{-\psi^{T} x^{(i)}}}} \\ &amp;amp;=\frac{e^{\theta_{l=1}^{T} x^{(i)}}}{\sum_{l=1}^{k} e^{\theta_{l}^{T} x^{(i)}}} \end{aligned}&quot; data-cke-saved-src=&quot;https://private.codecogs.com/gif.latex?%5Cbegin%7Baligned%7D%20p%5Cleft%28y%5E%7B%28i%29%7D%3Dj%20%7C%20x%5E%7B%28i%29%7D%20%3B%20%5Ctheta%5Cright%29%20%26%3D%5Cfrac%7Be%5E%7B%5Cleft%28%5Ctheta_%7Bj%7D-%5Cpsi%5Cright%29%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%7B%5Csum_%7Bl%3D1%7D%5E%7Bk%7D%20e%5E%7B%5Cleft%28%5Ctheta_%7Bl%7D-%5Cpsi%5Cright%29%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%20%5C%5C%20%26%3D%5Cfrac%7Be%5E%7B%5Ctheta_%7Bj%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%20e%5E%7B-%5Cpsi%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%7D%7B%5Csum_%7Bl%3D1%7D%5E%7Bk%7D%20e%5E%7B%5Ctheta_%7Bl%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%20e%5E%7B-%5Cpsi%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%7D%20%5C%5C%20%26%3D%5Cfrac%7Be%5E%7B%5Ctheta_%7Bl%3D1%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%7B%5Csum_%7Bl%3D1%7D%5E%7Bk%7D%20e%5E%7B%5Ctheta_%7Bl%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%20%5Cend%7Baligned%7D&quot; data-cke-widget-data=&quot;{}&quot; data-cke-widget-upcasted=&quot;1&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过上面公式展开，也就是说减φ与不减φ不影响最终的预测结果。这说明softmax参数有冗余，既然随便减一个φ可以，那我都给他减一个θ1，也可以，那么就是把θ1全变成零了，θ2变成θ2-θ1了，θ3变成θ3-θ1了。所以实际上我们只需要保存两组参数就够了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;我们再来看下Softmax回归与Logistic 回归的关系：&lt;/strong&gt;当类别数k=2时，softmax 回归退化为 logistic 回归。这表明 softmax 回归是 logistic 回归的一般形式。具体地说，当k=2时，softmax 回归的假设函数为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                                                                      &lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?h_%7B%5Ctheta%7D%28x%29%3D%5Cfrac%7B1%7D%7Be%5E%7B%5Ctheta_%7B1%7D%5E%7BT%7D%20x%7D&amp;amp;plus;e%5E%7B%5Ctheta_%7B2%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%20%5Cleft%5B%20%5Cbegin%7Barray%7D%7Bc%7D%7Be%5E%7B%5Ctheta_%7B1%7D%5E%7BT%7D%20x%7D%7D%20%5C%5C%20%7Be%5E%7B%5Ctheta_%7B2%7D%5E%7BT%7D%20x%7D%7D%5Cend%7Barray%7D%5Cright%5D&quot; alt=&quot;h_{\theta}(x)=\frac{1}{e^{\theta_{1}^{T} x}+e^{\theta_{2}^{T} x^{(i)}}} \left[ \begin{array}{c}{e^{\theta_{1}^{T} x}} \\ {e^{\theta_{2}^{T} x}}\end{array}\right]&quot; data-cke-saved-src=&quot;https://private.codecogs.com/gif.latex?h_%7B%5Ctheta%7D%28x%29%3D%5Cfrac%7B1%7D%7Be%5E%7B%5Ctheta_%7B1%7D%5E%7BT%7D%20x%7D&amp;amp;plus;e%5E%7B%5Ctheta_%7B2%7D%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%20%5Cleft%5B%20%5Cbegin%7Barray%7D%7Bc%7D%7Be%5E%7B%5Ctheta_%7B1%7D%5E%7BT%7D%20x%7D%7D%20%5C%5C%20%7Be%5E%7B%5Ctheta_%7B2%7D%5E%7BT%7D%20x%7D%7D%5Cend%7Barray%7D%5Cright%5D&quot; data-cke-widget-data=&quot;{}&quot; data-cke-widget-upcasted=&quot;1&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;利用softmax回归参数冗余的特点，θ1全置为0，θ2变成θ2-θ1：那么h(x)会输出两个结果。即：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                                                                       &lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?h%28x%29%3D%5Cfrac%7B1%7D%7Be%5E%7B%5Coverrightarrow%7B0%7D%5E%7BT%7D%20x%7D&amp;amp;plus;e%5E%7B%5Cleft%28%5Ctheta_%7B2%7D-%5Ctheta_%7B1%7D%5Cright%29%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%20%5Cleft%5B%20%5Cbegin%7Barray%7D%7Bc%7D%7Be%5E%7B%5Coverrightarrow%7B0%7D%5E%7BT%7D%20x%7D%7D%20%5C%5C%20%7Be%5E%7B%5Cleft%28%5Ctheta_%7B2%7D-%5Ctheta_%7B1%7D%5Cright%29%5E%7BT%7D%20x%7D%20%5D%7D%5Cend%7Barray%7D%5Cright%5D&quot; alt=&quot;h(x)=\frac{1}{e^{\overrightarrow{0}^{T} x}+e^{\left(\theta_{2}-\theta_{1}\right)^{T} x^{(i)}}} \left[ \begin{array}{c}{e^{\overrightarrow{0}^{T} x}} \\ {e^{\left(\theta_{2}-\theta_{1}\right)^{T} x} ]}\end{array}\right]&quot; data-cke-saved-src=&quot;https://private.codecogs.com/gif.latex?h%28x%29%3D%5Cfrac%7B1%7D%7Be%5E%7B%5Coverrightarrow%7B0%7D%5E%7BT%7D%20x%7D&amp;amp;plus;e%5E%7B%5Cleft%28%5Ctheta_%7B2%7D-%5Ctheta_%7B1%7D%5Cright%29%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%20%5Cleft%5B%20%5Cbegin%7Barray%7D%7Bc%7D%7Be%5E%7B%5Coverrightarrow%7B0%7D%5E%7BT%7D%20x%7D%7D%20%5C%5C%20%7Be%5E%7B%5Cleft%28%5Ctheta_%7B2%7D-%5Ctheta_%7B1%7D%5Cright%29%5E%7BT%7D%20x%7D%20%5D%7D%5Cend%7Barray%7D%5Cright%5D&quot; data-cke-widget-data=&quot;{}&quot; data-cke-widget-upcasted=&quot;1&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                                                                               &lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?%3D%5Cleft%5B%20%5Cbegin%7Barray%7D%7Bc%7D%7B%5Cfrac%7B1%7D%7B1&amp;amp;plus;e%5E%7B%5Cleft%28%5Ctheta_%7B2%7D-%5Ctheta_%7B1%7D%5Cright%29%5E%7BT%7D%20x%7D%7D%7D%20%5C%5C%20%7B%5Cfrac%7Be%5E%7B%5Cleft%28%5Ctheta_%7B2%7D-%5Ctheta_%7B1%7D%5Cright%29%5E%7BT%7D%20x%7D%7D%7B1&amp;amp;plus;e%5E%7B%5Cleft%28%5Ctheta_%7B2%7D-%5Ctheta_%7B1%7D%5Cright%29%5E%7BT%7D%20x%7D%7D%7D%5Cend%7Barray%7D%5Cright%5D&quot; alt=&quot;=\left[ \begin{array}{c}{\frac{1}{1+e^{\left(\theta_{2}-\theta_{1}\right)^{T} x}}} \\ {\frac{e^{\left(\theta_{2}-\theta_{1}\right)^{T} x}}{1+e^{\left(\theta_{2}-\theta_{1}\right)^{T} x}}}\end{array}\right]&quot; data-cke-saved-src=&quot;https://private.codecogs.com/gif.latex?%3D%5Cleft%5B%20%5Cbegin%7Barray%7D%7Bc%7D%7B%5Cfrac%7B1%7D%7B1&amp;amp;plus;e%5E%7B%5Cleft%28%5Ctheta_%7B2%7D-%5Ctheta_%7B1%7D%5Cright%29%5E%7BT%7D%20x%7D%7D%7D%20%5C%5C%20%7B%5Cfrac%7Be%5E%7B%5Cleft%28%5Ctheta_%7B2%7D-%5Ctheta_%7B1%7D%5Cright%29%5E%7BT%7D%20x%7D%7D%7B1&amp;amp;plus;e%5E%7B%5Cleft%28%5Ctheta_%7B2%7D-%5Ctheta_%7B1%7D%5Cright%29%5E%7BT%7D%20x%7D%7D%7D%5Cend%7Barray%7D%5Cright%5D&quot; data-cke-widget-data=&quot;{}&quot; data-cke-widget-upcasted=&quot;1&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                                                                              &lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?%3D%5Cleft%5B%20%5Cbegin%7Barray%7D%7Bc%7D%7B%5Cfrac%7B1%7D%7B1&amp;amp;plus;e%5E%7B%5Cleft%28%5Ctheta_%7B2%7D-%5Ctheta_%7B1%7D%5Cright%29%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%7D%20%5C%5C%20%7B1-%5Cfrac%7B1%7D%7B1&amp;amp;plus;e%5E%7B%5Cleft%28%5Ctheta_%7B2%7D-%5Ctheta_%7B1%7D%5Cright%29%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%7D%5Cend%7Barray%7D%5Cright%5D&quot; alt=&quot;=\left[ \begin{array}{c}{\frac{1}{1+e^{\left(\theta_{2}-\theta_{1}\right)^{T} x^{(i)}}}} \\ {1-\frac{1}{1+e^{\left(\theta_{2}-\theta_{1}\right)^{T} x^{(i)}}}}\end{array}\right]&quot; data-cke-saved-src=&quot;https://private.codecogs.com/gif.latex?%3D%5Cleft%5B%20%5Cbegin%7Barray%7D%7Bc%7D%7B%5Cfrac%7B1%7D%7B1&amp;amp;plus;e%5E%7B%5Cleft%28%5Ctheta_%7B2%7D-%5Ctheta_%7B1%7D%5Cright%29%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%7D%20%5C%5C%20%7B1-%5Cfrac%7B1%7D%7B1&amp;amp;plus;e%5E%7B%5Cleft%28%5Ctheta_%7B2%7D-%5Ctheta_%7B1%7D%5Cright%29%5E%7BT%7D%20x%5E%7B%28i%29%7D%7D%7D%7D%5Cend%7Barray%7D%5Cright%5D&quot; data-cke-widget-data=&quot;{}&quot; data-cke-widget-upcasted=&quot;1&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们就会发现 softmax 回归器预测其中一个类别的概率为&lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?%5Cfrac%7B1%7D%7B1&amp;amp;plus;e%5E%7B%5Cleft%28%5Ctheta_%7B2%7D-%5Ctheta_%7B1%7D%5Cright%29%5E%7BT%7D%20x%28i%29%7D%7D&quot; alt=&quot;\frac{1}{1+e^{\left(\theta_{2}-\theta_{1}\right)^{T} x(i)}}&quot; data-cke-saved-src=&quot;https://private.codecogs.com/gif.latex?%5Cfrac%7B1%7D%7B1&amp;amp;plus;e%5E%7B%5Cleft%28%5Ctheta_%7B2%7D-%5Ctheta_%7B1%7D%5Cright%29%5E%7BT%7D%20x%28i%29%7D%7D&quot; data-cke-widget-data=&quot;{}&quot; data-cke-widget-upcasted=&quot;1&quot;/&gt;，另一个类别的概率就是&lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?1-%5Cfrac%7B1%7D%7B1&amp;amp;plus;e%5E%7B%5Cleft%28%5Ctheta_%7B2%7D-%5Ctheta_%7B1%7D%5Cright%29%5E%7BT%7D%20x%7D%28i%29%7D&quot; alt=&quot;1-\frac{1}{1+e^{\left(\theta_{2}-\theta_{1}\right)^{T} x}(i)}&quot; data-cke-saved-src=&quot;https://private.codecogs.com/gif.latex?1-%5Cfrac%7B1%7D%7B1&amp;amp;plus;e%5E%7B%5Cleft%28%5Ctheta_%7B2%7D-%5Ctheta_%7B1%7D%5Cright%29%5E%7BT%7D%20x%7D%28i%29%7D&quot; data-cke-widget-data=&quot;{}&quot; data-cke-widget-upcasted=&quot;1&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;此时的softmax回归就是参数为θ2-θ1的逻辑回归&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 01 May 2019 15:33:00 +0000</pubDate>
<dc:creator>LHBlog</dc:creator>
<og:description>大白话5分钟带你走进人工智能-第二十节逻辑回归和Softmax多分类问题(5) 上一节中，我们讲解了逻辑回归的优化，本节的话我们讲解逻辑回归做多分类问题以及传统的多分类问题，我们用什么手段解决。 先看</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/LHWorldBlog/p/10801253.html</dc:identifier>
</item>
<item>
<title>Webpack &amp; The Hot Module Replacement热模块替换原理解析 - 宇的季节</title>
<link>http://www.cnblogs.com/chenkeyu/p/10801197.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenkeyu/p/10801197.html</guid>
<description>&lt;p class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;The Hot Module Replacement(HMR)俗称热模块替换。主要用来当代码产生变化后，可以在不刷新游览器的情况下对局部代码块进行替换更新。这在很多情况下都很有用，例如在处理弹出框时，使用HMR可以及时的看到变化，如果用刷新游览器的方式会回到初始页面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;很多人使用过HMR却不知道它是如何工作的，这里会对HMR实现原理进行解析。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;关于HMR需要知道的一些事&lt;/span&gt;&lt;/h2&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;2&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;HMR是Webpack的一个可选功能，如果想使用需要主动打开。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;需要通过webpack-dev-server方式来管理webpack（另一种方式是CLI）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;HMR只能工作在实现了HMR API的loaders里，例如：‘style-loader’,'react-hot-loader'&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;HMR只能在开发环境中使用，因为HMR会在打包的js中添加了很多额外的代码，并且webpack-dev-server也只用于开发环境。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;HMR工作原理&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;webpack会在打包的js中注入很多js库来让HMR工作，下图展示了当一个文件发生变化是HMR是如何工作的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;图片颜色说明：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;紫色：发生改变的js或者css文件&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;橘色：发生变化的代码块说明，变化后的代码块内容&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;彩兰色：项目代码&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;绿色：webpack-dev-server相关的库，有图中可以发现，webpack-dev-server主要负责server端和游览器端的通信。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;蓝色：webpack核心和插件库，由图中可以发现，server端代码的监听以及游览器端新代码的替换都是由webpack的不同模块处理。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;红色：react-loader或者style-loader等HMR库&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;/home/chenkeyu/Desktop/webpack-HMR/HMR-work.png&quot;&gt;&lt;img src=&quot;file:///home/chenkeyu/Desktop/webpack-HMR/HMR-work.png?lastModify=1556722872&quot; alt=&quot;&quot; data-local-refresh=&quot;true&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1003414/201905/1003414-20190501230730384-714203554.png&quot; alt=&quot;&quot; width=&quot;1224&quot; height=&quot;905&quot;/&gt; &lt;/p&gt;
&lt;h2&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;执行流程：&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;ol class=&quot;ol-list&quot; start=&quot;&quot; readability=&quot;6&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;当监听到文件发生变化时，webpack 使用HotModuleReplacementPlugin生成一个mainifest（一个json结构描述了发生变化的modules列表）和update file（一个js文件包含修改后的代码内容）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;webpack将上述变化信息告诉webpack-dev-server&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;webpack-dev-server通过webSocket给运行在游览器上的‘webpack-dev-server/client’（在打包时注入的js代码）发送一条‘invalide’信息以及更新后代码的hash值（该hash值本次不会用到，使用上一版本的hash值）.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;’webpack-dev-server/client’会将上一版本代码的hash传递给“hot/dev-server”&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;‘hot/dev-server’使用JsonpRuntime向server端发送带有上版本hash的ajax请求，server端返回一个json，该json包含要所有要更新的模块的hash值。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;JsonpRuntime根据返回的json值使用jsonp请求具体的代码块，jsonp返回的js代码类似下面:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;md-fences md-end-block contain-cm modeLoaded&quot;&gt;
&lt;span&gt;&lt;span class=&quot;cm-variable&quot;&gt;webpackHotUpdate(&lt;span class=&quot;cm-number&quot;&gt;0,&lt;br/&gt;&lt;span&gt;{&lt;br/&gt;&lt;span&gt; &lt;span class=&quot;cm-number cm-property&quot;&gt;82:&lt;br/&gt;&lt;span&gt;  &lt;span class=&quot;cm-keyword&quot;&gt;function(&lt;span class=&quot;cm-def&quot;&gt;module, &lt;span class=&quot;cm-def&quot;&gt;exports, &lt;span class=&quot;cm-def&quot;&gt;__webpack_require__) {&lt;br/&gt;&lt;span&gt;    &lt;span class=&quot;cm-variable-2&quot;&gt;exports &lt;span class=&quot;cm-operator&quot;&gt;= &lt;span class=&quot;cm-variable-2&quot;&gt;module.&lt;span class=&quot;cm-property&quot;&gt;exports &lt;span class=&quot;cm-operator&quot;&gt;= &lt;span class=&quot;cm-variable-2&quot;&gt;__webpack_require__(&lt;span class=&quot;cm-number&quot;&gt;79)();&lt;br/&gt;&lt;span&gt;    &lt;span class=&quot;cm-variable-2&quot;&gt;exports.&lt;span class=&quot;cm-property&quot;&gt;push([&lt;span class=&quot;cm-variable-2&quot;&gt;module.&lt;span class=&quot;cm-property&quot;&gt;id, &lt;span class=&quot;cm-variable&quot;&gt;“input {\&lt;span class=&quot;cm-variable&quot;&gt;n &lt;span class=&quot;cm-variable&quot;&gt;background: &lt;span class=&quot;cm-variable&quot;&gt;pink;\&lt;span class=&quot;cm-variable&quot;&gt;n}&lt;span class=&quot;cm-variable&quot;&gt;”, &lt;span class=&quot;cm-variable&quot;&gt;“”])&lt;br/&gt;&lt;span&gt;  }&lt;br/&gt;&lt;span&gt;})&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;ol class=&quot;ol-list&quot; start=&quot;7&quot; readability=&quot;0.5&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;代码会调用webpackHotUpdate方法并携带module_id和具体修改内容。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;HMR runtime本身并不会处理代码修改，它会将不同文件交给对应的loader runtime处理（例如：react-hot-loader runtime 或者 style-loader runtime）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;如果更新失败，会回退刷新游览器获取最新代码。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;示例&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;当游览器首次加载app时，server端会推送当前代码版本号current_hash。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1003414/201905/1003414-20190501230848097-1235451730.png&quot; alt=&quot;&quot; width=&quot;698&quot; height=&quot;167&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1003414/201905/1003414-20190501230913560-745982165.png&quot; alt=&quot;&quot; width=&quot;695&quot; height=&quot;177&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;/tmp/1556706513655.png&quot;&gt;&lt;img src=&quot;file:///tmp/1556706513655.png?lastModify=1556722872&quot; alt=&quot;&quot; data-local-refresh=&quot;true&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;/tmp/1556706478171.png&quot;&gt;&lt;img src=&quot;file:///tmp/1556706478171.png?lastModify=1556722872&quot; alt=&quot;&quot; data-local-refresh=&quot;true&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;当修改style文件后，server端HotModuleReplacementPlugin会根据更新内容生成manifest和js文件,文件名根据current_hash生成，然后更新current_hash，并将新的hash值推送给游览器端，用作下次更新。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1003414/201905/1003414-20190501231025996-890480559.png&quot; alt=&quot;&quot; width=&quot;639&quot; height=&quot;233&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1003414/201905/1003414-20190501231050296-1892570385.png&quot; alt=&quot;&quot; width=&quot;643&quot; height=&quot;171&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;/tmp/1556706725270.png&quot;&gt;&lt;img src=&quot;file:///tmp/1556706725270.png?lastModify=1556722872&quot; alt=&quot;&quot; data-local-refresh=&quot;true&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;游览器端webpack-dev-server/client接收到新的hash值后，会将previous hash值传递给webpack/hot/dev-server，dev-server根据previous hash请求具体的mainifest和js代码，并使用jsonp更新。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;/tmp/1556706915712.png&quot;&gt;&lt;img src=&quot;file:///tmp/1556706915712.png?lastModify=1556722872&quot; alt=&quot;&quot; data-local-refresh=&quot;true&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1003414/201905/1003414-20190501231131835-2117602168.png&quot; alt=&quot;&quot; width=&quot;660&quot; height=&quot;231&quot;/&gt;&lt;img src=&quot;file:///tmp/1556706838673.png?lastModify=1556722872&quot; alt=&quot;&quot; data-local-refresh=&quot;true&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;参考文档：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://medium.com/@rajaraodv/webpack-hot-module-replacement-hmr-e756a726a07&quot;&gt;&lt;span&gt;Webpack &amp;amp; The Hot Module Replacement&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/30669007&quot;&gt;Webpack HMR原理解析&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 01 May 2019 15:13:00 +0000</pubDate>
<dc:creator>宇的季节</dc:creator>
<og:description>Webpack &amp; The Hot Module Replacement热模块替换原理解析 The Hot Module Replacement(HMR)俗称热模块替换。主要用来当代码产生变化</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenkeyu/p/10801197.html</dc:identifier>
</item>
<item>
<title>软件工程专业毕业到底能做什么工作？考研还是工作？ - 二十四向风</title>
<link>http://www.cnblogs.com/hwtblog/p/10801130.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hwtblog/p/10801130.html</guid>
<description>&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;有很多刚刚踏入软件工程专业的学生或许对该专业还不太熟悉，不知道自己的努力方向，没有想好自己未来的路怎么走，如何走。&lt;/p&gt;
&lt;p&gt;没错，我原来就是其中的一员。当我真正将要踏入社会的那一刻，在写简历的那一刻，我才明白自己的大学生活缺少了什么。以下的内容只是我个人对这个行业的一点理解和一些建议。希望能帮助那些刚刚进入这个专业的学弟学妹们。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;-1&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;该文主要分为三大部分&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;互联网行业相关工作分类及描述&lt;/li&gt;
&lt;li&gt;考研还是工作？&lt;/li&gt;
&lt;li&gt;一些零散的宝贵经验（给学弟学妹们的）&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;-2&quot;&gt;一、互联网行业相关工作分类及描述&lt;/h2&gt;
&lt;p&gt;其他的学校我不知道，我们学校在大三的时候开过一门《职业生涯规划》的课。下面的内容也是我作业的一部分，就是探讨软件工程行业的工作选择的。&lt;/p&gt;
&lt;p&gt;简单分成两大类：技术类和非技术类&lt;/p&gt;
&lt;h3 id=&quot;1&quot;&gt;1、技术类&lt;/h3&gt;
&lt;h4 id=&quot;11&quot;&gt;1.1 前端&lt;/h4&gt;
&lt;p&gt;主要做的工作是用代码写出展示界面和一些特效。需要说明一点，不知道其他公司是怎么分类微信开发的，我们公司把微信开发（小程序开发）归入到了前端部分。总体来说前后端薪资都是差不多的。&lt;/p&gt;
&lt;p&gt;前端联系比较紧密的是&lt;strong&gt;UI设计师&lt;/strong&gt;。但是UI设计师相关的知识软件工程大多是不教的。UI设计师的工作就是设计出比较好看的界面和图标，合理的页面布局等，需要掌握一些专业的设计软件。有兴趣的可以自行谷歌学习。另外，我们在大三的时候学过一门《界面设计》的课，还是很不错的。建议学弟学妹们好好听一听。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pqtjk9wb5.bkt.clouddn.com/2019%E5%B9%B44%E6%9C%8830%E6%97%A5-%E4%BA%92%E8%81%94%E7%BD%91%E8%A1%8C%E4%B8%9A%E5%88%86%E6%9E%901556612005892.png&quot; alt=&quot;1556612005892&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;12&quot;&gt;1.2 后端&lt;/h4&gt;
&lt;p&gt;后端的工作需求也是比较多的，我对后端的理解就是完成系统所需的功能。你可以理解为前端定义了一个东西长得怎么样，后端定义了这个东西有什么功能。&lt;/p&gt;
&lt;p&gt;不想吹Java，但是现实是Java的需求量真的很大。当然也有C++，python工程师，就我们这一届来说，除了Java外这两个方向的职位也有看到，只是比较少罢了。&lt;/p&gt;
&lt;p&gt;因为我现在的职位就是Java后端工程师，虽然是在一个初创型公司，但是开发规范还是不错的，在公司能跟着大佬学习很多。不得不说Java后端需要掌握的东西实在太多了。需要详细了解的可以关注我微信公众号，里面有我的联系方式，希望结交一些小伙伴一起学习努力，哈哈哈&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pqtjk9wb5.bkt.clouddn.com/2019%E5%B9%B44%E6%9C%8830%E6%97%A5-%E4%BA%92%E8%81%94%E7%BD%91%E8%A1%8C%E4%B8%9A%E5%88%86%E6%9E%901556612045223.png&quot; alt=&quot;1556612045223&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;13android&quot;&gt;1.3 Android&lt;/h4&gt;
&lt;p&gt;说一说移动端开发，前几年移动端开发人特别多，导致了需求量过剩。所以到我们这一届，移动端人才特别缺，移动端开发工资特别高。不得不说如果打算就业工作，选对方向真的很重要（2019届算法和后端竞争比较大）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pqtjk9wb5.bkt.clouddn.com/2019%E5%B9%B44%E6%9C%8830%E6%97%A5-%E4%BA%92%E8%81%94%E7%BD%91%E8%A1%8C%E4%B8%9A%E5%88%86%E6%9E%901556707251971.png&quot; alt=&quot;1556707251971&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;14ios&quot;&gt;1.4 IOS&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://pqtjk9wb5.bkt.clouddn.com/2019%E5%B9%B44%E6%9C%8830%E6%97%A5-%E4%BA%92%E8%81%94%E7%BD%91%E8%A1%8C%E4%B8%9A%E5%88%86%E6%9E%901556707279238.png&quot; alt=&quot;1556707279238&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;15&quot;&gt;1.5 游戏开发&lt;/h4&gt;
&lt;p&gt;游戏的开发，我对具体的工作还是了解的不深，有兴趣的可以自己搜索相关资料&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pqtjk9wb5.bkt.clouddn.com/2019%E5%B9%B44%E6%9C%8830%E6%97%A5-%E4%BA%92%E8%81%94%E7%BD%91%E8%A1%8C%E4%B8%9A%E5%88%86%E6%9E%901556707323646.png&quot; alt=&quot;1556707323646&quot;/&gt;&lt;/p&gt;
&lt;p&gt;除了上述的开发的相关工作，一些其他的工作也属于技术岗位，虽然也需要一定的编码水平，但是需要掌握一些其他的特殊技能&lt;/p&gt;
&lt;h4 id=&quot;16&quot;&gt;1.6 人工智能与深度学习工程师&lt;/h4&gt;
&lt;p&gt;感觉这个工作主要招的都是研究生，毕竟是比较高端的技术，对应的薪资也是较高的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pqtjk9wb5.bkt.clouddn.com/2019%E5%B9%B44%E6%9C%8830%E6%97%A5-%E4%BA%92%E8%81%94%E7%BD%91%E8%A1%8C%E4%B8%9A%E5%88%86%E6%9E%901556707496183.png&quot; alt=&quot;1556707496183&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;17&quot;&gt;1.7 运维&lt;/h4&gt;
&lt;p&gt;个人感觉这个工作非常苦逼，枯燥没意思。运维的工作就是把开发好的项目在服务器上部署发布和长期的运行维护，需要精通熟悉linux系统。一般小公司是没有运维的~，没错，你猜对了。在小公司这部分的工作是交给开发来做的，项目无论在线上除了什么故障都来找开发，有点难受。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pqtjk9wb5.bkt.clouddn.com/2019%E5%B9%B44%E6%9C%8830%E6%97%A5-%E4%BA%92%E8%81%94%E7%BD%91%E8%A1%8C%E4%B8%9A%E5%88%86%E6%9E%901556707585657.png&quot; alt=&quot;1556707585657&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;18&quot;&gt;1.8网络安全分析师&lt;/h4&gt;
&lt;p&gt;这个工作呢？需要掌握网络安全的相关知识，但是你要知道在本科阶段学校教给你的东西，在这方面是完全不够的，如果真的对这方面非常感兴趣，可以自己搜索相关知识，多多参加相关比赛，或者是项目等&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pqtjk9wb5.bkt.clouddn.com/2019%E5%B9%B44%E6%9C%8830%E6%97%A5-%E4%BA%92%E8%81%94%E7%BD%91%E8%A1%8C%E4%B8%9A%E5%88%86%E6%9E%901556708034258.png&quot; alt=&quot;1556708034258&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;19&quot;&gt;1.9 软件测试&lt;/h4&gt;
&lt;p&gt;软件测试是一个非常关键的一个工作，其实软件测试的工作分为两种，一种是&lt;strong&gt;测试工程师&lt;/strong&gt;，另一种叫做&lt;strong&gt;测试开发工程师&lt;/strong&gt;，&lt;/p&gt;
&lt;p&gt;其实在本质上这是两个本质不太相同的职位。&lt;/p&gt;
&lt;p&gt;测试工程师是偏重业务逻辑的测试，即功能性测试，说白了就是说某个功能好不好使。写代码能力不强也不要紧。&lt;/p&gt;
&lt;p&gt;测试开发工程师是开发人员，比较偏重自动化测试工具的开发。&lt;/p&gt;
&lt;p&gt;总结：国外的软件行业是把软件测试环节看的非常重要的，软件的测试环节也有一系列的严格的步骤，不知道其他的学校，反正在我们学校会开一门《软件测试》的课，我感觉非常不错，教材使用的也非常好。但是在国内的话只有大厂的测试环节会比较好。总体来说测试也是一个非常好的行业，压力也不是太大（当然是相对于开发来说）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pqtjk9wb5.bkt.clouddn.com/2019%E5%B9%B44%E6%9C%8830%E6%97%A5-%E4%BA%92%E8%81%94%E7%BD%91%E8%A1%8C%E4%B8%9A%E5%88%86%E6%9E%901556708215767.png&quot; alt=&quot;1556708215767&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;2&quot;&gt;2、非技术类&lt;/h3&gt;
&lt;h4 id=&quot;21&quot;&gt;2.1 产品经理&lt;/h4&gt;
&lt;p&gt;产品经理的工作简单的讲就是决定了一个产品的发展。可以把产品经理比作导演，把程序员比作演员。导演决定了一部戏的发展走向，而演员是具体实施者。一个好的产品经理必须是一个好的交流者。说到这里我已经迫不及待的想和产品互怼了(〃'▽'〃)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pqtjk9wb5.bkt.clouddn.com/2019%E5%B9%B44%E6%9C%8830%E6%97%A5-%E4%BA%92%E8%81%94%E7%BD%91%E8%A1%8C%E4%B8%9A%E5%88%86%E6%9E%901556716887356.png&quot; alt=&quot;1556716887356&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;22&quot;&gt;2.2产品运营&lt;/h4&gt;
&lt;p&gt;负责产品的运营，平时和用户沟通的比较多。如果产品运营对现有的系统有不满，需要制定新功能的话，需要和产品经理研究，制定统一的解决方案。之后产品经理需要和技术部门经理讨论方案，选择最优的方案，最后制定开发任务&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pqtjk9wb5.bkt.clouddn.com/2019%E5%B9%B44%E6%9C%8830%E6%97%A5-%E4%BA%92%E8%81%94%E7%BD%91%E8%A1%8C%E4%B8%9A%E5%88%86%E6%9E%901556717453578.png&quot; alt=&quot;1556717453578&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;3&quot;&gt;3、总结&lt;/h3&gt;
&lt;p&gt;简单画一个图来说明一下各个人员在一个产品流程中的角色，当然这只是一个简单的图，现实中可能会有各种问题，大的公司流程可能会更多（如果有误，希望大佬给出宝贵意见）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pqtjk9wb5.bkt.clouddn.com/2019%E5%B9%B44%E6%9C%8830%E6%97%A5-%E4%BA%92%E8%81%94%E7%BD%91%E8%A1%8C%E4%B8%9A%E5%88%86%E6%9E%901556718489667.png&quot; alt=&quot;1556718489667&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;-3&quot;&gt;二、考研还是工作？&lt;/h2&gt;
&lt;p&gt;这个我不想多说，因为我也是刚刚毕业参加工作，没有真正体会到考研和工作的利弊。&lt;/p&gt;
&lt;p&gt;先说下我的观点：&lt;strong&gt;无论选择哪条道路，相信自己的决定是正确的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;直接上知乎大佬的回答，可以做下参考&lt;/p&gt;
&lt;h3 id=&quot;-4&quot;&gt;回答一&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;作者：Shengsheng&lt;/p&gt;
&lt;p&gt;链接：https://www.zhihu.com/question/60462553/answer/193112194&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;谢邀。是这样的，这个要看你怎么选择。&lt;strong&gt;如果你想以后不做开发，想做研究，甚至读博做教授，那么就读研读博吧&lt;/strong&gt;。如果你致力于成为一名软件工程师，想在工业界混，那么又要分情况来说了。&lt;/p&gt;
&lt;p&gt;安徽的211，只有安大和合工大，并不是什么很厉害的大学，跟985高校比起来还是差了一些。所以&lt;strong&gt;如果能够保研或者考研到985高校的，或者有条件出国留学的，可以考虑读研，但是这个只是为了拿到一块厉害一点的敲门砖&lt;/strong&gt;，你读研的成长，绝对比不上在公司里面的成长。有条件出国留学的，真的可以考虑出国留个学，在外面非常锻炼人。&lt;strong&gt;如果考不上985研究生，也没资格保研，也没法出国留学，那么就不要读研了。去公司工作，3年后你同学读研毕业了，但你可能升职了，就算不升值也积攒了3年的工作经验，你的水平会比你那些读研的同学强很多。&lt;/strong&gt;实际上，有了3年的工业界经验，你也不需要985、留学生什么的敲门砖了。另外，楼主说进不了BAT什么的...请充满信心，努力试一把，才知道究竟能不能进BAT啊。&lt;/p&gt;
&lt;p&gt;答主本科也是软件工程专业，虽然现在在读研，但读的是兼职的，白天都在工作，晚上才会抽时间弄一下学业上的事情。&lt;strong&gt;对比我在工作中的收获和在读研中的收获，我觉得读研给我的收获几乎可以忽略不计&lt;/strong&gt;...在工作中我学会了怎么从零开始构建分布式微服务架构，怎么调优接口提高并发量，怎么应对产品上线(表示每次上线都要跟同事奋战到第二天凌晨T^T...)，怎么跟上级、同事沟通，等等等等...&lt;strong&gt;这些东西，不是在工业界做一线开发，根本接触不到，或者不会去想&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我本科同学有不少去985高校读研的，从他们那里我多少了解了一些国内读研的现状。我只想说，国内985研究生好水(当然跟学校有关系)...我同学研一就想出来工作了...&lt;strong&gt;不光教的课比较古董，老师的项目大多也都是以demo为主，很少有真正商用的，团队里面也几乎没有在工业界工作过的人。&lt;/strong&gt;所以我想问，读研除了可以拿一块证书之外，能学到多少真正有用的东西？&lt;/p&gt;
&lt;h3 id=&quot;-5&quot;&gt;回答二&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;作者：菜根谭&lt;/p&gt;
&lt;p&gt;链接：https://www.zhihu.com/question/60462553/answer/186812668&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看到好多小朋友 我就想老司机开车 软件工程 本科 工作十年 一贯的风格是告诉你们很多利弊 但是这次准备直接排序 站在我的经验和判断&lt;/p&gt;
&lt;p&gt;\1. 名校研究生（清华 交大 中科院 中大 北邮） 机器学习和人工智能方向优先 \2. 真实实习 bat一流公司工作 \3. 重点学校研究生&lt;/p&gt;
&lt;p&gt;\4. 实习 毕业 \5. 毕业&lt;/p&gt;
&lt;p&gt;选择要有目的 多提供几个衡量目的的角度&lt;/p&gt;
&lt;p&gt;出国看世界与否？&lt;/p&gt;
&lt;p&gt;一线城市户口否？&lt;/p&gt;
&lt;p&gt;兴趣爱好匹配否？&lt;/p&gt;
&lt;p&gt;女朋友，家庭？&lt;/p&gt;
&lt;p&gt;职业目标IC还是管理还是创业？&lt;/p&gt;
&lt;h2 id=&quot;-6&quot;&gt;三、一些零散的宝贵经验（给学弟学妹们的）&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;大三下学期大公司正在春招，招很多实习生，实习生的岗位相对来说还是比较好得到的。如果能够拿到大公司的实习生岗位，对将来招工作和考研都是比较重要的。但是大公司往往在北上广深，对其他外地学校的学生来说还是不太友好，毕竟大三往往还有课。如果不能去实习的话，建议大三下学期就开始准备找工作的材料，好好准备秋招。&lt;/li&gt;
&lt;li&gt;学好算法，可以在秋招中脱颖而出，建议去刷LeetCode，很多公司的笔试题都是LeetCode的原题。注意！！！不要误认为自己有开发经验就不去准备这一部分。实际情况是如果你过不了笔试，你连面试的机会都没有~ 没错，现实就是如此残酷，我在这方面就吃了很大的亏。另外可以牛客网刷一些题。如果想要了解更多这方面的东西，可以到我公众号里留言私信我，如果人多的话，我就再写一些这方面的东西。&lt;/li&gt;
&lt;li&gt;必须有项目经验，无论项目大小，保证项目的完整性&lt;/li&gt;
&lt;li&gt;多参加学校的技术性比赛，无论是什么样的，你会慢慢在比赛中认识到自己想要什么&lt;/li&gt;
&lt;li&gt;简单总结了一下软件工程专业必备的基本知识素养（如下图），比较惭愧的是一下知识我有大部分都掌握的一般般。希望学弟学妹们不要向我学习&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://pqtjk9wb5.bkt.clouddn.com/2019%E5%B9%B44%E6%9C%8830%E6%97%A5-%E4%BA%92%E8%81%94%E7%BD%91%E8%A1%8C%E4%B8%9A%E5%88%86%E6%9E%90%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%8A%80%E8%83%BD%E5%9B%BE%E8%B0%B1.png&quot; alt=&quot;软件工程技能图谱&quot;/&gt;&lt;/p&gt;

&lt;p&gt;如果想获取上方所有完整的思维导图，可以关注我的公众号回复【思维导图之软件工程】即可获取，有其他想法也可在我公众号里留言大家一起进步学习&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
</description>
<pubDate>Wed, 01 May 2019 14:51:00 +0000</pubDate>
<dc:creator>二十四向风</dc:creator>
<og:description>有很多刚刚踏入软件工程专业的学生或许对该专业还不太熟悉，不知道自己的努力方向，没有想好自己未来的路怎么走，如何走。 没错，我原来就是其中的一员。当我真正将要踏入社会的那一刻，在写简历的那一刻，我才明白</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hwtblog/p/10801130.html</dc:identifier>
</item>
<item>
<title>一种简单高效的音频降噪算法示例(附完整C代码) - cpuimage</title>
<link>http://www.cnblogs.com/cpuimage/p/10800768.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cpuimage/p/10800768.html</guid>
<description>&lt;p&gt;近期比较忙,&lt;/p&gt;
&lt;p&gt;抽空出来5.1开源献礼.&lt;/p&gt;
&lt;p&gt;但凡学习音频降噪算法的朋友,肯定看过一个算法.&lt;/p&gt;
&lt;p&gt;&amp;lt;&amp;lt;语音增强-理论与实践&amp;gt;&amp;gt; 中提及到基于对数的最小均方误差的降噪算法,也就是LogMMSE.&lt;/p&gt;
&lt;p&gt;资料见:&lt;/p&gt;
&lt;p&gt;&amp;lt;&amp;lt;Speech enhancement using a minimum  mean-square error log-spectral amplitude estimator.&amp;gt;&amp;gt; &lt;/p&gt;
&lt;p&gt;-----Ephraim, Y. and Malah, D. (1985)&lt;/p&gt;
&lt;p&gt;之前也是花了不少时间去查阅降噪相关的思路,&lt;/p&gt;
&lt;p&gt;但是最终发现前人的思路,有很多局限性或者说弊端.&lt;/p&gt;
&lt;p&gt;一般都是提出一种数学先验的假设,换句话说,在paper里讲点故事.&lt;/p&gt;
&lt;p&gt;然后最终,故事的结局都是it works.&lt;/p&gt;
&lt;p&gt;但实际应用却差强人意.&lt;/p&gt;

&lt;p&gt; 而一般的图像降噪流程,见图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/824862/201905/824862-20190501222759528-1102983502.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也就是,一个降噪算法的基本组成部分有:&lt;/p&gt;
&lt;p&gt;1.噪声提取(用于提取噪声)&lt;/p&gt;
&lt;p&gt;2.静音检测(一般检测是否为人声,减少误判)&lt;/p&gt;
&lt;p&gt;3.数学先验假设(用于降噪)&lt;/p&gt;

&lt;p&gt;当然最小均方误差的降噪思路,用在图像上一样适用.&lt;/p&gt;

&lt;p&gt;但是,大多数音频降噪算法仅仅适配某种特殊情况(特例).&lt;/p&gt;
&lt;p&gt;工程化应用时,会发现,&lt;/p&gt;
&lt;p&gt;一个坑接着一个坑,&lt;/p&gt;
&lt;p&gt;然后不得不妥协.勉强能用就行,&lt;/p&gt;
&lt;p&gt;要求太高不现实.&lt;/p&gt;

&lt;p&gt;而当年看了logMMSE的思路之后,就很清楚地明白,&lt;/p&gt;
&lt;p&gt;这思路是可行的,但是特别鸡肋.&lt;/p&gt;

&lt;p&gt;话说如此,但是对作为学习信号处理,音频降噪来说,&lt;/p&gt;
&lt;p&gt;这个是一个特别好的入门示例算法.&lt;/p&gt;
&lt;p&gt;至少经过实践之后,你心中能有了个大概的印象.&lt;/p&gt;
&lt;p&gt;音频降噪是一个什么样的工作,会碰到什么样的难点.&lt;/p&gt;

&lt;p&gt; logmmse的各种实现,在github搜索一下,都能找得到.&lt;/p&gt;
&lt;p&gt;这里,并不打算解析logmmse的算法细节.&lt;/p&gt;

&lt;p&gt;只是分享一段非常简单有效的类似logmmse算法的c语言实现.&lt;/p&gt;
&lt;p&gt;说是类似,不如说,&lt;/p&gt;
&lt;p&gt;思路来自logmmse,只是更加的简洁明了.(自我以为)&lt;/p&gt;
&lt;p&gt;自己动手,丰衣足食.&lt;/p&gt;
&lt;p&gt;稍微改进一下,可以进一步适配各种环境和情况,&lt;/p&gt;
&lt;p&gt;当然也不是那么容易,&lt;/p&gt;
&lt;p&gt;例如:&lt;/p&gt;
&lt;p&gt;+vad.&lt;/p&gt;
&lt;p&gt;+延时记忆机制诸如此类&lt;/p&gt;

&lt;p&gt;代码基于本人最近开源的基于傅里叶变换的重采样算法.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/cpuimage/FFTResampler&quot; target=&quot;_blank&quot;&gt;https://github.com/cpuimage/FFTResampler&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;题外话:&lt;/p&gt;
&lt;p&gt;在之前为了找各种重采样算法,费心死了.&lt;/p&gt;
&lt;p&gt;所以,写一个通用简洁的重采样算法是我的一个待办事项.&lt;/p&gt;
&lt;p&gt;重采样算法算是暂时结束了.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/cpuimage/resampler&quot;&gt;https://github.com/cpuimage/resampler&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/cpuimage/FFTResampler&quot; target=&quot;_blank&quot;&gt;https://github.com/cpuimage/FFTResampler&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这两个平时应该是够用了,&lt;/p&gt;
&lt;p&gt;下一步要继续做的话,&lt;/p&gt;
&lt;p&gt;可能就是音频超分辨率算法了.&lt;/p&gt;

&lt;p&gt;除了懒,没别的,能复用就复用了.&lt;/p&gt;
&lt;p&gt;回到主题上,这个简易的算法用来去除平稳噪声或底噪,是非常合适的,&lt;/p&gt;
&lt;p&gt;当然当前开源实现的算法,是非实时的,&lt;/p&gt;
&lt;p&gt;当然稍微改进下可以应用在实时的环境.&lt;/p&gt;

&lt;p&gt;值5.1放假之际,开源出来,给大家参考学习.&lt;/p&gt;
&lt;p&gt;权当抛砖引玉,一起玩耍.&lt;/p&gt;

&lt;p&gt;项目地址:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/cpuimage/SimpleAudioDenoise&quot;&gt;https://github.com/cpuimage/SimpleAudioDenoise&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;br class=&quot;Apple-interchange-newline&quot;/&gt;
若有其他相关问题或者需求也可以邮件联系俺探讨。&lt;/p&gt;
&lt;p&gt;当然一些基础性的问题,一概忽略.&lt;/p&gt;
&lt;p&gt;有时间给我写邮件,不如多看点资料书籍.&lt;/p&gt;

&lt;p&gt;邮箱地址是: &lt;br/&gt;gaozhihan@vip.qq.com&lt;/p&gt;
</description>
<pubDate>Wed, 01 May 2019 14:50:00 +0000</pubDate>
<dc:creator>cpuimage</dc:creator>
<og:description>近期比较忙, 抽空出来5.1开源献礼. 但凡学习音频降噪算法的朋友,肯定看过一个算法. &lt;&lt;语音增强-理论与实践&gt;&gt; 中提及到基于对数的最小均方误差的降噪算法,也就是LogMM</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cpuimage/p/10800768.html</dc:identifier>
</item>
<item>
<title>如何写工程代码——重新认识面向对象 - 暮夜望日</title>
<link>http://www.cnblogs.com/scau-chm/p/10800885.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/scau-chm/p/10800885.html</guid>
<description>&lt;p&gt;工作一年，维护工程项目的同时一直写CURD，最近学习DDD，结合之前自己写的开源项目，深思我们这种CURD的编程方式的弊端，和朋友讨论后，发现我们从来没有面向对象开发，所以写这篇文章，希望更多人去思考面向对象，不只是停留在背书上&lt;/p&gt;
&lt;p&gt;下面以开发一个常规的登录模块为例，模拟实现一个登录功能，一步步地去说明其中的弊端和重新解释面向对象&lt;/p&gt;
&lt;h2 id=&quot;常规的开发方式&quot;&gt;常规的开发方式&lt;/h2&gt;
&lt;p&gt;创建模型&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Data
@NoArgsConstructor
class User{
    private Integer Id;
    private String name;
    private String password;//加密过的密码
  private Integer status;//账号状态
}

class UserRepository{
  User getByName(String name);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们都知道mvc，所以会这么写&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class UserController{
    @RequestMapping(&quot;/login&quot;)
    public void login(String name,String password){
        userService.login(name,password);
    }
}

class UserService{
    public void login(String name,String password);
}

class UserServiceImpl implements UserService{
    public void login(String name,String password){
        //1.查出这个用户
        User user = userRepo.getByName(name);
    //2.检查状态
    if(user.getStatus()!=1){
      //登录失败
    }
    //3.检查密码
    if(!Objects.equals(md5(password),user.getPassword())){
        //登录失败
    }
    //登录后续
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;虽然这个login方法有点丑，这还是没有打点，日志，生成登录态的情况下。我们所有的业务都写在了UserService里面，可能很多人不觉得这样写有什么问题。如果代码写多一点的程序员，可能会把每一步都抽成一个方法&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void login(String name,String password){
  //1.查出这个用户
  User user = userRepo.getByName(name);
  //2.检查状态
  checkUserStatus();
  //3.检查密码
  checkPassword();
  //登录后续
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样看是好看很多，但是换汤不换药，维护过工程项目的同学都会发现，项目里基本都是这种代码，维护起来成本极高：&lt;/p&gt;
&lt;ol readability=&quot;8.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;login方法被抽成几个方法，login方法是简单了，service却臃肿了&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;service臃肿后开始拆分service，再不济开始建立多一层manage之类的&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;复用极其困难，因为checkUserStatus这种方法往往是私有，并且这种抽离对其它业务场景是否合适也不好说&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;在代码开始出现冗余时，会开始写一些带有业务逻辑的Utils，把污染扩散到Utils&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;由于复用极其困难，开始出现多个类似功能的方法，分布在不同类里，后继维护项目的人很难分清类似方法的区别&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;因为不好统一表达语义，DTO等对象会在service层泛滥，controller和service耦合严重，导致分层变得没有意义&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;1，2其实是一个死循环，最后直接反映到项目难以维护上&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;在多数据源，多事务的情况下，难以确定事务边界，容易出现事务不能回滚的情况&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;单元测试的编写是个噩梦，尝试写单测的同学应该深有体会&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;为什么会这样呢？因为我们到这里为止，依然还是面向过程编程，完全没有面向对象的思维。代码其实都是堆起来，责任和边界不清晰，导致复用很难，维护变更的成本很高，所以项目经过多人维护后会变得更严重。唯一像面向对象的代码就是&lt;code&gt;User user = userRepo.getByName(name)这一句了&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;重新认识面向对象&quot;&gt;重新认识面向对象&lt;/h2&gt;
&lt;p&gt;为什么说这一句有面向对象的意味？因为这行含义十分明显，&lt;strong&gt;谁做了什么&lt;/strong&gt;，我觉得这是一个很好的判断原则，在scala里面，是可以把&lt;code&gt;a.do(thing)&lt;/code&gt;写成&lt;code&gt;a do thing&lt;/code&gt;，&lt;strong&gt;主语确定了责任，边界&lt;/strong&gt;。在这里，用户repo获取（生成）一个用户对象。虽然我们一直在说OO，什么封装继承多态，六大原则，张口就来，但是一写起代码就变成过程式开发。很多人说设计模式很难学，用不上，很大原因是连对象是什么都没概念，还怎么谈面向对象设计&lt;/p&gt;
&lt;p&gt;有人会问，上面的User不是对象吗？这个问题我在学校的时候也被别人问过，当时也觉得很疑惑。当时的问题是这样的，你觉得上面的User和下面这个有区别吗&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;struct User
{
   int id;
   char name[50];
   char password[50];
   int status;
} user;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;是的，这是c语言的结构体。你当然不会说这个是对象。这里有个误区，我们平时说的Java对象，其实指的是面向对象语言Java里类的实例，并不等同于面向对象里的对象。所以上面java对象也不见得是真的OO对象&lt;/p&gt;
&lt;p&gt;可以看一下&lt;a href=&quot;https://en.wikipedia.org/wiki/Object_(computer_science)&quot;&gt;维基百科关于对象的说法&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;对象是什么&quot;&gt;对象是什么&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;OO的对象应该是data+behavior&lt;/strong&gt;，所以我们上面的User对象没有行为，只是一个数据结构。试想一下，我是用户，校验密码应该是我自己的事，我用什么加密应该也是我来决定，甚至我加不加密也是我说了算。同样的，我的状态应该也是我来管理，我们的User可以改造成这样&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Data
@NoArgsConstructor
class User{
    private Integer Id;
    private String name;
    private String password;//加密过的密码
  private Integer status;//账号状态
  
  public boolean checkPassword(String pass){
    return Objects.equals(md5(pass),this.password);
  }
  
  public boolean isNormal(){
    return this.status==1
  }
  
  //这里啰嗦一下，有时候我们不太好把行为写到数据库模型类，可以单独建立一个User类，这个User类也就是DDD里面的领域对象。如果持久层使用JPA，JPA的数据模型类即是领域对象，JPA允许通过注解去把领域对象绑定到数据模型上。
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样，Service的代码就简单很多，只需要关注登录的逻辑，不需要关心细节&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void login(String name,String password){
  //1.查出这个用户
  User user = userRepo.getByName(name);
  //2.检查状态
  if(!user.isNormal()){
  
  }
  //3.检查密码
  if(!user.checkPassword(password)){
  
  }
  //登录后续
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;这样做有什么好处呢&quot;&gt;这样做有什么好处呢&lt;/h2&gt;
&lt;p&gt;把固有的逻辑由对象本身负责，责任分明，边界清晰，业务逻辑统一集中，编写单测更容易&lt;/p&gt;
&lt;p&gt;更重要的是，我们的User对象建立起来，有关用户相关的逻辑，方法，我们可以通过User来表达，并且可以在各个分层中传递，&lt;strong&gt;统一业务表达语言&lt;/strong&gt;，可以有效遏制DTO在Service层泛滥的问题。后续会说明一下DTO的问题&lt;/p&gt;
&lt;p&gt;理解了对象是什么后，会更好地反思封装的重要性，进而深入理解六大原则的含义，开始抽象出接口，在实践接口的基础上慢慢地会形成一些手法和技巧，那便是设计模式。而这一切都需要在开发时保持思考，这样写是否流程清晰，边界分明，复用是否容易，最重要的是，是否符合业务的表达，而不是写出service类do anything的过程式代码&lt;/p&gt;
</description>
<pubDate>Wed, 01 May 2019 13:44:00 +0000</pubDate>
<dc:creator>暮夜望日</dc:creator>
<og:description>工作一年，维护工程项目的同时一直写CURD，最近学习DDD，结合之前自己写的开源项目，深思我们这种CURD的编程方式的弊端，和朋友讨论后，发现我们从来没有面向对象开发，所以写这篇文章，希望更多人去思考</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/scau-chm/p/10800885.html</dc:identifier>
</item>
<item>
<title>C语言指针收藏 - 东小东</title>
<link>http://www.cnblogs.com/dongxiaodong/p/10743246.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dongxiaodong/p/10743246.html</guid>
<description>&lt;h2&gt;指针是什么&lt;/h2&gt;
&lt;p&gt;》》每一个内存单元只能同时存储一个数据，如何保证内存单元同时只能存储一个数据，可以使用编号的方式实现内存单元标记，此编号就是指针。&lt;/p&gt;
&lt;p&gt;》》指针是一个变量，指针是存放着一个数据的内存地址而不是数据本身的值，其是查找数据的另一种方式&lt;/p&gt;
&lt;h2&gt;相关运算符&lt;/h2&gt;
&lt;p&gt;【&amp;amp;】在变量中取地址&lt;/p&gt;
&lt;p&gt;【*】在地址中取变量&lt;/p&gt;
&lt;p&gt;测试小程序：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
#include&amp;lt;stdio.h&amp;gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main() {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;10&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义一个变量，并赋初始值为10&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; *p = &amp;amp;i;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义一个指针变量，并赋初始值为i的地址&lt;/span&gt;
    *p = &lt;span&gt;199&lt;/span&gt;&lt;span&gt;;
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d=%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, *p,i);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出199=199&lt;/span&gt;
    printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;---%d---&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, p);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到变量i的地址&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;指针变量的类型&lt;/h2&gt;
&lt;p&gt;》》指针类型：int *、float*、long*、double*、char*等等&lt;/p&gt;
&lt;p&gt;》》指针变量的类型需要与存储的数据类型相同&lt;/p&gt;
&lt;p&gt;》》确定类型可以方便指针变量确定存储数据的大小，为数据寻找到结束符，如int类型占四个字节、char占一个字节。也方便指针使用加1或减1操作，如int加减1会跳动4个字节，char加减1会跳动两个字节。&lt;/p&gt;
&lt;h2&gt;指针的赋值&lt;/h2&gt;
&lt;p&gt;int i=10;  int *p=&amp;amp;i;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485202/201904/1485202-20190430222532918-1492507645.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;int *pp;&lt;/p&gt;
&lt;p&gt;pp=p;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485202/201904/1485202-20190430222600841-144224055.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;指针运算符：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;*p++&lt;/p&gt;
&lt;p&gt;等同于p++;*p;或者*（p++）,运算优先级为从右到左。&lt;/p&gt;
&lt;h2&gt;指针变量作为函数参数&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
#include&amp;lt;stdio.h&amp;gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;int *a1=&amp;amp;b1;&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; fun(&lt;span&gt;int&lt;/span&gt; *a1, &lt;span&gt;int&lt;/span&gt;*&lt;span&gt; a2) {
    
    &lt;/span&gt;*a1 = &lt;span&gt;100&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; ii = &lt;span&gt;99&lt;/span&gt;&lt;span&gt;;
    a2 &lt;/span&gt;= &amp;amp;ii;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;让指针重新指向另外一个地址&lt;/span&gt;
    printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;得到的数据：%d,%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, *a1, *a2);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出100,99&lt;/span&gt;
&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main() {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; b1 = &lt;span&gt;1&lt;/span&gt;, b2 = &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
    fun(&lt;/span&gt;&amp;amp;b1, &amp;amp;&lt;span&gt;b2);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;调用函数后：%d,%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, b1, b2);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出100,2&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出b2的结果并不是相同的值，是因为执行调用函数改变了实参指针变量的值，并不是改变了实参指针变量所指变量的值&lt;/p&gt;
&lt;h2&gt;一维数组指针变量&lt;/h2&gt;
&lt;p&gt;数组名（如arr）代表元素的首地址，数组第一个元素的地址也是这个数组的首地址（如&amp;amp;arr[0]）。&lt;/p&gt;
&lt;p&gt;数组指针中使用加减1将跳到下一个或者上一个数组元素地址，与使用 &amp;amp;arr[n+1] 基本相同。&lt;/p&gt;
&lt;p&gt;如果整数数组名为arr,运行int *p=arr,则*(p+3)、p[3]、*(arr+3）、arr[3]效果均是取出数组arr的第三个元素，在编译时arr[3]实际上是*（arr+3）处理的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
#include&amp;lt;stdio.h&amp;gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main() {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; arr[] = { &lt;span&gt;5&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;&lt;span&gt; };
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; *p =&lt;span&gt; arr;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; *pp = &amp;amp;arr[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, *(p+&lt;span&gt;3&lt;/span&gt;));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出2&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;函数数组参数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
#include&amp;lt;stdio.h&amp;gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;等价于void fun(char a1[]) {&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; fun(&lt;span&gt;char&lt;/span&gt; *&lt;span&gt;a1) {
    &lt;/span&gt;*(a1 + &lt;span&gt;2&lt;/span&gt;) = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;改变第二个值的内容&lt;/span&gt;
&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main() {
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; b1[] = { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123456789&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
    fun(b1);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;调用函数后：%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, b1);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出: 12c456789&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;二维数组指针变量&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
#include&amp;lt;stdio.h&amp;gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main() {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; a1[][&lt;span&gt;3&lt;/span&gt;] = { {&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;11&lt;/span&gt;,&lt;span&gt;12&lt;/span&gt;},{&lt;span&gt;100&lt;/span&gt;,&lt;span&gt;110&lt;/span&gt;,&lt;span&gt;120&lt;/span&gt;&lt;span&gt;} };
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; a[][&lt;span&gt;3&lt;/span&gt;] = { &lt;span&gt;10&lt;/span&gt;,&lt;span&gt;11&lt;/span&gt;,&lt;span&gt;12&lt;/span&gt;,&lt;span&gt;100&lt;/span&gt;,&lt;span&gt;110&lt;/span&gt;,&lt;span&gt;120&lt;/span&gt;&lt;span&gt; };
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;地址：%d==%d==%d==%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, a[&lt;span&gt;0&lt;/span&gt;], &amp;amp;a[&lt;span&gt;0&lt;/span&gt;][&lt;span&gt;0&lt;/span&gt;],*(a+&lt;span&gt;0&lt;/span&gt;),a+&lt;span&gt;0&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出地址&lt;/span&gt;
    printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d===%d==%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, a[&lt;span&gt;0&lt;/span&gt;][&lt;span&gt;1&lt;/span&gt;], *(*(a + &lt;span&gt;0&lt;/span&gt;)+&lt;span&gt;1&lt;/span&gt;),*(a[&lt;span&gt;0&lt;/span&gt;]+&lt;span&gt;1&lt;/span&gt;));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到值&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;指针引用字符串&lt;/h2&gt;
&lt;p&gt;字符串常量【char *ch = &quot;dong xiao dong&quot;;】表示其指向地址的内容不可变，但指向的地址是可变的；&lt;/p&gt;
&lt;p&gt;字符串变量【char ch[] = &quot;dong xiao dong&quot;;】其指向地址的内容可变。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
#include&amp;lt;stdio.h&amp;gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main() {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;char *ch = &quot;dong xiao dong&quot;; &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;字符串常量，不可变 &lt;/span&gt;
    &lt;span&gt;char&lt;/span&gt; ch[] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dong xiao dong&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;字符数组，可变&lt;/span&gt;
    ch[&lt;span&gt;2&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;字符串常量运行这条将报错&lt;/span&gt;
    printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, ch);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可变格式的输出函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
#include&amp;lt;stdio.h&amp;gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main() {
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *ch = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dong xiao %d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    printf(ch, &lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;);
    ch &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xiaoxiao%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    printf(ch, &lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; chh[] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dongdong %d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    printf(ch, &lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;指向函数的指针&lt;/h2&gt;
&lt;p&gt;【int(*p)(int, int);//定义一个函数指针变量p】，第一个int表示返回值类型，第二个int和第三个int表示函数的参数类型。注意*p两侧的括号不能省略，表示p先与*结合，是指针变量，然后再于后面的（）结合，（）表示是函数，即该指针变量不是指向一般的变量，而是指向函数。如果写成“int * p(int,int);”,由于（）优先级高于*,它相当于“int *(p(int,int))”,就成了声明一个p函数，并且这个函数的返回值是指向整型变量的指针。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;返回值为int&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
#include&amp;lt;stdio.h&amp;gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main() {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; minto(&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt; b);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;函数声明&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt;(*p)(&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义一个函数指针变量p&lt;/span&gt;
    p = minto;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;函数指针指向函数minto首地址&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; cc = (*p)(&lt;span&gt;11&lt;/span&gt;, &lt;span&gt;55&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用函数&lt;/span&gt;
    printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Min===%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, cc);
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; minto(&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; b) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(a &amp;gt; b) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; b;
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;return&lt;/span&gt;&lt;span&gt; a;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;无返回值：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
#include&amp;lt;stdio.h&amp;gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main() {
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; fun(&lt;span&gt;int&lt;/span&gt; a);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;函数声明&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; (*p)(&lt;span&gt;int&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义一个函数指针变量p&lt;/span&gt;
    p = fun;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;函数指针指向函数fun首地址&lt;/span&gt;
    (*p)(&lt;span&gt;11&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用函数&lt;/span&gt;
&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; fun(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; a) {
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, a);  
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;指向函数指针作为函数的参数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
#include&amp;lt;stdio.h&amp;gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main() {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; fun(&lt;span&gt;int&lt;/span&gt;(*addpp)(&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;), &lt;span&gt;int&lt;/span&gt; x, &lt;span&gt;int&lt;/span&gt; y);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;函数声明&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; add(&lt;span&gt;int&lt;/span&gt; i, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; j);

    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; ii=fun(add, &lt;span&gt;11&lt;/span&gt;, &lt;span&gt;12&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;传递函数名和参数即可&lt;/span&gt;
    printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;输出相加的值为：%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, ii);
  }

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;int (*addpp)(int,int);addpp=add;&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; fun(&lt;span&gt;int&lt;/span&gt; (*addpp)(&lt;span&gt;int&lt;/span&gt;,&lt;span&gt;int&lt;/span&gt;),&lt;span&gt;int&lt;/span&gt; x,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; y){
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; cc = (*&lt;span&gt;addpp)(x, y);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cc;
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; add(&lt;span&gt;int&lt;/span&gt; i, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; j) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; i +&lt;span&gt; j;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;返回指针的函数&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
#include&amp;lt;stdio.h&amp;gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main() {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;* add(&lt;span&gt;int&lt;/span&gt; i, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; j);
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; *p = add(&lt;span&gt;10&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;&lt;span&gt;);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;输出相加的值为：%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, *&lt;span&gt;p);
  }

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;* add(&lt;span&gt;int&lt;/span&gt; i, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; j) {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; aa = i +&lt;span&gt; j;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &amp;amp;aa;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回地址&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;指针数组&lt;/h2&gt;
&lt;p&gt;一个数组其全部元素都存放着指针，就是指针数组【int * p[5];】&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
#include&amp;lt;stdio.h&amp;gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main() {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指针数组&lt;/span&gt;
    &lt;span&gt;char&lt;/span&gt; * p[] = { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dong1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xiao2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dong3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dong4&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, p[&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]);
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;进阶版&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
#include&amp;lt;stdio.h&amp;gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main() {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指针数组(字符串）&lt;/span&gt;
    &lt;span&gt;char&lt;/span&gt; * p[] = { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dong1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xiao2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dong3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dong4&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; **&lt;span&gt;pp;
    pp &lt;/span&gt;=&lt;span&gt; p;
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, *(pp+&lt;span&gt;1&lt;/span&gt;));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;转换一次就可以拿到对应字符串的首地址通过%s打印

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指针数组（整数）&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; a[&lt;span&gt;5&lt;/span&gt;]= {&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;11&lt;/span&gt;,&lt;span&gt;12&lt;/span&gt;,&lt;span&gt;13&lt;/span&gt;&lt;span&gt; };
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; * ip[] = { &amp;amp;a[&lt;span&gt;0&lt;/span&gt;],&amp;amp;a[&lt;span&gt;1&lt;/span&gt;],&amp;amp;a[&lt;span&gt;2&lt;/span&gt;],&amp;amp;a[&lt;span&gt;3&lt;/span&gt;],&amp;amp;a[&lt;span&gt;4&lt;/span&gt;&lt;span&gt;]};
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; **ppp =&lt;span&gt; ip;
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, *(*ppp+&lt;span&gt;1&lt;/span&gt;));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;转换第一次得到存储的指针，再次转换得到值&lt;/span&gt;
  }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;错误示范&lt;/h2&gt;
&lt;p&gt;1、&lt;/p&gt;
&lt;p&gt;int *p=10; //等同于：int *p; p=10;&lt;/p&gt;
&lt;p&gt;分析：非法操作，内存地址不能用户自定义。10相当于一个内存地址，该内存地址的值不确定且也不明确该地址是否可以直接访问，正确的应该是使用【&amp;amp;变量名】得到内存地址。&lt;/p&gt;

&lt;p&gt;2、&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; f = &lt;span&gt;12.3&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; *&lt;span&gt;p;
&lt;/span&gt;*p = &amp;amp;f;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;错误1&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; ff = &amp;amp;f; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;错误2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;分析：指针（地址）必须赋值给指针变量&lt;/p&gt;
</description>
<pubDate>Wed, 01 May 2019 13:27:00 +0000</pubDate>
<dc:creator>东小东</dc:creator>
<og:description>指针是什么 》》每一个内存单元只能同时存储一个数据，如何保证内存单元同时只能存储一个数据，可以使用编号的方式实现内存单元标记，此编号就是指针。 》》指针是一个变量，指针是存放着一个数据的内存地址而不是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dongxiaodong/p/10743246.html</dc:identifier>
</item>
<item>
<title>记一次OOM问题排查过程 - lovecindywang</title>
<link>http://www.cnblogs.com/lovecindywang/p/10800593.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lovecindywang/p/10800593.html</guid>
<description>&lt;p&gt;上周运维反馈线上程序出现了OOM，程序日志中的输出为&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Exception in thread &quot;http-nio-8080-exec-1027&quot; java.lang.OutOfMemoryError: Java heap space
Exception in thread &quot;http-nio-8080-exec-1031&quot; java.lang.OutOfMemoryError: Java heap space&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看线程名称应该是tomcat的nio工作线程，线程在处理程序的时候因为无法在堆中分配更多内存出现了OOM，幸好JVM启动参数配置了-XX:+HeapDumpOnOutOfMemoryError，使用MAT打开拿到的hprof文件进行分析。&lt;/p&gt;
&lt;p&gt;第一步就是打开Histogram看看占用内存最大的是什么对象：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/5/1/16a72ff9fbd9513b?w=2336&amp;amp;h=1442&amp;amp;f=png&amp;amp;s=859172&quot;/&gt;&lt;br/&gt;可以看到byte数组占用了接近JVM配置的最大堆的大小也就是8GB，显然这是OOM的原因。&lt;br/&gt;第二步看一下究竟是哪些byte数组，数组是啥内容：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/5/1/16a7303678679c97?w=1638&amp;amp;h=1434&amp;amp;f=png&amp;amp;s=1007057&quot;/&gt;&lt;br/&gt;可以看到很明显这和HTTP请求相关，一个数组大概是10M的大小。&lt;br/&gt;第三步通过查看GC根查看谁持有了数组的引用：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/5/1/16a7307cf3cc41ca?w=1920&amp;amp;h=302&amp;amp;f=png&amp;amp;s=164161&quot;/&gt;&lt;br/&gt;这符合之前的猜测，是tomcat的线程在处理过程中分配了10M的buffer在堆上。至此，马上可以想到一定是什么参数设置的不合理导致了这种情况，一般而言tomcat不可能为每一个请求分配如此大的buffer。&lt;br/&gt;第四步就是检查代码里是否有tomcat或服务器相关配置，看到有这么一个配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;max-http-header-size: 10000000&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至此，基本已经确定了八九不离十就是这个不合理的最大http请求头参数导致的问题。&lt;br/&gt;到这里还有3个疑问：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;即使一个请求分配10M内存，堆有8GB，难道当时有这么多并发吗？800个tomcat线程？&lt;/li&gt;
&lt;li&gt;参数只是设置了最大请求头10M，为什么tomcat就会一次性分配这么大的buffer呢？&lt;/li&gt;
&lt;li&gt;为什么会有如此多的tomcat线程？感觉程序没这么多并发。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;先来看问题1，这个可以通过MAT在dump中继续寻找答案。&lt;br/&gt;可以打开线程视图，搜索一下tomcat的工作线程，发现线程数量的确很多有401个，但是也只是800的一半：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/5/1/16a73127e0a2a49d?w=1722&amp;amp;h=1384&amp;amp;f=png&amp;amp;s=920561&quot;/&gt;&lt;br/&gt;再回到那些大数组的清单，按照堆分配大小排序，往下看：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/5/1/16a731484701e3b8?w=1646&amp;amp;h=1360&amp;amp;f=png&amp;amp;s=834613&quot;/&gt;&lt;br/&gt;可以发现除了有10008192字节的数组还有10000000字节的数组，查看引用路径可以看到这个正好是10M的数组是output buffer，区别于之前看到的input buffer：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/5/1/16a73137db081dc0?w=1468&amp;amp;h=412&amp;amp;f=png&amp;amp;s=217507&quot;/&gt;&lt;br/&gt;好吧，这就对了，一个线程分配了输入输出两个buffer，占用20M内存，一共401个线程，占用8GB，所以OOM了。&lt;br/&gt;还引申出一个问题为啥有这么多工作线程，&lt;/p&gt;
&lt;p&gt;再来看看问题2，这就需要来找一下源码了，首先max-http-header-size是springboot定义的参数，查看springboot代码可以看到这个参数对于tomcat设置的是MaxHttpHeaderSize：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/5/1/16a7326a1b4942de?w=1864&amp;amp;h=392&amp;amp;f=png&amp;amp;s=90147&quot;/&gt;&lt;br/&gt;然后来看看tomcat源码：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/5/1/16a7327bff9ec03a?w=1942&amp;amp;h=768&amp;amp;f=png&amp;amp;s=178901&quot;/&gt;&lt;br/&gt;进一步看一下input buffer：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/5/1/16a7329f8be52b2c?w=1610&amp;amp;h=686&amp;amp;f=png&amp;amp;s=131361&quot;/&gt;&lt;br/&gt;buffer大小是MaxHttpHeaderSize+ReadBuffer大小，这个默认是8192字节：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   &amp;lt;attribute name=&quot;socket.appReadBufSize&quot; required=&quot;false&quot;&amp;gt;
        &amp;lt;p&amp;gt;(int)Each connection that is opened up in Tomcat get associated with
        a read ByteBuffer. This attribute controls the size of this buffer. By
        default this read buffer is sized at &amp;lt;code&amp;gt;8192&amp;lt;/code&amp;gt; bytes. For lower
        concurrency, you can increase this to buffer more data. For an extreme
        amount of keep alive connections, decrease this number or increase your
        heap size.&amp;lt;/p&amp;gt;
      &amp;lt;/attribute&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这也就是为什么之前看到大量的buffer是10008192字节的。至于为什么分配的buffer需要是MaxHttpHeaderSize+ReadBuffer。显然还有一批内容是空的10000000字节的buffer应该是output buffer，源码可以印证这点：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/5/1/16a732d974f231ae?w=1564&amp;amp;h=822&amp;amp;f=png&amp;amp;s=127343&quot;/&gt;&lt;br/&gt;嗯这是一个header buffer，所以正好是10000000字节。&lt;/p&gt;
&lt;p&gt;至于问题3，显然我们的应用程序是配置过最大线程的（查看配置后发现的确，我们配置为了2000，好吧有点大），否则也不会有401个工作线程（默认150），如果当时并发并不大的话就一种可能，请求很慢，虽然并发不大，但是因为请求执行的慢就需要更多线程，比如TPS是100，但是平均RT是4s的话，就是400线程了。这个问题的答案还是可以通过MAT去找，随便看几个线程可以发现很多线程都在等待一个外部服务的返回，这说明外部服务比较慢，去搜索当时的程序日志可以发现有很多&quot;feign.RetryableException: Read timed out executing的日志&quot;。。。。追杀下游去！慢点，我们的feign的timeout也需要再去设置一下，别被外部服务拖死了。&lt;/p&gt;
</description>
<pubDate>Wed, 01 May 2019 12:05:00 +0000</pubDate>
<dc:creator>lovecindywang</dc:creator>
<og:description>上周运维反馈线上程序出现了OOM，程序日志中的输出为 看线程名称应该是tomcat的nio工作线程，线程在处理程序的时候因为无法在堆中分配更多内存出现了OOM，幸好JVM启动参数配置了 XX:+Hea</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lovecindywang/p/10800593.html</dc:identifier>
</item>
</channel>
</rss>