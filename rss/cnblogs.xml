<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>用StyleCop规范团队代码 - Catcher8</title>
<link>http://www.cnblogs.com/catcher1994/p/10375823.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/catcher1994/p/10375823.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;编码风格，每个人都是有不同的特点，风格各异，而且一个人在不同的时期，编码风格的差异也可能是非常大的，好比学生时代，刚工作的时候，工作一段时间后等。&lt;/p&gt;
&lt;p&gt;在一个团队中，或一个项目中，如果出现了N种风格，这个可能就是比较头疼了，尤其是风格差异很大的时候。&lt;/p&gt;
&lt;p&gt;一个项目一种风格或许还可以接受，如果一个项目风格都不一样，那就有点难受了，就更不用说整个团队的了。长久来看，团队之间，难免会有人员的调动，所以统一整个团队的编码风格还是很有必要的。&lt;/p&gt;
&lt;p&gt;统一了编码风格会带来什么好处呢？下面列出几点&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;便于代码审查&lt;/li&gt;
&lt;li&gt;新人(新同事/跨项目组同事)接手不会觉得杂乱无章&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;下面来先看看本文的重点StyleCop。&lt;/p&gt;
&lt;h2 id=&quot;什么是stylecop&quot;&gt;什么是StyleCop？&lt;/h2&gt;
&lt;p&gt;这里引用&lt;a href=&quot;https://en.wikipedia.org/wiki/StyleCop&quot;&gt;维基百科&lt;/a&gt;的介绍&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;StyleCop is an open-source static code analysis tool from Microsoft that checks C# code for conformance to StyleCop's recommended coding styles and a subset of Microsoft's .NET Framework Design Guidelines. StyleCop analyses the source code, allowing it to enforce a different set of rules from FxCop (which, instead of source code, checks .NET managed code assemblies). The rules are classified into the following categories:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Documentation&lt;/li&gt;
&lt;li&gt;Layout&lt;/li&gt;
&lt;li&gt;Maintainability&lt;/li&gt;
&lt;li&gt;Naming&lt;/li&gt;
&lt;li&gt;Ordering&lt;/li&gt;
&lt;li&gt;Readability&lt;/li&gt;
&lt;li&gt;Spacing&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;简单理解，开源的静态代码分析工具，用来检查代码是否符合推荐的编码风格。&lt;/p&gt;
&lt;p&gt;它的开源地址: &lt;a href=&quot;https://github.com/StyleCop/StyleCop&quot; class=&quot;uri&quot;&gt;https://github.com/StyleCop/StyleCop&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其在README的最后，建议我们(使用Visual Studio 2015或更高版本的开发人员)使用的是&lt;a href=&quot;https://github.com/DotNetAnalyzers/StyleCopAnalyzers&quot;&gt;StyleCopAnalyzers&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;所以，后面我们用到的是它，StyleCop规则基于.NET编译器(Roslyn)的实现。&lt;/p&gt;
&lt;p&gt;下面通过一个示例来介绍它的简单使用。&lt;/p&gt;
&lt;h2 id=&quot;示例&quot;&gt;示例&lt;/h2&gt;
&lt;p&gt;当我们新建一个.NET Core的控制台程序之后，大致就是下面的样子。可以看到是没有任何警告的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/558945/201902/558945-20190214173225919-379718244.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过Nuget安装StyleCop.Analyzers，或直接在csproj里面加下面的内容。&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;ItemGroup&amp;gt;
   &amp;lt;PackageReference Include=&quot;StyleCop.Analyzers&quot; Version=&quot;1.1.1-rc.94&quot;&amp;gt;
     &amp;lt;PrivateAssets&amp;gt;All&amp;lt;/PrivateAssets&amp;gt;
   &amp;lt;/PackageReference&amp;gt;
&amp;lt;/ItemGroup&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在回到&lt;code&gt;Program.cs&lt;/code&gt;，马上就可以看到有波浪线了~~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/558945/201902/558945-20190214173148436-826417358.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个时候我们需要狠一点，把项目的所有警告级别的提示都当成错误来看待。&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;PropertyGroup&amp;gt;
    &amp;lt;!-- other... --&amp;gt;
    &amp;lt;TreatWarningsAsErrors&amp;gt;true&amp;lt;/TreatWarningsAsErrors&amp;gt;
&amp;lt;/PropertyGroup&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;加了这个之后，编译就立马出错了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/558945/201902/558945-20190214173120703-1635574707.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在编译不通过时，还是ERROR级别的错，只能乖乖的去改了。&lt;/p&gt;
&lt;p&gt;按照提示，一个个修改之后，还是有一个&lt;code&gt;SA0001&lt;/code&gt;的错误提示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/558945/201902/558945-20190214173054298-1816982232.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;要修复这个问题，需要参考这个文档 &lt;a href=&quot;https://github.com/DotNetAnalyzers/StyleCopAnalyzers/blob/master/documentation/SA0001.md&quot;&gt;SA0001.md&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;启用一下生成XML文档，同时加几个禁止显示的警告即可。&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;PropertyGroup&amp;gt;
    &amp;lt;!-- other... --&amp;gt;
    &amp;lt;TreatWarningsAsErrors&amp;gt;true&amp;lt;/TreatWarningsAsErrors&amp;gt;
    &amp;lt;!-- 加下面2行,处理SA0001 --&amp;gt;
    &amp;lt;GenerateDocumentationFile&amp;gt;true&amp;lt;/GenerateDocumentationFile&amp;gt;
    &amp;lt;NoWarn&amp;gt;$(NoWarn),1573,1591,1712&amp;lt;/NoWarn&amp;gt;
&amp;lt;/PropertyGroup&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个时候再build，就不会有错误了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/558945/201902/558945-20190214173029966-1970651259.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于这么简单的一个空项目，都有不少要修改的地方，就可以知道，默认的规则是比较严格的。那么我们有没有办法避免应用某些规则呢？答案是肯定的。&lt;/p&gt;
&lt;p&gt;我们可以通过添加&lt;code&gt;代码分析规则集&lt;/code&gt;来自定义。&lt;/p&gt;
&lt;p&gt;有两个方式添加，一个是直接添加新建项；一个是通过修改分析器里面的规则集严重性，修改后会自动生成。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/558945/201902/558945-20190214172752538-114211501.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面我们通过修改两个规则来体验一下。&lt;/p&gt;
&lt;p&gt;一个是不想要上面的头部(SA1200)，一个是using可以在命名空间外面(SA1633)。&lt;/p&gt;
&lt;p&gt;下面是示例代码。&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;RuleSet Name=&quot;Demo Analyzer Rules&quot; Description=&quot;Analyzer rules for Demo.&quot; ToolsVersion=&quot;15.0&quot;&amp;gt;
  &amp;lt;Rules AnalyzerId=&quot;StyleCop.Analyzers&quot; RuleNamespace=&quot;StyleCop.Analyzers&quot;&amp;gt; 
    &amp;lt;!-- Using statements must be inside a namespace --&amp;gt;
    &amp;lt;Rule Id=&quot;SA1200&quot; Action=&quot;None&quot; /&amp;gt;
    &amp;lt;!-- The file header is missing or not located at the top of the file --&amp;gt;
    &amp;lt;Rule Id=&quot;SA1633&quot; Action=&quot;None&quot; /&amp;gt;    
  &amp;lt;/Rules&amp;gt;
&amp;lt;/RuleSet&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同时，还要修改csproj文件&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;PropertyGroup&amp;gt;
    &amp;lt;!-- other... --&amp;gt;
    &amp;lt;TreatWarningsAsErrors&amp;gt;true&amp;lt;/TreatWarningsAsErrors&amp;gt;
    &amp;lt;!-- 加下面2行,处理SA0001 --&amp;gt;
    &amp;lt;GenerateDocumentationFile&amp;gt;true&amp;lt;/GenerateDocumentationFile&amp;gt;
    &amp;lt;NoWarn&amp;gt;$(NoWarn),1573,1591,1712&amp;lt;/NoWarn&amp;gt;
    &amp;lt;!-- 加下面这行,自定义代码分析规则集 --&amp;gt;
    &amp;lt;CodeAnalysisRuleSet&amp;gt;..\test.ruleset&amp;lt;/CodeAnalysisRuleSet&amp;gt;
&amp;lt;/PropertyGroup&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;去掉代码的头部，和把using放到外面，再build一下项目，就可以正常通过了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/558945/201902/558945-20190214172938658-1609323277.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;既然可以自己定义，那么就必然有这样一个问题，每个人可能都会想把自己的习惯放开，这样的话，这个规则就是一个透明的存在了！！&lt;/p&gt;
&lt;p&gt;换句话说，必须要有一些硬性规定，必须要有一些取舍。我们可以向某些开源项目借鉴，同时在他的基础上做简单的添加删除，个人觉得应该可以适应大多数的情况了。&lt;/p&gt;
&lt;p&gt;下面放出几个觉得不错的参考。&lt;/p&gt;
&lt;p&gt;在代码分析规则集的基础上，还可以用&lt;code&gt;Stylecop.json&lt;/code&gt;来微调某些规则的行为。&lt;/p&gt;
&lt;p&gt;当把&lt;code&gt;SA1633&lt;/code&gt;恢复之后，提示的第二个选项就是添加&lt;code&gt;Stylecop.json&lt;/code&gt;配置文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/558945/201902/558945-20190214173541313-469434832.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;添加之后，还要在csproj里面做设置&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;ItemGroup&amp;gt;
    &amp;lt;AdditionalFiles Include=&quot;stylecop.json&quot; /&amp;gt;
&amp;lt;/ItemGroup&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于&lt;code&gt;Stylecop.json&lt;/code&gt;的具体配置，可以参考&lt;a href=&quot;https://github.com/DotNetAnalyzers/StyleCopAnalyzers/blob/master/documentation/Configuration.md&quot;&gt;Configuring StyleCop Analyzers&lt;/a&gt;，这里不继续展开。&lt;/p&gt;
&lt;p&gt;除了上面的办法，还可以通过安装扩展&lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=ChrisDahlberg.StyleCop&quot;&gt;StyleCop&lt;/a&gt;来处理。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/558945/201902/558945-20190214172859768-158497890.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;安装后，右击项目的时候就可以看到StyleCop相关的菜单。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/558945/201902/558945-20190214172827966-14566598.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;在团队内保持一样的编码风格，并能在开发过程中纠正相应的错误，这是编写可维护和可读代码的重要一步，同样也是代码审查的重要一步！&lt;/p&gt;
&lt;p&gt;当然，在团队内推行这类规范，还是要多多听取团队成员的意见，也要定时检查规则是否需要更新，毕竟时代在进步！只要达成一致，就是好规则，就应该要遵守。&lt;/p&gt;
&lt;p&gt;StyleCop是一个很不错的工具，用的好就是利器。可以把它和cli模板项目相结合，这样创建的新项目就都“内嵌”了一样的规则了。&lt;/p&gt;
&lt;p&gt;友情提示，在老项目添加这个要慎重，不然会有一阵阵酸爽。&lt;/p&gt;
&lt;h2 id=&quot;相关文章&quot;&gt;相关文章&lt;/h2&gt;
</description>
<pubDate>Thu, 14 Feb 2019 22:52:00 +0000</pubDate>
<dc:creator>Catcher8</dc:creator>
<og:description>用StyleCop来规范团队代码，通过一个简单的控制台程序来演示如何使用StyleCop.Analyzers</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/catcher1994/p/10375823.html</dc:identifier>
</item>
<item>
<title>《组织行为学》--情绪与工作压力及个人感悟--缓解程序员焦虑 - 超大的雪童子</title>
<link>http://www.cnblogs.com/yangsy0915/p/10381461.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yangsy0915/p/10381461.html</guid>
<description>&lt;h2&gt;个人感悟&lt;/h2&gt;
&lt;p&gt;　　本人也是程序猿出身，曾经无限的痴迷过、疯狂过、对于技术的热情达到一种疯狂状态，一起探讨技术、架构时那种无上的成就感，仿佛它便是爱情，即便随着工作的深入，角色职能逐渐模糊，多角色的承担也会跟随技术的发展。 那么从另一个角度，随着社会的发展，就像《组织行为学》中所说，每个2年基本上技术工作者拥有的技术栈都需要全方位更新，即便我们掌握其道之根本，也需要重新学习，信奉终身学习。但是，技术也是作为个体的能力体系之一，我们需要从第三者的角度，也就是上帝视角去审视自我，去审视社会，去审视整个人类生态。我们要发现其中的规律，掌握人性本身的一些规律和缺陷，从而使我们的工作效率能够进一步提升，缓解负面情绪，同时进行有效的压力管理，对自己及他人形成正向的影响，无论从技术方面、业务人员协作、社会网络关联、思维开放扩展上进行正向指导，最终能够对整个社会做出巨大贡献。&lt;/p&gt;
&lt;p&gt;　　从管理的角度，情绪管理是非常重要的一个点，因为我们毕竟生活在协作的世界，我们容易被自己已有成绩、自己所在地位、自信程度、家庭背景影响、工作环境影响、个人经历所束缚，性格特点下产生不同情况下的焦虑。那么本篇能够使我们有效的进行自我情绪管理，更好地正视自我，保证工作状态下的身心健康，朝着我们终极目标稳步前行。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;一、情绪&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　人非草木，孰能无情？我们的生活中总是充满着情绪的色彩。当苦苦追求的目标终于实现时，我们会欣喜若狂；当成功与我们擦肩而过、失之交臂时，我们会感伤无奈。当无端受到攻击、指责和伤害时，我们会满腔怒火；当企业由于经营不善而需要大幅度裁员时，我们会担惊受怕。查一查组织行为学的文献，你会发现这一领域中对情绪的关注少得可怜，这种情况直到最近才稍有改变。原因包括三方面。&lt;/p&gt;
&lt;p&gt;　　第一，工作长河中的理性神话。运作良好的组织是一个有着明确清晰的目标、进行理性选择和理性行为的组织，在这样的组织中可以成功排除人们因为焦虑、害怕、愤怒、憎恨、欢乐、悲伤等情绪而带来的人为影响。管理者试图创立的组织是排除情绪的，当然，这是不可能做到的。&lt;/p&gt;
&lt;p&gt;　　第二，不少人想你想呢情绪是有害的。情绪很少被们看做是具有建设性的，或者能够带来提高绩效的行为。平时我们提到“这个人闹情绪了”时，也暗指他产生了不慢或抵触情绪。&lt;/p&gt;
&lt;p&gt;　　第三，情绪由于其复杂性，又与行为、生理、认知等因素有着错综复杂、相互交织的关系，因此对其研究极为困难。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;（1）什么是情绪&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　情绪指的是个体受到某种刺激所产生的一种身心激动状态。情绪这一概念具有四个特点：&lt;/p&gt;
&lt;p&gt;　　　　第一，情绪不是自发的，它由刺激所引起的。&lt;/p&gt;
&lt;p&gt;　　　　第二、情绪是一种主管意识体验。个人对情绪的体验是主观的，是一种自我感受过程，它构成了情绪的心理内容。他人只能通过观察当事者的行为和表现，来推测个体的情绪状态，而不能直接通过刺激去了解其情绪。&lt;/p&gt;
&lt;p&gt;　　　　第三，伴随情绪体验同时出现的，是情绪的外部表现，包括面部表情、身体动作、手势、语调等等。即对情绪的外部表现，即这些身体各部分的动作进行量化和识别，可以帮助我们更精确地鉴别情绪。&lt;/p&gt;
&lt;p&gt;　　　　第四、情绪会产生生理唤醒。它通过测量脉搏、心率、呼吸频率、皮肤电流，来记录人们说谎时的细微情绪变化。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;（2）与情绪有关的几个概念&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　1、情绪劳动。 当员工把体力投入到工作中，他们小号的是身体劳动；当员工把智力投入到工作中，他们小号的是心理劳动。值得注意的是，大多数工作还需要付出情绪劳动。也就是说，员工要在工作当中表现出令组织满意的情绪状态。几乎所有的精彩演讲中都要包括强烈的情绪成分，才会感染他人，调动他人的积极性，不少组织已经在绩效考核当中把情绪劳动作为一个关键成分。&lt;/p&gt;
&lt;p&gt;　　　　2、情绪智力（EI）。认为它是一种“个体监控自己及他人的情绪，并识别和利用这些信息指导自己的思想和行为的能力”，它具体包括五个维度：&lt;/p&gt;
&lt;p&gt;　　　　　　自我意识：体味自我情感的能力。&lt;/p&gt;
&lt;p&gt;　　　　　　自我管理：管理自己情绪和冲动的能力。&lt;/p&gt;
&lt;p&gt;　　　　　　自我激励：面对挫折和失败依然坚持不懈的能力。&lt;/p&gt;
&lt;p&gt;　　　　　　感同身受：体味他人情感的能力。&lt;/p&gt;
&lt;p&gt;　　　　　　社会技能：处理他人情绪的能力。&lt;/p&gt;
&lt;p&gt;　　　　　　情绪智力高的个体更可能深刻意识到自己和他人的情绪，对自我内部体验的积极方面和消极方面更为开放。这种意识有助于他们对情绪做出积极的调控，从而维持自己良好的身心状态，与他人保持和谐的人际关系，对周围环境有较强的适应能力。对于那些被大家评价为工作出色的员工，其典型特点是情绪智力高，而不是认知智力高。&lt;/p&gt;
&lt;p&gt;　　　　3、情绪感受与情绪表达&lt;/p&gt;
&lt;p&gt;　　　　　　个体的实际情绪状态。而情绪表达指的是我们表现出来那些符合社会环境或组织环境的情绪。情绪表达并不是与生俱来的，它是后天学习的产物。个体的情绪感受与情绪表达常常是不同的。我们表现在众人面前的，并不总是自己的真实情感。&lt;/p&gt;
&lt;p&gt;　　　　　　不同的组织、不同的工作性质对情绪表达的要求也不相同。&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;（3）情绪的分类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　1、基本情绪与复合情绪&lt;/p&gt;
&lt;p&gt;　　　　　　　　从生物进化的角度来看，人的情绪可以分为基本情绪和复合情绪两大类。基本情绪来自于遗传，是人类与生俱来的、不学自通的、不分种族不分文化可以为全人类所理解的情绪。研究者识别出了七种基本情绪：愤怒、害怕、悲伤、快乐、厌恶、惊奇、轻蔑。&lt;/p&gt;
&lt;p&gt;　　　　　　　　而符合情绪则是由基本情绪的不同组合派生出来的，主要是后天在社会环境中学习的产物。例如，愤怒--厌恶--轻蔑组成的复合情绪可以命名为敌意；害怕--愤怒--悲伤组成的复合情绪可以命名为焦虑。&lt;/p&gt;
&lt;p&gt;　　　　　　2、罗素的环形情绪分类&lt;/p&gt;
&lt;p&gt;　　　　　　　　罗素提出情绪可以划分为两个维度，愉快度和强度。愉快度方面可以分为积极和消极两方面，强度方面可以分为高与低两个方向。由此根据两个维度可划分为四个象限以及相应的四大类情绪。愉快--高强度表示高兴类的情绪；愉快--低强度表示轻松类的情绪；不愉快--高强度表示惊恐类的情绪；不愉快--低强度表示厌烦类的情绪。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/820234/201902/820234-20190215000038422-851555645.jpg&quot; alt=&quot;&quot; width=&quot;540&quot; height=&quot;465&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　3、对情绪的解释：认知评价理论&lt;/p&gt;
&lt;p&gt;　　　　　　情绪体验是一种生理唤醒和认知评价相结合的状态，这两项因素对于情绪的产生至关重要，必不可少。研究表明，不仅仅是生理反应引发了情绪，个体对生理反应的认知和了解对于后续的情绪经验有着非常重要的影响作用。事实上，情绪状态是由认知过程（期望）、生理状态和环境因素在大脑皮层中整合的结果。那么认知过程是对过去经验的回忆和对当前情境的评估。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/820234/201902/820234-20190215000605647-2120908102.jpg&quot; alt=&quot;&quot; width=&quot;473&quot; height=&quot;207&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　这个情绪环形模型的核心部分是认知，通过认知比较器把当前的现实刺激与储存在记忆中的过去经验进行比较，当知觉分析与认知加工间出现不匹配时，认知比较器就产生信息，动员一系列的生化和神经机制，释放滑雪物质，改变脑的神经激活状态，使身体适应当前情景的要求，这种情绪就被唤醒了。&lt;/p&gt;
&lt;p&gt;　　　　　　“情绪体验不能被简单地理解为在个人或大脑中发生了什么，而要考虑和评估环境的交互作用”。在情绪活动中，个体不仅反映环境中的刺激事件对自己的影响，同时要调节自己对于刺激的反应。也就是说，情绪活动中必须有认知活动的指导，个体才可以了解环境中刺激事件的意义，才可能选择有价值、有意义的行动。因此，在情绪活动中，人们需要不断地评价事件与自身的关系。有三个层次的评价：初评价、次评价、再评价。&lt;/p&gt;
&lt;p&gt;　　　　　　初评价是指个体辨别刺激事件与自己是否有利害关系，以及这种利害关系的程度。这种状态是在无意识的条件下发生的。&lt;/p&gt;
&lt;p&gt;　　　　　　次评价是指个体对自己反应行为的调节与控制，它主要涉及人们能否控制刺激事件，以及控制的程度，也就是一种对控制力的判断。当人们要对刺激事件作出行为反应时，必须根据主观条件和客观社会规范来考虑行为的后果，从而选择有效的措施与方法。例如，当人们受到侵犯与伤害时，是采取攻击行为还是防御性为，这取决于人们对刺激事件的控制判断。在这个评价过程中，经验起着重要的作用。&lt;/p&gt;
&lt;p&gt;　　　　　　再评价是指人对自己的情绪和行为反应的有效性和适宜性的评价，实际上是一种反馈性行为。如果再评价的结果表明，该行为是无效的或不合时宜的，人们就会在下一个循环中调整自己对刺激事件的初评价和次评价，并相应地调整自己的情绪和行为反应。&lt;/p&gt;
&lt;p&gt;　　　　4、情绪组织行为中的应用&lt;/p&gt;
&lt;p&gt;　　　　　　员工甄选，了解自己的情绪病擅长解读他人情绪的人，会在工作中维持自己良好的身心状态，与他人保持和睦的人际关系，对周边有较强的适应能力。&lt;/p&gt;
&lt;p&gt;　　　　　　领导选拔，有效的领导几乎都会依赖于情绪表达来帮助他们传递信息。实际上，演讲过程中的情绪表达常常是导致个体是否接受领导者信息的一项关键变量。“当领导者表现出兴奋、热情、活跃时，他们更有可能调动下属的积极性，并传递着一种有效、胜任、乐观、喜悦的感受”。有效的领导者，还会利用积极的情绪作为社会粘合剂，使周边的人贴近他并支持他。因此，有效的领导者在实施重大变革时，他们依赖于“对情绪的唤醒和调动”。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;（4）人际冲突&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　实际上，管理者在处理冲突方面能否成功，常常在很大程度上取决于他识别冲突中情绪成分的能力，以及通过情绪力量促使冲突双方回复工作的能力。如果管理者在冲突过程中只关注理性与工作内容，忽视其中的情绪成分，很难有效地处理冲突。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;（5）组织决策&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　传统观点强调理性的作用，它们低估审视完全忽视了焦虑、害怕、失落、快乐、极度等情绪的作用。“在决策中不受情绪影响”这种假设十分优质。面对同样的客观资料，我们可以预计，当人们愤怒和承受压力时，与当它们平静和沉着时，会做出十分不同的选择。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;（6）动力功能&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　适度的情绪兴奋、积极地情绪体验，可以使身心活动处于最佳状态。它会引导并维持你的行为直到达到最终目标。它会促使人们积极地思考问题、解决困难、进而有效地完成工作任务。你会发现，“在活动过程中投入了全部身心和全部情绪”的人，会在工作中废寝忘食，而且因为工作而异常兴奋。&lt;/p&gt;
&lt;p&gt;二、工作压力&lt;/p&gt;
&lt;p&gt;　　随着就业竞争的加剧、生活节奏的加快、工作负担的加重、工作与家庭之间冲突的日益明显，工作压力正成为颇受个体和组织关注的一个问题。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;（1）什么是工作压力？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　压力指的是一种动力状态，当个体在实现对自己有着重要意义的目标的过程中，遇到机会、障碍或被要求时，便会处于压力状态。压力是环境刺激与个体反应相互作用的过程。&lt;/p&gt;
&lt;p&gt;　　　　潜在的压力情景转化为个人体会到的现实压力，具备两个关键条件：首先，是活动结果的不确定性。当面对一个具体情景时，如果个体确定不了自己能否抓住机会、突破障碍、符合要求、避免损失时，压力就会存在。所以，如果一个人无法确定自己能否成功，则压力最大；如果成百已成定局，即便是面对失败的不理状况，压力也会变小。&lt;/p&gt;
&lt;p&gt;　　　　压力虽然不可避免，但就其本身来说未必是有害的、破坏性的。尽管我们通常一提到它就会想到其负面影响，其实它也有积极的价值，会给我们带来潜在的收益。如果压力水平过低，活动效率也相对较低；当压力强度达到一个最佳水平时，此时的工作绩效最高；一旦超过了峰值状态，也就是压力过强时，又会对活动的记过产生阻碍作用。&lt;/p&gt;
&lt;p&gt;　　　　压力强度的最佳水平不是固定不变的，它根据任务性质的不同而不同。一些重大的科学发现，科学家常常会在相对轻松的时刻出现灵感，从而解决复杂问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/820234/201902/820234-20190215002907458-1500100360.jpg&quot; alt=&quot;&quot; width=&quot;400&quot; height=&quot;413&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　过度压力损害的不仅仅是工作绩效。近年来在职业领域中有一个非常流行的概念叫做 工作倦怠。指的是个体在过重工作压力下出现的一种心力衰竭、厌弃工作的综合征，有三个突出特点：自我感觉很糟、丧失成就感、待人冷漠、易受激惹、身心疲乏。同时，压力还有一个特点，它具有累加性。每一个新的压力事件都会增加个体的压力水平。也就是单向压力因素本身来说无足轻重，但如果加在已经很高的压力水平上，无疑会火上浇油，成为“压死骆驼的最后一根稻草”。如果你要评估一个员工所承受的压力水平，就必须综合累计他所经受的各种压力。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;（2）工作压力的成因与后果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　哪些因素会导致压力的产生？它给个体带来什么后果？为什么在同样条件下有些人会产生压力，但对于另外一些人却没有影响？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/820234/201902/820234-20190215003455781-317321169.jpg&quot; alt=&quot;&quot; width=&quot;610&quot; height=&quot;610&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　这个模型表名，环境、组织、个人三类因素，构成了压力的潜在来源，他们能否转变成现实压力，还取决于个体差异的调节。当个体体验压力时，会表现为四类症状：生理的、认知的、情绪的和性我的。&lt;/p&gt;
&lt;p&gt;　　　　1、潜在的压力源&lt;/p&gt;
&lt;p&gt;　　　　　　潜在的压力源包括三大类：环境因素、组织因素、个体因素。每项因素在强度、频率、持续性等方面的差异，造成压力的成都也不同。当完成工作规定的时间紧、任务重、处理的问题很复杂时，压力越大。有人统计，软件业不到两年时间技术换代一次，这意味着两年后个人所学的知识与技术大多数已被淘汰，需要从头学起。下面我们对各个压力源进行分析：&lt;/p&gt;
&lt;p&gt;　　　　　　环境因素，环境的不确定性会影响到组织中员工的压力水平。&lt;/p&gt;
&lt;p&gt;　　　　　　组织因素，组织内部也存在众多因素给我们带来压力，主要表现在任务要求、角色要求、人际关系、组织结构、工作条件等几个方面。&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/820234/201902/820234-20190215004124261-65495473.jpg&quot; alt=&quot;&quot; width=&quot;509&quot; height=&quot;293&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　任务要求指的是那些与个人工作任务有关的因素。当工作任务具有以下特点时，容易产生压力；工作负担过重，员工必须集中精力，从事高强度工作，此时很容易造成疲劳和紧张；工作任务以简单、枯燥、重复性为特点，会带来烦躁、压抑以及其他身体不适感；工作需要收集各种渠道信息，并且现有办法难以解决问题；工作责任大，稍有不慎，造成的损失不可弥补。&lt;/p&gt;
&lt;p&gt;　　　　角色要求指的是个体因为在组织中扮演特定的角色而带来的压力。个体在组织中常常扮演不止一种角色，当个体难以同时满足不同角色的不同要求时，角色冲突就会发生。作为中层管理人员，常常发现下属对自己的期待和老板对自己的期待不同时，当对公司的忠诚与对下属的关系相抵触时，压力就会产生。&lt;/p&gt;
&lt;p&gt;　　　　人际关系指的是由于个体与他人的关系而带来的压力。人是社会型动物，组织环境是大多数人满足自己社交需要和归属需要的重要场所。组织结构界定了组织的层级水平、规章制度的效力、决策在哪里进行。如果组织中的机构设置不合理、组织制度不健全、员工缺乏参与决策的机会，这些结构变量都可能成为潜在的压力源。&lt;/p&gt;
&lt;p&gt;　　　　个人因素，研究表明，个体如果在相对较短的时间内经历过多的压力事件，通常会对健康造成有害影响。&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/820234/201902/820234-20190215014540367-1580128037.jpg&quot; alt=&quot;&quot; width=&quot;691&quot; height=&quot;503&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　2、压力的调节因素：个体差异&lt;/p&gt;
&lt;p&gt;　　　　　　研究发现四项个体因素起着调节作用：个人的认知模式、工作经历、社会支持网络、性格特点。&lt;/p&gt;
&lt;p&gt;　　　　　　个体的行为基础是他们对现实的认知，而不是客观现实本身。个人的认知模式是影响压力感知的一项调节变量。有证据表明，工作经验与工作压力成负相关。有两种可能的解释，第一总会给你看法认为工作经验是个体应对压力的有效资源。工作经验越丰富，说明面对过更多的困难情境。第二种看法是选择性退缩，体会到更大压力的人员更可能会选择自动辞职，因此，在组织中工作时间较长的员工，更可能是哪些抗压素质较高的人。&lt;/p&gt;
&lt;p&gt;　　　　　　社会支持网络是周边他人提供的一种资源，它表明个体生活在一个彼此支持、相互帮助的网络当中，在此他能感受到被爱、被关心、被尊重。可以有效帮助个体缓解眼里，增强面对问题的信心和克服困难的实力。&lt;/p&gt;
&lt;p&gt;　　　　　　个体的性格特点也调节着人们对于压力的感受。有证据表明，当内控型人与外控型人面对相似情景的时候，内控者更倾向于认为自己能对行为后果产生较大的影响，因此，他们会主动采取行动以控制事态的发展，并且压力感受相对较弱。外控者更倾向于积极防守，并产生无助感。自我效能感也对压力结果产生影响，高自我效能感的人对自己的能力更有信心，更可能把压力视为挑战和机遇，而不是问题与威胁。&lt;/p&gt;
&lt;p&gt;　　　　3、压力的后果&lt;/p&gt;
&lt;p&gt;　　　　　　压力本身并不都是破坏性的，一定程度的压力会产生积极地结果。但是压力过大，也会造成相当有害的影响。会对身体产生一些影响，归纳为四类：生理症状、认知症状、情绪症状和行为症状。过度压力感使患者新陈代谢出现紊乱，降低身体对疾病的抵抗力，心率、呼吸频率加快等等。&lt;/p&gt;
&lt;p&gt;　　　　　　情绪症状，压力导致不满意感。压力的情绪反应还表现为紧张、焦虑、冲动、易怒、烦躁、悲观无助等。&lt;/p&gt;
&lt;p&gt;　　　　　　认知症状 主要表现为不能集中注意完成工作；反应速度变慢，思维模式杂乱无序，难以作出有效的决策；对自己的能力表示怀疑，常常拿不定主意，容易疲劳，健忘，错误率增加。&lt;/p&gt;
&lt;p&gt;　　　　　　行为症状 压力的行为症状包括：生产率变化、缺勤、离职、饮食习惯改变、抽烟喝酒增多、言语速度加快、烦躁、睡眠十条。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;三、对工作压力进行管理&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　&lt;strong&gt;（1）个人的解决途径&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　在降低压力水平方面，个体策略包括：掌握有效的时间管理技术，增强体育锻炼，及时倾诉，寻求帮助，学习放松训练。&lt;/p&gt;
&lt;p&gt;　　　　进行时间管理，如果能井然有序地安排时间，则可以在同样时间里更快、更多地完成工作。并运用时间管理原则，可以帮助员工更好地应对工作要求带来的压力。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/820234/201902/820234-20190215015753253-671472180.jpg&quot; alt=&quot;&quot; width=&quot;835&quot; height=&quot;214&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;（2）加强锻炼，重视休息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　每天固定抽出半小时到一小时时间，参加各种体育锻炼。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;（3）及时倾诉&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　当压力过强时，与朋友、家人、同事一起讨论，说出自己的苦闷，会给压力提供一个释放的出口。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;（4）寻求帮助&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　个体拥有的社会网络的数量和质量，对压力改善有着重要的作用。社会支持包括来自他人和群体的支持、帮助和信息提供。在需要寻求他人的帮助，千万不要让自己与社会孤立起来。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;（5）学会放松&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　个体可以自学一些放松技术来减轻压力。每天进行15分钟至30分钟的深度放松练习，有助于减轻紧张感，使人产生显著的平和感。压力放松方法如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/820234/201902/820234-20190215020204092-1824547449.jpg&quot; alt=&quot;&quot; width=&quot;751&quot; height=&quot;881&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/820234/201902/820234-20190215020233086-2087867431.jpg&quot; alt=&quot;&quot; width=&quot;796&quot; height=&quot;444&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;（6）组织的解决途径&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　1、改善甄选过程 不同员工对同一压力情景时的反应并不相同，这与员工的工作经历、人格特点等因素有关。因此，在人员甄选和配置过程中，管理者应该把这些因素考虑在内，实现个人与工作的恰当匹配。&lt;/p&gt;
&lt;p&gt;　　　　2、进行有效的目标管理  当员工拥有具体明确、富有挑战性的目标时，他们会因为降低了角色的模糊性，减少了挫败感，从而在工作中更加积极；当他们能参与目标的设置过程、有机会发表自己的一件和建议时，会因为增强了控制感，而减轻角色的压力。当他们能及时得到沟通和信息反馈，从而了解自己的工作业绩和工作表现时，更愿意付出努力改善工作水平，并在实现目标时体验到成就感。&lt;/p&gt;
&lt;p&gt;　　　　3、重新设计工作 工作任务本身是造成工作压力的主要因素之一，因此，组织可以在一定范围内设法改变一些工作内容。例如，对过于枯燥的工作进行工作扩大化和丰富化设计，使员工在工作当中拥有更多的责任，更多的意义，更大的自主性；对于负担过重的工作可以进行合理的工作分担。&lt;/p&gt;
&lt;p&gt;　　　　　但值得注意的是，并非所有员工都喜欢丰富化的工作，对于那些成就需要不高的员工，在进行工作设计时，应给他们提供工作责任较轻、工作要求具体的工作。在工作设计上，重要的一点是清洗了解个人的需要。&lt;/p&gt;
&lt;p&gt;　　　　4、增强正式沟通渠道  管理层可以运用有效的沟通作为塑造员工认知的手段。员工如果没有从正式的沟通渠道中获得充分的信息，则会利用小道消息了解信息，或者进行主观臆测，并因而出现认知失真和误解的现象。&lt;/p&gt;
&lt;p&gt;　　　　5、资助员工健康计划&lt;/p&gt;
&lt;p&gt;　　　　　　提供各种咨询活动帮助员工戒烟、戒酒、减肥、改善饮食情况、开发良好的锻炼计划。&lt;/p&gt;
&lt;h2&gt; &lt;/h2&gt;
</description>
<pubDate>Thu, 14 Feb 2019 18:12:00 +0000</pubDate>
<dc:creator>超大的雪童子</dc:creator>
<og:description>个人感悟 本人也是程序猿出身，曾经无限的痴迷过、疯狂过、对于技术的热情达到一种疯狂状态，一起探讨技术、架构时那种无上的成就感，仿佛它便是爱情，即便随着工作的深入，角色职能逐渐模糊，多角色的承担也会跟随</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yangsy0915/p/10381461.html</dc:identifier>
</item>
<item>
<title>JavaScript键盘鼠标事件处理 - 悠悠i</title>
<link>http://www.cnblogs.com/youyoui/p/10381457.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/youyoui/p/10381457.html</guid>
<description>&lt;h2 id=&quot;监听键盘鼠标事件&quot;&gt;监听键盘鼠标事件&lt;/h2&gt;
&lt;h3 id=&quot;监听某个按键事件&quot;&gt;监听某个按键事件&lt;/h3&gt;
&lt;p&gt;当键盘上的某个键被按下时，会依次触发一次下面的事件：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;onkeydown: 键盘按下这个动作（按下键盘）&lt;/li&gt;
&lt;li&gt;onkeypress: 键盘被按住（一直按着键盘不动）&lt;/li&gt;
&lt;li&gt;onkeyup: 键盘被弹起（松开键盘）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;通过监听keydown事件既可以知道键盘被按下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;document.onkeydown = function(event) {
    // 键盘按下时触发
    console.log('key down');
};

document.onkeypress = function(event) {
    // 键盘按住时触发
    console.log('key press');
};

document.onkeyup = function (event) {
    // 键盘弹起时触发
    console.log('key up');
};

// 控制台数据的顺序为：key down -&amp;gt; key press -&amp;gt; key up&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意到键盘按下的&lt;code&gt;event&lt;/code&gt;参数，该参数为&lt;code&gt;KeyboardEvent&lt;/code&gt;事件对象，其中包含按键相关的一些属性。其中：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;type: 事件类型，如'keydown'或者'keyup'&lt;/li&gt;
&lt;li&gt;key: 表示按下的键盘内容是什么即键值，按下字母'p'时，值为'p'&lt;/li&gt;
&lt;li&gt;code: 表示键盘代码，按下字母'p'时，值为'KeyP'&lt;/li&gt;
&lt;li&gt;keyCode(过时): 整数，表示键码，每个键都有唯一的键码，字母'p'的键码为80&lt;/li&gt;
&lt;li&gt;altKey: 布尔值，表示此时的alt键是否也按下&lt;/li&gt;
&lt;li&gt;ctrKey: 布尔值，表示此时的alt键是否也按下&lt;/li&gt;
&lt;li&gt;shiftKey: 布尔值，表示此时的shift键是否也按下&lt;/li&gt;
&lt;li&gt;metaKey: 布尔值，windows平台表示Window键是否同时按下，mac表示Command键是否同时按下&lt;/li&gt;
&lt;li&gt;repeat: 布尔值，如果一个键一直被按着，则其值为true，表示重复&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;可以通过检查这些属性来判断用户按下的是什么键，以及是否ctrl和alt等键是否同时按下。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;document.onkeydown = function(event) {
    // 键盘按下是触发
    console.log('key down: ' + event.key);
    if (event.altKey) {
        console.log('alt is active');
    }
    if (event.shiftKey) {
        console.log('shift is active');
    }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;监听鼠标事件&quot;&gt;监听鼠标事件&lt;/h3&gt;
&lt;p&gt;相应的也可以监听鼠标相关的事件，触发时的参数&lt;code&gt;event&lt;/code&gt;为&lt;code&gt;MouseEvent&lt;/code&gt;对象类型：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;onclick: 鼠标点击事件&lt;/li&gt;
&lt;li&gt;ondblclick: 鼠标双击事件&lt;/li&gt;
&lt;li&gt;onmousedown: 鼠标上的按钮被按下了&lt;/li&gt;
&lt;li&gt;onmouseup: 鼠标按下后松开时触发的事件&lt;/li&gt;
&lt;li&gt;onmousemove: 鼠标移动时触发的事件&lt;/li&gt;
&lt;li&gt;onmouseout: 鼠标离开监听该事件的元素或子元素时触发的事件&lt;/li&gt;
&lt;li&gt;onmouseover: 鼠标移动到监听该事件的元素或子元素时触发的事件&lt;/li&gt;
&lt;li&gt;onmousewheel: 鼠标滚轮事件，一般使用onscroll事件&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;MouseEvent&lt;/code&gt;对象中包含下面比较有用的属性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;type: 事件类型，如'mosemove'或者'mousedown'&lt;/li&gt;
&lt;li&gt;button: 整型，触发鼠标事件时按下的按钮编号&lt;/li&gt;
&lt;li&gt;buttons: 整型，触发鼠标事件时弹起来的按钮编号&lt;/li&gt;
&lt;li&gt;clientX: 鼠标指针在DOM内容区的X坐标&lt;/li&gt;
&lt;li&gt;clientY：鼠标指针在DOM内容区的Y坐标&lt;/li&gt;
&lt;li&gt;offsetX: 鼠标指针相对父节点填充边缘的X坐标&lt;/li&gt;
&lt;li&gt;offsetY: 鼠标指针相对父节点填充边缘的Y坐标&lt;/li&gt;
&lt;li&gt;screenX: 鼠标指针在全局屏幕的X坐标&lt;/li&gt;
&lt;li&gt;screenY: 鼠标指针在全局屏幕的Y坐标&lt;/li&gt;
&lt;li&gt;pageX: 鼠标指针在整个DOM内容（包括分页）的X坐标&lt;/li&gt;
&lt;li&gt;pageY: 鼠标指针在整个DOM内容（包括分页）的Y坐标&lt;/li&gt;
&lt;li&gt;altKey: 布尔值，表示此时的alt键是否也按下&lt;/li&gt;
&lt;li&gt;ctrKey: 布尔值，表示此时的alt键是否也按下&lt;/li&gt;
&lt;li&gt;shiftKey: 布尔值，表示此时的shift键是否也按下&lt;/li&gt;
&lt;li&gt;metaKey: 布尔值，windows平台表示Window键是否同时按下，mac表示Command键是否同时按下&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;通过鼠标事件的&lt;code&gt;event&lt;/code&gt;属性，可以获取鼠标点击的位置，&lt;a href=&quot;http://uusama.com/496.html&quot;&gt;这里有对各种坐标的相关介绍&lt;/a&gt;，鼠标点击时是否按住ctrl等。&lt;/p&gt;
&lt;h3 id=&quot;监听连续的按键事件实现秘笈开启&quot;&gt;监听连续的按键事件实现秘笈开启&lt;/h3&gt;
&lt;p&gt;在很多游戏中，都有隐藏的秘笈，比如上上下下左左右右BABA这样的秘笈，那么怎么在网页监听事件，能够知道用户是按下了这个秘笈呢？（才不是要在隐藏什么奇怪的东西才用这个的&amp;gt;_&amp;lt;）&lt;strong&gt;演示地址（输入秘笈真的有惊喜！）：&lt;a href=&quot;http://asset.uusama.com/example/keycode.html&quot; class=&quot;uri&quot;&gt;http://asset.uusama.com/example/keycode.html&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;实现的方法就是用一个数组来记录连续按键的状态，每次按键正确则匹配下一个，直到所有匹配成功，看下面代码：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// 上上下下左左右右BABA的键值
const secretKey = ['up', 'up', 'down', 'down', 'left', 'left', 'right', 'right', 'b', 'a', 'b', 'a'];
// 秘笈的键码
const secretKeyCode = [38, 38, 40, 40, 37, 37, 39, 39, 66, 65, 66, 65];
// 当前按键匹配的状态
let secretKeyCodeStatus = new Array(secretKeyCode.length).fill(0);
// 当前正确秘笈按键的索引
// let correctCodeIndex = 0;
const CORRECT_STATUS = 1;  // 表示正确匹配按键的状态

document.onkeydown = function(event) {
    // 查找第一个0的位置，即当前按键应该匹配的位置
    let correctCodeIndex = secretKeyCodeStatus.lastIndexOf(CORRECT_STATUS);
    correctCodeIndex = correctCodeIndex === -1 ? 0 : correctCodeIndex + 1;

    // 如果所有的按键都正确，则返回
    if (correctCodeIndex &amp;gt; secretKeyCode.length) {
        alert('你成功打开了秘笈！通往哲♂学♂之路啊，我命令你开启吧！');
        return true;
    }

    // 如果本次按键正确，则记录
    if (event.keyCode === secretKeyCode[correctCodeIndex]) {
        console.log('keyCode: ' + event.keyCode + ' code: ' + event.code + '  --correct,index:' + correctCodeIndex);
        // 所有按键都正确则成功
        if (correctCodeIndex + 1 === secretKeyCodeStatus.length) {
            alert('你成功打开了秘笈！通往哲♂学♂之路啊，我命令你开启吧！');
            // 重置状态
            secretKeyCodeStatus = new Array(secretKeyCode.length).fill(0);
            return true;
        } else {
            // 否则记录当前按键成功
            secretKeyCodeStatus[correctCodeIndex] = CORRECT_STATUS;
        }
    } else {
        console.log('keyCode: ' + event.keyCode + ' code: ' + event.code + '  --reset');
        // 按键错误则重置
        secretKeyCodeStatus = new Array(secretKeyCode.length).fill(0);
    }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;模拟键盘和鼠标事件&quot;&gt;模拟键盘和鼠标事件&lt;/h2&gt;
&lt;p&gt;上面我们说明了如何监听页面的按键和键盘事件，但是有的时候我们需要使用代码模拟按钮操作。&lt;/p&gt;
&lt;p&gt;比如看到很多图片的时候，我们需要批量下载，这个时候可以打开控制台，写一段JS代码批量模拟下载步骤即可，而不用一个一个的手动点击，非常方便。&lt;/p&gt;
&lt;h3 id=&quot;模拟鼠标点击&quot;&gt;模拟鼠标点击&lt;/h3&gt;
&lt;p&gt;最简单的就是模拟点击了，我们只需要选中一个元素，然后执行click函数即可。&lt;/p&gt;
&lt;p&gt;下面的代码实现在一个表格中，点击每一个图片。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const images = document.getElementById('content').getElementsByTagName('img');
for (let image of images) {
    images.click();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果要模拟鼠标双击，或者鼠标移动，则没有简单的函数可以调用。这个时候我们需要新建一个&lt;code&gt;MouseEvent&lt;/code&gt;对象，并手动触发即可。&lt;/p&gt;
&lt;p&gt;创建&lt;code&gt;MouseEvent&lt;/code&gt;对象的语法为：&lt;code&gt;const event = new MouseEvent(typeArg, mouseEventInit);&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;typeArg&lt;/code&gt;为鼠标事件类型，即上面的监听鼠标事件去掉&lt;code&gt;on&lt;/code&gt;后的字符串，
&lt;ul&gt;&lt;li&gt;click: 鼠标点击事件&lt;/li&gt;
&lt;li&gt;dblclick: 鼠标双击事件&lt;/li&gt;
&lt;li&gt;mousedown: 鼠标上的按钮被按下了&lt;/li&gt;
&lt;li&gt;mouseup: 鼠标按下后松开时触发的事件&lt;/li&gt;
&lt;li&gt;mousemove: 鼠标移动时触发的事件&lt;/li&gt;
&lt;li&gt;mouseout: 鼠标离开监听该事件的元素或子元素时触发的事件&lt;/li&gt;
&lt;li&gt;mouseover: 鼠标移动到监听该事件的元素或子元素时触发的事件&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mouseEventInit&lt;/code&gt;为&lt;code&gt;MouseEvent&lt;/code&gt;初始化的选项，指定鼠标事件的各种属性，可选值如下：
&lt;ul&gt;&lt;li&gt;button: 整型，触发鼠标事件时按下的按钮编号&lt;/li&gt;
&lt;li&gt;buttons: 整型，触发鼠标事件时弹起来的按钮编号&lt;/li&gt;
&lt;li&gt;clientX: 鼠标指针在DOM内容区的X坐标&lt;/li&gt;
&lt;li&gt;clientY：鼠标指针在DOM内容区的Y坐标&lt;/li&gt;
&lt;li&gt;offsetX: 鼠标指针相对父节点填充边缘的X坐标&lt;/li&gt;
&lt;li&gt;offsetY: 鼠标指针相对父节点填充边缘的Y坐标&lt;/li&gt;
&lt;li&gt;screenX: 鼠标指针在全局屏幕的X坐标&lt;/li&gt;
&lt;li&gt;screenY: 鼠标指针在全局屏幕的Y坐标&lt;/li&gt;
&lt;li&gt;pageX: 鼠标指针在整个DOM内容（包括分页）的X坐标&lt;/li&gt;
&lt;li&gt;pageY: 鼠标指针在整个DOM内容（包括分页）的Y坐标&lt;/li&gt;
&lt;li&gt;altKey: 布尔值，表示此时的alt键是否也按下&lt;/li&gt;
&lt;li&gt;ctrKey: 布尔值，表示此时的alt键是否也按下&lt;/li&gt;
&lt;li&gt;shiftKey: 布尔值，表示此时的shift键是否也按下&lt;/li&gt;
&lt;li&gt;metaKey: 布尔值，windows平台表示Window键是否同时按下，mac表示Command键是否同时按下&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;比如下面的示例在坐标200,200处触发一个鼠标双击事件：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// 创建一个event对象
const createEvent = new MouseEvent('dblclick', {
    clientX: 300,
    clientY: 300,
});

// 触发该事件
document.dispatchEvent(createEvent);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;可以使用任意的&lt;code&gt;Document&lt;/code&gt;对象的&lt;code&gt;dispatchEvent&lt;/code&gt;方法触发一个事件，这些触发的事件和实际发生的事件一模一样。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;模拟键盘输入事件&quot;&gt;模拟键盘输入事件&lt;/h3&gt;
&lt;p&gt;和模拟鼠标事件一样，不过这儿我们要创建一个&lt;code&gt;KeyboardEvent&lt;/code&gt;事件对象。&lt;/p&gt;
&lt;p&gt;创建&lt;code&gt;KeyboardEvent&lt;/code&gt;对象的语法类似为：&lt;code&gt;const event = new KeyboardEvent(typeArg, KeyboardEventInit);&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;typeArg&lt;/code&gt;为键盘输入事件类型，即上面的监听键盘输入事件去掉&lt;code&gt;on&lt;/code&gt;后的字符串，
&lt;ul&gt;&lt;li&gt;keydown: 键盘按下这个动作&lt;/li&gt;
&lt;li&gt;keypress: 键盘被按住&lt;/li&gt;
&lt;li&gt;keyup: 键盘被弹起&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;KeyboardEventInit&lt;/code&gt;为&lt;code&gt;KeyboardEvent&lt;/code&gt;初始化的选项，指定键盘输入事件的各种属性，可选值如下：
&lt;ul&gt;&lt;li&gt;type: 事件类型，如'keydown'或者'keyup'&lt;/li&gt;
&lt;li&gt;key: 表示按下的键盘内容是什么即键值，按下字母'p'时，值为'p'&lt;/li&gt;
&lt;li&gt;code: 表示键盘代码，按下字母'p'时，值为'KeyP'&lt;/li&gt;
&lt;li&gt;keyCode(过时): 整数，表示键码，每个键都有唯一的键码，字母'p'的键码为80&lt;/li&gt;
&lt;li&gt;altKey: 布尔值，表示此时的alt键是否也按下&lt;/li&gt;
&lt;li&gt;ctrKey: 布尔值，表示此时的alt键是否也按下&lt;/li&gt;
&lt;li&gt;shiftKey: 布尔值，表示此时的shift键是否也按下&lt;/li&gt;
&lt;li&gt;metaKey: 布尔值，windows平台表示Window键是否同时按下，mac表示Command键是否同时按下&lt;/li&gt;
&lt;li&gt;repeat: 布尔值，如果一个键一直被按着，则其值为true，表示重复&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;比如实现在按下字母'a'键时，自动按下'alt+ctrl+a'可以像下面实现。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// 监听按键事件
document.onkeydown = function(event) {
    console.log('keyCode: ' + event.keyCode + ' code: ' + event.code + ' alt:' + event.altKey);
    if (event.keyCode === 65 || event.code === 'KeyA') {
        // 如果按下的是a键，则新建一个a键按下的事件并触发
        const createEvent = new KeyboardEvent('keydown', {
            altKey: true,
            shiftKey: true,
            keyCode: 65,
            code: 'KeyA'
        });
        document.dispatchEvent(createEvent);
    }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后你就会发现上面的函数疯狂的输出A键被按下，哈哈哈！知道内存达到限制！&lt;/p&gt;
&lt;h2 id=&quot;附录&quot;&gt;附录&lt;/h2&gt;
&lt;p&gt;最后附上键值和键码的对应关系对象，可以直接拷贝使用：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const keyCodes = {
    0: 'That key has no keycode',
    3: 'break',
    8: 'backspace / delete',
    9: 'tab',
    12: 'clear',
    13: 'enter',
    16: 'shift',
    17: 'ctrl',
    18: 'alt',
    19: 'pause/break',
    20: 'caps lock',
    21: 'hangul',
    25: 'hanja',
    27: 'escape',
    28: 'conversion',
    29: 'non-conversion',
    32: 'spacebar',
    33: 'page up',
    34: 'page down',
    35: 'end',
    36: 'home',
    37: 'left arrow',
    38: 'up arrow',
    39: 'right arrow',
    40: 'down arrow',
    41: 'select',
    42: 'print',
    43: 'execute',
    44: 'Print Screen',
    45: 'insert',
    46: 'delete',
    47: 'help',
    48: '0',
    49: '1',
    50: '2',
    51: '3',
    52: '4',
    53: '5',
    54: '6',
    55: '7',
    56: '8',
    57: '9',
    58: ':',
    59: 'semicolon (firefox), equals',
    60: '&amp;lt;',
    61: 'equals (firefox)',
    63: 'ß',
    64: '@ (firefox)',
    65: 'a',
    66: 'b',
    67: 'c',
    68: 'd',
    69: 'e',
    70: 'f',
    71: 'g',
    72: 'h',
    73: 'i',
    74: 'j',
    75: 'k',
    76: 'l',
    77: 'm',
    78: 'n',
    79: 'o',
    80: 'p',
    81: 'q',
    82: 'r',
    83: 's',
    84: 't',
    85: 'u',
    86: 'v',
    87: 'w',
    88: 'x',
    89: 'y',
    90: 'z',
    91: 'Windows Key / Left ⌘ / Chromebook Search key',
    92: 'right window key',
    93: 'Windows Menu / Right ⌘',
    95: 'sleep',
    96: 'numpad 0',
    97: 'numpad 1',
    98: 'numpad 2',
    99: 'numpad 3',
    100: 'numpad 4',
    101: 'numpad 5',
    102: 'numpad 6',
    103: 'numpad 7',
    104: 'numpad 8',
    105: 'numpad 9',
    106: 'multiply',
    107: 'add',
    108: 'numpad period (firefox)',
    109: 'subtract',
    110: 'decimal point',
    111: 'divide',
    112: 'f1',
    113: 'f2',
    114: 'f3',
    115: 'f4',
    116: 'f5',
    117: 'f6',
    118: 'f7',
    119: 'f8',
    120: 'f9',
    121: 'f10',
    122: 'f11',
    123: 'f12',
    124: 'f13',
    125: 'f14',
    126: 'f15',
    127: 'f16',
    128: 'f17',
    129: 'f18',
    130: 'f19',
    131: 'f20',
    132: 'f21',
    133: 'f22',
    134: 'f23',
    135: 'f24',
    144: 'num lock',
    145: 'scroll lock',
    160: '^',
    161: '!',
    162: '؛ (arabic semicolon)',
    163: '#',
    164: '$',
    165: 'ù',
    166: 'page backward',
    167: 'page forward',
    168: 'refresh',
    169: 'closing paren (AZERTY)',
    170: '*',
    171: '~ + * key',
    172: 'home key',
    173: 'minus (firefox), mute/unmute',
    174: 'decrease volume level',
    175: 'increase volume level',
    176: 'next',
    177: 'previous',
    178: 'stop',
    179: 'play/pause',
    180: 'e-mail',
    181: 'mute/unmute (firefox)',
    182: 'decrease volume level (firefox)',
    183: 'increase volume level (firefox)',
    186: 'semi-colon / ñ',
    187: 'equal sign',
    188: 'comma',
    189: 'dash',
    190: 'period',
    191: 'forward slash / ç',
    192: 'grave accent / ñ / æ / ö',
    193: '?, / or °',
    194: 'numpad period (chrome)',
    219: 'open bracket',
    220: 'back slash',
    221: 'close bracket / å',
    222: 'single quote / ø / ä',
    223: '`',
    224: 'left or right ⌘ key (firefox)',
    225: 'altgr',
    226: '&amp;lt; /git &amp;gt;, left back slash',
    230: 'GNOME Compose Key',
    231: 'ç',
    233: 'XF86Forward',
    234: 'XF86Back',
    235: 'non-conversion',
    240: 'alphanumeric',
    242: 'hiragana/katakana',
    243: 'half-width/full-width',
    244: 'kanji',
    251: &quot;unlock trackpad (Chrome/Edge)&quot;,
    255: 'toggle touchpad',
};

// 压缩之后的
const keyCodesMin={0:&quot;That key has no keycode&quot;,3:&quot;break&quot;,8:&quot;backspace / delete&quot;,9:&quot;tab&quot;,12:&quot;clear&quot;,13:&quot;enter&quot;,16:&quot;shift&quot;,17:&quot;ctrl&quot;,18:&quot;alt&quot;,19:&quot;pause/break&quot;,20:&quot;caps lock&quot;,21:&quot;hangul&quot;,25:&quot;hanja&quot;,27:&quot;escape&quot;,28:&quot;conversion&quot;,29:&quot;non-conversion&quot;,32:&quot;spacebar&quot;,33:&quot;page up&quot;,34:&quot;page down&quot;,35:&quot;end&quot;,36:&quot;home&quot;,37:&quot;left arrow&quot;,38:&quot;up arrow&quot;,39:&quot;right arrow&quot;,40:&quot;down arrow&quot;,41:&quot;select&quot;,42:&quot;print&quot;,43:&quot;execute&quot;,44:&quot;Print Screen&quot;,45:&quot;insert&quot;,46:&quot;delete&quot;,47:&quot;help&quot;,48:&quot;0&quot;,49:&quot;1&quot;,50:&quot;2&quot;,51:&quot;3&quot;,52:&quot;4&quot;,53:&quot;5&quot;,54:&quot;6&quot;,55:&quot;7&quot;,56:&quot;8&quot;,57:&quot;9&quot;,58:&quot;:&quot;,59:&quot;semicolon (firefox), equals&quot;,60:&quot;&amp;lt;&quot;,61:&quot;equals (firefox)&quot;,63:&quot;ß&quot;,64:&quot;@ (firefox)&quot;,65:&quot;a&quot;,66:&quot;b&quot;,67:&quot;c&quot;,68:&quot;d&quot;,69:&quot;e&quot;,70:&quot;f&quot;,71:&quot;g&quot;,72:&quot;h&quot;,73:&quot;i&quot;,74:&quot;j&quot;,75:&quot;k&quot;,76:&quot;l&quot;,77:&quot;m&quot;,78:&quot;n&quot;,79:&quot;o&quot;,80:&quot;p&quot;,81:&quot;q&quot;,82:&quot;r&quot;,83:&quot;s&quot;,84:&quot;t&quot;,85:&quot;u&quot;,86:&quot;v&quot;,87:&quot;w&quot;,88:&quot;x&quot;,89:&quot;y&quot;,90:&quot;z&quot;,91:&quot;Windows Key / Left ⌘ / Chromebook Search key&quot;,92:&quot;right window key&quot;,93:&quot;Windows Menu / Right ⌘&quot;,95:&quot;sleep&quot;,96:&quot;numpad 0&quot;,97:&quot;numpad 1&quot;,98:&quot;numpad 2&quot;,99:&quot;numpad 3&quot;,100:&quot;numpad 4&quot;,101:&quot;numpad 5&quot;,102:&quot;numpad 6&quot;,103:&quot;numpad 7&quot;,104:&quot;numpad 8&quot;,105:&quot;numpad 9&quot;,106:&quot;multiply&quot;,107:&quot;add&quot;,108:&quot;numpad period (firefox)&quot;,109:&quot;subtract&quot;,110:&quot;decimal point&quot;,111:&quot;divide&quot;,112:&quot;f1&quot;,113:&quot;f2&quot;,114:&quot;f3&quot;,115:&quot;f4&quot;,116:&quot;f5&quot;,117:&quot;f6&quot;,118:&quot;f7&quot;,119:&quot;f8&quot;,120:&quot;f9&quot;,121:&quot;f10&quot;,122:&quot;f11&quot;,123:&quot;f12&quot;,124:&quot;f13&quot;,125:&quot;f14&quot;,126:&quot;f15&quot;,127:&quot;f16&quot;,128:&quot;f17&quot;,129:&quot;f18&quot;,130:&quot;f19&quot;,131:&quot;f20&quot;,132:&quot;f21&quot;,133:&quot;f22&quot;,134:&quot;f23&quot;,135:&quot;f24&quot;,144:&quot;num lock&quot;,145:&quot;scroll lock&quot;,160:&quot;^&quot;,161:&quot;!&quot;,162:&quot;؛ (arabic semicolon)&quot;,163:&quot;#&quot;,164:&quot;$&quot;,165:&quot;ù&quot;,166:&quot;page backward&quot;,167:&quot;page forward&quot;,168:&quot;refresh&quot;,169:&quot;closing paren (AZERTY)&quot;,170:&quot;*&quot;,171:&quot;~ + * key&quot;,172:&quot;home key&quot;,173:&quot;minus (firefox), mute/unmute&quot;,174:&quot;decrease volume level&quot;,175:&quot;increase volume level&quot;,176:&quot;next&quot;,177:&quot;previous&quot;,178:&quot;stop&quot;,179:&quot;play/pause&quot;,180:&quot;e-mail&quot;,181:&quot;mute/unmute (firefox)&quot;,182:&quot;decrease volume level (firefox)&quot;,183:&quot;increase volume level (firefox)&quot;,186:&quot;semi-colon / ñ&quot;,187:&quot;equal sign&quot;,188:&quot;comma&quot;,189:&quot;dash&quot;,190:&quot;period&quot;,191:&quot;forward slash / ç&quot;,192:&quot;grave accent / ñ / æ / ö&quot;,193:&quot;?, / or °&quot;,194:&quot;numpad period (chrome)&quot;,219:&quot;open bracket&quot;,220:&quot;back slash&quot;,221:&quot;close bracket / å&quot;,222:&quot;single quote / ø / ä&quot;,223:&quot;`&quot;,224:&quot;left or right ⌘ key (firefox)&quot;,225:&quot;altgr&quot;,226:&quot;&amp;lt; /git &amp;gt;, left back slash&quot;,230:&quot;GNOME Compose Key&quot;,231:&quot;ç&quot;,233:&quot;XF86Forward&quot;,234:&quot;XF86Back&quot;,235:&quot;non-conversion&quot;,240:&quot;alphanumeric&quot;,242:&quot;hiragana/katakana&quot;,243:&quot;half-width/full-width&quot;,244:&quot;kanji&quot;,251:&quot;unlock trackpad (Chrome/Edge)&quot;,255:&quot;toggle touchpad&quot;,};&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 14 Feb 2019 16:48:00 +0000</pubDate>
<dc:creator>悠悠i</dc:creator>
<og:description>监听键盘鼠标事件 监听某个按键事件 当键盘上的某个键被按下时，会依次触发一次下面的事件： onkeydown: 键盘按下这个动作（按下键盘） onkeypress: 键盘被按住（一直按着键盘不动） o</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/youyoui/p/10381457.html</dc:identifier>
</item>
<item>
<title>Springboot 系列（二）Spring Boot 配置文件 - 雪漫士兵</title>
<link>http://www.cnblogs.com/niumoo/p/10375227.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/niumoo/p/10375227.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：本 Spring Boot 系列文章基于 Spring Boot 版本 &lt;strong&gt;v2.1.1.RELEASE&lt;/strong&gt; 进行学习分析，版本不同可能会有细微差别。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2626549-88300780e01c5d1f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;不管是通过官方提供的方式获取 Spring Boot 项目，还是通过 IDEA 快速的创建 Spring Boot 项目，我们都会发现在 resource 有一个配置文件 &lt;code&gt;application.properties&lt;/code&gt;,也有可能是&lt;code&gt;application.yml&lt;/code&gt;.这个文件也就是 Spring Boot 的配置文件。&lt;/p&gt;
&lt;h2 id=&quot;yaml-文件&quot;&gt;1. YAML 文件&lt;/h2&gt;
&lt;p&gt;在 &lt;code&gt;Spring Boot&lt;/code&gt; 中，官方推荐使用 &lt;code&gt;properties&lt;/code&gt; 或者 &lt;code&gt;YAML&lt;/code&gt; 文件来完成配置，对于 &lt;code&gt;YAML&lt;/code&gt; 文件格式还不了解的可以查看官方的具体格式，这里只做简单介绍。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;YAML 语法规则：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;大小写敏感&lt;/li&gt;
&lt;li&gt;缩进表示层级&lt;/li&gt;
&lt;li&gt;缩进只能使用空格&lt;/li&gt;
&lt;li&gt;空格的数量不重要，但是相同层级的元素要左侧对齐&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#&lt;/code&gt; 开头的行表示注释&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;YAML 支持的数据结构：&lt;/strong&gt;&lt;/p&gt;
&lt;ol readability=&quot;5.5&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;单纯的变量，不可再分的单个的值，如数字，字符串等。&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;name: Darcy
age: 12
# ~表示NULL值
email: ~ 
# 多行字符串可以使用|保留换行符，也可以使用&amp;gt;折叠换行。
# +表示保留文字块末尾的换行，-表示删除字符串末尾的换行。
message:|-
  Hello world&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;数组，一组按次序排列的值。&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;lang:
 - java
 - golang
 - c
# 或者行内写法
lang:[java,golang,c]&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;对象，键值对的集合。&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;person:
  name:Darcy
  age:20
# 或者行内写法
person:{name:Darcy,age:20}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;使用 &lt;code&gt;YAML&lt;/code&gt; 支持的三种数据结构通过组合可以形成复杂的复合结构。&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;# 服务启动端口号
server:
  port: 8080
# 配置person属性值
person:
  last-name: Darcy
  age: 20
  birth: 2018/01/01
  email: gmail@gmail.com
  maps:
    key1:java
    key2:golang
  lists:
  - a
  - b
  - c
  dog:
    name: 旺财
    age: 2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要注意的是 &lt;code&gt;YAML&lt;/code&gt; 文件不能使用&lt;code&gt;@PropertySource&lt;/code&gt; 加载&lt;/p&gt;
&lt;h2 id=&quot;properties-文件&quot;&gt;2. Properties 文件&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;properties&lt;/code&gt; 配置文件简单好用，在各种配置环境里都可以看到它的身影，它简单易用，但是在配置复杂结构时不如&lt;code&gt;YAML&lt;/code&gt; 优雅美观。同样拿上面的 &lt;code&gt;YAML&lt;/code&gt; 的复合结构举例，演示同样的配置在 &lt;code&gt;properties&lt;/code&gt;文件中的写法。&lt;/p&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;# 服务启动端口号
server.port=8080
# 配置属性值（使用IDE进行配置需要处理编码问题，不然中文会发送乱码现象）
person.last-name=张三
person.age=18
person.birth=2018/12/06
person.email=niu@gmail.com
person.maps.key1=c
person.maps.key2=java
person.maps.key3=golang
person.lists=a,b,c,d
person.dog.name=旺财
person.dog.age=1&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;随机数与占位符&quot;&gt;3. 随机数与占位符&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;RandomValuePropertySource&lt;/code&gt; 类对于注入随机值很有用（例如，注入秘密或测试用例）。它可以生成整数，长整数，uuid 或字符串等，通过 Spring Boot 对我们的封装，我们可以轻松的使用。&lt;/p&gt;
&lt;p&gt;占位符允许在配置的值中引用之前定义过的变量。&lt;/p&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;# 生成随机值
bootapp.secret=$ {random.value}
bootapp.number=$ {random.int}
bootapp.bignumber=$ {random.long}
bootapp.uuid=$ {random.uuid}
bootapp.number.less.than.ten=$ {random.int（10）}
bootapp.number.in.range=$ {random.int [1024,65536]}
# 属性的占位符
bootapp.name=SpringBoot
bootapp.description=${bootapp.name}是一个spring应用程序&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;配置的使用&quot;&gt;4. 配置的使用&lt;/h2&gt;
&lt;p&gt;通过上面的介绍，可以发现不管是使用 &lt;code&gt;YAML&lt;/code&gt; 还是 &lt;code&gt;Properties&lt;/code&gt; 都可以进行配置文件的编写，但是还不知道具体的使用方式，通过下面的几个注解，可以让我们了解到这些配置的具体使用方式。&lt;/p&gt;
&lt;p&gt;在使用配置之前，添加所需依赖。&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt; &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt;
            &amp;lt;optional&amp;gt;true&amp;lt;/optional&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;!-- 导入配置文件处理器，在配置相关文件时候会有提示 --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-configuration-processor&amp;lt;/artifactId&amp;gt;
            &amp;lt;optional&amp;gt;true&amp;lt;/optional&amp;gt;
        &amp;lt;/dependency&amp;gt;

    &amp;lt;/dependencies&amp;gt;

    &amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;configurationproperties&quot;&gt;4.1 ConfigurationProperties&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;@ConfigurationProperties&lt;/code&gt; 注解是 &lt;code&gt;Spring Boot&lt;/code&gt; 提供的一种使用属性的注入方法。不仅可以方便的把配置文件中的属性值与所注解类绑定，还支持松散绑定，JSR-303 数据校验等功能。以上面演示的 &lt;code&gt;Properties&lt;/code&gt; 的配置为例演示 &lt;code&gt;@ConfigurationProperties&lt;/code&gt; 注解的使用。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;
import org.springframework.validation.annotation.Validated;

import javax.validation.constraints.Email;
import java.util.Date;
import java.util.List;
import java.util.Map;

/**
 * &amp;lt;p&amp;gt;
 * @Author niujinpeng
 * @Date 2018/12/6 22:54
 */

@Data
@Component
@ConfigurationProperties(prefix = &quot;person&quot;)
@Validated
public class Person {
    private String lastName;
    private Integer age;
    private Date birth;
    private Map&amp;lt;String, String&amp;gt; maps;
    private List&amp;lt;String&amp;gt; lists;
    private Dog dog;
    /**
     * 支持数据校验
     */
    @Email
    private String email;

}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;@Data&lt;/code&gt; 是 Lombok 的注解，会为这个类所有属性添加 getting 和 setting 方法，此外还提供了equals、canEqual、hashCode、toString 方法。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Component&lt;/code&gt; 自动添加 bean 到 spring 容器中。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@ConfigurationProperties&lt;/code&gt; 告诉这个类的属性都是配置文件里的属性，prefix 指定读取配置文件的前缀。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;value&quot;&gt;4.2 Value&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;@Value&lt;/code&gt; 支持直接从配置文件中读取值，同时支持 SpEL 表达式，但是不支持复杂数据类型和数据验证，下面是具体的使用。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import lombok.Data;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;
import org.springframework.validation.annotation.Validated;

import javax.validation.constraints.Email;
import java.util.Date;
import java.util.List;
import java.util.Map;

@Data
@Component
@Validated
public class PersonValue {

    /**
     * 直接从配置文件读取一个值
     */
    @Value(&quot;${person.last-name}&quot;)
    private String lastName;

    /**
     * 支持SpEL表达式
     */
    @Value(&quot;#{11*4/2}&quot;)
    private Integer age;

    @Value(&quot;${person.birth}&quot;)
    private Date birth;

    /**
     * 不支持复杂类型
     */
    private Map&amp;lt;String, String&amp;gt; maps;
    private List&amp;lt;String&amp;gt; lists;
    private Dog dog;

    /**
     * 不支持数据校验
     */
    @Email
    @Value(&quot;xxx@@@@&quot;)
    private String email;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;编写单元测试代码测试代码查看属性绑定是否成功。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
import net.codingme.boot.domain.Person;
import net.codingme.boot.domain.PersonValue;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.MediaType;
import org.springframework.test.context.junit4.SpringRunner;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.request.MockMvcRequestBuilders;

import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@RunWith(SpringRunner.class)
@SpringBootTest
@AutoConfigureMockMvc
public class HelloApplicationTests {

    @Autowired
    private MockMvc mvc;
    @Autowired
    private Person person;
    @Autowired
    private PersonValue personValue;

    /**
     * 模拟请求测试
     *
     * @throws Exception
     */
    @Test
    public void testGetHello() throws Exception {
        mvc.perform(MockMvcRequestBuilders.get(&quot;/&quot;).accept(MediaType.APPLICATION_JSON))
                .andExpect(status().isOk())
                .andExpect(content().string(&quot;Greetings from Spring Boot!&quot;));
    }

    /**
     * 测试@ConfigurationProperties
     */
    @Test
    public void testPersion() {
        System.out.println(person);
    }

    /**
     * 测试@Value 引入配置值
     */
    @Test
    public void testPersionValue() {
        System.out.println(personValue);
    }


}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行发现数据已经正常绑定。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2626549-ae5d07c48f67f2ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;单元测试&quot;/&gt;&lt;/div&gt;
&lt;p&gt;通过上面的示例，也可以发现 &lt;code&gt;@ConfigurationProperties&lt;/code&gt; 和 &lt;code&gt;@Value&lt;/code&gt;的区别。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;功能&lt;/td&gt;
&lt;td&gt;批量注入配置文件属性&lt;/td&gt;
&lt;td&gt;一个一个注入&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;松散绑定（松散的语法）&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;SpEL&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;JSR-303 数据校验&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;复杂类型&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;code&gt;@ConfigurationProperties&lt;/code&gt; 和 &lt;code&gt;@Value&lt;/code&gt;的使用场景。&lt;/p&gt;
&lt;p&gt;如果说，只是在某个业务逻辑中获取配置文件的某个值，使用 &lt;code&gt;@Value&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;如果说，专门编写有一个 Java Bean 来和配置文件映射，使用 &lt;code&gt;@ConfigurationProperties&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&quot;propertysource&quot;&gt;4.3 PropertySource&lt;/h3&gt;
&lt;p&gt;随着业务复杂性的增加，配置文件也越来越多，我们会觉得所有的配置都写在一个 properties 文件会使配置显得繁杂不利于管理，因此希望可以把映射属性类的配置单独的抽取出来。由于 Spring Boot 默认读取&lt;code&gt;application.properties&lt;/code&gt;，因此在抽取之后之前单独的&lt;code&gt;@ConfigurationProperties(prefix = &quot;person&quot;)&lt;/code&gt;已经无法读取到信息。这是可以使用 &lt;code&gt;@PropertySource&lt;/code&gt; 注解来指定要读取的配置文件。&lt;/p&gt;
&lt;p&gt;需要注意的是，使用 &lt;code&gt;@PropertySource&lt;/code&gt; 加载自定义的配置文件，，由于 &lt;code&gt;@PropertySource&lt;/code&gt; 指定的文件会优先加载，所以如果在 &lt;code&gt;applocation.properties&lt;/code&gt; 中存在相同的属性配置，会覆盖前者中对于的值。&lt;/p&gt;
&lt;p&gt;如果抽取 &lt;code&gt;person&lt;/code&gt; 配置为单独文件&lt;code&gt;domain-person.properties&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.PropertySource;
import org.springframework.stereotype.Component;
import org.springframework.validation.annotation.Validated;
import javax.validation.constraints.Email;
import java.util.Date;
import java.util.List;
import java.util.Map;

/**
 * &amp;lt;p&amp;gt;
 * @Author niujinpeng
 * @Date 2018/12/6 22:54
 */

@Data
@Component
@Validated
@PropertySource(value = &quot;classpath:domain-person.properties&quot;)
@ConfigurationProperties(value = &quot;person&quot;)
public class PersonSource {

    private String lastName;
    private Integer age;
    private Date birth;
    private Map&amp;lt;String, String&amp;gt; maps;
    private List&amp;lt;String&amp;gt; lists;
    private Dog dog;

    /**
     * 支持数据校验
     */
    @Email
    private String email;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;多环境配置&quot;&gt;5. 多环境配置&lt;/h2&gt;
&lt;p&gt;在主配置文件编写的时候，文件名可以是 &lt;code&gt;application-{name}.properties&lt;/code&gt;.默认使用的是&lt;code&gt;application.properties&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&quot;properties-多环境&quot;&gt;5.1 properties 多环境&lt;/h3&gt;
&lt;p&gt;那么如何在配置文件中激活其他的配置文件呢？只需要在 &lt;code&gt;application.properties&lt;/code&gt; 启用其他文件。&lt;/p&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;# 激活 application-prod.properties文件
spring.profiles.active=prod&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;yaml-多环境&quot;&gt;5.2 YAML 多环境&lt;/h3&gt;
&lt;p&gt;如果是使用 YAML 配置文件，我们可以使用文件块的形式，在一个 YAML 文件就可以达到多文件配置的效果，下面是 Spring Boot 使用 YAML 文件进行多环境配置的方式。&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;server:
  port: 8083
  profiles:
    active: dev # 指定环境为dev
# 使用三个---进行文档块区分
---
server:
  port: 8084
spring:
  profiles: dev
---
server:
  port: 8085
spring:
  profiles: prod&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;多环境激活方式&quot;&gt;5.3 多环境激活方式&lt;/h3&gt;
&lt;p&gt;除了以上的两种配置文件激活方式之外，还有另外两种种激活方式。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;命令行 ，运行时添加 &lt;code&gt;--spring.profiles.active=prod&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Jvm 参数 ，运行时添加 &lt;code&gt;-Dspring.profiles.active=prod&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果需要激活其他的配置文件，可以使用 &lt;code&gt;spring.config.location=G:/application.properties&lt;/code&gt; 进行配置。&lt;/p&gt;
&lt;h2 id=&quot;配置文件加载顺序&quot;&gt;6. 配置文件加载顺序&lt;/h2&gt;
&lt;p&gt;配置文件默认会从四个地方加载，且优先级从高到低。优先级高的配置会覆盖优先级低的配置。如果多个位置的配置同时存在，不同的配置信息会形成互补配置。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;-file: ./config/
-file: ./
-classpath: /config/
-classpath: /&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;外部配置文件&quot;&gt;7. 外部配置文件&lt;/h2&gt;
&lt;p&gt;Spring Boot 的外部配置文件加载的方式有很多，具体可以参考&lt;a href=&quot;https://docs.spring.io/spring-boot/docs/2.1.x/reference/html/boot-features-external-config.html&quot;&gt;官方文档&lt;/a&gt;。这写配置加载优先级从高到底，优先级高的配置会覆盖优先级低的配置。&lt;/p&gt;
&lt;p&gt;下面介绍几种常见的加载配置的顺序。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;命令行参数运行，所有的配置都可以在命令行上执行，多个配置空格隔开。&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;java -jar springboot-0.0.1-SNAPSHOT.jar --server.port=9999 --sercer.context-path=/spring&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;jar 包目录下的 application-{profile}.properties （或yml）文件&lt;/li&gt;
&lt;li&gt;jar 包里的 application-{profile}.properties （或yml）文件&lt;/li&gt;
&lt;li&gt;jar 包目录下的 application.properties （或yml）文件&lt;/li&gt;
&lt;li&gt;jar 包里下的 application.properties （或yml）文件&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;文章代码已经上传到 GitHub &lt;a href=&quot;https://github.com/niumoo/springboot/tree/master/springboot-properties&quot;&gt;Spring Boot 配置文件&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&amp;lt;完&amp;gt;&lt;br/&gt;本文原发于个人博客：&lt;a href=&quot;https://www.codingme.net/&quot; class=&quot;uri&quot;&gt;https://www.codingme.net&lt;/a&gt; 转载请注明出处&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2626549-e1b06fdf782b78e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 14 Feb 2019 16:40:00 +0000</pubDate>
<dc:creator>雪漫士兵</dc:creator>
<og:description>注意：本 Spring Boot 系列文章基于 Spring Boot 版本 v2.1.1.RELEASE 进行学习分析，版本不同可能会有细微差别。 前言 不管是通过官方提供的方式获取 Spring</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/niumoo/p/10375227.html</dc:identifier>
</item>
<item>
<title>我是如何在毕业不久只用1年就升为开发组长的 - 李新杰</title>
<link>http://www.cnblogs.com/lixinjie/p/how-i-to-be-a-leader-of-develop-in-only-a-year.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lixinjie/p/how-i-to-be-a-leader-of-develop-in-only-a-year.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;故事的开篇&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;br/&gt;把时钟拨回到9年前，那是2010年的10月份，李大胖入职了新公司，在公司本部呆了一个多月，就被发往客户单位进行驻场开发。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;公司给客户做的系统，需要不断的二次开发和维护，所以直接去客户单位比较利于工作的进行。&lt;/p&gt;&lt;p&gt;一个周五的下午，经理把我叫到办公室，说到：“下周你就去客户现场吧，我们有些同事在那里，那里是有门禁的，需要有人接你才行”。&lt;/p&gt;&lt;p&gt;然后就把一个同事的手机号给了我，说到了就给他打电话，他会接你。就暂且把这位同事称作“阿兵”吧。&lt;/p&gt;&lt;p&gt;此时刚刚毕业1年多点儿，不过好在客户单位也不太远。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;什么是甲方&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;周一的早上，我坐公交车来到了客户单位。大门口虽有保安，不过可以随意出入。我就进去来到了枢纽楼下面，掏出手机拨打经理给我的号码。&lt;/p&gt;&lt;p&gt;不一会下来一个人，就是阿兵，个头不太高，大概1米7多一点儿，人很随和。他带着我刷了门禁，乘电梯来到了15楼。&lt;/p&gt;&lt;p&gt;周围是一圈办公室，中间是个很大的大厅。跟网吧似的，放着一排排的桌子、凳子和台式机。&lt;/p&gt;&lt;p&gt;里面坐的大部分人都和我一样，是别的公司的，来这里为客户服务的。我就坐到了阿兵的边上，由于我刚来，用的还是客户单位的电脑。&lt;/p&gt;&lt;p&gt;不一会阿兵说要带我去见客户，就是负责我们公司相关业务的那个对接人。估计公司已经提前告诉客户了，今天要来一个新的开发。&lt;/p&gt;&lt;p&gt;我们来到了客户的工位，也是这个大厅里，不过在另一个角落。客户是个女的，30多岁，个子很矮。我们坐到她旁边，听她讲着。&lt;/p&gt;&lt;p&gt;初到一个新环境，我习惯性地抬头环顾四周，不料被客户发现了，她直接怼了过来：“看什么看，我是让你来干活的，还是瞎看的”。&lt;/p&gt;&lt;p&gt;我没有吭声，只是不敢再乱看了，心想客户脾气这么暴。估计是她在讲解，我没有认真听，她觉得是不尊重她吧。我当时是这样认为的。&lt;/p&gt;&lt;p&gt;事后阿兵跟我说，人家是甲方，牛逼的很，我们只不过是给人家服务而已。以前我也只是知道在签合同的时候有甲方乙方。&lt;/p&gt;&lt;p&gt;今天我算是领略了什么是甲方，甲方就是爷。乙方TMD就是孙子，即使不是，也得给我装成孙子。&lt;/p&gt;&lt;p&gt;事实证明我的理解没错，在接下来的日子里，我们一群1米7、8的血气方刚的大老爷们被这个不到1米6的客户无数次的批评，体无完肤，连头都抬不起来。真的就像是灰太狼遇到了红太郎，就差上平底锅了。&lt;/p&gt;&lt;p&gt;PS：我没有批判甲方的意思，只是我们运气不好，遇到的客户脾气不太好而已。相信绝大多数甲方和乙方都成了好朋友，毕竟买卖不在友情在，抬头不见低头见。&lt;/p&gt;&lt;p&gt;客户单位当时还是比较偏僻的，周围没有卖饭的，不过人家单位有食堂。中午阿兵请我在食堂吃了一顿饭，一般码农都不善言谈，也不太会跟别人客气，所以当时我连一句谢谢都没说。&lt;/p&gt;&lt;p&gt;在此我想对他说声，“谢谢”，虽然已经迟到了9年。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;找到原因了&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;没有培训，没有文档，阿兵大概给我讲了讲项目，又做了些必要的演示，然后我就开始自己慢慢熟悉、消化。&lt;/p&gt;&lt;p&gt;不久，来了一个需求，没有需求文档，是客户口头说的，说完就走了。阿兵就开始干了。&lt;/p&gt;&lt;p&gt;如果没有特别说明，就是一周时间开发完成并上线。因为周二、周四是例行上线日，我们项目组是周四上。&lt;/p&gt;&lt;p&gt;此后客户没再来找阿兵，阿兵也没去找过客户。&lt;/p&gt;&lt;p&gt;在周四的晚上，阿兵首先把新开发的需求打好包，然后停掉tomcat，把老的包备份出去，把新的包添加进来，然后启动tomcat。接着自己测试一下，走一遍流程，发现没有问题。最后给客户发邮件，表明上线成功了。然后就回家了。&lt;/p&gt;&lt;p&gt;第二天刚上班不一会，客户就气冲冲的跑了过来，对着阿兵就吼：“你做的什么东西呀，不是我要的啊，你要我说多少遍需求你才能明白呢”。&lt;/p&gt;&lt;p&gt;很显然，阿兵没有真正明白客户想要的，做的东西不对。看来一场暴风骤雨是跑不掉了。&lt;/p&gt;&lt;p&gt;此后，这种戏码经常性的不断上演，我渐渐的似乎明白了。&lt;/p&gt;&lt;p&gt;我想没有哪个人愿意在一见面就给对方一顿痛批的。我想客户在家里也一定是一个贤妻良母、小鸟依人（这真的是我想的）。&lt;/p&gt;&lt;p&gt;为什么她面对我们的时候就跟老虎似的。因为我们团队在现场做的东西老是出问题（当然其它团队也出问题），渐渐的就恶化了跟我们的关系。久而久之她对我们整个公司的所有团队态度都不好。&lt;/p&gt;&lt;p&gt;于是就有了第一次见面时就给我来了个“下马威”。&lt;/p&gt;&lt;p&gt;事实证明我想的是对的，因为后来我真的看到了客户对我的微笑，这其实是很难得的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;我要改变吗&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;丑媳妇儿早晚要见公婆。作为新手司机的我，终于要上路了。&lt;/p&gt;&lt;p&gt;客户照例过来传达一个口头需求，然后就走了。感觉跟宣读圣旨似的。然后我捋捋思绪，就开始做了。&lt;/p&gt;&lt;p&gt;在做的过程中，如果你仔细思考的话，会发现有很多问题。毕竟客户都是做业务的，从业务到需求的转化哪有那么容易呀。&lt;/p&gt;&lt;p&gt;此时我该怎么办呢？也像阿兵那样不考虑那么多直接做吗，还是选择一个我认为最合理的方法去做呢？&lt;/p&gt;&lt;p&gt;不管选择哪个，万一最后做出来与客户想要的又不一样呢，岂不是又是一场暴风雨。这样的话我和别人还有什么区别呢？&lt;/p&gt;&lt;p&gt;思索再三，我不能这样做。我要去找客户问清楚，虽然是硬着头皮去的。&lt;/p&gt;&lt;p&gt;来到客户工位旁，“X老师，你好，你刚才说的XX地方是不是可以这样理解”，“是的，没错”，客户说到。“那XX地方是不是可以那样理解”，“不是那样的，应该是这样的”，客户继续说到。&lt;/p&gt;&lt;p&gt;就这样一问一答，不一会功夫，我的所有疑问都解决了，道谢之后就回去继续干活。&lt;/p&gt;&lt;p&gt;其实我发现客户并不是那么难沟通，且沟通后做出来的东西，不管是好还是坏，至少和客户的想法保持一致。&lt;/p&gt;&lt;p&gt;有时候开发时发现客户的想法并不是最优解，我能想到更好的解决方案，此时就会去向客户表明我的意见，有时客户也会选择听我的。&lt;/p&gt;&lt;p&gt;慢慢地发现，客户和我们团队的关系缓和一些。客户和我的关系一直都还可以，因为我从来了之后基本没有犯过错。&lt;/p&gt;&lt;p&gt;有时候需求并不是客户直接提的，而是客户的其它部门的同事提的，如果让客户再从中间倒一下嘴，不仅费时费力，而且容易出错。此时我就说，你告诉我她在几楼，工位是哪个，我直接去找她。&lt;/p&gt;&lt;p&gt;就这样，我认识了一位14楼的姐姐，之所以叫姐姐是因为她人真的很好，后来在路上她看到我，特意降下车窗和我打招呼。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;更大的挑战&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;14楼的这位姐姐就称她为“时姐”吧。起初去找时姐，是为了沟通和确认需求，这样一来二去我们就渐渐地熟悉起来。&lt;/p&gt;&lt;p&gt;关系处的还不错，因为我觉得她人很好，她觉得我也不错。（此处省略一万字）她的女儿都即将要上小学了。&lt;/p&gt;&lt;p&gt;有一次时姐把我叫下去，竟然不是谈需求，而是告诉了我她的一个“大胆”的想法。&lt;/p&gt;&lt;p&gt;她有一项日常工作，就是把集团网站上的派给各个省的任务中和本省有关的任务都找出来，把这些网页内容和其中的附件都倒腾到我们做的这个系统里，再派给和任务相关的科室主任去查阅，科室主任看到后，再派给具体员工去完成这个任务，这些任务通常还有最晚完成时间节点的限制。&lt;/p&gt;&lt;p&gt;一方面，这些工作就是复制/粘贴网页内容，下载/上传附件，非常机械无聊。二来呢，好多任务具有时效性，不能一天看一次，必须时时地刷刷集团网站，看有没有新的任务。&lt;/p&gt;&lt;p&gt;目前这个工作都是她手动完成的，有时她需要提前下班去接孩子，就必须委托给其他人做这个事情，因为万一漏掉紧急任务，整个人都会不好的。&lt;/p&gt;&lt;p&gt;她跟我说，这个事情能不能做成自动的？我明白她的意思，然后就说，我回去先试试吧，应该可以的。&lt;/p&gt;&lt;p&gt;这里涉及到两个技术问题：&lt;/p&gt;&lt;p&gt;一是要定时刷集团网站，找到指定页面，获取页面内容，下载其中的附件。&lt;/p&gt;&lt;p&gt;二是想办法把这些网页内容和下载的附件，弄到我们的系统里。&lt;/p&gt;&lt;p&gt;先谈谈第二个问题，此时我对系统已经比较熟悉了，而且很早就知道一个工具叫做HttpWatch。在平时的开发测试中，都会使用这个工具查看当我在页面上点了按钮后，浏览器往服务器端发送的数据到底是什么样子的。&lt;/p&gt;&lt;p&gt;因为经常看，所以对这个比较熟悉。当没有附件时，默认使用application/x-www-form-urlencoded编码body，表单字段都是以key/value对的形式发送的。&lt;/p&gt;&lt;p&gt;当有附件时，必须以multipart/form-data编码body，此时表单字段和附件都是以分割线和回车换行来一部分一部分分开的。每部分都有字段的类型、名字和具体内容，如果是文件的话，就是文件的内容。当然，没有附件时，也可以使用这种方式。&lt;/p&gt;&lt;p&gt;后来上网搜索发现Apache HttpComponents可以以编程的方式发送http请求。我的初步想法就是拼凑模拟法。&lt;/p&gt;&lt;p&gt;浏览器往服务器端发送什么样的数据，我使用代码发送一模一样的数据，理论上即使服务器端认出来不是浏览器发送的，但因数据格式一样，也能够正常解析执行。&lt;/p&gt;&lt;p&gt;于是我使用代码拼凑出来HttpWatch里看到的body格式的内容，并把它们写入二进制文件里。然后使用HttpComponents设置好相同的Headers，并把这个二进制文件作为实体往服务器端POST。&lt;/p&gt;&lt;p&gt;套用岳云鹏的一句台词，我的天呢（再配上贱萌的表情），竟然成功了。&lt;/p&gt;&lt;p&gt;然后再来谈谈第一个问题。如何定时刷集团网站，复制网页内容和下载附件。说来还真是巧合，接着往下看就知道了。&lt;/p&gt;&lt;p&gt;我们公司既有Java项目也有.NET项目。在客户这边有一种小项目叫业务探测。因为客户有很多重要系统，要保证它们可用，在不可用时要及时发现并处理。&lt;/p&gt;&lt;p&gt;当时的做法就是定时刷页面，模拟人工登陆，在失败时发出告警。这个模拟就是用.NET做的，因为.NET是以控件打天下的，在它的toolbox中就有浏览器控件，把它拖到WinForm上，简直跟浏览器差不多。&lt;/p&gt;&lt;p&gt;而且还可以使用C#代码操作它，比如导航到某个页面啦，获取页面元素啦，往输入框里填值了，点击某个按钮了，非常之好用。&lt;/p&gt;&lt;p&gt;为什么我会对这个这么熟悉呢？因为我一开始就是学.NET的，只是现在是写Java的，不过在不忙时，也用.NET搞过几把业务探测。&lt;/p&gt;&lt;p&gt;这就给了我一个很明确的方向，在Java的世界中也一定有浏览器组件，而且可以使用Java语言来操作这个组件。可见多学点知识还是有好处的吧。&lt;/p&gt;&lt;p&gt;在网上一番搜索，终于找到了我想要的东西，它里面有一个测试用的demo，是一个Swing写的WinForm界面的浏览器，我大喜，直接用它了。&lt;/p&gt;&lt;p&gt;然后就使用Java代码操作浏览器组件进行页面导航，有一个问题是这个导航是异步的，因网速不同，所以页面完全加载好所花费的时间也不一样。&lt;/p&gt;&lt;p&gt;理论上在页面加载好后应该有一个回调，来告知页面已经OK了，可以去里面寻找html元素了，可惜我没找到这个回调。&lt;/p&gt;&lt;p&gt;当时就采取了一个笨方法，就是每次导航后等待5秒。然后就认为页面已经OK了，可以进行下一步了。&lt;/p&gt;&lt;p&gt;定位到页面元素后，直接使用innerHTML获取网页内容。定位到附件标签后，获取下载链接，再使用HttpComponents下载附件。&lt;/p&gt;&lt;p&gt;至此，所有的技术点都已经搞定了，然后就整体整合起来，也是OK的。有点小兴奋。&lt;/p&gt;&lt;p&gt;这一切都是在工作不忙时弄的，前前后后大概花了不到2个月。&lt;/p&gt;&lt;p&gt;然后就去找时姐，因为还有2个业务问题需要确定：&lt;/p&gt;&lt;p&gt;一是怎么判断任务和本省有关&lt;/p&gt;&lt;p&gt;二是怎么判断这个任务该派给哪个科室的领导&lt;/p&gt;&lt;p&gt;我跟时姐说，程序只能机械的模拟，它什么都不懂。&lt;/p&gt;&lt;p&gt;时姐说任务里有时会带省份名称，但有时不带。为了保证不漏掉内容，那就不判断了，全部任务都弄下来。第一个问题解决了。&lt;/p&gt;&lt;p&gt;第二个问题就更简单了，程序无论如何都不可能理解网页里的内容的，更不可能知道派给谁。时姐说那就每个科室都派一遍。&lt;/p&gt;&lt;p&gt;跟时姐这样的人沟通就是爽快，宁可错杀一千，绝不放过一个。这也是一种解决方案呀。&lt;/p&gt;&lt;p&gt;至此，业务问题也全部OK了。接下来就是部署了。&lt;/p&gt;&lt;p&gt;这是一个以个人名义做得东西，而且只能部署到windows系统上，就找了一个空闲的机器部署上了。&lt;/p&gt;&lt;p&gt;虽然是以个人名义免费给客户做的，但是如果真的出了问题，还是要承担部分责任的。因为甲方虽然在我们面前很牛逼，但是在集团面前她们也是被考核对象，哈哈。&lt;/p&gt;&lt;p&gt;通过网上搜索，我把这个Java桌面程序打包成了一个exe文件，然后配置到windows的定时任务里。&lt;/p&gt;&lt;p&gt;程序会在早上上班后开始运行，每小时执行一次，在晚上下班后自动退出。如果中途程序无故退出时，定时任务会把它再起起来。&lt;/p&gt;&lt;p&gt;为了更保险起见，还会把每次执行结果自动发邮件给时姐和我。&lt;/p&gt;&lt;p&gt;后来这个程序运行了很长一段时间，从来没出过问题。&lt;/p&gt;&lt;p&gt;当时之所以答应时姐，是因为一方面技术理论上可行，二是它能把一个人解放出来，去从事更有意义的事情。&lt;/p&gt;&lt;p&gt;也许搞编程的都有一种情怀吧，能让计算机干的重复无聊的工作，决不让人干。&lt;/p&gt;&lt;p&gt;这下可火了，时姐每次见到客户都一个劲的夸我，我终于看到了客户对我的微笑了。&lt;/p&gt;&lt;p&gt;客户仿佛对我们这个公司的印象都变好了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;终究被认可&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;后来随着项目组的调整，客户对原来的组长不太满意，正好他也不想干了，于是客户就像我们公司推荐让我当开发组长。&lt;/p&gt;&lt;p&gt;客户组团对我就行了面谈，其中一个人说到，如何提高软件质量，即上线时不要老出问题。她说需要一个专门的测试人员进行测试。因为我们那时没有测试人员，都是开发自己测自己的。&lt;/p&gt;&lt;p&gt;我当时说，一个工厂生产出来的产品好坏，不取决于质检部门，而是由生产车间决定的。（不过后来还是招了个测试）&lt;/p&gt;&lt;p&gt;一个项目一开始测出来的bug越多，测了几轮后没有bug了，并不是说明bug被测完了，而是剩下很多阴性的bug不容被测出来了而已。&lt;/p&gt;&lt;p&gt;就好比一个大池塘，第一网捞出来的鱼越多，说明池塘里的鱼越多，随着你的捕捞，鱼只会变少，但不会没有，除非把水抽干。&lt;/p&gt;&lt;p&gt;就这样，不管是鬼使神差的，还是命中注定的，我成了开发组长。&lt;/p&gt;&lt;p&gt;除此之外，我还收到了甲方给我颁发的优秀服务合作标兵证书和1000元购物卡，还有我们公司给我的优秀员工证书和1000元现金。&lt;/p&gt;&lt;p&gt;证书我就不晒了吧。当然卡和钱当时就被我媳妇儿弄跑了。&lt;/p&gt;&lt;p&gt;那么，我能当好这个开发组长吗，请关注后续讲解。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;如果觉得好看，请点个赞吧，或留下你的精彩评论。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;


&lt;p&gt;（完）&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;更多精彩故事请关注“编程新说”&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr data-width=&quot;80%&quot;/&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;用独特的视角说技术&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201901/76066-20190124185847216-1263582225.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 14 Feb 2019 16:36:00 +0000</pubDate>
<dc:creator>李新杰</dc:creator>
<og:description>故事的开篇 把时钟拨回到9年前，那是2010年的10月份，李大胖入职了新公司，在公司本部呆了一个多月，就被发往客户单位进行驻场开发。 公司给客户做的系统，需要不断的二次开发和维护，所以直接去客户单位比</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lixinjie/p/how-i-to-be-a-leader-of-develop-in-only-a-year.html</dc:identifier>
</item>
<item>
<title>第一章.java&amp;golang的区别之:闭包 - mantu</title>
<link>http://www.cnblogs.com/mantu/p/10381316.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mantu/p/10381316.html</guid>
<description>&lt;p&gt;对于golang一直存有觊觎之心，但一直苦于没有下定决心去学习研究，最近开始接触golang。就我个人来说，学习golang的原动力是因为想要站在java语言之外来审视java和其它语言的区别，再就是想瞻仰一下如此NB的语言。年前就想在2019年做一件事情，希望能从各个细节处做一次java和golang的对比分析，不评判语言的优劣，只想用简单的语言和可以随时执行的代码来表达出两者的区别和底层涉及到的原理。今天是情人节，馒头妈妈在加班，送给自己一件贴心的礼物，写下第一篇对比文章：java&amp;amp;golang的区别之:闭包。&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;java8之前的闭包&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在java8之前，java其实就已经对闭包有了一定层面的支持，实现的闭包方式主要是靠匿名类来实现的，下面是java程序员经常写的一段代码：&lt;/p&gt;
&lt;div readability=&quot;35&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ClosureBeforeJava8 {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; y = 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; x = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         ClosureBeforeJava8 closureBeforeJava8 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ClosureBeforeJava8();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         Runnable run =&lt;span&gt; closureBeforeJava8.getRunnable();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(run).start();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Runnable getRunnable() {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; x = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         Runnable run = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;16  &lt;br/&gt;&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                 System.out.println(&quot;local varable x is:&quot; +&lt;span&gt; x);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;System.out.println(&quot;member varable y is:&quot; + this.y); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;error&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        };
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; run;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上段代码的输出：&lt;em&gt;local varable x is:0&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;在代码的第13行到第20行，通过匿名类的方式实现了Runnable接口的run()方法，实现了一部分操作的集合(run方法)，并将这些操作映射为java的对象，在java中就可以实现将函数以变量的方式进行传递了，如果仅仅是传递函数指针，那还不能算是闭包，我们再注意第17行代码，在这段被封装可以在不同的java对象间传递的代码，引用了上层方法的局部变量，这个就有些闭包的意思在里面了。但是第18行被注释掉的代码在匿名类的情况下却无法编译通过，也就是封装的函数里面，无法引用上层方法所在对象的成员变量。总结一下，java8之前的闭包特点如下：&lt;/p&gt;
&lt;p&gt;1.可以实现封装的函数在jvm里进行传递，可以在不同的对象里进行调用；&lt;/p&gt;
&lt;p&gt;2.被封装的函数，可以调用上层的方法里的局部变量，但是此局部变量必须为final，也就是不可以更改的(基础类型不可以更改，引用类型不可以变更地址)；&lt;/p&gt;
&lt;p&gt;3.被封装的函数，不可以调用上层方法所在对象的成员变量；&lt;/p&gt;
&lt;div readability=&quot;43&quot;&gt;
&lt;ul&gt;&lt;li&gt;java8里对闭包的支持&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;java8里对于闭包的支持，其实也就是lamda表达式，我们再来看一下上段代码在lamda表达式方式下的写法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ClosureInJava8 {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; y = 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception{
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; x = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         ClosureInJava8 closureInJava8 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ClosureInJava8();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         Runnable run =&lt;span&gt; closureInJava8.getRunnable();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         Thread thread1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(run);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        thread1.start();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        thread1.join();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(run).start();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Runnable getRunnable() {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; x = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         Runnable run = () -&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;              &lt;br/&gt;&lt;span&gt;18&lt;/span&gt;             System.out.println(&quot;local varable x is:&quot; +&lt;span&gt; x);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             System.out.println(&quot;member varable y is:&quot; + &lt;span&gt;this&lt;/span&gt;.y++&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        };
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; run;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 上面对代码输出：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;local varable x is:0&lt;/em&gt;&lt;br/&gt;&lt;em&gt;member varable y is:1&lt;/em&gt;&lt;br/&gt;&lt;em&gt;local varable x is:0&lt;/em&gt;&lt;br/&gt;&lt;em&gt;member varable y is:2&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;在代码的第16行到第20行，通过lamda表达式的方式实现了函数的封装（关于lamda表达式的用法，大家可以自行google）。通过代码的输出，大家可以发现，在lamda表达式的书写方式下，封装函数不但可以引用上层方法的effectively final类型(java8的特性之一，其实也是final类型)的局部变量，还可以引用上层方法所在对象的成员变量，并可以在其它线程和方法中对此成员变量进行修改。总结一下：java8对于闭包支持的特点如下：&lt;/p&gt;
&lt;p&gt;1.通过lamda表达式的方式可以实现函数的封装，并可以在jvm里进行传递；&lt;/p&gt;
&lt;p&gt;2.lamda表达式，可以调用上层的方法里的局部变量，但是此局部变量必须为final或者是effectively final，也就是不可以更改的(基础类型不可以更改，引用类型不可以变更地址)；&lt;/p&gt;
&lt;p&gt;3.lamda表达式，可以调用和修改上层方法所在对象的成员变量；&lt;/p&gt;
&lt;p&gt;由于还没时间分析jdk和hotspot的源码，在此只能猜测推理，第2点和第3点的情况。关于第2点：上层方法的局部变量必须是final修饰的，网上的文章大部分都是说因为多线程并发的原因，无法在lamda表达式里进行修改上层方法的局部变量，这点上我是不同意这个观点的。我认为主要原因是：java在定义局部变量时，对于基础类型都是创建在stack frame上的，而一个方法执行完毕后，此方法所对应的stack frame也就没有意义了，试想一下，lamda表达式所依赖的上层方法的局部变量的存储区(stack frame)都消失了，我们还怎么能够修改这个变量，这是毫无意义的，在java里也很难实现这一点，除非像golang一下，在特定情况下，更改局部变量的存储区域(在heap里存储)。关于第3点：实现起来就比较容易，就是在lamda表达式的对象里，创建一个引用地址，地址指向原上层方法所在对象的堆存储地址即可。&lt;/p&gt;
&lt;div readability=&quot;30.5&quot;&gt;
&lt;ul&gt;&lt;li&gt;golang里对闭包的支持&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;golang里对于闭包的支持，理解起来就非常容易了，就是函数可以作为变量来传递使用，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; main
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; &quot;fmt&quot;
&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;func main()  {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     ch := make(chan &lt;span&gt;int&lt;/span&gt; ,1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     ch2 := make(chan &lt;span&gt;int&lt;/span&gt; ,1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     fn :=&lt;span&gt; closureGet()
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    go func() {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        fn()
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         ch &amp;lt;-1
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }()
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    go func() {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        fn()
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         ch2 &amp;lt;-1
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }()
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &amp;lt;-&lt;span&gt;ch
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &amp;lt;-&lt;span&gt;ch2
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;func closureGet() func(){
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     x := 1
&lt;span&gt;23&lt;/span&gt;     y := 2
&lt;span&gt;24&lt;/span&gt;     fn :=&lt;span&gt; func(){
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         x = x +&lt;span&gt;y
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         fmt.Printf(&quot;local varable x is:%d y is:%d \n&quot;&lt;span&gt;, x, y)
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; fn
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码输出如下：&lt;/p&gt;
&lt;p&gt;local varable x is:3 y is:2&lt;br/&gt;local varable x is:5 y is:2&lt;/p&gt;
&lt;p&gt;代码的第24行到27行，定义了一个方法fn，此方法可以使用上层方法的局部变量，总结一下：&lt;/p&gt;
&lt;p&gt;1.golang的闭包在表达形式上，理解起来非常容易，就是函数可以作为变量，来直接传递；&lt;/p&gt;
&lt;p&gt;2.golang的封装函数可以没有限制的使用上层函数里的局部变量，并且在不同的goroutine里修改的值，都会有所体现。&lt;/p&gt;
&lt;p&gt;关于第2点，大家可以参考文章：https://studygolang.com/articles/11627  中关于golang闭包的讲解部分。&lt;/p&gt;
&lt;p&gt;golang的闭包从语言的简洁性、理解的难易程度、支持的力度上来说，确实还是优于java的。本文作为java和golang对比分析的第一篇文章，由于调研分析的时间有限，难免有疏忽之处，欢迎各位指正。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Thu, 14 Feb 2019 16:32:00 +0000</pubDate>
<dc:creator>mantu</dc:creator>
<og:description>对于golang一直存有觊觎之心，但一直苦于没有下定决心去学习研究，最近开始接触golang。就我个人来说，学习golang的原动力是因为想要站在java语言之外来审视java和其它语言的区别，再就是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mantu/p/10381316.html</dc:identifier>
</item>
<item>
<title>最新 robot framework安装 - 虫师</title>
<link>http://www.cnblogs.com/fnng/p/10363371.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fnng/p/10363371.html</guid>
<description>&lt;p&gt;相信大家对robot framework并不陌生，它是一个基于Python语言，用于验收测试和验收测试驱动开发（ATDD）的通用测试自动化框架=，提供了一套特定的语法，并且有非常丰富的测试库。&lt;/p&gt;

&lt;h3 id=&quot;python&quot;&gt;&lt;a href=&quot;https://www.python.org/&quot;&gt;Python&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;现在可以使用Python3.x了，因为距离Python2.x停止维护也只剩一年时间了。&lt;/p&gt;

&lt;h3 id=&quot;robot-framework&quot;&gt;&lt;a href=&quot;https://pypi.org/project/robotframework/&quot;&gt;Robot framework&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;基于Python的robot framework测试框架，robot framework使用了一套特定语法，学习起来需要一定的门槛。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/311516/201902/311516-20190211221620521-583175565.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;pip安装：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;pip install robotframework&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;robot-framework-ride&quot;&gt;&lt;a href=&quot;https://pypi.org/project/robotframework-ride/&quot;&gt;Robot framework-RIDE&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;这是robot framework标配的IDE，就像PyCharm之于python，不！它对于robot framework来说它更加重要，对于上面的部份robot framework语法，在RIDE中其实可以通过配置完成。这就导致不少测试同学脱离了RIDE根本不会用robot framework。&lt;/p&gt;
&lt;p&gt;虽然，robot framework也提供了一些主流编辑器（Eclipse、Sublime、Notepad++等）的插件，但是，这些插件也仅限于语法着色这种简单的功能。&lt;/p&gt;
&lt;p&gt;然而，RIDE基于wxPython库开发，这是Python下面的一个GUI库，尴尬的是wxPython在很长的一段时间中都不支持Python3.x，这就导致RIDE无法支持Python3.x。所以，很多robot framework的使用者依然坚持使用Python2.x，只为了可以用RIDE。&lt;/p&gt;
&lt;p&gt;但是，在这个2019新年上班的第一天，我突然发现RIDE项目复活了….&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/robotframework/RIDE/&quot; class=&quot;uri&quot;&gt;https://github.com/robotframework/RIDE/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最新版本1.7.3.1基于wxPython4.0.4，此时的wxPython当然也是支持Python3.x的了。&lt;/p&gt;
&lt;p&gt;这对于robot framework的推广和使用无疑是非常有利的。&lt;/p&gt;
&lt;p&gt;pip安装：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;pip install robotframework-ride&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过执行C:\Python36\Scripts\ride.py文件启动RIDE。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;&amp;gt; cd C:\Python36\Scripts
&amp;gt; python ride.py&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/311516/201902/311516-20190211221641458-648452805.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最新的RIDE页面并没有什么变化，不过logo好像变了！将我以前的robot framework测试用例导入，依然可以很好的运行。&lt;/p&gt;
</description>
<pubDate>Thu, 14 Feb 2019 16:16:00 +0000</pubDate>
<dc:creator>虫师</dc:creator>
<og:description>最新 robot framework安装</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fnng/p/10363371.html</dc:identifier>
</item>
<item>
<title>【图解】我使用过的 Dubbo 和 Spring Cloud - 史亚健</title>
<link>http://www.cnblogs.com/shiyajian/p/10381335.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shiyajian/p/10381335.html</guid>
<description>&lt;p&gt;自从2015年毕业开始从事 Java 开发工作，已经过去3年多了， 在各种不知名的小公司待过，经历过生产力从低到高，技术从落后到先进的过程， Dubbo 和 Spring Cloud 就是我曾经所经历过的两次技术变革。微服务这个概念已经出现好多年了，但是最近几年微服务异常火爆，很多以前使用 Dubbo 的公司也在纷纷尝试转型。Dubbo 好还是 Spring Cloud 好，有啥差异，有啥优缺点是人们常常讨论的话题，很多知名大V也纷纷写一些科普文章，我也拜读过很多，读完感受良多，也激起了我写这篇文章的动力。这篇文章更多的不是解释概念，而是讲述我曾经使用到的两种技术的方式，希望大家可以从文章中获得启发。&lt;/p&gt;
&lt;h2 id=&quot;原生状态&quot;&gt;原生状态&lt;/h2&gt;
&lt;p&gt;如果以前关注过 Dubbo ，对 Dubbo 印象最深的一个定位就是 ”服务治理“的概念。为什么要服务治理？服务治理到底治理了什么方面？这是我们遇到的最直观的问题。&lt;/p&gt;
&lt;p&gt;下面就展示下我们曾经没有使用 Dubbo 的业务模型：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1221720/201902/1221720-20190214233642899-299437322.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;大体的业务如下：&lt;/p&gt;
&lt;p&gt;1、我们有项目A，和项目B，项目A由项目管理部负责使用，项目B由物流部负责使用；&lt;/p&gt;
&lt;p&gt;2、每当项目管理部在项目A中完成一个项目，那么就必须发请求给项目B，通知项目B进行物流发货；&lt;/p&gt;
&lt;p&gt;3、项目B物流完成之后给项目A发送一个请求，完成物流操作，告知项目A进入结算。&lt;/p&gt;
&lt;p&gt;根据图看的话，无非就是两个项目互相调用，在没用采用 Dubbo 之前，我们的项目结构就像图中那样混乱，很多问题都是不可避免的。下面我就把所有遇到的问题一一进行列举，以项目A为例，：&lt;/p&gt;
&lt;p&gt;1、开发者由于自身综合素质不高，没有良好编码习惯和架构能力，对 webservice 的调用和服务暴露散落在各个层面如图所示；&lt;/p&gt;
&lt;p&gt;2、项目A中所有的请求的ip，写在配置文件，如果项目B修改了部署ip或者端口，项目A需要手动修改配置文件然后重启；&lt;/p&gt;
&lt;p&gt;3、项目B如果修改了方法的参数和返回值，项目A无法得知；&lt;/p&gt;
&lt;p&gt;4、项目A调用项目B使用的方式由于开发者的能力和经验不同，采用的实现方式千奇百怪，有的使用 okhttp ，有的使用 Apache 的 HttpClient，有的使用原生的使用 Java 提供的原生操作。同样，项目B中提供服务的方式也千奇百怪，有的是 Spring MVC 提供的 http 接口，有的使用的是 webservice，整个项目混乱不堪；&lt;/p&gt;
&lt;p&gt;5、每个人写的请求参数五花八门，比如超时时间设置，比如MediaType的设置等，没有统一的规范；&lt;/p&gt;
&lt;p&gt;6、当时接口是暴露在内网的，所以接口没有做安全性校验，但是这也是一大遗留问题。&lt;/p&gt;
&lt;h2 id=&quot;dubbo&quot;&gt;Dubbo&lt;/h2&gt;
&lt;p&gt;当原生的架构出现了这些问题之后，我们需要对架构进行更新升级，综合以前遇到的问题，我们提出了一些关于框架的需求：&lt;/p&gt;
&lt;p&gt;1、调用其他服务的时候，不用手动的维护ip和端口；&lt;/p&gt;
&lt;p&gt;2、暴露给其他服务的接口，接口形式要一致；调用其他服务的接口，方式要统一，参数统一设置，支持个别方法单独设置参数；&lt;/p&gt;
&lt;p&gt;3、采用RPC的形式，本地项目依赖远程项目提供的sdk，调用sdk中的方法就可以实现远程方法的调用。&lt;/p&gt;
&lt;p&gt;在这样的趋势下，就很正常的选择了 Dubbo 作为项目的框架，当时的想法也特别单纯，和 Dubbo 当时的定位一样，主要就是&lt;strong&gt;”服务治理“&lt;/strong&gt;，让混乱不堪的项目结构清晰起来。当时还没有想到什么分布式事务、服务熔断、服务鉴权这些概念。我们使用 Dubbo 的时候， Dubbo 依然是停止更新状态，还没有捐献给 Apache 。才采用 Dubbo 架构之后，我们对项目进行了整体的重构，同时引入了 SSO 的单点登录，最后的架构大致如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1221720/201902/1221720-20190214233700275-1947221638.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;修改之后的架构大概如下：&lt;/p&gt;
&lt;p&gt;1、新增了 CAS 服务器作为统一认证，实现多项目的 SSO，保证登录了一个系统之后，其他的系统也处于登录状态；&lt;/p&gt;
&lt;p&gt;2、项目A和项目B，每个项目给对方提供一个 rpc-client 的包，里面包含所提供的接口，公用的实体类等；&lt;/p&gt;
&lt;p&gt;3、项目A和项目B，配置上增加 Dubbo 配置，比如注册地址，序列化协议扥等 。一般都是采用 Dubbo 协议，认证到zookeeper中；&lt;/p&gt;
&lt;p&gt;4、调用对方项目的接口时候，只需要注入 rpc-client 包中的类，调用其中的方法即可，dubbo会自动在zookeeper中查找服务注册信息，发送请求，返回结构。&lt;/p&gt;
&lt;h2 id=&quot;spring-cloud&quot;&gt;Spring Cloud&lt;/h2&gt;
&lt;p&gt;现在的公司架构采用的 Spring Cloud 微服务架构，平时自己也有学习和研究 Spring Cloud 相关的知识，自己对 Spring Cloud 的架构认识大概如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1221720/201902/1221720-20190214233712696-875606209.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;大概的架构如下：&lt;/p&gt;
&lt;p&gt;1、用户访问Nginx，跳转到前台页面；&lt;/p&gt;
&lt;p&gt;2、当页面有ajax请求时候，通过访问nginx，nginx转发到 Spring Cloud Gateway，然后根据路由规则转发到具体的某个微服务中；&lt;/p&gt;
&lt;p&gt;3、nacos作为服务注册发现 + 动态配置 + 服务监控使用，这里替代了 eureka + config + admin，其中config 项目，没有可视化页面，同时必须配合 Spring Cloud Bus + RabbitMQ通过订阅消息才可以实现配置的动态刷新。是nacos一个项目融合了多个功能，如果以集群方式部署，大大节省了项目的数量，比如 eureka + config + admin 都要实现高可用，那么需要至少 3*3个实例，而 nacos 只需要3个实例即可，同时降低项目复杂度。同时动态配置这块nacos提供了可视化界面，并且有配置信息回滚等操作，简单且功能强大 ；&lt;/p&gt;
&lt;p&gt;4、每个微服务之间难免有服务的调用，比如支付服务在付款的时候，必须调用订单服务，把订单中商品的数量和价格等信息查询过来，这里使用的是 Feign ，每个微服务本身属于 server 服务，给调用方提供一个 client 的sdk，当调用方使用 client 中的方法时候，就是实现了微服务之间的 Fegin 调用，同时配有 Hystrix 熔断功能，防止接口长时间不返回，阻塞后续请求造成服务的连锁奔溃反应。同时还包括有 Rbbion 的负载均衡和自动重试功能，某个服务无法访问时候，自动进行切换并重试；&lt;/p&gt;
&lt;p&gt;5、一次请求，可能涉及多个微服务，如果请求超时，那么必须要能定位到哪一步的请求耗时过多，方便后续的优化修改，这时候就必须使用微服务的全链路追踪，这里使用了 Skywalking ，是因为 Skywalking 是通过字节码增强技术实现，无须手动埋点，切性能较高。 Zipkin + Seluth 的组合，需要多个项目，同时 Zipkin 是通过 http 请求收集信息，性能较差；&lt;/p&gt;
&lt;p&gt;6、其他的分布式事务、分布式主键发号器、分库分表、缓存等方案就暂时不写，主要就是为了表达下 Spring Cloud 架构下的 Java 项目结构。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;大部分情况下，说区别其实是个伪概念，因为 Dubbo 能实现的方式 Spring Cloud 也能实现， 反之亦然。下面所说的区别是针对我个人曾经经历过的项目，个人所得出的感觉，欢迎不同观点朋友的探讨：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Dubbo
&lt;ul&gt;&lt;li&gt;项目结构：一般为前后一体化的项目为主，多以 JSP 为页面技术；&lt;/li&gt;
&lt;li&gt;项目定位：每个项目一般称之为一个系统，如 OA管理系统，BOSS系统等；&lt;/li&gt;
&lt;li&gt;团队构成：Java Web 员工为主，前后台都写；&lt;/li&gt;
&lt;li&gt;使用群体：一般为公司内部员工及管理人员使用，受众在百人与千人左右；&lt;/li&gt;
&lt;li&gt;性能要求：性能要求不高，高可用要求也不高，偶尔停机更新影响个5分钟，半小时都不会有太大影响（额。。好像容易挨打）；&lt;/li&gt;
&lt;li&gt;技术聚焦：采用 Dubbo 更多是出于服务治理的原因，就是为了解决原生架构中，服务调用的混乱和难以管理等问题。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Spring Cloud
&lt;ol&gt;&lt;li&gt;项目结构： 微服务化，每个服务关于某个具体领域，每个项目拥有自己的数据库。采用前后分离技术，前台页面关注于效果展示，页面统一访问网关，由网关根据路由规则转发到具体的某个微服务中；&lt;/li&gt;
&lt;li&gt;项目定位：每个项目称之为微服务，只提供 http ( restful ) 接口，不负责页面；&lt;/li&gt;
&lt;li&gt;研发团队：以微服务领域划分，每个微服务应该有自己的团队，独立开发和维护，每个团队尽可能将自己所负责的项目做到做好；&lt;/li&gt;
&lt;li&gt;使用群体：以广大用户为主，人数成千上万乃至亿；&lt;/li&gt;
&lt;li&gt;性能要求：一般微服务项目要求全年3个9（99.999%）或者4个9（99.9999%）高可用，微服务需要具备自动降级、故障切换、熔断、在线扩容、重启等功能；&lt;/li&gt;
&lt;li&gt;技术聚焦：采用 Spring Cloud 架构，整个系统复杂度大幅度提升了，更多的是为在高并发和大流量下系统可以正常运行。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;后记&quot;&gt;后记&lt;/h2&gt;
&lt;p&gt;由于本人经验有限，经验不足，文笔笨拙，文章写的有点过于粗糙，以上分析和解释可能还有错误和有失偏驳，还望大家批评指正。&lt;/p&gt;
</description>
<pubDate>Thu, 14 Feb 2019 15:43:00 +0000</pubDate>
<dc:creator>史亚健</dc:creator>
<og:description>自从2015年毕业开始从事 Java 开发工作，已经过去3年多了， 在各种不知名的小公司待过，经历过生产力从低到高，技术从落后到先进的过程， Dubbo 和 Spring Cloud 就是我曾经所经历</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shiyajian/p/10381335.html</dc:identifier>
</item>
<item>
<title>.Net Core跨平台应用研究-HelloDDNS(动态域名篇) - 赫山老妖</title>
<link>http://www.cnblogs.com/flyfire-cn/p/10381298.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flyfire-cn/p/10381298.html</guid>
<description>&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;.Net Core跨平台应用研究-HelloDDNS&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;-玩转DDNS&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;       为解决自己搭建的内网服务器需要域名而因没有超级用户密码不能开启光猫内置DDNS功能的问题，自己动手，基于.net core,实现动态域名的自助解析更新功能。&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;      最近学习ABP开源项目框架，因测试和展示需求，需要部署基于asp.net core的web应用。手上有一个闲置了两年的35互联基于windows IIS的虚拟主机空间，联系服务商升级支持.net core运行时，增加无托管应用程序池，等了两天，技术支持回复不能予以支持，建议购买云主机。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      登录35的管理控制台，看了看35云主机的价格，2核4G内存10M出口带宽的云主机，1年不下5K大洋的价格，让人无语。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      听说马云baba的阿里云性价比不错，登录阿里云，2核4G的ECS，1年价格也不低于1.5K。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      错过了双11，也错过了双12，肿么办？&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      想到家里100M的电信宽带，20M的上行速率，是不是可以利用下呢？&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      正好最近在折腾基于arm64的Linux嵌入式平台（ubuntu core内核），已经成功实现了.net core应用跨平台部署（详见之前&lt;a href=&quot;https://www.cnblogs.com/flyfire-cn/p/10356991.html&quot;&gt;《.Net Core跨平台应用研究-HelloArm(串口篇)》&lt;/a&gt;文章），只要解决了外部网络访问及域名解析问题，手上就是现成的云主机啊。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      习大大说，撸起袖子加油干。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      说干就干。&lt;/p&gt;

&lt;h2&gt;    .Net Core Web应用部署&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;      首先，需要解决web app的部署。发布.net core Web项目的Linux（arm64）平台运行版本，部署到Linux。具体步骤参见笔者另一篇文章&lt;a href=&quot;https://www.cnblogs.com/flyfire-cn/p/10356991.html&quot;&gt;《.Net Core跨平台应用研究-HelloArm(串口篇)》&lt;/a&gt;，在此不再赘述。&lt;/p&gt;
&lt;h2&gt;配置外网访问&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;      登录电信提供的光猫，开启端口映射功能。（不懂的同学请自行百度或必应）&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      通过&lt;a href=&quot;http://www.ip138.com&quot;&gt;www.ip138.com&lt;/a&gt;,查看自己的外网地址（本人直接使用的光猫路由功能，未使用二级路由），或登录光猫查看WLAN信息，获取自己的外网IP地址。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      关掉手机WIFI，用4G上网，通过手机浏览器访问http://外网IP:Port，访问发布的Web站点，bingo,访问成功。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      有同学会问，为什么要关掉手机wifi用流量访问？通常这些小型的家用路由器之类，是不会具有NAT回环配置功能的，无法从内网通过外网IP再NAT到内网IP。我的光猫，也不例外。&lt;/p&gt;
&lt;h2&gt;    DDNS简介&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;      稍懂网络知识的同学应该知道，家庭宽带用户，每次拨号上网得到IP地址是非固定的（固定IP地址的带宽线路用户，每年至少需要几万大洋哦，非土豪用户，一般不会申请 固定IP），光猫断个电或由于某些原因重新启动一下，IP就发生了变化。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      如何解决这个问题呢？此时，本文的主角终于快要出现了。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      我们知道，TCP/IP网络中的计算机，是通过IP地址进行寻址访问的，由于IP地址不好记忆，人们发明了一种便于标识IP的方式：域名。通过域名与IP进行绑定，解决IP地址难以记忆的问题。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      域名到IP地址的解析，是由DNS服务所完成。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      DNS通常只实现静态注册IP地址的解析，我们这种经常会变化的IP地址怎么办呢？&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      这年头，只要有需求，就会有对应的产品或服务。针对这种IP地坦经常发生变化又需要有域名的情况，一种叫DDNS的服务应运而生。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      顾名思义，DDNS就是动态DNS，当IP地址发生变化时，只要能及对所辖域名的DNS服务器进行更新，则可保证对应域名的解析服务可用。当然，DDNS在IP发生变化时，会有一个失效时间，但只要更新及时，失效时间很短，用于测试和展示的话，基本不影响使用。&lt;/p&gt;
&lt;h2&gt;    DDNS使用&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;      中国的互联网络，从电话拨号上网，到ADSL，到现在的光纤入户，经历了好几代的演进。目前，大部分的接入设备-光猫，都是具备DDNS功能的，只不过该功能属于高阶功能，通常需要具有管理员权限才能使用。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      使用DDNS服务，需要先到DDNS服务商注册，注册成功后，可下载DDNS客户端软件（pc端）或配置开启光猫DDNS功能，即可实现DDNS服务的自助更新。&lt;/p&gt;
&lt;h2&gt;    DDNS服务商&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;      笔者接触互联网较早（没有从事互联网行业，感觉错失几个亿，在此汗一个），知道国内较早提供DDNS服务的是花生壳，国外提供DDNS的有dynu.com、noip.com等。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      另外在折腾路由器的过程中，用过的内置支持DDNS的光猫，在此记录一下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;      华为HG8245光猫，支持3322、dynu；&lt;/li&gt;
&lt;li&gt;      烽火HG2201T光猫，支持oray(花生壳)；&lt;/li&gt;
&lt;li&gt;      ……&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;h2&gt;    蛋疼的中兴F450(V2)&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;      因升级到100M带宽，电信给提供了一个支持1000M的光猫，型号为中兴F450。根据网络上目前能查询到的资料，一翻折腾，确定目前中兴F450（V2版本）的光猫无法在免拆机的情况获取到超级管理员帐号。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      在没有超管密码的情况下，无法进入高级网络应用功能设置，不能开启光猫内置的动态域名支持（其实我也不知道它支持哪家的动态域名哈）。&lt;/p&gt;
&lt;h2&gt;    生命不休，折腾不止&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;      虽然本人的动手能力，足以通过拆机连接TTL串行接口的方式，以串行终端登录的方式获取中兴光猫的超级管理用户密码，一方面，考虑到光猫还在保修期（最近升级更换的新光猫呵），另一方，之前对DNS，DDNS的工作机制有一定的了解，知道DDNS厂家通常除了DDNS Client工具外，也有API接口可供用户自行开发集成。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;本着自已动手，丰衣足食的原则，决定自己实现DDNS定期更新功能。&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;      获取相关DDNS协议&lt;/p&gt;
&lt;h2&gt;    ORAY&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;      通过一翻搜索，查询到花生壳的协议文档，链接在&lt;a href=&quot;http://service.oray.com/question/3820.html&quot;&gt;这里&lt;/a&gt;，支持浏览器手动更新和原始Http Get请求：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      1.使用URL验证&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      适用于浏览器或应用程序（fetch, curl, lwp-request），可以在URL中包含验证信息。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      http://username:password@ddns.oray.com/ph/update?hostname=yourhostname&amp;amp;myip=ipaddress&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      2.原始HTTP GET请求&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      实际的HTTP请求，类似下面的代码。 其中 base-64-authorization 请使用 Base64 加密 username:password 后的字符替换。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      GET /ph/update?hostname=yourhostname&amp;amp;myip=ipaddress HTTP/1.0&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      Host: ddns.oray.com&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      Authorization: Basic base-64-authorization&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      User-Agent: Oray&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      请注意必须使用GET请求，POST是不被允许的。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;      更新参数&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      目前仅允许提交以下参数&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      参数      说明&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      hostname    需要更新的域名，此域名必须是开通花生壳服务。多个域名使用,分隔，默认为空，则更新护照下所有激活的域名。例：hostname=test.oray.com,customtest.oray.com&lt;/p&gt;
&lt;p&gt;      myip     需要更新的IP地址，可以不填。如果不指定，则由服务器获取到的IP地址为准。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;     看了花生壳的动态域名更新协议，心中有底了，very easy。&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;    DYNU&lt;/h2&gt;
&lt;p&gt;      因本人以前有申请过DYNU的免费域名，顺便也查了下&lt;a href=&quot;https://www.dynu.com/DynamicDNS/IP-Update-Protocol&quot;&gt;接口文档&lt;/a&gt;，文档地址如下（某些地区需要梯子呵）：&lt;/p&gt;
&lt;p&gt;      &lt;a href=&quot;https://www.dynu.com/DynamicDNS/IP-Update-Protocol&quot; target=&quot;_blank&quot;&gt;https://www.dynu.com/DynamicDNS/IP-Update-Protocol&lt;/a&gt;&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;主要内容如下：&lt;/p&gt;
&lt;p&gt;      GET /nic/update?myip=198.144.117.32 HTTP/1.1&lt;/p&gt;
&lt;p&gt;      Host: api.dynu.com&lt;/p&gt;
&lt;p&gt;      Authorization: Basic [BASE64-ENCODED-USERNAME:PASSWORD-PAIR]&lt;/p&gt;
&lt;p&gt;      User-Agent: [DEVICE-MODEL-MAKE-VERSION]&lt;/p&gt;

&lt;p&gt;      Oray和Dynu的接口协议简直是一个模子出来的，不知道是谁模仿了谁，本人不想深究，好用就行。&lt;/p&gt;

&lt;h2&gt;    NO-IP&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;      群中有网友提到No-IP，本人没有注册过，相关资料在此，无需FQ，有需要的同学拿走不谢。&lt;/p&gt;
&lt;p&gt;      &lt;a href=&quot;https://www.noip.com/&quot;&gt;https://www.noip.com/&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;      &lt;a href=&quot;https://www.noip.com/integrate/request&quot;&gt;https://www.noip.com/integrate/request&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;      &lt;a href=&quot;http://username:password@dynupdate.no-ip.com/nic/update?hostname=mytest.testdomain.com&amp;amp;myip=1.2.3.4&quot;&gt;http://username:password@dynupdate.no-ip.com/nic/update?hostname=mytest.testdomain.com&amp;amp;myip=1.2.3.4&lt;/a&gt;&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;      万事具备 ，只欠编码……&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;

&lt;h2&gt;    创建类库项目&lt;/h2&gt;
&lt;p&gt;      打开宇宙最强IDE，名字我就不说了，你懂的，新建一个类库项目，选择.NET Standard类库。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1525067/201902/1525067-20190214233454200-1241325160.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;      为什么选择.NET Standard类库，.net跨平台的之首选佳品。相关知识自行百度/必应补充。&lt;/p&gt;
&lt;p&gt;      类库实现以下功能：&lt;/p&gt;
&lt;p&gt;      夜深了，还是上图吧&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1525067/201902/1525067-20190214233522433-1105403757.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;    创建dotnet core控制台程序&lt;/h2&gt;
&lt;p&gt;      为啥选择dotnet core,原因很简单，跨平台。本人需要部署到Linux系统平台。&lt;/p&gt;
&lt;p&gt;      照旧，上图&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1525067/201902/1525067-20190214233537613-1906852990.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;    HttpClient和HttpClientFactor&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;      原来准备直接使用HttpClient，参考一些文章后，我发现HttpClient的使用会导致一些问题：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;      &lt;a href=&quot;https://www.zhibaoku.com/2018/10/31/net-core-zhong-httpclientfactory-ruhejiejue-httpclient-choumingzhaozhudewenti/&quot;&gt;.NET Core 中 HttpClientFactory 如何解决 HttpClient 臭名昭著的问题&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      &lt;a href=&quot;https://www.zhibaoku.com/2018/10/31/net-core-zhong-httpclientfactory-ruhejiejue-httpclient-choumingzhaozhudewenti/&quot;&gt;https://www.zhibaoku.com/2018/10/31/net-core-zhong-httpclientfactory-ruhejiejue-httpclient-choumingzhaozhudewenti/&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;      What is HttpClientFactory?&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      &lt;a href=&quot;https://www.stevejgordon.co.uk/introduction-to-httpclientfactory-aspnetcore&quot;&gt;https://www.stevejgordon.co.uk/introduction-to-httpclientfactory-aspnetcore&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;      .NET Core 2.1中的HttpClientFactory最佳实践&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      &lt;a href=&quot;https://www.cnblogs.com/xiaoliangge/p/9476568.html&quot;&gt;https://www.cnblogs.com/xiaoliangge/p/9476568.html&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;h2&gt;    Microsoft.Extensions.Http&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;      网上博客文章中，介绍IHttpClientFactory的可真不少，但是都没有提到需要安装其所需要Package,最后经过东搜西搜，花费了一翻不小的力气，还是在官方文档中找到了解决方法（好怀念有Google的日子啊）&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      需要安装Microsoft.Extensions.Http包&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      官方文档出处：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      &lt;a href=&quot;https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/http-requests?view=aspnetcore-2.2&quot;&gt;https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/http-requests?view=aspnetcore-2.2&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      完成程序，运行：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1525067/201902/1525067-20190214233559294-1648974423.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;


&lt;p&gt;基于.net core2.2环境，支持windows和linux.&lt;/p&gt;
&lt;p&gt;默认使用了oray的免费动态域名服务&lt;/p&gt;
&lt;p&gt;启动时解析一次域名服务，解析域名和IP是否一致，如不一致，更新DDNS。&lt;/p&gt;
&lt;p&gt;每十分钟检查一次，域名和公网IP不一致，则更新DDNS。&lt;/p&gt;
&lt;p&gt;更新后会输出更新结果到控制台。&lt;/p&gt;
&lt;p&gt;控制台输出可通过标准输出重定向输出到日志文件。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.oray.com/&quot; rel=&quot;nofollow&quot;&gt;https://www.oray.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用oray免费壳域名需要注册和实名认证。&lt;/p&gt;

&lt;h2&gt;ddns使用方式&lt;/h2&gt;
&lt;h3&gt;oray&lt;/h3&gt;
&lt;p&gt;dotnet ./flyfire.DDNS.Client.dll yourhostname yourusername yourpassword&lt;/p&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;dynu&lt;/h3&gt;
&lt;p&gt;dotnet ./flyfire.DDNS.Client.dll yourhostname yourusername yourpassword &lt;a href=&quot;http://api.dynu.com&quot; rel=&quot;nofollow&quot;&gt;http://api.dynu.com&lt;/a&gt; /nic/update&lt;/p&gt;
&lt;h2&gt;noip&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.noip.com/&quot; rel=&quot;nofollow&quot;&gt;https://www.noip.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://username:password@dynupdate.no-ip.com/nic/update?hostname=mytest.testdomain.com&amp;amp;myip=1.2.3.4&quot; rel=&quot;nofollow&quot;&gt;http://username:password@dynupdate.no-ip.com/nic/update?hostname=mytest.testdomain.com&amp;amp;myip=1.2.3.4&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;dotnet ./flyfire.DDNS.Client.dll yourhostname yourusername yourpassword &lt;a href=&quot;http://dynupdate.no-ip.com&quot; rel=&quot;nofollow&quot;&gt;http://dynupdate.no-ip.com&lt;/a&gt; /nic/update&lt;/p&gt;

&lt;h2&gt;linux下脚本配置（ubuntu）&lt;/h2&gt;
&lt;h3&gt;创建脚本文件&lt;/h3&gt;
&lt;p&gt;在程序目录下创建一个脚本文件，例如 ddns.sh&lt;/p&gt;
&lt;p&gt;文件内容如下：&lt;/p&gt;
&lt;p&gt;cd $(dirname $0)&lt;/p&gt;
&lt;p&gt;pwd&lt;/p&gt;
&lt;p&gt;nohup dotnet ./flyfire.DDNS.Client.dll yourhostname yourusername yourpassword 2&amp;gt;&amp;amp;1 &amp;gt;&amp;gt;log.txt&lt;/p&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;授予权限&lt;/h3&gt;
&lt;p&gt;chmod 777 ./ddns.sh&lt;/p&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;运行脚本&lt;/h3&gt;
&lt;p&gt;./ddns.sh&lt;/p&gt;
&lt;p&gt;脚本将启动程序，并且程序不会随shell的关闭而退出。同时，程序输出被重定向到日志文件log.txt。&lt;/p&gt;
&lt;p&gt;将脚本文件加入到linux的开机启动配置文件，即可实现开机自动运行。&lt;/p&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;windows下输出重定向&lt;/h2&gt;
&lt;p&gt;dotnet ./flyfire.DDNS.Client.dll yourhostname yourusername yourpassword 2&amp;gt;&amp;amp;1 &amp;gt;&amp;gt;log.txt&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      本项目已开源至：&lt;a href=&quot;https://github.com/flyfire-cn/flyfire.DDNS&quot;&gt;https://github.com/flyfire-cn/flyfire.DDNS&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      类库flyfire.DDNS已发布至：&lt;a href=&quot;https://www.nuget.org&quot;&gt;https://www.nuget.org&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      有需要的同学，请自行获取。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;      在今天这个特别的日子，谨以此文献给所有坚守在一线的程序员/媛，祝天下有情人终成眷属。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;      也感谢我的家人，长久以来为我默默的付出。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      注：本次折腾过程中，还出现了一个意外。在配置光猫NAT端口映射时，发现死活无法生效，开始还以为是光猫功能有问题，差点准备换光猫了（手上还有HW -HG8245光猫,因是华为早期产品，功耗有点大，无线信号稍弱，退休闲置中），无意中发现WLAN中得到的IP地址，居然是一个10开头的地址，原来电信把我给分配到了一个大局域网中了。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      同学们如果遇到这种情况，不要慌，给10000号打报修电话，要求使用公网IP，通常电信客服会帮你搞定。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      &lt;span&gt;&lt;strong&gt;&lt;span&gt;原创博文，写作不易。如果您认为这篇文章还不错或者有所收获，您可以通过右边的“打赏”功能，支持鼓励一下。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;      各位看官，有钱的捧个钱场，没钱的领个红包。在下在此谢过。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      &lt;strong&gt;&lt;span&gt;本文为作者原创，未经许可，请勿转载。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 14 Feb 2019 15:32:00 +0000</pubDate>
<dc:creator>赫山老妖</dc:creator>
<og:description>.Net Core跨平台应用研究-HelloDDNS -玩转DDNS 摘要 为解决自己搭建的内网服务器需要域名而因没有超级用户密码不能开启光猫内置DDNS功能的问题，自己动手，基于.net core,</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/flyfire-cn/p/10381298.html</dc:identifier>
</item>
<item>
<title>iOS 使用UI控件的外观协议UIAppearance进行设置默认UI控件样式 - 滴水微澜</title>
<link>http://www.cnblogs.com/zhou--fei/p/10381268.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhou--fei/p/10381268.html</guid>
<description>&lt;p&gt;在iOS开发中，经常会对UINavigationBar的样式进行全局样式。采用的设置方式有两种：&lt;/p&gt;
&lt;p&gt;第一种，采用方式如下：&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[UINavigationBar appearance]
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;这种是对一类对象的默认全局外观样式设置，它对设置时机有要求。&lt;/p&gt;
&lt;p&gt;通常需要在UIWindow的viewlayout之前。错过了时机后，设置是没有效果的。&lt;/p&gt;
&lt;p&gt;可以选择在下面方法内设置：&lt;/p&gt;
&lt;div readability=&quot;16.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *&lt;span&gt;)launchOptions {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Override point for customization after application launch.&lt;/span&gt;
    
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; YES;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第二种，采用方式如下：&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[self.navigationController.navigationBar setBarTintColor:[UIColor redColor]];
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这种是即时性的，设置后就会有效果。&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;8&quot;&gt;

&lt;p&gt;第一种方式通过appearance使得UINavigationBar产生了全局默认样式，那么appearance是什么东西呢？&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Appearance(外观协议)讲解&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;11.5&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/826860/201902/826860-20190214231421688-1023011964.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;UIAppearance文件包含于UIKit框架中，该文件很短，包括注释加起来总共56行&lt;/p&gt;
&lt;p&gt;点击去看看。&lt;/p&gt;
&lt;p&gt;里面有一个宏定义和两个协议声明，分别如下：&lt;/p&gt;
&lt;p&gt;1.宏定义：&lt;/p&gt;
&lt;div readability=&quot;13&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#define&lt;/span&gt; UI_APPEARANCE_SELECTOR __attribute__((annotate(&quot;ui_appearance_selector&quot;)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由注释可知：凡是被这个宏标记的属性方法，都可以当用作全局样式的调用方法。&lt;/p&gt;
&lt;p&gt;如：UIView的backgroundColor属性&lt;/p&gt;
&lt;div readability=&quot;20&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
@property(nullable, nonatomic,copy)            UIColor          *backgroundColor UI_APPEARANCE_SELECTOR; &lt;span&gt;//&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.外观容器协议：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@protocol&lt;/span&gt; UIAppearanceContainer &amp;lt;NSObject&amp;gt; &lt;span&gt;@end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是个空协议，里面啥都没有&lt;/p&gt;
&lt;p&gt;3.外观协议：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@protocol&lt;/span&gt; UIAppearance &amp;lt;NSObject&amp;gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回实现了此外观协议的UI控件实例，用这个返回的对象设置的属性是全局性。&lt;/span&gt;
+&lt;span&gt; (instancetype)appearance;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回实现了此外观协议的UI控件实例，用这个返回的对象设置的属性只对ContainerClass内部包裹的对象有效。&lt;/span&gt;
+ (instancetype)appearanceWhenContainedIn:(nullable Class &amp;lt;UIAppearanceContainer&amp;gt;)ContainerClass, ... NS_REQUIRES_NIL_TERMINATION NS_DEPRECATED_IOS(5_0, 9_0, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Use +appearanceWhenContainedInInstancesOfClasses: instead&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) __TVOS_PROHIBITED;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是iOS9之后的替代方法，作用和上面的一样。&lt;/span&gt;
+ (instancetype)appearanceWhenContainedInInstancesOfClasses:(NSArray&amp;lt;Class &amp;lt;UIAppearanceContainer&amp;gt;&amp;gt; *&lt;span&gt;)containerTypes NS_AVAILABLE_IOS(9_0);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是iOS8新增的方法，是对不同的布局方案（紧凑型，普通型）采用不同的外观样式&lt;/span&gt;
+ (instancetype)appearanceForTraitCollection:(UITraitCollection *&lt;span&gt;)trait NS_AVAILABLE_IOS(8_0);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;与上面的方法相似，多了一个参数条件，只对ContainerClass内部包裹的对象有效。&lt;/span&gt;
+ (instancetype)appearanceForTraitCollection:(UITraitCollection *)trait whenContainedIn:(nullable Class &amp;lt;UIAppearanceContainer&amp;gt;)ContainerClass, ... NS_REQUIRES_NIL_TERMINATION NS_DEPRECATED_IOS(8_0, 9_0, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Use +appearanceForTraitCollection:whenContainedInInstancesOfClasses: instead&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) __TVOS_PROHIBITED;
//iOS9后的新方法，是对上面方法的替换。
&lt;/span&gt;+ (instancetype)appearanceForTraitCollection:(UITraitCollection *)trait whenContainedInInstancesOfClasses:(NSArray&amp;lt;Class &amp;lt;UIAppearanceContainer&amp;gt;&amp;gt; *&lt;span&gt;)containerTypes  NS_AVAILABLE_IOS(9_0);
&lt;/span&gt;&lt;span&gt;@end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在上面代码中对里面定义的5个方法进行了说明。&lt;/p&gt;

&lt;div readability=&quot;10&quot;&gt;
&lt;p&gt;遵守了这两个协议的类，可以进行同一默认外观设置，那么哪些类遵守了这两个协议了呢？&lt;/p&gt;
&lt;p&gt;看一下UI控件的父类UIView&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;19&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
NS_CLASS_AVAILABLE_IOS(2_0) &lt;span&gt;@interface&lt;/span&gt; UIView : UIResponder &amp;lt;NSCoding, UIAppearance, UIAppearanceContainer, UIDynamicItem, UITraitEnvironment, UICoordinateSpace, UIFocusItem, UIFocusItemContainer, CALayerDelegate&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过上面UIView的定义可以发现，UIView遵守了外观协议和外观容器协议。&lt;/p&gt;
&lt;p&gt;也就是说所有的UI控件，只有其属性方法被UI_APPEARANCE_SELECTOR宏标示了，那么就可以进行全局外观&lt;/p&gt;
&lt;p&gt;默认设置。&lt;/p&gt;

&lt;div readability=&quot;17&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;这里列一下UINavigationBar通常用的的全局设置。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;//⚠️: 1与2互斥，且1的优先级高&lt;/p&gt;
&lt;p&gt;//1.设置导航背景&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
UIImage *bg =&lt;span&gt; [UIImage pureImageWithColor:[UIColor brownColor]];
[[UINavigationBar appearance] setBackgroundImage:bg forBarMetrics:UIBarMetricsDefault];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;//2.设置导航颜色&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[[UINavigationBar appearance] setBarTintColor:[UIColor redColor]];
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;//3.设置导航文字颜色&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[[UINavigationBar appearance] setTintColor:[UIColor blueColor]];
&lt;/pre&gt;&lt;/div&gt;
//4.设置导航字体&lt;/div&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;div readability=&quot;11&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
NSShadow *shadow =&lt;span&gt; [[NSShadow alloc] init];
shadow.shadowColor &lt;/span&gt;= [UIColor colorWithRed:&lt;span&gt;0.0&lt;/span&gt; green:&lt;span&gt;0.0&lt;/span&gt; blue:&lt;span&gt;0.0&lt;/span&gt; alpha:&lt;span&gt;0.8&lt;/span&gt;&lt;span&gt;];
shadow.shadowOffset &lt;/span&gt;= CGSizeMake(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
[[UINavigationBar appearance] setTitleTextAttributes: [NSDictionary dictionaryWithObjectsAndKeys: [UIColor colorWithRed:&lt;/span&gt;&lt;span&gt;245.0&lt;/span&gt;/&lt;span&gt;255.0&lt;/span&gt; green:&lt;span&gt;245.0&lt;/span&gt;/&lt;span&gt;255.0&lt;/span&gt; blue:&lt;span&gt;245.0&lt;/span&gt;/&lt;span&gt;255.0&lt;/span&gt; alpha:&lt;span&gt;1.0&lt;/span&gt;], NSForegroundColorAttributeName, shadow, NSShadowAttributeName, [UIFont fontWithName:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;HelveticaNeue-CondensedBlack&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; size:&lt;span&gt;21.0&lt;/span&gt;], NSFontAttributeName, nil]];
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;//5.特定环境或某种场合下外观样式设置（水平紧凑型，UINavigationBar默认外观为粉色。）&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;16.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[[UINavigationBar appearanceForTraitCollection:[UITraitCollection traitCollectionWithHorizontalSizeClass:UIUserInterfaceSizeClassCompact]] setBarTintColor:[UIColor purpleColor]];
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;另外对UIButton的全局默认设置如下：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;//让一类控件同时表现出某种属性&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[[UIButton appearance] setBackgroundColor:[UIColor yellowColor]];
[[UIButton appearance] setTitle:&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;同一设置&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; forState:UIControlStateNormal];
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;//让一类控件在某种环境下表现出某种外观样式&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[[UIButton appearanceWhenContainedInInstancesOfClasses:@[[UINavigationBar &lt;span&gt;class&lt;/span&gt;]]] setTitle:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;比较特别&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; forState:UIControlStateNormal];
[[UIButton appearanceWhenContainedInInstancesOfClasses:@[[UINavigationBar &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;]]] setBackgroundColor:[UIColor redColor]];
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;UI控件的默认全局设置方式符合预期。&lt;/p&gt;
&lt;p&gt;那么iOS开发中，所有的UI控件都可以通过上面两种方法进行全局样式默认设置和自定义设置了。&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Thu, 14 Feb 2019 15:23:00 +0000</pubDate>
<dc:creator>滴水微澜</dc:creator>
<og:description>在iOS开发中，经常会对UINavigationBar的样式进行全局样式。采用的设置方式有两种： 第一种，采用方式如下： [UINavigationBar appearance] 这种是对一类对象的默</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhou--fei/p/10381268.html</dc:identifier>
</item>
</channel>
</rss>