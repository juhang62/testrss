<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>[ Python入门教程 ] Python中JSON模块基本使用方法 - YingHong</title>
<link>http://www.cnblogs.com/linyfeng/p/12244596.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/linyfeng/p/12244596.html</guid>
<description>&lt;p&gt;&lt;span&gt;  JSON (JavaScript Object Notation)是一种使用广泛的轻量数据格式，Python标准库中的json模块提供了一种简单的方法来编码和解码JSON格式的数据。用于完成字符串和python数据类型间进行转换。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;  json.dumps()&lt;/strong&gt;：把Python数据类型转换成JSON字符串&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;  &lt;/strong&gt;&lt;span&gt;&lt;strong&gt;json.loads()：&lt;/strong&gt;把JSON字符串转换成Python数据类型&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;  json.&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;dump()：&lt;/strong&gt;把Python数据类型转换成JSON字符串并存储在文件中&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;  json.load()：&lt;/strong&gt;把文件打开并将JSON字符串转换成Python数据类型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  说明：使用 JSON 函数需要导入 json 库：&lt;strong&gt;import json&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;  1、将python中的字典转换为JSON字符串。说明：转换后的JSON字符串都是放在双引号中。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; json
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; student_dic = {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ACME&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;grade&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; : &lt;span&gt;'&lt;/span&gt;&lt;span&gt;90&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; json_data =&lt;span&gt; json.dumps(student_dic)
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; type(json_data)
&lt;/span&gt;&amp;lt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;str&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(json_data)
{&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ACME&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;grade&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;90&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;  2、将JSON字符串转换为Python字典。说明：字符串必须放在双引号中，否则会报错。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; tran_data =&lt;span&gt; json.loads(json_data)
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; type(tran_data)
&lt;/span&gt;&amp;lt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;dict&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(tran_data)
{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ACME&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;grade&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;90&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;  3、将Python字典类型数据写入json文件中&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; json
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; student_dic = {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ACME&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;grade&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; : &lt;span&gt;'&lt;/span&gt;&lt;span&gt;90&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; with open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;json.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) as f:
...   json.dump(student_dic,f)
...
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;  查看json.txt文件内容，如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
d:\pycharm&amp;gt;&lt;span&gt;type json.txt
{&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ACME&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;grade&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;90&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;  说明：type为dos命令，作用是查看文件内容。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  4、读取JSON文件，并把字符串变换为Python数据字典&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; with open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;json.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) as fr:
...   student_dict &lt;/span&gt;=&lt;span&gt; json.load(fr)
...
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; type(student_dict)
&lt;/span&gt;&amp;lt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;dict&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(student_dict)
{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ACME&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;grade&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;90&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;  5、将Python字典类型转换为JSON字符串，并以指定格式输出。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; json
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; student_dic = {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ACME&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;grade&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; : &lt;span&gt;'&lt;/span&gt;&lt;span&gt;90&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; json_data = json.dumps(student_dic,indent=4&lt;span&gt;)
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(json_data)
{
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ACME&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;grade&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;90&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;  6、将Python字典类型转换为JSON字符串，并按键排序输出。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; json_data = json.dumps(student_dic,sort_keys=True,indent=4&lt;span&gt;)
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(json_data)
{
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;grade&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;90&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ACME&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;  7、Python基本类型转换为JSON字符串的特殊变化。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; spec_value_dict = {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:True,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:False,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:None}
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; json_data = json.dumps(spec_value_dict,indent=4&lt;span&gt;)
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(json_data)
{
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: true,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: false,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: null
}
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 说明：Python中的True转换为true，False转化为false，None转换为null。使用loads将JSON类型转换后还原，如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; json.loads(json_data)
{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: True, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: False, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: None}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;  &lt;span&gt;本文仅是描述了Python基本类型与JSON字符串间转换的基本使用方法。对于JSON编解码更多功能使用可以阅读官方文档获取：&lt;a href=&quot;https://docs.python.org/3/library/json.html&quot; target=&quot;_blank&quot;&gt;https://docs.python.org/3/library/json.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 31 Jan 2020 00:33:00 +0000</pubDate>
<dc:creator>YingHong</dc:creator>
<og:description>JSON (JavaScript Object Notation)是一种使用广泛的轻量数据格式，Python标准库中的json模块提供了一种简单的方法来编码和解码JSON格式的数据。用于完成字符串和p</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/linyfeng/p/12244596.html</dc:identifier>
</item>
<item>
<title>高等数学——讲透求极限两大方法，夹逼法与换元法 - TechFlow2019</title>
<link>http://www.cnblogs.com/techflow/p/12244590.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/techflow/p/12244590.html</guid>
<description>&lt;p&gt;本文始发于个人公众号：&lt;strong&gt;TechFlow&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;今天的文章聊聊高等数学当中的&lt;strong&gt;极限&lt;/strong&gt;，我们跳过极限定义以及一些常用极限计算的部分。我想对于一些比较常用的函数以及数列的极限，大家应该都非常熟悉。&lt;/p&gt;

&lt;p&gt;大部分比较简单的函数或者数列，我们可以很直观地看出来它们的极限。比如&lt;span class=&quot;math inline&quot;&gt;\(\frac{1}{n}\)&lt;/span&gt;，当n趋向于无穷大的时候，&lt;span class=&quot;math inline&quot;&gt;\(\frac{1}{n}\)&lt;/span&gt;的极限是0，再比如当n趋向于无穷大的时候，&lt;span class=&quot;math inline&quot;&gt;\(n^2\)&lt;/span&gt;的极限也是无穷大，等等。但是对于一些相对比较复杂的函数，我们一时之间可能很难直观地看出极限，因此需要&lt;strong&gt;比较方便计算极限的方法&lt;/strong&gt;，今天的文章介绍的正是这样的方法——&lt;strong&gt;夹逼法和换元法&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;夹逼法&quot;&gt;夹逼法&lt;/h3&gt;

&lt;p&gt;夹逼法在数学领域其实非常常用，在中学的竞赛当中经常出现。夹逼法的原理非常简单，对于某一个函数f(x)，我们知道它的表达式，但是很难确定它的范围。我们可以先找到另外两个范围比较容易确定的函数g(x)和h(x)，然后证明:&lt;span class=&quot;math inline&quot;&gt;\(g(x)\leq f(x) \leq h(x)\)&lt;/span&gt;。通过h(x)和g(x)的范围来夹逼f(x)的范围。&lt;/p&gt;

&lt;p&gt;说白了，就是直接求解不方便的函数，我们通过&lt;strong&gt;用其他容易计算的函数来替代&lt;/strong&gt;的方法来间接求解，类似于“曲线救国”。&lt;/p&gt;

&lt;p&gt;明白了夹逼法的概念之后，我们再来看一下它在数列极限当中的应用。当下存在数列&lt;span class=&quot;math inline&quot;&gt;\(\{x_n\}\)&lt;/span&gt;我们需要确定它的极限，我们找到了另外两个数列&lt;span class=&quot;math inline&quot;&gt;\(\{y_n\}\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(\{z_n\}\)&lt;/span&gt;。如果它们满足以下两个条件：&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(\exists n_0 \in N\)&lt;/span&gt;，当&lt;span class=&quot;math inline&quot;&gt;\(n &amp;gt; n_0\)&lt;/span&gt;时，有&lt;span class=&quot;math inline&quot;&gt;\(y_n \leq x_n \leq z_n\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(\displaystyle\lim_{n \rightarrow +\infty}y_n=a, \lim_{n \to +\infty}z_n=a\)&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那么，数列&lt;span class=&quot;math inline&quot;&gt;\(\{x_n\}\)&lt;/span&gt;的极限存在，并且&lt;span class=&quot;math inline&quot;&gt;\(\displaystyle\lim_{n \to +\infty}x_n=a\)&lt;/span&gt;。从直觉上来看，上面的式子应该非常直观，但是我们还是试着从数学的角度来证明一下，顺便回顾一下极限的定义。&lt;/p&gt;

&lt;p&gt;证明过程如下：&lt;/p&gt;

&lt;p&gt;根据极限的定义，对于数列&lt;span class=&quot;math inline&quot;&gt;\(\{x_n\}\)&lt;/span&gt;而言，对于任意&lt;span class=&quot;math inline&quot;&gt;\(\epsilon\)&lt;/span&gt;都存在&lt;span class=&quot;math inline&quot;&gt;\(n_0 &amp;gt; 0\)&lt;/span&gt;，使得对于任意：&lt;span class=&quot;math inline&quot;&gt;\(n &amp;gt; n_0\)&lt;/span&gt;，都有&lt;span class=&quot;math inline&quot;&gt;\(|x_n - a| &amp;lt; \epsilon\)&lt;/span&gt;。那么就称数列&lt;span class=&quot;math inline&quot;&gt;\(\{x_n\}\)&lt;/span&gt;的极限是a。&lt;/p&gt;

&lt;p&gt;由于数列&lt;span class=&quot;math inline&quot;&gt;\(\{y_n\}\)&lt;/span&gt;的极限是a，所以存在&lt;span class=&quot;math inline&quot;&gt;\(n_1\)&lt;/span&gt;使得&lt;span class=&quot;math inline&quot;&gt;\(n &amp;gt; n_1\)&lt;/span&gt;时，&lt;span class=&quot;math inline&quot;&gt;\(|y_n -a | &amp;lt; \epsilon\)&lt;/span&gt;。同理，存在&lt;span class=&quot;math inline&quot;&gt;\(n_2\)&lt;/span&gt;使得&lt;span class=&quot;math inline&quot;&gt;\(n &amp;gt; n_2\)&lt;/span&gt;时，&lt;span class=&quot;math inline&quot;&gt;\(|z_n -a | &amp;lt; \epsilon\)&lt;/span&gt;。那么对于&lt;span class=&quot;math inline&quot;&gt;\(n &amp;gt; max(n_1, n_2)\)&lt;/span&gt;显然应该有：&lt;span class=&quot;math inline&quot;&gt;\(|y_n - a| &amp;lt; \epsilon\)&lt;/span&gt;并且&lt;span class=&quot;math inline&quot;&gt;\(|z_n - a | &amp;lt; \epsilon\)&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;我们将绝对值展开，可以得到：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{aligned} a - \epsilon &amp;amp;&amp;lt; y_n &amp;lt; a + \epsilon \\ a - \epsilon &amp;amp;&amp;lt; z_n &amp;lt; a + \epsilon \end{aligned} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们代入&lt;span class=&quot;math inline&quot;&gt;\(y_n \leq x_n \leq z_n\)&lt;/span&gt;，可以得到：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{aligned} a - \epsilon &amp;lt; y_n \leq x_n \leq z_n&amp;lt; a + \epsilon \\ | x_n -a | &amp;lt; \epsilon \end{aligned} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;根据极限的定义，显然可以得到数列&lt;span class=&quot;math inline&quot;&gt;\(\{x_n\}\)&lt;/span&gt;的极限也是a。&lt;/p&gt;

&lt;p&gt;我们利用这个方法来看一个书上的例子，我们都知道当x趋向于0的时候，&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(\sin x\)&lt;/span&gt;都趋向于0，但是&lt;span class=&quot;math inline&quot;&gt;\(\frac{\sin x}{x}\)&lt;/span&gt;的极限是多少呢？如果猜测一下，两个无穷趋向于0的极限的比值应该是1才对，但是这个只是我们的直观猜测，想要严格证明，还需要使用数学方法。&lt;/p&gt;

&lt;p&gt;这个证明就用到了我们刚才说的夹逼法，并且非常巧妙，让我们来看一张下面这张图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/1/31/16ff8de5134d2754?w=506&amp;amp;h=378&amp;amp;f=png&amp;amp;s=43735&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们假设夹角&lt;span class=&quot;math inline&quot;&gt;\(\angle AOB=x\)&lt;/span&gt;，这里采用弧度制。我们令圆心OB的长度等于1，那么&lt;span class=&quot;math inline&quot;&gt;\(BC=\sin x\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(OC=\cos x\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(AD=\tan x\)&lt;/span&gt;。我们下面要用这张图里的&lt;strong&gt;几何图形的面积关系&lt;/strong&gt;，显然：&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(\triangle AOB\)&lt;/span&gt;的面积 &amp;lt; 扇形AOB的面积 &amp;lt; &lt;span class=&quot;math inline&quot;&gt;\(\triangle AOD\)&lt;/span&gt;的面积。&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(\triangle AOB\)&lt;/span&gt;的面积等于&lt;span class=&quot;math inline&quot;&gt;\(\frac{1}{2}*OA*BC=\frac{1}{2}\sin x\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(\triangle AOD\)&lt;/span&gt;的面积等于&lt;span class=&quot;math inline&quot;&gt;\(\frac{1}{2}*OA*AD=\frac{1}{2}\tan x\)&lt;/span&gt;。这两个都很容易得出，直接套用三角形面积公式即可。扇形的面积看起来麻烦一些，但其实也很简单，在几何当中，&lt;strong&gt;扇形可以看成是特殊的三角形&lt;/strong&gt;。我们把弧长看成是底面，半径可以看成是高，那么扇形的面积等于&lt;span class=&quot;math inline&quot;&gt;\(\frac{1}{2}*弧长*半径\)&lt;/span&gt;。所以扇形AOB的面积等于&lt;span class=&quot;math inline&quot;&gt;\(\frac{1}{2}*x*1=\frac{1}{2}x\)&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;我们列出来，可以得到：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\frac{1}{2}\sin x &amp;lt; \frac{1}{2}x &amp;lt; \frac{1}{2}\tan x\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;即：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\sin x &amp;lt; x &amp;lt; \tan x\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;span class=&quot;math inline&quot;&gt;\(\tan x = \frac{\sin x}{\cos x}\)&lt;/span&gt;，所以我们可以不等号两边同时除以&lt;span class=&quot;math inline&quot;&gt;\(\sin x\)&lt;/span&gt;，得到：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[1 &amp;lt; \frac{x}{\sin x} &amp;lt; \frac{1}{\cos x}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;由于当x趋向于0的时候&lt;span class=&quot;math inline&quot;&gt;\(\sin x, \cos x\)&lt;/span&gt;都大于0，所以我们可以对不等式互换分子分母，得到：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\cos x &amp;lt; \frac{\sin x}{x} &amp;lt; 1\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;到这里已经结束了，因为我们&lt;strong&gt;根据余弦的函数图像&lt;/strong&gt;可以很容易看出来，当x趋向于0的时候，cosx趋向于1.但为了严谨起见，我们当做不知道这点，继续用数学的方法证明：&lt;/p&gt;

&lt;p&gt;我们来计算当x趋向于0的时候，&lt;span class=&quot;math inline&quot;&gt;\(1 - \cos x\)&lt;/span&gt;的取值范围，当x趋向于0的时候&lt;span class=&quot;math inline&quot;&gt;\(\cos x &amp;lt; 1\)&lt;/span&gt;，所以&lt;span class=&quot;math inline&quot;&gt;\(1 - \cos x &amp;gt; 0\)&lt;/span&gt;。我们再对&lt;span class=&quot;math inline&quot;&gt;\(1 - \cos x\)&lt;/span&gt;变形，这里要引入&lt;strong&gt;三角函数当中的和差化积公式&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\cos \alpha - \cos \beta = -2\sin \frac{\alpha + \beta}{2}\sin \frac{\alpha - \beta}{2}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;由于&lt;span class=&quot;math inline&quot;&gt;\(\cos 0 = 1\)&lt;/span&gt;，带入和差化积可以得到：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\cos 0 - \cos x = -2 \sin \frac{x}{2}\sin -\frac{x}{2}=2\sin ^2 \frac{x}{2}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们之前通过面积表示的方法已经证明了当x趋向于0的时候&lt;span class=&quot;math inline&quot;&gt;\(\sin x &amp;lt; x\)&lt;/span&gt;，所以&lt;span class=&quot;math inline&quot;&gt;\(2\sin ^2 \frac{x}{2} &amp;lt; 2 * (\frac{x}{2})^2=\frac{x^2}{2}\)&lt;/span&gt;。当x趋向于0的时候，显然&lt;span class=&quot;math inline&quot;&gt;\(x^2\)&lt;/span&gt;也趋向于0，所以我们可以证明&lt;span class=&quot;math inline&quot;&gt;\(\cos x\)&lt;/span&gt;的极限是1.&lt;/p&gt;

&lt;h3 id=&quot;换元法&quot;&gt;换元法&lt;/h3&gt;

&lt;p&gt;我们接着来看换元法，学名是&lt;strong&gt;复合函数的极限运算法则&lt;/strong&gt;。定义如下：假设我们有&lt;span class=&quot;math inline&quot;&gt;\(y = f[g(x)]\)&lt;/span&gt;，我们令&lt;span class=&quot;math inline&quot;&gt;\(u = g(x)\)&lt;/span&gt;。如果&lt;span class=&quot;math inline&quot;&gt;\(\displaystyle\lim_{x \to x_0}g(x)=u_0, \lim_{u \to u_0}f(u)=A\)&lt;/span&gt;，并且在x趋向于&lt;span class=&quot;math inline&quot;&gt;\(x_0\)&lt;/span&gt;时，有&lt;span class=&quot;math inline&quot;&gt;\(g(x) \neq u_0\)&lt;/span&gt;，那么：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\displaystyle\lim_{x \to x_0}f[g(x)]=\lim_{u \to u_0}g(u)=A\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们使用极限的定义同样可以很方便地证明它的正确性，这里就不证明了，感兴趣的同学可以试着证明一下。&lt;/p&gt;

&lt;p&gt;了解了符合函数的极限运算法则之后，我们再来看一个例子巩固一下。&lt;/p&gt;

&lt;p&gt;和上面的例子类似，我们这次求一下:&lt;span class=&quot;math inline&quot;&gt;\(\displaystyle\lim_{x \to 0}\frac{1-\cos x}{x^2}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;和上面那题一样，我们先使用和差化积对极限的分子进行变换，可以得到：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\displaystyle\lim_{x \to 0}\frac{2\sin^2\frac{x}{2}}{x^2}=\frac{1}{2}\lim_{x \to 0}\frac{\sin^2 \frac{x}{2}}{(\frac{x}{2})^2}\]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;如果通过极限本身的定义来计算这个式子还是蛮复杂的，很难直观地获得答案。这个时候就需要用上换元法了，我们令&lt;span class=&quot;math inline&quot;&gt;\(u = \frac{x}{2}\)&lt;/span&gt;，那么这个极限就可以转化成复合函数极限了。&lt;span class=&quot;math inline&quot;&gt;\(u=\frac{x}{2}, f(u)=\frac{\sin u}{u}\)&lt;/span&gt;。因为当x趋向于0的时候，u也趋向于0，当u趋向于0的时候，&lt;span class=&quot;math inline&quot;&gt;\(f(u)\)&lt;/span&gt;趋向于1，所以最终的极限就是1.&lt;/p&gt;

&lt;p&gt;通过夹逼法和复合函数的极限替换公式，我们可以很方便地求解一些看起来比较棘手的极限。这也是我们求极限的过程当中使用非常频繁的方法。虽然上文当中的公式看起来有些比较麻烦，但是方法本身并不难，只要沉下心来，一定可以看明白的。&lt;/p&gt;

&lt;p&gt;原创不易，希望我的文章可以给你带来收获。扫码关注我的公众号，获取更多文章，你们的支持是我最大的动力。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/1/31/16ff8e809660226b?w=258&amp;amp;h=258&amp;amp;f=png&amp;amp;s=23988&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;参考资料&lt;/p&gt;
&lt;p&gt;同济大学《高等数学》第六版&lt;/p&gt;
&lt;p&gt;程序员的数学&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 31 Jan 2020 00:05:00 +0000</pubDate>
<dc:creator>TechFlow2019</dc:creator>
<og:description>本文始发于个人公众号： TechFlow 今天的文章聊聊高等数学当中的 极限 ，我们跳过极限定义以及一些常用极限计算的部分。我想对于一些比较常用的函数以及数列的极限，大家应该都非常熟悉。 大部分比较简</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/techflow/p/12244590.html</dc:identifier>
</item>
<item>
<title>Go的切片：长度和容量 - 鹿呦呦</title>
<link>http://www.cnblogs.com/sunshineliulu/p/12244532.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sunshineliulu/p/12244532.html</guid>
<description>&lt;p&gt;虽然说 Go 的语法在很大程度上和 PHP 很像，但 PHP 中却是没有“切片”这个概念的，在学习的过程中也遇到了一些困惑，遂做此笔记。&lt;br/&gt;&lt;strong&gt;困惑1&lt;/strong&gt;：使用 append 函数为切片追加元素后，切片的容量时变时不变，其扩容机制是什么？&lt;br/&gt;&lt;strong&gt;困惑2&lt;/strong&gt;：更改切片的元素会修改其底层数组中对应的元素。为什么有些情况下更改了切片元素，其底层数组元素没有更改？&lt;/p&gt;
&lt;h4 id=&quot;一切片的声明&quot;&gt;一、切片的声明&lt;/h4&gt;
&lt;p&gt;切片可以看成是数组的引用。在 Go 中，每个数组的大小是固定的，不能随意改变大小，切片可以为数组提供动态增长和缩小的需求，但其本身并不存储任何数据。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;/*
 * 这是一个数组的声明
 */
var a [5]int //只指定长度，元素初始化为默认值0
var a [5]int{1,2,3,4,5}

/* 
 * 这是一个切片的声明：即声明一个没有长度的数组
 */
// 数组未创建
// 方法1：直接初始化
var s []int //声明一个长度和容量为 0 的 nil 切片
var s []int{1,2,3,4,5} // 同时创建一个长度为5的数组
// 方法2：用make()函数来创建切片：var 变量名 = make([]变量类型,长度,容量)
var s = make([]int, 0, 5)
// 数组已创建
// 切分数组：var 变量名 []变量类型 = arr[low, high]，low和high为数组的索引。
var arr = [5]int{1,2,3,4,5}
var slice []int = arr[1:4] // [2,3,4]&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;二切片的长度和容量&quot;&gt;二、切片的长度和容量&lt;/h4&gt;
&lt;p&gt;切片的长度是它所包含的元素个数。&lt;br/&gt;切片的容量是从它的第一个元素到其底层数组元素末尾的个数。&lt;br/&gt;切片 s 的长度和容量可通过表达式 &lt;code&gt;len(s)&lt;/code&gt; 和 &lt;code&gt;cap(s)&lt;/code&gt; 来获取。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;s := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9} // [0 1 2 3 4 5 6 7 8 9] len=10,cap=10
s1 := s[0:5] // [0 1 2 3 4] len=5,cap=10
s2 := s[5:] // [5 6 7 8 9] len=5,cap=5&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;三切片追加元素后长度和容量的变化&quot;&gt;三、切片追加元素后长度和容量的变化&lt;/h4&gt;
&lt;h5 id=&quot;append-函数&quot;&gt;1.append 函数&lt;/h5&gt;
&lt;p&gt;Go 提供了内建的 append 函数，为切片追加新的元素。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;code&gt;func append(s []T, vs ...T) []T&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;append 的结果是一个包含原切片所有元素加上新添加元素的切片。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面分两种情况描述了向切片追加新元素后切片长度和容量的变化。&lt;br/&gt;Example 1:&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main

import &quot;fmt&quot;

func main() {
    arr := [5]int{1,2,3,4,5} // [1 2 3 4 5]
    fmt.Println(arr)
    
    s1 := arr[0:3] // [1 2 3]
    printSlice(s1)
    s1 = append(s1, 6)
    printSlice(s1)
    fmt.Println(arr)
}

func printSlice(s []int) {
    fmt.Printf(&quot;len=%d cap=%d %p %v\n&quot;, len(s), cap(s), s, s)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[1 2 3 4 5]
len=3 cap=5 0xc000082030 [1 2 3]
len=4 cap=5 0xc000082030 [1 2 3 6]
[1 2 3 6 5]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到切片在追加元素后，其容量和指针地址没有变化，但底层数组发生了变化，下标 3 对应的 4 变成了 6。&lt;/p&gt;
&lt;p&gt;Example 2:&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main

import &quot;fmt&quot;

func main() {
    arr := [5]int{1,2,3,4} // [1 2 3 4 0]
    fmt.Println(arr)
    
    s2 := arr[2:] // [3 4 0]
    printSlice(s2)
    s2 = append(s2, 5)
    printSlice(s2)
    fmt.Println(arr)
}

func printSlice(s []int) {
    fmt.Printf(&quot;len=%d cap=%d %p %v\n&quot;, len(s), cap(s), s, s)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[1 2 3 4 0]
len=3 cap=3 0xc00001c130 [3 4 0]
len=4 cap=6 0xc00001c180 [3 4 0 5]
[1 2 3 4 0]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而这个切片在追加元素后，其容量和指针地址发生了变化，但底层数组未变。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当切片的底层数组不足以容纳所有给定值时，它就会分配一个更大的数组。返回的切片会指向这个新分配的数组&lt;/strong&gt;。&lt;/p&gt;
&lt;h5 id=&quot;切片的源代码学习&quot;&gt;2.切片的源代码学习&lt;/h5&gt;
&lt;p&gt;Go 中切片的数据结构可以在源码下的 &lt;code&gt;src/runtime/slice.go&lt;/code&gt; 查看。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;// go 1.3.16 src/runtime/slice.go:13
type slice struct {
    array unsafe.Pointer
    len   int
    cap   int
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，切片作为数组的引用，有三个属性字段：长度、容量和指向数组的指针。&lt;br/&gt;向 slice 追加元素的时候，若容量不够，会调用 growslice 函数，&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;// go 1.3.16 src/runtime/slice.go:76
func growslice(et *_type, old slice, cap int) slice {
    //...code
    
    newcap := old.cap
    doublecap := newcap + newcap
    if cap &amp;gt; doublecap {
        newcap = cap
    } else {
        if old.len &amp;lt; 1024 {
            newcap = doublecap
        } else {
            // Check 0 &amp;lt; newcap to detect overflow
            // and prevent an infinite loop.
            for 0 &amp;lt; newcap &amp;amp;&amp;amp; newcap &amp;lt; cap {
                newcap += newcap / 4
            }
            // Set newcap to the requested cap when
            // the newcap calculation overflowed.
            if newcap &amp;lt;= 0 {
                newcap = cap
            }
        }
    }
    
    // 跟据切片类型和容量计算要分配内存的大小
    var overflow bool
    var lenmem, newlenmem, capmem uintptr
    switch {
        // ...code
    }
    
    // ...code...
    
    // 将旧切片的数据搬到新切片开辟的地址中
    memmove(p, old.array, lenmem)
    
    return slice{p, old.len, newcap}
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面的源码，在对 slice 进行 append 等操作时，可能会造成 slice 的自动扩容。其扩容时的大小增长规则是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果切片的容量小于 1024，则扩容时其容量大小乘以2；一旦容量大小超过 1024，则增长因子变成 1.25，即每次增加原来容量的四分之一。&lt;/li&gt;
&lt;li&gt;如果扩容之后，还没有触及原数组的容量，则切片中的指针指向的还是原数组，如果扩容后超过了原数组的容量，则开辟一块新的内存，把原来的值拷贝过来，这种情况丝毫不会影响到原数组。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上面的两个例子中，切片的容量均小于 1024 个元素，所以扩容的时候增长因子为 2，每增加一个元素，其容量翻番。&lt;br/&gt;Example2 中，因为切片的底层数组没有足够的可用容量，append() 函数会创建一个新的底层数组，将被引用的现有的值复制到新数组里，再追加新的值，所以原数组没有变化，不是我想象中的[1 2 3 4 5]，&lt;/p&gt;
&lt;h5 id=&quot;切片扩容的内部实现&quot;&gt;3.切片扩容的内部实现&lt;/h5&gt;
&lt;p&gt;扩容1：切片扩容后其容量不变&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;slice := []int{1,2,3,4,5}
// 创建新的切片，其长度为 2 个元素，容量为 4 个元素
mySlice := slice[1:3]
// 使用原有的容量来分配一个新元素，将新元素赋值为 40
mySlice = append(mySlice, 40)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行上面代码后的底层数据结构如下图所示：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/953680/202001/953680-20200131011736120-1875404111.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;扩容2：切片扩容后其容量变化&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;// 创建一个长度和容量都为 5 的切片
mySlice := []int{1,2,3,4,5}
// 向切片追加一个新元素，将新元素赋值为 6
mySlice = append(mySlice, 6)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行上面代码后的底层数据结构如下图所示：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/953680/202001/953680-20200131011753142-1890662245.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;四小结&quot;&gt;四、小结&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;切片是一个结构体，保存着切片的容量，长度以及指向数组的指针（数组的地址）。&lt;/li&gt;
&lt;li&gt;尽量对切片设置初始容量值，以避免 append 调用 growslice，因为新的切片容量比旧的大，会开辟新的地址，拷贝数据，降低性能。&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Thu, 30 Jan 2020 17:21:00 +0000</pubDate>
<dc:creator>鹿呦呦</dc:creator>
<og:description>这是一篇切片扩容相关的学习笔记，主要介绍了切片的扩容机制及源代码的学习。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sunshineliulu/p/12244532.html</dc:identifier>
</item>
<item>
<title>剑指Offer对答如流系列 - 实现Singleton模式 - 沉晓Jeffery</title>
<link>http://www.cnblogs.com/JefferyChenXiao/p/12244387.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JefferyChenXiao/p/12244387.html</guid>
<description>&lt;p&gt;题目：设计一个类，我们只能生成该类的一个实例。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;由于设计模式在面向对象程序设计中起着举足轻重的作用，在面试过程中很多公司都喜欢问一些与设计模式相关的问题。在常用的模式中，Singleton是唯一一个能够用短短几十行代码完整实现的模式。因此，写一个Singleton的类型是一个很常见的面试题。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200103081244745.png#pic_center&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果你看过我之前写的设计模式专栏，那么这道题思路你会很开阔。&lt;/p&gt;
&lt;p&gt;单例模式的要点有三个：一是&lt;code&gt;某个类只能有一个实例&lt;/code&gt;；二是&lt;code&gt;它必须自行创建这个实例&lt;/code&gt;；三是&lt;code&gt;它必须自行向整个系统提供这个实例&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;我们下面来看一下它的实现&lt;/p&gt;
&lt;h2 id=&quot;懒汉式写法&quot;&gt;懒汉式写法&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class LazySingleton {

    private static LazySingleton lazySingleton = null;

    private LazySingleton() {

    }

    public static LazySingleton getInstance() {
        if(lazySingleton == null) {
            lazySingleton = new LazySingleton();
        }
        return lazySingleton;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关键就是将构造器私有，限制只能通过内部静态方法来获取一个实例。&lt;/p&gt;
&lt;p&gt;但是这种写法，很明显不是线程安全的。如果多个线程在该类初始化之前,有大于一个线程调用了getinstance方法且lazySingleton == null 判断条件都是正确的时候，这个时候就会导致new出多个LazySingleton实例。可以这么改一下：&lt;/p&gt;
&lt;p&gt;这种写法叫做DoubleCheck。针对类初始化之前多个线程进入 if(lazySingleton == null) 代码块中情况&lt;/p&gt;
&lt;p&gt;这个时候加锁控制，再次判断 if(lazySingleton == null) ，如果条件成立则new出来一个实例，轮到其他的线程判断的时候自然就就为假了，问题大致解决。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class LazyDoubleCheckSingleton {

    private static LazyDoubleCheckSingleton lazySingleton = null;

    private LazyDoubleCheckSingleton() {

    }

    public static LazyDoubleCheckSingleton getInstance() {
        if(lazySingleton == null) {
            synchronized (LazyDoubleCheckSingleton.class){
                if(lazySingleton == null) {
                    lazySingleton = new LazyDoubleCheckSingleton();
                }
            }
        }
        return lazySingleton;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是即使是这样，上面代码的改进有些问题还是无法解决的。&lt;/p&gt;
&lt;p&gt;因为会有重排序问题。重排序是一种编译优化技术，属于《编译原理》的内容了，这里不详细探讨，但是要告诉你怎么回事。&lt;/p&gt;
&lt;p&gt;正常来说，下面的这段代码&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;lazySingleton = new LazyDoubleCheckSingleton();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行的时候是这样的&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;分配内存给这个对象&lt;/li&gt;
&lt;li&gt;初始化对象&lt;/li&gt;
&lt;li&gt;设置LazyDoubleCheckSingleton指向刚分配的内存地址。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;但是编译优化后，可能是这种样子&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;分配内存给这个对象&lt;/li&gt;
&lt;li&gt;设置LazyDoubleCheckSingleton指向刚分配的内存地址。&lt;/li&gt;
&lt;li&gt;初始化对象&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;2 步骤 和 3 步骤一反，就出问题了。（前提条件，编译器进行了编译优化）&lt;br/&gt;比如说有两个线程，名字分别是线程1和线程2，线程1进入了 if(lazySingleton == null) 代码块，拿到了锁，进行了&lt;code&gt;new LazyDoubleCheckSingleton()&lt;/code&gt;的执行，在加载构造类的实例的时候，设置LazyDoubleCheckSingleton指向刚分配的内存地址，但是还没有初始化对象。线程2判断 if(lazySingleton == null) 为假，直接返回了lazySingleton，又进行了使用，使用的时候就会出问题了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;画两张图吧：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;重排序的情况如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191028140615305.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9jaGVueGlhby5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再看出问题的地方&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191028140845305.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9jaGVueGlhby5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然这个很好改进，从禁用重排序方面下手，添加一个volatile。不熟悉线程安全可以参考这篇文章&lt;a href=&quot;https://chenxiao.blog.csdn.net/article/details/102751344&quot;&gt;【Java并发编程】线程安全性详解&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    private volatile static LazyDoubleCheckSingleton lazySingleton = null;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;方法不止一种嘛，也可以利用对象初始化的“可见性”来解决，具体来说是利用静态内部类基于类初始化的延迟加载，名字很长，但是理解起来并不困难。（使用这种方法，不必担心上面编译优化带来的问题）&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;类初始化的延迟加载与JVM息息相关，我们演示的例子的&lt;code&gt;类&lt;/code&gt;只是被加载了而已，而没有链接和初始化。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们看一下实现方案：&lt;/p&gt;
&lt;p&gt;定义一个静态内部类，其静态字段实例化了一个单例。获取单例需要调用getInstance方法间接获取。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class StaticInnerClassSingleton {

    private static class InnerClass{
        private static StaticInnerClassSingleton staticInnerClassSingleton = new StaticInnerClassSingleton();
    }

    public static StaticInnerClassSingleton getInstance() {
        return InnerClass.staticInnerClassSingleton;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果对内部类不熟悉，可以参考这篇文章&lt;a href=&quot;https://chenxiao.blog.csdn.net/article/details/89421331&quot;&gt;【Java核心技术卷】深入理解Java的内部类&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191028142441992.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9jaGVueGlhby5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;懒汉式的介绍就到这里吧，下面再看看另外一种单例模式的实现&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;饿汉式写法&quot;&gt;饿汉式写法&lt;/h2&gt;
&lt;p&gt;演示一下基本的写法&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class HungrySingleton {

    // 类加载的时候初始化
    private final static HungrySingleton hungrySingleton = new HungrySingleton();

    /*
    也可以在静态块里进行初始化
      private static HungrySingleton hungrySingleton；

     static {
        hungrySingleton = new HungrySingleton();
     }
     */
    private HungrySingleton() {

    }

    public static HungrySingleton getInstance() {
        return hungrySingleton;
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;饿汉式在类加载的时候就完成单例的实例化，如果用不到这个类会造成内存资源的浪费，因为单例实例引用不可变，所以是线程安全的&lt;/p&gt;
&lt;p&gt;同样，上面的饿汉式写法也是存在问题的&lt;/p&gt;
&lt;p&gt;我们依次看一下：&lt;/p&gt;
&lt;p&gt;首先是&lt;strong&gt;序列化破坏单例模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先保证饿汉式能够序列化，需要继承Serializable 接口。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import java.io.Serializable;

public class HungrySingleton implements Serializable {

    // 类加载的时候初始化
    private final static HungrySingleton hungrySingleton = new HungrySingleton();

    /*
    也可以在静态块里进行初始化
      private static HungrySingleton hungrySingleton；

     static {
        hungrySingleton = new HungrySingleton();
     }
     */
    private HungrySingleton() {

    }

    public static HungrySingleton getInstance() {
        return hungrySingleton;
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们测试一下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import lombok.extern.slf4j.Slf4j;

import java.io.*;

@Slf4j
public class Test {

    public static void main(String[] args) throws IOException, ClassNotFoundException {
       HungrySingleton hungrySingleton = HungrySingleton.getInstance();
       ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;singleton&quot;));
       oos.writeObject(hungrySingleton);

       File file = new File(&quot;singleton&quot;);
       ObjectInputStream ois = new ObjectInputStream(new FileInputStream(file));

        HungrySingleton newHungrySingleton = (HungrySingleton) ois.readObject();

        log.info(&quot;结果 {}&quot;,hungrySingleton);
        log.info(&quot;结果 {}&quot;,newHungrySingleton);
        log.info(&quot;对比结果 {}&quot;,hungrySingleton == newHungrySingleton);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019102811342990.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;结果发现对象不一样，原因就涉及到序列化的底层原因了，我们先看解决方式：&lt;/p&gt;
&lt;p&gt;饿汉式代码中添加下面这段代码&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private Object readResolve() {
        return hungrySingleton;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重新运行，这个时候的结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191028114044339.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;原因出在readResolve方法上，下面去ObjectInputStream源码部分找找原因。（里面都涉及到底层实现，不要指望看懂）&lt;/p&gt;
&lt;p&gt;在一个读取底层数据的方法上有一段描述&lt;/p&gt;
&lt;p&gt;就是序列化的Object类中可能定义有一个readResolve方法。我们在二进制数据读取的方法中看到了是否判断&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191028114936564.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9jaGVueGlhby5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;private Object readOrdinaryObject()方法中有这段代码，如果存在ReadResolve方法，就去调用。不存在，不调用。联想到我们在饿汉式添加的代码，大致能猜到怎么回事了吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191028115318596.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9jaGVueGlhby5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外一种情况就是反射攻击破坏单例&lt;/p&gt;
&lt;p&gt;演示一下&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import lombok.extern.slf4j.Slf4j;

import java.io.*;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;

@Slf4j
public class Test {

    public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {
        Class objectClass = HungrySingleton.class;

        Constructor constructor = objectClass.getDeclaredConstructor();
        constructor.setAccessible(true); // 强行打开构造器权限
        HungrySingleton instance = HungrySingleton.getInstance();
        HungrySingleton newInstance = (HungrySingleton) constructor.newInstance();

        log.info(&quot;结果{}&quot;,instance);
        log.info(&quot;结果{}&quot;,newInstance);
        log.info(&quot;比较结果{}&quot;,newInstance == instance);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191028131807540.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;这里强行破开了private的构造方法的权限，使得能new出来一个单例实例，这不是我们想看到的。&lt;/p&gt;
&lt;p&gt;解决方法是在构造方法中抛出异常&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;   private HungrySingleton() {
        if( hungrySingleton != null) {
            throw new RuntimeException(&quot;单例构造器禁止反射调用&quot;);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个时候再运行一下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191028132023909.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实对于懒汉式也是有反射破坏单例的问题的，也可以采用类似抛出异常的方法来解决。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;饿汉式单例与懒汉式单例类比较&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;饿汉式单例类在自己被加载时就将自己实例化。单从资源利用效率角度来讲，这个比懒汉式单例类稍差些。从速度和反应时间角度来讲，则比懒汉式单例类稍好些。&lt;/li&gt;
&lt;li&gt;懒汉式单例类在实例化时，必须处理好在多个线程同时首次引用此类时的访问限制问题，特别是当单例类作为资源控制器在实例化时必然涉及资源初始化，而资源初始化很有可能耗费大量时间，这意味着出现多线程同时首次引用此类的机率变得较大，需要通过同步化机制进行控制。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;枚举&quot;&gt;枚举&lt;/h2&gt;
&lt;p&gt;除此之外还有一种单例模式的实现就是&lt;strong&gt;枚举&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用枚举的方式实现单例模式是《Effective Java》作者力推的方式，在很多优秀的开源代码中经常可以看到使用枚举方式实现单例模式的地方，枚举类型不允许被继承，同样是线程安全的且只能被实例化一次，但是枚举类型不能够懒加载，对Singleton主动使用，比如调用其中的静态方法则INSTANCE会立即得到实例化。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//枚举类型本身是final的，不允许被继承
public enum Singleton
{
    INSTANCE;
    //实例变量
    private byte[] data = new byte[1024];

    Singleton()
    {
        System.out.println(&quot;I want to follow Jeffery.&quot;);
    }

    public static void method()
    {
        //调用该方法则会主动使用Singleton，INSTANCE将会被实例化
    }

    public static Singleton getInstance()
    {
        return INSTANCE;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在实际面试中，我们为了展现枚举单例模式，可以写成这样：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public enum Singleton
{
    INSTANCE;
  
    public static Singleton getInstance()
    {
        return INSTANCE;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Java中的枚举其实是一种语法糖，换句话说就是编译器帮助我们做了一些的事情，我们将字节码反编译成Java代码，看看编译器帮我们做了什么，以及探讨为什么使用枚举的方式实现单例模式是《Effective Java》作者力推的方式？&lt;/p&gt;
&lt;p&gt;原始代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public enum EnumClass {
    SPRING,SUMMER,FALL,WINTER;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;反编译后的代码&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public final class EnumClass extends Enum
{

    public static EnumClass[] values()
    {
        return (EnumClass[])$VALUES.clone();
    }

    public static EnumClass valueOf(String name)
    {
        return (EnumClass)Enum.valueOf(suger/EnumClass, name);
    }

    private EnumClass(String s, int i)
    {
        super(s, i);
    }

    public static final EnumClass SPRING;
    public static final EnumClass SUMMER;
    public static final EnumClass FALL;
    public static final EnumClass WINTER;
    private static final EnumClass $VALUES[];

    static 
    {
        SPRING = new EnumClass(&quot;SPRING&quot;, 0);
        SUMMER = new EnumClass(&quot;SUMMER&quot;, 1);
        FALL = new EnumClass(&quot;FALL&quot;, 2);
        WINTER = new EnumClass(&quot;WINTER&quot;, 3);
        $VALUES = (new EnumClass[] {
            SPRING, SUMMER, FALL, WINTER
        });
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6.7108013937282&quot;&gt;
&lt;p&gt;对于静态代码块不了解的参考 ： &lt;a href=&quot;https://chenxiao.blog.csdn.net/article/details/88064170&quot;&gt;Java中静态代码块、构造代码块、构造函数、普通代码块&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;结合前面的内容，是不是很容易理解了？ 除此之外，我们还可以看出，枚举是继承了Enum类的，同时它也是final，即不可继承的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;枚举类型的单例模式的玩法有很多，网上传的比较多的有以下几种：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;内部枚举类形式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.构造方法中实例化对象（上面提到了 注意了吗）&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class EnumSingleton {
    private EnumSingleton(){}
    
    public static EnumSingleton getInstance(){
        return Singleton.INSTANCE.getInstance();
    }

    private enum Singleton{
        INSTANCE;
        
        private EnumSingleton singleton;
        
        //JVM会保证此方法绝对只调用一次
        Singleton(){
            singleton = new EnumSingleton();
        }
        public EnumSingleton getInstance(){
            return singleton;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.枚举常量的值即为对象实例&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class EnumSingleton {
    private EnumSingleton(){}
    
    public static EnumSingleton getInstance(){
        return Singleton.INSTANCE.getInstance();
    }

    private enum Singleton{
        INSTANCE(new EnumSingleton());
        private EnumSingleton singleton;
        
        //JVM会保证此方法绝对只调用一次
        Singleton(EnumSingleton singleton){
            this.singleton = singleton;
        }
        public EnumSingleton getInstance(){
            return singleton;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;接口实现形式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于一个标准的enum单例模式，最优秀的写法还是实现接口的形式:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 定义单例模式中需要完成的代码逻辑
public interface MySingleton {
    void doSomething();
}

public enum Singleton implements MySingleton {
    INSTANCE {
        @Override
        public void doSomething() {
            System.out.println(&quot;I want to follow Jeffery. What about you ?&quot;);
        }
    };

    public static MySingleton getInstance() {
        return Singleton.INSTANCE;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我就问！单例模式的面试，你还怕不怕？&lt;/p&gt;
</description>
<pubDate>Thu, 30 Jan 2020 15:41:00 +0000</pubDate>
<dc:creator>沉晓Jeffery</dc:creator>
<og:description>[toc] 面试题2：实现Singleton模式 题目：设计一个类，我们只能生成该类的一个实例。 由于设计模式在面向对象程序设计中起着举足轻重的作用，在面试过程中很多公司都喜欢问一些与设计模式相关的问</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/JefferyChenXiao/p/12244387.html</dc:identifier>
</item>
<item>
<title>算法 - 选择排序 - 东北小狐狸</title>
<link>http://www.cnblogs.com/hellxz/p/12244349.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hellxz/p/12244349.html</guid>
<description>&lt;h2 id=&quot;什么是选择排序&quot;&gt;什么是选择排序&lt;/h2&gt;
&lt;p&gt;选择排序是一种排序算法，时间复杂度简单可以记为&lt;code&gt;O(n x n)&lt;/code&gt;，算法灵巧但速度不是很快&lt;/p&gt;
&lt;p&gt;大体思路：遍历数组，每次取出遍历数组中最小值放到结果数组中，同时数组缩容去除遍历数组中最小值，继续遍历&lt;/p&gt;
&lt;p&gt;即，&lt;strong&gt;取最小值放结果数组中 -&amp;gt; 缩容去最小 -&amp;gt; 重复第一步&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;选择排序的步骤&quot;&gt;选择排序的步骤&lt;/h2&gt;
&lt;p&gt;给定数组&lt;img src=&quot;https://img2018.cnblogs.com/blog/1149398/202001/1149398-20200130224438612-2089197700.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;创建一个与原数组等长的结果数组&lt;/p&gt;
&lt;p&gt;使用两个变量分别记录数组中的最小值与最小值坐标&lt;/p&gt;
&lt;p&gt;取原数组中第一个值与其他元素比较，如果被比较值小于当前最小值则替换最小值为当前值，反之继续遍历&lt;/p&gt;
&lt;p&gt;遍历完成返回当前数组最小值的下标，将原数组中的最小值放到结果数组的第一位，第一次遍历得到2&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1149398/202001/1149398-20200130225417748-528282558.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来需要去除给定数组中的最小值，缩小数组，第二次遍历得到3&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1149398/202001/1149398-20200130230259758-408887126.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每次遍历缩小后的数组，找出最小值放到结果数组中，再次缩小上次缩小过的数组，直到将结果数组填满&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1149398/202001/1149398-20200130230648063-332862076.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后得到结果数组&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1149398/202001/1149398-20200130230927367-840437896.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;java实现&quot;&gt;Java实现&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.github.hellxz.grokkingalgorithms.selectionsort;

/**
 * 选择排序
 */
public class SelectionSort {

    public static int[] selectionSort(int[] arr) {
        //创建结果数组
        int[] solution = new int[arr.length];
        for (int i = 0; i &amp;lt; solution.length; i++) {
            //获得当前arr最小值下标
            int smallestIndex = findSmallestIndex(arr);
            //将当前arr最小值放到结果数组
            solution[i] = arr[smallestIndex];
            //arr缩容，去除最小值
            arr = newArrayWithoutLastSmallest(arr, smallestIndex);
        }
        return solution;
    }

    /**
     * 返回去掉给定值的新数组
     */
    private static int[] newArrayWithoutLastSmallest(int[] arr, int lastSmallestIndex) {
        int[] newArr = new int[arr.length - 1];
        for (int i = 0; i &amp;lt; arr.length; i++) {
            if (i &amp;lt; lastSmallestIndex) {
                newArr[i] = arr[i];
            } else if(i &amp;gt; lastSmallestIndex) {
                newArr[i-1] = arr[i];
            }
        }
        return newArr;
    }

    /**
     * 查找给定数组最小值下标
     */
    private static int findSmallestIndex(int[] arr) {
        int smallest = arr[0];
        int smallestIndex = 0;
        for (int i = 0; i &amp;lt; arr.length; i++) {
            if (smallest &amp;gt; arr[i]) {
                smallest = arr[i];
                smallestIndex = i;
            }
        }
        return smallestIndex;
    }

    public static void main(String[] args) {
        int[] arr = {8, 6, 7, 5, 3, 2, 4};
        int[] sortedArr = selectionSort(arr);
        for (int i = 0; i &amp;lt; sortedArr.length; i++) {
            System.out.print(sortedArr[i]);
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 30 Jan 2020 15:27:00 +0000</pubDate>
<dc:creator>东北小狐狸</dc:creator>
<og:description>什么是选择排序 选择排序是一种排序算法，时间复杂度简单可以记为 ，算法灵巧但速度不是很快 大体思路：遍历数组，每次取出遍历数组中最小值放到结果数组中，同时数组缩容去除遍历数组中最小值，继续遍历 即，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hellxz/p/12244349.html</dc:identifier>
</item>
<item>
<title>机器学习-TensorFlow应用之 binned features, Cross features和optimizer - HappyPuppy</title>
<link>http://www.cnblogs.com/tangxiaobo199181/p/12244347.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tangxiaobo199181/p/12244347.html</guid>
<description>&lt;p&gt;这一节主要介绍一下TensorFlow在应用的过程中的几个小的知识点，第一个是关于features的处理的，例如Bucketized (Binned) Features 和 Feature scalling。第二个是简单的介绍一下常用的几个Optimizer之间的区别，例如SGD, Adagrad, Adam等等。这里主要是对前面一节的内容的一个小补充。其实关于feature的处理，我在前面已经用了很长一段时间在讲了，但是基本都是基于sklearn的框架来处理的，虽然前面咱们说了很多很多，但是总有漏网之鱼嘛，那就是Binned features，咱们这里就用TensorFlow来解释并且应用。还有一个部分就是optimizer，咱们前面说了一个SGD的应用，这一节我准备简单讲述一下另外两个常用的optimizer，他们分别是Adagrad, Adam，我会简单说一下它们之间的优缺点以及应用场景。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Bucketized (Binned) Features&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;  &lt;/strong&gt;Features engineering咱们在前面讲述了很多很多，并且都用sklearn演示了他们的应用和实现过程。这里补充一下Binned features的知识点，具体什么是Binned features呢？它其实很简单就是将咱们的数据按大小顺序分成n 个bins, 或者这里可以理解成n个quantiles， 然后咱们将每一个bin的boundary记录下来放到一个list里面，最后将咱们的数据在应用到这个bin里面，看看咱们的每一个数据属于哪一个bin，咱的的结果是按照bin的大小从小到大一次是0,1,2，................这样。咱们可以看一个简单的实例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
boundaries = [0, 10, 100&lt;span&gt;]
input tensor &lt;/span&gt;= [[-5, 10000&lt;span&gt;]
                [&lt;/span&gt;150,   10&lt;span&gt;]
                [&lt;/span&gt;5,    100]]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;output如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
output = [[0, 3&lt;span&gt;]
          [&lt;/span&gt;3, 2&lt;span&gt;]
          [&lt;/span&gt;1, 3]]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从上面的一个简单的实例咱们看出，咱们的原始数据的范围非常大，咱们可以根据boundaries这个list来将他们分成4个bins, 最后再来看咱们的原始数据属于哪一个bin。上面的是一个简单的例子，那么接下来咱们来看看具体的代码实现过程。如果咱们需要将一个seriesbucketized，那么整个bucketized的过程其实分成三个部分，即分别是创建boundary，将series转成numerical_column，和最后的bucketized三个部分；咱们看下面&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_quantile_based_boundaries(series,num_bucket):
    quantiles &lt;/span&gt;= np.arange(1.0,num_bucket)/&lt;span&gt;num_bucket
    boundaries &lt;/span&gt;= series.quantile(quantiles)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;the index are the quantiles&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; [boundaries[key] &lt;span&gt;for&lt;/span&gt; key &lt;span&gt;in&lt;/span&gt; boundaries.keys()]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的这个函数的目的就是根据quantile来找到每一个bin的boundary；然后咱们需要将咱们的series转成一个numerical_column,如下所示&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
house_median_age_numeric_column = tf.feature_column.numeric_column(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;housing_median_age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其实这一个就是声明咱们的这一个column的类型，既然是按照大小来分配到不同的bin, 那么咱们这一列的数据肯定得是数字型的。既然咱们有了boundary， 也有了numeric_column， 那么接下来就是bucketized啦，如下所示&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
 bucketized_house_median_age = tf.feature_column.bucketized_column(source_column=&lt;span&gt;house_median_age_numeric_column,
                                                                   boundaries &lt;/span&gt;= get_quantile_based_boundaries(series=cali_housing_dataset_permutation[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;housing_median_age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;],num_bucket&lt;/span&gt;=10)&lt;br/&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里咱们就声明并且完成了一个column的bucketized的过程，然后咱们就是可以将这个bucketized_column传递给模型的feature_column参数。咱们就完成了一个column的bucketized的整个过程。&lt;/p&gt;
&lt;p&gt;补充：在这里咱们在补充一个小知识点，那就是既然咱们实例化了一个bucketized feature_column对象,并且告诉了咱们的模型，那么咱们如何获取咱们的这个bucketized后的feature_column的值呢？？简单点就是，咱们怎么知道bucketized_house_median_age这个转化后的值呢？其实很简单，我直接上代码，大家可以直接拿出来用哈&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; demo(feature_column):
  feature_layer &lt;/span&gt;=&lt;span&gt; tf.keras.layers.DenseFeatures(feature_column)
  &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(feature_layer(dict(cali_housing_dataset_permutation)).numpy())
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;咱们直接调用上面的函数就能打印出咱们想要的值了，如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[[0. 0. 0. ... 0. 1&lt;span&gt;. 0.]
 [0. 0. 0. ... 0. 0. 0.]
 [0. 0. 0. ... &lt;/span&gt;1&lt;span&gt;. 0. 0.]
 ...
 [0. 0. 0. ... 0. 0. 0.]
 [0. 0. &lt;/span&gt;1&lt;span&gt;. ... 0. 0. 0.]
 [0. 0. 0. ... &lt;/span&gt;1. 0. 0.]]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里咱们也可以看出来bucketized过后，咱们的feature会转成one-hot encoding的方式。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Cross_features&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在咱们的sklearn中的feature generation中已经介绍了cross_features的相关信息，在sklearn中咱们可以直接将categorical data或者numerical data进行cross操作并且生成一个新的feature， 并且将它进行一个新的feature进行一些feature engineering中的相应的操作。其实在TensorFlow中咱们也有相应的方法进行操作，TensorFlow中有专门的cross_feature来进行操作，并且将返回的cross_feature告诉咱们的模型，这是一个cross feature；在这里咱们也可以看出来TensorFlow的牛逼之处，那就是他只需要告诉咱们的模型咱们的如何操作每一列的数据，而不像在sklearn中的那样，需要咱们自己去label encoding 等一些列复杂的feature engineering的操作。但是凡事都是有好有坏的，TensorFlow中隐藏了很多feature engineering中的很多细节部分也导致咱们不能理解一些操作的底层原理，不利于咱们优化咱们的feature engineering的过程。其实总结起来就是说TensorFlow在cross_feature方面只需要咱们声明一下某几个features需要cross并且告诉一下模型就可以了，而不需要咱们真的去一步步的cross咱们的数据生成一个新的feature从而改变了咱们的原始的dataframe。具体在咱们的TensorFlow中，feature cross有多简单呢，咱们看下面的就可以了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    lon_x_lat = tf.feature_column.crossed_column(keys=&lt;span&gt;[bucketized_longitude, bucketized_latitude],
                                                 hash_bucket_size &lt;/span&gt;= 1000)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意上面的keys是一个list，这个list里面的元素只可以是string或者是categorical feature type的feature_column, 这里的element如果是string的话，我们就会用这些string相对应的feature来cross（同样的，这些feature的data type也必须要是string）；如果是categorical feature type的话，咱们就会直接用这些数据进行cross。这里有个小细节哈就是feature type和data type的区别，初学者经常会混淆，feature type只有2中categorical和numerical， 而data type则有可能是int float string等等，当data type是int 或者 float的时候，那么它的feature type则不一定是numerical，也有可能是categorical,例如咱们上面的bucketized columns虽然data type是int，但是它还是categorical data type。&lt;/p&gt;
&lt;p&gt;在咱们训练模型的过程中，经常会碰到选择optimizer的情况，实际中这一块没有最好只有更好。一般情况下每一种optimizer都有自己的优缺点，适合不同的应用场景。我今天主要讲一下三个常用的optimizer，分别是SGD, Adagrad和Adam。首先SDG是咱们最传统的一种计算梯度下降的算法， 它除了消耗的资源有点大外，没啥大毛病，几乎适用于所有的convex 的场景；Adagrad是一种改进的算法，它的learning rate并不是固定的，它的learning rate能够根据咱们数据的大小来改变的，它在convex problem中的表现非常好，但是在non-convex的场景中，表现的不好；Adam常用于non-convex的场景，它在non-convex中的表现要好于SGD和Adagrad。&lt;/p&gt;
</description>
<pubDate>Thu, 30 Jan 2020 15:26:00 +0000</pubDate>
<dc:creator>HappyPuppy</dc:creator>
<og:description>概述 这一节主要介绍一下TensorFlow在应用的过程中的几个小的知识点，第一个是关于features的处理的，例如Bucketized (Binned) Features 和 Feature sc</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tangxiaobo199181/p/12244347.html</dc:identifier>
</item>
<item>
<title>Linux网络文件共享服务之NFS - qiuhom</title>
<link>http://www.cnblogs.com/qiuhom-1874/p/12237964.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qiuhom-1874/p/12237964.html</guid>
<description>&lt;p&gt;一、NFS服务简介&lt;/p&gt;
&lt;p&gt;　　NFS全称network file system 网络文件系统，基于内核的文件系统，有sun公司开发，通过使用NFS，用户和程序可以像访问本地文件一样访问远端系统上的文件，它基于rpc实现（rpc是remote procedure call protocol 远程过程调用）。RPC采用C/S模式，客户机请求程序调用进程发送一个有进程参数的调用信息到服务进程，然后等待应答信息。在服务器端，进程保存睡眠状态直到调用信息到达为止。当一个调用信息到达，服务器获得进程参数，计算结果，发送答复信息，然后等待下一个调用信息，最后，客户端调用进程接收答复信息，获得进程结果，然后调用执行继续进行。&lt;/p&gt;
&lt;p&gt;　　NFS优势：节省本地存储空间，将常用的数据，如home目录存放在NFS服务器上且可以通过网络访问，本地终端将可减少自身存储空间的使用。&lt;/p&gt;
&lt;p&gt;二、NFS工作原理&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1503305/202001/1503305-20200129230218247-680654806.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　如上图所示，用户需要访问本地的资源，可通过本地文件系统访问，本地磁盘的资源，如果用户访问NFS服务器上的资源，则用户需要通过rpc服务，通过网络去访问NFS服务器，当用户的访问请求到达NFS服务器时，首先到达NFS服务器的tcp/ip协议栈，然后通过询问NFS服务器上的rpc服务，rpc服务在NFS服务器上的作用是当NFS启动时，NFS服务所监听的端口有很多且是随机，不固定，rpc的作用就是记录这些端口，如果有人来访问NFS服务了，它就把NFS的端口信息告诉客户端，然后客户端通过rpc给定端口信息，从而实现访问NFS服务。NFS服务收到客户端的请求，然后通过本地文件系统，访问对应本地磁盘上的文件，从而实现了完成客户端的访问和响应。&lt;/p&gt;
&lt;p&gt;三、NFS服务实现&lt;/p&gt;
&lt;p&gt;　　1、软件包信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]# yum info nfs-utils
已加载插件：fastestmirror
Loading mirror speeds from cached hostfile
 * base: mirrors.aliyun.com
 * extras: mirrors.aliyun.com
 * updates: mirrors.aliyun.com
可安装的软件包
名称    ：nfs-utils
架构    ：x86_64
时期       ：1
版本    ：1.3.0
发布    ：0.65.el7
大小    ：412 k
源    ：base/7/x86_64
简介    ： NFS utilities and supporting clients and daemons for the kernel NFS server
网址    ：http://sourceforge.net/projects/nfs
协议    ： MIT and GPLv2 and GPLv2+ and BSD
描述    ： The nfs-utils package provides a daemon for the kernel NFS server and
         : related tools, which provides a much higher level of performance than the
         : traditional Linux NFS server used by most users.
         : 
         : This package also contains the showmount program.  Showmount queries the
         : mount daemon on a remote host for information about the NFS (Network File
         : System) server on the remote host.  For example, showmount can display the
         : clients which are mounted on that host.
         : 
         : This package also contains the mount.nfs and umount.nfs program.

[root@test ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：NFS它是文件系统，在内核已经支持，且已经有它的驱动，我们装包的原因是，用软件去管理NFS文件系统，因为用户是没有办法直接和内核交互的。从上面的信息也可了解到nfs-utils的介绍它是NFS实用程序和支持NFS内核服务器的客户机和守护进程。&lt;/p&gt;
&lt;p&gt;　　2、安装nfs-utils&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]# yum install nfs-utils
……省略部分信息
依赖关系解决

============================================================================================================
 Package                       架构                 版本                           源                  大小
============================================================================================================
正在安装:
 nfs-utils                     x86_64               1:1.3.0-0.65.el7               base               412 k
为依赖而安装:
 gssproxy                      x86_64               0.7.0-26.el7                   base               110 k
 keyutils                      x86_64               1.5.8-3.el7                    base                54 k
 libbasicobjects               x86_64               0.1.1-32.el7                   base                26 k
 libcollection                 x86_64               0.7.0-32.el7                   base                42 k
 libini_config                 x86_64               1.3.1-32.el7                   base                64 k
 libnfsidmap                   x86_64               0.25-19.el7                    base                50 k
 libpath_utils                 x86_64               0.2.1-32.el7                   base                28 k
 libref_array                  x86_64               0.1.5-32.el7                   base                27 k
 libtirpc                      x86_64               0.2.4-0.16.el7                 base                89 k
 libverto-tevent               x86_64               0.2.5-4.el7                    base               9.0 k
 quota                         x86_64               1:4.01-19.el7                  base               179 k
 quota-nls                     noarch               1:4.01-19.el7                  base                90 k
 rpcbind                       x86_64               0.2.0-48.el7                   base                60 k
 tcp_wrappers                  x86_64               7.6-77.el7                     base                78 k

事务概要
============================================================================================================
安装  1 软件包 (+14 依赖软件包)
……省略部分信息
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：可以看到nfs-utils依赖这些包，其中rpcbind就是nfs启动时所使用的端口它会记录起来，一旦有客户端访问，它就把nfs的端口信息告诉给客户端&lt;/p&gt;
&lt;p&gt;　　3、写配置文件，让其客户端允许访问本地的资源&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]# mkdir /nfsdir
[root@test ~]# cat &amp;gt;&amp;gt; /etc/exports &amp;lt;&amp;lt; EOF
&amp;gt; /nfsdir 192.168.0.0/24(rw)
&amp;gt; EOF
[root@test ~]# cat /etc/exports
/nfsdir 192.168.0.0/24(rw)
[root@test ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：nfs服务的配置文件是/etc/exports 和/etc/exports.d/*.exports，以上定义了/nfsdir目录允许192.168.0.0/24当用户访问，相当与把/nfsdir给共享出来了&lt;/p&gt;
&lt;p&gt;　　4、启动服务&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]# systemctl status rpcbind nfs-server
● rpcbind.service - RPC bind service
   Loaded: loaded (/usr/lib/systemd/system/rpcbind.service; enabled; vendor preset: enabled)
   Active: inactive (dead)

● nfs-server.service - NFS server and services
   Loaded: loaded (/usr/lib/systemd/system/nfs-server.service; disabled; vendor preset: disabled)
   Active: inactive (dead)
[root@test ~]# systemctl start nfs-server
[root@test ~]# systemctl status rpcbind nfs-server
● rpcbind.service - RPC bind service
   Loaded: loaded (/usr/lib/systemd/system/rpcbind.service; enabled; vendor preset: enabled)
   Active: active (running) since 三 2020-01-29 23:52:08 CST; 2s ago
  Process: 4754 ExecStart=/sbin/rpcbind -w $RPCBIND_ARGS (code=exited, status=0/SUCCESS)
 Main PID: 4756 (rpcbind)
    Tasks: 1
   Memory: 1.1M
   CGroup: /system.slice/rpcbind.service
           └─4756 /sbin/rpcbind -w

1月 29 23:52:08 test systemd[1]: Starting RPC bind service...
1月 29 23:52:08 test systemd[1]: Started RPC bind service.

● nfs-server.service - NFS server and services
   Loaded: loaded (/usr/lib/systemd/system/nfs-server.service; disabled; vendor preset: disabled)
   Active: active (exited) since 三 2020-01-29 23:52:08 CST; 1s ago
  Process: 4787 ExecStartPost=/bin/sh -c if systemctl -q is-active gssproxy; then systemctl reload gssproxy ; fi (code=exited, status=0/SUCCESS)
  Process: 4771 ExecStart=/usr/sbin/rpc.nfsd $RPCNFSDARGS (code=exited, status=0/SUCCESS)
  Process: 4768 ExecStartPre=/usr/sbin/exportfs -r (code=exited, status=0/SUCCESS)
 Main PID: 4771 (code=exited, status=0/SUCCESS)
    Tasks: 0
   Memory: 0B
   CGroup: /system.slice/nfs-server.service

1月 29 23:52:08 test systemd[1]: Starting NFS server and services...
1月 29 23:52:08 test systemd[1]: Started NFS server and services.
[root@test ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：可看到在rpcbind 服务没有启动的情况下，直接启动nfs-server ，它会把rpcbind给一并启动起来，因为nfs-server依赖rpcbind服务。这个是在centos7上是这样的，centos7上有服务依赖解决，如果启动服务所依赖的服务没有启动，它会激活所依赖的服务，然后启动服务。在centos6上就没有这样的功能，在centos6上如果rpcbind没有启动起来，则nfs服务是启动不了的。&lt;/p&gt;
&lt;p&gt;　　5、在客户端查看共享目录以及挂载nfs共享出来的目录&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-node1 ~]#showmount -e 192.168.0.99
Export list for 192.168.0.99:
/nfsdir 192.168.0.0/24
[root@test-node1 ~]#mount 192.168.0.99:/nfsdir /mnt
[root@test-node1 ~]#df
Filesystem           1K-blocks     Used Available Use% Mounted on
/dev/mapper/VolGroup-lv_root
                      51475068  4746696  44106932  10% /
tmpfs                   959580        0    959580   0% /dev/shm
/dev/sda1               487652    45302    416750  10% /boot
/dev/mapper/VolGroup-lv_home
                     251354900    69264 238510828   1% /home
192.168.0.99:/nfsdir  27560960 13935872  13625088  51% /mnt
[root@test-node1 ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：可看到nfs服务器共享出来的目录在服务端是可以查看得到的，这里需要注意客户端也需要安装nfs-utils才可以用showmount命令来查看共享目录。nfs同ftp服务不一样，ftp共享出来的目录，我们是看不出来它在服务器上的具体路径，而nfs是可以看到的。&lt;/p&gt;
&lt;p&gt;四、测试在客户新建文件写入数据，看服务端的本地目录的变化&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-node1 ~]#cd /mnt
[root@test-node1 mnt]#ls
[root@test-node1 mnt]#touch clientfile
touch: cannot touch `clientfile': Permission denied
[root@test-node1 mnt]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：默认我们配置的nfs是允许对写，为什么在客户端没法创建文件呢？它告诉我们权限拒绝这到底是为什么呢？我们在服务器上用exportfs -v来查看nfs加载的配置内容&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]# exportfs -v
/nfsdir         192.168.0.0/24(sync,wdelay,hide,no_subtree_check,sec=sys,rw,secure,root_squash,no_all_squash)
[root@test ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：从上面的信息可以看到我们虽然配置了允许192.168.0.0/24这个网段的所有主机对其/nfsdir有读写权限（rw）,但是它还有默认配置了root_squash，这个权限表示客户端root账号权限在NFS服务器上会压榨，也就是说客户端的root到NFS服务器上就不是root权限了，那客户端的root到nfs服务器上是什么权限呢？ &lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]# chmod 777 /nfsdir
[root@test ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：把NFS共享出来的目录修改成777权限，然后在客户端在新建文件看看新建的文件的所有者和组就可以知道客户端的root到NFS服务器上是被映射成那个用户了&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-node1 ~]#cd /mnt
[root@test-node1 mnt]#ls
[root@test-node1 mnt]#touch rootfile
[root@test-node1 mnt]#ll
total 0
-rw-r--r-- 1 nfsnobody nfsnobody 0 Jan 30 00:21 rootfile
[root@test-node1 mnt]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：可看到客户端的root在共享目录里新建的文件是nfsnobody的所有者和组，那么我们只需要在服务端把共享目录的权限设置成nfsnobody这个用户可读写权限，客户端root就可在里面创建文件了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]# chmod 755 /nfsdir
[root@test ~]# ll /nfsdir -d
drwxr-xr-x 2 root root 22 1月  30 00:21 /nfsdir
[root@test ~]# setfacl -m u:nfsnobody:rwx /nfsdir
[root@test ~]# getfacl /nfsdir
getfacl: Removing leading '/' from absolute path names
# file: nfsdir
# owner: root
# group: root
user::rwx
user:nfsnobody:rwx
group::r-x
mask::rwx
other::r-x

[root@test ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：设置了/nfsdir这个共享目录nfsnobody用户有读写执行权限，那么客户端的root用户在共享目录新建文件是否还有问题呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-node1 mnt]#pwd
/mnt
[root@test-node1 mnt]#touch rootfile2
[root@test-node1 mnt]#ll 
total 0
-rw-r--r-- 1 nfsnobody nfsnobody 0 Jan 30 00:21 rootfile
-rw-r--r-- 1 nfsnobody nfsnobody 0 Jan 30 00:27 rootfile2
[root@test-node1 mnt]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：可看到客户端root用户在共享目录里是可以正常的创建文件的，那么客户端普通用户是否也可以呢？试一试&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-node1 mnt]#su - qiuhom
[qiuhom@test-node1 ~]$cd /mnt
[qiuhom@test-node1 mnt]$ll
total 0
-rw-r--r-- 1 nfsnobody nfsnobody 0 Jan 30 00:21 rootfile
-rw-r--r-- 1 nfsnobody nfsnobody 0 Jan 30 00:27 rootfile2
[qiuhom@test-node1 mnt]$touch qiuhomfile
touch: cannot touch `qiuhomfile': Permission denied
[qiuhom@test-node1 mnt]$
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：客户端的普通用户为什么就不能在共享目录里新建文件呢？我们在来看看服务端的配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]# exportfs -v
/nfsdir         192.168.0.0/24(sync,wdelay,hide,no_subtree_check,sec=sys,rw,secure,root_squash,no_all_squash)
[root@test ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：虽然服务端允许客户端的root映射成nfsnobody，但是后面又设置了no_all_squash，这个权限表示所有的用户不压榨，也就是说root用户压榨，其他用户不压榨，也就说除root用户，其他用户都不映射成nfsnobody用户。那么其他用户在NFS服务端映射成那个用户了呢？用上面的方法，把服务端共享的目录修改成777权限，然后客户端用普通用在其共享目录新建文件，看看里面新建的文件的所有者和组就知道了&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]# chmod 777 /nfsdir
[root@test ~]# 
==================================
[qiuhom@test-node1 mnt]$touch qiuhomfile
[qiuhom@test-node1 mnt]$ll
total 0
-rw-rw-r-- 1 qiuhom    qiuhom    0 Jan 30 00:35 qiuhomfile
-rw-r--r-- 1 nfsnobody nfsnobody 0 Jan 30 00:21 rootfile
-rw-r--r-- 1 nfsnobody nfsnobody 0 Jan 30 00:27 rootfile2
[qiuhom@test-node1 mnt]$
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：把服务端的共享目录权限更改为777后客户端的普通用在其里面新建文件的所有者和组都变成了客户端的普通用名称，但是这是在客户端查看的信息是这样的，我们在服务端查看是不是这样的呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]# ll /nfsdir
总用量 0
-rw-rw-r-- 1       503       503 0 1月  30 00:35 qiuhomfile
-rw-r--r-- 1 nfsnobody nfsnobody 0 1月  30 00:21 rootfile
-rw-r--r-- 1 nfsnobody nfsnobody 0 1月  30 00:27 rootfile2
[root@test ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：怎么在服务端查看刚才客户端普通用户新建的文件所有者和组是503呢？我们在来看看客户端普通用户的uid就明白了&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[qiuhom@test-node1 mnt]$id qiuhom
uid=503(qiuhom) gid=503(qiuhom) groups=503(qiuhom)
[qiuhom@test-node1 mnt]$
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：是不是明白了，普通用在nfs服务端陪映射成以普通用户uid和gid的用户了，如果服务端有对应uid用户和gid组，则服务端就会显示器名称，如果没有则显示器uid和gid，这个是服务端配置了root_squash和no_all_squash 是这样的。&lt;/p&gt;
&lt;p&gt;五、nfs配置文件格式说明&lt;/p&gt;
&lt;p&gt;　　1、nfs配置文件格式&lt;/p&gt;
&lt;p&gt;　　需要共享的目录路径    允许访问的主机或网段1（选项）   主机或网段2（选项）……&lt;/p&gt;
&lt;p&gt;　　2、“#”井号表示注释&lt;/p&gt;
&lt;p&gt;　　3、单个主机可以是ipv4地址，ipv6地址，FQDN（域名）&lt;/p&gt;
&lt;p&gt;　　4、网段支持两种掩码格式如：192.168.0.0/24  或者192.168.0.0/255.255.255.0&lt;/p&gt;
&lt;p&gt;　　5、通配符支持域名，不支持ip，如：*.test.com&lt;/p&gt;
&lt;p&gt;　　6、支持NIS域的主机组，如：@group_name&lt;/p&gt;
&lt;p&gt;　　7、anonymous：表示使用*通配所有客户端&lt;/p&gt;
&lt;p&gt;六、配置文件每个条目指定目录导出到的哪些主机，及相关的权限和选项说明&lt;/p&gt;
&lt;p&gt;　　1、默认选项：(ro,sync,root_squash,no_all_squash)&lt;/p&gt;
&lt;p&gt;　　2、ro,rw 只读和读写&lt;/p&gt;
&lt;p&gt;　　3、async 异步，数据变化后不立即写磁盘，性能高&lt;/p&gt;
&lt;p&gt;　　4、sync（1.0.0后为默认）同步，数据在请求时立即写入共享&lt;/p&gt;
&lt;p&gt;　　5、 no_all_squash （默认）保留共享文件的UID和GID&lt;/p&gt;
&lt;p&gt;　　6、 all_squash 所有远程用户(包括root)都变成nfsnobody&lt;/p&gt;
&lt;p&gt;　　7、 root_squash （默认）远程root映射为nfsnobody,UID为65534，早期版本是4294967294 (nfsnobody)&lt;/p&gt;
&lt;p&gt;　　8、no_root_squash 远程root映射成root用户&lt;/p&gt;
&lt;p&gt;　　9、anonuid和anongid 指明匿名用户映射为特定用户UID和组GID，而非nfsnobody,可配合all_squash使用&lt;/p&gt;
&lt;p&gt;七、NFS工具使用&lt;/p&gt;
&lt;p&gt;　　rpcinfo：查看rpc信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
qiuhom@test-node1 mnt]$rpcinfo -p 192.168.0.99
   program vers proto   port  service
    100000    4   tcp    111  portmapper
    100000    3   tcp    111  portmapper
    100000    2   tcp    111  portmapper
    100000    4   udp    111  portmapper
    100000    3   udp    111  portmapper
    100000    2   udp    111  portmapper
    100005    1   udp  20048  mountd
    100005    1   tcp  20048  mountd
    100024    1   udp  38042  status
    100024    1   tcp  45458  status
    100005    2   udp  20048  mountd
    100005    2   tcp  20048  mountd
    100005    3   udp  20048  mountd
    100005    3   tcp  20048  mountd
    100003    3   tcp   2049  nfs
    100003    4   tcp   2049  nfs
    100227    3   tcp   2049  nfs_acl
    100003    3   udp   2049  nfs
    100003    4   udp   2049  nfs
    100227    3   udp   2049  nfs_acl
    100021    1   udp  37177  nlockmgr
    100021    3   udp  37177  nlockmgr
    100021    4   udp  37177  nlockmgr
    100021    1   tcp  40293  nlockmgr
    100021    3   tcp  40293  nlockmgr
    100021    4   tcp  40293  nlockmgr
[qiuhom@test-node1 mnt]$
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：-p选项指定查看指定服务器上rpcbind所注册的端口信息，若-p后面不指定主机表示查看本机的端口注册信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;61&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[qiuhom@test-node1 mnt]$rpcinfo -s 192.168.0.99
   program version(s) netid(s)                         service     owner
    100000  2,3,4     local,udp,tcp,udp6,tcp6          portmapper  superuser
    100005  3,2,1     tcp6,udp6,tcp,udp                mountd      superuser
    100024  1         tcp6,udp6,tcp,udp                status      29
    100003  4,3       udp6,tcp6,udp,tcp                nfs         superuser
    100227  3         udp6,tcp6,udp,tcp                nfs_acl     superuser
    100021  4,3,1     tcp6,udp6,tcp,udp                nlockmgr    superuser
[qiuhom@test-node1 mnt]$
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：-s选项表示查看rpc注册的程序，若不跟主机地址，则表示查看本机rpc注册的程序信息&lt;/p&gt;
&lt;p&gt;　　exportfs：维护导出的NFS文件系统表&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]# exportfs -v
/nfsdir         192.168.0.0/24(sync,wdelay,hide,no_subtree_check,sec=sys,rw,secure,root_squash,no_all_squash)
[root@test ~]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：-v选项表示查看本机所有NFS共享详情&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]# cat /etc/exports
/nfsdir 192.168.0.0/24(rw)
[root@test ~]# cat &amp;gt; /etc/exports
/nfsdir *
^C
[root@test ~]# cat /etc/exports
/nfsdir *
[root@test ~]# exportfs -r
exportfs: No options for /nfsdir *: suggest *(sync) to avoid warning
[root@test ~]# exportfs -v
/nfsdir         &amp;lt;world&amp;gt;(sync,wdelay,hide,no_subtree_check,sec=sys,ro,secure,root_squash,no_all_squash)
[root@test ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：-r选项表示不重启重读配置文件，并共享目录，如果配置文件中没有明确写明是同步写磁盘还是异步写磁盘，它重读配置文件的时候它会警告我们建议加上sync&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;53&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]# exportfs -v
/nfsdir         &amp;lt;world&amp;gt;(sync,wdelay,hide,no_subtree_check,sec=sys,ro,secure,root_squash,no_all_squash)
[root@test ~]# cat &amp;gt; /etc/exports
/nfsdir *(rw,all_squash)
^C
[root@test ~]# cat /etc/exports
/nfsdir *(rw,all_squash)
[root@test ~]# exportfs -a
[root@test ~]# exportfs -v
/nfsdir         &amp;lt;world&amp;gt;(sync,wdelay,hide,no_subtree_check,sec=sys,rw,secure,root_squash,all_squash)
[root@test ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：-a选项表示重读配置并输出本机所有共享，如果停止本机的共享，使用-a会恢复所有共享&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]# exportfs -au
[root@test ~]# exportfs -v 
[root@test ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：-au选项表示停止所有共享&lt;/p&gt;
&lt;p&gt;　　showmount -e hostname：查看指定主机上的共享目录情况&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]# showmount -e 192.168.0.99
Export list for 192.168.0.99:
/nfsdir *
[root@test ~]# showmount -e 
Export list for test:
/nfsdir *
[root@test ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：-e后面若不跟主机地址，则表示查看本机的恭喜那个目录情况&lt;/p&gt;
&lt;p&gt; 八、客户端NFS挂载说明&lt;/p&gt;
&lt;p&gt;　　基于安全考虑，建议使用nosuid,nodev,noexec挂载选项&lt;/p&gt;
&lt;p&gt;　　NFS相关的挂载选项：&lt;/p&gt;
&lt;p&gt;　　　　fg（默认）前台挂载，bg后台挂载&lt;/p&gt;
&lt;p&gt;　　　　hard（默认）持续请求，soft 非持续请求&lt;/p&gt;
&lt;p&gt;　　　　intr 和hard配合，请求可中断&lt;/p&gt;
&lt;p&gt;　　　　rsize和wsize 一次读和写数据最大字节数，rsize=32768&lt;/p&gt;
&lt;p&gt;　　　　_netdev 无网络不挂载&lt;/p&gt;
&lt;p&gt;　　示例：&lt;/p&gt;
&lt;p&gt;　　　　mount -o rw,nosuid,fg,hard,intr 172.16.0.1:/testdir /mnt/nfs/&lt;/p&gt;
&lt;p&gt;　　开机挂载：编辑/etc/fstab文件在文件最后添加，如：172.16.0.1:/public /mnt/nfs nfs defaults 0 0&lt;/p&gt;
&lt;p&gt;九、NFS实现伪根&lt;/p&gt;
&lt;p&gt;　　1、创建目录&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]# mkdir /root/dir{1,2} -pv
mkdir: 已创建目录 &quot;/root/dir1&quot;
mkdir: 已创建目录 &quot;/root/dir2&quot;
[root@test ~]# mkdir /test/dir{1,2} -pv
mkdir: 已创建目录 &quot;/test&quot;
mkdir: 已创建目录 &quot;/test/dir1&quot;
mkdir: 已创建目录 &quot;/test/dir2&quot;
[root@test ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2、编写/etc/fstab文件，在其文件中填写如下内容&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]# tail -n 2 /etc/fstab
/root/dir1 /test/dir1 none bind 0 0
/root/dir2 /test/dir2 none bind 0 0
[root@test ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　3、编写/etc/exports文件，在其文件中添加如下内容&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]# cat /etc/exports
/test *(fsid=0,rw,crossmnt)
/test/dir1 192.168.0.0/24(rw,all_squash)
/test/dir2 192.168.0.0/24(rw,all_squash)
[root@test ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　4、挂载所有目录，并重读NFS配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;69&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]# mount -a
[root@test ~]# mount |tail -n 2
/dev/mapper/centos-root on /test/dir1 type xfs (rw,relatime,attr2,inode64,noquota)
/dev/mapper/centos-root on /test/dir2 type xfs (rw,relatime,attr2,inode64,noquota)
[root@test ~]# exportfs -r
[root@test ~]# exportfs -v
/test/dir1      192.168.0.0/24(sync,wdelay,hide,no_subtree_check,sec=sys,rw,secure,root_squash,all_squash)
/test/dir2      192.168.0.0/24(sync,wdelay,hide,no_subtree_check,sec=sys,rw,secure,root_squash,all_squash)
/test           &amp;lt;world&amp;gt;(sync,wdelay,hide,crossmnt,no_subtree_check,fsid=0,sec=sys,rw,secure,root_squash,no_all_squash)
[root@test ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：到此服务端的配置就完成了，接下来在客户端挂载即可&lt;/p&gt;
&lt;p&gt;　　5、客户端挂载伪根&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-node1 ~]#mkdir xxx
[root@test-node1 ~]#mount 192.168.0.99:/ ./xxx/
[root@test-node1 ~]#df
df: `/mnt': Stale file handle
Filesystem           1K-blocks     Used Available Use% Mounted on
/dev/mapper/VolGroup-lv_root
                      51475068  4746736  44106892  10% /
tmpfs                   959580        0    959580   0% /dev/shm
/dev/sda1               487652    45302    416750  10% /boot
/dev/mapper/VolGroup-lv_home
                     251354900    69268 238510824   1% /home
192.168.0.99:/        27560960 13935360  13625600  51% /root/xxx
[root@test-node1 ~]#ls xxx/
dir1  dir2
[root@test-node1 ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：如果客户端需要实现开机挂载，则需要在/etc/fstab下写明挂载关系和挂载选项即可，如：192.168.0.99：/ /root/xxx/ nfs ro 0 0&lt;/p&gt;
&lt;p&gt;十、配置NFS使用固定端口&lt;/p&gt;
&lt;p&gt;　　编辑配置文件/etc/sysconfig/nfs在其最后添加RQUOTAD_PORT=875（端口可以根据实际情况来定）修改后的文件如下几项内容&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]# grep  &quot;PORT&quot; /etc/sysconfig/nfs
LOCKD_TCPPORT=32803
LOCKD_UDPPORT=32769
MOUNTD_PORT=892
STATD_PORT=662
STATD_OUTGOING_PORT=2020
RQUOTAD_PORT=875
[root@test ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：除了以上端口外，防火墙配置还需要开放tcp和udp的111端口和2049端口共4个端口。配置了以上配置文件后，然后重启nfs-server服务，nfs注册的端口就不会变了，如下所示&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]# systemctl restart nfs-server
[root@test ~]# rpcinfo -p
   program vers proto   port  service
    100000    4   tcp    111  portmapper
    100000    3   tcp    111  portmapper
    100000    2   tcp    111  portmapper
    100000    4   udp    111  portmapper
    100000    3   udp    111  portmapper
    100000    2   udp    111  portmapper
    100024    1   udp  38042  status
    100024    1   tcp  45458  status
    100005    1   udp    892  mountd
    100005    1   tcp    892  mountd
    100005    2   udp    892  mountd
    100005    2   tcp    892  mountd
    100005    3   udp    892  mountd
    100005    3   tcp    892  mountd
    100003    3   tcp   2049  nfs
    100003    4   tcp   2049  nfs
    100227    3   tcp   2049  nfs_acl
    100003    3   udp   2049  nfs
    100003    4   udp   2049  nfs
    100227    3   udp   2049  nfs_acl
    100021    1   udp  32769  nlockmgr
    100021    3   udp  32769  nlockmgr
    100021    4   udp  32769  nlockmgr
    100021    1   tcp  32803  nlockmgr
    100021    3   tcp  32803  nlockmgr
    100021    4   tcp  32803  nlockmgr
[root@test ~]# systemctl restart nfs-server
[root@test ~]# rpcinfo -p                  
   program vers proto   port  service
    100000    4   tcp    111  portmapper
    100000    3   tcp    111  portmapper
    100000    2   tcp    111  portmapper
    100000    4   udp    111  portmapper
    100000    3   udp    111  portmapper
    100000    2   udp    111  portmapper
    100024    1   udp  38042  status
    100024    1   tcp  45458  status
    100005    1   udp    892  mountd
    100005    1   tcp    892  mountd
    100005    2   udp    892  mountd
    100005    2   tcp    892  mountd
    100005    3   udp    892  mountd
    100005    3   tcp    892  mountd
    100003    3   tcp   2049  nfs
    100003    4   tcp   2049  nfs
    100227    3   tcp   2049  nfs_acl
    100003    3   udp   2049  nfs
    100003    4   udp   2049  nfs
    100227    3   udp   2049  nfs_acl
    100021    1   udp  32769  nlockmgr
    100021    3   udp  32769  nlockmgr
    100021    4   udp  32769  nlockmgr
    100021    1   tcp  32803  nlockmgr
    100021    3   tcp  32803  nlockmgr
    100021    4   tcp  32803  nlockmgr
[root@test ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;十一、NFS实现自动挂载&lt;/p&gt;
&lt;p&gt;　　1、客户端安装autofs软件包&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-centos7-node1 ~]# yum info autofs
Loaded plugins: fastestmirror
Loading mirror speeds from cached hostfile
Available Packages
Name        : autofs
Arch        : x86_64
Epoch       : 1
Version     : 5.0.7
Release     : 69.el7
Size        : 808 k
Repo        : my_base/7/x86_64
Summary     : A tool for automatically mounting and unmounting filesystems
License     : GPLv2+
Description : autofs is a daemon which automatically mounts filesystems when you use
            : them, and unmounts them later when you are not using them.  This can
            : include network filesystems, CD-ROMs, floppies, and so forth.

[root@test-centos7-node1 ~]# yum install -y autofs
Loaded plugins: fastestmirror
epel                                                                                                     | 5.3 kB  00:00:00     
my_base                                                                                                  | 3.6 kB  00:00:00     
Loading mirror speeds from cached hostfile
Resolving Dependencies
--&amp;gt; Running transaction check
---&amp;gt; Package autofs.x86_64 1:5.0.7-69.el7 will be installed
--&amp;gt; Processing Dependency: libtirpc.so.1()(64bit) for package: 1:autofs-5.0.7-69.el7.x86_64
--&amp;gt; Processing Dependency: libhesiod.so.0()(64bit) for package: 1:autofs-5.0.7-69.el7.x86_64
--&amp;gt; Running transaction check
---&amp;gt; Package hesiod.x86_64 0:3.2.1-3.el7 will be installed
---&amp;gt; Package libtirpc.x86_64 0:0.2.4-0.10.el7 will be installed
--&amp;gt; Finished Dependency Resolution

Dependencies Resolved

================================================================================================================================
 Package                      Arch                       Version                              Repository                   Size
================================================================================================================================
Installing:
 autofs                       x86_64                     1:5.0.7-69.el7                       my_base                     808 k
Installing for dependencies:
 hesiod                       x86_64                     3.2.1-3.el7                          my_base                      30 k
 libtirpc                     x86_64                     0.2.4-0.10.el7                       my_base                      88 k

Transaction Summary
================================================================================================================================
Install  1 Package (+2 Dependent packages)

Total download size: 927 k
Installed size: 5.3 M
Downloading packages:
(1/3): hesiod-3.2.1-3.el7.x86_64.rpm                                                                     |  30 kB  00:00:00     
(2/3): libtirpc-0.2.4-0.10.el7.x86_64.rpm                                                                |  88 kB  00:00:00     
(3/3): autofs-5.0.7-69.el7.x86_64.rpm                                                                    | 808 kB  00:00:00     
--------------------------------------------------------------------------------------------------------------------------------
Total                                                                                           1.9 MB/s | 927 kB  00:00:00     
Running transaction check
Running transaction test
Transaction test succeeded
Running transaction
Warning: RPMDB altered outside of yum.
  Installing : libtirpc-0.2.4-0.10.el7.x86_64                                                                               1/3 
  Installing : hesiod-3.2.1-3.el7.x86_64                                                                                    2/3 
  Installing : 1:autofs-5.0.7-69.el7.x86_64                                                                                 3/3 
  Verifying  : 1:autofs-5.0.7-69.el7.x86_64                                                                                 1/3 
  Verifying  : hesiod-3.2.1-3.el7.x86_64                                                                                    2/3 
  Verifying  : libtirpc-0.2.4-0.10.el7.x86_64                                                                               3/3 

Installed:
  autofs.x86_64 1:5.0.7-69.el7                                                                                                  

Dependency Installed:
  hesiod.x86_64 0:3.2.1-3.el7                                  libtirpc.x86_64 0:0.2.4-0.10.el7                                 

Complete!
[root@test-centos7-node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：从上面的信息可以知道autofs这个包的主要功能就是自动挂载和卸载文件系统的工具&lt;/p&gt;
&lt;p&gt;　　2、查看autofs的配置文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-centos7-node1 ~]# rpm -ql autofs|grep etc
/etc/auto.master
/etc/auto.master.d
/etc/auto.misc
/etc/auto.net
/etc/auto.smb
/etc/autofs.conf
/etc/autofs_ldap_auth.conf
/etc/sysconfig/autofs
[root@test-centos7-node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：可以看到autofs的组配置文件是/etc/auto.master  当然也可以把配置文件放到/etc/auto.master.d/下&lt;/p&gt;
&lt;p&gt;　　3、查看主配置文件中定义的内容&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-centos7-node1 ~]# cat /etc/auto.master
#
# Sample auto.master file
# This is a 'master' automounter map and it has the following format:
# mount-point [map-type[,format]:]map [options]
# For details of the format look at auto.master(5).
#
/misc   /etc/auto.misc
#
# NOTE: mounts done from a hosts map will be mounted with the
#       &quot;nosuid&quot; and &quot;nodev&quot; options unless the &quot;suid&quot; and &quot;dev&quot;
#       options are explicitly given.
#
/net    -hosts
#
# Include /etc/auto.master.d/*.autofs
# The included files must conform to the format of this file.
#
+dir:/etc/auto.master.d
#
# Include central master map if it can be found using
# nsswitch sources.
#
# Note that if there are entries for /net or /misc (as
# above) in the included master map any keys that are the
# same will not be seen as the first read key seen takes
# precedence.
#
+auto.master
[root@test-centos7-node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：以上主配置文件定义了/misc 目录下的子目录挂载策略的子配置文件是/etc/auto.misc。我们可以这样理解，/etc/auto.master这个文件定义了挂载点的父目录位置，以及该父目录下面的子目录挂载策略的配置文件存放路径和名称。也就是说我们要实现自动挂载，我们需要把挂载点分成两部分，第一部分是挂载点的父目录在哪里，这个需要在/etc/auto.master里面定，除此之外，我们还需要在/etc/master下面定义挂载点的父目录下的子目录挂载策略的配置文件的路径以及名称。当然这个路径和名称可以根据自己的情况来写，通常情况下我们放在/etc/下面。了解了/etc/auto.master的配置文件规则，我们可以清楚的知道/misc 这个目录下的子目录挂载规则是存放在/etc/auto.misc里，接下来我们再来看看这个子配置文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-centos7-node1 ~]# cat /etc/auto.misc 
#
# This is an automounter map and it has the following format
# key [ -mount-options-separated-by-comma ] location
# Details may be found in the autofs(5) manpage

cd              -fstype=iso9660,ro,nosuid,nodev :/dev/cdrom

# the following entries are samples to pique your imagination
#linux          -ro,soft,intr           ftp.example.org:/pub/linux
#boot           -fstype=ext2            :/dev/hda1
#floppy         -fstype=auto            :/dev/fd0
#floppy         -fstype=ext2            :/dev/fd0
#e2floppy       -fstype=ext2            :/dev/fd0
#jaz            -fstype=ext2            :/dev/sdc1
#removable      -fstype=ext2            :/dev/hdd
[root@test-centos7-node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：这个之配置文件除了注释以外就只有一行，从上面的描述，我们不难理解子配置文件中的这个配置是什么意思。结合上面说的 这个之配置文件是/misc目录下的子目录挂载策略的配置。以上配置表示在/misc/cd目录挂载对应的设备上 /dev/cdrom 文件系统是iso9660 以只读，nosuid，nodev选项挂载。看了以上的配置我们就很容易理解，centos7上的&quot;神奇的目录&quot;，之所以我们在不访问/misc/cd 的时候是看不到挂载的，一旦访问就有挂载自动挂上去了 ，它的实现原理就是通过autofs自动挂载实现的。理解了上面的配置我们就可以写自己的挂载策略实现自动挂载&lt;/p&gt;
&lt;p&gt;　　4、NFS自动挂载实现&lt;/p&gt;
&lt;p&gt;　　　　4.1相对路径法&lt;/p&gt;
&lt;p&gt;　　　　首先解释下说明叫相对路径法，相对路径就是我们上面说的/misc/cd 这个挂载点例子，它是把挂载点分成了了basename和dirname两部分来配置的，所以说在组配置文件中（/etc/auto.master）需要定义dirname路径以及basename子目录挂载策略的配置文件路径和名称。然后在对应的之配置文件中写清楚挂载策略和子目录的关系即可&lt;/p&gt;
&lt;p&gt;　　　　将192.168.0.99：/nfsdir  自动挂载到本机的/auto/nfs/目录下&lt;/p&gt;
&lt;p&gt;　　　　4.1.1、编辑组配置文件定义父目录 和子目录配置文件的路径和名称&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-centos7-node1 ~]# grep nfs /etc/auto.master
/auto   /etc/nfs_auto.txt
[root@test-centos7-node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：以上内容是我们自己行家挂载点父目录和子目录配置文件的路径和名称，这个子配置文件的名称没有什么要求，可以随意写。&lt;/p&gt;
&lt;p&gt;　　　　4.1.2、在对应子配置文件中写子目录挂载策略&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-centos7-node1 ~]# cat /etc/nfs_auto.txt
nfs   -fstype=nfs,rw,vers=3   192.168.0.99:/nfsdir
[root@test-centos7-node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：配置好子目录的挂载策略后就实现了自动挂载。这里还需要注意一点的是，我们在客户端实现自动挂载的前提是NFS可以在客户端挂载，如果客户端都看不到NFS共享出来的目录，当然也不能实现自动挂载&lt;/p&gt;
&lt;p&gt;　　　　4.1.3、在客户端查看是否能够看到NFS共享出来的目录&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-centos7-node1 ~]# showmount -e 192.168.0.99
Export list for 192.168.0.99:
/test      *
/test/dir2 192.168.0.0/24
/test/dir1 192.168.0.0/24
/nfsdir    192.168.0.0/24
[root@test-centos7-node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：可看到在客户端是可以看到服务端的nfs共享的目录，接下来我们启动autofs服务查看挂载情况&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-centos7-node1 ~]# systemctl status autofs
● autofs.service - Automounts filesystems on demand
   Loaded: loaded (/usr/lib/systemd/system/autofs.service; disabled; vendor preset: disabled)
   Active: inactive (dead)
[root@test-centos7-node1 ~]# systemctl start autofs
[root@test-centos7-node1 ~]# systemctl status autofs
● autofs.service - Automounts filesystems on demand
   Loaded: loaded (/usr/lib/systemd/system/autofs.service; disabled; vendor preset: disabled)
   Active: active (running) since Tue 2020-01-28 18:13:19 CST; 1min 21s ago
  Process: 3862 ExecStart=/usr/sbin/automount $OPTIONS --pid-file /run/autofs.pid (code=exited, status=0/SUCCESS)
 Main PID: 3864 (automount)
   CGroup: /system.slice/autofs.service
           └─3864 /usr/sbin/automount --pid-file /run/autofs.pid

Jan 28 18:13:17 test-centos7-node1 automount[3864]: master_add_map_source: map source used without taking reference
Jan 28 18:13:17 test-centos7-node1 automount[3864]: master_add_map_source: map source used without taking reference
Jan 28 18:13:17 test-centos7-node1 automount[3864]: open_sss_lib:78: lookup(sss): failed to open /usr/lib64/sssd/modules...ctory
Jan 28 18:13:19 test-centos7-node1 automount[3864]: problem reading master map, maximum wait exceeded
Jan 28 18:13:19 test-centos7-node1 automount[3864]: /usr/sbin/automount: warning: could not read at least one map source...g ...
Jan 28 18:13:19 test-centos7-node1 automount[3864]: master_add_map_source: map source used without taking reference
Jan 28 18:13:19 test-centos7-node1 automount[3864]: master_add_map_source: map source used without taking reference
Jan 28 18:13:19 test-centos7-node1 automount[3864]: master_add_map_source: map source used without taking reference
Jan 28 18:13:19 test-centos7-node1 automount[3864]: open_sss_lib:78: lookup(sss): failed to open /usr/lib64/sssd/modules...ctory
Jan 28 18:13:19 test-centos7-node1 systemd[1]: Started Automounts filesystems on demand.
Hint: Some lines were ellipsized, use -l to show in full.
[root@test-centos7-node1 ~]# df
Filesystem     1K-blocks    Used Available Use% Mounted on
/dev/sda3       48209924 3116852  45093072   7% /
devtmpfs         1922828       0   1922828   0% /dev
tmpfs            1932652      20   1932632   1% /dev/shm
tmpfs            1932652    8800   1923852   1% /run
tmpfs            1932652       0   1932652   0% /sys/fs/cgroup
/dev/sda1        2086912  137672   1949240   7% /boot
tmpfs             386532       0    386532   0% /run/user/0
[root@test-centos7-node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：我们启动autofs后，我们定义的自动挂载好像没有自动挂载到对应的目录。这个时候我们来直接访问我们定义的挂载点看看有什么情况&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-centos7-node1 ~]# df
Filesystem     1K-blocks    Used Available Use% Mounted on
/dev/sda3       48209924 3116816  45093108   7% /
devtmpfs         1922828       0   1922828   0% /dev
tmpfs            1932652      20   1932632   1% /dev/shm
tmpfs            1932652    8800   1923852   1% /run
tmpfs            1932652       0   1932652   0% /sys/fs/cgroup
/dev/sda1        2086912  137672   1949240   7% /boot
tmpfs             386532       0    386532   0% /run/user/0
[root@test-centos7-node1 ~]# ls /
auto  boot  etc   lib    media  mnt  opt    proc  run   srv  tmp  var
bin   dev   home  lib64  misc   net  patch  root  sbin  sys  usr  www
[root@test-centos7-node1 ~]# ls /auto/
[root@test-centos7-node1 ~]# cd /auto/nfs
[root@test-centos7-node1 nfs]# ll
total 0
[root@test-centos7-node1 nfs]# df
Filesystem           1K-blocks     Used Available Use% Mounted on
/dev/sda3             48209924  3116996  45092928   7% /
devtmpfs               1922828        0   1922828   0% /dev
tmpfs                  1932652       20   1932632   1% /dev/shm
tmpfs                  1932652     8804   1923848   1% /run
tmpfs                  1932652        0   1932652   0% /sys/fs/cgroup
/dev/sda1              2086912   137672   1949240   7% /boot
tmpfs                   386532        0    386532   0% /run/user/0
192.168.0.99:/nfsdir  27560960 13929472  13631488  51% /auto/nfs
[root@test-centos7-node1 nfs]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：可看到我们去访问我们定义的挂载点，就能够立即将NFS给挂载到系统上，其实过上一段时间我们不访问我们的挂载点，它还会自动卸载掉，我们一旦去访问挂载点，它又会立刻触发挂载，把对应的资源给挂载到系统上;这里再说一下，如果子配置文件的挂载目录和NFS的共享目录相同 ，我们可以用*来通配，如：NFS服务器共享的目录是192.168.0.99：/nfsdir   客户端挂载的目录为/misc/nfsdir  这种挂载点的basename和nfs服务器上共享的目录的basename相同时。我们在子配置文件中还可以写成  *    -fstype=nfs,rw,vers=3   192.168.0.99:/&amp;amp;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-centos7-node1 ~]# cat /etc/nfs_auto.txt
*   -fstype=nfs,rw,vers=3   192.168.0.99:/&amp;amp;
[root@test-centos7-node1 ~]# df
Filesystem     1K-blocks    Used Available Use% Mounted on
/dev/sda3       48209924 3117020  45092904   7% /
devtmpfs         1922828       0   1922828   0% /dev
tmpfs            1932652      20   1932632   1% /dev/shm
tmpfs            1932652    8776   1923876   1% /run
tmpfs            1932652       0   1932652   0% /sys/fs/cgroup
/dev/sda1        2086912  137672   1949240   7% /boot
tmpfs             386532       0    386532   0% /run/user/0
[root@test-centos7-node1 ~]# cd /auto/nfsdir
[root@test-centos7-node1 nfsdir]# df
Filesystem           1K-blocks     Used Available Use% Mounted on
/dev/sda3             48209924  3117020  45092904   7% /
devtmpfs               1922828        0   1922828   0% /dev
tmpfs                  1932652       20   1932632   1% /dev/shm
tmpfs                  1932652     8776   1923876   1% /run
tmpfs                  1932652        0   1932652   0% /sys/fs/cgroup
/dev/sda1              2086912   137672   1949240   7% /boot
tmpfs                   386532        0    386532   0% /run/user/0
192.168.0.99:/nfsdir  27560960 13929472  13631488  51% /auto/nfsdir
[root@test-centos7-node1 nfsdir]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：这种写法我们在访问其挂载点的时候，需要清楚知道服务端共享目录的名称才可以，这种写法是可以匹配多个共享目录的，只要挂载点和NFS服务器共享目录路径有相同的，都可以匹配上。如下所示&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-centos7-node1 ~]# showmount -e 192.168.0.99
Export list for 192.168.0.99:
/test      *
/test/dir2 192.168.0.0/24
/test/dir1 192.168.0.0/24
/nfsdir    192.168.0.0/24
[root@test-centos7-node1 ~]# df
Filesystem           1K-blocks     Used Available Use% Mounted on
/dev/sda3             48209924  3116956  45092968   7% /
devtmpfs               1922828        0   1922828   0% /dev
tmpfs                  1932652       20   1932632   1% /dev/shm
tmpfs                  1932652     8776   1923876   1% /run
tmpfs                  1932652        0   1932652   0% /sys/fs/cgroup
/dev/sda1              2086912   137672   1949240   7% /boot
tmpfs                   386532        0    386532   0% /run/user/0
192.168.0.99:/nfsdir  27560960 13929728  13631232  51% /auto/nfsdir
[root@test-centos7-node1 ~]# cd /auto/test/
[root@test-centos7-node1 test]# df
Filesystem           1K-blocks     Used Available Use% Mounted on
/dev/sda3             48209924  3116956  45092968   7% /
devtmpfs               1922828        0   1922828   0% /dev
tmpfs                  1932652       20   1932632   1% /dev/shm
tmpfs                  1932652     8776   1923876   1% /run
tmpfs                  1932652        0   1932652   0% /sys/fs/cgroup
/dev/sda1              2086912   137672   1949240   7% /boot
tmpfs                   386532        0    386532   0% /run/user/0
192.168.0.99:/nfsdir  27560960 13929472  13631488  51% /auto/nfsdir
192.168.0.99:/test    27560960 13929472  13631488  51% /auto/test
[root@test-centos7-node1 test]# ls
dir1  dir2
[root@test-centos7-node1 test]# cd /auto/test/dir2
[root@test-centos7-node1 dir2]# df
Filesystem              1K-blocks     Used Available Use% Mounted on
/dev/sda3                48209924  3116956  45092968   7% /
devtmpfs                  1922828        0   1922828   0% /dev
tmpfs                     1932652       20   1932632   1% /dev/shm
tmpfs                     1932652     8776   1923876   1% /run
tmpfs                     1932652        0   1932652   0% /sys/fs/cgroup
/dev/sda1                 2086912   137672   1949240   7% /boot
tmpfs                      386532        0    386532   0% /run/user/0
192.168.0.99:/test       27560960 13929472  13631488  51% /auto/test
192.168.0.99:/test/dir2  27560960 13929472  13631488  51% /auto/test/dir2
[root@test-centos7-node1 dir2]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　4.2、绝对路径法&lt;/p&gt;
&lt;p&gt;　　绝对路径法就是在主配置文件中（/etc/auto.master）文件中用/-来表示不再主配置文件中定义父目录名称，然后在后面指定子配置文件的路径和名称即可，也就是说和相对路径法不同的是，把绝对路径和挂载策略都写在子配置文件中。&lt;/p&gt;
&lt;p&gt;　　接下来我们把192.168.0.99：/ 挂载到本地的 /a/b/c/d/目录下&lt;/p&gt;
&lt;p&gt;　　　　4.2.1、编辑主配置文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-centos7-node1 ~]# grep &quot;path&quot; /etc/auto.master
/-      /etc/mount_all_path.txt
[root@test-centos7-node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　4.2.2、在子配置文件中写挂载策略&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-centos7-node1 ~]# cat /etc/mount_all_path.txt
/a/b/c/d/       -fstype=nfs,rw,all_squash       192.168.0.99:/
[root@test-centos7-node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：我们写好子配置文件后，是需要重启autofs服务。然后通过访问挂载点，看看它是否能够挂载NFS共享出来的目录呢&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-centos7-node1 ~]# systemctl restart autofs&lt;br/&gt;[root@test-centos7-node1 ~]# df
Filesystem     1K-blocks    Used Available Use% Mounted on
/dev/sda3       48209924 3116996  45092928   7% /
devtmpfs         1922828       0   1922828   0% /dev
tmpfs            1932652      20   1932632   1% /dev/shm
tmpfs            1932652    8776   1923876   1% /run
tmpfs            1932652       0   1932652   0% /sys/fs/cgroup
/dev/sda1        2086912  137672   1949240   7% /boot
tmpfs             386532       0    386532   0% /run/user/0
[root@test-centos7-node1 ~]# ls /a/b/c/d/
dir1  dir2
[root@test-centos7-node1 ~]# df
Filesystem     1K-blocks     Used Available Use% Mounted on
/dev/sda3       48209924  3116996  45092928   7% /
devtmpfs         1922828        0   1922828   0% /dev
tmpfs            1932652       20   1932632   1% /dev/shm
tmpfs            1932652     8776   1923876   1% /run
tmpfs            1932652        0   1932652   0% /sys/fs/cgroup
/dev/sda1        2086912   137672   1949240   7% /boot
tmpfs             386532        0    386532   0% /run/user/0
192.168.0.99:/  27560960 13929472  13631488  51% /a/b/c/d
[root@test-centos7-node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：我们通过访问挂载点也实现了自动挂载。其实autofs对自动挂载NFS提前有在主配置文件中定义，我们可以不用任何配置，装好autofs软件包后，直接cd NFS服务器的主机地址就可实现自动挂载&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-centos7-node1 ~]# grep ^&quot;\/net&quot; /etc/auto.master
/net    -hosts
[root@test-centos7-node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：这个配置就是表示我们在通过网络挂载资源的时候，可以直接访问/net/对方ip地址即可，当然这种都是用在局域网里，NFS不建议用在互联网。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-centos7-node1 ~]# umount /a/b/c/d/
[root@test-centos7-node1 ~]# df
Filesystem     1K-blocks    Used Available Use% Mounted on
/dev/sda3       48209924 3116948  45092976   7% /
devtmpfs         1922828       0   1922828   0% /dev
tmpfs            1932652      20   1932632   1% /dev/shm
tmpfs            1932652    8776   1923876   1% /run
tmpfs            1932652       0   1932652   0% /sys/fs/cgroup
/dev/sda1        2086912  137672   1949240   7% /boot
tmpfs             386532       0    386532   0% /run/user/0
[root@test-centos7-node1 ~]# cd 192.168.0.99
-bash: cd: 192.168.0.99: No such file or directory
[root@test-centos7-node1 ~]# ls /net/
[root@test-centos7-node1 ~]# ls /net/192.168.0.99
nfsdir  test
[root@test-centos7-node1 ~]# df
Filesystem     1K-blocks    Used Available Use% Mounted on
/dev/sda3       48209924 3116952  45092972   7% /
devtmpfs         1922828       0   1922828   0% /dev
tmpfs            1932652      20   1932632   1% /dev/shm
tmpfs            1932652    8776   1923876   1% /run
tmpfs            1932652       0   1932652   0% /sys/fs/cgroup
/dev/sda1        2086912  137672   1949240   7% /boot
tmpfs             386532       0    386532   0% /run/user/0
[root@test-centos7-node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：这种方式用df命令是看不到它的挂载情况的，我们需要用mount命令是可以查看到挂载详情。如下所示&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;94&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-centos7-node1 ~]# mount |tail 
hugetlbfs on /dev/hugepages type hugetlbfs (rw,relatime)
mqueue on /dev/mqueue type mqueue (rw,relatime)
/dev/sda1 on /boot type xfs (rw,relatime,attr2,inode64,noquota)
tmpfs on /run/user/0 type tmpfs (rw,nosuid,nodev,relatime,size=386532k,mode=700)
/etc/auto.misc on /misc type autofs (rw,relatime,fd=7,pgrp=4091,timeout=300,minproto=5,maxproto=5,indirect,pipe_ino=28437)
/etc/nfs_auto.txt on /auto type autofs (rw,relatime,fd=13,pgrp=4091,timeout=300,minproto=5,maxproto=5,indirect,pipe_ino=29313)
/etc/mount_all_path.txt on /a/b/c/d type autofs (rw,relatime,fd=19,pgrp=4091,timeout=300,minproto=5,maxproto=5,direct,pipe_ino=26610)
-hosts on /net type autofs (rw,relatime,fd=24,pgrp=4091,timeout=300,minproto=5,maxproto=5,indirect,pipe_ino=26615)
-hosts on /net/192.168.0.99/nfsdir type autofs (rw,relatime,fd=24,pgrp=4091,timeout=300,minproto=5,maxproto=5,offset,pipe_ino=26615)
-hosts on /net/192.168.0.99/test type autofs (rw,relatime,fd=24,pgrp=4091,timeout=300,minproto=5,maxproto=5,offset,pipe_ino=26615)
[root@test-centos7-node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：以上的所有操作都建立在客户端上的操作，且客户端是能够看到其NFS服务器上的共享目录的前提才可以实现自动挂载。&lt;/p&gt;
</description>
<pubDate>Thu, 30 Jan 2020 15:11:00 +0000</pubDate>
<dc:creator>qiuhom</dc:creator>
<og:description>一、NFS服务简介 NFS全称network file system 网络文件系统，基于内核的文件系统，有sun公司开发，通过使用NFS，用户和程序可以像访问本地文件一样访问远端系统上的文件，它基于r</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qiuhom-1874/p/12237964.html</dc:identifier>
</item>
<item>
<title>JavaScript(2)---DOM详解 - 雨点的名字</title>
<link>http://www.cnblogs.com/qdhxhz/p/12244271.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qdhxhz/p/12244271.html</guid>
<description>&lt;center&gt;

&lt;/center&gt;
&lt;h2 id=&quot;一dom概念&quot;&gt;&lt;span&gt;一、DOM概念&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;什么是DOM&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;DOM全称为文本对象模型(Document Object Model),它定义了所有HTML元素的对象和属性，以及访问他们的方法。它的主要作用包括：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;改变HTML 元素&lt;/strong&gt; , &lt;strong&gt;改变HTML属性&lt;/strong&gt; , &lt;strong&gt;改变CSS 样式&lt;/strong&gt;，&lt;strong&gt;对页面中的所有事件做出反应&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&quot;dom-节点树&quot;&gt;1、DOM 节点树&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;概念&lt;/code&gt; DOM模型将整个HTML文档看成一个树形结构，并用document对象表示该文档，树的每个子节点表示HTM档中的不同内容。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201912/1090617-20191210211801380-562302127.jpg&quot; width=&quot;600&quot; height=&quot;300&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图对应的html代码如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;标题&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;h1&amp;gt;小小&amp;lt;/h1&amp;gt;
    &amp;lt;a href=&quot;www.xx.com&quot;&amp;gt;链接&amp;lt;/a&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过这幅图也可以看出节点树中有以下几种关系&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1、父级关系（图中 html 是 head 的父亲,head是title的父亲。）
2、子级关系（图中 head 是 html 的儿子,title是head的儿子。）
3、兄弟关系 （图中 head 和 body是兄弟关系。p 和 h1 是兄弟关系。）&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;dom-节点类型&quot;&gt;2、DOM 节点类型&lt;/h4&gt;
&lt;p&gt;从上图部分，我用四种颜色区分了不同节点的类型,每个节点对应的nodeType也是不一致的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201912/1090617-20191210212814463-169030870.jpg&quot; width=&quot;700&quot; height=&quot;210&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;dom-节点操作&quot;&gt;3、DOM 节点操作&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;节点查询操作&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201912/1090617-20191210212920518-626764047.jpg&quot; width=&quot;700&quot; height=&quot;370&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;节点增删操作&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201912/1090617-20191210213014167-663470734.jpg&quot; width=&quot;700&quot; height=&quot;210&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;节点属性操作&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201912/1090617-20191210213051283-1478146561.jpg&quot; width=&quot;700&quot; height=&quot;210&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;二查询示例&quot;&gt;&lt;span&gt;二、查询示例&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;这里通过举例去更好的理解上面的一些操作。&lt;/p&gt;
&lt;h4 id=&quot;查询子元素&quot;&gt;1、查询子元素&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;children&lt;/code&gt; : 可以获取当前元素的所有&lt;strong&gt;子元素&lt;/strong&gt;，它是不包含空白的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div id=&quot;father&quot;&amp;gt;
        &amp;lt;p&amp;gt;今天时间&amp;lt;/p&amp;gt;
        &amp;lt;p&amp;gt;2019.12.09&amp;lt;/p&amp;gt;
        &amp;lt;p&amp;gt;22:15分&amp;lt;/p&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;script&amp;gt;
    window.onload = function () {
        var father = document.getElementById(&quot;father&quot;);
        var all = father.children; // 获取 father 下边所有的子元素
        console.log(&quot;数组的长度为:&quot; + all.length);
    };
&amp;lt;/script&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;输出&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;数组的长度为:3&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;查询父元素&quot;&gt;2、查询父元素&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;parentNode&lt;/code&gt; ：获取当前元素的父节点(父元素)&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div id=&quot;father&quot;&amp;gt;
        &amp;lt;p id=&quot;childNode&quot;&amp;gt;我是子节点&amp;lt;/p&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;script&amp;gt;
    window.onload = function () {
        var p = document.getElementById(&quot;childNode&quot;);  //获取p元素
        var parent = p.parentNode;  // 获取父元素
        console.log(parent);
    };
&amp;lt;/script&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;输出&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;div id=&quot;father&quot;&amp;gt;
        &amp;lt;p id=&quot;childNode&quot;&amp;gt;我是子节点&amp;lt;/p&amp;gt;
 &amp;lt;/div&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;查询兄弟元素&quot;&gt;3、查询兄弟元素&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;previousElementSibling&lt;/code&gt; 获取当前元素的前一个兄弟元素(哥哥元素)&lt;br/&gt;&lt;code&gt;nextElementSibling&lt;/code&gt; 获取当前元素的后一个兄弟元素(弟弟元素)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;示例&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;p id=&quot;previous&quot; name=&quot;1111&quot;&amp;gt;哥哥元素&amp;lt;/p&amp;gt;
    &amp;lt;p id=&quot;my&quot;&amp;gt;本元素&amp;lt;/p&amp;gt;
    &amp;lt;p id=&quot;next&quot;&amp;gt;弟弟元素&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;script&amp;gt;
    window.onload = function () {
        var my = document.getElementById(&quot;my&quot;);   // 获取我的元素
        var previous = my.previousElementSibling; // 获取哥哥元素
        var next = my.nextElementSibling;         // 获取弟弟元素
        console.log(previous);
        console.log(&quot;---------------------&quot;);
        console.log(next);
    };
&amp;lt;/script&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;输出&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;p id=&quot;previous&quot; name=&quot;1111&quot;&amp;gt;哥哥节点&amp;lt;/p&amp;gt;
---------------------
&amp;lt;p id=&quot;next&quot;&amp;gt;弟弟节点&amp;lt;/p&amp;gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;三增删改示例&quot;&gt;&lt;span&gt;三、增删改示例&lt;/span&gt;&lt;/h2&gt;
&lt;h4 id=&quot;增加子节点&quot;&gt;1、增加子节点&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;appendChild()&lt;/code&gt; : 向一个父节点中添加一个新的子节点 &lt;strong&gt;父节点.appendChild(子节点)&lt;/strong&gt;;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;代码示例&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;script&amp;gt;
    window.onload = function () {
        // 获取到 btn
        var btn01 = document.getElementById(&quot;btn&quot;);
        // 添加点击事件
        btn01.onclick = function () {
            // 创建一个 p 标签
            var p = document.createElement(&quot;p&quot;);
            // 创建一个文本节点
            var txt = document.createTextNode(&quot;我是新创建p标签中的内容...&quot;);
            // 把文本节点添加到 p 标签中
            p.appendChild(txt);
            // 把 p 标签添加到 body 中
            var body = document.body; // 获取body
            body.appendChild(p);
        };
    };
&amp;lt;/script&amp;gt;

&amp;lt;body&amp;gt;
    &amp;lt;button id=&quot;btn&quot;&amp;gt;创建一个p标签&amp;lt;/button&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;运行&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201912/1090617-20191210211921179-738962422.gif&quot; width=&quot;600&quot; height=&quot;180&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;移除子节点&quot;&gt;2、移除子节点&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;removeChild()&lt;/code&gt; ：删除一个子节点 &lt;strong&gt;父节点.removeChild(子节点)&lt;/strong&gt;;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;代码示例&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;button id=&quot;btn&quot;&amp;gt;删除一个子节点&amp;lt;/button&amp;gt;
    &amp;lt;ul id=&quot;uls&quot;&amp;gt;
        &amp;lt;li&amp;gt;我是第一个子节点&amp;lt;/li&amp;gt;
        &amp;lt;li&amp;gt;我是第二个子节点&amp;lt;/li&amp;gt;
        &amp;lt;li&amp;gt;我是第三个子节点&amp;lt;/li&amp;gt;
        &amp;lt;li&amp;gt;我是第四个子节点&amp;lt;/li&amp;gt;
    &amp;lt;/ul&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;script&amp;gt;
    window.onload = function () {
        // 获取到 btn
        var btn = document.getElementById(&quot;btn&quot;);
        // 添加点击事件,删除第三个子节点
        btn.onclick = function () {
            //获取第三个子节点
            var node = document.getElementsByTagName(&quot;li&quot;)[2];
            // 获取父节点
            var ul = document.getElementById(&quot;uls&quot;);
            ul.removeChild(node); // 删除子节点
        };
    };
&amp;lt;/script&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;运行&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201912/1090617-20191210212006912-543498452.gif&quot; width=&quot;600&quot; height=&quot;180&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;替换子节点&quot;&gt;3、替换子节点&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;replaceChild()&lt;/code&gt; : 可以使用指定的子节点来替换已有的子节点 &lt;strong&gt;父节点.replaceChild(新节点,旧节点)&lt;/strong&gt;;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;代码示例&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;button id=&quot;btn&quot;&amp;gt;替换按钮&amp;lt;/button&amp;gt;
    &amp;lt;p id=&quot;pNode&quot;&amp;gt;我是旧节点 p &amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;script&amp;gt;
    window.onload = function () {
        // 获取到 btn01
        var btn = document.getElementById(&quot;btn&quot;);
        // 添加点击事件
        btn.onclick = function () {
            // 获取p标签
            var p = document.getElementById(&quot;pNode&quot;);
            // 获取父节点
            var body = document.body;

            //创建一个新的节点，用于替换旧节点
            var a = document.createElement(&quot;a&quot;);
            var txt = document.createTextNode(&quot;我是新的节点 a 哦~&quot;);
            a.appendChild(txt);

            // 替换节点
            body.replaceChild(a, p);
        };
    };
&amp;lt;/script&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;运行&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201912/1090617-20191210212059950-1050840245.gif&quot; width=&quot;600&quot; height=&quot;180&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;替换指定位置节点&quot;&gt;4、替换指定位置节点&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;insertBefore()&lt;/code&gt; : 可以在指定的子节点前插入一个新的子节点 &lt;strong&gt;父节点.insertBefore(新节点,旧节点)&lt;/strong&gt;;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;代码示例&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;button id=&quot;btn01&quot;&amp;gt;替换子节点&amp;lt;/button&amp;gt;
    &amp;lt;p id=&quot;pNode&quot;&amp;gt;我是旧节点 p &amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;script&amp;gt;
    window.onload = function () {
        // 获取到 btn01
        var btn01 = document.getElementById(&quot;btn01&quot;);
        // 添加点击事件
        btn01.onclick = function () {
            // 获取p标签
            var p = document.getElementById(&quot;pNode&quot;);
            // 获取父节点
            var body = document.body;

            //创建一个新的节点，用于插入到 p 元素前面
            var a = document.createElement(&quot;a&quot;);
            var txt = document.createTextNode(&quot;我是新的节点 a 哦~&quot;);
            a.appendChild(txt);

            // 插入一个新的节点 a 
            body.insertBefore(a, p);

        };
    };
&amp;lt;/script&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;运行&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201912/1090617-20191210212143352-1731675696.gif&quot; width=&quot;600&quot; height=&quot;180&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;四样式示例&quot;&gt;&lt;span&gt;四、样式示例&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;语法&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;元素.style.样式名 = 样式值&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里有关修改样式注意的点有&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1、 如果 CSS 样式名中含有 - 这种名称在JS 中是不合法的，例如： background-color我们需要将这种样式名，修改为 驼峰命名法backgroundColor

2、通过 style 属性设置的样式都是内联样式，而内联样式有较高的优先级，所以通过JS 修改的样式往往会立即显示。
3、但是如果在样式中写了 !important 则此时样式会有最高的优先级，即使通过 JS 也不能覆盖这个样式。此时将会导致 JS 修改的样式失效，所以尽量 不要给样式添加 !important
4、通过 style 读取也都是内联样式、无法读取样式表中的样式。&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;设置样式&quot;&gt;1、设置样式&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;代码示例&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;
&amp;lt;style&amp;gt;
    /* 设置一个基本的样式 */
    #box{
        width: 100px;  
        height: 100px;
        background-color: darkcyan;
    }
&amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;button id=&quot;btn&quot;&amp;gt;更换样式&amp;lt;/button&amp;gt;
    &amp;lt;br&amp;gt;
    &amp;lt;br&amp;gt;
    &amp;lt;div id=&quot;box&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;script&amp;gt;
    window.onload = function () {
        // 获取到 btn
        var btn = document.getElementById(&quot;btn&quot;);
        // 添加点击事件
        btn.onclick = function () {
            // 获取 box
            var box = document.getElementById(&quot;box&quot;);
            box.style.width = &quot;150px&quot;;  // 修改宽度
            box.style.height = &quot;150px&quot;;  // 修改高度
            box.style.backgroundColor = &quot;deeppink&quot;;  // 修改背景颜色
        };
    };
&amp;lt;/script&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;运行&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201912/1090617-20191210212232863-1550527927.gif&quot; width=&quot;600&quot; height=&quot;220&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;五综合示例&quot;&gt;&lt;span&gt;五、综合示例&lt;/span&gt;&lt;/h2&gt;
&lt;h4 id=&quot;霓虹灯特效示例&quot;&gt;1、霓虹灯特效示例&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;先看效果&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201912/1090617-20191210212316546-328742978.gif&quot; width=&quot;600&quot; height=&quot;200&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;代码示例&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;&amp;lt;/body&amp;gt;
&amp;lt;script&amp;gt;
        var  tName=&quot;北京首都欢迎您&quot;;
        var  tLen=tName.length; 
        document.write(&quot;&amp;lt;div id='a'  style='font-size:50px;'&amp;gt;&quot;+tName+&quot;&amp;lt;/div&amp;gt;&quot; );
        var color=new Array(&quot;#FFCC00&quot;,&quot;#3333FF&quot;,&quot;FFCCAA&quot;,&quot;#FF0000&quot;,&quot;#FFCC33&quot;,&quot;#CC33FF&quot;);
        var ic=0;  //这里很关键，一定要设置全局变量
        function  DColor(){
             var StrName=&quot;&quot;;  //这个很有必要，不然无法叠加单个汉字
             
             for(var i=0;i&amp;lt;tLen;i++){  //下面一步才是精髓，设置每一个汉子不同颜色，然后拼接起来
                var StrName=StrName+&quot;&amp;lt;font color=&quot;+color[ic]+&quot;&amp;gt;&quot;+tName.substring(i,i+1)+&quot;&amp;lt;/font&amp;gt;&quot;;
                ic=ic+1;    //下一个字下一个颜色
                if(ic==color.length){
                  ic=0;  //不设置为零，因为他是全局变量，那么会一直加到数组越界
                }   
             }
             
             a.innerHTML=StrName;  //可以通过id.innerHTML改变界面的字的颜色
                //设置时间的变化 改变情况
            setTimeout(&quot;DColor()&quot;,200);  //setTimeout代表每隔200毫秒运行一次函数
        }   
        DColor();    //这个代表直接开始运行这个函数，而不用通过触发事件
    &amp;lt;/script&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;核心点&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;核心点一&lt;/strong&gt; : 是ic=0写成全局变量，假如写在方法里，那么每一次初始化结果都一样，那么也不会有霓虹灯效果&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;核心点二&lt;/strong&gt; : color.length和tName.length如果相等同样也不会产生效果，因为每一次结束ic还是=0，而这里第一次DColor(),ic=0,第二次调用ic初始值=1，所以会有效果。&lt;/p&gt;
&lt;h4 id=&quot;显示系统时间秒一直动&quot;&gt;2、显示系统时间,秒一直动&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;效果&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201912/1090617-20191210212408594-1812881985.gif&quot; width=&quot;600&quot; height=&quot;150&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;代码&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body onload=&quot;showTime()&quot;&amp;gt;  &amp;lt;!-- 当加载时就执行 --&amp;gt;
    &amp;lt;label id=&quot;show&quot;&amp;gt;显示系统时间&amp;lt;/label&amp;gt;   &amp;lt;!-- 将系统时间显示在这个位置 --&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;  
    function showTime(){
      var objDate =new Date(); //得到系统时间对象
      var year =objDate.getFullYear(); //获取年份
      var month=objDate.getMonth()+1;//获取月份
      var date =objDate.getDate();//获取日期
      var hours=objDate.getHours();//小时
      var minutes=objDate.getMinutes();//分钟
      var seconds=objDate.getSeconds();//秒
      var day =objDate.getDay();   //获取星期几
        
        show.innerHTML=&quot;&quot;+year+&quot;年&quot;+month+&quot;月&quot;+date+&quot;日&quot;+hours+&quot;:&quot;+minutes+&quot;:&quot;+seconds +&quot;&amp;amp;nbsp;周&quot;+day;   //通过id改变界面显示内容 
        //每隔1秒刷新一次
        var  timeId=setTimeout(showTime,1000);
        }
    &amp;lt;/script&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;参考&quot;&gt;&lt;span&gt;参考&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;1、&lt;a href=&quot;https://www.jianshu.com/p/294da58c4a39&quot;&gt;前端学习记录之Javascript-DOM&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2、&lt;a href=&quot;https://blog.csdn.net/actionActivity/article/details/89839839&quot;&gt;JavaScript DOM&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;你如果愿意有所作为，就必须有始有终。(21)&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 30 Jan 2020 14:50:00 +0000</pubDate>
<dc:creator>雨点的名字</dc:creator>
<og:description>JavaScript(2) DOM详解 一、DOM概念 什么是DOM DOM全称为文本对象模型(Document Object Model),它定义了所有HTML元素的对象和属性，以及访问他们的方法。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qdhxhz/p/12244271.html</dc:identifier>
</item>
<item>
<title>跨域问题详解 - D13</title>
<link>http://www.cnblogs.com/D13blog/p/12244081.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/D13blog/p/12244081.html</guid>
<description>&lt;h6 id=&quot;阅读须知-作者是一个在校大学生尚未工作以下内容依据个人理解与网上资料编写若有错误还请指出感激不尽网上对于跨域的解释大多是一堆文字对于初学者来说往往较难理解这篇博客我将利用nodejs搭建一个简易的服务器用于模拟跨域不懂nodejs的小伙伴也不用紧张只是借助于nodejs来快速搭建一个http服务器我将以最简单的代码去还原跨域问题若有兴趣的小伙伴可自行百度学习菜鸟教程本篇博文所有代码均已跑通且会上传至个人仓库欢迎各位指正错误&quot;&gt;阅读须知: 作者是一个在校大学生,尚未工作，以下内容依据个人理解与网上资料编写。若有错误，还请指出，感激不尽。网上对于跨域的解释大多是一堆文字,对于初学者来说往往较难理解，这篇博客我将利用NodeJs搭建一个简易的服务器用于模拟跨域,不懂NodeJs的小伙伴也不用紧张,只是借助于NodeJs来快速搭建一个http服务器。我将以最简单的代码去还原跨域问题。若有兴趣的小伙伴，可自行百度学习(菜鸟教程)。本篇博文所有代码均已跑通且会上传至个人仓库。欢迎各位指正错误。&lt;/h6&gt;
&lt;h2 id=&quot;跨域是什么&quot;&gt;1.跨域是什么?&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/01/29/xHpeAc2hENUSZMi.png&quot; alt=&quot;跨域.PNG&quot;/&gt;&lt;br/&gt;这就是一个跨域引起的错误。或许许多小伙伴，一遇到错误就直接百度寻找答案，但有时候我们不妨看看错误信息，这对我们理解问题可能会有不错的帮助，而不是遇到问题就百度，goole。我们来看看错误信息都告诉我们什么？&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Access to XMLHttpRequest at 'http://127.0.0.1:8002/index.html' from origin 'http://127.0.0.1:8001' has been blocked by CORS policy: No'Access-Control-Allow-Origin' header is present on the requested resource.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们把它丢到百度翻译可以的到如下解释:&lt;/p&gt;
&lt;p&gt;CORS策略已阻止从“&lt;a href=&quot;http://127.0.0.1:8002/index.html%E2%80%9D%E6%BA%90%E2%80%9Chttp://127.0.0.1:8001%E2%80%9D%E5%AF%B9XMLHttpRequest%E7%9A%84%E8%AE%BF%E9%97%AE%EF%BC%9A%E8%AF%B7%E6%B1%82%E7%9A%84%E8%B5%84%E6%BA%90%E4%B8%8A%E4%B8%8D%E5%AD%98%E5%9C%A8%E2%80%9CAccess-Control-Allow-origin%E2%80%9D%E5%A4%B4&quot; class=&quot;uri&quot;&gt;http://127.0.0.1:8002/index.html”源“http://127.0.0.1:8001”对XMLHttpRequest的访问：请求的资源上不存在“Access-Control-Allow-origin”头&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;我们把它理顺一下可以变成：&lt;/p&gt;
&lt;p&gt;一个网页请求另外一个网页的资源被CORS策略给阻止了，原因XMLHttpRequest的请求不存在“Access-Control-Alloworigin&quot;头,如果你恰巧有网络协议方面的知识储备，或许你已经了解跨域是什么了，以及如何解决。&lt;/p&gt;
&lt;p&gt;我们可以在简化一下这个信息：网页间的XMLHttpRequest请求被CORS策略给阻止了。好的，来到这里我们已经知道了跨域请求失败的原因是什么了。&lt;strong&gt;CORS策略阻止了它！！&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;cors是什么&quot;&gt;CORS是什么？&lt;/h3&gt;
&lt;p&gt;（推荐阅读MDN的文章:中文版:&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS&quot; class=&quot;uri&quot;&gt;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS&lt;/a&gt; ，英文版:&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS&quot; class=&quot;uri&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;CORS：Cross-Origin Resource Sharing (CORS) is a mechanism that uses additional &lt;strong&gt;HTTP headers&lt;/strong&gt; to tell &lt;strong&gt;browsers&lt;/strong&gt; to give a web application running at one origin, access to selected resources from a different origin. A web application executes a cross-origin HTTP request when it requests a resource that has a different &lt;strong&gt;origin (domain, protocol, or port) from its own&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;由上边的介绍可知:CORS是不同域之间资源共享的一种机制，它使用额外的Http头来告诉&lt;strong&gt;浏览器&lt;/strong&gt;让运行在一个 origin (domain) 上的Web应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器&lt;strong&gt;不同的域、协议或端口&lt;/strong&gt;请求一个资源时，资源会发起一个跨域 HTTP 请求。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;跨域的安全限制，主要是针对浏览器端来说的，服务器端是不存在跨域安全限制的。&lt;/strong&gt;。所以我们可以通过代理服务器去解决跨域问题。&lt;/p&gt;
&lt;p&gt;域:简单理解由协议+域名+端口组成&lt;/p&gt;
&lt;p&gt;譬如文章开头图片中的两个域http://127.0.0.1:8002/index.html与http://127.0.0.1:8001是由于端口号不同而造成了跨域。http是他们的协议，127.0.0.1是他们的Ip地址，这里是本机Ip。8001，8002是他们的端口号，简单点说ip地址是你的电脑在网络世界里的标识。(Ip不是唯一不变的，它随着你接入的网络可能会发生改变，每台电脑的网卡还有一个物理地址MAC地址。MAC地址用于在网络中唯一标示一个网卡，一台设备若有一或多个网卡，则每个网卡都需要并会有一个唯一的MAC地址，这里不过多赘述，以后或许会更新相关内容的博文)&lt;/p&gt;
&lt;h3 id=&quot;跨域的原因是什么&quot;&gt;2.跨域的原因是什么&lt;/h3&gt;
&lt;p&gt;虽然在上边的翻译中告诉我们是因为CORS策略给阻止了请求，但我们通过查阅CORS在MDN上的解释可以知道，CORS是不同域之间共享资源的一种机制，也就是说它可以说是解决跨域的一种方案。那么引起跨域的原因是什么？&lt;/p&gt;
&lt;p&gt;上面说到跨域只存在于浏览器之间，这是因为浏览器存在有一个同源策略。什么是同源策略(SOP)呢？可以看一看MDN上的文章(&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy&quot; class=&quot;uri&quot;&gt;https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy&lt;/a&gt;)。&lt;/p&gt;
&lt;p&gt;同源策略是浏览器的一个安全功能，不同源的客户端脚本在没有明确授权的情况下，不能读写对方资源。所以xyz.com下的js脚本采用ajax读取abc.com里面的文件数据是会被拒绝的。同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。&lt;/p&gt;
&lt;p&gt;阮一峰的博客中有一段跨域同源策略的描述&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同源政策的目的&lt;/strong&gt;：是为了保证用户信息的安全，防止恶意的网站窃取数据。&lt;br/&gt;设想这样一种情况：A网站是一家银行，用户登录以后，又去浏览其他网站。如果其他网站可以读取A网站的Cookie，会发生什么？很显然，如果 Cookie 包含隐私（比如存款总额），这些信息就会泄漏。更可怕的是，Cookie 往往用来保存用户的登录状态，如果用户没有退出登录，其他网站就可以冒充用户，为所欲为。因为浏览器同时还规定，提交表单不受同源政策的限制。由此可见，&quot;同源政策&quot;是必需的，否则Cookie 可以共享，互联网就毫无安全可言了。&lt;/p&gt;
&lt;p&gt;在这里简单介绍一下cookie，因为理解了cookie能更好的理解浏览器与服务器间的交互。我们知道浏览器与服务器间使用过http协议来进行交互的，但是HTTP协议是无状态的，服务器是无法通过接收到的HTTP请求来区分是哪个用户发起的请求，即服务器不知道用户上一次做了什么，这严重阻碍了交互式Web应用程序的实现。在典型的网上购物场景中，用户浏览了几个页面，买了一盒饼干和两饮料。最后结帐时，由于HTTP的无状态性，不通过额外的手段，服务器并不知道用户到底买了什么。为了做到这点，就需要使用到Cookie了。服务器可以设置或读取Cookies中包含信息，借此维护用户跟服务器会话中的状态。&lt;/p&gt;
&lt;p&gt;如何查看Cookie?&lt;/p&gt;
&lt;p&gt;可以打开菜鸟教程里有关cookie的介绍https://www.runoob.com/js/js-cookies.html&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/01/29/6EKcyUTwmopsvaI.png&quot; alt=&quot;Cookie.PNG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;各位可以发现Cookies是有分组的，每个域下边存在有不同的cookie值，Cookie是由服务端生成的，发送给客户端（通常是浏览器）的。Cookie总是保存在浏览器中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180803193700323?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NTg1NzAx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当浏览器与服务器之间通信时，浏览器会在每个http请求中携带当前域下的cookie。&lt;/p&gt;
&lt;p&gt;到这里我们已经大概了解什么是同源策略，为什么要有同源策略。&lt;/p&gt;
&lt;p&gt;同源策略限制的行为:&lt;/p&gt;
&lt;p&gt;（1） 无法读取非同源网页的 Cookie、LocalStorage 和 IndexedDB。&lt;/p&gt;
&lt;p&gt;（2） 无法接触非同源网页的 DOM。&lt;/p&gt;
&lt;p&gt;（3） 无法向非同源地址发送AJAX请求（可以发送，但浏览器会拒绝接受响应）。&lt;/p&gt;
&lt;p&gt;不受同源策略限制的情况:&lt;/p&gt;
&lt;p&gt;有一些情况是不受同源策略的影响，简单列举如下:&lt;/p&gt;
&lt;p&gt;（1）页面中的超链接，点击可以访问其他不同源的页面。&lt;/p&gt;
&lt;p&gt;（2）表单提交，不同源的页面可以相互提交表单数据。&lt;/p&gt;
&lt;p&gt;（3）通过Html标签请求资源，如scrpit，img标签。&lt;/p&gt;

&lt;p&gt;这里介绍三中种跨域的解决方案 &lt;strong&gt;JSONP，代理服务器和CORS&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;jsonp&quot;&gt;JSONP&lt;/h2&gt;
&lt;h6 id=&quot;jsonp利用的是通过html标签请求资源不受同源策略影响它的基本思想是网页通过添加一个script元素向服务器请求数据这种做法不受同源策略限制服务器收到请求后将数据放在一个指定名字的回调函数里传回来-先贴上一段网上摘抄的代码&quot;&gt;JSONP利用的是通过HTML标签请求资源，不受同源策略影响。它的基本思想是，网页通过添加一个script元素，向服务器请求数据，这种做法不受同源策略限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。 先贴上一段网上摘抄的代码&lt;/h6&gt;
&lt;pre&gt;
&lt;code&gt;# 预先定义好处理数据的回调
function CallbackName(data) {
  console.log('Your public IP address is: ' + data.ip);
};
# 创建scrpit元素请求资源，以备后用
function addScriptTag(src) {
  var script = document.createElement('script');
  script.setAttribute(&quot;type&quot;,&quot;text/javascript&quot;);
  script.src = src;
  document.body.appendChild(script);
}
# 在页面加载完成时调用函数发送指定目标请求
window.onload = function () {
  addScriptTag('http://example.com/ip?callback=CallbackName');
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;初次看这代码时不太理解，因为当时没有接触后端开发，无法理解它们的交互过程。我们要明白一点script标签请求回来的数据浏览器是当成JS去解析的，我们可以简单验证一下，虽然没有资料讲述这一部分的内容。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/01/30/ThKo6QnlapFi35Z.png&quot; alt=&quot;1.PNG&quot;/&gt;&lt;br/&gt;script1.js代码如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;h1&amp;gt;11111&amp;lt;/h1&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;script2.js代码如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;alert(1);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当把这个页面打开，会发现页面弹出两次弹框，控制台提示无法解析h1标签的错误。所以可以大概理解浏览器是将请求回来的数据当成js代码执行。&lt;/p&gt;
&lt;p&gt;这时候我们就可以通过URL所带的queryString传递我们的函数名，例如下边这个URL传递了CallbackName作为回调函数的名称，而原先的JS代码又预先定义了回调函数。当后代给我们返回，Callbackname({dataObj})这样的字符串时，浏览器就会自动调用预先定义的回调函数，而需要的数据就通过{dataObj}传递过来了，于是实现了跨域请求。还是不太理解的小伙伴可以去我的仓库里查看相关代码。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;http://example.com/ip?callback=CallbackName&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;JSONP&lt;/strong&gt;只能支持get请求，并且前后端需要商量好回调函数的名称。&lt;/p&gt;
&lt;h3 id=&quot;cors与代理服务器相关内容我过两天整理后再更新累了&quot;&gt;CORS与代理服务器相关内容，我过两天整理后再更新，累了&lt;/h3&gt;
</description>
<pubDate>Thu, 30 Jan 2020 13:47:00 +0000</pubDate>
<dc:creator>D13</dc:creator>
<og:description>浅谈跨域 阅读须知: 作者是一个在校大学生,尚未工作，以下内容依据个人理解与网上资料编写。若有错误，还请指出，感激不尽。网上对于跨域的解释大多是一堆文字,对于初学者来说往往较难理解，这篇博客我将利用N</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/D13blog/p/12244081.html</dc:identifier>
</item>
<item>
<title>继承与多态 - 平酱</title>
<link>http://www.cnblogs.com/p1ng/p/12244063.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/p1ng/p/12244063.html</guid>
<description>&lt;h2 id=&quot;继承&quot;&gt;继承&lt;/h2&gt;
&lt;h3 id=&quot;概述&quot;&gt;概述&lt;/h3&gt;
&lt;h4 id=&quot;由来&quot;&gt;由来&lt;/h4&gt;
&lt;p&gt;多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那一个类即可。如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1898410/202001/1898410-20200130213929502-635680173.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中，多个类可以称为&lt;strong&gt;子类&lt;/strong&gt;，单独那一个类称为&lt;strong&gt;父类、超类（superclass）&lt;/strong&gt;或者&lt;strong&gt;基类&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;继承描述的是事物之间的所属关系，这种关系是： &lt;code&gt;is-a&lt;/code&gt; 的关系。例如，图中兔子属于食草动物，食草动物属于动物。可见，父类更通用，子类更具体。我们通过继承，可以使多种事物之间形成一种关系体系。&lt;/p&gt;
&lt;h4 id=&quot;定义&quot;&gt;定义&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;继承&lt;/strong&gt;：就是子类继承父类的&lt;strong&gt;属性&lt;/strong&gt;和&lt;strong&gt;行为&lt;/strong&gt;，使得子类对象具有与父类相同的属性、相同的行为。子类可以直接访问父类中的&lt;strong&gt;非私有&lt;/strong&gt;的属性和行为。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;好处&quot;&gt;好处&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;提高代码的&lt;strong&gt;复用性&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;类与类之间产生了关系，是&lt;strong&gt;多态的前提&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;继承的格式&quot;&gt;继承的格式&lt;/h3&gt;
&lt;p&gt;通过 &lt;code&gt;extends&lt;/code&gt; 关键字，可以声明一个子类继承另外一个父类，定义格式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class 父类 {
    ...
}
class 子类 extends 父类{
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;继承演示代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//定义员工类Employee作为父类
class Employee {    
    //定义name属性  
    String name;
    //定义员工的工作方法
    public void work() {
        System.out.println(&quot;尽心尽力地工作&quot;);
    }
}

//定义教师类Teacher继承员工类Employee
class Teacher extends Employee {
    //定义一个打印name的方法
    public void printName() {
        System.out.println(&quot;name=&quot;+ name);
    }
}

//定义测试类
public class ExtendDemo01 {
    public static void main(String[] args) {
        //创建一个教师类对象
        Teacher t = new Teacher();
        //为该员工类的name属性赋值
        t.name = &quot;小明&quot;;
        //调用Teacher类中的printName()方法
        t.printName(); // name=小明
        //调用Teacher类继承来的Work()方法
        t.work(); // 尽心尽力地工作
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;继承后的特点成员变量&quot;&gt;继承后的特点——成员变量&lt;/h3&gt;
&lt;p&gt;当类之间产生了关系后，其中各类中的成员变量，又产生了哪些影响呢？&lt;/p&gt;
&lt;h4 id=&quot;成员变量不重名&quot;&gt;成员变量不重名&lt;/h4&gt;
&lt;p&gt;如果子类父类中出现&lt;strong&gt;不重名&lt;/strong&gt;的成员变量，这时的访问是&lt;strong&gt;没有影响的&lt;/strong&gt;。代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Fu {
    //Fu中的成员变量
    int num = 5;
}

class Zi extends Fu {
    //Zi中的成员变量
    int num2 = 6;
    //Zi中的成员方法
    public void show() {
        //访问父类中的num
        System.out.println(&quot;Fu num = &quot;+num); //继承而来，所以直接访问。         
        //访问子类中的num2
        System.out.println(&quot;Zi num2 = &quot;+num2);
    }
}

class ExtendsDemo02 {
    public static void main(String[] args) {
        //创建子类对象
        Zi z = new Zi();
        //调用子类中的show()方法
        z.show();
    }
}

演示结果：
Fu num = 5
Zi num2 = 6&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;成员变量重名&quot;&gt;成员变量重名&lt;/h4&gt;
&lt;p&gt;如果子类父类中出现&lt;strong&gt;重名&lt;/strong&gt;的成员变量，这时的访问是&lt;strong&gt;有影响的&lt;/strong&gt;。代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Fu {
    //Fu中的成员变量
    int num = 5;
}

class Zi extends Fu {
    //Zi中的成员变量
    int num = 6;
    //Zi中的成员方法
    public void show() {
        //访问父类中的num
        System.out.println(&quot;Fu num = &quot;+num);            
        //访问子类中的num
        System.out.println(&quot;Zi num = &quot;+num);
    }
}

class ExtendsDemo02 {
    public static void main(String[] args) {
        //创建子类对象
        Zi z = new Zi();
        //调用子类中的show()方法
        z.show();
    }
}

演示结果：
Fu num = 6
Zi num = 6&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;子父类中出现了同名的成员变量时，在子类中需要访问父类中非私有成员变量时，需要使用 &lt;code&gt;super&lt;/code&gt; 关键字，修饰父类成员变量，类似于之前学过的 &lt;code&gt;this&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;使用格式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;super.父类成员变量名&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;子类方法需要修改，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Zi extends Fu {
    //Zi中的成员变量
    int num = 6;
    //Zi中的成员方法
    public void show() {
        //访问父类中的num
        System.out.println(&quot;Fu num = &quot;+super.num);          
        //访问子类中的num
        System.out.println(&quot;Zi num = &quot;+num);
    }
}

演示结果：
Fu num = 5
Zi num = 5&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;小贴士：Fu 类中的成员变量是非私有的，子类中可以直接访问。若Fu 类中的成员变量私有了，子类是不能直接访问的。通常编码时，我们遵循封装的原则，使用private修饰成员变量，那么如何访问父类的私有成员 变量呢？对！可以在父类中提供公共的getXxx方法和setXxx方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;继承后的特点成员方法&quot;&gt;继承后的特点——成员方法&lt;/h3&gt;
&lt;p&gt;当类之间产生了关系，其中各类中的成员方法，又产生了哪些影响呢？&lt;/p&gt;
&lt;h4 id=&quot;成员方法不重名&quot;&gt;成员方法不重名&lt;/h4&gt;
&lt;p&gt;如果子类父类中出现&lt;strong&gt;不重名&lt;/strong&gt;的成员方法，这时的调用是&lt;strong&gt;没有影响的&lt;/strong&gt;。对象调用方法时，会先在子类中查找有没有对应的方法，若子类中存在就会执行子类中的方法，若子类中不存在就会执行父类中相应的方法。代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Fu {
    public void show() {
        System.out.println(&quot;Fu类中的show方法执行&quot;);
    }
}
class Zi extends Fu {
    public void show2() {
        System.out.println(&quot;Zi类中的show2方法执行&quot;);
    }
}
public class ExtendsDemo04 {
    public static void main(String[] args) {
        Zi z = new Zi();
        //子类中没有show方法，但是可以找到父类方法去执行
        z.show();
        z.show2();
    }
}
演示结果：
Fu类中的show方法执行
Zi类中的show2方法执行&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;成员方法重名重写override&quot;&gt;成员方法重名——重写(Override)&lt;/h4&gt;
&lt;p&gt;如果子类父类中出现&lt;strong&gt;重名&lt;/strong&gt;的成员方法，这时的访问是一种特殊情况，叫做&lt;strong&gt;方法重写&lt;/strong&gt; (Override)。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;方法重写&lt;/strong&gt; ：子类中出现与父类一模一样的方法时（返回值类型，方法名和参数列表都相同），会出现覆盖效果，也称为重写或者复写。&lt;strong&gt;声明不变，重新实现&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Fu {
    public void show() {
        System.out.println(&quot;Fu类中的show方法执行&quot;);
    }
}
class Zi extends Fu {
    public void show() {
        System.out.println(&quot;Zi类中的show方法执行&quot;);
    }
}
public class ExtendsDemo04 {
    public static void main(String[] args) {
        Zi z = new Zi();
        z.show();
    }
}
演示结果：
Zi类中的show方法执行&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;重写的应用&quot;&gt;重写的应用&lt;/h4&gt;
&lt;p&gt;子类可以根据需要，定义特定于自己的行为。既沿袭了父类的功能名称，又根据子类的需要重新实现父类方法，从而进行扩展增强。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;super.父类成员方法，表示调用父类的成员方法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;注意事项&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;子类方法覆盖父类方法，必须要保证权限大于等于父类权限。&lt;/li&gt;
&lt;li&gt;子类方法覆盖父类方法，返回值类型、函数名和参数列表都要一模一样。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;继承后的特点构造方法&quot;&gt;继承后的特点——构造方法&lt;/h3&gt;
&lt;p&gt;当类之间产生了关系，其中各类中的构造方法，又产生了哪些影响呢？&lt;/p&gt;
&lt;p&gt;首先我们要回忆两个事情，构造方法的定义格式和作用。&lt;/p&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li&gt;构造方法的名字是与类名一致的。所以子类是无法继承父类构造方法的。&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;构造方法的作用是初始化成员变量的。所以子类的初始化过程中，必须先执行父类的初始化动作。子类的构造方法中默认有一个 super() ，表示调用父类的构造方法，父类成员变量初始化后，才可以给子类使用。代码如下：&lt;/p&gt;
&lt;p&gt;class Fu {&lt;br/&gt;private int n;&lt;br/&gt;Fu() {&lt;br/&gt;System.out.println(&quot;Fu()&quot;);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;class Zi extends Fu{&lt;br/&gt;Zi() {&lt;br/&gt;super(); //调用父类构造方法&lt;br/&gt;System.out.println(&quot;Zi()&quot;);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;public class ExtendsDemo07 {&lt;br/&gt;public static void main(String args) {&lt;br/&gt;Zi zi = new Zi();&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;输出结果：&lt;br/&gt;Fu()&lt;br/&gt;Zi()&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;super和this&quot;&gt;super和this&lt;/h3&gt;
&lt;h4 id=&quot;父类空间优先于子类对象产生&quot;&gt;父类空间优先于子类对象产生&lt;/h4&gt;
&lt;p&gt;在每次创建子类对象时，先初始化父类空间，再创建其子类对象本身。目的在于子类对象中包含了其对应的父类空间，便可以包含其父类的成员，如果父类成员非private修饰，则子类可以随意使用父类成员。代码体现在子类的构造方法调用时，一定先调用父类的构造方法。理解图解如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1898410/202001/1898410-20200130213946562-1083814649.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;super和this的含义&quot;&gt;super和this的含义&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;super&lt;/strong&gt; ：代表父类的&lt;strong&gt;存储空间标识&lt;/strong&gt;(可以理解为父亲的引用)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;this&lt;/strong&gt; ：代表&lt;strong&gt;当前对象的引用&lt;/strong&gt;(谁调用就代表谁)。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;super和this的用法&quot;&gt;super和this的用法&lt;/h4&gt;
&lt;ol readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;访问成员&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; this.成员变量    --  本类的
 super.成员变量   --  父类的

 this.成员方法名()    --  本类的
 super.成员方法名()   --  父类的&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;访问构造方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; this(...)    --  本类的构造方法
 super(...)   --  父类的构造方法&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;子类的每个构造方法中均有默认的super()，调用父类的空参构造。手动调用父类构造会覆盖默认的super()。 super() 和 this() 都必须是在构造方法的第一行，所以不能同时出现。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;继承的特点&quot;&gt;继承的特点&lt;/h3&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;Java只支持单继承，不支持多继承。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; //一个类只能有一个父类，不可以有多个父类。
 class C extends A{}     //ok
 class C exteds A,B...   //error&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;Java支持多层继承(继承体系)。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; class A{}
 class B extends A{}
 class C extends B{}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;顶层父类是Object类。所有的类默认继承Object作为父类。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;子类和父类是一种相对的概念。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;抽象类&quot;&gt;抽象类&lt;/h2&gt;
&lt;h3 id=&quot;概述-1&quot;&gt;概述&lt;/h3&gt;
&lt;h4 id=&quot;由来-1&quot;&gt;由来&lt;/h4&gt;
&lt;p&gt;父类中的方法，被它的子类们重写，子类各自的实现都不尽相同。那么父类的方法声明和方法主体，只有声明还有意义，而方法主体则没有存在的意义了。我们把没有方法主体的方法称为&lt;strong&gt;抽象方法&lt;/strong&gt;。Java语法规定，包含抽象方法的类就是&lt;strong&gt;抽象类&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&quot;定义-1&quot;&gt;定义&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;抽象方法&lt;/strong&gt; ： 没有方法体的方法。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;抽象类&lt;/strong&gt;：包含抽象方法的类。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;abstract使用格式&quot;&gt;abstract使用格式&lt;/h3&gt;
&lt;h4 id=&quot;抽象方法&quot;&gt;抽象方法&lt;/h4&gt;
&lt;p&gt;使用 &lt;code&gt;abstract&lt;/code&gt; 关键字修饰方法，该方法就成了抽象方法，抽象方法只包含一个方法名，而没有方法体。&lt;/p&gt;
&lt;p&gt;定义格式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;修饰符 abstract 返回值类型 方法名 (参数列表)；&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码举例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public abstract void run()；&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;抽象类-1&quot;&gt;抽象类&lt;/h4&gt;
&lt;p&gt;如果一个类包含抽象方法，那么该类必须是抽象类。&lt;/p&gt;
&lt;p&gt;定义格式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;abstract class 类名字 {

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码举例:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public abstract class Animal {
    public abstract void run();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;抽象的使用&quot;&gt;抽象的使用&lt;/h4&gt;
&lt;p&gt;继承抽象类的子类&lt;strong&gt;必须重写父类所有的抽象方法&lt;/strong&gt;。否则，该子类也必须声明为抽象类。最终，必须有子类实现该父类的抽象方法，否则，从最初的父类到最终的子类都不能创建对象，失去意义。&lt;/p&gt;
&lt;p&gt;代码举例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Cat extends Animal {
    public void run() {
        System.out.println(&quot;小猫在墙头走&quot;);
    }
}
public class CatTest {
    public static void main(String[] args) {
        Cat c = new Cat();
        c.run();
    }
}
输出结果：
小猫在墙头走&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时的方法重写，，是子类对父类抽象方法的完成实现，我们将这种方法重写的操作，也叫做&lt;strong&gt;实现方法&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;注意事项&quot;&gt;注意事项&lt;/h3&gt;
&lt;p&gt;关于抽象类的使用，以下为语法上要注意的细节，虽然条目较多，但若理解了抽象的本质，无需死记硬背。&lt;/p&gt;
&lt;p&gt;1.抽象类&lt;strong&gt;不能创建对象&lt;/strong&gt;，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;理解：假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2.抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;理解：子类的构造方法中，有默认的super()，需要访问父类构造方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;3.抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;理解：未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设计。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;4.抽象类的子类，必须重写抽象父类中&lt;strong&gt;所有的&lt;/strong&gt;抽象方法，否则，编译无法通过而报错。除非该g子类也是抽象类。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;理解：假设不重写所有抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有意义。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;继承的综合案例&quot;&gt;继承的综合案例&lt;/h2&gt;
&lt;p&gt;群主发普通红包。某群有多名成员，群主给成员发普通红包。普通红包的规则：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;群主的一笔金额，从群主余额中扣除，平均分成n等份，让成员领取。&lt;/li&gt;
&lt;li&gt;成员领取红包后，保存到成员余额中。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;请根据描述，完成案例中所有类的定义以及指定类之间的继承关系，并完成发红包的操作。&lt;/p&gt;
&lt;p&gt;根据描述分析，得到如下继承体系&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1898410/202001/1898410-20200130213957361-1467747322.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;案例实现&lt;/p&gt;
&lt;p&gt;定义用户类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class User {
    private String username;    //用户名
    private double leftMoney;   //余额

    //构造方法
    public User(){}

    public User(String username, double leftMoney) {
        this.username = username;
        this.leftMoney = leftMoney;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public double getLeftMoney() {
        return leftMoney;
    }

    public void setLeftMoney(double leftMoney) {
        this.leftMoney = leftMoney;
    }

    public void show() {
        System.out.println(&quot;用户名:&quot;+ username + &quot;, 余额为:&quot; + leftMoney + &quot;元&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定义群主类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Qunzhu extends User {

    public Qunzhu(){}

    public Qunzhu(String username, double leftMoney) {
        super(username, leftMoney);
    }
/*
    群主发红包，就是把一个浮点数的金额分成若干份。
    1.获取群主金额，是否够发红包 不够则返回null并提示 够则继续
    2.修改群主余额
    3.拆分红包
        3.1 如果能被整除就平均分
        3.2 如果不能 那么就把余数分给最后一份
 */
    public ArrayList&amp;lt;Double&amp;gt; send(double money, int count) {
        double leftMoney = getLeftMoney();
        if (money &amp;gt; leftMoney) {
            return null;
        }
        //修改群主余额
        setLeftMoney(leftMoney - money);
        //创建一个集合，保存等份金额
        ArrayList&amp;lt;Double&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        //扩大100倍，相当于折算成‘分’为单位，避免小数运算损失精度
        money = money * 100;
        //每份的金额
        double m = money / count;
        //不能整除的余数
        double l = money % count;

        for(int i = 0;i &amp;lt; count - 1; i++) {
            list.add(m / 100.0);
        }
        if(l == 0) {
            //能整除，最后一份金额与之前每份金额一致
            list.add(m / 100.0);
        } else {
            //不能整除，最后一份金额为之前每份的金额+余数金额
            list.add((m + 1) / 100.0);
        }

        return list;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定义成员类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Member extends User{
    public Member() {}

    public Member(String username, double leftMoney) {
        super(username, leftMoney);
    }
    // 打开红包，就是从集合中随机取出一份保存到自己的余额中
    public void openHongbao(ArrayList&amp;lt;Double&amp;gt; list) {
        Random r = new Random();
        int index = r.nextInt(list.size());
        Double money = list.remove(index);
        setLeftMoney(money);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Test {
    public static void main(String[] args) {
        Qunzhu qz = new Qunzhu(&quot;群主&quot;, 200);
        Scanner sc = new Scanner(System.in);
        System.out.println(&quot;请输入金额：&quot;);
        double money = sc.nextDouble();
        System.out.println(&quot;请输入个数：&quot;);
        int count = sc.nextInt();

        //发送红包
        ArrayList&amp;lt;Double&amp;gt; sendList = qz.send(money,count);

        if(sendList == null) {
            System.out.println(&quot;余额不足...&quot;);
            return;
        }

        Member m1 = new Member();
        Member m2 = new Member();
        Member m3 = new Member();

        m1.openHongbao(sendList);
        m2.openHongbao(sendList);
        m3.openHongbao(sendList);

        qz.show();
        m1.show();
        m2.show();
        m3.show();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;接口&quot;&gt;接口&lt;/h2&gt;
&lt;h3 id=&quot;概述-2&quot;&gt;概述&lt;/h3&gt;
&lt;p&gt;接口，是Java语言中一种引用类型，是方法的集合，如果说类的内部封装了成员变量、构造方法和成员方法，那么接口的内部主要就是封装了方法，包含抽象方法（JDK 7及以前），默认方法和静态方法（JDK 8），私有方法（JDK 9）。&lt;/p&gt;
&lt;p&gt;接口的定义，它与定义类方式相似，但是使用 &lt;code&gt;interface&lt;/code&gt; 关键字。它也会被编译成.class文件，但一定要明确它并不是类，而是另外一种引用数据类型。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;引用数据类型：数组、类、接口。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接口的使用，它不能创建对象，但是可以被实现（ implements ，类似于被继承）。一个实现接口的类（可以看作是接口的子类），需要实现接口中所有的抽象方法，创建该类对象，就可以调用方法了，否则它必须是一个抽象类。&lt;/p&gt;
&lt;h3 id=&quot;定义格式&quot;&gt;定义格式&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;public interface 接口名称 {
    //抽象方法
    //默认方法
    //静态方法
    //私有方法
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;含有抽象方法&quot;&gt;含有抽象方法&lt;/h4&gt;
&lt;p&gt;抽象方法：使用 &lt;code&gt;abstract&lt;/code&gt; 关键字修饰，可以省略，没有方法体。该方法供子类实现使用。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public interface InterFaceName {
    public abstract void method();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;含有默认方法和静态方法&quot;&gt;含有默认方法和静态方法&lt;/h4&gt;
&lt;p&gt;默认方法：使用 &lt;code&gt;default&lt;/code&gt; 修饰，不可省略，供子类调用或者子类重写。&lt;/p&gt;
&lt;p&gt;静态方法：使用 &lt;code&gt;static&lt;/code&gt; 修饰，供接口直接调用。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public interface InterFaceName {
    public default void method() {
        //执行语句
    }
    public static void method2() {
        //执行语句
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;含有私有方法和私有静态方法&quot;&gt;含有私有方法和私有静态方法&lt;/h4&gt;
&lt;p&gt;私有方法：使用 &lt;code&gt;private&lt;/code&gt; 修饰，供接口中的默认方法或者静态方法调用。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public interface InterFaceName {
    private void method() {
        //执行语句
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;基本的实现&quot;&gt;基本的实现&lt;/h3&gt;
&lt;h4 id=&quot;实现的概述&quot;&gt;实现的概述&lt;/h4&gt;
&lt;p&gt;类与接口的关系为实现关系，即&lt;strong&gt;类实现接口&lt;/strong&gt;，该类可以称为接口的实现类，也可以称为接口的子类。实现的动作类似继承，格式相仿，只是关键字不同，实现使用 &lt;code&gt;implements&lt;/code&gt; 关键字。&lt;/p&gt;
&lt;p&gt;非抽象子类实现接口：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;必须重写接口中所有抽象方法。&lt;/li&gt;
&lt;li&gt;继承了接口的默认方法，即可以直接调用，也可以重写。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;实现格式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class 类名 implements 接口名 {
    // 重写接口中抽象方法【必须】
    // 重写接口中默认方法【可选】
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;抽象方法的使用&quot;&gt;抽象方法的使用&lt;/h4&gt;
&lt;p&gt;必须全部实现，代码如下：&lt;/p&gt;
&lt;p&gt;定义接口：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public interface LivaAble {
    //定义抽象方法
    public abstract void eat();
    public abstract void sleep();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定义实现类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Animal implements LiveAble {
    @Override
    public void eat() {
        System.out.println(&quot;吃东西&quot;);
    }
    @Override
    public void sleep() {
        System.out.println(&quot;晚上睡&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class InterfaceDemo {
    public static void main(String[] args) {
        //创建子类对象
        Animal a = new Animal();
        //调用实现后的方法
        a.eat();
        a.sleep();
    }
}
输出结果：
吃东西
晚上睡&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;默认方法的使用&quot;&gt;默认方法的使用&lt;/h4&gt;
&lt;p&gt;可以继承，可以重写，二选一，但是只能通过实现类的对象来调用。&lt;/p&gt;
&lt;p&gt;1.默认继承方法，代码如下：&lt;/p&gt;
&lt;p&gt;定义接口：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public interface LiveAble {
    public default void fly() {
        System.out.println(&quot;天上飞&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定义实现类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Animal implements LiveAble {
    //继承，什么都不用谢，直接调用
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class InterfaceDemo {
    public static void main(String[] args) {
        //创建子类对象
        Animal a = new Animal();
        //调用默认方法
        a.fly();
    }
}
输出结果：
天上飞&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.重写默认方法，代码如下：&lt;/p&gt;
&lt;p&gt;定义接口：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public interface LiveAble {
    public default void fly() {
        System.out.println(&quot;天上飞&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定义实现类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Animal implements LiveAble {
    @Override
    public void fly() {
        System.out.println(&quot;自由自在的飞&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class InterfaceDemo {
    public static void main(String[] args) {
        //创建子类对象
        Animal a = new Animal();
        //调用重写方法
        a.fly();
    }
}
输出结果：
自由自在的飞&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;静态方法的使用&quot;&gt;静态方法的使用&lt;/h4&gt;
&lt;p&gt;静态与.class 文件相关，只能使用接口名调用，不可以通过实现类的类名或者实现类的对象调用，代码如下：&lt;/p&gt;
&lt;p&gt;定义接口：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public interface LiveAble {
    public static void run() {
        System.out.println(&quot;地上跑&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定义实现类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Animale implements LiveAble {
    //无法重写静态方法
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class InterfaceDemo {
    public static void main(String[] args) {
        // Animal.run(); //【错误】无法继承方法，也无法调用
        LiveAble.run();
    }
}
输出结果：
地上跑&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;私有方法的使用&quot;&gt;私有方法的使用&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;私有方法：只有默认方法可以调用&lt;/li&gt;
&lt;li&gt;私有静态方法：默认方法和静态方法可以调用。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果一个接口中有多个默认方法，并且方法中有重复的内容，那么可以抽取出来，封装到私有方法中，供默认方法去调用。从设计的角度讲，私有的方法是对默认方法和静态方法的辅助。&lt;/p&gt;
&lt;p&gt;定义接口：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public interface LiveAble {
    default void func() {
        func1();
        func2();
    }
    private void func1(){
        System.out.println(&quot;func1~~&quot;);
    }
    private void func2(){
        System.out.println(&quot;func2~~&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;接口的多实现&quot;&gt;接口的多实现&lt;/h3&gt;
&lt;p&gt;之前学过，在继承体系中，一个类只能继承一个父类。而对于接口而言，一个类是可以实现多个接口的，这叫做接口的&lt;strong&gt;多实现&lt;/strong&gt;。并且，一个类能继承一个父类，同时实现多个接口。&lt;/p&gt;
&lt;p&gt;实现格式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class 类名 [extends 父类名] implements 接口名1，接口名2，接口名3... {
    //重写接口中的抽象方法【必须】
    //重写接口中的默认方法【不重名时可选】
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;抽象方法-1&quot;&gt;抽象方法&lt;/h4&gt;
&lt;p&gt;接口中，有多个抽象方法时，实现类必须重写所有抽象方法。&lt;strong&gt;如果抽象方法有重名的，只需要重写一次&lt;/strong&gt;。代码如下：&lt;/p&gt;
&lt;p&gt;定义多个接口：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;interface A {
    public abstract void showA();
    public abstract void show();
}
interface B {
    public abstract void showB();
    public abstract void show();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定义实现类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class C implements A,B{
    @Override
    public void showA() {
        System.out.println(&quot;showA&quot;);
    }
    @Override
    public void showB() {
        System.out.println(&quot;showB&quot;);
    }
    @Override
    public void show() {
        System.out.println(&quot;show&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;默认方法&quot;&gt;默认方法&lt;/h4&gt;
&lt;p&gt;接口中，有多个默认方法时，实现类都可继承使用。&lt;strong&gt;如果默认方法有重名的，必须重写一次&lt;/strong&gt;。代码如下：&lt;/p&gt;
&lt;p&gt;定义多个接口：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;interface A {
    public default void methodA(){}
    public default void method(){}
}
interface B {
    public default void methodB(){}
    public default void method(){}
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定义实现类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class C implements A,B {
    @Override
    public void method() {
        System.out.println(&quot;method&quot;);   
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;静态方法&quot;&gt;静态方法&lt;/h4&gt;
&lt;p&gt;接口中，存在同名的静态方法并不会冲突，原因是只能通过各自接口名访问静态方法。&lt;/p&gt;
&lt;h4 id=&quot;优先级的问题&quot;&gt;优先级的问题&lt;/h4&gt;
&lt;p&gt;当一个类，既继承一个父类，又实现若干个接口时，父类中的成员方法与接口中的默认方法重名，子类就近选择执行父类的成员方法。代码如下：&lt;/p&gt;
&lt;p&gt;定义接口:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;interface A {
    public default void methodA(){
        System.out.println(&quot;AAA&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定义父类:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class B {
    public void methodA(){
        System.out.println(&quot;BBB&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定义子类:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class C extends D implements A {
    //未重写methodA方法
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试类:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Test {
    public static void main(String[] args) {
        C c = new C();
        c.methodA();
    }
}
输出结果：
BBB&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;接口的多继承了解&quot;&gt;接口的多继承【了解】&lt;/h3&gt;
&lt;p&gt;一个接口能继承另一个或者多个接口，这和类之间的继承比较相似。接口的继承使用 extends 关键字，子接口继承父接口的方法。&lt;strong&gt;如果父接口中的默认方法有重名的，那么子接口需要重写一次&lt;/strong&gt;。代码如下：&lt;/p&gt;
&lt;p&gt;定义父接口：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;interface A {
    public default void method(){
        System.out.println(&quot;AAA&quot;);
    }
}
interface B {
    public default void method(){
        System.out.println(&quot;BBB&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定义子接口：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;interface D extends A,B {
    @Override
    public default void method() {
        System.out.println(&quot;DD&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;小贴士：&lt;br/&gt;子接口重写默认方法时，default关键字可以保留。子类重写默认方法时，default关键字不可以保留。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;其他成员特点&quot;&gt;其他成员特点&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;接口中，无法定义成员变量，但是可以定义常量，其值不可以改变，默认使用public static ﬁnal修饰。&lt;/li&gt;
&lt;li&gt;接口中，没有构造方法，不能创建对象。&lt;/li&gt;
&lt;li&gt;接口中，没有静态代码块。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;多态&quot;&gt;多态&lt;/h2&gt;
&lt;h3 id=&quot;概述-3&quot;&gt;概述&lt;/h3&gt;
&lt;h4 id=&quot;引入&quot;&gt;引入&lt;/h4&gt;
&lt;p&gt;多态是继封装、继承之后，面向对象的第三大特性。&lt;/p&gt;
&lt;p&gt;生活中，比如跑的动作，小猫、小狗和大象，跑起来是不一样的。再比如飞的动作，昆虫、鸟类和飞机，飞起来也是不一样的。可见，同一行为通过不同的事物，可以体现出来的不同的形态。多态描述的就是这样的状态。&lt;/p&gt;
&lt;h4 id=&quot;定义-2&quot;&gt;定义&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;多态&lt;/strong&gt;： 是指同一行为，具有多个不同表现形式。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;前提重点&quot;&gt;前提【重点】&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;继承或者实现【二选一】&lt;/li&gt;
&lt;li&gt;方法的重写【意义体现：不重写，无意义】&lt;/li&gt;
&lt;li&gt;父类引用指向子类对象【格式体现】&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;多态的体现&quot;&gt;多态的体现&lt;/h3&gt;
&lt;p&gt;多态体现的格式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;父类类型 变量名 = new 子类对象;
变量名.方法名();&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;父类类型：指子类对象继承的父类类型，或者实现的父接口类型。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Fu f = new Zi();
f.method();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，执行的是子类重写后方法。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;p&gt;定义父类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public abstract class Animal {
    public abstract void eat();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定义子类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public Cat extends Animal {
    public void eat() {
        System.out.println(&quot;吃鱼&quot;);
    }
}
public Dog extends Animal {
    public void eat() {
        System.out.println(&quot;吃骨头&quot;)；
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Test {
    public static void main(String[] args) {
        //多态形式，创建对象
        Animal a1 = new Cat();
        //调用的是Cat的eat
        a1.eat();
        //多态形式，创建对象
        Animal a2 = new Dog();
        //调用的是Dog的eat
        a2.eat();
    }
}
输出结果：
吃鱼
吃骨头&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;多态的好处&quot;&gt;多态的好处&lt;/h3&gt;
&lt;p&gt;实际开发的过程中，父类类型作为方法形式参数，传递子类对象给方法，进行方法的调用，更能体现出多态的扩展性与便利。代码如下：&lt;/p&gt;
&lt;p&gt;定义父类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public abstract class Animal {
    public abstract void eat();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定义子类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public Cat extends Animal {
    public void eat() {
        System.out.println(&quot;吃鱼&quot;);
    }
}
public Dog extends Animal {
    public void eat() {
        System.out.println(&quot;吃骨头&quot;)；
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Test_1 {
    public static void main(String[] args) {
        Cat c = new Cat();
        Dog d = new Dog();

        showCatEat(c);
        showDogEat(d);

        /*
        以上两个方法均可以被showAnimalEat(Animal a)方法所替代，且执行效果一致
        */
        showAnimalEat(c);
        showAnimalEat(d);

    }
    public static void showCatEat(Cat c){
        c.eat();
    }
    public static void showDogEat(Dog d){
        d.eat();
    }
    public static void showAnimalEat(Animal a){
        a.eat();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于多态特性的支持，showAnimalEat方法的Animal类型，是Cat和Dog的父类类型，父类类型接收子类对象，当然可以把Cat对象和Dog对象，传递给方法。&lt;/p&gt;
&lt;p&gt;当eat方法执行时，多态规定，执行的是子类重写的方法，那么效果自然与showCatEat、showDogEat方法一致，所以showAnimalEat完全可以替代以上两方法。&lt;/p&gt;
&lt;p&gt;不仅仅是替代，在扩展性方面，无论之后再多的子类出现，我们都不需要编写showXxxEat方法了，直接使用showAnimalEat都可以完成。&lt;/p&gt;
&lt;p&gt;所以，多态的好处，体现在，可以使程序编写的更简单，并有良好的扩展。&lt;/p&gt;
&lt;h3 id=&quot;引用类型转换&quot;&gt;引用类型转换&lt;/h3&gt;
&lt;p&gt;多态的转型分为向上转型与向下转型两种：&lt;/p&gt;
&lt;h4 id=&quot;向上转型&quot;&gt;向上转型&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;向上转型&lt;/strong&gt;：多态本身是子类类型向父类类型向上转换的过程，这个过程是默认的。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当父类引用指向一个子类对象时，便是向上转型。&lt;/p&gt;
&lt;p&gt;使用格式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;父类类型 变量名 = new 子类类型();
如 Animal a = new Cat();&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;向下转型&quot;&gt;向下转型&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;向下转型&lt;/strong&gt;：父类类型向子类类型向下转换的过程，这个过程是强制的。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一个已经向上转型的子类对象，将父类引用转为子类引用，可以使用强制类型转换的格式，便是向下转型。&lt;/p&gt;
&lt;p&gt;使用格式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;子类类型 变量名 = (子类类型) 父类变量名;
如 Cat c = (Cat) a;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;为什么要转型&quot;&gt;为什么要转型&lt;/h4&gt;
&lt;p&gt;当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误。也就是说，不能调用子类拥有，而父类没有的方法。编译都错误，更别说运行了。这也是多态给我们带来的一点&quot;小麻烦&quot;。所以，想要调用子类特有的方法，必须做向下转型。&lt;/p&gt;
&lt;p&gt;转型演示，代码如下：&lt;/p&gt;
&lt;p&gt;定义类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;abstract class Animal {
    abstract void eat();
}

class Cat extends Animal {
    public void eat() {
        System.out.println(&quot;吃鱼&quot;);
    }
    public void catchMouse() {
        Sysetm.out.println(&quot;抓老鼠&quot;);
    }   
}

class Dog extends Animal {
    public void eat() {
        System.out.println(&quot;吃骨头&quot;);
    }
    public void watchHouse() {
        System.out.println(&quot;看家&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Test {
    public static void main(String[] args) {
        //向上转型
        Animal a = new Cat();
        a.eat();    //调用的是Cat的eat
        //向下转型
        Cat c = (Cat) a;
        c.catchMouse();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;转型的异常&quot;&gt;转型的异常&lt;/h4&gt;
&lt;p&gt;转型的过程中，一不小心就会遇到这样的问题，请看如下代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Test {
    public static void main(String[] args) {
        //向上转型
        Animal a = new Cat();
        a.eat();
        //向下转型
        Dog d = (Dog)a;
        d.watchHouse(); //调用的是Dog的watchHouse 【运行报错】
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码可以通过编译，但是运行时，却报出了 &lt;code&gt;ClassCastException&lt;/code&gt; ，类型转换异常！这是因为，明明创建了Cat类型对象，运行时，当然不能转换成Dog对象的。这两个类型并没有任何继承关系，不符合类型转换的定义。&lt;/p&gt;
&lt;p&gt;为了避免ClassCastException的发生，Java提供了 &lt;code&gt;instanceof&lt;/code&gt; 关键字，给引用变量做类型的校验，格式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;变量名 instanceof 数据类型  
如果变量属于该数据类型，返回true。 
如果变量不属于该数据类型，返回false。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以，转换前，我们好先做一个判断，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Test {
    public static void main(String[] args) {
        //向上转型
        Animal a = new Cat();
        a.eat();
        //向下转型
        if (a instanceof Cat) {
            Cat c = (Cat) a;
            c.catchMouse();
        } else if (a instanceof Dog) {
            Dog d = (Dog)a;
            d.watchHouse();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;接口多态的综合案例&quot;&gt;接口多态的综合案例&lt;/h2&gt;
&lt;p&gt;笔记本电脑（laptop）通常具备使用USB设备的功能。在生产时，笔记本都预留了可以插入USB设备的USB接口，但具体是什么USB设备，笔记本厂商并不关心，只要符合USB规格的设备都可以。&lt;/p&gt;
&lt;p&gt;定义USB接口，具备基本的开启功能和关闭功能。鼠标和键盘要想能在电脑上使用，那么鼠标和键盘也必须遵守USB规范，实现USB接口，否则鼠标和键盘的生产出来也无法使用。&lt;/p&gt;
&lt;h3 id=&quot;案例分析&quot;&gt;案例分析&lt;/h3&gt;
&lt;p&gt;进行描述笔记本类，实现笔记本使用USB鼠标、USB键盘&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;USB接口，包含开启功能、关闭功能&lt;/li&gt;
&lt;li&gt;笔记本类，包含运行功能、关机功能、使用USB设备功能&lt;/li&gt;
&lt;li&gt;鼠标类，要实现USB接口，并具备点击的方法&lt;/li&gt;
&lt;li&gt;键盘类，要实现USB接口，具备敲击的方法&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;案例实现&quot;&gt;案例实现&lt;/h3&gt;
&lt;p&gt;定义USB接口：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public interface USB {
    void open(); //开启功能
    void close(); //关闭功能
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定义鼠标类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Mouse implements USB {
    @Override
    public void open() {
        System.out.println(&quot;鼠标开启，红灯亮&quot;);
    }

    @Override
    public void close() {
        System.out.println(&quot;鼠标关闭，红灯灭&quot;);
    }

    public void click() {
        System.out.println(&quot;鼠标点击&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定义键盘类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class KeyBoard implements USB {
    @Override
    public void open() {
        System.out.println(&quot;键盘开启，绿灯亮&quot;);
    }

    @Override
    public void close() {
        System.out.println(&quot;键盘关闭，绿灯灭&quot;);
    }

    public void type() {
        System.out.println(&quot;键盘打字&quot;);
    }   
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定义笔记本类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Laptop {
    public void run() {
        System.out.println(&quot;笔记本运行&quot;);
    }

    //笔记本使用usb设备，当笔记本对象调用这个功能时必须给其传递一个符合USB规则的USB设备
    public void useUSB(USB usb) {
        if (usb != null) {
            usb.open();
            if (usb instanceof Mouse){
                Mouse m = (Mouse) usb;
                m.click();
            } else if (usb instanceof KeyBoard) {
                KeyBoard kb = (KeyBoard)usb;
                kb.type();
            }
            usb.close();
        }
    }

    public void shutDown() {
        System.out.println(&quot;笔记本关闭&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Test {
    public static void main(String[] args) {
        Laptop lt = new Laptop();
        lt.run();

        //创建鼠标实体对象
        USB u = new Mouse();
        //笔记本使用鼠标
        lt.useUSB(u);
        //创建键盘实体对象
        USB kb = new KeyBoard();
        //笔记本使用键盘
        lt.useUSB(kb);

        lt.shutDown();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;final关键字&quot;&gt;final关键字&lt;/h2&gt;
&lt;h3 id=&quot;概述-4&quot;&gt;概述&lt;/h3&gt;
&lt;p&gt;学习了继承后，我们知道，子类可以在父类的基础上改写父类内容，比如，方法重写。那么我们能不能随意的继承API中提供的类，改写其内容呢？显然这是不合适的。为了避免这种随意改写的情况，Java提供了 final 关键字，用于修饰不可改变内容。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;ﬁnal&lt;/strong&gt;： 不可改变。可以用于修饰类、方法和变量。
&lt;ul&gt;&lt;li&gt;类：被修饰的类，不能被继承。&lt;/li&gt;
&lt;li&gt;方法：被修饰的方法，不能被重写。&lt;/li&gt;
&lt;li&gt;变量：被修饰的变量，不能被重新赋值。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;使用方式&quot;&gt;使用方式&lt;/h3&gt;
&lt;h4 id=&quot;修饰类&quot;&gt;修饰类&lt;/h4&gt;
&lt;p&gt;格式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;final class 类名 {

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查询API发现像 &lt;code&gt;public final class String&lt;/code&gt; 、 &lt;code&gt;public final class Math&lt;/code&gt; 、 &lt;code&gt;public final class Scanner&lt;/code&gt;等，很多我们学习过的类，都是被ﬁnal修饰的，目的就是供我们使用，而不让我们所以改变其内容。&lt;/p&gt;
&lt;h4 id=&quot;修饰方法&quot;&gt;修饰方法&lt;/h4&gt;
&lt;p&gt;格式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;修饰符 final 返回值类型 方法名(参数列表) {
    //方法体
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重写被 &lt;code&gt;final&lt;/code&gt; 修饰的方法，编译时就会报错。&lt;/p&gt;
&lt;h4 id=&quot;修饰变量&quot;&gt;修饰变量&lt;/h4&gt;
&lt;p&gt;1.局部变量——基本类型&lt;/p&gt;
&lt;p&gt;基本类型的局部变量，被ﬁnal修饰后，只能赋值一次，不能再更改。&lt;/p&gt;
&lt;p&gt;2.局部变量——引用类型&lt;/p&gt;
&lt;p&gt;引用类型的局部变量，被ﬁnal修饰后，只能指向一个对象，地址不能再更改。但是不影响对象内部的成员变量值的修改，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class FinalDemo2 {
    public static void main(String[] args) {
        //创建User对象
        final User u = new User();
        //创建另一个User对象
        u = new User(); //报错，指向了新的对象，地址值改变。
        //调用setName方法
        u.setName(&quot;张三&quot;); //可以修改
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.成员变量&lt;/p&gt;
&lt;p&gt;成员变量涉及到初始化的问题，初始化方式有两种，只能二选一：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;显示初始化：&lt;/p&gt;
&lt;p&gt;public class User {&lt;br/&gt;final String USERNAME = &quot;张三&quot;;&lt;br/&gt;private int age;&lt;br/&gt;}&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;构造方法初始化：&lt;/p&gt;
&lt;p&gt;public class User {&lt;br/&gt;final String USERNAME;&lt;br/&gt;private int age;&lt;br/&gt;public User(String username, int age) {&lt;br/&gt;this.USERNAME = username;&lt;br/&gt;this.age = age;&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;被ﬁnal修饰的常量名称，一般都有书写规范，所有字母都大写。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;权限修饰符&quot;&gt;权限修饰符&lt;/h2&gt;
&lt;h3 id=&quot;概述-5&quot;&gt;概述&lt;/h3&gt;
&lt;p&gt;在Java中提供了四种访问权限，使用不同的访问权限修饰符修饰时，被修饰的内容会有不同的访问权限。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;public：公共的&lt;/li&gt;
&lt;li&gt;protected：受保护的&lt;/li&gt;
&lt;li&gt;default：默认的&lt;/li&gt;
&lt;li&gt;private：私有的&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;不同权限的访问能力&quot;&gt;不同权限的访问能力&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;同一类中&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;同一包中（子类与无关类）&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;不同包的子类&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;不同包中的无关类&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;可见，public具有最大权限。private则是最小权限。&lt;/p&gt;
&lt;p&gt;编写代码时，如果没有特殊的考虑，建议这样使用权限：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;成员变量使用 &lt;code&gt;private&lt;/code&gt; ，隐藏细节。&lt;/li&gt;
&lt;li&gt;构造方法使用 &lt;code&gt;public&lt;/code&gt; ，方便创建对象。&lt;/li&gt;
&lt;li&gt;成员方法使用 &lt;code&gt;public&lt;/code&gt; ，方便调用方法。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;小贴士：不加权限修饰符，其访问能力与default修饰符相同&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;内部类&quot;&gt;内部类&lt;/h2&gt;
&lt;h3 id=&quot;概述-6&quot;&gt;概述&lt;/h3&gt;
&lt;h4 id=&quot;什么是内部类&quot;&gt;什么是内部类&lt;/h4&gt;
&lt;p&gt;将一个类A定义在另一个类B里面，里面的那个类A就称为&lt;strong&gt;内部类&lt;/strong&gt;，B则称为&lt;strong&gt;外部类&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&quot;成员内部类&quot;&gt;成员内部类&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;成员内部类&lt;/strong&gt; ：定义在&lt;strong&gt;类中方法外&lt;/strong&gt;的类。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;定义格式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class 外部类 {
    class 内部类 {

    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在描述事物时，若一个事物内部还包含其他事物，就可以使用内部类这种结构。比如，汽车类 &lt;code&gt;Car&lt;/code&gt; 中包含发动机类 &lt;code&gt;Engine&lt;/code&gt; ，这时， &lt;code&gt;Engine&lt;/code&gt; 就可以使用内部类来描述，定义在成员位置。&lt;/p&gt;
&lt;p&gt;代码举例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Car { //外部类
    class Engine {  //内部类

    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;访问特点&quot;&gt;访问特点&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;内部类可以直接访问外部类的成员，包括私有成员。&lt;/li&gt;
&lt;li&gt;外部类要访问内部类的成员，必须要建立内部类的对象。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;创建内部类对象格式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;外部类名.内部类名 对象名 = new 外部类型().new 内部类型()；&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;访问演示代码如下：&lt;/p&gt;
&lt;p&gt;定义类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Person {
    private boolean live = true;
    class Heart {
        public void jump() {
            //直接访问外部类成员
            if (live) {
                System.out.println(&quot;心脏在跳动&quot;);
            } else {
                Sysetm.out.println(&quot;心脏不跳了&quot;);
            }
        }
    }

    public boolean isLive() {
        return live;
    }
    public void setLive(boolean live) {
        this.live = live;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class InnerDemo {
    public static void main(String[] args) {
        //创建外部类对象
        Person p = new Person();
        //创建内部类对象
        Heart heart = p.new Heart();

        //调用内部类方法
        heart.jump();
        //调用外部类方法
        p.setLive(false);
        //调用内部类方法
        heart.jump;
    }
}
输出结果：
心脏在跳动
心脏不跳了&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;内部类仍然是一个独立的类，在编译之后会内部类会被编译成独立的.class文件，但是前面冠以外部类的类名和$符号 。&lt;br/&gt;比如，Person$Heart.class&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;匿名内部类重点&quot;&gt;匿名内部类【重点】&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;匿名内部类&lt;/strong&gt; ：是内部类的简化写法。它的本质是一个 &lt;code&gt;带具体实现的&lt;/code&gt; &lt;code&gt;父类或者父接口的&lt;/code&gt; &lt;code&gt;匿名的&lt;/code&gt; &lt;strong&gt;子类对象&lt;/strong&gt;。&lt;br/&gt;开发中，最常用到的内部类就是匿名内部类了。以接口举例，当你使用一个接口时，似乎得做如下几步操作。&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;定义子类&lt;/li&gt;
&lt;li&gt;重写接口中的方法&lt;/li&gt;
&lt;li&gt;创建子类对象&lt;/li&gt;
&lt;li&gt;调用重写后的方法&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我们的目的，最终只是为了调用方法，那么能不能简化一下，把以上四步合成一步呢？匿名内部类就是做这样的快捷方式。&lt;/p&gt;
&lt;h4 id=&quot;前提&quot;&gt;前提&lt;/h4&gt;
&lt;p&gt;匿名内部类必须&lt;strong&gt;继承一个父类&lt;/strong&gt;或者&lt;strong&gt;实现一个父接口&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&quot;格式&quot;&gt;格式&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;new 父类名或者接口名() {
    //方法重写
    @Override
    public void method() {
        //执行语句
    }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;使用方式-1&quot;&gt;使用方式&lt;/h4&gt;
&lt;p&gt;以接口为例，匿名内部类的使用，代码如下：&lt;/p&gt;
&lt;p&gt;定义接口：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public abstract class FlyAble{
    public abstract void fly();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建匿名内部类并调用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class InnerDemo {
    public static void main(String[] args) {
        /*
        1.等号右边:是匿名内部类，定义并创建该接口的子类对象 
        2.等号左边:是多态赋值,接口类型引用指向子类对象   
        */
        FlyAble f = new FlyAble() {
            public void fly() {
                System.out.println(&quot;fly~&quot;);
            }
        };
        
        //调用fly方法，执行重写后的方法
        f.fly();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通常在方法的形式参数是接口或者抽象类时，也可以将匿名内部类作为参数传递。代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class InnerDemo2 {
    public static void main(String[] args) {
        /*         
        1.等号右边:定义并创建该接口的子类对象         
        2.等号左边:是多态,接口类型引用指向子类对象        
        */ 
        FlyAble f = new FlyAble() {
            public void fly() {
                System.out.println(&quot;fly~~&quot;);
            }
        };
        //将f传递给showFly方法中
        showFly(f);
    }
    public static void showFly(FlyAble f) {
        f.fly();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上两步，也可以简化为一步，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class InnerDemo3 {
    public static void main(String[] args) {
        /*         
        创建匿名内部类,直接传递给showFly(FlyAble f)           
        */
        showFly(new FlyAble(){
            public void fly() {
                System.out.println(&quot;fly~~&quot;);
            }
        }); 
    }
    public static void showFly(FlyAble f) {
        f.fly();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;引用类型用法总结&quot;&gt;引用类型用法总结&lt;/h2&gt;
&lt;p&gt;实际的开发中，引用类型的使用非常重要，也是非常普遍的。我们可以在理解基本类型的使用方式基础上，进一步去掌握引用类型的使用方式。基本类型可以作为成员变量、作为方法的参数、作为方法的返回值，那么当然引用类型也是可以的。&lt;/p&gt;
&lt;h3 id=&quot;class作为成员变量&quot;&gt;class作为成员变量&lt;/h3&gt;
&lt;p&gt;在定义一个类Role（游戏角色）时，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Role {
    int id; //角色id
    int blood; //生命值
    String name; //角色名称
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用 &lt;code&gt;int&lt;/code&gt; 类型表示 角色id和生命值，使用 &lt;code&gt;String&lt;/code&gt; 类型表示姓名。此时， &lt;code&gt;String&lt;/code&gt; 本身就是引用类型，由于使用的方式类似常量，所以往往忽略了它是引用类型的存在。如果我们继续丰富这个类的定义，给 &lt;code&gt;Role&lt;/code&gt; 增加武器，穿戴装备等属性，我们将如何编写呢？&lt;/p&gt;
&lt;p&gt;定义武器类，将增加攻击能力：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Weapon { 
    String name; //武器名称
    int hurt; //伤害值
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定义穿戴盔甲类，将增加防御能力，也就是提升生命值：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Armour {
    String name; //装备名称
    int protect; //防御值
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定义角色类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Role {
    int id;
    int blood;
    String name;
    //添加武器属性
    Weapon wp;
    //添加盔甲属性
    Armour ar;

    //提供get/set方法
    public Weapon getWp() {
        return wp;
    }
    public void setWeapon(Weapon wp) {
        this.wp = wp;
    }
    public Armour getArmour() {
        return ar;
    }
    public void setArmour(Armour ar) {
        this.ar = ar;
    }
    //攻击方法
    public void attack() {
        System.out.println(&quot;使用&quot;+wp.getName() + &quot;, 造成&quot;+wp.getHurt()+&quot;点伤害&quot;);
    }
    //穿戴盔甲
    public void wear() {
        //增加防御就是增加blood值
        this.blood += ar.getProtect();
        System.out.println(&quot;穿上&quot;+ar.getName()+&quot;, 生命值增加&quot;+ar.getProtect());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Test {
    public static void main(String[] args) {
        //创建Weapon对象
        Weapon wp = new Weapon(&quot;屠龙宝刀&quot;, 99999);
        //创建Armour对象
        Armour ar = new Armour(&quot;麒麟甲&quot;,10000);
        //创建Role对象
        Role r = new Role();
        //设置属性
        r.setWeapon(wp);
        r.setArmour(ar);
        r.attack();
        r.wear();
    }
}
输出结果：
使用屠龙宝刀，造成99999点伤害
穿上麒麟甲，生命值增加10000&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;类作为成员变量时，对它进行赋值的操作，实际上是赋给它该类的一个对象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;interface作为成员变量&quot;&gt;interface作为成员变量&lt;/h3&gt;
&lt;p&gt;接口是对方法的封装，对应游戏当中，可以看作是扩展游戏角色的技能。所以，如果想扩展更强大技能，我们在&lt;code&gt;Role&lt;/code&gt;中，可以增加接口作为成员变量，来设置不同的技能。&lt;/p&gt;
&lt;p&gt;定义接口：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//法术攻击
public interface FaShuSkill {
    public abstract void FaShuAttack();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定义角色类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Role {
    FaShuSkill fs;
    public void setFaShuSkill(FaShuSkill fs) {
        this.fs = fs;
    }
    //法术攻击
    public void FaShuSkillAttack() {
        System.out.print(&quot;发动法术攻击:&quot;);
        fa.FaShuAttack();
        System.out.println(&quot;攻击完毕&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Test {
    public static void main(String[] args) {
        //创建游戏角色
        Role role = new Role();
        //设置角色法术技能
        role.setFaShuSkill(new FaShuSkill(){
            @Override
            public void FaShuAttack() {
                System.out.println(&quot;纵横天下&quot;);
            }
        });
        //发动法术攻击
        role.FaShuSkillAttack();
        //更换技能
        role.setFaShuSkill(new FaShuSkill() {
            @Override
            public void FaShuAttack() {
                System.out.println(&quot;逆转乾坤&quot;)；
            }
        })；
        //发动法术攻击
        role.FaShuSkillAttack();
    }
}
输出结果：
发动法术攻击:纵横天下 
攻击完毕 
发动法术攻击:逆转乾坤 
攻击完毕 &lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;我们使用一个接口，作为成员变量，以便随时更换技能，这样的设计更为灵活，增强了程序的扩展性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;接口作为成员变量时，对它进行赋值的操作，实际上，是赋给它该接口的一个子类对象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;interface作为方法参数和返回值类型&quot;&gt;interface作为方法参数和返回值类型&lt;/h3&gt;
&lt;p&gt;当接口作为方法的参数时,需要传递什么呢？当接口作为方法的返回值类型时，需要返回什么呢？对，其实都是它的子类对象。 &lt;code&gt;ArrayList&lt;/code&gt; 类我们并不陌生，查看API我们发现，实际上，它是 &lt;code&gt;java.util.List&lt;/code&gt; 接口的实现类。所以，当我们看见 &lt;code&gt;List&lt;/code&gt; 接口作为参数或者返回值类型时，当然可以将 &lt;code&gt;ArrayList&lt;/code&gt; 的对象进行传递或返回。&lt;/p&gt;
&lt;p&gt;请观察如下方法：&lt;strong&gt;获取某集合中所有的偶数&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;定义方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static List&amp;lt;Integer&amp;gt; getEvenNum(List&amp;lt;Integer&amp;gt; list){
    //创建保存偶数的集合
    ArrayList&amp;lt;Integer&amp;gt; evenList = new ArrayList&amp;lt;&amp;gt;();
    for (int i = 0; i &amp;lt; list.size(); i++){
        Integer integer = list.get(i);
        if(integer % 2 == 0) {
            evenList.add(integer);
        }
    }
    /*
    返回偶数集合
    因为getEvenNum方法的返回值类型是List，而ArrayList是List的子类，所以evenList可以返回
     */
    return evenList;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static void main(String[] args) {
    //创建ArrayList集合，并添加数字
    ArrayList&amp;lt;Integer&amp;gt; srcList = new ArrayList&amp;lt;&amp;gt;();
    for(int i = 0; i &amp;lt; 10; i++) {
        srcList.add(i);
    }
    /*        
    获取偶数集合          
    因为getEvenNum方法的参数是List,而ArrayList是List的子类,          
    所以srcList可以传递          
    */
    List list = getEvenNum(srcList);
    System.out.println(list);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;接口作为参数时，传递它的子类对象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;接口作为返回值类型时，返回它的子类对象。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 30 Jan 2020 13:40:00 +0000</pubDate>
<dc:creator>平酱</dc:creator>
<og:description>继承 概述 由来 多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那一个类即可。如图所示： 其中，多个类可以称为 子类 ，单独那一个类称为 父类</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/p1ng/p/12244063.html</dc:identifier>
</item>
</channel>
</rss>