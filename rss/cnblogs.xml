<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>在React旧项目中安装并使用TypeScript的实践 - 韩子卢</title>
<link>http://www.cnblogs.com/vvjiang/p/11944912.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/vvjiang/p/11944912.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;本篇文章默认您大概了解什么是TypeScript，主要讲解如何在React旧项目中安装并使用TypeScript。&lt;/p&gt;
&lt;p&gt;写这个的目的主要是网上关于TypeScript这块的讲解虽然很多，但都是一些语法概念或者简单例子，真正改造一个React旧项目使用TypeScript的文章很少。&lt;/p&gt;
&lt;p&gt;所以在这里记录下改造一个React项目的实践。&lt;/p&gt;
&lt;p&gt;博客内容部分参照 &lt;a href=&quot;https://www.tslang.cn/docs/handbook/react-&amp;amp;-webpack.html&quot;&gt;TypeScript中文网&lt;/a&gt;，这个网站有官方文档的中文版。&lt;/p&gt;
&lt;h2 id=&quot;安装typescript及相关库&quot;&gt;安装TypeScript及相关库&lt;/h2&gt;
&lt;p&gt;对于集成了TypeScript的脚手架可以略过这一步，这里主要讲一下如何将TypeScript集成到一个React脚手架中。&lt;/p&gt;
&lt;p&gt;首先执行&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;npm install --save @types/react @types/react-dom&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这一步主要是为了获取react和react-dom的声明文件，因为并不是所有的库都有TypeScript的声明文件，所以通过运行&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;npm install --save @types/库名字&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;的方式来获取TypeScript的声明文件。&lt;/p&gt;
&lt;p&gt;只有获取了声明文件，才能实现对这个库的类型检查。&lt;/p&gt;
&lt;p&gt;如果你使用了一些其它的没有声明文件的库，那么可能也需要这么做。&lt;/p&gt;
&lt;p&gt;然后运行命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;npm install --save-dev typescript awesome-typescript-loader source-map-loader&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这一步，我们安装了typescript、awesome-typescript-loader和source-map-loader。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;awesome-typescript-loader&lt;/strong&gt;可以让Webpack使用TypeScript的标准配置文件tsconfig.json编译TypeScript代码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;source-map-loader&lt;/strong&gt;使用TypeScript输出的sourcemap文件来告诉webpack何时生成自己的sourcemaps,源码映射，方便调试。&lt;/p&gt;
&lt;h2 id=&quot;添加typescript配置文件&quot;&gt;添加TypeScript配置文件&lt;/h2&gt;
&lt;p&gt;在项目根目录下创建一个tsconfig.json文件，以下为内容示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
  &quot;compilerOptions&quot;: {
    &quot;allowSyntheticDefaultImports&quot;: true, // 允许从没有设置默认导出的模块中默认导入。这并不影响代码的输出，仅为了类型检查。
    &quot;outDir&quot;: &quot;./dist/&quot;, // 重定向输出目录
    &quot;sourceMap&quot;: true, // 生成相应的 .map文件
    &quot;noImplicitAny&quot;: true, // 在表达式和声明上有隐含的 any类型时报错。
    &quot;module&quot;: &quot;esnext&quot;, // 模块引入方式
    &quot;target&quot;: &quot;esnext&quot;, // 指定ECMAScript目标版本
    &quot;moduleResolution&quot;: &quot;node&quot;, // 决定如何处理模块
    &quot;lib&quot;: [
      &quot;esnext&quot;,
      &quot;dom&quot;
    ], // 编译过程中需要引入的库文件的列表。
    &quot;skipLibCheck&quot;: true, //忽略所有库中的声明文件（ *.d.ts）的类型检查。
    &quot;jsx&quot;: &quot;react&quot; // 在 .tsx文件里支持JSX
  },
  &quot;include&quot;: [
    &quot;./src/**/*&quot;, // 这个表示处理根目录的src目录下所有的.ts和.tsx文件，并不是所有文件
  ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;skipLibCheck&lt;/strong&gt;非常重要，并不是每个库都能通过typescript的检测。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;moduleResolution&lt;/strong&gt;设为node也很重要。如果不这么设置的话，找声明文件的时候typescript不会在node_modules这个文件夹中去找。&lt;/p&gt;
&lt;p&gt;更多配置文件信息可以参考：&lt;a href=&quot;https://www.tslang.cn/docs/handbook/tsconfig-json.html&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;配置webpack&quot;&gt;配置webpack&lt;/h2&gt;
&lt;p&gt;这里列出一些TypeScript需要在webpack中使用的配置。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解析tsx文件的rule配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;module: {
    rules: [
      {
        test: /\.jsx?$/,
        exclude: /(node_modules)/,
        use: {
          loader: 'babel-loader',
          options: {
            presets: ['react', 'env', 'stage-0', 'stage-3'],
            plugins: [
              'transform-decorators-legacy',
              ['import', { libraryName: 'antd', style: 'css' }], // `style: true` 会加载 less 文件
            ],
          },
        },
      },
      { test: /\.tsx?$/, loader: &quot;awesome-typescript-loader&quot; }
      //...
    ]
    //...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实就只是多加了一行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{ test: /\.tsx?$/, loader: &quot;awesome-typescript-loader&quot; }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意这一行需要加在解析jsx的rule下面，因为rule的执行顺序是从下往上的，先解析tsx和ts再解析js和jsx。&lt;/p&gt;
&lt;p&gt;当然用&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;enforce: 'pre'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调整过rule顺序的可以不用在意这一点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决使用css-moudule的问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果代码中使用了以下这种代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import styles from './index.css'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么很可能报下面的错：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Cannot find module './index.css'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解决方法就是在根目录下新建文件一个叫declaration.d.ts的文件，内容为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;declare module '*.css' {
  const content: any;
  export default content;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这行代码就是为所有的css文件进行声明。&lt;/p&gt;
&lt;p&gt;同时需要更改一下我们之前的tsconfig.json文件，将这个文件路径放在include中：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;include&quot;: [
  &quot;./src/**/*&quot;, 
  &quot;./declaration.d.ts&quot;
]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个问题有通过安装一些库来解决的办法，但是会给每个css生成一个声明文件，感觉有点奇怪，我这里自己考虑了一下采用了上面这种方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用于省略后缀名的配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你惯于在使用&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import Chart from './Chart/index.jsx'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;时省略后缀，即：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import Chart from './Chart/index'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么在webpack的resolve中同样需要加入ts和tsx：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;resolve: {
  extensions: [&quot;.ts&quot;, &quot;.tsx&quot;, &quot;.js&quot;, &quot;.jsx&quot;]
},&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;引入ant-design&quot;&gt;引入Ant Design&lt;/h2&gt;
&lt;p&gt;实际上这个东西Ant Design的官网上就有怎么在TypeScript中使用：&lt;a href=&quot;https://ant.design/docs/react/use-in-typescript-cn&quot;&gt;在 TypeScript 中使用&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;那么为什么还是要列出来呢？&lt;/p&gt;
&lt;p&gt;因为这里要指出，对于已经安装了Ant Design的旧项目而言（一般都是配了按需加载的吧），在安装配置TypeScript时上面这个文档基本没有任何用处。&lt;/p&gt;
&lt;p&gt;在网上可以搜到的貌似都是文档中的方案，而实际上我们需要做的只是安装&lt;strong&gt;ts-import-plugin&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;npm i ts-import-plugin --save-dev&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后结合之前的 &lt;strong&gt;awesome-typescript-loader&lt;/strong&gt; ，在webpack中进行如下配置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const tsImportPluginFactory = require('ts-import-plugin')

module.exports = {
  // ...
  module: {
    rules: [
      {
        test: /\.tsx?$/,
        loader: &quot;awesome-typescript-loader&quot;,
        options: {
          getCustomTransformers: () =&amp;gt; ({
            before: [tsImportPluginFactory([
              {
                libraryName: 'antd',
                libraryDirectory: 'lib',
                style: 'css'
              }
            ])]
          }),
        },
        exclude: /node_modules/
      }
    ]
  },
  // ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;配置完成修改前的准备&quot;&gt;配置完成，修改前的准备&lt;/h2&gt;
&lt;p&gt;注意，直到这一步，实际上您的项目在编译过程中仍然没有用到TypeScript。&lt;/p&gt;
&lt;p&gt;因为我们这里只会用TypeScript处理.ts和.tsx后缀的文件，除非在配置中将allowJs设为true。&lt;/p&gt;
&lt;p&gt;在使用之前，默认您已经对TypeScript语法有了了解，不了解可以参考：&lt;a href=&quot;https://www.tslang.cn/docs/handbook/typescript-in-5-minutes.html&quot;&gt;5分钟上手TypeScript&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;也就是说，经过了上面的这些步骤，您的原有代码在不改动后缀的情况下应该是可以继续用的。&lt;/p&gt;
&lt;p&gt;如果要使用TypeScript，那么新建tsx和ts文件，或者修改原有的文件后缀名即可。&lt;/p&gt;
&lt;p&gt;接下来会列出一些典型的修改示例。&lt;/p&gt;
&lt;h2 id=&quot;函数式组件的修改示例含children&quot;&gt;函数式组件的修改示例（含children）&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;import React from 'react'
import styles from './index.css'

interface ComputeItemProps {
  label: string;
  children: React.ReactNode;
}

function ComputeItem({ label, children }: ComputeItemProps) {
  return &amp;lt;div className={styles['item']}&amp;gt;
    &amp;lt;div className={styles['label']}&amp;gt;{label}:&amp;lt;/div&amp;gt;
    &amp;lt;div className={styles['content']}&amp;gt;{children}&amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
}
export default ComputeItem

这个例子中语法都可以在TypeScript的官网查到，唯一需要注意的是children的类型是React.ReactNode。&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;class组件修改示例含函数声明事件参数的定义&quot;&gt;class组件修改示例(含函数声明，事件参数的定义)&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;import React from 'react'
import styles from './index.css'

interface DataSourceItem {
  dayOfGrowth: string;
  netValueDate: string;
}

interface ComputeProps {
  fundCode: string;
  dataSource: DataSourceItem[];
  onChange(value: Object): void;
}

export default class Compute extends React.Component&amp;lt;ComputeProps, Object&amp;gt; {
  // 改变基金代码
  handleChangeFundCode = (e: React.ChangeEvent&amp;lt;HTMLInputElement&amp;gt;) =&amp;gt; {
    const fundCode = e.target.value
    this.props.onChange({
      fundCode
    })

  }  
  render() {
      //...
    );
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个例子展示如何声明class组件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;React.Component&amp;lt;ComputeProps, Object&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;语法虽然看起来很怪，但是这就是TypeScript中的泛型，以前有过C#或者Java经验的应该很好理解。&lt;/p&gt;
&lt;p&gt;其中，第一个参数定义Props的类型，第二个参数定义State的类型。&lt;/p&gt;
&lt;p&gt;而react的事件参数类型应该如下定义：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;React.ChangeEvent&amp;lt;HTMLInputElement&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里同样使用了泛型，上面表示Input的Change事件类型。&lt;/p&gt;
&lt;p&gt;而组件的Prop上有函数类型的定义，这里就不单独列出来了。&lt;/p&gt;
&lt;p&gt;这几个例子算是比较典型的TypeScript与React结合的例子。&lt;/p&gt;
&lt;h2 id=&quot;处理window上的变量&quot;&gt;处理window上的变量&lt;/h2&gt;
&lt;p&gt;使用写在window上的全局变量会提示window上不存在这个属性。&lt;/p&gt;
&lt;p&gt;为了处理这点，可以在declaration.d.ts这个文件中定义变量：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 定义window变量
interface Window{
  r:string[]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中r是变量名。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;本来还想再多写几个示例的，但是Dota2版本更新了，导致我不想继续写下去了，以后如果有时间再更新常用的示例吧。&lt;/p&gt;
&lt;p&gt;本篇文章只专注于在React旧项目中安装并集成TypeScript，尽可能做到不涉及TypeScript的具体语法与介绍，因为介绍这些东西就不是一篇博客能搞定的了。&lt;/p&gt;
&lt;p&gt;文章如有疏漏还请指正，希望能帮助到在TypeScript面前迟疑的你。&lt;/p&gt;
</description>
<pubDate>Thu, 28 Nov 2019 00:41:00 +0000</pubDate>
<dc:creator>韩子卢</dc:creator>
<og:description>前言 本篇文章默认您大概了解什么是TypeScript，主要讲解如何在React旧项目中安装并使用TypeScript。 写这个的目的主要是网上关于TypeScript这块的讲解虽然很多，但都是一些语</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/vvjiang/p/11944912.html</dc:identifier>
</item>
<item>
<title>用NodeJS实现一个网络爬虫小应用-爬取博客园首页文章列表 - Peerless1029</title>
<link>http://www.cnblogs.com/peerless1029/p/11946652.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/peerless1029/p/11946652.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;  &lt;strong&gt;网络爬虫&lt;/strong&gt;（又称为网页蜘蛛，网络机器人，在FOAF社区中间，更经常的称为网页追逐者），是一种按照一定的规则，自动地抓取万维网信息的程序或者脚本。另外一些不常使用的名字还有蚂蚁、自动索引、模拟程序或者蠕虫。&lt;/p&gt;
&lt;p&gt;  我们可以使用网络爬虫对数据信息进行自动采集，比如应用于搜索引擎中对站点进行爬取收录，应用于数据分析与挖掘中对数据进行采集，应用于金融分析中对金融数据进行采集，除此之外，还可以将网络爬虫应用于舆情监测与分析、目标客户数据的收集等各个领域。&lt;/p&gt;
&lt;h2 id=&quot;网络爬虫分类&quot;&gt;1、网络爬虫分类&lt;/h2&gt;
&lt;p&gt;  网络爬虫按照系统结构和实现技术，大致可以分为以下几种类型：&lt;strong&gt;通用网络爬虫&lt;/strong&gt;（General Purpose Web Crawler）、&lt;strong&gt;聚焦网络爬虫&lt;/strong&gt;（Focused Web Crawler）、&lt;strong&gt;增量式网络爬虫&lt;/strong&gt;（Incremental Web Crawler）、&lt;strong&gt;深层网络爬虫&lt;/strong&gt;（Deep Web Crawler）。 实际的网络爬虫系统通常是几种爬虫技术相结合实现的，下面分别对这几种爬虫加以简单的介绍。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.1、通用网络爬虫&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;又称全网爬虫（Scalable Web Crawler），爬行对象从一些种子URL扩充到整个Web，主要为门户站点搜索引擎和大型Web服务提供商采集数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;1.2、聚焦网络爬虫&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;又称主题网络爬虫（Topical Crawler），是指选择性地爬行那些与预先定义好的主题相关页面的网络爬虫。 和通用网络爬虫相比，聚焦爬虫只需要爬行与主题相关的页面，极大地节省了硬件和网络资源，保存的页面也由于数量少而更新快，还可以很好地满足一些特定人群对特定领域信息的需求。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;1.3、增量式网络爬虫&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;指对已下载网页采取增量式更新和只爬行新产生的或者已经发生变化网页的爬虫，它能够在一定程度上保证所爬行的页面是尽可能新的页面。。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;1.4、深层网络爬虫&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Web 页面按存在方式可以分为表层网页（Surface Web）和深层网页（Deep Web，也称 Invisible Web Pages 或 Hidden Web）。表层网页是指传统搜索引擎可以索引的页面，以超链接可以到达的静态网页为主构成的Web 页面。Deep Web是那些大部分内容不能通过静态链接获取的、隐藏在搜索表单后的，只有用户提交一些关键词才能获得的Web页面。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;创建一个简单的爬虫应用&quot;&gt;2、创建一个简单的爬虫应用&lt;/h2&gt;
&lt;p&gt;  对以上几种爬虫进行简单的了解后，下面来实现一个简单的爬虫小应用吧。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.1、实现目标&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;提到爬虫，大概率会想到大数据，从而又联想到&lt;strong&gt;Python&lt;/strong&gt;，百度了以下，Python做爬虫的确实比较多。由于自己主要做前端开发这块，相对来说，JavaScript更熟练简单一点。实现一个小目标，那就&lt;strong&gt;用NodeJS来对&lt;a href=&quot;https://www.cnblogs.com/&quot;&gt;博客园&lt;/a&gt;（自己常用的一个开发者网站）首页文章列表进行爬取，然后写入到本地JSON文件中&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.2、环境搭建&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;NodeJS&lt;/strong&gt;: 电脑要安装NodeJS,未安装的要去&lt;a href=&quot;http://NodeJS.cn/&quot;&gt;官网&lt;/a&gt;下载安装。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;npm&lt;/strong&gt;: NodeJS包管理工具，随NodeJS一起安装的。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;em&gt;NodeJS安装完毕，打开命令行，可用&lt;code&gt;node -v&lt;/code&gt;检测NodeJS是否安装成功，可用&lt;code&gt;npm -v&lt;/code&gt;检测NodeJS是否安装成功，安装成功应该会打印以下信息（因版本不同而异）：&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1103967/201911/1103967-20191128015110746-194208950.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.3、具体实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2.3.1、安装依赖包&lt;/p&gt;
&lt;p&gt;在目录下执行&lt;code&gt;npm install superagent cheerio --save-dev&lt;/code&gt;安装superagent，cheerio这两个依赖包。创建一个&lt;strong&gt;crawler.js&lt;/strong&gt;文件。&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;superagent&lt;/strong&gt;：&lt;a href=&quot;http://visionmedia.github.io/superagent&quot;&gt;SuperAgent&lt;/a&gt;是一个轻量级、灵活的、易读的、低学习曲线的客户端请求代理模块，使用在NodeJS环境中。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;cheerio&lt;/strong&gt;: &lt;a href=&quot;https://cheerio.js.org/&quot;&gt;cheerio&lt;/a&gt;是专为服务器设计的核心jQuery的快速，灵活和精益实现。它可以像jquery一样操作字符串。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;// 导入依赖包
const http       = require(&quot;http&quot;);
const path       = require(&quot;path&quot;);
const url        = require(&quot;url&quot;);
const fs         = require(&quot;fs&quot;);
const superagent = require(&quot;superagent&quot;);
const cheerio    = require(&quot;cheerio&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.3.2、爬取数据&lt;/p&gt;
&lt;p&gt;接着get请求页面，在获取到页面内容后，对返回的DOM根据自己想要的数据进行解析取值，最后把处理后的结果JSON转译成字符串保存到本地。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//爬取页面地址
const pageUrl=&quot;https://www.cnblogs.com/&quot;;

// 解码字符串
function unescapeString(str){
    if(!str){
        return ''
    }else{
        return unescape(str.replace(/&amp;amp;#x/g,'%u').replace(/;/g,''));
    }
}

// 抓取数据
function fetchData(){
    console.log('爬取数据时间节点：',new Date());
    superagent.get(pageUrl).end((error,response)=&amp;gt;{
        // 页面文档数据
        let content=response.text;
        if(content){
            console.log('获取数据成功');
        }
        // 定义一个空数组来接收数据
        let result=[];
        let $=cheerio.load(content);
        let postList=$(&quot;#main #post_list .post_item&quot;);
        postList.each((index,value)=&amp;gt;{
            let titleLnk=$(value).find('a.titlelnk');
            let itemFoot=$(value).find('.post_item_foot');

            let title=titleLnk.html(); //标题
            let href=titleLnk.attr('href'); //链接
            let author=itemFoot.find('a.lightblue').html(); //作者
            let headLogo=$(value).find('.post_item_summary a img').attr('src'); //头像
            let summary=$(value).find('.post_item_summary').text(); //简介
            let postedTime=itemFoot.text().split('发布于 ')[1].substr(0,16); //发布时间
            let readNum=itemFoot.text().split('阅读')[1]; //阅读量
            readNum=readNum.substr(1,readNum.length-1);

            title=unescapeString(title);
            href=unescapeString(href);
            author=unescapeString(author);
            headLogo=unescapeString(headLogo);
            summary=unescapeString(summary);
            postedTime=unescapeString(postedTime);
            readNum=unescapeString(readNum);

            result.push({
                index,
                title,
                href,
                author,
                headLogo,
                summary,
                postedTime,
                readNum
            });
        });

        // 数组转换为字符串
        result=JSON.stringify(result);

        // 写入本地cnblogs.json文件中
        fs.writeFile(&quot;cnblogs.json&quot;,result,&quot;utf-8&quot;,(err)=&amp;gt;{
            // 监听错误，如正常输出，则打印null
            if(!err){
                console.log('写入数据成功');
            }
        });
    });
}

fetchData();&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;执行优化&quot;&gt;3、执行优化&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;3.1、生成结果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在项目目录下打开命令行输入&lt;code&gt;node crawler.js&lt;/code&gt;,&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1103967/201911/1103967-20191128015125771-1722058187.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;会发现目录中会创建一个&lt;code&gt;cnblogs.json&lt;/code&gt;文件，打开文件如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1103967/201911/1103967-20191128015134445-1011911802.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;打开&lt;a href=&quot;https://www.cnblogs.com/&quot;&gt;博客园&lt;/a&gt;首页对比下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1103967/201911/1103967-20191128015148003-506008535.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;发现成功爬到了首页想要的文章列表&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.2、定时爬取&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;发现只有每执行一次才能获取到数据，价格定时器，让它每隔五分钟自动爬取一次，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;···
// 每隔5分钟请求一次
setInterval(()=&amp;gt;{
    fetchData()
},5*60*1000);
···&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;4、总结&lt;/h2&gt;
&lt;p&gt;  网络爬虫的应用远远不止这些，以上只是对网络爬虫做了一个简单的介绍，并实现了一个小demo，如有不足，欢迎指正。&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;a href=&quot;https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/5162711&quot;&gt;https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/5162711&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/zw0Pi8G5C1x/article/details/89078072&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/zw0Pi8G5C1x/article/details/89078072&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.jianshu.com/p/1432e0f29abd&quot; class=&quot;uri&quot;&gt;https://www.jianshu.com/p/1432e0f29abd&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.jianshu.com/p/843ade9bf6df&quot; class=&quot;uri&quot;&gt;https://www.jianshu.com/p/843ade9bf6df&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 28 Nov 2019 00:39:00 +0000</pubDate>
<dc:creator>Peerless1029</dc:creator>
<og:description>前言 &amp;emsp;&amp;emsp; 网络爬虫 （又称为网页蜘蛛，网络机器人，在FOAF社区中间，更经常的称为网页追逐者），是一种按照一定的规则，自动地抓取万维网信息的程序或者脚本。另外一些不常使用的名字还</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/peerless1029/p/11946652.html</dc:identifier>
</item>
<item>
<title>Spring框架AOP学习总结（下） - 宜春</title>
<link>http://www.cnblogs.com/yichunguo/p/11939547.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yichunguo/p/11939547.html</guid>
<description>&lt;p&gt;@&lt;br/&gt;在&lt;a href=&quot;https://blog.csdn.net/qq_44543508/article/details/98600615&quot;&gt;Spring框架学习一&lt;/a&gt;中主要讲的是一些Spring的概述、Spring工厂、Spring属性注入以及IOC入门，其中最重要的是IOC，上一篇中IOC大概讲的小结一下：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/27/16eaa393f31d8365?w=672&amp;amp;h=575&amp;amp;f=png&amp;amp;s=64910&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后呢这一篇中主要讲一下Spring中除了IOC之外的另一个重要的核心：AOP，在Spring中IOC也好，AOP也好，都必须会二者的XML开发以及注解开发，也就是说&lt;span&gt;&lt;strong&gt;IOC和AOP的XML开发以及注解开发都要掌握&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;aop-的概述&quot;&gt;1、 AOP 的概述&lt;/h2&gt;
&lt;p&gt;从专业的角度来讲（千万不要问我有多专业，度娘是我表锅不对是表嫂QAQ）：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从通俗易懂且不失风趣的角度来讲：（来自武哥文章&lt;a href=&quot;https://blog.csdn.net/eson_15/article/details/51090040&quot;&gt;谈谈Spring中的IOC和AOP概念&lt;/a&gt;）&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;面向切面编程的目标就是分离关注点。什么是关注点呢？就是你要做的事，就是关注点。假如你是个公子哥，没啥人生目标，天天就是衣来伸手，饭来张口，整天只知道玩一件事！那么，每天你一睁眼，就光想着吃完饭就去玩（你必须要做的事），但是在玩之前，你还需要穿衣服、穿鞋子、叠好被子、做饭等等等等事情，这些事情就是你的关注点，但是你只想吃饭然后玩，那么怎么办呢？这些事情通通交给别人去干。在你走到饭桌之前，有一个专门的仆人A帮你穿衣服，仆人B帮你穿鞋子，仆人C帮你叠好被子，仆人C帮你做饭，然后你就开始吃饭、去玩（这就是你一天的正事），你干完你的正事之后，回来，然后一系列仆人又开始帮你干这个干那个，然后一天就结束了！&lt;br/&gt;AOP的好处就是你只需要干你的正事，其它事情别人帮你干。也许有一天，你想裸奔，不想穿衣服，那么你把仆人A解雇就是了！也许有一天，出门之前你还想带点钱，那么你再雇一个仆人D专门帮你干取钱的活！这就是AOP。每个人各司其职，灵活组合，达到一种可配置的、可插拔的程序结构。&lt;br/&gt;从Spring的角度看，AOP最大的用途就在于提供了事务管理的能力。事务管理就是一个关注点，你的正事就是去访问数据库，而你不想管事务（太烦），所以，Spring在你访问数据库之前，自动帮你开启事务，当你访问数据库结束之后，自动帮你提交/回滚事务！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;为什么学习-aop&quot;&gt;1、1 为什么学习 AOP&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Spring 的 AOP 的由来&lt;/strong&gt;:AOP 最早由 AOP 联盟的组织提出的,制定了一套规范.Spring 将 AOP 思想引入到框架中,必须遵守 AOP 联盟的规范.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Aop解决实际开发中的一些问题:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;AOP 解决 OOP 中遇到的一些问题.是 OOP 的延续和扩展.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;对程序进行增强:不修改源码的情况下：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;AOP 可以进行权限校验,日志记录,性能监控,事务控制.&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;aop底层实现-代理机制了解&quot;&gt;1、2 AOP底层实现: 代理机制（了解）&lt;/h4&gt;
&lt;p&gt;Spring 的 AOP 的底层用到两种代理机制：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;JDK 的动态代理 :针对实现了接口的类产生代理.&lt;/li&gt;
&lt;li&gt;Cglib 的动态代理 :针对没有实现接口的类产生代理. 应用的是底层的字节码增强的技术 生成当前类的子类对象&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;spring底层会完成自动代理，实现了接口的类默认使用的是JDK 的动态代理，相反的，没有实现接口的类默认使用的是Cglib 的动态代理&lt;/span&gt; ，底层代码可以不懂但这个概念一定要知道，不然会被鄙视的，O(∩_∩)O哈哈~，下面是底层代码，有兴趣的可以了解了解。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JDK 动态代理增强一个类中方法:&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;public class MyJDKProxy implements InvocationHandler {
        private UserDao userDao;

        public MyJDKProxy(UserDao userDao) {
            this.userDao = userDao;
        }

        // 编写工具方法：生成代理：
        public UserDao createProxy() {
            UserDao userDaoProxy = (UserDao) Proxy.newProxyInstance(userDao
                    .getClass().getClassLoader(), userDao.getClass()
                    .getInterfaces(), this);
            return userDaoProxy;
        }

        @Override
        public Object invoke(Object proxy, Method method, Object[] args)
                throws Throwable {
            if (&quot;save&quot;.equals(method.getName())) {
                System.out.println(&quot;权限校验================&quot;);
            }
            return method.invoke(userDao, args);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Cglib 动态代理增强一个类中的方法:&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;public class MyCglibProxy implements MethodInterceptor {
        private CustomerDao customerDao;

        public MyCglibProxy(CustomerDao customerDao) {
            this.customerDao = customerDao;
        }

        // 生成代理的方法:
        public CustomerDao createProxy() {
            // 创建 Cglib 的核心类:
            Enhancer enhancer = new Enhancer();
            // 设置父类:
            enhancer.setSuperclass(CustomerDao.class);
            // 设置回调:
            enhancer.setCallback(this);
            // 生成代理：
            CustomerDao customerDaoProxy = (CustomerDao) enhancer.create();
            return customerDaoProxy;
        }

        @Override
        public Object intercept(Object proxy, Method method, Object[] args,
                MethodProxy methodProxy) throws Throwable {
            if (&quot;delete&quot;.equals(method.getName())) {
                Object obj = methodProxy.invokeSuper(proxy, args);
                System.out.println(&quot;日志记录================&quot;);
                return obj;
            }
            return methodProxy.invokeSuper(proxy, args);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;spring-基于aspectj-进行-aop-的开发入门xml-的方式&quot;&gt;2、 Spring 基于AspectJ 进行 AOP 的开发入门（XML 的方式）：&lt;/h2&gt;
&lt;p&gt;首先，Spring为什么不直接进行Spring的AOP开发呢，而要基于Aspectj呢，是因为，Spring自己的AOP开发实现方式（传统的AOP开发）繁琐且复杂，效率极低，于是传统的AOP开发基本上弃用了，相反Aspectj的AOP开发效率高，所以AOP开发一般是Spring 的基于 AspectJ 的 AOP 开发。&lt;/p&gt;
&lt;h4 id=&quot;aop-的开发中的相关术语&quot;&gt;2.1 AOP 的开发中的相关术语:&lt;/h4&gt;
&lt;p&gt;Aop是一种非常高深的思想，当然会有非常专业的相关术语了（这弯绕的，你打几分？）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;从专业的角度角度概述定义(相对来说比较枯燥不易理解)：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt;Joinpoint(连接点)&lt;/span&gt;:所谓连接点是指那些被拦截到的点。在 spring 中,这些点指的是方法,因为 spring 只&lt;br/&gt;支持方法类型的连接点.&lt;br/&gt;&lt;span&gt;Pointcut(切入点)&lt;/span&gt;:所谓切入点是指我们要对哪些 Joinpoint 进行拦截的定义.&lt;br/&gt;&lt;span&gt;Advice(通知/增强)&lt;/span&gt;:所谓通知是指拦截到 Joinpoint 之后所要做的事情就是通知.通知分为前置通知,后置&lt;br/&gt;通知,异常通知,最终通知,环绕通知(切面要完成的功能)&lt;br/&gt;&lt;span&gt;Introduction(引介)&lt;/span&gt;:引介是一种特殊的通知在不修改类代码的前提下, Introduction 可以在运行期为类&lt;br/&gt;动态地添加一些方法或 Field.&lt;br/&gt;&lt;span&gt;Target(目标对象)&lt;/span&gt;:代理的目标对象&lt;br/&gt;&lt;span&gt;Weaving(织入)&lt;/span&gt;:是指把增强应用到目标对象来创建新的代理对象的过程.&lt;br/&gt;spring 采用动态代理织入，而 AspectJ 采用编译期织入和类装在期织入&lt;br/&gt;&lt;span&gt;Proxy（代理）&lt;/span&gt;:一个类被 AOP 织入增强后，就产生一个结果代理类&lt;br/&gt;&lt;span&gt;Aspect(切面)&lt;/span&gt;: 是切入点和通知（引介）的结合&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;基于专业的角度实例分析&lt;/strong&gt;(相对来说易理解，什么？画质差？咳咳...1080p蓝光画质...哎哎哎..大哥..别打...别打...别打脸)：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/27/16eaa393f36fc98a?w=1392&amp;amp;h=646&amp;amp;f=png&amp;amp;s=629047&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;引入相应的-jar-包&quot;&gt;2.2引入相应的 jar 包&lt;/h4&gt;
&lt;p&gt;引入jar包：基础六个jar包、AOP联盟jar包、spring的AOPjar包、aspectJ的jar包、spring整合aspectj的jar包&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;spring 的传统 AOP 的开发的包&lt;/strong&gt;：&lt;br/&gt;spring-aop-4.2.4.RELEASE.jar&lt;br/&gt;com.springsource.org.aopalliance-1.0.0.jar&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;aspectJ 的开发包&lt;/strong&gt;:&lt;br/&gt;com.springsource.org.aspectj.weaver-1.6.8.RELEASE.jar&lt;br/&gt;spring-aspects-4.2.4.RELEASE.jar&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/27/16eaa393f35fc266?w=1531&amp;amp;h=516&amp;amp;f=png&amp;amp;s=355088&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;引入-spring-的配置文件&quot;&gt;2.3 引入 Spring 的配置文件&lt;/h4&gt;
&lt;p&gt;引入 AOP 约束:&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt; &amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;
http://www.springframework.org/schema/beans 
http://www.springframework.org/schema/beans/spring-beans.xsd
http://www.springframework.org/schema/aop 
http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&amp;gt;
&amp;lt;/beans&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;编写目标类&quot;&gt;2.4 编写目标类&lt;/h4&gt;
&lt;p&gt;创建接口和类:&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;    public interface OrderDao {
        public void save();

        public void update();

        public void delete();

        public void find();
    }

    public class OrderDaoImpl implements OrderDao {
        @Override
        public void save() {
            System.out.println(&quot;保存订单...&quot;);
        }

        @Override
        public void update() {
            System.out.println(&quot;修改订单...&quot;);
        }

        @Override
        public void delete() {
            System.out.println(&quot;删除订单...&quot;);
        }

        @Override
        public void find() {
            System.out.println(&quot;查询订单...&quot;);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;目标类的xml配置&quot;&gt;2.5 目标类的XML配置&lt;/h4&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;&amp;lt;!-- 目标类配置:被增强的类 --&amp;gt; 
&amp;lt;bean id=&quot;orderDao&quot; class=&quot;com.gx.spring.demo3.OrderDaoImpl&quot;&amp;gt;&amp;lt;/bean&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;整合-junit-单元测试&quot;&gt;2.6 整合 Junit 单元测试&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;前提：引入 &lt;strong&gt;spring-test.jar&lt;/strong&gt; 测试的jar包，整合 Junit 单元测试之后就不需要每次都重复注册工厂，只要固定格式在测试类上写两个注解，需要的属性直接注入，之后只关心自己的测试类即可&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;//固定注解写法（前提：引入 spring-test.jar 测试的jar包）
    @RunWith(SpringJUnit4ClassRunner.class)
    @ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)
    public class SpringDemo3 {
        @Resource(name = &quot;orderDao&quot;)  //需要的属性直接注入（前提：引入 spring-test.jar 测试的jar包）
        private OrderDao orderDao;

        @Test
        public void demo1() {
            orderDao.save();
            orderDao.update();
            orderDao.delete();
            orderDao.find();
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行demo出现如下效果：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/27/16eaa393f3cfd9de?w=647&amp;amp;h=196&amp;amp;f=png&amp;amp;s=86233&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;通知类型&quot;&gt;2.7 通知类型&lt;/h4&gt;
&lt;p&gt;到这里，就需要需要对通知类型了解一下（前三者常用）：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;前置通知&lt;/strong&gt; ：在目标方法执行之前执行.&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/27/16eaa393f3cb87fa?w=980&amp;amp;h=166&amp;amp;f=png&amp;amp;s=91938&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;strong&gt;后置通知&lt;/strong&gt; ：在目标方法执行之后执行&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/27/16eaa393f477ebea?w=1009&amp;amp;h=215&amp;amp;f=png&amp;amp;s=128729&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;span&gt;如果要获得后置通知中的返回值，必须注意的是：&lt;/span&gt;&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/27/16eaa393f486335e?w=1852&amp;amp;h=427&amp;amp;f=png&amp;amp;s=382060&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;strong&gt;环绕通知&lt;/strong&gt; ：在目标方法执行前和执行后执行&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/27/16eaa393f48a4f56?w=903&amp;amp;h=227&amp;amp;f=png&amp;amp;s=138188&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;strong&gt;异常抛出通知&lt;/strong&gt;：在目标方法执行出现 异常的时候 执行&lt;br/&gt;&lt;strong&gt;最终通知&lt;/strong&gt; ：无论目标方法是否出现异常 最终通知都会 执行.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通知类型XML配置&lt;/strong&gt;：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/27/16eaa393f473139d?w=1387&amp;amp;h=590&amp;amp;f=png&amp;amp;s=588440&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/27/16eaa393f49eacf4?w=1142&amp;amp;h=77&amp;amp;f=png&amp;amp;s=53774&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;切入点表达式&quot;&gt;2.8 切入点表达式&lt;/h4&gt;
&lt;p&gt;execution(表达式)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;表达式 : [方法访问修饰符] 方法返回值 包名.类名.方法名(方法的参数)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;切入点表达式所以就是execution( [方法访问修饰符] 方法返回值 包名.类名.方法名(方法的参数))&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中 [ ] 中的方法访问修饰符可有可无&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;切入点表达式各类型例子：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;public * com.gx.spring.dao. * .*(..)
com.gx.spring.dao.*.*(..)
com.gx.spring.dao.UserDao+.*(..)
com.gx.spring.dao..*.*(..)&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;编写一个切面类&quot;&gt;2.9 编写一个切面类&lt;/h4&gt;
&lt;p&gt;好了，了解了通知类型以及切入点表达式之后就可以来 编写一个切面类玩起来了QAQ&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;public class MyAspectXml {
    // 前置增强
    public void before(){
       System.out.println(&quot;前置增强===========&quot;);
} }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;配置完成增强&quot;&gt;2.10 配置完成增强&lt;/h4&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;&amp;lt;!-- 配置切面类 --&amp;gt; 
&amp;lt;bean id=&quot;myAspectXml&quot; class=&quot;com.gx.spring.demo3.MyAspectXml&quot;&amp;gt;&amp;lt;/bean&amp;gt;
&amp;lt;!-- 进行 aop 的配置 --&amp;gt; 
&amp;lt;aop:config&amp;gt;
&amp;lt;!-- 配置切入点表达式:哪些类的哪些方法需要进行增强 --&amp;gt;
 &amp;lt;aop:pointcut expression=&quot;execution(* com.gx.spring.demo3.OrderDao.save(..))&quot; id=&quot;pointcut1&quot;/&amp;gt;
&amp;lt;!-- 配置切面 --&amp;gt; 
&amp;lt;aop:aspect ref=&quot;myAspectXml&quot;&amp;gt; 
    &amp;lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;pointcut1&quot;/&amp;gt;
&amp;lt;/aop:aspect&amp;gt;
&amp;lt;/aop:config&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要注意的点我都规划出来了（不用夸我，我知道我长得帅QnQ）&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/27/16eaa393f492ad70?w=1770&amp;amp;h=773&amp;amp;f=png&amp;amp;s=693727&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;其他的增强的配置&quot;&gt;2.11 其他的增强的配置：&lt;/h4&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;&amp;lt;!-- 配置切面类 --&amp;gt;
 &amp;lt;bean id=&quot;myAspectXml&quot; class=&quot;com.gx.demo3.MyAspectXml&quot;&amp;gt;&amp;lt;/bean&amp;gt;
    &amp;lt;!-- 进行 aop 的配置 --&amp;gt;
 &amp;lt;aop:config&amp;gt;
    &amp;lt;!-- 配置切入点表达式:哪些类的哪些方法需要进行增强 --&amp;gt;
     &amp;lt;aop:pointcut expression=&quot;execution(* com.gx.spring.demo3.*Dao.save(..))&quot; id=&quot;pointcut1&quot;/&amp;gt;
     &amp;lt;aop:pointcut expression=&quot;execution(* com.gx.spring.demo3.*Dao.delete(..))&quot; id=&quot;pointcut2&quot;/&amp;gt;
     &amp;lt;aop:pointcut expression=&quot;execution(* com.gx.spring.demo3.*Dao.update(..))&quot; id=&quot;pointcut3&quot;/&amp;gt;
     &amp;lt;aop:pointcut expression=&quot;execution(* com.gx.spring.demo3.*Dao.find(..))&quot; id=&quot;pointcut4&quot;/&amp;gt;
    &amp;lt;!-- 配置切面 --&amp;gt; 
    &amp;lt;aop:aspect ref=&quot;myAspectXml&quot;&amp;gt;
       &amp;lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;pointcut1&quot;/&amp;gt;
       &amp;lt;aop:after-returning method=&quot;afterReturing&quot;pointcut-ref=&quot;pointcut2&quot;/&amp;gt;
       &amp;lt;aop:around method=&quot;around&quot; pointcut-ref=&quot;pointcut3&quot;/&amp;gt;
       &amp;lt;aop:after-throwing method=&quot;afterThrowing&quot; pointcut-ref=&quot;pointcut4&quot;/&amp;gt;
       &amp;lt;aop:after method=&quot;after&quot; pointcut-ref=&quot;pointcut4&quot;/&amp;gt;
    &amp;lt;/aop:aspect&amp;gt;
&amp;lt;/aop:config&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;spring-基于aspectj-进行-aop-的开发入门注解的方式&quot;&gt;3、Spring 基于AspectJ 进行 AOP 的开发入门（注解的方式）：&lt;/h2&gt;
&lt;h4 id=&quot;创建项目引入jar包&quot;&gt;3.1创建项目，引入jar包&lt;/h4&gt;
&lt;p&gt;引入的jar包如下：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/27/16eaa393f76255d1?w=532&amp;amp;h=277&amp;amp;f=png&amp;amp;s=86176&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;引入配置文件&quot;&gt;3.2引入配置文件&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/27/16eaa3941ebc886e?w=855&amp;amp;h=385&amp;amp;f=png&amp;amp;s=353687&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;编写目标类并配置&quot;&gt;3.3编写目标类并配置&lt;/h4&gt;
&lt;p&gt;编写目标类：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;package com.gx.spring.demo1;

public class OrderDao {

    public void save(){
        System.out.println(&quot;保存订单...&quot;);
    }
    public void update(){
        System.out.println(&quot;修改订单...&quot;);
    }
    public String delete(){
        System.out.println(&quot;删除订单...&quot;);
        return &quot;鄢寒&quot;;
    }
    public void find(){
        System.out.println(&quot;查询订单...&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;XML配置：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;&amp;lt;!-- 配置目标类 --&amp;gt;
    &amp;lt;bean id=&quot;orderDao&quot; class=&quot;com.gx.spring.demo1.OrderDao&quot;&amp;gt;

    &amp;lt;/bean&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;编写切面类并配置&quot;&gt;3.4编写切面类并配置&lt;/h4&gt;
&lt;p&gt;编写切面类&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;package com.gx.spring.demo1;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.After;
import org.aspectj.lang.annotation.AfterReturning;
import org.aspectj.lang.annotation.AfterThrowing;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;

/**
 * 切面类：注解的切面类
 * @author jt
 */
public class MyAspectAnno {

    public void before(){
        System.out.println(&quot;前置增强===========&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;XML配置：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;&amp;lt;!-- 配置切面类 --&amp;gt;
    &amp;lt;bean id=&quot;myAspect&quot; class=&quot;com.gx.spring.demo1.MyAspectAnno&quot;&amp;gt;
    
    &amp;lt;/bean&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;使用注解的aop对象目标类进行增强&quot;&gt;3.5使用注解的AOP对象目标类进行增强&lt;/h4&gt;
&lt;p&gt;1、在配置文件中打开注解的AOP开发&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;&amp;lt;!-- 在配置文件中开启注解的AOP的开发 --&amp;gt;
    &amp;lt;aop:aspectj-autoproxy/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、在切面类上使用注解&lt;br/&gt;在类上使用@Aspect注解代表这是一个切面类&lt;br/&gt;在方法上注入属性@Before（execution表达式）代表前置增强&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;@Aspect
public class MyAspectAnno {

    @Before(value=&quot;execution(* com.gx.spring.demo1.OrderDao.save(..))&quot;)
    public void before(){
        System.out.println(&quot;前置增强===========&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;编写测试类&quot;&gt;3.6编写测试类&lt;/h4&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;package com.gx.spring.demo1;

import javax.annotation.Resource;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

/**
 * Spring的AOP的注解开发
 *
 */
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)
public class SpringDemo1 {
    @Resource(name=&quot;orderDao&quot;)
    private static OrderDao orderDao;
    
    public static void main(String[] args) {
        
            orderDao.save();
            orderDao.update();
            orderDao.delete();
            orderDao.find();
        
    }
    
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试结果：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/27/16eaa3942073b46a?w=391&amp;amp;h=52&amp;amp;f=png&amp;amp;s=18095&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;spring的注解的aop的通知类型&quot;&gt;4、Spring的注解的AOP的通知类型&lt;/h2&gt;
&lt;h4 id=&quot;before-前置通知&quot;&gt;4.1@Before ：前置通知&lt;/h4&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;@Aspect
public class MyAspectAnno {

    @Before(value=&quot;execution(* com.gx.spring.demo1.OrderDao.save(..))&quot;)
    public void before(){
        System.out.println(&quot;前置增强===========&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;afterreturning-后置通知&quot;&gt;4.2@AfterReturning ：后置通知&lt;/h4&gt;
&lt;p&gt;后置通知可以获取方法返回值&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// 后置通知:
    @AfterReturning(value=&quot;execution(* com.gx.spring.demo1.OrderDao.save(..))&quot;)
    public void afterReturning(Object result){
        System.out.println(&quot;后置增强===========&quot;+result);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;借用一下XML方式的图，意思意思啦，意思还是那个意思QnQ&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/27/16eaa393f486335e?w=1852&amp;amp;h=427&amp;amp;f=png&amp;amp;s=382060&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;around-环绕通知&quot;&gt;4.3@Around ：环绕通知&lt;/h4&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// 环绕通知:
    @Around(value=&quot;execution(* com.gx.spring.demo1.OrderDao.save(..))&quot;)
    public Object around(ProceedingJoinPoint joinPoint) throws Throwable{
        System.out.println(&quot;环绕前增强==========&quot;);
        Object obj  = joinPoint.proceed();
        System.out.println(&quot;环绕后增强==========&quot;);
        return obj;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;afterthrowing-异常抛出通知&quot;&gt;4.4@AfterThrowing ：异常抛出通知&lt;/h4&gt;
&lt;p&gt;测试前记得制造出个异常qnq&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// 异常抛出通知:
    @AfterThrowing(value=&quot;execution(* com.gx.spring.demo1.OrderDao.save(..))&quot; throwing=&quot;e&quot;)
    public void afterThrowing(Throwable e){
        System.out.println(&quot;异常抛出增强=========&quot;+e.getMessage());
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;after-最终通知&quot;&gt;4.5@After ：最终通知&lt;/h4&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// 最终通知
    @After(value=&quot;execution(* com.gx.spring.demo1.OrderDao.save(..))&quot;)
    public void after(){
        System.out.println(&quot;最终增强============&quot;);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;spring的注解的aop的切入点的配置&quot;&gt;5、Spring的注解的AOP的切入点的配置&lt;/h2&gt;
&lt;p&gt;首先，我们发现在Spring 基于AspectJ 进行 AOP 的开发入门（注解的方式）的过程中如果方法过多，通知过多并且作用于一个方法，需求一改变就需要更改相应的源代码，为了更好的维护，于是有了AOP的切入点的配置，AOP的切入点的配置能很好地决绝改问题！只需要管理AOP的切入点的配置即可！&lt;/p&gt;
&lt;p&gt;具体代码如下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;package com.gx.spring.demo1;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.After;
import org.aspectj.lang.annotation.AfterReturning;
import org.aspectj.lang.annotation.AfterThrowing;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;

/**
 * 切面类：注解的切面类
 * @author jt
 */
@Aspect
public class MyAspectAnno {
    // 前置通知:
    @Before(value=&quot;MyAspectAnno.pointcut2()&quot;)
    public void before(){
        System.out.println(&quot;前置增强===========&quot;);
    }
    
    // 后置通知:
    @AfterReturning(value=&quot;MyAspectAnno.pointcut4()&quot;,returning=&quot;result&quot;)
    public void afterReturning(Object result){
        System.out.println(&quot;后置增强===========&quot;+result);
    }
    
    // 环绕通知:
    @Around(value=&quot;MyAspectAnno.pointcut3()&quot;)
    public Object around(ProceedingJoinPoint joinPoint) throws Throwable{
        System.out.println(&quot;环绕前增强==========&quot;);
        Object obj  = joinPoint.proceed();
        System.out.println(&quot;环绕后增强==========&quot;);
        return obj;
    }
    
    // 异常抛出通知:
    @AfterThrowing(value=&quot;MyAspectAnno.pointcut1()&quot;,throwing=&quot;e&quot;)
    public void afterThrowing(Throwable e){
        System.out.println(&quot;异常抛出增强=========&quot;+e.getMessage());
    }
    
    // 最终通知
    @After(value=&quot;MyAspectAnno.pointcut1()&quot;)
    public void after(){
        System.out.println(&quot;最终增强============&quot;);
    }
    
    // 切入点注解：
    @Pointcut(value=&quot;execution(* com.gx.spring.demo1.OrderDao.find(..))&quot;)
    private void pointcut1(){}
    @Pointcut(value=&quot;execution(* com.gx.spring.demo1.OrderDao.save(..))&quot;)
    private void pointcut2(){}
    @Pointcut(value=&quot;execution(* com.gx.spring.demo1.OrderDao.update(..))&quot;)
    private void pointcut3(){}
    @Pointcut(value=&quot;execution(* com.gx.spring.demo1.OrderDao.delete(..))&quot;)
    private void pointcut4(){}
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;如果本文对你有一点点帮助，那么请点个赞呗，谢谢~&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;最后，若有不足或者不正之处，欢迎指正批评，感激不尽！如果有疑问欢迎留言，绝对第一时间回复！&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;欢迎各位关注我的公众号，一起探讨技术，向往技术，追求技术，说好了来了就是盆友喔...&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/25/16ea262c1c0932c5?w=1430&amp;amp;h=544&amp;amp;f=png&amp;amp;s=499085&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 28 Nov 2019 00:20:00 +0000</pubDate>
<dc:creator>宜春</dc:creator>
<og:description>@[toc] 在 'Spring框架学习一' 中主要讲的是一些Spring的概述、Spring工厂、Spring属性注入以及IOC入门，其中最重要的是IOC，上一篇中IOC大概讲的小结一下： 然后呢这</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yichunguo/p/11939547.html</dc:identifier>
</item>
<item>
<title>Head First设计模式——适配器和外观模式 - Spring2Sun</title>
<link>http://www.cnblogs.com/SunSpring/p/11946631.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/SunSpring/p/11946631.html</guid>
<description>&lt;p&gt;前言：为什么要一次讲解这两个模式，说点骚话：因为比较简单(*^_^*)，其实是他们两个有相似和有时候我们容易搞混概念。&lt;/p&gt;
&lt;p&gt;讲到这两个设计模式与另外一个“装饰者模式”也有相似，他们三个按照结构模式分类都属于“结构性模式”，所有我们接下来就来看什么是适配器模式和外观模式。&lt;/p&gt;
&lt;p&gt;另外装饰模式可以看我的另一篇博文→&lt;span&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/SunSpring/p/11735959.html&quot;&gt;&lt;span&gt;Head First设计模式——装饰者模式&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;一、适配器模式&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;适配器对应到我们现实生活中的例子，最典型的就是插头接口适配器，比如我们买的有些港版手机充电头是圆形三角插头，而大陆的三角电源插板插不进去港版的插头。&lt;/p&gt;
&lt;p&gt;这时候我们就会在某宝上买个转接头转换一下，而这个转接头就是&lt;strong&gt;适配器&lt;/strong&gt;，用它来适配港版手机充电头让他能够插入到我们的电源插板里面。&lt;/p&gt;
&lt;p&gt;在设计模式中这个适配器是什么，用程序如何表现，先让我举个栗子：我们有一只鸭子，一只鸡，我们如何通过适配器转换鸭和鸡。&lt;/p&gt;
&lt;p&gt;鸭子有很多种，我们定义一个鸭子的接口，然后以绿头鸭为例。关于这个绿头鸭在策略模式也有用到，可以看看我另一篇绿头鸭如何搅动策略模式→&lt;span&gt;&lt;a class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/SunSpring/p/10898575.html&quot;&gt;&lt;span&gt;Head First设计模式——策略模式&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
    public  interface Duck
    {
        //叫
        public void Quack();
        //飞
        public void Fly();
    }

    public class GreenDuck : Duck
    {
        public void Fly()
        {
            Console.WriteLine(&quot;绿头鸭，飞&quot;);
        }

        public void Quack()
        {
            Console.WriteLine(&quot;绿头鸭，呱呱叫&quot;);
        }
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　同样我们定义一个鸡的接口，和一只母鸡的类&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
    public  interface Chicken
    {
        //叫
        public void Gobble();
        //飞
        public void Fly();
    }

    public class Hen : Chicken
    {
       
        public void Gobble()
        {
            Console.WriteLine(&quot;母鸡，咯咯叫&quot;);
        }

        public void Fly()
        {
            Console.WriteLine(&quot;母鸡，飞&quot;);
        }

    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　鸭子和母鸡的叫声不一样，现在我们让母鸡来冒充鸭子，利用适配器模式如何做。 直接看代码吧&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
    /// &amp;lt;summary&amp;gt;
    /// 母鸡适配器
    /// 适配母鸡让它变成鸭子
    /// &amp;lt;/summary&amp;gt;
    public class HenAdapter : Duck
    {
        Chicken chicken;
        public HenAdapter(Chicken chicken)
        {
            this.chicken = chicken;
        }
        public void Quack()
        {
            //调用母鸡咯咯叫
            chicken.Gobble();
        }

        public void Fly()
        {
            //调用母鸡飞
            chicken.Fly();
        }

    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　测试母鸡适配器&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/993045/201911/993045-20191127235541821-1504989480.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上我们使用母鸡适配器将母鸡适配成了鸭子，鸭子也可以用适配器将鸭子适配成母鸡，适配器模式定义：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;适配器模式：将一个类的接口，装换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;与适配器看起来相似的装饰者模式是包装对象的行为或责任，装饰者被包装后可能会继续被包装，他们不装换接口，而适配器则一定会进行接口的转换。&lt;/p&gt;
&lt;p&gt;适配的工作是将一个接口转换成另外一个接口，虽然大多数适配器采取的例子都是让一个适配器包装一个被适配者，但是有时候我们需要让一个适配器包装多个被适配者。&lt;/p&gt;
&lt;p&gt;而这实际又涉及到另外一个模式，就是外观模式，我们常常将适配器模式和外观模式混为一谈，那接着就来讲解外观模式。&lt;/p&gt;
&lt;h2&gt;二、外观模式&lt;/h2&gt;
&lt;p&gt;外观模式以家庭影院为例，家庭影院有许多组件构成，比如：显示屏、DVD、音响、灯光等等。&lt;/p&gt;
&lt;p&gt;当我们要看电影的时候要打开显示屏，打开DVD,打开音响，关闭灯光等一系列动作，将这些动作写成类方法的调用&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
            Screen screen = new Screen();
            DVD dvd = new DVD();
            SoundEngineer sound = new SoundEngineer();
            Light light = new Light();

            screen.Down();
            dvd.PlayDVD();
            sound.TurnOn();
            light.TurnOff();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到每次我们要使用就要调用一篇这些方法，如果要关闭呢，我们也需要调用一篇。而我们正需要的就是一个外观：通过实现一个提供更合理的接口的外观类。&lt;/p&gt;
&lt;p&gt;还是看代码吧&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
 public class HomeThreaterFacade
    {
        Screen screen;
        DVD dvd;
        SoundEngineer sound;
        Light light;

        public HomeThreaterFacade(Screen screen, DVD dvd, SoundEngineer sound, Light light)
        {
            this.screen = screen;
            this.dvd = dvd;
            this.sound = sound;
            this.light = light;
        }

        public void WatchMovie()
        {
            Console.WriteLine(&quot;开始播放电影......&quot;);
            screen.Down();
            dvd.PlayDVD();
            sound.TurnOn();
            light.TurnOff();
        }
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于其他类比较简单就是一个打印输出，我就不列出来了，还有关闭方法同理也很简单就实现了。&lt;/p&gt;
&lt;p&gt;还是测试一下效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/993045/201911/993045-20191128004611931-1904946923.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;外观模式定义&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;外观模式：提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;外观模式遵循了一个设计原则&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;最少知识原则：之和你的密友谈话。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这个原则希望我们在设计中，不要让太多的类耦合在一起，免得修改系统中一部分，会影响其他部分。而外观模式让用户不用关心全部子系统组件，让客户变得简单有弹性。我们可以在不影响客户的情况下升级外观模式里的组件，而客户只有一个朋友，也就是外观模式。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;三、适配器模式与外观模式区别&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;从上面例子我们也许会觉得适配器和外观模式之间的差异在于：适配器包装一个类，而外观可以代表许多类&lt;/p&gt;
&lt;p&gt;但是实际它们的本质和作用并不是在于包装多少类，适配器模式将一个或多个接口变成客户期望的一个接口，我们一般适配一个类，但是特殊需求也可以适配多个类来提供一个接口。类是地，一个外观也可以只争对一个复杂接口的类提供简化接口。两中模式的差异在于他们的意图。适配器模式意图是将接口装换成不同接口，外观的意图是简化接口。&lt;/p&gt;
</description>
<pubDate>Wed, 27 Nov 2019 23:58:00 +0000</pubDate>
<dc:creator>Spring2Sun</dc:creator>
<og:description>前言：为什么要一次讲解这两个模式，说点骚话：因为比较简单(*^_^*)，其实是他们两个有相似和有时候我们容易搞混概念。 讲到这两个设计模式与另外一个“装饰者模式”也有相似，他们三个按照结构模式分类都属</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/SunSpring/p/11946631.html</dc:identifier>
</item>
<item>
<title>Spring Security之多次登录失败后账户锁定功能的实现 - 字母哥博客</title>
<link>http://www.cnblogs.com/zimug/p/11946727.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zimug/p/11946727.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1815316/201911/1815316-20191128074424898-859198529.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在上一次写的文章中，为大家说到了如何动态的从数据库加载用户、角色、权限信息，从而实现登录验证及授权。在实际的开发过程中，我们通常会有这样的一个需求：当用户多次登录失败的时候，我们应该将账户锁定，等待一定的时间之后才能再次进行登录操作。&lt;/p&gt;
&lt;h2 id=&quot;一基础知识回顾&quot;&gt;一、基础知识回顾&lt;/h2&gt;
&lt;p&gt;要实现多次登录失败账户锁定的功能，我们需要先回顾一下基础知识：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Spring Security 不需要我们自己实现登录验证逻辑，而是将用户、角色、权限信息以实现UserDetails和UserDetailsService接口的方式告知Spring Security。具体的登录验证逻辑Spring Security 会帮助我们实现。&lt;/li&gt;
&lt;li&gt;UserDetails接口中有一个方法叫做isAccountNonLocked()用于判断账号是否被锁定，也就是说我们应该通过该方法对应的set方法setAccountNonLocked(false)告知Spring Security该登录账户被锁定。&lt;/li&gt;
&lt;li&gt;那么应该在哪里判断账号登录失败的次数并执行锁定机制呢？当然是我们之前文章给大家介绍的《自定义登录成功及失败结果处理》的AuthenticationFailureHandler。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;建议您先阅读本文，如果您对本文的实现过程感到迷惑，建议您再翻看本号之前的相关内容。&lt;/p&gt;
&lt;h2 id=&quot;二实现多次登录失败锁定的原理&quot;&gt;二、实现多次登录失败锁定的原理&lt;/h2&gt;
&lt;p&gt;一般来说实现这个需求，我们需要针对每一个用户记录登录失败的次数nLock和锁定账户的到期时间releaseTime。具体你是把这2个信息存储在mysql、还是文件中、还是redis中等等，完全取决于你对你所处的应用架构适用性的判断。具体的实现逻辑无非就是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;登陆失败之后，从存储中将nLock取出来加1。&lt;/li&gt;
&lt;li&gt;如果nLock大于登陆失败阈值(比如3次)，则将nLock=0，然后设置releaseTime为当前时间加上锁定周期。通过setAccountNonLocked(false)告知Spring Security该登录账户被锁定。&lt;/li&gt;
&lt;li&gt;如果nLock小于等于1，则将nLock再次存起来。&lt;/li&gt;
&lt;li&gt;在一个合适的时机，将锁定状态重置为setAccountNonLocked(true)。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这是一种非常典型的实现方式，笔者向大家介绍一款非常有用的开源软件叫做：ratelimitj。这个软件的功能主要是为API访问进行限流，也就是说可以通过制定规则限制API接口的访问频率。那恰好登录验证接口也是API的一种啊，我们正好也需要限制它在一定的时间内的访问次数。&lt;/p&gt;
&lt;h2 id=&quot;三具体实现&quot;&gt;三、具体实现&lt;/h2&gt;
&lt;p&gt;首先需要将ratelimitj通过maven坐标引入到我们的应用里面来。我们使用的是内存存储的版本，还有redis存储的版本，大家可以根据自己的应用情况选用。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;es.moki.ratelimitj&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;ratelimitj-inmemory&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;0.4.1&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;之后通过继承SimpleUrlAuthenticationFailureHandler ，实现onAuthenticationFailure方法。该实现是针对登录失败的结果的处理，在我们之前的文章中已经讲过。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Component
public class MyAuthenticationFailureHandler extends SimpleUrlAuthenticationFailureHandler {

    @Autowired
    UserDetailsManager userDetailsManager;

    //规则定义：1小时之内5次机会，就触发限流行为
    Set&amp;lt;RequestLimitRule&amp;gt; rules = 
            Collections.singleton(RequestLimitRule.of(1 * 60, TimeUnit.MINUTES,5)); 
    RequestRateLimiter limiter = new InMemorySlidingWindowRequestRateLimiter(rules);


    @Override
    public void onAuthenticationFailure(HttpServletRequest request,
                                        HttpServletResponse response, 
                                        AuthenticationException exception) 
                                        throws IOException, ServletException {

         String userId = //从request或request.getSession中获取登录用户名
         //计数器加1，并判断该用户是否已经到了触发了锁定规则
         boolean reachLimit = limiter.overLimitWhenIncremented(userId);

        if(reachLimit){ //如果触发了锁定规则，通过UserDetails告知Spring Security锁定账户
               user.setAccountNonLocked(false);
               userDetailsManager.updateUser(user);
               SysUser user = (SysUser) userDetailsManager.loadUserByUsername(userId);
        }
        

        
        //此处省略通过response做json或html响应
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;核心实现注意看代码中的注释&lt;/li&gt;
&lt;li&gt;代码中的SysUser为UserDetails的实现类，如果不知道如何实现请参考本号之前的文章&lt;/li&gt;
&lt;li&gt;userDetailsManager被用于管理UserDetails信息，通过改变UserDetails改变Spring Security验证行为。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;四重置锁定状态的时机&quot;&gt;四、重置锁定状态的时机&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;user.setAccountNonLocked(true);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重置锁定状态很简单，就是上面的代码。但是更重要的是如何选择重置锁定状态的时机。笔者能想到几种方案如下&lt;/p&gt;
&lt;ul readability=&quot;-0.88906752411576&quot;&gt;&lt;li&gt;下一次登陆的时候，自定义过滤器，加在Spring Boot过滤器链最前端做锁定状态重置的判断。&lt;/li&gt;
&lt;li&gt;当登录账户被锁定之后，之后用户的每一次登录都会抛出LockedException。我们完全可以通过Spring Boot的全局异常捕获机制，在其中捕获LockedException，并做锁定状态的判断及重置行为。&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;写一个Spring 的定时器轮询，当然这是最差的方案。&lt;/p&gt;
&lt;h2 id=&quot;期待您的关注&quot;&gt;期待您的关注&lt;/h2&gt;
&lt;/li&gt;
&lt;li&gt;向您推荐博主的系列文档：&lt;a href=&quot;http://springboot.zimug.com&quot;&gt;《手摸手教您学习SpringBoot系列-16章97节》&lt;/a&gt;&lt;/li&gt;
&lt;li readability=&quot;-0.82758620689655&quot;&gt;
&lt;p&gt;本文转载注明出处（必须带连接，不能只转文字）：&lt;a href=&quot;http://www.zimug.com&quot;&gt;字母哥博客&lt;/a&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Wed, 27 Nov 2019 23:44:00 +0000</pubDate>
<dc:creator>字母哥博客</dc:creator>
<og:description>在上一次写的文章中，为大家说到了如何动态的从数据库加载用户、角色、权限信息，从而实现登录验证及授权。在实际的开发过程中，我们通常会有这样的一个需求：当用户多次登录失败的时候，我们应该将账户锁定，等待一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zimug/p/11946727.html</dc:identifier>
</item>
<item>
<title>RocketMQ一个新的消费组初次启动时从何处开始消费呢？ - 中间件兴趣圈</title>
<link>http://www.cnblogs.com/dingwpmz/p/11946376.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dingwpmz/p/11946376.html</guid>
<description>&lt;p&gt;@(本文目录)&lt;/p&gt;
&lt;h2 id=&quot;抛出问题&quot;&gt;1、抛出问题&lt;/h2&gt;
&lt;p&gt;一个新的消费组订阅一个已存在的Topic主题时，消费组是从该Topic的哪条消息开始消费呢？&lt;/p&gt;
&lt;p&gt;首先翻阅DefaultMQPushConsumer的API时，setConsumeFromWhere(ConsumeFromWhere consumeFromWhere)API映入眼帘，从字面意思来看是设置消费者从哪里开始消费，正是解开该问题的”钥匙“。ConsumeFromWhere枚举类图如下：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190720120834686.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;CONSUME_FROM_MAX_OFFSET&lt;br/&gt;从消费队列最大的偏移量开始消费。&lt;/li&gt;
&lt;li&gt;CONSUME_FROM_FIRST_OFFSET&lt;br/&gt;从消费队列最小偏移量开始消费。&lt;/li&gt;
&lt;li&gt;CONSUME_FROM_TIMESTAMP&lt;br/&gt;从指定的时间戳开始消费，默认为消费者启动之前的30分钟处开始消费。可以通过DefaultMQPushConsumer#setConsumeTimestamp。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;是不是点小激动，还不快试试。&lt;/p&gt;
&lt;p&gt;需求：新的消费组启动时，从队列最后开始消费，即只消费启动后发送到消息服务器后的最新消息。&lt;/p&gt;
&lt;h3 id=&quot;环境准备&quot;&gt;1.1 环境准备&lt;/h3&gt;
&lt;p&gt;本示例所用到的Topic路由信息如下：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190720120920850.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Broker的配置如下(broker.conf)&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;properities&quot;&gt;
&lt;code&gt;brokerClusterName = DefaultCluster
brokerName = broker-a
brokerId = 0
deleteWhen = 04
fileReservedTime = 48
brokerRole = ASYNC_MASTER
flushDiskType = ASYNC_FLUSH

storePathRootDir=E:/SH2019/tmp/rocketmq_home/rocketmq4.5_simple/store
storePathCommitLog=E:/SH2019/tmp/rocketmq_home/rocketmq4.5_simple/store/commitlog
namesrvAddr=127.0.0.1:9876
autoCreateTopicEnable=false
mapedFileSizeCommitLog=10240
mapedFileSizeConsumeQueue=2000&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中重点修改了如下两个参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;mapedFileSizeCommitLog&lt;br/&gt;单个commitlog文件的大小，这里使用10M，方便测试用。&lt;/li&gt;
&lt;li&gt;mapedFileSizeConsumeQueue&lt;br/&gt;单个consumequeue队列长度，这里使用1000，表示一个consumequeue文件中包含1000个条目。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;消息发送者代码&quot;&gt;1.2 消息发送者代码&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void main(String[] args) throws MQClientException, InterruptedException {
    DefaultMQProducer producer = new DefaultMQProducer(&quot;please_rename_unique_group_name&quot;);
    producer.setNamesrvAddr(&quot;127.0.0.1:9876&quot;);
    producer.start();
    for (int i = 0; i &amp;lt; 300; i++) {
        try {
            Message msg = new Message(&quot;TopicTest&quot; ,&quot;TagA&quot; , (&quot;Hello RocketMQ &quot; + i).getBytes(RemotingHelper.DEFAULT_CHARSET));
            SendResult sendResult = producer.send(msg);
            System.out.printf(&quot;%s%n&quot;, sendResult);
        } catch (Exception e) {
            e.printStackTrace();
            Thread.sleep(1000);
        }
    }
    producer.shutdown();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过上述，往TopicTest发送300条消息，发送完毕后，RocketMQ Broker存储结构如下：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190720121132299.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;消费端验证代码&quot;&gt;1.3 消费端验证代码&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void main(String[] args) throws InterruptedException, MQClientException {
    DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(&quot;my_consumer_01&quot;);
    consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET);
    consumer.subscribe(&quot;TopicTest&quot;, &quot;*&quot;);
    consumer.setNamesrvAddr(&quot;127.0.0.1:9876&quot;);
    consumer.registerMessageListener(new MessageListenerConcurrently() {
        @Override
        public ConsumeConcurrentlyStatus consumeMessage(List&amp;lt;MessageExt&amp;gt; msgs,
            ConsumeConcurrentlyContext context) {
            System.out.printf(&quot;%s Receive New Messages: %s %n&quot;, Thread.currentThread().getName(), msgs);
            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
        }
    });
    consumer.start();
    System.out.printf(&quot;Consumer Started.%n&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行上述代码后，按照期望，应该是不会消费任何消息，只有等生产者再发送消息后，才会对消息进行消费，事实是这样吗？执行效果如图所示：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190720121225978.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;strong&gt;令人意外的是，竟然从队列的最小偏移量开始消费了&lt;/strong&gt;，这就“尴尬”了。难不成是RocketMQ的Bug。带着这个疑问，从源码的角度尝试来解读该问题，并指导我们实践。&lt;/p&gt;
&lt;h2 id=&quot;探究consume_from_max_offset实现原理&quot;&gt;2、探究CONSUME_FROM_MAX_OFFSET实现原理&lt;/h2&gt;
&lt;p&gt;对于一个新的消费组，无论是集群模式还是广播模式都不会存储该消费组的消费进度，可以理解为-1,此时就需要根据DefaultMQPushConsumer#consumeFromWhere属性来决定其从何处开始消费，首先我们需要找到其对应的处理入口。我们知道，消息消费者从Broker服务器拉取消息时，需要进行消费队列的负载，即RebalanceImpl。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;温馨提示：本文不会详细介绍RocketMQ消息队列负载、消息拉取、消息消费逻辑，只会展示出通往该问题的简短流程，如想详细了解消息消费具体细节，建议购买笔者出版的《RocketMQ技术内幕》书籍。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;RebalancePushImpl#computePullFromWhere&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public long computePullFromWhere(MessageQueue mq) {
        long result = -1;                                                                                                                                                                                                                  // @1
        final ConsumeFromWhere consumeFromWhere = this.defaultMQPushConsumerImpl.getDefaultMQPushConsumer().getConsumeFromWhere();    
        final OffsetStore offsetStore = this.defaultMQPushConsumerImpl.getOffsetStore();
        switch (consumeFromWhere) {
            case CONSUME_FROM_LAST_OFFSET_AND_FROM_MIN_WHEN_BOOT_FIRST:
            case CONSUME_FROM_MIN_OFFSET:
            case CONSUME_FROM_MAX_OFFSET:
            case CONSUME_FROM_LAST_OFFSET: {                                                                                                                                                                // @2
               // 省略部分代码
                break;
            }
            case CONSUME_FROM_FIRST_OFFSET: {                                                                                                                                                              // @3
                // 省略部分代码
                break;
            }
            case CONSUME_FROM_TIMESTAMP: {                                                                                                                                                                  //@4
                // 省略部分代码
                break;
            }
            default:
                break;
        }
        return result;                                                                                                                                                                                                                  // @5
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码@1：先解释几个局部变量。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;result&lt;br/&gt;最终的返回结果，默认为-1。&lt;/li&gt;
&lt;li&gt;consumeFromWhere&lt;br/&gt;消息消费者开始消费的策略，即CONSUME_FROM_LAST_OFFSET等。&lt;/li&gt;
&lt;li&gt;offsetStore&lt;br/&gt;offset存储器，消费组消息偏移量存储实现器。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;代码@2：CONSUME_FROM_LAST_OFFSET(从队列的最大偏移量开始消费)的处理逻辑，下文会详细介绍。&lt;/p&gt;
&lt;p&gt;代码@3：CONSUME_FROM_FIRST_OFFSET(从队列最小偏移量开始消费)的处理逻辑，下文会详细介绍。&lt;/p&gt;
&lt;p&gt;代码@4：CONSUME_FROM_TIMESTAMP(从指定时间戳开始消费)的处理逻辑，下文会详细介绍。&lt;/p&gt;
&lt;p&gt;代码@5：返回最后计算的偏移量，从该偏移量出开始消费。&lt;/p&gt;
&lt;h3 id=&quot;consume_from_last_offset计算逻辑&quot;&gt;2.1 CONSUME_FROM_LAST_OFFSET计算逻辑&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;case CONSUME_FROM_LAST_OFFSET: {
    long lastOffset = offsetStore.readOffset(mq, ReadOffsetType.READ_FROM_STORE);   // @1
    if (lastOffset &amp;gt;= 0) {                                                                                                             // @2
        result = lastOffset;
    }
    // First start,no offset
    else if (-1 == lastOffset) {                                                                                                  // @3
        if (mq.getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) {               
            result = 0L;
        } else {
            try {
                result = this.mQClientFactory.getMQAdminImpl().maxOffset(mq);                     
            } catch (MQClientException e) {                                                                              // @4
                result = -1;
            }
        }
    } else {
        result = -1;    
    }
    break;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码@1：使用offsetStore从消息消费进度文件中读取消费消费进度，本文将以集群模式为例展开。稍后详细分析。&lt;/p&gt;
&lt;p&gt;代码@2：如果返回的偏移量大于等于0，则直接使用该offset，这个也能理解，大于等于0，表示查询到有效的消息消费进度，从该有效进度开始消费，但我们要特别留意lastOffset为0是什么场景，因为返回0，并不会执行CONSUME_FROM_LAST_OFFSET(语义)。&lt;/p&gt;
&lt;p&gt;代码@3：如果lastOffset为-1,表示当前并未存储其有效偏移量，可以理解为第一次消费，如果是消费组重试主题，从重试队列偏移量为0开始消费；如果是普通主题，则从队列当前的最大的有效偏移量开始消费，即CONSUME_FROM_LAST_OFFSET语义的实现。&lt;/p&gt;
&lt;p&gt;代码@4：如果从远程服务拉取最大偏移量拉取异常或其他情况，则使用-1作为第一次拉取偏移量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分析，上述执行的现象，虽然设置的是CONSUME_FROM_LAST_OFFSET，但现象是从队列的第一条消息开始消费，根据上述源码的分析，只有从消费组消费进度存储文件中取到的消息偏移量为0时，才会从第一条消息开始消费，故接下来重点分析消息消费进度存储器(OffsetStore)在什么情况下会返回0。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接下来我们将以集群模式来查看一下消息消费进度的查询逻辑，集群模式的消息进度存储管理器实现为：&lt;br/&gt;RemoteBrokerOffsetStore,最终Broker端的命令处理类为：ConsumerManageProcessor。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;ConsumerManageProcessor#queryConsumerOffset
private RemotingCommand queryConsumerOffset(ChannelHandlerContext ctx, RemotingCommand request) throws RemotingCommandException {
    final RemotingCommand response =
        RemotingCommand.createResponseCommand(QueryConsumerOffsetResponseHeader.class);
    final QueryConsumerOffsetResponseHeader responseHeader =
        (QueryConsumerOffsetResponseHeader) response.readCustomHeader();
    final QueryConsumerOffsetRequestHeader requestHeader =
        (QueryConsumerOffsetRequestHeader) request
            .decodeCommandCustomHeader(QueryConsumerOffsetRequestHeader.class);

    long offset =
        this.brokerController.getConsumerOffsetManager().queryOffset(
            requestHeader.getConsumerGroup(), requestHeader.getTopic(), requestHeader.getQueueId());    // @1

    if (offset &amp;gt;= 0) {                                                                                                                                          // @2
        responseHeader.setOffset(offset);
        response.setCode(ResponseCode.SUCCESS);
        response.setRemark(null);
    } else {                                                                                                                                                       // @3
        long minOffset =
            this.brokerController.getMessageStore().getMinOffsetInQueue(requestHeader.getTopic(),
                requestHeader.getQueueId());                                                                                                     // @4
        if (minOffset &amp;lt;= 0
            &amp;amp;&amp;amp; !this.brokerController.getMessageStore().checkInDiskByConsumeOffset(                                // @5
            requestHeader.getTopic(), requestHeader.getQueueId(), 0)) {
            responseHeader.setOffset(0L);
            response.setCode(ResponseCode.SUCCESS);
            response.setRemark(null);
        } else {                                                                                                                                                 // @6
            response.setCode(ResponseCode.QUERY_NOT_FOUND);
            response.setRemark(&quot;Not found, V3_0_6_SNAPSHOT maybe this group consumer boot first&quot;);
        }
    }
    return response;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码@1：从消费消息进度文件中查询消息消费进度。&lt;/p&gt;
&lt;p&gt;代码@2：如果消息消费进度文件中存储该队列的消息进度，其返回的offset必然会大于等于0，则直接返回该偏移量该客户端，客户端从该偏移量开始消费。&lt;/p&gt;
&lt;p&gt;代码@3：如果未从消息消费进度文件中查询到其进度，offset为-1。则首先获取该主题、消息队列当前在Broker服务器中的最小偏移量(@4)。如果小于等于0(返回0则表示该队列的文件还未曾删除过)并且其最小偏移量对应的消息存储在内存中而不是存在磁盘中，则返回偏移量0，这就意味着ConsumeFromWhere中定义的三种枚举类型都不会生效，直接从0开始消费，到这里就能解开其谜团了(@5)。&lt;/p&gt;
&lt;p&gt;代码@6：如果偏移量小于等于0，但其消息已经存储在磁盘中，此时返回未找到，最终RebalancePushImpl#computePullFromWhere中得到的偏移量为-1。&lt;/p&gt;
&lt;p&gt;看到这里，大家应该能回答文章开头处提到的问题了吧？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;看到这里，大家应该明白了，为什么设置的CONSUME_FROM_LAST_OFFSET，但消费组是从消息队列的开始处消费了吧，原因就是消息消费进度文件中并没有找到其消息消费进度，并且该队列在Broker端的最小偏移量为0，说的更直白点，consumequeue/topicName/queueNum的第一个消息消费队列文件为00000000000000000000,并且消息其对应的消息缓存在Broker端的内存中(pageCache)，其返回给消费端的偏移量为0，故会从0开始消费，而不是从队列的最大偏移量处开始消费。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了知识体系的完备性，我们顺便来看一下其他两种策略的计算逻辑。&lt;/p&gt;
&lt;h3 id=&quot;consume_from_first_offset&quot;&gt;2.2 CONSUME_FROM_FIRST_OFFSET&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;case CONSUME_FROM_FIRST_OFFSET: {
    long lastOffset = offsetStore.readOffset(mq, ReadOffsetType.READ_FROM_STORE);   // @1
    if (lastOffset &amp;gt;= 0) {    // @2
        result = lastOffset;
    } else if (-1 == lastOffset) {  // @3
        result = 0L;
    } else {                                  
        result = -1;                    // @4
    }
    break;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从队列的开始偏移量开始消费，其计算逻辑如下：&lt;br/&gt;代码@1：首先通过偏移量存储器查询消费队列的消费进度。&lt;/p&gt;
&lt;p&gt;代码@2：如果大于等于0，则从当前该偏移量开始消费。&lt;/p&gt;
&lt;p&gt;代码@3：如果远程返回-1，表示并没有存储该队列的消息消费进度，从0开始。&lt;/p&gt;
&lt;p&gt;代码@4：否则从-1开始消费。&lt;/p&gt;
&lt;h3 id=&quot;consume_from_timestamp&quot;&gt;2.4 CONSUME_FROM_TIMESTAMP&lt;/h3&gt;
&lt;p&gt;从指定时戳后的消息开始消费。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;case CONSUME_FROM_TIMESTAMP: {
    ong lastOffset = offsetStore.readOffset(mq, ReadOffsetType.READ_FROM_STORE);   // @1
    if (lastOffset &amp;gt;= 0) {                                                                                                            // @2
        result = lastOffset;
    } else if (-1 == lastOffset) {                                                                                                 // @3
        if (mq.getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) {
            try {
                result = this.mQClientFactory.getMQAdminImpl().maxOffset(mq);
            } catch (MQClientException e) {
                result = -1;
            }
        } else {
            try {
                long timestamp = UtilAll.parseDate(this.defaultMQPushConsumerImpl.getDefaultMQPushConsumer().getConsumeTimestamp(),
                    UtilAll.YYYYMMDDHHMMSS).getTime();
                result = this.mQClientFactory.getMQAdminImpl().searchOffset(mq, timestamp);
            } catch (MQClientException e) {
                result = -1;
            }
        }
    } else {
        result = -1;
    }
    break;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其基本套路与CONSUME_FROM_LAST_OFFSET一样：&lt;br/&gt;代码@1：首先通过偏移量存储器查询消费队列的消费进度。&lt;/p&gt;
&lt;p&gt;代码@2：如果大于等于0，则从当前该偏移量开始消费。&lt;/p&gt;
&lt;p&gt;代码@3：如果远程返回-1，表示并没有存储该队列的消息消费进度，如果是重试主题，则从当前队列的最大偏移量开始消费，如果是普通主题，则根据时间戳去Broker端查询，根据查询到的偏移量开始消费。&lt;/p&gt;
&lt;p&gt;原理就介绍到这里，下面根据上述理论对其进行验证。&lt;/p&gt;
&lt;h2 id=&quot;猜想与验证&quot;&gt;3、猜想与验证&lt;/h2&gt;
&lt;p&gt;根据上述理论分析我们得知设置CONSUME_FROM_LAST_OFFSET但并不是从消息队列的最大偏移量开始消费的“罪魁祸首”是因为消息消费队列的最小偏移量为0，如果不为0，则就会符合预期，我们来验证一下这个猜想。&lt;br/&gt;首先我们删除commitlog目录下的文件，如图所示：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190720121720399.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;其消费队列截图如下：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190720121738795.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;消费端的验证代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void main(String[] args) throws InterruptedException, MQClientException {
    DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(&quot;my_consumer_02&quot;);
    consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET);
    consumer.subscribe(&quot;TopicTest&quot;, &quot;*&quot;);
    consumer.setNamesrvAddr(&quot;127.0.0.1:9876&quot;);
    consumer.registerMessageListener(new MessageListenerConcurrently() {
        @Override
        public ConsumeConcurrentlyStatus consumeMessage(List&amp;lt;MessageExt&amp;gt; msgs,
            ConsumeConcurrentlyContext context) {
            System.out.printf(&quot;%s Receive New Messages: %s %n&quot;, Thread.currentThread().getName(), msgs);
            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
        }
    });
    consumer.start();
    System.out.printf(&quot;Consumer Started.%n&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果如下：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190720121811440.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;并没有消息存在的消息，符合预期。&lt;/p&gt;
&lt;h2 id=&quot;解决方案&quot;&gt;4、解决方案&lt;/h2&gt;
&lt;p&gt;如果在生产环境下，一个新的消费组订阅一个已经存在比较久的topic，设置CONSUME_FROM_MAX_OFFSET是符合预期的，即该主题的consumequeue/{queueNum}/fileName，fileName通常不会是00000000000000000000，如是是上面文件名，想要实现从队列的最后开始消费，该如何做呢？那就走自动创建消费组的路子，执行如下命令：&lt;/p&gt;
&lt;pre class=&quot;sh&quot;&gt;
&lt;code&gt;./mqadmin updateSubGroup -n 127.0.0.1:9876 -c DefaultCluster -g my_consumer_05

//克隆一个订阅了该topic的消费组消费进度
./mqadmin cloneGroupOffset -n 127.0.0.1:9876 -s my_consumer_01 -d my_consumer_05 -t TopicTest

//重置消费进度到当前队列的最大值
./mqadmin resetOffsetByTime -n 127.0.0.1:9876 -g my_consumer_05 -t TopicTest -s -1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;按照上上述命令后，即可实现其目的。&lt;/p&gt;
&lt;p&gt;您都看到这里了，麻烦帮忙点个赞，谢谢您的认可与鼓励。&lt;/p&gt;
&lt;h2 id=&quot;section&quot;&gt;---&lt;/h2&gt;
&lt;blockquote readability=&quot;7.5714285714286&quot;&gt;
&lt;p&gt;作者介绍：&lt;br/&gt;丁威，《RocketMQ技术内幕》作者，RocketMQ 社区布道师，公众号：&lt;a href=&quot;https://mp.weixin.qq.com/s/LB7k8A06BgssXy9bxfZC3w&quot;&gt;中间件兴趣圈&lt;/a&gt; 维护者，目前已陆续发表源码分析Java集合、Java 并发包(JUC)、Netty、Mycat、Dubbo、RocketMQ、Mybatis等源码专栏。欢迎加入我的知识星球，构建一个高质量的技术交流社群。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191127232921737.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 27 Nov 2019 15:31:00 +0000</pubDate>
<dc:creator>中间件兴趣圈</dc:creator>
<og:description>@ 'TOC' 1、抛出问题 一个新的消费组订阅一个已存在的Topic主题时，消费组是从该Topic的哪条消息开始消费呢？ 首先翻阅DefaultMQPushConsumer的API时，setCons</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/dingwpmz/p/11946376.html</dc:identifier>
</item>
<item>
<title>使用node.js开发一个生成逐帧动画小工具 - 10年老程序猿</title>
<link>http://www.cnblogs.com/cinser/p/11946305.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cinser/p/11946305.html</guid>
<description>&lt;p&gt;在实际工作中我们已经下下来不下于一万个&lt;code&gt;npm&lt;/code&gt;包了，像我们熟悉的 &lt;code&gt;vue-cli&lt;/code&gt;，&lt;code&gt;react-native-cli&lt;/code&gt; 等，只需要输入简单的命令 &lt;code&gt;vue init webpack project&lt;/code&gt;，即可快速帮我们生成一个初始项目。在实际开发项目中，我们也可以定制一个属于自己的&lt;code&gt;npm&lt;/code&gt;包，来提高自己的工作效率。&lt;/p&gt;
&lt;p&gt;为什么要开发一个工具包？&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;减少重复性的工作，不再需要复制其他项目再删除无关代码，或者从零创建一个项目和文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;根据交互动态生成项目结构和所需要的文件等。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;减少人工检查的成本。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;提高工作效率，解放生产力。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这次以帧动画工具为例，来一步一步解析如何开发一个&lt;code&gt;npm&lt;/code&gt;包。&lt;/p&gt;
&lt;h2&gt;开始前的准备&lt;/h2&gt;
&lt;p&gt;以我们这次为例。由于目前在做一些活动页相关的工作，其中动画部分全都采用&lt;code&gt;CSS3&lt;/code&gt;中的&lt;code&gt;animation&lt;/code&gt;来完成，但是这样每次开发都要计算百分比，手动判断动画的一些属性值，十分耗时又很容易出错，就想能不能写个脚本，直接一行命令就可以搞定了呢？！答案当然是肯定的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;理清思路&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们要做一个可以通过读取图片就可以自动生成包含&lt;code&gt;CSS animation&lt;/code&gt;的&lt;code&gt;HTML&lt;/code&gt;页面，以后需要生成相应的&lt;code&gt;CSS&lt;/code&gt;片段，直接执行命令就可以了。&lt;/p&gt;
&lt;h2&gt;初始化&lt;/h2&gt;
&lt;p&gt;既然是&lt;code&gt;npm&lt;/code&gt;包，那我们就需要在npmjs上注册一个账号，注册完成之后回到本地新建一个文件目录&lt;code&gt;fbf&lt;/code&gt;，进入&lt;code&gt;fbf&lt;/code&gt;目录下执行&lt;code&gt;npm init -y。&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
  {
     &quot;name&quot;: &quot;fbf&quot;,
     &quot;version&quot;: &quot;1.0.0&quot;,
     &quot;description&quot;: &quot;&quot;,
     &quot;main&quot;: &quot;index.js&quot;,
     &quot;scripts&quot;: {
       &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;amp;&amp;amp; exit 1&quot;
     },
     &quot;bin&quot;: {
       &quot;test&quot;: &quot;index.js&quot;
     },
     &quot;keywords&quot;: [],
     &quot;author&quot;: &quot;&quot;,
     &quot;license&quot;: &quot;ISC&quot;
 }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这样，你的&lt;code&gt;package.json&lt;/code&gt;就建好了。&lt;/p&gt;
&lt;h2&gt;依赖的库&lt;/h2&gt;
&lt;p&gt;来看看会用到哪些库。&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;commander.js，可以自动的解析命令和参数，用于处理用户输入的命令。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;chalk，可以给终端的字体加上颜色。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;create-html，创建&lt;code&gt;HTML&lt;/code&gt;模版，用于生成&lt;code&gt;HTML&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;image-size，获取图片大小。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;npm install commander chalk create-html image-size -S&lt;/code&gt;&lt;/p&gt;

&lt;h2&gt;命令行操作&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;node.js&lt;/code&gt; 内置了对命令行操作的支持，在 &lt;code&gt;package.json&lt;/code&gt; 中的 &lt;code&gt;bin&lt;/code&gt; 字段可以定义命令名和关联的执行文件。所以现在 &lt;code&gt;package.json&lt;/code&gt; 中加上 bin 的内容：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
{
  &quot;name&quot;: &quot;fbf&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;bin&quot;: {
    &quot;fbf&quot;: &quot;index.js&quot;
  },
  ...
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后在 &lt;code&gt;index.js&lt;/code&gt; 中来定义 &lt;code&gt;start&lt;/code&gt; 命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
#!/usr/bin/env node
const program = require('commander');

program.version('1.0.0', '-v, --version')
  .command('start &amp;lt;name&amp;gt;')
  .action((name) =&amp;gt; {
    console.log(name);
  });
program.parse(process.argv);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用 &lt;code&gt;version('1.0.0', '-v, --version')&lt;/code&gt; 会将 &lt;code&gt;-v&lt;/code&gt; 和 &lt;code&gt;--version&lt;/code&gt; 添加到命令中，可以通过这些选项打印出版本号。&lt;/p&gt;
&lt;p&gt;调用 &lt;code&gt;command('start &amp;lt;name&amp;gt;')&lt;/code&gt; 定义 &lt;code&gt;start&lt;/code&gt; 命令，&lt;code&gt;name&lt;/code&gt; 则是必传的参数，为文件名。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;action()&lt;/code&gt; 则是执行 &lt;code&gt;start&lt;/code&gt; 命令会发生的行为，要生成项目的过程就是在这里面执行的，这里暂时只打印出 &lt;code&gt;name&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;其实到这里，已经可以执行 &lt;code&gt;start&lt;/code&gt; 命令了。我们来测试一下，在 &lt;code&gt;fbf&lt;/code&gt; 的同级目录下执行：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;node ./test/index.js start HelloWorld&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;可以看到命令行工具也打印出了 &lt;code&gt;HelloWorld&lt;/code&gt;，那么很清楚， &lt;code&gt;action((name) =&amp;gt; {})&lt;/code&gt; 这里的参数 &lt;code&gt;name&lt;/code&gt;，就是我们执行 &lt;code&gt;start&lt;/code&gt; 命令时输入的项目名称。&lt;/p&gt;
&lt;p&gt;命令已经完成，接下来就要针对图片的操作了。&lt;/p&gt;
&lt;h2&gt;获取图片信息&lt;/h2&gt;
&lt;p&gt;这里我们默认根据第一张图片的尺寸信息作为外层&lt;code&gt;DIV&lt;/code&gt;的默认尺寸。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
 #!/usr/bin/env node
  const program = require('commander');
  const fs = require('fs');
  const path = require('path');
  const createHTML = require('create-html');
  const sizeOf = require('image-size');
  const chalk = require('chalk');

  program.version('1.0.0', '-v, --version')
  .command('start &amp;lt;dir&amp;gt;')
  .action((dir) =&amp;gt; {
    
    //获取图片路径
    const imgPath = path.resolve(dir)

    let imgSize = null;
    fs.readdir(imgPath, (err, file) =&amp;gt; {
      imgSize = sizeOf(dir + '/' +file[0]);  
      //取第一个图片的尺寸作为框尺寸
      let cssString = `
        .fbf-animation{
          width: ${imgSize.width}px;
          height: ${imgSize.height}px;
          margin:auto;
          background-image: url(./${dir}/${file[0]});
          background-size: ${imgSize.width}px ${imgSize.height}px;
          background-repeat: no-repeat;
          animation-name: keyframes-img;
          animation-duration: 0.36s;
          animation-delay: 0s;
          animation-iteration-count: infinite;
          animation-fill-mode: forwards;
          animation-timing-function: steps(1);
      }
    `
    })
  })
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;生成CSS代码&lt;/h2&gt;
&lt;p&gt;然后根据图片数量生成相应的&lt;code&gt;keyframes&lt;/code&gt;代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
 function toCss(dir, fileList){
    let _css = '';
    let start = 0;
    const per = Math.floor(100/fileList.length);
    fileList.map((path, i) =&amp;gt; {
      if(i === fileList.length - 1){
        _css += `
          ${start + i*per}%, 100% {
            background:url(./${dir}/${path}) center center no-repeat;
            background-size:100% auto;
          }
        `
      }else{
        _css += `
          ${start + i*per}% {
            background:url(./${dir}/${path}) center center no-repeat;
            background-size:100% auto;
          }
        `
      }
    })
    
    return _css;
  }
  
  let frameCss = toCss(dir, newFile)

  //取第一个图片的尺寸作为框尺寸
  let cssString = `
    .fbf-animation{
      width: ${imgSize.width}px;
      height: ${imgSize.height}px;
      margin:auto;
      background-image: url(./${dir}/${file[0]});
      background-size: ${imgSize.width}px ${imgSize.height}px;
      background-repeat: no-repeat;
      animation-name: keyframes-img;
      animation-duration: 0.36s;
      animation-delay: 0s;
      animation-iteration-count: infinite;
      animation-fill-mode: forwards;
      animation-timing-function: steps(1);
    }
    @keyframes keyframes-img {
      ${frameCss}
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;生成html文件&lt;/h2&gt;
&lt;p&gt;最后我们把生成的&lt;code&gt;CSS&lt;/code&gt;放到&lt;code&gt;HTML&lt;/code&gt;里。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
//生成html
let html = createHTML({
  title: '逐帧动画',
  scriptAsync: true,
  lang: 'en',
  dir: 'rtl',
  head: '&amp;lt;meta name=&quot;description&quot; content=&quot;example&quot;&amp;gt;',
  body: '&amp;lt;div class=&quot;fbf-animation&quot;&amp;gt;&amp;lt;/div&amp;gt;' + css,
  favicon: 'favicon.png'
})
fs.writeFile('fbf.html', html, function (err) {
  if (err) console.log(err)
})
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;视觉美化&lt;/h2&gt;
&lt;p&gt;通过 &lt;code&gt;chalk&lt;/code&gt; 来为打印信息加上样式，比如成功信息为绿色，失败信息为红色，这样子会让用户更加容易分辨，同时也让终端的显示更加的好看。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;const chalk = require('chalk'); console.log(chalk.green('生成代码成功！')); console.log(chalk.red('生成代码失败'));&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;完整示例&lt;/h2&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;55&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
#!/usr/bin/env node
const program = require('commander');
const fs = require('fs');
const path = require('path');
const createHTML = require('create-html');
const sizeOf = require('image-size');
const chalk = require('chalk');

//排序
const sortByFileName = files =&amp;gt;  {
  const reg = /[0-9]+/g;
  return files.sort((a, b) =&amp;gt; {
    let imga = (a.match(reg) || []).slice(-1),
      imgb = (b.match(reg) || []).slice(-1)
    return imga - imgb
  });
}

//删除.DS_Store
function deleteDS(file) {
  file.map((v, i) =&amp;gt; {
    if(v === '.DS_Store'){
      fs.unlink('img/.DS_Store', err =&amp;gt; {})
    }
  })
}

// 生成keyframe
function toCss(dir, fileList){
  let _css = '';
  let start = 0;
  const per = Math.floor(100/fileList.length);
  fileList.map((path, i) =&amp;gt; {
    if(i === fileList.length - 1){
      _css += `
        ${start + i*per}%, 100% {
          background:url(./${dir}/${path}) center center no-repeat;
          background-size:100% auto;
        }
      `
    }else{
      _css += `
        ${start + i*per}% {
          background:url(./${dir}/${path}) center center no-repeat;
          background-size:100% auto;
        }
      `
    }
  })
  console.log(chalk.green('css successed!'))
  return _css;
}

program.version('1.0.0', '-v, --version')
  .command('start &amp;lt;dir&amp;gt;')
  .action((dir) =&amp;gt; {

    const imgPath = path.resolve(dir)

    let imgSize = null;
    fs.readdir(imgPath, (err, file) =&amp;gt; {
      const newFile = sortByFileName(file)
      deleteDS(newFile)
      imgSize = sizeOf(dir + '/' +file[0]);
      let frameCss = toCss(dir, newFile)

      //取第一个图片的尺寸作为框尺寸
      let cssString = `
      .fbf-animation{
        width: ${imgSize.width}px;
        height: ${imgSize.height}px;
        margin:auto;
        background-image: url(./${dir}/${file[0]});
        background-size: ${imgSize.width}px ${imgSize.height}px;
        background-repeat: no-repeat;
        animation-name: keyframes-img;
        animation-duration: 0.36s;
        animation-delay: 0s;
        animation-iteration-count: infinite;
        animation-fill-mode: forwards;
        animation-timing-function: steps(1);
      }
      @keyframes keyframes-img {
        ${frameCss}
      }
    `
      let css = `
      &amp;lt;style&amp;gt;${cssString}&amp;lt;/style&amp;gt;
    `
      //生成html
      let html = createHTML({
        title: '逐帧动画',
        scriptAsync: true,
        lang: 'en',
        dir: 'rtl',
        head: '&amp;lt;meta name=&quot;description&quot; content=&quot;example&quot;&amp;gt;',
        body: '&amp;lt;div class=&quot;fbf-animation&quot;&amp;gt;&amp;lt;/div&amp;gt;' + css,
        favicon: 'favicon.png'
      })
      fs.writeFile('fbf.html', html, function (err) {
        console.log(chalk.green('html successed!'))
        if (err) console.log(err)
      })
    })
  });
program.parse(process.argv);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码一共100行左右，可以说非常简单明了，有兴趣的同学可以试试。&lt;/p&gt;
&lt;h2&gt;最后&lt;/h2&gt;
&lt;p&gt;完成之后，使用&lt;code&gt;npm publish fbf&lt;/code&gt;就可以把脚手架发布到 &lt;code&gt;npm&lt;/code&gt; 上面，通过 &lt;code&gt;-g&lt;/code&gt; 进行全局安装，就可以在自己本机上执行 &lt;code&gt;fbf start [dir]&lt;/code&gt;来生成一个&lt;code&gt;fbf.html&lt;/code&gt;文件，这样便完成了一个简单的&lt;code&gt;node&lt;/code&gt;工具了。&lt;/p&gt;
</description>
<pubDate>Wed, 27 Nov 2019 15:16:00 +0000</pubDate>
<dc:creator>10年老程序猿</dc:creator>
<og:description>在实际工作中我们已经下下来不下于一万个npm包了，像我们熟悉的&amp;#160;vue-cli，react-native-cli&amp;#160;等，只需要输入简单的命令&amp;#160;vue init webpac</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cinser/p/11946305.html</dc:identifier>
</item>
<item>
<title>如何使用C#调用C++类虚函数（即动态内存调用） - 云中双月</title>
<link>http://www.cnblogs.com/Johness/p/csharp-do-memory-call.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Johness/p/csharp-do-memory-call.html</guid>
<description>&lt;p&gt;  本文讲解如何使用C#调用只有.h头文件的c++类的虚函数（非实例函数，因为非虚函数不存在于虚函数表，无法通过类对象偏移计算地址，除非用export导出，而gcc默认是全部导出实例函数，这也是为什么msvc需要.lib，如果你不清楚但希望了解，可以选择找我摆龙门阵），并以COM组件的c#直接调用（不需要引用生成introp.dll）举例。&lt;/p&gt;
&lt;p&gt;  我们都知道，C#支持调用非托管函数，使用P/Inovke即可方便实现，例如下面的代码&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;[DllImport(&quot;msvcrt&quot;, EntryPoint = &quot;memcpy&quot;, CallingConvention = CallingConvention.Cdecl)]
public static extern void memcpy(IntPtr dest, IntPtr src, int count);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不过使用DllImport只能调用某个DLL中标记为导出的函数，我们可以使用一些工具查看函数导出，如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/372875/201911/372875-20191125185036536-751430314.png&quot; title=&quot;lx-msvcrt.dll的部分导出函数&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一般会导出的函数，都是c语言格式的。&lt;/p&gt;
&lt;p&gt;  C++类因为有多态，所以内存中维护了一个虚函数表，如果我们知道了某个C++类的内存地址，也有它的头文件，那么我们就能自己算出想要调用的某个函数的内存地址从而直接call，下面是一个简单示例&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;iostream&amp;gt;

class A_A_A {
public:
    virtual void hello() {
        std::cout &amp;lt;&amp;lt; &quot;hello from A\n&quot;;
    };
};

//typedef void (*HelloMethod)(void*);

int main()
{
    A_A_A* a = new A_A_A();
    a-&amp;gt;hello();

    //HelloMethod helloMthd = *(HelloMethod *)*(void**)a;
    
    //helloMthd(a);
    (*(void(**)(void*))*(void**)a)(a);

    int c;
    std::cin &amp;gt;&amp;gt; c;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（上文中将第23行注释掉，然后将其他注释行打开也是一样的效果，可能更便于阅读）&lt;br/&gt;从代码中大家很容易看出，c++的类的内存结构是一个虚函数表二级指针（数组，多重继承时可能有多个），每个虚函数表又是一个函数二级指针（数组，多少个虚函数就有多少个指针）。上文中我们假使只知道a是一个类对象，它的第一个虚函数是void (*) (void)类型的，那么我们可以直接call它的函数。&lt;/p&gt;
&lt;p&gt;  接下来开始骚操作，我们尝试用c#来调用一个c++的虚函数，首先写一个c++的dll，并且我们提供一个c格式的导出函数用于提供一个new出的对象（毕竟c++的new操作符很复杂，而且实际中我们经常是可以拿到这个new出来的对象，后面的com组件调用部分我会详细说明），像下面这样&lt;/p&gt;
&lt;p&gt;dll.h&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;class DummyClass {
private:
    virtual void sayHello();
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;dll.cpp&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &quot;dll.h&quot;
#include &amp;lt;stdio.h&amp;gt;

void DummyClass::sayHello() {
    printf(&quot;Hello World\n&quot;);
}

extern &quot;C&quot; __declspec(dllexport) DummyClass* __stdcall newObj() {
    return new DummyClass();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们编译出的dll长这样&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/372875/201911/372875-20191125203007527-1778785287.png&quot; title=&quot;lx-测试dll1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;让我们编写使用C#来调用sayHello&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;using System;
using System.Runtime.InteropServices;

namespace ConsoleApp2
{
    class Program
    {
        [DllImport(&quot;Dll1&quot;, EntryPoint = &quot;newObj&quot;)]
        static extern IntPtr CreateObject();

        [UnmanagedFunctionPointer(CallingConvention.ThisCall)]
        delegate void voidMethod1(IntPtr thisPtr);

        static void Main(string[] args)
        {
            IntPtr dummyClass = CreateObject();
            IntPtr vfptr = Marshal.ReadIntPtr(dummyClass);
            IntPtr funcPtr = Marshal.ReadIntPtr(vfptr);
            voidMethod1 voidMethod = (voidMethod1)Marshal.GetDelegateForFunctionPointer(funcPtr, typeof(voidMethod1));
            voidMethod(dummyClass);

            Console.ReadKey();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（因为调用的是c++的函数，所以this指针是第一个参数，当然，不同调用约定时它入栈方式和顺序不一样）&lt;br/&gt;下面有一种另外的写法&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;using System;
using System.Reflection;
using System.Reflection.Emit;
using System.Runtime.InteropServices;

namespace ConsoleApp2
{
    class Program
    {
        [DllImport(&quot;Dll1&quot;, EntryPoint = &quot;newObj&quot;)]
        static extern IntPtr CreateObject();

        //[UnmanagedFunctionPointer(CallingConvention.ThisCall)]
        //delegate void voidMethod1(IntPtr thisPtr);

        static void Main(string[] args)
        {
            IntPtr dummyClass = CreateObject();
            IntPtr vfptr = Marshal.ReadIntPtr(dummyClass);
            IntPtr funcPtr = Marshal.ReadIntPtr(vfptr);
            /*voidMethod1 voidMethod = (voidMethod1)Marshal.GetDelegateForFunctionPointer(funcPtr, typeof(voidMethod1));
            voidMethod(dummyClass);*/

            AssemblyName MyAssemblyName = new AssemblyName();
            MyAssemblyName.Name = &quot;DummyAssembly&quot;;
            AssemblyBuilder MyAssemblyBuilder = AppDomain.CurrentDomain.DefineDynamicAssembly(MyAssemblyName, AssemblyBuilderAccess.Run);
            ModuleBuilder MyModuleBuilder = MyAssemblyBuilder.DefineDynamicModule(&quot;DummyModule&quot;);
            MethodBuilder MyMethodBuilder = MyModuleBuilder.DefineGlobalMethod(&quot;DummyFunc&quot;, MethodAttributes.Public | MethodAttributes.Static, typeof(void), new Type[] { typeof(int) });
            ILGenerator IL = MyMethodBuilder.GetILGenerator();

            IL.Emit(OpCodes.Ldarg, 0);
            IL.Emit(OpCodes.Ldc_I4, funcPtr.ToInt32());

            IL.EmitCalli(OpCodes.Calli, CallingConvention.ThisCall, typeof(void), new Type[] { typeof(int) });
            IL.Emit(OpCodes.Ret);

            MyModuleBuilder.CreateGlobalFunctions();

            MethodInfo MyMethodInfo = MyModuleBuilder.GetMethod(&quot;DummyFunc&quot;);

            MyMethodInfo.Invoke(null, new object[] { dummyClass.ToInt32() });

            Console.ReadKey();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上文中的方法虽然复杂了一点，但……就是没什么用。不用怀疑！&lt;/p&gt;
&lt;p&gt;文章写到这里，可能有童鞋就要发问了。你说这么多，tmd到底有啥用？那接下来，我举一个栗子，activex组件的直接调用！&lt;br/&gt;以前，我们调用activex组件需要做很多复杂的事情，首先需要使用命令行调用regsvr32将dll注册到系统，然后回到vs去引用com组件是吧&lt;/p&gt;
&lt;p&gt;  仔细想想，需要吗？并不需要，因为两个原因：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;COM组件规定DLL需要给出一个DllGetClassObject函数，它就可以为我们在DLL内部new一个所需对象&lt;/li&gt;
&lt;li&gt;COM组件返回的对象其实就是一个只有虚函数的C++类对象（COM组件规定属性和事件用getter/setter方式实现）&lt;/li&gt;
&lt;li&gt;COM组件其实不需要用户手动注册，执行regsvr32会操作注册表，而且32位/64位会混淆，其实regsvr32只是调用了DLL导出函数DllRegisterServer，而这个函数的实现一般只是把自己注册到注册表中，这一步可有可无（特别是对于我们已经知道某个activex的dll存在路径且它能提供的服务时，如果你非要注册，使用p/invoke调用该dll的DllRegisterServer函数是一样的效果）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因此，假如我们有一个activex控件（例如vlc），我们希望把它嵌入我们程序中，我们先看看常规的做法（本文没有讨论带窗体的vlc，因为窗体这块儿又复杂一些），直接贴图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/372875/201911/372875-20191127190627801-319176896.png&quot; title=&quot;lx-C#中使用vlc的常规做法&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看起来很简单，但当我们需要打包给客户使用时就很麻烦，涉及到嵌入vlc的安装程序。而当我们会动态内存调用之后，就可以不注册而使用vlc的功能，我先贴出代码：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;using System;
using System.Runtime.InteropServices;

namespace ConsoleApp3
{
    class Program
    {
        [DllImport(&quot;kernel32&quot;)]
        static extern IntPtr LoadLibraryEx(string path, IntPtr hFile, int dwFlags);
        [DllImport(&quot;kernel32&quot;)]
        static extern IntPtr GetProcAddress(IntPtr dll, string func);

        delegate int DllGetClassObject(Guid clsid, Guid iid, ref IntPtr ppv);

        delegate int CreateInstance(IntPtr _thisPtr, IntPtr unkown, Guid iid, ref IntPtr ppv);

        delegate int getVersionInfo(IntPtr _thisPtr, [MarshalAs(UnmanagedType.BStr)] out string bstr);

        static void Main(string[] args)
        {
            IntPtr dll = LoadLibraryEx(@&quot;D:\Program Files\VideoLAN\VLC\axvlc.dll&quot;, default, 8);
            IntPtr func = GetProcAddress(dll, &quot;DllGetClassObject&quot;);
            DllGetClassObject dllGetClassObject = (DllGetClassObject)Marshal.GetDelegateForFunctionPointer(func, typeof(DllGetClassObject));

            Guid vlc = new Guid(&quot;2d719729-5333-406c-bf12-8de787fd65e3&quot;);
            Guid clsid = new Guid(&quot;9be31822-fdad-461b-ad51-be1d1c159921&quot;);
            Guid iidClassFactory = new Guid(&quot;00000001-0000-0000-c000-000000000046&quot;);
            IntPtr objClassFactory = default;
            dllGetClassObject(clsid, iidClassFactory, ref objClassFactory);
            CreateInstance createInstance = (CreateInstance)Marshal.GetDelegateForFunctionPointer(Marshal.ReadIntPtr(Marshal.ReadIntPtr(objClassFactory) + IntPtr.Size * 3), typeof(CreateInstance));
            IntPtr obj = default;
            createInstance(objClassFactory, default, vlc, ref obj);
            getVersionInfo getVersion = (getVersionInfo)Marshal.GetDelegateForFunctionPointer(Marshal.ReadIntPtr(Marshal.ReadIntPtr(obj) + IntPtr.Size * 18), typeof(getVersionInfo));
            string versionInfo;
            getVersion(obj, out versionInfo);

            Console.ReadKey();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/372875/201911/372875-20191127225422376-997127215.png&quot; title=&quot;lx-效果图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  上文中的代码有几处可能大家不容易懂，特别是指针偏移量的运算，这里面有比较复杂的地方，文章篇幅有限，下来咱们细细研究。&lt;/p&gt;
&lt;p&gt;  从11年下半年开始学习编程到现在已经很久了，有时候会觉得没什么奔头。其实人生，无外乎两件事，爱情和青春，我希望大家能有抓住的，就不要放手。两年前，我为了要和一个女孩子多说几句话，给人家讲COM组件，其实我连c++有虚函数表都不知道，时至今日，我已经失去了她。今后怕是一直会任由灵魂游荡，半梦半醒，即是人生。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/372875/201910/372875-20191030100807030-720874413.jpg&quot; title=&quot;lx-聊天QQ群&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 27 Nov 2019 15:07:00 +0000</pubDate>
<dc:creator>云中双月</dc:creator>
<og:description>&amp;emsp;&amp;emsp;本文讲解如何使用C 调用只有.h头文件的c++类的虚函数（非实例函数，因为非虚函数不存在于虚函数表，无法通过类对象偏移计算地址，除非用export导出，而gcc默认是全部导出实</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Johness/p/csharp-do-memory-call.html</dc:identifier>
</item>
<item>
<title>GDG Xi'an DevFest 2019 闪电演讲 -《假如我是一个浏览器》PPT（经典多图，建议收藏） - 大史不说话</title>
<link>http://www.cnblogs.com/dashnowords/p/11946246.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dashnowords/p/11946246.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354575/201911/1354575-20191127223601944-1361399399.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;2.7857142857143&quot;&gt;
&lt;p&gt;GDG Xi'an DevFest2019演讲PPT链接：&lt;br/&gt;&lt;a href=&quot;http://tmp.link/f/5dd9e6bf461b6&quot; class=&quot;uri&quot;&gt;http://tmp.link/f/5dd9e6bf461b6&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;2.8032786885246&quot;&gt;
&lt;p&gt;闪电演讲《假如我是一个浏览器》PPT链接：&lt;br/&gt;&lt;a href=&quot;https://github.com/dashnowords/blogs/tree/master/Demo/DevFest2019&quot; class=&quot;uri&quot;&gt;https://github.com/dashnowords/blogs/tree/master/Demo/DevFest2019&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;2.8356164383562&quot;&gt;
&lt;p&gt;关于我的一篇鸡汤文，献给所有努力中的野生前端：&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/7Eb-JfGvQ2x5woI4Z5HYMw&quot;&gt;仰望星空的人，不应该被嘲笑--DevFest闪电演讲嘉宾--史文强&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;摘要&quot;&gt;摘要&lt;/h3&gt;
&lt;p&gt;内容讲述了HTML，CSS和JavaScript文件从代码到浏览器中图形的基本过程，实际上每个阶段正好代表了高级前端工程师可以选择的三大细分方向——架构师，工程化，图形学。PPT基本上全是图，引用了一些知名的前端神图，大部分都是自己一点点做的，毕竟图的表现力比文字要生动直观一些，&lt;strong&gt;原稿几乎每一页都加了备注！！！&lt;/strong&gt;，有需要的可以在我的博客或者GDG西安官方公众号获取到。&lt;/p&gt;
&lt;h3 id=&quot;作者简介&quot;&gt;作者简介&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354575/201911/1354575-20191127224330465-1591308855.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;请求阶段&quot;&gt;请求阶段&lt;/h3&gt;
&lt;p&gt;请求阶段从解析DNS开始，它是一个递归的过程，可以在Linux系统中使用dig+trace工具进行追踪查看；查询到地址后就需要开始建立连接（三次握手建立连接），然后从服务器获取第一个文件，通常是index.html，获取到文件后就需要根据响应头里的信息进行一些处理，对这块不太熟悉的同学可以阅读《图解Http》一书，强制缓存和协商缓存这一块是很重要的考点，index.html在解析时可能还会碰到请求其他资源的情况，这时又会引出CDN等等其他话题，本次分享中并未涉及。如果对于前端可用性及资源部署方面感兴趣，可以考虑向架构师的方向发展，也就是只将前端应用视为整个链路中的一环，尝试去关注整个链路中各个环节，前端工程师切入时并不需要特别关注去解决细枝末节的技术问题，那毕竟需要时间和经验的积累，请记住你是有伙伴的，我个人比较推荐前端工程师尝试建设全链路的异常监控体系，去了解各个环节有哪些关键指标，如何去呈现，如何去判断异常等等，以尽可能稳定有效的方式把关键信息呈现给能解决问题的人。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354575/201911/1354575-20191127224635371-112885647.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354575/201911/1354575-20191127224643543-2052552928.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354575/201911/1354575-20191127224651497-147099445.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354575/201911/1354575-20191127224701360-315491945.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354575/201911/1354575-20191127224710358-657052447.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;解析阶段&quot;&gt;解析阶段&lt;/h3&gt;
&lt;p&gt;我在分享时已经提及过，解析阶段的关键词就是“编译原理”，前端基础的HTML，CSS，JS，以及常见的工程化工具例如Webpack，Babel，Eslint等等，全部都是基于编译原理来运作的，如果从纯学术的角度来看，它的确很晦涩，但是从应用的角度来理解，实际上无论是分词，转换还是遍历AST以及最终的代码生成，实际上都是看得见摸得着的，并不算特别难理解，B站上有很多国内外的《编译原理》课程录像，你懂的（B站真的是学习用的）。其中还涉及到了一些基本的数据结构和基础算法的知识，这里的知识是对基本功的硬考验，也就是“设计模式”“数据结构”和“基础算法”的三座大山，爬山很慢，但真的很值。这一块的知识可以翻看朱永盛的《Webkit技术内幕》一书，慎重，没有老司机带的话这本书很容易看的人怀疑人生。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354575/201911/1354575-20191127224951061-1279612368.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354575/201911/1354575-20191127224957289-160394948.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354575/201911/1354575-20191127225004132-593038409.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354575/201911/1354575-20191127225010622-1543634357.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354575/201911/1354575-20191127225015725-1591529192.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354575/201911/1354575-20191127225020392-1298965088.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354575/201911/1354575-20191127225025618-1061734374.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354575/201911/1354575-20191127225031498-1107616509.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354575/201911/1354575-20191127225135319-729176344.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354575/201911/1354575-20191127225047945-1403142634.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;种树阶段&quot;&gt;种树阶段&lt;/h3&gt;
&lt;p&gt;种树阶段只是戏称，就是为了不同的目的构建了许许多多的树和层。HTML解析后生成DOM树，它表示文档的结构，CSS在内部优化时也会生成树，为了将用于渲染的信息整合在一起，两者被合并生成了RenderObject树，为了解决层叠顺序问题，又在此基础上生成了RenderLayer层，为了利用硬件加速渲染，又为满足另一些条件的层生成CompositingLayer合成层，合成层又使用GraphicsLayer来进行后端存储。概念之多，相对复杂。为了排除干扰，本次分享中并没有讲述Chrome浏览器的多进程模型和多线程结构，它们只是为了更好更高效地处理好关键渲染步骤，一次性信息量太大反而会影响吸收。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354575/201911/1354575-20191127225335675-263697414.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354575/201911/1354575-20191127225345172-996881809.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354575/201911/1354575-20191127225351184-1722694281.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354575/201911/1354575-20191127225357080-1107892227.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354575/201911/1354575-20191127225403135-908446038.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354575/201911/1354575-20191127225434763-1315387534.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354575/201911/1354575-20191127225440577-857873663.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;画画阶段&quot;&gt;画画阶段&lt;/h3&gt;
&lt;p&gt;画画阶段实际上是指将对象信息通过光栅化处理后得到位图信息并展示在显示器上的过程，PPT中并没有涉及，它涉及到很多图形学相关的知识，基本的WebGL以及Chromium渲染管线方面的知识。对此感兴趣的读者可以扫描下面的二维码关注我技术博客中&lt;a href=&quot;https://www.cnblogs.com/dashnowords/p/11680067.html&quot;&gt;《Web高性能动画及渲染原理》&lt;/a&gt;系列博文，比较详细地描述了这部分相关知识。最后提一下，原稿最后一页的资料在播放模式下都可以直接点击跳转，还有每一页的备注信息如果看不见可能需要手动把画面向上拖拽缩小一点。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354575/201911/1354575-20191127225457123-1891325650.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354575/201911/1354575-20191127225829257-1929263959.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;硬广时间&quot;&gt;硬广时间&lt;/h3&gt;
&lt;p&gt;我的博文集《大史住在大前端》是关于前端基础的文章，扫下面右边的二维码就可以看到，基本都是系列专题，没有太多关于三大框架或是热门技术的东西，都是基础基础基础，或许会对你有帮助。最后再次感谢GDGXi'an提供的这次机会，让我认识了好多好多优秀的大佬和开发者。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354575/201911/1354575-20191127225856068-1949429014.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354575/201911/1354575-20191127225924932-839733944.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 27 Nov 2019 15:00:00 +0000</pubDate>
<dc:creator>大史不说话</dc:creator>
<og:description>GDG Xi'an DevFest2019演讲PPT链接： 'http://tmp.link/f/5dd9e6bf461b6' 闪电演讲《假如我是一个浏览器》PPT链接： 'https://githu</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/dashnowords/p/11946246.html</dc:identifier>
</item>
<item>
<title>Java学习笔记 线程池使用及详解 - Stars-one</title>
<link>http://www.cnblogs.com/kexing/p/11946197.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kexing/p/11946197.html</guid>
<description>&lt;p&gt;有点笨，参考了好几篇大佬们写的文章才整理出来的笔记....&lt;/p&gt;
&lt;p&gt;字面意思上解释，线程池就是装有线程的池，我们可以把要执行的多线程交给线程池来处理，和连接池的概念一样，通过维护一定数量的线程池来达到多个线程的复用。&lt;/p&gt;
&lt;h2 id=&quot;好处&quot;&gt;好处&lt;/h2&gt;
&lt;h3 id=&quot;多线程产生的问题&quot;&gt;多线程产生的问题&lt;/h3&gt;
&lt;p&gt;一般我们使用到多线程的编程的时候，需要通过&lt;code&gt;new Thread(xxRunnable).start()&lt;/code&gt;创建并开启线程，我们可以使用多线程来达到最优效率（如多线程下载）。&lt;/p&gt;
&lt;p&gt;但是，线程不是越多就越好，线程过多，创建和销毁就会消耗系统的资源，也不方便管理。&lt;/p&gt;
&lt;p&gt;除此之外，多线程还会造成并发问题，线程并发数量过多，抢占系统资源从而导致阻塞。&lt;/p&gt;
&lt;h3 id=&quot;线程池优点&quot;&gt;线程池优点&lt;/h3&gt;
&lt;p&gt;我们将线程放入线程池，由线程池对线程进行管理，可以对线程池中缓冲的线程进行复用，这样，就不会经常去创建和销毁线程了，从而省下了系统的资源。&lt;/p&gt;
&lt;p&gt;线程池能够有效的控制线程并发的数量，能够解决多线程造成的并发问题。&lt;/p&gt;
&lt;p&gt;除此之外，线程池还能够对线程进行一定的管理，如延时执行、定时循环执行的策略等&lt;/p&gt;
&lt;h2 id=&quot;线程池实现&quot;&gt;线程池实现&lt;/h2&gt;
&lt;p&gt;线程池的实现，主要是通过这个类&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;，其的构造参数非常长，我们先大概了解，之后再进行详细的介绍。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public ThreadPoolExecutor(int corePoolSize,
    int maximumPoolSize,long keepAliveTime,
    TimeUnit unit,BlockingQueue workQueue,
    RejectedExecutionHandler handler)&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;corePoolSize：线程池核心线程数量&lt;/li&gt;
&lt;li&gt;maximumPoolSize：线程池最大线程数量&lt;/li&gt;
&lt;li&gt;keepAliverTime：当活跃线程数大于核心线程数时，空闲的多余线程最大存活时间&lt;/li&gt;
&lt;li&gt;unit：存活时间的单位&lt;/li&gt;
&lt;li&gt;workQueue：存放线程的工作队列&lt;/li&gt;
&lt;li&gt;handler：超出线程范围和队列容量的任务的处理程序（拒绝策略）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里大概简单说明一下线程池的运行流程：&lt;/p&gt;
&lt;p&gt;当线程被添加到线程池中，如果线程池中的当前的线程数量等于线程池定义的最大核心线程数量（corePoolSize)了，此线程就会别放入线程的工作队列(workQueue)中，等待线程池的调用。&lt;/p&gt;
&lt;p&gt;Java提供了一个工具类&lt;code&gt;Excutors&lt;/code&gt;，方便我们快速创建线程池，其底层也是调用了&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;不过阿里巴巴Java规范中强制要求我们应该通过&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;来创建自己的线程池，使用&lt;code&gt;Excutors&lt;/code&gt;容易造成OOM问题。&lt;/p&gt;
&lt;p&gt;所以，我们先从&lt;code&gt;Excutors&lt;/code&gt;开始学习，之后在对&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;进行详细的讲解&lt;/p&gt;
&lt;h3 id=&quot;excutors&quot;&gt;Excutors&lt;/h3&gt;
&lt;p&gt;由于&lt;code&gt;Excutors&lt;/code&gt;是工具类，所以下面的介绍的都是其的静态方法，如果是比较线程数目比较少的小项目，可以使用此工具类来创建线程池&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PS：把线程提交给线程池中，有两种方法，一种是submit，另外一种则是execute&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;两者的区别：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;execute没有返回值，如果不需要知道线程的结果就使用execute方法，性能会好很多。&lt;/li&gt;
&lt;li&gt;submit返回一个Future对象，如果想知道线程结果就使用submit提交，而且它能在主线程中通过Future的get方法捕获线程中的异常&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;线程池可以接收两种的参数，一个为Runnable对象，另外则是Callable对象&lt;/p&gt;
&lt;p&gt;Callable是JDK1.5时加入的接口，作为Runnable的一种补充，允许有返回值，允许抛出异常。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主要的几个静态方法：&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;9&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;newFixedThreadPool(int nThreads)&lt;/td&gt;
&lt;td&gt;创建固定大小的线程池&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;newSingleThreadExecutor()&lt;/td&gt;
&lt;td&gt;创建只有一个线程的线程池&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;newCachedThreadPool()&lt;/td&gt;
&lt;td&gt;创建一个不限线程数上限的线程池，任何提交的任务都将立即执行&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;newScheduledThreadPool(int nThreads)&lt;/td&gt;
&lt;td&gt;创建一个支持定时、周期性或延时任务的限定线程数目的线程池&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;newSingleThreadScheduledExecutor()&lt;/td&gt;
&lt;td&gt;创建一个支持定时、周期性或延时任务的单个线程的线程池&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;newsinglethreadexecutor&quot;&gt;1.newSingleThreadExecutor&lt;/h4&gt;
&lt;p&gt;创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行，我们可以使用它来达到控制线程顺序执行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;控制进程顺序执行：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Thread thread1 = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    System.out.println(&quot;这是线程1&quot;);
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });
Thread thread2 = new Thread(new Runnable() {
    @Override
    public void run() {
        try {
            System.out.println(&quot;这是线程2&quot;);
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
});
Thread thread3 = new Thread(new Runnable() {
    @Override
    public void run() {
        try {
            System.out.println(&quot;这是线程3&quot;);
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
});
//创建线程池对象
ExecutorService executorService = Executors.newSingleThreadExecutor();
//把线程添加到线程池中
executorService.submit(thread1);
executorService.submit(thread2);
executorService.submit(thread3);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;之后出现的结果就是按照顺序输出&lt;/p&gt;
&lt;h4 id=&quot;newfixedthreadpool&quot;&gt;2.newFixedThreadPool&lt;/h4&gt;
&lt;p&gt;创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。定长线程池的大小最好根据系统资源进行设置。如&lt;code&gt;Runtime.getRuntime().availableProcessors()&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;newcachedthreadpool&quot;&gt;3.newCachedThreadPool&lt;/h4&gt;
&lt;p&gt;创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程，线程池为无限大，当执行第二个任务时第一个任务已经完成，会复用执行第一个任务的线程，而不用每次新建线程。&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//创建了一个自定义的线程
public class MyThread extends Thread {
    private int index;

    public MyThread(int index) {
        this.index = index;
    }

    @Override
    public void run() {
        System.out.println(index+&quot; 当前线程&quot;+Thread.currentThread().getName());
    }
}

//创建缓存线程池
ExecutorService executorService = Executors.newCachedThreadPool();
for (int i = 0; i &amp;lt; 10; i++) {
    executorService.execute(new MyThread(i));
    try {
        //这里模拟等待时间，等待线程池复用回收线程
        Thread.sleep(1000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到结果都是使用的同一个线程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1210268/201911/1210268-20191127170905778-322116256.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;newscheduledthreadpool&quot;&gt;4.newScheduledThreadPool&lt;/h4&gt;
&lt;p&gt;创建一个定长线程池，支持定时、周期性或延时任务执行&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;延迟1s后启动线程：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(2);
scheduledExecutorService.schedule(new MyThread(1),1, TimeUnit.SECONDS);&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;threadpoolexecutor&quot;&gt;ThreadPoolExecutor&lt;/h2&gt;
&lt;h3 id=&quot;构造方法&quot;&gt;构造方法&lt;/h3&gt;
&lt;p&gt;上面提到的那个构造方法其实只是&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;类中的一个，&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;类中存在有四种不同的构造方法，主要区别就是参数不同。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//五个参数的构造函数
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue&amp;lt;Runnable&amp;gt; workQueue)

//六个参数的构造函数-1
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue&amp;lt;Runnable&amp;gt; workQueue,
                          ThreadFactory threadFactory)

//六个参数的构造函数-2
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue&amp;lt;Runnable&amp;gt; workQueue,
                          RejectedExecutionHandler handler)

//七个参数的构造函数
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue&amp;lt;Runnable&amp;gt; workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先，有个概念需要明白，线程池的最大线程数（线程总数,maximumPoolSize）= 核心线程数(corePoolSize)+非核心线程数&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;corePoolSize：线程池核心线程数量&lt;/li&gt;
&lt;li&gt;maximumPoolSize：线程池最大线程数量&lt;/li&gt;
&lt;li&gt;keepAliverTime：当活跃线程数大于核心线程数时，空闲的多余线程最大存活时间&lt;/li&gt;
&lt;li&gt;unit：存活时间的单位&lt;/li&gt;
&lt;li&gt;workQueue：存放线程的工作队列&lt;/li&gt;
&lt;li&gt;handler：超出线程范围和队列容量的任务的处理程序（拒绝策略）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;核心线程和非核心线程有什么区别呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;核心线程是永远不会被线程池丢弃回收（即使核心线程没有工作），非核心线程则是超过一定时间（keepAliverTime)则就会被丢弃&lt;/p&gt;
&lt;h4 id=&quot;workqueue&quot;&gt;workQueue&lt;/h4&gt;
&lt;p&gt;当所有的核心线程都在工作时，新添加的任务会被添加到这个队列中等待处理，如果队列满了，则新建非核心线程执行任务&lt;/p&gt;
&lt;blockquote readability=&quot;22&quot;&gt;
&lt;p&gt;1.&lt;strong&gt;SynchronousQueue&lt;/strong&gt;：这个队列接收到任务的时候，会直接提交给线程处理，而不保留它，如果所有线程都在工作怎么办？那就新建一个线程来处理这个任务！所以为了保证不出现&lt;code&gt;线程数达到了maximumPoolSize而不能新建线程&lt;/code&gt;的错误，使用这个类型队列的时候，maximumPoolSize一般指定成Integer.MAX_VALUE，即无限大&lt;/p&gt;
&lt;p&gt;2.&lt;strong&gt;LinkedBlockingQueue&lt;/strong&gt;：这个队列接收到任务的时候，如果当前线程数小于核心线程数，则新建线程(核心线程)处理任务；如果当前线程数等于核心线程数，则进入队列等待。由于这个队列没有最大值限制，即所有超过核心线程数的任务都将被添加到队列中，这也就导致了maximumPoolSize的设定失效，因为总线程数永远不会超过corePoolSize&lt;/p&gt;
&lt;p&gt;3.&lt;strong&gt;ArrayBlockingQueue&lt;/strong&gt;：可以限定队列的长度，接收到任务的时候，如果没有达到corePoolSize的值，则新建线程(核心线程)执行任务，如果达到了，则入队等候，如果队列已满，则新建线程(非核心线程)执行任务，又如果总线程数到了maximumPoolSize，并且队列也满了，则发生错误&lt;/p&gt;
&lt;p&gt;4.&lt;strong&gt;DelayQueue&lt;/strong&gt;：队列内元素必须实现Delayed接口，这就意味着你传进去的任务必须先实现Delayed接口。这个队列接收到任务时，首先先入队，只有达到了指定的延时时间，才会执行任务&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;拒绝策略&quot;&gt;拒绝策略：&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.yuque.com/lark/2018/png/54845/1521946099154-17b29e18-6853-4b39-8e2a-007ea89387bd.png&quot;/&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;AbortPolicy&lt;/td&gt;
&lt;td&gt;抛出RejectedExecutionException异常(默认)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;DiscardPolicy&lt;/td&gt;
&lt;td&gt;不处理，丢弃掉&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;DiscardOldestPolicy&lt;/td&gt;
&lt;td&gt;丢弃执行队列中等待最久的一个任务，尝试为新来的任务腾出位置&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;CallerRunsPolicy&lt;/td&gt;
&lt;td&gt;直接由提交任务者执行这个任务&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;两种方法设置拒绝策略：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//ThreadPoolExecutor对象的setRejectedExecutionHandler方法设置
ThreadPoolExecutor threadPool = new ThreadPoolExecutor(2, 5, 60, TimeUnit.SECONDS, queue);
threadPool.setRejectedExecutionHandler(new ThreadPoolExecutor.AbortPolicy());
//构造方法进行设置，省略&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;线程池默认的拒绝行为是AbortPolicy，也就是抛出RejectedExecutionHandler异常，该异常是非受检异常，很容易忘记捕获。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果不关心任务被拒绝的事件，可以将拒绝策略设置成DiscardPolicy&lt;/strong&gt;，这样多余的任务会悄悄的被忽略。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;threadfactory&quot;&gt;ThreadFactory&lt;/h4&gt;
&lt;p&gt;一个接口类，用来对线程进行设置，需要实现newThread(Runnable r)方法&lt;/p&gt;
&lt;p&gt;官方的文档说明:&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;code&gt;newThread&lt;/code&gt;此方法一般来初始化线程的优先级(priority)，名字(name)，守护进程(daemon)或线程组(ThreadGroup)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;简单的例子（让某个类实现ThreadFactory接口）：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Override
public Thread newThread(Runnable r) {
    Thread thread = new Thread(r);
    thread.setDaemon(true);
    return thread;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;线程池获取执行结果&quot;&gt;线程池获取执行结果&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;PS：把线程提交给线程池中，有两种方法，一种是submit，另外一种则是execute&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;两者的区别：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;execute没有返回值，如果不需要知道线程的结果就使用execute方法，性能会好很多。&lt;/li&gt;
&lt;li&gt;submit返回一个Future对象，如果想知道线程结果就使用submit提交，而且它能在主线程中通过Future的get方法捕获线程中的异常&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;线程池可以接收两种的参数，一个为Runnable对象，另外则是Callable对象&lt;/p&gt;
&lt;p&gt;Callable是JDK1.5时加入的接口，作为Runnable的一种补充，允许有返回值，允许抛出异常。&lt;/p&gt;
&lt;p&gt;线程池的处理结果、以及处理过程中的异常都被包装到Future中，并在调用Future.get()方法时获取，执行过程中的异常会被包装成ExecutionException，submit()方法本身不会传递结果和任务执行过程中的异常。&lt;/p&gt;
&lt;p&gt;获取执行结果的代码可以这样写：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ExecutorService executorService = Executors.newFixedThreadPool(4);
Future&amp;lt;Object&amp;gt; future = executorService.submit(new Callable&amp;lt;Object&amp;gt;() {
        @Override
        public Object call() throws Exception {
            //该异常会在调用Future.get()时传递给调用者
            throw new RuntimeException(&quot;exception in call~&quot;);
        }
    });
    
try {
    //获得返回结果
    Object result = future.get();
    
    
} catch (InterruptedException e) {
  // interrupt
} catch (ExecutionException e) {
  // exception in Callable.call()
  e.printStackTrace();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;线程池运行流程&quot;&gt;线程池运行流程&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;一个形象的比喻说明线程池的流程：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;规定：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;线程池比作成一家公司&lt;/li&gt;
&lt;li&gt;公司的最大员工数为maximumPoolSize&lt;/li&gt;
&lt;li&gt;最大正式员工数为coolPoolSize（核心线程的总数）&lt;/li&gt;
&lt;li&gt;最大员工数（maximumPoolSize） = 最大正式员工（coolPoolSize）和临时工（非核心线程）&lt;/li&gt;
&lt;li&gt;单子（任务）可看做为线程&lt;/li&gt;
&lt;li&gt;队列使用的是ArrayBlockingQueue&lt;/li&gt;
&lt;li&gt;一个员工只能干一个任务&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;最开始的时候，公司是没有一名员工。之后，公司接到了单子（任务），这个时候，公司才去找员工（创建核心线程并让线程开始执行），这个时候找到的员工就是正式员工了。&lt;/p&gt;
&lt;p&gt;公司的声誉越来越好，于是来了更多的单子，公司继续招人，直到正式员工数量达到最大的正式员工的数量（核心线程数量已达到最大）&lt;/p&gt;
&lt;p&gt;于是，多出来的单子就暂时地存放在了队列中，都在排队，等待正式员工们把手头的工作做完之后，就从队列中依次取出单子继续工作。&lt;/p&gt;
&lt;p&gt;某天，来了一个新单子，但是这个时候队列已经满了，公司为了自己的信誉和声誉着想，不得已只能去找临时工（创建非核心线程）来帮忙开始进行工作（负责新单子）&lt;/p&gt;
&lt;p&gt;在此之后，又来了新单子，公司继续去招临时工为新来的单子工作，直到正式工和临时工的数量已经达到了公司最大员工数。&lt;/p&gt;
&lt;p&gt;这个时候，公司没有办法了，只能拒绝新来的单子了（拒绝策略）&lt;/p&gt;
&lt;p&gt;此时，正式工和临时工都是在加班加点去从队列中取出任务来工作，终于某一天，队列的已经没有单子了，市场发展不好，单子越来越少，临时工很久都不工作了（非核心线程超过了最大存活时间keepAliveTime)，公司就把这些临时工解雇了，直到剩下只有正式员工。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PS:如果也想要解雇正式员工(销毁核心线程)，可以设置&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;对象的的&lt;code&gt;allowCoreThreadTimeOut&lt;/code&gt;这个属性为&lt;code&gt;true&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;个人理解，可能不是很正确，仅供参考！&lt;/p&gt;
&lt;h3 id=&quot;线程池关闭&quot;&gt;线程池关闭&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;shutdown()&lt;/td&gt;
&lt;td&gt;不再接受新的任务，之前提交的任务等执行结束再关闭线程池&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;shutdownNow()&lt;/td&gt;
&lt;td&gt;不再接受新的任务，试图停止池中的任务再关闭线程池，返回所有未处理的线程list列表。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;参考链接：&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;https://jingyan.baidu.com/album/3f16e00380ced06591c103b9.html?picindex=2&quot;&gt;java中常用线程池的：newCachedThreadPool&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/CarpenterLee/p/9558026.html&quot;&gt;Java线程池详解&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000018399962?utm_source=tag-newest&quot;&gt;Java 线程池的认识和使用&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_36759405/article/details/82825634&quot;&gt;Java 线程池全面解析&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://liuzho.github.io/2017/04/17/%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%8C%E8%BF%99%E4%B8%80%E7%AF%87%E6%88%96%E8%AE%B8%E5%B0%B1%E5%A4%9F%E4%BA%86/&quot;&gt;线程池，这一篇或许就够了&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/zw19910924/article/details/80298593&quot;&gt;Java线程池的运行原理以及使用详解&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 27 Nov 2019 14:54:00 +0000</pubDate>
<dc:creator>Stars-one</dc:creator>
<og:description>有点笨，参考了好几篇大佬们写的文章才整理出来的笔记.... 字面意思上解释，线程池就是装有线程的池，我们可以把要执行的多线程交给线程池来处理，和连接池的概念一样，通过维护一定数量的线程池来达到多个线程</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kexing/p/11946197.html</dc:identifier>
</item>
</channel>
</rss>