<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>GitHub 热点速览 Vol.35：Let's Go，Rust 大放异彩 - 削微寒</title>
<link>http://www.cnblogs.com/xueweihan/p/13589386.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xueweihan/p/13589386.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202008/759200-20200831142659366-1060806445.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;摘要：语言之争，一直存在于各类社群，不论是单个编程语言的交流群，亦或是 NoSQL、云开发等技术群，总能看到“要不要换 Go”、“Rust 比 C++ 更强”的影子。撇开语言特性，本周的热点趋势周榜上 Rust 和 Go 开发的项目表现都很良好，比如，搜索引擎：MeiliSearch，虽然 ES 在搜索这块独占鳌头，但是 MeiliSearch 凭借它的轻巧、易上手等特性也是圈了一波粉，ultimate-go 这个 Go 学习指南也是一周网罗了千粉，榜上有名…&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以下内容摘录自微博&lt;a href=&quot;https://www.weibo.com/hellogithub/&quot;&gt;@HelloGitHub&lt;/a&gt; 的 GitHub Trending 及 Hacker News 热帖（简称 HN 热帖），选项标准：&lt;code&gt;新发布&lt;/code&gt; | &lt;code&gt;实用&lt;/code&gt; | &lt;code&gt;有趣&lt;/code&gt;，根据项目 release 时间分类，发布时间不超过 7 day 的项目会标注 &lt;code&gt;New&lt;/code&gt;，无该标志则说明项目 release 超过一周。由于本文篇幅有限，还有部分项目未能在本文展示，望周知 🌝&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;本文目录
&lt;ul&gt;&lt;li&gt;
&lt;ol&gt;&lt;li&gt;本周特推&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;1.1 终极 Go 指南：ultimate-go&lt;/li&gt;
&lt;li&gt;1.2 免费书籍：free-programming-books&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;GitHub Trending 周榜&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;2.1 强大的搜索引擎：MeiliSearch&lt;/li&gt;
&lt;li&gt;2.2 科技酷炫 UI 框架：arwes&lt;/li&gt;
&lt;li&gt;2.3 自学笔记：CS-Notes&lt;/li&gt;
&lt;li&gt;2.4 数据驱动游戏引擎：Bevy&lt;/li&gt;
&lt;li&gt;2.5 Facebook 开源 ORM 框架：ent&lt;/li&gt;
&lt;li&gt;2.6 自动化安全调用 C++：autocxx&lt;/li&gt;
&lt;li&gt;2.7 制作可启动 U 盘工具：Ventoy&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;Emoji Time&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;推荐阅读&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;1-本周特推&quot;&gt;1. 本周特推&lt;/h2&gt;
&lt;h3 id=&quot;11-终极-go-指南：ultimate-go&quot;&gt;1.1 终极 Go 指南：ultimate-go&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：1300+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ultimate-go 是作者学习 Ardan Labs 的终极 Go 课程中学习 Go 编程语言时的笔记汇总，作者通过实例来学习 Golang，直接对源代码进行注释，以确保阅读时理解了每一行代码，并注意到背后的理论。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/hoanhan101/ultimate-go&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202008/759200-20200831142715683-365578441.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;12-免费书籍：free-programming-books&quot;&gt;1.2 免费书籍：free-programming-books&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：1050+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;free-programming-books 是一个收录免费编程书籍的项目，它分为语言无关（IDE、版本控制、正则表达式…）和语言相关（Dart、Golang、Java…）两大类，相对而言是一个比较全面的系统的编程学习资料，目前项目已经被翻译成了 20+ 个语言版本，如果你手头有不错的资源也可以提个 issue 来资源共享一番~&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/EbookFoundation/free-programming-books&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202008/759200-20200831142718666-664754435.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;2-github-trending-周榜&quot;&gt;2. GitHub Trending 周榜&lt;/h2&gt;
&lt;h3 id=&quot;21-强大的搜索引擎：meilisearch&quot;&gt;2.1 强大的搜索引擎：MeiliSearch&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：1050+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MeiliSearch 是一个快捷、易用且易部署的全文搜索引擎，支持自定义搜索和索引，支持容错搜索、过滤器和同义词、汉字分词库“结巴”等。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/meilisearch/MeiliSearch&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202008/759200-20200831142734020-1191937000.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;22-科技酷炫-ui-框架：arwes&quot;&gt;2.2 科技酷炫 UI 框架：arwes&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：2400+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Arwes 是一个基于未来科幻小说和赛博朋克风格、动画和音效为 Web 应用程序构建用户界面的 Web 框架，项目基于 React、JSS、Anime 和 Howler。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/arwes/arwes&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202008/759200-20200831142919713-529000284.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;23-自学笔记：cs-notes&quot;&gt;2.3 自学笔记：CS-Notes&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：1200+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;New&lt;/code&gt; CS-Notes 是字节跳动一名非科班程序员的自学笔记，目前收录了 C++、算法、操作系统笔记，后续将更新分布式系统知识，在该 repo 里作者也分享了他面试心得体会、转行相关随感，一些他用的到编程效率工具。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/huangrt01/CS-Notes&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202008/759200-20200831142940555-2081520618.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;24-数据驱动游戏引擎：bevy&quot;&gt;2.4 数据驱动游戏引擎：Bevy&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：700+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Bevy 是一个用 Rust 编写的一款简单数据驱动游戏引擎。设计目标为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;提供完整 2D/3D 功能集&lt;/li&gt;
&lt;li&gt;新手易上手，高级用户可灵活使用&lt;/li&gt;
&lt;li&gt;以数据为中心，使用实体组件系统范式的面向数据架构&lt;/li&gt;
&lt;li&gt;模块化，可随意替换你不喜欢的模块&lt;/li&gt;
&lt;li&gt;快速运行，并行运行&lt;/li&gt;
&lt;li&gt;生产可用，快速编译变更，毕竟等待不是件有趣的事&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;除了官方的特性、目标之外，使用者觉得它还有以下特性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Bevy ECS：具有无与伦比的可用性和超快性能的自定义实体组件系统&lt;/li&gt;
&lt;li&gt;渲染图：使用“渲染图”节点轻松构建自己的多线程渲染管道&lt;/li&gt;
&lt;li&gt;Bevy UI：专为 Bevy 构建的自定义 ECS 驱动的 UI 框架&lt;/li&gt;
&lt;li&gt;高效的编译时间：使用“快速编译”配置，预期更改将在约 0.8-3.0 秒内完成编译&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/bevyengine/bevy&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202008/759200-20200831142947704-1699322524.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;25-facebook-开源-orm-框架：ent&quot;&gt;2.5 Facebook 开源 ORM 框架：ent&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：750+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ent 是由 Facebook Connectivity 团队创建的 ORM 框架。迫于 Go 社区中缺少能够像图一样查询数据的工具，同时也缺少 100% 类型安全的 ORM，ent 就是被设计出来解决这些问题的。ent 的详细介绍可以参考 darluc 翻译的&lt;a href=&quot;https://v2ex.com/t/683589&quot;&gt;【[译文] Go:ent，基于图的 ORM 框架 - Facebook 出品】&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/facebook/ent&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202008/759200-20200831142954672-740203594.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;26-自动化安全调用-c：autocxx&quot;&gt;2.6 自动化安全调用 C++：autocxx&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：350+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;New&lt;/code&gt; autocxx 是一个以高度自动化、安全地从 Rust 调用 C++ 的工具。这样做的目的是，在使用 bindgen 变体从现有的 C++ 头文件自动生成接口的同时，它具有来自 CXX 的流畅、安全性。可以把 autocxx 看作是将 bindgen 插入 cxx 的胶水。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/google/autocxx&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202008/759200-20200831143000667-1710420389.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;27-制作可启动-u-盘工具：ventoy&quot;&gt;2.7 制作可启动 U 盘工具：Ventoy&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：1200+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Ventoy 是一款国人开发的新一代多 ISO 启动引导程序，这款工具最大的优点就是无需格式化优盘，用户只需要将所需的 ISO 镜像文件拷贝至优盘中即可在 Ventoy 界面中选择自己想要的 ISO 镜像文件。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/ventoy/Ventoy&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202008/759200-20200831143006102-122816238.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;3-ttime&quot;&gt;3. TTime&lt;/h2&gt;
&lt;p&gt;Talk Time (&lt;sup&gt;o&lt;/sup&gt;)/ 本周下选取了多个 Go、Rust 开源项，来#说说你主要用的编程语言#是什么吧 [吃瓜] 不知道本周的几个项目合不合 Rust 和 Go 同学胃口呢~~&lt;/p&gt;
&lt;h2 id=&quot;4-推荐阅读&quot;&gt;4. 推荐阅读&lt;/h2&gt;
&lt;p&gt;以上为 2020 年第 35 个工作周的 GitHub Trending 🎉如果你 Pick 其他好玩、实用的 GitHub 项目，记得来 &lt;a href=&quot;https://github.com/521xueweihan/HelloGitHub&quot;&gt;HelloGitHub&lt;/a&gt; issue 区和我们分享下哟 🌝&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;HelloGitHub 交流群现已全面开放，添加微信号：HelloGitHub 为好友入群，可同前端、Java、Go 等各界大佬谈笑风生、切磋技术~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202008/759200-20200825184537931-2074943966.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关注 HelloGitHub 公众号&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 01 Sep 2020 00:31:00 +0000</pubDate>
<dc:creator>削微寒</dc:creator>
<og:description>摘要：语言之争，一直存在于各类社群，不论是单个编程语言的交流群，亦或是 NoSQL、云开发等技术群，总能看到“要不要换 Go”、“Rust 比 C++ 更强”的影子。撇开语言特性，本周的热点趋势周榜上</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xueweihan/p/13589386.html</dc:identifier>
</item>
<item>
<title>【Flutter 实战】17篇动画系列文章带你走进自定义动画 - 老孟Flutter</title>
<link>http://www.cnblogs.com/mengqd/p/13594076.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mengqd/p/13594076.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200901072606348-604169196.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;老孟导读：Flutter 动画系列文章分为三部分：基础原理和核心概念、系统动画组件、8篇自定义动画案例，共17篇。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;动画核心概念&quot;&gt;动画核心概念&lt;/h2&gt;
&lt;p&gt;在开发App的过程中，自定义动画必不可少，Flutter 中想要自定义动画，首先要理解 Flutter 动画实现的基本原理及相关概念。&lt;/p&gt;
&lt;p&gt;第1-4篇介绍了 Flutter 动画中最重要的三个概念以及三者之间的关系：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;AnimationController：动画控制器，控制动画的播放、停止等。继承自Animation&amp;lt; double &amp;gt;，是一个特殊的Animation对象，默认情况下它会线性的生成一个0.0到1.0的值，类型只能是 double 类型，不设置动画曲线的情况下，可以设置输出的最小值和最大值。&lt;/li&gt;
&lt;li&gt;Curve：动画曲线，作用和Android中的Interpolator（差值器）类似，负责控制动画变化的速率，通俗地讲就是使动画的效果能够以匀速、加速、减速、抛物线等各种速率变化。&lt;/li&gt;
&lt;li&gt;Tween：将 AnimationController 生成的 [0,1]值映射成其他属性的值，比如颜色、样式等。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;第5篇讲解了&lt;strong&gt;动画序列 TweenSequence&lt;/strong&gt;，其将多个 Tween 或者 Curve 关联到一个 AnimationController 中。&lt;/p&gt;
&lt;p&gt;文章链接：&lt;/p&gt;
&lt;h2 id=&quot;系统动画组件&quot;&gt;系统动画组件&lt;/h2&gt;
&lt;p&gt;第6篇介绍了20多种系统动画组件的用法以及如何选取使用哪一种组件，乍一看20多种系统动画组件非常多，但其仅分为&lt;strong&gt;隐式动画组件&lt;/strong&gt; 和 &lt;strong&gt;显式动画组件&lt;/strong&gt; 两种，用法基本一样。文章地址：&lt;a href=&quot;http://laomengit.com/guide/animation/AnimatedWidget.html&quot;&gt;http://laomengit.com/guide/animation/AnimatedWidget.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;第7篇讲解 &lt;strong&gt;AnimatedList&lt;/strong&gt; 列表增/删动画组件：&lt;a href=&quot;http://laomengit.com/guide/animation/AnimatedList.html&quot;&gt;http://laomengit.com/guide/animation/AnimatedList.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200901072606858-1202031591.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第8篇讲解 &lt;strong&gt;Hero&lt;/strong&gt; 共享动画组件：&lt;a href=&quot;http://laomengit.com/guide/animation/Hero.html&quot;&gt;http://laomengit.com/guide/animation/Hero.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200901072608316-2004687693.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第9篇讲解 &lt;strong&gt;Material motion&lt;/strong&gt; 动画，Material motion 是 Flutter 1.17 大会上 Flutter 团队发布的新的 Animations 软件包，该软件包提供了实现新的 Material motion 规范的预构建动画：&lt;a href=&quot;http://laomengit.com/guide/animation/TranslationAnimations.html&quot;&gt;http://laomengit.com/guide/animation/TranslationAnimations.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200901072609175-1158304972.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200901072609660-27235261.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;自定义动画&quot;&gt;自定义动画&lt;/h2&gt;
&lt;p&gt;第10篇&lt;strong&gt;案例-自定义路由动画&lt;/strong&gt;：&lt;a href=&quot;http://laomengit.com/guide/animation/NavigatorAnimation.html&quot;&gt;http://laomengit.com/guide/animation/NavigatorAnimation.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200901072610394-1443896567.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第11篇&lt;strong&gt;案例-“孔雀开屏”的动画效果&lt;/strong&gt;：&lt;a href=&quot;http://laomengit.com/guide/animation/Peacock.html&quot;&gt;http://laomengit.com/guide/animation/Peacock.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200901072610579-1126011991.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第12篇&lt;strong&gt;案例-自定义渐变进度条&lt;/strong&gt;：&lt;a href=&quot;http://laomengit.com/guide/animation/CircleProgress.html&quot;&gt;http://laomengit.com/guide/animation/CircleProgress.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200901072610796-487893784.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第13篇&lt;strong&gt;案例-自绘玫瑰&lt;/strong&gt;：&lt;a href=&quot;http://laomengit.com/guide/animation/Rose.html&quot;&gt;http://laomengit.com/guide/animation/Rose.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200901072611124-431297293.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第14篇&lt;strong&gt;案例-仿掘金点赞&lt;/strong&gt;：&lt;a href=&quot;http://laomengit.com/guide/animation/JuejinLike.html&quot;&gt;http://laomengit.com/guide/animation/JuejinLike.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200901072611371-8504484.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第15篇&lt;strong&gt;案例-酷炫的3D效果&lt;/strong&gt;：&lt;a href=&quot;http://laomengit.com/guide/animation/3DPerspective.html&quot;&gt;http://laomengit.com/guide/animation/3DPerspective.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200901072611800-1286978808.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200901072612216-751154972.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第16篇&lt;strong&gt;案例-涟漪效果&lt;/strong&gt;：&lt;a href=&quot;http://laomengit.com/guide/animation/WaterRipple.html&quot;&gt;http://laomengit.com/guide/animation/WaterRipple.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200901072612637-2039611999.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第17篇&lt;strong&gt;案例-雷达扫描效果&lt;/strong&gt;：&lt;a href=&quot;http://laomengit.com/guide/animation/Radar.html&quot;&gt;http://laomengit.com/guide/animation/Radar.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200901072613461-380245308.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;结尾&quot;&gt;结尾&lt;/h2&gt;
&lt;p&gt;很多人都觉得 Flutter 动画比较难，不好入门，很多读者也反馈如何才能自定义动画？下面是我对学习 Flutter 动画的一些方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一步：详细的阅读第1-5篇，也就是基础概念部分，当然对于初学者来说，阅读完后依然会迷茫，不理解，没关系，记住即可。&lt;/li&gt;
&lt;li&gt;第二步：使用系统动画组件完成一些简单的动画效果，照猫画虎，不要觉得使用系统组件没有用处，当你写完20多个系统动画组件的用法的时候，你一定对动画的认知有极大的提升。&lt;/li&gt;
&lt;li&gt;第三步：在回过头来，认认真真的阅读第1-5篇，相信我，你一定会有不一样的感觉。&lt;/li&gt;
&lt;li&gt;第四步：动画系列文章中有8篇为自定义动画案例，建议先根据动画效果独自完成，如果没有思路再参考文章。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;个人觉得只有通过&lt;strong&gt;多写&lt;/strong&gt;才能理解的更加深刻，&lt;strong&gt;纸上得来终觉浅，绝知此事要躬行&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;Flutter 动画系列已经全部完成，如果对你有所帮助，请不要吝惜你的&lt;strong&gt;赞&lt;/strong&gt; 和 &lt;strong&gt;转发&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;交流&quot;&gt;交流&lt;/h2&gt;
&lt;p&gt;老孟Flutter博客地址（330个控件用法）：&lt;a href=&quot;http://laomengit.com&quot;&gt;http://laomengit.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎加入Flutter交流群（微信：laomengit）、关注公众号【老孟Flutter】：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th/&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200901072614096-2083357501.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200901072614719-1026147116.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</description>
<pubDate>Mon, 31 Aug 2020 23:26:00 +0000</pubDate>
<dc:creator>老孟Flutter</dc:creator>
<og:description>老孟导读：Flutter 动画系列文章分为三部分：基础原理和核心概念、系统动画组件、8篇自定义动画案例，共17篇。 动画核心概念 在开发App的过程中，自定义动画必不可少，Flutter 中想要自定义</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mengqd/p/13594076.html</dc:identifier>
</item>
<item>
<title>总结java创建文件夹的4种方法及其优缺点-JAVA IO基础总结第三篇 - 字母哥博客</title>
<link>http://www.cnblogs.com/zimug/p/13594066.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zimug/p/13594066.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202009/1815316-20200901071250559-1494939548.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本文是Java IO总结系列篇的第3篇，前篇的访问地址如下：&lt;/p&gt;
&lt;p&gt;本文为大家介绍Java IO-创建文件夹的四种方法，及其优缺点的解析。&lt;strong&gt;如果您阅读完成，觉得此文对您有帮助，请给我点个赞，您的支持是我不竭的创作动力。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;1传统api创建文件夹方式&quot;&gt;1.传统API创建文件夹方式&lt;/h2&gt;
&lt;p&gt;Java传统的IO API种使用&lt;code&gt;java.io.File&lt;/code&gt;类中的&lt;code&gt;file.mkdir()&lt;/code&gt;和&lt;code&gt;file.mkdirs()&lt;/code&gt;方法创建文件夹&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;file.mkdir()&lt;/code&gt;创建文件夹成功返回true，失败返回false。如果被创建文件夹的父文件夹不存在也返回false.没有异常抛出。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;file.mkdirs()&lt;/code&gt;创建文件夹连同该文件夹的父文件夹，如果创建成功返回true，创建失败返回false。创建失败同样没有异常抛出。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;@Test
void testCreateDir1() {
   //“D:\data111”目录现在不存在
   String dirStr = &quot;D:\\data111\\test&quot;;
   File directory = new File(dirStr);

   //mkdir
   boolean hasSucceeded = directory.mkdir();
   System.out.println(&quot;创建文件夹结果（不含父文件夹）：&quot; + hasSucceeded);

   //mkdirs
   hasSucceeded = directory.mkdirs();
   System.out.println(&quot;创建文件夹结果（包含父文件夹）：&quot; + hasSucceeded);

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下：使用mkdir创建失败，使用mkdirs创建成功。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;创建文件夹结果（不含父文件夹）：false
创建文件夹结果（包含父文件夹）：true
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;大家可以看到，mkdir和mkdirs虽然可以创建文件，但是它们在异常处理的环节做的非常不友好。创建失败之后统一返回false，创建失败的原因没有说明。是父文件夹不存在所以创建失败？还是文件夹已经存在所以创建失败？还是因为磁盘IO原因导致创建文件夹失败？&lt;/p&gt;
&lt;h2 id=&quot;2-java-nio创建文件夹&quot;&gt;2. Java NIO创建文件夹&lt;/h2&gt;
&lt;p&gt;为了解决传统IO创建文件夹中异常失败处理问题不明确的问题，在Java的NIO中进行了改进。&lt;/p&gt;
&lt;h3 id=&quot;21-filescreatedirectory创建文件夹&quot;&gt;2.1. &lt;code&gt;Files.createDirectory&lt;/code&gt;创建文件夹&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;如果被创建文件夹的父文件夹不存在，则抛出&lt;code&gt;NoSuchFileException&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;如果被创建的文件夹已经存在，则抛出&lt;code&gt;FileAlreadyExistsException&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;如果因为磁盘IO出现异常，则抛出&lt;code&gt;IOException&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Path path = Paths.get(&quot;D:\\data222\\test&quot;);
Path pathCreate = Files.createDirectory(path);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;22filescreatedirectories创建文件夹及其父文件夹&quot;&gt;2.2.&lt;code&gt;Files.createDirectories&lt;/code&gt;创建文件夹及其父文件夹&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;如果被创建文件夹的父文件夹不存在，就创建它&lt;/li&gt;
&lt;li&gt;如果被创建的文件夹已经存在，就是用已经存在的文件夹，不会重复创建，没有异常抛出&lt;/li&gt;
&lt;li&gt;如果因为磁盘IO出现异常，则抛出&lt;code&gt;IOException&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Path path = Paths.get(&quot;D:\\data222\\test&quot;);
Path pathCreate = Files.createDirectorys(path);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另外大家要注意：NIO的API创建的文件夹返回值是Path，这样方便我们在创建完成文件夹之后继续向文件夹里面写入文件数据等操作。比传统IO只返回一个boolean值要好得多。&lt;/p&gt;
&lt;h2 id=&quot;欢迎关注我的博客，里面有很多精品合集&quot;&gt;欢迎关注我的博客，里面有很多精品合集&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;本文转载注明出处（必须带连接，不能只转文字）：&lt;a href=&quot;http://www.zimug.com&quot;&gt;字母哥博客&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;觉得对您有帮助的话，帮我点赞、分享！您的支持是我不竭的创作动力！&lt;/strong&gt; 。另外，笔者最近一段时间输出了如下的精品内容，期待您的关注。&lt;/p&gt;
</description>
<pubDate>Mon, 31 Aug 2020 23:13:00 +0000</pubDate>
<dc:creator>字母哥博客</dc:creator>
<og:description>本文是Java IO总结系列篇的第3篇，前篇的访问地址如下： 总结java中创建并写文件的5种方式-JAVA IO基础总结第一篇 总结java从文件中读取数据的6种方法-JAVA IO基础总结第二篇</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zimug/p/13594066.html</dc:identifier>
</item>
<item>
<title>《恰如其分的软件架构》笔记摘要 - 九卷</title>
<link>http://www.cnblogs.com/jiujuan/p/13594006.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jiujuan/p/13594006.html</guid>
<description>&lt;blockquote readability=&quot;4.7225806451613&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://book.douban.com/subject/24872314/&quot;&gt;《恰如其分的软件架构》&lt;/a&gt; 一书&lt;br/&gt;其实读起来感觉有点学术性质，换句话说，有点晦涩难懂。不知道是不是翻译的问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;书里提倡的按风险驱动的架构设计，还是值得借鉴的设计方法。我的理解就是“问题驱动法”。&lt;br/&gt;比如说目前业务有哪些难点，有哪些问题需要解决，用笔一一罗列出来，然后按照罗列的问题，&lt;br/&gt;去选择合适的技术，合适的架构，来解决这些问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;什么是软件架构？&quot;&gt;什么是软件架构？&lt;/h2&gt;
&lt;p&gt;软件架构就是系统设计，以及它对诸如性能、安全和可修改性等系统所产生的影响。&lt;br/&gt;软件架构抉择很重要，架构是系统骨骼，直接影响质量属性，并约束整个系统。&lt;/p&gt;
&lt;p&gt;从某个角度来说，架构与功能可以互相组合，只是不同组合有不同表现效果而已。&lt;/p&gt;
&lt;p&gt;利用模型和抽象概念去构建和解释系统架构。&lt;/p&gt;
&lt;p&gt;软件设计可分为软件架构和详细设计。&lt;/p&gt;
&lt;p&gt;软件架构的定义，来自卡内基.梅隆大学软件工程研究所（MEI）定义：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;计算系统的软件架构是解释给系统锁所需的结构体集合，其中包括：软件元素、元素之间的相互关系，以及二者各自的属性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;该定义的重点：元素、元素之间的关系以及元素的属性。&lt;/p&gt;
&lt;p&gt;架构是设计的宏观部分。&lt;/p&gt;
&lt;p&gt;架构是必须在项目早期做出的一组设计决策。&lt;/p&gt;
&lt;h2 id=&quot;软件架构为什么重要&quot;&gt;软件架构为什么重要&lt;/h2&gt;
&lt;p&gt;软件架构重要性在于它会影响整个软件的系统。只有审慎的选择架构，才能降低风险，避免失败。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;架构扮演者系统骨架的角色&lt;/li&gt;
&lt;li&gt;架构影响质量属性&lt;/li&gt;
&lt;li&gt;架构与功能（基本上）正交的&lt;/li&gt;
&lt;li&gt;架构还是对系统的约束&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;系统架构不仅要支持所需的功能，同时还能促进或者抑制诸如安全或性能等系统质量。&lt;br/&gt;作者举例：&lt;br/&gt;人和马的身体骨架都能够运输苹果到市场的功能，但是运输效率和数量上相差甚远。&lt;/p&gt;
&lt;p&gt;选择一种架构使得系统能够工作并不是难事，但满足质量属性方面，有的选择是事半功倍，有的选择则会事倍功半。&lt;/p&gt;
&lt;h2 id=&quot;架构何时变得重要&quot;&gt;架构何时变得重要&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;解空间小&lt;/strong&gt;：问题复杂，很难设计出好的解决方案，那么架构就显得尤为重要。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;翻译成 解，真不好理解&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;高的失败风险&lt;/strong&gt;：任何时候，失败的风险越高，就越需要保证正确架构&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;难以实现的质量属性&lt;/strong&gt;：架构会影响质量属性的能力。开发一个邮件系统并不难，然而，一般要求高性能支持百万级用户，就变得异常困难&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;我理解的质量属性：就是架构的目标，比如高可用，安全性，可伸缩等等。翻译成质量属性也比较难理解。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;全新领域&lt;/strong&gt;：面对全新领域，或者对于设计者而言是全新领域，就需要对架构给予更多关注。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;产品线&lt;/strong&gt;：一些产品线会共享某一通用架构。&lt;/p&gt;
&lt;p&gt;企业架构师：企业架构师是负责多个应用系统的开发者。他们并不会控制任何一个应用系统的功能。相反，他们会设计一个生态系统，位于其中的每个应用系统都为整个企业做出自己的贡献。&lt;/p&gt;
&lt;p&gt;应用架构师：应用架构师是单个系统的开发者。他们设计系统功能，而非架构。当然，他们也可以专注架构设计或提升架构的设计运用到应用系统中。&lt;/p&gt;
&lt;p&gt;架构设计的方式有哪些？&lt;/p&gt;
&lt;p&gt;1、不做预先设计：开发者一上来就写代码。这也会发生设计，只不过是与编码起头并进&lt;br/&gt;2、用一些时间比例来做设计：比如，10%用于架构设计，50%编码，20%测试，10%集成&lt;br/&gt;3、详细的设计：一开始就做详细架构设计，并形成详细的架构文档&lt;br/&gt;4、随机应变方式：根据项目需求随机做出决定，是否需要架构设计？多少时间用来做架构设计？&lt;/p&gt;
&lt;h2 id=&quot;风险驱动模型&quot;&gt;风险驱动模型&lt;/h2&gt;
&lt;h3 id=&quot;什么是风险驱动模型：&quot;&gt;&lt;strong&gt;什么是风险驱动模型：&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;我的风险是什么？ 用于降低这些风险的技术是什么？风险是否化解，可以开始编码了吗？，这三问。&lt;/p&gt;
&lt;p&gt;风险驱动模型归纳三个步骤：&lt;br/&gt;1、识别风险，并排定优先级&lt;br/&gt;2、选择并运用一组技术&lt;br/&gt;3、评估风险降低的程度&lt;/p&gt;
&lt;h3 id=&quot;项目领域典型的风险：&quot;&gt;&lt;strong&gt;项目领域典型的风险&lt;/strong&gt;：&lt;/h3&gt;
&lt;p&gt;如下图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/650581/202009/650581-20200901023317883-1673065453.png&quot; alt=&quot;project-risk&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;识别风险以及风险决策：&quot;&gt;&lt;strong&gt;识别风险以及风险决策&lt;/strong&gt;：&lt;/h3&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;识别风险&lt;br/&gt;经验丰富的开发者很容易识别风险，如果开发者缺乏经验，或者对该领域不熟，怎么办？最容易办法从需求开始，去寻找那些似乎难以实现的内容。不完整或容易引起误解的质量属性需求是最为常见的风险。&lt;br/&gt;捕获风险并提供一份失败场景的优先级列表。&lt;br/&gt;必须认识到，及时竭尽全力，项目扔会面对一些未识别的风险。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;典型风险&lt;br/&gt;在某一领域工作一段时间后，你就会注意到一些典型风险，他们对于该领域大多数项目而言都是很常见的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;决策风险优先级&lt;br/&gt;由于风险有大有小，因此需要对他们进行优先级排序。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;技术&lt;/strong&gt;：&lt;br/&gt;一段识别了风险，就运用期望的技术去降低风险。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;我的举例：比如，访问量大了之后，数据库可能抗不住，你会想到增加一层缓存来降低对数据库的直接访问。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从分析到解决方案。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;软件工程以及其他领域中工程避险技术的若干示例&lt;/strong&gt;：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;软件工程&lt;/th&gt;
&lt;th&gt;其他工程&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;运用设计模式或架构模式&lt;/td&gt;
&lt;td&gt;应力计算&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;领域建模&lt;/td&gt;
&lt;td&gt;断点测试&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;吞吐量预估&lt;/td&gt;
&lt;td&gt;热分析&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;安全性评估&lt;/td&gt;
&lt;td&gt;可靠性测试&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;原型测试&lt;/td&gt;
&lt;td&gt;原型测试&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;风险驱动模型是以分析为目的的相关技术，他们都是过程性的，而且独立的问题域。这些技术包括：&lt;br/&gt;使用模型-层级图、组件装备模型以及部署模型；对性能、安全和可靠性进行分析的技术；利用各种架构风格，如client-server，pipe-and-filter（管道-过滤器）去实现某个紧迫的质量属性需求。&lt;/p&gt;
&lt;p&gt;设计是一个神秘的过程，只有大师才能实现从推理问题到解决方案的跨越。我们要从大师中学得这么技艺。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;做出技术合理决策公式&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;如果你面临&amp;lt;某种风险&amp;gt;，可以考虑使用&amp;lt;某种技术&amp;gt;降低它。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;利用你的若干知识把风险与技术之间做一个若干映射。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;任何特定技术都擅长降低某些风险，而对于其他风险却未必。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有些风险可以通过多种技术去缓解，而另外一些风险甚至需要发明一些技术才能解决。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;我理解：这些技术往往是大公司发明的，因为他们的业务体量，需要新的技术才能解决。比如google发表的那3篇大数据论文。就改变了大数据处理领域。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一眼看去，总是很难判断该运用哪些技术才是适合。每种技术都有其价值，却未必是项目最需要的。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;我理解：这就是项目技术选型难点之一。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;技术选型指导原则&quot;&gt;技术选型指导原则&lt;/h2&gt;
&lt;p&gt;上面介绍了风险驱动模型，并主张根据所面对的风险去挑选技术。那如何才能做出合适的选型决策？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;重要原则&lt;/strong&gt;：&lt;br/&gt;1、首先，当面临一个要解决的问题，而在其他情况下又遇到需要证明的问题，技术决策应该与具体需求相匹配&lt;br/&gt;2、其次，某些通过类比模型解决，而其他问题，借助分析模型解决，此时需要分辨不同模型之间差异&lt;br/&gt;3、再次，采用特定类型的模型，才能有效分析问题。&lt;br/&gt;4、最后，某些技术之间中存在着密切的关系&lt;/p&gt;
&lt;p&gt;要求解的问题和要证明的问题：要求解的问题，找到答案就可以了；要证明的问题，需要找到所有情况为真，这比求解问题难的多。&lt;/p&gt;
&lt;p&gt;举例：“数据库能否保存多大一百个字符的名称？”它属于要求解的问题，为此问题编写测试用例就很容易解出来。&lt;/p&gt;
&lt;p&gt;“该系统是否一致符合该框架的应用程序编程接口？” 这就是需要要证明的问题。尽管可以做多种测试，但，仍然会有某些情况被忽略了。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;我理解：上面说的是一些解决问题方法。但是做技术选择还要考虑人和技术社区因数，公司技术人是否会这种技术，该技术社区是否成熟，成熟的标准就是遇到了问题，能有人热心提供帮助。其次，就是该技术提供的解决方案是否与遇到的问题相匹配。最后，该技术后续升级发展，与公司业务发展周期是否相匹配。不要遇到那种纯kpi项目，突然就停止开发。但公司业务还在发展，遇到问题怎么办？这也是选型的风险。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;如何把握设计与架构的度&quot;&gt;如何把握设计与架构的度&lt;/h2&gt;
&lt;p&gt;有人说架构就是一种平衡，在现阶段下，“利益”的平衡和取舍。&lt;/p&gt;
&lt;p&gt;架构设计越复杂，那么，实现所花费的时间就越多，而需求变化又极快，所以必须平衡需求与架构之间冲突。&lt;br/&gt;不需要识别出所有风险后，包括现在和以后的风险才开始架构，只要架构能满足现在业务发展，并能应付未来1到2年的发展即可。&lt;/p&gt;
&lt;h3 id=&quot;计划式设计与演进式设计&quot;&gt;计划式设计与演进式设计&lt;/h3&gt;
&lt;h4 id=&quot;演进式设计&quot;&gt;演进式设计&lt;/h4&gt;
&lt;p&gt;从历史过往来看，演进式架构饱受争议，因为局部而又不协调的设计决策会导致混乱，从而创造出一个大杂烩，既难维护，又难以进一步演进。然而，随着敏捷实践中的重构、测试驱动设计以及持续集成可以对付各种混乱问题。&lt;br/&gt;重构（对代码进改进）清除了不协调的局部设计，&lt;br/&gt;测试驱动设计确保对系统更改不会导致系统丢失或破坏现有功能，&lt;br/&gt;持续集成则为整个团队提供了统一代码库。&lt;/p&gt;
&lt;p&gt;因为有上述种种实践，一些人认为可以不用做计划式设计。&lt;br/&gt;其中，重构式克服演进式设计中大杂烩问题的主力。但，重构缺陷是，它并没有为架构规模的转换提供指导。&lt;/p&gt;
&lt;h3 id=&quot;计划式设计&quot;&gt;计划式设计&lt;/h3&gt;
&lt;p&gt;演进式设计对立面就是计划式设计。&lt;br/&gt;它的总体思路是，在项目构建前，就非常详细制定各种计划。有时，它被称为预先大量设计（BDUF）。&lt;/p&gt;
&lt;h3 id=&quot;最小计划式设计&quot;&gt;最小计划式设计&lt;/h3&gt;
&lt;p&gt;最小计划式设计 （little design up front，Martin，2009）。这是一种介于演进式设计和计划式设计之间的一种设计方法。&lt;/p&gt;
&lt;p&gt;在计划式设计与演进式设计之间取得平衡是可能的。&lt;br/&gt;一种方法是现在一些初步的计划式设计，确保架构可以处理一些最大风险。在初始计划式设计完成后，未来的需求变化往往通过局部设计去处理，或采用演技式设计，前提是重构、测试驱动设计和持续集成等实践在项目中已经展开起来。&lt;/p&gt;
&lt;h3 id=&quot;理解过程变化&quot;&gt;理解过程变化&lt;/h3&gt;
&lt;p&gt;几种开发模型的比较：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/650581/202009/650581-20200901023519192-1609777262.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;还有现在流行的 &lt;strong&gt;DevOps&lt;/strong&gt;模型 ，开发运维一体化&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;风险驱动模型缺点&quot;&gt;风险驱动模型缺点&lt;/h3&gt;
&lt;p&gt;它能帮助我们决定何时可以停止架构设计，以及应到我们开展各种适当的架构活动。&lt;br/&gt;但是，它并不擅长预测在设计上到底花多长的时间。&lt;/p&gt;
&lt;h2 id=&quot;建模&quot;&gt;建模&lt;/h2&gt;
&lt;p&gt;工程师的目标是将现实世界的问题转换为现实世界的解决方案。若是简单问题，则无需抽象即可解决。然而，对于复杂的问题，越需要通过抽象来建模解决。&lt;br/&gt;现实世界的问题在抽象模型中体现，在建模领域中解决，在将该解决方案映射到现实世界的解决方案。架构模型也是如此。&lt;/p&gt;
&lt;h3 id=&quot;规模与复杂度需要抽象&quot;&gt;规模与复杂度需要抽象&lt;/h3&gt;
&lt;p&gt;模型为解决问题提供了洞察力和解决手段。&lt;/p&gt;
&lt;p&gt;建立架构模型是一种理解和解决棘手问题的好方法，因为它可以去掉无关的细节，使得你能够将注意力放在主要部分以及相关关系上，做出预测，评估候选方案。&lt;/p&gt;
&lt;p&gt;模型忽略了细节。&lt;/p&gt;
&lt;p&gt;站在巨人肩膀上，以前的巨人不仅为我们提供了可见的编译器和数据库，还提供了一套抽象的编程思维理论。一部分抽象概念已经植根与编程语言中--函数、类、模块等。其余则包括组件、端口和连接器。&lt;/p&gt;
&lt;h3 id=&quot;领域模型、设计模型和代码模型&quot;&gt;领域模型、设计模型和代码模型&lt;/h3&gt;
&lt;p&gt;规范化模型结构顶部抽象层次追到的模型（领域），底部模型则代表具体（代码）。指定关系和细化关系能确保模型一致性，又使得他们区分不同的抽象层次。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;领域模型&lt;/strong&gt;：&lt;br/&gt;领域模型表达了与系统相关的现实世界的不变事实。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;设计模型&lt;/strong&gt;：&lt;br/&gt;需要构建的系统不仅会显示在领域模型中，还会在设计模型中出现。&lt;br/&gt;设计模式由递归嵌套的边界模型和内部模型组成。边界模型涉及公共接口，内部模型介绍了内部设计。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码模型&lt;/strong&gt;：系统的源代码实现。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/650581/202009/650581-20200901023628265-772333247.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不同作者提出的模型如何与本书提到的业务模型、领域模型、设计模型（边界模型和内部模型）和代码模型的对应：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/650581/202009/650581-20200901023847656-1345781264.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;设计模型&quot;&gt;设计模型&lt;/h2&gt;
&lt;p&gt;视图类型以及视图类型内容举例：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/650581/202009/650581-20200901023951098-1976849336.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;视图类型和质量属性归纳，也就是设计时关注的一些指标，比如延迟，效率，可伸缩性，安全性，等等：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/650581/202009/650581-20200901024131162-1497101292.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;模型关系&quot;&gt;模型关系&lt;/h2&gt;
&lt;p&gt;各种关系的列表：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/650581/202009/650581-20200901024234938-1228726100.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设计模型，实现模型，领域模型（分析模型）&lt;/p&gt;
&lt;h2 id=&quot;架构风格&quot;&gt;架构风格&lt;/h2&gt;
&lt;p&gt;架构风格中的元素、关系、约束以及指标，图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/650581/202009/650581-20200901024346682-2076683791.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 31 Aug 2020 19:01:00 +0000</pubDate>
<dc:creator>九卷</dc:creator>
<og:description>《恰如其分的软件架构》 一书 其实读起来感觉有点学术性质，换句话说，有点晦涩难懂。不知道是不是翻译的问题。 书里提倡的按风险驱动的架构设计，还是值得借鉴的设计方法。我的理解就是“问题驱动法”。 比如说</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jiujuan/p/13594006.html</dc:identifier>
</item>
<item>
<title>【小白学PyTorch】1 搭建一个超简单的网络 - 忽逢桃林</title>
<link>http://www.cnblogs.com/PythonLearner/p/13587155.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/PythonLearner/p/13587155.html</guid>
<description>&lt;p&gt;文章目录：&lt;br/&gt;&lt;/p&gt;

&lt;h2 id=&quot;1-任务&quot;&gt;1 任务&lt;/h2&gt;
&lt;p&gt;首先说下我们要搭建的网络要完成的学习任务：&lt;br/&gt;让我们的神经网络学会逻辑异或运算，异或运算也就是俗称的“相同取0，不同取1” 。再把我们的需求说的简单一点，也就是我们需要搭建这样一个神经网络，让我们在输入（1,1）时输出0，输入（1,0）时输出1（相同取0，不同取1），以此类推。&lt;/p&gt;
&lt;h2 id=&quot;2-实现思路&quot;&gt;2 实现思路&lt;/h2&gt;
&lt;p&gt;因为我们的需求需要有两个输入，一个输出，所以我们需要在输入层设置两个输入节点，输出层设置一个输出节点。因为问题比较简单，所以隐含层我们只需要设置10个节点就可以达到不错的效果了，隐含层的激活函数我们采用ReLU函数，输出层我们用Sigmoid函数，让输出保持在0到1的一个范围，如果输出大于0.5，即可让输出结果为1，小于0.5，让输出结果为0.&lt;/p&gt;
&lt;h2 id=&quot;3-实现过程&quot;&gt;3 实现过程&lt;/h2&gt;
&lt;p&gt;我们使用的简单的快速搭建法。&lt;/p&gt;
&lt;h3 id=&quot;31-引入必要库&quot;&gt;3.1 引入必要库&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import torch
import torch.nn as nn
import numpy as np
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用pytorch当然要引入torch包，然后为了写代码方便将torch包里的nn用nn来代替，nn这个包就是neural network的缩写，专门用来搭神经网络的一个包。引入numpy是为了创建矩阵作为输入。&lt;/p&gt;
&lt;h3 id=&quot;32-创建训练集&quot;&gt;3.2 创建训练集&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 构建输入集
x = np.mat('0 0;'
           '0 1;'
           '1 0;'
           '1 1')
x = torch.tensor(x).float()
y = np.mat('1;'
           '0;'
           '0;'
           '1')
y = torch.tensor(y).float()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我个人比较喜欢用np.mat这种方式构建矩阵，感觉写法比较简单，当然你也可以用其他的方法。但是构建完矩阵一定要有这一步&lt;code&gt;torch.tensor(x).float()&lt;/code&gt;，必须要把你所创建的输入转换成tensor变量。&lt;/p&gt;
&lt;p&gt;什么是tensor呢？你可以简单地理解他就是pytorch中用的一种变量，你想用pytorch这个框架就必须先把你的变量转换成tensor变量。而我们这个神经网络会要求你的输入和输出必须是float浮点型的，指的是tensor变量中的浮点型，而你用np.mat创建的输入是int型的，转换成tensor也会自动地转换成tensor的int型，所以要在后面加个.float（）转换成浮点型。&lt;/p&gt;
&lt;p&gt;这样我们就构建完成了输入和输出（分别是x矩阵和y矩阵），x是四行二列的一个矩阵，他的每一行是一个输入，一次输入两个值，这里我们把所有的输入情况都列了出来。输出y是一个四行一列的矩阵，每一行都是一个输出，对应x矩阵每一行的输入。&lt;/p&gt;
&lt;h3 id=&quot;33-搭建网络&quot;&gt;3.3 搭建网络&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;myNet = nn.Sequential( 
    nn.Linear(2,10),
    nn.ReLU(),
    nn.Linear(10,1),
    nn.Sigmoid()
    )
print(myNet)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果:&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200128052008961.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0MTA3NDI1,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们使用nn包中的Sequential搭建网络，这个函数就是那个可以让我们像搭积木一样搭神经网络的一个东西。&lt;/p&gt;
&lt;p&gt;nn.Linear(2,10)的意思搭建输入层，里面的2代表输入节点个数，10代表输出节点个数。Linear也就是英文的线性，意思也就是这层不包括任何其它的激活函数，你输入了啥他就给你输出了啥。nn.ReLU（）这个就代表把一个激活函数层，把你刚才的输入扔到了ReLU函数中去。 接着又来了一个Linear，最后再扔到Sigmoid函数中去。 2,10,1就分别代表了三个层的个数，简单明了。&lt;/p&gt;
&lt;h3 id=&quot;34-设置优化器&quot;&gt;3.4 设置优化器&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;optimzer = torch.optim.SGD(myNet.parameters(),lr=0.05)
loss_func = nn.MSELoss()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对这一步的理解就是，你需要有一个优化的方法来训练你的网络，所以这步设置了我们所要采用的优化方法。&lt;/p&gt;
&lt;p&gt;torch.optim.SGD的意思就是采用SGD(随机梯度下降)方法训练，你只需要把你网络的参数和学习率传进去就可以了，分别是&lt;code&gt;myNet.paramets&lt;/code&gt;和&lt;code&gt;lr&lt;/code&gt;。 &lt;code&gt;loss_func&lt;/code&gt;这句设置了代价函数，因为我们的这个问题比较简单，所以采用了MSE，也就是均方误差代价函数。&lt;/p&gt;
&lt;h3 id=&quot;35-训练网络&quot;&gt;3.5 训练网络&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;for epoch in range(5000):
    out = myNet(x)
    loss = loss_func(out,y)
    optimzer.zero_grad()
    loss.backward()
    optimzer.step()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我这里设置了一个5000次的循环（可能不需要这么多次），让这个训练的动作迭代5000次。每一次的输出直接用myNet（x），把输入扔进你的网络就得到了输出out（就是这么简单粗暴！），然后用代价函数和你的标准输出y求误差。 清除梯度的那一步是为了每一次重新迭代时清除上一次所求出的梯度，你就把这一步记住就行，初学不用理解太深。 &lt;code&gt;loss.backward（）&lt;/code&gt;当然就是让误差反向传播，接着&lt;code&gt;optimzer.step（）&lt;/code&gt;也就是让我们刚刚设置的优化器开始工作。&lt;/p&gt;
&lt;h3 id=&quot;36-测试&quot;&gt;3.6 测试&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;print(myNet(x).data)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200128052716973.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0MTA3NDI1,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到这个结果已经非常接近我们期待的结果了，当然你也可以换个数据测试，结果也会是相似的。这里简单解释下为什么我们的代码末尾加上了一个.data，因为我们的tensor变量其实是包含两个部分的，一部分是tensor数据，另一部分是tensor的自动求导参数，我们加上.data意思是输出取tensor中的数据，如果不加的话会输出下面这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200128052757705.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0MTA3NDI1,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 31 Aug 2020 16:54:00 +0000</pubDate>
<dc:creator>忽逢桃林</dc:creator>
<og:description>文章目录： 1 任务 首先说下我们要搭建的网络要完成的学习任务： 让我们的神经网络学会逻辑异或运算，异或运算也就是俗称的“相同取0，不同取1” 。再把我们的需求说的简单一点，也就是我们需要搭建这样一个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/PythonLearner/p/13587155.html</dc:identifier>
</item>
<item>
<title>【译】ASP.NET Core updates in .NET 5 Preview 8  - MeteorSeed</title>
<link>http://www.cnblogs.com/MeteorSeed/p/13593798.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MeteorSeed/p/13593798.html</guid>
<description>&lt;p&gt;.NET 5 预览版 8 现在已经可以获取了，并且已经准备好接受评估。本文列出了本次发布的新特性。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;228.09644033244&quot;&gt;
&lt;p&gt;　　.NET 5 预览版 8 现在已经可以获取了，并且已经准备好接受评估。下面列出了本次发布的新特性：&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Blazorz 组件的 CSS 隔离&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Blazor WebAssembly 中的延迟加载&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;更新 Blazor WebAssembly 的全球化支持&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;
&lt;ul readability=&quot;5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;新的 InputRadio 组件&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在 Blazor 应用程序中设置 UI 焦点&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;影响 Blazor 应用程序的 HTML 头&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;IAsyncDisposable 用于 Blazor 组件&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;控制 Blazor 组件实例化&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;受保护的浏览器存储&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;使用 C# 9 记录类型进行模型绑定和验证&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;使用 dotnet watch 自动刷新&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Console Logger Formatter&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;JSON Console Logger&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　有关更多细节和已知问题，请参阅 .NET 5 发布说明。&lt;/p&gt;

&lt;p&gt;　　要使用.NET 5 Preview 8 中的 ASP.NET Core，则需要安装 .NET 5 SDK。&lt;/p&gt;
&lt;p&gt;　　你需要使用 Visual Studio 2019 16.8 Preview 2 或更版本。.NET 5 也支持最新的 Mac Visual Studio 预览版。要使用 .NET 5 和 Visual Studio Code，需要安装最新版本的 C# extension。&lt;/p&gt;

&lt;p&gt;　　把现有的ASP.NET Core 应用从 .NET 5 Preview 7 升级到 .NET 5 Preview 8：&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;更新所有 Microsoft.AspNetCore.* 包引用到 5.0.0-preview.8.*.&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;更新所有 Microsoft.Extensions.* 包引用到 5.0.0-preview.8.*.&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;更新 System.Net.Http.Json 包引用到 5.0.0-preview.8.*.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　就是这样！你应该准备好出发了。&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;3.1 使用 Microsoft.Identity.Web 进行 Azure Active Directory 认证&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　ASP.NET Core 项目模板现在与 Microsoft.Identity.Web 集成，用于处理Azure AD 身份验证。Microsoft.Identity.Web 包为 Azure AD 身份验证提供了更好的体验，还提供了用户访问 Azure 资源（包括 Microsoft Graph）的更简便方法。对此，微软提供了，使用 Azure API、Microsoft Graph 和用户自己的受保护的 API，从简单的登录到多租户的 Web 示例。Microsoft.Identity.Web 将会与 .NET 5 一起推广使用。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;3.2 Blazor 组件的 CSS 隔离&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　Blazor 现在支持定义特定组件范围内的 CSS 样式。特定于组件的 CSS 样式可以更容易地判断应用程序中的样式，并避免全局样式带来的意外副作用。你可以在 .razor.css 文件中定义特定于组件的样式，这些样式与组件的 .razor文件的名称相匹配。&lt;/p&gt;
&lt;p&gt;　　例如，假设你有一个组件 MyComponent.razor 文件，看起来像这样:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;h1&amp;gt;My Component&amp;lt;/h1&amp;gt;

&amp;lt;ul &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cool-list&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;li&amp;gt;Item1&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;Item2&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后你可以给这个组件定义一个 MyComponent.razor.css 样式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;h1 {
    font&lt;/span&gt;-family: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Comic Sans MS&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
}

.cool&lt;/span&gt;-&lt;span&gt;list li {
    color: red;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　css 中的样式将只应用于 MyComponent 组件，其他组件呈现的 h1 元素不会受到影响。&lt;/p&gt;
&lt;p&gt;　　要编写一个影响子组件样式的选择器，请使用 ::deep 组合符。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.parent ::deep .child {
    color: red;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　通过使用 ::deep 组合符，只有 .parent 类选择器被限定在组件的范围内；child class 选择器没有作用域，它将匹配子组件的内容。&lt;/p&gt;
&lt;p&gt;　　Blazor 通过将 CSS 选择器重写为构建的一部分来实现 CSS 隔离，以便它们只与组件呈现的标记匹配。&lt;/p&gt;
&lt;p&gt;　　Blazor 将重写的 CSS 文件捆绑在一起，并将该捆绑作为静态 web asset 提供给应用程序（_framework/scoped.styles.css.）。&lt;/p&gt;
&lt;p&gt;　　尽管 Blazor 本身并不支持 Sass 或 Less 等 CSS 预处理程序，但你仍然可以使用 CSS 预处理程序来生成特定于组件的样式，然后将其作为构建项目的一部分进行重写。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;3.3 Blazor WebAssembly 中的延迟加载&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　延迟加载可以通过延迟特定依赖程序的下载，直到需要时才下载，从而改善 Blazor WebAssembly 应用程序的加载时间。如果你的 Blazor WebAssembly 应用程序有很大的依赖关系，而这些依赖关系只用于应用程序的特定部分，那么延迟加载可能会很有帮助。&lt;/p&gt;
&lt;p&gt;　　要延迟程序集的加载，可以将其添加到项目文件中的 BlazorWebAssemblyLazyLoad 项组中。&lt;/p&gt;
&lt;p&gt;　　标记为延迟加载的程序集在使用之前必须由应用程序显式地加载。要在运行时延迟加载程序集，请使用 LazyAssemblyLoader 服务:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@inject LazyAssemblyLoader LazyAssemblyLoader

@code {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; assemblies = &lt;span&gt;await&lt;/span&gt; LazyAssemblyLoader.LoadAssembliesAsync(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Lib1.dll&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; });
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　要延迟加载特定页面的程序集，请使用 Router 组件上的 OnNavigateAsync 事件。OnNavigateAsync 事件在每个页面导航中触发，可用于为特定路径延迟加载程序集。你还可以通过将任何延迟加载的程序集作为附加程序集传递到 Router 来延迟加载路由的整个页面。&lt;/p&gt;
&lt;p&gt;　　下面的示例演示在用户导航到 /page1 时使用 LazyAssemblyLoader 服务来延迟加载特定依赖项（Lib1.dll）。然后将延迟加载的程序集添加到传递给 Router 组件的附加程序集列表中，以便它可以发现该程序集中的任何可路由的组件。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@using System.Reflection
@using Microsoft.AspNetCore.Components.Routing
@using Microsoft.AspNetCore.Components.WebAssembly.Services
@inject LazyAssemblyLoader LazyAssemblyLoader

&lt;/span&gt;&amp;lt;Router AppAssembly=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;typeof(Program).Assembly&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; AdditionalAssemblies=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lazyLoadedAssemblies&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; OnNavigateAsync=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;@OnNavigateAsync&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;Navigating&amp;gt;
        &amp;lt;div&amp;gt;
            &amp;lt;p&amp;gt;Loading the requested page...&amp;lt;/p&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/Navigating&amp;gt;
    &amp;lt;Found Context=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;routeData&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
        &amp;lt;RouteView RouteData=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;@routeData&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; DefaultLayout=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;typeof(MainLayout)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;/Found&amp;gt;
    &amp;lt;NotFound&amp;gt;
        &amp;lt;LayoutView Layout=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;typeof(MainLayout)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
            &amp;lt;p&amp;gt;Sorry, there &lt;span&gt;is&lt;/span&gt; nothing at &lt;span&gt;this&lt;/span&gt; address.&amp;lt;/p&amp;gt;
        &amp;lt;/LayoutView&amp;gt;
    &amp;lt;/NotFound&amp;gt;
&amp;lt;/Router&amp;gt;&lt;span&gt;

@code {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; List&amp;lt;Assembly&amp;gt; lazyLoadedAssemblies = 
        &lt;span&gt;new&lt;/span&gt; List&amp;lt;Assembly&amp;gt;&lt;span&gt;();

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task OnNavigateAsync(NavigationContext args)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (args.Path.EndsWith(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/page1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; assemblies = &lt;span&gt;await&lt;/span&gt; LazyAssemblyLoader.LoadAssembliesAsync(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Lib1.dll&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;  });
            lazyLoadedAssemblies.AddRange(assemblies);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;strong&gt;3.4 更新 Blazor WebAssembly 的全球化支持&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　.NET 5 Preview 8 重新引入了基于 International Components for Unicode（ICU）的 Blazor WebAssembly 全球化支持。引入 ICU 数据和逻辑的一部分是为下载大小优化这些有效负载。这项工作尚未完全完成。我们希望在未来的 .NET 5 预览更新中减少 ICU 数据的大小。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;3.5 新的 InputRadio 组件&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　.NET 5 中的 Blazor 现在包括内置的 InputRadio 和 InputRadioGroup 组件。这些组件通过与其他 Blazor 表单输入组件集成验证，简化了对单选按钮组的数据绑定。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;InputRadioGroup @bind-Value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;survey.OpinionAboutBlazor&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;
    @foreach (&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; opinion &lt;span&gt;in&lt;/span&gt;&lt;span&gt; opinions)
    {
        &lt;/span&gt;&amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;form-check&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
            &amp;lt;InputRadio &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;form-check-input&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;@opinion.id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;@opinion.id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
            &amp;lt;label &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;form-check-label&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;for&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;@opinion.id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;@opinion.label&amp;lt;/label&amp;gt;
        &amp;lt;/div&amp;gt;&lt;span&gt;
    }
&lt;/span&gt;&amp;lt;/InputRadioGroup&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;strong&gt;3.6 在Blazor应用程序中设置UI焦点&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　Blazor 现在在 ElementReference 上有一个 FocusAsync 方法，用于在该元素上设置 UI 焦点。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;button @onclick=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;() =&amp;gt; textInput.FocusAsync()&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;Set focus&amp;lt;/button&amp;gt;
&amp;lt;input @ref=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;textInput&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;strong&gt;3.7 IAsyncDisposable 用于 Blazor 组件&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　Blazor组件现在支持 IAsyncDisposable 接口来异步释放已分配的资源。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;3.8 控制 Blazor 组件实例化&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　现在，你可以通过提供自己的 IComponentActivator 服务实现来控制 Blazor 组件的实例化。&lt;/p&gt;
&lt;p&gt;　　再此，感谢 Mladen Macanović 的贡献！&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;3.9 影响 Blazor 应用程序的 HTML 头&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　使用新的 Title、Link 和 Meta 组件，以编程方式设置页面的标题，并动态添加 link 和 meta 标签到 Blazor 应用程序的 HTML 头部。&lt;/p&gt;
&lt;p&gt;　　使用新的 Title, Link,  Meta 组件：&lt;/p&gt;
&lt;ol class=&quot;list-paddingleft-2&quot; readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;添加 Microsoft.AspNetCore.Components.Web.Extensions 包引用&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;包含对 _content/Microsoft.AspNetCore.Components.Web.Extensions/headManager.js 的引用&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;添加 @using Microsoft.AspNetCore.Components.Web.Extensions.Head&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　下面的示例以编程方式设置页面标题来显示未读用户通知的数量，并更新页面图标：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
@if (unreadNotificationsCount &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; title = $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Notifications ({unreadNotificationsCount})&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&amp;lt;Title Value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/Title&amp;gt;
    &amp;lt;Link rel=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;icon&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;icon-unread.ico&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;strong&gt;3.10 受保护的浏览器存储&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　在 Blazor 服务器应用程序中，你可能想要将应用程序状态保存在本地或会话存储中，以便应用程序在需要时可以在稍后进行补充。在用户浏览器中存储应用程序状态时，还需要确保它没有被篡改。&lt;/p&gt;
&lt;p&gt;　　.NET 5 中的 Blazor 通过提供两个新服务来解决这个问题：ProtectedLocalStorage 和 ProtectedSessionStorage。这些服务分别帮助你将状态存储在本地存储和会话存储中，并且它们负责使用 ASP.NET Core 数据保护 API 保护存储的数据。&lt;/p&gt;
&lt;p&gt;　　使用新的受保护浏览器存储服务：&lt;/p&gt;
&lt;p&gt;　　1.添加 Microsoft.AspNetCore.Components.Web.Extensions 包引用&lt;/p&gt;
&lt;p&gt;　　2.通过从 Startup.ConfigureServcies 调用services.AddProtectedBrowserStorage() 来配置服务&lt;/p&gt;
&lt;p&gt;　　3.将 ProtectedLocalStorage 和 ProtectedSessionStorage 注入到组件实现中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@inject ProtectedLocalStorage ProtectedLocalStorage
@inject ProtectedSessionStorage ProtectedSessionStorage&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　4.使用所需的服务异步获取、设置和删除状态：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task IncrementCount()
{
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; ProtectedLocalStorage.SetAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;count&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ++&lt;span&gt;currentCount);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;strong&gt;3.11 使用 C# 9 记录类型进行模型绑定和验证&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　你现在可以在 MVC controller 或 Razor Page 中使用 C# 9 记录类型与模型绑定。记录类型是传输 model data 的好方法。&lt;/p&gt;
&lt;p&gt;　　例如，下面的 PersonController 使用带有模型绑定和表单验证的 Person记录类型：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; record Person([Required] &lt;span&gt;string&lt;/span&gt; Name, [Range(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;150&lt;/span&gt;)] &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Age);
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; PersonController { &lt;span&gt;public&lt;/span&gt; IActionResult Index() =&amp;gt;&lt;span&gt; View();
[HttpPost]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IActionResult Index(Person person) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; … } }&lt;/span&gt;
&amp;lt;br /&amp;gt;*Person/Index.cshtml*&lt;span&gt;

```razor
@model Person

Name: &lt;/span&gt;&amp;lt;input asp-&lt;span&gt;for&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Model.Name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
&amp;lt;span asp-validation-&lt;span&gt;for&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Model.Name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;&lt;span&gt;

Age: &lt;/span&gt;&amp;lt;input asp-&lt;span&gt;for&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Model.Age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
&amp;lt;span asp-validation-&lt;span&gt;for&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Model.Age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;strong&gt;3.12 改善 DynamicRouteValueTransformer&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　ASP.NET Core 3.1 引入了 DynamicRouteValueTransformer，可以使用自定义终结点动态选择 MVC controller action 或razor page。在 .NET 5 Preview 8 中，你现在可以将状态传递给 DynamicRouteValueTransformer 并过滤所选的终结点集。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;3.13 使用dotnet watch自动刷新&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　在 .NET 5 中，在 ASP.NET Core 项目上运行 dotnet watch，现在会启动默认浏览器，并在你修改代码时自动刷新浏览器。这意味着你可以在你最喜欢的文本编辑器中打开一个 ASP.NET Core 项目，只需要运行一次 dotnet watch，然后专注于你的代码变化，同时工具处理重建、重启和重新加载你的应用。我们希望在未来 Visual Studio 中也能带来自动刷新功能。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;3.14 Console Logger Formatter&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　我们对 Microsoft.Extensions.Logging 中的控制台日志提供程序进行了改进。开发人员现在可以实现自定义 ConsoleFormatter 来对控制台输出的格式和着色进行完全控制。formatter API 通过实现 VT-100（大多数现代终端支持）转义序列的一个子集来支持丰富的格式化。console logger 可以解析出不受支持的终端上的转义序列，从而允许你为所有终端编写单一格式化程序。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;3.15 JSON Console Logger&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　除了支持自定义格式化程序外，我们还添加了一个内置的 JSON 格式化程序，它会将结构化 JSON 日志发送到控制台。你可以从默认的 simple logger 切换到 JSON，添加以下代码片段到 Program.cs：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IHostBuilder CreateHostBuilder(&lt;span&gt;string&lt;/span&gt;[] args) =&amp;gt;&lt;span&gt;
    Host.CreateDefaultBuilder(args)
&lt;/span&gt;+       .ConfigureLogging(logging =&amp;gt;
+&lt;span&gt;       {
&lt;/span&gt;+           logging.AddJsonConsole(options =&amp;gt;
+&lt;span&gt;           {
&lt;/span&gt;+               options.JsonWriterOptions = &lt;span&gt;new&lt;/span&gt; JsonWriterOptions() { Indented = &lt;span&gt;true&lt;/span&gt;&lt;span&gt; };
&lt;/span&gt;+&lt;span&gt;           });
&lt;/span&gt;+&lt;span&gt;       })
        .ConfigureWebHostDefaults(webBuilder &lt;/span&gt;=&amp;gt;&lt;span&gt;
        {
            webBuilder.UseStartup&lt;/span&gt;&amp;lt;Startup&amp;gt;&lt;span&gt;();
        });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　一旦启用，发送到控制台的日志消息现在将被JSON格式化。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;EventId&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LogLevel&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Information&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Category&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Microsoft.Hosting.Lifetime&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Message&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Now listening on: https://localhost:5001&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;State&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Message&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Now listening on: https://localhost:5001&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;address&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://localhost:5001&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{OriginalFormat}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Now listening on: {address}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　我们希望你喜欢这个版本的 ASP.NET Core！我们渴望听到你对这个最新的 .NET 5 版本的反馈。通过在 GitHub 上提交问题，让我们知道你的想法。&lt;/p&gt;
&lt;p&gt;　　感谢您试用 ASP.NET Core！&lt;/p&gt;

&lt;p&gt;　　&lt;a href=&quot;https://devblogs.microsoft.com/aspnet/asp-net-core-updates-in-net-5-preview-8/&quot; target=&quot;_blank&quot;&gt;&lt;em&gt;https://devblogs.microsoft.com/aspnet/asp-net-core-updates-in-net-5-preview-8/&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/270073/202009/270073-20200901000451445-1044190190.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Mon, 31 Aug 2020 16:11:00 +0000</pubDate>
<dc:creator>MeteorSeed</dc:creator>
<og:description>.NET 5 预览版 8 现在已经可以获取了，并且已经准备好接受评估。本文列出了本次发布的新特性。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/MeteorSeed/p/13593798.html</dc:identifier>
</item>
<item>
<title>MySQL集群搭建方案（PXC） - 丰臣正一</title>
<link>http://www.cnblogs.com/cnroadbridge/p/13593685.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cnroadbridge/p/13593685.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;服务器快过期了，清一点库存，把运维这块的知识复习下&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;为什么要搭mysql集群&quot;&gt;为什么要搭MySQL集群&lt;/h2&gt;
&lt;p&gt;技术层面上，传统的单节点数据库，万一宕机了，就凉凉了。容灾性能差、抗并发能力有限，数据量大的时候查询有瓶颈。学习层面上，作为一个技术人了解一些技术相关的知识那也是无可厚非，爱折腾嘛。所以、本着“不把鸡蛋放在一个篮子里”的思想，我们来一起探讨学习下如何搭建MySQL集群。&lt;/p&gt;
&lt;h2 id=&quot;mysql集群的解决方案&quot;&gt;MySQL集群的解决方案&lt;/h2&gt;
&lt;p&gt;关于搭建MySQL集群解决方案的操作方面，这部分知识其实是很死板的，没有特别多的含金量，真正有含金量的是挖掘其背后实现的原理和思路，并能够晓之以情动之以理地讲出来。这里主要介绍两种解决方案，我们抓牢它们的侧重点总结下吧。&lt;/p&gt;
&lt;h3 id=&quot;pxc&quot;&gt;PXC&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;强一致性&lt;/li&gt;
&lt;li&gt;速度慢&lt;/li&gt;
&lt;li&gt;只支持InnoDB存储引擎同步&lt;/li&gt;
&lt;li&gt;所有节点可读写&lt;/li&gt;
&lt;li&gt;同步机制为同步&lt;/li&gt;
&lt;li&gt;存储信息价值量高&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;replication&quot;&gt;Replication&lt;/h3&gt;
&lt;p&gt;这里我们主要讲下PXC，当你在一个节点进行相关操作，比如说插入一条数据、它会同步到其他节点，若所有节点同步成功则插入成功、若所有节点同步失败，则回滚并告知插入失败，这个我们后面实践一下就知道了。&lt;/p&gt;
&lt;h2 id=&quot;创建mysql集群的步骤（pxc&quot;&gt;创建MySQL集群的步骤（PXC)&lt;/h2&gt;
&lt;h3 id=&quot;（一）、拉取镜像并重命名&quot;&gt;（一）、拉取镜像并重命名&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# 拉取镜像
docker pull percona/percona-xtradb-cluster

# 重名名(这步也可以不做，我就是想后面少打点字)
docker tag percona/percona-xtradb-cluster:latest pxc:latest
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;（二）、组网&quot;&gt;（二）、组网&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;2.1、创建网络：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;命令：&lt;code&gt;docker network create mysql_net&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;演示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;⚡ root@ataola  ~  docker network create mysql_net
79885a1c3b8a783e096a1610df08e353641bda74d0b996b4200f2ea5db3c5dbd
 ⚡ root@ataola  ~  
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2.2、查看网络：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;命令：&lt;code&gt;docker network inspect mysql_net&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;演示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;⚡ root@ataola  ~  docker network inspect mysql_net
[
    {
        &quot;Name&quot;: &quot;mysql_net&quot;,
        &quot;Id&quot;: &quot;79885a1c3b8a783e096a1610df08e353641bda74d0b996b4200f2ea5db3c5dbd&quot;,
        &quot;Created&quot;: &quot;2020-05-30T21:26:53.852825919+08:00&quot;,
        &quot;Scope&quot;: &quot;local&quot;,
        &quot;Driver&quot;: &quot;bridge&quot;,
        &quot;EnableIPv6&quot;: false,
        &quot;IPAM&quot;: {
            &quot;Driver&quot;: &quot;default&quot;,
            &quot;Options&quot;: {},
            &quot;Config&quot;: [
                {
                    &quot;Subnet&quot;: &quot;172.19.0.0/16&quot;,
                    &quot;Gateway&quot;: &quot;172.19.0.1&quot;
                }
            ]
        },
        &quot;Internal&quot;: false,
        &quot;Attachable&quot;: false,
        &quot;Containers&quot;: {},
        &quot;Options&quot;: {},
        &quot;Labels&quot;: {}
    }
]
 ⚡ root@ataola  ~  
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;（三）、创建数据卷&quot;&gt;（三）、创建数据卷&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;3.1、创建数据卷&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;命令：&lt;code&gt;docker volume create mysql_v&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;演示:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt; ⚡ root@ataola  ~  docker volume create mysql_v1   
mysql_v1
 ⚡ root@ataola  ~  docker volume create mysql_v2
mysql_v2
 ⚡ root@ataola  ~  docker volume create mysql_v3
mysql_v3
 ⚡ root@ataola  ~  docker volume create mysql_v4
mysql_v4
 ⚡ root@ataola  ~  docker volume create mysql_v5
mysql_v5
 ⚡ root@ataola  ~  
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3.2：查看数据卷&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;命令：&lt;code&gt;docker volume inspect mysql_v&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;演示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;✘ ⚡ root@ataola  /home/caocao  docker volume inspect mysql_v1
[
    {
        &quot;Driver&quot;: &quot;local&quot;,
        &quot;Labels&quot;: {},
        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/mysql_v1/_data&quot;,
        &quot;Name&quot;: &quot;mysql_v1&quot;,
        &quot;Options&quot;: {},
        &quot;Scope&quot;: &quot;local&quot;
    }
]
 ⚡ root@ataola  /home/caocao  

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;（四）、创建mysql节点&quot;&gt;（四）、创建MySQL节点&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;4.1、主节点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;命令：&lt;code&gt;docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=studypxc -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=studymysql -v mysql_v1:/var/lib/mysql --privileged --name=mysql_node1 --net=mysql_net pxc&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;演示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;⚡ root@ataola  ~  docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=studypxc -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=studymysql -v mysql_v1:/var/lib/mysql --privileged --name=mysql_node1 --net=mysql_net pxc
09e7715f71b4411974d862a2aa74ed0b1018fc4efb4196707576f935e1425f6b
 ⚡ root@ataola  ~  docker ps -a
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                                   NAMES
09e7715f71b4        pxc                 &quot;/entrypoint.sh my...&quot;   8 seconds ago       Up 6 seconds        0.0.0.0:3306-&amp;gt;3306/tcp, 4567-4568/tcp   mysql_node1
 ⚡ root@ataola  ~ 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;4.2、从节点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;命令:&lt;code&gt;docker run -d -p 3307:3306 -e MYSQL_ROOT_PASSWORD=studypxc -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=studymysql -e CLUSTER_JOIN=mysql_node1 -v mysql_v2:/var/lib/mysql --privileged --name=mysql_node2 --net=mysql_net pxc&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;更改相关参数重复三次楼上操作，我们构建一个主节点外加四个从节点的mysql集群，这个时候我们执行&lt;code&gt;docker ps -a&lt;/code&gt;看下，可以看到它们都跑起来了。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;⚡ root@ataola  ~  docker ps -a
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                                   NAMES
8d809616ea08        pxc                 &quot;/entrypoint.sh my...&quot;   9 seconds ago       Up 8 seconds        4567-4568/tcp, 0.0.0.0:3310-&amp;gt;3306/tcp   mysql_node5
6dc023253205        pxc                 &quot;/entrypoint.sh my...&quot;   18 seconds ago      Up 17 seconds       4567-4568/tcp, 0.0.0.0:3309-&amp;gt;3306/tcp   mysql_node4
18c232855938        pxc                 &quot;/entrypoint.sh my...&quot;   53 seconds ago      Up 52 seconds       4567-4568/tcp, 0.0.0.0:3308-&amp;gt;3306/tcp   mysql_node3
6de60216270a        pxc                 &quot;/entrypoint.sh my...&quot;   2 minutes ago       Up 2 minutes        4567-4568/tcp, 0.0.0.0:3307-&amp;gt;3306/tcp   mysql_node2
09e7715f71b4        pxc                 &quot;/entrypoint.sh my...&quot;   10 minutes ago      Up 10 minutes       0.0.0.0:3306-&amp;gt;3306/tcp, 4567-4568/tcp   mysql_node1
 ⚡ root@ataola  ~  
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们可以通过&lt;code&gt;docker network inspect mysql_net&lt;/code&gt;查看我们刚才创建集群的网络信息&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; ⚡ root@ataola  /home/caocao  docker network inspect mysql_net
[
    {
        &quot;Name&quot;: &quot;mysql_net&quot;,
        &quot;Id&quot;: &quot;79885a1c3b8a783e096a1610df08e353641bda74d0b996b4200f2ea5db3c5dbd&quot;,
        &quot;Created&quot;: &quot;2020-05-30T21:26:53.852825919+08:00&quot;,
        &quot;Scope&quot;: &quot;local&quot;,
        &quot;Driver&quot;: &quot;bridge&quot;,
        &quot;EnableIPv6&quot;: false,
        &quot;IPAM&quot;: {
            &quot;Driver&quot;: &quot;default&quot;,
            &quot;Options&quot;: {},
            &quot;Config&quot;: [
                {
                    &quot;Subnet&quot;: &quot;172.19.0.0/16&quot;,
                    &quot;Gateway&quot;: &quot;172.19.0.1&quot;
                }
            ]
        },
        &quot;Internal&quot;: false,
        &quot;Attachable&quot;: false,
        &quot;Containers&quot;: {
            &quot;09e7715f71b4411974d862a2aa74ed0b1018fc4efb4196707576f935e1425f6b&quot;: {
                &quot;Name&quot;: &quot;mysql_node1&quot;,
                &quot;EndpointID&quot;: &quot;621bc0ec6e4adb78e72f0f78ca04d154029abe1f0bb91fc5ccd42156bfa32d52&quot;,
                &quot;MacAddress&quot;: &quot;02:42:ac:13:00:02&quot;,
                &quot;IPv4Address&quot;: &quot;172.19.0.2/16&quot;,
                &quot;IPv6Address&quot;: &quot;&quot;
            },
            &quot;0e4ef69c19b981163067ec8af0c38b6fa84c380855c22309a884f0a0ed691912&quot;: {
                &quot;Name&quot;: &quot;haproxy1&quot;,
                &quot;EndpointID&quot;: &quot;02e8c179fdb7cbc4b3e7d72f8412129da487c65a3897e70e0da5693aa0d8d500&quot;,
                &quot;MacAddress&quot;: &quot;02:42:ac:13:00:07&quot;,
                &quot;IPv4Address&quot;: &quot;172.19.0.7/16&quot;,
                &quot;IPv6Address&quot;: &quot;&quot;
            },
            &quot;18c232855938d7263b90a4ab88874676110c6197a601aa72d8bec8f52e73dd02&quot;: {
                &quot;Name&quot;: &quot;mysql_node3&quot;,
                &quot;EndpointID&quot;: &quot;010538caec3ab7aafe1c708ebebdffa43e268d68147cf4a60f86a77247b3ef86&quot;,
                &quot;MacAddress&quot;: &quot;02:42:ac:13:00:04&quot;,
                &quot;IPv4Address&quot;: &quot;172.19.0.4/16&quot;,
                &quot;IPv6Address&quot;: &quot;&quot;
            },
            &quot;6dc0232532057a65db0607c92517307ee480bec32cb6311d6615555482670c7a&quot;: {
                &quot;Name&quot;: &quot;mysql_node4&quot;,
                &quot;EndpointID&quot;: &quot;cc59fe8fc8d7d02f367ec75b1897c51bf3731dbc5dc8d70510dde34aee6d4afa&quot;,
                &quot;MacAddress&quot;: &quot;02:42:ac:13:00:05&quot;,
                &quot;IPv4Address&quot;: &quot;172.19.0.5/16&quot;,
                &quot;IPv6Address&quot;: &quot;&quot;
            },
            &quot;6de60216270a3b6f5bfbe5d94d40fa2449e443eb77b67d4bf005061dd4ff412e&quot;: {
                &quot;Name&quot;: &quot;mysql_node2&quot;,
                &quot;EndpointID&quot;: &quot;b674d25e3e6c999324de9704419b1c97f008ca6e5d27e825bc0fc61d600848ff&quot;,
                &quot;MacAddress&quot;: &quot;02:42:ac:13:00:03&quot;,
                &quot;IPv4Address&quot;: &quot;172.19.0.3/16&quot;,
                &quot;IPv6Address&quot;: &quot;&quot;
            },
            &quot;8d809616ea08d46a3febb95259d9d0672d6112dd8cbe6c29f03f49cbc44ef444&quot;: {
                &quot;Name&quot;: &quot;mysql_node5&quot;,
                &quot;EndpointID&quot;: &quot;01f0988019206e959a7099736d9995cec1676aaec360db9bd78fa61b68a87f71&quot;,
                &quot;MacAddress&quot;: &quot;02:42:ac:13:00:06&quot;,
                &quot;IPv4Address&quot;: &quot;172.19.0.6/16&quot;,
                &quot;IPv6Address&quot;: &quot;&quot;
            }
        },
        &quot;Options&quot;: {},
        &quot;Labels&quot;: {}
    }
]
 ⚡ root@ataola  /home/caocao  
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至此，基于PXC解决方案MySQL集群搭建已经完成了，当然这里涉及到的一些命令和参数具体的还是要读者去看楼下参考文献的官方文档的。&lt;/p&gt;
&lt;h2 id=&quot;负载均衡（haproxy）&quot;&gt;负载均衡（haproxy）&lt;/h2&gt;
&lt;p&gt;在楼上的例子中，我们创建了一个MySQL集群，我们可以把它理解成一家超市。然后每个节点就是收银台。这个时候就会有个问题了，假设那批去超市购物的人不太正常了，买完东西都挤到1号收银台，那么1号收银台的收银员她承受的压力就会比较大，就会很焦虑。这个时候呢，超市经理拿这个大喇叭过来啊，你你你，去2号收银台、你们去3号收银台，购物的人很快地就付完钱回家了。haproxy就相当于这个超市经理，哪里有空闲就调度往哪个节点去。&lt;/p&gt;
&lt;p&gt;在理解完haproxy做的事情后，我们来实践一番吧。&lt;/p&gt;
&lt;h3 id=&quot;（一）、拉取镜像&quot;&gt;（一）、拉取镜像&lt;/h3&gt;
&lt;p&gt;这里我就不改名了，有兴趣的童鞋自己对照pxc改个名字。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;docker pull haproxy
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;（二）、创建haproxy配置文件&quot;&gt;（二）、创建haproxy配置文件&lt;/h3&gt;
&lt;p&gt;这里其他的配置都不用动，就后面server改成你电脑的配置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# haproxy.cfg
global
    #工作目录
    chroot /usr/local/etc/haproxy
    #日志文件，使用rsyslog服务中local5日志设备（/var/log/local5），等级info
    log 127.0.0.1 local5 info
    #守护进程运行
    daemon

defaults
    log    global
    mode    http
    #日志格式
    option    httplog
    #日志中不记录负载均衡的心跳检测记录
    option    dontlognull
    #连接超时（毫秒）
    timeout connect 5000
    #客户端超时（毫秒）
    timeout client  50000
    #服务器超时（毫秒）
    timeout server  50000

#监控界面    
listen  admin_stats
    #监控界面的访问的IP和端口
    bind  0.0.0.0:8888
    #访问协议
    mode        http
    #URI相对地址
    stats uri   /dbs
    #统计报告格式
    stats realm     Global\ statistics
    #登陆帐户信息
    stats auth  admin:abc123456
#数据库负载均衡
listen  proxy-mysql
    #访问的IP和端口
    bind  0.0.0.0:3306  
    #网络协议
    mode  tcp
    #负载均衡算法（轮询算法）
    #轮询算法：roundrobin
    #权重算法：static-rr
    #最少连接算法：leastconn
    #请求源IP算法：source 
    balance  roundrobin
    #日志格式
    option  tcplog
    #在MySQL中创建一个没有权限的haproxy用户，密码为空。Haproxy使用这个账户对MySQL数据库心跳检测
    option  mysql-check user haproxy
    server  MySQL_1 172.18.0.2:3306 check weight 1 maxconn 2000  
    server  MySQL_2 172.18.0.3:3306 check weight 1 maxconn 2000  
    server  MySQL_3 172.18.0.4:3306 check weight 1 maxconn 2000 
    server  MySQL_4 172.18.0.5:3306 check weight 1 maxconn 2000
    server  MySQL_5 172.18.0.6:3306 check weight 1 maxconn 2000
    #使用keepalive检测死链
    option  tcpka
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;（三）、创建haproxy容器&quot;&gt;（三）、创建haproxy容器&lt;/h3&gt;
&lt;p&gt;命令：&lt;code&gt;docker run -it -d -p 4001:8888 -p 4002:3306 -v /root/haproxy:/usr/local/etc/haproxy --name haproxy1 --privileged --net=mysql_net haproxy&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这里把监控界面的8888端口映射到宿主机的4001，然后把数据库负载均衡的3306端口映射到宿主机的4002&lt;/p&gt;
&lt;p&gt;演示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;⚡ root@ataola  ~/haproxy  docker run -it -d -p 4001:8888 -p 4002:3306 -v /root/haproxy:/usr/local/etc/haproxy --name haproxy1 --privileged --net=mysql_net haproxy
0e4ef69c19b981163067ec8af0c38b6fa84c380855c22309a884f0a0ed691912
 ⚡ root@ataola  ~/haproxy  
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;之后我们进入到这个起起来的容器&lt;code&gt;docker exec -it haproxy1 bash&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;执行配置命令：&lt;code&gt;haproxy -f /usr/local/etc/haproxy/haproxy.cfg&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;（四）、创建haproxy数据库账号&quot;&gt;（四）、创建haproxy数据库账号&lt;/h3&gt;
&lt;p&gt;打开MySQL数据库，创建一个用户&lt;code&gt;CREATE USER 'haproxy'@'%' IDENTIFIED BY 'superman';&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;访问&lt;code&gt;http://localhost:4001/dbs&lt;/code&gt;,就可以看到数据集群的情况。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2055171/202008/2055171-20200831231921377-1630385621.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看到这里就说明你的haproxy搭建成功了，接下来我们进行相关的实践。&lt;/p&gt;
&lt;h2 id=&quot;相关实验&quot;&gt;相关实验&lt;/h2&gt;
&lt;h3 id=&quot;实验须知&quot;&gt;实验须知&lt;/h3&gt;
&lt;p&gt;这里我们在创建了一个test数据库，在数据库中创建一张数据表为user，并添加相应的字段和数据，具体的如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2055171/202008/2055171-20200831231939002-1301511289.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;实验一：在主节点和从节点都完好的情况下，分别向主节点和从节点插入数据，看看其他节点的变化。&quot;&gt;实验一：在主节点和从节点都完好的情况下，分别向主节点和从节点插入数据，看看其他节点的变化。&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;主节点插入：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们尝试在主节点mysql_node1插入数据，然后去mysql_node_2去读取数据，这里我们就直接硬核的手动挡来吧（PS：初次加载时间长，如下图）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2055171/202008/2055171-20200831231956612-2118101154.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到我们从mysql_node2节点读取到了mysql_node1主节点写入的内容。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;从节点插入：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;把楼上的例子反过来，这次我们从节点插入，主节点读取看看。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2055171/202008/2055171-20200831232014384-1894007501.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从这个实验，我们可以印证一点的是，主从节点都是可以读写的。&lt;/p&gt;
&lt;h3 id=&quot;实验二：挂掉主节点，从节点看能不能插入&quot;&gt;实验二：挂掉主节点，从节点看能不能插入&lt;/h3&gt;
&lt;p&gt;接下来我们就要开始搞事情了，把主节点停掉，再从节点插入数据看看。&lt;/p&gt;
&lt;p&gt;命令：&lt;code&gt;docker pause mysql_node1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;演示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2055171/202008/2055171-20200831232032078-1359947315.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个时候主节点是打不开的，相当于宕机了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2055171/202008/2055171-20200831232045011-241476628.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2055171/202008/2055171-20200831232057647-469090336.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们尝试着在从节点插入数据,发现从节点也是打不开的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2055171/202008/2055171-20200831232112272-1759417653.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这印证了上面说的强一致性，同步机制为同步, 当主节点挂了以后，其余节点不可读写。&lt;/p&gt;
&lt;h3 id=&quot;实验三：挂掉某个从节点，看看主从节点能否插入&quot;&gt;实验三：挂掉某个从节点，看看主从节点能否插入&lt;/h3&gt;
&lt;p&gt;我们把node3和node4服务给停掉，接着我们尝试着打开node1去插入一条张东升试试&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2055171/202008/2055171-20200831232126344-2129067510.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2055171/202008/2055171-20200831232142491-1655132048.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到在主节点插入数据，从节点也能够同步。&lt;/p&gt;
&lt;p&gt;接着我们在node2从节点插入张朝阳&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2055171/202008/2055171-20200831232158269-469378707.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到从节点插入成功，也同步到了主节点。&lt;/p&gt;
&lt;p&gt;这个时候，我们把node3和node4起起来，看下数据会不会进行一个同步&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2055171/202008/2055171-20200831232215666-336755305.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，当node3和node4恢复的时候，便会进行一个数据同步，我们便在node3和node4中看到了张东升和张朝阳。&lt;/p&gt;
&lt;h2 id=&quot;参考文献&quot;&gt;参考文献&lt;/h2&gt;
&lt;p&gt;percona介绍：&lt;a href=&quot;https://hub.docker.com/_/percona&quot;&gt;https://hub.docker.com/_/percona&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;percona安装：&lt;a href=&quot;https://www.percona.com/doc/percona-server/8.0/installation/docker.html&quot;&gt;https://www.percona.com/doc/percona-server/8.0/installation/docker.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Docker环境下的前后端分离项目部署与运维： &lt;a href=&quot;https://coding.imooc.com/class/219.html&quot;&gt;https://coding.imooc.com/class/219.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;最后&quot;&gt;最后&lt;/h2&gt;
&lt;p&gt;写到这里，笔者也只是记流水账一样，记录了当时的操作过程并加以复现，并没有对集群关于性能热备份冷备份等等方面进行深入探讨学习，这里仅作抛砖引玉，有兴趣的童鞋接力实践吧！&lt;/p&gt;
&lt;p&gt;&lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by-nc-sa/4.0/&quot;&gt;&lt;img alt=&quot;知识共享许可协议&quot; src=&quot;https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png&quot;/&gt;&lt;/a&gt;&lt;br/&gt;本作品采用&lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by-nc-sa/4.0/&quot;&gt;知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议&lt;/a&gt;进行许可。&lt;/p&gt;
</description>
<pubDate>Mon, 31 Aug 2020 15:23:00 +0000</pubDate>
<dc:creator>丰臣正一</dc:creator>
<og:description>服务器快过期了，清一点库存，把运维这块的知识复习下 为什么要搭MySQL集群 技术层面上，传统的单节点数据库，万一宕机了，就凉凉了。容灾性能差、抗并发能力有限，数据量大的时候查询有瓶颈。学习层面上，作</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cnroadbridge/p/13593685.html</dc:identifier>
</item>
<item>
<title>07.初步学习redis哨兵机制 - MrMirror</title>
<link>http://www.cnblogs.com/mrmirror/p/13592512.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mrmirror/p/13592512.html</guid>
<description>&lt;h3 id=&quot;一、哨兵sentinal的介绍&quot;&gt;一、哨兵(sentinal)的介绍&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;哨兵是redis集群架构中非常重要的一个组件，主要功能如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;集群监控&lt;/strong&gt;，负责监控redis master和slave进程是否正常工作&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;消息通知&lt;/strong&gt;，如果某个redis实例有故障，那么哨兵负责发送消息作为报警通知给管理员&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;故障转移&lt;/strong&gt;，如果master node挂掉了，会自动转移到slave node上&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;配置中心&lt;/strong&gt;，如果故障转移发生了，通知client客户端新的master地址&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;哨兵本身也是&lt;strong&gt;分布式&lt;/strong&gt;的，作为一个哨兵集群去运行，互相协同工作&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;故障转移时，判断一个master node宕机了，需要大部分的哨兵都同意才行，涉及到了分布式选举的问题&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;即使部分哨兵节点挂掉了，哨兵集群还是能正常工作的&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; &lt;br/&gt; &lt;/p&gt;
&lt;h3 id=&quot;二、主观和客观宕机&quot;&gt;二、主观和客观宕机&lt;/h3&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;sdown&lt;/strong&gt;：主观宕机，就一个哨兵如果自己觉得一个master宕机了，那么就是主观宕机&lt;br/&gt;&lt;strong&gt;odown&lt;/strong&gt;：客观宕机，如果quorum数量的哨兵都觉得一个master宕机了，那么就是客观宕机&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;达成条件&quot;&gt;达成条件&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;sdown&lt;/strong&gt;：，如果一个哨兵ping一个master，超过了is-master-down-after-milliseconds指定的毫秒数之后，就主观认为master宕机&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;odown&lt;/strong&gt;：如果一个哨兵在指定时间内，收到了quorum指定数量的其他哨兵也认为那个master是sdown了，那么就认为是odown了，客观认为master宕机&lt;/p&gt;
&lt;p&gt; &lt;br/&gt; &lt;/p&gt;
&lt;h3 id=&quot;三、哨兵集群的自动发现机制&quot;&gt;三、哨兵集群的自动发现机制&lt;/h3&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;哨兵互相之间的发现&lt;/strong&gt;，是通过redis的pub/sub系统实现的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;每隔两秒钟，每个哨兵都会往自己监控的某个master+slaves对应的__sentinel__:hello channel里发送一个消息，内容是自己的host、ip和runid还有对这个master的监控配置&lt;/li&gt;
&lt;li&gt;每个哨兵也会去监听自己监控的每个master+slaves对应的__sentinel__:hello channel，然后去感知到同样在监听这个master+slaves的其他哨兵的存在&lt;/li&gt;
&lt;li&gt;每个哨兵还会跟其他哨兵交换对master的监控配置，互相进行监控配置的同步&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt; &lt;br/&gt; &lt;/p&gt;
&lt;h3 id=&quot;四、slave配置的自动纠正&quot;&gt;四、slave配置的自动纠正&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;哨兵会负责自动纠正slave的一些配置，比如slave如果要成为潜在的master候选人，哨兵会确保slave在复制现有master的数据; 如果slave连接到了一个错误的master上，比如故障转移之后，那么哨兵会确保它们连接到正确的master上&lt;/p&gt;
&lt;p&gt; &lt;br/&gt; &lt;/p&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;hi~我是Mirror，一个为了自由安逸的未来而不断前进的的程序员。&lt;br/&gt;如果你觉得文章对你有一点点帮助，一个小小赞，便是对我的认可，如果有不足之处，也欢迎各位指正。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 31 Aug 2020 14:52:00 +0000</pubDate>
<dc:creator>MrMirror</dc:creator>
<og:description>一、哨兵(sentinal)的介绍 哨兵是redis集群架构中非常重要的一个组件，主要功能如下： 集群监控，负责监控redis master和slave进程是否正常工作 消息通知，如果某个redis实</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mrmirror/p/13592512.html</dc:identifier>
</item>
<item>
<title>递归的编译优化(1) - 窗户</title>
<link>http://www.cnblogs.com/Colin-Cai/p/13499260.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Colin-Cai/p/13499260.html</guid>
<description>&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
　　版权申明：本文为博主窗户(Colin Cai)原创，欢迎转帖。如要转贴，必须注明原文网址

　　http://www.cnblogs.com/Colin-Cai/p/13499260.html 

　　作者：窗户

　　QQ/微信：6679072

　　E-mail：6679072@qq.com
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　本系列文章是想思考思考递归的编译优化问题，目标在于希望如何从编译、解释层次将树递归进行优化，从而避免过低效率运行。本章来讲讲树递归的问题。&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;&lt;span&gt;几个递归问题&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　先来看这样一个知名数列Fibnacci数列，定义如下&lt;/p&gt;
&lt;p&gt;　　$&lt;/p&gt;
&lt;p&gt;　　fib_{n} = \left\{\begin{matrix}&lt;br/&gt;　　　　1， &amp;amp; n = 1,2\\&lt;br/&gt;　　　　fib_{n-1}+fib_{n-2},&amp;amp; n&amp;gt;3&lt;br/&gt;　　\end{matrix}\right.&lt;/p&gt;
&lt;p&gt;　　$&lt;/p&gt;
&lt;p&gt;　　获得数列第n项用程序写如下，以下可以看成是伪码，只是用Python写出来，其实用什么语言写出来对于本文章所述说内容来说没太大关系：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; fib(n):
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; n &amp;lt; 3&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 1
    &lt;span&gt;return&lt;/span&gt; fib(n-1) + fib(n-2)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　再来看另外一个问题，如下图这样的方格，从A走到B，每次往右走一步或每次往上走一步，问有多少走法。　　&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1151747/202008/1151747-20200815193220045-1752472862.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　稍微加分析我们就可以知道，对于从(0,0)到坐标(x, y)的走法数量：&lt;/p&gt;
&lt;p&gt;　　(1)如果在两条坐标轴上，也就是x=0或者y=0，那么只有一种走法&lt;/p&gt;
&lt;p&gt;　　(2)除此之外，任何一种走法走到(x,y)之前的上一步，则要么是走到了(x-1,y)，要么是走到了(x,y-1)。从而，这种情况下，走到(x,y)的走法数量应该是走到(x-1,y)的走法数量和走到(x,y-1)的走法数量之和。&lt;/p&gt;
&lt;p&gt;　　用程序来表达，应该是&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; ways(x, y):
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; x==0 &lt;span&gt;or&lt;/span&gt; y==&lt;span&gt;0:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 1
    &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ways(x-1, y) + ways(x, y-1)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　再看一个问题，可以称之为零钱问题。假如有1分、2分、5分、10分、20分、50分、100分、200分、500分、1000分这几种面值各不相同的货币，组成1000分一共有多少种方法。&lt;/p&gt;
&lt;p&gt;　　这个问题一眼看上去可能会觉得毫无头绪，但依然存在树递归的方法。我们把原问题看成是changes(total, notes)，total为希望组成的钱的数量，notes是各种货币面值组成的list，其递归思路如下：&lt;/p&gt;
&lt;p&gt;　　(1)如果total=0，则组成方法当然只有一种。&lt;/p&gt;
&lt;p&gt;　　(2)如果total&amp;lt;0，则组成方法一种都没有。&lt;/p&gt;
&lt;p&gt;　　(3)如果total≥0且notes里面一种货币都没有，则组成方法也是一种都没有。&lt;/p&gt;
&lt;p&gt;　　(4)其他情况下，从notes中拿出一种货币，那么所有的组成方法包含两类，一类包含刚才这种货币，一类不包含刚才这种货币，两类情况交集为空。&lt;/p&gt;
&lt;p&gt;　　用程序来实现这个递归如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; changes(total, notes):
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; total ==&lt;span&gt; 0:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 1
    &lt;span&gt;if&lt;/span&gt; total &amp;lt;&lt;span&gt; 0:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; 0
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; len(notes) ==&lt;span&gt; 0:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; 0
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; changes(total-&lt;span&gt;notes[0], notes) \
            &lt;/span&gt;+ changes(total, notes[1:])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　原问题则可以靠&lt;span&gt;changes(1000, [1,2,5,10,20,50,100,200,500,1000])&lt;/span&gt;这样去求值了，其中第二个list的顺序并不重要。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;递归的效率&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　实际上，上述的三个Python代码执行以下三个函数调用&lt;/p&gt;
&lt;p&gt;　　fib(100)&lt;/p&gt;
&lt;p&gt;　　ways(100, 100)&lt;/p&gt;
&lt;p&gt;　　changes(1000, [1,2,5,10,20,50,100,200,500,1000])&lt;/p&gt;
&lt;p&gt;　　就可以看出问题，因为这三个函数调用似乎结束不了，最后一个可能需要修改一下栈大小。&lt;/p&gt;
&lt;p&gt;　　一个纯计算的函数的执行卡死，可能是执行运算量过大了。&lt;/p&gt;

&lt;p&gt;　　我们这里只考虑一下fib函数，其他两个类比。&lt;/p&gt;
&lt;p&gt;　　实际上，我们单修改一下，添加一个计数cnt来记录fib被调用的次数，用来估算时间复杂度，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
cnt =&lt;span&gt; 0
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; fib(n):
    &lt;/span&gt;&lt;span&gt;global&lt;/span&gt;&lt;span&gt; cnt
    cnt &lt;/span&gt;+= 1
    &lt;span&gt;if&lt;/span&gt; n &amp;lt; 3&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 1
    &lt;span&gt;return&lt;/span&gt; fib(n-1) + fib(n-2)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我们计算一下fib(10)，得到55&lt;/p&gt;
&lt;p&gt;　　打印cnt，得到109。&lt;/p&gt;
&lt;p&gt;　　实际上，cnt显然是以下这样一个数列&lt;/p&gt;
&lt;p&gt;　　$&lt;/p&gt;
&lt;p&gt;　　cnt_{n} = \left\{\begin{matrix}&lt;br/&gt;　　　　1， &amp;amp; n = 1,2\\ &lt;br/&gt;　　　　cnt_{n-1}+cnt_{n-2}+1,&amp;amp; n&amp;gt;3 &lt;br/&gt;　　\end{matrix}\right.&lt;/p&gt;
&lt;p&gt;　　$&lt;/p&gt;
&lt;p&gt;　　很容易用数学归纳法证明&lt;/p&gt;
&lt;p&gt;　　$cnt_{n}=fib_{n}*2-1$&lt;/p&gt;
&lt;p&gt;　　而fib是指数级的数列，所以这个树递归的计算fib(n)也是n的指数级的计算量，这个当然就可怕了。其他两个也一样是类似的计算量，从而短时间计算不出来是很正常的。&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;&lt;span&gt;递归为什么如此慢&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　为什么这些递归会如此的慢呢？这是一个值得思考的问题，也是提升其效率的入手点。&lt;/p&gt;
&lt;p&gt;　　我们还是从Fibnacci数列开始研究起，我们刚才知道了函数会被调用很多次，于是我们就想，每次调用函数的时候，参数都是什么。修改一下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; fib(n):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Call fib, arg:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, n)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; n &amp;lt; 3&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 1
    &lt;span&gt;return&lt;/span&gt; fib(n-1) + fib(n-2)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我们执行一下fib(6)，得到下面的打印结果：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Call fib, arg: 6&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Call fib, arg: 5&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Call fib, arg: 4&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Call fib, arg: 3&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Call fib, arg: 2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Call fib, arg: 1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Call fib, arg: 2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Call fib, arg: 3&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Call fib, arg: 2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Call fib, arg: 1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Call fib, arg: 4&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Call fib, arg: 3&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Call fib, arg: 2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Call fib, arg: 1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Call fib, arg: 2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　我们观察可以发现，一样参数的fib调用总是频繁发生，我们排除fib(1)、fib(2)这种可以直接得到结果的调用，fib(4)被调用了2次，fib(3)被调用了3次。然而，显然这个函数不包含任何的副作用，也就是函数本身的运算不会影响任何全局变量，所使用的运算部件也不带有任何的随机成分等。那么也就是，这样的函数是数学意义上的函数，所谓“纯函数”，从而相同的参数会计算出相同的值。&lt;/p&gt;
&lt;p&gt;　　比如fib(100)，以下是计算中的递归依赖&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1151747/202008/1151747-20200830201633200-67663590.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;



&lt;p&gt;　　红色的部分都是重复计算，大量的重复计算导致了计算效率过低，同样的事情也发生在ways和changes两个函数上。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1151747/202008/1151747-20200830202154220-246765192.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt; 　　&lt;span&gt;&lt;strong&gt;&lt;span&gt;如何避免重复&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　我们可以在黑板上依次根据规则一项项的写出Fibnacci数列各项，&lt;/p&gt;
&lt;p&gt;　　1 1 2 3 5 8 13 21 34 55 89 144 ...&lt;/p&gt;
&lt;p&gt;　　可以预计，一个小时差不多可以写出第100项，于是人比计算机快？&lt;/p&gt;
&lt;p&gt;　　其实，还是在于人没有重复计算，当然人在这里采用了一个更好的迭代算法也是一个原因。&lt;/p&gt;
&lt;p&gt;　　于是，我们可以想到，之前我们已经分析这些函数都是数学意义下的函数，如果建立一个cache，记录下函数得到的值，每次计算函数，当可能出现递归的时候，都先去查一下cache，如果cache中有，则取出返回，如果没有则递归计算。&lt;/p&gt;
&lt;p&gt;　　fib函数可以按照以上想法改写为这样，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
cache =&lt;span&gt; {}
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; fib(n):
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; n &amp;lt; 3&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 1
    &lt;span&gt;if&lt;/span&gt; n &lt;span&gt;in&lt;/span&gt;&lt;span&gt; cache:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cache[n]
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        r &lt;/span&gt;= fib(n-1) + fib(n-2&lt;span&gt;)
        cache[n] &lt;/span&gt;=&lt;span&gt; r
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; r
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　以此算法来运算fib(100)发现可以瞬间得到&lt;span&gt;354224848179261915075&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　依然以之前的方法记录一下函数调用次数，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
cache =&lt;span&gt; {}
cnt &lt;/span&gt;=&lt;span&gt; 0
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; fib(n):
    &lt;/span&gt;&lt;span&gt;global&lt;/span&gt;&lt;span&gt; cnt
    cnt &lt;/span&gt;+= 1
    &lt;span&gt;if&lt;/span&gt; n &amp;lt; 3&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 1
    &lt;span&gt;if&lt;/span&gt; n &lt;span&gt;in&lt;/span&gt;&lt;span&gt; cache:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cache[n]
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        r &lt;/span&gt;= fib(n-1) + fib(n-2&lt;span&gt;)
        cache[n] &lt;/span&gt;=&lt;span&gt; r
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; r
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　发现计算fib(100)之后，cnt只记录到197，显然cache避免了大量重复计算，从而很快。&lt;/p&gt;
&lt;p&gt;　　编译器判断一个函数是数学函数从而没有副作用其实并不难，只需要满足如下：&lt;/p&gt;
&lt;p&gt;　　(1)函数和全局变量不产生直接交互&lt;/p&gt;
&lt;p&gt;　　(2)函数如果有使用到其他函数，这些外部函数也是数学函数。&lt;/p&gt;
&lt;p&gt;　　(3)函数如果用到操作，所使用的操作不产生副作用。&lt;/p&gt;
&lt;p&gt;　　实际上，可以把操作也看成函数，从而只有上述1、2两条。然后这个cache也是一个k/v系统，此种优化可以在编译器中直接做到。&lt;/p&gt;
&lt;p&gt;　　甚至还可以考虑引入多任务，不过这是个比较麻烦的问题。另外，这种优化并不一定总是可以带来更高的效率，如果没有上述的大量复重复计算，这样的优化反而会加大数据复杂度开销，也加长运算时间。&lt;/p&gt;
&lt;p&gt;　　我这里用阶乘举个例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; factorial(n):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; n == 1&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 1
        &lt;span&gt;return&lt;/span&gt; n * factorial(n-1)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　以上递归并没有重复计算，添加cache如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
cache =&lt;span&gt; {}
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; factorial(n):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; n == 1&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 1
        &lt;span&gt;if&lt;/span&gt; n &lt;span&gt;in&lt;/span&gt;&lt;span&gt; cache:
                &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Cache Hit&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cache[n]
        r &lt;/span&gt;= n * factorial(n-1&lt;span&gt;)
        cache[n] &lt;/span&gt;=&lt;span&gt; r
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; r
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　因为没有重复计算，所以上面的Cache Hit永远不可能打印。&lt;/p&gt;


&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;&lt;span&gt;试图&lt;strong&gt;追求&lt;/strong&gt;更高的效率&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　前面提到可以在黑板上一项一项写出Fibnacci数列，用到的方法是迭代，用Python使用递归形式来描述迭代如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; fib(n):
        &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; fib_iter(n, m, first, second):
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; n ==&lt;span&gt; m:
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; second
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; fib_iter(n, m+1, second, second+&lt;span&gt;first)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; n &amp;lt; 3&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 1
        &lt;span&gt;return&lt;/span&gt; fib_iter(n, 2, 1, 1)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　而用循环来描述迭代如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; fib(n):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; n &amp;lt; 3&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 1&lt;span&gt;
        first &lt;/span&gt;= 1&lt;span&gt;
        second &lt;/span&gt;= 1
        &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(3, n+1&lt;span&gt;):
                first, second &lt;/span&gt;= second, second+&lt;span&gt;first
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; second
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　虽说对于Fibnacci数列求第n项有更好(时间复杂度更低)的算法，但是如果编译器可以自动产生以上算法，已经是可以满意了。&lt;/p&gt;
&lt;p&gt;　　我们思考用递归计算Fibnacci数列中的一项fib(n)&lt;/p&gt;
&lt;p&gt;　　以下符号，-&amp;gt;左边代表目标，-&amp;gt;右边::左边代表依赖值，::右边代表函数，&lt;/p&gt;
&lt;p&gt;　　fib(n)-&amp;gt;fib(n-1) ,fib(n-2)::λx y·x+y&lt;/p&gt;
&lt;p&gt;　　而所依赖的两个值分别是如下依赖，&lt;/p&gt;
&lt;p&gt;　　fib(n-1)-&amp;gt;fib(n-2),fib(n-3)::λx y·x+y&lt;/p&gt;
&lt;p&gt;　　fib(n-2)-&amp;gt;fib(n-3),fib(n-4)::λx y·x+y&lt;/p&gt;
&lt;p&gt;　　从而&lt;/p&gt;
&lt;p&gt;　　fib(n-1),fib(n-2)-&amp;gt;fib(n-3),fib(n-4)::λx y·x+y+x, λx y·x+y&lt;/p&gt;
&lt;p&gt;　　于是我们反复来就可以有以下的依赖&lt;/p&gt;
&lt;p&gt;　　fib(n)-&amp;gt;fib(n-1) ,fib(n-2)::λx y·x+y&lt;/p&gt;
&lt;p&gt;　　fib(n-1),fib(n-2)-&amp;gt;fib(n-3),fib(n-4)::λx y·x+y+x, λx y·x+y&lt;/p&gt;
&lt;p&gt;　　fib(n-3),fib(n-4)-&amp;gt;fib(n-5),fib(n-6)::λx y·x+y+x, λx y·x+y&lt;/p&gt;
&lt;p&gt;　　...&lt;/p&gt;
&lt;p&gt;　　于是我们的依赖&lt;/p&gt;
&lt;p&gt;　　fib(n)-&amp;gt;fib(n-1),fib(n-2)-&amp;gt;fib(n-3),fib(n-4)-&amp;gt;fib(n-5,n-6)...&lt;/p&gt;
&lt;p&gt;　　反过来&lt;/p&gt;
&lt;p&gt;　　f(1),f(2)=&amp;gt;f(3),f(4)=&amp;gt;f(5),f(6)....f(n)&lt;/p&gt;
&lt;p&gt;　　于是我们就有了一个O(1)空间的迭代，然而问题在于，我们怎么知道反过来可以从f(1),f(2)开始推呢？&lt;/p&gt;

&lt;p&gt;　　而考虑第二个问题ways递归，问题则变得麻烦了许多。&lt;/p&gt;
&lt;p&gt;　　ways(a,b)-&amp;gt;ways(a-1,b),ways(a,b-1)::λx y·x+y&lt;/p&gt;
&lt;p&gt;　　而&lt;/p&gt;
&lt;p&gt;　　ways(a-1,b)-&amp;gt;ways(a-2,b),ways(a-1,b-1)::λx y·x+y&lt;/p&gt;
&lt;p&gt;　　ways(a,b-1)-&amp;gt;ways(a-1,b-1),ways(a,b-2)::λx y·x+y&lt;/p&gt;
&lt;p&gt;　　从而&lt;/p&gt;
&lt;p&gt;　　ways(a-1,b),ways(a,b-1)-&amp;gt;ways(a-2,b),ways(a-1,b-1),ways(a,b-2)::λx y z·x+y,λx y z·y+z&lt;/p&gt;
&lt;p&gt;　　....&lt;/p&gt;
&lt;p&gt;　　于是我们通过观察，可以反过来这样去推：&lt;/p&gt;
&lt;p&gt;　　f(1,1)=&amp;gt;f(2,1),f(1,2)=&amp;gt;f(3,1),f(2,2),f(3,3)=&amp;gt;....　&lt;/p&gt;
&lt;p&gt;　　其中省略所有的递归边界条件，比如&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;f(2,1) = f(1,1)+f(2,0) = f(1,1)+1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　于是，这几乎成了一个人脑才能理解的问题，很难有固定的算法可以将树递归转换为迭代，不过得到一种人脑似乎可以通过树递归寻找迭代的方法，也算不错。&lt;/p&gt;
&lt;p&gt;　　当然，编译器大多数优化方法还是使用粒度更细的模板式寻找和替换，没有通式的优化，可以采用模板式的匹配，替换。&lt;/p&gt;
</description>
<pubDate>Mon, 31 Aug 2020 14:30:00 +0000</pubDate>
<dc:creator>窗户</dc:creator>
<og:description>版权申明：本文为博主窗户(Colin Cai)原创，欢迎转帖。如要转贴，必须注明原文网址 http://www.cnblogs.com/Colin-Cai/p/13499260.html 作者：窗户</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Colin-Cai/p/13499260.html</dc:identifier>
</item>
<item>
<title>理解Django 中Call Stack 机制的小Demo - JohnYang819</title>
<link>http://www.cnblogs.com/johnyang/p/13592340.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/johnyang/p/13592340.html</guid>
<description>&lt;p&gt;&lt;strong&gt;1.工作流程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;request/response模式下，request并不是直接到达view方法，view方法也不是将返回的response直接发送给浏览器的，而是request由外到里的层层通过各种middleware层，这个时候可以对request做一些事情，到最后一层也就是最内层时，得到view方法返回的response，然后再把这个response再由内到外层层传递出来，这时候可以对response做一些事情，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1599580/202008/1599580-20200831221138410-1141044968.png&quot; alt=&quot;&quot; width=&quot;441&quot; height=&quot;224&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; 2.原理&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
class SimpleMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response
        # One-time configuration and initialization.

    def __call__(self, request):
        # Code to be executed for each request before
        # the view (and later middleware) are called.

        response = self.get_response(request)

        # Code to be executed for each request/response after
        # the view is called.

        return response
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　每个middleware都如上面代码一样，有两个必须的函数：（1）__init__(self,get_response)，负责在web server启动时完成初始化，即建立与下一层middleware的联系.（2）__call__(self,request)，在每次request下，被调用。&lt;/p&gt;
&lt;p&gt;有三个可选的函数：（1）process_view:__init__和__call__对view 方法一无所知，而process_view给了通道（give access to)在调用view方法之前获晓view方法及其参数，如果出现了，则它在__call__调用后，在self.get_response(request)之前调用，因此可以触发view 方法。（2）process_exception:如果在view方法中出现异常，该函数可以提供机会来处理异常（3）process_template_response:在self.get_response(request)调用后，view方法结束后，提供修改response的机会，需要注意的是该函数仅仅在view方法返回的是TemplateResponse类的情况下有效，如果返回的是render() ，则该函数不被触发。&lt;/p&gt;
&lt;p&gt;详见&lt;a href=&quot;https://docs.djangoproject.com/en/3.1/topics/http/middleware/&quot;&gt;https://docs.djangoproject.com/en/3.1/topics/http/middleware/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（3）供进一步理解call stack 机制的小demo（仅供参考）&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
import time
class Base:
        def __init__(self,get_response):
                self.get_response=get_response
        def __call__(self,request=None):
                self.pre()
                response=self.get_response(request)
                self.after()
                return response 
        def pre(self):
                pass 
        def after(self):
                pass 
class Response:
        def __init__(self):
                pass 
def view(request):
        return Response()
def startServer(callstackSets,view):
        callstackSets.reverse()
        last=callstackSets.pop(0)(view)
        for i in range(len(callstackSets)):
                last=callstackSets.pop(0)(last)
        return last
class A(Base):
        def pre(self):
                print('In A')
        def after(self):
                print('Out A ')
class B(Base):
        def pre(self):
                print('In B')
        def after(self):
                print('Out B ')
class C(Base):
        def pre(self):
                print('In C')
        def after(self):
                print('Out C ')
if __name__=='__main__':
        callstackSets=[A,B,C]
        calls=startServer(callstackSets,view)
        calls('req')
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　运行后：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1599580/202008/1599580-20200831222108096-1868778070.png&quot; alt=&quot;&quot; width=&quot;379&quot; height=&quot;338&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 可以看到完成了既定的目标，request进来后，一层一层的进入，直到最内层C，调用view方法，得到response,然后将response从最内层一层一层的传递出来！&lt;/p&gt;

</description>
<pubDate>Mon, 31 Aug 2020 14:22:00 +0000</pubDate>
<dc:creator>JohnYang819</dc:creator>
<og:description>1.工作流程 request/response模式下，request并不是直接到达view方法，view方法也不是将返回的response直接发送给浏览器的，而是request由外到里的层层通过各种m</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/johnyang/p/13592340.html</dc:identifier>
</item>
</channel>
</rss>