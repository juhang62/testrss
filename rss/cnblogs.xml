<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>支撑微博亿级社交平台，小白也能玩转Redis集群(实战篇) - 分布式系统架构</title>
<link>http://www.cnblogs.com/caison/p/11717636.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/caison/p/11717636.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1317777/201910/1317777-20191022082510118-1386746411.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上篇文章《支撑微博亿级社交平台，小白也能玩转Redis集群(原理篇)》介绍了Redis集群相关原理，这篇文章将介绍Redis Cluster集群的搭建、配置，运维、扩容等具体操作&lt;/p&gt;

&lt;p&gt;2018年10月 Redis 发布了稳定版本的 5.0 版本，推出了各种新特性，其中一点是集群管理工具从基于Ruby的redis-trib.rb移植到基于C语言redis-cli中，方便集群的构建和管理&lt;/p&gt;
&lt;p&gt;Redis Cluster集群运行至少需要包含3个主节点，实现高可用最少需要3主3从6个节点&lt;/p&gt;
&lt;p&gt;以下步骤基于Redis 5.0.5版本，介绍如何在一台 Linux 服务器上搭建有3主3从的6节点的 Redis集群&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;步骤1 创建安装目录&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;mkdir -p /data/project/redis-cluster&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;步骤2 下载源码并解压编译&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;cd /data/project/redis-cluster
wget http://download.redis.io/releases/redis-5.0.5.tar.gz
tar xzf redis-5.0.5.tar.gz
cd redis-5.0.5
make&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行make后，如果报错“jemalloc/jemalloc.h：没有那个文件或目录”，可以改为用以下命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;make MALLOC=libc&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;步骤3 创建6个Redis配置文件&lt;/strong&gt;&lt;br/&gt;6个配置文件不能在同一个目录，下面Redis 6个节点分别安装在7000~7005端口&lt;br/&gt;首先创建配置文件目录及文件，定义如下：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;mkdir -p /data/project/redis-cluster/nodes/7000
mkdir -p /data/project/redis-cluster/nodes/7001
mkdir -p /data/project/redis-cluster/nodes/7002
mkdir -p /data/project/redis-cluster/nodes/7003
mkdir -p /data/project/redis-cluster/nodes/7004
mkdir -p /data/project/redis-cluster/nodes/7005

touch /data/project/redis-cluster/nodes/7000/redis.conf
touch /data/project/redis-cluster/nodes/7001/redis.conf
touch /data/project/redis-cluster/nodes/7002/redis.conf
touch /data/project/redis-cluster/nodes/7003/redis.conf
touch /data/project/redis-cluster/nodes/7004/redis.conf
touch /data/project/redis-cluster/nodes/7005/redis.conf&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;redis.conf配置文件的内容为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;############################## 网络 ##############################
# 端口
port 7000
# 非保护模式，如果值为yes，则必须是 bind配置指定的ip的机器连接或者使用密码连接
protected-mode no 

############################## 通用 ##############################
# 后台运行
daemonize yes 
# 记录redis进程pid
pidfile  /var/run/redis_7000.pid

############################## 集群 ##############################
# 启用集群模式
cluster-enabled yes 
cluster-config-file nodes_7000.conf
# 集群节点如果在该超时时间(毫秒)内不可达，则认为节点处于故障状态
cluster-node-timeout 5000

############################## 持久化 ##############################
# AOF, RDB持久化文件目录
dir /data/project/redis-cluster/nodes
# 开启AOF持久化
appendonly yes
# AOF文件名
appendfilename &quot;appendonly_7000.aof&quot;
# 当目前aof文件大小超过上一次重写的aof文件大小的百分之多少进行重写
auto-aof-rewrite-percentage 100
# 设置允许重写的最小aof文件大小，避免了达到约定百分比但尺寸仍然很小的情况还要重写
auto-aof-rewrite-min-size 64mb
# RDB文件名
dbfilename dump_7000.rdb&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中 port 、 pidfile、cluster-config-file、appendfilename、 dbfilename配置需要随着节点的不同而调整&lt;/p&gt;
&lt;p&gt;配置项说明可以参考redis-5.0.5/redis.conf，每一项都介绍得很详细，推荐阅读&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;步骤4 启动节点&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;/data/project/redis-cluster/redis-5.0.5/src/redis-server /data/project/redis-cluster/nodes/7000/redis.conf
/data/project/redis-cluster/redis-5.0.5/src/redis-server /data/project/redis-cluster/nodes/7001/redis.conf
/data/project/redis-cluster/redis-5.0.5/src/redis-server /data/project/redis-cluster/nodes/7002/redis.conf
/data/project/redis-cluster/redis-5.0.5/src/redis-server /data/project/redis-cluster/nodes/7003/redis.conf
/data/project/redis-cluster/redis-5.0.5/src/redis-server /data/project/redis-cluster/nodes/7004/redis.conf
/data/project/redis-cluster/redis-5.0.5/src/redis-server /data/project/redis-cluster/nodes/7005/redis.conf&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ps -ef|grep redis，可以看到6个redis进程已启动：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1317777/201910/1317777-20191022082510336-987048863.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;步骤5 启动集群&lt;/strong&gt;&lt;br/&gt;使用如下命令启动集群，IP地址自行替换：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;/data/project/redis-cluster/redis-5.0.5/src/redis-cli --cluster create 192.168.56.102:7000 192.168.56.102:7001 192.168.56.102:7002 192.168.56.102:7003 192.168.56.102:7004 192.168.56.102:7005 --cluster-replicas 1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动成功信息如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1317777/201910/1317777-20191022082510475-261037360.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到此，Redis Cluster 集群搭建完成&lt;/p&gt;

&lt;p&gt;Redis5的redis-cli新增系列集群运维功能，查看命令详情：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/data/project/redis-cluster/redis-5.0.5/src/redis-cli --cluster help&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1317777/201910/1317777-20191022082510616-1469942602.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;命令参数具体作用可以参考官方文档，下面会基于其中一些常用命令对集群进行管理&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;检查节点状态&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;/data/project/redis-cluster/redis-5.0.5/src/redis-cli --cluster check 192.168.56.102:7000&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1317777/201910/1317777-20191022082510767-1601678771.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;查看集群信息&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;/data/project/redis-cluster/redis-5.0.5/src/redis-cli --cluster info 192.168.56.102:7000&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1317777/201910/1317777-20191022082510914-1358046291.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;集群现在有3主3从，下面新增4个节点扩容变成5主5从&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;步骤1 启动新节点&lt;/strong&gt;&lt;br/&gt;创建4个Redis配置文件，端口号为7006~7009，然后启动节点(参考“集群搭建”的步骤3和步骤4)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;步骤2 新节点加入集群&lt;/strong&gt;&lt;br/&gt;设置4个节点分别加入已有redis集群，2个为主节点，2个为从节点&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;/data/project/redis-cluster/redis-5.0.5/src/redis-cli --cluster add-node 192.168.56.102:7006 192.168.56.102:7005 
/data/project/redis-cluster/redis-5.0.5/src/redis-cli --cluster add-node 192.168.56.102:7007 192.168.56.102:7005 

# 24e2c是节点7006的id，代表该节点加入集群并为7006的从节点
/data/project/redis-cluster/redis-5.0.5/src/redis-cli --cluster add-node 192.168.56.102:7008 192.168.56.102:7005 --cluster-slave --cluster-master-id 24e2c369678952b07d95c0a4b49c2d7a7b2e2bf7 
# 24e2c是节点7007的id，代表该节点加入集群并为7007的从节点
/data/project/redis-cluster/redis-5.0.5/src/redis-cli --cluster add-node 192.168.56.102:7009  192.168.56.102:7005 --cluster-slave --cluster-master-id ab0f74a19819a74238df7a510494e9418678cbe1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时集群状态如下，其中主节点7006和主节点7007还没分配任何slot，在下面的步骤会进行分配：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1317777/201910/1317777-20191022082511068-565650758.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;步骤3 模拟slot重新平衡分配&lt;/strong&gt;&lt;br/&gt;基于rebalance命令，增加--cluster-simulat参数，查看会迁移哪些slots，而不会真正执行迁移操作&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;/data/project/redis-cluster/redis-5.0.5/src/redis-cli --cluster rebalance 192.168.56.102:7000 --cluster-threshold 1 --cluster-use-empty-masters  --cluster-simulat&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回以下迁移信息：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1317777/201910/1317777-20191022082511257-2048231229.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;步骤4 执行slot重新平衡分配&lt;/strong&gt;&lt;br/&gt;执行rebalance命令，平衡集群节点slot数量，重新分配slot( 去掉--cluster-simulat)&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;/data/project/redis-cluster/redis-5.0.5/src/redis-cli --cluster rebalance 192.168.56.102:7000 --cluster-threshold 1 --cluster-use-empty-masters&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1317777/201910/1317777-20191022082511424-1415205633.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，集群扩容完成，集群缩容的话，需要基于reshard将需被下线的结点中的slot移到其他结点，然后基于del-node命令删除结点&lt;/p&gt;

&lt;p&gt;这篇文章介绍Redis Cluster集群一些基本实现，篇幅所限，后面有机会再展开介绍Redis一些线上问题踩坑经验、监控运维平台建设，欢迎继续关注&lt;/p&gt;

&lt;p&gt;redis cluster管理工具redis-trib-rb详解&lt;br/&gt;&lt;a href=&quot;http://weizijun.cn/2016/01/08/redis%20cluster%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7redis-trib-rb%E8%AF%A6%E8%A7%A3/&quot;&gt;http://weizijun.cn/2016/01/08/redis%20cluster管理工具redis-trib-rb详解/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1317777/201910/1317777-20191022082511577-290072449.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 22 Oct 2019 00:25:00 +0000</pubDate>
<dc:creator>分布式系统架构</dc:creator>
<og:description>上篇文章《支撑微博亿级社交平台，小白也能玩转Redis集群(原理篇)》介绍了Redis集群相关原理，这篇文章将介绍Redis Cluster集群的搭建、配置，运维、扩容等具体操作 集群搭建 2018年</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/caison/p/11717636.html</dc:identifier>
</item>
<item>
<title>java架构之路-（Redis专题）Redis的主从、哨兵和集群 - oO从零开始Oo</title>
<link>http://www.cnblogs.com/cxiaocai/p/11711377.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cxiaocai/p/11711377.html</guid>
<description>&lt;p&gt;　　我们使用的redis，单机的绝对做不到高可用的，万一单机的redis宕机了，就没有备用的了，我们可以采用集群的方式来保证我们的高可用操作。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;主从架构&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1506597/201910/1506597-20191021095638454-500111094.png&quot; alt=&quot;&quot; width=&quot;503&quot; height=&quot;339&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　大致就是这样的，一个主节点，两个从节点（一般两个就可以了）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主从工作原理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 　　如果你为master配置了一个slave，不管这个slave是否是第一次连接上Master，它都会发送一个SYNC命 令(redis2.8版本之前的命令)给master请求复制数据。 master收到SYNC命令后，会在后台进行数据持久化通过bgsave生成最新的rdb快照文件，持久化期间， master会&lt;span&gt;继续接收&lt;/span&gt;客户端的请求，它会把这些可能修改数据集的请求缓存在内存中。当持久化进行完毕以 后，master会把这份rdb文件数据集发送给slave，slave会把接收到的数据进行持久化生成rdb，然后再加载到内存中。然后master再将之前缓存在内存中的命令发送给slave。 当master与slave之间的连接由于某些原因而断开时，slave能够自动重连Master，如果master收到了多 个slave并发连接请求，它只会进行一次持久化，而不是一个连接一次，然后再把这一份持久化的数据发送 给多个并发连接的slave。 当master和slave断开重连后，一般都会对整份数据进行复制。但从redis2.8版本开始，master和slave断开重连后支持部分复制。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1506597/201910/1506597-20191021131140114-2051874720.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　我们在上述文字中可以得出，我们的master得到了SYNC命令以后，还是会继续接收我们客户端的命令的，或者说，我们的slave第一次全量复制了，而第二次就不再需要全量复制了，那么就提到了我们的数据部分复制&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据部分复制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;从2.8版本开始，slave与master能够在网络连接断开重连后只进行部分数据复制。 master会在其内存中创建一个复制数据用的缓存队列，缓存最近一段时间的数据，master和它所有的 slave都维护了复制的数据下标offset和master的进程id，因此，当网络连接断开后，slave会请求master 继续进行未完成的复制，从所记录的数据下标开始。如果master进程id变化了，或者从节点数据下标 offset太旧，已经不在master的缓存队列里了，那么将会进行一次全量数据的复制。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1506597/201910/1506597-20191021132553478-341377553.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　那么我们实际搭建一下我们的redis主从架构。&lt;/p&gt;
&lt;p&gt;1.首先我们准备三台已经安装好redis的服务器，不会安装的小伙伴可以回到我以后的博客去看一下，超详细&lt;a href=&quot;https://www.cnblogs.com/cxiaocai/p/11674716.html&quot;&gt;https://www.cnblogs.com/cxiaocai/p/11674716.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2.修改我们的主节点和从节点配置，将protected-mode no修改为yes，大概在88行，将我们bind 127.0.0.1修改为bind 0.0.0.0，启动一下我们的主节点，然后分别测试一下从节点的服务器是否可以连接我们的主节点（我怕你们防火墙开着），输入$ redis-cli -h  &lt;span&gt;主节点IP &lt;/span&gt;  -p  &lt;span&gt;主节点redis端口 。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@iZm5ec3zn3tzdvp7ttnnosZ redis-5.0.5]&lt;span&gt;#&lt;/span&gt;&lt;span&gt; ./src/redis-cli -h 47.104.129.103 -p 6379&lt;/span&gt;
47.104.129.103:6379&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;注意：我们需要保证主节点和从节点是可以互通的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3.确保可以连接了，我们来配置从节点，我们全局搜索一下replica-read-only 改为replica-read-only yes（搜不到自己写上replica-read-only yes）大概在326行，表示从节点只读不写。在replica‐read‐only yes上面设置replicaof 47.104.129.103 6379。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; administrative / dangerous commands.&lt;/span&gt;&lt;span&gt;
replicaof &lt;/span&gt;47.104.129.103 6379&lt;span&gt;
replica&lt;/span&gt;-read-&lt;span&gt;only yes
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Replication SYNC strategy: disk or socket.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4.启动从节点，在主节点写入，查看从节点是否得到数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1506597/201910/1506597-20191021112547430-1901614512.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 配置完成，over~！&lt;/p&gt;
&lt;div class=&quot;page&quot; title=&quot;Page 6&quot; readability=&quot;41&quot;&gt;
&lt;div class=&quot;section&quot; readability=&quot;27&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;哨兵架构&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;span&gt;其实我们的主从架构只保证了数据的一致性，但是还是解决不了我们的高可用，我们的master节点宕机了，我们的服务还是不可用的。没有Zookeeper的选举机制，我们来看看我们的哨兵架构。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;哨兵就是保证我们的master不会宕机，当master宕机以后，他会主动选举出来一个节点作为我们的master。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1506597/201910/1506597-20191021135008528-166055542.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　sentinel哨兵是特殊的redis服务，&lt;span&gt;不提供读写服务&lt;/span&gt;，主要用来监控redis实例节点。 哨兵架构下client端第一次从哨兵找出redis的主节点，后续就直接访问redis的主节点，不会每次都通过 sentinel代理访问redis的主节点，当redis的主节点发生变化，哨兵会第一时间感知到，并且将新的redis 主节点通知给client端(这里面redis的client端一般都实现了订阅功能，订阅sentinel发布的节点变动消息)&lt;/p&gt;
&lt;p&gt;　　配置起来也是很简单的，还是我们上一次的主从架构，然后加上我们的哨兵集群。&lt;/p&gt;
&lt;p&gt;1.准备好我们刚才搭建完成的主从架构&lt;/p&gt;
&lt;p&gt;2.准备三个以上的服务器（推荐奇数个服务器，有内部选举），安装我们的Redis，需要服务器之间都相通，上面主从说过&lt;/p&gt;
&lt;p&gt;3.修改我们的sentinel.conf文件&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;page&quot; title=&quot;Page 6&quot; readability=&quot;35&quot;&gt;
&lt;div class=&quot;section&quot; readability=&quot;16.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
daemonize yes &lt;span&gt;#&lt;/span&gt;&lt;span&gt;允许后台启动&lt;/span&gt;
sentinel monitor mymaster 192.168.0.60 6379 2 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置连接我们的redis主从master 2表示服务器的数目/2取整数+1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4.输入src/redis‐sentinel sentinel.conf启动我们的程序，这时我们的端口是26379。&lt;span&gt;注意：这里的启动不再是src/redis‐server。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;5.输入src/redis‐cli进入客户端，输入info，即可查看我们的sentinel 信息。&lt;/p&gt;
&lt;p&gt;　　哨兵模式也就很简单的配置好了，是在主从的基础之上搭建的，我们之前的主从架构，当我们的master宕机以后，redis也就算是宕机了，不会有任何选举机制，但是我们的哨兵会有一个选举机制，当我们的master宕机以后，我们的哨兵集群会主动选举一个master，然后告知我们的客户端，哪个是新的master。即使我们的曾经的master重新启动了，那也恢复不到主节点了，只能当做从节点（redis集群会详细说这个选举）&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Redis集群架构&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt; 　　我们的哨兵架构，几乎可以做到了我们的要实现的高可用，但是哨兵的选举还是需要时间的，而且中间会阻塞客户端的请求，假如我们的选举消耗了1秒（实际可能几秒，高则几十秒），就在这1秒的时候来了客户端的请求，那个请求也是不可用的，并且我们的读写的节点实际还是单节点的，这时我们有了更好的方案，我们的Redis集群架构，并且现在Redis的集群架构做的也很成熟了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1506597/201910/1506597-20191021205139682-1374683683.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　也就是我们Redis的集群其实就是一个个小的主从结合在一起（官方建议小于1000个小主从），变成了我们的Redis集群，每个小主从也就是我们的Redis数据分片，每个小主从的数据存储是不一样的，内部是有一套他自己的运算规则的。我们还是先来看一下如何配置，上文提过的简单的我就直接过了啊。&lt;/p&gt;
&lt;p&gt;　　1.准备9台服务器，保证互通，下载解压。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1506597/201910/1506597-20191021221154398-1097433487.png&quot; alt=&quot;&quot; width=&quot;2039&quot; height=&quot;1275&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2.编辑我们的redis.conf文件&lt;/p&gt;
&lt;p&gt;　　　　(1)daemonize yes # 设置后台启动，大概在136行&lt;/p&gt;
&lt;p&gt;　　　　(2)cluster-enabled yes # 是否开启集群模式，大概在832行&lt;/p&gt;
&lt;p&gt;　　　　(3)cluster-config-file nodes‐8001.conf #集群节点信息文件，这里800x最好和port对应上，方便后期查找。大概在840行&lt;/p&gt;
&lt;p&gt;　　　　(4)cluster-node-timeout 5000 # 节点离线超时时间，5000毫秒，大概在846行&lt;/p&gt;
&lt;p&gt;　　　　(5)bind 0.0.0.0 #去掉bind绑定访问ip信息，大概在69行&lt;/p&gt;
&lt;p&gt;　　　　(6)protected-mode no #关闭保护模式，大概在88行&lt;/p&gt;
&lt;p&gt;　　　　(7)appendonly yes # 打开AOF，大概在699行&lt;/p&gt;
&lt;p&gt;　　　　(8)requirepass xiaocai #设置redis访问密码，大概在507行&lt;/p&gt;
&lt;p&gt;　　　　(9)masterauth xiaocai # 设置集群节点间访问密码，跟上面一致，大概在293行&lt;/p&gt;
&lt;p&gt;　　3. 配置完成全部启动./src/redis-server redis.conf 检查是否启动成ps -ef|grep redis。我们会看到这样的信息&lt;img src=&quot;https://img2018.cnblogs.com/blog/1506597/201910/1506597-20191021224940031-1633724888.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 这里显示cluster，说到这我们只差最后一步了。&lt;/p&gt;
&lt;p&gt;　　4.我们在任意服务器输入./src/redis-cli -a xiaocai --cluster create --cluster-replicas 2 172.31.179.185:6379 172.31.179.178:6379 172.31.179.184:6379 172.31.179.183:6379 172.31.179.180:6379 172.31.179.181:6379 172.31.179.182:6379 172.31.179.179:6379 172.31.179.177:6379命令，意思是要组建我们的集群环境了，-a后面是密码xiaocai，--cluster-replicas 2这个数字2表示我们每个主节点有几个从节点，一般来说前三个IP会设置为master，输入之后会有确认信息。我们会看到这样的信息，我们输入yes继续&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1506597/201910/1506597-20191021225622069-278274583.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　静静等待一会（时间也不会太久，时间太久的，你去检查一下网络之间互通吗），当我们出现【ok】的画面也就是成功了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1506597/201910/1506597-20191021230757760-197747622.png&quot; alt=&quot;&quot;/&gt;  　　5.我们随便找一个客户端输入./src/redis-cli -a xiaocai，进入我们的客户端，输入cluster info，就可以查看到节点信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1506597/201910/1506597-20191021231237597-1756056451.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 我们看到cluster_known_nodes：9就是我们一共拥有多少节点，cluster_size：3就是我们拥有多少组主从架构。配置完成~！&lt;/p&gt;
&lt;p&gt;扩展：输入cluster nodes还可以查看我们的节点关联信息。&lt;/p&gt;
&lt;p&gt;　　我们在刚才输入我们的cluster info时，我们看到了一个16384，其实就是一个Redis集群的片区，我们在单节点来执行set命令时，并不一定会成功，你可以尝试不同的key试一下，这就是我们的Redis分片区的存储，当你的key属于那个片区下，就会存储到哪个小主从内，其余的并不需要重复存储。在输入cluster nodes时会返回我们的片区信息。片区是从0开始计算，最大到16383的。&lt;/p&gt;
&lt;p&gt;　　今天就说到这里吧，下次我们说下java代码来操作我们的Redis。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1506597/201910/1506597-20191008130905751-289956431.gif&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1506597/201910/1506597-20191008130911073-1068230076.jpg&quot; alt=&quot;&quot; width=&quot;298&quot; height=&quot;297&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;最进弄了一个公众号，小菜技术，欢迎大家的加入&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1506597/201910/1506597-20191006211816137-1624049234.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 22 Oct 2019 00:18:00 +0000</pubDate>
<dc:creator>oO从零开始Oo</dc:creator>
<og:description>我们使用的redis，单机的绝对做不到高可用的，万一单机的redis宕机了，就没有备用的了，我们可以采用集群的方式来保证我们的高可用操作。 主从架构 大致就是这样的，一个主节点，两个从节点（一般两个就</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cxiaocai/p/11711377.html</dc:identifier>
</item>
<item>
<title>AOP框架Dora.Interception 3.0 [2]: 实现原理 - Artech</title>
<link>http://www.cnblogs.com/artech/p/dora-interception-3-2.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/artech/p/dora-interception-3-2.html</guid>
<description>&lt;p&gt;和所有的AOP框架一样，我们必须将正常的方法调用进行拦截，才能将应用到当前方法上的所有拦截器纳入当前调用链。Dora.Interception采用&lt;strong&gt;IL Eimit&lt;/strong&gt;的方式实现对方法调用的拦截，接下来我们就来聊聊大致的实现原理。&lt;/p&gt;

&lt;p&gt;由于Dora.Interception是为.NET Core定制的AOP框架，而依赖注入是.NET Core基本的编程方式，所以Dora.Interception最初就是作为一个依赖注入框架的扩展而涉及的。我们知道.NET Core的依赖注入框架支持三种服务实例提供方式。由于Dora.Interception最终会利用IL Emit的方式动态生成目标实例的类型，所以它只适合&lt;strong&gt;第一种服务注册方式&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果注册的是一个服务类型，最终会选择一个匹配的构造函数来创建服务实例；&lt;/li&gt;
&lt;li&gt;如果注册的是一个服务实例创建工厂，那么目标服务实例就由该工厂来创建；&lt;/li&gt;
&lt;li&gt;如果注册的是一个服务实例，那么它会直接作为目标服务实例。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;.NET Core的依赖注入框架采用ServiceDescriptor对象来描述服务注册。拦截器最终会注册到ImplementationType 属性表示的实现类型上，所以Dora.Interception需要根据该类型生成一个可以被拦截的代理类型。针对ServiceType属性表示的服务类型的不同，我们会采用不同的代码生成方式。&lt;/p&gt;
&lt;h2&gt;针对接口&lt;/h2&gt;
&lt;p&gt;如果注册服务时提供的是一个接口和它的实现类型，我们会按照如下的方式来生成可被拦截的代理类型。假设接口和实现类型分别为IFoobar和Foobar，那么我们会生成一个同样实现IFoobar接口的FoobarProxy类型。FoobarProxy对象是对Foobar对象的封装，对于它实现的方法来说，如果没有拦截器应用到Foobar类型对应的方法上，它只需要调用封装的这个Foobar对象对应的方法就可以了。反之，针对拦截器的调用将会注入到FoobarProxy实现的方法中。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/201910/19327-20191022075706454-842176041.png&quot;&gt;&lt;img width=&quot;439&quot; height=&quot;249&quot; title=&quot;image_thumb2_thumb&quot; alt=&quot;image_thumb2_thumb&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/201910/19327-20191022075706826-1669844902.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;针对类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果注册是提供的服务类型并不是一个接口，而是一个类型，比如服务类型和实现类型都是Foobar，上述的代码生成机制就不适用了。此时我们要求Foobar必须是一个非封闭（Sealed）的类型，而且拦截器只能应用到它的虚方法上。基于这种假设，我们生成的代理类型FoobarProxy实际上市Foobar的子类，如果拦截器应用到Foobar的某个&lt;strong&gt;虚方法&lt;/strong&gt;上，FoobarProxy只需要重写这个方法将应用的拦截器注入到方法调用管道中。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/201910/19327-20191022075707154-449635436.png&quot;&gt;&lt;img width=&quot;413&quot; height=&quot;203&quot; title=&quot;image_thumb5_thumb&quot; alt=&quot;image_thumb5_thumb&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/201910/19327-20191022075707445-1033227898.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;上述针对IL Emit的动态代理类型生成体现在如下这个ICodeGenerator接口上，该接口唯一的方法GenerateInterceptableProxyClass会根据提供的上下文信息生成可被拦截的代理类型。作为代码生成上下文的的CodeGenerationContext对象来说，它除了提供服务注册的类型和实现类型之外，它还提供了IInterceptorRegistry对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; ICodeGenerator
{
    Type GenerateInterceptableProxyClass(CodeGenerationContext  context);
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CodeGenerationContext
{   
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Type InterfaceOrBaseType { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Type TargetType { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IInterceptorRegistry Interceptors { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; CodeGenerationContext(Type baseType, IInterceptorRegistry interceptors );   
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; CodeGenerationContext(Type @interface, Type targetType, IInterceptorRegistry interceptors);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;IInterceptorRegistry接口在Dora.Interception中表示某个类型针对拦截器的注册。它的IsEmpty表示拦截器是否应用到目标类型的任意成员中；IsInterceptable方法帮助我们确定指定的方法是否应用了拦截器；应用到某个方法的所有拦截器可以通过GetInterceptor方法提取出来。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IInterceptorRegistry
{   
    &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; IsEmpty { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    InterceptorDelegate GetInterceptor(MethodInfo methodInfo);
    &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt;&lt;span&gt; IsInterceptable(MethodInfo methodInfo);
    MethodInfo GetTargetMethod(MethodInfo methodInfo);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果我们需要得到针对某个类型的IInterceptorRegistry对象，可以调用IInterceptorResolver接口的如下两个GetInterceptors方法重载。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IInterceptorResolver
{    
    IInterceptorRegistry GetInterceptors(Type initerfaceType, Type targetType);
    IInterceptorRegistry GetInterceptors(Type targetType);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;与代码生成相关的还具有如下这个ICodeGeneratorFactory接口，它是创建ICodeGenerator的工厂。&lt;/p&gt;

&lt;p&gt;由于服务实例最终是通过依赖注入框架提供的，而最终得到怎样的服务实例则由最初的服务注册决定。为了让依赖注入框架能够提供一个可被拦截的代理对象，而不是原始的目标对象，我们必须&lt;strong&gt;改变初始的服务注册&lt;/strong&gt;，为此我们定义了如下这个InterceptableServiceDescriptor。如下面的代码片段所示，InterceptableServiceDescriptor实际是一个基于工厂的ServiceDescriptor，创建代理对象的逻辑体现在GetImplementationFactory方法返回Func&amp;lt;IServiceProvider, &lt;span&gt;object&lt;/span&gt;&amp;gt;对象上。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;sealed&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; InterceptableServiceDescriptor : ServiceDescriptor, IInterceptableServiceDescriptor
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; Type _targetType;
        : &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;(serviceType, GetImplementationFactory(serviceType, implementationType), lifetime)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (serviceType.IsGenericTypeDefinition)
        {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArgumentException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Open generic type (generic type definition) is not support&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, nameof(serviceType));
        }
        _targetType &lt;/span&gt;=&lt;span&gt; implementationType;
    }

    Type IInterceptableServiceDescriptor.TargetType &lt;/span&gt;=&amp;gt;&lt;span&gt; _targetType;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Func&amp;lt;IServiceProvider, &lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt; GetImplementationFactory(Type serviceType, Type implementationType)
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; serviceProvider =&amp;gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; interceptorResolver = serviceProvider.GetRequiredService&amp;lt;IInterceptorResolver&amp;gt;&lt;span&gt;();
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; codeGeneratorFactory = serviceProvider.GetRequiredService&amp;lt;ICodeGeneratorFactory&amp;gt;&lt;span&gt;();
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; factoryCache = serviceProvider.GetRequiredService&amp;lt;IInterceptableProxyFactoryCache&amp;gt;&lt;span&gt;();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (serviceType.IsInterface)
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; interceptors =&lt;span&gt; interceptorResolver.GetInterceptors(serviceType, implementationType);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (interceptors.IsEmpty)
                {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ActivatorUtilities.CreateInstance(serviceProvider, implementationType);
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                {
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; target =&lt;span&gt; ActivatorUtilities.CreateInstance(serviceProvider, implementationType);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; factoryCache.GetInstanceFactory(serviceType, implementationType).Invoke(target);
                }
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; interceptors =&lt;span&gt; interceptorResolver.GetInterceptors(implementationType);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (interceptors.IsEmpty)
                {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ActivatorUtilities.CreateInstance(serviceProvider, implementationType);
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; factoryCache.GetTypeFactory(implementationType).Invoke(serviceProvider);
                }
            }
        };
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们可以利用提供的如下的扩展方法直接创建InterceptableServiceDescriptor 对象作为服务注册。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;68&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AddInterceptionExtensions
{   
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection AddInterceptable(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IServiceCollection services, Type serviceType, Type implementationType, ServiceLifetime lifetime);
   
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection AddTransientInterceptable(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IServiceCollection services, Type serviceType, Type implementationType);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection AddScopedInterceptable(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IServiceCollection services, Type serviceType, Type implementationType);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection AddSingletonInterceptable(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IServiceCollection services, Type serviceType, Type implementationType);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection AddInterceptable&amp;lt;TService, TImplementation&amp;gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IServiceCollection services, ServiceLifetime lifetime);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection AddTransientInterceptable&amp;lt;TService, TImplementation&amp;gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IServiceCollection services);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection AddScopedInterceptable&amp;lt;TService, TImplementation&amp;gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IServiceCollection services);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection AddSingletonInterceptable&amp;lt;TService, TImplementation&amp;gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IServiceCollection services);

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection TryAddInterceptable(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IServiceCollection services, Type serviceType, Type implementationType, ServiceLifetime lifetime);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection TryAddTransientInterceptable(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IServiceCollection services, Type serviceType, Type implementationType);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection TryAddScopedInterceptable(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IServiceCollection services, Type serviceType, Type implementationType);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection TryAddSingletonInterceptable(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IServiceCollection services, Type serviceType, Type implementationType);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection TryAddInterceptable&amp;lt;TService, TImplementation&amp;gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IServiceCollection services, ServiceLifetime lifetime);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection TryAddInterceptable&amp;lt;TService, TImplementation&amp;gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IServiceCollection services);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection TryAddScopedInterceptable&amp;lt;TService, TImplementation&amp;gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IServiceCollection services);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection TryAddSingletonInterceptable&amp;lt;TService, TImplementation&amp;gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IServiceCollection services);

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection TryAddEnumerableInterceptable(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IServiceCollection services, Type serviceType, Type implementationType, ServiceLifetime lifetime);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection TryAddEnumerableInterceptable&amp;lt;TService, TImplementation&amp;gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IServiceCollection services, ServiceLifetime lifetime)
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果我们依然希望采用默认提供的服务注册API，那么我们可以将服务注册的转换实现在利用IServiceCollection集合创建IServiceProvider对象的时候，为此我们定义了如下这个&lt;strong&gt;BuildInterceptableServiceProvider&lt;/strong&gt;扩展方法。顺便说一下，另一个AddInterception扩展方法用来注册Dora.Interception框架自身的一些核心服务。BuildInterceptableServiceProvider方法内部会调用这个方法，如果没有采用这种方式来创建IServiceProvider对象，AddInterception扩展方法必须显式调用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ServiceCollectionExtensions
{   
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceProvider BuildInterceptableServiceProvider(&lt;span&gt;this&lt;/span&gt; IServiceCollection services, Action&amp;lt;InterceptionBuilder&amp;gt; configure = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection AddInterception(&lt;span&gt;this&lt;/span&gt; IServiceCollection services, Action&amp;lt;InterceptionBuilder&amp;gt; configure = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;.NET Core依赖注入框架利用自定义的IServiceProviderFactory&amp;lt;TContainerBuilder&amp;gt;实现与第三方依赖注入框架的整合。如下这个的InterceptableServiceProviderFactory是我们为Dora.Interception定义的实现类型。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;sealed&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; InterceptableServiceProviderFactory : IServiceProviderFactory&amp;lt;IServiceCollection&amp;gt;&lt;span&gt;
{   
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; InterceptableServiceProviderFactory(ServiceProviderOptions options, Action&amp;lt;InterceptionBuilder&amp;gt;&lt;span&gt; configure);   
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IServiceCollection CreateBuilder(IServiceCollection services);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IServiceProvider CreateServiceProvider(IServiceCollection containerBuilder);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为了在服务承载应用（含ASP.NET Core应用）更好地使用Dora.Interception，可以调用我们为IHostBuilder定义的UseInterceptableServiceProvider扩展方法，该方法会帮助我们完成针对InterceptableServiceProviderFactory的注册。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HostBuilderExtensions
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IHostBuilder UseInterceptableServiceProvider(&lt;span&gt;this&lt;/span&gt; IHostBuilder builder,ServiceProviderOptions options = &lt;span&gt;null&lt;/span&gt;,Action&amp;lt;InterceptionBuilder&amp;gt; configure = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们在《&lt;a href=&quot;https://www.cnblogs.com/artech/p/dora-interception-3-01.html&quot;&gt;AOP框架Dora.Interception 3.0 [1]: 编程体验&lt;/a&gt;》提供的演示程序（如下所示）正是调用了这个UseInterceptableServiceProvider方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
    {
        Host.CreateDefaultBuilder()
            &lt;strong&gt;.UseInterceptableServiceProvider(configure: Configure)&lt;/strong&gt;
            .ConfigureWebHostDefaults(buider &lt;/span&gt;=&amp;gt; buider.UseStartup&amp;lt;Startup&amp;gt;&lt;span&gt;())
            .Build()
            .Run();

        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(InterceptionBuilder interceptionBuilder)
        {
            interceptionBuilder.AddPolicy(policyBuilder &lt;/span&gt;=&amp;gt;&lt;span&gt; policyBuilder
                .For&lt;/span&gt;&amp;lt;CacheReturnValueAttribute&amp;gt;(order: &lt;span&gt;1&lt;/span&gt;, cache =&amp;gt;&lt;span&gt; cache
                    .To&lt;/span&gt;&amp;lt;SystemClock&amp;gt;(target =&amp;gt;&lt;span&gt; target
                        .IncludeMethod(clock &lt;/span&gt;=&amp;gt; clock.GetCurrentTime(&lt;span&gt;default&lt;/span&gt;&lt;span&gt;)))));
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/dora-interception-3-01.html&quot;&gt;AOP框架Dora.Interception 3.0 [1]: 编程体验&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/dora-interception-3-2.html&quot;&gt;AOP框架Dora.Interception 3.0 [2]: 实现原理&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/dora-interception-3-03.html&quot;&gt;AOP框架Dora.Interception 3.0 [3]: 拦截器设计&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/dora-interception-3-04.html&quot;&gt;AOP框架Dora.Interception 3.0 [4]: 基于特性的拦截器注册&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/dora-interception-3-05.html&quot;&gt;AOP框架Dora.Interception 3.0 [5]: 基于策略的拦截器注册&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/dora-interception-3-06.html&quot;&gt;AOP框架Dora.Interception 3.0 [6]: 自定义拦截器注册方式&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 21 Oct 2019 23:57:00 +0000</pubDate>
<dc:creator>Artech</dc:creator>
<og:description>和所有的AOP框架一样，我们必须将正常的方法调用进行拦截，才能将应用到当前方法上的所有拦截器纳入当前调用链。Dora.Interception采用IL Eimit的方式实现对方法调用的拦截，接下来我们</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/artech/p/dora-interception-3-2.html</dc:identifier>
</item>
<item>
<title>机器学习回顾篇（7）：决策树算法（ID3、C4.5） - 奥辰</title>
<link>http://www.cnblogs.com/chenhuabin/p/11717580.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenhuabin/p/11717580.html</guid>
<description>&lt;p&gt;ID3算法是经典的决策树构建算法，结构简单清晰、灵活方便，但存在以下不足：&lt;/p&gt;
&lt;p&gt;（1）在选择最优分裂特征属性时，偏好于多取值的特征属性。在选择最优分裂特征属性时，某特征属性的取值越多，分裂后的数据子集就越多，子集中类别相对而言就可能更少，数据“纯度”更高，信息增益更大，所以更有可能被选为当前分裂节点的特征属性。如果还不理解，那么，我们将这种情况极端化，数据集中都有一个ID属性，如果以ID作为分裂特征属性计算信息增益时，每一条数据都是一个分裂，那么多有分裂的分裂后的熵都是0，多以信息增益一定是1，一定会被选为最优分裂特征属性。&lt;/p&gt;
&lt;p&gt;（2）不能处理连续型特征属性。&lt;/p&gt;
&lt;p&gt;（3）没有树剪枝过程，容易发生过拟合现象。&lt;/p&gt;
&lt;p&gt;针对ID3决策树算法的不足，有大能进行优化改进，于是就有了C4.5决策树算法。&lt;/p&gt;
</description>
<pubDate>Mon, 21 Oct 2019 23:36:00 +0000</pubDate>
<dc:creator>奥辰</dc:creator>
<og:description>我们每天都做着各种形形色色的决策——周末怎么嗨、是否买下衣服、出差选哪种交通工具等等，这些决策的过程我们用图形的形式表现出来就是一种类似树形的结构，将这种决策思想应用到机器学习算法领域，那就是我们本文</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chenhuabin/p/11717580.html</dc:identifier>
</item>
<item>
<title>.Net Core3.0使用gRPC - 成天</title>
<link>http://www.cnblogs.com/chengtian/p/11714694.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chengtian/p/11714694.html</guid>
<description>&lt;h2&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/449569/201910/449569-20191021213606768-839197461.png&quot; alt=&quot;&quot;/&gt;&lt;/h2&gt;
&lt;h2&gt;gRPC是什么&lt;/h2&gt;
&lt;p&gt;gRPC是可以在任何环境中运行的现代开源高性能RPC框架。它可以通过可插拔的支持来有效地连接数据中心内和跨数据中心的服务，以实现负载平衡，跟踪，运行状况检查和身份验证。它也适用于分布式计算的最后一英里，以将设备，移动应用程序和浏览器连接到后端服务。&lt;/p&gt;
&lt;h3 data-source-line=&quot;11&quot;&gt;proto文件&lt;/h3&gt;
&lt;p data-source-line=&quot;11&quot;&gt;用于定义gRPC服务和消息的协定；服务端和客户端共享&lt;a href=&quot;https://developers.google.com/protocol-buffers/docs/proto3&quot; target=&quot;_blank&quot;&gt;proto&lt;/a&gt;文件。&lt;/p&gt;
&lt;h2 data-source-line=&quot;11&quot;&gt;使用新模板创建gRPC服务端&lt;/h2&gt;
&lt;p data-source-line=&quot;13&quot;&gt;.NETcore 3.0创建项目提供了一个新的gRPC模板，可以轻松地使用ASP.NET&lt;span class=&quot;Apple-converted-space&quot;&gt; Core构建gRPC服务。我们按照步骤一步一步创建AA.GrpcService 服务，当然你可以使用命令：&lt;/span&gt;dotnet new grpc -o GrpcGreeter&lt;/p&gt;
&lt;p data-source-line=&quot;16&quot;&gt; 选择gRPC服务项目模板&lt;/p&gt;
&lt;p data-source-line=&quot;16&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/449569/201910/449569-20191021165645105-619202282.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p data-source-line=&quot;16&quot;&gt;最终生成的项目&lt;/p&gt;
&lt;p data-source-line=&quot;16&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/449569/201910/449569-20191021165730533-398195649.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4 data-source-line=&quot;16&quot;&gt;greet.proto文件&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
syntax = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;proto3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

option csharp_namespace &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AA.GrpcService&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

package Greet;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; The greeting service definition.&lt;/span&gt;
&lt;span&gt;service Greeter {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Sends a greeting&lt;/span&gt;
&lt;span&gt;  rpc SayHello (HelloRequest) returns (HelloReply);
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; The request message containing the user's name.&lt;/span&gt;
&lt;span&gt;message HelloRequest {
  &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; name = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; The response message containing the greetings.&lt;/span&gt;
&lt;span&gt;message HelloReply {
  &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; message = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;GreeterService.cs&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; GreeterService : Greeter.GreeterBase
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; ILogger&amp;lt;GreeterService&amp;gt;&lt;span&gt; _logger;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; GreeterService(ILogger&amp;lt;GreeterService&amp;gt;&lt;span&gt; logger)
        {
            _logger &lt;/span&gt;=&lt;span&gt; logger;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; Task&amp;lt;HelloReply&amp;gt;&lt;span&gt; SayHello(HelloRequest request, ServerCallContext context)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Task.FromResult(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; HelloReply
            {
                Message &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; request.Name
            });
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Startup.cs&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
        {
            services.AddGrpc();
        }

 &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app, IWebHostEnvironment env)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (env.IsDevelopment())
            {
                app.UseDeveloperExceptionPage();
            }

            app.UseRouting();

            app.UseEndpoints(endpoints &lt;/span&gt;=&amp;gt;&lt;span&gt;
            {
                endpoints.MapGrpcService&lt;/span&gt;&amp;lt;GreeterService&amp;gt;&lt;span&gt;();

                endpoints.MapGet(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;async&lt;/span&gt; context =&amp;gt;&lt;span&gt;
                {
                    &lt;/span&gt;&lt;span&gt;await&lt;/span&gt; context.Response.WriteAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Communication with gRPC endpoints must be made through a gRPC client. To learn how to create a client, visit: https://go.microsoft.com/fwlink/?linkid=2086909&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                });
            });
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;创建完成之后，自动包含了包的引用、proto文件的创建、services服务的生成，模板项目在后台执行一些操作如&lt;/p&gt;
&lt;ul data-source-line=&quot;17&quot;&gt;&lt;li&gt;创建一个包含所有gRPC依赖项的ASP.NET&lt;span class=&quot;Apple-converted-space&quot;&gt; Core项目。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;创建一个名为的gRPC服务定义文件greet.proto。&lt;/li&gt;
&lt;li&gt;根据服务定义文件自动生成所有gRPC存根。&lt;/li&gt;
&lt;li&gt;GreeterService.cs根据自动生成的gRPC存根创建gRPC服务。&lt;/li&gt;
&lt;li&gt;在Startup.cs中配置gRPC管道映射到GreeterService.cs&lt;/li&gt;
&lt;/ul&gt;&lt;h4 data-source-line=&quot;23&quot;&gt;运行服务&lt;/h4&gt;
&lt;p data-source-line=&quot;23&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/449569/201910/449569-20191021165942965-373104727.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 data-source-line=&quot;26&quot;&gt;创建gRPC客户端&lt;/h2&gt;
&lt;h4 data-source-line=&quot;28&quot;&gt;下面，我们创建一个控制台应用程序作为客户端调用gRPC服务；&lt;/h4&gt;
&lt;p data-source-line=&quot;28&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/449569/201910/449569-20191021170247766-1397436254.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;引用gRPC服务，步骤：右键项目添加=》服务引用弹出以下页面；&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/449569/201910/449569-20191021170356909-1346657498.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4 data-source-line=&quot;34&quot;&gt;点击确定&lt;/h4&gt;
&lt;p data-source-line=&quot;34&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/449569/201910/449569-20191021170716084-983097537.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p data-source-line=&quot;34&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/449569/201910/449569-20191021170735913-350545172.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4 data-source-line=&quot;34&quot;&gt;我们看项目结构，他们会自动帮我们处理一下操作：&lt;/h4&gt;
&lt;ul data-source-line=&quot;35&quot;&gt;&lt;li&gt;添加引用包：&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt; package Grpc.Net.ClientFactory&lt;/li&gt;
&lt;li&gt; package Google.Protobuf&lt;/li&gt;
&lt;li&gt; package Grpc.Tools&lt;/li&gt;
&lt;/ol&gt;&lt;ul data-source-line=&quot;35&quot;&gt;&lt;li&gt;Protos 文件（包含greet.proto）自动从AA.GrpcService项目拷贝&lt;/li&gt;
&lt;li&gt;自动添加节点&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
  &amp;lt;ItemGroup&amp;gt;
    &amp;lt;Protobuf Include=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;..\AA.GrpcService\Protos\greet.proto&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; GrpcServices=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Client&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
      &amp;lt;Link&amp;gt;Protos\greet.proto&amp;lt;/Link&amp;gt;
    &amp;lt;/Protobuf&amp;gt;
  &amp;lt;/ItemGroup&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后，添加以下代码进行gRPC请求；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; channel = GrpcChannel.ForAddress(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://localhost:5005&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; client = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Greeter.GreeterClient(channel);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; response = &lt;span&gt;await&lt;/span&gt; client.SayHelloAsync(&lt;span&gt;new&lt;/span&gt; HelloRequest { Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gRPC&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; });
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Greeting:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; response.Message);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Press a key to exit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.ReadKey();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/449569/201910/449569-20191021171106341-1510930233.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p data-source-line=&quot;53&quot;&gt;小结： .NETcore 3.0 使得使用gRPC是非常方便集成到项目中，希望这篇文章使你可以了解.NETcore与gRPC结合使用。那gRPC适用于以下场景&lt;/p&gt;
&lt;ul data-source-line=&quot;54&quot; readability=&quot;3&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;微服务– gRPC专为低延迟和高吞吐量通信而设计。 gRPC对于效率至关重要的轻量级微服务非常有用。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;点对点实时通信– gRPC对双向流具有出色的支持。 gRPC服务可以实时推送消息而无需轮询。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;多种语言环境– gRPC工具支持所有流行的开发语言，因此gRPC是多语言环境的理想选择。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;网络受限的环境– gRPC消息使用轻量级消息格式Protobuf进行了序列化。 gRPC消息始终小于等效的JSON消息。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p data-source-line=&quot;65&quot;&gt;参考：&lt;/p&gt;
</description>
<pubDate>Mon, 21 Oct 2019 23:30:00 +0000</pubDate>
<dc:creator>成天</dc:creator>
<og:description>gRPC是什么 gRPC是可以在任何环境中运行的现代开源高性能RPC框架。它可以通过可插拔的支持来有效地连接数据中心内和跨数据中心的服务，以实现负载平衡，跟踪，运行状况检查和身份验证。它也适用于分布式</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chengtian/p/11714694.html</dc:identifier>
</item>
<item>
<title>Flask源码分析一：服务启动 - Yabea</title>
<link>http://www.cnblogs.com/ybjourney/p/11717347.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ybjourney/p/11717347.html</guid>
<description>&lt;p&gt;Flask是目前为止我最喜欢的一个Python Web框架了，为了更好的掌握其内部实现机制，这两天准备学习下Flask的源码，将由浅入深跟大家分享下，其中Flask版本为1.1.1。&lt;/p&gt;
&lt;p&gt;Flask系列文章：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/ybjourney/p/10125532.html&quot;&gt;Flask开发初探&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本文将结合源码跟踪看下Flask是如何启动并运行一个服务的。&lt;/p&gt;
&lt;p&gt;首先，继续贴上最简单的应用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from flask import Flask
app = Flask(__name__)

@app.route('/')
def hello_world():
    return 'Hello Flask!'

if __name__ == '__main__':
    app.run()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们看到，这段代码先初始化了Flask类并被app所指向，然后执行run()来启动程序的。&lt;/p&gt;
&lt;p&gt;查看run方法：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def run(self, host=None, port=None, debug=None, load_dotenv=True, **options):
        if os.environ.get(&quot;FLASK_RUN_FROM_CLI&quot;) == &quot;true&quot;:
            from .debughelpers import explain_ignored_app_run

            explain_ignored_app_run()
            return

        if get_load_dotenv(load_dotenv):
            cli.load_dotenv()

            # if set, let env vars override previous values
            if &quot;FLASK_ENV&quot; in os.environ:
                self.env = get_env()
                self.debug = get_debug_flag()
            elif &quot;FLASK_DEBUG&quot; in os.environ:
                self.debug = get_debug_flag()

        # debug passed to method overrides all other sources
        if debug is not None:
            self.debug = bool(debug)

        _host = &quot;127.0.0.1&quot;
        _port = 5000
        server_name = self.config.get(&quot;SERVER_NAME&quot;)
        sn_host, sn_port = None, None

        if server_name:
            sn_host, _, sn_port = server_name.partition(&quot;:&quot;)

        host = host or sn_host or _host
        # pick the first value that's not None (0 is allowed)
        port = int(next((p for p in (port, sn_port) if p is not None), _port))

        options.setdefault(&quot;use_reloader&quot;, self.debug)
        options.setdefault(&quot;use_debugger&quot;, self.debug)
        options.setdefault(&quot;threaded&quot;, True)

        cli.show_server_banner(self.env, self.debug, self.name, False)

        from werkzeug.serving import run_simple

        try:
            run_simple(host, port, self, **options)
        finally:
            # reset the first request information if the development server
            # reset normally.  This makes it possible to restart the server
            # without reloader and that stuff from an interactive shell.
            self._got_first_request = False&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先入参：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;host&lt;/td&gt;
&lt;td&gt;服务器地址，不设置的话默认为127.0.0.1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;port&lt;/td&gt;
&lt;td&gt;端口，不设置的话默认为5000&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;debug&lt;/td&gt;
&lt;td&gt;是否为调试模式， 默认为否&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;load_dotenv&lt;/td&gt;
&lt;td&gt;设置环境变量&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;options&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;该方法的处理流程是：对入参进行配置处理之后，执行werkzeug的run_simple()方法，&lt;/p&gt;
&lt;p&gt;run_simple将启动一个WSGI服务。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;关于WSGI协议：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;它是关于HTTP服务器和Web应用的桥梁，定义了标准接口以提升Web应用之间的可移植性，是一套接口交互规范。&lt;/li&gt;
&lt;li&gt;它的功能是监听指定端口服务，将来自HTTP服务器的请求解析为WSGI格式，调用Flask app处理请求。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;run_simple中的inner方法是核心，inner调用make_server().serve_forever()启动服务。关于make_server:&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def make_server(host=None, port=None, app=None, threaded=False, processes=1,
                request_handler=None, passthrough_errors=False,
                ssl_context=None, fd=None):
    if threaded and processes &amp;gt; 1:
        raise ValueError(&quot;cannot have a multithreaded and &quot;
                         &quot;multi process server.&quot;)
    elif threaded:
        return ThreadedWSGIServer(host, port, app, request_handler,
                                  passthrough_errors, ssl_context, fd=fd)
    elif processes &amp;gt; 1:
        return ForkingWSGIServer(host, port, app, processes, request_handler,
                                 passthrough_errors, ssl_context, fd=fd)
    else:
        return BaseWSGIServer(host, port, app, request_handler,
                              passthrough_errors, ssl_context, fd=fd)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;make_server会根据线程或者进程数返回相应的WSGI服务器，默认情况下返回BaseWSGIServer，ThreadedWSGIServer和ForkingWSGIServer均集成了BaserWSGIServer，接下来我们看下serve_forever()方法：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def serve_forever(self):
    self.shutdown_signal = False
    try:
        HTTPServer.serve_forever(self)
    except KeyboardInterrupt:
        pass
    finally:
        self.server_close()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终调用了Python标准类库接口HTTPServer的serve_forever()方法，而HTTPServer又是socketserver.TCPServer的子类，通过server_bind来监听服务：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class HTTPServer(socketserver.TCPServer):

    allow_reuse_address = 1    # Seems to make sense in testing environment

    def server_bind(self):
        &quot;&quot;&quot;Override server_bind to store the server name.&quot;&quot;&quot;
        socketserver.TCPServer.server_bind(self)
        host, port = self.server_address[:2]
        self.server_name = socket.getfqdn(host)
        self.server_port = port&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上，就是Flask服务启动的流程。&lt;/p&gt;
</description>
<pubDate>Mon, 21 Oct 2019 16:15:00 +0000</pubDate>
<dc:creator>Yabea</dc:creator>
<og:description>本文分析Flask源码，了解服务的启动流程。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ybjourney/p/11717347.html</dc:identifier>
</item>
<item>
<title>.NET Core使用App.Metrics监控消息队列(一)：初探 - 名字都被注册了</title>
<link>http://www.cnblogs.com/weiBlog/p/11717324.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/weiBlog/p/11717324.html</guid>
<description>&lt;p&gt;一、简介&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;App Metrics是一个开放源代码和跨平台的.NET库，用于记录应用程序中的指标。&lt;/span&gt;&lt;span&gt;App Metrics可以在.NET Core或也支持.NET 4.5.2的完整.NET框架上运行。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;App Metrics通过在内存中进行采样和聚合，并提供可扩展性点以指定间隔将指标刷新到存储库中，从而抽象化了Metrics的基础存储库，例如InfluxDB，Prometheus，Graphite，Elasticsearch等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;App Metrics提供了各种度量标准类型来度量事物，例如请求率，计算一段时间内的用户登录数，度量执行数据库查询所花费的时间，度量可用内存的数量等等。&lt;/span&gt;&lt;span&gt;支持的指标类型包括Apdex，仪表，计数器，仪表，直方图和计时器。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;App Metrics还提供了运行状况检查系统，使您可以通过用户定义的检查来监视应用程序的运行状况。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用App Metrics，可以：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;捕获任何类型的.NET应用程序中的应用程序指标，例如Windows Service，MVC Site，Web API等&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;自动测量MVC或Web API项目中每个端点的性能和错误&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;使用OAuth2保护API时，自动衡量每个客户端的请求率和错误率&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;选择保存捕获的指标的位置以及希望用来可视化这些指标的仪表板&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;通过特定于TSDB的报告扩展支持基于推和拉的指标收集，并通过HTTP以要求的格式公开指标&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;支持以所需格式将指标推送到自定义HTTP端点&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;支持以所需格式将指标写入文件以供指标代理收集、&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;更多使用方式直接访问官网：&lt;a href=&quot;https://www.app-metrics.io/&quot;&gt;https://www.app-metrics.io/&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;二、实际业务场景&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上面介绍了App.Metrics以及它支持的场景，但是读完你一定会觉得很抽象，没错我也一样。如果不是带着实际的业务场景去看这些东西，其实还是有点云里雾里的。&lt;/span&gt;在实际的业务中我们通常会把它用于两个方面，一方面是包括CPU、内存在内的对系统级别的整体监控，园子里有很多文章都做了demo供大家参考，大家可以搜一下。另外一方面是通过埋点的方式统计相关数据，后端通常使用InfluxDB作为数据库，并使用Grafana或者Prometheus来对数据进行展示。&lt;/p&gt;
&lt;p&gt;本篇将介绍的使用方式是第二钟，通过埋点的方式来对消息队列进行统计，统计的数据包括 队列数量、每个队列当前消息数量（已消费、未消费），以及消息的生成和发布速率。&lt;/p&gt;
&lt;p&gt;最后的样子大体就是下面这个样子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1036828/201910/1036828-20191021224955411-1912344664.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;一、InfluxDB 简介&quot;&gt;三、InfluxDB &lt;/h2&gt;
&lt;p&gt;在使用App.Metrics之前，我们需要先准备好数据库，也就是InfluxDB，首先快速了解一下InfluxDB是什么：&lt;/p&gt;
&lt;p&gt;InfluxDB 是用Go语言编写的一个开源分布式时序、事件和指标数据库，无需外部依赖。&lt;/p&gt;
&lt;p&gt;类似的数据库有Elasticsearch、Graphite等。&lt;/p&gt;
&lt;h3 id=&quot;其主要特色功能&quot;&gt;其主要特色功能&lt;/h3&gt;
&lt;p&gt;1）基于时间序列，支持与时间有关的相关函数（如最大，最小，求和等）&lt;/p&gt;
&lt;p&gt;2）可度量性：你可以实时对大量数据进行计算&lt;/p&gt;
&lt;p&gt;3）基于事件：它支持任意的事件数据&lt;/p&gt;
&lt;h3 id=&quot;InfluxDB的主要特点&quot;&gt;InfluxDB的主要特点&lt;/h3&gt;
&lt;p&gt;1）无结构（无模式）：可以是任意数量的列&lt;/p&gt;
&lt;p&gt;2）可拓展的&lt;/p&gt;
&lt;p&gt;3）支持min, max, sum, count, mean, median 等一系列函数，方便统计&lt;/p&gt;
&lt;p&gt;4）原生的HTTP支持，内置HTTP API&lt;/p&gt;
&lt;p&gt;5）强大的类SQL语法&lt;/p&gt;
&lt;p&gt;6）自带管理界面，方便使用&lt;/p&gt;

&lt;p&gt;Influx包含以下属性：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;database&lt;/strong&gt;: 数据库名，在 InfluxDB 中可以创建多个数据库，不同数据库中的数据文件是隔离存放的，存放在磁盘上的不同目录。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;retention policy&lt;/strong&gt;: 存储策略，用于设置数据保留的时间，每个数据库刚开始会自动创建一个默认的存储策略 autogen，数据保留时间为永久，之后用户可以自己设置，例如保留最近2小时的数据。插入和查询数据时如果不指定存储策略，则使用默认存储策略，且默认存储策略可以修改。InfluxDB 会定期清除过期的数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;measurement&lt;/strong&gt;: 测量指标名，例如 cpu_usage 表示 cpu 的使用率。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;tag sets&lt;/strong&gt;: tags 在 InfluxDB 中会按照字典序排序，不管是 tagk 还是 tagv，只要不一致就分别属于两个 key，例如 &lt;code&gt;host=server01,region=us-west&lt;/code&gt; 和 &lt;code&gt;host=server02,region=us-west&lt;/code&gt; 就是两个不同的 tag set。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;field name&lt;/strong&gt;: 例如上面数据中的 &lt;code&gt;value&lt;/code&gt; 就是 fieldName，InfluxDB 中支持一条数据中插入多个 fieldName，这其实是一个语法上的优化，在实际的底层存储中，是当作多条数据来存储。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;timestamp&lt;/strong&gt;: 每一条数据都需要指定一个时间戳，在 TSM 存储引擎中会特殊对待，以为了优化后续的查询操作。&lt;/p&gt;
&lt;p&gt;2）Point&lt;/p&gt;
&lt;p&gt;InfluxDB 中单条插入语句的数据结构，series + timestamp 可以用于区别一个 point，也就是说一个 point 可以有多个 field name 和 field value。&lt;/p&gt;
&lt;p&gt;3）Series&lt;/p&gt;
&lt;p&gt;series 相当于是 InfluxDB 中一些数据的集合，在同一个 database 中，retention policy、measurement、tag sets 完全相同的数据同属于一个 series，同一个 series 的数据在物理上会按照时间顺序排列存储在一起。&lt;/p&gt;
&lt;p&gt;series 的 key 为 measurement + 所有 tags 的序列化字符串，这个 key 在之后会经常用到。&lt;/p&gt;

&lt;h2 id=&quot;一、InfluxDB 简介&quot;&gt;四、搭建InfuxDB+Grafana &lt;/h2&gt;
&lt;p&gt;OK，这篇是一个DEMO演示篇，所以我们使用Dokcer快速的创建InfluxDB和Grafana:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
docker run -d -p 8083:8083 -p 8086:8086 --expose 8090 --expose 8099 tutum/influxdb
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
docker run -d --name=grafana -p &lt;span&gt;3000&lt;/span&gt;:&lt;span&gt;3000&lt;/span&gt; grafana/grafana
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;运行成功之后我们分别可以访问8083端口的InfluxDB和3000端口的Grafana：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1036828/201910/1036828-20191021233356889-8040769.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1036828/201910/1036828-20191021233414449-1730590169.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;我们首先给InfluxDB添加一个用户：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1036828/201910/1036828-20191021233500355-324615060.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 添加完成后配置一下Grafana：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1036828/201910/1036828-20191021233743001-1161329967.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;h2 id=&quot;一、InfluxDB 简介&quot;&gt;四、.NET CORE使用App.Metrics&lt;/h2&gt;
&lt;p&gt;这里我们使用.net core控制台项目来演示（API项目例子已经有很多了，但是控制台项目没看到），新建一个控制台项目 AppMetricsPractice：&lt;/p&gt;
&lt;p&gt;通过NuGet引用App.Metrics和App.Metrics.Reporting.InfluxDB&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1036828/201910/1036828-20191021234222411-1223955589.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1036828/201910/1036828-20191021234246961-1156111803.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 然后我们就可以愉快的使用了，简单使用可以如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; metrics = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MetricsBuilder().Report
                .ToInfluxDb(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://47.99.92.76:8086&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;metricsdatabase&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                .Build();


            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; counter = &lt;span&gt;new&lt;/span&gt; CounterOptions { Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;my_counter&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, MeasurementUnit =&lt;span&gt; Unit.Calls };
            metrics.Measure.Counter.Increment(counter,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MqQueueNmae&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; task = Task.Run(&lt;span&gt;async&lt;/span&gt; () =&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; Task.WhenAll(metrics.ReportRunner.RunAllAsync());
            });

            task.Wait();


            Console.Read();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用方式在官网有简介，这里介绍一下，ToInfluxDb（influxDB url,InfluxDB databaseName）,这里是InfluxDB的地址和数据库名称，如果没有改数据库，会自动创建。&lt;/p&gt;
&lt;p&gt;以上写法是简写，当然我们可以详细的控制InfluxDB的属性，通过以下写法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;var&lt;/span&gt; metrics = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MetricsBuilder()
                .Report.ToInfluxDb(
                    options &lt;/span&gt;=&amp;gt;&lt;span&gt;
                    {
                        options.InfluxDb.BaseUri &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Uri(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://47.99.92.76:8086&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                        options.InfluxDb.Database &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;metricsdatabase&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                        options.InfluxDb.Consistenency &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;consistency&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                        options.InfluxDb.UserName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;admin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                        options.InfluxDb.Password &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;password&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                        options.InfluxDb.RetentionPolicy &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;rp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                        options.InfluxDb.CreateDataBaseIfNotExists &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                        options.HttpPolicy.BackoffPeriod &lt;/span&gt;= TimeSpan.FromSeconds(&lt;span&gt;30&lt;/span&gt;&lt;span&gt;);
                        options.HttpPolicy.FailuresBeforeBackoff &lt;/span&gt;= &lt;span&gt;5&lt;/span&gt;&lt;span&gt;;
                        options.HttpPolicy.Timeout &lt;/span&gt;= TimeSpan.FromSeconds(&lt;span&gt;10&lt;/span&gt;&lt;span&gt;);
                        options.MetricsOutputFormatter &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MetricsInfluxDbLineProtocolOutputFormatter();
                        options.Filter &lt;/span&gt;=&lt;span&gt; filter;
                        options.FlushInterval &lt;/span&gt;= TimeSpan.FromSeconds(&lt;span&gt;20&lt;/span&gt;&lt;span&gt;);
                    })
                .Build();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;span&gt;Option&lt;/span&gt;&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;&lt;span&gt;Description&lt;/span&gt;&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;15&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;MetricsOutputFormatter&lt;/span&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;span&gt;向InfluxDB报告指标时使用的格式化程序。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;Filter&lt;/span&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;span&gt;该过滤器仅用于为此报告者过滤指标。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;FlushInterval&lt;/span&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;span&gt;向InfluxDB报告指标之间的延迟。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;InfluxDb.Database&lt;/span&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;span&gt;报告指标的InfluxDB数据库。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;InfluxDb.BaseUri&lt;/span&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;span&gt;InfluxDB服务器的URI。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;InfluxDb.UserName&lt;/span&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;span&gt;使用基本身份验证与InfluxDB进行身份验证时的用户名。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;InfluxDb.Password&lt;/span&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;span&gt;使用基本身份验证与InfluxDB进行身份验证时使用的密码。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;InfluxDb.Consistenency&lt;/span&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;span&gt;要使用的InfluxDB数据库一致性级别。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;InfluxDb.RetentionPolicy&lt;/span&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;span&gt;InfluxDB数据库保留策略以向其写入指标。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;span&gt;InfluxDb.CreateDataBaseIfNotExists&lt;/span&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;span&gt;如果指定的influxdb数据库不存在，将尝试创建该数据库。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;HttpPolicy.BackoffPeriod&lt;/span&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;span&gt;&lt;code&gt;TimeSpan&lt;/code&gt;当指标无法向指标入口端点报告时，从后退。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;span&gt;HttpPolicy.FailuresBeforeBackoff&lt;/span&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;span&gt;指标未能向指标入口端点报告时，在回退之前的失败次数。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;HttpPolicy.Timeout&lt;/span&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;span&gt;尝试向度量标准入口端点报告度量标准时的HTTP超时持续时间。&lt;br/&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;然后我们要存储一个Counter类型的数据，App.Metrics里有主要有6种数据类型：Counter、Gauge、Histograms 、Meter 、Timer 、Apdex。我们本篇主要使用Counter和Gauge这两种数据类型，&lt;/p&gt;
&lt;p&gt;CounterOptions种的Name是数据表名，MeasurementUnit是测量的内容的描述。&lt;/p&gt;
&lt;p&gt;metrics.Measure.Counter.Increment(counter,&quot;MqQueueNmae&quot;);  会往把“my_counter”表里的value + 1，实际就是对value加加减减，大致如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1036828/201910/1036828-20191021235755674-2096606941.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 同时还会创建一张名为my_counter__items的表，同时为一个字段为“MqQueueNmae”的value+1，如下：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1036828/201910/1036828-20191022000001931-1304199086.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;多了几个字段，通过这个我们可以用来对不同的消息度列Queue进行统计，而第一张表则当做一张当前消费消息的统计表。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;            var&lt;/span&gt; task = Task.Run(&lt;span&gt;async&lt;/span&gt; () =&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; Task.WhenAll(metrics.ReportRunner.RunAllAsync());
            });

            task.Wait();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这句代码是指将当前的统计数据报告到InfluDB，这段代码一定要在最后，它会将数据发送到所有已注册的存储端，比如你同时注册了InfluxDB和Prometheus，那么数据会同时发送到这两个存储端。&lt;/p&gt;
&lt;p&gt;执行完成后创建的两张表如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1036828/201910/1036828-20191022000354471-1873621195.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;然后我们就可以去Granfan里自定义统计图了，比较简单，大家可以自己研究一下，大致如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1036828/201910/1036828-20191022000728612-168075017.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;下一篇将会把这一套集成到实际项目中，用来监控消息队列系统，这一篇只是了解，等我明天写可以直接用于生产的！&lt;/p&gt;
</description>
<pubDate>Mon, 21 Oct 2019 16:10:00 +0000</pubDate>
<dc:creator>名字都被注册了</dc:creator>
<og:description>一、简介 App Metrics是一个开放源代码和跨平台的.NET库，用于记录应用程序中的指标。App Metrics可以在.NET Core或也支持.NET 4.5.2的完整.NET框架上运行。 A</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/weiBlog/p/11717324.html</dc:identifier>
</item>
<item>
<title>Windows系统调用中的系统服务表描述符 - OneTrainee</title>
<link>http://www.cnblogs.com/onetrainee/p/11717309.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/onetrainee/p/11717309.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt; &lt;span&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/onetrainee/p/11675224.html&quot; target=&quot;_blank&quot;&gt;Windows内核分析索引目录&lt;/a&gt;：https://www.cnblogs.com/onetrainee/p/11675224.html&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Windows系统调用中的系统服务表描述符&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　在前面，我们将解过 系统服务表。可是，我们有个疑问，系统服务表存储在哪里呢？&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　答案就是：系统服务表 存储在 系统服务描述符表中。(其又称为 SSDT Service Descriptor Table)&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1827556/201910/1827556-20191021202101383-398040416.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt; 一、使用PELord函数从ntoskrnl.exe文件中查看SSDT导出函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　如图，可以看出KeServiceDescriptorTable导出函数。&lt;/p&gt;
&lt;p&gt;　　通过该函数可以查找SSDT表的位置。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1827556/201910/1827556-20191021202646309-583916324.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二、通过Windbg来内存中查看SSDT表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　使用Windbg，可以使用 kd&amp;gt; dd nt!KeServiceDescriptorTable 指令来查看SSDT表。&lt;/p&gt;
&lt;p&gt;　　但该指令存在缺点，可以看到第二张表为0，说明如果使用KeServiceDescriptorTable这个公开的导出函数，我们无法看到win32k.sys这张表结构&lt;/p&gt;
&lt;p&gt;　　kd&amp;gt; dd nt!KeServiceDescriptorTable&lt;br/&gt;　　　　83f759c0  83e89d9c 00000000 00000191 83e8a3e4&lt;br/&gt;　　　　83f759d0  00000000 00000000 00000000 00000000&lt;br/&gt;　　　　83f759e0  83ee86af 00000000 0327aa43 000000bb&lt;br/&gt;　　　　83f759f0  00000011 00000100 5385d2ba d717548f&lt;/p&gt;
&lt;p&gt;　　为了解决上面这个问题，我们只能使用另外一个指令，该指令对应的是一个未公开导出的函数。&lt;/p&gt;
&lt;p&gt;　　如下，可以看到其第二行，win32k.sys系统服务表已经可见。&lt;/p&gt;
&lt;p&gt;　　kd&amp;gt; dd KeServiceDescriptorTableShadow&lt;br/&gt;　　　　83f75a00  83e89d9c 00000000 00000191 83e8a3e4&lt;br/&gt;　　　　83f75a10  83b66000 00000000 00000339 83b6702c&lt;br/&gt;　　　　83f75a20  00000000 00000000 83f75a24 00000340&lt;br/&gt;　　　　83f75a30  00000340 855e8440 00000007 00000000&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三、验证ReadMemory真正的内核实现部分&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　我们在这篇《&lt;a href=&quot;https://www.cnblogs.com/onetrainee/p/11704626.html&quot; target=&quot;_blank&quot;&gt;Windows系统调用中API的三环部分(依据分析重写ReadProcessMemory函数)&lt;/a&gt;》中曾提到过直接使用快速调用来摒弃R3层层封装的API，其中给eax一个函数号，现在我们来实战刨析一下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
mov eax, &lt;span&gt;0x115&lt;/span&gt;&lt;span&gt;
mov edx, &lt;/span&gt;&lt;span&gt;0X7FFE0300&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　如下，系统描述符的数据结构，其依次分别为&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1827556/201910/1827556-20191021203658087-61804745.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　其依次分别为 ServiceTable 83e89d9c,Count 00000000,ServiceLimit  00000191,ServiceTable 83e8a3e4　&lt;/p&gt;
&lt;p&gt;　　使用Windbg来查看其115h序号的函数地址 115h*4 + 83e89d9c (ServiceTable)&lt;/p&gt;
&lt;p&gt;　　得到函数地址为 8406c82c&lt;/p&gt;
&lt;p&gt;　　kd&amp;gt; dd 115h*4 + 83e89d9c&lt;br/&gt;　　　　83e8a1f0  &lt;strong&gt;8406c82c&lt;/strong&gt; 840feb46 83fb488c 83fb6128　&lt;/p&gt;
&lt;p&gt;　　再对此进行反汇编可得&lt;/p&gt;
&lt;p&gt;　　kd &amp;gt; u 8406c82c　　　&lt;br/&gt;                &lt;strong&gt;nt!NtReadVirtualMemory:&lt;/strong&gt;&lt;br/&gt;                8406c82c 6a18            push    18h&lt;br/&gt;                8406c82e 68282ae683      push    offset nt!? ? ::FNODOBFM::`string'+0x3ea8 (83e62a28)&lt;br/&gt;                8406c833 e870e3e1ff      call    nt!_SEH_prolog4(83e8aba8)&lt;br/&gt;                8406c838 648b3d24010000  mov     edi, dword ptr fs : [124h]&lt;br/&gt;                8406c83f 8a873a010000    mov     al, byte ptr[edi + 13Ah]&lt;br/&gt;                8406c845 8845e4          mov     byte ptr[ebp - 1Ch], al&lt;br/&gt;                8406c848 8b7514          mov     esi, dword ptr[ebp + 14h]&lt;br/&gt;                8406c84b 84c0            test    al, al&lt;/p&gt;
&lt;p&gt;　　之后，我们查看该&lt;strong&gt;nt!NtReadVirtualMemory&lt;/strong&gt;函数的参数个数&lt;/p&gt;
&lt;p&gt;　　kd &amp;gt; db 83e8a3e4 + 115&lt;br/&gt;                83e8a4f9  &lt;strong&gt;14&lt;/strong&gt; 08 04 04 14 04 10 08 - 0c 04 14 18 08 08 08 0c&lt;br/&gt;                83e8a509  0c 08 10 14 08 08 0c 08 - 0c 0c 04 08 08 08 08 08  &lt;br/&gt;                83e8a519  08 0c 0c 24 00 08 08 08 - 0c 04 08 04 08 10 08 04　　&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;四、通过修改SSDT表增添系统服务函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　我们在 &lt;a href=&quot;https://www.cnblogs.com/onetrainee/p/11704626.html&quot; target=&quot;_blank&quot;&gt;Windows系统调用中API的三环部分(依据分析重写ReadProcessMemory函数)&lt;/a&gt; 调用的是 115h 号函数。&lt;/p&gt;
&lt;p&gt;　　现在，我们将该函数地址放到 191 号函数处(之前一共有191个函数，占据0-190位)。&lt;/p&gt;
&lt;p&gt;　　修改思路：&lt;/p&gt;
&lt;p&gt;　　1）将 &lt;strong&gt;nt!NtReadVirtualMemory&lt;/strong&gt; 函数地址 8406c82c 放到 191号处(83e89d9 + 191h*4)&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;kd&amp;gt; ed 83e89d9 + 191h*4　8406c82c　&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　2)  增大 服务表最大个数。 (因为我们上一节分析其反汇编代码的时候，发现其会进行最大个数的判断)&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;kd&amp;gt; ed 83f75a00+8 192&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　3)  修改参数个数表中对应的191号参数个数。（我们之前查阅过其为 14,以字节为单位)&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;kd&amp;gt; eb 83e8a3e4+191 14&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;4)  之后，我们运行下列代码。其与《&lt;a href=&quot;https://www.cnblogs.com/onetrainee/p/11704626.html&quot; target=&quot;_blank&quot;&gt;Windows系统调用中API的三环部分(依据分析重写ReadProcessMemory函数)&lt;/a&gt;》唯一的不同调用函数号为192，最终效果完全一样。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pch.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; #include &amp;lt;iostream&amp;gt;
&lt;span&gt; 3&lt;/span&gt; #include &amp;lt;algorithm&amp;gt;
&lt;span&gt; 4&lt;/span&gt; #include &amp;lt;Windows.h&amp;gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;  ReadMemory(HANDLE hProcess, PVOID pAddr, PVOID pBuffer, DWORD dwSize, DWORD  *&lt;span&gt;dwSizeRet)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    _asm
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         lea     eax, [ebp + &lt;span&gt;0x14&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        push    eax
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         push[ebp + &lt;span&gt;0x14&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         push[ebp + &lt;span&gt;0x10&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         push[ebp + &lt;span&gt;0xc&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         push[ebp + &lt;span&gt;8&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         sub esp, &lt;span&gt;4&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         mov eax, &lt;span&gt;0x192  // 注意：修改的是这里&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;         mov edx, &lt;span&gt;0X7FFE0300&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;sysenter不能直接调用，我间接call的&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        CALL DWORD PTR[EDX]
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         add esp, &lt;span&gt;24&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     HANDLE hProcess = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; t = &lt;span&gt;123&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    DWORD pBuffer;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;hProcess = OpenProcess(PROCESS_ALL_ACCESS, 0,a);&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;     ReadMemory((HANDLE)-&lt;span&gt;1&lt;/span&gt;, (PVOID)&amp;amp;t, &amp;amp;pBuffer, &lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;), &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%X\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, pBuffer);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     ReadProcessMemory((HANDLE)-&lt;span&gt;1&lt;/span&gt;, &amp;amp;t, &amp;amp;pBuffer, &lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;), &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%X\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, pBuffer);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt; &lt;span&gt;    getchar();
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;




</description>
<pubDate>Mon, 21 Oct 2019 16:05:00 +0000</pubDate>
<dc:creator>OneTrainee</dc:creator>
<og:description>Windows内核分析索引目录：https://www.cnblogs.com/onetrainee/p/11675224.html Windows系统调用中的系统服务表描述符 在前面，我们将解过 系</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/onetrainee/p/11717309.html</dc:identifier>
</item>
<item>
<title>从零开始实现ASP.NET Core MVC的插件式开发(六) - 如何加载插件引用 - LamondLu</title>
<link>http://www.cnblogs.com/lwqlun/p/11717254.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lwqlun/p/11717254.html</guid>
<description>&lt;blockquote readability=&quot;4.2743362831858&quot;&gt;
&lt;p&gt;标题：从零开始实现ASP.NET Core MVC的插件式开发(六) - 如何加载插件引用。&lt;br/&gt;作者：Lamond Lu&lt;br/&gt;地址：&lt;a href=&quot;https://www.cnblogs.com/lwqlun/p/11717254.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/lwqlun/p/11717254.html&lt;/a&gt;&lt;br/&gt;源代码：&lt;a href=&quot;https://github.com/lamondlu/DynamicPlugins&quot; class=&quot;uri&quot;&gt;https://github.com/lamondlu/DynamicPlugins&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201910/65831-20191021235506621-170598947.jpg&quot;/&gt;&lt;/p&gt;


&lt;p&gt;在前一篇中，我给大家演示了如何使用.NET Core 3.0中新引入的&lt;code&gt;AssemblyLoadContext&lt;/code&gt;来实现运行时升级和删除插件。完成此篇之后，我得到了很多园友的反馈，很高兴有这么多人能够参与进来，我会根据大家的反馈，来完善这个项目。本篇呢，我将主要解决加载插件引用的问题，这个也是反馈中被问的最多的问题。&lt;/p&gt;

&lt;p&gt;在之前做的插件中，我们做的都是非常非常简单的功能，没有引入任何的第三方库。但是正常情况下，我们所创建的插件或多或少的都会引用一些第三方库，那么下面我们来尝试一下，使用我们先前的项目，加载一个使用第三方程序集, 看看会的得到什么结果。&lt;/p&gt;
&lt;p&gt;这里为了模拟，我创建了一个新的类库项目&lt;code&gt;DemoReferenceLibrary&lt;/code&gt;， 并在之前的&lt;code&gt;DemoPlugin1&lt;/code&gt;项目中引用&lt;code&gt;DemoReferenceLibrary&lt;/code&gt;项目。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;DemoReferenceLibrary&lt;/code&gt;中，我新建了一个类Demo.cs文件, 其代码如下：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;    public class Demo
    {
        public string SayHello()
        {
            return &quot;Hello World. Version 1&quot;;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里就是简单的通过&lt;code&gt;SayHello&lt;/code&gt;方法，返回了一个字符串。&lt;/p&gt;
&lt;p&gt;然后在&lt;code&gt;DemoPlugin1&lt;/code&gt;项目中，我们修改之前创建的&lt;code&gt;Plugin1Controller&lt;/code&gt;，从&lt;code&gt;Demo&lt;/code&gt;类中通过&lt;code&gt;SayHello&lt;/code&gt;方法得到需要在页面中显示的字符串。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;    [Area(&quot;DemoPlugin1&quot;)]
    public class Plugin1Controller : Controller
    {
        public IActionResult HelloWorld()
        {
            var content = new Demo().SayHello();
            ViewBag.Content = content;
            return View();
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后我们打包一下插件，重新将其安装到系统中，访问插件路由之后，就会得到以下错误。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201910/65831-20191021235837083-1888725334.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里就是大部分同学遇到的问题，无法加载程序集&lt;code&gt;DemoReferenceLibrary&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;如何加载插件引用&quot;&gt;如何加载插件引用？&lt;/h2&gt;
&lt;p&gt;这个问题的原因很简单，就是当通过&lt;code&gt;AssemblyLoadContext&lt;/code&gt;加载程序集的时候，我们只加载了插件程序集，没有加载它引用的程序集。&lt;/p&gt;
&lt;p&gt;例如，我们以&lt;code&gt;DemoPlugin1&lt;/code&gt;的为例，在这个插件的目录如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201910/65831-20191021235543878-1051412123.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这个目录中，除了我们熟知的&lt;code&gt;DemoPlugin1.dll&lt;/code&gt;,&lt;code&gt;DemoPlugin1.Views.dll&lt;/code&gt;之外，还有一个&lt;code&gt;DemoReferenceLibrary.dll&lt;/code&gt;文件。 这个文件我们并没有在插件启用时加载到当前的&lt;code&gt;AssemblyLoadContext&lt;/code&gt;中，所以在访问插件路由时，系统找不到这个组件的dll文件。&lt;/p&gt;
&lt;h2 id=&quot;为什么mystique.core.dllsystem.data.sqlclient.dllnewtonsoft.json.dll这些dll不会出现问题呢&quot;&gt;&lt;strong&gt;为什么&lt;code&gt;Mystique.Core.dll&lt;/code&gt;、&lt;code&gt;System.Data.SqlClient.dll&lt;/code&gt;、&lt;code&gt;Newtonsoft.Json.dll&lt;/code&gt;这些DLL不会出现问题呢？&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;在.NET Core中有2种&lt;code&gt;LoadContext&lt;/code&gt;。 一种是我们之前介绍的&lt;code&gt;AssemblyLoadContext&lt;/code&gt;, 它是一种自定义&lt;code&gt;LoadContext&lt;/code&gt;。 另外一种就是系统默认的&lt;code&gt;DefaultLoadContext&lt;/code&gt;。当一个.NET Core应用启动的时候，都会创建并引用一个&lt;code&gt;DefaultLoadContext&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果没有指定&lt;code&gt;LoadContext&lt;/code&gt;， 系统默认会将程序集都加载到&lt;code&gt;DefaultLoadContext&lt;/code&gt;中。这里我们可以查看一下我们的主站点项目，这个项目我们也引用了&lt;code&gt;Mystique.Core.dll&lt;/code&gt;、&lt;code&gt;System.Data.SqlClient.dll&lt;/code&gt;、&lt;code&gt;Newtonsoft.Json.dll&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201910/65831-20191021235914383-547669973.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在.NET Core的设计文档中，对于程序集加载有这样一段描述&lt;/p&gt;
&lt;blockquote readability=&quot;14&quot;&gt;
&lt;p&gt;If the assembly was already present in &lt;em&gt;A1's&lt;/em&gt; context, either because we had successfully loaded it earlier, or because we failed to load it for some reason, we return the corresponding status (and assembly reference for the success case).&lt;/p&gt;
&lt;p&gt;However, if &lt;em&gt;C1&lt;/em&gt; was not found in &lt;em&gt;A1's&lt;/em&gt; context, the &lt;em&gt;Load&lt;/em&gt; method override in &lt;em&gt;A1's&lt;/em&gt; context is invoked.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;For &lt;em&gt;Custom LoadContext&lt;/em&gt;, this override is an opportunity to load an assembly &lt;strong&gt;before&lt;/strong&gt; the fallback (see below) to &lt;em&gt;Default LoadContext&lt;/em&gt; is attempted to resolve the load.&lt;/li&gt;
&lt;li&gt;For &lt;em&gt;Default LoadContext&lt;/em&gt;, this override always returns &lt;em&gt;null&lt;/em&gt; since &lt;em&gt;Default Context&lt;/em&gt; cannot override itself.&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;这里简单来说，意思就是当在一个自定义&lt;code&gt;LoadContext&lt;/code&gt;中加载程序集的时候，如果找不到这个程序集，程序会自动去默认&lt;code&gt;LoadContext&lt;/code&gt;中查找，如果默认&lt;code&gt;LoadContext&lt;/code&gt;中都找不到，就会返回&lt;code&gt;null&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;由此，我们之前的疑问就解决了，这里正是因为主站点已经加载了所需的程序集，虽然在插件的&lt;code&gt;AssemblyLoadContext&lt;/code&gt;中找不到这个程序集，程序依然可以通过默认&lt;code&gt;LoadContext&lt;/code&gt;来加载程序集。&lt;/p&gt;
&lt;h2 id=&quot;那么是不是真的就没有问题了呢&quot;&gt;&lt;strong&gt;那么是不是真的就没有问题了呢？&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;其实我不是很推荐用以上的方式来加载第三方程序集。主要原因有两点&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;不同插件可以引用不同版本的第三方程序集，可能不同版本的第三方程序集实现不同。 而默认&lt;code&gt;LoadContext&lt;/code&gt;只能加载一个版本，导致总有一个插件引用该程序集的功能失效。&lt;/li&gt;
&lt;li&gt;默认&lt;code&gt;LoadContext&lt;/code&gt;中可能加载的第三方程序集与其他插件都不同，导致其他插件功能引用该程序集的功能失效。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以这里最正确的方式，还是放弃使用默认&lt;code&gt;LoadContext&lt;/code&gt;加载程序集，保证每个插件的&lt;code&gt;AssemblyLoadContext&lt;/code&gt;都完全加载所需的程序集。&lt;/p&gt;
&lt;p&gt;那么如何加载这些第三方程序集呢？我们下面就来介绍两种方式&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;原始方式&lt;/li&gt;
&lt;li&gt;使用插件缓存&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;原始方式&quot;&gt;原始方式&lt;/h2&gt;
&lt;p&gt;原始方式比较暴力，我们可以选择加载插件程序集的同时，加载程序集所在目录中所有的dll文件。&lt;/p&gt;
&lt;p&gt;这里首先我们创建了一个插件引用库加载器接口&lt;code&gt;IReferenceLoader&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;    public interface IRefenerceLoader
    {
        public void LoadStreamsIntoContext(CollectibleAssemblyLoadContext context, 
            string folderName, 
            string excludeFile);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们创建一个默认的插件引用库加载器&lt;code&gt;DefaultReferenceLoader&lt;/code&gt;，其代码如下：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;    public class DefaultReferenceLoader : IRefenerceLoader
    {
        public void LoadStreamsIntoContext(CollectibleAssemblyLoadContext context, 
            string folderName, 
            string excludeFile)
        {
            var streams = new List&amp;lt;Stream&amp;gt;();
            var di = new DirectoryInfo(folderName);
            var allReferences = di.GetFiles(&quot;*.dll&quot;).Where(p =&amp;gt; p.Name != excludeFile);

            foreach (var file in allReferences)
            {
                using (var sr = new StreamReader(file.OpenRead()))
                {
                    context.LoadFromStream(sr.BaseStream);
                }
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码解释&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;这里我是为了排除当前已经加载插件程序集，所以添加了一个&lt;code&gt;excludeFile&lt;/code&gt;参数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;folderName&lt;/code&gt;即当前插件的所在目录，这里我们通过&lt;code&gt;DirectoryInfo&lt;/code&gt;类的&lt;code&gt;GetFiles&lt;/code&gt;方法，获取了当前指定&lt;code&gt;folderName&lt;/code&gt;目录中的所有dll文件。&lt;/li&gt;
&lt;li&gt;这里我依然通过文件流的方式加载了插件所需的第三方程序集。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;完成以上代码之后，我们还需要修改启用插件的两部分代码&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;[MystiqueStartup.cs] - 程序启动时，注入&lt;code&gt;IReferenceLoader&lt;/code&gt;服务，启用插件&lt;/li&gt;
&lt;li&gt;[MvcModuleSetup.cs] - 在插件管理页面，触发启用插件操作&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;MystiqueStartup.cs&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;    public static void MystiqueSetup(this IServiceCollection services, IConfiguration configuration)
    {

        ...
            
        services.AddSingleton&amp;lt;IReferenceLoader, DefaultReferenceLoader&amp;gt;();

        var mvcBuilder = services.AddMvc();

        var provider = services.BuildServiceProvider();
        using (var scope = provider.CreateScope())
        {
            ...

            foreach (var plugin in allEnabledPlugins)
            {
                var context = new CollectibleAssemblyLoadContext();
                var moduleName = plugin.Name;
                var filePath = $&quot;{AppDomain.CurrentDomain.BaseDirectory}Modules\\{moduleName}\\{moduleName}.dll&quot;;
                var referenceFolderPath = $&quot;{AppDomain.CurrentDomain.BaseDirectory}Modules\\{moduleName}&quot;;

                _presets.Add(filePath);
                using (var fs = new FileStream(filePath, FileMode.Open))
                {
                    var assembly = context.LoadFromStream(fs);
                    loader.LoadStreamsIntoContext(context, 
                          referenceFolderPath,
                          $&quot;{moduleName}.dll&quot;);

                   ...
                }
            }
        }

        ...
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;MvcModuleSetup.cs&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;    public void EnableModule(string moduleName)
    {
        if (!PluginsLoadContexts.Any(moduleName))
        {
            var context = new CollectibleAssemblyLoadContext();

            var filePath = $&quot;{AppDomain.CurrentDomain.BaseDirectory}Modules\\{moduleName}\\{moduleName}.dll&quot;;
            var referenceFolderPath = $&quot;{AppDomain.CurrentDomain.BaseDirectory}Modules\\{moduleName}&quot;;
            using (var fs = new FileStream(filePath, FileMode.Open))
            {
                var assembly = context.LoadFromStream(fs);
                _referenceLoader.LoadStreamsIntoContext(context, 
                      referenceFolderPath, 
                      $&quot;{moduleName}.dll&quot;);

                ...
            }
        }
        else
        {
            var context = PluginsLoadContexts.GetContext(moduleName);
            var controllerAssemblyPart = new MystiqueAssemblyPart(context.Assemblies.First());
            _partManager.ApplicationParts.Add(controllerAssemblyPart);
        }

        ResetControllActions();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在我们重新运行之前的项目，并访问插件1的路由，你会发现页面正常显示了，并且页面内容也是从&lt;code&gt;DemoReferenceLibrary&lt;/code&gt;程序集中加载出来了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201910/65831-20191021235600898-23107475.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;使用插件缓存&quot;&gt;使用插件缓存&lt;/h2&gt;
&lt;p&gt;原始方式虽然可以帮助我们成功加载插件引用程序集，但是它并不效率，如果插件1和插件2引用了相同的程序集，当插件1的&lt;code&gt;AssemblyLoadContext&lt;/code&gt;加载所有的引用程序集之后，插件2会将插件1所干的事情重复一遍。这并不是我们想要的，我们希望如果多个插件同时使用了相同的程序集，就不需要重复读取dll文件了。&lt;/p&gt;
&lt;p&gt;如何避免重复读取dll文件呢？这里我们可以使用一个静态字典来缓存文件流信息，从而避免重复读取dll文件。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果大家觉着在ASP.NET Core MVC中使用静态字典来缓存文件流信息不安全，可以改用其他缓存方式，这里只是为了简单演示。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里我们首先创建一个引用程序集缓存容器接口&lt;code&gt;IReferenceContainer&lt;/code&gt;， 其代码如下：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;    public interface IReferenceContainer
    {
        List&amp;lt;CachedReferenceItemKey&amp;gt; GetAll();

        bool Exist(string name, string version);

        void SaveStream(string name, string version, Stream stream);

        Stream GetStream(string name, string version);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码解释&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;GetAll&lt;/code&gt;方法会在后续使用，用来获取系统中加载的所有引用程序集&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Exist&lt;/code&gt;方法判断了指定版本程序集的文件流是否存在&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SaveStream&lt;/code&gt;是将指定版本的程序集文件流保存到静态字典中&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GetStream&lt;/code&gt;是从静态字典中拉取指定版本程序集的文件流&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;然后我们可以创建一个引用程序集缓存容器的默认实现&lt;code&gt;DefaultReferenceContainer&lt;/code&gt;类，其代码如下：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;    public class DefaultReferenceContainer : IReferenceContainer
    {
        private static Dictionary&amp;lt;CachedReferenceItemKey, Stream&amp;gt; _cachedReferences = new Dictionary&amp;lt;CachedReferenceItemKey, Stream&amp;gt;();

        public List&amp;lt;CachedReferenceItemKey&amp;gt; GetAll()
        {
            return _cachedReferences.Keys.ToList();
        }

        public bool Exist(string name, string version)
        {
            return _cachedReferences.Keys.Any(p =&amp;gt; p.ReferenceName == name
                &amp;amp;&amp;amp; p.Version == version);
        }

        public void SaveStream(string name, string version, Stream stream)
        {
            if (Exist(name, version))
            {
                return;
            }

            _cachedReferences.Add(new CachedReferenceItemKey { ReferenceName = name, Version = version }, stream);
        }

        public Stream GetStream(string name, string version)
        {
            var key = _cachedReferences.Keys.FirstOrDefault(p =&amp;gt; p.ReferenceName == name
                &amp;amp;&amp;amp; p.Version == version);

            if (key != null)
            {
                _cachedReferences[key].Position = 0;
                return _cachedReferences[key];
            }

            return null;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个类比较简单，我就不做太多解释了。&lt;/p&gt;
&lt;p&gt;完成了引用缓存容器之后，我修改了之前创建的&lt;code&gt;IReferenceLoader&lt;/code&gt;接口，及其默认实现&lt;code&gt;DefaultReferenceLoader&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;    public interface IReferenceLoader
    {
        public void LoadStreamsIntoContext(CollectibleAssemblyLoadContext context, string moduleFolder, Assembly assembly);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;    public class DefaultReferenceLoader : IReferenceLoader
    {
        private IReferenceContainer _referenceContainer = null;
        private readonly ILogger&amp;lt;DefaultReferenceLoader&amp;gt; _logger = null;

        public DefaultReferenceLoader(IReferenceContainer referenceContainer, ILogger&amp;lt;DefaultReferenceLoader&amp;gt; logger)
        {
            _referenceContainer = referenceContainer;
            _logger = logger;
        }

        public void LoadStreamsIntoContext(CollectibleAssemblyLoadContext context, string moduleFolder, Assembly assembly)
        {
            var references = assembly.GetReferencedAssemblies();

            foreach (var item in references)
            {
                var name = item.Name;

                var version = item.Version.ToString();

                var stream = _referenceContainer.GetStream(name, version);

                if (stream != null)
                {
                    _logger.LogDebug($&quot;Found the cached reference '{name}' v.{version}&quot;);
                    context.LoadFromStream(stream);
                }
                else
                {

                    if (IsSharedFreamwork(name))
                    {
                        continue;
                    }

                    var dllName = $&quot;{name}.dll&quot;;
                    var filePath = $&quot;{moduleFolder}\\{dllName}&quot;;

                    if (!File.Exists(filePath))
                    {
                        _logger.LogWarning($&quot;The package '{dllName}' is missing.&quot;);
                        continue;
                    }

                    using (var fs = new FileStream(filePath, FileMode.Open))
                    {
                        var referenceAssembly = context.LoadFromStream(fs);

                        var memoryStream = new MemoryStream();

                        fs.Position = 0;
                        fs.CopyTo(memoryStream);
                        fs.Position = 0;
                        memoryStream.Position = 0;
                        _referenceContainer.SaveStream(name, version, memoryStream);

                        LoadStreamsIntoContext(context, moduleFolder, referenceAssembly);
                    }
                }
            }
        }

        private bool IsSharedFreamwork(string name)
        {
            return SharedFrameworkConst.SharedFrameworkDLLs.Contains($&quot;{name}.dll&quot;);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码解释：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;这里&lt;code&gt;LoadStreamsIntoContext&lt;/code&gt;方法的&lt;code&gt;assembly&lt;/code&gt;参数，即当前插件程序集。&lt;/li&gt;
&lt;li&gt;这里我通过&lt;code&gt;GetReferencedAssemblies&lt;/code&gt;方法，获取了插件程序集引用的所有程序集。&lt;/li&gt;
&lt;li&gt;如果引用程序集在引用容器中不存在，我们就是用文件流加载它，并将其保存到引用容器中， 如果引用程序集已存在于引用容器，就直接加载到当前插件的&lt;code&gt;AssemblyLoadContext&lt;/code&gt;中。这里为了检验效果，如果程序集来自缓存，我使用日志组件输出了一条日志。&lt;/li&gt;
&lt;li&gt;由于插件引用的程序集，有可能是来自&lt;code&gt;Shared Framework&lt;/code&gt;, 这种程序集是不需要加载的，所以这里我选择跳过这类程序集的加载。（这里我还没有考虑Self-Contained发布的情况，后续这里可能会更改）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;最后我们还是需要修改&lt;code&gt;MystiqueStartup.cs&lt;/code&gt;和&lt;code&gt;MvcModuleSetup.cs&lt;/code&gt;中启用插件的代码。&lt;/p&gt;
&lt;p&gt;MystiqueStartup.cs&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;    public static void MystiqueSetup(this IServiceCollection services, IConfiguration configuration)
    {

        ...
        services.AddSingleton&amp;lt;IReferenceContainer, DefaultReferenceContainer&amp;gt;();
        services.AddSingleton&amp;lt;IReferenceLoader, DefaultReferenceLoader&amp;gt;();
        ...

        var mvcBuilder = services.AddMvc();

        var provider = services.BuildServiceProvider();
        using (var scope = provider.CreateScope())
        {
            ...

            foreach (var plugin in allEnabledPlugins)
            {
                ...
               
                using (var fs = new FileStream(filePath, FileMode.Open))
                {
                    var assembly = context.LoadFromStream(fs);
                    loader.LoadStreamsIntoContext(context, referenceFolderPath, assembly);

                    ...
                }
            }
        }

        ...
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;MvcModuleSetup.cs&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;    public void EnableModule(string moduleName)
    {
        if (!PluginsLoadContexts.Any(moduleName))
        {
            ...
            using (var fs = new FileStream(filePath, FileMode.Open))
            {
                var assembly = context.LoadFromStream(fs);
                _referenceLoader.LoadStreamsIntoContext(context, referenceFolderPath, assembly);
               ...
            }
        }
        else
        {
            ...
        }

        ResetControllActions();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;完成代码之后，为了检验效果，我创建了另外一个插件&lt;code&gt;DemoPlugin2&lt;/code&gt;, 这个项目的代码和&lt;code&gt;DemoPlugin1&lt;/code&gt;基本一样。程序启动时，你会发现&lt;code&gt;DemoPlugin2&lt;/code&gt;所使用的引用程序集都是从缓存中加载的，而且&lt;code&gt;DemoPlugin2&lt;/code&gt;的路由也能正常访问。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201910/65831-20191021235614814-1754321527.gif&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;添加页面来显示加载的第三方程序集&quot;&gt;添加页面来显示加载的第三方程序集&lt;/h2&gt;
&lt;p&gt;这里为了显示一下系统中加载了哪些程序集，我添加了一个新页面&lt;code&gt;Assembilies&lt;/code&gt;, 这个页面就是调用了&lt;code&gt;IReferenceContainer&lt;/code&gt;接口中定义的&lt;code&gt;GetAll&lt;/code&gt;方法，显示了静态字典中，所有加载的程序集。&lt;/p&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201910/65831-20191021235628146-912128479.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;最后，在编写完成以上代码功能之后，我们使用以下几种场景来测试一下，看一看&lt;code&gt;AssemblyLoadContext&lt;/code&gt;为我们提供的强大功能。&lt;/p&gt;
&lt;h2 id=&quot;场景1&quot;&gt;场景1&lt;/h2&gt;
&lt;p&gt;2个插件，一个引用&lt;code&gt;DemoReferenceLibrary&lt;/code&gt;的1.0.0.0版本，另外一个引用&lt;code&gt;DemoReferenceLibrary&lt;/code&gt;的1.0.1.0版本。其中1.0.0.0版本，&lt;code&gt;SayHello&lt;/code&gt;方法返回的字符串是&quot;Hello World. Version 1&quot;, 1.0.1.0版本， &lt;code&gt;SayHello&lt;/code&gt;方法返回的字符串是“Hello World. Version 2”。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201910/65831-20191021235636171-1037826095.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;启动项目，安装插件1和插件2，分别运行插件1和插件2的路由，你会得到不同的结果。这说明&lt;code&gt;AssemblyLoadContext&lt;/code&gt;为我们做了很好的隔离，插件1和插件2虽然引用了相同插件的不同版本，但是互相之间完全没有影响。&lt;/p&gt;
&lt;h2 id=&quot;场景2&quot;&gt;场景2&lt;/h2&gt;
&lt;p&gt;当2个插件使用了相同的第三方库，并加载完成之后，禁用插件1。虽然他们引用的程序集相同，但是你会发现插件2还是能够正常访问，这说明插件1的&lt;code&gt;AssemblyLoadContext&lt;/code&gt;的释放，对插件2的&lt;code&gt;AssemblyLoadContext&lt;/code&gt;完全没有影响。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201910/65831-20191021235641060-1601816987.gif&quot;/&gt;&lt;/p&gt;

&lt;p&gt;本篇我为大家介绍了如何解决插件引用程序集的加载问题，这里我们讲解了两种方式，原始方式和缓存方式。这两种方式的最终效果虽然相同，但是缓存方式的效率明显更高。后续我会根据反馈，继续添加新内容，大家敬请期待。&lt;/p&gt;
</description>
<pubDate>Mon, 21 Oct 2019 16:01:00 +0000</pubDate>
<dc:creator>LamondLu</dc:creator>
<og:description>在前一篇中，我给大家演示了如何使用.NET Core 3.0中新引入的`AssemblyLoadContext`来实现运行时升级和删除插件。完成此篇之后，我的得到了很多园友的反馈，很高兴有这么多人能够</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lwqlun/p/11717254.html</dc:identifier>
</item>
<item>
<title>如何正确的在 Android 上使用协程 ？ - 秉心说</title>
<link>http://www.cnblogs.com/bingxinshuo/p/11717209.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bingxinshuo/p/11717209.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;你还记得是哪一年的 Google IO 正式宣布 &lt;code&gt;Kotlin&lt;/code&gt; 成为 Android 一级开发语言吗？是 &lt;code&gt;Google IO 2017&lt;/code&gt; 。如今两年时间过去了，站在一名 Android 开发者的角度来看，Kotlin 的生态环境越来越好了，相关的开源项目和学习资料也日渐丰富，身边愿意去使用或者试用 Kotlin 的朋友也变多了。常年混迹掘金的我也能明显感觉到 Kotlin 标签下的文章慢慢变多了（其实仍然少的可怜）。今年的 Google IO 也放出了 &lt;code&gt;Kotlin First&lt;/code&gt; 的口号，许多新的 API 和功能特性将优先提供 Kotlin 支持。所以，时至今日，实在找不到安卓开发者不学 Kotlin 的理由了。&lt;/p&gt;
&lt;p&gt;今天想聊聊的是 &lt;code&gt;Kotlin Coroutine&lt;/code&gt;。虽然在 Kotlin 发布之初就有了协程，但是直到 2018 年的 &lt;strong&gt;KotlinConf&lt;/strong&gt; 大会上，JetBrain 发布了 Kotlin1.3RC，这才带来了稳定版的协程。即使稳定版的协程已经发布了一年之余，但是好像并没有足够多的用户，至少在我看来是这样。在我学习协程的各个阶段中，遇到问题都鲜有地方可以求助，抛到技术群基本就石沉大海了。基本只能靠一些英文文档来解决问题。&lt;/p&gt;
&lt;p&gt;关于协程的文章我看过很多，总结一下，无非下面几类。&lt;/p&gt;
&lt;p&gt;第一类是 Medium 上热门文章的翻译，其实我也翻译过：&lt;/p&gt;
&lt;blockquote readability=&quot;0.10843373493976&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5cea3ee0f265da1bca51b841&quot;&gt;在 Android 上使用协程（一）：Getting The Background&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5cee800051882544171c5a2c&quot;&gt;在 Android 上使用协程（二）：Getting started&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5cf513d3e51d4577407b1ceb&quot;&gt;在 Android 上使用协程（三） ：Real Work&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;说实话，这三篇文章的确加深了我对协程的理解。&lt;/p&gt;
&lt;p&gt;第二类就是官方文档的翻译了，我看过至少不下于五个翻译版本，还是觉得看 &lt;a href=&quot;https://kotlinlang.org/docs/reference/coroutines/coroutines-guide.html&quot;&gt;官网文档&lt;/a&gt; 比较好，如果英文看着实在吃力，可以对照着 Kotlin 中文站的翻译来阅读。&lt;/p&gt;
&lt;p&gt;在看完官方文档的很长一段时间，我几乎只知道 &lt;code&gt;GlobalScope&lt;/code&gt;。的确，官方文档上基本从头到尾都是在用 GlobalScope 写示例代码。所以一部分开发者，也包括我自己，在写自己的代码时也就直接 GlobalScope 了。一次偶然的机会才发现其实这样的问题是很大的。在 Android 中，一般是不建议直接使用 GlobalScope 的。那么，在 Android 中应该如何正确使用协程呢？再细分一点，如何直接在 Activity 中使用呢？如何配合 ViewModel 、LiveData 、LifeCycle 等使用呢？我会通过简单的示例代码来阐述 Android 上的协程使用，你也可以跟着动手敲一敲。&lt;/p&gt;
&lt;h2 id=&quot;协程在-android-上的使用&quot;&gt;协程在 Android 上的使用&lt;/h2&gt;
&lt;h3 id=&quot;globalscope&quot;&gt;GlobalScope&lt;/h3&gt;
&lt;p&gt;在一般的应用场景下，我们都希望可以异步进行耗时任务，比如网络请求，数据处理等等。当我们离开当前页面的时候，也希望可以取消正在进行的异步任务。这两点，也正是使用协程中所需要注意的。既然不建议直接使用 &lt;code&gt;GlobalScope&lt;/code&gt;，我们就先试验一下使用它会是什么效果。&lt;/p&gt;
&lt;pre class=&quot;kotlin&quot;&gt;
&lt;code&gt;private fun launchFromGlobalScope() {
    GlobalScope.launch(Dispatchers.Main) {
        val deferred = async(Dispatchers.IO) {
            // network request
            delay(3000)
            &quot;Get it&quot;
        }
        globalScope.text = deferred.await()
        Toast.makeText(applicationContext, &quot;GlobalScope&quot;, Toast.LENGTH_SHORT).show()
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 &lt;code&gt;launchFromGlobalScope()&lt;/code&gt; 方法中，我直接通过 &lt;code&gt;GlobalScope.launch()&lt;/code&gt; 启动一个协程，&lt;code&gt;delay(3000)&lt;/code&gt; 模拟网络请求，三秒后，会弹出一个 Toast 提示。使用上是没有任何问题的，可以正常的弹出 Toast 。但是当你执行这个方法之后，立即按返回键返回上一页面，仍然会弹出 Toast 。如果是实际开发中通过网络请求更新页面的话，当用户已经不在这个页面了，就根本没有必要再去请求了，只会浪费资源。GlobalScope 显然并不符合这一特性。&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;Kotlin 文档&lt;/a&gt; 中其实也详细说明了，如下所示:&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;Global scope is used to launch top-level coroutines which are operating on the whole application lifetime and are not cancelled prematurely. Another use of the global scope is operators running in Dispatchers.Unconfined, which don’t have any job associated with them.&lt;/p&gt;
&lt;p&gt;Application code usually should use an application-defined CoroutineScope. Using async or launch on the instance of GlobalScope is highly discouraged.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;大致意思是，Global scope 通常用于启动顶级协程，这些协程在整个应用程序生命周期内运行，不会被过早地被取消。程序代码通常应该使用自定义的协程作用域。直接使用 GlobalScope 的 async 或者 launch 方法是强烈不建议的。&lt;/p&gt;
&lt;p&gt;GlobalScope 创建的协程没有父协程，GlobalScope 通常也不与任何生命周期组件绑定。除非手动管理，否则很难满足我们实际开发中的需求。所以，GlobalScope 能不用就尽量不用。&lt;/p&gt;
&lt;h3 id=&quot;mainscope&quot;&gt;MainScope&lt;/h3&gt;
&lt;p&gt;官方文档中提到要使用自定义的协程作用域，当然，Kotlin 已经给我们提供了合适的协程作用域 &lt;code&gt;MainScope&lt;/code&gt; 。看一下 MainScope 的定义：&lt;/p&gt;
&lt;pre class=&quot;kotlin&quot;&gt;
&lt;code&gt;public fun MainScope(): CoroutineScope = ContextScope(SupervisorJob() + Dispatchers.Main)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;记着这个定义，在后面 ViewModel 的协程使用中也会借鉴这种写法。&lt;/p&gt;
&lt;p&gt;给我们的 Activity 实现自己的协程作用域：&lt;/p&gt;
&lt;pre class=&quot;kotlin&quot;&gt;
&lt;code&gt;class BasicCorotineActivity : AppCompatActivity(), CoroutineScope by MainScope() {}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过扩展函数 &lt;code&gt;launch()&lt;/code&gt; 可以直接在主线程中启动协程，示例代码如下：&lt;/p&gt;
&lt;pre class=&quot;kotlin&quot;&gt;
&lt;code&gt;private fun launchFromMainScope() {
    launch {
        val deferred = async(Dispatchers.IO) {
            // network request
            delay(3000)
            &quot;Get it&quot;
        }
        mainScope.text = deferred.await()
        Toast.makeText(applicationContext, &quot;MainScope&quot;, Toast.LENGTH_SHORT).show()
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后别忘了在 &lt;code&gt;onDestroy()&lt;/code&gt; 中取消协程，通过扩展函数 &lt;code&gt;cancel()&lt;/code&gt; 来实现：&lt;/p&gt;
&lt;pre class=&quot;kotlin&quot;&gt;
&lt;code&gt;override fun onDestroy() {
    super.onDestroy()
    cancel()
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在来测试一下 &lt;code&gt;launchFromMainScope()&lt;/code&gt; 方法吧！你会发现这完全符合你的需求。实际开发中可以把 MainScope 整合到 BaseActivity 中，就不需要重复书写模板代码了。&lt;/p&gt;
&lt;h3 id=&quot;viewmodelscope&quot;&gt;ViewModelScope&lt;/h3&gt;
&lt;p&gt;如果你使用了 MVVM 架构，根本就不会在 Activity 上书写任何逻辑代码，更别说启动协程了。这个时候大部分工作就要交给 ViewModel 了。那么如何在 ViewModel 中定义协程作用域呢？还记得上面 &lt;code&gt;MainScope()&lt;/code&gt; 的定义吗？没错，搬过来直接使用就可以了。&lt;/p&gt;
&lt;pre class=&quot;kotlin&quot;&gt;
&lt;code&gt;class ViewModelOne : ViewModel() {

    private val viewModelJob = SupervisorJob()
    private val uiScope = CoroutineScope(Dispatchers.Main + viewModelJob)

    val mMessage: MutableLiveData&amp;lt;String&amp;gt; = MutableLiveData()

    fun getMessage(message: String) {
        uiScope.launch {
            val deferred = async(Dispatchers.IO) {
                delay(2000)
                &quot;post $message&quot;
            }
            mMessage.value = deferred.await()
        }
    }

    override fun onCleared() {
        super.onCleared()
        viewModelJob.cancel()
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的 &lt;code&gt;uiScope&lt;/code&gt; 其实就等同于 &lt;code&gt;MainScope&lt;/code&gt;。调用 &lt;code&gt;getMessage()&lt;/code&gt; 方法和之前的 &lt;code&gt;launchFromMainScope()&lt;/code&gt; 效果也是一样的，记得在 ViewModel 的 &lt;code&gt;onCleared()&lt;/code&gt; 回调里取消协程。&lt;/p&gt;
&lt;p&gt;你可以定义一个 &lt;code&gt;BaseViewModel&lt;/code&gt; 来处理这些逻辑，避免重复书写模板代码。然而 Kotlin 就是要让你做同样的事，写更少的代码，于是 &lt;code&gt;viewmodel-ktx&lt;/code&gt; 来了。看到 ktx ，你就应该明白它是来简化你的代码的。引入如下依赖：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;implementation &quot;androidx.lifecycle:lifecycle-viewmodel-ktx:2.2.0-alpha03&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后，什么都不需要做，直接使用协程作用域 &lt;code&gt;viewModelScope&lt;/code&gt; 就可以了。&lt;code&gt;viewModelScope&lt;/code&gt; 是 ViewModel 的一个扩展属性，定义如下：&lt;/p&gt;
&lt;pre class=&quot;kotlin&quot;&gt;
&lt;code&gt;val ViewModel.viewModelScope: CoroutineScope
        get() {
            val scope: CoroutineScope? = this.getTag(JOB_KEY)
            if (scope != null) {
                return scope
            }
            return setTagIfAbsent(JOB_KEY,
                CloseableCoroutineScope(SupervisorJob() + Dispatchers.Main))
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看下代码你就应该明白了，还是熟悉的那一套。当 &lt;code&gt;ViewModel.onCleared()&lt;/code&gt; 被调用的时候，&lt;code&gt;viewModelScope&lt;/code&gt; 会自动取消作用域内的所有协程。使用示例如下：&lt;/p&gt;
&lt;pre class=&quot;kotlin&quot;&gt;
&lt;code&gt;fun getMessageByViewModel() {
    viewModelScope.launch {
        val deferred = async(Dispatchers.IO) { getMessage(&quot;ViewModel Ktx&quot;) }
        mMessage.value = deferred.await()
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;写到这里，&lt;code&gt;viewModelScope&lt;/code&gt; 是能满足需求的最简写法了。实际上，写完全篇，&lt;code&gt;viewModelScope&lt;/code&gt; 仍然是我认为的最好的选择。&lt;/p&gt;
&lt;h3 id=&quot;livedata&quot;&gt;LiveData&lt;/h3&gt;
&lt;p&gt;Kotlin 同样为 LiveData 赋予了直接使用协程的能力。添加如下依赖：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;implementation &quot;androidx.lifecycle:lifecycle-livedata-ktx:2.2.0-alpha03&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;直接在 &lt;code&gt;liveData {}&lt;/code&gt; 代码块中调用需要异步执行的挂起函数，并调用 &lt;code&gt;emit()&lt;/code&gt; 函数发送处理结果。示例代码如下所示：&lt;/p&gt;
&lt;pre class=&quot;kotlin&quot;&gt;
&lt;code&gt;val mResult: LiveData&amp;lt;String&amp;gt; = liveData {
    val string = getMessage(&quot;LiveData Ktx&quot;)
    emit(string)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你可能会好奇这里好像并没有任何的显示调用，那么，liveData 代码块是在什么执行的呢？当 LiveData 进入 &lt;code&gt;active&lt;/code&gt; 状态时，&lt;code&gt;liveData{ }&lt;/code&gt; 会自动执行。当 LiveData 进入 &lt;code&gt;inactive&lt;/code&gt; 状态时，经过一个可配置的 timeout 之后会自动取消。如果它在完成之前就取消了，当 LiveData 再次 &lt;code&gt;active&lt;/code&gt; 的时候会重新运行。如果上一次运行成功结束了，就不会再重新运行。也就是说只有自动取消的 &lt;code&gt;liveData{ }&lt;/code&gt; 可以重新运行。其他原因（比如 &lt;code&gt;CancelationException&lt;/code&gt;）导致的取消也不会重新运行。&lt;/p&gt;
&lt;p&gt;所以 &lt;code&gt;livedata-ktx&lt;/code&gt; 的使用是有一定限制的。对于需要用户主动刷新的场景，就无法满足了。&lt;strong&gt;在一次完整的生命周期内，一旦成功执行完成一次，就没有办法再触发了。&lt;/strong&gt; 这句话不知道对不对，我个人是这么理解的。因此，还是 &lt;code&gt;viewmodel-ktx&lt;/code&gt; 的适用性更广，可控性也更好。&lt;/p&gt;
&lt;h3 id=&quot;lifecyclescope&quot;&gt;LifecycleScope&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;implementation &quot;androidx.lifecycle:lifecycle-runtime-ktx:2.2.0-alpha03&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;lifecycle-runtime-ktx&lt;/code&gt; 给每个 &lt;code&gt;LifeCycle&lt;/code&gt; 对象通过扩展属性定义了协程作用域 &lt;code&gt;lifecycleScope&lt;/code&gt; 。你可以通过 &lt;code&gt;lifecycle.coroutineScope&lt;/code&gt; 或者 &lt;code&gt;lifecycleOwner.lifecycleScope&lt;/code&gt; 进行访问。示例代码如下：&lt;/p&gt;
&lt;pre class=&quot;kotlin&quot;&gt;
&lt;code&gt;fun getMessageByLifeCycle(lifecycleOwner: LifecycleOwner) {
    lifecycleOwner.lifecycleScope.launch {
        val deferred = async(Dispatchers.IO) { getMessage(&quot;LifeCycle Ktx&quot;) }
        mMessage.value = deferred.await()
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当 LifeCycle 回调 &lt;code&gt;onDestroy()&lt;/code&gt; 时，协程作用域 &lt;code&gt;lifecycleScope&lt;/code&gt; 会自动取消。在 &lt;code&gt;Activity/Fragment&lt;/code&gt; 等生命周期组件中我们可以很方便的使用，但是在 MVVM 中又不会过多的在 View 层进行逻辑处理，viewModelScope 基本就可以满足 ViewModel 中的需求了，&lt;code&gt;lifecycleScope&lt;/code&gt; 也显得有点那么食之无味。但是他有一个特殊的用法：&lt;/p&gt;
&lt;pre class=&quot;kotlin&quot;&gt;
&lt;code&gt;suspend fun &amp;lt;T&amp;gt; Lifecycle.whenCreated()
suspend fun &amp;lt;T&amp;gt; Lifecycle.whenStarted()
suspend fun &amp;lt;T&amp;gt; Lifecycle.whenResumed()
suspend fun &amp;lt;T&amp;gt; LifecycleOwner.whenCreated()
suspend fun &amp;lt;T&amp;gt; LifecycleOwner.whenStarted()
suspend fun &amp;lt;T&amp;gt; LifecycleOwner.whenResumed()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以指定至少在特定的生命周期之后再执行挂起函数，可以进一步减轻 View 层的负担。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;以上简单的介绍了在 Android 中合理使用协程的一些方案，示例代码已上传至 &lt;a href=&quot;https://github.com/lulululbj/CoroutineDemo&quot;&gt;Github&lt;/a&gt;。关于 &lt;code&gt;MVVM + 协程&lt;/code&gt; 的实战项目，可以看看我的开源项目 &lt;a href=&quot;https://github.com/lulululbj/wanandroid&quot;&gt;wanandroid&lt;/a&gt;，同时也期待你宝贵的意见。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;文章首发微信公众号： &lt;strong&gt;&lt;code&gt;秉心说&lt;/code&gt;&lt;/strong&gt; ， 专注 Java 、 Android 原创知识分享，LeetCode 题解。&lt;/p&gt;
&lt;p&gt;更多最新原创文章，扫码关注我吧！&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 21 Oct 2019 15:48:00 +0000</pubDate>
<dc:creator>秉心说</dc:creator>
<og:description>前言 你还记得是哪一年的 Google IO 正式宣布 成为 Android 一级开发语言吗？是 。如今两年时间过去了，站在一名 Android 开发者的角度来看，Kotlin 的生态环境越来越好了，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bingxinshuo/p/11717209.html</dc:identifier>
</item>
</channel>
</rss>