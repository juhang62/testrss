<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>IOS真机测试（已拥有个人开发者证书） - Solist</title>
<link>http://www.cnblogs.com/Solist/p/10354288.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Solist/p/10354288.html</guid>
<description>&lt;p&gt;创建真机调试证书并进行真机测试&lt;/p&gt;
&lt;p&gt;现在就已经大功告成了，只需要在运行中找到自己的设备（前提：手机连接着电脑），点击运行，程序就会出现在Iphone上了。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1598960/201902/1598960-20190206233240272-872128595.png&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;以下的其中一个是我的程序在手机上的运行截图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1598960/201902/1598960-20190206233259448-831698557.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1598960/201902/1598960-20190206233308108-60951541.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;猜一下哪个是iphone上真正的计算器&quot;&gt;猜一下哪个是Iphone上真正的计算器&lt;/h2&gt;
</description>
<pubDate>Wed, 06 Feb 2019 15:34:00 +0000</pubDate>
<dc:creator>Solist</dc:creator>
<og:description>创建真机调试证书并进行真机测试 步骤1 在启动台中点击其他，找到钥匙串访问。 步骤2 在打开的界面中点击右边的系统根证书，然后点击左上角的钥匙串访问，然后是证书助理，最后点击从证书颁发机构申请证书。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Solist/p/10354288.html</dc:identifier>
</item>
<item>
<title>如何在ASP.NET Core程序启动时运行异步任务（2） - LamondLu</title>
<link>http://www.cnblogs.com/lwqlun/p/10354149.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lwqlun/p/10354149.html</guid>
<description>&lt;blockquote readability=&quot;2.7222222222222&quot;&gt;
&lt;p&gt;原文：&lt;a href=&quot;https://andrewlock.net/running-async-tasks-on-app-startup-in-asp-net-core-part-2/&quot;&gt;Running async tasks on app startup in ASP.NET Core (Part 2)&lt;/a&gt;&lt;br/&gt;作者：Andrew Lock&lt;br/&gt;译者：Lamond Lu&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201902/65831-20190206215519247-618941604.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在我的&lt;a href=&quot;https://www.cnblogs.com/lwqlun/p/10346733.html&quot;&gt;上一篇博客&lt;/a&gt;中，我介绍了如何在ASP.NET Core应用程序启动时运行一些一次性异步任务。本篇博客将继续讨论上一篇的内容，如果你还没有读过，我建议你先读一下前一篇。&lt;/p&gt;
&lt;p&gt;在本篇博客中，我将展示上一篇博文中提出的“在&lt;code&gt;Program.cs&lt;/code&gt;中手动运行异步任务”的实现方法。该实现会使用一些简单的接口和类来封装应用程序启动时的运行任务逻辑。我还会展示一个替代方法，这个替代方法是在Kestral服务器启动时，使用&lt;code&gt;IServer&lt;/code&gt;接口。&lt;/p&gt;
&lt;h2 id=&quot;在应用程序启动时运行异步任务&quot;&gt;在应用程序启动时运行异步任务&lt;/h2&gt;
&lt;p&gt;这里我们先回顾一下上一遍博客内容，在上一篇中，我们试图寻找一种方案，允许我们在ASP.NET Core应用程序启动时执行一些异步任务。这些任务应该是在ASP.NET Core应用程序启动之前执行，但是由于这些任务可能需要读取配置或者使用服务，所以它们只能在ASP.NET Core的依赖注入容器配置完成后执行。数据库迁移，填充缓存都可以这种异步任务的使用场景。&lt;/p&gt;
&lt;p&gt;我们在一篇文章的末尾提出了一个相对完善的解决方案，这个方案是在&lt;code&gt;Program.cs&lt;/code&gt;中“手动”运行任务。运行任务的时机是在&lt;code&gt;IWebHostBuilder.Build()&lt;/code&gt;和&lt;code&gt;IWebHost.RunAsync()&lt;/code&gt;之间。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class Program
{
    public static async Task Main(string[] args)
    {
        IWebHost webHost = CreateWebHostBuilder(args).Build();

        using (var scope = webHost.Services.CreateScope())
        {
            var myDbContext = scope.ServiceProvider.GetRequiredService&amp;lt;MyDbContext&amp;gt;();

            await myDbContext.Database.MigrateAsync();
        }

        await webHost.RunAsync();
    }

    public static IWebHostBuilder CreateWebHostBuilder(string[] args) =&amp;gt;
        WebHost.CreateDefaultBuilder(args)
            .UseStartup&amp;lt;Startup&amp;gt;();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种实现方式是可行的，但是有点乱。这里我们将许多不应该属于&lt;code&gt;Program.cs&lt;/code&gt;职责的代码放在了&lt;code&gt;Program.cs&lt;/code&gt;中，让它看起来有点臃肿了，所以这里我们需要将数据库迁移相关的代码移到另外一个类中。&lt;/p&gt;
&lt;p&gt;这里更麻烦的问题是，我们必须要手动调用任务。如果你在多个应用程序中使用相同的模式，那么最好能改成自动调用任务。&lt;/p&gt;
&lt;h2 id=&quot;在依赖注入容器中注册启动任务&quot;&gt;在依赖注入容器中注册启动任务&lt;/h2&gt;
&lt;p&gt;这里我将使用基于&lt;code&gt;IStartupFilter&lt;/code&gt;和&lt;code&gt;IHostService&lt;/code&gt;使用的模式。它们允许你在依赖注入容器中注册它们的实现类，并在应用程序启动前获取到这些接口的所有实现类，并依次执行它们。&lt;/p&gt;
&lt;p&gt;所以，这里首先我们创建一个简单的接口来启动任务。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public interface IStartupTask
{
    Task ExecuteAsync(CancellationToken cancellationToken = default);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;并且创建一个在依赖注入容器中注册任务的便捷方法。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public static class ServiceCollectionExtensions
{
    public static IServiceCollection AddStartupTask&amp;lt;T&amp;gt;(this IServiceCollection services)
        where T : class, IStartupTask
        =&amp;gt; services.AddTransient&amp;lt;IStartupTask, T&amp;gt;();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后，我们添加一个扩展方法，在应用程序启动时找到所有已注册的IStartupTasks，按顺序运行它们，然后启动IWebHost：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public static class StartupTaskWebHostExtensions
{
    public static async Task RunWithTasksAsync(this IWebHost webHost, CancellationToken cancellationToken = default)
    {
        var startupTasks = webHost.Services.GetServices&amp;lt;IStartupTask&amp;gt;();
       
        foreach (var startupTask in startupTasks)
        {
            await startupTask.ExecuteAsync(cancellationToken);
        }

        await webHost.RunAsync(cancellationToken);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上就是所有的代码。&lt;/p&gt;
&lt;p&gt;下面为了看一下它的实际效果，我将继续使用上一篇中EF Core数据库迁移的例子&lt;/p&gt;
&lt;h2 id=&quot;例子异步迁移数据库&quot;&gt;例子：异步迁移数据库&lt;/h2&gt;
&lt;p&gt;实现&lt;code&gt;IStartupTask&lt;/code&gt;和实现&lt;code&gt;IStartupFilter&lt;/code&gt;非常的相似。你可以从依赖注入容器中注入服务。为了使用依赖注入容器中的服务，这里我们需要手动注入一个&lt;code&gt;IServiceProvider&lt;/code&gt;对象，并手动创建一个Scoped服务。&lt;/p&gt;
&lt;p&gt;EF Core的数据库迁移启动任务类似以下代码：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class MigratorStartupFilter: IStartupTask
{
    private readonly IServiceProvider _serviceProvider;
    public MigratorStartupFilter(IServiceProvider serviceProvider)
    {
        _serviceProvider = serviceProvider;
    }

    public Task ExecuteAsync(CancellationToken cancellationToken = default)
    {
        using(var scope = _seviceProvider.CreateScope())
        {
            var myDbContext = scope.ServiceProvider.GetRequiredService&amp;lt;MyDbContext&amp;gt;();

            await myDbContext.Database.MigrateAsync();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在，我们可以在&lt;code&gt;ConfigureServices&lt;/code&gt;方法中使用依赖注入容器添加启动任务了。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public void ConfigureServices(IServiceCollection services)
{
    services.MyDbContext&amp;lt;ApplicationDbContext&amp;gt;(options =&amp;gt;
        options.UseSqlServer(Configuration               
             .GetConnectionString(&quot;DefaultConnection&quot;)));

    services.AddMvc()
        .SetCompatibilityVersion(CompatibilityVersion.Version_2_1);

    services.AddStartupTask&amp;lt;MigrationStartupTask&amp;gt;();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后我们更新一下&lt;code&gt;Program.cs&lt;/code&gt;, 使用&lt;code&gt;RunWithTasksAsync()&lt;/code&gt;方法替换&lt;code&gt;Run()&lt;/code&gt;方法。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class Program
{
    public static async Task Main(string[] args)
    {
        await CreateWebHostBuilder(args)
            .Build()
            .RunWithTasksAsync();
    }

    public static IWebHostBuilder CreateWebHostBuilder(string[] args) =&amp;gt;
        WebHost.CreateDefaultBuilder(args)
            .UseStartup&amp;lt;Startup&amp;gt;();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上代码利用了C# 7.1中引入的异步Task Main的特性。从功能上来说，它与我上一篇博客中的手动代码等同，但是它有一些优点。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;它的任务实现代码没有放在&lt;code&gt;Program.cs&lt;/code&gt;中。&lt;/li&gt;
&lt;li&gt;由于上一条的优点，开发人员可以很容易的添加额外的任务。&lt;/li&gt;
&lt;li&gt;如果不运行任何任务，它的功能和&lt;code&gt;RunAsync&lt;/code&gt;是一样的&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于以上方案，有一个问题需要注意。这里我们定义的任务会在&lt;code&gt;IConfiguration&lt;/code&gt;和依赖注入容器配置完成之后运行，这也就意味着，当任务执行时，所有的&lt;code&gt;IStartupFilter&lt;/code&gt;都没有运行，中间件管道也没有配置。&lt;/p&gt;
&lt;p&gt;就我个人而言，我不认为这是一个问题，因为我暂时想不出任何可能。到目前为止，我所编写的任务都不依赖于&lt;code&gt;IStartupFilter&lt;/code&gt;和中间件管道。但这也并不意味着没有这种可能。&lt;/p&gt;
&lt;p&gt;不幸的是，使用当前的WebHost代码并没有简单的方法（尽管 在.NET Core 3.0中当ASP.NET Core作为IHostedService运行时，这可能会发生变化）。 问题是应用程序是引导（通过配置中间件管道并运行IStartupFilters）和启动在同一个函数中。 当你在Program.cs中调用&lt;code&gt;WebHost.Run()&lt;/code&gt;时，在内部程序会调用&lt;code&gt;WebHost.StartAsync&lt;/code&gt;，如下所示，为简洁起见,其中只包含了日志记录和一些其他次要代码：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public virtual async Task StartAsync(CancellationToken cancellationToken = default)
{
    _logger = _applicationServices.GetRequiredService&amp;lt;ILogger&amp;lt;WebHost&amp;gt;&amp;gt;();

   
    var application = BuildApplication();

    _applicationLifetime = _applicationServices.GetRequiredService&amp;lt;IApplicationLifetime&amp;gt;() as ApplicationLifetime;
    _hostedServiceExecutor = _applicationServices.GetRequiredService&amp;lt;HostedServiceExecutor&amp;gt;();
    var diagnosticSource = _applicationServices.GetRequiredService&amp;lt;DiagnosticListener&amp;gt;();
    var httpContextFactory = _applicationServices.GetRequiredService&amp;lt;IHttpContextFactory&amp;gt;();
    var hostingApp = new HostingApplication(application, _logger, diagnosticSource, httpContextFactory);

    await Server.StartAsync(hostingApp, cancellationToken).ConfigureAwait(false);

    _applicationLifetime?.NotifyStarted();

    await _hostedServiceExecutor.StartAsync(cancellationToken).ConfigureAwait(false);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里问题是我们想要在&lt;code&gt;BuildApplication()&lt;/code&gt;和&lt;code&gt;Server.StartAsync&lt;/code&gt;之间插入代码，但是现在没有这样做的机制。&lt;/p&gt;
&lt;p&gt;我不确定我所给出的解决方案是否优雅，但它可以工作，并为消费者提供更好的体验，因为他们不需要修改Program.cs&lt;/p&gt;
&lt;h2 id=&quot;使用iserver的替代方案&quot;&gt;使用&lt;code&gt;IServer&lt;/code&gt;的替代方案&lt;/h2&gt;
&lt;p&gt;为了实现在&lt;code&gt;BuildApplication()&lt;/code&gt;和&lt;code&gt;Server.StartAsync()&lt;/code&gt;之间运行异步代码，我能想到的唯一办法是我们自己的实现一个IServer实现（Kestrel）！ 对你来说，听到这个可能感觉非常可怕 - 但是我们真的不打算更换服务器，我们只是去装饰它。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class TaskExecutingServer : IServer
{
    private readonly IServer _server;
    private readonly IEnumerable&amp;lt;IStartupTask&amp;gt; _startupTasks;
    public TaskExecutingServer(IServer server, IEnumerable&amp;lt;IStartupTask&amp;gt; startupTasks)
    {
        _server = server;
        _startupTasks = startupTasks;
    }

    public async Task StartAsync&amp;lt;TContext&amp;gt;(IHttpApplication&amp;lt;TContext&amp;gt; application, CancellationToken cancellationToken)
    {
        foreach (var startupTask in _startupTasks)
        {
            await startupTask.ExecuteAsync(cancellationToken);
        }

        await _server.StartAsync(application, cancellationToken);
    }

    public IFeatureCollection Features =&amp;gt; _server.Features;
    public void Dispose() =&amp;gt; _server.Dispose();
    public Task StopAsync(CancellationToken cancellationToken) =&amp;gt; _server.StopAsync(cancellationToken);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;TaskExecutingServer&lt;/code&gt;在其构造函数中获取了一个&lt;code&gt;IServer&lt;/code&gt;实例 - 这是&lt;code&gt;ASP.NET Core&lt;/code&gt;注册的原始Kestral服务器。我们将大部分&lt;code&gt;IServer&lt;/code&gt;的接口实现直接委托给Kestrel，我们只是拦截对&lt;code&gt;StartAsync&lt;/code&gt;的调用并首先运行注入的任务。&lt;/p&gt;
&lt;p&gt;这个实现最困难部分是使装饰器正常工作。正如我在上一篇文章中所讨论的那样，使用带有默认ASP.NET Core容器的装饰可能会非常棘手。我通常使用Scrutor来创建装饰器，但是如果你不想依赖另一个库，你总是可以手动进行装饰， 但一定要看看Scrutor是如何做到这一点的！&lt;/p&gt;
&lt;p&gt;下面我们添加一个用于添加&lt;code&gt;IStartupTask&lt;/code&gt;的扩展方法， 这个扩展方法做了两件事，一是将&lt;code&gt;IStartupTask&lt;/code&gt;注册到依赖注入容器中，二是装饰了之前注册的&lt;code&gt;IServer&lt;/code&gt;实例（这里为了简洁，我省略了&lt;code&gt;Decorate&lt;/code&gt;方法的实现）。如果它发现&lt;code&gt;IServer&lt;/code&gt;已经被装饰，它会跳过第二步，这样你就可以安全的多次调用&lt;code&gt;AddStartupTask&lt;/code&gt;方法。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public static class ServiceCollectionExtensions
{
    public static IServiceCollection AddStartupTask&amp;lt;TStartupTask&amp;gt;(this IServiceCollection services)
        where TStartupTask : class, IStartupTask
        =&amp;gt; services
            .AddTransient&amp;lt;IStartupTask, TStartupTask&amp;gt;()
            .AddTaskExecutingServer();

    private static IServiceCollection AddTaskExecutingServer(this IServiceCollection services)
    {
        var decoratorType = typeof(TaskExecutingServer);
        if (services.Any(service =&amp;gt; service.ImplementationType == decoratorType))
        {
            return services;
        }

        return services.Decorate&amp;lt;IServer, TaskExecutingServer&amp;gt;();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用这两段代码，我们不再需要再对Program.cs文件进行任何更改，并且我们是在完全构建应用程序后执行我们的任务，这其中也包括IStartupFilters和中间件管道。&lt;/p&gt;
&lt;p&gt;启动过程的序列图现在看起来有点像这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201902/65831-20190206215559298-1703373608.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上就是这种实现方式全部的内容。它的代码非常少, 以至于我自己都在考虑是否要自己编写一个库。不过最后我还是在&lt;a href=&quot;https://github.com/andrewlock/NetEscapades.AspNetCore.StartupTasks&quot;&gt;GitHub&lt;/a&gt;和&lt;a href=&quot;https://www.nuget.org/packages/NetEscapades.AspNetCore.StartupTasks/&quot;&gt;Nuget&lt;/a&gt;上创建了一个库NetEscapades.AspNetCore.StartupTasks&lt;/p&gt;
&lt;p&gt;这里我只编写了使用后一种&lt;code&gt;IServer&lt;/code&gt;实现的库，因为它更容易使用，而且Thomas Levesque已经编写针对第一种方法可用的&lt;a href=&quot;https://github.com/thomaslevesque/AspNetCore.AsyncInitialization/&quot;&gt;NuGet&lt;/a&gt;包。&lt;/p&gt;
&lt;p&gt;在GitHub的实现中，我手动构造了装饰器，以避免强制依赖Scrutor。 但最好的方法可能就是将代码复制并粘贴到您自己的项目中。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;在这篇博文中，我展示了两种在ASP.NET Core应用程序启动时异步运行任务的方法。 第一种方法需要稍微修改Program.cs，但是“更安全”，因为它不需要修改像IServer这样的内部实现细节。 第二种方法是装饰IServer，提供更好的用户体验，但感觉更加笨拙。&lt;/p&gt;
</description>
<pubDate>Wed, 06 Feb 2019 14:07:00 +0000</pubDate>
<dc:creator>LamondLu</dc:creator>
<og:description>在本篇博客中，我将展示上一篇博文中提出的Program.cs中手动运行异步任务”的实现方法。该实现会使用一些简单的接口和类来封装应用程序启动时的运行任务逻辑。我还会展示一个替代方法，这个替代方法是在K</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lwqlun/p/10354149.html</dc:identifier>
</item>
<item>
<title>多线程场景设计利器：分离方法的调用和执行——命令模式总结 - dashuai的博客</title>
<link>http://www.cnblogs.com/kubixuesheng/p/10353809.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kubixuesheng/p/10353809.html</guid>
<description>&lt;p&gt;个人感觉，&lt;span&gt;&lt;strong&gt;该模式主要还是在多线程程序的设计中比较常用&lt;/strong&gt;&lt;/span&gt;，尤其是一些异步任务执行的过程。但是本文还是打算先在单线程程序里总结它的用法，至于多线程环境中命令模式的用法，还是想在多线程的设计模式里重点总结。&lt;/p&gt;

&lt;p&gt;其实思路很简单，就是把方法的请求调用和具体执行过程分开，让客户端不知道该请求是如何、何时执行的。那么如何分开呢？&lt;/p&gt;
&lt;p&gt;其实没什么复杂的，就是使用 OO 思想，把对方法的请求封装为对象即可，然后在设计一个请求的接受者对象，当然还要有一个请求的发送者对象，请求本身也是一个对象。最后，请求要如何执行呢？&lt;/p&gt;
&lt;p&gt;故，除了请求对象，请求发送者，请求接受者，还要一个请求执行者——这里可以看成是客户端，而请求（其实叫命令、或者请求都是一样的意思，后文就用请求这个术语）最好设计为抽象的（或者接口）。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;也可得知，命令模式是对象的行为型的设计模式。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;模拟场景：在线教育平台售卖一些培训的视频课程，规定必须付费后才能观看，故管理员需要有开放课程观看和关闭课程观看权限的操作&lt;/p&gt;
&lt;p&gt;首先需要一个抽象的命令（请求）接口&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; ICommand { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 抽象的命令（请求）接口&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; execute();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后设计一个课程类——Lesson，它代表课程本身，也是命令（请求）的接受者，因为是对课程这个实体下命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Lesson { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 代表课程本身，也是命令（请求）的接受者，因为是对课程这个实体下命令&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Lesson(String name) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; openLesson() {
        System.out.println(&lt;/span&gt;&quot;可以观看课程：&quot; +&lt;span&gt; name);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; closeLesson() {
        System.out.println(&lt;/span&gt;&quot;不可以观看课程：&quot; +&lt;span&gt; name);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面是两个具体的命令类，分别实现命令接口，里面是有聚合关系，把课程 Lesson 的引用聚合到命令类，哪一个命令要对哪一个实体，不能写错，比如关闭对关闭。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CloseCommand &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; ICommand {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Lesson lesson;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; CloseCommand(Lesson lesson) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.lesson =&lt;span&gt; lesson;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; execute() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.lesson.closeLesson();
    }
}
&lt;/span&gt;&lt;span&gt;//////////////////////////////////////////////////////
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; OpenCommand &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; ICommand {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Lesson lesson;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; OpenCommand(Lesson lesson) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.lesson =&lt;span&gt; lesson;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; execute() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.lesson.openLesson();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;设计一个管理员类，作为命令（请求）的调用者，用来发出请求（命令），而命令的实际执行，交给了命令（请求）的接受者——Lesson&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Admin2 {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; ICommand commond;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCommond(ICommand commond) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.commond =&lt;span&gt; commond;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; executeCommond() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.commond.execute();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;客户端&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        Lesson lesson1 = &lt;span&gt;new&lt;/span&gt; Lesson(&quot;c++&quot;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 请求（命令）的接受者&lt;/span&gt;
        CloseCommand closeCommand1 = &lt;span&gt;new&lt;/span&gt; CloseCommand(lesson1); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 命令封装为对象&lt;/span&gt;
        OpenCommand openCommand1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; OpenCommand(lesson1);
        Admin2 admin2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Admin2(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 请求（命令）的调用者：用来发出请求&lt;/span&gt;
        admin2.setCommond(openCommand1); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将命令传给调用者&lt;/span&gt;
&lt;span&gt;        admin2.executeCommond(); // 发出请求（命令），但是admin 并不知道这个请求（命令）发给了谁，是谁在执行这个请求（命令）
        admin2.setCommond(closeCommand1);
        admin2.executeCommond();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上就实现了请求调用和具体执行的分离（解耦）&lt;/p&gt;

&lt;p&gt;下面是一次执行多个命令的写法，也可以作为宏命令的实现&lt;/p&gt;
&lt;p&gt;命令接口和具体命令都不变，admin 变化如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Admin {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; List&amp;lt;ICommand&amp;gt; commondList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用 ArrayList 还能保证命令的顺序执行&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addCommond(ICommand commond) {
        commondList.add(commond);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; executeCommond() {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (ICommand commond : commondList) {
            commond.execute();
        }
        commondList.clear();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然这里用栈等数据结构去包装命令也是可以的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        Lesson lesson = &lt;span&gt;new&lt;/span&gt; Lesson(&quot;java&quot;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 请求（命令）的接受者&lt;/span&gt;
        CloseCommand closeCommand = &lt;span&gt;new&lt;/span&gt; CloseCommand(lesson); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 命令&lt;/span&gt;
        OpenCommand openCommand = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; OpenCommand(lesson);
        Admin admin &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Admin(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 请求（命令）的调用者：用来发出请求&lt;/span&gt;
        admin.addCommond(openCommand); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将命令传给调用者&lt;/span&gt;
&lt;span&gt;        admin.addCommond(closeCommand);
        admin.executeCommond();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;引申：空类型模式&lt;/h2&gt;
&lt;p&gt;再比如，使用静态数组去包装命令，这里引申一个空类型模式，就是说有一个类，这个类什么都不做，就是占位或者初始化用的，代替 null 类型。&lt;/p&gt;
&lt;p&gt;下面举一个例子，设计一个控制器，控制电灯的开关，闪烁，变暗，变亮等操作&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; ICommand2 {
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; execute(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 命令接口&lt;/span&gt;
&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;//////////////////////////////////
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; LightOffCommand &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; ICommand2 {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Light light;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; LightOffCommand(Light light) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.light =&lt;span&gt; light;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; execute() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.light.off();
    }
}
&lt;/span&gt;&lt;span&gt;//////////////////////////////////
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; LightOnCommand &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; ICommand2 {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Light light;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; LightOnCommand(Light light) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.light =&lt;span&gt; light;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; execute() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.light.on();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.light.zoomin();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.light.blink();
    }
}
&lt;/span&gt;&lt;span&gt;//////////////////////////////////
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; EmptyCommand &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; ICommand2 { // 空类型模式的体现
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; execute() {
        System.out.println(&lt;/span&gt;&quot;什么都不做&quot;&lt;span&gt;);
    }
}
&lt;/span&gt;&lt;span&gt;//////////////////////////////////
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Light {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Light() {
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; on() {
        System.out.println(&lt;/span&gt;&quot;电灯打开&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; off() {
        System.out.println(&lt;/span&gt;&quot;电灯关闭&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; zoomin() {
        System.out.println(&lt;/span&gt;&quot;灯光变强&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; zoomout() {
        System.out.println(&lt;/span&gt;&quot;灯光变弱&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; blink() {
        System.out.println(&lt;/span&gt;&quot;灯光闪烁&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; noBlink() {
        System.out.println(&lt;/span&gt;&quot;灯光停止闪烁&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面是一个控制器类，setCommand 方法可以设置某个命令和某个操作的对应关系，初始化时，使用空类型模式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MainController {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; ICommand2[] onCommands;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; ICommand2[] offCommands;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; MainController() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.onCommands = &lt;span&gt;new&lt;/span&gt; ICommand2[3&lt;span&gt;];
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.offCommands = &lt;span&gt;new&lt;/span&gt; ICommand2[2&lt;span&gt;];
        ICommand2 emptyCommand &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EmptyCommand();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 3; i++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.onCommands[i] =&lt;span&gt; emptyCommand;
        }
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 2; i++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.offCommands[i] =&lt;span&gt; emptyCommand;
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setCommand(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; idx, ICommand2 onCommand, ICommand2 offCommand) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.onCommands[idx] =&lt;span&gt; onCommand;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.offCommands[idx] =&lt;span&gt; offCommand;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; executeOnCommand(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; idx) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.onCommands[idx].execute();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; executeOffCommand(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; idx) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.offCommands[idx].execute();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;客户端&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
        MainController mainController = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MainController();
        Light roomLight &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Light();
        Light doorLight &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Light();
        LightOnCommand roomLightOnCommand &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LightOnCommand(roomLight);
        LightOffCommand roomLightOffCommand &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LightOffCommand(roomLight);
        LightOnCommand doorLightOnCommand &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LightOnCommand(doorLight);
        LightOffCommand doorLightOffCommand &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LightOffCommand(doorLight);

        mainController.setCommand(&lt;/span&gt;0&lt;span&gt;, roomLightOnCommand, roomLightOffCommand);
        mainController.setCommand(&lt;/span&gt;1&lt;span&gt;, doorLightOnCommand, doorLightOffCommand);

        mainController.executeOnCommand(&lt;/span&gt;0&lt;span&gt;);
        mainController.executeOffCommand(&lt;/span&gt;0&lt;span&gt;);
        mainController.executeOnCommand(&lt;/span&gt;1&lt;span&gt;);
        mainController.executeOffCommand(&lt;/span&gt;1&lt;span&gt;);
        mainController.executeOnCommand(&lt;/span&gt;2);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;通过封装对方法的请求调用和方法执行过程，并将其分离，也就是所谓的完全解耦了。&lt;/p&gt;
&lt;p&gt;故可以对方法的调用执行实现一些额外操作，比如记录日志，撤销某个方法的请求调用，或者实现一次请求，N 次执行某个方法等。&lt;/p&gt;
&lt;p&gt;在架构上，可以让程序易于扩展新的请求（命令）。&lt;/p&gt;

&lt;p&gt;这样做，在多线程环境下的好处是：&lt;/p&gt;
&lt;p&gt;1、&lt;span&gt;&lt;strong&gt;避免算法（策略）模块执行缓慢拖累调用方——抽象了需要等待的操作&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2、控制执行顺序，因为请求调用和具体执行分离，故执行顺序和调用顺序没有关系&lt;/p&gt;
&lt;p&gt;3、可以轻松实现请求的取消，或者反复执行某个请求&lt;/p&gt;
&lt;p&gt;4、请求调用和具体执行分离后，进一步把负责调用的机器和负责执行的机器分开，可以基于网络，实现分布式程序&lt;/p&gt;

&lt;p&gt;前面，无论在什么环境下，都提到了能撤销命令（请求），故命令模式经常和备忘录模式搭配使用。参考：&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/kubixuesheng/p/10353325.html&quot;&gt;保存快照和撤销功能的实现方案——备忘录模式总结&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;这里举一个很简单的例子，还是电灯开关的例子&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; ICommand3 {
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; execute();
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; undo(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 和 execute 执行相反的操作&lt;/span&gt;
&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;//////////////////////////////////
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; EmptyCommand &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; ICommand3 {
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; execute() {
        System.out.println(&lt;/span&gt;&quot;什么都不做&quot;&lt;span&gt;);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; undo() {
        System.out.println(&lt;/span&gt;&quot;什么都不做&quot;&lt;span&gt;);
    }
}
&lt;/span&gt;&lt;span&gt;////////////////////////////////&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; LightOnCommand &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; ICommand3 {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Light light;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; LightOnCommand(Light light) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.light =&lt;span&gt; light;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; execute() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.light.on();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.light.zoomin();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.light.blink();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; undo() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.light.noBlink();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.light.zoomout();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.light.off();
    }
}
&lt;/span&gt;&lt;span&gt;//////////////////////////////////&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; LightOffCommand &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; ICommand3 {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Light light;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; LightOffCommand(Light light) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.light =&lt;span&gt; light;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; execute() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.light.off();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; undo() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.light.on();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;控制器也要变化，初始化命令的同时，也要初始化 undo 命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MainController {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; ICommand3[] onCommands;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; ICommand3[] offCommands;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; ICommand3 undoCommand; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 记录上一个命令&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; MainController() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.onCommands = &lt;span&gt;new&lt;/span&gt; ICommand3[3&lt;span&gt;];
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.offCommands = &lt;span&gt;new&lt;/span&gt; ICommand3[2&lt;span&gt;];
        ICommand3 emptyCommand &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EmptyCommand();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 3; i++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.onCommands[i] =&lt;span&gt; emptyCommand;
        }
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 2; i++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.offCommands[i] =&lt;span&gt; emptyCommand;
        }
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.undoCommand =&lt;span&gt; emptyCommand; // 初始化 undo 命令
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setCommand(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; idx, ICommand3 onCommand, ICommand3 offCommand) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.onCommands[idx] =&lt;span&gt; onCommand;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.offCommands[idx] =&lt;span&gt; offCommand;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; executeOnCommand(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; idx) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.onCommands[idx].execute();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.undoCommand = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.onCommands[idx];
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; executeOffCommand(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; idx) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.offCommands[idx].execute();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.undoCommand = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.offCommands[idx];
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; undoCommand() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.undoCommand.undo();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;客户端&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
        MainController mainController = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MainController();
        Light roomLight &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Light();
        LightOffCommand offCommand &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LightOffCommand(roomLight);
        LightOnCommand onCommand &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LightOnCommand(roomLight);
        mainController.setCommand(&lt;/span&gt;0&lt;span&gt;, onCommand, offCommand);
        mainController.executeOnCommand(&lt;/span&gt;0&lt;span&gt;);
        System.out.println();
        mainController.executeOffCommand(&lt;/span&gt;0&lt;span&gt;);
        System.out.println();
        mainController.undoCommand();
        System.out.println();
        mainController.executeOffCommand(&lt;/span&gt;0&lt;span&gt;);
        System.out.println();
        mainController.executeOnCommand(&lt;/span&gt;0&lt;span&gt;);
        System.out.println();
        mainController.undoCommand();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;电灯打开
灯光变强
灯光闪烁

电灯关闭

电灯打开

电灯关闭

电灯打开
灯光变强
灯光闪烁

灯光停止闪烁
灯光变弱
电灯关闭&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;个人觉得，唯一的缺点就是会使得程序复杂性提高，但是我认为微不足道，基础扎实的 RD 应该无压力阅读和使用才对，因为在多线程程序里，该模式大量出现，比如 Netty 等框架就大量使用了该思想。 &lt;/p&gt;

&lt;p&gt;策略是不同的算法做同一件事情。不同的策略之间可以相互替换。比如实现一个支付功能，有微信支付，支付宝支付，各自渠道的支付。。。&lt;/p&gt;
&lt;p&gt;命令是不同的命令做不同的事情。对外隐藏了具体的执行细节。比如菜单中的复制，移动和压缩&lt;/p&gt;

&lt;p&gt;最最常见的就是 lang 包里的 Runnable 接口，这就是一个命令接口，将对线程启动的请求和具体的执行分离了。实现该接口，也是启动线程推荐的写法&lt;/p&gt;
</description>
<pubDate>Wed, 06 Feb 2019 13:49:00 +0000</pubDate>
<dc:creator>dashuai的博客</dc:creator>
<og:description>前言 个人感觉，该模式主要还是在多线程程序的设计中比较常用，尤其是一些异步任务执行的过程。但是本文还是打算先在单线程程序里总结它的用法，至于多线程环境中命令模式的用法，还是想在多线程的设计模式里重点总</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kubixuesheng/p/10353809.html</dc:identifier>
</item>
<item>
<title>进程同步经典示例 多线程上篇（五） - noteless</title>
<link>http://www.cnblogs.com/noteless/p/10350296.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/noteless/p/10350296.html</guid>
<description>&lt;p&gt;&lt;span&gt;同步回顾&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;进程同步控制有多种方式：&lt;/span&gt;&lt;span&gt;算法、硬件、信号量、管程&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;这些方式可以认为就是&lt;/span&gt;&lt;span&gt;同步的工具（方法、函数）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如信号量机制中的wait(S) 和 signal(S) ，就相当于是两个方法调用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;调用wait(S)就会申请这个资源，否则就会等待（进入等待队列）；调用signal(S)就会释放资源（或一并唤醒等待队列中的某个）；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在梳理同步问题的解决思路时，只需要合理安排方法调用即可，底层的实现细节不需要关注。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接下来以这种套路，看一下借助与不同的同步方式“算法、硬件、信号量、管程”这一“API”，如何解决经典的进程同步问题&lt;/span&gt;&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190206190519574-1560421897.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;生产者消费者&lt;/span&gt;&lt;/h3&gt;
&lt;div readability=&quot;20&quot;&gt;
&lt;hr noshade=&quot;noshade&quot;/&gt;&lt;p&gt;&lt;span&gt;生产者-消费者(producer-consumer)问题是一个著名的进程同步问题。它描述的是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有一&lt;span&gt;群生产者进程在生产产品，并将这些产品提供给消费者进程去消费。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;为使生产者进程与消&lt;/span&gt;&lt;span&gt;费者进程能并发执行，在两者之间设置了一个具有 n 个缓冲区的缓冲池，生产者进程将它&lt;/span&gt;&lt;span&gt;所生产的产品放入一个缓冲区中；消费者进程可从一个缓冲区中取走产品去消费。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;尽管所&lt;/span&gt;&lt;span&gt;有的生产者进程和消费者进程都是以异步方式运行的，但它们之间必须保持同步&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;也就是即不允&lt;/span&gt;&lt;span&gt;许消费者进程到一个空缓冲区去取产品，也不允许生产者进程向一个已装满产品且尚未被&lt;/span&gt;&lt;span&gt;取走的缓冲区中投放产品。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr noshade=&quot;noshade&quot;/&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;记录型信号量&lt;/span&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;对于缓冲池本身，可以借助一个互斥信号量mutex实现各个进程对缓冲池的互斥使用；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;生产者关注于缓冲池空位子的个数，消费者关注的是缓冲池中被放置好产品的满的个数&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190203140634138-449927561.png&quot;&gt;&lt;img title=&quot;image_5c568495_5abf&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190203140639601-1041444768.png&quot; alt=&quot;image_5c568495_5abf&quot; width=&quot;548&quot; height=&quot;257&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;所以，我们总共设置&lt;span&gt;三个信号量semaphore&lt;/span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;mutex&lt;/span&gt;值为&lt;span&gt;1&lt;/span&gt;，用于进程间互斥访问缓冲池&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;full&lt;/span&gt;表示缓冲区这一排坑中被放置产品的个数，初始时为&lt;span&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;empty&lt;/span&gt;表示缓冲区中空位子的个数，初始时为&lt;span&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;对于缓冲池以一个数组的形式进行描述：&lt;/span&gt;&lt;span&gt;buffer[n]&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;另外还需要定义两个用于对数组进行访问的下标 &lt;span&gt;in&lt;/span&gt; 和 &lt;span&gt;out&lt;/span&gt; ，初始时都是0，也就是生产者会往0号位置放置元素，消费者会从0号开始取&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;每次的操作之后，下标后移，in和out采用自增的方式，所以应该是循环设置，比如in为10时，应该从头再来，所以求余（简言之in out序号一直自增，通过求余循环）&lt;/span&gt;&lt;/p&gt;

&lt;div readability=&quot;8.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;变量定义&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; in=0, out=0&lt;span&gt;;
item buffer[n];
semaphore mutex&lt;/span&gt;=l，empty=n, full=0&lt;span&gt;;
 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;生产者&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; proceducer(){
&lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;{
producer an item nextp;
......
wait(empty);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;等待空位子&lt;/span&gt;
wait(mutex);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;等待缓冲池可用&lt;/span&gt;
buffer[in] =nextp;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置元素&lt;/span&gt;
in =(in+1)%n;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;下标后移&lt;/span&gt;
signal(mutex);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;释放缓冲池&lt;/span&gt;
signal(full);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;“满”也就是已生产产品个数释放1个(+1)&lt;/span&gt;
}&lt;span&gt;while&lt;/span&gt;&lt;span&gt;(TRUE);
 
 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;消费者&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; consumer() {
&lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;{
wait(full);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;等待已生产资源个数&lt;/span&gt;
wait(mutex);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;等待缓冲池可用&lt;/span&gt;
nextc= buffer[out];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获得一个元素&lt;/span&gt;
out =(out+1) % n;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;下标后移&lt;/span&gt;
signal(mutex);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;释放缓冲池&lt;/span&gt;
signal(empty);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;空位子多出来一个&lt;/span&gt;
consumer the item in nextc;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;消费掉获得的产品&lt;/span&gt;
} &lt;span&gt;while&lt;/span&gt;&lt;span&gt;(TRUE);
}
 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;主程序&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main() {
proceducer();
consumer();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;以上就是一个记录型信号量解决生产者消费者的问题的思路&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;对于信号量中用于实现互斥的wait和signal必须是成对出现的，尽管他们可能位于不同的程序中，这都无所谓，他们使用信号量作为纽带进行联系&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190203140645143-1905290356.png&quot;&gt;&lt;img title=&quot;image_5c568495_6434&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190203140649540-1615770663.png&quot; alt=&quot;image_5c568495_6434&quot; width=&quot;519&quot; height=&quot;172&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;AND型信号量&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;对于生产者和消费者，都涉及两种资源，一个是缓冲池，一个是缓冲池空或满&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以可以将上面两种资源申请的步骤转换为AND型，比如&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;wait(empty);//等待空位子&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;wait(mutex);//等待缓冲池可用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;转换为AND的形式的Swait(empty，mutex)&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;11&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; in=0, out=0&lt;span&gt;;
item buffer[n];
semaphore mutex&lt;/span&gt;=l, empty=n, full=&lt;span&gt;O;
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; proceducer() {
&lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;{
producer an item nextp;
......
Swait(empty, mutex);
buffer[in] &lt;/span&gt;=&lt;span&gt; nextp;
in &lt;/span&gt;=(in+1) %&lt;span&gt; n;
Ssignal(mutex, full)
} &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt;(TRUE);
}
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; consumer() {
&lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;{
Swait(full, mutex);
nextc&lt;/span&gt;=&lt;span&gt; buffer[out];
out &lt;/span&gt;=(out+1) %&lt;span&gt; n;
Ssignal(mutex, empty);
consumer the item in nextc;
......
} &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt;(TRUE);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这个示例中，AND型信号量方案只是记录型信号量机制的一个简单升级&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;管程方案&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;管程由一组共享数据结构以及过程，还有条件变量组成。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;共享的数据结构就是缓冲池，大小为n&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;生产者向缓冲池中放入产品，定义过程put(item)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;消费者从缓冲池中取出产品，定义过程get(item)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于生产者，非满 not full 就可以继续生产数据；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于消费者，非空 not empty 就可以继续消费数据；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以设置两个条件：notfull，notempty&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果数据个数 count&amp;gt;=N，那么 notfull 非满条件不成立&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果数据个数 count&amp;lt;=0，那么notempty 非空条件不成立&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也就是说：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;count&amp;gt;=N，notfull 不满足，生产者就会在 notfull 条件上等待&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;count&amp;lt;=0N，notempty 不满足，消费者就会在 notempty 条件上等待&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;8.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义一个管程&lt;/span&gt;&lt;span&gt;
Monitor procducerconsumer {
item buffer[N];&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;缓冲区大小&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; in, out;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;访问下标&lt;/span&gt;&lt;span&gt;
condition notfull, notempty;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;条件变量&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; count;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;已生产产品的个数
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;生产方法&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; put(item x) {
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(count&amp;gt;=&lt;span&gt;N){
notfull.wait; &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果生产个数已经大于缓冲区大小，将生产进程添加到notfull条件的等待队列中&lt;/span&gt;&lt;span&gt;
}
buffer[in] &lt;/span&gt;= x; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置元素&lt;/span&gt;&lt;span&gt;
in &lt;/span&gt;= (in+1) % N; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;下标移动&lt;/span&gt;&lt;span&gt;
count&lt;/span&gt;++;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;已生产产品个数+1&lt;/span&gt;&lt;span&gt;
notempty.signal &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;释放等待notempty条件的进程&lt;/span&gt;&lt;span&gt;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取方法&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; get(item x) {
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(count&amp;lt;=0&lt;span&gt;){
notempty.wait; &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果已生产产品数量为0（以下），消费者进程添加到notempty的等待队列中&lt;/span&gt;&lt;span&gt;
}
x &lt;/span&gt;= buffer[out];&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 读取元素&lt;/span&gt;&lt;span&gt;
out &lt;/span&gt;= (out+1) % N; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 下标移动&lt;/span&gt;&lt;span&gt;
count&lt;/span&gt;--; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;已生产产品个数-1&lt;/span&gt;&lt;span&gt;
notfull.signal; &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 释放等待notfull条件的进程&lt;/span&gt;&lt;span&gt;
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化数据方法&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; init(){
in&lt;/span&gt;=0;out=0;count=0&lt;span&gt;;
}
} PC;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;生产者和消费者逻辑&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; producer(){
item x;
&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt;(TRUE){
produce an item in nextp;
PC.put(x);
}
}
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; consumer( {
item x;
&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt;(TRUE) {
PC.get(x);
consume the item in nextc;
......
}
}
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(){
proceducer();
consumer();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;管程的解决思路就是将同步的问题封装在管程内部，管程会帮你解决所有的问题&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;哲学家进餐&lt;/span&gt;&lt;/h3&gt;

&lt;div readability=&quot;19&quot;&gt;
&lt;p&gt;&lt;span&gt;由Dijkstra提出并解决的哲学家进餐问题(The Dinning Philosophers Problem)是典型的同&lt;span&gt;步问题。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;该问题是描述有五个哲学家共用一张圆桌，分别坐在周围的五张椅子上，在圆桌&lt;/span&gt;&lt;span&gt;上有五个碗和五只筷子，他们的生活方式是交替地进行思考和进餐。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;平时，一个哲学家进&lt;/span&gt;&lt;span&gt;行思考，饥饿时便试图取用其左右最靠近他的筷子，只有在他拿到两只筷子时才能进餐。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;进餐完毕，放下筷子继续思考。 &lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190203140651861-523892948.png&quot;&gt;&lt;img title=&quot;image_5c568495_2aeb&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190203140652696-760097453.png&quot; alt=&quot;image_5c568495_2aeb&quot; width=&quot;416&quot; height=&quot;355&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;灰色大圆桌，黄色凳子，每个人左右各有一根筷子，小圆点表示碗。（尽管画的像乌龟，但这真的是桌子 ￣□￣｜｜）&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;h4&gt;&lt;span&gt;记录型信号量机制&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;放在桌子上的筷子是临界资源，同一根筷子不可能被两个人同时使用，所以每一根筷子都是一个共享资源&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;需要使用五个信号量表示，五个信号量每个表示一根筷子&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span&gt;当哲学家饥饿时，总是先去拿他左边的筷子，即执行wait(chopstick[i])； &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;成功后，再去拿他右边的筷子，即执行wait(chopstick[(i+1)mod 5])；又成功后便可进餐。（i+1)mod 5 是为了处理第五个人右边的是第一个的问题 ）&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;进餐完毕，又先放下他左边的筷子，然后再放右边的筷子。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;div readability=&quot;9.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义五个信号量
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;为简单起见，假定数组起始下标为1
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;信号量全部初始化为1&lt;/span&gt;&lt;span&gt;
semaphore chopstick[&lt;/span&gt;5]={1,1,1,1,1&lt;span&gt;};
&lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;按照我们上面图中所示，第 i号哲学家，左手边为i号筷子，右手边是 (i+1)%5&lt;/span&gt;
wait(chopstick[i]);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;等待左手边的，&lt;/span&gt;&lt;span&gt;
wait(chopstick[(i&lt;/span&gt;+1)%5]);]);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;等待右手边的
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 进餐......&lt;/span&gt;&lt;span&gt;
signal(chopstick[i]);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;释放左手边的&lt;/span&gt;&lt;span&gt;
signal(chopstick[(i&lt;/span&gt;+1)%5])&lt;span&gt;//&lt;/span&gt;&lt;span&gt;释放右手边的
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 思考......&lt;/span&gt;&lt;span&gt;
} &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(TRUE);
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;通过这种算法可以保证相邻的两个哲学家之间不会出现问题，但是一旦五个人同时拿起左边的筷子，都等待右边的筷子，将会出现死锁&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有几种解决思路&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;19&quot;&gt;
&lt;p&gt;&lt;span&gt;(1)至多只允许有四位哲学家同时去拿左边的筷子&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以保证肯定会空余一根筷子，并且没拿起筷子的这个人的左手边的这一根，肯定是已经拿起左手边筷子的某一个人的右手边，所以肯定不会死锁&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(2)  仅当哲学家的左、右两只筷子均可用时，才允许他拿起筷子进餐。 也就是AND机制，将左右操作转化为“原子”&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;17&quot;&gt;
&lt;p&gt;&lt;span&gt;(3)  规定奇数号哲学家先拿他左边的筷子，然后再去拿右边的筷子，而偶数号哲学家则相反。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如上图所示，1抢1号筷子，2号和3号哲学家竞争3号筷子，4号和5号哲学家竞争5号筷子，所有人都是先竞争奇数，然后再去竞争偶数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这一条是为了所有的人都会先竞争奇数号筷子，那么也就是最多三个人抢到了奇数号筷子，有两个人第一步奇数号筷子都没抢到的这一轮就相当于出局了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;三个人，还有两个偶数号筷子，必然会有一个人抢得到&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;AND型信号量&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;哲学家进餐需要左手和右手的筷子，所以可以将左右手筷子的获取操作原子化，借助于AND型信号量&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;10.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义五个信号量
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;为简单起见，假定数组起始下标为1
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;信号量全部初始化为1&lt;/span&gt;&lt;span&gt;
semaphore chopstick[&lt;/span&gt;5]={1,1,1,1,1&lt;span&gt;};

&lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;按照我们上面图中所示，第 i号哲学家，左手边为i号筷子，右手边是 (i+1)%5&lt;/span&gt;&lt;span&gt;
Swait(chopstick[i],chopstick[(i&lt;/span&gt;+1)%5&lt;span&gt;]))
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 进餐......&lt;/span&gt;&lt;span&gt;
Ssignal(chopstick[i],chopstick[(i&lt;/span&gt;+1)%5&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 思考......&lt;/span&gt;&lt;span&gt;
} &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt;(TRUE);
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;h3&gt;&lt;span&gt;读者写者问题&lt;/span&gt;&lt;/h3&gt;
&lt;div readability=&quot;18&quot;&gt;
&lt;hr noshade=&quot;noshade&quot;/&gt;&lt;p&gt;&lt;span&gt;一个数据文件或记录，可被多个进程共享，我们把只要求读该文件的进程称为“Reader进程” ，其他进程则称为“Writer 进程” 。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;允许多个进程同时读一个共享对象，因为读操作不会使数据文件混乱。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但不允许一个Writer 进程和其他Reader 进程或 Writer 进程同时访问共享对象，因为这种访问将会引起混乱。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所谓“读者—写者问题(Reader-Writer  Problem)”是指保证一个 Writer 进程必须与其他进程互斥地访问共享对象的同步问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;读者—写者问题常被用来测试新同步原语。 &lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span&gt;很显然，只有多个读者时不冲突&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190203140652923-394197183.png&quot;&gt;&lt;img title=&quot;image_5c568495_6e&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190203140653279-1137755174.png&quot; alt=&quot;image_5c568495_6e&quot; width=&quot;532&quot; height=&quot;122&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;

&lt;h4&gt;&lt;span&gt;记录型信号量机制&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;读和写之间是互斥的，所以需要一个信号量用于读写互斥Wmutex&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;另外如果有读的进程存在，另外的进程如果想要读的话，不需要同步也就是Wait(Wmutex)操作；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果当前没有进程在读，那么需要Wait(Wmutex)操作，所以设置一个变量记录写者个数Readcount，可以用来判断是否需要同步&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;另外Readcount 会被多个读者进程访问，所以也是临界资源，所以设置一个rmutex 用于互斥访问Readcount&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;两个信号量，一个用于读者互斥 readcount ，一个用于读写互斥&lt;/span&gt;&lt;span&gt;
semaphore rmutex&lt;/span&gt;=l,wmutex=1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; readcount=0;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始时读者个数为0
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;读者&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; reader() {
&lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;{
wait(rmutex);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;读者先获取 readcount&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt;(readcount==0){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果一个读者没有，第一个读者需要与写者互斥访问&lt;/span&gt;&lt;span&gt;
wait(wmutex);
}
readcount&lt;/span&gt;++;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;读者个数+1&lt;/span&gt;&lt;span&gt;
signal(rmutex);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;读者个数+1后，可以释放readcount的锁，其他读者可以进来
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开始慢慢读书......&lt;/span&gt;&lt;span&gt;
wait(rmutex);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;读者结束时，需要获取readcount的锁&lt;/span&gt;&lt;span&gt;
readcount&lt;/span&gt;--;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;退出一个读者&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; (readcount==0) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果此时一个读者都没有了，还需要释放与读写互斥的锁&lt;/span&gt;&lt;span&gt;
signal(wmutex);
}
signal(rmutex);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;释放readcount的锁&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt;(TRUE);
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; writer(){
&lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;{
wait(wmutex);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;写者必须获得wmutex
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行写任务....&lt;/span&gt;&lt;span&gt;
signal(wmutex);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;写任务结束后就可以释放锁&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt;(TRUE);

}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;主程序&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main() {
reader();
writer();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;写者相对比较简单，获得锁wmutex之后，进行写操作，否则等待wmutex&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;读者也是需要先获得锁，读操作后释放锁，但是因为多个读者之间互不影响，所以使用readcount记录读者个数，只有第一个读者才需要竞争wmutex，只有最后一个读者才需要释放wmutex&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;readcount作为读者之间的竞争资源，所以对readcount进行操作的时候也需要进行加锁&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;信号量集机制&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;将读者写者的问题复杂化一点，&lt;span&gt;它增加了一个限制，即最多只允许 N个读&lt;/span&gt;&lt;span&gt;者同时读。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在上面的解决方法中，可以不使用rmutex控制对readcount的互斥，可以构造一个读者个数的信号量readcountmutex，初始值设置为N&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;每次新增一个读者时，wait(readcountmutex)，一个读者离开时signal(readcountmutex)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也可以使用信号量集机制&lt;/span&gt;&lt;/p&gt;

&lt;div readability=&quot;13&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; N;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最大的读者个数，也就是相当于图书馆的空位子，初始时空位子为N&lt;/span&gt;
&lt;span&gt;
semaphore L&lt;/span&gt;=N, mx=1;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义两个信号量资源L和mx，分别用于控制读者个数限制和读写（写写)&lt;/span&gt;

&lt;span&gt;void&lt;/span&gt;&lt;span&gt; reader() {

&lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;{

Swait(L, &lt;/span&gt;1, 1);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取空位子L，每次获取1个，&amp;gt;=1时可分配&lt;/span&gt;
&lt;span&gt;
Swait(mx, &lt;/span&gt;1, 0);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取与写的互斥量mx，每次获取0个，&amp;gt;=1时可分配，如果mx为1，也就是没有写者，读者都可以进来，否则一个都进不来

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;进行一些读操作&lt;/span&gt;
&lt;span&gt;
Ssignal(L, &lt;/span&gt;1);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;释放一个单位的资源L&lt;/span&gt;
&lt;span&gt;
}&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt;(TRUE);

}
 

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; writer() {

&lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;{

Swait(mx,&lt;/span&gt;1,1; L,N,0);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获得资源mx，每次获取1个，&amp;gt;=1时分配，获得资源L，每次获得0个，&amp;gt;=N时即可分配

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;进行一些写操作&lt;/span&gt;
&lt;span&gt;
Ssignal(mx, &lt;/span&gt;1);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;释放资源mx&lt;/span&gt;
&lt;span&gt;
}&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt;(TRUE);

}


&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(){

reader();

writer();

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;Swait(L, 1, 1);用于获取读者空位子没什么好说的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Swait(mx, 1, 0);作为开关，只要mx满足条件&amp;gt;=1，那么就可以无限制的进入（此例中有L的限制），一旦条件不满足，则全都不能进入，满足多读者，有写不能读的情况&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于写者中的Swait(mx,1,1; L,N,0);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;他会获取mx，&amp;gt;=1时，获取一个资源，并且当L&amp;gt;=N时，分配0个L资源，也就是说一个读者都没有的时候才行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Swait(mx, 1, 0); 与Swait( L,N,0);都是需求0个，相当于开关判断&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;以上为借助“进程同步的API”，信号量，管程等方式完成进程同步的经典示例，例子来源于《计算机操作系统》&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;说白了，就是用 wait(S)   Swait(S)   signal(S)   Ssignal(S)等这些“方法”描述进程同步算法&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;可能会觉得这些内容乱七八糟的，根本没办法使用，的确这些内容全都没办法直接转变为代码写到你的项目中&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是，这些都是解决问题的思路&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不管是信号量还是管程还是什么，不会需要你从头开始实现一个信号量，然后.......也不需要你从头开始实现一个管程，然后......&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不管是操作系统层面，还是编程语言层面，还是具体的API，万变不离其宗&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;尽管这些wait和signal的确不存在，但是，但是，但是编程语言中很可能已经提供了语意相同的方法供你调用了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也就是说，你只需要理解同步的思路即可，尽管没有我们此处说的wait（S）,但是肯定有对应物。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 06 Feb 2019 11:03:00 +0000</pubDate>
<dc:creator>noteless</dc:creator>
<og:description>以上同步示例，是借助于前文提到的进程同步机制与工具的一个简单的应用，前文中的信号量机制管程机制等就是同步工具，本文的实例就是“”“同步工具”这些方法的一个调用而已，希望借助于几个简单的示例能够对线程同</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/noteless/p/10350296.html</dc:identifier>
</item>
<item>
<title>Netty学习问题总结 - 陈芳志</title>
<link>http://www.cnblogs.com/chenfangzhi/p/10353920.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenfangzhi/p/10353920.html</guid>
<description>&lt;p&gt;本篇记录了Netty学习过程中想到的问题和自己的一些思考，对于应用层的协议也有了更好的理解，所以在此做一个记录。&lt;/p&gt;
&lt;h3 id=&quot;一http协议分包&quot;&gt;一、HTTP协议分包&lt;/h3&gt;
&lt;p&gt;TCP是作为面来流的协议，所以需要应用层协议自己去分包。常见的分包格式如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;定长： 比如100字节每个报文，不足的前面补0，这时候每次取消息就取到100字节算整包)&lt;/li&gt;
&lt;li&gt;分隔符： 换行符其实是一种特别的分隔符，每次读取到分隔符就知道一个包读取完毕)&lt;/li&gt;
&lt;li&gt;指明长度： 比如前两个字节为长度字段，先读取两个字节，知道了需要多少字节，读取到对应的字节就是一个整包了&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;然而HTTP协议格式并不是上面的简单的一种，它结合了2和3两种来进行分包，因为请求和响应报文格式一样，所以这里针对请求报文进行说明。我们知道HTTP分为请求行，请求头，请求体。&lt;br/&gt;下面是报文说明摘自&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;HTTP RFC文档&lt;/a&gt;中4.1 Message Types：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HTTP报文格式&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    generic-message = start-line
                      *(message-header CRLF)
                      CRLF
                      [ message-body ]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.jiangmiantex.com/http%E6%8A%A5%E6%96%87.png&quot; alt=&quot;HTTP报文格式&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;报文读取过程&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;读取请求行：每个HTTP请求的第一行作为请求行，所以知道读取到CRLF就说明结束了&lt;/li&gt;
&lt;li&gt;读取请求头：请求头有多行，行数不是固定的，他的结尾是根据连续的两个CRLF来判断的，在message-body之前会有一个CRLF&lt;/li&gt;
&lt;li&gt;读取请求体：对于POST等带有请求体的方法来说，请求体的长度是不固定的，这时候请求头中会有个Content-Length字段说明了请求体的长度，所以只要读取完Content-Length个字节，整个HTTP请求报文也就得到了&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;关于报文分割一点备注&lt;/strong&gt;：早期的HTTP 1.0时代，因为它每次请求都会经历tcp的三次握手连接过程，所以它是通过连接的关闭来判断报文已经读取完毕，但是这里还有一个问题，如果这个连接关闭时因为服务端的错误引起的那客户端就无法区分了。到了HTTP 1.1，因为很多请求会重用一个连接，所以需要用到Content-Length这个字段来做分包。另外还有一种不需要Content-Length的方法就是请求头中Transfer-Encoding为chunked，这是一种分块传输，在压缩传输，动态内容生成等响应在一开始长度未知的场景下很有用。他的报文分割也很简单，详情参见：&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%88%86%E5%9D%97%E4%BC%A0%E8%BE%93%E7%BC%96%E7%A0%81&quot;&gt;分块传输编码&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;二websocket协议分包&quot;&gt;二、WebSocket协议分包&lt;/h2&gt;
&lt;p&gt;理解了HTTP协议的分包，WebSocket的协议也容易理解，道理都是想通的。一开始在谷歌的时候一直搜索不到相关的报文，最后搜索WebSocket数据帧才搜到了结果(搜索是门技巧啊)。我最关注的是opcode字段，因为在用WebSocket的时候就用到了这个字段来判断是什么帧类型。第二是Payload len字段，这是一个变长字段，为了节省字节数，含义如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如果数据长度小于等于125的话，那么该7位用来表示实际数据长度。&lt;/li&gt;
&lt;li&gt;如果数据长度为126到65535(2的16次方)之间，该7位值固定为126，也就是 1111110，往后扩展2个字节(16为，第三个区块表示)，用于存储数据的实际长度。&lt;/li&gt;
&lt;li&gt;如果数据长度大于65535， 该7位的值固定为127，也就是 1111111 ，往后扩展8个字节(64位)，用于存储数据实际长度。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;摘录自：&lt;a href=&quot;https://www.cnblogs.com/tugenhua0707/p/8542890.html%EF%BC%8C%E5%85%B7%E4%BD%93%E5%85%B3%E4%BA%8EWebSocket%E5%8F%AF%E4%BB%A5%E6%9F%A5%E9%98%85%E8%B5%84%E6%96%99%EF%BC%8C%E6%9C%89%E9%9D%9E%E5%B8%B8%E5%A4%9A%E7%9A%84%E8%AE%B2%E8%A7%A3&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/tugenhua0707/p/8542890.html，具体关于WebSocket可以查阅资料，有非常多的讲解&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc6455#section-5.2&quot;&gt;WebSocket RFC&lt;/a&gt;中websocket报文格式&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-------+-+-------------+-------------------------------+
     |F|R|R|R| opcode|M| Payload len |    Extended payload length    |
     |I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |
     |N|V|V|V|       |S|             |   (if payload len==126/127)   |
     | |1|2|3|       |K|             |                               |
     +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
     |     Extended payload length continued, if payload len == 127  |
     + - - - - - - - - - - - - - - - +-------------------------------+
     |                               |Masking-key, if MASK set to 1  |
     +-------------------------------+-------------------------------+
     | Masking-key (continued)       |          Payload Data         |
     +-------------------------------- - - - - - - - - - - - - - - - +
     :                     Payload Data continued ...                :
     + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
     |                     Payload Data continued ...                |
     +---------------------------------------------------------------+&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;三http和websocket协议共用一个端口的问题&quot;&gt;三、HTTP和WebSocket协议共用一个端口的问题&lt;/h2&gt;
&lt;p&gt;之前对这个现象十分不理解，很多Web服务器例如Tomcat都支持HTTP和WebSocket共用一个端口，他是怎么做到的？&lt;/p&gt;
&lt;p&gt;其实理解了报文的解析就很容易理解了，HTTP和WebSocket协议的下层都是TCP连接，他们是应用层连接，所以在处理TCP的字节流时，可以先获取几个字节，如果前几个字节解析出来是GET，POST等HTTP协议的用到的，那么就根据HTTP报文的分包规则获取一个HTTP报文然后流转到后端处理。如果是WebSocket协议就根据WebSocket报文来解析然后做响应的处理。&lt;/p&gt;
&lt;p&gt;补充：很多的协议栈都是以魔数打头，这样就更容易实现同端口多协议的支持，如Dubbo协议栈前两个字节是魔数，只需要判断报文的前两个字节就知道是不是Dubbo协议了，Dubbo协议栈头报文如下图(摘抄自http://ifeve.com/dubbo-protocol/)：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.jiangmiantex.com/Dubbo%E5%8D%8F%E8%AE%AE%E6%A0%88.png&quot; alt=&quot;Dubbo协议栈&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;四time-wait状态占用了什么资源&quot;&gt;四、TIME WAIT状态占用了什么资源&lt;/h2&gt;
&lt;p&gt;我们知道TCP四次挥手时主动发起方会经历一个TIME WAIT状态，也正是因为这个原因我们尽量让客户端主动关闭连接。对于这个状态有人说是占用了文件描述符，有人说是端口，那么究竟是占用了什么资源？&lt;/p&gt;
&lt;p&gt;根据我自己的实验，Windows系统下，TIME WAIT状态占用了端口，该端口不能作为客户端端口使用，但仍然可以作为服务端端口使用。实验端口：服务端8080，客户端6060 。情况如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;客户端主动关闭，客户端重启时报BindException，服务端用6060端口仍可正常启动&lt;/li&gt;
&lt;li&gt;服务端主动关闭，服务端重启正常，客户端重启也正常，但是如果停掉服务端8080，客户端用6060报BindException&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;实验代码如下，可根据需要自己修改试验：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;服务端主动关闭&lt;/strong&gt;：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ServerSocketCloseTest {
    public static void main(String[] args) throws IOException, InterruptedException {
        Runnable runnable = () -&amp;gt; {
            try {
                ServerSocket serverSocket = null;
                serverSocket = new ServerSocket(8080, 10);
                while (true) {
                    Socket accept = serverSocket.accept();
                    accept.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        };
        new Thread(runnable).start();
        Socket socket = new Socket(InetAddress.getLocalHost(), 8080, InetAddress.getLocalHost(), 6060);
        Thread.sleep(1000);
        socket.close();
        System.in.read();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;客户端主动关闭场景&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ClientSocketCloseTest {

    public static void main(String[] args) throws IOException, InterruptedException {
        Runnable runnable = () -&amp;gt; {
            try {
                ServerSocket serverSocket = new ServerSocket(8080, 10);
                while (true) {
                    Socket accept = serverSocket.accept();
                    Thread.sleep(1000);
                    accept.close();
                }
            } catch (IOException | InterruptedException e) {
                e.printStackTrace();
            }
        };
        new Thread(runnable).start();

        Socket socket = new Socket(InetAddress.getLocalHost(), 8080, InetAddress.getLocalHost(), 6060);
        socket.close();
        Thread.sleep(1000);
        System.in.read();
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结论：处于TIME WAIT状态下的端口不能作为客户端端口使用。对于服务端端口没有影响，服务端是仍然是可以正常绑定，接收到客户端连接后本地端口和监听端口是同一个所以不存在端口占用。另外通过查阅资料，TIME WAIT是释放了文件描述符，但是TCP连接的五元组并未释放，还占用一定的内存。参考地址如下：&lt;a href=&quot;https://stackoverflow.com/questions/1803566/what-is-the-cost-of-many-time-wait-on-the-server-side/1806033#1806033&quot; class=&quot;uri&quot;&gt;https://stackoverflow.com/questions/1803566/what-is-the-cost-of-many-time-wait-on-the-server-side/1806033#1806033&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;五关于&quot;&gt;五、关于&lt;/h2&gt;
&lt;p&gt;待补充&lt;/p&gt;
</description>
<pubDate>Wed, 06 Feb 2019 10:42:00 +0000</pubDate>
<dc:creator>陈芳志</dc:creator>
<og:description>[TOC] 本篇记录了Netty学习过程中想到的问题和自己的一些思考，对于应用层的协议也有了更好的理解，所以在此做一个记录。 一、HTTP协议分包 TCP是作为面来流的协议，所以需要应用层协议自己去分</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenfangzhi/p/10353920.html</dc:identifier>
</item>
<item>
<title>最小生成树算法 - 风沙迷了眼</title>
<link>http://www.cnblogs.com/fsmly/p/10215179.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fsmly/p/10215179.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;最小生成树的形成&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;　　(1)一个贪心策略设计如下&lt;br/&gt;       每个时刻生长最小生成树的一条边，并在整个策略的实施过程中，遵守下述循环不变式的边集合A：&lt;br/&gt;          &lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190103133912079-926071865.png&quot; alt=&quot;&quot; width=&quot;327&quot; height=&quot;29&quot;/&gt;&lt;br/&gt;　　每一步，选择一条边(u,v)加入集合A，使得A不违反循环不变式。&lt;br/&gt;　　这样的边使得我们可以“安全地”将之加入到集合A而不会破坏A的循环不变式，因此称之为集合A的“安全边”。&lt;br/&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190103133948335-1995435439.png&quot; alt=&quot;&quot; width=&quot;252&quot; height=&quot;102&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　(2)使用的循环不变式方式如下：&lt;br/&gt;　　初始化：集合A直接满足循环不变式。&lt;br/&gt;　　保持：算法的循环通过只加入安全边来维持循环不变式。&lt;br/&gt;　　终止：所有加入到集合A中的边都属于某棵最小生成树，因此，算法第5行所返回的集合A必然是一棵最小生成树。&lt;br/&gt;　　说明：循环不变式告诉了我们存在一棵生成树，满足&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190103134144131-1151829200.png&quot; alt=&quot;&quot; width=&quot;31&quot; height=&quot;15&quot;/&gt;。在进入while循环时，A是T的真子集，因此必然存在一条边&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190103134203635-1915183471.png&quot; alt=&quot;&quot; width=&quot;50&quot; height=&quot;17&quot;/&gt;，使得&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190103134229187-1193655311.png&quot; alt=&quot;&quot; width=&quot;61&quot; height=&quot;19&quot;/&gt;，并且(u,v)对于集合A是安全的。&lt;br/&gt;　　(3)定义一些概念&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190103134420057-1462785353.png&quot; alt=&quot;&quot; width=&quot;359&quot; height=&quot;120&quot;/&gt;&lt;br/&gt;　　切割：无向图G=(V,E)的一个切割(S,V-S)是集合V的一个划分。&lt;/p&gt;
&lt;p&gt;　　横跨切割：如果一条边(u,v)∈E的一个端点在集合S中，另一个端点在集合V-S中，则称该条边横跨切割(S,V-S)。&lt;/p&gt;
&lt;p&gt;　　尊重集合：如果集合A中不存在横跨该切割的边，则称该切割尊重集合A。&lt;/p&gt;
&lt;p&gt;　　轻量级边：在横跨一个切割的所有边中，权重最小的边称为轻量级边&lt;/p&gt;
&lt;p&gt;　　(4)距离说明上述概念&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190103134930800-250892019.png&quot; alt=&quot;&quot; width=&quot;598&quot; height=&quot;277&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　图(a)中所示的黑色结点位于集合S中，白色结点位于V-S中。横跨该切割的边是那些连接白色结点和黑色结点的边。如&amp;lt;a,h&amp;gt;&amp;lt;b,c&amp;gt;&amp;lt;c,d&amp;gt;等等，其中&amp;lt;d,c&amp;gt;是轻量级边。若定义加了阴影的边属于集合A，那么可以看出集合A中没有横跨切割的边，所以切割&amp;lt;S,V-S&amp;gt;尊重集合A。&lt;/p&gt;
&lt;p&gt;　　图(b)中是同样一个图，只是换了视角。&lt;/p&gt;
&lt;p&gt;　　(5)辨认安全边的规则&lt;/p&gt;
&lt;p&gt;　　设G=(V,E)是一个在边E上定义了实数值权重函数ω的连通无向图。设集合A为E的一个子集，且A包含在图G的某棵最小生成树中，设(S,V-S)是图G中尊重集合A的任意一个切割，&lt;/p&gt;
&lt;p&gt;又设(u,v)是横跨切割(S,V-S)的一条轻量级边。那么边(u,v)对于集合A是安全的。&lt;/p&gt;
&lt;p&gt;　　证明：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190103142152388-52881631.png&quot; alt=&quot;&quot; width=&quot;257&quot; height=&quot;289&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　我们现在构建一个最小生成树T ′，通过将A∪{(u,v)}包括在树T '中，从而证明(u,v)对集合A来说是安全的。T中包含有G的所有结点，所以(u,v)与T中从结点u到结点v的简单路径p形成一个环。如上图所示。由于结点u，v分别处于切割S，V-S中，T中至少含有一条简单路径p并且横跨该切割。假设(x,y)是这样一条边。由于切割(S,V-S)尊重集合A，所以(x,y)不在集合A中。又因为（x，y）位于T中从u到v的唯一一条简单路径上，将这条边删除会导致T被分为两个连通分量，这时候，将（u，v）加入就能将这两个连通分量连接起来成为一颗心得生成树&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190103142930698-507209905.png&quot; alt=&quot;&quot; width=&quot;189&quot; height=&quot;19&quot;/&gt;。&lt;/p&gt;
&lt;p&gt;　　这时候我们来证明T ′是一颗最小生成树。&lt;/p&gt;
&lt;p&gt;　　由于（u，v）是横跨切割的一条轻量级边，并且边（x，y）也横跨该切割，所以我们有ω(u,v)≤ ω(x,y)，所以可以简单得出这样一个关系&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190103143200451-1945645408.png&quot; alt=&quot;&quot; width=&quot;410&quot; height=&quot;63&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　又因为T是一颗最小生成树，ω(T) ≤ ω(T ')，因此T ′也是一颗最小生成树。&lt;/p&gt;
&lt;p&gt;　　因为 A∈T，且 （x，y）∉A，所以A∈T ' 。因此&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190103143546401-371147985.png&quot; alt=&quot;&quot; width=&quot;144&quot; height=&quot;28&quot;/&gt;。由于T ' 是最小生成树，(u,v)对于集合A而言是安全的。&lt;/p&gt;
&lt;p&gt;　　在算法GENERIC-MST推进的过程中，集合A始终保持无环状态( 每条边都是安全的 )。算法执行的任意时刻，图G A =(V,A)是一个森林。&lt;/p&gt;
&lt;p&gt;　　while循环执行|V|-1次，每次找出构造最小生成树所需的一条边。每遍循环将树的数量减少1。当整个森林只含有一棵树时，算法终止。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Kruskal算法&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;　　Kruskal和Prim算法是求解最小生成树的两个经典算法。它们都是GENERIC-MST算法的具体细化：&lt;/p&gt;
&lt;p&gt;　　(1)Kruskal算法找安全边的方法：在所有连接森林中两棵不同树的边中，找权重最小的边(u,v)。设C 1 和C 2 为边(u,v)所连接的两棵树。边(u,v)是C 1 的一条安全边。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190103144819806-389369819.png&quot; alt=&quot;&quot; width=&quot;416&quot; height=&quot;169&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　(2)简单讲述一下Kruskal算法的工作过程。算法的1~3行将集合A初始化为一个空集，并创建|V|棵树，每棵树仅包含一个结点，作为初始情况。5~8行中的for循环按照权重从低到高的次序对每一条边逐一进行检查。&lt;span&gt;&lt;span&gt;对于每条边(u,v)而言，循环将检查该结点u和结点v是否属于同一棵树。如果是，这条边不能加入，避免形成环路。&lt;/span&gt;&lt;span&gt;如果不是，则两个端点分别属于不同的树，算法第7行将吧这些边加入到集合A中，第8行将两棵树进行合并。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　(3)下面给出一个具体的例子看看算法的流程&lt;/p&gt;
&lt;p&gt;　　①首先找到最小权重的边为&amp;lt;h,g&amp;gt; = 1&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190103144915742-220307267.png&quot; alt=&quot;&quot; width=&quot;337&quot; height=&quot;133&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　②继续寻找下一条权重次小的边，以此类推&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190103145018807-406781822.png&quot; alt=&quot;&quot; width=&quot;312&quot; height=&quot;116&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190103145143228-1590169951.png&quot; alt=&quot;&quot; width=&quot;273&quot; height=&quot;111&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190103145201951-1395110415.png&quot; alt=&quot;&quot; width=&quot;282&quot; height=&quot;108&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190103145258641-21317444.png&quot; alt=&quot;&quot; width=&quot;289&quot; height=&quot;116&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190103145221932-1549367411.png&quot; alt=&quot;&quot; width=&quot;277&quot; height=&quot;111&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　③注意到，(f)图中此时权重为6的边的两个端点i和g都属于同一棵树(&amp;lt;i,c,f,g,h&amp;gt;)中，所以不能加这条边加入，否则会形成环路&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190103145345603-921927779.png&quot; alt=&quot;&quot; width=&quot;275&quot; height=&quot;106&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190103145539249-2013648672.png&quot; alt=&quot;&quot; width=&quot;262&quot; height=&quot;110&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　④同③一样，（h）图中的权重为7的边不同加入集合中，避免形成环路(&amp;lt;i,c,f,g,h&amp;gt;)&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190103145556067-1239868670.png&quot; alt=&quot;&quot; width=&quot;261&quot; height=&quot;103&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190103145723404-258509018.png&quot; alt=&quot;&quot; width=&quot;252&quot; height=&quot;107&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　⑤同④一样，（j）图中的权重为8的边不同加入集合中，避免形成环路(&amp;lt;a,b,d,c,f,g,h&amp;gt;)&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190103145752127-2117858419.png&quot; alt=&quot;&quot; width=&quot;298&quot; height=&quot;121&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190103145914049-500546443.png&quot; alt=&quot;&quot; width=&quot;289&quot; height=&quot;111&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　⑥同理，&amp;lt;e,f&amp;gt;边如果加入集合中，会形成环路&amp;lt;c,d,e,f&amp;gt;；&amp;lt;b,h&amp;gt;不能加入集合中，会形成&amp;lt;a,b,h&amp;gt;环路；&amp;lt;d,f&amp;gt;不能加入集合中，会形成&amp;lt;c,f,d&amp;gt;环路&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190103145941338-964950079.png&quot; alt=&quot;&quot; width=&quot;305&quot; height=&quot;117&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190103150049803-805039336.png&quot; alt=&quot;&quot; width=&quot;292&quot; height=&quot;119&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190103150104062-1733737950.png&quot; alt=&quot;&quot; width=&quot;300&quot; height=&quot;118&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Prim算法&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　(1)Prim算法的每一步是在连接集合A和A之外的结点的所有边中，选择一条轻量级边加入到A中。所加入的边对于A也是安全的。Prim算法的基本性质：集合A中的边总是构成一棵树。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190103153832171-878557558.png&quot; alt=&quot;&quot; width=&quot;291&quot; height=&quot;237&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 　　(2)简单描述一下上述算法的流程。1~5行将每个节点的key值设置为∞（除根节点r以外，根节点key值置为0，作为第一个被处理的点），然后将每个结点的父节点置为NIL，并对最小优先队列Q进行初始化，使其包含图中的所有节点。&lt;/p&gt;
&lt;p&gt;　　算法维持的循环不变式由3个部分组成：&lt;/p&gt;
&lt;p&gt;　　①A={(v,v.π):v∈V-{r}-Q}&lt;/p&gt;
&lt;p&gt;　　②已经加入到最小生成树中的结点集合为V-Q&lt;/p&gt;
&lt;p&gt;　　③对于所有结点v∈Q，如果v.π≠NIL，则v.key&amp;lt;∞并且v.key是连接结点v和最小生成树中某个节点的轻量级边(v,v.π)的权重&lt;/p&gt;
&lt;p&gt;　　第7行找出结点v∈Q，该结点是某条横跨切割&amp;lt;V-Q,Q&amp;gt;的轻量级边的一个端点，然后将结点u从队列中删除，并将其加入到集合V-Q中，也就是将边&amp;lt;u,u.π&amp;gt;加入到集合A中。8~11行的for循环将每个与u邻接但是不在树中的结点v的key和π属性进行更新，从而维持循环不变式。&lt;/p&gt;
&lt;p&gt;　　(3)简单看一个Prim算法的例子&lt;/p&gt;
&lt;p&gt;　　例子中，初始的根节点为a，加阴影的边和黑色结点属于树A。在算法的每一步，树中的结点就决定了图的一个切割，横跨该切割的一条轻量级边就被加入到树中。&lt;/p&gt;
&lt;p&gt;　　例如：在图(b)，轻量级边有两条，&amp;lt;b,c&amp;gt;,&amp;lt;a,h&amp;gt;的权重都为8，所以可以选择两条边中的一条加入到树中&lt;/p&gt;
&lt;p&gt;　　 &lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190103155648939-224056547.png&quot; alt=&quot;&quot; width=&quot;296&quot; height=&quot;123&quot;/&gt;　     　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190103155707097-1526409978.png&quot; alt=&quot;&quot; width=&quot;305&quot; height=&quot;122&quot;/&gt;　  &lt;/p&gt;
&lt;p&gt;　　 &lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190103155726918-1490970405.png&quot; alt=&quot;&quot; width=&quot;308&quot; height=&quot;114&quot;/&gt;　　   &lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190103155756829-652188952.png&quot; alt=&quot;&quot; width=&quot;321&quot; height=&quot;125&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　 &lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190103155814006-281716340.png&quot; alt=&quot;&quot; width=&quot;308&quot; height=&quot;118&quot;/&gt;　     　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190103160916320-577260934.png&quot; alt=&quot;&quot; width=&quot;319&quot; height=&quot;120&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　  &lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190103160939642-258718486.png&quot; alt=&quot;&quot; width=&quot;311&quot; height=&quot;121&quot;/&gt; 　   　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190103161001601-1726106858.png&quot; alt=&quot;&quot; width=&quot;308&quot; height=&quot;125&quot;/&gt;　  &lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190103161029202-1430189063.png&quot; alt=&quot;&quot; width=&quot;321&quot; height=&quot;136&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 06 Feb 2019 10:28:00 +0000</pubDate>
<dc:creator>风沙迷了眼</dc:creator>
<og:description>最小生成树的形成 (1)一个贪心策略设计如下 每个时刻生长最小生成树的一条边，并在整个策略的实施过程中，遵守下述循环不变式的边集合A： 每一步，选择一条边(u,v)加入集合A，使得A不违反循环不变式。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fsmly/p/10215179.html</dc:identifier>
</item>
<item>
<title>（原创）像极了爱情的详解排序二叉树，一秒get - compassion‘s</title>
<link>http://www.cnblogs.com/yx1999/p/10352828.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yx1999/p/10352828.html</guid>
<description>&lt;p&gt;&lt;span&gt;二叉树我们已经非常熟悉了，但是除了寻常的储存数据、遍历结构，我们还能用二叉树做什么呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们都知道不同的遍历方式会对相同的树中产生不同的序列结果，排序二叉树就是利用二叉树的遍历特征实现的特殊树种，也叫二叉查找树。&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;排序二叉树从根结点起的每一个结点的左子树元素均小于其自身，右子树元素值均大于其自身&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;即任何结点的值均大于其左子树所有元素，均小于其右子树所有元素&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1598426/201902/1598426-20190205143804959-1841428011.png&quot; alt=&quot;&quot; width=&quot;359&quot; height=&quot;297&quot;/&gt;&lt;span&gt;就是一个排序二叉树，直观的一批，从子树到根结点，永远符合左小右大的规则（中序遍历）&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;Ⅰ、结构定义&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;排序二叉树的定义与一般二叉树无异&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; BiTree{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; item;
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; BiTree *lchild,*&lt;span&gt;rchild;
}BiTree;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;Ⅱ、排序二叉树的查找&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;我们先来看一下排序二叉树的查找实现，因为插入在排序二叉树中是实现后续建立、删除结点的基础，因为结点带有顺序，故而遍历条件有所改变，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; searchnode(BiTree *t, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; key)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;t)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(t-&amp;gt;item ==&lt;span&gt; key)
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(t-&amp;gt;item &amp;gt;&lt;span&gt; key)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; searchnode(t-&amp;gt;&lt;span&gt;lchild,key);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(t-&amp;gt;item &amp;lt;&lt;span&gt; key)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; searchnode(t-&amp;gt;&lt;span&gt;rchild,key);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;清爽递归，不解释&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;Ⅲ、二叉排序树的插入&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; insertbitree(BiTree **t, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; value)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!searchnode(*&lt;span&gt;t,value))
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(*t ==&lt;span&gt; NULL)
        {
            &lt;/span&gt;*t = (BiTree *)&lt;span&gt;malloc&lt;/span&gt;(&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(BiTree));
            (&lt;/span&gt;*t)-&amp;gt;item =&lt;span&gt; value;
            (&lt;/span&gt;*t)-&amp;gt;lchild =&lt;span&gt; NULL;
            (&lt;/span&gt;*t)-&amp;gt;rchild =&lt;span&gt; NULL;
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;((*t)-&amp;gt;item &amp;gt;&lt;span&gt; value)
                insertbitree(&lt;/span&gt;&amp;amp;((*t)-&amp;gt;&lt;span&gt;lchild), value);
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                insertbitree(&lt;/span&gt;&amp;amp;((*t)-&amp;gt;&lt;span&gt;rchild), value);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这个插入上来先判断一哈我们现有的树里面有没有这个元素，如果有就不会进入循环，至于插入操作的框架也基本符合中序遍历的操作，只是加上了判断大小&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;Ⅳ、二叉排序树删除结点（HARD）&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;轻松愉快的建立、查找排序二叉树的操作完成之后，我们来看看比较困难的删除排序二叉树结点的操作。为什么说它困难呢，相比插入或者查找，删除面对的是一个已经成型的树，我们不仅要考虑怎样去掉这个结点，还要想到按照中序以及数字大小将原有结点按序放到正确位置。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;好的，我们先来考虑一下我们可能删除哪几种结点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一类：待删除结点只有左子树，没有右子树，可以想见，这种情况下只需要把后续的左子树接到待删除结点的上一个结点上，再释放待删除结点的空间就OK&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二类：带删除结点只有右子树，没有左子树，跟第一类一个道理，这样的操作只需要三行就解决，但是棘手的问题总在短暂的轻松过后&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第三类：这一类情况就是大魔王辽，左右孩子一个不缺，手心手背都是肉，哪个也不能少，怎么解决这个问题呢？让我们来看一个例子。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1598426/201902/1598426-20190206153735905-1491752970.png&quot; alt=&quot;&quot;/&gt;&lt;span&gt;看这个丑不拉叽的排序二叉树，非常体现中序遍历特点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在我们要删除 34 这个结点，就是我们刚才说的那种第三类情况，左右均有结点，这个时候，我们有这两种方法阔以达成目的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1598426/201902/1598426-20190206154000732-124477.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一种：姑且叫他 牺牲前驱法 ，我们要去掉 34 ，就要把他的前驱拿来顶替这个位置，保持二叉排序树的序，然后当然要检测一下，如果牺牲的这个前驱点（在我们这里是 33 ）有子树，还需要把子树和上一级连上（如32），这是第一种方法&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;用直接前驱 33 替换 34 &lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;删除原有的 33 结点&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;把结点 32 ，移到原 33 位置&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;第二种：相信你也猜到了，牺牲后继法，反正兄弟两个要挑一个顶上去，让我们看一哈在这个例子中，怎么个牺牲后继&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1598426/201902/1598426-20190206154708352-1959386085.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 35 已经被我们放上来辽 &lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;用直接后继 35 替换 34&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;删除结点 35 &lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;因为这里的 35 茕茕孑立，没儿没女，所以这个例子的这里不需要连接子树，但是千万注意不要认为所有的替换后继法都不用管子树&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;好的，方法讲明白了辽，我们代码实现一哈&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; Delete(BiTree **&lt;span&gt;t)
{
    BiTree &lt;/span&gt;*s,*&lt;span&gt;q;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;((*t) -&amp;gt; lchild ==&lt;span&gt; NULL)//左子树空的情况
    {
        q &lt;/span&gt;= *&lt;span&gt;t;
        &lt;/span&gt;*t = (*t)-&amp;gt;&lt;span&gt;lchild;
        &lt;/span&gt;&lt;span&gt;free&lt;/span&gt;&lt;span&gt;(q);
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;( (*t) -&amp;gt; rchild ==&lt;span&gt; NULL)//右子树为空的情况
    {
        q &lt;/span&gt;= *&lt;span&gt;t;
        &lt;/span&gt;*t = (*t)-&amp;gt;&lt;span&gt;rchild;
        &lt;/span&gt;&lt;span&gt;free&lt;/span&gt;&lt;span&gt;(q);
    }
    &lt;/span&gt;&lt;span&gt;else //左右子数均为空&lt;/span&gt;&lt;span&gt;
    {
        q &lt;/span&gt;= *&lt;span&gt;t;
        s &lt;/span&gt;= (*t)-&amp;gt;&lt;span&gt;lchild;
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(s-&amp;gt;&lt;span&gt;rchild)//循环找到直接前驱
        {
            q &lt;/span&gt;=&lt;span&gt; s;
            s &lt;/span&gt;= s-&amp;gt;&lt;span&gt;rchild;
        }
        (&lt;/span&gt;*t) -&amp;gt; item = s -&amp;gt;&lt;span&gt; item; //结点数据替换
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(q != *&lt;span&gt;t) //接原有左右子树
            q&lt;/span&gt;-&amp;gt;rchild = s-&amp;gt;&lt;span&gt;lchild;
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            q&lt;/span&gt;-&amp;gt;lchild = s-&amp;gt;&lt;span&gt;lchild;
        &lt;/span&gt;&lt;span&gt;free&lt;/span&gt;&lt;span&gt;(s);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; DeleteBST(BiTree **T, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; key)
{

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!*&lt;span&gt;T)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (key ==  (*T)-&amp;gt;&lt;span&gt;item)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Delete(T);
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (key &amp;lt; (*T)-&amp;gt;&lt;span&gt;item)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; DeleteBST(&amp;amp;(*T)-&amp;gt;&lt;span&gt;lchild, key);
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; DeleteBST(&amp;amp;(*T)-&amp;gt;&lt;span&gt;rchild, key);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;解读见注释&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;测试用主函数部分：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i;
    BiTree &lt;/span&gt;*t =&lt;span&gt; NULL;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; value[] = {&lt;span&gt;12&lt;/span&gt;,&lt;span&gt;24&lt;/span&gt;,&lt;span&gt;88&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;64&lt;/span&gt;,&lt;span&gt;99&lt;/span&gt;,&lt;span&gt;71&lt;/span&gt;,&lt;span&gt;64&lt;/span&gt;,&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;8&lt;/span&gt;&lt;span&gt;};
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;10&lt;/span&gt;; i++&lt;span&gt;)
        insertbitree(&lt;/span&gt;&amp;amp;&lt;span&gt;t,value[i]);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;建立序列为：\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    lar(t);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;删除结点88，结果为：\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    DeleteBST(&lt;/span&gt;&amp;amp;t,&lt;span&gt;88&lt;/span&gt;&lt;span&gt;);
    lar(t);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1598426/201902/1598426-20190206170505167-1869048482.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


</description>
<pubDate>Wed, 06 Feb 2019 09:08:00 +0000</pubDate>
<dc:creator>compassion‘s</dc:creator>
<og:description>数据结构 查找二叉树 排序二叉树</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yx1999/p/10352828.html</dc:identifier>
</item>
<item>
<title>【杂谈】一个回车下去，浏览器做了什么？ - 猫毛·波拿巴</title>
<link>http://www.cnblogs.com/longfurcat/p/10353786.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/longfurcat/p/10353786.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;　　在使用PostMan之前，自己测试Rest接口都是直接在浏览器地址栏输入URL来测试的，但是这种方法发出的请求都是Get，如果要发送POST请求只能用ajax等编程方式。有了PostMan就方便多了。某一天在输URL的时候，突然想看看浏览器到底做了什么，于是就有了下面这些内容。&lt;/p&gt;
&lt;h2&gt;概述&lt;/h2&gt;
&lt;p&gt;以下讲述的是一个请求静态网页文件的例子，该例子有以下几个过程：&lt;/p&gt;
&lt;p&gt;1.在浏览器地址栏输入一个URL，并回车&lt;/p&gt;
&lt;p&gt;2.浏览器利用DNS，找到域名对应的IP地址&lt;/p&gt;
&lt;p&gt;3.浏览器与服务端建立socket连接，如果已有则无需建立&lt;/p&gt;
&lt;p&gt;4.浏览器利用socket连接发送请求数据报&lt;/p&gt;
&lt;p&gt;5.服务端返回响应数据报&lt;/p&gt;
&lt;p&gt;6.浏览器渲染HTML&lt;/p&gt;
&lt;p&gt;7.如果HTML中含有其他文件的引用，如css，js文件，那么它还会重复步骤3~6&lt;/p&gt;
&lt;h2&gt;建立Socket&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;要与服务端建立socket连接，浏览器要知道哪些信息呢？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;服务器的IP地址&lt;/li&gt;
&lt;li&gt;应用程序占用端口。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;IP地址怎么获取？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先你输入要访问一个网站必然有域名，有了域名必然就能找到IP地址。域名与IP地址是多对一的关系。值得一提的是，域名到IP地址的映射不一定要用到DNS，如果本地hosts文件中有相关的映射，那就不必远程查询了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;地址栏就不能直接输IP地址吗？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;只要你记得住，当然可以输，还省去了解析域名的麻烦。域名的出现就是为了不用去记IP地址。例如，baidu.com 总比 xxx.xxx.xxx.xxx好记吧。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那端口呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;端口在URL中是直接跟在IP地址/域名后面，一般是这样：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
IP地址/域名:端口
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;比如tomcat项目就是，localost:8080/xxx&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那为什么很多网站访问的时候不需要输端口？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为默认不输入的话，会补上80端口。所以端口还是有的。&lt;/p&gt;
&lt;h2&gt;发送请求数据报&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;请求数据报包含哪些内容？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那就要说到数据报的结构了，HTTP请求报文分三部分，请求行（request line）、请求头（request headers）、请求实体（request body）。大概就是下面这样：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Method Uri Protocol/&lt;span&gt;version CLRF 

Header1:Value1 CLRF
Header2:Value2 CLRF
....
CLRF

Body&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这三大块用CLRF分隔（CLRF就是回车+换行，即&quot;\r\n&quot;）。&lt;/p&gt;
&lt;h2&gt;接收响应数据报&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;200、500等这些响应结果是怎么回事？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你能收到这些响应结果，至少网络是通的。需要明确一点的是，这些状态码是服务端写好，然后发给你的。请求正常就是200，请求参数导致服务程序出现异常就是500等等。这些状态码很多，有兴趣的可以去看Http协议说明。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;网页数据在哪里？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;网页文件的内容都放在响应报文的body中，浏览器会把网页内容渲染到页面上。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;提示下载文件是怎么回事？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这其实说的是响应报文对于body内容的处理方式，默认情况下是直接在网页上展示的。这主要由响应头中的Content-Disposition值决定，默认是&lt;span&gt;inline&lt;/span&gt;，也就是直接在网页上展示。如果是需要下载的话，那就是&lt;span&gt;attachement;filename=xxx.&lt;/span&gt;如果浏览器接收到这样的响应报文，会弹出下载提示框，让用户选择保存位置。&lt;/p&gt;
&lt;h2&gt;断开Socket连接&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;什么时候断开连接?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;实际上，Http协议到了1.1之后，默认维持的是长连接，也就是不会关闭。因为如果每个请求都建立新的连接的话，握手的开销不可小觑。现在基本上使用的都是1.1版本。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;怎么断开连接？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;socket连接只要双方任何一方关闭即可断开连接，所以可以是浏览器或服务端任意一方关闭连接。&lt;/p&gt;
&lt;p&gt;浏览器 =&amp;gt; 关闭浏览器应用 Or 提示服务端，让服务端关闭，具体方式为添加请求头Connect:close&lt;/p&gt;
&lt;p&gt;服务端 =&amp;gt; 编程调用close方法&lt;/p&gt;
</description>
<pubDate>Wed, 06 Feb 2019 08:51:00 +0000</pubDate>
<dc:creator>猫毛&amp;#183;波拿巴</dc:creator>
<og:description>前言 在使用PostMan之前，自己测试Rest接口都是直接在浏览器地址栏输入URL来测试的，但是这种方法发出的请求都是Get，如果要发送POST请求只能用ajax等编程方式。有了PostMan就方便</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/longfurcat/p/10353786.html</dc:identifier>
</item>
<item>
<title>mybatis缓存的设计 - JsonSun</title>
<link>http://www.cnblogs.com/marioS/p/10353468.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/marioS/p/10353468.html</guid>
<description>&lt;p&gt;继续用提问的方式来看Mybatis的缓存设计。&lt;/p&gt;
&lt;p&gt;1、Mybatis如何开启缓存&lt;/p&gt;
&lt;p&gt;Mybatis对查询结果进行缓存,所以缓存的对象为具体的Statement&lt;/p&gt;
&lt;p&gt;通过在Statement上是否使用缓存来启用。&lt;/p&gt;
&lt;pre&gt;
&amp;lt;select id=&quot;selectByPrimaryKey&quot; parameterType=&quot;java.lang.Long&quot; resultMap=&quot;BaseResultMap&quot;  fetchSize=&quot;5&quot; statementType=&quot;PREPARED&quot; &lt;strong&gt;useCache&lt;/strong&gt;=&quot;true&quot; &amp;gt;&lt;br/&gt;useCache默认值为true
&lt;/pre&gt;
&lt;p&gt;2、谁持有缓存？&lt;/p&gt;
&lt;p&gt; Mybatis中有两个对象持有缓存。&lt;/p&gt;
&lt;pre&gt;
CachingExecutor以及BaseExecutor&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1589170/201902/1589170-20190206073657266-1259619616.png&quot; alt=&quot;&quot; width=&quot;248&quot; height=&quot;163&quot;/&gt;   &lt;img src=&quot;https://img2018.cnblogs.com/blog/1589170/201902/1589170-20190206073831512-516331657.png&quot; alt=&quot;&quot; width=&quot;297&quot; height=&quot;162&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
CachingExecutor和SimpleExecutor的关系是持有的关系
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CachingExecutor &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Executor {

  &lt;/span&gt;&lt;strong&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; Executor delegate;
  &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; TransactionalCacheManager tcm = &lt;span&gt;new&lt;/span&gt; TransactionalCacheManager();
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1589170/201902/1589170-20190206074758075-1542678291.png&quot; alt=&quot;&quot; width=&quot;291&quot; height=&quot;222&quot;/&gt;&lt;/p&gt;

&lt;p&gt;3、缓存何时开启?&lt;/p&gt;
&lt;p&gt;　　当开启Mapper级别的缓存时，&lt;strong&gt;&lt;span&gt;缓存&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;被开启&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;strong&gt;&lt;span&gt;缓存&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;是一直开启的&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;4、缓存何时被命中?&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1589170/201902/1589170-20190206080732050-646216275.png&quot; alt=&quot;&quot; width=&quot;347&quot; height=&quot;321&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　 5、缓存清空的时机&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　①数据库发生变更(update,insert,delete),即使事物没有提交,&lt;span&gt;&lt;strong&gt;缓存&lt;span&gt;也&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;失效&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　②对于相同命名空间Mapper的缓存，多个线程，并发使用相同Mapper的不同语句，任意一个执行事物提交,可导致&lt;strong&gt;&lt;span&gt;缓存&lt;/span&gt;&lt;/strong&gt;失效&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　实际效果：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　&lt;strong&gt;&lt;span&gt;缓存&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;会和Mysql的rr隔离级别一致，不会导致幻读(read uncommited)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　&lt;strong&gt;&lt;span&gt;缓存&lt;/span&gt;&lt;/strong&gt; &lt;span&gt;&lt;span&gt;在不使用&lt;strong&gt;&lt;span&gt;缓存&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;的时候,有效&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　验证&lt;strong&gt;&lt;span&gt;缓存&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;         &lt;img src=&quot;https://img2018.cnblogs.com/blog/1589170/201902/1589170-20190206151115911-76611523.png&quot; alt=&quot;&quot; width=&quot;271&quot; height=&quot;344&quot;/&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　使用代码验证:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　两次查询,只访问了数据库1次.第二次不再请求数据库&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1589170/201902/1589170-20190206154642842-913855395.png&quot; alt=&quot;&quot; width=&quot;456&quot; height=&quot;203&quot;/&gt;　　&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　一次查询,一次更新(不提交),一次查询.缓存失效,出发了两次数据库查询。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;     &lt;img src=&quot;https://img2018.cnblogs.com/blog/1589170/201902/1589170-20190206155053250-1601469832.png&quot; alt=&quot;&quot; width=&quot;533&quot; height=&quot;262&quot;/&gt; &lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;缓存&lt;span&gt;的验证&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　不配置&lt;span&gt;缓存&lt;span&gt;时,验证不同的sqlSesiion缓存是否通用&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　触发2次数据库访问&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1589170/201902/1589170-20190206155705003-1680021886.png&quot; alt=&quot;&quot; width=&quot;666&quot; height=&quot;338&quot;/&gt;　　&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　配置缓存参数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;settings&amp;gt;
        &amp;lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&amp;gt;
    &amp;lt;/settings&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　 &lt;img src=&quot;https://img2018.cnblogs.com/blog/1589170/201902/1589170-20190206161745168-1202273120.png&quot; alt=&quot;&quot; width=&quot;405&quot; height=&quot;225&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　结果出乎意料,缓存竟然没有命中。分析下原因:&lt;/p&gt;
&lt;p&gt;　　 &lt;img src=&quot;https://img2018.cnblogs.com/blog/1589170/201902/1589170-20190206162326737-494769493.png&quot; alt=&quot;&quot; width=&quot;328&quot; height=&quot;176&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　即使打开了&lt;span&gt;缓存,&lt;span&gt;首先也是保存在事物级别的缓存里,TransactionalCache里.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　只有当实物提交时，才会真正将缓存转移到delegate中(delegate是真正的Mapper之间公用的缓存)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　调整代码,后缓存生效。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1589170/201902/1589170-20190206162618400-887014143.png&quot; alt=&quot;&quot; width=&quot;504&quot; height=&quot;274&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　让人不理解的，出于什么目的，要commit后,再共享？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　如果在某一秒，有10个并发共同访问数据库。那他们会同时产生10个连接，并不会命中。　　&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;6、Mybatis&lt;strong&gt;&lt;span&gt;缓存&lt;/span&gt;&lt;/strong&gt;设计的目的&lt;/p&gt;
&lt;p&gt;　　简单,不配置也可以使用。用与在一个sqlSession中多次使用相同条件多次查询。&lt;/p&gt;
&lt;p&gt;7、Mybatis&lt;strong&gt;&lt;span&gt;缓存&lt;/span&gt;&lt;/strong&gt;设计的目的&lt;/p&gt;
&lt;p&gt;　　增强版，也支持事物级别的缓存，同时支持不同sqlSession之间的共享。扩大可缓存的可用性。&lt;/p&gt;

</description>
<pubDate>Wed, 06 Feb 2019 08:45:00 +0000</pubDate>
<dc:creator>JsonSun</dc:creator>
<og:description>继续用提问的方式来看Mybatis的缓存设计。 1、Mybatis如何开启缓存 Mybatis对查询结果进行缓存,所以缓存的对象为具体的Statement 通过在Statement上是否使用缓存来启用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/marioS/p/10353468.html</dc:identifier>
</item>
<item>
<title>配置CLion作为Qt5开发环境 - apocelipes</title>
<link>http://www.cnblogs.com/apocelipes/p/10353698.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/apocelipes/p/10353698.html</guid>
<description>&lt;p&gt;使用Qt进行程序开发时QtCreator总是不二之选。作为老牌IDE在提供了强大的功能同时也对Qt的支持做了许多优化。如果没有特别的原因你应该使用它。&lt;/p&gt;
&lt;p&gt;然而一个顺手的工具将会极大得提升生产效率，而如果你之前使用别的工具进行开发，那么就要斟酌一下学习使用QtCreator的成本了。&lt;/p&gt;
&lt;p&gt;所以我将介绍配置CLion（另一个强大的c++ IDE）作为Qt5的开发环境，在利用现有工具链的同时避免了安装另一个大型软件。&lt;/p&gt;
&lt;h2 id=&quot;perpare&quot;&gt;准备工作&lt;/h2&gt;
&lt;p&gt;CLion的安装和激活超出了本文的讨论范围，我们假设你已经安装好了CLion。如果需要帮助可以去CLion官网查找安装方法。&lt;/p&gt;
&lt;p&gt;CLion默认使用GCC进行工程构建，然而使用GCC是无法使用代码补全功能的，所以我们将toolchains替换成clang：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1434464/201902/1434464-20190206141638533-1039972746.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意，CLion自带了一个cmake，如果我们想使用系统提供的一些cmake模块，那么就必须如图所示替换为系统的cmake。&lt;/p&gt;
&lt;p&gt;随后确保你的编译器至少要支持c++11，如果能支持c++14或者c++17那自然是最好。&lt;/p&gt;
&lt;h2 id=&quot;create-project&quot;&gt;创建Qt5项目&lt;/h2&gt;
&lt;p&gt;下面是创建Qt5项目，CLion没有区分普通c++项目和Qt项目（毕竟Qt项目一般也是c++项目或者c++/QML项目），所以这样创建即可：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1434464/201902/1434464-20190206141619463-20126742.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;创建完成后项目结构如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1434464/201902/1434464-20190206141601932-706929034.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cmake-build-release&lt;/code&gt;目录是生成moc等工具的中间代码以及可执行文件的地方，当然可执行文件的生成路径可以自己指定，这是CLion默认的选项。&lt;/p&gt;
&lt;p&gt;这时编译运行和代码补全还是不能用的，所以接下来我们设置编译和代码补全。&lt;/p&gt;
&lt;h2 id=&quot;settings&quot;&gt;设置Qt代码补全和项目编译&lt;/h2&gt;
&lt;p&gt;事先要说明的一点是，CLion是根据&lt;code&gt;CMakeLists.txt&lt;/code&gt;文件来组织和设置项目的，所以如果我们需要添加诸如Qt这样的第三方库或是改变编译行为，都只要修改&lt;code&gt;CMakeLists.txt&lt;/code&gt;即可。&lt;/p&gt;
&lt;p&gt;所以我们需要把&lt;code&gt;CMakeLists.txt&lt;/code&gt;修改成如下的样子：&lt;/p&gt;
&lt;pre class=&quot;cmakelists&quot;&gt;
&lt;code&gt;cmake_minimum_required(VERSION 3.0)
project(test)

# 指定c++标准的版本
set(CMAKE_CXX_STANDARD 17)

# 自动调用moc，uic，rcc处理qt的扩展部分
set(CMAKE_AUTOMOC ON)
set(CMAKE_AUTOUIC ON)
set(CMAKE_AUTORCC ON)

set(CMAKE_INCLUDE_CURRENT_DIR ON)

# 设置Qt5的cmake模块所在目录，如果不设置将使用系统提供的版本
# QT_DIR和QT_VERSION是指定了qt安装目录和版本的环境变量
# 如果你使用了系统的cmake，那么会优先使用系统提供模块，如果不想发生这种行为你需要自己运行cmake或者使用CLion自带的
set(CMAKE_PREFIX_PATH $ENV{QT_DIR}/$ENV{QT_VERSION}/gcc_64/lib/cmake)

# 找到对应的qt模块，名字为qmake中QT += &amp;lt;name&amp;gt;中的name首字母大写后加上Qt5前缀
# 例如core为QtCore，你也可以去${CMAKE_PREFIX_PATH}的目录中找到正确的模块名
find_package(Qt5Widgets REQUIRED)

aux_source_directory(. DIRS_SRCS)

add_executable(test ${DIRS_SRCS})

# 把对应Qt模块的库链接进程序
target_link_libraries(test Qt5::Widgets)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;值得注意的是，使用系统提供的Qt的一个好处是编译出来的程序可以使用系统的样式和主题，但缺点是版本可能会与我们想使用的不一致从而产生错误。&lt;/p&gt;
&lt;p&gt;修改之后点击图中的&lt;code&gt;Reload changes&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1434464/201902/1434464-20190206141516624-1338866483.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;CLion会自动生成新的Makefile用于编译项目，现在代码补全也可以使用了。&lt;/p&gt;
&lt;h2 id=&quot;compile&quot;&gt;编译项目&lt;/h2&gt;
&lt;p&gt;我们先写一个小的示例，让一个spinbox和slider可以相互联动：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;QApplication&amp;gt;
#include &amp;lt;QFormLayout&amp;gt;
#include &amp;lt;QtGlobal&amp;gt;
#include &amp;lt;QObject&amp;gt;
#include &amp;lt;QSlider&amp;gt;
#include &amp;lt;QSpinBox&amp;gt;
#include &amp;lt;QWidget&amp;gt;

int main(int argc, char *argv[])
{
    QApplication app(argc, argv);

    auto window = new QWidget;

    auto spinBox = new QSpinBox;
    spinBox-&amp;gt;setRange(0, 100);
    auto slider = new QSlider;
    slider-&amp;gt;setRange(0, 100);
    QObject::connect(spinBox,
                     // 对于重载函数需要给出确定的版本，QOverload需要编译器支持c++11
                     QOverload&amp;lt;int&amp;gt;::of(&amp;amp;QSpinBox::valueChanged),
                     slider,
                     &amp;amp;QSlider::setValue);
    QObject::connect(slider,
                     &amp;amp;QSlider::valueChanged,
                     spinBox,
                     &amp;amp;QSpinBox::setValue);

    auto layout = new QFormLayout;
    layout-&amp;gt;addRow(&quot;spin box:&quot;, spinBox);
    layout-&amp;gt;addRow(&quot;slider:&quot;, slider);
    window-&amp;gt;setLayout(layout);
    window-&amp;gt;show();

    return app.exec();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们点击&lt;code&gt;int main(...)&lt;/code&gt;左侧的运行按钮：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1434464/201902/1434464-20190206141441452-2051567902.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;程序就开始编译了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1434464/201902/1434464-20190206141423077-849002016.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果编译成功程序就会自动运行：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1434464/201902/1434464-20190206141402652-580946372.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此CLion已经可以正常配合Qt进行开发。&lt;/p&gt;
</description>
<pubDate>Wed, 06 Feb 2019 06:17:00 +0000</pubDate>
<dc:creator>apocelipes</dc:creator>
<og:description>使用Qt进行程序开发时QtCreator总是不二之选。作为老牌IDE在提供了强大的功能同时也对Qt的支持做了许多优化。如果没有特别的原因你应该使用它。 然而一个顺手的工具将会极大得提升生产效率，而如果</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/apocelipes/p/10353698.html</dc:identifier>
</item>
</channel>
</rss>