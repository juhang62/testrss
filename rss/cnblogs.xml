<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>kubernetes集群管理常用命令一 - 周国通</title>
<link>http://www.cnblogs.com/tylerzhou/p/11056440.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tylerzhou/p/11056440.html</guid>
<description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/tylerzhou/p/10969041.html&quot;&gt;系列目录&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们把集群管理命令分为两个部分,第一部分介绍一些简单的,但是可能是非常常用的命令以及一些平时可能没有碰到的技巧.第二部分将综合前面介绍的工具通过示例来讲解一些更为复杂的命令.&lt;/p&gt;
&lt;h2 id=&quot;列出集群中所有pod&quot;&gt;列出集群中所有pod&lt;/h2&gt;
&lt;p&gt;使用&lt;code&gt;kubectl get pods&lt;/code&gt;获取的一般是默认名称空间的信息(可以在配置文件中指定默认全称空间,如果没有指定则默认为default).如果想要获取获取非默认名称空间的pod,则需要指定-n(或者--namespace)参数.但是有些时候我们想要查看整个集群中所有名称空间的pod,则可以通过&lt;code&gt;kubectl get pods --all-namespaces&lt;/code&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;有的童鞋可能会好奇,可不可能不选择全部,但是选择多个名称空间下的pod,其实也是可以的.以下示例同时选择了default和kube-system名称空间下的所有pod&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[centos@k8s-master ~]$ kubectl get po --namespace={default,kube-system}
NAME                                                   READY   STATUS             RESTARTS   AGE
coredns-78d4cf999f-8lpm6                               1/1     Running            4          64d
coredns-78d4cf999f-hd7nn                               1/1     Running            4          64d
etcd-k8s-master                                        1/1     Running            6          64d
jxing-nginx-ingress-controller-7d9d4fc99d-bksl2        1/1     Running            0          2d1h
jxing-nginx-ingress-default-backend-7875d67576-cmwz5   0/1     ImagePullBackOff   0          2d1h
kube-apiserver-k8s-master                              1/1     Running            0          23d
kube-controller-manager-k8s-master                     1/1     Running            7          64d
kube-flannel-ds-amd64-5w2d6                            1/1     Running            1          2d2h
kube-flannel-ds-amd64-69vhm                            1/1     Running            1          31h
kube-flannel-ds-amd64-bh5hw                            1/1     Running            1          2d7h
kube-flannel-ds-amd64-csnqm                            1/1     Running            0          47h
kube-flannel-ds-amd64-fpdx5                            1/1     Running            6          64d
kube-flannel-ds-amd64-j6v7h                            1/1     Running            4          3h50m
kube-flannel-ds-amd64-qsrxw                            1/1     Running            1          46h
kube-proxy-7xcb7                                       1/1     Running            6          64d
kube-proxy-d4jxx                                       1/1     Running            2          2d7h
kube-proxy-ftjsk                                       1/1     Running            2          46h
kube-proxy-jrfxs                                       1/1     Running            5          3h50m
kube-proxy-kw4fw                                       1/1     Running            1          31h
kube-proxy-thzdp                                       1/1     Running            1          2d2h
kube-proxy-wrbmm                                       1/1     Running            0          47h
kube-scheduler-k8s-master                              1/1     Running            9          64d
kubernetes-dashboard-6b8667558-dtn6r                   1/1     Running            0          2d1h
tiller-deploy-6df646875f-tp26r                         1/1     Running            0          2d1h
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;只列出资源的名称&quot;&gt;只列出资源的名称&lt;/h2&gt;
&lt;p&gt;在测试环境中,有时候我们可能想要把所有类型的资源全部删除.比如删除所有deployment.我们可以通过&lt;code&gt;kubectl get deployment&lt;/code&gt;来列出所有的deployment,然后逐个删除.如果是全部删除的话,这样显然是低效的,并且往往因为名称拼写错误导致操作失败.在docker里们,我们想要删除全部运行的容器,可以通过&lt;code&gt;docker ps -q&lt;/code&gt;来获取所有pod的id,然后通过循环来删除.其实在kubernetes里,可以通过&lt;code&gt;kubectl get deployment -o=name&lt;/code&gt;仅仅输出名称,然后使用循环逐个删除.&lt;/p&gt;
&lt;h2 id=&quot;列出包含特定标签的pod&quot;&gt;列出包含特定标签的pod&lt;/h2&gt;
&lt;p&gt;有经验的童鞋都知道,受某个Deployment控制的一组pod的名称往往跟这个Deployment的名称有关系,往往是Deployment的名称加上一串hash.但是如果如果两个deployment名称很类似,我就不就太容易找出某个deployment所控制的pod.最为无助的是service和它选择的pod之间往往从表面上看不出关系的,如何知道一个service所控制.其实我们可以通过service里的labelselector选择的lable来过滤此service所控制的pod.&lt;/p&gt;
&lt;p&gt;比如我有一个名为helloworld的service,我们使用&lt;code&gt;kubectl describe service helloworld&lt;/code&gt;来查看它的信息&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[centos@k8s-master ~]$ kubectl describe service helloworld
Name:                     helloworld
Namespace:                default
Labels:                   run=helloworld
Annotations:              field.cattle.io/publicEndpoints:
                            [{&quot;addresses&quot;:[&quot;192.168.9.40&quot;],&quot;port&quot;:32001,&quot;protocol&quot;:&quot;TCP&quot;,&quot;serviceName&quot;:&quot;default:helloworld&quot;,&quot;allNodes&quot;:true}]
                          kubectl.kubernetes.io/last-applied-configuration:
                            {&quot;apiVersion&quot;:&quot;v1&quot;,&quot;kind&quot;:&quot;Service&quot;,&quot;metadata&quot;:{&quot;annotations&quot;:{},&quot;labels&quot;:{&quot;run&quot;:&quot;helloworld&quot;},&quot;name&quot;:&quot;helloworld&quot;,&quot;namespace&quot;:&quot;default&quot;},...
Selector:                 app=helloworld
Type:                     NodePort
IP:                       10.108.25.188
Port:                     &amp;lt;unset&amp;gt;  80/TCP
TargetPort:               80/TCP
NodePort:                 &amp;lt;unset&amp;gt;  32001/TCP
Endpoints:                10.244.2.30:80
Session Affinity:         None
External Traffic Policy:  Cluster
Events:                   &amp;lt;none&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它的labelSelector的值为&lt;code&gt;app=helloworld&lt;/code&gt;.我们可以通过这个label来过滤pod&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[centos@k8s-master ~]$ kubectl get pod -l=app=helloworld
NAME                          READY   STATUS    RESTARTS   AGE
helloworld-6d6bdb66dd-ncwk5   1/1     Running   0          3h4m&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;其实,除了service以外,deployment,ReplicationController,ReplicaSet也可以通过类似方式选择,这样选择出的结果更为准确.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;选择指定节点上的pod&quot;&gt;选择指定节点上的pod&lt;/h2&gt;
&lt;p&gt;有一定经验的童鞋可能会知道,使用&lt;code&gt;kubectl get pods'时是不显示节点信息的,通过指定参数&lt;/code&gt;-o wide&lt;code&gt;就可以展示出来pod所在的节点信息,然后便可以通过grep命令来过滤结果.比如我们想要查找&lt;/code&gt;k8s-node2`节点上的运行了哪些pod(节点名称可以自定义的,大家的不必是k8s-nodexxx这种形式)&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[centos@k8s-master easymock]$ kubectl get po --all-namespaces -o wide|grep k8s-node2
cattle-system      cattle-node-agent-djg2h                                1/1     Running            2          2d8h    192.168.122.74   k8s-node2    &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
default            consul-0                                               1/1     Running            0          2d2h    10.244.2.27      k8s-node2    &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
default            consul-2                                               1/1     Running            0          2d2h    10.244.2.28      k8s-node2    &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
default            helloworld-6d6bdb66dd-ncwk5                            1/1     Running            0          3h48m   10.244.2.30      k8s-node2    &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
default            stodagent-6f47976ccb-8fzmv                             1/1     Running            0          2d2h    10.244.2.23      k8s-node2    &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
default            stodagent-6f47976ccb-vf7kx                             1/1     Running            0          2d2h    10.244.2.22      k8s-node2    &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
default            trackingapi-gateway-dep-79bb86bb57-x9xzp               1/1     Running            0          2d2h    10.244.2.24      k8s-node2    &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
ingress-nginx      nginx-ingress-controller-c7dcb4d44-rhp22               1/1     Running            0          2d2h    10.244.2.25      k8s-node2    &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
kube-system        kube-flannel-ds-amd64-bh5hw                            1/1     Running            1          2d8h    192.168.122.74   k8s-node2    &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
kube-system        kube-proxy-d4jxx                                       1/1     Running            2          2d8h    192.168.122.74   k8s-node2    &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
kube-system        tiller-deploy-6df646875f-tp26r                         1/1     Running            0          2d2h    10.244.2.26      k8s-node2    &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
tekton-pipelines   tekton-pipelines-webhook-79d8658cdc-2tp84              1/1     Running            0          2d2h    10.244.2.19      k8s-node2    &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是通过linux的grep命令来实现的,其实,kubectl也有着非常强大的过滤功能,我们可以对它字段选择过滤器&lt;code&gt;feild selector&lt;/code&gt;,通过pod描述文件里的&lt;code&gt;spec.nodeName&lt;/code&gt;来过滤指定节点上的pod.命令示例如下:&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[centos@k8s-master easymock]$ kubectl get po --all-namespaces -o wide --field-selector=spec.nodeName=k8s-node2
NAMESPACE          NAME                                        READY   STATUS    RESTARTS   AGE     IP               NODE        NOMINATED NODE   READINESS GATES
cattle-system      cattle-node-agent-djg2h                     1/1     Running   2          2d8h    192.168.122.74   k8s-node2   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
default            consul-0                                    1/1     Running   0          2d2h    10.244.2.27      k8s-node2   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
default            consul-2                                    1/1     Running   0          2d2h    10.244.2.28      k8s-node2   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
default            helloworld-6d6bdb66dd-ncwk5                 1/1     Running   0          3h52m   10.244.2.30      k8s-node2   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
default            stodagent-6f47976ccb-8fzmv                  1/1     Running   0          2d2h    10.244.2.23      k8s-node2   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
default            stodagent-6f47976ccb-vf7kx                  1/1     Running   0          2d2h    10.244.2.22      k8s-node2   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
default            trackingapi-gateway-dep-79bb86bb57-x9xzp    1/1     Running   0          2d2h    10.244.2.24      k8s-node2   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
ingress-nginx      nginx-ingress-controller-c7dcb4d44-rhp22    1/1     Running   0          2d2h    10.244.2.25      k8s-node2   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
kube-system        kube-flannel-ds-amd64-bh5hw                 1/1     Running   1          2d8h    192.168.122.74   k8s-node2   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
kube-system        kube-proxy-d4jxx                            1/1     Running   2          2d8h    192.168.122.74   k8s-node2   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
kube-system        tiller-deploy-6df646875f-tp26r              1/1     Running   0          2d2h    10.244.2.26      k8s-node2   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
tekton-pipelines   tekton-pipelines-webhook-79d8658cdc-2tp84   1/1     Running   0          2d2h    10.244.2.19      k8s-node2   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;列出所有状态不是运行中的pod&quot;&gt;列出所有状态不是运行中的Pod&lt;/h2&gt;
&lt;p&gt;有时候我们需要列出所有未在运行的pod,以便决定下一步要做什么行动.未运行的原因有很多,比如镜像未能正常拉取,pod无法被正常调度等,我们首先要把所有未运行的pod过滤出来.&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[root@k8s-master helloworld]# kubectl get pod --field-selector=status.phase!=Running
NAME                          READY   STATUS             RESTARTS   AGE
redis-cache-f87d8488c-4d9dl   0/1     ErrImagePull       0          4d4h
redis-cache-f87d8488c-gjxqj   0/1     ImagePullBackOff   0          20h
redis-cache-f87d8488c-v4zjx   0/1     ImagePullBackOff   0          4d4h&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;这里不同的是,前面我们使用的是等号来判断相等关系,其实也可以像这里使用(!=)来表示否定.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;还有一点需要特别注意&lt;code&gt;phase=Running&lt;/code&gt;的pod并不全是正常运行的pod,要确认一个pod是正常运行的,必须&lt;code&gt;.status.conditions里的Initialized,Ready,ContainersReady和PodScheduled几种类型的值必须全部是&quot;true&quot;,也可以通过展示字段STATUS的值为Running&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;列出所有节点&quot;&gt;列出所有节点&lt;/h2&gt;
&lt;p&gt;我们通常都是和pod,service这些资源打交道,但是有些时候,我们也需要和节点打交道.可以使用&lt;code&gt;kubectl get nodes&lt;/code&gt;来查看集群中的所有节点信息&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;查看node信息是通过&lt;code&gt;kubectl get&lt;/code&gt;命令,kubectl get的参数在这里同样适用.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;node也是k8s的资源,我们可以通过kubectl describe+节点名称查看节点内存,cpu核数,以及该节点的压力等信息.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 20 Jun 2019 00:12:00 +0000</pubDate>
<dc:creator>周国通</dc:creator>
<og:description>'系列目录' 我们把集群管理命令分为两个部分,第一部分介绍一些简单的,但是可能是非常常用的命令以及一些平时可能没有碰到的技巧.第二部分将综合前面介绍的工具通过示例来讲解一些更为复杂的命令. 列出集群中</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tylerzhou/p/11056440.html</dc:identifier>
</item>
<item>
<title>@Java web程序员，在保留现场，服务不重启的情况下，执行我们的调试代码（JSP 方式） - 三国梦回</title>
<link>http://www.cnblogs.com/grey-wolf/p/11052495.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/grey-wolf/p/11052495.html</guid>
<description>&lt;p&gt;&lt;span&gt;最近事不算多，所以有点时间写博客，昨天写着写着，测试的同学反馈说有一个bug。我看了下服务端日志，空指针了：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;73.710653753027&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/519126/201906/519126-20190619162606769-632816277.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面会给出详细代码，这个空指针不是那么好一眼看出来，不过最后，该bug就是在没有重启服务，也没在本地调试的情况下解决的，利用的方法就是 JSP。没错，就是这么古老的技术。现在很多90程序员已经慢慢成为主力了，对于JSP这类技术估计都不了解，尤其现在前后端分离后，互联网领域的公司，包括一些传统行业的新的项目，后端服务都只是简单的api 服务。下面演示下，怎么利用JSP来找BUG，一点不难，主要是提供一个思路吧。（不适用于打成 jar 包的spring boot应用，对于 打成 war包的spring boot项目是否支持，我还没实验，有兴趣同学可以试试）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;1、问题代码&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/519126/201906/519126-20190619163315114-316254059.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如图所示，npe抛出的那行，暂时也确定不了到底是哪个空了。jsonObj来自于 array，array来自 resultList，resultList 来自 incidentInformationDao.queryAllIncidentInformation，然后又被  gisCommonService.getCoordinatesWithinCircle 处理了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;大概又看了一眼  gisCommonService.getCoordinatesWithinCircle 的代码：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/519126/201906/519126-20190619163728076-900481674.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;看着这一坨坨的代码，而且不是我写的，而且没什么注释，而且bug还要我来看。。。哎。。。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我就想了，我要看看到底 在执行了 gisCommonService.getCoordinatesWithinCircle 后，要是可以直接把 List&amp;lt;GisAccessAlarm&amp;gt; resultList 打印出来，不是一下就清晰了吗？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;说干就干，本来 &lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/grey-wolf/p/11051427.html&quot;&gt;@Java Web 程序员，我们一起给程序开个后门吧：让你在保留现场，服务不重启的情况下，执行我们的调试代码&lt;/a&gt; 这个博文里提供了一种方式，但是这个测试环境的工程还没搞上这个东东，无奈，用不了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是，emmm，等等，JSP 不是可以吗？ &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;2、jsp文件代码&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;test.jsp：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; &amp;lt;%@ page &lt;span&gt;import&lt;/span&gt;=&quot;com.alibaba.fastjson.JSONArray&quot; %&amp;gt;
&lt;span&gt; 2&lt;/span&gt; &amp;lt;%@ page &lt;span&gt;import&lt;/span&gt;=&quot;com.*.base.common.exception.IllegalParameterException&quot; %&amp;gt;
&lt;span&gt; 3&lt;/span&gt; &amp;lt;%@ page &lt;span&gt;import&lt;/span&gt;=&quot;com.*.base.common.utilities.JsonUtils&quot; %&amp;gt;
&lt;span&gt; 4&lt;/span&gt; &amp;lt;%@ page &lt;span&gt;import&lt;/span&gt;=&quot;com.*.base.common.utilities.SpringContextUtils&quot; %&amp;gt;
&lt;span&gt; 5&lt;/span&gt; &amp;lt;%@ page &lt;span&gt;import&lt;/span&gt;=&quot;com.*.dao.interfaces.IncidentInformationDao&quot; %&amp;gt;
&lt;span&gt; 6&lt;/span&gt; &amp;lt;%@ page &lt;span&gt;import&lt;/span&gt;=&quot;com.*.model.IncidentAppealInformation&quot; %&amp;gt;
&lt;span&gt; 7&lt;/span&gt; &amp;lt;%@ page &lt;span&gt;import&lt;/span&gt;=&quot;com.*.model.IncidentInformation&quot; %&amp;gt;
&lt;span&gt; 8&lt;/span&gt; &amp;lt;%@ page &lt;span&gt;import&lt;/span&gt;=&quot;com.*.service.impls.GisIncidentInformationServiceImpl&quot; %&amp;gt;
&lt;span&gt; 9&lt;/span&gt; &amp;lt;%@ page &lt;span&gt;import&lt;/span&gt;=&quot;com.*.service.interfaces.IGisService&quot; %&amp;gt;
&lt;span&gt;10&lt;/span&gt; &amp;lt;%@ page &lt;span&gt;import&lt;/span&gt;=&quot;com.*.service.interfaces.IncidentAppealService&quot; %&amp;gt;
&lt;span&gt;11&lt;/span&gt; &amp;lt;%@ page &lt;span&gt;import&lt;/span&gt;=&quot;com.*.service.interfaces.IncidentInformationService&quot; %&amp;gt;
&lt;span&gt;12&lt;/span&gt; &amp;lt;%@ page &lt;span&gt;import&lt;/span&gt;=&quot;com.*.utils.GisUtils&quot; %&amp;gt;
&lt;span&gt;13&lt;/span&gt; &amp;lt;%@ page &lt;span&gt;import&lt;/span&gt;=&quot;com.*.vo.GisAccessAlarm&quot; %&amp;gt;
&lt;span&gt;14&lt;/span&gt; &amp;lt;%@ page &lt;span&gt;import&lt;/span&gt;=&quot;org.apache.commons.collections.CollectionUtils&quot; %&amp;gt;
&lt;span&gt;15&lt;/span&gt; &amp;lt;%@ page &lt;span&gt;import&lt;/span&gt;=&quot;org.apache.commons.lang3.StringUtils&quot; %&amp;gt;
&lt;span&gt;16&lt;/span&gt; &amp;lt;%@ page &lt;span&gt;import&lt;/span&gt;=&quot;org.slf4j.Logger&quot; %&amp;gt;
&lt;span&gt;17&lt;/span&gt; &amp;lt;%@ page &lt;span&gt;import&lt;/span&gt;=&quot;org.slf4j.LoggerFactory&quot; %&amp;gt;
&lt;span&gt;18&lt;/span&gt; &amp;lt;%@ page &lt;span&gt;import&lt;/span&gt;=&quot;java.util.Calendar&quot; %&amp;gt;
&lt;span&gt;19&lt;/span&gt; &amp;lt;%@ page &lt;span&gt;import&lt;/span&gt;=&quot;java.util.Date&quot; %&amp;gt;
&lt;span&gt;20&lt;/span&gt; &amp;lt;%@ page &lt;span&gt;import&lt;/span&gt;=&quot;java.util.List&quot; %&amp;gt;
&lt;span&gt;21&lt;/span&gt; &amp;lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&amp;gt;
&lt;span&gt;22&lt;/span&gt; &amp;lt;%@page contentType=&quot;text/html;charset=UTF-8&quot;%&amp;gt;
&lt;span&gt;23&lt;/span&gt; &amp;lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&amp;gt;
&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt; &amp;lt;head&amp;gt;
&lt;span&gt;27&lt;/span&gt; &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
&lt;span&gt;29&lt;/span&gt;     &amp;lt;meta http-equiv=&quot;pragma&quot; content=&quot;no-cache&quot;&amp;gt;
&lt;span&gt;30&lt;/span&gt;     &amp;lt;meta http-equiv=&quot;cache-control&quot; content=&quot;no-cache&quot;&amp;gt;
&lt;span&gt;31&lt;/span&gt;     &amp;lt;meta http-equiv=&quot;expires&quot; content=&quot;0&quot;&amp;gt;
&lt;span&gt;32&lt;/span&gt;     &amp;lt;meta http-equiv=&quot;keywords&quot; content=&quot;keyword1,keyword2,keyword3&quot;&amp;gt;
&lt;span&gt;33&lt;/span&gt;     &amp;lt;meta http-equiv=&quot;description&quot; content=&quot;This is my page&quot;&amp;gt;
&lt;span&gt;34&lt;/span&gt; &amp;lt;/head&amp;gt;
&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt; &amp;lt;%
&lt;span&gt;37&lt;/span&gt;     Logger logger = LoggerFactory.getLogger(GisIncidentInformationServiceImpl.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;     IncidentInformationService incidentInformationService = SpringContextUtils.getBean(IncidentInformationService.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;     IncidentAppealService incidentAppealService = SpringContextUtils.getBean(IncidentAppealService.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;     IncidentInformationDao incidentInformationDao = SpringContextUtils.getBean(IncidentInformationDao.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;     IGisService gisCommonService = SpringContextUtils.getBean(IGisService.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; 
&lt;span&gt;43&lt;/span&gt;     String incidentInformationId = &quot;B06BBE52-E85F-450C-A8C6-EB45D2634EED&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;     Integer radius = 2000&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;     Integer startTime = 10&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;     Integer endTime = 10&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (StringUtils.isEmpty(incidentInformationId)) {
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;         &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalParameterException(&quot;IncidentinformationID is null or empty.&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;     IncidentInformation incidentInfo =&lt;span&gt; incidentInformationService.get(incidentInformationId);
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;     IncidentAppealInformation incidentAppealInformation =&lt;span&gt; incidentAppealService.get(incidentInformationId);
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (incidentInfo == &lt;span&gt;null&lt;/span&gt; || &lt;span&gt;null&lt;/span&gt; ==&lt;span&gt; incidentAppealInformation) {
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;         &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalParameterException(&quot;incidentinformationID is not found in db. IncidentinformationID = &quot; +&lt;span&gt; incidentInformationId);
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; 
&lt;span&gt;56&lt;/span&gt;     String type =&lt;span&gt; incidentInfo.getIncidentTypeId();
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;     type = StringUtils.substring(type, 0, 2&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (StringUtils.isEmpty(type)) {
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;         &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalParameterException(&quot;incidentinformation type is empty.&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; 
&lt;span&gt;62&lt;/span&gt;     String lonStr =&lt;span&gt; incidentInfo.getLongitude();
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;     String latStr =&lt;span&gt; incidentInfo.getLatitude();
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; &lt;span&gt;    GisUtils.checkLonLat(lonStr,latStr);
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt; 
&lt;span&gt;66&lt;/span&gt;     Date appealTime =&lt;span&gt; incidentAppealInformation.getIncidentTime();
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;     Calendar cal =&lt;span&gt; Calendar.getInstance();
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt; &lt;span&gt;    cal.setTime(appealTime);
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;     cal.add(Calendar.MINUTE, -1 *&lt;span&gt; startTime);
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt;     Date startDate =&lt;span&gt; cal.getTime();
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt; 
&lt;span&gt;72&lt;/span&gt;     Calendar cal1 =&lt;span&gt; Calendar.getInstance();
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt; &lt;span&gt;    cal1.setTime(appealTime);
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt;     cal1.add(Calendar.MINUTE, 1 *&lt;span&gt; endTime);
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt;     cal1.add(Calendar.SECOND, 1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt;     Date endDate =&lt;span&gt; cal1.getTime();
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt;     List&amp;lt;GisAccessAlarm&amp;gt; resultList =&lt;span&gt; incidentInformationDao.queryAllIncidentInformation(incidentInformationId, type, startDate, endDate);
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt; != resultList &amp;amp;&amp;amp;&lt;span&gt; CollectionUtils.isNotEmpty(resultList)) {
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt;         resultList =&lt;span&gt; gisCommonService.getCoordinatesWithinCircle(resultList, Double.valueOf(lonStr), Double.valueOf(latStr), radius.doubleValue());
&lt;/span&gt;&lt;span&gt;80&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;81&lt;/span&gt;     JSONArray array =&lt;span&gt; JsonUtils.toFormatDateJSONArray(resultList);
&lt;/span&gt;&lt;span&gt;82     logger.info(&quot;array:{}&quot;,array);
&lt;/span&gt;&lt;span&gt;83&lt;/span&gt; %&amp;gt;
&lt;span&gt;84&lt;/span&gt; &amp;lt;body&amp;gt;
&lt;span&gt;85&lt;/span&gt; 
&lt;span&gt;86&lt;/span&gt; &amp;lt;/body&amp;gt;
&lt;span&gt;87&lt;/span&gt; &amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;你大概看到了，我写了这么大一坨，我这么懒，肯定是不可能手写，拷过来，然后把本来自动注入的那些，改成从 SpringContextUtils 静态工具中获取就行了。 我们这里，重点代码就一行，也就是标红的 82 行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;3、执行 jsp&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;然后我就把这个jsp 丢到了 web应用的根目录下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/519126/201906/519126-20190619164804202-2143402820.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 然后从我的浏览器访问之：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;http://192.168.19.97:8080/web应用上下文/test.jsp&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;执行后，去看看我们的日志文件：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/519126/201906/519126-20190619165326311-2122742092.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;把array 序列化之后，一看，原来是没有 userId 这个属性存在。。。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;于是，下面这行红色处，肯定就空了：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;jsonObj.put(&quot;userName&quot;, userService.getUserMap().getOrDefault(jsonObj.get(&quot;userId&quot;), &lt;span&gt;jsonObj.get(&quot;userId&quot;).toString()&lt;/span&gt;));&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;JSP 这种方式，说起来还是挺方便的，可以马上修改，马上看到效果。但是背后的原理我们也需要了解，再看看 Tomcat 的类加载器图（来自于网络，侵删）：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/519126/201906/519126-20190619165724243-576259010.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以看到， JSP 的类加载器处于最下面一层，每次访问 JSP 时，如果JSP文件已经被修改过（通过文件的最近一次修改时间确定），都会生成一个新的 JSP 类加载器。 JSP 类加载器 加载的对象，为什么能够和 WebApp类加载器加载的类交互呢（比如我们上面例子中，JSP文件中引用了很多 java代码，甚至用了里面的spring 的 bean），这都是因为 JSP 类加载器的双亲加载器 就是 WebApp 类加载器，JSP 类加载器在遇到自己加载不了的那些类时，都委派给 WebApp 类加载器去加载了，所以 Jsp 文件中引用的那些类，最终是由 Webapp 类加载器加载的，所以才可以调用那些 java 代码。如果我们自己自定义个类加载器，这个类加载器除了加载 jsp 文件，也自己去 web-inf 下面加载想要的类，那么，肯定是会出错的，具体表现就是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;IncidentInformationService incidentInformationService = SpringContextUtils.getBean(IncidentInformationService.class);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这一句中，SpringContextUtils 如果由自己加载，那么 SpringContextUtils 里面是没有任何 bean 存在的，取出来的都为 null，也就不能达到我们动态调试的效果了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Thu, 20 Jun 2019 00:07:00 +0000</pubDate>
<dc:creator>三国梦回</dc:creator>
<og:description>一、前言 类加载器实战系列的第六篇（悄悄跟你说，这篇比较水），前面5篇在这里： 实战分析Tomcat的类加载器结构（使用Eclipse MAT验证） 还是Tomcat，关于类加载器的趣味实验 了不得，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/grey-wolf/p/11052495.html</dc:identifier>
</item>
<item>
<title>每日一问：详细说一下 MeasureSpec.UNSPECIFIED - 南尘</title>
<link>http://www.cnblogs.com/liushilin/p/11055741.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liushilin/p/11055741.html</guid>
<description>&lt;h2 id=&quot;详细说一下-measurespec.unspecified&quot;&gt;详细说一下 MeasureSpec.UNSPECIFIED&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/6cdbb418df46&quot;&gt;前面的文章&lt;/a&gt; 我留下了一个疑惑，那就是到底为什么 &lt;code&gt;NestedScrollView&lt;/code&gt; 要把子 View 的测量模式强行设置为 &lt;code&gt;MeasureSpec.UNSPECIFIED&lt;/code&gt; ，这不，在鸿洋的 &quot;wanAndroid&quot; 中，他再次提出了这样的问题：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;MesureSpec.UNSPECIFIED&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;这个模式什么时候会遇到？&lt;/li&gt;
&lt;li&gt;遇到后怎么处理？&lt;/li&gt;
&lt;li&gt;有什么注意事项？&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;下面摘自用户「陈小缘啦啦啦」的回答，我觉得回答的非常到位，特别在这里和大家分享一下。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;UNSPECIFID&lt;/code&gt;，就是未指定的意思，在这个模式下父控件不会干涉子 View 想要多大的尺寸。&lt;/strong&gt;&lt;br/&gt;那么，这个模式什么时候会&lt;code&gt;onMeasure()&lt;/code&gt; 里遇到呢？其实是取决于它的父容器。&lt;br/&gt;就拿最常用的 &lt;code&gt;RecyclerView&lt;/code&gt; 做例子，在 &lt;code&gt;Item&lt;/code&gt; 进行 &lt;code&gt;measure()&lt;/code&gt; 时，如果列表可滚动，并且 &lt;code&gt;Item&lt;/code&gt; 的宽或高设置了 &lt;code&gt;wrap_content&lt;/code&gt; 的话，那么接下来，itemView 的 &lt;code&gt;onMeasure( )&lt;/code&gt;方法的测量模式就会变成 &lt;code&gt;MeasureSpec.UNSPECIFIED&lt;/code&gt;。&lt;br/&gt;我们不妨打开 &lt;code&gt;RecyclerView&lt;/code&gt; 源码，会在 &lt;code&gt;getChildMeasureSpec()&lt;/code&gt; 方法里看到这么一句注释：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;MATCH_PARENT can't be applied since we can scroll in this dimension, wrap instead using UNSPECIFIED.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;它想表达的是：在可滚动的&lt;code&gt;ViewGroup&lt;/code&gt;中，不应该限制 Item 的尺寸（如果是水平滚动，就不限制宽度），为什么呢？ 因为是可以滚动的，就算 Item 有多宽，有多高，通过滚动也一样能看到滚动前被遮挡的部分。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;这里其实也就回答了我之前询问的 &lt;code&gt;NestedScrollView&lt;/code&gt; 要强行设置 Item 为 UNSPECIFIED 的原因。&lt;br/&gt;有同学可能会有疑问： 我设置 &lt;code&gt;wrap_content&lt;/code&gt;，在 &lt;code&gt;onMeasure()&lt;/code&gt; 中应该收到的是 &lt;code&gt;AT_MOST&lt;/code&gt; 才对啊，为什么要强制变成 &lt;code&gt;UNSPECIFIED&lt;/code&gt;？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;这是因为考虑到 Item 的尺寸有可能超出这个可滚动的 &lt;code&gt;ViewGroup&lt;/code&gt; 的尺寸，而在 &lt;code&gt;AT_MOST&lt;/code&gt; 模式下，你的尺寸不能超出你所在的 &lt;code&gt;ViewGroup&lt;/code&gt; 的尺寸，最多只能等于，所以用 &lt;code&gt;UNSPECIFIED&lt;/code&gt;会更合适，这个模式下你想要多大就多大。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那么，我们在自定义 View 的时候，在测量时发现是 &lt;code&gt;UNSPECIFIED&lt;/code&gt; 模式时，应该怎么做呢？&lt;/p&gt;
&lt;p&gt;这个就比较自由了，既然尺寸由自己决定，那么我可以写死为 50，也可以固定为 200。但还是建议结合实际需求来定义咯。&lt;/p&gt;
&lt;p&gt;比如 &lt;code&gt;ImageView&lt;/code&gt;，它的做法就是：有设置图片内容(drawable)的话，会直接使用这个 drawable 的尺寸，但不会超过指定的 &lt;code&gt;MaxWidth&lt;/code&gt; 或 &lt;code&gt;MaxHeight&lt;/code&gt;， 没有内容的话就是 0。而 &lt;code&gt;TextView&lt;/code&gt; 处理 &lt;code&gt;UNSPECIFIED&lt;/code&gt; 的方式，和 &lt;code&gt;AT_MOST&lt;/code&gt; 是一样的。&lt;/p&gt;
&lt;p&gt;当然了，这些尺寸都不一定等于最后 &lt;code&gt;layout&lt;/code&gt; 出来的尺寸，因为最后决定子 &lt;code&gt;View&lt;/code&gt; 位置和大小的，是在 &lt;code&gt;onLayout()&lt;/code&gt; 方法中，在这里你完全可以无视这些尺寸，去 &lt;code&gt;layout()&lt;/code&gt;成自己想要的样子。不过，一般不会这么做。&lt;/p&gt;
</description>
<pubDate>Wed, 19 Jun 2019 15:30:00 +0000</pubDate>
<dc:creator>南尘</dc:creator>
<og:description>详细说一下 MeasureSpec.UNSPECIFIED '前面的文章' 我留下了一个疑惑，那就是到底为什么 要把子 View 的测量模式强行设置为 ，这不，在鸿洋的 'wanAndroid' 中，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/liushilin/p/11055741.html</dc:identifier>
</item>
<item>
<title>Visual Studio 调试技巧 - LightSmaile</title>
<link>http://www.cnblogs.com/LightSmile/p/11055665.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/LightSmile/p/11055665.html</guid>
<description>&lt;p&gt;&lt;strong&gt;写在前面：假定你在日常的工作中使用到了Visual Studio，并期望了解一些调试技巧来提高工作效率，也许本文适合你。以下&lt;/strong&gt;Visual Studio简称vs。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;一、入门&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;以最简单的控制台应用程序为例，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
 1 class&lt;span&gt; Program
 2 &lt;span&gt;{
 3     static void Main(string&lt;span&gt;[] args)
 4 &lt;span&gt;    {
 5         int result = Sum(2, 3&lt;span&gt;);
 6         Console.WriteLine(&quot;2+3={0}&quot;&lt;span&gt;, result);
 7 &lt;span&gt;    }
 8 
 9     private static int Sum(int a,int&lt;span&gt; b)
10 &lt;span&gt;    {
11         return a +&lt;span&gt; b;
12 &lt;span&gt;    }
13 }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调试的根本目的是跟踪代码、程序的状态，判断是否按照期望的行为运行。常用的跟踪手段有控制台输出、日志输出以及断点调试。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;控制台输出用于开发环境，可以在vs输出窗口中查看程序输出的内容如下图所示：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/891388/201905/891388-20190521213402626-616247895.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于是控制台应用程序，&lt;em&gt;&lt;strong&gt;Console.WriteLine() &lt;/strong&gt;&lt;/em&gt;输出的内容不会显示在输出窗口，故采用&lt;em&gt;&lt;strong&gt;Trace.WriteLine()&lt;/strong&gt;&lt;/em&gt;&lt;strong&gt; 。&lt;/strong&gt;对非控制台应用程序，&lt;strong&gt;&lt;em&gt;Console.WriteLine() &lt;/em&gt;&lt;/strong&gt;输出的内容会正常显示在输出窗口。&lt;/p&gt;
&lt;p&gt;2. 日志输出用于开发环境和生产环境，但更多用于生产环境，用来收集程序的运行信息。常用的日志组件有Log4Net、NLog以及自定义日志组件。依据问题严重程度大致分为严重错误、错误、警告、信息以及调试信息等几个级别。可结合实际需求灵活配置。&lt;/p&gt;
&lt;p&gt;3. 断点调试多用于开发环境，通过设置断点，让程序在指定的位置暂停，以便观察上下文环境情况。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/891388/201905/891388-20190521215559187-548218275.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上图为例，添加断点后，鼠标移动到变量名上，可以观察一些变量的值。对于复杂类型的变量，通过选中变量，右键选择快速监视的方式。避免鼠标移动后，监视的信息消失。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/891388/201905/891388-20190521220244448-1113469792.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上三种调试方法中，对于开发环境而言，使用最为频繁的方法当数断点调试。后面以断点调试为主，深入介绍。&lt;/p&gt;
&lt;h3&gt;二、进阶&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;启动外部程序&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;要使用断点调试，需要满足一些断点调试的条件。对于可执行程序，如控制台应用程序、窗体应用程序、WPF应用程序以及Web应用程序，启动调试后，可以在期望的位置添加断点。而对于如动态库类型，不可以直接启动调试。想要调试这类项目，有两种方式。一种是可以设置项目属性中的启动操作，指定引用该动态库的可执行程序路径。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/891388/201905/891388-20190521221858901-16712878.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另一种方式是运行调用了动态库的可执行程序，通过附加可执行程序进程的方式来调试。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;附加进程&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/891388/201905/891388-20190521222653275-1532116714.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;新建 &lt;em&gt;&lt;strong&gt;DllDemo&lt;/strong&gt;&lt;/em&gt; 动态库项目，添加 &lt;em&gt;&lt;strong&gt;MyMath&lt;/strong&gt;&lt;/em&gt; 类，添加静态方法 &lt;em&gt;&lt;strong&gt;Max(int a,int b) &lt;/strong&gt;&lt;/em&gt;。代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 1 using&lt;span&gt; System;
 2 
 3 namespace&lt;span&gt; DllDemo
 4 &lt;span&gt;{
 5     public class&lt;span&gt; MyMath
 6 &lt;span&gt;    {
 7         public static int Max(int a,int&lt;span&gt; b)
 8 &lt;span&gt;        {
 9             return&lt;span&gt; Math.Max(a, b);
10 &lt;span&gt;        }
11 &lt;span&gt;    }
12 }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 添加对 &lt;em&gt;&lt;strong&gt;DllDemo &lt;/strong&gt;&lt;/em&gt;动态库项目引用， 并修改控制台应用程序如下。为了方便后续调试，控制台应用程序中添加 Console.Read()。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
 1 using&lt;span&gt; DllDemo;
 2 using&lt;span&gt; System;
 3 using&lt;span&gt; System.Diagnostics;
 4 
 5 namespace&lt;span&gt; DebugDemo
 6 &lt;span&gt;{
 7     class&lt;span&gt; Program
 8 &lt;span&gt;    {
 9         static void Main(string&lt;span&gt;[] args)
10 &lt;span&gt;        {
11             Console.WriteLine(&quot;等待键盘输入...&quot;&lt;span&gt;);
12 
13 &lt;span&gt;            Console.Read();
14 
15             int result = Sum(2, 3&lt;span&gt;);
16 
17             Console.WriteLine(string.Format(&quot;2+3={0}&quot;&lt;span&gt;, result));
18 
19             result = MyMath.Max(2, 3&lt;span&gt;);
20 
21             Console.WriteLine(string.Format(&quot;MyMath.Max(2, 3)={0}&quot;&lt;span&gt;, result));
22 &lt;span&gt;        }
23 
24         private static int Sum(int a, int&lt;span&gt; b)
25 &lt;span&gt;        {
26             return a +&lt;span&gt; b;
27 &lt;span&gt;        }
28 &lt;span&gt;    }
29 }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行控制台应用程序DebugDemo.exe ，附加该进程，在合适的位置添加断点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/891388/201905/891388-20190521225915367-779135539.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;查看调用堆栈&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当程序包含接口继承、抽象类继承等逻辑，导致结构过于复杂，知道功能入口以及出口，想要了解过程时，调用堆栈会比较有用。以下面代码为例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
private static void&lt;span&gt; DoWork()
{
    DoWork1();
}

private static void&lt;span&gt; DoWork1()
{
    DoWork2();
}

private static void&lt;span&gt; DoWork2()
{
    DoWork3();
}

private static void&lt;span&gt; DoWork3()
{
    Console.Write(&quot;DoWork3&quot;&lt;span&gt;);
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;假设知道功能入口为DoWork，功能结果为DoWork3，想要了解DoWork3的调用逻辑，可以在DoWork3中设置断点，启动调试后打开调用堆栈窗口，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/891388/201906/891388-20190619211446410-438479179.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;异常设置&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当程序运行以后，结果不是预期的。初步猜测发生了异常，由于某些原因，捕获了异常，却未妥善处理，导致异常信息被“吞”掉。此时，异常设置会格外有效。以下面代码为例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
private static void&lt;span&gt; TryToDivideByZero()
{
    try&lt;span&gt;
    {
        int a = 9&lt;span&gt;;
        int b = 0&lt;span&gt;;
        int c = a /&lt;span&gt; b;
    }
    catch&lt;span&gt;(Exception ex)
    {
        Console.WriteLine(ex.Message);
    }
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于方法中存在异常，又有异常捕获，后续逻辑会被打断，此时对异常设置做如下设置：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/891388/201906/891388-20190619214558384-1896158314.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;重新调试程序会有如下结果，方便快速定位异常发生点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/891388/201906/891388-20190619214928719-563123134.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;三、高级&lt;/h3&gt;
&lt;p&gt;在某些场景下，开发环境运行正常，非开发环境运行异常，依赖常规手段无法定位问题原因，想要断点调试，非开发环境运行缺少VS时，远程调试会比较有效。&lt;/p&gt;
&lt;p&gt;在VS安装目录下拷贝远程调试所需的文件夹x86，x64到非开发环境&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/891388/201906/891388-20190619221031919-55286496.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;依据远程目标机系统环境，运行x86/x64文件夹下msvsmon.exe，选择工具中的选项菜单做如下配置：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/891388/201906/891388-20190619224532449-1284470362.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;运行待调试程序后，在VS中选择调试&amp;gt;附加到进程（ctrl+alt+p），设置连接类型，连接目标（远程ip地址或计算机名）后查找，会自动列出相关内容。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/891388/201906/891388-20190619225137329-502436653.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在可用进程中选择对应的进程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/891388/201906/891388-20190619225628694-1443715604.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在合适的位置添加断点即可开始调试了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/891388/201906/891388-20190619230139477-1690135266.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 19 Jun 2019 15:18:00 +0000</pubDate>
<dc:creator>LightSmaile</dc:creator>
<og:description>写在前面：假定你在日常的工作中使用到了Visual Studio，并期望了解一些调试技巧来提高工作效率，也许本文适合你。以下Visual Studio简称vs。 一、入门 以最简单的控制台应用程序为例</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/LightSmile/p/11055665.html</dc:identifier>
</item>
<item>
<title>Redisson实现分布式锁—RedissonLock - 雨点的名字</title>
<link>http://www.cnblogs.com/qdhxhz/p/11055426.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qdhxhz/p/11055426.html</guid>
<description>&lt;center&gt;

&lt;/center&gt;
&lt;p&gt;有关Redisson实现分布式锁上一篇博客讲了分布式的锁原理：&lt;a href=&quot;https://www.cnblogs.com/qdhxhz/p/11046905.html&quot;&gt;Redisson实现分布式锁---原理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这篇主要讲RedissonLock和RLock。Redisson分布式锁的实现是基于RLock接口，RedissonLock实现RLock接口。&lt;/p&gt;
&lt;h2 id=&quot;一rlock接口&quot;&gt;&lt;span&gt;一、RLock接口&lt;/span&gt;&lt;/h2&gt;
&lt;h4 id=&quot;概念&quot;&gt;1、概念&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface RLock extends Lock, RExpirable, RLockAsync&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;很明显RLock是继承Lock锁，所以他有Lock锁的所有特性，比如lock、unlock、trylock等特性,同时它还有很多新特性：强制锁释放，带有效期的锁,。&lt;/p&gt;
&lt;h4 id=&quot;rlock锁api&quot;&gt;2、RLock锁API&lt;/h4&gt;
&lt;p&gt;这里针对上面做个整理，这里列举几个常用的接口说明&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface RRLock {
    //----------------------Lock接口方法-----------------------

    /**
     * 加锁 锁的有效期默认30秒
     */
    void lock();
    /**
     * tryLock()方法是有返回值的，它表示用来尝试获取锁，如果获取成功，则返回true，如果获取失败（即锁已被其他线程获取），则返回false .
     */
    boolean tryLock();
    /**
     * tryLock(long time, TimeUnit unit)方法和tryLock()方法是类似的，只不过区别在于这个方法在拿不到锁时会等待一定的时间，
     * 在时间期限之内如果还拿不到锁，就返回false。如果如果一开始拿到锁或者在等待期间内拿到了锁，则返回true。
     *
     * @param time 等待时间
     * @param unit 时间单位 小时、分、秒、毫秒等
     */
    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;
    /**
     * 解锁
     */
    void unlock();
    /**
     * 中断锁 表示该锁可以被中断 假如A和B同时调这个方法，A获取锁，B为获取锁，那么B线程可以通过
     * Thread.currentThread().interrupt(); 方法真正中断该线程
     */
    void lockInterruptibly();

    //----------------------RLock接口方法-----------------------
    /**
     * 加锁 上面是默认30秒这里可以手动设置锁的有效时间
     *
     * @param leaseTime 锁有效时间
     * @param unit      时间单位 小时、分、秒、毫秒等
     */
    void lock(long leaseTime, TimeUnit unit);
    /**
     * 这里比上面多一个参数，多添加一个锁的有效时间
     *
     * @param waitTime  等待时间
     * @param leaseTime 锁有效时间
     * @param unit      时间单位 小时、分、秒、毫秒等
     */
    boolean tryLock(long waitTime, long leaseTime, TimeUnit unit) throws InterruptedException;
    /**
     * 检验该锁是否被线程使用，如果被使用返回True
     */
    boolean isLocked();
    /**
     * 检查当前线程是否获得此锁（这个和上面的区别就是该方法可以判断是否当前线程获得此锁，而不是此锁是否被线程占有）
     * 这个比上面那个实用
     */
    boolean isHeldByCurrentThread();
    /**
     * 中断锁 和上面中断锁差不多，只是这里如果获得锁成功,添加锁的有效时间
     * @param leaseTime  锁有效时间
     * @param unit       时间单位 小时、分、秒、毫秒等
     */
    void lockInterruptibly(long leaseTime, TimeUnit unit);  
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;RLock相关接口，主要是新添加了 &lt;code&gt;leaseTime&lt;/code&gt; 属性字段，主要是用来设置锁的过期时间,避免死锁。&lt;/p&gt;

&lt;h2 id=&quot;二redissonlock实现类&quot;&gt;&lt;span&gt;二、RedissonLock实现类&lt;/span&gt;&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class RedissonLock extends RedissonExpirable implements RLock&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;RedissonLock实现了RLock接口，所以实现了接口的具体方法。这里我列举几个方法说明下&lt;/p&gt;
&lt;h4 id=&quot;void-lock方法&quot;&gt;1、void lock()方法&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @Override
    public void lock() {
        try {
            lockInterruptibly();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;发现lock锁里面进去其实用的是&lt;code&gt;lockInterruptibly&lt;/code&gt;（中断锁，表示可以被中断）,而且捕获异常后用 Thread.currentThread().interrupt()来真正中断当前线程，其实它们是搭配一起使用的。&lt;/p&gt;
&lt;p&gt;具体有关lockInterruptibly()方法讲解推荐一个博客。&lt;code&gt;博客&lt;/code&gt;：&lt;a href=&quot;https://blog.csdn.net/zengmingen/article/details/53260650&quot;&gt;Lock的lockInterruptibly()&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;接下来执行流程,这里理下关键几步&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;   /**
     * 1、带上默认值调另一个中断锁方法
     */
    @Override
    public void lockInterruptibly() throws InterruptedException {
        lockInterruptibly(-1, null);
    }
    /**
     * 2、另一个中断锁的方法
     */
    void lockInterruptibly(long leaseTime, TimeUnit unit) throws InterruptedException 
    /**
     * 3、这里已经设置了锁的有效时间默认为30秒  （commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout()=30）
     */
    RFuture&amp;lt;Long&amp;gt; ttlRemainingFuture = tryLockInnerAsync(commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(), TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);
    /**
     * 4、最后通过lua脚本访问Redis,保证操作的原子性
     */
    &amp;lt;T&amp;gt; RFuture&amp;lt;T&amp;gt; tryLockInnerAsync(long leaseTime, TimeUnit unit, long threadId, RedisStrictCommand&amp;lt;T&amp;gt; command) {
        internalLockLeaseTime = unit.toMillis(leaseTime);

        return commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, command,
                &quot;if (redis.call('exists', KEYS[1]) == 0) then &quot; +
                        &quot;redis.call('hset', KEYS[1], ARGV[2], 1); &quot; +
                        &quot;redis.call('pexpire', KEYS[1], ARGV[1]); &quot; +
                        &quot;return nil; &quot; +
                        &quot;end; &quot; +
                        &quot;if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then &quot; +
                        &quot;redis.call('hincrby', KEYS[1], ARGV[2], 1); &quot; +
                        &quot;redis.call('pexpire', KEYS[1], ARGV[1]); &quot; +
                        &quot;return nil; &quot; +
                        &quot;end; &quot; +
                        &quot;return redis.call('pttl', KEYS[1]);&quot;,
                Collections.&amp;lt;Object&amp;gt;singletonList(getName()), internalLockLeaseTime, getLockName(threadId));
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么void lock(long leaseTime, TimeUnit unit)方法其实和上面很相似了，就是从上面第二步开始的。&lt;/p&gt;
&lt;h4 id=&quot;trylocklong-waittime-long-leasetime-timeunit-unit&quot;&gt;2、tryLock(long waitTime, long leaseTime, TimeUnit unit)&lt;/h4&gt;
&lt;p&gt;接口的参数和含义上面已经说过了，现在我们开看下源码，这里只显示一些重要逻辑。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; @Override
    public boolean tryLock(long waitTime, long leaseTime, TimeUnit unit) throws InterruptedException {
        long time = unit.toMillis(waitTime);
        long current = System.currentTimeMillis();
        long threadId = Thread.currentThread().getId();
        Long ttl = tryAcquire(leaseTime, unit, threadId);
        //1、 获取锁同时获取成功的情况下，和lock(...)方法是一样的 直接返回True，获取锁False再往下走
        if (ttl == null) {
            return true;
        }
        //2、如果超过了尝试获取锁的等待时间,当然返回false 了。
        time -= System.currentTimeMillis() - current;
        if (time &amp;lt;= 0) {
            acquireFailed(threadId);
            return false;
        }

        // 3、订阅监听redis消息，并且创建RedissonLockEntry，其中RedissonLockEntry中比较关键的是一个 Semaphore属性对象,用来控制本地的锁请求的信号量同步，返回的是netty框架的Future实现。
        final RFuture&amp;lt;RedissonLockEntry&amp;gt; subscribeFuture = subscribe(threadId);
        //  阻塞等待subscribe的future的结果对象，如果subscribe方法调用超过了time，说明已经超过了客户端设置的最大wait time，则直接返回false，取消订阅，不再继续申请锁了。
        //  只有await返回true，才进入循环尝试获取锁
        if (!await(subscribeFuture, time, TimeUnit.MILLISECONDS)) {
            if (!subscribeFuture.cancel(false)) {
                subscribeFuture.addListener(new FutureListener&amp;lt;RedissonLockEntry&amp;gt;() {
                    @Override
                    public void operationComplete(Future&amp;lt;RedissonLockEntry&amp;gt; future) throws Exception {
                        if (subscribeFuture.isSuccess()) {
                            unsubscribe(subscribeFuture, threadId);
                        }
                    }
                });
            }
            acquireFailed(threadId);
            return false;
        }

       //4、如果没有超过尝试获取锁的等待时间，那么通过While一直获取锁。最终只会有两种结果
        //1)、在等待时间内获取锁成功 返回true。2）等待时间结束了还没有获取到锁那么返回false。
        while (true) {
            long currentTime = System.currentTimeMillis();
            ttl = tryAcquire(leaseTime, unit, threadId);
            // 获取锁成功
            if (ttl == null) {
                return true;
            }
           //   获取锁失败
            time -= System.currentTimeMillis() - currentTime;
            if (time &amp;lt;= 0) {
                acquireFailed(threadId);
                return false;
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;重点&lt;/code&gt; tryLock一般用于特定满足需求的场合，但不建议作为一般需求的分布式锁，一般分布式锁建议用void lock(long leaseTime, TimeUnit unit)。因为从性能上考虑，在高并发情况下后者效率是前者的好几倍&lt;/p&gt;
&lt;h4 id=&quot;unlock&quot;&gt;3、unlock()&lt;/h4&gt;
&lt;p&gt;解锁的逻辑很简单。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Override
    public void unlock() {
        // 1.通过 Lua 脚本执行 Redis 命令释放锁
        Boolean opStatus = commandExecutor.evalWrite(getName(), LongCodec.INSTANCE,
                RedisCommands.EVAL_BOOLEAN,
                &quot;if (redis.call('exists', KEYS[1]) == 0) then &quot; +
                        &quot;redis.call('publish', KEYS[2], ARGV[1]); &quot; +
                        &quot;return 1; &quot; +
                        &quot;end;&quot; +
                        &quot;if (redis.call('hexists', KEYS[1], ARGV[3]) == 0) then &quot; +
                        &quot;return nil;&quot; +
                        &quot;end; &quot; +
                        &quot;local counter = redis.call('hincrby', KEYS[1], ARGV[3], -1); &quot; +
                        &quot;if (counter &amp;gt; 0) then &quot; +
                        &quot;redis.call('pexpire', KEYS[1], ARGV[2]); &quot; +
                        &quot;return 0; &quot; +
                        &quot;else &quot; +
                        &quot;redis.call('del', KEYS[1]); &quot; +
                        &quot;redis.call('publish', KEYS[2], ARGV[1]); &quot; +
                        &quot;return 1; &quot;+
                        &quot;end; &quot; +
                        &quot;return nil;&quot;,
                Arrays.&amp;lt;Object&amp;gt;asList(getName(), getChannelName()),
                LockPubSub.unlockMessage, internalLockLeaseTime,
                getLockName(Thread.currentThread().getId()));
        // 2.非锁的持有者释放锁时抛出异常
        if (opStatus == null) {
            throw new IllegalMonitorStateException(
                    &quot;attempt to unlock lock, not locked by current thread by node id: &quot;
                            + id + &quot; thread-id: &quot; + Thread.currentThread().getId());
        }
        // 3.释放锁后取消刷新锁失效时间的调度任务
        if (opStatus) {
            cancelExpirationRenewal();
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用 EVAL 命令执行 Lua 脚本来释放锁：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;key 不存在，说明锁已释放，直接执行 &lt;code&gt;publish&lt;/code&gt; 命令发布释放锁消息并返回 &lt;code&gt;1&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;key 存在，但是 field 在 Hash 中不存在，说明自己不是锁持有者，无权释放锁，返回 &lt;code&gt;nil&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;因为锁可重入，所以释放锁时不能把所有已获取的锁全都释放掉，一次只能释放一把锁，因此执行 &lt;code&gt;hincrby&lt;/code&gt; 对锁的值&lt;strong&gt;减一&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;释放一把锁后，如果还有剩余的锁，则刷新锁的失效时间并返回 &lt;code&gt;0&lt;/code&gt;；如果刚才释放的已经是最后一把锁，则执行 &lt;code&gt;del&lt;/code&gt; 命令删除锁的 key，并发布锁释放消息，返回 &lt;code&gt;1&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;code&gt;注意&lt;/code&gt;这里有个实际开发过程中，容易出现很容易出现上面第二步异常，非锁的持有者释放锁时抛出异常。比如下面这种情况&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;      //设置锁1秒过去
        redissonLock.lock(&quot;redisson&quot;, 1);
        /**
         * 业务逻辑需要咨询2秒
         */
        redissonLock.release(&quot;redisson&quot;);
      /**
       * 线程1 进来获得锁后，线程一切正常并没有宕机，但它的业务逻辑需要执行2秒，这就会有个问题，在 线程1 执行1秒后，这个锁就自动过期了，
       * 那么这个时候 线程2 进来了。在线程1去解锁就会抛上面这个异常（因为解锁和当前锁已经不是同一线程了）
       */&lt;/code&gt;
&lt;/pre&gt;

&lt;pre&gt;
&lt;code&gt;只要自己变优秀了，其他的事情才会跟着好起来（中将6）&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 19 Jun 2019 15:00:00 +0000</pubDate>
<dc:creator>雨点的名字</dc:creator>
<og:description>Redisson实现分布式锁—RedissonLock 有关Redisson实现分布式锁上一篇博客讲了分布式的锁原理： 'Redisson实现分布式锁 原理' 这篇主要讲RedissonLock和RL</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qdhxhz/p/11055426.html</dc:identifier>
</item>
<item>
<title>手撕面试题ThreadLocal！！！ - 匠心零度</title>
<link>http://www.cnblogs.com/jiangxinlingdu/p/11055540.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jiangxinlingdu/p/11055540.html</guid>
<description>&lt;h2 id=&quot;说明&quot;&gt;说明&lt;/h2&gt;
&lt;p&gt;面试官：讲讲你对ThreadLocal的一些理解。&lt;/p&gt;
&lt;p&gt;那么我们该怎么回答呢？？？？你也可以思考下，下面看看零度的思考；&lt;/p&gt;
&lt;h2 id=&quot;threadlocal用在什么地方&quot;&gt;ThreadLocal用在什么地方？&lt;/h2&gt;
&lt;p&gt;讨论ThreadLocal用在什么地方前，我们先明确下，如果仅仅就一个线程，那么都不用谈ThreadLocal的，&lt;strong&gt;ThreadLocal是用在多线程的场景的！！！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ThreadLocal归纳下来就2类用途：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;保存线程上下文信息，在任意需要的地方可以获取！！！&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;线程安全的，避免某些情况需要考虑线程安全必须同步带来的性能损失！！！&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;保存线程上下文信息在任意需要的地方可以获取&quot;&gt;保存线程上下文信息，在任意需要的地方可以获取！！！&lt;/h3&gt;
&lt;p&gt;由于ThreadLocal的特性，同一线程在某地方进行设置，在随后的任意地方都可以获取到。从而可以用来保存线程上下文信息。&lt;/p&gt;
&lt;p&gt;常用的比如每个请求怎么把一串后续关联起来，就可以用ThreadLocal进行set，在后续的任意需要记录日志的方法里面进行get获取到请求id，从而把整个请求串起来。&lt;/p&gt;
&lt;p&gt;还有比如Spring的事务管理，用ThreadLocal存储Connection，从而各个DAO可以获取同一Connection，可以进行事务回滚，提交等操作。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;备注：&lt;/strong&gt; ThreadLocal的这种用处，很多时候是用在一些优秀的框架里面的，一般我们很少接触，反而下面的场景我们接触的更多一些！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;线程安全的避免某些情况需要考虑线程安全必须同步带来的性能损失&quot;&gt;线程安全的，避免某些情况需要考虑线程安全必须同步带来的性能损失！！！&lt;/h3&gt;
&lt;p&gt;ThreadLocal为解决多线程程序的并发问题提供了一种新的思路。但是ThreadLocal也有局限性，我们来看看阿里规范：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.jiangxinlingdu.com/assets/images/2019/2019061995966.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每个线程往ThreadLocal中读写数据是线程隔离，互相之间不会影响的，所以&lt;strong&gt;ThreadLocal无法解决共享对象的更新问题！&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;由于不需要共享信息，自然就不存在竞争问题了，从而保证了某些情况下线程的安全，以及避免了某些情况需要考虑线程安全必须同步带来的性能损失！！！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;这类场景阿里规范里面也提到了：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.jiangxinlingdu.com/assets/images/2019/2019061985112.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;threadlocal一些细节&quot;&gt;ThreadLocal一些细节！&lt;/h2&gt;
&lt;p&gt;ThreaLocal使用示例代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class ThreadLocalTest {
    private static ThreadLocal&amp;lt;Integer&amp;gt; threadLocal = new ThreadLocal&amp;lt;&amp;gt;();

    public static void main(String[] args) {

        new Thread(() -&amp;gt; {
            try {
                for (int i = 0; i &amp;lt; 100; i++) {
                    threadLocal.set(i);
                    System.out.println(Thread.currentThread().getName() + &quot;====&quot; + threadLocal.get());
                    try {
                        Thread.sleep(200);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            } finally {
                threadLocal.remove();
            }
        }, &quot;threadLocal1&quot;).start();


        new Thread(() -&amp;gt; {
            try {
                for (int i = 0; i &amp;lt; 100; i++) {
                    System.out.println(Thread.currentThread().getName() + &quot;====&quot; + threadLocal.get());
                    try {
                        Thread.sleep(200);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            } finally {
                threadLocal.remove();
            }
        }, &quot;threadLocal2&quot;).start();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.jiangxinlingdu.com/assets/images/2019/2019061905672.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.jiangxinlingdu.com/assets/images/2019/2019061975650.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从运行的结果我们可以看到threadLocal1进行set值对threadLocal2并没有任何影响！&lt;/p&gt;
&lt;p&gt;Thread、ThreadLocalMap、ThreadLocal总览图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.jiangxinlingdu.com/assets/images/2019/2019061906258.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.jiangxinlingdu.com/assets/images/2019/2019061972141.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Thread类有属性变量threadLocals （类型是ThreadLocal.ThreadLocalMap），也就是说每个线程有一个自己的ThreadLocalMap ，所以每个线程往这个ThreadLocal中读写隔离的，并且是互相不会影响的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一个ThreadLocal只能存储一个Object对象，如果需要存储多个Object对象那么就需要多个ThreadLocal！！！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.jiangxinlingdu.com/assets/images/2019/2019061926179.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看到上面的几个图，大概思路应该都清晰了，我们Entry的key指向ThreadLocal用&lt;strong&gt;虚线&lt;/strong&gt;表示弱引用 ，下面我们来看看ThreadLocalMap:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.jiangxinlingdu.com/assets/images/2019/2019061957308.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;java对象的引用包括 ： 强引用，软引用，弱引用，虚引用 。&lt;/p&gt;
&lt;p&gt;因为这里涉及到弱引用，简单说明下：&lt;/p&gt;
&lt;p&gt;弱引用也是用来描述非必需对象的，当JVM进行垃圾回收时，无论内存是否充足，&lt;strong&gt;该对象仅仅被弱引用关联&lt;/strong&gt;，那么就会被回收。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当仅仅只有ThreadLocalMap中的Entry的key指向ThreadLocal的时候，ThreadLocal会进行回收的！！！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ThreadLocal被垃圾回收后，在ThreadLocalMap里对应的Entry的键值会变成null，但是Entry是强引用，那么Entry里面存储的Object，并没有办法进行回收，所以ThreadLocalMap 做了一些额外的回收工作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.jiangxinlingdu.com/assets/images/2019/2019061948918.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;虽然做了但是也会存在内存泄漏风险（我没有遇到过，网上很多类似场景，&lt;strong&gt;所以会提到后面的ThreadLocal最佳实践！！！&lt;/strong&gt;）&lt;/p&gt;
&lt;h2 id=&quot;threadlocal的最佳实践&quot;&gt;ThreadLocal的最佳实践！&lt;/h2&gt;
&lt;p&gt;ThreadLocal被垃圾回收后，在ThreadLocalMap里对应的Entry的键值会变成null，但是Entry是强引用，那么Entry里面存储的Object，并没有办法进行回收，所以ThreadLocalMap 做了一些额外的回收工作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.jiangxinlingdu.com/assets/images/2019/2019061948918.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;备注：&lt;/strong&gt; 很多时候，我们都是用在线程池的场景，程序不停止，线程基本不会销毁！！！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由于线程的生命周期很长，如果我们往ThreadLocal里面set了很大很大的Object对象，虽然set、get等等方法在特定的条件会调用进行额外的清理，但是&lt;strong&gt;ThreadLocal被垃圾回收后，在ThreadLocalMap里对应的Entry的键值会变成null，但是后续在也没有操作set、get等方法了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以最佳实践，应该在我们不使用的时候，主动调用remove方法进行清理。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.jiangxinlingdu.com/assets/images/2019/2019061958893.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里把ThreadLocal定义为static还有一个好处就是，由于ThreadLocal有强引用在，那么在ThreadLocalMap里对应的Entry的键会永远存在，那么执行remove的时候就可以正确进行定位到并且删除！！！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最佳实践做法应该为：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;try {
    // 其它业务逻辑
} finally {
    threadLocal对象.remove();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://www.jiangxinlingdu.com/assets/images/2019/2019061910377.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;思考&quot;&gt;思考&lt;/h2&gt;
&lt;p&gt;如果面试的时候，可以把上面的内容都可以讲到，个人觉得就非常好了，回答的就挺完美了。&lt;strong&gt;但是&lt;/strong&gt;如果你可以进行下面的回答，那么就更完美了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对于ThreadLocal，我在看Netty源码的时候，还了解过FastThreadLocal，xxxxx一些列内容，那就是一个升级了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.jiangxinlingdu.com/assets/images/2019/2019061900601.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在我本地进行测试，FastThreadLocal的吞吐量是jdkThreadLocal的3倍左右。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;备注：&lt;/strong&gt; 由于FastThreadLocal内容也非常非常多，而且有很多技巧，所以准备后续专门在开一篇进行串起来！！！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;如果读完觉得有收获的话，欢迎点赞、关注、加公众号 [匠心零度] ，查阅更多精彩历史！！！&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;http://www.jiangxinlingdu.com/assets/images/lingdu.gif&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 19 Jun 2019 14:55:00 +0000</pubDate>
<dc:creator>匠心零度</dc:creator>
<og:description>说明 面试官：讲讲你对ThreadLocal的一些理解。 那么我们该怎么回答呢？？？？你也可以思考下，下面看看零度的思考； ThreadLocal用在什么地方？ ThreadLocal一些细节！ Th</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jiangxinlingdu/p/11055540.html</dc:identifier>
</item>
<item>
<title>高仿富途牛牛-组件化(四)-优秀的时钟 - 朝十晚八</title>
<link>http://www.cnblogs.com/swarmbees/p/11055495.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/swarmbees/p/11055495.html</guid>
<description>&lt;h2 id=&quot;一概述&quot;&gt;一、概述&lt;/h2&gt;
&lt;p&gt;最近一直在仿照富途牛牛做组件化功能，目前已经有了初步的效果。&lt;/p&gt;
&lt;p&gt;组件化基础的功能已经有了，接下来就是一些细节上的处理了，比如说加载模板、保存模板、标签页修改名称等等，细节上的问题我们在后续的文章中都会一一做以介绍&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;最近打算把组件化中的工具箱相关功能做以实现。比如说迷你报价、自选股、小时钟这些窗口。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;仔细观察了牛牛的小窗口，无非就是一个窗口外壳，标题栏和客户区内容，下面我们来具体分析下&lt;/p&gt;
&lt;h3 id=&quot;窗口外壳&quot;&gt;1、窗口外壳&lt;/h3&gt;
&lt;p&gt;例如效果展示中的gif图，小时钟就是一个小窗口，他的外壳对我们肉眼所见到的骑士就是外边线、或者说是高亮选中时候的黄色边框。&lt;/p&gt;
&lt;p&gt;窗口外壳是我们进行缩放小窗口的利器，当我们鼠标属于这个外壳时，我们按下鼠标就可以对其进行放大、缩小，如果把鼠标放到四个角进行拖拽的时，你会惊奇的发现他还可以同时朝着两个方向进行缩放&lt;/p&gt;
&lt;h3 id=&quot;标题栏&quot;&gt;2、标题栏&lt;/h3&gt;
&lt;p&gt;windows原生的窗口是包含标题栏的，同样他还为我们提供了很好的放大缩小、拖拽、高亮消息通知等很好用的功能。但是windows原生的标题栏属于非客户端，我们是不能直接进行操作的，也就是说我们不能对其进行更多的定制化操作。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这下糟心了，windows原生标题栏用不了了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;既然windows原生的标题栏我们用不了，那么我们就只能隐藏原生的标题栏，然后自己去模拟一个新的标题栏，然后实现我们自己需要的所有标题栏该有的行为。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对于这样的小窗口我们已经实现了，在我们之前的文章中也有提到，他就是SmallWidget，只是在这个版本的代码里，我们才实现了放大、缩小等功能&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;客户区&quot;&gt;3、客户区&lt;/h3&gt;
&lt;p&gt;理解了上边2个概念，客户区利器起来就很简单了，他就是我们可以操作的区域。&lt;/p&gt;
&lt;p&gt;既然标题栏都已经被我们重写了，那么其实我们定制化后的SmallWidget窗口，标题栏也就是一个客户区了。&lt;/p&gt;
&lt;p&gt;如gif图中所展示的，小时钟窗口上的时间就是客户区内容了。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;了解了小窗口这个概念之后，来进入我们本篇文章的重点内容--&lt;strong&gt;优秀的时钟&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接下来我将会讲述下我们这个小时钟是怎么完成的。&lt;/p&gt;
&lt;h2 id=&quot;二效果展示&quot;&gt;二、效果展示&lt;/h2&gt;
&lt;p&gt;下面gif图所示，录制的时间比较长，大家可以仔细看下，交互效果完全是参照富途牛牛做的，只是目前视为没有接入正式数据。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;如有问题，欢迎提出。感谢！！！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;欢迎大家提出问题，交互、配色都可以&lt;/p&gt;
&lt;/blockquote&gt;
&lt;center&gt;
&lt;div&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/swarmbees/1482844/o_clock.gif&quot;/&gt;&lt;/div&gt;
&lt;/center&gt;
&lt;h2 id=&quot;三小窗口&quot;&gt;三、小窗口&lt;/h2&gt;
&lt;p&gt;写这篇文章之前，一直想写一篇&lt;code&gt;小窗口管理&lt;/code&gt;的文章，主要是为了更好的通过工具箱来构造小窗口，让使用者使用起来成本更低，无奈架构一直没有写好，因此这里一直往后推。&lt;/p&gt;
&lt;p&gt;写这篇文章的时候，&lt;code&gt;小窗口管理&lt;/code&gt;的代码结构已经在搭建了，因此展示的代码可能会暴露这一点，但是这不是我们这篇文章讲解的核心，暂时不用关心。&lt;/p&gt;
&lt;p&gt;小窗口还是那个窗口类，就像上一篇文章&lt;a href=&quot;https://www.cnblogs.com/swarmbees/p/11048378.html&quot;&gt;高仿富途牛牛-组件化(三)-界面美化&lt;/a&gt;中说的那样，只是这一次我们又加了一些新的功能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最主要的就是我们重写了鼠标3大事件，用于处理缩放效果&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;virtual void mousePressEvent(QMouseEvent * event) override;
virtual void mouseMoveEvent(QMouseEvent *) override;
virtual void mouseReleaseEvent(QMouseEvent * event) override;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这三个函数各司其职，分工协作，完成了缩放事件&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;mousePressEvent：记录鼠标按下时的一些状态，比如鼠标按下位置、鼠标按下状态&lt;/li&gt;
&lt;li&gt;mouseMoveEvent：负责处理移动事件，判断鼠标是否在窗口边缘，如果在的话，修改鼠标状态&lt;/li&gt;
&lt;li&gt;mouseReleaseEvent：当鼠标抬起时，恢复鼠标按下时记录的信息&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;下面主要分析下第二个步骤，鼠标移动事件处理，他的处理代码可能像下面这样，分为两个部分：修改鼠标状态和修改窗口大小&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void SmallWidget::mouseMoveEvent(QMouseEvent * event)
{
    if (mLeftButtonPressed)
    {
        ResizeWidget(event);
    }
    else
    {
        UpdateCursorShape(event-&amp;gt;pos());
    }

    __super::mouseMoveEvent(event);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;修改鼠标状态&quot;&gt;1、修改鼠标状态&lt;/h3&gt;
&lt;p&gt;鼠标移动时，当我们发现没有按下鼠标左键，这个时候我们就执行UpdateCursorShape方法，去判断是否可以进行修改窗口大小，同时修改鼠标状态&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;当鼠标不在窗口边缘时，也即不满足修改鼠标状态时，记得把鼠标状态还原&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;a判断是否满足拖拽&quot;&gt;a、判断是否满足拖拽&lt;/h4&gt;
&lt;p&gt;当鼠标处于窗口边缘时，并且在一定的范围内，就认为他进入了修改大小的准备状态&lt;/p&gt;
&lt;p&gt;如代码所示，我们首先判断鼠标满足四个边的那几个边的缩放，然后在继续判断是否是在某一个角上拖拽，最后一个变量onEdges标志着是否有缩放状态。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;当有一个变量onEdges变为true时，我们就认为要进行缩放，然后下一步我们就可以进行修改鼠标状态&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;void SmallWidget::Recalculate(const QPoint&amp;amp; mousePos, const QRect&amp;amp; frameRect)
{
    int mouseX = mousePos.x();
    int mouseY = mousePos.y();

    int frameX = frameRect.x();
    int frameY = frameRect.y();

    int frameWidth = frameRect.width();
    int frameHeight = frameRect.height();

    onLeftEdge = mouseX &amp;gt;= frameX &amp;amp;&amp;amp; mouseX &amp;lt;= frameX + mBorderWidth;//左
    onRightEdge = mouseX &amp;gt;= frameX + frameWidth - mBorderWidth &amp;amp;&amp;amp; mouseX &amp;lt;= frameX + frameWidth;//右 
    onTopEdge = mouseY &amp;gt;= frameY &amp;amp;&amp;amp; mouseY &amp;lt;= frameY + mBorderWidth;//上
    onBottomEdge = mouseY &amp;gt;= frameY + frameHeight - mBorderWidth &amp;amp;&amp;amp; mouseY &amp;lt;= frameY + frameHeight;//下
    
    onTopLeftEdge = onTopEdge &amp;amp;&amp;amp; onLeftEdge;
    onBottomLeftEdge = onBottomEdge &amp;amp;&amp;amp; onLeftEdge;
    onTopRightEdge = onTopEdge &amp;amp;&amp;amp; onRightEdge;
    onBottomRightEdge = onBottomEdge &amp;amp;&amp;amp; onRightEdge;

    //only these checks would be enough
    onEdges = onLeftEdge || onRightEdge || onTopEdge || onBottomEdge;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;b修改鼠标状态&quot;&gt;b、修改鼠标状态&lt;/h4&gt;
&lt;p&gt;判断完是否有边可以进行缩放之后，我们只需要根据这些变量就可以轻易知道，我们要把鼠标状态改成什么样子了。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;最后记住，如果不使用了，记得还原鼠标状态&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;void SmallWidget::UpdateCursorShape(const QPoint &amp;amp; mousePos)
{
    Recalculate(mousePos, rect());

    if (onTopLeftEdge || onBottomRightEdge)
    {
        setCursor(Qt::SizeFDiagCursor);
        mCursorShapeChanged = true;
    }
    else if (onTopRightEdge || onBottomLeftEdge)
    {
        setCursor(Qt::SizeBDiagCursor);
        mCursorShapeChanged = true;
    }
    else if (onLeftEdge || onRightEdge)
    {
        setCursor(Qt::SizeHorCursor);
        mCursorShapeChanged = true;
    }
    else if (onTopEdge || onBottomEdge)
    {
        setCursor(Qt::SizeVerCursor);
        mCursorShapeChanged = true;
    }
    else
    {
        if (mCursorShapeChanged)//修改鼠标状态
        {
            unsetCursor();
            mCursorShapeChanged = false;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;修改大小&quot;&gt;2、修改大小&lt;/h3&gt;
&lt;p&gt;修改了鼠标状态实在鼠标未按下的时候触发的，一旦我们修改了鼠标状态后，拖拽的第一步准备工作算是做到位了，&lt;strong&gt;这个时候我们只要按下鼠标，继续移动鼠标，然后就进入了修改窗口大小的流程中&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;修改窗口大小主要是使用了我们鼠标按下时记录的一些信息&lt;/p&gt;
&lt;p&gt;窗口大小的量应该等于鼠标按下时到移动的距离偏移，这里我们就那有边框右移来说明问题&lt;/p&gt;
&lt;p&gt;假设说右边框本身的值时500，我们鼠标按下时的全局坐标是1000，这个时候鼠标向右移动，移动到了1100这个坐标，那么鼠标其实就是移动了100像素，那么这样就很清晰了，我们的右边框此时的值应该是500+100=600。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;为什么移动后的位置 = 从按下时窗口的位置+鼠标按下时到当前位置的偏移量？这样做有一个很大的好处，那就是我们不需要考虑中间的过程，及时中间有些地方处理错了，如果又一次处罚了缩放，那么错误也会被修正。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;还有一个好处就是，如果我们每次只做上一次和本次的鼠标位置偏移量，这样处理结果会有异常，根据机器性能，有些机器会丢失需要处理的事件，导致鼠标移动的距离大，我们窗口缩放的少，这个主要是因为Qt把很多事件优化了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;void SmallWidget::ResizeWidget(QMouseEvent * event)
{
    QPoint mousePos = event-&amp;gt;pos();
    QPoint globalPos = event-&amp;gt;globalPos();

    QPoint offsetPos = globalPos - m_PressPos;

    QRect origRect = m_PressRect;

    if (onLeftEdge)
    {
        origRect.setLeft(origRect.left() + offsetPos.x());
    }
    else if (onRightEdge)
    {
        origRect.setRight(origRect.right() + offsetPos.x());
    }
    else if (onTopEdge)
    {
        origRect.setTop(origRect.top() + offsetPos.y());
    }
    else if (onBottomEdge)
    {
        origRect.setBottom(origRect.bottom() + offsetPos.y());
    }
    //其他四个角的处理省略
    if (onEdges)
    {
        move(origRect.topLeft());
        resize(origRect.size());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;四时钟窗口&quot;&gt;四、时钟窗口&lt;/h2&gt;
&lt;p&gt;讲完了小窗口，我们的小时钟已经具有了放大、缩小、和移动的功能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;接下来我们分析下这个时钟是怎么显示的，貌似他好像还支持自提自动放大。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先我们来分析下这个时钟窗口的布局，上边是一个动态刷新的时间文本，下边是一个文本框，主要显示当前日期。&lt;strong&gt;仔细看效果展示的gif图，其中主要的应该是上半部分的时间了，因为他居然支持窗口当大时，自身也可以平滑的放大&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;整个窗口的代码布局，我这里就不做介绍了，比较简单，就是一个垂直布局，其中有一个需要注意的地方就是分割线，研究过QtDesigner的同学应该都知道，Qt中的分割线其实就是一个像素的QFrame，他的实现代码可能像下面这样，然后加入布局即可&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//实现代码
QFrame * line = new QFrame;
line-&amp;gt;setObjectName(&quot;line&quot;);
line-&amp;gt;setFixedHeight(1);

//样式表
ClockSmall QFrame#line{border:1 solid #474F57;}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;重要环节登场了，也是我们本篇文章中的核心，支持字体平滑放大，就像效果图那样&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void TimeLabel::paintEvent(QPaintEvent * event)
{
    __super::paintEvent(event);

    QPainter painter(this);
    painter.setRenderHint(QPainter::Antialiasing);

    QFont font = painter.font();
    font.setPixelSize(14);
    painter.setFont(font);

    double side = qMin(width(), height());

    int text_w = painter.fontMetrics().width(m_text);
    int text_h = painter.fontMetrics().height();
    
    painter.translate(width() / 2, height() / 2);
    painter.scale(side / text_w * 1.5, side / text_w * 1.5);

    QRect r(-text_w / 2, -text_h / 2, text_w, text_h);
    painter.drawText(r, m_text);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面这几行代码就是负责绘制时钟的，这里边使用到了一个技巧--&lt;strong&gt;场景缩放&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;painter.scale()&lt;/strong&gt;这行代码可以把绘制的场景缩放一个比例系数，也就是当我们的窗体放大缩小时，我们根据窗体的大小计算出一个合适的缩放比，然后把场景进行缩放，这样我们的字体自然而然就会变大&lt;/p&gt;
&lt;p&gt;绘制时，我们也应该开启平滑绘制QPainter::Antialiasing这个属性，这样我们的程序看起来就会更舒畅一些，不会出现很明显的锯齿&lt;/p&gt;
&lt;p&gt;在缩放场景的时候，我们是这么干的&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;先把中心点平移到窗口中心&lt;/li&gt;
&lt;li&gt;使用缩放比例进行缩放场景&lt;/li&gt;
&lt;li&gt;计算我们字体的宽度和高度&lt;/li&gt;
&lt;li&gt;定义我们字体需要绘制的矩形&lt;/li&gt;
&lt;li&gt;在矩形中绘制我们要显示的文本&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;这里需要注意一个点，我们必须要计算矩形来绘制文字，如果想计算文字的起始点坐标这个比较困难，因为文字绘制时，并不是说你给的起始点就是文本串的左上角&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最后我们做一个定时器，每个一秒进行数据更新，然后刷新界面即可&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//启动定时器
QTimer * timer = new QTimer(this);
connect(timer, &amp;amp;QTimer::timeout, this, &amp;amp;ClockSmall::UpdateTime);
timer-&amp;gt;start(1000);

UpdateTime();
    
//更新数据
void ClockSmall::UpdateTime()
{
    QDateTime dt = QDateTime::currentDateTime();
    m_pTime-&amp;gt;SetText(dt.time().toString(&quot;HH:mm:ss&quot;));

    QString text = QStringLiteral(&quot;北京(CN) &quot;) + dt.date().toString(&quot;yyyy/MM/d&quot;);
    m_pText-&amp;gt;setText(text);
}

//更新数据 并发起绘制请求
void TimeLabel::SetText(const QString &amp;amp; text){ m_text = text; update(); }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;五相关文章&quot;&gt;五、相关文章&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/swarmbees/p/11027429.html&quot;&gt;高仿富途牛牛-组件化(一)-支持页签拖拽、增删、小工具&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/swarmbees/p/11042704.html&quot;&gt;高仿富途牛牛-组件化(二)-磁力吸附&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/swarmbees/p/11048378.html&quot;&gt;高仿富途牛牛-组件化(三)-界面美化&lt;/a&gt;&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;转载声明：本站文章无特别说明，皆为原创，版权所有，转载请注明：&lt;a href=&quot;https://www.cnblogs.com/swarmbees/&quot;&gt;朝十晚八&lt;/a&gt; or &lt;a href=&quot;https://www.jianshu.com/u/7673f8cfb4e6&quot;&gt;Twowords&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;</description>
<pubDate>Wed, 19 Jun 2019 14:52:00 +0000</pubDate>
<dc:creator>朝十晚八</dc:creator>
<og:description>[TOC] 一、概述 最近一直在仿照富途牛牛做组件化功能，目前已经有了初步的效果。 组件化基础的功能已经有了，接下来就是一些细节上的处理了，比如说加载模板、保存模板、标签页修改名称等等，细节上的问题我</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/swarmbees/p/11055495.html</dc:identifier>
</item>
<item>
<title>在nginx上部署vue项目(history模式)--demo实列； - 龙恩0707</title>
<link>http://www.cnblogs.com/tugenhua0707/p/11055512.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tugenhua0707/p/11055512.html</guid>
<description>&lt;p&gt;在很早之前，我写了一篇 关于 在&lt;a href=&quot;https://www.cnblogs.com/tugenhua0707/p/8127466.html&quot; target=&quot;_blank&quot;&gt;nginx上部署vue项目(history模式)&lt;/a&gt; 但是讲的都是理论，所以今天做个demo来实战下。有必要让大家更好的理解，我发现搜索这类似的问题还是挺多的，因此在写一篇有关这方面的实战文章。&lt;br/&gt;在讲解之前，我们还是和以前一样，一步步来，先看下我们项目的整个架构。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
|-------&lt;span&gt; 项目的根目录
&lt;/span&gt;|  |---&lt;span&gt; app
&lt;/span&gt;|  | |---&lt;span&gt; index
&lt;/span&gt;|  | | |---&lt;span&gt; components
&lt;/span&gt;|  | | | |---&lt;span&gt; home.vue
&lt;/span&gt;|  | | | |---&lt;span&gt; index.vue
&lt;/span&gt;|  | | | |---&lt;span&gt; java.vue
&lt;/span&gt;|  | | | |---&lt;span&gt; node.vue
&lt;/span&gt;|  | | | |---&lt;span&gt; xxx.vue
&lt;/span&gt;|  | | |---&lt;span&gt; app.js
&lt;/span&gt;|  | | |---&lt;span&gt; router.js
&lt;/span&gt;|  |---&lt;span&gt; views
&lt;/span&gt;|  |---&lt;span&gt; package.json
&lt;/span&gt;|  |--- webpack.config.js
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;整个项目架构基本上如上一个简单的结构。下面我们来分别贴下代码吧：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;app/index/components/index.vue 代码如下：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;stylus&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;header&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;router-link &lt;/span&gt;&lt;span&gt;to&lt;/span&gt;&lt;span&gt;=&quot;/home&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Home&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;router-link&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;router-link &lt;/span&gt;&lt;span&gt;to&lt;/span&gt;&lt;span&gt;=&quot;/java&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;java&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;router-link&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;router-link &lt;/span&gt;&lt;span&gt;to&lt;/span&gt;&lt;span&gt;=&quot;/node&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;node&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;router-link&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;router-link &lt;/span&gt;&lt;span&gt;to&lt;/span&gt;&lt;span&gt;='/xxx'&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;XXX&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;router-link&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;header&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 对应组件的内容渲染到router-view中 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;router-view&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;router-view&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
    data() {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
        
      }
    }
  }
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;app/index/components/home.vue 代码如下：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;='stylus'&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  .home-container
    width 100%
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;home-container&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;欢迎来到home页面&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;router-view&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;router-view&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
    data() {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
        msg: &lt;/span&gt;&lt;span&gt;''&lt;/span&gt;&lt;span&gt;
      }
    },
    methods: {
      
    }
  }
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;app/index/components/java.vue 代码如下：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;='stylus'&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  .java-container
    width 100%
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;java-container&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;欢迎来到java类书籍&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{msg}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
    data() {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
        msg: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;我是java组件&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
      }
    },
    methods: {
      
    }
  }
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;app/index/components/node.vue 代码如下：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;='stylus'&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  .node-container
    width 100%
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;node-container&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;欢迎来到node类书籍&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{msg}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
    data() {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
        msg: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;我是node组件&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
      }
    },
    methods: {
      
    }
  }
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;app/index/components/xxx.vue 代码如下：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;='stylus'&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  .xxx-container
    width 100%
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;xxx-container&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;欢迎来到xxx&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{msg}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
    data() {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
        msg: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;我是XXX组件&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
      }
    },
    created() {
      console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$route.params.id)
    }
  }
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;app/index/app.js 代码如下：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
import Vue from 'vue'&lt;span&gt;;

import Index from &lt;/span&gt;'./components/index'&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 引入路由&lt;/span&gt;
import router from './router'&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
  el: &lt;/span&gt;'#app'&lt;span&gt;,
  router: router,
  render: h &lt;/span&gt;=&amp;gt;&lt;span&gt; h(Index)
});

app&lt;/span&gt;/index/&lt;span&gt;router.js 代码如下：


import Vue from &lt;/span&gt;'vue'&lt;span&gt;;
import VueRouter from &lt;/span&gt;'vue-router'&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 告诉 vue 使用 vueRouter&lt;/span&gt;
&lt;span&gt;Vue.use(VueRouter);

const routes &lt;/span&gt;=&lt;span&gt; [
  {
    path: &lt;/span&gt;'/home'&lt;span&gt;,
    name: &lt;/span&gt;'home'&lt;span&gt;,
    component: resolve &lt;/span&gt;=&amp;gt; require(['./components/home'&lt;span&gt;], resolve)
  },
  {
    path: &lt;/span&gt;'/java'&lt;span&gt;,
    name: &lt;/span&gt;'java'&lt;span&gt;,
    component: resolve &lt;/span&gt;=&amp;gt; require(['./components/java'&lt;span&gt;], resolve)
  },
  {
    path: &lt;/span&gt;'/node'&lt;span&gt;,
    name: &lt;/span&gt;'node'&lt;span&gt;,
    component: resolve &lt;/span&gt;=&amp;gt; require(['./components/node'&lt;span&gt;], resolve)
  },
  {
    path: &lt;/span&gt;'/xxx'&lt;span&gt;,
    name: &lt;/span&gt;'xxx'&lt;span&gt;,
    component: resolve &lt;/span&gt;=&amp;gt; require(['./components/xxx'&lt;span&gt;], resolve)
  },
  {
    path: &lt;/span&gt;'*', &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 其他没有的页面都重定向到 home页面去&lt;/span&gt;
    redirect: '/home'&lt;span&gt;
  }
]

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; router = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; VueRouter({
  base: &lt;/span&gt;'', &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 配置单页应用的基路径&lt;/span&gt;
&lt;span&gt;  routes: routes,
  mode: &lt;/span&gt;'history'&lt;span&gt;
});

export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; router;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上就是所有的代码。然后就是webpack.config.js 代码了。&lt;/p&gt;
&lt;p&gt;webpack.config.js 代码我就不贴代码了，到时候大家可以看下github源码即可：&lt;/p&gt;
&lt;p&gt;package.json 代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&quot;scripts&quot;&lt;span&gt;: {
  &lt;/span&gt;&quot;dev&quot;: &quot;webpack-dev-server --progress --colors --devtool cheap-module-eval-source-map --hot --inline&quot;&lt;span&gt;,
  &lt;/span&gt;&quot;build&quot;: &quot;webpack --progress --colors --devtool cheap-module-source-map&quot;&lt;span&gt;
},&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在一切准备就绪完成后，我们运行 命令 npm run dev 后就可以启动我们的服务了，然后当我们访问：&lt;/p&gt;
&lt;p&gt;http://0.0.0.0:8083/java&lt;/p&gt;
&lt;p&gt;就可以看到如下信息了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201906/561794-20190619224109757-140796830.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是当我们刷新下 就变成如下了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201906/561794-20190619224131175-380221843.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;具体什么原因，请看我之前的&lt;a href=&quot;https://www.cnblogs.com/tugenhua0707/p/8127466.html&quot; target=&quot;_blank&quot;&gt;这篇文章&lt;/a&gt;解释. 我这边就不再描述了。因此现在我们需要在nginx上配置下即可。&lt;/p&gt;
&lt;p&gt;实现步骤. 我们首先 运行 npm run build 打包正式环境，然后在我们的项目根目录下会生成 dist 文件夹，然后再把我们生成的dist 文件夹的所有页面扔到nginx服务器下的html文件夹下。然后我们就需要在nginx上配置即可。&lt;/p&gt;
&lt;p&gt;首先执行 npm run build 打包，打包完成后，我们可以看到项目的根目录下有dist目录，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201906/561794-20190619224301535-946971851.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我们查看下 dist/index.html 页面，会把css和js自动加上去，代码如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201906/561794-20190619224310866-1123285344.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在我们需要把dist目录下的文件放到 nginx下的html文件夹下。因此我们需要移动目录了。&lt;/p&gt;
&lt;p&gt;我本地的nginx的html目录路径是如下：/usr/local/Cellar/nginx/1.15.12/html 如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201906/561794-20190619224330617-2026504955.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1. 我们先需要在该html目录下，新建一个文件夹，来保存所有的资源文件，假如我这边叫 vuedemo. 创建文件如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201906/561794-20190619224348042-221705066.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2. 我们现在把我们的打包的dist目录下的所有文件复制到 /usr/local/Cellar/nginx/1.15.12/html/vuedemo 目录下：先进入我们的项目根目录下，使用命令：&lt;strong&gt;cp -Rf dist/* /usr/local/Cellar/nginx/1.15.12/html/vuedemo&lt;/strong&gt;  如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201906/561794-20190619224409021-1775680608.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我们再查看下 /usr/local/Cellar/nginx/1.15.12/html/vuedemo 下的文件，看是否复制过来了没，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201906/561794-20190619224424743-1469460356.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在文件一切准备好了，现在我们需要在我们的nginx下配置即可：&lt;/p&gt;
&lt;p&gt;3. 使用 &lt;strong&gt;sudo open /usr/local/etc/nginx/nginx.conf -a 'sublime text'&lt;/strong&gt; 使用编辑器sublime打开)。&lt;/p&gt;
&lt;p&gt;然后在nginx.conf 配置信息如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
worker_processes  1&lt;span&gt;;
events {
    worker_connections  &lt;/span&gt;1024&lt;span&gt;;
}

http {
  include       mime.types;
  default_type  application&lt;/span&gt;/octet-stream;
&lt;span&gt;  sendfile        on;
  keepalive_timeout  &lt;/span&gt;65&lt;span&gt;;
  server {
    listen       &lt;/span&gt;8022&lt;span&gt;;
    server_name  xxx.abc.com;
    root html&lt;/span&gt;/vuedemo;
&lt;span&gt;    index index.html;
    location &lt;/span&gt;~ ^/favicon\.ico$ {
      root html/vuedemo;
&lt;span&gt;    }
    location &lt;/span&gt;/&lt;span&gt; {
      index index.html index.htm;
      try_files $uri $uri&lt;/span&gt;/&lt;span&gt; @fallback;
      add_header &lt;/span&gt;'Access-Control-Allow-Origin' '*'&lt;span&gt;;
      add_header &lt;/span&gt;'Access-Control-Allow-Credentials' 'true'&lt;span&gt;;
      add_header &lt;/span&gt;'Access-Control-Allow-Methods' 'GET, POST, OPTIONS'&lt;span&gt;;
      add_header &lt;/span&gt;'Access-Control-Allow-Headers' 'DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type'&lt;span&gt;;
      proxy_set_header   Host             $host;
      proxy_set_header   X&lt;/span&gt;-Real-&lt;span&gt;IP        $remote_addr;
      proxy_set_header   X&lt;/span&gt;-Forwarded-&lt;span&gt;For  $proxy_add_x_forwarded_for;
      proxy_set_header   X&lt;/span&gt;-Forwarded-&lt;span&gt;Proto  $scheme;
    }
    location @fallback {
      rewrite &lt;/span&gt;^.*$ /index.html break;
&lt;span&gt;    }
  }
  include servers&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1. 我们的vuedemo的路径是在nginx下的，如：/usr/local/Cellar/nginx/1.15.12/html/vuedemo 这个下的，vuedemo文件夹下是存放的是我们使用webpack打包所有的dist目录下的资源文件。如下所示：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201906/561794-20190619224538738-1374541381.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因此我们如上server中的root(根目录) 是从 html/vuedemo 文件开始的。index index.html 这样的，默认主页面是 index.html. try_files的基本语法我这边不再描述，有兴趣的话看我之前&lt;a href=&quot;https://www.cnblogs.com/tugenhua0707/p/8127466.html&quot; target=&quot;_blank&quot;&gt;这篇文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2. 是否注意到，我listen(监听的)是 8022，本来应该是80的，这样访问页面的时候就不用添加端口号，但是也不知道为什么我本地安装的nginx默认的端口号不是80，而是8080. 所以如果我监听80端口号的话，会有问题。因此这边先不管。&lt;/p&gt;
&lt;p&gt;如上配置完成后，我们就可以再页面上访问 http://xxx.abc.com:8022/home 就可以访问到页面了，不管我页面刷新多少次，都是这个页面；如下所示：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201906/561794-20190619224711124-1309736232.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击任何一个路由的话，比如点击java路由，再刷新的话也是可以的，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201906/561794-20190619224719209-1747240015.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因此nginx部署就完成了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：本地hosts文件需要绑定&lt;/strong&gt;  &lt;strong&gt;127.0.0.1   xxx.abc.com&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/tugenhua0707/webpack-all-demo/tree/master/webpack%2Bvue%2Brouter%2Bnginx%E9%85%8D%E7%BD%AE&quot; target=&quot;_blank&quot;&gt;github简单的源码查看&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 19 Jun 2019 14:49:00 +0000</pubDate>
<dc:creator>龙恩0707</dc:creator>
<og:description>在nginx上部署vue项目(history模式)--demo实列；</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tugenhua0707/p/11055512.html</dc:identifier>
</item>
<item>
<title>用Multisim实现彩灯循环控制器 - 菜白小系瓦</title>
<link>http://www.cnblogs.com/yaopeiyun/p/11055475.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yaopeiyun/p/11055475.html</guid>
<description>&lt;h2&gt;&lt;span&gt;2019/06/06&lt;/span&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;span&gt;！转载请注明出处&lt;/span&gt;&lt;/h2&gt;
&lt;h2&gt;1.设计任务目的与要求&lt;/h2&gt;
&lt;h4&gt;1.1 展示器件&lt;/h4&gt;
&lt;p&gt;10路彩灯分别用10个发光二极管L&lt;sub&gt;0&lt;/sub&gt;、L&lt;sub&gt;1&lt;/sub&gt;…..L&lt;sub&gt;9&lt;/sub&gt;模拟，发光二极管L&lt;sub&gt;0&lt;/sub&gt;、L&lt;sub&gt;1&lt;/sub&gt;…..L&lt;sub&gt;9&lt;/sub&gt;从左到右排列。&lt;/p&gt;
&lt;h4&gt;1.2 要求显示三种不同的花型&lt;/h4&gt;
&lt;p&gt;1)      10路彩灯按照L&lt;sub&gt;0&lt;/sub&gt;、L&lt;sub&gt;1&lt;/sub&gt;…..L&lt;sub&gt;9&lt;/sub&gt;的顺序依次点亮至全亮，再按照L&lt;sub&gt;9&lt;/sub&gt;、L&lt;sub&gt;8&lt;/sub&gt;…..L&lt;sub&gt;0&lt;/sub&gt;的顺序依次熄灭至全灭。&lt;/p&gt;
&lt;p&gt;2)      10路彩灯按照L&lt;sub&gt;0&lt;/sub&gt;L&lt;sub&gt;1&lt;/sub&gt;亮、L&lt;sub&gt;1&lt;/sub&gt; L&lt;sub&gt;2&lt;/sub&gt;亮、L&lt;sub&gt;2&lt;/sub&gt;L&lt;sub&gt;3&lt;/sub&gt;亮、…L&lt;sub&gt;8&lt;/sub&gt;L&lt;sub&gt;9&lt;/sub&gt;亮、L&lt;sub&gt;9&lt;/sub&gt;L&lt;sub&gt;0&lt;/sub&gt;亮的顺序轮流点亮。&lt;/p&gt;
&lt;p&gt;3)      10路彩灯按照L&lt;sub&gt;0&lt;/sub&gt;L&lt;sub&gt;9&lt;/sub&gt;、L&lt;sub&gt;1&lt;/sub&gt;L&lt;sub&gt;8&lt;/sub&gt;、L&lt;sub&gt;2&lt;/sub&gt;L&lt;sub&gt;7&lt;/sub&gt;、L&lt;sub&gt;3&lt;/sub&gt;L&lt;sub&gt;6&lt;/sub&gt;、L&lt;sub&gt;4&lt;/sub&gt;L&lt;sub&gt;5&lt;/sub&gt;的顺序依次点亮，然后按相反的顺序依次灭掉。&lt;/p&gt;
&lt;h4&gt;1.3 控制电路设有启动、切换、复位按钮&lt;/h4&gt;
&lt;p&gt;按下启动按钮，进入花型（1）并反复循环运行。按下切换按钮，进入花型（2）并反复循环运行；再次按下切换按钮，进入花型（3）并反复循环运行；再次按下切换按钮，则三个花型顺序运行并反复循环；若再次按下切换按钮，则又进入花型（1）并反复循环；不断按下切换按钮，则按上面顺序进行花型切换。任何时候按下复位按钮，全部灯灭。&lt;/p&gt;
&lt;h2&gt;2.模块及其原理介绍&lt;/h2&gt;
&lt;h4&gt;2.1 计数电路单元&lt;/h4&gt;
&lt;p&gt;该电路单元用74192计数器来实现。74192是双时钟十进制计数器。本电路用74192来实现0000—1001的十进制计数，同时用另外一个74192的来对第一片芯片进位进行计数，第二个芯片计数到2时同时对两个计数器进行清0操作。其电路图如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1476016/201906/1476016-20190619223146340-325718283.png&quot; alt=&quot;&quot; width=&quot;363&quot; height=&quot;475&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;2.2 编码电路单元&lt;/h4&gt;
&lt;p&gt;编码电路全局如图：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1476016/201906/1476016-20190619223318418-735509071.png&quot; alt=&quot;&quot; width=&quot;547&quot; height=&quot;562&quot;/&gt;&lt;/p&gt;
&lt;h5&gt;2.2.1 花型1编码电路&lt;/h5&gt;
&lt;p&gt;由于我最后灯泡的输出电路前面接了一个反相器，所以这里用0来表示灯泡亮。&lt;/p&gt;
&lt;p&gt;该序列对应了20种状态，这个序列的状态如表所示：&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot; align=&quot;left&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;94&quot;&gt;
&lt;p align=&quot;center&quot;&gt;A&lt;sub&gt;2&lt;/sub&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;D&lt;sub&gt;1&lt;/sub&gt;C&lt;sub&gt;1&lt;/sub&gt;B&lt;sub&gt;1&lt;/sub&gt;A&lt;sub&gt;1&lt;/sub&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;373&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;center&quot;&gt;L0 L1 L2 L3 L4 L5 L6 L7 L8 L9&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;94&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0000&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;373&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0 1 1 1 1 1 1 1 1 1&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;94&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0001&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;373&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0 0 1 1 1 1 1 1 1 1&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;94&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0010&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;373&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0 0 0 1 1 1 1 1 1 1&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;94&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0011&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;373&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0 0 0 0 1 1 1 1 1 1&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;94&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0100&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;373&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0 0 0 0 0 1 1 1 1 1&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;94&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0101&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;373&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0 0 0 0 0 0 1 1 1 1&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;94&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0110&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;373&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0 0 0 0 0 0 0 1 1 1&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;94&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0111&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;373&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0 0 0 0 0 0 0 0 1 1&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;94&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;1000&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;373&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0 0 0 0 0 0 0 0 0 1&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;94&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;1001&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;373&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0 0 0 0 0 0 0 0 0 0&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;94&quot;&gt;
&lt;p align=&quot;center&quot;&gt;1&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0000&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;373&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0 0 0 0 0 0 0 0 0 1&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;94&quot;&gt;
&lt;p align=&quot;center&quot;&gt;1&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0001&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;373&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0 0 0 0 0 0 0 0 1 1&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;94&quot;&gt;
&lt;p align=&quot;center&quot;&gt;1&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0010&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;373&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0 0 0 0 0 0 0 1 1 1&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;94&quot;&gt;
&lt;p align=&quot;center&quot;&gt;1&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0011&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;373&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0 0 0 0 0 0 1 1 1 1&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;94&quot;&gt;
&lt;p align=&quot;center&quot;&gt;1&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0100&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;373&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0 0 0 0 0 1 1 1 1 1&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;94&quot;&gt;
&lt;p align=&quot;center&quot;&gt;1&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0101&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;373&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0 0 0 0 1 1 1 1 1 1&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;94&quot;&gt;
&lt;p align=&quot;center&quot;&gt;1&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0110&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;373&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0 0 0 1 1 1 1 1 1 1&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;94&quot;&gt;
&lt;p align=&quot;center&quot;&gt;1&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0111&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;373&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0 0 1 1 1 1 1 1 1 1&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;94&quot;&gt;
&lt;p align=&quot;center&quot;&gt;1&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;1000&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;373&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0 1 1 1 1 1 1 1 1 1&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;94&quot;&gt;
&lt;p align=&quot;center&quot;&gt;1&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;1001&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;373&quot;&gt;
&lt;p align=&quot;center&quot;&gt;1 1 1 1 1 1 1 1 1 1&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;



























&lt;p&gt;　　根据表格可知，编号数较低的灯泡在编号数较高的灯泡亮时也必须亮，故可用与门将较低灯泡的电路与较高灯泡的输出电路相关联起来。&lt;/p&gt;
&lt;p&gt;为了实现三个花型的顺序输出，该自然序列显示电路还是要经过7442译码器和74153多路选择器。7442译码器的作用在于将4位BCD码的10组代码翻译成10个与十进制数字符号对应的输出信号，图中输入端ABCD为8421码，输出端O0N—O9N分别代表十进制数字0—9。74153是个双4路选择器，其功能是选择输出四个编码单元电路的值。本电路中用了5个74153来对应10个灯泡。74153的器件上用1C0和2C0来连接对应的输出端O0N—O9N。当74153器件的A和B为00时，顺序输出自然序列的值。最后经过指示灯和数码管显示出来。&lt;/p&gt;
&lt;p&gt;            &lt;img src=&quot;https://img2018.cnblogs.com/blog/1476016/201906/1476016-20190619223351073-1753274238.png&quot; alt=&quot;&quot; width=&quot;518&quot; height=&quot;209&quot;/&gt;&lt;/p&gt;

&lt;p&gt;与门实现电路截图：&lt;/p&gt;
&lt;p&gt;1）前10种状态：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1476016/201906/1476016-20190619223407320-1140054525.png&quot; alt=&quot;&quot; width=&quot;314&quot; height=&quot;421&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2）后10种状态&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1476016/201906/1476016-20190619223420246-704001163.png&quot; alt=&quot;&quot; width=&quot;472&quot; height=&quot;323&quot;/&gt;&lt;/p&gt;

&lt;h5&gt;2.2.2 花型2编码电路&lt;/h5&gt;
&lt;p&gt;为了使灯泡按照顺序01，12，23，34，45，56，67，78，89，90的输出，可以使用与门同时关联译码器对应的两种状态，比如L0要在计数器为0和9的时候亮。&lt;/p&gt;
&lt;p&gt;序列的状态如表：&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;211&quot;&gt;
&lt;p align=&quot;center&quot;&gt;DCBA&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;357&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;center&quot;&gt;L0 L1 L2 L3 L4 L5 L6 L7 L8 L9&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;211&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0000&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;357&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0 0 1 1 1 1 1 1 1 1&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;211&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0001&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;357&quot;&gt;
&lt;p align=&quot;center&quot;&gt;1 0 0 1 1 1 1 1 1 1&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;211&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0010&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;357&quot;&gt;
&lt;p align=&quot;center&quot;&gt;1 1 0 0 1 1 1 1 1 1&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;211&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0011&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;357&quot;&gt;
&lt;p align=&quot;center&quot;&gt;1 1 1 0 0 1 1 1 1 1&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;211&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0100&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;357&quot;&gt;
&lt;p align=&quot;center&quot;&gt;1 1 1 1 0 0 1 1 1 1&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;211&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0101&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;357&quot;&gt;
&lt;p align=&quot;center&quot;&gt;1 1 1 1 1 0 0 1 1 1&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;211&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0110&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;357&quot;&gt;
&lt;p align=&quot;center&quot;&gt;1 1 1 1 1 1 0 0 1 1&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;211&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0111&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;357&quot;&gt;
&lt;p align=&quot;center&quot;&gt;1 1 1 1 1 1 1 0 0 1&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;211&quot;&gt;
&lt;p align=&quot;center&quot;&gt;1000&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;357&quot;&gt;
&lt;p align=&quot;center&quot;&gt;1 1 1 1 1 1 1 1 0 0&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;211&quot;&gt;
&lt;p align=&quot;center&quot;&gt;1001&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;357&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0 1 1 1 1 1 1 1 1 0&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;电路截图：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1476016/201906/1476016-20190619223442696-891690637.png&quot; alt=&quot;&quot; width=&quot;464&quot; height=&quot;352&quot;/&gt;&lt;/p&gt;

&lt;h5&gt;2.2.3 花型3编码电路&lt;/h5&gt;
&lt;p&gt;       为了使按照L0L9、L1L8、L2L7、L3L6、L4L5的顺序依次点亮，然后按相反的顺序依次灭掉，要使用与门相关联。&lt;/p&gt;
&lt;p&gt;序列的状态如表：&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;206&quot;&gt;
&lt;p align=&quot;center&quot;&gt;DCBA&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;347&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;center&quot;&gt;L0 L1 L2 L3 L4 L5 L6 L7 L8 L9&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;206&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0000&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;347&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0 1 1 1 1 1 1 1 1 0&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;206&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0001&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;347&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0 0 1 1 1 1 1 1 0 0 &lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;206&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0010&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;347&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0 0 0 1 1 1 1 0 0 0&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;206&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0011&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;347&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0 0 0 0 1 1 0 0 0 0&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;206&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0100&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;347&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0 0 0 0 0 0 0 0 0 0&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;206&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0101&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;347&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0 0 0 0 1 1 0 0 0 0&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;206&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0110&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;347&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0 0 0 1 1 1 1 0 0 0&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;206&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0111&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;347&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0 0 1 1 1 1 1 1 0 0 &lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;206&quot;&gt;
&lt;p align=&quot;center&quot;&gt;1000&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;347&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0 1 1 1 1 1 1 1 1 0&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;206&quot;&gt;
&lt;p align=&quot;center&quot;&gt;1001&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;347&quot;&gt;
&lt;p align=&quot;center&quot;&gt;1 1 1 1 1 1 1 1 1 1&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;电路与门实现截图：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1476016/201906/1476016-20190619223458956-226812704.png&quot; alt=&quot;&quot; width=&quot;496&quot; height=&quot;374&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;2.3 花型控制端输出电路&lt;/h4&gt;
&lt;p&gt;       主要由加法器和一些基本门电路组成。AB从00-11计数，分别对应三个花型和三个花型循环播放，再结合前面计数电路单元中的第二个芯片A端输出0/1以及循环播放时控制花型的计数器芯片，可以画出对应的真值表：&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;10&quot;&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;359&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;QA（计数电路） QB QA （U3） QB QA (U63)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;194&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;center&quot;&gt;    A   B （多路选择器）&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;359&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;0        0 0             0 0&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;194&quot;&gt;
&lt;p&gt;0    0&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;359&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;1        0 0             0 0&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;194&quot;&gt;
&lt;p&gt;1    1&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;359&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;d        0 1             0 0&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;194&quot;&gt;
&lt;p&gt;0    1&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;359&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;d        1 0             0 0&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;194&quot;&gt;
&lt;p&gt;1    0&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;359&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;0        1 1             0 1&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;194&quot;&gt;
&lt;p&gt;0    0&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;359&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;1        1 1             0 1&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;194&quot;&gt;
&lt;p&gt;1    1&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;359&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;0        1 1             1 0&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;194&quot;&gt;
&lt;p&gt;0    1&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;359&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;1        1 1             1 1&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;194&quot;&gt;
&lt;p&gt;1    0&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;359&quot;&gt;
&lt;p&gt;其他&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;194&quot;&gt;
&lt;p&gt;d    d&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;可以画出对应的卡诺图：（这里为了便于区分将输入三个值设为D0 D1 D2，输出仍为A B）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1476016/201906/1476016-20190619223526389-929827178.png&quot; alt=&quot;&quot; width=&quot;637&quot; height=&quot;282&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;根据上图中AB的式子，在电路中用基本门连接到多路选择器的AB端。&lt;/p&gt;
&lt;h4&gt;2.4 彩灯显示电路&lt;/h4&gt;
&lt;p&gt;通过连接对应多路选择器的输出端口，再加一个非门，即可得到灯泡的亮灭情况。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1476016/201906/1476016-20190619223549156-1641268838.png&quot; alt=&quot;&quot; width=&quot;524&quot; height=&quot;164&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;2.5 几个按钮的功能实现&lt;/h4&gt;
&lt;h5&gt;2.5.1 启动按钮&lt;/h5&gt;
&lt;p&gt;通过控制计数电路单元两片计数器的清零来控制启动。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1476016/201906/1476016-20190619223612122-903670391.png&quot; alt=&quot;&quot; width=&quot;269&quot; height=&quot;334&quot;/&gt;&lt;/p&gt;
&lt;h5&gt;2.5.2 切换按钮&lt;/h5&gt;
&lt;p&gt;切换开关一次或点击空格，就相当于输出一次电平，可使计数器进行计数操作。&lt;/p&gt;
&lt;p&gt;当到达三个花型循环切换之后，再按一次，三种花型自动循环播放，通过另外一片74192来控制。&lt;/p&gt;
&lt;p&gt;       当U3计数到3时，U63进1，当记录状态的芯片计数到20时且U63为1时，U63进2，当记录状态计数到10时且U63为2或3时，U63计数。这几个通过基本逻辑门电路来实现。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1476016/201906/1476016-20190619223631009-450514984.png&quot; alt=&quot;&quot; width=&quot;738&quot; height=&quot;420&quot;/&gt;&lt;/p&gt;
&lt;h5&gt;2.5.3 复位按钮&lt;/h5&gt;
&lt;p&gt;每个灯泡前面连接着一个与门，只有当复位按钮连接高电平一端时灯泡才能正常显示，当复位按钮连接低电平一端时灯泡全部都熄灭。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1476016/201906/1476016-20190619223652784-758722392.png&quot; alt=&quot;&quot; width=&quot;230&quot; height=&quot;260&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;3.设计方案&lt;/h2&gt;
&lt;h4&gt;3.1 设计思路&lt;/h4&gt;
&lt;p&gt;根据老师给出的设计要求，彩灯循环控制器主要是完成10个灯泡的亮灭。由此可想到用74192计数器从0-9计数，可以分别对应每一种花型不同时刻下对应灯泡的亮灭情况。其中花型1较为特殊，需要计数两轮才能完成花型的展示。由于74192芯片的输出对应的是8421编码，可以用7442译码器将计数值输出。由于一共有三种花型，可以通过74153多路选择器来控制花型的切换。&lt;/p&gt;
&lt;h4&gt;3.2 设计框图及原理&lt;/h4&gt;
&lt;p&gt;彩灯循环控制器的结构框图：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1476016/201906/1476016-20190619223735520-730656128.png&quot; alt=&quot;&quot; width=&quot;646&quot; height=&quot;314&quot;/&gt;&lt;/p&gt;

&lt;p&gt;       该彩灯循环控制器的原理是：由方波信号发生器产生稳定的高频脉冲信号，作为计时基准。用两个计数器来实现电路计数，第一个花型需要20个状态来展示彩灯，故需要两片计数器，而另外两种花型只需要10个状态来实现花型，不考虑第二片计数器的位数。计数器的实时状态同时输出到数码管。接下来由译码器输出对应状态，通过不同的编码电路（主要由与门实现）接到对应的多路选择器。多路选择器的控制端由花型控制电路来控制，花型控制电路主要由两个计数器的低两位实现0-4计数和0-3计数，再结合前面计数电路的第二个芯片的输出值进行逻辑电路的设计完成选择器控制端相对应的值。由于74153有两个输出值，故本次一共需要5个多路选择器输出到对应的彩灯显示电路。&lt;/p&gt;
&lt;h4&gt;3.3 流程图&lt;/h4&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1476016/201906/1476016-20190619223751295-454320776.png&quot; alt=&quot;&quot; width=&quot;590&quot; height=&quot;260&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;3.4 总电路图&lt;/h4&gt;
&lt;p&gt;总电路如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1476016/201906/1476016-20190619223837506-23057320.png&quot; alt=&quot;&quot; width=&quot;882&quot; height=&quot;1084&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 19 Jun 2019 14:40:00 +0000</pubDate>
<dc:creator>菜白小系瓦</dc:creator>
<og:description>2019/06/06 ！转载请注明出处 1.设计任务目的与要求 1.1 展示器件 10路彩灯分别用10个发光二极管L0、L1…..L9模拟，发光二极管L0、L1…..L9从左到右排列。 1.2 要求显</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yaopeiyun/p/11055475.html</dc:identifier>
</item>
<item>
<title>golang开发:环境篇(五)实时加载工具gin的使用 - 飞翔码农</title>
<link>http://www.cnblogs.com/feixiangmanon/p/11055244.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/feixiangmanon/p/11055244.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;gin 工具是golang开发中非常有用且有效的工具，有效的提高了开发调试go程序的效率。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://img.pconline.com.cn/images/upload/upc/tx/itbbs/1402/24/c26/31530690_1393243456690.jpg&quot; alt=&quot;实时编译 gin&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;为什么要使用gin&quot;&gt;为什么要使用gin&lt;/h3&gt;
&lt;p&gt;我们知道golang是编译型语言，这就表示go程序的每次改动，如果需要查看改动结果都必须重新编译一次，即go build .像我们从事go web的开发，可能是从其他解释型语言跨过来的，就特别的不适应这种调试开发，改完代码需要编译go build。然后，gin的出现就为了解决这种需求。&lt;/p&gt;
&lt;p&gt;看下gin 的官方解释&lt;/p&gt;
&lt;p&gt;gin是一个简单的命令行实用程序，用于实时重新加载Go Web应用程序。 只需在您的应用程序目录中运行gin ，您的网络应用程序将以 gin 作为代理服务。 当gin检测到有代码更改时，它会自动重新编译代码。 您的应用将在下次收到HTTP请求时重新启动。&lt;/p&gt;
&lt;h3 id=&quot;安装-gin&quot;&gt;安装 gin&lt;/h3&gt;
&lt;p&gt;当然，第一是当然是在我们的虚拟机中安装 gin&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;vagrant ssh
go get github.com/codegangsta/gin

gin -h
NAME:
   gin - A live reload utility for Go web applications.

USAGE:
   gin [global options] command [command options] [arguments...]

VERSION:
   0.0.0

COMMANDS:
     run, r   Run the gin proxy in the current working directory
     env, e   Display environment variables set by the .env file
     help, h  Shows a list of commands or help for one command

GLOBAL OPTIONS:
   --laddr value, -l value       listening address for the proxy server [$GIN_LADDR]
   --port value, -p value        port for the proxy server (default: 3000) [$GIN_PORT]
   --appPort value, -a value     port for the Go web server (default: 3001) [$BIN_APP_PORT]
   --bin value, -b value         name of generated binary file (default: &quot;gin-bin&quot;) [$GIN_BIN]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;出现上面的提示信息表示安装成功了。&lt;/p&gt;
&lt;h3 id=&quot;使用gin&quot;&gt;使用gin&lt;/h3&gt;
&lt;p&gt;了解平常开发中使用最多的几个gin的命令&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;--laddr value, -l value       listening address for the proxy server [$GIN_LADDR]
监听代理服务器的地址 系统变量[$GIN_LADDR]
--port value, -p value        port for the proxy server (default: 3000)  [$GIN_PORT] 
代理服务器的端口号 默认3000 系统变量[$GIN_PORT] 
--appPort value, -a value     port for the Go web server (default: 3001)  [$BIN_APP_PORT]
转发给Go web服务的端口 默认3001 系统变量[$BIN_APP_PORT]
--bin value, -b value         name of generated binary file (default: &quot;gin-bin&quot;) [$GIN_BIN]
Go生成的二进制可执行文件的名称 默认gin-bin 系统变量[$GIN_BIN]
--path value, -t value        Path to watch files from (default: &quot;.&quot;)  [$GIN_PATH]
监听文件改动的目录 默认 . 系统变量[$GIN_PATH]
--build value, -d value       Path to build files from (defaults to same value as --path) [$GIN_BUILD]
编译Go 程序的目录 默认 . 系统变量[$GIN_BUILD]
--all                         reloads whenever any file changes, as opposed to reloading only on .go file change 系统变量[$GIN_ALL]
监听所有文件的修改，都会重新编译。如果不加all就只会监听go文件的修改 系统变量[$GIN_ALL]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以使用后面的系统变量名进行这些变量设置&lt;br/&gt;这几个命令掌握了基本平常开发就没啥问题了。&lt;/p&gt;
&lt;h3 id=&quot;举个栗子&quot;&gt;举个栗子&lt;/h3&gt;
&lt;p&gt;新建一个web服务&lt;br/&gt;看下Go的简单的web服务代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package main

import (
    &quot;fmt&quot;
    &quot;net/http&quot;
    &quot;log&quot;
)

func sayhelloName(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, &quot;Hello world!&quot;)
}

func main() {
    http.HandleFunc(&quot;/&quot;, sayhelloName)
    err := http.ListenAndServe(&quot;:9090&quot;, nil)
    if err != nil {
        log.Fatal(&quot;ListenAndServe: &quot;, err)
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码编译完成后，启动WEB服务后会监听9090端口。&lt;br/&gt;我们使用 gin 来编译启动这个服务&lt;br/&gt;我的物理机到虚拟机映射的是&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;192.168.0.10
配置
Vagrant.configure(&quot;2&quot;) do |config|
  config.vm.box = &quot;base&quot;
  config.vm.box_check_update = false
  config.vm.network &quot;forwarded_port&quot;, guest: 80, host: 8080
  config.vm.network &quot;private_network&quot;, ip: &quot;192.168.0.10&quot;
  config.vm.synced_folder &quot;/data/www&quot;,&quot;/data/www&quot;,create:true
  config.ssh.username = &quot;root&quot;
  config.ssh.private_key_path = &quot;/Users/XXX/.ssh/id_rsa&quot;
end&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们vagrant 登录虚拟机启动服务&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;sudo vagrant ssh
cd 项目目录
gin -p 3000 -a 9090 -b test.bin --all run
表示监听虚拟机的3000端口，将请求转发给9000端口，生成的二进制执行文件 test.bin，所有文件的改动都会引起项目编译&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然了上面的参数都是可以在后面添加的，path和build都在当前目录下，所以就使用默认的 .&lt;br/&gt;我们curl测试下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;curl http://192.168.0.10:3000
Hello world!&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们修改下输出文件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;fmt.Fprintf(w, &quot;Hello China!&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Ctrl+S保存的时候看到有编译的信息&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[gin] Building...
[gin] Build finished&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们再次测试下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;curl http://192.168.0.10:3000
Hello China!&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然了，我们也可以使用系统变量的方式，启动 gin服务&lt;br/&gt;创建test.sh&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;export GIN_PORT=&quot;3000&quot;
export BIN_APP_PORT=&quot;9090&quot;
export GIN_BIN=&quot;test.bin&quot;
export GIN_ALL=1
gin run

chmod +x test.sh
./test.sh&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;跟上面的命令行的结果一毛一样。&lt;/p&gt;
&lt;h3 id=&quot;完结&quot;&gt;完结&lt;/h3&gt;
&lt;p&gt;有了Gin之后，go web调试基本就跟PHP NODE等的解释型语言一样了，不用每次都go build之后再发请求测试，只需要启动 shell脚本，gin自动帮你在改动代码的时候编译。&lt;/p&gt;
&lt;p&gt;想要了接更多，关注下 gin的官方 说明&lt;br/&gt;&lt;a href=&quot;https://github.com/codegangsta/gin&quot; class=&quot;uri&quot;&gt;https://github.com/codegangsta/gin&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 19 Jun 2019 13:59:00 +0000</pubDate>
<dc:creator>飞翔码农</dc:creator>
<og:description>gin 工具是golang开发中非常有用且有效的工具，有效的提高了开发调试go程序的效率。 为什么要使用gin 我们知道golang是编译型语言，这就表示go程序的每次改动，如果需要查看改动结果都必须</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/feixiangmanon/p/11055244.html</dc:identifier>
</item>
</channel>
</rss>