<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>基于Springboot的BaseService和BaseController - 李成洪</title>
<link>http://www.cnblogs.com/c-lover/p/11380912.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/c-lover/p/11380912.html</guid>
<description>&lt;p&gt;基于Springboot的BaseService,BaseController&lt;/p&gt;
&lt;p&gt;前言：&lt;/p&gt;
&lt;p&gt;在做项目时需要对大量的表做增删查改，而其中的逻辑大同小异，所以抽象了一个 BaseService,BaseController来实现所有表的增删查改和一些公用的基础方法。&lt;/p&gt;
&lt;p&gt;UML类图：&lt;/p&gt;
&lt;p&gt;大体的思路就是在BaseService和BaseController中都使用泛型，到真正创建类的时候才知道具体的对象，对对象进行操作。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;p&gt;BaseEnity(需要使用BaseService方法的实体必须实现这些抽象方法)&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.honeywell.tms.entity.base;

public abstract class BaseEntity {
    public abstract boolean ValidateEmpty();
    public abstract boolean ValidateUnique();
    public abstract boolean AutoFill();
    public abstract Object getKey();
    public abstract String getText();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;BaseMapper&lt;/p&gt;
&lt;p&gt;逆向后得到的mapper方法都是相同的，所以我把它抽象出来了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.honeywell.tms.dao.base;

import com.honeywell.tms.entity.CompanyEntity;
import com.honeywell.tms.entity.base.BaseEntity;
import org.apache.ibatis.annotations.Param;

import java.util.List;
//所有被BaseService方法调用的dao都需要实现这个接口
public interface BaseMapper&amp;lt;E extends BaseEntity&amp;gt; {
    int deleteByPrimaryKey(@Param(value=&quot;ID&quot;)Object ID);//在Mapper文件中的占位符的关键字就是value的值

    int insert(E record);

    int insertSelective(E record);

    E selectByPrimaryKey(@Param(value=&quot;ID&quot;) Object ID);

    List&amp;lt;E&amp;gt; selectAll();

    int updateByPrimaryKeySelective(E record);

    int updateByPrimaryKey(E record);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;BaseService方法如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.honeywell.tms.service.base;

import com.github.pagehelper.PageHelper;
import com.github.pagehelper.PageInfo;
import com.honeywell.tms.dao.base.BaseMapper;
import com.honeywell.tms.entity.base.BaseEntity;
import com.honeywell.tms.entity.base.ResponseEntity;
import com.honeywell.tms.entity.base.ValueTextEntity;
import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

public class BaseService&amp;lt;E extends BaseEntity&amp;gt; {//一些提取了一些公用的Service方法，使用前必须通过init()方法注入相应的Mapper
    BaseMapper dao;

    //在子类构造函数中调用，指明具体的dao层
    public void init(BaseMapper mapper){
        dao=mapper;
    }
    //分页获取
    public ResponseEntity getByPage(int pageNum,int pageSize) {
        PageHelper.startPage(pageNum,pageSize,true);
        ResponseEntity responseEntity=new ResponseEntity();
        List&amp;lt;E&amp;gt;  pageList=dao.selectAll();//这个不是获取到的entity的集合了
        PageInfo&amp;lt;E&amp;gt; entityList=new PageInfo&amp;lt;&amp;gt;(pageList);
        pageList=entityList.getList();
        long count=entityList.getTotal();;
        responseEntity.setData(pageList);
        responseEntity.setTotal(String.valueOf(count));
        return  responseEntity;
    }

    //批量增加
    public ResponseEntity batchSave(List&amp;lt;E&amp;gt; list) {
        ResponseEntity responseEntity=new ResponseEntity();
        StringBuffer message=new StringBuffer();
        int row=0;
        for(E j:list){
            row++;
            if(!j.ValidateEmpty()){
                message.append(&quot;第&quot;+row+&quot;行插入失败,请检查是否有违规的空值+\n&quot;);
                continue;
            }
            if(!j.ValidateUnique()){
                message.append(&quot;第&quot;+row+&quot;行已经存在,插入失败\n&quot;);
            }
            j.AutoFill();
            dao.insert(j);
        }
        responseEntity.setMessage(message.toString());
        return responseEntity;
    }

    //批量更新
    public ResponseEntity batchUpdate(List&amp;lt;E&amp;gt; list) {
        ResponseEntity responseEntity=new ResponseEntity();
        StringBuffer message=new StringBuffer();
        int row=0;
        for(E j:list){
            row++;
            if(!j.ValidateEmpty()){
                message.append(&quot;第&quot;+row+&quot;行更新失败,请检查是否有违规的空值+\n&quot;);
                continue;
            }
            if(!j.ValidateUnique()) {
                message.append(&quot;第&quot; + row + &quot;行已经存在,更新失败\n&quot;);
            }
            j.AutoFill();
            StringToUUID(j);
            int back=dao.updateByPrimaryKeySelective(j);//不为空的才更新，为空的不更新。
            System.out.println(back);
        }
        responseEntity.setMessage(message.toString());
        return responseEntity;
    }

    //批量删除
    public ResponseEntity batchDestroy(List&amp;lt;E&amp;gt; list) {
        ResponseEntity responseEntity=new ResponseEntity();
        StringBuffer message=new StringBuffer();
        int row=0;
        for(E j:list) {
            row++;
            try{
                StringToUUID(j);
                int count=dao.deleteByPrimaryKey(j.getKey());
            }catch (Exception e){
                System.out.println(e.getMessage());
                message.append(&quot;第&quot;+row+&quot;删除失败,请先删除相关引用\n&quot;);
            }
        }
        responseEntity.setMessage(message.toString());
        return  responseEntity;
    }
    //获取ValueText模型
    public ResponseEntity getVTModel(){
        ResponseEntity responseEntity=new ResponseEntity();
        List&amp;lt;E&amp;gt; list=dao.selectAll();
        List&amp;lt;ValueTextEntity&amp;gt; vtList=new ArrayList&amp;lt;&amp;gt;();
        for(E j:list){
            ValueTextEntity  vtEntity=new ValueTextEntity();
            vtEntity.setText(j.getText());
            vtEntity.setValue(j.getKey().toString());
            vtList.add(vtEntity);
        }
        responseEntity.setListData(vtList);
        return  responseEntity;

    }
    //将前端页面传来的字符串转为UUID,前提条件是相应属性的名称必须包含&quot;ID&quot;
    public Object StringToUUID(Object obj ){
        Field[] fields=obj.getClass().getDeclaredFields();
        try {
            for (Field field : fields) {
                field.setAccessible(true);
                if (field.getName().contains(&quot;ID&quot;)) {
                    Object value = field.get(obj);
                    Object uid= UUID.fromString(value.toString());
                    field.set(obj,uid);
                }
            }
        }catch (Exception e){
            System.out.println(e.getMessage());
        }
        return null;
    }




}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;BaseController&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.honeywell.tms.controller.base;

import com.alibaba.fastjson.JSONArray;
import com.honeywell.tms.entity.CompanyEntity;
import com.honeywell.tms.entity.base.BaseEntity;
import com.honeywell.tms.entity.base.ResponseEntity;
import com.honeywell.tms.service.base.BaseService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

import javax.servlet.http.HttpServletRequest;
import java.lang.reflect.ParameterizedType;
import java.util.*;

public class BaseController&amp;lt;E extends BaseEntity&amp;gt; {
    private BaseService&amp;lt;E&amp;gt; service;
    private static  final String models=&quot;models&quot;;

    //初始化
    public void init(BaseService service){
        this.service=service;
    }
    //查询
    public  Map Read(HttpServletRequest request){
        String pageSkip=request.getParameter(&quot;pageSkip&quot;);
        String pageSize=request.getParameter(&quot;pageSize&quot;);
        int skip=Integer.valueOf(pageSkip);
        int size=Integer.valueOf(pageSize);
        int pageNum=skip/size+1;
        ResponseEntity responseEntity=service.getByPage(pageNum,size);
        return responseEntity.getMap();
    }

    //增加
    public Map Create(HttpServletRequest request){
        ResponseEntity responseEntity;//返回的实体
        List&amp;lt;E&amp;gt; dataList=getModel(request);
        responseEntity=service.batchSave(dataList);
        responseEntity.setData(dataList);
        return responseEntity.getMap();
    }

    //更新
    public Map Update(HttpServletRequest request){
        ResponseEntity responseEntity;//返回的实体
        List&amp;lt;E&amp;gt; dataList=getModel(request);
        responseEntity=service.batchUpdate(dataList);
        responseEntity.setData(dataList);
        return  responseEntity.getMap();
    }

    //删除
    public Map Destroy(HttpServletRequest request){
        ResponseEntity responseEntity;//返回的实体
        List&amp;lt;E&amp;gt; dataList=getModel(request);
        responseEntity=service.batchDestroy(dataList);
        return responseEntity.getMap();
    }

    //获取ValueText模型
    public List getVTModel(){
        ResponseEntity responseEntity=service.getVTModel();
        return  responseEntity.getListData();
    }

    //从request中获取实体
    public List&amp;lt;E&amp;gt; getModel(HttpServletRequest request){
        String json=request.getParameter(models);
        return JSONArray.parseArray(json,createModel());
    }


    //获取实列的类信息
    public Class createModel()  {
        try {
            ParameterizedType ptype = (ParameterizedType) this.getClass().getGenericSuperclass();
            Class clazz = (Class&amp;lt;E&amp;gt;) ptype.getActualTypeArguments()[0];
            E o = (E) clazz.newInstance();
            return  o.getClass();
        }catch (Exception e){
            System.out.println(e.getMessage());
        }
        return null;

    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用（用了公司这个实体举例）&lt;/p&gt;
&lt;p&gt;公司的实体：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.honeywell.tms.entity;


import com.honeywell.tms.dao.CompanyMapper;
import com.honeywell.tms.entity.base.BaseEntity;
import org.springframework.beans.factory.annotation.Autowired;


import java.util.Date;
import java.util.UUID;

public class CompanyEntity  extends BaseEntity {
    @Autowired
    CompanyMapper dao;


    private Object COMPANY_ID;


    private String COMPANY_CODE;


    private String COMPANY_NAME;


    private String COMPANY_ADDR;


    private String CREATED_BY;

    private String UPDATE_BY;

    private Date CREATED_DATE;

    private Date UPDATE_DATE;


    public Object getCOMPANY_ID() {
        return COMPANY_ID;
    }


    public void setCOMPANY_ID(Object COMPANY_ID) {
        this.COMPANY_ID=COMPANY_ID;
    }


    public String getCOMPANY_CODE() {
        return COMPANY_CODE;
    }


    public void setCOMPANY_CODE(String COMPANY_CODE) {
        this.COMPANY_CODE = COMPANY_CODE == null ? null : COMPANY_CODE.trim();
    }


    public String getCOMPANY_NAME() {
        return COMPANY_NAME;
    }


    public void setCOMPANY_NAME(String COMPANY_NAME) {
        this.COMPANY_NAME = COMPANY_NAME == null ? null : COMPANY_NAME.trim();
    }

    public String getCOMPANY_ADDR() {
        return COMPANY_ADDR;
    }


    public void setCOMPANY_ADDR(String COMPANY_ADDR) {
        this.COMPANY_ADDR = COMPANY_ADDR == null ? null : COMPANY_ADDR.trim();
    }


    public String getCREATED_BY() {
        return CREATED_BY;
    }


    public void setCREATED_BY(String CREATED_BY) {
        this.CREATED_BY = CREATED_BY == null ? null : CREATED_BY.trim();
    }


    public String getUPDATE_BY() {
        return UPDATE_BY;
    }


    public void setUPDATE_BY(String UPDATE_BY) {
        this.UPDATE_BY = UPDATE_BY == null ? null : UPDATE_BY.trim();
    }


    public Date getCREATED_DATE() {
        return CREATED_DATE;
    }


    public void setCREATED_DATE(Date CREATED_DATE) {
        this.CREATED_DATE = CREATED_DATE;
    }

    public Date getUPDATE_DATE() {
        return UPDATE_DATE;
    }


    public void setUPDATE_DATE(Date UPDATE_DATE) {
        this.UPDATE_DATE = UPDATE_DATE;
    }

    @Override
    public boolean ValidateEmpty() {
        if(this.COMPANY_CODE==null||this.COMPANY_CODE.equals(&quot;&quot;)){
            return false;
        }
        if(this.COMPANY_NAME==null||this.COMPANY_NAME.equals(&quot;&quot;)){
            return false;
        }
        return true;
    }
    @Override
    public boolean ValidateUnique() {
        return true;
    }

    @Override
    public boolean AutoFill(){
        //ID为空说明是新增操作,
        if(getCOMPANY_ID()==null){
            this.setCOMPANY_ID(UUID.randomUUID());
            this.setCREATED_BY(&quot;admin&quot;);
            this.setCREATED_DATE(new Date());
        }
        this.setUPDATE_BY(&quot;admin&quot;);
        this.setUPDATE_DATE(new Date());
        return  true;
    }

    @Override
    public Object getKey() {
        return this.COMPANY_ID;
    }
    @Override
    public String getText() {
        return this.COMPANY_NAME;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;公司的mapper,只需要继承BaseMapper&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.honeywell.tms.dao;

import com.honeywell.tms.dao.base.BaseMapper;
import com.honeywell.tms.entity.CompanyEntity;
import com.honeywell.tms.entity.base.BaseEntity;

public interface CompanyMapper extends BaseMapper&amp;lt;CompanyEntity&amp;gt; {

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;公司的Service&lt;/p&gt;
&lt;p&gt;(继承BaseService，指明相应的实体，构造注入相应的Service)&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.honeywell.tms.service;
import com.honeywell.tms.dao.CompanyMapper;
import com.honeywell.tms.entity.CompanyEntity;
import com.honeywell.tms.service.base.BaseService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;


@Service
public class CompanyService extends BaseService&amp;lt;CompanyEntity&amp;gt; {
    private CompanyMapper dao;//如果此处出现红色波浪线 Settings - Editor - Inspections - Spring - Spring Core - Code - Autowiring for Bean Class 勾去掉
    @Autowired
    public CompanyService(CompanyMapper mapper){//这里必须要使用构造注入。
        this.dao=mapper;
        init(dao);
    }



}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;公司的Controller&lt;/p&gt;
&lt;p&gt;(继承BaseController并构造注入相应的Service就行了，一定要构造注入哟。这里其实映射也可以写在BaseController里面，但是项目用了Swagger,它不支持。)&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.honeywell.tms.controller;

import com.honeywell.tms.controller.base.BaseController;
import com.honeywell.tms.entity.CompanyEntity;
import com.honeywell.tms.service.CompanyService;
import com.honeywell.tms.service.base.BaseService;
import com.honeywell.tms.utils.consts.Response;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.util.List;
import java.util.Map;

@Api(value=&quot;/Company&quot;,tags = &quot;公司模块&quot;)
@RestController
@RequestMapping(&quot;/Company&quot;)
public class CompanyController extends BaseController&amp;lt;CompanyEntity&amp;gt; {//继承BaseController后可以调用一些基本的方法,不过需要注入相应的Service
    private CompanyService service;
    @Autowired
    public CompanyController(CompanyService service){
        init(service);
    }

    @RequestMapping(&quot;/DownloadTemplate&quot;)
    @ApiOperation(value = &quot;公司模板下载&quot;,notes = &quot;直接下载excel模板&quot;)
    @ResponseBody
    public void DownloadTemplate(HttpServletResponse httpServletResponse){
       return;
    }

    @RequestMapping(&quot;/Read&quot;)
    public Map Read(HttpServletRequest request){
        return  super.Read(request);
    }
    @RequestMapping(&quot;Create&quot;)
    public Map Create(HttpServletRequest request){
        return  super.Create(request);
    }

    @RequestMapping(&quot;/Update&quot;)
    public Map Update(HttpServletRequest request){
        return super.Update(request);
    }

    @RequestMapping(&quot;/Destroy&quot;)
    public Map Destroy(HttpServletRequest request) {
        return super.Destroy(request);
    }

    @RequestMapping(&quot;/getVTModel&quot;)
    public List getVTModel(HttpServletRequest request){
        return super.getVTModel();
    }


}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;总结：总体来说较为满意的，能够实现基本的增删改查和一些基本的方法。缺点是大多都是用继承，没有面向接口编程。UML类图画的不够好，有什么意见或修改的地方请多多指教。&lt;/p&gt;
</description>
<pubDate>Tue, 20 Aug 2019 00:46:00 +0000</pubDate>
<dc:creator>李成洪</dc:creator>
<og:description>在项目中实现批量表的增删改查</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/c-lover/p/11380912.html</dc:identifier>
</item>
<item>
<title>ServerResponse（服务器统一响应数据格式） - 血夜之末</title>
<link>http://www.cnblogs.com/Tiancheng-Duan/p/11363437.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Tiancheng-Duan/p/11363437.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言：&lt;/h2&gt;
&lt;p&gt;其实严格来说，ServerResponse应该归类到common包中。但是我实在太喜欢这玩意儿了。而且用得也非常频繁，所以忍不住推荐一下。&lt;/p&gt;
&lt;p&gt;借此机会，申明一点，这个系列的类并不是都是我原创的，都是我从各个项目中看到的，感觉非常赞，一点点攒起来的。当然后面也有我自己写的一些工具。重要的是学习，从中学习到知识，就算脱离了这些工具，我们也可以自己写一个。&lt;/p&gt;
&lt;h2 id=&quot;场景&quot;&gt;场景：&lt;/h2&gt;
&lt;p&gt;这个场景我真的觉得只要写过接口的，都需要这个。&lt;/p&gt;
&lt;p&gt;其实，在刚刚接触代码的时候，看到大佬接口返回的JSON。JSON里面除了必要的data外，还有各种状态码，状态说明什么的，感觉很厉害。后来渐渐明白了，这个东西是必须的，你不写试试，看与你交互的大佬会不会把你拍成肉饼。&lt;/p&gt;
&lt;h2 id=&quot;演进&quot;&gt;演进：&lt;/h2&gt;
&lt;h3 id=&quot;直接返回请求的数据&quot;&gt;1.直接返回请求的数据：&lt;/h3&gt;
&lt;p&gt;后端：呀，前端发来的这个请求，数据库没有对应数据啊。返回一个null吧。&lt;/p&gt;
&lt;p&gt;前端：大哥，你返回给我一个null，是不是接口有问题啊？&lt;/p&gt;
&lt;p&gt;后端：那是你请求的数据在数据库中没有。&lt;/p&gt;
&lt;p&gt;前端：哦。那我知道了。&lt;/p&gt;
&lt;p&gt;后端：呀，前端发来的这个请求，参数不对啊（可能必要参数为空什么的）。我要返回null。&lt;/p&gt;
&lt;p&gt;前端：大哥，你给我返回个null，是数据库没有对应数据嘛？但是这个条件应该有数据啊。&lt;/p&gt;
&lt;p&gt;后端：不是的，你请求的参数有问题啊。&lt;/p&gt;
&lt;p&gt;前端：大哥，那你倒是给我要给回馈啊。否则，我还以为是你接口没数据呢。&lt;/p&gt;
&lt;p&gt;后端：好的吧。让我想想。&lt;/p&gt;
&lt;h3 id=&quot;返回一个对象resultvo包含data与codedata为请求的数据code为状态码&quot;&gt;2.返回一个对象ResultVo（包含data与code，data为请求的数据，code为状态码）：&lt;/h3&gt;
&lt;p&gt;后端：嘿，兄弟。我想到了一个好办法，我写了一个ResultVo，它是这样的……%￥&amp;amp;￥……。&lt;/p&gt;
&lt;p&gt;前端：好的。我了解了。&lt;/p&gt;
&lt;p&gt;后端：呀，前端发来的这个请求，没有足够的权限啊。我要返回data=null&amp;amp;code=10。然后在常量表中设置一下。&lt;/p&gt;
&lt;p&gt;前端：我刚刚无意间发现，你的code又增加了10，什么意思？&lt;/p&gt;
&lt;p&gt;后端：啊。忘了告诉你了。code=10表示权限不足。&lt;/p&gt;
&lt;p&gt;前端：那我需要就这个情况，给用户提供专门的说明呀。&lt;/p&gt;
&lt;p&gt;后端：这样效率太低了。而且以后可能会有更复杂多变的情况。我得想想办法。&lt;/p&gt;
&lt;h3 id=&quot;返回一个对象resultvo2新增msg属性充当响应的说明&quot;&gt;3.返回一个对象ResultVo2（新增msg属性，充当响应的说明）：&lt;/h3&gt;
&lt;p&gt;后端：嘿，兄弟。我将原来的ResultVo进行了升级，它是这样的&amp;amp;……%&amp;amp;%&amp;amp;……。&lt;/p&gt;
&lt;p&gt;前端：这挺不错的，以后很多地方，我可以直接显示msg就行了。但是，现在有一个问题，现在的code太多了。我每次进行处理时都要遍历判断，而我常常只需要判断这个响应是否成功了。&lt;/p&gt;
&lt;p&gt;后端：这样啊。我还得再改进一下。&lt;/p&gt;
&lt;h3 id=&quot;serverresponse&quot;&gt;4.ServerResponse:&lt;/h3&gt;
&lt;p&gt;后端：请教大佬后，我得到了非常棒的解决方案。并且，我根据自己的业务情况，进行细微的调整，这下就没什么问题了。&lt;/p&gt;
&lt;p&gt;前端&amp;amp;后端：我们感受到了效率的显著提升，以及最为重要的代码规范（契约）。&lt;/p&gt;
&lt;h2 id=&quot;作用&quot;&gt;作用：&lt;/h2&gt;
&lt;p&gt;ServerResponse就是用来统一服务器接口调用的响应&lt;/p&gt;
&lt;h2 id=&quot;代码&quot;&gt;代码：&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    
    package tech.jarry.learning;
    
    
    import lombok.AllArgsConstructor;
    import lombok.NoArgsConstructor;
    import lombok.RequiredArgsConstructor;
    import org.codehaus.jackson.annotate.JsonIgnore;
    import org.codehaus.jackson.map.annotate.JsonSerialize;
    
    import java.io.Serializable;
    
    /**
     * @Author: jarry
     */
    // 确保序列化JSON时，如果是null对象，其key也会消失。
    @JsonSerialize(include = JsonSerialize.Inclusion.NON_NULL)
    // 生成无参构造，确保在RPC调用时，不会出现反序列失败
    @NoArgsConstructor
    public class ServerResponse&amp;lt;T&amp;gt; implements Serializable {
    
        private int status;
        private String msg;
        private T data;
    
        private ServerResponse(int status) {
            this.status = status;
        }
    
        private ServerResponse(int status, String msg) {
            this.status = status;
            this.msg = msg;
        }
    
        //  这里存在一个问题，如果构造函数传入的参数列表为(int,String)，那么是调用上面的（int,String），还是这里的（int,T)，毕竟T作为泛型是可以表示String的
        //  答案是调用上面的（int,String)（可以理解为上面的是专业的）。那么有时候data作为T类型传入的就是String啊，岂不是就出问题了。这里会在下方对应的public函数处理
        private ServerResponse(int status, T data) {
            this.status = status;
            this.data = data;
        }
    
        private ServerResponse(int status, String msg, T data) {
            this.status = status;
            this.msg = msg;
            this.data = data;
        }
    
        //    使之不在JSON序列化结果当中
        @JsonIgnore
        // 可以快速进行成功与否的条件判断
        public boolean isSuccess() {
            return this.status == ResponseCode.SUCCESS.getCode();
        }
    
        @JsonIgnore
        // 可以快速进行成功与否的条件判断，判断false时，不用加!。囧
        public boolean isFail() {
            return this.status != ResponseCode.SUCCESS.getCode();
        }
    
        public int getStatus() {
            return status;
        }
    
        public String getMsg() {
            return msg;
        }
    
        public T getData() {
            return data;
        }
    
        // 快速构建返回结果
        //    成功时的调用
        public static &amp;lt;T&amp;gt; ServerResponse&amp;lt;T&amp;gt; createBySuccess() {
            return new ServerResponse&amp;lt;T&amp;gt;(ResponseCode.SUCCESS.getCode());
        }
    
        public static &amp;lt;T&amp;gt; ServerResponse&amp;lt;T&amp;gt; createBySuccessMessage(String msg) {
            return new ServerResponse&amp;lt;T&amp;gt;(ResponseCode.SUCCESS.getCode(), msg);
        }
    
        public static &amp;lt;T&amp;gt; ServerResponse&amp;lt;T&amp;gt; createBySuccess(T data) {
            return new ServerResponse&amp;lt;T&amp;gt;(ResponseCode.SUCCESS.getCode(), data);
        }
    
        public static &amp;lt;T&amp;gt; ServerResponse&amp;lt;T&amp;gt; createBySuccess(String msg, T data) {
            return new ServerResponse&amp;lt;T&amp;gt;(ResponseCode.SUCCESS.getCode(), msg, data);
        }
    
        //    失败时的调用
        public static &amp;lt;T&amp;gt; ServerResponse&amp;lt;T&amp;gt; createByError() {
            return new ServerResponse&amp;lt;T&amp;gt;(ResponseCode.ERROR.getCode(), ResponseCode.ERROR.getDesc());
        }
    
        public static &amp;lt;T&amp;gt; ServerResponse&amp;lt;T&amp;gt; createByErrorMessage(String errorMessage) {
            return new ServerResponse&amp;lt;T&amp;gt;(ResponseCode.ERROR.getCode(), errorMessage);
        }
    
        public static &amp;lt;T&amp;gt; ServerResponse&amp;lt;T&amp;gt; createByErrorCodeMessage(int errorCode, String errorMessage) {
            return new ServerResponse&amp;lt;T&amp;gt;(errorCode, errorMessage);
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;依赖&quot;&gt;依赖：&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://search.maven.org/artifact/org.projectlombok/lombok/1.18.8/jar&quot;&gt;lombok&lt;/a&gt;（绝对的效率工具，值得推荐）&lt;/p&gt;
&lt;h2 id=&quot;应用&quot;&gt;应用：&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    
    package tech.jarry.learning.terminal.client;
    
    import com.renewable.terminal.terminal.common.ServerResponse;
    import com.renewable.terminal.terminal.entity.Terminal;
    import org.springframework.cloud.openfeign.FeignClient;
    import org.springframework.stereotype.Component;
    import org.springframework.web.bind.annotation.GetMapping;
    import org.springframework.web.bind.annotation.PostMapping;
    import org.springframework.web.bind.annotation.RequestBody;
    import org.springframework.web.bind.annotation.ResponseBody;
    
    import java.util.List;
    
    /**
     * @Description：通过feign，对外提供termina服务的调用接口
     * @Author: jarry
     */
    @FeignClient(name = &quot;terminal&quot;, fallback = TerminalClient.TerminalClientFallback.class)
    
    public interface TerminalClient {
    
        @PostMapping(&quot;/terminal/update_from_center.do&quot;)
        ServerResponse updateTerminalFromCenter(@RequestBody Terminal terminal);
    
        @PostMapping(&quot;/terminal/update.do&quot;)
        ServerResponse updateTerminal(@RequestBody Terminal terminal);
    
        @GetMapping(&quot;/terminal/refresh.do&quot;)
        ServerResponse refreshTerminal();
    
        @Component
        public static class TerminalClientFallback implements TerminalClient {
            @Override
            public ServerResponse updateTerminalFromCenter(@RequestBody Terminal terminal){
                return ServerResponse.createByErrorMessage(&quot;Busy service about Terminal/updateTerminalFromCenter().&quot;);
            }
    
            @Override
            public ServerResponse updateTerminal(Terminal terminal) {
                return ServerResponse.createByErrorMessage(&quot;Busy service about Terminal/updateTerminal().&quot;);
            }
    
            @Override
            public ServerResponse refreshTerminal(){
                return ServerResponse.createByErrorMessage(&quot;Busy service about Terminal/refreshTerminal().&quot;);
            }
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    package tech.jarry.learning.terminal.controller;
    
    
    import com.renewable.terminal.message.client.TerminalMessageClient;
    import com.renewable.terminal.terminal.common.ServerResponse;
    import com.renewable.terminal.terminal.entity.Terminal;
    import com.renewable.terminal.terminal.service.ITerminalService;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.web.bind.annotation.*;
    
    
    /**
     * &amp;lt;p&amp;gt;
     * 前端控制器
     * &amp;lt;/p&amp;gt;
     *
     * @author jarry
     * @since 2019-07-22
     */
    @RestController
    @RequestMapping(&quot;/terminal/&quot;)
    public class TerminalController {
    
        @Autowired
        private ITerminalService iTerminalService;
    
        @GetMapping(&quot;get_terminal.do&quot;)
        @ResponseBody
        public ServerResponse getTerminal(){
            return iTerminalService.getTerminal();
        }
    
        @PostMapping(&quot;update.do&quot;)
        @ResponseBody
        public ServerResponse updateTerminal(@RequestBody Terminal terminal){
            boolean result = iTerminalService.updateById(terminal);
            iTerminalService.refresh();
            if (!result){
                return ServerResponse.createByErrorMessage(&quot;fail !&quot;);
            }
            return ServerResponse.createBySuccess(terminal);
        }
        @PostMapping(&quot;update_from_center.do&quot;)
        @ResponseBody
        public ServerResponse updateTerminalFromCenter(@RequestBody Terminal terminal){
            boolean result = iTerminalService.updateById(terminal);
            if (!result){
                return ServerResponse.createByErrorMessage(&quot;fail !&quot;);
            }
            return ServerResponse.createBySuccessMessage(&quot;success&quot;);
        }
    
        @GetMapping(&quot;refresh.do&quot;)
        @ResponseBody
        public ServerResponse refreshTerminal(){
            return iTerminalService.refresh();
        }
    
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;问题&quot;&gt;问题：&lt;/h2&gt;
&lt;p&gt;在使用ServerResponse的过程中，曾经遇到一个问题。&lt;br/&gt;那就是ServerResponse在SpringCloud架构中的Feign中的RPC调用中，无法进行反序列化。&lt;br/&gt;找到的解释是，缺乏无参构造器（如果类中具有任意构造器，JVM就不会提供默认的无参构造器）。&lt;br/&gt;所以在类的开头增加了@NoArgsConstructor，使得类具备无参构造器，问题解决。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结：&lt;/h2&gt;
&lt;p&gt;作为服务器响应的统一数据格式，网上有很多的写法。这个ServerResponse也不一定是最好的。即使是最好的，也不一定是最适合你的。&lt;/p&gt;
&lt;p&gt;往往我们在项目中需要一些工具实现一些特定功能，在实现功能之后，都或多或少会对现有的工具做一些调整，使得其更适合自己现有项目。&lt;/p&gt;
&lt;p&gt;所以说，最好的不一定最适合。我们需要根据现有的情况，进行调整，重构，乃至自研。&lt;/p&gt;
&lt;h2 id=&quot;题外话&quot;&gt;题外话：&lt;/h2&gt;
&lt;p&gt;偷偷地推荐一下自己的&lt;a href=&quot;http://blog.jarry.tech&quot;&gt;个人博客&lt;/a&gt;。目前这个博客还处于测试阶段。还有很多的调整，之后还会与我自己微信公众号绑定，目测需要到今年下半年，才能全部完成。囧。有什么意见也可以提一提。&lt;/p&gt;
&lt;p&gt;另外，由于还在测试阶段，所以如果哪天看不了，实属正常。囧&lt;/p&gt;
</description>
<pubDate>Tue, 20 Aug 2019 00:38:00 +0000</pubDate>
<dc:creator>血夜之末</dc:creator>
<og:description>'ServerResponse（服务器统一响应数据格式）' 前言： 其实严格来说，ServerResponse应该归类到common包中。但是我实在太喜欢这玩意儿了。而且用得也非常频繁，所以忍不住推荐</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Tiancheng-Duan/p/11363437.html</dc:identifier>
</item>
<item>
<title>如何参与一个顶级开源项目 - crossoverJie</title>
<link>http://www.cnblogs.com/crossoverJie/p/11380889.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/crossoverJie/p/11380889.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431471/201908/1431471-20190820083542036-886907269.jpg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;最近个人事情比较多（搬家、换工作、短暂休息）所以一直也没有顾得上博客更新，恰好最近收到一封邮件提醒了我。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431471/201908/1431471-20190820083542716-2073634213.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也是时候写一篇文章来聊聊参与开源项目的事（最近也确实进入了笔荒期）。&lt;/p&gt;
&lt;p&gt;ps:第一次收到这样的中秋节礼物，加上 &lt;code&gt;Dubbo&lt;/code&gt; 社区的活跃及阿里的重视度，还在做 &lt;code&gt;PRC&lt;/code&gt; 或微服务技术选型的朋友可以考虑 &lt;code&gt;Dubbo&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;现在具体来聊聊参与开源的事；&lt;/p&gt;
&lt;p&gt;日常几乎所有的开发者都会享受到开源项目所带来的便利甚至是收益，受限于环境早在十几年前甚至几年前开源活动一直都是有国外开发者主导。&lt;/p&gt;
&lt;p&gt;但这几年国内互联网公司逐渐国际化扩大影响力也很大程度的提高了我们的开发水平，以 &lt;code&gt;BAT&lt;/code&gt; 为首出现了许多优秀的开源项目。&lt;/p&gt;
&lt;p&gt;现在甚至参与开源项目还能另辟蹊径的拿到大厂 &lt;code&gt;offer&lt;/code&gt;，所以其实不少朋友都想参与其中，可能这事给人的第一感觉就不太容易，所以现在还卡在第一步。&lt;/p&gt;
&lt;h2 id=&quot;具体步骤&quot;&gt;具体步骤&lt;/h2&gt;
&lt;p&gt;以下是以我个人经验总结的几大步骤：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;发现问题或自荐 &lt;code&gt;feature&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;fork 源码。&lt;/li&gt;
&lt;li&gt;本地开发、自测。&lt;/li&gt;
&lt;li&gt;发起 &lt;code&gt;pull request&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;等待社区 &lt;code&gt;Code Review&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;跟进社区意见调整代码。&lt;/li&gt;
&lt;li&gt;审核通过，合并进 &lt;code&gt;master&lt;/code&gt; 分支，完成本次贡献。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面我会结合最近一次参与 &lt;code&gt;Dubbo&lt;/code&gt; 的流程来具体聊聊。&lt;/p&gt;
&lt;h3 id=&quot;发现问题或自荐-feature&quot;&gt;发现问题或自荐 feature&lt;/h3&gt;
&lt;p&gt;首先第一步自然要搞清楚自己本次贡献的内容是什么？通常都是解决某个问题或者是提交一个新的 &lt;code&gt;feature&lt;/code&gt; ；前者相对起来更加容易一些。&lt;/p&gt;
&lt;p&gt;当然这个问题可以是自己使用过程中发现的，也可以是 Issues 列表中待解决的问题。&lt;/p&gt;
&lt;p&gt;以本次为例，就是我在使用过程中所发现的问题，也提交了相关 &lt;a href=&quot;https://github.com/apache/dubbo/issues/4556&quot;&gt;Issue&lt;/a&gt; 并写了一篇文章记录并解决了该问题：&lt;a href=&quot;https://crossoverjie.top/2019/07/05/troubleshoot/dubbo-start-slow/&quot;&gt;What？一个 Dubbo 服务启动要两个小时！&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;值得注意的是在提交 Issue 之前最好是先在 Issue 列表中通过关键字检索下是否已经有相关问题，避免重复。&lt;/p&gt;
&lt;p&gt;同时提交之后也许社区会进行跟进，被打上 &lt;code&gt;invalid&lt;/code&gt; 标签认为不是问题，或者是使用姿势不对也是有可能的。&lt;/p&gt;
&lt;h3 id=&quot;fork-源码本地开发&quot;&gt;fork 源码，本地开发&lt;/h3&gt;
&lt;p&gt;当确定这是一个待修复的问题时就可以着手开发了。&lt;/p&gt;
&lt;p&gt;首先第一步自然是将源码拷贝一份到自己仓库中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431471/201908/1431471-20190820083543740-815276149.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接着只需要 clone 自己仓库中的源码到本地进行开发。&lt;/p&gt;
&lt;p&gt;先回顾下我遇到的这个问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431471/201908/1431471-20190820083545915-651931355.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;简单来说就是启动 &lt;code&gt;Dubbo&lt;/code&gt; 服务非常缓慢，经过定位是 &lt;code&gt;main&lt;/code&gt; 线程阻塞在了获取本机 ip 处。&lt;/p&gt;
&lt;p&gt;所以当时我提出的方案是：在获取本机 ip 时加上超时时间，一旦超时便抛出异常或者是再次重试，但起码得有日志方便用户定位问题。&lt;/p&gt;
&lt;p&gt;问题是主线程会一直阻塞在此处 &lt;code&gt;InetAddress.getLocalHost().getHostAddress()&lt;/code&gt;，但又需要知道它阻塞了多久才好判断是否超时。&lt;/p&gt;
&lt;p&gt;所以只能再额外开启一个线程，定时去检测 &lt;code&gt;main&lt;/code&gt; 线程是否已经完成任务了，以下便是我第一次 pr 的内容。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431471/201908/1431471-20190820083548031-1666907627.jpg&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431471/201908/1431471-20190820083549144-1398422824.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这次的重点不是讨论这里具体的技术细节，所以简单说下步骤：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;额为声明了大小为 1 的线程池。&lt;/li&gt;
&lt;li&gt;再声明了一个 &lt;code&gt;volatile&lt;/code&gt; 标志用于判断主线程是否有完成任务。&lt;/li&gt;
&lt;li&gt;声明了一个 condition 用于新线程做等待。&lt;/li&gt;
&lt;li&gt;最后只需要运行这个线程用于判断这个标志即可。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;如何自测&quot;&gt;如何自测&lt;/h3&gt;
&lt;p&gt;开发完成后下一步就是自测，由于这类项目是作为一个基础包依赖于其他的项目才能运行的，所以通常我们还得新建一个项目来配合做全流程测试（单测除外）。&lt;/p&gt;
&lt;p&gt;这里我觉得还是有几个小技巧值得注意。&lt;/p&gt;
&lt;p&gt;第一个是版本号；因为在本地测试，所以需要使用 &lt;code&gt;mvn clean install&lt;/code&gt; 将包安装到本地才能在其他项目中依赖进去进行测试。&lt;/p&gt;
&lt;p&gt;但由于我们从官方拉出来的代码版本都已经发布到了 maven 中央仓库中（不管是 release 还是 snapshot），所以我们本地仓库中肯定已经存在这几个版本的 jar 包。&lt;/p&gt;
&lt;p&gt;一旦我们执行 &lt;code&gt;mvn clean install&lt;/code&gt; 将自己修改的代码安装到本地时，大概率是会出问题的（也可能是我姿势不对），这样就会导致新建的项目中依赖不了自己新增的代码。&lt;/p&gt;
&lt;p&gt;所以我通常的做法是修改版本号，这个版本号是从来没有被官方发布到中央仓库中的，可以确保自己新增的代码会以一个全新版本安装到本地，这样我们再依赖这个版本进行测试即可。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;不过再提交时得注意不要把这个版本号提交上去了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;发起-pull-request&quot;&gt;发起 pull request&lt;/h3&gt;
&lt;p&gt;自测完成后便可发起 &lt;code&gt;pull request&lt;/code&gt; 了，不要大意，这里还得有一个地方需要注意，那就是代码换行符的问题。&lt;/p&gt;
&lt;p&gt;一旦换行符与源仓库的不一致时，&lt;code&gt;git&lt;/code&gt; 会认为这次修改是删除后重来的，这样会给 &lt;code&gt;code review&lt;/code&gt; 带来巨大的麻烦。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431471/201908/1431471-20190820083550655-819944797.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;就像这样，明明我改动的行数并不多，但 &lt;code&gt;git&lt;/code&gt; 确认为你是推翻了重来，导致审核起来根本不知道你改了哪些地方。&lt;/p&gt;
&lt;p&gt;最简单的方法就是设置自己 &lt;code&gt;git&lt;/code&gt; 的全局配置，可以参考&lt;a href=&quot;http://kuanghy.github.io/2017/03/19/git-lf-or-crlf&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# 提交时转换为LF，检出时转换为CRLF
git config --global core.autocrlf true

# 提交时转换为LF，检出时不转换
git config --global core.autocrlf input

# 提交检出均不转换
git config --global core.autocrlf false&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431471/201908/1431471-20190820083551293-511612141.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;确认没问题后便可点击这里发起 pull request，后面按照引导执行即可。&lt;/p&gt;
&lt;p&gt;当然各个项目之间还会有自己定制的贡献流程，最好就是查看官方的贡献指南。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dubbo.apache.org/en-us/docs/developers/contributor-guide/new-contributor-guide_dev.html&quot; class=&quot;uri&quot;&gt;http://dubbo.apache.org/en-us/docs/developers/contributor-guide/new-contributor-guide_dev.html&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;code-review&quot;&gt;Code Review&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;pr&lt;/code&gt; 发起后便可等待社区审核了。&lt;/p&gt;
&lt;p&gt;在这过程中要充分和社区进行交流，有可能你的方案和社区的想法并不一致。&lt;/p&gt;
&lt;p&gt;比如像我这次：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431471/201908/1431471-20190820083552506-412098097.jpg&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431471/201908/1431471-20190820083553036-796927109.jpg&quot;/&gt;&lt;br/&gt;最终通过沟通加上自己后面的思考觉得还是社区的方案更加轻便合理一些，达成一致之后社区便将这次 pr 合并进 master 中。&lt;/p&gt;
&lt;p&gt;其实整个过程我觉得最有意义的便是 &lt;code&gt;code review&lt;/code&gt; 的过程，所有人都可以参与其中头脑风暴，其中也不乏技术大牛，不知不觉便能学到不少东西。&lt;/p&gt;
&lt;h2 id=&quot;类似案例&quot;&gt;类似案例&lt;/h2&gt;
&lt;p&gt;虽然我之前的方案没有被采纳，但类似的用法（一个线程监控其他线程）还是不少，正好在 &lt;code&gt;Dubbo&lt;/code&gt; 中也有用到。&lt;/p&gt;
&lt;p&gt;便是其中核心的服务调用，默认情况下对使用者来说这看起来是一个同步调用，也就是说消费方会等待 PRC 执行完毕后才会执行后续逻辑。&lt;/p&gt;
&lt;p&gt;但其实在底层这就是一个 &lt;code&gt;TCP&lt;/code&gt; 网络包的发送过程，&lt;strong&gt;本身就是异步的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;只是 &lt;code&gt;Dubbo&lt;/code&gt; 在你不知道的情况下做了异步转同步，这样看起来就像是一个同步方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431471/201908/1431471-20190820083554406-1701729852.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如图中的红框部分，&lt;code&gt;Dubbo&lt;/code&gt; 自身调用了 &lt;code&gt;get()&lt;/code&gt; 方法用于同步获取服务提供者的返回结果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431471/201908/1431471-20190820083555187-810968124.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;逻辑其实也挺简单，和我上文的方案类似，只是这里的 &lt;code&gt;isDone()&lt;/code&gt; 函数返回的是是否已经拿到了服务提供者的返回值而已。&lt;/p&gt;

&lt;p&gt;本次总结了参与开源的具体步骤，其实也挺简单；就如官方所说哪怕是提个 Issue，修改一个错别字都算是参与，所以不要想的太难。&lt;/p&gt;
&lt;p&gt;最后还简单分析了 Dubbo 调用过程中的异步转同步的过程，掌握这些操作对自己平时开发也是很有帮助的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;你的点赞与分享是对我最大的支持&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 20 Aug 2019 00:36:00 +0000</pubDate>
<dc:creator>crossoverJie</dc:creator>
<og:description>前言 最近个人事情比较多（搬家、换工作、短暂休息）所以一直也没有顾得上博客更新，恰好最近收到一封邮件提醒了我。 也是时候写一篇文章来聊聊参与开源项目的事（最近也确实进入了笔荒期）。 ps:第一次收到这</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/crossoverJie/p/11380889.html</dc:identifier>
</item>
<item>
<title>Java Socket：飞鸽传书的网络套接字 - 沉默王二</title>
<link>http://www.cnblogs.com/qing-gee/p/11380884.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qing-gee/p/11380884.html</guid>
<description>&lt;p&gt;在古代，由于通信不便利，一些聪明的人就利用鸽子会飞且飞得比较快、会辨认方向的优点，对其进行了驯化，用来进行消息的传递——也就是所谓的“飞鸽传书”。而在 Java 中，网络套接字（Socket）扮演了同样的角色。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://upload-images.jianshu.io/upload_images/1179389-1d1e7e87e4a5e346.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;套接字（Socket）是一个抽象层，应用程序可以通过它发送或接收数据；就像操作文件那样可以打开、读写和关闭。套接字允许应用程序将 I/O 应用于网络中，并与其他应用程序进行通信。网络套接字是 IP 地址与端口的组合。&lt;/p&gt;
&lt;h3 id=&quot;h01pingtelnet&quot;&gt;01、ping 与 telnet&lt;/h3&gt;
&lt;p&gt;“老王啊，能不能帮我看一下这个问题呢，明明本地可以进行网络通信，可等我部署到服务器上时就通信不了了，搞了半天也不知道什么原因，我看代码是没有问题的。”小二的语气中充满了沮丧。&lt;/p&gt;
&lt;p&gt;“ping 过吗？或者 telnet 了吗？”老王头都没回，冷冰冰地扔出去了这句话。&lt;/p&gt;
&lt;p&gt;“哦，我去试试。”小二心头掠过一丝愧疚。&lt;/p&gt;
&lt;p&gt;ping 与 telnet 这两个命令，对调试网络程序有着非常大的帮助。&lt;/p&gt;
&lt;p&gt;ping，一种计算机网络工具，用来测试数据包能否透过 IP 协议到达特定主机。ping 会向目标主机发出一个 ICMP 的请求回显数据包，并等待接收回显响应数据包。&lt;/p&gt;
&lt;p&gt;例如，我们 ping 一下博客园。截图如下。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://upload-images.jianshu.io/upload_images/1179389-d5d52105f9501230.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;telnet，Internet 远程登录服务的标准协议和主要方式，可以让我们坐在家里的计算机面前，登录到另一台远在天涯海角的远程计算机上。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://upload-images.jianshu.io/upload_images/1179389-be96e982048428d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在 Windows 系统中，telnet 一般是默认安装的，但未激活（可以在控制面板中激活它）。&lt;/p&gt;
&lt;p&gt;例如，我们 telnet 一下火（shui）土（mu）社区。截图如下。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://upload-images.jianshu.io/upload_images/1179389-92757796b4e6d781.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用 telnet 登录远程计算机时，需要远程计算机上运行一个服务，它一直不停地等待那些希望和它进行连接的网络请求；当接收到一个客户端的网络连接时，它便唤醒正在监听网络连接请求的服务器进程，并为两者建立连接。连接会一直保持，直到某一方中止。&lt;/p&gt;
&lt;p&gt;不过，需要注意的是，telnet 在格外重视安全的现代网络技术中并不受到重用。因为 telnet 是一个明文传输协议，用户的所有内容（包括用户名和密码）都没有经过加密，安全隐患非常大。&lt;/p&gt;
&lt;h3 id=&quot;h02socket&quot;&gt;02、Socket 实例&lt;/h3&gt;
&lt;p&gt;不知道你有没有体验一下 telnet 火土社区的那条命令，结果非常有趣。我们也可以通过 Java 的客户端套接字（Socket）实现，代码示例如下。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;try (Socket socket = &lt;span class=&quot;hljs-keyword&quot;&gt;new Socket(&lt;span class=&quot;hljs-string&quot;&gt;&quot;bbs.newsmth.net&quot;, &lt;span class=&quot;hljs-number&quot;&gt;23);) {&lt;br/&gt;InputStream is = socket.getInputStream();&lt;br/&gt;Scanner scanner = &lt;span class=&quot;hljs-keyword&quot; readability=&quot;2.5&quot;&gt;new Scanner(is, &lt;span class=&quot;hljs-string&quot; readability=&quot;5&quot;&gt;&quot;gbk&quot;);&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;while (scanner.hasNextLine()) {&lt;br/&gt;String line = scanner.nextLine();&lt;br/&gt;System.out.println(line);&lt;br/&gt;}&lt;/span&gt;&lt;/p&gt;&lt;p&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;catch (UnknownHostException e) {&lt;br/&gt;e.printStackTrace();&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;catch (IOException e) {&lt;br/&gt;e.printStackTrace();&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;1）建立套接字连接非常简单，只需要一行代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;Socket socket = &lt;span class=&quot;hljs-keyword&quot;&gt;new Socket(host, port)&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;host 为主机名，port 为端口号（23 为默认的 telnet 端口号）。如果无法确定主机的 IP 地址，则抛出 &lt;code&gt;UnknownHostException&lt;/code&gt; 异常；如果在创建套接字时发生 IO 错误，则抛出 &lt;code&gt;IOException&lt;/code&gt; 异常。&lt;/p&gt;
&lt;p&gt;需要注意的是，套接字在建立的时候，如果远程主机不可访问，这段代码就会阻塞很长时间，直到底层操作系统的限制而抛出异常。所以一般会在套接字建立后设置一个超时时间。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;Socket socket = &lt;span class=&quot;hljs-keyword&quot;&gt;new Socket(...);&lt;br/&gt;socket.setSoTimeout(&lt;span class=&quot;hljs-number&quot;&gt;10000); &lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2）套接字连接成功后，可以通过 &lt;code&gt;java.net.Socket&lt;/code&gt; 类的 &lt;code&gt;getInputStream()&lt;/code&gt; 方法获取输入流。有了 &lt;code&gt;InputStream&lt;/code&gt; 对象后，可以借助文本扫描器类（Scanner）将其中的内容打印出来。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;InputStream is = socket.getInputStream();&lt;br/&gt;Scanner scanner = &lt;span class=&quot;hljs-keyword&quot; readability=&quot;1&quot;&gt;new Scanner(is, &lt;span class=&quot;hljs-string&quot; readability=&quot;2&quot;&gt;&quot;gbk&quot;);&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;while (scanner.hasNextLine()) {&lt;br/&gt;String line = scanner.nextLine();&lt;br/&gt;System.out.println(line);&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;部分结果（完整结果自己亲手实践一下哦）如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://upload-images.jianshu.io/upload_images/1179389-e0f08e7de5248c41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;h03serversocket&quot;&gt;03、ServerSocket 实例&lt;/h3&gt;
&lt;p&gt;接下来，我们模拟一个远程服务，通过 &lt;code&gt;java.net.ServerSocket&lt;/code&gt; 实现。代码示例如下。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;try (ServerSocket server = &lt;span class=&quot;hljs-keyword&quot; readability=&quot;6&quot;&gt;new ServerSocket(&lt;span class=&quot;hljs-number&quot; readability=&quot;12&quot;&gt;8888);&lt;br/&gt;Socket socket = server.accept();&lt;br/&gt;InputStream is = socket.getInputStream();&lt;br/&gt;OutputStream os = socket.getOutputStream();&lt;p&gt;Scanner scanner = &lt;span class=&quot;hljs-keyword&quot;&gt;new Scanner(is)) {&lt;br/&gt;PrintWriter pw = &lt;span class=&quot;hljs-keyword&quot;&gt;new PrintWriter(&lt;span class=&quot;hljs-keyword&quot;&gt;new OutputStreamWriter(os, &lt;span class=&quot;hljs-string&quot;&gt;&quot;gbk&quot;), &lt;span class=&quot;hljs-keyword&quot;&gt;true);&lt;br/&gt;pw.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;你好啊，欢迎关注「沉默王二」 公众号，回复关键字「2048」 领取程序员进阶必读资料包&quot;);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;boolean done = &lt;span class=&quot;hljs-keyword&quot;&gt;false;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;while (!done &amp;amp;&amp;amp; scanner.hasNextLine()) {&lt;br/&gt;String line = scanner.nextLine();&lt;br/&gt;System.out.println(line);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if (&lt;span class=&quot;hljs-string&quot;&gt;&quot;2048&quot;.equals(line)) {&lt;br/&gt;done = &lt;span class=&quot;hljs-keyword&quot;&gt;true;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;catch (UnknownHostException e) {&lt;br/&gt;e.printStackTrace();&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;catch (IOException e) {&lt;br/&gt;e.printStackTrace();&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;1）建立服务器端的套接字也比较简单，只需要指定一个能够独占的端口号就可以了（0~1023 这些端口都已经被系统预留了）。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;ServerSocket server = &lt;span class=&quot;hljs-keyword&quot;&gt;new ServerSocket(&lt;span class=&quot;hljs-number&quot;&gt;8888);&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2）调用 ServerSocket 对象的 &lt;code&gt;accept()&lt;/code&gt; 等待客户端套接字的连接请求。一旦监听到客户端的套接字请求，就会返回一个表示连接已建立的 Socket 对象，可以从中获取到输入流和输出流。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;Socket socket = server.accept();&lt;br/&gt;InputStream is = socket.getInputStream();&lt;br/&gt;OutputStream os = socket.getOutputStream();&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;客户端套接字发送的所有信息都会包裹在服务器端套接字的输入流中；而服务器端套接字发送的所有信息都会包裹在客户端套接字的输出流中。&lt;/p&gt;
&lt;p&gt;3）服务器端可以通过以下代码向客户端发送消息。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;PrintWriter pw = &lt;span class=&quot;hljs-keyword&quot;&gt;new PrintWriter(&lt;span class=&quot;hljs-keyword&quot;&gt;new OutputStreamWriter(os, &lt;span class=&quot;hljs-string&quot;&gt;&quot;gbk&quot;), &lt;span class=&quot;hljs-keyword&quot;&gt;true);&lt;br/&gt;pw.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;你好啊，欢迎关注「沉默王二」 公众号，回复关键字「2048」 领取程序员进阶必读资料包&quot;);&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4）服务器端可以通过以下代码读取客户端发送过来的消息。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;Scanner scanner = &lt;span class=&quot;hljs-keyword&quot;&gt;new Scanner(is);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;boolean done = &lt;span class=&quot;hljs-keyword&quot; readability=&quot;1&quot;&gt;false;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot; readability=&quot;2&quot;&gt;while (!done &amp;amp;&amp;amp; scanner.hasNextLine()) {&lt;br/&gt;String line = scanner.nextLine();&lt;br/&gt;System.out.println(line);&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if (&lt;span class=&quot;hljs-string&quot;&gt;&quot;2048&quot;.equals(line)) {&lt;br/&gt;done = &lt;span class=&quot;hljs-keyword&quot;&gt;true;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行该服务后，可以通过 &lt;code&gt;telnet localhost 8888&lt;/code&gt; 命令连接该远程服务，不出所料，你将会看到以下信息。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://upload-images.jianshu.io/upload_images/1179389-0b09206c59c3b2f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;PS：可以在当前命令窗口中输入 2048，服务端收到该消息后会中断该套接字连接（当前窗口会显示“遗失对主机的连接”）。&lt;/p&gt;
&lt;h3 id=&quot;h04&quot;&gt;04、为多个客户端服务&lt;/h3&gt;
&lt;p&gt;非常遗憾的是，上面的例子中，服务器端只能为一个客户端服务——这不符合服务器端一对多的要求。&lt;/p&gt;
&lt;p&gt;优化方案也非常简单（你应该也能想得到）：服务器端接收到客户端的套接字请求时，可以启动一个线程来处理，而主程序继续等待下一个连接。代码示例如下。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;try (ServerSocket server = &lt;span class=&quot;hljs-keyword&quot; readability=&quot;3&quot;&gt;new ServerSocket(&lt;span class=&quot;hljs-number&quot; readability=&quot;6&quot;&gt;8888)) {&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;while (&lt;span class=&quot;hljs-keyword&quot;&gt;true) {&lt;br/&gt;Socket socket = server.accept();&lt;br/&gt;Thread thread = &lt;span class=&quot;hljs-keyword&quot;&gt;new Thread(&lt;span class=&quot;hljs-keyword&quot;&gt;new Runnable() {&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;run&lt;span class=&quot;hljs-params&quot;&gt;() {&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;}&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;catch (IOException e) {&lt;br/&gt;e.printStackTrace();&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;线程内部（&lt;code&gt;run(){}&lt;/code&gt; 方法里）用来处理套接字，代码示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;try {&lt;br/&gt;InputStream is = socket.getInputStream();&lt;br/&gt;OutputStream os = socket.getOutputStream();&lt;br/&gt;Scanner scanner = &lt;span class=&quot;hljs-keyword&quot;&gt;new Scanner(is);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;服务器端代码优化后重新运行，你就可以通过 telnet 命令测试了。打开一个命令行窗口输入 &lt;code&gt;telnet localhost 8888&lt;/code&gt;，再打开一个新的命令行窗口输入 &lt;code&gt;telnet localhost 8888&lt;/code&gt;，多个窗口都可以和服务器端进行通信，除非服务器端代码中断运行。&lt;/p&gt;
&lt;h3 id=&quot;h05&quot;&gt;05、最后&lt;/h3&gt;
&lt;p&gt;如今大多数基于网络的软件，如浏览器、即时通讯工具甚至是 P2P 下载都是基于 Socket 实现的，所以掌握 Java Socket 编程还是蛮有必要的。Socket 编程也比较有趣，很多初学者都会编写一两个基于“客户端-服务器端”的小程序来提高自己的编程水平，建议你也试一试。&lt;/p&gt;

</description>
<pubDate>Tue, 20 Aug 2019 00:35:00 +0000</pubDate>
<dc:creator>沉默王二</dc:creator>
<og:description>在古代，由于通信不便利，一些聪明的人就利用鸽子会飞且飞得比较快、会辨认方向的优点，对其进行了驯化，用来进行消息的传递——也就是所谓的“飞鸽传书”。而在 Java 中，网络套接字（Socket）扮演了同</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qing-gee/p/11380884.html</dc:identifier>
</item>
<item>
<title>Spring Boot 统一异常这样处理和剖析，安否？ - tan日拱一兵</title>
<link>http://www.cnblogs.com/FraserYu/p/11380878.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/FraserYu/p/11380878.html</guid>
<description>&lt;h2 id=&quot;话说异常&quot;&gt;话说异常&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;「欲渡黄河冰塞川，将登太行雪满天」&lt;/code&gt;，无论生活还是计算机世界难免发生异常，上一篇文章&lt;a href=&quot;https://fraseryu.github.io/2019/08/08/mei-tian-yong-springboot-huan-bu-dong-tong-yi-fan-hui-shu-ju-ge-shi-shi-zen-me-shi-xian-de/#toc-heading-2&quot;&gt;RESTful API 返回统一JSON数据格式&lt;/a&gt; 说明了统一返回的处理，这是请求一切正常的情形；&lt;strong&gt;这篇文章将说明如何统一处理异常，以及其背后的实现原理&lt;/strong&gt;，老套路，先实现，后说明原理，有了上一篇文章的铺底，相信，理解这篇文章就驾轻就熟了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1583165/201908/1583165-20190820083048139-339253779.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;实现&quot;&gt;实现&lt;/h2&gt;
&lt;h3 id=&quot;新建业务异常&quot;&gt;新建业务异常&lt;/h3&gt;
&lt;p&gt;新建 BusinessException.class 类表示业务异常，&lt;strong&gt;注意这是一个 Runtime 异常&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Data
@AllArgsConstructor
public final class BusinessException extends RuntimeException {

    private String errorCode;

    private String errorMsg;
    
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;添加统一异常处理静态方法&quot;&gt;添加统一异常处理静态方法&lt;/h3&gt;
&lt;p&gt;在 CommonResult 类中添加静态方法 errorResult 用于接收异常码和异常消息:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static &amp;lt;T&amp;gt; CommonResult&amp;lt;T&amp;gt; errorResult(String errorCode, String errorMsg){
    CommonResult&amp;lt;T&amp;gt; commonResult = new CommonResult&amp;lt;&amp;gt;();
    commonResult.errorCode = errorCode;
    commonResult.errorMsg = errorMsg;
    commonResult.status = -1;
    return commonResult;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;配置&quot;&gt;配置&lt;/h3&gt;
&lt;p&gt;同样要用到 &lt;code&gt;@RestControllerAdvice&lt;/code&gt; 注解，将统一异常添加到配置中:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RestControllerAdvice(&quot;com.example.unifiedreturn.api&quot;)
static class UnifiedExceptionHandler{

    @ExceptionHandler(BusinessException.class)
    public CommonResult&amp;lt;Void&amp;gt; handleBusinessException(BusinessException be){
        return CommonResult.errorResult(be.getErrorCode(), be.getErrorMsg());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;三部搞定，到这里无论是 Controller 还是 Service 中，只要抛出 BusinessException, 我们都会返回给前端一个统一数据格式&lt;/p&gt;
&lt;h2 id=&quot;测试&quot;&gt;测试&lt;/h2&gt;
&lt;p&gt;将 UserController 中的方法进行改造，直接抛出异常:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@GetMapping(&quot;/{id}&quot;)
public UserVo getUserById(@PathVariable Long id){
    throw new BusinessException(&quot;1001&quot;, &quot;根据ID查询用户异常&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;浏览器中输入: &lt;em&gt;http://localhost:8080/users/1&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1583165/201908/1583165-20190820083048924-1306667432.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在 Service 中抛出异常:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Service
public class UserServiceImpl implements UserService {

    /**
     * 根据用户ID查询用户
     *
     * @param id
     * @return
     */
    @Override
    public UserVo getUserById(Long id) {
        throw new BusinessException(&quot;1001&quot;, &quot;根据ID查询用户异常&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行是得到同样的结果，所以我们尽可能的抛出异常吧 (作为一个程序猿这种心理很可拍)&lt;/p&gt;
&lt;h2 id=&quot;解剖实现过程&quot;&gt;解剖实现过程&lt;/h2&gt;
&lt;p&gt;解剖这个过程是相当纠结的，为了更好的说(yin)明(wei)问(wo)题(lan)，我要说重中之重了，真心希望看该文章的童鞋自己去案发现场发现线索&lt;br/&gt;还是在 WebMvcConfigurationSupport 类中实例化了 HandlerExceptionResolver Bean&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Bean
public HandlerExceptionResolver handlerExceptionResolver() {
    List&amp;lt;HandlerExceptionResolver&amp;gt; exceptionResolvers = new ArrayList&amp;lt;&amp;gt;();
    configureHandlerExceptionResolvers(exceptionResolvers);
    if (exceptionResolvers.isEmpty()) {
        addDefaultHandlerExceptionResolvers(exceptionResolvers);
    }
    extendHandlerExceptionResolvers(exceptionResolvers);
    HandlerExceptionResolverComposite composite = new HandlerExceptionResolverComposite();
    composite.setOrder(0);
    composite.setExceptionResolvers(exceptionResolvers);
    return composite;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;和上一篇文章一毛一样的套路，ExceptionHandlerExceptionResolver 实现了 InitializingBean 接口，重写了 afterPropertiesSet 方法:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Override
public void afterPropertiesSet() {
    // Do this first, it may add ResponseBodyAdvice beans
    initExceptionHandlerAdviceCache();
    ...
}

private void initExceptionHandlerAdviceCache() {
    if (getApplicationContext() == null) {
        return;
    }

    List&amp;lt;ControllerAdviceBean&amp;gt; adviceBeans = ControllerAdviceBean.findAnnotatedBeans(getApplicationContext());
    AnnotationAwareOrderComparator.sort(adviceBeans);

    for (ControllerAdviceBean adviceBean : adviceBeans) {
        Class&amp;lt;?&amp;gt; beanType = adviceBean.getBeanType();
        if (beanType == null) {
            throw new IllegalStateException(&quot;Unresolvable type for ControllerAdviceBean: &quot; + adviceBean);
        }
        // 重点看这个构造方法
        ExceptionHandlerMethodResolver resolver = new ExceptionHandlerMethodResolver(beanType);
        if (resolver.hasExceptionMappings()) {
            this.exceptionHandlerAdviceCache.put(adviceBean, resolver);
        }
        if (ResponseBodyAdvice.class.isAssignableFrom(beanType)) {
            this.responseBodyAdvice.add(adviceBean);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重点看上面我用注释标记的构造方法，代码很好懂，仔细看看吧，其实就是筛选出我们用 @ExceptionHandler 注解标记的方法并放到集合当中，用于后续全局异常捕获的匹配&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * A constructor that finds {@link ExceptionHandler} methods in the given type.
 * @param handlerType the type to introspect
 */
public ExceptionHandlerMethodResolver(Class&amp;lt;?&amp;gt; handlerType) {
    for (Method method : MethodIntrospector.selectMethods(handlerType, EXCEPTION_HANDLER_METHODS)) {
        for (Class&amp;lt;? extends Throwable&amp;gt; exceptionType : detectExceptionMappings(method)) {
            addExceptionMapping(exceptionType, method);
        }
    }
}


/**
 * Extract exception mappings from the {@code @ExceptionHandler} annotation first,
 * and then as a fallback from the method signature itself.
 */
@SuppressWarnings(&quot;unchecked&quot;)
private List&amp;lt;Class&amp;lt;? extends Throwable&amp;gt;&amp;gt; detectExceptionMappings(Method method) {
    List&amp;lt;Class&amp;lt;? extends Throwable&amp;gt;&amp;gt; result = new ArrayList&amp;lt;&amp;gt;();
    detectAnnotationExceptionMappings(method, result);
    if (result.isEmpty()) {
        for (Class&amp;lt;?&amp;gt; paramType : method.getParameterTypes()) {
            if (Throwable.class.isAssignableFrom(paramType)) {
                result.add((Class&amp;lt;? extends Throwable&amp;gt;) paramType);
            }
        }
    }
    if (result.isEmpty()) {
        throw new IllegalStateException(&quot;No exception types mapped to &quot; + method);
    }
    return result;
}

private void detectAnnotationExceptionMappings(Method method, List&amp;lt;Class&amp;lt;? extends Throwable&amp;gt;&amp;gt; result) {
    ExceptionHandler ann = AnnotatedElementUtils.findMergedAnnotation(method, ExceptionHandler.class);
    Assert.state(ann != null, &quot;No ExceptionHandler annotation&quot;);
    result.addAll(Arrays.asList(ann.value()));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到这里，我们用 &lt;code&gt;@RestControllerAdvice&lt;/code&gt; 和 &lt;code&gt;@ExceptionHandler&lt;/code&gt; 注解就会被 Spring 扫描到上下文，供我们使用&lt;/p&gt;
&lt;p&gt;让我们回到你最熟悉的调用的入口 DispatcherServlet 类的 doDispatch 方法:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {
    ...

    try {
        ModelAndView mv = null;
        Exception dispatchException = null;

        try {
            ...
            // 当请求发生异常，该方法会通过 catch 捕获异常
            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());
        ...
            
        }
        catch (Exception ex) {
            dispatchException = ex;
        }
        catch (Throwable err) {
            // As of 4.3, we're processing Errors thrown from handler methods as well,
            // making them available for @ExceptionHandler methods and other scenarios.
            dispatchException = new NestedServletException(&quot;Handler dispatch failed&quot;, err);
        }
        // 调用该方法分析捕获的异常
        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);
    }
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来，我们来看 processDispatchResult 方法，这里只要展示调用栈你就会眼前一亮了，又是为了返回统一格式数据:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1583165/201908/1583165-20190820083054880-119627200.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;上一篇文章的返回统一数据格式是基础，当异常情况发生时，只不过需要将异常信息提取出来。本文主要为了说明问题，剖析原理，好多地方设计方式是不可取，比如我们最好将异常封装在一个 Enum 类，通过 enum 对象抛出异常等，如果你用到这些，去完善你的设计方案吧&lt;/p&gt;
&lt;p&gt;回复 「demo」，打开链接，查看文件夹 「unifiedreturn」下内容，获取完整代码，更好阅读体验:&lt;br/&gt;https://fraseryu.github.io/2019/08/09/ru-he-tong-yi-chu-li-yi-chang-bing-fan-hui-tong-yi-ge-shi/&lt;/p&gt;
&lt;h2 id=&quot;附加说明&quot;&gt;附加说明&lt;/h2&gt;
&lt;p&gt;之前看到的一本书对异常的分类让我印象深刻，在此摘录一小段分享给大家:&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1583165/201908/1583165-20190820083055777-1106625000.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;结合出国旅行的例子说明异常分类:&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;机场地震，属于不可抗力，对应异常分类中的 &lt;code&gt;Error&lt;/code&gt;，在制订出行计划时，根本不需要把这个部分的异常考虑进去&lt;/li&gt;
&lt;li&gt;堵车属于 &lt;code&gt;checked&lt;/code&gt; 异常，应对这种异常，我们可以提前出发，或者改签机票。而飞机延误异常,虽然也需要 check，但我们无能为力，只能持续关注航班动态&lt;/li&gt;
&lt;li&gt;没有带护照，明显属于可&lt;code&gt;提前预测的异常&lt;/code&gt;，只要出发前检查即可避免；去机场路上车子抛锚，这个异常是突发的，虽然难以预料，但是必须处理，属于&lt;code&gt;需要捕捉的异常&lt;/code&gt;，可以通过更换交通工具；应对检票机器故障属于 &lt;code&gt;可透出异常&lt;/code&gt;，交由航空公司处理,我们无须关心&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h2 id=&quot;灵魂追问&quot;&gt;灵魂追问&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;这两篇文章，你学到了哪些设计模式？&lt;/li&gt;
&lt;li&gt;你能熟练的使用反射吗？当看源码是会看到很多反射的应用&lt;/li&gt;
&lt;li&gt;你了解 Spring CGLIB 吗？它的工作原理是什么？&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;提高效率工具&quot;&gt;提高效率工具&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1583165/201908/1583165-20190820083055907-286841295.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;json-viewer&quot;&gt;JSON-Viewer&lt;/h3&gt;
&lt;p&gt;JSON-Viewer 是 Chrome 浏览器的插件，用于快速解析及格式化 json 内容，在 Chrome omnibox（多功能输入框）输入&lt;code&gt;json-viewer + TAB&lt;/code&gt; ，将 json 内容拷贝进去，然后输入回车键，将看到结构清晰的 json 数据，同时可以自定义主题&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1583165/201908/1583165-20190820083056631-1463152228.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;另外前端人员打开开发者工具双击请求链接会自动将-response-中的-json-数据解析出来非常方便&quot;&gt;另外，前端人员打开开发者工具，双击请求链接，会自动将 response 中的 json 数据解析出来，非常方便&lt;/h2&gt;
&lt;h2 id=&quot;推荐阅读&quot;&gt;推荐阅读&lt;/h2&gt;
&lt;hr/&gt;&lt;blockquote&gt;
&lt;h3 id=&quot;欢迎持续关注公众号日拱一兵&quot;&gt;欢迎持续关注公众号：「日拱一兵」&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;前沿 Java 技术干货分享&lt;/li&gt;
&lt;li&gt;高效工具汇总 | 回复「工具」&lt;/li&gt;
&lt;li&gt;面试问题分析与解答&lt;/li&gt;
&lt;li&gt;技术资料领取 | 回复「资料」&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;以读侦探小说思维轻松趣味学习 Java 技术栈相关知识，本着将复杂问题简单化，抽象问题具体化和图形化原则逐步分解技术问题，技术持续更新，请持续关注......&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1583165/201908/1583165-20190820083057344-111192583.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 20 Aug 2019 00:31:00 +0000</pubDate>
<dc:creator>tan日拱一兵</dc:creator>
<og:description>话说异常 ，无论生活还是计算机世界难免发生异常，上一篇文章 'RESTful API 返回统一JSON数据格式' 说明了统一返回的处理，这是请求一切正常的情形； 这篇文章将说明如何统一处理异常，以及其</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/FraserYu/p/11380878.html</dc:identifier>
</item>
<item>
<title>.netcore持续集成测试篇之web项目验收测试 - 周国通</title>
<link>http://www.cnblogs.com/tylerzhou/p/11380856.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tylerzhou/p/11380856.html</guid>
<description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/tylerzhou/p/11204826.html&quot;&gt;系列目录&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通过前面的单元测试,我们能够保证项目的基本模块功能逻辑是正常的,通过集成测试能够保证接口的请求是正常的.然而最终项目交付我们还需要对项目进行页面的行为进行测试,比如页面布局是否正常,按钮是否能点击,点击后执行的动作是否正确,链接是否正常等功能进行测试,表单提交是否返回正确结果等.这些都是一些墨盒测试,一般是由专门测试人员来完成,然而随着web的发展,各种自动化工具越来越完善,有一些页面功能的测试也可以由程序员来编写自动测试代码完成.这里主要结合Selenium来介绍如何完成页面行为的测试.&lt;/p&gt;
&lt;h2 id=&quot;点击按钮&quot;&gt;点击按钮&lt;/h2&gt;
&lt;p&gt;前面我们已经讲到如何安装和简单使用Selenium,这里不再介绍.下面介绍一下如何使用Selenium来触发一个按钮点击事件.&lt;/p&gt;
&lt;p&gt;首先我们在HelloWorldController里新建Action FormTest(也可以在其它控制器里创建,这里随意),代码如下&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt; public IActionResult FormTest()
        {
            return View();
        }
        [HttpPost]
        public IActionResult FormTest(string name)
        {
            return Content(name);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上代码非常简单,我们创建FormTest并请求自己,然后把请求的数据返回&lt;/p&gt;
&lt;p&gt;我们为这个Action新建一个页面,并且引入jquery.&lt;/p&gt;
&lt;p&gt;页面代码如下&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;

&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot; /&amp;gt;
    &amp;lt;script src=&quot;~/js/JQueryt.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;title&amp;gt;FormTest&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;form method=&quot;post&quot; id=&quot;frm1&quot;&amp;gt;
    &amp;lt;input id=&quot;btn1&quot; type=&quot;button&quot; value=&quot;点我&quot;/&amp;gt;
&amp;lt;/form&amp;gt;
&amp;lt;script&amp;gt;
    $(&quot;#btn1&quot;).click(function() {
        alert(&quot;hello,world&quot;);
    });
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个页面里有一个btn1,如果我们点击它就会弹出一个alert框.&lt;br/&gt;测试代码如下&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;        [Fact]
        public void ClickTest()
        {
            IWebDriver driver =
                new ChromeDriver(Environment.CurrentDirectory);

            driver.Url = &quot;http://localhost:28614/HelloWorld/FormTest&quot;;
            driver.Navigate();
            var element = driver.FindElement(By.Id(&quot;btn1&quot;));
            element.Click();
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们先通过id找到这个按钮,然后令它触发一个click事件.我们运行测试&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201908/811801-20190820080123576-770915472.png&quot; alt=&quot;avatar&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们并没有手动点击按钮,但是弹出了上面的弹框,说明点击事件正确触发了.&lt;/p&gt;
&lt;h2 id=&quot;自动填写表单&quot;&gt;自动填写表单&lt;/h2&gt;
&lt;p&gt;通过以上代码我们可以看到,触发一个按钮点击事件在Selenium是非常容易的,这对我们自动模拟表单提交提供了大大的便利.Selenium还可以模拟自动填写表单,思路和上面是一样的,首先获取到要填写的表单,然后模拟填写内容.下面我们改动一下网页代码,在form里面添加一个简单的表单&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;input type=&quot;text&quot; name=&quot;name&quot;/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试代码改为如下:&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;       [Fact]
        public void ClickTest()
        {
            IWebDriver driver =
                new ChromeDriver(Environment.CurrentDirectory);

            driver.Url = &quot;http://localhost:28614/HelloWorld/FormTest&quot;;
            driver.Navigate();
            var input = driver.FindElement(By.Name(&quot;name&quot;));
            input.SendKeys(&quot;hello,world&quot;);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上代通过FindElement By.Name获取到页面里name为name的元素(听起来有点绕),然后通过SendKeys方法模拟向指定元素填写内容&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201908/811801-20190820080118304-828913244.png&quot; alt=&quot;avatar&quot;/&gt;&lt;/p&gt;
&lt;p&gt;页面的开以后便会自动填写以上内容.这样我们就可以自动填写内容,然后点击点我按钮提交表单了.&lt;/p&gt;
&lt;h2 id=&quot;自动填写表单然后提交&quot;&gt;自动填写表单,然后提交&lt;/h2&gt;
&lt;p&gt;综合以上我们模拟一次自动填写表单,然后提交的动作.&lt;/p&gt;
&lt;p&gt;下面贴出修改后的完整代码.&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot; /&amp;gt;
    &amp;lt;script src=&quot;~/js/JQueryt.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;title&amp;gt;FormTest&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;form method=&quot;post&quot; id=&quot;frm1&quot;&amp;gt;
    &amp;lt;input type=&quot;text&quot; name=&quot;name&quot;/&amp;gt;
    &amp;lt;input id=&quot;btn1&quot; type=&quot;button&quot; value=&quot;点我&quot;/&amp;gt;
&amp;lt;/form&amp;gt;
&amp;lt;script&amp;gt;
    $(&quot;#btn1&quot;).click(function() {
        $.ajax({
            type: &quot;POST&quot;,
            url: &quot;/HelloWorld/FormTest&quot;,
            data: $(&quot;#frm1&quot;).serialize(),
            dataType: &quot;text&quot;,
            success: function (response) {
                alert(&quot;返回的数据是:&quot;+response);
            }
        });
    });
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这次当按钮点击以后我们触发一次ajax提交,然后alert服务器返回的数据&lt;/p&gt;
&lt;p&gt;测试代码如下:&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;        [Fact]
        public void ClickTest()
        {
            IWebDriver driver =
                new ChromeDriver(Environment.CurrentDirectory);

            driver.Url = &quot;http://localhost:28614/HelloWorld/FormTest&quot;;
            driver.Navigate();
            var input = driver.FindElement(By.Name(&quot;name&quot;));
            input.SendKeys(&quot;hello,world&quot;);
            var btn = driver.FindElement(By.Id(&quot;btn1&quot;));
            btn.Click();
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码执行了两个动作,第一是模拟填写表单数据,第二是点击按钮,提交表单.&lt;br/&gt;我们运行测试代码,看一下结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201908/811801-20190820080113100-548595860.png&quot; alt=&quot;avatar&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到表单自动提交了.&lt;/p&gt;
&lt;h2 id=&quot;获取alert框&quot;&gt;获取Alert框&lt;/h2&gt;
&lt;p&gt;我们前面都是通过截图来看指定的行为是否产生了正确的结果,然而在自动化环境中这是不能接受的,更多的时候我们是在无头模式下进行测试,然后自动获取行为产生的结果,然后断言此结果是否是期待的一个值.下面我们改造以上代码,自动获致到Alert框并取得它里面的值,然后断言这个值是我们想要的值.&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt; [Fact]
        public void ClickTest()
        {
            IWebDriver driver =
                new ChromeDriver(Environment.CurrentDirectory);

            driver.Url = &quot;http://localhost:28614/HelloWorld/FormTest&quot;;
            driver.Navigate();
            var input = driver.FindElement(By.Name(&quot;name&quot;));
            input.SendKeys(&quot;hello,world&quot;);
            var btn = driver.FindElement(By.Id(&quot;btn1&quot;));
            btn.Click();
            Thread.Sleep(3000);
            var alert = driver.SwitchTo().Alert();
            var txt = alert.Text;
            Assert.Equal(&quot;返回的数据是:hello,world&quot;, txt);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上代码的关键是通过SwitchTo获取到Alert框,进而获取到它的Text值,我们在ajax请求成功的处理是&lt;code&gt;&quot;返回的数据是:&quot;&lt;/code&gt;+提交的值,因此如果正常则以上代码会执行成功.这样我们就不用守着页面查看结果了.&lt;/p&gt;
&lt;h2 id=&quot;获取自定义弹出层&quot;&gt;获取自定义弹出层&lt;/h2&gt;
&lt;p&gt;做到以上并没有成事大吉,实际业务中我们很少使用浏览器自带的Alert,而是使用一些第三方的组件,因为原生Alert用户体验实在不是太好,只能在测试的时候玩一玩还可以.由于第三方组件实现方式不同,这就导致获取的方法也不一样,我们还要根据具体情况而定.下面我们结合layui的alert框来介绍一下如何来获取它里面的内容.&lt;/p&gt;
&lt;p&gt;我们在项目中引入layui,然后把ajax请求成功后的alert换成layui的alert,代码如下&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot; /&amp;gt;

    &amp;lt;link href=&quot;~/lib/layui/css/layui.css&quot; rel=&quot;stylesheet&quot; /&amp;gt;
    &amp;lt;script src=&quot;~/lib/jquery/dist/jquery.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;~/lib/layui/layui.all.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;title&amp;gt;FormTest&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;form method=&quot;post&quot; id=&quot;frm1&quot;&amp;gt;
    &amp;lt;input type=&quot;text&quot; name=&quot;name&quot;/&amp;gt;
    &amp;lt;input id=&quot;btn1&quot; type=&quot;button&quot; value=&quot;点我&quot;/&amp;gt;
&amp;lt;/form&amp;gt;
&amp;lt;script&amp;gt;
    var layer = layui.layer;
    $(&quot;#btn1&quot;).click(function() {
        $.ajax({
            type: &quot;POST&quot;,
            url: &quot;/HelloWorld/FormTest&quot;,
            data: $(&quot;#frm1&quot;).serialize(),
            dataType: &quot;text&quot;,
            success: function (response) {
                layer.alert(&quot;返回的数据是:&quot; + response);
            }
        });
    });
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于这是一个自定义alert,我们先运行一下项目,然后手动点击下按钮,等alert框出来以后我们分析一下它的结构:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201908/811801-20190820080105613-2078484807.png&quot; alt=&quot;avatar&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以看到,layui的这个alert框实际上是一个div层,由于id是动态生成的,因此我们不能使用,但是它的class是固定的,它包含了两个class元素,内部弹出的具体内容则是蓝色高亮的那个div里面的内容,它的class也是固定的,我们这里可以使用class获取到它们.&lt;/p&gt;
&lt;p&gt;下面看测试代码:&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;       [Fact]
        public void ClickTest()
        {
            IWebDriver driver =
                new ChromeDriver(Environment.CurrentDirectory);

            driver.Url = &quot;http://localhost:28614/HelloWorld/FormTest&quot;;
            driver.Navigate();
            var input = driver.FindElement(By.Name(&quot;name&quot;));
            input.SendKeys(&quot;hello,world&quot;);
            var btn = driver.FindElement(By.Id(&quot;btn1&quot;));
            btn.Click();
            Thread.Sleep(3000);
            var layer = driver.FindElement(By.ClassName(&quot;layui-layer-dialog&quot;));
            var content = layer.FindElement(By.ClassName(&quot;layui-layer-content&quot;));
            var text = content.Text;
            Assert.Equal(&quot;返回的数据是:hello,world&quot;, text);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;产生我们通过class获取到这个弹出层元素,然后再通过它找到它的子元素(包含弹出信息文字的div).这里的sleep前面说过,由于js是异步执行的,因此点击后并不能马上获取到结果,这里我们sleep一下.&lt;/p&gt;
&lt;blockquote readability=&quot;14&quot;&gt;
&lt;p&gt;需要特别注意的是,通过By.ClassName获取到的元素可能不止一下,默认取得的是获取到的第一个,这在有些时候可能并不能满足我们的要求(这里代码比较少,发生冲突的机率比较小),实际工作中我们一定要想办法保证元素的惟一性,也就是获取到的元素确定是我们所需要的.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;还有一点需要注意的是第三方的组件实现方式可能会改变导致获取不到内容,这确实没有比较好的解决方案.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;实际工作中可能还会有更为复杂的行为要去模拟,比如说弹出层是一个带有tab的面板,我们需要切换到特定的tab去寻找想要的内容,由于这些内容都是非标准实现,因此模拟的难度根据采用框架的复杂度而定,有时候可能特别复杂,但是只要静下心来分析分析,总是能找到解决方案的.&lt;/p&gt;
&lt;p&gt;前面讲到了如何填写表单,点击按钮提交表单以及获取弹出层内容.下面讲解一下如何获取链接,弹出页面,iframe以及高级行为.这里仍然是以实际应该为主导讲解一些最基本最常用的功能,并不求面面俱到,有兴趣的同事可以查看官方文档,第三方博客,书籍等获取更多知识.&lt;/p&gt;
&lt;h2 id=&quot;链接行为测试&quot;&gt;链接行为测试&lt;/h2&gt;
&lt;p&gt;链接很多时候可以完成按钮的功能,但是最常用的是跳到一个新的页面,下面讲一下如何获取到新的页面&lt;/p&gt;
&lt;p&gt;我们在上节的页面中添加一个a链接,代码如下:&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;a id=&quot;clk&quot; href=&quot;http://www.baidu.com&quot; target=&quot;_blank&quot;&amp;gt;飞往百度&amp;lt;/a&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上代码很简单,点击一下a标签就会出现一个新的百度页面,我们想要判断一下是否正确打开了百度页面,测试代码如下:&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;        [Fact]
        public void LinkClick()
        {
            IWebDriver driver =
                new ChromeDriver(Environment.CurrentDirectory);

            driver.Url = &quot;http://localhost:28614/HelloWorld/FormTest&quot;;
            driver.Navigate();
            var link = driver.FindElement(By.Id(&quot;clk&quot;));
            link.Click();
            var hands = driver.WindowHandles;
            var wind = driver.SwitchTo().Window(hands[1]);
            var title = wind.Title;
            Assert.Equal(&quot;百度一下，你就知道&quot;, title);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码主要的功能在于当点击链接以后通过driver.WindowHandles获取到容器的句柄,需要说明的是这里的句柄并不是指针类型的句柄,而是一个字符串类类型的变量,我们可以通过它找到指定的窗口,下面部分通过SwitchTo切换到一个窗口(SwitchTo我们前面讲到过),Window接收一个字符串类开的参数,虽然提示字符说是窗口的标题,实际上并不是,而是我们刚才获取到的句柄,我们知道现在共有两个窗口,百度窗口是后打开的,因此它的索引是是1.然后我们再获取它的标题,看看是不是&quot;百度一下, 你就知道&quot;&lt;/p&gt;
&lt;blockquote readability=&quot;18&quot;&gt;
&lt;p&gt;需要说明的是,以上我们虽然是通过索引获取的百度窗口,这样可能会因为位置切换造成问题(这里强烈不建议手动修改自动过程中的行为,实际上真实的测试环境是无头环境,因此这其实不是一个很大的问题),就上面的例子我们确实有办法能惟一确定百度窗口,但是如果窗口过多想要不使用索引获取到指定的窗口还是很困难的,这里强烈建议如果有打开非常多的窗口的复杂行为时,把测试分成若干个测试,每个测试里的逻辑只打开少量窗口,这样出现问题也更容易排查.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;点击时按下修改键&quot;&gt;点击时按下修改键&lt;/h2&gt;
&lt;p&gt;前面我们多次用到了模拟点击事件,其实这也是实际项目中用的最多的,但是也不排除少数情况下会用到其它的按键,比如说拖拽,双击,ctrl+点击等,&lt;/p&gt;
&lt;p&gt;下面我们演示如何在百度首页点击百度新闻并在新页面打开,我们知道百度首页的新闻默认是在本页打开的,如果点击链接时按下ctrl键则会在新页面中打开.下面我们模拟ctrl+点击这个行为&lt;br/&gt;这里其实也很简单,主要通过Actions封装对象来触发一系列动作来达到我们的目的.&lt;/p&gt;
&lt;p&gt;下面看测试代码:&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;       [Fact]
        public void LinkClick()
        {
            IWebDriver driver =
                new ChromeDriver(Environment.CurrentDirectory);

            driver.Url = &quot;http://www.baidu.com&quot;;
            driver.Navigate();
            var link = driver.FindElement(By.LinkText(&quot;新闻&quot;));
            Actions actions = new Actions(driver);
            actions.KeyDown(Keys.LeftControl).Click(link).Build().Perform();
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上代码主要是通过传入driver对象构造一个Actions类型对象,这个对象在调用build之前会一直返回自身,类似是是jQuery里的链式操作,这样我们就可以连续执行多个动作.&lt;/p&gt;
&lt;p&gt;下面的代码我们先是调用actions对象的keyDown方法,然后传入要按下的键,然后再调用点击事件,最后调用Build方法终止链式调用,最后再执行Perform执行前面的操作.启动测试就会发现浏览器在新的页面打开了百度新闻页&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;上面用到了一个以前没用到的选择方法那就是By.LinkText,语义非常明确那就是根据链接的文本找到链接对象.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;iframe对象的获取&quot;&gt;Iframe对象的获取&lt;/h2&gt;
&lt;p&gt;我们知道Iframe对象的处理比较麻烦,里面是一个比较封装的区域与外面通信过程比较麻烦,在selenium里它的处理也比较特殊,直接按照id或者其它特征获取到它几乎没有任何作用,因为无法获取到内容元素,selenium是通过switchTo.Frame传入获取到的iframe对象对它进行一层封装,然后就能够正常获取到它内部的元素了.&lt;/p&gt;
&lt;p&gt;我们在页面添加一个简单的iframe页面,代码如下&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;&amp;lt;iframe id=&quot;ifrm1&quot; src=&quot;http://www.baidu.com&quot;&amp;gt;&amp;lt;/iframe&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试代码如下&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;        [Fact]
        public void FindIframe()
        {
            IWebDriver driver =
                new ChromeDriver(Environment.CurrentDirectory);
            driver.Url = &quot;http://localhost:28614/HelloWorld/FormTest&quot;;
            driver.Navigate();
            var ele = driver.FindElement(By.Id(&quot;ifrm1&quot;));
            var frm = driver.SwitchTo().Frame(ele);
            var txt = frm.FindElement(By.LinkText(&quot;新闻&quot;)).Text;
            Assert.Equal(&quot;新闻&quot;, txt);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上代码首先像获取普通元素一样获取到这个iframe对象,然后通过SwitchTo.Frame把它传入封装成个frame对象,后面就可以获取到它内部的元素了.(iframe指向百度首页,我们获取到新闻链接)&lt;/p&gt;
&lt;p&gt;然而实际项目中,往往我们并不自己去创建iframe,而是由一些第三方ui框架自动创建的,框架生成的iframe要么没有id,要么是动态的,因此使用自动生成元素的id要非常慎重,但是笔者见过不少在生成iframe时可以给iframe指定name的,由于页面中iframe一般都不会太多,我们可以给它命一个惟一的名字,通过名字找到它.如果没有名字,还可以根据它的class找到它,一般iframe样式class都是固定的,但是这时候要想办法确保选择到的对象是惟一的,这样才能保证测试结果的稳定性.&lt;/p&gt;
&lt;h2 id=&quot;获取下拉列表&quot;&gt;获取下拉列表&lt;/h2&gt;
&lt;p&gt;在一些查询功能中,往往全有下拉列表,通过js获取或者设置下拉项并不是一件很困难的事,然而我们并不想不了测试而增加无关的js代码,这样用完还要删除非常麻烦,其实Selenium也提供了设置下拉列表选项的功能,这样极大方便了我们的测试.&lt;/p&gt;
&lt;p&gt;下面看示例代码&lt;/p&gt;
&lt;p&gt;我们首先 在页面中添加如下代码&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;select name=&quot;China&quot; id=&quot;zhengzhouDistrict&quot;&amp;gt;
    &amp;lt;option value=&quot;&quot;&amp;gt;--请选择区域--&amp;lt;/option&amp;gt;
    &amp;lt;option value=&quot;pdditrict&quot;&amp;gt;中原区&amp;lt;/option&amp;gt;
    &amp;lt;option value=&quot;hpditrict&quot;&amp;gt;二七区&amp;lt;/option&amp;gt;
    &amp;lt;option value=&quot;xhditrict&quot;&amp;gt;管城区&amp;lt;/option&amp;gt;
    &amp;lt;option value=&quot;cnditrict&quot;&amp;gt;高新区&amp;lt;/option&amp;gt;
    &amp;lt;option value=&quot;sjditrict&quot;&amp;gt;开发区&amp;lt;/option&amp;gt;
&amp;lt;/select&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试代码如下:&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;       [Fact]
        public void DropDownListTest()
        {
            IWebDriver driver =
                new ChromeDriver(Environment.CurrentDirectory);
            driver.Url = &quot;http://localhost:28614/HelloWorld/FormTest&quot;;
            driver.Navigate();
            var element = driver.FindElement(By.Id(&quot;zhengzhouDistrict&quot;));
            SelectElement dropdownList = new SelectElement(element);
            dropdownList.SelectByIndex(3);
            var select = dropdownList.SelectedOption.Text;
            Assert.Equal(&quot;管城区&quot;, select);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上代码中我们先是通过普通方法获取到了这个下拉列表,然后把它封装成一个SelectElement对象,然后调用它的SelectByIndex设置选中的项,这样选中的项就是不默认值了,而是我们想要选择的值.&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;select还有按索引,键,值等设置选择项的方法,并且可以取消选择,大家自己尝试一下,这里不再介绍.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;18&quot;&gt;
&lt;p&gt;然而以上方法并没有什么太大作用,由于浏览器自带的select界面往往都不太美观,并且动态交互性不是非常好,实际项目中我们很少使用原生的select,而是使用第三方ui框架带的select,而第三方框架往往都是把select隐藏起来,然后把它的值赋值给一个input元素,它设置和获取值都是通过第三方框架提供的api而非原生select自带的方法.如果这时候使用以上方法获取select元素就会导致失败,selenium会提交元素被隐藏无法交互.针对这个问题笔者采用了一种比较笨的方法那就是模拟按键,当然这里模拟按键并不引入第三方按键类框架,而是使用selenium本身的功能.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面仍然以layui为例说明如何设置下拉列表值.&lt;/p&gt;
&lt;p&gt;页面代码如下&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot; /&amp;gt;

    &amp;lt;link href=&quot;~/lib/layui/css/layui.css&quot; rel=&quot;stylesheet&quot; /&amp;gt;
    &amp;lt;script src=&quot;~/lib/jquery/dist/jquery.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;~/lib/layui/layui.all.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;title&amp;gt;FormTest&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;form class=&quot;layui-form&quot; action=&quot;&quot;&amp;gt;
    &amp;lt;div class=&quot;layui-form-item&quot;&amp;gt;
        &amp;lt;div class=&quot;layui-input-inline&quot;&amp;gt;
            &amp;lt;select name=&quot;China&quot; id=&quot;zhengzhouDistrict&quot;&amp;gt;
                &amp;lt;option value=&quot;&quot;&amp;gt;--请选择区域--&amp;lt;/option&amp;gt;
                &amp;lt;option value=&quot;pdditrict&quot;&amp;gt;中原区&amp;lt;/option&amp;gt;
                &amp;lt;option value=&quot;hpditrict&quot;&amp;gt;二七区&amp;lt;/option&amp;gt;
                &amp;lt;option value=&quot;xhditrict&quot;&amp;gt;管城区&amp;lt;/option&amp;gt;
                &amp;lt;option value=&quot;cnditrict&quot;&amp;gt;高新区&amp;lt;/option&amp;gt;
                &amp;lt;option value=&quot;sjditrict&quot;&amp;gt;开发区&amp;lt;/option&amp;gt;
            &amp;lt;/select&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/form&amp;gt;
        &amp;lt;script&amp;gt;
            var layer = layui.layer;
            var form = layui.form;
            form.render();
        &amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上代码和上面的类似,只是这里把它封装成layui的select,我们的思路是先获取到layui的显示select的元素,也就是最终渲染的input元素,经过观察发现这个元素有一个这样的样式layui-input,我们可以通过这个关键信息找到它,然后点击一下,这时候下拉列表就出来了,此时再点击向下按钮,在想要的位置处click一下就可以得到想要的结果了.&lt;/p&gt;
&lt;p&gt;测试代码如下:&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;       [Fact]
        public void DropDownListTest()
        {
            IWebDriver driver =
                new ChromeDriver(Environment.CurrentDirectory);
            driver.Url = &quot;http://localhost:28614/HelloWorld/FormTest&quot;;
            driver.Navigate();
            var input = driver.FindElement(By.ClassName(&quot;layui-input&quot;));
            input.Click();
            Actions action = new Actions(driver);
            action.SendKeys(Keys.ArrowDown+Keys.ArrowDown+Keys.ArrowDown).Click().Build().Perform();
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上主要是使用的Actions连续点击两次向下,就可以选择到指定的元素了.&lt;/p&gt;
&lt;h2 id=&quot;日期框处理&quot;&gt;日期框处理&lt;/h2&gt;
&lt;p&gt;这里结合layui来讲解如何处理日期框的问题&lt;/p&gt;
&lt;p&gt;首先我们来观察一下layui日期输入框的特点,它其实是一个input,并且是可以接受用户输入的,这就跟我们模拟手动输入带来了方便,但是事情并没有这么简单,我们可以看到手输内容之后还要点击那个弹出层的确定按钮来确认输入,一旦点击了确定则会把弹出层默认选中的日期输入到input框中,覆盖了刚才的选择.然而它却有以下一个特点:如果我们输入以后不点击确认,而是把光标移到空白色点击或者光标焦点移到其它可输入元素内,则也可以确认输入.这样我们就可以在日期输入框输入内容以后再把焦点移到其它输入框就能够确认输入了.&lt;/p&gt;
&lt;p&gt;页面代码如下:&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot; /&amp;gt;
    &amp;lt;link href=&quot;~/lib/layui/css/layui.css&quot; rel=&quot;stylesheet&quot; /&amp;gt;
    &amp;lt;script src=&quot;~/lib/jquery/dist/jquery.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;~/lib/layui/layui.all.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;title&amp;gt;FormTest&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;div class=&quot;layui-inline&quot;&amp;gt;
    &amp;lt;input type=&quot;text&quot; class=&quot;layui-input&quot; id=&quot;test1&quot;&amp;gt;
    &amp;lt;input type=&quot;text&quot; id=&quot;input1&quot;/&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;script&amp;gt;
    var laydate = layui.laydate;
    laydate.render({
        elem: '#test1'
    });
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上有两个input框,一个是普通input,一个是日期框,我们模拟在日期输入框输入内容后把焦点移动它右边空白处点击,然后看看上面日期输入框里的值是不是我们赋予的.&lt;/p&gt;
&lt;p&gt;测试代码如下:&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;        [Fact]
        public void DropDownListTest()
        {
            IWebDriver driver =
                new ChromeDriver(Environment.CurrentDirectory);
            driver.Url = &quot;http://localhost:28614/HelloWorld/FormTest&quot;;
            driver.Navigate();
            var input = driver.FindElement(By.Id(&quot;test1&quot;));
            input.SendKeys(&quot;2008-5-3&quot;);
            var position = input.Location;
            var clickposition = position.X + 200;
            Actions actions = new Actions(driver);
            actions.MoveByOffset(clickposition, 0).Click().Build().Perform();
            var txt = input.GetAttribute(&quot;value&quot;);
            Assert.Equal(&quot;2008-05-03&quot;, txt);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上代码我们首先获取到这个日期选择框,然后给它输入值.下面我们获取它的位置主要是为了让它关闭(如果点击了空白处或者其它可点击控件,则日期选择框就会消失,这里只所以要关闭它是因为它当前处于激活状态,如果不关闭则会影响其它操作).我们获取到它的位置后向右移动鼠标到空白处,然后点击空白处日期选择框就消失了.我们输入的是'2008-5-3'而断言它是'2008-05-03'是因为layui有格式纠正功能,自动把一位的数据前面补零.&lt;/p&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;这里获取input的值是通过GetAttribute获取的,而不是通过Text,text是获取元素内部的文本(也就是文本包含在标签里),而input的值是它的value属性的一个值,因此使用Text获取不到.&lt;br/&gt;一定要注意点击位置,如果点击位置位于链接或者提交按钮上则可能触发不可预期的效果.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前面我们介绍了如何通过普通的方法给元素设置值以及模拟特定的行为,本篇主要介绍如何获取页面cookie,如何模拟手机测试.&lt;/p&gt;
&lt;h2 id=&quot;获取页面cookie&quot;&gt;获取页面cookie&lt;/h2&gt;
&lt;p&gt;有些比较复杂的测试可能会用到cookie,在Selenium里通过&lt;code&gt;driver.Manage().Cookies&lt;/code&gt;就可以获取到页面所有的cookie对象了.&lt;/p&gt;
&lt;h2 id=&quot;模拟手机浏览器&quot;&gt;模拟手机浏览器&lt;/h2&gt;
&lt;p&gt;由于目前没有手机项目,这里并不详细介绍,只是作为一个知识点简单介绍一下.&lt;/p&gt;
&lt;p&gt;看以下测试代码&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;        [Fact]
        public void DropDownListTest()
        {
            ChromeOptions opts = new ChromeOptions();
            opts.EnableMobileEmulation(&quot;iPhone X&quot;);
            IWebDriver driver =
                new ChromeDriver(Environment.CurrentDirectory,opts);
            driver.Url = &quot;http://www.baidu.com&quot;;
            driver.Navigate();

        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里主要是增加一个谷歌浏览器启用模拟手机浏览器选项,并指定一个模拟器的名字(这些名字可以通过谷歌浏览器的手机模式查看).然后再启动页面就会在指定的手机模拟器运行了.&lt;/p&gt;
&lt;p&gt;以上运行结果截图如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201908/811801-20190820080630610-1409886031.png&quot; alt=&quot;avatar&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 20 Aug 2019 00:07:00 +0000</pubDate>
<dc:creator>周国通</dc:creator>
<og:description>'系列目录' 通过前面的单元测试,我们能够保证项目的基本模块功能逻辑是正常的,通过集成测试能够保证接口的请求是正常的.然而最终项目交付我们还需要对项目进行页面的行为进行测试,比如页面布局是否正常,按钮</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tylerzhou/p/11380856.html</dc:identifier>
</item>
<item>
<title>Kafka 系列（五）—— 深入理解 Kafka 副本机制 - 黑白影</title>
<link>http://www.cnblogs.com/heibaiying/p/11380835.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/heibaiying/p/11380835.html</guid>
<description>&lt;h2 id=&quot;一kafka集群&quot;&gt;一、Kafka集群&lt;/h2&gt;
&lt;p&gt;Kafka 使用 Zookeeper 来维护集群成员 (brokers) 的信息。每个 broker 都有一个唯一标识 &lt;code&gt;broker.id&lt;/code&gt;，用于标识自己在集群中的身份，可以在配置文件 &lt;code&gt;server.properties&lt;/code&gt; 中进行配置，或者由程序自动生成。下面是 Kafka brokers 集群自动创建的过程：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;每一个 broker 启动的时候，它会在 Zookeeper 的 &lt;code&gt;/brokers/ids&lt;/code&gt; 路径下创建一个 &lt;code&gt;临时节点&lt;/code&gt;，并将自己的 &lt;code&gt;broker.id&lt;/code&gt; 写入，从而将自身注册到集群；&lt;/li&gt;
&lt;li&gt;当有多个 broker 时，所有 broker 会竞争性地在 Zookeeper 上创建 &lt;code&gt;/controller&lt;/code&gt; 节点，由于 Zookeeper 上的节点不会重复，所以必然只会有一个 broker 创建成功，此时该 broker 称为 controller broker。它除了具备其他 broker 的功能外，&lt;strong&gt;还负责管理主题分区及其副本的状态&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;当 broker 出现宕机或者主动退出从而导致其持有的 Zookeeper 会话超时时，会触发注册在 Zookeeper 上的 watcher 事件，此时 Kafka 会进行相应的容错处理；如果宕机的是 controller broker 时，还会触发新的 controller 选举。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;二副本机制&quot;&gt;二、副本机制&lt;/h2&gt;
&lt;p&gt;为了保证高可用，kafka 的分区是多副本的，如果一个副本丢失了，那么还可以从其他副本中获取分区数据。但是这要求对应副本的数据必须是完整的，这是 Kafka 数据一致性的基础，所以才需要使用 &lt;code&gt;controller broker&lt;/code&gt; 来进行专门的管理。下面将详解介绍 Kafka 的副本机制。&lt;/p&gt;
&lt;h3 id=&quot;分区和副本&quot;&gt;2.1 分区和副本&lt;/h3&gt;
&lt;p&gt;Kafka 的主题被分为多个分区 ，分区是 Kafka 最基本的存储单位。每个分区可以有多个副本 (可以在创建主题时使用 &lt;code&gt;replication-factor&lt;/code&gt; 参数进行指定)。其中一个副本是首领副本 (Leader replica)，所有的事件都直接发送给首领副本；其他副本是跟随者副本 (Follower replica)，需要通过复制来保持与首领副本数据一致，当首领副本不可用时，其中一个跟随者副本将成为新首领。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/heibaiying/BigData-Notes/master/pictures/kafka-cluster.png&quot;/&gt;&lt;/div&gt;
&lt;h3 id=&quot;isr机制&quot;&gt;2.2 ISR机制&lt;/h3&gt;
&lt;p&gt;每个分区都有一个 ISR(in-sync Replica) 列表，用于维护所有同步的、可用的副本。首领副本必然是同步副本，而对于跟随者副本来说，它需要满足以下条件才能被认为是同步副本：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;与 Zookeeper 之间有一个活跃的会话，即必须定时向 Zookeeper 发送心跳；&lt;/li&gt;
&lt;li&gt;在规定的时间内从首领副本那里低延迟地获取过消息。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果副本不满足上面条件的话，就会被从 ISR 列表中移除，直到满足条件才会被再次加入。&lt;/p&gt;
&lt;p&gt;这里给出一个主题创建的示例：使用 &lt;code&gt;--replication-factor&lt;/code&gt; 指定副本系数为 3，创建成功后使用 &lt;code&gt;--describe&lt;/code&gt; 命令可以看到分区 0 的有 0,1,2 三个副本，且三个副本都在 ISR 列表中，其中 1 为首领副本。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/heibaiying/BigData-Notes/master/pictures/kafka-%E5%88%86%E5%8C%BA%E5%89%AF%E6%9C%AC.png&quot;/&gt;&lt;/div&gt;
&lt;h3 id=&quot;不完全的首领选举&quot;&gt;2.3 不完全的首领选举&lt;/h3&gt;
&lt;p&gt;对于副本机制，在 broker 级别有一个可选的配置参数 &lt;code&gt;unclean.leader.election.enable&lt;/code&gt;，默认值为 fasle，代表禁止不完全的首领选举。这是针对当首领副本挂掉且 ISR 中没有其他可用副本时，是否允许某个不完全同步的副本成为首领副本，这可能会导致数据丢失或者数据不一致，在某些对数据一致性要求较高的场景 (如金融领域)，这可能无法容忍的，所以其默认值为 false，如果你能够允许部分数据不一致的话，可以配置为 true。&lt;/p&gt;
&lt;h3 id=&quot;最少同步副本&quot;&gt;2.4 最少同步副本&lt;/h3&gt;
&lt;p&gt;ISR 机制的另外一个相关参数是 &lt;code&gt;min.insync.replicas&lt;/code&gt; , 可以在 broker 或者主题级别进行配置，代表 ISR 列表中至少要有几个可用副本。这里假设设置为 2，那么当可用副本数量小于该值时，就认为整个分区处于不可用状态。此时客户端再向分区写入数据时候就会抛出异常 &lt;code&gt;org.apache.kafka.common.errors.NotEnoughReplicasExceptoin: Messages are rejected since there are fewer in-sync replicas than required。&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;发送确认&quot;&gt;2.5 发送确认&lt;/h3&gt;
&lt;p&gt;Kafka 在生产者上有一个可选的参数 ack，该参数指定了必须要有多少个分区副本收到消息，生产者才会认为消息写入成功：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;acks=0&lt;/strong&gt; ：消息发送出去就认为已经成功了，不会等待任何来自服务器的响应；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;acks=1&lt;/strong&gt; ： 只要集群的首领节点收到消息，生产者就会收到一个来自服务器成功响应；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;acks=all&lt;/strong&gt; ：只有当所有参与复制的节点全部收到消息时，生产者才会收到一个来自服务器的成功响应。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;三数据请求&quot;&gt;三、数据请求&lt;/h2&gt;
&lt;h3 id=&quot;元数据请求机制&quot;&gt;3.1 元数据请求机制&lt;/h3&gt;
&lt;p&gt;在所有副本中，只有领导副本才能进行消息的读写处理。由于不同分区的领导副本可能在不同的 broker 上，如果某个 broker 收到了一个分区请求，但是该分区的领导副本并不在该 broker 上，那么它就会向客户端返回一个 &lt;code&gt;Not a Leader for Partition&lt;/code&gt; 的错误响应。 为了解决这个问题，Kafka 提供了元数据请求机制。&lt;/p&gt;
&lt;p&gt;首先集群中的每个 broker 都会缓存所有主题的分区副本信息，客户端会定期发送发送元数据请求，然后将获取的元数据进行缓存。定时刷新元数据的时间间隔可以通过为客户端配置 &lt;code&gt;metadata.max.age.ms&lt;/code&gt; 来进行指定。有了元数据信息后，客户端就知道了领导副本所在的 broker，之后直接将读写请求发送给对应的 broker 即可。&lt;/p&gt;
&lt;p&gt;如果在定时请求的时间间隔内发生的分区副本的选举，则意味着原来缓存的信息可能已经过时了，此时还有可能会收到 &lt;code&gt;Not a Leader for Partition&lt;/code&gt; 的错误响应，这种情况下客户端会再次求发出元数据请求，然后刷新本地缓存，之后再去正确的 broker 上执行对应的操作，过程如下图：&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/heibaiying/BigData-Notes/master/pictures/kafka-%E5%85%83%E6%95%B0%E6%8D%AE%E8%AF%B7%E6%B1%82.png&quot;/&gt;&lt;/div&gt;
&lt;h3 id=&quot;数据可见性&quot;&gt;3.2 数据可见性&lt;/h3&gt;
&lt;p&gt;需要注意的是，并不是所有保存在分区首领上的数据都可以被客户端读取到，为了保证数据一致性，只有被所有同步副本 (ISR 中所有副本) 都保存了的数据才能被客户端读取到。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/heibaiying/BigData-Notes/master/pictures/kafka-%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%81%E6%80%A7.png&quot;/&gt;&lt;/div&gt;
&lt;h3 id=&quot;零拷贝&quot;&gt;3.3 零拷贝&lt;/h3&gt;
&lt;p&gt;Kafka 所有数据的写入和读取都是通过零拷贝来实现的。传统拷贝与零拷贝的区别如下：&lt;/p&gt;
&lt;h4 id=&quot;传统模式下的四次拷贝与四次上下文切换&quot;&gt;传统模式下的四次拷贝与四次上下文切换&lt;/h4&gt;
&lt;p&gt;以将磁盘文件通过网络发送为例。传统模式下，一般使用如下伪代码所示的方法先将文件数据读入内存，然后通过 Socket 将内存中的数据发送出去。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;buffer = File.read
Socket.send(buffer)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这一过程实际上发生了四次数据拷贝。首先通过系统调用将文件数据读入到内核态 Buffer（DMA 拷贝），然后应用程序将内存态 Buffer 数据读入到用户态 Buffer（CPU 拷贝），接着用户程序通过 Socket 发送数据时将用户态 Buffer 数据拷贝到内核态 Buffer（CPU 拷贝），最后通过 DMA 拷贝将数据拷贝到 NIC Buffer。同时，还伴随着四次上下文切换，如下图所示：&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/heibaiying/BigData-Notes/master/pictures/kafka-BIO.png&quot;/&gt;&lt;/div&gt;
&lt;h4 id=&quot;sendfile和transferto实现零拷贝&quot;&gt;sendfile和transferTo实现零拷贝&lt;/h4&gt;
&lt;p&gt;Linux 2.4+ 内核通过 &lt;code&gt;sendfile&lt;/code&gt; 系统调用，提供了零拷贝。数据通过 DMA 拷贝到内核态 Buffer 后，直接通过 DMA 拷贝到 NIC Buffer，无需 CPU 拷贝。这也是零拷贝这一说法的来源。除了减少数据拷贝外，因为整个读文件到网络发送由一个 &lt;code&gt;sendfile&lt;/code&gt; 调用完成，整个过程只有两次上下文切换，因此大大提高了性能。零拷贝过程如下图所示：&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/heibaiying/BigData-Notes/master/pictures/kafka-%E9%9B%B6%E6%8B%B7%E8%B4%9D.png&quot;/&gt;&lt;/div&gt;
&lt;p&gt;从具体实现来看，Kafka 的数据传输通过 TransportLayer 来完成，其子类 &lt;code&gt;PlaintextTransportLayer&lt;/code&gt; 的 &lt;code&gt;transferFrom&lt;/code&gt; 方法通过调用 Java NIO 中 FileChannel 的 &lt;code&gt;transferTo&lt;/code&gt; 方法实现零拷贝，如下所示：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Override
public long transferFrom(FileChannel fileChannel, long position, long count) throws IOException {
    return fileChannel.transferTo(position, count, socketChannel);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt; &lt;code&gt;transferTo&lt;/code&gt; 和 &lt;code&gt;transferFrom&lt;/code&gt; 并不保证一定能使用零拷贝。实际上是否能使用零拷贝与操作系统相关，如果操作系统提供 &lt;code&gt;sendfile&lt;/code&gt; 这样的零拷贝系统调用，则这两个方法会通过这样的系统调用充分利用零拷贝的优势，否则并不能通过这两个方法本身实现零拷贝。&lt;/p&gt;
&lt;h2 id=&quot;四物理存储&quot;&gt;四、物理存储&lt;/h2&gt;
&lt;h3 id=&quot;分区分配&quot;&gt;4.1 分区分配&lt;/h3&gt;
&lt;p&gt;在创建主题时，Kafka 会首先决定如何在 broker 间分配分区副本，它遵循以下原则：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在所有 broker 上均匀地分配分区副本；&lt;/li&gt;
&lt;li&gt;确保分区的每个副本分布在不同的 broker 上；&lt;/li&gt;
&lt;li&gt;如果使用了 &lt;code&gt;broker.rack&lt;/code&gt; 参数为 broker 指定了机架信息，那么会尽可能的把每个分区的副本分配到不同机架的 broker 上，以避免一个机架不可用而导致整个分区不可用。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;基于以上原因，如果你在一个单节点上创建一个 3 副本的主题，通常会抛出下面的异常：&lt;/p&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;Error while executing topic command : org.apache.kafka.common.errors.InvalidReplicationFactor   
Exception: Replication factor: 3 larger than available brokers: 1.&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;分区数据保留规则&quot;&gt;4.2 分区数据保留规则&lt;/h3&gt;
&lt;p&gt;保留数据是 Kafka 的一个基本特性， 但是 Kafka 不会一直保留数据，也不会等到所有消费者都读取了消息之后才删除消息。相反， Kafka 为每个主题配置了数据保留期限，规定数据被删除之前可以保留多长时间，或者清理数据之前可以保留的数据量大小。分别对应以下四个参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;log.retention.bytes&lt;/code&gt; ：删除数据前允许的最大数据量；默认值-1，代表没有限制；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;log.retention.ms&lt;/code&gt;：保存数据文件的毫秒数，如果未设置，则使用 &lt;code&gt;log.retention.minutes&lt;/code&gt; 中的值，默认为 null；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;log.retention.minutes&lt;/code&gt;：保留数据文件的分钟数，如果未设置，则使用 &lt;code&gt;log.retention.hours&lt;/code&gt; 中的值，默认为 null；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;log.retention.hours&lt;/code&gt;：保留数据文件的小时数，默认值为 168，也就是一周。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因为在一个大文件里查找和删除消息是很费时的，也很容易出错，所以 Kafka 把分区分成若干个片段，当前正在写入数据的片段叫作活跃片段。活动片段永远不会被删除。如果按照默认值保留数据一周，而且每天使用一个新片段，那么你就会看到，在每天使用一个新片段的同时会删除一个最老的片段，所以大部分时间该分区会有 7 个片段存在。&lt;/p&gt;
&lt;h3 id=&quot;文件格式&quot;&gt;4.3 文件格式&lt;/h3&gt;
&lt;p&gt;通常保存在磁盘上的数据格式与生产者发送过来消息格式是一样的。 如果生产者发送的是压缩过的消息，那么同一个批次的消息会被压缩在一起，被当作“包装消息”进行发送 (格式如下所示) ，然后保存到磁盘上。之后消费者读取后再自己解压这个包装消息，获取每条消息的具体信息。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/heibaiying/BigData-Notes/master/pictures/kafka-compress-message.png&quot;/&gt;&lt;/div&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;Neha Narkhede, Gwen Shapira ,Todd Palino(著) , 薛命灯 (译) . Kafka 权威指南 . 人民邮电出版社 . 2017-12-26&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.jasongj.com/kafka/high_throughput/&quot;&gt;Kafka 高性能架构之道&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;3.75&quot;&gt;
&lt;p&gt;&lt;strong&gt;更多大数据系列文章可以参见 GitHub 开源项目&lt;/strong&gt;： &lt;a href=&quot;https://github.com/heibaiying/BigData-Notes&quot;&gt;&lt;strong&gt;大数据入门指南&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 19 Aug 2019 23:42:00 +0000</pubDate>
<dc:creator>黑白影</dc:creator>
<og:description>一、Kafka集群 Kafka 使用 Zookeeper 来维护集群成员 (brokers) 的信息。每个 broker 都有一个唯一标识 ，用于标识自己在集群中的身份，可以在配置文件 中进行配置，或</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/heibaiying/p/11380835.html</dc:identifier>
</item>
<item>
<title>Docker系列之.NET Core入门（三） - Jeffcky</title>
<link>http://www.cnblogs.com/CreateMyself/p/11342976.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CreateMyself/p/11342976.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;在Docker生态系统中除了上一节所讲解的基本概念，还有其他专业术语，本文我们将一笔带过，同时会开始陆续进入到在.NET Core中使用Docker。&lt;/p&gt;
&lt;h2&gt;专业术语&lt;/h2&gt;
&lt;blockquote readability=&quot;40&quot;&gt;
&lt;p&gt;Docker Engine（Docker引擎）：客户端 - 服务器应用程序。 Docker公司将Docker Engine分为两个产品。 Docker Community Edition（CE）基于开源工具且免费，我们学习时可以使用这款产品。 Docker Enterprise附带了其他功能支持，比如管理和安全等等功能。&lt;/p&gt;
&lt;p&gt;Docker Client（Docker客户端）：我们与Docker进行交互的主要方式。 使用Docker命令行界面（CLI）时，在终端中键入以docker开头的命令，Docker Client会使用Docker API将命令发送到Docker守护进程中。&lt;/p&gt;
&lt;p&gt;Docker Daemon（Docker守护进程）：监听Docker API请求的Docker服务器。 Docker守护进程主要管理镜像，容器，网络和卷。&lt;/p&gt;
&lt;p&gt;Docker Volumes（Docker卷）：存储创建应用程序和运行应用程序持久化数据的最佳方式。&lt;/p&gt;
&lt;p&gt;Docker Registry：存储Docker镜像的远程注册位置。 我们将镜像推送到注册表并从注册表中提取图像，我们可以托管自己的注册表或使用供应商商的注册表。&lt;/p&gt;
&lt;p&gt;Docker Hub：Docker镜像的最大注册表。 它也是Dcoker默认的注册表位置， 我们可以在Docker Hub上找到免费的镜像并存储我们自己的图像。&lt;/p&gt;
&lt;p&gt;Docker Networking：允许我们将Docker容器连接在一起。 连接的Docker容器可以位于同一主机或多个主机上。&lt;/p&gt;
&lt;p&gt;Docker Compose：属于一个工具，我们可以非常轻松地运行需要多个Docker容器的应用程序。 Docker Compose允许我们将命令写到docker-compose.yml文件中以供重用。 Docker Compose命令行界面（cli）使我们可以更轻松地与多容器应用程序进行交互。 Docker Compose免费安装Docker。&lt;/p&gt;
&lt;p&gt;Docker Swarm：容器部署编排的产品。Docker官方教程进行容器编排和部署使用的Docker Swarm。 建议不要浪费时间在Docker Swarm上，推荐使用Kubernetes(k8s)。&lt;/p&gt;
&lt;p&gt;Docker Services：分布式应用程序的不同部分。 服务实际上只是“生产中的容器”。服务只运行一个镜像，但它编码了镜像的运行方式 - 它应该使用哪些端口，容器应该运行多少个副本，以便服务具有所需的容量等等。 扩展服务会更改运行该软件的容器实例的数量，从而为流程中的服务分配更多计算资源。Docker服务允许我们跨多个Docker守护进程扩展容器，并使Docker Swarms成为可能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;回顾容器&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;Docker镜像在构建时被创建，而Dokcer容器在运行时被创建&lt;/span&gt;。Dockerfile是Docker的核心，Dockerfile告诉Docker如何构建镜像从而被用来制作容器，每个Docker镜像都包含一个名为Dockerfile但没有扩展名的文件。当调用docker build以创建映像时，假定Dockerfile位于当前工作目录中，可以使用文件标志（-f）指定到其他位置，容器是由一系列层所构建，而且每个镜像层只读，除了位于其他镜像层之上的最终容器镜像层。 Dockerfile告诉Docker要添加哪些层以及添加它们的顺序，每个镜像层实际上只是一个包含自上一层以来的所更改的文件。 在linux中，几乎所有东西都是文件。基础镜像提供初始层，基础镜像也称为父镜像，将镜像从远程存储库提取到本地时，仅仅只下载本地计算机上尚未存在的层， Docker通过重用现有层来节省空间和时间。&lt;/p&gt;
&lt;p&gt;Dockerfile指令是一行开头的大写单词，后紧跟其参数，Dockerfile中的每一行都可以包含一条指令。 构建图像时，将从上到下处理指令，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201908/589642-20190819222153703-781234585.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;只有FROM，RUN，COPY和ADD指令才能在最终镜像中创建镜像层，其他指令只是作为配置或说明，比如添加元数据或告诉Docker在运行时执行某些操作，例如公开端口或运行命令。在本文中，我们使用基于linux的Docker镜像，当然我们也可以使用基于Windows的镜像，建议使用linux。接下来我们来过滤下Dockerfile中各个指令说明。&lt;/p&gt;
&lt;h2&gt;Dockerfile指令&lt;/h2&gt;
&lt;p&gt;FROM - 指定基础（父）镜像。&lt;/p&gt;
&lt;p&gt;LABEL - 提供元数据，包含维护者信息。&lt;/p&gt;
&lt;p&gt;ENV - 设置持久化环境变量。&lt;/p&gt;
&lt;p&gt;RUN - 运行命令并创建镜像层，用于将包安装到容器中。&lt;/p&gt;
&lt;p&gt;COPY - 将文件和目录复制到容器中。&lt;/p&gt;
&lt;p&gt;ADD - 将文件和目录复制到容器中。 可以upack本地.tar文件。&lt;/p&gt;
&lt;p&gt;CMD - 为执行容器提供命令和参数，可以覆盖参数，只能有一个CMD。&lt;/p&gt;
&lt;p&gt;WORKDIR - 设置后续说明的工作目录。&lt;/p&gt;
&lt;p&gt;ARG - 定义一个在构建时传递给Docker的变量。&lt;/p&gt;
&lt;p&gt;ENTRYPOINT - 为正在执行的容器提供命令和参数。 &lt;/p&gt;
&lt;p&gt;EXPOSE - 对外暴露端口。&lt;/p&gt;
&lt;p&gt;VOLUME - 创建目录用于访问和存储持久化数据。&lt;/p&gt;
&lt;h2&gt;.NET Core入门例子 &lt;/h2&gt;
&lt;p&gt;接下来我们以.NET Core中使用Docker并输出Hello World结束本文。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201908/589642-20190819234542408-940300346.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们通过命令创建一个.NET Core控制台程序，接下来为了在页面上输出Hello World，我们需要使用中间件，所以我们添加AspNetCore包，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201908/589642-20190819234747914-1889012454.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我们打开控制台程序，添加中间件打印Hello World代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Startup
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder applicationBuilder, IHostingEnvironment hostingEnvironment)
        {
            applicationBuilder.Run(&lt;/span&gt;&lt;span&gt;async&lt;/span&gt; context =&amp;gt;&lt;span&gt;
              {
                  &lt;/span&gt;&lt;span&gt;await&lt;/span&gt; context.Response.WriteAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello World&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
              });
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            WebHost.CreateDefaultBuilder()
           .UseStartup&lt;/span&gt;&amp;lt;Startup&amp;gt;&lt;span&gt;()
           .UseKestrel()
           .UseUrls(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://0.0.0.0:5050&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
           .Build()
           .Run();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;程序已就绪完毕，接下来我们发布该控制台程序，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201908/589642-20190819235341086-1226416215.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来将执行上述步骤生成的bin目录（实际上只需拷贝发布后生成的publish目录即可，为了省事，我直接拷贝了整个bin目录）拷贝到ubuntu中（由于我对linux不熟悉，所以采用虚拟机加载桌面端ubuntu镜像的方式，对于从未使用过linux的童鞋，推荐使用桌面端ubuntu，友好的GUI界面，方便我们初学知道各个文件夹是做什么的，一看便知，后续再使用服务端版的ubuntu就会得心应手啦）。 &lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201908/589642-20190820000037782-472240801.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来我们进入HelloWorld文件目录，创建Dockerfile文件从而来创建.NET Core镜像。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201908/589642-20190820000337527-733172261.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我们来编写Dockerfile文件构建镜像，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
FROM mcr.microsoft.com/dotnet/core/aspnet:&lt;span&gt;2.2&lt;/span&gt;&lt;span&gt; AS runtime

COPY .&lt;/span&gt;/bin/Debug/netcoreapp2.&lt;span&gt;2&lt;/span&gt;/linux-x64/publish/ ./&lt;span&gt;

ENTRYPOINT [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dotnet&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HelloWorld.dll&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201908/589642-20190820000543243-714401148.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;父镜像为.NET Core 2.2版本和我们创建的程序版本一致，然后将我们的应用程序(即publish目录)拷贝，最后指定程序运行的命令和参数。有了Dockerfile文件，那么我们就可以开始构建镜像了，终端继续运行如下命令(&lt;span&gt;注意：镜像标签名称必须全部为小写，否则报错&lt;/span&gt;)：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
docker build . -t hellowrold
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201908/589642-20190820000923717-1691193248.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;镜像已构建完毕，接下来则是创建并启动容器运行程序，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
docker run -p &lt;span&gt;5050&lt;/span&gt;:&lt;span&gt;5050&lt;/span&gt; hellowrold
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201908/589642-20190820001424771-1684720213.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上述我们可看到容器已正常启动，且运行环境为生产环境，监听端口为5050。桌面版ubuntu默认为我们安装了火狐浏览器，此时我们打开浏览器将会输出Hello World，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201908/589642-20190820001733304-1666780943.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201908/589642-20190820001843788-949918347.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;总结 &lt;/h2&gt;
&lt;p&gt;本文我们介绍Docker中的一些术语，然后最后写了一个在.NET Core中使用Docker的入门例子，非常简单。若直接使用服务端版本的ubuntu我是一脸懵逼，有了界面，我也大概知道了一些文件夹里存放的是什么，一目了然，虽说这还只是冰山一角，每天积累一点，日积月累，厚积薄发嘛不是。 &lt;/p&gt;
</description>
<pubDate>Mon, 19 Aug 2019 23:41:00 +0000</pubDate>
<dc:creator>Jeffcky</dc:creator>
<og:description>前言 在Docker生态系统中除了上一节所讲解的基本概念，还有其他专业术语，本文我们将一笔带过，同时会开始陆续进入到在.NET Core中使用Docker。 专业术语 Docker Engine（Do</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/CreateMyself/p/11342976.html</dc:identifier>
</item>
<item>
<title>部分APP无法代理抓包的原因及解决方法 - lulianqi15</title>
<link>http://www.cnblogs.com/lulianqi/p/11380794.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lulianqi/p/11380794.html</guid>
<description>&lt;h2&gt;引言&lt;/h2&gt;
&lt;p&gt;HTTP应用层的抓包已经成为日常工作测试与调试中的重要一环，最近接触新项目突然之间发现之前的抓包手段都不好使了，顿时模块与模块之间的前端与服务之间的交互都变成了不可见，整个人都好像被蒙住了眼睛。&lt;/p&gt;
&lt;p&gt;其实自己也很早就发现平时使用的支付宝等APP使用Fiddler 或 Charles这类代理抓包软件默认情况下就无法抓取请求的，但使用Wireshark这类网卡抓包软件可以看到这些APP的流量，而已这些流量也表明这些APP使用的主要应用层协议仍然是HTTP（https），不过我们的代理抓包工具却失效了。如今终于在实际工作中遇到了，也不得不解决了，毕竟眼前有东西挡住会让我浑身不适。&lt;/p&gt;


&lt;h2&gt;代理抓包原理&lt;/h2&gt;
&lt;div readability=&quot;9.5366795366795&quot;&gt;为了弄明白为什么Fiddler 或 Charles对这些APP无效，我们有必要先了解代理抓包我原理（当然您不想了解也是完全可以的，直接看后面的&lt;a href=&quot;https://www.cnblogs.com/lulianqi/p/11380794.html#l_1&quot;&gt;实际操作&lt;/a&gt;就可以完成，原理分析什么的可以有兴趣随时回来看）&lt;/div&gt;

&lt;p&gt;Fiddler 或 Charles 这类使用的代理的抓包软件与Wireshark是完全不同的（Wireshark 使用的网卡数据复制，只要是经过指定网卡都会被抓取），其只能对使用代理的应用层网络协议生效，比如常见的HTTP（https），Websocket  。&lt;/p&gt;
&lt;p&gt;这里以HTTP为例简单说明下&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/209007/201908/209007-20190820045101040-740598303.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;
&lt;div readability=&quot;8.0217391304348&quot;&gt;客户端需要完成一次HTTP请求，通常需要先找到服务器，客户端会根据http请求中url的主机名（实际会使用host中的主角名）及其端口与目标主机建立tcp连接，建立连接后会将http报文发送给目标服务器 （更多细节请参考&lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;https://tools.ietf.org/html/rfc7232&lt;/a&gt;）&lt;/div&gt;

&lt;p&gt;接下来我来看下HTTP代理是如何运作的，我们启动Fiddler 或 Charles就是启动了一个HTTP代理服务器，这类工具会通知操作系统，“现在我在系统上创建了一个HTTP代理，IP为XXXXXX端口为XX。如果您使用的是linux您可以手动通知操作系统(export http_proxy=ip:port export https_proxy=$http_proxy),如果您使用的是手机等移动设备您可以在当前wifi设置处告诉系统你要使用http代理。 现在我们已经告诉系统我们想要使用代理，这个时候运行在系统上的http客户端再去发送请求的时候，他就不会再去进行DNS解析，去连接目标服务器，而是直接连接系统告诉他代理所在的地址（代理的ip及端口，注意无论是http或https或其他支持代理的协议都会连接同一个端口）。然后代理服务器会与客户端建立连接，再然后代理服务器根据请求信息再去连接真正的服务器。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/209007/201908/209007-20190820045116747-1833239090.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;
&lt;p&gt;这里还有个细节正常在没有代理的情况下客户端向服务器发送的请求行里只包含部分URI（实际上是没有方案，主机名及端口的）&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/209007/201908/209007-20190820045201299-1206950664.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;
&lt;p&gt;如上图如果在没有代理的情况下，对www.baidu.com/index.html的请求的请求行实际上是GET /index.html HTTP/1.1 其实并不是我们常见的完整uri。因为在原始的HTTP设计中没有考虑中间服务器（即代理）的情况，客户端在发送报文前已经知道服务器的地址并与之建立了连接，没有必要再发送方案，主机名及端口。不过代理出现后这种做法就会有问题了，客户端连接了代理服务器，而代理服务器却没有办法连接正确的服务器。因此客户端发送给代理的请求其实稍有不同，客户端会在请求行里使用完整的uri，这样代理服务器才能解析真实的服务器的地址。&lt;/p&gt;
&lt;p&gt;现在我们的请求实际上都是通过代理服务器（Fiddler 或 Charles）发送出去的，所以代理抓包软件不仅知道http请求及响应的所有报文，甚至还可以随时修改请求及响应。&lt;/p&gt;

&lt;h2&gt;部分应用不能抓包的原因&lt;/h2&gt;
&lt;p&gt;可以看到代理抓包的关键就是需要HTTP客户端按照要求去连接代理服务器，一般情况下我们已经在系统层面上设置了代理，通常http客户端都是按要求去实现的，在进行http请求前会先检查系统代理，如果有设置代理，客户端会直接使用完整uri去连接代理服务器。不同的平台通常会实现自己的的http客户端的，虽然他们都按照协议要求实现了代理功能，但是并不一定在默认情况下会直接使用系统代理。&lt;/p&gt;
&lt;p&gt;在现实中这种况下这种情况还不少，笔者当前项目使用到的Flutter就是这种情况，默认Flutter不会主动使用系统代理，需要单独设置。（当然个人认为这种策略也是有理由，虽然给测试及调试带来了不便不过也在一程度上提高了些许数据安全）&lt;/p&gt;
&lt;p&gt;正是因为HTTP客户端没有使用我们设置的系统代理，他们自然也不会连接Fiddler 或 Charles创建的代理服务器，最终导致我们无法获取任何请求。&lt;/p&gt;

&lt;h2&gt;解决方案&lt;/h2&gt;
&lt;p&gt;不过既然我们已经知道了Fiddler 和 Charles不能抓包的具体原因，前面也提到了代理抓包的原理，那我们就总有办法解决。&lt;/p&gt;
&lt;p&gt;前面说到了我们APP使用的HTTP客户端没有连接到代理服务器，导致我们的代理抓包软件无法正常抓包，那我们只要想办法让客户端重新连接到代理服务器就好了（当然这一切都是以不修改客户端软件APP为前提的）&lt;/p&gt;
&lt;p&gt;方法1：控制DNS解析，通过修改dns的方式让客户端以为我们的代理服务器就是目标服务器。&lt;/p&gt;
&lt;p&gt;            优势：操作方便，通过修改设备的hosts可以十分方便的首先&lt;/p&gt;
&lt;p&gt;            劣势：需要为每个需要操作的域名提前添加host&lt;/p&gt;
&lt;p&gt;                      在手机等手持设备上难以修改hosts（即对移动APP这类应用很难实现）&lt;/p&gt;

&lt;p&gt;方法2：在网络设备上直接做流量转发，将指定终端设备上发往80及443端口的数据直接转发到代理服务器的    目标端口上&lt;/p&gt;
&lt;p&gt;           优势：可以针对连接到网络设备上的终端设备进行分别配置，而手机等终端设备不需要进行任何设备&lt;/p&gt;
&lt;p&gt;           劣势：需要单独的硬件设备&lt;/p&gt;

&lt;p&gt;方法3：使用VPN将终端设备的流量转发到代理服务器&lt;/p&gt;
&lt;p&gt;           优势：使用VPN软件不用添加其他测试。&lt;/p&gt;
&lt;p&gt;           劣势：终端上的VPN默认会直接对所有流量进行转发，要进行合理的配置可能需要额外的学习成本&lt;/p&gt;

&lt;h2&gt;实际操作步骤&lt;/h2&gt;
&lt;div readability=&quot;12.81658692185&quot;&gt;笔者这里直接使用上面提到第3种方法（方法1在对于手机APP很难操作，方法2可能需要其他设备所以这里不使用），因为我们的测试对象是手机移动APP，所以我们首先要在手机上安装一个VPN，这里使用一个十分方便的VPN软件drony （介绍在这里&lt;a href=&quot;https://github.com/SuppSandroB/sandrop/wiki/Drony-FAQ&quot;&gt;https://github.com/SuppSandroB/sandrop/wiki/Drony-FAQ&lt;/a&gt;），drony会在你的手机上创建一个VPN，将手机上的所有流量都重定向到drony自身（不是流向vpn服务器） ，这样drony就可以管理所有手机上的网络流量，甚至可以对手机上不同APP的流量进行单独配置。&lt;/div&gt;
&lt;h3&gt;1：安装drony  （这里手机使用的Android设备）&lt;/h3&gt;

&lt;div&gt;   &lt;img src=&quot;https://img2018.cnblogs.com/blog/209007/201908/209007-20190820045253676-205232869.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;


&lt;h3&gt;2：开启代理抓包软件（这里代理抓包软件使用的是Fiddler）&lt;/h3&gt;
&lt;p&gt;  Fiddler的使用这里不再介绍，需要打开远程代理，并在手机中安装Fiddler根证书&lt;/p&gt;
&lt;p&gt;  这里笔者开启的远程代理的地址是192.168.2.244:8888&lt;/p&gt;
&lt;p&gt;  关于证书安装有些细节，Fiddler默认的根证书是cer格式，部分手机可能只能识别pem格式证书&lt;/p&gt;
&lt;p&gt;  直接使用openssl 转一下就行了 （openssl x509 -inform der -in FiddlerRoot.cer -out FiddlerRoot.pem）&lt;/p&gt;
&lt;p&gt;  openssl 在中 windows/mac 一般都安装有，命令直接使用就行了，使用生成的FiddlerRoot.pem安装到手机上就行了（Charles默认就是pem证书）&lt;/p&gt;

&lt;h3&gt;3：配置drony转发&lt;/h3&gt;
&lt;div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/209007/201908/209007-20190820045310049-1416053217.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;p&gt;打开Drony（处于OFF状态），滑动到SETING页，点击选择Networks Wi-Fi 进入配置&lt;/p&gt;
&lt;div&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/209007/201908/209007-20190820045440754-1113055467.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;
&lt;p&gt;在网络列表中选择点击当前手机wifi连接的网络 （需要确保该网络与Fiddler代理服务器网络是联通的）&lt;/p&gt;
&lt;div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/209007/201908/209007-20190820045502038-310691272.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;/div&gt;
&lt;p&gt;配置要为当前网络使用的代理入口（这里直接填写fiddler代理地址就可以），选择代理模式为手动（Manual）&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/209007/201908/209007-20190820045515523-88075362.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;
&lt;p&gt;注意Proxy type代理方式要选择 Plain http proxy&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/209007/201908/209007-20190820045531427-413658920.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;
&lt;p&gt;Filter default value 选择 Direct all ，然后点击下面的Rule设置应用规则&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/209007/201908/209007-20190820045543225-129850996.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;
&lt;p&gt;默认您的规则里应该是空的，这里直接点击上面的加号添加一个规则（符合规则要求的才会被转发）&lt;/p&gt;
&lt;p&gt;说明一下后面的操作会以咸鱼或支付宝做演示说明，不过笔者当前测试项目并不是咸鱼或支付宝，也不是其公司的员工，选择这2个APP做演示是因为这些APP比较常用，且无法抓包的原因与笔者当前项目APP是类似的。&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/209007/201908/209007-20190820045556355-484314983.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;
&lt;p&gt;在Network id处 选择当前wifi的SSID&lt;/p&gt;
&lt;p&gt;Action 选择 Local proxy chain&lt;/p&gt;
&lt;p&gt;Application 选择需要强制代理的APP&lt;/p&gt;
&lt;p&gt;Hostname 及 Port 不填 表示所有的都会被强制代理，因为APP可能会使用其他的网络协议不一定都是http，可能不希望把所有流量都引流到http代理服务器，这个时候就会使用这个配置指定ip及端口才转发&lt;/p&gt;
&lt;p&gt;完成后保存即可，然后返回到SETTING主页，滑动到LOG页，点击下面按钮，使其处于ON的状态（表示启用）&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/209007/201908/209007-20190820045614059-1445595456.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;


&lt;p&gt;这个时候启动支付宝或咸鱼，我们就可以在Fiddler上看到正常的流量。不过如果你的运气与笔者一样可能只能看到这些Tunnel to （TLS管道建立），如果您使用的是Charles在列表里看到的可能是一个个红叉。&lt;/p&gt;

&lt;div&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/209007/201908/209007-20190820045722994-1495476061.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;
&lt;p&gt;当然笔者Fiddler根证书是安装成功的，Fiddler配置也是正确的（手机上的Chrome https抓包都是正常的）&lt;/p&gt;
&lt;div readability=&quot;8.5893536121673&quot;&gt;既然流量已经到Fiddler了，Drony的工作算是完美完成了，之所部分APP以不能解密https报文，还是我们自己证书的问题。首先先简单描述下证书校验的过程（如果不想看这些过程可以直接看后面&lt;a href=&quot;https://www.cnblogs.com/lulianqi/p/11380794.html#l_2&quot;&gt;操作步骤&lt;/a&gt;）&lt;/div&gt;


&lt;h2&gt;证书校验原理&lt;/h2&gt;
&lt;p&gt;无论Fiddler 或 Charles都使用中间人攻击的方式替换tls链路证书，解密报文然后再加密发送给真实服务器。&lt;/p&gt;

&lt;div&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/209007/201908/209007-20190820045702839-1338500421.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;
&lt;p&gt;存在代理的情况下客户端首先连接的是代理服务器（即是图中的攻击者），实际client是直接与Proxy建立的TLS通道，所以代理当然TLS通道的传输密钥然后解密报文。&lt;/p&gt;

&lt;p&gt;不过由于证书的存在，client会校验证书的合法性，然后决定是否连接服务器。我们使用Fiddler或Charles抓取https前在设备中安装根证书正是为了通过client的证书校验。&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/209007/201908/209007-20190820045735425-347009230.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;
&lt;p&gt;在浏览器中任意找一个https的网页，查看其证书信息。&lt;/p&gt;

&lt;p&gt;从这里面我们能看到证书包含以下内容：&lt;/p&gt;
&lt;p&gt;(1) Validity也即有效期，有效期包含生效时间和失效时间，是一个时间区间；&lt;/p&gt;
&lt;p&gt;(2) 公钥信息Subject Public Key Info，包括公钥的加密算法和公钥内容；&lt;/p&gt;
&lt;p&gt;(3) 指纹信息，指纹用于验证证书的完整性，也是证书校验的关键，他保证书没有被修改过。 其原理就是在发布证书时，发布者根据指纹算法(此处证书使用了SHA-1和SHA-256算法 有多个指纹是为了兼容老的客户端)计算整个证书的hash指纹【证书内容hash值使用CA私钥加密就是指纹】并和证书放在一起，client在打开证书时，自己也根据指纹算法计算一下证书的hash值，同时使用自己信任的根证书的公钥解密hash指纹计算出原始hash，如果hash值不一致，则表明证书内容被篡改过；&lt;/p&gt;
&lt;p&gt;(4) 证书的签名Certificate Signature Value和Certificate Signature Algorithm，对证书签名所使用的Hash算法和Hash值；&lt;/p&gt;
&lt;p&gt;(5) 签发该证书的CA机构Issuer；&lt;/p&gt;
&lt;p&gt;(6) 该证书是签发给哪个组织/公司信息Subject；&lt;/p&gt;
&lt;p&gt;(7) 证书版本Version、证书序列号Serial Number以及Extensions扩展信息等。&lt;/p&gt;



&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/209007/201908/209007-20190820045747115-632393349.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;
&lt;p&gt;上图即是证书指纹校验的过程，可能看到Client校验证书的核心其实是CA公钥解密原始指纹，CA公钥从哪里来，为了确保安全设备系统会有一批自己信任的CA公钥列表（根证书）。这些CA公钥对应的一般是权威机构或组织，然后由这些权威机构颁发证书时会使用他们自己的私钥去签名（为证书生成指纹）。这样就确保了只有权威机构颁发给各个网站的证书才会被客户端校验通过。&lt;/p&gt;

&lt;p&gt;Filddler没有这些证书里公钥对应的私钥（CA只会把为完整颁发的证书对应的私钥给网站的所有者），所以没有办法与客户端完成TLS握手。Filddler为了完成握手只能自己为不同的站点生成证书，&lt;/p&gt;
&lt;p&gt;不过自己的生成的证书肯定是用自己的私钥签名的，客户端在自己信任的CA公钥列表找不到对应根证书，肯定是不能通过证书校验的。所以Filddler要求我们安装他的根证书到设备，这样自己签发的证书就可以通过证书校验，自己就能解密https报文了。&lt;/p&gt;

&lt;h2&gt;不能解密的原因&lt;/h2&gt;
&lt;p&gt;其实通过上面的描述也很明白了不能正常建立连接解密https报文的原因就是证书校验失败，我们的根证书安装不够完全。&lt;/p&gt;
&lt;div readability=&quot;11.763016157989&quot;&gt;从Android7.0以后，系统允许每个应用可以定义自己的&lt;a href=&quot;https://developer.android.com/training/articles/security-config#CustomTrust&quot;&gt;可信CA集&lt;/a&gt;。有部分应用默认只会信任系统预装的CA证书，而不会信任用户安装的CA证书（或者说是应用使用的开发框架默认只信任系统证书，因为开发者通常不关心这些配置，也不会去更改他）。而在Android中用户安装的证书都是用户证书，所以无论是Filddler还是Charles我们都只是把他们的根证书安装到了用户证书，这些应用并不使用他们，所以我们的安装的证书是无效的。&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/209007/201908/209007-20190820045802004-1809233138.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;

&lt;h2&gt;解决方法及操作方法&lt;/h2&gt;
&lt;p&gt;既然又知道了原因，那就总还是有办法去解决的。我们只要把代理软件的根证书安装成系统证书就可以了。&lt;/p&gt;
&lt;p&gt;实际上将证书安装到系统区操作还是相对简单的，将证书用指定的名称放到指定的位置（/system/etc/security/cacerts/）就可以了&lt;/p&gt;
&lt;p&gt;先将我们的根证书名称改为&amp;lt;Certificate_Hash&amp;gt;.&amp;lt;Number&amp;gt;&lt;/p&gt;
&lt;p&gt;Certificate_Hash表示证书文件的hash值，Number是为了防止证书文件的hash值一致而增加的后缀（用0就行了）&lt;/p&gt;
&lt;p&gt;下载自己的根证书FiddlerRoot.cer，使用openssl x509 -subject_hash_old -in &amp;lt;Certificate_File&amp;gt; 计算证书hash ，根据hash将证书重命名为 269953fb.0 （269953fb是笔者证书的hash，大家的肯定不一样）&lt;/p&gt;
&lt;p&gt;然后将269953fb.0文件复制到/system/etc/security/cacerts/&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/209007/201908/209007-20190820045814808-1704213368.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;
&lt;p&gt;完成后我们就可以看到代理软件的证书出现在系统区了。&lt;/p&gt;

&lt;p&gt;这里还有一点需要单独说明，/system/etc/security/cacerts/目录的写权限，需要手机root权限。&lt;/p&gt;
&lt;p&gt;也就是说复制证书到该目录需要您root自己的设备。&lt;/p&gt;
&lt;p&gt;关于Android手机的root，通常手机厂家都会有自己官方的教程，建议大家按官方的操作进行root&lt;/p&gt;

&lt;p&gt;当前小米手机的root需要手机绑定小米账号7天以上才能解锁，解锁后刷入开发版即可完成root&lt;/p&gt;
&lt;div readability=&quot;8.4792626728111&quot;&gt;需要注意的是不是所有小米的手机都有对应的开发版的，所以购买测试设备时留意下。（&lt;a href=&quot;http://www.miui.com/download.html&quot;&gt;http://www.miui.com/download.html&lt;/a&gt; 这里可以看下自己的手机有没有开发版可以使用）&lt;/div&gt;

&lt;p&gt;效果&lt;/p&gt;
&lt;p&gt;现在证书也被安装到了系统区，再回到Fiddler看下效果&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/209007/201908/209007-20190820045827607-1871349753.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;
&lt;p&gt;再次打开闲鱼我们已经可以看到完整的https请求了。&lt;/p&gt;

&lt;p&gt;下面我们找个请求修改下请求返回数据&lt;/p&gt;
&lt;p&gt;借助Fiddler插件FreeHttp修改这个请求的返回数据将二手手机修改为二手马总并将图片也替换掉&lt;/p&gt;


&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/209007/201908/209007-20190820045839818-169061456.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;
&lt;p&gt;再次打开闲鱼，可以看到经过代理的数据已经被篡改了（注意测试时清除咸鱼的缓存及应用数据，以保证每次打开APP都会请求firstdata）&lt;/p&gt;
</description>
<pubDate>Mon, 19 Aug 2019 21:15:00 +0000</pubDate>
<dc:creator>lulianqi15</dc:creator>
<og:description>引言 HTTP应用层的抓包已经成为日常工作测试与调试中的重要一环，最近接触新项目突然之间发现之前的抓包手段都不好使了，顿时模块与模块之间的前端与服务之间的交互都变成了不可见，整个人都好像被蒙住了眼睛。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lulianqi/p/11380794.html</dc:identifier>
</item>
<item>
<title>关于在taro使用wx.parse那些事 - 丫丫小卉</title>
<link>http://www.cnblogs.com/yyxh/p/11380709.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yyxh/p/11380709.html</guid>
<description>&lt;p&gt;　　好久不见，好久没更新博客，最近工作也比较忙，今天在使用解决富文本的时候遇到两个bug，由于第一次使用wx.parse经验不足，走了很多弯路，今天特地把自己修复bug的感想分享一下，希望能帮助更多的小伙伴们，有错误的地方，请多多指教🙏。&lt;/p&gt;
&lt;p&gt;　　首先在taro实现富文本的方式有多种，之前也是尝试过使用richText标签，但是感觉很不好用，一个原因是，每次要把原有后台返回的数据格式都要组装成特定的格式，过程很麻烦，还好后端比较友好给转好，不然就费劲了。&lt;a href=&quot;https://taro-docs.jd.com/taro/docs/components/base/rich-text.html&quot; target=&quot;_blank&quot;&gt;关于richText的使用&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　最终使用了一次就放弃了，最后选择wx.parse,它是微信小程序专门用来解析富文本的，上手很快，只要把需要的包给引进来就行了，这里不详细介绍了，可以参考&lt;a href=&quot;https://github.com/icindy/wxParse&quot; target=&quot;_blank&quot;&gt;wx.parse&lt;/a&gt;,在使用过程中注意以下几点：&lt;/p&gt;
&lt;p&gt;1、在渲染之前一定要引用这两个文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
import WxParse &lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;../../../components/wxParse/wxParse&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
import &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;../../../components/wxParse/wxParse.wxss&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;今天就是因为没有引入css文件排查了半天，不引入的现象就是，加粗加颜色的文本会换行显示，图片也不会自适应。其中的主要的原因在于思路错了，一开始一直以为，可以用css强制把它变成一行，后来发现行不通，因为层级太深，节点关系也不统一，接着试了第二中方法就是改变wxParse的代码，将strong的标签给转成text标签，这个方法太蠢了，最后在github上发现和我一样问题的朋友，引入wxss解决了问题。&lt;/p&gt;
&lt;p&gt;2、在渲染组件之前&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
 WxParse.wxParse(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;article&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, res.data.msg, &lt;span&gt;this&lt;/span&gt;.$scope, &lt;span&gt;5&lt;/span&gt;);
&lt;/pre&gt;
&lt;div readability=&quot;17&quot;&gt;
&lt;p&gt;　　参数说明：&lt;/p&gt;
&lt;p&gt;　　bindName绑定的数据名(必填)&lt;/p&gt;
&lt;p&gt;　　type可以为html或者md(必填)&lt;/p&gt;
&lt;p&gt;　　data为传入的具体数据(必填)&lt;/p&gt;
&lt;p&gt;　　target为Page对象,一般为this(必填)&lt;/p&gt;
&lt;p&gt;　　imagePadding为当图片自适应是左右的单一padding(默认为0,可选)&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;3、在标签中引入&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;import src=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;../../../components/wxParse/wxParse.wxml&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; /&amp;gt;  //注一定要有
&amp;lt;template &lt;span&gt;is&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;wxParse&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; data=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;{{wxParseData:article.nodes}}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;/&amp;gt;  //注：article和上面保持一致
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ok，简单的一条数据就可以渲染成功了，问题来了，我们开发过程中经常会遇到像ugc列表一样的需求，不仅仅渲染的是一条数据，而是很多条json数据，怎么实现呢，我上网搜了一下，有很多解决方法，这里不多说了，主要是我试了没成功，感兴趣的可以试试，顺便教教我😊，参考文件&lt;a href=&quot;https://github.com/icindy/wxParse/wiki/wxParse%E5%A4%9A%E6%95%B0%E6%8D%AE%E5%BE%AA%E7%8E%AF%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95&quot; target=&quot;_blank&quot;&gt;wxParse多数据循环使用&lt;/a&gt;，最终用了一个偷懒的方法解决了，思路就是自己封装了一个组件，然后遍历的时候每次调用这个组件，可以说简单粗暴而且有效，封装组件的过程就是实现一条数据的过程，可以参考1，2，3步骤。&lt;/p&gt;
&lt;p&gt;这就是我今天遇到的两个关于taro富文本问题bug，最后总结：问题很简单，主要是一开始思路没想对，以后遇到问题先不要急于去写，先仔细分析下问题，方向很重要，晚安😴&lt;/p&gt;
</description>
<pubDate>Mon, 19 Aug 2019 16:52:00 +0000</pubDate>
<dc:creator>丫丫小卉</dc:creator>
<og:description>好久不见，好久没更新博客，最近工作也比较忙，今天在使用解决富文本的时候遇到两个bug，由于第一次使用wx.parse经验不足，走了很多弯路，今天特地把自己修复bug的感想分享一下，希望能帮助更多的小伙</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yyxh/p/11380709.html</dc:identifier>
</item>
</channel>
</rss>