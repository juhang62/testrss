<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>自动化测试之路3-selenium3+python3环境搭建 - 寻不到花的蝶</title>
<link>http://www.cnblogs.com/jenny-jenny/p/10080470.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jenny-jenny/p/10080470.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、首先安装火狐浏览器&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;有单独文章分享怎么安装&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、搭建python环境&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;安装python，安装的时候把path选好，就不用自己在配置，安装方法&lt;strong&gt;有单独文档分享&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;安装好以后cmd打开输入python查看是否配置好&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3、安装pip&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一般python会默认带一个，放置和python一个地址，这样就不需要重新配置环境变量&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;安装路径可以上网查询很多的教程https：//pypi.python.org/pypi/pip下载pip源码包&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101595/201812/1101595-20181206225807818-241350678.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;减压以后在cmd 窗口下用cd命令切换到  E:\新建文件夹 (2)\python\pip-18.1 目录下 。然后输入 python setup.py install  安装pip工具。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;安装完成以后会显示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Finished processing dependencies for pip==8.1.2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4、安装python集成开发环境pycharm&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;地址的话官网一搜索就有，下载一个exe文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101595/201812/1101595-20181206230426818-872902581.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下载到本地以后，双击exe文件安装，具体官网有很多教程，可以看怎么安装。安装好以后就可以创建project。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101595/201812/1101595-20181206230602286-1420127985.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;5、最后一步安装selenium3（webdriver）主要就是其在python中如何安装和使用&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 如果安装好python和pip 尝试在cmd中输入 pip install selenium&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果ok的话就可以省很多事&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果不ok&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;就跟着我的脚步&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、下载selenium安装包，地址https://pypi.python.org/pypi/selenium&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101595/201812/1101595-20181206231256608-69392933.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;点击download 然后进入下一界面&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101595/201812/1101595-20181206231354280-1081009759.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 点击扩展名为gz的源码包下载，下载后减压。然后cd切换到该文件的setup.py目录下，类似于安装pip安装包的方法一样，输入python setup.py install&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;安装ok界面显示&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Finished processing dependencies for selenium==3.0.2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;重新打开cmd 输入python回车，在python交互模式输入import selenium &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;显示&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101595/201812/1101595-20181206232944860-87754029.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;接下来就是使用 Firefox浏览器验证WebDriver是否可用&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;实在不想打字了，图片上传即可看清楚&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101595/201812/1101595-20181206233515407-940161644.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;接着图片里的话：；；驱动兼容32位FireFox浏览器）下载对应的Webdriver操作Firefox浏览器的驱动程序，&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101595/201812/1101595-20181206233730801-931421735.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; 下载后减压即可&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; 到此为止自动化测试整个环境搭建完毕&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;我们可以来测试一下。打开pycharm输入脚本，点击运行即可。也可以在命令框里测试，脚本复制在下面，可自行测试&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101595/201812/1101595-20181206233936589-1460319005.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;from selenium import webdriver&lt;/span&gt;&lt;br/&gt;&lt;span&gt;from time import sleep&lt;/span&gt;&lt;br/&gt;&lt;span&gt;b=webdriver.Firefox()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;b.get('http://xdclass.net')&lt;/span&gt;&lt;br/&gt;&lt;span&gt;print(b.title)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;sleep(10)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;v/div[3]/div/div[2]/a[1]/div/img').click()b.find_element_by_xpath('/html/body/div/di&lt;/span&gt;&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101595/201812/1101595-20181206234145209-42763494.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;pre&gt;
&lt;span&gt;这样就算是迈入自动化测试大门啦&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 06 Dec 2018 15:45:00 +0000</pubDate>
<dc:creator>寻不到花的蝶</dc:creator>
<og:description>1、首先安装火狐浏览器 有单独文章分享怎么安装 2、搭建python环境 安装python，安装的时候把path选好，就不用自己在配置，安装方法有单独文档分享 安装好以后cmd打开输入python查看</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jenny-jenny/p/10080470.html</dc:identifier>
</item>
<item>
<title>我该不该学习C语言 - 极客大全</title>
<link>http://www.cnblogs.com/AIThink/p/10080471.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/AIThink/p/10080471.html</guid>
<description>&lt;p&gt;这几天把c语言过了一遍，基本上算是入门了，常用语法、函数的使用。c语言是比较古老的语言了，很多系统的底层、工业控制软件都是使用C语言编写，过一遍之后觉得c语言屹立不倒是有原因。c程序员有一句话：使用c语言时间长了，感觉自己能控制整个世界。&lt;/p&gt;
&lt;p&gt;01 c语言和其他语言的区别和联系&lt;/p&gt;
&lt;p&gt;c比较古老，很多现代编程语言设计时基于c的语法。C是面向过程的语言，Java、c#、Python、c++等是面向对象的语言，封装的比较好，同样执行速度也不如c快。c没有复杂的封装，所以使用起来很多东西需要自己编写实现，入门容易精通难。c很多操作直接面向内存操作，还需要手动释放内存，控制性更强，但也需要更多的经验才能保证程序的稳定健壮，像现代语言都不需要考虑内存释放。&lt;/p&gt;
&lt;p&gt;02 c语言好学不？&lt;/p&gt;
&lt;p&gt;好学，如果你学过Java、c#语言就会发现语法都差不多，像c语言中的结构体就和c#的结构很像。有很多人认为指针比较难学，其实不然，能搞懂Java、c#中的值类型和引用类型就能搞懂c语言的指针。c中的函数都是比较基础的函数，不像面向对象语言那样庞大繁多。掌握了常用的函数后，其他的可以查函数手册，用法都差不多，soso easy。&lt;/p&gt;
&lt;p&gt;03 能干啥？&lt;/p&gt;
&lt;p&gt;编写嵌入式程序(电子电路控制)、桌面程序、游戏、写个服务、写个dll库给别人调、写个操作系统(谁写出来请务必联系我)、写个别的语言。&lt;/p&gt;
&lt;p&gt;04 那我该不该学？&lt;/p&gt;
&lt;p&gt;这个由你自己决定！我个人认为不该学，现在很多公司不提倡重复造轮子，要快速开发，明天上线，用c写程序实在不合时宜。我个人认为该学，下图便是对这个急功近利时代的嘲讽，只会复制粘贴的属于体力劳作，详情参考之前的这篇文章 程序员都知道，如何不被淘汰&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/784606/201812/784606-20181206234442680-1463087163.jpg&quot; alt=&quot;图片来自网络&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图片来自网络&lt;/p&gt;
&lt;p&gt;为啥有些公司乐意招 985、211 毕业的，培训出来的就不能创造价值了吗？并非鄙视培训出来的同学，但 985、211 的同学确实好使，他们受到过更加基础系统的训练，操作系统、网络协议、算法、数据结构这些思维性的才是核心竞争力，所以学习c造造轮子也并非无用功。&lt;/p&gt;
&lt;p&gt;大家思考一个问题，开源社区有很多优秀的开源项目，我们国人的开源项目能占到多少？&lt;/p&gt;
</description>
<pubDate>Thu, 06 Dec 2018 15:45:00 +0000</pubDate>
<dc:creator>极客大全</dc:creator>
<og:description>这几天把c语言过了一遍，基本上算是入门了，常用语法、函数的使用。c语言是比较古老的语言了，很多系统的底层、工业控制软件都是使用C语言编写，过一遍之后觉得c语言屹立不倒是有原因。c程序员有一句话：使用c</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/AIThink/p/10080471.html</dc:identifier>
</item>
<item>
<title>网络流之转换为对偶图 - SongHL</title>
<link>http://www.cnblogs.com/songorz/p/10080445.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/songorz/p/10080445.html</guid>
<description>&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; #include&amp;lt;bits/stdc++.h&amp;gt;
&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; N=&lt;span&gt;2000006&lt;/span&gt;,INF=&lt;span&gt;0x3fffffff&lt;/span&gt;,E=N*&lt;span&gt;3&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; ARC {
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; u, val, next;
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt;     inline &lt;span&gt;void&lt;/span&gt; init(&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt; b, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; c) {
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt;         u=a, val=b, next=&lt;span&gt;c;
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;} arc[E];
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; head[N], tot, S, T, n, m, dis[N];
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; vs[N];
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; 
&lt;span&gt; 13&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; data{
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; u, dis;
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt; &lt;span&gt;    data() {}
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt;     data(&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; b) : u(a), dis(b) {}
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt;     &lt;span&gt;bool&lt;/span&gt; &lt;span&gt;operator&lt;/span&gt; &amp;lt; (&lt;span&gt;const&lt;/span&gt; data &amp;amp;T) &lt;span&gt;const&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; dis&amp;gt;&lt;span&gt;T.dis;
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt; 
&lt;span&gt; 22&lt;/span&gt; inline &lt;span&gt;void&lt;/span&gt; add_arc(&lt;span&gt;int&lt;/span&gt; s, &lt;span&gt;int&lt;/span&gt; t, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; val) 
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt; &lt;span&gt;    arc[tot].init(t, val, head[s]);
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt;     head[s]=tot++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt; 
&lt;span&gt; 28&lt;/span&gt; priority_queue&amp;lt;data&amp;gt;&lt;span&gt; Q;
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Dijkstra() 
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt;     fill(dis, dis+T+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;, INF);
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt;     fill(vs, vs+T+&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(!&lt;span&gt;Q.empty()) Q.pop();
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;     dis[S]=&lt;span&gt;0&lt;/span&gt;, Q.push(data(S, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; u; !&lt;span&gt;Q.empty(); ) 
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt;         u=&lt;span&gt;Q.top().u, Q.pop();
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(vs[u]) &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(u==&lt;span&gt;T) 
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt;             printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, dis[T]);
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt;             &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt;         vs[u]=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; e=head[u]; e!=-&lt;span&gt;1&lt;/span&gt;; e=&lt;span&gt;arc[e].next) {
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; v=&lt;span&gt;arc[e].u;
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(vs[v] || dis[u]+arc[e].val&amp;gt;=dis[v]) &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt;             dis[v]=dis[u]+&lt;span&gt;arc[e].val;
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt; &lt;span&gt;            Q.push(data(v, dis[v]));
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt; 
&lt;span&gt; 54&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; read(&lt;span&gt;int&lt;/span&gt; &amp;amp;&lt;span&gt;x) {
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt;     &lt;span&gt;char&lt;/span&gt;&lt;span&gt; c;
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;((c=getchar())&amp;lt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; || c&amp;gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;     x=c-&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;((c=getchar())&amp;gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &amp;amp;&amp;amp; c&amp;lt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) x=(x&amp;lt;&amp;lt;&lt;span&gt;3&lt;/span&gt;)+(x&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;)+c-&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt; 
&lt;span&gt; 61&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Input() {
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;, id1, id2, a; i&amp;lt;=n-&lt;span&gt;1&lt;/span&gt;; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j=&lt;span&gt;1&lt;/span&gt;; j&amp;lt;=m-&lt;span&gt;1&lt;/span&gt;; j++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt; &lt;span&gt;            read(a);
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt;             id1=((i-&lt;span&gt;1&lt;/span&gt;)*(m-&lt;span&gt;1&lt;/span&gt;)+j)*&lt;span&gt;2&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt;             id2=(i*(m-&lt;span&gt;1&lt;/span&gt;)+j)*&lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(i==&lt;span&gt;0&lt;/span&gt;) id1=&lt;span&gt;T;
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(i==n-&lt;span&gt;1&lt;/span&gt;) id2=&lt;span&gt;S;
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt; &lt;span&gt;            add_arc(id1,id2,a);
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt; &lt;span&gt;            add_arc(id2,id1,a);
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt; 
&lt;span&gt; 73&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;, id1, id2, a; i&amp;lt;=n-&lt;span&gt;1&lt;/span&gt;; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j=&lt;span&gt;0&lt;/span&gt;; j&amp;lt;m; j++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt; &lt;span&gt;            read(a);
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;             id1=((i-&lt;span&gt;1&lt;/span&gt;)*(m-&lt;span&gt;1&lt;/span&gt;)+j)*&lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt;             id2=((i-&lt;span&gt;1&lt;/span&gt;)*(m-&lt;span&gt;1&lt;/span&gt;)+j+&lt;span&gt;1&lt;/span&gt;)*&lt;span&gt;2&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(j==&lt;span&gt;0&lt;/span&gt;) id1=&lt;span&gt;S;
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(j==m-&lt;span&gt;1&lt;/span&gt;) id2=&lt;span&gt;T;
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt; &lt;span&gt;            add_arc(id1, id2, a);
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt; &lt;span&gt;            add_arc(id2, id1, a);
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt; 
&lt;span&gt; 84&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;, id1, id2, a; i&amp;lt;=n-&lt;span&gt;1&lt;/span&gt;; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j=&lt;span&gt;1&lt;/span&gt;; j&amp;lt;=m-&lt;span&gt;1&lt;/span&gt;; j++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt; &lt;span&gt;            read(a);
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt;             id1=((i-&lt;span&gt;1&lt;/span&gt;)*(m-&lt;span&gt;1&lt;/span&gt;)+j)*&lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt;             id2=((i-&lt;span&gt;1&lt;/span&gt;)*(m-&lt;span&gt;1&lt;/span&gt;)+j)*&lt;span&gt;2&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt; &lt;span&gt;            add_arc(id1, id2, a);
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt; &lt;span&gt;            add_arc(id2, id1, a);
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt; 
&lt;span&gt; 94&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; main() {
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt; &lt;span&gt;    read(n), read(m);
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt;     S=&lt;span&gt;0&lt;/span&gt;, T=(n-&lt;span&gt;1&lt;/span&gt;)*(m-&lt;span&gt;1&lt;/span&gt;)*&lt;span&gt;2&lt;/span&gt;+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt;     fill(head, head+T+&lt;span&gt;1&lt;/span&gt;, -&lt;span&gt;1&lt;/span&gt;), tot=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(n==&lt;span&gt;1&lt;/span&gt; || m==&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) 
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(n&amp;gt;&lt;span&gt;m) swap(n, m);
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; ans=&lt;span&gt;INF;
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;, a; i&amp;lt;m; i++&lt;span&gt;) 
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt; &lt;span&gt;            read(a);
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(ans&amp;gt;a) ans=&lt;span&gt;a;
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ans==INF?&lt;span&gt;0&lt;/span&gt;&lt;span&gt;:ans);
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt; Input(), Dijkstra();
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt; }
&lt;/pre&gt;</description>
<pubDate>Thu, 06 Dec 2018 15:42:00 +0000</pubDate>
<dc:creator>SongHL</dc:creator>
<og:description>网络流之转换为对偶图 先来观察下面的这张图： 下面的这张却完全不行。 像这样任意两边的交点在顶点上的图我们称为平面图。 几条边围成一个区域，这个区域称为一个面。 对平面图，我们定义对偶图： 下图中黑色</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/songorz/p/10080445.html</dc:identifier>
</item>
<item>
<title>002---Python基本数据类型--字符串 - 爬呀爬Xjm</title>
<link>http://www.cnblogs.com/xjmlove/p/10074245.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xjmlove/p/10074245.html</guid>
<description>[unable to retrieve full-text content]字符串 字符串的定义与创建¶ 定义：字符串是一个有序的字符集合，用来存储和表示文本信息。用双引和单引表示。是一种不可变类型。¶ 创建：¶ In [9]: s = 'Hello Python' print(s) Hello Python 常用操作：¶ In [1]: # 索引和切片 s = 'Pyth</description>
<pubDate>Thu, 06 Dec 2018 15:27:00 +0000</pubDate>
<dc:creator>爬呀爬Xjm</dc:creator>
<og:description>字符串常用方法总结</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xjmlove/p/10074245.html</dc:identifier>
</item>
<item>
<title>补习系列(14)-springboot redis 整合-数据读写 - 美码师</title>
<link>http://www.cnblogs.com/littleatp/p/10080296.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/littleatp/p/10080296.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;h2 id=&quot;一简介&quot;&gt;一、简介&lt;/h2&gt;
&lt;p&gt;在 &lt;a href=&quot;http://www.cnblogs.com/littleatp/p/10080296.html&quot;&gt;补习系列(A3)-springboot redis 与发布订阅&lt;/a&gt; 一文中，我们介绍了使用 Redis 实现消息订阅发布的机制，并且给出了一个真实用例。&lt;br/&gt;然而，绝大多数场景下 Redis 是作为缓存被使用的(这是其主要优势)。除此之外，由于Redis 提供了 AOF以及RDB两种持久化机制，某些情况下也可以作为临时数据库使用。&lt;br/&gt;本次将介绍 SpringBoot 中如何使用 Redis 进行缓存读写。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201812/242916-20181206231101579-1459785266.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5.4193548387097&quot;&gt;
&lt;p&gt;Redis 的基本命令&lt;br/&gt;在学习之前，需要先了解一些Redis 的基本命令，可以&lt;a href=&quot;http://www.redis.cn/&quot;&gt;参考这里&lt;/a&gt;&lt;br/&gt;http://www.redis.cn/&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;二springboot-redis-读写&quot;&gt;二、SpringBoot Redis 读写&lt;/h2&gt;
&lt;h3 id=&quot;a.-引入-spring-data-redis&quot;&gt;A. 引入 spring-data-redis&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;添加依赖&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; &amp;lt;!-- redis --&amp;gt;
  &amp;lt;dependency&amp;gt;
   &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
   &amp;lt;artifactId&amp;gt;spring-boot-starter-data-redis&amp;lt;/artifactId&amp;gt;
   &amp;lt;version&amp;gt;${spring-boot.version}&amp;lt;/version&amp;gt;
  &amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;spring-boot-starter-redis在1.4版本已经废弃&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;配置redis连接&lt;/strong&gt;&lt;br/&gt;application.properties&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# redis 连接配置
spring.redis.database=0 
spring.redis.host=127.0.0.1
spring.redis.password=
spring.redis.port=6379
spring.redis.ssl=false

# 连接池最大数
spring.redis.pool.max-active=10 
# 空闲连接最大数
spring.redis.pool.max-idle=10
# 获取连接最大等待时间(s)
spring.redis.pool.max-wait=600000&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;b.-序列化&quot;&gt;B. 序列化&lt;/h3&gt;
&lt;p&gt;同样，我们需要指定 JSON作为 Key/HashKey/Value的主要方式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    /**
     * 序列化定制
     * 
     * @return
     */
    @Bean
    public Jackson2JsonRedisSerializer&amp;lt;Object&amp;gt; jackson2JsonSerializer() {
        Jackson2JsonRedisSerializer&amp;lt;Object&amp;gt; jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer&amp;lt;&amp;gt;(
                Object.class);

        // 初始化objectmapper
        ObjectMapper mapper = new ObjectMapper();
        mapper.setSerializationInclusion(Include.NON_NULL);
        mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
        jackson2JsonRedisSerializer.setObjectMapper(mapper);
        return jackson2JsonRedisSerializer;
    }

   /**
     * 操作模板
     * 
     * @param connectionFactory
     * @param jackson2JsonRedisSerializer
     * @return
     */
    @Bean
    public RedisTemplate&amp;lt;String, Object&amp;gt; redisTemplate(JedisConnectionFactory connectionFactory,
            Jackson2JsonRedisSerializer&amp;lt;Object&amp;gt; jackson2JsonRedisSerializer) {

        RedisTemplate&amp;lt;String, Object&amp;gt; template = new RedisTemplate&amp;lt;String, Object&amp;gt;();
        template.setConnectionFactory(connectionFactory);

        // 设置key/hashkey序列化
        RedisSerializer&amp;lt;String&amp;gt; stringSerializer = new StringRedisSerializer();
        template.setKeySerializer(stringSerializer);
        template.setHashKeySerializer(stringSerializer);

        // 设置值序列化
        template.setValueSerializer(jackson2JsonRedisSerializer);
        template.setHashValueSerializer(jackson2JsonRedisSerializer);
        template.afterPropertiesSet();

        // template.setValueSerializer(new
        // GenericToStringSerializer&amp;lt;Object&amp;gt;(Object.class));
        return template;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Jackson2JsonRedisSerializer&lt;/strong&gt;是Jackson转换的桥接器；&lt;br/&gt;&lt;strong&gt;RedisTemplate&lt;/strong&gt;是用于读写的主要操作类；&lt;/p&gt;
&lt;h3 id=&quot;c.-读写样例&quot;&gt;C. 读写样例&lt;/h3&gt;
&lt;p&gt;首先定义一个Pet实体类&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class RedisPet {

    private String name;
    private String type;
... ignore get set&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;利用&lt;strong&gt;RedisTemplate&lt;/strong&gt;封装一层Repository，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    @Repository
    public static class PetRepository {

        private static final String KEY = &quot;Pets&quot;;

        @Autowired
        private RedisTemplate&amp;lt;String, Object&amp;gt; redisTemplate;
        private HashOperations&amp;lt;String, String, Object&amp;gt; hashOperations;

        @PostConstruct
        private void init() {
            hashOperations = redisTemplate.opsForHash();
        }

        public void add(RedisPet pet) {
            hashOperations.put(KEY, pet.getName(), pet);
        }

        public RedisPet find(String name) {
            return (RedisPet) hashOperations.get(KEY, name);
        }

        public Map&amp;lt;String, Object&amp;gt; findAll() {
            return hashOperations.entries(KEY);
        }
        
        public void clear() {
            hashOperations.getOperations().delete(KEY);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在&lt;strong&gt;PetRepository&lt;/strong&gt; 的实现中，我们利用Hash结构来存储 Pet信息(Pet.name是key)&lt;br/&gt;分别实现了添加(add)/查找(get)/清除(clear)等方法。&lt;/p&gt;
&lt;p&gt;最后，实现读写调用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
@Service
public class RedisDataOperation {

    private static final Logger logger = LoggerFactory.getLogger(RedisDataOperation.class);

    @Autowired
    private PetRepository petRepo;


    @PostConstruct
    public void start() {

        RedisPet pet1 = new RedisPet(&quot;Polly&quot;, &quot;Bird&quot;);
        RedisPet pet2 = new RedisPet(&quot;Tom&quot;, &quot;Cat&quot;);

        //写入宠物信息
        petRepo.add(pet1);
        petRepo.add(pet2);

        //打印宠物信息
        logger.info(&quot;polly {}&quot;, JsonUtil.toJson(petRepo.find(&quot;Polly&quot;)));
        logger.info(&quot;pets  {}&quot;, JsonUtil.toJson(petRepo.findAll()));

        //清空
        petRepo.clear();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码在应用启动时，会写入两个Pet信息，之后完成清理，控制台输出如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;RedisDataOperation : polly {&quot;name&quot;:&quot;Polly&quot;,&quot;type&quot;:&quot;Bird&quot;}
RedisDataOperation : pets {&quot;Tom&quot;:{&quot;name&quot;:&quot;Tom&quot;,&quot;type&quot;:&quot;Cat&quot;},&quot;Polly&quot;:{&quot;name&quot;:&quot;Polly&quot;,&quot;type&quot;:&quot;Bird&quot;}}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;三方法级缓存&quot;&gt;三、方法级缓存&lt;/h2&gt;
&lt;p&gt;除了上面的RedisTemplate，&lt;strong&gt;spring-data-redis&lt;/strong&gt;还提供了&lt;strong&gt;方法级缓存&lt;/strong&gt;,&lt;br/&gt;就是将业务方法的执行结果缓存起来，后面再次调用直接从缓存中取得结果返回。&lt;/p&gt;
&lt;p&gt;这种方式可以简化缓存逻辑的代码，比如配置类数据的读取，通过方法注解就可以实现，&lt;br/&gt;下面是一个样例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 方法级缓存样例
 * 
 * @author atp
 *
 */
@Service
public class RedisCacheOperation {

    private static final Logger logger = LoggerFactory.getLogger(RedisCacheOperation.class);

    public static final String PREFIX = &quot;pets:&quot;;
    public static final String WRAP_PREFIX = &quot;'pets:'&quot;;

    /**
     * 当结果不为空时缓存
     * 
     * @param name
     * @return
     */
    @Cacheable(value = &quot;petCache&quot;, key = WRAP_PREFIX + &quot;+#name&quot;, unless = &quot;#result==null&quot;)
    public RedisPet getPet(String name) {
        logger.info(&quot;get pet {}&quot;, name);
        return new RedisPet(name, &quot;Bird&quot;);
    }

    /**
     * 当结果不为空时淘汰缓存
     * 
     * @param pet
     * @return
     */
    @CacheEvict(value = &quot;petCache&quot;, key = WRAP_PREFIX + &quot;+#pet.name&quot;, condition = &quot;#result!=null&quot;)
    public RedisPet updatePet(RedisPet pet) {
        logger.info(&quot;update pet {}&quot;, pet.getName());
        return new RedisPet(pet.getName(), &quot;Bird1&quot;);
    }

    /**
     * 当结果为true时淘汰缓存
     * 
     * @param name
     * @return
     */
    @CacheEvict(value = &quot;petCache&quot;, key = WRAP_PREFIX + &quot;+#name&quot;, condition = &quot;#result==true&quot;)
    public boolean deletePet(String name) {
        logger.info(&quot;delete pet {}&quot;, name);
        return true;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;涉及到几个注解：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;@Cachable&lt;/td&gt;
&lt;td&gt;方法执行结果缓存&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;@CachePut&lt;/td&gt;
&lt;td&gt;方法执行结果缓存(强制)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;@CacheEvict&lt;/td&gt;
&lt;td&gt;方法执行时触发删除&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;其中 &lt;strong&gt;@CachePut&lt;/strong&gt; 与 &lt;strong&gt;@Cachable&lt;/strong&gt; 的区别在于，前者一定会执行方法，并尝试刷新缓存(条件满足)，&lt;br/&gt;而后者则是当缓存中不存在时才会执行方法并更新。&lt;br/&gt;注解中的属性 key/condition 都支持通过 Spring EL 表达式来引用参数对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;启用注解&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;除了上面的代码，我们还需要使用 &lt;strong&gt;@EnableCaching&lt;/strong&gt; 启用注解：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@EnableCaching
@Configuration
public class RedisConfig {

    private static final Logger logger = LoggerFactory.getLogger(RedisConfig.class);

    /**
     * 缓存管理，支持方法级注解
     * 
     * @param template
     * @return
     */
    @Bean
    public RedisCacheManager cacheManager(RedisTemplate&amp;lt;String, Object&amp;gt; template) {
        RedisCacheManager redisCacheManager = new RedisCacheManager(template);
        // 默认过期时间
        redisCacheManager.setDefaultExpiration(30 * 60 * 1000);
        return redisCacheManager;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当@Cacheable 的key属性为空时，框架会自动生成，格式类似：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;param1,param2,param3...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果希望修改默认的行为，可以使用自定义的 &lt;strong&gt;KeyGenerator&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    /**
     * 定制方法缓存的key生成策略
     *
     * @return
     */
    @Bean
    public KeyGenerator keyGenerator() {
        return new KeyGenerator() {
            @Override
            public Object generate(Object target, Method method, Object... args) {
                StringBuilder sb = new StringBuilder();
                sb.append(target.getClass().getName());
                sb.append(method.getName());

                for (Object arg : args) {
                    sb.append(arg.toString());
                }
                return sb.toString();
            }
        };
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;单元测试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用一小段单元测试代码来测试&lt;strong&gt;方法级缓存&lt;/strong&gt;功能&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@RunWith(SpringRunner.class)
@SpringBootTest(classes =BootSampleRedis.class)
public class RedisCacheOperationTest {

    private static final Logger logger = LoggerFactory.getLogger(RedisCacheOperationTest.class);

    @Autowired
    private RedisTemplate&amp;lt;String, Object&amp;gt; redisTemplate;

    @Autowired
    private RedisCacheOperation operation;

    private RedisPet pet1 = new RedisPet(&quot;Polly&quot;, &quot;Bird&quot;);

    @Test
    public void testGet() {
        operation.getPet(pet1.getName());

        Object object = redisTemplate.opsForValue().get(RedisCacheOperation.PREFIX + pet1.getName());
        logger.info(String.valueOf(object));

        assertNotNull(object);
    }

    @Test
    public void testUpdate() {
        operation.updatePet(pet1);

        Object object = redisTemplate.opsForValue().get(RedisCacheOperation.PREFIX + pet1.getName());
        logger.info(String.valueOf(object));

        assertNull(object);
    }

    @Test
    public void testDelete() {
        operation.getPet(pet1.getName());

        // delete cache
        operation.deletePet(pet1.getName());

        Object object = redisTemplate.opsForValue().get(RedisCacheOperation.PREFIX + pet1.getName());
        logger.info(String.valueOf(object));

        assertNull(object);
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;四连接池&quot;&gt;四、连接池&lt;/h2&gt;
&lt;p&gt;如果希望通过代码来配置 Jedis 的连接池(熟悉的方式)，可以声明 &lt;strong&gt;JedisConnectionFactory&lt;/strong&gt; 实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    /**
     * 连接池配置
     *
     * @return
     */
    @Bean
    public JedisConnectionFactory jedisConnectionFactory() {
        JedisPoolConfig config = new JedisPoolConfig();

        // 最大连接
        config.setMaxTotal(10);
        // 最大空闲，与最大连接保持一致，可减少频繁键链的开销
        config.setMaxIdle(10);
        // 连接最大空闲时间
        config.setMinEvictableIdleTimeMillis(10 * 60 * 1000);
        // 获取连接等待的最大时长
        config.setMaxWaitMillis(30000);

        // 进行空闲连接检测的时间间隔
        config.setTimeBetweenEvictionRunsMillis(30 * 1000);
        // 取消不必要的test，有利于性能提升
        config.setTestOnBorrow(false);![](https://img2018.cnblogs.com/blog/242916/201812/242916-20181206231048870-1133770725.png)

        config.setTestOnReturn(false);

        JedisConnectionFactory factory = new JedisConnectionFactory(config);
        factory.setHostName(&quot;127.0.0.1&quot;);
        factory.setPort(6379);

        logger.info(&quot;redis config init first&quot;);
        return factory;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更多配置可&lt;a href=&quot;http://oopsguy.com/documents/springboot-docs/1.5.4/index.html#common-application-properties&quot;&gt;参考这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;示例代码可从 &lt;a href=&quot;https://gitee.com/littleatp/springboot-samples/tree/master/springboot-samples/springboot-redis&quot;&gt;码云gitee&lt;/a&gt; 下载。&lt;br/&gt;https://gitee.com/littleatp/springboot-samples/&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;Redis 在大多数项目中的核心用途是&lt;strong&gt;缓存&lt;/strong&gt;，spring-data-redis 为 SpringBoot 中集成 Redis 读写的封装。&lt;br/&gt;除了 RedisTemplate之外，还实现了方法级的缓存注解，一定程度上简化了业务的使用。&lt;br/&gt;Redis 在分布式系统中的应用场景有很多，后续有机会将进行更多的探讨。&lt;/p&gt;
&lt;p&gt;欢迎继续关注&quot;美码师的补习系列-springboot篇&quot; ，期待更多精彩内容^-^&lt;/p&gt;
</description>
<pubDate>Thu, 06 Dec 2018 15:12:00 +0000</pubDate>
<dc:creator>美码师</dc:creator>
<og:description>[TOC] 一、简介 在</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/littleatp/p/10080296.html</dc:identifier>
</item>
<item>
<title>从yield 到yield from再到python协程 - python修行路</title>
<link>http://www.cnblogs.com/zhaof/p/10072934.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhaof/p/10072934.html</guid>
<description>&lt;h2&gt;yield 关键字&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; fib():
    a, b &lt;/span&gt;= 0, 1
    &lt;span&gt;while&lt;/span&gt; 1&lt;span&gt;:
       &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt;&lt;span&gt; b
       a, b &lt;/span&gt;= b, a+b
&lt;/pre&gt;&lt;/div&gt;

&lt;p class=&quot;page-title&quot;&gt;yield 是在：PEP 255 -- Simple Generators 这个pep引入的&lt;/p&gt;
&lt;p class=&quot;page-title&quot;&gt;yield 只能在函数内部使用，包含yield语句的函数称为生成器函数&lt;/p&gt;
&lt;p class=&quot;page-title&quot;&gt;当调用生成器函数时，并不会执行函数体中的代码，而是返回一个生成器对象&lt;/p&gt;
&lt;p&gt;每次调用生成器对象的next()方法时，才会执行生成器函数中的代码，直到遇到&lt;span&gt;yield 或者return&lt;/span&gt; 语句。&lt;/p&gt;
&lt;p&gt;如果遇到yield 语句， 怎会&lt;span&gt;挂起&lt;/span&gt;函数的运行状态，并将yield 右边的表达式的值返回给next()的调用者， 挂起的时候会保存所有本地状态，包括局部变量，指令指针和内部堆栈信息，这样当下次再次调用next()时, 看起来yield 部分就像是调用了一个外部调用一样，可以接着往下执行&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意：try/ finnally 结构中的try子句中不允许使用yield语句， 问题是因为无法保证生成器被恢复，因此无法保证finally块将被执行&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;yield from 关键字&lt;/h2&gt;
&lt;p&gt;yield from关键字是在：PEP 380 -- Syntax for Delegating to a Subgenerator 中提出的&lt;/p&gt;
&lt;p&gt;用于生成器将其部分操作委托给另外一个生成器，这允许将包含yield的一段代码分解出来并放在另外一个生成器中，此外，允许子生成器返回一个值，这个值可供委派生成器使用&lt;/p&gt;

&lt;p&gt;上述描述听起来可能还是不是特别清楚，我们先看一下语法：&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre class=&quot;literal-block&quot;&gt;
yield from &amp;lt;expr&amp;gt;
&lt;/pre&gt;&lt;/blockquote&gt;

&lt;p&gt;yield from expr 表达式中，做的第一件事就是调用iter(expr) 从中获取迭代器，因此expr可以是任何可迭代的对象&lt;/p&gt;
&lt;p&gt;通过下面的下例子把yield 和yield from 做对比&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; collections &lt;span&gt;import&lt;/span&gt;&lt;span&gt; namedtuple


Result &lt;/span&gt;= namedtuple(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Result&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;count average&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

li &lt;/span&gt;= [40.9, 38.5, 44.3, 42.2, 45.2, 41.7, 44.5, 38.0, 40.6, 44.5&lt;span&gt;]

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 子生成器&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; averager():
    total &lt;/span&gt;= 0.0&lt;span&gt;
    count &lt;/span&gt;=&lt;span&gt; 0
    average &lt;/span&gt;=&lt;span&gt; None
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
        term &lt;/span&gt;= &lt;span&gt;yield&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; term &lt;span&gt;is&lt;/span&gt;&lt;span&gt; None:
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;
        total &lt;/span&gt;+=&lt;span&gt; term
        count &lt;/span&gt;+= 1&lt;span&gt;
        average &lt;/span&gt;= total/&lt;span&gt;count
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Result(count, average)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 委派生成器&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; grouper(result, key):
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
        result[key] &lt;/span&gt;= &lt;span&gt;yield&lt;/span&gt; &lt;span&gt;from&lt;/span&gt;&lt;span&gt; averager()

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 调用方&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; main():
    results &lt;/span&gt;=&lt;span&gt; {}
    group &lt;/span&gt;= grouper(results, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;kg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    next(group)
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; value &lt;span&gt;in&lt;/span&gt;&lt;span&gt; li:
        group.send(value)
    group.send(None)


&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
    main()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;yield from的主要功能是打开双向通道，把最外层的调用方与最内层的子生成器连接起来，这样二者可以直接发送和产出值，还可以直接传入异常&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;yield from 的六个重要意义&lt;/h3&gt;
&lt;p&gt;关于yield from 六点重要的说明：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;子生成器产出的值都直接传给委派生成器的调用方(即客户端代码)&lt;/li&gt;
&lt;li&gt;使用send()方法发送给委派生成器的值都直接传给子生成器。如果发送的值为None,那么会给委派调用子生成器的__next__()方法。如果发送的值不是None,那么会调用子生成器的send方法，如果调用的方法抛出StopIteration异常，那么委派生成器恢复运行，任何其他异常都会向上冒泡，传给委派生成器&lt;/li&gt;
&lt;li&gt;生成器退出时，生成器(或子生成器)中的return expr表达式会出发StopIteration(expr)异常抛出&lt;/li&gt;
&lt;li&gt;yield from表达式的值是子生成器终止时传给StopIteration异常的第一个参数。yield from 结构的另外两个特性与异常和终止有关。&lt;/li&gt;
&lt;li&gt;传入委派生成器的异常，除了GeneratorExit之外都传给子生成器的throw()方法。如果调用throw()方法时抛出StopIteration异常，委派生成器恢复运行。StopIteration之外的异常会向上冒泡，传给委派生成器&lt;/li&gt;
&lt;li&gt;如果把GeneratorExit异常传入委派生成器，或者在委派生成器上调用close()方法，那么在子生成器上调用clsoe()方法，如果它有的话。如果调用close()方法导致异常抛出，那么异常会向上冒泡，传给委派生成器，否则委派生成器抛出GeneratorExit异常&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;python协程&lt;/h2&gt;
&lt;p&gt;Python的生成器函数和python的协程非常接近 ,但并不完全 - 因为生成器然允许暂停执行以生成值，但是不提供在执行恢复时传递的值或异常。&lt;/p&gt;
&lt;p&gt;并且生成器不允许在try / finally块的try部分中暂停执行，因此使中止的协程很难在其自身之后进行清理。&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;将yield重新定义为表达式，而不是语句。当前的yield语句将成为一个yield值表达式，其值将被丢弃。每当通过正常的next（）调用恢复生成器时，yield表达式的值为None&lt;/li&gt;
&lt;li&gt;为generator-iterators 添加了一个新的方法send(), 它可以恢复生成器并发送给生成一个值，该值称为yield - expression的结果，send（）方法返回生成器产生的下一个值，如果生成器退出而不产生另一个值，则引发StopIteration。&lt;/li&gt;
&lt;li&gt;为generator-iterators 添加了一个新的方法throw(), 它在生成器暂停时引发异常，并返回生成器产生的下一个值，如果生成器退出而不产生另一个值，则引发StopIteration（如果生成器没有捕获传入的异常，或者引发另外的一个异常，那么该异常会传播给调用者）&lt;/li&gt;
&lt;li&gt;为generator-iterators 添加了一个新的方法close(), 在生成器暂停的位置引发一个&lt;tt class=&quot;docutils literal&quot;&gt;GeneratorExit&lt;/tt&gt; 异常，如果一个生成器引发了&lt;tt class=&quot;docutils literal&quot;&gt;StopIteration&lt;/tt&gt; 异常或者&lt;tt class=&quot;docutils literal&quot;&gt;GeneratorExit&lt;/tt&gt; 异常， close()方法将返回给它的调用者，如果生成是yield 一个值，会引发&lt;tt class=&quot;docutils literal&quot;&gt;RuntimeError&lt;/tt&gt; 异常。如果一个生成器引发了任何其他异常，则会传给他的调用者 ，如果生成器，由于异常退出或者已经正常退出，那么close()不执行任何操作。&lt;/li&gt;
&lt;li&gt;确保了当生成器被垃圾回收的时候执行close()&lt;/li&gt;
&lt;li&gt;因为垃圾回收或者clsoe被调用将允许允许yield在try / finally块中使用。&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;send方法&lt;/h3&gt;
&lt;p&gt;send方法只有一个参数，就是发送值到生成器，调用send(None)相当于调用生成器的next()方法&lt;/p&gt;
&lt;p&gt;因为我们开始执行生成器函数的时候，并没有实际执行生成器函数中的代码而是返回一个生成器对象，所以我们需要调用next()或者send(None)来激活协程&lt;/p&gt;
&lt;p&gt;与next（）方法一样，send（）方法返回generator-iterator产生的下一个值，如果生成器正常退出或已经退出，则引发StopIteration。如果生成器引发未捕获的异常，它将传播到send（）的调用者&lt;/p&gt;

&lt;h3&gt;throw方法&lt;/h3&gt;
&lt;p&gt;让生成器在被挂起的位置抛出指定的异常，如果生成器捕获了异常并且返回的另外一个值，那么这个值就是g.throw()返回的值&lt;/p&gt;
&lt;p&gt;如果生成器没有捕获异常，那么throw()将会引发传递相同的异常，如果生成器引发了另外一个异常，throw调用将引发异常，总之throw()的行为类似next()或者send()&lt;/p&gt;
&lt;p&gt;除了它在挂起的时候引发异常。如果生成器已经处于关闭状态，throw() 只会引发它传递的异常，而不执行任何生成器的代码&lt;/p&gt;

&lt;p&gt;generator.throw:会让生成器在暂停的yield表达式处抛出指定的异常，如果生成器处理了抛出的异常，代码会向前执行到下一个yield表达式，而产出的值会成为调用generator.throw方法代码的返回值。如果生成器没有处理抛出的异常，异常会向上冒泡，传到调用方的上下文中。&lt;br/&gt;generator.close:会让生成器在暂停的yield表达式处抛出GeneratorExit异常。如果生成器没有处理这个异常，或者抛出了StopIteration异常，调用方不会报错，如果收到GeneratorExit异常，生成器一定不能产出值，否则解释器会抛出RuntimeError异常。生成器抛出的异常会向上冒泡，传给调用方。&lt;/p&gt;

&lt;p&gt;早期的python协程，语法上协程和生成器看起来也非常类似，也是通过yield关键字如：num = yield&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; simple_coroutine():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;coroutine start&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    x &lt;/span&gt;= &lt;span&gt;yield&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;coroutine receive [%s]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt;x)


coroutine &lt;/span&gt;=&lt;span&gt; simple_coroutine()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(coroutine)
next(coroutine)
coroutine.send(&lt;/span&gt;888)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上面的例子中yield 的右边没有表达式，所以默认产出的值为None,通过之前将yield 关键字的时候我们已经知道当我们执行函数的时候&lt;/p&gt;
&lt;p&gt;并不会运行生成器函数中的代码，而是返回一个生成器对象，所以我们需要通过调用next(...)来激活协程，这个时候开始运行生成器函数，&lt;/p&gt;
&lt;p&gt;当运行到x = yield的时候，yield的右边如果有表达式，则会先进行右边表达式的计算，然后再进行赋值，所以当上面函数执行next()之后，&lt;/p&gt;
&lt;p&gt;程序会停在yield那里，当我们调用send方法后yield会收到这个值并赋值给x,而当程序运行到协程定义体的末尾时和用生成器的时候一样会抛出StopIteration异常&lt;/p&gt;
&lt;p&gt;如果协程没有通过next(...)激活(同样我们可以通过send(None)的方式激活)，但是我们直接send，则会出错&lt;/p&gt;

&lt;p&gt;关于调用next(...)函数这一步通常称为”预激(prime)“协程，即让协程向前执行到第一个yield表达式，准备好作为活跃的协程使用&lt;/p&gt;
&lt;p&gt;协程在运行过程中有四个状态：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;GEN_CREATE:等待开始执行&lt;/li&gt;
&lt;li&gt;GEN_RUNNING:解释器正在执行，这个状态一般看不到&lt;/li&gt;
&lt;li&gt;GEN_SUSPENDED:在yield表达式处暂停&lt;/li&gt;
&lt;li&gt;GEN_CLOSED:执行结束&lt;/li&gt;
&lt;/ol&gt;
</description>
<pubDate>Thu, 06 Dec 2018 14:47:00 +0000</pubDate>
<dc:creator>python修行路</dc:creator>
<og:description>yield 关键字 yield 是在：PEP 255 -- Simple Generators 这个pep引入的 yield 只能在函数内部使用，包含yield语句的函数称为生成器函数 当调用生成器函</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhaof/p/10072934.html</dc:identifier>
</item>
<item>
<title>白话架构设计为你阐述什么是架构设计，架构设计的三大原则是什么 - 依乐祝</title>
<link>http://www.cnblogs.com/yilezhu/p/10080136.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yilezhu/p/10080136.html</guid>
<description>&lt;p&gt;前面两篇文章给大家介绍了我们实战的CMS系统的数据库设计，源码也已经上传到服务器上了。今天我们就好聊聊架构设计，在开始之前先给大家分享一下这几天我一直在听的《从零开始学架构》里面关于架构设计的定义以及架构设计的三大原则，希望能对大家有所启发。有着这些基础之后，我们再基于此搭建我们的项目框架吧！如果你在阅读的过程中有任何的问题，欢迎大家在留言区进行留言，或者加入.NET Core实战项目群637326624跟大伙一起交流经验。&lt;/p&gt;
&lt;blockquote readability=&quot;2.36&quot;&gt;
&lt;p&gt;本文已收录至《&lt;a href=&quot;https://www.cnblogs.com/yilezhu/p/9977862.html&quot;&gt;.NET Core实战项目之CMS 第一章 入门篇-开篇及总体规划&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;作者：依乐祝&lt;/p&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;https://www.cnblogs.com/yilezhu/p/10080136.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/yilezhu/p/10080136.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;程序员的成长绕不开架构设计，有时架构设计就像鸿沟一样挡在程序的晋升之路上，只要跨过去就可以海阔天空，但不少技术能力很强的程序员却依然不能完全掌握架构设计，包括我自己在内，在实践过程中经常把握不住重点、分不清主次；或者说没有彻底掌握架构设计的原则，在设计上举棋不定。本文是我在观看了李运华老师从零开始学架构后的一些看法，文章最后会给出如何查看原作的方法。文章大部分内容也都是摘录自李运华的文章，当然，中间穿插了很多自己的认识在里面。目的就是给大家分享一下架构方面的知识，希望本篇的内容分享能对你有所启发！&lt;/p&gt;
&lt;h2 id=&quot;架构的定义&quot;&gt;架构的定义&lt;/h2&gt;
&lt;p&gt;对于技术人员来说，“架构”是一个再常见不过的词了。我们会对新员工培训整个系统的架构，参加架构设计评审，学习业界开源系统（例如，MySQL、Hadoop）的架构，研究大公司的架构实现（例如，微信架构、淘宝架构）……虽然“架构”这个词常见，但如果深究一下“架构”到底指什么呢？相信大部分人也许并不一定能够准确地回答。例如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;架构和框架是什么关系？有什么区别？&lt;/li&gt;
&lt;li&gt;Windows有架构，SQL Server 有架构，.NET Core也有架构，使用 .NET Core开发、SQL Server 存储、跑在 Windows 上的业务系统也有架构，那么我们应该关注哪个架构呢？&lt;/li&gt;
&lt;li&gt;微信有架构，微信的登录系统也有架构，微信的支付系统也有架构，当我们谈微信架构时，到底是在谈什么架构？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;要想准确地回答这几个问题，关键在于梳理几个有关系而又相似的概念，包括：系统与子系统、模块与组件、框架与架构。&lt;/p&gt;
&lt;h3 id=&quot;系统与子系统&quot;&gt;系统与子系统&lt;/h3&gt;
&lt;p&gt;我们先来看维基百科定义的“系统”。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;系统泛指由一群有关联的个体组成，根据某种规则运作，能完成个别元件不能单独完成的工作的群体。它的意思是“总体”“整体”或“联盟”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;关键内容提炼：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;关联&lt;/strong&gt;：系统是由一群有关联的个体组成的，没有关联的个体堆在一起不能成为一个系统。例如，把一个发动机和一台 PC 放在一起不能称之为一个系统，把发动机、底盘、轮胎、车架组合起来才能成为一台汽车。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;规则&lt;/strong&gt;：系统内的个体需要按照指定的规则运作，而不是单个个体各自为政。规则规定了系统内个体分工和协作的方式。例如，汽车发动机负责产生动力，然后通过变速器和传动轴，将动力输出到车轮上，从而驱动汽车前进。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;能力&lt;/strong&gt;：系统能力与个体能力有本质的差别，系统能力不是个体能力之和，而是产生了新的能力。例如，汽车能够载重前进，而发动机、变速器、传动轴、车轮本身都不具备这样的能力。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;维基百科定义的“子系统”&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;子系统也是由一群有关联的个体所组成的系统，多半会是更大系统中的一部分。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其实&lt;strong&gt;子系统的定义和系统定义是一样的，只是观察的角度有差异&lt;/strong&gt;，一个系统可能是另外一个更大系统的子系统。&lt;/p&gt;
&lt;p&gt;按照这个定义，系统和子系统比较容易理解。我们以微信为例来做一个分析。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;微信本身是一个系统，包含聊天、登录、支付、朋友圈等子系统。&lt;/li&gt;
&lt;li&gt;朋友圈这个系统又包括动态、评论、点赞等子系统。&lt;/li&gt;
&lt;li&gt;评论这个系统可能又包括防刷子系统、审核子系统、发布子系统、存储子系统。&lt;/li&gt;
&lt;li&gt;评论审核子系统不再包含业务意义上的子系统，而是包括各个模块或者组件，这些模块或者组件本身也是另外一个维度上的系统。例如，MySQL、Redis 等是存储系统，但不是业务子系统。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;模块与组件&quot;&gt;模块与组件&lt;/h3&gt;
&lt;p&gt;模块和组件两个概念在实际工作中很容易混淆，我们经常能够听到类似这样的说法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;MySQL &lt;strong&gt;模块&lt;/strong&gt;主要负责存储数据，而 ElasticSearch&lt;strong&gt;模块&lt;/strong&gt;主要负责数据搜索。&lt;/li&gt;
&lt;li&gt;我们有安全加密&lt;strong&gt;组件&lt;/strong&gt;、有审核&lt;strong&gt;组件&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;App 的下载&lt;strong&gt;模块&lt;/strong&gt;使用了第三方的&lt;strong&gt;组件&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;造成这种现象的主要原因是，模块与组件的定义并不好理解，也不能很好地进行区分。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;两者在维基百科上的定义:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;软件模块（Module）是一套一致而互相有紧密关连的软件组织。它分别包含了程序和数据结构两部分。现代软件开发往往利用模块作为合成的单位。模块的接口表达了由该模块提供的功能和调用它时所需的元素。模块是可能分开被编写的单位。这使它们可再用和允许人员同时协作、编写及研究不同的模块。&lt;br/&gt;软件组件定义为自包含的、可编程的、可重用的、与语言无关的软件单元，软件组件可以很容易被用于组装应用程序中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;从逻辑的角度来拆分系统后，得到的单元就是“模块”；从物理的角度来拆分系统后，得到的单元就是“组件”。&lt;/strong&gt;划分模块的主要目的是&lt;strong&gt;职责分离&lt;/strong&gt;；划分组件的主要目的是&lt;strong&gt;单元复用&lt;/strong&gt;。其实，“组件”的英文 component 也可翻译成中文的“零件”一词，“零件”更容易理解一些，“零件”是一个物理的概念，并且具备“独立且可替换”的特点。&lt;/p&gt;
&lt;h3 id=&quot;框架与架构&quot;&gt;框架与架构&lt;/h3&gt;
&lt;p&gt;框架是和架构比较相似的概念，且两者有较强的关联关系，所以在实际工作中，这两个概念有时我们容易分不清楚。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;框架与架构的区别：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;软件框架（Software Framework）通常指的是为了实现某个业界标准或完成特定基本任务的软件组件规范，也指为了实现某个软件组件规范时，提供规范所要求之基础功能的软件产品。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;关键部分提炼：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;框架是组件规范：例如，MVC 就是一种最常见的开发规范&lt;/li&gt;
&lt;li&gt;框架提供基础功能的产品：例如，WebApi 是 MVC 的开发框架，除了满足 MVC 的规范，.NET Core WebApi 提供了很多基础功能来帮助我们实现功能，包括Http请求，过滤器（[HttpGet]）等很多基础功能。&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;软件架构指软件系统的“基础结构”，创造这些基础结构的准则，以及对这些结构的描述。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;单纯从定义的角度来看，框架和架构的区别还是比较明显的，&lt;strong&gt;框架关注的是“规范”，架构关注的是“结构”&lt;/strong&gt;。框架的英文是 Framework[ˈfreɪmwɜ:rk]，架构的英文是 Architecture[ˈɑ:rkɪtektʃə(r)]。EF 的英文文档标题就是“Entity framework”。&lt;/p&gt;
&lt;h3 id=&quot;重新定义架构&quot;&gt;重新定义架构&lt;/h3&gt;
&lt;p&gt;参考维基百科的定义，架构重新定义为：&lt;strong&gt;软件架构指软件系统的顶层结构。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先，“系统是一群关联个体组成”，这些“个体”可以是“子系统”“模块”“组件”等；架构需要明确系统包含哪些“个体”。&lt;/p&gt;
&lt;p&gt;其次，系统中的个体需要“根据某种规则”运作，架构需要明确个体运作和协作的规则。&lt;/p&gt;
&lt;p&gt;第三，维基百科定义的架构用到了“基础结构”这个说法，我改为“顶层结构”，可以更好地区分系统和子系统，避免将系统架构和子系统架构混淆在一起导致架构层次混乱。&lt;/p&gt;
&lt;h3 id=&quot;总结提炼上述概念&quot;&gt;总结提炼上述概念&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;架构是顶层设计；&lt;/li&gt;
&lt;li&gt;框架是面向编程或配置的半成品；&lt;/li&gt;
&lt;li&gt;组件是从技术维度上的复用；&lt;/li&gt;
&lt;li&gt;模块是从业务维度上职责的划分；&lt;/li&gt;
&lt;li&gt;系统是相互协同可运行的实体。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;架构设计三原则&quot;&gt;架构设计三原则&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;合适原则、简单原则、演化原则&lt;/strong&gt;，架构设计时遵循这几个原则，有助于做出最好的选择。&lt;/p&gt;
&lt;h3 id=&quot;合适原则&quot;&gt;合适原则&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;合适原则宣言：“合适优于业界领先”。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;优秀的技术人员都有很强的技术情结，当他们做方案或者架构时，总想不断地挑战自己，想达到甚至优于业界领先水平是其中一个典型表现，因为这样才能够展现自己的优秀，才能在年终 KPI 绩效总结里面骄傲地写上“设计了 XX 方案，达到了和 Google 相同的技术水平”“XX 方案的性能测试结果大大优于阿里集团的 YY 方案”。&lt;br/&gt;但现实是，大部分这样想和这样做的架构，最后可能都以失败告终！&lt;br/&gt;为什么会这样呢？&lt;/p&gt;
&lt;p&gt;再好的梦想，也需要脚踏实地实现！这里的“脚踏实地”主要体现在下面几个方面。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;将军难打无兵之仗&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;大公司的分工比较细，一个小系统可能就是一个小组负责，比如说某个通信大厂，做一个 OM 管理系统就有十几个人，阿里的中间件团队有几十个人，而大部分公司，整个研发团队可能就 100 多人，某个业务团队可能就十几个人。十几个人的团队，想做几十个人的团队的事情，而且还要做得更好，不能说绝对不可能，但难度是可想而知的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;没那么多人，却想干那么多活，是失败的第一个主要原因。&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;罗马不是一天建成的&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;业界领先的很多方案，其实并不是一堆天才某个时期灵机一动，然后加班加点就做出来的，而是经过几年时间的发展才逐步完善和初具规模的。阿里中间件团队 2008 年成立，发展到现在已经有十年了。我们只知道他们抗住了多少次“双 11”，做了多少优秀的系统，但经历了什么样的挑战、踩了什么样的坑，只有他们自己知道！这些挑战和踩坑，都是架构设计非常关键的促进因素，单纯靠拍脑袋或者头脑风暴，是不可能和真正实战相比的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;没有那么多积累，却想一步登天，是失败的第二个主要原因。&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;冰山下面才是关键&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;可能有人认为，业界领先的方案都是天才创造出来的，所以自己也要造一个业界领先的方案，以此来证明自己也是天才。确实有这样的天才，但更多的时候，业界领先的方案其实都是“逼”出来的！简单来说，“业务”发展到一定阶段，量变导致了质变，出现了新的问题，已有的方式已经不能应对这些问题，需要用一种新的方案来解决，通过创新和尝试，才有了业界领先的方案。GFS 为何在 Google 诞生，而不是在 Microsoft 诞生？我认为 Google 有那么庞大的数据是一个主要的因素，而不是因为 Google 的工程师比 Microsoft 的工程师更加聪明。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;没有那么卓越的业务场景，却幻想灵光一闪成为天才，是失败的第三个主要原因。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所以，真正优秀的架构都是在企业当前人力、条件、业务等各种约束下设计出来的，能够合理地将资源整合在一起并发挥出最大功效，并且能够快速落地。这也是很多 BAT 出来的架构师到了小公司或者创业团队反而做不出成绩的原因，因为没有了大公司的平台、资源、积累，只是生搬硬套大公司的做法，失败的概率非常高。&lt;/p&gt;
&lt;h3 id=&quot;简单原则&quot;&gt;简单原则&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;简单原则宣言：“简单优于复杂”。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;软件架构设计是一门技术活。所谓技术活，从历史上看，无论是瑞士的钟表，还是瓦特的蒸汽机；无论是莱特兄弟发明的飞机，还是摩托罗拉发明的手机，无一不是越来越精细、越来越复杂。因此当我们进行架构设计时，会自然而然地想把架构做精美、做复杂，这样才能体现我们的技术实力，也才能够将架构做成一件艺术品。&lt;/p&gt;
&lt;p&gt;由于软件架构和建筑架构表面上的相似性，我们也会潜意识地将对建筑的审美观点移植到软件架构上面。我们惊叹于长城的宏伟、泰姬陵的精美、悉尼歌剧院的艺术感、迪拜帆船酒店的豪华感，因此，对于我们自己亲手打造的软件架构，我们也希望它宏伟、精美、艺术、豪华……总之就是不能寒酸、不能简单。&lt;/p&gt;
&lt;p&gt;团队的压力有时也会有意无意地促进我们走向复杂的方向，因为大部分人在评价一个方案水平高低的时候，复杂性是其中一个重要的参考指标。例如设计一个主备方案，如果你用心跳来实现，可能大家都认为这太简单了。但如果你引入 ZooKeeper 来做主备决策，可能很多人会认为这个方案更加“高大上”一些，毕竟 ZooKeeper 使用的是 ZAB 协议，而 ZAB 协议本身就很复杂。其实，真正理解 ZAB 协议的人很少（我也不懂），但并不妨碍我们都知道 ZAB 协议很优秀。&lt;/p&gt;
&lt;p&gt;刚才我聊的这些原因，会在潜意识层面促使初出茅庐的架构师，不自觉地追求架构的复杂性。然而，“复杂”在制造领域代表先进，在建筑领域代表领先，但在软件领域，却恰恰相反，代表的是“问题”。&lt;/p&gt;
&lt;p&gt;软件领域的复杂性体现在两个方面：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;结构的复杂性&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;结构复杂的系统几乎毫无例外具备两个特点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;组成复杂系统的组件数量更多；&lt;/li&gt;
&lt;li&gt;同时这些组件之间的关系也更加复杂。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;结构上的复杂性存在的第一个问题是，&lt;strong&gt;组件越多，就越有可能其中某个组件出现故障&lt;/strong&gt;，从而导致系统故障。这个概率可以算出来，假设组件的故障率是 10%（有 10% 的时间不可用），那么有 3 个组件的系统可用性是（1-10%）×（1-10%）×（1-10%）= 72.9%，有 5 个组件的系统可用性是（1-10%）×（1-10%）×（1-10%）×（1-10%）×（1-10%）=59%，两者的可用性相差 13%。&lt;/p&gt;
&lt;p&gt;结构上的复杂性存在的第二个问题是，&lt;strong&gt;某个组件改动，会影响关联的所有组件&lt;/strong&gt;，这些被影响的组件同样会继续递归影响更多的组件。这个问题会影响整个系统的开发效率，因为一旦变更涉及外部系统，需要协调各方统一进行方案评估、资源协调、上线配合。&lt;/p&gt;
&lt;p&gt;结构上的复杂性存在的第三个问题是，&lt;strong&gt;定位一个复杂系统中的问题总是比简单系统更加困难&lt;/strong&gt;。首先是组件多，每个组件都有嫌疑，因此要逐一排查；其次组件间的关系复杂，有可能表现故障的组件并不是真正问题的根源。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;逻辑的复杂性&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;意识到结构的复杂性后，我们的第一反应可能就是“降低组件数量”，毕竟组件数量越少，系统结构越简。最简单的结构当然就是整个系统只有一个组件，即系统本身，所有的功能和逻辑都在这一个组件中实现。&lt;/p&gt;
&lt;p&gt;不幸的是，这样做是行不通的，原因在于除了结构的复杂性，还有逻辑的复杂性，即如果某个组件的逻辑太复杂，一样会带来各种问题。&lt;/p&gt;
&lt;p&gt;逻辑复杂的组件，一个典型特征就是单个组件承担了太多的功能。以电商业务为例，常见的功能有：商品管理、商品搜索、商品展示、订单管理、用户管理、支付、发货、客服……把这些功能全部在一个组件中实现，就是典型的逻辑复杂性。&lt;/p&gt;
&lt;p&gt;逻辑复杂几乎会导致软件工程的每个环节都有问题，假设现在淘宝将这些功能全部在单一的组件中实现，可以想象一下这个恐怖的场景：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;系统会很庞大，可能是上百万、上千万的代码规模，“clone”一次代码要 30 分钟。&lt;/li&gt;
&lt;li&gt;几十、上百人维护这一套代码，某个“菜鸟”不小心改了一行代码，导致整站崩溃。&lt;/li&gt;
&lt;li&gt;需求像雪片般飞来，为了应对，开几十个代码分支，然后各种分支合并、各种分支覆盖。&lt;/li&gt;
&lt;li&gt;产品、研发、测试、项目管理不停地开会讨论版本计划，协调资源，解决冲突。&lt;/li&gt;
&lt;li&gt;版本太多，每天都要上线几十个版本，系统每隔 1 个小时重启一次。&lt;/li&gt;
&lt;li&gt;线上运行出现故障，几十个人扑上去定位和处理，一间小黑屋都装不下所有人，整个办公区闹翻天。&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;不用多说，肯定谁都无法忍受这样的场景。&lt;/p&gt;
&lt;p&gt;但是，为什么复杂的电路就意味更强大的功能，而复杂的架构却有很多问题呢？根本原因在于电路一旦设计好后进入生产，就不会再变，复杂性只是在设计时带来影响；而一个软件系统在投入使用后，后续还有源源不断的需求要实现，因此要不断地修改系统，复杂性在整个系统生命周期中都有很大影响。&lt;/p&gt;
&lt;p&gt;功能复杂的组件，另外一个典型特征就是采用了复杂的算法。复杂算法导致的问题主要是难以理解，进而导致难以实现、难以修改，并且出了问题难以快速解决。&lt;/p&gt;
&lt;p&gt;以 ZooKeeper 为例，ZooKeeper 本身的功能主要就是选举，为了实现分布式下的选举，采用了 ZAB 协议，所以 ZooKeeper 功能虽然相对简单，但系统实现却比较复杂。相比之下，etcd 就要简单一些，因为 etcd 采用的是 Raft 算法，相比 ZAB 协议，Raft 算法更加容易理解，更加容易实现。&lt;/p&gt;
&lt;p&gt;综合前面的分析，我们可以看到，无论是结构的复杂性，还是逻辑的复杂性，都会存在各种问题，所以架构设计时如果简单的方案和复杂的方案都可以满足需求，最好选择简单的方案。《UNIX 编程艺术》总结的 KISS（Keep It Simple, Stupid!）原则一样适应于架构设计。&lt;/p&gt;
&lt;h3 id=&quot;演化原则&quot;&gt;演化原则&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;演化原则宣言：“演化优于一步到位”。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;软件架构从字面意思理解和建筑结构非常类似，事实上“架构”这个词就是建筑领域的专业名词，维基百科对“软件架构”的定义中有一段话描述了这种相似性：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;从和目的、主题、材料和结构的联系上来说，软件架构可以和建筑物的架构相比拟。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;例如，软件架构描述的是一个软件系统的结构，包括各个模块，以及这些模块的关系；建筑架构描述的是一幢建筑的结构，包括各个部件，以及这些部件如何有机地组成成一幢完美的建筑。&lt;/p&gt;
&lt;p&gt;然而，字面意思上的相似性却掩盖了一个本质上的差异：建筑一旦完成（甚至一旦开建）就不可再变，而软件却需要根据业务的发展不断地变化！&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;古埃及的吉萨大金字塔，4000 多年前完成的，到现在还是当初的架构。&lt;/li&gt;
&lt;li&gt;中国的明长城，600 多年前完成的，现在保存下来的长城还是当年的结构。&lt;/li&gt;
&lt;li&gt;美国白宫，1800 年建成，200 年来进行了几次扩展，但整体结构并无变化，只是在旁边的空地扩建或者改造内部的布局。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;对于建筑来说，永恒是主题；而对于软件来说，变化才是主题&lt;/strong&gt;。软件架构需要根据业务的发展而不断变化。设计 Windows 和 Android 的人都是顶尖的天才，即便如此，他们也不可能在 1985 年设计出 Windows 8，不可能在 2009 年设计出 Android 6.0。&lt;/p&gt;
&lt;p&gt;如果没有把握“软件架构需要根据业务发展不断变化”这个本质，在做架构设计的时候就很容易陷入一个误区：试图一步到位设计一个软件架构，期望不管业务如何变化，架构都稳如磐石。&lt;/p&gt;
&lt;p&gt;为了实现这样的目标，要么照搬业界大公司公开发表的方案；要么投入庞大的资源和时间来做各种各样的预测、分析、设计。无论哪种做法，后果都很明显：投入巨大，落地遥遥无期。更让人沮丧的是，就算跌跌撞撞拼死拼活终于落地，却发现很多预测和分析都是不靠谱的。&lt;/p&gt;
&lt;p&gt;考虑到软件架构需要根据业务发展不断变化这个本质特点，&lt;strong&gt;软件架构设计其实更加类似于大自然“设计”一个生物，通过演化让生物适应环境，逐步变得更加强大：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先，生物要适应当时的环境。&lt;/li&gt;
&lt;li&gt;其次，生物需要不断地繁殖，将有利的基因传递下去，将不利的基因剔除或者修复。&lt;/li&gt;
&lt;li&gt;第三，当环境变化时，生物要能够快速改变以适应环境变化；如果生物无法调整就被自然淘汰；新的生物会保留一部分原来被淘汰生物的基因。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;软件架构设计同样是类似的过程：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先，设计出来的架构要满足当时的业务需要。&lt;/li&gt;
&lt;li&gt;其次，架构要不断地在实际应用过程中迭代，保留优秀的设计，修复有缺陷的设计，改正错误的设计，去掉无用的设计，使得架构逐渐完善。&lt;/li&gt;
&lt;li&gt;第三，当业务发生变化时，架构要扩展、重构，甚至重写；代码也许会重写，但有价值的经验、教训、逻辑、设计等（类似生物体内的基因）却可以在新架构中延续。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;架构师在进行架构设计时需要牢记这个原则，时刻提醒自己不要贪大求全，或者盲目照搬大公司的做法。应该认真分析当前业务的特点，明确业务面临的主要问题，设计合理的架构，快速落地以满足业务需要，然后在运行过程中不断完善架构，不断随着业务演化架构。&lt;/p&gt;
&lt;p&gt;即使是大公司的团队，在设计一个新系统的架构时，也需要遵循演化的原则，而不应该认为团队人员多、资源多，不管什么系统上来就要一步到位，因为业务的发展和变化是很快的，不管多牛的团队，也不可能完美预测所有的业务发展和变化路径。&lt;/p&gt;
&lt;h3 id=&quot;本节总结&quot;&gt;本节总结&lt;/h3&gt;
&lt;p&gt;架构即决策。架构需要面向业务需求，并在各种资源（人、财、物、时、事）约束条件下去做权衡、取舍。而决策就会存在不确定性。采用一些高屋建瓴的设计原则有助于去消除不确定，去逼近解决问题的最优解。&lt;/p&gt;
&lt;p&gt;1 合适原则&lt;/p&gt;
&lt;p&gt;架构无优劣，但存合适性。“汝之蜜糖，吾之砒霜”；架构一定要匹配企业所在的业务阶段；不要面向简历去设计架构，高大上的架构不等于适用；削足适履与打肿充胖都不符合合适原则；所谓合适，一定要匹配业务所处阶段，能够合理地将资源整合在一起并发挥出最大功效，并能够快速落地。&lt;/p&gt;
&lt;p&gt;2 简单原则&lt;/p&gt;
&lt;p&gt;&quot;我没有时间写一封短信，所以只好写一封长信&quot;。其实，简单比复杂更加困难。面对系统结构、业务逻辑和复杂性，我们可以编写出复杂的系统，但在软件领域，复杂代表的是“问题”。架构设计时如果简单的方案和复杂的方案都可以满足需求，最好选择简单的方案。但是，事实上，当软件系统变得太复杂后，就会有人换一个思路进行重构、升级，将它重新变得简单，这也是软件开发的大趋势。 简单原则是一个朴素且伟大的原则，Google的MapReduce系统就采用了分而治之的思想，而背后就是将复杂问题转化为简单问题的典型案例。&lt;/p&gt;
&lt;p&gt;3 演化原则&lt;/p&gt;
&lt;p&gt;大到人类社会、自然生物，小到一个细胞，似乎都遵循这一普世原则，软件架构也不例外。业务在发展、技术在创新、外部环境在变化，这一切都是在告诫架构师不要贪大求全，或者盲目照搬大公司的做法。应该认真分析当前业务的特点，明确业务面临的主要问题，设计合理的架构，快速落地以满足业务需要，然后在运行过程中不断完善架构，不断随着业务演化架构。怀胎需要十月，早一月或晚一月都很危险。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;今天我带着大家记录一下李运华老师从零开始学架构的关于架构的概念以及架构的三个原则，希望对您有所启发！如果你想学习更多关于架构方面的知识也可以订阅李老师的课程，文章最后我会给出微信二维码！好了，下篇我们就基于这些思想设计最适合我们实际的.NET Core CMS系统的开发框架吧！&lt;br/&gt;这里免费给李老师打个广告，毕竟本篇文章摘录了很多李老师的内容！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201812/1377250-20181206224136668-2070320704.png&quot; alt=&quot;1544107087000&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 06 Dec 2018 14:43:00 +0000</pubDate>
<dc:creator>依乐祝</dc:creator>
<og:description>﻿ .NET Core实战项目之CMS 第九章 设计篇 白话架构设计 前面两篇文章给大家介绍了我们实战的CMS系统的数据库设计，源码也已经上传到服务器上了。今天我们就好聊聊架构设计，在开始之前先给大家</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yilezhu/p/10080136.html</dc:identifier>
</item>
<item>
<title>插入排序的实现与优化并和选择排序进行性能比较 - Tom-shushu</title>
<link>http://www.cnblogs.com/Tom-shushu/p/10067561.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Tom-shushu/p/10067561.html</guid>
<description>&lt;p&gt;&lt;strong&gt;插入排序&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;第一种：交换法&lt;/strong&gt;&lt;br/&gt;| 8 | 6 | 3 | 2 | 10 | 9 | 11 | 4 | 5 |&lt;br/&gt;第一个元素就不需要考虑了，直接看第二个元素6，因为6&amp;lt;8,所以6与8交换位置得到：&lt;br/&gt;| 6 | 8 | 3 | 2 | 10 | 9 | 11 | 4 | 5 |&lt;br/&gt;在考虑第三个元素3，因为3&amp;lt;8,交换3和8，再比较3和6因为3&amp;lt;6，交换3和6得到：&lt;br/&gt;| 3 | 6 | 8 | 2 | 10 | 9 | 11 | 4 | 5 |&lt;br/&gt;后面以此类推&lt;br/&gt;&lt;strong&gt;第二种：复制法：&lt;/strong&gt;&lt;br/&gt;|51|6|85|6|8|5|4|&lt;br/&gt;| | 6|&lt;br/&gt;将6复制一份，然后比较6之前的元素51&lt;br/&gt;因为6&amp;lt;51，不适合放到当前位置，所以将51向后移动 ，考虑6是不是应该放到前一个位置&lt;br/&gt;|51|51|85|6|8|5|4|&lt;br/&gt;|6 |&lt;br/&gt;因为现在6已经是第0个位置了，所以就放到这个位置。。。。以此类推&lt;br/&gt;和上一个博客一样，将之前的选择排序写到一个 .h 文件中来测试：&lt;br/&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#ifndef INC_04_INSERTION_SORT_SORTTESTHELPER_H
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; INC_04_INSERTION_SORT_SORTTESTHELPER_H
&lt;span&gt; 3&lt;/span&gt; #include &amp;lt;iostream&amp;gt;
&lt;span&gt; 4&lt;/span&gt; #include &amp;lt;algorithm&amp;gt;
&lt;span&gt; 5&lt;/span&gt; #include &amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;
&lt;span&gt; 6&lt;/span&gt; #include &amp;lt;ctime&amp;gt;
&lt;span&gt; 7&lt;/span&gt; #include &amp;lt;cassert&amp;gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; SortTestHelper {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 生成有n个元素的随机数组,每个元素的随机范围为[rangeL, rangeR]&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; *generateRandomArray(&lt;span&gt;int&lt;/span&gt; n, &lt;span&gt;int&lt;/span&gt; range_l, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; range_r) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; *arr = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[n];
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        srand(time(NULL));
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; n; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             arr[i] = rand() % (range_r - range_l + &lt;span&gt;1&lt;/span&gt;) +&lt;span&gt; range_l;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; arr;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 拷贝整型数组a中的所有元素到一个新的数组, 并返回新的数组&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; *copyIntArray(&lt;span&gt;int&lt;/span&gt; a[], &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n){
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; *arr = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[n];
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         copy(a, a+&lt;span&gt;n, arr);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; arr;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打印arr数组的所有内容&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;     template&amp;lt;typename T&amp;gt;
&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; printArray(T arr[], &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; n; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             cout &amp;lt;&amp;lt; arr[i] &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             cout &amp;lt;&amp;lt;&lt;span&gt; endl;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断arr数组是否有序&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;     template&amp;lt;typename T&amp;gt;
&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;bool&lt;/span&gt; isSorted(T arr[], &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n) {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; n - &lt;span&gt;1&lt;/span&gt;; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (arr[i] &amp;gt; arr[i + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 测试sort排序算法排序arr数组所得到结果的正确性和算法运行时间&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt;     template&amp;lt;typename T&amp;gt;
&lt;span&gt;43&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; testSort(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; &amp;amp;sortName, &lt;span&gt;void&lt;/span&gt; (*sort)(T[], &lt;span&gt;int&lt;/span&gt;), T arr[], &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n) {
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;         clock_t startTime =&lt;span&gt; clock();
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;        sort(arr, n);
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;         clock_t endTime =&lt;span&gt; clock();
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;         cout &amp;lt;&amp;lt; sortName &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; : &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;double&lt;/span&gt;(endTime - startTime) / CLOCKS_PER_SEC &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;endl;
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;        assert(isSorted(arr, n));
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; 
&lt;span&gt;53&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;选择排序代码：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#ifndef INC_04_INSERTION_SORT_SELECTIONSORT_H
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; INC_04_INSERTION_SORT_SELECTIONSORT_H
&lt;span&gt; 3&lt;/span&gt; #include &amp;lt;iostream&amp;gt;
&lt;span&gt; 4&lt;/span&gt; #include &amp;lt;algorithm&amp;gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; template&amp;lt;typename T&amp;gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; selectionSort(T arr[], &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n){
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt; ; i &amp;lt; n ; i ++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; minIndex =&lt;span&gt; i;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;( &lt;span&gt;int&lt;/span&gt; j = i + &lt;span&gt;1&lt;/span&gt; ; j &amp;lt; n ; j ++&lt;span&gt; )
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;( arr[j] &amp;lt;&lt;span&gt; arr[minIndex] )
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 minIndex =&lt;span&gt; j;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        swap( arr[i] , arr[minIndex] );
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;插入函数（主函数）代码&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
#include &amp;lt;iostream&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;algorithm&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SortTestHelper.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SelectionSort.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;一，没有优化的插入排序（交换法） &lt;/span&gt;&lt;span&gt;
/*&lt;/span&gt;&lt;span&gt;
template&amp;lt;typename T&amp;gt;
void insertionSort(T arr[], int n){
//插入排序第一个元素不用考虑 
    for( int i = 1 ; i &amp;lt; n ; i ++ ) {
        // 寻找元素arr[i]合适的插入位置
        // 写法一： 
//        for( int j = i ; j &amp;gt; 0 ; j-- )
//            if( arr[j] &amp;lt; arr[j-1] )
//                swap( arr[j] , arr[j-1] );
//            else
//           break;
        // 写法二 ： 
          for( int j = i ; j &amp;gt; 0 &amp;amp;&amp;amp; arr[j] &amp;lt; arr[j-1] ; j -- )
                 swap( arr[j] , arr[j-1] );
    }
    return;
}
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;二，优化后的插入排序 （复制法）
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;51,6,85,6,8,5,4
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;   6
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将6复制一份，然后比较6之前的元素51
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;因为6&amp;lt;51，不适合放到当前位置，所以将51向后移动 ，考虑6是不是应该放到前一个位置 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;51,51,85,6,8,5,4
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;6
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;因为现在6已经是第0个位置了，所以就放到这个位置。。。。以此类推 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;写法三 ： &lt;/span&gt;
&lt;span&gt; 
template&lt;/span&gt;&amp;lt;typename T&amp;gt;
&lt;span&gt;void&lt;/span&gt; insertionSort(T arr[], &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n){
   &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;( &lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt; ; i &amp;lt; n ; i ++&lt;span&gt; ) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 寻找元素arr[i]合适的插入位置&lt;/span&gt;
        T e =&lt;span&gt; arr[i];
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; j;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存元素e应该插入的位置 &lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;( j = i ; j &amp;gt; &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; arr[j-&lt;span&gt;1&lt;/span&gt;] &amp;gt; e ; j --&lt;span&gt; ){
            arr[j] &lt;/span&gt;= arr[j-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
        }
    arr[j] &lt;/span&gt;=&lt;span&gt; e;
    }
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 比较SelectionSort和InsertionSort两种排序算法的性能效率
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 此时， 插入排序比选择排序性能略低&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main() {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n = &lt;span&gt;20000&lt;/span&gt;&lt;span&gt;;
    cout&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Test for random array, size = &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;lt;&amp;lt;n&amp;lt;&amp;lt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, random range [0, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;lt;&amp;lt;n&amp;lt;&amp;lt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;endl;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; *arr1 = SortTestHelper::generateRandomArray(n,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; *arr2 =&lt;span&gt; SortTestHelper::copyIntArray(arr1, n);
    SortTestHelper::testSort(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Insertion Sort&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, insertionSort,arr1,n);
    SortTestHelper::testSort(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Selection Sort&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, selectionSort,arr2,n);
    &lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;&lt;span&gt;[] arr1;
    &lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;&lt;span&gt;[] arr2;
    cout&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;endl;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;进行测试：&lt;/strong&gt;&lt;br/&gt;1.首先看一下没有进行优化的[写法一:]插入排序和选择排序性能比较：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1398504/201812/1398504-20181204214630586-1060521285.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2.然后是没有进行优化的[写法二:]插入排序和选择排序性能比较：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1398504/201812/1398504-20181204214452958-578760750.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可见虽然性能都差不多，但是写法二明显比写法一的代码更漂亮&lt;br/&gt;结论：在随机的，无序的情况下，即是插入排序没有优化但是它的性能依然比选择排序好&lt;br/&gt;3.优化后的插入排序与选择排序比较：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1398504/201812/1398504-20181204214816563-651098215.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可见此时插入排序的性能远远大于选择排序&lt;/p&gt;

</description>
<pubDate>Thu, 06 Dec 2018 14:38:00 +0000</pubDate>
<dc:creator>Tom-shushu</dc:creator>
<og:description>插入排序第一种：交换法| 8 | 6 | 3 | 2 | 10 | 9 | 11 | 4 | 5 |第一个元素就不需要考虑了，直接看第二个元素6，因为6&lt;8,所以6与8交换位置得到：| 6 |</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Tom-shushu/p/10067561.html</dc:identifier>
</item>
<item>
<title>自己动手实现java数据结构（三） 栈 - 小熊餐馆</title>
<link>http://www.cnblogs.com/xiaoxiongcanguan/p/10061255.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaoxiongcanguan/p/10061255.html</guid>
<description>&lt;p&gt;　　在许多算法设计中都需要一种&lt;strong&gt;&quot;先进后出(First Input Last Output)&quot;&lt;/strong&gt;的数据结构，因而一种被称为&lt;strong&gt;&quot;栈&quot;&lt;/strong&gt;的数据结构被抽象了出来。&lt;/p&gt;
&lt;p&gt;　　栈的结构类似一个罐头：只有一个开口；先被放进去的东西沉在底下，后放进去的东西被放在顶部；想拿东西必须按照从上到下的顺序进行操作。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1506329/201812/1506329-20181204193005971-2091660923.png&quot; alt=&quot;&quot;/&gt;     示意图来自《大话数据结构》&lt;/p&gt;
&lt;p&gt;　　对于一个类似罐头的栈，用户能对其进行的操作很少：仅仅可以对栈顶开口处元素进行操作，因而栈的使用方式非常简单。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 栈ADT 接口定义
 * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; Stack&amp;lt;E&amp;gt;&lt;span&gt;{

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 将一个元素 加入栈顶
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt;  e 需要插入的元素
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 是否插入成功
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; push(E e);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 返回栈顶元素，并且将其从栈中移除(弹出)
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 当前栈顶元素
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    E pop();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 返回栈顶元素，不将其从栈中移除(窥视)
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 当前栈顶元素
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    E peek();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 返回当前列表中元素的个数
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 判断当前列表是否为空
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 如果当前列表中元素个数为0，返回true；否则，返回false
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isEmpty();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 清除栈中所有元素
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; clear();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获得迭代器
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    Iterator&lt;/span&gt;&amp;lt;E&amp;gt;&lt;span&gt; iterator();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　如果我们将开口朝上的栈旋转90度，会发现栈和先前我们介绍过的线性表非常相似。栈可以被视为一个只能在某一端进行操作的，被施加了特别限制的线性表。&lt;/p&gt;
&lt;h2&gt;3.1 栈的向量实现&lt;/h2&gt;
&lt;p&gt;　　栈作为一种特殊的线性表，使用向量作为栈的底层实现是很自然的(&lt;strong&gt;向量栈&lt;/strong&gt;)。&lt;/p&gt;
&lt;p&gt;　　jdk的栈结构(Stack)是通过继承向量类(Vector)来实现的，这一栈的实现方式被java集合框架(&lt;strong&gt;Collection Framework&lt;/strong&gt;)的作者&lt;strong&gt;Josh Bloch&lt;/strong&gt;在其所著书籍&lt;strong&gt;《Effective Java》&lt;/strong&gt;中所批评，&lt;strong&gt;Josh Bloch&lt;/strong&gt;认为这是一种糟糕的实现方式，因为&lt;strong&gt;继承自向量的栈对使用者暴露了过多的细节&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;原文部分摘录：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre readability=&quot;4.5&quot;&gt;
&lt;span readability=&quot;3&quot;&gt;&lt;em&gt;&lt;strong&gt;复合优先于继承&lt;/strong&gt;&lt;/em&gt;

　　&lt;em&gt;继承打破了封装性。  

　　java对象中违反这条规则的：stack不是vector，所以stack不应该扩展vector。如果在合适用复合的地方用了继承，会暴露实现细节。&lt;/em&gt;&lt;p&gt;&lt;em&gt;　　继承机制会把超类中所有缺陷传递到子类中，而复合则允许设计新的API来隐藏这些缺陷。&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　考虑到这一点，我们的向量栈采用复合的方式实现。通过使用之前我们已经实现的向量数据结构作为基础，实现一个栈容器。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;向量基本属性和接口：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 向量为基础实现的 栈结构
 * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; VectorStack &amp;lt;E&amp;gt; &lt;span&gt;implements&lt;/span&gt; Stack&amp;lt;E&amp;gt;&lt;span&gt;{

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 内部向量
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; ArrayList&amp;lt;E&amp;gt;&lt;span&gt; innerArrayList;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 默认构造方法
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; VectorStack() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.innerArrayList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 构造方法,确定初始化时的内部向量大小
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; VectorStack(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; initSize) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.innerArrayList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;(initSize);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; innerArrayList.size();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isEmpty() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; innerArrayList.isEmpty();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; clear() {
        innerArrayList.clear();
    }

   @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Iterator&amp;lt;E&amp;gt;&lt;span&gt; iterator() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; innerArrayList.iterator();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; innerArrayList.toString();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　由于我们的向量容器已经具备了诸如自动扩容等特性，因而向量栈的许多接口都可以通过简单的调用内部向量的接口来实现，不需要额外的操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;栈的特有接口实现：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; push(E e) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::将新元素插入内部向量末尾(入栈)&lt;/span&gt;
&lt;span&gt;        innerArrayList.add(e);

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; E pop() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.isEmpty()){
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; CollectionEmptyException(&quot;Stack already empty&quot;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::内部向量末尾下标&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; lastIndex = innerArrayList.size() - 1&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::将向量末尾处元素删除并返回(出栈)&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; innerArrayList.remove(lastIndex);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; E peek() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.isEmpty()){
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; CollectionEmptyException(&quot;Stack already empty&quot;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::内部向量末尾下标&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; lastIndex = innerArrayList.size() - 1&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::返回向量末尾处元素(窥视)&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; innerArrayList.get(lastIndex);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　栈的&lt;strong&gt;FIFO&lt;/strong&gt;的特性，使得我们必须选择内部线性表的一端作为栈顶。&lt;/p&gt;
&lt;p&gt;　　我们知道向量在&lt;strong&gt;头部&lt;/strong&gt;的插入/删除由于需要批量移动内部元素，时间复杂度为&lt;strong&gt;O(n)&lt;/strong&gt;；而向量&lt;strong&gt;尾部&lt;/strong&gt;的插入/删除由于避免了内部元素的移动，时间复杂度为&lt;strong&gt;O(1)&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　而位于栈顶的元素是需要频繁&lt;strong&gt;插入(push)&lt;/strong&gt;和&lt;strong&gt;删除(pop)&lt;/strong&gt;的。出于效率的考虑，我们将&lt;strong&gt;向量的尾部作为栈顶&lt;/strong&gt;，使得向量栈的出栈、入栈操作都达到了优秀的&lt;strong&gt;常数时间复杂度O(1)&lt;/strong&gt;。&lt;/p&gt;
&lt;h2&gt;3.2 栈的链表实现&lt;/h2&gt;
&lt;p&gt;　　链表和向量同为线性表，因此栈的链表实现和向量实现几乎完全雷同。&lt;/p&gt;
&lt;p&gt;　　由于链表在头尾出的增加/删除操作时间复杂度都是O(1)，理论上链表栈的栈顶放在链表的头部或者尾部都可以。为了和向量栈实现保持一致，我们的链表栈也将尾部作为栈顶。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 链表为基础实现的 栈结构
 * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; LinkedListStack&amp;lt;E&amp;gt; &lt;span&gt;implements&lt;/span&gt; Stack&amp;lt;E&amp;gt;&lt;span&gt;{

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 内部链表
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; LinkedList&amp;lt;E&amp;gt;&lt;span&gt; innerLinkedList;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 默认构造方法
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; LinkedListStack() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.innerLinkedList = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;&lt;span&gt;();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; push(E e) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::将新元素插入内部链表末尾(入栈)&lt;/span&gt;
&lt;span&gt;        innerLinkedList.add(e);

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; E pop() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.isEmpty()){
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; CollectionEmptyException(&quot;Stack already empty&quot;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::内部链表末尾下标&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; lastIndex = innerLinkedList.size() - 1&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::将链表末尾处元素删除并返回(出栈)&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; innerLinkedList.remove(lastIndex);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; E peek() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.isEmpty()){
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; CollectionEmptyException(&quot;Stack already empty&quot;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::内部链表末尾下标&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; lastIndex = innerLinkedList.size() - 1&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::返回链表末尾处元素(窥视)&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; innerLinkedList.get(lastIndex);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; innerLinkedList.size();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isEmpty() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; innerLinkedList.isEmpty();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; clear() {
        innerLinkedList.clear();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Iterator&amp;lt;E&amp;gt;&lt;span&gt; iterator() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; innerLinkedList.iterator();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; innerLinkedList.toString();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　前面说到，栈在许多算法中被广泛的使用。我们在这里举一个简单的例子，来介绍栈的应用场合。&lt;/p&gt;
&lt;h3&gt;算术表达式括号匹配校验&lt;/h3&gt;
&lt;p&gt;　　在算术表达式中，通过添加括号来设置运算符的优先级，进而控制计算的顺序。如果粗心大意导致括号没有匹配，会导致算术表达式语法错误，无法计算出正确结果。因此需要一种括号匹配的校验，来防止这种错误。&lt;/p&gt;
&lt;p&gt;　　我们的算术表达式支持：小括号&quot;()&quot;、中括号&quot;[]&quot;、大括号&quot;{}&quot;。简单起见，当前括号匹配算法实现不支持括号优先级的校验。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;常量及辅助方法&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 括号匹配 工具类
 * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ParenthesisMatchingUtil {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 左 小括号
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; PARENTHESES_OPEN = '('&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 右 小括号
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; PARENTHESES_CLOSE = ')'&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 左 中括号
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; BRACKET_OPEN = '['&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 右 中括号
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; BRACKET_CLOSE = ']'&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 左 大括号
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; BRACES_OPEN = '{'&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 右 右括号
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; BRACES_CLOSE = '}'&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 判断当前字符是否是 左括号
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; isParenthesisOpen(&lt;span&gt;char&lt;/span&gt;&lt;span&gt; target){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (target == PARENTHESES_OPEN) || (target == BRACKET_OPEN) || (target ==&lt;span&gt; BRACES_OPEN);
    }
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 判断当前字符是否是 右括号
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; isParenthesisClose(&lt;span&gt;char&lt;/span&gt;&lt;span&gt; target){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (target == PARENTHESES_CLOSE) || (target == BRACKET_CLOSE) || (target ==&lt;span&gt; BRACES_CLOSE);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 判断左右括号是否匹配
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; isMatch(&lt;span&gt;char&lt;/span&gt; left, &lt;span&gt;char&lt;/span&gt;&lt;span&gt; right){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (left == PARENTHESES_OPEN &amp;amp;&amp;amp; right == PARENTHESES_CLOSE) ||&lt;span&gt;
                (left &lt;/span&gt;== BRACKET_OPEN &amp;amp;&amp;amp; right == BRACKET_CLOSE) ||&lt;span&gt;
                (left &lt;/span&gt;== BRACES_OPEN &amp;amp;&amp;amp; right ==&lt;span&gt; BRACES_CLOSE);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;校验算法实现：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　/**&lt;/span&gt;&lt;span&gt;
     * 判断表达式中的括号是否匹配
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; expression 表达式
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; bracketsMatch(String expression){
        Stack&lt;/span&gt;&amp;lt;Character&amp;gt; stack = &lt;span&gt;new&lt;/span&gt; VectorStack&amp;lt;&amp;gt;&lt;span&gt;();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::将字符串转换为字符数组，进行遍历&lt;/span&gt;
        &lt;span&gt;char&lt;/span&gt;[] expressionChars =&lt;span&gt; expression.toCharArray();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;char&lt;/span&gt;&lt;span&gt; targetChar : expressionChars){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::如果当前字符是 左括号&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(isParenthesisOpen(targetChar)){
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::左括号 压入栈中&lt;/span&gt;
&lt;span&gt;                stack.push(targetChar);

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::如果当前字符是 右括号&lt;/span&gt;
            }&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(isParenthesisClose(targetChar)){
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::如果当前栈为空&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(stack.isEmpty()){
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::左括号少于右括号 (校验失败)&lt;/span&gt;
                    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::查看栈顶左括号&lt;/span&gt;
                &lt;span&gt;char&lt;/span&gt; leftParenthesis =&lt;span&gt; stack.peek();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::&quot;栈顶左括号&quot; 和 &quot;当前右括号&quot; 匹配&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(isMatch(leftParenthesis,targetChar)){
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::栈顶左括号出栈&lt;/span&gt;
&lt;span&gt;                    stack.pop();
                }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::左右括号类型不匹配 (校验失败)&lt;/span&gt;
                    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                }
            }&lt;br/&gt;　　　　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::其它字符不进行处理&lt;/span&gt;&lt;span&gt;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::遍历结束&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(stack.isEmpty()){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::如果栈为空,说明括号完全匹配 (校验成功)&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::如果栈不为空，左括号多于右括号 (校验失败)&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　栈作为线性表的限制性封装，其性能和其内部作为基础的线性表相同。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;空间效率：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　向量栈的空间效率和内部向量相似，效率很高。&lt;/p&gt;
&lt;p&gt;　　　　链表栈的空间效率和内部链表相似，效率略低于向量栈。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　时间效率：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　&lt;/strong&gt;　　　栈的常用操作，&lt;strong&gt;pop&lt;/strong&gt;、&lt;strong&gt;push&lt;/strong&gt;、&lt;strong&gt;peek&lt;/strong&gt;都是在线性表的尾部进行操作。因此无论是向量栈还是链表栈，栈的常用操作时间复杂度都为&lt;strong&gt;O(1)&lt;/strong&gt;，效率很高。&lt;/p&gt;

&lt;p&gt;　　虽然从理论上来说，栈作为一个功能上被限制了的线性表，完全可以被线性表所替代。但相比线性表，栈结构屏蔽了线性表的下标等细节，只对外暴露出必要的接口。栈的引入简化了许多程序设计的复杂度，让使用者的思维能够聚焦于算法逻辑本身而不是其所依赖数据结构的细节。&lt;/p&gt;
&lt;p&gt;　　通常，暴露出不必要的内部细节对于使用者是一种沉重的负担。简单为美，从栈的设计思想中可见一斑。&lt;/p&gt;
&lt;p&gt;　　这篇博客的代码在我的 github上：&lt;a href=&quot;https://github.com/1399852153/DataStructures&quot; target=&quot;_blank&quot;&gt;https://github.com/1399852153/DataStructures&lt;/a&gt;&lt;a href=&quot;https://github.com/1399852153/DataStructures&quot; target=&quot;_blank&quot;&gt; &lt;/a&gt;，文章还存在许多不足之处，请多指教。&lt;/p&gt;
</description>
<pubDate>Thu, 06 Dec 2018 13:59:00 +0000</pubDate>
<dc:creator>小熊餐馆</dc:creator>
<og:description>1.栈的介绍 在许多算法设计中都需要一种&quot;先进后出(First Input Last Output)&quot;的数据结构，因而一种被称为&quot;栈&quot;的数据结构被抽象了出来。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaoxiongcanguan/p/10061255.html</dc:identifier>
</item>
<item>
<title>我的一次被骗去培训班狗血的经历 - 锋哥程序十年</title>
<link>http://www.cnblogs.com/bianchengniuren/p/10079809.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bianchengniuren/p/10079809.html</guid>
<description>&lt;p&gt;2017年的夏天特别热，以至于杭州的夜晚依然像蒸笼一般。&lt;/p&gt;
&lt;p&gt;就在那年，小于在杭州参加了高考。艺术科成绩已经知道了，过本科线。只是文化课成绩还没有出来。小于的文化课成绩向来不大好，小于一直有点担心。&lt;/p&gt;
&lt;p&gt;2017年的互联网浪潮席卷全球，程序员的工资收入首次打败金融从业人员，名列榜首。搞得人人想要学习编程，个个争当编程模范。一天，班主任找小于等几个同学到学校，向他们介绍了某培训机构的老师。班主任建议两点：一，按照他们几个的成绩，考上好的学校机会不大。二，现在编程很火爆，工资又高，学习编程是一个比较不错的选择。&lt;/p&gt;
&lt;p&gt;培训在北京进行，培训期一年。学费6万5。到北京上学是很多人从小的梦想。培训机构的老师为他们量身定做了一系列的培训计划。承诺两点：一，学完之后包分配工作，工资不会少于7000。 二，学费通过信用卡贷款的方式，分期偿还，解决了他们没有钱报名的后顾之忧。但是有一个条件，三天之后招生结束，需要在三天之内做出决定。&lt;/p&gt;
&lt;p&gt;后来在班主任的“&lt;strong&gt;怂恿&lt;/strong&gt;”之下，小于和他的三位同学报名参加培训班，通过信用卡贷款的方式一次把学费交清。对于小于来说，悲剧也从此开始了。高考放榜，小于以优异的成绩被某本科师范院校录取。但此时对于小于来说，似乎已经没有选择了。如果小于去读本科，培训班的学费不能退，意味着在读本科期间，每月都要还两千多块的贷款，一直还三年。这是小于负担不起的。如果放弃去读本科，选择去某内培训班学习。一年学成之后，每个月都有工资收入，这些工资可以用来还贷。&lt;/p&gt;
&lt;p&gt;小于收拾行李，踏上了北上的列车。&lt;/p&gt;
&lt;p&gt;培训班开始之后，小于很快尝到了苦头。大班制上课，和高中差不多。但是由于小于是读艺术专业的，文化课本来就不怎么好，所以很快就跟不上老师的进度了。和班里的大多数同学一样，第一个月是新鲜期，学的都很带劲。但是到了第三个月之后，基本上就不知道老师在讲什么了。而这时，小于很惊讶的发现，班里竟然还有小学毕业的学生。而且小于还知道了，很多毕业班的老师给培训学校介绍学生是有回扣的，但一切都晚了。很快一年过去了，小于学的是前端，HTML基本只学了一点皮毛。&lt;/p&gt;
&lt;p&gt;学校介绍的工作很烂，据很多已经毕业的同学说，根本待不下去。于是小于到社会上找工作，平时寄宿在北京上大学的同学宿舍。工作找了几个月，经过多次的面试，小于终于明白了，以他目前的水平，根本干不了研发工作。和他一个班的同学，基本上都没有找到研发的工作。过程中，有些同学打电话回学校闹，学校的老师承诺可以让他们再回学校免费学习一段时间。但是他们谁都不愿意去浪费时间了。&lt;/p&gt;
&lt;p&gt;小于就业了，干的是外包测试的项目。小于在微信说，公司不给买社保，干完三个月外包公司就会把他们开掉，到时又得重新找工作。小于无奈的说，他还是很想上大学，以后有机会应该会去考成人高考，拿到本科证。&lt;/p&gt;
&lt;p&gt;小于说完叹了一口气，我的内心也变得无比沉重。&lt;/p&gt;
&lt;p&gt;给大家准备了一些免费的编程学习资料：&lt;a href=&quot;https://jq.qq.com/?_wv=1027&amp;amp;k=5AJtT6Q&quot;&gt;点击领资料&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 06 Dec 2018 13:51:00 +0000</pubDate>
<dc:creator>锋哥程序十年</dc:creator>
<og:description>2017年的夏天特别热，以至于杭州的夜晚依然像蒸笼一般。 就在那年，小于在杭州参加了高考。艺术科成绩已经知道了，过本科线。只是文化课成绩还没有出来。小于的文化课成绩向来不大好，小于一直有点担心。 20</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bianchengniuren/p/10079809.html</dc:identifier>
</item>
</channel>
</rss>