<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>【Spring源码解析】—— 简单工厂模式的BeanFactory的超简版实现 - 可可_小虾米</title>
<link>http://www.cnblogs.com/keke-xiaoxiami/p/10934406.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/keke-xiaoxiami/p/10934406.html</guid>
<description>&lt;h3 align=&quot;center&quot;&gt; 一、什么是简单工厂模式&lt;/h3&gt;
&lt;p&gt;设计模式的核心是“分工”，通过分工将对象与职责划分的更细化，进而提升系统设计的可扩展性，使其更容易维护。&lt;/p&gt;

&lt;p&gt;开闭原则：对扩展开放，对修改关闭；要增加一个新的处理逻辑，可以开一个新的类，不要在老的上面修改&lt;/p&gt;
&lt;p&gt;依赖倒转原则：依赖关系从具体转向抽象，也就是说：A调用B，不是直接调用B的实现，而是依赖B的接口&lt;/p&gt;
&lt;p&gt;迪米特法则：类尽量少的与其他类发生关系，或者产生依赖，以此来使扩展可以更容易&lt;/p&gt;

&lt;p&gt;工厂模式中的三种：简单工厂模式、工厂方法模式、抽象工厂模式；实现了创建者和调用者的分离，调用者不需要知道具体的创建者是什么类，只需要知道工厂的接口以及自己想要的产品名称，就可以进行调用得到想要的产品&lt;/p&gt;
&lt;p&gt;简单工厂模式：简单工厂模式也称为静态工厂模式，工厂类一般采用静态方法，根据接收的参数不同来确定返回对象实例，但简单工厂模式违反了开闭原则，要增加一个新的类别必须要修改代码&lt;/p&gt;
&lt;p&gt;注意，简单工厂模式就是：针对一个项目或者一个独立模块只有一个工厂类，而工厂方法模式是有一组实现了相同接口的工厂类（虽然符合开闭原则，但是会增加新的类来扩展，看情况而定，实际上在项目开发中通常还是用简单工厂比较多）&lt;/p&gt;
&lt;h3&gt;二、依据Spring中的BeanFactory自己实现简版&lt;/h3&gt;
&lt;p&gt;首先是，先写一个接口类，BeanFactory的接口类如下：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;public interface&lt;/strong&gt; BeanFactory {&lt;br/&gt;    Object getBean(String beanName);&lt;br/&gt;}&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;下面是xml配置文件 springtest.xml：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;

&amp;lt;beans&amp;gt;

    &amp;lt;bean id=&quot;usertest&quot; &lt;span&gt;class&lt;/span&gt;=&quot;beanfactory.demo.User&quot;&amp;gt;

        &amp;lt;property name=&quot;username&quot; value=&quot;lxlx&quot; /&amp;gt;

        &amp;lt;property name=&quot;passWord&quot; value=&quot;111&quot; /&amp;gt;

        &amp;lt;property name=&quot;age&quot; value=&quot;11&quot;/&amp;gt;

    &amp;lt;/bean&amp;gt;

&amp;lt;/beans&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;下面是bean定义的class文件 User类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; User {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String username;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String passWord;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setUsername(String username) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.username =&lt;span&gt; username;
    }&lt;br/&gt;&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setPassWord(String passWord) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.passWord =&lt;span&gt; passWord;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setAge(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; age) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getUsername() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; username;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getPassWord() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; passWord;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getAge() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; age;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来是实现类 ConcreteBeanFactory：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; beanfactory.demo;


&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.dom4j.io.SAXReader;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; org.dom4j.*&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.File;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Type;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.HashMap;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Map;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Iterator;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Method;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;

 * Created by xiami on 2019/5/26.

 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ConcreteBeanFactory &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; BeanFactory{


    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Map&amp;lt;String, Object&amp;gt; beanDefinitionMap = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String, Object&amp;gt;&lt;span&gt;();


    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;简单工厂模式的特征是：一个工厂中可以生产多种不同的产品，这里的Bean其实是没有区分不同的bean，是可以通过get返回不同的bean&lt;/span&gt;
&lt;span&gt;
    @Override

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object getBean(String beanName) {

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; beanDefinitionMap.get(beanName);

    }


    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;增加一个init的操作方法

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从xml配置文件中进行解析读取&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; init(String xmlPath){

        SAXReader saxReader &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SAXReader();

        File file &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; File(xmlPath);

        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {

            Document document &lt;/span&gt;=&lt;span&gt; saxReader.read(file);

            Element root &lt;/span&gt;=&lt;span&gt; document.getRootElement();

            Element foo;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 遍历bean&lt;/span&gt;

            &lt;span&gt;for&lt;/span&gt; (Iterator i = root.elementIterator(&quot;bean&quot;&lt;span&gt;); i.hasNext();) {

                foo &lt;/span&gt;=&lt;span&gt; (Element) i.next();

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取bean的属性id和class&lt;/span&gt;
&lt;span&gt;
                Attribute id &lt;/span&gt;= foo.attribute(&quot;id&quot;&lt;span&gt;);

                Attribute cls &lt;/span&gt;= foo.attribute(&quot;class&quot;&lt;span&gt;);

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 利用Java反射机制，通过class的名称获取Class对象&lt;/span&gt;
&lt;span&gt;
                Class&lt;/span&gt;&amp;lt;?&amp;gt; bean =&lt;span&gt; Class.forName(cls.getText());

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取对应class的信息&lt;/span&gt;
&lt;span&gt;
                java.beans.BeanInfo info &lt;/span&gt;=&lt;span&gt; java.beans.Introspector.getBeanInfo(bean);

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取其属性描述&lt;/span&gt;
&lt;span&gt;
                java.beans.PropertyDescriptor pd[] &lt;/span&gt;=&lt;span&gt; info.getPropertyDescriptors();

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置值的方法&lt;/span&gt;
&lt;span&gt;
                Method mSet &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建一个对象&lt;/span&gt;
&lt;span&gt;
                Object obj &lt;/span&gt;=&lt;span&gt; bean.newInstance();

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 遍历该bean的property属性&lt;/span&gt;

                &lt;span&gt;for&lt;/span&gt; (Iterator ite = foo.elementIterator(&quot;property&quot;&lt;span&gt;); ite.hasNext();) {

                    Element foo2 &lt;/span&gt;=&lt;span&gt; (Element) ite.next();

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取该property的name属性&lt;/span&gt;
&lt;span&gt;
                    Attribute name &lt;/span&gt;= foo2.attribute(&quot;name&quot;&lt;span&gt;);

                    String value &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

                    Object typeValue &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取value值&lt;/span&gt;
&lt;span&gt;
                    value &lt;/span&gt;= foo2.attributeValue(&quot;value&quot;&lt;span&gt;);

                    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; k = 0; k &amp;lt; pd.length; k++&lt;span&gt;) {

                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (pd[k].getName().equalsIgnoreCase(name.getText())) {

                            mSet &lt;/span&gt;=&lt;span&gt; pd[k].getWriteMethod();

                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置值这里，需要根据类型给value做类型转换

                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;properties中包含了properType的项，因为当前程序中就只有String和Int，先处理这样的类型&lt;/span&gt;
&lt;span&gt;
                            Type mType &lt;/span&gt;=&lt;span&gt; pd[k].getPropertyType();

                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mType.getTypeName().equals(&quot;java.lang.String&quot;&lt;span&gt;)){

                                typeValue &lt;/span&gt;=&lt;span&gt; String.valueOf(value);

                            }

                            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(mType.getTypeName().equals(&quot;int&quot;&lt;span&gt;)){

                                typeValue &lt;/span&gt;=&lt;span&gt; Integer.parseInt(value);

                            }

                            mSet.invoke(obj, typeValue);

                        }

                    }

                }

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将对象放入beanMap中，其中key为id值，value为对象&lt;/span&gt;
&lt;span&gt;
                beanDefinitionMap.put(id.getText(), obj);

            }

        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e){

            System.out.println(e.toString());

        }

    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;下面是测试类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Client {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){

        AbstractBeanFactory absbf &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AbstractBeanFactory();

        absbf.init(&lt;/span&gt;&quot;E:\\java-demo\\src\\beanfactory\\demo\\springtest.xml&quot;&lt;span&gt;);

        User user &lt;/span&gt;= (User)absbf.getBean(&quot;usertest&quot;&lt;span&gt;);

        System.out.println(&lt;/span&gt;&quot;User类的bean有没有创建成功：&quot; +&lt;span&gt; user);

        System.out.println(&lt;/span&gt;&quot;属性值：&quot; + user.getUsername() + &quot;,&quot; + user.getPassWord() + &quot;,&quot; +&lt;span&gt; user.getAge());

    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试结果是：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/634202/201905/634202-20190527234319779-1881480996.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;要理解的是：简单工厂模式是一种思想，就是：不针对特定的产品进行工厂的划分，也就是说没有多个批次或者类别的工厂，而是所有的内容都在一个工厂里面生产，你需要什么我给你什么即可&lt;/p&gt;

&lt;p&gt;参考文章：https://blog.csdn.net/mlc1218559742/article/details/52776160/&lt;/p&gt;
</description>
<pubDate>Mon, 27 May 2019 15:50:00 +0000</pubDate>
<dc:creator>可可_小虾米</dc:creator>
<og:description>一、什么是简单工厂模式 设计模式的核心是“分工”，通过分工将对象与职责划分的更细化，进而提升系统设计的可扩展性，使其更容易维护。 开闭原则：对扩展开放，对修改关闭；要增加一个新的处理逻辑，可以开一个新</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/keke-xiaoxiami/p/10934406.html</dc:identifier>
</item>
<item>
<title>一篇文章搞懂装饰器所有用法（建议收藏） - 站在两个世界的边缘</title>
<link>http://www.cnblogs.com/wongbingming/p/10934356.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wongbingming/p/10934356.html</guid>
<description>&lt;h2 id=&quot;装饰器语法糖&quot;&gt;01. 装饰器语法糖&lt;/h2&gt;
&lt;p&gt;如果你接触 Python 有一段时间了的话，想必你对 &lt;code&gt;@&lt;/code&gt; 符号一定不陌生了，没错 &lt;code&gt;@&lt;/code&gt; 符号就是装饰器的语法糖。&lt;/p&gt;
&lt;p&gt;它放在一个函数开始定义的地方，它就像一顶帽子一样戴在这个函数的头上。和这个函数绑定在一起。在我们调用这个函数的时候，第一件事并不是执行这个函数，而是将这个函数做为参数传入它头顶上这顶帽子，这顶帽子我们称之为&lt;code&gt;装饰函数&lt;/code&gt; 或 &lt;code&gt;装饰器&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;你要问我装饰器可以实现什么功能？我只能说你的脑洞有多大，装饰器就有多强大。&lt;/p&gt;
&lt;p&gt;装饰器的使用方法很固定：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;先定义一个装饰函数（帽子）（也可以用类、偏函数实现）&lt;/li&gt;
&lt;li&gt;再定义你的业务函数、或者类（人）&lt;/li&gt;
&lt;li&gt;最后把这顶帽子带在这个人头上&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;装饰器的简单的用法有很多，这里举两个常见的。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;日志打印器&lt;/li&gt;
&lt;li&gt;时间计时器&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;入门用法日志打印器&quot;&gt;02. 入门用法：日志打印器&lt;/h2&gt;
&lt;p&gt;首先是&lt;strong&gt;日志打印器&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;实现的功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在函数执行前，先打印一行日志告知一下主人，我要执行函数了。&lt;/li&gt;
&lt;li&gt;在函数执行完，也不能拍拍屁股就走人了，咱可是有礼貌的代码，再打印一行日志告知下主人，我执行完啦。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 这是装饰函数
def logger(func):
    def wrapper(*args, **kw):
        print('我准备开始计算：{} 函数了:'.format(func.__name__))

        # 真正执行的是这行。
        func(*args, **kw)

        print('啊哈，我计算完啦。给自己加个鸡腿！！')
    return wrapper&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;假如，我的业务函数是，计算两个数之和。写好后，直接给它带上帽子。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;@logger
def add(x, y):
    print('{} + {} = {}'.format(x, y, x+y))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们来计算一下。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;add(200, 50)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;快来看看输出了什么，神奇不？&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;我准备开始计算：add 函数了:
200 + 50 = 250
啊哈，我计算完啦。给自己加个鸡腿！&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;入门用法时间计时器&quot;&gt;03. 入门用法：时间计时器&lt;/h2&gt;
&lt;p&gt;再来看看 &lt;strong&gt;时间计时器&lt;/strong&gt;&lt;br/&gt;实现功能：顾名思义，就是计算一个函数的执行时长。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 这是装饰函数
def timer(func):
    def wrapper(*args, **kw):
        t1=time.time()
        # 这是函数真正执行的地方
        func(*args, **kw)
        t2=time.time()

        # 计算下时长
        cost_time = t2-t1 
        print(&quot;花费时间：{}秒&quot;.format(cost_time))
    return wrapper&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;假如，我们的函数是要睡眠10秒。这样也能更好的看出这个计算时长到底靠不靠谱。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import time

@timer
def want_sleep(sleep_time):
    time.sleep(sleep_time)

want_sleep(10)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;来看看，输出。真的是10秒耶。真历害！！！&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;花费时间：10.0073800086975098秒&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;进阶用法带参数的函数装饰器&quot;&gt;04. 进阶用法：带参数的函数装饰器&lt;/h2&gt;
&lt;p&gt;通过上面简单的入门，你大概已经感受到了装饰的神奇魅力了。&lt;/p&gt;
&lt;p&gt;不过，装饰器的用法远不止如此。我们今天就要把这个知识点讲透。&lt;/p&gt;
&lt;p&gt;上面的例子，装饰器是不能接收参数的。其用法，只能适用于一些简单的场景。不传参的装饰器，只能对被装饰函数，执行固定逻辑。&lt;/p&gt;
&lt;p&gt;如果你有经验，你一定经常在项目中，看到有的装饰器是带有参数的。&lt;/p&gt;
&lt;p&gt;装饰器本身是一个函数，既然做为一个函数都不能携带函数，那这个函数的功能就很受限。只能执行固定的逻辑。这无疑是非常不合理的。而如果我们要用到两个内容大体一致，只是某些地方不同的逻辑。不传参的话，我们就要写两个装饰器。小明觉得这不能忍。&lt;/p&gt;
&lt;p&gt;那么装饰器如何实现&lt;code&gt;传参&lt;/code&gt;呢，会比较复杂，需要两层嵌套。&lt;/p&gt;
&lt;p&gt;同样，我们也来举个例子。&lt;/p&gt;
&lt;p&gt;我们要在这两个函数的执行的时候，分别根据其国籍，来说出一段打招呼的话。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def american():
    print(&quot;我来自中国。&quot;)

def chinese():
    print(&quot;I am from America.&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在给他们俩戴上装饰器的时候，就要跟装饰器说，这个人是哪国人，然后装饰器就会做出判断，打出对应的招呼。&lt;/p&gt;
&lt;p&gt;戴上帽子后，是这样的。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;@say_hello(&quot;china&quot;)
def american():
    print(&quot;我来自中国。&quot;)

@say_hello(&quot;america&quot;)
def chinese():
    print(&quot;I am from America.&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;万事俱备，只差帽子了。来定义一下，这里需要两层嵌套。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def say_hello(contry):
    def wrapper(func):
        def deco(*args, **kwargs):
            if contry == &quot;china&quot;:
                print(&quot;你好!&quot;)
            elif contry == &quot;america&quot;:
                print('hello.')
            else:
                return

            # 真正执行函数的地方
            func(*args, **kwargs)
        return deco
    return wrapper&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行一下&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;american()
print(&quot;------------&quot;)
chinese()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看看输出结果。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;你好!
我来自中国。
------------
hello.
I am from America&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;emmmm，这很NB。。。&lt;/p&gt;
&lt;h2 id=&quot;高阶用法不带参数的类装饰器&quot;&gt;05. 高阶用法：不带参数的类装饰器&lt;/h2&gt;
&lt;p&gt;以上都是基于函数实现的装饰器，在阅读别人代码时，还可以时常发现还有基于类实现的装饰器。&lt;/p&gt;
&lt;p&gt;基于类装饰器的实现，必须实现 &lt;code&gt;__call__&lt;/code&gt; 和 &lt;code&gt;__init__&lt;/code&gt;两个内置函数。&lt;br/&gt;&lt;code&gt;__init__&lt;/code&gt; ：接收被装饰函数&lt;br/&gt;&lt;code&gt;__call__&lt;/code&gt; ：实现装饰逻辑。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class logger(object):
    def __init__(self, func):
        self.func = func

    def __call__(self, *args, **kwargs):
        print(&quot;[INFO]: the function {func}() is running...&quot;\
            .format(func=self.func.__name__))
        return self.func(*args, **kwargs)

@logger
def say(something):
    print(&quot;say {}!&quot;.format(something))

say(&quot;hello&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行一下，看看输出&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[INFO]: the function say() is running...
say hello!&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;高阶用法带参数的类装饰器&quot;&gt;06. 高阶用法：带参数的类装饰器&lt;/h2&gt;
&lt;p&gt;上面不带参数的例子，你发现没有，只能打印&lt;code&gt;INFO&lt;/code&gt;级别的日志，正常情况下，我们还需要打印&lt;code&gt;DEBUG&lt;/code&gt; &lt;code&gt;WARNING&lt;/code&gt;等级别的日志。 这就需要给类装饰器传入参数，给这个函数指定级别了。&lt;/p&gt;
&lt;p&gt;带参数和不带参数的类装饰器有很大的不同。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;__init__&lt;/code&gt; ：不再接收被装饰函数，而是接收传入参数。&lt;br/&gt;&lt;code&gt;__call__&lt;/code&gt; ：接收被装饰函数，实现装饰逻辑。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class logger(object):
    def __init__(self, level='INFO'):
        self.level = level

    def __call__(self, func): # 接受函数
        def wrapper(*args, **kwargs):
            print(&quot;[{level}]: the function {func}() is running...&quot;\
                .format(level=self.level, func=func.__name__))
            func(*args, **kwargs)
        return wrapper  #返回函数

@logger(level='WARNING')
def say(something):
    print(&quot;say {}!&quot;.format(something))

say(&quot;hello&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们指定&lt;code&gt;WARNING&lt;/code&gt;级别，运行一下，来看看输出。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[WARNING]: the function say() is running...
say hello!&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;使用偏函数与类实现装饰器&quot;&gt;07. 使用偏函数与类实现装饰器&lt;/h2&gt;
&lt;p&gt;绝大多数装饰器都是基于函数和闭包实现的，但这并非制造装饰器的唯一方式。&lt;/p&gt;
&lt;p&gt;事实上，Python 对某个对象是否能通过装饰器（ &lt;code&gt;@decorator&lt;/code&gt;）形式使用只有一个要求：&lt;strong&gt;decorator 必须是一个“可被调用（callable）的对象&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;对于这个 callable 对象，我们最熟悉的就是函数了。&lt;/p&gt;
&lt;p&gt;除函数之外，类也可以是 callable 对象，只要实现了&lt;code&gt;__call__&lt;/code&gt; 函数（上面几个盒子已经接触过了），还有比较少人使用的偏函数也是 callable 对象。&lt;/p&gt;
&lt;p&gt;接下来就来说说，如何使用 类和偏函数结合实现一个与众不同的装饰器。&lt;/p&gt;
&lt;p&gt;如下所示，DelayFunc 是一个实现了 &lt;code&gt;__call__&lt;/code&gt; 的类，delay 返回一个偏函数，在这里 delay 就可以做为一个装饰器。（以下代码摘自 Python工匠：使用装饰器的小技巧）&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import time
import functools

class DelayFunc:
    def __init__(self,  duration, func):
        self.duration = duration
        self.func = func

    def __call__(self, *args, **kwargs):
        print(f'Wait for {self.duration} seconds...')
        time.sleep(self.duration)
        return self.func(*args, **kwargs)

    def eager_call(self, *args, **kwargs):
        print('Call without delay')
        return self.func(*args, **kwargs)

def delay(duration):
    &quot;&quot;&quot;
    装饰器：推迟某个函数的执行。
    同时提供 .eager_call 方法立即执行
    &quot;&quot;&quot;
    # 此处为了避免定义额外函数，
    # 直接使用 functools.partial 帮助构造 DelayFunc 实例
    return functools.partial(DelayFunc, duration)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们的业务函数很简单，就是相加&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;@delay(duration=2)
def add(a, b):
    return a+b&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;来看一下执行过程&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; add    # 可见 add 变成了 Delay 的实例
&amp;lt;__main__.DelayFunc object at 0x107bd0be0&amp;gt;
&amp;gt;&amp;gt;&amp;gt; 
&amp;gt;&amp;gt;&amp;gt; add(3,5)  # 直接调用实例，进入 __call__
Wait for 2 seconds...
8
&amp;gt;&amp;gt;&amp;gt; 
&amp;gt;&amp;gt;&amp;gt; add.func # 实现实例方法
&amp;lt;function add at 0x107bef1e0&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;如何写能装饰类的装饰器&quot;&gt;08. 如何写能装饰类的装饰器？&lt;/h2&gt;
&lt;p&gt;用 Python 写单例模式的时候，常用的有三种写法。其中一种，是用装饰器来实现的。&lt;/p&gt;
&lt;p&gt;以下便是我自己写的装饰器版的单例写法。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;instances = {}

def singleton(cls):
    def get_instance(*args, **kw):
        cls_name = cls.__name__
        print('===== 1 ====')
        if not cls_name in instances:
            print('===== 2 ====')
            instance = cls(*args, **kw)
            instances[cls_name] = instance
        return instances[cls_name]
    return get_instance

@singleton
class User:
    _instance = None

    def __init__(self, name):
        print('===== 3 ====')
        self.name = name&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到我们用singleton 这个装饰函数来装饰 User 这个类。装饰器用在类上，并不是很常见，但只要熟悉装饰器的实现过程，就不难以实现对类的装饰。在上面这个例子中，装饰器就只是实现对类实例的生成的控制而已。&lt;/p&gt;
&lt;p&gt;其实例化的过程，你可以参考我这里的调试过程，加以理解。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://image.python-online.cn/20190512113917.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;wrapper-装饰器有啥用&quot;&gt;09. wrapper 装饰器有啥用？&lt;/h2&gt;
&lt;p&gt;在 functools 标准库中有提供一个 wrapper 装饰器，你应该也经常见过，那他有啥用呢？&lt;/p&gt;
&lt;p&gt;先来看一个例子&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def wrapper(func):
    def inner_function():
        pass
    return inner_function

@wrapper
def wrapped():
    pass

print(wrapped.__name__)
#inner_function&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为什么会这样子？不是应该返回 &lt;code&gt;func&lt;/code&gt; 吗？&lt;/p&gt;
&lt;p&gt;这也不难理解，因为上边执行&lt;code&gt;func&lt;/code&gt; 和下边 &lt;code&gt;decorator(func)&lt;/code&gt; 是等价的，所以上面 &lt;code&gt;func.__name__&lt;/code&gt; 是等价于下面&lt;code&gt;decorator(func).__name__&lt;/code&gt; 的，那当然名字是 &lt;code&gt;inner_function&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def wrapper(func):
    def inner_function():
        pass
    return inner_function

def wrapped():
    pass

print(wrapper(wrapped).__name__)
#inner_function&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那如何避免这种情况的产生？方法是使用 functools .wrapper 装饰器，它的作用就是将 &lt;strong&gt;被修饰的函数(wrapped)&lt;/strong&gt; 的一些属性值赋值给 &lt;strong&gt;修饰器函数(wrapper)&lt;/strong&gt; ，最终让属性的显示更符合我们的直觉。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from functools import wraps

def wrapper(func):
    @wraps(func) 
    def inner_function():
        pass
    return inner_function

@wrapper
def wrapped():
    pass

print(wrapped.__name__)
# wrapped&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;准确点说，wrapper 其实是一个偏函数对象（partial），源码如下&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def wraps(wrapped,
          assigned = WRAPPER_ASSIGNMENTS,
          updated = WRAPPER_UPDATES):
    return partial(update_wrapper, wrapped=wrapped,
                   assigned=assigned, updated=updated)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到wraps其实就是调用了一个函数&lt;code&gt;update_wrapper&lt;/code&gt;，知道原理后，我们改写上面的代码，在不使用 wraps的情况下，也可以让 &lt;code&gt;wrapped.__name__&lt;/code&gt; 打印出 wrapped，代码如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from functools import update_wrapper

def wrapper(func):
    def inner_function():
        pass
    update_wrapper(func, inner_function)
    return inner_function

def wrapped():
    pass

print(wrapped.__name__)
# wrapped&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;内置装饰器property&quot;&gt;10. 内置装饰器：property&lt;/h2&gt;
&lt;p&gt;以上，我们介绍的都是自定义的装饰器。&lt;/p&gt;
&lt;p&gt;其实Python语言本身也有一些装饰器。比如&lt;code&gt;property&lt;/code&gt;这个内建装饰器，我们再熟悉不过了。&lt;/p&gt;
&lt;p&gt;它通常存在于类中，可以将一个函数定义成一个属性，属性的值就是该函数return的内容。&lt;/p&gt;
&lt;p&gt;通常我们给实例绑定属性是这样的&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Student(object):
    def __init__(self, name, age=None):
        self.name = name
        self.age = age

# 实例化
XiaoMing = Student(&quot;小明&quot;)

# 添加属性
XiaoMing.age=25

# 查询属性
XiaoMing.age

# 删除属性
del XiaoMing.age&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是稍有经验的开发人员，一下就可以看出，这样直接把属性暴露出去，虽然写起来很简单，但是并不能对属性的值做合法性限制。为了实现这个功能，我们可以这样写。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Student(object):
    def __init__(self, name):
        self.name = name
        self.name = None

    def set_age(self, age):
        if not isinstance(age, int):
            raise ValueError('输入不合法：年龄必须为数值!')
        if not 0 &amp;lt; age &amp;lt; 100:
            raise ValueError('输入不合法：年龄范围必须0-100')
        self._age=age

    def get_age(self):
        return self._age

    def del_age(self):
        self._age = None


XiaoMing = Student(&quot;小明&quot;)

# 添加属性
XiaoMing.set_age(25)

# 查询属性
XiaoMing.get_age()

# 删除属性
XiaoMing.del_age()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码设计虽然可以变量的定义，但是可以发现不管是获取还是赋值（通过函数）都和我们平时见到的不一样。&lt;br/&gt;按照我们思维习惯应该是这样的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 赋值
XiaoMing.age = 25

# 获取
XiaoMing.age&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么这样的方式我们如何实现呢。请看下面的代码。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Student(object):
    def __init__(self, name):
        self.name = name
        self.name = None

    @property
    def age(self):
        return self._age

    @age.setter
    def age(self, value):
        if not isinstance(value, int):
            raise ValueError('输入不合法：年龄必须为数值!')
        if not 0 &amp;lt; value &amp;lt; 100:
            raise ValueError('输入不合法：年龄范围必须0-100')
        self._age=value

    @age.deleter
    def age(self):
        del self._age

XiaoMing = Student(&quot;小明&quot;)

# 设置属性
XiaoMing.age = 25

# 查询属性
XiaoMing.age

# 删除属性
del XiaoMing.age&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用&lt;code&gt;@property&lt;/code&gt;装饰过的函数，会将一个函数定义成一个属性，属性的值就是该函数return的内容。&lt;strong&gt;同时&lt;/strong&gt;，会将这个函数变成另外一个装饰器。就像后面我们使用的&lt;code&gt;@age.setter&lt;/code&gt;和&lt;code&gt;@age.deleter&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;@age.setter&lt;/code&gt; 使得我们可以使用&lt;code&gt;XiaoMing.age = 25&lt;/code&gt;这样的方式直接赋值。&lt;br/&gt;&lt;code&gt;@age.deleter&lt;/code&gt; 使得我们可以使用&lt;code&gt;del XiaoMing.age&lt;/code&gt;这样的方式来删除属性。&lt;/p&gt;
&lt;p&gt;property 的底层实现机制是「描述符」，为此我还写过一篇文章。&lt;/p&gt;
&lt;p&gt;这里也介绍一下吧，正好将这些看似零散的文章全部串起来。&lt;/p&gt;
&lt;p&gt;如下，我写了一个类，里面使用了 property 将 math 变成了类实例的属性&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Student:
    def __init__(self, name):
        self.name = name

    @property
    def math(self):
        return self._math

    @math.setter
    def math(self, value):
        if 0 &amp;lt;= value &amp;lt;= 100:
            self._math = value
        else:
            raise ValueError(&quot;Valid value must be in [0, 100]&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为什么说 property 底层是基于描述符协议的呢？通过 PyCharm 点击进入 property 的源码，很可惜，只是一份类似文档一样的伪源码，并没有其具体的实现逻辑。&lt;/p&gt;
&lt;p&gt;不过，从这份伪源码的魔法函数结构组成，可以大体知道其实现逻辑。&lt;/p&gt;
&lt;p&gt;这里我自己通过模仿其函数结构，结合「描述符协议」来自己实现类 &lt;code&gt;property&lt;/code&gt; 特性。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class TestProperty(object):

    def __init__(self, fget=None, fset=None, fdel=None, doc=None):
        self.fget = fget
        self.fset = fset
        self.fdel = fdel
        self.__doc__ = doc

    def __get__(self, obj, objtype=None):
        print(&quot;in __get__&quot;)
        if obj is None:
            return self
        if self.fget is None:
            raise AttributeError
        return self.fget(obj)

    def __set__(self, obj, value):
        print(&quot;in __set__&quot;)
        if self.fset is None:
            raise AttributeError
        self.fset(obj, value)

    def __delete__(self, obj):
        print(&quot;in __delete__&quot;)
        if self.fdel is None:
            raise AttributeError
        self.fdel(obj)


    def getter(self, fget):
        print(&quot;in getter&quot;)
        return type(self)(fget, self.fset, self.fdel, self.__doc__)

    def setter(self, fset):
        print(&quot;in setter&quot;)
        return type(self)(self.fget, fset, self.fdel, self.__doc__)

    def deleter(self, fdel):
        print(&quot;in deleter&quot;)
        return type(self)(self.fget, self.fset, fdel, self.__doc__)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后 Student 类，我们也相应改成如下&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Student:
    def __init__(self, name):
        self.name = name

    # 其实只有这里改变
    @TestProperty
    def math(self):
        return self._math

    @math.setter
    def math(self, value):
        if 0 &amp;lt;= value &amp;lt;= 100:
            self._math = value
        else:
            raise ValueError(&quot;Valid value must be in [0, 100]&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了尽量让你少产生一点疑惑，我这里做两点说明：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;使用&lt;code&gt;TestProperty&lt;/code&gt;装饰后，&lt;code&gt;math&lt;/code&gt; 不再是一个函数，而是&lt;code&gt;TestProperty&lt;/code&gt; 类的一个实例。所以第二个math函数可以使用 &lt;code&gt;math.setter&lt;/code&gt; 来装饰，本质是调用&lt;code&gt;TestProperty.setter&lt;/code&gt; 来产生一个新的 &lt;code&gt;TestProperty&lt;/code&gt; 实例赋值给第二个&lt;code&gt;math&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;第一个 &lt;code&gt;math&lt;/code&gt; 和第二个 &lt;code&gt;math&lt;/code&gt; 是两个不同 &lt;code&gt;TestProperty&lt;/code&gt; 实例。但他们都属于同一个描述符类（TestProperty），当对 math 对于赋值时，就会进入 &lt;code&gt;TestProperty.__set__&lt;/code&gt;，当对math 进行取值里，就会进入 &lt;code&gt;TestProperty.__get__&lt;/code&gt;。仔细一看，其实最终访问的还是Student实例的 &lt;code&gt;_math&lt;/code&gt; 属性。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;说了这么多，还是运行一下，更加直观一点。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 运行后，会直接打印这一行，这是在实例化 TestProperty 并赋值给第二个math
in setter
&amp;gt;&amp;gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; s1.math = 90
in __set__
&amp;gt;&amp;gt;&amp;gt; s1.math
in __get__
90&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如对上面代码的运行原理，有疑问的同学，请务必结合上面两点说明加以理解，那两点相当关键。&lt;/p&gt;
&lt;h2 id=&quot;其他装饰器装饰器实战&quot;&gt;11. 其他装饰器：装饰器实战&lt;/h2&gt;
&lt;p&gt;读完并理解了上面的内容，你可以说是Python高手了。别怀疑，自信点，因为很多人都不知道装饰器有这么多用法呢。&lt;/p&gt;
&lt;p&gt;在我看来，使用装饰器，可以达到如下目的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使代码可读性更高，逼格更高；&lt;/li&gt;
&lt;li&gt;代码结构更加清晰，代码冗余度更低；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;刚好我在最近也有一个场景，可以用装饰器很好的实现，暂且放上来看看。&lt;/p&gt;
&lt;p&gt;这是一个实现控制函数运行超时的装饰器。如果超时，则会抛出超时异常。&lt;/p&gt;
&lt;p&gt;有兴趣的可以看看。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import signal

class TimeoutException(Exception):
    def __init__(self, error='Timeout waiting for response from Cloud'):
        Exception.__init__(self, error)


def timeout_limit(timeout_time):
    def wraps(func):
        def handler(signum, frame):
            raise TimeoutException()

        def deco(*args, **kwargs):
            signal.signal(signal.SIGALRM, handler)
            signal.alarm(timeout_time)
            func(*args, **kwargs)
            signal.alarm(0)
        return deco
    return wraps&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;http://image.python-online.cn/20190511161447.png&quot; alt=&quot;关注公众号，获取最新干货！&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 27 May 2019 15:38:00 +0000</pubDate>
<dc:creator>站在两个世界的边缘</dc:creator>
<og:description>一文搞懂 Python 中装饰器的所有用法</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wongbingming/p/10934356.html</dc:identifier>
</item>
<item>
<title>搞懂ZooKeeper的Watcher之源码分析及特性总结 - GrimMjx</title>
<link>http://www.cnblogs.com/GrimMjx/p/10922480.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/GrimMjx/p/10922480.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;　　本章讲ZooKeeper重要的机制，Watcher特性。&lt;span&gt;ZooKeeper允许客户端向服务端注册Watcher监听，当服务端一些指定事件触发了这个Watcher，那么就会向指定客户端发送一个事件通知客户端执行回调逻辑&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;一.Watcher机制&lt;/h2&gt;
&lt;p&gt;　　ZooKeeper允许客户端向服务端注册感兴趣的Watcher监听，当服务端触发了这个Watcher，那么就会向客户端发送一个时间来实现分布式的通知功能。真正的Watcher回调与业务逻辑执行都在客户端&lt;/p&gt;
&lt;p&gt;　　那么需要注意一下，&lt;span&gt;给客户端的通知里只会告诉你通知状态（KeeperState），事件类型（EventType）和路径（Path）。&lt;span&gt;&lt;strong&gt;不会告诉你原始数据和更新过后的数据！&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　Watcher机制包括三部分：&lt;span&gt;注册、存储、通知&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;注册：注册Watcher&lt;/li&gt;
&lt;li&gt;存储：讲Watcher对象存在客户端的WatcherManager中&lt;/li&gt;
&lt;li&gt;通知：服务端触发Watcher事件，通知客户端，客户端从WatcherManager中取出对应的Watcher对象执行回调 &lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1465200/201905/1465200-20190525152451939-1359939836.png&quot; alt=&quot;&quot; width=&quot;746&quot; height=&quot;527&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　那么接下来，我们就分这3步来分析：&lt;/p&gt;
&lt;h3&gt;注册&lt;/h3&gt;
&lt;p&gt;　　我们可以通过以下方式向服务端注册Watcher，主要是构造参数、getData、getChildren和exists方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; ZooKeeper(String connectString, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; sessionTimeout, Watcher watcher)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] getData(String path, Watcher watcher, Stat stat)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;String&amp;gt;&lt;span&gt; getChildren(String path, Watcher watcher)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Stat exists(String path, Watcher watcher)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我们就看getData方法，从源码角度看看如何注册的，可以看到首先封装了一个WatchRegistration对象，保存了节点的路径和Watcher对象的关系，然后在请求的request设置了是否有watcher这么一个boolean的成员变量：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] getData(String path, Watcher &lt;span&gt;watcher&lt;/span&gt;, Stat stat) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; KeeperException, InterruptedException {
    PathUtils.validatePath(path);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 封装一个WatcherRegistration的对象，保存节点路径和Watcher的对应关系&lt;/span&gt;
    ZooKeeper.WatchRegistration &lt;span&gt;wcb&lt;/span&gt; = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;watcher&lt;/span&gt; != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        &lt;span&gt;wcb &lt;/span&gt;&lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ZooKeeper.DataWatchRegistration(watcher, path);
    }
    String serverPath &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.prependChroot(path);
    RequestHeader h &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RequestHeader();
    h.setType(&lt;/span&gt;4&lt;span&gt;);
    GetDataRequest request &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; GetDataRequest();
    request.setPath(serverPath);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 标记是否有watcher&lt;/span&gt;
    request.setWatch(&lt;span&gt;watcher&lt;/span&gt; != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
    GetDataResponse response &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; GetDataResponse();
    ReplyHeader r &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.cnxn.submitRequest(h, request, response, &lt;span&gt;wcb&lt;/span&gt;);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (r.getErr() != 0&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; KeeperException.create(Code.get(r.getErr()), path);
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (stat != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            DataTree.copyStat(response.getStat(), stat);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; response.getData();
    }
}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; DataWatchRegistration &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; ZooKeeper.WatchRegistration {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 保存节点路径和Watcher的关系&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; DataWatchRegistration(Watcher watcher, String clientPath) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(watcher, clientPath);
    }

    ...
}

&lt;/span&gt;&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WatchRegistration {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Watcher watcher;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String clientPath;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; WatchRegistration(Watcher watcher, String clientPath) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.watcher =&lt;span&gt; watcher;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.clientPath =&lt;span&gt; clientPath;
    }
    ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后我们继续接着看这个wcb变量做了什么（已经用&lt;span&gt;紫色&lt;/span&gt;标注该变量），简单来说就是这个变量被封装在了packet对象里，packet可以看成一个最小的通信协议单元，传输信息。最后将packet对象放到了发送队列里&lt;span&gt;SendThread&lt;span&gt;里&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; ReplyHeader submitRequest(RequestHeader h, Record request, Record response, WatchRegistration &lt;span&gt;watchRegistration&lt;/span&gt;) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
    ReplyHeader r &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReplyHeader();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 客户端与服务端的网络传输&lt;/span&gt;
    ClientCnxn.Packet packet = &lt;span&gt;this&lt;/span&gt;.queuePacket(h, r, request, response, (AsyncCallback)&lt;span&gt;null&lt;/span&gt;, (String)&lt;span&gt;null&lt;/span&gt;, (String)&lt;span&gt;null&lt;/span&gt;, (Object)&lt;span&gt;null&lt;/span&gt;&lt;span&gt;, &lt;span&gt;watchRegistration&lt;/span&gt;);
    &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt;(packet) {
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(!&lt;span&gt;packet.finished) {
            packet.wait();
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; r;
    }
}

ClientCnxn.Packet queuePacket(RequestHeader h, ReplyHeader r, Record request, Record response, AsyncCallback cb, String clientPath, String serverPath, Object ctx, WatchRegistration &lt;span&gt;watchRegistration&lt;/span&gt;) {
    ClientCnxn.Packet packet &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    LinkedList var11 &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.outgoingQueue;
    &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.outgoingQueue) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 任何传输的对象都包装成Packet对象&lt;/span&gt;
        packet = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ClientCnxn.Packet(h, r, request, response, &lt;span&gt;watchRegistration&lt;/span&gt;);
        packet.cb &lt;/span&gt;=&lt;span&gt; cb;
        packet.ctx &lt;/span&gt;=&lt;span&gt; ctx;
        packet.clientPath &lt;/span&gt;=&lt;span&gt; clientPath;
        packet.serverPath &lt;/span&gt;=&lt;span&gt; serverPath;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.state.isAlive() &amp;amp;&amp;amp; !&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.closing) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (h.getType() == -11&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.closing = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 放入发送队列中，等待发送&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.outgoingQueue.add(packet);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.conLossPacket(packet);
        }
    }

    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.sendThread.getClientCnxnSocket().wakeupCnxn();
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; packet;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后我们看org.apache.zookeeper.ClientCnxnSocketNIO#doIO这个方法，关键代码已经用红色标注出来了，从要发送的队列outgoingQueue中取出packet然后序列化到底层数组，&lt;span&gt;注意了，这里没有序列化前面说的WatchRegistration对象，只序列化了requestHeader和request两个属性，也就是说，&lt;span&gt;&lt;strong&gt;服务端并不会接收到阶段路径和watcher对象的关系，回调的业务逻辑代码也不会给服务端！&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; doIO(List&amp;lt;Packet&amp;gt; pendingQueue, LinkedList&amp;lt;Packet&amp;gt; outgoingQueue, ClientCnxn cnxn) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException, IOException {
    SocketChannel sock &lt;/span&gt;= (SocketChannel)&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.sockKey.channel();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sock == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IOException(&quot;Socket is null!&quot;&lt;span&gt;);
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 是否可读&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.sockKey.isReadable()) {
            ...
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.sockKey.isWritable()) {
            &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt;(outgoingQueue) {
                &lt;span&gt;Packet p &lt;/span&gt;&lt;/span&gt;&lt;span&gt;= this.findSendablePacket(outgoingQueue, cnxn.sendThread.clientTunneledAuthenticationInProgress());
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (p != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.updateLastSend();
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (p.bb == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (p.requestHeader != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; p.requestHeader.getType() != 11 &amp;amp;&amp;amp; p.requestHeader.getType() != 100&lt;span&gt;) {
                            p.requestHeader.setXid(cnxn.getXid());
                        }

                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 序列化&lt;/span&gt;
&lt;span&gt;&lt;span&gt;                        p.createBB();&lt;/span&gt;
                    }
                    
                    &lt;span&gt;sock.write(p.bb);&lt;/span&gt;
                    ...
                }

                ...
            }
        }
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; createBB() {
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        ByteArrayOutputStream baos &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ByteArrayOutputStream();
        BinaryOutputArchive boa &lt;/span&gt;=&lt;span&gt; BinaryOutputArchive.getArchive(baos);
        boa.writeInt(&lt;/span&gt;-1, &quot;len&quot;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 序列化header&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.requestHeader != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;this.requestHeader.serialize(boa, &quot;header&quot;&lt;/span&gt;&lt;span&gt;&lt;span&gt;);&lt;/span&gt;
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.request &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; ConnectRequest) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.request.serialize(boa, &quot;connect&quot;&lt;span&gt;);
            boa.writeBool(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.readOnly, &quot;readOnly&quot;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 序列化request&lt;/span&gt;
        } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.request != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;this.request.serialize(boa, &quot;request&quot;&lt;/span&gt;&lt;span&gt;&lt;span&gt;);&lt;/span&gt;
        }
        baos.close();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.bb =&lt;span&gt; ByteBuffer.wrap(baos.toByteArray());
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.bb.putInt(&lt;span&gt;this&lt;/span&gt;.bb.capacity() - 4&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.bb.rewind();
    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException var3) {
        ClientCnxn.LOG.warn(&lt;/span&gt;&quot;Ignoring unexpected exception&quot;&lt;span&gt;, var3);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;存储&lt;/h3&gt;
&lt;p&gt;　　上面都是客户端发起请求的过程，那么接下来我们看服务端接收到请求会做些什么，&lt;span&gt;ZooKeeper的服务端对于客户端的请求，采用了典型的责任链模式&lt;/span&gt;，也就是说客户端的每个请求都由几个不同的处理器来依次进行处理，我们这里就看这个方法:org.apache.zookeeper.server.FinalRequestProcessor#processRequest&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; processRequest(Request request) {
    ...
    PrepRequestProcessor.checkACL(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.zks, &lt;span&gt;this&lt;/span&gt;.zks.getZKDatabase().convertLong(aclG), 1&lt;span&gt;, request.authInfo);
    Stat stat &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Stat();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里根据客户端设置的是否有watch变量来传入watcher对象
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果true则将当前的ServerCnxn传入（ServerCnxn代表客户端和服务端的连接）&lt;/span&gt;
    &lt;span&gt;byte&lt;/span&gt;[] b = &lt;span&gt;this&lt;/span&gt;.zks.getZKDatabase().getData(getDataRequest.getPath(), stat, getDataRequest.getWatch() ? cnxn : &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
    rsp &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; GetDataResponse(b, stat);
    ...
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] getData(String path, Stat stat, Watcher watcher) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; NoNodeException {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.dataTree.getData(path, stat, watcher);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　紧接着，将数据节点路径和ServerCnxn对象存储在&lt;span&gt;WatcherManager的watchTable和watch2Paths中。前者是路径维度，后者是Watcher维度&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] getData(String path, Stat stat, Watcher watcher) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; NoNodeException {
    DataNode n &lt;/span&gt;= (DataNode)&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.nodes.get(path);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (n == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NoNodeException();
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt;(n) {
            n.copyStat(stat);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (watcher != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加watcher&lt;/span&gt;
                &lt;span&gt;this&lt;/span&gt;&lt;span&gt;&lt;span&gt;.dataWatches.addWatch(path, watcher);&lt;/span&gt;
            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; n.data;
        }
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addWatch(String path, Watcher watcher) {
    HashSet&lt;/span&gt;&amp;lt;Watcher&amp;gt; list = (HashSet)&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.watchTable.get(path);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (list == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        list &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; HashSet(4&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;&lt;span&gt;.watchTable.put(path, list);&lt;/span&gt;
    }

    list.add(watcher);
    HashSet&lt;/span&gt;&amp;lt;String&amp;gt; paths = (HashSet)&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.watch2Paths.get(watcher);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (paths == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        paths &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HashSet();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;&lt;span&gt;.watch2Paths.put(watcher, paths);&lt;/span&gt;
    }

   &lt;span&gt; paths.add(path);&lt;/span&gt;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 路径维度&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; HashMap&amp;lt;String, HashSet&amp;lt;Watcher&amp;gt;&amp;gt; watchTable = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HashMap();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Watcher维度&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; HashMap&amp;lt;Watcher, HashSet&amp;lt;String&amp;gt;&amp;gt; watch2Paths = &lt;span&gt;new&lt;/span&gt; HashMap();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　当服务端处理完毕之后，&lt;span&gt;客户端的SendThread线程负责接收服务端的响应，finishPacket方法会从packet中取出WatchRegistration并注册到ZKWatchManager中：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; finishPacket(ClientCnxn.Packet p) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 客户端注册wathcer&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (p.watchRegistration != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;span&gt;        p.watchRegistration.register(p.replyHeader.getErr());&lt;/span&gt;
    }

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (p.cb == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt;(p) {
            p.finished &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            p.notifyAll();
        }
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        p.finished &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.eventThread.queuePacket(p);
    }

}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; register(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; rc) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.shouldAddWatch(rc)) {
        Map&lt;/span&gt;&amp;lt;String, Set&amp;lt;Watcher&amp;gt;&amp;gt; watches = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getWatches(rc);
        &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt;(watches) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据路径拿到&lt;/span&gt;
            Set&amp;lt;Watcher&amp;gt; watchers = (Set)watches.get(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.clientPath);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (watchers == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                watchers &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HashSet();
               &lt;span&gt; watches.put(&lt;/span&gt;&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;&lt;span&gt;.clientPath, watchers);&lt;/span&gt;
            }

            &lt;span&gt;((Set)watchers).add(&lt;/span&gt;&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;&lt;span&gt;.watcher);&lt;/span&gt;
        }
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;通知&lt;/h3&gt;
&lt;p&gt; 　　当服务端对应的数据节点内容发生改变，那么会触发watcher，对应的代码在org.apache.zookeeper.server.DataTree#setData&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; Stat setData(String path, &lt;span&gt;byte&lt;/span&gt;[] data, &lt;span&gt;int&lt;/span&gt; version, &lt;span&gt;long&lt;/span&gt; zxid, &lt;span&gt;long&lt;/span&gt; time) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; NoNodeException {
    Stat s &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Stat();
    DataNode n &lt;/span&gt;= (DataNode)&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.nodes.get(path);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (n == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NoNodeException();
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] lastdata = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] lastdata;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 赋值node&lt;/span&gt;
        &lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt;(n) {
            lastdata &lt;/span&gt;=&lt;span&gt; n.data;
            n.data &lt;/span&gt;=&lt;span&gt; data;
            n.stat.setMtime(time);
            n.stat.setMzxid(zxid);
            n.stat.setVersion(version);
            n.copyStat(s);
        }

        String lastPrefix;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((lastPrefix = &lt;span&gt;this&lt;/span&gt;.getMaxPrefixWithQuota(path)) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.updateBytes(lastPrefix, (&lt;span&gt;long&lt;/span&gt;)((data == &lt;span&gt;null&lt;/span&gt; ? 0 : data.length) - (lastdata == &lt;span&gt;null&lt;/span&gt; ? 0&lt;span&gt; : lastdata.length)));
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 触发watcher&lt;/span&gt;
        &lt;span&gt;this.dataWatches.triggerWatch(path, EventType.NodeDataChanged);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; s;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　触发watcher，&lt;span&gt;从watchTable和watch2Paths中移除该路径的watcher。这里可以看出，Watcher在服务端是&lt;span&gt;&lt;strong&gt;一次性&lt;/strong&gt;&lt;/span&gt;的，触发一次就失效了&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; Set&amp;lt;Watcher&amp;gt;&lt;span&gt; triggerWatch(String path, EventType type) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.triggerWatch(path, type, (Set)&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Set&amp;lt;Watcher&amp;gt; triggerWatch(String path, EventType type, Set&amp;lt;Watcher&amp;gt;&lt;span&gt; supress) {
    WatchedEvent e &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WatchedEvent(type, KeeperState.SyncConnected, path);
    HashSet watchers;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这个同步代码块主要做的就是从watchTable和watch2Paths中移除该路径的watcher&lt;/span&gt;
    &lt;span&gt;synchronized&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;) {
        &lt;span&gt;watchers &lt;/span&gt;&lt;/span&gt;&lt;span&gt;= (HashSet)this.watchTable.remove(path);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (watchers == &lt;span&gt;null&lt;/span&gt; ||&lt;span&gt; watchers.isEmpty()) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (LOG.isTraceEnabled()) {
                ZooTrace.logTraceMessage(LOG, &lt;/span&gt;64L, &quot;No watchers for &quot; +&lt;span&gt; path);
            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }

        Iterator i$ &lt;/span&gt;=&lt;span&gt; watchers.iterator();

        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt;(i$.hasNext()) {
            Watcher w &lt;/span&gt;=&lt;span&gt; (Watcher)i$.next();
            HashSet&lt;/span&gt;&amp;lt;String&amp;gt; paths = (HashSet)&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.watch2Paths.get(w);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (paths != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;span&gt;paths.remove(path);&lt;/span&gt;
            }
        }
    }

    Iterator i$ &lt;/span&gt;=&lt;span&gt; watchers.iterator();

    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
        Watcher w;
        &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;i$.hasNext()) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; watchers;
            }

            w &lt;/span&gt;=&lt;span&gt; (Watcher)i$.next();
        } &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(supress != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; supress.contains(w));

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; watcher调用，这里的e对象里只有通知状态（KeeperState）、事件类型（EventType）以及节点路径（Path）
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 没有修改过后的新值也没有老的值&lt;/span&gt;
&lt;span&gt;&lt;span&gt;        w.process(e);&lt;/span&gt;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　最后看一下process方法里，其实做的事情就是把事件发送给客户端，所以我们可以看出，真正的回调和业务逻辑执行都在客户端org.apache.zookeeper.server.NIOServerCnxn#process：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; process(WatchedEvent event) {&lt;br/&gt;&lt;span&gt; 　　// 请求头标记-1，表明是通知&lt;/span&gt;
    ReplyHeader h &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ReplyHeader(-1, -1L, 0&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (LOG.isTraceEnabled()) {
        ZooTrace.logTraceMessage(LOG, &lt;/span&gt;64L, &quot;Deliver event &quot; + event + &quot; to 0x&quot; + Long.toHexString(&lt;span&gt;this&lt;/span&gt;.sessionId) + &quot; through &quot; + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
    }

    WatcherEvent e &lt;/span&gt;=&lt;span&gt; event.getWrapper();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 发送通知&lt;/span&gt;
    &lt;span&gt;this.sendResponse(h, e, &quot;notification&quot;&lt;/span&gt;&lt;span&gt;&lt;span&gt;);&lt;/span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　客户端收到该通知，由org.apache.zookeeper.ClientCnxn.SendThread#readResponse处理，主要做的就是反序列化然后交给EventThread线程&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; readResponse(ByteBuffer incomingBuffer) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
    ...
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果是通知&lt;/span&gt;
    } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (replyHdr.getXid() == -1&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ClientCnxn.LOG.isDebugEnabled()) {
            ClientCnxn.LOG.debug(&lt;/span&gt;&quot;Got notification sessionid:0x&quot; + Long.toHexString(ClientCnxn.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.sessionId));
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 反序列化&lt;/span&gt;
        WatcherEvent event = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WatcherEvent();
        event.deserialize(bbia, &lt;/span&gt;&quot;response&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ClientCnxn.&lt;span&gt;this&lt;/span&gt;.chrootPath != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            String serverPath &lt;/span&gt;=&lt;span&gt; event.getPath();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (serverPath.compareTo(ClientCnxn.&lt;span&gt;this&lt;/span&gt;.chrootPath) == 0&lt;span&gt;) {
                event.setPath(&lt;/span&gt;&quot;/&quot;&lt;span&gt;);
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (serverPath.length() &amp;gt; ClientCnxn.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.chrootPath.length()) {
                event.setPath(serverPath.substring(ClientCnxn.&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.chrootPath.length()));
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                ClientCnxn.LOG.warn(&lt;/span&gt;&quot;Got server path &quot; + event.getPath() + &quot; which is too short for chroot path &quot; + ClientCnxn.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.chrootPath);
            }
        }

        WatchedEvent we &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WatchedEvent(event);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ClientCnxn.LOG.isDebugEnabled()) {
            ClientCnxn.LOG.debug(&lt;/span&gt;&quot;Got &quot; + we + &quot; for sessionid 0x&quot; + Long.toHexString(ClientCnxn.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.sessionId));
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 交给EventThread线程处理&lt;/span&gt;
        &lt;span&gt;ClientCnxn.this&lt;/span&gt;&lt;span&gt;&lt;span&gt;.eventThread.queueEvent(we);&lt;/span&gt;
    } 
    ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后从之前注册的ZKWatcherManager中获取到所有该路径的watcher，注意了，客户端的Watcher机制也是一次性的！&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; queueEvent(WatchedEvent event) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (event.getType() != EventType.None || &lt;span&gt;this&lt;/span&gt;.sessionState !=&lt;span&gt; event.getState()) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sessionState =&lt;span&gt; event.getState();
        ClientCnxn.WatcherSetEventPair pair &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ClientCnxn.WatcherSetEventPair(ClientCnxn.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.watcher.&lt;span&gt;materialize&lt;/span&gt;(event.getState(), event.getType(), event.getPath()), event);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.waitingEvents.add(pair);
    }
}


&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Set&amp;lt;Watcher&amp;gt;&lt;span&gt; materialize(KeeperState state, EventType type, String clientPath) {
    ...
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 把该路径下的所有Watcher都拿出来
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; remove方法，所以客户端也是一次性的，一旦触发，watcher就失效了&lt;/span&gt;
    &lt;span&gt;case&lt;/span&gt;&lt;span&gt; NodeDataChanged:
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; NodeCreated:
        var6 &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.dataWatches;
        &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.dataWatches) {
            &lt;/span&gt;&lt;span&gt;this.addTo((Set)this&lt;/span&gt;&lt;span&gt;&lt;span&gt;.dataWatches.remove(clientPath), result);&lt;/span&gt;
        }

        var6 &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.existWatches;
        &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.existWatches) {
            &lt;/span&gt;&lt;span&gt;this.addTo((Set)this.existWatches.remove(clientPath), result);
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
    ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　最后EventThread会从waitingEvents队列中取出Watcher并执行串行化同步处理。看一下这个方法：org.apache.zookeeper.ClientCnxn.EventThread#processEvent&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; processEvent(Object event) {
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (event &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; ClientCnxn.WatcherSetEventPair) {
             ClientCnxn.WatcherSetEventPair pair &lt;/span&gt;=&lt;span&gt; (ClientCnxn.WatcherSetEventPair)event;
             Iterator i$ &lt;/span&gt;=&lt;span&gt; pair.watchers.iterator();
  
             &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt;(i$.hasNext()) {
             
                 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里的watcher就是客户端传入的watcher，里面有真正的回调逻辑代码&lt;/span&gt;
                &lt;span&gt;Watcher watcher = (Watcher)i$.next();
 
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    &lt;span&gt;watcher.process(pair.event);&lt;/span&gt;
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable var7) {
                    ClientCnxn.LOG.error(&lt;/span&gt;&quot;Error while calling watcher &quot;&lt;span&gt;, var7);
                }
             }
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        ...
    }
    ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　嗯，就是这样，走完了，从网上找到一张图，我觉得画的很不错。以上三步骤，注册，存储，通知可以结合这张图来看，最好请打开原图来看：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1465200/201905/1465200-20190527233624890-1044105279.png&quot; alt=&quot;&quot; width=&quot;2974&quot; height=&quot;2362&quot;/&gt;&lt;/p&gt;


&lt;h2&gt;三.总结&lt;/h2&gt;
&lt;h3&gt;Watcher特性总结&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;一次性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　无论客户端还是服务端，一旦watcher被触发，都会被移除&lt;/p&gt;
&lt;p&gt;&lt;span&gt;客户端串行执行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　从源码也看到了，watcher回调是串行同步化执行过程，注意不要一个watcher中放很多处理逻辑造成影响别的watcher回调&lt;/p&gt;
&lt;p&gt;&lt;span&gt;性能轻量&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　注册watcher把watcher对象传给服务端，回调的时候并不会告诉节点的具体变化前后的内容。非常轻量　　&lt;/p&gt;
&lt;p&gt;&lt;span&gt;时效&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　发生CONNECTIONLOSS之后，只要在session_timeout之内再次连接上（即不发生SESSIONEXPIRED），那么这个连接注册的watches依然在。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;节点通知&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;guava to java is Curator to ZooKeeper，开源客户端Curator引入Cache实现对服务端事件的监听，从而大大简化了原生API开发的繁琐过程。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;span&gt;虽然我们可以通过Curator或者ZKClient避免每次要watcher注册的痛苦，&lt;span&gt;&lt;strong&gt;但是我们无法保证在节点更新频率很高的情况下客户端能收到每一次节点变化的通知&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　原因在于：当一次数据修改，通知客户端，客户端再次注册watch，在这个过程中，可能数据已经发生了许多次数据修改&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;h3&gt;&lt;span&gt;&lt;span&gt;参考：&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;偷来的图：&lt;a href=&quot;https://blog.csdn.net/huyangyamin/article/details/77743624&quot;&gt;https://blog.csdn.net/huyangyamin/article/details/77743624&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 27 May 2019 15:34:00 +0000</pubDate>
<dc:creator>GrimMjx</dc:creator>
<og:description>前言 本章讲ZooKeeper重要的机制，Watcher特性。ZooKeeper允许客户端向服务端注册Watcher监听，当服务端一些指定事件触发了这个Watcher，那么就会向指定客户端发送一个事件</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/GrimMjx/p/10922480.html</dc:identifier>
</item>
<item>
<title>数据库扩展表设计过程记录 - 微笑刺客D</title>
<link>http://www.cnblogs.com/CKExp/p/10919740.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CKExp/p/10919740.html</guid>
<description>&lt;p&gt;　　&lt;strong&gt;这两天需要实现一个动态表单设计，面对着属性的不确定，要能够容纳不同的属性进来，之前也接触过这方面的设计，但是没有设计好，导致问题太多，这一次参考一些前辈们的经验后，再次尝试一番，通过动态设计表结构，以达到任务要求。&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;一、常用动态表结构设计方式&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　1、动态修改表，适应变化。&lt;/p&gt;
&lt;p&gt;　　2、预留字段实现动态表结构(伪动态)。&lt;/p&gt;
&lt;p&gt;　　3、将动态属性全部保存在一个字段中，xml或是json格式保存(版本号+通用列)。&lt;/p&gt;
&lt;p&gt;　　4、表结构和表数据分离，xml形式分别保存表结构和表数据。&lt;/p&gt;
&lt;p&gt;　　5、横向表转纵向表(属性字段行存储)。&lt;/p&gt;
&lt;p&gt;　　对于这几种方式，或许不同的选用适用不同的形式，我选择了最后一种来实现我现有的设计，这种方式个人感觉更加灵活，可以更方便的扩展属性(适合的才是最好的)。&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;二、横向表转纵向表初步设计&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　首先看下横向表的设计，如果采用横向表，因为业务的需要，要容纳好几种行业的信息进来，这样一来整张表的字段数将会非常多，从设计或是维护角度来讲，这都是一个棘手的芋头，因此传统的横向表设计不能满足现有的需求了。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201905/1133736-20190527215318636-1434148158.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　按照横向表转纵向表的思路对表结构进行更改，通过设置成键值对形式，得到如下表结构。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201905/1133736-20190527220659802-1847602494.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　在这里可能有一个情况得想清楚了，我们每一次增加一条记录的时候，记录内的信息是作为同一批添加进来的，反过来，当我从数据库中取出数据时，也应该需要把同一批的记录信息取出来，因此在上面的设计中再加入一个GroupId用来区分同一批次的数据，而至于属性的重复量很大，之后将进行优化处理。&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201905/1133736-20190527220718218-1926552670.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　现在看到这个结构时，对于动态扩充属性来讲，已经是达到了我的预期了，对于数据库设计时，将检测指标及限值均设置成字符串的，分组号我采用时间戳的形式进行存储，当然也可以采用其它更为稳妥的方式，如Guid或是自定义ID等。&lt;/p&gt;
&lt;p&gt;　　对于好多检测指标名称出现重复情况，我将这部分单独抽出来一张表用于存储检测指标属性，需要注意的是此处的名称需要在某个检测项目编号下唯一，该部分属性先在界面上呈现，其次呈现对应的数据，如果某列增加或删除了，对应展示行也就空着了一个数据或是消失了一个数据单元，而对于改了指标名称或是对外的展示名称，都不会影响数据的存储，通过默认值可以使得有些常用值不要再二次输入，减少工作量。&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201905/1133736-20190527221138968-1619935917.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在具体检测限值中完成对检测指标的关联，加入一列完成外键关联，同时对原有表内存在的列可以进行优化，因为这些信息都在检测指标中存在了，不必要的数据冗余还是不存在为好。单从现在的表结构来看，当我们按照在增加一些额外的属性时，可以做到不要去修改表结构，而只需要对表内数据进行管理即可。&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201905/1133736-20190527221700790-1157804374.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;&lt;span&gt;三、代码实现过程&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　此处我采用Asp.Net Core MVC并利用Razor语法，更为方便的完成表单展示工作，当然对于这部分工作，采用js或模板等等都是可以快速完成的。&lt;/p&gt;
&lt;p&gt;　　1、首先对于界面添加检测指标的设计，遵循普通的表单设计方式即可，此处增加了两个隐藏元素，为适用于编辑场景而存在，此处快速略过提交到后台并保存到数据库的过程，可能需要在后台验证提交的名称的唯一性。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;layui-fluid&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;layui-form&quot;&lt;/span&gt;&lt;span&gt; lay-filter&lt;/span&gt;&lt;span&gt;=&quot;layuiadmin-form-evaluationIndex&quot;&lt;/span&gt;&lt;span&gt; style&lt;/span&gt;&lt;span&gt;=&quot;padding: 15px 0 0 0;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;hidden&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;id&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;@Model.Id&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;hidden&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;evaluationStandardId&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;@Model.EvaluationStandardId&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;layui-form-item&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;layui-form-label&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;名称&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;layui-input-block&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;name&quot;&lt;/span&gt;&lt;span&gt; lay-verify&lt;/span&gt;&lt;span&gt;=&quot;required&quot;&lt;/span&gt;&lt;span&gt; placeholder&lt;/span&gt;&lt;span&gt;=&quot;请输入名称&quot;&lt;/span&gt;&lt;span&gt; autocomplete&lt;/span&gt;&lt;span&gt;=&quot;off&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;layui-input&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;layui-form-item&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;layui-form-label&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;显示名称&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;layui-input-block&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;displayName&quot;&lt;/span&gt;&lt;span&gt; lay-verify&lt;/span&gt;&lt;span&gt;=&quot;required&quot;&lt;/span&gt;&lt;span&gt; placeholder&lt;/span&gt;&lt;span&gt;=&quot;请输入显示名称&quot;&lt;/span&gt;&lt;span&gt; autocomplete&lt;/span&gt;&lt;span&gt;=&quot;off&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;layui-input&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;layui-form-item&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;layui-form-label&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;默认值&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;layui-input-block&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;defaultValue&quot;&lt;/span&gt;&lt;span&gt; placeholder&lt;/span&gt;&lt;span&gt;=&quot;请输入默认值&quot;&lt;/span&gt;&lt;span&gt; autocomplete&lt;/span&gt;&lt;span&gt;=&quot;off&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;layui-input&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;layui-form-item&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;layui-input-block&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;layui-btn layui-hide&quot;&lt;/span&gt;&lt;span&gt; lay-submit lay-filter&lt;/span&gt;&lt;span&gt;=&quot;LAY-evaluationIndex-front-submit&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;LAY-evaluationIndex-front-submit&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;立即提交&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　2、对于增加具体的检测记录，需要先读取到整个检测项目下的所有检测指标，然后实现生成表单的过程，按照如下的思路一步一步实现：&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201905/1133736-20190527222416282-794537383.png&quot; alt=&quot;&quot; width=&quot;645&quot; height=&quot;211&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　对于第一步，从数据库获取指定检测项目的检测指标，该步可以直接利用提供的id做一次查询即可得到相应的指标集合。然后在前端循环输出时，利用Razor语法完成动态渲染Html，生成label和input元素，依照之前设计检测指标时的name唯一，可以在此处设计表单时指定name属性。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;layui-fluid&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;layui-form&quot;&lt;/span&gt;&lt;span&gt; lay-filter&lt;/span&gt;&lt;span&gt;=&quot;layuiadmin-form-evaluationLimitValue&quot;&lt;/span&gt;&lt;span&gt; style&lt;/span&gt;&lt;span&gt;=&quot;padding: 15px 0 0 0;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        @foreach (var item in Model)
        {
            &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;layui-form-item&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;layui-form-label&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;@item.DisplayName&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;layui-input-block&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;@item.Name&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;@item.DefaultValue&quot;&lt;/span&gt;&lt;span&gt; placeholder&lt;/span&gt;&lt;span&gt;=&quot;@(&quot;&lt;/span&gt;&lt;span&gt;请输入&quot;+item.DisplayName)&quot; autocomplete&lt;/span&gt;&lt;span&gt;=&quot;off&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;layui-input&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        }
        &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;layui-form-item&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;layui-input-block&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;layui-btn layui-hide&quot;&lt;/span&gt;&lt;span&gt; lay-submit lay-filter&lt;/span&gt;&lt;span&gt;=&quot;LAY-evaluationLimitValue-front-submit&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;LAY-evaluationLimitValue-front-submit&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;立即提交&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　接下来可以完成表单的输入工作了，并提交到后台完成保存到数据库中，如我此处，新增记录时，保存到数据库前，先生成分组号，以此来区分这些指标下的数据是一个批次的，然后完成保存到数据库的过程。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task ConvertTableToEvaluationLimitValues(TestItemCode_EvaluationStandardSubItem assignTestItemCode, Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; evaluationLimitValues)
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; groupId =&lt;span&gt; DateTimeHelper.GetTimeStamp();
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; evaluationIndexes =&lt;span&gt; assignTestItemCode.EvaluationStandardSubItem.EvaluationStandard.EvaluationIndexes.ToList();

    &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; evaluationLimitValues)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; evaluationIndex = evaluationIndexes.Where(e =&amp;gt; e.Name ==&lt;span&gt; item.Key).FirstOrDefault();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (evaluationIndex == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; evaluationLimitValue = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EvaluationLimitValue(evaluationIndex.Id, assignTestItemCode.Id, item.Value, groupId);
        &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; _evaluationLimitValueRepository.InsertAsync(evaluationLimitValue);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　对于这部分的设计，做一点更改也适用于更新操作，但是得注意到，更新表单时，表单上展示的检测指标可能存在增加或是删除的情形，因此对于存在的记录我们可以展示出来，不存在的则留空，当提交到数据库时，需要做一次比对过程，对那部分增加的检测指标需要保存到数据库中，当然对于已有的检测指标也存在变更的可能，因此需要做一次判断，当有变更时更新，没有时不处理。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task UpdateEvaluationLimitValues(TestItemCode_EvaluationStandardSubItem assignTestItemCode, &lt;span&gt;string&lt;/span&gt; groupId, Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; evaluationLimitValues)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取当前的检测指标&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; evaluationIndexes =&lt;span&gt; assignTestItemCode.EvaluationStandardSubItem.EvaluationStandard.EvaluationIndexes.ToList();

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;目标分组已存在的检测限值&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; results = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; _evaluationLimitValueRepository.GetAll()
        .Where(e &lt;/span&gt;=&amp;gt; e.TestItemCode_EvaluationStandardSubItemId == assignTestItemCode.Id &amp;amp;&amp;amp; e.GroupId ==&lt;span&gt; groupId)
        .Include(e &lt;/span&gt;=&amp;gt;&lt;span&gt; e.EvaluationIndex).ToListAsync();

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;已存在的检测限值对应于检测指标名称列表&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; existedEvaluationLimitValueNameList = results.Select(r =&amp;gt;&lt;span&gt; r.EvaluationIndex.Name).ToList();

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;需新增的检测限值记录&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; addEvaluationLimitValueList =&lt;span&gt; evaluationLimitValues.Keys.Except(existedEvaluationLimitValueNameList).ToList();
    &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; key &lt;span&gt;in&lt;/span&gt;&lt;span&gt; addEvaluationLimitValueList)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; evaluationIndexId = evaluationIndexes.Where(e =&amp;gt; e.Name ==&lt;span&gt; key).FirstOrDefault().Id;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; evaluationLimitValue = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EvaluationLimitValue(evaluationIndexId, assignTestItemCode.Id, evaluationLimitValues[key], groupId);
        &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; _evaluationLimitValueRepository.InsertAsync(evaluationLimitValue);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;移除记录&lt;/span&gt;
&lt;span&gt;        evaluationLimitValues.Remove(key);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;更新已有检测限值记录值&lt;/span&gt;
    &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; key &lt;span&gt;in&lt;/span&gt;&lt;span&gt; evaluationLimitValues.Keys)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; editEvaluationLimitValues = results.Where(r =&amp;gt; r.EvaluationIndex.Name == key &amp;amp;&amp;amp; r.LimitValue !=&lt;span&gt; evaluationLimitValues[key]).FirstOrDefault();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (editEvaluationLimitValues != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        {
            editEvaluationLimitValues.LimitValue &lt;/span&gt;=&lt;span&gt; evaluationLimitValues[key];
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; _evaluationLimitValueRepository.UpdateAsync(editEvaluationLimitValues);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　3、完成检测记录的表格展示，此处需要遵循一个原则，就是先展示检测指标，也就是先展示属性列，其次展示数据值，只有相应的属性列存在，展示的数据值才有意义，通过指定的编号Id获取相应的属性集合并展示在前端，利用Razor语法循环输出th元素，来产生表格行头。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;layui-col-xs12&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;table &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;layui-table&quot;&lt;/span&gt;&lt;span&gt;
            lay-data&lt;/span&gt;&lt;span&gt;=&quot;{height: 'full-100', id:'mainList'}&quot;&lt;/span&gt;&lt;span&gt;
            lay-filter&lt;/span&gt;&lt;span&gt;=&quot;list&quot;&lt;/span&gt;&lt;span&gt; lay-size&lt;/span&gt;&lt;span&gt;=&quot;xs&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;thead&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;th &lt;/span&gt;&lt;span&gt;lay-data&lt;/span&gt;&lt;span&gt;=&quot;{checkbox:true, fixed: true}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
                @foreach (var item in Model)
                {
                    &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;th &lt;/span&gt;&lt;span&gt;lay-data&lt;/span&gt;&lt;span&gt;=&quot;{field:'@item.Name'}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;@Html.Raw(item.DisplayName)&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
                }
                &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;th &lt;/span&gt;&lt;span&gt;lay-data&lt;/span&gt;&lt;span&gt;=&quot;{fixed:'right', width:240, align:'center', toolbar: '#barList'}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;thead&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;table&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　表格展示完毕时便是数据开始呈现的时机，通过获取检测限值中的记录，注意这里的记录会有多条存在的，我们需要将纵向表结构转换成横向的json格式，用于前端读取，注意这里得把分组号加入进来，这是属于同一批次的标识。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201905/1133736-20190527225947244-1910562538.png&quot; alt=&quot;&quot; width=&quot;1316&quot; height=&quot;376&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　通过纵向转横向，可以得到字典类型的list集合，然后再返回前序列化成json格式，便是前端需要的格式。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;List&amp;lt;Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; ConvertEvaluationLimitValuesToTable(Guid assignedTestItemCodeId)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;分组后的评价限值&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; results = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; _evaluationLimitValueRepository.GetAll()
        .Where(e &lt;/span&gt;=&amp;gt; e.TestItemCode_EvaluationStandardSubItemId ==&lt;span&gt; assignedTestItemCodeId)
        .Include(e &lt;/span&gt;=&amp;gt;&lt;span&gt; e.EvaluationIndex)
        .GroupBy(e &lt;/span&gt;=&amp;gt;&lt;span&gt; e.GroupId).ToListAsync();

    List&lt;/span&gt;&amp;lt;Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;&amp;gt; convertResultList = &lt;span&gt;new&lt;/span&gt; List&amp;lt;Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt;();

    &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; result &lt;span&gt;in&lt;/span&gt;&lt;span&gt; results)
    {
        Dictionary&lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt; tempResultList = &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;
        {
            { EvaluationLimitValue.GetGroupIdName(), result.ElementAt(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;).GroupId }&lt;span&gt;//&lt;/span&gt;&lt;span&gt;增加分组号GroupId&lt;/span&gt;
&lt;span&gt;        };

        &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; result)
        {
            tempResultList.Add(item.EvaluationIndex.Name, item.LimitValue);
        }

        convertResultList.Add(tempResultList);
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; convertResultList;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;四、设计实现效果&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　1、实现动态增加属性列，尽管没有太丰富的功能，但是已经满足我现有的需求了，或许还能依据此得到更复杂的表单属性列设计。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201905/1133736-20190527230617422-762272980.gif&quot; alt=&quot;&quot; width=&quot;792&quot; height=&quot;374&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2、增加表单具体值，依据增加的属性列完成相应值填写。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201905/1133736-20190527230750766-1440723637.gif&quot; alt=&quot;&quot; width=&quot;813&quot; height=&quot;384&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　3、再次增加属性列后增加表单具体值，实现属性列的增加删除和修改后，仍然可以适用而无需手动修改表结构。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201905/1133736-20190527230935327-543914222.gif&quot; alt=&quot;&quot; width=&quot;866&quot; height=&quot;409&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　至此，动态表单的简单设计工作已经完成，过程较为简单，没有融入更多的比如多选，单选、数值型的设计，纯字符类型设计工作。&lt;/strong&gt;&lt;/p&gt;

&lt;pre class=&quot;lang-java prettyprint prettyprinted&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;str&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;lit&quot;&gt;&lt;strong&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;2019-&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;05-&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;27,望技术有成后能回来看见自己的脚步&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 27 May 2019 15:16:00 +0000</pubDate>
<dc:creator>微笑刺客D</dc:creator>
<og:description>这两天需要实现一个动态表单设计，面对着属性的不确定，要能够容纳不同的属性进来，之前也接触过这方面的设计，但是没有设计好，导致问题太多，这一次参考一些前辈们的经验后，再次尝试一番，通过动态设计表结构，以</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/CKExp/p/10919740.html</dc:identifier>
</item>
<item>
<title>TensorFlow——共享变量的使用方法 - Baby-Lily</title>
<link>http://www.cnblogs.com/baby-lily/p/10934131.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/baby-lily/p/10934131.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.共享变量用途&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在构建模型时，需要使用tf.Variable来创建一个变量（也可以理解成节点）。当两个模型一起训练时，一个模型需要使用其他模型创建的变量，比如，对抗网络中的生成器和判别器。如果使用tf.Variable，将会生成一个新的变量，而我们需要使用原来的那个变量。这时就是通过引入get_Variable方法，实现共享变量来解决这个问题。这种方法可以使用多套网络模型来训练一套权重。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.使用get_Variable获取变量&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;get_Variable一般会配合Variable_scope一起使用，以实现共享变量。Variable_scope的含义是变量作用域。在某一作用域中的变量可以被设置成共享的方式，被其他网络模型使用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;get_Variable函数的定义如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;tf.get_Variable(&amp;lt;name&amp;gt;, &amp;lt;shape&amp;gt;, &amp;lt;initializer&amp;gt;)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在TensorFlow里，使用get_Variable时候生成的变量是以指定的name属性为唯一标识，并不是定义的变量名称。使用时一般是通过name属性定位到具体变量，并将其共享到其他的模型中。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; tensorflow as tf
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np


var1 &lt;/span&gt;= tf.Variable(1.0, name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;first_var&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;var1: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, var1.name)

var1 &lt;/span&gt;= tf.Variable(2.0, name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;first_var&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;var1: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, var1.name)

var2 &lt;/span&gt;= tf.Variable(3.0&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;var2: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, var2.name)

var2 &lt;/span&gt;= tf.Variable(4.0&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;var1: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, var2.name)

with tf.Session() as sess:
    sess.run(tf.global_variables_initializer())
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;var1=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, var1.eval())
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;var2=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, var2.eval())
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1636554/201905/1636554-20190527211741582-1575208213.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在上述的代码中，，可以看到内存中有两个var1，并且他们的name是不一样的，对于图来说，后面的var1是生效的。当Variable定义没有指定名字时，系统会自动的加上一个名字Variable：0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.get_Variable用法演示&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; tensorflow as tf
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np


get_var1 &lt;/span&gt;= tf.get_variable(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;firat_var_1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, [1], initializer=tf.constant_initializer(2&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;var1: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, get_var1.name)

get_var1 &lt;/span&gt;= tf.get_variable(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;firat_var_2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, [1], initializer=tf.constant_initializer(3&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;var1: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, get_var1.name)

with tf.Session() as sess:
    sess.run(tf.global_variables_initializer())
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;var1=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, get_var1.name)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;var1=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, get_var1.eval())
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1636554/201905/1636554-20190527212926871-93103387.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用不同的name定义变量，当使用相同的name时，会抛出异常，变量名可以相同，但是name是不能相同的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果要使用相同的name的话，我们需要使用variable_scope将他们隔开，看如下代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; tensorflow as tf

with tf.variable_scope(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test_1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
    var1 &lt;/span&gt;= tf.get_variable(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;first_var&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, shape=[2], dtype=&lt;span&gt;tf.float32)

with tf.variable_scope(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test_2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
    var1 &lt;/span&gt;= tf.get_variable(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;first_var&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, shape=[2], dtype=&lt;span&gt;tf.float32)

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;var1:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, var1.name)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;var1:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, var1.name)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1636554/201905/1636554-20190527213826924-1053713250.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;根据程序的运行结果，我们可以发现变量的名字加上了作用域的名称，这样使得我们能够在不同的作用域下面定义name相同的变量，同时，scope还支持嵌套定义，&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
with tf.variable_scope(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test_0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
    with tf.variable_scope(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test_1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
        var1 &lt;/span&gt;= tf.get_variable(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;first_var&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, shape=[2], dtype=&lt;span&gt;tf.float32)

    with tf.variable_scope(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test_2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
        var1 &lt;/span&gt;= tf.get_variable(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;first_var&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, shape=[2], dtype=&lt;span&gt;tf.float32)

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;var1:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, var1.name)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;var1:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, var1.name)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.共享作用域&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用作用域中的参数reuse可以实现共享变量功能&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在variable_scope里面有一个reuse=True属性，表示使用已经定义过的变量，这时，get_variable将不会在创建新的变量，而是去图中get_variable所创建的变量中找与name相同的变量。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; tensorflow as tf

with tf.variable_scope(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test_0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
    var1 &lt;/span&gt;= tf.get_variable(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;first_var&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, shape=[2], dtype=&lt;span&gt;tf.float32)
    with tf.variable_scope(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test_2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
        var2 &lt;/span&gt;= tf.get_variable(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;first_var&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, shape=[2], dtype=&lt;span&gt;tf.float32)

with tf.variable_scope(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test_0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, reuse=&lt;span&gt;True):
    var3 &lt;/span&gt;= tf.get_variable(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;first_var&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, shape=[2], dtype=&lt;span&gt;tf.float32)
    with tf.variable_scope(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test_2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
        var4 &lt;/span&gt;= tf.get_variable(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;first_var&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, shape=[2], dtype=&lt;span&gt;tf.float32)


&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;var1:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, var1.name)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;var2:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, var2.name)

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;var3:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, var3.name)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;var4:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, var4.name)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1636554/201905/1636554-20190527215147785-784793441.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在上述的输出结果中，我们可以看到，var1和var3的名字一样，var2和var4的名字一样，则表明他们是同一个变量，如此就实现了变量的共享。在实际应用中，可以将1,2和3,4分别放在不同的模型进行训练，但是他们会作用于同一个模型的学习参数上。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用anaconda的spyder工具运行时，代码只能运行一次，第二次运行将会报错。可以退出当前的kernel，再重新进入一下，因为tf.get_varibale在创建变量时，会去检查图中是否已经创建过该变量，如果创建过且不是共享的方式，则会报错。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因而可以使用tf.reset_default_graph()，将图里面的变量清空，就可以解决这个问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;5.初始化共享变量&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;variable_scope和get_variable都具有初始化的功能。在初始化时，如果没有对当前变量初始化，则TensorFlow会默认使用作用域的初始化，并且作用域的初始化方法也有继承功能。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; tensorflow as tf

with tf.variable_scope(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test_0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, initializer=tf.constant_initializer(0.15&lt;span&gt;)):
    var1 &lt;/span&gt;= tf.get_variable(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;first_var&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, shape=[2], dtype=&lt;span&gt;tf.float32)
    with tf.variable_scope(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test_2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
        var2 &lt;/span&gt;= tf.get_variable(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;first_var&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, shape=[2], dtype=&lt;span&gt;tf.float32)
        var3 &lt;/span&gt;= tf.get_variable(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;first_var_2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, shape=[2], initializer=tf.constant_initializer(0.315&lt;span&gt;))

with tf.Session() as sess:
    sess.run(tf.global_variables_initializer())
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;var1:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, var1.eval())
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;var2:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, var2.eval())
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;var3:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, var3.eval())
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1636554/201905/1636554-20190527221119650-1384445141.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当变量没有进行初始化时，会继承它的域的初始化方式，域也会继承它的上一级的域的初始化方式。在多模型训练时，常常可以对模型中的张量进行分区，同时，同一进行初始化。在变量共享方面，可以使用tf.AUTO_REUSE来为reuse属性赋值。tf。AUTO_REUSE可以实现第一次调用variable_scope时，传入reuse的值为false，再次调用时，reuse的值为True。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;6.作用域与操作符的受限范围&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;variable_scope还可以使用with variable_scope as xxxscope的方式定义作用域，当使用这种方式时，将不会在受到外层的scope所限制。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; tensorflow as tf

with tf.variable_scope(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, initializer=tf.constant_initializer(1.5&lt;span&gt;)) as sp:
    var1 &lt;/span&gt;= tf.get_variable(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;var1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, [2], dtype=&lt;span&gt;tf.float32)

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(sp.name)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(var1.name)

with tf.variable_scope(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, dtype=tf.float32, initializer=tf.constant_initializer(5.5&lt;span&gt;)):
    var2 &lt;/span&gt;= tf.get_variable(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;var1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, [2], dtype=&lt;span&gt;tf.float32)
    with tf.variable_scope(sp) as sp1:
        var3 &lt;/span&gt;= tf.get_variable(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;var2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, [2], dtype=&lt;span&gt;tf.float32)

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;var2:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, var2.name)


&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;var3:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, var3.name)


with tf.Session() as sess:
    sess.run(tf.global_variables_initializer())
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;var2:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, var2.eval())
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;var2:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, var3.eval())
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1636554/201905/1636554-20190527223910111-1023984294.png&quot; alt=&quot;&quot; width=&quot;319&quot; height=&quot;173&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过with tf.variable_scope(sp) as sp1我们可知其没有收到外层的作用域所限制，初始化的操作时，它的值不是外层作用域的初始化值，而是指定的作用域的初始化的值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于操作符而言，不仅收到tf.name_scope限制还收到tf.variable_scope限制。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; tensorflow as tf
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np

with tf.variable_scope(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
    with tf.name_scope(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;op&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
        v &lt;/span&gt;= tf.get_variable(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;var1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, [1&lt;span&gt;])
        x &lt;/span&gt;= v + 2.0

&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, v.name)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;x&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, x.name)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1636554/201905/1636554-20190527224646285-1894164147.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;根据结果，我们可知，通过添加tf.name_scope('op'):作用域时，变量的命名并没有收到限制，只是改变了op的命名，通过tf.name_scope(''):还可以返回到顶层的作用域中。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; tensorflow as tf
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np

with tf.variable_scope(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
    var1 &lt;/span&gt;= tf.get_variable(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, [1&lt;span&gt;])

    with tf.variable_scope(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;scope_1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
        var2 &lt;/span&gt;= tf.get_variable(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, [1&lt;span&gt;])

        with tf.name_scope(&lt;/span&gt;&lt;span&gt;''&lt;/span&gt;&lt;span&gt;):
            var3 &lt;/span&gt;= tf.get_variable(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;var1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, [1&lt;span&gt;])
            x &lt;/span&gt;= var3 + 2.0

&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;var1 &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, var1.name)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;var2 &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, var2.name)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;var3 &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, var3.name)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;x &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, x.name)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1636554/201905/1636554-20190527225510266-1343788919.png&quot; alt=&quot;&quot; width=&quot;471&quot; height=&quot;105&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过将通过tf.name_scope('')设置为空，对于变量名是没有影响，但是可以看到x的命名，它已经变成了最外层的命名了。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 27 May 2019 15:01:00 +0000</pubDate>
<dc:creator>Baby-Lily</dc:creator>
<og:description>1.共享变量用途 在构建模型时，需要使用tf.Variable来创建一个变量（也可以理解成节点）。当两个模型一起训练时，一个模型需要使用其他模型创建的变量，比如，对抗网络中的生成器和判别器。如果使用t</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/baby-lily/p/10934131.html</dc:identifier>
</item>
<item>
<title>浅谈.Net异步编程的前世今生----EAP篇 - Wackysoft</title>
<link>http://www.cnblogs.com/wackysoft/p/10927588.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wackysoft/p/10927588.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在上一篇博文中，我们提到了APM模型实现异步编程的模式，通过使用APM模型，可以简化.Net中编写异步程序的方式，但APM模型本身依然存在一些缺点，如无法得知操作进度，不能取消异步操作等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;针对这些缺点，微软在.Net 2.0中提出了基于事件的异步模式，简称为EAP模型。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;第二个异步编程模型：EAP&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;概述&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;EAP，全称Event-based Asynchronous Pattern，基于事件的异步模式，它提供了一系列的事件声明与方法，用于实现异步模式的各个阶段。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;典型的内置组件为BackgroundWorker组件，本文中我们将使用它来探寻此种模式的执行过程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;使用&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们需要创建一个窗体应用，并模拟下载实时进度显示。创建WinForm后，放入Label控件用于展示下载进度和其他信息，并加入两个Button按钮，分别为开始下载和取消下载，再放入我们的主角：BackgroundWorker组件，如图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/443744/201905/443744-20190526210607563-427594934.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在加入这些基本组件后，我们开始这一次的编码之旅，BackgroundWorker在后台属于一个类，因此它已经内置了部分属性和事件：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/443744/201905/443744-20190527214345972-1621786193.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这些属性中包含取消、支持进度更新、判断是否执行等，恰恰是我们在这次异步操作中需要的。于是，我们根据需求编写了以下代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.ComponentModel;
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Data;
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Drawing;
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.IO;
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading;
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Windows.Forms;
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; 
&lt;span&gt; 13&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; BackgroundWorkerDemo
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;partial&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BackgroundWorkerForm : Form
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; BackgroundWorkerForm()
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt; &lt;span&gt;            InitializeComponent();
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt;             backgroundWorker1.WorkerReportsProgress = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt;             backgroundWorker1.WorkerSupportsCancellation = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt; 
&lt;span&gt; 24&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 25&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 点击开始下载按钮
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 27&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;sender&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 28&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;e&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 29&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; btnDownLoad_Click(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e)
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!backgroundWorker1.IsBusy) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断是否正在执行异步操作&lt;/span&gt;
&lt;span&gt; 32&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;backgroundWorker开始执行异步操作&lt;/span&gt;
&lt;span&gt; 34&lt;/span&gt; &lt;span&gt;                backgroundWorker1.RunWorkerAsync();
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt; 
&lt;span&gt; 38&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 39&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 点击取消按钮
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 41&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;sender&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 42&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;e&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 43&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; btnCancel_Click(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e)
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (backgroundWorker1.WorkerSupportsCancellation) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断是否支持异步取消操作&lt;/span&gt;
&lt;span&gt; 46&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;开始执行取消操作&lt;/span&gt;
&lt;span&gt; 48&lt;/span&gt; &lt;span&gt;                backgroundWorker1.CancelAsync();
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt; 
&lt;span&gt; 52&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 53&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; backgroundworker异步执行事件
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 55&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;sender&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 56&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;e&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 57&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; backgroundWorker1_DoWork(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, DoWorkEventArgs e)
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;             System.ComponentModel.BackgroundWorker worker = sender &lt;span&gt;as&lt;/span&gt;&lt;span&gt; System.ComponentModel.BackgroundWorker;
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt;             &lt;span&gt;string&lt;/span&gt; msg = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;当前线程是否为后台线程：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + Thread.CurrentThread.IsBackground + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;，是否为线程池线程：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; Thread.CurrentThread.IsThreadPoolThread;
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;             WriteLog(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Backgroundworker日志&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, msg);
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;20&lt;/span&gt;; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (worker.CancellationPending)
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt;                     e.Cancel = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 70&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;模拟下载执行进度&lt;/span&gt;
&lt;span&gt; 72&lt;/span&gt;                     Thread.Sleep(&lt;span&gt;500&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;                     worker.ReportProgress(i * &lt;span&gt;5&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt; 
&lt;span&gt; 78&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 79&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 进度报告事件
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 81&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;sender&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 82&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;e&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 83&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; backgroundWorker1_ProgressChanged(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, ProgressChangedEventArgs e)
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt;             lblProcess.Text = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;当前下载进度为：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + e.ProgressPercentage + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%，是否为后台线程：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + Thread.CurrentThread.IsBackground + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;，是否为线程池线程：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; Thread.CurrentThread.IsThreadPoolThread;
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt; 
&lt;span&gt; 88&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 89&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 异步操作完成事件
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 91&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;sender&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 92&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;e&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 93&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; backgroundWorker1_RunWorkerCompleted(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, RunWorkerCompletedEventArgs e)
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (e.Cancelled) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;此状态为取消&lt;/span&gt;
&lt;span&gt; 96&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt;                 lblProcess.Text = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;下载已经被取消&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (e.Error != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt;                 lblProcess.Text = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;出现错误：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; e.Error.Message;
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;104&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt;                 lblProcess.Text = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;下载已完成&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt; 
&lt;span&gt;109&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;110&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 记录日志
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;112&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;documentName&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;113&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;msg&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;114&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; WriteLog(&lt;span&gt;string&lt;/span&gt; documentName, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; msg)
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt;             &lt;span&gt;string&lt;/span&gt; errorLogFilePath = System.IO.Path.Combine(AppDomain.CurrentDomain.BaseDirectory, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Log&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;System.IO.Directory.Exists(errorLogFilePath))
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt; &lt;span&gt;                System.IO.Directory.CreateDirectory(errorLogFilePath);
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt;             &lt;span&gt;string&lt;/span&gt; logFile = System.IO.Path.Combine(errorLogFilePath, documentName + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;@&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + DateTime.Today.ToString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yyyy-MM-dd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt;             &lt;span&gt;bool&lt;/span&gt; writeBaseInfo =&lt;span&gt; System.IO.File.Exists(logFile);
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;             StreamWriter swLogFile = &lt;span&gt;new&lt;/span&gt; StreamWriter(logFile, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;, Encoding.Unicode);
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt;             swLogFile.WriteLine(DateTime.Now.ToString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HH:mm:ss&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\t&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; msg);
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt; &lt;span&gt;            swLogFile.Close();
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt; &lt;span&gt;            swLogFile.Dispose();
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt; &lt;span&gt;        }  
&lt;/span&gt;&lt;span&gt;128&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;129&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在这段示例代码中，我们首先设置组件支持取消及报告进度操作属性，其次在点击开始按钮时，判断是否执行，若未执行，则执行RunWorkerAsync方法，避免多次重复执行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在EAP模型中，执行RunWorkerAsync方法后，会触发backgroundWorker1_DoWork事件。此事件中我们放入模拟实时下载进度代码，并调用ReportProgress进行进度报告，这时backgroundWorker1_ProgressChanged事件会被触发，同时对UI进行更新操作，此段过程运行结果如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/443744/201905/443744-20190527220140049-449299846.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/443744/201905/443744-20190527215148855-1970838030.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过结果可以看出，运行过程中已经实现了实时更新进度的功能。于此同时，根据反馈的信息我们发现，backgroundWorker1_ProgressChanged事件内部是线程安全的，在操作UI时不会出现跨线程对UI进行更新的问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么BackgroundWorker内部是不是依然使用了线程池及后台线程呢？我们来一起看看在backgroundWorker1_DoWork事件中记录的日志：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/443744/201905/443744-20190527222100461-605628573.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过日志我们发现，EAP与APM一样，也使用了线程池中的线程，不得不感叹一句，线程池是个伟大的发明，微软真是无所不用其极啊！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;讲到这里，细心的同学会发现，我们唠叨了这么半天，似乎还少了点什么，对了，取消操作，一起来看看效果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/443744/201905/443744-20190527222342129-1601383276.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;点击界面上的&quot;取消下载&quot;按钮后，会提示下载已经被取消。原因是我们在点击按钮时，首先判断了WorkerSupportsCancellation属性，看组件是否支持取消操作，随后执行CancelAsync方法进行异步取消。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由于这个过程是异步的，因此我们在backgroundWorker1_DoWork事件中不断判断CancellationPending属性，若取消则设置e.Cancel=true进行标志位标志，标志后我们可以在backgroundWorker1_RunWorkerCompleted判断是否已经取消，最后对UI进行提示输出，取消操作完成。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;小结&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对比APM调用委托进行异步操作的方式，EAP显得更加简洁明了，只需更少的代码即可实现更多的功能。尤其是BackgroundWorker组件，定义相应的事件后，在不同阶段根据需求编写方法即可实现异步操作、报告进度及取消等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是EAP模型的使用，局限性会更强，主要包括以下几点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、可用组件少，除了BackgroundWorker之外，仅有WebClient类支持此模型，在B/S程序中难以使用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、只能使用预定义事件，无法手动定义回调函数，且依赖事件的执行顺序&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、内部封装较多，占用资源比APM方式多&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因此在愈演愈烈的需求中，微软又对异步编程模型进行了变革，一种兼顾强大与灵活的新模型诞生了，它会是谁呢？预知后事如何，且听下回分解。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;下集预告&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;浅谈.Net异步编程的前世今生----TPL篇&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 27 May 2019 14:56:00 +0000</pubDate>
<dc:creator>Wackysoft</dc:creator>
<og:description>前言 在上一篇博文中，我们提到了APM模型实现异步编程的模式，通过使用APM模型，可以简化.Net中编写异步程序的方式，但APM模型本身依然存在一些缺点，如无法得知操作进度，不能取消异步操作等。 针对</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wackysoft/p/10927588.html</dc:identifier>
</item>
<item>
<title>Java爬虫系列之实战：爬取酷狗音乐网 TOP500 的歌曲(附源码) - JAVA开发老菜鸟</title>
<link>http://www.cnblogs.com/sam-uncle/p/10934064.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sam-uncle/p/10934064.html</guid>
<description>
&lt;p&gt;在前面分享的两篇随笔中分别介绍了HttpClient和Jsoup以及简单的代码案例：&lt;/p&gt;
&lt;p&gt;今天就来实战下，用他们来抓取酷狗音乐网上的 Top500排行榜音乐。接下来的代码中除了会用到HttpClient和Jsoup之外，还会用到log4j和ehcache，分别用来记录日志和实现缓存，如果看官对这两个不是很熟悉的话，请自行百度，现在网上的入门实例有很多，我就不专门记笔记了。&lt;/p&gt;

&lt;p&gt;那为什么会想到爬取酷狗音乐网呢？其实也不是我想到的，而是不久前看过某位大神的博客就是爬取酷狗的（具体哪位大神不记得了，见谅哈~~~），我也想用自己的代码试试，并且我看的博客里面好像没有用到缓存，也没有用到代理ip这种反反爬虫的工具，我会在我的爬虫程序里面补上，亲测能自动处理全部23页的歌曲（但是付费歌曲由于必须登录购买才能访问，因此未能下载到，只有其他的400+首非付费歌曲可以正常下载），所以酷狗网的工作人员不要担心哦~~~&lt;/p&gt;
&lt;p&gt;话有又说回来了，在那篇博客出来后，也没见酷狗音乐去专门处理下，还能给我留下写这段代码的机会，说明人家酷狗不在乎，毕竟付费歌曲是不能爬取的，而且网站已经有了一定的反爬虫机制。&lt;/p&gt;
&lt;p&gt;***************************************************************************&lt;/p&gt;
&lt;p&gt; 声明：&lt;/p&gt;
&lt;p&gt;本爬虫程序和程序爬取到的内容仅限个人学习交流使用，&lt;/p&gt;
&lt;p&gt;请勿用于商业用途，否则后果自负&lt;/p&gt;
&lt;p&gt;***************************************************************************&lt;/p&gt;
&lt;p&gt;好，废话不多说，该上干货了~~&lt;/p&gt;
&lt;p&gt;================很华丽的分割线=================&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、设计思路&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先说下思路，我看过的那篇博客没有把过程写详细，我就把它补充下吧：&lt;/p&gt;
&lt;p&gt;1.点进去Top500排行榜，它的地址栏里面是：&lt;a href=&quot;https://www.kugou.com/yy/rank/home/1-8888.html?from=homepage&quot;&gt;https://www.kugou.com/yy/rank/home/1-8888.html?from=homepage&lt;/a&gt;，而这个1其实就是页码，访问第N页就把1改成N就行，这个是我爬取的基础&lt;/p&gt;
&lt;p&gt;2.点具体某首歌曲，比如《你的酒馆对我打了烊》，新打开页面：&lt;a href=&quot;https://www.kugou.com/song/#hash=BE1E1D3C2A46B4CBD259ACA7FF050CD3&amp;amp;album_id=14913769&quot;&gt;https://www.kugou.com/song/#hash=BE1E1D3C2A46B4CBD259ACA7FF050CD3&amp;amp;album_id=14913769&lt;/a&gt;，&lt;/p&gt;
&lt;p&gt;3.我们F12分析下网络请求（啥？打开F12没东西？大哥呀你不会再刷新下吗），&lt;/p&gt;
&lt;p&gt;你会发现有个耗时很长的请求,而且类型是media，它很可能就是真正获取mp3的请求&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1345071/201905/1345071-20190527214042184-901370823.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;仔细看，果然是的，mp3的真实地址是：http://fs.w.kugou.com/201905272134/9d4d81230e6f5c759df51618b03961a7/G126/M00/05/09/HocBAFxLAoeAT3BzAD1nWyW7V5M814.mp3&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1345071/201905/1345071-20190527214209450-1071460442.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;关掉页面，重新进入该页面，MP3的真是地址是：http://fs.w.kugou.com/201905272139/2897cc9816b82f4cda304d927187b282/G126/M00/05/09/HocBAFxLAoeAT3BzAD1nWyW7V5M814.mp3&lt;/p&gt;
&lt;p&gt;根据这个看不出来啥&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1345071/201905/1345071-20190527215220153-1233335756.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;继续分析，那它是怎么找到这个真实地址的呢？应该是前面的某个请求里面获取到了真实地址，找前面的请求：&lt;/p&gt;
&lt;p&gt;这个请求的response里面含有MP3的真实地址，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1345071/201905/1345071-20190527215916535-100670123.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;请求的request为：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;https://wwwapi.kugou.com/yy/index.php?r=play/getdata&amp;amp;callback=jQuery19106506492572547629_1558964792005&amp;amp;&lt;span&gt;&lt;strong&gt;hash=BE1E1D3C2A46B4CBD259ACA7FF050CD3&amp;amp;album_id=14913769&lt;/strong&gt;&lt;/span&gt;&amp;amp;dfid=3LWatj1PQwvn09grkH3FbFAF&amp;amp;mid=31adc5218ff6a510b05aacad71bc7090&amp;amp;platid=4&amp;amp;_=&lt;span&gt;&lt;strong&gt;1558964792007&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;退出重新获取一次，然后再退出换首歌再获取一下这个request，你会发现一些规律：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;粉红色是歌曲播放页面地址栏里面的内容，加粗部分是日期的long值，其他的都可以不变&lt;/strong&gt;（“jQuery19106506492572547629_1558964792005”虽然每次有变化，但是经过尝试，其实没有影响），&lt;/p&gt;
&lt;p&gt;所以我们就可以通过请求这个链接来获取带有MP3真实地址的json，然后请求真实地址，从而获取音乐文件。&lt;/p&gt;

&lt;p&gt;4.那粉红色部分的值怎么获取呢？查看top500的列表页的源码会发现有段内容，这个里面记录的第N页所有歌曲的hash值、歌曲名、id等基本信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;188&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 列表数据&lt;/span&gt;
global.features = [{&quot;Hash&quot;:&quot;BE1E1D3C2A46B4CBD259ACA7FF050CD3&quot;,&quot;FileName&quot;:&quot;\u9648\u96ea\u51dd - \u4f60\u7684\u9152\u9986\u5bf9\u6211\u6253\u4e86\u70ca&quot;,&quot;timeLen&quot;:251.048,&quot;privilege&quot;:10,&quot;size&quot;:4024155,&quot;album_id&quot;:14913769,&quot;encrypt_id&quot;:&quot;tlk6517&quot;},{&quot;Hash&quot;:&quot;9198B18815EE8CE42AE368AE29276F78&quot;,&quot;FileName&quot;:&quot;\u9648\u96ea\u51dd - \u7eff\u8272&quot;,&quot;timeLen&quot;:269.064,&quot;privilege&quot;:10,&quot;size&quot;:4314636,&quot;album_id&quot;:15270740,&quot;encrypt_id&quot;:&quot;txskm8f&quot;},{&quot;Hash&quot;:&quot;458E9B9F362277AC37E9EEF1CB80B535&quot;,&quot;FileName&quot;:&quot;\u738b\u742a - \u4e07\u7231\u5343\u6069&quot;,&quot;timeLen&quot;:322.011,&quot;privilege&quot;:10,&quot;size&quot;:5152644,&quot;album_id&quot;:18712576,&quot;encrypt_id&quot;:&quot;vsdz726&quot;},{&quot;Hash&quot;:&quot;7E91FDE7E8D33E8ED11C6DB4620917E2&quot;,&quot;FileName&quot;:&quot;\u5b64\u72ec\u8bd7\u4eba - \u6e21\u6211\u4e0d\u6e21\u5979&quot;,&quot;timeLen&quot;:182.23,&quot;privilege&quot;:10,&quot;size&quot;:2916145,&quot;album_id&quot;:14624971,&quot;encrypt_id&quot;:&quot;th6cka5&quot;},{&quot;Hash&quot;:&quot;9681F4CCD830B8436DB5F8218C7DF0C7&quot;,&quot;FileName&quot;:&quot;\u864e\u4e8c - \u4f60\u4e00\u5b9a\u8981\u5e78\u798f&quot;,&quot;timeLen&quot;:259.066,&quot;privilege&quot;:10,&quot;size&quot;:4155201,&quot;album_id&quot;:12249679,&quot;encrypt_id&quot;:&quot;rniv71f&quot;},{&quot;Hash&quot;:&quot;44ABEAA9CCE29AFB5C947D4FBD2C567F&quot;,&quot;FileName&quot;:&quot;\u5927\u58ee - \u4f2a\u88c5&quot;,&quot;timeLen&quot;:301.004,&quot;privilege&quot;:10,&quot;size&quot;:4817151,&quot;album_id&quot;:15999493,&quot;encrypt_id&quot;:&quot;u6n6i28&quot;},{&quot;Hash&quot;:&quot;5FCE4CBCB96D6025033BCE2025FC3943&quot;,&quot;FileName&quot;:&quot;\u5468\u6770\u4f26 - \u544a\u767d\u6c14\u7403&quot;,&quot;timeLen&quot;:215,&quot;privilege&quot;:10,&quot;size&quot;:3443771,&quot;album_id&quot;:1645030,&quot;encrypt_id&quot;:&quot;d5c5m23&quot;},{&quot;Hash&quot;:&quot;0A62227CAAB66F54D43EC084B4BDD81F&quot;,&quot;FileName&quot;:&quot;\u5468\u6770\u4f26 - \u7a3b\u9999&quot;,&quot;timeLen&quot;:223.582,&quot;privilege&quot;:10,&quot;size&quot;:3577344,&quot;album_id&quot;:960399,&quot;encrypt_id&quot;:&quot;74itc7&quot;},{&quot;Hash&quot;:&quot;A11F7A8BD2EA5BBDB32F58A9081F27B4&quot;,&quot;FileName&quot;:&quot;\u82b1\u59d0 - \u72c2\u6d6a&quot;,&quot;timeLen&quot;:181.037,&quot;privilege&quot;:10,&quot;size&quot;:2902317,&quot;album_id&quot;:13476703,&quot;encrypt_id&quot;:&quot;sfzob9f&quot;},{&quot;Hash&quot;:&quot;33EB8FE0DC9F70D9F7FE4CB77305D5A8&quot;,&quot;FileName&quot;:&quot;\u6d77\u6765\u963f\u6728\u3001\u963f\u5477\u62c9\u53e4\u3001\u66f2\u6bd4\u963f\u4e14 - \u522b\u77e5\u5df1&quot;,&quot;timeLen&quot;:280.111,&quot;privilege&quot;:10,&quot;size&quot;:4482365,&quot;album_id&quot;:16324799,&quot;encrypt_id&quot;:&quot;uajki71&quot;},{&quot;Hash&quot;:&quot;76D04F195C1F081CC0CD027A310A7D9A&quot;,&quot;FileName&quot;:&quot;\u738b\u742a - \u7ad9\u7740\u7b49\u4f60\u4e09\u5343\u5e74&quot;,&quot;timeLen&quot;:381.083,&quot;privilege&quot;:10,&quot;size&quot;:6109771,&quot;album_id&quot;:13886090,&quot;encrypt_id&quot;:&quot;sunkg88&quot;},{&quot;Hash&quot;:&quot;9C00A468D2658487DB2DE4ED16A12B5A&quot;,&quot;FileName&quot;:&quot;\u738b\u8d30\u6d6a - \u50cf\u9c7c&quot;,&quot;timeLen&quot;:285.031,&quot;privilege&quot;:10,&quot;size&quot;:4565459,&quot;album_id&quot;:13621986,&quot;encrypt_id&quot;:&quot;smhia84&quot;},{&quot;Hash&quot;:&quot;4F76587A5B0B93EEF15883E54DD3E2DB&quot;,&quot;FileName&quot;:&quot;\u6bdb\u4e0d\u6613 - \u6d88\u6101 (Live)&quot;,&quot;timeLen&quot;:179,&quot;privilege&quot;:10,&quot;size&quot;:2870658,&quot;album_id&quot;:2900867,&quot;encrypt_id&quot;:&quot;gf96d56&quot;},{&quot;Hash&quot;:&quot;8B7DF540F77042FB76DA1EE3A79EAE0A&quot;,&quot;FileName&quot;:&quot;NCF-\u827e\u529b - \u9ece\u660e\u524d\u7684\u9ed1\u6697 (\u5973\u58f0\u7248)&quot;,&quot;timeLen&quot;:145.058,&quot;privilege&quot;:10,&quot;size&quot;:2329748,&quot;album_id&quot;:17997426,&quot;encrypt_id&quot;:&quot;twhgf05&quot;},{&quot;Hash&quot;:&quot;7A3269C36D07E88A24FB35D246856FA4&quot;,&quot;FileName&quot;:&quot;Yusee\u897f - \u5fc3\u5982\u6b62\u6c34&quot;,&quot;timeLen&quot;:182.883,&quot;privilege&quot;:10,&quot;size&quot;:2926594,&quot;album_id&quot;:19692772,&quot;encrypt_id&quot;:&quot;wd07h77&quot;},{&quot;Hash&quot;:&quot;7995A2173ED0914868BB860F93C3D642&quot;,&quot;FileName&quot;:&quot;\u9b4f\u65b0\u96e8 - \u4f59\u60c5\u672a\u4e86&quot;,&quot;timeLen&quot;:216.189,&quot;privilege&quot;:10,&quot;size&quot;:3459539,&quot;album_id&quot;:20709823,&quot;encrypt_id&quot;:&quot;wnru4c8&quot;},{&quot;Hash&quot;:&quot;D8E40DA7F51C0486224E008A3B6ABD45&quot;,&quot;FileName&quot;:&quot;\u5154\u5b50\u7259 - \u5c0f\u767d\u5154\u9047\u4e0a\u5361\u5e03\u5947\u8bfa&quot;,&quot;timeLen&quot;:163.087,&quot;privilege&quot;:10,&quot;size&quot;:2622454,&quot;album_id&quot;:12492325,&quot;encrypt_id&quot;:&quot;rrrbccf&quot;},{&quot;Hash&quot;:&quot;D2462B148305FF7D990F3B6EB3F90D66&quot;,&quot;FileName&quot;:&quot;\u5f20\u656c\u8f69 - \u53ea\u662f\u592a\u7231\u4f60&quot;,&quot;timeLen&quot;:254.302,&quot;privilege&quot;:10,&quot;size&quot;:4080941,&quot;album_id&quot;:558311,&quot;encrypt_id&quot;:&quot;3f65bd&quot;},{&quot;Hash&quot;:&quot;03FE01457005CEEF8627BE5E5313D230&quot;,&quot;FileName&quot;:&quot;\u84dd\u4e03\u4e03 - \u9ece\u660e\u524d\u7684\u9ed1\u6697 (\u5973\u58f0\u7248)&quot;,&quot;timeLen&quot;:111.986,&quot;privilege&quot;:10,&quot;size&quot;:1792253,&quot;album_id&quot;:19842582,&quot;encrypt_id&quot;:&quot;w8lwi96&quot;},{&quot;Hash&quot;:&quot;96E064A41AB84EBE4C03C6AAE3CB9334&quot;,&quot;FileName&quot;:&quot;\u5f20\u7d2b\u8c6a - \u53ef\u4e0d\u53ef\u4ee5&quot;,&quot;timeLen&quot;:240.093,&quot;privilege&quot;:10,&quot;size&quot;:3855453,&quot;album_id&quot;:9618875,&quot;encrypt_id&quot;:&quot;mkt6v7f&quot;},{&quot;Hash&quot;:&quot;5D6CCE061BD65404BF5669FDD26C40B1&quot;,&quot;FileName&quot;:&quot;\u4e01\u8299\u59ae - \u53ea\u662f\u592a\u7231\u4f60&quot;,&quot;timeLen&quot;:247.797,&quot;privilege&quot;:10,&quot;size&quot;:3965342,&quot;album_id&quot;:18231730,&quot;encrypt_id&quot;:&quot;vhrxi30&quot;},{&quot;Hash&quot;:&quot;95B48A0894FC2198B6E2B93C034AAC72&quot;,&quot;FileName&quot;:&quot;\u5468\u6770\u4f26 - \u9752\u82b1\u74f7&quot;,&quot;timeLen&quot;:239.046,&quot;privilege&quot;:10,&quot;size&quot;:3825206,&quot;album_id&quot;:979856,&quot;encrypt_id&quot;:&quot;7a6sd6&quot;}];
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;把这些信息获取后放到ehcache缓存，hash为key，album_id为value，循环单个歌曲的时候播放页也能获取到hash，然后根据hash到缓存里面取值即可&lt;/p&gt;
&lt;p&gt;5.根据以上获取的信息就可以正常爬取文件了，但是在爬取了一段时间后会发现无法正常下载了，在log中看到请求不到MP3的真实地址， 返回的json报文里面error_code不为0，这个就是爬虫程序被网站识别了，这就要用到代理ip了，当被识别出后就换个代理ip，如此循环下去直到歌曲轮询完或代理ip被用完为止。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、核心代码展示&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有了思路之后，就可以写代码了，由于篇幅原因，这里只贴出部分核心代码，完整代码请在下面的gitee上获取&lt;/p&gt;
&lt;p&gt;代码结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1345071/201905/1345071-20190527223239947-1996741092.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li readability=&quot;-0.5&quot;&gt;需要的依赖
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; httpclient 抓取html &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.apache.httpcomponents&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;httpclient&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;4.5.8&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; Jsoup 解析html&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.jsoup&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;jsoup&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.11.3&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 用来下载歌曲，就不用自己写流操作了 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;commons-io&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;commons-io&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2.6&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; fastjson用来处理json &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.alibaba&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;fastjson&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.2.58&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; ehcache用作缓存 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;net.sf.ehcache&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;ehcache&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2.10.6&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 引入slf4j-nop 纯粹是防止ehcache执行报错 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.slf4j&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;slf4j-nop&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.7.2&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; log4j作为日志系统 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;log4j&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;log4j&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.2.17&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li readability=&quot;3.5&quot;&gt;主类
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.sam.kugou.main;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.log4j.Logger;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.jsoup.Jsoup;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.jsoup.nodes.Document;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.jsoup.nodes.Element;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.jsoup.select.Elements;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.alibaba.fastjson.JSONObject;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.sam.kugou.utils.DownLoadMusic;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.sam.kugou.utils.EhcacheUtil;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.sam.kugou.utils.HttpClientUtil;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; KugouSpiderMain {

    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Logger logger = Logger.getLogger(KugouSpiderMain.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
    
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; String URL_TEMP = &quot;https://www.kugou.com/yy/rank/home/PAGE_NUM-8888.html?from=homepage&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; SLEEP_TIME_WHEN_DENY = 1000*60*60;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;被网站识别后睡眠时间&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; SPIDER_DURING = 1;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;隔多久爬取下一首，单位：ms&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String DIR_NAME = &quot;E:\\personal\\音乐\\酷狗\\&quot;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;音乐下载地址&lt;/span&gt;
    
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;酷狗TOP500页面&lt;/span&gt;
        &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 1; i &amp;lt;= 23; i++&lt;span&gt;) {
                String url &lt;/span&gt;=&lt;span&gt; URL_TEMP;
                url &lt;/span&gt;= url.replace(&quot;PAGE_NUM&quot;, i + &quot;&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
                 * 1.请求歌曲列表
                 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
                logger.info(url);
                String html &lt;/span&gt;=&lt;span&gt; HttpClientUtil.getHtml(url);
                logger.debug(html);
                
                &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
                 * 2.获取该页的hash和id 放到缓存
                 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
                
                &lt;span&gt;int&lt;/span&gt; beginIdx = html.indexOf(&quot;global.features = &quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; endIdx = html.indexOf(&quot;];&quot;&lt;span&gt;, beginIdx);
                String features &lt;/span&gt;= html.substring(beginIdx, endIdx + 1).replace(&quot;global.features = &quot;, &quot;&quot;&lt;span&gt;);
                logger.info(&lt;/span&gt;&quot;containingOwnText &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; &quot; +&lt;span&gt; features);
                
                List&lt;/span&gt;&amp;lt;JSONObject&amp;gt; list = JSONObject.parseArray(features, JSONObject.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (JSONObject jsonObject : list) {
                    String hash &lt;/span&gt;= (String) jsonObject.get(&quot;Hash&quot;&lt;span&gt;);
                    Integer albumId &lt;/span&gt;= (Integer) jsonObject.get(&quot;album_id&quot;&lt;span&gt;);
                    EhcacheUtil.setCache(hash, albumId);
                }
                
                &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
                 * 3.解析列表内容
                 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
                Document doc &lt;/span&gt;=&lt;span&gt; Jsoup.parse(html);
                Elements songList &lt;/span&gt;= doc.select(&quot;.pc_temp_songlist ul li a&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Element element : songList) {
                    
                    String title &lt;/span&gt;= element.attr(&quot;title&quot;&lt;span&gt;);
                    String href &lt;/span&gt;= element.attr(&quot;href&quot;&lt;span&gt;);
                    
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(href.contains(&quot;https&quot;&lt;span&gt;)) {
                        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                            Thread.sleep(SPIDER_DURING);
                        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                            logger.error(e.getMessage());
                        }
                        logger.info(&lt;/span&gt;&quot;title &quot; + title +&quot; &amp;gt;&amp;gt;&amp;gt; href &quot; +&lt;span&gt; href);
                        DownLoadMusic.requestMusic(title, href);
                    }
                }

            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(Exception ex) {
            logger.error(ex.getMessage(), ex);
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;*
             * 4.关闭
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            EhcacheUtil.shutDownManager();
        }
        
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;获取真实地址&lt;img src=&quot;https://img2018.cnblogs.com/blog/1345071/201905/1345071-20190527224130307-129405277.png&quot; alt=&quot;&quot;/&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;执行下载
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; downLoad(String title, String url) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(url == &lt;span&gt;null&lt;/span&gt; || url.equals(&quot;&quot;&lt;span&gt;)) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;已经完成的就不再重新下载&lt;/span&gt;
        Element finishedCache =&lt;span&gt; EhcacheUtil.getFinishedCache(title);
        logger.debug(&lt;/span&gt;&quot;finishedCache &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; &quot; +&lt;span&gt; finishedCache);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(finishedCache != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            logger.info(&lt;/span&gt;&quot;歌曲已经存在！！！&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        String suffix &lt;/span&gt;= url.substring(url.lastIndexOf(&quot;.&quot;&lt;span&gt;));
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            HttpEntity httpEntity &lt;/span&gt;=&lt;span&gt; HttpClientUtil.getHttpEntity(url);
            InputStream inputStream &lt;/span&gt;=&lt;span&gt; httpEntity.getContent();
            String filePath &lt;/span&gt;= KugouSpiderMain.DIR_NAME+title+&lt;span&gt;suffix;
            FileUtils.copyToFile(inputStream, &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; File(filePath));
            logger.info(&lt;/span&gt;&quot;***完成下载：***&quot;+title+&lt;span&gt;suffix);
            logger.info(&lt;/span&gt;&quot;***总歌曲数量：***&quot;+(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; File(KugouSpiderMain.DIR_NAME)).list().length);
            EhcacheUtil.setFinishedCache(url, title);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
            logger.error(e.getMessage());
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;设置代理ip
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; setProxy() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1.创建一个httpClient&lt;/span&gt;
        CloseableHttpClient httpClient =&lt;span&gt; HttpClients.createDefault();
        CloseableHttpResponse response &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        String url &lt;/span&gt;= &quot;https://raw.githubusercontent.com/fate0/proxylist/master/proxy.list&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            response &lt;/span&gt;=&lt;span&gt; doRequest(httpClient, url);

            logger.debug(&lt;/span&gt;&quot;getHtml &quot; + url + &quot;**处理结果：**&quot; +&lt;span&gt; response.getStatusLine());
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 5.判断返回结果，200， 成功&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (HttpStatus.SC_OK ==&lt;span&gt; response.getStatusLine().getStatusCode()) {
                HttpEntity httpEntity &lt;/span&gt;=&lt;span&gt; response.getEntity();
                String html &lt;/span&gt;= EntityUtils.toString(httpEntity, &quot;utf-8&quot;&lt;span&gt;);
                html &lt;/span&gt;= &quot;[&quot;+html+&quot;]&quot;&lt;span&gt;;
                List&lt;/span&gt;&amp;lt;JSONObject&amp;gt; list = JSONArray.parseArray(html, JSONObject.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (JSONObject jsonObject : list) {
                    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; port = Integer.valueOf(jsonObject.get(&quot;port&quot;&lt;span&gt;).toString());
                    String host &lt;/span&gt;= jsonObject.get(&quot;host&quot;&lt;span&gt;).toString();
                    logger.info(host &lt;/span&gt;+ &quot;:&quot;+&lt;span&gt;port);
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(isHostConnectable(host, port)) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;代理ip可以连接&lt;/span&gt;
                        Element ipsCache = EhcacheUtil.getProxyIpsCache(host, port);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;代理ip未使用过&lt;/span&gt;
                        &lt;span&gt;if&lt;/span&gt;(ipsCache == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                            proxyIp &lt;/span&gt;=&lt;span&gt; host;
                            proxyPort &lt;/span&gt;=&lt;span&gt; port;
                            EhcacheUtil.setProxyIpsCache(host, port);
                            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                            logger.info(&lt;/span&gt;&quot;该代理ip已经使用过，切换下一个&quot;&lt;span&gt;);
                        }
                    }
                }
            }

        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            logger.error(e.getMessage(),e);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 关闭&lt;/span&gt;
&lt;span&gt;            HttpClientUtils.closeQuietly(response);
            HttpClientUtils.closeQuietly(httpClient);
        }
        logger.info(&lt;/span&gt;&quot;切换代理ip成功：&amp;gt;&amp;gt;&amp;gt;&quot; + proxyIp + &quot;:&quot; +&lt;span&gt; proxyPort);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;三、源码下载&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 源码已经上传到我的gitee:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/sam-uncle/kugou-spider&quot;&gt;https://gitee.com/sam-uncle/kugou-spider&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎下载~~&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; 四、遗留问题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1.只能抓取到免费歌曲，对于收费歌曲不能抓取，其实我们也不该抓取&lt;/p&gt;
&lt;p&gt;2.代码中为了方便用了很多static，不能支持多线程或并发抓取&lt;/p&gt;
&lt;p&gt;3.其实代理IP那里可以优化的&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;声明：&lt;/p&gt;
&lt;p&gt;本爬虫程序和程序爬取到的内容仅限个人学习交流使用，请勿用于商业用途，否则后果自负！！！谢谢&lt;/p&gt;
</description>
<pubDate>Mon, 27 May 2019 14:51:00 +0000</pubDate>
<dc:creator>JAVA开发老菜鸟</dc:creator>
<og:description>在前面分享的两篇随笔中分别介绍了HttpClient和Jsoup以及简单的代码案例： Java爬虫系列二：使用HttpClient抓取页面HTML Java爬虫系列三：使用Jsoup解析HTML 今天</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sam-uncle/p/10934064.html</dc:identifier>
</item>
<item>
<title>IDEA阅读源码的技巧 - 海向</title>
<link>http://www.cnblogs.com/haixiang/p/10934040.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/haixiang/p/10934040.html</guid>
<description>&lt;hr/&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;本教程仅支持 MAC 系统下的 IDEA 开发工具，如果需要 Windows 对应的操作起自行替代相应快捷键即可。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;查看当前类内容&quot;&gt;1. 查看当前类内容&lt;/h3&gt;
&lt;p&gt;快捷键：&lt;code&gt;command + 7&lt;/code&gt;&lt;br/&gt;我们可以使用快捷键快速了解该类中有哪些方法、字段以及内部类，也可以了解到从父类继承的方法以及字段，并且可以按照修饰符就行筛选，或者根据首字母进行排序。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1543774/201905/1543774-20190527165408518-406784669.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;查看当前类的继承体系&quot;&gt;2. 查看当前类的继承体系&lt;/h3&gt;
&lt;p&gt;快捷键：&lt;code&gt;control + h&lt;/code&gt;&lt;br/&gt;在这里除了查看类的继承层级也可以查看实现了哪些接口。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1543774/201905/1543774-20190527164135922-120708002.png&quot;/&gt;&lt;br/&gt;我们也可以选中当前类名点击右键，查看uml结构&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1543774/201905/1543774-20190527164515573-2073057098.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1543774/201905/1543774-20190527164623078-790152552.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;查看当前方法的调用链&quot;&gt;3. 查看当前方法的调用链&lt;/h3&gt;
&lt;p&gt;快捷键：&lt;code&gt;control + option + h&lt;/code&gt;&lt;br/&gt;我们可以在这里哪些方法调用了此方法，也可以查到此方法调用了哪些方法，我们可以利用这个核心功能快速定位某个方法的用处。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1543774/201905/1543774-20190527224237370-1777131358.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 27 May 2019 14:48:00 +0000</pubDate>
<dc:creator>海向</dc:creator>
<og:description>[TOC] 本教程仅支持 MAC 系统下的 IDEA 开发工具，如果需要 Windows 对应的操作起自行替代相应快捷键即可。 1. 查看当前类内容 快捷键： 我们可以使用快捷键快速了解该类中有哪些方</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/haixiang/p/10934040.html</dc:identifier>
</item>
<item>
<title>【IDEA】（3）---非常实用提高开发效率和水平的插件 - 雨点的名字</title>
<link>http://www.cnblogs.com/qdhxhz/p/10933769.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qdhxhz/p/10933769.html</guid>
<description>&lt;center&gt;

&lt;/center&gt;
&lt;p&gt;IDEA提供了许多很实用的插件，能够大大提高开发效率和开发水平，这里列举几个很实用的插件。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;说明&lt;/code&gt;：这边的IDEA是MAC系统。&lt;/p&gt;
&lt;h2 id=&quot;一插件管理界面简介&quot;&gt;&lt;span&gt;一、插件管理界面简介&lt;/span&gt;&lt;/h2&gt;
&lt;h4 id=&quot;界面位置&quot;&gt;1、界面位置&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201905/1090617-20190527220218813-1120223645.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;安装插件三个按钮的作用&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Install JetBrains Plugin&lt;/code&gt; 此按钮的功能是安装JetBrains的官方插件&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Browes repositories&lt;/code&gt; 此按钮的功能是浏览官方仓库，官方仓库不仅有官方插件，还有来自社区的插件的第三方插件&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Install plugin form disk&lt;/code&gt; 此按钮的功能是从本地安装插件，IDEA的插件打包之后，用这个功能就可以安装，方便了小团体之间的插 件开发和共享。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;说明&lt;/code&gt; 下面的几个插件都是选择&lt;code&gt;Browes repositories&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;二alibaba-java-coding-guidelines-插件&quot;&gt;&lt;span&gt;二、Alibaba java Coding Guidelines 插件&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;作用&lt;/code&gt; 我们知道阿里巴巴开发手册，这个是基于阿里巴巴手册制订的插件，以便提高我们开发代码质量。&lt;/p&gt;
&lt;h4 id=&quot;安装&quot;&gt;1、安装&lt;/h4&gt;
&lt;p&gt;进入到plugins，点击【Browse repositories】&lt;br/&gt;搜索 alibaba，找到 Alibaba java Coding Guidelines 并进行安装&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201905/1090617-20190527221133599-516875308.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;示例&quot;&gt;2、示例&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;编码规范扫码&lt;/code&gt; 可以在整个项目上右击，也可以在某个包名下，或者某一个类中进行代码检查编码规范扫码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201905/1090617-20190527221151914-1723167233.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;扫描反馈&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201905/1090617-20190527221213434-2056425547.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;很实用！&lt;/p&gt;

&lt;h2 id=&quot;三generateallsetter-插件&quot;&gt;&lt;span&gt; 三、generateAllSetter 插件&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;作用&lt;/code&gt; 当我们new了一个对象,一键调用该对象的所有的set方法。&lt;/p&gt;
&lt;h4 id=&quot;安装-1&quot;&gt;1、安装&lt;/h4&gt;
&lt;p&gt;进入到plugins，点击【Browse repositories】&lt;/p&gt;
&lt;p&gt;搜索 generateAllSetter，并进行安装。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201905/1090617-20190527220351974-183656909.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;安装成功后鼠标光标放到按下person处，按下 &lt;code&gt;alt + enter&lt;/code&gt; 键，如果出现下面三个，说明安装成功。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201905/1090617-20190527220438786-1438587401.jpg&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;代码示例&quot;&gt;2、代码示例&lt;/h4&gt;
&lt;p&gt;通过代码对上面三个不同方式做个说明，先创建两个对象。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Person&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Person {
    private String name;
    private String sex;
    private Integer age;
    //省略set和get方法
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;User&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class User {
    private String name;
    private int age;
     //省略set和get方法
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;示例&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;      public static void main(String[] args) {
        //Person person = new Person();
        /**
         * 鼠标光标放到按下person处，按下 alt + enter 键
         * 1、Generate all setter no default value (生成所有setter没有默认值)
         *    第一种很好理解，当你创建了一个对象，调用该对象的所有set方法，且set里放空
         * 2、Generate all setter with default value (使用默认值生成所有setter)
         *    第二种也很好理解，当你创建一个对象时，调用该对象的所有set方法，且set里放默认值。
         * 3、Generate setter getter converter（生成setter getter转换器）
         *    第三种等下用代码演示，它们涉及到两个实体赋值。
         */

        // 1、Generate all setter no default value
        // 发现都自动调用了person的set方法，且set里都为空
        Person person = new Person();
        person.setName();
        person.setSex();
        person.setAge();
        //2、Generate all setter with default value
        //通用都自动调用了person的set方法，不同的是set里传的是默认值
        Person person1 = new Person();
        person1.setName(&quot;&quot;);
        person1.setSex(&quot;&quot;);
        person1.setAge(0);
    }
    //3、Generate setter getter converter
    //示例 新建一个方法 需要传入User对象 最后返回Person对象
    //没有用插件三部曲
    Person build(User user) {
        //1、 先new 一个Person对象
        //2、然后将User对象相关属性一个一个赋值给Person
        //3、最后返回这个Person对象
    }
    //通过插件这三步都可以不用做,只要将光标放在 user 处，选择Generate setter getter converter 下面的代码都会自动生成
    Person build1(User user) {
        Person person = new Person();
        person.setName(user.getName());
        person.setSex(); //这个地方说明user对象没有对应的sex属性，所以为空
        person.setAge(user.getAge());
        return person;
    }    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实用！&lt;/p&gt;


&lt;p&gt;&lt;code&gt;作用&lt;/code&gt; 快捷键提示插件。&lt;/p&gt;
&lt;h4 id=&quot;安装-2&quot;&gt;1、安装&lt;/h4&gt;
&lt;p&gt;搜索&lt;code&gt;key promoter&lt;/code&gt;，并进行安装&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201905/1090617-20190527220526600-1326654928.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;示例-1&quot;&gt;2、示例&lt;/h4&gt;
&lt;p&gt;这个时候如果你使用IDEA过程中没有使用IDEA快捷键，那么它会提示你，比如这里运行SpringBoot启动类&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201905/1090617-20190527220706272-806300224.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为是右击运行，所以会有快捷键提示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201905/1090617-20190527220742229-107909267.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;注意&lt;/code&gt; 如果你鼠标运行的没有快捷键，那么累计三次它会提醒你问你是否去设置快捷键。&lt;/p&gt;

&lt;h2 id=&quot;五translation-插件&quot;&gt;&lt;span&gt;五、translation 插件&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;作用&lt;/code&gt; 这一个英文翻译插件，主要是你在看源码的时候可以进行英文翻译。&lt;/p&gt;
&lt;h4 id=&quot;安装-3&quot;&gt;1、安装&lt;/h4&gt;
&lt;p&gt;进入到plugins，点击【Browse repositories】&lt;br/&gt;搜索 translation，并进行安装&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201905/1090617-20190527220809480-1009786118.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;示例-2&quot;&gt;2、示例&lt;/h4&gt;
&lt;p&gt;选中一段源码注解，右击(也可以直接快捷键)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201905/1090617-20190527220831569-1392620056.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最终翻译&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201905/1090617-20190527220847619-1370138219.png&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;六sequencediagram-插件&quot;&gt;&lt;span&gt;六、sequenceDiagram 插件&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;作用&lt;/code&gt; 源码阅读得力助手之时序图,会为方法生成时序图。&lt;/p&gt;
&lt;h4 id=&quot;安装-4&quot;&gt;1、安装&lt;/h4&gt;
&lt;p&gt;进入到plugins，点击【Browse repositories】&lt;br/&gt;搜索 sequenceDiagram，并进行安装。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201905/1090617-20190527220912428-81250639.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;示例-3&quot;&gt;2、示例&lt;/h4&gt;
&lt;p&gt;在想查看时序图的方法处，&lt;code&gt;右键--&amp;gt;Sequence Diagram..&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201905/1090617-20190527220931682-796368322.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;去掉display only project classes，之后点击ok&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201905/1090617-20190527220949168-1790146922.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在下方即可看到生成的时序图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201905/1090617-20190527221007263-1967624727.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还有些实用的插件比如&lt;strong&gt;lombok&lt;/strong&gt;,为Class里的属性自动生成&lt;strong&gt;getter&lt;/strong&gt;、&lt;strong&gt;setter&lt;/strong&gt;插件。&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;只要自己变优秀了，其他的事情才会跟着好起来（少将18）&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 27 May 2019 14:21:00 +0000</pubDate>
<dc:creator>雨点的名字</dc:creator>
<og:description>IDEA(3)—Mac中IDEA插件 IDEA提供了许多很实用的插件，能够大大提高开发效率和开发水平，这里列举几个很实用的插件。 ：这边的IDEA是MAC系统。 一、插件管理界面简介 1、界面位置 安</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qdhxhz/p/10933769.html</dc:identifier>
</item>
<item>
<title>MySQL 如何优化cpu消耗 - Jia-Xin</title>
<link>http://www.cnblogs.com/YangJiaXin/p/10933458.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/YangJiaXin/p/10933458.html</guid>
<description>&lt;hr/&gt;&lt;h2 id=&quot;谁在消耗cpu&quot;&gt;谁在消耗cpu?&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;用户+系统+IO等待+软硬中断+空闲&lt;/em&gt;&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1179590/201905/1179590-20190527220055993-65442699.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1179590/201905/1179590-20190527220154673-599033146.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;祸首是谁&quot;&gt;祸首是谁？&lt;/h2&gt;
&lt;h3 id=&quot;用户&quot;&gt;用户&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;用户空间CPU消耗，各种逻辑运算&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;正在进行大量tps&lt;br/&gt;函数/排序/类型转化/逻辑IO访问...&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;用户空间消耗大量cpu，产生的系统调用是什么？那些函数使用了cpu周期？&lt;/em&gt;&lt;/strong&gt;&lt;br/&gt;参考&lt;a href=&quot;https://www.cnblogs.com/YangJiaXin/p/10928160.html&quot;&gt;&lt;br/&gt;Linux 性能优化解析&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/YangJiaXin/p/10853560.html&quot;&gt;MySQL 几种调式分析利器&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;io等待&quot;&gt;IO等待&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;等待IO请求的完成&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;此时CPU实际上空闲&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;如vmstat中的wa 很高。但IO等待增加，wa也不一定会上升（请求I/O后等待响应，但进程从核上移开了）&lt;/em&gt;&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1179590/201905/1179590-20190527220232193-1150896123.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1179590/201905/1179590-20190527220252309-1933130433.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;产生影响&quot;&gt;产生影响&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;用户和IO等待消耗了大部分cpu&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;吞吐量下降（tps）&lt;/em&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;em&gt;查询响应时间增加&lt;/em&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;em&gt;慢查询数增加&lt;/em&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;em&gt;对mysql的并发陡增，也会产生上诉影响&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1179590/201905/1179590-20190527220350730-466848858.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;如何减少cpu消耗&quot;&gt;如何减少CPU消耗？&lt;/h2&gt;
&lt;h3 id=&quot;减少等待&quot;&gt;减少等待&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;减少IO量&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;SQL/index，使用合适的索引减少扫描的行数（需平衡索引的正收益和维护开销，空间换时间）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;提升IO处理能力&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;加cache/加磁盘/SSD&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1179590/201905/1179590-20190527220402693-1264789500.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;减少计算&quot;&gt;减少计算&lt;/h3&gt;
&lt;h4 id=&quot;减少逻辑运算量&quot;&gt;减少逻辑运算量&lt;/h4&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;em&gt;避免使用函数&lt;/em&gt;&lt;/strong&gt;，将运算转移至易扩展的应用服务器中&lt;br/&gt;如substr等字符运算，dateadd/datesub等日期运算，abs等数学函数&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;减少排序&lt;/em&gt;&lt;/strong&gt;，利用索引取得有序数据或避免不必要排序&lt;br/&gt;如union all代替 union，order by 索引字段等&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;禁止类型转换&lt;/em&gt;&lt;/strong&gt;，使用合适类型并保证传入参数类型与数据库字段类型绝对一致&lt;br/&gt;如数字用tiny/int/bigint等，必需转换的在传入数据库之前在应用中转好&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;简单类型&lt;/em&gt;&lt;/strong&gt;，尽量避免复杂类型，降低由于复杂类型带来的附加运算。更小的数据类型占用更少的磁盘、内存、cpu缓存和cpu周期&lt;/li&gt;
&lt;li&gt;....&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h4 id=&quot;减少逻辑io量&quot;&gt;减少逻辑IO量&lt;/h4&gt;
&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1179590/201905/1179590-20190527220428944-1005198827.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;减少query请求量非数据库本身&quot;&gt;减少query请求量（非数据库本身）&lt;/h4&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;em&gt;适当缓存&lt;/em&gt;&lt;/strong&gt;，降低缓存数据粒度，对静态并被频繁请求的数据进行适当的缓存&lt;br/&gt;如用户信息，商品信息等&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;优化实现&lt;/em&gt;&lt;/strong&gt;，尽量去除不必要的重复请求&lt;br/&gt;如禁止同一页面多次重复请求相同数据的问题，通过跨页面参数传递减少访问等&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;合理需求&lt;/em&gt;&lt;/strong&gt;，评估需求产出比，对产出比极端底下的需求合理去除&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;....&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1179590/201905/1179590-20190527220447492-64921986.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;升级cpu&quot;&gt;升级cpu&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;参考&lt;/em&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;em&gt;《高性能MySQL》&lt;/em&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;em&gt;《图解性能优化》&lt;/em&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;em&gt;大部分整理自《MySQL Tuning For CPU Bottleneck》&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 27 May 2019 14:07:00 +0000</pubDate>
<dc:creator>Jia-Xin</dc:creator>
<og:description>[toc] 谁在消耗cpu? 用户+系统+IO等待+软硬中断+空闲 祸首是谁？ 用户 用户空间CPU消耗，各种逻辑运算 正在进行大量tps 函数/排序/类型转化/逻辑IO访问... 用户空间消耗大量c</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/YangJiaXin/p/10933458.html</dc:identifier>
</item>
</channel>
</rss>