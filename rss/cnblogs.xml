<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>快速筛出topK的快速选择算法和BFPRT优化 - TechFlow2019</title>
<link>http://www.cnblogs.com/techflow/p/12370356.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/techflow/p/12370356.html</guid>
<description>&lt;p&gt;本文始发于个人公众号：&lt;strong&gt;TechFlow&lt;/strong&gt;，原创不易，求个关注&lt;/p&gt;

&lt;p&gt;在之前Python系列当中，我们介绍了heapq这个库的用法，它可以在&lt;span class=&quot;math inline&quot;&gt;\(O(nlogn)\)&lt;/span&gt;的时间里筛选出前K大或者前K小的元素。今天我们一起来看一个可以更快实现选择的快速选择算法。&lt;/p&gt;

&lt;h2 id=&quot;思维推导&quot;&gt;思维推导&lt;/h2&gt;

&lt;p&gt;在公布答案之前，我想先带着大家试着推导一下解法。这其实才是算法能力的精髓，即是应用已知能力解决未知问题的能力。我们学的各种各样的算法都可以看成是已知能力，已知能力越多，说明能力的边界越广，也就意味着理论上可以解决的问题也就越多。相比已知能力，解决问题的能力同样重要，尤其是当我们有了一定的基础之后，这一点甚至更加重要。因为有了这项能力，在一些极端情况下我们甚至可以自己推导出新算法，也即是开创和创新。&lt;/p&gt;
&lt;p&gt;假设当下我们并不知道正确的解法是什么，我们想要尽可能快地找到前K大的元素。如果一个一个找这个过程会很慢，除非我们可以做到&lt;span class=&quot;math inline&quot;&gt;\(O(1)\)&lt;/span&gt;的查找。显然这是不可能的，因为即使是平衡树这类快速查找的数据结构，单词查找也需要&lt;span class=&quot;math inline&quot;&gt;\(O(logn)\)&lt;/span&gt;。所以一个一个找是不行的。那么就只剩下一批一批找，批量查找又有两种，一种是直接查找K个，还有一种是多次查找，最后得到正解。&lt;/p&gt;
&lt;p&gt;我们并不知道哪种方法更靠谱，但是第一种看起来不太可行，因为它就是问题本身，第二种方法看起来稍微可行一些。在这个问题下，我们并没有多余的信息，想要直接查找K个元素应该不太容易。所以可能通过多次查找得到解是比较好的方法。多次查找也可以简单分为两种情况，一种是每次查找一批，最后合并在一起，还有一种是每次缩小查找的范围，最后锁定答案。&lt;/p&gt;
&lt;p&gt;到这里，如果你对分治算法熟悉的话，你会觉得它和分治算法的应用场景很相似。我们想要求解一个比较大的问题，但是直接求解很困难，所以我们将它拆解，将大问题拆解成小问题，通过对小问题的解决来搞定原本的大问题。&lt;/p&gt;
&lt;p&gt;我们目前比较熟悉的分治算法好像只有归并排序和快速排序这两个，我们可以试着把这两个算法往这个问题上套。归并排序核心思路是每次将数组一分为二，然后通过这两个数组归并的过程找到我们想要的解法。这个方案可行，但是和排序并没有区别。我们文章开头就已经说过了，我们想要寻找的是比排序更快的算法。再看快排，它每次是设置一个标杆，然后对数组当中的元素进行调整，保证比标杆小的元素都在它的左边，比它大的都在它的右边。标杆最后在的位置就是数据有序之后它正确的位置。这个方法好像和我们想要的很接近。&lt;/p&gt;
&lt;p&gt;于是，我们就这样顺藤摸瓜，找到了正确的方法。当然实际的思考过程可能要比这个复杂，考虑的情况也会更多，但是总体的思维推导过程应该是差不多的。同样是解题，新手往往靠灵光一闪，而高手都是有一个完整的思维链。很多算法问题看起来一头雾水，但其实是有迹可循的。训练出一个思维模型来寻找正确的解法是新手通往高手的必经之路，也是算法能力的核心。&lt;/p&gt;

&lt;h2 id=&quot;算法原理&quot;&gt;算法原理&lt;/h2&gt;

&lt;p&gt;我们来仔细分析一下，一次快速排序的调整之后，我们可以确定标杆的位置，这样一来就有三种情况。第一种，它所在的位置刚好是K，说明它前面的这一段数组就是答案，直接返回即可。如果它小于K，说明这个标杆取小了，我们应该在它右侧的数组当中重新选择一个标杆。如果它大于K说明这个标杆取大了，我们可以直接忽略它右侧的元素，因为它右侧的元素一定不在答案里。&lt;/p&gt;
&lt;p&gt;我们可以参考一下下面这张图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/2/27/1708416d2c6341b2?w=402&amp;amp;h=511&amp;amp;f=png&amp;amp;s=14206&quot;/&gt;&lt;/p&gt;
&lt;p&gt;思路有了，代码就不难写了：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def quick_select_without_optimizer(arr, k):
    n = len(arr)
    # 如果k大于n，没啥好说的，直接返回
    if k &amp;gt;= n:
        return arr

    # 缓存
    buffer = []
    while arr:
        # 选择最后一个元素作为标杆
        mark = arr.pop()
        less, greater = [], []
        # 遍历数组，将元素分为less和greater
        for x in arr:
            if x &amp;lt;= mark:
                less.append(x)
            else:
                greater.append(x)
        # 判断三种情况，如果相等直接返回
        if len(less) == k:
            return less
        # 如果小于，将less存入buffer，因为它一定是答案的一部分，可以简化计算
        elif len(less) &amp;lt; k:
            buffer += less
            # k要减去less的长度
            k -= len(less)
            arr = [mark] + greater
        else:
            # 如果大于，直接舍弃右边
            arr = less
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;复杂度分析&quot;&gt;复杂度分析&lt;/h2&gt;

&lt;p&gt;写完了代码，我们来分析一下算法的复杂度。有些同学可能会有些疑惑，这个算法和快排基本上一样，为什么会更快呢？&lt;/p&gt;
&lt;p&gt;这是因为我们每次迭代的过程中，数组都会被舍弃一部分，我们把完整的搜索树画出来大概是下面这个样子。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/2/27/1708416d38586473?w=491&amp;amp;h=272&amp;amp;f=png&amp;amp;s=5773&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，虽然总的迭代次数还是&lt;span class=&quot;math inline&quot;&gt;\(log_2n\)&lt;/span&gt;次，但是每一层当中遍历的元素个数不再是n。我们假设每次迭代数组的长度都会折损一半，到数组长度等于1的时候结束。我们把每一层遍历的长度全部相加，就得到了一个等比数列：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[1, 2, 4, \cdots, n\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这个等比数列的长度是&lt;span class=&quot;math inline&quot;&gt;\(log_2n\)&lt;/span&gt;，我们套用等比数列求和公式：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\displaystyle S=\frac{a_1(1-q^n)}{1-q}=\frac{1(1-2n)}{1-2}\approx 2n\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;也就是说虽然它的形式看起来和快排很接近，但是由于我们在遍历的过程当中，每次都会缩小遍历的范围，所以整体的复杂度控制在了&lt;span class=&quot;math inline&quot;&gt;\(O(n)\)&lt;/span&gt;。当然这也只是理想情况下的复杂度，一般情况下随着数据分布的不同，实际的复杂度也会稍有浮动。可以理解成乘上了一个浮动的常数。&lt;/p&gt;
&lt;p&gt;之前我们分析快排的时候曾经得出过结论，如果原始数组是逆序的，那么快排的复杂度会退化到&lt;span class=&quot;math inline&quot;&gt;\(O(n^2)\)&lt;/span&gt;。我们当前的快速选择算法和快排算法几乎如出一辙，整个的思路是一样的，也就是说，在数组是逆序的情况下同样会遇到复杂度降级的问题。不过好在这个问题并不是不可解的，我们下面就来分析一下关于这种情况的优化。&lt;/p&gt;

&lt;h2 id=&quot;优化探索&quot;&gt;优化探索&lt;/h2&gt;

&lt;p&gt;优化目标很明显，就是极端情况下复杂度会出现降级的情况。问题出现的原因也已经知道了，是由于数组逆序，并且我们默认选择最后一个元素作为标杆。所以想要解决这个问题的入手点就有两个，一个是数组逆序的情况，一个是标杆的选择。&lt;/p&gt;
&lt;p&gt;相比于标杆的选择来说，数组逆序情况的判断不太可取。因为对于不是严格逆序的数组，也一样可能出现复杂度很大的情况。如果我们通过逆序数来判断数组的逆序程度，又会带来额外的开销，所以只能从标杆的选择入手。之前我们默认选择最后一个元素，其实这并不是元素位置的问题，无论选择什么样的位置，都有可能出现对应的极端情况使得复杂度升级，所以简单地改变选择的位置是不能解决问题的，我们需要针对这个问题单独设计算法。&lt;/p&gt;
&lt;p&gt;一个比较简单的思路是我们可以选择首尾和中间三个位置的元素，然后选择其中第二大的元素作为标杆。这种方案实现简单，效果也不错，但是分析一下的话，其实没有从根本上解决问题，因为依然还是可能出现极端情况，比如首尾和中间刚好是三个最大的元素。虽然这个概率比单个元素出现最大降低了很多。还有一个问题是，这样选出来的标杆不能保证分割出来的数组是平衡的。&lt;/p&gt;

&lt;h2 id=&quot;bfprt算法&quot;&gt;BFPRT算法&lt;/h2&gt;

&lt;p&gt;这里要给大家介绍一个牛哄哄的算法，说它牛不是因为它很难，而是因为它真的很牛。它的名字叫BFPRT，是由Blum、Floyd、Pratt、Rivest、Tarjan五位大牛一起发明的。如果你读过《算法导论》的话，一定会找到其中好几个人的名字。该算法可以找到一个比较合适的标杆，用来在快排和快速选择的时候切分数组。&lt;/p&gt;
&lt;p&gt;算法的流程很简单，一共只有几个步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;判断数组元素是否大于5，如果小于5，对它进行排序，并返回数组的中位数&lt;/li&gt;
&lt;li&gt;如果元素大于5个，对数组进行分组，每5个元素分成一组，允许最后一个分组元素不足5个。&lt;/li&gt;
&lt;li&gt;对于每个分组，对它进行插入排序&lt;/li&gt;
&lt;li&gt;选择出每个分组排序之后的中位数，组成新的数组&lt;/li&gt;
&lt;li&gt;重复以上操作&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;算法思路很朴素，其实就是一个不断选择中位数的过程。我们先来证明它的正确性，我们假设最终选出来的数是x，一个长度为n的数组会产生n/5个分组。由于我们取的是中位数的中位数，所以在这n/5个分组当中，有一半的中位数小于x，还有一半大于x。在中位数大于它的分组当中至少有3个元素大于等于它，所以整体而言，至少有 n/10 * 3 = 0.3n的元素大于等于x，同理也可以证明有30%元素小于等于x。所以最坏的情况选出来的x是70%位置的数。&lt;/p&gt;
&lt;p&gt;最后，我们来分析一下它的复杂度，我们可以得到一个不等式：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\displaystyle T(n) \leq T(\frac{n}{5}) + T(\frac{7n}{10}) + cn\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;span class=&quot;math inline&quot;&gt;\(T(\frac{n}{5})\)&lt;/span&gt;是寻找&lt;span class=&quot;math inline&quot;&gt;\(\frac{n}{5}\)&lt;/span&gt;个中位数的复杂度，&lt;span class=&quot;math inline&quot;&gt;\(T(\frac{7n}{10})\)&lt;/span&gt;是递归的最坏的情况，即只能减少30%数组的长度。&lt;span class=&quot;math inline&quot;&gt;\(cn\)&lt;/span&gt;是我们使用插入排序进行多次排序的复杂度，这里的c是一个常数。&lt;/p&gt;
&lt;p&gt;我们很容易可以证明&lt;span class=&quot;math inline&quot;&gt;\(T(n)=T(\frac{n}{2}) + cn\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(T(n)=T(\frac{7n}{10}) + cn\)&lt;/span&gt;都是&lt;span class=&quot;math inline&quot;&gt;\(O(n)\)&lt;/span&gt;的复杂度，这里我们证明一下前者作为一个例子：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \displaystyle\begin{aligned} T(n) &amp;amp;= T(\frac{n}{2}) + cn \\ T(\frac{n}{2}) &amp;amp;= T(\frac{n}{4}) + \frac{cn}{2} \\ \vdots \\ T(2) &amp;amp;= T(1) + c \end{aligned} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们把这个式子累加起来，可以得到：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[T(n)=c(1 + 2 + 4 + \cdots + n) \approx 2cn\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;同理，我们也可以证明&lt;span class=&quot;math inline&quot;&gt;\(T(n)=T(\frac{7n}{10})+cn\)&lt;/span&gt;也是&lt;span class=&quot;math inline&quot;&gt;\(O(n)\)&lt;/span&gt;的算法，所以&lt;span class=&quot;math inline&quot;&gt;\(\displaystyle T(n) \leq T(\frac{n}{5}) + T(\frac{7n}{10}) + cn\)&lt;/span&gt;也是&lt;span class=&quot;math inline&quot;&gt;\(O(n)\)&lt;/span&gt;的算法。&lt;/p&gt;
&lt;p&gt;根据BFPRT算法的定义很容易写出代码：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def bfprt(arr, l=None, r=None):
    if l is None or r is None:
        l, r = 0, len(arr)
    length = r - l
    # 如果长度小于5，直接返回中位数
    if length &amp;lt;= 5:
        arr[l: r] = insert_sort(arr[l: r])
        return l + length // 2
    medium_num = l
    start = l
    # 否则每5个数分组
    while start + 5 &amp;lt; r:
        # 对每5个数进行插入排序
        arr[start: start + 5] = insert_sort(arr[start: start + 5])
        arr[medium_num], arr[start + 2] = arr[start + 2], arr[medium_num]
        medium_num += 1
        start += 5
    # 特殊处理最后不足5个的情况
    if start &amp;lt; r:
        arr[start:r] = insert_sort(arr[start:r])
        _l = r - start
        arr[medium_num], arr[start + _l // 2] = arr[start + _l // 2], arr[medium_num]
        medium_num += 1
    # 递归调用，对中位数继续求中位数
    return bfprt(arr, l, medium_num)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个代码写出来了之后，剩下的就容易了，改动量并不大，只需要加上两行即可。：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def quick_select(arr, k):
    n = len(arr)
    if k &amp;gt;= n:
        return arr

    # 获取标杆的下标
    mark = bfprt(arr)
    arr[mark], arr[-1] = arr[-1], arr[mark]
    buffer = []

    while arr:
        mark = arr.pop()
        less, greater = [], []
        for x in arr:
            if x &amp;lt;= mark:
                less.append(x)
            else:
                greater.append(x)
        if len(less) == k:
            return buffer + less
        elif len(less) &amp;lt; k:
            k -= len(less)
            buffer += less
            arr = [mark] + greater
        else:
            arr = less&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看代码的话和上面基本上没有什么差别，唯一的不同就是选择之前先获取了一下标杆。在这里我只是在一开始的时候调用了一次，当然也可以在while循环里每一次都调用，不过我个人觉得没什么必要，因为在获取标杆的时候，会将数组全部打乱，足够避免极端情况了。&lt;/p&gt;
&lt;p&gt;今天的文章篇幅有点长，但内容还可以，尤其是BFPRT算法，真的是非常经典，算得上是不复杂但是很巧妙了。感兴趣的同学可以了解一下它背后五个大佬的故事，估计比我的文章精彩得多。&lt;/p&gt;
&lt;p&gt;好了，今天的文章就是这些，如果觉得有所收获，请顺手扫码点个关注吧，你们的举手之劳对我来说很重要。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/2/27/1708418548054328?w=258&amp;amp;h=258&amp;amp;f=png&amp;amp;s=23988&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 27 Feb 2020 00:44:00 +0000</pubDate>
<dc:creator>TechFlow2019</dc:creator>
<og:description>本文始发于个人公众号： TechFlow ，原创不易，求个关注 在之前Python系列当中，我们介绍了heapq这个库的用法，它可以在$O(nlogn)$的时间里筛选出前K大或者前K小的元素。今天我们</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/techflow/p/12370356.html</dc:identifier>
</item>
<item>
<title>第2篇-如何编写一个面试时能拿的出手的开源项目？ - 归去来兮辞</title>
<link>http://www.cnblogs.com/extjs4/p/12370328.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/extjs4/p/12370328.html</guid>
<description>
&lt;p&gt;在&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/extjs4/p/12342287.html&quot;&gt;第1篇-如何编写一个面试时能拿的出手的开源项目？&lt;/a&gt;博文中曾详细介绍过编写一个规范开源项目所要遵循的规范，并且初步实现了博主自己的开源项目&lt;a href=&quot;https://github.com/mazhimazh/JavacASTViewer&quot; target=&quot;_blank&quot;&gt;Javac AST View插件&lt;/a&gt;，不过只搭建了项目开发的基本框架，树状结构的数据模型也是硬编码的，本篇博文将继续完善这个项目，实现动态从Eclipse编辑器中读取Java源代码，并在JavacASTViewer视图中展现Javac编译器的抽象语法树。实现过程中需要调用Javac的API接口获取抽象语法树，同时遍历这个抽象语法树，将其转换为Eclipse插件的树形视图所识别的数据模型。&lt;/p&gt;
&lt;p&gt;下面我们基于上一篇博文所搭建的框架上继续进行开发。&lt;/p&gt;
&lt;p&gt;首先需要对插件树形视图提供的数据模型进行修改，添加一些必要的属性，具体的源代码实现如下： &lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
package astview;

import java.util.ArrayList;
import java.util.List;

public class JavacASTNode {

        private String name;
        private String type;
        private String value;

        private List&amp;lt;JavacASTNode&amp;gt; children = null;
        private JavacASTNode parent = null;

        public JavacASTNode(String name, String type) {
                this.name = name;
                this.type = type;
                children = new ArrayList&amp;lt;JavacASTNode&amp;gt;();
        }

        public JavacASTNode(String name, String type, String value) {
                this(name, type);
                this.value = value;
        }

        public JavacASTNode() {
                children = new ArrayList&amp;lt;JavacASTNode&amp;gt;();
        }

        // 省略各属性的get与set方法

        public String toString() {
                String display = name;
                if (type != null &amp;amp;&amp;amp; type.length() &amp;gt; 0) {
                        display = display + &quot;={&quot; + type.trim() + &quot;}&quot;;
                } else {
                        display = display + &quot;=&quot;;
                }
                if (value != null &amp;amp;&amp;amp; value.length() &amp;gt; 0) {
                        display = display + &quot; &quot; + value.trim();
                }
                return display;
        }

}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中property表示属性名，如JCCompilationUnit树节点下有packageAnnotations、pid、defs等表示子树节点的属性；type为属性对应的定义类型；value为属性对应的值，这个值可选。这3个值在Eclipse树形中的显示格式由toString()方法定义。 &lt;/p&gt;
&lt;p&gt;现在我们需要修改内容提供者ViewContentProvider类中的getElements()方法，在这个方法中将Javac的抽象语法树转换为使用JavacASTNode表示的、符合Eclipse树形视图要求的数据模型。修改后的方法源代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
public Object[] getElements(Object inputElement) {
　　JavacASTNode root = null;
　　if(inputElement instanceof JCCompilationUnit) {
            JavacASTVisitor visitor = new JavacASTVisitor();
　　　　 root  = visitor.traverse((JCCompilationUnit)inputElement);
        }
　　return new JavacASTNode[] {root};
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Javac用JCCompilationUnit来表示编译单元，可以简单认为一个Java源文件对应一个JCCompilationUnit实例。这里使用了JDK1.8的tools.jar包中提供的API，因为Javac的源代码包被打包到了这个压缩包中，所以需要将JDK1.8安装目录下的lib目录中的tools.jar引到项目中来。&lt;/p&gt;
&lt;p&gt;JCCompilationUnit也是抽象语法树的根节点，遍历这个语法树并将每个语法树节点用JavacASTNode表示。使用访问者模式遍历抽象语法树。创建JavacASTVisitor类并继承TreeVisitor接口，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
package astview;

import java.util.Set;
import javax.lang.model.element.Modifier;
import com.sun.source.tree.*;
import com.sun.tools.javac.code.TypeTag;
import com.sun.tools.javac.tree.JCTree;
import com.sun.tools.javac.tree.JCTree.*;
import com.sun.tools.javac.util.List;

public class JavacASTVisitor implements TreeVisitor&amp;lt;JavacASTNode, Void&amp;gt; { 
        ...
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;继承的接口TreeVisitor定义在com.sun.source.tree包下，是Javac为开发者提供的、遍历抽象语法树的访问者接口，接口的源代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;89&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
public interface TreeVisitor&amp;lt;R,P&amp;gt; {
    R visitAnnotatedType(AnnotatedTypeTree node, P p);
    R visitAnnotation(AnnotationTree node, P p);
    R visitMethodInvocation(MethodInvocationTree node, P p);
    R visitAssert(AssertTree node, P p);
    R visitAssignment(AssignmentTree node, P p);
    R visitCompoundAssignment(CompoundAssignmentTree node, P p);
    R visitBinary(BinaryTree node, P p);
    R visitBlock(BlockTree node, P p);
    R visitBreak(BreakTree node, P p);
    R visitCase(CaseTree node, P p);
    R visitCatch(CatchTree node, P p);
    R visitClass(ClassTree node, P p);
    R visitConditionalExpression(ConditionalExpressionTree node, P p);
    R visitContinue(ContinueTree node, P p);
    R visitDoWhileLoop(DoWhileLoopTree node, P p);
    R visitErroneous(ErroneousTree node, P p);
    R visitExpressionStatement(ExpressionStatementTree node, P p);
    R visitEnhancedForLoop(EnhancedForLoopTree node, P p);
    R visitForLoop(ForLoopTree node, P p);
    R visitIdentifier(IdentifierTree node, P p);
    R visitIf(IfTree node, P p);
    R visitImport(ImportTree node, P p);
    R visitArrayAccess(ArrayAccessTree node, P p);
    R visitLabeledStatement(LabeledStatementTree node, P p);
    R visitLiteral(LiteralTree node, P p);
    R visitMethod(MethodTree node, P p);
    R visitModifiers(ModifiersTree node, P p);
    R visitNewArray(NewArrayTree node, P p);
    R visitNewClass(NewClassTree node, P p);
    R visitLambdaExpression(LambdaExpressionTree node, P p);
    R visitParenthesized(ParenthesizedTree node, P p);
    R visitReturn(ReturnTree node, P p);
    R visitMemberSelect(MemberSelectTree node, P p);
    R visitMemberReference(MemberReferenceTree node, P p);
    R visitEmptyStatement(EmptyStatementTree node, P p);
    R visitSwitch(SwitchTree node, P p);
    R visitSynchronized(SynchronizedTree node, P p);
    R visitThrow(ThrowTree node, P p);
    R visitCompilationUnit(CompilationUnitTree node, P p);
    R visitTry(TryTree node, P p);
    R visitParameterizedType(ParameterizedTypeTree node, P p);
    R visitUnionType(UnionTypeTree node, P p);
    R visitIntersectionType(IntersectionTypeTree node, P p);
    R visitArrayType(ArrayTypeTree node, P p);
    R visitTypeCast(TypeCastTree node, P p);
    R visitPrimitiveType(PrimitiveTypeTree node, P p);
    R visitTypeParameter(TypeParameterTree node, P p);
    R visitInstanceOf(InstanceOfTree node, P p);
    R visitUnary(UnaryTree node, P p);
    R visitVariable(VariableTree node, P p);
    R visitWhileLoop(WhileLoopTree node, P p);
    R visitWildcard(WildcardTree node, P p);
    R visitOther(Tree node, P p);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;定义的泛型类型中，R可以指定返回类型，而P可以额外为访问者方法指定参数。我们需要访问者方法返回转换后的JavacASTNode节点，所以R指定为了JavacASTNode类型，参数不需要额外指定，所以直接使用Void类型即可。&lt;/p&gt;
&lt;p&gt;在TreeVisitor中定义了许多访问者方法，涉及到了抽象语法树的每个节点，这些节点在《深入解析Java编译器：源码剖析与实例详解》一书中详细做了介绍，有兴趣的可以参考。&lt;/p&gt;
&lt;p&gt;接口中定义的访问者方法需要在JavacASTVisitor类中实现，例如对于visitCompilationUnit()方法、visitClass()方法、visitImport()方法及visitIdentifier()方法的具体实现如下： &lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;55&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
@Override
public JavacASTNode visitCompilationUnit(CompilationUnitTree node, Void p) {
        JCCompilationUnit t = (JCCompilationUnit) node;
        JavacASTNode currnode = new JavacASTNode();
        currnode.setProperty(&quot;root&quot;);
        currnode.setType(t.getClass().getSimpleName());

        traverse(currnode,&quot;packageAnnotations&quot;,t.packageAnnotations);
        traverse(currnode,&quot;pid&quot;,t.pid);
        traverse(currnode,&quot;defs&quot;,t.defs);

        return currnode;
}

@Override
public JavacASTNode visitClass(ClassTree node, Void p) {
        JCClassDecl t = (JCClassDecl) node;
        JavacASTNode currnode = new JavacASTNode();

        traverse(currnode,&quot;extending&quot;,t.extending);
        traverse(currnode,&quot;implementing&quot;,t.implementing);
        traverse(currnode,&quot;defs&quot;,t.defs);
        
        return currnode;
}

public JavacASTNode visitImport(ImportTree node, Void curr) {
        JCImport t = (JCImport) node;
        JavacASTNode currnode = new JavacASTNode();
        
        traverse(currnode,&quot;qualid&quot;,t.qualid);

        return currnode;
}

@Override
public JavacASTNode visitIdentifier(IdentifierTree node, Void p) {
        JCIdent t = (JCIdent) node;
        JavacASTNode currnode = new JavacASTNode();
        JavacASTNode name = new JavacASTNode(&quot;name&quot;, t.name.getClass().getSimpleName(), t.name.toString());
        currnode.addChild(name);
        name.setParent(currnode);
        return currnode;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将JCCompilationUnit节点转换为JavacASTNode节点，并且调用traverse()方法继续处理子节点packageAnnotations、pid和defs。其它方法类似，这里不再过多介绍。更多关于访问者方法的实现可查看我的开源项目，地址为&lt;a href=&quot;https://github.com/mazhimazh/JavacASTViewer&quot; target=&quot;_blank&quot;&gt;https://github.com/mazhimazh/JavacASTViewer&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;tranverse()方法的实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
public JavacASTNode traverse(JCTree tree) {
        if (tree == null)
                return null;
        return tree.accept(this, null);
}


public void traverse(JavacASTNode parent, String property, JCTree currnode) {
        if (currnode == null)
                return;

        JavacASTNode sub = currnode.accept(this, null);
        sub.setProperty(property);
        if (sub.getType() == null) {
                sub.setType(currnode.getClass().getSimpleName());
        }
        sub.setParent(parent);
        parent.addChild(sub);

}

public &amp;lt;T extends JCTree&amp;gt; void traverse(JavacASTNode parent, String property, List&amp;lt;T&amp;gt; trees) {
        if (trees == null || trees.size() == 0)
                return;

        JavacASTNode defs = new JavacASTNode(property, trees.getClass().getSimpleName());
        defs.setParent(parent);
        parent.addChild(defs);

        for (int i = 0; i &amp;lt; trees.size(); i++) {
                JCTree tree = trees.get(i);
                JavacASTNode def_n = tree.accept(this, null);
                def_n.setProperty(i + &quot;&quot;);
                if (def_n.getType() == null) {
                        def_n.setType(tree.getClass().getSimpleName());
                }
                def_n.setParent(defs);

                defs.addChild(def_n);
        }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为了方便对单个JCTree及列表List进行遍历，在JavacASTVisitor 类中定义了3个重载方法。在遍历列表时，列表的每一项的属性被指定为序号。&lt;/p&gt;
&lt;p&gt;这样我们就将Javac的抽象语法树转换为Eclipse树形视图所需要的数据模型了。下面我们就来应用这个数据模型。&lt;/p&gt;
&lt;p&gt;在JavacASTViewer插件启动时，读取Eclipse编辑器中的Java源代码，修改JavacASTViewer类的createPartControl()方法，具体实现如下： &lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
public void createPartControl(Composite parent) {
        
        fViewer = new TreeViewer(parent, SWT.SINGLE);   
        fViewer.setLabelProvider(new ViewLabelProvider());
        fViewer.setContentProvider(new ViewContentProvider());
        // fViewer.setInput(getSite());
        
        try {
                IEditorPart part= EditorUtility.getActiveEditor();
                if (part instanceof ITextEditor) {
                        setInput((ITextEditor) part);
                }
        } catch (CoreException e) {
                // ignore
        }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用EditorUtility工具类的getActiveEditor()方法获取代表Eclipse当前激活的编辑器窗口，然后调用setInput()方法，这个方法的实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
public void setInput(ITextEditor editor) throws CoreException {
        if (editor != null) {
                fEditor = editor;
                is = EditorUtility.getURI(editor);
                internalSetInput(is);
        }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用EditorUtility工具类的getURI()方法从当前激活的编辑器中获取Java源代码文件的路径，这个工具类的实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
package astview;

import java.net.URI;
import org.eclipse.core.resources.IFile;
import org.eclipse.ui.IEditorPart;
import org.eclipse.ui.IWorkbenchPage;
import org.eclipse.ui.IWorkbenchWindow;
import org.eclipse.ui.PlatformUI;

public class EditorUtility {
        private EditorUtility() {
                super();
        }

        public static IEditorPart getActiveEditor() {
                IWorkbenchWindow window = PlatformUI.getWorkbench().getActiveWorkbenchWindow();
                if (window != null) {
                        IWorkbenchPage page = window.getActivePage();
                        if (page != null) {
                                return page.getActiveEditor();
                        }
                }
                return null;
        }

        public static URI getURI(IEditorPart part) {
                IFile file = part.getEditorInput().getAdapter(IFile.class);
                return file.getLocationURI();
        }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;继续看setInput()方法的实现，得到Java源文件的路径后，就需要调用Javac相关的API来解析这个Java源文件了，internalSetInput()方法的实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
private JCCompilationUnit internalSetInput(URI is) throws CoreException {
        JCCompilationUnit root = null;
        try {
                root= createAST(is);
                resetView(root);
                if (root == null) {
                        setContentDescription(&quot;AST could not be created.&quot;);
                        return null;
                }
        } catch (RuntimeException e) {
                e.printStackTrace();
        }
        return root;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用createAST()方法获取抽象语法树，调用resetView()方法为Eclipse的树形视图设置数据来源。&lt;/p&gt;
&lt;p&gt;createAST()方法的实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
JavacFileManager dfm = null;
JavaCompiler comp = null;
private JCCompilationUnit createAST(URI is) {
        if (comp == null) {
                Context context = new Context();
                JavacFileManager.preRegister(context);
                JavaFileManager fileManager = context.get(JavaFileManager.class);
                comp = JavaCompiler.instance(context);
                dfm = (JavacFileManager) fileManager;
        }
                
        JavaFileObject jfo = dfm.getFileForInput(is.getPath());
        JCCompilationUnit tree = comp.parse(jfo);
        return tree;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用Javac相关的API解析Java源代码，然后返回抽象语法树，在resetView()方法中将这个抽象语法树设置为树形视图的输入，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
private void resetView(JCCompilationUnit root) {
     fViewer.setInput(root);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为为fViewer设置的数据模型为JCCompilationUnit，所以当树形视图需要数据时，会调用JavacASTNode节点中的getElements()方法，接收到的参数inputElement的类型就是JCCompilationUnit的，这个方法我们在前面介绍过，这里不再介绍。&lt;/p&gt;

&lt;p&gt;现在编写个实例来查看JavacASTViewer的显示效果，实例如下： &lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
package test;

import java.util.ArrayList;
import java.util.List;

public class Test {
        List&amp;lt;String&amp;gt; a = new ArrayList&amp;lt;String&amp;gt;();
        String b;
        int c;

        public void test() {
                a.add(&quot;test&quot;);
                b = &quot;hello word!&quot;;
                c = 1;
        }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;JavacASTViewer的显示效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/222237/202002/222237-20200226204108482-599661522.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;后续文章将继续完善这个项目，包括为JavacASTViewer增加重新读取编辑器视图内容的“读入”按钮，双击抽象语法树的某个语法树节点后，Eclipse的编辑视图自动选中所对应的Java源代码，&lt;/p&gt;
&lt;p&gt;增加测试用例及发布Eclipse插件安装地址等等。　 &lt;/p&gt;

&lt;p&gt; 参考：&lt;/p&gt;
&lt;p&gt;（1）《深入解析Java编译器：源码剖析与实例详解》一书&lt;/p&gt;
&lt;p&gt;（2）《Eclipse插件开发学习笔记》一书&lt;/p&gt;

</description>
<pubDate>Thu, 27 Feb 2020 00:15:00 +0000</pubDate>
<dc:creator>归去来兮辞</dc:creator>
<og:description>在第1篇-如何编写一个面试时能拿的出手的开源项目？博文中曾详细介绍过编写一个规范开源项目所要遵循的规范，并且初步实现了博主自己的开源项目Javac AST View插件，不过只搭建了项目开发的基本框架</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/extjs4/p/12370328.html</dc:identifier>
</item>
<item>
<title>有了这些开源动效项目，设计和开发不再相杀只剩相爱 - 削微寒</title>
<link>http://www.cnblogs.com/xueweihan/p/12368377.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xueweihan/p/12368377.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/202002/759200-20200226182635525-1010428549.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;作者：HelloGitHub-&lt;strong&gt;小鱼干&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不知道各位前端 &amp;amp; 移动端同学拿到 UI 同学给你的动效图，心里是什么想法。小鱼干曾混迹某个国内技术论坛，里面的大佬们对动效有惊人的一致评论：&lt;code&gt;砍死设计师系列&lt;/code&gt;，&lt;code&gt;花里胡哨系列&lt;/code&gt;，&lt;code&gt;有时间再做&lt;/code&gt;，&lt;code&gt;一点都不实用&lt;/code&gt;…统一下，大部分的开发对动效的感觉是没啥卵用徒增工作量的 Task，不过也有部分开发小伙伴觉得 App / Web 大多数时候并不是都注重的是功能，功能都能实现的情况下，想要博得用户，UI（动效） 也很重要。&lt;/p&gt;
&lt;p&gt;那么有什么方法让产品锦上添花又不会增加过多的开发量呢？答案很简单：就是开源的动效库，这里小鱼干推荐几款 BlingBling 的动效库，如果你有别的好收藏记得在评论区或者 HelloGitHub issue 区交流下心得哟~&lt;/p&gt;
&lt;h2 id=&quot;d-动态墙slideshow&quot;&gt;1. 3D 动态墙：Slideshow&lt;/h2&gt;
&lt;p&gt;Slideshow 是一个采用 SceneKit 写的 3D 动态图片墙，虽然效果很酷炫但是性能便不是很好，如果你要是使用该动效建议优化下。&lt;/p&gt;
&lt;blockquote readability=&quot;1.4814814814815&quot;&gt;
&lt;p&gt;GitHub 地址：&lt;a href=&quot;https://github.com/folio-sec/Slideshow&quot; class=&quot;uri&quot;&gt;https://github.com/folio-sec/Slideshow&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/202002/759200-20200226182906494-998084798.gif&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;定制动画ddanimatedswitch&quot;&gt;2. 定制动画：DDAnimatedSwitch&lt;/h2&gt;
&lt;p&gt;DDAnimatedSwitch 是一个可定制的开关动画。它支持你使用任何帧动画来当 icon，你不仅可以为开关设置动画，还可以为拇指设置动画，可播放、调整比例大小、循环播放，在播放速度方面支持你加快，放慢和倒转动画。&lt;/p&gt;
&lt;blockquote readability=&quot;1.2903225806452&quot;&gt;
&lt;p&gt;GitHub 地址：&lt;a href=&quot;https://github.com/d-dotsenko/DDAnimatedSwitch&quot; class=&quot;uri&quot;&gt;https://github.com/d-dotsenko/DDAnimatedSwitch&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/202002/759200-20200226182922262-1856890331.gif&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;加载进程动画loady&quot;&gt;3. 加载进程动画：Loady&lt;/h2&gt;
&lt;p&gt;Loady 是一个小动效库用来定制加载按钮动画，可用于显示 UI 中 Button 的加载，支持你自定义样式，它本身提供有 6 种不同的加载样式，4 种动画状态（成功加载、加载失败、加载中，正常加载）。&lt;/p&gt;
&lt;blockquote readability=&quot;1.3559322033898&quot;&gt;
&lt;p&gt;GitHub 地址：&lt;a href=&quot;https://github.com/farshadjahanmanesh/loady&quot; class=&quot;uri&quot;&gt;https://github.com/farshadjahanmanesh/loady&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/202002/759200-20200226182947153-1626653202.gif&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;登录动画logincritter&quot;&gt;4. 登录动画：LoginCritter&lt;/h2&gt;
&lt;p&gt;LoginCritter 是一个响应文本交互的动画，它会跟踪用户的操作轨迹同你交互。LoginCritter 使用多个 &lt;code&gt;UIPropertyAnimator&lt;/code&gt;，头部旋转是通过更新 &lt;code&gt;fractionComplete&lt;/code&gt; 属性来控制的。当用户输入时，程序会计算文本的长度和宽度。&lt;/p&gt;
&lt;blockquote readability=&quot;1.4285714285714&quot;&gt;
&lt;p&gt;GitHub 地址：&lt;a href=&quot;https://github.com/cgoldsby/LoginCritter&quot; class=&quot;uri&quot;&gt;https://github.com/cgoldsby/LoginCritter&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/202002/759200-20200226183014228-1898838247.gif&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;简洁之美sica&quot;&gt;5. 简洁之美：Sica&lt;/h2&gt;
&lt;p&gt;Sica 是一个顺序 / 并行执行的动画库，虽然它是个简单的动效库，但是它支持绝大部分的动效。&lt;/p&gt;
&lt;blockquote readability=&quot;1.6666666666667&quot;&gt;
&lt;p&gt;GitHub 地址：&lt;a href=&quot;https://github.com/cats-oss/Sica&quot; class=&quot;uri&quot;&gt;https://github.com/cats-oss/Sica&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/202002/759200-20200226183029653-1890595373.gif&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;指示小组件arrows&quot;&gt;6. 指示小组件：Arrows&lt;/h2&gt;
&lt;p&gt;Arrows 是一种下拉动画中指示箭头小组件，它代表了三种不同的箭头状态： up / down / middle。&lt;/p&gt;
&lt;blockquote readability=&quot;1.4545454545455&quot;&gt;
&lt;p&gt;GitHub 地址：&lt;a href=&quot;https://github.com/antoniocasero/Arrows&quot; class=&quot;uri&quot;&gt;https://github.com/antoniocasero/Arrows&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/202002/759200-20200226183047187-306042851.gif&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;多个动效要收藏animate.css&quot;&gt;7. 多个动效要收藏：Animate.css&lt;/h2&gt;
&lt;p&gt;Animate.css 是一个 CSS 的跨浏览器的动画，涵盖了常见的动效，直接调用省时省力，此外它有在线版支持你搜索特定的效果：&lt;a href=&quot;https://daneden.github.io/animate.css/&quot; class=&quot;uri&quot;&gt;https://daneden.github.io/animate.css/&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;1.4814814814815&quot;&gt;
&lt;p&gt;GitHub 地址：&lt;a href=&quot;https://github.com/daneden/animate.css&quot; class=&quot;uri&quot;&gt;https://github.com/daneden/animate.css&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/202002/759200-20200226183101143-136302990.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;加载插件flutter_easyloading&quot;&gt;8. 加载插件：flutter_easyloading&lt;/h2&gt;
&lt;p&gt;flutter_easyloading 是一个简单易用的 Flutter Loading 插件，包含 23 种动画效果。&lt;/p&gt;
&lt;blockquote readability=&quot;1.2121212121212&quot;&gt;
&lt;p&gt;GitHub 地址：&lt;a href=&quot;https://github.com/huangjianke/flutter_easyloading&quot; class=&quot;uri&quot;&gt;https://github.com/huangjianke/flutter_easyloading&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/202002/759200-20200226183112944-100970280.gif&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;菜单栏切换动效ltabview&quot;&gt;9. 菜单栏切换动效：LTabView&lt;/h2&gt;
&lt;p&gt;LTabView 是一个作者见到某个 GIF 动效之后自己实现的带动画的 TabView 项目。&lt;/p&gt;
&lt;blockquote readability=&quot;1.4285714285714&quot;&gt;
&lt;p&gt;GitHub 地址：&lt;a href=&quot;https://github.com/Mr-XiaoLiang/LTabView&quot; class=&quot;uri&quot;&gt;https://github.com/Mr-XiaoLiang/LTabView&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/202002/759200-20200226183124743-939559974.gif&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;又见加载之集大成者loadingindicator&quot;&gt;10. 又见加载之集大成者：LoadingIndicator&lt;/h2&gt;
&lt;p&gt;LoadingIndicator 是一个开箱即用的 loading 加载库，包含 32 个不同类型动画，灵感来源于 loaders.css 和 NVActivityIndicatorView。&lt;/p&gt;
&lt;blockquote readability=&quot;1.3333333333333&quot;&gt;
&lt;p&gt;GitHub 地址：&lt;a href=&quot;https://github.com/TinoGuo/loading_indicator&quot; class=&quot;uri&quot;&gt;https://github.com/TinoGuo/loading_indicator&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/202002/759200-20200226183140670-1398705309.gif&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;最后&quot;&gt;最后&lt;/h2&gt;
&lt;p&gt;爱啦，爱啦。。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;HelloGitHub 交流群现已全面开放，添加微信号：HelloGitHub 为好友。可同前端、Java、Go…各界大佬谈笑风生、切磋技术~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/202002/759200-20200217165012919-1203910757.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关注公众号加入交流群&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 27 Feb 2020 00:13:00 +0000</pubDate>
<dc:creator>削微寒</dc:creator>
<og:description>作者：HelloGitHub 小鱼干 不知道各位前端 &amp;amp; 移动端同学拿到 UI 同学给你的动效图，心里是什么想法。小鱼干曾混迹某个国内技术论坛，里面的大佬们对动效有惊人的一致评论： ，`花里胡</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xueweihan/p/12368377.html</dc:identifier>
</item>
<item>
<title>解决掉你心中 js function与Function的关系的疑问 - 族语1996</title>
<link>http://www.cnblogs.com/aoximin/p/12369693.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/aoximin/p/12369693.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;在网上有很多关于js function 与 Function直接关系的文章。&lt;br/&gt;但是我感觉过于抽象化了，那么如何是具体化的解释？&lt;br/&gt;正文部分为个人理解部分，如有不对望指出。&lt;/p&gt;
&lt;h3 id=&quot;正文&quot;&gt;正文&lt;/h3&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;&amp;lt;script&amp;gt;
    if((function(){}).constructor === Function)
    {
        console.log(true);
    }
&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我写了一段这个代码，答案为true。&lt;br/&gt;这就是function 与 Function的关系。&lt;br/&gt;看下Function的定义:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Function 构造函数创建一个新的 Function 对象。直接调用此构造函数可用动态创建函数，但会遭遇来自 eval 的安全问题和相对较小的性能问题。然而，与 eval 不同的是，Function 构造函数只在全局作用域中运行。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后还给出了这样一个结论:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;每个 JavaScript 函数实际上都是一个 Function 对象。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重新理解一下，Function的定义。&lt;/p&gt;
&lt;p&gt;第一句话很好理解，就是可以创建一个Function对象。第二句好也好理解，就是会有安全漏洞和性能问题,详细部分可看eval的安全问题，至于为什么低效，官方解释是:因为使用后者创建的函数是跟其他代码一起解析的。&lt;br/&gt;第三句话，什么叫&quot;Function 构造函数只在全局作用域中运行&quot;?&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var func = new Function(&quot;alert(x+y);&quot;);
var test = function () {
    var x=1,y=2;
    func();
    eval(&quot;x+y&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就是func()运行会报错。而eval(&quot;x+y&quot;)是成功的。&lt;br/&gt;因为func()是在全局作用域中运行。&lt;br/&gt;如果是这样:&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var x=1,y=2;
var func = new Function(&quot;alert(x+y);&quot;);
var test = function () {
    var x=1,y=2;
    func();
    eval(&quot;x+y&quot;);
}

test();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么会弹出3；&lt;br/&gt;当然这里说eval是在局部变量中运行也比较绝对，因为eval的引用变量是在全局中运行的。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var global=eval;
global(&quot;x+y&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样就在全局中运行，好吧，这不是该篇的重点。&lt;br/&gt;那么这种Function 对象和申明函数有什么区别呢？前面已经说明了，Function对象是在全局中运行，而声明函数是在局部中运行。&lt;br/&gt;我找了一个例子:&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var x = 10;

function createFunction1() {
    var x = 20;
    return new Function('return x;'); // 这里的 x 指向最上面全局作用域内的 x
}

function createFunction2() {
    var x = 20;
    function f() {
        return x; // 这里的 x 指向上方本地作用域内的 x
    }
    return f;
}

var f1 = createFunction1();
console.log(f1());          // 10
var f2 = createFunction2();
console.log(f2());          // 20&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看到这里，以为结束了？下面是本文的核心思想部分。&lt;br/&gt;我们如何才能够，用function的方式建立出Function对象的效果？或者说我们如何模拟new Function() 到底发生了什么。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var x=1,y=2;
var func = new Function(&quot;alert(x+y);&quot;);
var func1= function ()
{
    alert(x+y);
}
console.log(func);
console.log(func1);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打印出来func,是一个匿名的函数。&lt;br/&gt;匿名函数自带是闭包效果，在这里我似乎找到了答案，现在我们就来模拟出new Function();&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function main() {
    var x = 5;
    var y = 6;
     FunctionObj = function () {
        alert(x + y);
    };

    function func() {
        var x = 1;
        var y = 2;
        var Newfunc = FunctionObj;
        Newfunc();
    }
    func();
}
main();
FunctionObj();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;弹出的结果是11,另一个弹出的还是11;&lt;br/&gt;在这里我假设启动的是main主函数，x与y是全局变量。&lt;br/&gt;然后在func中的:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var func = FunctionObj;
func();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;假设为new Function（），也就是说去假设构建一个Function 对象。&lt;br/&gt;这样实现的其实就是在全局变量中创建了FunctionObj变量，然后赋值给了func,然后再执行func的时候自然就在main变量中了，因为匿名函数本身就闭包。&lt;br/&gt;对应为:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var x=5;
var y=6;
function func()
{
    var x=1;
    var y=2;
    var NewFunc= new Function(&quot;alert(x+y)&quot;);
    NewFunc();
}
func();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;继续变化一下，模拟Function 做了什么:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var x=5;
var y=6;
function func()
{
    var x=1;
    var y=2;
    var NewFunc= Functionsimulation();
    NewFunc();
}
function Functionsimulation()
{
     var global=eval;
     return eval(&quot;(function(){return function(){alert(x+y)}})()&quot;);
}
func();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;弹出的结果依然是：11；&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;回过头来，再看一下这段话:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;每个 JavaScript 函数实际上都是一个 Function 对象。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;new Function 只是将匿名包，绑定到了一个全局变量了，这样它的this永远固定,运行时，永远是在全局中运行。&lt;br/&gt;至于声明函数，因为是动态的运行，所以我们访问的以局部优先，也可以理解为绑定的为局部变量。&lt;br/&gt;以上是个人理解，如有不对望指出。&lt;/p&gt;
</description>
<pubDate>Thu, 27 Feb 2020 00:05:00 +0000</pubDate>
<dc:creator>族语1996</dc:creator>
<og:description>前言 在网上有很多关于js function 与 Function直接关系的文章。 但是我感觉过于抽象化了，那么如何是具体化的解释？ 正文部分为个人理解部分，如有不对望指出。 正文 我写了一段这个代码</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/aoximin/p/12369693.html</dc:identifier>
</item>
<item>
<title>Chrome开发者工具使用指南 - 韩子卢</title>
<link>http://www.cnblogs.com/vvjiang/p/12370112.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/vvjiang/p/12370112.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;工欲善其事，必先利其器。&lt;/p&gt;
&lt;p&gt;在前端工作中，我们常常使用到Chrome开发者工具去做各种各样的事情。&lt;/p&gt;
&lt;p&gt;但是您真的了解这些开发者工具吗？&lt;/p&gt;
&lt;p&gt;官方文档还是挺详细的：&lt;a href=&quot;https://developers.google.cn/web/tools/chrome-devtools&quot;&gt;chrome-devtools文档&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;但是文档中仍然会有一些功能没有描述到和一笔带过。&lt;/p&gt;
&lt;p&gt;而我的这篇指南，会略过那些一目了然的功能以及一些容易替代的方案，写一写那些您可能不太了解的功能和文档描述不清的功能。&lt;/p&gt;
&lt;p&gt;阅读本篇文章需要有一定的前端基础。&lt;/p&gt;
&lt;h2 id=&quot;媒体查询功能&quot;&gt;媒体查询功能&lt;/h2&gt;
&lt;p&gt;Chrome开发者工具不仅可以调试web应用，还可以模拟各种终端设备。&lt;/p&gt;
&lt;p&gt;通过激活下图中红框部位开启设备工具栏。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/746209/202002/746209-20200227003642968-1415743577.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;工具栏可以切换模拟各种型号的设备，也可以通过自适应模式（Responsive）来调整视口。&lt;/p&gt;
&lt;p&gt;这里通过更多工具中的&lt;strong&gt;Show media queries&lt;/strong&gt;查看媒体查询：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/746209/202002/746209-20200227003729293-1924660735.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图中蓝色区块为最大宽度断点，黄色区块为最小宽度断点。&lt;/p&gt;
&lt;p&gt;右键相应区块还可以跳转到具体的css文件中的媒体查询代码。&lt;/p&gt;
&lt;h2 id=&quot;模拟传感器地理位置手机朝向&quot;&gt;模拟传感器（地理位置，手机朝向）&lt;/h2&gt;
&lt;p&gt;点击更多工具中的Sensors（传感器）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/746209/202002/746209-20200227003933731-132385728.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这里可以模拟地理位置，手机朝向&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/746209/202002/746209-20200227004012750-573701455.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;生成页面全尺寸快照图片&quot;&gt;生成页面全尺寸快照图片&lt;/h2&gt;
&lt;p&gt;通过下图操作，可以生成一张页面全尺寸的快照。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/746209/202002/746209-20200227004127798-1831024178.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而它上面那个选项是生成当前视口大小的图片。&lt;/p&gt;
&lt;h2 id=&quot;控制台快速获取元素面板的元素&quot;&gt;控制台快速获取元素面板的元素&lt;/h2&gt;
&lt;p&gt;在元素面板上选中一个元素后：&lt;/p&gt;
&lt;p&gt;细心的朋友会发现后面总是会出现一个&lt;strong&gt;== $0&lt;/strong&gt;的提示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/746209/202002/746209-20200227004317360-1288992084.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时在控制台输入&lt;strong&gt;$0&lt;/strong&gt;,实际上就可以获取到该元素。&lt;/p&gt;
&lt;p&gt;通过这种方式，即使对于那些没有&lt;strong&gt;class&lt;/strong&gt;和&lt;strong&gt;id&lt;/strong&gt;的元素，我们也可以在控制台快速获取并使用。&lt;/p&gt;
&lt;p&gt;您可能会问：&lt;strong&gt;那我要是想在控制台调用多个这样的元素呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;选中元素，右键，选择选项：&lt;strong&gt;Store as global variable&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;此时会将选中的元素存储在一个临时变量中，并自动在控制台输出这个变量的名字。&lt;/p&gt;
&lt;h2 id=&quot;页面跳转到元素面板指定的元素&quot;&gt;页面跳转到元素面板指定的元素&lt;/h2&gt;
&lt;p&gt;某些时候页面元素出现BUG，不知道跑到哪去了，我们需要页面跳转到这个元素所在的位置。&lt;/p&gt;
&lt;p&gt;如果我们知道它的&lt;strong&gt;id&lt;/strong&gt;或者&lt;strong&gt;class&lt;/strong&gt;，我们可以通过在控制台输入js命令去跳转：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;document.querySelector('.icon-cool').scrollIntoView()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然也可以通过我们上面说到的&lt;strong&gt;$0&lt;/strong&gt;做到：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$0.scrollIntoView()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是有个更简单的办法，那就是右键元素面板上的指定元素，然后点击&lt;strong&gt;Scroll into view&lt;/strong&gt;的选项。&lt;/p&gt;
&lt;h2 id=&quot;dom断点&quot;&gt;DOM断点&lt;/h2&gt;
&lt;p&gt;同样右键元素面板上的元素，发现有个&lt;strong&gt;Break on&lt;/strong&gt;的选项，这里可以打DOM断点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/746209/202002/746209-20200227004545586-1585323446.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上往下依次是子节点改变时断下，元素属性改变时断下，节点移除时断下。&lt;/p&gt;
&lt;p&gt;打下断点后，在左侧会有断点标识，右侧的DOM Breakpoints也会有相应的显示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/746209/202002/746209-20200227004746969-2098866663.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击DOM Breakpoints的相应DOM断点，元素面板也会定位到相应元素。&lt;/p&gt;
&lt;p&gt;当js去修改指定元素的DOM结构时，就会在修改的位置断下。&lt;/p&gt;
&lt;p&gt;这种断点很方便查找到究竟是哪里对页面元素进行了修改。&lt;/p&gt;
&lt;h2 id=&quot;元素事件侦听器&quot;&gt;元素事件侦听器&lt;/h2&gt;
&lt;p&gt;在元素面板选中元素，右侧的&lt;strong&gt;Event Listeners&lt;/strong&gt;会显示该元素上的事件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/746209/202002/746209-20200227005438081-663312663.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果勾选了&lt;strong&gt;Ancestors&lt;/strong&gt;（祖先），那么会展示祖先节点的事件，通常不需要勾选这个。&lt;/p&gt;
&lt;p&gt;点击事件右侧的链接可以跳转到附加事件的代码。&lt;/p&gt;
&lt;p&gt;通常一些js框架或库（比如jQeury）会将原生DOM事件进行封装，而这会导致我们通过元素事件侦听器跳转到的代码是这些库文件的封装代码。&lt;/p&gt;
&lt;p&gt;不过如果我们勾选了&lt;strong&gt;Framework listeners&lt;/strong&gt;（框架侦听器），那么就会跳转到我们使用库文件事件API的地方，而不是库文件里。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Framework listeners&lt;/strong&gt;对于jQuery这样对事件进行简单封装的特别好用，但是对于React这种的话作用有限。&lt;/p&gt;
&lt;h2 id=&quot;查看当前页面对css和js使用覆盖率&quot;&gt;查看当前页面对css和js使用覆盖率&lt;/h2&gt;
&lt;p&gt;通过以下方式打开Coverage选项卡，这个可以查看当前页面对css和js的使用覆盖率。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/746209/202002/746209-20200227005615575-1844813870.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击左上角按钮开始记录：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/746209/202002/746209-20200227005716213-659115673.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图可以单纯查看css还是js，或者都查看。&lt;/p&gt;
&lt;p&gt;选中单个文件，还可以查看具体是哪些代码或者css没有使用到。&lt;/p&gt;
&lt;p&gt;记录期间，我们做各种操作，都会影响到这个使用覆盖率的变动。&lt;/p&gt;
&lt;p&gt;对于现在常用的单页面应用而言，尤为有效，因为切换页面实际并没有改变html，所以这个记录一直有效。&lt;/p&gt;
&lt;p&gt;对于以往采用jQuery的多页面应用而言，当切换了页面之后，记录就重新开始了。&lt;/p&gt;
&lt;p&gt;不过不管是单页面还是多页面，通过这种方式都是可以查看相应的js和css的使用覆盖率的，对于优化css和js，删除无用的废代码，以及代码文件拆分都很有帮助。&lt;/p&gt;
&lt;h2 id=&quot;使用本地文件调试生产环境网站代码&quot;&gt;使用本地文件调试生产环境网站代码&lt;/h2&gt;
&lt;p&gt;我们调试生产环境的BUG，经常需要修改样式或者js，但是页面一刷新这些东西就又还原了。&lt;/p&gt;
&lt;p&gt;所以这里有个神技，可以将生产环境的引用文件进行本地化，然后修改本地化后的文件进行调试。&lt;/p&gt;
&lt;p&gt;首先我们需要打开在&lt;strong&gt;Source&lt;/strong&gt;面板下左侧的Overrides选项卡，选择一个本地文件夹作为覆盖文件夹。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/746209/202002/746209-20200227005932822-1751950429.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里我选择了一个名为&lt;strong&gt;test&lt;/strong&gt;的文件夹。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/746209/202002/746209-20200227010029487-398595580.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我们切换到&lt;strong&gt;Source&lt;/strong&gt;面板的Page选项卡，选中某个文件，然后右键，选中选项&lt;strong&gt;Save for overrides&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;此时切回&lt;strong&gt;Overrides&lt;/strong&gt;选项卡，发现test文件夹中已存在相关的js文件。&lt;/p&gt;
&lt;p&gt;修改该文件的js内容，再保存，即使刷新之后修改后的内容依然会生效，并且页面会加载我们修改之后的js文件。&lt;/p&gt;
&lt;h2 id=&quot;animation动画检查器&quot;&gt;Animation动画检查器&lt;/h2&gt;
&lt;p&gt;通过下图方式可以打开Animation检查器：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/746209/202002/746209-20200227010217671-217208823.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个检查器自动开始监听页面上的动画，但是这个时候动画已经加载完了，监听不到，需要我们重新刷新页面才行。&lt;/p&gt;
&lt;p&gt;选中其中的一个动画，会显示如下图的效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/746209/202002/746209-20200227010259470-1744331228.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过它我们可以查看和调整CSS动画和过渡的各种效果。&lt;/p&gt;
&lt;h2 id=&quot;rendering选项卡高亮重排重绘合成层fps和gpu占用滚动优化媒体查询模拟如打印&quot;&gt;Rendering选项卡（高亮重排重绘合成层，fps和gpu占用，滚动优化，媒体查询模拟如打印）&lt;/h2&gt;
&lt;p&gt;Rendering选项卡，顾名思义是做一些渲染相关的事。&lt;/p&gt;
&lt;p&gt;通过下图方式打开Rendering选项卡：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/746209/202002/746209-20200227010351517-1012105407.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面是选项卡的界面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/746209/202002/746209-20200227010502199-811004312.png&quot;/&gt;&lt;/p&gt;
&lt;ul readability=&quot;11.254697286013&quot;&gt;&lt;li&gt;&lt;strong&gt;Paint flashing&lt;/strong&gt; 高亮页面重绘区域。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Layout Shift Regions&lt;/strong&gt; 高亮布局变动区域（重排）。&lt;/li&gt;
&lt;li readability=&quot;4.9641255605381&quot;&gt;
&lt;p&gt;&lt;strong&gt;Layer borders&lt;/strong&gt; 高亮合成层边框，对于减少合成层还是挺好用的。&lt;/p&gt;
&lt;p&gt;以上三点，如果不太清楚，可以看看这篇好文：&lt;a href=&quot;https://juejin.im/entry/590801780ce46300617c89b8&quot;&gt;浏览器渲染详细过程：重绘、重排和 composite 只是冰山一角&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;简略一点来说，渲染过程就是DOM树+样式树，合成渲染树，渲染树加上层叠遮罩之类的再演变为Layer树，Layer树再合成为为Graphics Layers即Composite Layer，再丢给GPU进行处理。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;15&quot;&gt;
&lt;p&gt;&lt;strong&gt;Scrolling Performance Issues&lt;/strong&gt; 用于优化滚动性能问题。&lt;/p&gt;
&lt;p&gt;这个是用来高亮可能会影响滚动性能的元素，这些元素主要指绑定了scroll事件和touch事件的元素。&lt;/p&gt;
&lt;p&gt;scroll大家可能会比较理解，touch的话其实也可以影响滚动性能，最直观的就是只要我们禁止了某元素上touch的事件中禁止浏览器默认行为，那么就不会再触发scroll事件。&lt;/p&gt;
&lt;p&gt;而touch的影响还不止如此，比如将touch-action改为manipulation可以减少移动端浏览器在用户点击事件的延迟，但是这个东西会影响到滚动时的性能。&lt;/p&gt;
&lt;p&gt;当您开&lt;strong&gt;Scrolling Performance Issues&lt;/strong&gt;发现页面上一堆高亮的touch事件时，可以考虑touch-action:auto来去除。&lt;/p&gt;
&lt;p&gt;具体的优化可能得根据实际情况去处理，哪里有问题优化哪里，取得一个平衡即可。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Highlight ad frames&lt;/strong&gt; 高亮用于广告的iframe（试了下，谷歌的推广广告识别没问题，百度的没测）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Hit-test borders&lt;/strong&gt; 展示点击测试的区域。（鸡肋，请忘记）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Emulate CSS media type&lt;/strong&gt; 模拟媒体查询是打印还是终端屏幕。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Emulate CSS media feature prefers-color-scheme&lt;/strong&gt; 模拟媒体查询的系统主题，具体参考&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media/prefers-color-scheme&quot;&gt;prefers-color-scheme&lt;/a&gt;。&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;Emulate CSS media feature prefers-reduced-momition&lt;/strong&gt; 模拟媒体查询的开启动画减弱功能，具体参考&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media/prefers-reduced-motion&quot;&gt;prefers-reduced-motion&lt;/a&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;保留页面控制台记录和网络请求记录&quot;&gt;保留页面控制台记录和网络请求记录&lt;/h2&gt;
&lt;p&gt;Chrome的&lt;strong&gt;Console&lt;/strong&gt;面板和&lt;strong&gt;Network&lt;/strong&gt;面板都有&lt;strong&gt;Preserve Log&lt;/strong&gt;这个选项，当勾选了这个选项后，会保留当前选项卡的控制台和请求记录。&lt;/p&gt;
&lt;p&gt;对于涉及到多个页面间跳转的问题，这个功能很有帮助。&lt;/p&gt;
&lt;h2 id=&quot;切换控制台的执行环境iframe中运行脚本&quot;&gt;切换控制台的执行环境（iframe中运行脚本）&lt;/h2&gt;
&lt;p&gt;Console面板上面有个名为&lt;strong&gt;Javascript contexts&lt;/strong&gt;的选择器，一般值默认为&lt;strong&gt;top&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;top&lt;/strong&gt;表示当前执行环境为当前页面，而如果想切换到当前页面各个iframe，就需要进行相应切换。&lt;/p&gt;
&lt;p&gt;比如，在博客园首页，我们可以切换到各个广告iframe的运行环境。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/746209/202002/746209-20200227010717824-26237260.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;与此相关的一个功能是，只输出所选运行环境的打印日志：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/746209/202002/746209-20200227010744196-157069469.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击右上角齿轮打开控制台设置，勾选&lt;strong&gt;Selected context only&lt;/strong&gt;即可。&lt;/p&gt;
&lt;h2 id=&quot;控制台的实时表达式&quot;&gt;控制台的实时表达式&lt;/h2&gt;
&lt;p&gt;在控制台面板有个眼睛一样的图标，名为：&lt;strong&gt;Create live express&lt;/strong&gt;（创建实时表达式）。&lt;/p&gt;
&lt;p&gt;点击它创建一个入上图红框所示的小面板。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/746209/202002/746209-20200227010935905-64970972.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输入表达式可以自动监控这个表达式。&lt;/p&gt;
&lt;p&gt;比如如果实时表达式为a，如果a的值变动了，那么这个实时表达式的值也会变动。&lt;/p&gt;
&lt;h2 id=&quot;控制台的api&quot;&gt;控制台的API&lt;/h2&gt;
&lt;p&gt;我这里直接给开发者文档的地址了，毕竟有点多，建议了解一下，知道有哪些功能即可。&lt;/p&gt;
&lt;p&gt;比如monitor（监听函数执行）和monitorEvent（监听事件）还是有些用处的。&lt;/p&gt;
&lt;p&gt;文档地址为：&lt;a href=&quot;https://developers.google.cn/web/tools/chrome-devtools/console/api&quot;&gt;API列表&lt;/a&gt;和&lt;a href=&quot;https://developers.google.cn/web/tools/chrome-devtools/console/utilities&quot;&gt;工具API列表&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;可重复执行的控制台脚本片段&quot;&gt;可重复执行的控制台脚本片段&lt;/h2&gt;
&lt;p&gt;如果您在调试BUG时总是在控制台多次重复执行大段的相同的JS代码。&lt;/p&gt;
&lt;p&gt;那么您可以考虑用&lt;strong&gt;Snippet&lt;/strong&gt;（片段）。&lt;/p&gt;
&lt;p&gt;这个东西虽然作用于控制台，但是却不是在&lt;strong&gt;Console&lt;/strong&gt;面板，而是在&lt;strong&gt;Source&lt;/strong&gt;面板。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/746209/202002/746209-20200227011116493-1664996739.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如图所示，我们通过点击&lt;strong&gt;New snippet&lt;/strong&gt;新建了一个叫&lt;strong&gt;TestSnippet&lt;/strong&gt;的代码片段。&lt;/p&gt;
&lt;p&gt;然后我们可以点击右下角的运行或者用&lt;strong&gt;Ctrl+Enter&lt;/strong&gt;在控制台运行这段代码片段。&lt;/p&gt;
&lt;h2 id=&quot;xhrfetch-断点&quot;&gt;XHR/Fetch 断点&lt;/h2&gt;
&lt;p&gt;在&lt;strong&gt;Sources&lt;/strong&gt;面板，右侧会显示&lt;strong&gt;XHR/fetch Breakpoints&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/746209/202002/746209-20200227011203805-753592635.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击加号，可以输入字符，如果输入&lt;strong&gt;mynameis&lt;/strong&gt;，那么就会在ajax请求或者fetch请求的URI包含&lt;strong&gt;mynameis&lt;/strong&gt;时断下。&lt;/p&gt;
&lt;p&gt;如果不填，那么也会新增一行，表示断下所有的ajax请求和fetch请求。&lt;/p&gt;
&lt;h2 id=&quot;事件侦听器断点&quot;&gt;事件侦听器断点&lt;/h2&gt;
&lt;p&gt;在&lt;strong&gt;Sources&lt;/strong&gt;面板，右侧会显示&lt;strong&gt;Event Listener Breakpoints&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;顾名思义，用来给相应事件打断点的。&lt;/p&gt;
&lt;p&gt;这里基本上收录了所有的事件，连WebAudio，Worker，Timer的都有。&lt;/p&gt;
&lt;h2 id=&quot;异常断点&quot;&gt;异常断点&lt;/h2&gt;
&lt;p&gt;同样在&lt;strong&gt;Sources&lt;/strong&gt;面板右侧会显示异常断点的图标：&lt;/p&gt;
&lt;p&gt;激活后可以在各个未捕获的异常处断下，激活后还可以通过进一步勾选 Pause on caught exceptions在已捕获的异常处也断下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/746209/202002/746209-20200227011302808-1666165987.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;脚本黑盒化blackbox-script&quot;&gt;脚本黑盒化（Blackbox script）&lt;/h2&gt;
&lt;p&gt;在&lt;strong&gt;Source&lt;/strong&gt;面板，选中某js脚本文件后右键，或者在调试的堆栈中右键，都会出现一个&lt;strong&gt;Blackbox script&lt;/strong&gt;选项。&lt;/p&gt;
&lt;p&gt;点击这个选项，可以让我们在调试时认为此脚本总是对的，忽略此脚本，不论是调试过程或者堆栈都不会进入这个脚本。&lt;/p&gt;
&lt;p&gt;一般用来黑盒化一些js库，比如jQuery或者lodash之类的。&lt;/p&gt;
&lt;h2 id=&quot;网络面板的截图功能&quot;&gt;网络面板的截图功能&lt;/h2&gt;
&lt;p&gt;Network面板中有个截屏功能，开启之后再重新加载页面，就会如下图显示各个时间段下的截图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/746209/202002/746209-20200227011519204-775434911.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;双击这些缩略图，可以放大查看当时页面的具体样子。&lt;/p&gt;
&lt;p&gt;单击缩略图，可以显示当前缩略图时间点前发送的所有请求。&lt;/p&gt;
&lt;h2 id=&quot;网络面板关于网络请求的一些优化&quot;&gt;网络面板关于网络请求的一些优化&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;同域名请求数量限制（HTTP/1.0或HTTP/1.1）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果网络请求出现排队的情况，那么说明是在单个域上提出了太多请求。&lt;/p&gt;
&lt;p&gt;在HTTP/1.0或HTTP/1.1连接上，Chrome每个主机最多允许六个同步TCP连接。&lt;/p&gt;
&lt;p&gt;想要优化这一点，可以将关键请求提前，不关键请求延后。&lt;/p&gt;
&lt;p&gt;如果都是关键请求，那么可以尝试使用HTTP 2。（在Network面板可以展示Protocol显示）&lt;/p&gt;
&lt;p&gt;如果条件有限，可以将这些请求放在不同的域名上，然后用nginx指向同一个源头，这样同样可以解决这个问题&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;请求第一个字节的时间过长 Time To First Byte (TTFB)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们查看一下博客园首页的请求。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/746209/202002/746209-20200227011649416-333270808.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看见每个请求后面都有一个绿色的区域，这个绿色区域表示每个请求的&lt;strong&gt;Time To First Byte (TTFB)&lt;/strong&gt;，即请求第一个字节的时间。&lt;/p&gt;
&lt;p&gt;点开一个具体的请求，看一下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/746209/202002/746209-20200227011709606-44466799.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通常原因是浏览器与服务端的请求连接速度很慢，或者服务端的请求响应过慢。&lt;/p&gt;
&lt;p&gt;简单来说，就是网络连接慢，或者是服务端代码写得太辣鸡。&lt;/p&gt;
&lt;p&gt;如果是网络连接慢，可以用CDN，或者换个近一些的服务器。&lt;/p&gt;
&lt;p&gt;如果是服务端响应慢，那么可以考虑缓存，或者优化接口，那就是服务端的事情了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;内容下载慢&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里直接用Chrome官网的图片吧：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/746209/202002/746209-20200227011747789-1900014422.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一般表现于请求的下载时间过长，也就是请求后面跟着的蓝条。&lt;/p&gt;
&lt;p&gt;原因基本上就是js或者其它的一些资源文件太大了，导致下载过慢。&lt;/p&gt;
&lt;p&gt;因为用的是100M的网，所以我比较难找这样的例子，不过用浏览器的模拟3G网的话，其实博客园很多那种二次元风格，自带一张二次元大背景的博客都会出现这种现象。&lt;/p&gt;
&lt;p&gt;这种建议将图片尺寸压缩一下。&lt;/p&gt;
&lt;h2 id=&quot;网络面板时间分解阶段说明&quot;&gt;网络面板时间分解阶段说明&lt;/h2&gt;
&lt;p&gt;这里列出Timing选项卡可以看到的各个时间阶段：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Queueing（排队）&lt;/strong&gt;：浏览器在以下情况下将请求排队:
&lt;ul&gt;&lt;li&gt;有更高优先级的请求。&lt;/li&gt;
&lt;li&gt;已为该来源打开了六个TCP连接。仅适用于HTTP/1.0和HTTP/1.1。&lt;/li&gt;
&lt;li&gt;浏览器正在磁盘缓存中短暂分配空间&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Stalled&lt;/strong&gt;：出于Queueing中描述的任何原因，该请求都可能被暂停&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DNS Lookup&lt;/strong&gt;：浏览器正在解析请求的IP地址&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Proxy negotiation&lt;/strong&gt;：浏览器正在与代理服务器协商请求&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Request sent&lt;/strong&gt;：请求发送时间&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ServiceWorker Preparation&lt;/strong&gt;：浏览器正在启动service worker&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Request to ServiceWorker&lt;/strong&gt;：请求发送到service worker的时间&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Waiting (TTFB)&lt;/strong&gt;: 浏览器等待第一个字节响应的时间&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Content Download&lt;/strong&gt;：响应内容下载时间&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Receiving Push&lt;/strong&gt;：浏览器正在通过HTTP/2服务器推送接收此响应的数据&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Reading Push&lt;/strong&gt;： 浏览器正在读取先前接收的本地数据。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;查看请求的依赖关系&quot;&gt;查看请求的依赖关系&lt;/h2&gt;
&lt;p&gt;各个请求都有着它们各自的依赖关系，最常见的是图片、js和css依赖html请求。&lt;/p&gt;
&lt;p&gt;只有在html请求完毕才会在上面慢慢加载这些资源文件。&lt;/p&gt;
&lt;p&gt;同样以博客园为例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/746209/202002/746209-20200227012012868-232051190.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们按住&lt;strong&gt;Shift&lt;/strong&gt;，鼠标浮动到&lt;strong&gt;analytics.js&lt;/strong&gt;这个请求上，可以看到&lt;strong&gt;www.cnblogs.com&lt;/strong&gt;那个请求变绿了，&lt;strong&gt;collect&lt;/strong&gt;那个请求变红了。&lt;/p&gt;
&lt;p&gt;这个表示&lt;strong&gt;analytics.js&lt;/strong&gt;这个请求，依赖于&lt;strong&gt;www.cnblogs.com&lt;/strong&gt;，而&lt;strong&gt;collect&lt;/strong&gt;这个请求依赖于&lt;strong&gt;analytics.js&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;websocket消息的监控&quot;&gt;WebSocket消息的监控&lt;/h2&gt;
&lt;p&gt;如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/746209/202002/746209-20200227011932036-67517246.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们通过Network面板上的类型筛选到WebSocket请求，点开这个请求，我们可以看到相应的消息。&lt;/p&gt;
&lt;h2 id=&quot;audit面板&quot;&gt;Audit面板&lt;/h2&gt;
&lt;p&gt;关于Audit面板这里不讲使用方法，主要是太多了。&lt;/p&gt;
&lt;p&gt;但是这个东西确实很方便，这里是：&lt;a href=&quot;https://developers.google.cn/web/tools/chrome-devtools/speed/get-started&quot;&gt;参考文档&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;这里要说的是这个东西需要翻墙，如果翻不了，可以装个LightHouse的扩展插件，如果下不了或者不想更新麻烦，有个更好的办法。&lt;/p&gt;
&lt;p&gt;使用微软的Edge，基于Chromium的那个，然后在它的商店装个SiteTool的扩展插件即可。&lt;/p&gt;
&lt;h2 id=&quot;performance面板性能分析&quot;&gt;Performance面板性能分析&lt;/h2&gt;
&lt;p&gt;Performance面板主要是用来分析运行时的性能。加载的用Audit即可。&lt;/p&gt;
&lt;p&gt;关于怎么使用这里就太多了，咱们先挑最简单的一个流程来讲。&lt;/p&gt;
&lt;p&gt;我们首先看一下一个性能良好的结果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/746209/202002/746209-20200227012149814-918097707.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我们再将CPU变慢6倍，再看一下性能不好的结果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/746209/202002/746209-20200227012222518-1743651892.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;FPS概览&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对比第一张图，我们发现第二张图关于FPS那一行出现了很多红色，并且绿色的高度明显降低。&lt;/p&gt;
&lt;p&gt;这表示它的FPS值很低，一般给用户的感受就是很卡。出现了红色表示会影响到用户体验。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CPU概览&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;同时我们再对比上面两张图，发现第一张图的CPU那行颜色区域都很低，而第二张图CPU那块都占满了，这表示CPU占用率高。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;FPS详情&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们之前只是对哪个时间段的FPS低有了一个大致的了解，如果我们想要了解具体的情况，我们可以将鼠标浮动到&lt;strong&gt;Frames&lt;/strong&gt;那一行，这样可以了解到具体的帧的FPS。&lt;/p&gt;
&lt;p&gt;同样点击选中那一帧，还可以在下方的摘要（Summary）中查看具体的情况。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/746209/202002/746209-20200227012346150-12462063.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CPU工作详情&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;选中&lt;strong&gt;Main&lt;/strong&gt;那一行，下方的摘要就会显示主线程CPU各个活动的耗时。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/746209/202002/746209-20200227012419291-1895583756.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是即使如此，可能您也只能知道大致是哪个阶段出了问题，比如渲染还是脚本执行时间过长。&lt;/p&gt;
&lt;p&gt;如果想要快速定位，您可以展开&lt;strong&gt;Main&lt;/strong&gt;查看具体的工作详情。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/746209/202002/746209-20200227012458020-1239531297.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在Main那一行的展开详情中，可能会出现一些红色的三角符号或者红色区块，点击选中之后会有相应的优化提示，下方摘要也会展示出来。&lt;/p&gt;
&lt;p&gt;比如上图中就是因为强制回流导致的性能瓶颈。&lt;/p&gt;
&lt;p&gt;可以看一下摘要中红框中的链接，很方便地告诉了我们到底是哪段代码出了问题，点击进去：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/746209/202002/746209-20200227012634893-1685336662.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以发现是调用了offsetTop导致的回流，然后优化这部分代码即可。&lt;/p&gt;
&lt;p&gt;至于具体的优化我们这里就不讲了，关于性能优化可以参考一下:&lt;a href=&quot;https://developers.google.cn/web/fundamentals/performance/why-performance-matters&quot;&gt;Web Fundamentals的Performance&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;关于更多性能面板的介绍可以看下：&lt;a href=&quot;https://developers.google.cn/web/tools/chrome-devtools/evaluate-performance/timeline-tool#make-a-recording&quot;&gt;如何使用Timeline&lt;/a&gt; 和 &lt;a href=&quot;https://developers.google.cn/web/tools/chrome-devtools/evaluate-performance/performance-reference&quot;&gt;Timeline事件参考&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;这里说个小技巧，在Timeline上可以按&lt;strong&gt;Ctrl+F&lt;/strong&gt;，然后搜索事件，这样可以在大量的事件中快速定位想找的事件。&lt;/p&gt;
&lt;h2 id=&quot;javascript分析器&quot;&gt;JavaScript分析器&lt;/h2&gt;
&lt;p&gt;还是More tools中打开&lt;strong&gt;JavaScript Profiler&lt;/strong&gt;面板，怎么打开这里不讲了，操作好多遍了。&lt;/p&gt;
&lt;p&gt;然后记录下页面一段时间的js执行情况。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/746209/202002/746209-20200227012727365-1072308362.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们看到的上图就是记录结果，默认是分析模式是&lt;strong&gt;Heavy (Bottom Up)&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这个模式下可以看到哪些函数对性能影响最大并能够检查这些函数的调用路径。&lt;/p&gt;
&lt;p&gt;分析模式有下面三种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Chart&lt;/strong&gt;。显示按时间顺序排列的火焰图&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Heavy (Bottom Up)&lt;/strong&gt;。按照函数对性能的影响列出函数，让您可以检查函数的调用路径&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Tree (Top Down)&lt;/strong&gt;。显示调用结构的总体状况，从调用堆栈的顶端开始。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Heavy (Bottom Up)&lt;/strong&gt;和&lt;strong&gt;Tree (Top Down)&lt;/strong&gt;比较简单，这里直接略过。&lt;/p&gt;
&lt;p&gt;Chart的火焰图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/746209/202002/746209-20200227013115432-934298406.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;火焰图越高的部分表示函数调用的堆栈越高，但是高度并不代表什么。&lt;/p&gt;
&lt;p&gt;这样看图肯定是看不出来什么，所以我们需要选中一块区域放大，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/746209/202002/746209-20200227013159315-1802275018.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;色块越宽表示该函数的执行时间越长，而这个才表示该函数可能需要优化。&lt;/p&gt;
&lt;p&gt;鼠标浮动到色块上可以看到函数执行的具体信息，这里只说几个重要的点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Name。函数的名称。&lt;/li&gt;
&lt;li&gt;Self time。完成函数当前的调用所需的时间，仅包含函数本身的声明，不包含函数调用的任何函数。&lt;/li&gt;
&lt;li&gt;Total time。完成此函数和其调用的任何函数当前的调用所需的时间。&lt;/li&gt;
&lt;li&gt;URL。函数在哪个脚本中，并且它的行号。&lt;/li&gt;
&lt;li&gt;Aggregated self time。记录中函数所有调用的总时间，不包含此函数调用的函数。&lt;/li&gt;
&lt;li&gt;Aggregated total time。函数所有调用的总时间，包含此函数调用的函数。&lt;/li&gt;
&lt;li&gt;Not optimized。如果分析器已检测出函数存在优化可能，会在此处列出。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;点击相应色块可以进到具体的函数中查看。&lt;/p&gt;
&lt;h2 id=&quot;memory面板&quot;&gt;Memory面板&lt;/h2&gt;
&lt;p&gt;Memory面板主要用来监控页面的内存使用情况，并解决一些内存泄漏或者频繁的垃圾回收等问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Heap snapshot（堆快照）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用堆快照一般用来解决内存泄漏的问题。&lt;/p&gt;
&lt;p&gt;我们在内存面板&lt;strong&gt;Take snapshot&lt;/strong&gt;之后，可以看到这样一个画面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/746209/202002/746209-20200227013305382-642035899.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我们在上方输入&lt;strong&gt;Detached&lt;/strong&gt;，会筛选出下面的结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/746209/202002/746209-20200227013331859-1009692976.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里可以看看到底是哪些DOM节点没有释放。&lt;/p&gt;
&lt;p&gt;官网文档上显示如果DOM节点没有被引用，那么应该是红色的，但是实际上不是如此。&lt;/p&gt;
&lt;p&gt;不过这个功能还是有些用处的，选中相应的节点可以看看到底是哪些变量引用了，然后看是否能消除这些变量。&lt;/p&gt;
&lt;p&gt;这里得注意图中的&lt;strong&gt;Shallow Size&lt;/strong&gt;表示对象自身占用内存的大小，&lt;strong&gt;Retained Size&lt;/strong&gt;表示通过保持对其他对象的引用隐式占用的总内存大小，而&lt;strong&gt;Distance&lt;/strong&gt;是对象到&lt;strong&gt;GC roots&lt;/strong&gt;（如window或者DOM树）的距离。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Allocation instrumentation on timeline（时间线上的内存分配工具）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;翻译起来有点绕口，实际上就是一个用来按时间查看内存分配情况的工具。&lt;/p&gt;
&lt;p&gt;我们直接看一下检测结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/746209/202002/746209-20200227013428675-1806441591.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以看到时间轴上有不少柱子，这些柱子高度会变，表示所在的那个点分配的对象大小。&lt;/p&gt;
&lt;p&gt;我们可以看到图中我们选中的那个时间点分配的内存大概为384byte，旁边那个100B是一个参照线。&lt;/p&gt;
&lt;p&gt;柱子的颜色代表这些对象是否被回收了，蓝色代表还存在，灰色代表被回收了。&lt;/p&gt;
&lt;h2 id=&quot;application面板&quot;&gt;Application面板&lt;/h2&gt;
&lt;p&gt;这个面板内容多，但是简单易懂，本来想着写点的，太简单就算了。&lt;/p&gt;
&lt;p&gt;主要就是关于存储和缓存的。&lt;/p&gt;
&lt;p&gt;除此之外，就是有个关于PWA的调试，这里可以参考：&lt;a href=&quot;https://developers.google.cn/web/tools/chrome-devtools/progressive-web-apps&quot;&gt;调试 Progressive Web App&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;我对这个涉猎较少，就不班门弄斧了。&lt;/p&gt;
&lt;h2 id=&quot;security面板&quot;&gt;Security面板&lt;/h2&gt;
&lt;p&gt;这个面板主要是看是否https的，有用的时候是有用，没用的时候是真没用。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;学习Chrome开发者工具不仅能提高我们工具的使用效率，这其中涉及到的很多前端知识点也能令人眼界大开。&lt;/p&gt;
&lt;p&gt;在阅读Chrome的开发者工具文档时有很多缺失和不同步，这是因为它在不断地演进，包括我现在提到的一些功能也许在将来有一天就消失或者增强了。&lt;/p&gt;
&lt;p&gt;所以我觉得对于这份指南您可以当做一份索引，有所了解，但不必记住，只要在遇到问题的时候能记起来我可以用什么工具来处理就够了。&lt;/p&gt;
&lt;p&gt;希望这篇博客能帮助到您,也希望您能对疏漏之处指正一二。&lt;/p&gt;
</description>
<pubDate>Wed, 26 Feb 2020 17:58:00 +0000</pubDate>
<dc:creator>韩子卢</dc:creator>
<og:description>前言 工欲善其事，必先利其器。 在前端工作中，我们常常使用到Chrome开发者工具去做各种各样的事情。 但是您真的了解这些开发者工具吗？ 官方文档还是挺详细的： &amp;quot;chrome devtoo</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/vvjiang/p/12370112.html</dc:identifier>
</item>
<item>
<title>Gong服务实现平滑重启分析 - qīqíqǐqì</title>
<link>http://www.cnblogs.com/zhucheer/p/12368301.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhucheer/p/12368301.html</guid>
<description>&lt;p&gt;&lt;span data-slate-leaf=&quot;true&quot; data-offset-key=&quot;3:0&quot;&gt;平滑重启是指能让我们的程序在重启的过程不中断服务，新老进程无缝衔接，实现零停机时间(Zero&lt;span data-slate-leaf=&quot;true&quot; data-offset-key=&quot;3:1&quot;&gt;-&lt;span data-slate-leaf=&quot;true&quot; data-offset-key=&quot;3:2&quot; data-slate-fragment=&quot;JTdCJTIyb2JqZWN0JTIyJTNBJTIyZG9jdW1lbnQlMjIlMkMlMjJkYXRhJTIyJTNBJTdCJTdEJTJDJTIybm9kZXMlMjIlM0ElNUIlN0IlMjJvYmplY3QlMjIlM0ElMjJibG9jayUyMiUyQyUyMnR5cGUlMjIlM0ElMjJsaW5lJTIyJTJDJTIyZGF0YSUyMiUzQSU3QiU3RCUyQyUyMm5vZGVzJTIyJTNBJTVCJTdCJTIyb2JqZWN0JTIyJTNBJTIydGV4dCUyMiUyQyUyMmxlYXZlcyUyMiUzQSU1QiU3QiUyMm9iamVjdCUyMiUzQSUyMmxlYWYlMjIlMkMlMjJ0ZXh0JTIyJTNBJTIyJUU0JUI4JTgwJUU3JUE3JThEJUU4JTgzJUJEJUU4JUFFJUE5JUU1JUJBJTk0JUU3JTk0JUE4JUU0JUI4JThEJUU0JUI4JUFEJUU2JTk2JUFEJUU0JUI4JTlBJUU1JThBJUExJUU3JTlBJTg0JUU5JTg3JThEJUU1JTkwJUFGJUU2JTk2JUI5JUU1JUJDJThGJUVGJUJDJThDJUU5JTg3JThEJUU1JTkwJUFGJUU2JTlDJThEJUU1JThBJUExJUU4JTgzJUJEJUU4JUFFJUE5JUU2JTk2JUIwJUU4JTgwJTgxJUU4JUJGJTlCJUU3JUE4JThCJUU2JTk3JUEwJUU3JUJDJTlEJUU1JTg4JTg3JUU2JThEJUEyJUVGJUJDJThDJTIwJUU1JUFFJTlFJUU3JThFJUIwJUU5JTlCJUI2JUU1JTgxJTlDJUU2JTlDJUJBJUU2JTk3JUI2JUU5JTk3JUI0KFplcm8tRG93bnRpbWUpJUU5JTgzJUE4JUU3JUJEJUIyJUUzJTgwJTgyJTIyJTJDJTIybWFya3MlMjIlM0ElNUIlNUQlN0QlNUQlN0QlNUQlN0QlNUQlN0Q=&quot;&gt;Downtime)部署；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-slate-leaf=&quot;true&quot; data-offset-key=&quot;3:0&quot;&gt;&lt;span data-slate-leaf=&quot;true&quot; data-offset-key=&quot;3:1&quot;&gt;&lt;span data-slate-leaf=&quot;true&quot; data-offset-key=&quot;3:2&quot; data-slate-fragment=&quot;JTdCJTIyb2JqZWN0JTIyJTNBJTIyZG9jdW1lbnQlMjIlMkMlMjJkYXRhJTIyJTNBJTdCJTdEJTJDJTIybm9kZXMlMjIlM0ElNUIlN0IlMjJvYmplY3QlMjIlM0ElMjJibG9jayUyMiUyQyUyMnR5cGUlMjIlM0ElMjJsaW5lJTIyJTJDJTIyZGF0YSUyMiUzQSU3QiU3RCUyQyUyMm5vZGVzJTIyJTNBJTVCJTdCJTIyb2JqZWN0JTIyJTNBJTIydGV4dCUyMiUyQyUyMmxlYXZlcyUyMiUzQSU1QiU3QiUyMm9iamVjdCUyMiUzQSUyMmxlYWYlMjIlMkMlMjJ0ZXh0JTIyJTNBJTIyJUU0JUI4JTgwJUU3JUE3JThEJUU4JTgzJUJEJUU4JUFFJUE5JUU1JUJBJTk0JUU3JTk0JUE4JUU0JUI4JThEJUU0JUI4JUFEJUU2JTk2JUFEJUU0JUI4JTlBJUU1JThBJUExJUU3JTlBJTg0JUU5JTg3JThEJUU1JTkwJUFGJUU2JTk2JUI5JUU1JUJDJThGJUVGJUJDJThDJUU5JTg3JThEJUU1JTkwJUFGJUU2JTlDJThEJUU1JThBJUExJUU4JTgzJUJEJUU4JUFFJUE5JUU2JTk2JUIwJUU4JTgwJTgxJUU4JUJGJTlCJUU3JUE4JThCJUU2JTk3JUEwJUU3JUJDJTlEJUU1JTg4JTg3JUU2JThEJUEyJUVGJUJDJThDJTIwJUU1JUFFJTlFJUU3JThFJUIwJUU5JTlCJUI2JUU1JTgxJTlDJUU2JTlDJUJBJUU2JTk3JUI2JUU5JTk3JUI0KFplcm8tRG93bnRpbWUpJUU5JTgzJUE4JUU3JUJEJUIyJUUzJTgwJTgyJTIyJTJDJTIybWFya3MlMjIlM0ElNUIlNUQlN0QlNUQlN0QlNUQlN0QlNUQlN0Q=&quot;&gt;平滑重启是建立在优雅退出的基础之上的，之前一篇文章介绍了相关实现：&lt;a href=&quot;https://www.cnblogs.com/zhucheer/p/12337277.html&quot; target=&quot;_blank&quot;&gt;Golang中使用Shutdown特性对http服务进行优雅退出使用总结&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-slate-leaf=&quot;true&quot; data-offset-key=&quot;3:0&quot;&gt;目前实现平滑重启的主要策略有两种：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-slate-leaf=&quot;true&quot; data-offset-key=&quot;3:0&quot;&gt;方案一：我们的服务如果是多机器部署，可以通过网关程序，将即将重启服务的机器从网关下线，重启完成后再重新上线，该方案适合多机器部署的企业级应用；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-slate-leaf=&quot;true&quot; data-offset-key=&quot;3:0&quot;&gt;方案二：让我们的程序实现自启动，重启子进程来实现平滑重启，核心策略是通过拷贝文件描述符实现子进程和父进程切换，适合单机器部署应用；&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span data-slate-leaf=&quot;true&quot; data-offset-key=&quot;3:0&quot;&gt;今天我们就主要介绍方案二，让我们的程序拥有平滑重启的功能，相关实现参考一个开源库：&lt;a class=&quot;uri&quot; href=&quot;https://github.com/fvbock/endless&quot;&gt;https://github.com/fvbock/endless&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;实现原理介绍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;http 连接介绍：&lt;/p&gt;
&lt;p&gt;我们知道，http 服务也是基于 tcp 连接，我们通过 golang http 包源码也能看到底层是通过监听 tcp 连接实现的；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
func (srv *&lt;span&gt;Server) ListenAndServe() error {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; srv.&lt;span&gt;shuttingDown() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ErrServerClosed
    }
    addr &lt;/span&gt;:= srv.&lt;span&gt;Addr
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; addr == &quot;&quot;&lt;span&gt; {
        addr &lt;/span&gt;= &quot;:http&quot;&lt;span&gt;
    }
    ln&lt;/span&gt;, err := net.Listen(&quot;tcp&quot;,&lt;span&gt; addr)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; err
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; srv.Serve(tcpKeepAliveListener{ln.(*net.&lt;span&gt;TCPListener)})
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;复用 socket：&lt;/p&gt;
&lt;p&gt;当程序开启 tcp 连接监听时会创建一个 socket 并返回一个文件描述符 handler 给我们的程序； &lt;/p&gt;
&lt;p&gt;通过拷贝文件描述符文件可以使 socket 不关闭继续使用原有的端口，自然 http 连接也不会断开，启动一个相同的进程也不会出现端口被占用的问题；&lt;/p&gt;
&lt;p&gt;通过如下代码进行测试：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package main

import (
    &lt;/span&gt;&quot;fmt&quot;
    &quot;net/http&quot;
    &quot;context&quot;
    &quot;time&quot;
    &quot;os&quot;
    &quot;os/signal&quot;
    &quot;syscall&quot;
    &quot;net&quot;
    &quot;flag&quot;
    &quot;os/exec&quot;&lt;span&gt;
)

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; (
    graceful &lt;/span&gt;= flag.Bool(&quot;grace&quot;, &lt;span&gt;false&lt;/span&gt;, &quot;graceful restart flag&quot;&lt;span&gt;)
    procType &lt;/span&gt;= &quot;&quot;&lt;span&gt;
)

func main() {
    flag&lt;/span&gt;.&lt;span&gt;Parse()
    mux &lt;/span&gt;:= http.&lt;span&gt;NewServeMux()
    mux&lt;/span&gt;.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.&lt;span&gt;Request) {

        fmt&lt;/span&gt;.Fprintln(w, fmt.&lt;span&gt;Sprintf&lt;/span&gt;(&quot;Hello world! ===&amp;gt; %s&quot;,&lt;span&gt; procType))
    })
    server &lt;/span&gt;:= &amp;amp;http.&lt;span&gt;Server{
        Addr&lt;/span&gt;:         &quot;:8080&quot;,&lt;span&gt;
        Handler&lt;/span&gt;:      mux,&lt;span&gt;

    }

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; err error
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; listener net.&lt;span&gt;Listener
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; *&lt;span&gt;graceful {
        f &lt;/span&gt;:= os.NewFile(3, &quot;&quot;&lt;span&gt;)
        listener&lt;/span&gt;, err = net.&lt;span&gt;FileListener(f)
        procType &lt;/span&gt;= &quot;fork process&quot;&lt;span&gt;
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        listener&lt;/span&gt;, _ = net.Listen(&quot;tcp&quot;, server.&lt;span&gt;Addr)
        procType &lt;/span&gt;= &quot;main process&quot;

        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;主程序开启5s 后 fork 子进程&lt;/span&gt;
&lt;span&gt;        go func() {
            &lt;/span&gt;&lt;span&gt;time&lt;/span&gt;.&lt;span&gt;Sleep&lt;/span&gt;(5*&lt;span&gt;time&lt;/span&gt;.&lt;span&gt;Second)
            forkSocket(listener&lt;/span&gt;.(*net.&lt;span&gt;TCPListener))
        }()

    }

    err&lt;/span&gt;=server.Serve(listener.(*net.&lt;span&gt;TCPListener))

    fmt&lt;/span&gt;.Println(fmt.&lt;span&gt;Sprintf&lt;/span&gt;(&quot;proc exit %v&quot;,&lt;span&gt; err))
}


func forkSocket(tcpListener &lt;/span&gt;*net.&lt;span&gt;TCPListener) error {
    f&lt;/span&gt;, err := tcpListener.&lt;span&gt;File&lt;/span&gt;&lt;span&gt;()
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; err
    }

    args &lt;/span&gt;:= []&lt;span&gt;string&lt;/span&gt;{&quot;-grace&quot;&lt;span&gt;}
    fmt&lt;/span&gt;.Println(os.Args[0],&lt;span&gt; args)
    cmd &lt;/span&gt;:= &lt;span&gt;exec&lt;/span&gt;.Command(os.Args[0], args...&lt;span&gt;)
    cmd&lt;/span&gt;.Stdout = os.&lt;span&gt;Stdout
    cmd&lt;/span&gt;.Stderr = os.&lt;span&gt;Stderr
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; put socket FD at the first entry&lt;/span&gt;
    cmd.ExtraFiles = []*os.&lt;span&gt;File&lt;/span&gt;&lt;span&gt;{f}
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; cmd.&lt;span&gt;Start()
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该程序启动后，等待 5s 会自动 fork 子进程，通过 ps 命令查看如图可以看到有两个进程同时共存：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/490885/202002/490885-20200226210555165-1251343469.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我们可以通过浏览器访问 http://127.0.0.1/ 可以看到会随机显示主进程或子进程的输出；&lt;/p&gt;
&lt;p&gt;写一个测试代码进行循环请求：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package main

import (
    &lt;/span&gt;&quot;net/http&quot;
    &quot;io/ioutil&quot;
    &quot;fmt&quot;
    &quot;sync&quot;&lt;span&gt;
)

func main(){

    wg&lt;/span&gt;:=sync.&lt;span&gt;WaitGroup{}
    wg&lt;/span&gt;.Add(100&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i:=0; i&amp;lt;100; i++&lt;span&gt; {
        go func(index int) {
            result&lt;/span&gt;:=getUrl(fmt.&lt;span&gt;Sprintf&lt;/span&gt;(&quot;http://127.0.0.1:8080?%d&quot;,&lt;span&gt; i))
            fmt&lt;/span&gt;.Println(fmt.&lt;span&gt;Sprintf&lt;/span&gt;(&quot;loop:%d %s&quot;, index,&lt;span&gt; result))
            wg&lt;/span&gt;.&lt;span&gt;Done&lt;/span&gt;&lt;span&gt;()
        }(i)
    }
    wg&lt;/span&gt;.&lt;span&gt;Wait()
}

func getUrl(url &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;) &lt;span&gt;string&lt;/span&gt;&lt;span&gt;{
    resp&lt;/span&gt;, _ := http.&lt;span&gt;Get(url)
    defer resp&lt;/span&gt;.Body.&lt;span&gt;Close()
    body&lt;/span&gt;, _ := ioutil.ReadAll(resp.&lt;span&gt;Body)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;(body)
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/common/490885/202002/490885-20200226210214328-53294445.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;能看到返回的数据也是有些是主进程有些是子进程。&lt;/p&gt;

&lt;p&gt;切换过程：&lt;/p&gt;
&lt;p&gt;在开启新的进程和老进程退出的瞬间，会有一个短暂的瞬间是同时有两个进程使用同一个文件描述符，此时这种状态，通过http请求访问，会随机请求到新进程或老进程上，这样也没有问题，因为请求不是在新进程上就是在老进程上；当老进程结束后请求就会全部到新进程上进行处理，通过这种方式即可实现平滑重启；&lt;/p&gt;

&lt;p&gt;综上，我们可以将核心的实现总结如下：&lt;/p&gt;
&lt;p&gt;1.监听退出信号；&lt;/p&gt;
&lt;p&gt;2.监听到信号后 fork 子进程，使用相关的命令启动程序，将文件描述符传递给子进程；&lt;/p&gt;
&lt;p&gt;3.子进程启动后，父进程停止服务并处理正在执行的任务（或超时）退出；&lt;/p&gt;
&lt;p&gt;4.此时只有一个新的进程在运行，实现平滑重启。&lt;/p&gt;

&lt;p&gt;一个完整的 demo 代码，通过发送 USR1 信号，程序会自动创建子进程并关闭主进程，实现平滑重启：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package main

import (
    &lt;/span&gt;&quot;fmt&quot;
    &quot;net/http&quot;
    &quot;context&quot;
    &quot;os&quot;
    &quot;os/signal&quot;
    &quot;syscall&quot;
    &quot;net&quot;
    &quot;flag&quot;
    &quot;os/exec&quot;&lt;span&gt;
)

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; (
    graceful &lt;/span&gt;= flag.Bool(&quot;grace&quot;, &lt;span&gt;false&lt;/span&gt;, &quot;graceful restart flag&quot;&lt;span&gt;)
)

func main() {
    flag&lt;/span&gt;.&lt;span&gt;Parse()
    mux &lt;/span&gt;:= http.&lt;span&gt;NewServeMux()
    mux&lt;/span&gt;.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.&lt;span&gt;Request) {

        fmt&lt;/span&gt;.Fprintln(w, &quot;Hello world!&quot;&lt;span&gt;)
    })
    server &lt;/span&gt;:= &amp;amp;http.&lt;span&gt;Server{
        Addr&lt;/span&gt;:         &quot;:8080&quot;,&lt;span&gt;
        Handler&lt;/span&gt;:      mux,&lt;span&gt;

    }

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; err error
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; listener net.&lt;span&gt;Listener
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; *&lt;span&gt;graceful {
        f &lt;/span&gt;:= os.NewFile(3, &quot;&quot;&lt;span&gt;)
        listener&lt;/span&gt;, err = net.&lt;span&gt;FileListener(f)
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        listener&lt;/span&gt;, err = net.Listen(&quot;tcp&quot;, server.&lt;span&gt;Addr)
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil{
        fmt&lt;/span&gt;.Println(fmt.&lt;span&gt;Sprintf&lt;/span&gt;(&quot;listener error %v&quot;,&lt;span&gt; err))
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;
    }

    go listenSignal(context&lt;/span&gt;.Background(), server,&lt;span&gt; listener)

    err&lt;/span&gt;=server.Serve(listener.(*net.&lt;span&gt;TCPListener))
    fmt&lt;/span&gt;.Println(fmt.&lt;span&gt;Sprintf&lt;/span&gt;(&quot;proc exit %v&quot;,&lt;span&gt; err))
}


func forkSocket(tcpListener &lt;/span&gt;*net.&lt;span&gt;TCPListener) error {
    f&lt;/span&gt;, err := tcpListener.&lt;span&gt;File&lt;/span&gt;&lt;span&gt;()
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; err
    }

    args &lt;/span&gt;:= []&lt;span&gt;string&lt;/span&gt;{&quot;-grace&quot;&lt;span&gt;}
    fmt&lt;/span&gt;.Println(os.Args[0],&lt;span&gt; args)
    cmd &lt;/span&gt;:= &lt;span&gt;exec&lt;/span&gt;.Command(os.Args[0], args...&lt;span&gt;)
    cmd&lt;/span&gt;.Stdout = os.&lt;span&gt;Stdout
    cmd&lt;/span&gt;.Stderr = os.&lt;span&gt;Stderr
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; put socket FD at the first entry&lt;/span&gt;
    cmd.ExtraFiles = []*os.&lt;span&gt;File&lt;/span&gt;&lt;span&gt;{f}
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; cmd.&lt;span&gt;Start()
}




func listenSignal(ctx context&lt;/span&gt;.Context, httpSrv *http.Server, listener net.&lt;span&gt;Listener) {
    sigs &lt;/span&gt;:= make(chan os.Signal, 1&lt;span&gt;)
    signal&lt;/span&gt;.Notify(sigs, syscall.&lt;span&gt;USR1)


    select {
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &amp;lt;-sigs:&lt;span&gt;
        forkSocket(listener&lt;/span&gt;.(*net.&lt;span&gt;TCPListener))
        httpSrv&lt;/span&gt;.&lt;span&gt;Shutdown(ctx)
        fmt&lt;/span&gt;.Println(&quot;http shutdown&quot;&lt;span&gt;)
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用 apache 的 ab 压测工具进行验证一下，执行 ab -c 50 -t 20 http://127.0.0.1:8080/ 持续 50 的并发 20s，在压测的期间向程序运行的pid发送 USR1 信号，可以看到压测结果，没有失败的请求，由此可知，该方案实现平滑重启是木有问题的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/490885/202002/490885-20200226235824052-988023867.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;最后给大家安利一个 Web 开发框架，该框架已经将平滑重启进行的封装，开箱即用，快速构建一个带平滑重启的 Web 服务。&lt;/p&gt;
&lt;p&gt;框架源码：&lt;a href=&quot;https://gitee.com/zhucheer/orange&quot; target=&quot;_blank&quot;&gt;https://gitee.com/zhucheer/orange&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文档：&lt;a href=&quot;https://www.kancloud.cn/chase688/orange_framework/1448035&quot; target=&quot;_blank&quot;&gt;https://www.kancloud.cn/chase688/orange_framework/1448035&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 26 Feb 2020 16:04:00 +0000</pubDate>
<dc:creator>qīq&amp;#237;qǐq&amp;#236;</dc:creator>
<og:description>平滑重启是指能让我们的程序在重启的过程不中断服务，新老进程无缝衔接，实现零停机时间(Zero-Downtime)部署； 平滑重启是建立在优雅退出的基础之上的，之前一篇文章介绍了相关实现：Golang中</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhucheer/p/12368301.html</dc:identifier>
</item>
<item>
<title>Jmeter 连接Redis获取数据集 - 梦雨情殇</title>
<link>http://www.cnblogs.com/mengyu/p/12362999.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mengyu/p/12362999.html</guid>
<description>&lt;p&gt;　　公司开展了新的业务活动，需要配合其他部门做压测，由于脚本中的手机号和用户的uid需要参数化而且每次均不能重复，最初的考虑使用csv的方式来获取数据，比较头疼的问题是集群节点需要维护测试数据，所以我将所有数据统一存储到使Redis中，Redis 将测试数据提供给Jmeter 服务器，设置如图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/616077/202002/616077-20200226231731375-1526828880.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;一、Jmeter安装 Redis 数据插件&lt;/h3&gt;
&lt;p&gt;　　　　1.Jmeter  插件管理中Avaliable Plugins 搜索redis,勾选 Reids Data Set 进行安装，安装的过程比较慢，安装完成以后进行重启&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/616077/202002/616077-20200225155634625-1428024491.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;　　　　2.Jmeter Plugins 插件管理的&lt;a href=&quot;https://jmeter-plugins.org/&quot; target=&quot;_blank&quot;&gt;网站&lt;/a&gt;直接下载Reids插件，解压后拷贝至lib目录，然后重新启动Jmeter&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/616077/202002/616077-20200225154441260-1943579938.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;二、安装完成以后，配置redis 相关信息&lt;/h3&gt;
&lt;p&gt;　　1、&lt;span data-spm-anchor-id=&quot;a2c4e.11153940.0.i4.23fd6c41xXGZcd&quot;&gt;右键线程组- &amp;gt;添加 -&amp;gt; 配置元素 -&amp;gt; jp@gc - Redis数据集　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/616077/202002/616077-20200225163337912-649204847.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2、配置redis 连接信息&lt;/p&gt;
&lt;p&gt; 　　Reids 数据集配置主要分为三部分&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数据配置信息&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/616077/202002/616077-20200225215355963-310234618.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Redis key：Redis中的key，Redis数据库中列表（有序数据）或集（无序数据）的名称&lt;/li&gt;
&lt;li&gt;Variable Names：由数据集导出到测试元素的变量的名称（设置取出来的value存放在哪个变量中）&lt;/li&gt;
&lt;li&gt;Delimiter：存储在Redis列表或集合中的行中使用的分隔符（取出的value有多个值时，变量名之间的分隔符）&lt;/li&gt;
&lt;li&gt;Date Sources Type：数据源类型，有List、Set两种选择（在JMeter 3 中RANDOM_REMOVE 对应 List，RANDOM_KEEP 对应 Set）&lt;/li&gt;
&lt;li&gt;Recycle data on Flase： 数据是否重复使用&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;Reids连接配置信息&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/616077/202002/616077-20200225215846062-381484626.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Redis server host：Redis服务器地址&lt;/li&gt;
&lt;li&gt;Redis server port：Redis服务器端口&lt;/li&gt;
&lt;li&gt;Timeout for connect in ms： 连接超时时间，默认2000 ms&lt;/li&gt;
&lt;li&gt;Password for connection：连接Redis的密码&lt;/li&gt;
&lt;li&gt;Database：数据库名称，连接Redis的第几个数据库，默认为0&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;Redis 线程组配置信息&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/616077/202002/616077-20200225221455512-1390739494.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;minIdle:至少有多少个状态为idle(空闲)的jedis实例；默认为0；&lt;/li&gt;
&lt;li&gt;maxIdle：控制一个pool最多有多少个状态为idle(空闲)的jedis实例；&lt;/li&gt;
&lt;li&gt;maxActive：控制一个pool可分配多少个jedis实例，通过pool.getResource()来获取；如果赋值为-1，则表示不限制；如果pool已经分配了maxActive个jedis实例，则此时pool的状态就成exhausted了，在JedisPoolConfig&lt;/li&gt;
&lt;li&gt;maxWait：表示当borrow一个jedis实例时，最大的等待时间，如果超过等待时间，则直接抛出JedisConnectionException；&lt;/li&gt;
&lt;li&gt;whenExhaustedAction：表示当pool中的jedis实例都被allocated完时，pool要采取的操作；默认有三种WHEN_EXHAUSTED_FAIL（表示无jedis实例时，直接抛出NoSuchElementException）、WHEN_EXHAUSTED_BLOCK（则表示阻塞住，或者达到maxWait时抛出JedisConnectionException）、WHEN_EXHAUSTED_GROW（则表示新建一个jedis实例，也就说设置的maxActive无用）；&lt;/li&gt;
&lt;li&gt;testOnBorrow：在borrow一个jedis实例时，是否提前进行alidate操作；如果为true，则得到的jedis实例均是可用的；&lt;/li&gt;
&lt;li&gt;testOnReturn：在return给pool时，是否提前进行validate操作；&lt;/li&gt;
&lt;li&gt;testWhileIdle：如果为true，表示有一个idle object evitor线程对idle object进行扫描，如果validate失败，此object会被从pool中drop掉；这一项只有在timeBetweenEvictionRunsMillis大于0时才有意义；&lt;/li&gt;
&lt;li&gt;timeBetweenEvictionRunsMillis：表示idle object evitor两次扫描之间要sleep的毫秒数；&lt;/li&gt;
&lt;li&gt;numTestsPerEvictionRun：表示idle object evitor每次扫描的最多的对象数；&lt;/li&gt;
&lt;li&gt;minEvictableIdleTimeMillis：表示一个对象至少停留在idle状态的最短时间，然后才能被idle object evitor扫描并驱逐；这一项只有在timeBetweenEvictionRunsMillis大于0时才有意义；&lt;/li&gt;
&lt;li&gt;softMinEvictableIdleTimeMillis：在minEvictableIdleTimeMillis基础上，加入了至少minIdle个对象已经在pool里面了。如果为-1，evicted不会根据idle time驱逐任何对象。如果minEvictableIdleTimeMillis&amp;gt;0，则此项设置无意义，且只有在timeBetweenEvictionRunsMillis大于0时才有意义；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　Redis 连接池配置信息转自：&lt;a href=&quot;https://www.cnblogs.com/linjiqin/p/7473410.html&quot;&gt;https://www.cnblogs.com/linjiqin/p/7473410.html&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;三、Redis 插入数据&lt;/h3&gt;
&lt;p&gt;　　1、将测试数据填充Redis中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
LPUSH user &lt;span&gt;13200039246&lt;/span&gt;,&lt;span&gt;10000200039246&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2、通过编程语言方式插入redis数据库&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;#&lt;/span&gt;&lt;span&gt;通过Python代码实现填充数据&lt;/span&gt;
 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; redis
 pool &lt;/span&gt;= redis.ConnectionPool(host=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;xxx.xxx.xxx.xxx&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, port=6728&lt;span&gt;)

 client &lt;/span&gt;= redis.Redis(connection_pool=&lt;span&gt;pool)
 r.lpush(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;13200039246,10000200039246&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;四、通过Redis 数据集创建测试脚本&lt;/h3&gt;
&lt;p&gt;　　1、线程组添加到测试计划&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;右键单击测试计划 -&amp;gt;添加 -&amp;gt;线程（用户） -&amp;gt;线程组&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　2、将Redis数据集添加到线程组&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;线程组 -&amp;gt;添加 -&amp;gt;配置元素 -&amp;gt; jp@gc-Redis数据集&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　3、设置Redis数据集&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/616077/202002/616077-20200226235209967-377239929.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　4、添加HTTP请求。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;线程组 -&amp;gt;添加 -&amp;gt;取样器 -&amp;gt; HTTP请求&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　接口的请求数据，只要我们正常填写，只需要引用变量的地方，用${phone}和${uid}调用对应变量数据，这里的变量名称需要与redis 设置的变量名称一致&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/616077/202002/616077-20200226234204270-1437710505.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　5、执行Jmeter脚本，接口调用成功，说明Jmeter 连接Redis 数据库成功了&lt;/p&gt;

&lt;h3&gt;四、总结&lt;/h3&gt;
&lt;p&gt;　　 通过Redis统一管理测试数据，JMeter获取Redis对应列表的数据，然后设置变量名，在JMeter里调用实现参数的过程。&lt;/p&gt;
</description>
<pubDate>Wed, 26 Feb 2020 15:52:00 +0000</pubDate>
<dc:creator>梦雨情殇</dc:creator>
<og:description>公司开展了新的业务活动，需要配合其他部门做压测，由于脚本中的手机号和用户的uid需要参数化而且每次均不能重复，最初的考虑使用csv的方式来获取数据，比较头疼的问题是集群节点需要维护测试数据，所以我将所</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mengyu/p/12362999.html</dc:identifier>
</item>
<item>
<title>单元测试-xUnit总结 - 星空天宇</title>
<link>http://www.cnblogs.com/AlexanderZhao/p/12369732.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/AlexanderZhao/p/12369732.html</guid>
<description>&lt;h2 id=&quot;什么是xunit&quot;&gt;什么是xUnit&lt;/h2&gt;
&lt;p&gt;xUnit.net是针对.NET Framework的免费，开源，以社区为中心的单元测试工具。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/740100/202002/740100-20200226225221900-658586334.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;自动化测试的优点&quot;&gt;自动化测试的优点&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;可以频繁的进行测试&lt;/li&gt;
&lt;li&gt;可以在任何时间进行测试，也可以按计划定时进行，例如：可以在半夜进行自动化测试&lt;/li&gt;
&lt;li&gt;比人工测试速度快&lt;/li&gt;
&lt;li&gt;可以更快速地发现错误&lt;/li&gt;
&lt;li&gt;基本上是非常可靠的&lt;/li&gt;
&lt;li&gt;测试代码与生产代码紧密结合&lt;/li&gt;
&lt;li&gt;使得开发团队更具有幸福感&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;自动化测试的分类&quot;&gt;自动化测试的分类&lt;/h2&gt;
&lt;p&gt;单元测试可以测试某个类或方法，具有较高的深度,对应用的功能覆盖面很小。&lt;br/&gt;集成测试有更好的广度，可以测试web资源，数据库资源等。&lt;br/&gt;皮下测试在web中针对controller下的节点测试。&lt;br/&gt;UI测试是对应用的界面功能测试。&lt;br/&gt;实际上常用的是单元测试和集成测试。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/740100/202002/740100-20200226225236336-1520288473.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;是测试行为还是测试私有方法&quot;&gt;是测试行为还是测试私有方法&lt;/h2&gt;
&lt;p&gt;一般是针对类的Public方法进行测试，也就是对行为进行测试，如果是私有方法需要改变修饰符才能测试&lt;/p&gt;
&lt;h2 id=&quot;xunit.net特点&quot;&gt;xUnit.Net特点：&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;支持多平台/运行时&lt;/li&gt;
&lt;li&gt;并行测试&lt;/li&gt;
&lt;li&gt;数据驱动测试&lt;/li&gt;
&lt;li&gt;可扩展&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;xunit支持的平台&quot;&gt;xUnit支持的平台：&lt;/h2&gt;
&lt;p&gt;.Net Framework&lt;br/&gt;.Net Core&lt;br/&gt;.Net Standard&lt;br/&gt;UWP&lt;br/&gt;Xamarin&lt;/p&gt;
&lt;p&gt;官网：&lt;br/&gt;https://xunit.net&lt;/p&gt;
&lt;h2 id=&quot;测试工具&quot;&gt;测试工具：&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;VS自带的测试浏览器（右键测试或者ctrl+r,t）
resharper,
cmd命令行(.net cli)： 
    dotnet test
        dotnet test --help&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;简单的例子&quot;&gt;简单的例子&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;在VS中创建一个解决方案，再创建一个.net core类库:Demo，添加一个Calculator类：&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;namespace Demo
{
    public class Calculator
    {
        public int Add(int x,int y)
        {
            return x + y;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;在同一解决方案，创建一个xUnit测试项目：DemoTest,针对项目测试，一般是项目名+Test命名测试项目。创建一个类：CalculatorTests：&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class CalculatorTests
{
    [Fact]
    public void ShouldAddEquals5() //注意命名规范
    {
        //Arrange
        var sut = new Calculator(); //sut-system under test，通用命名
        //Act
        var result = sut.Add(3, 2);
        //Assert
        Assert.Equal(5, result);

    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;运行测试(任意一种方法)：&lt;br/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;
&lt;ol&gt;&lt;li&gt;通过vs自带的测试资源管理器，找到测试项目，选择运行；&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/740100/202002/740100-20200226225255182-1217016026.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ol&gt;&lt;li&gt;通过在ShouldAddEquals5方法上，右键选择运行测试或者快捷键(ctrl+r,t)&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol&gt;&lt;li&gt;通过cmd,在测试项目目录运行dotnet test&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/740100/202002/740100-20200226225303687-120177354.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ol&gt;&lt;li&gt;resharper(没有安装,太耗费内存)&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;测试的三个阶段aaa&quot;&gt;测试的三个阶段：AAA&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;Arrange: 在这里做一些先决的设定。例如创建对象实例，数据，输入等。&lt;br/&gt;Act: 在这里执行生产代码并返回结果。例如调用方法或者设置属性。&lt;br/&gt;Assert:在这里检查结果，会产生测试通过或者失败两种结果。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/740100/202002/740100-20200226225312440-118157942.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/740100/202002/740100-20200226225321505-2023032788.png&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;Assert基于代码的返回值、对象的最终状态、事件是否发生等情况来评估测试的结果&lt;br/&gt;Assert的结果可能是Pass或者Fail&lt;br/&gt;如果所有的asserts都通过了，那么整个测试就通过了。&lt;br/&gt;如果任何assert 失败了，那么结果就失败了。&lt;/p&gt;
&lt;p&gt;一个test里应该有多少个asserts&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;一种简易的做法是，每个test方法里面只有一个assert.&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;而还有一种建议就是，每个test里面可以有多个asserts，只要这些asserts都是针对同一个行为。&lt;br/&gt;xUnit提供了以下类型的Assert:&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/740100/202002/740100-20200226225337152-491179473.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;assert方法应用&quot;&gt;Assert方法应用&lt;/h2&gt;
&lt;p&gt;演示示例：&lt;br/&gt;先建一个.net core类库项目,再建立一个xunit测试项目(参考最后综合示例)&lt;/p&gt;
&lt;h3 id=&quot;assert.trueassert.false&quot;&gt;Assert.True,Assert.False&lt;/h3&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;[Fact]
[Trait(&quot;Category&quot;,&quot;New&quot;)]
public void BeNewWhenCreated()
{
    _output.WriteLine(&quot;第一个测试&quot;);
    // Arrange
    var patient = new Patient();
    // Act
    var result = patient.IsNew;
    // Assert
    Assert.True(result);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;字符串结果测试assert.equal&quot;&gt;字符串结果测试：Assert.Equal&lt;/h3&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;[Fact]
public void HaveCorrectFullName()
{
    //var patient = new Patient();
    _patient.FirstName = &quot;Nick&quot;;
    _patient.LastName = &quot;Carter&quot;;
    var fullName = _patient.FullName;
    Assert.Equal(&quot;Nick Carter&quot;, fullName); //相等
    Assert.StartsWith(&quot;Nick&quot;, fullName);//以开头
    Assert.EndsWith(&quot;Carter&quot;, fullName);//以结尾
    Assert.Contains(&quot;Carter&quot;, fullName);//包含
    Assert.Contains(&quot;Car&quot;, fullName);
    Assert.NotEqual(&quot;CAR&quot;, fullName);//不相等
    Assert.Matches(@&quot;^[A-Z][a-z]*\s[A-Z][a-z]*&quot;, fullName);//正则表达式
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;数字结果测试&quot;&gt;数字结果测试&lt;/h3&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;[Fact]
[Trait(&quot;Category&quot;, &quot;New&quot;)]
public void HaveDefaultBloodSugarWhenCreated()
{
    var p = new Patient();
    var bloodSugar = p.BloodSugar;
    Assert.Equal(4.9f, bloodSugar,5); //判断是否相等
    Assert.InRange(bloodSugar, 3.9, 6.1);//判断是否在某一范围内
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;判断nullnot-null&quot;&gt;判断null，not null&lt;/h3&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;[Fact]
public void HaveNoNameWhenCreated()
{
    var p = new Patient();
    Assert.Null(p.FirstName);
    Assert.NotNull(_patient);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;集合测试&quot;&gt;集合测试&lt;/h3&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;[Fact]
public void HaveHadAColdBefore()
{
    //Arrange
    var _patient = new Patient();
    
    //Act
    var diseases = new List&amp;lt;string&amp;gt;
    {
        &quot;感冒&quot;,
        &quot;发烧&quot;,
        &quot;水痘&quot;,
        &quot;腹泻&quot;
    };
    _patient.History.Add(&quot;发烧&quot;);
    _patient.History.Add(&quot;感冒&quot;);
    _patient.History.Add(&quot;水痘&quot;);
    _patient.History.Add(&quot;腹泻&quot;);
    
    //Assert
    //判断集合是否含有或者不含有某个元素
    Assert.Contains(&quot;感冒&quot;,_patient.History);
    Assert.DoesNotContain(&quot;心脏病&quot;, _patient.History);

    //判断p.History至少有一个元素，该元素以水开头
    Assert.Contains(_patient.History, x =&amp;gt; x.StartsWith(&quot;水&quot;));
    //判断集合的长度
    Assert.All(_patient.History, x =&amp;gt; Assert.True(x.Length &amp;gt;= 2));

    //判断集合是否相等,这里测试通过，说明是比较集合元素的值，而不是比较引用
    Assert.Equal(diseases, _patient.History);

}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;测试对象&quot;&gt;测试对象&lt;/h3&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// 测试Object
/// &amp;lt;/summary&amp;gt;
[Fact]
public void BeAPerson()
{
    var p = new Patient();
    var p2 = new Patient();
    Assert.IsNotType&amp;lt;Person&amp;gt;(p); //测试对象是否相等，注意这里为false
    Assert.IsType&amp;lt;Patient&amp;gt;(p);

    Assert.IsAssignableFrom&amp;lt;Person&amp;gt;(p);//判断对象是否继承自Person,true

    //判断是否为同一个实例
    Assert.NotSame(p, p2);
    //Assert.Same(p, p2);

}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;判断是否发生异常&quot;&gt;判断是否发生异常&lt;/h3&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// 判断是否发生异常
/// &amp;lt;/summary&amp;gt;
[Fact]
public void ThrowException() //注意不能使用ctrl+R,T快捷键,因为会中断测试，抛出异常
{
    var p = new Patient();
    //判断是否返回指定类型的异常
    var ex = Assert.Throws&amp;lt;InvalidOperationException&amp;gt;(()=&amp;gt; { p.NotAllowed(); });
    //判断异常信息是否相等
    Assert.Equal(&quot;not able to create&quot;, ex.Message);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;判断是否触发事件&quot;&gt;判断是否触发事件&lt;/h3&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// 判断是否触发事件
/// &amp;lt;/summary&amp;gt;
[Fact]
public void RaizeSleepEvent()
{
    var p = new Patient();
    Assert.Raises&amp;lt;EventArgs&amp;gt;(
        handler=&amp;gt;p.PatientSlept+=handler,
        handler=&amp;gt;p.PatientSlept -= handler,
        () =&amp;gt; p.Sleep());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;判断属性改变是否触发事件&quot;&gt;判断属性改变是否触发事件&lt;/h3&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// 测试属性改变事件是否触发
/// &amp;lt;/summary&amp;gt;
[Fact]
public void RaisePropertyChangedEvent()
{
    var p = new Patient();
    Assert.PropertyChanged(p, nameof(p.HeartBeatRate),
                           () =&amp;gt; p.IncreaseHeartBeatRate());
}&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;测试分组&quot;&gt;测试分组&lt;/h2&gt;
&lt;p&gt;使用trait特性，对测试进行分组：[Trait(&quot;Name&quot;,&quot;Value&quot;)] 可以作用于方法级和Class级别&lt;br/&gt;相同的分组使用相同的特性。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;[Fact]
[Trait(&quot;Category&quot;,&quot;New&quot;)]
public void BeNewWhenCreated()
{
    _output.WriteLine(&quot;第一个测试&quot;);
    // Arrange
    //var patient = new Patient();
    // Act
    var result = _patient.IsNew;
    // Assert
    Assert.True(result);
    //Assert.False(result);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试分组搜索： 可以在测试资源管理器中按分组排列、搜索、运行测试&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/740100/202002/740100-20200226225404966-1364056168.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在dotnet cli中分组测试：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;dotnew test --filter “Category=New” //运行单个分类测试
dotnew test --filter “Category=New|Category=Add”//运行多个分类测试
dotnet test --filter Category --logger:trx //输出测试日志&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;忽略测试&quot;&gt;忽略测试&lt;/h2&gt;
&lt;p&gt;使用特性：[Fact(Skip=&quot;不跑这个测试&quot;)]，可以忽略测试，忽略测试图标为黄色警告&lt;/p&gt;
&lt;h2 id=&quot;自定义测试输出内容&quot;&gt;自定义测试输出内容&lt;/h2&gt;
&lt;p&gt;使用ITestOutputHelper可以自定义在测试时的输出内容&lt;br/&gt;dotnet test --filter Category --logger:trx会输出测试日志trx结尾的文件&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class PatientShould:IClassFixture&amp;lt;LongTimeFixture&amp;gt;,IDisposable
{
    private readonly ITestOutputHelper _output;
    private readonly Patient _patient;
    private readonly LongTimeTask _task;
    public PatientShould(ITestOutputHelper output,LongTimeFixture fixture)
    {
        this._output = output;
        _patient = new Patient();
        //_task = new LongTimeTask();
        _task = fixture.Task;
    }

    [Fact]
    [Trait(&quot;Category&quot;,&quot;New&quot;)]
    public void BeNewWhenCreated()
    {
        _output.WriteLine(&quot;第一个测试&quot;);
        // Arrange
        //var patient = new Patient();
        // Act
        var result = _patient.IsNew;
        // Assert
        Assert.True(result);
        //Assert.False(result);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;减少重复代码&quot;&gt;减少重复代码&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;减少new对象，可以在构造函数中new，在方法中使用。&lt;/li&gt;
&lt;li&gt;测试类实现IDispose接口，测试完释放资源，注意每个测试结束后都会调用Dispose方法。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;共享上下文&quot;&gt;共享上下文&lt;/h2&gt;
&lt;h3 id=&quot;同一个测试类&quot;&gt;同一个测试类&lt;/h3&gt;
&lt;p&gt;在执行一个方法时，需要很长事件，而在构造函数中new时，每个测试跑的时候都会new对象或者执行方法，这是导致测试很慢。解决方法：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;创建一个类：&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;using Demo2;
using System;

namespace Demo2Test
{
    public class LongTimeFixture : IDisposable
    {
        public LongTimeTask Task { get; }
        public LongTimeFixture()
        {

        }
        public void Dispose()
        {
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;测试类实现IClassFixture&amp;lt;LongTimeFixture&amp;gt;接口,并在构造函数中获取方法&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class PatientShould:IClassFixture&amp;lt;LongTimeFixture&amp;gt;,IDisposable
{
    private readonly ITestOutputHelper _output;
    private readonly Patient _patient;
    private readonly LongTimeTask _task;
    public PatientShould(ITestOutputHelper output,LongTimeFixture fixture)
    {
        this._output = output;
        _patient = new Patient();
        //_task = new LongTimeTask();
        _task = fixture.Task;//获取方法
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;不同的测试类&quot;&gt;不同的测试类&lt;/h3&gt;
&lt;p&gt;1.在上一个的继承上，先建立一个TaskCollection类，实现ICollectionFixture&amp;lt;LongTimeFixture&amp;gt;接口，注意不能有副作用，否则会影响结果&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;using Xunit;

namespace Demo2Test
{
    [CollectionDefinition(&quot;Lone Time Task Collection&quot;)]
    public class TaskCollection:ICollectionFixture&amp;lt;LongTimeFixture&amp;gt;
    {
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;使用，加上[Collection(&quot;Lone Time Task Collection&quot;)]&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;[Collection(&quot;Lone Time Task Collection&quot;)]
public class PatientShould:IClassFixture&amp;lt;LongTimeFixture&amp;gt;,IDisposable
{
    private readonly ITestOutputHelper _output;
    private readonly Patient _patient;
    private readonly LongTimeTask _task;
    public PatientShould(ITestOutputHelper output,LongTimeFixture fixture)
    {
        this._output = output;
        _patient = new Patient();
        //_task = new LongTimeTask();
        _task = fixture.Task;//获取方法
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;
&lt;h2 id=&quot;使用theory可以写有构造参数的测试方法使用inlinedata传递数据&quot;&gt;1. 使用[Theory]，可以写有构造参数的测试方法,使用InlineData传递数据&lt;/h2&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;[Theory]
[InlineData(1,2,3)]
[InlineData(2,2,4)]
[InlineData(3,3,6)]
public void ShouldAddEquals(int operand1,int operand2,int expected)
{
    //Arrange
    var sut = new Calculator(); //sut-system under test
    //Act
    var result = sut.Add(operand1, operand2);
    //Assert
    Assert.Equal(expected, result);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;使用memberdata特性可以在多个测试中使用&quot;&gt;2. 使用[MemberData]特性,可以在多个测试中使用&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;先添加CalculatorTestData类：&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;using System.Collections.Generic;

namespace DemoTest
{
    public  class CalculatorTestData
    {
        private static readonly List&amp;lt;object[]&amp;gt; Data = new List&amp;lt;object[]&amp;gt;
        {
            new object[]{ 1,2,3},
            new object[]{ 1,3,4},
            new object[]{ 2,4,6},
            new object[]{ 0,1,1},
        };

        public static IEnumerable&amp;lt;object[]&amp;gt; TestData =&amp;gt; Data;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;使用MemberData&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// 数据共享-MemberData
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;operand1&quot;&amp;gt;&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;operand2&quot;&amp;gt;&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;expected&quot;&amp;gt;&amp;lt;/param&amp;gt;
[Theory]
[MemberData(nameof(CalculatorTestData.TestData),MemberType =typeof(CalculatorTestData))]
public void ShouldAddEquals2(int operand1, int operand2, int expected)
{
    //Arrange
    var sut = new Calculator(); //sut-system under test
    //Act
    var result = sut.Add(operand1, operand2);
    //Assert
    Assert.Equal(expected, result);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;使用外部数据&quot;&gt;3. 使用外部数据&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;先创建一个类，准备数据,这里是读取的csv文件的数据&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace DemoTest.Data
{
    /// &amp;lt;summary&amp;gt;
    /// 读取文件并返回数据集合
    /// &amp;lt;/summary&amp;gt;
    public class CalculatorCsvData
    {
        public static IEnumerable&amp;lt;object[]&amp;gt; TestData
        {
            get
            {
                //把csv文件中的数据读出来，转换
                string[] csvLines = File.ReadAllLines(&quot;Data\\TestData.csv&quot;);
                var testCases = new List&amp;lt;object[]&amp;gt;();
                foreach (var csvLine in csvLines)
                {
                    IEnumerable&amp;lt;int&amp;gt; values = csvLine.Trim().Split(',').Select(int.Parse);
                    object[] testCase = values.Cast&amp;lt;object&amp;gt;().ToArray();
                    testCases.Add(testCase);
                }
                return testCases;
            }
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;csv数据&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;1,2,3
1,3,4
2,4,6
0,1,1&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;使用&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// 数据共享-MemberData-外部数据
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;operand1&quot;&amp;gt;&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;operand2&quot;&amp;gt;&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;expected&quot;&amp;gt;&amp;lt;/param&amp;gt;
[Theory]
[MemberData(nameof(CalculatorCsvData.TestData), MemberType = typeof(CalculatorCsvData))]
public void ShouldAddEquals3(int operand1, int operand2, int expected)
{
    //Arrange
    var sut = new Calculator(); //sut-system under test
    //Act
    var result = sut.Add(operand1, operand2);
    //Assert
    Assert.Equal(expected, result);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;使用自定义特性继承自dataattribute&quot;&gt;4. 使用自定义特性，继承自DataAttribute&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;自定义特性&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;using System.Collections.Generic;
using System.Reflection;
using Xunit.Sdk;

namespace DemoTest.Data
{
    public class CalculatorDataAttribute : DataAttribute
    {
        public override IEnumerable&amp;lt;object[]&amp;gt; GetData(MethodInfo testMethod)
        {
            yield return new object[] { 0, 100, 100 };
            yield return new object[] { 1, 99, 100 };
            yield return new object[] { 2, 98, 100 };
            yield return new object[] { 3, 97, 100 };
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;使用&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// 数据共享-自定义特性继承自DataAttribute
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;operand1&quot;&amp;gt;&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;operand2&quot;&amp;gt;&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;expected&quot;&amp;gt;&amp;lt;/param&amp;gt;
[Theory]
[CalculatorDataAttribute]
public void ShouldAddEquals4(int operand1, int operand2, int expected)
{
    //Arrange
    var sut = new Calculator(); //sut-system under test
    //Act
    var result = sut.Add(operand1, operand2);
    //Assert
    Assert.Equal(expected, result);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;源码：https://gitee.com/Alexander360/LearnXUnit&lt;/p&gt;
</description>
<pubDate>Wed, 26 Feb 2020 14:55:00 +0000</pubDate>
<dc:creator>星空天宇</dc:creator>
<og:description>xUnit总结 什么是xUnit xUnit.net是针对.NET Framework的免费，开源，以社区为中心的单元测试工具。 自动化测试的优点 + 可以频繁的进行测试 + 可以在任何时间进行测试，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/AlexanderZhao/p/12369732.html</dc:identifier>
</item>
<item>
<title>python爬虫实战：基础爬虫(使用BeautifulSoup4等) - Charzueus</title>
<link>http://www.cnblogs.com/chenzhenhong/p/12367987.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenzhenhong/p/12367987.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　以前学习写爬虫程序时候，我没有系统地学习爬虫最基本的模块框架，只是实现自己的目标而写出来的，最近学习基础的爬虫，但含有完整的结构，大型爬虫含有的基础模块，此项目也有，“麻雀虽小，五脏俱全”，只是没有考虑优化和稳健性问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1496983/202002/1496983-20200226172448308-1957708613.png&quot; alt=&quot;&quot; width=&quot;618&quot; height=&quot;266&quot;/&gt;　　　　　　　　　　　　　　爬虫框架&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;爬虫框架包括这五大模块，简单介绍作用：&lt;strong&gt;1.爬虫调度器：&lt;/strong&gt;协调其他四大模块工作；&lt;strong&gt;2.URL管理器：&lt;/strong&gt;就是管理提供爬取的链接，分为已爬取URL集合和未爬取URL集合；&lt;strong&gt;3.html下载器：&lt;/strong&gt;下载URL的整个html网页；&lt;strong&gt;4.html解析器：&lt;/strong&gt;将下载的网页进行解析，获得有效数据；&lt;strong&gt;5.数据存储器：&lt;/strong&gt;存储解析后的数据，以文件或数据库形式存储。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;项目准备爬取百度百科的一些名词解释和链接，这是小的项目，许多方法简化处理，做起来简洁有效。下面是具体步骤：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;1、URL管理器&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;根据作用可知，它包括2个集合，已爬取和未爬取URL链接，所以使用python的set()类型进行去重，防止重复死循环。这里在实践时候我存在疑问，后面再讨论。去重方案主要有3种：1)内存去重，2）关系数据库去重，3）缓存数据库去重；明显地，大型成熟爬虫会选择后两种，避免内存大小限制，而现在尚未成熟的小项目，就使用第1种。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt; UrlManager():  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; URL管理器&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        self.new_urls &lt;/span&gt;= set()  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 未爬取集合（去重）&lt;/span&gt;
        self.old_urls =&lt;span&gt; set()

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; has_new_url(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; self.new_url_size() != 0  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 判断是否有未爬取&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_new_url(self):
        new_url &lt;/span&gt;=&lt;span&gt; self.new_urls.pop()
        self.old_urls.add(new_url)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; new_url

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; add_new_url(self, url):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将新的URL添加到未爬取集合&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; url &lt;span&gt;is&lt;/span&gt;&lt;span&gt; None:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; url &lt;span&gt;not&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; self.new_urls &lt;span&gt;and&lt;/span&gt; url &lt;span&gt;not&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt; self.old_urls:
            self.new_urls.add(url)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; add_new_urls(self, urls):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; urls &lt;span&gt;is&lt;/span&gt; None &lt;span&gt;or&lt;/span&gt; len(urls) ==&lt;span&gt; 0:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; url &lt;span&gt;in&lt;/span&gt;&lt;span&gt; urls:
            self.add_new_url(url)


    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; new_url_size(self):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(len(self.new_urls))&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; len(self.new_urls)


    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; old_url_size(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; len(self.old_urls)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;几个函数作用很清晰，它会将新的链接加入未爬取集合，爬取过的URL就存入old_urls集合中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2&lt;span&gt;、HTML下载器&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里本来用requests包操作，但是我在后面运行程序时出现错误，所以后来我用了urllib包代替，而requests是它的高级封装，按往常也是用这个，具体是函数返回值出问题还是其他原因还没找出来，给出2个方法，需要大家指正。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; urllib.request

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; HtmlDownloader(object):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; download(self, url):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; url &lt;span&gt;is&lt;/span&gt;&lt;span&gt; None:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; None
        user_agent &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (Windows NT 6.1; Win64; x64)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        headers &lt;/span&gt;= {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;User-Agent&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: user_agent}
        html_content &lt;/span&gt;= urllib.request.Request(url,headers=headers)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;urlopen(url)&lt;/span&gt;
        response=&lt;span&gt;urllib.request.urlopen(html_content)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; response.getcode() == 200&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(response.read())&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; response.read()&lt;span&gt;#&lt;/span&gt;&lt;span&gt;.decode('utf-8')&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; None
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这个是成功的方法，使用urllib打开URL链接，添加请求头可以更好的模拟正常访问，根据状态码返回内容。而存在问题的requests如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt; requests&lt;span&gt;#&lt;/span&gt;&lt;span&gt;使用requests包爬取，结果提示页面不存在&lt;/span&gt;

&lt;span&gt;class&lt;/span&gt; HtmlDownloader(object):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; HTML下载器&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; download(self, url):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; url &lt;span&gt;is&lt;/span&gt;&lt;span&gt; None:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; None
        user_agent &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (Windows NT 6.1; Win64; x64)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        headers &lt;/span&gt;= {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;User-Agent&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: user_agent}
        respondse &lt;/span&gt;= requests.get(url, headers=&lt;span&gt;headers)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(url)&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; respondse.status_code != 200&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; None
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; respondse.encoding = 'utf-8'&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(respondse.content)&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; respondse.content
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;测试时候可看出urllib的respondse.read()与requests的content都是bytes类型，从代码阅读上大体一样，经过几次尝试，以为是编解码问题，最后还是没能找出问题，所以用了urllib进行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、HTML下载器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 　　这里使用BeautifulSoup4进行解析，bs4进行解析可以很简洁的几行代码完成，功能强大常使用。先分析网页结构格式，写出匹配表达式获取数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1496983/202002/1496983-20200226185622349-904377463.png&quot; alt=&quot;&quot; width=&quot;951&quot; height=&quot;274&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;分析之后标题&lt;span&gt;title = soup.find('dd', class_='lemmaWgt-lemmaTitle-title').find('h1')。&lt;/span&gt;&lt;/span&gt;&lt;span&gt;获取tag中包含的所有文本内容，包括子孙tag中的内容，并将结果作为Unicode字符串返回，词条解释可写出式子匹配&lt;/span&gt;&lt;span&gt;summary = soup.find('div', class_='lemma-summary')。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; re
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; urllib.parse &lt;span&gt;import&lt;/span&gt;&lt;span&gt; urljoin
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; bs4 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; BeautifulSoup


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; HtmlParser(object):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; _get_new_data(self, page_url, soup):
        data &lt;/span&gt;=&lt;span&gt; {}
        data[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; page_url
        title &lt;/span&gt;= soup.find(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;dd&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, class_=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;lemmaWgt-lemmaTitle-title&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).find(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        data[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; title.get_text()
        summary &lt;/span&gt;= soup.find(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, class_=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;lemma-summary&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        data[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;summary&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; summary.get_text()
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(summary_node.get_text())&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; data

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; _get_new_urls(self, page_url, soup):
        new_urls &lt;/span&gt;=&lt;span&gt; set()
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(new_urls)&lt;/span&gt;
        links = soup.find_all(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, href=re.compile(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/item/\w+&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; link &lt;span&gt;in&lt;/span&gt;&lt;span&gt; links:
            new_url &lt;/span&gt;= link[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
            new_full_url &lt;/span&gt;=&lt;span&gt; urljoin(page_url, new_url)
            new_urls.add(new_full_url)
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(new_full_url)&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; new_urls

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; parser(self, page_url, html_cont):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; page_url &lt;span&gt;is&lt;/span&gt; None &lt;span&gt;or&lt;/span&gt; html_cont &lt;span&gt;is&lt;/span&gt;&lt;span&gt; None:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;
        soup &lt;/span&gt;= BeautifulSoup(html_cont, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;html.parser&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) 
        new_urls &lt;/span&gt;=&lt;span&gt; self._get_new_urls(page_url, soup)
        new_data &lt;/span&gt;=&lt;span&gt; self._get_new_data(page_url, soup)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; new_urls, new_data
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;这里使用了正则表达式来匹配网页中的词条链接：&lt;/span&gt;&lt;span&gt;links = soup.find_all('a', href=re.compile('/item/\w+'))&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、数据存储器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　包括两个方法，store_data：将目标数据存到列表中；out_html：数据输出外存，这里存为html格式，也可以根据需要存为csv、txt形式。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; codecs


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; DataOutput(object):&lt;span&gt;#&lt;/span&gt;&lt;span&gt;数据存储器&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        self.datas&lt;/span&gt;=&lt;span&gt;[]

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; store_data(self,data):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; data &lt;span&gt;is&lt;/span&gt;&lt;span&gt; None:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;
        self.datas.append(data)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; output_html(self):
        fout&lt;/span&gt;=codecs.open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;baike.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,encoding=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        fout.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;html&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        fout.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;head&amp;gt;&amp;lt;meta charset='utf-8'/&amp;gt;&amp;lt;/head&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        fout.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;body&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        fout.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;table&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; data &lt;span&gt;in&lt;/span&gt;&lt;span&gt; self.datas:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(data[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;])
            fout.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;tr&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            fout.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;td&amp;gt;%s&amp;lt;/td&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
            fout.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;td&amp;gt;%s&amp;lt;/td&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
            fout.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;td&amp;gt;%s&amp;lt;/td&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;summary&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
            fout.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; self.datas.remove(data)&lt;/span&gt;
        fout.write(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;/table&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        fout.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        fout.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        fout.close()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;爬取数据量少的情况下可用以上方法，否则要使用分批存储，避免发生异常，数据丢失。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5、爬虫调度器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　终于到最后步骤了，也是关键的一步，协调上面所有“器”，爬虫开始！&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; craw_pratice.adataOutput &lt;span&gt;import&lt;/span&gt;&lt;span&gt; DataOutput
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; craw_pratice.ahtmlDownloader &lt;span&gt;import&lt;/span&gt;&lt;span&gt; HtmlDownloader
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; craw_pratice.ahtmlParser &lt;span&gt;import&lt;/span&gt;&lt;span&gt; HtmlParser
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; craw_pratice.aurlManeger &lt;span&gt;import&lt;/span&gt;&lt;span&gt; UrlManager


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; spiderman(object):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        self.manage &lt;/span&gt;=&lt;span&gt; UrlManager()
        self.downloader &lt;/span&gt;=&lt;span&gt; HtmlDownloader()
        self.parser &lt;/span&gt;=&lt;span&gt; HtmlParser()
        self.output &lt;/span&gt;=&lt;span&gt; DataOutput()

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; crawl(self, root_url):
        self.manage.add_new_url(root_url)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 判断URL管理器中是否有新的URL，同时判断抓去了多少个URL&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt; (self.manage.has_new_url() &lt;span&gt;and&lt;/span&gt; self.manage.old_url_size() &amp;lt; 100&lt;span&gt;):
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
                new_url &lt;/span&gt;= self.manage.get_new_url()  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 从管理器获取新的URL&lt;/span&gt;
                &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;已经抓取%s个链接: %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; (self.manage.old_url_size(), new_url))
                html &lt;/span&gt;= self.downloader.download(new_url)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 下载网页&lt;/span&gt;
                &lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(html)&lt;/span&gt;
                new_urls, data = self.parser.parser(new_url, html)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 解析器抽取网页数据&lt;/span&gt;
                &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(data)
                self.manage.add_new_urls(new_urls)
                self.output.store_data(data)  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 存储&lt;/span&gt;
            &lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception:

                &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;crawl failed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        self.output.output_html()


&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
    root_url &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://baike.baidu.com/item/Python/407313&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    spider_man =&lt;span&gt; spiderman()
    spider_man.crawl(root_url) &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;至此，整个爬虫项目完成了，效果如图：&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1496983/202002/1496983-20200226213916658-1528952963.png&quot; alt=&quot;&quot; width=&quot;1236&quot; height=&quot;353&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;这是我成功后的小总结，而过程并不是如此顺利，而是遇到小问题，对程序代码不断debug，比如：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上面说到的requests问题，导致爬取的链接不存在，一直提示页面不存在。后来采取urllib解决。还有第3中urljoin的调用，整个小爬虫项目我用到的是python3.6，已经把urlparse模块封装到urllib里面，所以不采用import parser。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个项目实践让我学习到爬虫最基本的框架，各个功能都实现模块化，清晰简洁，为之后实现大型成熟的爬虫项目做了铺垫，分享学习心得，希望能学得更好，要继续努力！&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 26 Feb 2020 14:06:00 +0000</pubDate>
<dc:creator>Charzueus</dc:creator>
<og:description>以前学习写爬虫程序时候，我没有系统地学习爬虫最基本的模块框架，只是实现自己的目标而写出来的，最近学习基础的爬虫，但含有完整的结构，大型爬虫含有的基础模块，此项目也有，“麻雀虽小，五脏俱全”，只是没有考</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chenzhenhong/p/12367987.html</dc:identifier>
</item>
<item>
<title>「C++ 」借来的资源，何如还的潇洒？ - 小林coding</title>
<link>http://www.cnblogs.com/xiaolincoding/p/12369300.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaolincoding/p/12369300.html</guid>
<description>&lt;h2 id=&quot;h-5&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;本文的内容将专门对付&lt;strong&gt;内存管理&lt;/strong&gt;，培养起&lt;strong&gt;有借有还&lt;/strong&gt;的好习惯，方可消除资源管理的问题。&lt;/p&gt;
&lt;img src=&quot;https://img2018.cnblogs.com/common/1770351/202002/1770351-20200226214124237-908359578.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;h2 id=&quot;h-6&quot;&gt;&lt;span&gt;正文&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;所谓的资源就是，一旦用了它，将来必须还给系统。如果不是这样，糟糕的事情就会发生。&lt;/p&gt;
&lt;p&gt;C++ 程序内常见的资源：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;动态分配内存&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;文件描述符&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;互斥锁&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;图形页面中的字型和笔刷&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;数据库连接&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;网络 sockets&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;无论哪一种资源，重要的是，当你不再使用它时，必须将它还给系统，有借有还是个好习惯。&lt;/p&gt;
&lt;h3 id=&quot;h01&quot;&gt;&lt;span&gt;细节 01 ： 以对象管理资源&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;把资源放在析构函数，交给析构函数释放资源&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;假设某个 class 含有个工厂函数，该函数获取了对象的指针：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
A* createA();    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回指针，指向的是动态分配对象。
                 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用者有责任删除它。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上述注释所言，createA 的调用端使用了函数返回的对象后，有责任删除它。现在考虑有个&lt;code&gt;f&lt;/code&gt;函数履行了这个责任:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; f()
{
    A &lt;/span&gt;*pa = createA();  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用工厂函数&lt;/span&gt;
    ...                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 其他代码&lt;/span&gt;
    &lt;span&gt;delete&lt;/span&gt; pa;          &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 释放资源&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这看起来稳妥，但存在若干情况&lt;code&gt;f&lt;/code&gt;函数可能无法执行到&lt;code&gt;delete pa&lt;/code&gt;语句，也就会造成&lt;strong&gt;资源泄漏&lt;/strong&gt;，例如如下情况：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;或许因为「…」区域内的一个过早的 return 语句；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;或许因为「…」区域内的一个循环语句过早的continue 或 goto 语句退出；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;或许因为「…」区域内的语句抛出异常，无法执行到 delete。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当然可以通过谨慎地编写程序可以防止这一类错误，但你必须想想，代码可能会在时间渐渐过去后被修改，如果是一个新手没有注意这一类情况，那必然又会再次有内存泄漏的可能性。&lt;/p&gt;
&lt;p&gt;为确保 A 返回的资源都是被回收，我们需要将资源放进对象内，当对象离开作用域时，该对象的析构函数会自动释放资源。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;「智能指针」是个好帮手，交给它去管理指针对象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;对于是由动态分配（new）于堆内存的对象，指针对象离开了作用域并不会自动调用析构函数（需手动delete）&lt;/strong&gt;，为了让指针对象能像普通对象一样，离开作用域自动调用析构函数回收资源，我们需要借助「智能指针」的特性。&lt;/p&gt;
&lt;p&gt;常用的「智能指针」有如下三个：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;std::auto_ptr（ C++ 98 提供、C++ 11 建议摒弃不用 ）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;std::unique_ptr（ C++ 11 提供 ）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;std::shared_ptr（ C++ 11 提供 ）&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;hstdauto_ptr&quot;&gt;&lt;span&gt;std::auto_ptr&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;下面示范如何使用 std::auto_ptr 以避免 &lt;code&gt;f&lt;/code&gt; 函数潜在的资源泄漏可能性：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; f()
{
    std::auto_ptr&lt;/span&gt;&amp;lt;A&amp;gt; pa (createA()); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用工厂函数&lt;/span&gt;
    ...  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 一如既往的使用pa&lt;/span&gt;
}        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 离开作用域后，经由 auto_ptr 的析构函数自动删除pa;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个简单的例子示范「以对象管理资源」的两个关键想法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;获得资源后立刻放进管理对象内&lt;/strong&gt;。以上代码中 createA 返回的资源被当做其管理者 auto_ptr 的初值，也就立刻被放进了管理对象中。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;管理对象运用析构函数确保资源释放&lt;/strong&gt;。不论控制流如何离开区块，一旦对象被销毁（例如当对象离开作用域）其析构函数自然会被自动调用，于是资源被释放。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为什么在 C++11 建议弃用 auto_ptr 吗？当然是 auto_ptr 存在缺陷，所以后续不被建议使用。&lt;/p&gt;
&lt;p&gt;auto_ptr 有一个不寻常的特质：若通过「复制构造函数或赋值操作符函数」 &lt;strong&gt;copy&lt;/strong&gt; 它们，它们会变成 &lt;strong&gt;null&lt;/strong&gt; ，而复制所得的指针将获取资源的唯一拥有权！&lt;br/&gt;见如下例子说明：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
std::auto_ptr&amp;lt;A&amp;gt; pa1(createA()); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; pa1 指向 createA 返回物&lt;/span&gt;
&lt;span&gt;
std::auto_ptr&lt;/span&gt;&amp;lt;A&amp;gt; pa2(pa1); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 现在 pa2 指向对象，pa1将被设置为 null&lt;/span&gt;
&lt;span&gt;
pa1 &lt;/span&gt;= pa2; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 现在 pa1 指向对象，pa2 将被设置为 null&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这一诡异的复制行为，如果再次使用指向为 null 的指针，那必然会导致程序&lt;strong&gt;奔溃&lt;/strong&gt;。&lt;br/&gt;意味着 auto_ptr 并非管理动态分配资源的神兵利器。&lt;/p&gt;
&lt;h5 id=&quot;hstdunique_ptr&quot;&gt;&lt;span&gt;std::unique_ptr&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;unique_ptr 也采用所有权模型，但是在使用时，是直接&lt;strong&gt;禁止&lt;/strong&gt;通过复制构造函数或赋值操作符函数 copy 指针对象，如下例子在编译时，会出错：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
std::unique_ptr&amp;lt;A&amp;gt; pa1(createA()); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; pa1 指向 createA 返回物&lt;/span&gt;
&lt;span&gt;
std::unique_ptr&lt;/span&gt;&amp;lt;A&amp;gt; pa2(pa1); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 编译出错！&lt;/span&gt;
&lt;span&gt;
pa1 &lt;/span&gt;= pa2; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 编译出错！&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h5 id=&quot;hstdshared_ptr&quot;&gt;&lt;span&gt;std::shared_ptr&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;shared_ptr 在使用复制构造函数或赋值操作符函数后，&lt;strong&gt;引用计会数累加并且两个指针对象指向的都是同一个块内存&lt;/strong&gt;，这就与 unique_ptr、auto_ptr 不同之处。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; f()
{
    std::shared_ptr&lt;/span&gt;&amp;lt;A&amp;gt; pa1(createA()); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; pa1 指向 createA 返回物&lt;/span&gt;
&lt;span&gt;
    std::shared_ptr&lt;/span&gt;&amp;lt;A&amp;gt; pa2(pa1); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 引用计数+1，pa2和pa1指向同一个内存&lt;/span&gt;
&lt;span&gt;
    pa1 &lt;/span&gt;= pa2; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 引用计数+1，pa2和pa1指向同一个内存&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当一个对象离开作用域，shared_ptr 会把引用计数值 -1 ，&lt;strong&gt;直到引用计数值为 0 时，才会进行删除对象。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于 shared_ptr 释放空间时会事先要判断&lt;strong&gt;引用计数值的大小&lt;/strong&gt;，因此不会出现多次删除一个对象的错误。&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;h&quot;&gt;&lt;span&gt;小结 - 请记住&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;为防止资源泄漏，请使用 RAII（Resource Acquisition Is Initaliaztion - 资源取得时机便是初始化时机） 对象，它们在构造函数中获取资源，并在析构函数中是释放资源&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;两个建议使用的 RAII classes 分别是 std::unique_ptr 和 std::shared_ptr。前者不允许 copy 动作，后者允许 copy 动作。但是不建议用 std::auto_ptr，若选 auto_ptr，复制动作会使它（被复制物）指向 null 。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;hr/&gt;&lt;h3 id=&quot;h02copying&quot;&gt;&lt;span&gt;细节 02：在资源管理类中小心 copying 行为&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;假设，我们使用 C 语音的 API 函数处理类型为 Mutex 的互斥对象，共有 lock 和 unlock 两函数可用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; locak(Mutex *pm);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 锁定 pm 所指的互斥器&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; unlock(Mutex* pm); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将互斥器解除锁定&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为确保绝不会忘记一个被锁住的 Mutex 解锁，我们可能会希望创立一个 class 来管理锁资源。这样的 class 要遵守 RAII 守则，也就是「资源在构造期间获得，在析构释放期间释放」：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Lock
{
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;explicit&lt;/span&gt; Lock(Mutex *pm) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 构造函数&lt;/span&gt;
&lt;span&gt;        : pMutex(pm)
    {
        &lt;/span&gt;&lt;span&gt;lock&lt;/span&gt;&lt;span&gt;(pMutex);
    }

    &lt;/span&gt;~Lock()  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 析构函数&lt;/span&gt;
&lt;span&gt;    {
        unlock(pMutex);
    }
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;:
    Mutex&lt;/span&gt;*&lt;span&gt; pMutex;
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样定义的 Lock，用法符合 RAII 方式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Mutex m;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义你需要的互斥锁&lt;/span&gt;
&lt;span&gt;... 
{                 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 建立一个局部区块作用域&lt;/span&gt;
    Lock m1(&amp;amp;m);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 锁定互斥器&lt;/span&gt;
&lt;span&gt;    ...
}                 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在离开区块作用域，自动解除互斥器锁定&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这很好，但如果 Lock 对象被复制，会发生什么事情？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Lock m1(&amp;amp;m);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 锁定m&lt;/span&gt;
Lock m2(&amp;amp;m1); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将 m1 复制到 m2身上，这会发生什么？&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是我们需要思考和面对的：「当一个 RAII 对象被复制，会发生什么事情？」大多数时候你会选择以下两种可能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;禁止复制&lt;/strong&gt;。如果 RAII 不允许被复制，那我们需要将 class 的复制构造函数和赋值操作符函数声明在 private。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;使用引用计数法&lt;/strong&gt;。有时候我们希望保有资源，直到它直的最后一个对象被消耗。这种情况下复制 RAII 对象时，应该将资源的「被引用数」递增。std::shared_ptr 便是如此。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果前述的 Lock 打算使用&lt;strong&gt;使用引用计数法&lt;/strong&gt;，它可以使用 std::shared_ptr 来管理 pMutex 指针，然后很不幸 std::shared_ptr 的默认行为是「当引用次数为 0 时删除其所指物」那不是我们想要的行为，&lt;strong&gt;因为要对 Mutex 释放动作是解锁而非删除。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;幸运的是 std::shared_ptr 允许指定&lt;strong&gt;自定义的删除方式&lt;/strong&gt;，那是一个函数或函数对象。如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Lock
{
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;explicit&lt;/span&gt; Lock(Mutex *&lt;span&gt;pm)  
        : pMutex(pm, unlock)  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 以某个 Mutex 初始化 shared_ptr，
                              &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 并以 unlock 函数为删除器。&lt;/span&gt;
&lt;span&gt;    {
        &lt;/span&gt;&lt;span&gt;lock&lt;/span&gt;(pMutex.&lt;span&gt;get&lt;/span&gt;());  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; get 获取指针地址&lt;/span&gt;
&lt;span&gt;    }

&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;:
    std::shared_ptr&lt;/span&gt;&amp;lt;Mutex&amp;gt; pMutex; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用 shared_ptr&lt;/span&gt;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;请注意，本例的 Lock class 不再声明析构函数。因为编译器会自动创立默认的析构函数，来自动调用其 non-static 成员变量（本例为 pMutex ）的析构函数。&lt;/p&gt;
&lt;p&gt;而 pMutex 的析构函数会&lt;strong&gt;在互斥器的引用次数为 0 时，自动调用 std::shared_ptr 的删除器（本例为 unlock ）&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;h-1&quot;&gt;&lt;span&gt;小结 - 请记住&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;复制 RAII 对象必须一并复制它的所管理的资源（深拷贝），所以资源的 copying 行为决定 RAII 对象的 copying 行为。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;普通而常见的 RAII class copying 行为是：禁止 copying、施行引用计数法。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;hr/&gt;&lt;h3 id=&quot;h03&quot;&gt;&lt;span&gt;细节 03 ：在资源类中提供对原始资源的访问&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;智能指针「显式」转换，也就是通过 get 成员函数的方式转换为原始指针对象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面提到的「智能指针」分别是：std::auto_ptr、std::unique_ptr、std::shared_ptr。它们都有访问原始资源的办法，都提供了一个 get 成员函数，用来执行&lt;strong&gt;显式转换&lt;/strong&gt;，也就是它会&lt;strong&gt;返回智能指针内部的原始指针（的复件）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;举个例子，使用智能指针如 std::shared_ptr 保存 createA() 返回的指针对象 ：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
std::shared_ptr&amp;lt;A&amp;gt; pA(createA());
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;假设你希望以某个函数处理 A 对象，像这样：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; getInfo(&lt;span&gt;const&lt;/span&gt; A* pA);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;你想这么调用它：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
std::shared_ptr&amp;lt;A&amp;gt;&lt;span&gt; pA(createA());
getInfo(pA);       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 错误！！&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;会编译错误，因为 getInfo 需要的是 &lt;code&gt;A&lt;/code&gt; 指针对象，而不是类型为 &lt;code&gt;std::shared_ptr&amp;lt;A&amp;gt;&lt;/code&gt; 的对象。&lt;/p&gt;
&lt;p&gt;这时候就需要用 std::shared_ptr 智能指针提供的 &lt;code&gt;get&lt;/code&gt; 成员函数访问原始的资源：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
std::shared_ptr&amp;lt;A&amp;gt;&lt;span&gt; pA(createA());
getInfo(pA.&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;());   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 很好，将 pA 内的原始指针传递给 getInfo&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;智能指针「隐式」转换的方式，是通过指针取值操作符。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;智能指针都重载了指针取值操作符（operator-&amp;gt;和operator*），它们允许&lt;strong&gt;隐式转换&lt;/strong&gt;至底部原始指针：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; A
{
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;：
    &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; isExist() &lt;span&gt;const&lt;/span&gt;&lt;span&gt;;
    ...
};

A&lt;/span&gt;* createA();  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 工厂函数，创建指针对象&lt;/span&gt;
&lt;span&gt;
std::shared_ptr&lt;/span&gt;&amp;lt;A&amp;gt; pA(createA()); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 令 shared_ptr 管理对象资源&lt;/span&gt;

&lt;span&gt;bool&lt;/span&gt; exist = pA-&amp;gt;isExist();    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 经由 operator-&amp;gt; 访问资源&lt;/span&gt;
&lt;span&gt;bool&lt;/span&gt; exist2 = (*pA).isExist(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 经由 operator* 访问资源&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;多数设计良好的 classes 一样，它隐藏了程序员不需要看到的部分，但是有程序员需要的所有东西。&lt;/p&gt;
&lt;p&gt;所以对于自身设计 RAII classes 我们也要提供一个「取得其所管理的资源」的办法。&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;h-2&quot;&gt;&lt;span&gt;小结 - 请记住&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;APIs 往往要求访问原始资源，所以每一个 RAII class 应该提供一个「取得其所管理的资源」的办法。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;对原始资源的访问可能经由显式转换或隐式转换。一般而言显式转换比较安全，但隐式转换比较方便。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;hr/&gt;&lt;h3 id=&quot;h04newdelete&quot;&gt;&lt;span&gt;细节 04：成对使用 new 和 delete&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;以下动作有什么错？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
std::&lt;span&gt;string&lt;/span&gt;* strArray = &lt;span&gt;new&lt;/span&gt; std::&lt;span&gt;string&lt;/span&gt;[&lt;span&gt;100&lt;/span&gt;&lt;span&gt;];
...
&lt;/span&gt;&lt;span&gt;delete&lt;/span&gt; strArray;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;每件事情看起来都井然有序。使用了 new，也搭配了对应的 delete。但还是有某样东西完全错误。strArray 所含的 100 个 string 对象中的 99 个不太可能被适当删除，因为它们的析构函数很可能没有被调用。&lt;/p&gt;
&lt;p&gt;当使用 new ，有两件事发生：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;内存被分配出来（通过名为 operator new 的函数）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;针对此内存会有&lt;strong&gt;一个或多个&lt;/strong&gt;构造函数被调用&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当使用 delete，也会有两件事情：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;针对此内存会有&lt;strong&gt;一个或多个&lt;/strong&gt;析构函数被调用&lt;/li&gt;
&lt;li&gt;&lt;span&gt;然后内存才被释放（通过名为 operator delete 的函数）&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;delete 的最大问题在于：&lt;strong&gt;即将被删除的内存之内究竟有多少对象？这个答案决定了需要执行多少个析构函数。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对象数组所用的内存通常还包括「数组大小」的记录，以便 delete 知道需要调用多少次析构函数。单一对象的内存则没有这笔记录。你可以把两者不同的内存布局想象如下，其中 n 是数组大小：&lt;/p&gt;
&lt;p&gt;当你对着一个指针使用 delete，唯一能够让 delete 知道内存中是否存在一个「数组大小记录」的办法就是：由你告诉它。如果你使用 delete 时加上中括号&lt;strong&gt;[]&lt;/strong&gt;，delete 便认定指针指向一个数组，否则它便认定指针指向一个单一对象：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
std::&lt;span&gt;string&lt;/span&gt;* strArray = &lt;span&gt;new&lt;/span&gt; std::&lt;span&gt;string&lt;/span&gt;[&lt;span&gt;100&lt;/span&gt;&lt;span&gt;];
std::&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;* strPtr = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; std::strin;
... 
&lt;/span&gt;&lt;span&gt;delete&lt;/span&gt; [] strArray;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 删除一个对象&lt;/span&gt;
&lt;span&gt;delete&lt;/span&gt; strPtr;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 删除一个由对象组成的数组&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;游戏规则很简单：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果你在 new 表达式中&lt;strong&gt;使用[]&lt;/strong&gt;，必须在相应的 delete 表达式也&lt;strong&gt;使用[]&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;如果你在 new 表达式中&lt;strong&gt;不使用[]&lt;/strong&gt;，一定&lt;strong&gt;不要&lt;/strong&gt;在相应的 delete 表达式&lt;strong&gt;使用[]&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;h4 id=&quot;h-3&quot;&gt;&lt;span&gt;小结 - 请记住&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;如果你在 new 表达式中使用[]，必须在相应的 delete 表达式也使用[]。如果你在 new 表达式中不使用[]，一定不要在相应的 delete 表达式使用[]。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;hr/&gt;&lt;h3 id=&quot;h05newednew&quot;&gt;&lt;span&gt;细节 05：以独立语句将 newed （已被 new 的）对象置入智能指针&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;假设我们有个以下示范的函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt;&lt;span&gt; getNum();
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; fun(std::shared_ptr&amp;lt;A&amp;gt; pA, &lt;span&gt;int&lt;/span&gt; num);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在考虑调用 fun：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
fun(&lt;span&gt;new&lt;/span&gt; A(), getNum());
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它不能通过编译，因为 &lt;code&gt;std::shared_ptr&lt;/code&gt; 构造函数需要一个原始指针，而且该构造函数是个 &lt;code&gt;explicit&lt;/code&gt; 构造函数，无法进行隐式转换。如果写成这样就可以编译通过：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
fun(std::shared_ptr&amp;lt;A&amp;gt;(&lt;span&gt;new&lt;/span&gt; A), getNum());
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;令人想不到吧，上述调用却可能&lt;strong&gt;泄露资源&lt;/strong&gt;。接下来我们来一步一步的分析为什么存在内存泄漏的可能性。&lt;/p&gt;
&lt;p&gt;在进入 &lt;code&gt;fun&lt;/code&gt; 函数之前，肯定会先执行各个实参。上述第二个实参只是单纯的对 &lt;code&gt;getNum&lt;/code&gt; 函数的调用，但第一个实参 &lt;code&gt;std::shared_ptr&amp;lt;A&amp;gt;(new A)&lt;/code&gt; 由两部分组成：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;执行 &lt;code&gt;new A&lt;/code&gt; 表达式&lt;/li&gt;
&lt;li&gt;调用 &lt;code&gt;std::shared_ptr&lt;/code&gt; 构造函数&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;于是在调用 &lt;code&gt;fun&lt;/code&gt; 函数之前，先必须做以下三件事：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;调用 &lt;code&gt;getNum&lt;/code&gt; 函数&lt;/li&gt;
&lt;li&gt;执行 &lt;code&gt;new A&lt;/code&gt; 表达式&lt;/li&gt;
&lt;li&gt;调用 &lt;code&gt;std::shared_ptr&lt;/code&gt; 构造函数&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;那么他们的执行次序是一定如上述那样的吗？可以确定的是 &lt;code&gt;new A&lt;/code&gt; 一定比 &lt;code&gt;std::shared_ptr&lt;/code&gt; 构造函数先被执行。但对 getNum 调用可以排在第一或第二或第三执行。&lt;/p&gt;
&lt;p&gt;如果编译器选择以第二顺位执行它：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;执行 &lt;code&gt;new A&lt;/code&gt; 表达式&lt;/li&gt;
&lt;li&gt;调用 &lt;code&gt;getNum&lt;/code&gt; 函数&lt;/li&gt;
&lt;li&gt;调用 &lt;code&gt;std::shared_ptr&lt;/code&gt; 构造函数&lt;br/&gt;万一在调用 &lt;code&gt;getNum&lt;/code&gt; 函数发生了异常，会发生什么事情？在此情况下 &lt;code&gt;new A&lt;/code&gt; 返回的指针将不会置入 &lt;code&gt;std::shared_ptr&lt;/code&gt; 智能指针里，就&lt;strong&gt;存在内存泄漏的现象&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;避免这类问题的办法很简单：使用&lt;strong&gt;分离语句&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;分别写出：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;创建 A&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;将它置入一个智能指针内&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;然后再把智能指针传递给 &lt;code&gt;fun&lt;/code&gt; 函数。&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
std::shared_ptr&amp;lt;A&amp;gt; pA(&lt;span&gt;new&lt;/span&gt; A); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 先构造智能指针对象&lt;/span&gt;
fun(pA, getNum()); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这个调用动作绝不至于造成泄漏。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上的方式，就能避免原本由于次序导致内存泄漏发生。&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;h-4&quot;&gt;&lt;span&gt;小结 - 请记住&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;以独立语句将 newed （已 new 过） 对象存储于智能指针内。如果不这样做，一旦异常被抛出，有可能导致难以察觉的资源泄漏。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;hr/&gt;&lt;h2 id=&quot;h-7&quot;&gt;&lt;span&gt;最后&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;本文部分内容参考了《Effective C++ （第3版本）》第三章节内容，前两章节的内容可看旧文&lt;br/&gt;《&lt;a href=&quot;https://mp.weixin.qq.com/s/3dUQpmKsA-6LHopYY9u4HQ&quot;&gt;学过 C++ 的你，不得不知的这 10 条细节！&lt;/a&gt;》&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;关注公众号，后台回复「我要学习」，即可免费获取精心整理「服务器 Linux C/C++ 」成长路程（书籍资料 + 思维导图）&lt;/p&gt;
&lt;img src=&quot;https://img2018.cnblogs.com/common/1770351/202002/1770351-20200226214651648-1265295690.png&quot; alt=&quot;&quot;/&gt;</description>
<pubDate>Wed, 26 Feb 2020 13:49:00 +0000</pubDate>
<dc:creator>小林coding</dc:creator>
<og:description>有借有还是好习惯！</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiaolincoding/p/12369300.html</dc:identifier>
</item>
</channel>
</rss>