<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>机器学习——dbscan密度聚类 - 大数据技术宅</title>
<link>http://www.cnblogs.com/followees/p/14003340.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/followees/p/14003340.html</guid>
<description>&lt;p&gt;完整版可关注公众号:大数据技术宅获取&lt;/p&gt;
&lt;p&gt;DBSCAN（Density-Based Spatial Clustering of Applications with Noise，基于密度的有噪应用中的空间聚类）是一种简单，却又在处理时空数据时表现不错的算法，借最近正好有看，这里整理下。不同于k-means，以中心点为原则进行聚类，只要样本点离同一个簇中心最近，就被划分到同一个簇中，且簇的形状是“类圆形”（凸形状）。DBSCAN将簇定义为密度相连的点的最大集合，即把样本点的密度情况作为聚类的基本原则，然后把相互之间有联系且聚集程度高的那些部分连接起来最终形成簇。&lt;/p&gt;
&lt;p&gt;DBSCAN原理&lt;/p&gt;
&lt;p&gt;DBSCAN的原理可以概括为：同一个簇，其样本两两相连；对于任意一个簇，对应的样本集是最大最完整的，即在所有样本点中，如果某个样本点是由一个簇中的点出发可达的，那么该点也将被划分到同一个簇。&lt;/p&gt;
&lt;p&gt;      然而，如何定义上述的相连和可达呢，下面将给出DBSCAN的相关概念。&lt;/p&gt;
&lt;p&gt;DBSCAN相关概念&lt;/p&gt;
&lt;p&gt;ϵ-邻域：以给定对象为中心，ϵ为半径的区域。&lt;/p&gt;
&lt;p&gt;核心对象（核心点）：对于给定的点数MinPts，如果点p的ϵ邻域包含至少MinPts个样本点（包含p），那么点p就被称作核心对象。&lt;/p&gt;
&lt;p&gt;密度直达：如果点p为核心对象，样本点q出现在P的ϵ-邻域中，那么点q就是点p出发直接密度可达的（注意：不能说点p是由q出发密度直达的，除非q也是核心对象）。&lt;/p&gt;
&lt;p&gt;密度可达：可达指从核心点出发可以到达的样本点。这里的到达分为2种情况：一种情况就是上面所说的密度直达的；另外一种，就是间接到达的。间接能到达就是说，可以找到一个对象链（序列），如p，p1，p2，...，pn，q（n&amp;gt;=1），其中后者从前者是密度直达的（p1由p直达，p1由p0直达，q由pn直达），那么q就是由核心对象p出发可达的，q是一个可达点。&lt;/p&gt;
&lt;p&gt;密度相连：对于两个样本点p和q，如果能找到一个样本点o，使得o到p可达，同时o到q也可达，那么p和q就是密度相连的。&lt;/p&gt;
&lt;p&gt;簇：最大的密度相连对象的集合。&lt;/p&gt;
&lt;p&gt;噪声：不包含在任何簇中的对象。&lt;/p&gt;
&lt;p&gt;为了让大家更直观的理解以上概念，给大家举个小例子（见下图，忽略字丑）。这里假设MinPts=4，ϵ=1cm，那么可以看出，对于左边2个图中标绿的点，显然为核心对象，因为以它们为中心，ϵ为半径画圆后，圆里边的样本点数均大于MinPts的值4。左图s为q出发的密度直达点；左图p为q出发密度可达点；中间那幅图，由于o到p可达，o到q可达，故p和q密度相连。右图由于最上边的那个样本点不在任何簇中，所以被归为噪声。&lt;/p&gt;






&lt;p&gt;DBSCAN优缺点&lt;/p&gt;
&lt;p&gt;（1）优点&lt;/p&gt;
&lt;p&gt;无需指定簇个数&lt;/p&gt;
&lt;p&gt;对任意形状的稠密数据集都可以聚类，簇的形状可以任意&lt;/p&gt;
&lt;p&gt;擅长寻找离群点（检测任务）&lt;/p&gt;
&lt;p&gt;（2）缺点：&lt;/p&gt;
&lt;p&gt;不适用于样本集密度不均匀、聚类间距相差大的情况&lt;/p&gt;
&lt;p&gt;样本集较大时，聚类收敛时间较长&lt;/p&gt;
&lt;p&gt;参数不好选择（参数对聚类结果的影响较大）&lt;/p&gt;
&lt;p&gt;DBSCAN聚类举例&lt;/p&gt;
&lt;p&gt;（1）生成数据集&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;p&gt;1#导入所需python模块&lt;/p&gt;
&lt;p&gt; 2from sklearn.datasets import make_blobs&lt;/p&gt;
&lt;p&gt; 3from sklearn.cluster import DBSCAN&lt;/p&gt;
&lt;p&gt; 4import matplotlib; matplotlib.use('TkAgg')&lt;/p&gt;
&lt;p&gt; 5import matplotlib.pyplot as plt&lt;/p&gt;
&lt;p&gt; 6import numpy as np&lt;/p&gt;
&lt;p&gt; 7#利用生成器生成具有三个簇的合成数据集，共1000个样本点，为方便作图，特征维度这里设为2&lt;/p&gt;
&lt;p&gt; 8X,t=make_blobs(n_samples=1000,n_features=2,centers=[[1.2,1.5],[2.2,1.1],[1.5,2.8]],cluster_std=[[0.3],[0.2],[0.25]],random_state=2020)&lt;/p&gt;
&lt;p&gt; 9#生成样本点的分布图&lt;/p&gt;
&lt;p&gt;10fig=plt.figure(figsize=(8,8))&lt;/p&gt;
&lt;p&gt;11ax=fig.add_subplot(111)&lt;/p&gt;
&lt;p&gt;12ax.scatter(X[:,0],X[:,1])&lt;/p&gt;
&lt;p&gt;13plt.show()&lt;/p&gt;


&lt;p&gt;生成的样本点分布图：&lt;/p&gt;

</description>
<pubDate>Thu, 19 Nov 2020 00:37:00 +0000</pubDate>
<dc:creator>大数据技术宅</dc:creator>
<og:description>完整版可关注公众号:大数据技术宅获取 DBSCAN（Density-Based Spatial Clustering of Applications with Noise，基于密度的有噪应用中的空间聚</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/followees/p/14003340.html</dc:identifier>
</item>
<item>
<title>HotSpot源码分析之C++对象的内存布局 - HotSpot-Researcher</title>
<link>http://www.cnblogs.com/mazhimazhi/p/14003295.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mazhimazhi/p/14003295.html</guid>
<description>&lt;p&gt;HotSpot采用了OOP-Klass模型来描述Java类和对象。OOP（Ordinary Object Pointer）指的是普通对象指针，而Klass用来描述对象的具体类型。为了更好理解这个模型，首先要介绍一下C++的内存对象模型和虚函数。&lt;/p&gt;
&lt;h3&gt;1、C++类对象的内存布局&lt;/h3&gt;
&lt;p&gt;我们使用Visual Studio工具来查看C++对象的内存布局，所以需要在当前项目上右键单击选择“属性”后，打开属性页，在配置属性-&amp;gt;C/C++-&amp;gt;命令行下的其它选项文本框中配置如下命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
/d1 reportAllClassLayout
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样，运行main()函数后就会打印出对应的内存布局。如果想要指定看某个类的内存布局时，可以配置命令： &lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
/d1 reportSingleClassLayoutXXX  // XXX表示类名
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;内存布局的原则，简单来说就是&lt;strong&gt;：成员变量按其被声明的顺序排列，按具体实现所规定的对齐原则在内存地址上对齐。&lt;/strong&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
class Base1{
 
public: 
 char        base1_var1; 
 int         base1_var2;

 static int  base1_var3;

 void func(){}  
};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出的布局如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
1&amp;gt;  class Base1      size(8):
1&amp;gt;   +---
1&amp;gt;   0       | base1_var1
1&amp;gt;           | &amp;lt;alignment member&amp;gt; (size=3)
1&amp;gt;   4       | base1_var2
1&amp;gt;   +---
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;根据如上的布局结果可知：&lt;/p&gt;
&lt;p data-change-style-times=&quot;1&quot;&gt;&lt;span data-change-style-times=&quot;1&quot;&gt;（一）类内部的成员变量：&lt;/span&gt;&lt;/p&gt;
&lt;ul data-change-style-times=&quot;1&quot;&gt;&lt;li data-change-style-times=&quot;1&quot;&gt;&lt;span data-change-style-times=&quot;1&quot;&gt;普通的变量要占用内存，按照声明成员的先后顺序进行布局（类内偏移从0开始），但是要注意对齐原则。对于如上实例来说，4个字节包含一个字符（实际占用1个字节，3个字节空着，补对齐），后4个字节包含一个整数。A的指针就指向字符开始字节处。&lt;/span&gt;&lt;/li&gt;
&lt;li data-change-style-times=&quot;1&quot;&gt;&lt;span data-change-style-times=&quot;1&quot;&gt;static修饰的静态变量不占用内容，原因是编译器将其放在全局变量区。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-change-style-times=&quot;1&quot;&gt;&lt;span data-change-style-times=&quot;1&quot;&gt;（二）类内部的成员函数：&lt;/span&gt;&lt;/p&gt;
&lt;ul data-change-style-times=&quot;1&quot;&gt;&lt;li data-change-style-times=&quot;1&quot;&gt;&lt;span data-change-style-times=&quot;1&quot;&gt;普通函数不占用内存。&lt;/span&gt;&lt;/li&gt;
&lt;li data-change-style-times=&quot;1&quot;&gt;&lt;span data-change-style-times=&quot;1&quot;&gt;虚函数要占用8个字节，用来指定虚拟函数表的入口地址。后面会介绍。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;空类也会占用内存空间的，而且大小是1，原因是C++要求每个实例在内存中都有独一无二的地址。&lt;/p&gt;
&lt;p&gt;下面继续讨论有继承的情况，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
class Base1{
 
public: 
 char        base1_var1; 
 int         base1_var2;

 static int  base1_var3;

 void func(){}  
};

class Derived1:public Base1{
public:
  int         derived1_var1;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出的布局如下：　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
1&amp;gt;  class Derived1   size(12):
1&amp;gt;   +---
1&amp;gt;   | +--- (base class Base1)
1&amp;gt;   0       | | base1_var1
1&amp;gt;           | | &amp;lt;alignment member&amp;gt; (size=3)
1&amp;gt;   4       | | base1_var2
1&amp;gt;   | +---
1&amp;gt;   8       | derived1_var1
1&amp;gt;   +---
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到，子类继承了父类的成员变量，在内存布局上，先是布局了父类的成员变量（父类的内存分布不变），接着布局子类的成员变量。&lt;/p&gt;
&lt;p&gt;在HotSpot中，经常需要计算类本身需要占用的内在大小，只要通过sizeof来计算即可。编写main() 函数来测试：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
void main(int argc,char *argv[]){
        cout &amp;lt;&amp;lt; &quot;Base1的大小&quot; &amp;lt;&amp;lt; sizeof(Base1) &amp;lt;&amp;lt; endl;
        cout &amp;lt;&amp;lt; &quot;Derived1的大小&quot; &amp;lt;&amp;lt; sizeof(Derived1) &amp;lt;&amp;lt; endl;
        system(&quot;pause&quot;); // 为了让运行程序停止，以便察看结果
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行后打印结果如下：&lt;/p&gt;
&lt;p&gt;Base1的大小8&lt;br/&gt;Derived1的大小12&lt;/p&gt;
&lt;p&gt;另外在HotSpot中经常做的操作就是计算某个变量的偏移量。例如定义的用来表示Java类的C++类Klass中有如下2个函数： &lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
static ByteSize access_flags_offset(){
  return in_ByteSize(offset_of(Klass, _access_flags));
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中的_access_flags属性就是定义在Klass中的，通过调用access_flags_offset()来计算这个属性在类中的偏移量。offset_of是一个宏，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
#define offset_of(klass,field) (size_t)((intx)&amp;amp;(((klass*)16)-&amp;gt;field) - 16)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;则经过宏替换和格式调整后的方法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
static ByteSize access_flags_offset(){
  return in_ByteSize((size_t)(
     (intx)&amp;amp;(  ((Klass*)16)-&amp;gt;_access_flags) - 16
  ));
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过(intx)&amp;amp;(((Klass*)16)-&amp;gt;_access_flags) - 16 方式来计算出具体的偏移量。解释一下这种写法。&lt;/p&gt;
&lt;p&gt;假如定义个变量Klass a; 我们都知道&amp;amp;a表示变量a的首地址，&amp;amp;(a._access_flags)表示变量_access_flags的地址，那么&amp;amp;(a._access_flags)减去&amp;amp;a就得到_access_flags的偏移量。&lt;/p&gt;
&lt;p&gt;((Klass*)16)的地址为16，所以偏移量最终等于&amp;amp;( ((Klass*)16)-&amp;gt;_access_flags)减去16。&lt;/p&gt;
&lt;p&gt;当HotSpot JVM要用一个成员变量的时候，它会根据对象的首地址加上成员的偏移量得到成员变量的地址。当对象的首地址为0时，得到的成员变量地址就是它的偏移量。&lt;/p&gt;
&lt;h3&gt;2、虚函数　　&lt;/h3&gt;
&lt;p&gt;HotSpot采用了OOP-Klass模型来描述Java类和对象。那么为何要设计这样一个一分为二的对象模型呢？因为类和对象本来就不是一个概念，分别使用不同的对象模型描述符合软件开发的设计思想。另外英文注释也说明了其中的一个原因：&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;One reason for the oop/klass dichotomy in the implementation is that we don't want a C++ vtbl pointer in every object. Thus,&lt;br/&gt;normal oops don't have any virtual functions. Instead, they forward all &quot;virtual&quot; functions to their klass, which does have&lt;br/&gt;a vtbl and does the C++ dispatch depending on the object's actual type. (See oop.inline.hpp for some of the forwarding code.)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;根据注释描述，HotSopt的设计者不想让每个对象中都含有一个vtable（虚函数表），所以就把对象模型拆成klass和oop，其中oop中不含有任何虚函数，而klass就含有虚函数表，可以进行方法分发。&lt;/p&gt;
&lt;p&gt;我们简单介绍一下虚函数是如何影响C++中对象的内存布局的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、只含有数据成员的对象 &lt;/strong&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
class Base1{
 
public: 
int base1_var1; 
int base1_var2; 

};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对象的内存布局如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
1&amp;gt;  class Base1      size(8):
1&amp;gt;   +---
1&amp;gt;   0       | base1_var1
1&amp;gt;   4       | base1_var2
1&amp;gt;   +---
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到，成员变量是按照定义的顺序来保存的，类对象的大小就是所有成员变量的大小之和。　&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、没有虚函数的对象&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
class Base1{
 
public: 
int base1_var1; 
int base1_var2; 
 
void func(){}  
};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;C++中有方法的动态分派，就类似于Java中方法的多态。而C++实现动态分派主要就是通过虚函数来完成的，非虚函数在编译时就已经确定调用目标。C++中的虚函数通过关键字virtual来声明，如上函数func()没有virtual关键字，所以是非虚函数。　　&lt;/p&gt;
&lt;p&gt;查看内存布局，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
1&amp;gt;  class Base1      size(8):
1&amp;gt;   +---
1&amp;gt;   0       | base1_var1
1&amp;gt;   4       | base1_var2
1&amp;gt;   +---
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;非虚函数不会影响内存布局。　&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、含有虚函数的对象 &lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
class Base1{
 
public: 
int base1_var1; 
int base1_var2; 
 
virtual void base1_fun1() {}

};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;内存布局如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
1&amp;gt;  class Base1      size(16):
1&amp;gt;   +---
1&amp;gt;   0       | {vfptr}
1&amp;gt;   8       | base1_var1
1&amp;gt;  12       | base1_var2
1&amp;gt;   +---
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在64位环境下，指针占用8字节，而vfptr就是指向虚函数表（vtable）的指针，其类型为void**, 这说明它是一个void*指针。类似于在类Base1中定义了如下类似的伪代码： &lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
void* vtable[1] = {  &amp;amp;Base1::base1_fun1  };

const void**  vfptr = &amp;amp;vtable[0];
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另外我们还可以看到，虚函数指针vfptr位于所有的成员变量之前。　&lt;/p&gt;
&lt;p&gt;我们在上面的例子中再添加一个虚函数，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
virtual void base1_fun2() {}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;内存布局如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
1&amp;gt;  class Base1      size(16):
1&amp;gt;   +---
1&amp;gt;   0       | {vfptr}
1&amp;gt;   8       | base1_var1
1&amp;gt;  12       | base1_var2
1&amp;gt;   +---
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到，内存布局无论有一个还是多个虚函数都是一样的，改变的只是vfptr指向的虚函数表中的项。类似于在类Base1中定义了如下类似的伪代码：　&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
void* vtable[] = { &amp;amp;Base1::base1_fun1, &amp;amp;Base1::base1_fun2 };

const void** vfptr = &amp;amp;vtable[0];
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;4、继承类对象&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
class Base1{
 
public:
 
int base1_var1; 
int base1_var2;
 
 
virtual void base1_fun1() {} 
virtual void base1_fun2() {}
 
};
 
 
class Derive1 : public Base1{
 
public:
 
int derive1_var1; 
int derive1_var2;
 
};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看Derive1对象的内存布局，如下： &lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
1&amp;gt;  class Derive1    size(24):
1&amp;gt;   +---
1&amp;gt;   | +--- (base class Base1)
1&amp;gt;   0       | | {vfptr}
1&amp;gt;   8       | | base1_var1
1&amp;gt;  12       | | base1_var2
1&amp;gt;   | +---
1&amp;gt;  16       | derive1_var1
1&amp;gt;  20       | derive1_var2
1&amp;gt;   +---
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到，基类在上边, 继承类的成员在下边，并且基类的内存布局与之前介绍的一模一样。继续来改造如上的实例，为派生类Derive1添加一个与基本base1_fun1()函数一模一样的虚函数，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
class Base1{
 
public:
 
int base1_var1; 
int base1_var2;
 
 
virtual void base1_fun1() {} 
virtual void base1_fun2() {}
 
};
 
 
class Derive1 : public Base1{
 
public:
 
int derive1_var1; 
int derive1_var2;

virtual void base1_fun1() {} // 覆盖基类函数
 
};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;布局如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
1&amp;gt;  class Derive1    size(24):
1&amp;gt;   +---
1&amp;gt;   | +--- (base class Base1)
1&amp;gt;   0       | | {vfptr}
1&amp;gt;   8       | | base1_var1
1&amp;gt;  12       | | base1_var2
1&amp;gt;   | +---
1&amp;gt;  16       | derive1_var1
1&amp;gt;  20       | derive1_var2
1&amp;gt;   +---
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;基本的布局没变，不过由于发生了虚函数覆盖，所以虚函数表中的内容已经发生了变化，类似于在类Derive1中定义了如下类似的伪代码：　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
void* vtable[] = { &amp;amp;Derive1::base1_fun1, &amp;amp;Base1::base1_fun2 };

const void** vfptr = &amp;amp;vtable[0];
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到，vtable[0]指针指向的是Derive1::base1_fun1()函数。所以当调用Derive1对象的base1_fun1()函数时，会根据虚函数表找到Derive1::base1_fun1()函数进行调用，而当调用Base1对象的base1_fun1()函数时，由于Base1对象的虚函数表中的vtable[0]指针指向Base1::base1_func1()函数，所以会调用Base1::base1_fun1()函数。是不是和Java中方法的多态很像？那么HotSpot虚拟机是怎么实现Java方法的多态呢？我们后续在讲解Java方法时会详细介绍。&lt;/p&gt;
&lt;p&gt;下面继续看虚函数的相关实例，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
class Base1{
 
public:
 
int base1_var1; 
int base1_var2;
 
 
virtual void base1_fun1() {} 
virtual void base1_fun2() {}
 
};
 
 
class Derive1 : public Base1{
 
public:
 
int derive1_var1; 
int derive1_var2;

virtual void derive1_fun1() {}
 
};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对象的内存布局如下：　&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
1&amp;gt;  class Derive1    size(24):
1&amp;gt;   +---
1&amp;gt;   | +--- (base class Base1)
1&amp;gt;   0       | | {vfptr}
1&amp;gt;   8       | | base1_var1
1&amp;gt;  12       | | base1_var2
1&amp;gt;   | +---
1&amp;gt;  16       | derive1_var1
1&amp;gt;  20       | derive1_var2
1&amp;gt;   +---
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对象的内存布局没有改变，改变的仍然是虚函数表，类似于在类Derive1中定义了如下类似的伪代码： &lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
void* vtable[] = { &amp;amp;Derive1::base1_fun1, &amp;amp;Base1::base1_fun2，&amp;amp;Derive1::derive1_fun1 };

const void** vfptr = &amp;amp;vtable[0];
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到，在虚函数表中追加了&amp;amp;Derive1::derive1_fun1()函数。　　&lt;/p&gt;
&lt;p&gt;好了，关于对象的布局我们就简单的介绍到这里，因为毕竟不是在研究C++，只要够我们研究HotSpot时使用就够了，更多关于内存布局的知识请参考其它文章或书籍。&lt;/p&gt;
&lt;p&gt;其它文章：&lt;/p&gt;
&lt;p&gt;1、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13983301.html&quot; target=&quot;_blank&quot;&gt;在Ubuntu 16.04上编译OpenJDK8的源代码（配视频）&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;2、&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2 vertical-middle&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13992240.html&quot;&gt;调试HotSpot源代码（配视频）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3、&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2 vertical-middle&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13222664.html&quot;&gt;HotSpot项目结构&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4、&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2 vertical-middle&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13997925.html&quot;&gt;HotSpot的启动过程（配视频进行源码分析）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;搭建过程中如果有问题可直接评论留言或加作者微信mazhimazh。&lt;/p&gt;
&lt;p&gt;作者持续维护的个人博客  &lt;a href=&quot;http://classloading.com/&quot; target=&quot;_blank&quot;&gt;classloading.com&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;B站上有HotSpot源码分析相关视频 &lt;a href=&quot;https://space.bilibili.com/27533329&quot;&gt;https://space.bilibili.com/27533329&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;关注公众号，有HotSpot源码剖析系列文章！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1236123/202006/1236123-20200630200021532-955264784.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;  　&lt;/p&gt;

</description>
<pubDate>Thu, 19 Nov 2020 00:15:00 +0000</pubDate>
<dc:creator>HotSpot-Researcher</dc:creator>
<og:description>HotSpot采用了OOP-Klass模型来描述Java类和对象。OOP（Ordinary Object Pointer）指的是普通对象指针，而Klass用来描述对象的具体类型。为了更好理解这个模型，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mazhimazhi/p/14003295.html</dc:identifier>
</item>
<item>
<title>企业网络拓扑VRRP主备功能实例(一) - 南空城</title>
<link>http://www.cnblogs.com/zhangwencheng/p/14002891.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangwencheng/p/14002891.html</guid>
<description>&lt;p&gt;&lt;strong&gt;组网图形&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1080590/202011/1080590-20201118230635370-1421603371.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; VRRP主备备份简介&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通常，同一网段内的所有主机上都存在一条相同的、以网关为下一跳的缺省路由。主机发往其他网段的报文将通过缺省路由发往网关，再由网关进行转发，从而实现主机与外部网络的通信。当网关发生故障时，本网段内所有以网关为缺省路由的主机将无法与外部网络通信。增加出口网关是提高系统可靠性的常见方法，此时如何在多个出口之间进行选路就成为需要解决的问题。&lt;/li&gt;
&lt;li&gt;VRRP的出现很好的解决了这个问题。VRRP能够在不改变组网的情况下，采用将多台路由设备组成一个虚拟路由器，通过配置虚拟路由器的IP地址为默认网关，实现默认网关的备份。当网关设备发生故障时，VRRP机制能够选举新的网关设备承担数据流量，从而保障网络通信的可靠性。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;p&quot; readability=&quot;68&quot;&gt;
&lt;ul&gt;&lt;li&gt;在配置VRRP备份组内各&lt;span class=&quot;keyword&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;交换机时，建议将Backup配置为立即抢占，即不延迟（延迟时间为0），而将Master配置为延时抢占，并且配置15秒以上的延迟时间。这样配置的目的是为了在网络环境不稳定时，在上下行链路的状态恢复一致性期间等待一定时间，避免由于双方频繁抢占导致用户设备学习到错误的Master设备地址而导致流量中断问题。&lt;/span&gt;&lt;/span&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;抢占模式：在抢占模式下，如果Backup设备的优先级比当前Master设备的优先级高，则主动将自己切换成Master。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;非抢占模式：在非抢占模式下，只要Master设备没有出现故障，Backup设备即使随后被配置了更高的优先级也不会成为Master设备。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;说明：
•保证同一备份组的设备上配置相同的备份组号（&lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt;-router-&lt;span&gt;id）。
•不同备份组之间的虚拟IP地址不能重复，并且必须和接口的IP地址在同一网段。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;组网需求&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如图1所示，HostA通过Switch双归属到SwitchA和SwitchB。为保证用户的各种业务在网络传输中不中断，需在SwitchA和SwitchB上配置VRRP主备备份功能。&lt;/li&gt;
&lt;li&gt;正常情况下，主机以SwitchA为默认网关接入Internet，当SwitchA故障时，SwitchB接替SwitchA作为网关继续进行工作，实现网关的冗余备份。&lt;/li&gt;
&lt;li&gt;SwitchA故障恢复后，其延时20秒通过抢占的方式重新成为Master，承担数据传输。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;配置思路&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1.配置各设备接口IP地址及路由协议，使各设备间网络层连通。&lt;/li&gt;
&lt;li&gt;2.在SwitchA和SwitchB上配置VRRP备份组。其中，SwitchA上配置较高优先级和20秒抢占延时，作为Master设备承担流量转发；SwitchB上配置较低优先级，作为备用交换机，实现网关冗余备份。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;操作步骤&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1.配置设备间的网络互连&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　# 配置设备各接口的IP地址，以&lt;span class=&quot;keyword&quot;&gt;SwitchA为例。&lt;span class=&quot;keyword&quot;&gt;SwitchB和&lt;span class=&quot;keyword&quot;&gt;SwitchC的配置与&lt;span class=&quot;keyword&quot;&gt;SwitchA类似&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，不再赘述。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&amp;lt;HUAWEI&amp;gt; system-view
[HUAWEI] sysname SwitchA
[SwitchA] vlan batch 100 300
[SwitchA] interface gigabitethernet 1/0/1
[SwitchA-GigabitEthernet1/0/1] port link-type hybrid
[SwitchA-GigabitEthernet1/0/1] port hybrid pvid vlan 300
[SwitchA-GigabitEthernet1/0/1] port hybrid untagged vlan 300
[SwitchA-GigabitEthernet1/0/1] quit
[SwitchA] interface gigabitethernet 1/0/2
[SwitchA-GigabitEthernet1/0/2] port link-type hybrid
[SwitchA-GigabitEthernet1/0/2] port hybrid pvid vlan 100
[SwitchA-GigabitEthernet1/0/2] port hybrid untagged vlan 100
[SwitchA-GigabitEthernet1/0/2] quit
[SwitchA] interface vlanif 100
[SwitchA-Vlanif100] ip address 10.1.1.1 24
[SwitchA-Vlanif100] quit
[SwitchA] interface vlanif 300
[SwitchA-Vlanif300] ip address 192.168.1.1 24
[SwitchA-Vlanif300] quit
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　# 配置Switch的二层转发功能。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&amp;lt;HUAWEI&amp;gt; system-view
[HUAWEI] sysname Switch
[Switch] vlan 100
[Switch-vlan100] quit
[Switch] interface gigabitethernet 1/0/1
[Switch-GigabitEthernet1/0/1] port link-type hybrid
[Switch-GigabitEthernet1/0/1] port hybrid pvid vlan 100
[Switch-GigabitEthernet1/0/1] port hybrid untagged vlan 100
[Switch-GigabitEthernet1/0/1] quit
[Switch] interface gigabitethernet 1/0/2
[Switch-GigabitEthernet1/0/2] port link-type hybrid
[Switch-GigabitEthernet1/0/2] port hybrid pvid vlan 100
[Switch-GigabitEthernet1/0/2] port hybrid untagged vlan 100
[Switch-GigabitEthernet1/0/2] quit
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　# 配置&lt;span class=&quot;keyword&quot;&gt;SwitchA、&lt;span class=&quot;keyword&quot;&gt;SwitchB和&lt;span class=&quot;keyword&quot;&gt;SwitchC间采用OSPF协议进行互连。以&lt;span class=&quot;keyword&quot;&gt;SwitchA为例，&lt;span class=&quot;keyword&quot;&gt;SwitchB和&lt;span class=&quot;keyword&quot;&gt;SwitchC的配置与&lt;span class=&quot;keyword&quot;&gt;SwitchA类似，不再赘述。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
[SwitchA] ospf 1
[SwitchA-ospf-1] area 0
[SwitchA-ospf-1-area-0.0.0.0] network 10.1.1.0 0.0.0.255
[SwitchA-ospf-1-area-0.0.0.0] network 192.168.1.0 0.0.0.255
[SwitchA-ospf-1-area-0.0.0.0] quit
[SwitchA-ospf-1] quit
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt; 2.配置VRRP备份组&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　# 在&lt;span class=&quot;keyword&quot;&gt;SwitchA上创建VRRP备份组1，配置&lt;span class=&quot;keyword&quot;&gt;SwitchA在该备份组中的优先级为120，并配置抢占时间为20秒。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
[SwitchA] interface vlanif 100
[SwitchA-Vlanif100] vrrp vrid 1 virtual-ip 10.1.1.111
[SwitchA-Vlanif100] vrrp vrid 1 priority 120                  //设备在VRRP备份组中的优先级缺省为100，修改Master设备的优先级大于Backup设备
[SwitchA-Vlanif100] vrrp vrid 1 preempt-mode timer delay 20   //设备在VRRP备份组中缺省采用立即抢占方式。修改Master设备的延迟抢占时间，以避免在网络环境不稳定时，由于双方频繁抢占而导致流量中断的问题
[SwitchA-Vlanif100] quit
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　# 在&lt;span class=&quot;keyword&quot;&gt;SwitchB上创建VRRP备份组1，其在该备份组中的优先级采用缺省值100（不需要配置）。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
[SwitchB] interface vlanif 100
[SwitchB-Vlanif100] vrrp vrid 1 virtual-ip 10.1.1.111
[SwitchB-Vlanif100] quit
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt; 3.验证配置结果&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　# 完成上述配置以后，在&lt;span class=&quot;keyword&quot;&gt;SwitchA和&lt;span class=&quot;keyword&quot;&gt;SwitchB上分别执行&lt;strong&gt;&lt;span class=&quot;cmdname&quot;&gt;display vrrp&lt;/span&gt;&lt;/strong&gt;命令，可以看到&lt;span class=&quot;keyword&quot;&gt;SwitchA在备份组中的状态为Master，&lt;span class=&quot;keyword&quot;&gt;SwitchB在备份组中的状态为Backup。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
[SwitchA] display vrrp
  Vlanif100 | Virtual Router 1
    State : Master
    Virtual IP : 10.1.1.111
    Master IP : 10.1.1.1
    PriorityRun : 120
    PriorityConfig : 120                                                        
    MasterPriority : 120                                                        
    Preempt : YES   Delay Time : 20 s
    TimerRun : 1 s
    TimerConfig : 1 s
    Auth type : NONE                                                            
    Virtual MAC : 0000-5e00-0101                                                
    Check TTL : YES                                                             
    Config type : normal-vrrp                                                   
    Backup-forward : disabled
    Create time : 2018-07-12 20:15:46
    Last change time : 2018-07-12 20:15:46
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
[SwitchB] display vrrp
  Vlanif100 | Virtual Router 1
    State : Backup
    Virtual IP : 10.1.1.111
    Master IP : 10.1.1.1
    PriorityRun : 100
    PriorityConfig : 100                                                        
    MasterPriority : 120                                                        
    Preempt : YES   Delay Time : 0 s
    TimerRun : 1 s
    TimerConfig : 1 s
    Auth type : NONE                                                            
    Virtual MAC : 0000-5e00-0101                                                
    Check TTL : YES                                                             
    Config type : normal-vrrp                                                   
    Backup-forward : disabled
    Create time : 2018-07-12 20:15:46
    Last change time : 2018-07-12 20:15:46
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　# 在&lt;span class=&quot;keyword&quot;&gt;SwitchA和&lt;span class=&quot;keyword&quot;&gt;SwitchB上执行&lt;strong&gt;&lt;span class=&quot;cmdname&quot;&gt;display ip routing-table&lt;/span&gt;&lt;/strong&gt;命令，&lt;span class=&quot;keyword&quot;&gt;SwitchA上可以看到路由表中有一条目的地址为虚拟IP地址的直连路由，而&lt;span class=&quot;keyword&quot;&gt;SwitchB上该路由为OSPF路由。&lt;span class=&quot;keyword&quot;&gt;SwitchA和&lt;span class=&quot;keyword&quot;&gt;SwitchB上的显示信息如下。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
[SwitchA] display ip routing-table
Route Flags: R - relay, D - download to fib
------------------------------------------------------------------------------  
Routing Tables: Public                                                          
         Destinations : 9       Routes : 10                                    
                                                                                
Destination/Mask    Proto   Pre  Cost      Flags NextHop         Interface      
                                                                                
     10.1.1.0/24    Direct   0     0         D      10.1.1.1        Vlanif100
     10.1.1.1/32    Direct   0     0         D      127.0.0.1       Vlanif100
 10.1.1.111/32    Direct  0     0         D      127.0.0.1      Vlanif100
     127.0.0.0/8    Direct   0    0          D      127.0.0.1       InLoopBack0
    127.0.0.1/32    Direct   0    0          D      127.0.0.1       InLoopBack0
   172.16.1.0/24    OSPF     10   2          D      192.168.1.2     Vlanif300
  192.168.1.0/24    Direct   0    0          D      192.168.1.1     Vlanif300
  192.168.1.1/32    Direct   0    0          D      127.0.0.1       Vlanif300
  192.168.2.0/24    OSPF     10   2          D      10.1.1.2        Vlanif100
                    OSPF     10   2          D      192.168.1.2     Vlanif300
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
[SwitchB] display ip routing-table
Route Flags: R - relay, D - download to fib
------------------------------------------------------------------------------  
Routing Tables: Public                                                          
         Destinations : 9       Routes : 10                                    
                                                                                
Destination/Mask    Proto   Pre  Cost      Flags NextHop         Interface      
                                                                                
     10.1.1.0/24    Direct   0     0         D     10.1.1.2        Vlanif100
     10.1.1.2/32    Direct   0     0         D     127.0.0.1       Vlanif100
 10.1.1.111/32    OSPF    10    2         D     10.1.1.1       Vlanif100
     127.0.0.0/8    Direct   0     0         D     127.0.0.1       InLoopBack0
    127.0.0.1/32    Direct   0     0         D     127.0.0.1       InLoopBack0
   172.16.1.0/24    OSPF     10    2         D     192.168.2.2     Vlanif200
  192.168.1.0/24    OSPF     10    2         D     10.1.1.1        Vlanif100
                    OSPF     10    2         D     192.168.2.2     Vlanif200
  192.168.2.0/24    Direct   0     0         D     192.168.2.1     Vlanif200
  192.168.2.1/32    Direct   0     0         D     127.0.0.1       Vlanif200
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　# 在&lt;span class=&quot;keyword&quot;&gt;SwitchA的接口&lt;span class=&quot;keyword&quot;&gt;GE1/0/2上执行&lt;strong&gt;shutdown&lt;/strong&gt;命令，模拟&lt;span class=&quot;keyword&quot;&gt;SwitchA出现故障。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
[SwitchA] interface gigabitethernet 1/0/2
[SwitchA-GigabitEthernet1/0/2] shutdown
[SwitchA-GigabitEthernet1/0/2] quit
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　# 在&lt;span class=&quot;keyword&quot;&gt;SwitchB上执行&lt;strong&gt;display vrrp&lt;/strong&gt;命令查看VRRP状态信息，可以看到&lt;span class=&quot;keyword&quot;&gt;SwitchB的状态是Master。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
[SwitchB] display vrrp
  Vlanif100 | Virtual Router 1
    State : Master
    Virtual IP : 10.1.1.111
    Master IP : 10.1.1.2
    PriorityRun : 100
    PriorityConfig : 100                                                        
    MasterPriority : 100                                                        
    Preempt : YES   Delay Time : 0 s
    TimerRun : 1 s
    TimerConfig : 1 s
    Auth type : NONE                                                            
    Virtual MAC : 0000-5e00-0101                                                
    Check TTL : YES                                                             
    Config type : normal-vrrp                                                   
    Backup-forward : disabled
    Create time : 2018-07-12 20:15:46
    Last change time : 2018-07-12 20:18:40
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　 # 在&lt;span class=&quot;keyword&quot;&gt;SwitchA的接口&lt;span class=&quot;keyword&quot;&gt;GE1/0/2上执行&lt;strong&gt;undo shutdown&lt;/strong&gt;命令。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
[SwitchA] interface gigabitethernet 1/0/2
[SwitchA-GigabitEthernet1/0/2] undo shutdown
[SwitchA-GigabitEthernet1/0/2] quit
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　# 等待20秒后，在&lt;span class=&quot;keyword&quot;&gt;SwitchA上执行&lt;strong&gt;display vrrp&lt;/strong&gt;命令查看VRRP状态信息，可以看到&lt;span class=&quot;keyword&quot;&gt;SwitchA的状态恢复成Master。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
[SwitchA] display vrrp
  Vlanif100 | Virtual Router 1
    State : Master
    Virtual IP : 10.1.1.111
    Master IP : 10.1.1.1
    PriorityRun : 120
    PriorityConfig : 120                                                        
    MasterPriority : 120                                                        
    Preempt : YES   Delay Time : 20 s
    TimerRun : 1 s
    TimerConfig : 1 s
    Auth type : NONE                                                            
    Virtual MAC : 0000-5e00-0101                                                
    Check TTL : YES                                                             
    Config type : normal-vrrp                                                   
    Backup-forward : disabled
    Create time : 2018-07-12 20:15:46
    Last change time : 2018-07-12 20:20:56
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
</description>
<pubDate>Wed, 18 Nov 2020 23:19:00 +0000</pubDate>
<dc:creator>南空城</dc:creator>
<og:description>组网图形 VRRP主备备份简介 通常，同一网段内的所有主机上都存在一条相同的、以网关为下一跳的缺省路由。主机发往其他网段的报文将通过缺省路由发往网关，再由网关进行转发，从而实现主机与外部网络的通信。当</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhangwencheng/p/14002891.html</dc:identifier>
</item>
<item>
<title>再聊 Blazor，它是否值得你花时间学习 - 精致码农</title>
<link>http://www.cnblogs.com/willick/p/14003239.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/willick/p/14003239.html</guid>
<description>&lt;p&gt;之前写了一篇文章&lt;a href=&quot;https://mp.weixin.qq.com/s/LvWaATYJsJk2TQyZkLa-Sg&quot;&gt;《快速了解 ASP.NET Core Blazor》&lt;/a&gt;，大家关心最多的问题是，我该不该花时间去学习 Blazor。今天聊聊这个话题，并表达一下我个人的看法。&lt;/p&gt;
&lt;p&gt;在此之前，我还是想不厌其烦的介绍一个 Blazor。&lt;/p&gt;
&lt;p&gt;Blazor 是微软 .NET 团队开发的一个新的 UI 框架，目前生态发展的还不错。仅国内就出现了不少成熟的 UI 框架，比如基于 Ant Design 的企业级组件库 ant-design-blazor&lt;sup&gt;[1]&lt;/sup&gt;、基于 ElementUI 的 element-blazor&lt;sup&gt;[2]&lt;/sup&gt; 和基于 Bootstrap 的 BootstrapBlazor&lt;sup&gt;[3]&lt;/sup&gt; 等，这些开源项目的发起人都是国内开发者。另外，你可以在 GitHub 的 awesome-blazor&lt;sup&gt;[4]&lt;/sup&gt; 项目查看更丰富的 Blazor 资源。&lt;/p&gt;
&lt;p&gt;要更好地了解 Blazor，必定要先知道 WebAssembly 是什么。&lt;/p&gt;
&lt;p&gt;WebAssembly 与 .NET 无关，WebAssembly 已经慢慢开始普及被采用。简单来说，WebAssembly 是一种新的、类似汇编的网络语言。它可以在浏览器中运行，并且支持所有现代浏览器。由于经过高度优化，所以运行速度快，接近本地应用。&lt;/p&gt;
&lt;p&gt;重要的是，WebAssembly 不是一种绝大多数开发者都会写的语言，而是用来作为编译目标的。你可以将代码针对特定的处理器或操作系统编译成 WebAssembly，然后让你的程序在浏览器中运行。&lt;/p&gt;
&lt;p&gt;理解了 WebAssembly，我们再来正式介绍一下 Blazor。&lt;/p&gt;
&lt;p&gt;在概念上，Blazor 更像是 Vue 或 React，而不是 ASP.NET Core MVC。&lt;strong&gt;它是一个基于组件的框架，用于构建丰富的交互式 Web 应用程序&lt;/strong&gt;。Blazor 与传统 JavaScript 框架的主要区别在于，Blazor 组件完全用 C# 和 Razor 编写，不需要用到 JavaScript，但可以和 JavaScript 交互。&lt;/p&gt;
&lt;p&gt;Blazor 有两种模式。一种是在服务器端运行再实时渲染到浏览器，叫&lt;strong&gt;服务端模式&lt;/strong&gt;；一种是在客户端使用 WebAssembly 运行，叫 &lt;strong&gt;WebAssembly 模式&lt;/strong&gt;。两种模式都使用了相同的面向组件的架构，但在运行这些组件的方式上却有很大的不同。&lt;/p&gt;
&lt;p&gt;服务端模式，就是渲染代码的工作在服务器上运行，它使用 &lt;strong&gt;SignalR&lt;/strong&gt;（一个用于管理客户端和服务器之间的实时连接的 .NET 库）将事件从浏览器发送到服务器，并将 DOM 的差异部分发送到浏览器进行渲染。即，服务端模式是服务器渲染你的组件并通过 SignalR 管理交互。&lt;/p&gt;
&lt;p&gt;WebAssembly 模式，更容易理解一些。所有的代码，包括框架和你的组件，都在浏览器中运行。你的 C# 代码像其他 .NET 应用程序一样被编译成 DLL，随后 DLL 被发送到浏览器，然后在浏览器中运行你的代码。打开浏览器开发者工具，在第一次加载页面时，你可以看到它会下载一堆的 DLL。&lt;/p&gt;
&lt;p&gt;这两种模式都有各自的优势。服务端模式在浏览器中的工作较少，但由于涉及到网络，用户界面交互会有一些延迟。WebAssembly 模式，运行速度较快，但第一次加载较慢，需要下载 DLL，加起来大约有 2M 的样子。&lt;/p&gt;
&lt;p&gt;这就是 Blazor。现在说说我个人对 Blazor 的看法。&lt;/p&gt;
&lt;p&gt;对于 Blazor，最大的优点是前后端代码的共用以及组件的重用，而且可以不需要 JavaScript，极大简单了开发工作流。&lt;/p&gt;
&lt;p&gt;从我的体验来说，我不太满意 Blazor 的服务端模式，因为大部分交互都要经过网络，这就导致少许延迟，体验不是很好。服务端模式不适合实时性要求较高的应用，比较适合供外网访问的网站，比如公司官网和要求利于 SEO 的网站。&lt;/p&gt;
&lt;p&gt;Blazor 的未来，我看好的是 WebAssembly 模式。性能上，WebAssembly 接近于本地应用。相对本地应用，它的好处是不需要安装，不需要在客户端升级，可以说是结合了本地应用和 Web 网页的优点。而且基于 Blazor 的 WebAssembly 应用可以创建为 PWA(Progressive Web App)，以实现离线支持。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;WebAssembly 是未来的趋势，但要被普遍性采用，还有一段较长的路要走&lt;/strong&gt;。首批会采用 WebAssembly 的应用会是面向企业内部的应用，比如企业的 ERP、CRM 等应用。目前各大主流浏览器都已支持 WebAssembly，这一点也证明各大浏览器厂商推 WebAssembly 技术的决心。&lt;/p&gt;
&lt;p&gt;相较于其它语言平台，基于 .NET 平台的 Blazor 在 WebAssembly 发展方面目前处于绝对的领先，更具有前瞻性。另外，群友分享的最新消息：&lt;strong&gt;微软公布，在 .NET 6 中，Blazor 将增加支持基于 Web 渲染的跨平台桌面应用&lt;/strong&gt;&lt;sup&gt;[5]&lt;/sup&gt;。在我看来，借助 C# 语言和 WebAssembly 性能的优势，未来 Blazor 有望接替 Electron 的位置，成为跨平台桌面应用的新霸主。&lt;/p&gt;
&lt;p&gt;我个人非常看好 Blazor 的未来发展。对于已有 ASP.NET Core 开发经验的人来说，学习 Blazor 并没有多少学习成本。如果你是 .NET 开发者，&lt;strong&gt;在学有余力的情况下，我强烈建议你花点时间学一学 Blazor&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;[1]. &lt;a href=&quot;https://github.com/ant-design-blazor/ant-design-blazor&quot;&gt;https://github.com/ant-design-blazor/ant-design-blazor&lt;/a&gt;&lt;br/&gt;[2]. &lt;a href=&quot;https://github.com/Element-Blazor/Element-Blazor&quot;&gt;https://github.com/Element-Blazor/Element-Blazor&lt;/a&gt;&lt;br/&gt;[3]. &lt;a href=&quot;https://gitee.com/LongbowEnterprise/BootstrapBlazor&quot;&gt;https://gitee.com/LongbowEnterprise/BootstrapBlazor&lt;/a&gt;&lt;br/&gt;[4]. &lt;a href=&quot;https://github.com/AdrienTorris/awesome-blazor&quot;&gt;https://github.com/AdrienTorris/awesome-blazor&lt;/a&gt;&lt;br/&gt;[5]. &lt;a href=&quot;https://github.com/dotnet/aspnetcore/issues/27217&quot;&gt;https://github.com/dotnet/aspnetcore/issues/27217&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 18 Nov 2020 23:12:00 +0000</pubDate>
<dc:creator>精致码农</dc:creator>
<og:description>之前写了一篇文章《快速了解 ASP.NET Core Blazor》，大家关心最多的问题是，我该不该花时间去学习 Blazor。今天聊聊这个话题，并表达一下我个人的看法。 在此之前，我还是想不厌其烦的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/willick/p/14003239.html</dc:identifier>
</item>
<item>
<title>接口自动化测试：apiAutoTest使用re 处理数据依赖 - zy7y</title>
<link>http://www.cnblogs.com/zy7y/p/14003170.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zy7y/p/14003170.html</guid>
<description>&lt;p&gt;目前在工作中写脚本的时候发现了一些之前开源的apiAutoTest的可优化项，后面应该也是会慢慢的继续优化了&lt;/p&gt;

&lt;p&gt;截止到写这篇文章的时间是，2020/11/19 00:53 现在也是把该项优化了，那优化了什么尼？&lt;/p&gt;

&lt;p&gt;我理解的参数依赖/接口依赖就是接口进行关联操作，比如有些查询接口需要登录之后才可以操作，那么我们就需要拿到token之类的东西，这一部分东西是放到header中的，apiAutoTest围绕的只有路径参数依赖，请求数据依赖&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;路径参数依赖&lt;/p&gt;
&lt;p&gt;譬如说现在的restful，一个users接口，路由一般这样的&lt;code&gt;users&lt;/code&gt;他的请求方式是get，这个路由我们把他认为是查所有用户，如果查某一个用户可能是这样的&lt;code&gt;users/:id&lt;/code&gt;也是个get请求，这里这个id想表达的意思是这里有个需要个用户id的参数，比如1-500里面的任意1个，也就是说这个id是可变的，可以从登录接口的返回响应取一个叫userId的值&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;请求参数依赖&lt;/p&gt;
&lt;p&gt;这个应该好理解些，就是说支付接口需要的订单id，是从上一步提交订单接口返回的响应订单id&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于在改动时发现了之前的代码挺绕的，而且都没什么帮助所以就不说了，如果对之前的感兴趣可以看这里：&lt;a href=&quot;https://testerhome.com/topics/25003&quot;&gt;https://testerhome.com/topics/25003&lt;/a&gt; ， 下面上新版用例截图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/11/19/DnO1UJ.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul readability=&quot;12.5&quot;&gt;&lt;li readability=&quot;28&quot;&gt;
&lt;p&gt;关于文件改动，新增了&lt;code&gt;data_process.py&lt;/code&gt;文件里面封装了请求保存实际结果响应，path参数处理，请求数据处理&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;#!/usr/bin/env/python3
# -*- coding:utf-8 -*-
&quot;&quot;&quot;
@project: apiAutoTest
@author: zy7y
@file: data_process.py
@ide: PyCharm
@time: 2020/11/18
&quot;&quot;&quot;
import json
import re
from tools import *


class DataProcess:
    response_dict = {}
    header = {}
    null_header = {}

    @classmethod
    def save_response(cls, key: str, value: object) -&amp;gt; None:
        &quot;&quot;&quot;
        保存实际响应
        :param key: 保存字典中的key，一般使用用例编号
        :param value: 保存字典中的value，使用json响应
        &quot;&quot;&quot;
        cls.response_dict[key] = value
        logger.info(f'添加key: {key}, 对应value: {value}')

    @classmethod
    def handle_path(cls, path_str: str = '') -&amp;gt; str:
        &quot;&quot;&quot;路径参数处理
        :param path_str: 带提取表达式的字符串 /&amp;amp;$.case_005.data.id&amp;amp;/state/&amp;amp;$.case_005.data.create_time&amp;amp;
        上述内容表示，从响应字典中提取到case_005字典里data字典里id的值，假设是500，后面&amp;amp;$.case_005.data.create_time&amp;amp; 类似，最终提取结果
        return  /511/state/1605711095
        &quot;&quot;&quot;
        # /&amp;amp;$.case.data.id&amp;amp;/state/&amp;amp;$.case_005.data.create_time&amp;amp;

        for i in re.findall('&amp;amp;(.*?)&amp;amp;', path_str):
            path_str = path_str.replace(f'&amp;amp;{i}&amp;amp;', str(extractor(cls.response_dict, i)))
        logger.info(f'提取出的路径地址: {path_str}')
        return path_str

    @classmethod
    def handle_header(cls, is_token: str, response: dict, reg) -&amp;gt; dict:
        &quot;&quot;&quot;处理header&quot;&quot;&quot;
        if is_token == '写':
            cls.header['Authorization'] = extractor(response, reg)
            return cls.header
        elif is_token == '':
            return cls.null_header
        else:
            return cls.header

    @classmethod
    def handle_data(cls, variable: str) -&amp;gt; dict:
        &quot;&quot;&quot;请求数据处理
        :param variable: 请求数据，传入的是可转换字典/json的字符串,其中可以包含变量表达式
        return 处理之后的json/dict类型的字典数据
        &quot;&quot;&quot;
        if variable == '':
            return
        for i in re.findall('&amp;amp;(.*?)&amp;amp;', variable):
            variable = variable.replace(f'&amp;amp;{i}&amp;amp;', str(extractor(cls.response_dict, i)))
        if 'null' in variable:
            variable = variable.replace('null', 'None')
        if 'true' in variable:
            variable = variable.replace('true', 'True')
        if 'false' in variable:
            variable = variable.replace('false', 'False')
        logger.info(f'最终的请求数据如下: {variable}')
        return eval(variable)

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;相比之前这种写法应该更加清晰，然后之前的请求数据是采用字典合并的方式，在请求数据多层结构的时候会出现bug，现在改成了文本替换之后转json/dict的方法&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;举个例子&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设现在有个实际响应结果字典如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;{&quot;case_002&quot;: {
        &quot;data&quot;: {
            &quot;id&quot;: 500,
            &quot;username&quot;: &quot;admin&quot;,
            &quot;mobile&quot;: &quot;12345678&quot;,
        }},
  &quot;case_005&quot;: {
        &quot;data&quot;: {
            &quot;id&quot;: 511,
            &quot;create_time&quot;: 1605711095
        },
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;8&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;excel中接口路径内容：&lt;code&gt;users/&amp;amp;$.case_005.data.id&amp;amp;/state/&amp;amp;$.case_005.data.careate_time&amp;amp;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;代码内部解析后如下:&lt;code&gt;users/511/state/1605711095&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;amp;$.case_005.data.id&amp;amp;&lt;/code&gt; 代表从响应字典中提取case_005字典中data字典中的id的值，提取出来的结果是511&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;12&quot;&gt;
&lt;p&gt;excel中请求参数内容如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;{
 &quot;pagenum&quot;: 1, 
 &quot;pagesize&quot;: &quot;12&quot;,
 &quot;data&quot;: &amp;amp;$.case_005.data&amp;amp;, 
 &quot;userId&quot;: &amp;amp;$.case_002.data.id&amp;amp;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码内部解析后如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;{
 &quot;pagenum&quot;: 1, 
 &quot;pagesize&quot;: &quot;12&quot;,
 &quot;meta&quot;: {
            &quot;id&quot;: 511,
            &quot;create_time&quot;: 1605711095
        }, 
 &quot;userId&quot;: 500
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;其实不难看出其中规则&lt;code&gt;&amp;amp;jsonpath提取语法&amp;amp;&lt;/code&gt;，如果你需要的内容是字符串类型，只需要这样&lt;code&gt;&quot;&amp;amp;jsonpath提取语法&amp;amp;&quot;&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;github: &lt;a href=&quot;https://github.com/zy7y/apiAutoTest.git&quot;&gt;https://github.com/zy7y/apiAutoTest.git&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;gitee: &lt;a href=&quot;https://gitee.com/zy7y/apiAutoTest.git&quot;&gt;https://gitee.com/zy7y/apiAutoTest.git&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;谢谢各位的点评，在实际工作写到之后发现之前的写法的确不如意，希望多写，然后进步~晚安&lt;/p&gt;
</description>
<pubDate>Wed, 18 Nov 2020 17:35:00 +0000</pubDate>
<dc:creator>zy7y</dc:creator>
<og:description>废话 目前在工作中写脚本的时候发现了一些之前开源的apiAutoTest的可优化项，后面应该也是会慢慢的继续优化了 2020/11/19 截止到写这篇文章的时间是，2020/11/19 00:53 现</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zy7y/p/14003170.html</dc:identifier>
</item>
<item>
<title>EFCore 5 中的 DbContextFactory - WeihanLi</title>
<link>http://www.cnblogs.com/weihanli/p/13997751.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/weihanli/p/13997751.html</guid>
<description>&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;/h2&gt;
&lt;p&gt;使用过 EF Core 大多都会遇到这样一个场景，希望能够并行查询，但是如果使用同一个 DbContext 实例进行并行操作的时候就会遇到一个 &lt;code&gt;InvalidOperationException&lt;/code&gt; 的异常，在 EF Core 2.x/3.x 版本中， EF Core DbContext 的生命周期默认是 &lt;code&gt;Scoped&lt;/code&gt;，如果要并行查询，需要创建多个 Scope，在子 Scope 中创建 DbContext 来进行操作，EF Core 5 中的 &lt;code&gt;DbContextFactory&lt;/code&gt; 可以用来简化这样的操作，且看下文示例&lt;/p&gt;
&lt;h2 id=&quot;dbcontextfactory&quot;&gt;DbContextFactory&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;DbContextFactory&lt;/code&gt; 就如同它的名字一样，就是一个 &lt;code&gt;DbContext&lt;/code&gt; 的工厂，就是用来创建 &lt;code&gt;DbContext&lt;/code&gt; 的&lt;/p&gt;
&lt;p&gt;&lt;code&gt;IDbContextFactory&lt;/code&gt; 接口定义如下，Github 源码 &lt;a href=&quot;https://github.com/dotnet/efcore/blob/v5.0.0/src/EFCore/IDbContextFactory.cs&quot;&gt;https://github.com/dotnet/efcore/blob/v5.0.0/src/EFCore/IDbContextFactory.cs&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public interface IDbContextFactory&amp;lt;out TContext&amp;gt; where TContext : DbContext
{
    /// &amp;lt;summary&amp;gt;
    ///     &amp;lt;para&amp;gt;
    ///         Creates a new &amp;lt;see cref=&quot;DbContext&quot; /&amp;gt; instance.
    ///     &amp;lt;/para&amp;gt;
    ///     &amp;lt;para&amp;gt;
    ///         The caller is responsible for disposing the context; it will not be disposed by the dependency injection container.
    ///     &amp;lt;/para&amp;gt;
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;returns&amp;gt; A new context instance. &amp;lt;/returns&amp;gt;
    TContext CreateDbContext();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要注意的是，如果使用 &lt;code&gt;DbContextFactory&lt;/code&gt; 来创建 &lt;code&gt;DbContext&lt;/code&gt;，需要自己来释放 &lt;code&gt;DbContext&lt;/code&gt;，需要自己使用 &lt;code&gt;using&lt;/code&gt; 或者 &lt;code&gt;Dispose&lt;/code&gt; 来释放资源&lt;/p&gt;
&lt;p&gt;另外 &lt;code&gt;DbContextFactory&lt;/code&gt; 生命周期不同于 &lt;code&gt;DbContext&lt;/code&gt;，默认的生命周期的 &lt;code&gt;Singleton&lt;/code&gt;，也正是因为这样使得我们可以简化并行查询的代码，可以参考&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/dotnet/efcore/blob/v5.0.0/src/EFCore/Extensions/EntityFrameworkServiceCollectionExtensions.cs#L607&quot;&gt;https://github.com/dotnet/efcore/blob/v5.0.0/src/EFCore/Extensions/EntityFrameworkServiceCollectionExtensions.cs#L607&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;sample&quot;&gt;Sample&lt;/h2&gt;
&lt;p&gt;来看一个实际的示例，这是一个并行操作插入100条记录的简单示例，看一下如何使用 &lt;code&gt;DbContextFactory&lt;/code&gt; 进行并行操作&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;var services = new ServiceCollection();
services.AddDbContextFactory&amp;lt;TestDbContext&amp;gt;(options =&amp;gt;
{
    options.UseInMemoryDatabase(&quot;Tests&quot;)
        ;
});
using var provider = services.BuildServiceProvider();
var contextFactory = provider.GetRequiredService&amp;lt;IDbContextFactory&amp;lt;TestDbContext&amp;gt;&amp;gt;();

Enumerable.Range(1, 100)
    .Select(async i =&amp;gt;
    {
        using (var dbContext = contextFactory.CreateDbContext())
        {
            dbContext.Posts.Add(new Post() { Id = i + 101, Author = $&quot;author_{i}&quot;, Title = $&quot;title_{i}&quot; });
            return await dbContext.SaveChangesAsync();
        }
    })
    .WhenAll()
    .Wait();

using var context = contextFactory.CreateDbContext();
Console.WriteLine(context.Posts.Count());
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;实现源码&quot;&gt;实现源码&lt;/h2&gt;
&lt;p&gt;EF Core 的 &lt;code&gt;DbContextFactory&lt;/code&gt; 的实现不算复杂，一起来看一下，首先看一下 &lt;code&gt;DbContextFactory&lt;/code&gt; 的实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public class DbContextFactory&amp;lt;TContext&amp;gt; : IDbContextFactory&amp;lt;TContext&amp;gt; where TContext : DbContext
{
    private readonly IServiceProvider _serviceProvider;
    private readonly DbContextOptions&amp;lt;TContext&amp;gt; _options;
    private readonly Func&amp;lt;IServiceProvider, DbContextOptions&amp;lt;TContext&amp;gt;, TContext&amp;gt; _factory;

    public DbContextFactory(
        [NotNull] IServiceProvider serviceProvider,
        [NotNull] DbContextOptions&amp;lt;TContext&amp;gt; options,
        [NotNull] IDbContextFactorySource&amp;lt;TContext&amp;gt; factorySource)
    {
        Check.NotNull(serviceProvider, nameof(serviceProvider));
        Check.NotNull(options, nameof(options));
        Check.NotNull(factorySource, nameof(factorySource));

        _serviceProvider = serviceProvider;
        _options = options;
        _factory = factorySource.Factory;
    }

    public virtual TContext CreateDbContext()
        =&amp;gt; _factory(_serviceProvider, _options);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到 &lt;code&gt;DbContextFactory&lt;/code&gt; 的实现里用到了一个 &lt;code&gt;IDbContextFactorySource&lt;/code&gt;，再来看一下 &lt;code&gt;DbContextFactorySource&lt;/code&gt; 的实现，实现如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public class DbContextFactorySource&amp;lt;TContext&amp;gt; : IDbContextFactorySource&amp;lt;TContext&amp;gt; where TContext : DbContext
{
    public DbContextFactorySource()
        =&amp;gt; Factory = CreateActivator();

    public virtual Func&amp;lt;IServiceProvider, DbContextOptions&amp;lt;TContext&amp;gt;, TContext&amp;gt; Factory { get; }

    private static Func&amp;lt;IServiceProvider, DbContextOptions&amp;lt;TContext&amp;gt;, TContext&amp;gt; CreateActivator()
    {
        var constructors
            = typeof(TContext).GetTypeInfo().DeclaredConstructors
            .Where(c =&amp;gt; !c.IsStatic &amp;amp;&amp;amp; c.IsPublic)
            .ToArray();

        if (constructors.Length == 1)
        {
            var parameters = constructors[0].GetParameters();

            if (parameters.Length == 1)
            {
                var isGeneric = parameters[0].ParameterType == typeof(DbContextOptions&amp;lt;TContext&amp;gt;);
                if (isGeneric
                    || parameters[0].ParameterType == typeof(DbContextOptions))
                {
                    var optionsParam = Expression.Parameter(typeof(DbContextOptions&amp;lt;TContext&amp;gt;), &quot;options&quot;);
                    var providerParam = Expression.Parameter(typeof(IServiceProvider), &quot;provider&quot;);

                    return Expression.Lambda&amp;lt;Func&amp;lt;IServiceProvider, DbContextOptions&amp;lt;TContext&amp;gt;, TContext&amp;gt;&amp;gt;(
                        Expression.New(
                            constructors[0],
                            isGeneric
                            ? optionsParam
                            : (Expression)Expression.Convert(optionsParam, typeof(DbContextOptions))),
                        providerParam, optionsParam)
                        .Compile();
                }
            }
        }

        var factory = ActivatorUtilities.CreateFactory(typeof(TContext), new Type[0]);

        return (p, _) =&amp;gt; (TContext)factory(p, null);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面的源码中可以看得出来， &lt;code&gt;DbContextFactory&lt;/code&gt; 把工厂拆成了两部分，&lt;code&gt;DbContextFactorySource&lt;/code&gt; 提供一个工厂方法，提供一个委托来创建 &lt;code&gt;DbContext&lt;/code&gt;，而 &lt;code&gt;DbContextFactory&lt;/code&gt; 则利用 &lt;code&gt;DbContextFactorySource&lt;/code&gt; 提供的工厂方法来创建 &lt;code&gt;DbContext&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&quot;more&quot;&gt;More&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;DbContextFactory&lt;/code&gt; 可以使得在并行操作得时候会更加方便一些，但是注意要自己控制好 &lt;code&gt;DbContext&lt;/code&gt; 生命周期，防止内存泄漏。&lt;/p&gt;
&lt;p&gt;对于 EF Core &lt;code&gt;DbContextFactory&lt;/code&gt; 的实现，不得不说这样的实现灵活性更强一些，但是又感觉有一些多余，想要扩展 &lt;code&gt;DbContextFactory&lt;/code&gt; 的实现，直接重写一个 &lt;code&gt;DbContextFactory&lt;/code&gt; 的实现服务注册的时候注入就可以了，你觉得呢~~&lt;/p&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
</description>
<pubDate>Wed, 18 Nov 2020 16:40:00 +0000</pubDate>
<dc:creator>WeihanLi</dc:creator>
<og:description>EF Core 5 中的 DbContextFactory</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/weihanli/p/13997751.html</dc:identifier>
</item>
<item>
<title>痞子衡嵌入式：工作多年的工程师且看这四条进阶之路 - 痞子衡</title>
<link>http://www.cnblogs.com/henjay724/p/14003001.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/henjay724/p/14003001.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/cnblogs/pzh-story-3_dongfangzhimen.PNG&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;-- 题图：苏州东方之门夜景&lt;/p&gt;
&lt;p&gt;大家好，我是痞子衡，是正经搞技术的痞子。今天痞子衡不讲技术，跟大家随便唠唠嗑。&lt;/p&gt;
&lt;p&gt;工作五年以上的工程师，免不了会思考自己的职业发展之路，关于职业发展，估计大部分人都是比较随性的，今天痞子衡就跟大家一起认真探讨下职业发展。&lt;/p&gt;
&lt;p&gt;痞子衡最近认识了一个新朋友，笔名叫袁吴范（公众号pointers），2013年双非本科毕业，工作七年便升职做了知名大厂海康威视的技术总监，他在公众号里分享了多篇个人成长感悟，痞子衡都认真拜读了，也因此对于职业发展有了更多思考。&lt;/p&gt;
&lt;p&gt;工程师（程序员）这行都说是青春饭，到了35岁便会有强烈的职业危机，究其原因，无非是咱们这IT行技术更迭较快，且属于高强度脑力劳动，每年市场上都会有大量应届毕业生涌入（电子、计算机等专业常年霸占热门专业），年轻人学习能力更强、更能接受新知识，相对来说使得工作多年但成绩并不突出的工程师不太受市场待见。&lt;/p&gt;
&lt;p&gt;那么作为一名工作多年的&quot;老&quot;工程师该如何突破重围呢？痞子衡觉得有如下四条出路：&lt;/p&gt;
&lt;h4 id=&quot;一、资深工程师架构师&quot;&gt;一、资深工程师(架构师)&lt;/h4&gt;
&lt;p&gt;成为资深工程师是大部分人的最终出路，这条路不用刻意规划，随性发展也能到达，但要注意这里的&quot;资深&quot;并非单纯地指工作年限，毕竟单论年限，谁都能成为资深工程师。&lt;/p&gt;
&lt;p&gt;痞子衡想表达的&quot;资深&quot;是区别于年轻人的那种深厚的工作经验，作为资深工程师你不仅要做到驾驭工作游刃有余，还能对行业技术发展有深刻思考和自己的独到见解，技术水平专而精，在小组里能扛重担，能打硬仗，成为技术经理手里的一张王牌。&lt;/p&gt;
&lt;p&gt;任何一个资深工程师都必须要有一颗架构师的心，接到任何任务都需要从系统架构角度去思考解决方案，不能仅抱有完成任务能工作就行的想法，需要不断去打磨和优化解决方案，直至高效完美。&lt;/p&gt;
&lt;p&gt;如何成为资深工程师(架构师)？这条路没有统一答案，不过肯定是需要不断积累以及深度思考，平时不拘泥于自己手头工作，多看架构类书籍，多阅读优秀开源项目源码，拓展知识边界，勤于整理总结。&lt;/p&gt;
&lt;h4 id=&quot;二、技术经理总监&quot;&gt;二、技术经理(总监)&lt;/h4&gt;
&lt;p&gt;成为技术经理是大部分人最期望的出路，在中国官本位思想影响下，作为一名管人的经理（领导/老板），显然是世俗意义上成功的象征，经理这个职位考验的是人的综合能力。&lt;/p&gt;
&lt;p&gt;技术经理是小组的负责人，需要对整个小组所有成员负责，指导和引领小组工作方向。经理不一定是技术最厉害的那个人，但一定是综合素质最高的那个人。当上技术经理往往需要跳出具体技术工作本身，要从小组整体发展角度考虑问题，协调组内人力资源，把控组内成员人心，跟踪组内工作进度，对上层负责，对结果负责。&lt;/p&gt;
&lt;p&gt;技术经理需要培养的是老板思维，要完全摒弃打工者思维，需要站在公司利益角度考虑问题，这种思维角色转变并不容易，并且很多时候需要处理好员工利益与公司利益之间的矛盾统一关系。&lt;/p&gt;
&lt;p&gt;如何成为技术经理？这条路没有明确答案，总之肯定需要得到大老板赏识，组内成员的拥护，与人打交道其实是最难的，大部分人的智商差异并不大，这时候情商远比智商更重要，想当经理需要刻意地训练情商。&lt;/p&gt;
&lt;h4 id=&quot;三、项目管理者&quot;&gt;三、项目管理者&lt;/h4&gt;
&lt;p&gt;成为项目管理是相当一部分人的转型之路，虽然不是管理人事的经理，但也是一个项目的负责人，有调动协调项目资源的能力，项目经理职位考验得就是项目管理能力，这个能力是可以通过专业培训获得的。&lt;/p&gt;
&lt;p&gt;在一个公司正常运营过程中，项目管理是必不可缺的，中长期任务其实都是以一个个项目的形式存在的，每个项目都必须安排专人定期跟踪推进，确保项目按计划有序执行直至成功，这个人就是项目经理。&lt;/p&gt;
&lt;p&gt;从参与人员的规模上来看，项目经理管理的人远比技术经理要多，但这些受管理人没有黏性，并不一定对项目管理者唯命是从。一个项目可能由很多不同功能的小组人员参加，他们各司其职，也只对自己小组的任务负责，他们不需要全局观，当项目推进过程中产生冲突，需要损害某些小组利益（比如额外加班、比如沟通失误），这时候项目管理者必须负责协调，解决好矛盾。&lt;/p&gt;
&lt;p&gt;如何成为项目管理者？这条路的答案还算清晰，接受专业的项目管理培训，拓展公司内的人际圈（最好能成为交际花），培养高效沟通、流畅表达的能力，另外最好英文口语要流利（适用外企）。&lt;/p&gt;
&lt;h4 id=&quot;四、市场运营销售&quot;&gt;四、市场运营(销售)&lt;/h4&gt;
&lt;p&gt;成为市场运营是较少部分有商业嗅觉的人的转型之路，从做技术到做市场，这是完全不同的两类工作，前者只需要关注技术本身，后者更需要考虑技术/时间投入的收益比。&lt;/p&gt;
&lt;p&gt;做市场运营或者技术销售，也需要有扎实的技术背景，毕竟咱们这个行业对接的是高科技公司专业研发人员，能够说服这些人选择某款产品，一定是需要详尽地介绍这款产品特点/技术参数，参与客户公司的方案评估，对于关键指标和重大技术攻关点，能够给出建设性意见。&lt;/p&gt;
&lt;p&gt;做市场运营更像是对多年技术工作的一种整理性汇报，这个职位其实更适合内部资深技术人员转岗，虽然也有应届生直接做市场运营，但拿下重大客户往往要靠技术出身的资深市场运营。&lt;/p&gt;
&lt;p&gt;如何成为市场运营？这需要在日常技术工作之外，培养接触和服务客户的意识，多和外面同行业上下游交流，多关注竞争对手动向，总之要对市场动态敏锐。&lt;/p&gt;
&lt;p&gt;以上就是痞子衡关于工程师进阶之路方面的一些个人想法，不保证绝对正确，仅供参考。好了，今天的闲聊就到这里，咱们下回再见。&lt;/p&gt;
</description>
<pubDate>Wed, 18 Nov 2020 15:49:00 +0000</pubDate>
<dc:creator>痞子衡</dc:creator>
<og:description>-- 题图：苏州东方之门夜景 大家好，我是痞子衡，是正经搞技术的痞子。今天痞子衡不讲技术，跟大家随便唠唠嗑。 工作五年以上的工程师，免不了会思考自己的职业发展之路，关于职业发展，估计大部分人都是比较随</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/henjay724/p/14003001.html</dc:identifier>
</item>
<item>
<title>AQS详解,并发编程的半壁江山 - 彼岸舞</title>
<link>http://www.cnblogs.com/flower-dance/p/13929599.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flower-dance/p/13929599.html</guid>
<description>&lt;p&gt;千呼万唤始出来,终于写到AQS这个一章了,其实为了写这一章,前面也是做了很多的铺垫,比如之前的&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;entrylistItemTitle&quot; href=&quot;https://www.cnblogs.com/flower-dance/p/13673858.html&quot;&gt;深度理解volatile关键字&lt;/a&gt; &lt;a class=&quot;entrylistItemTitle&quot; href=&quot;https://www.cnblogs.com/flower-dance/p/13678742.html&quot;&gt;线程之间的协作(等待通知模式)&lt;/a&gt; &lt;a class=&quot;entrylistItemTitle&quot; href=&quot;https://www.cnblogs.com/flower-dance/p/13714006.html&quot;&gt;JUC 常用4大并发工具类&lt;/a&gt; &lt;a class=&quot;entrylistItemTitle&quot; href=&quot;https://www.cnblogs.com/flower-dance/p/13767956.html&quot;&gt;CAS 原子操作&lt;/a&gt; &lt;a class=&quot;entrylistItemTitle&quot; href=&quot;https://www.cnblogs.com/flower-dance/p/13917164.html&quot;&gt;显示锁&lt;/a&gt; &lt;a class=&quot;entrylistItemTitle&quot; href=&quot;https://www.cnblogs.com/flower-dance/p/13929100.html&quot;&gt;了解LockSupport工具类&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这些文章其实都是为了让大家理解AQS而写的铺垫,就像吃东西需要一口一口的吃一样&lt;/p&gt;
&lt;h2&gt;AQS概述及其实现类:&lt;/h2&gt;
&lt;p&gt;　　AQS,是AbstractQuenedSynchronizer的缩写,中文名称为抽象的队列式同步器,是java并发编程这一块的半壁江山,这个类存在于在java.util.concurrent.locks包,AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它,比如之前写的显示锁ReentrantLock,,读写锁ReentrantReadWriteLock,JUC的四大并发工具类中的Semaphore,CountDownLatch,线程池暂时还没写之后再写&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1979837/202011/1979837-20201104225738113-663936690.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 在JDK1.7之前,FutureTask,应该也是继承了AQS来实现的,但是1.8之后就改变了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1979837/202011/1979837-20201104230414488-622436392.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 但是实现思想应该没有太大改变,,所以说AQS是并发编程的半壁江山&lt;/p&gt;

&lt;h2&gt;核心思想:&lt;/h2&gt;
&lt;p&gt;　　如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态，如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。&lt;/p&gt;
&lt;p&gt;CLH（Craig，Landin，and Hagersten）队列是一个虚拟的双向队列，虚拟的双向队列即不存在队列实例，仅存在节点之间的关联关系。&lt;br/&gt;AQS是将每一条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node），来实现锁的分配。&lt;/p&gt;
&lt;p&gt;其实在我理解来说,AQS就是基于CLH队列，用volatile修饰共享变量state,来保证变量的可见性，线程通过CAS去改变状态符,保证状态的原子性，成功则获取锁成功，失败则进入等待队列，等待被唤醒。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：AQS是自旋锁：在等待唤醒的时候，经常会使用自旋（while(!cas())）的方式，不停地尝试获取锁，直到被其他线程获取成功&lt;/p&gt;

&lt;h2&gt;框架:&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1979837/202011/1979837-20201104232043013-462627355.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt;通过这个图得知，AQS维护了一个volatile int state和一个FIFO线程等待队列，多线程争用资源被阻塞的时候就会进入这个队列。state就是共享资源，其访问方式有如下三种：&lt;br/&gt;getState();setState();compareAndSetState();&lt;/p&gt;
&lt;p&gt;AQS 定义了两种资源共享方式：&lt;br/&gt;1.Exclusive：独占，只有一个线程能执行，如ReentrantLock&lt;br/&gt;2.Share：共享，多个线程可以同时执行，如Semaphore、CountDownLatch、ReadWriteLock，CyclicBarrier&lt;/p&gt;
&lt;p&gt;不同的自定义的同步器争用共享资源的方式也不同。&lt;/p&gt;
&lt;h2&gt;AQS底层使用了模板方法模式&lt;/h2&gt;
&lt;p&gt;同步器的设计是基于模板方法模式的,如果不了解的可以去看看模板方法设计模式,之前在写设计模式的六大设计原则的时候也说了,看看设计模式有助于理解源码,如果需要自定义同步器一般的方式是这样：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;使用者继承AbstractQueuedSynchronizer并重写指定的方法。&lt;/li&gt;
&lt;li&gt;将AQS组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法,就类似于我定义了一个骨架,你填充东西一样&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;自定义同步器在实现的时候只需要实现共享资源state的获取和释放方式即可，至于具体线程等待队列的维护，AQS已经在顶层实现好了。自定义同步器实现的时候主要实现下面几种方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。&lt;/li&gt;
&lt;li&gt;tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。&lt;/li&gt;
&lt;li&gt;tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。&lt;/li&gt;
&lt;li&gt;tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。&lt;/li&gt;
&lt;li&gt;tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。&lt;/p&gt;
&lt;p&gt;　　再以CountDownLatch以例，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS减1。等到所有子线程都执行完后(即state=0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作。&lt;/p&gt;
&lt;p&gt;　　一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。&lt;/p&gt;
&lt;p&gt;　　在acquire() acquireShared()两种方式下，线程在等待队列中都是忽略中断的，acquireInterruptibly()/acquireSharedInterruptibly()是支持响应中断的。&lt;/p&gt;
&lt;h2&gt;继承AQS,手写独占式可重入锁:&lt;/h2&gt;
&lt;p&gt;　　说了那么多,但是说一千道一万不如自己手写试试,接下来看代码&lt;/p&gt;
&lt;p&gt;锁&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; org.dance.day4.aqs;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.TimeUnit;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.locks.AbstractQueuedSynchronizer;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.locks.Condition;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.locks.Lock;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 采用主类实现Lock接口,内部类继承AQS,封装细节
 * 自定义锁
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; ZYGisComputer
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CustomerLock &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Lock {

    &lt;/span&gt;&lt;span&gt;private final&lt;/span&gt; Sync sync = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Sync();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 采用内部类来继承AQS,封装细节
     *  实现独占锁,通过控制state状态开表示锁的状态
     *      state:1 代表锁已被占用
     *      state:0 代表锁可以被占用
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Sync &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; AbstractQueuedSynchronizer{
        @Override
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; tryAcquire(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; arg) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(compareAndSetState(0,1&lt;span&gt;)){
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前线程获取到锁&lt;/span&gt;
&lt;span&gt;                setExclusiveOwnerThread(Thread.currentThread());
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }
        }

        @Override
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; tryRelease(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; arg) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果状态为没人占用,还去释放,就报错&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;(getState()==0&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UnsupportedOperationException();
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 把锁的占用者制空&lt;/span&gt;
            setExclusiveOwnerThread(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
            setState(&lt;/span&gt;0&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 判断线程是否占用资源
         * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
         &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        @Override
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isHeldExclusively() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; getState()==1&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 获取Condition接口
         * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
         &lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Condition getCondition(){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConditionObject();
        }
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; lock() {
        sync.acquire(&lt;/span&gt;1&lt;span&gt;);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; lockInterruptibly() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
        sync.acquireInterruptibly(&lt;/span&gt;1&lt;span&gt;);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; tryLock() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; sync.tryAcquire(1&lt;span&gt;);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; tryLock(&lt;span&gt;long&lt;/span&gt; time, TimeUnit unit) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; sync.tryAcquireNanos(1&lt;span&gt;,unit.toNanos(time));
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; unlock() {
        sync.release(&lt;/span&gt;1&lt;span&gt;);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Condition newCondition() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; sync.getCondition();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;工具类:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; org.dance.tools;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.TimeUnit;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 类说明：线程休眠辅助工具类
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SleepTools {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 按秒休眠
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; seconds 秒数
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; second(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; seconds) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            TimeUnit.SECONDS.sleep(seconds);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 按毫秒数休眠
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; seconds 毫秒数
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ms(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; seconds) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            TimeUnit.MILLISECONDS.sleep(seconds);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试类:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; org.dance.day4.aqs;


&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.dance.tools.SleepTools;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.locks.Lock;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.locks.ReentrantLock;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 *类说明：测试手写锁
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestMyLock {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        TestMyLock testMyLock &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TestMyLock();
        testMyLock.test();
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 先使用ReentrantLock 然后替换为我们自己的Lock&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; Lock lock = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReentrantLock();

        &lt;/span&gt;&lt;span&gt;class&lt;/span&gt; Worker &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
                    lock.lock();
                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                        SleepTools.second(&lt;/span&gt;1&lt;span&gt;);
                        System.out.println(Thread.currentThread().getName());
                        SleepTools.second(&lt;/span&gt;1&lt;span&gt;);
                    } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                        lock.unlock();
                    }
                    SleepTools.second(&lt;/span&gt;2&lt;span&gt;);
                }
            }
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 启动10个子线程&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 10; i++&lt;span&gt;) {
            Worker w &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Worker();
            w.setDaemon(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
            w.start();
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 主线程每隔1秒换行&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 10; i++&lt;span&gt;) {
            SleepTools.second(&lt;/span&gt;1&lt;span&gt;);
            System.out.println();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行结果:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Thread-0&lt;span&gt;



Thread&lt;/span&gt;-1&lt;span&gt;

Thread&lt;/span&gt;-2&lt;span&gt;



Thread&lt;/span&gt;-3&lt;span&gt;

Thread&lt;/span&gt;-4
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过结果可以看出来每次都是只有一个线程在执行的,线程的锁获取没有问题,接下来换我们自己的锁&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;final&lt;/span&gt; Lock lock = &lt;span&gt;new&lt;/span&gt; CustomerLock();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再次执行测试&lt;/p&gt;
&lt;p&gt;执行结果:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Thread-0&lt;span&gt;


Thread&lt;/span&gt;-1&lt;span&gt;


Thread&lt;/span&gt;-2&lt;span&gt;


Thread&lt;/span&gt;-3&lt;span&gt;


Thread&lt;/span&gt;-4
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由此可见,这个手写的锁,和ReentrantLock是一样的效果,是不是感觉也挺简单的,也没有多少行代码&lt;/p&gt;
&lt;p&gt;那么独占锁,被一个线程占用着,其他线程去了哪里?不要走开接下来进入AQS的源码看看&lt;/p&gt;

&lt;h2&gt;理论:&lt;/h2&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1979837/202011/1979837-20201118211049118-1947719189.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 在AQS中的数据结构是采用同步器+一个双向循环链表的数据结构,来存储等待的节点的,因为双向链表是没有头的,但是为了保证唤醒的操作,同步器中的head标志了链表中的一个节点为头节点,也就是将要唤醒的,也标识了一个尾节点&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1979837/202011/1979837-20201118211554179-1823175520.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;h2&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1979837/202011/1979837-20201118212202060-63052022.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/h2&gt;
&lt;h2&gt;结点状态waitStatus,需要保证可见性,用volatile修饰&lt;/h2&gt;
&lt;p&gt;      这里我们说下Node。Node结点是对每一个等待获取资源的线程的封装，其包含了需要同步的线程本身及其等待状态，如是否被阻塞、是否等待唤醒、是否已经被取消等。变量waitStatus则表示当前Node结点的等待状态，共有5种取值CANCELLED、SIGNAL、CONDITION、PROPAGATE、0。&lt;/p&gt;
&lt;ul readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;CANCELLED&lt;/strong&gt;(1)：表示当前结点已取消调度。当timeout或被中断（响应中断的情况下），会触发变更为此状态，进入该状态后的结点将不会再变化。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;SIGNAL&lt;/strong&gt;(-1)：表示后继结点在等待当前结点唤醒。后继结点入队时，会将前继结点的状态更新为SIGNAL。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;CONDITION&lt;/strong&gt;(-2)：表示结点等待在Condition上，当其他线程调用了Condition的signal()方法后，CONDITION状态的结点将&lt;strong&gt;从等待队列转移到同步队列中&lt;/strong&gt;，等待获取同步锁。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;PROPAGATE&lt;/strong&gt;(-3)：共享模式下，前继结点不仅会唤醒其后继结点，同时也可能会唤醒后继的后继结点。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;0&lt;/strong&gt;：新结点入队时的默认状态。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;注意，&lt;strong&gt;负值表示结点处于有效等待状态，而正值表示结点已被取消。所以源码中很多地方用&amp;gt;0、&amp;lt;0来判断结点的状态是否正常&lt;/strong&gt;。&lt;/p&gt;
&lt;h2&gt;同步队列中节点的增加和移除&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1979837/202011/1979837-20201118213132230-502494217.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 通过图可以看出来,在增加 尾节点的时候需要通过CAS设置,因为可能是多个线程同时设置,但是移除首节点的时候是不需要的,因为这个操作是由同步器操作的,并且首节点只有一个&lt;/p&gt;
&lt;h2&gt;独占式同步状态的获取与释放&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1979837/202011/1979837-20201118214117103-1018749021.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt; AQS的从线程的获取同步状态到,对同步队列的维护,到释放,的流程图就是这样的,有兴趣看源码的自己去跟一下,就是主要实现的模板方法,&lt;/p&gt;
&lt;p&gt;注意:其实在这个给大家提个醒,看源码的时候,找核心的看,找主要的看,不要一行一行的扣着看,没有意义,还有就是调用过程复杂,体会核心流程就可以&lt;/p&gt;

&lt;p&gt;之前写了&amp;lt;&amp;lt;&lt;a class=&quot;postTitle2 vertical-middle&quot; href=&quot;https://www.cnblogs.com/flower-dance/p/13923528.html&quot;&gt;Lock接口之Condition接口&lt;/a&gt;&amp;gt;&amp;gt;这一章,然后在这里写一下Condition接口在AQS里面的实现吧,因为不管自己写锁也好,默认锁的实现也好,用的Condition都是AQS默认写好的&lt;/p&gt;
&lt;h2&gt;Condition实现分析:&lt;/h2&gt;
&lt;p&gt;　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1979837/202011/1979837-20201118221339701-644876895.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 一个锁是可以有多个Condition的,每个Condition都包含一个自己的等待队列,不同于Object属于同一个对象等待,他存在一个单链表结构的等待队列,清晰的知道要唤醒自己的等待队列中的节点,所以采用signal方法而不是signalall&lt;/p&gt;
&lt;p&gt;当然采用的类还是Node类当然单链表其实就是没有上一个节点的引用而已&lt;/p&gt;
&lt;p&gt;等待队列和同步队列采用的是相同的类,只不过是实现的数据机构确是不一样的而已&lt;/p&gt;
&lt;p&gt;最终一个锁的实例化会成为上图中第二个图的这种形式,Demo也就是之前写的&amp;lt;&amp;lt;&lt;a class=&quot;postTitle2 vertical-middle&quot; href=&quot;https://www.cnblogs.com/flower-dance/p/13923528.html&quot;&gt;Lock接口之Condition接口&lt;/a&gt;&amp;gt;&amp;gt;中的用的锁最终形成的结构及时就是维持了一个同步队列和两个等待队列,锁用于控制并发,而两个队列用于控制地点变化和公里数变化的不同的等待通知模式&lt;/p&gt;
&lt;h2&gt;节点在队列中的移动&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1979837/202011/1979837-20201118222137328-1298962476.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 就是在当前线程await的时候从同步队列移除后加入到等待队列尾部,而唤醒就是从等待队列移除后加入到同步队列尾部,两个队列相互转换的过程,之所以采用同一个类,就是为了方便的在不同队列中相互转化&lt;/p&gt;
&lt;p&gt;当然这也是为什么不推荐使用SignalAll方法的原因,因为如果一个等待队列中有很多的线程在等待,全部唤醒后,最多且只能有一个线程获取到同步状态,其他线程全部要被加入到同步队列的末尾,而且也可能当前的同步状态被别人持有,一个线程也获取不到,全部都要被加入同步队列中,所以不推荐使用SignalAll,推荐是用Signal&lt;/p&gt;
&lt;p&gt;其实也可以想象,比如wait和notify/notifyAll 在写&amp;lt;&amp;lt;&lt;a class=&quot;postTitle2 vertical-middle&quot; href=&quot;https://www.cnblogs.com/flower-dance/p/13678742.html&quot;&gt;线程之间的协作(等待通知模式)&lt;/a&gt;&amp;gt;&amp;gt;这篇文章的时候的最后一个问题也可以大概想象一下,应该也是维持了一个同步队列,但是等待队列应该是只有一个,所以,被唤醒的是第一个等待的节点,但是它没有办法保证要被唤醒的节点一定是在头一个,只能唤醒全部的节点,来保证需要唤醒的线程一定被唤醒,大概也是这样的一个节点的移动,根据网络文章的描述,应该八九不离十&lt;/p&gt;
&lt;p&gt;根据猜测,结合上方的Condition接口分析,所以说,在wait,notify/notifyAll中推荐使用notifyAll,防止第一个节点不是需要唤醒的节点,造成唤醒错误,但是Condition是知道的,被唤醒的一定是需要唤醒的,不会唤醒错误,所以说,推荐使用signal&lt;/p&gt;
&lt;p&gt;能看到这里的证明你真的很爱这个行业,你是最棒的!加油&lt;/p&gt;
&lt;h2&gt;回顾Lock的实现&lt;/h2&gt;
&lt;h3&gt;ReentrantLock&lt;/h3&gt;
&lt;p&gt;其实在上面手写的锁,是有一些缺陷的,因为判断的是不是等于1,所以他是一个不支持可重入的,一旦重入,就会造成死锁,自己锁住自己,但是ReentrantLock就不会&lt;/p&gt;
&lt;p&gt;他支持锁的可重入,并且支持锁的公平和非公平&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1979837/202011/1979837-20201118224943903-368701860.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 通过源码可以看到,他是通过状态的累加完成的锁的可重入,当然前提是已经拿到锁的线程,会有这样一个判断&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1979837/202011/1979837-20201118225209480-1740610597.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 所以可想而知,释放的时候,每次释放就递减,最终等于0的时候完成锁的释放&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1979837/202011/1979837-20201118225518587-913274097.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 在实现公平锁的时候,就是判断当前节点是否有前期节点,是不是第一个,如果有,不是第一个,抱歉你不能抢锁&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1979837/202011/1979837-20201118225645497-1232413231.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 可想而知在非公平锁中就是不判断而已&lt;/p&gt;
&lt;p&gt;因为不需要判断,并且是谁抢到锁,锁就是谁的,所以说非公平锁比公平锁效率高&lt;/p&gt;

&lt;h3&gt;ReentrantReadWriteLock&lt;/h3&gt;
&lt;p&gt;在读写锁中,一个状态如何 保存两个状态呢?采用位数分割&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1979837/202011/1979837-20201118230936714-1954808222.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 应该有知道 int是32位的,他把32位一分为二,采用低位保存写的状态,高位保存读的状态&lt;/p&gt;
&lt;p&gt;写锁,应该都知道,只能同时被一个线程持有,所以重入的话,也比较好保存&lt;/p&gt;
&lt;p&gt;但是读锁不一样,可以被多个线程同时持有,是共享锁,并且重入的次数是不一样的,那么该则么保存呢?采用高位只保存被多少线程持有&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1979837/202011/1979837-20201118231421281-232137159.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 采用每个持有锁的线程中的一个HoldCounter对象保存,使用ThreadLocalHoldCounter继承ThreadLocal来保存线程变量,区别不同线程&lt;/p&gt;
&lt;h4&gt;读写锁的升级和降级&lt;/h4&gt;
&lt;p&gt;读写锁支持写锁降级为读锁,但是不支持读锁升级为写锁,为了保证线程安全和数据可见性,因为在写锁执行期间,读锁是被阻塞的,所以说写锁降级为读锁是没有问题的,但是如果是读锁升级为写锁,在其他线程使用完写锁的时候,读锁是看不见的,为了保证线程安全,所以不支持读锁升级成写锁&lt;/p&gt;

&lt;p&gt;到此AQS就写完了,因为AQS涉及的知识太多,能看到现在的也都是大神了,恭喜你们,掌握了并发编程的半壁江上,为了自己的梦想更近了一步,加油,因为知识点多,所以大家多看几遍,不理解的可以百度,也可以评论区提问&lt;/p&gt;

&lt;p&gt;作者：彼岸舞&lt;/p&gt;
&lt;p&gt;时间：2020\11\18&lt;/p&gt;
&lt;p&gt;内容关于：并发编程&lt;/p&gt;
&lt;p&gt;本文来源于网络，只做技术分享，一概不负任何责任&lt;/p&gt;

</description>
<pubDate>Wed, 18 Nov 2020 15:27:00 +0000</pubDate>
<dc:creator>彼岸舞</dc:creator>
<og:description>千呼万唤始出来,终于写到AQS这个一章了,其实为了写这一章,前面也是做了很多的铺垫,比如之前的 深度理解volatile关键字&amp;#160;线程之间的协作(等待通知模式)&amp;#160;JUC 常用4大并发</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/flower-dance/p/13929599.html</dc:identifier>
</item>
<item>
<title>解密Cookie，这一篇就够了 - Ming~~</title>
<link>http://www.cnblogs.com/ym7583306/p/14002809.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ym7583306/p/14002809.html</guid>
<description>&lt;p&gt;因为HTTP协议是无状态的，每次请求都是独立的，服务器端无法判断两次请求是否来自同一个用户，进而也就无法判断用户的登录状态，也不知道用户上一次做了什么。所以Cookie就是用来绕开HTTP的无状态性的“额外手段”之一。服务器可以设置或读取Cookies中包含信息，借此维护用户跟服务器会话中的状态。&lt;/p&gt;
&lt;p&gt;Cookie 是服务器端发送给客户端的一段特殊信息，这些信息以文本的方式存放在客户端，客户端每次向服务器端发送请求时都会带上这些特殊信息。&lt;br/&gt;具体过程是：客户端发送请求到服务端，然后服务端返回的response headers中会有Set-Cookie这个字段，将 信息写入 Cookie 中。然后在下一次客户端请求接口时，会在request headers里带上这个Cookie字段，这样服务器就可以拿到这些信息，达到了维持状态的目的。&lt;br/&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/1726990/1603262684364-f218636f-2387-4256-87ee-0287261f1de9.png#align=left&amp;amp;display=inline&amp;amp;height=190&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202020-10-21%2014.43.46.png&amp;amp;originHeight=258&amp;amp;originWidth=491&amp;amp;size=42575&amp;amp;status=done&amp;amp;style=stroke&amp;amp;width=361&quot; alt=&quot;屏幕快照 2020-10-21 14.43.46.png&quot; loading=&quot;lazy&quot;/&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/1726990/1603262688203-21f8b5cd-3e5b-4ab4-a93b-ac2705f137d4.png#align=left&amp;amp;display=inline&amp;amp;height=154&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202020-10-21%2014.43.33.png&amp;amp;originHeight=172&amp;amp;originWidth=407&amp;amp;size=27350&amp;amp;status=done&amp;amp;style=stroke&amp;amp;width=364&quot; alt=&quot;屏幕快照 2020-10-21 14.43.33.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Cookie 主要用于以下三个方面：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）&lt;/li&gt;
&lt;li&gt;个性化设置（如用户自定义设置、主题等）&lt;/li&gt;
&lt;li&gt;浏览器行为跟踪（如跟踪分析用户行为等）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;21-domain和path属性&quot;&gt;2.1 domain和path属性&lt;/h2&gt;
&lt;p&gt;domain 指定了该 Cookie 所属的域名，默认情况下，domain 会被设置为创建该 Cookie 时所在的域名。如果不指定，默认为 origin，不包含子域名。如果指定了Domain，则一般包含子域名。&lt;br/&gt;例如，如果设置 Domain=mozilla.org，则 Cookie 也包含在子域名中（如developer.mozilla.org）。&lt;br/&gt;而 path 则指定了该 Cookie 所属的路径，注意子路径也会被匹配。&lt;br/&gt;例如，设置 Path=/docs，则/docs/Web/ 这个地址也会匹配。&lt;br/&gt;domain 和 path 两者一起来限制了该 Cookie 允许被哪些 URL 访问。&lt;/p&gt;
&lt;h2 id=&quot;22-expiresmax-age&quot;&gt;2.2 Expires/Max-Age&lt;/h2&gt;
&lt;p&gt;Expires :具体到期时间，UTC格式。如果没有设置该选项，则默认有效期为session，即会话cookie，这种cookie在浏览器关闭后就没有了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Max-Age属性指定从现在开始 Cookie 存在的秒数，比如60 * 60 * 24 * 365（即一年）。过了这个时间以后，浏览器就不再保留这个 Cookie。&lt;br/&gt;如果同时指定了Expires和Max-Age，那么Max-Age的值将优先生效。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Max-Age为正数: cookie 会在 max-age 秒之后被销毁&lt;/li&gt;
&lt;li&gt;Max-Age为负数时: cookie 只在浏览器会话期间存在，当用户关闭浏览器窗口后这些值也会随之销毁&lt;/li&gt;
&lt;li&gt;Max-Age 为 0 时: cookie 将被立即销毁&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;23-samesite属性&quot;&gt;2.3 SameSite属性&lt;/h2&gt;
&lt;p&gt;SameSite： Cookie 允许服务器要求某个 cookie 在跨站请求时不会被发送，从而可以阻止跨站请求伪造攻击（CSRF）。&lt;br/&gt;SameSite 可以有下面三种值：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;None。浏览器会在同站请求、跨站请求下继续发送 cookies，不区分大小写。&lt;/li&gt;
&lt;li&gt;Strict。浏览器将只发送相同站点请求的 Cookie(即当前网页 URL 与请求目标 URL 完全一致)。&lt;/li&gt;
&lt;li&gt;Lax。在新版本浏览器中，为默认选项，Same-site Cookies 将会为一些跨站子请求保留，如图片加载或者 iframe 不会发送，而点击 a 标签会发送；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;大多数主流浏览器的SameSite的默认值已经是Lax了。如果想要指定 Cookies 在同站、跨站请求都被发送，现在需要明确指定 SameSite 为 None。（所以不要再问为什么接口返回了Set-Cookie但是却没有设置成功了，大概率原因在这里，曾经遇到过。本地开发的话在chrome://flags中把SameSite by default cookies设为Disabled即可解决，可正常开发，上线的话一般不会跨域，即不会出现这个问题，如果出现跨域就只能让后端改了domain字段了）&lt;/p&gt;
&lt;h2 id=&quot;24-httponly&quot;&gt;2.4 HttpOnly&lt;/h2&gt;
&lt;p&gt;如果这个属性设置为true，意思就是告之浏览器该 cookie 绝不能通过 JavaScript 的 document.cookie 属性访问。可以避免跨域脚本 (XSS) 攻击。&lt;br/&gt;（面试高频）&lt;/p&gt;
&lt;h2 id=&quot;25-secure&quot;&gt;2.5 Secure&lt;/h2&gt;
&lt;p&gt;标记为 Secure的 Cookie 只应通过被 HTTPS 协议加密过的请求发送给服务端。&lt;/p&gt;

&lt;h3 id=&quot;1创建cookie：&quot;&gt;1.创建Cookie：&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;// 直接使用document.cookie = 设置即可
document.cookie= &quot;test=&quot; + '123';
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;2读取cookie：&quot;&gt;2.读取Cookie：&lt;/h3&gt;
&lt;p&gt;直接调用函数，例如let cookie = getCookie(); cookie.name即为对应cookie。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;// 读取Cookie函数
function getCookie() {
  let cookieArr = document.cookie.split(&quot;; &quot;); // 特别注意！cookie中的数据都是以分号加空格区分开 
  let obj = {};
  cookieArr.forEach( v =&amp;gt; {
    let arr = v.split(&quot;=&quot;);
    obj[arr[0]] =  unescape(arr[1]); // unescape 解码
  });
  return obj
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;3删除cookie：&quot;&gt;3.删除Cookie：&lt;/h3&gt;
&lt;p&gt;直接调用：delCookie(&quot;xxx&quot;);&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;//删除Cookie
        function delCookie(name){
    // 将 cookie 的 max-age 属性设置 0 来实现对 cookie 的删除
                document.cookie = `${name}=;max-age=0`;
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在ios系统上面，设置Cookie为汉字时会设置失败，所以需要将汉字进行编码，再储存到Cookie，取出来的时候也需要解码，encode：escape()，decode：unescape()。&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;Cookie是跨域的，也就是在不同的域名中，访问的Cookie的时候，只能访问对应的域名的Cookie。&lt;/li&gt;
&lt;li&gt;每个Cookie的大小一般不超过4KB，超过以后，Cookie将会被忽略，不会被设置&lt;/li&gt;
&lt;li&gt;浏览器每次向服务器发起请求，就会自动附上Cookie&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;更多文章以及分享请关注微信公众号 &lt;strong&gt;前端er的分享&lt;/strong&gt;，不止于前端，定期输出一些技术知识、生活感想、理财知识等。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 18 Nov 2020 15:05:00 +0000</pubDate>
<dc:creator>Ming~~</dc:creator>
<og:description>一、Cookie介绍 因为HTTP协议是无状态的，每次请求都是独立的，服务器端无法判断两次请求是否来自同一个用户，进而也就无法判断用户的登录状态，也不知道用户上一次做了什么。所以Cookie就是用来绕</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ym7583306/p/14002809.html</dc:identifier>
</item>
<item>
<title>一文解析TCP/UDP - _热风</title>
<link>http://www.cnblogs.com/refeng/p/13996657.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/refeng/p/13996657.html</guid>
<description>&lt;p&gt;声明：本文部分内容来自互联网、书籍等渠道，表示感谢；&lt;/p&gt;
&lt;p&gt;转载请注明出处：@热风、&lt;a href=&quot;https://www.cnblogs.com/refeng/p/13996657.html&quot;&gt;https://www.cnblogs.com/refeng/p/13996657.html&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;

&lt;h2 id=&quot;1、tcpudp比较&quot;&gt;1、TCP/UDP比较&lt;/h2&gt;
&lt;h3 id=&quot;11：简介&quot;&gt;1.1：简介&lt;/h3&gt;
&lt;p&gt;TCP（Transmission Control Protocol，&lt;strong&gt;传输控制协议&lt;/strong&gt;）和UDP（User Datagram Protocol，&lt;strong&gt;用户数据报协议&lt;/strong&gt;）是OSI七层模型——传输层的两个主要协议，均是互联网的正式标准。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/refeng/1883680/o_201118143113%E5%9B%BE%E7%89%871.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;12：tcp&quot;&gt;1.2：TCP&lt;/h3&gt;
&lt;p&gt;TCP是一种&lt;strong&gt;面向连接&lt;/strong&gt;的、&lt;strong&gt;可靠&lt;/strong&gt;的、基于&lt;strong&gt;字节流&lt;/strong&gt;的通信协议，是为了在不可靠的互联网络上提供可靠的&lt;strong&gt;端到端&lt;/strong&gt;字节流而专门设计的一个传输协议。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;优点：&lt;strong&gt;可靠&lt;/strong&gt;。传递数据之前，通过三次握手来建立连接，在数据传递时，有滑动窗口、拥塞控制、超时重传等机制保证传输的可靠性、正确性，在数据传输完成后，可保持连接状态（长连接）或通过四次挥手来断开连接（短连接）。&lt;/li&gt;
&lt;li&gt;缺点：&lt;strong&gt;效率较低&lt;/strong&gt;、&lt;strong&gt;占用系统资源高&lt;/strong&gt;，&lt;strong&gt;易被攻击&lt;/strong&gt;。TCP在传递数据之前，要先建连接，会消耗时间，在数据传递时，各种机制都会消耗大量的时间，而且要在每台设备上维护所有的传输连接，事实上，每个连接都会占用系统的CPU、内存等硬件资源。而且TCP有确认机制、三次握手机制，这些容易被人利用。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;13：udp&quot;&gt;1.3：UDP&lt;/h3&gt;
&lt;p&gt;UDP是一种无连接的、不可靠的、基于报文的通信协议，为应用程序提供了一种无需建立连接就可以发送封装的 IP 数据包的方法。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;优点：&lt;strong&gt;快&lt;/strong&gt;。没有TCP协议的各种机制。&lt;/li&gt;
&lt;li&gt;缺点：&lt;strong&gt;不可靠&lt;/strong&gt;，&lt;strong&gt;不稳定&lt;/strong&gt;。尽最大努力交付，如果网络质量不好，就很容易丢包。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;14：tcpudp比较&quot;&gt;1.4：TCP/UDP比较&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th&gt;TCP&lt;/th&gt;
&lt;th&gt;UDP&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;5.5&quot;&gt;&lt;tr&gt;&lt;td&gt;是否连接&lt;/td&gt;
&lt;td&gt;面向连接&lt;/td&gt;
&lt;td&gt;无连接&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;是否可靠&lt;/td&gt;
&lt;td&gt;可靠&lt;/td&gt;
&lt;td&gt;不可靠&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;连接对象个数&lt;/td&gt;
&lt;td&gt;只能一对一&lt;/td&gt;
&lt;td&gt;支持一对一，一对多，多对一和多对多&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;传输方式&lt;/td&gt;
&lt;td&gt;面向字节流&lt;/td&gt;
&lt;td&gt;面向报文&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;首部开销&lt;/td&gt;
&lt;td&gt;首部最小20字节，最大60字节&lt;/td&gt;
&lt;td&gt;首部开销小，仅8字节&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;适用场景&lt;/td&gt;
&lt;td&gt;适用于要求可靠传输的应用，例如&lt;strong&gt;FTP、HTTP、STMP&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;适用于实时应用，例如&lt;strong&gt;即时通信、视频会议、直播&lt;/strong&gt;等（丢包影响不大、就要快）&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/refeng/1883680/o_20111713341720180907190118826.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;2、tcp详解&quot;&gt;2、TCP详解&lt;/h2&gt;
&lt;h3 id=&quot;21：概念&quot;&gt;2.1：概念&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;TCP是一种面向连接的、可靠的传输层协议；&lt;/li&gt;
&lt;li&gt;TCP协议建立在不可靠的网络层IP协议之上，IP不能提供任何可靠性机制，TCP的可靠性完全由自己实现；&lt;/li&gt;
&lt;li&gt;TCP采用的最基本的可靠性技术是：
&lt;ul&gt;&lt;li&gt;确认与超时重传&lt;/li&gt;
&lt;li&gt;滑动窗口机制进行流量控制&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;22：tcp报文格式&quot;&gt;2.2：TCP报文格式&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/refeng/1883680/o_201118142930360%E6%88%AA%E5%9B%BE17911006153349.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;221：各字段含义&quot;&gt;2.2.1：各字段含义&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;源端口号与目的端口号：各占&lt;strong&gt;2&lt;/strong&gt;个字节。端口是传输层与高层的服务接口。&lt;/li&gt;
&lt;li&gt;序号：占&lt;strong&gt;4&lt;/strong&gt;字节，是本报文段所发送的数据部分第一个字节的序号。在TCP传送的数据流中，&lt;strong&gt;每一个字节都有一个序号&lt;/strong&gt;。例如，在一个报文段中，序号为300，而报文中的数据共100字节。那么在下一个报文段中，其序号就是400。因此TCP是面向数据流（字节流）的。&lt;/li&gt;
&lt;li&gt;确认号：占&lt;strong&gt;4&lt;/strong&gt;字节，是期望收到对方下次发送的数据的第一个字节的序号，也就是期望收到的下一个报文段的首部中的序号。由于序号字段有32bit长，可对4GB(即4千兆字节)的数据进行编号。&lt;/li&gt;
&lt;li&gt;报头长度：占&lt;strong&gt;4&lt;/strong&gt;bit，&lt;/li&gt;
&lt;li&gt;确认比特ACK：只有当ACK＝1时确认序号字段才有意义。当ACK＝0时，确认序号没有意义。&lt;/li&gt;
&lt;li&gt;同步比特SYN：在连接建立时使用。当&lt;strong&gt;SYN＝1&lt;/strong&gt;而&lt;strong&gt;ACK＝0&lt;/strong&gt;时，表明这是一个&lt;strong&gt;连接请求&lt;/strong&gt;报文段。对方若同意建立连接，则应在发回的报文段中使&lt;strong&gt;SYN＝1&lt;/strong&gt;和&lt;strong&gt;ACK=1&lt;/strong&gt;，表明这是一个&lt;strong&gt;连接接受&lt;/strong&gt;报文段。因此，&lt;strong&gt;同步比特SYN为1，就表示这是一个连接请求或连接接受报文，而 ACK比特的值用来区分是哪一种报文。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;终止比特FIN：用来释放一个连接，当&lt;strong&gt;FIN＝1&lt;/strong&gt;时．表明欲发送的字节串已经发完，并要求释放传输连接。&lt;/li&gt;
&lt;li&gt;窗口大小：占&lt;strong&gt;2&lt;/strong&gt;字节。窗口字段实际上是报文段&lt;strong&gt;发送方的接收窗口&lt;/strong&gt;，单位为字节。通过此窗口告诉对方，“在未收到我的确认时，你能发送的数据的字节数至多是此窗口的大小。”&lt;/li&gt;
&lt;li&gt;检验和：占&lt;strong&gt;2&lt;/strong&gt;字节。检验和字段检验的范围包括首部和数据这两部分。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;23：可靠传输步骤&quot;&gt;2.3：可靠传输步骤&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;建立连接&lt;/li&gt;
&lt;li&gt;报文传输
&lt;ul&gt;&lt;li&gt;差错控制：校验，错误（丢包）重传机制&lt;/li&gt;
&lt;li&gt;流量控制：滑动窗口机制&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;关闭连接&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;231：建立连接，三次握手&quot;&gt;2.3.1：建立连接，三次握手&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/refeng/1883680/o_201118142953%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B1.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;主机1 首先发起TCP 连接请求，并在所发送的数据段中将控制字段中的&lt;strong&gt;SYN置为“1”、ACK置为“0”，并设置数据起始序号为x&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;主机2 收到该报文，若同意建立连接，则发送一个连接接受的应答数据段，其中控制字段的SYN 和ACK均被&lt;strong&gt;置“1”&lt;/strong&gt;，指示对第一个SYN 报文段的确认，&lt;strong&gt;响应序号x+1&lt;/strong&gt;,表示对指定报文的响应，同时指定自己的数据序号&lt;strong&gt;y&lt;/strong&gt;，以继续握手操作；否则，主机2 要发送一个将RST置为“1”的应答数据段，表示拒绝建立连接。&lt;/li&gt;
&lt;li&gt;主机1 收到主机2 发来的同意建立连接数据段后，还有再次进行选择的机会，若其确认要建立这个连接，则向主机2 发送确认数据段，确认序号为y+1，同时自己的数据需要为x+1，用来通知主机2 双方已完成建立连接；若主机1已不想建立这个连接，则可以发送一个将&lt;strong&gt;RST置为“1”&lt;/strong&gt;的应答数据段来告之主机2 拒绝建立连接。（思考：若主机1迟迟不发消息，怎么办？）&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;232：差错控制&quot;&gt;2.3.2：差错控制&lt;/h4&gt;
&lt;p&gt;TCP采用校验、确认以及超时重传，进行差错控制。&lt;/p&gt;
&lt;h5 id=&quot;2321：校验与确认&quot;&gt;2.3.2.1：校验与确认&lt;/h5&gt;
&lt;p&gt;发送方会对发送数据进行处理生成校验码，并设置在校验码字段中，随数据一起发送：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;接收方对数据进行校验，判断数据传输是否出现错误；&lt;/li&gt;
&lt;li&gt;接收方对正确接收到的数据进行确认；&lt;/li&gt;
&lt;li&gt;发送方发送数据时，启动定时器，超时未接收到确认，则重传数据。&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;2322：超时重传&quot;&gt;2.3.2.2：超时重传&lt;/h5&gt;
&lt;p&gt;采用&lt;strong&gt;单一定时器&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;发送TCP分段（TCP会自己分段）时，如果没有重传定时器开启，那么开启；如果已有重传定时器开启，不再开启。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;收到一个非重复ACK时，如果有数据在传输中，重新开启重传定时器；如果没有数据在传输中，则关闭重传定时器。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;未收到确认造成定时器超时，重传所有发出未确认的分段。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;收到重复ACK时，超过3个，则立即重传重复确认的数据。&lt;/p&gt;
&lt;p&gt;（还有一些深入知识不详解）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;2323：流量控制&quot;&gt;2.3.2.3：流量控制&lt;/h5&gt;
&lt;p&gt;接收方和发送方都有一定大小的接收和发送缓冲区。发送方的发送速度不能超过接收方的接收速度。&lt;/p&gt;
&lt;p&gt;为了防止由于发送端与接收端之间的不匹配而引起数据丢失，TCP采用滑动窗口进行流量控制。双方通过窗口大小来告诉对方，在没有收到确认前，最多可以发送的数据量。&lt;/p&gt;
&lt;p&gt;发送窗口=min{拥塞窗口，通告窗口}&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/refeng/p/13996657.html#2.5.2：拥塞窗口&quot;&gt;拥塞窗口&lt;/a&gt;：从&lt;strong&gt;通信子网拥塞程度&lt;/strong&gt;考虑确定的在没有收到接收方确认情况，发送方可以发送的数据量；&lt;/li&gt;
&lt;li&gt;通告窗口：从&lt;strong&gt;接收方接收能力&lt;/strong&gt;的角度考虑，确定的在没有收到接收方确认情况，发送方可以发送的数据量；由接收到的TCP报文中的窗口大小字段确定。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;233关闭连接，四次挥手&quot;&gt;2.3.3:关闭连接，四次挥手&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/refeng/1883680/o_201118143009%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;当主机1 的数据已发送完毕时，其在等待确认的同时可发送一个将控制字段&lt;strong&gt;FIN 置“1”&lt;/strong&gt;的数据段给主机2，表示请求中断主机1到主机2的连接。&lt;/li&gt;
&lt;li&gt;若主机2 已正确接收主机1 的所有分段，则会发送一个数据段正确接收的确认段，同时通知本地相应的应用程序，对方要求关闭连接，接着再发送一个对主机1 所发送的FIN段进行确认的应答段。由此便拆除了一个方向的TCP连接。&lt;/li&gt;
&lt;li&gt;但是，此时在相反方向上，主机2 仍然可以向主机1 发送数据，直到主机2 数据发送完毕并要求关闭连接。这个方向上连接的拆除同样要经过（1）、（2）两步，&lt;strong&gt;由主机2发起FIN段，主机1应答确认ACK，拆除另一方向的TCP连接&lt;/strong&gt;。（全双工）&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;24：常用tcp端口号分配&quot;&gt;2.4：常用TCP端口号分配&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;端口号&lt;/th&gt;
&lt;th&gt;服务进程&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;20&lt;/td&gt;
&lt;td&gt;FTP&lt;/td&gt;
&lt;td&gt;文件传输协议（数据连接）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;21&lt;/td&gt;
&lt;td&gt;FTP&lt;/td&gt;
&lt;td&gt;文件传输协议（控制连接）&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;23&lt;/td&gt;
&lt;td&gt;Telent&lt;/td&gt;
&lt;td&gt;虚拟终端网络&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;25&lt;/td&gt;
&lt;td&gt;SMTP&lt;/td&gt;
&lt;td&gt;简单邮件传输协议&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;53&lt;/td&gt;
&lt;td&gt;DNS&lt;/td&gt;
&lt;td&gt;域名服务器&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;80&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;HTTP&lt;/td&gt;
&lt;td&gt;超文本传输协议&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;111&lt;/td&gt;
&lt;td&gt;RPC&lt;/td&gt;
&lt;td&gt;远程过程调用&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;25：tcp的拥塞控制&quot;&gt;2.5：TCP的拥塞控制&lt;/h3&gt;
&lt;h4 id=&quot;251：概念&quot;&gt;2.5.1：概念&lt;/h4&gt;
&lt;p&gt;网络中的链路带宽、交换节点的存储和处理能力等都是网络的资源，这些资源一般是有限的，&lt;strong&gt;当网络的资源容量和处理能力大于网络负载的需求时&lt;/strong&gt;，网络处于&lt;strong&gt;正常&lt;/strong&gt;运转状态，反之网络会出现拥塞。&lt;/p&gt;
&lt;p&gt;网络拥塞的根本原因在于&lt;strong&gt;端系统向网络提供的负载大于网络资源容量和处理能力&lt;/strong&gt;，主要体现在&lt;strong&gt;网络转发设备的存储空间有限，网络链路带宽有限&lt;/strong&gt;以及&lt;strong&gt;网络转发设备的处理能力有限&lt;/strong&gt;等。&lt;/p&gt;
&lt;p&gt;TCP拥塞控制的基本策略是&lt;strong&gt;发送端通过跟踪传输数据的丢失现象&lt;/strong&gt;和&lt;strong&gt;往返时延的变化&lt;/strong&gt;确定网络的传输能力，并以此来调整发送数据率。&lt;/p&gt;
&lt;h4 id=&quot;252：拥塞窗口&quot;&gt;2.5.2：拥塞窗口&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;拥塞窗口cwnd&lt;/strong&gt;是每个TCP端系统在建立连接时创建的拥塞控制量，同样定义为&lt;strong&gt;发送端未收到确认时可以连续发送的字节数&lt;/strong&gt;。拥塞窗口随网络传输能力变化而变化。当网络负载较小时，拥塞窗口可以设置比较大，发之，就要设置成相对较小值。&lt;/p&gt;
&lt;h4 id=&quot;253：控制方法&quot;&gt;2.5.3：控制方法&lt;/h4&gt;
&lt;p&gt;TCP发送端可以通过两种方式检测到发送的数据在网络中丢失，一种是通过&lt;strong&gt;超时定时器，超时未收到对发送数据的正确确认，则判定所发数据丢失&lt;/strong&gt;，另一种方式是，&lt;strong&gt;当发送端连续收到多个对其发送的某个数据分组的重复确认时，说明该分组后继分组在传输中出了问题&lt;/strong&gt;。对两种不同方式检测到的数据包丢弃，TCP发送端采用不同的方式进行拥塞控制。&lt;/p&gt;
&lt;p&gt;针对&lt;strong&gt;超时重发&lt;/strong&gt;检测到的数据丢失，TCP发送端采用&lt;strong&gt;慢启动和拥塞避免&lt;/strong&gt;方法进行拥塞控制；&lt;/p&gt;
&lt;p&gt;对通过&lt;strong&gt;重复确认&lt;/strong&gt;发现的数据包丢失，TCP发送端采用&lt;strong&gt;快重发和拥塞避免&lt;/strong&gt;方法进行拥塞控制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;慢启动门限&lt;/strong&gt;ssthresh是一个动态变化的门限值，用来确定当前是否采用拥塞避免算法，初始值65535。&lt;/p&gt;
&lt;h5 id=&quot;2531：慢启动算法&quot;&gt;2.5.3.1：慢启动算法&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/refeng/1883680/o_201118142948%E6%85%A2%E5%90%AF%E5%8A%A8%E7%AE%97%E6%B3%95.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;RTT：传输往返时间&lt;/p&gt;
&lt;p&gt;（思考：cwnd以&lt;strong&gt;指数&lt;/strong&gt;形式增长，为什么叫慢启动算法？）&lt;/p&gt;
&lt;h5 id=&quot;2532：拥塞避免算法&quot;&gt;2.5.3.2：拥塞避免算法&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/refeng/1883680/o_201118143013%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D%E7%AE%97%E6%B3%95.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;cwnd&lt;strong&gt;线性&lt;/strong&gt;增长。&lt;/p&gt;
&lt;p&gt;例子：发生超时，进入慢启动；超过门限，进入拥塞避免&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/refeng/1883680/o_201118143001%E6%85%A2%E5%90%AF%E5%8A%A8%E6%A0%B7%E4%BE%8B.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;2533：工作过程&quot;&gt;2.5.3.3：工作过程&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/refeng/1883680/o_201118143018%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/refeng/1883680/o_201118143023%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%A0%B7%E4%BE%8B.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;3、udp详解&quot;&gt;3、UDP详解&lt;/h2&gt;
&lt;p&gt;UDP是一种无连接的、不可靠的传输层协议，UDP协议的目的是希望以最小的开销来达到网络环境中的进程通信目的。&lt;/p&gt;
&lt;h3 id=&quot;31：udp数据报格式&quot;&gt;3.1：UDP数据报格式&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/refeng/1883680/o_201118142943UDP%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%A0%BC%E5%BC%8F.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;32：udp的基本工作过程&quot;&gt;3.2：UDP的基本工作过程&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/refeng/1883680/o_201118142937UDP%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;33：常用udp端口号分配&quot;&gt;3.3：常用UDP端口号分配&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;端口号&lt;/th&gt;
&lt;th&gt;服务进程&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr&gt;&lt;td&gt;53&lt;/td&gt;
&lt;td&gt;Name server&lt;/td&gt;
&lt;td&gt;域名服务&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;67&lt;/td&gt;
&lt;td&gt;Bootps&lt;/td&gt;
&lt;td&gt;下载引导程序信息的服务器端口&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;68&lt;/td&gt;
&lt;td&gt;Bootpc&lt;/td&gt;
&lt;td&gt;下载引导程序信息的客户器端口&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;69&lt;/td&gt;
&lt;td&gt;TFTP&lt;/td&gt;
&lt;td&gt;简单文件传输协议&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;111&lt;/td&gt;
&lt;td&gt;RPC&lt;/td&gt;
&lt;td&gt;远程过程调用&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;123&lt;/td&gt;
&lt;td&gt;NTP&lt;/td&gt;
&lt;td&gt;网络时间协议&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;161&lt;/td&gt;
&lt;td&gt;SNMP&lt;/td&gt;
&lt;td&gt;简单网络管理协议&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;hr/&gt;&lt;p&gt;声明：本文部分内容来自互联网、书籍等渠道，表示感谢；&lt;/p&gt;
&lt;p&gt;转载请注明出处：@热风、&lt;a href=&quot;https://www.cnblogs.com/refeng/p/13996657.html&quot;&gt;https://www.cnblogs.com/refeng/p/13996657.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果有学到东西，请&lt;strong&gt;点赞&lt;/strong&gt;给予鼓励，谢谢。&lt;/p&gt;
&lt;hr/&gt;</description>
<pubDate>Wed, 18 Nov 2020 14:43:00 +0000</pubDate>
<dc:creator>_热风</dc:creator>
<og:description>声明：本文部分内容来自互联网、书籍等渠道，表示感谢； 转载请注明出处：@热风、https://www.cnblogs.com/refeng/p/13996657.html TCP/UDP详解 1、TC</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/refeng/p/13996657.html</dc:identifier>
</item>
</channel>
</rss>