<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>JVM 第四篇：可视化 JVM 故障处理工具 - 极客挖掘机</title>
<link>http://www.cnblogs.com/babycomeon/p/13800816.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/babycomeon/p/13800816.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://cdn.geekdigging.com/java/java_header.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;本文内容过于硬核，建议有 Java 相关经验人士阅读。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-可视化工具&quot;&gt;1. 可视化工具&lt;/h2&gt;
&lt;p&gt;在 JDK 中为我们提供了大量的 JVM 故障处理工具，都在 JDK 的 bin 目录下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.geekdigging.com/java/jvm/jvm4/jvm_tools.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这其中除了大量的命令行工具以外，还为我们提供了更加方便快捷的可视化工具，主要是以下这 4 个：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;JConsole: 最古老的工具，早在 JDK 5 时期就已经存在的虚拟机监控工具。&lt;/li&gt;
&lt;li&gt;JHSDB: 名义上在 JDK 9 中才正式提供，但之前已经以 sa-jdi.jar 包里面的 HSDB（可视化工具） 和 CLHSDB（命令行工具） 的形式存在了很长一段时间。&lt;/li&gt;
&lt;li&gt;VisualVM: 在 JDK 6 Update 7 中首次发布，直到 JRockit Mission Control 与 OracleJDK 的融合工作完成之前，它都曾是 Oracle 主力推动的多合一故障处理工具，现在它已经从 OracleJDK 中分离出来，成为一个独立发展的开源项目。&lt;/li&gt;
&lt;li&gt;JMC: Java Mission Control ，曾经是大名鼎鼎的来自 BEA 公司的图形化诊断工具，随着 BEA 公司被 Oracle 收购，它便被融合进 OracleJDK 之中。在 JDK 7 Update 40 时开始随 JDK 一起发布，后来 Java SE Advanced 产品线建立， Oracle 明确区分了 Oracle OpenJDK 和 OracleJDK 的差别， JMC 从 JDK 11 开始又被移除出 JDK 。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;2-hsdb&quot;&gt;2. HSDB&lt;/h2&gt;
&lt;p&gt;HSDB（Hotspot Debugger） 是 JDK 自带的工具，用于查看 JVM 运行时的状态。&lt;/p&gt;
&lt;p&gt;使用方式由于在 JDK 9 之前没有正式提供，所以也未在 JDK 的 bin 目录下提供直接可执行文件，需要在命令行执行命令才能启动。&lt;/p&gt;
&lt;p&gt;首先在命令行中先 cd 至 &lt;code&gt;C:\Program Files\Java\jdk1.8.0_221\lib&lt;/code&gt; 目录，然后执行：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;java -cp .\sa-jdi.jar sun.jvm.hotspot.HSDB
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我在执行这句命令的时候报了个错:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;Exception in thread &quot;Thread-1&quot; java.lang.UnsatisfiedLinkError: Can't load library: C:\Program Files\Java\jdk-11.0.4\bin\sawindbg.dll
        at java.base/java.lang.ClassLoader.loadLibrary(ClassLoader.java:2620)
        at java.base/java.lang.Runtime.load0(Runtime.java:767)
        at java.base/java.lang.System.load(System.java:1831)
        at sun.jvm.hotspot.debugger.windbg.WindbgDebuggerLocal.&amp;lt;clinit&amp;gt;(WindbgDebuggerLocal.java:661)
        at sun.jvm.hotspot.HotSpotAgent.setupDebuggerWin32(HotSpotAgent.java:567)
        at sun.jvm.hotspot.HotSpotAgent.setupDebugger(HotSpotAgent.java:335)
        at sun.jvm.hotspot.HotSpotAgent.go(HotSpotAgent.java:304)
        at sun.jvm.hotspot.HotSpotAgent.attach(HotSpotAgent.java:140)
        at sun.jvm.hotspot.HSDB.attach(HSDB.java:1184)
        at sun.jvm.hotspot.HSDB.access$1700(HSDB.java:53)
        at sun.jvm.hotspot.HSDB$25$1.run(HSDB.java:456)
        at sun.jvm.hotspot.utilities.WorkerThread$MainLoop.run(WorkerThread.java:66)
        at java.base/java.lang.Thread.run(Thread.java:834)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;含义是有一个 &lt;code&gt;sawindbg.dll&lt;/code&gt; 在 jdk 的目录下找不到，因为我本地有多个 jdk ，配置环境变量的是 jdk 11 ，我在 jdk 8 的 jre 的 bin 目录下找到了这个文件，直接 copy 到 jdk 11 的bin 目录下解决此问题。&lt;/p&gt;
&lt;p&gt;执行完成后会打开这么个界面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.geekdigging.com/java/jvm/jvm4/HSDB_1.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来，我们写一小段测试代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public abstract class A {
    public void printMe() {
        System.out.println(&quot;I am A class&quot;);
    }
    public abstract void sayHello();
}

public class B extends A {
    @Override
    public void sayHello() {
        System.out.println(&quot;I am B class&quot;);
    }
}

public class HSDB_Test {
    public static void main(String[] args) throws IOException {
        A obj = new B();
        // 无意义，单纯用作卡住主线程，防止线程结束
        System.in.read();
        System.out.println(obj);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先在命令行中使用命令 &lt;code&gt;jps -l&lt;/code&gt; 查看 Java 进程的 pid ：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;PS C:\Users\inwsy&amp;gt; jps -l
1648 com.geekdigging.lesson04.jvmtools.HSDB_Test
8704
9280 org.jetbrains.jps.cmdline.Launcher
14724 jdk.jcmd/sun.tools.jps.Jps
3220 org/netbeans/Main
15144
20572 org.jetbrains.jps.cmdline.Launcher
7548 sun.jvm.hotspot.HSDB
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，我们刚写的测试方法的 pid 是 1648 ，在 HSDB 中点击 File &amp;gt; Attach to Hotspot process ：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.geekdigging.com/java/jvm/jvm4/HSDB_2.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第一个看到的就是当前进程中的线程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.geekdigging.com/java/jvm/jvm4/HSDB_3.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到这里，我们的准备工作就已经结束，接着我们使用 Tools &amp;gt; Class Browser 找到对象 B 的内存地址：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.geekdigging.com/java/jvm/jvm4/HSDB_4.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图中红框框起来的是我自己写的三个类，可以看到我这里 B 的内存地址是 &lt;code&gt;0x00000007c0060c18&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;接下来，使用 Tools &amp;gt; Inspector 查看这个对象的详细信息：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.geekdigging.com/java/jvm/jvm4/HSDB_5.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;vtable 是虚表方法，这里我们看到 class B 有 7 个虚表方法，因为所有的对象都继承自 Object ，所以 B 继承了 Object 的 5 个方法，然后还继承了 A 的一个方法，自己重写了一个方法，总共是 7 个方法。&lt;/p&gt;
&lt;p&gt;这个我们可以进行一下验证，可以在 Windows &amp;gt; Console 中使用 mem 命令进行查看。&lt;/p&gt;
&lt;p&gt;那么我们可以开始计算， vtable 是在 instanceKlass 对象实例的尾部，而 instanceKlass 大小在 64 位系统的大小为 0x1B8 ，因此 vtable 的起始地址等于 instanceKlass 的内存首地址加上 0x1B8 等于 7C0060DD0 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.geekdigging.com/java/jvm/jvm4/HSDB_6.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来，我们在 Windows &amp;gt; Console 中使用 mem 命令进行验证：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.geekdigging.com/java/jvm/jvm4/HSDB_7.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第一列是方法实际在堆中的内存地址，第二列则是内存指针地址，我们可以将拿到的内存指针地址去 A ， B 和 Object 中分别查看，可以看到前 5 行对应的是 Object 的方法，第 6 行对应的是 A 对象中的方法，第 7 行则对应 B 对象中的方法。&lt;/p&gt;
&lt;h2 id=&quot;3-jconsole&quot;&gt;3. JConsole&lt;/h2&gt;
&lt;p&gt;JConsole（Java Monitoring and Management Console） 是一款基于 JMX（Java Manage-ment Extensions） 的可视化监视、管理工具。它的主要功能是通过 JMX 的 MBean（Managed Bean） 对系统进行信息收集和参数动态调整。&lt;/p&gt;
&lt;p&gt;JConsole 位于 JDK/bin 这个目录下，直接双击 jconsole.exe 就可以直接启动，在启动之后，会自动搜索出当前在本机运行的所有虚拟机进程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.geekdigging.com/java/jvm/jvm4/JConsole_1.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里可以看到我本机目前运行了一个 JConsole ，一个 idea ，还有一个启动的 tomcat 的源码。&lt;/p&gt;
&lt;p&gt;随便双击一个服务，进入主页面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.geekdigging.com/java/jvm/jvm4/JConsole_2.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到主界面里共包括概述、内存、线程、类、 VM 摘要、 MBean 六个页签。&lt;/p&gt;
&lt;p&gt;还是来个小示例，我们来了解下它的监控功能。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class MonitoringTest {
    // 内存占位对象，一个对象大约 64KB
    static class OOMObject {
        public byte[] placeholder = new byte[64 * 1024];
    }

    public static void fillHeap(int nums) throws InterruptedException {
        List&amp;lt;OOMObject&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        for (int i = 0; i &amp;lt; nums; i++) {
            Thread.sleep(50);
            list.add(new OOMObject());
        }
        System.gc();
    }

    public static void main(String[] args) throws InterruptedException {
        fillHeap(1000);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个案例是使用大约 64KB/50ms 的速度向 Java 堆中填充数据，一共填充 1000 次。&lt;/p&gt;
&lt;p&gt;程序执行后可以看到，在整个 Java 堆中，曲线一直是平滑向上的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.geekdigging.com/java/jvm/jvm4/JConsole_3.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;切换到内存标签页，查看 Eden 后可以发现，整个 Eden 的图形是一个折线：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.geekdigging.com/java/jvm/jvm4/JConsole_4.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再切换到 Gen ，可以看到整个老年代也是折叠向上的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.geekdigging.com/java/jvm/jvm4/JConsole_5.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们已经在代码里加了 &lt;code&gt;System.gc()&lt;/code&gt; ，为什么看起来没生效呢？&lt;/p&gt;
&lt;p&gt;因为 &lt;code&gt;System.gc()&lt;/code&gt; 是在 &lt;code&gt;fillHeap()&lt;/code&gt; 方法中的，在 GC 的时候，还在作用域中，想要正常回收老年代，需要将 &lt;code&gt;System.gc()&lt;/code&gt; 这段代码转移到 &lt;code&gt;fillHeap()&lt;/code&gt; 外面。&lt;/p&gt;
&lt;p&gt;先修改下代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static void main(String[] args) throws InterruptedException {
    fillHeap(1000);
    System.gc();
    // GC 后停顿 3s ，方便观察图像
    Thread.sleep(3000);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.geekdigging.com/java/jvm/jvm4/JConsole_6.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到在最后进程结束的时候， Gen 的柱状图已经没有内存占用了，内存回收成功。&lt;/p&gt;
&lt;h2 id=&quot;3-visualvm&quot;&gt;3. VisualVM&lt;/h2&gt;
&lt;p&gt;VisualVM（All-in-One Java Troubleshooting Tool）是功能最强大的运行监视和故障处理程序之一，曾经在很长一段时间内是 Oracle 官方主力发展的虚拟机故障处理工具。&lt;/p&gt;
&lt;p&gt;VisualVM 同样在 JDK/bin 这个目录下，双击 jvisualvm.exe 即可运行。在启动之后，直接在左侧会显示当前在本机运行的所有虚拟机进程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.geekdigging.com/java/jvm/jvm4/VisualVM_1.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;VisualVM 基于 NetBeans 平台开发工具，所以一开始它就具备了通过插件扩展功能的能力，有了插件扩展支持， VisualVM 可以做到：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;显示虚拟机进程以及进程的配置、环境信息（jps、jinfo）。&lt;/li&gt;
&lt;li&gt;监视应用程序的处理器、垃圾收集、堆、方法区以及线程的信息（jstat、jstack）。&lt;/li&gt;
&lt;li&gt;dump 以及分析堆转储快照（jmap、jhat）。&lt;/li&gt;
&lt;li&gt;方法级的程序运行性能分析，找出被调用最多、运行时间最长的方法。&lt;/li&gt;
&lt;li&gt;离线程序快照：收集程序的运行时配置、线程 dump 、内存 dump 等信息建立一个快照，可以将快照发送开发者处进行 Bug 反馈。&lt;/li&gt;
&lt;li&gt;其他插件带来的无限可能性。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;VisualVM 的插件可以在 工具-&amp;gt;插件 中联网后直接安装。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.geekdigging.com/java/jvm/jvm4/VisualVM_2.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.geekdigging.com/java/jvm/jvm4/VisualVM_3.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我这里只安装了两个最常用的，一个是 GC 监控的插件，还有一个可以动态插入调试程序的插件。&lt;/p&gt;
&lt;p&gt;我这里使用最常用的开发工具 IDEA 启动过程演示一下通过 VisualVM 监控程序 GC 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.geekdigging.com/java/jvm/jvm4/idea_logo.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先我们启动 IDEA ，直到 IDEA 可以正常操作，看下 VisualVM 的 GC 监控。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.geekdigging.com/java/jvm/jvm4/VisualVM_4.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在主信息面板，可以看到 IDEA 所使用 JVM 的版本信息，可以看到具体的 JAVA_HOME 路径，还可以看到具体的 JVM 参数，这里可以看到 IDEA 启动时设置的默认最小堆和最大堆内存的设置分别是 128MB 和 750 MB ，所使用的垃圾回收器则是 CMS 收集器。&lt;/p&gt;
&lt;p&gt;然后点击 Visual GC，可以看到：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.geekdigging.com/java/jvm/jvm4/VisualVM_5.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在启动过程中， Class 加载消耗了 28s 左右，而 Class 编译则消耗了 35s 。并且在这个过程中， Minor GC 被触发了 149 次，消耗只有 713ms ，我们更加关注的 Full GC 更是一次都没有触发，消耗为 0 。&lt;/p&gt;
&lt;p&gt;因为 IDEA 默认使用的是 CMS 收集器，如果我们换成 G1 收集器会不会更快一些呢？&lt;/p&gt;
&lt;p&gt;首先，找到 IDEA 的配置文件，我的 IDEA 是通过 Toolbox 进行安装的，所以我的 IDEA 的配置文件的路径有点奇怪 &lt;code&gt;D:\Program Files\JetBrains\apps\IDEA-U\ch-0\202.7660.26.vmoptions&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;先把这个文件备份到桌面一个，防止改坏了导致 IDEA 不能使用。&lt;/p&gt;
&lt;p&gt;删掉现有的垃圾回收器配置 &lt;code&gt;-XX:+UseConcMarkSweepGC&lt;/code&gt; ，增加 G1 收集器的配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;-XX:+UseG1GC
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其余的配置不做修改，直接关闭 IDEA 重启，再看下 GC 情况。&lt;/p&gt;
&lt;p&gt;首先先看下主面板，看下我们的 GC 收集器是否已经切换成功：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.geekdigging.com/java/jvm/jvm4/VisualVM_6.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后再看下 GC 面板：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.geekdigging.com/java/jvm/jvm4/VisualVM_7.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Minor GC 竟然被触发了 271 次，而且消耗达到了 853ms ，好吧，看来在客户端还是更适合使用 CMS 做为垃圾回收器。&lt;/p&gt;
&lt;p&gt;我们再修改下 -Xmx 这个配置，将配置的大小缩减为现在的一半，再把 GC 换回原有的 CMS ，看下 Full GC 的情况：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.geekdigging.com/java/jvm/jvm4/VisualVM_8.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到， Full GC 整整发生了 46 次，并且耗时超过了 21s ，而且这是 IDEA 的界面上也开始弹出警告，警告我们内存不足了，需要调整。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.geekdigging.com/java/jvm/jvm4/idea_warning.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;吓得我赶紧改回了原有配置，顺便把 -Xmx 的大小加到了 1024 ，尽量减少 Full GC 的情况。&lt;/p&gt;
&lt;h2 id=&quot;4-java-mission-control&quot;&gt;4. Java Mission Control&lt;/h2&gt;
&lt;p&gt;JMC 同样在 JDK/bin 这个目录下，双击 jmc.exe 即可运行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.geekdigging.com/java/jvm/jvm4/JMC_1.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;打开后在 JVM 浏览器面板中有两个选项，一个是 MBean ，一个是 JFR 飞行记录器。&lt;/p&gt;
&lt;p&gt;关于 MBean 这部分数据，与 JConsole 和 VisualVM 上取到的内容是一样的，只是展示形式上有些差别，就不多说了。&lt;/p&gt;
&lt;p&gt;双击「飞行记录器」，将会出现「飞行记录器」窗口（如果第一次使用，还会收到解锁商业功能的警告窗）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.geekdigging.com/java/jvm/jvm4/JFR_1.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意：在使用前需要在 JVM 中增加如下两个参数，含义是解锁 JFR 功能的锁定。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;-XX:+UnlockCommercialFeatures
-XX:+FlightRecorder
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.geekdigging.com/java/jvm/jvm4/JFR_2.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;飞行记录报告里包含以下几类信息：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一般信息：关于虚拟机、操作系统和记录的一般信息。&lt;/li&gt;
&lt;li&gt;内存：关于内存管理和垃圾收集的信息。&lt;/li&gt;
&lt;li&gt;代码：关于方法、异常错误、编译和类加载的信息。&lt;/li&gt;
&lt;li&gt;线程：关于应用程序中线程和锁的信息。&lt;/li&gt;
&lt;li&gt;I/O：关于文件和套接字输入、输出的信息。&lt;/li&gt;
&lt;li&gt;系统：关于正在运行Java虚拟机的系统、进程和环境变量的信息。&lt;/li&gt;
&lt;li&gt;事件：关于记录中的事件类型的信息，可以根据线程或堆栈跟踪，按照日志或图形的格式查看。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;5-小结&quot;&gt;5. 小结&lt;/h2&gt;
&lt;p&gt;这 4 款可视化工具看下来，个人感觉还是最后一个 JMC 对使用者来讲最友好， MBean 数据源展示了大量的当前 JVM 的信息，而且全都以图表的形式进行了展现，更加给力还是它的 JFR 功能，可以记录一段时间内所有的操作，并且以图表的形式进行展现，对我们分析问题时候的帮助无疑是巨大的。&lt;/p&gt;
&lt;p&gt;当然，喜欢用哪款工具完全是个人喜好，比如 VisualVM 也很强大，可能它本身的功能没那么强，但是它可以安装插件，完全根据需要进行插件的安装，这个玩法非常 DIY ，总的算下来，我还是喜欢使用 VisualVM 更多一些。&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;p&gt;《深入理解Java虚拟机：JVM高级特性与最佳实践_周志明》&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/alinainai/p/11070923.html&quot;&gt;https://www.cnblogs.com/alinainai/p/11070923.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 12 Oct 2020 00:47:00 +0000</pubDate>
<dc:creator>极客挖掘机</dc:creator>
<og:description>本文内容过于硬核，建议有 Java 相关经验人士阅读。 1. 可视化工具 在 JDK 中为我们提供了大量的 JVM 故障处理工具，都在 JDK 的 bin 目录下： 这其中除了大量的命令行工具以外，还</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/babycomeon/p/13800816.html</dc:identifier>
</item>
<item>
<title>前端性能优化 - 一只菜鸟攻城狮啊</title>
<link>http://www.cnblogs.com/suihang/p/13800808.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/suihang/p/13800808.html</guid>
<description>&lt;div class=&quot;lake-engine-view lake-typography-traditional&quot; readability=&quot;72.513841143477&quot;&gt;
&lt;p data-lake-id=&quot;477d88b8d22e5679f1702872be9c8366&quot; data-wording=&quot;true&quot;&gt;&lt;span class=&quot;lake-fontsize-1515&quot;&gt;就我个人而言，性能优化分为三大主要部分，构建工具优化，&lt;span class=&quot;lake-fontsize-1515&quot;&gt;网络请求优化，&lt;span class=&quot;lake-fontsize-1515&quot;&gt;渲染优化。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-lake-id=&quot;394c564dbb2598d4a44a4250cee27dc6&quot; data-wording=&quot;true&quot;&gt;&lt;span class=&quot;lake-fontsize-1515&quot;&gt;当前前端最常使用的工具是webpack，所以我们要做的第一步就是提高他的构建效率&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;Rvmde&quot; data-lake-id=&quot;0d819ff19830cc67bad5a9f37e251ef9&quot; data-wording=&quot;true&quot;&gt;构建工具优化&lt;/h2&gt;
&lt;h3 id=&quot;wn3bR&quot; data-lake-id=&quot;3dd5892624bc50cd970cd98aa7c82186&quot; data-wording=&quot;true&quot;&gt;多进程构建&lt;/h3&gt;
&lt;p data-lake-id=&quot;e6533116111cd759e9cce663f389f783&quot; data-wording=&quot;true&quot;&gt;&lt;span class=&quot;lake-fontsize-1515&quot;&gt;webpack 是单线程的，就算此刻存在多个任务，你也只能排队一个接一个地等待处理。这是 webpack 的缺点，好在我们的 CPU 是多核的，Happypack 会充分释放 CPU 在多核并发方面的优势，帮我们把任务分解给多个子进程去并发执行，大大提升打包效率。&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;jmLSO&quot; data-lake-id=&quot;83a15a986373c073e441343d526cf2e5&quot; data-wording=&quot;true&quot;&gt;使用DllPlugin处理第三方库&lt;/h3&gt;
&lt;p data-lake-id=&quot;33fdc338fe091b655968ad4c14b8abe4&quot; data-wording=&quot;true&quot;&gt;&lt;span class=&quot;lake-fontsize-1515&quot;&gt;DllPlugin 是基于 Windows 动态链接库（dll）的思想被创作出来的。这个插件会把第三方库单独打包到一个文件中，这个文件就是一个单纯的依赖库。&lt;span class=&quot;lake-fontsize-1515&quot;&gt;&lt;strong&gt;这个依赖库不会跟着你的业务代码一起被重新打包，只有当依赖自身发生版本变化时才会重新打包。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;WOHyk&quot; data-lake-id=&quot;fb20b696a386eaa4a124198986d32dbe&quot; data-wording=&quot;true&quot;&gt;删除冗余代码&lt;/h3&gt;
&lt;h4 id=&quot;UQn5W&quot; data-lake-id=&quot;816a7652f038ff7f4698372cf11b7e89&quot; data-wording=&quot;true&quot;&gt;利用Tree-Shaking去除没被使用的模块&lt;/h4&gt;
&lt;p data-lake-id=&quot;42a88e5af95f3c485d4753ef10726516&quot; data-wording=&quot;true&quot;&gt;&lt;span class=&quot;lake-fontsize-1515&quot;&gt;Tree-Shaking&lt;span class=&quot;lake-fontsize-1515&quot;&gt;基于 import/export 语法，Tree-Shaking 可以在编译的过程中获悉哪些&lt;span class=&quot;lake-fontsize-1515&quot;&gt;&lt;strong&gt;模块&lt;/strong&gt;&lt;span class=&quot;lake-fontsize-1515&quot;&gt;并没有真正被使用，这些没用的代码，在最后打包的时候会被去除。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;uBI1T&quot; data-lake-id=&quot;e702b5b1bbf0674151a879743464a855&quot; data-wording=&quot;true&quot;&gt;利用UglifyJsPlugin在压缩过程中对碎片化的冗余代码进行自动删除&lt;/h4&gt;
&lt;p data-lake-id=&quot;78081b595038260df44ec98014358513&quot; data-wording=&quot;true&quot;&gt;手动引入 UglifyJsPlugin 的代码其实是 webpack3 的用法，webpack4 现在已经默认使用 uglifyjs-webpack-plugin 对代码做压缩了——在 webpack4 中，我们是通过配置 optimization.minimize 与 optimization.minimizer 来自定义压缩相关的操作的。&lt;/p&gt;
&lt;h3 id=&quot;ZRQ1u&quot; data-lake-id=&quot;91e0458e0c3b0db521ef661729e2b4d5&quot; data-wording=&quot;true&quot;&gt;按需加载&lt;/h3&gt;
&lt;p data-lake-id=&quot;aa7deda21d5f8547449d8d804dfda144&quot; data-wording=&quot;true&quot;&gt;使用 &lt;span class=&quot;lake-fontsize-1515&quot;&gt;React-Router来实现组件按需加载&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;8CPbo&quot; data-lake-id=&quot;84108063ccb64a141048d0ca9af70fe4&quot; data-wording=&quot;true&quot;&gt;分析构建结果进行体积压缩&lt;/h3&gt;
&lt;p data-lake-id=&quot;8b0d9fb05ed64f5f95d5606487e74078&quot; data-wording=&quot;true&quot;&gt;&lt;span class=&quot;lake-fontsize-1515&quot;&gt;使用&lt;a href=&quot;https://www.npmjs.com/package/webpack-bundle-analyzer&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;span class=&quot;lake-fontsize-1515&quot;&gt;webpack-bundle-analyzer&lt;/span&gt;&lt;/a&gt;&lt;span class=&quot;lake-fontsize-1515&quot;&gt;插件&lt;span class=&quot;lake-fontsize-1515&quot;&gt;，它会以矩形树图的形式将包内各个模块的大小和依赖关系呈现出来，使&lt;span class=&quot;lake-fontsize-1515&quot;&gt;文件结构可视化，找出导致体积过大的原因。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;LxSmY&quot; data-lake-id=&quot;d81e7c36aa855484f3c36cf2fc2f2fb4&quot; data-wording=&quot;true&quot;&gt;网络请求优化&lt;/h2&gt;
&lt;p data-lake-id=&quot;0a662cf2fd7868c2675b03f2f432dee5&quot; data-wording=&quot;true&quot;&gt;&lt;span class=&quot;lake-fontsize-1515&quot;&gt;通过两个大方面来进行优化&lt;/span&gt;&lt;/p&gt;
&lt;ul data-lake-id=&quot;1bdc69c7abe091bb404b528c5105bea0&quot;&gt;&lt;li data-lake-id=&quot;131c840c5243b5f4fbd26b3ef986aea5&quot; data-wording=&quot;true&quot;&gt;&lt;span class=&quot;lake-fontsize-1515&quot;&gt;减小请求体积&lt;/span&gt;&lt;/li&gt;
&lt;li data-lake-id=&quot;32ed74c0849987ca8e4c2e4689e86219&quot; data-wording=&quot;true&quot;&gt;&lt;span class=&quot;lake-fontsize-1515&quot;&gt;减少网络请求&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;izxbM&quot; data-lake-id=&quot;a4840f137c32053b381982c736c00d4c&quot; data-wording=&quot;true&quot;&gt;减小请求体积&lt;/h3&gt;
&lt;p data-lake-id=&quot;9d4c8c9e9491bcbf05270415409badee&quot; data-wording=&quot;true&quot;&gt;&lt;span class=&quot;lake-fontsize-1515&quot;&gt;关于减少请求体积，在上面webpack中已经都基本包含了，另外，还可以开启Gzip压缩来进一步缩小体积&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;rKGLN&quot; data-lake-id=&quot;bda0224bbca909224bf38f055e666d7a&quot; data-wording=&quot;true&quot;&gt;开启Gzip压缩&lt;/h4&gt;
&lt;p data-lake-id=&quot;edfe489f18526fbfaf0b5fffe416ee0a&quot; data-wording=&quot;true&quot;&gt;&lt;span class=&quot;lake-fontsize-1515&quot;&gt;只需要你在你的 request headers 加上accept-encoding:gzip&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;7JHEC&quot; data-lake-id=&quot;90d7c6d2a2618211e600f30371a7fd01&quot; data-wording=&quot;true&quot;&gt;将静态资源放到CDN&lt;/h4&gt;
&lt;p data-lake-id=&quot;dfcc7b5933223066e6e7d35c841ddce9&quot; data-wording=&quot;true&quot;&gt;将静态资源放到CDN以提升访问速度&lt;/p&gt;
&lt;h4 id=&quot;YfV3l&quot; data-lake-id=&quot;5c86ca6129bed8de37e001dc9d462793&quot; data-wording=&quot;true&quot;&gt;合理的处理图片&lt;/h4&gt;
&lt;p data-lake-id=&quot;3b2430b613724922c83406a7dcb9ecd9&quot; data-wording=&quot;true&quot;&gt;&lt;span class=&quot;lake-fontsize-1515&quot;&gt;在合适的场景下选择合适的图片格式&lt;/span&gt;&lt;/p&gt;
&lt;ul data-lake-id=&quot;df819ae72619560dd6fe693375a9718d&quot;&gt;&lt;li data-lake-id=&quot;d703fbbe27dbe78913fbe6a7df6fb271&quot; data-wording=&quot;true&quot;&gt;&lt;span class=&quot;lake-fontsize-1515&quot;&gt;&lt;strong&gt;JPEG/JPG：&lt;/strong&gt;&lt;span class=&quot;lake-fontsize-1515&quot;&gt;&lt;strong&gt;有损压缩、体积小、加载快、不支持透明，适用于轮播图等大图片。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li data-lake-id=&quot;6b45d1f2e0ed9d54f96523b44ec0bd15&quot; data-wording=&quot;true&quot;&gt;&lt;span class=&quot;lake-fontsize-1515&quot;&gt;&lt;strong&gt;PNG：&lt;/strong&gt;&lt;span class=&quot;lake-fontsize-1515&quot;&gt;&lt;strong&gt;无损压缩、质量高、体积大、支持透明，适用于&lt;/strong&gt;&lt;span class=&quot;lake-fontsize-1515&quot;&gt;&lt;strong&gt;呈现小的 Logo、颜色简单且对比强烈的图片或背景等。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li data-lake-id=&quot;7752b7275dd606809edd9425fdde39ee&quot; data-wording=&quot;true&quot;&gt;&lt;span class=&quot;lake-fontsize-1515&quot;&gt;&lt;strong&gt;SVG：&lt;/strong&gt;&lt;span class=&quot;lake-fontsize-1515&quot;&gt;&lt;strong&gt;文本文件、体积小、不失真、兼容性好，&lt;/strong&gt;&lt;span class=&quot;lake-fontsize-1515&quot;&gt;&lt;strong&gt;图片可无限放大而不失真。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li data-lake-id=&quot;37b0b4ec75a5887b9caa09262012cd22&quot; data-wording=&quot;true&quot;&gt;&lt;span class=&quot;lake-fontsize-1515&quot;&gt;&lt;strong&gt;Base64：&lt;/strong&gt;&lt;span class=&quot;lake-fontsize-1515&quot;&gt;&lt;strong&gt;文本文件、依赖编码、小图标解决方案&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li data-lake-id=&quot;ca7c0c0722f1868632bcdc08d04f2c6f&quot; data-wording=&quot;true&quot;&gt;&lt;span class=&quot;lake-fontsize-1515&quot;&gt;&lt;strong&gt;WebP：支持透明，可展示动图，兼容性差。&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;cSvul&quot; data-lake-id=&quot;5c85bf8d918510c1f14be7b1acd31fdd&quot; data-wording=&quot;true&quot;&gt;减少网络请求&lt;/h3&gt;
&lt;h4 id=&quot;9ImG8&quot; data-lake-id=&quot;1d566222361313541a4bf7b872b42c71&quot; data-wording=&quot;true&quot;&gt;CSS精灵图&lt;/h4&gt;
&lt;p data-lake-id=&quot;34f8801695060f902227fb8645edab1b&quot; data-wording=&quot;true&quot;&gt;&lt;span class=&quot;lake-fontsize-1515&quot;&gt;将多个图标放在一张图片上，通过定位使用对应的图标，从而减少请求次数&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;zcfqh&quot; data-lake-id=&quot;4b219410be0899c9b1d19d7f2bbe7437&quot; data-wording=&quot;true&quot;&gt;使用Base64图片&lt;/h4&gt;
&lt;p data-lake-id=&quot;9e77fc0134e2664055f58f5fcd00802e&quot; data-wording=&quot;true&quot;&gt;&lt;span class=&quot;lake-fontsize-1515&quot;&gt;Base64可以直接将小图标写在代码中，从而减少图标请求。&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;rbaG0&quot; data-lake-id=&quot;c4f3f6cd86da54c5769ac1afe5c89bdc&quot; data-wording=&quot;true&quot;&gt;合理的使用缓存&lt;/h4&gt;
&lt;p data-lake-id=&quot;f42dacfd55770c2192a8b8df36d0efca&quot; data-wording=&quot;true&quot;&gt;&lt;span class=&quot;lake-fontsize-1515&quot;&gt;通过网络获取内容既速度缓慢又开销巨大。较大的响应需要在客户端与服务器之间进行多次往返通信，这会延迟浏览器获得和处理内容的时间，还会增加访问者的流量费用。因此，缓存并重复利用之前获取的资源的能力成为性能优化的一个关键方面。缓存详解请看我之前的文章&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p data-lake-id=&quot;94728b17625118c05dc14c90bd1296c8&quot; data-wording=&quot;true&quot;&gt;&lt;a href=&quot;https://www.yuque.com/suihangadam/liulanqi/gcmgi4#AA3sg&quot; target=&quot;_blank&quot;&gt;https://www.yuque.com/suihangadam/liulanqi/gcmgi4#AA3sg&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;JkstX&quot; data-lake-id=&quot;fd0acf8cd00f5cc12d69551b81617ebb&quot; data-wording=&quot;true&quot;&gt;渲染优化&lt;/h2&gt;
&lt;p data-lake-id=&quot;a18118dd1bc4f59b973580a7320f394b&quot; data-wording=&quot;true&quot;&gt;渲染方面主要有三个优化方面&lt;/p&gt;
&lt;ul data-lake-id=&quot;463647d86453626b6ba4b85fe68785b4&quot;&gt;&lt;li data-lake-id=&quot;4a720fcc6f2cd11b15981b307ef79101&quot; data-wording=&quot;true&quot;&gt;服务端渲染&lt;/li&gt;
&lt;li data-lake-id=&quot;d734b2302bd9663d9afc17de1e631e5a&quot; data-wording=&quot;true&quot;&gt;CSS优化&lt;/li&gt;
&lt;li data-lake-id=&quot;f12c414c40349217a0ae16b8cb74ff87&quot; data-wording=&quot;true&quot;&gt;JS优化&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;Meuds&quot; data-lake-id=&quot;c845addb2a3547fc6e1e0070a7816421&quot; data-wording=&quot;true&quot;&gt;SSR服务端渲染&lt;/h3&gt;
&lt;p data-lake-id=&quot;4ad6753eabff67c195234d75399080c8&quot; data-wording=&quot;true&quot;&gt;&lt;span class=&quot;lake-fontsize-1515&quot;&gt;使用SSR服务端渲染减少首屏白屏的时间，但是他并不是银弹，因为他将原本分散在客户端的压力全都聚集到了服务器，在服务器性能低下时，很可能会得不尝失。&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;JiNJu&quot; data-lake-id=&quot;c862bf71b9bc64cd4719416a8d18e246&quot; data-wording=&quot;true&quot;&gt;CSS优化&lt;/h3&gt;
&lt;h4 id=&quot;j5jHh&quot; data-lake-id=&quot;000c6c734f4d42a897003e00613bd24f&quot; data-wording=&quot;true&quot;&gt;CSS选择器优化&lt;/h4&gt;
&lt;p data-lake-id=&quot;338b9fec064ec7f717bd3c64e07dd17e&quot; data-wording=&quot;true&quot;&gt;&lt;span class=&quot;lake-fontsize-1515&quot;&gt;由于CSS选择器是从右向左匹配的，所以我们可以做如下几条优化&lt;/span&gt;&lt;/p&gt;
&lt;ul data-lake-id=&quot;5fc8411d78f9f67ec105239c71e02992&quot;&gt;&lt;li data-lake-id=&quot;44108561cf3d83cf1f707963b4a6c3b2&quot; data-wording=&quot;true&quot;&gt;&lt;span class=&quot;lake-fontsize-1515&quot;&gt;避免使用通配符，只对需要用到的元素进行选择。,因为他会将所有元素全匹配一遍&lt;/span&gt;&lt;/li&gt;
&lt;li data-lake-id=&quot;135e46a96477f4e0b14ee95fc74a9a1b&quot; data-wording=&quot;true&quot;&gt;&lt;span class=&quot;lake-fontsize-1515&quot;&gt;少用标签选择器。如果可以，用类选择器替代&lt;br/&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li data-lake-id=&quot;a6a758b10e650691e1e7b950191b0b3c&quot; data-wording=&quot;true&quot;&gt;&lt;span class=&quot;lake-fontsize-1515&quot;&gt;减少嵌套。后代选择器的开销是最高的，因此我们应该尽量将选择器的深度降到最低（最高不要超过三层），尽可能使用类来关联每一个标签元素。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;ja7Ai&quot; data-lake-id=&quot;0359fe54192d89f076c88abcaeacd45f&quot; data-wording=&quot;true&quot;&gt;CSS加载顺序优化&lt;/h4&gt;
&lt;p data-lake-id=&quot;ed072a075c422bf93d3c01b5c1e872af&quot; data-wording=&quot;true&quot;&gt;由于CSS会阻碍页面渲染，所以需要尽量的将CSS前置。&lt;/p&gt;
&lt;h3 id=&quot;uqGRm&quot; data-lake-id=&quot;d722327072cc21cb74bf621e5d429d8e&quot; data-wording=&quot;true&quot;&gt;JS优化&lt;/h3&gt;
&lt;p data-lake-id=&quot;accab9775230bee49a5d85cc1a444fdd&quot; data-wording=&quot;true&quot;&gt;&lt;span class=&quot;lake-fontsize-1515&quot;&gt;主要的优化方面在于减少回流重绘&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;rTv5d&quot; data-lake-id=&quot;3bbc2d64dd99069359a7cecab2daf551&quot; data-wording=&quot;true&quot;&gt;用async和defer合理的选择JS的加载时机&lt;/h4&gt;
&lt;ul data-lake-id=&quot;30b3a57cdd54684ff7f0f70b18dbb08a&quot;&gt;&lt;li data-lake-id=&quot;7b4253ce776a2384e73c481dec0e0142&quot; data-wording=&quot;true&quot;&gt;&lt;span class=&quot;lake-fontsize-1515&quot;&gt;在正常模式下，js&lt;span class=&quot;lake-fontsize-1515&quot;&gt;会阻塞浏览器，浏览器必须等待js 加载和执行完毕才能去做其它事情。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li data-lake-id=&quot;4c17e85fd061ebbd5ccfcf7143813994&quot; data-wording=&quot;true&quot;&gt;&lt;span class=&quot;lake-fontsize-1515&quot;&gt;async 模式下，JS 不会阻塞浏览器做任何其它的事情。它的加载是异步的，当它加载结束，JS 脚本会&lt;span class=&quot;lake-fontsize-1515&quot;&gt;&lt;strong&gt;立即执行&lt;/strong&gt;&lt;span class=&quot;lake-fontsize-1515&quot;&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li data-lake-id=&quot;4a0e48e37a6555607534a6f8f8748e89&quot; data-wording=&quot;true&quot;&gt;&lt;span class=&quot;lake-fontsize-1515&quot;&gt;defer 模式下，JS 的加载是异步的，执行是&lt;span class=&quot;lake-fontsize-1515&quot;&gt;&lt;strong&gt;被推迟的&lt;/strong&gt;&lt;span class=&quot;lake-fontsize-1515&quot;&gt;。等整个文档解析完成、DOMContentLoaded 事件即将被触发时，被标记了 defer 的 JS 文件才会开始依次执行。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-lake-id=&quot;563c25d72ce1d6de64f0386b1d2b941e&quot; data-wording=&quot;true&quot;&gt;&lt;span class=&quot;lake-fontsize-1515&quot;&gt;当脚本与 DOM 元素和其它脚本之间的依赖关系不强时，选用 async；当脚本依赖于 DOM 元素和其它脚本的执行结果时，选用 def&lt;span class=&quot;lake-fontsize-1515&quot;&gt;er。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;e0Pfy&quot; data-lake-id=&quot;61486c38dc4337255140ba0483271fdc&quot; data-wording=&quot;true&quot;&gt;减少回流重绘&lt;/h4&gt;
&lt;ul data-lake-id=&quot;0cf12b3ba6ada03f46f930fd2354c9a0&quot;&gt;&lt;li data-lake-id=&quot;d744eabc79201bff1f54f87441440e6e&quot; data-wording=&quot;true&quot;&gt;&lt;strong&gt;&lt;span class=&quot;lake-fontsize-1515&quot;&gt;合并多次DOM操作&lt;/span&gt;&lt;/strong&gt;&lt;span class=&quot;lake-fontsize-1515&quot;&gt;，尽量将多次DOM操作合并成一次，减少回流或者重绘的性能。例如使用&lt;span class=&quot;lake-fontsize-1515&quot;&gt;DocumentFragment或者innerHTML&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li data-lake-id=&quot;98e83d8716125181f4b24d4df32e074e&quot; data-wording=&quot;true&quot;&gt;&lt;span class=&quot;lake-fontsize-1515&quot;&gt;&lt;strong&gt;DOM离线化&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li data-lake-id=&quot;b0bfcf79807e2ee85d4b98acd10a2f99&quot; data-wording=&quot;true&quot;&gt;&lt;strong&gt;&lt;span class=&quot;lake-fontsize-1515&quot;&gt;使用类名去合并样式，&lt;/span&gt;&lt;/strong&gt;而不要一条条的修改&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;NW54Y&quot; data-lake-id=&quot;65e421af5b3f14f81b51cf75149e9482&quot; data-wording=&quot;true&quot;&gt;懒加载&lt;/h4&gt;
&lt;p data-lake-id=&quot;cb0924980381bef0d7645bf9767fd988&quot; data-wording=&quot;true&quot;&gt;利用元素占位，只有当图片到了可视区域内再去拉取图片。&lt;/p&gt;
&lt;h4 id=&quot;eRIt1&quot; data-lake-id=&quot;6b9d9fd4f25784aa67d3ce48de7a73b2&quot; data-wording=&quot;true&quot;&gt;防抖节流&lt;/h4&gt;
&lt;p data-lake-id=&quot;599652588ecf61ffe44409ac9f7bd505&quot; data-wording=&quot;true&quot;&gt;利用防抖节流来减少某些高频事件触发的次数&lt;/p&gt;
&lt;p data-lake-id=&quot;16c65d0ca8b3d424bd26c7f329a2128a&quot;&gt; &lt;/p&gt;
&lt;blockquote readability=&quot;1.3333333333333&quot;&gt;
&lt;p data-lake-id=&quot;ee64c57056c01fd95e491c4213263021&quot; data-wording=&quot;true&quot;&gt;参考自：&lt;a href=&quot;https://juejin.im/book/6844733750048210957&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;前端性能优化原理与实践&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
</description>
<pubDate>Mon, 12 Oct 2020 00:45:00 +0000</pubDate>
<dc:creator>一只菜鸟攻城狮啊</dc:creator>
<og:description>就我个人而言，性能优化分为三大主要部分，构建工具优化，网络请求优化，渲染优化。 当前前端最常使用的工具是webpack，所以我们要做的第一步就是提高他的构建效率 构建工具优化 多进程构建 webpac</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/suihang/p/13800808.html</dc:identifier>
</item>
<item>
<title>JavaCV FFmpeg H264编码 - HiIT青年</title>
<link>http://www.cnblogs.com/itqn/p/13797243.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/itqn/p/13797243.html</guid>
<description>&lt;p&gt;上次成功通过FFmpeg采集摄像头的YUV数据，这次针对上一次的程序进行了改造，使用H264编码采集后的数据。&lt;/p&gt;
&lt;p&gt;(传送门) &lt;a href=&quot;https://www.cnblogs.com/itqn/p/13789079.html&quot;&gt;JavaCV FFmpeg采集摄像头YUV数据&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;采集摄像头数据是一个解码过程，而将采集后的数据进行H264编码则是编码过程，如图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2083963/202010/2083963-20201011103416657-1015041119.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;从上图可以看出，编码过程，数据流是从AVFrame流向AVPacket，而解码过程正好相反，数据流是从AVPacket流向AVFrame。&lt;/p&gt;
&lt;p&gt;javacpp-ffmpeg依赖：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.bytedeco.javacpp-presets&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;ffmpeg&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;${ffmpeg.version}&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;FFmpeg编码的过程是解码的逆过程，不过主线流程是类似的，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2083963/202010/2083963-20201011112313775-1458162758.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;基本上主要的步骤都是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;查找编码/解码器&lt;/li&gt;
&lt;li&gt;打开编码/解码器&lt;/li&gt;
&lt;li&gt;进行编码/解码&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在FFmpeg的demo流程中其实还有创建流&lt;code&gt;avformat_new_stream()&lt;/code&gt;，写入头部信息&lt;code&gt;avformat_write_header()&lt;/code&gt;和尾部信息&lt;code&gt;av_write_trailer()&lt;/code&gt;等操作，这里只是将YUV数据编码成H264裸流，所以可以暂时不需要考虑这些操作。&lt;/p&gt;
&lt;p&gt;将采集视频流数据进行H264编码的整体流程主要有以下几个步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;采集视频帧&lt;/li&gt;
&lt;li&gt;将视频帧转化为YUV420P格式&lt;/li&gt;
&lt;li&gt;构建H264编码器&lt;/li&gt;
&lt;li&gt;对视频帧进行编码&lt;/li&gt;
&lt;/ol&gt;&lt;h5 id=&quot;采集视频帧&quot;&gt;采集视频帧&lt;/h5&gt;
&lt;p&gt;采集视频流中的视频帧在上一次采集YUV数据的时候已经实现了，主要是从AVFormatContext中用&lt;code&gt;av_read_frame()&lt;/code&gt;读取视频数据并进行解码（&lt;code&gt;avcodec_decode_video2()&lt;/code&gt;），实现代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public AVFrame grab() throws FFmpegException {
    if (av_read_frame(pFormatCtx, pkt) &amp;gt;= 0 &amp;amp;&amp;amp; pkt.stream_index() == videoIdx) {
        ret = avcodec_decode_video2(pCodecCtx, pFrame, got, pkt);
        if (ret &amp;lt; 0) {
            throw new FFmpegException(ret, &quot;avcodec_decode_video2 解码失败&quot;);
        }
        if (got[0] != 0) {
            return videoConverter.scale(pFrame);
        }
        av_packet_unref(pkt);
    }
    return null;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样通过grab()方法就可以获取到视频流中的视频帧了。&lt;/p&gt;
&lt;h5 id=&quot;将视频帧转化为yuv420p格式&quot;&gt;将视频帧转化为YUV420P格式&lt;/h5&gt;
&lt;p&gt;在进行H264编码之前一定要确保视频帧是YUV420P格式的，所以必须对采集到的视频帧做一次转化，用到的是FFmpeg的&lt;code&gt;SwsContext&lt;/code&gt;组件，下面的&lt;code&gt;VideoConverter&lt;/code&gt;是对&lt;code&gt;SwsContext&lt;/code&gt;封装的组件，内部实现了AVFrame的填充及&lt;code&gt;SwsContext&lt;/code&gt;的初始化，使用方式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 1. 创建VideoConverter，指定转化格式为AV_PIX_FMT_YUV420P
videoConverter = VideoConverter.create(videoWidth, videoHeight, pCodecCtx.pix_fmt(), 
    videoWidth, videoHeight, AV_PIX_FMT_YUV420P);
// 2. 对视频帧进行转化
videoConverter.scale(pFrame);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;VideoConvert的scale方式，实际上也是调用了SwsContext的scale方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;sws_scale(swsContext, new PointerPointer&amp;lt;&amp;gt;(pFrame), pFrame.linesize(), 
    0, srcSliceH, new PointerPointer&amp;lt;&amp;gt;(avFrame), avFrame.linesize());
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;构建h264编码器&quot;&gt;构建H264编码器&lt;/h5&gt;
&lt;p&gt;进行H264编码之前需要构建H264编码器，根据上面的流程图利用&lt;code&gt;avcodec_find_encoder()&lt;/code&gt;和&lt;code&gt;avcodec_alloc_context3()&lt;/code&gt;实现编码器的创建和参数配置，最后用&lt;code&gt;avcodec_open()&lt;/code&gt;打开编码器，完整的初始化代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static VideoH264Encoder create(int width, int height, int fps, Map&amp;lt;String, String&amp;gt; opts)
        throws FFmpegException {
    VideoH264Encoder h = new VideoH264Encoder();
    // 查找H264编码器
    h.pCodec = avcodec_find_encoder(AV_CODEC_ID_H264);
    if (h.pCodec == null) {
        throw new FFmpegException(&quot;初始化 AV_CODEC_ID_H264 编码器失败&quot;);
    }
    // 初始化编码器信息
    h.pCodecCtx = avcodec_alloc_context3(h.pCodec);
    h.pCodecCtx.codec_id(AV_CODEC_ID_H264);
    h.pCodecCtx.codec_type(AVMEDIA_TYPE_VIDEO);
    h.pCodecCtx.pix_fmt(AV_PIX_FMT_YUV420P);
    h.pCodecCtx.width(width);
    h.pCodecCtx.height(height);
    h.pCodecCtx.time_base().num(1);
    h.pCodecCtx.time_base().den(fps);
    // 其他参数设置
    AVDictionary dictionary = new AVDictionary();
    opts.forEach((k, v) -&amp;gt; {
        avutil.av_dict_set(dictionary, k, v, 0);
    });
    h.ret = avcodec_open2(h.pCodecCtx, h.pCodec, dictionary);
    if (h.ret &amp;lt; 0) {
        throw new FFmpegException(h.ret, &quot;avcodec_open2 编码器打开失败&quot;);
    }
    h.pkt = new AVPacket();
    return h;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;参数说明&lt;br/&gt;width：视频的宽度&lt;br/&gt;height：视频的高度&lt;br/&gt;fps：视频的帧率&lt;br/&gt;opts：编码器的其他参数设置&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;对视频帧进行编码&quot;&gt;对视频帧进行编码&lt;/h5&gt;
&lt;p&gt;编码器构建完成后就可以对视频帧进行编码了，入参为AVFrame，出参为byte[]（这里也可以是AVPacket，由于需要将H264裸流写入文件，这里直接返回byte数组）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public byte[] encode(AVFrame avFrame) throws FFmpegException {
    if (avFrame == null) {
        return null;
    }
    byte[] bf = null;
    try {
        avFrame.format(pCodecCtx.pix_fmt());
        avFrame.width(pCodecCtx.width());
        avFrame.height(pCodecCtx.height());
        ret = avcodec_encode_video2(pCodecCtx, pkt, avFrame, got);
        if (ret &amp;lt; 0) {
            throw new FFmpegException(ret, &quot;avcodec_encode_video2 编码失败&quot;);
        }
        if (got[0] != 0) {
            bf = new byte[pkt.size()];
            pkt.data().get(bf);
        }
        av_packet_unref(pkt);
    } catch (Exception e) {
        throw new FFmpegException(e.getMessage());
    }
    return bf;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后只需要调整一下上一次的主程序，将读取YUV数据的部分，调整为将AVFrame丢进编码器，拉取byte数组即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static void main(String[] args) throws FFmpegException, IOException, InterruptedException {
    int fps = 25;
    avdevice_register_all();
    av_register_all();

    VideoGrabber g = new VideoGrabber();
    g.open(&quot;Integrated Camera&quot;);
    VideoH264Encoder encoder = VideoH264Encoder.create(g.getVideoWidth(), g.getVideoHeight(), fps);
    OutputStream fos = new FileOutputStream(&quot;yuv420p.h264&quot;);
    for (int i = 0; i &amp;lt; 200; i++) {
        AVFrame avFrame = g.grab();
        byte[] buf = encoder.encode(avFrame);
        if (buf != null) {
            fos.write(buf);
        }
        Thread.sleep(1000 / fps);
    }
    fos.flush();
    fos.close();
                
    encoder.release();
    g.close();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终采集效果（H264裸流）可以用VLC播放：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2083963/202010/2083963-20201011135753095-1560866461.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这里对比一下&lt;/strong&gt;，同样的200帧YUV数据和H264数据的大小，相差还是很大的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2083963/202010/2083963-20201011135934803-2010197156.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;=========================================================&lt;br/&gt;H264编码源码可&lt;strong&gt;关注&lt;/strong&gt;公众号 “HiIT青年” 发送 “ffmpeg-h264” 获取。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/itqn/1797476/o_200702010008qrcode.jpg&quot; alt=&quot;HiIT青年&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;strong&gt;关注公众号&lt;/strong&gt;，阅读更多文章。&lt;/p&gt;
</description>
<pubDate>Mon, 12 Oct 2020 00:41:00 +0000</pubDate>
<dc:creator>HiIT青年</dc:creator>
<og:description>上次成功通过FFmpeg采集摄像头的YUV数据，这次针对上一次的程序进行了改造，使用H264编码采集后的数据。 (传送门) JavaCV FFmpeg采集摄像头YUV数据 采集摄像头数据是一个解码过程</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/itqn/p/13797243.html</dc:identifier>
</item>
<item>
<title>钱被扣走了，但是订单却未成功！支付掉单异常最全解决方案 - 楼下小黑哥</title>
<link>http://www.cnblogs.com/goodAndyxublog/p/13800796.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/goodAndyxublog/p/13800796.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;好了，回归到今天的主题，今天分享一下支付系统中异常一些处理方式。&lt;/p&gt;
&lt;p&gt;其实这些处理方式并不只是局限于支付系统，也可以适用于其他系统，大家可以借鉴，应用到自己系统中，提高自己系统的健壮性。&lt;/p&gt;
&lt;p&gt;异常是系统运行不可避免会发生的问题，如果一切都正常，我们的系统设计将会相当简单。&lt;/p&gt;
&lt;p&gt;但是可惜没有人能做到这一点，所以为了处理异常可能导致的问题，我们不得不需要加上很多额外的设计，用来应对这些异常。&lt;/p&gt;
&lt;p&gt;可以说系统设计中，异常处理需要我们着重思考，将会占据我们大部分的精力。&lt;/p&gt;
&lt;p&gt;下面我们先来看下支付系统中最常见的异常：&lt;strong&gt;掉单&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5.5384615384615&quot;&gt;
&lt;p&gt;欢迎关注我的公众号：程序通事，获得日常干货推送。如果您对我的专题内容感兴趣，也可以关注我的博客：&lt;a href=&quot;https://studyidea.cn&quot;&gt;studyidea.cn&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;掉单异常&quot;&gt;掉单异常&lt;/h2&gt;
&lt;p&gt;一个最常见的支付平台架构关系如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202010/1419561-20201012083859085-1227418818.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;上图我们是站在第三方支付公司支付角度，如果是自己公司的内部支付系统，那么外部商户这一块其实就是公司内部一些系统，比如说订单系统，而外部支付渠道其实就是第三方支付公司&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们以携程为例，在其上面发起一笔订单支付，将会经过三个系统：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;携程创建订单，向第三方支付公司发起支付请求&lt;/li&gt;
&lt;li&gt;第三方支付公司创建订单，并向工行发起支付请求&lt;/li&gt;
&lt;li&gt;工行完成扣款操作，返回第三方支付公司&lt;/li&gt;
&lt;li&gt;第三方支付完成订单更新并返回携程&lt;/li&gt;
&lt;li&gt;携程变更订单状态&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;上面的流程，简单如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202010/1419561-20201012083859313-868801941.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这个过程就可能会碰到，用户工行卡已经扣款，但是携程订单却还是待支付，我们通常将这种情况称为&lt;strong&gt;掉单&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;上述掉单的场景，多数是因为&lt;strong&gt;③、⑤&lt;/strong&gt;环节信息丢失导致，这种掉单我们将其称为&lt;strong&gt;外部掉单&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;还有一种极少数的情况，收到 &lt;strong&gt;③、⑤&lt;/strong&gt;环节返回信息，但是在&lt;strong&gt;④、⑥&lt;/strong&gt;环节内部系统更新订单状态失败，从而导致丢失支付成功的信息，这类掉单由于是内部问题，我们通常将其称之为&lt;strong&gt;内部掉单&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;外部掉单&quot;&gt;外部掉单&lt;/h2&gt;
&lt;p&gt;外部掉单是因为没有收到对端返回信息，这种情况极有可能是网络问题，也有可能对端处理逻辑太慢，导致我方请求超时，直接断开了网络请求。&lt;/p&gt;
&lt;h3 id=&quot;增加超时时间&quot;&gt;增加超时时间&lt;/h3&gt;
&lt;p&gt;对于这种情况，第一个最简单的解决办法，&lt;strong&gt;适当的增加超时时间&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;不过这里需要注意了，在我们增加网络超时时间之后，我们可能还需要调整整个链路的超时时间，不然有可能导致整个链路内部差事从而引起内部掉单。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;画外音：对接外部渠道，一定要&lt;strong&gt;设置网络连接超时时间与读取超时时间&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;接收异步通知&quot;&gt;接收异步通知&lt;/h3&gt;
&lt;p&gt;第二个办法，接收渠道异步回执通知信息。&lt;/p&gt;
&lt;p&gt;一般来说，现在支付渠道接口我们都可以上送一个异步回调地址，当渠道端处理成功，将会把成功信息通知到这个回调地址上。&lt;/p&gt;
&lt;p&gt;这种情况下，我们只需要接收通知信息，然后解析，再更新内部订单状态。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202010/1419561-20201012083859492-1898161292.jpg&quot; alt=&quot;支付系统异常处理-支付异步通知&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这种情况下，我们需要注意几点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;对于异步请求信息，一定需要对通知内容进行签名验证，并校验返回的订单金额是否与商户侧的订单金额一致，防止数据泄漏导致出现“假通知”，造成资金损失。&lt;/li&gt;
&lt;li&gt;异步通知将会发送多次，所以异步通知处理需要幂等。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;掉单查询&quot;&gt;掉单查询&lt;/h3&gt;
&lt;p&gt;有的渠道可能没有提供异步通知的功能，只提供了订单查询的接口，这种情况下，我们只能使用第三种解决办法，定时掉单查询。&lt;/p&gt;
&lt;p&gt;我们可以将这类超时未知的订单的单独保存到掉单表，然后定时向渠道端查询订单的状态。&lt;/p&gt;
&lt;p&gt;若查询成功或者明确失败（比如订单不存在等），可以更新订单状态，并且删除掉单表记录。&lt;/p&gt;
&lt;p&gt;若查询依旧未知，这时我们需要等待下次查询的结果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202010/1419561-20201012083859615-1762843903.jpg&quot; alt=&quot;支付系统异常处理-定时查询&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里我们需要注意了，有些情况下，有可能无法查询返回订单的状态，所以我们需要设置订单查询的最大次数，防止无限查询浪费性能。&lt;/p&gt;
&lt;h3 id=&quot;对账&quot;&gt;对账&lt;/h3&gt;
&lt;p&gt;最后，极少数的情况下，订单查询与异步通知都无法获取的支付结果，这就还剩下最后一种兜底的解决办法，对账。&lt;/p&gt;
&lt;p&gt;如果第二天渠道端给的对账文件有这一笔支付结果，那么我们可以根据这个记录更新直接更新我们内部支付记录。&lt;/p&gt;
&lt;p&gt;之前小黑哥写过一篇对账文章，感兴趣的可以再看一下：&lt;a href=&quot;https://mp.weixin.qq.com/s/47s0YdRM6u1JNngNe6yghg&quot;&gt;聊聊对账系统的设计方案&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;画外音：稳妥一点，可以先发起查询，然后根据查询结果更新订单记录。&lt;/p&gt;
&lt;p&gt;不过有些极端情况，查询无法获取结果，那么直接更新内部记录即可。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那如果第二天也没有这笔记录的结果，这种情况下，我们可以认为这笔是失败的。如果用户被扣款，渠道端内部将会发起退款，将支付金额返回给用户。所以这种情况可以无需处理。&lt;/p&gt;
&lt;h2 id=&quot;内部掉单异常&quot;&gt;内部掉单异常&lt;/h2&gt;
&lt;h3 id=&quot;支付公司内部订单关系&quot;&gt;支付公司内部订单关系&lt;/h3&gt;
&lt;p&gt;接下来我们讲下内部掉单异常，首先我们来看下为什么会发生内部掉单的异常，这其实跟我们系统架构有关。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202010/1419561-20201012083859756-1011257296.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图随所示，第三方支付公司内部表通常为支付订单与渠道订单这样一种 1 比 N 的关系。&lt;/p&gt;
&lt;p&gt;支付订单保存着外部商户系统的订单号，代表第三方支付公司内部订单与外部商户的订单的关系。&lt;/p&gt;
&lt;p&gt;而渠道订单代表着第三方支付公司与外部渠道的关系，其实对于外部渠道系统来讲，第三方支付公司就是一个外部商户。&lt;/p&gt;
&lt;p&gt;为什么需要设计这种关系那？而不是使用下面这种 1 对 1 关系的那？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202010/1419561-20201012083859966-155602254.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果我们使用上图 1 对1 的订单关系，如果第一次支付支付失败，外部商户可能会再次使用相同订单号对第三方支付公司发起支付。&lt;/p&gt;
&lt;p&gt;这时如果第三方支付公司也拿相同的内部订单去请求外部渠道系统，有可能外部渠道系统并不支持同一订单号再次请求。&lt;/p&gt;
&lt;p&gt;那其实我们也有其他办法，生成一个新的内部单号，更新原有支付订单上内部记录，然后去请求外部渠道系统。但是这样的话就会丢失上次支付失败记录，这就不利于我们做一些事后统计了。&lt;/p&gt;
&lt;p&gt;那其实第三方支付公司也可以不支持相同的订单号再次发起请求，但是这样的话，就需要外部商户重新生成的新的订单号。&lt;/p&gt;
&lt;p&gt;这样的话，第三方支付公司是系统是简单了，全部复杂度都交给了外部商户。&lt;/p&gt;
&lt;p&gt;但是现实的情况，很多外部商户并不是那么容易更换生成新的订单号，所以一般第三方支付公司都需要支持同一外部商户订单号在未成功的情况下，支持重复支付。&lt;/p&gt;
&lt;p&gt;在这种情况下，就需要我们上面的 1:N 的订单关系图了。&lt;/p&gt;
&lt;h3 id=&quot;内部掉单异常的原因&quot;&gt;内部掉单异常的原因&lt;/h3&gt;
&lt;p&gt;当我们收到外部渠道系统的成功的返回信息，成功更新了渠道订单表的记录。但是由于渠道订单表与支付订单表可能不是同一个数据库，也有可能两者并不在同一个应用中，这就有可能导致更新支付订单表的更新失败。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202010/1419561-20201012083900191-2087810427.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于支付订单是表保存着外部商户订单与内部订单关系，支付订单未成功，所以外部商户也无法查询得到成功的支付结果。&lt;/p&gt;
&lt;p&gt;此时渠道订单表已经成功，所以上面外部掉单的方法并不适用内部掉单。&lt;/p&gt;
&lt;h3 id=&quot;内部掉单异常解决办法&quot;&gt;内部掉单异常解决办法&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;第一种解决办法，分布式事务。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;内部掉单异常，说白就是因为支付订单表与渠道订单表无法使用数据库事务保证两者同时更新成功或失败。&lt;/p&gt;
&lt;p&gt;那么这种情况下，我们其实就需要使用分布式事务了。&lt;/p&gt;
&lt;p&gt;不过我们没有采用这种分布式事务，一是因为之前开发的时候市面上并没有开源成熟分布式事务框架，第二自己自己开发难度又很大。&lt;/p&gt;
&lt;p&gt;所以对于分布式事务这一块，并没有什么使用经验。如果有使用分布式事务解决这类的问题同学，留言去可以评论一下。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二种解决办法，异步补偿更新。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当发生内部掉单的情况，即更新支付订单失败等情况，可以将这里支付订单保存到一张内部掉单表。&lt;/p&gt;
&lt;p&gt;但是这里可能会有一个问题，我们无法保证保存到内部掉单表这一步骤也一定成功。&lt;/p&gt;
&lt;p&gt;所以说，我们还需要定时查询，查询一段时间内支付订单未成功，而渠道订单表已成功的支付订单记录，然后也将其插入到内部掉单表。&lt;/p&gt;
&lt;p&gt;另一个系统应用，只需要定时扫描内部掉单表，将支付订单成功，然后再删除内部掉单记录即可。&lt;/p&gt;
&lt;p&gt;这里需要注意了，当支付订单表数据量很大之后，定时查询可能会慢，为了防止影响主库，所以这类查询可以在备库进行。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;今天主要介绍了支付系统中的掉单异常，这类异常往往会导致用户实际已经被扣钱，但是商户订单还是等待支付的情况。&lt;/p&gt;
&lt;p&gt;这个异常如果没有很好处理，将会导致客户用户体验很不好，还有可能收到客户的投诉。&lt;/p&gt;
&lt;p&gt;掉单的异常，通常可以外部系统与内部系统。而大部分的掉单都是因为外部系统导致，我们可以增加超时时间，掉单查询，以及接受异步通知解决 99% 的问题，剩下 1% 的掉单只能通过次日的对账来兜底。&lt;/p&gt;
&lt;p&gt;内部系统导致掉单异常是典型的分布式环境数据一致性的问题，这类问题我们可以不需要追求强一致性，只要保证最终一致性即可。我们可以使用分布式事务解决这类问题，也可以定时扫描状态不一致的订单，然后在做批量更新。&lt;/p&gt;
&lt;p&gt;最后，这次只是介绍支付系统中一类掉单异常，下一篇文章中，再给大家介绍一下支付系统的其他异常，敬请期待！&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/19848613&quot;&gt;知乎@天顺 谈谈异常（一）&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;5.5384615384615&quot;&gt;
&lt;p&gt;欢迎关注我的公众号：程序通事，获得日常干货推送。如果您对我的专题内容感兴趣，也可以关注我的博客：&lt;a href=&quot;https://studyidea.cn&quot;&gt;studyidea.cn&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 12 Oct 2020 00:39:00 +0000</pubDate>
<dc:creator>楼下小黑哥</dc:creator>
<og:description>前言 好了，回归到今天的主题，今天分享一下支付系统中异常一些处理方式。 其实这些处理方式并不只是局限于支付系统，也可以适用于其他系统，大家可以借鉴，应用到自己系统中，提高自己系统的健壮性。 异常是系统</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/goodAndyxublog/p/13800796.html</dc:identifier>
</item>
<item>
<title>远程触发Jenkins的Pipeline任务的并发问题处理 - 程序员欣宸</title>
<link>http://www.cnblogs.com/bolingcavalry/p/13800722.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bolingcavalry/p/13800722.html</guid>
<description>&lt;h3 id=&quot;前文概述&quot;&gt;前文概述&lt;/h3&gt;
&lt;p&gt;本文是《远程触发Jenkins的pipeline任务》的续篇，上一篇文章实战了如何通过Http请求远程触发指定的Jenkins任务，并且将参数传递给Jenkins任务去使用，文末提到了有个并发问题待处理，这就是本文的内容：处理上一篇文章提到的遗留问题。&lt;/p&gt;
&lt;h3 id=&quot;远程触发jenkins的问题&quot;&gt;远程触发Jenkins的问题&lt;/h3&gt;
&lt;p&gt;对Jenkins服务来说，很有可能在某一时刻同时收到多个Http请求，并且这些请求都想触发同一个任务，在实际使用中发现此时Jenkins并不对每个请求都运行一次任务，接下来的实战，我们就来重现并解决此问题；&lt;/p&gt;
&lt;h3 id=&quot;用java代码实现多个并发请求&quot;&gt;用Java代码实现多个并发请求&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;我们用代码来模拟同一时刻多个Http请求到达Jenkins的情况：写个Java程序，一次性发送10个Http请求，都是远程触发上一章的Jenkins任务的，参考源码如下：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.bolingcavalry;

import com.alibaba.fastjson.JSONObject;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.entity.StringEntity;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;

public class App {
    public static void main( String[] args ) throws Exception {
        for(int i=0;i&amp;lt;10;i++) {
            JSONObject jsonObject = new JSONObject();
            jsonObject.put(&quot;ref&quot;, &quot;ref-&quot;+i);
            jsonObject.put(&quot;repositoryURL&quot;,&quot;https://github.com/zq2599/jenkinsdemo.git&quot;);
            jsonObject.put(&quot;branch&quot;, &quot;master&quot;);

            CloseableHttpClient httpClient = HttpClients.createDefault();
            HttpPost httpPost = new HttpPost(&quot;http://192.168.133.149:32049/generic-webhook-trigger/invoke?token=token-remote-test&quot;);
            httpPost.addHeader(&quot;Content-Type&quot;, &quot;application/json&quot;);
            httpPost.setEntity(new StringEntity(jsonObject.toJSONString()));
            CloseableHttpResponse response = httpClient.execute(httpPost);
            response.close();
            httpClient.close();

            System.out.println(&quot;response code : &quot; + response.getStatusLine().getStatusCode() + &quot;\n&quot;);
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
</description>
<pubDate>Sun, 11 Oct 2020 23:42:00 +0000</pubDate>
<dc:creator>程序员欣宸</dc:creator>
<og:description>前文概述 本文是《远程触发Jenkins的pipeline任务》的续篇，上一篇文章实战了如何通过Http请求远程触发指定的Jenkins任务，并且将参数传递给Jenkins任务去使用，文末提到了有个并</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bolingcavalry/p/13800722.html</dc:identifier>
</item>
<item>
<title>从红黑树的本质出发，彻底理解红黑树！ - 彤哥读源码</title>
<link>http://www.cnblogs.com/tong-yuan/p/13800721.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tong-yuan/p/13800721.html</guid>
<description>&lt;p&gt;早上好，我是彤哥。&lt;/p&gt;
&lt;p&gt;上一节，我们一起从二叉树、二叉查找树、平衡树、AVL树、2-3树、2-3-4树、B树，一路讲到红黑树，最后得出红黑树的本质：红黑树就是2-3-4树，请看下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1648938/202010/1648938-20201012074056717-376018948.jpg&quot; alt=&quot;14&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们知道2-3-4的插入、删除、查找元素的原理是相当简单的，那么，我们是不是可以利用2-3-4树来记忆红黑树呢？&lt;/p&gt;
&lt;p&gt;答案是肯定的，本节，我们就来看看如何利用2-3-4树来快速掌握红黑树，再也不用死记硬背了~~&lt;/p&gt;
&lt;p&gt;好了，让我们进入今天的学习吧。&lt;/p&gt;

&lt;p&gt;我们给出一张图简单地回顾一下上一节关于2-3-4树插入元素N的过程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1648938/202010/1648938-20201012074057429-1815659933.jpg&quot; alt=&quot;12&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;关注公主号彤哥读源码，查看上一节的内容。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在正式讲解红黑树之前呢，彤哥先来给大家普及几个有意思的概念，分别是左倾红黑树、右倾红黑树、AA树。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;图片太小？试试横屏！&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1648938/202010/1648938-20201012074058466-1524364404.jpg&quot; alt=&quot;1&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;请看上图，其实按照红黑树的概念，上面3颗树都是红黑树，而且元素也是一模一样，可以说是同一颗红黑树的不同变种。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;细心的同学会发现①和②是同一颗2-3-4树演化而来，③是这颗2-3-4树缩小成2-3树的样子。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么，到底什么是红黑树呢？&lt;/p&gt;
&lt;p&gt;红黑树是每个节点都带有颜色属性的二叉查找树，颜色或红色或黑色。&lt;/p&gt;
&lt;p&gt;首先，红黑树是一颗二叉查找树，另外，它还必须满足以下五点要求：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;节点是红色或黑色；&lt;/li&gt;
&lt;li&gt;根节点是黑色；&lt;/li&gt;
&lt;li&gt;所有叶子节点是黑色；（叶子节点是NULL节点）&lt;/li&gt;
&lt;li&gt;每个红色节点的两个子节点都是黑色；（从根节点到每个叶子节点的路径上不能有两个连续的红节点）&lt;/li&gt;
&lt;li&gt;从任何一个节点到每个叶子节点的所有路径都包含相同数目的黑色节点；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;大家不用记这个概念哈，因为确实很难记得住哈，下面彤哥会教大家更简单的方法。&lt;/p&gt;
&lt;p&gt;所以，你看上面三个图是不是都是红黑树呢？&lt;/p&gt;
&lt;p&gt;并不是啊，因为叶子节点有的是红色的呀。&lt;/p&gt;
&lt;p&gt;其实，它们都是红黑树，让我把叶子节点补齐：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1648938/202010/1648938-20201012074058910-174221356.jpg&quot; alt=&quot;2&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;你再仔细看看，是不是满足上面五条规则了？！&lt;/p&gt;
&lt;p&gt;所以，你看，随便画一颗树，它都可能满足红黑树的定义，因此，为了方便记忆，我们将红黑树分成这么几种类型：左倾红黑树、右倾红黑树、AA树。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;左倾红黑树（LLRB，Left-Learning Red-Black Tree）&lt;/strong&gt;，一个节点如果有红色子节点，那么，它的红色子节点是向左倾斜的。&lt;/p&gt;
&lt;p&gt;怎么理解呢？&lt;/p&gt;
&lt;p&gt;我们还是把上面的null节点干掉哈，叶子节点都是null节点，那是经典红黑树的讲法，到彤哥这里，完全不存在这种要求。&lt;/p&gt;
&lt;p&gt;我们来看，一个节点要么有一个子节点，要么有两个子节点，对吧。&lt;/p&gt;
&lt;p&gt;如果这个节点有红色的子节点呢，也是一个或者两个，如果只有一个红色子节点的话，那么，这个子节点只能在左边，如果是有两个红色子节点，那就不用管。&lt;/p&gt;
&lt;p&gt;所以，整颗红黑树中，如果存在红色节点，那么只能是下面这两种形态：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1648938/202010/1648938-20201012074059414-1027161624.jpg&quot; alt=&quot;3&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同理，&lt;strong&gt;右倾红黑树（RLRB，Right-Learning Red-Black Tree）&lt;/strong&gt;，也是一样的道理，即红色子节点向右倾斜，它的红色子节点只能是下面这两种形态：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1648938/202010/1648938-20201012074059806-1197523327.jpg&quot; alt=&quot;4&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好了，左倾和右倾红黑树都还算比较正常的形态，还有一种变态的红黑树，叫作&lt;strong&gt;AA树（AA Tree）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;当然，这里的AA不是吃饭的时候大家各付各的哈，这里的AA是其作者的名字的缩写：&lt;strong&gt;A&lt;/strong&gt;rne &lt;strong&gt;A&lt;/strong&gt;ndersson。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AA树&lt;/strong&gt;，是指红黑树中所有的红色子节点必须只能是右节点，左子节点一律不允许是红色子节点，所以，在AA树中，红色子节点只能是下面这一种形态：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1648938/202010/1648938-20201012074100141-1409960465.jpg&quot; alt=&quot;5&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也可以理解为严重右倾主义（我这么说会不会被约去喝茶^^）。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;其实AA树可以看作2-3树的右倾演化而来，而不是2-3-4树，你可以画个图体验一下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;好了，上面就是左倾红黑树、右倾红黑树、AA树的概念，当然，也有可能存在一种红黑树，比如红色子节点只能是左子节点，是不是叫BB树，咱也不知道，还有一种可能是像下面这种红黑树：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1648938/202010/1648938-20201012074100502-1390587452.jpg&quot; alt=&quot;6&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面这颗树，它既有左边的红色子节点，也有右边的红色子节点，其实它也满足红黑树的定义，这种就只是普通（经典）的红黑树了。&lt;/p&gt;
&lt;p&gt;既然红黑树有这么多完全不同的形态，我们要如何快速的记住它们呢？&lt;/p&gt;
&lt;p&gt;很难，真的很难，所以，我们只需要记住一种形态就可以了，比如左倾红黑树，其它的形态都是一样的道理，完全不用强形记忆。&lt;/p&gt;
&lt;p&gt;因此，下面的内容，我将全部以&lt;strong&gt;左倾红黑树&lt;/strong&gt;来讲解，跟经典的红黑树讲法会有点出入，且跟你以前看到的所有文章都不一样，请不要纠结。&lt;/p&gt;

&lt;p&gt;首先，让我们约定一件事：&lt;strong&gt;插入的节点必须为红色，但如果是根节点，就把它涂成黑色。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有了这个约定之后，我们使用一步一图的方式来慢慢拆解红黑树（左倾，下同）插入元素的过程。&lt;/p&gt;
&lt;ol readability=&quot;32&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;插入第一个元素F&lt;/p&gt;
&lt;p&gt;第一个元素肯定是根节点，直接涂成黑色：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1648938/202010/1648938-20201012074100868-1107633557.jpg&quot; alt=&quot;7&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;19&quot;&gt;
&lt;p&gt;插入第二个元素&lt;/p&gt;
&lt;p&gt;这里分两种情况：比F小，比F大。&lt;/p&gt;
&lt;p&gt;（1）假设插入的元素为D，那么，它比F小，所以会成为F的左子节点：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1648938/202010/1648938-20201012074101514-926299855.jpg&quot; alt=&quot;8&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时，D为红色左子节点，所以，不需要再平衡。&lt;/p&gt;
&lt;p&gt;（2）假设插入的元素为K，那么，它比F大，所以会成为F的右子节点：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1648938/202010/1648938-20201012074101893-709984556.jpg&quot; alt=&quot;9&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时，K为红色右子节点，不符合左倾红黑树的规则，所以，需要再平衡，那么，要如何再平衡呢？&lt;/p&gt;
&lt;p&gt;让我们回归红黑树的本质——2-3-4树，上面包含F和K两个元素的红黑树换成2-3-4树就变成了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1648938/202010/1648938-20201012074102299-1910266716.jpg&quot; alt=&quot;10&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再把这个2-3-4树转换成左倾红黑树就变成了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1648938/202010/1648938-20201012074102710-557433298.jpg&quot; alt=&quot;11&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;让我们画一张对比图来看看：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1648938/202010/1648938-20201012074103090-679457447.jpg&quot; alt=&quot;12&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以，你看，结合2-3-4树来理解红黑树是不是就特别简单了，对于2-3-4树就是一个普通的3节点，而对于红黑树相当于插入一个右子节点，再做一次左旋变色即可。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;26&quot;&gt;
&lt;p&gt;插入第三个元素&lt;/p&gt;
&lt;p&gt;我们以上述的&lt;code&gt;F K&lt;/code&gt;两个元素的红黑树为例，在这个基础上再增加一个元素，这里可能有三种情况，我们一一来分析：&lt;/p&gt;
&lt;p&gt;（1）假设插入的元素为D，它比F小，所以会成为F的左子节点：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1648938/202010/1648938-20201012074103518-370008778.jpg&quot; alt=&quot;13&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时，显然不符合红黑树的定义了，所以，需要再平衡，那么如何平衡呢？来，上图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1648938/202010/1648938-20201012074103871-20160489.jpg&quot; alt=&quot;14&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;插入元素D，对于2-3-4树就是形成一个4节点，而对于红黑树树需要经过右旋再变色的过程。&lt;/p&gt;
&lt;p&gt;（2）假设插入的元素为G，它比F大，比K小，所以会成为F的右子节点：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1648938/202010/1648938-20201012074104286-1750787929.jpg&quot; alt=&quot;15&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;显然，它也不符合红黑树的定义，所以，也需要再平衡：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1648938/202010/1648938-20201012074104671-1168664441.jpg&quot; alt=&quot;16&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;插入元素G，对于2-3-4树，只是形成一个普通的4节点，而对于红黑树，需要先以F左旋，变成与情况（1）相同的状态，再以G右旋，然后变色，最终再平衡成红黑树。&lt;/p&gt;
&lt;p&gt;（3）假设插入的元素为N，它比K大，所以会成为K的右子节点：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1648938/202010/1648938-20201012074105126-759235621.jpg&quot; alt=&quot;17&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时，正好符合红黑树的定义，不需要再平衡了，但是，我们同样画一张图对比看下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1648938/202010/1648938-20201012074105453-51402742.jpg&quot; alt=&quot;18&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好了，通过上面的分析，连续插入三个元素，可以看到，对于2-3-4，都是形成一个4节点，而对于红黑树，最终都变成了下面这个样子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1648938/202010/1648938-20201012074105900-628414941.jpg&quot; alt=&quot;19&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以，我们再插入第四个元素看看。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;12&quot;&gt;
&lt;p&gt;插入第四个元素&lt;/p&gt;
&lt;p&gt;我们以&lt;code&gt;F K N&lt;/code&gt;这颗红黑树为例，插入第四个元素，可能会出现四种情况，也就是分别可能会成为F和N的四个子节点的其中之一，简单点，我们直接上图：&lt;/p&gt;
&lt;p&gt;（1）假设为D，其为F的左子节点&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1648938/202010/1648938-20201012074106365-604742459.jpg&quot; alt=&quot;20&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）假设为G，其为F的右子节点&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1648938/202010/1648938-20201012074106923-293723290.jpg&quot; alt=&quot;21&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（3）假设为M，其为N的左子节点&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1648938/202010/1648938-20201012074107454-571696230.jpg&quot; alt=&quot;22&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（4）假设为Q，其为N的右子节点&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1648938/202010/1648938-20201012074107951-1816923486.jpg&quot; alt=&quot;23&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好了，插入四个元素的各种情况到此结束，可以看到，插入第四个元素时，对于2-3-4树，会形成一个5节点，然后再分裂，而对于红黑树，要经过一系列的左旋、右旋、变色，最终转变成跟2-3-4树对应的形态，是不是很好玩儿^^&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;插入第五个元素&lt;/p&gt;
&lt;p&gt;画图太累，交给你了~~&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;不管是2-3-4树还是左倾红黑树删除元素的过程都要比插入元素复杂得多，我们先来看2-3-4树删除元素的过程。&lt;/p&gt;
&lt;h2 id=&quot;2-3-4树删除元素&quot;&gt;2-3-4树删除元素&lt;/h2&gt;
&lt;p&gt;为了方便讲解，我构造了一颗下图所示的2-3-4树：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1648938/202010/1648938-20201012074108557-1374325103.jpg&quot; alt=&quot;24&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于2-3-4树，删除3节点或4节点的叶子节点是最简单的，比如&lt;code&gt;C D&lt;/code&gt;和&lt;code&gt;P Q R&lt;/code&gt;这两个叶子节点，删除这两个节点中的任意一个元素直接删除即可，4节点删除一个元素后变成3节点，3节点删除一个元素之后变成2节点，并不影响原来树的平衡性，比如，删除C之后的结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1648938/202010/1648938-20201012074108976-986688411.jpg&quot; alt=&quot;25&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是，删除2节点就不一样了，比如，上图删除&lt;code&gt;A&lt;/code&gt;、&lt;code&gt;B&lt;/code&gt;、&lt;code&gt;F&lt;/code&gt;、&lt;code&gt;G&lt;/code&gt;、&lt;code&gt;H&lt;/code&gt;、&lt;code&gt;J&lt;/code&gt;、&lt;code&gt;L&lt;/code&gt;、&lt;code&gt;N&lt;/code&gt;这几个节点，直接删除之后树就不平衡了，所以，需要想一些办法来保证删除L之后树依然是平衡的，怎么办呢？&lt;/p&gt;
&lt;p&gt;答案是——偷！&lt;/p&gt;
&lt;p&gt;没错，就是偷，从别的地方偷元素过来，把这个空缺补上，就像我们上班划水一样，总要找一些东西把工时补上对不对。&lt;/p&gt;
&lt;p&gt;那么，怎么个偷法呢？&lt;/p&gt;
&lt;p&gt;总体来说，分成两大类，子节点从父节点偷，父节点从子节点偷，偷着偷着可能还要合并或者迁移元素。&lt;/p&gt;
&lt;p&gt;我们来分别看一下删除&lt;code&gt;A&lt;/code&gt;、&lt;code&gt;B&lt;/code&gt;、&lt;code&gt;F&lt;/code&gt;、&lt;code&gt;G&lt;/code&gt;、&lt;code&gt;H&lt;/code&gt;、&lt;code&gt;J&lt;/code&gt;、&lt;code&gt;L&lt;/code&gt;、&lt;code&gt;N&lt;/code&gt;这几个节点的过程是如何偷的，以下多图，请慎重！&lt;/p&gt;
&lt;p&gt;（1）删除A&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1648938/202010/1648938-20201012074109399-855631352.jpg&quot; alt=&quot;26&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;删除A元素时，先从父节点偷个B过来，此时，B位置空缺了，原来B的位置再从其右子节点偷个C过来，搞定。&lt;/p&gt;
&lt;p&gt;（2）删除B&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1648938/202010/1648938-20201012074109982-1299779715.jpg&quot; alt=&quot;27&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;删除B就很简单了，直接从右子节点偷个C过来就搞定了。&lt;/p&gt;
&lt;p&gt;（3）删除F&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1648938/202010/1648938-20201012074110498-2054182837.jpg&quot; alt=&quot;28&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;删除F的过程就比较复杂了，总之，始终围绕着一个原则：子节点偷不到就偷父节点的，偷过来的元素之后记得可能会合并或者迁移元素。&lt;/p&gt;
&lt;p&gt;合并的规则是要始终保证整颗树的有序性，比如，上面从父节点偷了个I过来，它本身就比H大，所以，H必须放在I的左子节点，而左子节点原来已经有G了，所以，只能把它们俩合并了。&lt;/p&gt;
&lt;p&gt;同理，迁移J元素的过程也是一样的，J肯定是要放在K的左边，迁移到I的右子节点正好。&lt;/p&gt;
&lt;p&gt;（4）删除G&lt;/p&gt;
&lt;p&gt;其实跟删除F时从偷I开始是一样的，就不赘述了。&lt;/p&gt;
&lt;p&gt;（5）删除H&lt;/p&gt;
&lt;p&gt;与删除F的过程一模一样，不再赘述。&lt;/p&gt;
&lt;p&gt;（6）删除J&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1648938/202010/1648938-20201012074111088-968352833.jpg&quot; alt=&quot;29&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;删除J时，从父节点先偷个K过来，此时父节点变成了3节点，所以，直接把M左边的两个元素合并即可。&lt;/p&gt;
&lt;p&gt;（7）删除L&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1648938/202010/1648938-20201012074111658-1215644610.jpg&quot; alt=&quot;30&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;删除L的过程与删除J的过程有点像，也是从父节点偷K过来，然后再把M左边的两个元素合并。&lt;/p&gt;
&lt;p&gt;（8）删除N&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1648938/202010/1648938-20201012074112196-1201448372.jpg&quot; alt=&quot;31&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;删除N时，从父节点偷个O过来，父节点再从其右子节点偷个P过来，偷个屁，偷个屁呀~~&lt;/p&gt;
&lt;p&gt;好了，到此为止，2-3-4树删除元素的过程全解析完毕了，我这个示例中几乎包含了所有的场景，请多画图仔细体会，虽然画得想吐血了。&lt;/p&gt;
&lt;h2 id=&quot;左倾红黑树删除元素&quot;&gt;左倾红黑树删除元素&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注：红黑树的删除稍微有点小复杂，如果强型跟2-3-4挂钩会变得更复杂，所以，下面的内容不完全跟2-3-4树挂钩。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先，我想问一个问题：一颗二叉查找树删除元素之后如何还能保证它还是二叉查找树呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1648938/202010/1648938-20201012074112793-1560995891.jpg&quot; alt=&quot;32&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果是叶子节点，删了也就删了，不影响，但如果是非叶子节点呢？比如，删除M这个元素。&lt;/p&gt;
&lt;p&gt;其实，有两种方法：一种是找到M的前置节点并拿到M的位置，一种是找到M的后继节点并拿到M的位置。&lt;/p&gt;
&lt;p&gt;什么是前置节点？什么是后继节点呢？好像二叉树里面只听说过父节点、子节点？&lt;/p&gt;
&lt;p&gt;我们知道二叉查找树本质上是有序的，这个有序性指的是元素的自然顺序（还有一种有序性是插入顺序）。&lt;/p&gt;
&lt;p&gt;所以，你把这颗二叉树中的所有元素排个序（或者中序遍历一下），在M前面的那个节点就是前置节点，在M后面的那个节点就是后继节点。&lt;/p&gt;
&lt;p&gt;还有一种更形象的方法，M这个节点左子树中最大的元素就是M的前置节点，M节点右子树中最小的元素就是M的后继节点。&lt;/p&gt;
&lt;p&gt;所以，删除M后，把L或者N移到M的位置就可以了，此时，就能保证二叉查找树依然是二叉查找树。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1648938/202010/1648938-20201012074113397-665036012.jpg&quot; alt=&quot;33&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1648938/202010/1648938-20201012074113821-1878206614.jpg&quot; alt=&quot;34&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不过，大家好像都喜欢移后继节点，即右子树中最小的节点你如果看源码的话，会看到一个单词叫作&lt;code&gt;successor&lt;/code&gt;，就是后继节点的意思。&lt;/p&gt;
&lt;p&gt;好了，关于二叉查找树删除元素我们就讲这么多，还是回到红黑树删除元素的过程。&lt;/p&gt;
&lt;p&gt;为了方便讲解，我构造了下面这么一颗红黑树：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1648938/202010/1648938-20201012074114201-1163612186.jpg&quot; alt=&quot;35&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们先来看一种最简单的情况，如果删除的是红色的叶子节点，比如，上图中的C、P、R这三个元素，如果它的父节点只有它这么一个子节点，直接删之，啥也不用管，比如C，如果它的父节点有两个子节点，那么会分成两种情况，一种是删除的右子节点，则直接删，比如R，另一种是删除的左子节点，那就做一次简单的左旋即可，比如P。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;我们这里讲的是左倾红黑树，如果是经典的红黑树，则删除红色叶子节点不需要旋转。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;OK，我们再来看第二种情况，如果删除的是黑色的叶子节点呢？&lt;/p&gt;
&lt;p&gt;我们知道，黑色节点删除之后，肯定不符合红黑树定义了，所以，肯定要进行再平衡的过程。&lt;/p&gt;
&lt;p&gt;如果按照经典红黑树的说法，要看它的兄弟节点的颜色，有可能还要看它兄弟节点的子节点的颜色，情况大概有三四种，根本不可能记得住，我这里介绍一种更牛逼的方法，保证你看一遍就能记住。&lt;/p&gt;
&lt;p&gt;我们以删除F节点为例，我先给出图示，下面再描述详细步骤：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1648938/202010/1648938-20201012074114620-1387073484.jpg&quot; alt=&quot;36&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这种方法非常简单，F是黑色节点没错，那就想办法把它变成红色节点，怎么变呢？&lt;/p&gt;
&lt;p&gt;那就得从它的上层节点动手，上层节点的红色其实是可以向下传递的，传递之后，整颗树其实还是红黑树，并不会打破原来红黑树的平衡，直到F变成红色的叶子节点，再一举把它删除，就很简单了。&lt;/p&gt;
&lt;p&gt;这种方法相比于经典红黑树的方法，理解起来就容易得多了。&lt;/p&gt;
&lt;p&gt;我们再举个删除L的例子，直接上图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1648938/202010/1648938-20201012074115418-1714249339.jpg&quot; alt=&quot;37&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好了，上面说的都是删除叶子节点，那么，如果删除的是非叶子节点呢，比如删除E。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1648938/202010/1648938-20201012074116033-313277404.jpg&quot; alt=&quot;38&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;根据二叉查找树的特性，那么，我们会找到E的后继节点F，然后，把它移到E的位置，但是，此时，不符合红黑树的定义了，所以，你可以发现，其实，删除E相当于间接地删除F原来所在的节点位置，因此，又转化成了上面的删除叶子节点。&lt;/p&gt;
&lt;p&gt;过程很简单，最后的结果与删除F的结果基本相同，只是原来E所在位置的元素变成了F，我就不画图了。&lt;/p&gt;
&lt;p&gt;你可以想想删除M的过程~&lt;/p&gt;
&lt;p&gt;总算讲完了，能看到这里的同学不容易，可能已经超出了一顿早餐的时间，我很抱歉！&lt;/p&gt;

&lt;p&gt;本节，我们从红黑树的本质，即2-3-4树出发，彻底掌握了一种不用死记硬背的方法来理解红黑树，你Get到了吗？欢迎留言评论。&lt;/p&gt;
&lt;p&gt;有些同学看到这里，可能又说了：Talk is cheap, show me the code！&lt;/p&gt;
&lt;p&gt;好，下一节，我就show you the code，敬请期待！&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;关注公主号“彤哥读源码”，解锁更多源码、基础、架构知识。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sun, 11 Oct 2020 23:41:00 +0000</pubDate>
<dc:creator>彤哥读源码</dc:creator>
<og:description>前言 早上好，我是彤哥。 上一节，我们一起从二叉树、二叉查找树、平衡树、AVL树、2-3树、2-3-4树、B树，一路讲到红黑树，最后得出红黑树的本质：红黑树就是2-3-4树，请看下图： 我们知道2-3</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tong-yuan/p/13800721.html</dc:identifier>
</item>
<item>
<title>在java中使用SFTP协议安全的传输文件 - 字母哥博客</title>
<link>http://www.cnblogs.com/zimug/p/13800694.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zimug/p/13800694.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202010/1815316-20201012071227672-1051132907.jpg&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本文介绍在Java中如何使用基于SSH的文件传输协议（SFTP）将文件从本地上传到远程服务器，或者将文件在两个服务器之间安全的传输。我们先来了解一下这几个协议&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;SSH 是较可靠，专为远程登录会话和其他网络服务提供安全性的协议。比如：我们购买的云服务器登陆的时候使用的协议都是ssh。&lt;/li&gt;
&lt;li&gt;ftp协议通常是用来在两个服务器之间传输文件的，但是它本质上是不安全的。&lt;/li&gt;
&lt;li&gt;那么SFTP是什么？SFTP可以理解为SSH + FTP，也就是&lt;strong&gt;安全的&lt;/strong&gt;网络文件传输协议。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一般来说，SFTP和FTP服务都是使用相应的客户端软件来提供服务。如果你希望在java代码中使用SFTP协议进行安全的文件传输，那么这篇文章非常适合你。&lt;/p&gt;
&lt;h2 id=&quot;1-导入jsch-依赖包&quot;&gt;1. 导入JSch 依赖包&lt;/h2&gt;
&lt;p&gt;在maven项目pom.xml中导入如下的坐标，我们使用JSch，JSch将SFTP协议封装为对应的API供我们调用。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-markup&quot;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.jcraft&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;jsch&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;0.1.55&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;2-文件传输--jsch例子&quot;&gt;2. 文件传输 – JSch例子&lt;/h2&gt;
&lt;h3 id=&quot;21-get与put方法&quot;&gt;2.1 get与put方法&lt;/h3&gt;
&lt;p&gt;在中&lt;code&gt;JSch&lt;/code&gt;，我们可以使用&lt;code&gt;put&lt;/code&gt;和&lt;code&gt;get&lt;/code&gt;在服务器之间进行文件传输。&lt;code&gt;put&lt;/code&gt;方法用来将文件从本地系统传输到远程服务器。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;channelSftp.put(localFile, remoteFile);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;get&lt;/code&gt;方法将文件从远程服务器下载到本地系统。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;channelSftp.get(remoteFile, localFile);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;22-使用用户名和密码进行认证&quot;&gt;2.2 使用用户名和密码进行认证&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;JSch jsch = new JSch();
jsch.setKnownHosts(&quot;/home/zimug/.ssh/known_hosts&quot;);
jschSession = jsch.getSession(USERNAME, REMOTE_HOST, REMOTE_PORT);

jschSession.setPassword(PASSWORD);
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&quot;/home/zimug/.ssh/known_hosts&quot;为SSH的known_hosts文件，也就是可信远程主机的公钥保存文件。&lt;/li&gt;
&lt;li&gt;USERNAME 为用户名&lt;/li&gt;
&lt;li&gt;REMOTE_HOST远程主机的Ip&lt;/li&gt;
&lt;li&gt;REMOTE_PORT远程主机端口&lt;/li&gt;
&lt;li&gt;PASSWORD远程主机登录密码&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;23使用公钥和私钥进行认证&quot;&gt;2.3.使用公钥和私钥进行认证&lt;/h3&gt;
&lt;p&gt;如果读者不能理解公钥和私钥的用法及含义，需要先自行补充一下SSH知识。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;本地私钥–&lt;code&gt;/home/登录用户名/.ssh/id_rsa&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;远程公钥默认保存位置–&lt;code&gt;~/.ssh/authorized_keys&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;JSch jsch = new JSch();
jsch.setKnownHosts(&quot;/home/zimug/.ssh/known_hosts&quot;);
jschSession = jsch.getSession(USERNAME, REMOTE_HOST, REMOTE_PORT);

jsch.addIdentity(&quot;/home/zimug/.ssh/id_rsa&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;24-完整jsch文件传输示例&quot;&gt;2.4 完整&lt;code&gt;JSch&lt;/code&gt;文件传输示例&lt;/h3&gt;
&lt;p&gt;将文件从本地系统传输到远程服务器&lt;code&gt;1.2.3.4&lt;/code&gt;，并使用SSH密码登陆方式进行身份验证。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;import com.jcraft.jsch.*;

public class SFTPFileTransfer {

    private static final String REMOTE_HOST = &quot;1.2.3.4&quot;;  //远程主机ip
    private static final String USERNAME = &quot;&quot;;  //登录用户名
    private static final String PASSWORD = &quot;&quot;;  //登陆密码
    private static final int REMOTE_PORT = 22;   //ssh协议默认端口
    private static final int SESSION_TIMEOUT = 10000; //session超时时间
    private static final int CHANNEL_TIMEOUT = 5000; //管道流超时时间

    public static void main(String[] args) {

        String localFile = &quot;/home/zimug/local/random.txt&quot;;   //本地文件路径
        String remoteFile = &quot;/home/zimug/remote/targetfile.txt&quot;;   //上传到远程的文件路径，要保证登录用户有写权限

        Session jschSession = null;

        try {

            JSch jsch = new JSch();
            jsch.setKnownHosts(&quot;/home/zimug/.ssh/known_hosts&quot;);
            jschSession = jsch.getSession(USERNAME, REMOTE_HOST, REMOTE_PORT);

            // 通过ssh私钥的方式登录认证
            // jsch.addIdentity(&quot;/home/zimug/.ssh/id_rsa&quot;);

            // 通过密码的方式登录认证
            jschSession.setPassword(PASSWORD);
            jschSession.connect(SESSION_TIMEOUT);

            Channel sftp = jschSession.openChannel(&quot;sftp&quot;);  //建立sftp文件传输管道
            sftp.connect(CHANNEL_TIMEOUT);

            ChannelSftp channelSftp = (ChannelSftp) sftp;

            // 传输本地文件到远程主机
            channelSftp.put(localFile, remoteFile);

            channelSftp.exit();

        } catch (JSchException | SftpException e) {
            e.printStackTrace();
        } finally {
            if (jschSession != null) {
                jschSession.disconnect();
            }
        }
        System.out.println(&quot;文件传输完成！&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;3-jsch异常处理&quot;&gt;3. JSch异常处理&lt;/h2&gt;
&lt;p&gt;在文件上传的过程中，我们可能会遇到下面的一些异常&lt;/p&gt;
&lt;h3 id=&quot;31unknownhostkey异常&quot;&gt;3.1UnknownHostKey异常&lt;/h3&gt;
&lt;p&gt;需要将远程服务器IP地址添加到&lt;code&gt;known_hosts&lt;/code&gt;文件中。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;$ ssh-keyscan -t rsa 1.2.3.4 &amp;gt;&amp;gt; ~/.ssh/known_hosts
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;32对于私钥无效异常&quot;&gt;3.2对于私钥无效异常&lt;/h3&gt;
&lt;p&gt;有可能是远程服务器重新生成了私钥，需要把私钥分发复制到本地服务器。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;ssh-copy-id  -i  ~/.ssh/id_rsa.pub  &amp;lt;被分发的服务器ip&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;33对于auth-fail异常&quot;&gt;3.3对于&lt;code&gt;Auth fail&lt;/code&gt;异常&lt;/h3&gt;
&lt;p&gt;请确保提供的登录密码时正确的&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;com.jcraft.jsch.JSchException: Auth fail
        at com.jcraft.jsch.Session.connect(Session.java:519)
        at com.zimug.io.howto.SFTPFileTransfer.main(SFTPFileTransfer.java:34)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;欢迎关注我的博客，里面有很多精品合集&quot;&gt;欢迎关注我的博客，里面有很多精品合集&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;本文转载注明出处（必须带连接，不能只转文字）：&lt;a href=&quot;http://www.zimug.com&quot;&gt;字母哥博客&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;觉得对您有帮助的话，帮我点赞、分享！您的支持是我不竭的创作动力！&lt;/strong&gt; 。另外，笔者最近一段时间输出了如下的精品内容，期待您的关注。&lt;/p&gt;
</description>
<pubDate>Sun, 11 Oct 2020 23:12:00 +0000</pubDate>
<dc:creator>字母哥博客</dc:creator>
<og:description>本文介绍在Java中如何使用基于SSH的文件传输协议（SFTP）将文件从本地上传到远程服务器，或者将文件在两个服务器之间安全的传输。我们先来了解一下这几个协议 SSH 是较可靠，专为远程登录会话和其他</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zimug/p/13800694.html</dc:identifier>
</item>
<item>
<title>汇编入门第一篇，小白也能看懂 - 程序员cxuan</title>
<link>http://www.cnblogs.com/cxuanBlog/p/13800692.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cxuanBlog/p/13800692.html</guid>
<description>&lt;blockquote readability=&quot;3.0808080808081&quot;&gt;
&lt;p&gt;cxuan自己的 Github 非常硬核，求各位大佬 star： &lt;a href=&quot;https://github.com/crisxuan/bestJavaer&quot;&gt;https://github.com/crisxuan/bestJavaer&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;汇编代码是计算机的一种低级表示，它是一种低级语言，可以从字面角度去理解它，包括处理数据、管理内存、读写存储设备上的数据，以及利用网络通信等。编译器生成机器码经过了一系列的转换，这些转换遵循&lt;code&gt;编程语言&lt;/code&gt;、目标机器的&lt;code&gt;指令集&lt;/code&gt; 和&lt;code&gt;操作系统&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;指令集&quot;&gt;指令集&lt;/h2&gt;
&lt;p&gt;指令集就是指挥计算机工作的指令，因为程序就是按照一定执行顺序排列的指令。因为计算机的执行控制权由 CPU 操作，所以指令集就是 CPU 中用来计算和控制计算机的一系列指令的集合。每个 CPU 在产出时都规定了与硬件电路相互配合工作的指令集。&lt;/p&gt;
&lt;p&gt;指令集有不少分类，但是一般分为两种，一种是&lt;code&gt;精简指令集&lt;/code&gt;，一种是&lt;code&gt;复杂指令集&lt;/code&gt;。具体描述如下&lt;/p&gt;
&lt;h3 id=&quot;精简指令集&quot;&gt;精简指令集&lt;/h3&gt;
&lt;p&gt;精简指令的英文是 &lt;code&gt;reduced instruction set computer， RISC&lt;/code&gt;，原意是精简指令集计算，简称为精简指令集，是 CPU 的一种 &lt;code&gt;设计模式&lt;/code&gt;，可以把 CPU 想象成一家流水线工厂，对&lt;code&gt;指令数目&lt;/code&gt;和&lt;code&gt;寻址方式&lt;/code&gt;都做了精简，使其实现更容易，指令并行执行程度更好，编译器的效率更高。&lt;/p&gt;
&lt;p&gt;常见的精简指令集处理器包括 &lt;strong&gt;ARM、AVR、MIPS、PARISC、RISC-V 和 SPARC&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;所以你就能理解&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/09/29/0Zeguq.png&quot; alt=&quot;assembly001&quot; border=&quot;0&quot;/&gt;&lt;p&gt;这本书是讲啥的了。&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;它主要是基于 MIPS 体系结构把冯诺依曼体系的五大组件进行了逐一的硬件实现 + 软件设计介绍，更为重要的是引入了诸多并行计算的内容，这是大部分教材中忽略或者内容较少的，会根据这个思路把并行相关的内容，结合 OpenMP, CUDA 和 Hadoop/Spark 整体融入到新书中，毕竟这是未来发展的趋势&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;还有这本书&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/09/29/0ZefET.png&quot; alt=&quot;assembly002&quot; border=&quot;0&quot;/&gt;&lt;p&gt;这本书又是讲啥的。&lt;/p&gt;
&lt;p&gt;这本书是讲 RISC-V 指令集的，因为指令集的不同也区分了三个版本，三个版本？？？嗯，还有下面这个&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/09/29/0ZeRbV.png&quot; alt=&quot;assembly003&quot; border=&quot;0&quot;/&gt;&lt;p&gt;这本书是讲 ARM 指令集的。&lt;/p&gt;
&lt;p&gt;所以一般在看 CASPP 的时候并发的看看这本书是非常不错的选择。&lt;/p&gt;
&lt;p&gt;精简指令集一般具有如下特征&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;统一的指令编码&lt;/li&gt;
&lt;li&gt;通用的寄存器，一般会区分整数和浮点数&lt;/li&gt;
&lt;li&gt;简单的寻址模式，复杂寻址模式被简单指令序列来取代&lt;/li&gt;
&lt;li&gt;支持很少偏门的类型，例如 RISC 支持字节字符串类型。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;复杂指令集&quot;&gt;复杂指令集&lt;/h3&gt;
&lt;p&gt;复杂指令集的英文是 &lt;code&gt;Complex Instruction Set Computing, CISC&lt;/code&gt;，是一种微处理器指令集架构，也被译为复杂指令集。&lt;/p&gt;
&lt;p&gt;复杂指令集包括 &lt;strong&gt;System/360、VAX、x86 等&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;复杂指令集可以说是在精简指令集之上作出的改变。&lt;/p&gt;
&lt;p&gt;复杂指令集的特点是指令数目多而复杂，每条指令字长并不相等，计算机必须加以判读，并为此付出了性能的代价。&lt;/p&gt;
&lt;p&gt;一般来说，提升 CPU 性能的方法有如下这几种&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;增加寄存器的大小&lt;/li&gt;
&lt;li&gt;增进内部的并行性&lt;/li&gt;
&lt;li&gt;增加高速缓存的大小&lt;/li&gt;
&lt;li&gt;增加核心时脉的速度&lt;/li&gt;
&lt;li&gt;加入其他功能，例如 IO 和计时器&lt;/li&gt;
&lt;li&gt;加入向量处理器&lt;/li&gt;
&lt;li&gt;硬件多线程技术&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;比较抽象，我们后面会组织成文章具体介绍一下。&lt;/p&gt;
&lt;p&gt;C 编译器会接收其他操作并把其转换为&lt;code&gt;汇编语言&lt;/code&gt;输出，汇编语言是机器级别的代码表示。我们之前介绍过，C 语言程序的执行过程分为下面这几步&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/09/29/0Ze2D0.png&quot; alt=&quot;assembly004&quot; border=&quot;0&quot;/&gt;&lt;p&gt;下面我们更多的讨论都是基于汇编代码来讨论。&lt;/p&gt;
&lt;p&gt;我们日常所接触的高级语言，都是经过了层层封装的结果，所以我们平常是接触不到汇编语言的，更不会用汇编语言来进行编程，这就和你不知道操作系统的存在一样，但其实你每个操作，甚至你双击一个图标都和操作系统有关系。&lt;/p&gt;
&lt;p&gt;高级语言的抽象级别很高，但是经过了层层抽象之后，高级语言的执行效率肯定没有汇编语言高，也没有汇编语言可靠。&lt;/p&gt;
&lt;p&gt;但是高级语言有更大的优点是其编译后能够在不同的机器上运行，汇编语言针对不同的指令集有不同的表示。并且高级语言学习来更加通俗易懂，降低计算机门槛，让内卷更加严重（当然这是开个玩笑，冒犯到请别当真）。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;话不多说，了解底层必须了解汇编语言。否则一个 synchronized 底层实现就能够让你头疼不已。而且，天天飘着也不好，迟早要落地。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;了解汇编代码也有助于我们优化程序代码，分析代码中隐含的低效率，并且这种优化方法一旦优化成功，将是量级的提高，而不是改改 if...else ，使用一个新特性所能比的。&lt;/p&gt;
&lt;h2 id=&quot;机器级代码&quot;&gt;机器级代码&lt;/h2&gt;
&lt;p&gt;计算机系统使用了多种不同形式的抽象，可以通过一个简单的抽象模型来隐藏实现细节。对于机器级别的程序来说，有两点非常重要。&lt;/p&gt;
&lt;p&gt;首先第一点，定义机器级别程序的格式和行为被称为 &lt;code&gt;指令集体系结构或指令集架构(instruction set architecture)&lt;/code&gt;， ISA。ISA 定义了进程状态、指令的格式和每一个指令对状态的影响。大部分的指令集架构包括 ISA 用来描述进程的行为就好像是顺序执行的，一条指令执行结束后，另外一条指令再开始。处理器硬件的描述要更复杂，它可以同时并行执行许多指令，但是它采用了&lt;code&gt;安全措施&lt;/code&gt;来确保整体行为与 ISA 规定的顺序一致。&lt;/p&gt;
&lt;p&gt;第二点，机器级别对内存地址的描述就是 &lt;code&gt;虚拟地址(virtual address)&lt;/code&gt;，它提供了一个内存模型来表示一个巨大的字节数组。&lt;/p&gt;
&lt;p&gt;编译器在整个编译的过程中起到了至关重要的作用，把 C 语言转换为处理器执行的基本指令。汇编代码非常接近于机器代码，只不过与二进制机器代码相比，汇编代码的可读性更强，所以理解汇编是理解机器工作的第一步。&lt;/p&gt;
&lt;p&gt;一些进程状态对机器可见，但是 C 语言程序员却看不到这些，包括&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;程序计数器(Program counter)&lt;/code&gt;，它存储下一条指令的地址，在 x86-64 架构中用 &lt;code&gt;%rip&lt;/code&gt; 来表示。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;程序执行时，PC 的初始值为程序第一条指令的地址，在顺序执行程序时， CPU 首先按程序计数器所指出的指令地址从内存中取出一条指令，然后分析和执行该指令，同时将 PC 的值加 1 并指向下一条要执行的指令。&lt;/p&gt;
&lt;p&gt;比如下面一个例子。&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/09/29/0Ze6vn.png&quot; alt=&quot;assembly005&quot; border=&quot;0&quot;/&gt;&lt;p&gt;这是一段数值进行相加的操作，程序启动，在经过编译解析后会由操作系统把硬盘中的程序复制到内存中，示例中的程序是将 123 和 456 执行相加操作，并将结果输出到显示器上。由于使用机器语言难以描述，所以这是经过翻译后的结果，实际上每个指令和数据都可能分布在不同的地址上，但为了方便说明，把组成一条指令的内存和数据放在了一个内存地址上。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;整数&lt;code&gt;寄存器文件(register file)&lt;/code&gt;包含 16 个命名的位置，用来存储 64 位的值。这些寄存器可以存储地址和整型数据。有些寄存器用于跟踪程序状态，而另一些寄存器用于保存临时数据，例如过程的参数和局部变量，以及函数要返回的值。这个 &lt;code&gt;文件&lt;/code&gt; 是和磁盘文件无关的，它只是 CPU 内部的一块高速存储单元。有专用的寄存器，也有通用的寄存器用来存储操作数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;条件码寄存器&lt;/code&gt; 用来保存有关最近执行的算术或逻辑指令的状态信息。这些用于实现控件或数据流中的条件更改，例如实现 if 和 while 语句所需的条件更改。我们都学过高级语言，高级语言中的条件控制流程主要分为三种：&lt;code&gt;顺序执行、条件分支、循环判断&lt;/code&gt;三种，顺序执行是按照地址的内容顺序的执行指令。条件分支是根据条件执行任意地址的指令。循环是重复执行同一地址的指令。
&lt;ul&gt;&lt;li&gt;顺序执行的情况比较简单，每执行一条指令程序计数器的值就是 + 1。&lt;/li&gt;
&lt;li&gt;条件和循环分支会使程序计数器的值指向任意的地址，这样一来，程序便可以返回到上一个地址来重复执行同一个指令，或者跳转到任意指令。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面以条件分支为例来说明程序的执行过程（循环也很相似）&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/09/29/0Zeygs.png&quot; alt=&quot;assembly006&quot; border=&quot;0&quot;/&gt;&lt;p&gt;程序的开始过程和顺序流程是一样的，CPU 从 0100 处开始执行命令，在 0100 和 0101 都是顺序执行，PC 的值顺序+1，执行到 0102 地址的指令时，判断 0106 寄存器的数值大于 0，跳转（jump）到 0104 地址的指令，将数值输出到显示器中，然后结束程序，0103 的指令被跳过了，这就和我们程序中的 &lt;code&gt;if()&lt;/code&gt; 判断是一样的，在不满足条件的情况下，指令会直接跳过。所以 PC 的执行过程也就没有直接+1，而是下一条指令的地址。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一组 &lt;code&gt;向量寄存器&lt;/code&gt;用来存储一个或者多个整数或者浮点数值，向量寄存器是对一维数据上进行操作。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;机器指令只会执行非常简单的操作，例如将存放在寄存器的两个数进行相加，把数据从内存转移到寄存器中或者是条件分支转移到新的指令地址。编译器必须生成此类指令的序列，以实现程序构造，例如算术表达式求值，循环或过程调用和返回&lt;/p&gt;
&lt;h2 id=&quot;认识汇编&quot;&gt;认识汇编&lt;/h2&gt;
&lt;p&gt;我相信各位应该都知道汇编语言的出现背景吧，那就是二进制表示数据，太复杂太庞大了，为了解决这个问题，出现了汇编语言，汇编语言和机器指令的区别就在于表示方法上，汇编使用&lt;code&gt;操作数&lt;/code&gt;来表示，机器指令使用二进制来表示，我之前多次提到机器码就是汇编，你也不能说我错，但是不准确。&lt;/p&gt;
&lt;p&gt;但是汇编适合二进制代码存在转换关系的。&lt;/p&gt;
&lt;p&gt;汇编代码需要经过 &lt;code&gt;汇编器&lt;/code&gt; 编译后才产生二进制代码，这个二进制代码就是目标代码，然后由链接器将其连接起来运行。&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/09/29/0Zes3j.png&quot; alt=&quot;assembly007&quot; border=&quot;0&quot;/&gt;&lt;p&gt;汇编语言主要分为以下三类&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;汇编指令：它是一种机器码的&lt;code&gt;助记符&lt;/code&gt;，它有对应的机器码&lt;/li&gt;
&lt;li&gt;伪指令：没有对应的机器码，由编译器执行，计算机并不执行&lt;/li&gt;
&lt;li&gt;其他符号，比如 +、-、*、/ 等，由编译器识别，没有对应的机器码&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;汇编语言的核心是汇编指令，而我们对汇编的探讨也是基于汇编指令展开的。&lt;/p&gt;
&lt;h2 id=&quot;与汇编有关的硬件和概念&quot;&gt;与汇编有关的硬件和概念&lt;/h2&gt;
&lt;h3 id=&quot;cpu&quot;&gt;CPU&lt;/h3&gt;
&lt;p&gt;CPU 是计算机的大脑，它也是整个计算机的核心，它也是执行汇编语言的硬件，CPU 的内部包含有寄存器，而寄存器是用于存储指令和数据的，汇编语言的本质也就是 CPU 内部操作数所执行的一系列计算。&lt;/p&gt;
&lt;h3 id=&quot;内存&quot;&gt;内存&lt;/h3&gt;
&lt;p&gt;没有内存，计算机就像是一个没有记忆的人类，只会永无休止的重复性劳动。CPU 所需的指令和数据都由内存来提供，CPU 指令经由内存提供，经过一系列计算后再输出到内存。&lt;/p&gt;
&lt;h3 id=&quot;磁盘&quot;&gt;磁盘&lt;/h3&gt;
&lt;p&gt;磁盘也是一种存储设备，它和内存的最大区别在于永久存储，程序需要在内存装载后才能运行，而提供给内存的程序都是由磁盘存储的。&lt;/p&gt;
&lt;h3 id=&quot;总线&quot;&gt;总线&lt;/h3&gt;
&lt;p&gt;一般来说，内存内部会划分多个存储单元，存储单元用来存储指令和数据，就像是房子一样，存储单元就是房子的门牌号。而 CPU 与内存之间的交互是通过地址&lt;code&gt;总线&lt;/code&gt;来进行的，总线从逻辑上分为三种&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;地址线&lt;/li&gt;
&lt;li&gt;数据线&lt;/li&gt;
&lt;li&gt;控制线&lt;/li&gt;
&lt;/ul&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/09/29/0ZewE8.png&quot; alt=&quot;assembly008&quot; border=&quot;0&quot;/&gt;&lt;p&gt;CPU 与存储器之间的读写主要经过以下几步&lt;/p&gt;
&lt;h4 id=&quot;读操作步骤&quot;&gt;读操作步骤&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;CPU 通过地址线发出需要读取指令的位置&lt;/li&gt;
&lt;li&gt;CPU 通过控制线发出读指令&lt;/li&gt;
&lt;li&gt;内存把数据放在数据线上返回给 CPU&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;写操作步骤&quot;&gt;写操作步骤&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;CPU 通过地址线发出需要写出指令的位置&lt;/li&gt;
&lt;li&gt;CPU 通过控制线发出写指令&lt;/li&gt;
&lt;li&gt;CPU 把数据通过数据线写入内存&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面我们就来具体了解一下这三类总线&lt;/p&gt;
&lt;h3 id=&quot;地址总线&quot;&gt;地址总线&lt;/h3&gt;
&lt;p&gt;通过我们上面的探讨，我们知道 CPU 通过&lt;code&gt;地址总线&lt;/code&gt;来指定存储位置的，地址总线上能传送多少不同的信息，CPU 就可以对多少个存储单元进行寻址。&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/09/29/0Ze0US.png&quot; alt=&quot;assembly009&quot; border=&quot;0&quot;/&gt;&lt;p&gt;上图中 CPU 和内存中间信息交换通过了 10 条地址总线，每一条线能够传递的数据都是 0 或 1 ，所以上图一次 CPU 和内存传递的数据是 2 的十次方。&lt;/p&gt;
&lt;p&gt;所以，如果 CPU 有 N 条地址总线，那么可以说这个地址总线的宽度是 N 。这样 CPU 可以寻找 2 的 N 次方个内存单元。&lt;/p&gt;
&lt;h3 id=&quot;数据总线&quot;&gt;数据总线&lt;/h3&gt;
&lt;p&gt;CPU 与内存或其他部件之间的数据传送是由&lt;code&gt;数据总线&lt;/code&gt;来完成的。数据总线的宽度决定了 CPU 和外界的数据传输速度。8 根数据总线可以一次传送一个 8 位二进制数据（即一个字节）。16 根数据总线一次可以传输两个字节，32 根数据总线可以一次传输四个字节。。。。。。&lt;/p&gt;
&lt;h3 id=&quot;控制总线&quot;&gt;控制总线&lt;/h3&gt;
&lt;p&gt;CPU 与其他部件之间的控制是通过 &lt;code&gt;控制总线&lt;/code&gt; 来完成的。有多少根控制总线，就意味着 CPU 提供了对外部器件的多少种控制。所以，控制总线的宽度决定了 CPU 对外部部件的控制能力。&lt;/p&gt;
&lt;h3 id=&quot;一次内存的读取过程&quot;&gt;一次内存的读取过程&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;内存结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;内存 IC 是一个完整的结构，它内部也有电源、地址信号、数据信号、控制信号和用于寻址的 IC 引脚来进行数据的读写。下面是一个虚拟的 IC 引脚示意图&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/09/29/0ZeB4g.png&quot; alt=&quot;assembly010&quot; border=&quot;0&quot;/&gt;&lt;p&gt;图中 VCC 和 GND 表示电源，A0 - A9 是地址信号的引脚，D0 - D7 表示的是控制信号、RD 和 WR 都是好控制信号，我用不同的颜色进行了区分，将电源连接到 VCC 和 GND 后，就可以对其他引脚传递 0 和 1 的信号，大多数情况下，&lt;strong&gt;+5V 表示1，0V 表示 0&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我们都知道内存是用来存储数据，那么这个内存 IC 中能存储多少数据呢？D0 - D7 表示的是数据信号，也就是说，一次可以输入输出 8 bit = 1 byte 的数据。A0 - A9 是地址信号共十个，表示可以指定 00000 00000 - 11111 11111 共 2 的 10次方 = &lt;code&gt;1024个地址&lt;/code&gt;。每个地址都会存放 1 byte 的数据，因此我们可以得出内存 IC 的容量就是 1 KB。&lt;/p&gt;
&lt;p&gt;如果我们使用的是 512 MB 的内存，这就相当于是 512000（512 * 1000） 个内存 IC。当然，一台计算机不太可能有这么多个内存 IC ，然而，通常情况下，一个内存 IC 会有更多的引脚，也就能存储更多数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;内存读取过程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面是一次内存的读取过程。&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/09/29/0ZerCQ.png&quot; alt=&quot;assembly011&quot; border=&quot;0&quot;/&gt;&lt;p&gt;来详细描述一下这个过程，假设我们要向内存 IC 中写入 1byte 的数据的话，它的过程是这样的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先给 VCC 接通 +5V 的电源，给 GND 接通 0V 的电源，使用 &lt;code&gt;A0 - A9&lt;/code&gt; 来指定数据的存储场所，然后再把数据的值输入给 &lt;code&gt;D0 - D7&lt;/code&gt; 的数据信号，并把 &lt;code&gt;WR（write）&lt;/code&gt;的值置为 1，执行完这些操作后，即可以向内存 IC 写入数据&lt;/li&gt;
&lt;li&gt;读出数据时，只需要通过 A0 - A9 的地址信号指定数据的存储场所，然后再将 RD 的值置为 1 即可。&lt;/li&gt;
&lt;li&gt;图中的 RD 和 WR 又被称为控制信号。其中当WR 和 RD 都为 0 时，无法进行写入和读取操作。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;此篇文章我们主要探讨了指令集、指令集的分类，与汇编有关的硬件，总线都有哪些，分别的作用都是什么，然后我们以一次内存读取过程来连接一下 CPU 和内存的交互过程。&lt;/p&gt;
&lt;p&gt;原创不易，如有帮助还请各位读者四连（点在、在看、分享、留言），感谢各位大佬&lt;/p&gt;
&lt;p&gt;关注公众号 程序员cxuan 回复 cxuan 领取优质资料。&lt;/p&gt;
&lt;p&gt;我自己写了六本 PDF ，非常硬核，链接如下&lt;/p&gt;
&lt;p&gt;我自己写了六本 PDF ，非常硬核，链接如下&lt;/p&gt;
&lt;p&gt;我自己写了六本 PDF ，非常硬核，链接如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202009/1515111-20200928073258556-2142265096.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI0ODk2NDIyMQ==&amp;amp;mid=2247485329&amp;amp;idx=1&amp;amp;sn=673f306bb229e73e8f671443488b42d4&amp;amp;chksm=e999f283deee7b95a3cce247907b6557bf5f228c85434fc6cbadf42b2ec4c64443742a8bea7a&amp;amp;token=581641926&amp;amp;lang=zh_CN#rd&quot;&gt;cxuan 呕心沥血肝了四本 PDF。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU2NDg0OTgyMA==&amp;amp;mid=2247494165&amp;amp;idx=1&amp;amp;sn=4e0247006bef89701529d765e6ce32a4&amp;amp;chksm=fc4617e6cb319ef0991ff70c8a769b92f59cf92122f27785b848604493653fdcc206d6830a23&amp;amp;token=794467841&amp;amp;lang=zh_CN#rd&quot;&gt;cxuan 又肝了两本 PDF。&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 11 Oct 2020 23:05:00 +0000</pubDate>
<dc:creator>程序员cxuan</dc:creator>
<og:description>cxuan自己的 Github 非常硬核，求各位大佬 star： https://github.com/crisxuan/bestJavaer 汇编代码是计算机的一种低级表示，它是一种低级语言，可以从</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cxuanBlog/p/13800692.html</dc:identifier>
</item>
<item>
<title>数据结构和算法躬行记（7）——分治算法 - 咖啡机（K.F.J）</title>
<link>http://www.cnblogs.com/strick/p/13392504.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/strick/p/13392504.html</guid>
<description>&lt;p&gt;　　分治算法（Divide-and-Conquer Algorithm），就是分而治之，把一个复杂问题分成两个或更多个相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。&lt;/p&gt;
&lt;p&gt;　　分治算法比较适合用递归来实现，而每一层递归都会涉及三个操作：&lt;/p&gt;
&lt;p&gt;　　（1）分解：将原问题分解为若干个规模较小，相对独立，与原问题形式相同的子问题，缩小问题规模。&lt;/p&gt;
&lt;p&gt;　　（2）求解：若子问题规模较小且易于解决时（找出基线条件），则直接解。否则，递归地解决各子问题。其中基线条件（base case）通常是数组为空或只包含一个元素。&lt;/p&gt;
&lt;p&gt;　　（3）合并：将各子问题的解合并为原问题的解。&lt;/p&gt;
&lt;p&gt;　　分治算法是一种处理问题的思想和技巧，是很多高效算法的基础，例如排序算法（归并和快排）、最大公因数等。&lt;/p&gt;
&lt;p&gt;　　LeetCode的&lt;span&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/majority-element/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;169. 多数元素&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;，可将数组一分为二，左边递归最大值（left），右边也一样（right），当两者相同，就是找到了；当不同时，比较谁的计数多。&lt;/p&gt;
&lt;p&gt;　　与动态规划不同，分治算法分解的子问题可以独立求解，并且它们之间没有相关性。&lt;/p&gt;
&lt;p&gt;　　在《剑指Offer》一书中曾提到，解决复杂问题的3种方法：&lt;/p&gt;
&lt;p&gt;　　（1）画图，涉及链表、二叉树等数据结构时，画几张草图，可将隐藏的规律变得直观。&lt;/p&gt;
&lt;p&gt;　　（2）举例，将抽象问题具体化，模拟运行过程，说不定能发现其中规律。&lt;/p&gt;
&lt;p&gt;　　（3）分解，如果问题很大，则尝试把大问题分解成小问题，然后递归解决，分治法、动态规划等方法都是分解复杂问题的思路。&lt;/p&gt;

&lt;p&gt;　　利用递归与分治技术将数据序列划分成越来越小的半子表，再对半子表排序，最后用递归方法将排好序的半子表合并成为越来越大的有序序列，&lt;span&gt;&lt;a href=&quot;https://codepen.io/strick/pen/LYGoWmo&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;如下所示&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;，思路如图8所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; mergeSort(arr) {
  let len &lt;/span&gt;=&lt;span&gt; arr.length;
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;基线条件&lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt; (len &amp;lt; 2&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; arr;
  }
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;分解&lt;/span&gt;
  let middle = Math.floor(len / 2&lt;span&gt;),
    left &lt;/span&gt;= mergeSort(arr.slice(0&lt;span&gt;, middle)),
    right &lt;/span&gt;=&lt;span&gt; mergeSort(arr.slice(middle));
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;合并&lt;/span&gt;
  &lt;span&gt;return&lt;/span&gt;&lt;span&gt; merge(left, right);
}
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; merge(left, right) {
  let result &lt;/span&gt;=&lt;span&gt; [];
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;求解&lt;/span&gt;
  &lt;span&gt;while&lt;/span&gt; (left.length &amp;amp;&amp;amp;&lt;span&gt; right.length) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;小的在左，大的在右&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (left[0] &amp;lt;= right[0&lt;span&gt;]) {
      result.push(left.shift());
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      result.push(right.shift());
    }
  }
  &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (left.length)
    result.push(left.shift());
  &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (right.length)
    result.push(right.shift());
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202007/211606-20200728174301606-1911731711.png&quot; width=&quot;300&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图 8&lt;/p&gt;
&lt;p&gt;　　面试题51 &lt;span&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;数组中的逆序对&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。先统计子数组中的逆序对，然后统计两个相邻数组之间的逆序对，在统计的过程中还需要对数组进行归并排序。&lt;/p&gt;

&lt;p&gt;　　采用“分而治之”的思想，把大的拆分为小的，小的再拆分为更小的。&lt;/p&gt;
&lt;p&gt;　　将原序列分为两部分，其中前一部分的所有记录均比后一部分的所有记录小，然后再依次对前后两部分的记录进行快速排序，递归该过程，直到序列中的所有记录均有序为止。&lt;/p&gt;
&lt;p&gt;　　代码实现&lt;span&gt;&lt;a href=&quot;https://codepen.io/strick/pen/GRoaWbN&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;如下所示&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;，思路如图9所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; quickSort(arr) {
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; length =&lt;span&gt; arr.length;
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;基线条件&lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt; (length &amp;lt;= 1&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; arr;
  }
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; base = arr[0&lt;span&gt;],
    left &lt;/span&gt;= [],             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存小于基准元素的记录&lt;/span&gt;
    right = [];            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存大于基准元素的记录&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;求解&lt;/span&gt;
  &lt;span&gt;for&lt;/span&gt; (let i = 1; i &amp;lt; length; i++&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (base &amp;gt; arr[i]) {        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;放入左边数组&lt;/span&gt;
&lt;span&gt;      left.push(arr[i]);
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; {                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;放入右边数组&lt;/span&gt;
&lt;span&gt;      right.push(arr[i]);
    }
  }
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;分解&lt;/span&gt;
  left =&lt;span&gt; quickSort(left);
  right &lt;/span&gt;=&lt;span&gt; quickSort(right);
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;合并&lt;/span&gt;
  &lt;span&gt;return&lt;/span&gt;&lt;span&gt; left.concat([base], right);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202007/211606-20200728174617871-1118500480.png&quot; width=&quot;400&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图 9&lt;/p&gt;
&lt;p&gt;　　面试题39 &lt;span&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;数组中出现次数超过一半的数字&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。问题转换为查找中位数，受快速排序的启发，当基准值的下标刚好是n/2时，那么就是中位数，否则在另外两部分中查找。&lt;/p&gt;
&lt;p&gt;　　面试题40 &lt;span&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;最小的 k 个数&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。采用快速排序思想，基于数组第 k 个数字来调整，比 k 个数小的在左边，大的在右边。&lt;/p&gt;

</description>
<pubDate>Sun, 11 Oct 2020 21:58:00 +0000</pubDate>
<dc:creator>咖啡机（K.F.J）</dc:creator>
<og:description>分治算法（Divide-and-Conquer Algorithm），就是分而治之，把一个复杂问题分成两个或更多个相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/strick/p/13392504.html</dc:identifier>
</item>
<item>
<title>在Linux下如何根据域名自签发OpenSSL证书与常用证书转换 - 踏歌行666</title>
<link>http://www.cnblogs.com/zhanglianghhh/p/13800490.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhanglianghhh/p/13800490.html</guid>
<description>&lt;p&gt;在Linux下如何根据域名自签发各种SSL证书，这里我们以Apache、Tomcat、Nginx为例。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;243.77912910359&quot;&gt;

&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在Linux下如何根据域名自签发各种SSL证书，这里我们以Apache、Tomcat、Nginx为例。&lt;/p&gt;
&lt;/blockquote&gt;


&lt;p&gt;首先要有openssl工具，如果没有那么使用如下命令安装：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;yum&lt;/span&gt; &lt;span&gt;install&lt;/span&gt; -y openssl openssl-devel
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;修改openssl-cnf配置文件&quot;&gt;修改openssl.cnf配置文件&lt;/h2&gt;
&lt;p&gt;具体修改如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [root@docker02 ~]# vim /etc/pki/tls/&lt;span&gt;openssl.cnf
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;[ req ]
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;………………
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;# 将如下配置的注释放开
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; req_extensions =&lt;span&gt; v3_req # The extensions to add to a certificate request
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;………………
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;[ v3_req ]
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;# Extensions to add to a certificate request
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; basicConstraints =&lt;span&gt; CA:FALSE
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; keyUsage =&lt;span&gt; nonRepudiation, digitalSignature, keyEncipherment
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;# 添加如下行
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; subjectAltName =&lt;span&gt; @SubjectAlternativeName
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;# 同时增加如下信息
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;[SubjectAlternativeName]
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; DNS.&lt;span&gt;1&lt;/span&gt; =&lt;span&gt; zhangbook.com
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; DNS.&lt;span&gt;2&lt;/span&gt; = *.zhangbook.com
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;说明：本次我们以 &lt;code&gt;*.zhangbook.com&lt;/code&gt; 泛域名为例。&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;创建根证书&quot;&gt;创建根证书&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [root@docker02 ssl]# &lt;span&gt;pwd&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; /root/software/&lt;span&gt;ssl
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;[root@docker02 ssl]# 
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;## 创建CA私钥
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; [root@docker02 ssl]# openssl genrsa -out CA.key &lt;span&gt;2048&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;## 制作CA公钥
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; [root@docker02 ssl]# openssl req -sha256 -new -x509 -days &lt;span&gt;36500&lt;/span&gt; -key CA.key -out CA.crt -config /etc/pki/tls/&lt;span&gt;openssl.cnf 
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;………………
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; Country Name (&lt;span&gt;2&lt;/span&gt;&lt;span&gt; letter code) [XX]:CN
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;State or Province Name (full name) []:BJ
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;Locality Name (eg, city) [Default City]:BeiJing
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;Organization Name (eg, company) [Default Company Ltd]:BTC
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;Organizational Unit Name (eg, section) []:MOST
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; Common Name (eg, your name or your server&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s hostname) []:Light Zhang   # 这里就是证书上的：颁发者&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; Email Address []:ca@test.com
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;当然上述的公钥制作方式需要交互式输入信息，如果不想频繁输入，那么可以使用如下命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;## 免交互式制作CA公钥
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; openssl req -sha256 -new -x509 -days &lt;span&gt;36500&lt;/span&gt; -key CA.key -out CA.crt -config /etc/pki/tls/openssl.cnf -subj &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/C=CN/ST=BJ/L=BeiJing/O=BTC/OU=MOST/CN=Light Zhang/emailAddress=ca@test.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;subj内容详解：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; C             = Country Name (&lt;span&gt;2&lt;/span&gt;&lt;span&gt; letter code)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; ST            =&lt;span&gt; State or Province Name (full name)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; L             =&lt;span&gt; Locality Name (eg, city) [Default City]
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; O             =&lt;span&gt; Organization Name (eg, company) [Default Company Ltd]
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; OU            =&lt;span&gt; Organizational Unit Name (eg, section)
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; CN            = Common Name (eg, your name or your server&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s hostname)&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt; emailAddress  = Email Address
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;此时的的文件有：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;[root@docker02 ssl]# ll
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; total &lt;span&gt;32&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; -rw-r--r-- &lt;span&gt;1&lt;/span&gt; root root &lt;span&gt;1387&lt;/span&gt; Oct  &lt;span&gt;2&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;:&lt;span&gt;25&lt;/span&gt;&lt;span&gt; CA.crt
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; -rw-r--r-- &lt;span&gt;1&lt;/span&gt; root root &lt;span&gt;1679&lt;/span&gt; Oct  &lt;span&gt;2&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;:&lt;span&gt;04&lt;/span&gt; CA.key
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;自签发泛域名证书&quot;&gt;自签发泛域名证书&lt;/h2&gt;
&lt;p&gt;操作步骤为：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;生成域名私钥&lt;/li&gt;
&lt;li&gt;生成证书签发请求文件&lt;/li&gt;
&lt;li&gt;使用自签署的CA，生成域名公钥&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;具体如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; ### 当前目录 /root/software/&lt;span&gt;ssl
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;# 生成 zhangbook.com.key 密钥
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; openssl genrsa -out zhangbook.com.key &lt;span&gt;2048&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;# 生成 zhangbook.com.csr 证书签发请求  交互式
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; openssl req -new -sha256 -key zhangbook.com.key -out zhangbook.com.csr -config /etc/pki/tls/&lt;span&gt;openssl.cnf
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;………………
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;##### 产生的交互式内容与填写如下
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; Country Name (&lt;span&gt;2&lt;/span&gt;&lt;span&gt; letter code) [XX]:CN
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;State or Province Name (full name) []:BJ
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;Locality Name (eg, city) [Default City]:BeiJing
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;Organization Name (eg, company) [Default Company Ltd]:BTC
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;Organizational Unit Name (eg, section) []:MOST
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; Common Name (eg, your name or your server&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s hostname) []:*.zhangbook.com   # 这里就是证书上的：颁发给&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;Email Address []:ca@test.com
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; Please enter the following &lt;span&gt;'&lt;/span&gt;&lt;span&gt;extra&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; attributes
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;to be sent with your certificate request
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; A challenge password []:&lt;span&gt;123456&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;An optional company name []:BTC
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;………………
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;# 生成 zhangbook.com.csr 证书签发请求  非交互式
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; openssl req -new -sha256 -key zhangbook.com.key -out zhangbook.com.csr -config /etc/pki/tls/openssl.cnf -subj &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/C=CN/ST=BJ/L=BeiJing/O=BTC/OU=MOST/CN=*.zhangbook.com/emailAddress=ca@test.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;PS1：上面的Common Name 就是在这步填写 &lt;code&gt;*.zhangbook.com&lt;/code&gt; ，表示的就是该证书支持泛域名，common name一定要在SubjectAlternativeName中包含&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;PS2：进行CA签名获取证书时，需要注意国家、省、单位需要与CA证书相同，否则会报异常&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;查看签名请求文件信息&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
openssl req -&lt;span&gt;in&lt;/span&gt; zhangbook.com.csr -text
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;使用自签署的CA，签署zhangbook.com.crt&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
openssl ca -&lt;span&gt;in&lt;/span&gt; zhangbook.com.csr -md sha256 -days &lt;span&gt;36500&lt;/span&gt; -out zhangbook.com.crt -cert CA.crt -keyfile CA.key -extensions v3_req -config /etc/pki/tls/openssl.cnf
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里证书有效时间为100年。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;PS1：即便是你前面是sha256的根证书和sha256的请求文件，如果这里不加 &lt;code&gt;-md sha256&lt;/code&gt;，那么默认是按照sha1进行签名的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;PS2：在执行时，可能出现如下错误&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;异常问题1：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; Using configuration from /etc/pki/tls/&lt;span&gt;openssl.cnf
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; /etc/pki/CA/index.txt: No such &lt;span&gt;file&lt;/span&gt;&lt;span&gt; or directory
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; unable to open &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/etc/pki/CA/index.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;140652962035600&lt;/span&gt;:error:&lt;span&gt;02001002&lt;/span&gt;:system library:fopen:No such &lt;span&gt;file&lt;/span&gt; or directory:bss_file.c:&lt;span&gt;402&lt;/span&gt;:fopen(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/etc/pki/CA/index.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;140652962035600&lt;/span&gt;:error:&lt;span&gt;20074002&lt;/span&gt;:BIO routines:FILE_CTRL:system lib:bss_file.c:&lt;span&gt;404&lt;/span&gt;:
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1395193/202010/1395193-20201011235709025-2144640167.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;处理：这时我们创建该文件即可&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;touch&lt;/span&gt; /etc/pki/CA/index.txt
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;异常问题2：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;然后我们继续使用 【自签署的CA，签署zhangbook.com.crt】；结果又出现新问题&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; Using configuration from /etc/pki/tls/&lt;span&gt;openssl.cnf
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; /etc/pki/CA/serial: No such &lt;span&gt;file&lt;/span&gt;&lt;span&gt; or directory
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; error &lt;span&gt;while&lt;/span&gt;&lt;span&gt; loading serial number
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;140087163742096&lt;/span&gt;:error:&lt;span&gt;02001002&lt;/span&gt;:system library:fopen:No such &lt;span&gt;file&lt;/span&gt; or directory:bss_file.c:&lt;span&gt;402&lt;/span&gt;:fopen(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/etc/pki/CA/serial&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;140087163742096&lt;/span&gt;:error:&lt;span&gt;20074002&lt;/span&gt;:BIO routines:FILE_CTRL:system lib:bss_file.c:&lt;span&gt;404&lt;/span&gt;:
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1395193/202010/1395193-20201011235757898-1670873284.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;处理：使用如下命令即可。表示：用来跟踪最后一次颁发证书的序列号。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;01&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;gt; /etc/pki/CA/serial
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;之后我们再次执行 【自签署的CA，签署zhangbook.com.crt 】 就正常了。详情如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [root@docker02 ssl]# openssl ca -&lt;span&gt;in&lt;/span&gt; zhangbook.com.csr -md sha256 -days &lt;span&gt;36500&lt;/span&gt; -out zhangbook.com.crt -cert CA.crt -keyfile CA.key -extensions v3_req -config /etc/pki/tls/&lt;span&gt;openssl.cnf
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; Using configuration from /etc/pki/tls/&lt;span&gt;openssl.cnf
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;Check that the request matches the signature
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;Signature ok
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;Certificate Details:
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         Serial Number: &lt;span&gt;1&lt;/span&gt; (&lt;span&gt;0x1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        Validity
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             Not Before: Oct  &lt;span&gt;2&lt;/span&gt; &lt;span&gt;03&lt;/span&gt;:&lt;span&gt;42&lt;/span&gt;:&lt;span&gt;39&lt;/span&gt; &lt;span&gt;2020&lt;/span&gt;&lt;span&gt; GMT
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             Not After : Sep  &lt;span&gt;8&lt;/span&gt; &lt;span&gt;03&lt;/span&gt;:&lt;span&gt;42&lt;/span&gt;:&lt;span&gt;39&lt;/span&gt; &lt;span&gt;2120&lt;/span&gt;&lt;span&gt; GMT
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        Subject:
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             countryName               =&lt;span&gt; CN
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             stateOrProvinceName       =&lt;span&gt; BJ
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             organizationName          =&lt;span&gt; BTC
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             organizationalUnitName    =&lt;span&gt; MOST
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             commonName                = *&lt;span&gt;.zhangbook.com
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             emailAddress              =&lt;span&gt; ca@test.com
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        X509v3 extensions:
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            X509v3 Basic Constraints: 
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;                CA:FALSE
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;            X509v3 Key Usage: 
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;                Digital Signature, Non Repudiation, Key Encipherment
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;            X509v3 Subject Alternative Name: 
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                 DNS:zhangbook.com, DNS:*&lt;span&gt;.zhangbook.com
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; Certificate is to be certified &lt;span&gt;until&lt;/span&gt; Sep  &lt;span&gt;8&lt;/span&gt; &lt;span&gt;03&lt;/span&gt;:&lt;span&gt;42&lt;/span&gt;:&lt;span&gt;39&lt;/span&gt; &lt;span&gt;2120&lt;/span&gt; GMT (&lt;span&gt;36500&lt;/span&gt;&lt;span&gt; days)
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; Sign the certificate? [y/n]:y &amp;lt;==&lt;span&gt; 需要输入的
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; out of &lt;span&gt;1&lt;/span&gt; certificate requests certified, commit? [y/n]y &amp;lt;==&lt;span&gt; 需要输入的
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; Write out database with &lt;span&gt;1&lt;/span&gt;&lt;span&gt; new entries
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; Data Base Updated
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;说明：此时我们再看，&lt;code&gt;/etc/pki/CA/index.txt&lt;/code&gt; 和 &lt;code&gt;/etc/pki/CA/serial&lt;/code&gt; 文件信息。如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; [root@docker02 ~]# &lt;span&gt;cat&lt;/span&gt; /etc/pki/CA/&lt;span&gt;index.txt
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; V    21200908034239Z        &lt;span&gt;01&lt;/span&gt;    unknown    /C=CN/ST=BJ/O=BTC/OU=MOST/CN=*.zhangbook.com/emailAddress=&lt;span&gt;ca@test.com
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; [root@docker02 ~&lt;span&gt;]# 
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; [root@docker02 ~]# &lt;span&gt;cat&lt;/span&gt; /etc/pki/CA/&lt;span&gt;serial
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;02&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由上可知：域名签署信息已经保存到index.txt文件；并且证书序列serial文件已经更新【从01变为了02】。&lt;/p&gt;
&lt;p&gt;PS：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;同一个域名不能签署多次；由于签署了&lt;code&gt;*.zhangbook.com&lt;/code&gt;，且已经被记录，因此不能再次被签署。除非删除该记录。&lt;/li&gt;
&lt;li&gt;注意index.txt文件和serial文件的关系。serial文件内容为index.txt文件内容行数加1。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;查看证书信息&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
openssl x509 -&lt;span&gt;in&lt;/span&gt; zhangbook.com.crt -text
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;验证签发证书是否有效&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; [root@docker02 ssl]# openssl verify -&lt;span&gt;CAfile CA.crt zhangbook.com.crt
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; zhangbook.com.crt: OK
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;此时的文件有：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;[root@docker02 ssl]# ll
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; total &lt;span&gt;32&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; -rw-r--r-- &lt;span&gt;1&lt;/span&gt; root root &lt;span&gt;1387&lt;/span&gt; Oct  &lt;span&gt;2&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;:&lt;span&gt;25&lt;/span&gt;&lt;span&gt; CA.crt
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; -rw-r--r-- &lt;span&gt;1&lt;/span&gt; root root &lt;span&gt;1679&lt;/span&gt; Oct  &lt;span&gt;2&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;:&lt;span&gt;04&lt;/span&gt;&lt;span&gt; CA.key
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; -rw-r--r-- &lt;span&gt;1&lt;/span&gt; root root &lt;span&gt;4364&lt;/span&gt; Oct  &lt;span&gt;2&lt;/span&gt; &lt;span&gt;11&lt;/span&gt;:&lt;span&gt;42&lt;/span&gt;&lt;span&gt; zhangbook.com.crt
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; -rw-r--r-- &lt;span&gt;1&lt;/span&gt; root root &lt;span&gt;1151&lt;/span&gt; Oct  &lt;span&gt;2&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;:&lt;span&gt;48&lt;/span&gt;&lt;span&gt; zhangbook.com.csr
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; -rw-r--r-- &lt;span&gt;1&lt;/span&gt; root root &lt;span&gt;1679&lt;/span&gt; Oct  &lt;span&gt;2&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;:&lt;span&gt;44&lt;/span&gt; zhangbook.com.key
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时我们已经完成自签发证书。&lt;/p&gt;


&lt;p&gt;实际工作和生产环境中，可能需要各种各样的证书格式。下面我们将证书转换为常用的其他证书格式。&lt;/p&gt;

&lt;h2 id=&quot;将crt转pem格式&quot;&gt;将crt转pem格式&lt;/h2&gt;
&lt;p&gt;命令如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
openssl x509 -&lt;span&gt;in&lt;/span&gt; zhangbook.com.crt -out zhangbook.com.pem -outform PEM
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;生成-p12-格式的证书&quot;&gt;生成 p12 格式的证书&lt;/h2&gt;
&lt;p&gt;利用生成的CA根证书和服务证书的crt 和 key 文件生成 p12 文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
openssl pkcs12 -export -&lt;span&gt;in&lt;/span&gt; zhangbook.com.crt -inkey zhangbook.com.key -passin pass:CS2i1QkR -name *.zhangbook.com -chain -CAfile CA.crt -password pass:CS2i1QkR -caname *.zhangbook.com -out zhangbook.com.p12
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;PS：p12证书的password为&lt;code&gt;CS2i1QkR&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;查看p12证书信息&lt;/strong&gt;【keytool命令依赖于Java，因此需要先安装Java】&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; [root@docker02 ssl]# keytool -rfc -list -keystore zhangbook.com.p12 -&lt;span&gt;storetype pkcs12  
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; Enter keystore password:   &amp;lt;==&lt;span&gt; 输入：CS2i1QkR
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;Keystore type: PKCS12
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;Keystore provider: SunJSSE
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; 
&lt;span&gt;6&lt;/span&gt; Your keystore contains &lt;span&gt;1&lt;/span&gt;&lt;span&gt; entry
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; ………………
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;转换-p12-证书为-jks-证书文件&quot;&gt;转换 p12 证书为 jks 证书文件&lt;/h2&gt;
&lt;p&gt;使用jdk keytool工具进而生成tomcat/jboss端使用的证书文件【需要安装 Java】。&lt;/p&gt;
&lt;p&gt;具体如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [root@docker02 ssl]# keytool -importkeystore -srckeystore zhangbook.com.p12 -srcstoretype PKCS12 -deststoretype JKS -&lt;span&gt;destkeystore zhangbook.com.jks
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;Importing keystore zhangbook.com.p12 to zhangbook.com.jks...
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; Enter destination keystore password:  &amp;lt;==&lt;span&gt; 输入 jks 证书的密码，如：CS2i1QkR
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; Re-enter new password: &amp;lt;==&lt;span&gt; 重复输入 jks 证书的密码，如：CS2i1QkR
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; Enter source keystore password:  &amp;lt;==&lt;span&gt; 输入 p12 证书的密码，这里是：CS2i1QkR
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; Entry &lt;span&gt;for&lt;/span&gt; alias *&lt;span&gt;.zhangbook.com successfully imported.
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; Import command completed:  &lt;span&gt;1&lt;/span&gt; entries successfully imported, &lt;span&gt;0&lt;/span&gt;&lt;span&gt; entries failed or cancelled
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;Warning:
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; The JKS keystore uses a proprietary format. It is recommended to migrate to PKCS12 &lt;span&gt;which&lt;/span&gt; is an industry standard format using &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;keytool -importkeystore -srckeystore zhangbook.com.jks -destkeystore zhangbook.com.jks -deststoretype pkcs12&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;PS：p12证书和jks证书的密码相同，防止出现各种异常情况。&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;利用-jks-证书生成-cer-证书&quot;&gt;利用 jks 证书生成 cer 证书&lt;/h2&gt;
&lt;p&gt;具体如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
keytool -export -alias *.zhangbook.com -keystore zhangbook.com.jks -storepass CS2i1QkR -&lt;span&gt;file&lt;/span&gt; zhangbook.com.cer
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;-storepass CS2i1QkR&lt;/code&gt; 为jks证书密码&lt;/p&gt;

&lt;h2 id=&quot;利用-cer-证书文件生成-jdk-所使用的文件&quot;&gt;利用 cer 证书文件生成 jdk 所使用的文件&lt;/h2&gt;
&lt;p&gt;具体如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
keytool -import -alias *.zhangbook.com -keystore cacerts -&lt;span&gt;file&lt;/span&gt; zhangbook.com.cer
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;目前存在文件说明&quot;&gt;目前存在文件说明&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [root@docker02 ssl]# &lt;span&gt;pwd&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; /root/software/&lt;span&gt;ssl
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;[root@docker02 ssl]# 
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;[root@docker02 ssl]# ll
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; total &lt;span&gt;52&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; -rw-r--r-- &lt;span&gt;1&lt;/span&gt; root root &lt;span&gt;1018&lt;/span&gt; Oct  &lt;span&gt;2&lt;/span&gt; &lt;span&gt;14&lt;/span&gt;:&lt;span&gt;24&lt;/span&gt;&lt;span&gt; cacerts ## jdk 所使用的文件
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; -rw-r--r-- &lt;span&gt;1&lt;/span&gt; root root &lt;span&gt;1387&lt;/span&gt; Oct  &lt;span&gt;2&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;:&lt;span&gt;25&lt;/span&gt;&lt;span&gt; CA.crt  ## CA公钥
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; -rw-r--r-- &lt;span&gt;1&lt;/span&gt; root root &lt;span&gt;1679&lt;/span&gt; Oct  &lt;span&gt;2&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;:&lt;span&gt;04&lt;/span&gt;&lt;span&gt; CA.key  ## CA私钥
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; -rw-r--r-- &lt;span&gt;1&lt;/span&gt; root root  &lt;span&gt;946&lt;/span&gt; Oct  &lt;span&gt;2&lt;/span&gt; &lt;span&gt;14&lt;/span&gt;:&lt;span&gt;21&lt;/span&gt;&lt;span&gt; zhangbook.com.cer  ## cer证书
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; -rw-r--r-- &lt;span&gt;1&lt;/span&gt; root root &lt;span&gt;4364&lt;/span&gt; Oct  &lt;span&gt;2&lt;/span&gt; &lt;span&gt;11&lt;/span&gt;:&lt;span&gt;42&lt;/span&gt;&lt;span&gt; zhangbook.com.crt  ## zhangbook.com域名 CA签发公钥
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; -rw-r--r-- &lt;span&gt;1&lt;/span&gt; root root &lt;span&gt;1151&lt;/span&gt; Oct  &lt;span&gt;2&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;:&lt;span&gt;48&lt;/span&gt;&lt;span&gt; zhangbook.com.csr  ## zhangbook.com域名 证书签发请求
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; -rw-r--r-- &lt;span&gt;1&lt;/span&gt; root root &lt;span&gt;3303&lt;/span&gt; Oct  &lt;span&gt;2&lt;/span&gt; &lt;span&gt;14&lt;/span&gt;:&lt;span&gt;13&lt;/span&gt;&lt;span&gt; zhangbook.com.jks  ## jks证书
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; -rw-r--r-- &lt;span&gt;1&lt;/span&gt; root root &lt;span&gt;1679&lt;/span&gt; Oct  &lt;span&gt;2&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;:&lt;span&gt;44&lt;/span&gt;&lt;span&gt; zhangbook.com.key  ## zhangbook.com域名 私钥
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; -rw-r--r-- &lt;span&gt;1&lt;/span&gt; root root &lt;span&gt;3716&lt;/span&gt; Oct  &lt;span&gt;2&lt;/span&gt; &lt;span&gt;14&lt;/span&gt;:&lt;span&gt;02&lt;/span&gt;&lt;span&gt; zhangbook.com.p12  ## p12格式证书
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; -rw-r--r-- &lt;span&gt;1&lt;/span&gt; root root &lt;span&gt;1338&lt;/span&gt; Oct  &lt;span&gt;2&lt;/span&gt; &lt;span&gt;13&lt;/span&gt;:&lt;span&gt;56&lt;/span&gt; zhangbook.com.pem  ## zhangbook.com域名 PEM文件
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;修改本地Windows的hosts文件，用于域名解析&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;文件位置：C:\WINDOWS\System32\drivers\etc\hosts   追加如下信息
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;# zhangbook.com
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;172.16&lt;/span&gt;.&lt;span&gt;1.32&lt;/span&gt;    www.zhangbook.com  blog.zhangbook.com  auth.zhangbook.com
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中172.16.1.32为测试使用的Linux机器，后面会部署WEB服务。由于自签发的是泛域名证书，因此可以有多个二级域名。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;后面访问的时候，既可以使用域名访问，也可以使用IP访问。【推荐】使用域名访问。&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;Apache服务的SSL证书使用&quot;&gt;Apache服务的SSL证书使用&lt;/h2&gt;
&lt;p&gt;1、将Apache httpd用到的证书拷贝到指定目录&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; [root@docker02 ssl]# &lt;span&gt;pwd&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; /root/software/&lt;span&gt;ssl
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;[root@docker02 ssl]# 
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; [root@docker02 ssl]# &lt;span&gt;cp&lt;/span&gt; -a zhangbook.com.crt zhangbook.com.key zhangbook.com.pem /etc/pki/tls/certs
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2、在Linux机器安装httpd服务并添加ssl插件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;yum&lt;/span&gt; &lt;span&gt;install&lt;/span&gt; -&lt;span&gt;y httpd
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;yum&lt;/span&gt; &lt;span&gt;install&lt;/span&gt; -y mod_ssl openssl    # 执行后，会增加 /etc/httpd/conf.d/ssl.conf 文件
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;3、在httpd添加SSL配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [root@docker02 conf.d]# &lt;span&gt;pwd&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; /etc/httpd/&lt;span&gt;conf.d
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;[root@docker02 conf.d]# 
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;[root@docker02 conf.d]# vim ssl.conf
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &amp;lt;VirtualHost _default_:&lt;span&gt;443&lt;/span&gt;&amp;gt;
&lt;span&gt; 6&lt;/span&gt; # General setup &lt;span&gt;for&lt;/span&gt;&lt;span&gt; the virtual host, inherited from global configuration
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; #DocumentRoot &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/var/www/html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;………………
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;# 修改如下3行
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; SSLCertificateFile /etc/pki/tls/certs/&lt;span&gt;zhangbook.com.crt
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; SSLCertificateKeyFile /etc/pki/tls/certs/&lt;span&gt;zhangbook.com.key
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;# 如下行可以注释掉，也可以取消注释
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; #SSLCertificateChainFile /etc/pki/tls/certs/&lt;span&gt;zhangbook.com.pem
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;………………
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &amp;lt;/VirtualHost&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;4、向VirtualHost的默认目录添加文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Apache web&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;gt; /var/www/html/index.html
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;5、启动httpd服务&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
systemctl start httpd
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;6、浏览器访问&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;172.16.1.32/&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.zhangbook.com/&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;blog.zhangbook.com &lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;auth.zhangbook.com&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1395193/202010/1395193-20201012000402698-724670671.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1395193/202010/1395193-20201012000409576-989059492.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1395193/202010/1395193-20201012000415797-230918422.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;7、验证完毕，停止httpd服务&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
systemctl stop httpd
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;Nginx服务的SSL证书使用&quot;&gt;Nginx服务的SSL证书使用&lt;/h2&gt;
&lt;p&gt;1、在Linux机器安装nginx服务&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;yum&lt;/span&gt; &lt;span&gt;install&lt;/span&gt; -y nginx
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过 &lt;code&gt;nginx -V&lt;/code&gt; 可见，&lt;code&gt;--with-http_ssl_module&lt;/code&gt; 已安装。&lt;/p&gt;

&lt;p&gt;2、将nginx用到的证书拷贝到指定目录&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; [root@docker02 ssl]# &lt;span&gt;pwd&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; /root/software/&lt;span&gt;ssl
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;[root@docker02 ssl]# 
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; [root@docker02 ssl]# &lt;span&gt;cp&lt;/span&gt; -a zhangbook.com.key zhangbook.com.crt /etc/nginx/cert
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;3、在nginx添加SSL配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [root@docker02 nginx]# &lt;span&gt;pwd&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; /etc/&lt;span&gt;nginx
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;[root@docker02 nginx]# 
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;[root@docker02 nginx]# vim nginx.conf
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;………………
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    server {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         listen       &lt;span&gt;80&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         listen       [::]:&lt;span&gt;80&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        server_name  www.zhangbook.com  blog.zhangbook.com  auth.zhangbook.com;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         return &lt;span&gt;301&lt;/span&gt; https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;$server_name$request_uri;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; # Settings &lt;span&gt;for&lt;/span&gt;&lt;span&gt; a TLS enabled server.
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    server {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         listen       &lt;span&gt;443&lt;/span&gt;&lt;span&gt; ssl http2 default_server;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         listen       [::]:&lt;span&gt;443&lt;/span&gt;&lt;span&gt; ssl http2 default_server;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        server_name  www.zhangbook.com  blog.zhangbook.com  auth.zhangbook.com;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         root         /usr/share/nginx/&lt;span&gt;html;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;         ssl_certificate &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/etc/nginx/cert/zhangbook.com.crt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         ssl_certificate_key &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/etc/nginx/cert/zhangbook.com.key&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        ssl_session_cache shared:SSL:1m;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        ssl_session_timeout  10m;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         ssl_ciphers HIGH:!aNULL:!&lt;span&gt;MD5;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        ssl_prefer_server_ciphers on;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;         # Load configuration files &lt;span&gt;for&lt;/span&gt;&lt;span&gt; the default server block.
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         include /etc/nginx/default.d&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;.conf;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;        location / {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;          index  index.html index.htm;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;………………&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;4、向WEB站点添加html文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Nginx web&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;gt; /usr/share/nginx/html/index.html
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;5、启动nginx服务&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
systemctl start nginx.service
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;6、浏览器访问&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.zhangbook.com/&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;blog.zhangbook.com &lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;auth.zhangbook.com&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1395193/202010/1395193-20201012000921232-1501306654.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1395193/202010/1395193-20201012000928777-1181682330.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;7、验证完毕，停止nginx服务&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
systemctl stop nginx
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;Tomcat服务的SSL证书使用&quot;&gt;Tomcat服务的SSL证书使用&lt;/h2&gt;
&lt;p&gt;1、下载Tomcat。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [root@docker02 App]# &lt;span&gt;pwd&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; /root/&lt;span&gt;App
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;[root@docker02 App]# 
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; [root@docker02 App]# &lt;span&gt;wget&lt;/span&gt; https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;mirrors.bfsu.edu.cn/apache/tomcat/tomcat-8/v8.5.58/bin/apache-tomcat-8.5.58.tar.gz&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;[root@docker02 App]# 
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; [root@docker02 App]# &lt;span&gt;tar&lt;/span&gt; xf apache-tomcat-&lt;span&gt;8.5&lt;/span&gt;.&lt;span&gt;58&lt;/span&gt;.&lt;span&gt;tar&lt;/span&gt;&lt;span&gt;.gz
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;### 查看Java版本信息
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; [root@docker02 App]# java -&lt;span&gt;version
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; java version &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1.8.0_231&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; Java(TM) SE Runtime Environment (build &lt;span&gt;1.8&lt;/span&gt;.0_231-&lt;span&gt;b11)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; Java HotSpot(TM) &lt;span&gt;64&lt;/span&gt;-Bit Server VM (build &lt;span&gt;25.231&lt;/span&gt;-&lt;span&gt;b11, mixed mode)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;### 查看Tomcat版本信息
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; [root@docker02 bin]# &lt;span&gt;pwd&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; /root/App/apache-tomcat-&lt;span&gt;8.5&lt;/span&gt;.&lt;span&gt;58&lt;/span&gt;/&lt;span&gt;bin
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;[root@docker02 bin]# 
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; [root@docker02 bin]# ./version.&lt;span&gt;sh&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; ………………
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2、将Tomcat用到的证书拷贝到指定目录&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; [root@docker02 ssl]# &lt;span&gt;pwd&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; /root/software/&lt;span&gt;ssl
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;[root@docker02 ssl]# 
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; [root@docker02 ssl]# &lt;span&gt;cp&lt;/span&gt; -a zhangbook.com.jks /root/App/apache-tomcat-&lt;span&gt;8.5&lt;/span&gt;.&lt;span&gt;58&lt;/span&gt;/conf/cert/
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;3、在Tomcat添加SSL配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [root@docker02 conf]# &lt;span&gt;pwd&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; /root/App/apache-tomcat-&lt;span&gt;8.5&lt;/span&gt;.&lt;span&gt;58&lt;/span&gt;/&lt;span&gt;conf
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;[root@docker02 conf]# 
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;[root@docker02 conf]# vim server.xml
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;………………
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &amp;lt;Connector port=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;80&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; protocol=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HTTP/1.1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;                connectionTimeout=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;20000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;                redirectPort=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;443&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;………………
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;### 其中Connector标签中的子标签 SSLHostConfig 已去掉
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &amp;lt;Connector port=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;443&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; protocol=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;org.apache.coyote.http11.Http11NioProtocol&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;                maxThreads=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;600&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; SSLEnabled=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; clientAuth=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; keystoreFile=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/root/App/apache-tomcat-8.5.58/conf/cert/zhangbook.com.jks&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;                            keystorePass=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CS2i1QkR&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; keystoreType=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;JKS&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; scheme=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; secure=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;                            sslProtocol=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TLS&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; compression=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;on&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; acceptorThreadCount=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; connectionTimeout=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;20000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&lt;span&gt;15&lt;/span&gt;     &amp;lt;/Connector&amp;gt;
&lt;span&gt;16&lt;/span&gt; ………………
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;4、向WEB站点添加html文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; [root@docker02 ROOT]# &lt;span&gt;pwd&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; /root/App/apache-tomcat-&lt;span&gt;8.5&lt;/span&gt;.&lt;span&gt;58&lt;/span&gt;/webapps/&lt;span&gt;ROOT
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;[root@docker02 ROOT]# 
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; [root@docker02 ROOT]# &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Tomcat web&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &amp;gt; index.html
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;PS：原ROOT目录下的文件已移走。&lt;/p&gt;
&lt;p&gt;5、启动Tomcat服务&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; [root@docker02 bin]# &lt;span&gt;pwd&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; /root/App/apache-tomcat-&lt;span&gt;8.5&lt;/span&gt;.&lt;span&gt;58&lt;/span&gt;/&lt;span&gt;bin
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;[root@docker02 bin]# 
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; [root@docker02 bin]# &lt;span&gt;sh&lt;/span&gt; startup.&lt;span&gt;sh&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;6、浏览器访问&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;172.16.1.32/&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.zhangbook.com/&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;blog.zhangbook.com &lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;auth.zhangbook.com&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1395193/202010/1395193-20201012001124011-1193467247.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1395193/202010/1395193-20201012001129484-2035352422.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;7、验证完毕，停止Tomcat服务&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; [root@docker02 bin]# &lt;span&gt;pwd&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; /root/App/apache-tomcat-&lt;span&gt;8.5&lt;/span&gt;.&lt;span&gt;58&lt;/span&gt;/&lt;span&gt;bin
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;[root@docker02 bin]# 
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; [root@docker02 bin]# &lt;span&gt;sh&lt;/span&gt; shutdown.&lt;span&gt;sh&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;1、&lt;a href=&quot;https://blog.csdn.net/qq_21359467/article/details/102731032&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;openssl生成自签名泛域名（通配符）证书&lt;/a&gt;&lt;/p&gt;

&lt;hr/&gt;

&lt;p&gt;———END———&lt;br/&gt;如果觉得不错就关注下呗 (-^O^-) ！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1395193/202010/1395193-20201012001226096-832810331.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;/div&gt;</description>
<pubDate>Sun, 11 Oct 2020 16:14:00 +0000</pubDate>
<dc:creator>踏歌行666</dc:creator>
<og:description>在Linux下如何根据域名自签发各种SSL证书，这里我们以Apache、Tomcat、Nginx为例。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhanglianghhh/p/13800490.html</dc:identifier>
</item>
</channel>
</rss>