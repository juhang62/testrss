<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>华东交通大学编译原理期末试卷 - RunWsh</title>
<link>http://www.cnblogs.com/chenqiwei/p/RunWsh007.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenqiwei/p/RunWsh007.html</guid>
<description>&lt;p&gt;&lt;span&gt;被人称为&quot;&lt;strong&gt;&lt;span&gt;软件四大天书之首&lt;/span&gt;&lt;/strong&gt;&quot;---&lt;strong&gt;&lt;span&gt;编译原理&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里小编给大家收集了一些习题--&lt;strong&gt;&lt;span&gt;华东交通大学编译原理期末试卷及相关习题&lt;span&gt;(话不多说,直接上链接)--&amp;gt;&lt;a onclick=&quot;window.open('https://files.cnblogs.com/files/chenqiwei/华东交通大学编译原理期末试卷.7z','1','width=300,height=300,left='+(screen.availWidth/2-150)+',top='+(screen.availHeight/2-150)+'');return false;&quot; href=&quot;https://files.cnblogs.com/files/chenqiwei/%E5%8D%8E%E4%B8%9C%E4%BA%A4%E9%80%9A%E5%A4%A7%E5%AD%A6%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%9C%9F%E6%9C%AB%E8%AF%95%E5%8D%B7.7z&quot; target=&quot;_blank&quot;&gt;全部下载&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;a title=&quot;1&quot; onclick=&quot;window.open('https://files.cnblogs.com/files/chenqiwei/2010-2011编译原理2010-2011试卷---A%28答案%29.7z','给小编一个赞,买杯咖啡提提神','width=100,height=100,left='+(screen.availWidth/2-50)+',top='+(screen.availHeight/2-50)+'');&quot; href=&quot;https://files.cnblogs.com/files/chenqiwei/2010-2011%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862010-2011%E8%AF%95%E5%8D%B7---A%28%E7%AD%94%E6%A1%88%29.7z&quot; target=&quot;_blank&quot;&gt;2010-2011编译原理2010-2011试卷---A(答案)&lt;/a&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;a title=&quot;1&quot; onclick=&quot;window.open('https://files.cnblogs.com/files/chenqiwei/华东交通大学编译原理试题库试卷八.7z','给个赞,点个关注,买杯咖啡','width=300,height=300,left='+(screen.availWidth/2-150)+',top='+(screen.availHeight/2-150)+'');return false;&quot; href=&quot;https://files.cnblogs.com/files/chenqiwei/%E5%8D%8E%E4%B8%9C%E4%BA%A4%E9%80%9A%E5%A4%A7%E5%AD%A6%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E8%AF%95%E9%A2%98%E5%BA%93%E8%AF%95%E5%8D%B7%E5%85%AB.7z&quot; target=&quot;_blank&quot;&gt;华东交通大学编译原理试题试卷a&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;a onclick=&quot;window.open('https://files.cnblogs.com/files/chenqiwei/2016-2017华东交通大学学年度第一学期编译原理期末题.7z','点个赞','width=300,height=300,left='+(screen.availWidth/2-150)+',top='+(screen.availHeight/2-150)+'');return false;&quot; href=&quot;https://files.cnblogs.com/files/chenqiwei/2016-2017%E5%8D%8E%E4%B8%9C%E4%BA%A4%E9%80%9A%E5%A4%A7%E5%AD%A6%E5%AD%A6%E5%B9%B4%E5%BA%A6%E7%AC%AC%E4%B8%80%E5%AD%A6%E6%9C%9F%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%9C%9F%E6%9C%AB%E9%A2%98.7z&quot; target=&quot;_blank&quot;&gt;2016-2017华东交通大学学年度第一学期编译原理期末题&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;a title=&quot;1&quot; onclick=&quot;window.open('https://files.cnblogs.com/files/chenqiwei/华东交通大学编译原理试题库试卷二.7z','','width=300,height=300,left='+(screen.availWidth/2-150)+',top='+(screen.availHeight/2-150)+'');return false;&quot; href=&quot;https://files.cnblogs.com/files/chenqiwei/%E5%8D%8E%E4%B8%9C%E4%BA%A4%E9%80%9A%E5%A4%A7%E5%AD%A6%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E8%AF%95%E9%A2%98%E5%BA%93%E8%AF%95%E5%8D%B7%E4%BA%8C.7z&quot; target=&quot;_blank&quot;&gt;华东交通大学编译原理试题库试卷b&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;a title=&quot;1&quot; onclick=&quot;window.open('https://files.cnblogs.com/files/chenqiwei/%5B复习%5D华东交通大学编译原理试题库试卷七.7z','3','width=300,height=300,left='+(screen.availWidth/2-150)+',top='+(screen.availHeight/2-150)+'');return false;&quot; href=&quot;https://files.cnblogs.com/files/chenqiwei/%5B%E5%A4%8D%E4%B9%A0%5D%E5%8D%8E%E4%B8%9C%E4%BA%A4%E9%80%9A%E5%A4%A7%E5%AD%A6%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E8%AF%95%E9%A2%98%E5%BA%93%E8%AF%95%E5%8D%B7%E4%B8%83.7z&quot; target=&quot;_blank&quot;&gt;华东交通大学编译原理试题库试卷七&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;a onclick=&quot;window.open('https://files.cnblogs.com/files/chenqiwei/华东交通大学编译原理试题库_试卷九.7z','3','width=300,height=300,left='+(screen.availWidth/2-150)+',top='+(screen.availHeight/2-150)+'');return false;&quot; href=&quot;https://files.cnblogs.com/files/chenqiwei/%E5%8D%8E%E4%B8%9C%E4%BA%A4%E9%80%9A%E5%A4%A7%E5%AD%A6%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E8%AF%95%E9%A2%98%E5%BA%93_%E8%AF%95%E5%8D%B7%E4%B9%9D.7z&quot; target=&quot;_blank&quot;&gt;华东交通大学编译原理试题库_试卷c&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;a title=&quot;20&quot; onclick=&quot;window.open('https://files.cnblogs.com/files/chenqiwei/华东交通大学编译原理试题库_试卷十.7z','3','width=300,height=300,left='+(screen.availWidth/2-150)+',top='+(screen.availHeight/2-150)+'');return false;&quot; href=&quot;https://files.cnblogs.com/files/chenqiwei/%E5%8D%8E%E4%B8%9C%E4%BA%A4%E9%80%9A%E5%A4%A7%E5%AD%A6%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E8%AF%95%E9%A2%98%E5%BA%93_%E8%AF%95%E5%8D%B7%E5%8D%81.7z&quot; target=&quot;_blank&quot;&gt;华东交通大学编译原理试题库_试卷x&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;a title=&quot;12&quot; onclick=&quot;window.open('https://files.cnblogs.com/files/chenqiwei/编译试卷2013-2014及答案.7z','30','width=300,height=300,left='+(screen.availWidth/2-150)+',top='+(screen.availHeight/2-150)+'');return false;&quot; href=&quot;https://files.cnblogs.com/files/chenqiwei/%E7%BC%96%E8%AF%91%E8%AF%95%E5%8D%B72013-2014%E5%8F%8A%E7%AD%94%E6%A1%88.7z&quot; target=&quot;_blank&quot;&gt;编译试卷2013-2014及答案&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1469234/201904/1469234-20190428153419338-663714943.jpg&quot; alt=&quot;&quot; width=&quot;694&quot; height=&quot;462&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;








</description>
<pubDate>Sun, 28 Apr 2019 07:43:00 +0000</pubDate>
<dc:creator>RunWsh</dc:creator>
<og:description>被人称为&quot;软件四大天书之首&quot; 编译原理 这里小编给大家收集了一些习题--华东交通大学编译原理期末试卷及相关习题(话不多说,直接上链接)--&gt;全部下载 2010-2011编译原</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenqiwei/p/RunWsh007.html</dc:identifier>
</item>
<item>
<title>JS异步操作新体验之 async函数 - rogerwu</title>
<link>http://www.cnblogs.com/rogerwu/p/10784236.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rogerwu/p/10784236.html</guid>
<description>&lt;div readability=&quot;22&quot;&gt;
&lt;p&gt;&lt;strong&gt;1、初识 async 函数&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ES6中提供了两个很好的解决异步操作的方案 Promise 和 Generator，ES2017标准中引入的 async 函数就是建立在 Promise 和 Generator的基础之上，它是 Generator函数的语法糖，使异步操作更加方便&lt;/p&gt;

&lt;p&gt;先通过一个异步读取文件的小栗子来对比下Promise、Generator 和 async 的异同点&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
const fs = require('fs'&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; readFile(fileName) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Promise((resolve, reject) =&amp;gt;&lt;span&gt; {
    fs.readFile(fileName, (err, data) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(err) {
        reject(err)
      }
      resolve(data.toString())
    })
  })
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;（1）、通过 Promise 读取文件&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
readFile('data/a.txt').then(res =&amp;gt;&lt;span&gt; console.log(res))
                      .&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;(err =&amp;gt;&lt;span&gt; console.log(err))

readFile(&lt;/span&gt;'data/b.txt').then(res =&amp;gt;&lt;span&gt; console.log(res))
                      .&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;(err =&amp;gt;&lt;span&gt; console.log(err))

readFile(&lt;/span&gt;'data/c.txt').then(res =&amp;gt;&lt;span&gt; console.log(res))
                      .&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;(err =&amp;gt; console.log(err))
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;（2）、通过 Generator 函数读取文件&lt;/p&gt;
&lt;p&gt;与 Promise 相比较，优点：把所有的接口都封装在一个函数里面了，缺点：代码量稍微多一点点&lt;/p&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;*&lt;span&gt; gen() {
  yield readFile(&lt;/span&gt;'data/a.txt'&lt;span&gt;)
  yield readFile(&lt;/span&gt;'data/b.txt'&lt;span&gt;)
  yield readFile(&lt;/span&gt;'data/c.txt'&lt;span&gt;)
}

let it &lt;/span&gt;=&lt;span&gt; gen()

it.next().value.then(res &lt;/span&gt;=&amp;gt;&lt;span&gt; {
  console.log(res)
}).&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;(err =&amp;gt;&lt;span&gt; {
  console.log(err)
})

it.next().value.then(res &lt;/span&gt;=&amp;gt;&lt;span&gt; {
  console.log(res)
}).&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;(err =&amp;gt;&lt;span&gt; {
  console.log(err)
})

it.next().value.then(res &lt;/span&gt;=&amp;gt;&lt;span&gt; {
  console.log(res)
}).&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;(err =&amp;gt;&lt;span&gt; {
  console.log(err)
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;（3）、通过 async 函数读取文件&lt;/p&gt;
&lt;p&gt;充分吸取了 Promise 和 Generator的优点，同时避免了它们的缺点&lt;/p&gt;
&lt;div readability=&quot;18&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
async &lt;span&gt;function&lt;/span&gt;&lt;span&gt; read() {
  let readA &lt;/span&gt;= await readFile('data/a.txt'&lt;span&gt;)
  let readB &lt;/span&gt;= await readFile('data/b.txt'&lt;span&gt;)
  let readC &lt;/span&gt;= await readFile('data/c.txt'&lt;span&gt;)

  console.log(readA)
  console.log(readB)
  console.log(readC)
}

read()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;最终的输出结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/997093/201904/997093-20190428104056607-1539721712.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;div readability=&quot;28&quot;&gt;
&lt;p&gt;通过上例可以看出，async 函数就是将 Generator函数的星号(&quot;*&quot;)替换成了 async，把 yield 替换成了 await&lt;/p&gt;

&lt;p&gt;async 函数对 Generator函数的改进，主要体现在三个方面：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（1）、内置执行器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;async函数的执行，与普通函数一模一样，只需一行；而 Generator函数，需要调用next 方法&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（2）、返回值是 Promise&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;async函数的返回值是Promise，这比 Generator函数返回一个 Iterator对象方便多了&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（3）、更好的语义化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从字面意思上来讲，async是英文单词 asynchronous 的缩写，表示异步的；await中的 wait 是等待的意思。&lt;/p&gt;

&lt;p&gt;因此相比 Generator函数中的星号和yield，语义更加清楚，async 表示这是一个异步操作的函数，await 表示紧跟在后面的表达式需要等待结果&lt;/p&gt;


&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;2、async 函数的多种使用形式&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;12.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 函数声明&lt;/span&gt;
async &lt;span&gt;function&lt;/span&gt;&lt;span&gt; foo() {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ....&lt;/span&gt;
&lt;span&gt;}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 函数表达式&lt;/span&gt;
let foo = async &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ....&lt;/span&gt;
&lt;span&gt;}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 箭头函数&lt;/span&gt;
let foo = async() =&amp;gt;&lt;span&gt; {}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对象的方法&lt;/span&gt;
let obj =&lt;span&gt; {
  name: &lt;/span&gt;'Roger'&lt;span&gt;,
  async foo() {

  }
}
obj.foo().then(res &lt;/span&gt;=&amp;gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ....&lt;/span&gt;
&lt;span&gt;})

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 类的方法&lt;/span&gt;
&lt;span&gt;class Student{
  constructor(name, age) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age
  }
  async say() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; `My name is ${&lt;span&gt;this&lt;/span&gt;.name}, I'&lt;span&gt;m ${this.age} years old !`
  }
}

let jim = new Student(&lt;/span&gt;'Jim Green'&lt;span&gt;, 13)
jim.say().then(res =&amp;gt; console.log(res))   // My name is Jim Green, I&lt;/span&gt;'m 13 years old !
&lt;/pre&gt;&lt;/div&gt;

&lt;div readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;strong&gt;3、基本用法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;async 函数返回一个 Promise 实例对象，可以使用 then 方法添加回调函数。&lt;/p&gt;

&lt;p&gt;当函数执行时，一旦遇到 await 就会先返回，等到异步操作完成，再接着执行函数体内后面的语句&lt;/p&gt;

&lt;div readability=&quot;11.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 休眠 ms 毫秒&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; sleep(ms) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Promise(resolve =&amp;gt;&lt;span&gt; {
    setTimeout(resolve, ms)
  })
}

async &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; print(ms) {
  console.log(&lt;/span&gt;'start... ...'&lt;span&gt;)
  await sleep(ms)
  console.log(&lt;/span&gt;'end... ...'&lt;span&gt;)
}

print(&lt;/span&gt;1000)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/997093/201904/997093-20190428113004615-1029208253.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div readability=&quot;13&quot;&gt;
&lt;p&gt;（1）、async 函数内部 return语句返回的值，会成为then方法回调函数的参数&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
async &lt;span&gt;function&lt;/span&gt;&lt;span&gt; foo() {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 'hello world'&lt;span&gt;
}

foo().then(res &lt;/span&gt;=&amp;gt; console.log(res))   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; hello world&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;（2）、async 函数内部抛出错误，会导致返回的 Promise对象变成reject状态，抛出的错误会被catch方法回调函数接收到&lt;/p&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
async &lt;span&gt;function&lt;/span&gt;&lt;span&gt; bar() {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Error('Error... ...'&lt;span&gt;)
}

bar().then(res &lt;/span&gt;=&amp;gt;&lt;span&gt; console.log(res))
     .&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;(err =&amp;gt; console.log(err))   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Error: Error... ...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;（3）、只有 async 函数内部的异步操作执行完，才会执行 then方法指定的回调函数&lt;/p&gt;
&lt;div readability=&quot;9.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
async &lt;span&gt;function&lt;/span&gt;&lt;span&gt; baz() {
  await &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Promise(resolve =&amp;gt;&lt;span&gt; {
    console.log(&lt;/span&gt;'执行第一个异步操作'&lt;span&gt;)
    setTimeout(resolve, &lt;/span&gt;2000&lt;span&gt;)
  })

  await &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Promise(resolve =&amp;gt;&lt;span&gt; {
    console.log(&lt;/span&gt;'执行第二个异步操作'&lt;span&gt;)
    setTimeout(resolve, &lt;/span&gt;3000&lt;span&gt;)
  })

  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; '异步执行完毕再执行then方法'&lt;span&gt;
}

baz().then(res &lt;/span&gt;=&amp;gt; {console.log(res)})
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/997093/201904/997093-20190428115134892-163894986.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;strong&gt;4、await 命令&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;await 用于等待一个 Promise对象，它只能在一个 async函数中使用&lt;/p&gt;
&lt;div readability=&quot;14&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[return_value] =&lt;span&gt; await expression

表达式：一个 Promise对象或者任何要等待的值

返回值：返回 Promise对象的处理结果。如果等待的不是 Promise对象，则返回该值本身&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;await命令会暂停当前 async函数的执行，等待 Promise处理完成。如果 Promise正常处理，其回调的 resolve函数参数会作为 await表达式的返回值，继续执行 async函数。如果 Promise处理异常，await表达式会把 Promise的异常原因抛出&lt;/p&gt;

&lt;div readability=&quot;11.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果 await 命令后的表达式的值不是一个 Promise，则返回该值本身&lt;/span&gt;
async &lt;span&gt;function&lt;/span&gt;&lt;span&gt; foo() {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; await 123&lt;span&gt;
}

foo().then(res &lt;/span&gt;=&amp;gt; console.log(res))    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 123&lt;/span&gt;


&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果 Promise 正常处理(fulfilled)，其回调的resolve函数参数作为 await 表达式的返回值&lt;/span&gt;
async &lt;span&gt;function&lt;/span&gt;&lt;span&gt; bar() {
  let f &lt;/span&gt;= await &lt;span&gt;new&lt;/span&gt; Promise((resolve, reject) =&amp;gt;&lt;span&gt; {
    resolve(&lt;/span&gt;'我是表达式的返回值'&lt;span&gt;)
  })
  console.log(f)   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 我是表达式的返回值&lt;/span&gt;

  &lt;span&gt;return&lt;/span&gt; 'ending'&lt;span&gt;
}

bar().then(res &lt;/span&gt;=&amp;gt; {console.log(res)})    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ending&lt;/span&gt;


&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果 Promise 处理异常(rejected)，await 表达式会把 Promise 的异常原因抛出&lt;/span&gt;
async &lt;span&gt;function&lt;/span&gt;&lt;span&gt; baz() {
  await &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Promise((resolve, reject) =&amp;gt;&lt;span&gt; {
    reject(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Error('出错啦......'&lt;span&gt;))
  })
}

baz().then(res &lt;/span&gt;=&amp;gt;&lt;span&gt; console.log(res))
     .&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;(err =&amp;gt; console.log(err))     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Error: 出错啦......&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;（1）、任何一个 await语句后面的 Promise对象变为 reject状态，那么整个 async函数都会中断执行&lt;/p&gt;

&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
async &lt;span&gt;function&lt;/span&gt;&lt;span&gt; foo() {
  await Promise.reject(&lt;/span&gt;'error'&lt;span&gt;)
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 'ending'   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 未执行&lt;/span&gt;
&lt;span&gt;}

foo().then(res &lt;/span&gt;=&amp;gt;&lt;span&gt; console.log(res))
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Uncaught (in promise) error&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;9.5&quot;&gt;
&lt;p&gt;（2）、如果希望当前面的异步操作失败时，不要中断后面的异步操作，可以把前面的 await放在try...catch结构里面&lt;/p&gt;

&lt;div readability=&quot;11&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
async &lt;span&gt;function&lt;/span&gt;&lt;span&gt; foo() {
  &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
    await Promise.reject(&lt;/span&gt;'error'&lt;span&gt;)
  } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(e) {
    
  }
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; await Promise.resolve('执行完毕'&lt;span&gt;)
}

foo().then(res &lt;/span&gt;=&amp;gt; console.log(res))    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行完毕&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;还可以在 await后面的 Promise对象再跟一个 catch方法，处理前面可能出现的错误&lt;/p&gt;

&lt;div readability=&quot;9.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
async &lt;span&gt;function&lt;/span&gt;&lt;span&gt; foo() {
  await Promise.reject(&lt;/span&gt;'error').&lt;span&gt;catch&lt;/span&gt;(err =&amp;gt;&lt;span&gt; console.log(err))
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; '执行完毕'&lt;span&gt;
}

foo().then(res &lt;/span&gt;=&amp;gt; console.log(res))    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行完毕&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;（3）、如果想让多个异步操作同时触发，缩短程序的执行时间，可以参考如下两种写法&lt;/p&gt;

&lt;div readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 写法一&lt;/span&gt;
let [foo, bar] =&lt;span&gt; await Promise.all([getFoo(), getBar()]);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 写法二&lt;/span&gt;
let fooPromise =&lt;span&gt; getFoo();
let barPromise &lt;/span&gt;=&lt;span&gt; getBar();
let foo &lt;/span&gt;=&lt;span&gt; await fooPromise;
let bar &lt;/span&gt;= await barPromise;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Sun, 28 Apr 2019 07:25:00 +0000</pubDate>
<dc:creator>rogerwu</dc:creator>
<og:description>1、初识 async 函数 ES6中提供了两个很好的解决异步操作的方案 Promise 和 Generator，ES2017标准中引入的 async 函数就是建立在 Promise 和 Generat</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/rogerwu/p/10784236.html</dc:identifier>
</item>
<item>
<title>Python爬虫入门教程 64-100 反爬教科书级别的网站-汽车之家，字体反爬之二 - 梦想橡皮擦</title>
<link>http://www.cnblogs.com/happymeng/p/10784177.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/happymeng/p/10784177.html</guid>
<description>&lt;h2 id=&quot;说说这个网站&quot;&gt;说说这个网站&lt;/h2&gt;
&lt;p&gt;汽车之家，反爬神一般的存在，字体反爬的鼻祖网站，这个网站的开发团队，一定擅长前端吧，2019年4月19日开始写这篇博客，不保证这个代码可以存活到月底，希望后来爬虫coder，继续和汽车之间对抗。&lt;/p&gt;
&lt;p&gt;CSDN上关于汽车之家的反爬文章千千万万了，但是爬虫就是这点有意思，这一刻写完，下一刻还能不能用就不知道了，所以可以一直不断有人写下去。希望今天的博客能帮你学会一个反爬技巧。&lt;/p&gt;
&lt;h2 id=&quot;今天要爬去的网页&quot;&gt;今天要爬去的网页&lt;/h2&gt;
&lt;blockquote readability=&quot;2.4642857142857&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://car.autohome.com.cn/config/series/59.html#pvareaid=3454437&quot; class=&quot;uri&quot;&gt;https://car.autohome.com.cn/config/series/59.html#pvareaid=3454437&lt;/a&gt;&lt;br/&gt;我们要做的就是爬取汽车参数配置&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;具体的数据如下&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/4/28/16a62caa318e7473?w=697&amp;amp;h=737&amp;amp;f=png&amp;amp;s=75088&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;查看页面源代码发现，一个好玩的事情，源代码中使用了大量的CSS3的语法&lt;br/&gt;下图，我标注的部分就是关键的一些数据了，大概在600行之后。&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/4/28/16a62caa31e91ccd?w=1808&amp;amp;h=525&amp;amp;f=png&amp;amp;s=145489&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;反爬措施展示&quot;&gt;反爬措施展示&lt;/h3&gt;
&lt;p&gt;源文件数据&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;刹车/&amp;lt;span class='hs_kw86_baikeIl'&amp;gt;&amp;lt;/span&amp;gt;安全系统&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;页面显示数据&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/4/28/16a62caa3151a325?w=236&amp;amp;h=55&amp;amp;f=png&amp;amp;s=3001&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;一些关键数据被处理过了。&lt;/p&gt;
&lt;h2 id=&quot;爬取关键信息&quot;&gt;爬取关键信息&lt;/h2&gt;
&lt;p&gt;我们要把源代码中的关键信息先获取到，即使他数据是存在反爬的。获取数据是非常简单的。通过&lt;code&gt;request&lt;/code&gt;模块即可&lt;/p&gt;
&lt;pre class=&quot;py&quot;&gt;
&lt;code&gt;def get_html():
    url = &quot;https://car.autohome.com.cn/config/series/59.html#pvareaid=3454437&quot;
    headers = {
        &quot;User-agent&quot;: &quot;你的浏览器UA&quot;
    }
    with requests.get(url=url, headers=headers, timeout=3) as res:
        html = res.content.decode(&quot;utf-8&quot;)
    
    return html&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;找关键因素&quot;&gt;找关键因素&lt;/h3&gt;
&lt;p&gt;在html页面中找到关键点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;var config&lt;/li&gt;
&lt;li&gt;var levelId&lt;/li&gt;
&lt;li&gt;var keyLink&lt;/li&gt;
&lt;li&gt;var bag&lt;/li&gt;
&lt;li&gt;var color&lt;/li&gt;
&lt;li&gt;var innerColor&lt;/li&gt;
&lt;li&gt;var option&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这些内容你找到之后，你下手就用重点了，他们是什么？数据啊，通过简单的正则表达式就可以获取到了&lt;/p&gt;
&lt;pre class=&quot;py&quot;&gt;
&lt;code&gt;def get_detail(html):
    
    config = re.search(&quot;var config = (.*?)};&quot;, html, re.S)  
    option = re.search(&quot;var option = (.*?)};&quot;, html, re.S)
    print(config,option)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果&lt;/p&gt;
&lt;pre class=&quot;py&quot;&gt;
&lt;code&gt;
&amp;gt;python e:/python/demo.py
&amp;lt;re.Match object; span=(167291, 233943), match='var config = {&quot;message&quot;:&quot;&amp;lt;span class=\'hs_kw50_co&amp;gt;

&amp;gt;python e:/python/demo.py
&amp;lt;re.Match object; span=(167291, 233943), match='var config = {&quot;message&quot;:&quot;&amp;lt;span class=\'hs_kw50_co&amp;gt; &amp;lt;re.Match object; span=(233952, 442342), match='var option = {&quot;message&quot;:&quot;&amp;lt;span class=\'hs_kw16_op&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;处理汽车参数&quot;&gt;处理汽车参数&lt;/h3&gt;
&lt;p&gt;通过正则表达式的search方法，匹配数据，然后调用group(0) 即可得到相关的数据&lt;/p&gt;
&lt;pre class=&quot;py&quot;&gt;
&lt;code&gt;def get_detail(html):
    
    config = re.search(&quot;var config = (.*?)};&quot;, html, re.S)  
    option = re.search(&quot;var option = (.*?)};&quot;, html, re.S)
    
    # 处理汽车参数
    car_info = &quot;&quot; 
    if config and option :
        car_info = car_info + config.group(0) + option.group(0)

    print(car_info)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;拿到数据之后，没有完，这是混淆之后的数据，需要解析回去，继续关注网页源代码，发现一段奇怪的JS。这段JS先不用管，留点印象即可~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/4/28/16a62caa307288ca?w=1803&amp;amp;h=745&amp;amp;f=png&amp;amp;s=190617&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;关键字破解&quot;&gt;关键字破解&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/4/28/16a62caa31a3a7b7?w=806&amp;amp;h=547&amp;amp;f=png&amp;amp;s=91653&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;注意到&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;span class=&quot;hs_kw28_configfH&quot;&amp;gt;&amp;lt;/span&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;hs_kw数字_configfH&lt;/code&gt;是一个span的class&lt;/p&gt;
&lt;p&gt;我选中&lt;code&gt;span&lt;/code&gt;之后的&lt;code&gt;::before&lt;/code&gt;&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/4/28/16a62caa31ea611f?w=643&amp;amp;h=537&amp;amp;f=png&amp;amp;s=88298&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;对应的css为&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/4/28/16a62caa7711b40d?w=279&amp;amp;h=153&amp;amp;f=png&amp;amp;s=7344&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;发现&lt;code&gt;实测&lt;/code&gt;两个字出现了，对应的class请记住&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;.hs_kw28_configfH::before&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;全局搜索一下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/4/28/16a62caa87720a7f?w=708&amp;amp;h=187&amp;amp;f=png&amp;amp;s=20037&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;双击找到来源&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/4/28/16a62caa7fc8fcb3?w=797&amp;amp;h=333&amp;amp;f=png&amp;amp;s=76766&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;确定数据就在html源码当中。&lt;/p&gt;
&lt;p&gt;格式化html源码，在内部搜索&lt;code&gt;hs_kw&lt;/code&gt;，找到关键函数&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/4/28/16a62caa8700114d?w=606&amp;amp;h=448&amp;amp;f=png&amp;amp;s=46134&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;                function $GetClassName$($index$) {
                    return '.hs_kw' + $index$ + '_baikeCt';
                }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段JS的来源就是我们刚才保留的那个JS代码段，复制所有的JS源码，到source里面新建一个&lt;code&gt;snippet&lt;/code&gt;，然后我们运行一下。&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/4/28/16a62caa8dd8a239?w=714&amp;amp;h=187&amp;amp;f=png&amp;amp;s=24732&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;在里面代码最后添加一个断点，&lt;code&gt;ctrl+enter&lt;/code&gt;运行&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/4/28/16a62caa92c17f13?w=1100&amp;amp;h=408&amp;amp;f=png&amp;amp;s=18231&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;运行到断点，在右侧就能看到一些参数出现&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/4/28/16a62caa97e30dd9?w=1607&amp;amp;h=299&amp;amp;f=png&amp;amp;s=53174&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;$ruleDict$:&lt;/li&gt;
&lt;li&gt;$rulePosList$&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/4/28/16a62caaa5d89380?w=1100&amp;amp;h=369&amp;amp;f=png&amp;amp;s=58879&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;通过参数去查找，核心的替换方法&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/4/28/16a62caaba889e6b?w=646&amp;amp;h=610&amp;amp;f=png&amp;amp;s=43178&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来，我们进行替换操作，这部流程需要用到selenium进行替换&lt;/p&gt;
&lt;p&gt;核心代码如下，主要的注释，我写在了代码内部，希望能帮助你看懂&lt;/p&gt;
&lt;pre class=&quot;py&quot;&gt;
&lt;code&gt;def write_html(js_list,car_info):
    # 运行JS的DOM -- 这部破解是最麻烦的，非常耗时间~参考了互联网上的大神代码
    DOM = (&quot;var rules = '2';&quot;
       &quot;var document = {};&quot;
       &quot;function getRules(){return rules}&quot;
       &quot;document.createElement = function() {&quot;
       &quot;      return {&quot;
       &quot;              sheet: {&quot;
       &quot;                      insertRule: function(rule, i) {&quot;
       &quot;                              if (rules.length == 0) {&quot;
       &quot;                                      rules = rule;&quot;
       &quot;                              } else {&quot;
       &quot;                                      rules = rules + '#' + rule;&quot;
       &quot;                              }&quot;
       &quot;                      }&quot;
       &quot;              }&quot;
       &quot;      }&quot;
       &quot;};&quot;
       &quot;document.querySelectorAll = function() {&quot;
       &quot;      return {};&quot;
       &quot;};&quot;
       &quot;document.head = {};&quot;
       &quot;document.head.appendChild = function() {};&quot;

       &quot;var window = {};&quot;
       &quot;window.decodeURIComponent = decodeURIComponent;&quot;)

    # 把JS文件写入到文件中去
    for item in js_list:
        DOM = DOM + item
    html_type = &quot;&amp;lt;html&amp;gt;&amp;lt;meta http-equiv='Content-Type' content='text/html; charset=utf-8' /&amp;gt;&amp;lt;head&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;    &amp;lt;script type='text/javascript'&amp;gt;&quot;
    # 拼接成一个可以运行的网页
    js = html_type + DOM + &quot; document.write(rules)&amp;lt;/script&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&quot;    
    # 再次运行的时候，请把文件删除，否则无法创建同名文件，或者自行加验证即可
    with open(&quot;./demo.html&quot;, &quot;w&quot;, encoding=&quot;utf-8&quot;) as f:
        f.write(js)

    # 通过selenium将数据读取出来，进行替换
    driver = webdriver.PhantomJS()
    driver.get(&quot;./demo.html&quot;)
    # 读取body部分
    text = driver.find_element_by_tag_name('body').text   
    # 匹配车辆参数中所有的span标签
    span_list = re.findall(&quot;&amp;lt;span(.*?)&amp;gt;&amp;lt;/span&amp;gt;&quot;, car_info)  # car_info 是我上面拼接的字符串

    # 按照span标签与text中的关键字进行替换
    for span in span_list:
        # 这个地方匹配的是class的名称  例如 &amp;lt;span class='hs_kw7_optionZl'&amp;gt;&amp;lt;/span&amp;gt; 匹配   hs_kw7_optionZl 出来
        info = re.search(&quot;'(.*?)'&quot;, span)
        if info:
            class_info = str(info.group(1)) + &quot;::before { content:(.*?)}&quot;  # 拼接为  hs_kw7_optionZl::before { content:(.*?)}             
            content = re.search(class_info, text).group(1)   # 匹配文字内容，返回结果为 &quot;实测&quot;&quot;油耗&quot;&quot;质保&quot;
                                    
            car_info = car_info.replace(str(&quot;&amp;lt;span class='&quot; + info.group(1) + &quot;'&amp;gt;&amp;lt;/span&amp;gt;&quot;),
                                        re.search(&quot;\&quot;(.*?)\&quot;&quot;, content).group(1))
    print(car_info)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/4/28/16a62caaaea657ce?w=762&amp;amp;h=223&amp;amp;f=png&amp;amp;s=112043&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;对比一下原来数据，发现问题不大，完成任务。&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/4/28/16a62caad1760be4?w=915&amp;amp;h=116&amp;amp;f=png&amp;amp;s=18867&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;入库操作&quot;&gt;入库操作&lt;/h2&gt;
&lt;p&gt;剩下的步骤就是数据持久化了，数据拿到之后，其他的都是比较简单的，希望你可以直接搞定。&lt;/p&gt;
&lt;h3 id=&quot;小扩展格式化js&quot;&gt;小扩展：格式化JS&lt;/h3&gt;
&lt;p&gt;碰到这种JS，直接找到格式化工具处理它&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://tool.oschina.net/codeformat/js/&quot; class=&quot;uri&quot;&gt;http://tool.oschina.net/codeformat/js/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;格式完成之后，代码具备一定的阅读能力&lt;/p&gt;
&lt;h2 id=&quot;思路汇总&quot;&gt;思路汇总&lt;/h2&gt;
&lt;p&gt;汽车之家用CSS隐藏了部分真实的字体，在解决的过程中，需要首先针对class去查找，当找到JS位置的时候，必须要搞定它的加密规则，顺着规则之后，只需要完成基本的key、value替换就可以拿到真实的数据了。&lt;/p&gt;
&lt;h2 id=&quot;关注公众账号非本科程序员&quot;&gt;关注公众账号：非本科程序员&lt;/h2&gt;
&lt;p&gt;关注之后，发送【汽车】获取源码&lt;/p&gt;
</description>
<pubDate>Sun, 28 Apr 2019 07:16:00 +0000</pubDate>
<dc:creator>梦想橡皮擦</dc:creator>
<og:description>说说这个网站 汽车之家，反爬神一般的存在，字体反爬的鼻祖网站，这个网站的开发团队，一定擅长前端吧，2019年4月19日开始写这篇博客，不保证这个代码可以存活到月底，希望后来爬虫coder，继续和汽车之</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/happymeng/p/10784177.html</dc:identifier>
</item>
<item>
<title>.Net开发者必知的技术类RSS订阅指南 - Enjoy233</title>
<link>http://www.cnblogs.com/enjoy233/p/technical_rss_subscription_guide_for_dotNet_developers.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/enjoy233/p/technical_rss_subscription_guide_for_dotNet_developers.html</guid>
<description>&lt;p&gt;作为一个.Net开发者，在如今这个信息大爆炸时代，网络上.net开发方面的信息浩如烟海(获取信息的渠道很多，比如各种 APP、公众号、聚合信息网站、博客园、InfoQ等等)，如何用有限的时间来获取并消化有效信息显得格外重要。&lt;/p&gt;
&lt;p&gt;虽然我们获取信息的取到很多，但也存在如下缺点：&lt;/p&gt;
&lt;ul readability=&quot;0.98356164383562&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;非常耗时，且极易分散个人注意力&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;对于微信公众号，由于微信中自己订阅了各种公众号，哪些是技术的，哪些不是技术的，即使加星标，也不一定能及时阅读&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;对于App平台，比如: 博客园、CSDN、&lt;a href=&quot;https://juejin.im/&quot;&gt;掘金&lt;/a&gt;、开发者头条、牛客网等，相信你并不愿意一个个安装，然后再去筛选有效信息&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;好在最近找到了一个很不错的有效解决方法，今天分享给大家，这个方法就是&lt;strong&gt;「订阅 RSS 源」&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;RSS(Really Simple Syndication，简易信息聚合)是一种消息来源格式规范，表达了&lt;strong&gt;「聚合真的很简单」&lt;/strong&gt;这样一种理念，使用RSS订阅，我们可以通过最短路径将感兴趣的网上内容抽取出来后推送给自己，不失为目前最有效的定制个性化推送信息的方式。&lt;/p&gt;

&lt;p&gt;首先，给大家分享一些.net开发者不容错过的RSS订阅源地址。&lt;/p&gt;
&lt;h2 id=&quot;net基金会&quot;&gt;.Net基金会&lt;/h2&gt;
&lt;p&gt;RSS 地址: &lt;a href=&quot;https://www.dotnetfoundation.org/blog&quot; class=&quot;uri&quot;&gt;https://www.dotnetfoundation.org/blog&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;msdn中文版-杂志&quot;&gt;MSDN中文版 杂志&lt;/h2&gt;
&lt;p&gt;这是微软官方的最新技术前沿，RSS分中文版和英文版:&lt;/p&gt;
&lt;p&gt;中文版地址: &lt;a href=&quot;http://ftr.fivefilters.org/makefulltextfeed.php?url=https%3A%2F%2Ffeed43.com%2F0781432610337857.xml&amp;amp;max=10&amp;amp;summary=1&quot;&gt;http://ftr.fivefilters.org/makefulltextfeed.php?url=https%3A%2F%2Ffeed43.com%2F0781432610337857.xml&amp;amp;max=10&amp;amp;summary=1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;英文版地址: &lt;a href=&quot;https://docs.microsoft.com/en-us/msdn-files/feeds/msdn/en-us/magazine/rss.xml&quot; class=&quot;uri&quot;&gt;https://docs.microsoft.com/en-us/msdn-files/feeds/msdn/en-us/magazine/rss.xml&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;微软-github-系列&quot;&gt;微软 Github 系列&lt;/h3&gt;
&lt;p&gt;本人在之前的文章中提到微软的&lt;code&gt;github&lt;/code&gt;开源项目有统一的入口&lt;a href=&quot;https://opensource.microsoft.com&quot; class=&quot;uri&quot;&gt;https://opensource.microsoft.com&lt;/a&gt; 或 &lt;a href=&quot;https://microsoft.github.io&quot; class=&quot;uri&quot;&gt;https://microsoft.github.io&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;本人为该网站创建了RSS订阅功能，RSS订阅地址为&lt;a href=&quot;http://ftr.fivefilters.org/makefulltextfeed.php?url=https%3A%2F%2Fopensource.microsoft.com%2F&amp;amp;max=10&quot;&gt;http://ftr.fivefilters.org/makefulltextfeed.php?url=https%3A%2F%2Fopensource.microsoft.com%2F&amp;amp;max=10&lt;/a&gt;，或者 &lt;a href=&quot;http://www.feed43.com/8078656626535244.xml&quot; class=&quot;uri&quot;&gt;http://www.feed43.com/8078656626535244.xml&lt;/a&gt;，同时我还创建了一个全文RSS的版本: &lt;a href=&quot;https://feedex.net/feed/www.feed43.com/8078656626535244.xml&quot; class=&quot;uri&quot;&gt;https://feedex.net/feed/www.feed43.com/8078656626535244.xml&lt;/a&gt;，按需取用吧。&lt;/p&gt;
&lt;h2 id=&quot;微软devblog系列&quot;&gt;微软DevBlog系列&lt;/h2&gt;
&lt;h2 id=&quot;infoq中文版系列&quot;&gt;InfoQ中文版系列&lt;/h2&gt;
&lt;p&gt;借助于&lt;code&gt;RSSHub&lt;/code&gt;，这里给出&lt;strong&gt;InfoQ中文 - RSS源完整版&lt;/strong&gt;，请按需取用。&lt;/p&gt;
&lt;p&gt;InfoQ中文- 语言 &amp;amp; 开发 &lt;a href=&quot;https://rsshub.app/infoq/topic/1&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/1&lt;/a&gt;&lt;br/&gt;InfoQ中文- 架构 &lt;a href=&quot;https://rsshub.app/infoq/topic/8&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/8&lt;/a&gt;&lt;br/&gt;InfoQ中文- 文化 &amp;amp; 方法 &lt;a href=&quot;https://rsshub.app/infoq/topic/3&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/3&lt;/a&gt;&lt;br/&gt;InfoQ中文- DevOps &lt;a href=&quot;https://rsshub.app/infoq/topic/4&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/4&lt;/a&gt;&lt;br/&gt;InfoQ中文- Java &lt;a href=&quot;https://rsshub.app/infoq/topic/6&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/6&lt;/a&gt;&lt;br/&gt;InfoQ中文- .NET &lt;a href=&quot;https://rsshub.app/infoq/topic/7&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/7&lt;/a&gt; ✔&lt;br/&gt;InfoQ中文- AI &lt;a href=&quot;https://rsshub.app/infoq/topic/31&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/31&lt;/a&gt;&lt;br/&gt;InfoQ中文- 敏捷 &lt;a href=&quot;https://rsshub.app/infoq/topic/9&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/9&lt;/a&gt;&lt;br/&gt;InfoQ中文- 云计算 &lt;a href=&quot;https://rsshub.app/infoq/topic/11&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/11&lt;/a&gt;&lt;br/&gt;InfoQ中文- Ruby &lt;a href=&quot;https://rsshub.app/infoq/topic/10&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/10&lt;/a&gt;&lt;br/&gt;InfoQ中文- 移动 &lt;a href=&quot;https://rsshub.app/infoq/topic/13&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/13&lt;/a&gt;&lt;br/&gt;InfoQ中文- SOA &lt;a href=&quot;https://rsshub.app/infoq/topic/12&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/12&lt;/a&gt;&lt;br/&gt;InfoQ中文- JavaScript &lt;a href=&quot;https://rsshub.app/infoq/topic/14&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/14&lt;/a&gt;&lt;br/&gt;InfoQ中文- 大数据 &lt;a href=&quot;https://rsshub.app/infoq/topic/15&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/15&lt;/a&gt;&lt;br/&gt;InfoQ中文- 开源 &lt;a href=&quot;https://rsshub.app/infoq/topic/17&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/17&lt;/a&gt;&lt;br/&gt;InfoQ中文- Android &lt;a href=&quot;https://rsshub.app/infoq/topic/16&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/16&lt;/a&gt;&lt;br/&gt;InfoQ中文- Google &lt;a href=&quot;https://rsshub.app/infoq/topic/19&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/19&lt;/a&gt;&lt;br/&gt;InfoQ中文- iOS &lt;a href=&quot;https://rsshub.app/infoq/topic/18&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/18&lt;/a&gt;&lt;br/&gt;InfoQ中文- 微软 &lt;a href=&quot;https://rsshub.app/infoq/topic/20&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/20&lt;/a&gt;&lt;br/&gt;InfoQ中文- 安全 &lt;a href=&quot;https://rsshub.app/infoq/topic/21&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/21&lt;/a&gt;&lt;br/&gt;InfoQ中文- 最佳实践 &lt;a href=&quot;https://rsshub.app/infoq/topic/36&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/36&lt;/a&gt;&lt;br/&gt;InfoQ中文- 前端 &lt;a href=&quot;https://rsshub.app/infoq/topic/33&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/33&lt;/a&gt;&lt;br/&gt;InfoQ中文- 数据库 &lt;a href=&quot;https://rsshub.app/infoq/topic/29&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/29&lt;/a&gt;&lt;br/&gt;InfoQ中文- AWS &lt;a href=&quot;https://rsshub.app/infoq/topic/26&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/26&lt;/a&gt;&lt;br/&gt;InfoQ中文- 运维 &lt;a href=&quot;https://rsshub.app/infoq/topic/38&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/38&lt;/a&gt;&lt;br/&gt;InfoQ中文- Web框架 &lt;a href=&quot;https://rsshub.app/infoq/topic/24&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/24&lt;/a&gt;&lt;br/&gt;InfoQ中文- 测试 &lt;a href=&quot;https://rsshub.app/infoq/topic/25&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/25&lt;/a&gt;&lt;br/&gt;InfoQ中文- HTML5 &lt;a href=&quot;https://rsshub.app/infoq/topic/22&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/22&lt;/a&gt;&lt;br/&gt;InfoQ中文- 编程语言 &lt;a href=&quot;https://rsshub.app/infoq/topic/32&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/32&lt;/a&gt;&lt;br/&gt;InfoQ中文- 机器学习 &lt;a href=&quot;https://rsshub.app/infoq/topic/41&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/41&lt;/a&gt; ✔&lt;br/&gt;InfoQ中文- Scrum &lt;a href=&quot;https://rsshub.app/infoq/topic/23&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/23&lt;/a&gt;&lt;br/&gt;InfoQ中文- 方法论 &lt;a href=&quot;https://rsshub.app/infoq/topic/48&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/48&lt;/a&gt;&lt;br/&gt;InfoQ中文- 社区 &lt;a href=&quot;https://rsshub.app/infoq/topic/34&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/34&lt;/a&gt;&lt;br/&gt;InfoQ中文- 技术管理 &lt;a href=&quot;https://rsshub.app/infoq/topic/43&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/43&lt;/a&gt;&lt;br/&gt;InfoQ中文- REST &lt;a href=&quot;https://rsshub.app/infoq/topic/28&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/28&lt;/a&gt;&lt;br/&gt;InfoQ中文- Ruby on Rails &lt;a href=&quot;https://rsshub.app/infoq/topic/27&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/27&lt;/a&gt;&lt;br/&gt;InfoQ中文- QCon &lt;a href=&quot;https://rsshub.app/infoq/topic/30&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/30&lt;/a&gt;&lt;br/&gt;InfoQ中文- Kubernetes (k8s) &lt;a href=&quot;https://rsshub.app/infoq/topic/51&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/51&lt;/a&gt; ✔&lt;br/&gt;InfoQ中文- Azure &lt;a href=&quot;https://rsshub.app/infoq/topic/40&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/40&lt;/a&gt;&lt;br/&gt;InfoQ中文- 区块链 &lt;a href=&quot;https://rsshub.app/infoq/topic/81&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/81&lt;/a&gt;&lt;br/&gt;InfoQ中文- C# &lt;a href=&quot;https://rsshub.app/infoq/topic/35&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/35&lt;/a&gt; ✔&lt;br/&gt;InfoQ中文- Node.js &lt;a href=&quot;https://rsshub.app/infoq/topic/37&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/37&lt;/a&gt;&lt;br/&gt;InfoQ中文- Facebook &lt;a href=&quot;https://rsshub.app/infoq/topic/42&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/42&lt;/a&gt;&lt;br/&gt;InfoQ中文- 物联网 &lt;a href=&quot;https://rsshub.app/infoq/topic/45&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/45&lt;/a&gt;&lt;br/&gt;InfoQ中文- 深度学习 &lt;a href=&quot;https://rsshub.app/infoq/topic/69&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/69&lt;/a&gt;&lt;br/&gt;InfoQ中文- 持续集成 &lt;a href=&quot;https://rsshub.app/infoq/topic/39&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/39&lt;/a&gt;&lt;br/&gt;InfoQ中文- 阿里巴巴 &lt;a href=&quot;https://rsshub.app/infoq/topic/61&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/61&lt;/a&gt;&lt;br/&gt;InfoQ中文- 微服务 &lt;a href=&quot;https://rsshub.app/infoq/topic/70&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/70&lt;/a&gt;&lt;br/&gt;InfoQ中文- Linux &lt;a href=&quot;https://rsshub.app/infoq/topic/44&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/44&lt;/a&gt;&lt;br/&gt;InfoQ中文- Oracle &lt;a href=&quot;https://rsshub.app/infoq/topic/46&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/46&lt;/a&gt;&lt;br/&gt;InfoQ中文- 百度 &lt;a href=&quot;https://rsshub.app/infoq/topic/54&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/54&lt;/a&gt;&lt;br/&gt;InfoQ中文- Apache &lt;a href=&quot;https://rsshub.app/infoq/topic/52&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/52&lt;/a&gt;&lt;br/&gt;InfoQ中文- 容器 &lt;a href=&quot;https://rsshub.app/infoq/topic/68&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/68&lt;/a&gt;&lt;br/&gt;InfoQ中文- Python &lt;a href=&quot;https://rsshub.app/infoq/topic/50&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/50&lt;/a&gt;&lt;br/&gt;InfoQ中文- 精益 &lt;a href=&quot;https://rsshub.app/infoq/topic/47&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/47&lt;/a&gt;&lt;br/&gt;InfoQ中文- 《架构师》月刊 &lt;a href=&quot;https://rsshub.app/infoq/topic/88&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/88&lt;/a&gt;&lt;br/&gt;InfoQ中文- Apple &lt;a href=&quot;https://rsshub.app/infoq/topic/53&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/53&lt;/a&gt;&lt;br/&gt;InfoQ中文- GitHub &lt;a href=&quot;https://rsshub.app/infoq/topic/56&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/56&lt;/a&gt;&lt;br/&gt;InfoQ中文- 性能调优 &lt;a href=&quot;https://rsshub.app/infoq/topic/57&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/57&lt;/a&gt;&lt;br/&gt;InfoQ中文- InfoQ &lt;a href=&quot;https://rsshub.app/infoq/topic/66&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/66&lt;/a&gt;&lt;br/&gt;InfoQ中文- IDE &lt;a href=&quot;https://rsshub.app/infoq/topic/49&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/49&lt;/a&gt;&lt;br/&gt;InfoQ中文- MySQL &lt;a href=&quot;https://rsshub.app/infoq/topic/55&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/55&lt;/a&gt;&lt;br/&gt;InfoQ中文- 阿里云 &lt;a href=&quot;https://rsshub.app/infoq/topic/74&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/74&lt;/a&gt;&lt;br/&gt;InfoQ中文- IBM &lt;a href=&quot;https://rsshub.app/infoq/topic/58&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/58&lt;/a&gt;&lt;br/&gt;InfoQ中文- 腾讯 &lt;a href=&quot;https://rsshub.app/infoq/topic/78&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/78&lt;/a&gt;&lt;br/&gt;InfoQ中文- 设计模式 &lt;a href=&quot;https://rsshub.app/infoq/topic/64&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/64&lt;/a&gt;&lt;br/&gt;InfoQ中文- 持续交付 &lt;a href=&quot;https://rsshub.app/infoq/topic/63&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/63&lt;/a&gt;&lt;br/&gt;InfoQ中文- ArchSummit &lt;a href=&quot;https://rsshub.app/infoq/topic/65&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/65&lt;/a&gt;&lt;br/&gt;InfoQ中文- JVM &lt;a href=&quot;https://rsshub.app/infoq/topic/59&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/59&lt;/a&gt;&lt;br/&gt;InfoQ中文- 算法 &lt;a href=&quot;https://rsshub.app/infoq/topic/84&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/84&lt;/a&gt;&lt;br/&gt;InfoQ中文- 治理 &lt;a href=&quot;https://rsshub.app/infoq/topic/62&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/62&lt;/a&gt;&lt;br/&gt;InfoQ中文- Book Review &lt;a href=&quot;https://rsshub.app/infoq/topic/60&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/60&lt;/a&gt;&lt;br/&gt;InfoQ中文- C++ &lt;a href=&quot;https://rsshub.app/infoq/topic/67&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/67&lt;/a&gt;&lt;br/&gt;InfoQ中文- 腾讯云 &lt;a href=&quot;https://rsshub.app/infoq/topic/79&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/79&lt;/a&gt;&lt;br/&gt;InfoQ中文- Chrome &lt;a href=&quot;https://rsshub.app/infoq/topic/71&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/71&lt;/a&gt;&lt;br/&gt;InfoQ中文- 企业动态 &lt;a href=&quot;https://rsshub.app/infoq/topic/147&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/147&lt;/a&gt;&lt;br/&gt;InfoQ中文- 架构师 &lt;a href=&quot;https://rsshub.app/infoq/topic/82&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/82&lt;/a&gt;&lt;br/&gt;InfoQ中文- Windows Azure &lt;a href=&quot;https://rsshub.app/infoq/topic/73&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/73&lt;/a&gt; ✔&lt;br/&gt;InfoQ中文- 函数式编程 &lt;a href=&quot;https://rsshub.app/infoq/topic/72&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/72&lt;/a&gt;&lt;br/&gt;InfoQ中文- Windows &lt;a href=&quot;https://rsshub.app/infoq/topic/80&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/80&lt;/a&gt;&lt;br/&gt;InfoQ中文- PHP &lt;a href=&quot;https://rsshub.app/infoq/topic/77&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/77&lt;/a&gt; ✔&lt;br/&gt;InfoQ中文- 重构 &lt;a href=&quot;https://rsshub.app/infoq/topic/76&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/76&lt;/a&gt;&lt;br/&gt;InfoQ中文- Scala &lt;a href=&quot;https://rsshub.app/infoq/topic/75&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/75&lt;/a&gt;&lt;br/&gt;InfoQ中文- 其他 &lt;a href=&quot;https://rsshub.app/infoq/topic/107&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/107&lt;/a&gt;&lt;br/&gt;InfoQ中文- TGO鲲鹏会 &lt;a href=&quot;https://rsshub.app/infoq/topic/96&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/96&lt;/a&gt;&lt;br/&gt;InfoQ中文- Spark &lt;a href=&quot;https://rsshub.app/infoq/topic/87&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/87&lt;/a&gt;&lt;br/&gt;InfoQ中文- 产业互联网 &lt;a href=&quot;https://rsshub.app/infoq/topic/157&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/157&lt;/a&gt;&lt;br/&gt;InfoQ中文- TensorFlow &lt;a href=&quot;https://rsshub.app/infoq/topic/89&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/89&lt;/a&gt;&lt;br/&gt;InfoQ中文- 硬件 &lt;a href=&quot;https://rsshub.app/infoq/topic/108&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/108&lt;/a&gt;&lt;br/&gt;InfoQ中文- Git &lt;a href=&quot;https://rsshub.app/infoq/topic/85&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/85&lt;/a&gt;&lt;br/&gt;InfoQ中文- Go &lt;a href=&quot;https://rsshub.app/infoq/topic/98&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/98&lt;/a&gt;&lt;br/&gt;InfoQ中文- ThoughtWorks &lt;a href=&quot;https://rsshub.app/infoq/topic/86&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/86&lt;/a&gt;&lt;br/&gt;InfoQ中文- CDN &lt;a href=&quot;https://rsshub.app/infoq/topic/90&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/90&lt;/a&gt;&lt;br/&gt;InfoQ中文- RedHat &lt;a href=&quot;https://rsshub.app/infoq/topic/91&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/91&lt;/a&gt;&lt;br/&gt;InfoQ中文- 云原生 &lt;a href=&quot;https://rsshub.app/infoq/topic/106&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/106&lt;/a&gt; ✔&lt;br/&gt;InfoQ中文- 双十一 &lt;a href=&quot;https://rsshub.app/infoq/topic/1111&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/1111&lt;/a&gt;&lt;br/&gt;InfoQ中文- 百度云 &lt;a href=&quot;https://rsshub.app/infoq/topic/94&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/94&lt;/a&gt;&lt;br/&gt;InfoQ中文- NLP &lt;a href=&quot;https://rsshub.app/infoq/topic/126&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/126&lt;/a&gt;&lt;br/&gt;InfoQ中文- APM &lt;a href=&quot;https://rsshub.app/infoq/topic/92&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/92&lt;/a&gt;&lt;br/&gt;InfoQ中文- Erlang &lt;a href=&quot;https://rsshub.app/infoq/topic/93&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/93&lt;/a&gt;&lt;br/&gt;InfoQ中文- 华为 &lt;a href=&quot;https://rsshub.app/infoq/topic/145&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/145&lt;/a&gt;&lt;br/&gt;InfoQ中文- JetBrains &lt;a href=&quot;https://rsshub.app/infoq/topic/95&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/95&lt;/a&gt;&lt;br/&gt;InfoQ中文- Mozilla &lt;a href=&quot;https://rsshub.app/infoq/topic/97&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/97&lt;/a&gt;&lt;br/&gt;InfoQ中文- 网络 &lt;a href=&quot;https://rsshub.app/infoq/topic/116&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/116&lt;/a&gt;&lt;br/&gt;InfoQ中文- 计算机视觉 &lt;a href=&quot;https://rsshub.app/infoq/topic/127&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/127&lt;/a&gt;&lt;br/&gt;InfoQ中文- 公链 &lt;a href=&quot;https://rsshub.app/infoq/topic/132&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/132&lt;/a&gt;&lt;br/&gt;InfoQ中文- 高可用 &lt;a href=&quot;https://rsshub.app/infoq/topic/117&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/117&lt;/a&gt;&lt;br/&gt;InfoQ中文- 联盟链 &lt;a href=&quot;https://rsshub.app/infoq/topic/133&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/133&lt;/a&gt;&lt;br/&gt;InfoQ中文- 自动驾驶 &lt;a href=&quot;https://rsshub.app/infoq/topic/125&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/125&lt;/a&gt;&lt;br/&gt;InfoQ中文- SQL &lt;a href=&quot;https://rsshub.app/infoq/topic/152&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/152&lt;/a&gt;&lt;br/&gt;InfoQ中文- 京东618 &lt;a href=&quot;https://rsshub.app/infoq/topic/110&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/110&lt;/a&gt;&lt;br/&gt;InfoQ中文- Hadoop &lt;a href=&quot;https://rsshub.app/infoq/topic/111&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/111&lt;/a&gt;&lt;br/&gt;InfoQ中文- 网络协议 &lt;a href=&quot;https://rsshub.app/infoq/topic/154&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/154&lt;/a&gt;&lt;br/&gt;InfoQ中文- AWS re:Invent &lt;a href=&quot;https://rsshub.app/infoq/topic/130&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/130&lt;/a&gt;&lt;br/&gt;InfoQ中文- 工程效率 &lt;a href=&quot;https://rsshub.app/infoq/topic/129&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/129&lt;/a&gt;&lt;br/&gt;InfoQ中文- Docker &lt;a href=&quot;https://rsshub.app/infoq/topic/118&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/118&lt;/a&gt;&lt;br/&gt;InfoQ中文- Serverless &lt;a href=&quot;https://rsshub.app/infoq/topic/119&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/119&lt;/a&gt;&lt;br/&gt;InfoQ中文- 小程序 &lt;a href=&quot;https://rsshub.app/infoq/topic/141&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/141&lt;/a&gt;&lt;br/&gt;InfoQ中文- 信息泄露 &lt;a href=&quot;https://rsshub.app/infoq/topic/148&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/148&lt;/a&gt;&lt;br/&gt;InfoQ中文- Swift &lt;a href=&quot;https://rsshub.app/infoq/topic/113&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/113&lt;/a&gt;&lt;br/&gt;InfoQ中文- MongoDB &lt;a href=&quot;https://rsshub.app/infoq/topic/122&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/122&lt;/a&gt;&lt;br/&gt;InfoQ中文- Service Mesh &lt;a href=&quot;https://rsshub.app/infoq/topic/139&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/139&lt;/a&gt;&lt;br/&gt;InfoQ中文- 数据可视化 &lt;a href=&quot;https://rsshub.app/infoq/topic/140&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/140&lt;/a&gt;&lt;br/&gt;InfoQ中文- 面试 &lt;a href=&quot;https://rsshub.app/infoq/topic/137&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/137&lt;/a&gt;&lt;br/&gt;InfoQ中文- 华为云 &lt;a href=&quot;https://rsshub.app/infoq/topic/146&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/146&lt;/a&gt;&lt;br/&gt;InfoQ中文- 强化学习 &lt;a href=&quot;https://rsshub.app/infoq/topic/138&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/138&lt;/a&gt;&lt;br/&gt;InfoQ中文- 小米 &lt;a href=&quot;https://rsshub.app/infoq/topic/135&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/135&lt;/a&gt;&lt;br/&gt;InfoQ中文- 质量保证 &lt;a href=&quot;https://rsshub.app/infoq/topic/128&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/128&lt;/a&gt;&lt;br/&gt;InfoQ中文- 数据处理 &lt;a href=&quot;https://rsshub.app/infoq/topic/1118&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/1118&lt;/a&gt;&lt;br/&gt;InfoQ中文- Rust &lt;a href=&quot;https://rsshub.app/infoq/topic/142&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/142&lt;/a&gt;&lt;br/&gt;InfoQ中文- Fintech &lt;a href=&quot;https://rsshub.app/infoq/topic/131&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/131&lt;/a&gt;&lt;br/&gt;InfoQ中文- Uber &lt;a href=&quot;https://rsshub.app/infoq/topic/143&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/143&lt;/a&gt;&lt;br/&gt;InfoQ中文- 视频 &lt;a href=&quot;https://rsshub.app/infoq/topic/134&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/134&lt;/a&gt;&lt;br/&gt;InfoQ中文- 财报 &lt;a href=&quot;https://rsshub.app/infoq/topic/114&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/114&lt;/a&gt;&lt;br/&gt;InfoQ中文- Kotlin &lt;a href=&quot;https://rsshub.app/infoq/topic/112&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/112&lt;/a&gt;&lt;br/&gt;InfoQ中文- 电商 &lt;a href=&quot;https://rsshub.app/infoq/topic/1117&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/1117&lt;/a&gt;&lt;br/&gt;InfoQ中文- Kafka &lt;a href=&quot;https://rsshub.app/infoq/topic/144&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/144&lt;/a&gt;&lt;br/&gt;InfoQ中文- 生态链 &lt;a href=&quot;https://rsshub.app/infoq/topic/136&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/136&lt;/a&gt;&lt;br/&gt;InfoQ中文- 旷视 &lt;a href=&quot;https://rsshub.app/infoq/topic/155&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/155&lt;/a&gt;&lt;br/&gt;InfoQ中文- Redis &lt;a href=&quot;https://rsshub.app/infoq/topic/121&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/121&lt;/a&gt;&lt;br/&gt;InfoQ中文- AIOps &lt;a href=&quot;https://rsshub.app/infoq/topic/120&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/120&lt;/a&gt;&lt;br/&gt;InfoQ中文- OpenStack &lt;a href=&quot;https://rsshub.app/infoq/topic/115&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/115&lt;/a&gt;&lt;br/&gt;InfoQ中文- 医疗 &lt;a href=&quot;https://rsshub.app/infoq/topic/160&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/160&lt;/a&gt;&lt;br/&gt;InfoQ中文- 增强现实 &lt;a href=&quot;https://rsshub.app/infoq/topic/151&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/151&lt;/a&gt;&lt;br/&gt;InfoQ中文- 金融 &lt;a href=&quot;https://rsshub.app/infoq/topic/159&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/159&lt;/a&gt;&lt;br/&gt;InfoQ中文- 制造 &lt;a href=&quot;https://rsshub.app/infoq/topic/158&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/158&lt;/a&gt;&lt;br/&gt;InfoQ中文- FreeWheel &lt;a href=&quot;https://rsshub.app/infoq/topic/149&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/149&lt;/a&gt;&lt;br/&gt;InfoQ中文- 唯品会 &lt;a href=&quot;https://rsshub.app/infoq/topic/1114&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/1114&lt;/a&gt;&lt;br/&gt;InfoQ中文- 知乎 &lt;a href=&quot;https://rsshub.app/infoq/topic/1112&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/1112&lt;/a&gt;&lt;br/&gt;InfoQ中文- 虚拟现实 &lt;a href=&quot;https://rsshub.app/infoq/topic/150&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/150&lt;/a&gt;&lt;br/&gt;InfoQ中文- 逆向工程 &lt;a href=&quot;https://rsshub.app/infoq/topic/124&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/124&lt;/a&gt;&lt;br/&gt;InfoQ中文- 闲鱼 &lt;a href=&quot;https://rsshub.app/infoq/topic/1116&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/1116&lt;/a&gt;&lt;br/&gt;InfoQ中文- 京东 &lt;a href=&quot;https://rsshub.app/infoq/topic/1115&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/1115&lt;/a&gt;&lt;br/&gt;InfoQ中文- 部署 &lt;a href=&quot;https://rsshub.app/infoq/topic/1113&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/1113&lt;/a&gt;&lt;br/&gt;InfoQ中文- 生成对抗网络 &lt;a href=&quot;https://rsshub.app/infoq/topic/153&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/153&lt;/a&gt;&lt;br/&gt;InfoQ中文- GPU &lt;a href=&quot;https://rsshub.app/infoq/topic/123&quot; class=&quot;uri&quot;&gt;https://rsshub.app/infoq/topic/123&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.infoq.com/news/2014/02/infoq-topics-rss&quot;&gt;InfoQ英文版&lt;/a&gt; 的各topic(主题)自带RSS功能，就不再列了，自己有兴趣到页面上找一下就好了。&lt;/p&gt;
&lt;h2 id=&quot;如果找到大佬的-twitteryoutubestackoverflow-的订阅源&quot;&gt;如果找到大佬的 Twitter/Youtube/Stackoverflow 的订阅源&lt;/h2&gt;
&lt;h3 id=&quot;twitter-订阅举例&quot;&gt;Twitter 订阅举例&lt;/h3&gt;
&lt;p&gt;大家知道 C#/TypeScript之父 Anders Hejlsberg 是没有个人博客的，但他有Twitter&lt;a href=&quot;https://twitter.com/ahejlsberg&quot; class=&quot;uri&quot;&gt;https://twitter.com/ahejlsberg&lt;/a&gt;，使用网站&lt;a href=&quot;https://twitrss.me/&quot; class=&quot;uri&quot;&gt;https://twitrss.me/&lt;/a&gt;可得到相应的RSS订阅地址为: &lt;a href=&quot;https://twitrss.me/twitter_user_to_rss/?user=ahejlsberg&quot; class=&quot;uri&quot;&gt;https://twitrss.me/twitter_user_to_rss/?user=ahejlsberg&lt;/a&gt;，接下来贴进RSS reader就能接收更新了。&lt;/p&gt;
&lt;h3 id=&quot;youtube订阅举例&quot;&gt;Youtube订阅举例&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Youtube 频道&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;而入选.Net基金会Board(理事会)的美女微软MVP - &lt;code&gt;Iris Classon&lt;/code&gt;除了有个人博客之外，她还有Youtube喔。那怎么订阅这个地方的信息呢？&lt;/p&gt;
&lt;p&gt;只需在&lt;code&gt;Chrome&lt;/code&gt;上安装好油猴(Tampermonkey)插件，贴入本人写的一段&lt;code&gt;JS&lt;/code&gt;脚本 &lt;a href=&quot;https://gist.github.com/yanglr/3b76229aa3015c7777e3baca6fd49732&quot; class=&quot;uri&quot;&gt;https://gist.github.com/yanglr/3b76229aa3015c7777e3baca6fd49732&lt;/a&gt;。然后打开相应的Youtube页面，进入&lt;code&gt;CHANNELS&lt;/code&gt;，会发现有个&lt;code&gt;RSS Link&lt;/code&gt;出现，复制其链接地址&lt;a href=&quot;https://www.youtube.com/feeds/videos.xml?channel_id=UChUJLb50mNALThfUuZZn7QA&quot; class=&quot;uri&quot;&gt;https://www.youtube.com/feeds/videos.xml?channel_id=UChUJLb50mNALThfUuZZn7QA&lt;/a&gt;，贴到RSS阅读器中就可以收到更新了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/436938/201904/436938-20190428150026459-1190234834.png&quot; alt=&quot;1556427882484&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Youtube 用户&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;举例: &lt;a href=&quot;https://rsshub.app/youtube/user/JFlaMusic/&quot; class=&quot;uri&quot;&gt;https://rsshub.app/youtube/user/JFlaMusic/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;路由: /youtube/user/:username/:embed?&lt;/p&gt;
&lt;p&gt;参数:&lt;/p&gt;
&lt;p&gt;username, 必选 - 用户名&lt;br/&gt;embed, 可选 - 默认为开启内嵌视频, 任意值为关闭&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Youtube 播放列表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;举例: &lt;a href=&quot;https://rsshub.app/youtube/playlist/PLqQ1RwlxOgeLTJ1f3fNMSwhjVgaWKo_9Z&quot; class=&quot;uri&quot;&gt;https://rsshub.app/youtube/playlist/PLqQ1RwlxOgeLTJ1f3fNMSwhjVgaWKo_9Z&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;路由: /youtube/playlist/:id/:embed?&lt;/p&gt;
&lt;p&gt;参数:&lt;/p&gt;
&lt;p&gt;id, 必选 - 播放列表 id&lt;br/&gt;embed, 可选 - 默认为开启内嵌视频, 任意值为关闭&lt;/p&gt;
&lt;p&gt;同样的方法可定义《深入浅出WPF》一书作者刘铁锰老师的&lt;code&gt;Youtube&lt;/code&gt;频道&lt;a href=&quot;https://www.youtube.com/user/waspec/playlists?pbjreload=10&quot;&gt;Smart College&lt;/a&gt;.&lt;br/&gt;铁猛老师前一段时间还推出了深入浅出UWP视频课程，相关课件的&lt;a href=&quot;https://github.com/yanglr/wpf_in-depth_explanation/tree/master/courseware&quot;&gt;传送门&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&quot;stack-overflow订阅举例&quot;&gt;Stack overflow订阅举例&lt;/h3&gt;
&lt;p&gt;比如，我最近比较关心.net core，我找到&lt;code&gt;coreFx&lt;/code&gt;项目的活跃开发者&lt;code&gt;Jon Hanna&lt;/code&gt;，&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/436938/201904/436938-20190428150057456-745788400.png&quot; alt=&quot;1556426119175&quot;/&gt;&lt;br/&gt;进入他的博客发现并没有新的什么博客文章，发现他喜欢在stackoverflow上答题，其主页为&lt;a href=&quot;https://stackoverflow.com/users/400547/jon-hanna&quot; class=&quot;uri&quot;&gt;https://stackoverflow.com/users/400547/jon-hanna&lt;/a&gt;。而Stackoverflow本来就提供了RSS功能，找到他的RSS地址&lt;a href=&quot;https://stackoverflow.com/feeds/user/400547&quot; class=&quot;uri&quot;&gt;https://stackoverflow.com/feeds/user/400547&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;具体操作是：&lt;/p&gt;
&lt;p&gt;先进入他在Stackoverflow上的主页，然后切换到&lt;code&gt;Activity&lt;/code&gt;, 向下拖到页面最下方，会有个rss订阅按钮，复制上面的链接，贴到RSS阅读器中就可以收到更新了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/436938/201904/436938-20190428150111738-734174858.png&quot; alt=&quot;1556428621042&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来把该RSS地址放进RSS reader或推送到自己的邮箱就可以了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;UWP方向&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;WPF方向&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ASP.net方向&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;蒋金楠 博客园RSS地址:&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;.Net跨平台方向&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Windows应用开发方向&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;其他.net跨平台相关&quot;&gt;其他.Net跨平台相关&lt;/h2&gt;

&lt;p&gt;可参考本人旧文: &lt;a href=&quot;https://blog.csdn.net/lzuacm/article/details/11734051&quot;&gt;运用在线RSS阅读器订阅微信公众账号的日志&lt;/a&gt;，方法依然有效。&lt;/p&gt;
&lt;h2 id=&quot;github上如何订阅一个组织的repo更新&quot;&gt;Github上如何订阅一个组织的Repo更新&lt;/h2&gt;
&lt;p&gt;此部分摘录于RSShub文档: &lt;a href=&quot;https://docs.rsshub.app/programming.html#github&quot; class=&quot;uri&quot;&gt;https://docs.rsshub.app/programming.html#github&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;GitHub 官方也提供了一些 RSS:&lt;/p&gt;

&lt;p&gt;订阅用户的仓库，举例: &lt;a href=&quot;https://rsshub.app/github/repos/yanglr&quot; class=&quot;uri&quot;&gt;https://rsshub.app/github/repos/yanglr&lt;/a&gt;&lt;br/&gt;订阅组织的仓库，举例: &lt;a href=&quot;https://rsshub.app/github/repos/enjoy233&quot; class=&quot;uri&quot;&gt;https://rsshub.app/github/repos/enjoy233&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;路由: &lt;code&gt;/github/repos/:user(or organization)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;参数:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;user/organization, 必选 - 用户名或组织名&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;举例: &lt;a href=&quot;https://rsshub.app/github/trending/daily/javascript&quot; class=&quot;uri&quot;&gt;https://rsshub.app/github/trending/daily/javascript&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;路由: &lt;code&gt;/github/trending/:since/:language?&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;参数:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;since, 必选 - 时间跨度, 可在 &lt;a href=&quot;https://github.com/trending/javascript?since=monthly&quot;&gt;Trending 页&lt;/a&gt; URL 中找到, 可选 daily weekly monthly&lt;/li&gt;
&lt;li&gt;language, 可选 - 语言, 可在 &lt;a href=&quot;https://github.com/trending/javascript?since=monthly&quot;&gt;Trending 页&lt;/a&gt; URL 中找到&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;举例: &lt;a href=&quot;https://rsshub.app/github/issue/DIYgod/RSSHub&quot; class=&quot;uri&quot;&gt;https://rsshub.app/github/issue/DIYgod/RSSHub&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;路由: &lt;code&gt;/github/issue/:user/:repo&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;参数:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;user, 必选 - 用户名&lt;/li&gt;
&lt;li&gt;repo, 必选 - 仓库名&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;举例: &lt;a href=&quot;https://rsshub.app/github/pull/DIYgod/RSSHub&quot; class=&quot;uri&quot;&gt;https://rsshub.app/github/pull/DIYgod/RSSHub&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;路由: &lt;code&gt;/github/pull/:user/:repo&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;参数:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;user, 必选 - 用户名&lt;/li&gt;
&lt;li&gt;repo, 必选 - 仓库名&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;举例: &lt;a href=&quot;https://rsshub.app/github/user/followers/HenryQW&quot; class=&quot;uri&quot;&gt;https://rsshub.app/github/user/followers/HenryQW&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;路由: &lt;code&gt;/github/user/followers/:user&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;参数:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;user, 必选 - 用户名&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;举例: &lt;a href=&quot;https://rsshub.app/github/stars/DIYgod/RSSHub&quot; class=&quot;uri&quot;&gt;https://rsshub.app/github/stars/DIYgod/RSSHub&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;路由: &lt;code&gt;/github/stars/:user/:repo&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;参数:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;user, 必选 - 用户名&lt;/li&gt;
&lt;li&gt;repo, 必选 - 仓库名&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;举例: &lt;a href=&quot;https://rsshub.app/github/branches/DIYgod/RSSHub&quot; class=&quot;uri&quot;&gt;https://rsshub.app/github/branches/DIYgod/RSSHub&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;路由: &lt;code&gt;/github/branches/:user/:repo&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;参数:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;user, 必选 - 用户名&lt;/li&gt;
&lt;li&gt;repo, 必选 - 仓库名&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;举例: &lt;a href=&quot;https://rsshub.app/github/search/RSSHub/bestmatch/desc&quot; class=&quot;uri&quot;&gt;https://rsshub.app/github/search/RSSHub/bestmatch/desc&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;路由: &lt;code&gt;/github/search/:query/:sort?/:order?&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;参数:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;query, 必选 - 搜索关键词&lt;/li&gt;
&lt;li&gt;sort, 可选 - 排序选项（默认为bestmatch）&lt;/li&gt;
&lt;li&gt;order, 可选 - 排序顺序，desc和asc（默认desc降序）&lt;/li&gt;
&lt;/ul&gt;&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;最佳匹配&lt;/td&gt;
&lt;td&gt;bestmatch&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;根据 star 数量排序&lt;/td&gt;
&lt;td&gt;stars&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;根据 fork 数量排序&lt;/td&gt;
&lt;td&gt;forks&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;根据更新时间排序&lt;/td&gt;
&lt;td&gt;updated&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;有些RSS源，订阅之后发现只能阅读摘要。对于这种情形，可使用一些在线工具将其转换为全文RSS。&lt;/p&gt;
&lt;p&gt;这些工具一般被称为&lt;code&gt;RSS expander&lt;/code&gt;或&lt;code&gt;RSS enlarger&lt;/code&gt;. 目前还有效的免费工具主要有下面几个:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.FeedEx&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;FeedEx.Net:The Feed Expander 挺好用&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://feedex.net/&quot; class=&quot;uri&quot;&gt;https://feedex.net/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.Full-Text RSS Feeds - fivefilters&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Full-TextRSS Feeds | fivefilters.org &lt;a href=&quot;https://fivefilters.org/content-only/&quot; class=&quot;uri&quot;&gt;https://fivefilters.org/content-only/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.Full RSS - Full text rss feed generator&lt;/strong&gt; &lt;a href=&quot;https://www.freefullrss.com/&quot; class=&quot;uri&quot;&gt;https://www.freefullrss.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用方法: 打开工具网站，贴入原RSS地址，点击按钮进行转换即可。&lt;/p&gt;

&lt;p&gt;在线RSS阅读器，推荐Feedly 或 InoReader。&lt;/p&gt;
&lt;p&gt;离线版，推荐 &lt;a href=&quot;http://www.feeddemon.com/&quot;&gt;Feed Demon&lt;/a&gt; 和 &lt;a href=&quot;http://www.jetbrains.com/omea/download/&quot;&gt;Omega reader&lt;/a&gt;. 前者中添加订阅的按钮在很显眼的地方，就不再赘述。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/436938/201904/436938-20190428150147900-2035093375.png&quot; alt=&quot;1556424964661&quot;/&gt;&lt;/p&gt;
&lt;p&gt;后者中，添加订阅的方法为:&lt;/p&gt;
&lt;p&gt;依次进入: &lt;strong&gt;All&lt;/strong&gt; -&amp;gt; &lt;strong&gt;Feeds&lt;/strong&gt; -&amp;gt; &lt;strong&gt;+Subscribe&lt;/strong&gt;，然后填入rss地址。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/436938/201904/436938-20190428150206587-730805519.png&quot; alt=&quot;1556424889899&quot;/&gt;&lt;/p&gt;

&lt;p&gt;除了使用阅读器阅读RSS信息以外，还可以使用email推送功能，使用方法也很简单。&lt;/p&gt;
&lt;p&gt;先注册账号&lt;a href=&quot;https://blogtrottr.com/signup/&quot;&gt;Blogtrottr&lt;/a&gt;(完全免费)，&lt;/p&gt;
&lt;p&gt;激活后，Add subscription，填入RSS地址，然后设置好提醒频率。&lt;/p&gt;
&lt;p&gt;只要对方有更新，你就会收到一封邮件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/436938/201904/436938-20190428150224132-1377235697.png&quot; alt=&quot;1556426870505&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于极少数RSS，这个工具可能搞不定，当然此时有个替代工具&lt;a href=&quot;https://www.feed2mail.com/&quot;&gt;Feed2Mail&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;文中有✔的地方是本人已设置好邮件通知的部分RSS.&lt;/p&gt;
&lt;p&gt;就酱，有了RSS，重要信息你也可以和国内各个&lt;code&gt;.Net&lt;/code&gt;开发大佬同步了，希望对大家有所帮助~&lt;/p&gt;

&lt;p&gt;查看本人&lt;strong&gt;最近其他原创作品&lt;/strong&gt;请移步(想第一时刻阅读本人最新文章请在&lt;strong&gt;博客园&lt;/strong&gt;上&lt;strong&gt;关注我&lt;/strong&gt;):&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;参考资料:&lt;/strong&gt;&lt;br/&gt;RSSHub文档 &lt;a href=&quot;https://docs.rsshub.app/&quot; class=&quot;uri&quot;&gt;https://docs.rsshub.app/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 28 Apr 2019 07:05:00 +0000</pubDate>
<dc:creator>Enjoy233</dc:creator>
<og:description>作为一个.Net开发者，在如今这个信息大爆炸时代，网络上.net开发方面的信息浩如烟海(获取信息的渠道很多，比如各种 APP、公众号、聚合信息网站、博客园、InfoQ等等)，如何用有限的时间来获取并消</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/enjoy233/p/technical_rss_subscription_guide_for_dotNet_developers.html</dc:identifier>
</item>
<item>
<title>【填坑纪事】一次用System.nanoTime()填坑System.currentTimeMills()的实例记录 - 宋者为王</title>
<link>http://www.cnblogs.com/andy-songwei/p/10784049.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/andy-songwei/p/10784049.html</guid>
<description>&lt;p&gt;       JDK提供了两个方法，System.currentTimeMillis()和System.nanoTime()，这两个方法都可以用来获取表征当前时间的数值。但是如果不仔细辨别这两个方法的差别和联系，在使用当中也很容易出错。笔者在前不久的工作当中使用System.currentTimeMillis()时就踩了一个大坑，后来在查明System.currentTimeMillis()和System.nanoTime()的特性后，才用System.nanoTime()来填了这个坑。本文，笔者就以自己的踩坑和填坑经历来介绍一下这两个方法。&lt;/p&gt;

&lt;p&gt; &lt;strong&gt;一、事故回顾&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       文章的开头，笔者先描述一下自己前不久工作当中碰到的一个bug，分析过程以及解决办法。&lt;/p&gt;
&lt;p&gt;  1、问题描述&lt;/p&gt;
&lt;p&gt;        当手机按power键亮屏时，会调用人脸解锁功能来解锁手机。如果高频率不停地按power键，人脸解锁功能会被不停地调用，这样会产生很多并发问题，导致一些不可预料的异常，同时在这么高频率下，也没有必要每次亮屏都调用人脸解锁功能，需要过滤掉其中一部分调用。当时的处理办法是，当上一次调用人脸解锁功能的时候记录当前时间点 long mLastUnlockTime = System.currentTimeMillis(); 当再次调用的时候，也记录当前时间点 long nowUnlockTime = System.currentTimeMillis()。然后判断这两者的时间差 long durTime = nowUnlockTime - mLastUnlockTime，如果durTime&amp;lt;=300，表示距离上次调用不到300毫秒，本次不允许继续调用；如果durTime&amp;gt;300，表示距离上一次调用已经超过300毫秒了，则允许这一次继续调用，并把nowUnlockTime 的值赋给mLastUnlockTime，用于进行下一次的判断。&lt;/p&gt;
&lt;p&gt;       按照这个思路，就是防止300毫秒内连续调用两次人脸解锁功能，这种设计看起来似乎没什么问题。但是这个设计在正常运行了几个月后，测试人员提了一个bug：如果在系统设置中把时间往回调，那么人脸解锁功能就失效了。&lt;/p&gt;
&lt;p&gt;  2、原因分析&lt;/p&gt;
&lt;p&gt;       当收到这个bug后，我百思不得其解，调个系统时间能把人脸解锁功能给调失效了？我一度觉得这个现象很奇葩，不过作为一名老猿，我当然是去关键部分添加log分析原因了，最终定位到，是durTime出现问题了，居然出现了负数！！！这个时间差怎么会出现负数呢？仔细分析后才发现，这是System.currentTimeMills()的特性所致：该方法记录的是系统时间距离1970年1月1日的毫秒数。当把时间往前调了，本次获取的时间点nowUnlockTime 当然就小于上一次记录的时间值了，那自然而然 durTime 就是负数了。&lt;/p&gt;
&lt;p&gt;  3、解决办法&lt;/p&gt;
&lt;p&gt;       后来和某同事聊天，说起了这个听起来似乎挺奇葩的现象，同事说推荐我去了解一下System.namoTime()这个方法。后来用 System.namoTime() 取代 System.currentTimeMillis() 后，问题就迎刃而解了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二、System.currentTimeMillis()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  1、系统源码说明&lt;/p&gt;
&lt;p&gt;       咱们这里先看看系统类System.java中对currentTimeMillis()的官方说明。如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;     * Returns the current time in milliseconds.  Note that
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;     * while the unit of time of the return value is a millisecond,
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     * the granularity of the value depends on the underlying
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;     * operating system and may be larger.  For example, many
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;     * operating systems measure time in units of tens of
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;     * milliseconds.
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;     * &amp;lt;p&amp;gt; See the description of the class &amp;lt;code&amp;gt;Date&amp;lt;/code&amp;gt; for
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;     * a discussion of slight discrepancies that may arise between
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;     * &quot;computer time&quot; and coordinated universal time (UTC).
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt;  the difference, measured in milliseconds, between
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;     *          the current time and midnight, January 1, 1970 UTC.
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@see&lt;/span&gt;&lt;span&gt;     java.util.Date
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; currentTimeMillis();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  2、翻译&lt;/p&gt;
&lt;p&gt;       这里咱们翻译一下系统源码中的注释：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;1  以毫秒的方式返回当前时间。请注意，虽然返回值的时间单位是毫秒，但是这个值的粒度取决于底层操作系统并且可能粒度更大。例如，许多操作系统是以几十毫秒为粒度测量时间的。
2  有关于“计算机时间”和协调世界时（UTC）之间的细微差别， 请查阅“Date”类。
3  @return 当前时间和1970年1月1日午夜之间的差值，以毫秒来测量。
4  @see java.util.Date&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  3、补充说明&lt;/p&gt;
&lt;p&gt;       （1）从源码中可以看到，这个方式是一个native方法，该值由底层提供。&lt;/p&gt;
&lt;p&gt;       （2）该方法可以用来计算当前日期，当前星期几等，与Date的换算非常方便，JDK提供了相关的接口来换算。&lt;/p&gt;
&lt;p&gt;       （3）通过该方法获取的值的依据是当前系统的日期和时间，可以在系统设置中进行设置和修改。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;三、System.nanoTime()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  1、系统源码说明&lt;/p&gt;
&lt;p&gt;       这里先看看系统类System.java中对nanoTime()的官方说明。如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;     * Returns the current value of the running Java Virtual Machine's
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;     * high-resolution time source, in nanoseconds.
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;     * &amp;lt;p&amp;gt;This method can only be used to measure elapsed time and is
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;     * not related to any other notion of system or wall-clock time.
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;     * The value returned represents nanoseconds since some fixed but
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;     * arbitrary &amp;lt;i&amp;gt;origin&amp;lt;/i&amp;gt; time (perhaps in the future, so values
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;     * may be negative).  The same origin is used by all invocations of
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;     * this method in an instance of a Java virtual machine; other
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;     * virtual machine instances are likely to use a different origin.
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;     * &amp;lt;p&amp;gt;This method provides nanosecond precision, but not necessarily
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;     * nanosecond resolution (that is, how frequently the value changes)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;     * - no guarantees are made except that the resolution is at least as
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;     * good as that of {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #currentTimeMillis()}.
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;     * &amp;lt;p&amp;gt;Differences in successive calls that span greater than
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;     * approximately 292 years (2&amp;lt;sup&amp;gt;63&amp;lt;/sup&amp;gt; nanoseconds) will not
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;     * correctly compute elapsed time due to numerical overflow.
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;     * &amp;lt;p&amp;gt;The values returned by this method become meaningful only when
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;     * the difference between two such values, obtained within the same
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;     * instance of a Java virtual machine, is computed.
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;     * &amp;lt;p&amp;gt; For example, to measure how long some code takes to execute:
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;     *  &amp;lt;pre&amp;gt; {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;     * long startTime = System.nanoTime();
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;     * // ... the code being measured ...
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;     * long estimatedTime = System.nanoTime() - startTime;}&amp;lt;/pre&amp;gt;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;     * &amp;lt;p&amp;gt;To compare two nanoTime values
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;     *  &amp;lt;pre&amp;gt; {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;     * long t0 = System.nanoTime();
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;     * ...
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;     * long t1 = System.nanoTime();}&amp;lt;/pre&amp;gt;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;     * one should use {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; t1 - t0 &amp;lt; 0}, not {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; t1 &amp;lt; t0},
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;     * because of the possibility of numerical overflow.
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; the current value of the running Java Virtual Machine's
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;     *         high-resolution time source, in nanoseconds
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@since&lt;/span&gt;&lt;span&gt; 1.5
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; nanoTime();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  2、翻译&lt;/p&gt;
&lt;p&gt;       这里先翻译一下系统源码中的注释：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt; 1 返回正在运行的Java虚拟机的高分辨率时间源的当前值，以纳秒计。
 2 
 3 该方法可能仅仅用于测量已经逝去的时间，并且与任何其它系统或者挂钟时间概念无关。该返回值表示从某个固定但任意的原点时间（可能在未来，所以值可能是负数）开始的纳秒数。在一个java虚拟机实例中，所有该方法的调用都使用相同的原点；其它虚拟机实例很可能使用不同的源头。
 4 
 5 该方法提供了纳秒级别的精度，但是不一定是纳秒级分辨率（也就是该值改变的频率）———— 除非这个分辨率至少和currentTimeMillis()一样好，否则将不会做任何保证。
 6 
 7 在跨越大于292年（2的63次方纳秒）左右的连续调用中，这个差值将不能正确地计算已经过去的时间，因为数字溢出。
 8 
 9 仅仅只有当在同一java虚拟机实例中获取的两个值之间的差值被计算时，返回值才有意义。
10 
11 例如，去测量某代码执行花费了多长时间：
12  long startTime = System.nanoTime(); 
13  //...被测量的代码... 
14  long estimatedTime = System.nanoTime() - startTime;
15 
16 要比较两个nanoTime的值：
17  long t0 = System.nanoTime();
18  ... 
19  long t1 = System.nanoTime()。
20 因为数字溢出的可能性，您应该使用&quot;t1 - t0 &amp;lt; 0&quot;，而不是&quot;t1 &amp;lt; t0&quot;（来判断它们的大小，笔者注）。
21 @return 当前正在运行的java虚拟机的高精度时间资源值，以纳秒为单位。
22 @since 1.5&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 3、补充说明&lt;/p&gt;
&lt;p&gt;    （1）该方法也是一个本地方法，返回值由底层提供。&lt;/p&gt;
&lt;p&gt;    （2）如注释中所说，该方法从java 1.5开始引入。 &lt;/p&gt;
&lt;p&gt;    （3）该方法所基于的时间是随机的，但在同一个JVM中，不同的地方使用的原点时间是一样的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;四、两者的区别与选择&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       前面对System.currentTimeMillis()和System.nanoTime()都分别从源码注释的角度进行了介绍，算是比较详细了，这里再简单终结一下，顺便谈一谈工作中如何选择：&lt;/p&gt;
&lt;p&gt;    （1）System.nanoTime()的精确度更高一些，如今的硬件设备性能越来越好，如果要更精密计算执行某行代码或者某块代码所消耗的时间，该方法会测量得更精确。开发者可以根据需要的精确度来选择用哪一个方法。&lt;/p&gt;
&lt;p&gt;    （2）单独获取System.nanoTime()没有什么意义，因为该值是随机的，无法表示当前的时间。如果要记录当前时间点，用System.currentTimeMills()。&lt;/p&gt;
&lt;p&gt;    （3）System.currentTimeMills()得到的值能够和Date类方便地转换，jdk提供了多个接口来实现；但是System.nanoTime()则不行。&lt;/p&gt;
&lt;p&gt;    （4） System.currentTimeMills()的值是基于系统时间的，可以人为地进行修改；而System.nanoTime()则不能，所以如文章开头笔者碰到的问题一样，如果需要根据时间差来过滤某些频繁的操作，用System.nanoTime()会比较合适。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;五、结语&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       程序中往往某一行简单的代码，都包含了很多的知识点，真正推敲起来，似乎没有简单的东西。计算机世界浩如烟海，知识博大精深，我等只能望洋兴叹啊！！！本文的内容是基于自己平时的工作实践，然后做的总结，如果有错误的地方或者不妥的地方，还请不吝赐教，谢谢！&lt;/p&gt;
</description>
<pubDate>Sun, 28 Apr 2019 07:02:00 +0000</pubDate>
<dc:creator>宋者为王</dc:creator>
<og:description>JDK提供了两个方法，System.currentTimeMillis()和System.nanoTime()，这两个方法都可以用来获取表征当前时间的数值。但是如果不仔细辨别这两个方法的差别和联系，在</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/andy-songwei/p/10784049.html</dc:identifier>
</item>
<item>
<title>Java集合--TreeSet详细解析 - 取个名字咋这难</title>
<link>http://www.cnblogs.com/-1007813544/p/10780898.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/-1007813544/p/10780898.html</guid>
<description>&lt;p&gt;谈到TreeSet的特点，估计大家脑海里想到的都是：有序，不可重复，红黑树，基于Treemap实现，自定义排序等特点。这篇博客帮助大家从源码梳理下TreeSet的知识点。&lt;/p&gt;
&lt;h3 id=&quot;构造函数&quot;&gt;1.构造函数&lt;/h3&gt;
&lt;p&gt;TreeSet提供了四种构造器&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;TreeSet()&lt;/li&gt;
&lt;li&gt;TreeSet(Collection&amp;lt; ? extends E&amp;gt; c)&lt;/li&gt;
&lt;li&gt;TreeSet(Comparator&amp;lt; ? super E&amp;gt; comparator)&lt;/li&gt;
&lt;li&gt;TreeSet(SortedSet&amp;lt; E &amp;gt; s)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;四种构造器在底层都调用了同一个方法。以无参构造函数为例。[1]处的this方法最终调用的是[2]的方法，其中四个构造器的传参都被TreeMap封装了一层。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;   public TreeSet() {
        this(new TreeMap&amp;lt;E,Object&amp;gt;()); //[1]
    }
    TreeSet(NavigableMap&amp;lt;E,Object&amp;gt; m) {//[2]
        this.m = m;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;增&quot;&gt;2.增&lt;/h3&gt;
&lt;p&gt;TreeSet在添加元素时，会把元素放入TreeMap中的key上来&lt;strong&gt;&lt;em&gt;确保元素的唯一性&lt;/em&gt;&lt;/strong&gt;，并让其value指向一个空对象。TreeSet#add()方法会调用TreeMap#put()方法添加元素，添加元素时，从树的根节点开始遍历直到找到新增元素的parent节点，添加进去。通过TreeMap的源码可以看出维护的是一个红黑树数据结构。&lt;/p&gt;
&lt;p&gt;PS:由于TreeSet的实例化时都会调用TreeMap的无参构造函数，此时&lt;br/&gt;TreeMap#comparator=null;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;   private static final Object PRESENT = new Object();
   
   public boolean add(E e) {
        return m.put(e, PRESENT)==null;
    }
    
    public  boolean addAll(Collection&amp;lt;? extends E&amp;gt; c) {
        // Use linear-time version if applicable
        if (m.size()==0 &amp;amp;&amp;amp; c.size() &amp;gt; 0 &amp;amp;&amp;amp;
            c instanceof SortedSet &amp;amp;&amp;amp;   //是否是SortedSet类或其子类
            m instanceof TreeMap) {
            SortedSet&amp;lt;? extends E&amp;gt; set = (SortedSet&amp;lt;? extends E&amp;gt;) c;
            TreeMap&amp;lt;E,Object&amp;gt; map = (TreeMap&amp;lt;E, Object&amp;gt;) m;
            Comparator&amp;lt;?&amp;gt; cc = set.comparator();
            Comparator&amp;lt;? super E&amp;gt; mc = map.comparator();
            if (cc==mc || (cc != null &amp;amp;&amp;amp; cc.equals(mc))) {//[3]
                map.addAllForTreeSet(set, PRESENT);
                return true;
            }
        }
        return super.addAll(c); // 不是SortedSet子类，就是Collection子类
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;删&quot;&gt;3.删&lt;/h3&gt;
&lt;p&gt;TreeSet中提供了两个和删除相关的方法。&lt;br/&gt;TreeSet#clear()复用了TreeMap#clear()方法，把root节点置为null,size置为0；&lt;br/&gt;通过TreeSet#remove()移除特定元素时，TreeSet首先先遍历出该元素，然后将红黑树中的元素置为null，重新平衡红黑树。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;   public boolean remove(Object o) {
        return m.remove(o)==PRESENT;
    }
    
       public void clear() {
        m.clear();
    }
    
        /**
     * Delete node p, and then rebalance the tree.
     */
    private void deleteEntry(Entry&amp;lt;K,V&amp;gt; p) {
        modCount++;
        size--;
        // If strictly internal, copy successor's element to p and then make p
        // point to successor.
        if (p.left != null &amp;amp;&amp;amp; p.right != null) {
            Entry&amp;lt;K,V&amp;gt; s = successor(p);
            p.key = s.key;
            p.value = s.value;
            p = s;
        } // p has 2 children

        // Start fixup at replacement node, if it exists.
        Entry&amp;lt;K,V&amp;gt; replacement = (p.left != null ? p.left : p.right);

        if (replacement != null) {
            // Link replacement to parent
            replacement.parent = p.parent;
            if (p.parent == null)
                root = replacement;
            else if (p == p.parent.left)
                p.parent.left  = replacement;
            else
                p.parent.right = replacement;

            // Null out links so they are OK to use by fixAfterDeletion.
            p.left = p.right = p.parent = null;

            // Fix replacement
            if (p.color == BLACK)
                fixAfterDeletion(replacement);
        } else if (p.parent == null) { // return if we are the only node.
            root = null;
        } else { //  No children. Use self as phantom replacement and unlink.
            if (p.color == BLACK)
                fixAfterDeletion(p);

            if (p.parent != null) {
                if (p == p.parent.left)
                    p.parent.left = null;
                else if (p == p.parent.right)
                    p.parent.right = null;
                p.parent = null;
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;比较器&quot;&gt;4.比较器&lt;/h3&gt;
&lt;p&gt;TreeSet中有两种排序，一个是自然排序，一个是重写compareTo()方法自定义排序。&lt;br/&gt;自然排序可以参考Integer，String等类中的实现。其顺序也是我们常见的“1,2,3,4”，“a,b,c,d”。假如我们想让Student对象中String类型的字段倒序输出呢&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Data
public class Student implements Comparable&amp;lt;Student&amp;gt;{
    String name;
    /**
     * 这里的参数o,其实是TreeMap中维护的根节点
     * @param o
     * @return
     */
    @Override
    public int compareTo(Student o) {
        System.out.println(&quot;name:&quot;+name+&quot;,参数:&quot;+o.getName());
        int i = this.name.compareTo(o.getName());
       return i==0?0:-i;
    }
}

public static void main(String[] args) {
        Set&amp;lt;Student&amp;gt; set = new TreeSet&amp;lt;&amp;gt;();
        Student a = new Student();
        a.setName(&quot;a&quot;);
        Student b = new Student();
        b.setName(&quot;b&quot;);
        Student c = new Student();
        c.setName(&quot;c&quot;);
        Student d = new Student();
        d.setName(&quot;d&quot;);
        Student e = new Student();
        e.setName(&quot;e&quot;);
        Student f = new Student();
        f.setName(&quot;f&quot;);
        set.add(a);
        set.add(c);
        set.add(e);
        set.add(b);
        set.add(d);
        set.add(f);
        for (Student str: set) {
            System.out.print(str.getName());
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其结果如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1049223/201904/1049223-20190427224420220-1644281782.png&quot;/&gt;&lt;br/&gt;从打印的日志可以看出，每次插入新的元素，都会从根节点开始遍历比较。当然TreeSet中也提供了我们倒序输出的方法。有兴趣可以自己试验下。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;descendingSet()&lt;/li&gt;
&lt;li&gt;descendingIterator()&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;TreeSet是通过TreeMap实现的一个有序的、不可重复的集合，底层维护的是红黑树结构。当TreeSet的泛型对象不是java的基本类型的包装类时，对象需要重写Comparable#compareTo()方法&lt;/p&gt;
</description>
<pubDate>Sun, 28 Apr 2019 06:58:00 +0000</pubDate>
<dc:creator>取个名字咋这难</dc:creator>
<og:description>[TOC] 谈到TreeSet的特点，估计大家脑海里想到的都是：有序，不可重复，红黑树，基于Treemap实现，自定义排序等特点。这篇博客帮助大家从源码梳理下TreeSet的知识点。 1.构造函数 T</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/-1007813544/p/10780898.html</dc:identifier>
</item>
<item>
<title>Hadoop InputFormat（一）输入文件分片 - ZacksTang</title>
<link>http://www.cnblogs.com/zackstang/p/10776857.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zackstang/p/10776857.html</guid>
<description>
&lt;p&gt;&lt;strong&gt;1. Mapper&lt;/strong&gt; &lt;strong&gt;&lt;span&gt;与&lt;/span&gt; Reducer&lt;/strong&gt; &lt;strong&gt;&lt;span&gt;数量&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于一个默认的&lt;/span&gt;MapReduce Job &lt;span&gt;来说，&lt;/span&gt;map&lt;span&gt;任务的数量等于输入文件被划分成的分块数，这个取决于输入文件的大小以及文件块的大小（如果此文件在&lt;/span&gt; HDFS&lt;span&gt;中）。但是对于&lt;/span&gt; reduce&lt;span&gt;的任务，并不会自动决定&lt;/span&gt;reducer&lt;span&gt;数目的大小，若未指定，则默认为&lt;/span&gt;1&lt;span&gt;。例如：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1287132/201904/1287132-20190428145434346-1746615595.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;但单个&lt;/span&gt;reducer&lt;span&gt;任务执行效率不尽人意，在实际场景中会将它设置为一个较大的数值。此时，决定&lt;/span&gt;Key&lt;span&gt;条目被送往哪个&lt;/span&gt;reducer&lt;span&gt;由方法&lt;/span&gt; setPartitionerClass() &lt;span&gt;指定：&lt;/span&gt;&lt;span&gt;job.setPartitionerClass(HashPartitioner.&lt;/span&gt;&lt;strong&gt;&lt;span&gt;class&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;);&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt; &lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;默认为&lt;/span&gt;&lt;span&gt;HashPartitioner&lt;/span&gt;&lt;span&gt;，它会将每条&lt;/span&gt;&lt;span&gt;Key&lt;/span&gt;&lt;span&gt;做&lt;/span&gt;&lt;span&gt;Hash&lt;/span&gt;&lt;span&gt;，然后与最大的整型值做一次按位与操作，以得到一个非负整数。然后对分区数做取模（&lt;/span&gt;&lt;span&gt;mod&lt;/span&gt;&lt;span&gt;）操作，将&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;分配到其中一个分区。这里的分区数即为&lt;/span&gt;&lt;span&gt;reducer&lt;/span&gt;&lt;span&gt;数目。&lt;/span&gt;&lt;span&gt;HashPartitioner &lt;/span&gt;&lt;span&gt;源码如下：&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;public class &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;HashPartitioner&amp;lt;K, V&amp;gt; &lt;/span&gt;&lt;strong&gt;&lt;span&gt;extends &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;Partitioner&amp;lt;K, V&amp;gt; {&lt;br/&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;public &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;HashPartitioner() {&lt;br/&gt;}&lt;/span&gt;&lt;strong&gt;&lt;span&gt;public int &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;getPartition(K key, V value, &lt;/span&gt;&lt;strong&gt;&lt;span&gt;int &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;numReduceTasks) {&lt;br/&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;return &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;(key.hashCode() &amp;amp; &lt;/span&gt;&lt;span&gt;2147483647&lt;/span&gt;&lt;span&gt;) % numReduceTasks;&lt;br/&gt;}&lt;br/&gt;}&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;若是为&lt;/span&gt;reducer&lt;span&gt;数目设置为默认值&lt;/span&gt;1&lt;span&gt;，则所有的中间数据都会被放入到一个&lt;/span&gt;reducer&lt;span&gt;中，作业处理效率会非常低效。若是设置了过大的值，则每个&lt;/span&gt;reducer&lt;span&gt;都会输出一个文件，会导致过多的小文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在为一个任务选择多少个&lt;/span&gt;reducer&lt;span&gt;个数时，应遵循的原则为：目标&lt;/span&gt;reducer&lt;span&gt;保持在每个运行&lt;/span&gt;5&lt;span&gt;分钟左右，且产生至少一个&lt;/span&gt;HDFS&lt;span&gt;块的输出比较合适。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;记录在发送给&lt;/span&gt; reducer &lt;span&gt;之前，会被&lt;/span&gt;MapReduce&lt;span&gt;系统进行排序。因此输入文件中的行会被交叉放入一个合并后的输出文件。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.&lt;/span&gt;&lt;/strong&gt; &lt;strong&gt;&lt;span&gt;输入格式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们已经了解到&lt;/span&gt;map&lt;span&gt;的输入是分片（&lt;/span&gt;split&lt;span&gt;），一个分片对应一个&lt;/span&gt;mapper&lt;span&gt;，且仅被一个&lt;/span&gt;mapper&lt;span&gt;处理。分片里面是多条记录（&lt;/span&gt;item&lt;span&gt;）。“输入分片”在&lt;/span&gt;Hadoop&lt;span&gt;中以&lt;/span&gt;InputSplit &lt;span&gt;接口的方式提供：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;public interface &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;InputSplit &lt;/span&gt;&lt;strong&gt;&lt;span&gt;extends &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;Writable {&lt;br/&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;long &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;getLength() &lt;/span&gt;&lt;strong&gt;&lt;span&gt;throws &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;IOException;&lt;p&gt;String[] getLocations() &lt;/p&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;throws &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;IOException;&lt;br/&gt;}&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;它包含两个方法，分别为&lt;/span&gt;getLength() &lt;span&gt;与&lt;/span&gt; getLocations()&lt;span&gt;。其中&lt;/span&gt;getLength() &lt;span&gt;用于获取数据的长度（以字节为单位）；&lt;/span&gt;getLocations() &lt;span&gt;用于获取一组存储位置（也就是一组主机名）。其中&lt;/span&gt;getLocations()&lt;span&gt;的返回值由&lt;/span&gt;mapreduce&lt;span&gt;系统获取后，实现&lt;/span&gt;data locality&lt;span&gt;，也就是尽量将&lt;/span&gt;map&lt;span&gt;任务放在离数据节点近的地方。而&lt;/span&gt;getLength() &lt;span&gt;的返回值用于排序分片，将最大的分片优先处理，以最小化整个作业运行的时间。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;InputSplit&lt;span&gt;（&lt;/span&gt;mapreduce&lt;span&gt;中的分片）由&lt;/span&gt;InputFormat&lt;span&gt;创建，它负责创建输入分片，并将它们分成一条条记录（&lt;/span&gt;item&lt;span&gt;）。首先简单看一下&lt;/span&gt;InputFormat &lt;span&gt;抽象类：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;public abstract class &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;InputFormat&amp;lt;K, V&amp;gt; {&lt;br/&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;public &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;InputFormat() {&lt;br/&gt;}&lt;/span&gt;&lt;strong&gt;&lt;span&gt;public abstract &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;List&amp;lt;InputSplit&amp;gt; getSplits(JobContext var1) &lt;/span&gt;&lt;strong&gt;&lt;span&gt;throws &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;IOException, InterruptedException;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;public abstract &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;RecordReader&amp;lt;K, V&amp;gt; createRecordReader(InputSplit var1, TaskAttemptContext var2) &lt;/span&gt;&lt;strong&gt;&lt;span&gt;throws &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;IOException, InterruptedException;&lt;br/&gt;}&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;这里&lt;/span&gt; getSplits() &lt;span&gt;方法计算分片，然后将计算得到的&lt;/span&gt;List &lt;span&gt;结果发给&lt;/span&gt; application master&lt;span&gt;。&lt;/span&gt;Application master &lt;span&gt;根据其分片所在节点信息，调度&lt;/span&gt;map&lt;span&gt;任务到离分片数据最近的节点。在&lt;/span&gt;map&lt;span&gt;任务端，会把输入分片传给&lt;/span&gt; InputFormat &lt;span&gt;的&lt;/span&gt; createRecordReader() &lt;span&gt;方法，此方法会返回一个&lt;/span&gt; RecordReader &lt;span&gt;对象，用于迭代读取这个分片上的记录（&lt;/span&gt;item&lt;span&gt;），并生成记录的键值对，之后传递给&lt;/span&gt; map&lt;span&gt;函数。通过查看&lt;/span&gt; Mapper &lt;span&gt;类中的&lt;/span&gt; run() &lt;span&gt;方法，更好的了解此过程：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;public void &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;run(Mapper&amp;lt;KEYIN, VALUEIN, KEYOUT, VALUEOUT&amp;gt;.Context context) &lt;/span&gt;&lt;strong&gt;&lt;span&gt;throws &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;IOException, InterruptedException {&lt;br/&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;this&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;.setup(context);&lt;/span&gt;&lt;strong&gt;&lt;span&gt;try &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;{&lt;br/&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;while&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;(context.nextKeyValue()) {&lt;br/&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;this&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;.map(context.getCurrentKey(), context.getCurrentValue(), context);&lt;br/&gt;}&lt;br/&gt;} &lt;/span&gt;&lt;strong&gt;&lt;span&gt;finally &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;{&lt;br/&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;this&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;.cleanup(context);&lt;br/&gt;}&lt;p&gt;}&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;这里，先运行&lt;/span&gt;setup() &lt;span&gt;操作，然后从&lt;/span&gt; context &lt;span&gt;不断迭代获取分片的内容，并传给&lt;/span&gt;map() &lt;span&gt;方法，并由&lt;/span&gt;map() &lt;span&gt;方法进一步对&lt;/span&gt; key-value &lt;span&gt;对进行处理。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;3. FileInputFormat&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;类&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在&lt;/span&gt;Hadoop &lt;span&gt;中，数据源一般为文件，而&lt;/span&gt; FileInputFormat &lt;span&gt;类就是用于处理数据源为文件的一个（继承于）&lt;/span&gt;InputFormat &lt;span&gt;类&lt;/span&gt;:&lt;/p&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;public abstract class &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;FileInputFormat&amp;lt;K, V&amp;gt; &lt;/span&gt;&lt;strong&gt;&lt;span&gt;implements &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;InputFormat&amp;lt;K, V&amp;gt; {&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;可以看到它是一个抽象类，它的实现类有&lt;/span&gt;CombineFileInputFormat&lt;span&gt;、&lt;/span&gt;TextInputFormat&lt;span&gt;、&lt;/span&gt;KeyValueTextInputFormat&lt;span&gt;、&lt;/span&gt;NLineInputFormat&lt;span&gt;以及&lt;/span&gt;SequenceFileInputFormat&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;FileInputFormat&lt;span&gt;类提供两个功能：&lt;/span&gt;1. &lt;span&gt;指出作业的输入文件位置；&lt;/span&gt;2. &lt;span&gt;为输入文件生成分片的代码实现。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在&lt;/span&gt;FileInputFormat&lt;span&gt;中，作业的输入可以是一个文件、一个目录，也可以是目录与文件的集合。它提供了四种方法用于设置&lt;/span&gt;Job&lt;span&gt;的输入路径：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;public static void &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;addInputPath(JobConf conf, Path path)&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;public static void &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;addInputPaths(JobConf conf, String commaSeparatedPaths)&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;public static void &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;setInputPaths(JobConf conf, Path... inputPaths)&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;public static void &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;setInputPaths(JobConf conf, String commaSeparatedPaths) &lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;其中&lt;/span&gt;addInputPath() &lt;span&gt;和&lt;/span&gt; addInputPaths() &lt;span&gt;用于添加路径，以构成路径列表。而&lt;/span&gt;setInputPath() &lt;span&gt;用于一次性设置完整的路径列表（会替换前面所有路径设置）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在设置路径后，也可以指定需要排除的特定文件，此功能由&lt;/span&gt; setInputPathFilter() &lt;span&gt;实现：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;public static void &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;setInputPathFilter(JobConf conf, Class&amp;lt;? &lt;/span&gt;&lt;strong&gt;&lt;span&gt;extends &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;PathFilter&amp;gt; filter) {&lt;br/&gt;conf.setClass(&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&quot;mapreduce.input.pathFilter.class&quot;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;, filter, PathFilter.&lt;/span&gt;&lt;strong&gt;&lt;span&gt;class&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;);&lt;br/&gt;}&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;它可以设置一个过滤器&lt;/span&gt;PathFilter&lt;span&gt;，默认的实现是过滤掉隐藏文件（以&lt;/span&gt; . &lt;span&gt;和&lt;/span&gt; _ &lt;span&gt;开头的文件）。如果通过&lt;/span&gt;setInputPathFilter() &lt;span&gt;设置过滤器，它会在默认过滤器的基础上进行过滤，也就是说，仅会在非隐藏文件中再次进行过滤。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;输入路径的设置可以通过属性与选项进行配置，在属性配置中相关配置为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;mapreduce.input.fileinputformat.inputdir &lt;span&gt;（逗号分隔属性，无默认值）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;mapreduce.input.pathFilter.class  &lt;span&gt;（&lt;/span&gt;PathFilter &lt;span&gt;类名，无默认值）&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;4. FileInputFormat&lt;/span&gt;&lt;/strong&gt; &lt;strong&gt;&lt;span&gt;类处理输入分片&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在设置了一组文件后，&lt;/span&gt;FileInputFormat&lt;span&gt;会将文件转换为输入分片。这里需要注意的是：在&lt;/span&gt;HDFS&lt;span&gt;中，一个文件可以占用（分布到）多个&lt;/span&gt;block&lt;span&gt;，但是不会存在一个&lt;/span&gt;block&lt;span&gt;中存多个文件。对于小文件（小于一个&lt;/span&gt;HDFS &lt;span&gt;块大小的文件）来说，一个文件就是占用一个&lt;/span&gt;block&lt;span&gt;，但是不会占据整个&lt;/span&gt;block&lt;span&gt;的空间。例如，当一个&lt;/span&gt;1MB&lt;span&gt;的文件存储在一个&lt;/span&gt;128MB &lt;span&gt;的块中时，文件只使用&lt;/span&gt; 1MB &lt;span&gt;的磁盘空间，而不是&lt;/span&gt;128MB&lt;span&gt;）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;FileInputFormat &lt;span&gt;只分割大文件，也就是文件超过&lt;/span&gt;HDFS&lt;span&gt;块的大小。在&lt;/span&gt;FileInputFormat&lt;span&gt;中，控制分片大小的属性有：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;mapreduce.input.fileinputformat.split.minsize  &lt;span&gt;一个文件分片最小的有效字节数（&lt;/span&gt;int&lt;span&gt;类型），默认值为&lt;/span&gt;1&lt;span&gt;（字节）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;mapreduce.input.fileinputformat.split.maxsize  &lt;span&gt;一个文件分片中最大的有效字节数（&lt;/span&gt;long &lt;span&gt;类型），默认值为&lt;/span&gt;Long.MAX_VALUE&lt;span&gt;，即&lt;/span&gt;9223372036854775807&lt;/p&gt;
&lt;p&gt;dfs.blocksize        HDFS&lt;span&gt;中的块大小（按字节），默认为&lt;/span&gt; 128MB&lt;span&gt;（即&lt;/span&gt; 134217728&lt;span&gt;）&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;最小分片通常为&lt;/span&gt;1&lt;span&gt;个字节，用户可以设置最小分片的大小超过&lt;/span&gt;HDFS &lt;span&gt;块大小，这样会强制分片比&lt;/span&gt;HDFS&lt;span&gt;块大。但是如果数据存储在&lt;/span&gt; HDFS &lt;span&gt;上，则这样对&lt;/span&gt;data locality &lt;span&gt;来说，并不友好，以至于延长任务执行时间。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最大分片默认是&lt;/span&gt; Java Long &lt;span&gt;类型的最大值，只有把它的值设置为小于&lt;/span&gt; HDFS Block &lt;span&gt;大小才有效，此时会强制分片比块小。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在&lt;/span&gt; FileInputFormat&lt;span&gt;中，分片的大小由以下公式计算：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;protected long &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;computeSplitSize(&lt;/span&gt;&lt;strong&gt;&lt;span&gt;long &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;blockSize, &lt;/span&gt;&lt;strong&gt;&lt;span&gt;long &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;minSize, &lt;/span&gt;&lt;strong&gt;&lt;span&gt;long &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;maxSize) {&lt;br/&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;return &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;Math.max(minSize, Math.min(maxSize, blockSize));&lt;br/&gt;}&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;其中参数部分为：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;long &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;minSize = Math.max(&lt;/span&gt;&lt;strong&gt;&lt;span&gt;this&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;.getFormatMinSplitSize(), getMinSplitSize(job));&lt;br/&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;long &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;maxSize = getMaxSplitSize(job);&lt;/span&gt;
&lt;/pre&gt;

&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;protected long &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;getFormatMinSplitSize() {&lt;br/&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;return &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;1L&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;}&lt;/span&gt;
&lt;/pre&gt;

&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;public static long &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;getMinSplitSize(JobContext job) {&lt;br/&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;return &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;job.getConfiguration().getLong(&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&quot;mapreduce.input.fileinputformat.split.minsize&quot;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;1L&lt;/span&gt;&lt;span&gt;);&lt;br/&gt;}&lt;/span&gt;
&lt;/pre&gt;

&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;public static long &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;getMaxSplitSize(JobContext context) {&lt;br/&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;return &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;context.getConfiguration().getLong(&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&quot;mapreduce.input.fileinputformat.split.maxsize&quot;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;9223372036854775807L&lt;/span&gt;&lt;span&gt;);&lt;br/&gt;}&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;minSize &lt;span&gt;若未指定，则默认为&lt;/span&gt; 1&lt;span&gt;。&lt;/span&gt;MaxSize&lt;span&gt;默认为&lt;/span&gt;Java Long&lt;span&gt;类型最大值。再计算时，先取&lt;/span&gt; maxSize &lt;span&gt;和&lt;/span&gt; blockSize &lt;span&gt;的最小值，然后再取结果与&lt;/span&gt; minSize&lt;span&gt;的最大值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在默认情况下：&lt;/span&gt;minSize &amp;lt; blockSize &amp;lt; maxSize&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以分片的大小就是&lt;/span&gt; blockSize&lt;span&gt;大小。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;5.&lt;/span&gt;&lt;/strong&gt; &lt;strong&gt;&lt;span&gt;小文件与&lt;/span&gt;&lt;/strong&gt; &lt;strong&gt;&lt;span&gt;CombineFileInputFormat&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;相对于大量的小文件，&lt;/span&gt;Hadoop&lt;span&gt;更适合处理少量的大文件。其中一个原因是：对于每个小文件（远小于&lt;/span&gt; HDFS&lt;span&gt;块大小），&lt;/span&gt;FileInputFormat &lt;span&gt;都会生成一个分片（生成的分片要么是文件的整个内容，要么是文件的部分内容），这样会产生大量的&lt;/span&gt; map &lt;span&gt;任务，并且每个&lt;/span&gt;map&lt;span&gt;任务仅处理一小部分数据，这样会导致任务执行效率低下，时间过长。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;CombineFileInputFormat &lt;span&gt;可以缓解此问题，它针对小文件而设计。&lt;/span&gt;FileInputFormat &lt;span&gt;为每个小文件产生一个分片，而&lt;/span&gt;CombineFileInpurtFormat &lt;span&gt;把多个文件打包到一个分片中，以便于每个&lt;/span&gt; mapper &lt;span&gt;可以处理更多的数据。更重要的是：&lt;/span&gt;CombineFileInputFormat&lt;span&gt;在分配多个&lt;/span&gt;block&lt;span&gt;到同一个&lt;/span&gt; split&lt;span&gt;时，会考虑到&lt;/span&gt;node locality &lt;span&gt;以及&lt;/span&gt; rack locality&lt;span&gt;。所以它的速度在一个典型的&lt;/span&gt; mr &lt;span&gt;任务中，处理输入的速度并不会下降。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不过尽可能要避免小文件过多的情况，原因有：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1. &lt;/span&gt;&lt;span&gt;处理小文件会增加运行作业而必须的寻址次数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2. &lt;/span&gt;&lt;span&gt;浪费&lt;/span&gt;namenode&lt;span&gt;的内存&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以尝试使用顺序文件（&lt;/span&gt;sequence file&lt;span&gt;）将这些小文件合并成一个或多个大文件：例如将文件名作为&lt;/span&gt;key&lt;span&gt;，文件内容作为&lt;/span&gt; value&lt;span&gt;。但是如果集群里已经有了大量小文件，可以尝试一下&lt;/span&gt;CombineFileInputFormat &lt;span&gt;方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;CombinedFileInputFormat&lt;span&gt;不仅处理小文件有好处，处理大文件时也有益处。例如，如果&lt;/span&gt;mapper&lt;span&gt;在处理一个&lt;/span&gt;block&lt;span&gt;时仅花费很少的时间，则可以考虑使用&lt;/span&gt;CombineFileInputFormat&lt;span&gt;，并将&lt;/span&gt;maximum split size &lt;span&gt;设置为&lt;/span&gt; HDFS block &lt;span&gt;大小的几倍（参数为&lt;/span&gt;mapred.max.split.size&lt;span&gt;）。这样每个&lt;/span&gt;mapper&lt;span&gt;会处理多个&lt;/span&gt;block&lt;span&gt;，使得整个处理时间下降。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;6.&lt;/span&gt;&lt;/strong&gt; &lt;strong&gt;&lt;span&gt;避免分片&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有时候可能需要计算整个文件里的顺序关系，这种任务无法分布式处理，所以只能让文件由一个&lt;/span&gt;mapper&lt;span&gt;处理，此时需要避免文件被分片。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有两种方式可以避免文件被分片，而是当作一个单独分片处理：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1. &lt;/span&gt;&lt;span&gt;设置最小分片大小&lt;/span&gt;split.minsize &lt;span&gt;为&lt;/span&gt;Java Long&lt;span&gt;类型最大值（&lt;/span&gt;long.MAX_VALUE&lt;span&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2. &lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;使用&lt;/span&gt;FileInputFormat &lt;span&gt;具体子类时，重写&lt;/span&gt;isSplitable() &lt;span&gt;方法，把返回值设置为&lt;/span&gt; false&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用第二种方法时，以&lt;/span&gt; TextInputFormat&lt;span&gt;类为例：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;public class &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;TextInputFormat &lt;/span&gt;&lt;strong&gt;&lt;span&gt;extends &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;FileInputFormat&amp;lt;LongWritable, Text&amp;gt; &lt;/span&gt;&lt;strong&gt;&lt;span&gt;implements &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;JobConfigurable {&lt;br/&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;private &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;CompressionCodecFactory compressionCodecs = &lt;/span&gt;&lt;strong&gt;&lt;span&gt;null&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;public &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;TextInputFormat() {&lt;br/&gt;}&lt;/span&gt;&lt;strong&gt;&lt;span&gt;public void &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;configure(JobConf conf) {&lt;br/&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;this&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;.compressionCodecs = &lt;/span&gt;&lt;strong&gt;&lt;span&gt;new &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;CompressionCodecFactory(conf);&lt;br/&gt;}&lt;/span&gt;&lt;strong&gt;&lt;span&gt;protected boolean &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;isSplitable(FileSystem fs, Path file) {&lt;br/&gt;CompressionCodec codec = &lt;/span&gt;&lt;strong&gt;&lt;span&gt;this&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;.compressionCodecs.getCodec(file);&lt;br/&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;return null &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;== codec ? &lt;/span&gt;&lt;strong&gt;&lt;span&gt;true &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;: codec &lt;/span&gt;&lt;strong&gt;&lt;span&gt;instanceof &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;SplittableCompressionCodec;&lt;br/&gt;}&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;….&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;&lt;span&gt;默认会根据&lt;/span&gt; CompressionCodec &lt;span&gt;类型判断是否切分，也可以直接指定&lt;/span&gt;return &lt;span&gt;为&lt;/span&gt; false&lt;span&gt;，使得输入文件不可切分。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;References：Hadoop权威指南第4版 &lt;/p&gt;

</description>
<pubDate>Sun, 28 Apr 2019 06:55:00 +0000</pubDate>
<dc:creator>ZacksTang</dc:creator>
<og:description>1. Mapper 与 Reducer 数量 对于一个默认的MapReduce Job 来说，map任务的数量等于输入文件被划分成的分块数，这个取决于输入文件的大小以及文件块的大小（如果此文件在 HD</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zackstang/p/10776857.html</dc:identifier>
</item>
<item>
<title>2019年程序员最值得学习的思维利器——任务分解 - LevenYes</title>
<link>http://www.cnblogs.com/levenyes/p/10783861.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/levenyes/p/10783861.html</guid>
<description>&lt;h3&gt;&lt;strong&gt;只用系统1不行，还要用系统2&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;作为程序员，我们常常会遇到以下这些典型问题：工时常常估不准，估少了加班加点都做不完，估多了项目经理会有意见；遇到不熟悉的任务容易恐慌，怕自己完不成；开发进行到一半才发现某个地方设计有缺陷，要返工，费时费力。&lt;/p&gt;

&lt;p&gt;做一个普通人，我们还要面对更多的难题：到年底了，是不是应该考虑跳槽，该跳去哪里；该不该买房子，是将其视为一种投资手段，还是应该认为房子就是必需品；要找什么样的人处对象，什么时候应该结婚。&lt;/p&gt;

&lt;p&gt;有些人不觉得这些是问题，因为他们从来不把它们当回事。工作随便应付了事，这里干不下去就去别的地方干。单身的生活早已习惯，自由自在挺好的，就算一辈子不结婚也不是什么大事。&lt;/p&gt;

&lt;p&gt;然而更多的人，还是会被这几个问题所困扰，每一次想起来都非常头疼，不知道如何是好。久而久之，这些问题甚至有可能变成一块心病，产生着持续的负面影响，非常不利于日常的工作和生活。&lt;/p&gt;

&lt;p&gt;《思考，快与慢》的作者提出了“系统1”和“系统2”的概念，系统1能很快地给出答案，系统2则需要通过分析和计算才能回答问题。我们在思考前面所提到的典型难题时，使用的通常是系统1，但给出的答案往往不是最优的。系统2，是时候派上用场了。更具体地来说，我们要采用的思维工具是，任务分解。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;什么是任务分解&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;任务分解，又或者叫目标分解，就是把一个任务、目标分拆解开成一个个更加具体、清晰的子任务、子目标，通过这些子任务、子目标最终完成任务和达成目标。&lt;/p&gt;

&lt;p&gt;我们可以先来看看现实版“钢铁侠”埃隆·马斯克是怎么做目标分解的。&lt;/p&gt;

&lt;p&gt;马斯克是特斯拉和SpaceX的CEO，他曾经公开宣布自己要送100万人殖民火星。那么从地球送一个大活人到火星上去要多少钱呢？美国太空总署NASA还真就算过一笔账，答案是100亿美元。&lt;/p&gt;

&lt;p&gt;如果要自费的话，恐怕只有少数十几个顶级富豪才能在倾家荡产之后移民火星，而且他们还很大可能不愿意去。如果是国家政府负担这100万人的费用，即便是富如美国都要花费几百年的GDP。由此看来，百万地球人殖民火星这个想法根本不可能实现。&lt;/p&gt;

&lt;p&gt;但是，马斯克并没有死心，他认为只要把成本降下来就可以。那么要降到多少呢？50万美元。这个钱并不多，在北上广深甚至连一套比较好的房子都买不下来。从NASA的100亿美元到50万美元，足足差了两万倍之多，仍然让人觉得不可思议。&lt;/p&gt;

&lt;p&gt;马斯克接下来就是把两万分解成20x10x100，并且将这个公式作为自己公司的三个主要努力方向。&lt;/p&gt;

&lt;p&gt;“20”：现在的宇宙飞船一般最多只能承载5个人，马斯克认为这太浪费了，我们可以完全可以把火箭造宽敞一些，一次载个100个人。从5到100，平均到每个人身上的成本就降了20倍。如果你平时有一直在关注SpaceX的新闻，就会发现他们正在做这方面的工作。&lt;/p&gt;

&lt;p&gt;“10”：政府机关或国营企业效率低，马斯克认为自己掌控的企业完全可以通过提升效率再把成本降低10倍。他并没有说大话，成本已经降到同行的五分之一了。&lt;/p&gt;

&lt;p&gt;“100”：如果我们每天开车上班，一辆车只能开单程，开到目的地就报废，估计没多少人能开得起车。马斯克认为如果可以使火箭可回收重复使用，让发射火箭像开车一样只耗燃料钱，那么成本将会极大地降低，100倍不是梦。在经历过多次失败之后，SpaceX现在已经实现了可回收火箭这一目标，并且在这个方向继续前进。&lt;/p&gt;

&lt;p&gt;这些算下来，你是不是不再觉得马斯克是在痴人说梦话了呢？虽然还是很困难，但是我们却能看到他实现终极目标的希望。相比之下，我们的工作和生活难题远远比不上殖民火星复杂度那么高，完全可以参考任务分解的思路去解决。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;任务分解有什么用&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;h4&gt;1.把大任务分解成小任务，工时估计会更加准确&lt;/h4&gt;

&lt;p&gt;完成一个完整的登录功能需要多长时间，我们很难估计，可能只要三个工作日，也可能要三个礼拜。如果我们把这个估计提交给项目经理或产品经理，他们很可能会发疯。&lt;/p&gt;

&lt;p&gt;其实我们完全可能通过任务分解，将这么一个大功能分解成一个个小功能，例如申请、找回密码、登录、注销等等，然后再逐一向下分解。&lt;/p&gt;

&lt;p&gt;判断一个类大概要实现哪些逻辑，要如何实现，需要多长时间，这就是我们所擅长的了。&lt;/p&gt;

&lt;h4&gt;2.面对以前没做过的需求，通过任务分解遍历一次，熟悉度提升之后就不会恐慌&lt;/h4&gt;

&lt;p&gt;我们在接到一个陌生的活儿之后，难免会心里忐忑不安，生怕自己完不成或者是最终做完了但是花费太多的时间。&lt;/p&gt;

&lt;p&gt;首先，一个再怎么新的任务都不可能是完全陌生的，我们可以先将其分解成自己熟悉的部分和陌生的部分。然后，我们再对陌生的那一部分做调研或者请教同事。最后，通过一小段时间的认知获取，我们就会对这个看似陌生的任务越来越熟悉，从而做到心里有底。&lt;/p&gt;

&lt;h4&gt;3.反复推演，全盘考虑， 会让我们少做很多的返工工作&lt;/h4&gt;

&lt;p&gt;如果要做任务分解，就必然要从全局的角度出发，通盘考虑每一个子任务之间的关系。我们如果要选择某个关键字段的类型和长度，就要考虑到哪些模块要存，哪些模块要改，哪些模块要取，这样就不容易出现前后不一致要推倒重来的情况。&lt;/p&gt;

&lt;p&gt;如果没有全局的视角，只是走一步看一步，遇到一个选择就做一次决定，这就叫窄框架。相反的叫宽框架，这正是我们在做任务分解的同时需要掌握的一种思维工具。&lt;/p&gt;

&lt;h4&gt;4.反思任务或目标本身，再决定要不要去做&lt;/h4&gt;

&lt;p&gt;在对“买房子”这一目标做分解的时候，我们很容易想到一个问题，就是为什么要买房子。别人都在购房或者打算购房，这不应该成为我们做出决定的依据，至少不能成为主要依据。&lt;/p&gt;

&lt;p&gt;房子主要有两种价值，一种是居住价值，另一种是投资价值。如果我们更看重居住价值，就要找环境更好、周围教育资源更丰富的住宅。如果我们更看重投资价值，就要找发展速度更快的地段和升值空间更大的楼盘。&lt;/p&gt;

&lt;p&gt;一个打算两三年跳槽一次的单身汉，居住价值很可能不是他所看重的，他可能认为租房更符合他的需求。对于一个职业生涯刚起步、家里又不能提供支持的年轻人来说，投资房地产就不是一个好的选择，远不如专注地投资自身来的要好。&lt;/p&gt;

&lt;h4&gt;5.任务分解，就是一个学习和进步的过程&lt;/h4&gt;

&lt;p&gt;查理·芒格说，“要想找到一个好的妻子，先要做的就是让你配得上她”。&lt;/p&gt;

&lt;p&gt;如果希望找到一个知书达理的对象，你自己就不能总是控制不住自己的情绪，老是把错误归咎到别人的身上。如果希望你的另一半有一定的经济能力，你自己就要学会掌握一技之长，有自己的立身之本。如果希望那个跟自己组建家庭、生儿育女的人能心甘情愿奉献，你自己就要开始学会为别人考虑，在必要的时候牺牲一定程度的自由和其他宝贵的东西。&lt;/p&gt;

&lt;h4&gt;6.目标分解，能让我们更关注当下，做更多更有实际意义的事情&lt;/h4&gt;

&lt;p&gt;在互联网行业里做技术工作，两三年甚至一两年跳槽一次是很平常的事。我们不能为了跳槽而跳槽，抛开薪酬问题暂且不谈，跳槽到底是为了什么呢？&lt;/p&gt;

&lt;p&gt;跳槽可能是为了更快地成长，到一个更有挑战性的岗位上，做更有意思的工作。跳槽可能是为了有一个新的工作环境，建立更好的同事关系。跳槽可能是为了找回生活的那一部分，有更多的业余时间。&lt;/p&gt;

&lt;p&gt;找到原因之后，我们可以看看是否有改变当下情况的可能。我们是不是可以找老大谈谈，为自己争取更多有难度的、把自己从舒适区推向学习区的任务？我们是不是可以学习一些人际交往的技巧，改善现在让自己并不满意的同事关系？我们是不是可以找出自己为什么那么忙碌的原因，尝试改变现状？&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;如何练习任务分解&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;任务和目标其实没有特别明显的区分，为了更好地叙述，接下来我们就以“小任务”和“大目标”的说法继续讨论。&lt;/p&gt;

&lt;p&gt;知道了任务分解的诸多好处，那么我们要如何通过练习掌握这个解决复杂问题、实现宏大目标的思维利器呢？小任务采用列表法，大目标借鉴金字塔原理。&lt;/p&gt;

&lt;p&gt;相对于大目标来说，小任务规模比较小，分层的必要性不大，所以我们可以使用列表的形式把一个任务分解成若干个具体的步骤，然后逐一完成。&lt;/p&gt;

&lt;p&gt;就拿去医院看病为例，我们完全可以将其分解成以下几个步骤：&lt;/p&gt;
&lt;ol class=&quot;list-paddingleft-2&quot; readability=&quot;5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;使用医院小程序的分诊功能，根据自己的症状找到自己要挂号的门诊科室。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;了解是否可以网上挂号，如果是就在线完成，如果不行就查要去哪里排队。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;挂号后，是否要等待比较长的时间，考虑是否携带充电宝&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;医生看诊时，如果要看腿，最好穿短裤；如果要看上身，最好穿宽松的短袖。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;诊断完毕之后，如果要当场做手术（牙科），术后是否能自行回家。如果不能，则需要提前通知亲友帮忙。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;回到家之后能否照常进食，是否需要提前准备流食。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;第二天能否照常上班，是否需要提前请假。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在工作当中，我常常会对任务做这样的分解，分解完之后感觉特别有底气，而且不怕被打断。即便有人中途找我，我在响应完之后看一眼列表就知道已经做完了哪些工作，接下来还要做哪些。&lt;/p&gt;

&lt;p&gt;在这里给大家推荐一个小技巧，在心理学上叫做激励。我们可以把分解完的步骤罗列在自己的笔记本上，然后每完成一个步骤就拿笔在后面打一个勾，这样做能给自己带来一定的成就感和满足感。&lt;/p&gt;

&lt;p&gt;相对于小任务来说，大目标规模比较大，非常有必要对其进行分层处理。&lt;/p&gt;

&lt;p&gt;在商务写作领域有一本书非常有名，叫《金字塔原理》。一篇商务文章，例如报告、总结等，都要有一个中心思想。这个中心思想下面，可能会有几个主分论点，而每一个主分论点下面可能还会有几个二级主分论点，一直细分到每一个子论点。&lt;/p&gt;

&lt;p&gt;我们在分解大目标的时候，就可以借鉴上面这种分层思想去操作。以个人成长为例，我们的核心目标就是成为一个更好的自己。那么这个核心目标就可以分解成思想（学识更渊博）、经济（财务自由度更高）、健康（身体素质更好）、人际（跟身边人相处得更好）四个主目标。就经济主目标而言，我们又可以分解成开源（提升赚钱能力）和节流（提升理财能力）两个次主目标。接下来还可以把节流目标再次分解，分解成理财（储蓄和投资）和消费（理性消费）两部分。就这样，我们可以继续细分下去，一直到了现实当中可操作的每一个动作。&lt;/p&gt;

&lt;p&gt;任务分解是一种可以通过练习来掌握和运用的技能，并不是什么了不起的天赋。只要在日常工作和生活当中有意识地练习和使用，我们每个人都能借助这个强有力的思维工具获得一开始完全想象不到的好处。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;敢于挑战自我和超越自我的勇气&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过任务分解，不仅可以为日常工作生活找到它们在人生大图景中的位置，还给了我们挑战复杂目标、超越自我的勇气。&lt;/p&gt;

&lt;p&gt;如果我们可以分解所追求的目标，分解成一个个可操作的单元步骤，那就永远不会觉得无聊，永远有事可做。我在年初给自己定下了11月份之前要完成1000个番茄时间（1个番茄时间32分钟）的目标，所以我只要一有条件就会阅读，例如长时间坐车或排队的时候，我会听“得到”或“极客时间”的课程。&lt;/p&gt;

&lt;p&gt;我们知道每一个看似普通的小任务都是为了大目标的达成，所以不会觉得乏味或者毫无意义。以前的我们可能会讨厌上班，但是如果定下了成长的目标，我们就会变得有动力和有自主能动性，积极地去找那些能让自己学习进步的工作去做。以前的我们可能会觉得运动很累，但是如果定下了健康的目标，我们就会觉得走路不是浪费时间，跑步并没有之前想象得那么不可接受。&lt;/p&gt;

&lt;p&gt;我们以前可能会有这样的想法：工时估不准就估不准吧，我就尽量做，完不成我也没办法；遇到不熟悉的任务能躲就躲吧，躲不过去就硬着头皮做；做到一半遇到前后不一致的问题就看能不能绕过去，绕不过去就推倒重来。&lt;/p&gt;

&lt;p&gt;我们甚至还会有这样的看法：房子这么贵，买房子是不可能买房子的，近期不考虑了；结婚这么麻烦，结婚是不可能结婚的，单身一辈子也不是坏事；跳槽到一家好公司那么难，跳槽是不可能跳槽的，就这么将就下去吧。&lt;/p&gt;

&lt;p&gt;通过目标分解，我们会意识到这些事情虽然复杂，要做好的难度比较高，但是并非不可企及。先将大目标分解成小目标，然后再一步步通过实现小目标的方式，看到一条有希望实现大目标的道路。&lt;/p&gt;

&lt;p&gt;如此这般，我们就能鼓起勇气，开始挑战自我，最终超越自我。&lt;/p&gt;


&lt;p&gt;我有一个公众号，经常会发一些看书思考过后写的文章，还有作为一个程序员的工作经验分享。&lt;/p&gt;
&lt;p&gt;如果你喜欢我的文字，可以用微信搜索“李文业的思考笔记”或者扫描二维码关注。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/470341/201707/470341-20170704180534003-535825211.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 28 Apr 2019 06:45:00 +0000</pubDate>
<dc:creator>LevenYes</dc:creator>
<og:description>只用系统1不行，还要用系统2 作为程序员，我们常常会遇到以下这些典型问题：工时常常估不准，估少了加班加点都做不完，估多了项目经理会有意见；遇到不熟悉的任务容易恐慌，怕自己完不成；开发进行到一半才发现某</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/levenyes/p/10783861.html</dc:identifier>
</item>
<item>
<title>滴滴 App 的质量优化框架 Booster，开源了！ - 承香墨影</title>
<link>http://www.cnblogs.com/plokmju/p/didi_booster.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/plokmju/p/didi_booster.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/04/25/5cc17e0d52fe3.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/04/28/5cc542a21f68d.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;一.-序&quot;&gt;一. 序&lt;/h2&gt;
&lt;p&gt;当 App 达到一定体量的时候，肯定是要考虑质量优化。有些小问题，看似只有 0.01% 触发率，但是如果发生在 DAU 过千万的产品中，就很严重了。&lt;/p&gt;
&lt;p&gt;滴滴这个独角兽的 DAU 早已过千万，自然有一些独到的优化方案。最近滴滴在 Github 上开源了一个 Android App 的质量优化工具 &lt;strong&gt;Booster&lt;/strong&gt;，通过动态发现和加载机制，提供了可扩展的能力。等于是一款移动应用的质量优化框架。&lt;/p&gt;
&lt;p&gt;说到优化好像也不知道具体能干什么。从特性上笼统来说，Booster 可以做到性能检测和优化、包体积瘦身、代码注入等。&lt;/p&gt;
&lt;p&gt;稍微看了一下，暂时所支持的优化还比较有限，但是好 Booster 提供了非常便捷的扩展能力，我们可以根据业务场景，进行针对性的优化。&lt;/p&gt;
&lt;p&gt;虽然 Booster 现在的优化点还很少，但是在开源的同时，也给出了后续发展的 Roadmap，之后的功能应该是会越来越完善的。下面就来了解一下滴滴新开源的 Booster。&lt;/p&gt;
&lt;h2 id=&quot;二.-booster&quot;&gt;二. Booster&lt;/h2&gt;
&lt;h3 id=&quot;什么是-booster&quot;&gt;2.1 什么是 Booster&lt;/h3&gt;
&lt;p&gt;Booster 是专门为移动应用而设计的简单易用、轻量级、功能强大且可扩展的质量优化工具包，其通过动态发现和加载机制，提供了可扩展的能力。是一款移动应用的质量优化框架。&lt;/p&gt;
&lt;p&gt;Booster 主要由 Transformer 和 Task 组成。&lt;/p&gt;
&lt;p&gt;Transformer 用于对字节码进行扫描或修改（取决于 Transformer 的功能），而 Task 则用于处理构建中的资源。&lt;/p&gt;
&lt;p&gt;为了满足不同业务场景下的优化需求，Booster 提供了 Transformer SPI 和 VariantProcessor SPI 接口，来允许开发者进行定制。&lt;/p&gt;
&lt;p&gt;Booster 的整体框架如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/04/25/5cc19c1307f70.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Booster 对 Gradle 还有一些小的版本要求：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Gradle 4.1 以上版本&lt;/li&gt;
&lt;li&gt;Android Gradle 插件 3.0 以上版本&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;booster-到底能干什么&quot;&gt;2.2 Booster 到底能干什么？&lt;/h3&gt;
&lt;p&gt;读了一遍官方的概念，好像还是不知道 Booster 的用处，这里就以 Booster 已经支持的一个 Transformer 为例子，来讲解它到底能干什么。&lt;/p&gt;
&lt;p&gt;Toast 是我们在日常开发中经常会用到的一个提示信息的组件，而在 Android 7.0 的系统中，它有可能会触发 BadTokenException 的异常。这个问题，用 Booster 就可以解决。&lt;/p&gt;
&lt;p&gt;Toast 抛 BadTokenException 看起来是在显示的时候，窗口的 Token 已经失效了，也有可能在显示 Toast 的时候，窗口已经被销毁了。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;android.view.WindowManager$BadTokenException: 
    at android.view.ViewRootImpl.setView(ViewRootImpl.java)
    at android.view.WindowManagerGlobal.addView(WindowManagerGlobal.java)
    at android.view.WindowManagerImpl.addView(WindowManagerImpl.java4)
    at android.widget.Toast$TN.handleShow(Toast.java)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个问题只出现在 Android 7.0 中，在之后的版本中，为了解决这个问题，是直接将其 Catch 住这个异常来解决问题的。下面是 Android 8.0 的相关代码。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;try {
    mWM.addView(mView, mParams);
    trySendAccessibilityEvent();
} catch (WindowManager.BadTokenException e) {
    /* ignore */
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;虽然这个问题已经有了一些解决方案，但是 Booster 给了我们另外一个选择。&lt;/p&gt;
&lt;p&gt;在 Booster 中，已经内置了一些 Transformers，其中就有一个 booster-transform-bugfix-toast，是用于修复 Android 7.0 中，Toast 导致的系统错误。&lt;/p&gt;
&lt;p&gt;ToastBugfixTransformer 的主要源码在此：&lt;/p&gt;
&lt;pre class=&quot;kotlin&quot;&gt;
&lt;code&gt;@AutoService(ClassTransformer::class)
class ToastBugfixTransformer : ClassTransformer {

    override fun transform(context: TransformContext, klass: ClassNode): ClassNode {
        klass.methods.forEach { method -&amp;gt;
            method.instructions?.iterator()?.asIterable()?.filterIsInstance(MethodInsnNode::class.java)?.filter {
                it.owner == TOAST &amp;amp;&amp;amp; it.name == &quot;show&quot; &amp;amp;&amp;amp; it.desc == &quot;()V&quot;
            }?.forEach {
                it.owner = `TOAST'`
                it.desc = &quot;(L$TOAST;)V&quot;
                it.opcode = Opcodes.INVOKESTATIC
            }
        }
        return klass
    }
}
private const val TOAST = &quot;android/widget/Toast&quot;
private const val `TOAST'` = &quot;com/didiglobal/booster/$TOAST&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它是将系统的 Toast 传递到另外定制的一个 com.didiglobal.booster.android.widget 包下的 Toast 来解决。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void show(final android.widget.Toast toast) {
    if (Build.VERSION.SDK_INT == 25) {
        workaround(toast).show();
    } else {
        toast.show();
    }
}

private static android.widget.Toast workaround(final android.widget.Toast toast) {
    final Object tn = getFieldValue(toast, &quot;mTN&quot;);
    if (null == tn) {
        Log.w(TAG, &quot;Field mTN of &quot; + toast + &quot; is null&quot;);
        return toast;
    }

    final Object handler = getFieldValue(tn, &quot;mHandler&quot;);
    if (handler instanceof Handler) {
        if (setFieldValue(handler, &quot;mCallback&quot;, new CaughtCallback((Handler) handler))) {
            return toast;
        }
    }

    final Object show = getFieldValue(tn, &quot;mShow&quot;);
    if (show instanceof Runnable) {
        if (setFieldValue(tn, &quot;mShow&quot;, new CaughtRunnable((Runnable) show))) {
            return toast;
        }
    }

    Log.w(TAG, &quot;Neither field mHandler nor mShow of &quot; + tn + &quot; is accessible&quot;);
    return toast;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当 API Level 不为 25 时，直接调用 &lt;code&gt;Toast.show()&lt;/code&gt; 方法，为 25 时，通过反射来判断当前 Toast 的情况，进而返回一个有效的 Toast 对象，再调用 &lt;code&gt;show()&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;到这里就将 Toast 在 7.0 上的问题修复了，我们正常开发过程中，完全不需要担心 Toast 的使用，做质量保证的和做业务的也可以区分开了。&lt;/p&gt;
&lt;h3 id=&quot;booster-已经内置的功能&quot;&gt;2.3 Booster 已经内置的功能&lt;/h3&gt;
&lt;p&gt;在 Booster 开源的时候，内部已经内置了一些 Transformer 和 Task，前面介绍的 booster-transform-bugfix-toast 就是其中之一。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;内置 Transformers&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;booster-transform-bugfix-toast：修复 7.0 中 Toast 导致的系统错误。&lt;/li&gt;
&lt;li&gt;booster-transform-lint：检查潜在的性能问题。&lt;/li&gt;
&lt;li&gt;booster-transform-shrink：用于清除 class 文件中的常量。&lt;/li&gt;
&lt;li&gt;booster-transform-usage：用于扫描特定 API 的使用情况。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;内置 Tasks&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Booster-task-artifact：提供显示 artifact 的 Task。&lt;/li&gt;
&lt;li&gt;Booster-task-dependency：提供显示所有依赖项的标识符以及文件路径的 Task。&lt;/li&gt;
&lt;li&gt;Booster-task-permission：提供显示所有依赖项使用的 Android 权限。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这些 Booster 提供的 Transformer 和 Task，功能还有限，它们更多的是提供一些指导意义，可以让我们通过源码了解到 Booster 的使用。&lt;/p&gt;
&lt;p&gt;有更多想法，可以自己去实现 Transformer 和 Task。&lt;/p&gt;
&lt;p&gt;在发布的 Roadmap 中，已经提出接下来几个版本的迭代计划，例如会专注：性能优化、Lint、资源压缩、用户体验等等。在性能优化上，会对多线程的使用、SP 的使用、WebView 的预加载进行针对性的优化。&lt;/p&gt;
&lt;h2 id=&quot;三.-小结时刻&quot;&gt;三. 小结时刻&lt;/h2&gt;
&lt;p&gt;整体来看，Booster 是一个非常好的性能优化框架，它使用的都是成熟的技术，将其包装而成，降低了我们使用的难度。并没有什么太大的深坑，有需要可以进行尝试。&lt;/p&gt;
&lt;p&gt;更多内容可以去 Github 上阅读 Wiki 和源码，有兴趣别忘点个 star。&lt;/p&gt;
&lt;p&gt;Github：https://github.com/didi/booster&lt;/p&gt;
&lt;p&gt;本文对你有帮助吗？&lt;strong&gt;留言、点赞、转发&lt;/strong&gt;是最大的支持，谢谢！&lt;/p&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;公众号后台回复成长『&lt;strong&gt;成长&lt;/strong&gt;』，将会得到我准备的学习资料，也能回复『&lt;strong&gt;加群&lt;/strong&gt;』，一起学习进步；你还能回复『&lt;strong&gt;提问&lt;/strong&gt;』，向我发起提问。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/04/28/5cc5431211c28.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 28 Apr 2019 06:09:00 +0000</pubDate>
<dc:creator>承香墨影</dc:creator>
<og:description>一. 序 当 App 达到一定体量的时候，肯定是要考虑质量优化。有些小问题，看似只有 0.01% 触发率，但是如果发生在 DAU 过千万的产品中，就很严重了。 滴滴这个独角兽的 DAU 早已过千万，自</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/plokmju/p/didi_booster.html</dc:identifier>
</item>
<item>
<title>《前端之路》 之 前端开发规范 从制定到实施 - SmallW</title>
<link>http://www.cnblogs.com/erbingbing/p/10783641.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/erbingbing/p/10783641.html</guid>
<description>&lt;h2 id=&quot;前端开发规范-从制定到实施&quot;&gt;前端开发规范 从制定到实施&lt;/h2&gt;
&lt;p&gt;在我们开始这个题目的时候，我们应该思考下面几个问题：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;前端开发为什么需要 开发规范？&lt;/li&gt;
&lt;li&gt;前端开发规范是什么？&lt;/li&gt;
&lt;li&gt;什么时候需要这个规范？&lt;/li&gt;
&lt;li&gt;如何制定这个规范？&lt;/li&gt;
&lt;li&gt;如何落实这个规范？&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;一前端开发为什么需要-开发规范&quot;&gt;一、前端开发为什么需要 开发规范？&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;why？&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;前端还在 刀耕火种的时代的时候，前端是没有 &lt;code&gt;工程&lt;/code&gt; 这个概念的。更多是&lt;code&gt;切图仔&lt;/code&gt;这个概念，（将设计师设计出来的 web 、app、h5 的 &lt;code&gt;UI&lt;/code&gt; 通过 PS &lt;code&gt;切图&lt;/code&gt; 然后再通过 HTML、CSS 实现出来）的这么一个工种。那么随着 互联网兴起到后来的移动互联网发展，To C 产品需求 精细化， 用户对于 C 端产品越来越挑剔也促使着 前端工程化越来越规范化了。 渐渐的&lt;code&gt;前端工程&lt;/code&gt;形成，那么随之而来的就是 &lt;code&gt;工程化 带来的 规范化&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;回到 &lt;code&gt;why&lt;/code&gt; 的问题上来，我们先举一个简单的例子来说，&lt;/p&gt;
&lt;p&gt;可能 工程化 这个名词在很多的后端语言中早早的就已经形成了，但前端 这么一门到现在大学课程都没开课的工种，全靠大学毕业后工作中自学积累而来，那么我们是否可以说，现阶段前端搞的好的人，Ta 的自学能力一定不会差。&lt;/p&gt;
&lt;h3 id=&quot;二前端开发规范是什么&quot;&gt;二、前端开发规范是什么？&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;what?&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;什么是前端开发规范？&lt;/p&gt;
&lt;p&gt;HTML\CSS\Javascript\TypeScript 的代码编写规范，这里我们着重讲一下 JS 的 编码规范&lt;/p&gt;
&lt;h4 id=&quot;types&quot;&gt;1、Types&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;javascript 的数据类型&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;1.1 基本数据类型&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;string&lt;/li&gt;
&lt;li&gt;number&lt;/li&gt;
&lt;li&gt;boolean&lt;/li&gt;
&lt;li&gt;null&lt;/li&gt;
&lt;li&gt;undefined&lt;/li&gt;
&lt;li&gt;symbol&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const foo = 1;
let bar = foo;

bar = 9;

console.log(foo, bar); // =&amp;gt; 1, 9&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;1.2 引用数据类型&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;object&lt;/li&gt;
&lt;li&gt;array&lt;/li&gt;
&lt;li&gt;function&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const foo = [1, 2];
const bar = foo;

bar[0] = 9;

console.log(foo[0], bar[0]); // =&amp;gt; 9, 9&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上则 是 基础数据 在 &lt;code&gt;coding&lt;/code&gt; 的时候的基本规范。&lt;/p&gt;
&lt;h4 id=&quot;references&quot;&gt;2、References&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;变量、常量、定义规范&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;2.1 eslint: &lt;code&gt;prefer-const&lt;/code&gt;, &lt;code&gt;no-const-assign&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// bad
var a = 1;
var b = 2;

// good
const a = 1;
const b = 2;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;建议使用 const 定义常量，可以阻止一些 重复定义导致的 bug&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;2.2 eslint: &lt;code&gt;no-var&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// bad
var count = 1;
if (true) {
  count += 1;
}

// good, use the let.
let count = 1;
if (true) {
  count += 1;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;推荐使用 let 来定义变量，形成块级作用域，减少因为变量提升导致的bug&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;objects&quot;&gt;3、Objects&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;对象 定义规范&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;3.1 eslint: &lt;code&gt;no-new-object&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// bad
const item = new Object();

// good
const item = {};&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;推荐使用 对象字面量来定义空对象，而不是通过 new 实例化进行操作&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;3.2 动态属性名 使用 计算属性&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// bad
const obj = {
  id: 5,
  name: 'San Francisco',
};
obj[getKey('enabled')] = true;

// good
const obj = {
  id: 5,
  name: 'San Francisco',
  [getKey('enabled')]: true,
};&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;3.3 eslint: &lt;code&gt;object-shorthand&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// bad
const atom = {
  value: 1,

  addValue: function (value) {
    return atom.value + value;
  },
};

// good
const atom = {
  value: 1,

  addValue(value) {
    return atom.value + value;
  },
};&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;推荐 在给对象添加方法的时候，使用 简化符号&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;3.4 eslint: &lt;code&gt;object-shorthand&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const lukeSkywalker = 'Luke Skywalker';

// bad
const obj = {
  lukeSkywalker: lukeSkywalker,
};

// good
const obj = {
  lukeSkywalker,
};&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;方法名如果和对象的属性名称相同的时候，推荐使用简化符号编写&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;3.5 在使用 &lt;code&gt;object-shorthand&lt;/code&gt; 的时候，推荐先写出简化符号的属性或者方法&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const anakinSkywalker = 'Anakin Skywalker';
const lukeSkywalker = 'Luke Skywalker';

// bad
const obj = {
  episodeOne: 1,
  lukeSkywalker,
  anakinSkywalker,
};

// good
const obj = {
  lukeSkywalker,
  anakinSkywalker,
  episodeOne: 1,
};&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;3.6 eslint: &lt;code&gt;quote-props： as-needed&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// bad
const bad = {
  'foo': 3,
  'bar': 4,
  'data-blah': 5,
};

// good
const good = {
  foo: 3,
  bar: 4,
  'data-blah': 5,
};&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;推荐在 给对象属性不要轻易加引号，除非必要的情况下，比如属性的key带有 符号等&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;3.7 eslint: &lt;code&gt;no-prototype-builtins&lt;/code&gt; 不使用 prototype 的内置命令&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// bad
console.log(object.hasOwnProperty(key));

// good
console.log(Object.prototype.hasOwnProperty.call(object, key));

// best
const has = Object.prototype.hasOwnProperty; // cache the lookup once, in module scope.
/* or */
import has from 'has'; // https://www.npmjs.com/package/has
// ...
console.log(has.call(object, key));&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;推荐理由是：这些方法可能被有关对象上的属性所遮蔽&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;3.8 对象扩展符 比使用 &lt;code&gt;Object.assign&lt;/code&gt; 好&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// very bad
const original = { a: 1, b: 2 };
const copy = Object.assign(original, { c: 3 }); // this mutates `original` ಠ_ಠ
delete copy.a; // so does this

// bad
const original = { a: 1, b: 2 };
const copy = Object.assign({}, original, { c: 3 }); // copy =&amp;gt; { a: 1, b: 2, c: 3 }

// good
const original = { a: 1, b: 2 };
const copy = { ...original, c: 3 }; // copy =&amp;gt; { a: 1, b: 2, c: 3 }

const { a, ...noA } = copy; // noA =&amp;gt; { b: 2, c: 3 }&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;推荐原因就是， 对象扩展符 比 Object.assign 看着舒服10倍吧&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;arrays&quot;&gt;4、Arrays&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;4.1 eslint: &lt;code&gt;no-array-constructor&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;/*推荐使用通过字面量创建对象、数组*/
// bad
const items = new Array();
// good
const items = [];&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;4.2 Use &lt;code&gt;Array#push&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;/*推荐使用 push 来进行 stack add */
// bad
someArr[someArr.length] = 'xxxxsssswwww'
// good
someArr.push('xxxxsssswwww')&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;4.3 Use array spreads ... to copy arrays&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;/*推荐使用 `...` 进行数组 复制 */
// bad
for(i=0; i&amp;lt;arr.length; i++) { newArr[i] = arr[i] }
// good
let newArr = [...arr]&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;4.4 use spreads ... instead of Array.from&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;/*推荐使用 `...` 将可迭代对象转换为数组 */
// bad
const foo = document.querySelectorAll('.foo'); nodes = Array.from(foo)  // array[]
// good
let nodes = [...foo]&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;4.5 Use Array.from for converting an array-like object to an array&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;/*推荐使用 `Array.from` 将 array-like[类数组] 转换为对象 */
const arrLike = { 0: 'foo', 1: 'bar', 2: 'baz', length: 3 };
// bad
const arr = Array.prototype.slice.call(arrLike);
// good
const arr = Array.from(arrLike);&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;4.6 Use Array.from instead of spread ... for mapping over iterables&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;/*推荐使用 `Array.from` 实现可迭代数组方法而不是通过 ... */
// bad
const baz = [...foo].map(bar);
// good
const baz = Array.from(foo, fn);&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;4.7 eslint: &lt;code&gt;array-callback-return&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;/*推荐使用 `Array.from` 实现可迭代数组方法而不是通过 ... */
// good
[1, 2, 3].map(x =&amp;gt; x + 1);
// 优化写法、代码简洁易懂&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;4.8 Use line breaks after open and before close array brackets&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;/* 数组换行格式 优化 */
// bad
const arr = [
  [0, 1], [2, 3], [4, 5],
];

// good
const arr = [[0, 1], [2, 3], [4, 5]];&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;destructuring---解构&quot;&gt;5、Destructuring - 解构&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;5.1 eslint: &lt;code&gt;prefer-destructuring&lt;/code&gt; 对象结构&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;/* 对象结构 带来的更加简洁的代码 */
// bad
function getFullName(user) {
  const firstName = user.firstName;
  const lastName = user.lastName;

  return `${firstName} ${lastName}`;
}
// good
function getFullName(user) {
  const { firstName, lastName } = user;
  return `${firstName} ${lastName}`;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;5.2 eslint: &lt;code&gt;prefer-destructuring&lt;/code&gt; 函数参数结构&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// bad
function getFullName(user) {
  const firstName = user.firstName;
  const lastName = user.lastName;

  return `${firstName} ${lastName}`;
}

// best
function getFullName({ firstName, lastName }) {
  return `${firstName} ${lastName}`;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;5.3 eslint: &lt;code&gt;prefer-destructuring&lt;/code&gt; 数组结构&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const arr = [1, 2, 3, 4];

// bad
const first = arr[0];
const second = arr[1];

// good
const [first, second] = arr;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;string&quot;&gt;6、 String&lt;/h4&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;h4 id=&quot;function&quot;&gt;7、 function&lt;/h4&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;h4 id=&quot;classes-constructors&quot;&gt;8、Classes &amp;amp; Constructors&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;这里的核心就是减少构造函数的使用、多使用 通过 class 来进行 类的创建、constructor、extends 实现继承、构造函数等 原始的方法。&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// bad
function Queue(contents = []) {
  this.queue = [...contents];
}
Queue.prototype.pop = function () {
  const value = this.queue[0];
  this.queue.splice(0, 1);
  return value;
};

// good
class Queue {
  constructor(contents = []) {
    this.queue = [...contents];
  }
  pop() {
    const value = this.queue[0];
    this.queue.splice(0, 1);
    return value;
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;modules&quot;&gt;9、Modules&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;模块化的 导入、导出。&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// bad
const AirbnbStyleGuide = require('./AirbnbStyleGuide');
module.exports = AirbnbStyleGuide.es6;

// ok
import AirbnbStyleGuide from './AirbnbStyleGuide';
export default AirbnbStyleGuide.es6;

// best
import { es6 } from './AirbnbStyleGuide';
export default es6;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;space&quot;&gt;10、space&lt;/h4&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;由于篇幅有限，这里就不做过多的描述了，详情可以查看 &lt;a href=&quot;https://github.com/airbnb/javascript&quot;&gt;Airbnb eslint 规则&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;三什么时候需要这个规范&quot;&gt;三、什么时候需要这个规范？&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;我觉得任何时候都需要这个规范！！！&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;无论是一个人，还是 前端小组，甚至全公司的 大前端开发团队 都是需要的！！！&lt;/p&gt;
&lt;h3 id=&quot;四如何制定这个规范&quot;&gt;四、如何制定这个规范？&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;如何定制这个规范&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;code-代码层面实现&quot;&gt;1、&lt;code&gt;CODE&lt;/code&gt; 代码层面实现&lt;/h4&gt;
&lt;p&gt;借助ESLint的autofix功能，在保存代码的时候，自动将抛出error的地方进行fix。因为我们项目是在webpack中引入eslint-loader来启动eslint的，所以我们只要稍微修改webpack的配置，就能在启动webpack-dev-server的时候，每次保存代码同时自动对代码进行格式化。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;
// webpack.config.base.js  or webpack.config.dev.js

const path = require('path')
module.exports = {
  module: {
    rules: [
      {
        test: /\.(js|vue|jsx)$/,
        loader: 'eslint-loader',
        enforce: 'pre',
        include: [path.join(__dirname, 'src')],
        options: {
          fix: true
        }
      }
    ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;lint-lint-规则层面&quot;&gt;2、&lt;code&gt;lint&lt;/code&gt; lint 规则层面：&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;秉承着 一个原则， 渐进式 规则完善，从最基本的 规范到 逐步 健全的规范落实，结合 code review 逐渐完善。&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;五如何落实这个规范&quot;&gt;五、如何落实这个规范？&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;对了，关键点就是 如何落实这个规范！！！&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;ide-的选择&quot;&gt;1、IDE 的选择&lt;/h4&gt;
&lt;p&gt;前端IDE开发的选择，从大学阶段的 &lt;code&gt;DW&lt;/code&gt;（Adobe Dreamweaver）、&lt;code&gt;Notepad++&lt;/code&gt; 等等，再到后面的 &lt;code&gt;Sublime&lt;/code&gt; 、&lt;code&gt;Webstorm&lt;/code&gt; 再到后面的 &lt;code&gt;Atom&lt;/code&gt; 、&lt;code&gt;Visual Studio Code （VScode）&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;IDE 不断的变化过程中也给了我们 更加高效编程的选择&lt;/p&gt;
&lt;h4 id=&quot;ide-的-本地设置文件-setting.json&quot;&gt;2、IDE 的 本地设置文件 setting.json&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;在 vscode 中的设置中配置（新旧不同版本的 vscode setting.json 的展现形式是不一样的）&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/675289/201904/675289-20190425162713172-277284817.jpg&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;但是这个 格式化 往往只是最最进本的格式化，在前端如此多的 语言中很显然是不够用的，下面，我们就主要介绍下 `Prettier`&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;prettier---code-formatter-格式化插件的使用&quot;&gt;3、Prettier - Code formatter 格式化插件的使用&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;在 vscode 的应用商店进行 搜索（Prettier - Code formatter ）下载安装 

在项目的根目录创建 Prettier 的配置文件 `.prettierrc`

Prettier 格式化的配置文件文档地址： https://prettier.io/docs/en/options.html

基本的配置文件格式如下：&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
  &quot;singleQuote&quot;: true,
  &quot;trailingComma&quot;: &quot;es5&quot;,
  &quot;printWidth&quot;: 140,
  &quot;semi&quot;: true,
  &quot;bracketSpacing&quot;: true,
  &quot;overrides&quot;: [
    {
      &quot;files&quot;: &quot;.prettierrc&quot;,
      &quot;options&quot;: { &quot;parser&quot;: &quot;json&quot; }
    }
  ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么，我们来看下 Prettier 做了哪些事情&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/675289/201904/675289-20190428105816016-810880686.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/675289/201904/675289-20190428105819473-1753899564.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;能支持jsx&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/675289/201904/675289-20190428105822374-127256674.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;也能支持css&lt;/code&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/675289/201904/675289-20190428105824599-442339127.gif&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;eslint-与-prettier配合使用&quot;&gt;4、ESLint 与 Prettier配合使用&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;首先肯定是需要安装prettier，并且你的项目中已经使用了ESLint，有eslintrc.js配置文件。&lt;/code&gt;&lt;/p&gt;
&lt;h5 id=&quot;配合eslint检测代码风格&quot;&gt;4.1 配合ESLint检测代码风格&lt;/h5&gt;
&lt;p&gt;eslint-plugin-prettier插件会调用prettier对你的代码风格进行检查，其原理是先使用prettier对你的代码进行格式化，然后与格式化之前的代码进行对比，如果过出现了不一致，这个地方就会被prettier进行标记。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;//.eslintrc
{
  &quot;plugins&quot;: [&quot;prettier&quot;],
  &quot;rules&quot;: {
    &quot;prettier/prettier&quot;: &quot;error&quot;
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样就 可以通过 eslint 来 extend prettier 的规范，最后结合 webpack 的 module 中 对于 js、vue、jsx 文件的 loader 处理，来实现 实时的 lint 。&lt;/p&gt;
&lt;h4 id=&quot;项目架构中-应该具备的-配置文件&quot;&gt;5、项目架构中 应该具备的 配置文件&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;那么 回归到最后，我们去架构这个项目的时候，从 前端编码规范层面去考虑的话，我们的项目 最少需要的几个 配置文件是这样子的：&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;webpack.config.js&quot;&gt;5.1 、webpack.config.js&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;webpack&lt;/code&gt; 是 构建根本，结合各类插件使用&lt;/p&gt;
&lt;h5 id=&quot;prettierrc&quot;&gt;5.2 、prettierrc&lt;/h5&gt;
&lt;p&gt;结合 &lt;code&gt;vscode&lt;/code&gt; 终极格式化 我们的代码，一键化操作带你飞~&lt;/p&gt;
&lt;h5 id=&quot;eslintrc&quot;&gt;5.3 、eslintrc&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;eslint&lt;/code&gt; 结合 各类 eslint 的规则。 进行 强/弱 类型提示 （0、1、2）&lt;/p&gt;
&lt;h5 id=&quot;babelrc&quot;&gt;5.4 、babelrc&lt;/h5&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;{
  &quot;presets&quot;: [&quot;es2015&quot;, &quot;stage-1&quot;, &quot;react&quot;],
  &quot;plugins&quot;: [&quot;transform-runtime&quot;, &quot;transform-decorators-legacy&quot;],
  &quot;env&quot;: {}
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结合 &lt;code&gt;babel&lt;/code&gt; 的各类 loader 进行 ES 的语法预编译处理，这里由于时间关系就不仔细去阐述了。&lt;/p&gt;
&lt;h3 id=&quot;六-总结&quot;&gt;六 、总结&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;一套好的规范，可以解决不想遇到的意外的bug、可以规范自己的编码习惯、可以让 code Review 更加简单。
好处多多，有待不断摸索，前期自然回遇到一些困难，但结果是值得期待的~&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;4.0568181818182&quot;&gt;
&lt;p&gt;GitHub 地址：（欢迎 star 、欢迎推荐 : )&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/erbing/blog/blob/master/%E5%89%8D%E7%AB%AF%E4%B9%8B%E8%B7%AF%20-%20%E8%A7%84%E8%8C%83/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83%20%E4%BB%8E%E5%88%B6%E5%AE%9A%E5%88%B0%E5%AE%9E%E6%96%BD.md&quot;&gt;前端开发规范 从制定到实施&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sun, 28 Apr 2019 06:04:00 +0000</pubDate>
<dc:creator>SmallW</dc:creator>
<og:description>前端开发规范 从制定到实施 在我们开始这个题目的时候，我们应该思考下面几个问题： 1. 前端开发为什么需要 开发规范？ 2. 前端开发规范是什么？ 3. 什么时候需要这个规范？ 4. 如何制定这个规范</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/erbingbing/p/10783641.html</dc:identifier>
</item>
</channel>
</rss>