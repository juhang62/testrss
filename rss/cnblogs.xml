<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>MVC + EFCore  项目实战 - 数仓管理系统1 - 编程小纸条</title>
<link>http://www.cnblogs.com/miro/p/13211630.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/miro/p/13211630.html</guid>
<description>&lt;p&gt;&lt;span&gt;这是一个数据管理&quot;工具类&quot;的系统，计划有三个核心功能：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、通过界面配置相关连接字符串，查询数据库的表数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、配置相关模板，生成数据库表。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以界面填报或通过Excel导入导出填报表数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、通过界面配置导出数据库表结构（数据字典）。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;通过以上功能，在数据分析、可视化项目中，更方便的进行数据管理。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;项目需要用到的基础知识之前已有文章做介绍，如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（共20篇，其中1~10是基础知识介绍，11~20是专题知识介绍）&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;项目实战部分实际是系列文章的续集，考虑到编号太长了，我们重新开始编号。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;之前的文章，由于种种原因（工作是项目制的， 经常需要管理多个项目进度，工作太忙没时间写），周期拉的太长，耽误了大家学习，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在经常还有园友加QQ群问问题和查看源码（也很少有时间回答，大部分问题都是园友们互助），实在抱歉。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;考虑到这些问题，实战部分的教程，准备每晚固定投入两小时，暑假期间完成初版，整个周期压缩在一个半月到两个月之间。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以开发速度为第一优先级， 围绕三个功能边设计边开发，快速迭代完成第一版本。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;文章更新时间为每周的周二和周五（如遇节假日顺延）。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;加拿大畅销书作家麦尔坎·葛拉威尔在《异数》一书中指出：&quot;人们眼中的天才之所以卓越非凡，并非天资超人一等，而是付出了持续不断的努力。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;只要经过1万小时的锤炼，任何人都能从平凡变成超凡。&quot;他将此称为&quot;一万小时定律&quot;。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;这里我要强调的并非是练习时间，而是练习方法。按每天三小时算，一万小时大概需要10年不间断的练习。如何缩短一万小时？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;答案是 &quot;刻意练习&quot;（deliberate practice）。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;首次提出&quot;刻意练习&quot;这个概念的是佛罗里达大学心理学家 K. Anders Ericsson。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这套练习方法的核心假设是，专家级水平是逐渐地练出来的，而有效进步的关键在于找到一系列的小任务让受训者按顺序完成。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这些小任务必须是受训者正好不会做，但是又正好可以学习掌握的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;完成这种练习要求受训者思想高度集中。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&quot;刻意练习&quot;的理论目前已经被广泛接受，我们总结一下它的特点。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;1、只在&quot;学习区&quot;练习 &lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;练习的精髓是要持续地做自己做不好的事。 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;心理学家把人的知识和技能分为嵌套的三个圆形区域：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最内一层是&quot;舒适区&quot;，是我们已经熟练掌握的各种技能；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最外一层是&quot;恐慌区&quot;，是我们暂时无法学会的技能；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;二者中间则是&quot;学习区&quot;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/101211/202006/101211-20200630081541975-753722026.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;只有在学习区里面练习，一个人才可能进步。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有效的练习任务必须精确的在受训者的&quot;学习区&quot;内进行，具有高度的针对性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因此我们首先必须发现自己的学习区，找到我们最需要改进的地方。 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;只在学习区练习，是一个非常强的要求。一旦已经学会了某个东西，就不应该继续在上面花时间，应该立即转入下一个难度。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;2、大量重复训练&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;从不会到会，秘诀是重复。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如MBA课程的一个典型特点就是把不常见的高难度事件（商业决策）重复化。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在商学院里一个学生每周可能要面对20个真实发生过的商业案例，学生们首先自己研究怎么决策，提出解决方案，最后老师给出实际的结果并作点评。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;学习商业决策的最好办法不是观察老板每个月做两次决策，而是自己每周做20次模拟的决策。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;疫情放假期间，我上了一些音乐学习的网课，在音乐训练中，比较强调&quot;分块&quot;练习。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先你要把整个动作或者整首曲子过一遍，看专家是怎么做的。然后把它分解为很多小块，一块一块地学习掌握。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;3、持续获得有效的反馈 &lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;要学会自己给自己当教练。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;优秀的学习者都有很强的自学能力，对他们而言，老师最重要的作用是提供即时的反馈。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;优秀的学习者会以一个旁观者的角度观察自己，每天都有非常具体的小目标，对自己的错误极其敏感，并不断寻求改进。 &lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;4、精神高度集中 &lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;请高效率的学习，不要磨洋工。刻意练习没有&quot;寓教于乐&quot;这个概念，完全投入的状态是很累的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;曾经有个著名小提琴家说过，如果你是练习手指，你可以练一整天；可是如果你是练习脑子，你每天能练两个小时就不错了。&lt;/span&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;1、这是一个非常实用的数据管理工具类软件，初版完成后你可以方便的去使用和扩展功能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、计划每周更新两次（周二和周五，节假日顺延），初版大约两个月完成。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、人生苦短。不断迭代你的学习方法，刻意练习。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;祝大家学习进步 ：）&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 30 Jun 2020 00:18:00 +0000</pubDate>
<dc:creator>编程小纸条</dc:creator>
<og:description>项目背景及需求说明 这是一个数据管理&amp;quot;工具类&amp;quot;的系统，计划有三个核心功能： 1、通过界面配置相关连接字符串，查询数据库的表数据。 2、配置相关模板，生成数据库表。 可以界面填报或通</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/miro/p/13211630.html</dc:identifier>
</item>
<item>
<title>恕我直言你可能真的不会java第9篇-Stream元素的匹配与查找 - 字母哥博客</title>
<link>http://www.cnblogs.com/zimug/p/13211574.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zimug/p/13211574.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202006/1815316-20200630081006382-1802805918.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;在我们对数组或者集合类进行操作的时候，经常会遇到这样的需求，比如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;是否包含某一个“匹配规则”的元素&lt;/li&gt;
&lt;li&gt;是否所有的元素都符合某一个“匹配规则”&lt;/li&gt;
&lt;li&gt;是否所有元素都不符合某一个“匹配规则”&lt;/li&gt;
&lt;li&gt;查找第一个符合“匹配规则”的元素&lt;/li&gt;
&lt;li&gt;查找任意一个符合“匹配规则”的元素&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这些需求如果用for循环去写的话，还是比较麻烦的，需要使用到for循环和break！本节就介绍一个如何用Stream API来实现“查找与匹配”。&lt;/p&gt;
&lt;h2 id=&quot;一、对比一下有多简单&quot;&gt;一、对比一下有多简单&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;employees是10个员工对象组成的List，在前面的章节中我们已经用过多次，这里不再列出代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果我们不用Stream API实现，查找员工列表中是否包含年龄大于70的员工？代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;boolean isExistAgeThan70 = false;
for(Employee employee:employees){
  if(employee.getAge() &amp;gt; 70){
    isExistAgeThan70 = true;
    break;
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果我们使用Stream API就是下面的一行代码，其中使用到了我们之前学过的&quot;谓词逻辑&quot;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;boolean isExistAgeThan70 = employees.stream().anyMatch(Employee.ageGreaterThan70);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将谓词逻辑换成lambda表达式也可以，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;boolean isExistAgeThan72 = employees.stream().anyMatch(e -&amp;gt; e.getAge() &amp;gt; 72);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以，我们介绍了第一个匹配规则函数：anyMatch，判断Stream流中是否包含某一个“匹配规则”的元素。这个匹配规则可以是&lt;strong&gt;lambda表达式&lt;/strong&gt;或者&lt;strong&gt;谓词&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;二、其他匹配规则函数介绍&quot;&gt;二、其他匹配规则函数介绍&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;是否所有员工的年龄都大于10岁？allMatch匹配规则函数：判断是够Stream流中的所有元素都&lt;strong&gt;符合&lt;/strong&gt;某一个&quot;匹配规则&quot;。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;boolean isExistAgeThan10 = employees.stream().allMatch(e -&amp;gt; e.getAge() &amp;gt; 10);
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;是否不存在小于18岁的员工？noneMatch匹配规则函数：判断是否Stream流中的所有元素都&lt;strong&gt;不符合&lt;/strong&gt;某一个&quot;匹配规则&quot;。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;boolean isExistAgeLess18 = employees.stream().noneMatch(e -&amp;gt; e.getAge() &amp;lt; 18);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;三、元素查找与optional&quot;&gt;三、元素查找与Optional&lt;/h2&gt;
&lt;p&gt;从列表中按照顺序查找第一个年龄大于40的员工。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Optional&amp;lt;Employee&amp;gt; employeeOptional
        =  employees.stream().filter(e -&amp;gt; e.getAge() &amp;gt; 40).findFirst();
System.out.println(employeeOptional.get());
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打印结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Employee(id=3, age=43, gender=M, firstName=Ricky, lastName=Martin)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Optional类代表一个值存在或者不存在。在java8中引入，这样就不用返回null了。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;isPresent() 将在 Optional 包含值的时候返回 true , 否则返回 false 。&lt;/li&gt;
&lt;li&gt;ifPresent(Consumer block) 会在值存在的时候执行给定的代码块。我们在第3章&lt;br/&gt;介绍了 Consumer 函数式接口；它让你传递一个接收 T 类型参数，并返回 void 的Lambda&lt;br/&gt;表达式。&lt;/li&gt;
&lt;li&gt;T get() 会在值存在时返回值，否则?出一个 NoSuchElement 异常。&lt;/li&gt;
&lt;li&gt;T orElse(T other) 会在值存在时返回值，否则返回一个默认值。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;3.8235294117647&quot;&gt;
&lt;p&gt;关于Optinal的各种函数用法请观看视频！&lt;a href=&quot;https://www.bilibili.com/video/BV1sE411P7C1/&quot;&gt;B站观看地址&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;findFirst用于查找第一个符合“匹配规则”的元素，返回值为Optional&lt;/li&gt;
&lt;li&gt;findAny用于查找任意一个符合“匹配规则”的元素，返回值为Optional&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;欢迎关注我的博客，里面有很多精品合集&quot;&gt;欢迎关注我的博客，里面有很多精品合集&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;本文转载注明出处（必须带连接，不能只转文字）：&lt;a href=&quot;http://www.zimug.com&quot;&gt;字母哥博客&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;觉得对您有帮助的话，帮我点赞、分享！您的支持是我不竭的创作动力！&lt;/strong&gt; 。另外，笔者最近一段时间输出了如下的精品内容，期待您的关注。&lt;/p&gt;
</description>
<pubDate>Tue, 30 Jun 2020 00:10:00 +0000</pubDate>
<dc:creator>字母哥博客</dc:creator>
<og:description>在我们对数组或者集合类进行操作的时候，经常会遇到这样的需求，比如： 是否包含某一个“匹配规则”的元素 是否所有的元素都符合某一个“匹配规则” 是否所有元素都不符合某一个“匹配规则” 查找第一个符合“匹</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zimug/p/13211574.html</dc:identifier>
</item>
<item>
<title>【Xamarin.Forms 1】App的创建与运行 - 芝麻麻雀</title>
<link>http://www.cnblogs.com/sesametech-netcore/p/13211541.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sesametech-netcore/p/13211541.html</guid>
<description>&lt;h2 id=&quot;引言&quot;&gt;引言&lt;/h2&gt;
&lt;p&gt;本篇文章将从介绍Xamarin.Forms创建开始。&lt;/p&gt;
&lt;h2 id=&quot;开发环境&quot;&gt;开发环境&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;Visual Studio 2019 16.6.2&lt;/li&gt;
&lt;li&gt;Xamarin.Forms 4.6.0.726&lt;/li&gt;
&lt;li&gt;Android 5.0 (API 级别21 - Lollipop)以上&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;一、新建app项目&quot;&gt;一、新建App项目&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;在VS2019启动后，选择项目类型为：移动应用(Xamarin.Forms)，点击&lt;code&gt;下一步&lt;/code&gt;。为了更快的找到要创建的项目类型，可以在上面的选择框中分别选择：C# Android，选择好这两项后就可以很快的找到Xamarin.Forms项目类型了。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1746998/202006/1746998-20200629184321344-20582812.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;输入项目名称：HelloXamarinApp，选择好一个存储项目的路径，点击&lt;code&gt;创建&lt;/code&gt;按钮，&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1746998/202006/1746998-20200629185624572-740182900.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;模版先选择Blank，平台选择Android和iOS，点击OK，完成项目的创建。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1746998/202006/1746998-20200629190127770-1753619340.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;二、使用nuget更新xamarinforms&quot;&gt;二、使用NUGET更新Xamarin.Forms&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;点击解决方案，右键-&amp;gt;管理解决方案的NuGet程序包(N)，打开NuGet，点击&lt;code&gt;更新&lt;/code&gt;选项卡，更新&lt;code&gt;Xamarin.Essentials&lt;/code&gt;,&lt;code&gt;Xamarin.Forms&lt;/code&gt;两个程序包。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1746998/202006/1746998-20200629190936008-2109168521.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;三、启动android项目&quot;&gt;三、启动Android项目&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;我们使用真机运行项目。在手机使用USB线接入电脑后，在下图的红框位置选择对应手机型号的选项。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1746998/202006/1746998-20200629191935904-1935553239.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot; readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;按&lt;code&gt;Ctrl + F5&lt;/code&gt;启动项目，在手机上安装的需要的一些支持库，首先安装的是&lt;code&gt;Mono Shared Runtime&lt;/code&gt;工具，弹窗的窗口中选择：继续安装&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1746998/202006/1746998-20200629192543650-1676309849.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;荣耀手机检查安装的支持库来源检测，点击：继续安装，即可。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1746998/202006/1746998-20200629192725556-103085063.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;再进行安装&lt;code&gt;Xamarin.Android API-28 Support&lt;/code&gt;支持库，仍然选择：继续安装。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1746998/202006/1746998-20200629192926957-1969244210.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;荣耀手机检查安装的支持库来源检测，点击：继续安装，即可。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1746998/202006/1746998-20200629193003683-967707944.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;6&quot;&gt;&lt;li&gt;最后进行安装我们的项目：HelloXamarinApp.Android，选择：继续安装。我们可以看到默认使用的权限为：读取你的 SD 卡中的内容、修改或删除 SD 卡中的内容。两项权限。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1746998/202006/1746998-20200629193057173-336389394.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;7&quot; readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;荣耀手机再次检查安装来源，点击：继续安装，即可。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1746998/202006/1746998-20200629193222063-1645226882.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;安装完成后，我们手机上已经有我们的项目的App了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1746998/202006/1746998-20200629193323914-295387495.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;9&quot;&gt;&lt;li&gt;在手机运行App。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1746998/202006/1746998-20200629194131631-2018152718.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;0.95744680851064&quot;&gt;
&lt;p&gt;参考：&lt;a href=&quot;https://www.jianshu.com/p/5eb2a58f9637&quot;&gt;https://www.jianshu.com/p/5eb2a58f9637&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 29 Jun 2020 23:55:00 +0000</pubDate>
<dc:creator>芝麻麻雀</dc:creator>
<og:description>引言 本篇文章将从介绍Xamarin.Forms创建开始。 开发环境 Visual Studio 2019 16.6.2 Xamarin.Forms 4.6.0.726 Android 5.0 (AP</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sesametech-netcore/p/13211541.html</dc:identifier>
</item>
<item>
<title>Flutter 中那么多组件，难道要都学一遍？ - 老孟Flutter</title>
<link>http://www.cnblogs.com/mengqd/p/13211505.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mengqd/p/13211505.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202006/467322-20200630072515350-204253364.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在 Flutter 中一切皆是 &lt;strong&gt;组件&lt;/strong&gt;，仅仅 Widget 的子类和间接子类就有 &lt;strong&gt;350&lt;/strong&gt; 多个，整理的 &lt;a href=&quot;http://laomengit.com/flutter/widgets/widgets_structure.html&quot;&gt;&lt;strong&gt;Flutter组件继承关系图&lt;/strong&gt;&lt;/a&gt; 可以帮助大家更好的理解学习 Flutter，回归正题，如此多的组件到底如果学习，真的需要学习 350 多个组件？&lt;/p&gt;
&lt;p&gt;在经济学中有一个著名的 &lt;strong&gt;二八定律&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;二八定律是意大利经济学家帕累托发现的。帕累托认为任何一组东西中最重要的只占其中一小部分约占20%，其余80%尽管是多数，却是次要的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;而我们学习 Flutter 也适用于二八定律，大部分组件是平时很少用到的，因此作为初学者，只需学习那 20% 常用的组件即可，常用的组件及案例地址：&lt;a href=&quot;http://laomengit.com/guide/introduction/mobile_system.html&quot;&gt;http://laomengit.com/guide/introduction/mobile_system.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;除了常用组件外，还总结了300多个其余组件到详细用法，这些组件可以作为手册，用到的时候在查阅即可，地址：&lt;a href=&quot;http://laomengit.com/flutter/widgets/widgets_structure.html&quot;&gt;http://laomengit.com/flutter/widgets/widgets_structure.html&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;组件树&quot;&gt;组件树&lt;/h3&gt;
&lt;p&gt;Flutter 创建App的时候，所有的组件最后会生成一个&lt;strong&gt;组件树&lt;/strong&gt;，例如如下代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Flutter Demo',
      theme: ThemeData(
      ),
      home: Scaffold(
        body: Text('老孟'),
      ),
    );
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;main&lt;/strong&gt; 函数是应用程序开始的地方，运行 MyApp 组件。生成的组件树如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202006/467322-20200630072515691-1066559105.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;让 Text 组件居中，修改如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;Scaffold(
  body: Center(
    child: Text('老孟'),
  ),
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;生成的组件树如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202006/467322-20200630072515904-494852240.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;给应用程序添加 AppBar：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;Scaffold(
  appBar: AppBar(),
  body: Center(
    child: Text('老孟'),
  ),
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;生成的组件树如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202006/467322-20200630072516109-1623435676.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;statefulwidget-vs-statelesswidget&quot;&gt;StatefulWidget vs StatelessWidget&lt;/h3&gt;
&lt;p&gt;Flutter 中组件分为 &lt;strong&gt;无状态组件（StatelessWidget）&lt;/strong&gt; 和 &lt;strong&gt;有状态组件（StatefulWidget）&lt;/strong&gt;两种。它们唯一的区别就是运行时 &lt;strong&gt;重新加载&lt;/strong&gt; 组件的方式不同，StatelessWidget 组件重新加载时重新创建当前组件的实例，而StatefulWidget组件重新加载时不会重新创建实例，而是重新执行 &lt;strong&gt;build&lt;/strong&gt; 函数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;StatelessWidget&lt;/strong&gt; 组件创建的方式：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;class StatelessWidgetDemo extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Container();
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;build 函数返回当前组件，此组件一旦创建将不可改变，build 函数只能执行一次。如果想重新绘制此组件，只能重新创建此组件新的实例。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;StatefulWidget&lt;/strong&gt; 组件创建的方式：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;class StatefulWidgetDemo extends StatefulWidget {
  @override
  _StatefulWidgetDemoState createState() =&amp;gt; _StatefulWidgetDemoState();
}

class _StatefulWidgetDemoState extends State&amp;lt;StatefulWidgetDemo&amp;gt; {
  @override
  Widget build(BuildContext context) {
    return Container();
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;StatefulWidget 组件的创建方式和 StatelessWidget 不同，&lt;strong&gt;State&amp;lt;&amp;gt;&lt;/strong&gt; 中的 build 函数返回当前组件，有状态的组件可以在其生命周期内多次重绘，即多次调用 build 函数，而不是创建一个新的实例。&lt;/p&gt;
&lt;p&gt;StatefulWidget 组件重绘需要调用 setstate 方法，setstate 会使其自身及其子组件重绘，所以尽量封装 StatefulWidget 组件，避免无效的重建和重绘，影响性能。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;快速书写小技巧：在 Android Studio 和 VS Code 中 输入 &lt;strong&gt;stl&lt;/strong&gt; 然后点击回车，可以快速创建 StatelessWidget 组件，同理输入 &lt;strong&gt;stf&lt;/strong&gt; 点击回车，可以快速创建 StatefulWidget 组件，这是编辑器 &lt;strong&gt;Live Templates&lt;/strong&gt; 的功能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;material-vs-cupertino&quot;&gt;Material vs Cupertino&lt;/h3&gt;
&lt;p&gt;Flutter 中包含两套风格的组件，分别是 Material 和 Cupertino ，Cupertino 是 iOS风格的组件，命名都带 Cupertino 前缀，比如 CupertinoSlider 、 CupertinoDatePicker 等， Material Design 是由 Google 推出，旨在为手机、平板电脑、台式机和“其他平台”提供更一致、更广泛的“外观和感觉”。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Flutter 使用一套代码在不同的平台上表现一致&lt;/strong&gt;，它不会根据不同的平台绘制不同的外形，比如使用 AlertDialog 弹出警告框，不管在 Android 上，还是在 iOS上效果是一样。&lt;/p&gt;
&lt;p&gt;但有一些功能 Flutter 区分平台，比如 ListView 滑动到底部时继续滑动，Android 底部会出现淡蓝色（默认情况下）拱形，而 iOS 上则没有，这是因为 Flutter 在封装此组件时在代码中区分了平台，所以在查看 Flutter 源码到过程中会经常看到根据不同的平台做不同处理的情况。&lt;/p&gt;
&lt;h2 id=&quot;交流&quot;&gt;交流&lt;/h2&gt;
&lt;p&gt;老孟Flutter博客地址（330个控件用法）：&lt;a href=&quot;http://laomengit.com&quot;&gt;http://laomengit.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎加入Flutter交流群（微信：laomengit）、关注公众号【老孟Flutter】：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th/&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202006/467322-20200630072516375-376560138.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202006/467322-20200630072516607-413248094.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</description>
<pubDate>Mon, 29 Jun 2020 23:25:00 +0000</pubDate>
<dc:creator>老孟Flutter</dc:creator>
<og:description>在 Flutter 中一切皆是 组件，仅仅 Widget 的子类和间接子类就有 350 多个，整理的 Flutter组件继承关系图 可以帮助大家更好的理解学习 Flutter，回归正题，如此多的组件到</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mengqd/p/13211505.html</dc:identifier>
</item>
<item>
<title>一张PDF了解JDK9 GC调优秘籍-附PDF下载 - flydean</title>
<link>http://www.cnblogs.com/flydean/p/jdk9-gc-cheatsheet.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flydean/p/jdk9-gc-cheatsheet.html</guid>
<description>&lt;p&gt;今天我们讲讲JDK9中的JVM GC调优参数，JDK9中JVM的参数总共有2142个，其中正式的参数有659个。好像比JDK8中的参数要少一点。&lt;/p&gt;
&lt;p&gt;为了方便大家的参考，特意将JDK9中的GC参数总结成了一张PDF，这个PDF比之前总结的JDK8的PDF在排版，颜色和内容准确性上面又有了非常大的提升，欢迎大家下载。&lt;/p&gt;

&lt;p&gt;今天这篇文章的内容都是从Oracle JDK9的官方文档中提炼出来的。对于里面的内容的真实性，我不能保证是100%正确的。&lt;/p&gt;
&lt;p&gt;有人要问了，官网文档也会有错误？&lt;/p&gt;
&lt;p&gt;这个问题要从两个方面说起，第一方面，任何人都会犯错误，虽然官网文档经过了编辑，校验核对然后才发布，但是总会有一些遗漏的地方。&lt;/p&gt;
&lt;p&gt;第二，Oracle的文档是有专门的写文档的部门来专门编写的，写文档就是他们的工作，所以，这些文档并不是开发JDK的开发人员编写的，而是和开发JDK不相关的文档编写员编写的。&lt;/p&gt;
&lt;p&gt;至于文档写完之后有没有JDK开发人员过目，大家可以自行脑补......&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;所以古人说得好，尽信书不如无书。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;一代新人换旧人，长江后浪推前浪。由来只有新人笑 有谁听到旧人哭。&lt;/p&gt;
&lt;p&gt;JDK9出现了，那么JDK8中的一些参数自然需要退伍了。&lt;/p&gt;
&lt;p&gt;我们回想一下JDK9中有些什么变化呢？我总结一下有三个。&lt;/p&gt;
&lt;ol readability=&quot;5.5&quot;&gt;&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;最大的变化就是引入了JPMS(Java Platform Module System)也就是Project Jigsaw。&lt;/p&gt;
&lt;p&gt;模块化的本质就是将一个大型的项目拆分成为一个一个的模块，每个模块都是独立的单元，并且不同的模块之间可以互相引用和调用。&lt;/p&gt;
&lt;p&gt;在module中会有元数据来描述该模块的信息和该模块与其他模块之间的关系。这些模块组合起来，构成了最后的运行程序。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;然后就是引入的Xlog日志服务，通过Xlog日志服务我们可以监控JVM中的事件，比如：GC,class loading,JPMS,heap,thread等等。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;最后就是将String中的底层存储从char数组换成了byte数组。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这三个变化中和JVM最相关的就是第二个Xlog日志服务。&lt;/p&gt;
&lt;h2 id=&quot;废弃的jvm选项&quot;&gt;废弃的JVM选项&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;-Xusealtsigs / -XX:+UseAltSigs&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这两个选项在JDK9中被废弃了，如果你不知道也没关系，因为这两个选项是在Oracle Solaris中专有的。现在用Solaris服务器的人应该比较少了.....&lt;/p&gt;
&lt;h2 id=&quot;不推荐deprecated的jvm选项&quot;&gt;不推荐(Deprecated)的JVM选项&lt;/h2&gt;
&lt;p&gt;下面这些选项是JVM已经不再推荐使用了，如果你使用的话也没问题，但是会有报警。&lt;/p&gt;
&lt;p&gt;Deprecated表示这些选项会在未来被删除，我们应该尽量避免使用这些选项。&lt;/p&gt;
&lt;p&gt;选项有很多，我们挑一些比较常见和重要的来给大家讲解一下。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-d32 / -d64&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;为什么这两个参数会被不推荐呢？因为现在的服务器性能已经非常非常的好了。&lt;/p&gt;
&lt;p&gt;如果你的JDK是64位的，那么默认就启用了-server和-d64模式，32位的JDK现在应该很少见到了。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Oracle官方文档说只有Java HotSpot Server VM才有64位的模式。不知道是真是假，因为其他的VM我也没有用过，没有发言权。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;-Xloggc:garbage-collection.log&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;因为JDK9中引入Xlog框架，所以之前的日志输出的参数都被替换成了新的Xlog格式：&lt;/p&gt;
&lt;p&gt;比如上面的命令被替换成为 &lt;code&gt;-Xlog:gc:garbage-collection.log&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;所以那些以Print开头的GC日志输出参数都是不推荐的。我们需要使用Xlog来替代。&lt;/p&gt;
&lt;p&gt;同样的以Trace开头的运行时日志输出参数也是不推荐的，也可以使用Xlog来替代。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-XX:+UseConcMarkSweepGC / -XX:CMS*&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;CMS在JDK9中是不被推荐的，所以CMS开头的参数都不要用了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-XX:+UseParNewGC&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;因为ParNewGC是和CMS一起使用的，所以CMS不推荐之后，ParNewGC也是不推荐使用的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-XX:MaxPermSize=size / -XX:PermSize=size&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;JDK8中，Prem区已经被移到了Metaspace，所以上面的参数可以被下面的替代：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-XX:MaxMetaspaceSize=size / -XX:MetaspaceSize=size&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;被删除的jvm参数&quot;&gt;被删除的JVM参数&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;-Xincgc&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;增量GC在JDK9中被删除了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-Xmaxjitcodesize=size&lt;/code&gt; JIT中最大的code cache大小被替换成 &lt;code&gt;-XX:ReservedCodeCacheSize&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;还有其他的一些CMS的参数。&lt;/p&gt;

&lt;p&gt;AppCDS的全称是Application Class-Data Sharing。主要是用来在不同的JVM中共享Class-Data信息，从而提升应用程序的启动速度。&lt;/p&gt;
&lt;p&gt;通常来说，如果要执行class字节码，JVM需要执行下面的一些步骤：给定一个类的名字，JVM需要从磁盘上面找到这个文件，加载，并验证字节码，最后将它加载进来。&lt;/p&gt;
&lt;p&gt;如果JVM启动的时候需要加载成百上千个class，那么需要的就不是一个小数目了。&lt;/p&gt;
&lt;p&gt;对于打包好的jar包来说，只要jar的内容不变，那么jar包中的类的数据始终是相同的。JVM在启动时候每次都会运行相同的加载步骤。&lt;/p&gt;
&lt;p&gt;AppCDS的作用就是将这些能够共享的数据归类成一个存储文件，在不同的JVM中共享。&lt;/p&gt;
&lt;p&gt;下面是AppCDS的大概工作流程：&lt;/p&gt;
&lt;ol readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;选择要归档的class，并创建一个class的列表，用在归档中。（ -XX:DumpLoadedClassList）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;创建归档文件（-Xshare:dump和-XX:SharedArchiveFile）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;使用归档文件（-Xshare:on 和 -XX:SharedArchiveFile）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;相应的VM参数如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200623211247590.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_0,text_aHR0cDovL3d3dy5mbHlkZWFuLmNvbQ==,size_35,color_8F8F8F,t_70&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在java程序中，我们通过日志来定位和发现项目中可能出现的问题。在现代java项目中，我们使用log4j或者slf4j，Logback等日志记录框架来处理日志问题。&lt;/p&gt;
&lt;p&gt;JVM是java程序运行的基础，JVM中各种事件比如：GC,class loading,JPMS,heap,thread等等其实都可以有日志来记录。通过这些日志，我们可以监控JVM中的事件，并可以依次来对java应用程序进行调优。&lt;/p&gt;
&lt;p&gt;在JDK9中引入的Xlog日志服务就是为这个目的而创建的。&lt;/p&gt;
&lt;p&gt;通过xlog，JDK将JVM中的各种事件统一起来，以统一的形式对外输出。通过tag参数来区分子系统，通过log level来区分事件的紧急性，通过logging output来配置输出的地址。&lt;/p&gt;
&lt;p&gt;在JDK9之后，之前的Print*参数都被Xlog所代替了。&lt;/p&gt;
&lt;p&gt;我们看下常用的Xlog和GC日志参数：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200623211704311.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_0,text_aHR0cDovL3d3dy5mbHlkZWFuLmNvbQ==,size_35,color_8F8F8F,t_70&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;作为JDK9中的默认垃圾回收器G1，对G1的调优是必不可少的。下面是G1的参数：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200623211932693.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_0,text_aHR0cDovL3d3dy5mbHlkZWFuLmNvbQ==,size_35,color_8F8F8F,t_70&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;下面是通用的VM参数：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200623212028662.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_0,text_aHR0cDovL3d3dy5mbHlkZWFuLmNvbQ==,size_35,color_8F8F8F,t_70&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;下面是JDK9中的通用GC参数：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200623212122210.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_0,text_aHR0cDovL3d3dy5mbHlkZWFuLmNvbQ==,size_35,color_8F8F8F,t_70&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;下面是JDK9中的内存调整参数：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200623212227955.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_0,text_aHR0cDovL3d3dy5mbHlkZWFuLmNvbQ==,size_35,color_8F8F8F,t_70&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;千言万语不如一张PDF。我把JDK9的GC参数总结成了一张PDF，下面是PDF的下载链接。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/ddean2009/www.flydean.com/blob/master/cheatSheet/JDK9GC-cheatsheet.pdf&quot;&gt;JDK9GC-cheatsheet.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎大家下载。&lt;/p&gt;
&lt;blockquote readability=&quot;8.6666666666667&quot;&gt;
&lt;p&gt;本文作者：flydean程序那些事&lt;/p&gt;
&lt;p&gt;本文链接：&lt;a href=&quot;http://www.flydean.com/jdk9-gc-cheatsheet/&quot;&gt;http://www.flydean.com/jdk9-gc-cheatsheet/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文来源：flydean的博客&lt;/p&gt;
&lt;p&gt;欢迎关注我的公众号:程序那些事，更多精彩等着您！&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 29 Jun 2020 22:54:00 +0000</pubDate>
<dc:creator>flydean</dc:creator>
<og:description>简介 今天我们讲讲JDK9中的JVM GC调优参数，JDK9中JVM的参数总共有2142个，其中正式的参数有659个。好像比JDK8中的参数要少一点。 为了方便大家的参考，特意将JDK9中的GC参数总</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/flydean/p/jdk9-gc-cheatsheet.html</dc:identifier>
</item>
<item>
<title>Docker入门——理解Docker的核心概念 - 南瓜慢说</title>
<link>http://www.cnblogs.com/larrydpk/p/13211467.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/larrydpk/p/13211467.html</guid>
<description>&lt;p&gt;相信不少人听过这么一句话：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;人类的本质是复读机。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在软件开发领域也一样，我们总是想寻找更好地方式复制优秀的逻辑或系统。最核心的方法是抽取通用逻辑和组件，把差异化的东西接口化或配置化，达到复用的效果。如&lt;code&gt;Java&lt;/code&gt;的&lt;code&gt;Build Once, Run Everywhere&lt;/code&gt;，还有&lt;code&gt;Spring&lt;/code&gt;的强大的抽象能力。这是应用层面的复用，&lt;code&gt;Docker&lt;/code&gt;则在系统层面作文章，让我们可以快速复制一个系统（如CentOS）或一个服务（如Kafka）。&lt;/p&gt;

&lt;p&gt;利用&lt;code&gt;Docker&lt;/code&gt;，我们可以很快的使用别人已经建立好的镜像来发布一个完整的系统或某个组件。它至少提供了以下便利：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;提供一致的运行环境。从同一个镜像文件创建容器，应用运行环境相同，保持开发环境、测试环境和生产环境的一致。这能减少许多因环境差异和配置差异带来的问题。测试提了Bug，开发再也不能第一时间回：是你环境没配好吧？是你不会用吧？&lt;/li&gt;
&lt;li&gt;弹性的系统。因&lt;code&gt;Docker&lt;/code&gt;可快速启动/停止，使系统能根据请求量/数据量动态的改变运行的服务数量，以提供伸缩可变的系统服务。&lt;/li&gt;
&lt;li&gt;微服务开发。容器可以非常轻量级，而且可快速动态启停，非常适用于微服务架构。一台物理机器也能运行多个容器，不一定需要物理集群。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;复制一个系统，我们可以通过增加一台物理机，或者通过虚拟机技术运行多个系统，现在有了&lt;code&gt;Docker&lt;/code&gt;，还可以通过它来启动一个系统。与其它方式相比，&lt;code&gt;Docker&lt;/code&gt;有以下优势：&lt;/p&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;启动速度快，秒级的启动速度；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;性能好，近似物理机的性能，不会有过多资源损失和性能浪费；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;体量小，镜像可以做得更小（MB级），不像虚拟机的几GB；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;跨平台，能在Linux/Unix/Mac/Windows系统下运行；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;利于CI/CD，有成熟的技术实践；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;社区活跃，有大公司背书，应用广泛，镜像资源丰富。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;31-镜像image&quot;&gt;3.1 镜像Image&lt;/h2&gt;
&lt;p&gt;说起镜像，不由想起当年拿着U盘捣鼓各种系统的日子。那时会找各种系统的&lt;code&gt;iso文件&lt;/code&gt;，下载速度还特别慢，几GB的文件呢。那些&lt;code&gt;iso文件&lt;/code&gt;，就是镜像文件。但这些镜像文件是相对于物理机系统或虚拟机技术而言的，而不是&lt;code&gt;Docker&lt;/code&gt;的镜像文件。&lt;/p&gt;
&lt;p&gt;对于&lt;code&gt;Docker&lt;/code&gt;而言，镜像会被统一管理，在本地有特定的地方存放镜像，不同的系统位置不一样。一般而言，是无须自己管理镜像文件的，&lt;code&gt;Docker&lt;/code&gt;会有效地管理和组织。列出所有镜像命令如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;docker images
或docker image ls
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/946674/202006/946674-20200630040004752-770359420.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Docker&lt;/code&gt;由镜像启动容器，就像通过&lt;code&gt;iso文件&lt;/code&gt;安装启动系统一样。镜像是通用的，因此也是可以共享的。一般我们可以通过复用别人做好的优秀镜像来提高开发效率。我们只需要在别人镜像的基础上做定制开发即可。例如我们可拉取一个带&lt;code&gt;JDK&lt;/code&gt;的&lt;code&gt;Linux&lt;/code&gt;镜像，然后把自己的Java应用添加上去，形成自己新的镜像。&lt;/p&gt;
&lt;p&gt;为了提高复用率与速度，我们将镜像分层，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/946674/202006/946674-20200630040005712-1467437287.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如镜像B是基于镜像A打包而成的，则镜像B比镜像A多一层。镜像B包含了镜像A的所有层级。这样做的好处是，不用管理一个大的镜像，而管理层级变化。假如本机已经下载了镜像E，则本机已经有（A, B, C, E），当需要拉取F的时候，不再需要拉取（A, B）了。这利用了&lt;code&gt;Docker&lt;/code&gt;的缓存技术，另外，在构建新镜像时，同样也使用了缓存。&lt;/p&gt;
&lt;p&gt;标签Tag是镜像的重要概念，一般用于标记版本号，对于同一个镜像源名，可以有多个标签，如&lt;code&gt;redis:5.0.8&lt;/code&gt;、&lt;code&gt;redis:latest&lt;/code&gt;，&lt;code&gt;5.0.8&lt;/code&gt;和&lt;code&gt;latest&lt;/code&gt;都是标签名，默认使用&lt;code&gt;latest&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;32-容器container&quot;&gt;3.2 容器Container&lt;/h2&gt;
&lt;p&gt;有了镜像后，就可以创建容器了。启动一个容器，就像启动一个进程一样快速，可以通过&lt;code&gt;docker run&lt;/code&gt;命令启动，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;$ docker run hello-world

Hello from Docker!
This message shows that your installation appears to be working correctly.

To generate this message, Docker took the following steps:
 1. The Docker client contacted the Docker daemon.
 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.
    (amd64)
 3. The Docker daemon created a new container from that image which runs the
    executable that produces the output you are currently reading.
 4. The Docker daemon streamed that output to the Docker client, which sent it
    to your terminal.

To try something more ambitious, you can run an Ubuntu container with:
 $ docker run -it ubuntu bash

Share images, automate workflows, and more with a free Docker ID:
 https://hub.docker.com/

For more examples and ideas, visit:
 https://docs.docker.com/get-started/
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;容器提供了软件硬件环境，会消耗物理机资源，同时它还具有状态，相互隔离。可以从一个镜像启动多个不同的容器，如从&lt;code&gt;Ubuntu&lt;/code&gt;镜像启动多个&lt;code&gt;Ubuntu&lt;/code&gt;系统。可以通过命令&lt;code&gt;docker ps&lt;/code&gt;查看当前运行的容器，已经停止的容器不会显示出来。当容器停止时，容器文件并不会消失，可以通过&lt;code&gt;docker ps -a&lt;/code&gt;查看所有容器。&lt;/p&gt;
&lt;p&gt;可以简单理解镜像与容器的关系：&lt;/p&gt;
&lt;p&gt;镜像是容器的模板，是没运行没状态的文件，启动容器需要镜像。容器是运行着的、带状态的相互隔离的服务。可以由一个镜像启动多个容器，也可以从一个容器创建一个镜像，但这并不说明两者是可逆的相互转换。&lt;/p&gt;
&lt;h2 id=&quot;33-仓库repository&quot;&gt;3.3 仓库Repository&lt;/h2&gt;
&lt;p&gt;仓库很容易理解，就是存放镜像的地方。既然镜像是通用的，可以共享，那就需要一个共享的地方，仓库承担着这样一个责任。这跟&lt;code&gt;maven&lt;/code&gt;、&lt;code&gt;npm&lt;/code&gt;等是同样的道理。最大、最常用的仓库当然是官方仓库&lt;code&gt;Docker Hub&lt;/code&gt;，但国内访问速度也相当感人，可以通过使用国内仓库解决这个问题，如使用阿里的仓库。这跟&lt;code&gt;GitHub&lt;/code&gt;、&lt;code&gt;maven&lt;/code&gt;也是何其相似。&lt;/p&gt;
&lt;p&gt;我们可以从仓库拉取别人的镜像，也可以把自己构建的镜像推送到仓库上。&lt;/p&gt;

&lt;h2 id=&quot;本次主要讲解一下docker的概念，实践与命令以后再一一道来。&quot;&gt;本次主要讲解一下&lt;code&gt;Docker&lt;/code&gt;的概念，实践与命令以后再一一道来。&lt;/h2&gt;
&lt;p&gt;欢迎访问&lt;a href=&quot;https://www.pkslow.com/&quot;&gt;南瓜慢说 www.pkslow.com&lt;/a&gt;获取更多精彩文章！&lt;/p&gt;
&lt;p&gt;欢迎关注微信公众号&amp;lt;&lt;strong&gt;南瓜慢说&lt;/strong&gt;&amp;gt;，将持续为你更新...&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/946674/202006/946674-20200630040025023-1791639170.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多读书，多分享；多写作，多整理。&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 29 Jun 2020 20:00:00 +0000</pubDate>
<dc:creator>南瓜慢说</dc:creator>
<og:description>1 前言 相信不少人听过这么一句话： 人类的本质是复读机。 在软件开发领域也一样，我们总是想寻找更好地方式复制优秀的逻辑或系统。最核心的方法是抽取通用逻辑和组件，把差异化的东西接口化或配置化，达到复用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/larrydpk/p/13211467.html</dc:identifier>
</item>
<item>
<title>【Spring注解驱动开发】BeanPostProcessor在Spring底层是如何使用的？看完这篇我懂了！！ - 冰河团队</title>
<link>http://www.cnblogs.com/binghe001/p/13211362.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/binghe001/p/13211362.html</guid>
<description>&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;blockquote readability=&quot;6.469298245614&quot;&gt;
&lt;p&gt;在《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg3MzE1NTIzNA==&amp;amp;mid=2247485089&amp;amp;idx=1&amp;amp;sn=466c246a28440329d4bf3d82a2214229&amp;amp;chksm=cee5196cf992907a3aaa9e7bfef971328a16ceb525c8c80a34822e04955de3f423e1b8f90540&amp;amp;token=2101168258&amp;amp;lang=zh_CN#rd&quot;&gt;【String注解驱动开发】面试官再问你BeanPostProcessor的执行流程，就把这篇文章甩给他！&lt;/a&gt;》一文中，我们详细的介绍了BeanPostProcessor的执行流程。那么，BeanPostProcessor在Spring底层是如何使用的？今天，我们就一起来探讨下Spring的源码，一探BeanPostProcessor在Spring底层的使用情况。&lt;/p&gt;

&lt;p&gt;项目工程源码已经提交到GitHub：&lt;a href=&quot;https://github.com/sunshinelyz/spring-annotation&quot;&gt;https://github.com/sunshinelyz/spring-annotation&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;beanpostprocessor接口&quot;&gt;BeanPostProcessor接口&lt;/h2&gt;
&lt;p&gt;我们先来看下BeanPostProcessor接口的源码，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package org.springframework.beans.factory.config;
import org.springframework.beans.BeansException;
import org.springframework.lang.Nullable;

public interface BeanPostProcessor {
    
        @Nullable
        default Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
                return bean;
        }

        @Nullable
        default Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
                return bean;
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，在BeanPostProcessor接口中，提供了两个方法：postProcessBeforeInitialization()方法和postProcessAfterInitialization()方法。postProcessBeforeInitialization()方法会在bean初始化之前调用，postProcessAfterInitialization()方法会在bean初始化之后调用。接下来，我们就分析下BeanPostProcessor接口在Spring中的实现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：这里，我列举几个BeanPostProcessor接口在Spring中的实现类，来让大家更加清晰的理解BeanPostProcessor接口在Spring底层的应用。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;applicationcontextawareprocessor类&quot;&gt;ApplicationContextAwareProcessor类&lt;/h2&gt;
&lt;p&gt;org.springframework.context.support.ApplicationContextAwareProcessor是BeanPostProcessor接口的实现类，这个类的作用是可以向组件中注入IOC容器，大致的源码如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package org.springframework.context.support;

import java.security.AccessControlContext;
import java.security.AccessController;
import java.security.PrivilegedAction;

import org.springframework.beans.BeansException;
import org.springframework.beans.factory.config.BeanPostProcessor;
import org.springframework.beans.factory.config.EmbeddedValueResolver;
import org.springframework.context.ApplicationContextAware;
import org.springframework.context.ApplicationEventPublisherAware;
import org.springframework.context.ConfigurableApplicationContext;
import org.springframework.context.EmbeddedValueResolverAware;
import org.springframework.context.EnvironmentAware;
import org.springframework.context.MessageSourceAware;
import org.springframework.context.ResourceLoaderAware;
import org.springframework.lang.Nullable;
import org.springframework.util.StringValueResolver;
class ApplicationContextAwareProcessor implements BeanPostProcessor {
    /****************************省略N多行代码************************/
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里，省略了源码的细节，只给出了类结构，感兴趣的小伙伴们可自行翻阅Spring源码进行查看，我这里的Spring版本为5.2.6.RELEASE。&lt;/p&gt;
&lt;p&gt;那具体如何使用ApplicationContextAwareProcessor类向组件中注入IOC容器呢？别急，我用一个例子来说明下，相信小伙伴们看完后会有一种豁然开朗的感觉——哦，原来是它啊，我之前在项目中使用过的！&lt;/p&gt;
&lt;p&gt;要想使用ApplicationContextAwareProcessor类向组件中注入IOC容器，我们就不得不提Spring中的另一个接口：ApplicationContextAware，如果需要向组件中注入IOC容器，可以使组件实现ApplicationContextAware接口。&lt;/p&gt;
&lt;p&gt;例如，我们创建一个Employee类，使其实现ApplicationContextAware接口，此时，我们需要实现ApplicationContextAware接口的setApplicationContext()方法，在setApplicationContext()方法中有一个ApplicationContext类型的参数，这个就是IOC容器对象，我们可以在Employee类中定义一个ApplicationContext类型的成员变量，然后在setApplicationContext()方法中为这个成员变量赋值，此时就可以在Employee中的其他方法中使用ApplicationContext对象了，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package io.mykit.spring.plugins.register.bean;

import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.stereotype.Component;
/**
 * @author binghe
 * @version 1.0.0
 * @description 测试ApplicationContextAware
 */
@Component
public class Employee implements ApplicationContextAware {
    private ApplicationContext applicationContext;
    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看到这里，相信不少小伙伴们都有一种很熟悉的感觉：没错，我之前也在项目中使用过！是的，这就是BeanPostProcessor在Spring底层的一种使用场景。至于上面的案例代码为何会在setApplicationContext()方法中获取到ApplicationContext对象，这就是ApplicationContextAwareProcessor类的功劳了！&lt;/p&gt;
&lt;p&gt;接下来，我们就深入分析下ApplicationContextAwareProcessor类。&lt;/p&gt;
&lt;p&gt;我们先来看下ApplicationContextAwareProcessor类中对于postProcessBeforeInitialization()方法的实现，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Override
@Nullable
public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
    if (!(bean instanceof EnvironmentAware || bean instanceof EmbeddedValueResolverAware ||
          bean instanceof ResourceLoaderAware || bean instanceof ApplicationEventPublisherAware ||
          bean instanceof MessageSourceAware || bean instanceof ApplicationContextAware)){
        return bean;
    }

    AccessControlContext acc = null;

    if (System.getSecurityManager() != null) {
        acc = this.applicationContext.getBeanFactory().getAccessControlContext();
    }

    if (acc != null) {
        AccessController.doPrivileged((PrivilegedAction&amp;lt;Object&amp;gt;) () -&amp;gt; {
            invokeAwareInterfaces(bean);
            return null;
        }, acc);
    }
    else {
        invokeAwareInterfaces(bean);
    }

    return bean;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在bean初始化之前，首先对当前bean的类型进行判断，如果当前bean的类型不是EnvironmentAware，不是EmbeddedValueResolverAware，不是ResourceLoaderAware，不是ApplicationEventPublisherAware，不是MessageSourceAware，也不是ApplicationContextAware，则直接返回bean。如果是上面类型中的一种类型，则最终会调用invokeAwareInterfaces()方法，并将bean传递给invokeAwareInterfaces()方法。invokeAwareInterfaces()方法又是个什么鬼呢？我们继续看invokeAwareInterfaces()方法的源码，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private void invokeAwareInterfaces(Object bean) {
    if (bean instanceof EnvironmentAware) {
        ((EnvironmentAware) bean).setEnvironment(this.applicationContext.getEnvironment());
    }
    if (bean instanceof EmbeddedValueResolverAware) {
        ((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(this.embeddedValueResolver);
    }
    if (bean instanceof ResourceLoaderAware) {
        ((ResourceLoaderAware) bean).setResourceLoader(this.applicationContext);
    }
    if (bean instanceof ApplicationEventPublisherAware) {
        ((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(this.applicationContext);
    }
    if (bean instanceof MessageSourceAware) {
        ((MessageSourceAware) bean).setMessageSource(this.applicationContext);
    }
    if (bean instanceof ApplicationContextAware) {
        ((ApplicationContextAware) bean).setApplicationContext(this.applicationContext);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到invokeAwareInterfaces()方法的源码比较简单，就是判断当前bean属于哪种接口类型，则将bean强转为哪种接口类型的对象，然后调用接口的方法，将相应的参数传递到接口的方法中。这里，我们在创建Employee类时，实现的是ApplicationContextAware接口，所以，在invokeAwareInterfaces()方法中，会执行如下的逻辑代码。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;if (bean instanceof ApplicationContextAware) {
    ((ApplicationContextAware) bean).setApplicationContext(this.applicationContext);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以看到，此时会将this.applicationContext传递到ApplicationContextAware接口的setApplicationContext()方法中。所以，我们在Employee类中的setApplicationContext()方法中就可以直接接收到ApplicationContext对象了。&lt;/p&gt;
&lt;p&gt;我们也可以在IDEA中通过Debug的形式来看一下程序的执行过程，此时我们在Employee类的setApplicationContext()方法上设置断点，如下所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200630005336355.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来，我们以Debug的方式来运行SpringBeanTest类的testAnnotationConfig2()方法，运行后的效果如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200630005348483.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在IDEA的左下角可以看到方法的调用堆栈，通过对方法调用栈的分析，我们看到在执行Employee类中的setApplicationContext()方法之前，执行了ApplicationContextAwareProcessor类的invokeAwareInterfaces方法，如下所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200630005359965.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当我们点击方法调用栈中的invokeAwareInterfaces()方法时，代码的执行定位到如下一行代码。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;((ApplicationContextAware) bean).setApplicationContext(this.applicationContext);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;和我们之前分析的逻辑一致。&lt;/p&gt;
&lt;h2 id=&quot;beanvalidationpostprocessor类&quot;&gt;BeanValidationPostProcessor类&lt;/h2&gt;
&lt;p&gt;org.springframework.validation.beanvalidation.BeanValidationPostProcessor类主要是用来为bean进行校验操作，当我们创建bean，并为bean赋值后，我们可以通过BeanValidationPostProcessor类为bean进行校验操作。BeanValidationPostProcessor类的结构如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package org.springframework.validation.beanvalidation;

import java.util.Iterator;
import java.util.Set;

import javax.validation.ConstraintViolation;
import javax.validation.Validation;
import javax.validation.Validator;
import javax.validation.ValidatorFactory;

import org.springframework.aop.framework.AopProxyUtils;
import org.springframework.beans.BeansException;
import org.springframework.beans.factory.BeanInitializationException;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.beans.factory.config.BeanPostProcessor;
import org.springframework.lang.Nullable;
import org.springframework.util.Assert;

public class BeanValidationPostProcessor implements BeanPostProcessor, InitializingBean {
    /*******************************省略N行代码**********************************/
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里，我们也来看看postProcessBeforeInitialization()方法和postProcessAfterInitialization()方法的实现，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Override
public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
    if (!this.afterInitialization) {
        doValidate(bean);
    }
    return bean;
}

@Override
public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
    if (this.afterInitialization) {
        doValidate(bean);
    }
    return bean;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，在postProcessBeforeInitialization()方法和postProcessAfterInitialization()方法中的主要逻辑都是调用doValidate()方法对bean进行校验，只不过在两个方法中都会对afterInitialization这个boolean类型的成员变量进行判断，如果afterInitialization的值为false，则在postProcessBeforeInitialization()方法中调用doValidate()方法对bean进行校验；如果afterInitialization的值为true，则在postProcessAfterInitialization()方法中调用doValidate()方法对bean进行校验。&lt;/p&gt;
&lt;h2 id=&quot;initdestroyannotationbeanpostprocessor类&quot;&gt;InitDestroyAnnotationBeanPostProcessor类&lt;/h2&gt;
&lt;p&gt;org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor类主要用来处理@PostConstruct注解和@PreDestroy注解。&lt;/p&gt;
&lt;p&gt;例如，我们之前创建的Cat类中就使用了@PostConstruct注解和@PreDestroy注解，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package io.mykit.spring.plugins.register.bean;
import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
/**
 * @author binghe
 * @version 1.0.0
 * @description 测试@PostConstruct注解和@PreDestroy注解
 */
public class Cat {

    public Cat(){
        System.out.println(&quot;Cat类的构造方法...&quot;);
    }

    public void init(){
        System.out.println(&quot;Cat的init()方法...&quot;);
    }

    @PostConstruct
    public void postConstruct(){
        System.out.println(&quot;Cat的postConstruct()方法...&quot;);
    }

    @PreDestroy
    public void preDestroy(){
        System.out.println(&quot;Cat的preDestroy()方法...&quot;);
    }

    public void destroy(){
        System.out.println(&quot;Cat的destroy()方法...&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么，在Cat类中使用了 @PostConstruct注解和@PreDestroy注解来标注方法，Spring怎么就知道什么时候执行 @PostConstruct注解标注的方法，什么时候执行@PreDestroy标注的方法呢？这就要归功于InitDestroyAnnotationBeanPostProcessor类的实现了。&lt;/p&gt;
&lt;p&gt;接下来，我们也通过Debug的方式来跟进下代码的执行流程。首先，在Cat类的postConstruct()方法上打上断点，如下所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200630005416195.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来，我们以Debug的方式运行BeanLifeCircleTest类的testBeanLifeCircle04()方法，效果如下所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200630005427761.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们还是带着问题来分析，Spring怎么就能定位到使用@PostConstruct注解标注的方法呢？通过分析方法的调用栈我们发现了在进入使用@PostConstruct注解标注的方法之前，Spring调用了InitDestroyAnnotationBeanPostProcessor类的postProcessBeforeInitialization()方法，如下所示。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200630005438321.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;在InitDestroyAnnotationBeanPostProcessor类的postProcessBeforeInitialization()方法中，首先会找到bean中有关生命周期的注解，比如@PostConstruct注解等，找到这些注解之后，则将这些信息赋值给LifecycleMetadata类型的变量metadata，之后调用metadata的invokeInitMethods()方法，通过反射来调用标注了@PostConstruct注解的方法。这就是为什么标注了@PostConstruct注解的方法被Spring执行。&lt;/p&gt;
&lt;h2 id=&quot;autowiredannotationbeanpostprocessor类&quot;&gt;AutowiredAnnotationBeanPostProcessor类&lt;/h2&gt;
&lt;p&gt;org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor类主要是用于处理标注了@Autowired注解的变量或方法。&lt;/p&gt;
&lt;p&gt;Spring为何能够自动处理标注了@Autowired注解的变量或方法，就交给小伙伴们自行分析了。大家可以写一个测试方法并通过方法调用堆栈来分析AutowiredAnnotationBeanPostProcessor类的源码，从而找到自己想要的答案。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;好了，咱们今天就聊到这儿吧！别忘了给个在看和转发，让更多的人看到，一起学习一起进步！！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;2.3333333333333&quot;&gt;
&lt;p&gt;项目工程源码已经提交到GitHub：&lt;a href=&quot;https://github.com/sunshinelyz/spring-annotation&quot;&gt;https://github.com/sunshinelyz/spring-annotation&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;写在最后&quot;&gt;写在最后&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;如果觉得文章对你有点帮助，请微信搜索并关注「 冰河技术 」微信公众号，跟冰河学习Spring注解驱动开发。公众号回复“spring注解”关键字，领取Spring注解驱动开发核心知识图，让Spring注解驱动开发不再迷茫。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 29 Jun 2020 16:59:00 +0000</pubDate>
<dc:creator>冰河团队</dc:creator>
<og:description>写在前面 在《【String注解驱动开发】面试官再问你BeanPostProcessor的执行流程，就把这篇文章甩给他！》一文中，我们详细的介绍了BeanPostProcessor的执行流程。那么，B</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/binghe001/p/13211362.html</dc:identifier>
</item>
<item>
<title>02 . Shell变量和逻辑判断及循环使用 - you-men</title>
<link>http://www.cnblogs.com/you-men/p/13211363.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/you-men/p/13211363.html</guid>
<description>&lt;h4 id=&quot;shell变量&quot;&gt;Shell变量&lt;/h4&gt;
&lt;h5 id=&quot;系统变量&quot;&gt;系统变量&lt;/h5&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;在命令行提示符直接执行 env、set 查看系统或环境变量。env 显示用户环境变量，set 显示 Shell预先定义好的变量以及用户变量。可以通过 export 导出成用户变量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;一些写Shell脚本时常用的系统变量&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;$SHELL  默认 Shell
$HOME  当前用户家目录
$IFS  内部字段分隔符
$LANG  默认语言
$PATH  默认可执行程序路径
$PWD  当前目录
$UID  当前用户 ID
$USER  当前用户
$HISTSIZE  历史命令大小，可通过 HISTTIMEFORMAT 变量设置命令执行时间
$RANDOM  随机生成一个 0 至 32767 的整数
$HOSTNAME  主机名
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;普通变量与临时环境变量&quot;&gt;普通变量与临时环境变量&lt;/h5&gt;
&lt;blockquote readability=&quot;29&quot;&gt;
&lt;p&gt;普通变量定义：VAR=value&lt;/p&gt;
&lt;p&gt;临时环境变量定义：export VAR=value&lt;/p&gt;
&lt;p&gt;变量引用：$VAR&lt;/p&gt;
&lt;p&gt;下面看下他们之间区别：&lt;/p&gt;
&lt;p&gt;Shell 进程的环境变量作用域是 Shell 进程，当 export 导入到系统变量时，则作用域是 Shell 进程及其 Shell 子进程。&lt;/p&gt;
&lt;p&gt;Shell 进程的环境变量作用域是 Shell 进程，当 export 导入到系统变量时，则作用域是 Shell 进程及其 Shell 子进程。&lt;/p&gt;
&lt;p&gt;ps axjf 输出的第一列是 PPID（父进程 ID），第二列是 PID（子进程 ID）当SSH 连接 Shell 时，当前终端 PPID（-bash）是 sshd 守护程序的 PID（root@pts/0），因此在当前终端下的所有进程的 PPID 都是-bash 的 PID，比如执行命令、运行脚本。&lt;/p&gt;
&lt;p&gt;所以当在-bash 下设置的变量，只在-bash 进程下有效，而-bash 下的子进程 bash 是无效的，当export 后才有效。&lt;/p&gt;
&lt;p&gt;进一步说明：再重新连接 SSH，去除上面定义的变量测试下所以在当前 shell 定义的变量一定要 export，否则在写脚本时，会引用不到。&lt;/p&gt;
&lt;p&gt;还需要注意的是退出终端后，所有用户定义的变量都会清除。&lt;/p&gt;
&lt;p&gt;在/etc/profile 下定义的变量就是这个原理.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;位置变量&quot;&gt;位置变量&lt;/h5&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;位置变量指的是函数或脚本后跟的第 n 个参数。&lt;/p&gt;
&lt;p&gt;1−1−n，需要注意的是从第 10 个开始要用花括号调用，例如${10}&lt;/p&gt;
&lt;p&gt;shift 可对位置变量控制，例如：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;#!/bin/bash
echo &quot;1: $1&quot;
shift
echo &quot;2: $2&quot;
shift
echo &quot;3: $3&quot;

sh test.sh 1 2 3
1: 1
2: 3
3: 
# 每执行一次 shift 命令，位置变量个数就会减一，而变量值则提前一位。shift n，可设置向前移动n位。
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;特殊变量&quot;&gt;特殊变量&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;$0  # 脚本自身名字
$?  # 返回上一条命令是否执行成功，0 为执行成功，非 0 则为执行失败
$#  # 位置参数总数
$*  # 所有的位置参数被看做一个字符串
$@  # 每个位置参数被看做独立的字符串
$$  # 当前进程 PID
$!  # 上一条运行后台进程的 PID
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;变量引用&quot;&gt;变量引用&lt;/h5&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;赋值运算符&lt;/th&gt;
&lt;th&gt;示例&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;=&lt;/td&gt;
&lt;td&gt;变量赋值&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;+=&lt;/td&gt;
&lt;td&gt;两个变量相加&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h5 id=&quot;自定义变量与引用&quot;&gt;自定义变量与引用&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;a=123
echo $a
123

a+=456
echo $a
123456

# Shell 中所有变量引用使用$符，后跟变量名

# 有时个别特殊字符会影响正常使用,就需要使用${a},例如
[root@redis ~]# b=123
[root@redis ~]# echo $b
123
[root@redis ~]# echo ${b}
123
# 有时个别特殊字符会影响正常引用，那么需要使用${VAR}
[root@redis ~]# echo $b123

[root@redis ~]# echo ${b}123
123123


# 将命令结果作为变量值
[root@redis ~]# c=`echo 123`
[root@redis ~]# echo $c
123
[root@redis ~]# c=$(echo 123)
[root@redis ~]# echo $c
123

# 这里的反撇号等效于$()，都是用于执行 Shell 命令。

# 单引号和双引号
[root@redis ~]# d=1
[root@redis ~]# d=&quot;1 2 $d&quot;
[root@redis ~]# echo $d
1 2 1
[root@redis ~]# c=1
[root@redis ~]# c='1 2 $c'
[root@redis ~]# echo $c
1 2 $c
# 单引号是告诉 Shell 忽略特殊字符，而双引号则解释特殊符号原有的意义，比如$ 、 ！。
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;shell变量的输入&quot;&gt;Shell变量的输入&lt;/h5&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Shell变量除了可以直接赋值或脚本传参外，还可以使用read命令从标准输入获得，read为bash内置命令，可以通过help read查看帮助&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;语法格式&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# read [参数] [变量名]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;常用参数&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# -p prompt: 设置提示信息
# -t timeout: 设置输入等待的事件,单位默认为秒
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;read的基本读入&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;如果不加-t read就会一直等待&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# read后面的参数是一个变量
[root@youmen ~]# read -p 'please input you num:' num
please input you num:234
[root@youmen ~]# echo $num
234


# 设置超时事件为3秒
read -t 3 -p &quot;please input you num:&quot; num
please input you num:
# 过3秒钟会脚本会自己执行结束
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;read在脚本中常用例子&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;[root@youmen ~]# sh test.sh 
please input you num: 1 2
1-2 =-1
1+2 =3
1*2 =2
1/2 =0
1**2 =1
1%2 =1
[root@youmen ~]# cat abc.sh 
#!/bin/bash
read -t 18 -p &quot;please input you num:&quot; a b
echo &quot;$a-$b =$(( $a - $b ))&quot;
echo &quot;$a+$b =$(( $a + $b ))&quot;
echo &quot;$a*$b =$(( $a * $b ))&quot;
echo &quot;$a/$b =$(( $a / $b ))&quot;
echo &quot;$a**$b =$(( $a ** $b ))&quot;
echo &quot;$a%$b =$(( $a % $b ))&quot;

# 利用echo 命令替代和read -p的功能
[root@youmen ~]# cat test.sh 
#!/bin/bash
echo -n &quot;请输入两个数字:&quot;
read a b 
echo &quot;$a+$b =$(( $a + $b ))&quot;
echo &quot;$a*$b =$(( $a * $b ))&quot;
echo &quot;$a/$b =$(( $a / $b ))&quot;
echo &quot;$a**$b =$(( $a ** $b ))&quot;
echo &quot;$a%$b =$(( $a % $b ))&quot;

[root@youmen ~]# bash test.sh 
请输入两个数字:2 3
2+3 =5
2*3 =6
2/3 =0
2**3 =8
2%3 =2
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;条件测试与比较&quot;&gt;条件测试与比较&lt;/h4&gt;
&lt;h5 id=&quot;介绍&quot;&gt;介绍&lt;/h5&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在bash的各种流程控制结构中通常要进行各种测试，然后根据测试结果执行不同的操作，有时也会通过与if等条件语句相结合，更方便的完成判断&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;条件测试通常由如下3种语法形式&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 语法1：test&amp;lt;测试表达式&amp;gt;
# 语法2：[&amp;lt;测试表达式&amp;gt;]
# 语法3：[[&amp;lt;测试表达式&amp;gt;]]

# 说明
# 1.上述语法格式1和语法格式2的写法是相等的。语法格式3为扩展的test命令。推荐使用语法格式2.

# 2.在[[]]中可以使用通配符进行模式匹配。&amp;amp;&amp;amp;、||、&amp;gt;、&amp;lt;等操作可以应用于[[]]中，但不能应用于[]中.

# 3.对于整数的关系运算，也可以使用Shell的算术运算符(())
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;test测试表达式&quot;&gt;test测试表达式&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 判断是不是文件
[root@youmen ~]# test -f /etc/hosts
[root@youmen ~]# echo $?
0
[root@youmen ~]# test -f /etc/hostss
[root@youmen ~]# echo $?
1

# 判断文件是否可以执行
[root@youmen ~]# test -x /usr/bin/ssh
[root@youmen ~]# echo $?
0
[root@youmen ~]# test -x /etc/hosts
[root@youmen ~]# echo $?
1

# 判断是不是目录
[root@youmen ~]# test -d /etc/
[root@youmen ~]# echo $?
0
[root@youmen ~]# test -d /etc/hosts
[root@youmen ~]# echo $?
1
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;中括号表达式&quot;&gt;[]中括号表达式&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 判断是不是普通文件
[root@youmen ~]# [ -f /etc/hosts ]
[root@youmen ~]# echo $?
0
[root@youmen ~]# [ -f /etc/hostss ]
[root@youmen ~]# echo $?
1

# 判断是否是目录
[root@youmen ~]# [ -d /etc/hosts ]
[root@youmen ~]# echo $?
1
[root@youmen ~]# [ -d /etc/ ]
[root@youmen ~]# echo $?
0

# 判断是否可被执行
[root@youmen ~]# [ -x /etc/hosts ]
[root@youmen ~]# echo $?
1
[root@youmen ~]# [ -x /usr/bin/ssh ]
[root@youmen ~]# echo $?
0
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;双括号表达式&quot;&gt;[[双括号表达式]]&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;[root@youmen ~]# [[ -x /etc/hosts ]]
[root@youmen ~]# echo $?
1
[root@youmen ~]# [[ -x /usr/bin/ssh ]]
[root@youmen ~]# echo $?
0

# [[]] 和[]一样
# 区别是可以在多括号里面添加多个判断
# 例如判断是不是目录,并判断下一个文件是不是可执行
[root@youmen ~]# [[ -d /etc/ &amp;amp;&amp;amp; -x /usr/bin/ssh ]]
[root@youmen ~]# echo $?
0
[root@youmen ~]# [[ -d /etc/ &amp;amp;&amp;amp; -x /usr/bin/sshdd ]]
[root@youmen ~]# echo $?
1

# &amp;amp;&amp;amp;只在双括号里面有效,如果单括号里面需要使用-a,-o
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;文件测试表达式&quot;&gt;文件测试表达式&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;操作符 说明 举例

# -b file 检测文件是否是块设备文件，如果是，则返回 true。 [ -b $file ] 返回 false。

# -c file 检测文件是否是字符设备文件，如果是，则返回 true。 [ -c $file ] 返回 false。

# -d file 检测文件是否是目录，如果是，则返回 true。 [ -d $file ] 返回 false。

# -f file 检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。 [ -f $file ] 返回 true。 

# -g file 检测文件是否设置了 SGID 位，如果是，则返回 true。 [ -g $file ] 返回 false。 

# -k file 检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。 [ -k $file ] 返回 false。 

# -p file 检测文件是否是具名管道，如果是，则返回 true。 [ -p $file ] 返回 false。

# -u file 检测文件是否设置了 SUID 位，如果是，则返回 true。 [ -u $file ] 返回 false。

# -r file 检测文件是否可读，如果是，则返回 true。 [ -r $file ] 返回 true。

# -w file 检测文件是否可写，如果是，则返回 true。 [ -w $file ] 返回 true。

# -x file 检测文件是否可执行，如果是，则返回 true。 [ -x $file ] 返回 true。

# -s file 检测文件是否为空（文件大小是否大于0），不为空返回 true。 [ -s $file ] 返回 true。

# -e file 检测文件（包括目录）是否存在，如果是，则返回 true。 [ -e $file ] 返回 true。

# 特别说明：这些操作符号对于[[]]、[]、test几乎都是通用的，
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;字符串表达式&quot;&gt;字符串表达式&lt;/h4&gt;
&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;字符串测试操作符的作用有：比较两个字符串是否相同、字符串的长度是否为零，字符串是否为NULL（注：bash区分零长度字符串和空字符串）等&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;常用字符串测试操作符&lt;/strong&gt; &lt;strong&gt;说明&lt;/strong&gt; -z “字符串” 若串长度为0则真，-z可以理解为zero -n ”字符串“ 若昂度不为0则真，-n 可以理解为no zero ”串1“ = ”串2“&lt;/p&gt;
&lt;p&gt;若串1等于串2则真，可以使用”==“代替”=“&lt;/p&gt;
&lt;p&gt;“串2” ！= “串2”&lt;/p&gt;
&lt;p&gt;若串1不等于串2则真，不能用“！==“ 代替”！=“ 特别注意：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 1. 以上表格中的字符串测试操作符号务必要用”“引起来。
# 2.比较符号两端有空格
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;字符串测试操作符提示&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 1）-n 比较字符串长度是否不为零，如果不为零则为真，如：[ -n “$myvar” ]

# 2）-z 比较字符串长度是否等于零，如果等于零则为真，如：[ -z “$myvar” ]

# 特别注意
# 对于以上表格中的字符串测试操作符号，如[ -n “$myvar” ]，要把字符串用“”引起来。

# 1、字符串或字符串变量比较都要加双引号之后再比较。

# 2、字符串或字符串变量比较，比较符号两端最好都有空格，可以参考系统脚本

# “=”比较两个字符串是否相同，与“==”等价，如[ “$a” = “$b” ]其中$a这样的变量最好用“”括起来，因为如果中间由空格，*等符号就可能出错，更好的办法就是[ “${a}” = “${b}” ]

# “！=” 比较两个字符串是否相同，不同则为“是”
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;逻辑操作符&quot;&gt;逻辑操作符&lt;/h4&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在[]和test中使用 在[[]]中使用 说明 -a &amp;amp;&amp;amp; and与，两端都为真，则真 -o || or或，两端有一个为真则真 ！ ！ not非，相反则为真&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# ！中文意思是反：与一个逻辑值相关的逻辑值

# -a 中文意思是（and|&amp;amp;&amp;amp;）：两个逻辑值都为“真”，返回值才为“真”，反之为“假”

# -o 中文意思是或（or| ||）：两个逻辑值只要有一个为“真”，返回值就为“真”

# 逻辑操作运算规则
# -a和&amp;amp;&amp;amp; 的运算规则：只有两端都是1才为真
# 要想使用&amp;amp;&amp;amp;注意双括号
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;shell流程控制&quot;&gt;Shell流程控制&lt;/h4&gt;
&lt;h5 id=&quot;if&quot;&gt;If&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;if 语句语法格式&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;if condition
then
    command1 
    command2
    ...
    commandN 
fi

# 写成一行
if [ $(ps -ef | grep -c &quot;ssh&quot;) -gt 1 ]; then echo &quot;true&quot;; fi
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;if-else&quot;&gt;If else&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;if else语法格式&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;if condition
then
    command1 
    command2
    ...
    commandN
else
    command
fi
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;if-else-if-else&quot;&gt;if else-if else&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;if else-if else语法格式&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if condition1
then
    command1
elif condition2 
then 
    command2
else
    commandN
fi
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;实例&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;a=10
b=20
if [ $a == $b ]
then
   echo &quot;a 等于 b&quot;
elif [ $a -gt $b ]
then
   echo &quot;a 大于 b&quot;
elif [ $a -lt $b ]
then
   echo &quot;a 小于 b&quot;
else
   echo &quot;没有符合的条件&quot;
fi

# a 小于 b
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;if else语句经常与test命令结合使用,如下所示&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;num1=$[2*3]
num2=$[1+5]
if test $[num1] -eq $[num2]
then
    echo '两个数字相等!'
else
    echo '两个数字不相等!'
fi

# 输出结果
# 两个数字相等!
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;循环&quot;&gt;循环&lt;/h4&gt;
&lt;h5 id=&quot;for&quot;&gt;for&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;语法格式&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;for var in item1 item2 ... itemN
do
    command1
    command2
    ...
    commandN
done

# 写成一行
for var in item1 item2 ... itemN; do command1; command2… done;

# 当变量值在列表里，for循环即执行一次所有命令，使用变量名获取列表中的当前取值。
# 命令可为任何有效的shell命令和语句。in列表可以包含替换、字符串和文件名。
# in列表是可选的，如果不用它，for循环使用命令行的位置参数。
# 顺序输出当前列表中的数字

for loop in 1 2 3 4 5
do
    echo &quot;The value is: $loop&quot;
done

# 输出
The value is: 1
The value is: 2
The value is: 3
The value is: 4
The value is: 5
  
# 顺序输出字符串中的字符
for str in 'This is a string'
do
    echo $str
done
# 输出结果
This is a string
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;while&quot;&gt;While&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;while循环用于不断执行一系列命令，也用于从输入文件中读取数据；命令通常为测试条件。其格式为：&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;while condition
do
    command
done
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;一下是一个基本的while循环,测试条件是,如果int小于等于5，那么条件返回真。int从0开始，每次循环处理时，int加1。运行上述脚本，返回数字1到5，然后终止。&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;#!/bin/bash
int=1
while(( $int&amp;lt;=5 ))
do
    echo $int
    let &quot;int++&quot;
done

# 输出
1
2
3
4
5

# 以上实例使用了 Bash let 命令，它用于执行一个或多个表达式，变量计算中不需要加上 $ 来表示变量
# while循环可用于读取键盘信息。下面的例子中，输入信息被设置为变量FILM，按&amp;lt;Ctrl-D&amp;gt;结束循环

echo '按下 &amp;lt;CTRL-D&amp;gt; 退出'
echo -n '输入你最喜欢的网站名: '
while read FILM
do
    echo &quot;是的！$FILM 是一个好网站&quot;
done

# 运行脚本,输出类似下面
按下 &amp;lt;CTRL-D&amp;gt; 退出
输入你最喜欢的网站名: youmeblog
是的！youmenblog 是一个好博客
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;无限循环&quot;&gt;无限循环&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;无限循环语法格式&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;while :
do
    command
done

# or
while true
do
    command
done

# or 
for (( ; ;))
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;until循环&quot;&gt;until循环&lt;/h5&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;until 循环执行一系列命令直至条件为 true 时停止。&lt;/p&gt;
&lt;p&gt;until 循环与 while 循环在处理方式上刚好相反。&lt;/p&gt;
&lt;p&gt;一般 while 循环优于 until 循环，但在某些时候—也只是极少数情况下，until 循环更加有用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;until 语法格式&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;until condition
do
    command
done
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;condition 一般为条件表达式，如果返回值为 false，则继续执行循环体内的语句，否则跳出循环。&lt;/p&gt;
&lt;p&gt;以下实例我们使用 until 命令来输出 0 ~ 9 的数字：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;#!/bin/bash

a=0

until [ ! $a -lt 10 ]
do
   echo $a
   a=`expr $a + 1`
done

# 运行结果
0
1
2
3
4
5
6
7
8
9
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;case&quot;&gt;case&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;Shell case语句为多选择语句。可以用case语句匹配一个值与一个模式，如果匹配成功，执行相匹配的命令。case语句格式如下：&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;case 值 in
模式1)
    command1
    command2
    ...
    commandN
    ;;
模式2）
    command1
    command2
    ...
    commandN
    ;;
esac
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;case工作方式如上所示。取值后面必须为单词in，每一模式必须以右括号结束。取值可以为变量或常数。匹配发现取值符合某一模式后，其间所有命令开始执行直至 ;;。&lt;/p&gt;
&lt;p&gt;取值将检测匹配的每一个模式。一旦模式匹配，则执行完匹配模式相应命令后不再继续其他模式。如果无一匹配模式，使用星号 * 捕获该值，再执行后面的命令。&lt;/p&gt;
&lt;p&gt;下面的脚本提示输入1到4，与每一种模式进行匹配：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;echo '输入 1 到 4 之间的数字:'
echo '你输入的数字为:'
read aNum
case $aNum in
    1)  echo '你选择了 1'
    ;;
    2)  echo '你选择了 2'
    ;;
    3)  echo '你选择了 3'
    ;;
    4)  echo '你选择了 4'
    ;;
    *)  echo '你没有输入 1 到 4 之间的数字'
    ;;
esac

# 输入不同的内容，会有不同的结果，例如：
输入 1 到 4 之间的数字:
你输入的数字为:
3
你选择了 3
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;break&quot;&gt;break&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;break命令允许跳出所有循环（终止执行后面的所有循环）&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;下面的例子中，脚本进入死循环直至用户输入数字大于5。要跳出这个循环，返回到shell提示符下，需要使用break命令&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;#!/bin/bash
while :
do
    echo -n &quot;输入 1 到 5 之间的数字:&quot;
    read aNum
    case $aNum in
        1|2|3|4|5) echo &quot;你输入的数字为 $aNum!&quot;
        ;;
        *) echo &quot;你输入的数字不是 1 到 5 之间的! 游戏结束&quot;
            break
        ;;
    esac
done

# 执行以上代码,输出结果为
输入 1 到 5 之间的数字:3
你输入的数字为 3!
输入 1 到 5 之间的数字:7
你输入的数字不是 1 到 5 之间的! 游戏结束
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;continue&quot;&gt;continue&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;continue命令与break命令类似，只有一点差别，它不会跳出所有循环，仅仅跳出当前循环。对上面的例子进行修改：&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;#!/bin/bash
while :
do
    echo -n &quot;输入 1 到 5 之间的数字: &quot;
    read aNum
    case $aNum in
        1|2|3|4|5) echo &quot;你输入的数字为 $aNum!&quot;
        ;;
        *) echo &quot;你输入的数字不是 1 到 5 之间的!&quot;
            continue
            echo &quot;游戏结束&quot;
        ;;
    esac
done
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;caseesac&quot;&gt;Case..esac&lt;/h5&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;strong&gt;case ... esac&lt;/strong&gt; 与其他语言中的 switch ... case 语句类似，是一种多分枝选择结构，每个 case 分支用右圆括号开始，用两个分号 &lt;strong&gt;;;&lt;/strong&gt; 表示 break，即执行结束，跳出整个 case ... esac 语句，esac（就是 case 反过来）作为结束标记。&lt;/p&gt;
&lt;p&gt;case ... esac 语法格式如下&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;case 值 in
模式1)
    command1
    command2
    command3
    ;;
模式2）
    command1
    command2
    command3
    ;;
*)
    command1
    command2
    command3
    ;;
esac

# case后为取值,值可以为变量或常数
# 值后为关键字 in，接下来是匹配的各种模式，每一模式最后必须以右括号结束，模式支持正则表达式。

#!/bin/sh

site=&quot;runoob&quot;

case &quot;$site&quot; in
   &quot;runoob&quot;) echo &quot;youmen博客&quot;
   ;;
   &quot;google&quot;) echo &quot;Google 搜索&quot;
   ;;
   &quot;taobao&quot;) echo &quot;淘宝网&quot;
   ;;
esac
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 29 Jun 2020 16:59:00 +0000</pubDate>
<dc:creator>you-men</dc:creator>
<og:description>Shell变量 系统变量 在命令行提示符直接执行 env、set 查看系统或环境变量。env 显示用户环境变量，set 显示 Shell预先定义好的变量以及用户变量。可以通过 export 导出成用户</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/you-men/p/13211363.html</dc:identifier>
</item>
<item>
<title>基于 Fetch 的请求封装 - whosmeya</title>
<link>http://www.cnblogs.com/whosmeya/p/13211221.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/whosmeya/p/13211221.html</guid>
<description>&lt;p&gt;原生 fetch 请求失败后（如无网络）状态会变成 reject 走 .catch 。绝大多数情况下业务场景只需要给个 toast 等简单处理。每个请求都 .catch 会显得格外繁琐，并且如果不 .catch, .then 里面的后续处理不会触发，可能会导致逻辑中断。&lt;/p&gt;
&lt;p&gt;基于上述情况，可以封装公共请求方法处理异常情况，返回固定格式 { code, data, massage }, 只需在 .then 里面获取数据并处理。&lt;/p&gt;
&lt;h2 id=&quot;目标&quot;&gt;目标&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;保留 fetch 语法不变&lt;/li&gt;
&lt;li&gt;返回 promise，且状态一定变成 resolve，返回固定数据格式 { code, data, message }&lt;/li&gt;
&lt;li&gt;给 url 动态添加域名&lt;/li&gt;
&lt;li&gt;默认失败弹出 toast，且提供开关&lt;/li&gt;
&lt;li&gt;默认请求中 loading，且提供开关&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;实现&quot;&gt;实现&lt;/h2&gt;
&lt;p&gt;实现如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-ts&quot;&gt;/**
 * 返回 Promise({ code, data, message});
 */

import { message } from 'antd';
import { dispatch } from '../index';
import { startLoading, endLoading } from '../store/globalSlice';

// 在 config/env.js 中设置
export const origin = process.env.ORIGIN;

interface MyInit extends RequestInit {
  noToastError?: boolean; // 默认false
  noLoading?: boolean; // 默认false
}

// 请求返回统一格式
export class Response {
  code: number;
  data: any;
  message: string | null;
  constructor(code: number, data: any, message: string | null) {
    this.code = code;
    this.data = data;
    this.message = message;
  }
}

export default (input: RequestInfo, myInit?: MyInit) =&amp;gt; {
  const init: MyInit = myInit || {};

  // url 动态添加 origin
  if (typeof input === 'string') {
    if (!/https?:\/\//.test(input)) {
      input = origin + input;
    }
  }

  // 开始 loading
  if (!init?.noLoading) {
    dispatch(startLoading());
  }

  // 请求
  return fetch(input, {
    headers: {
      'Content-Type': 'application/json',
    },
    ...init,
  })
    .then((resp) =&amp;gt; {
      // code 不为 2xx
      if (!/^2\d{2}$/.test(String(resp.status))) {
        return new Response(resp.status, null, null);
      }

      return resp
        .json()
        .then((json) =&amp;gt; {
          // toast错误信息
          if (json.code !== 0) {
            message.error(json.message);
          }

          // 退出登陆
          if (json.code === 20001) {
            // logout();
            // window.location.pathname = '/login';
          }

          // 请求成功的数据
          return json;
        })
        .catch((err) =&amp;gt; {
          // 不是 json 格式
          return new Response(999998, null, 'data is not json.');
        });
    })
    .catch((err) =&amp;gt; {
      // 请求发送失败
      message.error('您的网络可能不通，请确认后重试');
      return new Response(999999, null, err);
    })
    .finally(() =&amp;gt; {
      // 结束 loading
      if (!init?.noLoading) {
        dispatch(endLoading());
      }
    });
};

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;目前只完成了对 json 数据的处理。&lt;/p&gt;
&lt;p&gt;其中 loading 部分用了 redux 和 @reduxjs/toolkit，用一个变量记录当前请求个数，控制实际 loading 开始和结束，实现如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-ts&quot;&gt;let count = 0;
export const startLoading = () =&amp;gt; (dispatch: any) =&amp;gt; {
  if (count === 0) {
    dispatch(setLoding(true));
  }
  count++;
};
export const endLoading = () =&amp;gt; (dispatch: any) =&amp;gt; {
  count--;
  if (count === 0) {
    dispatch(setLoding(false));
  }
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;使用&quot;&gt;使用&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;import myfetch from './myfetch.ts';

myfetch('/xxx/xxx')
  .then(res =&amp;gt; console.log(res))

myfetch('https://www.xxx.com/xxx/xxx')
  .then(res =&amp;gt; console.log(res))

myfetch('/xxx/xxx', {
  methods: 'POST',
  body: JSON.stringify({}),
})
  .then(res =&amp;gt; console.log(res))

myfetch('/xxx/xxx', {
  methods: 'POST',
  body: JSON.stringify({}),
  noToastError: true,
  noLoading: true,
})
  .then(res =&amp;gt; console.log(res))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://www.whosmeya.com/&quot;&gt;whosmeya.com&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 29 Jun 2020 15:59:00 +0000</pubDate>
<dc:creator>whosmeya</dc:creator>
<og:description>原生 fetch 请求失败后（如无网络）状态会变成 reject 走 .catch 。绝大多数情况下业务场景只需要给个 toast 等简单处理。每个请求都 .catch 会显得格外繁琐，并且如果不 .</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/whosmeya/p/13211221.html</dc:identifier>
</item>
<item>
<title>序列推荐(transformer) - 混沌战神阿瑞斯</title>
<link>http://www.cnblogs.com/arachis/p/sdm.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/arachis/p/sdm.html</guid>
<description>&lt;h2 id=&quot;attention演进rnnlstmgruseq2seq--attention机制&quot;&gt;Attention演进(RNN&amp;amp;LSTM&amp;amp;GRU&amp;amp;Seq2Seq + Attention机制)&lt;/h2&gt;
&lt;h3 id=&quot;lstm&quot;&gt;LSTM&lt;/h3&gt;
&lt;p&gt;LSTM是RNN的一种变体，RNN由于梯度消失只有短期记忆，而LSTM网络通过精妙的门控制，一定程度上缓解了梯度消失的问题。&lt;br/&gt;LSTM得神经网络模块具有不同的结构，LSTM包含遗忘门、输入门和输出门，增加了非线性的相互作用。整体结构如图所示：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/776149/202006/776149-20200629233544126-935872320.png&quot; alt=&quot;LSTM&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;details readability=&quot;17&quot;&gt;点击查看公式
&lt;p&gt;遗忘门:&lt;span class=&quot;math inline&quot;&gt;\( f_{t}=\sigma\left(W_{f} \cdot\left[h_{t-1}, x_{t}\right]+b_{f}\right) \)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;输入门:&lt;span class=&quot;math inline&quot;&gt;\( \begin{array}{l} i_{t}=\sigma\left(W_{i} \cdot\left[h_{t-1}, x_{t}\right]+b_{i}\right) \end{array} \)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;cell state更新:&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\tilde{C_t}=\tanh \left(W_{C} \cdot\left[h_{t-1}, x_{t}\right]+b_{C}\right)\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(C_{t}=f_{t} * C_{t-1}+i_{t} * \tilde{C}_{t}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;输出门:&lt;span class=&quot;math inline&quot;&gt;\( \begin{array}{l} o_{t}=\sigma\left(W_{o}\left[h_{t-1}, x_{t}\right]+b_{o}\right) \end{array} \)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;当前层输出:&lt;span class=&quot;math inline&quot;&gt;\( \begin{array}{l} h_{t}=o_{t} * \tanh \left(C_{t}\right) \end{array} \)&lt;/span&gt;&lt;/p&gt;
&lt;/details&gt;&lt;h3 id=&quot;gru&quot;&gt;GRU&lt;/h3&gt;
&lt;p&gt;GRU是LSTM的一种变体，也是为了解决梯度消失（即长期记忆问题）而提出来的。相较于LSTM，GRU的网络结构更加简单，且效果很好。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/776149/202006/776149-20200629233632816-1658911870.png&quot; alt=&quot;GRU&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;seq2seq--attention机制&quot;&gt;Seq2Seq + Attention机制&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;提出问题&lt;/strong&gt;：在做机器翻译时，专家学者们发现，在Seq2Seq结构中，Encoder把所有的输入序列都编码成一个统一的语义向量context，然后再由Decoder解码。其中，context自然也就成了限制模型性能的瓶颈，当要翻译的句子较长时，一个 context 可能存不下那么多信息。同时，只使用编码器的最后一个隐藏层状态，似乎不是很合理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方案&lt;/strong&gt;：因此，引入了Attention机制（&lt;strong&gt;将有限的认知资源集中到最重要的地方&lt;/strong&gt;）。在生成 Target 序列的每个词时，用到的中间语义向量 context 是 Source 序列通过Encoder的隐藏层的加权和，而不是只用Encoder最后一个时刻的输出作为context，这样就能保证在解码不同词的时候，Source 序列对现在解码词的贡献是不一样的。例如，Decoder 在解码”machine”时，”机”和”器”提供的权重要更大一些，同样，在解码”learning”时，”学”和”习”提供的权重相应的会更大一些。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现步骤&lt;/strong&gt;：（1）衡量编码中第 j 阶段的隐含层状态和解码时第 i 阶段的相关性（有很多种打分方式，这里不细讲）；（2）通过相关性的打分为编码中的不同阶段分配不同的权重；（3）解码中第 i 阶段输入的语义向量context就来自于编码中不同阶段的隐含层状态的加权和。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/776149/202006/776149-20200629233722145-813605866.png&quot; alt=&quot;Attention&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;简单总结下：attention比rnn之类参数更少，速度更快(类似cnn可以并行化)，效果更好【1】；因为其过滤掉大部分无用信息，所以可以处理更长的序列；下面看下attention是如何建模完成信息过滤的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;attention机制self-attention&quot;&gt;Attention机制(self-attention)&lt;/h2&gt;
&lt;p&gt;Attention其实就是计算一种相关程度；Attention通常可以进行如下描述，表示为将query(Q)和key-value pairs映射到输出上，其中query、每个key、每个value都是向量，输出是V中所有values的加权，其中权重是由Query和每个key计算出来的，计算方法分为三步：&lt;br/&gt;1)计算比较Q和K的相似度，用f来表示：&lt;/p&gt;
&lt;p&gt;\[f\left(Q, K_{i}\right) , i=1,2,3 \]&lt;/p&gt;
&lt;p&gt;2)将得到的相似度进行softmax归一化：&lt;/p&gt;
&lt;p&gt;\[\alpha_{i}=\frac{e^{f\left(Q, K_{i}\right)}}{\sum_{j=1}^{m} e^{f\left(Q, K_{i}\right)}}, i=1,2,3, . . \]&lt;/p&gt;
&lt;p&gt;3)针对计算出来的权重，对所有的values进行加权求和，得到Attention向量：&lt;/p&gt;
&lt;p&gt;\[\sum_{i=1}^m a_i V_i \]&lt;/p&gt;
&lt;h3 id=&quot;变种之memory-based-attention&quot;&gt;变种之Memory-based Attention&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/776149/202006/776149-20200629233804343-590534414.jpg&quot; alt=&quot;mba&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Q&amp;amp;A 任务中，k 是 question，v 是 answer，q 是新来的 question，看看历史 memory 中 q 和哪个 k 更相似，然后依葫芦画瓢，根据相似 k 对应的 v，合成当前 question 的 answer。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic2.zhimg.com/80/v2-0fd8593685e1e8c661553d65bd599c75_1440w.jpg&quot; alt=&quot;Key-Value Memory network&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;模型的输入是一个稠密特征q，输出是一个特征向量v,向量v的计算是通过对每个embedding vector进行加权求和得到的;【2】&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;变种之softhard-attention&quot;&gt;变种之Soft/Hard Attention&lt;/h3&gt;
&lt;p&gt;hard attention 是一个随机采样，采样集合是输入向量的集合，采样的概率分布即attention weight。因此，hard attention 的输出是某一个特定的输入向量。&lt;br/&gt;soft attention 是一个带权求和的过程，求和集合是输入向量的集合，对应权重是 相似度function 产出的 attention weight。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;soft attention 是更常用的,下面讨论相似度function 【3】&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/776149/202006/776149-20200629234034799-506322758.png&quot; alt=&quot;score_func&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;变种之self-attention&quot;&gt;变种之self-attention&lt;/h3&gt;
&lt;p&gt;定义：Self Attention，指的不是Target和Source之间的Attention机制，而是Source内部元素之间或者Target内部元素之间发生的Attention机制，也可以理解为Target=Source这种特殊情况下的Attention。&lt;/p&gt;
&lt;h4 id=&quot;scaled-dot-product-attention&quot;&gt;Scaled Dot-Product Attention&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/776149/202006/776149-20200629234115035-237536769.png&quot; alt=&quot;sdpa&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Dot-Product计算相似度&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;outputs = tf.matmul(Q,tf.transpose(K,[0,2,1]))
outputs = outputs / (K.get_shape().as_list()[-1] ** 0.5)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Encoder mask(主要是padding value平滑下)&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;key_masks = tf.sign(tf.abs(tf.reduce_sum(keys,axis=-1)))
key_masks = tf.tile(tf.expand_dims(key_masks,1),[1,tf.shape(queries)[1],1])
paddings = tf.ones_like(outputs) * (-2 ** 32 + 1)
outputs = tf.where(tf.equal(key_masks,0),paddings,outputs)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Decoder mask(padding value平滑+只能利用之前的输入约束)&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;diag_vals = tf.ones_like(outputs[0,:,:])
tril = tf.contrib.linalg.LinearOperatorTriL(diag_vals).to_dense()
masks = tf.tile(tf.expand_dims(tril,0),[tf.shape(outputs)[0],1,1])
paddings = tf.ones_like(masks) * (-2 ** 32 + 1)
outputs = tf.where(tf.equal(masks,0),paddings,outputs)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;计算结果outputs&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# scaled 
outputs = tf.nn.softmax(outputs)
# Query Mask
query_masks = tf.sign(tf.abs(tf.reduce_sum(queries,axis=-1)))
query_masks = tf.tile(tf.expand_dims(query_masks,-1),[1,1,tf.shape(keys)[1]])
outputs *= query_masks
# Dropout
outputs = tf.layers.dropout(outputs,rate = dropout_rate,training = tf.convert_to_tensor(is_training))
# Weighted sum
outputs = tf.matmul(outputs,V)
# Residual connection
outputs += queries
# Normalize
outputs = normalize(outputs)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;multi-head-attention&quot;&gt;Multi-Head Attention&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/776149/202006/776149-20200629234335671-1763284728.png&quot; alt=&quot;mha&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;Multi-Head Attention就是把Scaled Dot-Product Attention的过程做H次，然后把输出concat合起来。&lt;/p&gt;
&lt;h2 id=&quot;序列建模有哪些经典论文？&quot;&gt;序列建模有哪些经典论文？&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://arxiv.org/abs/1808.06414?context=cs&quot;&gt;Next Item Recommendation with Self-Attention&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://arxiv.org/pdf/1905.06874.pdf&quot;&gt;Behavior Sequence Transformer for E-commerce Recommendation in Alibaba&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://arxiv.org/abs/1511.06939&quot;&gt;Session-based recommendations with recurrent neural networks&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://arxiv.org/abs/1711.04725&quot;&gt;Neural Attentive Session-based Recommendation&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://arxiv.org/abs/1707.02410&quot;&gt;Translation-based Recommendation&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://arxiv.org/abs/1904.06690&quot;&gt;BERT4Rec: Sequential Recommendation with Bidirectional Encoder Representations from Transformer&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://www.ijcai.org/proceedings/2018/0546.pdf&quot;&gt;SHAN:Sequential Recommender System based on Hierarchical Attention Networks&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/arachis/p/sdm.html&quot;&gt;BINN:Learning from history and present: next-item recommendation via discrimina-tively exploiting user behaviors&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;sdm论文笔记&quot;&gt;SDM论文笔记&lt;/h2&gt;
&lt;h3 id=&quot;回顾与引入abstract12两小节&quot;&gt;回顾与引入(ABSTRACT+1,2两小节)&lt;/h3&gt;
&lt;p&gt;SDM：&lt;a href=&quot;https://arxiv.org/abs/1909.00385&quot;&gt;SDM: Sequential Deep Matching Model for Online Large-scale Recommender System&lt;/a&gt;&lt;br/&gt;在淘宝的场景中，用户的行为主要分为两种，第一个是当前的浏览session，用户在一个session中，需求往往是十分明确的，比如你想买球鞋，往往只会关注球鞋类的商品。另一个是之前的记录，一个用户虽然可能不是每次都来买球鞋，但是也可能提供一定的有用信息，比如用户只买阿迪的鞋子或者只买帆布鞋等等。因此分别建模这两种行为序列来刻画用户的兴趣，是十分有用的。&lt;/p&gt;
&lt;p&gt;提出问题：1)CF类方法并未建模用户的兴趣的动态性和兴趣随时间的演化过程(DSIN)；2)一个session内也可能存在多种兴趣倾向(feed的多个维度);3)长期偏好和短期偏好没很好融合&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;我对动态性/静态性的理解:1）icf是取topk相似的item,然后i2i推荐,相当于仅利用了分布的头部部分；2)传统的embedding建模假设用户的兴趣是长久稳定的和集中的，不随时间和context变化；所以相对的就是动态多兴趣的假设&lt;br/&gt;我对多兴趣倾向的理解:文章中主要是提出电商场景下用户会综合商品的多个角度，也就是多兴趣观点;个人在双列feed的关注点基本1)萌宠/美女类型2)订阅科技/影视作者；还有可能关注封面；同时全局类策略一般不看&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;解决方案：提出multi-head attention和Gate自适应长短期融合&lt;/p&gt;
&lt;p&gt;multi-head attention主要有两点原因：&lt;br/&gt;1）用户的行为中存在一些误点击行为，通过self-attention来降低这种影响；&lt;br/&gt;2）用户可能对不同物品的关注点不同。&lt;/p&gt;
&lt;p&gt;Gate自适应长短期融合的原因：&lt;br/&gt;之前简单将item concat或者weighted sum的工作，因为用户找了很久才找到和NBA明星相关的球鞋,其他item反而是噪音；本工作对应的模块是类似lstm的长短期向量门融合模块可以避免这种噪音干扰；&lt;/p&gt;
&lt;h3 id=&quot;建模模型架构结构第3节&quot;&gt;建模&amp;amp;模型架构/结构(第3节)&lt;/h3&gt;
&lt;p&gt;长期序列：相隔一周以内的行为认为是用户的长期行为(不包含短期序列)&lt;br/&gt;短期序列：&lt;br/&gt;1）日志中标记了同样的session ID&lt;br/&gt;2）虽然session ID不相同，但是相邻的行为间隔小于10min&lt;br/&gt;3）最长的session长度为50，超过50的划分到前一个session&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;这里论文没给出规则2,3的原因，推测还是阿里这边数据分析的经验；&lt;br/&gt;sdk埋点中session_id定义：应用进入前台生成session_id,退至后台10秒以上重新进入前台重新生成session_id&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/776149/202006/776149-20200629234539576-1016837893.png&quot; alt=&quot;sdm&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在长期行为中挖掘用户对商品属性的偏好（如类目、品牌、店铺等），在短期行为中结合Multi-Head Self-Attention过滤掉session内部的casual click，并利用Multi-Head挖掘用户在session内的多方面兴趣，最后构造Gate自适应的融合长短期兴趣得到用户兴趣的充分表达。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/776149/202006/776149-20200629234616302-1439491624.png&quot; alt=&quot;train&amp;amp;serving&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;循环层：&lt;br/&gt;使用LSTM捕获和刻画短期行为数据中的全局时序依赖&lt;/p&gt;
&lt;p&gt;Multi-Head Attention：&lt;/p&gt;
&lt;p&gt;User Attention层&lt;br/&gt;对于不同的用户，即使是相似的商品集合，用户在偏好方面也可能有所不同。因此使用User Attention层去捕获更细粒度的用户偏好。使用用户的embedding(eu)作为attention的query。&lt;/p&gt;
&lt;p&gt;\[\alpha_{k}=\frac{\exp \left(\hat{h}\_{k}^{u T} e_{u}\right)}{\sum_{k=1}^{t} \exp \left(\hat{h}\_{k}^{u T} e_{u}\right)} \]&lt;/p&gt;
&lt;p&gt;\[s_{t}^{u}=\sum_{k=1}^{t} \alpha_{k} \hat{h}\_{k}^{u} \]&lt;/p&gt;
&lt;p&gt;短期行为和长期行为融合:&lt;/p&gt;
&lt;p&gt;\[G_{t}^{u}=\operatorname{sigmoid}\left(W^{1} e_{u}+W^{2} s_{t}^{u}+W^{3} p^{u}+b\right) \]&lt;/p&gt;
&lt;p&gt;\[o_t^u=\left(1-G_t^u\right) \odot p^u+G_t^u \odot s_t^u \]&lt;/p&gt;
&lt;h3 id=&quot;线上线下实验设计实验分析第456小节&quot;&gt;(线上线下)实验设计&amp;amp;实验分析(第4,5,6小节)&lt;/h3&gt;
&lt;p&gt;数据集：&lt;br/&gt;1)淘宝数据集：8天内行为物品大于40的活跃用户，但过滤行为超过1000 items的异常用户+过滤出现5次以下的item+过滤长度小于2的session(训练阶段)；前7天做训练第8天测试；长期行为限制为20；&lt;br/&gt;2)京东数据机：3周训练1周测试；其余与淘宝数据机相同；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/776149/202006/776149-20200629234702897-1872522069.png&quot; alt=&quot;t1&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;论文中虽然给了代码和数据集链接，但具体的数据处理，模型输入和离线验证都是基于阿里的ODPS和PAI，所以基本不可复现；只能看DeepMatch中关于movielens数据集复现&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;实现细节：&lt;br/&gt;1)multi-head attention中头个数的实验&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/776149/202006/776149-20200629234731223-680181248.png&quot; alt=&quot;t2&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/776149/202006/776149-20200629234752919-768776657.png&quot; alt=&quot;p2&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2)融合门的实验&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/776149/202006/776149-20200629234817145-1304842648.png&quot; alt=&quot;t4&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/776149/202006/776149-20200629234846185-340925778.png&quot; alt=&quot;p5&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码：&lt;br/&gt;&lt;a href=&quot;https://github.com/alicogintel/SDM&quot;&gt;https://github.com/alicogintel/SDM&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://github.com/shenweichen/DeepMatch&quot;&gt;https://github.com/shenweichen/DeepMatch&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;【1】&lt;a href=&quot;https://zhuanlan.zhihu.com/p/91839581&quot;&gt;一文看懂 Attention（本质原理+3大优点+5大类型）&lt;/a&gt;&lt;br/&gt;【2】&lt;a href=&quot;https://www.zhihu.com/question/363478566/answer/954127887&quot;&gt;稠密特征加入CTR预估模型有哪些方法？&lt;/a&gt;&lt;br/&gt;【3】&lt;a href=&quot;https://www.jianshu.com/p/b1030350aadb&quot;&gt;一步步解析Attention is All You Need！&lt;/a&gt;&lt;br/&gt;【4】&lt;a href=&quot;https://www.jianshu.com/p/2b0a5541a17c&quot;&gt;使用Excel通俗易懂理解Transformer！&lt;/a&gt;&lt;br/&gt;【5】&lt;a href=&quot;https://www.jianshu.com/p/9eb209343c56&quot;&gt;推荐系统遇上深度学习(三十一)--使用自注意力机制进行物品推荐&lt;/a&gt;&lt;br/&gt;【6】&lt;a href=&quot;https://www.jianshu.com/p/9a4b3791fda2&quot;&gt;推荐系统遇上深度学习(四十)-SESSION-BASED RECOMMENDATIONS WITH RECURRENT NEURAL NETWORKS&lt;/a&gt;.&lt;br/&gt;【7】&lt;a href=&quot;https://www.jianshu.com/p/caa2d87cb78c&quot;&gt;推荐系统遇上深度学习(四十八)-BST:将Transformer用于淘宝电商推荐&lt;/a&gt;&lt;br/&gt;【8】&lt;a href=&quot;https://www.jianshu.com/p/1fe9c66dac4a&quot;&gt;推荐系统遇上深度学习(五十二)-基于注意力机制的用户行为建模框架ATRank&lt;/a&gt;&lt;br/&gt;【9】&lt;a href=&quot;https://www.jianshu.com/p/f716110f7b80&quot;&gt;推荐系统遇上深度学习(五十八)-基于“翻译”的序列推荐方法&lt;/a&gt;&lt;br/&gt;【10】&lt;a href=&quot;https://www.jianshu.com/p/ed3aa36d9813&quot;&gt;推荐系统遇上深度学习(六十一)-[阿里]使用Bert来进行序列推荐&lt;/a&gt;&lt;br/&gt;【11】&lt;a href=&quot;https://www.jianshu.com/p/95acafac035c&quot;&gt;推荐系统遇上深度学习(六十三)-[阿里]大型推荐系统中的深度序列匹配模型SDM&lt;/a&gt;&lt;br/&gt;【12】&lt;a href=&quot;https://www.jianshu.com/p/bc8c85dc5a54&quot;&gt;推荐系统遇上深度学习(六十四)-通过自注意力机制来自动学习特征组合&lt;/a&gt;&lt;br/&gt;【13】&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5MzY4NzE3MA==&amp;amp;mid=2247484488&amp;amp;idx=1&amp;amp;sn=d94e223790c91fd73129d364dac822d7&amp;amp;source=41#wechat_redirect&quot;&gt;SDM(Sequential Deep Matching Model)的复现之路&lt;/a&gt;&lt;br/&gt;【14】&lt;a href=&quot;https://www.chenmo.com.cn/372514&quot;&gt;深度学习中的序列模型演变及学习笔记（含RNN/LSTM/GRU/Seq2Seq/Attention机制）,智能推荐算法演变及学习笔记,数据挖掘比赛/项目全流程介绍&lt;/a&gt;!&lt;/p&gt;
</description>
<pubDate>Mon, 29 Jun 2020 15:55:00 +0000</pubDate>
<dc:creator>混沌战神阿瑞斯</dc:creator>
<og:description>Attention演进(RNN&amp;amp;LSTM&amp;amp;GRU&amp;amp;Seq2Seq + Attention机制) LSTM LSTM是RNN的一种变体，RNN由于梯度消失只有短期记忆，而LSTM</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/arachis/p/sdm.html</dc:identifier>
</item>
</channel>
</rss>