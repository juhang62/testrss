<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>JVM自动内存管理机制——Java内存区域（上） - 风沙迷了眼</title>
<link>http://www.cnblogs.com/fsmly/p/10356492.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fsmly/p/10356492.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、JVM运行时数据区域概述&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　Java相比较于C/C++的一个特点就是，在虚拟机自动内存管理机制的帮助下，我们不需要为每一个操作都写像C/C++一样的delete/free代码，所以也不容易出现内存泄漏和内存溢出的问题。显然，这里的不容易只是相对而言的，如果我们想要降低这种代码隐患的发生，就需要对Java虚拟机怎样使用内存有了解，这样的话就算产生错误，排查起来也会相对容易。下面我们来说一说JVM运行时数据区域&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201902/1368768-20190208123758382-331193994.png&quot; alt=&quot;&quot; width=&quot;587&quot; height=&quot;262&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;1、程序计数器（PC寄存器）:&lt;/strong&gt; 被看作是当前线程所执行的字节码的行号指示器，字节码解析的时候就通过改变这个计数器的值来选取下一条需要执行的指令（包括分支、循环、跳转、异常处理等等都依赖PC）。在多线程程序中，每条线程都需要拥有一个独立的程序计数器，所以程序计数器是线程私有的。（如果程序正在执行一个Java方法，那么这个计数器记录的就是当前执行的字节码指令的地址；如果执行的是一个Native方法，那么计数器为Undefined），该内存区域是JVM规范中唯一一个没有规定OutOfMemoryError的区域。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;2、Java虚拟机栈：&lt;/strong&gt;虚拟机栈描述的是Java方法执行的内存模型，这块区域也是线程私有的，生命周期和线程相同。每个方法在执行的时候会创建栈帧，用来存放局部变量表、操作数栈、动态链接、返回值等信息。（我们常说的在Java中的栈内存就是指这块区域）。在JVM规范中：如果线程请求栈深度大于虚拟机提供的深度，那么抛出StackOutflowError异常；如果无法申请得到足够的内存，会抛出OutofMemoryError异常&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;3、本地方法栈：&lt;/strong&gt;与Java虚拟机栈不同的是，本地方法栈为虚拟机执行Native方法服务，而Java虚拟机栈为虚拟机执行Java方法服务。由于JVM规范并没有对本地方法栈做强制规定，所以如同HotSpot一样，直接将本地方法栈和虚拟机栈合二为一。异常情况和JAVA虚拟机栈相同&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;4、Java堆：&lt;/strong&gt;Java堆是被所有线程所共享的一块内存区域，在虚拟机启动时候创建，这块区域的目的就是存放对象实力，基本上我们所创建的所有的对象实例都要在这里分配内存。我们下面会详细的介绍Java堆&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;5、方法区：&lt;/strong&gt;方法区和Java堆一样，是各个线程共享的内存区域，&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;6、运行时常量池：&lt;/strong&gt;运行时常量池是方法区的一部分，在Class文件中（存在类的版本、字段、方法、接口等）存在常量池的信息，作用就是用于存放编译期间生成的各种字面量和符号引用。受到方法区内存的限制，当无法申请到内存时候会抛出OutOfMemoryError异常&lt;/p&gt;
&lt;p&gt;　　还有一部分就是直接内存，但是直接内存并不是运行时数据区域的一部分，在Java的NIO库中允许Java程序员频繁的使用直接内存，从而提高性能（避免了Java堆和Native堆之间来回复制数据）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、再探Java堆、栈、方法区&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　1、Java堆：Java堆的存在是为了解决数据存储的问题，堆中存放了对象实例。堆也是垃圾收集器管理的主要区域（所以也可以被称为GC堆）。从内存回收的角度来讲，采用分代回收算法的JVM，在堆中可被分为新生代（新生的对象或者年龄不大的对象）和老年代（老年对象），这里面的划分是按照垃圾收集器的次数，来判断对象的年龄。新生代中又被分为Eden区、s0区（from区域）、s1区（to区域），From和To是两块大小相等，可以互换角色的区域。一般来说，新生的对象会被首先分配在Eden区，然经过一次GC之后（如果对象还存活）会到from或者to区。之后类似的每一次回收，都会加1，当对象达到一定年龄后，会进入老年代。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201902/1368768-20190208144457452-499090490.png&quot; alt=&quot;&quot; width=&quot;494&quot; height=&quot;146&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2、栈：Java栈是一个线程私有的空间，一般情况下一个栈由3部分组成：局部变量表、操作数栈、帧数据区。&lt;/p&gt;
&lt;p&gt;　　局部变量表：里面存放的是报错函数的参数以及局部变量；&lt;/p&gt;
&lt;p&gt;　　操作数栈：其中保存计算过程中的中间结果，同时作为计算过程中变量的临时存储空间；&lt;/p&gt;
&lt;p&gt;　　帧数据区：除了局部变量表和操作数栈之外，还需要一些数据来支持常量池的解析，帧数据区中保存着访问常量池的指针，方便程序访问常量池。除此之外，当函数返回或者出现异常时，JVM必须有一个异常处理表，方便发送异常的时候找到异常的代码（从而异常处理也是帧数据区的一部分）&lt;/p&gt;
&lt;p&gt;　　3、方法区：方法区是一块所有线程共享的内存区域，他保存了类的信息（类的字段、方法、常量池等等），方法区大小决定了系统可以保存多少个类。&lt;/p&gt;
&lt;p&gt;　　4、一张简略的图描述一下堆、栈、方法区之间的关系&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201902/1368768-20190208132516505-1427233686.png&quot; alt=&quot;&quot; width=&quot;557&quot; height=&quot;244&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、探秘JVM堆中对象分配&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;1、对象的创建&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　a）我们从new开始，当虚拟机遇到一条new指令的时候，会首先检查这个指令的参数能否在常量池中找到这个类的符号引用，并且检查这个类的加载是否被加载、解析、初始化过，如果没有就会按照类加载过程进行相应类的加载。&lt;/p&gt;
&lt;p&gt;　　b）在类加载完毕后，然后JVM对新生对象分配内存，对象的分配简单而言就是在将一块确定大小的内存从Java堆中分配出来。&lt;/p&gt;
&lt;p&gt;　　①堆是完整的（这时候所有使用的内存在一边，没有使用的内存在一边，中间放着一个指针作为分界点的指示器）：分配内存就只是把指针向空闲内存那边移动与对象大小一样大的距离（这种方式成为“指针碰撞”）&lt;/p&gt;
&lt;p&gt;　　②堆不是完整的（使用和未用的相互交错）：虚拟机需要维护一个列表，其中记录的是空间内存的状况，在分配的时候从空闲内存中找到一块足够的空间划分给对象实例，然后更新表中的记录信息（这种方式成为“空闲列表”）&lt;/p&gt;
&lt;p&gt;　　c）考虑多线程情况下的对象内存分配&lt;/p&gt;
&lt;p&gt;　　在并发的情况下是线程不安全的，可能出现正在给对象A进行分配，这时候指针位置还没有来得及改变，然后这时候对象B的内存分配又使用了原来的指针记性分配。在《深入理解Java虚拟机》中讲到两种解决方案&lt;/p&gt;
&lt;p&gt;　　①对对象的分配进行同步处理，采用CAS配置失败重试的方式保证更新操作的原子性&lt;/p&gt;
&lt;p&gt;　　②将内存分配的动作按照线程划分在不同的空间中进行。即保证每个线程预先在Java堆中分配一小块空间（本地线程分配缓冲TLAB）。线程需要分配的时候，就先在TLAB上面分配，然后当TLAB使用完毕再进行同步锁定。&lt;/p&gt;
&lt;p&gt;　　d）内存分配完成之后，虚拟机需要将分配的内存初始化为零值，这一步保证了对象实例字段在Java代码中可以不被赋初值就使用，使得程序能够访问到这些字段的数据类型对应的零值。&lt;/p&gt;
&lt;p&gt;　　e）然后虚拟机需要对对象进行必要的设置，比如对象是那个类的实例，类的元数据、对象哈希码、GC年龄等等存放在对象头中。　　&lt;/p&gt;
&lt;p&gt;　　f） 上面执行完毕之后，从虚拟机角度而言已经产生了心得对象。但是程序中对象创建还没有执行&amp;lt;init&amp;gt;方法，所有字段均为零值。所以，执行完new指令，还需要执行&amp;lt;init&amp;gt;方法，按照程序的角度进行初始化，才能使用这个对象。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;2&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;、对象的访问定位&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　我们在介绍堆栈的时候就介绍过堆栈和方法区之间的关系，Java程序中对象的引用存放在栈（reference）中，引用的实例存放在Java堆中（使用栈上面的对象引用来操作堆上面的具体对象），但是我们并没有定义怎样通过引用去定位、访问堆中的具体对象位置，下面介绍句柄和直接指针的方式&lt;/p&gt;
&lt;p&gt;　　a）句柄方式&lt;/p&gt;
&lt;p&gt;　　首先在Java堆中分配一块区域作为句柄池，栈中的reference中存放的就是对象的句柄地址信息（句柄中包含的是对象实例数据和类型数据各自的具体地址信息）。使用句柄方式的好处就是reference中存储的是稳定的句柄地址信息，而reference本身不需要修改。下面是句柄方式的简略图&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201902/1368768-20190208174022582-346906097.png&quot; alt=&quot;&quot; width=&quot;511&quot; height=&quot;286&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　b）直接指针方式：&lt;/p&gt;
&lt;p&gt;　　Java堆中对象的布局中必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象的地址。使用直接指针的方式就是存取速度快，节省了一次指针定位的时间。&lt;/p&gt;
&lt;p&gt;　　 &lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201902/1368768-20190208183023055-1345752181.png&quot; alt=&quot;&quot; width=&quot;499&quot; height=&quot;265&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 08 Feb 2019 15:32:00 +0000</pubDate>
<dc:creator>风沙迷了眼</dc:creator>
<og:description>一、JVM运行时数据区域概述 Java相比较于C/C++的一个特点就是，在虚拟机自动内存管理机制的帮助下，我们不需要为每一个操作都写像C/C++一样的delete/free代码，所以也不容易出现内存泄</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fsmly/p/10356492.html</dc:identifier>
</item>
<item>
<title>Python入门习题2.蟒蛇绘制（turtle库） - runningCsnail</title>
<link>http://www.cnblogs.com/runningCsnail/p/10356969.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/runningCsnail/p/10356969.html</guid>
<description>&lt;p&gt;例2.调用turtle库中的若干函数来绘制蟒蛇，要求：（1）主体窗口宽650像素，高度350像素，窗口左侧与屏幕左侧像素距离200，窗口顶部与屏幕顶部像素距离200；（2）画笔落点在原点反向前进250像素处，画笔尺寸25，颜色紫色；（3）画笔初始行进方向逆时针40°，先后分别绘制40为半径，80°的顺时针和逆时针圆弧，循环四次。（4）绘制40半径，40°顺时针圆弧，再前进40像素，绘制16半径180°顺时针圆弧，前行40*2/3像素。&lt;/p&gt;
&lt;p&gt;解：效果如图：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1378367/201902/1378367-20190208222143828-742908538.png&quot; alt=&quot;&quot; width=&quot;448&quot; height=&quot;279&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; turtle &lt;span&gt;import&lt;/span&gt; *   #引入turtle库
&lt;span&gt; 2&lt;/span&gt; setup(650,350,200,200&lt;span&gt;) #设置窗口位置
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;penup()                #“抬起笔”
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; fd(-250&lt;span&gt;)               #执笔前进 forward 反之backward 或 bk
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;pendown()              #落笔 
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; pensize(25&lt;span&gt;)            #设置画笔尺寸
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; pencolor(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;purple&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)     #设置画笔颜色
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; seth(-40&lt;span&gt;)              #设置初始行进角度 setheading
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(4&lt;span&gt;):     #遍历循环
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     circle(40,80&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     circle(-40,80&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; circle(40,40&lt;span&gt;)          #绘制圆弧
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; fd(40&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; circle(16,180&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; fd(40*2/3)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;turtle快速参考：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1378367/201902/1378367-20190208231155882-73217264.png&quot; alt=&quot;&quot; width=&quot;580&quot; height=&quot;820&quot;/&gt;&lt;/p&gt;
&lt;p&gt;博客参考《Python程序设计基础》高等教育出版社（第2版） 嵩天，礼欣，黄天羽著   第二章2.3，2.4部分&lt;/p&gt;
&lt;p&gt;推荐与上述教材配套的北京理工大学 嵩天，礼欣，黄天羽老师的MOOC&lt;/p&gt;

</description>
<pubDate>Fri, 08 Feb 2019 15:27:00 +0000</pubDate>
<dc:creator>runningCsnail</dc:creator>
<og:description>例2.调用turtle库中的若干函数来绘制蟒蛇，要求：（1）主体窗口宽650像素，高度350像素，窗口左侧与屏幕左侧像素距离200，窗口顶部与屏幕顶部像素距离200；（2）画笔落点在原点反向前进250</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/runningCsnail/p/10356969.html</dc:identifier>
</item>
<item>
<title>TensorFlow中的通信机制——Rendezvous（一）本地传输 - DeepLearningStack</title>
<link>http://www.cnblogs.com/deep-learning-stacks/p/10354258.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/deep-learning-stacks/p/10354258.html</guid>
<description>&lt;p&gt;[作者：&lt;a href=&quot;https://www.cnblogs.com/deep-learning-stacks&quot; target=&quot;_blank&quot;&gt;DeepLearningStack&lt;/a&gt;，阿里巴巴算法工程师，开源TensorFlow Contributor]&lt;/p&gt;
&lt;p&gt;在TensorFlow源码中我们经常能看到一个奇怪的词——Rendezvous。如果从仔细统计该单词出现的频率和模块，你会发现无论在单机还是分布式，无论在core目录还是contrib目录都存在它的身影，所涉及的模块非常多。Rendezvous是一个法语单词，发音也比较特殊，一般直译为“约会、相会、会和”，而在TensorFlow中，Rendezvous是用来完成消息传输的通信组件。大部分源码读者在起初阅读时通信部分的代码时可能会觉得有点懵圈，为什么不使用Communicator这样简单明了的单词来表明通信过程，反而使用这样一个晦涩的法语词作为抽象呢？其实在了解TensorFlow消息通信的原理后就会发现，使用Rendezvous作为这一过程的抽象是非常贴切的。&lt;/p&gt;
&lt;p&gt;因为Rendezvous所涉及的模块组件较多，为了让读者循序渐进地理解TensorFlow中的通信机制，决定将Rendezvous分成多个系列，由浅入深分开梳理。这样做的目的不但能让读者阅读时对整体层次结构有较好的把握，而且简短的篇幅也便于阅读，所以建议读者按顺序阅读本系列。 本文是TensorFlow通信机制系列的第一篇文章，侧重整体结构和本地传输通信的梳理。&lt;/p&gt;

&lt;p&gt;在TensorFlow中无论是单机还是分布式都涉及到消息传输，并且消息传输总是从发送端Send，接收端Recv。那么这里就存在一个消息的对应问题：在多组消息同时发送接收时，需要对每一对Send和Recv梳理一个对应关系，即Send端发送的消息与Recv端接收的消息不能有错位。如果Recv端本打算接收的消息是A，但由于消息对应错误导致接收到了B，那么整个训练过程就会出现错误。其实解决这个问题也非常简单，因为每一对Send和Recv所处理消息都是同一个，所以只要让某个消息在被Send前加上一个唯一标识符，而Recv在接收消息前也能够按照某种规则拼出一样的唯一标识符，这个对应关系就完美解决了。在TensorFlow中确实定义了这样一种标识符，它就是结构体ParsedKey。&lt;/p&gt;
&lt;h2&gt;ParsedKey结构体&lt;/h2&gt;
&lt;p&gt;在tensorflow/core/framework/rendezvous.h的Rendezvous类内定义了结构体ParsedKey，它内容非常简短却又十分全面，不但包含了消息传输的所有必须的内容，还具备唯一性，在我们直接分析其源代码结构。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Parses the key constructed by CreateKey and parse src/dst device
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; names into structures respectively.&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; ParsedKey {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;  StringPiece src_device;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;  DeviceNameUtils::ParsedName src;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;   uint64 src_incarnation = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;  StringPiece dst_device;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;  DeviceNameUtils::ParsedName dst;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;  StringPiece edge_name;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;  ParsedKey() {}
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;   ParsedKey(&lt;span&gt;const&lt;/span&gt; ParsedKey&amp;amp; b) { *&lt;span&gt;this&lt;/span&gt; =&lt;span&gt; b; }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;   ParsedKey&amp;amp; &lt;span&gt;operator&lt;/span&gt;=(&lt;span&gt;const&lt;/span&gt; ParsedKey&amp;amp;&lt;span&gt; b);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;   StringPiece FullKey() &lt;span&gt;const&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; buf_; }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;  &lt;span&gt;private&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;   friend &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Rendezvous;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;   friend &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SendOp;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;   friend &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RecvOp;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;   &lt;span&gt;string&lt;/span&gt;&lt;span&gt; buf_;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; };
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到其结构非常简单，一个完备的ParsedKey要包括六个部分。&lt;/p&gt;
&lt;p&gt;src_device：消息发送源的字符串信息，形如/job:localhost/replica:0/task_id:0/device:GPU:0&lt;/p&gt;
&lt;p&gt;src：和src_device的信息量相同，只不过是结构体的表示方法&lt;/p&gt;
&lt;p&gt;src_incarnation：一般来说这个字段没有什么作用，但是当某个worker重启后，该值会发生变化，用来和之前挂掉的worker做区分，这便于debug&lt;/p&gt;
&lt;p&gt;dst_device：消息发送的接收方字符串信息，格式和src_device相同&lt;/p&gt;
&lt;p&gt;dst：和dst_device的信息量相同，只不过是结构体的表示方法&lt;/p&gt;
&lt;p&gt;edge_name：这个字段是该Key最特殊的地方，它可以灵活指定为任何字符串，实现不同Key的区分。比如它可以是Tensor的名字，也可以是具有某种特殊意义的固定字符串&lt;/p&gt;
&lt;h2&gt;CreateKey过程与ParseKey过程&lt;/h2&gt;
&lt;p&gt;一般情况下，在TensorFlow中应该优先使用CreateKey函数来构造可以解析的Key字符串，然后经过ParseKey过程将该字符串的每个信息解析到ParsedKey结构体中，之所以使用CreateKey函数构造Key字符串是因为这是最安全保险的方式，下面是CreateKey函数构造Key字符串的过程展现。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1437153/201902/1437153-20190208202040797-1150435323.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;CreateKey只要接受五个参数即可安全构造字符串形式的Key，这里面特殊之处有两个，a. 参数中frame_and_iter一般直接取自OpKernelContext中的FrameAndIter对象；b. src_incarnation要做一个十六进制的字符串转换。CreateKey函数的输出是以分号（&quot;;&quot;）为分隔符的字符串，该字符串同样包含五个域。CreateKey是一个static函数，代码比较简单，就不在这里列出。随后我们这个字符串传入ParseKey函数即可完成结构体ParsedKey的解析，解析过程如下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1437153/201902/1437153-20190208203302181-1488622898.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ParseKey对输入字符串的前四个域做了映射，抛弃了第五个域，但是在提供Key字符串时需要提供完整的五个域，否则会检查报错。和CreateKey相同，ParseKey过程也是一个static函数，代码如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; static &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; Status Rendezvous::ParseKey(StringPiece key, ParsedKey* &lt;span&gt;out&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (key.data() == &lt;span&gt;out&lt;/span&gt;-&amp;gt;&lt;span&gt;buf_.data()) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Caller used our buf_ string directly, so we don't need to copy.  (The
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; SendOp and RecvOp implementations do this, for example).&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     DCHECK_EQ(key.size(), &lt;span&gt;out&lt;/span&gt;-&amp;gt;&lt;span&gt;buf_.size());
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;   } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Make a copy that our StringPieces can point at a copy that will persist
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; for the lifetime of the ParsedKey object.&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;out&lt;/span&gt;-&amp;gt;&lt;span&gt;buf_.assign(key.data(), key.size());
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;   StringPiece s(&lt;span&gt;out&lt;/span&gt;-&amp;gt;&lt;span&gt;buf_);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;   StringPiece parts[&lt;span&gt;5&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;   &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;5&lt;/span&gt;; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     parts[i] = ConsumeNextPart(&amp;amp;s, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (s.empty() &amp;amp;&amp;amp;          &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Consumed the whole string&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;       !parts[&lt;span&gt;4&lt;/span&gt;].empty() &amp;amp;&amp;amp;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Exactly five parts&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;       DeviceNameUtils::ParseFullName(parts[&lt;span&gt;0&lt;/span&gt;], &amp;amp;&lt;span&gt;out&lt;/span&gt;-&amp;gt;src) &amp;amp;&amp;amp;
&lt;span&gt;20&lt;/span&gt;       strings::HexStringToUint64(parts[&lt;span&gt;1&lt;/span&gt;], &amp;amp;&lt;span&gt;out&lt;/span&gt;-&amp;gt;src_incarnation) &amp;amp;&amp;amp;
&lt;span&gt;21&lt;/span&gt;       DeviceNameUtils::ParseFullName(parts[&lt;span&gt;2&lt;/span&gt;], &amp;amp;&lt;span&gt;out&lt;/span&gt;-&amp;gt;dst) &amp;amp;&amp;amp;
&lt;span&gt;22&lt;/span&gt;       !parts[&lt;span&gt;3&lt;/span&gt;&lt;span&gt;].empty()) {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;out&lt;/span&gt;-&amp;gt;src_device = StringPiece(parts[&lt;span&gt;0&lt;/span&gt;].data(), parts[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;].size());
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;out&lt;/span&gt;-&amp;gt;dst_device = StringPiece(parts[&lt;span&gt;2&lt;/span&gt;].data(), parts[&lt;span&gt;2&lt;/span&gt;&lt;span&gt;].size());
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;out&lt;/span&gt;-&amp;gt;edge_name = StringPiece(parts[&lt;span&gt;3&lt;/span&gt;].data(), parts[&lt;span&gt;3&lt;/span&gt;&lt;span&gt;].size());
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Status::OK();
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;   &lt;span&gt;return&lt;/span&gt; errors::InvalidArgument(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Invalid  rendezvous key: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, key);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在了解ParsedKey之后，我们就可以窥探Rendezvous这个类的内部结构和实现了。最基本的Rendezvous类被定义在了tensorflow/core/framework/rendezvous.h文件中，它对外提供了最基本的Send、Recv和RecvAsync接口和实现。总体来说这个类还是比较抽象的，在不同的通信场景下需要提供不同的实现。比如对于本地传输来说，TensorFlow提供了LocalRendezvous和IntraProcessRendezvous实现类，对于使用跨进程通信场景来说，TensorFlow提供了RemouteRendezvous实现系列。不同通信场景的实现细节差别相当大，所以本系列将对这些做逐个梳理，本文只关注本地传输部分。如果对跨进程传输感兴趣，那么请关注该系列的下一篇文章。Rendezvous类中最重要的函数是Send和Recv系列，它们的签名和注释如下代码所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; The caller is a tensor producer and it sends a message (a tensor
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; &quot;val&quot; and a bool &quot;is_dead&quot;) under the given &quot;key&quot;.
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; {val, is_dead} is bundled as a message sent and received.
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Typically, is_dead is set by some control flow nodes
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; (e.g., a not-taken branch).  args is passed by Send to the
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Recv function to communicate any information that the Recv
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; function might need.  This is typically only necessary for
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Send/Recv on the same worker.
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Send() never blocks.&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; Status Send(&lt;span&gt;const&lt;/span&gt; ParsedKey&amp;amp; key, &lt;span&gt;const&lt;/span&gt; Args&amp;amp; args, &lt;span&gt;const&lt;/span&gt; Tensor&amp;amp; val, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; is_dead) = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; RecvAsync(&lt;span&gt;const&lt;/span&gt; ParsedKey&amp;amp; key, &lt;span&gt;const&lt;/span&gt; Args&amp;amp; args, DoneCallback done) = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Synchronous wrapper for RecvAsync.&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; Status Recv(&lt;span&gt;const&lt;/span&gt; ParsedKey&amp;amp; key, &lt;span&gt;const&lt;/span&gt; Args&amp;amp; args, Tensor* val, &lt;span&gt;bool&lt;/span&gt;*&lt;span&gt; is_dead, int64 timeout_ms);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; Status Recv(&lt;span&gt;const&lt;/span&gt; ParsedKey&amp;amp; key, &lt;span&gt;const&lt;/span&gt; Args&amp;amp; args, Tensor* val, &lt;span&gt;bool&lt;/span&gt;* is_dead);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;TensorFlow中的Recv有两种，一种是同步版本，换一种是异步版本。通常情况下为了计算和通信的overlap，TensorFlow广泛使用了RecvAsync函数。并且在后面一节中我们可以知道，Send过程并不是真的参与数据通信，所有的通信过程均由RecvAsync完成。&lt;/p&gt;
&lt;h2&gt;Rendezvous相关类结构&lt;/h2&gt;
&lt;p&gt;在了解通信过程之前，应该先熟悉下Rendezvous相关的类结构。下面的类图展示了当期TensorFlow系统中所有的Rendezvous相关类图结构。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1437153/201902/1437153-20190208205157291-2111425534.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所有的Rendezvous相关类都以Rendezvous基类为核心，LocalRendezvous和IntraProcessRendezvous是我们本文分析的重点，SimpleRendezvous实现非常简单，读者可以在熟悉前两个实现之后自行分析该类。而BaseRemoteRendezvous类以及相关类是跨进程通信相关的组件，这部分内容将在下一篇文章中分析。&lt;/p&gt;
&lt;h2&gt;Rendezvous基类中的Recv函数&lt;/h2&gt;
&lt;p&gt;因为Recv函数只是RecvAsync函数的同步版本封装，因此在每个实现类继承重新函数时，只需要提供Send函数的实现和RecvAsync函数实现即可，下面的代码是Rendezvous基类中同步版本实现。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; Status Rendezvous::Recv(&lt;span&gt;const&lt;/span&gt; ParsedKey&amp;amp; key, &lt;span&gt;const&lt;/span&gt; Args&amp;amp;&lt;span&gt; recv_args,
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;                         Tensor* val, &lt;span&gt;bool&lt;/span&gt;*&lt;span&gt; is_dead, int64 timeout_ms) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;  Status ret;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;  Notification n;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;  RecvAsync(key, recv_args,
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             [&amp;amp;ret, &amp;amp;n, val, is_dead](&lt;span&gt;const&lt;/span&gt; Status&amp;amp; s, &lt;span&gt;const&lt;/span&gt; Args&amp;amp;&lt;span&gt; send_args,
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                                      &lt;span&gt;const&lt;/span&gt; Args&amp;amp; recv_args, &lt;span&gt;const&lt;/span&gt; Tensor&amp;amp;&lt;span&gt; v,
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                                      &lt;span&gt;const&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; dead) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;               ret =&lt;span&gt; s;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;               *val =&lt;span&gt; v;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;               *is_dead =&lt;span&gt; dead;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;              n.Notify();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (timeout_ms &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     int64 timeout_us = timeout_ms * &lt;span&gt;1000&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;bool&lt;/span&gt; notified = WaitForNotificationWithTimeout(&amp;amp;&lt;span&gt;n, timeout_us);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;notified) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;       &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Status(error::DEADLINE_EXCEEDED,
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Timed out waiting for notification&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;   } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    n.WaitForNotification();
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;   &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看出，无论RecvAsync的实现内容是什么，Recv函数都可以将RecvAsync视为黑盒，在其上层封装成为与RecvAsync相同实现的同步函数版本。&lt;/p&gt;
&lt;h2&gt;本地传输过程&lt;/h2&gt;
&lt;p&gt;使用本地传输过程包括LocalRendezous和IntraProcessRendezvous两个实现类，但是后者是前者的封装，因此本文分析的重点在于LocalRendezvous实现类。&lt;/p&gt;
&lt;h3&gt;消息队列的缓存——Table&lt;/h3&gt;
&lt;p&gt;在TensorFlow中，几乎每个Rendezvous实现类都有自己的消息队列缓存，而几乎每种消息队列缓存都是依靠Table实现的。&lt;strong&gt;Rendezvous的发送(Send)和接收(Recv)都将通过Table完成，这完美地阐释了“约会、相会、会和”的释义，这也是为什么TensorFlow使用这样一个法语词来抽象通信过程&lt;/strong&gt;。下图形象化的表示了Table以及Table中的每个Item。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1437153/201902/1437153-20190208212513856-400473741.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在LocalRendezvous实现类中，Send端和Recv端使用的是同一个Rendezvous对象，所以他们共享同一个Table，所以Table属于临界资源，应该加锁形成互斥访问。Item这个结构中其实有很多内容，在上图中只解释两个比较重要的部分。&lt;/p&gt;
&lt;p&gt;Value：这就是参与通信Tensor本体&lt;/p&gt;
&lt;p&gt;Waitor：这是在确认Tensor被接收端完成接收后的处理函数，也就是consumer处理该Tensor的函数过程&lt;/p&gt;
&lt;h3&gt;传输过程分析&lt;/h3&gt;
&lt;p&gt;无论是Send过程还是Recv过程，它们都将借助Table完成Tensor的转发。Send过程作为Tensor的生产者，它负责将待发送的Tensor送入Table中，并将ParsedKey作为该Item的键。而Recv过程作为消费者，它也会根据自己所需拼出相同的ParsedKey，然后从Table中查看是否已经存在该项。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1437153/201902/1437153-20190208214124589-375714695.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;应该注意的是，&lt;span&gt;Tensor虽然由Send端生产，但是Table中的Item却不一定是由Send端插入&lt;/span&gt;。因为在TensorFlow中，Send和RecvAsync二者的相对顺序是不能保证先后的，经常出现需求比供给在时间片上先到的情况，那么这时就会出现RecvAsync先拼出了ParsedKey然后立即查表的情况。应对这种情况的一种方案是，RecvAsync放弃此次查询，开启另一个线程轮询该表直到Send端产生为止，然后执行consumer的waiter函数，但这是一个非常消耗资源的实现方式。TensorFlow为了保证异步性，使用另一种无需CPU轮询消耗资源的实现方式。&lt;/p&gt;
&lt;p&gt;我们知道，在Send和RecvAsync顺序相对异步的情况下，waitor函数的执行时机只有两种情况，它取决于Send的供给和RecvAsync的需求哪一个先到达。若生产者先到达，那么waiter函数的调用由RecvAsync执行。若消费者的需求先到达，那么waiter函数的调用由Send执行。简而言之，&lt;span&gt;总是迟到的一方执行waiter函数&lt;/span&gt;。那么可以这样设计：和Send端相同，允许RecvAsync将所需的Item插入到Table中，并连同waiter函数一起发送到该表里。如果Send端后到达，那么Send函数将从表中取出该Item，并执行waiter函数，反之，则由RecvAsync函数取出自己所需要的Item，然后执行waiter函数，下面的图展示了这个过程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1437153/201902/1437153-20190208220553449-627548990.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;Send过程源码&lt;/h3&gt;
&lt;p&gt;了解上述的过程后，我们可以直接看Send函数的源码了。下面是LocalRendezvous的Send函数源码展示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; Status Send(&lt;span&gt;const&lt;/span&gt; ParsedKey&amp;amp; key, &lt;span&gt;const&lt;/span&gt; Args&amp;amp; send_args, &lt;span&gt;const&lt;/span&gt; Tensor&amp;amp;&lt;span&gt; val,
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;               &lt;span&gt;const&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; is_dead) &lt;span&gt;override&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     uint64 key_hash =&lt;span&gt; KeyHash(key.FullKey());
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     VLOG(&lt;span&gt;2&lt;/span&gt;) &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Send &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;this&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; key_hash &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; key.FullKey();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     mu_.&lt;span&gt;lock&lt;/span&gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;status_.ok()) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Rendezvous has been aborted.&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;       Status s =&lt;span&gt; status_;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;      mu_.unlock();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;       &lt;span&gt;return&lt;/span&gt;&lt;span&gt; s;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;     ItemQueue* queue = &amp;amp;&lt;span&gt;table_[key_hash];
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (queue-&amp;gt;empty() || queue-&amp;gt;front()-&amp;gt;&lt;span&gt;IsSendValue()) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; There is no waiter for this message. Append the message
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; into the queue. The waiter will pick it up when arrives.
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Only send-related fields need to be filled.&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;       Item* item = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Item;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;       item-&amp;gt;value =&lt;span&gt; val;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;       item-&amp;gt;is_dead =&lt;span&gt; is_dead;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;       item-&amp;gt;send_args =&lt;span&gt; send_args;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;       &lt;span&gt;if&lt;/span&gt; (item-&amp;gt;&lt;span&gt;send_args.device_context) {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         item-&amp;gt;send_args.device_context-&amp;gt;&lt;span&gt;Ref();
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;       queue-&amp;gt;&lt;span&gt;push_back(item);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;      mu_.unlock();
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;       &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Status::OK();
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; There is an earliest waiter to consume this message.&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;     Item* item = queue-&amp;gt;&lt;span&gt;front();
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     queue-&amp;gt;&lt;span&gt;pop_front();
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;    mu_.unlock();
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Notify the waiter by invoking its done closure, outside the
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; lock.&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;     DCHECK(!item-&amp;gt;&lt;span&gt;IsSendValue());
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;     item-&amp;gt;waiter(Status::OK(), send_args, item-&amp;gt;&lt;span&gt;recv_args, val, is_dead);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;     &lt;span&gt;delete&lt;/span&gt;&lt;span&gt; item;
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Status::OK();
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;   }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;RecvAsync过程源码&lt;/h3&gt;
&lt;p&gt;下面是LocalRendezvous的RecvAsync函数源码展示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;   &lt;span&gt;void&lt;/span&gt; RecvAsync(&lt;span&gt;const&lt;/span&gt; ParsedKey&amp;amp; key, &lt;span&gt;const&lt;/span&gt; Args&amp;amp;&lt;span&gt; recv_args,
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;                  DoneCallback done) &lt;span&gt;override&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     uint64 key_hash =&lt;span&gt; KeyHash(key.FullKey());
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     VLOG(&lt;span&gt;2&lt;/span&gt;) &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Recv &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;this&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; key_hash &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; key.FullKey();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     mu_.&lt;span&gt;lock&lt;/span&gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;status_.ok()) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Rendezvous has been aborted.&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;       Status s =&lt;span&gt; status_;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;      mu_.unlock();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;       done(s, Args(), recv_args, Tensor(), &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;       &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     ItemQueue* queue = &amp;amp;&lt;span&gt;table_[key_hash];
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (queue-&amp;gt;empty() || !queue-&amp;gt;front()-&amp;gt;&lt;span&gt;IsSendValue()) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; There is no message to pick up.
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Only recv-related fields need to be filled.&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;       Item* item = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Item;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;       item-&amp;gt;waiter =&lt;span&gt; std::move(done);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;       item-&amp;gt;recv_args =&lt;span&gt; recv_args;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;       &lt;span&gt;if&lt;/span&gt; (item-&amp;gt;&lt;span&gt;recv_args.device_context) {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         item-&amp;gt;recv_args.device_context-&amp;gt;&lt;span&gt;Ref();
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;       queue-&amp;gt;&lt;span&gt;push_back(item);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;      mu_.unlock();
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;       &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; A message has already arrived and is queued in the table under
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; this key.  Consumes the message and invokes the done closure.&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;     Item* item = queue-&amp;gt;&lt;span&gt;front();
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     queue-&amp;gt;&lt;span&gt;pop_front();
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;    mu_.unlock();
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Invokes the done() by invoking its done closure, outside scope
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; of the table lock.&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;     DCHECK(item-&amp;gt;&lt;span&gt;IsSendValue());
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;     done(Status::OK(), item-&amp;gt;send_args, recv_args, item-&amp;gt;value, item-&amp;gt;&lt;span&gt;is_dead);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;     &lt;span&gt;delete&lt;/span&gt;&lt;span&gt; item;
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;   }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;关于IntraProcessRendezvous的Send和RecvAsync函数&lt;/h2&gt;
&lt;p&gt;其实本质上IntraProcessRendezvous和LocalRendezvous是同一个函数实现，只是前者对后者做了一层封装。我们从源码中看到，LocalRendezvous是IntraProcessRendezvous的成员之一，只是在回调函数中多了一些简单的处理而已，比如它会仔细考量Tensor的生产方和消费方是存在于CPU还是GPU，是否可以通过P2P直接拷贝，还是需要通过Host做中转，关于拷贝过程使用的是下面的函数，其他地方大同小异，因此不再赘述。有兴趣的读者可以到tensorflow/core/common_runtime/目录下参考rendezvous_mgr.h、rendezvous_mgr.cc和copy_tensor.h与copy_tensor.cc这几个文件。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Copies &quot;input&quot; to &quot;output&quot; between devices accessible to the
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; local process via some DMA-like method.  &quot;edge_name&quot; is the name
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; of the tensor being copied, for debugging purposes. Depending on
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; the type of devices and memory in use, the copy may be performed
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; synchronously or asynchronously.  'done' will be invoked only
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; after the copy is actually complete.&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;   &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ViaDMA(StringPiece edge_name, DeviceContext*&lt;span&gt; send_dev_context,
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                      DeviceContext* recv_dev_context, Device* src, Device*&lt;span&gt; dst,
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                      &lt;span&gt;const&lt;/span&gt;&lt;span&gt; AllocatorAttributes src_alloc_attr,
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                      &lt;span&gt;const&lt;/span&gt;&lt;span&gt; AllocatorAttributes dst_alloc_attr,
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                      &lt;span&gt;const&lt;/span&gt; Tensor* input, Tensor*&lt;span&gt; output,
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                      &lt;span&gt;int&lt;/span&gt; dev_to_dev_stream_index, StatusCallback done);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;本文是TensorFlow通信机制系列的第一篇文章，先通过抛出高并发情况下消息通信两端的对应问题引出TensorFlow中的ParsedKey结构设计的必要性，然后给出了Rendezvous全局类图，最后详细的分析了LocalRendezvous的消息传输实现过程。TensorFlow的通信机制的完美的阐释了Rendezvous一词的含义——无论是Send端还是Recv端都需要在临界资源Table中“约会”，进行消息的传输。随后还着重分析了异步情况下，本属于consumer的waiter函数调用时机设计问题——为了保证waiter函数的执行不被阻塞，从设计上采取Late invoke的方案。IntraProcessRendezous本质是LocalRendezvous的一层封装，它在数据拷贝上面做了更多的工作，借助LocalRendezvous实现了Send和Recv处于不同或相同种类Device情况下，对上层完全透明的拷贝过程。由于篇幅原因，特意将TensorFlow通信机制分为多个系列分析，作为第一篇文章，本篇介绍了Rendezvous的基本框架。在该系列之后的文章中，还会对跨进程的通信进行详细地分析。&lt;/p&gt;
</description>
<pubDate>Fri, 08 Feb 2019 14:31:00 +0000</pubDate>
<dc:creator>DeepLearningStack</dc:creator>
<og:description>背景 [作者：DeepLearningStack，阿里巴巴算法工程师，开源TensorFlow Contributor] 在TensorFlow源码中我们经常能看到一个奇怪的词——Rendezvous</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/deep-learning-stacks/p/10354258.html</dc:identifier>
</item>
<item>
<title>Android Intent实现页面跳转 - carry莫奈</title>
<link>http://www.cnblogs.com/MrChen-/p/10356866.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MrChen-/p/10356866.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;什么是Intent&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    Intent可以理解为信使(意图)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    由Intent来协作完成Android各个组件之间的通讯, 也可以说是实现页面与页面之间的跳转&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Intent实现页面之间的跳转&lt;/p&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li&gt;startActivity(intent)        //第一种方式启动&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;startActivityForResult(intent, requestCode); //第二种启动方式&lt;/p&gt;
&lt;p&gt;onActivityResult(int requestCode, int resultCode, Intent data)&lt;/p&gt;
&lt;p&gt;setResult(resultCode, data);&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;第一种启动方式实现直接跳转,无返回值&lt;/p&gt;
&lt;p&gt;第二种启动方式A页面-&amp;gt;B页面, B页面也能回传到A页面数据&lt;/p&gt;
&lt;p&gt;onActivityResult(int requestCode, int resultCode, Intent data)&lt;/p&gt;
&lt;p&gt;这个是 用来A页面接收B页面回传的数据用的&lt;/p&gt;
&lt;p&gt;setResult(resultCode, data) 这个是用来B页面回传给A页面数据&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/756009/201902/756009-20190208221433369-787598379.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/756009/201902/756009-20190208221433610-1865199953.png&quot; alt=&quot;&quot;/&gt;首先创建一个项目&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;新建两个Activity&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/756009/201902/756009-20190208221433976-1410214243.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;然后再layout 里面新建两个页面布局 layout右键&lt;span&gt;à&lt;/span&gt;new&lt;span&gt;à&lt;/span&gt;Android XML File&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/756009/201902/756009-20190208221434429-1738423906.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;随后,进行绑定,例如:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/756009/201902/756009-20190208221434904-1326781442.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后,配置清单文件AndroidManifest.xml&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/756009/201902/756009-20190208221435370-950926494.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/756009/201902/756009-20190208221435574-671920061.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后,在activity_first 插入两个button 一个textview 分别用来第一个和第二个跳转方式, 以及数据回传,代码如下:&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;LinearLayout &lt;/span&gt;&lt;span&gt;xmlns:android&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.android.com/apk/res/android&quot;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    android:orientation&lt;/span&gt;&lt;span&gt;=&quot;vertical&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;android:id&lt;/span&gt;&lt;span&gt;=&quot;@+id/bt_first&quot;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;wrap_content&quot;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        android:text&lt;/span&gt;&lt;span&gt;=&quot;第一种启动方式&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;android:id&lt;/span&gt;&lt;span&gt;=&quot;@+id/bt_Second&quot;&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;wrap_content&quot;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        android:text&lt;/span&gt;&lt;span&gt;=&quot;第二种启动方式&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextView
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;android:id&lt;/span&gt;&lt;span&gt;=&quot;@+id/textview&quot;&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;wrap_content&quot;&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        android:text&lt;/span&gt;&lt;span&gt;=&quot;把第二个页面回传的数据显示&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;LinearLayout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;刚才提到了,实现跳转需要用到Intent意图,代码很简单 清晰明了 我直接贴代码了&lt;/p&gt;
&lt;p&gt;首先 FirstActivity&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.example.intentdemo;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.app.Activity;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.content.Intent;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.os.Bundle;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.view.View;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.view.View.OnClickListener;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.widget.Button;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.widget.TextView;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; FirstActivity &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Activity {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    Button bt_first, bt_second;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    TextView textView;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onCreate(Bundle savedInstanceState) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onCreate(savedInstanceState);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        setContentView(R.layout.activity_first);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        initView();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; initView() {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 关联控件&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;         bt_first =&lt;span&gt; (Button) findViewById(R.id.bt_first);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         bt_second =&lt;span&gt; (Button) findViewById(R.id.bt_Second);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         textView =&lt;span&gt; (TextView) findViewById(R.id.textview);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         bt_first.setOnClickListener(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; OnClickListener() {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onClick(View arg0) {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第一种跳转,无数据返回跳转&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;                 Intent intent = &lt;span&gt;new&lt;/span&gt; Intent(FirstActivity.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;                         SecondActivity.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                 intent.putExtra(&quot;content&quot;, &quot;第一种跳转方式&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;                startActivity(intent);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         bt_second.setOnClickListener(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; OnClickListener() {
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; 
&lt;span&gt;41&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onClick(View arg0) {
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第二种方式,有数据返回跳转&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt;                 Intent intent = &lt;span&gt;new&lt;/span&gt; Intent(FirstActivity.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;                         SecondActivity.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;                 intent.putExtra(&quot;content&quot;, &quot;第二种跳转方式&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; 
&lt;span&gt;48&lt;/span&gt;                 &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;49&lt;/span&gt; &lt;span&gt;                 * 第一个参数是intent对象 第二个参数的请求的一个标识
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;                  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;51&lt;/span&gt;                 startActivityForResult(intent, 1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; 
&lt;span&gt;56&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;57&lt;/span&gt; &lt;span&gt;     * 通过startActivityForresult跳转,接收返回数据的方法 requestCode:请求的标识
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; &lt;span&gt;     * resultCode:第二个页面返回的标识 data:第二个页面回传的数据
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;60&lt;/span&gt; 
&lt;span&gt;61&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; onActivityResult(&lt;span&gt;int&lt;/span&gt; requestCode, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; resultCode, Intent data) {
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;         &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onActivityResult(requestCode, resultCode, data);
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (requestCode == 1&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (resultCode == 1&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;                 String text = data.getStringExtra(&quot;content&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt; &lt;span&gt;                textView.setText(text);
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;SecondActivity代码如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.example.intentdemo;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.app.Activity;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.content.Intent;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.os.Bundle;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.view.View;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.view.View.OnClickListener;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.widget.Button;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.widget.TextView;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; SecondActivity &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Activity {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    TextView textView;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    Button button;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onCreate(Bundle savedInstanceState) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onCreate(savedInstanceState);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        setContentView(R.layout.activity_second);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取第一个页面的意图&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         Intent intent =&lt;span&gt; getIntent();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         
&lt;span&gt;21&lt;/span&gt;         button =&lt;span&gt; (Button) findViewById(R.id.button);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         textView =&lt;span&gt; (TextView) findViewById(R.id.textview);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;接收第一个页面传送的数据&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;         textView.setText(intent.getStringExtra(&quot;content&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         button.setOnClickListener(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; OnClickListener() {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onClick(View arg0) {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                 setResult(1, &lt;span&gt;new&lt;/span&gt; Intent().putExtra(&quot;content&quot;, &quot;从第二个页面返回&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;结束当前页面&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt; &lt;span&gt;                finish(); 
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; }&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/756009/201902/756009-20190208223753604-470559341.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/756009/201902/756009-20190208223801562-433943799.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/756009/201902/756009-20190208223809161-132566406.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;这样就简单的实现了,&lt;/p&gt;
&lt;p&gt;如果有不懂的可以在下面发,我看到会帮你解决,Android其他问题也可以&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://pan.baidu.com/s/16HEQ1pVnpB995i3-lAG7qw&quot; target=&quot;_blank&quot;&gt;下面贴上Demo:https://pan.baidu.com/s/16HEQ1pVnpB995i3-lAG7qw&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 08 Feb 2019 14:15:00 +0000</pubDate>
<dc:creator>carry莫奈</dc:creator>
<og:description>什么是Intent Intent可以理解为信使(意图) 由Intent来协作完成Android各个组件之间的通讯, 也可以说是实现页面与页面之间的跳转 Intent实现页面之间的跳转 startAct</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/MrChen-/p/10356866.html</dc:identifier>
</item>
<item>
<title>SpringMVC源码阅读：异常解析器 - Rest探路者</title>
<link>http://www.cnblogs.com/Java-Starter/p/10356055.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Java-Starter/p/10356055.html</guid>
<description>&lt;h2&gt;1.前言&lt;/h2&gt;
&lt;p&gt;SpringMVC是目前J2EE平台的主流Web框架，不熟悉的园友可以看&lt;span&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/Java-Starter/p/10304896.html&quot;&gt;&lt;span&gt;SpringMVC源码阅读入门&lt;/span&gt;&lt;/a&gt;&lt;span class=&quot;postTitle2&quot;&gt;,它交代了SpringMVC的基础知识和源码阅读的技巧&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span&gt;&lt;span class=&quot;postTitle2&quot;&gt;本文将通过源码(基于Spring4.3.7)分析，弄清楚SpringMVC如何完成异常解析、捕捉异常，并自定义异常和异常解析器&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;2.源码分析&lt;/h2&gt;
&lt;p&gt;进入DispatcherServlet的processDispatchResult方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201453/201902/1201453-20190208170026293-944358959.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1024行判断异常是否是ModelAndViewDefiningException类型，如果是，直接返回ModelAndView&lt;/p&gt;
&lt;p&gt;不是ModelAndViewDefiningException类型，则获取HandlerMethod，调用processHandlerExeception方法&lt;/p&gt;
&lt;p&gt;点进去1030行的processHandlerException方法，该方法根据HandlerExecutionResolvers来解析异常并选择ModelAndView&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201453/201902/1201453-20190208171835812-95739692.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1217行遍历HandlerExecutionResolvers，我们讲过，在&amp;lt;mvc:annotation-driven/&amp;gt;帮我们注册了默认的异常解析器&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201453/201902/1201453-20190208172038102-1832208929.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;请看AnnotationDrivenBeanDefinitionParser(解析annotation-driven的类)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201453/201902/1201453-20190208172128532-175487705.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1218行调用HandlerExceptionResolver的resolveException方法，该方法被子类AbstractHandlerExceptionResolver实现&lt;/p&gt;
&lt;p&gt;1225行给request设置异常信息&lt;/p&gt;
&lt;p&gt;现在进入HandlerExceptionResolver接口resolveException方法的实现处——AbstractHandlerExceptionResolver的resolveException方法&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201453/201902/1201453-20190208173205501-573075239.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;131行判断该异常解析器是否可以被应用到Handler&lt;/p&gt;
&lt;p&gt;135行为异常情况准备response，即给response添加头部&lt;/p&gt;
&lt;p&gt;136行调用抽象方法doResolveException，由子类实现&lt;/p&gt;
&lt;p&gt;进入AbstractHandlerMethodExceptionResolver的&lt;span&gt;doResolveException方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201453/201902/1201453-20190208174209221-254562967.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;59行调用抽象方法，被子类ExceptionHandlerExceptionResolver实现&lt;/p&gt;
&lt;p&gt;打开ExceptionHandlerExceptionResolver的doResolveHandlerMethodException方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201453/201902/1201453-20190208180528183-359441487.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;362行获取有异常的Controller方法&lt;/p&gt;
&lt;p&gt;367~368行为ServletInvocableHandlerMethod设置HandlerMethodArgumentResolverComposite和HandlerMethodReturnValueComposite，用来解析参数和处理返回值&lt;/p&gt;
&lt;p&gt;380行调用invokeAndHandle方法处理返回值，暴露cause&lt;/p&gt;
&lt;p&gt;384行无cause&lt;/p&gt;
&lt;h2&gt;3.实例&lt;/h2&gt;
&lt;h3&gt;3.1 使用@ResponseStatus自定义异常UnauthorizedException&lt;/h3&gt;
&lt;p&gt;@ResponseStatus会被ResponseStatusExceptionResolver解析&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
@ResponseStatus(code=HttpStatus.UNAUTHORIZED,reason=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;用户未授权&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UnauthorizedException extends RuntimeException {

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    @RequestMapping(&quot;/unauth&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Map unauth() {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UnauthorizedException();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;浏览器输入http://localhost:8080/springmvcdemo/error/unauth&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201453/201902/1201453-20190208211146717-1078606498.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3.2 无注解情况&lt;/h3&gt;
&lt;p&gt;测试方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    @RequestMapping(&quot;/noSuchMethod&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Map noHandleMethod() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; NoSuchMethodException {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NoSuchMethodException();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;没有@ExceptionHandler和@ResponseStatus注解则会被DefaultHandlerExceptionResolver解析&lt;/p&gt;
&lt;p&gt;浏览器输入http://localhost:8080/springmvcdemo/error/noSuchMethod&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201453/201902/1201453-20190208212031026-45807059.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3.3 @ExceptionHandler处理异常&lt;/h3&gt;
&lt;p&gt;测试方法&lt;/p&gt;
&lt;p&gt;@ExceptionHandler会被ExceptionHandlerExceptionResolver解析&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
    @RequestMapping(&quot;/exception&quot;&lt;span&gt;)
    @ResponseBody
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Map exception() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ClassNotFoundException {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ClassNotFoundException(&quot;class not found&quot;&lt;span&gt;);
    }

    @RequestMapping(&lt;/span&gt;&quot;/nullpointer&quot;&lt;span&gt;)
    @ResponseBody
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Map nullpointer() {
        Map resultMap &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HashMap();
        String str &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        str.length();
        resultMap.put(&lt;/span&gt;&quot;strNullError&quot;&lt;span&gt;,str);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; resultMap;
    }

    @ExceptionHandler(RuntimeException.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
    @ResponseBody
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Map error(RuntimeException error, HttpServletRequest request) {
        Map resultMap &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HashMap();
        resultMap.put(&lt;/span&gt;&quot;param&quot;, &quot;Runtime error&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; resultMap;
    }

    @ExceptionHandler()
    @ResponseBody
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Map error(Exception error, HttpServletRequest request, HttpServletResponse response) {
        Map resultMap &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HashMap();
        resultMap.put(&lt;/span&gt;&quot;param&quot;, &quot;Exception error&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; resultMap;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;浏览器输入http://localhost:8080/springmvcdemo/error/classNotFound&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201453/201902/1201453-20190208213744608-773765210.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;浏览器输入http://localhost:8080/springmvcdemo/error/nullpointer&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201453/201902/1201453-20190208213611837-440482564.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;根据异常类继承关系，ClassNotFoundException离Exception更近，所以被&lt;span&gt;@ExceptionHandler()&lt;/span&gt;的error方法解析，注解无参相当于Exception.class。&lt;/p&gt;
&lt;p&gt;同理，NullPointerException方法离NullPointerException“最近”，把&lt;span&gt;@ExceptionHandler(NullPointerException.class)的error方法注释掉，浏览器输入http://localhost:8080/springmvcdemo/error/nullpointer，会发现&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;浏览器返回RuntimeException，印证了我们的说法&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;3.4 定义全局异常处理&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @Author: 谷天乐
 * @Date: 2019/1/21 10:48
 * @Description: ExceptionHandlerMethodResolver内部找不到Controller的@ExceptionHandler注解的话，
 * 会找@ControllerAdvice中的@ExceptionHandler注解方法
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@ControllerAdvice
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ExceptionControllerAdvice {

    @ExceptionHandler(Throwable.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
    @ResponseBody
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Map&amp;lt;String, Object&amp;gt;&lt;span&gt; ajaxError(Throwable error, HttpServletRequest request, HttpServletResponse response) {
        Map&lt;/span&gt;&amp;lt;String, Object&amp;gt; map = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String, Object&amp;gt;&lt;span&gt;();
        map.put(&lt;/span&gt;&quot;error&quot;&lt;span&gt;, error.getMessage());
        map.put(&lt;/span&gt;&quot;result&quot;, &quot;error&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; map;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;浏览器输入http://localhost:8080/springmvcdemo/error/unauth&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201453/201902/1201453-20190208214947884-667464365.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;优先级关系：@ExceptionHandler&amp;gt;@ControllerAdvice中的@ExceptionHandler&amp;gt;@ResponseStatus&lt;/p&gt;
&lt;p&gt;要把TestErrorController中@ExceptionHandler的方法注释掉才会有效果&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span&gt;&lt;span class=&quot;postTitle2&quot;&gt;4.总结&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;HandlerExceptionResolver作为异常解析器的接口，核心方法是resolveException&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;AbstractHandlerExceptionResolver实现HandlerException，resolveException方法内部调用抽象方法doResolveException，该方法被子类实现；shouldApplyTo方法检查该异常解析器是否可以被应用到Handler&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;AbstractHandlerMethodExceptionResolver的doResolveException内部调用抽象方法doResolveHandlerMethodException，由子类实现，返回ModelAndView，可以在视图模型里自定义错误页面；&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;shouldApplyTo&lt;/span&gt;&lt;/span&gt;调用父类方法&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;ExceptionHandlerExceptionResovler的doResolveHandlerMethodException处理异常，返回ModelAndView&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;DefaultHandlerExceptionResolver的doResolveException处理默认异常&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;ResponseStatusExceptionResolver的doResolveException方法处理@ResponseStatus修饰的异常&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;DispatcherServler的processHandlerException方法根据注册的HandlerExceptionResolvers选择一个ModelAndView&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;DispatcherServlet的doDispatch方法调用processDispatchResult，该方法处理Handler的选择和调用的结果，processDispatchResult方法调用&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;processHandlerException&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span&gt;&lt;span class=&quot;postTitle2&quot;&gt;5.参考&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://docs.spring.io/spring/docs/4.3.7.RELEASE/spring-framework-reference/htmlsingle/#beans-beans-conversion&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://docs.spring.io/spring/docs/4.3.7.RELEASE/spring-framework-reference/htmlsingle/#beans-beans-conversion&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://docs.spring.io/spring/docs/current/javadoc-api/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://docs.spring.io/spring/docs/current/javadoc-api/&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://github.com/spring-projects/spring-framework&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://github.com/spring-projects/spring-framework&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;文中难免有不足，欢迎指正&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 08 Feb 2019 14:07:00 +0000</pubDate>
<dc:creator>Rest探路者</dc:creator>
<og:description>1.前言 SpringMVC是目前J2EE平台的主流Web框架，不熟悉的园友可以看SpringMVC源码阅读入门,它交代了SpringMVC的基础知识和源码阅读的技巧 本文将通过源码(基于Spring</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Java-Starter/p/10356055.html</dc:identifier>
</item>
<item>
<title>前端开发掌握nginx常用功能之server&amp;location匹配规则 - wonyun</title>
<link>http://www.cnblogs.com/wonyun/p/10309491.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wonyun/p/10309491.html</guid>
<description>&lt;p&gt;nginx主要是公司运维同学必须掌握的知识，涉及到反向代理、负载均衡等服务器配置。前端开发尤其是纯前端开发来说对nginx接触的并不多，但是在一些情况下，nginx还是需要前端自己来搞；例如我们公司的开发环境和测试环境，虽然qa可以帮助搞定配置，但是每新增一个前端模块或者模块nginx配置经常变更都求着qa搞，麻烦别人还不如自己来搞，这样更能理解自己的需求。这些都需要前端开发对nginx有所理解，下面我们来说说nginx最基础的server和location匹配规则。&lt;/p&gt;
&lt;h2 id=&quot;server匹配规则&quot;&gt;1. server匹配规则&lt;/h2&gt;
&lt;p&gt;nginx的&lt;code&gt;server&lt;/code&gt;块可以配置多个，那么一个请求该匹配那个server块呢，这主要是根据server块的&lt;code&gt;server_name&lt;/code&gt;和&lt;code&gt;listen&lt;/code&gt;来决定的。其中&lt;code&gt;server_name&lt;/code&gt;仅仅检查请求的“Host”头以决定该请求应由哪个虚拟主机来处理。&lt;/p&gt;
&lt;p&gt;先看一个例子：&lt;/p&gt;
&lt;pre class=&quot;nginx&quot;&gt;
&lt;code&gt;server {
    listen      8001;
    server_name *.net;
}

server {
    listen      8001;
    server_name baidu.net;
}

server {
    listen      8001;
    server_name baidu.*;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过测试，发现&lt;strong&gt;相同listen端口&lt;/strong&gt;的情况下，多个server的匹配顺序如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;完全匹配优先级最高，匹配则终止&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;通配符在前的优先级其次&lt;/strong&gt;，如*.com&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;通配符在后的优先级次之&lt;/strong&gt;，如baidu.*&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;正则匹配优先级最低&lt;/strong&gt;，如~^.www.test.com$&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以上若都没有匹配，那么其会走默认的server，即：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;优先选择listen配置项后有default或default_server的server&lt;/strong&gt;，若没有则：&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;找到匹配listen端口的第一个server块&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一种特殊情况，如果nginx中只为某个listen端口配置一个server块的话，那么nginx是不会根据该端口的server_name进行匹配的。因为只有一个server域，那么根据上面没有匹配的规则的情况下会走第一个匹配listen端口的server块。&lt;/p&gt;
&lt;pre class=&quot;nginx&quot;&gt;
&lt;code&gt;server {
    listen    8001;
    server_name baidu.net;
}
server { # server没有配置listen的话，root用户默认是80端口，非root用户默认8080
    server_name server.com; 
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上面8001端口只有一个server的情况下，任何server_name访问&lt;code&gt;server_name:8001&lt;/code&gt;都会匹配上面server块（前提是server_name对应域名能请求到该机器上）。&lt;/p&gt;
&lt;p&gt;另一种特殊情况，server块配置的虚拟主机是&lt;strong&gt;基于域名和IP混合&lt;/strong&gt;的。如下所示：&lt;/p&gt;
&lt;pre class=&quot;nginx&quot;&gt;
&lt;code&gt;server {
    listen      192.168.1.1:8001;
    server_name example.org www.example.org;
    ...
}
server {
    listen      192.168.1.1:8002;
    server_name example.com www.example.com;
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种情况下，其匹配顺序是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先，看请求的IP地址和端口是否匹配某个server配置块中的listen指令配置，匹配则命中该server块，否则执行以下&lt;/li&gt;
&lt;li&gt;其次，看请求的Host头是否匹配这个server块中的某个server_name的值，匹配这命中，否则走默认server。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;第二点需要补充一下，看请求的Host头是否匹配server_name，要满足一个条件，即通过server_name指定的域名可以访问到当前nginx配置所在的机器，因为通过域名访问nginx所在的机器最终还是通过ip的形式来访问的。&lt;/p&gt;
&lt;p&gt;比如，访问www.example.org，最终通过dns解析出nginx所在的ip地址来进行访问的，又因为该server监听8001端口，所以通过www.example.org:8001也可以命中192.168.1.1:8001所在的server块。&lt;/p&gt;
&lt;h2 id=&quot;location匹配规则&quot;&gt;2. location匹配规则&lt;/h2&gt;
&lt;p&gt;一个示例：&lt;/p&gt;
&lt;pre class=&quot;nginx&quot;&gt;
&lt;code&gt;location  = / {
  # 精确匹配 / ，主机名后面不能带任何字符串
  [ configuration A ]
}

location  / {
  # 因为所有的地址都以 / 开头，所以这条规则将匹配到所有请求
  # 但是正则和最长字符串会优先匹配
  [ configuration B ]
}

location /documents/ {
  # 匹配任何以 /documents/ 开头的地址，匹配符合以后，还要继续往下搜索
  # 只有后面的正则表达式没有匹配到时，这一条才会采用这一条
  [ configuration C ]
}

location ~ /documents/Abc {
  # 匹配任何以 /documents/Abc 开头的地址，匹配符合以后，还要继续往下搜索
  # 只有后面的正则表达式没有匹配到时，这一条才会采用这一条
  [ configuration CC ]
}

location ^~ /images/ {
  # 匹配任何以 /images/ 开头的地址，匹配符合以后，停止往下搜索正则，采用这一条。
  [ configuration D ]
}

location ~* \.(gif|jpg|jpeg)$ {
  # 匹配所有以 gif,jpg或jpeg 结尾的请求
  # 然而，所有请求 /images/ 下的图片会被 config D 处理，因为 ^~ 到达不了这一条正则
  [ configuration E ]
}

location /images/ {
  # 字符匹配到 /images/，继续往下，会发现 ^~ 存在
  [ configuration F ]
}

location /images/abc {
  # 最长字符匹配到 /images/abc，继续往下，会发现 ^~ 存在
  # F与G的放置顺序是没有关系的
  [ configuration G ]
}

location ~ /images/abc/ {
  # 只有去掉 config D 才有效：先最长匹配 config G 开头的地址，继续往下搜索，匹配到这一条正则，采用
    [ configuration H ]
}

location ~* /js/.*/\.js {
  # 不区分大小写匹配
  [ configuration I ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;以&lt;code&gt;=&lt;/code&gt; 开头表示精确匹配，匹配则终止后续查找；如 A 中只匹配根目录结尾的请求，后面不能带任何字符串.&lt;/li&gt;
&lt;li&gt;以&lt;code&gt;^~&lt;/code&gt; 开头表示uri以某个常规字符串开头，不是正则匹配，匹配则终止后续查找，包括正则匹配，它依然支持最长匹配原则&lt;/li&gt;
&lt;li&gt;以&lt;code&gt;~&lt;/code&gt; 开头表示区分大小写的正则匹配;&lt;/li&gt;
&lt;li&gt;以&lt;code&gt;~*&lt;/code&gt; 开头表示不区分大小写的正则匹配&lt;/li&gt;
&lt;li&gt;以&lt;code&gt;/&lt;/code&gt; 通用匹配, 如果没有其它匹配,任何请求都会匹配到&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;location 顺序 no优先级：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;关于location的优先级需要认知三点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;先匹配普通location，后匹配正则location&lt;/strong&gt;；因为正则会覆盖普通&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;普通location匹配与顺序无关&lt;/strong&gt;，因为采用&lt;code&gt;最长匹配&lt;/code&gt;原则；&lt;strong&gt;正则location匹配与顺序有关&lt;/strong&gt;，但是正则location依然采用&lt;code&gt;最长匹配&lt;/code&gt;原则&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;普通location指定了&lt;code&gt;^~&lt;/code&gt;则一旦该普通规则匹配上，则不会进行后续匹配了，即使是正则匹配；&lt;code&gt;=&lt;/code&gt;严格匹配一旦匹配，也不会后续正则匹配&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以，location的优先级如下：&lt;/p&gt;
&lt;pre class=&quot;nginx&quot;&gt;
&lt;code&gt;(location =) &amp;gt; (location ^~ 路径) &amp;gt; (location ~,~* 正则顺序) &amp;gt; (location 完整路径)  &amp;gt;  (location 部分起始路径) &amp;gt; (/)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;按照上面的location写法，以下的匹配示例成立：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;/ -&amp;gt; &lt;code&gt;config A&lt;/code&gt;&lt;br/&gt;精确完全匹配，即使/index.html也匹配不了&lt;/li&gt;
&lt;li&gt;/downloads/download.html -&amp;gt; &lt;code&gt;config B&lt;/code&gt;&lt;br/&gt;匹配B以后，往下没有任何匹配，采用B&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;/images/1.gif -&amp;gt; &lt;code&gt;configuration D&lt;/code&gt;&lt;br/&gt;匹配到F，往下匹配到D，停止往下&lt;/li&gt;
&lt;li&gt;/images/abc/def -&amp;gt; &lt;code&gt;config D&lt;/code&gt;&lt;br/&gt;最长匹配到G，往下匹配D，停止往下&lt;br/&gt;你可以看到 任何以/images/开头的都会匹配到D并停止，FG写在这里是没有任何意义的，H是永远轮不到的，这里只是为了说明匹配顺序&lt;/li&gt;
&lt;li&gt;/documents/document.html -&amp;gt; &lt;code&gt;config C&lt;/code&gt;&lt;br/&gt;匹配到C，往下没有任何匹配，采用C&lt;/li&gt;
&lt;li&gt;/documents/1.jpg -&amp;gt; &lt;code&gt;configuration E&lt;/code&gt;&lt;br/&gt;匹配到C，往下正则匹配到E&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;/documents/Abc.jpg -&amp;gt; &lt;code&gt;config CC&lt;/code&gt;&lt;br/&gt;最长匹配到C，往下正则顺序匹配到CC，不会往下到E&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;实际使用建议&quot;&gt;实际使用建议&lt;/h3&gt;
&lt;pre class=&quot;nginx&quot;&gt;
&lt;code&gt;所以实际使用中，个人觉得至少有三个匹配规则定义，如下：
#直接匹配网站根，通过域名访问网站首页比较频繁，使用这个会加速处理，官网如是说。
#这里是直接转发给后端应用服务器了，也可以是一个静态首页
# 第一个必选规则
location = / {
    proxy_pass http://tomcat:8080/index
}
# 第二个必选规则是处理静态文件请求，这是nginx作为http服务器的强项
# 有两种配置模式，目录匹配或后缀匹配,任选其一或搭配使用
location ^~ /static/ {
    root /webroot/static/;
}
location ~* \.(gif|jpg|jpeg|png|css|js|ico)$ {
    root /webroot/res/;
}
#第三个规则就是通用规则，用来转发动态请求到后端应用服务器
#非静态文件请求就默认是动态请求，自己根据实际把握
#毕竟目前的一些框架的流行，带.php,.jsp后缀的情况很少了
location / {
    proxy_pass http://tomcat:8080/
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
</description>
<pubDate>Fri, 08 Feb 2019 11:19:00 +0000</pubDate>
<dc:creator>wonyun</dc:creator>
<og:description>nginx主要是公司运维同学必须掌握的知识，涉及到反向代理、负载均衡等服务器配置。前端开发尤其是纯前端开发来说对nginx接触的并不多，但是在一些情况下，nginx还是需要前端自己来搞；例如我们公司的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wonyun/p/10309491.html</dc:identifier>
</item>
<item>
<title>ABP大型项目实战(2) - 调试与排错 - 日志 - 查看审计日志 - 叶伟民</title>
<link>http://www.cnblogs.com/adalovelacer/p/abp-big-project-2-read-auditlog.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/adalovelacer/p/abp-big-project-2-read-auditlog.html</guid>
<description>
&lt;p&gt;项目发布到生产环境后难免会有错误。&lt;/p&gt;
&lt;p&gt;那么如何进行调试和排错呢？&lt;/p&gt;

&lt;p&gt;我看到俱乐部里有人是直接登陆生产服务器把数据库下载到开发机器进行调试排错。&lt;/p&gt;
&lt;p&gt;这种办法是不适用于大型项目的：&lt;/p&gt;
&lt;ol readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;首先，大型项目(特别是全球都有分公司的大型项目)很有可能24小时都有人在使用。所以尽量避免直接登录生产服务器操作，就算部署，也应该用DevOps、蓝绿部署等办法。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;另外，如果大型项目有采用金丝雀发布和A/B测试，那么把数据库下载到开发机器这种方法是很不适用的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;即使大型项目没有采用金丝雀发布和A/B测试，也不适合把数据库下载到开发机器进行调试排错。因为数据库有可能很大，网络传输需要时间，特别是连VPN的时候，甚至有可能要从欧洲传到中国，又要从中国回传到欧洲。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;生产环境数据库下载后为了安全还需要脱敏，这也需要时间。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;还有其他方法，但是这些方法都存在一个问题，就是时光不能倒流，很多时候你是不可能叫客户回来重现一遍操作流程来复现bug的。&lt;/p&gt;

&lt;p&gt;那么有什么好办法呢？&lt;/p&gt;
&lt;p&gt;有的，通过查看日志来调试与排错。&lt;/p&gt;

&lt;p&gt;ABP在这方面做得不错，内置了审计日志，提供了详细日志基类。嗯，这是两块内容了，一篇文章是讲不完的，所以我分开多篇文章来讲。&lt;/p&gt;
&lt;p&gt;先从审计日志开始吧。&lt;/p&gt;

&lt;p&gt;不得不说，ABP在这方面做得很好，审计日志是透明的，你要关闭审计日志反而要写代码控制。当然，这里不建议关闭审计日志。&lt;/p&gt;

&lt;p&gt;然而，ABP的审计日志只提供了写，没有提供读的UI，这样的话，要看审计日志就必须要打开数据库查看了。&lt;/p&gt;
&lt;p&gt;从前面的描述看到，这种做法在大型项目肯定是行不通的啦。我们必须要提供读取审计日志的UI。这就是这篇文章的主题。&lt;/p&gt;

&lt;p&gt;在我使用的ABP 3.4版本里面，并没有提供审计日志的读取AppService, 但是提供了审计日志的Entity class。（注意： ABP更新很频繁，所以你目前使用的版本有可能新增甚至删除了部分interface或class）&lt;/p&gt;
&lt;p&gt;所以我们第一步是先围绕ABP提供的审计日志Entity class（AuditLog）来建立AppService class和相关读取Mehtod. 以下是ABP 3.4版本的示例代码：&lt;/p&gt;

&lt;p&gt;IAuditLogAppService.cs&lt;/p&gt;
&lt;div readability=&quot;12&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
 public interface IAuditLogAppService : IApplicationService
    {
        /// &amp;lt;summary&amp;gt;
        /// 大型项目的审计日志量会十分大，所以最起码要分页
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;input&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        Task&amp;lt;PagedResultDto&amp;lt;AuditLogListDto&amp;gt;&amp;gt; GetAuditLogs(GetAuditLogsInput input);
        /// &amp;lt;summary&amp;gt;
        /// 一定要提供Excel下载功能，一般建议是按照时间段选取
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;input&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        Task&amp;lt;FileDto&amp;gt; GetAuditLogsToExcel(GetAuditLogsInput input);
        /// &amp;lt;summary&amp;gt;
        /// 提供全部审计日志的Excel下载，因为数据量会比较大，需要在服务器先压缩好，再提供给客户端下载。
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        Task&amp;lt;FileDto&amp;gt; GetAuditLogsToExcel();

        //List&amp;lt;AuditLogListDto&amp;gt; GetAllAuditLogs(); //错误案例示范，大型项目的审计日志量会十分大，所以最起码要分页
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　AuditLogListDto.cs&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
using System;
using Abp.Application.Services.Dto;
using Abp.Auditing;
using Abp.AutoMapper;

[AutoMapFrom(typeof(AuditLog))]
    public class AuditLogListDto : EntityDto&amp;lt;long&amp;gt;
    {
        public long? UserId { get; set; }

        public string UserName { get; set; }

        public int? ImpersonatorTenantId { get; set; }

        public long? ImpersonatorUserId { get; set; }

        public string ServiceName { get; set; }

        public string MethodName { get; set; }

        public string Parameters { get; set; }

        public DateTime ExecutionTime { get; set; }

        public int ExecutionDuration { get; set; }

        public string ClientIpAddress { get; set; }

        public string ClientName { get; set; }

        public string BrowserInfo { get; set; }

        public string Exception { get; set; }

        public string CustomData { get; set; }
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　AuditLogAppService.cs&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;11.5&quot;&gt; 
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
[DisableAuditing] //屏蔽这个AppService的审计功能
    [AbpAuthorize(AppPermissions.Pages_Administration_AuditLogs)]
    public class AuditLogAppService : GHITAssetAppServiceBase, IAuditLogAppService
    {
        private readonly IRepository&amp;lt;AuditLog, long&amp;gt; _auditLogRepository;
        private readonly IRepository&amp;lt;User, long&amp;gt; _userRepository;
        private readonly IAuditLogListExcelExporter _auditLogListExcelExporter;
        private readonly INamespaceStripper _namespaceStripper;

        public AuditLogAppService(
            IRepository&amp;lt;AuditLog, long&amp;gt; auditLogRepository,
            IRepository&amp;lt;User, long&amp;gt; userRepository,
            IAuditLogListExcelExporter auditLogListExcelExporter,
            INamespaceStripper namespaceStripper)
        {
            _auditLogRepository = auditLogRepository;
            _userRepository = userRepository;
            _auditLogListExcelExporter = auditLogListExcelExporter;
            _namespaceStripper = namespaceStripper;
        }

// 下面视具体业务情况实现接口的方法
}
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;第二步就是UI层面，因为审计日志数量会很大，查阅基本要靠搜索，所以要选一个查阅功能强大的Grid组件，根据我个人经验，推荐使用primeng的table组件。具体代码因为没有什么技术难点，我就不贴了。&lt;/p&gt;

&lt;p&gt;对了，前端一定要完成导出Excel格式功能哦，你会发觉这个功能实在是太赞了！&lt;/p&gt;

&lt;p&gt;现在终于可以不用登陆生产服务器就可以查看审计日志了。&lt;/p&gt;
&lt;p&gt;但是这只是开始！&lt;/p&gt;
&lt;p&gt;因为一个大型项目里，审计日志的增长速度是惊人的，如果审计日志表和主数据库放在一起，是十分不科学的。&lt;/p&gt;
&lt;p&gt;那么我们如何解决这个问题呢？敬请期待下一篇文章《ABP大型项目实战(2) - 调试与排错 - 日志 - 单独存储审计日志》&lt;/p&gt;

&lt;p&gt;Q&amp;amp;A：&lt;/p&gt;
&lt;p&gt;等待大家问问题中。&lt;/p&gt;
</description>
<pubDate>Fri, 08 Feb 2019 11:12:00 +0000</pubDate>
<dc:creator>叶伟民</dc:creator>
<og:description>ABP的审计日志只提供了写，没有提供读的UI，要看审计日志就必须要打开数据库查看了。 从前面的描述看到，这种做法在大型项目肯定是行不通的啦。我们必须要提供读取审计日志的UI。这就是这篇文章的主题。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/adalovelacer/p/abp-big-project-2-read-auditlog.html</dc:identifier>
</item>
<item>
<title>《.NET和Java之争》 读后感 - 虫师</title>
<link>http://www.cnblogs.com/fnng/p/10356484.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fnng/p/10356484.html</guid>
<description>&lt;p&gt;原文地址：&lt;a href=&quot;https://www.cnblogs.com/adalovelacer/p/dotnet-vs-java.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/adalovelacer/p/dotnet-vs-java.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这是博客园被推荐上首页的文章，本着好学的心态，点进去拜读...&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/311516/201902/311516-20190208174831194-471541430.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我也不清除作者都又哪里看到 .NET 和Java的论战了，身为.NET 大神，不对“主席” 必须要站出说两句，因为这是群众的呼声很高，也为了社区的荣誉。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/311516/201902/311516-20190208175024608-1383763675.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不是说好了讲《.NET和Java之争》 么？ 为什么变成 &quot;读书没有用&quot; 了？ 那么 引申的出来就是 .NET 没有用？ .NET 不能赚大钱？ 对吧！？&lt;/p&gt;
&lt;p&gt;然后，作者举例子说，读书是有用的，福布斯500 大多数都是 上过大学的，确实是啊！ 这个例子是好例子。 这充分正明了读书有用！&lt;/p&gt;
&lt;p&gt;可是， 这和 学习.NET 有没有用有什么关系？ 你想证明 .NET 有用，能赚大钱的例子呢？&lt;/p&gt;
&lt;p&gt;所以：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有人说吃shi 没用， 好！ 我来跟你证明 读书是用的。&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;有人说学.net 没用， 好！ 我来跟你证明 读书是用的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;就算，你证明了 .NET 是有用的，这和 人家Java有什么关系？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/311516/201902/311516-20190208181335355-211839326.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;作者反复用到了 《田忌赛马》 的例子，这个例子也挺好。这例子套的有点硬！&lt;/p&gt;
&lt;p&gt;如果有人刻意 找一个工资高的Java程序员和 一个工资低的.NET程序员比较，这应该是很容易拆穿的吧！?&lt;/p&gt;
&lt;p&gt;比如， 我说 测试比开发工资高，因为 我就比我们公司的某某开发实习生工资高。虽然我说举的例子是事实，但你这就信了测试普遍比开发工资高？&lt;/p&gt;
&lt;p&gt;.NET 职位 和工资 确实没有Java 多，这也是比较普遍的吧！？ 这个普遍性，我觉得是有一点参考价值的。&lt;/p&gt;
&lt;h4 id=&quot;最近我在整理叶季壮将军的史料过程中发现在ocr这一块.....&quot;&gt;&quot;最近我在整理叶季壮将军的史料过程中，发现在OCR这一块，.....&quot;&lt;/h4&gt;
&lt;p&gt;这转折.... 硬转？&lt;/p&gt;
&lt;p&gt;“我最近在看猪年春晚，说起猪我就想了猪八戒，一说到猪八戒我就想起了孙悟空，说到孙悟空... 最近六老师的中美合拍片《敢问路在何方》下半年就要开机了... ” 突然觉着，我这转折无比流畅。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/311516/201902/311516-20190208182227374-776241251.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;期待你能给社区贡献更多优秀的 .NET 技术文章， 也希望你能说到做到，将会是唯一一次也是最后一次讨论.NET和Java之争。&lt;/p&gt;
&lt;p&gt;虽然，我从头到尾也没有看到Java的存在，Java 争论了什么。。&lt;/p&gt;
&lt;p&gt;为什么要写读后感？ 作者删评论啊！ 不让留言。。。。&lt;/p&gt;
</description>
<pubDate>Fri, 08 Feb 2019 10:25:00 +0000</pubDate>
<dc:creator>虫师</dc:creator>
<og:description>原文地址：https://www.cnblogs.com/adalovelacer/p/dotnet vs java.html 这是博客园被推荐上首页的文章，本着好学的心态，点进去拜读... 我也不清</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fnng/p/10356484.html</dc:identifier>
</item>
<item>
<title>我对测试工作的一些认识 - 代码清洁工</title>
<link>http://www.cnblogs.com/linyfeng/p/10356390.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/linyfeng/p/10356390.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;span&gt;  华为5年测试老兵，对自己这些年工作经历做个总结。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;一些观点&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;  1、生活大于工作。努力的工作是为了更好的生活。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;  2、与同事相处多包容，多理解。每个人的追求和对自己的要求都不一样。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;  3、精力有限，尽早构建自己的知识体系并不断丰富自己体系内的知识主干。做一个有所长的人。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;  4、不懂编码的测试不是一个好的测试人员。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;  5、个人能力越强的人在做决定时往往越容易占据主动地位。建议入职开始就构建自己的能力。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;  6、升职、加薪长期来看往往是相对公平的。如果你觉得长期不公平，别抱怨，努力提升自己。最后可以选择离开。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;  7、测试人员的地位高低客观条件取决于团队组织架构、产品形态。主观条件取决于你的能力。你对产品保障、团队、开发贡献越大，你的被认可度就越高。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;  8、入门测试行业很容易、完成大部分测试工作也很简单，但是你要成为一个好的测试人员很难。测试工作中有很多内容都相对简单，有很多体力活。资料测试、测试执行、安装环境等重复性高的工作。但是你要成为一个好的测试，需要懂测试分析和设计方法、编码、网络知识、Linux、数据库、问题分析方法、各种测试工具等等。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;  9、测试技术和业务能力都很重要。但是你要努力做好平衡。这与你的工作岗位有关。如果你是功能测试，侧重业务能力。如果你是专项测试，侧重测试技术。如果你是领导。我不知道。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;  10、在非工作时间学习，建议多打磨测试技术。因为它们在就业市场更通用。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;  11、问题是能力提升最好的催化剂。分析问题、解决问题、总结问题相关的知识、输出经验文档可以快速提升你的能力和经验。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;  12、研究工具、多动手实践是学编码的有效手段，只看书不动手是没有任何用处的。这里的工具指的是项目组同事自行开发的效率提升、解决问题的工具。Python/Shell脚本语言可以直接看源码。Java语言编写的.jar包可以用jd-gui.exe反编译查看。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;  13、工作方法有时候比技术更重要。凡事有交代，件件有着落，事事有回音。做一个让人觉得靠谱的人。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;  14、执行力太重要了。工作中由于执行力不够而导致决策没有落实的事情太多了。特别是每次现网问题发生后的问题回溯，各种大会小会的开、各种落地方法的研讨。实施执行两次后都是不了了之。然后更可悲的是重犯相同的错误。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;  15、如果觉得自己有能力，就多输出。可以是效率提升的工具、可以是特性或问题解决经验文档、可以是培训，要让人看到有承载能力的东西出来。不然领导想夸你都不知道拿啥去夸。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;  16、越是莫名其妙的问题，根因往往很简单。可以看看新员工给你提的问题~&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;  17、测试不要存在侥幸心理。如果你认为需要测试的场景没有测试的抓紧测试把。做个认真、负责任的Tester。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;  18、做个有原则的测试人。至于哪些原则，看组织和个人情况。因为与开发打交道，某些事情（某个缺陷是提单还是不提单、确实定级致命、严重、一般，转测试电子流启动再开始测试还是先测试）难免存在灰度，如何妥善处理特殊场景就要根据自己的原则来办。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;  19、测试无法完全保证产品质量。产品质量需要设计、开发、QA各角色合力保障。之前听到一句话说的很有意思，没有哪一个牛逼的发动机是靠测试测出来的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;  20、测试经常是背锅的。每次出问题领导第一句话是&quot;测试为什么没有测出来&quot;。我的理解是这也难免，产品发布的最后一道环节，而且马后炮去看一个场景真的觉得都挺简单的。分析下问题场景，如果确实很低级，就反思下为啥会漏了。如果是在很苛刻的条件下才能重现，就好好总结一下，都是宝贵经验。最重要一点不应该把责任都归咎于测试执行或设计人身上。否则后面就没有人愿意主动承担高风险任务了。每个测试人员在过程中按流程尽职尽责做好就好。因上努力，果上随缘了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;  21、你的个人的能力、工作态度要尽早表现出来，特别是新岗位、新员工。领导对你的印象往往在开始就慢慢形成。后面要想扭转，需要花费更多的经历。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 08 Feb 2019 09:03:00 +0000</pubDate>
<dc:creator>代码清洁工</dc:creator>
<og:description>华为5年测试老兵，对自己这些年工作经历做个总结。 一些观点 1、生活大于工作。努力的工作是为了更好的生活。 2、与同事相处多包容，多理解。每个人的追求和对自己的要求都不一样。 3、精力有限，尽早构建自</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/linyfeng/p/10356390.html</dc:identifier>
</item>
<item>
<title>精力充沛，过好每一天 - Avenstar</title>
<link>http://www.cnblogs.com/zjf-1992/p/10336582.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zjf-1992/p/10336582.html</guid>
<description>&lt;p&gt;这篇文章从1月份一直拖到现在哇...... 先来看几张拍到的作品，超有意思哇......&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/819169/201901/819169-20190130041537509-1071599099.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;《远方来客》&lt;/strong&gt; 100cm×150cm 2009年  &lt;span&gt;(图源自徐匡作品)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/819169/201901/819169-20190130041908272-2136990168.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;《牧 归》&lt;/strong&gt; 120cm×180cm  &lt;span&gt;(图源自徐匡作品)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/819169/201901/819169-20190130042140190-1902326215.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;《斯朗卓嘎》&lt;/strong&gt; 100cm×150cm 2010年   &lt;span&gt;(图源自徐匡作品)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/819169/201901/819169-20190130042824507-46692461.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;《小黑马》&lt;/strong&gt;100cm×150cm 2010年  &lt;span&gt; (图源自徐匡作品)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;楼主最初看到这些艺术画（徐匡画）时候还以为都是用宣纸画的的呢？直到在展厅中央看见&lt;strong&gt;作画使用很普通的工具.&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;一把锤子、 一块放大镜、一块有色泽的（天然的）木板、一盒木刻刀&lt;/strong&gt; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;内心着实深深的被震撼到了，居然是木刻画（大概因为站得角度不同，对于作画者来说是活生生的的经历，看者来说就是故事）......&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/819169/201901/819169-20190130043337986-735110997.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 几件很普通的、习以为常的工具  &lt;strong&gt;&lt;span class=&quot;cnblogs_code&quot;&gt;一把锤子、 一块放大镜、一块有色泽的（天然的）木板、一盒木刻刀&lt;/span&gt;&lt;/strong&gt;   在艺术家（徐匡版画）的手中经过&lt;strong&gt;细节的处理、刀痕的深浅、木纹肌理、木材的质地、色泽的变化等...&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;精雕细琢&lt;/strong&gt;就能&lt;strong&gt;变幻出巧夺天工、精美绝伦、栩栩如生的艺术品&lt;/strong&gt;.....然在我们平凡人的手里，&lt;strong&gt;大概什么都不是......导致这种差距原因除天赋、兴趣......等外，&lt;/strong&gt;大概还有一个很重要的因素———&lt;strong&gt;持续的进步。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;知识的学习大概亦是如此&lt;/strong&gt;&lt;strong&gt;......认真、反复的刻意练习。每日持续的进步量层层累加，推导出一个好的结果。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用一道简明的数学公式（复利公式）&lt;/strong&gt;大概表示如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;PG（个人成长）  = P(&lt;span&gt;1&lt;/span&gt;+i)&lt;span&gt;&lt;sup&gt;365&lt;/sup&gt;&lt;/span&gt;   &lt;span&gt;一个人的成长 = 一个人现阶段能力*（1+每日的持续进步量）&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;365次方&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一直以来就深受儒家文化影响（儒家文化像芯片一样植入大脑），摘录《&lt;span class=&quot;tit&quot;&gt;曾国藩家训&lt;/span&gt;》日课十二条，很有值得借鉴、学习的意义......&lt;/p&gt;
&lt;p&gt;&lt;em&gt;（标注 关键字解释均为个人理解，难免挂一漏万。欢迎指出）&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;（大意：持神敬肃：衣冠外貌要保持整齐，心思神情要端正严肃，时时刻刻都要警惕、检查自己是否出现了闲杂或不良的念头。平日闲居无事时，要宁静安泰，不要想身体以外的事情，一旦投入工作中，就要做到专心致志，不存杂念。&lt;/p&gt;
&lt;p&gt;  只有保持清澈明朗的精神状态，才能保持旺盛的生机，就像早晨的太阳一样。 所谓“主敬”，是要求内心恭敬而不是外表恭敬。心中无我才能做到真正谦虚。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关键词： 主敬：内心、外表恭敬 。专注、衣冠整洁、精力充沛&lt;/strong&gt;）&lt;/p&gt;

&lt;p&gt; （大意：静坐养性：每天不限任何时间，必须静坐一小时以上，体验圣人所教诲的仁心，使思虑不出本位，以使性命凝结，就像宝鼎一样镇定而不可动摇。 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关键词： 静坐：体念来复之仁心、内心极度平静。 冥想&lt;/strong&gt;）&lt;/p&gt;

&lt;p&gt; （大意：起床要早，天色刚亮就赶紧起身，不要有留恋安逸的念头  &lt;strong&gt;关键词： 早起&lt;/strong&gt;）&lt;/p&gt;

&lt;p&gt; （大意：读书要专一：一本书还没有读完，一定不去看其它的书籍。东翻西阅地随意读书，对自己的道德学问没有一点益处，不过就是一个只求知识而没有道德的人。每天必须圈点十页。 &lt;strong&gt;关键词： 读书&lt;/strong&gt; ）&lt;/p&gt;

&lt;p&gt; （大意：读史可以使人明白善恶事理，才能正确地为人处世，光宗耀祖，这是父母所希望的，对于为己为人，也是必要的。否则，必定成为不忠不孝之徒。 &lt;strong&gt;关键词： 读书&lt;/strong&gt;   ）&lt;/p&gt;

&lt;p&gt;  （大意：说话谨慎：对此要时时刻刻细心留意，这是为人处世的第一等功夫。 为人处世的关键在于谨慎地说话，而谨言的基础在于“三思”和“反省”。这也是能够做到“不生气”的最行之有效的方法。&lt;strong&gt;关键词：谨言&lt;/strong&gt; ）&lt;/p&gt;

&lt;p&gt; （大意：培养自己的真气：能够做到内外统一、光明正大之行，没有奸诈计谋、行险侥幸之念，任何所作所想都能够说得出口，只有这样，才能将真气存蓄于丹田之中。&lt;/p&gt;
&lt;p&gt;处处心存他人，才能为人光明坦荡；时时行险侥幸，必然处世奸诈虚伪。生活中常心存机谋算计，不论如何打坐修炼，必定不能“体念来复之仁心”。 &lt;strong&gt;关键词：养气  真气内外统一、气沉丹田&lt;/strong&gt;）&lt;/p&gt;

&lt;p&gt;  （大意：保持身体健康要做到节制操劳，节制欲望，节制饮食，要时时刻刻都像养病时一样地保养自己的身体。&lt;strong&gt;关键词：保身  身体健康&lt;/strong&gt;）&lt;/p&gt;

&lt;p&gt; （大意：所谓“日知所亡”，即要将每日的心得体会记录下来，从而自省而能有所感知，不刻意从书中谋求深意，否则，就是曲从于他人。&lt;strong&gt;关键词：日知所亡. 读书心得体会&lt;/strong&gt;）&lt;/p&gt;

&lt;p&gt;（大意：每月都要复习已经学过的知识和本领，每个月必须做诗歌或短文数首，用来检验所学理论是多还是少，所培养真气是否充盛。不可以一味地懒惰迟延，这样最容易使自己的志向丧失殆尽。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关键词：月无亡所能.  复盘、反省、总结、计划&lt;/strong&gt;）&lt;/p&gt;

&lt;p&gt;（大意：早饭后必须练习书法一小时。而且，所有文字方面的应酬，都可以作为练习书法的机会。凡是今天的事情，一定不许留待明天去做，事情越积越多，就会越难以清理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关键词： 作字  皆当作功课、今日事今日毕。不拖延&lt;/strong&gt; ）&lt;/p&gt;

&lt;p&gt;（大意：夜晚不出家门：出门应酬玩乐，会使人荒废修养功夫，会使精气耗损、神情疲惫。所以，这种不良习气要戒除。&lt;strong&gt;关键词： 夜不出门&lt;/strong&gt; ）&lt;/p&gt;
&lt;p&gt;以前总觉得日子是按年过的，现在随着年龄渐长，深深的觉得日子是按天过得。并且这种感觉越来越强烈。&lt;/p&gt;
&lt;p&gt;祝愿90后同龄结婚的小伙伴爱情甜蜜、与之偕老，还在找寻另一半的伙伴遇见真爱，终成眷属，一切越来越好。———未来很遥远，当下（今天）最美好，精力充沛，过好每一天。&lt;/p&gt;
&lt;p&gt;尾声：梳理文章的大体思路如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/819169/201902/819169-20190208155939972-902582664.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 08 Feb 2019 08:48:00 +0000</pubDate>
<dc:creator>Avenstar</dc:creator>
<og:description>这篇文章从1月份一直拖到现在哇...... 先来看几张拍到的作品，超有意思哇...... 《远方来客》 100cm×150cm 2009年 (图源自徐匡作品) 《牧 归》 120cm</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zjf-1992/p/10336582.html</dc:identifier>
</item>
</channel>
</rss>