<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Redis分布式锁实战 - 胡峻峥</title>
<link>http://www.cnblogs.com/hujunzheng/p/11295345.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hujunzheng/p/11295345.html</guid>
<description>[unable to retrieve full-text content]什么是分布式锁 在单机部署的情况下，要想保证特定业务在顺序执行，通过JDK提供的synchronized关键字、Semaphore、ReentrantLock，或者我们也可以基于AQS定制化锁。单机部署的情况下，锁是在多线程之间共享的，但是分布式部署的情况下，锁是多进程之间共享的。那么分布式锁要保证</description>
<pubDate>Mon, 05 Aug 2019 00:43:00 +0000</pubDate>
<dc:creator>胡峻峥</dc:creator>
<dc:identifier>http://www.cnblogs.com/hujunzheng/p/11295345.html</dc:identifier>
</item>
<item>
<title>用词向量得句向量的无监督方法 - Kalafinaian</title>
<link>http://www.cnblogs.com/Kalafinaian/p/11300953.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Kalafinaian/p/11300953.html</guid>
<description>&lt;p&gt;       词向量技术是NLP领域中一种基础的技术，词向量将一个词语转换为固定维度的向量，通过处理向量关系让NLP中语义计算的任务得以实现。&lt;/p&gt;
&lt;p&gt;       我们都知道句子是由一个个词语组成的，词向量技术只是将单个词语转成固定维度的向量，那么怎么得到多个词语组成的句子的向量了？这是一个好问题，毕竟实际环境中需要处理的文本是一个个句子，而非一个个词语。为了让读者了解用词向量生成句向量的具体步骤，本文将介绍如下几种词向量生成句向量的无监督学习手段，它们分别是：累加法、平均法、TF-IDF加权平均法以及SIF嵌入法。&lt;/p&gt;

&lt;p&gt;       累加法是得到句子向量最简单的方法，假设有这样一句文本:&lt;/p&gt;
&lt;center&gt;There is no royal way to geometry.&lt;br/&gt;——Euclid(欧几里得)&lt;/center&gt;
&lt;p&gt;       这句是古希腊著名数学家欧几里得的名言，其中文意思是“通往几何并没有皇家大道”。NLP处理一段文本首先需要将一段文本进行去停用词处理，英语中常见的停用词有be动词、介词、连词等，经过去停用词处理后上述文本可得下面的词语距离:&lt;/p&gt;
&lt;p&gt;       {there, no, royal, way, geometry}&lt;br/&gt;       本文采用相应的词向量词典(GoogleNews-vectors-negative300.bin)和python的gensim来得到词向量，可得上述单词的如下词向量(本文篇幅有限，用5维的词向量来演示)&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;15&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;6&quot;&gt;&lt;td&gt;There&lt;/td&gt;
&lt;td&gt;[ 0.1, 0.2, 0.3, 0.4, 0.5]&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;6&quot;&gt;&lt;td&gt;No&lt;/td&gt;
&lt;td&gt;[ 0.2, 0.3, 0.4, 0.5, 0.6]&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;6&quot;&gt;&lt;td&gt;Royal&lt;/td&gt;
&lt;td&gt;[ 0.3, 0.4, 0.5, 0.6, 0.7 ]&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;6&quot;&gt;&lt;td&gt;Way&lt;/td&gt;
&lt;td&gt;[ 0.4, 0.5, 0.6, 0.7, 0.8 ]&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;6&quot;&gt;&lt;td&gt;Geometry&lt;/td&gt;
&lt;td&gt;[0.5, 0.6, 0.7, 0.8, 0.9]&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;       累加法的做法是将句子中所有非停用词的词向量叠加，如果句子有n个非停用词，则句子的词向量通过下面的手段获得:&lt;/p&gt;
&lt;p&gt;       Vsentence = Vword1 + Vword2 + …… + Vwordn&lt;/p&gt;
&lt;p&gt;       根据此方法可以得到” There is no royal way to geometry.“ 的句子向量为:&lt;/p&gt;
&lt;p&gt;       Vsentence = Vthere + Vno + Vroyal + Vway + Vgeometry&lt;/p&gt;
&lt;p&gt;                     = [ 0.1, 0.2, 0.3, 0.4, 0.5] + [ 0.2, 0.3, 0.4, 0.5, 0.6] + … + [0.5, 0.6, 0.7, 0.8, 0.9]&lt;/p&gt;
&lt;p&gt;                     = [1.5, 2.0, 2.5, 3.0, 3.5]&lt;/p&gt;

&lt;p&gt;       平均法和累计法方法相似，同样需要将一个句子中所有的非停用词向量叠加起来，但最后需要加叠加起来向量处以非停用词的个数。句子的词向量通过下面的手段获得:&lt;/p&gt;
&lt;p&gt;       Vsentence = (Vword1 + Vword2 + …… + Vwordn) / n&lt;/p&gt;
&lt;p&gt;       根据此方法可以得到” There is no royal way to geometry.“ 的句子向量为:&lt;/p&gt;
&lt;p&gt;       Vsentence =( Vthere + Vno + Vroyal + Vway + Vgeometry) / 5&lt;/p&gt;
&lt;p&gt;                     = ([ 0.1, 0.2, 0.3, 0.4, 0.5] + [ 0.2, 0.3, 0.4, 0.5, 0.6] + … + [0.5, 0.6, 0.7, 0.8, 0.9]) / 5&lt;/p&gt;
&lt;p&gt;                     = [1.5, 2.0, 2.5, 3.0, 3.5] / 5&lt;/p&gt;
&lt;p&gt;                     = [0.3, 0.4, 0.5, 0.6, 0.7]&lt;/p&gt;

&lt;p&gt;       TF-IDF加权平均法需要利用到TF-IDF技术，TF-IDF技术是一种常用的文本处理技术。TF-IDF模型常用评估一个词语对于一个文档的重要程度，经常应用于搜索技术和信息检索的领域。一个词语TF-IDF值与它在文档中出现频数成正比，与它在语料库中出现的频率成反比。TF-IDF由TF词频(Term Frequency)和IDF逆向文件频率(Inverse Document Frequency)相乘而得。对于词语ti来说：&lt;/p&gt;
&lt;p&gt;       其中ni,j是词语ti在自己所处的文档j中出现频数，Σknk,j是文档j中所有所有词语对应数&lt;br/&gt;之和，|D|表示训练语料库中文档的总数，| j:ti∈dj|表示训练语料库中包含词语ti的文档总数。&lt;br/&gt;另外值得注意的是，如果词语ti不在语料库中那么(1)式中| j:ti∈dj|为0，那么会导致IDFj中分母为0，则无法计算出IDFj值。所以需要改进为如下：&lt;/p&gt;
&lt;p&gt;       TF-IDF加权法不仅需要得到句子中每个非停用词的词向量，还需要得到句子中每个非停用词的TFIDF值。每个非停用词的TF部分还好计算，IDF部分就要看用户使用哪个语料库，如果是做query检索，那么IDF部分对应的语料库就是所有query句子；如果是做文本自相似聚类，那么IDF部分对应的语料库就是全体待分类句子。然后通过如下手段得到TF-IDF加权的的句子向量:&lt;/p&gt;
&lt;p&gt;       Vsentence = TFIDFword1 * Vword1 + TFIDFword2 * Vword2 + …… + TFIDFwordn * Vwordn&lt;/p&gt;
&lt;p&gt;       假设” There is no royal way to geometry.“ 是做query检索，那么计算IT-IDF对应的语料库就是全体query句子。若全体query句子一共有100个; 其中60个query句子含有词语there, 65个query句子含有词语no, 7个query句子含有词语royal, 72个query句子含有词语way, 9个quer句子y含有词语geometry。那么这句话中每个非停用词的TF-IDF数如下所示：&lt;/p&gt;
&lt;p&gt;       There: 1/(1+1+1+1+1) * log(100/(1+60) = 0.098&lt;/p&gt;
&lt;p&gt;       No: 1/(1+1+1+1+1) * log(100/(1+65) = 0.083&lt;/p&gt;
&lt;p&gt;       Royal: 1/(1+1+1+1+1) * log(100/(1+7) = 0.505&lt;/p&gt;
&lt;p&gt;       Way: 1/(1+1+1+1+1) * log(100/(1+72) = 0.629&lt;/p&gt;
&lt;p&gt;       Geometry: 1/(1+1+1+1+1) * log(100/(1+9) = 0.460&lt;/p&gt;
&lt;p&gt;       所以这句话的IT-IDF加权据向量为:&lt;/p&gt;
&lt;p&gt;       Vsentence = TFIDFthere * Vthere + TFIDFno * Vno + …… + TFIDFgeometry * Vgeometry&lt;/p&gt;
&lt;p&gt;                     =0.098&lt;em&gt;[0.1,0.2,0.3,0.4,0.5]+0.083&lt;/em&gt;[0.2,0.3,0.4,0.5,0.6]+…+0.460*[0.5,0.6,0.7,0.8,0.9]&lt;/p&gt;
&lt;p&gt;                     = [0.147, 0.166, 1.2625 , 1.887, 1.61]&lt;/p&gt;

&lt;p&gt;       ISF加权平均法和TF-IDF加权平均法类似，ISF加权计算来源于普林斯顿大学的论文A latent variable model approach to pmi-based word embeddings. ( &lt;a href=&quot;https://openreview.net/forum?id=Sy&quot; class=&quot;uri&quot;&gt;https://openreview.net/forum?id=Sy&lt;/a&gt; K00v5xx)，按照论文作者说法，此方法可以很好的根据每个词词向量得到整个句子的据向量。SIF嵌入法需要利用主成分分析和每个词语的estimated probability, SIF嵌入法具体操作如下所示：&lt;br/&gt;&lt;/p&gt;
&lt;center readability=&quot;2&quot;&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1180694/201908/1180694-20190805084038716-1658384319.jpg&quot;/&gt;&lt;p&gt;图1 SIF句子向量嵌入生成&lt;br/&gt;&lt;/p&gt;&lt;/center&gt;
&lt;br/&gt;       首先整个算法的输入有:&lt;br/&gt;       (1) 每个词语的词向量&lt;br/&gt;       (2) 语料库中全体句子&lt;br/&gt;       (3) 可调参数a&lt;br/&gt;       (4) 每个词语estimated probability
&lt;p&gt;       整个算法的输出为:&lt;br/&gt;       一个句子向量&lt;/p&gt;
&lt;p&gt;       算法的具体步骤是：&lt;br/&gt;       (1) 得到初步句向量&lt;/p&gt;
&lt;p&gt;       遍历语料库中每个句子，假设当前句子为s, 通过如下计算式子得到当前句子s的初步句向量:&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\frac{{\rm{1}}}{{\left| s \right|}}\sum\nolimits_{w \in s} {\frac{a}{{a + p\left( w \right)}}{v_w}} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;       即加权求平均的过程，每个词语向量乘以系数a/(a+p(w)后叠加，最后叠加向量处以句子s中词语的个数，对于可调参数a论文中作者使用0.001和0.0001两个。P(w)是词语在全体语料库中unigram probability，即词语w词频处以语料库所有词语词频之和。&lt;/p&gt;
&lt;p&gt;       (2) 主成分计算&lt;br/&gt;       全体初步句向量进行主成分分析，计算出全体初步句向量第一主成分u&lt;/p&gt;
&lt;p&gt;       (3) 得到目标句向量&lt;br/&gt;       通过如下计算时对初步句向量进行二次处理，得到目标句向量&lt;/p&gt;
&lt;p&gt;       此论文作者也在Github上公开了源代码，感兴趣的读者可以自行下载做实验,&lt;a href=&quot;https://github.com/PrincetonML/SIF&quot;&gt;Github代码&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;       本文主要介绍了四种无监督手段来根据词向量生成一个句子的句向量，除了无监督手段外，实际环境中还有用到监督方法来生成一个句子向量，例如训练一个CNN的文本分类器，取最后一个隐藏层的输出作为句子向量，感兴趣的读者可以google来进一步学习。&lt;/p&gt;
&lt;h2 id=&quot;参考文献&quot;&gt;参考文献&lt;/h2&gt;
&lt;p&gt;       [1] Arora S, Liang Y, Ma T. A simple but tough-to-beat baseline for sentence embeddings[J]. 2016.&lt;/p&gt;
</description>
<pubDate>Mon, 05 Aug 2019 00:42:00 +0000</pubDate>
<dc:creator>Kalafinaian</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Kalafinaian/p/11300953.html</dc:identifier>
</item>
<item>
<title>Linux grep 命令 - sparkdev</title>
<link>http://www.cnblogs.com/sparkdev/p/11294517.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sparkdev/p/11294517.html</guid>
<description>[unable to retrieve full-text content]Grep 是 Global Regular Expression Print 的缩写，它搜索指定文件的内容，匹配指定的模式，默认情况下输出匹配内容所在的行。注意，grep 只支持匹配而不能替换匹配到的内容。 基本语法 语法格式：grep [OPTIONS] PATTERN [FILE...]grep</description>
<pubDate>Mon, 05 Aug 2019 00:40:00 +0000</pubDate>
<dc:creator>sparkdev</dc:creator>
<dc:identifier>https://www.cnblogs.com/sparkdev/p/11294517.html</dc:identifier>
</item>
<item>
<title>程序员修炼之道-注重实效 - 渡码</title>
<link>http://www.cnblogs.com/duma/p/11286005.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/duma/p/11286005.html</guid>
<description>&lt;p&gt;&lt;span&gt;本篇文章是阅读《程序员修炼之道——从小工到专家》第一章 “注重实效的哲学” 的笔记。有了一些开发经验后再看这本书会比较有感触，本书第一章讲了一些对程序员最基本的要求，如果你正在进行职业规划，那么这本书有很好的参考意义。下面我结合自己的经历聊聊第一章的内容。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;责任&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;责任是做一切事情得前提，小到对自己的代码，大到人生规划，我想这也是作者把它作为第一章第一段的原因。责任是你主动承担的东西，当然如果这件事超过了你的控制范围，你有权不对它负责。否则的话你需要切实负起责任，即使过程中犯了错误也应该坦诚承认，而不是找各种借口。我觉得大部分程序员都会对自己的代码有很强的的责任心，毕竟它就像孩子一样，当然责任心太强往往会导致不愿承认一些错误。其实在职场中领导也比较喜欢那些能够主动承认错误的员工，谁也不能保证不犯错误，但对于犯了错误藏着掖着甚至乱甩锅的员工，领导可能更不放心交付他更重要的任务。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;软件的熵&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;熵是一个物理学的概念，指的是某个系统中 “无序” 的总量，当软件中的无序增长时，我们称之为 “软件腐烂”。至于什么情况会导致软件腐烂，作者举了一个 “破窗户” 的例子，也就是我们常听说的 “破窗理论”。简单来说，&lt;/span&gt;&lt;em&gt;&lt;span&gt;一扇破窗户，长时间不修理，会给人们带来一种废弃感。于是又破了一扇窗户，人们开始乱扔垃圾，乱涂乱画，最终房屋的结构遭到严重破坏，且超出了业主的修理程度，从而废弃感变成了现实。&lt;/span&gt;&lt;/em&gt;&lt;span&gt;破窗理论启发了警察部门对一些轻微的案件也严加处理，防止大案件的发生。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在软件开发中，低劣的设计、糟糕的代码和低质的文档等，都是 “破窗户”，应该看见一个修一个，不能让这种无序的状态越来越严重，导致软件腐烂。当然我们可能没有时间、精力去清理所有的 “破窗户”，我们可以加一些 TODO，或者集中整理成文档，拉一个专项专门处理。所以说，没有不好的程序员，只有不好的设计、代码和文档。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;石头汤与煮青蛙&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;我们开发过程中，需要其他团队配合的时候，往往容易出现其他团队对我们所做的事情的漠视、拖延。这时候比较好的做法是，我们需要先把自己的想法进行落地，设计并开发出一个初版，有一些成就积极与大家分享。当其他人看到这个东西正在走向成功的时候，别人就会愿意帮助我们，最终共同协作完成项目，当然成果也要与大家共享。为了说明这个问题，作者讲了一个故事，&lt;/span&gt;&lt;span&gt;&lt;em&gt;有三个饥饿的士兵，路过一个村庄，由于多年的战乱，村民的食物也很匮乏。于是，士兵们便煮了一锅水，里面放了几块石头。士兵告诉惊讶的村民说这是 “石头汤”，如果放一点胡萝卜会更鲜美，一个村民就跑开去拿胡萝卜。士兵又说放点土豆会更好，另一个村民回去拿土豆。接下来不断有人拿东西，食物变得越来越多，汤越来越丰盛，最终士兵和村民一起享用了一顿美餐。&lt;/em&gt;&lt;/span&gt;&lt;span&gt;这就是 “石头汤” 的案例&lt;/span&gt;&lt;span&gt;。当然，工作中也会碰到有些团队就是不配合，就像有些村民就是不愿意把自己私藏的东西拿出来。这也没办法，或许别人有更重要的事情去做。至少这个案例给了我们一个解决这类问题的新视角。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从村民的角度来，这个案例也告诫我们视野不要太狭窄，要关注到别人做的事情，如果是一件值得去做的事情就要积极主动地参与进去，留心大图景。不要固执地只负责自己那一块的内容，不要做温水里的青蛙。所以，石头汤和煮青蛙看似两个独立的案例，却有一定的联系。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;用户的参与&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;完美的软件需要用户的参与，因为通常我们是为别人编写软件。除了软件的功能需求，还要关注交付时间、软件质量等需求，无视用户的需求，一味地追求新特性、粉饰代码并不是有职业素养的做法。以我所从事的大数据工作为例，其实我们的用户就是运营、产品，如果无视他们的数据需求，一味地增加一些酷炫的指标，可能对分析产品并没有什么帮助，显然这样做是不对的。同样，为了交付期限、功能需求而无视工程质量的做法也不可取。所以，我们经常需要在满足用户需求与完美的工程实践之间权衡。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;知识资产&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;我们经常听到说程序员是吃青春饭的，也就是说知识资产是有时效性的。随着我们的知识价值降低，我们对公司或者客户来说，我们的价值也在降低。为了阻止这样的事情发生，我们需要像对待金融资产一样，对待我们的知识资产。每年学一门新编程语言、每个季度读一本书（定期投资自己）。多接触了解其他的技术栈，比如：做前端的了解后端技术，做大数据的了解算法（多元化的投资）。关注新技术，在新技术流行前就花时间研究，当它流行时我们已经领先了大部分人（低买高卖）。要经常评估自己掌握的技术在市场上中的地位，如果已经凉了，需要果断放弃把经历放到新的方向（周期性地重新评估资产）。我们经常拿老外来反驳程序员吃青春饭，看完这部分内容才发现，原来老外把知识资产当做了金融资产，所以才能保证自己的价值。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;交流&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;虽然程序员生活中不善言谈，但在工作中往往需要大量的沟通，小到接口协议，大到架构设计。交流一方面是为了推进自己的工作，另一方面是为了输出自己的观点，建立自己的影响力。同时交流的过程需要注意一些细节，比如：了解听众，选择沟通的时机，选择沟通的风格，沟通前注意自己的思路、文档是否清晰，交流中要倾听别人意见、让听众参与，沟通后及时总结、回复他人。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;小结&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;本篇内容各个小结看似比较独立，但其实是有一定的联系的。首先责任是后续所以内容的一个前提。其次，作为程序员我们要把自己的工作做好，“软件的熵” 告诉我们要立足于我们自己的工作，要解决自己软件里的的“破窗户”。当我们把自己的事情做好，需要别人参与到我们的软件中，组成一个大的协作体的时候，需要我们怎么去协作，便是 “石头汤与煮青蛙” 一节的内容。我们开发软件，最终要解决用户的需求、为用户创造价值，所以这个过程要有 “用户的参与”。虽然目前我们开发出了让用户满意的产品，但过程中我们用到的知识有时效性的，“知识资产” 这节告诉我们如果让自己有价值。最后提到的 “交流” 是为了让我们上面所有的努力能够输出，建立自己的影响力。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;欢迎关注公众号&lt;strong/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1129006/201905/1129006-20190519220125818-12935098.png&quot; alt=&quot;&quot; width=&quot;130&quot; height=&quot;129&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 05 Aug 2019 00:36:00 +0000</pubDate>
<dc:creator>渡码</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/duma/p/11286005.html</dc:identifier>
</item>
<item>
<title>WebSocket的实现与应用 - 血夜之末</title>
<link>http://www.cnblogs.com/Tiancheng-Duan/p/11288593.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Tiancheng-Duan/p/11288593.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;说到websocket，就不得不提http协议的连接特点特点与交互模型。&lt;/p&gt;
&lt;p&gt;首先，http协议的特点是无状态连接。即http的前一次连接与后一次连接是相互独立的。&lt;/p&gt;
&lt;p&gt;其次，http的交互模型是请求/应答模型。即交互是通过C/B端向S端发送一个请求，S端根据请求，返回一个响应。&lt;/p&gt;
&lt;p&gt;那么这里就有一个问题了--S端无法主动向C/B端发送消息。而交互是双方的事情，怎么能限定一方发数据，另一方接数据呢。&lt;/p&gt;
&lt;h3 id=&quot;传统解决方案&quot;&gt;传统解决方案：&lt;/h3&gt;
&lt;p&gt;传统的解决方案就俩字：轮询。&lt;/p&gt;
&lt;p&gt;长短连接轮询就不详细说了，就说说轮询。大概的场景是这样的：&lt;/p&gt;
&lt;p&gt;客户端（Request）：有消息不？&lt;/p&gt;
&lt;p&gt;服务端（Response）：No&lt;/p&gt;
&lt;p&gt;客户端（Request）：有消息不？&lt;/p&gt;
&lt;p&gt;服务端（Response）：No&lt;/p&gt;
&lt;p&gt;客户端（Request）：有消息不？&lt;/p&gt;
&lt;p&gt;服务端（Response）：No&lt;/p&gt;
&lt;p&gt;客户端（Request）：有消息不？&lt;/p&gt;
&lt;p&gt;服务端（Response）：有了。你妈叫你回家吃饭。&lt;/p&gt;
&lt;p&gt;客户端（Request）：有消息不？&lt;/p&gt;
&lt;p&gt;服务端（Response）：No&lt;/p&gt;
&lt;p&gt;==================================&amp;gt; loop&lt;/p&gt;
&lt;p&gt;看着都累，资源消耗那就更不必说了。尤其有些对实时性要求高的数据，那可能就是1s请求一次。目测服务器已经泪奔。&lt;/p&gt;
&lt;h3 id=&quot;websocket解决方案&quot;&gt;websocket解决方案：&lt;/h3&gt;
&lt;p&gt;那么websocket的解决方案，总结一下，就是：建立固定连接&lt;/p&gt;
&lt;p&gt;说白了，就是C/B端与S端就一个websocket服务建立一个固定的连接，不断开。&lt;/p&gt;
&lt;p&gt;大概的场景是这样的：&lt;/p&gt;
&lt;p&gt;服务端：我建立了一个chat的websocket，欢迎大家连接。&lt;/p&gt;
&lt;p&gt;客户端：我要和你的chat的websocket连接，我的sid（唯一标识）是No.1&lt;/p&gt;
&lt;p&gt;服务端：好的，我已经记住你了。如果有发往chat下No.1的消息，我会告诉你的。&lt;/p&gt;
&lt;p&gt;客户端：嗯。谢谢了哈。&lt;/p&gt;
&lt;p&gt;==================================&amp;gt; 过了一段时间&lt;/p&gt;
&lt;p&gt;（有一个请求调用了chat的websocket，并且指名是给No.1的消息）&lt;/p&gt;
&lt;p&gt;服务端（发送消息给No.1）：No.1，有你的消息。你妈妈叫你回家做作业。&lt;/p&gt;
&lt;p&gt;客户端（No.1）：好的。我收到了。谢谢。&lt;/p&gt;
&lt;p&gt;由于这次只是简单说一下websocket，所以就不深入解读网络相关知识了。&lt;/p&gt;
&lt;h2 id=&quot;应用场景&quot;&gt;应用场景&lt;/h2&gt;
&lt;p&gt;既然http无法满足用户的所有需求，那么为之诞生的websocket必然有其诸多应用场景。如：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;实时显示网站在线人数&lt;/li&gt;
&lt;li&gt;账户余额等数据的实时更新&lt;/li&gt;
&lt;li&gt;多玩家网络游戏&lt;/li&gt;
&lt;li&gt;多媒体聊天，如聊天室&lt;/li&gt;
&lt;li&gt;。。。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;其实总结一下，websocket的应用场景就俩字：实时&lt;/p&gt;
&lt;p&gt;无论是多玩家网络游戏，网站在线人数等都是由于实时性的需求，才用上了websocket（后面用缩写ws)。&lt;/p&gt;
&lt;p&gt;谈几个在我项目中用到的情景：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在线教育项目中的课件系统，通过ws实现学生端课件与教师端课件的实时交互&lt;/li&gt;
&lt;li&gt;物联网项目中的报警系统，通过ws实现报警信息的实时推送&lt;/li&gt;
&lt;li&gt;大数据项目中的数据展示，通过ws实现数据的实时更新&lt;/li&gt;
&lt;li&gt;物联网项目中的硬件交互系统，通过ws实现硬件异步响应的展示&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;当你的项目中存在需要S端向C/B端发送数据的情形，那就可以考虑上一个websocket了。&lt;/p&gt;
&lt;h2 id=&quot;实现&quot;&gt;实现&lt;/h2&gt;
&lt;h3 id=&quot;服务端开发&quot;&gt;服务端开发：&lt;/h3&gt;
&lt;h3 id=&quot;引入依赖&quot;&gt;引入依赖：&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
        &amp;lt;!-- websocket --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-websocket&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;添加配置&quot;&gt;添加配置：&lt;/h3&gt;
&lt;p&gt;忍不住想要吐槽，为什么不可以如eureka等组件那样，直接在启动类写一个注解就Ok了呢。看来还得以后自己动手，丰衣足食啊。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    
    package com.renewable.center.warning.configuration;
    
    import org.springframework.context.annotation.Bean;
    import org.springframework.context.annotation.Configuration;
    import org.springframework.web.socket.server.standard.ServerEndpointExporter;
    
    /**
     * Websocket的配置
     * 说白了就是引入Websocekt至spring容器
     */
    @Configuration
    public class WebSocketConfig {  
        
        @Bean
        public ServerEndpointExporter serverEndpointExporter() {  
            return new ServerEndpointExporter();
        }  
      
    } 
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;代码实现&quot;&gt;代码实现：&lt;/h3&gt;
&lt;h4 id=&quot;websocketserver的实现&quot;&gt;WebSocketServer的实现：&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    package com.renewable.center.warning.controller.websocket;
    
    import lombok.extern.slf4j.Slf4j;
    import org.apache.commons.lang3.StringUtils;
    import org.springframework.stereotype.Component;
    
    import javax.websocket.*;
    import javax.websocket.server.PathParam;
    import javax.websocket.server.ServerEndpoint;
    import java.io.IOException;
    import java.util.concurrent.CopyOnWriteArraySet;
    
    /**
     * @Description：
     * @Author: jarry
     */
    @Component
    @Slf4j
    @ServerEndpoint(&quot;/websocket/warning/{sid}&quot;)
    public class WarningWebSocketServer {
    
        // JUC包的线程安全Set，用来存放每个客户端对应的WarningWebSocketServer对象。
        // 用ConcurrentHashMap也是可以的。说白了就是类似线程池中的BlockingQueue那样作为一个容器
        private static CopyOnWriteArraySet&amp;lt;WarningWebSocketServer&amp;gt; warningWebSocketSet = new CopyOnWriteArraySet&amp;lt;WarningWebSocketServer&amp;gt;();
    
        // 与某个客户端的连接会话，需要通过它来给客户端发送数据
        private Session session;
    
        // 接收sid
        private String sid=&quot;&quot;;
    
        /**
         * 建立websocket连接
         * 看起来很像JSONP的回调，因为前端那里是Socket.onOpne()
         * @param session
         * @param sid
         */
        @OnOpen
        public void onOpen(Session session, @PathParam(&quot;sid&quot;) String sid){
            this.session = session;
            this.sid = sid;
            warningWebSocketSet.add(this);
    
            sendMessage(&quot;websocket connection has created.&quot;);
        }
    
        /**
         * 关闭websocket连接
         */
        @OnClose
        public void onClose(){
            warningWebSocketSet.remove(this);
            log.info(&quot;there is an wsConnect has close .&quot;);
        }
    
        /**
         * websocket连接出现问题时的处理
         */
        @OnError
        public void onError(Session session, Throwable error){
            log.error(&quot;there is an error has happen ! error:{}&quot;,error);
        }
    
        /**
         * websocket的server端用于接收消息的（目测是用于接收前端通过Socket.onMessage发送的消息）
         * @param message
         */
        @OnMessage
        public void onMessage(String message){
            log.info(&quot;webSocketServer has received a message:{} from {}&quot;, message, this.sid);
    
            // 调用消息处理方法（此时针对的WarningWebSocektServer对象，只是一个实例。这里进行消息的单发）
            // 目前这里还没有处理逻辑。故为了便于前端调试，这里直接返回消息
            this.sendMessage(message);
        }
    
        /**
         * 服务器主动推送消息的方法
         */
        public void sendMessage(String message){
            try {
                this.session.getBasicRemote().sendText(message);
            } catch (IOException e) {
                log.warn(&quot;there is an IOException:{}!&quot;,e.toString());
            }
        }
    
        public static void sendInfo(String sid, String message){
            for (WarningWebSocketServer warningWebSocketServerItem : warningWebSocketSet) {
                if (StringUtils.isBlank(sid)){
                    // 如果sid为空，即群发消息
                    warningWebSocketServerItem.sendMessage(message);
                    log.info(&quot;Mass messaging. the message({}) has sended to sid:{}.&quot;, message,warningWebSocketServerItem.sid);
                }
                if (StringUtils.isNotBlank(sid)){
                    if (warningWebSocketServerItem.sid.equals(sid)){
                        warningWebSocketServerItem.sendMessage(message);
                        log.info(&quot;single messaging. message({}) has sended to sid:{}.&quot;, message, warningWebSocketServerItem.sid);
                    }
                }
            }
        }
    
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;wesocketcontroller&quot;&gt;WesocketController&lt;/h4&gt;
&lt;p&gt;为了便于调试与展示效果，写一个控制层，用于推送消息&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    package com.renewable.center.warning.controller.websocket;
    
    import com.renewable.terminal.terminal.common.ServerResponse;
    import org.springframework.stereotype.Controller;
    import org.springframework.web.bind.annotation.GetMapping;
    import org.springframework.web.bind.annotation.RequestMapping;
    import org.springframework.web.bind.annotation.RequestParam;
    import org.springframework.web.bind.annotation.ResponseBody;
    
    import java.io.IOException;
    
    /**
     * @Description： 用于测试WebsocketServer
     * @Author: jarry
     */
    @Controller
    @RequestMapping(&quot;/websocket/test/&quot;)
    public class WarningWebsocketController {
    
        @GetMapping(&quot;link.do&quot;)
        @ResponseBody
        public ServerResponse link(@RequestParam(name = &quot;sid&quot;) int sid){
            return ServerResponse.createBySuccessMessage(&quot;link : &quot;+sid);
        }
    
        /**
         * 调用WarningWebsocketServer的消息推送方法，从而进行消息推送
         * @param sid 连接WarningWebsocketServer的前端的唯一标识。如果sid为空，即表示向所有连接WarningWebsocketServer的前端发送相关消息
         * @param message 需要发送的内容主体
         * @return
         */
        @ResponseBody
        @RequestMapping(&quot;push.do&quot;)
        public ServerResponse pushToWeb(@RequestParam(name = &quot;sid&quot;, defaultValue = &quot;&quot;) String sid, @RequestParam(name = &quot;message&quot;)  String message) {
            WarningWebSocketServer.sendInfo(sid, message);
            return ServerResponse.createBySuccessMessage(message+&quot;@&quot;+sid+&quot; has send to target.&quot;);
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;wesockettestindex&quot;&gt;WesocketTestIndex&lt;/h4&gt;
&lt;p&gt;这里建立了一个B端页面，用于与S端进行交互，演示。&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;    
    &amp;lt;!DOCTYPE html&amp;gt;
    &amp;lt;html lang=&quot;en&quot;&amp;gt;
    &amp;lt;head&amp;gt;
        &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
        &amp;lt;title&amp;gt;WebsocketTestIndex&amp;lt;/title&amp;gt;
    &amp;lt;/head&amp;gt;
    &amp;lt;body&amp;gt;
    
    &amp;lt;h1&amp;gt;Websocket Test&amp;lt;/h1&amp;gt;
    
    &amp;lt;/body&amp;gt;
    &amp;lt;/html&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;效果展示&quot;&gt;效果展示&lt;/h2&gt;
&lt;p&gt;再次强调，图片很大很清晰。如果看不清楚，请单独打开图片。&lt;/p&gt;
&lt;h3 id=&quot;b端网页初始化&quot;&gt;B端网页初始化：&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/987666/201908/987666-20190802145953358-1370483570.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;调用s端warningwebsocketcontroller下pushtoweb接口对sid2的b端发送消息&quot;&gt;调用S端WarningWebsocketController下pushToWeb()接口，对sid=2的B端发送消息：&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/987666/201908/987666-20190802150014281-562381172.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;b端网页接收到专门发给sid2的消息后的效果&quot;&gt;B端网页接收到专门发给sid=2的消息后的效果：&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/987666/201908/987666-20190802150025162-933625171.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;调用s端warningwebsocketcontroller下pushtoweb接口所有连接该websocket的b端群发消息&quot;&gt;调用S端WarningWebsocketController下pushToWeb()接口，所有连接该websocket的B端群发消息：&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/987666/201908/987666-20190802150038552-561933723.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;b端网页接收到群发消息后的效果&quot;&gt;B端网页接收到群发消息后的效果：&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/987666/201908/987666-20190802150054066-2143719372.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;s端接收到消息后的日志打印&quot;&gt;S端接收到消息后的日志打印：&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/987666/201908/987666-20190802150107378-674217175.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;s端在b端关闭连接后的日志打印&quot;&gt;S端在B端关闭连接后的日志打印：&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/987666/201908/987666-20190802150117968-1049675757.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;至此，websocket的应用就算入门了。至于实际的使用，其实就是服务端自己调用WebSocket的sendInfo接口。当然也可以自己扩展更为细致的逻辑，方法等。&lt;/p&gt;
&lt;p&gt;另外，需要注意的是，别忘了及时关闭webocket的连接。尤其在负载较大的情况下，更需要注意即使关闭不必要的连接。&lt;/p&gt;
&lt;p&gt;架构的技术选型，需要的不是最好的，而是最适合的。&lt;/p&gt;
&lt;h2 id=&quot;扩展&quot;&gt;扩展：&lt;/h2&gt;
&lt;p&gt;如果想要了解更多概念上的细节，可以看看这篇文章：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/guoqiang1/p/8296176.html&quot;&gt;websocket的理解&amp;amp;应用&amp;amp;场景&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 05 Aug 2019 00:28:00 +0000</pubDate>
<dc:creator>血夜之末</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Tiancheng-Duan/p/11288593.html</dc:identifier>
</item>
<item>
<title>WebRTC：一个视频聊天的简单例子 - 程序猿小卡</title>
<link>http://www.cnblogs.com/chyingp/p/example-of-video-chat-using-webrtc.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chyingp/p/example-of-video-chat-using-webrtc.html</guid>
<description>&lt;h2 id=&quot;相关api简介&quot;&gt;相关API简介&lt;/h2&gt;
&lt;p&gt;在前面的章节中，已经对WebRTC相关的重要知识点进行了介绍，包括涉及的网络协议、会话描述协议、如何进行网络穿透等，剩下的就是WebRTC的API了。&lt;/p&gt;
&lt;p&gt;WebRTC通信相关的API非常多，主要完成了如下功能：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;信令交换&lt;/li&gt;
&lt;li&gt;通信候选地址交换&lt;/li&gt;
&lt;li&gt;音视频采集&lt;/li&gt;
&lt;li&gt;音视频发送、接收&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;相关API太多，为避免篇幅过长，文中部分采用了伪代码进行讲解。详细代码参考文章末尾，也可以在&lt;a href=&quot;https://github.com/chyingp/blog/tree/master/demo/2019.08.02-video-talk-using-webrtc&quot;&gt;笔者的Github&lt;/a&gt;上找到，有问题欢迎留言交流。&lt;/p&gt;
&lt;h2 id=&quot;信令交换&quot;&gt;信令交换&lt;/h2&gt;
&lt;p&gt;信令交换是WebRTC通信中的关键环节，交换的信息包括编解码器、网络协议、候选地址等。对于如何进行信令交换，WebRTC并没有明确说明，而是交给应用自己来决定，比如可以采用WebSocket。&lt;/p&gt;
&lt;p&gt;发送方伪代码如下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const pc = new RTCPeerConnection(iceConfig);
const offer = await pc.createOffer();
await pc.setLocalDescription(offer);
sendToPeerViaSignalingServer(SIGNALING_OFFER, offer); // 发送方发送信令消息&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接收方伪代码如下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const pc = new RTCPeerConnection(iceConfig);
await pc.setRemoteDescription(offer);
const answer = await pc.createAnswer();
await pc.setLocalDescription(answer);
sendToPeerViaSignalingServer(SIGNALING_ANSWER, answer); // 接收方发送信令消息&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;候选地址交换服务&quot;&gt;候选地址交换服务&lt;/h2&gt;
&lt;p&gt;当本地设置了会话描述信息，并添加了媒体流的情况下，ICE框架就会开始收集候选地址。两边收集到候选地址后，需要交换候选地址，并从中知道合适的候选地址对。&lt;/p&gt;
&lt;p&gt;候选地址的交换，同样采用前面提到的信令服务，伪代码如下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// 设置本地会话描述信息
const localPeer = new RTCPeerConnection(iceConfig);
const offer = await pc.createOffer();
await localPeer.setLocalDescription(offer);

// 本地采集音视频
const localVideo = document.getElementById('local-video');
const mediaStream = await navigator.mediaDevices.getUserMedia({ 
    video: true, 
    audio: true
});
localVideo.srcObject = mediaStream;

// 添加音视频流
mediaStream.getTracks().forEach(track =&amp;gt; {
    localPeer.addTrack(track, mediaStream);
});

// 交换候选地址
localPeer.onicecandidate = function(evt) {
    if (evt.candidate) {
        sendToPeerViaSignalingServer(SIGNALING_CANDIDATE, evt.candidate);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;音视频采集&quot;&gt;音视频采集&lt;/h2&gt;
&lt;p&gt;可以使用浏览器提供的&lt;code&gt;getUserMedia&lt;/code&gt;接口，采集本地的音视频。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const localVideo = document.getElementById('local-video');
const mediaStream = await navigator.mediaDevices.getUserMedia({ 
    video: true, 
    audio: true
});
localVideo.srcObject = mediaStream;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;音视频发送接收&quot;&gt;音视频发送、接收&lt;/h2&gt;
&lt;p&gt;将采集到的音视频轨道，通过&lt;code&gt;addTrack&lt;/code&gt;进行添加，发送给远端。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;mediaStream.getTracks().forEach(track =&amp;gt; {
    localPeer.addTrack(track, mediaStream);
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;远端可以通过监听&lt;code&gt;ontrack&lt;/code&gt;来监听音视频的到达，并进行播放。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;remotePeer.ontrack = function(evt) {
    const remoteVideo = document.getElementById('remote-video');
    remoteVideo.srcObject = evt.streams[0];
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;完整代码&quot;&gt;完整代码&lt;/h2&gt;
&lt;p&gt;包含两部分：客户端代码、服务端代码。&lt;/p&gt;
&lt;p&gt;1、客户端代码&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const socket = io.connect('http://localhost:3000');

const CLIENT_RTC_EVENT = 'CLIENT_RTC_EVENT';
const SERVER_RTC_EVENT = 'SERVER_RTC_EVENT';

const CLIENT_USER_EVENT = 'CLIENT_USER_EVENT';
const SERVER_USER_EVENT = 'SERVER_USER_EVENT';

const CLIENT_USER_EVENT_LOGIN = 'CLIENT_USER_EVENT_LOGIN'; // 登录

const SERVER_USER_EVENT_UPDATE_USERS = 'SERVER_USER_EVENT_UPDATE_USERS';

const SIGNALING_OFFER = 'SIGNALING_OFFER';
const SIGNALING_ANSWER = 'SIGNALING_ANSWER';
const SIGNALING_CANDIDATE = 'SIGNALING_CANDIDATE';

let remoteUser = ''; // 远端用户
let localUser = ''; // 本地登录用户

function log(msg) {
    console.log(`[client] ${msg}`);
}

socket.on('connect', function() {
    log('ws connect.');
});

socket.on('connect_error', function() {
    log('ws connect_error.');
});

socket.on('error', function(errorMessage) {
    log('ws error, ' + errorMessage);
});

socket.on(SERVER_USER_EVENT, function(msg) {
    const type = msg.type;
    const payload = msg.payload;

    switch(type) {
        case SERVER_USER_EVENT_UPDATE_USERS:
            updateUserList(payload);
            break;
    }
    log(`[${SERVER_USER_EVENT}] [${type}], ${JSON.stringify(msg)}`);
});

socket.on(SERVER_RTC_EVENT, function(msg) {
    const {type} = msg;

    switch(type) {
        case SIGNALING_OFFER:
            handleReceiveOffer(msg);
            break;
        case SIGNALING_ANSWER:
            handleReceiveAnswer(msg);
            break;
        case SIGNALING_CANDIDATE:
            handleReceiveCandidate(msg);
            break;
    }
});

async function handleReceiveOffer(msg) {
    log(`receive remote description from ${msg.payload.from}`);
    
    // 设置远端描述
    const remoteDescription = new RTCSessionDescription(msg.payload.sdp);
    remoteUser = msg.payload.from;
    createPeerConnection();
    await pc.setRemoteDescription(remoteDescription); // TODO 错误处理

    // 本地音视频采集
    const localVideo = document.getElementById('local-video');
    const mediaStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
    localVideo.srcObject = mediaStream;
    mediaStream.getTracks().forEach(track =&amp;gt; {
        pc.addTrack(track, mediaStream);
        // pc.addTransceiver(track, {streams: [mediaStream]}); // 这个也可以
    });
    // pc.addStream(mediaStream); // 目前这个也可以，不过接口后续会废弃

    const answer = await pc.createAnswer(); // TODO 错误处理
    await pc.setLocalDescription(answer);
    sendRTCEvent({
        type: SIGNALING_ANSWER,
        payload: {
            sdp: answer,
            from: localUser,
            target: remoteUser
        }
    });
}

async function handleReceiveAnswer(msg) {
    log(`receive remote answer from ${msg.payload.from}`);
    
    const remoteDescription = new RTCSessionDescription(msg.payload.sdp);
    remoteUser = msg.payload.from;

    await pc.setRemoteDescription(remoteDescription); // TODO 错误处理
}

async function handleReceiveCandidate(msg){
    log(`receive candidate from ${msg.payload.from}`);
    await pc.addIceCandidate(msg.payload.candidate); // TODO 错误处理
}

/**
 * 发送用户相关消息给服务器
 * @param {Object} msg 格式如 { type: 'xx', payload: {} }
 */
function sendUserEvent(msg) {
    socket.emit(CLIENT_USER_EVENT, JSON.stringify(msg));
}

/**
 * 发送RTC相关消息给服务器
 * @param {Object} msg 格式如{ type: 'xx', payload: {} }
 */
function sendRTCEvent(msg) {
    socket.emit(CLIENT_RTC_EVENT, JSON.stringify(msg));
}

let pc = null;

/**
 * 邀请用户加入视频聊天
 *  1、本地启动视频采集
 *  2、交换信令
 */
async function startVideoTalk() {
    // 开启本地视频
    const localVideo = document.getElementById('local-video');
    const mediaStream = await navigator.mediaDevices.getUserMedia({
        video: true, 
        audio: true
    });
    localVideo.srcObject = mediaStream;

    // 创建 peerConnection
    createPeerConnection();

    // 将媒体流添加到webrtc的音视频收发器
    mediaStream.getTracks().forEach(track =&amp;gt; {
        pc.addTrack(track, mediaStream);
        // pc.addTransceiver(track, {streams: [mediaStream]});
    });
    // pc.addStream(mediaStream); // 目前这个也可以，不过接口后续会废弃
}

function createPeerConnection() {
    const iceConfig = {&quot;iceServers&quot;: [
        {url: 'stun:stun.ekiga.net'},
        {url: 'turn:turnserver.com', username: 'user', credential: 'pass'}
    ]};
    
    pc = new RTCPeerConnection(iceConfig);

    pc.onnegotiationneeded = onnegotiationneeded;
    pc.onicecandidate = onicecandidate;
    pc.onicegatheringstatechange = onicegatheringstatechange;
    pc.oniceconnectionstatechange = oniceconnectionstatechange;
    pc.onsignalingstatechange = onsignalingstatechange;
    pc.ontrack = ontrack;
    
    return pc;
}

async function onnegotiationneeded() {
    log(`onnegotiationneeded.`);

    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer); // TODO 错误处理

    sendRTCEvent({
        type: SIGNALING_OFFER,
        payload: {
            from: localUser,
            target: remoteUser,
            sdp: pc.localDescription // TODO 直接用offer？
        }
    });
}

function onicecandidate(evt) {
    if (evt.candidate) {
        log(`onicecandidate.`);

        sendRTCEvent({
            type: SIGNALING_CANDIDATE,            
            payload: {
                from: localUser,
                target: remoteUser,
                candidate: evt.candidate
            }
        });
    }
}

function onicegatheringstatechange(evt) {
    log(`onicegatheringstatechange, pc.iceGatheringState is ${pc.iceGatheringState}.`);
}

function oniceconnectionstatechange(evt) {
    log(`oniceconnectionstatechange, pc.iceConnectionState is ${pc.iceConnectionState}.`);
}

function onsignalingstatechange(evt) {
    log(`onsignalingstatechange, pc.signalingstate is ${pc.signalingstate}.`);
}

// 调用 pc.addTrack(track, mediaStream)，remote peer的 onTrack 会触发两次
// 实际上两次触发时，evt.streams[0] 指向同一个mediaStream引用
// 这个行为有点奇怪，github issue 也有提到 https://github.com/meetecho/janus-gateway/issues/1313
let stream;
function ontrack(evt) {
    // if (!stream) {
    //     stream = evt.streams[0];
    // } else {
    //     console.log(`${stream === evt.streams[0]}`); // 这里为true
    // }
    log(`ontrack.`);
    const remoteVideo = document.getElementById('remote-video');
    remoteVideo.srcObject = evt.streams[0];
}

// 点击用户列表
async function handleUserClick(evt) {
    const target = evt.target;
    const userName = target.getAttribute('data-name').trim();

    if (userName === localUser) {
        alert('不能跟自己进行视频会话');
        return;
    }

    log(`online user selected: ${userName}`);

    remoteUser = userName;
    await startVideoTalk(remoteUser);
}

/**
 * 更新用户列表
 * @param {Array} users 用户列表，比如 [{name: '小明', name: '小强'}]
 */
function updateUserList(users) {
    const fragment = document.createDocumentFragment();
    const userList = document.getElementById('login-users');
    userList.innerHTML = '';

    users.forEach(user =&amp;gt; {
        const li = document.createElement('li');
        li.innerHTML = user.userName;
        li.setAttribute('data-name', user.userName);
        li.addEventListener('click', handleUserClick);
        fragment.appendChild(li);
    });    
    
    userList.appendChild(fragment);
}

/**
 * 用户登录
 * @param {String} loginName 用户名
 */
function login(loginName) {
    localUser = loginName;
    sendUserEvent({
        type: CLIENT_USER_EVENT_LOGIN,
        payload: {
            loginName: loginName
        }
    });
}

// 处理登录
function handleLogin(evt) {
    let loginName = document.getElementById('login-name').value.trim();
    if (loginName === '') {
        alert('用户名为空！');
        return;
    }
    login(loginName);
}

function init() {
    document.getElementById('login-btn').addEventListener('click', handleLogin);
}

init();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、服务端代码&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// 添加ws服务
const io = require('socket.io')(server);
let connectionList = [];

const CLIENT_RTC_EVENT = 'CLIENT_RTC_EVENT';
const SERVER_RTC_EVENT = 'SERVER_RTC_EVENT';

const CLIENT_USER_EVENT = 'CLIENT_USER_EVENT';
const SERVER_USER_EVENT = 'SERVER_USER_EVENT';

const CLIENT_USER_EVENT_LOGIN = 'CLIENT_USER_EVENT_LOGIN';
const SERVER_USER_EVENT_UPDATE_USERS = 'SERVER_USER_EVENT_UPDATE_USERS';

function getOnlineUser() {
  return connectionList
  .filter(item =&amp;gt; {
    return item.userName !== '';
  })
  .map(item =&amp;gt; {
    return {
      userName: item.userName
    };
  });
}

function setUserName(connection, userName) {
  connectionList.forEach(item =&amp;gt; {
    if (item.connection.id === connection.id) {
      item.userName = userName;
    }
  });
}

function updateUsers(connection) {
  connection.emit(SERVER_USER_EVENT, { type: SERVER_USER_EVENT_UPDATE_USERS, payload: getOnlineUser()});  
}

io.on('connection', function (connection) {

  connectionList.push({
    connection: connection,
    userName: ''
  });
  
  // 连接上的用户，推送在线用户列表
  // connection.emit(SERVER_USER_EVENT, { type: SERVER_USER_EVENT_UPDATE_USERS, payload: getOnlineUser()});
  updateUsers(connection);

  connection.on(CLIENT_USER_EVENT, function(jsonString) {
    const msg = JSON.parse(jsonString);
    const {type, payload} = msg;

    if (type === CLIENT_USER_EVENT_LOGIN) {
      setUserName(connection, payload.loginName);
      connectionList.forEach(item =&amp;gt; {
        // item.connection.emit(SERVER_USER_EVENT, { type: SERVER_USER_EVENT_UPDATE_USERS, payload: getOnlineUser()});
        updateUsers(item.connection);
      });
    }
  });

  connection.on(CLIENT_RTC_EVENT, function(jsonString) {
    const msg = JSON.parse(jsonString);
    const {payload} = msg;
    const target = payload.target;

    const targetConn = connectionList.find(item =&amp;gt; {
      return item.userName === target;
    });
    if (targetConn) {
      targetConn.connection.emit(SERVER_RTC_EVENT, msg);
    }
  });

  connection.on('disconnect', function () {
    connectionList = connectionList.filter(item =&amp;gt; {
      return item.connection.id !== connection.id;
    });
    connectionList.forEach(item =&amp;gt; {
      // item.connection.emit(SERVER_USER_EVENT, { type: SERVER_USER_EVENT_UPDATE_USERS, payload: getOnlineUser()});
      updateUsers(item.connection);
    });    
  });
});&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;写在后面&quot;&gt;写在后面&lt;/h2&gt;
&lt;p&gt;WebRTC的API非常多，因为WebRTC本身就比较复杂，随着时间的推移，WebRTC的某些API(包括某些协议细节)也在改动或被废弃，这其中也有向后兼容带来的复杂性，比如本地视频采集后加入传输流，可以采用 addStream 或 addTrack 或 addTransceiver，再比如会话描述版本从plan-b迁移到unified-plan。&lt;/p&gt;
&lt;p&gt;建议亲自动手撸一遍代码，加深了解。&lt;/p&gt;
&lt;h2 id=&quot;相关链接&quot;&gt;相关链接&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chyingp/blog/tree/master/demo/2019.08.02-video-talk-using-webrtc&quot;&gt;2019.08.02-video-talk-using-webrtc&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection&quot; class=&quot;uri&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/meetecho/janus-gateway/issues/1313&quot;&gt;onremotestream called twice for each remote stream&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 05 Aug 2019 00:20:00 +0000</pubDate>
<dc:creator>程序猿小卡</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chyingp/p/example-of-video-chat-using-webrtc.html</dc:identifier>
</item>
<item>
<title>ansible批量管理服务 下 - 昨夜、星辰</title>
<link>http://www.cnblogs.com/basa/p/11300911.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/basa/p/11300911.html</guid>
<description>&lt;h2 id=&quot;剧本文件概念&quot;&gt;1.1 剧本文件概念&lt;/h2&gt;
&lt;p&gt;（1）playbook可以将多个批量操作模块功能整合，完成一件事情。&lt;br/&gt;（2）简化运维工作复杂度&lt;br/&gt;（3）playbook通过yaml语法识别描述的状态文件，扩展名是yaml&lt;br/&gt;&lt;/p&gt;
&lt;h2 id=&quot;剧本文件组成部分&quot;&gt;1.2 剧本文件组成部分&lt;/h2&gt;
&lt;p&gt;（1）剧本的角色（hosts）定义的是主机信息&lt;br/&gt;（2）剧本的任务（tasks）定义的是具体任务信息&lt;br/&gt;（3）一个剧本文件有多个hosts组成，一个hosts可以包含多个tasks任务&lt;br/&gt;&lt;/p&gt;
&lt;h2 id=&quot;剧本文件优势特点&quot;&gt;1.3 剧本文件优势特点&lt;/h2&gt;
&lt;p&gt;（1）实现自动化功能更加全面&lt;br/&gt;（2）可以更好的控制逻辑关系&lt;br/&gt;（3）剧本展现命令语法更直观&lt;br/&gt;（4）拥有持久反复执行的特性&lt;br/&gt;&lt;/p&gt;
&lt;h2 id=&quot;剧本文件编写规范&quot;&gt;1.4 剧本文件编写规范&lt;/h2&gt;
&lt;p&gt;（1）缩进特点:  两个空格表示一个缩进关系&lt;br/&gt;（2）冒号用法:  冒号后面需要有空格  冒号结尾不需要有空格&lt;br/&gt;主机信息: 172.16.1.41   --- key: value (键值写法)&lt;br/&gt;（3）列表用法:  利用短横线加空格构建列表清单&lt;br/&gt;&lt;/p&gt;
&lt;h2 id=&quot;剧本执行使用方法&quot;&gt;1.5 剧本执行使用方法&lt;/h2&gt;
&lt;p&gt;（1）检查剧本语法：ansible-playbook --syntax-check test.yaml&lt;br/&gt;（2）剧本模拟执行：ansible-playbook -C test.yaml&lt;br/&gt;（3）剧本真实运行：ansible-playbook  test.yaml&lt;br/&gt;&lt;/p&gt;
&lt;h2 id=&quot;剧本编写扩展功能&quot;&gt;1.6 剧本编写扩展功能&lt;/h2&gt;
&lt;p&gt;（1）剧本变量编写功能&lt;br/&gt;（2）剧本信息通知功能&lt;br/&gt;（3）剧本信息判断功能&lt;br/&gt;（4）剧本信息循环功能&lt;br/&gt;（5）剧本编写忽略错误&lt;br/&gt;（6）剧本标签设置功能&lt;br/&gt;（7）剧本忽略采集功能&lt;br/&gt;（8）剧本信息触发功能&lt;br/&gt;&lt;/p&gt;
&lt;h3 id=&quot;剧本变量编写功能&quot;&gt;1.6.1 剧本变量编写功能&lt;/h3&gt;
&lt;p&gt;设置变量方法一: 在剧本执行命令参数中设置变量，命令行最优先&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@m01 ansible_playbook]#ansible-playbook -e dir=/etc -e file=rsyncd.conf test_变量编写.yaml&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;设置变量方法二: 在剧本中设置变量，剧本变量其次优先&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@m01 ansible_playbook]#vim test_变量编写.yaml 
- hosts: 172.16.1.41
  vars:
    dir: /etc
    file: rsyncd.conf
  tasks:
   - name: copy file 
     copy: src={{ dir }}/{{ file }} dest={{ dir }}/
# {{}}调用变量&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;设置变量方法二: 在主机清单中设置变量，主机清单变量最不优先&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@m01 ansible_playbook]#vim /etc/ansible/hosts
[sersync_server]
172.16.1.31
[sersync_client]
172.16.1.41
[sersync_server:vars]
dir=/etc
file=rsyncd.conf
# 直接给主机组设置变量，这样主机组内的所有主机都可以调用变量了&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;剧本信息通知功能&quot;&gt;1.6.2 剧本信息通知功能&lt;/h3&gt;
&lt;p&gt;编辑剧本&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@m01 ansible_playbook]#vim test_通知功能.yaml
- hosts: 172.16.1.41
  tasks:
    - name: boot server
      service: name=rsyncd state=started
    - name: check server boot
      shell: netstat -lntup|grep 873
      register: oldboy
    - debug: msg={{ oldboy.stdout_lines }}
# 将shell中命令执行结果通过register注册给oldboy，oldboy相当于一个变量，{{}}调取oldboy
# debug类似echo，输出信息
# stdout_lines 将输出的信息变得有格式&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行剧本&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@m01 ansible_playbook]#ansible-playbook test_通知功能.yaml 

PLAY [172.16.1.41] ***********************************************************************************

TASK [Gathering Facts] *******************************************************************************
ok: [172.16.1.41]

TASK [boot server] ***********************************************************************************
ok: [172.16.1.41]

TASK [check server boot] *****************************************************************************
changed: [172.16.1.41]

TASK [debug] *****************************************************************************************
ok: [172.16.1.41] =&amp;gt; {
    &quot;msg&quot;: [
        &quot;tcp        0      0 0.0.0.0:873             0.0.0.0:*               LISTEN      3708/rsync          &quot;, 
        &quot;tcp6       0      0 :::873                  :::*                    LISTEN      3708/rsync          &quot;
    ]
}

PLAY RECAP *******************************************************************************************
172.16.1.41                : ok=4    changed=1    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0  &lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;剧本信息判断功能&quot;&gt;1.6.3 剧本信息判断功能&lt;/h3&gt;
&lt;p&gt;nfs服务客户端三台主机&lt;br/&gt;centos7  10.0.0.7、centos6  10.0.0.8、centos7  10.0.0.9&lt;br/&gt;此时在批量启动的时候需要进行判断，因为centos6，centos7启动命令不一样&lt;br/&gt;判断的格式&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;- hosts: nfs_client
tasks:
- name: boot centos7 nfs
shell: systemctl start nfs 
判断: 如果是centos7 ???
- name: boot centos6 nfs 
shell: /etc/init.d/nfs start    
判断: 如果是centos6 ???&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;setup模块：收集远程主机信息&lt;/strong&gt;&lt;br/&gt;语法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@m01 ansible_playbook]#ansible 172.16.1.41 -m setup -a &quot;filter=ansible_hostname&quot;
172.16.1.41 | SUCCESS =&amp;gt; {
    &quot;ansible_facts&quot;: {
        &quot;ansible_hostname&quot;: &quot;backup&quot;, 
        &quot;discovered_interpreter_python&quot;: &quot;/usr/bin/python&quot;
    }, 
    &quot;changed&quot;: false
}

# filter 过滤 筛选&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实现收集子信息的方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;问题: 获取主机信息,以及子信息
方法一:
- hosts: rsync
  tasks:
    - name: touch file
      file: path=/etc/oldboy01.txt state=touch
      when: (ansible_eth1.ipv4.address == &quot;172.16.1.41&quot;)
方法二:
- hosts: rsync
  tasks:
    - name: touch file
      file: path=/etc/oldboy01.txt state=touch
      when: (ansible_eth1[&quot;ipv4&quot;][&quot;address&quot;] == &quot;172.16.1.41&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;setup模块常用来收集的信息&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2019/png/391345/1564309749744-4256f770-9449-4e42-840a-b6f9e3dfac45.png#align=left&amp;amp;display=inline&amp;amp;height=403&amp;amp;name=image.png&amp;amp;originHeight=403&amp;amp;originWidth=887&amp;amp;size=83638&amp;amp;status=done&amp;amp;width=887&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;根据 ip 地址进行判断创建目录&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@m01 ansible_playbook]#vim test_判断功能.yaml
- hosts: nfs_client
  tasks:
    - name: create file for 41 host
      file: path=/tmp/172.16.1.41 state=directory
      when: (ansible_hostname == &quot;backup&quot;)
    - name: create file for 7 host
      file: path=/tmp/172.16.1.7  state=directory
      when: (ansible_hostname == &quot;web01&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行剧本&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;root@m01 ansible_playbook]#ansible-playbook -C test_判断功能.yaml 

PLAY [nfs_client] ************************************************************************************

TASK [Gathering Facts] *******************************************************************************
ok: [172.16.1.41]
ok: [172.16.1.7]

TASK [create file for 41 host] ***********************************************************************
skipping: [172.16.1.7]
changed: [172.16.1.41]

TASK [create file for 7 host] ************************************************************************
skipping: [172.16.1.41]
changed: [172.16.1.7]

PLAY RECAP *******************************************************************************************
172.16.1.41                : ok=2    changed=1    unreachable=0    failed=0    skipped=1    rescued=0    ignored=0   
172.16.1.7                 : ok=2    changed=1    unreachable=0    failed=0    skipped=1    rescued=0    ignored=0   &lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;剧本信息循环功能&quot;&gt;1.6.4 剧本信息循环功能&lt;/h3&gt;
&lt;p&gt;循环创建多个用户&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@m01 ansible_playbook]#vim test_循环功能.yaml
- hosts: 172.16.1.41
  tasks:
    - name: create user
      user: name={{ item }}
      with_items:
        - oldgirl01
        - oldgirl02
        - oldgirl03
        - oldgirl04
        - oldgirl05&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;循环创建多个用户  多个用户uid数值是不同的&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@m01 ansible_playbook]#vim test_循环功能.yaml
- hosts: 172.16.1.41
  tasks:
    - name: create user
      user: name={{ item.name }} uid={{ item.uid }}
      with_items:
        - {name: &quot;oldgirl06&quot;, uid: &quot;3006&quot;}
        - {name: &quot;oldgirl07&quot;, uid: &quot;3007&quot;}
        - {name: &quot;oldgirl08&quot;, uid: &quot;3008&quot;}
        - {name: &quot;oldgirl09&quot;, uid: &quot;3009&quot;}
        - name: check create user info
          shell: grep oldgirl0 /etc/passwd
          register: user_info
        - debug: msg={{ user_info.stdout_lines }}&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;剧本编写忽略错误功能&quot;&gt;1.6.5 剧本编写忽略错误功能&lt;/h3&gt;
&lt;p&gt;忽略功能主要用来调试剧本&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@m01 ansible_playbook]#vim test_h忽略功能.yaml
- hosts: 172.16.1.41
  tasks:
    - name: create rsync user
      shell: useradd rsync -M -s /sbin/nologin
      ignore_errors: yes
    - name: create backup dir
      shell: mkdir /backup
      ignore_errors: yes
    - name: boot server
      shell: systemctl start rsyncd
      ignore_errors: yes&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在使用shell进行一些操作时，shell产生的结果已经存在时，会导致剧本无法进行下去，因此使用忽略功能可以有效的使剧本进行下去。&lt;br/&gt;&lt;/p&gt;
&lt;h3 id=&quot;剧本标签设置功能&quot;&gt;1.6.6 剧本标签设置功能&lt;/h3&gt;
&lt;p&gt;标签功能主要用来调试剧本&lt;br/&gt;tags：标签&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@m01 ansible_playbook]#vim test_标签功能.yaml
- hosts: 172.16.1.41
  tasks:
    - name: 01:安装软件
      yum: name=rsync state=installed
      ignore_errors: yes
    - name: 02:创建用户
      user: name=rsync create_home=no shell=/sbin/nologin
      ignore_errors: yes
      tags: create_user
    - name: 03:创建目录
      file: path=/backup state=directory&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行剧本&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ansible-playbook -t create_user test_标签功能.yaml             --- 执行剧本中标签任务
ansible-playbook --skip-tags create_user test_标签功能.yaml    --- 跳过指定标签任务,执行其他任务
ansible-playbook -t create_user,create_dir test_标签功能.yaml  --- 执行多个标签
# -t=tags&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;剧本忽略采集功能&quot;&gt;1.6.7 剧本忽略采集功能&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;[root@m01 ansible_playbook]#vim test_忽略采集.yaml
- hosts: 172.16.1.41
  gather_facts: no
  tasks:
    - name: 01:安装软件
      yum: name=rsync state=installed
      ignore_errors: yes
    - name: 02:创建用户
      user: name=rsync create_home=no shell=/sbin/nologin
      ignore_errors: yes
      tags: create_user
    - name: 03:创建目录
      file: path=/backup state=directory
      tags: create_dir  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当剧本采集大量主机信息时，可能会变得卡，慢，影响剧本后面的操作执行的效率。所以在这个时候，可以忽略采集功能，提高效率，在hosts下面添加 gather_facts: no&lt;br/&gt;如果剧本中有判断功能,不能使用此参数，因为采集的信息会与判读信息对比&lt;br/&gt;&lt;/p&gt;
&lt;h3 id=&quot;剧本信息触发功能&quot;&gt;1.6.8 剧本信息触发功能&lt;/h3&gt;
&lt;p&gt;编写剧本&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@m01 ansible_playbook]#vim test_触发功能.yaml
- hosts: 172.16.1.41
  tasks:
    - name: 01:传输配置文件
      copy: src=/etc/ansible/ansible_playbook/rsyncd.conf dest=/etc/
      notify: rsync_restart
    - name: 02:启动服务程序
      service: name=rsyncd state=started
  handlers:
    - name: rsync_restart
      service: name=rsyncd state=restarted&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;handlers：一般用于配置文件修改时，才会进行触发功能，对服务进行重启&lt;br/&gt;notify：传输配置文件过来，notify通知rsync_restart这个触发器。然后handlers会进行重启服务&lt;br/&gt;说明: 整体任务执行完毕,才会执行触发功能&lt;br/&gt;&lt;/p&gt;
&lt;h2 id=&quot;编写剧本练习题&quot;&gt;1.7 编写剧本练习题&lt;/h2&gt;
&lt;p&gt;要求：&lt;br/&gt;（1）在172.16.1.41主机上操作:&lt;br/&gt;       ①将定时任务服务停止&lt;br/&gt;       ②创建一个/etc/目录软连接 在/opt目录中生成  &lt;br/&gt;       ③将本地/etc/hosts文件分发给41主机 保存到/tmp目录中&lt;br/&gt;（2）在172.16.1.31主机上操作:&lt;br/&gt;       ①将防火墙服务开机自动运行&lt;br/&gt;       ②将主机上安装keepalived软件&lt;br/&gt;实践：&lt;br/&gt;&lt;strong&gt;编写剧本文件&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@m01 ansible_playbook]#vim test.yaml 
- hosts: 172.16.1.41
  tasks:
    - service: name=crond state=stopped
    - file: src=/etc path=/opt/etc_link state=link
    - copy: src=/etc/hosts dest=/tmp
- hosts: 172.16.1.31
  tasks:
    - service: name=firewalld enabled=yes
    - yum: name=keepalived state=installed&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;剧本语法检查&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 语法检查剧本文件
[root@m01 ansible_playbook]#ansible-playbook --syntax-check test.yaml 

playbook: test.yaml&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;剧本模拟执行&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@m01 ansible_playbook]#ansible-playbook -C test.yaml

PLAY [172.16.1.41] ***********************************************************************************

TASK [Gathering Facts] *******************************************************************************
ok: [172.16.1.41]

TASK [service] ***************************************************************************************
ok: [172.16.1.41]

TASK [file] ******************************************************************************************
ok: [172.16.1.41]

TASK [copy] ******************************************************************************************
ok: [172.16.1.41]

PLAY [172.16.1.31] ***********************************************************************************

TASK [Gathering Facts] *******************************************************************************
ok: [172.16.1.31]

TASK [service] ***************************************************************************************
ok: [172.16.1.31]

TASK [yum] *******************************************************************************************
ok: [172.16.1.31]

PLAY RECAP *******************************************************************************************
172.16.1.31                : ok=3    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0   
172.16.1.41                : ok=4    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0   &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;剧本真实执行&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@m01 ansible_playbook]#ansible-playbook test.yaml

PLAY [172.16.1.41] ***********************************************************************************

TASK [Gathering Facts] *******************************************************************************
ok: [172.16.1.41]

TASK [service] ***************************************************************************************
ok: [172.16.1.41]

TASK [file] ******************************************************************************************
ok: [172.16.1.41]

TASK [copy] ******************************************************************************************
ok: [172.16.1.41]

PLAY [172.16.1.31] ***********************************************************************************

TASK [Gathering Facts] *******************************************************************************
ok: [172.16.1.31]

TASK [service] ***************************************************************************************
ok: [172.16.1.31]

TASK [yum] *******************************************************************************************
ok: [172.16.1.31]

PLAY RECAP *******************************************************************************************
172.16.1.31                : ok=3    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0   
172.16.1.41                : ok=4    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0   &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;补充：&lt;br/&gt;如果系统中装有cowsay软件，在执行命令时，会产生图案信息，影响查阅结果，可以关闭。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@m01 ansible]#vim ansible.cfg 
# don't like cows?  that's unfortunate.
# set to 1 if you don't want cowsay support or export ANSIBLE_NOCOWS=1
# nocows = 1
把# nocows = 1 中的 # 去掉即可。&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;ansible剧本实现rsync一键化部署&quot;&gt;1.8 ansible剧本实现rsync一键化部署&lt;/h2&gt;
&lt;p&gt;第一个历程: 按照模块方式,完成服务每个步骤部署&lt;br/&gt;第一步：服务端配置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 安装软件程序
ansible rsync -m yum -a &quot;name=rsync state=installed&quot;
# 编写配置文件：要在批量管理主机上提前写好，然后推送给服务端
# 在管理端准备好服务配置文件
ansible rsync_server -m copy -a &quot;src=/etc/ansible/conf_file/rsyncd.conf dest=/etc/&quot;
# 创建虚拟用户
ansible rsync_server -m user -a &quot;name=rsync create_home=no shell=/sbin/nologin&quot;
# 创建密码文件 (授权600)
ansible rsync_server -m copy -a &quot;content='rsync_backup:oldboy123' dest=/etc/rsync.password mode=600&quot;
# 创建备份目录 (授权 属主 属组)
ansible rsync_server -m file -a &quot;path=/backup state=directory owner=rsync group=rsync&quot;
@ 启动程序服务
ansible rsync_server -m service -a &quot;name=rsyncd state=started enabled=yes&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二步：客户端配置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 创建密钥文件 (授权600)
ansible rsync_client -m copy -a &quot;content='oldboy123' dest=/etc/rsync.password mode=600&quot;
# 批量测试传输文件
ansible rsync_client -m shell -a &quot;rsync -avz /etc/hosts rsync_backup@172.16.1.41::backup --password-file=/etc/rsync.password&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二个历程: 编写剧本信息&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@m01 ansible_playbook]#vim rsync_auto.yaml 
- hosts: rsync_server
  tasks:
    - name: 01:install rsync
      yum: name=rsync state=installed
    - name: 02:copy conf file
      copy: src=/etc/ansible/conf_file/rsyncd.conf dest=/etc/
    - name: 03:create rsync user
      user: name=rsync create_home=no shell=/sbin/nologin
    - name: 04:create password file
      copy: content='rsync_backup:oldboy123' dest=/etc/rsync.password mode=600
    - name: 05:create backup dir
      file: path=/backup state=directory owner=rsync group=rsync
    - name: 06:boot rsync server
      service: name=rsyncd state=started enabled=yes

- hosts: rsync_client
  tasks:
    - name: 01:create password file
      copy: content='oldboy123' dest=/etc/rsync.password mode=600&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;恢复环境剧本&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@m01 ansible_playbook]#vim rsync_backup.yaml 
- hosts: rsync_server
  tasks:
    - name: 01:delete conf file
      file: path=/etc/rsyncd.conf state=absent
    - name: 02:delete rsync user
      user: name=rsync state=absent 
    - name: 03:delete password file
      file: path=/etc/rsync.password state=absent
    - name: 04:delete backup dir
      file: path=/backup/ state=absent
    - name: 05:boot rsync server
      service: name=rsyncd state=stopped enabled=no

- hosts: rsync_client
  tasks:
    - name: 01:delete password file
      file: path=/etc/rsync.password state=absent&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;ansible剧本实现nfs一键化部署&quot;&gt;1.9 ansible剧本实现nfs一键化部署&lt;/h2&gt;
&lt;p&gt; 第一个历程: 按照模块方式,完成服务每个步骤部署&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;服务端配置 
01. 安装部署软件程序: rpcbind nfs-utile
ansible nfs_server -m yum -a &quot;name=rpcbind state=installed&quot;
ansible nfs_server -m yum -a &quot;name=nfs-utile state=installed&quot;
02. 编写配置文件:配置文件要提前写好
# 批量管理主机写好的配置文件推送给服务端/etc/ansible-playbook/nfs.conf 
ansible nfs_server -m copy -a &quot;src=/etc/ansible/ansible_playbook/nfs.conf  dest=/etc/exports&quot;
03. 创建共享目录:
ansible nfs_server -m file -a &quot;path=/data/ state=directory owner=nfsnobody group=nfsnobody&quot;
04. 启动程序服务:
ansible nfs_server -m service -a &quot;name=rpcbind state=started enabled=yes&quot;
ansible nfs_server -m service -a &quot;name=nfs state=started enabled=yes&quot;
    
客户端配置:
01. 安装部署软件 
ansible nfs_client -m yum -a &quot;name=nfs-utile state=installed&quot;
02. 挂载共享目录
ansible nfs_client -m mount -a &quot;src=172.16.1.31:/data/ path=/mnt fstype=nfs state=mounted&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二个历程编写剧本：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@m01 ansible_playbook]#vim nfs_auto.yaml 
- hosts: nfs_server
  tasks:
    - name: 1:install rpcbind nsf-utils
      yum:
        name:
          - rpcbind
          - nfs-utils
        state: installed
    - name: 2:copy conf file
      copy: src=/etc/ansible/ansible_playbook/nfs.conf dest=/etc/exports
    - name: 3:create data dir
      file: path=/data/ state=directory owner=nfsnobody group=nfsnobody
    - name: 4:boot server rcbind
      service: name=rpcbind state=started enabled=yes
    - name: 4:boot server nfs
      service: name=nfs state=restarted enabled=yes
- hosts: nfs_client
  tasks:
    - name: 1:install nfs
      yum: name=nfs-utils state=installed
    - name: 2:mount data dir
      mount: src=172.16.1.31:/data/ path=/mnt fstype=nfs state=mounted&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;恢复环境剧本&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@m01 ansible_playbook]#vim nfs_backup.yaml 
- hosts: nfs_server 
  tasks:
    - name: 01:install rpcbind nfs-utils
      yum:
        name:
          - rpcbind
          - nfs-utils
        state: removed
    - name: 02:copy conf file
      shell: echo &quot;&quot;  &amp;gt;/etc/exports
    - name: 03:create data dir
      file: path=/data/ state=absent
- hosts: nfs_client
  tasks:
    - name: 01:install nfs
      yum: name=nfs-utils state=removed
    - name: 02:mount data dir
      mount: src=172.16.1.31:/data/ path=/mnt fstype=nfs state=unmounted&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;优化剧本：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@m01 ansible_playbook]#vim nfs_auto.yaml 
- hosts: nfs_server
  vars:
    conf_file: exports
    data_dir: /data
  tasks:
    - name: 01:install nfs rpcbind
      yum:
        name: ['nfs-utils', 'rpcbind'] 
        state: installed
    - name: 02:copy conf file
      copy: src=/etc/ansible/ansible_playbook/nfs.conf  dest=/etc/{{ conf_file }}
      notify: 
        - nfs_restart
    - name: 03:create data dir
      file: path={{ data_dir }} state=directory owner=nfsnobody group=nfsnobody
    - name: 04:boot server rpcbind
      service: name={{ item.name }} state={{ item.state }} enabled={{ item.enabled }}
      with_items:
        - {name: &quot;rpcbind&quot;, state: &quot;started&quot;, enabled: &quot;yes&quot;}
        - {name: &quot;nfs&quot;,     state: &quot;started&quot;, enabled: &quot;yes&quot;}
  handlers:
    - name: nfs_restart
      service: name=nfs state=reloaded
- hosts: nfs_client
  vars:
    data_dir: /data
  tasks:
    - name: 01:install nfs
      yum: name=nfs-utils state=installed
    - name: 02:mount data dir
      mount: src=172.16.1.31:{{ data_dir }} path=/mnt fstype=nfs state=mounted
    - name: 03:check mount info
      shell: df -h|grep mnt
      register: mount_info
    - debug: msg={{ mount_info.stdout_lines }}&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;ansible剧本实现sersync一键化部署&quot;&gt;1.10 ansible剧本实现sersync一键化部署&lt;/h2&gt;
&lt;p&gt; 第一个历程: 按照模块方式,完成服务每个步骤部署&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;配置hosts主机清单
[server_server]
172.16.1.31
[server_client]
172.16.1.41

#安装rsync
ansible backup_server -m yum -a &quot;name=rsync state=installed&quot;
#在批量管理主机上下载sersync，解压发送给客户端
ansible backup_server -m file -a &quot;src=/usr/local/sersync_installdir_64bit/sersync dest=/usr/local&quot;
#在批量管理主机上写好sersync配置文件，发送给客户端
ansible backup_server -m copy -a &quot;src=/usr/local/sersync_installdir_64bit/sersync/conf/confxml.xml dest=/usr/local/sersync/conf/&quot;
#给sersync加上执行权限
ansible backup_server -m file -a &quot;path=/usr/local/sersync/bin/sersync mode=a+x&quot;
#给sersync创建软链接
ansible backup_server -m file -a &quot;src=/usr/local/sersync/bin/sersync path=/usr/local/sbin/sersync state=link&quot;
#启动sersync 测试实时同步
ansible backup_server -m shell -a &quot;sersync -dro /usr/local/sersync/conf/confxml.xml&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二个历程，编写剧本&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@m01 ansible_playbook]#vim sersync_auto.yaml 
- hosts: sersync_server
  tasks:
    - name: 安装rsync
      yum: name=rsync state=installed
    - name: 将sersync传输到客户端
      file: src=/usr/local/sersync_installdir_64bit/sersync/ dest=/usr/local
    - name: 将写好的配置文件传输到客户端
      copy: src=/usr/local/sersync_installdir_64bit/sersync/conf/confxml.xml dest=/usr/local/sersync/conf/
    - name: 加上执行权限
      file: path=/usr/local/sersync/bin/sersync mode=a+x
    - name: 创建软链接
      file: src=/usr/local/sersync/bin/sersync path=/usr/local/sbin/sersync state=link
    - name: 启动sersync 测试实时同步
      shell: sersync -dro /usr/local/sersync/conf/confxml.xml&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;恢复环境剧本&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@m01 ansible_playbook]#cat sersync_backup.yaml
- hosts: sersync_server
  tasks:
    - name: 卸载rsync 
      yum: name=rsync state=removed
    - name: 删除sersync
      file: path=/usr/local/sersync&lt;/code&gt;
&lt;/pre&gt;


&lt;p&gt;第一个历程: 确保每个剧本执行成功&lt;br/&gt;第二个历程: 进行剧本整合&lt;br/&gt;方法一：不建议使用&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@m01 ansible_playbook]#vim zhenghe.yaml  # ---角色里使用
- hosts: all
  remote_user: root
  tasks:
    - include_tasks: nfs_auto.yml
    - include_tasks: rsync_auto.yml
# 不写hosts信息，只写任务信息&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;方法二：在以后的ansible中可能会取消include功能&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@m01 ansible_playbook]#vim zhenghe.yaml 
- include：nfs_auto.yml  
- include：rsync_auto.yml&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;方法三：建议使用这个方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@m01 ansible_playbook]#vim zhenghe.yaml 
- import_playbook: nfs_auto.yaml     
- import_playbook: rsync_auto.yaml &lt;/code&gt;
&lt;/pre&gt;


&lt;p&gt;（1）规范ansible程序目录结构&lt;br/&gt;（2）汇总剧本中有定义的主机信息&lt;br/&gt;&lt;/p&gt;
&lt;h2 id=&quot;角色调用流程图&quot;&gt;3.1 角色调用流程图&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2019/png/391345/1564398271668-be564a44-9e4e-4cfa-b8f1-129ecc4e285b.png#align=left&amp;amp;display=inline&amp;amp;height=1201&amp;amp;name=%E8%A7%92%E8%89%B2.png&amp;amp;originHeight=1201&amp;amp;originWidth=1123&amp;amp;size=115138&amp;amp;status=done&amp;amp;width=1123&quot; alt=&quot;角色.png&quot;/&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id=&quot;nfs服务角色编写&quot;&gt;3.2 nfs服务角色编写&lt;/h2&gt;
&lt;p&gt;第一个历程: 创建角色目录结构&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cd roles/;mkdir {nfs,rsync,web,sersync} 
cd nfs/{vars,tasks,templates,handlers,files}
# vars:      定义变量信息
# tasks:     定义任务信息
# templates: 定义模板文件(jinja2模板文件)
# handlers:  定义触发器信息
# files:     定义需要分发的文件&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二个历程: 编写文件信息&lt;br/&gt;tasks:  任务信息编写方式一:&lt;br/&gt;nfs服务编写&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;vim main.yaml
- name: 01:install nfs rpcbind
  yum:
    name: ['nfs-utils', 'rpcbind'] 
    state: installed
- name: 02:copy conf file
  copy: src=/etc/ansible/ansible_playbook/nfs.conf  dest=/etc/{{ conf_file }}
  notify: 
    - nfs_restart
- name: 03:create data dir 
  file: path={{ data_dir }} state=directory owner=nfsnobody group=nfsnobody
- name: 04:boot server rpcbind
  service: name={{ item.name }} state={{ item.state }} enabled={{ item.enabled }}
  with_items:
    - {name: &quot;rpcbind&quot;, state: &quot;started&quot;, enabled: &quot;yes&quot;}
    - {name: &quot;nfs&quot;,     state: &quot;started&quot;, enabled: &quot;yes&quot;}
- name: 01:install nfs
  yum: name=nfs-utils state=installed
- name: 02:mount data dir
  mount: src=172.16.1.31:{{ data_dir }} path=/mnt fstype=nfs state=mounted
- name: 03:check mount info
  shell: df -h|grep mnt
  register: mount_info
- debug: msg={{ mount_info.stdout_lines }}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;tasks:  任务信息编写方式二:&lt;br/&gt;tasks：定义任务信息&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cd tasks
vim main.yaml
vim nfs_boot.yaml
vim nfs_conf.yaml
vim nfs_datadir.yaml
vim nfs_install.yaml
vim nfs_mount.yaml
#########################
vim main.yaml
- include_tasks: nfs_install.yaml
- include_tasks: nfs_conf.yaml
- include_tasks: nfs_datadir.yaml
- include_tasks: nfs_boot.yaml
- include_tasks: nfs_mount.yaml&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;vars：定义变量信息&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;vim main.yaml
conf_file: exports
data_dir: /data&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;files：定义需要分发的文件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@m01 files]# ll
total 4
-rw-r--r-- 1 root root 42 Jul 29 10:34 nfs.conf&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;handlers：定义触发器信息&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;vim main.yaml 
- name: nfs_restart
service: name=nfs state=reloaded&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 05 Aug 2019 00:16:00 +0000</pubDate>
<dc:creator>昨夜、星辰</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/basa/p/11300911.html</dc:identifier>
</item>
<item>
<title>ThreadLocal详解 - 代码无止境</title>
<link>http://www.cnblogs.com/endless-code/p/11300166.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/endless-code/p/11300166.html</guid>
<description>&lt;blockquote readability=&quot;3.943661971831&quot;&gt;
&lt;p&gt;想要获取更多文章可以访问我的博客 - &lt;a href=&quot;https://itweknow.cn&quot;&gt;代码无止境&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;什么是threadlocal&quot;&gt;什么是ThreadLocal&lt;/h3&gt;
&lt;p&gt;ThreadLocal在《Java核心技术 卷一》中被称作&lt;em&gt;线程局部变量&lt;/em&gt;（PS：关注公众号itweknow，回复“Java核心技术”获取该书），我们可以利用ThreadLocal创建只能由同一线程读和写的变量。因此就算两个线程正在执行同一段代码，并且这段代码具有对ThreadLocal变量的引用，这两个线程也无法看到彼此的ThreadLocal变量。&lt;/p&gt;
&lt;h3 id=&quot;简单使用&quot;&gt;简单使用&lt;/h3&gt;
&lt;p&gt;1.创建ThreadLocal，只需要new一个ThreadLocal对象即可。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private ThreadLocal&amp;lt;String&amp;gt; myThreadLocal = new ThreadLocal&amp;lt;String&amp;gt;();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.设置值&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;myThreadLocal.set(&quot;I'm a threadLocal&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.获取值&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;myThreadLocal.get();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4.清除，有些情况下我们在使用完线程局部变量后，需要即时清理，否则会导致程序运行错误。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;myThreadLocal.remove();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;假如我们现在要利用AOP打印方法的耗时，这个时候我们需要在&lt;code&gt;@Before&lt;/code&gt;方法中记录方法开始执行的时间，然后在&lt;code&gt;@AfterReturning&lt;/code&gt;方法中打印出来耗时时间。我们写在切面里的方法可能慧在多个线程中同时执行，所以此时我们需要ThreadLocal来记录开始执行的时间。&lt;/p&gt;
&lt;p&gt;1.我们需要在切面类中定义一个ThreadLocal。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private ThreadLocal&amp;lt;Long&amp;gt; threadLocal = new ThreadLocal();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.在&lt;code&gt;@Before&lt;/code&gt;方法中记录开始时间。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;long startTime = System.currentTimeMillis();
threadLocal.set(startTime);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.在&lt;code&gt;@AfterReturning&lt;/code&gt;方法中取出开始时间，并计算耗时。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;long startTime = threadLocal.get();
long spendTime = System.currentTimeMillis() - startTime;
threadLocal.remove();
System.out.println(&quot;方法执行时间：&quot; + spendTime + &quot;ms&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里只是借这个场景和大家一起熟悉一下ThreadLocal的用法，整个打印方法耗时的&lt;a href=&quot;https://github.com/ganchaoyang/spring-tutorial/blob/master/sb-aop/src/main/java/cn/itweknow/sbaop/aop/WebLogAspect.java&quot;&gt;实现你可以在Github&lt;/a&gt;上找到，如果你想了解AOP可以参考这篇文章&lt;a href=&quot;https://www.ibm.com/developerworks/cn/java/j-spring-boot-aop-web-log-processing-and-distributed-locking/index.html&quot;&gt;《使用 Spring Boot AOP 实现 Web 日志处理和分布式锁》&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;原理解析&quot;&gt;原理解析&lt;/h3&gt;
&lt;p&gt;其实ThreadLocal是个数据结构，下面我们就一起通过源码来剖析一下ThreadLocal的运行原理。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public T get() {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null) {
        ThreadLocalMap.Entry e = map.getEntry(this);
        if (e != null) {
            @SuppressWarnings(&quot;unchecked&quot;)
            T result = (T)e.value;
            return result;
        }
    }
    return setInitialValue();
}

public void set(T value) {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null)
        map.set(this, value);
    else
        createMap(t, value);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面是ThreadLocal的&lt;code&gt;get()&lt;/code&gt;和&lt;code&gt;set()&lt;/code&gt;方法的源码，可以看到ThreadLocal是将值存放在ThreadLocalMap中。其实在每个线程中都维护着一个threadLocals变量（ThreadLocalMap类型），当使用&lt;code&gt;set()&lt;/code&gt;方法的时候实际上是将值存在当前线程的threadLocals中的，调用&lt;code&gt;get()&lt;/code&gt;方法也是从当前线程中取值的，这样就做到了线程间的隔离。&lt;br/&gt;看到这里想必你也奇怪，在设置值和取值的时候都没有任何与key有关的东西，那么当一个线程有多个ThreadLocal的时候是如何做到一一对应的呢？那我们就一起来看下这个ThreadLocalMap类吧。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;static class ThreadLocalMap {
    /**
     * The initial capacity -- MUST be a power of two.
     */
    private static final int INITIAL_CAPACITY = 16;

    /**
     * The table, resized as necessary.
     * table.length MUST always be a power of two.
     */
    private Entry[] table;

    /**
     * The number of entries in the table.
     */
    private int size = 0;

    /**
     * The next size value at which to resize.
     */
    private int threshold; // Default to 0
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由上面可见在ThreadLocalMap中维护着&lt;code&gt;table&lt;/code&gt;，&lt;code&gt;size&lt;/code&gt;以及&lt;code&gt;threshold&lt;/code&gt;三个属性。&lt;code&gt;table&lt;/code&gt;是一个Entry数组主要用来保存具体的数据，&lt;code&gt;size&lt;/code&gt;是&lt;code&gt;table&lt;/code&gt;的大小，而&lt;code&gt;threshold&lt;/code&gt;这表示当&lt;code&gt;table&lt;/code&gt;中元素数量超过该值时，&lt;code&gt;table&lt;/code&gt;就会扩容。了解了ThreadLocalMap的结构之后，我们就来看下其&lt;code&gt;set&lt;/code&gt;方法吧。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private void set(ThreadLocal&amp;lt;?&amp;gt; key, Object value) {

    Entry[] tab = table;
    int len = tab.length;
    int i = key.threadLocalHashCode &amp;amp; (len-1);

    for (Entry e = tab[i];
        e != null;
        e = tab[i = nextIndex(i, len)]) {
        ThreadLocal&amp;lt;?&amp;gt; k = e.get();

        if (k == key) {
            e.value = value;
            return;
        }

        if (k == null) {
            replaceStaleEntry(key, value, i);
            return;
        }
    }

    tab[i] = new Entry(key, value);
    int sz = ++size;
    if (!cleanSomeSlots(i, sz) &amp;amp;&amp;amp; sz &amp;gt;= threshold)
        rehash();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过上面的代码分析得出，整个的设值过程如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;通过ThreadLocal的threadLocalHashCode值定位到table中的位置i。&lt;/li&gt;
&lt;li&gt;如果table中i这个位置是空的，那么就新创建一个Entry对象放置在i这个位置。&lt;/li&gt;
&lt;li&gt;如果table中i这个位置不为空，则取出来i这个位置的key。&lt;/li&gt;
&lt;li&gt;如果这个key刚好就是当前ThreadLocal对象，则直接修改该位置上Entry对象的value。&lt;/li&gt;
&lt;li&gt;如果这个key不是当前TreadLocal对象，则寻找下一个位置的Entry对象，然后重复上述步骤进行判断。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;对于get方法也是同样的原理从ThreadLocalMap中获取值。那么ThreadLocal是如何生成threadLocalHashCode值的呢？&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ThreadLocal&amp;lt;T&amp;gt; {
    private final int threadLocalHashCode = nextHashCode();
    private static final int HASH_INCREMENT = 0x61c88647;
    private static int nextHashCode() {
        return nextHashCode.getAndAdd(HASH_INCREMENT);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可见我们在初始化一个ThreadLocal对象的时候都为其会生成一个threadLocalHashCode值，每初始化一个ThreadLocal该值就增加0x61c88647。这样就可以做到每个ThreadLocal在ThreadLocalMap中找到一个存储值的位置了。&lt;/p&gt;
&lt;h3 id=&quot;结束语&quot;&gt;结束语&lt;/h3&gt;
&lt;p&gt;在文章的最后分享一次之前遇到的一个与ThreadLocal有关的坑，有一次在写分页的时候使用了PageHeler插件，引包的时候错误地引用了MybatisPlus下的PagerHelper，而MybatisPlus下的PageHelper在ThreadLocal中存储了SQL分页信息在使用之后没有移除，所以执行了分页的SQL之后在当前线程中执行的SQL都会出现问题。所以大家在使用ThreadLocal的过程中千万要注意在适当的时候需要清除。本文主要介绍了Java中的线程局部变量ThreadLocal的使用，并且和大家一起稍微了解了一下源码。希望对大家能够有所帮助。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;PS:学习不止，码不停蹄！如果您喜欢我的文章，就关注我吧！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://g-blog.oss-cn-beijing.aliyuncs.com/image/qrcode_for_gh_526c6f450b21_258.jpg&quot; alt=&quot;扫码关注“代码无止境”&quot;/&gt;&lt;/div&gt;
</description>
<pubDate>Mon, 05 Aug 2019 00:09:00 +0000</pubDate>
<dc:creator>代码无止境</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/endless-code/p/11300166.html</dc:identifier>
</item>
<item>
<title>[ PyQt入门教程 ] PyQt5基本控件使用:单选按钮、复选框、下拉框 - BengDou_Do&amp;Think</title>
<link>http://www.cnblogs.com/linyfeng/p/11294173.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/linyfeng/p/11294173.html</guid>
<description>&lt;p&gt;&lt;span&gt;   本文主要介绍PyQt5界面最基本使用的单选按钮、复选框、下拉框三种控件的使用方法进行介绍。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   1、RadioButton单选按钮/CheckBox复选框。需要知道如何判断单选按钮是否被选中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   2、ComboBox下拉框。需要知道如何对下拉框中的取值进行设置以及代码实现中如何获取用户选中的值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   带着这些问题下面开始介绍这&lt;span&gt;RadioButton单选按钮、CheckBox复选框、&lt;span&gt;ComboBox下拉框&lt;/span&gt;&lt;/span&gt;三种基本控件的使用方法&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;  &lt;span&gt;单选按钮为用户提供&lt;strong&gt;多选一&lt;/strong&gt;的选择，是一种开关按钮。QRadioButton单选按钮是否选择状态通过isChecked()方法判断。isChecked()方法返回值True表示选中，False表示未选中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;RadioButton示例完整代码如下：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;

&lt;span&gt;import&lt;/span&gt;&lt;span&gt; sys
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; PyQt5 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; QtCore, QtGui, QtWidgets
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; PyQt5.QtWidgets &lt;span&gt;import&lt;/span&gt;&lt;span&gt; QApplication, QMainWindow, QMessageBox, QRadioButton

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Ui_Form(object):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; setupUi(self, Form):
        Form.setObjectName(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Form&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        Form.resize(&lt;/span&gt;309, 126&lt;span&gt;)
        self.radioButton &lt;/span&gt;=&lt;span&gt; QtWidgets.QRadioButton(Form)
        self.radioButton.setGeometry(QtCore.QRect(&lt;/span&gt;70, 40, 89, 16&lt;span&gt;))
        self.radioButton.setObjectName(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;radioButton&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        self.okButton &lt;/span&gt;=&lt;span&gt; QtWidgets.QPushButton(Form)
        self.okButton.setGeometry(QtCore.QRect(&lt;/span&gt;70, 70, 75, 23&lt;span&gt;))
        self.okButton.setObjectName(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;okButton&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

        self.retranslateUi(Form)
        QtCore.QMetaObject.connectSlotsByName(Form)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; retranslateUi(self, Form):
        _translate &lt;/span&gt;=&lt;span&gt; QtCore.QCoreApplication.translate
        Form.setWindowTitle(_translate(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Form&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RadioButton单选按钮例子&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
        self.radioButton.setText(_translate(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Form&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;单选按钮&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
        self.okButton.setText(_translate(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Form&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;确定&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyMainForm(QMainWindow, Ui_Form):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(self, parent=&lt;span&gt;None):
        super(MyMainForm, self).&lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(parent)
        self.setupUi(self)
        self.okButton.clicked.connect(self.checkRadioButton)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; checkRadioButton(self):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; self.radioButton.isChecked():
            QMessageBox.information(self,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;消息框标题&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;我RadioButton按钮被选中啦！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,QMessageBox.Yes |&lt;span&gt; QMessageBox.No)

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
    app &lt;/span&gt;=&lt;span&gt; QApplication(sys.argv)
    myWin &lt;/span&gt;=&lt;span&gt; MyMainForm()
    myWin.show()
    sys.exit(app.exec_())&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;运行结果如下：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/774327/201908/774327-20190803104343702-1153275014.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;&lt;span&gt;关键代码介绍：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;strong&gt;&lt;span&gt;self.radioButton.isChecked()&lt;/span&gt;&lt;/strong&gt;  --&amp;gt; 用于判断RadioButton控件是否被选中。返回值Trule表示按钮被选中，False表示按钮未选中。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;   &lt;span&gt;复选框和单选按钮一样都是选项按钮，区别是复选框为用户提供&lt;strong&gt;多选多&lt;/strong&gt;的选择。复选框按钮同样是使用isChecked()方法判断是否被选中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;CheckBox例子完整代码如下：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;

&lt;span&gt;import&lt;/span&gt;&lt;span&gt; sys
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; PyQt5 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; QtCore, QtGui, QtWidgets
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; PyQt5.QtWidgets &lt;span&gt;import&lt;/span&gt;&lt;span&gt; QApplication, QMainWindow, QMessageBox, QCheckBox

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Ui_Form(object):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; setupUi(self, Form):
        Form.setObjectName(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Form&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        Form.resize(&lt;/span&gt;380, 154&lt;span&gt;)
        self.freshcheckBox &lt;/span&gt;=&lt;span&gt; QtWidgets.QCheckBox(Form)
        self.freshcheckBox.setGeometry(QtCore.QRect(&lt;/span&gt;50, 40, 71, 31&lt;span&gt;))
        font &lt;/span&gt;=&lt;span&gt; QtGui.QFont()
        font.setPointSize(&lt;/span&gt;14&lt;span&gt;)
        self.freshcheckBox.setFont(font)
        self.freshcheckBox.setObjectName(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;freshcheckBox&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        self.bearcheckBox &lt;/span&gt;=&lt;span&gt; QtWidgets.QCheckBox(Form)
        self.bearcheckBox.setGeometry(QtCore.QRect(&lt;/span&gt;140, 40, 71, 31&lt;span&gt;))
        font &lt;/span&gt;=&lt;span&gt; QtGui.QFont()
        font.setPointSize(&lt;/span&gt;14&lt;span&gt;)
        self.bearcheckBox.setFont(font)
        self.bearcheckBox.setObjectName(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bearcheckBox&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        self.okButton &lt;/span&gt;=&lt;span&gt; QtWidgets.QPushButton(Form)
        self.okButton.setGeometry(QtCore.QRect(&lt;/span&gt;230, 40, 71, 31&lt;span&gt;))
        font &lt;/span&gt;=&lt;span&gt; QtGui.QFont()
        font.setPointSize(&lt;/span&gt;14&lt;span&gt;)
        self.okButton.setFont(font)
        self.okButton.setObjectName(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;okButton&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

        self.retranslateUi(Form)
        QtCore.QMetaObject.connectSlotsByName(Form)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; retranslateUi(self, Form):
        _translate &lt;/span&gt;=&lt;span&gt; QtCore.QCoreApplication.translate
        Form.setWindowTitle(_translate(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Form&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CheckBox例子&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
        self.freshcheckBox.setText(_translate(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Form&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;鱼&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
        self.bearcheckBox.setText(_translate(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Form&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;熊掌&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
        self.okButton.setText(_translate(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Form&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;确定&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyMainForm(QMainWindow, Ui_Form):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(self, parent=&lt;span&gt;None):
        super(MyMainForm, self).&lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(parent)
        self.setupUi(self)
        self.okButton.clicked.connect(self.checkCheckBox)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; checkCheckBox(self):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; self.freshcheckBox.isChecked() &lt;span&gt;and&lt;/span&gt;&lt;span&gt; self.bearcheckBox.isChecked():
            QMessageBox.information(self,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;消息框标题&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;鱼和熊掌我要兼得！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,QMessageBox.Yes |&lt;span&gt; QMessageBox.No)

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
    app &lt;/span&gt;=&lt;span&gt; QApplication(sys.argv)
    myWin &lt;/span&gt;=&lt;span&gt; MyMainForm()
    myWin.show()
    sys.exit(app.exec_())&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;运行结果如下：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/774327/201908/774327-20190803105955429-341890867.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; 关键代码介绍：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;self.freshcheckBox.isChecked() &lt;span&gt;and &lt;span&gt;self.bearcheckBox.isChecked()  --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt; &lt;span&gt;&lt;span&gt;同样适用isChecked()函数判断。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;  &lt;span&gt;下拉列表框是一个集按钮和下拉选项于一体的控件。通常用于固定的枚举值供用户选择时使用。对于下拉列表框的使用最基本的是要知道如何添加下拉列表框中的值以及如何获取下拉框中选择的值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  （1）&lt;strong&gt;如何添加下拉列表框中的值。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  1、使用addItem() 添加一个下拉选项或者additems() 从列表中添加下拉选项 方法进行添加。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  2、如果使用Qt Designer画图实现，可以将ComboBox控件添加到主界面后双击下拉列表框进行打开添加。如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/774327/201908/774327-20190803110632141-2107466794.png&quot; alt=&quot;&quot; width=&quot;709&quot; height=&quot;328&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;  （2）如何获取下拉框中的取值&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  &lt;span&gt;使用函数currentText() 返回选项中的文本进行获取&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;ComboBox示例完整代码如下：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;

&lt;span&gt;import&lt;/span&gt;&lt;span&gt; sys
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; PyQt5 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; QtCore, QtGui, QtWidgets
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; PyQt5.QtWidgets &lt;span&gt;import&lt;/span&gt;&lt;span&gt; QApplication, QMainWindow, QMessageBox, QComboBox

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Ui_Form(object):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; setupUi(self, Form):
        Form.setObjectName(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Form&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        Form.resize(&lt;/span&gt;400, 130&lt;span&gt;)
        self.comboBox &lt;/span&gt;=&lt;span&gt; QtWidgets.QComboBox(Form)
        self.comboBox.setGeometry(QtCore.QRect(&lt;/span&gt;80, 50, 69, 22&lt;span&gt;))
        self.comboBox.setObjectName(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;comboBox&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        self.comboBox.addItem(&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;)
        self.comboBox.addItem(&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;)
        self.comboBox.addItem(&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;)
        self.comboBox.addItem(&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;)
        self.okButton &lt;/span&gt;=&lt;span&gt; QtWidgets.QPushButton(Form)
        self.okButton.setGeometry(QtCore.QRect(&lt;/span&gt;190, 50, 75, 23&lt;span&gt;))
        self.okButton.setObjectName(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;okButton&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

        self.retranslateUi(Form)
        QtCore.QMetaObject.connectSlotsByName(Form)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; retranslateUi(self, Form):
        _translate &lt;/span&gt;=&lt;span&gt; QtCore.QCoreApplication.translate
        Form.setWindowTitle(_translate(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Form&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ComboBox下拉框例子&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
        self.comboBox.setItemText(0, _translate(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Form&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Python&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
        self.comboBox.setItemText(&lt;/span&gt;1, _translate(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Form&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C++&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
        self.comboBox.setItemText(&lt;/span&gt;2, _translate(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Form&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Go&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
        self.comboBox.setItemText(&lt;/span&gt;3, _translate(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Form&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Java&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
        self.okButton.setText(_translate(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Form&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;确定&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyMainForm(QMainWindow, Ui_Form):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(self, parent=&lt;span&gt;None):
        super(MyMainForm, self).&lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(parent)
        self.setupUi(self)
        self.okButton.clicked.connect(self.getComboxBoxValue)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; getComboxBoxValue(self):
        select_value &lt;/span&gt;=&lt;span&gt; self.comboBox.currentText()
        QMessageBox.information(self,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;消息框标题&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;你要学%s,为师给你说道说道！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % (select_value,),QMessageBox.Yes |&lt;span&gt; QMessageBox.No)

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
    app &lt;/span&gt;=&lt;span&gt; QApplication(sys.argv)
    myWin &lt;/span&gt;=&lt;span&gt; MyMainForm()
    myWin.show()
    sys.exit(app.exec_())&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;运行结果如下：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/774327/201908/774327-20190803111506531-784673945.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; 关键代码介绍：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;span&gt;select_value = &lt;span&gt;self.comboBox.currentText() --&amp;gt; 使用currentText()函数获取下拉框中选择的值&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;RadioButton单选按钮、CheckBox复选框、&lt;span&gt;ComboBox下拉框三种基本控件&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的使用方法介绍完了。本文中的内容和实例也基本回答了开篇提到的问题。这三种基本控件的使用简单但也很频繁。可以多动手实践一下。上文中的程序都可以直接运行。可以运行看看效果。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 05 Aug 2019 00:06:00 +0000</pubDate>
<dc:creator>BengDou_Do&amp;amp;Think</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/linyfeng/p/11294173.html</dc:identifier>
</item>
<item>
<title>.net持续集成测试篇之Nunit文件断言、字符串断言及集合断言 - 周国通</title>
<link>http://www.cnblogs.com/tylerzhou/p/11300896.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tylerzhou/p/11300896.html</guid>
<description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/tylerzhou/p/11204826.html&quot;&gt;系列目录&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用前面讲过的方法基本上能够完成工作中的大部分任务了,然而有些功能实现起来还是比较麻烦的,比如说&lt;code&gt;字符串相等性比较不区分大小写,字符串是否匹配某一正则规则,集合中的每一个(某一个)元素是否符合特定规则&lt;/code&gt;等,Nunit提供了一些特定的方法用来实现一些用普通断言比较难以实现的扩展类型和方法.&lt;/p&gt;
&lt;h2 id=&quot;下面介绍一下stringassert类型下面的方法&quot;&gt;下面介绍一下&lt;strong&gt;StringAssert&lt;/strong&gt;类型下面的方法&lt;/h2&gt;
&lt;h3 id=&quot;stringassert.areequalignoringcasestring-expectedstring-actual&quot;&gt;StringAssert.AreEqualIgnoringCase(string expected,string actual)&lt;/h3&gt;
&lt;p&gt;此方法用于断言两个字符串在不区分大小写情况下是否相等,需要提供两个参数,第一个是期待的结果,第二个是实际结果.这个方法比较简单,不再提供示例.&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;需要注意的是Nunit里有许多需要提供两个参数的方法,一般情况下都是第一个是期待的结果,第二个是实际结果&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;stringassert.contains&quot;&gt;StringAssert.Contains&lt;/h3&gt;
&lt;p&gt;用于断言一个字符串是否包含另一字符串,其中第一个参数为被包含的字符串,第二个为实际字符串,这个方法语义不是特别明确,需要注意&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;        [Test]
        public void DemoTest()
        {
            StringAssert.Contains(&quot;hello&quot;, &quot;hello,world&quot;);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码片段会返回成功&lt;/p&gt;
&lt;h3 id=&quot;stringassert.startswith&quot;&gt;StringAssert.StartsWith&lt;/h3&gt;
&lt;p&gt;用于断言字符串是否以某(几)字符开始&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;       [Test]
        public void DemoTest()
        {
            StringAssert.StartsWith(&quot;h&quot;, &quot;hello,world&quot;);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;stringassert.endswith&quot;&gt;StringAssert.EndsWith&lt;/h3&gt;
&lt;p&gt;与StringAssert.StartsWith类似,string类也有此方法,相信大家都比较熟悉&lt;/p&gt;
&lt;h3 id=&quot;stringassert.ismatch&quot;&gt;StringAssert.IsMatch&lt;/h3&gt;
&lt;p&gt;用于断言指定字符串是否匹配某一正则规则&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;[warning]&lt;/strong&gt;这个方法并没有大小写开关&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;下面介绍两个与&lt;code&gt;文件(目录)&lt;/code&gt;有关的断言类FileAssert和DirectoryAssert.两个类下面的断言方法基本一样,只是一个是断言文件,一个是断言目录.下面以FileAssert为例说明&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;fileassert.areequal&quot;&gt;FileAssert.AreEqual&lt;/h3&gt;
&lt;p&gt;这个方法用于断言两个文件是否是同一个文件,接受字符串参数&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;需要说明的是,字符串路径必须指向文件,而不能是目录或者不存在的文件.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;fileassert.exists&quot;&gt;&lt;code&gt;FileAssert.Exists&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;用于断言某个文件是否存在,接受&lt;code&gt;字符串参数&lt;/code&gt;或者&lt;code&gt;FileInfo&lt;/code&gt;作为参数&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;DirectoryAssert方法类似,并且这些方法都对应的有相反方向的断言,方法名包含Not,很容易理解&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;单元测试过程中,我们很多时候都要处理集合,Nunit里提供了一个 &lt;strong&gt;CollectionAssert&lt;/strong&gt; 类用于处理对集合类型的断言&lt;/p&gt;
&lt;p&gt;下面介绍一下这个类下面的断言方法&lt;/p&gt;
&lt;h2 id=&quot;collectionassert.allitemsareinstancesoftype&quot;&gt;&lt;code&gt;CollectionAssert.AllItemsAreInstancesOfType&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;用于断言集合里面的元素是否都是某一特定类型.&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;        [Test]
        public void DemoTest()
        {
            ArrayList ar = new ArrayList {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;};
            CollectionAssert.AllItemsAreInstancesOfType(ar, typeof(string));
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上断言会返回成功,因为我们向ArrayList里添加的全是string类型的元素&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;需要注意,很多断言方法第一个参数是期待类型,第二个是实际类型,而此方法则相反,第一个是实际集合,第二个是期待的类型&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;这里的类型支持父类,比如说如果是&lt;code&gt;typeof(object)&lt;/code&gt;也同样能通过,语义上来讲,元素是string类型,也是object类型,讲得通的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;collectionassert.allitemsarenotnull&quot;&gt;CollectionAssert.AllItemsAreNotNull&lt;/h2&gt;
&lt;p&gt;用于断言集合里的元素全部不是Null,也即集合不包含null元素,这个方法只有一个参数,传入我们要判断的集合即可&lt;/p&gt;
&lt;h2 id=&quot;collectionassert.allitemsareunique&quot;&gt;CollectionAssert.AllItemsAreUnique&lt;/h2&gt;
&lt;p&gt;用于断言集合里面的元素全部是惟一的,即集合里没有重复元素.&lt;/p&gt;
&lt;blockquote readability=&quot;17&quot;&gt;
&lt;p&gt;&lt;strong&gt;[warning]&lt;/strong&gt;需要注意的是,这个方法并没有提供一个重载支持自定义比较器,它只能用于断言简单类型,如string,int,datetime等是否惟一,如果是类类型则需要重载&lt;code&gt;equals&lt;/code&gt;和&lt;code&gt;gethashcode&lt;/code&gt;但是通常我们并不这样做,而是在类外部提供一个比较器,如果判断复杂类型是否惟一,我们在以后再介绍&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面举一个例子说明这个问题&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;      [Test]
        public void DemoTest()
        {
            Person[] psn = new Person[] {
                new Person { Name=&quot;sto&quot;,Age=32,BirthDay=DateTime.Today.AddYears(-10)},
                new Person { Name=&quot;sto&quot;,Age=32,BirthDay=DateTime.Today.AddYears(-10)}};
            CollectionAssert.AllItemsAreUnique(psn);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上代码测试会通过,因为两个new出来的Persn不是同一个对象,但实际业务中,两个对象的属性完全相等时我们就认为它们是相等的,以上我们期待的结果是 &lt;strong&gt;不通过&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;collectionassert.areequal&quot;&gt;CollectionAssert.AreEqual&lt;/h2&gt;
&lt;p&gt;用于断言两个集合是否相等,如果两个集合里的元素都是简单对象,如果是复杂对象用这个方法并不是很方便(虽然此方法提供提供IComparer作为参数,然而IComparer对集合并不是很方便)&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;[warning]&lt;/strong&gt;这里的两个集合相等第一集合元素个数必须相等(不用多说),第二集合元素的&lt;code&gt;顺序必须一致的&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;14&quot;&gt;
&lt;p&gt;还有一点需要说明还有一点需要说明,如以上所说,两个集合元素顺序一致,并且在运行时类型是一致的就会被认为是相等,这两个集合的&lt;code&gt;类型不必一样&lt;/code&gt;,比如说一个是array,一个是list,&lt;code&gt;泛型参数也不必须一样&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;只要在运行时类型是一致的即可&lt;/p&gt;
&lt;p&gt;请看下面一段代码&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;        [Test]
        public void DemoTest()
        {
            int[] a = {3, 4, 5};
            List&amp;lt;object&amp;gt; b =new List&amp;lt;object&amp;gt; {3, 4, 5};
            CollectionAssert.AreEqual(a, b);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;a和b两个集合的集合类型不一样,泛型类型也不一样,但是运行的时候却是一样的,因此以上代码执行会返回成功状态&lt;/p&gt;
&lt;h2 id=&quot;collectionassert.areequivalent&quot;&gt;CollectionAssert.AreEquivalent&lt;/h2&gt;
&lt;p&gt;这个方法用来判断两个集合的元素是否等价,如果两个集合元素类型相同,个数也相同,即视为等价,与上面的方法相比,它不&lt;code&gt;关心顺序&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;        [Test]
        public void DemoTest()
        {
            int[] a = {3, 4, 5};
            List&amp;lt;object&amp;gt; b =new List&amp;lt;object&amp;gt; {4,3, 5};
            CollectionAssert.AreEquivalent(a, b);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上代码测试是通过的&lt;/p&gt;
&lt;h2 id=&quot;collectionassert.contains&quot;&gt;CollectionAssert.Contains&lt;/h2&gt;
&lt;p&gt;用于断言集合是否包含某一元素&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;需要说明的是.要判断集合中是否包含某一元素,只要集合运行时有特定元素和指定元素类型相同,并且值相同,即认为集合包含这一元素&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;请看以下代码片段&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;
        [Test]
        public void DemoTest()
        {
            int[] a = {3, 4, 5};
            object element = 4;
            List&amp;lt;object&amp;gt; b =new List&amp;lt;object&amp;gt; {element,3, 5};
            CollectionAssert.Contains(b, 4);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上代码段中b集合虽然不包含值为4的int类型元素,只有object类型的值为4的元素,然而它在运行时真正的类型是int,因此以上测试也是通过的.&lt;/p&gt;
&lt;h2 id=&quot;collectionassert.isempty&quot;&gt;CollectionAssert.IsEmpty&lt;/h2&gt;
&lt;p&gt;用于断言某一集合是空集合,即元素个数为0&lt;/p&gt;
&lt;h2 id=&quot;collectionassert.isordered&quot;&gt;CollectionAssert.IsOrdered&lt;/h2&gt;
&lt;p&gt;用于断言集合元素是否按&lt;span&gt;&lt;strong&gt;正序&lt;/strong&gt;&lt;/span&gt;排列,所谓正序列,是指按阿拉伯数字或者字符表顺序正序排列.&lt;/p&gt;
&lt;h2 id=&quot;collectionassert.issubsetof&quot;&gt;CollectionAssert.IsSubsetOf&lt;/h2&gt;
&lt;p&gt;用于判断一个集合是否为另一个集合的子集,与以上相同的是,这两个集合不必是同一类集合(可以一个是array,一个是list),只要一个集合的元素完全包含在另一个集合中,即认为它是另一个集合的子集&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;只要一个集合元素完全包含在另一个集合中即可,顺序不必相同&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;collectionassert.issupersetof&quot;&gt;CollectionAssert.IsSupersetOf&lt;/h2&gt;
&lt;p&gt;用于断言一个集合是否是另一个集合的父集,与子集判断用法一样.&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;以上大部分方法都有一个判断相反的方法,名称中多一个Not,这里不再罗列&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 05 Aug 2019 00:03:00 +0000</pubDate>
<dc:creator>周国通</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tylerzhou/p/11300896.html</dc:identifier>
</item>
</channel>
</rss>