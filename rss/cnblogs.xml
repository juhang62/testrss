<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>机器学习笔记  逻辑回归 - sdu20112013</title>
<link>http://www.cnblogs.com/sdu20112013/p/10196444.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sdu20112013/p/10196444.html</guid>
<description>&lt;h3&gt;逻辑回归&lt;/h3&gt;
&lt;p&gt;逻辑回归和线性回归其实有不少类似的地方,不同的是逻辑回归的$\hat y$是离散的.线性回归的$\hat y$是连续的.&lt;/p&gt;
&lt;p&gt;逻辑回归：拟合样本数据发生的概率,根据概率进行分类处理.&lt;/p&gt;
&lt;p&gt;逻辑回归,拟合样本发生的概率.&lt;br/&gt;$\hat p = f(x)$,之后根据概率的大小对样本做分类.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/583030/201901/583030-20190122164212315-1064076469.png&quot; alt=&quot;&quot; width=&quot;162&quot; height=&quot;88&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通常,将逻辑回归用来解决分类问题.作为分类算法时,解决的是二分类问题.&lt;/p&gt;
&lt;p&gt;在&lt;a href=&quot;https://www.cnblogs.com/sdu20112013/p/10186516.html&quot; target=&quot;_blank&quot;&gt;线性回归&lt;/a&gt;一文中,我们知道$\hat y = \theta ^T X_b$,但是这个值的取值范围是负无穷到正无穷,如果我们想要表达概率的话,希望找到一个函数,取值范围在0-1.&lt;/p&gt;
&lt;h4 id=&quot;Sigmoid_u51FD_u6570&quot;&gt;Sigmoid函数&lt;/h4&gt;
&lt;p&gt;在&lt;a href=&quot;https://www.cnblogs.com/sdu20112013/p/10266382.html&quot; target=&quot;_blank&quot;&gt;一文读懂svm&lt;/a&gt;中,我们也提到过这个函数,是常见核函数的一种.以后在讲神经网络的时候也会再看到它.&lt;/p&gt;
&lt;p&gt;$\hat p = \sigma(X_b \theta) =\frac 1 {1+e^{-X_b \theta}}$&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/583030/201901/583030-20190110192356355-380693094.png&quot; alt=&quot;&quot; width=&quot;305&quot; height=&quot;85&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个函数,我想不用多解释了,学过高中数学的应该都能明白其取值在0-1之间.&lt;/p&gt;
&lt;p&gt;通过这个函数,我们可以把一个预测值转化为概率值,所以逻辑回归的概率模型可以表达为$$\hat p = \frac 1 {1+e^{-\theta ^T X_b}}$$.&lt;/p&gt;
&lt;p&gt;我们做这样一个假设.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/583030/201901/583030-20190123095646191-1240722019.png&quot; alt=&quot;&quot; width=&quot;116&quot; height=&quot;55&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样当有一个样本x过来,我们可以先计算出$\hat p$，再进而得到一个$\hat y$。&lt;/p&gt;
&lt;p&gt;那么此时我们的问题转变为：怎样求得这样的$\theta$，使得我们预测的$\hat y$与真实的y之间误差最小？&lt;/p&gt;

&lt;h4&gt;损失函数&lt;/h4&gt;
&lt;p&gt;由于我们的$\hat y$有两种情况,是二元的,离散的.所以我们的损失函数也分两种情况&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/583030/201901/583030-20190123110534206-2105213586.png&quot; alt=&quot;&quot; width=&quot;234&quot; height=&quot;72&quot;/&gt;&lt;/p&gt;
&lt;p&gt;怎么理解？当y=1时,p越小,我们越倾向于把$\hat y$归为0. 这时候错的越离谱.   当y=0时,p越大,我们越认为$\hat y$归为1.&lt;/p&gt;

&lt;p&gt;符合上述描述的损失函数可以表达如下：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/583030/201901/583030-20190123105218178-914524811.png&quot; alt=&quot;&quot; width=&quot;237&quot; height=&quot;63&quot;/&gt;&lt;/p&gt;
&lt;p&gt;转换为统一的表达形式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/583030/201901/583030-20190123105229755-570311054.png&quot; alt=&quot;&quot; width=&quot;209&quot; height=&quot;28&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面是单个样本的cost，这样对一个有着m个样本的系统来说,损失函数可以表达为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/583030/201901/583030-20190123105402215-1071568009.png&quot; alt=&quot;&quot; width=&quot;254&quot; height=&quot;35&quot;/&gt;&lt;/p&gt;
&lt;p&gt;即：&lt;img src=&quot;https://img2018.cnblogs.com/blog/583030/201901/583030-20190123105527979-1918562808.png&quot; alt=&quot;&quot; width=&quot;299&quot; height=&quot;44&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;求损失函数的梯度&lt;/h4&gt;
&lt;p&gt;推导不困难,但是有点复杂.......&lt;/p&gt;
&lt;h4&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/583030/201901/583030-20190123154103522-807776534.png&quot; alt=&quot;&quot; width=&quot;223&quot; height=&quot;172&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/583030/201901/583030-20190123154120086-1680917499.png&quot; alt=&quot;&quot; width=&quot;228&quot; height=&quot;157&quot;/&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/583030/201901/583030-20190123154219248-2054151449.png&quot; alt=&quot;&quot; width=&quot;406&quot; height=&quot;189&quot;/&gt;&lt;/p&gt;
&lt;p&gt;即&lt;img src=&quot;https://img2018.cnblogs.com/blog/583030/201901/583030-20190123154337831-768536463.png&quot; alt=&quot;&quot; width=&quot;249&quot; height=&quot;135&quot;/&gt;，和我们在线性回归中算出的梯度形式很像.&lt;/p&gt;

&lt;p&gt;有了梯度,就可以用梯度下降法求出使得$J(\theta)$最小的$\theta$。&lt;/p&gt;

</description>
<pubDate>Wed, 23 Jan 2019 15:51:00 +0000</pubDate>
<dc:creator>sdu20112013</dc:creator>
<og:description>逻辑回归 逻辑回归和线性回归其实有不少类似的地方,不同的是逻辑回归的$\hat y$是离散的.线性回归的$\hat y$是连续的. 逻辑回归：拟合样本数据发生的概率,根据概率进行分类处理. 逻辑回归,</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sdu20112013/p/10196444.html</dc:identifier>
</item>
<item>
<title>寒冬储粮 - LieBrother</title>
<link>http://www.cnblogs.com/liebrother/p/10312113.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liebrother/p/10312113.html</guid>
<description>&lt;p&gt;个人博客原文：&lt;br/&gt;&lt;a href=&quot;http://www.liebrother.com/share-mind-map&quot;&gt;寒冬储粮&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.liebrother.com/upload/852d9920ae5e42dd9be8dcdf6533439d_0046_01.jpg&quot; alt=&quot;鸟儿&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上次发了这篇文章 &lt;a href=&quot;https://mp.weixin.qq.com/s/h2-qaF3HVwUe0vbo57ldRw&quot;&gt;跳槽 &amp;amp; 思维导图&lt;/a&gt;，里面只是贴了一个图，也不是很清晰，主要是想给大家看一下思维导图记录知识点，供大家参考一下，后面有小伙伴在咨询能否把思维导图原件分享出来，分享出来肯定是可以的，这些都不是我的知识，都是网上的资料，我只是把它们记录在思维导图。&lt;/p&gt;
&lt;p&gt;今天把这些资料整理了，有的其实还没记录到位，还有很多遗漏的知识点，用我个人力量也很难把这些知识点都总结起来。因此，在把资料上传到百度网盘和 github 之间，我选择了后者，因为大家可以把自己觉得有用的知识点也提交上来，或者在已经存在的思维导图基础上补充进去，让大家都能学习到，也可以多多交流。&lt;/p&gt;
&lt;p&gt;有一点想强调的：&lt;strong&gt;思维导图就跟人的思维一样，每个人的思维都是不一样的，所以其他人记录下来的东西不一定适合你，最好大家自己都能养成把知识点用思维导图记录的习惯，自己记录下的东西才真正属于你的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;年底了，希望大家过个好年，猪年一起牛逼。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/1CSH1/liebrother/tree/master/interview&quot;&gt;粮食链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;目录如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.liebrother.com/upload/19baaeb98ecb4f9aaa9f33b171154a9d_share.jpg&quot; alt=&quot;share&quot;/&gt;&lt;/p&gt;
&lt;p&gt;推荐阅读：&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/mp/homepage?__biz=MzIxMzgwMTAyMg==&amp;amp;hid=2&amp;amp;sn=c97b64288d92312f57d3c8298f8d8888&quot;&gt;公众号之设计模式系列文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.liebrother.com/upload/df81ac224abe46b38131a0e78f4dcf9c_wechat.jpg&quot; alt=&quot;公众号&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 23 Jan 2019 15:42:00 +0000</pubDate>
<dc:creator>LieBrother</dc:creator>
<og:description>猪年一起牛逼。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liebrother/p/10312113.html</dc:identifier>
</item>
<item>
<title>css之标签选择器 - cherry小樱桃</title>
<link>http://www.cnblogs.com/surewing/p/10312111.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/surewing/p/10312111.html</guid>
<description>&lt;p&gt;标签（空格分隔）： 标签选择器&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;选择器定义&quot;&gt;选择器定义：&lt;/h2&gt;
&lt;p&gt;在一个HTML页面中会有很多很多的元素，不同的元素可能会有不同的样式，某些元素又需要设置相同的样式，选择器就是用来从HTML页面中查找特定元素的，找到元素之后就可以为它们设置样式了。选择器为样式规则指定一个作用范围。&lt;/p&gt;
&lt;h2 id=&quot;基础选择器包含&quot;&gt;基础选择器包含：&lt;/h2&gt;
&lt;p&gt;1.标签选择器&lt;br/&gt;2.类选择器&lt;br/&gt;3.ID选择器&lt;br/&gt;4.通用选择器&lt;/p&gt;
&lt;h2 id=&quot;标签选择器&quot;&gt;标签选择器：&lt;/h2&gt;
&lt;p&gt;顾名思义通过标签名来选择元素；&lt;br/&gt;例如：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;p {
  color: red;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将所有的p标签设置字体颜色为红色。&lt;br/&gt;如下代码：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;css的选择器&amp;lt;/title&amp;gt;
    &amp;lt;style type=&quot;text/css&quot;&amp;gt;
        /*标签选择器*/
        /*p{*/
            /*color:red;*/
            /*font-size:20px;*/
        
        /*}*/
        /*span{*/
            /*color:yellow;*/
            /*font-size:20px;*/
        
        /*}*/
        body{
            color: gray;
            font-size: 12px;

        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;!--
css选择器
1.标签选择器：
        标签选择器，可以选中所有的标签，比如div,ul,li,p等等；
        不管标签的藏得多深，都能选中；
        选中的是所有的，不是某一个，所以说这个标签选择器选中的是&quot;共性&quot;的属性，而不是&quot;特性&quot;


--&amp;gt;
    &amp;lt;div&amp;gt;
        &amp;lt;p&amp;gt;我是一个段落&amp;lt;/p&amp;gt;
        &amp;lt;ul&amp;gt;
            &amp;lt;li&amp;gt;
                &amp;lt;span&amp;gt;
                    想想吧！！！
                &amp;lt;/span&amp;gt;
            &amp;lt;/li&amp;gt;
        &amp;lt;/ul&amp;gt;

    &amp;lt;/div&amp;gt;
    &amp;lt;div&amp;gt;
        &amp;lt;div&amp;gt;
            &amp;lt;div&amp;gt;
                &amp;lt;div&amp;gt;
                    &amp;lt;p&amp;gt;
                        藏得深的段落
                    &amp;lt;/p&amp;gt;
                &amp;lt;/div&amp;gt;
            &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;id选择器&quot;&gt;id选择器：&lt;/h2&gt;
&lt;p&gt;通过元素的ID值选择元素：&lt;br/&gt;例如：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;#i1 {
  color: red;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将id值为i1的元素字体颜色设置为红色。&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;css的选择器&amp;lt;/title&amp;gt;
    &amp;lt;style type=&quot;text/css&quot;&amp;gt;
        /*id选择器*/
        #box{
            color: green;
        }
        #s1{
            color: red;
        }
        #s2{
            color: red;
            font-size:16px;
        }

    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;!--
css选择器
1.标签选择器：
        标签选择器，可以选中所有的标签，比如div,ul,li,p等等；
        不管标签的藏得多深，都能选中；
        选中的是所有的，不是某一个，所以说这个标签选择器选中的是&quot;共性&quot;的属性，而不是&quot;特性&quot;
2.id 选择器：
    #选中id
    同一个页面中id不能重复，
    是不是所有的标签都可以加标签呢？任何的标签都可以设置ID，但是ID的命名一定要规范，字母开头后边可以数字，下划线等等；



--&amp;gt;
    &amp;lt;div&amp;gt;
        &amp;lt;p&amp;gt;我是一个段落&amp;lt;/p&amp;gt;
        &amp;lt;ul&amp;gt;
            &amp;lt;li&amp;gt;
                &amp;lt;span&amp;gt;
                    想想吧！！！
                &amp;lt;/span&amp;gt;
            &amp;lt;/li&amp;gt;
        &amp;lt;/ul&amp;gt;

    &amp;lt;/div&amp;gt;
    &amp;lt;div&amp;gt;
        &amp;lt;div&amp;gt;
            &amp;lt;div&amp;gt;
                &amp;lt;div&amp;gt;
                    &amp;lt;p&amp;gt;
                        藏得深的段落
                    &amp;lt;/p&amp;gt;
                &amp;lt;/div&amp;gt;
            &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;div id=&quot;box&quot;&amp;gt;
        &amp;lt;span id=&quot;s1&quot;&amp;gt;123&amp;lt;/span&amp;gt;
        &amp;lt;span id=&quot;s2&quot;&amp;gt;234&amp;lt;/span&amp;gt;
    &amp;lt;/div&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;类选择器&quot;&gt;类选择器：&lt;/h2&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;css的选择器&amp;lt;/title&amp;gt;
    &amp;lt;style type=&quot;text/css&quot;&amp;gt;
        /*id选择器*/
        #box{
            color: green;
        }
        #s1{
            color: red;
        }
        #s2{
            color: red;
            font-size:16px;
        }
        .titile{
            color: yellowgreen;
            font-size: 12px;
        }
        .aaaa{
            color: red;
        }

    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;!--
css选择器
1.标签选择器：
        标签选择器，可以选中所有的标签，比如div,ul,li,p等等；
        不管标签的藏得多深，都能选中；
        选中的是所有的，不是某一个，所以说这个标签选择器选中的是&quot;共性&quot;的属性，而不是&quot;特性&quot;
2.id 选择器：
    #选中id
    同一个页面中id不能重复，
    是不是所有的标签都可以加标签呢？任何的标签都可以设置ID，但是ID的命名一定要规范，字母开头后边可以数字，下划线等等；
3.类选择器：
    所谓类：.，class 与id非常的相似，可以作用任何标签，
    但是id特性是唯一，但是类是可以重复的，叫做归类；
    同一个标签中可以携带多个类；多个类之间用空格隔开；

--&amp;gt;
    &amp;lt;div&amp;gt;
        &amp;lt;p&amp;gt;我是一个段落&amp;lt;/p&amp;gt;
        &amp;lt;ul&amp;gt;
            &amp;lt;li&amp;gt;
                &amp;lt;span&amp;gt;
                    想想吧！！！
                &amp;lt;/span&amp;gt;
            &amp;lt;/li&amp;gt;
        &amp;lt;/ul&amp;gt;

    &amp;lt;/div&amp;gt;
    &amp;lt;div&amp;gt;
        &amp;lt;div&amp;gt;
            &amp;lt;div&amp;gt;
                &amp;lt;div&amp;gt;
                    &amp;lt;p&amp;gt;
                        藏得深的段落
                    &amp;lt;/p&amp;gt;
                &amp;lt;/div&amp;gt;
            &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;div id=&quot;box&quot;&amp;gt;
        &amp;lt;span id=&quot;s1&quot;&amp;gt;123&amp;lt;/span&amp;gt;
        &amp;lt;span id=&quot;s2&quot;&amp;gt;234&amp;lt;/span&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;div&amp;gt;
        &amp;lt;h3 id=&quot;h&quot; class=&quot;titile xiaoma egon aaaa&quot;&amp;gt;woshi yige sanji bieti &amp;lt;/h3&amp;gt;
        &amp;lt;h3 class=&quot;titile&quot;&amp;gt;woshi yige sanji bieti &amp;lt;/h3&amp;gt;
        &amp;lt;h3 class=&quot;titile&quot;&amp;gt;woshi yige sanji bieti &amp;lt;/h3&amp;gt;
        &amp;lt;h3&amp;gt;woshi yige sanji bieti &amp;lt;/h3&amp;gt;
        &amp;lt;h3&amp;gt;woshi yige sanji bieti &amp;lt;/h3&amp;gt;
        &amp;lt;h3&amp;gt;woshi yige sanji bieti &amp;lt;/h3&amp;gt;
    &amp;lt;/div&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;类选择器：具体的可以查看代码注释里面；&lt;/p&gt;
&lt;h2 id=&quot;如何正确的使用类选择器及总结&quot;&gt;如何正确的使用类选择器及总结：&lt;/h2&gt;
&lt;p&gt;需求：&lt;br/&gt;段落1：40px,绿色&lt;br/&gt;段落2：绿色，下划线&lt;br/&gt;段落3：下划线，40px&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;练习&amp;lt;/title&amp;gt;
    &amp;lt;style&amp;gt;
        .lv{
            color: green;
            font-size: 40px
        ;
        }
        .l2{
            text-decoration: underline;
            color: green;
        }
        .l3{
            font-size: 40px;
            text-decoration: underline;
            

        }
    &amp;lt;/style&amp;gt;
    &amp;lt;div&amp;gt;
        &amp;lt;p class=&quot;lv&quot;&amp;gt;段落1&amp;lt;/p&amp;gt;
        &amp;lt;p class=&quot;l2&quot;&amp;gt;段落2&amp;lt;/p&amp;gt;
        &amp;lt;p class=&quot;l3&quot;&amp;gt;段落3&amp;lt;/p&amp;gt;
    &amp;lt;/div&amp;gt;

&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;方案2：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;练习&amp;lt;/title&amp;gt;
    &amp;lt;style&amp;gt;
        .lv{
            color: green;
        }
        .un{
            text-decoration: underline;
        }
        .big{
            font-size: 40px;

        }
    &amp;lt;/style&amp;gt;
    &amp;lt;div&amp;gt;
        &amp;lt;p class=&quot;lv big&quot;&amp;gt;段落1&amp;lt;/p&amp;gt;
        &amp;lt;p class=&quot;lv un&quot;&amp;gt;段落2&amp;lt;/p&amp;gt;
        &amp;lt;p class=&quot;un big&quot;&amp;gt;段落3&amp;lt;/p&amp;gt;
    &amp;lt;/div&amp;gt;

&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;总结：不要试图，用一个类的页面写完，这个标签要携带多个类共同设置样式，&lt;br/&gt;2.每个类要尽可能的小，有公共的概念，能够让更多的标签使用&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;总结：&lt;br/&gt;到底是用id修改样式还是用class呢？&lt;br/&gt;答案：尽可能的使用class，除非特殊的原因，ID是用来js，也就是说js是通过ID来获取到标签的，后边我们还会说的这个内容；在css中尽量不要用id，（一般的来说，css用class,js用ID，更像是一种约定）&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
</description>
<pubDate>Wed, 23 Jan 2019 15:41:00 +0000</pubDate>
<dc:creator>cherry小樱桃</dc:creator>
<og:description>标签（空格分隔）： 标签选择器 选择器定义： 在一个HTML页面中会有很多很多的元素，不同的元素可能会有不同的样式，某些元素又需要设置相同的样式，选择器就是用来从HTML页面中查找特定元素的，找到元素</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/surewing/p/10312111.html</dc:identifier>
</item>
<item>
<title>并发编程的目标与挑战 - 丁可乐</title>
<link>http://www.cnblogs.com/dwlovelife/p/9944085.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dwlovelife/p/9944085.html</guid>
<description>&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;If I had only one hour to save the worlds,I would spend fifty-five minutes defining the problem,and only five minutes finding the solution.&lt;/p&gt;
&lt;p&gt;如果我只有1小时拯救世界,我将花55分钟定义这个问题而只花分钟去寻找解决方案 ——Albert Einstein&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;本文讲解的将是多线程的一些重要概念,为接下来自己以及读者更好的理解并发编程做个铺垫。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;之后会讲解volatile关键字，CAS , AQS 等等，总之概念是实践的基石&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;竞态&quot;&gt;1.1 竞态&lt;/h2&gt;
&lt;p&gt;多线程编程中经常遇到一个问题就是对于同样的输入，程序的输出有时候是正确的，而有时候却是错误的。这种一个计算结果的正确性与时间有关的现象就被称为&lt;strong&gt;竞态&lt;/strong&gt;(Race Condition)。&lt;/p&gt;
&lt;p&gt;如 &lt;a href=&quot;https://www.cnblogs.com/dwlovelife/p/9926645.html&quot;&gt;java核心技术-多线程基础&lt;/a&gt; 中 1.1 (2)&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Ticket implements Runnable{
    
    private int ticket = 100;

    @Override
    public void run() {
        while(ticket &amp;gt; 0){
            System.out.println(Thread.currentThread().getName() + &quot;=&quot; + --ticket);
        }
        
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class TestThread2 {
    public static void main(String[] args) {
        
        Ticket ticket = new Ticket();
        
        //虽然是实现了Runnable接口 本质上只是实现了线程执行体 启动工作还是需要Thread类来进行
        Thread t1 = new Thread(ticket,&quot;售票窗口一&quot;);
        t1.start();
        
        Thread t2 = new Thread(ticket,&quot;售票窗口二&quot;);
        t2.start();
        
        Thread t3 = new Thread(ticket,&quot;售票窗口三&quot;);
        t3.start();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;卖票的CASE，此案例中竞态导致的结果是不同业务的线程可能拿到了重复的ticket(票),且可能出现ticket为负数的情况。&lt;/p&gt;
&lt;p&gt;可见 &lt;strong&gt;while(ticket &amp;gt; 0)&lt;/strong&gt; 以及 &lt;strong&gt;--ticket&lt;/strong&gt; 这两个操作 是祸端之源。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进一步来说，导致竞态的常见因素是多个线程 在没有采取任何控制措施的情况下，并发地更新、读取同一个共享变量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有朋友可能会说：--ticket 操作 是一个操作啊 你怎么能说是祸端之源&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其实不是的，只是看起来像是一个操作而已，它实际上 相当于如下伪代码所表示的三个指令&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;load(ticket,r1); //指令①：将变量ticket 的值从内存读到寄存器r1
decrement(r1); //指令②：将寄存器r1的值减少1
store(ticket,r1);//指令③：将寄存器r1的内容写入变量ticket所对应的内存空间&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而 ①②③并不能保证是一个原子操作，两个业务线程可能在同一时刻读取到ticket的同一个值,一个业务线程对ticket所做的更新也可能&quot;覆盖&quot;其他线程对该变量做的更新,所以，问题不言而喻.....&lt;/p&gt;
&lt;h2 id=&quot;竞态的模式与竞态产生的条件&quot;&gt;1.2 竞态的模式与竞态产生的条件&lt;/h2&gt;
&lt;p&gt;从上述竞态的典型实例中,我们可以提炼出竞态的两种模式:&lt;/p&gt;
&lt;p&gt;① read-modify-write（读改写）&lt;/p&gt;
&lt;p&gt;② check-then-act (检测而后行动)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;read-modify-write（读改写）操作可以被细分为这样几个步骤:读取一个共享变量的值(read),然后根据该值做一些计算(modify),接着更新该共享变量的值。例如 --ticket&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;check-then-act (检测而后行动) ,该操作可以被细分为这样几个步骤:读取某个共享变量的值，根据该共享变量的值决定下一步的动作是什么。while(ticket &amp;gt; 0) --ticket&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;但是对于局部变量(包括形式参数和方法体内定义的变量)，由于不同的线程各自访问的各自访问的是各自的那一份局部变量，&lt;strong&gt;因此局部变量的使用不会导致竞态&lt;/strong&gt;，如下例&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class NoRaceCondition {
    
    
    public int nextSequence(int sequence){
        if(sequence &amp;gt;= 999){
            sequence = 0;
        }else{
            sequence++;
        }
        return sequence;
    }
    
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;线程安全性&quot;&gt;1.3 线程安全性&lt;/h2&gt;
&lt;p&gt;一般而言，如果一个类在单线程环境下能够正常运行，并且在多线程环境下，在其使用方不必为其做任何改变的情况下也能正常运行，那么我们就称其是线程安全的，相应的我们称这个类具有线程安全性，反之亦然。&lt;strong&gt;而一个类如果是线程安全的，那么它就不会导致竞态。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;线程安全问题概括来说表现为3个方面: 原子性、可见性、有序性&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;原子性&quot;&gt;1.3.1 原子性&lt;/h3&gt;
&lt;p&gt;原子(Atomic) 的字面意思是不可分割的。其含义简单的来说就是，&lt;strong&gt;访问（读、写）某个共享变量的操作从执行线程以外的任何线程来看，该操作要么已经执行结束，要么尚未发生，即其他线程不会&quot;看到&quot;该操作线程执行了部分的中间效果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在生活中我们可以找到的一个原子操作的例子就是人们从 ATM 机提取现金; 尽管从ATM软件的角度来说，一笔交易涉及扣减主账户余额、吐钞器吐出钞票、新增交易记录等一系列操作，但是从用户的角度来看 ATM取款就是一个操作。 该操作要么成功了，我们拿到了现金。要么失败了，我们没有拿到现金。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;理解原子操作要注意以下两点:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;原子操作是针对访问共享变量的操作而言的&lt;/li&gt;
&lt;li&gt;原子操作是从该操作的执行线程以外的线程来描述的&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;总的来说，&lt;strong&gt;Java 中有两种方式来实现原子性。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一种是使用锁(Lock)。&lt;/strong&gt;锁具有排他性，即它能保证一个共享变量在任意时刻只能够被一个线程访问。这就排除了多个线程在同一时刻访问通一个共享变量而导致干扰与冲突的可能，即消除了竞态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;另一种是利用处理器处理器专门提供的 CAS(Compare-and-Swap)指令&lt;/strong&gt; ,CAS 指令实现原子性的方式与锁实现原子性的方式实质上相同的，差别在于锁通常是在软件这一层次实现的，而CAS 是直接在硬件(处理器和内存) 这一层次实现的，它可以被看作&quot;硬件锁&quot;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在Java 语言中,long型 和 double型 以外的任何基础类型的变量的写操作 都是原子操作。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对 long/double 型变量的写操作 由于 &lt;strong&gt;Java语言规范并不保障其具有原子性&lt;/strong&gt;,因此多个线程并发访问同 一 long/double型变量的情况下，一个线程可能会读取到其他线程更新该变量的&quot;中间结果&quot;(64位的虚拟机应该不会出现这个问题);&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注：使用32位虚拟机 用对个线程对long,double型数据进行操作 会有低32位 高32位的问题，尽管如此可以使用volatile关键字进行解决，它可以保证变量写操作的原子性，即线程共享变量 刷新到主存这个动作是原子的&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;可见性&quot;&gt;1.3.2 可见性&lt;/h3&gt;
&lt;p&gt;在多线程环境下,一个线程对某个共享变量进行更新后，后续访问该变量的线程可能无法立刻读取到这个更新的结果，甚至永远无法读取到这个更新的结果。这就是线程安全问题的另外一个表现形式：&lt;strong&gt;可见性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;下面我们来一个Demo吧&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ThreadVolatile{
    public static void main(String[] args) {
        ThreadDemo td = new ThreadDemo(); //01
        new Thread(td).start();//02
        
        while(true){
            if(td.isFlag()){//03
                System.out.println(&quot;-----------------&quot;);
                break;
            }
        }
    }
}

class ThreadDemo implements Runnable{
    
    private boolean flag = false;
    
    @Override
    public void run() {
        //此处的目的 是让main线程 从主存那 先获取flag等于false的值 
        try {
            Thread.sleep(200);
        } catch (Exception e) {
        }
        flag = true;//04
        System.out.println(&quot;flag=&quot; + flag);
    }
    
    public boolean isFlag(){
        return flag;
    }
    
    public void setFlag(boolean flag){
        this.flag = flag;
    }
    
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;运行结果:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​ &lt;strong&gt;打印flag=true, 但循环无法终止&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在解释原因之前先说几个概念:(很重要)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;栈：线程独有，保存其运行状态以及局部自动变量，操作系统在切换线程的时候会自动切换栈，也就是切换寄存器&lt;/li&gt;
&lt;li&gt;堆：保存对象的实体以及全局变量，可以把堆内存 约看成 主内存&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;01-初始化完ThreadDemo 内存空间：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1348730/201901/1348730-20190123231845812-2097377008.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;02.子线程ThreadDemo启动 获取到flag=false的值 开始睡觉&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1348730/201901/1348730-20190123231857840-633102842.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;03.main线程获得了flag=false的值 在循环体中跑了若干次&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1348730/201901/1348730-20190123231912565-2094151350.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;04.由于03步骤main线程获得了flag=flase,虽然主存变了,但是由于while(true)执行效率太高,根本没有时间让主存中的数据同步到main线程中去,所以main线程一直在死循环&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1348730/201901/1348730-20190123231924383-2109692620.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那么，在Java平台中 如何保证可见性呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于上例Demo,我们只需将其flag的声明添加一个&lt;strong&gt;volatile&lt;/strong&gt;关键字即可，即&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private volatile boolean flag = false;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;这里，volatile关键字所起到的一个作用就是，提示JIT编译器被修饰的变量可能被多个线程共享，以组织JIT编译器做出可能导致运行不正常的优化 (重排序)。另外一个作用就是 &lt;u&gt;读取一个volatile关键字所修饰的变量会使相应的处理器执行刷新处理器缓存的动作&lt;/u&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;有序性&quot;&gt;1.3.3 有序性&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;有序性&lt;/strong&gt; 指在什么情况下一个处理器上的运行的一个线程所执行的内存访问操作在另外一个处理器上运行的其他线程看来是乱序的。(&lt;u&gt;某书定义&lt;/u&gt;)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我的理解：程序运行顺序要与代码逻辑顺序保持基本一致，避免多线程情况由于重排导致的错误&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所谓乱序，是指内存访问操作的顺序看起来像是发生了变化。在进一步介绍有序性概念之前，我们需要介绍重排序的概念&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;重排序:&lt;/strong&gt;是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;指令重排序：源代码顺序与程序顺序不一致，或者程序顺序与执行顺序不一致的情况下 (编译器，处理器)&lt;/li&gt;
&lt;li&gt;存储子系统重排：源代码顺序、程序顺序和执行顺序这三者保持一致，但是感知顺序与执行顺序不一致 (高速缓存，写缓冲器)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;注：这一块建议了解编译原理 以及汇编&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;as-if-serial语义：&lt;/strong&gt;编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变程序执行结果。但是，如果操作之间不存在数据依赖关系，这些操作就可以被编译器和处理器重排序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;double pi = 3.14;  // A 
double r = 1.0;     //B
double area = pi * r * r; //C&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;分析：A与C之间存在数据依赖关系，所以C不能排到A的前面，同时B与C之间也存在数据依赖关系，所以，C也不能排到B的前面，但是A与B之间是不存在数据依赖关系的，所以A与B之间是可以进行重排序的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;程序顺序规则：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;根据&lt;strong&gt;happens-before&lt;/strong&gt;的程序规则，上面的计算圆的示例代码存在3个happens-before关系：&lt;/p&gt;
&lt;p&gt;A happens-before B ; B happens-before C; A happens-before C;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;重排序对多线程的影响：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class RecorderExample{
    int a = 0;
    boolean flag = false;
    public void writer(){
        a = 1; // 1
        flag = true; // 2
}
    public void reader(){
        if(flag){          // 3
            int i = a * a;  // 4
             ......
    }
} 
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;flag是一个变量，用来表示变量a是否已被写入。这里假设有两个线程A和B ，A线程首先执行writer方法，随后线程B执行reader方法。线程B在执行操作4的时候，能否看到线程A在操作共享变量a的写入呢?&lt;/p&gt;
&lt;p&gt;答案是：在多线程的情况下，不一定能看到；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;由于操作1和操作2没有数据依赖的关系，编译器和处理器可以对这两个操作进行重排序，操作3和操作4没有数据依赖关系，编译器和处理器也可以对其进行重排序，下面我们看一下可能的执行情况的示意图：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1348730/201901/1348730-20190123231953011-482522817.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上所示，操作1 和操作2 进行了重排序。程序执行时，线程A首先写标记变量flag，随后线程B读这个变量。由于判断条件为真，线程B将读取变量a。此时，变量a还没有被线程A写入，所以在这里，多项层程序的语义就被重排序破坏了。&lt;/p&gt;
&lt;p&gt;下面在看一下操作3和操作4重排序会发生什么效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1348730/201901/1348730-20190123232008348-1947410608.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在程序中，操作3和操作4存在控制依赖关系。当代码中存在控制依赖行时，会影响指令序列执行的并行度。为此，编译器和处理器会采用猜测执行来克服控制相关性对并行度的影响。以处理器的猜测执行为例，执行线程B的处理器可以提前读取并计算a*a,然后把计算结果临时保存到一个名为重排序缓冲的硬件缓存中。当操作3的条件判断为真的时候，就把该结算结果写入到变量i中。&lt;/p&gt;
&lt;p&gt;从上图我们可以看出，猜测执行实质上是对操作3和操作4进行了重排序，重排序在这里破坏了多线程程序的语义。&lt;/p&gt;
&lt;p&gt;在单线程程序中，对存在控制依赖的操作进行重排序，不会改变执行结果（这也是as-if-serial 语义允许对存在控制依赖的操作做重排序的原因），但是在多线程的程序中，对存在控制依赖的操作重排序，可能会改变程序的执行结果。&lt;/p&gt;
</description>
<pubDate>Wed, 23 Jan 2019 15:22:00 +0000</pubDate>
<dc:creator>丁可乐</dc:creator>
<og:description>If I had only one hour to save the worlds,I would spend fifty five minutes defining the problem,and</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dwlovelife/p/9944085.html</dc:identifier>
</item>
<item>
<title>spring之旅第三篇-spring配置详解 - 茶底世界</title>
<link>http://www.cnblogs.com/yuanqinnan/p/10312037.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuanqinnan/p/10312037.html</guid>
<description>&lt;p&gt;上一篇学习了IOC的概念并初步分析了实现原理，这篇主要学习spring的配置，话不多说，让我们开始！&lt;/p&gt;
&lt;h2&gt;一、&lt;span class=&quot;md-expand&quot;&gt;Bean元素配置&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span class=&quot;md-expand&quot;&gt;1.1 &lt;/span&gt;&lt;span class=&quot;md-expand&quot;&gt;基本配置&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;看一个最基本的bean配置&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;hello&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;com.yuanqinnan.test.HelloWorld&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;上面的配置中，我们将bean交给spring管理，看其中属性字段：&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;0.5&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;class：被管理对象的完整类名&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;name：被管理对象的名称，可以通过名称获取改对象（可以重复，可以使用特殊字符）&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;id：与name作用相同（不可以重复，不可以使用特殊字符）&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 class=&quot;md-end-block&quot;&gt;&lt;span&gt;1.2 &lt;/span&gt;&lt;span class=&quot;md-expand&quot;&gt;bean的进阶配置&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;scope属性&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;3&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;singleton：定义bean的范围为每个Spring容器一个实例（默认值）&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;prototype：定义bean可以被多次实例化（使用一次就创建一次）&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;request：定义bean的范围是HTTP请求，只有再使用有web能力的spring上下文时有效。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;request：定义bean的范围是HTTP请求，只有再使用有web能力的spring上下文时有效。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;global-session：定义bean的范围是全局HTTP会话，只有再portlet上下文中有效。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;生命周期属性&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;0&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;init-method：配置一个方法作为生命周期初始化方法.spring会在对象创建之后立即调用.&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;destory-method：配置一个方法作为生命周期的销毁方法.spring容器在关闭并销毁所有容器中的对象之前调用.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;代码如下&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;hello&quot;&lt;/span&gt;&lt;span&gt;  init-method&lt;/span&gt;&lt;span&gt;=&quot;getInfo&quot;&lt;/span&gt;&lt;span&gt; destroy-method&lt;/span&gt;&lt;span&gt;=&quot;destory&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;com.yuanqinnan.test.HelloWorld&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;注意，只有singleton的bean,destory-method才有效&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;strong&gt;1.3实例化bean的方式&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;ol class=&quot;ol-list&quot; start=&quot;&quot; readability=&quot;-2&quot;&gt;&lt;li class=&quot;md-list-item md-focus-container&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;使用类构造器实例化(默认无参数)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;hello&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;com.yuanqinnan.test.HelloWorld&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ol class=&quot;ol-list&quot; start=&quot;2&quot; readability=&quot;-2&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;使用静态工厂方法实例化(简单工厂模式)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HellowWorldFactory {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; HelloWorld createHellowWorld(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;  &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HelloWorld();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;hello2&quot;&lt;/span&gt;&lt;span&gt; 
          class&lt;/span&gt;&lt;span&gt;=&quot;com.yuanqinnan.test.HellowWorldFactory&quot;&lt;/span&gt;&lt;span&gt;
          factory-method&lt;/span&gt;&lt;span&gt;=&quot;createHellowWorld&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ol class=&quot;ol-list&quot; start=&quot;3&quot; readability=&quot;-2&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;使用实例工厂方法实例化(工厂方法模式)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HellowWorldFactory2 {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;  HelloWorld createHellowWorld(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HelloWorld();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;HellowWorldFactory2&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;com.yuanqinnan.test.HellowWorldFactory2&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;hello3&quot;&lt;/span&gt;&lt;span&gt; factory-bean&lt;/span&gt;&lt;span&gt;=&quot;HellowWorldFactory2&quot;&lt;/span&gt;&lt;span&gt; factory-method&lt;/span&gt;&lt;span&gt;=&quot;createHellowWorld&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 class=&quot;md-fences md-end-block ty-contain-cm modeLoaded&quot;&gt;&lt;span&gt;&lt;span class=&quot;cm-tag cm-bracket&quot;&gt;&lt;span class=&quot;cm-tag&quot;&gt;&lt;span class=&quot;cm-attribute&quot;&gt;&lt;span class=&quot;cm-string&quot;&gt;&lt;span class=&quot;cm-attribute&quot;&gt;&lt;span class=&quot;cm-string&quot;&gt;&lt;span class=&quot;cm-tag cm-bracket&quot;&gt;&lt;span&gt;&lt;span class=&quot;cm-tag cm-bracket&quot;&gt;&lt;span class=&quot;cm-tag&quot;&gt;&lt;span class=&quot;cm-attribute&quot;&gt;&lt;span class=&quot;cm-string&quot;&gt;&lt;span class=&quot;cm-attribute&quot;&gt;&lt;span class=&quot;cm-string&quot;&gt;&lt;span class=&quot;cm-attribute&quot;&gt;&lt;span class=&quot;cm-string&quot;&gt;&lt;span class=&quot;cm-tag cm-bracket&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;1.4 spring的分模块配置&lt;/strong&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;spring 允许多个文件进行配置，可以按照模块来进行配置&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;import &lt;/span&gt;&lt;span&gt;resource&lt;/span&gt;&lt;span&gt;=&quot;applicationContext2.xml&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span class=&quot;md-expand&quot;&gt;二、spring 属性注入&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span class=&quot;md-expand&quot;&gt;2.1 &lt;/span&gt;&lt;span class=&quot;md-expand&quot;&gt;set方法注入&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;&lt;span class=&quot;md-tag md-raw-inline md-expand&quot;&gt;&amp;lt;bean&amp;gt;&lt;span&gt;元素的&lt;span class=&quot;md-tag md-raw-inline&quot;&gt;&amp;lt;property&amp;gt;&lt;span&gt;子元素指明了使用它们的set方法来注入，可以使用property的value属性来注入简单类型&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;user&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;com.yuanqinnan.test.User&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;值类型注入&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;age&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;18&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;name&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;tom&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 引用类型注入&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;car&quot;&lt;/span&gt;&lt;span&gt; ref&lt;/span&gt;&lt;span&gt;=&quot;car&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;car&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;com.yuanqinnan.test.Car&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;color&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;blue&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;User类与Car类代码就不贴了，应该是可以看得懂。&lt;/p&gt;
&lt;h3&gt;2.2 &lt;span class=&quot;md-expand&quot;&gt;构造函数注入&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;使用constructor-arg来完成构造方法的注入，注入的方式和setter方式注入相同。 可以通过type属性，控制注入的类型 可以通过index属性，控制注入的顺序 可以通过name属性，控制注入的名字&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;user2&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;com.yuanqinnan.test.User&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;constructor-arg &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;name&quot;&lt;/span&gt;&lt;span&gt; index&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;java.lang.String&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;lucy&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;constructor-arg&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;constructor-arg &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;age&quot;&lt;/span&gt;&lt;span&gt; index&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;java.lang.Integer&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;20&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;constructor-arg&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;constructor-arg &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;car&quot;&lt;/span&gt;&lt;span&gt; ref&lt;/span&gt;&lt;span&gt;=&quot;car&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;constructor-arg&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2.3 &lt;span class=&quot;md-expand&quot;&gt;spel注入&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;user3&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;com.yuanqinnan.test.User&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;name&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;#{user.name}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;age&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;#{user2.age}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 引用类型注入 为car属性注入下方配置的car对象&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;car&quot;&lt;/span&gt;&lt;span&gt; ref&lt;/span&gt;&lt;span&gt;=&quot;car&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;三、&lt;span class=&quot;md-expand&quot;&gt;复杂类型注入&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span class=&quot;md-expand&quot;&gt;3.1 数组&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;arr&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;array&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;tom&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;lucy&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ref &lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;=&quot;user2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;array&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.2 &lt;span class=&quot;md-expand&quot;&gt;List&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;list&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;tom&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;lucy&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ref &lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;=&quot;user2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.3 &lt;span class=&quot;md-expand&quot;&gt;Set&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;set&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.jbdc.mysql.Driver&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;root&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ref &lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;=&quot;user&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.4 &lt;span class=&quot;md-expand&quot;&gt;Map&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;map&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;map&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;entry &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;url&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;entry&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;entry &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;user&quot;&lt;/span&gt;&lt;span&gt; value-ref&lt;/span&gt;&lt;span&gt;=&quot;user&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;entry&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;entry &lt;/span&gt;&lt;span&gt;key-ref&lt;/span&gt;&lt;span&gt;=&quot;user3&quot;&lt;/span&gt;&lt;span&gt; value-ref&lt;/span&gt;&lt;span&gt;=&quot;user2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;entry&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;map&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.5 &lt;span class=&quot;md-expand&quot;&gt;Properties&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;prop&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;props&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;prop &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;url&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.jbdc.mysql.Driver&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;prop&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;prop &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;userName&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;root&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;prop&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;prop &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;password&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1234&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;prop&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;props&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;以上是spring的配置详解，都是通过XML装配，下一篇我们学习注解配置&lt;/p&gt;
</description>
<pubDate>Wed, 23 Jan 2019 15:15:00 +0000</pubDate>
<dc:creator>茶底世界</dc:creator>
<og:description>上一篇学习了IOC的概念并初步分析了实现原理，这篇主要学习spring的配置，话不多说，让我们开始！ 一、Bean元素配置 1.1 基本配置 看一个最基本的bean配置 上面的配置中，我们将</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuanqinnan/p/10312037.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core WebApi中使用FluentValidation验证数据模型 - LamondLu</title>
<link>http://www.cnblogs.com/lwqlun/p/10311945.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lwqlun/p/10311945.html</guid>
<description>&lt;blockquote readability=&quot;3.1327433628319&quot;&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;http://anthonygiretti.com/2018/11/18/common-features-in-asp-net-core-2-1-webapi-validation/&quot;&gt;Common features in ASP.NET Core 2.1 WebApi: Validation&lt;/a&gt;&lt;br/&gt;作者：Anthony Giretti&lt;br/&gt;译者：Lamond Lu&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;介绍&quot;&gt;介绍&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201901/65831-20190123224636317-1694891130.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;验证用户输入是一个Web应用中的基本功能。对于生产系统，开发人员通常需要花费大量时间，编写大量的代码来完成这一功能。如果我们使用FluentValidation构建ASP.NET Core Web API，输入验证的任务将比以前容易的多。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;FluentValidation是一个非常流行的构建强类型验证规则的.NET库。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;配置项目&quot;&gt;配置项目&lt;/h2&gt;
&lt;h3 id=&quot;第一步下载fluentvalidation&quot;&gt;第一步：下载FluentValidation&lt;/h3&gt;
&lt;p&gt;我们可以使用Nuget下载最新的&lt;code&gt;FluentValidation&lt;/code&gt;库&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;PM&amp;gt; Install-Package FluentValidation.AspNetCore&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;第二步添加fluentvalidation服务&quot;&gt;第二步：添加FluentValidation服务&lt;/h3&gt;
&lt;p&gt;我们需要在&lt;code&gt;Startup.cs&lt;/code&gt;文件中添加FluentValidation服务&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public void ConfigureServices(IServiceCollection services) 
{ 
   // mvc + validating
   services.AddMvc()
   .SetCompatibilityVersion(CompatibilityVersion.Version_2_1)
   .AddFluentValidation();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;添加校验器&quot;&gt;添加校验器&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;FluentValidation&lt;/code&gt;提供了多种内置的校验器。在下面的例子中，我们可以看到其中的2种&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;em&gt;NotNull&lt;/em&gt;校验器&lt;/li&gt;
&lt;li&gt;&lt;em&gt;NotEmpty&lt;/em&gt;校验器&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;第一步-添加一个需要验证的数据模型&quot;&gt;第一步： 添加一个需要验证的数据模型&lt;/h3&gt;
&lt;p&gt;下面我们添加一个&lt;code&gt;User&lt;/code&gt;类。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class User
{
   public string Gender { get; set; }
   public string FirstName { get; set; }
   public string LastName { get; set; }
   public string SIN { get; set; }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;第二步-添加校验器类&quot;&gt;第二步： 添加校验器类&lt;/h3&gt;
&lt;p&gt;使用&lt;code&gt;FluentValidation&lt;/code&gt;创建校验器类，校验器类都需要继承自一个抽象类&lt;code&gt;AbstractValidator&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class UserValidator : AbstractValidator&amp;lt;User&amp;gt;
{
   public UserValidator()
   {
      // 在这里添加规则
   }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;第三步-添加验证规则&quot;&gt;第三步： 添加验证规则&lt;/h3&gt;
&lt;p&gt;在这个例子中，我们需要验证FirstName, LastName, SIN不能为null, 不能为空。我们也需要验证工卡SIN(Social Insurance Number)编号是合法的&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public static class Utilities
{
   public static bool IsValidSIN(int sin)
   {
      if (sin &amp;lt; 0 || sin &amp;gt; 999999998) return false;

      int checksum = 0;
      for (int i = 4; i != 0; i--)
      {
         checksum += sin % 10;
         sin /= 10;

         int addend = 2 * (sin % 10); 
         
         if (addend &amp;gt;= 10) addend -= 9;
          
         checksum += addend;
         sin /= 10;
      }
         
      return (checksum + sin) % 10 == 0;
   }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面我们在&lt;code&gt;UserValidator&lt;/code&gt;类的构造函数中，添加验证规则&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class UserValidator : AbstractValidator&amp;lt;User&amp;gt;
{
   public UserValidator()
   {
      RuleFor(x =&amp;gt; x.FirstName)
      .NotEmpty()
      .WithMessage(&quot;FirstName is mandatory.&quot;);

      RuleFor(x =&amp;gt; x.LastName)
      .NotEmpty()
      .WithMessage(&quot;LastName is mandatory.&quot;);

      RuleFor(x =&amp;gt; x.SIN)
      .NotEmpty()
      .WithMessage(&quot;SIN is mandatory.&quot;)
      .Must((o, list, context) =&amp;gt;
      {
         if (null != o.SIN)
         {
            context.MessageFormatter.AppendArgument(&quot;SIN&quot;, o.SIN);
            return Utilities.IsValidSIN(int.Parse(o.SIN));
         }
         return true;
      })
     .WithMessage(&quot;SIN ({SIN}) is not valid.&quot;);
   } 
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;第四步-注入验证服务&quot;&gt;第四步： 注入验证服务&lt;/h3&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public void ConfigureServices(IServiceCollection services) 
{ 
   // 添加验证器
   services.AddSingleton&amp;lt;IValidator&amp;lt;User&amp;gt;, UserValidator&amp;gt;();
   // mvc + validating
   services
       .AddMvc()
       .SetCompatibilityVersion(CompatibilityVersion.Version_2_1)
       .AddFluentValidation();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;第五步在startup.cs中管理你的验证错误&quot;&gt;第五步：在&lt;code&gt;Startup.cs&lt;/code&gt;中管理你的验证错误&lt;/h3&gt;
&lt;p&gt;ASP.NET Core 2.1及以上版本中，你可以覆盖ModelState管理的默认行为（ApiBehaviorOptions）&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public void ConfigureServices(IServiceCollection services) 
{ 
   // Validators
   services.AddSingleton&amp;lt;IValidator&amp;lt;User&amp;gt;, UserValidator&amp;gt;();
   // mvc + validating
   services
       .AddMvc()
       .SetCompatibilityVersion(CompatibilityVersion.Version_2_1)
       .AddFluentValidation();

    // override modelstate
    services.Configure&amp;lt;ApiBehaviorOptions&amp;gt;(options =&amp;gt;
    {
       options.InvalidModelStateResponseFactory = (context) =&amp;gt;
       {
          var errors = context.ModelState
              .Values
              .SelectMany(x =&amp;gt; x.Errors
                          .Select(p =&amp;gt; p.ErrorMessage))
              .ToList();
           
          var result = new
          {
             Code = &quot;00009&quot;,
             Message = &quot;Validation errors&quot;,
             Errors = errors
          };
           
          return new BadRequestObjectResult(result);
       };
    });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当数据模型验证失败时，程序会执行这段代码。&lt;/p&gt;
&lt;p&gt;在这个例子，我设置了如何向客户端显示错误。这里返回结果中，我只是包含了一个错误代码，错误消息以及错误对象列表。&lt;/p&gt;
&lt;p&gt;下面让我们看一下最终效果。&lt;/p&gt;
&lt;h2 id=&quot;使用验证器&quot;&gt;使用验证器&lt;/h2&gt;
&lt;p&gt;这里验证器使用起来非常容易。&lt;/p&gt;
&lt;p&gt;你只需要创建一个action, 并将需要验证的数据模型放到action的参数中。&lt;/p&gt;
&lt;p&gt;由于验证服务已在配置中添加，因此当请求这个action时，&lt;code&gt;FluentValidation&lt;/code&gt;将自动验证你的数据模型！&lt;/p&gt;
&lt;h3 id=&quot;第一步创建一个使用待验证数据模型的action&quot;&gt;第一步：创建一个使用待验证数据模型的action&lt;/h3&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;[Route(&quot;api/[controller]&quot;)]
[ApiController]
public class DemoValidationController : ControllerBase
{
   [HttpPost]
   public IActionResult Post(User user)
   {
      return NoContent();
   }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;第二步使用postman测试你的action&quot;&gt;第二步：使用POSTMAN测试你的action&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201901/65831-20190123224644862-1274840787.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;在本篇博客中，我讲解了如何使用&lt;code&gt;FluentValidation&lt;/code&gt;进行数据模型验证。&lt;/p&gt;
&lt;p&gt;本篇源代码&lt;a href=&quot;https://github.com/lamondlu/FluentValidationExample&quot; class=&quot;uri&quot;&gt;https://github.com/lamondlu/FluentValidationExample&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 23 Jan 2019 14:50:00 +0000</pubDate>
<dc:creator>LamondLu</dc:creator>
<og:description>原文链接： 'Common features in ASP.NET Core 2.1 WebApi: Validation' 作者：Anthony Giretti 译者：Lamond Lu 介绍 验证</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lwqlun/p/10311945.html</dc:identifier>
</item>
<item>
<title>【分布式缓存系列】集群环境下Redis分布式锁的正确姿势 - Learning hard</title>
<link>http://www.cnblogs.com/zhili/p/redLock_DistributedLock.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhili/p/redLock_DistributedLock.html</guid>
<description>&lt;h2&gt;一、前言&lt;/h2&gt;
&lt;p&gt;　　在上一篇文章中，已经介绍了基于Redis实现分布式锁的正确姿势，但是上篇文章存在一定的缺陷——它加锁只作用在一个Redis节点上，如果通过sentinel保证高可用，如果master节点由于某些原因发生了主从切换，那么就会出现锁丢失的情况：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt; 客户端1在Redis的master节点上拿到了锁&lt;/li&gt;
&lt;li&gt;Master宕机了，存储锁的key还没有来得及同步到Slave上&lt;/li&gt;
&lt;li&gt;master故障，发生故障转移，slave节点升级为master节点&lt;/li&gt;
&lt;li&gt;客户端2从新的Master获取到了对应同一个资源的锁&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　于是，客户端1和客户端2同时持有了同一个资源的锁。锁的安全性被打破了。针对这个问题。Redis作者antirez提出了RedLock算法来解决这个问题&lt;/p&gt;
&lt;h2&gt;二、RedLock算法的实现思路&lt;/h2&gt;
&lt;p&gt;　　antirez提出的redlock算法实现思路大概是这样的。&lt;/p&gt;
&lt;p&gt;　　客户端按照下面的步骤来获取锁：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;获取当前时间的毫秒数T1。&lt;/li&gt;
&lt;li&gt;按顺序依次向N个Redis节点执行获取锁的操作。这个获取锁的操作和上一篇中基于单Redis节点获取锁的过程相同。包括唯一UUID作为Value以及锁的过期时间(expireTime)。为了保证在某个在某个Redis节点不可用的时候算法能够继续运行，这个获取锁的操作还需要一个超时时间。它应该远小于锁的过期时间。客户端向某个Redis节点获取锁失败后，应立即尝试下一个Redis节点。这里失败包括Redis节点不可用或者该Redis节点上的锁已经被其他客户端持有。&lt;/li&gt;
&lt;li&gt;计算整个获取锁过程的总耗时。即当前时间减去第一步记录的时间。计算公司为T2=now()- T1。如果客户端从大多数Redis节点(&amp;gt;N/2 +1)成功获取到锁。并且获取锁总共消耗的时间小于锁的过期时间（即T2&amp;lt;expireTime）。则认为客户端获取锁成功，否则，认为获取锁失败&lt;/li&gt;
&lt;li&gt;如果获取锁成功，需要重新计算锁的过期时间。它等于最初锁的有效时间减去第三步计算出来获取锁消耗的时间，即expireTime - T2&lt;/li&gt;
&lt;li&gt;如果最终获取锁失败，那么客户端立即向所有Redis系欸但发起释放锁的操作。（和上一篇释放锁的逻辑一样）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　虽然说RedLock算法可以解决单点Redis分布式锁的安全性问题，但如果集群中有节点发生崩溃重启，还是会锁的安全性有影响的。具体出现问题的场景如下：&lt;/p&gt;
&lt;p&gt;　　假设一共有5个Redis节点：A, B, C, D, E。设想发生了如下的事件序列：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;客户端1成功锁住了A, B, C，&lt;strong&gt;获取锁&lt;/strong&gt;成功（但D和E没有锁住）&lt;/li&gt;
&lt;li&gt;节点C崩溃重启了，但客户端1在C上加的锁没有持久化下来，丢失了&lt;/li&gt;
&lt;li&gt;节点C重启后，客户端2锁住了C, D, E，&lt;strong&gt;获取锁&lt;/strong&gt;成功&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　这样，客户端1和客户端2同时获得了锁（针对同一资源）。针对这样场景，解决方式也很简单，也就是让Redis崩溃后延迟重启，并且这个延迟时间大于锁的过期时间就好。这样等节点重启后，所有节点上的锁都已经失效了。也不存在以上出现2个客户端获取同一个资源的情况了。　&lt;/p&gt;
&lt;p&gt;　　相比之下，RedLock安全性和稳定性都比前一篇文章中介绍的实现要好很多，但要说完全没有问题不是。例如，如果客户端获取锁成功后，如果访问共享资源操作执行时间过长，导致锁过期了，后续客户端获取锁成功了，这样在同一个时刻又出现了2个客户端获得了锁的情况。所以针对分布式锁的应用的时候需要多测试。服务器台数越多，出现不可预期的情况也越多。如果客户端获取锁之后，在上面第三步发生了GC得情况导致GC完成后，锁失效了，这样同时也使得同一时间有2个客户端获得了锁。如果系统对共享资源有非常严格要求得情况下，还是建议需要做数据库锁得得方案来补充。如飞机票或火车票座位得情况。对于一些抢购获取，针对偶尔出现超卖，后续可以人为沟通置换得方式采用分布式锁得方式没什么问题。因为可以绝大部分保证分布式锁的安全性。&lt;/p&gt;
&lt;h2&gt;三、分布式场景下基于Redis实现分布式锁的正确姿势&lt;/h2&gt;
&lt;p&gt;　　目前redisson包已经有对redlock算法封装，接下来就具体看看使用redisson包来实现分布式锁的正确姿势。&lt;/p&gt;
&lt;p&gt;　　具体实现代码如下代码所示：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; DistributedLock {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获取锁
     * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; zhi.li
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 锁标识
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    String acquire();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 释放锁
     * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; zhi.li
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; indentifier
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; release(String indentifier);
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; RedisDistributedRedLock &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; DistributedLock {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * redis 客户端
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; RedissonClient redissonClient;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 分布式锁的键值
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String lockKey;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; RLock redLock;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 锁的有效时间 10s
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; expireTime = 10 * 1000&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获取锁的超时时间
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; acquireTimeout  = 500&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; RedisDistributedRedLock(RedissonClient redissonClient, String lockKey) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.redissonClient =&lt;span&gt; redissonClient;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.lockKey =&lt;span&gt; lockKey;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String acquire() {
        redLock &lt;/span&gt;=&lt;span&gt; redissonClient.getLock(lockKey);
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isLock;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
            isLock &lt;/span&gt;=&lt;span&gt; redLock.tryLock(acquireTimeout, expireTime, TimeUnit.MILLISECONDS);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(isLock){
                System.out.println(Thread.currentThread().getName() &lt;/span&gt;+ &quot; &quot; + lockKey + &quot;获得了锁&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            }
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e){
            e.printStackTrace();
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; release(String indentifier) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;null&lt;/span&gt; !=&lt;span&gt; redLock){
            redLock.unlock();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　由于RedLock是针对主从和集群场景准备。上面代码采用哨兵模式。所以要让上面代码运行起来，需要先本地搭建Redis哨兵模式。本人的环境是Windows,具体Windows 哨兵环境搭建参考文章：&lt;a href=&quot;https://blog.csdn.net/liuchuanhong1/article/details/53206028&quot; target=&quot;_blank&quot;&gt;redis sentinel部署(Windows下实现)&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;　　具体测试代码如下所示：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RedisDistributedRedLockTest {
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; n = 5&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; secskill() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(n &amp;lt;= 0&lt;span&gt;) {
            System.out.println(&lt;/span&gt;&quot;抢购完成&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }

        System.out.println(&lt;/span&gt;--&lt;span&gt;n);
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {

        Config config &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Config();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;支持单机，主从，哨兵，集群等模式
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;此为哨兵模式&lt;/span&gt;
&lt;span&gt;        config.useSentinelServers()
                .setMasterName(&lt;/span&gt;&quot;mymaster&quot;&lt;span&gt;)
                .addSentinelAddress(&lt;/span&gt;&quot;127.0.0.1:26369&quot;,&quot;127.0.0.1:26379&quot;,&quot;127.0.0.1:26389&quot;&lt;span&gt;)
                .setDatabase(&lt;/span&gt;0&lt;span&gt;);
        Runnable runnable &lt;/span&gt;= () -&amp;gt;&lt;span&gt; {
            RedisDistributedRedLock redisDistributedRedLock &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            RedissonClient redissonClient &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                redissonClient &lt;/span&gt;=&lt;span&gt; Redisson.create(config);
                redisDistributedRedLock &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; RedisDistributedRedLock(redissonClient, &quot;stock_lock&quot;&lt;span&gt;);
                redisDistributedRedLock.acquire();
                secskill();
                System.out.println(Thread.currentThread().getName() &lt;/span&gt;+ &quot;正在运行&quot;&lt;span&gt;);
            } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (redisDistributedRedLock != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    redisDistributedRedLock.release(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
                }

                redissonClient.shutdown();
            }
        };

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 10; i++&lt;span&gt;) {
            Thread t &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(runnable);
            t.start();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　具体的运行结果，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/383187/201901/383187-20190123222143177-819484498.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;四、总结&lt;/h2&gt;
&lt;p&gt;　　到此，基于Redis实现分布式锁的就告一段落了，由于分布式锁的实现方式主要有：数据库锁的方式、基于Redis实现和基于Zookeeper实现。接下来的一篇文章将介绍基于Zookeeper分布式锁的正确姿势。&lt;/p&gt;
&lt;p&gt;　　本文所有代码地址：&lt;a href=&quot;https://github.com/learninghard-lizhi/common-util&quot; target=&quot;_blank&quot;&gt;https://github.com/learninghard-lizhi/common-util &lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 23 Jan 2019 14:30:00 +0000</pubDate>
<dc:creator>Learning hard</dc:creator>
<og:description>一、前言 在上一篇文章中，已经介绍了基于Redis实现分布式锁的正确姿势，但是上篇文章存在一定的缺陷——它加锁只作用在一个Redis节点上，如果通过sentinel保证高可用，如果master节点由于</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhili/p/redLock_DistributedLock.html</dc:identifier>
</item>
<item>
<title>集群选举算法实现 - 铁芒箕</title>
<link>http://www.cnblogs.com/bwar/p/10311894.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bwar/p/10311894.html</guid>
<description>&lt;p&gt;一个分布式服务集群管理通常需要一个协调服务，提供服务注册、服务发现、配置管理、组服务等功能，而协调服务自身应是一个高可用的服务集群，ZooKeeper是广泛应用且众所周知的协调服务。协调服务自身的高可用需要选举算法来支撑，本文将讲述选举原理并以分布式服务集群&lt;a href=&quot;https://github.com/Bwar/NebulaBootstrap&quot;&gt;NebulaBootstrap&lt;/a&gt;的协调服务&lt;a href=&quot;https://github.com/Bwar/NebulaBeacon&quot;&gt;NebulaBeacon&lt;/a&gt;为例详细说明协调服务的选举实现。&lt;/p&gt;
&lt;p&gt;  为什么要选NebulaBeacon来说明协调服务的选举实现？一方面是我没有读过Zookeeper的代码，更重要的另一方面是NebulaBeacon的选举实现只有两百多行代码，简单精炼，很容易讲清楚。基于高性能C++网络框架&lt;a href=&quot;https://github.com/Bwar/Nebula&quot;&gt;Nebula&lt;/a&gt;实现的分布式服务集群&lt;a href=&quot;https://github.com/Bwar/NebulaBootstrap&quot;&gt;NebulaBootstrap&lt;/a&gt;是一种用C++快速构建高性能分布式服务的解决方案。&lt;/p&gt;
&lt;p&gt;  为什么要实现自己的协调服务而不直接用Zookeeper？想造个C++的轮子，整个集群都是C++服务，因为选了ZooKeeper而需要部署一套Java环境，配置也跟其他服务不是一个体系，实在不是一个好的选择。Spring Cloud有Eureka，NebulaBootstrap有NebulaBeacon，未来NebulaBootstrap会支持ZooKeeper，不过暂无时间表，还是首推NebulaBeacon。&lt;/p&gt;
&lt;h3 id=&quot;h3_1&quot;&gt;1. 选举算法选择&lt;/h3&gt;
&lt;p&gt;  Paxos算法 和 ZooKeeper ZAB协议 是两种较广为人知的选举算法。ZAB协议主要用于构建一个高可用的分布式数据主备系统，例如ZooKeeper，而Paxos算法则是用于构建一个分布式的一致性状态机系统。也有很多应用程序采用自己设计的简单的选举算法，这类型简单的选举算法通常依赖计算机自身因素作为选举因子，比如IP地址、CPU核数、内存大小、自定义序列号等。&lt;/p&gt;
&lt;p&gt;  Paxos规定了四种角色（Proposer，Acceptor，Learner，以及Client）和两个阶段（Promise和Accept）。   ZAB服务具有四种状态：LOOKING、FOLLOWING、LEADING、OBSERVING。   NebulaBeacon是高可用分布式系统的协调服务，采用ZAP协议更为合适，不过ZAP协议还是稍显复杂了，NebulaBeacon的选举算法实现基于节点的IP地址标识，选举速度快，实现十分简单。&lt;/p&gt;
&lt;h3 id=&quot;h3_2&quot;&gt;2. 选举相关数据结构&lt;/h3&gt;
&lt;p&gt;  NebulaBeacon的选举相关数据结构非常简单：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs C++&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const uint32 SessionOnlineNodes::mc_uiLeader = &lt;span class=&quot;hljs-number&quot;&gt;0x80000000;   &lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  如上数据结构m_mapBeacon保存了Beacon集群各Beacon节点信息，以Beacon节点的IP地址标识为key排序，每次遍历均从头开始，满足条件（1&amp;amp;&amp;amp;2 或者 1&amp;amp;&amp;amp;3）则标识为Leader：1. 节点在线；2. 已经成为Leader； 3. 整个列表中不存在在线的Leader，而节点处于在线节点列表的首位。&lt;/p&gt;
&lt;h3 id=&quot;h3_3&quot;&gt;3. Beacon选举流程&lt;/h3&gt;
&lt;p&gt;  Beacon选举基于节点IP地址标识，实现非常简单且高效。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs json&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;beacon&quot;:[&lt;span class=&quot;hljs-string&quot;&gt;&quot;192.168.1.11:16000&quot;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;192.168.1.12:16000&quot;]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  进程启动时首先检查&lt;a href=&quot;https://github.com/Bwar/NebulaBeacon/blob/master/conf/NebulaBeacon.json&quot;&gt;Beacon集群配置&lt;/a&gt;，若未配置其他Beacon节点信息，则默认只有一个Beacon节点，此时该节点在启动时自动成为Leader节点。否则，向其他Beacon节点发送一个心跳消息，等待定时器回调检查并选举出Leader节点。选举流程如下图：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;zoom-in-cursor&quot; title=&quot;Beacon选举流程&quot; src=&quot;https://oscimg.oschina.net/oscnet/23871d87cd7e51f776866b09c36890634c2.jpg&quot; alt=&quot;Beacon选举流程&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  检查是否在线就是通过检查两次定时器回调之间是否收到了其他Beacon节点的心跳消息。对m_mapBeacon的遍历检查判断节点在线情况，对已离线的Leader节点置为离线状态，若当前节点应成为Leader节点则成为Leader节点。&lt;/p&gt;
&lt;h3 id=&quot;h3_4&quot;&gt;4. Beacon节点间选举通信&lt;/h3&gt;
&lt;p&gt;  Beacon节点间的选举通信与节点心跳合为一体，这样做的好处是当leader节点不可用时，fllower节点立刻可以成为leader节点，选举过程只需每个fllower节点遍历自己内存中各Beacon节点的心跳信息即可，无须在发现leader不在线才发起选举，更快和更好地保障集群的高可用性。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;zoom-in-cursor&quot; title=&quot;Beacon间心跳&quot; src=&quot;https://oscimg.oschina.net/oscnet/c278d5b0a4089a311d98433e46b65c0cd16.jpg&quot; alt=&quot;Beacon间心跳&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  Beacon节点心跳信息带上了leader节点作为协调服务产生的新数据，fllower节点在接收心跳的同时完成了数据同步，保障任意一个fllower成为leader时已获得集群所有需协调的信息并可随时切换为leader。除定时器触发的心跳带上协调服务产生的新数据之外，leader节点产生新数据的同时会立刻向fllower发送心跳。&lt;/p&gt;
&lt;h3 id=&quot;h3_5&quot;&gt;5. Beacon选举实现&lt;/h3&gt;
&lt;p&gt;  Beacon心跳协议proto：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs proto php&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;  检查Beacon配置，若只有一个Beacon节点则自动成为Leader：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs C++&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void SessionOnlineNodes::InitElection(&lt;span class=&quot;hljs-keyword&quot;&gt;const neb::CJsonObject&amp;amp; oBeacon)
{
    neb::CJsonObject oBeaconList = oBeacon;
    &lt;span class=&quot;hljs-keyword&quot;&gt;for (&lt;span class=&quot;hljs-keyword&quot;&gt;int i = &lt;span class=&quot;hljs-number&quot;&gt;0; i &amp;lt; oBeaconList.GetArraySize(); ++i)
    {
        m_mapBeacon.insert(&lt;span class=&quot;hljs-built_in&quot;&gt;std::make_pair(oBeaconList(i) + &lt;span class=&quot;hljs-string&quot;&gt;&quot;.1&quot;, &lt;span class=&quot;hljs-number&quot;&gt;0));
    }
    &lt;span class=&quot;hljs-keyword&quot;&gt;if (m_mapBeacon.size() == &lt;span class=&quot;hljs-number&quot;&gt;0)
    {
        m_bIsLeader = &lt;span class=&quot;hljs-literal&quot;&gt;true;
    }
    &lt;span class=&quot;hljs-keyword&quot;&gt;else &lt;span class=&quot;hljs-keyword&quot;&gt;if (m_mapBeacon.size() == &lt;span class=&quot;hljs-number&quot;&gt;1
            &amp;amp;&amp;amp; GetNodeIdentify() == m_mapBeacon.begin()-&amp;gt;first)
    {
        m_bIsLeader = &lt;span class=&quot;hljs-literal&quot;&gt;true;
    }
    &lt;span class=&quot;hljs-keyword&quot;&gt;else
    {
        SendBeaconBeat();
    }
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  发送Beacon心跳：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs C++&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void SessionOnlineNodes::SendBeaconBeat()
{
    LOG4_TRACE(&lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;);
    MsgBody oMsgBody;
    Election oElection;
    &lt;span class=&quot;hljs-keyword&quot;&gt;if (m_bIsLeader)
    {
        oElection.set_is_leader(&lt;span class=&quot;hljs-number&quot;&gt;1);
        oElection.set_last_node_id(m_unLastNodeId);
        &lt;span class=&quot;hljs-keyword&quot;&gt;for (&lt;span class=&quot;hljs-keyword&quot;&gt;auto it = m_setAddedNodeId.begin(); it != m_setAddedNodeId.end(); ++it)
        {
            oElection.add_added_node_id(*it);
        }
        &lt;span class=&quot;hljs-keyword&quot;&gt;for (&lt;span class=&quot;hljs-keyword&quot;&gt;auto it = m_setRemovedNodeId.begin(); it != m_setRemovedNodeId.end(); ++it)
        {
            oElection.add_removed_node_id(*it);
        }
    }
    &lt;span class=&quot;hljs-keyword&quot;&gt;else
    {
        oElection.set_is_leader(&lt;span class=&quot;hljs-number&quot;&gt;0);
    }
    m_setAddedNodeId.clear();
    m_setRemovedNodeId.clear();
    oMsgBody.set_data(oElection.SerializeAsString());

    &lt;span class=&quot;hljs-keyword&quot;&gt;for (&lt;span class=&quot;hljs-keyword&quot;&gt;auto iter = m_mapBeacon.begin(); iter != m_mapBeacon.end(); ++iter)
    {
        &lt;span class=&quot;hljs-keyword&quot;&gt;if (GetNodeIdentify() != iter-&amp;gt;first)
        {
            SendTo(iter-&amp;gt;first, neb::CMD_REQ_LEADER_ELECTION, GetSequence(), oMsgBody);
        }
    }
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  接收Beacon心跳：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs C++&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void SessionOnlineNodes::AddBeaconBeat(&lt;span class=&quot;hljs-keyword&quot;&gt;const &lt;span class=&quot;hljs-built_in&quot;&gt;std::&lt;span class=&quot;hljs-built_in&quot;&gt;string&amp;amp; strNodeIdentify, &lt;span class=&quot;hljs-keyword&quot;&gt;const Election&amp;amp; oElection)
{
    &lt;span class=&quot;hljs-keyword&quot;&gt;if (!m_bIsLeader)
    {
        &lt;span class=&quot;hljs-keyword&quot;&gt;if (oElection.last_node_id() &amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;0)
        {
            m_unLastNodeId = oElection.last_node_id();
        }
        &lt;span class=&quot;hljs-keyword&quot;&gt;for (int32 i = &lt;span class=&quot;hljs-number&quot;&gt;0; i &amp;lt; oElection.added_node_id_size(); ++i)
        {
            m_setNodeId.insert(oElection.added_node_id(i));
        }
        &lt;span class=&quot;hljs-keyword&quot;&gt;for (int32 j = &lt;span class=&quot;hljs-number&quot;&gt;0; j &amp;lt; oElection.removed_node_id_size(); ++j)
        {
            m_setNodeId.erase(m_setNodeId.find(oElection.removed_node_id(j)));
        }
    }

    &lt;span class=&quot;hljs-keyword&quot;&gt;auto iter = m_mapBeacon.find(strNodeIdentify);
    &lt;span class=&quot;hljs-keyword&quot;&gt;if (iter == m_mapBeacon.end())
    {
        uint32 uiBeaconAttr = &lt;span class=&quot;hljs-number&quot;&gt;1;
        &lt;span class=&quot;hljs-keyword&quot;&gt;if (oElection.is_leader() != &lt;span class=&quot;hljs-number&quot;&gt;0)
        {
            uiBeaconAttr |= mc_uiLeader;
        }
        m_mapBeacon.insert(&lt;span class=&quot;hljs-built_in&quot;&gt;std::make_pair(strNodeIdentify, uiBeaconAttr));
    }
    &lt;span class=&quot;hljs-keyword&quot;&gt;else
    {
        iter-&amp;gt;second |= &lt;span class=&quot;hljs-number&quot;&gt;1;
        &lt;span class=&quot;hljs-keyword&quot;&gt;if (oElection.is_leader() != &lt;span class=&quot;hljs-number&quot;&gt;0)
        {
            iter-&amp;gt;second |= mc_uiLeader;
        }
    }
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  检查在线leader，成为leader：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs C++&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void SessionOnlineNodes::CheckLeader()
{
    LOG4_TRACE(&lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;);
    &lt;span class=&quot;hljs-built_in&quot;&gt;std::&lt;span class=&quot;hljs-built_in&quot;&gt;string strLeader;
    &lt;span class=&quot;hljs-keyword&quot;&gt;for (&lt;span class=&quot;hljs-keyword&quot;&gt;auto iter = m_mapBeacon.begin(); iter != m_mapBeacon.end(); ++iter)
    {
        &lt;span class=&quot;hljs-keyword&quot;&gt;if (mc_uiAlive &amp;amp; iter-&amp;gt;second)
        {
            &lt;span class=&quot;hljs-keyword&quot;&gt;if (mc_uiLeader &amp;amp; iter-&amp;gt;second)
            {
                strLeader = iter-&amp;gt;first;
            }
            &lt;span class=&quot;hljs-keyword&quot;&gt;else &lt;span class=&quot;hljs-keyword&quot;&gt;if (strLeader.size() == &lt;span class=&quot;hljs-number&quot;&gt;0)
            {
                strLeader = iter-&amp;gt;first;
            }
        }
        &lt;span class=&quot;hljs-keyword&quot;&gt;else
        {
            iter-&amp;gt;second &amp;amp;= (~mc_uiLeader);
        }
        uint32 uiLeaderBit = mc_uiLeader &amp;amp; iter-&amp;gt;second;
        iter-&amp;gt;second = ((iter-&amp;gt;second &amp;lt;&amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;1) &amp;amp; mc_uiAlive) | uiLeaderBit;
        &lt;span class=&quot;hljs-keyword&quot;&gt;if (iter-&amp;gt;first == GetNodeIdentify())
        {
            iter-&amp;gt;second |= &lt;span class=&quot;hljs-number&quot;&gt;1;
        }
    }

    &lt;span class=&quot;hljs-keyword&quot;&gt;if (strLeader == GetNodeIdentify())
    {
        m_bIsLeader = &lt;span class=&quot;hljs-literal&quot;&gt;true;
    }
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h3_6&quot;&gt;6. Beacon节点切换leader&lt;/h3&gt;
&lt;p&gt;  通过Nebula集群的命令行管理工具&lt;a href=&quot;https://github.com/Bwar/Nebcli&quot;&gt;nebcli&lt;/a&gt;可以很方便的查看Beacon节点状态，nebcli的使用说明见Nebcli项目的README。下面启动三个Beacon节点，并反复kill掉Beacon进程和重启，查看leader节点的切换情况。&lt;/p&gt;
&lt;p&gt;  启动三个beacon节点：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs css&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;nebcli): &lt;span class=&quot;hljs-selector-tag&quot;&gt;show &lt;span class=&quot;hljs-selector-tag&quot;&gt;beacon
&lt;span class=&quot;hljs-selector-tag&quot;&gt;node                        &lt;span class=&quot;hljs-selector-tag&quot;&gt;is_leader       &lt;span class=&quot;hljs-selector-tag&quot;&gt;is_online
192&lt;span class=&quot;hljs-selector-class&quot;&gt;.168&lt;span class=&quot;hljs-selector-class&quot;&gt;.157&lt;span class=&quot;hljs-selector-class&quot;&gt;.176&lt;span class=&quot;hljs-selector-pseudo&quot;&gt;:16000.1     &lt;span class=&quot;hljs-selector-tag&quot;&gt;yes             &lt;span class=&quot;hljs-selector-tag&quot;&gt;yes
192&lt;span class=&quot;hljs-selector-class&quot;&gt;.168&lt;span class=&quot;hljs-selector-class&quot;&gt;.157&lt;span class=&quot;hljs-selector-class&quot;&gt;.176&lt;span class=&quot;hljs-selector-pseudo&quot;&gt;:17000.1     &lt;span class=&quot;hljs-selector-tag&quot;&gt;no              &lt;span class=&quot;hljs-selector-tag&quot;&gt;yes
192&lt;span class=&quot;hljs-selector-class&quot;&gt;.168&lt;span class=&quot;hljs-selector-class&quot;&gt;.157&lt;span class=&quot;hljs-selector-class&quot;&gt;.176&lt;span class=&quot;hljs-selector-pseudo&quot;&gt;:18000.1     &lt;span class=&quot;hljs-selector-tag&quot;&gt;no              &lt;span class=&quot;hljs-selector-tag&quot;&gt;yes
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  kill掉leader节点：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs css&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;nebcli): &lt;span class=&quot;hljs-selector-tag&quot;&gt;show &lt;span class=&quot;hljs-selector-tag&quot;&gt;beacon
&lt;span class=&quot;hljs-selector-tag&quot;&gt;node                        &lt;span class=&quot;hljs-selector-tag&quot;&gt;is_leader       &lt;span class=&quot;hljs-selector-tag&quot;&gt;is_online
192&lt;span class=&quot;hljs-selector-class&quot;&gt;.168&lt;span class=&quot;hljs-selector-class&quot;&gt;.157&lt;span class=&quot;hljs-selector-class&quot;&gt;.176&lt;span class=&quot;hljs-selector-pseudo&quot;&gt;:16000.1     &lt;span class=&quot;hljs-selector-tag&quot;&gt;no              &lt;span class=&quot;hljs-selector-tag&quot;&gt;no
192&lt;span class=&quot;hljs-selector-class&quot;&gt;.168&lt;span class=&quot;hljs-selector-class&quot;&gt;.157&lt;span class=&quot;hljs-selector-class&quot;&gt;.176&lt;span class=&quot;hljs-selector-pseudo&quot;&gt;:17000.1     &lt;span class=&quot;hljs-selector-tag&quot;&gt;yes             &lt;span class=&quot;hljs-selector-tag&quot;&gt;yes
192&lt;span class=&quot;hljs-selector-class&quot;&gt;.168&lt;span class=&quot;hljs-selector-class&quot;&gt;.157&lt;span class=&quot;hljs-selector-class&quot;&gt;.176&lt;span class=&quot;hljs-selector-pseudo&quot;&gt;:18000.1     &lt;span class=&quot;hljs-selector-tag&quot;&gt;no              &lt;span class=&quot;hljs-selector-tag&quot;&gt;yes
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  kill掉fllower节点：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs css&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;nebcli): &lt;span class=&quot;hljs-selector-tag&quot;&gt;show &lt;span class=&quot;hljs-selector-tag&quot;&gt;beacon
&lt;span class=&quot;hljs-selector-tag&quot;&gt;node                        &lt;span class=&quot;hljs-selector-tag&quot;&gt;is_leader       &lt;span class=&quot;hljs-selector-tag&quot;&gt;is_online
192&lt;span class=&quot;hljs-selector-class&quot;&gt;.168&lt;span class=&quot;hljs-selector-class&quot;&gt;.157&lt;span class=&quot;hljs-selector-class&quot;&gt;.176&lt;span class=&quot;hljs-selector-pseudo&quot;&gt;:16000.1     &lt;span class=&quot;hljs-selector-tag&quot;&gt;no              &lt;span class=&quot;hljs-selector-tag&quot;&gt;no
192&lt;span class=&quot;hljs-selector-class&quot;&gt;.168&lt;span class=&quot;hljs-selector-class&quot;&gt;.157&lt;span class=&quot;hljs-selector-class&quot;&gt;.176&lt;span class=&quot;hljs-selector-pseudo&quot;&gt;:17000.1     &lt;span class=&quot;hljs-selector-tag&quot;&gt;yes             &lt;span class=&quot;hljs-selector-tag&quot;&gt;yes
192&lt;span class=&quot;hljs-selector-class&quot;&gt;.168&lt;span class=&quot;hljs-selector-class&quot;&gt;.157&lt;span class=&quot;hljs-selector-class&quot;&gt;.176&lt;span class=&quot;hljs-selector-pseudo&quot;&gt;:18000.1     &lt;span class=&quot;hljs-selector-tag&quot;&gt;no              &lt;span class=&quot;hljs-selector-tag&quot;&gt;no
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  重启被kill掉的两个节点：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs css&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;nebcli): &lt;span class=&quot;hljs-selector-tag&quot;&gt;show &lt;span class=&quot;hljs-selector-tag&quot;&gt;beacon
&lt;span class=&quot;hljs-selector-tag&quot;&gt;node                        &lt;span class=&quot;hljs-selector-tag&quot;&gt;is_leader       &lt;span class=&quot;hljs-selector-tag&quot;&gt;is_online
192&lt;span class=&quot;hljs-selector-class&quot;&gt;.168&lt;span class=&quot;hljs-selector-class&quot;&gt;.157&lt;span class=&quot;hljs-selector-class&quot;&gt;.176&lt;span class=&quot;hljs-selector-pseudo&quot;&gt;:16000.1     &lt;span class=&quot;hljs-selector-tag&quot;&gt;no              &lt;span class=&quot;hljs-selector-tag&quot;&gt;yes
192&lt;span class=&quot;hljs-selector-class&quot;&gt;.168&lt;span class=&quot;hljs-selector-class&quot;&gt;.157&lt;span class=&quot;hljs-selector-class&quot;&gt;.176&lt;span class=&quot;hljs-selector-pseudo&quot;&gt;:17000.1     &lt;span class=&quot;hljs-selector-tag&quot;&gt;yes             &lt;span class=&quot;hljs-selector-tag&quot;&gt;yes
192&lt;span class=&quot;hljs-selector-class&quot;&gt;.168&lt;span class=&quot;hljs-selector-class&quot;&gt;.157&lt;span class=&quot;hljs-selector-class&quot;&gt;.176&lt;span class=&quot;hljs-selector-pseudo&quot;&gt;:18000.1     &lt;span class=&quot;hljs-selector-tag&quot;&gt;no              &lt;span class=&quot;hljs-selector-tag&quot;&gt;yes
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  fllower节点在原leader节点不可用后成为leader节点，且只要不宕机则一直会是leader节点，即使原leader节点重新变为可用状态也不会再次切换。&lt;/p&gt;
&lt;h3 id=&quot;h3_7&quot;&gt;7. 结束&lt;/h3&gt;
&lt;p&gt;  开发Nebula框架目的是致力于提供一种基于C++快速构建高性能的分布式服务。如果觉得本文对你有用，别忘了到Nebula的&lt;a href=&quot;https://github.com/Bwar/Nebula&quot;&gt;Github&lt;/a&gt;或&lt;a href=&quot;https://gitee.com/Bwar/Nebula&quot;&gt;码云&lt;/a&gt;给个star，谢谢。&lt;/p&gt;
</description>
<pubDate>Wed, 23 Jan 2019 14:26:00 +0000</pubDate>
<dc:creator>铁芒箕</dc:creator>
<og:description>一个分布式服务集群管理通常需要一个协调服务，提供服务注册、服务发现、配置管理、组服务等功能，而协调服务自身应是一个高可用的服务集群，ZooKeeper是广泛应用且众所周知的协调服务。协调服务自身的高可</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bwar/p/10311894.html</dc:identifier>
</item>
<item>
<title>张高兴的 .NET Core IoT 入门指南：环境配置、Blink、部署 - 张高兴</title>
<link>http://www.cnblogs.com/zhanggaoxing/p/10311697.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhanggaoxing/p/10311697.html</guid>
<description>&lt;p&gt;如何在 Raspberry Pi 的 Raspbian 上构建使用 GPIO 引脚的 IoT 程序？你可能会回答使用 C++ 或 Python 去访问 Raspberry Pi 的引脚。现在，C# 程序员可以使用 .NET Core 在 Raspbian(Linux) 上构建 IoT 应用程序。只需要引入 &lt;strong&gt;System.Device.GPIO&lt;/strong&gt; NuGet 包即可。&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;p&gt;  注意&lt;/p&gt;
&lt;p&gt;System.Device.GPIO 仍处于早期预览状态。并且目前仅支持部分 Raspberry Pi 、 Pine64 和 Hummingboard 的板子。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;若要继续阅读下面的内容，你需要准备：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;安装有 Linux 的 Raspberry Pi 2B/3B/3B+&lt;/li&gt;
&lt;li&gt;Visual Studio 2017&lt;/li&gt;
&lt;li&gt;用于构建程序的 .NET Core SDK （版本大于 2.1）&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;环境配置&quot;&gt;环境配置&lt;/h2&gt;
&lt;ol readability=&quot;0.91849148418491&quot;&gt;&lt;li readability=&quot;3.462962962963&quot;&gt;
&lt;p&gt;首先在 Raspbian 的 Terminal 上运行如下命令，以安装运行程序所依赖的程序包。&lt;br/&gt;&lt;code&gt;sudo apt-get update sudo apt-get install curl libunwind8 gettext apt-transport-https&lt;/code&gt;&lt;br/&gt;&lt;/p&gt;
&lt;div readability=&quot;11.811023622047&quot;&gt;&lt;p&gt;  提示&lt;/p&gt;
&lt;p&gt;&lt;span&gt;① 远程访问 Raspbian 可以使用 putty 通过 SSH 进行访问，也可以使用 apt 安装 xrdp ，通过 Windows 远程桌面进行访问。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;② 运行 ASP.NET Core 程序还需要安装运行时（Runtime）。安装可以参考&lt;a target=&quot;_blank&quot; href=&quot;https://blog.csdn.net/sD7O95O/article/details/812952862&quot;&gt;这个&lt;/a&gt;。（不管是 3B 还是 3B+ ，Raspbian 的内核都为 32 位，部分 ASP.NET Core 常用的 NuGet 包并不支持 arm32）&lt;/span&gt;&lt;/p&gt;
&lt;br/&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;打开菜单中的 Raspberry Pi 配置，获取必要的硬件接口的访问权限。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1085877/201901/1085877-20190123213821543-412511542.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1085877/201901/1085877-20190123213831859-633639378.jpg&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;打开 Visual Studio 的设置，在 NuGet 包管理器设置下，添加 .NET Core Lab 的程序包源：&lt;a href=&quot;https://dotnet.myget.org/F/dotnet-corefxlab/api/v3/index.json&quot; class=&quot;uri&quot;&gt;https://dotnet.myget.org/F/dotnet-corefxlab/api/v3/index.json&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1085877/201901/1085877-20190123213857397-1330695545.jpg&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;blink&quot;&gt;Blink&lt;/h2&gt;
&lt;p&gt;熟悉 Arduino 的朋友都知道，Blink 是默认烧写进 Arduino 的初始程序，控制板载连接 13 号引脚的 LED 闪烁。是一种类似于“Hello World”的存在。这里我们将 LED 小灯连接至 Raspberry Pi 的 GPIO 17 引脚。&lt;/p&gt;
&lt;h3 id=&quot;硬件&quot;&gt;硬件&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;一颗 LED 小灯&lt;/li&gt;
&lt;li&gt;一个 220 Ω 电阻&lt;/li&gt;
&lt;li&gt;若干杜邦线&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;电路&quot;&gt;电路&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1085877/201901/1085877-20190123213908533-979973048.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图源：&lt;a href=&quot;https://github.com/dotnet/iot/tree/master/samples/led-blink&quot; class=&quot;uri&quot;&gt;https://github.com/dotnet/iot/tree/master/samples/led-blink&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;代码&quot;&gt;代码&lt;/h3&gt;
&lt;ol readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;打开 Visual Studio ，新建一个 .NET Core 控制台应用程序，项目名称为“Blink”。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1085877/201901/1085877-20190123213920383-22196706.jpg&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;打开 “工具”——“NuGet包管理器”——“程序包管理器控制台”，运行如下命令，以获取程序包。&lt;br/&gt;&lt;code&gt;Install-Package System.Devices.Gpio -Version 0.1.0-preview2-181222-2&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1085877/201901/1085877-20190123213932405-2102850788.jpg&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;在 Program.cs 中，替换如下代码：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;using System;
using System.Devices.Gpio;
using System.Threading;

namespace Blink
{
    class Program
    {
        static void Main(string[] args)
        {
            // get the GPIO controller
            // 获取 GPIO 控制器
            GpioController controller = new GpioController(PinNumberingScheme.Gpio);
            // open PIN 17
            // 打开引脚 17
            GpioPin ledPin = controller.OpenPin(17, PinMode.Output);

            // define delay time
            // 设置延迟时间
            int time = 1000;

            // loop
            // 循环
            while (true)
            {
                Console.WriteLine($&quot;Light for {time}ms&quot;);
                // turn the LED on
                // 打开 LED
                ledPin.Write(PinValue.High);
                // wait for a second
                // 等待 1s
                Thread.Sleep(time);

                Console.WriteLine($&quot;Dim for {time}ms&quot;);
                // turn the LED off
                // 关闭 LED
                ledPin.Write(PinValue.Low);
                // wait for a second
                // 等待 1s
                Thread.Sleep(time);
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;部署&quot;&gt;部署&lt;/h2&gt;
&lt;ol readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;在“程序包管理器控制台”运行发布命令：&lt;br/&gt;&lt;code&gt;dotnet publish -c release -r linux-arm&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1085877/201901/1085877-20190123213945135-972669238.jpg&quot;/&gt;&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;&lt;p&gt;  提示&lt;/p&gt;
&lt;p&gt;&lt;span&gt;默认的发布路径是在 “\Blink\bin\Release\netcoreappXXX\win10-arm\publish”。你也可以使用 -o 来指定发布路径，如：-o D:\BlinkPublish ，这将会发布在 D 盘的 BlinkPublish 文件夹下。&lt;/span&gt;&lt;/p&gt;
&lt;br/&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;使用 FTP 工具将生成的发布文件夹复制到 Raspberry Pi 上，这里使用的是 WinSCP 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1085877/201901/1085877-20190123213955826-2085051282.jpg&quot;/&gt;&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;&lt;p&gt;  提示&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Raspbian 使用 FTP 服务，请使用 apt 安装 vsftpd 。&lt;/span&gt;&lt;/p&gt;
&lt;br/&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;更改程序权限。使用 cd 命令切换到发布的文件夹，运行：&lt;br/&gt;&lt;code&gt;chmod 755 ./Blink&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;或使用 FTP 工具进行变更&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1085877/201901/1085877-20190123214007100-651877273.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1085877/201901/1085877-20190123214016900-698745092.jpg&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;执行 ./Blink 运行程序，此时 LED 小灯应该一闪一闪的了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1085877/201901/1085877-20190123214027193-1762353955.jpg&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;  备注&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下一篇文章将使用红外传感器进一步熟悉 GPIO 的操作。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Wed, 23 Jan 2019 13:41:00 +0000</pubDate>
<dc:creator>张高兴</dc:creator>
<og:description>如何在 Raspberry Pi 的 Raspbian 上构建使用 GPIO 引脚的 IoT 程序？你可能会回答使用 C++ 或 Python 去访问 Raspberry Pi 的引脚。现在，C 程序</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhanggaoxing/p/10311697.html</dc:identifier>
</item>
<item>
<title>Vue渲染数据理解以及Vue指令 - 心晴安夏</title>
<link>http://www.cnblogs.com/lihuijuan/p/10279589.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lihuijuan/p/10279589.html</guid>
<description>&lt;p&gt;原生JS改变页面数据，必须要获取页面节点，也即是进行DOM操作，jQuery之类的框架只是简化DOM操作的写法，实质并没有改变操作页面数据的底层原理，DOM操作影响性能（导致浏览器的重绘和回流），Vue是一个mvvm框架（库），大幅度减少了DOM操作，操作数据如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1271936/201901/1271936-20190116211850125-43612650.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;View也就是页面，Model是指数据，VM是Vue实例，页面所需的数据或者方法都定义在vm中&lt;/p&gt;
&lt;p&gt;页面通过Vue实例（vm）来获取数据，数据改变是通过改变Vue实例中的数据使展示在页面上的数据发生改变，并不是直接改变页面上的数据。&lt;/p&gt;
&lt;p&gt;注：Vue实例包括根实例（new Vue({})）和组件实例&lt;/p&gt;

&lt;h3&gt;1、v-model：表单控件元素上创建&lt;span&gt;双向数据&lt;/span&gt;绑定。它会根据控件类型自动选取正确的方法来更新元素&lt;/h3&gt;
&lt;p&gt;（&lt;code&gt;v-model&lt;/code&gt; 并不关心表单控件初始化所生成的值。因为它会选择 Vue 实例数据来作为具体的值。）&lt;/p&gt;
&lt;p&gt;对于不同的控件，v-model会自动绑定到不同的值上&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
（1）&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; v-model&lt;/span&gt;&lt;span&gt;=&quot;value&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt; v-model绑定的是其 value值；

（2）&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;checkbox&quot;&lt;/span&gt;&lt;span&gt;  v-model&lt;/span&gt;&lt;span&gt;=&quot;checked&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;test&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;单个勾选框 v-model绑定的是checked的状态，即是否勾选上，其值为布尔值；

（3）&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;checkbox&quot;&lt;/span&gt;&lt;span&gt;  value&lt;/span&gt;&lt;span&gt;=&quot;Jack&quot;&lt;/span&gt;&lt;span&gt; v-model&lt;/span&gt;&lt;span&gt;=&quot;checkedNames&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;checkbox&quot;&lt;/span&gt;&lt;span&gt;  value&lt;/span&gt;&lt;span&gt;=&quot;John&quot;&lt;/span&gt;&lt;span&gt; v-model&lt;/span&gt;&lt;span&gt;=&quot;checkedNames&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;checkbox&quot;&lt;/span&gt;&lt;span&gt;  value&lt;/span&gt;&lt;span&gt;=&quot;John&quot;&lt;/span&gt;&lt;span&gt; v-model&lt;/span&gt;&lt;span&gt;=&quot;checkedNames&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;多个勾选框，v-model绑定的是勾选上的选项的value值所组成的一个数组；

（4）&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;radio&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;One&quot;&lt;/span&gt;&lt;span&gt; v-model&lt;/span&gt;&lt;span&gt;=&quot;picked&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;radio&quot;&lt;/span&gt;&lt;span&gt;  value&lt;/span&gt;&lt;span&gt;=&quot;Two&quot;&lt;/span&gt;&lt;span&gt; v-model&lt;/span&gt;&lt;span&gt;=&quot;picked&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;单选按钮，v-model绑定是选中的那一项的value值
（5）&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;v-model&lt;/span&gt;&lt;span&gt;=&quot;selected&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;one&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;A&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;two&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;B&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;three&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;C&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;  单选列表，若 option中规定了value属性，v-model绑定的是选中的那一项的value值，若option中没有规定value属性，v-model绑定的是选中的那一项的内容

（6）&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;v-model&lt;/span&gt;&lt;span&gt;=&quot;selected&quot;&lt;/span&gt;&lt;span&gt; multiple&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;one&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;A&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;B&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;three&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;C&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;多选列表，绑定到数组，与单选列表类似，规定了value值，数组就由所选项的value组成，未规定value值，数组就由所选项的内容组成

（7）&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;textarea &lt;/span&gt;&lt;span&gt;v-model&lt;/span&gt;&lt;span&gt;=&quot;textarea&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;textarea&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; v-model绑定的是其 value值;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2、v-for列表渲染&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li &lt;/span&gt;&lt;span&gt;v-for&lt;/span&gt;&lt;span&gt;=&quot;item in items&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    {{ item.message }}
  &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;v-for&lt;/span&gt;&lt;span&gt;=&quot;(item, index) in items&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;v-for&lt;/span&gt;&lt;span&gt;=&quot;(val, key) in object&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;v-for&lt;/span&gt;&lt;span&gt;=&quot;(val, key, index) in object&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3、v-on:绑定事件（缩写@）&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;v-on:click&lt;/span&gt;&lt;span&gt;=&quot;testclick&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;click&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
            el: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#app&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            methods:{
                testclick: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                    alert(&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;&lt;span&gt;)
                }
            }
        })
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注：绑定事件直接在dom上完成，所有的 Vue.js 事件处理方法和表达式都严格绑定在当前视图的 ViewModel 上&lt;/p&gt;
&lt;p&gt;常用的一些事件有：click、dbclick、keydown、keyup、mouseover、 mouseout、mousedown........&lt;/p&gt;
&lt;h3&gt;4、v-bind:绑定属性（缩写：）&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 绑定一个属性 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;v-bind:src&lt;/span&gt;&lt;span&gt;=&quot;imageSrc&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 缩写 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;:src&lt;/span&gt;&lt;span&gt;=&quot;imageSrc&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;在绑定 class 或 style 特性时，支持其它类型的值，如数组或对象&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; class 绑定 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;:class&lt;/span&gt;&lt;span&gt;=&quot;{ red: isRed }&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt; &lt;span&gt;&lt;strong&gt;&amp;lt;!--这里的red是类名，isRed是数据名，值为ture或false--&amp;gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;:class&lt;/span&gt;&lt;span&gt;=&quot;[classA, classB]&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt; &lt;strong&gt;&lt;span&gt;&amp;lt;!--这里的classA/classB都是数据名，他们的值是类名，自动渲染到div上--&amp;gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;:class&lt;/span&gt;&lt;span&gt;=&quot;[classA, { classB: isB, classC: isC }]&quot;&lt;/span&gt;&lt;span&gt;&amp;gt; &lt;span&gt;&lt;strong&gt;&amp;lt;!--同上，classA,isB,isC是数据名，classA的数据值，classB，classC是类名，isB，isC的数据值是true/false--&amp;gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; style 绑定 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;:style&lt;/span&gt;&lt;span&gt;=&quot;{ fontSize: size + 'px' }&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;:style&lt;/span&gt;&lt;span&gt;=&quot;[styleObjectA, styleObjectB]&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt; &lt;span&gt;&lt;strong&gt;&amp;lt;!--styleObjectA是数据名，其结构形如：styleObjectA:{backgroundColor:'red'}复合样式采用驼峰命名--&amp;gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 没有参数(属性名)时，可以绑定到一个包含键值对的对象 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;v-bind&lt;/span&gt;&lt;span&gt;=&quot;{ id: someProp, 'other-attr': otherProp }&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 通过 prop 修饰符绑定 DOM 属性 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;v-bind:text-content.prop&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 在绑定 prop 时，prop 必须在子组件中声明。可以用修饰符指定不同的绑定类型。 “prop” 必须在 my-component 中声明。 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;my-component &lt;/span&gt;&lt;span&gt;:prop&lt;/span&gt;&lt;span&gt;=&quot;someThing&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;my-component&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; XLink &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;svg&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;:xlink:special&lt;/span&gt;&lt;span&gt;=&quot;foo&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;svg&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;关于props的绑定：用于父组件向子组件传值&lt;/p&gt;
&lt;p&gt;在父组件中，使用子组件时，&amp;lt;Child v-bind:data=&quot;data&quot;/&amp;gt;，通过v-bind把子组件需要的数据传递给子组件；&lt;/p&gt;
&lt;p&gt;在子组件中通过props来接受传过来的数据，常用写法：props:['data',......]/props:{data:dataType,.....} &lt;/p&gt;
&lt;h3&gt;5、v-show根据表达式的真假切换元素的display的属性值&lt;/h3&gt;
&lt;p&gt;表达式为真，display:block；表达式为假，display:none&lt;/p&gt;
&lt;h3&gt;6、v-once数据只绑定一次，只渲染元素和组件一次。随后的重新渲染,元素/组件及其所有的子节点将被视为静态内容并跳过。&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 单个元素 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;v-once&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;This will never change: {{msg}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 有子元素 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;v-once&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;comment&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{msg}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 组件 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;my-component &lt;/span&gt;&lt;span&gt;v-once :comment&lt;/span&gt;&lt;span&gt;=&quot;msg&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;my-component&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; v-for 指令&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li &lt;/span&gt;&lt;span&gt;v-for&lt;/span&gt;&lt;span&gt;=&quot;i in list&quot;&lt;/span&gt;&lt;span&gt; v-once&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{i}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;7、v-html 更新元素的 &lt;code&gt;innerHTML&lt;/code&gt; 。注意：内容按普通 HTML 插入 - 不会作为 Vue 模板进行编译&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;rawHtml将会按照HTML的格式 插入到span中&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;v-html&lt;/span&gt;&lt;span&gt;=&quot;rawHtml&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;8、v-text更新元素的 &lt;code&gt;textContent&lt;/code&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;v-text&lt;/span&gt;&lt;span&gt;=&quot;msg&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 和下面的一样 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{msg}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; 9、v-if、v-else根据表达式的值的真假条件渲染元素&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;v-if&lt;/span&gt;&lt;span&gt;=&quot;Math.random() &amp;gt; 0.5&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  Sorry
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;v-else&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  Not sorry
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Wed, 23 Jan 2019 13:08:00 +0000</pubDate>
<dc:creator>心晴安夏</dc:creator>
<og:description>一、Vue渲染数据原理 原生JS改变页面数据，必须要获取页面节点，也即是进行DOM操作，jQuery之类的框架只是简化DOM操作的写法，实质并没有改变操作页面数据的底层原理，DOM操作影响性能（导致浏</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lihuijuan/p/10279589.html</dc:identifier>
</item>
</channel>
</rss>