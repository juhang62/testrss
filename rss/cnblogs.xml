<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>WeihanLi.Npoi 支持 ShadowProperty 了 - WeihanLi</title>
<link>http://www.cnblogs.com/weihanli/p/12033144.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/weihanli/p/12033144.html</guid>
<description>&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;/h2&gt;
&lt;p&gt;在 EF 里有个 &lt;code&gt;ShadowProperty&lt;/code&gt; (阴影属性/影子属性)的概念，你可以通过 FluentAPI 的方式来定义一个不在 .NET model 里定义的属性，只能通过 EF 里的 &lt;code&gt;Change Tracker&lt;/code&gt; 来操作这种属性。&lt;/p&gt;
&lt;p&gt;在导出 Excel 的时候有时候我们可能希望导出的列并不是都定义好在我们的 model 中的，有的可能只是想增加一列导出某个属性中的嵌套属性之中的某一个属性值，或者我就是单纯的想多定义一列，而这个时候可能 model 是别的地方写死的，不方便改。&lt;/p&gt;
&lt;p&gt;于是 &lt;code&gt;WeihanLi.Npoi&lt;/code&gt; 从 1.6.0 版本开始支持 &lt;code&gt;ShadowProperty&lt;/code&gt; ，将 EF 里的 &lt;code&gt;ShadowProperty&lt;/code&gt; 引入到 excel 导出里，目前来说 &lt;code&gt;ShadowProperty&lt;/code&gt; 是不可写的，读取的话也只是返回一个类型的默认值，不支持 &lt;code&gt;ChangeTracker&lt;/code&gt;，不支持改。&lt;/p&gt;
&lt;h2 id=&quot;使用示例&quot;&gt;使用示例&lt;/h2&gt;
&lt;p&gt;来看一个简单使用示例：(示例来源于网友提出的这个issue： &lt;a href=&quot;https://github.com/WeihanLi/WeihanLi.Npoi/issues/51&quot; class=&quot;uri&quot;&gt;https://github.com/WeihanLi/WeihanLi.Npoi/issues/51&lt;/a&gt;)&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;using System;
using System.Collections.Generic;
using System.IO;
using WeihanLi.Npoi;

namespace NpoiTest
{
    public class Program
    {
        public static void Main(string[] args)
        {
            var settings = ExcelHelper.SettingFor&amp;lt;TestEntity&amp;gt;();
            settings.Property(x =&amp;gt; x.Name)
                .HasColumnIndex(0);
            // settings.Property(x =&amp;gt; x.UserFields)
            //     .HasOutputFormatter((entity, value) =&amp;gt; $&quot;{value[0].Value},{value[2].Value}&quot;)
            //     .HasColumnTitle(&quot;姓名,工号&quot;)
            //     .HasColumnIndex(1);
            settings.Property(x=&amp;gt;x.UserFields).Ignored();
            settings.Property(&quot;工号&quot;)
                .HasOutputFormatter((entity,val)=&amp;gt; $&quot;{entity.UserFields[2].Value}&quot;)
                 ;
            settings.Property(&quot;部门&quot;)
                .HasOutputFormatter((entity,val)=&amp;gt; $&quot;{entity.UserFields[1].Value}&quot;)
                 ;

            var data = new List&amp;lt;TestEntity&amp;gt;()
            {
                new TestEntity()
                {
                    Name = &quot;xiaoming&quot;,
                    TotalScore = 100,
                    UserFields = new UserField[]
                    {
                        new UserField()
                        {
                            Name = &quot;姓名&quot;,
                            Value = &quot;xaioming&quot;,
                        },
                        new UserField()
                        {
                            Name = &quot;部门&quot;,
                            Value = &quot;1212&quot;
                        },
                        new UserField()
                        {
                            Name = &quot;工号&quot;,
                            Value = &quot;121213131&quot;
                        },
                    }
                }
            };
            data.ToExcelFile($@&quot;{Directory.GetCurrentDirectory()}\output.xls&quot;);
            Console.WriteLine(&quot;complete.&quot;);
        }

        private class TestEntity
        {
            public string Name { get; set; }

            public UserField[] UserFields { get; set; }

            public int TotalScore { get; set; }
        }

        private class UserField
        {
            public string Fid { get; set; }
            public string Name { get; set; }
            public string Value { get; set; }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;导出效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/489462/201912/489462-20191213084226066-1767559517.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，我们为导出的 Excel 增加在原本的 Model 里没有定义的两列，借助于此，我们可以更灵活的定制要导出的内容&lt;/p&gt;
&lt;h2 id=&quot;more&quot;&gt;More&lt;/h2&gt;
&lt;p&gt;快来体验吧，欢迎反馈，欢迎 issue&lt;/p&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
</description>
<pubDate>Fri, 13 Dec 2019 00:48:00 +0000</pubDate>
<dc:creator>WeihanLi</dc:creator>
<og:description>WeihanLi.Npoi 支持 了 Intro 在 EF 里有个 (阴影属性/影子属性)的概念，你可以通过 FluentAPI 的方式来定义一个不在 .NET model 里定义的属性，只能通过 E</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/weihanli/p/12033144.html</dc:identifier>
</item>
<item>
<title>17.Django学习之django自带的contentType表 - changxin7</title>
<link>http://www.cnblogs.com/changxin7/p/12033148.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/changxin7/p/12033148.html</guid>
<description>&lt;p&gt;　　　　通过django的contentType表来搞定一个表里面有多个外键的简单处理： 摘自：&lt;a href=&quot;https://blog.csdn.net/aaronthon/article/details/81714496&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/aaronthon/article/details/81714496&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　　　contenttypes 是Django内置的一个应用，可以追踪项目中所有app和model的对应关系，并记录在ContentType表中。&lt;/p&gt;
&lt;p&gt;　　　　models.py文件的表结构写好后，通过makemigrations和migrate两条命令迁移数据后，在数据库中会自动生成一个django_content_type表，比如我们有在models.py中写了这么几张表：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from django.db import models

class Electrics(models.Model):
    &quot;&quot;&quot;
    id    name
     1   日立冰箱
     2   三星电视
     3   小天鹅洗衣机
    &quot;&quot;&quot;
    name = models.CharField(max_length=32)


class Foods(models.Model):
    &quot;&quot;&quot;
    id   name
    1    面包
    2    烤鸭
    &quot;&quot;&quot;
    name = models.CharField(max_length=32)


class Clothes(models.Model):
    name = models.CharField(max_length=32)


class Coupon(models.Model):  # 特殊关系表
&quot;&quot;&quot; 
　　id    name 　　　electric_id 　　food_id   cloth_id   more...   # 每增加一张表，关系表的结构就要多加一个字段。
    1   通用优惠券 　　null　　　　　　 null      null 
    2   冰箱满减券 　　2　　　　　　　 　null 　　  null 
    3   面包狂欢节 　　null　　　　　  　1 　　　　 null 
&quot;&quot;&quot; 
name = models.CharField(max_length=32) 
electric = models.ForeignKey(to='Electrics', null=True) 
food = models.ForeignKey(to='Foods', null=True) 
cloth = models.ForeignKey(to='Clothes', null=True)&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/988061/201904/988061-20190421201813217-923226313.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;


&lt;p&gt;　　如果是通用优惠券，那么所有的ForeignKey为null，如果仅限某些商品，那么对应商品ForeignKey记录该商品的id，不相关的记录为null。但是这样做是有问题的：实际中商品品类繁多，而且很可能还会持续增加，那么优惠券表中的外键将越来越多，但是每条记录仅使用其中的一个或某几个外键字段。&lt;/p&gt;
&lt;p&gt;　　contenttypes 应用&lt;/p&gt;
&lt;p&gt;　　　　通过使用contenttypes 应用中提供的特殊字段GenericForeignKey，我们可以很好的解决这个问题。只需要以下三步：&lt;/p&gt;
&lt;p&gt;　　　　在model中定义ForeignKey字段，并关联到ContentType表。通常这个字段命名为“content_type”&lt;/p&gt;
&lt;p&gt;　　　　在model中定义PositiveIntegerField字段，用来存储关联表中的主键。通常这个字段命名为“object_id”&lt;/p&gt;
&lt;p&gt;　　　　在model中定义GenericForeignKey字段，传入上述两个字段的名字。&lt;/p&gt;
&lt;p&gt;　　　　为了更方便查询商品的优惠券，我们还可以在商品类中通过GenericRelation字段定义反向关系。&lt;/p&gt;
&lt;p&gt;　　示例代码：models.py文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from django.db import models
from django.contrib.contenttypes.models import ContentType
from django.contrib.contenttypes.fields import GenericForeignKey, GenericRelation


class Electrics(models.Model):
    name = models.CharField(max_length=32)
    price = models.IntegerField(default=100)
    coupons = GenericRelation(to='Coupon')  # 用于反向查询，不会生成表字段

    def __str__(self):
        return self.name


class Foods(models.Model):
    name = models.CharField(max_length=32)
    price=models.IntegerField(default=100)
    coupons = GenericRelation(to='Coupon')

    def __str__(self):
        return self.name


class Clothes(models.Model):
    name = models.CharField(max_length=32)
    price = models.IntegerField(default=100)
    coupons = GenericRelation(to='Coupon')

    def __str__(self):
        return self.name


class bed(models.Model):
    name = models.CharField(max_length=32)
    price = models.IntegerField(default=100)
    coupons = GenericRelation(to='Coupon')


class Coupon(models.Model):
    &quot;&quot;&quot;
    Coupon
        id    name                      content_type_id       object_id_id
              美的满减优惠券                    9（电器表electrics）   3
              猪蹄买一送一优惠券                10                    2
              南极被子买200减50优惠券           11                    1
    &quot;&quot;&quot;
    name = models.CharField(max_length=32)

    content_type = models.ForeignKey(to=ContentType,on_delete=models.CASCADE) # step 1 既然没有直接和关联表进行外键关系，我们通过这一步先找到关联表
    object_id = models.PositiveIntegerField() # step 2  #存的是关联的那个表的对应的那条记录的id
    content_object = GenericForeignKey('content_type', 'object_id') # step 3  对象.content_object直接就拿到了这个优惠券对象关联的那个商品记录对象。

    def __str__(self):
        return self.name&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　注意：ContentType只运用于1对多的关系！！！并且多的那张表中有多个ForeignKey字段。&lt;/p&gt;
&lt;p&gt;　　数据化迁移，再给每张表添加数据&lt;/p&gt;
&lt;p&gt;　　衣服表，电器表，床上用品表，美食表&lt;/p&gt;
&lt;p&gt;　　添加完之后，数据迁移,python manage.py makemigrations 和 python manage.py migrate&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;创建记录和查询

from django.shortcuts import render, HttpResponse
from api import models
from django.contrib.contenttypes.models import ContentType


def test(request):
    if request.method == 'GET':
        # ContentType表对象有model_class() 方法，取到对应model
        content = ContentType.objects.filter(app_label='api', model='electrics').first()  # 表名小写
        cloth_class = content.model_class() # cloth_class 就相当于models.Electrics
        res = cloth_class.objects.all()
        print(res)

        # 为三星电视(id=2)创建一条优惠记录
        s_tv = models.Electrics.objects.filter(id=2).first()
        models.Coupon.objects.create(name='电视优惠券', content_object=s_tv)

        # 查询优惠券（id=1）绑定了哪个商品
        coupon_obj = models.Coupon.objects.filter(id=1).first()
        prod = coupon_obj.content_object
        print(prod)

        # 查询三星电视(id=2)的所有优惠券
        res = s_tv.coupons.all()
        print(res)&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;　　总结： 当一张表和多个表FK关联，并且多个FK中只能选择其中一个或其中n个时，可以利用contenttypes app，只需定义三个字段就搞定！&lt;/p&gt;
&lt;p&gt;　　创建记录&lt;/p&gt;
&lt;p&gt;　　　　关系表的结构&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/988061/201904/988061-20190421202554582-648033419.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　用语法给关系表加记录。&lt;/p&gt;
&lt;p&gt;　　添加方式1：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/988061/201904/988061-20190421202634451-1688300386.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/988061/201904/988061-20190421202658998-1158982.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　接下来用postmen来发送请求&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/988061/201904/988061-20190421202718073-1729940762.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　然后代金券表数据就添加完成了&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/988061/201904/988061-20190421202744229-1168965651.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　添加方式2：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/988061/201904/988061-20190421202822945-1297330552.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　通过postmen发送请求结果&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/988061/201904/988061-20190421202852087-172584429.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　查询记录&lt;/p&gt;
&lt;p&gt;　　查询name=&quot;电商1代金券&quot;的代金券信息&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/988061/201904/988061-20190421202914926-462383537.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/988061/201904/988061-20190421202939646-1434985101.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 13 Dec 2019 00:48:00 +0000</pubDate>
<dc:creator>changxin7</dc:creator>
<og:description>通过django的contentType表来搞定一个表里面有多个外键的简单处理： 摘自：https://blog.csdn.net/aaronthon/article/details/81714496</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/changxin7/p/12033148.html</dc:identifier>
</item>
<item>
<title>小白学 Python 爬虫（17）：Requests 基础使用 - 极客挖掘机</title>
<link>http://www.cnblogs.com/babycomeon/p/12033132.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/babycomeon/p/12033132.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201912/908359-20191213084437127-425739543.jpg&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;人生苦短，我用 Python&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前文传送门：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/13/3303836941/&quot;&gt;小白学 Python 爬虫（1）：开篇&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/20/2586166930/&quot;&gt;小白学 Python 爬虫（2）：前置准备（一）基本类库的安装&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/21/1005563697/&quot;&gt;小白学 Python 爬虫（3）：前置准备（二）Linux基础入门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/22/3679472340/&quot;&gt;小白学 Python 爬虫（4）：前置准备（三）Docker基础入门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/24/334078215/&quot;&gt;小白学 Python 爬虫（5）：前置准备（四）数据库基础&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/25/1881661601/&quot;&gt;小白学 Python 爬虫（6）：前置准备（五）爬虫框架的安装&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/26/1197821400/&quot;&gt;小白学 Python 爬虫（7）：HTTP 基础&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/27/101847406/&quot;&gt;小白学 Python 爬虫（8）：网页基础&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/28/1668465912/&quot;&gt;小白学 Python 爬虫（9）：爬虫基础&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/12/01/2475257648/&quot;&gt;小白学 Python 爬虫（10）：Session 和 Cookies&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/12/02/2333822325/&quot;&gt;小白学 Python 爬虫（11）：urllib 基础使用（一）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/12/03/819896244/&quot;&gt;小白学 Python 爬虫（12）：urllib 基础使用（二）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/12/04/2992515886/&quot;&gt;小白学 Python 爬虫（13）：urllib 基础使用（三）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/12/05/104488944/&quot;&gt;小白学 Python 爬虫（14）：urllib 基础使用（四）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/12/07/2788855167/&quot;&gt;小白学 Python 爬虫（15）：urllib 基础使用（五）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/12/09/1691033431/&quot;&gt;小白学 Python 爬虫（16）：urllib 实战之爬取妹子图&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;引言&quot;&gt;引言&lt;/h2&gt;
&lt;p&gt;在前面的前置准备中，我们安装了好多第三方的请求库，如 Request 、 AioHttp 等，不知各位同学还有印象不，没印象的同学可以翻翻前面的文章。&lt;/p&gt;
&lt;p&gt;前面几篇文章我们大致了解了 urllib 的基本用法，其中确实有很多使用不便的地方，如处理 Cookies 或者使用代理访问的时候，都需要使用 Opener 和 Handler 来处理。&lt;/p&gt;
&lt;p&gt;这时，更加强大的 Request 库的出现就顺理成章。有了 Request 库，我们可以更加简单方便的使用这些高阶操作。&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;首先还是各种官方地址敬上：&lt;/p&gt;
&lt;p&gt;这里列出各种官方文档的目的是希望各位同学能养成查阅官方文档的习惯，毕竟小编也是人，也会犯错，相比较而言，官方文档的错误率会非常低，包括有时候一些疑难问题都能通过官方文档来解决。&lt;/p&gt;
&lt;p&gt;各种基础概念我们已经在介绍 urllib 基础使用的时候都介绍过了，这里也就不再多 BB ，直接进入干货环节：&lt;strong&gt;写代码&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;这里我们使用的测试地址依然事前面提到过的：&lt;a href=&quot;https://httpbin.org/&quot; class=&quot;uri&quot;&gt;https://httpbin.org/&lt;/a&gt; 。&lt;/p&gt;
&lt;h2 id=&quot;get-请求&quot;&gt;GET 请求&lt;/h2&gt;
&lt;p&gt;GET 请求是我们最常用的请求，先来了解一下如何使用 Requests 发送一个 GET 请求。代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import requests

r = requests.get('https://httpbin.org/get')
print(r.text)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
  &quot;args&quot;: {}, 
  &quot;headers&quot;: {
    &quot;Accept&quot;: &quot;*/*&quot;, 
    &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;, 
    &quot;Host&quot;: &quot;httpbin.org&quot;, 
    &quot;User-Agent&quot;: &quot;python-requests/2.22.0&quot;
  }, 
  &quot;origin&quot;: &quot;116.234.254.11, 116.234.254.11&quot;, 
  &quot;url&quot;: &quot;https://httpbin.org/get&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里就不多讲了，和前面的 urllib 是一样的。&lt;/p&gt;
&lt;p&gt;如果我们想在 GET 请求中添加请求参数，需要如何添加呢？&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import requests

params = {
    'name': 'geekdigging',
    'age': '18'
}

r1 = requests.get('https://httpbin.org/get', params)
print(r1.text)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
  &quot;args&quot;: {
    &quot;age&quot;: &quot;18&quot;, 
    &quot;name&quot;: &quot;geekdigging&quot;
  }, 
  &quot;headers&quot;: {
    &quot;Accept&quot;: &quot;*/*&quot;, 
    &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;, 
    &quot;Host&quot;: &quot;httpbin.org&quot;, 
    &quot;User-Agent&quot;: &quot;python-requests/2.22.0&quot;
  }, 
  &quot;origin&quot;: &quot;116.234.254.11, 116.234.254.11&quot;, 
  &quot;url&quot;: &quot;https://httpbin.org/get?name=geekdigging&amp;amp;age=18&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，请求的链接被自动构造成了：&lt;a href=&quot;https://httpbin.org/get?name=geekdigging&amp;amp;age=18&quot; class=&quot;uri&quot;&gt;https://httpbin.org/get?name=geekdigging&amp;amp;age=18&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;值得注意的一点是， &lt;code&gt;r1.text&lt;/code&gt; 返回的数据类型是 str 类型，但是实际上是一个 json ，如果想直接将这个 json 转化成我们可以直接使用的字典格式，可以使用以下方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;print(type(r1.text))
print(r1.json())
print(type(r.json()))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;class 'str'&amp;gt;
{'args': {'age': '18', 'name': 'geekdigging'}, 'headers': {'Accept': '*/*', 'Accept-Encoding': 'gzip, deflate', 'Host': 'httpbin.org', 'User-Agent': 'python-requests/2.22.0'}, 'origin': '116.234.254.11, 116.234.254.11', 'url': 'https://httpbin.org/get?name=geekdigging&amp;amp;age=18'}
&amp;lt;class 'dict'&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;添加请求头：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import requests

headers = {
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.108 Safari/537.36',
    'referer': 'https://www.geekdigging.com/'
}
r2 = requests.get('https://httpbin.org/get', headers = headers)
print(r2.text)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
  &quot;args&quot;: {}, 
  &quot;headers&quot;: {
    &quot;Accept&quot;: &quot;*/*&quot;, 
    &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;, 
    &quot;Host&quot;: &quot;httpbin.org&quot;, 
    &quot;Referer&quot;: &quot;https://www.geekdigging.com/&quot;, 
    &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.108 Safari/537.36&quot;
  }, 
  &quot;origin&quot;: &quot;116.234.254.11, 116.234.254.11&quot;, 
  &quot;url&quot;: &quot;https://httpbin.org/get&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;与 urllib.request 一样，我们也是通过 headers 参数来传递头信息。&lt;/p&gt;
&lt;p&gt;如果我们想要抓取一张图片或者一个视频这种文件，可以怎么做呢？&lt;/p&gt;
&lt;p&gt;这些文件本质上都是由二进制码组成的，由于有特定的保存格式和对应的解析方式，我们才可以看到这些形形色色的多媒体。所以，想要抓取它们，就要拿到它们的二进制码。&lt;/p&gt;
&lt;p&gt;比如我们抓取一张百度上的 logo 图片，图片地址为：&lt;a href=&quot;https://www.baidu.com/img/superlogo_c4d7df0a003d3db9b65e9ef0fe6da1ec.png&quot; class=&quot;uri&quot;&gt;https://www.baidu.com/img/superlogo_c4d7df0a003d3db9b65e9ef0fe6da1ec.png&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import requests

r3 = requests.get(&quot;https://www.baidu.com/img/superlogo_c4d7df0a003d3db9b65e9ef0fe6da1ec.png&quot;)
with open('baidu_logo.png', 'wb') as f:
    f.write(r3.content)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果小编就不展示了，可以正常下载。&lt;/p&gt;
&lt;h2 id=&quot;post-请求&quot;&gt;POST 请求&lt;/h2&gt;
&lt;p&gt;我们接着来介绍一个非常常用的 POST 请求。和上面的 GET 请求一样，我们依然使用： &lt;a href=&quot;https://httpbin.org/post&quot; class=&quot;uri&quot;&gt;https://httpbin.org/post&lt;/a&gt; 进行测试。示例代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import requests

headers = {
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.108 Safari/537.36',
    'referer': 'https://www.geekdigging.com/'
}

params = {
    'name': 'geekdigging',
    'age': '18'
}

r = requests.post('https://httpbin.org/post', data = params, headers = headers)
print(r.text)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
  &quot;args&quot;: {}, 
  &quot;data&quot;: &quot;&quot;, 
  &quot;files&quot;: {}, 
  &quot;form&quot;: {
    &quot;age&quot;: &quot;18&quot;, 
    &quot;name&quot;: &quot;geekdigging&quot;
  }, 
  &quot;headers&quot;: {
    &quot;Accept&quot;: &quot;*/*&quot;, 
    &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;, 
    &quot;Content-Length&quot;: &quot;23&quot;, 
    &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;, 
    &quot;Host&quot;: &quot;httpbin.org&quot;, 
    &quot;Referer&quot;: &quot;https://www.geekdigging.com/&quot;, 
    &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.108 Safari/537.36&quot;
  }, 
  &quot;json&quot;: null, 
  &quot;origin&quot;: &quot;116.234.254.11, 116.234.254.11&quot;, 
  &quot;url&quot;: &quot;https://httpbin.org/post&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们在这个 POST 请求中添加了请求头和参数。&lt;/p&gt;
&lt;h2 id=&quot;response-响应&quot;&gt;Response 响应&lt;/h2&gt;
&lt;p&gt;上面我们使用过 text 和 json 来获取响应内容，除了这两个，还有很多属性和方法可以用来获取其他信息。&lt;/p&gt;
&lt;p&gt;我们来访问百度首页演示一下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import requests

r = requests.get('https://www.baidu.com')
print(type(r.status_code), r.status_code)
print(type(r.headers), r.headers)
print(type(r.cookies), r.cookies)
print(type(r.url), r.url)
print(type(r.history), r.history)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;class 'int'&amp;gt; 200
&amp;lt;class 'requests.structures.CaseInsensitiveDict'&amp;gt; {'Cache-Control': 'private, no-cache, no-store, proxy-revalidate, no-transform', 'Connection': 'Keep-Alive', 'Content-Encoding': 'gzip', 'Content-Type': 'text/html', 'Date': 'Thu, 05 Dec 2019 13:24:11 GMT', 'Last-Modified': 'Mon, 23 Jan 2017 13:23:55 GMT', 'Pragma': 'no-cache', 'Server': 'bfe/1.0.8.18', 'Set-Cookie': 'BDORZ=27315; max-age=86400; domain=.baidu.com; path=/', 'Transfer-Encoding': 'chunked'}
&amp;lt;class 'requests.cookies.RequestsCookieJar'&amp;gt; &amp;lt;RequestsCookieJar[&amp;lt;Cookie BDORZ=27315 for .baidu.com/&amp;gt;]&amp;gt;
&amp;lt;class 'str'&amp;gt; https://www.baidu.com/
&amp;lt;class 'list'&amp;gt; []&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里分别打印输出 &lt;code&gt;status_code&lt;/code&gt; 属性得到状态码，输出 &lt;code&gt;headers&lt;/code&gt; 属性得到响应头，输出 &lt;code&gt;cookies&lt;/code&gt; 属性得到 Cookies ，输出 &lt;code&gt;url&lt;/code&gt; 属性得到 URL ，输出 &lt;code&gt;history&lt;/code&gt; 属性得到请求历史。&lt;/p&gt;
&lt;h2 id=&quot;示例代码&quot;&gt;示例代码&lt;/h2&gt;
&lt;p&gt;本系列的所有代码小编都会放在代码管理仓库 Github 和 Gitee 上，方便大家取用。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/meteor1993/python-learning/tree/master/python-spider/requests-demo&quot; title=&quot;示例代码-Github&quot;&gt;示例代码-Github&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/inwsy/python-learning/tree/master/python-spider/requests-demo&quot; title=&quot;示例代码-Gitee&quot;&gt;示例代码-Gitee&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 13 Dec 2019 00:45:00 +0000</pubDate>
<dc:creator>极客挖掘机</dc:creator>
<og:description>人生苦短，我用 Python 前文传送门： '小白学 Python 爬虫（1）：开篇' '小白学 Python 爬虫（2）：前置准备（一）基本类库的安装' '小白学 Python 爬虫（3）：前置准备</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/babycomeon/p/12033132.html</dc:identifier>
</item>
<item>
<title>[ASP.NET Core 3框架揭秘] 配置[5]：配置数据与数据源的实时同步 - Artech</title>
<link>http://www.cnblogs.com/artech/p/inside-asp-net-core-05-05.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/artech/p/inside-asp-net-core-05-05.html</guid>
<description>&lt;p&gt;在《&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-05-03.html&quot;&gt;配置模型总体设计&lt;/a&gt;》介绍配置模型核心对象的时候，我们刻意回避了与配置同步相关的API，现在我们利用一个独立文章来专门讨论这个话题。配置的同步涉及到两个方面：第一，对原始的配置源实施监控并在其发生变化之后重新加载配置；第二，配置重新加载之后及时通知应用程序进而使应用能够及时使用最新的配置。要了解配置同步机制的实现原理，我们先得了解一下配置数据的流向。&lt;/p&gt;

&lt;p&gt;通过前面的介绍，我们已经对配置模型有了充分的了解，处于核心地位的 IConfigurationBuilder对象借助注册的IConfigurationSource对象提供的IConfigurationProvider对象从相应的配置源中加载数据，而各种针对IConfigurationProvider接口的实现就是为了将形态各异的原始配置数据转换成配置字典。我们在应用程序中使用的配置数据直接来源于IConfigurationBuilder对象创建的IConfiguration对象，那么当我们调用定义在IConfiguration对象上的API获取配置数据时，配置数据究竟具有怎样的流向呢？&lt;/p&gt;
&lt;p&gt;我们在前面已经提到过，由ConfigurationBuilder（IConfigurationBuilder接口的默认实现）的Build方法提供的IConfiguration对象是一个ConfigurationRoot对象，它代表着整颗配置树，而组成这棵树的配置节则通过ConfigurationSection对象表示。这棵由ConfigurationRoo对象表示的配置树其实是无状态的，也就说&lt;span&gt;不论是ConfigurationRoot对象还是ConfigurationSection对象，它们并没有利用某个字段存储任何的配置数据&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;ConfigurationRoot对象保持着对所有注册IConfigurationSource提供的IConfigurationProvider对象的引用，当我们调用ConfigurationRoot或者ConfigurationSection相应的API提取配置数据时，最终都会直接从这些IConfigurationProvider中提取数据。换句话说，&lt;span&gt;配置数据在整个模型中只以配置字典的形式存储在IConfigurationProvider对象上面&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/201912/19327-20191213083241263-1528989183.png&quot;&gt;&lt;img width=&quot;367&quot; height=&quot;92&quot; title=&quot;6-15&quot; alt=&quot;6-15&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/201912/19327-20191213083241673-1631931467.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;应用程序在读取配置时产生的数据流基本体现在上图中。接下来我们从ConfigurationRoot和ConfigurationSection这两个类型的定义来对这个数据流，以及建立在此基础上的配置同步机制作进一步的介绍，不过在这之前我们得先来了解一个名为ConfigurationReloadToken的类型。&lt;/p&gt;

&lt;p&gt;ConfigurationRoot和ConfigurationSection的GetReloadToken方法返回的IChangeToken对象类型都是ConfigurationReloadToken。不仅如此，对于组成同一棵配置树的所有节点对应的IConfiguration对象（ConfigurationRoot或者ConfigurationSection）来说，它们的GetReload&lt;br/&gt;Token方法返回的其实是&lt;span&gt;同一个ConfigurationReloadToken对象&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;还有一点值得强调，IConfiguration接口的GetReloadToken方法返回的IChangeToken，其作用不是在配置源发生变化时向应用程序发送通知，它实际上是通知应用程序：&lt;span&gt;配置源已经发生改变，并且新的数据已经被相应的IConfigurationProvider重新加载进来&lt;/span&gt;。由于Configuration&lt;br/&gt;Root和ConfigurationSection对象都不维护任何数据，它们仅仅将我们的API调用转移到IConfigurationProvider对象上，所以应用程序使用原来的IConfiguration对象就可以获取到最新的配置数据。&lt;/p&gt;
&lt;p&gt;ConfigurationReloadToken本质上是对一个&lt;span&gt;CancellationTokenSource&lt;/span&gt;对象的封装。从如下的代码片段可以看出，ConfigurationReloadToken与CancellationChangeToken具有类似的定义和实现。两者唯一不同之处在于：CancellationChangeToken对象利用创建时提供的CancellationTokenSource对象对外发送通知，而ConfigurationReloadToken对象则通过调用&lt;span&gt;OnReload&lt;/span&gt;方法利用内置的CancellationTokenSource对象发送通知。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ConfigurationReloadToken : IChangeToken
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; CancellationTokenSource _cts = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CancellationTokenSource(); 
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IDisposable RegisterChangeCallback(Action&amp;lt;&lt;span&gt;object&lt;/span&gt;&amp;gt; callback, &lt;span&gt;object&lt;/span&gt; state) =&amp;gt;&lt;span&gt;_cts.Token.Register(callback, state);    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; ActiveChangeCallbacks =&amp;gt;&lt;span&gt; True; 
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; HasChanged =&amp;gt;&lt;span&gt;_cts.IsCancellationRequested;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; OnReload() =&amp;gt;&lt;span&gt; _cts.Cancel();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;接下来我们来看看由ConfigurationBuilder对象的Build方法直接创建的ConfigurationRoot对象具有怎样的实现。正如我们前面所说，一个ConfigurationRoot对象根据一组IConfigurationProvider对象创建，这些IConfigurationProvider对象则由注册的IConfigurationSource对象来提供。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ConfigurationRoot : IConfigurationRoot
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; IList&amp;lt;IConfigurationProvider&amp;gt;&lt;span&gt; _providers;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; ConfigurationReloadToken _changeToken;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ConfigurationRoot(IList&amp;lt;IConfigurationProvider&amp;gt;&lt;span&gt; providers)
    {
        _providers  &lt;/span&gt;=&lt;span&gt; providers;
        _changeToken &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConfigurationReloadToken();
        &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; provider &lt;span&gt;in&lt;/span&gt;&lt;span&gt; providers)
        {
            provider.Load();
            ChangeToken.OnChange( () &lt;/span&gt;=&amp;gt; provider.GetReloadToken(), () =&amp;gt;&lt;span&gt; RaiseChanged());
        }
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Reload()
    {
        &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; provider &lt;span&gt;in&lt;/span&gt;&lt;span&gt; _providers)
        {
            provider.Load();  
        }
        RaiseChanged();
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IChangeToken GetReloadToken() =&amp;gt;&lt;span&gt; _changeToken;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; RaiseChanged()   =&amp;gt; Interlocked.Exchange(&lt;span&gt;ref&lt;/span&gt; _changeToken, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConfigurationReloadToken()) .OnReload();
    ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ConfigurationRoot的GetReloadToken方法返回的是一个ConfigurationReloadToken对象，该对象通过字段_changeToken表示。我们知道如果需要利用这个对象对外发送配置重新加载的通知，需要调用其OnReload方法就可以了，通过上面的代码片段我们知道该方法会在RaiseChanged方法中被调用。由于一个IChangeToken对象只能发送一次通知，所以该方法还负责创建新的ConfigurationReloadToken对象并对_changeToken字段赋值。&lt;/p&gt;
&lt;p&gt;换句话说，一旦ConfigurationRoot的&lt;span&gt;RaiseChanged&lt;/span&gt;方法被调用，我们就可以利用其GetReloadToken方法返回的IChangeToken对象接收到配置被重新加载的通知。通过上面提供的代码，我们可以看到这个RaiseChanged方法在两个地方被调用：第一，&lt;span&gt;在构造函数中调用每个IConfigurationProvider对象的GetReloadToken方法得到对应的IChangeToken对象后，并为它们注册的回调中调用了这个方法&lt;/span&gt;；第二，&lt;span&gt;实现的Reload方法依次调用每个IConfigurationProvider对象的Load方法重新加载配置数据之后，调用了这个RaiseChanged方法&lt;/span&gt;。按照这个逻辑，应用程序会在如下两个场景中利用ConfigurationRoot返回的IChangeToken接收到配置被重新加载的通知：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;某个IConfigurationProvider对象捕捉到对应配置源的改变后自动重新加载配置，并在加载完成后利用其GetReloadToken方法返回的IChangeToken发送通知；&lt;/li&gt;
&lt;li&gt;我们显式调用ConfigurationRoot的Reload方法手动加载配置。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在了解了ConfigurationRoot的GetRealodToken返回的是什么样的IChangeToken之后，我们接着介绍它的其他成员具有怎样的&lt;a&gt;实现&lt;/a&gt; 。如下面的代码片段所示，在ConfigurationRoot的索引定义中，它分别调用了IConfigurationProvider对象的TryGet和Set方法根据配置字典的Key获取和设置对应的Value。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ConfigurationRoot : IConfigurationRoot
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; IList&amp;lt;IConfigurationProvider&amp;gt;&lt;span&gt; _providers;    

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;[&lt;span&gt;string&lt;/span&gt;&lt;span&gt; key]
    {
        &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; provider &lt;span&gt;in&lt;/span&gt;&lt;span&gt; _providers.Reverse())
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (provider.TryGet(key, &lt;span&gt;out&lt;/span&gt; &lt;span&gt;var&lt;/span&gt;&lt;span&gt; value))
                {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; value;
                }
            }  
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;
        { 
            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; provider &lt;span&gt;in&lt;/span&gt;&lt;span&gt; _providers)
            {
                provider.Set(key, value);
            }
        }
    } 
  
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IConfigurationSection GetSection(&lt;span&gt;string&lt;/span&gt; key)  =&amp;gt; &lt;span&gt;new&lt;/span&gt; ConfigurationSection(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, key); 
  
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IEnumerable&amp;lt;IConfigurationSection&amp;gt; GetChildren()  =&amp;gt; GetChildrenImplementation(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;internal&lt;/span&gt; IEnumerable&amp;lt;IConfigurationSection&amp;gt; GetChildrenImplementation(  &lt;span&gt;string&lt;/span&gt;&lt;span&gt; path)
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _providers
            .Aggregate(Enumerable.Empty&lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;(),   (seed, source) =&amp;gt;&lt;span&gt; source.GetChildKeys(seed, path))
            .Distinct()
            .Select(key &lt;/span&gt;=&amp;gt; GetSection(path == &lt;span&gt;null&lt;/span&gt; ? key : $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{path}:{key}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IEnumerable&amp;lt;IConfigurationProvider&amp;gt; Providers =&amp;gt;&lt;span&gt; _providers;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从索引的定义可以看出，ConfigurationRoot在读取Value值时针对IConfigurationProvider列表的遍历是&lt;span&gt;从后往前&lt;/span&gt;的，这一点非常重要，因为该特性决定了IConfigurationSource的注册会采用“&lt;span&gt;后来居上&lt;/span&gt;”的原则。也就说如果&lt;span&gt;多个IConfigurationSource配置源提供的IConfiguationProvider对象包含同名的配置项，后面注册的IConfigurationSource对象具有更高选择优先级&lt;/span&gt;，我们应该根据这个特性合理安排IConfigurationSource对象的注册顺序。在进行Value的设置的时候，ConfigurationRoot对象会调用每个IConfigurationProvider对象的Set方法，这意味着新的值会被保存到所有IConfigurationProvider对象的配置字典中。&lt;/p&gt;
&lt;p&gt;正如我们前面多次提到过的，通过ConfigurationRoot表示的配置树的所有配置节都是一个类型为ConfigurationSection的对象，这一点体现在实现的GetSection方法上。将对应的路径作为参数，我们可以得到组成配置树的所有配置节。用于获取所有子配置节的GetChildren方法通过调用内部方法GetChildrenImplementation来实现。GetChildrenImplementation方法旨在获取配置树某个节点的所有子节点，该方法的参数表示指定节点针对配置树根的路径。当这个方法被执行的时候，它会以聚合的形式遍历所有的IConfigurationProvider并调用它们的GetChildKeys方法获取所有子节点的Key，这些Key与当前节点的路径进行合并后代表子节点的路径，这些路径最终被作为参数调用GetSection方法创建出对应的配置节。&lt;/p&gt;

&lt;p&gt;如下所示的代码片段大体上体现了代表配置节的ConfigurationSection类型的实现逻辑。如下面的代码片段所示，一个ConfigurationSection对象通过代表配置树根的ConfigurationRoot对象和当前配置节在配置树中的路径来构建。ConfigurationSection的Path属性直接返回构建时指定的路径，而&lt;a&gt;Key&lt;/a&gt;属性则由根据这个路径解析出来 。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ConfigurationSection : IConfigurationSection
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; ConfigurationRoot     _root;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; _path;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; _key;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ConfigurationSection(ConfigurationRoot root, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; path)
    {  
        _root &lt;/span&gt;=&lt;span&gt; root;
        _path &lt;/span&gt;=&lt;span&gt; path;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;[&lt;span&gt;string&lt;/span&gt;&lt;span&gt; key]
    {
        &lt;/span&gt;&lt;span&gt;get&lt;/span&gt; =&amp;gt; _root[&lt;span&gt;string&lt;/span&gt;.Join(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] { _path, _key })];
        &lt;/span&gt;&lt;span&gt;set&lt;/span&gt; =&amp;gt; _root[&lt;span&gt;string&lt;/span&gt;.Join(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] { _path, _key })] =&lt;span&gt; value;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Key =&amp;gt; _key  ?? (_key = _path.Contains(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) ? _path.Split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).Last() : _path);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Path =&amp;gt;&lt;span&gt; _path;  
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; Value
    {
        &lt;/span&gt;&lt;span&gt;get&lt;/span&gt; =&amp;gt;&lt;span&gt; _root[_path];
        &lt;/span&gt;&lt;span&gt;set&lt;/span&gt; =&amp;gt; _root[_path] =&lt;span&gt; value;
    } 
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IEnumerable&amp;lt;IConfigurationSection&amp;gt; GetChildren()   =&amp;gt;&lt;span&gt; _root.GetChildrenImplementation(_path);  
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IChangeToken GetReloadToken() =&amp;gt;&lt;span&gt; _root.GetReloadToken();
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IConfigurationSection GetSection(&lt;span&gt;string&lt;/span&gt; key)  =&amp;gt; _root.GetSection(&lt;span&gt;string&lt;/span&gt;.Join(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] { _path, key }));
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如下图6-15所示，&lt;a&gt;实现&lt;/a&gt;在ConfigurationSection类型中的大部分成员都是调用ConfigurationRoot对象相应的API来实现的。ConfigurationSection的索引直接调用ConfigurationRoot的索引来获取或者设置配置字典的Value，GetChildren方法返回的就是调用GetChildrenImplementation方法得到的结果，而GetReloadToken和GetSection方法都是通过调用同名方法实现的。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/201912/19327-20191213083241900-608467288.png&quot;&gt;&lt;img width=&quot;367&quot; height=&quot;87&quot; title=&quot;6-15&quot; alt=&quot;6-15&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/201912/19327-20191213083242122-654839129.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-05-01.html&quot;&gt;[ASP.NET Core 3框架揭秘] 配置[1]：读取配置数据[上篇]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-05-02.html&quot;&gt;[ASP.NET Core 3框架揭秘] 配置[2]：读取配置数据[下篇]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-05-03.html&quot;&gt;[ASP.NET Core 3框架揭秘] 配置[3]：配置模型总体设计&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-05-04.html&quot;&gt;[ASP.NET Core 3框架揭秘] 配置[4]：将配置绑定为对象&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-05-05.html&quot;&gt;[ASP.NET Core 3框架揭秘] 配置[5]：配置数据与数据源的实时同步&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-05-06.html&quot;&gt;[ASP.NET Core 3框架揭秘] 配置[6]：多样化的配置源[上篇]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-05-07.html&quot;&gt;[ASP.NET Core 3框架揭秘] 配置[7]：多样化的配置源[中篇]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-05-08.html&quot;&gt;[ASP.NET Core 3框架揭秘] 配置[8]：多样化的配置源[下篇]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-05-09.html&quot;&gt;[ASP.NET Core 3框架揭秘] 配置[9]：自定义配置源&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 13 Dec 2019 00:33:00 +0000</pubDate>
<dc:creator>Artech</dc:creator>
<og:description>在《配置模型总体设计》介绍配置模型核心对象的时候，我们刻意回避了与配置同步相关的API，现在我们利用一个独立文章来专门讨论这个话题。配置的同步涉及到两个方面：第一，对原始的配置源实施监控并在其发生变化</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/artech/p/inside-asp-net-core-05-05.html</dc:identifier>
</item>
<item>
<title>node - 流 浅析 - 小雨小雨丶</title>
<link>http://www.cnblogs.com/xiaoyuxy/p/12032985.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaoyuxy/p/12032985.html</guid>
<description>&lt;h3 id=&quot;概念&quot;&gt;概念&lt;/h3&gt;
&lt;p&gt;流（stream）是 Node.js 中处理流式数据的抽象接口。 stream 模块用于构建实现了流接口的对象。&lt;/p&gt;
&lt;p&gt;Node.js 提供了多种流对象。 例如，HTTP 服务器的请求和 process.stdout 都是流的实例。&lt;/p&gt;
&lt;p&gt;流可以是可读的、可写的、或者可读可写的。 所有的流都是 EventEmitter 的实例。&lt;/p&gt;
&lt;p&gt;访问 stream 模块：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const stream = require('stream');&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;尽管理解流的工作方式很重要，但是 stream 模块主要用于开发者创建新类型的流实例。 对于以消费流对象为主的开发者，极少需要直接使用 stream 模块。&lt;/p&gt;
&lt;p&gt;Node.js 中有四种基本的流类型：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Writable - 可写入数据的流（例如 fs.createWriteStream()）。&lt;/li&gt;
&lt;li&gt;Readable - 可读取数据的流（例如 fs.createReadStream()）。&lt;/li&gt;
&lt;li&gt;Duplex - 可读又可写的流（例如 net.Socket）。&lt;/li&gt;
&lt;li&gt;Transform - 在读写过程中可以修改或转换数据的 Duplex 流（例如 zlib.createDeflate()）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;此外，该模块还包括实用函数 stream.pipeline()、stream.finished() 和 stream.Readable.from()。&lt;/p&gt;
&lt;p&gt;盗图&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/FoxDaxian/FoxDaxian.github.io/master/assets/picgo/20191014212453.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;如何获取内存中的流&quot;&gt;如何获取内存中的流&lt;/h3&gt;
&lt;p&gt;可写流和可读流都会在内部的缓冲器中存储数据，可以分别使用的 writable.writableBuffer 或 readable.readableBuffer 来获取。&lt;br/&gt;&lt;a href=&quot;http://nodejs.cn/api/stream.html#stream_buffering&quot;&gt;细节&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;可读流&quot;&gt;可读流&lt;/h3&gt;
&lt;h4 id=&quot;两种模式&quot;&gt;两种模式&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;流动模式(不用打，自己动)：数据&lt;code&gt;自动&lt;/code&gt;从底层系统读取，并通过EventEmitter接口的事件尽可能快的提供刚给应用程序&lt;/li&gt;
&lt;li&gt;暂停模式(打一下，动一下)：必须显示调用&lt;code&gt;stream.read()&lt;/code&gt;读取数据块&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其实，所有可读流&lt;code&gt;初始&lt;/code&gt;的时候都处于&lt;code&gt;暂停模式&lt;/code&gt;，不过可以通过以下方法切换到流动模式&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;添加 &lt;code&gt;data&lt;/code&gt; 事件句柄。&lt;/li&gt;
&lt;li&gt;调用 &lt;code&gt;stream.resume()&lt;/code&gt; 方法。&lt;/li&gt;
&lt;li&gt;调用 &lt;code&gt;stream.pipe()&lt;/code&gt; 方法将数据发送到可写流。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当然，能切到&lt;code&gt;流动模式&lt;/code&gt;，肯定也能切到&lt;code&gt;暂停模式&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果没有管道目标，则调用 &lt;code&gt;stream.pause()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果有管道目标，则移除所有的管道目标。调用&lt;code&gt;stream.unpipe()&lt;/code&gt;可以移除多个管道目标。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为了向后兼容，移除 'data' 事件句柄不会自动地暂停流。&lt;/p&gt;
&lt;p&gt;如果有管道目标，一旦目标变为 drain 状态并请求接收数据时，则调用 stream.pause() 也不能保证流会保持暂停模式。&lt;/p&gt;
&lt;p&gt;如果可读流切换到流动模式，且没有可用的消费者来处理数据，则数据将会丢失。 例如，当调用 readable.resume() 时，没有监听 'data' 事件或 'data' 事件句柄已移除。&lt;/p&gt;
&lt;p&gt;添加 &lt;code&gt;readable&lt;/code&gt; 事件句柄会使流自动停止流动，并通过 &lt;code&gt;readable.read()&lt;/code&gt; 消费数据。 如果 &lt;code&gt;readable&lt;/code&gt; 事件句柄被移除，且存在 &lt;code&gt;data&lt;/code&gt; 事件句柄，则流会再次开始流动&lt;/p&gt;
&lt;h3 id=&quot;demo&quot;&gt;demo&lt;/h3&gt;
&lt;h4 id=&quot;流动模式&quot;&gt;流动模式&lt;/h4&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const fs = require('fs')
const path = require('path')
const rs = fs.createReadStream(path.join(__dirname, './1.txt'))

rs.setEncoding('utf8')

rs.on('data', (data) =&amp;gt; {
    console.log(data)
})&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;暂停模式&quot;&gt;暂停模式&lt;/h4&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const fs = require('fs')
const path = require('path')
const rs = fs.createReadStream(path.join(__dirname, './1.txt'))

rs.setEncoding('utf8')

rs.on('readable', () =&amp;gt; {
    let d = rs.read(1) // 要读取的数据的字节数。
    console.log(d)
})&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;read方法-参数-可选-size&quot;&gt;read方法： 参数 可选 [size]&lt;/h3&gt;
&lt;p&gt;如果没有指定 size 参数，则返回内部缓冲中的所有数据。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;readable.read()&lt;/code&gt; 处理数据时， while 循环是必需的。&lt;br/&gt;read方法消耗的是内存中的数据&lt;/p&gt;
&lt;p&gt;当read方法返回的是&lt;code&gt;null&lt;/code&gt;的时候，会触发 流监听的 &lt;code&gt;end&lt;/code&gt; 事件&lt;br/&gt;不使用read消耗内存中的流数据，则不会触发end&lt;/p&gt;
&lt;p&gt;预览一波&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/FoxDaxian/FoxDaxian.github.io/master/assets/picgo/20191014220028.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/FoxDaxian/FoxDaxian.github.io/master/assets/picgo/20191014220036.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;遇到的问题&quot;&gt;遇到的问题&lt;/h3&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;process.stdin.setEncoding('utf8');

process.stdin.on('readable', () =&amp;gt; {
    let chunk;
    while ((chunk = process.stdin.read()) !== null) {
        process.stdout.write(`数据: ${chunk}长度${chunk.length}\n`);
    }
});

process.stdin.on('end', () =&amp;gt; {
    process.stdout.write('结束\n');
    process.exit(1);
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码作用是读取用户在terminal上的输出，然后输出内容和长度，但是执行的时候，总是无法执行到end，不仅如此，就算内容为空，返回的长度也不为0，这让我很疑惑。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/FoxDaxian/FoxDaxian.github.io/master/assets/picgo/20191014220334.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后发现是监听的&lt;code&gt;end&lt;/code&gt;事件，只有当read方法返回为null的时候才会触发，所以没有触发，而问题就在于返回的内容是换行符，不同系统下换行符不一样，mac下是&lt;code&gt;\n&lt;/code&gt;，所以我们需要处理一下read返回的内容，然后手动end&lt;br/&gt;查看字符串中回车符可以使用:&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;console.log(JSON.stringify(chunk));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修正后的代码为:&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;process.stdin.setEncoding('utf8');

process.stdin.on('readable', () =&amp;gt; {
    let chunk;
    while ((chunk = process.stdin.read()) !== null) {
        chunk = chunk.replace(/\n/g, '');
        if (!chunk.length) {
            console.log('输入为空');
            return process.stdin.emit('end');
        }
        process.stdout.write(`数据: ${chunk}长度${chunk.length}\n`);
    }
});

process.stdin.on('end', () =&amp;gt; {
    process.stdout.write('结束\n');
    process.exit(1);
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果:&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/FoxDaxian/FoxDaxian.github.io/master/assets/picgo/20191014221044.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://nodejs.cn/api/stream.html#stream_readable_streams&quot;&gt;中文文档&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 13 Dec 2019 00:32:00 +0000</pubDate>
<dc:creator>小雨小雨丶</dc:creator>
<og:description>概念 流（stream）是 Node.js 中处理流式数据的抽象接口。 stream 模块用于构建实现了流接口的对象。 Node.js 提供了多种流对象。 例如，HTTP 服务器的请求和 proces</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiaoyuxy/p/12032985.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core 选项模式源码学习Options IOptions（二） - HueiFeng</title>
<link>http://www.cnblogs.com/yyfh/p/12032983.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yyfh/p/12032983.html</guid>
<description>[unable to retrieve full-text content]前言 上一篇文章介绍IOptions的注册,本章我们继续往下看 IOptions IOptions是一个接口里面只有一个Values属性，该接口通过OptionsManager实现 OptionsManager OptionsManager实现了IOptions和IOptionsSnapshot，他</description>
<pubDate>Fri, 13 Dec 2019 00:31:00 +0000</pubDate>
<dc:creator>HueiFeng</dc:creator>
<dc:identifier>http://www.cnblogs.com/yyfh/p/12032983.html</dc:identifier>
</item>
<item>
<title>【重学Node.js 第3篇】mongodb以及mongoose的使用 - 张小然</title>
<link>http://www.cnblogs.com/zhangran/p/12032266.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangran/p/12032266.html</guid>
<description>&lt;p&gt;本篇为这个系列的第三篇，想看更多可以直接去github的项目：&lt;a href=&quot;https://github.com/hellozhangran/happy-egg-server&quot; class=&quot;uri&quot;&gt;https://github.com/hellozhangran/happy-egg-server&lt;/a&gt;&lt;br/&gt;更多介绍可以看：&lt;a href=&quot;https://www.cnblogs.com/zhangran/p/11963616.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/zhangran/p/11963616.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;mongodb&quot;&gt;mongodb&lt;/h2&gt;
&lt;p&gt;mongodb是典型的非关系型数据库，关于它的背景介绍和优势劣势这里就不赘述，我们直接讲实操或者说最有可能用到的部分。&lt;/p&gt;
&lt;h2 id=&quot;mongodb常用指令&quot;&gt;mongodb常用指令&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;mongod --config /opt/mongodb/mongod.conf&lt;/code&gt; 启动mongod服务。
&lt;ul&gt;&lt;li&gt;如果想在后台启动，需要修改mongod.conf，添加fork=true，然后再启动。&lt;/li&gt;
&lt;li&gt;想关掉后台运行的mongod服务，先查看所有后台运行的服务 &lt;code&gt;lsof -i&lt;/code&gt;，找到mongod的pid号，&lt;code&gt;kill yourpid&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mongo&lt;/code&gt; 进入 mongo 环境&lt;/li&gt;
&lt;li&gt;&lt;code&gt;show dbs&lt;/code&gt; 查看所有的数据库&lt;/li&gt;
&lt;li&gt;&lt;code&gt;use test&lt;/code&gt; 进入test数据库&lt;/li&gt;
&lt;li&gt;&lt;code&gt;db.createCollection('user')&lt;/code&gt; 创建一个&lt;code&gt;user&lt;/code&gt;集合
&lt;ul&gt;&lt;li&gt;这里简单介绍一下集合的概念，mongo 是非关系型数据库，不存在表的概念，与表相对应的是集合。当然集合不是表，与表相差很大，没有表的行列结构，可以简单的把集合当成一个 list，而 list 里面会放一个个对象。有没有发现这像极了json数据格式。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;db.user.insert({name: 'zhangsan', age: 21, sex: 'male'})&lt;/code&gt; 在集合中插入一条数据&lt;/li&gt;
&lt;li&gt;&lt;code&gt;db.user.find()&lt;/code&gt; 查看集合user中的所有数据&lt;/li&gt;
&lt;li&gt;&lt;code&gt;db.user.find().pretty()&lt;/code&gt; 以一个漂亮点的格式显示数据&lt;/li&gt;
&lt;li&gt;&lt;code&gt;db.user.find({name: 'zhangsan'})&lt;/code&gt; find的第一个参数是where选择条件，显示符合name='zhangsan'的整条数据&lt;/li&gt;
&lt;li&gt;&lt;code&gt;db.user.find({name: 'zhangsan'}, {name: 1})&lt;/code&gt; find的第一个参数是指定显示内容，显示符合条件的name，1是显示，0是不显示。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;使用mongoose&quot;&gt;使用mongoose&lt;/h2&gt;
&lt;p&gt;mongoose是一个nodejs工具库，方便使用nodejs操作mongodb&lt;/p&gt;
&lt;h3 id=&quot;首先使用mongoose连接mongodb数据库&quot;&gt;1. 首先使用mongoose连接mongodb数据库&lt;/h3&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const mongoose = require('mongoose');

// 创建一个连接，并监听各种事件，在执行connect操作时，各事件会视具体情况而触发。
mongoose.connection
.on('error', function (err) {
    // 数据库连接失败时触发
    console.log('connect error: ', err);
})
.on('disconnected', function () {
    // 数据库断开时触发，断开重连的逻辑可以放在这里。
})
.once('open', function () {
    // 数据库连接成功时触发，express开启listen的逻辑可以放在这里。
});

// 启动mongod服务默认是运行在127.0.0.1上，所以下面路径是localhost
// test是数据库名，如果有则连接，如果无则创建
mongoose.connect('mongodb://localhost/test', {
    useNewUrlParser: true,
    useUnifiedTopology: true
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;schema与model&quot;&gt;2. Schema与Model&lt;/h3&gt;
&lt;p&gt;在mongoose中Schema、Model是非常重要的概念。Model对应mongodb中的集合 &lt;code&gt;collection&lt;/code&gt;，而Schema对应集合的结构，也就是结合都有哪些字段、字段的类型、是否必填、是否有缺省值等。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const UserSchema = mongoose.Schema({
    name: String,
    age: Number,
    sex: Boolean
});

// Schema的静态方法
UserSchema.statics.findUserByAge = function (age) {
    // 用then来拿到结果，如findUserByAge(21).then((res) =&amp;gt; {})。
    // 也可以在find第二个参数传回调函数
    return this.find({'age': age});
}

// Schema的实例方法
UserSchema.methods.findUserByName = function(name) {
    return this.model('User').find({ name: name });
};

// 创建一个Model，第三参数指定mongodb中collection的名字，如果不传则默认为变为复数（即Users）
const User = mongoose.model('User', UserSchema, 'user');

// 创建一条数据
// 1. 直接用User创建
User.create({name: 'zhangsan', age: 27, sex: true}, function(err, info) {
    console.log(info);
});

// 2. 新创建一个对象再添加数据到数据库
// 再次说明下现在mongoose默认是支持promise方式的，可以使用then 或 回调函数的方式
var person = new User({name: 'lisi', age: 20, sex: false});
person.save().then(res =&amp;gt; {
    console.log(res);
})

// 调用Schema中定义的静态方法，可以通过User直接调
User.findUserByAge(21);

// 调用Schema中定义的实例方法方法，先实例化再调
const user = new User();
user.findUserByName('zhangsan');

// 删除数据，删除符合条件的一条
User.deleteOne({name: 'lisi'}).then();

// 删除符合条件的所有数据
User.deleteMany({age: 20}).then();

// 注意：remove()方法已经被弃用了！&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后附上mongoose的api文档，其他的使用方法不一一列举：&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;http://www.mongoosejs.net/docs/api.html&quot; class=&quot;uri&quot;&gt;http://www.mongoosejs.net/docs/api.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;todo&quot;&gt;TODO&lt;/h2&gt;
&lt;p&gt;上面讲的是目前项目中已经用到的，后续可能会继续拓展的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;docker与mongodb&lt;/li&gt;
&lt;li&gt;mongodb复制集之自动容灾&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Fri, 13 Dec 2019 00:17:00 +0000</pubDate>
<dc:creator>张小然</dc:creator>
<og:description>mongodb以及mongoose的使用 本篇为这个系列的第三篇，想看更多可以直接去github的项目：https://github.com/hellozhangran/happy egg serve</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhangran/p/12032266.html</dc:identifier>
</item>
<item>
<title>软件架构质量属性之《独孤九剑》 - 朱利民</title>
<link>http://www.cnblogs.com/zhulimin/p/12032916.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhulimin/p/12032916.html</guid>
<description>&lt;p&gt;　　 什么是架构？架构是一个系统的基本组织结构，涵盖所包含的组件、组件之间的关系、组件与环境的关系、以及指导架构设计和演进的原则等内容。经常有人问架构重点需要关注多少属性，我们粗略的可以概括一下九点：&lt;span&gt;可修改性、可测试性、可扩展性、性能、可用性、安全性、可部署性、共享性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　  　　一、&lt;strong&gt;可修改性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　什么是可修改性？可修改性是指一个系统进行修改的容易程度，以及系统适应这些修改的灵活性。&lt;/p&gt;
&lt;p&gt;　　与可修改性相关的几个方面：可读性（readability）、模块化（modularity）、可重用性（reusability）、可维护性（maintainability）&lt;/p&gt;
&lt;p&gt;        可读性涉及要素：1)写得好。方法、函数、变量、类、模块是否简单明了。2）文档齐全。代码中注释是否齐全。3）结构规整。结构清晰明了、注释简介规范。&lt;/p&gt;
&lt;p&gt;　　 提高可读性策略：1.提供显示接口；2.减少双向依赖；3.抽象公共服务；4.使用继承技术；5.使用延迟绑定技术。&lt;/p&gt;
&lt;p&gt;　　　　  二、&lt;strong&gt;可测试性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　什么是可测试性？可测试性是指软件系统通过执行基本的测试来暴露其错误的难易程度。&lt;/p&gt;
&lt;p&gt;　　软件测试包括：功能测试(白盒测试、黑盒测试)、性能测试(负载测试、压力测试、可扩展性测试)、安全性测试、可用性测试、安装测试、可访问性测试。&lt;/p&gt;
&lt;p&gt;　　增强可测试性策略：1）降低系统复杂度（子系统）、2）高内聚低耦合、3）提供定义良好的接口、4）降低类的复杂性、5）正确的异常处理、6）无限循环和/或阻塞等待、7）依赖于时间的逻辑、8）并发性、9）内存管理。&lt;/p&gt;
&lt;p&gt;　　　　  三、&lt;strong&gt;可扩展性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　什么是可扩展性？可扩展性重点关注的是代码和应用程序是否能符合将来未知的编码而进行的提前设计。比如：代码设计中我们尽可能要求功能的最小化原则，接口设计的高内聚低耦合原则，应用程序设计子系统等，都和可扩展性相关。&lt;/p&gt;
&lt;p&gt;　　　　    四、&lt;strong&gt;性能&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　什么是性能？性能是指系统能够满足吞吐量或时延要求程度的指标，用每秒执行事务的数量或单个事务耗费的时间来表示。&lt;/p&gt;
&lt;p&gt;　　性能复杂度一般用大写的&lt;em&gt;&lt;strong&gt;O&lt;/strong&gt;&lt;/em&gt;符合表示，定义为输入变化的响应情况，通常用执行代码所耗费的时间来表示。&lt;/p&gt;
&lt;p&gt;　　度量性能方法：1.使用上下文管理器度量时间 2.使用时间模块开计时代码 3.使用时间模块来度量代码性能 4.使用时间模块度量CPU时间 &lt;/p&gt;
&lt;p&gt;　　　　  五、&lt;strong&gt;可用性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　程序设计的可用性主要包括以下几点：是否符合使用者的操作心里，是否满足性能要求，是否开发者能在系统真实运行的环境下进行相应的修改，是否程序可以进行友好的扩展而不是僵化设计。&lt;/p&gt;
&lt;p&gt;　　　　  六、&lt;strong&gt;可扩展性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　可扩展性包括两种：水平扩展和垂直扩展。&lt;/p&gt;
&lt;p&gt;　　水平扩展包括：1）活跃冗余 2）热备份 3）故障检测或重启 4）缓存它 5）去偶 6）优雅降级 7）数据接近代码 8）按照SLA设计&lt;/p&gt;
&lt;p&gt;　　垂直扩展包括：1）向现有系统添加更多资源 2）更好地利用系统中的现有资源&lt;/p&gt;
&lt;p&gt;　　　　  七、&lt;strong&gt;安全性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　安全性是软件重要的方面。信息系统安全架构需要包含以下几个方面：保密性、完整性、可用性、认证、授权、不可否认性。&lt;/p&gt;
&lt;p&gt;　　常见的安全漏洞：溢出错误(缓存溢出、算术溢出、整型溢出)、未经验证或验证不当的输入、不当的访问控制、加密问题、使用HTTP而没有使用HTTPS、不安全的认证、弱密码的使用、安全散列或秘钥的重用、弱加密技术、无效或过期的证书/秘钥、信息泄露、服务器的元信息、开放的索引页、开发的端口、静态条件、系统时钟漂移、不安全的文件(文件夹)操作等&lt;/p&gt;
&lt;p&gt;　　Python中常见的四种安全问题：读取输入、表达式求值、溢出错误、序列化问题。&lt;/p&gt;
&lt;p&gt;　　Web应用中的安全问题：服务器端模板注入、服务器端模板注入-回避、服务拒绝、跨站脚本攻击等&lt;/p&gt;
&lt;p&gt;　　安全编码的策略：输入验证、最简原则、最小特权原则、清理数据、授权访问、进行有效的测试、多层防御实践、定义安全需求、模型威胁、安全策略的架构和设计&lt;/p&gt;
&lt;p&gt;　　　　 八、&lt;strong&gt;可部署性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　与可部署性相关的因素：模块结构、产品运行环境和开发环境、开发生态系统支持、标准化配置、标准化基础设施、容器的使用&lt;/p&gt;
&lt;p&gt;　　　　 九、&lt;strong&gt;共享性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　面对现今互联网蓬勃发展，出现了很多大数据云计算的新理念，比如:BaaS、IaaS、PaaS、SaaS、DaaS、低代码等，我们可以理解为共享技术。比如云计算里的多租户、为什么要上云，都是为了最大化节约社会资源，增强系统的可共享性，而进行的创新。&lt;/p&gt;
&lt;p&gt;　　共享性涉及的要素：可分为软件共享性和硬件共享性。&lt;/p&gt;
&lt;p&gt;　　软件共享性的策略：虚拟机技术、云计算技术、大数据技术等；硬件共享性的策略：共享数据库、共享硬件系统等&lt;/p&gt;
&lt;p&gt;　　　　       &lt;strong&gt;总纲&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　系统架构需要关注的属性客观因素不外乎以上九大专题内容，不过真实的系统架构设计我们又不仅仅需要关注以上内容，还包括系统的主观因素，环境、相关利益者等都能制约系统的架构。我们需要灵活运用以上的知识，比如有的架构更关注安全性可能会舍弃部分的可用性，又比如我们为了增强系统的可修改性，可能系统的可部署性又需要折中处理。我们需要融汇贯通的理解主客观因素，平衡制约系统的主客观矛盾，所以我在总结篇介绍&lt;/p&gt;
&lt;p&gt;　　系统架构的核心理念：他强由他强，清风拂山岗；他横由他横，明月照大江；他自狠来他自恶，我自一口真气足。最终达到《无招》境界！&lt;/p&gt;
</description>
<pubDate>Thu, 12 Dec 2019 22:14:00 +0000</pubDate>
<dc:creator>朱利民</dc:creator>
<og:description>什么是架构？架构是一个系统的基本组织结构，涵盖所包含的组件、组件之间的关系、组件与环境的关系、以及指导架构设计和演进的原则等内容。经常有人问架构重点需要关注多少属性，我们粗略的可以概括一下九点：可修改</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhulimin/p/12032916.html</dc:identifier>
</item>
<item>
<title>Spring Security OAuth2 Demo —— 隐式授权模式（Implicit） - 东北小狐狸</title>
<link>http://www.cnblogs.com/hellxz/p/oauth2_impilit_pattern.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hellxz/p/oauth2_impilit_pattern.html</guid>
<description>&lt;p&gt;本文可以转载，但请注明出处https://www.cnblogs.com/hellxz/p/oauth2_impilit_pattern.html&lt;/p&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;在文章&lt;a href=&quot;https://www.cnblogs.com/hellxz/p/oauth2_process.html&quot;&gt;OAuth 2.0 概念及授权流程梳理&lt;/a&gt; 中我们谈到OAuth 2.0的概念与流程，上一篇文章&lt;a href=&quot;https://www.cnblogs.com/hellxz/p/oauth2_oauthcode_pattern.html&quot;&gt;Spring Security OAuth2 Demo —— 授权码模式&lt;/a&gt;简单演示了OAuth2的授权码模式流程，本文继续整理隐式授权模式相关内容&lt;/p&gt;
&lt;p&gt;写文不易，如有错误，请在评论区指出，谢谢合作&lt;/p&gt;
&lt;h2 id=&quot;本文目标&quot;&gt;本文目标&lt;/h2&gt;
&lt;p&gt;使用相对简易的代码演示隐式授权模式的流程，让其流程更加清晰易懂&lt;/p&gt;
&lt;h2 id=&quot;隐式授权模式流程回顾&quot;&gt;隐式授权模式流程回顾&lt;/h2&gt;
&lt;p&gt;隐式授权模式要求：用户登录并对第三方应用进行授权，直接返回访问token，通过token访问资源&lt;/p&gt;
&lt;p&gt;相比授权码模式，它少了一次授权码的颁发与客户端使用授权码换取token的过程&lt;/p&gt;
&lt;h2 id=&quot;隐式授权模式适用场景&quot;&gt;隐式授权模式适用场景&lt;/h2&gt;
&lt;p&gt;适用场景有以下几个条件：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;用户参与：使用隐式授权需要&lt;strong&gt;与用户交互&lt;/strong&gt;，用户对授权服务器进行登录与授权&lt;/li&gt;
&lt;li&gt;单页应用：SPA前端，&lt;strong&gt;没有后端或者后端属于授权方&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;客户端密码：访问授权时，&lt;strong&gt;不需要&lt;/strong&gt;带第三方应用secret，前提是资源服务校验token使用的client信息与客户端（第三方应用）不同，且配置了secret&lt;/li&gt;
&lt;li&gt;前端：&lt;strong&gt;必须要有前端&lt;/strong&gt;，否则无法使用授权功能&lt;/li&gt;
&lt;li&gt;客户端后端：Options，仅当应用前后端不分离MVC场景&lt;/li&gt;
&lt;li&gt;资源所属方：授权方&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;demo结构&quot;&gt;Demo结构&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1149398/201912/1149398-20191212234241528-405231551.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;主要还是两个角色，授权服务器与资源服务器两个模块，另外与其他几个demo一样，在父项目中包含一个说明文档&lt;/p&gt;
&lt;p&gt;本文以及后续文章的demo均放在GitHub上，欢迎大家Star &amp;amp; Fork，源码地址：https://github.com/hellxz/spring-security-oauth2-learn&lt;/p&gt;
&lt;h2 id=&quot;maven依赖&quot;&gt;Maven依赖&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;        &amp;lt;!--Spring Security--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-security&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!--Spring Boot Starter Web 所有demo均使用web--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!-- Spring Security OAuth2 --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.security.oauth&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-security-oauth2&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${spring-security-oauth2.version}&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;搭建授权服务器&quot;&gt;搭建授权服务器&lt;/h2&gt;
&lt;p&gt;项目启动类不多说，直接贴代码，讲讲主要内容&lt;/p&gt;
&lt;p&gt;先说下SecurityConfig&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.github.hellxz.oauth2.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;

import java.util.Collections;

@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Bean
    public PasswordEncoder passwordEncoder(){
        return new BCryptPasswordEncoder();
    }

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        // @formatter: off
        auth.inMemoryAuthentication()
                .withUser(&quot;hellxz&quot;)
                .password(passwordEncoder().encode(&quot;xyz&quot;))
                .authorities(Collections.emptyList());
        // @formatter: on
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests()
                .anyRequest().authenticated() //所有请求都需要通过认证
                .and()
                .httpBasic() //Basic提交
                .and()
                .csrf().disable(); //关跨域保护
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参考了上文的话，这里基本上没有什么变化，除了开启web安全外，重写了认证管理器的用户提供部分、简单配置了所有资源都需要认证&lt;/p&gt;
&lt;p&gt;授权服务主要配置AuthorizationConfig&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.github.hellxz.oauth2.config;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.oauth2.config.annotation.configurers.ClientDetailsServiceConfigurer;
import org.springframework.security.oauth2.config.annotation.web.configuration.AuthorizationServerConfigurerAdapter;
import org.springframework.security.oauth2.config.annotation.web.configuration.EnableAuthorizationServer;
import org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerSecurityConfigurer;

//授权服务器配置
@Configuration
@EnableAuthorizationServer //开启授权服务
public class AuthorizationConfig extends AuthorizationServerConfigurerAdapter {

    @Autowired
    private PasswordEncoder passwordEncoder;

    @Override
    public void configure(AuthorizationServerSecurityConfigurer security) throws Exception {
        //允许表单提交
        security.allowFormAuthenticationForClients()
                .checkTokenAccess(&quot;permitAll()&quot;); //参数与security访问控制一致
    }

    @Override
    public void configure(ClientDetailsServiceConfigurer clients) throws Exception {
        // @formatter: off
        clients.inMemory()
                .withClient(&quot;client-a&quot;) //client端唯一标识
                    .authorizedGrantTypes(&quot;implicit&quot;) //授权模式标识
                    .accessTokenValiditySeconds(120) //访问令牌的有效期，这里设置120s
                    .scopes(&quot;read_user_info&quot;) //作用域
                    .resourceIds(&quot;resource1&quot;) //资源id
                    .redirectUris(&quot;http://localhost:9001/callback&quot;) //回调地址
                    .and()
                .withClient(&quot;resource-server&quot;) //资源服务器校验token时用的客户端信息，仅需要client_id与密码
                    .secret(passwordEncoder.encode(&quot;test&quot;));
        // @formatter: on
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为最复杂的授权码已经有讲过了，这里简单说下，授权配置除了开启授权服务器，并重写认证服务器安全配置（接收客户端提交请求部分）允许客户端进行表单提交；另外配置了一个客户端的信息，包含其标识id、授权模式标识、令牌有效期、回调地址这几个必要的配置；&lt;/p&gt;
&lt;p&gt;为了更清晰地区分第三方应用的客户端与资源服务器的客户端，这里额外配置了资源服务的客户端信息&lt;/p&gt;
&lt;h2 id=&quot;测试授权服务器&quot;&gt;测试授权服务器&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;获取token&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;浏览器访问地址：http://localhost:8080/oauth/authorize?client_id=client-a&amp;amp;redirect_uri=http://localhost:9001/callback&amp;amp;response_type=token&amp;amp;scope=read_user_info&lt;/p&gt;
&lt;p&gt;请求参数列表：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;client_id=客户端id&lt;/li&gt;
&lt;li&gt;redirect_uri=回调url 一定要与授权服务器配置保持一致，否则得不到授权码&lt;/li&gt;
&lt;li&gt;response_type=token 简化模式必须是token&lt;/li&gt;
&lt;li&gt;scope=作用域 与授权服务器配置保持一致&lt;/li&gt;
&lt;li&gt;state=自定义串（可选）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1149398/201912/1149398-20191213005836840-1669285944.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;返回响应会回调我们之前输入的回调地址，包含access_token和token类型及过期时间&lt;/p&gt;
&lt;h2 id=&quot;搭建资源服务器&quot;&gt;搭建资源服务器&lt;/h2&gt;
&lt;p&gt;资源服务器也不复杂，一个资源服务器配置类，一个controller、一个vo，还有启动类（这里就不贴了，详见源码）&lt;/p&gt;
&lt;p&gt;ResourceController主要接收用户传来的用户名，返回一个json串，这里用标准错误输出高亮了下登录用户信息&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.github.hellxz.oauth2.web.controller;

import com.github.hellxz.oauth2.web.vo.UserVO;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class ResourceController {

    @GetMapping(&quot;/user/{username}&quot;)
    public UserVO user(@PathVariable String username){
        System.err.println(SecurityContextHolder.getContext().getAuthentication());
        return new UserVO(username, username + &quot;@foxmail.com&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;UserVO&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.github.hellxz.oauth2.web.vo;

public class UserVO {
    private String username;
    private String email;

    public UserVO(String username, String email) {
        this.username = username;
        this.email = email;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;资源服务器配置类ResourceConfig&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.github.hellxz.oauth2.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.oauth2.config.annotation.web.configuration.EnableResourceServer;
import org.springframework.security.oauth2.config.annotation.web.configuration.ResourceServerConfigurerAdapter;
import org.springframework.security.oauth2.config.annotation.web.configurers.ResourceServerSecurityConfigurer;
import org.springframework.security.oauth2.provider.token.RemoteTokenServices;

@Configuration
@EnableResourceServer
public class ResourceConfig extends ResourceServerConfigurerAdapter {

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Primary
    @Bean
    public RemoteTokenServices remoteTokenServices() {
        final RemoteTokenServices tokenServices = new RemoteTokenServices();
        tokenServices.setCheckTokenEndpointUrl(&quot;http://localhost:8080/oauth/check_token&quot;);
        //这里的clientId和secret对应资源服务器信息，授权服务器处需要配置
        tokenServices.setClientId(&quot;resource-server&quot;);
        tokenServices.setClientSecret(&quot;test&quot;);
        return tokenServices;
    }

    @Override
    public void configure(HttpSecurity http) throws Exception {
        //设置创建session策略
        http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED);
        //@formatter:off
        //所有请求必须授权
        http.authorizeRequests()
                .anyRequest().authenticated();
        //@formatter:on
    }

    @Override
    public void configure(ResourceServerSecurityConfigurer resources) {
        resources.resourceId(&quot;resource1&quot;).stateless(true);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;资源服务器相对授权服务器更简单，仅需要开启EnableResourceServer，实现HttpSecurity配置、ResourceServerSecurityConfigurer配置 和 校验token的配置，这里使用远程调用授权服务器的做法；&lt;/p&gt;
&lt;p&gt;需要注意的是区分资源服务器client信息和第三方应用客户端信息，之前这里有些模糊，直到著此文时方才发现这两者应区分（隐式授权可以不用密码啊，如果第三方应用等于资源服务器client，在不设置client_secret情况下，会校验失败，无法访问资源）&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;一般而言，校验token的配置如果是资源服务器自己校验，则需要在&lt;code&gt;configure(ResourceServerSecurityConfigurer resources)&lt;/code&gt;这个方法中添加token存储（tokenStore）的位置等信息&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;使用token访问资源&quot;&gt;使用token访问资源&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1149398/201912/1149398-20191213011605112-1911356240.gif&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;结束&quot;&gt;结束&lt;/h2&gt;
&lt;p&gt;最近比较忙，抽时间整理代码时发现：我对OAuth2的资源服务器与授权服务器的client配置有些模糊，现在已经清晰多了，并且及时修改了demo。如果本文对你有帮助，欢迎点推荐，Github点Star :happy:&lt;/p&gt;
&lt;p&gt;OAuth2系列demo仓库地址：https://github.com/hellxz/spring-security-oauth2-learn&lt;/p&gt;
&lt;p&gt;纸上得来终觉浅，觉知此事要躬行。愿大家共勉&lt;/p&gt;
&lt;p&gt;本文可以转载，但请注明出处https://www.cnblogs.com/hellxz/p/oauth2_impilit_pattern.html&lt;/p&gt;
</description>
<pubDate>Thu, 12 Dec 2019 17:26:00 +0000</pubDate>
<dc:creator>东北小狐狸</dc:creator>
<og:description>本文可以转载，但请注明出处https://www.cnblogs.com/hellxz/p/oauth2_impilit_pattern.html 写在前面 在文章 'OAuth 2.0 概念及授权流</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hellxz/p/oauth2_impilit_pattern.html</dc:identifier>
</item>
<item>
<title>Apache Maven从入门到升天 - 布尔bl</title>
<link>http://www.cnblogs.com/chenzhuantou/p/12032704.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenzhuantou/p/12032704.html</guid>
<description>&lt;blockquote readability=&quot;4.1964285714286&quot;&gt;
&lt;p&gt;喜欢就点个赞呗!&lt;br/&gt;GitHub项目&lt;a href=&quot;https://github.com/buerbl/JavaHouse&quot;&gt;JavaHouse&lt;/a&gt;同步收录&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;引入&quot;&gt;1 引入&lt;/h3&gt;
&lt;p&gt;在日常 Java 开发中，Maven 应该是必不可少的一个工具了，当然也有人使用 Gradle 的。那么 Maven 究竟是个啥东西呢？不就是一个依赖引入工具吗？我相信很多人和我是一样的感觉。但是一般而言，感觉的东西往往是不可靠的。我在网上收集一些资料，翻翻官网，重新整理了一下 Maven 的资料。&lt;/p&gt;
&lt;h3 id=&quot;maven-简介&quot;&gt;2 Maven 简介&lt;/h3&gt;
&lt;p&gt;维基百科上面说 Maven 是一个软件项目管理和自动构建工具。单从字面意思来看，我是不知道这是想要表达什么意思的。按照我的理解，Maven 其实就是一个开发工具，跟 IDEA 相辅相成。我们日常使用 IDEA 的编译项目的时候，其实就是在使用 Maven，只不过这些操作都被强大的 IDEA 隐藏了，造成我们在使用 IDEA，和 Maven 没有联系的错觉。&lt;/p&gt;
&lt;h3 id=&quot;maven-的命令&quot;&gt;3 Maven 的命令&lt;/h3&gt;
&lt;p&gt;说命令行之前，容我说手几个专业的名词。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;groupId&lt;/td&gt;
&lt;td&gt;包名&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;artifactId&lt;/td&gt;
&lt;td&gt;项目名称&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;groupId 的 artifactId 被人们称为坐标，确实也是，一旦他们的值确定了，我们就可以根据他们的坐标找到他们。&lt;/p&gt;
&lt;h4 id=&quot;创建&quot;&gt;创建&lt;/h4&gt;
&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;mvn -B archetype:generate 
-DarchetypeGroupId=org.apache.maven.archetypes -DgroupId=com.mycompany.app    
-Dartifac t Id=my-app&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://javahouse.xyz/GY7MAIMWP3RV@ZKU7W%7D6%5DLG.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样maven就自动创建了一个带有 hello world 的 Maven 项目。包名是 com.mycompany.app； 项目名是 my-app。看到这里，我们就知道为什么 Maven 是项目构建工具了。我个人觉得 Maven 跟大前端的 npm 工具有相似的地方。&lt;/p&gt;
&lt;h4 id=&quot;编译&quot;&gt;编译&lt;/h4&gt;
&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;mvn compile&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该命令从字面意思流知道是编译命令，他是不是编译 test 文件夹里面的源码的。执行该命令就会生成一个 target 文件。文件夹里面就是编译后的内容。&lt;/p&gt;
&lt;h4 id=&quot;清除&quot;&gt;清除&lt;/h4&gt;
&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;mvn clean&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该命令主要是清除编译后产生的 target 文件夹。&lt;/p&gt;
&lt;h4 id=&quot;打包&quot;&gt;打包&lt;/h4&gt;
&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;mvn package&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该命令会将项目默认打成 jar 包，当然我们就也可以打成 war 包。&lt;/p&gt;
&lt;h4 id=&quot;安装&quot;&gt;安装&lt;/h4&gt;
&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;mvn install&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该命令可以把项目打成 jar，放到本地仓库。&lt;/p&gt;
&lt;h3 id=&quot;仓库&quot;&gt;4 仓库&lt;/h3&gt;
&lt;p&gt;要理解 Maven，仓库概念是必不可少的。让我（灵魂画手）画个图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://javahouse.xyz/20191212201309.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;项目需要的依赖都是从本地仓库里面拿到的，本地仓库就是自己的电脑，我们引入的各种依赖都放在本地仓库里面，一般依赖有问题的话，就是本地仓库的依赖没有。我们可以先把本地的对应的依赖删除，在试试，或许就可以了。&lt;br/&gt;从中，我们可以看到自建仓库，也就是我们说的私服，可以存放一些我们开发的基础包，从自建仓库引入依赖就比较快的，当然如果自建仓库里面没有我们需要的依赖，自建仓库就会发出请求，请求远程的中央仓库，中央仓库没有那就真的没有了。&lt;/p&gt;
&lt;h3 id=&quot;pom&quot;&gt;5 POM&lt;/h3&gt;
&lt;p&gt;现在是我们的重要任务出场了--POM. Maven 项目都会有一个 pom.xml 文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://javahouse.xyz/20191212202738.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是一个最简单的 pom 文件。这个 pom 文件应该我们很熟悉了，引入依赖就是从这里引的。没什么好说的，所以说些其他的。&lt;/p&gt;
&lt;h4 id=&quot;包类型&quot;&gt;包类型&lt;/h4&gt;
&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;// war
&amp;lt;packaging&amp;gt;jar&amp;lt;/packaging&amp;gt;  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该标签决定项目是 jar 包或者 war 包。一般来说，SpringBoot 项目会打成 war 包，然后放进 tomcat 运行。当然也可以 jar 包运行，毕竟 SpringBoot 内置了tomcat ，强的一批。&lt;/p&gt;
&lt;h4 id=&quot;加进来&quot;&gt;加进来&lt;/h4&gt;
&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;&amp;lt;build&amp;gt;
    &amp;lt;resources&amp;gt;
      &amp;lt;resource&amp;gt;
        &amp;lt;directory&amp;gt;src/main/resources&amp;lt;/directory&amp;gt;
        &amp;lt;filtering&amp;gt;true&amp;lt;/filtering&amp;gt;
      &amp;lt;/resource&amp;gt;
    &amp;lt;/resources&amp;gt;
&amp;lt;/build&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果我们把一下文件，例如 xml 后缀的 mapper 文件放在 resources 里面，编译的时候会发现他们没有编译进去，是因为 标签默认是 false，我们需要 true。&lt;/p&gt;
&lt;h4 id=&quot;去掉他&quot;&gt;去掉他&lt;/h4&gt;
&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;&amp;lt;exclusions&amp;gt;
    &amp;lt;exclusion&amp;gt;
      &amp;lt;groupId&amp;gt;sample.ProjectE&amp;lt;/groupId&amp;gt; &amp;lt;!-- Exclude Project-E from Project-B --&amp;gt;
      &amp;lt;artifactId&amp;gt;Project-E&amp;lt;/artifactId&amp;gt;
    &amp;lt;/exclusion&amp;gt;
&amp;lt;/exclusions&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;部署到远程&quot;&gt;部署到远程&lt;/h4&gt;
&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;&amp;lt;distributionManagement&amp;gt;
    &amp;lt;repository&amp;gt;
      &amp;lt;id&amp;gt;mycompany-repository&amp;lt;/id&amp;gt;
      &amp;lt;name&amp;gt;MyCompany Repository&amp;lt;/name&amp;gt;
      &amp;lt;url&amp;gt;scp://repository.mycompany.com/repository/maven2&amp;lt;/url&amp;gt;
    &amp;lt;/repository&amp;gt;
&amp;lt;/distributionManagement&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当我们造好轮子之后，想部署到远程中央仓库，就添加上面标签。同时在 setting.xml(Maven 安装的目录下)添加以下&lt;/p&gt;
&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;&amp;lt;servers&amp;gt;
    &amp;lt;server&amp;gt;
      &amp;lt;id&amp;gt;mycompany-repository&amp;lt;/id&amp;gt;
      &amp;lt;username&amp;gt;jvanzyl&amp;lt;/username&amp;gt;
      &amp;lt;!-- Default value is ~/.ssh/id_dsa --&amp;gt;
      &amp;lt;privateKey&amp;gt;/path/to/identity&amp;lt;/privateKey&amp;gt; (default is ~/.ssh/id_dsa)
      &amp;lt;passphrase&amp;gt;my_key_passphrase&amp;lt;/passphrase&amp;gt;
    &amp;lt;/server&amp;gt;
 &amp;lt;/servers&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;多个模块&quot;&gt;多个模块&lt;/h4&gt;
&lt;p&gt;如果我们想一次建造几个maven项目，也是没有问题的。比如有两个模块（my-app、my-webapp），目录如下&lt;/p&gt;
&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;+- pom.xml
+- my-app
| +- pom.xml
| +- src
|   +- main
|     +- java
+- my-webapp
| +- pom.xml
| +- src
|   +- main
|     +- webapp&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在顶层 pom.xml 需要添加 标签，如下&lt;/p&gt;
&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0
                      http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
  &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;
 
  &amp;lt;groupId&amp;gt;com.mycompany.app&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;app&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
  &amp;lt;packaging&amp;gt;pom&amp;lt;/packaging&amp;gt;
 
  &amp;lt;modules&amp;gt;
    &amp;lt;module&amp;gt;my-app&amp;lt;/module&amp;gt;
    &amp;lt;module&amp;gt;my-webapp&amp;lt;/module&amp;gt;
  &amp;lt;/modules&amp;gt;
&amp;lt;/project&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后选一个做老大（webapp），在他的 pom 文件里加入 my-app 的依赖&lt;/p&gt;
&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;&amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;com.mycompany.app&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;my-app&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    ...
&amp;lt;/dependencies&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后再这两个项目（webapp、my-app）的 pom 文件里面加入顶层的 标签&lt;/p&gt;
&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0
                      http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
  &amp;lt;parent&amp;gt;
    &amp;lt;groupId&amp;gt;com.mycompany.app&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;app&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
 &amp;lt;/parent&amp;gt;
 ...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后执行 mvn verify 命令，就会在老大项目（webapp）的 target 文件夹里生成 war 包。&lt;/p&gt;
&lt;h4 id=&quot;参考&quot;&gt;参考&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;https://zh.wikipedia.org/wiki/Apache_Maven&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;https://maven.apache.org/&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;https://maven.apache.org/guides/getting-started/index.html&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;https://maven.apache.org/guides/mini/guide-configuring-maven.html&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;https://www.cnblogs.com/luotaoyeah/p/3791966.html&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;关注微信公众号随时移动端阅读&quot;&gt;关注微信公众号，随时移动端阅读&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://javahouse.xyz/20191212204326.png&quot; alt=&quot;公众号.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 12 Dec 2019 16:44:00 +0000</pubDate>
<dc:creator>布尔bl</dc:creator>
<og:description>喜欢就点个赞呗! GitHub项目 'JavaHouse' 同步收录 1 引入 在日常 Java 开发中，Maven 应该是必不可少的一个工具了，当然也有人使用 Gradle 的。那么 Maven 究</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chenzhuantou/p/12032704.html</dc:identifier>
</item>
</channel>
</rss>