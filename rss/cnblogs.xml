<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>认识机器学习与深度学习的区别 - zhouwenfan</title>
<link>http://www.cnblogs.com/zhouwenfan-home/p/10328500.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhouwenfan-home/p/10328500.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　最近学校开始了深度学习的课程，想大致上了解下关于机器学习有关的知识：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1462254/201901/1462254-20190127232502624-620543693.webp&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;div readability=&quot;12&quot;&gt;
&lt;p&gt;　　&lt;span&gt;Nvidia 博客上的这张图表示了 AI, Machine Learning, Deep Learning 三者的关系。人工智能是一类非常广泛的问题，&lt;strong&gt;机器学习是其中一个重要领域和手段&lt;/strong&gt;，&lt;strong&gt;深度学习则是机器学习的一个分支&lt;/strong&gt;。在很多人工智能问题上，深度学习的方法突破了传统机器学习的瓶颈，因而影响力迅速扩大。&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/span&gt;
&lt;div readability=&quot;20&quot;&gt;
&lt;div readability=&quot;35&quot;&gt;
&lt;h3&gt;　　什么是机器学习？&lt;/h3&gt;
&lt;p&gt;00 试着翻出一些机器学习相对权威的定义，看看它们有什么共同点：&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1420&quot; data-height=&quot;1116&quot;&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/149-609660d58b1e8833.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/149-609660d58b1e8833.png&quot; data-original-width=&quot;1420&quot; data-original-height=&quot;1116&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;363887&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Col.DL.MLDefinitions.png&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;简单来说，&lt;strong&gt;就是机器通过一系列「任务」从「经验」（数据）中学习&lt;/strong&gt;，&lt;strong&gt;并且评估「效果」如何：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;800&quot; data-height=&quot;400&quot;&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/149-d16c7fb4ac45923c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/149-d16c7fb4ac45923c.png&quot; data-original-width=&quot;800&quot; data-original-height=&quot;400&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;26147&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;　　为什么叫做「学习」呢？一般编程语言的做法，是定义每一步指令，逐一执行并最终达到目标。而机器学习则相反，先定义好输出，然后程序自动「学习」出达到目标的「步骤」。&lt;/p&gt;

&lt;p&gt;机器学习可以分为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;监督学习：给出定义好的标签，程序「学习」标签和数据之间的映射关系&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;非监督学习：没有标签的数据集&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;强化学习：达到目标会有正向反馈&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;770&quot; data-height=&quot;551&quot;&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/149-467e516670d02572.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/770/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/149-467e516670d02572.png&quot; data-original-width=&quot;770&quot; data-original-height=&quot;551&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;48486&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;h3&gt;　　机器学习擅长做什么？&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;当然是替代重复的人工劳动，用机器自动从大量数据中识别模式&lt;/strong&gt;——也就是「套路」啦。知道「套路」后，我们可以干嘛呢？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Classification 分类，如垃圾邮件识别(detection, ranking)&lt;/li&gt;
&lt;li&gt;Regression 回归，例如股市预测&lt;/li&gt;
&lt;li&gt;Clustering 聚类，如 iPhoto 按人分组&lt;/li&gt;
&lt;li&gt;Rule Extraction 规则提取，如数据挖掘&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　比如垃圾邮件识别的问题，做法是先从每一封邮件中抽取出对识别结果可能有影响的因素（称为特征 feature），比如发件地址、邮件标题、收件人数量等等。然后使用算法去训练数据中每个特征和预测结果的相关度，最终得到可以预测结果的特征。&lt;/p&gt;
&lt;p&gt;　　算法再强大，如果无法从数据中「学习到」更好的特征表达，也是徒劳。同样的数据，使用不同的表达方法，可能会极大影响问题的难度。一旦解决了数据表达和特征提取问题，很多人工智能任务也就迎刃而解。&lt;/p&gt;
&lt;h3&gt;为什么需要深度学习？&lt;/h3&gt;
&lt;p&gt;但是对机器学习来说，特征提取并不简单。特征工程往往需要人工投入大量时间去研究和调整，就好像原本应该机器解决的问题，却需要人一直在旁边搀扶。&lt;/p&gt;
&lt;p&gt;深度学习便是解决特征提取问题的一个机器学习分支。它可以&lt;strong&gt;自动学习特征和任务之间的关联&lt;/strong&gt;，还能&lt;strong&gt;从简单特征中提取复杂的特征。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;800&quot; data-height=&quot;600&quot;&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/149-a93967b20e7ea78e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/149-a93967b20e7ea78e.png&quot; data-original-width=&quot;800&quot; data-original-height=&quot;600&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;55893&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Sun, 27 Jan 2019 15:51:00 +0000</pubDate>
<dc:creator>zhouwenfan</dc:creator>
<og:description>最近学校开始了深度学习的课程，想大致上了解下关于机器学习有关的知识： Nvidia 博客上的这张图表示了 AI, Machine Learning, Deep Learning 三者的关系。人工智能是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhouwenfan-home/p/10328500.html</dc:identifier>
</item>
<item>
<title>ASPICE 简介 - 朝阳小胖</title>
<link>http://www.cnblogs.com/nelson2013/p/10328483.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nelson2013/p/10328483.html</guid>
<description>&lt;blockquote&gt;
&lt;p&gt;ASPICE学习笔记&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;微信公众号 SystemEngineeringLab&lt;br/&gt;&lt;img src=&quot;https://github.com/nixxyahoocn/resources/blob/master/imgs/common/weixin.png?raw=true&quot; alt=&quot;SystemEngineeringLab&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Automotive SPICE于2005年由AutoSIG发布，是SPICE(ISO\IEC15504国际标准)在汽车行业的衍生标准，其关注汽车行业的软件过程改进和能力测定。ASPICE兴起于欧洲，广泛用于主机厂以及供应商企业自身的的过程能力改进，以及对供应商的风险评估。从更务实的角度，主机厂基于供应商的ASPICE等级评定其是否具有供应商资质。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;ASPICE中的过程被分成3大类:&lt;/p&gt;
&lt;ol readability=&quot;-0.5&quot;&gt;&lt;li&gt;Primary Life Cycle Processes&lt;/li&gt;
&lt;li&gt;Organizational Life Cycle Processes&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Supporting Life Cycle Processes&lt;br/&gt;根据过程所侧重的活动类型的不同，每个分类下的过程又被组织成一系列的过程组。PRM提供了8组32个过程：&lt;/p&gt;
&lt;h3 id=&quot;primary-life-cycle-processes&quot;&gt;Primary Life Cycle Processes&lt;/h3&gt;
包含4个过程组：&lt;/li&gt;
&lt;li&gt;ACQ(Acquisition)，采购过程组&lt;/li&gt;
&lt;li&gt;SPL(Supply)，供应过程组&lt;/li&gt;
&lt;li&gt;SYS(System Enginneering)，系统工程过程组&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;SWE(Software Engineering)，软件工程过程组&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/557590/201901/557590-20190127233407625-1274719410.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;organizational-life-cycle-processes&quot;&gt;Organizational Life Cycle Processes&lt;/h3&gt;
&lt;p&gt;支持类过程包3个过程组，5个过程：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;REU(Reuse)，重用过程组&lt;/li&gt;
&lt;li&gt;PIM(Process Improvement)，过程改进过程组&lt;/li&gt;
&lt;li&gt;MAN(Management)，管理过程组&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/557590/201901/557590-20190127233446612-944347909.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;supporting-life-cycle-processes&quot;&gt;Supporting Life Cycle Processes&lt;/h3&gt;
&lt;p&gt;组织类过程包含1个过程组，7个过程：SUP(Supporting)，支持过程组。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/557590/201901/557590-20190127234218632-139411760.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;vda-scope&quot;&gt;VDA Scope&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;VDA Scope（以前的HIS）关注的16个过程:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/557590/201901/557590-20190127233619614-1896541849.jpg&quot;/&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;ACQ.4-供应商监控&lt;/td&gt;
&lt;td&gt;MAN.3-项目管理&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;SUP.1-质量保证&lt;/td&gt;
&lt;td&gt;SYS.2-系统需求分析&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;SUP.8-配置管理&lt;/td&gt;
&lt;td&gt;SYS.3-系统架构设计&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;SUP.9-问题管理&lt;/td&gt;
&lt;td&gt;SYS.4-系统集成和集成测试&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;SUP.10-变更管理&lt;/td&gt;
&lt;td&gt;SYS.5-系统验收测试&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;SWE.1-软件需求分析&lt;/td&gt;
&lt;td&gt;SWE.4-软件单元验证&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;SWE.2-软件架构设计&lt;/td&gt;
&lt;td&gt;SWE.5-软件集成和集成测试&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;SWE.3-软件详细设计和单元实现&lt;/td&gt;
&lt;td&gt;SWE.6-软件验收测试&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;过程结构&quot;&gt;过程结构&lt;/h3&gt;
&lt;p&gt;ASPICE标准的过程使用统一的结构进行描述：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/557590/201901/557590-20190127233656662-173624016.jpg&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Process ID： 过程的唯一标识ID&lt;/li&gt;
&lt;li&gt;Process Name：过程的名字，例如：供应商监控&lt;/li&gt;
&lt;li&gt;Process Purpose：对过程目标的简述&lt;/li&gt;
&lt;li&gt;Process Outecomes：过程成功实施后的结果&lt;/li&gt;
&lt;li&gt;Basic Practices：为确保达到过程结果而建议的过程活动&lt;/li&gt;
&lt;li&gt;Output Work Products：过程实施产生的工作产品，每个工作产品都有一个唯一标识（WP ID) ，一个工作产品和一个或多个过程结果关联&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;Automotive SPICE标准中过程通过ID、名字、目标、结果进行描述，同时提供了过程执行标示，即基础实践和输出的工作产品，这些指示为过程评估提供指导。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;aspice等级&quot;&gt;ASPICE等级&lt;/h2&gt;
&lt;p&gt;ASPICE等级包括能力等级和组织成熟度等级两种类型。组织成熟度等级侧重于组织层面的成熟度。能力等级侧重于单个过程的能力等级，关注于单个项目。能力等级是目前最为普遍使用的方式。ASPICE的能力等级划分与ISO/IEC 33020标准一致，可分为L0-L5共6个等级，如下表所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/557590/201901/557590-20190127233752614-1845091588.jpg&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Incomplete Process 不完全：过程没有被实施，或实施失败（未达到过程目标）&lt;/li&gt;
&lt;li&gt;Performed Process已执行级：过程已经实施，并且达到了过程目标&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;Managed Process | 已管理级: 已执行的过程是通过一种“管理”的方式实施的，即有计划、被监控的和可调整的方式，并且工作产品被适当的确立、控制和维护。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;Established Process |已定义级：组织级别进行了标准过程的定义，不同的项目基于已定义的标准过程进行裁剪。&lt;/li&gt;
&lt;li&gt;Predictable Process |可预测级：量化管理&lt;/li&gt;
&lt;li&gt;Innovating Process | 创新级：过程持续改进以应对组织变化&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;过程属性&quot;&gt;过程属性&lt;/h2&gt;
&lt;p&gt;过程属性为过程能力等级评定提供了可以度量的特性，不同能力等级的过程属性分配参考下表：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/557590/201901/557590-20190127233822621-1857284053.jpg&quot;/&gt;&lt;br/&gt;CL1:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;PA 1.1 Process performance process attribute&lt;br/&gt;CL2:&lt;/li&gt;
&lt;li&gt;PA 2.1 Performance management process attribute，&lt;/li&gt;
&lt;li&gt;PA 2.2 Work product management process attribute&lt;br/&gt;CL3:&lt;/li&gt;
&lt;li&gt;PA 3.1 Process definition process attribute&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;PA 3.2 Process deployment process attribute&lt;br/&gt;CL4:&lt;/li&gt;
&lt;li&gt;PA 4.1 Quantitative analysis process attribute&lt;/li&gt;
&lt;li&gt;PA 4.2 Quantitative control process attribute&lt;br/&gt;CL5:&lt;/li&gt;
&lt;li&gt;PA 5.1 Process innovation process attribute&lt;/li&gt;
&lt;li&gt;PA 5.2 Process innovation implementation&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在Automotive SPICE标准中，每个PA都有与之对应的通用实践和通用资源的描述。以PA1.1为例：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;PA1.1实现的结果是：
&lt;ul&gt;&lt;li&gt;a. 过程获得了其过程结果&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;通用实践
&lt;ul&gt;&lt;li&gt;GP1.1.1
&lt;ul&gt;&lt;li&gt;Achieve the intent of the base practices&lt;/li&gt;
&lt;li&gt;Produce work products that evidence the process outcomes&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;通用资源
&lt;/li&gt;
&lt;li&gt;过程执行指标：仅应用于能力等级L1，为过程结果的实现程度提供指标
&lt;ul&gt;&lt;li&gt;基础实践（BP, Base Practices）&lt;/li&gt;
&lt;li&gt;工作产品（WP, Work Products）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;过程能力指标：应用于能力等级L2-L5. 为过程属性的实现程度提供指标
&lt;ul&gt;&lt;li&gt;通用实践（GP, Generic Practice）：面向活动&lt;/li&gt;
&lt;li&gt;通用资源（GR, Generic Resource）：面向基础设置（资源）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;GP和GR与PA相关，他们对所有的过程通用。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/557590/201901/557590-20190127234046685-1152817615.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;过程能力等级评定&quot;&gt;过程能力等级评定&lt;/h2&gt;
&lt;p&gt;各级别过程能力的评定要求参考下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/557590/201901/557590-20190127233937637-2117675746.jpg&quot;/&gt;&lt;br/&gt;每个过程能力等级的评定要依据于其分配的过程属性评分。对于特定的目标等级，要求该等级的过程属性评分为L或F，且其低级别等级的过程属性评分必须为F。以CL3级别为例，PA3.1和PA3.2至少为L。但对应于CL2的PA2.1、PA2.2以及CL1的PA1.1必须为F。&lt;/p&gt;
</description>
<pubDate>Sun, 27 Jan 2019 15:45:00 +0000</pubDate>
<dc:creator>朝阳小胖</dc:creator>
<og:description>ASPICE学习笔记 微信公众号 SystemEngineeringLab Automotive SPICE于2005年由AutoSIG发布，是SPICE(ISO\IEC15504国际标准)在汽车行业</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nelson2013/p/10328483.html</dc:identifier>
</item>
<item>
<title>20190127-Orleans与SF小伙伴的部分问答 - 几维</title>
<link>http://www.cnblogs.com/CharlesZHENG/p/10328451.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CharlesZHENG/p/10328451.html</guid>
<description>&lt;div class=&quot;markdown-here-wrapper&quot; data-md-url=&quot;https://i.cnblogs.com/EditPosts.aspx?opt=1&quot; readability=&quot;24.529258400927&quot;&gt;
&lt;h5 id=&quot;orleans&quot;&gt;Orleans&lt;/h5&gt;
&lt;ol&gt;&lt;li&gt;怎么部署到服务器？&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;方式1：Orleans 服务端寄宿在Web应用中，将Web应用部署到服务器&lt;/li&gt;
&lt;li&gt;方式2：通过SF/K8s部署到服务器&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;不同服务器上的谷仓和谷如何调配？&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;由Orleans框架调度。当部署到有一组节点的集群时，Orleans在内部实现了一组协议，来发现和维护集群中Orleans silo的成员身份，包括检测节点故障和自动重新配置。&lt;/li&gt;
&lt;/ul&gt;&lt;ol readability=&quot;-1&quot;&gt;&lt;li readability=&quot;1&quot;&gt;谷和谷仓如何连接
&lt;pre&gt;
&lt;code&gt; var silo = new SiloHostBuilder()
 [...]
 // Endpoints
 .ConfigureEndpoints(siloPort: 11111, gatewayPort: 30000)
 [...]
&lt;/code&gt;
&lt;/pre&gt;
Orleans silo有两种典型类型的端点配置：&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;silo-to-silo端点(siloPort)，用于同一集群中的silo之间的通信&lt;/li&gt;
&lt;li&gt;client-to-silo端点（gatewayPort），用于同一集群中的客户端和silo之间的通信&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在示例中，我们使用帮助方法.ConfigureEndpoints(siloPort: 11111, gatewayPort: 30000)，将用于silo-to-silo通信的端口设置为11111和用于网关的端口设置为30000。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;接口、服务、actor概念的边界&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;结合OrleansSample.zip示例程序理解接口、服务、actor的概念&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;明确谷仓的含义&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;Grain的集合&lt;/li&gt;
&lt;li&gt;结合OrleansSample.zip示例程序理解
&lt;h5 id=&quot;actor&quot;&gt;Actor&lt;/h5&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;无状态的Actor上数据如何处理&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;通过调用actor的方法，对actor的字段数据CRUD&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;示例：&lt;br/&gt;Grain:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public class HelloGrain : Orleans.Grain, IHello
    {
        private readonly ILogger logger;
        private string tempData;
        public HelloGrain(ILogger&amp;lt;HelloGrain&amp;gt; logger)
        {
            this.logger = logger;
        }
        Task&amp;lt;string&amp;gt; IHello.SayHello(string greeting)
        {
            var result = string.IsNullOrEmpty(tempData) ? $&quot;You said: '{greeting}', I say: Hello!&quot; : $&quot;You said:'{tempData}-{greeting}'&quot;;
            return Task.FromResult(result);
        }

        public Task SetValue(string temp)
        {
            tempData = temp;
            return Task.CompletedTask;
        }
    }`
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public class HomeController : Controller
    {
        private IClientFactory clientFactory;
        public HomeController(IClientFactory clientFactory)
        {
            this.clientFactory = clientFactory;
        }
        public async Task&amp;lt;IActionResult&amp;gt; Index()
        {
            var client = clientFactory.GetClient();
            var actor = client.GetGrain&amp;lt;IHello&amp;gt;(0);
            var r = await actor.SayHello(&quot;Kiwi&quot;);
            return Content(r);
        }
        public async Task SetValue(string str)
        {
            var client = clientFactory.GetClient();
            var actor = client.GetGrain&amp;lt;IHello&amp;gt;(0);
            await actor.SetValue(str);
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;Actor持续化的过程怎么实现&lt;/li&gt;
&lt;/ol&gt;&lt;ol&gt;&lt;li&gt;多个物理分离的服务如何连接在一起&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;通过&lt;code&gt;orleansmembershiptable&lt;/code&gt;表和Orleans框架维护的协调方式。&lt;/li&gt;
&lt;li&gt;相关回答 Orleans问题 3&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;Orleans+Actor 怎么部署 实际使用&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;相关回答 Orleans 问题 1
&lt;h5 id=&quot;sf&quot;&gt;SF&lt;/h5&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;SF与IIS的区别是什么?&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;Internet Information Service（IIS）是windows开设web网页服务的组件,提供Web、FTP、SMTP等服务，是用来搭载&lt;code&gt;网站运行程序&lt;/code&gt;的平台。&lt;/li&gt;
&lt;li&gt;Service Fabric 是一款分布式系统平台，可方便用户轻松打包、部署和管理可缩放的可靠微服务和容器。&lt;/li&gt;
&lt;li&gt;Service Fabric 可帮助你构建使用微服务方法的应用程序，它提供：
&lt;ol&gt;&lt;li&gt;提供系统服务的平台，用于部署、升级、检测和重启失败的服务、发现服务、路由消息、管理状态和监视运行状况。&lt;/li&gt;
&lt;li&gt;能够部署在容器中运行或作为进程运行的应用程序。 Service Fabric 是容器和进程 Orchestrator。&lt;/li&gt;
&lt;li&gt;有助于以微服务形式生成应用程序的编程模型，如：ASP.NET Core、Reliable Actors。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;SF的节点之间如何保证同步（例：一个节点死掉之后，再复原的时候依据的数据是怎么获得的）&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;可靠性子系统通过使用复制器、故障转移管理器和资源平衡器提供一种机制，使得 Service Fabric 服务的状态高度可用。&lt;br/&gt;复制器确保主服务副本中的状态更改会自动复制到辅助副本，从而维护服务副本集中主副本和辅助副本之间的一致性。 复制器负责副本集中副本间的仲裁管理。 它与故障转移单元进行交互以获取要复制的操作列表，重新配置代理为其提供副本集的配置。 该配置指示操作需要复制到哪些副本。 Service Fabric 提供名为 Fabric Replicator 的默认复制器，编程模型 API 可使用它来使服务状态高度可用和高度可靠。&lt;br/&gt;故障转移管理器确保向群集添加节点或从群集中删除节点时，会自动在可用节点间重新分发负载。 如果群集中的节点失败，群集会自动重新配置服务副本以维持可用性。&lt;br/&gt;Resource Manager 在群集中的失败域之间放置服务副本，并确保所有故障转移单元正常运行。 Resource Manager 还会平衡群集节点基础共享池中的服务资源，从而获得最佳的统一负载分布。&lt;/li&gt;
&lt;li&gt;SF中的微服务支持备份还原、容错域等概念实现高可用&lt;/li&gt;
&lt;li&gt;相关参考&lt;a href=&quot;https://docs.microsoft.com/zh-cn/azure/service-fabric/service-fabric-reliable-services-introduction&quot;&gt;Reliable Services 概述&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;SF与docker的关系&lt;/li&gt;
&lt;/ol&gt;&lt;ol&gt;&lt;li&gt;SF是否可以做到负载均衡&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;一般sf上的微服务之前，会配置专门的负载均衡器。&lt;/li&gt;
&lt;li&gt;支持。&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;在SF中，是否一个node对应多个服务器&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;Service Fabric 群集是一组通过网络连接在一起的虚拟机或物理计算机，微服务会在其中部署和管理。&lt;/li&gt;
&lt;li&gt;群集可以扩展到成千上万台计算机。&lt;/li&gt;
&lt;li&gt;属于群集一部分的计算机或 VM 称为节点。需为每个节点分配节点名称（字符串）。 节点具有各种特征，如放置属性。 每个计算机或 VM 都有一个自动启动 Windows 服务 FabricHost.exe，此服务在引导时开始运行，并启动两个可执行文件：Fabric.exe 和 FabricGateway.exe。 这两个可执行文件构成了节点。在开发或测试方案中，可以通过运行 Fabric.exe 和 FabricGateway.exe 的多个实例，在单台计算机或 VM 上托管多个节点。&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;p&gt;总结：&lt;br/&gt;上面表述摘自官方文档，可以理解为：生产环境，一个node对应一个服务器（一台物理机或一个VM）；测试开发环境，单台计算机或VM可以托管多个node&lt;/p&gt;
&lt;hr/&gt;&lt;ol&gt;&lt;li&gt;actor如何跨服务器通信&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;Silo对消息进行路由的过程分为以下3步
&lt;ol&gt;&lt;li&gt;查找本地的Actor Activation数据字典，如果找到了，直接路由到本地的Actor Activation进行消息处理&lt;/li&gt;
&lt;li&gt;如果本地的Actor Activation数据字典中没有这个Grain,则查找缓存字典,找到后根据字典中的Silo地址，然后将消息路由到对应的Silo&lt;/li&gt;
&lt;li&gt;如果缓存中也没找到，会根据GrainId，通过Consistent Hash来获得目标Silo，进行远程的Silo查找GrainId对应的激活，然后保存到本地的缓存字典中&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;相关参考 Orleans问题3和Actor问题3&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;如果SF部署两个cloud，是两个不同进程吗？&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;Service Fabric 是容器和进程Orchestrator。能够部署在容器中运行或作为进程运行的应用程序。&lt;/li&gt;
&lt;li&gt;sf集群中的协调器，帮助运行其他进程。协调器的数量和机制没有看到相关文档。&lt;/li&gt;
&lt;li&gt;如果Cloud_A下有一个应用程序项目；Cloud_B下有一个应用程序项目，是两个进程。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;​&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Sun, 27 Jan 2019 15:29:00 +0000</pubDate>
<dc:creator>几维</dc:creator>
<og:description>Orleans 怎么部署到服务器？ 方式1：Orleans 服务端寄宿在Web应用中，将Web应用部署到服务器 方式2：通过SF/K8s部署到服务器 不同服务器上的谷仓和谷如何调配？ 由Orleans</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CharlesZHENG/p/10328451.html</dc:identifier>
</item>
<item>
<title>创建型模式：原型模式 - LieBrother</title>
<link>http://www.cnblogs.com/liebrother/p/10328436.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liebrother/p/10328436.html</guid>
<description>&lt;p&gt;个人公众号原文：&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/4GLtg5Qrdpltz4C4-KtLZg&quot;&gt;创建型模式：原型模式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.liebrother.com/upload/4b000c18e7b640f6a72c02cc31559641_0022_01.jpg&quot; alt=&quot;景&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;五大创建型模式之五：原型模式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;姓名&lt;/strong&gt; ：原型模式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;英文名&lt;/strong&gt; ：Prototype Pattern&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;价值观&lt;/strong&gt; ：效率第一&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;个人介绍&lt;/strong&gt; ：&lt;/p&gt;
&lt;p&gt;Specify the kinds of objects to create using a prototypical instance,and create new objects by copying this prototype.&lt;br/&gt;用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。&lt;br/&gt;（来自《设计模式之禅》）&lt;/p&gt;
&lt;p&gt;又到了一个系列的最后一篇文章了，今天是创建型模式的最后一篇。什么是创建型模式呢？创建型模式是对类的实例化过程进行抽象，使对象的创建和使用分离，从而使代码更加灵活。&lt;/p&gt;
&lt;p&gt;我们平时使用最多的一种创建对象方式就是 new ABC()，直接通过构造方法来创建一个对象。通过原型模式来创建对象则不用调用构造方法，就可以创建一个对象。下面来揭开它的面纱。&lt;/p&gt;
&lt;h2 id=&quot;你要的故事&quot;&gt;你要的故事&lt;/h2&gt;
&lt;p&gt;前几天有出版社的老师邀请写书，鉴于深知自己水平还不足以出书，所以没有合作，还在努力学习，以后有能力有机会再考虑这方面的事情。&lt;/p&gt;
&lt;p&gt;今天的故事就从出书讲起。我们知道一本新书发版的时候，会复印很多册，如果销售得好，会有很多个印刷版本。我们来了解复印一批书籍这个过程是怎么实现的。小明写下了下面这段代码。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class NoPrototypeTest {

    public static void main(String[] args) {
        for (int i = 1; i &amp;lt;= 10; i ++) {
            Book book = new Book(&quot;娱乐至死&quot;, &quot;尼尔波兹曼&quot;, &quot;社会科学&quot;, &quot;XXXX&quot;);
            System.out.println(&quot;复印书籍：&quot; + book.getName() + &quot;，第 &quot; + i + &quot; 本&quot;);
        }
    }

}

class Book {
    private String name;
    private String author;
    private String type;
    private String content;

    public Book(String name, String author, String type, String content) {
        this.name = name;
        this.author = author;
        this.type = type;
        this.content = content;
        System.out.println(&quot;实例化书籍：&quot; + this.name);
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getAuthor() {
        return author;
    }

    public void setAuthor(String author) {
        this.author = author;
    }

    public String getType() {
        return type;
    }

    public void setType(String type) {
        this.type = type;
    }

    public String getContent() {
        return content;
    }

    public void setContent(String content) {
        this.content = content;
    }
}

// 打印结果：
实例化书籍：娱乐至死
复印书籍：娱乐至死，第 1 本
实例化书籍：娱乐至死
复印书籍：娱乐至死，第 2 本
实例化书籍：娱乐至死
复印书籍：娱乐至死，第 3 本
实例化书籍：娱乐至死
复印书籍：娱乐至死，第 4 本
实例化书籍：娱乐至死
复印书籍：娱乐至死，第 5 本
实例化书籍：娱乐至死
复印书籍：娱乐至死，第 6 本
实例化书籍：娱乐至死
复印书籍：娱乐至死，第 7 本
实例化书籍：娱乐至死
复印书籍：娱乐至死，第 8 本
实例化书籍：娱乐至死
复印书籍：娱乐至死，第 9 本
实例化书籍：娱乐至死
复印书籍：娱乐至死，第 10 本
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面小明的代码复印了 10 本《娱乐至死》，代码逻辑没有问题，有个问题就是复印一本就实例化一次书籍，这个实例化可以减少么？使用原型模式可以实现。小明根据这些提示，重新修改了代码。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class PrototypeTest {

    public static void main(String[] args) {
        Book2 book1 = new ConcreteBook(&quot;娱乐至死&quot;, &quot;尼尔波兹曼&quot;, &quot;社会科学&quot;, &quot;XXXX&quot;);
        System.out.println(&quot;复印书籍：&quot; + book1.getName() + &quot;，第 &quot; + 1 + &quot; 本&quot;);
        for (int i = 2; i &amp;lt;= 10; i ++) {
            Book2 book2 = (Book2) book1.clone();
            System.out.println(&quot;复印书籍：&quot; + book2.getName() + &quot;，第 &quot; + i + &quot; 本&quot;);
        }


    }

}

/**
 * 抽象类
 */
abstract class Book2 implements Cloneable {

    private String name;
    private String author;
    private String type;
    private String content;

    public Book2(String name, String author, String type, String content) {
        this.name = name;
        this.author = author;
        this.type = type;
        this.content = content;
        System.out.println(&quot;实例化书籍：&quot; + this.name);
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getAuthor() {
        return author;
    }

    public void setAuthor(String author) {
        this.author = author;
    }

    public String getType() {
        return type;
    }

    public void setType(String type) {
        this.type = type;
    }

    public String getContent() {
        return content;
    }

    public void setContent(String content) {
        this.content = content;
    }

    @Override
    protected Object clone() {
        try {
            return super.clone();
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }
        return null;
    }
}

/**
 * 具体类
 */
class ConcreteBook extends Book2 {

    public ConcreteBook(String name, String author, String type, String content) {
        super(name, author, type, content);
    }
}

打印结果：
实例化书籍：娱乐至死
复印书籍：娱乐至死，第 1 本
复印书籍：娱乐至死，第 2 本
复印书籍：娱乐至死，第 3 本
复印书籍：娱乐至死，第 4 本
复印书籍：娱乐至死，第 5 本
复印书籍：娱乐至死，第 6 本
复印书籍：娱乐至死，第 7 本
复印书籍：娱乐至死，第 8 本
复印书籍：娱乐至死，第 9 本
复印书籍：娱乐至死，第 10 本&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看，打印结果和第一次实现的结果完全不一样，这一次只实例化了一次，后面复印的书籍都没有实例化。我们看看代码的变化，代码中最最主要的就是 Book2 实现了 Cloneable 接口，这个接口有个 clone() 方法，通过实现这个方法，可以实现对象的拷贝，就是不用调用构造方法，直接通过对内存的拷贝来创建一个新的对象。这就是原型模式的实现方式，&lt;strong&gt;通过原型模式可以提高创建对象的效率&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;代码：&lt;br/&gt;&lt;a href=&quot;https://github.com/1CSH1/DesignPatterns/blob/master/src/com/liebrother/designpatterns/prototype/&quot;&gt;Prototype Pattern&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;通过原型模式，绕过构造方法创建对象，利用内存直接拷贝对象，提高对象的创建性效率。在有大量的对象创建或者类初始化消耗多资源的场景下可以利用原型模式来优化。当然在实现的过程中，要注意&lt;strong&gt;浅拷贝与深拷贝&lt;/strong&gt;的问题，防止写出 bug，文章主要介绍原型模式，就不详细说这个问题了，留给大家去扩展了解。&lt;/p&gt;
&lt;p&gt;参考资料：《大话设计模式》、《Java设计模式》、《设计模式之禅》、《研磨设计模式》、《Head First 设计模式》&lt;/p&gt;
&lt;p&gt;推荐阅读：&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/aJSf8yESPeex78S6W0FWWw&quot;&gt;创建型模式：单例模式&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/12fLnRxKCYABSItkKvU8Fw&quot;&gt;创建型模式：工厂方法&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/zGDzkvftexHzJqaAL5oSAQ&quot;&gt;创建型模式：抽象工厂&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/iR4vsDblhFd7cmaM9hrfGg&quot;&gt;创建型模式：原型模式&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/mp/homepage?__biz=MzIxMzgwMTAyMg==&amp;amp;hid=2&amp;amp;sn=c97b64288d92312f57d3c8298f8d8888&quot;&gt;公众号之设计模式系列文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;希望文章对您有所帮助，设计模式系列会持续更新，感兴趣的同学可以关注公众号：&lt;strong&gt;LieBrother&lt;/strong&gt;，第一时间获取文章推送阅读，也可以一起交流，交个朋友。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.liebrother.com/upload/df81ac224abe46b38131a0e78f4dcf9c_wechat.jpg&quot; alt=&quot;公众号&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 27 Jan 2019 15:20:00 +0000</pubDate>
<dc:creator>LieBrother</dc:creator>
<og:description>五大创建型模式之五：原型模式。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liebrother/p/10328436.html</dc:identifier>
</item>
<item>
<title>Quartz.NET 3.0.7 + MySql 实现动态调度作业+动态切换版本+多作业引用同一程序集不同版本+持久化+集群(二) - 热敷哥</title>
<link>http://www.cnblogs.com/refuge/p/10325163.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/refuge/p/10325163.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/refuge/p/10324578.html&quot;&gt;Quartz.NET 3.0.7 + MySql 实现动态调度作业+动态切换版本+多作业引用同一程序集不同版本+持久化+集群(一)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;上篇文章搞定了第一个功能.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.利用反射动态创建Job;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2.调度服务如何知道有新的任务来了?是调度服务轮询数据库?还是管理后台通知调度服务?又或者远程代理?&lt;/p&gt;
&lt;p&gt;3.需要一个管理后台,提供启动,暂停,恢复,停止等功能;&lt;/p&gt;
&lt;p&gt;4.至于集群,Quartz.NET 本身就提供该功能,只不过要使用它的持久化方案而已.这个点只需要在配置文件上做做手脚就可以了,并不需要怎么开发.&lt;/p&gt;
&lt;p&gt;5.管理后台如何实现启动,暂停,恢复,停止等功能?靠远程代理?还是通过其他方式?&lt;/p&gt;

&lt;p&gt;接下来解决剩下的问题.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我一直认为世间万物,尘归尘,土归土,本质都是一样的.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;动物与动物交流,机器与机器交流,两个应用程序之间的交流,管你是什么东西交流,都跟人与人交流一样.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;要么你不停的问他,要么你等他告诉你.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;再不济,你俩都看对方不顺眼,不想彼此直接交流,于是找来一个中间人.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;他告诉中间人,中间人告诉你,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;或者中间人不停的问他,有了消息,中间人再告诉你.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;又或者你想要什么消息了,就去问中间人.中间人告诉你没有,那就没有.中间人说&quot;我找一找&quot;,&quot;诶,这里有.来给你消息&quot;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我认为其实就是这么回事儿,当然,我入行不久,理解还不够深入.不过目前我觉得这样理解能解决问题,就够了.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;学习讲究的是方法,一来就研究到最底层,不是明智之举.等哪天发现这么理解不能解决问题,这么理解有问题的时候,再深入研究也不迟.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;还是那句话,路要一步一步走,饭要一口一口吃.存在的就是合理的.&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;当我们在管理后台新增一个作业的时候,作业的信息,比如名称,时间表达式,程序集物理路径,作业类型的完全限定名等,我们肯定是要找张表单独存起来的,所以这里需要新建一张表:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;&lt;img id=&quot;code_img_closed_16c7e062-127b-4ef8-bc3d-b68b91ce0937&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_16c7e062-127b-4ef8-bc3d-b68b91ce0937&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_16c7e062-127b-4ef8-bc3d-b68b91ce0937&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;73&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt; `jobinfo` (
  `Id` &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; AUTO_INCREMENT COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;编号&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  `SchedName` &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;20&lt;/span&gt;) &lt;span&gt;CHARACTER&lt;/span&gt; &lt;span&gt;SET&lt;/span&gt; utf8mb4 &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;调度器名称&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  `JobName` &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;50&lt;/span&gt;) &lt;span&gt;CHARACTER&lt;/span&gt; &lt;span&gt;SET&lt;/span&gt; utf8mb4 &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;''&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;作业名称&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  `JobGroup` &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;20&lt;/span&gt;) &lt;span&gt;CHARACTER&lt;/span&gt; &lt;span&gt;SET&lt;/span&gt; utf8mb4 &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;''&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;作业组&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  `Cron` &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;50&lt;/span&gt;) &lt;span&gt;CHARACTER&lt;/span&gt; &lt;span&gt;SET&lt;/span&gt; utf8mb4 &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;''&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;时间表达式&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  `Second` &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;间隔时间,单位:秒&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  `AssemblyPath` &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;250&lt;/span&gt;) &lt;span&gt;CHARACTER&lt;/span&gt; &lt;span&gt;SET&lt;/span&gt; utf8mb4 &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;''&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;作业程序集物理路径&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  `ClassType` &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;100&lt;/span&gt;) &lt;span&gt;CHARACTER&lt;/span&gt; &lt;span&gt;SET&lt;/span&gt; utf8mb4 &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;''&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;作业完全限定名&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  `StartTime` &lt;/span&gt;&lt;span&gt;datetime&lt;/span&gt; &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;0001-01-01 00:00:00&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;作业开始时间&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  `CreateTime` &lt;/span&gt;&lt;span&gt;datetime&lt;/span&gt; &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;0001-01-01 00:00:00&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;作业创建时间&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  `ProjectTeam` &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;20&lt;/span&gt;) &lt;span&gt;CHARACTER&lt;/span&gt; &lt;span&gt;SET&lt;/span&gt; utf8mb4 &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;项目组&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  `IsDeleted` &lt;/span&gt;&lt;span&gt;tinyint&lt;/span&gt;(&lt;span&gt;4&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;是否删除 0:否 1:是&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt;&lt;span&gt; (`Id`)
) ENGINE&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;InnoDB &lt;span&gt;DEFAULT&lt;/span&gt; CHARSET&lt;span&gt;=&lt;/span&gt;utf8;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;那么这些数据如何让调度服务知道呢?(由于调研 Quartz,NET 框架的时候,看到很多大神说,IIS 回收池有坑.所以我就没考虑把调度服务和管理后台集成在一起)&lt;/p&gt;
&lt;p&gt;我第一版做的轮询 ,就是在调度服务启动的时候,启动一个预先已经建好的轮询job(轮询的间隔时间尽量短一点,调低哑火忍耐时间,设置好失火策略),&lt;/p&gt;
&lt;p&gt;轮询job扫描这张表(下简称:作业表),然后根据表里的某个字段来判断是否已经启动了该job.&lt;/p&gt;
&lt;p&gt;同时,当Job监听器监听到本次轮询job执行完成后,暂停它,避免无谓的轮询.&lt;/p&gt;
&lt;p&gt;当管理后台新增了一个作业时,就通过远程代理对象恢复该轮询job.&lt;/p&gt;
&lt;p&gt;我自以为这个方案很牛B,或者有那么一点点小&quot;聪明&quot;.&lt;/p&gt;
&lt;p&gt;但是,我后来把这个方案干掉了.&lt;/p&gt;
&lt;p&gt;因为要使用远程代理,管理后台就必须要 安装 Quartz.NET ,这一点我感觉很不爽.我只想在调度服务一个地方安装它.&lt;/p&gt;
&lt;p&gt;这里插一句.&lt;/p&gt;
&lt;p&gt;为了实现远程代理,网上找了好多代码,各种配置,都失败了,不知道是我没copy对,还是版本问题.&lt;/p&gt;
&lt;p&gt;这里奉上我自己研究出来的,实测可用的代码.至于远程代理的配置文件,就不贴出来了,网上太多了.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
                RemotingSchedulerProxyFactory proxyFactory = new&lt;span&gt; RemotingSchedulerProxyFactory
                {
                    Address = &quot;tcp://127.0.0.1:555/QuartzScheduler&quot;&lt;span&gt;
                };
                var schedulerProxy = proxyFactory.GetProxy();&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第二版,也就是目前采用的方案:&lt;/p&gt;
&lt;p&gt;在调度服务内利用 owinself 组件内置一个api接口,接收管理后台的请求,拿到作业的数据后,实现该作业的启动,暂停,恢复,停止等操作. &lt;/p&gt;
&lt;p&gt;因此,管理后台不需要安装 Quartz.NET 组件了,只需要操作一下作业表,把作业的信息post给调度服务内置的api接口即可.&lt;/p&gt;
&lt;p&gt;整个设计如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1189148/201901/1189148-20190127204155623-16637230.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;(03 调度服务框架核心 中的 Middleware 大家可以不用理它,仅仅是我拿来练手用的)&lt;/p&gt;
&lt;p&gt;引用关系如下:&lt;/p&gt;
&lt;p&gt;Host 引用 Service ,Service 里面主要是初始化调度器,启动API监听方面的代码;&lt;/p&gt;
&lt;p&gt;Service 引用 Api , Api 接收管理后台的请求&lt;/p&gt;
&lt;p&gt;Api 引用 Logic ,Logic 里面就是具体的对Job的启动,暂停,恢复等操作了.&lt;/p&gt;
&lt;p&gt;另外, Api , Logic 都需要应用 Model&lt;/p&gt;
&lt;p&gt;Logic 还需要引用 BaseJob &lt;/p&gt;
&lt;p&gt;管理后台与调度框架没半毛钱联系.(当然,Model还是要引用一下)&lt;/p&gt;
&lt;p&gt;个人觉得这个设计耦合度比较低了.不过,还是那句话,任何事物都要辩证来看,耦合度是低了,开发量就相对多了一些.&lt;/p&gt;
&lt;p&gt;是时候看看界面了,MVC做的,很清(jian)爽(lou)吧!我的水平实在有限,就这个界面我还是网上抄的模板,当然也参考了这位前辈对Quartz.NET使用方面的一些思路.原谅我,帖子找不到了....&lt;/p&gt;
&lt;p&gt;像很多功能,比如触发器的触发机制选择,执行次数,失火策略等,我就没有在页面上体现了,而是在调度框架内部暂时写死了.一是时间来不及,二是公司的调度任务基本都差不多,没有什么大的区别.不过以后肯定还是要加上.比如我只想今天下午执行10次等等&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1189148/201901/1189148-20190126223204569-1187676081.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 对这个界面做一个简单的说明:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;从&quot;编号&quot;到&quot;程序集&quot;,这些字段的值来自作业表 jobInfo.&lt;/li&gt;
&lt;li&gt;&quot;状态&quot;,&quot;开始时间&quot;,&quot;上次执行&quot;,&quot;下次执行&quot;4个字段来自官方的 qrtz_triggers 表.&lt;/li&gt;
&lt;li&gt;页面暂时不是实时的,要看最新状态需要F5刷新.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于&quot;调度器名称&quot;字段需要特别说明.&lt;/p&gt;
&lt;p&gt;整个框架开发到一半的时候,来了个新需求:&lt;/p&gt;
&lt;p&gt;要同时开多个调度服务(控制台程序)调度不同的任务,但是用同一张数据库表,同一个管理后台来管理.&lt;/p&gt;
&lt;p&gt;比如现在已经启了一个控制台程序了,管理了10个任务;&lt;/p&gt;
&lt;p&gt;再启一个控制台程序,管理另外10个任务,但是管理后台还是同一个,数据库表还是同一张.注意,不是集群,只是想分开管理任务而已.&lt;/p&gt;
&lt;p&gt;基于这个需求,所以设计了&quot;调度器名称&quot;字段.&lt;/p&gt;
&lt;p&gt;了解持久化方案的朋友肯定知道,在quartz.config配置文件中有这么一行:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
  quartz.scheduler.instanceName = &lt;span&gt;wechat&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我的方案就是利用这句配置,&lt;/p&gt;
&lt;p&gt;一个控制台程序(宿主)就是一个调度器,同时,将api地址放到控制台程序的配置文件中:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;add key=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ApiAddress&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:&lt;span&gt;25250&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当我们再开一个控制台程序时,(注意,不是集群),就需要同时修改上面两个配置,&lt;/p&gt;
&lt;p&gt;比如新的控制台程序的配置及新的quartz.config如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 quartz.scheduler.instanceName =&lt;span&gt; refuge

&lt;/span&gt;&amp;lt;add key=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ApiAddress&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:&lt;span&gt;25251&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么,这时候管理后台就需要增加如下配置了:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 &amp;lt;add key=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wechat&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:&lt;span&gt;25250&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
 &amp;lt;add key=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;refuge&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:&lt;span&gt;25251&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当我们点击按钮,发送请求前,先根据这个job的 &quot;调度器名称&quot; 字段从配置文件中获取它应该请求的地址.&lt;/p&gt;
&lt;p&gt;为了做到绝对安全,我在控制台程序的api中添加了过滤器,操作请求过来的时候,检查传过来的job数据中的&quot;调度器名称&quot;是否和该控制台程序中的调度器名称一样.不一样则不做任何操作.&lt;/p&gt;
&lt;p&gt;效果:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1189148/201901/1189148-20190126233512974-880594517.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;既然说到这个份上了,顺便把集群也说了.配置文件就不贴了,网上太多.&lt;/p&gt;
&lt;p&gt;Quartz.NET 的集群功能到底是个什么功能?它实际覆盖两个功能:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;解决单点问题&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;均衡服务器压力&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;解决单点问题&lt;/h2&gt;
&lt;p&gt;简单说就是启动两个控制台程序,作业只会被一个控制台程序调度,当其中一个挂了,另外一个立马开始工作.&lt;/p&gt;
&lt;p&gt;由于我这个框架内置了api,api监听地址肯定不能重复,所以要使用集群,必须修改api地址.&lt;/p&gt;
&lt;p&gt;那么在集群模式下,管理后台怎么知道应该请求哪个api呢?&lt;/p&gt;
&lt;p&gt;我们先看看效果,然后再解释.&lt;/p&gt;
&lt;p&gt;假设现在有两个控制台应用程序,配置如下,调度器名称都叫 &quot;wechat&quot;,并且本身已经存在一个Job了.&lt;/p&gt;
&lt;p&gt;控制台1:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
  &amp;lt;add key=&quot;ApiAddress&quot; value=&quot;http://localhost:25250&quot; /&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;控制台2:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
  &amp;lt;add key=&quot;ApiAddress&quot; value=&quot;http://localhost:25260&quot; /&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;效果图: &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1189148/201901/1189148-20190127210525674-1209550300.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;可以清楚的看到,下面的控制台程序并没有执行Job,现在我们关掉上面的控制台,&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1189148/201901/1189148-20190127210609683-2001890412.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我是20秒的时候关闭的,过了16秒,下面的控制台开始执行了.&lt;/p&gt;
&lt;p&gt;现在来解释下,管理后台的操作到底请求哪个api.&lt;/p&gt;
&lt;p&gt;可能会有朋友认为,肯定要请求 25250 ,因为 25260 的控制台处于&quot;备用&quot;状态,请求它没效果.&lt;/p&gt;
&lt;p&gt;事实上,这样理解是错的.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;就算请求发送到 25260 控制台,虽然表面上这个控制台的调度器是处于&quot;备用&quot;状态,但实际上它只是&quot;待命&quot;而已,有请求过来,它依然能&quot;干活&quot;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&quot;改革春风吹满地&quot;,实践是检验真理的唯一标准.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;还是上面两个控制台,配置文件不变,现在修改一下管理后台的配置文件,api地址修改为 25260&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
   &amp;lt;add key=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wechat&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:25260&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行效果:&lt;/p&gt;
&lt;p&gt;21:18:00左右的时候 ,我通过管理后台启动了 Job2,可以看到 25260 所在的控制台开始干活了.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1189148/201901/1189148-20190127211709608-721103908.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;所以,根本不用担心,以集群的方式运行多个宿主的时候,管理后台应该请求哪一个api,而事实上,我们应该在管理后台的配置文件中,把所有集群的api地址都写上:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &amp;lt;add key=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wechat&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:25250,http://localhost:25260&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后,请求的时候,判断地址是否被监听,只要被监听了,post过去就不会有问题.&lt;br/&gt;比如上面这个配置,如果某一天 25250 控制台挂了,无所谓,25260 不还在么?请求发送到 25260 就OK了.我们要做的仅仅是在请求前判断一下这个地址是否已被监听就行了,没被监听,就换一个.&lt;/p&gt;
&lt;h2&gt;均衡服务器压力&lt;/h2&gt;
&lt;p&gt;这个就直接上图吧!&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1189148/201901/1189148-20190127224535698-2109800087.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;下面来解释一下:&lt;/p&gt;
&lt;p&gt;首先,4个Job的时间表达式都一样: 0/30 * * * * ?&lt;/p&gt;
&lt;p&gt;我先启动上面的控制台,在22:38:00 秒,4个Job都执行完成后,我启动了下面的控制台,可以看到,&quot;负载均衡&quot;是起到了效果的.但是,4个Job在下面的控制台都各自重复了一次.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而且不管Job的间隔时间是多久,不过失火策略是什么,不管哑火的忍耐时间是多久,不管我隔多久启动下面的控制台,我做了很多实验,都会重复.而且迟早会重复一次,比如上面的 Job3 .但是只会重复一次.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这个有点小&quot;坑&quot;...我反复检查了我的代码,感觉不是代码层面的问题.&lt;/p&gt;
&lt;p&gt;我不知道这到底原因是什么?有没有哪位前辈知道的?能否告知一下,或者大概可能是哪个方面的原因?&lt;/p&gt;
&lt;p&gt;先到这吧!太晚了,明天继续写。&lt;/p&gt;

&lt;p&gt;躺在床上，想起一个问题，判断api地址是否被监听不对！&lt;/p&gt;
&lt;p&gt;万一我的集群是在两个服务器上呢？我去......&lt;/p&gt;
&lt;p&gt;我傻逼了......妈蛋......睡觉💤&lt;/p&gt;
</description>
<pubDate>Sun, 27 Jan 2019 15:17:00 +0000</pubDate>
<dc:creator>热敷哥</dc:creator>
<og:description>Quartz.NET 3.0.7 + MySql 实现动态调度作业+动态切换版本+多作业引用同一程序集不同版本+持久化+集群(一) 上篇文章搞定了第一个功能. 1.利用反射动态创建Job; 2.调度服</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/refuge/p/10325163.html</dc:identifier>
</item>
<item>
<title>windows图标变空白解决方案 - Sun2Q</title>
<link>http://www.cnblogs.com/sunlightstoyou/p/10328424.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sunlightstoyou/p/10328424.html</guid>
<description>&lt;p&gt;对磁盘软件路径进行规整，把磁盘不同类型软件进行分类存储后，部分软件在windows桌面为空白，有些在start menu不为空白但是发送至桌面后却变成空白&lt;/p&gt;

&lt;p&gt;工具：search everything&lt;/p&gt;
&lt;p&gt;目标文件：IconCache.*&lt;/p&gt;
&lt;p&gt;利用工具搜索目标文件，进行删除，本质是删除图标的缓存文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1279060/201901/1279060-20190127231350627-1202317553.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;会遇到的问题&quot;&gt;会遇到的问题&lt;/h2&gt;
&lt;p&gt;windows运行时部分IconCache.*是不可删除的&lt;/p&gt;
&lt;h2 id=&quot;应对策略&quot;&gt;应对策略&lt;/h2&gt;
&lt;p&gt;使用微PE工具进入PE系统，实行解决方法。&lt;/p&gt;
</description>
<pubDate>Sun, 27 Jan 2019 15:15:00 +0000</pubDate>
<dc:creator>Sun2Q</dc:creator>
<og:description>windows 图标空白</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sunlightstoyou/p/10328424.html</dc:identifier>
</item>
<item>
<title>JVM调优常用参数和注意点备忘录 - 陈芳志</title>
<link>http://www.cnblogs.com/chenfangzhi/p/10328423.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenfangzhi/p/10328423.html</guid>
<description>&lt;p&gt;本文主要是工作过程中总结的一些jvm调优的参数和注意的地方，作为一个备忘录，先占个坑，有时间在来细化具体的实例。&lt;/p&gt;
&lt;ol readability=&quot;0.48397372088393&quot;&gt;&lt;li&gt;gc日志是覆盖的方式如果文件名字固定会导致上一次被覆盖可以采用这个-Xloggc:backv2_gc_%t.log&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;jinfo&lt;/strong&gt;可以动态修改java -XX:+PrintFlagsFinal -version|grep manageable这些参数&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;打印java可配置的非稳定参数&lt;/strong&gt;：java -XX:+PrintFlagsFinal ，输出的信息中 “:=” 表明了参数被用户或者 JVM 赋值了&lt;/li&gt;
&lt;li&gt;jstat可以查看类加载和gc的耗时信息 -t参数表示每行前面输出时间&lt;/li&gt;
&lt;li&gt;java堆溢出时获取heap dump -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=./m.hprof&lt;/li&gt;
&lt;li&gt;当系统发生OOM错误时，虚拟机在错误发生时运行一段第三方脚本， 比如， 当OOM发生时，重置系统 -XX:OnOutOfMemoryError=c:\reset.bat&lt;/li&gt;
&lt;li&gt;取消outofmemory警告：-XX:-UseGCOverheadLimit&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;获取GC信息&lt;/strong&gt;
&lt;ol readability=&quot;-1.5&quot;&gt;&lt;li&gt;-verbose:gc(-verbose:class可以输出类加载的信息) 或者 -XX:+PrintGC 打印gc日志&lt;/li&gt;
&lt;li&gt;如果要获得更加详细的信息， 可以使用 -XX:+PrintGCDetails.&lt;/li&gt;
&lt;li readability=&quot;2.5&quot;&gt;
&lt;p&gt;如果需要查看新生对象晋升老年代的实际阈值， 可以使用参数 -XX:+PrintTenuringDistribution&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;java8中使用这个参数没有详细输出各个年龄的分布，因为java8默认的收集器是ParallelGC和ParallelGC Old，&lt;br/&gt;这个收集器注重吞吐量没有用年龄，所以没必要打印详细的年龄分布。只会显示晋升到老年代的阈值还有期望的Survivor区的预期大小。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;输出jvm启动时的参数 -XX:+PrintFlagsInitial&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;禁用代码中显示的触发FULL GC&lt;/strong&gt; [System.gc()]：-XX:+DisableExplicitGC&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;64位机器上压缩指针&lt;/strong&gt; -XX:+UseCompressedOops&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;禁用类验证&lt;/strong&gt; -Xverfy:none&lt;/li&gt;
&lt;li&gt;禁用类元数据回收 -Xnoclassgc&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;确定堆内存大小 -Xmx 堆最大内存, -Xms对最小内存&lt;/li&gt;
&lt;li readability=&quot;4.5&quot;&gt;
&lt;p&gt;合理分配新生代和老生代-Xmn 新生代大小, -XX:SurvivorRatio Eden和Survivor空间的比例 默认是8 设置年轻代(包括Eden和两个Survivor区)与年老代的比值(除去持久代) -XX:NewRatio=4 默认是2&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;老年代和新生代大小比例调节&lt;/strong&gt;：如果应用存在大量的临时对象，应该选择更大的年轻代；如果存在相对较多的持久对象，年老代应该适当增大。但很多应用都没有这样明显的特性，在抉择时应该根据以下两点：&lt;br/&gt;a.本着Full GC尽量少的原则，让年老代尽量缓存常用对象，JVM的默认比例1：2也是这个道理&lt;br/&gt;b.通过观察应用一段时间，看其他在峰值时年老代会占多少内存，在不影响Full GC的前提下，根据实际情况加大年轻代，比如可以把比例控制在1：1。但应该给年老代至少预留1/3的增长空间&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;设置每个线程的堆栈大小，如：-Xss128k&lt;/li&gt;
&lt;li&gt;导致jvm停顿的原因
&lt;ol&gt;&lt;li&gt;垃圾收集&lt;/li&gt;
&lt;li&gt;代码反优化&lt;/li&gt;
&lt;li&gt;Flushing code&lt;/li&gt;
&lt;li&gt;类重定义如热加载&lt;/li&gt;
&lt;li&gt;取消偏向锁&lt;/li&gt;
&lt;li&gt;调试动作（死锁检测，输出线程堆栈）&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;STW&lt;/strong&gt;的四个阶段
&lt;ol&gt;&lt;li&gt;Spin阶段:因为jvm在决定进入全局safepoint的时候，有的线程在安全点上，而有的线程不在安全点上，这个阶段是等待未在安全点上的用户线程进入安全点。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/iter_zc/article/details/41892567&quot;&gt;Block阶段:即使进入safepoint，用户线程这时候仍然是running状态，保证用户不在继续执行，需要将用户线程阻塞&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Cleanup:这个阶段是JVM做的一些内部的清理工作&lt;/li&gt;
&lt;li&gt;VM Operation. JVM执行的一些全局性工作，例如GC,代码反优化,偏向锁&lt;br/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;jvm停顿时间的输出&lt;/strong&gt;：-XX:+PrintGCApplicationStoppedTime 上一次gc停顿程序运行时间 -XX:+PrintGCApplicationConcurrentTime&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;jvm停顿原因分析&lt;/strong&gt;： -XX:+PrintSafepointStatistics -XX:PrintSafepointStatisticsCount=1
&lt;ol readability=&quot;-1&quot;&gt;&lt;li&gt;vmop：引发STW的原因，以及触发时间该项常见的输出有：RevokeBias、BulkRevokeBias、Deoptimize、G1IncCollectionPause。GC log可以根据该项内容定位Total time for which application threads…引发的详细信息。&lt;/li&gt;
&lt;li&gt;total ：STW发生时，JVM存在的线程数目。&lt;/li&gt;
&lt;li&gt;initially_running ：STW发生时，仍在运行的线程数，这项是Spin阶段的 时间来源&lt;/li&gt;
&lt;li&gt;wait_to_block ： STW需要阻塞的线程数目，这项是block阶段的时间来源&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;输出如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    发生时间    操作                        线程   总数   正在运行        等待阻塞               
               vmop                    [threads: total initially_running wait_to_block]    [time: spin block sync cleanup vmop] page_trap_count
    0.462: ForceSafepoint              [           8          0              1        ]    [       0     0     0     0     0  ]      0  &lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;-XX:+UnlockDiagnosticVMOptions -XX:-DisplayVMOutput -XX:+LogVMOutput -XX:LogFile=vm.log 可以将详细的停顿信息输出到日志文件中&lt;/li&gt;
&lt;li&gt;来解锁任何额外的隐藏参数-XX:+UnlockDiagnosticVMOptions和-XX:+UnlockExperimentalVMOptions&lt;/li&gt;
&lt;li&gt;输出启动时的参数信息和vm根据环境设置的参数信息： -XX:+PrintCommandLineFlags&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;CMS垃圾收集器的理解
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/onmyway20xx/p/6605324.html&quot;&gt;参数优化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;cms清理老年代并不是&lt;a href=&quot;https://www.zhihu.com/question/41922036/answer/93079526&quot;&gt;FULL GC&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;java启动参数-agentlib,最常用的两种常见一个是jdwp远程调试，还有个hprof内存和CPU分析&lt;/li&gt;
&lt;li&gt;string的intern方法，内部实现是hash数据结构，参数StringTableSize可以用来控制散列桶的数量，java8默认是60013，自定义的话最好设置一个素数&lt;/li&gt;
&lt;li&gt;JIT相关参数：-Djava.compiler=NONE禁用JIT，-XX:+PrintCompilation 打印JIT编译情况&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;定制JIT编译的参数 -XX:CompileCommand&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;待解决：&lt;br/&gt;GC overhead limit exceeded问题&lt;/p&gt;
</description>
<pubDate>Sun, 27 Jan 2019 15:14:00 +0000</pubDate>
<dc:creator>陈芳志</dc:creator>
<og:description>本文主要是工作过程中总结的一些jvm调优的参数和注意的地方，作为一个备忘录，先占个坑，有时间在来细化具体的实例。 1. gc日志是覆盖的方式如果文件名字固定会导致上一次被覆盖可以采用这个 Xloggc</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenfangzhi/p/10328423.html</dc:identifier>
</item>
<item>
<title>java虚拟机内存管理 - WaJC2017</title>
<link>http://www.cnblogs.com/wangjiachun2017/p/10328416.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangjiachun2017/p/10328416.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1576902/201901/1576902-20190127230223615-738734710.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;程序计数器：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。&lt;/li&gt;
&lt;li&gt;程序计数器处于线程独占区&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果线程执行的是&lt;/span&gt;Java&lt;span&gt;方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址，如果正在执行的&lt;/span&gt;&lt;span&gt;native&lt;/span&gt;&lt;span&gt;方法，这个计数器的值为&lt;/span&gt;&lt;span&gt;undefined&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;此区域是唯一一个&lt;/span&gt;Java&lt;span&gt;虚拟机规范中没有规定任何&lt;/span&gt;&lt;span&gt;OutOfMenmoryError&lt;/span&gt;&lt;span&gt;（内存溢出）情况的区域。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Java&lt;span&gt;虚拟机栈&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;&lt;span&gt;虚拟机栈描述的是&lt;/span&gt;Java&lt;span&gt;方法执行的动态内存模型&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;栈帧：每个方法执行，都会创建一个栈帧，伴随这方法从创建到执行完成。用于存储局部变量表，操作数栈，动态链接，方法出口等。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;局部变量表：（&lt;/span&gt;1&lt;span&gt;）&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;存放编译期可知的公众基本数据类型，引用类型，&lt;/span&gt;&lt;span&gt;returnAddress&lt;/span&gt;&lt;span&gt;类型。       （&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;局部变量表的内存空间在编译期完成分配，当进入一个方法时，这个方法需要在帧分配多少内存是固定的，在方法运行期间是不会改变局部变量表的大小&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;大小：当栈帧的内存大于&lt;/span&gt;Java&lt;span&gt;虚拟机栈的内存时，会报&lt;/span&gt;&lt;span&gt;StackOverflowError&lt;/span&gt;&lt;span&gt;或&lt;/span&gt;&lt;span&gt;OutOfMemoryError&lt;/span&gt;&lt;span&gt;内存溢出问题&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;span&gt;【示例&lt;/span&gt;1-1&lt;span&gt;】：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public static void test(){
         test();
}
public static void main(String[] args) {
        AssetPreservationServer.test();
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Java&lt;span&gt;虚拟机栈内存溢出：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1576902/201901/1576902-20190127230546621-601907602.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Java&lt;span&gt;方法执行动态内存模型图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1576902/201901/1576902-20190127230615627-1047235453.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本地方法栈：&lt;/strong&gt;&lt;span&gt;与&lt;/span&gt;Java&lt;span&gt;虚拟机栈的运行都是一致的，唯一的区别是：&lt;/span&gt;&lt;span&gt;Java&lt;/span&gt;&lt;span&gt;虚拟机栈为虚拟机执行&lt;/span&gt;&lt;span&gt;Java&lt;/span&gt;&lt;span&gt;方法服务，而本地方法栈为虚拟机执行&lt;/span&gt;&lt;span&gt;native&lt;/span&gt;&lt;span&gt;方法服务。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Java&lt;span&gt;堆：&lt;/span&gt;&lt;/strong&gt;是虚拟机中管理内存最大的一块区域。也是垃圾收集器主要的管理区域，主要存放对象实例等等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法区：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;   &lt;span&gt;存储虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;   &lt;span&gt;类信息包含：类的版本，字段，接口，方法等等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;运行时常量池：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;   &lt;span&gt;常量池是属于方法区&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码【实例&lt;/span&gt;1-2&lt;span&gt;】&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public static void main(String[] args) {
        String s1 = &quot;abc&quot;;
        String s2 = &quot;abc&quot;;
                
        String s3 = new String(&quot;abc&quot;);
                
        System.out.println(s1 == s2);//true
        System.out.println(s1 == s3);//false
        System.out.println(s1 == s3.intern());//true
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;运行是常量池运行模型【示例&lt;/span&gt;1-3&lt;span&gt;】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1576902/201901/1576902-20190127230923609-529271070.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;解读：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.Java&lt;span&gt;中创建两个变量&lt;/span&gt;&lt;span&gt;s1,s2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;           String s1 = &quot;abc&quot;;&lt;/p&gt;
&lt;p&gt;           String s2 = &quot;abc&quot;;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.程序执行到&lt;/span&gt;s1,s2&lt;span&gt;时，&lt;/span&gt;&lt;span&gt;Java&lt;/span&gt;&lt;span&gt;虚拟机中栈内存开辟一块局部变量，而这块局部变量中存放了&lt;/span&gt;&lt;span&gt;s1&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;s2&lt;/span&gt;&lt;span&gt;两个变量&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.堆内存中就创建&lt;/span&gt;“&lt;span&gt;abc&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;“&lt;/span&gt;&lt;span&gt;abc&lt;/span&gt;&lt;span&gt;”两个实例&lt;/span&gt;&lt;span&gt;,s1&lt;/span&gt;&lt;span&gt;指向一个&lt;/span&gt;&lt;span&gt;abc&lt;/span&gt;&lt;span&gt;实例，&lt;/span&gt;&lt;span&gt;s2&lt;/span&gt;&lt;span&gt;指向另外一个“&lt;/span&gt;&lt;span&gt;abc&lt;/span&gt;&lt;span&gt;”实例&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.我们创建的每一个字符串的都会放到常量池里，所以方法区中就创建了一块常量池，在常量池中，我们可以想象有一张&lt;/span&gt;StringTable&lt;span&gt;表，而它数据类型为一个&lt;/span&gt;&lt;span&gt;HashSet&lt;/span&gt;&lt;span&gt;集合，用来存放我们所实例化的对象，&lt;/span&gt;&lt;span&gt;s1&lt;/span&gt;&lt;span&gt;创建一个“&lt;/span&gt;&lt;span&gt;abc&lt;/span&gt;&lt;span&gt;”，就会放到&lt;/span&gt;&lt;span&gt;HashSet&lt;/span&gt;&lt;span&gt;中，创建一个就存放一个，而&lt;/span&gt;&lt;span&gt;HashSet&lt;/span&gt;&lt;span&gt;的特性是无序不可重复的，所以&lt;/span&gt;&lt;span&gt;s1&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;s2&lt;/span&gt;&lt;span&gt;创建的“&lt;/span&gt;&lt;span&gt;abc&lt;/span&gt;&lt;span&gt;”最后只存放了一个“&lt;/span&gt;&lt;span&gt;abc&lt;/span&gt;&lt;span&gt;”，所以&lt;/span&gt;&lt;span&gt;s1&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;s2&lt;/span&gt;&lt;span&gt;的对应地址显然是相同的（&lt;/span&gt;&lt;span&gt;s1==s2&lt;/span&gt;&lt;span&gt;的值是相等的）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.再创建一个实例&lt;/span&gt;s3&lt;/p&gt;
&lt;p&gt;          String s3 = new String(&quot;abc&quot;);&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6.第&lt;/span&gt;5&lt;span&gt;步创建的实例是我们手动直接创建，我们通过&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt;创建出来的对象是直接放在堆内存里，所以就不用去考虑常量池的问题了。就直接在堆内存中开辟一块空间，将值直接赋给了&lt;/span&gt;&lt;span&gt;s3&lt;/span&gt;&lt;span&gt;，所以&lt;/span&gt;&lt;span&gt;s3==s1&lt;/span&gt;&lt;span&gt;或&lt;/span&gt;&lt;span&gt;s2&lt;/span&gt;&lt;span&gt;时，值是&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;7.当我们在&lt;/span&gt;s3&lt;span&gt;加&lt;/span&gt;&lt;span&gt;intern()&lt;/span&gt;&lt;span&gt;方法时，&lt;/span&gt;&lt;span&gt;s1==s3.intern()&lt;/span&gt;&lt;span&gt;的值为&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;，因为&lt;/span&gt;&lt;span&gt;intern()&lt;/span&gt;&lt;span&gt;这个方法会把我们创建的“&lt;/span&gt;&lt;span&gt;abc&lt;/span&gt;&lt;span&gt;”区域，搬到运行时常量池里面去，产生一个运行时常量，所以&lt;/span&gt;&lt;span&gt;s1==s3.intern()&lt;/span&gt;&lt;span&gt;的值是&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 27 Jan 2019 15:13:00 +0000</pubDate>
<dc:creator>WaJC2017</dc:creator>
<og:description>程序计数器： Java虚拟机栈 【示例1-1】： Java虚拟机栈内存溢出： Java方法执行动态内存模型图： 本地方法栈：与Java虚拟机栈的运行都是一致的，唯一的区别是：Java虚拟机栈为虚拟机执</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wangjiachun2017/p/10328416.html</dc:identifier>
</item>
<item>
<title>一份来自一月寒冬互联网一线的面经（附面试题） - NovaCN</title>
<link>http://www.cnblogs.com/novaCN/p/10328380.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/novaCN/p/10328380.html</guid>
<description>&lt;h3&gt;1.背景：&lt;/h3&gt;
&lt;p&gt;因为公司变动，lz不得不出来看看机会， 面试的岗位主要是后端，历经三周，面了北京大大小小的几家公司，最后收获了满意的offer。&lt;/p&gt;
&lt;p&gt;自己也成长收获了不少， 谨以笔记，自己可以日后回忆，也希望能帮助到最近寒冬下需要找工作的同学，在文章的后面会附上一点小心得和建议。&lt;/p&gt;

&lt;h3&gt;2.level&lt;/h3&gt;
&lt;p&gt;我是16年本科毕业， 算上实习接近2年半-3年的工作经历吧，一直做java后端。  自己定位大概能到p6+的水平。有大厂经验，本科211， 所以面试机会总体来说还是挺多的。&lt;/p&gt;

&lt;h3&gt;3.过程&lt;/h3&gt;
&lt;p&gt;大概是从元旦过后开始写简历，投简历，从7号开始陆陆续续面了若干公司， 有好有坏，以表格形式记录如下，以我面试的时间排序。&lt;/p&gt;
&lt;p&gt;声明：虽然博客没有什么人看，但是如果您认为记录有不实或者伤害到下述公司名誉啥的， 直接联系我删除即可。&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;23.5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;公司&lt;/td&gt;
&lt;td&gt;部门&lt;/td&gt;
&lt;td&gt; 渠道&lt;/td&gt;
&lt;td&gt; 结果&lt;/td&gt;
&lt;td&gt; 感受（办公环境，面试难度，感受）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;14.5&quot;&gt;&lt;td&gt; 
&lt;p class=&quot;p1&quot;&gt;百信银行&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt; 
&lt;p class=&quot;p1&quot;&gt;DevOps&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;Boss&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt; 4+0，拿到offer.&lt;/p&gt;
&lt;p&gt;（4技术面 0hr面，下同）&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;16&quot;&gt;
&lt;p&gt; 百信的位置和办公环境都很不错，位于安贞门。&lt;/p&gt;
&lt;p&gt;面试官人很nice，没有多余的操作， 并且友好地帮我倒了一杯水。&lt;/p&gt;
&lt;p&gt;主要针对简历中的项目，以及java基础进行面试。&lt;/p&gt;
&lt;p&gt;难度也是循序渐进， 说实话因为是第一家面试， 我确实很多地方没有准备好，但是还是感谢面试官给我机会。&lt;/p&gt;
&lt;p&gt;感受：之前感觉银行可能比较水， 但是感觉各方面都挺与时俱进的， 待遇和人文也很有竞争力。 百信应该有大几百人的研发团队，各方面应该都不输于D轮的互联网公司。 总体是比较赞的。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8.5&quot;&gt;&lt;td&gt; 动动&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; Boss&lt;/td&gt;
&lt;td&gt; 线上笔试&lt;/td&gt;
&lt;td readability=&quot;10&quot;&gt;
&lt;p&gt; 3道Codility，英文，大概3h限时， 我应该1h就写完了，用例跑通我就提交了，但是只有一道题ac。（很奇怪，也没有错误用例的提示，和LeetCode有些不一样）&lt;/p&gt;
&lt;p&gt; 然后hr还是让我去面试， 我拒绝了，可能是我当时已经对这家公司没有太大兴趣了。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td&gt;悉见科技&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;笔试+面试&lt;/td&gt;
&lt;td readability=&quot;11&quot;&gt;
&lt;p&gt;一家AI创业公司， 看jd介绍不错就去了。 最后发现是在一个很偏，有点破的创业园，里面环境有点像家乡的网吧。&lt;/p&gt;
&lt;p&gt;笔试3道很简单的题， 面试也没什么深度，面试官说实话感觉挺菜的。&lt;/p&gt;
&lt;p&gt;总体技术和互联网差别很大， 我当时也是抱着练手的态度过去。 所以也没下文了。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt; vivo&lt;/td&gt;
&lt;td&gt; 金融&lt;/td&gt;
&lt;td&gt;Boss &lt;/td&gt;
&lt;td&gt; 视频面试&lt;/td&gt;
&lt;td readability=&quot;9&quot;&gt;
&lt;p&gt; 1面视频面，难度循序渐进，两位面试官提问。 面试官说第二天hr联系我，结果也没联系。我也没问了。&lt;/p&gt;
&lt;p&gt;主要是因为vivo在深圳，我在北京，可能我也不是很想换城市，后面投的都是在北京了。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;td&gt; 美团&lt;/td&gt;
&lt;td&gt; --&lt;/td&gt;
&lt;td&gt; Boss&lt;/td&gt;
&lt;td&gt;3+0 拿到offer &lt;/td&gt;
&lt;td readability=&quot;11&quot;&gt;
&lt;p&gt;美团的环境感觉就是标准的互联网风格，&lt;/p&gt;
&lt;p&gt;面试官也很务实友好， 难度循序渐进，二面会问一些底层，并发的理解。&lt;/p&gt;
&lt;p&gt;美团无论是从技术沉淀还是我面试团队的潜力， 都是我很心仪的。&lt;/p&gt;
&lt;p&gt;很幸运也给了我一个不错的定级和待遇。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;15.5&quot;&gt;&lt;td&gt; 小米&lt;/td&gt;
&lt;td&gt; 有品&lt;/td&gt;
&lt;td&gt; Boss&lt;/td&gt;
&lt;td&gt;2面撤了&lt;/td&gt;
&lt;td readability=&quot;24&quot;&gt;
&lt;p&gt; 说实话，我开始是不想投小米的，但是考虑到我是湖北人，可能回武汉。&lt;/p&gt;
&lt;p&gt;但是！！！我面试之前应该在脉脉上搜一搜这个部门的。&lt;/p&gt;
&lt;p&gt;这个部门位于清河一个挺偏的地方， 周围仿佛回到了18县小乡镇。&lt;/p&gt;
&lt;p&gt;面试官也是low爆炸了，一面面试官穿了一个脱鞋，让我在楼下等了20min，前台态度也不好。&lt;/p&gt;
&lt;p&gt;然后竟然去了一个茶吧台面试。不过一面面试官总体态度还行。（小米不提供饮水，面试官带我去饮料机买了瓶汽水，当然是我自费，从小米出来我就有了带水的习惯了。）&lt;/p&gt;
&lt;p&gt;二面简直是个活宝，上来站着问，你懂hashmap吗， 我简单答了一下数组+链表，然后按理应该往碰撞，或者并发的方向继续问， 结果坐下，抖腿，问什么抓包的原理，然后扯的乱七八糟的。 最后憋了一分钟吧，出了一个很无聊的题（LeetCode第十题）。 我实在不想浪费彼此时间，就直接走了。&lt;/p&gt;
&lt;p&gt;小米本身在我心中还是个挺有态度的公司，和雷总也是老乡。  哎，真是刷新了我的三观。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;11.5&quot;&gt;&lt;td&gt; 脉脉&lt;/td&gt;
&lt;td&gt; 效能&lt;/td&gt;
&lt;td&gt; Boss&lt;/td&gt;
&lt;td&gt; 2+1&lt;/td&gt;
&lt;td readability=&quot;16&quot;&gt;
&lt;p&gt; 脉脉我觉得公司和产品一样nice， 位于768，环境很安静。&lt;/p&gt;
&lt;p&gt;hr笑的很开心，面试官也很有礼节。&lt;/p&gt;
&lt;p&gt;他们主后端是用python， java主要做一些离线和效能的工作。&lt;/p&gt;
&lt;p&gt;因为第一天3面面试官不在， hr让我第二天过去， 但是由于面试过程中了解到是去做效能平台，财务平台。&lt;/p&gt;
&lt;p&gt;秉着发展的考虑，我还是拒绝了。 &lt;/p&gt;
&lt;p&gt;但是我还是推荐脉脉， 小而美。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;13&quot;&gt;&lt;td&gt; 字节跳动&lt;/td&gt;
&lt;td&gt; 广告&lt;/td&gt;
&lt;td&gt; 猎头&lt;/td&gt;
&lt;td&gt; 3+1，拿到offer&lt;/td&gt;
&lt;td readability=&quot;19&quot;&gt;
&lt;p&gt; 面完小米之后，我觉得我不能在小公司上面浪费时间，同时也有了美团的offer。&lt;/p&gt;
&lt;p&gt;于是我把其余的面试都取消了，只剩下了头条和阿里。&lt;/p&gt;
&lt;p&gt;头条办公环境，位置都很好。 每层都有食堂（请我吃了一顿，很好吃）&lt;/p&gt;
&lt;p&gt;同学们给我最大的感受是 年轻，有活力，友好。 还有就是真的忙。&lt;/p&gt;
&lt;p&gt;我身边已经有陆陆续续不少同事选择了头条了。&lt;/p&gt;
&lt;p&gt;面试难度其实没有传说中的那么难， 不至于手写红黑树，但是基本的数据结构和算法要熟悉，每一面都会写算法。&lt;/p&gt;
&lt;p&gt;hr感觉也很尽心尽责。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;14&quot;&gt;&lt;td&gt;阿里巴巴&lt;/td&gt;
&lt;td&gt;文学&lt;/td&gt;
&lt;td&gt;Boss&lt;/td&gt;
&lt;td&gt;3+1&lt;/td&gt;
&lt;td readability=&quot;21&quot;&gt;
&lt;p&gt;阿里巴巴的面试总体有点失望，首先hr没预约会议室，导致在休息区面试。 也没有茶水，虽然我自带了。&lt;/p&gt;
&lt;p&gt;然后是办公区到处都是屏幕，循环着马云的创业视频。&lt;/p&gt;
&lt;p&gt;三面面试中规中矩。&lt;/p&gt;
&lt;p&gt;文学本来就不是我投的部门（我投的uc，不知道咋流过去了，然后让我面试，我也想试一试吧，然后hr说我蚂蚁简历没过，可我压根没投过）&lt;/p&gt;
&lt;p&gt;阿里最难的是hr面，  一个hr非要充当心里学家，问你人生高潮是啥， 非常没有礼貌，说话直接打断，也没什么信用，感觉这群hr把阿里搞得乌烟瘴气。   特别是hr套路很多， 面完了说没有hc，hc要审批（那你喊我来干嘛） ，然后我有很优秀的同事面过了 ，我说有人拿offer了 ，hr又说人家面的早。让我感觉她就是在刷kpi啥的。&lt;/p&gt;
&lt;p&gt;反正这个部门我是不建议去了， 周围拿到文学offer的同事也打算拒了再看看。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;亚马逊&lt;/td&gt;
&lt;td&gt;物流仓储&lt;/td&gt;
&lt;td&gt;Boss&lt;/td&gt;
&lt;td&gt;还没面&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h3&gt;4.总结及建议&lt;/h3&gt;
&lt;p&gt;1.一定要提前准备好，刷一定量的题，特别是现在各大公司都有自己的招聘系统，如果一面就挂了，可能直接就拉黑，后续面试就更难了。&lt;/p&gt;
&lt;p&gt;2.关于刷题，大概刷完剑指offer上面的经典题， 或者leetcode前100道应该就够了，我建议有选择的刷，主攻排序，链表，大文件处理这些面试高频的，也有意义的。&lt;/p&gt;
&lt;p&gt;3.关于练手，我觉得不要有太大的心里负担， 你去一般公司面试，对于公司可能是一种匹配，但是对个人可是一次很好的自我认知反省的机会，甚至会改变后续的很多结果。&lt;/p&gt;
&lt;p&gt;我们结合对行业的了解，如下公司可以说小而美（其实也是大独角兽了），本身就值得加入，面试也有很多收获： 猿辅导，脉脉，探探，瓜子，vivo互联网。&lt;/p&gt;
&lt;p&gt;当然拿大厂的边缘部门练手也未尝不可，就是有风险有记录。&lt;/p&gt;
&lt;p&gt;当然也有一些黑名单，面试官迷之自信，态度傲慢，技术浅显， 建议大家面试前脉脉一下。。&lt;/p&gt;
&lt;p&gt;最后一棒子打死，感觉位于清河的公司，可能都不太利于个人生活和发展。&lt;/p&gt;
&lt;p&gt;4.关于基础，我在下面附上一些前辈整理好的url。一定要夯实打捞。&lt;/p&gt;
&lt;p&gt;5.我觉得面试礼仪是衡量双方的重要标准， 面试者要注重自己的仪表整洁，谈吐礼貌自然。 可以从公司面试官的行为判断出公司的大体人员素质，我个人比较看重公司行政或者面试官是否能给瓶矿泉水或者倒杯水，我认为这是尊重一个面试者的基本表现，虽然后来我都是自己带水。 我面试中就小米和阿里没有(并且阿里文学是饭点约去面试，也不管饭，饿着肚子从5点面到9点多），然后就是双方是否守时，我一般提前20分钟到，提前10分钟给hr打个电话。 &lt;/p&gt;
&lt;p&gt;6.关于面试难度，我觉得正常应该是围绕简历和基础循序渐进，一上来手撕红黑树，给个hard基本要dp的，或许不是真心想招人的。 &lt;/p&gt;
&lt;p&gt;当然，即使难点也不要慌， 表达好自己的思考过程， 即使错了也没太大关系。&lt;/p&gt;
&lt;p&gt;其他的想到在整理吧。&lt;/p&gt;


&lt;h3&gt;5.面试题+基础&lt;/h3&gt;
&lt;p&gt;各家的面试题其实都大同小异， 掌握基础和原理，走到哪都不怕。&lt;/p&gt;
&lt;p&gt;电脑没电了 明天去公司再整理格式吧。&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;strong&gt;reids&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;知道&lt;span class=&quot;s1&quot;&gt;redis吗，&lt;span class=&quot;s1&quot;&gt;redis是如何做持久化的&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;介绍下&lt;span class=&quot;s1&quot;&gt;redis的特点，&lt;span class=&quot;s1&quot;&gt;redis的基本数据结构，数据持久化方式，主从之间如何同步；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;导致&lt;span class=&quot;s1&quot;&gt;redis性能瓶颈的操作&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p4&quot;&gt;redis&lt;span class=&quot;s2&quot;&gt;有哪些接口&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;span class=&quot;s1&quot;&gt;Redis的实现模式；&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;span class=&quot;s1&quot;&gt;redis为什么这么快？&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;strong&gt;java-core&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;p4&quot;&gt;1&lt;span class=&quot;s2&quot;&gt;、List &lt;span class=&quot;s2&quot;&gt;和 Set &lt;span class=&quot;s2&quot;&gt;的区别2&lt;span class=&quot;s2&quot;&gt;、HashSet &lt;span class=&quot;s2&quot;&gt;是如何保证不重复的3&lt;span class=&quot;s2&quot;&gt;、HashMap &lt;span class=&quot;s2&quot;&gt;是线程安全的吗，为什么不是线程安全的（最好画图说明多线程环境下不安全）?4&lt;span class=&quot;s2&quot;&gt;、HashMap &lt;span class=&quot;s2&quot;&gt;的扩容过程5&lt;span class=&quot;s2&quot;&gt;、HashMap 1.7 &lt;span class=&quot;s2&quot;&gt;与 1.8 &lt;span class=&quot;s2&quot;&gt;的 &lt;span class=&quot;s2&quot;&gt;区别，说明 1.8 &lt;span class=&quot;s2&quot;&gt;做了哪些优化，如何优化的？6&lt;span class=&quot;s2&quot;&gt;、final finally finalize7&lt;span class=&quot;s2&quot;&gt;、强引用 &lt;span class=&quot;s2&quot;&gt;、软引用、 &lt;span class=&quot;s2&quot;&gt;弱引用、虚引用8&lt;span class=&quot;s2&quot;&gt;、Java&lt;span class=&quot;s2&quot;&gt;反射9&lt;span class=&quot;s2&quot;&gt;、Arrays.sort &lt;span class=&quot;s2&quot;&gt;实现原理和 Collection &lt;span class=&quot;s2&quot;&gt;实现原理10&lt;span class=&quot;s2&quot;&gt;、LinkedHashMap&lt;span class=&quot;s2&quot;&gt;的应用11&lt;span class=&quot;s2&quot;&gt;、cloneable&lt;span class=&quot;s2&quot;&gt;接口实现原理12&lt;span class=&quot;s2&quot;&gt;、异常分类以及处理机制13&lt;span class=&quot;s2&quot;&gt;、wait&lt;span class=&quot;s2&quot;&gt;和sleep&lt;span class=&quot;s2&quot;&gt;的区别14&lt;span class=&quot;s2&quot;&gt;、数组在内存中如何分配&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;strong&gt;java-&lt;/strong&gt;&lt;span class=&quot;s3&quot;&gt;并发&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;span class=&quot;s1&quot;&gt;1、&lt;span class=&quot;s1&quot;&gt;synchronized 的实现原理以及锁优化？&lt;span class=&quot;s1&quot;&gt;2、&lt;span class=&quot;s1&quot;&gt;volatile 的实现原理？&lt;span class=&quot;s1&quot;&gt;3、&lt;span class=&quot;s1&quot;&gt;Java 的信号灯？&lt;span class=&quot;s1&quot;&gt;4、&lt;span class=&quot;s1&quot;&gt;synchronized 在静态方法和普通方法的区别？&lt;span class=&quot;s1&quot;&gt;5、怎么实现所有线程在等待某个事件的发生才会去执行？&lt;span class=&quot;s1&quot;&gt;6、&lt;span class=&quot;s1&quot;&gt;CAS？&lt;span class=&quot;s1&quot;&gt;CAS 有什么缺陷，如何解决？&lt;span class=&quot;s1&quot;&gt;7、&lt;span class=&quot;s1&quot;&gt;synchronized 和 &lt;span class=&quot;s1&quot;&gt;lock 有什么区别？&lt;span class=&quot;s1&quot;&gt;8、&lt;span class=&quot;s1&quot;&gt;Hashtable 是怎么加锁的 &lt;span class=&quot;s1&quot;&gt;？&lt;span class=&quot;s1&quot;&gt;9、&lt;span class=&quot;s1&quot;&gt;HashMap 的并发问题？&lt;span class=&quot;s1&quot;&gt;10、&lt;span class=&quot;s1&quot;&gt;ConcurrenHashMap 介绍？&lt;span class=&quot;s1&quot;&gt;1.8 中为什么要用红黑树？&lt;span class=&quot;s1&quot;&gt;11、&lt;span class=&quot;s1&quot;&gt;AQS12、如何检测死锁？怎么预防死锁？&lt;span class=&quot;s1&quot;&gt;13、&lt;span class=&quot;s1&quot;&gt;Java 内存模型？&lt;span class=&quot;s1&quot;&gt;14、如何保证多线程下 &lt;span class=&quot;s1&quot;&gt;i++ 结果正确？&lt;span class=&quot;s1&quot;&gt;15、线程池的种类，区别和使用场景？&lt;span class=&quot;s1&quot;&gt;16、分析线程池的实现原理和线程的调度过程？&lt;span class=&quot;s1&quot;&gt;17、线程池如何调优，最大数目如何确认？&lt;span class=&quot;s1&quot;&gt;18、&lt;span class=&quot;s1&quot;&gt;ThreadLocal原理，用的时候需要注意什么？&lt;span class=&quot;s1&quot;&gt;19、&lt;span class=&quot;s1&quot;&gt;CountDownLatch 和 &lt;span class=&quot;s1&quot;&gt;CyclicBarrier 的用法，以及相互之间的差别&lt;span class=&quot;s1&quot;&gt;?20、&lt;span class=&quot;s1&quot;&gt;LockSupport工具&lt;span class=&quot;s1&quot;&gt;21、&lt;span class=&quot;s1&quot;&gt;Condition接口及其实现原理&lt;span class=&quot;s1&quot;&gt;22、&lt;span class=&quot;s1&quot;&gt;Fork/Join框架的理解&lt;span class=&quot;s1&quot;&gt;23、分段锁的原理,锁力度减小的思考&lt;span class=&quot;s1&quot;&gt;24、八种阻塞队列以及各个阻塞队列的特性&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul1&quot;&gt;&lt;li class=&quot;li3&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;单机上一个线程池正在处理服务，如果忽然断电了怎么办（正在处理和阻塞队列里的请求怎么处理）？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li3&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;为什么要使用线程池？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li3&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;线程池有什么作用？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li3&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;说说几种常见的线程池及使用场景。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li3&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;线程池都有哪几种工作队列？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li3&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;怎么理解无界队列和有界队列？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li3&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;线程池中的几种重要的参数及流程说明。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;p2&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;strong&gt;JVM&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;span class=&quot;s1&quot;&gt;1、详细&lt;span class=&quot;s1&quot;&gt;jvm内存模型&lt;span class=&quot;s1&quot;&gt;2、讲讲什么情况下回出现内存溢出，内存泄漏？ &lt;span class=&quot;s1&quot;&gt;3、说说&lt;span class=&quot;s1&quot;&gt;Java线程栈&lt;span class=&quot;s1&quot;&gt;4、&lt;span class=&quot;s1&quot;&gt;JVM 年轻代到年老代的晋升过程的判断条件是什么呢？&lt;span class=&quot;s1&quot;&gt;5、&lt;span class=&quot;s1&quot;&gt;JVM 出现 &lt;span class=&quot;s1&quot;&gt;fullGC 很频繁，怎么去线上排查问题？&lt;span class=&quot;s1&quot;&gt;6、类加载为什么要使用双亲委派模式，有没有什么场景是打破了这个模式？&lt;span class=&quot;s1&quot;&gt;7、类的实例化顺序&lt;span class=&quot;s1&quot;&gt;8、&lt;span class=&quot;s1&quot;&gt;JVM垃圾回收机制，何时触发&lt;span class=&quot;s1&quot;&gt;MinorGC等操作&lt;span class=&quot;s1&quot;&gt;9、&lt;span class=&quot;s1&quot;&gt;JVM 中一次完整的 &lt;span class=&quot;s1&quot;&gt;GC 流程（从 &lt;span class=&quot;s1&quot;&gt;ygc 到 &lt;span class=&quot;s1&quot;&gt;fgc）是怎样的&lt;span class=&quot;s1&quot;&gt;10、各种回收器，各自优缺点，重点&lt;span class=&quot;s1&quot;&gt;CMS、&lt;span class=&quot;s1&quot;&gt;G111、各种回收算法&lt;span class=&quot;s1&quot;&gt;12、&lt;span class=&quot;s1&quot;&gt;OOM错误，&lt;span class=&quot;s1&quot;&gt;stackoverflow错误，&lt;span class=&quot;s1&quot;&gt;permgen space错误&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul1&quot;&gt;&lt;li class=&quot;li3&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;说一下对&lt;span class=&quot;s1&quot;&gt;jvm的理解，&lt;span class=&quot;s1&quot;&gt;jvm的组成部分，各个部分的存储内容以及常见的&lt;span class=&quot;s1&quot;&gt;jvm的问题排查步骤。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li3&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;对&lt;span class=&quot;s1&quot;&gt;JVM熟不熟悉？简单说说类加载过程，里面执行的那些操作？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li3&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;JVM方法区存储内容 &lt;span class=&quot;s1&quot;&gt;是否会动态扩展 &lt;span class=&quot;s1&quot;&gt;是否会出现内存溢出 &lt;span class=&quot;s1&quot;&gt;出现的原因有哪些。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li4&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;s2&quot;&gt;介绍介绍CMS&lt;span class=&quot;s2&quot;&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li3&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;介绍介绍&lt;span class=&quot;s1&quot;&gt;G1。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li4&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;s2&quot;&gt;为什么jdk8&lt;span class=&quot;s2&quot;&gt;用metaspace&lt;span class=&quot;s2&quot;&gt;数据结构用来替代perm&lt;span class=&quot;s2&quot;&gt;？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li3&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;简单谈谈堆外内存以及你的理解和认识。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li3&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;JVM的内存模型的理解，&lt;span class=&quot;s1&quot;&gt;threadlocal使用场景及注意事项？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li3&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;JVM老年代和新生代的比例？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li4&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;jstack&lt;span class=&quot;s2&quot;&gt;,jmap&lt;span class=&quot;s2&quot;&gt;,jutil&lt;span class=&quot;s2&quot;&gt;分别的意义？如何线上排查JVM&lt;span class=&quot;s2&quot;&gt;的相关问题？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li3&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;Java虚拟机中，数据类型可以分为哪几类？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li3&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;怎么理解栈、堆？堆中存什么？栈中存什么？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li3&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;为什么要把堆和栈区分出来呢？栈中不是也可以存储数据吗？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li3&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;在&lt;span class=&quot;s1&quot;&gt;Java中，什么是是栈的起始点，同是也是程序的起始点？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li3&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;为什么不把基本类型放堆中呢？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li3&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;Java中的参数传递时传值呢？还是传引用？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li3&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;Java中有没有指针的概念？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li3&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;Java中，栈的大小通过什么参数来设置？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li3&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;一个空&lt;span class=&quot;s1&quot;&gt;Object对象的占多大空间？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li3&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;对象引用类型分为哪几类？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li3&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;讲一讲垃圾回收算法。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li3&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;如何解决内存碎片的问题？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li3&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;如何解决同时存在的对象创建和对象回收问题？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li3&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;讲一讲内存分代及生命周期。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li3&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;什么情况下触发垃圾回收？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li3&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;如何选择合适的垃圾收集算法？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li3&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;JVM中最大堆大小有没有限制？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li3&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;堆大小通过什么参数设置？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li3&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;JVM有哪三种垃圾回收器？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li3&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;吞吐量优先选择什么垃圾回收器？响应时间优先呢？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li3&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;如何进行&lt;span class=&quot;s1&quot;&gt;JVM调优？有哪些方法？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li3&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;如何理解内存泄漏问题？有哪些情况会导致内存泄露？如何解决？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;p2&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;strong&gt;Spring&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;p4&quot;&gt;1&lt;span class=&quot;s2&quot;&gt;、BeanFactory &lt;span class=&quot;s2&quot;&gt;和 FactoryBean&lt;span class=&quot;s2&quot;&gt;？2&lt;span class=&quot;s2&quot;&gt;、Spring IOC &lt;span class=&quot;s2&quot;&gt;的理解，其初始化过程？3&lt;span class=&quot;s2&quot;&gt;、BeanFactory &lt;span class=&quot;s2&quot;&gt;和 ApplicationContext&lt;span class=&quot;s2&quot;&gt;？4&lt;span class=&quot;s2&quot;&gt;、Spring Bean &lt;span class=&quot;s2&quot;&gt;的生命周期，如何被管理的？5&lt;span class=&quot;s2&quot;&gt;、Spring Bean &lt;span class=&quot;s2&quot;&gt;的加载过程是怎样的？6&lt;span class=&quot;s2&quot;&gt;、如果要你实现Spring AOP&lt;span class=&quot;s2&quot;&gt;，请问怎么实现？7&lt;span class=&quot;s2&quot;&gt;、如果要你实现Spring IOC&lt;span class=&quot;s2&quot;&gt;，你会注意哪些问题？8&lt;span class=&quot;s2&quot;&gt;、Spring &lt;span class=&quot;s2&quot;&gt;是如何管理事务的，事务管理机制？9&lt;span class=&quot;s2&quot;&gt;、Spring &lt;span class=&quot;s2&quot;&gt;的不同事务传播行为有哪些，干什么用的？10&lt;span class=&quot;s2&quot;&gt;、Spring &lt;span class=&quot;s2&quot;&gt;中用到了那些设计模式？11&lt;span class=&quot;s2&quot;&gt;、Spring MVC &lt;span class=&quot;s2&quot;&gt;的工作原理？12&lt;span class=&quot;s2&quot;&gt;、Spring &lt;span class=&quot;s2&quot;&gt;循环注入的原理？13&lt;span class=&quot;s2&quot;&gt;、Spring AOP&lt;span class=&quot;s2&quot;&gt;的理解，各个术语，他们是怎么相互工作的？14&lt;span class=&quot;s2&quot;&gt;、Spring &lt;span class=&quot;s2&quot;&gt;如何保证 Controller &lt;span class=&quot;s2&quot;&gt;并发的安全？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;strong&gt;Netty&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p5&quot;&gt;分布式相关&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;span class=&quot;s1&quot;&gt;1、&lt;span class=&quot;s1&quot;&gt;Dubbo的底层实现原理和机制&lt;span class=&quot;s1&quot;&gt;2、描述一个服务从发布到被消费的详细过程&lt;span class=&quot;s1&quot;&gt;3、分布式系统怎么做服务治理&lt;span class=&quot;s1&quot;&gt;4、接口的幂等性的概念&lt;span class=&quot;s1&quot;&gt;5、消息中间件如何解决消息丢失问题&lt;span class=&quot;s1&quot;&gt;6、&lt;span class=&quot;s1&quot;&gt;Dubbo的服务请求失败怎么处理&lt;span class=&quot;s1&quot;&gt;7、重连机制会不会造成错误&lt;span class=&quot;s1&quot;&gt;8、对分布式事务的理解&lt;span class=&quot;s1&quot;&gt;9、如何实现负载均衡，有哪些算法可以实现？&lt;span class=&quot;s1&quot;&gt;10、&lt;span class=&quot;s1&quot;&gt;Zookeeper的用途，选举的原理是什么？&lt;span class=&quot;s1&quot;&gt;11、数据的垂直拆分水平拆分。&lt;span class=&quot;s1&quot;&gt;12、&lt;span class=&quot;s1&quot;&gt;zookeeper原理和适用场景&lt;span class=&quot;s1&quot;&gt;13、&lt;span class=&quot;s1&quot;&gt;zookeeper watch机制&lt;span class=&quot;s1&quot;&gt;14、&lt;span class=&quot;s1&quot;&gt;redis/zk节点宕机如何处理&lt;span class=&quot;s1&quot;&gt;15、分布式集群下如何做到唯一序列号&lt;span class=&quot;s1&quot;&gt;16、如何做一个分布式锁&lt;span class=&quot;s1&quot;&gt;17、用过哪些&lt;span class=&quot;s1&quot;&gt;MQ，怎么用的，和其他&lt;span class=&quot;s1&quot;&gt;mq比较有什么优缺点，&lt;span class=&quot;s1&quot;&gt;MQ的连接是线程安全的吗&lt;span class=&quot;s1&quot;&gt;18、&lt;span class=&quot;s1&quot;&gt;MQ系统的数据如何保证不丢失&lt;span class=&quot;s1&quot;&gt;19、列举出你能想到的数据库分库分表策略；分库分表后，如何解决全表查询的问题&lt;span class=&quot;s1&quot;&gt;20、&lt;span class=&quot;s1&quot;&gt;zookeeper的选举策略&lt;span class=&quot;s1&quot;&gt;21、全局&lt;span class=&quot;s1&quot;&gt;ID&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;strong&gt;mysql:&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;p4&quot;&gt;http://www.iocoder.cn/Interview/MySQL-01/&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;span class=&quot;s1&quot;&gt;mysql索引的实现原理&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;span class=&quot;s1&quot;&gt;Innodb中，什么是聚集索引，非聚集索引，他们是什么关系&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;插入一条记录时，聚集索引和非聚集索引是如何修改的&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;建立索引的标准是什么&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;查看 &lt;span class=&quot;s1&quot;&gt;SQL 是不是使用了索引？（有什么工具）&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;span class=&quot;s1&quot;&gt;SQL 索引的顺序，字段的顺序&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;span class=&quot;s1&quot;&gt;MySQL 分页查询语句,&lt;span class=&quot;s1&quot;&gt;mysql分页有什么优化&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt; &lt;/p&gt;
</description>
<pubDate>Sun, 27 Jan 2019 15:03:00 +0000</pubDate>
<dc:creator>NovaCN</dc:creator>
<og:description>1.背景： 因为公司变动，lz不得不出来看看机会， 面试的岗位主要是后端，历经三周，面了北京大大小小的几家公司，最后收获了满意的offer。 自己也成长收获了不少， 谨以笔记，自己可以日后回忆，也希望</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/novaCN/p/10328380.html</dc:identifier>
</item>
<item>
<title>SpringBoot(二十六)整合Redis之共享Session - 请叫我头头哥</title>
<link>http://www.cnblogs.com/toutou/p/redis_session.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/toutou/p/redis_session.html</guid>
<description>&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mapper &lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt;=&quot;com.demo.dao.UserAccountMapper&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;resultMap &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;BaseResultMap&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;com.demo.pojo.UserAccount&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;id &lt;/span&gt;&lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&quot;id&quot;&lt;/span&gt;&lt;span&gt; jdbcType&lt;/span&gt;&lt;span&gt;=&quot;INTEGER&quot;&lt;/span&gt;&lt;span&gt; property&lt;/span&gt;&lt;span&gt;=&quot;id&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&quot;username&quot;&lt;/span&gt;&lt;span&gt; jdbcType&lt;/span&gt;&lt;span&gt;=&quot;VARCHAR&quot;&lt;/span&gt;&lt;span&gt; property&lt;/span&gt;&lt;span&gt;=&quot;username&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&quot;age&quot;&lt;/span&gt;&lt;span&gt; jdbcType&lt;/span&gt;&lt;span&gt;=&quot;INTEGER&quot;&lt;/span&gt;&lt;span&gt; property&lt;/span&gt;&lt;span&gt;=&quot;age&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&quot;phone&quot;&lt;/span&gt;&lt;span&gt; jdbcType&lt;/span&gt;&lt;span&gt;=&quot;BIGINT&quot;&lt;/span&gt;&lt;span&gt; property&lt;/span&gt;&lt;span&gt;=&quot;phone&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&quot;email&quot;&lt;/span&gt;&lt;span&gt; jdbcType&lt;/span&gt;&lt;span&gt;=&quot;VARCHAR&quot;&lt;/span&gt;&lt;span&gt; property&lt;/span&gt;&lt;span&gt;=&quot;email&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&quot;account&quot;&lt;/span&gt;&lt;span&gt; jdbcType&lt;/span&gt;&lt;span&gt;=&quot;VARCHAR&quot;&lt;/span&gt;&lt;span&gt; property&lt;/span&gt;&lt;span&gt;=&quot;account&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&quot;pwd&quot;&lt;/span&gt;&lt;span&gt; jdbcType&lt;/span&gt;&lt;span&gt;=&quot;VARCHAR&quot;&lt;/span&gt;&lt;span&gt; property&lt;/span&gt;&lt;span&gt;=&quot;pwd&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;resultMap&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;sql &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;Base_Column_List&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    id, username, age, phone, email, account, pwd
  &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;sql&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;selectByPrimaryKey&quot;&lt;/span&gt;&lt;span&gt; parameterType&lt;/span&gt;&lt;span&gt;=&quot;java.lang.Integer&quot;&lt;/span&gt;&lt;span&gt; resultMap&lt;/span&gt;&lt;span&gt;=&quot;BaseResultMap&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    select 
    &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;include &lt;/span&gt;&lt;span&gt;refid&lt;/span&gt;&lt;span&gt;=&quot;Base_Column_List&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
    from useraccount
    where id = #{id,jdbcType=INTEGER}
  &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;getUserByAccount&quot;&lt;/span&gt;&lt;span&gt; parameterType&lt;/span&gt;&lt;span&gt;=&quot;java.lang.String&quot;&lt;/span&gt;&lt;span&gt; resultMap&lt;/span&gt;&lt;span&gt;=&quot;BaseResultMap&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    select
    &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;include &lt;/span&gt;&lt;span&gt;refid&lt;/span&gt;&lt;span&gt;=&quot;Base_Column_List&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
    from useraccount
    where account = #{account}
  &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;delete &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;deleteByPrimaryKey&quot;&lt;/span&gt;&lt;span&gt; parameterType&lt;/span&gt;&lt;span&gt;=&quot;java.lang.Integer&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    delete from useraccount
    where id = #{id,jdbcType=INTEGER}
  &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;insert &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;insert&quot;&lt;/span&gt;&lt;span&gt; parameterType&lt;/span&gt;&lt;span&gt;=&quot;com.demo.pojo.UserAccount&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    insert into useraccount (id, username, age, 
      phone, email, account, 
      pwd)
    values (#{id,jdbcType=INTEGER}, #{username,jdbcType=VARCHAR}, #{age,jdbcType=INTEGER}, 
      #{phone,jdbcType=BIGINT}, #{email,jdbcType=VARCHAR}, #{account,jdbcType=VARCHAR}, 
      #{pwd,jdbcType=VARCHAR})
  &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;insert &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;insertSelective&quot;&lt;/span&gt;&lt;span&gt; parameterType&lt;/span&gt;&lt;span&gt;=&quot;com.demo.pojo.UserAccount&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    insert into useraccount
    &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;trim &lt;/span&gt;&lt;span&gt;prefix&lt;/span&gt;&lt;span&gt;=&quot;(&quot;&lt;/span&gt;&lt;span&gt; suffix&lt;/span&gt;&lt;span&gt;=&quot;)&quot;&lt;/span&gt;&lt;span&gt; suffixOverrides&lt;/span&gt;&lt;span&gt;=&quot;,&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;if &lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;=&quot;id != null&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        id,
      &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;if &lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;=&quot;username != null&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        username,
      &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;if &lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;=&quot;age != null&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        age,
      &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;if &lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;=&quot;phone != null&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        phone,
      &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;if &lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;=&quot;email != null&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        email,
      &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;if &lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;=&quot;account != null&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        account,
      &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;if &lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;=&quot;pwd != null&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        pwd,
      &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;trim&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;trim &lt;/span&gt;&lt;span&gt;prefix&lt;/span&gt;&lt;span&gt;=&quot;values (&quot;&lt;/span&gt;&lt;span&gt; suffix&lt;/span&gt;&lt;span&gt;=&quot;)&quot;&lt;/span&gt;&lt;span&gt; suffixOverrides&lt;/span&gt;&lt;span&gt;=&quot;,&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;if &lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;=&quot;id != null&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        #{id,jdbcType=INTEGER},
      &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;if &lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;=&quot;username != null&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        #{username,jdbcType=VARCHAR},
      &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;if &lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;=&quot;age != null&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        #{age,jdbcType=INTEGER},
      &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;if &lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;=&quot;phone != null&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        #{phone,jdbcType=BIGINT},
      &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;if &lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;=&quot;email != null&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        #{email,jdbcType=VARCHAR},
      &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;if &lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;=&quot;account != null&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        #{account,jdbcType=VARCHAR},
      &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;if &lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;=&quot;pwd != null&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        #{pwd,jdbcType=VARCHAR},
      &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;trim&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;update &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;updateByPrimaryKeySelective&quot;&lt;/span&gt;&lt;span&gt; parameterType&lt;/span&gt;&lt;span&gt;=&quot;com.demo.pojo.UserAccount&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    update useraccount
    &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;if &lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;=&quot;username != null&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        username = #{username,jdbcType=VARCHAR},
      &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;if &lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;=&quot;age != null&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        age = #{age,jdbcType=INTEGER},
      &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;if &lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;=&quot;phone != null&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        phone = #{phone,jdbcType=BIGINT},
      &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;if &lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;=&quot;email != null&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        email = #{email,jdbcType=VARCHAR},
      &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;if &lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;=&quot;account != null&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        account = #{account,jdbcType=VARCHAR},
      &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;if &lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;=&quot;pwd != null&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        pwd = #{pwd,jdbcType=VARCHAR},
      &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    where id = #{id,jdbcType=INTEGER}
  &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;update&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;update &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;updateByPrimaryKey&quot;&lt;/span&gt;&lt;span&gt; parameterType&lt;/span&gt;&lt;span&gt;=&quot;com.demo.pojo.UserAccount&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    update useraccount
    set username = #{username,jdbcType=VARCHAR},
      age = #{age,jdbcType=INTEGER},
      phone = #{phone,jdbcType=BIGINT},
      email = #{email,jdbcType=VARCHAR},
      account = #{account,jdbcType=VARCHAR},
      pwd = #{pwd,jdbcType=VARCHAR}
    where id = #{id,jdbcType=INTEGER}
  &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;update&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mapper&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;</description>
<pubDate>Sun, 27 Jan 2019 14:32:00 +0000</pubDate>
<dc:creator>请叫我头头哥</dc:creator>
<og:description>集群现在越来越常见，当我们项目搭建了集群，就会产生session共享问题。因为session是保存在服务器上面的。那么解决这一问题，大致有三个方案，1.通过nginx的负载均衡其中一种ip绑定来实现（</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/toutou/p/redis_session.html</dc:identifier>
</item>
</channel>
</rss>