<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>『读书』可复制的领导力 - LieBrother</title>
<link>http://www.cnblogs.com/liebrother/p/11462817.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liebrother/p/11462817.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1563867/201909/1563867-20190905082604424-1130408244.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这本书是樊登老师写的，在看这本书前，听过这本书的语音讲解、樊登老师内部 3 天的领导力培训以及低风险创业的培训，大概对书里的内容已经有了初步的了解，也非常认可里面的一些理论实践，所以就花点时间去看。&lt;/p&gt;
&lt;p&gt;看书的过程，和以往的不一样。以前看书，特别是技术书，我喜欢在电脑上看，因为可以边看边做笔记，但是看非技术的书就喜欢在手机看，而不做笔记，这本书比较特别，里面有很多工具类的理论和实践指导，记录下来会有价值，所以尝试了在手机边看边记录，使用了『幕布』这个思维导图软件，好像打开了一扇窗，这个软件太棒了，下载了很久了，但是一直没有去使用，有读书习惯的朋友可以考虑下载一个。&lt;/p&gt;
&lt;p&gt;下面这一张图是记录下来的笔记。比较大，在电脑看比较清晰，手机很模糊。&lt;strong&gt;想看原件的可以在微信后台回复『领导力』得到幕布原文件&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;embed src=&quot;https://img2018.cnblogs.com/blog/1563867/201909/1563867-20190905082628427-1914647882.jpeg;charset=UTF-8&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看完这本书感受挺深的，在微信读书上，我写下了这么一句总结：&lt;strong&gt;结合樊登的内部员工培训教程、低风险创业课程和读书会 App 对这本书的讲解会非常深刻，在以人为本的基础上应用各种工具使工作的每个人都有所成长，实现团队价值的同时实现自我价值。&lt;/strong&gt; 这句话也得到了领导的认可。&lt;/p&gt;
&lt;p&gt;很建议每个人都去看这本书，我也推荐了身边的朋友去看。如果你是领导者，看一看，也许有你需要用的工具去打造你想要的企业；如果你不是领导者，看一看，了解领导做的一些事情是基于什么考虑的，学会换位思考。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;薅当当网羊毛&lt;/strong&gt;：&lt;a href=&quot;https://mp.weixin.qq.com/s/QoL1iXBW-zOlIEhYzGA67A&quot;&gt;福利又送上&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;推荐阅读&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/Euc2NKvK_TsqvcT-DWpD5A&quot;&gt;吃个快餐都能学到串行、并行、并发&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/yWqFw_S7suYpqszuJFDsGg&quot;&gt;泡一杯茶，学一学同异步&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/HJIVxnzyDesYPGGyJsaFyQ&quot;&gt;进程知多少？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/WiPwb7AyVlxyr1_kYXt96w&quot;&gt;设计模式看了又忘，忘了又看？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;后台回复『设计模式』可以获取《一故事一设计模式》电子书&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;觉得文章有用帮忙转发&amp;amp;点赞，多谢朋友们！&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;embed src=&quot;https://img2018.cnblogs.com/blog/1563867/201909/1563867-20190905082633434-1183722772.jpeg;charset=UTF-8&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 05 Sep 2019 00:27:00 +0000</pubDate>
<dc:creator>LieBrother</dc:creator>
<og:description>这本书是樊登老师写的，在看这本书前，听过这本书的语音讲解、樊登老师内部 3 天的领导力培训以及低风险创业的培训，大概对书里的内容已经有了初步的了解，也非常认可里面的一些理论实践，所以就花点时间去看。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/liebrother/p/11462817.html</dc:identifier>
</item>
<item>
<title>分布式全局唯一ID生成策略​ - 风尘博客</title>
<link>http://www.cnblogs.com/vandusty/p/11462585.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/vandusty/p/11462585.html</guid>
<description>&lt;h3 id=&quot;一背景&quot;&gt;一、背景&lt;/h3&gt;
&lt;p&gt;分布式系统中我们会对一些数据量大的业务进行分拆，如：用户表，订单表。因为数据量巨大一张表无法承接，就会对其进行分库分表。&lt;br/&gt;但一旦涉及到分库分表，就会引申出分布式系统中唯一主键&lt;code&gt;ID&lt;/code&gt;的生成问题。&lt;/p&gt;
&lt;h4 id=&quot;唯一id的特性&quot;&gt;1.1 唯一ID的特性&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;整个系统&lt;code&gt;ID&lt;/code&gt;唯一;&lt;/li&gt;
&lt;li&gt;ID是数字类型，而且是趋势递增;&lt;/li&gt;
&lt;li&gt;ID简短，查询效率快。&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;递增与趋势递增&quot;&gt;1.2 递增与趋势递增&lt;/h4&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;6&quot;&gt;&lt;td&gt;第一次生成的ID为12，下一次生成的ID是13，再下一次生成的ID是14。&lt;/td&gt;
&lt;td&gt;什么是？如：在一段时间内，生成的ID是递增的趋势。如：再一段时间内生成的ID在【0，1000】之间，过段时间生成的ID在【1000，2000】之间。但在【0-1000】区间内的时候，ID生成有可能第一次是12，第二次是10，第三次是14。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;二方案&quot;&gt;二、方案&lt;/h3&gt;
&lt;h4 id=&quot;uuid&quot;&gt;2.1 UUID&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;UUID&lt;/code&gt;全称:&lt;code&gt;Universally Unique Identifier&lt;/code&gt;。标准型式包含32个16进制数字，以连字号分为五段，形式为&lt;code&gt;8-4-4-4-12&lt;/code&gt;的36个字符，示例：&lt;code&gt;9628f6e9-70ca-45aa-9f7c-77afe0d26e05&lt;/code&gt;。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;代码实现简单;&lt;/li&gt;
&lt;li&gt;本机生成，没有性能问题;&lt;/li&gt;
&lt;li&gt;因为是全球唯一的&lt;code&gt;ID&lt;/code&gt;，所以迁移数据容易。&lt;/li&gt;
&lt;/ol&gt;&lt;ol&gt;&lt;li&gt;每次生成的&lt;code&gt;ID&lt;/code&gt;是无序的，无法保证趋势递增;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;UUID&lt;/code&gt;的字符串存储，查询效率慢;&lt;/li&gt;
&lt;li&gt;存储空间大;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ID&lt;/code&gt;本身无业务含义，不可读。&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;应用场景：&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;类似生成token令牌的场景;&lt;/li&gt;
&lt;li&gt;不适用一些要求有趋势递增的ID场景,不适合作为高性能需求的场景下的数据库主键。&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;4.7412587412587&quot;&gt;
&lt;p&gt;也有在线生成&lt;code&gt;UUID&lt;/code&gt;的网站，如果你的项目上用到了&lt;code&gt;UUID&lt;/code&gt;，可以用来生成临时的测试数据。&lt;a href=&quot;https://www.uuidgenerator.net/&quot; class=&quot;uri&quot;&gt;https://www.uuidgenerator.net/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;mysql主键自增&quot;&gt;2.2 MySQL主键自增&lt;/h4&gt;
&lt;p&gt;利用了&lt;code&gt;MySQL&lt;/code&gt;的主键自增&lt;code&gt;auto_increment&lt;/code&gt;，默认每次&lt;code&gt;ID&lt;/code&gt;加&lt;code&gt;1&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;数字化，&lt;code&gt;ID&lt;/code&gt;递增;&lt;/li&gt;
&lt;li&gt;查询效率高;&lt;/li&gt;
&lt;li&gt;具有一定的业务可读。&lt;/li&gt;
&lt;/ol&gt;&lt;ol&gt;&lt;li&gt;存在单点问题，如果&lt;code&gt;MySQL&lt;/code&gt;挂了，就没法生成&lt;code&gt;ID&lt;/code&gt;了;&lt;/li&gt;
&lt;li&gt;数据库压力大，高并发抗不住。&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;mysql多实例主键自增&quot;&gt;2.3 MySQL多实例主键自增&lt;/h4&gt;
&lt;p&gt;这个方案就是解决&lt;code&gt;MySQL&lt;/code&gt;的单点问题，在&lt;code&gt;auto_increment&lt;/code&gt;基本上面，设置&lt;code&gt;step&lt;/code&gt;步长&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1768363/201909/1768363-20190904234920358-510205343.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上，每台的初始值分别为&lt;code&gt;1&lt;/code&gt;,&lt;code&gt;2&lt;/code&gt;,&lt;code&gt;3&lt;/code&gt;...&lt;code&gt;N&lt;/code&gt;，步长为&lt;code&gt;N&lt;/code&gt;（这个案例步长为&lt;code&gt;4&lt;/code&gt;）&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;优点：解决了单点问题;&lt;/li&gt;
&lt;li&gt;缺点：一旦把步长定好后，就无法扩容；而且单个数据库的压力大，数据库自身性能无法满足高并发。&lt;/li&gt;
&lt;li&gt;应用场景：数据不需要扩容的场景。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;基于redis实现&quot;&gt;2.4 基于Redis实现&lt;/h4&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;单机：&lt;code&gt;Redis&lt;/code&gt;的&lt;code&gt;incr&lt;/code&gt;函数在单机上是原子操作，可以保证唯一且递增。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;集群：单机&lt;code&gt;Redis&lt;/code&gt;可能无法支撑高并发。集群情况下，可以使用步长的方式。比如有5个&lt;code&gt;Redis&lt;/code&gt;节点组成的集群，它们生成的&lt;code&gt;ID&lt;/code&gt;分别为：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;A: 1,6,11,16,21
B: 2,7,12,17,22
C: 3,8,13,18,23
D: 4,9,14,19,24
E: 5,10,15,20,25&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;优点：有序递增，可读性强。&lt;/li&gt;
&lt;li&gt;缺点：占用带宽，每次要向&lt;code&gt;Redis&lt;/code&gt;进行请求。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;三优化方案&quot;&gt;三、优化方案&lt;/h3&gt;
&lt;h4 id=&quot;改造数据库主键自增&quot;&gt;3.1、改造数据库主键自增&lt;/h4&gt;
&lt;p&gt;数据库的自增主键的特性，可以实现分布式ID，适合做userId，正好符合如何永不迁移数据和避免热点? 但这个方案有严重的问题：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;一旦步长定下来，不容易扩容;&lt;/li&gt;
&lt;li&gt;数据库压力山大。&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;为什么压力大？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因为我们每次获取ID的时候，都要去数据库请求一次。那我们可以不可以不要每次去取？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可以请求数据库得到ID的时候，可设计成获得的ID是一个ID区间段。&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1768363/201909/1768363-20190904234955374-1091832672.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;上图&lt;code&gt;ID&lt;/code&gt;规则表含义：&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;&lt;code&gt;id&lt;/code&gt;表示为主键，无业务含义;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;biz_tag&lt;/code&gt;为了表示业务，因为整体系统中会有很多业务需要生成&lt;code&gt;ID&lt;/code&gt;，这样可以共用一张表维护;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;max_id&lt;/code&gt;表示现在整体系统中已经分配的最大&lt;code&gt;ID&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;desc&lt;/code&gt;描述;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;update_time&lt;/code&gt;表示每次取的&lt;code&gt;ID&lt;/code&gt;时间;&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;整体流程：&lt;/li&gt;
&lt;/ul&gt;&lt;ol readability=&quot;0.5&quot;&gt;&lt;li&gt;【用户服务】在注册一个用户时，需要一个用户&lt;code&gt;ID&lt;/code&gt;；会请求【生成&lt;code&gt;ID&lt;/code&gt;服务(是独立的应用)】的接口;&lt;/li&gt;
&lt;li&gt;【生成&lt;code&gt;ID&lt;/code&gt;服务】会去查询数据库，找到&lt;code&gt;user_tag&lt;/code&gt;的&lt;code&gt;id&lt;/code&gt;，现在的&lt;code&gt;max_id&lt;/code&gt;为&lt;code&gt;0&lt;/code&gt;，&lt;code&gt;step=1000&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;【生成&lt;code&gt;ID&lt;/code&gt;服务】把&lt;code&gt;max_id&lt;/code&gt;和&lt;code&gt;step&lt;/code&gt;返回给【用户服务】；并且把&lt;code&gt;max_id&lt;/code&gt;更新为&lt;code&gt;max_id = max_id + step&lt;/code&gt;，即更新为&lt;code&gt;1000&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;【用户服务】获得&lt;code&gt;max_id=0&lt;/code&gt;，&lt;code&gt;step=1000&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;这个用户服务可以用&lt;code&gt;ID=【max_id + 1，max_id+step】&lt;/code&gt;区间的&lt;code&gt;ID&lt;/code&gt;，即为&lt;code&gt;【1，1000】&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;【用户服务】会把这个区间保存到&lt;code&gt;jvm&lt;/code&gt;中;&lt;/li&gt;
&lt;li&gt;【用户服务】需要用到&lt;code&gt;ID&lt;/code&gt;的时候，在区间&lt;code&gt;【1，1000】&lt;/code&gt;中依次获取&lt;code&gt;ID&lt;/code&gt;，可采用&lt;code&gt;AtomicLong&lt;/code&gt;中的&lt;code&gt;getAndIncrement&lt;/code&gt;方法;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果把区间的值用完了，再去请求【生产&lt;code&gt;ID&lt;/code&gt;服务】接口，获取到&lt;code&gt;max_id&lt;/code&gt;为&lt;code&gt;1000&lt;/code&gt;，即可以用&lt;code&gt;【max_id + 1，max_id+step】&lt;/code&gt;区间的&lt;code&gt;ID&lt;/code&gt;，即为&lt;code&gt;【1001，2000】&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;该方案就非常完美的解决了数据库自增的问题，而且可以自行定义&lt;code&gt;max_id&lt;/code&gt;的起点，和&lt;code&gt;step&lt;/code&gt;步长，非常方便扩容；&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;也解决了数据库压力的问题，因为在一段区间内，是在&lt;code&gt;jvm&lt;/code&gt;内存中获取的，而不需要每次请求数据库。即使数据库宕机了，系统也不受影响，&lt;code&gt;ID&lt;/code&gt;还能维持一段时间。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;竞争问题&quot;&gt;3.2 竞争问题&lt;/h4&gt;
&lt;p&gt;以上方案中，如果是多个用户服务，同时获取&lt;code&gt;ID&lt;/code&gt;，同时去请求【ID服务】，在获取&lt;code&gt;max_id&lt;/code&gt;的时候会存在并发问题。如:&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;用户服务&lt;code&gt;A&lt;/code&gt;，取到的&lt;code&gt;max_id=1000&lt;/code&gt; ;用户服务&lt;code&gt;B&lt;/code&gt;取到的也是&lt;code&gt;max_id=1000&lt;/code&gt;，那就出现了问题，&lt;code&gt;ID&lt;/code&gt;重复了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;解决方案是：加分布式锁，保证同一时刻只有一个用户服务获取&lt;code&gt;max_id&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&quot;突发阻塞问题&quot;&gt;3.3 突发阻塞问题&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1768363/201909/1768363-20190904235045382-1093103627.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为竞争问题，所有只有一个用户服务去操作数据库，其他二个会被阻塞。出现的现象就是一会儿突然系统耗时变长，怎么去解决？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;双&lt;code&gt;buffer&lt;/code&gt;方案&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1768363/201909/1768363-20190904235127380-1410451523.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;流程如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;当前获取&lt;code&gt;ID&lt;/code&gt;在&lt;code&gt;buffer1&lt;/code&gt;中，每次获取&lt;code&gt;ID&lt;/code&gt;在&lt;code&gt;buffer1&lt;/code&gt;中获取;&lt;/li&gt;
&lt;li&gt;当&lt;code&gt;buffer1&lt;/code&gt;中的&lt;code&gt;ID&lt;/code&gt;已经使用到了&lt;code&gt;100&lt;/code&gt;，也就是达到区间的&lt;code&gt;10%&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;达到了&lt;code&gt;10%&lt;/code&gt;，先判断&lt;code&gt;buffer2&lt;/code&gt;中有没有去获取过，如果没有就立即发起请求获取&lt;code&gt;ID&lt;/code&gt;线程，此线程把获取到的&lt;code&gt;ID&lt;/code&gt;，设置到&lt;code&gt;buffer2&lt;/code&gt;中;&lt;/li&gt;
&lt;li&gt;如果&lt;code&gt;buffer1&lt;/code&gt;用完了，会自动切换到&lt;code&gt;buffer2&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;buffer2&lt;/code&gt;用到&lt;code&gt;10%&lt;/code&gt;了，也会启动线程再次获取，设置到&lt;code&gt;buffer1&lt;/code&gt;中;&lt;/li&gt;
&lt;li&gt;依次往返。&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;总结&quot;&gt;3.4 总结&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;双&lt;code&gt;buffer&lt;/code&gt;的方案就达到了业务场景用的&lt;code&gt;ID&lt;/code&gt;，都是在&lt;code&gt;jvm&lt;/code&gt;内存中获得的，从此不需要到数据库中获取了,数据库宕机时长长点儿也没太大影响了。&lt;/li&gt;
&lt;li&gt;因为会有一个线程，会观察什么时候去自动获取。两个&lt;code&gt;buffer&lt;/code&gt;之间自行切换使用，就解决了突发阻塞的问题。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;四其他方式&quot;&gt;四、其他方式&lt;/h3&gt;
&lt;p&gt;还有一些其他的&lt;code&gt;ID&lt;/code&gt;生成方案，比如：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;滴滴：时间+起点编号+车牌号;&lt;/li&gt;
&lt;li&gt;淘宝订单：时间戳+用户&lt;code&gt;ID&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;其他电商：时间戳+下单渠道+用户&lt;code&gt;ID&lt;/code&gt;，有的会加上订单第一个商品的&lt;code&gt;ID&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MongoDB&lt;/code&gt; 的&lt;code&gt;ID&lt;/code&gt;：通过&lt;code&gt;时间+机器码+pid+inc&lt;/code&gt;共12个字节，&lt;code&gt;4+3+2+3&lt;/code&gt;的方式最终标识成一个24长度的十六进制字符。&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Wed, 04 Sep 2019 16:04:00 +0000</pubDate>
<dc:creator>风尘博客</dc:creator>
<og:description>在单机场景下，全局唯一的ID可以使用数据库的自增功能，分布式系统一般是高并发场景，那自然不适合。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/vandusty/p/11462585.html</dc:identifier>
</item>
<item>
<title>Angular Material 的设计之美 - 叙帝利</title>
<link>http://www.cnblogs.com/nzbin/p/11424801.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nzbin/p/11424801.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/999445/201909/999445-20190904145716535-1633080146.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;Angular Material 作为 Angular 的官方组件库，无论是设计交互还是易用性都有着极高的质量。正如官方所说其目的就是构建基于 Angular 和 TypeScript 的高质量组件库。&lt;/p&gt;
&lt;p&gt;官方列举了如下几点来解释“高质量”的含义。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;国际化和可访问性，以便所有用户都可以使用。&lt;/li&gt;
&lt;li&gt;不会让开发人员感到困惑的简单 API。&lt;/li&gt;
&lt;li&gt;在各种各样没有 bug 的用例中按预期行事。&lt;/li&gt;
&lt;li&gt;通过单元测试和集成测试更好地测试行为。&lt;/li&gt;
&lt;li&gt;可在 Material Design 规范的范围内进行定制。&lt;/li&gt;
&lt;li&gt;将性能开销降至最低。&lt;/li&gt;
&lt;li&gt;代码简洁，文档友好，可以作为 Angular 开发人员的一个例子。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;Material Design 作为一个非常流行的设计语言，它有多个版本的实现。React 版的 Material Design 有着很高的人气，大家可以自行对比，我就不赘述了，以免引起无谓的争吵，进而扯到框架层面。我可以说一下自己的感受，Angular Material 的交互更加流畅，细节做的更好。&lt;/p&gt;
&lt;p&gt;Angular Material 组件库虽然很优秀，但是却被带上了只适合做 C 端界面的帽子。这也是我刚开始不敢选择 Angular Material 的一个原因。但是编写 ng-matero 的过程中，随着对 Angular Material 的深入了解，我发现这种说法稍显狭隘甚至产生了一定的误导，所以我希望这篇文章可以让大家对 Angular Material 有一个更加正确的认识。接下来我会从相对宏观的角度介绍 Angular Material 设计的一些亮点，并且简单介绍 Angular Material 的一些使用技巧。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;题外话：为什么 ng-matero 会选择 Angular Material?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;抛开官方提到的几点不谈。首先我是那种比较激进的开发者，对于先进的设计理念，我都有跃跃欲试的执念。国内的 Element UI 以及 Ant Design 都是 Bootstrap 3 时代的风格。随着业务人员对界面细致紧凑的要求越来越高，我发现 Material 的设计风格更加符合需求，层次感更强。不过最主要的还是 Material Design 的交互更吸引我。另外，Angular Material 的样式是基于 Sass 编写，而我最喜欢的也是 Sass，所以基于 Angular Material 编写 ng-matero 就是命运的归宿。顺便插一句，如果大家纠结用 Sass 还是 Less，可以看一下这篇文章 &lt;a href=&quot;https://www.cnblogs.com/nzbin/p/6613674.html&quot;&gt;CSS 预处理器中的循环&lt;/a&gt;，个人不建议用 Less，请原谅我无意引战🤪。&lt;/p&gt;
&lt;blockquote readability=&quot;4.6551724137931&quot;&gt;
&lt;p&gt;ng-matero 0.3 已发布，新增 module schematic 以及 page schematic，详见 &lt;a href=&quot;https://github.com/ng-matero/ng-matero/tree/dev#schematics&quot;&gt;README&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;少即是多&quot;&gt;少即是多&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Less is more（少即是多）—— 密斯·凡德罗&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我想很多人对 Angular Material 望而却步的原因之一就是它的组件看上去有点少。然而在一般的业务中这些组件已经够用。除了常用组件之外，Angular Material 还有一个组件开发包 CDK。在设计界有一句名言“少即是多”，苹果的产品就是最好的证明。把这句名言用在 Angular material 上丝毫不为过，其实除了我们看到的组件之外，Material 还有一些隐藏组件，比如可以用 &lt;code&gt;menu&lt;/code&gt; 组件构造 &lt;code&gt;popover&lt;/code&gt;，我会在下文中介绍。&lt;/p&gt;
&lt;h2 id=&quot;丰富的颜色&quot;&gt;丰富的颜色&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/999445/201909/999445-20190904132552681-2098143922.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Material Design 的亮点之一就是拥有非常丰富的颜色值，其实 Angular Material 的颜色变量比官方定义的色值还要多一些。大家可以点击 ng-matero 的 &lt;a href=&quot;https://ng-matero.github.io/ng-matero/#/design/colors&quot;&gt;colors 页面&lt;/a&gt; 查看。ng-matero 也有所有颜色值对应的 &lt;a href=&quot;https://ng-matero.github.io/ng-matero/#/helpers&quot;&gt;colors helper&lt;/a&gt;，可以更加方便的创建丰富多彩的按钮或标签。Angular Material 的颜色定义严谨且优雅。以下是红色值的变量。&lt;/p&gt;
&lt;pre class=&quot;sass&quot;&gt;
&lt;code&gt;$mat-red: (
  50: #ffebee,
  100: #ffcdd2,
  200: #ef9a9a,
  300: #e57373,
  400: #ef5350,
  500: #f44336,
  600: #e53935,
  700: #d32f2f,
  800: #c62828,
  900: #b71c1c,
  A100: #ff8a80,
  A200: #ff5252,
  A400: #ff1744,
  A700: #d50000,
  contrast: (
    50: $dark-primary-text,
    100: $dark-primary-text,
    200: $dark-primary-text,
    300: $dark-primary-text,
    400: $dark-primary-text,
    500: $light-primary-text,
    600: $light-primary-text,
    700: $light-primary-text,
    800: $light-primary-text,
    900: $light-primary-text,
    A100: $dark-primary-text,
    A200: $light-primary-text,
    A400: $light-primary-text,
    A700: $light-primary-text,
  )
);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;除了定义基础色值之外，还有相对应的文本色定义，非常严谨。我在以前写 helper 库的时候，曾写过颜色集群，文本色处理都是一刀切，所以感触非常深。更惊喜的的是 Angular Material 甚至给出了灰色值的别名。&lt;/p&gt;
&lt;pre class=&quot;sass&quot;&gt;
&lt;code&gt;// Alias for alternate spelling.
$mat-gray: $mat-grey;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;灵活的主题定制&quot;&gt;灵活的主题定制&lt;/h2&gt;
&lt;p&gt;Angular Material 的样式几乎全部写在了 &lt;code&gt;mixin&lt;/code&gt; 中，定制起来非常容易。我最开始认为将所有样式全部写到 &lt;code&gt;mixin&lt;/code&gt; 中并不是很优雅的做法，但是在编写 ng-matero 暗黑主题的时候，我发现不这样做是不行的。以下是 Angular Material 主题定制的方法。&lt;/p&gt;
&lt;pre class=&quot;sass&quot;&gt;
&lt;code&gt;@import '~@angular/material/theming';

// Include non-theme styles for core.
@include mat-core();

// Define a theme.
$candy-app-primary: mat-palette($mat-indigo);
$candy-app-accent:  mat-palette($mat-pink, A200, A100, A400);

$candy-app-theme: mat-light-theme($candy-app-primary, $candy-app-accent, $candy-app-warn);

// Include all theme styles for the components.
@include angular-material-theme($candy-app-theme);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Angular Material 给出了多套主题的设置方法：&lt;/p&gt;
&lt;pre class=&quot;sass&quot;&gt;
&lt;code&gt;// Define an alternate dark theme.
$dark-primary: mat-palette($mat-blue-grey);
$dark-accent:  mat-palette($mat-amber, A200, A100, A400);
$dark-warn:    mat-palette($mat-deep-orange);
$dark-theme:   mat-dark-theme($dark-primary, $dark-accent, $dark-warn);

// `.unicorn-dark-theme` will be affected by this alternate dark theme instead of the default theme.
.unicorn-dark-theme {
  @include angular-material-theme($dark-theme);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;只需要增加样式控制类就可以了。&lt;/p&gt;
&lt;p&gt;在此我简单介绍一下 ng-matero 的主题切换。增加样式控制类可以说是最简单的主题切换方式，但是缺点就是同时拥有多套主题，代码量太大。如果只作为 DEMO 展示是没问题的，但是生产环境不推荐这样做。&lt;/p&gt;
&lt;p&gt;ng-matero 在使用 &lt;code&gt;ng add&lt;/code&gt; 初始化的时候增加了预构建主题选项，生成的主题只有一份，如果有特殊需求可以自行定制。实现方式就是不同主题传入不同变量，但是这种情况下多主题控制会有问题。所以必须使用 mixin 编写某些样式，这样的话就可以有局部变量环境。如下：&lt;/p&gt;
&lt;pre class=&quot;sass&quot;&gt;
&lt;code&gt;.theme-dark {
  $primary: mat-palette($mat-pink, 700, 500, 900);
  $accent: mat-palette($mat-blue-grey, A200, A100, A400);
  $warn: mat-palette($mat-red);
  $theme: mat-dark-theme($primary, $accent, $warn);

  @include angular-material-theme($theme);
  @include matero-admin-theme($theme);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;工具集&quot;&gt;工具集&lt;/h2&gt;
&lt;p&gt;Angular Material 提供了几乎所有和 Material Design 有关的样式工具，包括&lt;code&gt;变量&lt;/code&gt;、 &lt;code&gt;function&lt;/code&gt; 和 &lt;code&gt;mixin&lt;/code&gt;，都可以在 theming 文件中找到。&lt;/p&gt;
&lt;p&gt;除了上面提到的主题定制 &lt;code&gt;function&lt;/code&gt;、&lt;code&gt;mixin&lt;/code&gt; 之外，我们还可以使用 &lt;code&gt;mat-elevation()&lt;/code&gt; 轻松制作 MD 阴影。另外我们还可以使用 &lt;code&gt;$swift-ease-out-timing-function&lt;/code&gt;、&lt;code&gt;$mat-fast-out-slow-in-timing-function&lt;/code&gt; 这些动画变量实现和 MD 一样的动画效果。&lt;/p&gt;
&lt;p&gt;基于这套工具集，我们可以很容易的搭建和 MD 风格相统一的界面。&lt;/p&gt;
&lt;h2 id=&quot;极简的-api&quot;&gt;极简的 API&lt;/h2&gt;
&lt;p&gt;Angular Material 的官方文档可能稍微不太友好，总感觉内容很多，看不进去。但是耐心看一下，就会发现其简洁之道，Angular Material 的 API 也是“少即是多”的一种表现。以表单组件为例，以下是一个滑块组件。&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;mat-slide-toggle [(ngModel)]=&quot;options.model&quot;
                  (change)=&quot;changeOptions()&quot;
                  [disabled]=&quot;options.disabled&quot;&amp;gt;visible
&amp;lt;/mat-slide-toggle&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Angular Material 的表单组件更像是对原生 html 元素的复写。在熟悉了一种组件之后，几乎不需要额外的记忆成本，就可以很容易的猜到某些 API，简单易懂，使用很方便。不过时常翻文档还是很有必要的。&lt;/p&gt;
&lt;p&gt;再看一下菜单组件，使用方式同样非常简单。&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;button mat-button [matMenuTriggerFor]=&quot;menu&quot;&amp;gt;Menu&amp;lt;/button&amp;gt;
&amp;lt;mat-menu #menu=&quot;matMenu&quot;&amp;gt;
  &amp;lt;button mat-menu-item&amp;gt;Item 1&amp;lt;/button&amp;gt;
  &amp;lt;button mat-menu-item&amp;gt;Item 2&amp;lt;/button&amp;gt;
&amp;lt;/mat-menu&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在我更新 ng-zorro-antd 8.x 之后，我发现 zorro 的菜单组件的使用已经和 Angular Material 一样了。可见优秀的设计理念会被广泛借鉴。&lt;/p&gt;
&lt;h2 id=&quot;菜单&quot;&gt;菜单&lt;/h2&gt;
&lt;p&gt;Angular Material 的菜单组件可以说非常强大，除了官网提到的功能之外，我们还可以用以下方式实现动态数据加载的多级菜单，比如 &lt;a href=&quot;https://ng-matero.github.io/ng-matero/&quot;&gt;ng-matero 的 Top Menu 布局&lt;/a&gt;。&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;a mat-button [routerLink]=&quot;['/', menuItem.state]&quot; *ngIf=&quot;menuItem.type === 'link'&quot;&amp;gt;
  &amp;lt;span&amp;gt;{{menuItem.name}}&amp;lt;/span&amp;gt;
  ...
&amp;lt;/a&amp;gt;
...
&amp;lt;!-- level 1 --&amp;gt;
&amp;lt;button mat-button *ngIf=&quot;menuItem.type === 'sub'&quot; [matMenuTriggerFor]=&quot;menulevel1&quot;&amp;gt;
  &amp;lt;span&amp;gt;{{menuItem.name}}&amp;lt;/span&amp;gt;
  ...
&amp;lt;/button&amp;gt;
&amp;lt;mat-menu #menulevel1=&quot;matMenu&quot;&amp;gt;
  &amp;lt;ng-container *ngFor=&quot;let childLvl1 of menuItem.children&quot;&amp;gt;

    &amp;lt;a mat-menu-item [routerLink]=&quot;['/', menuItem.state, childLvl1.state]&quot;
       *ngIf=&quot;childLvl1.type === 'link'&quot;&amp;gt;{{childLvl1.name}}&amp;lt;/a&amp;gt;
    ...
    &amp;lt;!-- level 2 --&amp;gt;
    &amp;lt;button mat-menu-item *ngIf=&quot;childLvl1.type === 'sub'&quot;
            [matMenuTriggerFor]=&quot;menulevel2&quot;&amp;gt;{{ childLvl1.name }}&amp;lt;/button&amp;gt;
    &amp;lt;mat-menu #menulevel2=&quot;matMenu&quot;&amp;gt;
      &amp;lt;ng-container *ngFor=&quot;let childLvl2 of childLvl1.children&quot;&amp;gt;

        &amp;lt;a mat-menu-item
           [routerLink]=&quot;filterStates(['/', menuItem.state, childLvl1.state, childLvl2.state])&quot;
           *ngIf=&quot;childLvl2.type === 'link'&quot;&amp;gt;{{childLvl2.name}}&amp;lt;/a&amp;gt;
        ...

      &amp;lt;/ng-container&amp;gt;
    &amp;lt;/mat-menu&amp;gt;
  &amp;lt;/ng-container&amp;gt;
&amp;lt;/mat-menu&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另外，菜单组件还可以实现 &lt;code&gt;popover&lt;/code&gt; 的效果，不过需要做一些特殊处理，如下：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;mat-menu class=&quot;menu-form-wrapper&quot; [hasBackdrop]=&quot;false&quot;&amp;gt;
  &amp;lt;div (click)=&quot;$event.stopPropagation()&quot; (keydown)=&quot;$event.stopPropagation()&quot;&amp;gt;
    ...
  &amp;lt;/div&amp;gt;
&amp;lt;/mat-menu&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后可以根据自己的需求调整一下样式。&lt;/p&gt;
&lt;h2 id=&quot;表格&quot;&gt;表格&lt;/h2&gt;
&lt;p&gt;Angular Material 的表格是我见过最特殊的表格，结构简洁，通过定义动态列渲染数据，以下是一个官网例子：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;table mat-table [dataSource]=&quot;dataSource&quot; class=&quot;mat-elevation-z8&quot;&amp;gt;

  &amp;lt;!--- Note that these columns can be defined in any order.
        The actual rendered columns are set as a property on the row definition&quot; --&amp;gt;

  &amp;lt;!-- Position Column --&amp;gt;
  &amp;lt;ng-container matColumnDef=&quot;position&quot;&amp;gt;
    &amp;lt;th mat-header-cell *matHeaderCellDef&amp;gt; No. &amp;lt;/th&amp;gt;
    &amp;lt;td mat-cell *matCellDef=&quot;let element&quot;&amp;gt; {{element.position}} &amp;lt;/td&amp;gt;
  &amp;lt;/ng-container&amp;gt;

  &amp;lt;!-- Name Column --&amp;gt;
  &amp;lt;ng-container matColumnDef=&quot;name&quot;&amp;gt;
    &amp;lt;th mat-header-cell *matHeaderCellDef&amp;gt; Name &amp;lt;/th&amp;gt;
    &amp;lt;td mat-cell *matCellDef=&quot;let element&quot;&amp;gt; {{element.name}} &amp;lt;/td&amp;gt;
  &amp;lt;/ng-container&amp;gt;

  &amp;lt;!-- Weight Column --&amp;gt;
  &amp;lt;ng-container matColumnDef=&quot;weight&quot;&amp;gt;
    &amp;lt;th mat-header-cell *matHeaderCellDef&amp;gt; Weight &amp;lt;/th&amp;gt;
    &amp;lt;td mat-cell *matCellDef=&quot;let element&quot;&amp;gt; {{element.weight}} &amp;lt;/td&amp;gt;
  &amp;lt;/ng-container&amp;gt;

  &amp;lt;!-- Symbol Column --&amp;gt;
  &amp;lt;ng-container matColumnDef=&quot;symbol&quot;&amp;gt;
    &amp;lt;th mat-header-cell *matHeaderCellDef&amp;gt; Symbol &amp;lt;/th&amp;gt;
    &amp;lt;td mat-cell *matCellDef=&quot;let element&quot;&amp;gt; {{element.symbol}} &amp;lt;/td&amp;gt;
  &amp;lt;/ng-container&amp;gt;

  &amp;lt;tr mat-header-row *matHeaderRowDef=&quot;displayedColumns&quot;&amp;gt;&amp;lt;/tr&amp;gt;
  &amp;lt;tr mat-row *matRowDef=&quot;let row; columns: displayedColumns;&quot;&amp;gt;&amp;lt;/tr&amp;gt;
&amp;lt;/table&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;相比于 ng-zorro-antd 会暴露全部的 DOM 结构，这样简洁的结构（&lt;code&gt;CDKTable&lt;/code&gt; 的结构也是如此）确实让人不适应，甚至有一些担忧，遇到复杂的需求会不会吃瘪。在我写了大量表格需求之后，我可以很肯定说 Angular Material 的表格足以应对复杂需求（话也不敢说太满😅）。&lt;/p&gt;
&lt;p&gt;我很赞同 ng-alain 对 ng-zorro-antd 表格的进一步抽象，熟悉了 ng-alain 编写表格的方式之后，我一直以为 &lt;code&gt;mat-table&lt;/code&gt; 略显笨拙。然而仔细研究一下就会发现，&lt;code&gt;mat-table&lt;/code&gt; 是在 DOM 层面的抽象，本质是一样的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mat-table&lt;/code&gt; 对表格列宽的首选操控方式是 CSS，起初我对这种方式也存在疑虑，但是在我亲自封装了 ng-zorro-antd 的表格组件之后，我发现一切都很自然。这让我想起前端流行的一句话，“凡事能用 CSS 完成的就不要用 JS”，这也是我不建议大家用 Less 的原因之一。&lt;/p&gt;
&lt;h2 id=&quot;响应式布局&quot;&gt;响应式布局&lt;/h2&gt;
&lt;p&gt;Angular Material 并没有布局组件。但是不用担心，官方出品了一款基于指令布局的神器 &lt;a href=&quot;https://github.com/angular/flex-layout&quot;&gt;flex-layout&lt;/a&gt;，它是专门为 Angular 设计的。基于指令的布局方式和 Bootstrap 的栅格布局是两种不同的设计理念。flex-layout 的使用很简单，可以很快上手，熟悉之后你一定会喜欢这种布局方式。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;文章篇幅有限，以我浅薄的资历还无法将 Angular Material 的设计之美剖析的面面俱到，但是如果大家通过这篇文章能够更好的了解 Angular Material 或者对 Angular Material 产生了一点兴趣，我也算是做了一件好事。&lt;/p&gt;
&lt;p&gt;任何组件库都无法满足所有业务需求，如果你无法在 Angular Material 中找到可用的组件，你可以尝试第三方组件，或者可以将 ng-zorro-antd 按模块单独引入。在此推荐一些优秀的第三方组件。&lt;/p&gt;
&lt;p&gt;如果大家喜欢 Angular 或者对 Angular Material 感兴趣，欢迎进群讨论！&lt;/p&gt;

</description>
<pubDate>Wed, 04 Sep 2019 15:44:00 +0000</pubDate>
<dc:creator>叙帝利</dc:creator>
<og:description>前言 Angular Material 作为 Angular 的官方组件库，无论是设计交互还是易用性都有着极高的质量。正如官方所说其目的就是构建基于 Angular 和 TypeScript 的高质量</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/nzbin/p/11424801.html</dc:identifier>
</item>
<item>
<title>bdtrans 一个命令行下的机器翻译工具 - 梦醒时夜续</title>
<link>http://www.cnblogs.com/nkqlhqc/p/11462302.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nkqlhqc/p/11462302.html</guid>
<description>&lt;p&gt;　　现如今，机器翻译技术已经越来越成熟了，尽管从整体来看机器翻译的结果还不是特别如意，但是也足以应付一般的翻译需求了。近几年机器翻译平台层出不穷，国外比较出名的翻译平台有Google翻译、必应翻译等，国内比较出名的也有百度翻译、有道翻译等。&lt;/p&gt;&lt;div readability=&quot;100.22249342846&quot;&gt;
&lt;p&gt;　　中国的百度公司在人工智能层面做的还算是蛮不错的（虽然它的搜索一直以来为人所诟病），笔者经常在Linux下做一些工作，当有翻译需求时不得不打开浏览器，进入百度翻译官网去翻译一些句子，这样显然是有些麻烦，我想如果百度翻译肯提供一个API的话就好了，这样我就能做一个在终端下调用API的小工具。&lt;/p&gt;
&lt;p&gt;　　笔者尝试登录百度翻译的开发者平台，发现百度翻译果然提供了API，于是笔者便用Python脚本语言写了一个命令行下的调用百度翻译工具，将其命名为 bdtrans&lt;/p&gt;
&lt;p&gt;　　虽然笔者是在Linux下写的这个工具，但是其它平台也是支持的（前提是你的计算机上安装了一个python3的解释器），它所依赖的第三方包只有setuptools与prompt_toolkit.&lt;/p&gt;
&lt;p&gt;　　你可以将其当作一个pyhton包，在自己的脚本文件中导入并使用它，或者在python解释器中使用它，也可以将其完全当作一个命令行下的小工具，甚至启动交互式的翻译环境交互式翻译句子，它也支持从文件中读取翻译内容，并将翻译结果存储进文件中去，下面笔者简要介绍一下工具的使用。&lt;/p&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;安装&lt;/h3&gt;
&lt;p&gt;你可以使用Python包管理工具来安装它： &lt;code&gt;pip install bdtrans&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;你也可以下载源码包，解压后运行安装文件： &lt;code&gt;python setup.py insatll&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Github开源地址：&lt;a href=&quot;https://github.com/zsimline/bdtrans&quot;&gt;https://github.com/zsimline/bdtrans&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;使用方式&lt;/h3&gt;
&lt;blockquote readability=&quot;7.918505942275&quot;&gt;
&lt;p&gt;　　首先，你应该去百度翻译的&lt;a href=&quot;http://api.fanyi.baidu.com/&quot;&gt;官网&lt;/a&gt;上注册一个账户，并按照官网上的指导并申请一个百度翻译API的AppID与秘钥。&lt;br/&gt;　　当你首次尝试导入bdtrans包，或者在命令行工具下使用它时，它将会指引你输AppID、秘钥、默认的翻译规则等信息，并在输入完成后在你的用户目录下生成一个名为.bdtrans的配置文件，之后你就可以直接使用它而无需再次输入AppID等相关信息了。&lt;br/&gt;　　需要注意的是，百度翻译限制调用API的频率为1s/次，所以请不要在1s内调用多次API&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;模块函数 &lt;/h3&gt;
&lt;p&gt;trans(words, source_lang=None, target_lang=None, reverse=False)&lt;/p&gt;
&lt;p&gt;作用：翻译用户给定的句子，输出翻译结果&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th align=&quot;left&quot;&gt;参数&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;含义&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;words&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;你想要翻译的句子&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;source_lang&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;源语言代码（非必须）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;target_lang&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;目标语言代码（非必须）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;reverse&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;是否反转源语言与目标语言&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; bdtrans
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; bdtrans.trans(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Hello, boy!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;en&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;zh&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; 你好，男孩！
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;io_trans(input_file, output_file=None, quiet=False)&lt;/p&gt;
&lt;p&gt;作用：从文件中读取翻译内容，如果指定了输出文件，翻译结果将被存储到输出文件中&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th align=&quot;left&quot;&gt;参数&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;含义&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;input_file&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;输入的文件名&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;output_file&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;输出的文件名&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;quiet&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;是否关闭控制台输出&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;set_lang(source_lang, target_lang)&lt;/p&gt;
&lt;p&gt;作用：设置源语言代码与目标语言代码&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th align=&quot;left&quot;&gt;参数&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;含义&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;source_lang&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;源语言代码&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;target_lang&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;目标语言代码&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;save(file_name)&lt;/p&gt;
&lt;p&gt;作用：保存翻译结果到文件中&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th align=&quot;left&quot;&gt;参数&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;含义&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;file_name&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;保存的文件名&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;reverse_lang()&lt;/p&gt;
&lt;p&gt;作用：反转源语言与目标语言&lt;/p&gt;

&lt;p&gt;list_langs()&lt;/p&gt;
&lt;p&gt;作用：打印目前支持的语言列表&lt;/p&gt;

&lt;p&gt;display_rules&lt;/p&gt;
&lt;p&gt;作用：显示当前的语言翻译规则&lt;/p&gt;

&lt;p&gt;change_appid()&lt;/p&gt;
&lt;p&gt;作用：按照向导改变配置文件中的AppID&lt;/p&gt;

&lt;p&gt;change_lang()&lt;/p&gt;
&lt;p&gt;作用：按照向导改变配置文件中的默认翻译规则&lt;/p&gt;

&lt;p&gt;initialize_app()&lt;/p&gt;
&lt;p&gt;作用：按照向导初始化APP&lt;/p&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;命令行工具&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;可以直接在命令行下使用它，最重要的是你可以使用 “bdtrans -S” 进入交互式的翻译环境。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;bdtrans [选项] 待翻译文本&lt;/p&gt;
&lt;h4&gt;选项&lt;/h4&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th align=&quot;left&quot;&gt;选项&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;含义&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;-h, –help&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;显示帮助消息&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;-v, –version&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;显示程序版本&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;-l, –list&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;打印语言列表&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;-S, –shell&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;启动交互式翻译环境&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;-s code, –source code&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;指定源语言&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;-t code, –target code&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;指定目标语言&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td align=&quot;left&quot;&gt;-i filename, –input filename&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;指定输入文件&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td align=&quot;left&quot;&gt;-o filename, –output filename&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;指定输出文件&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;–init&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;按照向导初始化APP&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;–changeinfo&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;改变配置文件中的AppID&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;–changelang&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;改变配置文件中的翻译规则&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4&gt;交互环境下的选项&lt;/h4&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th align=&quot;left&quot;&gt;选项&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;含义&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;/reve&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;反转源语言与目标语言&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;/rule&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;显示当前的翻译规则&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;/list&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;打印支持的语言列表&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;/help&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;显示帮助信息&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;/quit&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;退出交互环境&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;/save filename&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;保存翻译结果&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;/setlang source_lang target_lang&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;设置源语言与目标语言&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
user@host:$ bdtrans 德玛西亚万岁
user@host:$ Long live Demasia
user@host:$ bdtrans -t ara 德玛西亚万岁
user@host:$ فيفا دي مارسيا
user@host:$ bdtrans -s zh 德玛西亚万岁
user@host:$ 不可以只指定源语言！
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;在交互环境下可以使用 =code 来临时的指定目标语言，此时源语言将自动的被指定为auto, 例如 ” =zh hello world ”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;gt;=th 你在地球嗑瓜子
คุณใช้เมล็ดแตงโมบนโลก
&amp;gt;=jp 我在月球吃西瓜
月でスイカを食べます
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;支持的语言列表&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th align=&quot;left&quot;&gt;语言代码&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;语言&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;zh&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;中文&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;en&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;英语&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;yue&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;粤语&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;wyw&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;文言文&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;jp&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;日语&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;kor&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;韩语&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;fra&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;法语&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;spa&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;西班牙语&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;th&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;泰语&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;ara&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;阿拉伯语&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;ru&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;俄语&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;pt&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;葡萄牙语&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;de&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;德语&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;it&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;意大利语&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;el&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;希腊语&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;nl&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;荷兰语&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;pl&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;波兰语&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;bul&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;保加利亚语&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;est&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;爱沙尼亚语&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;dan&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;丹麦语&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;fin&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;芬兰语&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;cs&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;捷克语&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;rom&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;罗马尼亚语&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;slo&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;斯洛文尼亚语&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;swe&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;瑞典语&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;hu&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;匈牙利语&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;cht&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;繁体中文&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;vie&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;越南语&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;auto&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;自动检测&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;</description>
<pubDate>Wed, 04 Sep 2019 15:18:00 +0000</pubDate>
<dc:creator>梦醒时夜续</dc:creator>
<og:description>现如今，机器翻译技术已经越来越成熟了，尽管从整体来看机器翻译的结果还不是特别如意，但是也足以应付一般的翻译需求了。近几年机器翻译平台层出不穷，国外比较出名的翻译平台有Google翻译、必应翻译等，国内</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/nkqlhqc/p/11462302.html</dc:identifier>
</item>
<item>
<title>【故障公告】阿里云 RDS 数据库服务器 CPU 100% 造成全站故障 - 博客园团队</title>
<link>http://www.cnblogs.com/cmt/p/11461524.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cmt/p/11461524.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/35695/201909/35695-20190904214647370-2084128374.png&quot; alt=&quot;&quot; width=&quot;800&quot; height=&quot;261&quot;/&gt;&lt;/p&gt;
&lt;p&gt;github 故障公告链接：&lt;a href=&quot;https://github.com/cnblogs/coder-service/issues/106&quot; target=&quot;_blank&quot;&gt;https://github.com/cnblogs/coder-service/issues/106&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;非常非常抱歉，今晚 19:34 ~ 21:16 园子所使用的阿里云 RDS 数据库服务器突然出现 CPU 100% 问题，造成全站无法正常访问，由此您带来了很大的麻烦，请您谅解。&lt;/p&gt;
&lt;p&gt;故障经过是这样的。19:34 这个时间点本来是一个访问低峰，数据库压力比访问高峰时低很多，但数据库服务器却异想天开、吃饱了撑着地让自己的 CPU 满负荷工作（到现在我们都没想通，难道是服务器晚饭吃多了想帮助消化？）。开始我们以为是某个应用引起的，一个一个应用排查与重启， 但 CPU 不为所动，依然百分百。接着，我们一边向阿里云提交工单求助，一边通过阿里云 RDS 控制台进行主备切换，虽然控制台显示切换成功后，但“实例可用性”中主备库信息无任何变化，实际主备库切换并没有成功，绝招也失灵。请阿里云帮忙手动进行主备切换，但阿里云操作后反馈由于数据库访问压力大，手动也切换不过去，建议我们重启实例。最终，我们决定重启实例，重启实例后一切恢复正常。是的，就是用最笨的方法——重启——解决了问题，在故障期间我们采取的所有措施都是徒劳，让人哭笑不得。&lt;/p&gt;
&lt;p&gt;望着今晚被狂风暴雨突袭后一片狼藉的园子，心中说不出的难受和愧疚。真的很抱歉，我们一直在努力建设园子，但今天的故障又告诉我们，没那么容易，我们的努力还不够，我们别无选择，唯有更加努力。&lt;/p&gt;
&lt;p&gt;【更新】&lt;/p&gt;
&lt;p&gt;00:22 开始将阿里云 RDS 实例从 SQL Server 2008 R2 升级至 2016&lt;/p&gt;
&lt;p&gt;6:20  数据库升级完成&lt;/p&gt;
&lt;p&gt;升级后大量数据库查询超时，正在紧急处理中。&lt;/p&gt;
</description>
<pubDate>Wed, 04 Sep 2019 15:15:00 +0000</pubDate>
<dc:creator>博客园团队</dc:creator>
<og:description>非常非常抱歉，今晚 19:34 ~ 21:16 园子所使用的阿里云 RDS 数据库服务器突然出现 CPU 100% 问题，造成全站无法正常访问，由此您带来了很大的麻烦，请您谅解。望着今晚被狂风暴雨突袭</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cmt/p/11461524.html</dc:identifier>
</item>
<item>
<title>并发环境下，先操作数据库还是先操作缓存？ - Jay_huaxiao</title>
<link>http://www.cnblogs.com/jay-huaxiao/p/11462232.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jay-huaxiao/p/11462232.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;在分布式系统中，缓存和数据库同时存在时，如果有写操作的时候，先操作数据库还是先操作缓存呢？先思考一下，可能会存在哪些问题，再往下看。下面我分几种方案阐述。&lt;/p&gt;
&lt;h2 id=&quot;缓存维护方案一&quot;&gt;缓存维护方案一&lt;/h2&gt;
&lt;p&gt;假设有一写（线程A）一读（线程B）操作，&lt;strong&gt;先操作缓存，在操作数据库&lt;/strong&gt;。，如下流程图所示：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/7/19/16c09e4c5c718c7a?w=849&amp;amp;h=513&amp;amp;f=png&amp;amp;s=52606&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1）线程A发起一个写操作，第一步del cache&lt;/p&gt;
&lt;p&gt;2）线程A第二步写入新数据到DB&lt;/p&gt;
&lt;p&gt;3）线程B发起一个读操作，cache miss，&lt;/p&gt;
&lt;p&gt;4）线程B从DB获取最新数据&lt;/p&gt;
&lt;p&gt;5）请求B同时set cache&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这样看，没啥问题&lt;/strong&gt;。我们再看第二个流程图，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/7/19/16c09e12153a79b8?w=803&amp;amp;h=517&amp;amp;f=png&amp;amp;s=52726&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1）线程A发起一个写操作，第一步del cache&lt;/p&gt;
&lt;p&gt;2）此时线程B发起一个读操作，cache miss&lt;/p&gt;
&lt;p&gt;3）线程B继续读DB，读出来一个老数据&lt;/p&gt;
&lt;p&gt;4）然后老数据入cache&lt;/p&gt;
&lt;p&gt;5）线程A写入了最新的数据&lt;/p&gt;
&lt;p&gt;OK，酱紫，就有问题了吧，老数据入到缓存了，&lt;strong&gt;每次读都是老数据啦，缓存与数据与数据库数据不一致&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;缓存维护方案二&quot;&gt;缓存维护方案二&lt;/h2&gt;
&lt;p&gt;双写操作，&lt;strong&gt;先操作缓存，在操作数据库&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/7/19/16c09f09e4c1c292?w=610&amp;amp;h=512&amp;amp;f=png&amp;amp;s=45931&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1）线程A发起一个写操作，第一步set cache&lt;/p&gt;
&lt;p&gt;2）线程A第二步写入新数据到DB&lt;/p&gt;
&lt;p&gt;3）线程B发起一个写操作，set cache，&lt;/p&gt;
&lt;p&gt;4）线程B第二步写入新数据到DB&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这样看，也没啥问题。&lt;/strong&gt;，但是有时候可能事与愿违，我们再看第二个流程图，如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/7/20/16c0eb335ee9b878?w=1001&amp;amp;h=676&amp;amp;f=png&amp;amp;s=71130&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1）线程A发起一个写操作，第一步set cache&lt;/p&gt;
&lt;p&gt;2）线程B发起一个写操作，第一步setcache&lt;/p&gt;
&lt;p&gt;3）线程B写入数据库到DB&lt;/p&gt;
&lt;p&gt;4）线程A写入数据库到DB&lt;/p&gt;
&lt;p&gt;执行完后，缓存保存的是B操作后的数据，数据库是A操作后的数据，&lt;strong&gt;缓存和数据库数据不一致&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;缓存维护方案三&quot;&gt;缓存维护方案三&lt;/h2&gt;
&lt;p&gt;一写（线程A）一读（线程B）操作，&lt;strong&gt;先操作数据库，再操作缓存&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/7/20/16c0ec1c874c19eb?w=1076&amp;amp;h=637&amp;amp;f=png&amp;amp;s=79727&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1）线程A发起一个写操作，第一步write DB&lt;/p&gt;
&lt;p&gt;2）线程A第二步del cache&lt;/p&gt;
&lt;p&gt;3）线程B发起一个读操作，cache miss&lt;/p&gt;
&lt;p&gt;4）线程B从DB获取最新数据&lt;/p&gt;
&lt;p&gt;5）线程B同时set cache&lt;/p&gt;
&lt;p&gt;这种方案&lt;strong&gt;没有明显的并发问题&lt;/strong&gt;，但是有可能&lt;strong&gt;步骤二删除缓存失败&lt;/strong&gt;，虽然概率比较小，&lt;strong&gt;优于方案一和方案二&lt;/strong&gt;，平时工作中也是使用方案三。&lt;/p&gt;
&lt;p&gt;综上对比，我们一般采用方案三，但是有没有完美全解决方案三的弊端的方法呢？&lt;/p&gt;
&lt;h2 id=&quot;缓存维护方案四&quot;&gt;缓存维护方案四&lt;/h2&gt;
&lt;p&gt;这个是方案三的改进方案，都是先操作数据库再操作缓存，我们来看一下流程图：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/7/20/16c0f4116f0a062f?w=995&amp;amp;h=778&amp;amp;f=png&amp;amp;s=88742&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过数据库的&lt;strong&gt;binlog&lt;/strong&gt;来&lt;strong&gt;异步淘汰key&lt;/strong&gt;，以mysql为例&lt;br/&gt;可以&lt;strong&gt;使用阿里的canal将binlog日志采集发送到MQ队列&lt;/strong&gt;里面，然后&lt;strong&gt;通过ACK机制&lt;br/&gt;确认处理&lt;/strong&gt; 这条更新消息，删除缓存，保证数据缓存一致性。&lt;/p&gt;
&lt;p&gt;但是呢还有个&lt;strong&gt;问题，如果是主从数据库呢&lt;/strong&gt;？&lt;/p&gt;
&lt;h2 id=&quot;缓存维护方案五&quot;&gt;缓存维护方案五&lt;/h2&gt;
&lt;p&gt;主从DB问题：因为主从DB同步存在同时延时时间如果删除缓存之后，数据同步到备库之前已经有请求过来时，&lt;strong&gt;会从备库中读到脏数据&lt;/strong&gt;，如何解决呢？解决方案如下流程图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/7/20/16c0f481dee559a5?w=1019&amp;amp;h=908&amp;amp;f=png&amp;amp;s=109517&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;缓存维护总结&quot;&gt;缓存维护总结&lt;/h2&gt;
&lt;p&gt;综上所述，在分布式系统中，缓存和数据库同时存在时，如果有写操作的时候，&lt;strong&gt;先操作数据库，再操作缓存&lt;/strong&gt;。如下：&lt;/p&gt;
&lt;p&gt;（1）读取缓存中是否有相关数据&lt;/p&gt;
&lt;p&gt;（2）如果缓存中有相关数据value，则返回&lt;/p&gt;
&lt;p&gt;（3）如果缓存中没有相关数据，则从数据库读取相关数据放入缓存中key-&amp;gt;value，再返回&lt;/p&gt;
&lt;p&gt;（4）如果有更新数据，则先更新数据，再删除缓存&lt;/p&gt;
&lt;p&gt;（5）为了保证第四步删除缓存成功，使用binlog异步删除&lt;/p&gt;
&lt;p&gt;（6）如果是主从数据库，binglog取自于从库&lt;/p&gt;
&lt;p&gt;（7）如果是一主多从，每个从库都要采集binlog，然后消费端收到最后一台binlog数据才删除缓存&lt;/p&gt;
&lt;h2 id=&quot;个人公众号&quot;&gt;个人公众号&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/7/28/16c381c89b127bbb?w=344&amp;amp;h=344&amp;amp;f=jpeg&amp;amp;s=8943&quot;/&gt;&lt;/p&gt;
&lt;p&gt;欢迎大家关注，大家一起学习，一起讨论哈。&lt;/p&gt;
</description>
<pubDate>Wed, 04 Sep 2019 15:10:00 +0000</pubDate>
<dc:creator>Jay_huaxiao</dc:creator>
<og:description>前言 在分布式系统中，缓存和数据库同时存在时，如果有写操作的时候，先操作数据库还是先操作缓存呢？先思考一下，可能会存在哪些问题，再往下看。下面我分几种方案阐述。 缓存维护方案一 假设有一写（线程A）一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jay-huaxiao/p/11462232.html</dc:identifier>
</item>
<item>
<title>基于ASP.Net Core开发的一套通用后台框架 - 果冻栋吖</title>
<link>http://www.cnblogs.com/jellydong/p/11462192.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jellydong/p/11462192.html</guid>
<description>&lt;h2 id=&quot;基于asp.net-core开发一套通用后台框架&quot;&gt;基于ASP.Net Core开发一套通用后台框架&lt;/h2&gt;
&lt;h3 id=&quot;写在前面&quot;&gt;写在前面&lt;/h3&gt;
&lt;p&gt;这是本人在学习的过程中搭建学习的框架，如果对你有所帮助那再好不过。如果您有发现错误，请告知我，我会第一时间修改。&lt;br/&gt;知其然，知其所以然，并非重复的造轮子。因为这段时间我发现，自己闷很久写出来的代码，再去看看别人的，会有种恍然大悟的感觉。不是只会用，而不知道为什么要这样用。&lt;br/&gt;真的，只看不敲，总是学不会。&lt;/p&gt;
&lt;blockquote readability=&quot;3.9512195121951&quot;&gt;
&lt;p&gt;Demo地址：&lt;a href=&quot;http://app.guoddy.com&quot; class=&quot;uri&quot;&gt;http://app.guoddy.com&lt;/a&gt;&lt;br/&gt;源代码地址：&lt;a href=&quot;https://github.com/jellydong/LJDAPP&quot; class=&quot;uri&quot;&gt;https://github.com/jellydong/LJDAPP&lt;/a&gt;&lt;br/&gt;数据并不会真实保存，设定的为测试模式，所以免登录。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;开发工具&quot;&gt;开发工具&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;1.Visual Studio 2019&lt;br/&gt;2.SQL Server 2017&lt;br/&gt;3.Power Design&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;总体效果&quot;&gt;总体效果&lt;/h3&gt;
&lt;p&gt;主页&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1006210/201909/1006210-20190904225749403-1123258770.png&quot; alt=&quot;主页&quot;/&gt;&lt;br/&gt;菜单管理&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1006210/201909/1006210-20190904225817394-1355983395.png&quot; alt=&quot;菜单管理&quot;/&gt;&lt;br/&gt;)&lt;br/&gt;角色管理及权限配置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1006210/201909/1006210-20190904225840427-1402017233.png&quot; alt=&quot;菜单管理&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;权限设计why&quot;&gt;权限设计&amp;amp;Why&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1006210/201909/1006210-20190904225928358-485618065.png&quot; alt=&quot;权限&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;我这里主要涉及七个表，四个数据表，三个关联表。&lt;br/&gt;为什么这样设计，我觉得可能这是大多数系统的需求。&lt;br/&gt;1.用户和角色多对多，一个用户可以拥有多个角色，不然设计角色就没有了意义，实际可能一个人身兼数职。&lt;br/&gt;2.可以直接给用户授予或取消授予某个权限。这个可能会有人觉得没必要，所以如果不涉及这个，那就是五个表。但是我这里保留，因为很多情况下，这是很正常的需求。&lt;br/&gt;3.菜单可以无限级别，根据实际需求，修改系统配置参数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;详细说明&quot;&gt;详细说明&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;ObjectID&lt;/code&gt;、&lt;code&gt;Remark&lt;/code&gt;、&lt;code&gt;Status&lt;/code&gt;、&lt;code&gt;CreatedBy&lt;/code&gt;、&lt;code&gt;CreatedTime&lt;/code&gt;、&lt;code&gt;ModifiedBy&lt;/code&gt;、&lt;code&gt;ModifiedTime&lt;/code&gt;、&lt;code&gt;Sort&lt;/code&gt;是默认字段。&lt;/p&gt;
&lt;h5 id=&quot;sysuserinfo用户表&quot;&gt;SysUserInfo用户表&lt;/h5&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;如果用户数据量大的话，实际这个表只需要保留&lt;code&gt;ObjectID&lt;/code&gt;、&lt;code&gt;ULoginName&lt;/code&gt;、&lt;code&gt;ULoginPWD&lt;/code&gt;就可以了，这样可以提高速度，没必要把所有信息都保存起来。&lt;/li&gt;
&lt;li&gt;用户和角色多对多 R_sysUserInfo_sysRole&lt;/li&gt;
&lt;li&gt;用户和权限项多对多(直接授权或禁止) R_UserPermissions&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;ObjectID&lt;/td&gt;
&lt;td&gt;主键&lt;/td&gt;
&lt;td&gt;nvarchar(50)&lt;/td&gt;
&lt;td&gt;TRUE&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;ULoginName&lt;/td&gt;
&lt;td&gt;用户名&lt;/td&gt;
&lt;td&gt;nvarchar(20)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;ULoginPWD&lt;/td&gt;
&lt;td&gt;密码&lt;/td&gt;
&lt;td&gt;nvarchar(50)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;URealName&lt;/td&gt;
&lt;td&gt;真实姓名&lt;/td&gt;
&lt;td&gt;nvarchar(10)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;UTelphone&lt;/td&gt;
&lt;td&gt;电话&lt;/td&gt;
&lt;td&gt;nvarchar(20)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;UMobile&lt;/td&gt;
&lt;td&gt;手机号&lt;/td&gt;
&lt;td&gt;nvarchar(11)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;UEmail&lt;/td&gt;
&lt;td&gt;Email&lt;/td&gt;
&lt;td&gt;nvarchar(50)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;UQQ&lt;/td&gt;
&lt;td&gt;QQ&lt;/td&gt;
&lt;td&gt;nvarchar(20)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;UGender&lt;/td&gt;
&lt;td&gt;性别:0-女;1-男;2-保密&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;UDepID&lt;/td&gt;
&lt;td&gt;所属部门&lt;/td&gt;
&lt;td&gt;nvarchar(50)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Remark&lt;/td&gt;
&lt;td&gt;备注&lt;/td&gt;
&lt;td&gt;nvarchar(500)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Status&lt;/td&gt;
&lt;td&gt;状态:0-启用;1-禁用&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;CreatedBy&lt;/td&gt;
&lt;td&gt;创建人&lt;/td&gt;
&lt;td&gt;nvarchar(50)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;CreatedTime&lt;/td&gt;
&lt;td&gt;创建时间&lt;/td&gt;
&lt;td&gt;datetime&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;ModifiedBy&lt;/td&gt;
&lt;td&gt;修改人&lt;/td&gt;
&lt;td&gt;nvarchar(50)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;ModifiedTime&lt;/td&gt;
&lt;td&gt;修改时间&lt;/td&gt;
&lt;td&gt;datetime&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Sort&lt;/td&gt;
&lt;td&gt;排序值&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h5 id=&quot;sysrole角色表&quot;&gt;SysRole角色表&lt;/h5&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;对角色的分类，比如管理员、普通用户等。&lt;/li&gt;
&lt;li&gt;角色用户多对多 R_sysUserInfo_sysRole&lt;/li&gt;
&lt;li&gt;角色权限多对多 R_RolePermission&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;ObjectID&lt;/td&gt;
&lt;td&gt;主键&lt;/td&gt;
&lt;td&gt;nvarchar(50)&lt;/td&gt;
&lt;td&gt;TRUE&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;RName&lt;/td&gt;
&lt;td&gt;角色名称&lt;/td&gt;
&lt;td&gt;varchar(50)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Remark&lt;/td&gt;
&lt;td&gt;备注&lt;/td&gt;
&lt;td&gt;nvarchar(500)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Status&lt;/td&gt;
&lt;td&gt;状态:0-启用;1-禁用&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;CreatedBy&lt;/td&gt;
&lt;td&gt;创建人&lt;/td&gt;
&lt;td&gt;nvarchar(50)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;CreatedTime&lt;/td&gt;
&lt;td&gt;创建时间&lt;/td&gt;
&lt;td&gt;datetime&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;ModifiedBy&lt;/td&gt;
&lt;td&gt;修改人&lt;/td&gt;
&lt;td&gt;nvarchar(50)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;ModifiedTime&lt;/td&gt;
&lt;td&gt;修改时间&lt;/td&gt;
&lt;td&gt;datetime&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Sort&lt;/td&gt;
&lt;td&gt;排序值&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;菜单表 是一开始设计好后，改动最多的一个表。后续在开发过程中增加了&lt;code&gt;IsLast&lt;/code&gt;、&lt;code&gt;Hierarchy&lt;/code&gt;;去除了&lt;code&gt;MAction&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;IsLast用来标记是不是最后一级，如果是最后一级我们给自动增加增删改等默认方法。&lt;/li&gt;
&lt;li&gt;Hierarchy用来标记层级，前面我们说可以做到无限极，但是通常情况下会是三级，所以这个需要根据实际设定系统参数，维护的时候检查限制即可。&lt;/li&gt;
&lt;li&gt;IsMenuShow是否作为菜单显示，也就是左侧菜单递归的，因为有部分API不需要作为菜单显示，并且授权的方式也会不一样。&lt;/li&gt;
&lt;li&gt;菜单角色多对多 R_RolePermission&lt;/li&gt;
&lt;li&gt;菜单权限项一对多&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;ObjectID&lt;/td&gt;
&lt;td&gt;主键&lt;/td&gt;
&lt;td&gt;nvarchar(50)&lt;/td&gt;
&lt;td&gt;TRUE&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;MName&lt;/td&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;nvarchar(100)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;MUrl&lt;/td&gt;
&lt;td&gt;URL&lt;/td&gt;
&lt;td&gt;nvarchar(100)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;MArea&lt;/td&gt;
&lt;td&gt;区域&lt;/td&gt;
&lt;td&gt;nvarchar(100)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;MController&lt;/td&gt;
&lt;td&gt;控制器&lt;/td&gt;
&lt;td&gt;nvarchar(100)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;MIcon&lt;/td&gt;
&lt;td&gt;图标&lt;/td&gt;
&lt;td&gt;nvarchar(100)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;IsLast&lt;/td&gt;
&lt;td&gt;是不是最后一级菜单:0-是;1-否&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;IsMenuShow&lt;/td&gt;
&lt;td&gt;是不是作为菜单显示:0-是;1-否&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Remark&lt;/td&gt;
&lt;td&gt;备注&lt;/td&gt;
&lt;td&gt;nvarchar(500)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;ParentID&lt;/td&gt;
&lt;td&gt;父ID&lt;/td&gt;
&lt;td&gt;nvarchar(50)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Status&lt;/td&gt;
&lt;td&gt;状态:0-启用;1-禁用&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Hierarchy&lt;/td&gt;
&lt;td&gt;层级&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;CreatedBy&lt;/td&gt;
&lt;td&gt;创建人&lt;/td&gt;
&lt;td&gt;nvarchar(50)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;CreatedTime&lt;/td&gt;
&lt;td&gt;创建时间&lt;/td&gt;
&lt;td&gt;datetime&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;ModifiedBy&lt;/td&gt;
&lt;td&gt;修改人&lt;/td&gt;
&lt;td&gt;nvarchar(50)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;ModifiedTime&lt;/td&gt;
&lt;td&gt;修改时间&lt;/td&gt;
&lt;td&gt;datetime&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Sort&lt;/td&gt;
&lt;td&gt;排序值&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h5 id=&quot;sysfunction-菜单按钮表-菜单权限项表&quot;&gt;SysFunction &lt;s&gt;&lt;em&gt;菜单按钮表&lt;/em&gt;&lt;/s&gt; (菜单权限项表)&lt;/h5&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;SysFunction一开始我是叫菜单按钮表的，我计划是查询、新增编辑删除、其他权限这样控制，但后来发现这样不好，所以全都分开，每个方法都要记录。当然为了方便，通用的方法，在增加菜单的时候会自动添加上。&lt;/li&gt;
&lt;li&gt;菜单权限项菜单是多对一关系&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;ObjectID&lt;/td&gt;
&lt;td&gt;主键&lt;/td&gt;
&lt;td&gt;nvarchar(50)&lt;/td&gt;
&lt;td&gt;TRUE&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;FName&lt;/td&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;nvarchar(50)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;FFunction&lt;/td&gt;
&lt;td&gt;方法&lt;/td&gt;
&lt;td&gt;nvarchar(50)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;FIcon&lt;/td&gt;
&lt;td&gt;图标&lt;/td&gt;
&lt;td&gt;nvarchar(50)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;ParentID&lt;/td&gt;
&lt;td&gt;所属菜单&lt;/td&gt;
&lt;td&gt;nvarchar(50)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Remark&lt;/td&gt;
&lt;td&gt;备注&lt;/td&gt;
&lt;td&gt;nvarchar(500)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Status&lt;/td&gt;
&lt;td&gt;状态:0-启用;1-禁用&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;CreatedBy&lt;/td&gt;
&lt;td&gt;创建人&lt;/td&gt;
&lt;td&gt;nvarchar(50)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;CreatedTime&lt;/td&gt;
&lt;td&gt;创建时间&lt;/td&gt;
&lt;td&gt;datetime&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;ModifiedBy&lt;/td&gt;
&lt;td&gt;修改人&lt;/td&gt;
&lt;td&gt;nvarchar(50)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;ModifiedTime&lt;/td&gt;
&lt;td&gt;修改时间&lt;/td&gt;
&lt;td&gt;datetime&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Sort&lt;/td&gt;
&lt;td&gt;排序值&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h5 id=&quot;r_sysuserinfo_sysrole用户和角色关联表记录用户和角色的对应关系&quot;&gt;R_sysUserInfo_sysRole用户和角色关联表，记录用户和角色的对应关系。&lt;/h5&gt;
&lt;h5 id=&quot;r_rolepermission-角色菜单权限项关联表&quot;&gt;R_RolePermission 角色菜单权限项关联表。&lt;/h5&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;比如一个角色有用某菜单下的查询和删除权限，那么这个表应该是具有两条记录的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;r_userpermissions-用户菜单权限项关联表&quot;&gt;R_UserPermissions 用户菜单权限项关联表。&lt;/h5&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;code&gt;HavePermission&lt;/code&gt;记录该用户是 是否有权限:0-无权限;1-有权限&lt;br/&gt;后续处理的时候，要从获取的权限记录中排除直接无权限的记录，增加有权限的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;其实网上很多关于权限的文章，之前自己再看的时候，总是觉得迷迷糊糊，所以最后打算自己动手做。到做完的时候，才有所理解。我也不知道我这里叙述的是不是不清楚或者设计的是否合理，如果您觉得有问题，请告知我，我会立即改正！&lt;br/&gt;切勿眼高手低，动手敲，像Power Design我也是第一次用，也是第一次用MarkDown写博客。&lt;br/&gt;此框架可以快速搭建应用，T4模板生成代码，适合学习使用。如有问题，请与我联系&lt;/p&gt;
&lt;blockquote readability=&quot;3.9512195121951&quot;&gt;
&lt;p&gt;Demo地址：&lt;a href=&quot;http://app.guoddy.com&quot; class=&quot;uri&quot;&gt;http://app.guoddy.com&lt;/a&gt;&lt;br/&gt;源代码地址：&lt;a href=&quot;https://github.com/jellydong/LJDAPP&quot; class=&quot;uri&quot;&gt;https://github.com/jellydong/LJDAPP&lt;/a&gt;&lt;br/&gt;数据并不会真实保存，设定的为测试模式，所以免登录。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 04 Sep 2019 15:10:00 +0000</pubDate>
<dc:creator>果冻栋吖</dc:creator>
<og:description>Demo地址：http://app.guoddy.com  源代码地址：https://github.com/jellydong/LJDAPP  数据并不会真实保存，设定的为测试模式，所以免登录。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jellydong/p/11462192.html</dc:identifier>
</item>
<item>
<title>Elasticsearch(5)--- 基本命令(集群相关命令、索引CRUD命令、文档CRUD命令) - 雨点的名字</title>
<link>http://www.cnblogs.com/qdhxhz/p/11461174.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qdhxhz/p/11461174.html</guid>
<description>&lt;center&gt;

&lt;/center&gt;
&lt;p&gt;这篇博客的命令分为&lt;code&gt;ES集群相关命令&lt;/code&gt;，&lt;code&gt;索引CRUD命令&lt;/code&gt;，&lt;code&gt;文档CRUD命令&lt;/code&gt;。这里不包括&lt;strong&gt;Query查询命令&lt;/strong&gt;,它单独写一篇博客。&lt;/p&gt;
&lt;h2 id=&quot;一es集群相关命令&quot;&gt;&lt;span&gt;一、ES集群相关命令&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;ES集群相关命令主要是&lt;code&gt;_cat&lt;/code&gt;命令，所以这里详细讲解下该命令。&lt;/p&gt;
&lt;h4 id=&quot;cat命令&quot;&gt;1、_cat命令&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;_cat&lt;/code&gt;系列提供了一系列查询Elasticsearch集群状态的接口。&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;/_cat/allocation      #查看单节点的shard分配整体情况
/_cat/shards          #查看各shard的详细情况
/_cat/shards/{index}  #查看指定分片的详细情况
/_cat/master          #查看master节点信息
/_cat/nodes           #查看所有节点信息
/_cat/indices         #查看集群中所有index的详细信息
/_cat/indices/{index} #查看集群中指定index的详细信息
/_cat/segments        #查看各index的segment详细信息,包括segment名, 所属shard, 内存(磁盘)占用大小, 是否刷盘
/_cat/segments/{index}#查看指定index的segment详细信息
/_cat/count           #查看当前集群的doc数量
/_cat/count/{index}   #查看指定索引的doc数量
/_cat/recovery        #查看集群内每个shard的recovery过程.调整replica。
/_cat/recovery/{index}#查看指定索引shard的recovery过程
/_cat/health          #查看集群当前状态：红、黄、绿
/_cat/pending_tasks   #查看当前集群的pending task
/_cat/aliases         #查看集群中所有alias信息,路由配置等
/_cat/aliases/{alias} #查看指定索引的alias信息
/_cat/thread_pool     #查看集群各节点内部不同类型的threadpool的统计信息,
/_cat/plugins         #查看集群各个节点上的plugin信息
/_cat/fielddata       #查看当前集群各个节点的fielddata内存使用情况
/_cat/fielddata/{fields}     #查看指定field的内存使用情况,里面传field属性对应的值
/_cat/nodeattrs              #查看单节点的自定义属性
/_cat/repositories           #输出集群中注册快照存储库
/_cat/templates              #输出当前正在存在的模板信息&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;每个命令都支持使用?v参数，让输出内容表格显示表头; pretty则让输出缩进更规范&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;示例&quot;&gt;2、示例&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;1) 节点信息&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;curl -X GET &quot;localhost:9200/_cat/nodes?v&amp;amp;pretty&quot;
ip         heap.percent ram.percent cpu load_1m load_5m load_15m node.role master name
172.18.0.4           52          97   6    0.02    0.11     0.28 mdi       -      es7_02
172.18.0.5           57          97   6    0.02    0.11     0.28 mdi       *      es7_01&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;heap.percent&lt;/code&gt; 堆内存占用百分比&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ram.percent&lt;/code&gt; 内存占用百分比&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cpu&lt;/code&gt; CPU占用百分比&lt;/li&gt;
&lt;li&gt;&lt;code&gt;master&lt;/code&gt; &lt;code&gt;*&lt;/code&gt;表示节点是集群中的&lt;code&gt;主节点&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;name&lt;/code&gt; 节点名&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;2) 分片信息&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;curl -X GET &quot;localhost:9200/_cat/shards?v&amp;amp;pretty&quot;
index                           shard prirep state    docs   store ip         node
.monitoring-es-7-2019.08.30     0     p      STARTED 21333  11.8mb 172.18.0.5 es7_01
.monitoring-es-7-2019.08.30     0     r      STARTED 21333  11.8mb 172.18.0.4 es7_02
goods-index                     0     p      STARTED     1   2.5mb 172.18.0.5 es7_01
goods-index                     0     r      STARTED     1   2.5mb 172.18.0.4 es7_02
.kibana_1                       0     p      STARTED     4  22.4kb 172.18.0.5 es7_01
.kibana_1                       0     r      STARTED     4  22.4kb 172.18.0.4 es7_02&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;index&lt;/code&gt; 索引名称&lt;/li&gt;
&lt;li&gt;&lt;code&gt;shard&lt;/code&gt; 分片序号&lt;/li&gt;
&lt;li&gt;&lt;code&gt;prirep&lt;/code&gt; &lt;code&gt;p&lt;/code&gt;表示该分片是&lt;code&gt;主分片&lt;/code&gt;, &lt;code&gt;r&lt;/code&gt; 表示该分片是&lt;code&gt;复制分片&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;store&lt;/code&gt; 该分片占用存储空间&lt;/li&gt;
&lt;li&gt;&lt;code&gt;node&lt;/code&gt; 所属节点&lt;code&gt;节点名&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docs&lt;/code&gt; 分片存放的&lt;code&gt;文档&lt;/code&gt;数&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;3) 索引信息&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;curl -X GET &quot;localhost:9200/_cat/indices?v&quot;
health status index                           uuid                   pri rep docs.count docs.deleted store.size pri.store.size
green  open   goods-index                     NhqSRJWUQiu46tdOKol4wA   1   1          1         7018        5mb          2.5mb
green  open   .monitoring-es-7-2019.08.30     lVDNFDVdSXqqrn8CdI_XGg   1   1      21333        18920     23.6mb         11.8mb
green  open   .kibana_1                       rvSlNVjJTsus80klzU19jQ   1   1          4            1     44.9kb         22.4kb&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;health&lt;/code&gt; 索引的健康状态&lt;/li&gt;
&lt;li&gt;&lt;code&gt;index&lt;/code&gt; 索引名&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pri&lt;/code&gt; 索引&lt;code&gt;主分片&lt;/code&gt;数量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rep&lt;/code&gt; 索引&lt;code&gt;复制分片&lt;/code&gt; 数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;store.size&lt;/code&gt; 索引&lt;code&gt;主分片&lt;/code&gt; &lt;code&gt;复制分片&lt;/code&gt; 总占用存储空间&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pri.store.size&lt;/code&gt; 索引总占用空间, 不计算&lt;code&gt;复制分片&lt;/code&gt; 占用空间&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;二索引crud命令&quot;&gt;&lt;span&gt;二、索引CRUD命令&lt;/span&gt;&lt;/h2&gt;
&lt;h4 id=&quot;查询索引&quot;&gt;1、查询索引&lt;/h4&gt;
&lt;p&gt;查询索引命令上面已经展示过了，这里再补充一些&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;条件过滤&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;_cat/indices?v&amp;amp;health=yellow   #查询健康状态为yellow的索引&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;排序&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;_cat/indices?v&amp;amp;health=yellow&amp;amp;s=docs.count:desc #根据文档数量进行索引排序&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;索引详细信息&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;curl -X GET &quot;localhost:9200/my_index/_stats?pretty&quot; #索引详细信息&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;创建索引&quot;&gt;2、创建索引&lt;/h4&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;PUT /student
{
    &quot;settings&quot;: {
        &quot;number_of_shards&quot;: 3,
        &quot;number_of_replicas&quot;: 1
    },
    &quot;mappings&quot;: {
            &quot;properties&quot;: {
                &quot;name&quot;: {
                    &quot;type&quot;:&quot;text&quot;
                },
                &quot;country&quot;: {
                    &quot;type&quot;:&quot;keyword&quot;
                },
                &quot;age&quot;: {
                    &quot;type&quot;:&quot;integer&quot;
                },
                &quot;date&quot;: {
                    &quot;type&quot;: &quot;date&quot;,
                    &quot;format&quot;: &quot;yyyy-MM-dd HH:mm:ss||yyyy-MM-dd||epoch_millis&quot;
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建成功&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201909/1090617-20190904193216967-2022307408.jpg&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;删除索引&quot;&gt;3、删除索引&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;curl -X DELETE &quot;localhost:9200/index-name&quot;&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;三文档crud命令&quot;&gt;&lt;span&gt;三、文档CRUD命令&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;在讲文档的CRUD之前我们要先理解 &lt;code&gt;GET/PUT/POST/DELETE&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;POST /uri        #创建
DELETE /uri/xxx  #删除
PUT /uri/xxx     #更新或创建
GET /uri/xxx     #查看&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;思考&lt;/code&gt;：&lt;strong&gt;POST和PUT的区别&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1）在ES中,如果不确定文档的ID，那么就需要用POST，它可以自己生成唯一的文档ID。如果确定文档的ID，那么就可以用PUT，当然也可以用POST，它们都可以创建或修改文档（如果是修改，那么_version版本号提高1）&lt;/p&gt;
&lt;p&gt;2）PUT、GET、DELETE是幂等的，而POST并不一定是幂等。如果你对POST也指定了文档ID,那它其实和PUT没啥区别，那它就是幂等。如果你没有指定文档ID那么就不是幂等操作了，因为同一数据，你执行多次POST，那么生成多个UUID的文档，&lt;/p&gt;
&lt;p&gt;也就是每POST一次都会新增一条数据。&lt;/p&gt;
&lt;h4 id=&quot;创建文档&quot;&gt;1、创建文档&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;1）PUT方式创建&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;PUT  /student/_doc/1 
{
    &quot;name&quot;: &quot;徐小小&quot;,
    &quot;country&quot;: &quot;杭州&quot;,
    &quot;age&quot;: &quot;3&quot;,
    &quot;date&quot;: &quot;2019-09-04&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201909/1090617-20190904193228591-122365236.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2）POST方式创建&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;POST不指定主键&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;POST  /student/_doc
{
    &quot;name&quot;: &quot;徐小小&quot;,
    &quot;country&quot;: &quot;杭州&quot;,
    &quot;age&quot;: &quot;3&quot;,
    &quot;date&quot;: &quot;2019-09-04&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201909/1090617-20190904193238837-1814442489.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;POST指定主键ID&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;POST  /student/_doc/88
{
    &quot;name&quot;: &quot;徐小小&quot;,
    &quot;country&quot;: &quot;杭州&quot;,
    &quot;age&quot;: &quot;3&quot;,
    &quot;date&quot;: &quot;2019-09-04&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201909/1090617-20190904193248162-869271490.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以明显看出，POST也可以指定文档ID,如果指定文档ID,那么就和PUT没有区别。ID不存在则创建，存在则更新并且&lt;code&gt;_version&lt;/code&gt;版本+1.&lt;/p&gt;
&lt;h4 id=&quot;文档查看&quot;&gt;2、文档查看&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;GET  /student/_doc/1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201909/1090617-20190904193307867-277286253.jpg&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;文档更新&quot;&gt;3、文档更新&lt;/h4&gt;
&lt;p&gt;商品PUT和POST执行的时候，如果指定的文档ID存在，那么就可以执行更新操作。不过它们执行的是全量更新，如果需要单独对某字段更新我们可以使用关键字&lt;code&gt;_update&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;例如&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;POST /student/_update/1
{
   &quot;doc&quot; : {
      &quot;age&quot;: 5
   }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如图,发现age已经更新成功&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201909/1090617-20190904193321674-918567170.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;文档删除&quot;&gt;4、文档删除&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;语法&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;DELETE /{index}/{type}/{id}&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;参考&quot;&gt;&lt;span&gt;参考&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;1、Elasticsearch核心技术与实战---阮一鸣(eBay Pronto平台技术负责人&lt;/p&gt;
&lt;p&gt;2、&lt;a href=&quot;https://www.jianshu.com/p/c6708ea88710&quot;&gt;ElasticSearch常用命令&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3、&lt;a href=&quot;https://www.jianshu.com/p/de311fd56420&quot;&gt;Elasticsearch 状态查询Cat接口&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4、&lt;a href=&quot;https://www.jianshu.com/p/a172c67bdd3e&quot;&gt;文档操作基本命令&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;5、&lt;a href=&quot;https://www.cnblogs.com/supersnowyao/p/11159197.html&quot;&gt;ElasticSearch批量操作相关命令&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt; 我相信，无论今后的道路多么坎坷，只要抓住今天，迟早会在奋斗中尝到人生的甘甜。抓住人生中的一分一秒，胜过虚度中的一月一年！(9）&lt;/code&gt;
&lt;/pre&gt;

</description>
<pubDate>Wed, 04 Sep 2019 14:54:00 +0000</pubDate>
<dc:creator>雨点的名字</dc:creator>
<og:description>Elasticsearch(5) 基本命令 这篇博客的命令分为 ，`索引CRUD命令 文档CRUD命令`。这里不包括 Query查询命令 ,它单独写一篇博客。 一、ES集群相关命令 ES集群相关命令主</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qdhxhz/p/11461174.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core 3.0中使用动态控制器路由 - LamondLu</title>
<link>http://www.cnblogs.com/lwqlun/p/11461657.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lwqlun/p/11461657.html</guid>
<description>&lt;blockquote readability=&quot;1.9591836734694&quot;&gt;
&lt;p&gt;原文：&lt;a href=&quot;https://www.strathweb.com/2019/08/dynamic-controller-routing-in-asp-net-core-3-0/&quot;&gt;Dynamic controller routing in ASP.NET Core 3.0&lt;/a&gt;&lt;br/&gt;作者：&lt;a href=&quot;http://twitter.com/filip_woj&quot;&gt;Filip W&lt;/a&gt;&lt;br/&gt;译文：&lt;a href=&quot;https://www.cnblogs.com/lwqlun/p/11461657.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/lwqlun/p/11461657.html&lt;/a&gt;&lt;br/&gt;译者：Lamond Lu&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201909/65831-20190904214946373-1517921684.jpg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;今天在网上看到了这篇关于ASP.NET Core动态路由的文章，感觉蛮有意思的，给大家翻译一下，虽然文中的例子不一定会在日常编码中出现，但是也给我们提供了一定的思路。&lt;/p&gt;

&lt;p&gt;相对于ASP.NET MVC以及ASP.NET Core MVC中的旧版本路由特性, 在ASP.NET Core 3.0中新增了一个不错的扩展点，即程序获取到路由后，可以将其动态指向一个给定的controller/action.&lt;/p&gt;
&lt;p&gt;这个功能有非常多的使用场景。如果你正在使用从ASP.NET Core 3.0 Preview 7及更高版本，你就可以在ASP.NET Core 3.0中使用它了。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;PS: 官方没有在Release Notes中提到这一点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面就让我们一起来看一看ASP.NET Core 3.0中的动态路由。&lt;/p&gt;

&lt;p&gt;当我们使用MVC路由的时候，最典型的用法是，我们使用路由特性(Route Attributes)来定义路由信息。使用这种方法，我们需要要为每个路由进行显式的声明。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class HomeController : Controller
{
   [Route(&quot;&quot;)]
   [Route(&quot;Home&quot;)]
   [Route(&quot;Home/Index&quot;)]
   public IActionResult Index()
   {
      return View();
   }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;相对的，你可以使用中心化的路由模型，使用这种方式，你就不需要显式的声明每一个路由 - 这些路由会自动被所有发现的控制器的自动识别。 然而，这样做的前提是，所有的控制器首先必须存在。&lt;/p&gt;
&lt;p&gt;以下是ASP.NET Core 3.0中使用新语法Endpoint Routing的实现方式。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;app.UseEndpoints(
    endpoints =&amp;gt;
    {
        endpoints.MapControllerRoute(&quot;default&quot;, 
                  &quot;{controller=Home}/{action=Index}/{id?}&quot;);
    }
);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上两种方式的共同点是，所有的路由信息都必须在应用程序启动时加载。&lt;/p&gt;
&lt;p&gt;但是，如果你希望能够动态定义路由, 并在应用程序运行时添加/删除它们，该怎么办？&lt;/p&gt;
&lt;p&gt;下面我给大家列举几个动态定义路由的使用场景。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;多语言路由，以及使用新语言时，针对那些新语言路由的修改。&lt;/li&gt;
&lt;li&gt;在CMS类型的系统中，我们可能会动态添加一些新页面，这些新页面不需要创建的控制器或者在源码中硬编码路由信息。&lt;/li&gt;
&lt;li&gt;多租户应用中，租户路由可以在运行时动态激活或者取消激活。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这个问题的处理过程应该相当的好理解。我们希望尽早的拦截路由处理，检查已为其解析的当前路由值，并使用例如数据库中的数据将它们“转换”为一组新的路由值，这些新的路由值指向了一个实际存在的控制器。&lt;/p&gt;

&lt;p&gt;在旧版本的ASP.NET Core MVC中, 我们通常通过自定义&lt;em&gt;&lt;code&gt;IRouter&lt;/code&gt;&lt;/em&gt;接口，来解决这个问题。然而在ASP.NET Core 3.0中这种方式已经行不通了，因为路由已经改由上面提到的Endpoint Routing来处理。值得庆幸的是，ASP.NET Core 3.0 Preview 7以及后续版本中，我们可以通过一个新特性&lt;em&gt;&lt;code&gt;MapDynamicControllRoute&lt;/code&gt;&lt;/em&gt;以及一个扩展点&lt;em&gt;&lt;code&gt;DynamicRouteValueTransformer&lt;/code&gt;&lt;/em&gt;, 来支持我们的需求。下面让我们看一个具体的例子。&lt;/p&gt;
&lt;p&gt;想象一下，在你的项目中，有一个&lt;em&gt;&lt;code&gt;OrderController&lt;/code&gt;&lt;/em&gt;控制器，然后你希望它支持多语言翻译路由。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class OrdersController : Controller
{
    public IActionResult List()
    {
        return View();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可能希望的请求的URL是这样的，例如&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;英语 - &lt;em&gt;/en/orders/list&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;德语 - &lt;em&gt;/de/bestellungen/liste&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;波兰语 - &lt;em&gt;/pl/zamowienia/lista&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那么我们现在该如何解决这个问题呢？我们可以使用新特性&lt;em&gt;&lt;code&gt;MapDynamicControllerRoute&lt;/code&gt;&lt;/em&gt;来替代默认的MVC路由， 并将其指向我们自定义的&lt;em&gt;&lt;code&gt;DynamicRouteValueTransformer&lt;/code&gt;&lt;/em&gt;类, 该类实现了我们之前提到的路由值转换 。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class Startup
{
    public void ConfigureServices(IServiceCollection services)
    {
        services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Latest);

        services.AddSingleton&amp;lt;TranslationTransformer&amp;gt;();
        services.AddSingleton&amp;lt;TranslationDatabase&amp;gt;();
    }

    public void Configure(IApplicationBuilder app)
    {
        app.UseRouting();
        app.UseEndpoints(endpoints =&amp;gt;
        {
            endpoints.MapDynamicControllerRoute&amp;lt;TranslationTransformer&amp;gt;(&quot;{language}/{controller}/{action}&quot;);
        });
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我们定义了一个&lt;em&gt;&lt;code&gt;TranslationTransformer&lt;/code&gt;&lt;/em&gt;类，它继承了&lt;em&gt;&lt;code&gt;DynamicRouteValueTransformer&lt;/code&gt;&lt;/em&gt;类。这个新类将负责将特定语言路由值，转换为可以在我们应用可以匹配到controller/action的路由值字典，而这些值通常不能直接和我们应用中的任何controller/action匹配。所以这里简单点说，就是在德语场景下，controller名会从“Bestellungen”转换成&quot;Orders&quot;, action名&quot;Liste&quot;转换成&quot;List&quot;。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;code&gt;TranslationTransformer&lt;/code&gt;&lt;/em&gt;类被作为泛型类型参数，传入&lt;em&gt;&lt;code&gt;MapDynamicControllerRoute&lt;/code&gt;&lt;/em&gt;方法中，它必须在依赖注入容器中注册。这里，我们还需要注册一个&lt;em&gt;&lt;code&gt;TranslationDatabase&lt;/code&gt;&lt;/em&gt;类，但是这个类仅仅为了帮助演示，后面我们会需要它。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class TranslationTransformer : DynamicRouteValueTransformer
{
    private readonly TranslationDatabase _translationDatabase;

    public TranslationTransformer(TranslationDatabase translationDatabase)
    {
        _translationDatabase = translationDatabase;
    }

    public override async ValueTask&amp;lt;RouteValueDictionary&amp;gt; TransformAsync(HttpContext httpContext
    , RouteValueDictionary values)
    {
        if (!values.ContainsKey(&quot;language&quot;) 
            || !values.ContainsKey(&quot;controller&quot;) 
            || !values.ContainsKey(&quot;action&quot;)) return values;

        var language = (string)values[&quot;language&quot;];
        var controller = await _translationDatabase.Resolve(language, 
            (string)values[&quot;controller&quot;]);
            
        if (controller == null) return values;
        values[&quot;controller&quot;] = controller;

        var action = await _translationDatabase.Resolve(language, 
            (string)values[&quot;action&quot;]);
            
        if (action == null) return values;
        values[&quot;action&quot;] = action;

        return values;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这个转换器中，我们需要尝试提取3个路由参数, &lt;em&gt;&lt;code&gt;language&lt;/code&gt;&lt;/em&gt;, &lt;em&gt;&lt;code&gt;controller&lt;/code&gt;&lt;/em&gt;,&lt;em&gt;&lt;code&gt;action&lt;/code&gt;&lt;/em&gt;，然后我们需要在模拟用的数据库类中，找到其对应的翻译。正如我们之前提到的，你通常会希望从数据库中查找对应的内容，因为使用这种方式，我们可以在应用程序生命周期的任何时刻，动态的影响路由。为了说明这一点，我们将使用&lt;em&gt;&lt;code&gt;TranslationDatabase&lt;/code&gt;&lt;/em&gt;类来模拟数据库操作，这里你可以把它想象成一个真正的数据库仓储服务。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class TranslationDatabase
{
    private static Dictionary&amp;lt;string, Dictionary&amp;lt;string, string&amp;gt;&amp;gt; Translations 
        = new Dictionary&amp;lt;string, Dictionary&amp;lt;string, string&amp;gt;&amp;gt;
    {
        {
            &quot;en&quot;, new Dictionary&amp;lt;string, string&amp;gt;
            {
                { &quot;orders&quot;, &quot;orders&quot; },
                { &quot;list&quot;, &quot;list&quot; }
            }
        },
        {
            &quot;de&quot;, new Dictionary&amp;lt;string, string&amp;gt;
            {
                { &quot;bestellungen&quot;, &quot;orders&quot; },
                { &quot;liste&quot;, &quot;list&quot; }
            }
        },
        {
            &quot;pl&quot;, new Dictionary&amp;lt;string, string&amp;gt;
            {
                { &quot;zamowienia&quot;, &quot;order&quot; },
                { &quot;lista&quot;, &quot;list&quot; }
            }
        },
    };

    public async Task&amp;lt;string&amp;gt; Resolve(string lang, string value)
    {
        var normalizedLang = lang.ToLowerInvariant();
        var normalizedValue = value.ToLowerInvariant();
        if (Translations.ContainsKey(normalizedLang) 
            &amp;amp;&amp;amp; Translations[normalizedLang]
                .ContainsKey(normalizedValue))
        {
            return Translations[normalizedLang][normalizedValue];
        }

        return null;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到目前为止，我们已经很好的解决了这个问题。这里通过在MVC应用中启用这个设置，我们就可以向我们之前定义的3个路由发送请求了。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;英语 - &lt;em&gt;/en/orders/list&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;德语 - &lt;em&gt;/de/bestellungen/liste&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;波兰语 - &lt;em&gt;/pl/zamowienia/lista&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;每个请求都会命中&lt;em&gt;&lt;code&gt;OrderController&lt;/code&gt;&lt;/em&gt;控制器和&lt;em&gt;&lt;code&gt;List&lt;/code&gt;&lt;/em&gt;方法。当前你可以将这个方法进一步扩展到其他的控制器。但最重要的是，如果新增一种新语言或者新的路由别名映射到现有语言中的controller/actions，你是不需要做任何代码更改，甚至重启项目的。&lt;/p&gt;
&lt;p&gt;请注意，在本文中，我们只关注路由转换，这里仅仅是为了演示ASP.NET Core 3.0中的动态路由特性。如果你希望在应用程序中实现本地化，你可能还需要阅读ASP.NET Core 3.0的&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/fundamentals/localization?view=aspnetcore-3.0&quot;&gt;本地化指南&lt;/a&gt;, 因为你可以需要根据语言的路由值设置正确的&lt;em&gt;&lt;code&gt;CurrentCulture&lt;/code&gt;&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;最后， 我还想再补充一点，在我们之前的例子中，我们在路由模板中显式的使用了&lt;em&gt;&lt;code&gt;{controller}&lt;/code&gt;&lt;/em&gt;和&lt;em&gt;&lt;code&gt;{action}&lt;/code&gt;&lt;/em&gt;占位符。这并不是必须的，在其他场景中，你还可以使用&lt;code&gt;&quot;catch-all&quot;&lt;/code&gt;路由通配符，并将其转换为controller/action路由值。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&quot;catch-all&quot;&lt;/code&gt;路由通配符是CMS系统中的典型解决方案，你可以使用它来处理不同的动态“页面”路由。&lt;/p&gt;
&lt;p&gt;它看起来可能类似：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;endpoints.MapDynamicControllerRoute&amp;lt;PageTransformer&amp;gt;(&quot;pages/{**slug}&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后，你需要将&lt;em&gt;&lt;code&gt;pages&lt;/code&gt;&lt;/em&gt;之后的整个URL参数转换为现有可执行控制器的内容 - 通常URL/路由的映射是保存在数据库中的。&lt;/p&gt;
&lt;p&gt;希望你会发现这篇文章很有用 - 所有的演示源代码都可以在&lt;a href=&quot;https://github.com/filipw/Strathweb.Samples.DynamicControllerRouting&quot;&gt;Github&lt;/a&gt;上找到。&lt;/p&gt;
</description>
<pubDate>Wed, 04 Sep 2019 13:51:00 +0000</pubDate>
<dc:creator>LamondLu</dc:creator>
<og:description>原文： 'Dynamic controller routing in ASP.NET Core 3.0' 作者： 'Filip W' 译文：https://www.cnblogs.com/lwqlun</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lwqlun/p/11461657.html</dc:identifier>
</item>
<item>
<title>新手学习 React 迷惑的点 - 李萧然</title>
<link>http://www.cnblogs.com/taoweng/p/11461253.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/taoweng/p/11461253.html</guid>
<description>&lt;p&gt;网上各种言论说 React 上手比 Vue 难，可能难就难不能深刻理解 JSX，或者对 ES6 的一些特性理解得不够深刻，导致觉得有些点难以理解，然后说 React 比较难上手，还反人类啥的，所以我打算写两篇文章来讲新手学习 React 的时候容易迷惑的点写出来，如果你还以其他的对于学习 React 很迷惑的点，可以在留言区里给我留言。&lt;/p&gt;
&lt;h2 id=&quot;为什么要引入-react&quot;&gt;为什么要引入 React&lt;/h2&gt;
&lt;p&gt;在写 React 的时候，你可能会写类似这样的代码：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;import React from 'react'

function A() {
  // ...other code
  return &amp;lt;h1&amp;gt;前端桃园&amp;lt;/h1&amp;gt;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你肯定疑惑过，下面的代码都没有用到 React，为什么要引入 React 呢？&lt;/p&gt;
&lt;p&gt;如果你把 &lt;code&gt;import React from ‘react’&lt;/code&gt; 删掉，还会报下面这样的错误：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1147374/201909/1147374-20190904195407535-258884279.jpg&quot; alt=&quot;7F6E506E-3025-401D-A492-3B501F8081C6&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么究竟是哪里用到了这个 React，导致我们引入 React 会报错呢，不懂这个原因，那么就是 JSX 没有搞得太明白。&lt;/p&gt;
&lt;p&gt;你可以讲上面的代码(忽略导入语句)放到&lt;a href=&quot;https://www.babeljs.cn/repl&quot;&gt;在线 babel&lt;/a&gt; 里进行转化一下，发现 babel 会把上面的代码转化成:&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;function A() {
  // ...other code
  return React.createElement(&quot;h1&quot;, null, &quot;前端桃园&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为从本质上讲，JSX 只是为 &lt;code&gt;React.createElement(component, props, ...children)&lt;/code&gt; 函数提供的语法糖。&lt;/p&gt;
&lt;h2 id=&quot;为什么要用-classname-而不用-class&quot;&gt;为什么要用 className 而不用 class&lt;/h2&gt;
&lt;ol readability=&quot;5&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;React 一开始的理念是想与浏览器的 DOM API 保持一直而不是 HTML，因为 JSX 是 JS 的扩展，而不是用来代替 HTML 的，这样会和元素的创建更为接近。在元素上设置 &lt;code&gt;class&lt;/code&gt; 需要使用 &lt;code&gt;className&lt;/code&gt; 这个 API：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const element = document.createElement(&quot;div&quot;)
element.className = &quot;hello&quot; &lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;浏览器问题，ES5 之前，在对象中不能使用保留字。以下代码在 IE8 中将会抛出错误：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const element = {
  attributes: {
    class: &quot;hello&quot;
  }
} &lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;解构问题，当你在解构属性的时候，如果分配一个 &lt;code&gt;class&lt;/code&gt; 变量会出问题：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;const { class } = { class: 'foo' } // Uncaught SyntaxError: Unexpected token }
const { className } = { className: 'foo' } 
const { class: className } = { class: 'foo' } &lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;其他讨论可见：&lt;a href=&quot;https://www.jackpu.com/you-qu-de-hua-ti-wei-shi-yao-jsxyong-classnameer-bu-shi-class/&quot;&gt;有趣的话题，为什么jsx用className而不是class&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;为什么属性要用小驼峰&quot;&gt;为什么属性要用小驼峰&lt;/h2&gt;
&lt;p&gt;因为 JSX 语法上更接近 JavaScript 而不是 HTML，所以 React DOM 使用 &lt;code&gt;camelCase&lt;/code&gt;（小驼峰命名）来定义属性的名称，而不使用 HTML 属性名称的命名约定。&lt;/p&gt;
&lt;p&gt;来自 &lt;a href=&quot;https://zh-hans.reactjs.org/docs/introducing-jsx.html&quot;&gt;JSX 简介&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;为什么-constructor-里要调用-super-和传递-props&quot;&gt;为什么 constructor 里要调用 super 和传递 props&lt;/h2&gt;
&lt;p&gt;这是官网的一段代码，具体见：&lt;a href=&quot;http://react.html.cn/docs/state-and-lifecycle.html&quot;&gt;状态(State) 和 生命周期&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;class Clock extends React.Component {
  constructor(props) {
    super(props);
    this.state = {date: new Date()};
  }

  render() {
    return (
      &amp;lt;div&amp;gt;
        &amp;lt;h1&amp;gt;Hello, world!&amp;lt;/h1&amp;gt;
        &amp;lt;h2&amp;gt;It is {this.state.date.toLocaleTimeString()}.&amp;lt;/h2&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而且有这么一段话，不仅让我们调用 &lt;code&gt;super&lt;/code&gt; 还要把 &lt;code&gt;props&lt;/code&gt; 传递进去，但是没有告诉我们为什么要这么做。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1147374/201909/1147374-20190904195407863-1867563219.png&quot; alt=&quot;image-20190901222456704&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不知道你有没有疑惑过为什么要调用 &lt;code&gt;super&lt;/code&gt; 和传递 &lt;code&gt;props&lt;/code&gt;，接下来我们来解开谜题吧。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么要调用 super&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其实这不是 React 的限制，这是 JavaScript 的限制，在构造函数里如果要调用 this，那么提前就要调用 super，在 React 里，我们常常会在构造函数里初始化 state，&lt;code&gt;this.state = xxx&lt;/code&gt; ，所以需要调用 super。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么要传递 props&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你可能以为必须给 &lt;code&gt;super&lt;/code&gt; 传入 &lt;code&gt;props&lt;/code&gt;，否则 &lt;code&gt;React.Component&lt;/code&gt; 就没法初始化 &lt;code&gt;this.props&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;class Component {
  constructor(props) {
    this.props = props;
    // ...
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不过，如果你不小心漏传了 &lt;code&gt;props&lt;/code&gt;，直接调用了 &lt;code&gt;super()&lt;/code&gt;，你仍然可以在 &lt;code&gt;render&lt;/code&gt; 和其他方法中访问 &lt;code&gt;this.props&lt;/code&gt;（不信的话可以试试嘛）。&lt;/p&gt;
&lt;p&gt;为啥这样也行？因为&lt;strong&gt;React 会在构造函数被调用之后，会把 props 赋值给刚刚创建的实例对象：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;const instance = new YourComponent(props);
instance.props = props;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;props&lt;/code&gt; 不传也能用，是有原因的。&lt;/p&gt;
&lt;p&gt;但这意味着你在使用 React 时，可以用 &lt;code&gt;super()&lt;/code&gt; 代替 &lt;code&gt;super(props)&lt;/code&gt; 了么？&lt;/p&gt;
&lt;p&gt;那还是不行的，不然官网也不会建议你调用 props 了，虽然 React 会在构造函数运行之后，为 &lt;code&gt;this.props&lt;/code&gt; 赋值，但在 &lt;code&gt;super()&lt;/code&gt; 调用之后与构造函数结束之前， &lt;code&gt;this.props&lt;/code&gt; 仍然是没法用的。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// Inside React
class Component {
  constructor(props) {
    this.props = props;
    // ...
  }
}

// Inside your code
class Button extends React.Component {
  constructor(props) {
    super(); // 😬 忘了传入 props
    console.log(props); // ✅ {}
    console.log(this.props); // 😬 undefined
  }
  // ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;要是构造函数中调用了某个访问 &lt;code&gt;props&lt;/code&gt; 的方法，那这个 bug 就更难定位了。&lt;strong&gt;因此我强烈建议始终使用super(props)，即使这不是必须的：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;class Button extends React.Component {
  constructor(props) {
    super(props); // ✅ We passed props
    console.log(props); // ✅ {}
    console.log(this.props); // ✅ {}
  }
  // ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码确保 &lt;code&gt;this.props&lt;/code&gt; 始终是有值的。&lt;/p&gt;
&lt;p&gt;如果你想避免以上的问题，你可以通过&lt;a href=&quot;https://github.com/tc39/proposal-class-fields&quot;&gt;class 属性提案&lt;/a&gt; 来简化代码：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;class Clock extends React.Component {
  state = {date: new Date()};

  render() {
    return (
      &amp;lt;div&amp;gt;
        &amp;lt;h1&amp;gt;Hello, world!&amp;lt;/h1&amp;gt;
        &amp;lt;h2&amp;gt;It is {this.state.date.toLocaleTimeString()}.&amp;lt;/h2&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更详细的内容可见&lt;a href=&quot;https://overreacted.io/why-do-we-write-super-props/&quot;&gt;Dan 的博客&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;为什么组件用大写开头&quot;&gt;为什么组件用大写开头&lt;/h2&gt;
&lt;p&gt;前面以及说过了，JSX 是 &lt;code&gt;React.createElement(component, props, …children)&lt;/code&gt; 提供的语法糖，component 的类型是：&lt;code&gt;string/ReactClass type&lt;/code&gt;，我们具体看一下在什么情况下会用到 string 类型，什么情况下用到 ReactClass type 类型&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;string 类型react会觉得他是一个原生dom节点&lt;/li&gt;
&lt;li&gt;ReactClass type 类型 自定义组件&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;例如（string）：在 jsx 中我们写一个&lt;/p&gt;
&lt;pre class=&quot;react&quot;&gt;
&lt;code&gt;&amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;转换为js的时候就变成了&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;React.createElement(&quot;div&quot;, null)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例如（ReactClass type）：在jsx中我们写一个&lt;/p&gt;
&lt;pre class=&quot;react&quot;&gt;
&lt;code&gt;function MyDiv() {
    return (&amp;lt;div&amp;gt;&amp;lt;div&amp;gt;)
}
&amp;lt;MyDiv&amp;gt;&amp;lt;/MyDiv&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;转换为js的时候就变成了&lt;/p&gt;
&lt;pre class=&quot;react&quot;&gt;
&lt;code&gt;function MyDiv() {
  return React.createElement(&quot;div&quot;, null);
}

React.createElement(MyDiv, null);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上边的例子中如果将MyDiv中的首字母小写，如下&lt;/p&gt;
&lt;pre class=&quot;react&quot;&gt;
&lt;code&gt;function myDiv() {
    return (&amp;lt;div&amp;gt;&amp;lt;div&amp;gt;)
}
&amp;lt;myDiv&amp;gt;&amp;lt;/myDiv&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;转换为 js 的时候就变成了&lt;/p&gt;
&lt;pre class=&quot;react&quot;&gt;
&lt;code&gt;function MyDiv() {
  return React.createElement(&quot;div&quot;, null);
}

React.createElement(&quot;myDiv&quot;, null);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于找不到 myDiv 这个 dom，所以就会报错。&lt;/p&gt;
&lt;h2 id=&quot;为什么调用方法要-bind-this&quot;&gt;为什么调用方法要 bind this&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;前提知识：&lt;/strong&gt;深刻的理解 JavaScript 中的 this&lt;/p&gt;
&lt;p&gt;相信刚写 React 的时候，很多朋友可能会写类似这样的代码：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;class Foo extends React.Component {
  handleClick () {
    this.setState({ xxx: aaa })
  }

  render() {
    return (
      &amp;lt;button onClick={this.handleClick}&amp;gt;
        Click me
      &amp;lt;/button&amp;gt;
    )
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;发现会报 &lt;code&gt;this&lt;/code&gt; 是 &lt;code&gt;undefined&lt;/code&gt; 的错，然后可能对事件处理比较疑惑，然后去看官网的&lt;a href=&quot;https://zh-hans.reactjs.org/docs/handling-events.html&quot;&gt;事件处理&lt;/a&gt;有下面一段话：&lt;/p&gt;
&lt;blockquote readability=&quot;10.172043010753&quot;&gt;
&lt;p&gt;你必须谨慎对待 JSX 回调函数中的 &lt;code&gt;this&lt;/code&gt;，在 JavaScript 中，class 的方法默认不会&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind&quot;&gt;绑定&lt;/a&gt;&lt;code&gt;this&lt;/code&gt;。如果你忘记绑定 &lt;code&gt;this.handleClick&lt;/code&gt; 并把它传入了 &lt;code&gt;onClick&lt;/code&gt;，当你调用这个函数的时候 &lt;code&gt;this&lt;/code&gt; 的值为 &lt;code&gt;undefined&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这并不是 React 特有的行为；这其实与 &lt;a href=&quot;https://www.smashingmagazine.com/2014/01/understanding-javascript-function-prototype-bind/&quot;&gt;JavaScript 函数工作原理&lt;/a&gt;有关。通常情况下，如果你没有在方法后面添加 &lt;code&gt;()&lt;/code&gt;，例如 &lt;code&gt;onClick={this.handleClick}&lt;/code&gt;，你应该为这个方法绑定 &lt;code&gt;this&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然后你看了官网的例子和建议之后，知道需要为事件处理函数绑定 &lt;code&gt;this&lt;/code&gt;就能解决，想下面这样：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;class Foo extends React.Component {
  handleClick () {
    this.setState({ xxx: aaa })
  }

  render() {
    return (
      &amp;lt;button onClick={this.handleClick.bind(this)}&amp;gt;
        Click me
      &amp;lt;/button&amp;gt;
    )
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是可能你没有去思考过为什么需要 bind this？如果你不能理解的话，还是 js 的基础没有打好。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;React 是如何处理事件的？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;咱们先来了解一下 React 是如何处理事件的。&lt;/p&gt;
&lt;p&gt;React 的事件是合成事件， 内部原理非常复杂，我这里只把关键性，可以用来解答这个问题的原理部分进行介绍即可(后面应该会写一篇 react 的事件原理，敬请期待)。&lt;/p&gt;
&lt;p&gt;上篇文章已经说过，jsx 实际上是 &lt;code&gt;React.createElement(component, props, …children)&lt;/code&gt; 函数提供的语法糖，那么这段 jsx 代码：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt; &amp;lt;button onClick={this.handleClick}&amp;gt;
     Click me
 &amp;lt;/button&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;会被转化为：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;React.createElement(&quot;button&quot;, {
     onClick: this.handleClick
}, &quot;Click me&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;了解了上面的，然后简单的理解 react 如何处理事件的，React 在组件加载(&lt;code&gt;mount&lt;/code&gt;)和更新(&lt;code&gt;update&lt;/code&gt;)时，将事件通过 &lt;code&gt;addEventListener&lt;/code&gt; 统一注册到 &lt;code&gt;document&lt;/code&gt; 上，然后会有一个事件池存储了所有的事件，当事件触发的时候，通过 &lt;code&gt;dispatchEvent&lt;/code&gt; 进行事件分发。&lt;/p&gt;
&lt;p&gt;所以你可以简单的理解为，最终 &lt;code&gt;this.handleClick&lt;/code&gt; 会作为一个回调函数调用。&lt;/p&gt;
&lt;p&gt;理解了这个，然后再来看看回调函数为什么就会丢失 &lt;code&gt;this&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;this 简单回顾&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;在函数内部，&lt;code&gt;this&lt;/code&gt;的值取决于函数被调用的方式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果你不能理解上面那句话，那么你可能需要停下来阅读文章，去查一下相关资料，否则你可能看不懂下面的，如果你懒的话，就看为你准备好的 &lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this&quot;&gt;MDN&lt;/a&gt; 吧。&lt;/p&gt;
&lt;p&gt;通过上面对事件处理的介绍，来模拟一下在类组件的 render 函数中， 有点类似于做了这样的操作:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;class Foo {
    sayThis () {
        console.log(this); // 这里的 `this` 指向谁？
    }

    exec (cb) {
        cb();
    }

    render () {
        this.exec(this.sayThis);
  }
}

var foo = new Foo();
foo.render(); // 输出结果是什么？&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你会发现最终结果输出的是 &lt;code&gt;undefined&lt;/code&gt;，如果你不理解为什么输出的是 &lt;code&gt;undefined&lt;/code&gt;，那么还是上面说的，需要去深刻的理解 this 的原理。如果你能理解输出的是 &lt;code&gt;undefined&lt;/code&gt;，那么我觉得你就可以理解为什么需要 bind this 了。&lt;/p&gt;
&lt;p&gt;那么你可能会问：&lt;strong&gt;为什么React没有自动的把 bind 集成到 render 方法中呢?&lt;/strong&gt;在 exec 调用回调的时候绑定进去，像这样：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;class Foo {
    sayThis () {
        console.log(this); // 这里的 `this` 指向谁？
    }

    exec (cb) {
        cb().bind(this);
    }

    render () {
        this.exec(this.sayThis);
  }
}

var foo = new Foo();
foo.render(); // 输出结果是什么？&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;因为 render 多次调用每次都要 bind 会影响性能，所以官方建议你自己在 constructor 中手动 bind 达到性能优化。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;四种事件处理对比&quot;&gt;四种事件处理对比&lt;/h3&gt;
&lt;p&gt;对于事件处理的写法也有好几种，咱们来进行对比一下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 直接 bind this 型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;就是像文章开始的那样，直接在事件那里 bind this&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;class Foo extends React.Component {
  handleClick () {
    this.setState({ xxx: aaa })
  }

  render() {
    return (
      &amp;lt;button onClick={this.handleClick.bind(this)}&amp;gt;
        Click me
      &amp;lt;/button&amp;gt;
    )
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;：写起来顺手，一口气就能把这个逻辑写完，不用移动光标到其他地方。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;：性能不太好，这种方式跟 react 内部帮你 bind 一样的，每次 render 都会进行 bind，而且如果有两个元素的事件处理函数式同一个，也还是要进行 bind，这样会多写点代码，而且进行两次 bind，性能不是太好。(其实这点性能往往不会是性能瓶颈的地方，如果你觉得顺手，这样写完全没问题)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. constuctor 手动 bind 型&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;class Foo extends React.Component {
  constuctor(props) {
    super(props)
    this.handleClick = this.handleClick.bind(this)
  }
  handleClick () {
    this.setState({ xxx: aaa })
  }

  render() {
    return (
      &amp;lt;button onClick={this.handleClick}&amp;gt;
        Click me
      &amp;lt;/button&amp;gt;
    )
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;相比于第一种性能更好，因为构造函数只执行一次，那么只会 bind 一次，而且如果有多个元素都需要调用这个函数，也不需要重复 bind，基本上解决了第一种的两个缺点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;没有明显缺点，硬要说的话就是太丑了，然后不顺手(我觉得丑，你觉得不丑就这么写就行了)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 箭头函数型&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;class Foo extends React.Component {
  handleClick () {
    this.setState({ xxx: aaa })
  }

  render() {
    return (
      &amp;lt;button onClick={(e) =&amp;gt; this.handleClick(e)}&amp;gt;
        Click me
      &amp;lt;/button&amp;gt;
    )
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;顺手，好看。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;每次 render 都会重复创建函数，性能会差一点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. public class fields 型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这种 &lt;code&gt;class fields&lt;/code&gt;还处于实验阶段，据我所知目前还没有被纳入标准，具体可见&lt;a href=&quot;https://babeljs.io/docs/en/babel-plugin-proposal-class-properties&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;class Foo extends React.Component {
  handleClick = () =&amp;gt; {
    this.setState({ xxx: aaa })
  }

  render() {
    return (
      &amp;lt;button onClick={this.handleClick}&amp;gt;
        Click me
      &amp;lt;/button&amp;gt;
    )
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;好看，性能好。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;没有明显缺点，如果硬要说可能就是要多装一个 &lt;a href=&quot;https://babeljs.io/docs/en/babel-plugin-proposal-class-properties&quot;&gt;babel 插件&lt;/a&gt;来支持这种语法。&lt;/p&gt;
&lt;h4 id=&quot;总结&quot;&gt;总结&lt;/h4&gt;
&lt;p&gt;我平时用的就这四种写法，我这边从代码的美观性、性能以及是否顺手方便对各种写法做了简单的对比。其实每种方法在项目里用都是没什么问题的，性能方面基本上可以忽略，对于美观性和顺手比较主观，所以总体来说就是看大家的偏好咯，如果硬要推荐的话，我还是比较推荐第四种写法，美观而且不影响性能。&lt;/p&gt;
&lt;h2 id=&quot;为什么要-setstate而不是直接-this.state.xx-oo&quot;&gt;为什么要 setState，而不是直接 this.state.xx = oo&lt;/h2&gt;
&lt;p&gt;这个问题是我们公司后端写 React 的时候提出的问题，为啥不能直接修改 state，要 setState 一下。我在想，从 vue 转到 React 可能也会有这种疑问，因为 vue 修改状态都是直接改的。&lt;/p&gt;
&lt;p&gt;如果我们了解 setState 的原理的话，可能就能解答这个问题了，setState 做的事情不仅仅只是修改了 &lt;code&gt;this.state&lt;/code&gt; 的值，另外最重要的是它会触发 React 的更新机制，会进行 diff ，然后将 patch 部分更新到真实 dom 里。&lt;/p&gt;
&lt;p&gt;如果你直接 &lt;code&gt;this.state.xx == oo&lt;/code&gt; 的话，state 的值确实会改，但是改了不会触发 UI 的更新，那就不是数据驱动了。&lt;/p&gt;
&lt;p&gt;那为什么 Vue 直接修改 data 可以触发 UI 的更新呢？因为 Vue 在创建 UI 的时候会把这些 data 给收集起来，并且在这些 data 的访问器属性 setter 进行了重写，在这个重写的方法里会去触发 UI 的更新。如果你想更多的了解 vue 的原理，可以去购买染陌大佬的&lt;a href=&quot;https://juejin.im/book/5a36661851882538e2259c0f&quot;&gt;剖析 Vue.js 内部运行机制&lt;/a&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;3.3116883116883&quot;&gt;
&lt;p&gt;不明白访问器属性的可以看这篇文章：&lt;a href=&quot;https://rainzhaojy.github.io/2015/js_object.html&quot;&gt;深入理解JS里的对象&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;setstate-是同步还是异步相关问题&quot;&gt;setState 是同步还是异步相关问题&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1. setState 是同步还是异步？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我的回答是执行过程代码同步的，&lt;strong&gt;只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形式了所谓的“异步”&lt;/strong&gt;，所以&lt;strong&gt;表现出来&lt;/strong&gt;有时是同步，有时是“异步”。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 何时是同步，何时是异步呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;只在合成事件和钩子函数中是“异步”的，在原生事件和 setTimeout/setInterval等原生 API 中都是同步的。简单的可以理解为被 React 控制的函数里面就会表现出“异步”，反之表现为同步。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 那为什么会出现异步的情况呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了做性能优化，将 state 的更新延缓到最后批量合并再去渲染对于应用的性能优化是有极大好处的，如果每次的状态改变都去重新渲染真实 dom，那么它将带来巨大的性能消耗。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. 那如何在表现出异步的函数里可以准确拿到更新后的 state 呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过第二个参数 &lt;code&gt;setState(partialState, callback)&lt;/code&gt; 中的 callback 拿到更新后的结果。&lt;/p&gt;
&lt;p&gt;或者可以通过给 setState 传递函数来表现出同步的情况：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;this.setState((state) =&amp;gt; {
    return { val: newVal }
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;5. 那表现出异步的原理是怎么样的呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;直接讲源码肯定篇幅不够，可以看这篇文章：&lt;a href=&quot;https://juejin.im/post/5b45c57c51882519790c7441#heading-0&quot;&gt;你真的理解setState吗？&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;我这里还是用最简单的语言让你理解：在 React 的 setState 函数实现中，会根据 isBatchingUpdates(默认是 false) 变量判断是否直接更新 this.state 还是放到队列中稍后更新。然后有一个 batchedUpdate 函数，可以修改 isBatchingUpdates 为 true，当 React 调用事件处理函数之前，或者生命周期函数之前就会调用 batchedUpdate 函数，这样的话，setState 就不会同步更新 this.state，而是放到更新队列里面后续更新。&lt;/p&gt;
&lt;p&gt;这样你就可以理解为什么原生事件和 setTimeout/setinterval 里面调用 this.state 会同步更新了吧，因为通过这些函数调用的 React 没办法去调用 batchedUpdate 函数将 isBatchingUpdates 设置为 true，那么这个时候 setState 的时候默认就是 false，那么就会同步更新。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最后&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;setState 是 React 非常重要的一个方法，值得大家好好去研究一下他的原理。&lt;/p&gt;
&lt;h2 id=&quot;后记&quot;&gt;后记&lt;/h2&gt;
&lt;p&gt;上一篇发出之后，有很多小伙伴留言说想看关于 hooks 相关的问题，毕竟 hooks 出来没多久，有很多疑问很正常，下一篇估计就专门写 hooks 相关的吧。&lt;/p&gt;
&lt;h2 id=&quot;参考文章&quot;&gt;参考文章&lt;/h2&gt;
</description>
<pubDate>Wed, 04 Sep 2019 11:54:00 +0000</pubDate>
<dc:creator>李萧然</dc:creator>
<og:description>网上各种言论说 React 上手比 Vue 难，可能难就难不能深刻理解 JSX，或者对 ES6 的一些特性理解得不够深刻，导致觉得有些点难以理解，然后说 React 比较难上手，还反人类啥的，所以我打</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/taoweng/p/11461253.html</dc:identifier>
</item>
</channel>
</rss>