<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>【一起学源码-微服务】Hystrix 源码二：Hystrix核心流程：Hystix非降级逻辑流程梳理 - 一枝花算不算浪漫</title>
<link>http://www.cnblogs.com/wang-meng/p/12199520.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wang-meng/p/12199520.html</guid>
<description>&lt;h3 id=&quot;说明&quot;&gt;说明&lt;/h3&gt;
&lt;p&gt;原创不易，如若转载 请标明来源！&lt;/p&gt;
&lt;p&gt;欢迎关注本人微信公众号：&lt;a href=&quot;https://www.cnblogs.com/wang-meng/&quot;&gt;壹枝花算不算浪漫&lt;/a&gt;&lt;br/&gt;更多内容也可查看本人博客：&lt;a href=&quot;https://www.cnblogs.com/wang-meng/&quot;&gt;一枝花算不算浪漫&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;h4 id=&quot;前情回顾&quot;&gt;前情回顾&lt;/h4&gt;
&lt;p&gt;上一讲我们讲了配置了feign.hystrix.enabled=true之后，默认的Targeter就会构建成&lt;code&gt;HystrixTargter&lt;/code&gt;, 然后通过对应的&lt;code&gt;HystrixInvocationHandler&lt;/code&gt; 生成对应的动态代理。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/799093/202001/799093-20200116084420061-1793063462.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;本讲目录&quot;&gt;本讲目录&lt;/h4&gt;
&lt;p&gt;这一讲开始讲解Hystrix相关代码，当然还是基于上一个组件Feign的基础上开始讲解的，这里默认你已经对Feign有过大致了解。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;目录如下：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;线程池初始化过程&lt;/li&gt;
&lt;li&gt;HystrixCommand通过线程池执行原理&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;由于这里面代码比较多，所以我都是将一些主要核心代码发出来，这里后面会汇总一个流程图，可以参考流程图 自己一点点调试。&lt;/p&gt;
&lt;p&gt;这里建议在回调的地方都加上断点，而且修改feign和hystrix超时时间，浏览器发送请求后，一步步debug代码。&lt;/p&gt;
&lt;h3 id=&quot;源码分析&quot;&gt;源码分析&lt;/h3&gt;
&lt;h4 id=&quot;线程池初始化过程&quot;&gt;线程池初始化过程&lt;/h4&gt;
&lt;p&gt;上一讲已经讲过激活Hystrix后，构造的InvocationHandler为&lt;code&gt;HystrixInvocationHandler&lt;/code&gt;，所以当调用FeignClient服务实例的时候，会先执行&lt;code&gt;HystrixInvocationHandler.invoke()&lt;/code&gt;方法，这里我们先跟进这个方法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;final class HystrixInvocationHandler implements InvocationHandler {

    @Override
    public Object invoke(final Object proxy, final Method method, final Object[] args)
            throws Throwable {

        // 构建一个HystrixCommand
        // HystrixCommand构造参数需要Setter对象
        HystrixCommand&amp;lt;Object&amp;gt; hystrixCommand = new HystrixCommand&amp;lt;Object&amp;gt;(setterMethodMap.get(method)) {
            @Override
            protected Object run() throws Exception {
                try {
                    // 执行SynchronousMethodHandler.invoke方法
                    return HystrixInvocationHandler.this.dispatch.get(method).invoke(args);
                } catch (Exception e) {
                    throw e;
                } catch (Throwable t) {
                    throw (Error) t;
                }
            }
        }

        // 省略部分代码...

        return hystrixCommand.execute();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里主要是构造&lt;code&gt;HystrixCommand&lt;/code&gt;，我们先看看它的构造函数以及线程池池初始化的代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public abstract class HystrixCommand&amp;lt;R&amp;gt; extends AbstractCommand&amp;lt;R&amp;gt; implements HystrixExecutable&amp;lt;R&amp;gt;, HystrixInvokableInfo&amp;lt;R&amp;gt;, HystrixObservable&amp;lt;R&amp;gt; {

    protected HystrixCommand(HystrixCommandGroupKey group) {
        super(group, null, null, null, null, null, null, null, null, null, null, null);
    }
}

abstract class AbstractCommand&amp;lt;R&amp;gt; implements HystrixInvokableInfo&amp;lt;R&amp;gt;, HystrixObservable&amp;lt;R&amp;gt; {
    protected AbstractCommand(HystrixCommandGroupKey group, HystrixCommandKey key, HystrixThreadPoolKey threadPoolKey, HystrixCircuitBreaker circuitBreaker, HystrixThreadPool threadPool,
            HystrixCommandProperties.Setter commandPropertiesDefaults, HystrixThreadPoolProperties.Setter threadPoolPropertiesDefaults,
            HystrixCommandMetrics metrics, TryableSemaphore fallbackSemaphore, TryableSemaphore executionSemaphore,
            HystrixPropertiesStrategy propertiesStrategy, HystrixCommandExecutionHook executionHook) {

        this.commandGroup = initGroupKey(group);
        this.commandKey = initCommandKey(key, getClass());
        this.properties = initCommandProperties(this.commandKey, propertiesStrategy, commandPropertiesDefaults);
        this.threadPoolKey = initThreadPoolKey(threadPoolKey, this.commandGroup, this.properties.executionIsolationThreadPoolKeyOverride().get());
        this.metrics = initMetrics(metrics, this.commandGroup, this.threadPoolKey, this.commandKey, this.properties);
        this.circuitBreaker = initCircuitBreaker(this.properties.circuitBreakerEnabled().get(), circuitBreaker, this.commandGroup, this.commandKey, this.properties, this.metrics);
        // 初始化线程池
        this.threadPool = initThreadPool(threadPool, this.threadPoolKey, threadPoolPropertiesDefaults);

      // 省略部分代码...
    }

    private static HystrixThreadPool initThreadPool(HystrixThreadPool fromConstructor, HystrixThreadPoolKey threadPoolKey, HystrixThreadPoolProperties.Setter threadPoolPropertiesDefaults) {
        if (fromConstructor == null) {
            // get the default implementation of HystrixThreadPool
            return HystrixThreadPool.Factory.getInstance(threadPoolKey, threadPoolPropertiesDefaults);
        } else {
            return fromConstructor;
        }
    }
}

public interface HystrixThreadPool {
    final static ConcurrentHashMap&amp;lt;String, HystrixThreadPool&amp;gt; threadPools = new ConcurrentHashMap&amp;lt;String, HystrixThreadPool&amp;gt;();

    static HystrixThreadPool getInstance(HystrixThreadPoolKey threadPoolKey, HystrixThreadPoolProperties.Setter propertiesBuilder) {
        // 这个线程池的key就是我们feignClient定义的value名称，其他服务的projectName
        // 在我们的demo中：key = serviceA
        String key = threadPoolKey.name();

        // threadPools是一个map，key就是serviceA
        HystrixThreadPool previouslyCached = threadPools.get(key);
        if (previouslyCached != null) {
            return previouslyCached;
        }

        // 初始化线程池
        synchronized (HystrixThreadPool.class) {
            if (!threadPools.containsKey(key)) {
                threadPools.put(key, new HystrixThreadPoolDefault(threadPoolKey, propertiesBuilder));
            }
        }
        return threadPools.get(key);
    }
}


public abstract class HystrixThreadPoolProperties {
    /* defaults */
    static int default_coreSize = 10;
    static int default_maximumSize = 10;
    static int default_keepAliveTimeMinutes = 1;
    static int default_maxQueueSize = -1;            
    static boolean default_allow_maximum_size_to_diverge_from_core_size = false;
    static int default_queueSizeRejectionThreshold = 5;
    static int default_threadPoolRollingNumberStatisticalWindow = 10000;
    static int default_threadPoolRollingNumberStatisticalWindowBuckets = 10;

    // 省略部分代码...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里主要是初始化线程池的逻辑，从&lt;code&gt;HystrixCommand&lt;/code&gt;一直到&lt;code&gt;HystrixThreadPoolProperties&lt;/code&gt;。这里的&lt;code&gt;threadPools&lt;/code&gt; 是一个Map，一个serviceName会对应一个线程池。&lt;/p&gt;
&lt;p&gt;线程池的默认配置都在&lt;code&gt;HystrixThreadPoolProperties&lt;/code&gt;中。线程池的核心线程和最大线程数都是10，队列的大小为-1，这里意思是不使用队列。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;HystrixCommand&lt;/code&gt;构造函数需要接收一个&lt;code&gt;Setter&lt;/code&gt;对象，Setter中包含两个很重要的属性，&lt;code&gt;groupKey&lt;/code&gt;和&lt;code&gt;commandKey&lt;/code&gt;, 这里看下Setter是如何构造的：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;final class HystrixInvocationHandler implements InvocationHandler {

    HystrixInvocationHandler(Target&amp;lt;?&amp;gt; target, Map&amp;lt;Method, MethodHandler&amp;gt; dispatch,
                           SetterFactory setterFactory, FallbackFactory&amp;lt;?&amp;gt; fallbackFactory) {
        this.target = checkNotNull(target, &quot;target&quot;);
        this.dispatch = checkNotNull(dispatch, &quot;dispatch&quot;);
        this.fallbackFactory = fallbackFactory;
        this.fallbackMethodMap = toFallbackMethod(dispatch);
        this.setterMethodMap = toSetters(setterFactory, target, dispatch.keySet());
    }

    static Map&amp;lt;Method, Setter&amp;gt; toSetters(SetterFactory setterFactory, Target&amp;lt;?&amp;gt; target,
                                       Set&amp;lt;Method&amp;gt; methods) {
        Map&amp;lt;Method, Setter&amp;gt; result = new LinkedHashMap&amp;lt;Method, Setter&amp;gt;();
        for (Method method : methods) {
            method.setAccessible(true);
            result.put(method, setterFactory.create(target, method));
        }
        return result;
    }
}

public interface SetterFactory {
    HystrixCommand.Setter create(Target&amp;lt;?&amp;gt; target, Method method);
    final class Default implements SetterFactory {
        @Override
        public HystrixCommand.Setter create(Target&amp;lt;?&amp;gt; target, Method method) {
            // groupKey既是调用的服务服务名称：serviceA
            String groupKey = target.name();
            // commandKey即是方法的名称+入参定义等，一个commandKey能够确定这个类中唯一的一个方法
            String commandKey = Feign.configKey(target.type(), method);
            return HystrixCommand.Setter
                .withGroupKey(HystrixCommandGroupKey.Factory.asKey(groupKey))
                .andCommandKey(HystrixCommandKey.Factory.asKey(commandKey));
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;构建一个HystrixCommand时必须要传入这两个参数。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;groupKey&lt;/code&gt;: 就是调用的服务名称，例如我们demo中的ServiceA，&lt;code&gt;groupKey&lt;/code&gt;对应着一个线程池。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;commandKey&lt;/code&gt;: 一个FeignClient接口中的一个方法就是一个&lt;code&gt;commandKey&lt;/code&gt;, 其组成为方法名和入参等信息。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;code&gt;groupkey&lt;/code&gt;和&lt;code&gt;commandKey&lt;/code&gt;是一对多的关系，例如ServiceA中的2个方法，那么groupKey就对应着这个ServiceA中的2个commandKey。&lt;/p&gt;
&lt;p&gt;groupKey -&amp;gt; target.name() -&amp;gt; ServiceA -&amp;gt; @FeignClient注解里设置的服务名称&lt;/p&gt;
&lt;p&gt;commanKey -&amp;gt; ServiceAFeignClient#sayHello(String)&lt;/p&gt;
&lt;p&gt;这里回调函数执行&lt;code&gt;HystrixInvocationHandler.this.dispatch.get(method).invoke(args)&lt;/code&gt; 其实就是执行&lt;code&gt;SynchronousMethodHandler.invoke()&lt;/code&gt; 方法了。但是什么时候才会回调回来呢？后面接着看吧。&lt;/p&gt;
&lt;h4 id=&quot;hystrixcommand通过线程池执行原理&quot;&gt;HystrixCommand通过线程池执行原理&lt;/h4&gt;
&lt;p&gt;上面已经看了线程池的初始化过程，当一个服务第一次被调用的时候，会判断&lt;code&gt;threadPools&lt;/code&gt; (数据结构为ConcurrentHashMap) 中是否存在这个serviceName对应的线程池，如果没有的话则会初始化一个对应的线程池。线程池默认配置属性在&lt;code&gt;HystrixThreadPoolProperties&lt;/code&gt;中可以看到。&lt;/p&gt;
&lt;p&gt;Hystrix线程池默认是不使用队列进行线程排队的，核心线程数为10。接下来我们看看创建&lt;code&gt;HystrixCommand&lt;/code&gt;后，线程池是如何将&lt;code&gt;HystrixCommand&lt;/code&gt; 命令提交的：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public abstract class HystrixCommand&amp;lt;R&amp;gt; extends AbstractCommand&amp;lt;R&amp;gt; implements HystrixExecutable&amp;lt;R&amp;gt;, HystrixInvokableInfo&amp;lt;R&amp;gt;, HystrixObservable&amp;lt;R&amp;gt; {
    public R execute() {
        try {
            return queue().get();
        } catch (Exception e) {
            throw Exceptions.sneakyThrow(decomposeException(e));
        }
    }

    public Future&amp;lt;R&amp;gt; queue() {
        final Future&amp;lt;R&amp;gt; delegate = toObservable().toBlocking().toFuture();
        
        final Future&amp;lt;R&amp;gt; f = new Future&amp;lt;R&amp;gt;() {

            @Override
            public boolean cancel(boolean mayInterruptIfRunning) {
                if (delegate.isCancelled()) {
                    return false;
                }

                if (HystrixCommand.this.getProperties().executionIsolationThreadInterruptOnFutureCancel().get()) {
                    interruptOnFutureCancel.compareAndSet(false, mayInterruptIfRunning);
                }

                final boolean res = delegate.cancel(interruptOnFutureCancel.get());

                if (!isExecutionComplete() &amp;amp;&amp;amp; interruptOnFutureCancel.get()) {
                    final Thread t = executionThread.get();
                    if (t != null &amp;amp;&amp;amp; !t.equals(Thread.currentThread())) {
                        t.interrupt();
                    }
                }

                return res;
            }

            @Override
            public boolean isCancelled() {
                return delegate.isCancelled();
            }

            @Override
            public boolean isDone() {
                return delegate.isDone();
            }

            @Override
            public R get() throws InterruptedException, ExecutionException {
                return delegate.get();
            }

            @Override
            public R get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
                return delegate.get(timeout, unit);
            }
            
        };

        if (f.isDone()) {
            try {
                f.get();
                return f;
            } catch (Exception e) {
                Throwable t = decomposeException(e);
                if (t instanceof HystrixBadRequestException) {
                    return f;
                } else if (t instanceof HystrixRuntimeException) {
                    HystrixRuntimeException hre = (HystrixRuntimeException) t;
                    switch (hre.getFailureType()) {
                    case COMMAND_EXCEPTION:
                    case TIMEOUT:
                        // we don't throw these types from queue() only from queue().get() as they are execution errors
                        return f;
                    default:
                        // these are errors we throw from queue() as they as rejection type errors
                        throw hre;
                    }
                } else {
                    throw Exceptions.sneakyThrow(t);
                }
            }
        }

        return f;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里又是一堆的回调函数，我们可以在每个回调函数中打上断点，然后一点点调试。&lt;br/&gt;这里主要是通过&lt;code&gt;toObservable()&lt;/code&gt;方法构造了一个&lt;code&gt;Future&amp;lt;R&amp;gt;&lt;/code&gt;, 然后包装此Future，添加了中断等逻辑，后面使用&lt;code&gt;f.get()&lt;/code&gt; 阻塞获取线程执行结果，最后返回Future对象。&lt;/p&gt;
&lt;p&gt;这里我们的重点在于寻找哪里将HystrixCommand丢入线程池，然后返回一个Future的。&lt;br/&gt;接着往后跟进代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;abstract class AbstractCommand&amp;lt;R&amp;gt; implements HystrixInvokableInfo&amp;lt;R&amp;gt;, HystrixObservable&amp;lt;R&amp;gt; {
    public Observable&amp;lt;R&amp;gt; toObservable() {
        // _cmd就是HystrixInvocationHandler对象
        // 里面包含要请求的method信息，threadPool信息，groupKey，commandKey等信息
        final AbstractCommand&amp;lt;R&amp;gt; _cmd = this;
        final Func0&amp;lt;Observable&amp;lt;R&amp;gt;&amp;gt; applyHystrixSemantics = new Func0&amp;lt;Observable&amp;lt;R&amp;gt;&amp;gt;() {
            @Override
            public Observable&amp;lt;R&amp;gt; call() {
                if (commandState.get().equals(CommandState.UNSUBSCRIBED)) {
                    return Observable.never();
                }
                return applyHystrixSemantics(_cmd);
            }
        };

        // 省略部分回调函数代码...

        return Observable.defer(new Func0&amp;lt;Observable&amp;lt;R&amp;gt;&amp;gt;() {
            @Override
            public Observable&amp;lt;R&amp;gt; call() {
                // 是否使用请求缓存，默认为false
                final boolean requestCacheEnabled = isRequestCachingEnabled();
                // 请求缓存相关
                final String cacheKey = getCacheKey();

                // 省略部分代码...

                Observable&amp;lt;R&amp;gt; hystrixObservable =
                        Observable.defer(applyHystrixSemantics)
                                .map(wrapWithAllOnNextHooks);

                Observable&amp;lt;R&amp;gt; afterCache;

                // put in cache
                if (requestCacheEnabled &amp;amp;&amp;amp; cacheKey != null) {
                    // 省略部分代码...
                } else {
                    afterCache = hystrixObservable;
                }

                return afterCache
                        .doOnTerminate(terminateCommandCleanup)
                        .doOnUnsubscribe(unsubscribeCommandCleanup)
                        .doOnCompleted(fireOnCompletedHook);
            }
        });
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;toObservable()&lt;/code&gt;是比较核心的代码，这里也是定义了很多回调函数，上面代码做了精简，留下一些核心逻辑，在&lt;code&gt;defer()&lt;/code&gt;中构造返回了一个&lt;code&gt;Observable&lt;/code&gt;对象，这个&lt;code&gt;Observable&lt;/code&gt;是包含上面的一些回调函数的。&lt;/p&gt;
&lt;p&gt;通过debug代码，这里会直接执行到&lt;code&gt;applyHystrixSemantics&lt;/code&gt;这个构造函数Func0中的&lt;code&gt;call()&lt;/code&gt;方法中，通过语意 我们可以大致猜到这个函数的意思：应用Hystrix语义&lt;br/&gt;接着往下跟进代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;abstract class AbstractCommand&amp;lt;R&amp;gt; implements HystrixInvokableInfo&amp;lt;R&amp;gt;, HystrixObservable&amp;lt;R&amp;gt; {
    private Observable&amp;lt;R&amp;gt; applyHystrixSemantics(final AbstractCommand&amp;lt;R&amp;gt; _cmd) {
        executionHook.onStart(_cmd);
        // 判断是否短路
        if (circuitBreaker.attemptExecution()) {
            final TryableSemaphore executionSemaphore = getExecutionSemaphore();
            final AtomicBoolean semaphoreHasBeenReleased = new AtomicBoolean(false);
            // 如果不使用Semaphore配置，那么tryAcquire使用的是TryableSemaphoreNoOp中的方法，返回true
            if (executionSemaphore.tryAcquire()) {
                try {
                    /* used to track userThreadExecutionTime */
                    executionResult = executionResult.setInvocationStartTime(System.currentTimeMillis());
                    return executeCommandAndObserve(_cmd)
                            .doOnError(markExceptionThrown)
                            .doOnTerminate(singleSemaphoreRelease)
                            .doOnUnsubscribe(singleSemaphoreRelease);
                } catch (RuntimeException e) {
                    return Observable.error(e);
                }
            } else {
                return handleSemaphoreRejectionViaFallback();
            }
        } else {
            return handleShortCircuitViaFallback();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里面我们默认使用的线程池的隔离配置，所以&lt;code&gt;executionSemaphore.tryAcquire()&lt;/code&gt;都会返回true，这里有个重要的方法：&lt;code&gt;executeCommandAndObserve(_cmd)&lt;/code&gt;, 我们继续往后跟进这个方法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;abstract class AbstractCommand&amp;lt;R&amp;gt; implements HystrixInvokableInfo&amp;lt;R&amp;gt;, HystrixObservable&amp;lt;R&amp;gt; {
    private Observable&amp;lt;R&amp;gt; executeCommandAndObserve(final AbstractCommand&amp;lt;R&amp;gt; _cmd) {
        final HystrixRequestContext currentRequestContext = HystrixRequestContext.getContextForCurrentThread();

        // 省略部分回调函数...

        Observable&amp;lt;R&amp;gt; execution;
        // 默认配置timeOutEnabled为true
        if (properties.executionTimeoutEnabled().get()) {
            // 执行指定的隔离执行命令
            execution = executeCommandWithSpecifiedIsolation(_cmd)
                    .lift(new HystrixObservableTimeoutOperator&amp;lt;R&amp;gt;(_cmd));
        } else {
            execution = executeCommandWithSpecifiedIsolation(_cmd);
        }

        return execution.doOnNext(markEmits)
                .doOnCompleted(markOnCompleted)
                .onErrorResumeNext(handleFallback)
                .doOnEach(setRequestContext);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于Hystrix来说，默认是开启超时机制的，这里会执行&lt;code&gt;executeCommandWithSpecifiedIsolation()&lt;/code&gt;, 返回一个执行的&lt;code&gt;Observable&lt;/code&gt;.还是通过方法名我们可以猜测这个方法是：使用指定的隔离执行命令&lt;br/&gt;继续往里面跟进：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;abstract class AbstractCommand&amp;lt;R&amp;gt; implements HystrixInvokableInfo&amp;lt;R&amp;gt;, HystrixObservable&amp;lt;R&amp;gt; {
    private Observable&amp;lt;R&amp;gt; executeCommandWithSpecifiedIsolation(final AbstractCommand&amp;lt;R&amp;gt; _cmd) {
        if (properties.executionIsolationStrategy().get() == ExecutionIsolationStrategy.THREAD) {
            // mark that we are executing in a thread (even if we end up being rejected we still were a THREAD execution and not SEMAPHORE)
            return Observable.defer(new Func0&amp;lt;Observable&amp;lt;R&amp;gt;&amp;gt;() {
                @Override
                public Observable&amp;lt;R&amp;gt; call() {
                    executionResult = executionResult.setExecutionOccurred();
                    if (!commandState.compareAndSet(CommandState.OBSERVABLE_CHAIN_CREATED, CommandState.USER_CODE_EXECUTED)) {
                        return Observable.error(new IllegalStateException(&quot;execution attempted while in state : &quot; + commandState.get().name()));
                    }

                    metrics.markCommandStart(commandKey, threadPoolKey, ExecutionIsolationStrategy.THREAD);

                    if (isCommandTimedOut.get() == TimedOutStatus.TIMED_OUT) {
                        return Observable.error(new RuntimeException(&quot;timed out before executing run()&quot;));
                    }
                    if (threadState.compareAndSet(ThreadState.NOT_USING_THREAD, ThreadState.STARTED)) {
                        //we have not been unsubscribed, so should proceed
                        HystrixCounters.incrementGlobalConcurrentThreads();
                        threadPool.markThreadExecution();
                        // store the command that is being run
                        endCurrentThreadExecutingCommand = Hystrix.startCurrentThreadExecutingCommand(getCommandKey());
                        executionResult = executionResult.setExecutedInThread();
                        try {
                            executionHook.onThreadStart(_cmd);
                            executionHook.onRunStart(_cmd);
                            executionHook.onExecutionStart(_cmd);
                            return getUserExecutionObservable(_cmd);
                        } catch (Throwable ex) {
                            return Observable.error(ex);
                        }
                    } else {
                        //command has already been unsubscribed, so return immediately
                        return Observable.error(new RuntimeException(&quot;unsubscribed before executing run()&quot;));
                    }
                }
            }).subscribeOn(threadPool.getScheduler(new Func0&amp;lt;Boolean&amp;gt;() {
                @Override
                public Boolean call() {
                    return properties.executionIsolationThreadInterruptOnTimeout().get() &amp;amp;&amp;amp; _cmd.isCommandTimedOut.get() == TimedOutStatus.TIMED_OUT;
                }
            }));
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里就是我们千辛万苦需要找的核心方法了，里面仍然是一个回调函数，通过断点调试，这里会先执行：&lt;code&gt;subscribeOn&lt;/code&gt;回调函数，执行&lt;code&gt;threadPool.getScheduler&lt;/code&gt;方法，我们进一步往后跟进：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface HystrixThreadPool {
    @Override
    public Scheduler getScheduler(Func0&amp;lt;Boolean&amp;gt; shouldInterruptThread) {
        touchConfig();
        return new HystrixContextScheduler(HystrixPlugins.getInstance().getConcurrencyStrategy(), this, shouldInterruptThread);
    }

    private void touchConfig() {
        final int dynamicCoreSize = properties.coreSize().get();
        final int configuredMaximumSize = properties.maximumSize().get();
        int dynamicMaximumSize = properties.actualMaximumSize();
        final boolean allowSizesToDiverge = properties.getAllowMaximumSizeToDivergeFromCoreSize().get();
        boolean maxTooLow = false;

        // 动态调整最大线程池的数量
        if (allowSizesToDiverge &amp;amp;&amp;amp; configuredMaximumSize &amp;lt; dynamicCoreSize) {
            //if user sets maximum &amp;lt; core (or defaults get us there), we need to maintain invariant of core &amp;lt;= maximum
            dynamicMaximumSize = dynamicCoreSize;
            maxTooLow = true;
        }

        // In JDK 6, setCorePoolSize and setMaximumPoolSize will execute a lock operation. Avoid them if the pool size is not changed.
        if (threadPool.getCorePoolSize() != dynamicCoreSize || (allowSizesToDiverge &amp;amp;&amp;amp; threadPool.getMaximumPoolSize() != dynamicMaximumSize)) {
            if (maxTooLow) {
                logger.error(&quot;Hystrix ThreadPool configuration for : &quot; + metrics.getThreadPoolKey().name() + &quot; is trying to set coreSize = &quot; +
                        dynamicCoreSize + &quot; and maximumSize = &quot; + configuredMaximumSize + &quot;.  Maximum size will be set to &quot; +
                        dynamicMaximumSize + &quot;, the coreSize value, since it must be equal to or greater than the coreSize value&quot;);
            }
            threadPool.setCorePoolSize(dynamicCoreSize);
            threadPool.setMaximumPoolSize(dynamicMaximumSize);
        }

        threadPool.setKeepAliveTime(properties.keepAliveTimeMinutes().get(), TimeUnit.MINUTES);
    }
}

public class HystrixContextScheduler extends Scheduler {
    public HystrixContextScheduler(HystrixConcurrencyStrategy concurrencyStrategy, HystrixThreadPool threadPool, Func0&amp;lt;Boolean&amp;gt; shouldInterruptThread) {
        this.concurrencyStrategy = concurrencyStrategy;
        this.threadPool = threadPool;
        this.actualScheduler = new ThreadPoolScheduler(threadPool, shouldInterruptThread);
    }

    @Override
    public Worker createWorker() {
        // 构建一个默认的Worker
        return new HystrixContextSchedulerWorker(actualScheduler.createWorker());
    }

    private static class ThreadPoolScheduler extends Scheduler {

        private final HystrixThreadPool threadPool;
        private final Func0&amp;lt;Boolean&amp;gt; shouldInterruptThread;

        public ThreadPoolScheduler(HystrixThreadPool threadPool, Func0&amp;lt;Boolean&amp;gt; shouldInterruptThread) {
            this.threadPool = threadPool;
            this.shouldInterruptThread = shouldInterruptThread;
        }

        @Override
        public Worker createWorker() {
            // 默认的worker为：ThreadPoolWorker
            return new ThreadPoolWorker(threadPool, shouldInterruptThread);
        }

    }

    private class HystrixContextSchedulerWorker extends Worker {
        // 执行schedule方法
        @Override
        public Subscription schedule(Action0 action) {
            if (threadPool != null) {
                if (!threadPool.isQueueSpaceAvailable()) {
                    throw new RejectedExecutionException(&quot;Rejected command because thread-pool queueSize is at rejection threshold.&quot;);
                }
            }
            // 默认的worker为：ThreadPoolWorker
            return worker.schedule(new HystrixContexSchedulerAction(concurrencyStrategy, action));
        }
    }


    // 执行command的核心类
    private static class ThreadPoolWorker extends Worker {

        private final HystrixThreadPool threadPool;
        private final CompositeSubscription subscription = new CompositeSubscription();
        private final Func0&amp;lt;Boolean&amp;gt; shouldInterruptThread;

        public ThreadPoolWorker(HystrixThreadPool threadPool, Func0&amp;lt;Boolean&amp;gt; shouldInterruptThread) {
            this.threadPool = threadPool;
            this.shouldInterruptThread = shouldInterruptThread;
        }

        @Override
        public void unsubscribe() {
            subscription.unsubscribe();
        }

        @Override
        public boolean isUnsubscribed() {
            return subscription.isUnsubscribed();
        }

        @Override
        public Subscription schedule(final Action0 action) {
            if (subscription.isUnsubscribed()) {
                // don't schedule, we are unsubscribed
                return Subscriptions.unsubscribed();
            }

            // This is internal RxJava API but it is too useful.
            ScheduledAction sa = new ScheduledAction(action);

            subscription.add(sa);
            sa.addParent(subscription);

            ThreadPoolExecutor executor = (ThreadPoolExecutor) threadPool.getExecutor();
            FutureTask&amp;lt;?&amp;gt; f = (FutureTask&amp;lt;?&amp;gt;) executor.submit(sa);
            sa.add(new FutureCompleterWithConfigurableInterrupt(f, shouldInterruptThread, executor));

            return sa;
        }

        @Override
        public Subscription schedule(Action0 action, long delayTime, TimeUnit unit) {
            throw new IllegalStateException(&quot;Hystrix does not support delayed scheduling&quot;);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;touchConfig()&lt;/code&gt; 方法主要是重新设置最大线程池actualMaximumSize的，这里默认的allowMaximumSizeToDivergeFromCoreSize是false。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;HystrixContextScheduler&lt;/code&gt;类中有&lt;code&gt;HystrixContextSchedulerWorker&lt;/code&gt;、&lt;code&gt;ThreadPoolScheduler&lt;/code&gt;、&lt;code&gt;ThreadPoolWorker&lt;/code&gt; 这几个内部类。看看它们的作用：&lt;/p&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;HystrixContextSchedulerWorker&lt;/code&gt;: 对外提供&lt;code&gt;schedule()&lt;/code&gt;方法，这里会判断线程池队列是否已经满，如果满了这会抛出异常：Rejected command because thread-pool queueSize is at rejection threshold。 如果配置的队列大小为-1 则默认返回true。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;ThreadPoolScheduler&lt;/code&gt;：执行&lt;code&gt;createWorker()&lt;/code&gt;方法，默认使用&lt;code&gt;ThreadPoolWorker()&lt;/code&gt;类&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;ThreadPoolWorker&lt;/code&gt;：执行command的核心逻辑&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private static class ThreadPoolWorker extends Worker {

    private final HystrixThreadPool threadPool;
    private final CompositeSubscription subscription = new CompositeSubscription();
    private final Func0&amp;lt;Boolean&amp;gt; shouldInterruptThread;

    @Override
    public Subscription schedule(final Action0 action) {
        if (subscription.isUnsubscribed()) {
            return Subscriptions.unsubscribed();
        }

        ScheduledAction sa = new ScheduledAction(action);
        subscription.add(sa);
        sa.addParent(subscription);
        // 获取线程池
        ThreadPoolExecutor executor = (ThreadPoolExecutor) threadPool.getExecutor();
        // 将包装后的HystrixCommand submit到线程池，然后返回FutureTask
        FutureTask&amp;lt;?&amp;gt; f = (FutureTask&amp;lt;?&amp;gt;) executor.submit(sa);
        sa.add(new FutureCompleterWithConfigurableInterrupt(f, shouldInterruptThread, executor));

        return sa;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;原来一个command就是在这里被提交到线程池的，再次回到&lt;code&gt;AbstractCommand.executeCommandWithSpecifiedIsolation()&lt;/code&gt;方法中，这里会回调到这个回调函数的&lt;code&gt;call()&lt;/code&gt;方法中，这里一路执行逻辑如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;getUserExecutionObservable(_cmd)&lt;/code&gt;==&amp;gt;&lt;code&gt;getExecutionObservable()&lt;/code&gt;==&amp;gt;&lt;code&gt;hystrixCommand.run()&lt;/code&gt;==&amp;gt;&lt;code&gt;SynchronousMethodHandler.invoke()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这里最后执行到&lt;code&gt;HystrixInvocationHandler&lt;/code&gt;中的&lt;code&gt;invoke()&lt;/code&gt;方法中的回调函数&lt;code&gt;run()&lt;/code&gt;中，最后执行&lt;code&gt;SynchronousMethodHandler.invoke()&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;一个正常的feign请求，经过hystrix走一遍也就返回对应的response。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;上面一顿分析，不知道大家有没有对hystrix 线程池及command执行是否有些理解了？&lt;/p&gt;
&lt;p&gt;这个是一个正向流程，没有涉及超时、熔断、降级等代码。关于这些异常降级的源码会在后面一篇文章涉及。&lt;/p&gt;
&lt;p&gt;还是之前的建议，大家可以在每个相关的回调函数打上断点，然后一点点调试。&lt;/p&gt;
&lt;p&gt;最后再总结一下简单的流程：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;浏览器发送请求，执行HystrixTargter&lt;/li&gt;
&lt;li&gt;创建HystrixCommand，根据serviceName构造线程池&lt;/li&gt;
&lt;li&gt;AbstractCommand中一堆回调函数，最后将command交由线程池submit处理&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;画一张流程图加深理解：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/799093/202001/799093-20200116084421491-849320224.png&quot; alt=&quot;Hystrix线程池创建过程及线程调用原理.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;高清大图：https://www.processon.com/view/link/5e1c128ce4b0169fb51ce77e&lt;/p&gt;
&lt;h3 id=&quot;申明&quot;&gt;申明&lt;/h3&gt;
&lt;p&gt;本文章首发自本人博客：&lt;a href=&quot;https://www.cnblogs.com/wang-meng/&quot;&gt;https://www.cnblogs.com/wang-meng&lt;/a&gt; 和公众号：&lt;strong&gt;壹枝花算不算浪漫&lt;/strong&gt;，如若转载请标明来源!&lt;/p&gt;
&lt;p&gt;感兴趣的小伙伴可关注个人公众号：壹枝花算不算浪漫&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/799093/202001/799093-20200116084421921-664627768.jpg&quot; alt=&quot;WechatIMG33.jpeg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 16 Jan 2020 00:44:00 +0000</pubDate>
<dc:creator>一枝花算不算浪漫</dc:creator>
<og:description>说明 原创不易，如若转载 请标明来源！ 欢迎关注本人微信公众号：[壹枝花算不算浪漫][1] 更多内容也可查看本人博客：[一枝花算不算浪漫][2] 前言 前情回顾 上一讲我们讲了配置了feign.hys</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wang-meng/p/12199520.html</dc:identifier>
</item>
<item>
<title>.NET Core 3 WPF MVVM框架 Prism系列之事件聚合器 - RyzenAdorer</title>
<link>http://www.cnblogs.com/ryzen/p/12196619.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ryzen/p/12196619.html</guid>
<description>&lt;p&gt;本文将介绍如何在.NET Core3环境下使用MVVM框架Prism的使用事件聚合器实现模块间的通信&lt;/p&gt;
&lt;h2 id=&quot;一.事件聚合器&quot;&gt;一.事件聚合器&lt;/h2&gt;
&lt;p&gt; 在上一篇 &lt;a href=&quot;https://www.cnblogs.com/ryzen/p/12185054.html&quot;&gt;.NET Core 3 WPF MVVM框架 Prism系列之模块化&lt;/a&gt; 我们留下了一些问题，就是如何处理同模块不同窗体之间的通信和不同模块之间不同窗体的通信，Prism提供了一种事件机制，可以在应用程序中低耦合的模块之间进行通信，该机制基于事件聚合器服务，允许发布者和订阅者之间通过事件进行通讯，且彼此之间没有之间引用，这就实现了模块之间低耦合的通信方式，下面引用官方的一个事件聚合器模型图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1294271/202001/1294271-20200115143733933-563795532.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;二.创建和发布事件&quot;&gt;二.创建和发布事件&lt;/h2&gt;
&lt;h3 id=&quot;创建事件&quot;&gt;1.创建事件&lt;/h3&gt;
&lt;p&gt; 首先我们来处理同模块不同窗体之间的通讯，我们在PrismMetroSample.Infrastructure新建一个文件夹Events,然后新建一个类PatientSentEvent，代码如下：&lt;br/&gt;PatientSentEvent.cs:&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class PatientSentEvent: PubSubEvent&amp;lt;Patient&amp;gt;
{
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;订阅事件&quot;&gt;2.订阅事件&lt;/h3&gt;
&lt;p&gt; 然后我们在病人详细窗体的PatientDetailViewModel类订阅该事件，代码如下：&lt;br/&gt;PatientDetailViewModel.cs:&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt; public class PatientDetailViewModel : BindableBase
 {
    IEventAggregator _ea;
    IMedicineSerivce _medicineSerivce;

    private Patient _currentPatient;
     //当前病人
    public Patient CurrentPatient
    {
        get { return _currentPatient; }
        set { SetProperty(ref _currentPatient, value); }
    }

    private ObservableCollection&amp;lt;Medicine&amp;gt; _lstMedicines;
     //当前病人的药物列表
    public ObservableCollection&amp;lt;Medicine&amp;gt; lstMedicines
    {
        get { return _lstMedicines; }
        set { SetProperty(ref _lstMedicines, value); }
    }
  
     //构造函数
    public PatientDetailViewModel(IEventAggregator ea, IMedicineSerivce medicineSerivce)
    {
        _medicineSerivce = medicineSerivce;
        _ea = ea;
        _ea.GetEvent&amp;lt;PatientSentEvent&amp;gt;().Subscribe(PatientMessageReceived);//订阅事件
    }
     
     //处理接受消息函数
    private void PatientMessageReceived(Patient patient)
    {
        this.CurrentPatient = patient;
        this.lstMedicines = new ObservableCollection&amp;lt;Medicine&amp;gt;(_medicineSerivce.GetRecipesByPatientId(this.CurrentPatient.Id).FirstOrDefault().LstMedicines);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;发布消息&quot;&gt;3.发布消息&lt;/h3&gt;
&lt;p&gt; 然后我们在病人列表窗体的PatientListViewModel中发布消息，代码如下：&lt;br/&gt;PatientListViewModel.cs:&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class PatientListViewModel : BindableBase
{

    private IApplicationCommands _applicationCommands;
    public IApplicationCommands ApplicationCommands
    {
        get { return _applicationCommands; }
        set { SetProperty(ref _applicationCommands, value); }
    }

    private List&amp;lt;Patient&amp;gt; _allPatients;
    public List&amp;lt;Patient&amp;gt; AllPatients
    {
        get { return _allPatients; }
        set { SetProperty(ref _allPatients, value); }
    }

    private DelegateCommand&amp;lt;Patient&amp;gt; _mouseDoubleClickCommand;
    public DelegateCommand&amp;lt;Patient&amp;gt; MouseDoubleClickCommand =&amp;gt;
        _mouseDoubleClickCommand ?? (_mouseDoubleClickCommand = new DelegateCommand&amp;lt;Patient&amp;gt;(ExecuteMouseDoubleClickCommand));

    IEventAggregator _ea;

    IPatientService _patientService;

        /// &amp;lt;summary&amp;gt;
        /// 构造函数
        /// &amp;lt;/summary&amp;gt;
    public PatientListViewModel(IPatientService patientService, IEventAggregator ea, IApplicationCommands applicationCommands)
    {
         _ea = ea;
         this.ApplicationCommands = applicationCommands;
         _patientService = patientService;
         this.AllPatients = _patientService.GetAllPatients();         
    }

    /// &amp;lt;summary&amp;gt;
    /// DataGrid 双击按钮命令方法
    /// &amp;lt;/summary&amp;gt;
    void ExecuteMouseDoubleClickCommand(Patient patient)
    {
        //打开窗体
        this.ApplicationCommands.ShowCommand.Execute(FlyoutNames.PatientDetailFlyout);
        //发布消息
        _ea.GetEvent&amp;lt;PatientSentEvent&amp;gt;().Publish(patient);
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1294271/202001/1294271-20200115143836570-347160412.gif&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;实现多订阅多发布&quot;&gt;4.实现多订阅多发布&lt;/h3&gt;
&lt;p&gt; 同理，我们实现搜索后的Medicine添加到当前病人列表中也是跟上面步骤一样,在Events文件夹创建事件类MedicineSentEvent:&lt;/p&gt;
&lt;p&gt;MedicineSentEvent.cs:&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt; public class MedicineSentEvent: PubSubEvent&amp;lt;Medicine&amp;gt;
 {

 }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt; 在病人详细窗体的PatientDetailViewModel类订阅该事件：&lt;br/&gt;PatientDetailViewModel.cs:&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt; public PatientDetailViewModel(IEventAggregator ea, IMedicineSerivce medicineSerivce)
 {
      _medicineSerivce = medicineSerivce;
      _ea = ea;
      _ea.GetEvent&amp;lt;PatientSentEvent&amp;gt;().Subscribe(PatientMessageReceived);
      _ea.GetEvent&amp;lt;MedicineSentEvent&amp;gt;().Subscribe(MedicineMessageReceived);
 }

 /// &amp;lt;summary&amp;gt;
 // 接受事件消息函数
 /// &amp;lt;/summary&amp;gt;
 private void MedicineMessageReceived(Medicine  medicine)
 {
      this.lstMedicines?.Add(medicine);
 }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt; 在药物列表窗体的MedicineMainContentViewModel也订阅该事件：&lt;br/&gt;MedicineMainContentViewModel.cs：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class MedicineMainContentViewModel : BindableBase
{
   IMedicineSerivce _medicineSerivce;
   IEventAggregator _ea;

   private ObservableCollection&amp;lt;Medicine&amp;gt; _allMedicines;
   public ObservableCollection&amp;lt;Medicine&amp;gt; AllMedicines
   {
        get { return _allMedicines; }
        set { SetProperty(ref _allMedicines, value); }
   }
   public MedicineMainContentViewModel(IMedicineSerivce medicineSerivce,IEventAggregator ea)
   {
        _medicineSerivce = medicineSerivce;
        _ea = ea;
        this.AllMedicines = new ObservableCollection&amp;lt;Medicine&amp;gt;(_medicineSerivce.GetAllMedicines());
        _ea.GetEvent&amp;lt;MedicineSentEvent&amp;gt;().Subscribe(MedicineMessageReceived);//订阅事件
   }

   /// &amp;lt;summary&amp;gt;
   /// 事件消息接受函数
   /// &amp;lt;/summary&amp;gt;
   private void MedicineMessageReceived(Medicine medicine)
   {
        this.AllMedicines?.Add(medicine);
   }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在搜索Medicine窗体的SearchMedicineViewModel类发布事件消息：&lt;br/&gt;SearchMedicineViewModel.cs:&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt; IEventAggregator _ea;

 private DelegateCommand&amp;lt;Medicine&amp;gt; _addMedicineCommand;
 public DelegateCommand&amp;lt;Medicine&amp;gt; AddMedicineCommand =&amp;gt;
     _addMedicineCommand ?? (_addMedicineCommand = new DelegateCommand&amp;lt;Medicine&amp;gt;(ExecuteAddMedicineCommand));

public SearchMedicineViewModel(IMedicineSerivce medicineSerivce, IEventAggregator ea)
{
     _ea = ea;
     _medicineSerivce = medicineSerivce;
     this.CurrentMedicines = this.AllMedicines = _medicineSerivce.GetAllMedicines();
 }

 void ExecuteAddMedicineCommand(Medicine currentMedicine)
 {
     _ea.GetEvent&amp;lt;MedicineSentEvent&amp;gt;().Publish(currentMedicine);//发布消息
 }

 &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1294271/202001/1294271-20200115143933366-977108670.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我们看看现在Demo项目的事件模型和程序集引用情况，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1294271/202001/1294271-20200115143955612-401611739.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 我们发现PatientModule和MedicineModule两个模块之间做到了通讯，但却不相互引用，依靠引用PrismMetroSample.Infrastructure程序集来实现间接依赖关系，实现了不同模块之间通讯且低耦合的情况&lt;/p&gt;
&lt;h2 id=&quot;三.取消订阅事件&quot;&gt;三.取消订阅事件&lt;/h2&gt;
&lt;p&gt; Prism还提供了取消订阅的功能，我们在病人详细窗体提供该功能，PatientDetailViewModel加上这几句：&lt;br/&gt;PatientDetailViewModel.cs:&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt; private DelegateCommand _cancleSubscribeCommand;
 public DelegateCommand CancleSubscribeCommand =&amp;gt;
       _cancleSubscribeCommand ?? (_cancleSubscribeCommand = new DelegateCommand(ExecuteCancleSubscribeCommand));

  void ExecuteCancleSubscribeCommand()
  {
      _ea.GetEvent&amp;lt;MedicineSentEvent&amp;gt;().Unsubscribe(MedicineMessageReceived);
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1294271/202001/1294271-20200115144032900-810268328.gif&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;四.几种订阅方式设置&quot;&gt;四.几种订阅方式设置&lt;/h2&gt;
&lt;p&gt; 我们在Demo已经通过消息聚合器的事件机制，实现订阅者和发布者之间的通讯，我们再来看看，Prim都有哪些订阅方式，我们可以通过PubSubEvent类上面的Subscribe函数的其中最多参数的重载方法来说明：&lt;/p&gt;
&lt;p&gt;Subscribe.cs:&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public virtual SubscriptionToken Subscribe(Action&amp;lt;TPayload&amp;gt; action, ThreadOption threadOption, bool keepSubscriberReferenceAlive, Predicate&amp;lt;TPayload&amp;gt; filter);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;action参数&quot;&gt;1.action参数&lt;/h3&gt;
&lt;p&gt;其中action参数则是我们接受消息的函数&lt;/p&gt;
&lt;h3 id=&quot;threadoption参数&quot;&gt;2.threadOption参数&lt;/h3&gt;
&lt;p&gt;ThreadOption类型参数threadOption是个枚举类型参数，代码如下：&lt;br/&gt;ThreadOption.cs&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public enum ThreadOption
{
        /// &amp;lt;summary&amp;gt;
        /// The call is done on the same thread on which the &amp;lt;see    cref=&quot;PubSubEvent{TPayload}&quot;/&amp;gt; was published.
        /// &amp;lt;/summary&amp;gt;
        PublisherThread,

        /// &amp;lt;summary&amp;gt;
        /// The call is done on the UI thread.
        /// &amp;lt;/summary&amp;gt;
        UIThread,

        /// &amp;lt;summary&amp;gt;
        /// The call is done asynchronously on a background thread.
        /// &amp;lt;/summary&amp;gt;
        BackgroundThread
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;三种枚举值的作用：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;PublisherThread：默认设置，使用此设置能接受发布者传递的消息&lt;/li&gt;
&lt;li&gt;UIThread：可以在UI线程上接受事件&lt;/li&gt;
&lt;li&gt;BackgroundThread：可以在线程池在异步接受事件&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;keepsubscriberreferencealive参数&quot;&gt;3.keepSubscriberReferenceAlive参数&lt;/h3&gt;
&lt;p&gt;默认keepSubscriberReferenceAlive为false，在Prism官方是这么说的，该参数指示订阅使用弱引用还是强引用，false为弱引用，true为强引用：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;设置为true，能够提升短时间发布多个事件的性能，但是要手动取消订阅事件，因为事件实例对保留对订阅者实例的强引用，否则就算窗体关闭，也不会进行GC回收.&lt;/li&gt;
&lt;li&gt;设置为false，事件维护对订阅者实例的弱引用，当窗体关闭时，会自动取消订阅事件，也就是不用手动取消订阅事件&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;filter参数&quot;&gt;4.filter参数&lt;/h3&gt;
&lt;p&gt; filter是一个Predicate的泛型委托参数，返回值为布尔值，可用来订阅过滤，以我们demo为例子，更改PatientDetailViewModel订阅，代码如下：&lt;br/&gt;PatientDetailViewModel.cs：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;  _ea.GetEvent&amp;lt;MedicineSentEvent&amp;gt;().Subscribe(MedicineMessageReceived,
ThreadOption.PublisherThread,false,medicine=&amp;gt;medicine.Name==&quot;当归&quot;|| medicine.Name== &quot;琼浆玉露&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1294271/202001/1294271-20200115144118423-1341552290.gif&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;五.源码&quot;&gt;五.源码&lt;/h2&gt;
&lt;p&gt; 最后，附上整个demo的源代码：&lt;a href=&quot;https://github.com/ZhengDaoWang/PrismMetroSample&quot;&gt;PrismDemo源码&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 16 Jan 2020 00:10:00 +0000</pubDate>
<dc:creator>RyzenAdorer</dc:creator>
<og:description>本文将介绍如何在.NET Core3环境下使用MVVM框架Prism的使用事件聚合器实现模块间的通信 一.事件聚合器 在上一篇 &amp;quot;.NET Core 3 WPF MVVM框架 Prism系列</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ryzen/p/12196619.html</dc:identifier>
</item>
<item>
<title>[ASP.NET Core 3框架揭秘] Options[5]: 依赖注入 - Artech</title>
<link>http://www.cnblogs.com/artech/p/inside-asp-net-core-06-05.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/artech/p/inside-asp-net-core-06-05.html</guid>
<description>&lt;p&gt;《&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-06-03.html&quot;&gt;Options模型&lt;/a&gt;》介绍了组成Options模型的4个核心对象以及它们之间的交互关系，读者对如何得到Options对象的实现原理可能不太了解，本篇文章主要介绍依赖注入的相关内容。既然我们能够利用IServiceProvider对象提供的IOptions&amp;lt;TOptions&amp;gt;服务、IOptionsSnapshot&amp;lt;TOptions&amp;gt;服务和IOptionsMonitorCache&amp;lt;TOptions&amp;gt;服务来获取对应的Options对象，那么在这之前必然需要注册相应的服务。回顾《&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-06-01.html&quot;&gt;配置选项的正确使用方式&lt;/a&gt;》演示的几个实例可以发现，Options模式涉及的API其实不是很多，大都集中在相关服务的注册上。Options模型的核心服务实现在IServiceCollection接口的&lt;span&gt;AddOptions&lt;/span&gt;扩展方法。&lt;/p&gt;

&lt;p&gt;AddOptions扩展方法的完整定义如下所示，由此可知，该方法将Options模型中的几个核心类型作为服务注册到了指定的IServiceCollection对象之中。由于它们都是调用&lt;span&gt;TryAdd&lt;/span&gt;方法进行服务注册的，所以我们可以在需要Options模式支持的情况下调用AddOptions方法，而不需要担心是否会添加太多重复服务注册的问题。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OptionsServiceCollectionExtensions
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection AddOptions(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IServiceCollection services)
    {
        services.TryAdd(ServiceDescriptor.Singleton(&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;(IOptions&amp;lt;&amp;gt;), &lt;span&gt;typeof&lt;/span&gt;(OptionsManager&amp;lt;&amp;gt;&lt;span&gt;)));
        services.TryAdd(ServiceDescriptor.Scoped(&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;(IOptionsSnapshot&amp;lt;&amp;gt;), &lt;span&gt;typeof&lt;/span&gt;(OptionsManager&amp;lt;&amp;gt;&lt;span&gt;)));
        services.TryAdd(ServiceDescriptor.Singleton(&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;(IOptionsMonitor&amp;lt;&amp;gt;), &lt;span&gt;typeof&lt;/span&gt;(OptionsMonitor&amp;lt;&amp;gt;&lt;span&gt;)));
        services.TryAdd(ServiceDescriptor.Transient(&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;(IOptionsFactory&amp;lt;&amp;gt;), &lt;span&gt;typeof&lt;/span&gt;(OptionsFactory&amp;lt;&amp;gt;&lt;span&gt;)));
        services.TryAdd(ServiceDescriptor.Singleton(&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;(IOptionsMonitorCache&amp;lt;&amp;gt;), &lt;span&gt;typeof&lt;/span&gt;(OptionsCache&amp;lt;&amp;gt;&lt;span&gt;)));
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; services;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从给出的代码片段可以看出，AddOptions扩展方法实际上注册了5个服务。由于这5个服务注册非常重要，所以笔者采用表格的形式列出了它们的Service Type（服务接口）、Implementation（实现类型）和Lifetime（生命周期）（见下表）。虽然服务接口IOptions&amp;lt;TOptions&amp;gt;和IOptionsSnapshot&amp;lt;TOptions&amp;gt;映射的实现类型都是&lt;span&gt;OptionsManager&amp;lt;TOptions&amp;gt;，&lt;/span&gt;但是它们&lt;span&gt;具有不同的生命周期&lt;/span&gt;。具体来说，前者的生命周期为Singleton，后者的生命周期则是Scoped，后续内容会单独讲述不同生命周期对Options对象产生什么样的影响。&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr&gt;&lt;td width=&quot;250&quot;&gt;
&lt;p&gt;&lt;strong&gt;Service Type&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;240&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;strong&gt;Implementation&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;144&quot;&gt;
&lt;p&gt;&lt;strong&gt;Lifetime&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td width=&quot;204&quot;&gt;
&lt;p&gt;IOptions&amp;lt;TOptions&amp;gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;240&quot;&gt;
&lt;p&gt;OptionsManager&amp;lt;TOptions&amp;gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;144&quot;&gt;
&lt;p&gt;Singleton&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td width=&quot;204&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;IOptionsSnapshot&amp;lt;TOptions&amp;gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;240&quot;&gt;
&lt;p&gt;OptionsManager&amp;lt;TOptions&amp;gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;144&quot;&gt;
&lt;p&gt;Scoped&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td width=&quot;204&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;IOptionsMonitor&amp;lt;TOptions&amp;gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;240&quot;&gt;
&lt;p&gt;OptionsMonitor&amp;lt;TOptions&amp;gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;144&quot;&gt;
&lt;p&gt;Singleton&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td width=&quot;204&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;IOptionsFactory&amp;lt;TOptions&amp;gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;240&quot;&gt;
&lt;p&gt;OptionsFactory&amp;lt;TOptions&amp;gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;144&quot;&gt;
&lt;p&gt;Transient&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td width=&quot;204&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;IOptionsMonitorCache&amp;lt;TOptions&amp;gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;240&quot;&gt;
&lt;p&gt;OptionsCache&amp;lt;TOptions&amp;gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;144&quot;&gt;
&lt;p&gt;Singleton&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;按照上表列举的服务注册，如果以IOptions&amp;lt;TOptions&amp;gt;和IOptionsSnapshot&amp;lt;TOptions&amp;gt;作为服务类型从IServieProvidere对象中提取对应的服务实例，得到的都是OptionsManager&amp;lt;TOptions&amp;gt;对象。当OptionsManager&amp;lt;TOptions&amp;gt;对象被创建时，OptionsFactory&amp;lt;TOptions&amp;gt;对象会被自动创建出来并以构造器注入的方式提供给它并且被用来创建Options对象。但是由于表7-1中并没有针对服务IConfigureOptions&amp;lt;TOptions&amp;gt;和IPostConfigureOptions&amp;lt;TOptions&amp;gt;的注册，所以创建的Options对象无法被初始化。&lt;/p&gt;

&lt;p&gt;针对IConfigureOptions&amp;lt;TOptions&amp;gt;和IPostConfigureOptions&amp;lt;TOptions&amp;gt;的服务注册是通过如下这些扩展方法来完成的。具体来说，针对IConfigureOptions&amp;lt;TOptions&amp;gt;服务的注册实现在&lt;span&gt;Configure&amp;lt;TOptions&amp;gt;&lt;/span&gt;方法中，而&lt;span&gt;PostConfigure&amp;lt;TOptions&amp;gt;&lt;/span&gt;扩展方法则帮助我们完成针对IPostConfigureOptions&amp;lt;TOptions&amp;gt;的注册。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OptionsServiceCollectionExtensions
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection Configure&amp;lt;TOptions&amp;gt;(&lt;span&gt;this&lt;/span&gt; IServiceCollection services, Action&amp;lt;TOptions&amp;gt;&lt;span&gt; configureOptions)
        &lt;/span&gt;&lt;span&gt;where&lt;/span&gt; TOptions : &lt;span&gt;class&lt;/span&gt;
        =&amp;gt;&lt;span&gt; services.Configure(Options.Options.DefaultName, configureOptions);

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection Configure&amp;lt;TOptions&amp;gt;(&lt;span&gt;this&lt;/span&gt; IServiceCollection services, &lt;span&gt;string&lt;/span&gt; name, Action&amp;lt;TOptions&amp;gt; configureOptions) &lt;span&gt;where&lt;/span&gt; TOptions : &lt;span&gt;class&lt;/span&gt;
        =&amp;gt; services.AddSingleton&amp;lt;IConfigureOptions&amp;lt;TOptions&amp;gt;&amp;gt;&lt;span&gt;(
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; ConfigureNamedOptions&amp;lt;TOptions&amp;gt;&lt;span&gt;(name, configureOptions));
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; services;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection PostConfigure&amp;lt;TOptions&amp;gt;(&lt;span&gt;this&lt;/span&gt; IServiceCollection services, Action&amp;lt;TOptions&amp;gt;&lt;span&gt; configureOptions)
        &lt;/span&gt;&lt;span&gt;where&lt;/span&gt; TOptions : &lt;span&gt;class&lt;/span&gt;
        =&amp;gt;&lt;span&gt; services.PostConfigure(Options.Options.DefaultName, configureOptions);

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection PostConfigure&amp;lt;TOptions&amp;gt;(&lt;span&gt;this&lt;/span&gt; IServiceCollection services, &lt;span&gt;string&lt;/span&gt; name,Action&amp;lt;TOptions&amp;gt; configureOptions) &lt;span&gt;where&lt;/span&gt; TOptions : &lt;span&gt;class&lt;/span&gt;
        =&amp;gt; services.AddSingleton&amp;lt;IPostConfigureOptions&amp;lt;TOptions&amp;gt;&amp;gt;(&lt;span&gt;new&lt;/span&gt; PostConfigureOptions&amp;lt;TOptions&amp;gt;&lt;span&gt;(name, configureOptions));
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从上述代码可以看出，这些方法注册的服务实现类型为ConfigureNamedOptions&amp;lt;TOptions&amp;gt;和PostConfigureOptions&amp;lt;TOptions&amp;gt;，采用的生命周期模式均为Singleton。不论是ConfigureNamedOptions&amp;lt;TOptions&amp;gt;还是PostConfigureOptions&amp;lt;TOptions&amp;gt;，都需要指定一个具体的名称，对于没有指定具体Options名称的Configure&amp;lt;TOptions&amp;gt;和PostConfigure&amp;lt;TOptions&amp;gt;方法重载来说，最终指定的是代表默认名称的空字符串。&lt;/p&gt;

&lt;p&gt;虽然ConfigureAll&amp;lt;TOptions&amp;gt;和PostConfigureAll&amp;lt;TOptions&amp;gt;扩展方法注册的同样是ConfigureNamedOptions&amp;lt;TOptions&amp;gt;和PostConfigureOptions&amp;lt;TOptions&amp;gt;类型，但是它们会将名称设置为Null。通过《&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-06-03.html&quot;&gt;Options模型&lt;/a&gt;》的内容可知，OptionsFactory对象在进行Options对象的初始化过程中会将名称为Null的IConfigureNamedOptions&amp;lt;TOptions&amp;gt;和IPostConfigureOptions&amp;lt;TOptions&amp;gt;对象作为公共的配置对象，并且无条件执行。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OptionsServiceCollectionExtensions
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection ConfigureAll&amp;lt;TOptions&amp;gt;(&lt;span&gt;this&lt;/span&gt; IServiceCollection services, Action&amp;lt;TOptions&amp;gt;&lt;span&gt; configureOptions)
        &lt;/span&gt;&lt;span&gt;where&lt;/span&gt; TOptions : &lt;span&gt;class&lt;/span&gt;
        =&amp;gt; services.Configure(name: &lt;span&gt;null&lt;/span&gt;&lt;span&gt;, configureOptions: configureOptions);

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection PostConfigureAll&amp;lt;TOptions&amp;gt;(&lt;span&gt;this&lt;/span&gt; IServiceCollection services, Action&amp;lt;TOptions&amp;gt;&lt;span&gt; configureOptions)
        &lt;/span&gt;&lt;span&gt;where&lt;/span&gt; TOptions : &lt;span&gt;class&lt;/span&gt;
        =&amp;gt; services.PostConfigure(name: &lt;span&gt;null&lt;/span&gt;&lt;span&gt;, configureOptions: configureOptions);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;对于&lt;a&gt;上面这几个将&lt;/a&gt;Options类型作为泛型参数的方法来说，它们总是利用指定的Action&amp;lt;Options&amp;gt;对象来创建注册的ConfigureNamedOptions&amp;lt;TOptions&amp;gt;对象和PostConfigureOptions&amp;lt;TOptions&amp;gt;对象 。对于自定义的实现了IConfigureOptions&amp;lt;TOptions&amp;gt;接口或者IPostConfigureOptions&amp;lt;TOptions&amp;gt;接口的类型，我们可以调用如下所示的3个ConfigureOptions扩展方法来对它们进行注册。笔者在如下所示的代码片段中通过简化的代码描述了这3个扩展方法的实现逻辑。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OptionsServiceCollectionExtensions
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection ConfigureOptions(&lt;span&gt;this&lt;/span&gt; IServiceCollection services, &lt;span&gt;object&lt;/span&gt;&lt;span&gt; configureInstance)
    {
        Array.ForEach(FindIConfigureOptions(configureInstance.GetType()), it &lt;/span&gt;=&amp;gt;&lt;span&gt; services.AddSingleton(it, configureInstance));
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; services;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection ConfigureOptions(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IServiceCollection services, Type configureType)
    {
        Array.ForEach(FindIConfigureOptions(configureType), it &lt;/span&gt;=&amp;gt;&lt;span&gt; services.AddTransient(it, configureType));
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; services;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection ConfigureOptions&amp;lt;TConfigureOptions&amp;gt;(&lt;span&gt;this&lt;/span&gt; IServiceCollection services) &lt;span&gt;where&lt;/span&gt; TConfigureOptions : &lt;span&gt;class&lt;/span&gt;
        =&amp;gt; services.ConfigureOptions(&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(TConfigureOptions));

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Type[] FindIConfigureOptions(Type type)
    {
        Func&lt;/span&gt;&amp;lt;Type, &lt;span&gt;bool&lt;/span&gt;&amp;gt; valid = it =&amp;gt; it.IsGenericType &amp;amp;&amp;amp; (it.GetGenericTypeDefinition() == &lt;span&gt;typeof&lt;/span&gt;(IConfigureOptions&amp;lt;&amp;gt;) || it.GetGenericTypeDefinition() == &lt;span&gt;typeof&lt;/span&gt;(IPostConfigureOptions&amp;lt;&amp;gt;&lt;span&gt;));
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; types =&lt;span&gt; type.GetInterfaces().Where(valid).ToArray();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (types.Any())
        {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InvalidOperationException();
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; types;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Options模式涉及针对非常多的服务注册，并且这些服务都是针对具体某个Options类型的，为了避免定义过多针对IServiceCollection接口的扩展方法，最新版本的Options模型采用Builder模式来完成相关的服务注册。具体来说，可以将用来存储服务注册的IServiceCollection集合封装到下面的OptionsBuilder&amp;lt;TOptions&amp;gt;对象中，并利用它提供的方法间接地完成所需的服务注册。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;152&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; OptionsBuilder&amp;lt;TOptions&amp;gt; &lt;span&gt;where&lt;/span&gt; TOptions : &lt;span&gt;class&lt;/span&gt;&lt;span&gt;
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IServiceCollection Services { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; OptionsBuilder(IServiceCollection services, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; name);

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; OptionsBuilder&amp;lt;TOptions&amp;gt; Configure(Action&amp;lt;TOptions&amp;gt;&lt;span&gt; configureOptions);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; OptionsBuilder&amp;lt;TOptions&amp;gt; Configure&amp;lt;TDep&amp;gt;(Action&amp;lt;TOptions, TDep&amp;gt; configureOptions) &lt;span&gt;where&lt;/span&gt; TDep : &lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; OptionsBuilder&amp;lt;TOptions&amp;gt; Configure&amp;lt;TDep1, TDep2&amp;gt;(Action&amp;lt;TOptions, TDep1, TDep2&amp;gt; configureOptions) &lt;span&gt;where&lt;/span&gt; TDep1 : &lt;span&gt;class&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; TDep2 : &lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; OptionsBuilder&amp;lt;TOptions&amp;gt; Configure&amp;lt;TDep1, TDep2, TDep3&amp;gt;(Action&amp;lt;TOptions, TDep1, TDep2, TDep3&amp;gt; configureOptions) &lt;span&gt;where&lt;/span&gt; TDep1 : &lt;span&gt;class&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; TDep2 : &lt;span&gt;class&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; TDep3 : &lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; OptionsBuilder&amp;lt;TOptions&amp;gt; Configure&amp;lt;TDep1, TDep2, TDep3, TDep4&amp;gt;(Action&amp;lt;TOptions, TDep1, TDep2, TDep3, TDep4&amp;gt; configureOptions) &lt;span&gt;where&lt;/span&gt; TDep1 : &lt;span&gt;class&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; TDep2 : &lt;span&gt;class&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; TDep3 : &lt;span&gt;class&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; TDep4 : &lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; OptionsBuilder&amp;lt;TOptions&amp;gt; Configure&amp;lt;TDep1, TDep2, TDep3, TDep4, TDep5&amp;gt;(Action&amp;lt;TOptions, TDep1, TDep2, TDep3, TDep4, TDep5&amp;gt; configureOptions) &lt;span&gt;where&lt;/span&gt; TDep1 : &lt;span&gt;class&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; TDep2 : &lt;span&gt;class&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; TDep3 : &lt;span&gt;class&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; TDep4 : &lt;span&gt;class&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; TDep5 : &lt;span&gt;class&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; OptionsBuilder&amp;lt;TOptions&amp;gt; PostConfigure(Action&amp;lt;TOptions&amp;gt;&lt;span&gt; configureOptions);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; OptionsBuilder&amp;lt;TOptions&amp;gt; PostConfigure&amp;lt;TDep&amp;gt;(Action&amp;lt;TOptions, TDep&amp;gt; configureOptions) &lt;span&gt;where&lt;/span&gt; TDep : &lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; OptionsBuilder&amp;lt;TOptions&amp;gt; PostConfigure&amp;lt;TDep1, TDep2&amp;gt;(Action&amp;lt;TOptions, TDep1, TDep2&amp;gt; configureOptions) &lt;span&gt;where&lt;/span&gt; TDep1 : &lt;span&gt;class&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; TDep2 : &lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; OptionsBuilder&amp;lt;TOptions&amp;gt; PostConfigure&amp;lt;TDep1, TDep2, TDep3&amp;gt;(Action&amp;lt;TOptions, TDep1, TDep2, TDep3&amp;gt; configureOptions) &lt;span&gt;where&lt;/span&gt; TDep1 : &lt;span&gt;class&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; TDep2 : &lt;span&gt;class&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; TDep3 : &lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; OptionsBuilder&amp;lt;TOptions&amp;gt; PostConfigure&amp;lt;TDep1, TDep2, TDep3, TDep4&amp;gt;(Action&amp;lt;TOptions, TDep1, TDep2, TDep3, TDep4&amp;gt; configureOptions) &lt;span&gt;where&lt;/span&gt; TDep1 : &lt;span&gt;class&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; TDep2 : &lt;span&gt;class&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; TDep3 : &lt;span&gt;class&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; TDep4 : &lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; OptionsBuilder&amp;lt;TOptions&amp;gt; PostConfigure&amp;lt;TDep1, TDep2, TDep3, TDep4, TDep5&amp;gt;(Action&amp;lt;TOptions, TDep1, TDep2, TDep3, TDep4, TDep5&amp;gt; configureOptions) &lt;span&gt;where&lt;/span&gt; TDep1 : &lt;span&gt;class&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; TDep2 : &lt;span&gt;class&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; TDep3 : &lt;span&gt;class&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; TDep4 : &lt;span&gt;class&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; TDep5 : &lt;span&gt;class&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; OptionsBuilder&amp;lt;TOptions&amp;gt; Validate(Func&amp;lt;TOptions, &lt;span&gt;bool&lt;/span&gt;&amp;gt;&lt;span&gt; validation);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; OptionsBuilder&amp;lt;TOptions&amp;gt; Validate&amp;lt;TDep&amp;gt;(Func&amp;lt;TOptions, TDep, &lt;span&gt;bool&lt;/span&gt;&amp;gt;&lt;span&gt; validation);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; OptionsBuilder&amp;lt;TOptions&amp;gt; Validate&amp;lt;TDep1, TDep2&amp;gt;(Func&amp;lt;TOptions, TDep1, TDep2, &lt;span&gt;bool&lt;/span&gt;&amp;gt;&lt;span&gt; validation);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; OptionsBuilder&amp;lt;TOptions&amp;gt; Validate&amp;lt;TDep1, TDep2, TDep3&amp;gt;(Func&amp;lt;TOptions, TDep1, TDep2, TDep3, &lt;span&gt;bool&lt;/span&gt;&amp;gt;&lt;span&gt; validation);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; OptionsBuilder&amp;lt;TOptions&amp;gt; Validate&amp;lt;TDep1, TDep2, TDep3, TDep4&amp;gt;(Func&amp;lt;TOptions, TDep1, TDep2, TDep3, TDep4, &lt;span&gt;bool&lt;/span&gt;&amp;gt;&lt;span&gt; validation);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; OptionsBuilder&amp;lt;TOptions&amp;gt; Validate&amp;lt;TDep1, TDep2, TDep3, TDep4, TDep5&amp;gt;(Func&amp;lt;TOptions, TDep1, TDep2, TDep3, TDep4, TDep5, &lt;span&gt;bool&lt;/span&gt;&amp;gt;&lt;span&gt; validation);

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; OptionsBuilder&amp;lt;TOptions&amp;gt; Validate&amp;lt;TDep&amp;gt;(Func&amp;lt;TOptions, TDep, &lt;span&gt;bool&lt;/span&gt;&amp;gt; validation, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; failureMessage);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; OptionsBuilder&amp;lt;TOptions&amp;gt; Validate&amp;lt;TDep1, TDep2&amp;gt;(Func&amp;lt;TOptions, TDep1, TDep2, &lt;span&gt;bool&lt;/span&gt;&amp;gt; validation, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; failureMessage);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; OptionsBuilder&amp;lt;TOptions&amp;gt; Validate&amp;lt;TDep1, TDep2, TDep3&amp;gt;(Func&amp;lt;TOptions, TDep1, TDep2, TDep3, &lt;span&gt;bool&lt;/span&gt;&amp;gt; validation, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; failureMessage);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; OptionsBuilder&amp;lt;TOptions&amp;gt; Validate&amp;lt;TDep1, TDep2, TDep3, TDep4&amp;gt;(Func&amp;lt;TOptions, TDep1, TDep2, TDep3, TDep4, &lt;span&gt;bool&lt;/span&gt;&amp;gt; validation, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; failureMessage);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; OptionsBuilder&amp;lt;TOptions&amp;gt; Validate&amp;lt;TDep1, TDep2, TDep3, TDep4, TDep5&amp;gt;(Func&amp;lt;TOptions, TDep1, TDep2, TDep3, TDep4, TDep5, &lt;span&gt;bool&lt;/span&gt;&amp;gt; validation, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; failureMessage);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如下面的代码片段所示，OptionsBuilder&amp;lt;TOptions&amp;gt;对象不仅通过泛型参数关联对应的Options类型，还利用Name属性提供了Options的名称。从上面的代码片段可以看出，OptionsBuilder&amp;lt;TOptions&amp;gt;类型提供的3组方法分别提供了针对IConfigureOptions&amp;lt;TOptions&amp;gt;接口、IPostConfigureOptions&amp;lt;TOptions&amp;gt;接口和IValidateOptions&amp;lt;TOptions&amp;gt;接口的18个实现类型的注册。&lt;/p&gt;
&lt;p&gt;当利用Builder模式来注册这些服务的时候，只需要调用IServiceCollection接口的如下这两个AddOptions&amp;lt;TOptions&amp;gt;扩展方法根据指定的名称（默认名称为空字符串）创建出对应的OptionsBuilder&amp;lt;TOptions&amp;gt;对象即可。从如下所示的代码片段可以看出，这两个方法最终都需要调用非泛型的AddOptions方法，由于该方法调用TryAdd扩展方法注册Options模式的5个核心服务，所以不会导致服务的重复注册。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OptionsServiceCollectionExtensions
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; OptionsBuilder&amp;lt;TOptions&amp;gt; AddOptions&amp;lt;TOptions&amp;gt;( &lt;span&gt;this&lt;/span&gt; IServiceCollection services) &lt;span&gt;where&lt;/span&gt; TOptions : &lt;span&gt;class&lt;/span&gt; =&amp;gt; services.AddOptions&amp;lt;TOptions&amp;gt;&lt;span&gt;(Options.DefaultName);

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; OptionsBuilder&amp;lt;TOptions&amp;gt; AddOptions&amp;lt;TOptions&amp;gt;(&lt;span&gt;this&lt;/span&gt; IServiceCollection services, &lt;span&gt;string&lt;/span&gt; name) &lt;span&gt;where&lt;/span&gt; TOptions : &lt;span&gt;class&lt;/span&gt;&lt;span&gt;
    {
        services.AddOptions();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; OptionsBuilder&amp;lt;TOptions&amp;gt;&lt;span&gt;(services, name);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;通过对注册服务的分析可知，服务接口IOptions&amp;lt;TOptions&amp;gt;和IOptionsSnapshot&amp;lt;TOptions&amp;gt;的默认实现类型都是OptionsManager&amp;lt;TOptions&amp;gt;，两者的不同之处体现在生命周期上，前者采用的生命周期模式为Singleton，后者采用的生命周期模式则是Scoped。对于一个ASP.NET Core应用来说，Singleton和Scoped对应的是针对当前应用和当前请求的生命周期，所以通过IOptions&amp;lt;TOptions&amp;gt;接口获取的Options对象在整个应用的生命周期内都是一致的，而通过IOptionsSnapshot&amp;lt;TOptions&amp;gt;接口获取的Options对象则只能在当前请求上下文中保持一致。这也是后者命名的由来，它表示针对当前请求的Options&lt;a&gt;快照&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;下面通过一个实例来演示IOptions&amp;lt;TOptions&amp;gt;和IOptionsSnapshot&amp;lt;TOptions&amp;gt;之间的差异。下面定义了FoobarOptions类型，简单起见，我们仅仅为它定义了两个整型的属性（Foo和Bar），并重写了ToString方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FoobarOptions
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Foo { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Bar { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; } 
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; ToString() =&amp;gt; $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Foo:{Foo}, Bar:{Bar}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;整个演示程序体现在如下所示的代码片段中。我们创建了一个ServiceCollection对象，在调用AddOptions扩展方法注册Options模型的基础服务之后，调用Configure&amp;lt;FoobarOptions&amp;gt;方法利用定义的本地函数Print将FoobarOptions对象的Foo属性和Bar属性设置为一个随机数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; random = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Random();
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; serviceProvider = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServiceCollection()
            .AddOptions()
            .Configure&lt;/span&gt;&amp;lt;FoobarOptions&amp;gt;(foobar =&amp;gt;&lt;span&gt;
            {
                foobar.Foo &lt;/span&gt;= random.Next(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;&lt;span&gt;);
                foobar.Bar &lt;/span&gt;= random.Next(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;&lt;span&gt;);
            })
            .BuildServiceProvider();        

        Print(serviceProvider);
        Print(serviceProvider);

        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Print(IServiceProvider provider)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; scopedProvider =&lt;span&gt; provider
                .GetRequiredService&lt;/span&gt;&amp;lt;IServiceScopeFactory&amp;gt;&lt;span&gt;()
                .CreateScope()
                .ServiceProvider;

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; options =&lt;span&gt; scopedProvider
                .GetRequiredService&lt;/span&gt;&amp;lt;IOptions&amp;lt;FoobarOptions&amp;gt;&amp;gt;&lt;span&gt;()
                .Value;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; optionsSnapshot1 =&lt;span&gt; scopedProvider
                .GetRequiredService&lt;/span&gt;&amp;lt;IOptionsSnapshot&amp;lt;FoobarOptions&amp;gt;&amp;gt;&lt;span&gt;()
                .Value;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; optionsSnapshot2 =&lt;span&gt; scopedProvider
                .GetRequiredService&lt;/span&gt;&amp;lt;IOptionsSnapshot&amp;lt;FoobarOptions&amp;gt;&amp;gt;&lt;span&gt;()
                .Value;
            Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;options:{options}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;optionsSnapshot1:{optionsSnapshot1}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;optionsSnapshot2:{optionsSnapshot2}\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们并没有直接利用ServiceCollection对象创建的IServiceProvider对象来提供服务，而是利用它创建了一个代表子容器的IServiceProvider对象，该对象就相当于ASP.NET Core应用中针对当前请求创建的IServiceProvider对象（&lt;span&gt;RequestServices&lt;/span&gt;）。在利用这个IServiceProvider对象分别针对IOptions&amp;lt;TOptions&amp;gt;接口和IOptionsSnapshot&amp;lt;TOptions&amp;gt;接口得到对应的FoobarOptions对象之后，我们将配置选项输出到控制台上。上述操作先后执行了两次，相当于&lt;span&gt;ASP.NET Core应用分别处理了两次请求&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;下图展示了该演示程序执行后的输出结果，由此可知，只有从同一个IServiceProvider对象获取的IOptionsSnapshot&amp;lt;TOptions&amp;gt;服务才能提供一致的Options对象，但是对于所有源自同一个根的所有IServiceProvider对象来说，从中提取的IOptions&amp;lt;TOptions&amp;gt;服务都能提供一致的Options对象。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/202001/19327-20200116080922812-942582655.png&quot;&gt;&lt;img width=&quot;240&quot; height=&quot;146&quot; title=&quot;7-10&quot; alt=&quot;7-10&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/202001/19327-20200116080923532-2128584022.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;OptionsManager&amp;lt;Options&amp;gt;会利用一个自行创建的OptionsCache&amp;lt;TOptions&amp;gt;对象来缓存Options对象，也就说，OptionsManager&amp;lt;Options&amp;gt;提供的Options对象存放在其&lt;span&gt;私有缓存&lt;/span&gt;中。虽然OptionsCache&amp;lt;TOptions&amp;gt;提供了清除缓存的能力，但是OptionsManager&amp;lt;Options&amp;gt;自身无法感知原始Options数据是否发生变化，所以不会清除缓存的Options对象。&lt;/p&gt;
&lt;p&gt;这个特性决定了在一个ASP.NET Core应用中，&lt;span&gt;以IOptions&amp;lt;TOptions&amp;gt;服务的形式提供的Options在整个应用的生命周期内不会发生改变&lt;/span&gt;&lt;span&gt;，但是若使用IOptionsSnapshot&amp;lt;TOptions&amp;gt;服务，提供的Options对象只能在同一个请求上下文中提供一致的保障&lt;/span&gt;。如果希望即使在同一个请求处理周期内也能及时应用最新的Options属性，就只能使用&lt;span&gt;IOptionsMonitor&amp;lt;TOptions&amp;gt;&lt;/span&gt;服务来提供Options对象。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-06-01.html&quot;&gt;[ASP.NET Core 3框架揭秘] Options[1]: 配置选项的正确使用方式[上篇]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-06-02.html&quot;&gt;[ASP.NET Core 3框架揭秘] Options[2]: 配置选项的正确使用方式[下篇]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-06-03.html&quot;&gt;[ASP.NET Core 3框架揭秘] Options[3]: Options模型[上篇]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-06-04.html&quot;&gt;[ASP.NET Core 3框架揭秘] Options[4]: Options模型[下篇]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-06-05.html&quot;&gt;[ASP.NET Core 3框架揭秘] Options[5]: 依赖注入&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-06-06.html&quot;&gt;[ASP.NET Core 3框架揭秘] Options[6]: 扩展与定制&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-06-07.html&quot;&gt;[ASP.NET Core 3框架揭秘] Options[7]: 与配置系统的整合&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 16 Jan 2020 00:09:00 +0000</pubDate>
<dc:creator>Artech</dc:creator>
<og:description>《Options模型》介绍了组成Options模型的4个核心对象以及它们之间的交互关系，读者对如何得到Options对象的实现原理可能不太了解，本篇文章主要介绍依赖注入的相关内容。既然我们能够利用IS</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/artech/p/inside-asp-net-core-06-05.html</dc:identifier>
</item>
<item>
<title>算法浅谈——怎么样才最有可能选中真命天子呢？ - TechFlow2019</title>
<link>http://www.cnblogs.com/techflow/p/12199491.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/techflow/p/12199491.html</guid>
<description>&lt;p&gt;本文始发于个人公众号：&lt;strong&gt;TechFlow&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;正文开始之前，我们先来讲一个故事。&lt;/p&gt;
&lt;p&gt;在很久很久以前，有一个万人迷。&lt;/p&gt;
&lt;p&gt;她从18岁开始就有数不完的追求者，追她的男生一个个在她的窗前排起了长队。但是她挑来挑去，终究不觉得满意。终于，这个万人迷一天天长大，年老色衰，在她门口排队的男生也越来越少。&lt;/p&gt;
&lt;p&gt;她开始后悔拒绝男生时的轻率，怀念起了从前的荣光。她也不知道，最后她是会向现实妥协，选择一个看起来远不是那么好的男生共度一生，还是会就这么一直等下去。&lt;/p&gt;
&lt;p&gt;这样的故事其实并不罕见，知乎里关于剩男剩女以及婚嫁的问题屡见不鲜。选择配偶也是我们人生当中的必经之路，苏格拉底说过，&lt;strong&gt;人生就是一次无法重复的选择&lt;/strong&gt;，在婚姻这个问题上尤为明显。&lt;/p&gt;
&lt;p&gt;那么问题来了，如果我们是故事中的万人迷，我们应该如何选择配偶呢？&lt;/p&gt;
&lt;p&gt;即使是真的万人迷，她可以选择的&lt;strong&gt;配偶也一定是有限的&lt;/strong&gt;。我们可以做一个简单的量化，假设她一年平均有30个追求者，她打算28岁结婚。那么从她18岁开始算起，假设她的魅力保持不变，她一共可以遇到300个潜在的配偶。&lt;/p&gt;
&lt;p&gt;这个数字对于每个女生而言各有不同，但是它其实并不重要，并不会影响我们的计算过程。为了简化计算，我们就假设它为n。接着，我们再进一步简化模型，假设这n个男生排成一队，一个一个地来发起追求。我们假设女生面临每个追求者的时候只会有两个选择，&lt;strong&gt;一是直接拒绝，二是答应追求&lt;/strong&gt;，从此牵手共度一生。&lt;/p&gt;
&lt;p&gt;那么，我们来做一个好的决策呢？&lt;/p&gt;
&lt;p&gt;和现实中一样，一种比较聪明的做法是，&lt;strong&gt;先和前面的一些男生每个人都相处一段时间&lt;/strong&gt;，做一个了解，摸清这些男生大概的水平底细之后再认真考虑。抽象成数学模型来，就是女生会直接拒绝掉前面k个男生，从第k+1个男生开始一一和前面k个男生比对。当一个比前面k个男生都要好的男生出现的时候，她果断选择接受，从此和他共度一生。&lt;/p&gt;
&lt;p&gt;如此一来，这就成了一个数学问题，&lt;strong&gt;究竟这个k应该等于多少，才可以使得女生选中所有男生当中最好的那个的概率最大呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所以，我们应该怎么求出这个K呢？&lt;/p&gt;
&lt;p&gt;对于某个固定的K，我们假设最佳配偶出现在了第i的位置。想让他能被挑选中，必须要保证前面i-1个人中的最好的配偶出现在前K个人当中。也就是说如果真命天子前面没有出现另一个优质的男生，会导致女生在遇见真命天子前就草草选择。从这个问题上来说，真命天子也需要好的对手陪衬。&lt;/p&gt;
&lt;p&gt;这个概率不难计算，是：&lt;span class=&quot;math inline&quot;&gt;\(\frac{K}{i-1}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;那么，我们对所有的i进行加权求和即可：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(P(K)=\sum_{i=K+1}^n\frac{1}{n}\cdot \frac{K}{i-1}=\frac{K}{n}\sum_{i=K+1}^n\frac{1}{i-1}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们假设n是一个很大的值，我们可以先算后面的部分。如果n足够大，可以认为&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\sum_{i=K+1}^n\frac{1}{i-1}=\int_{K}^n\frac{1}{t}dt=ln(n)-ln(K)=ln(\frac{n}{K})\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们令&lt;span class=&quot;math inline&quot;&gt;\(x=\frac{K}{n}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;求积分，可以得到：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(P(K)=x(ln(\frac{n}{K}))=x(ln(\frac{1}{x}))=-x\cdot ln(x)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们对&lt;span class=&quot;math inline&quot;&gt;\(P(K)\)&lt;/span&gt;的求导，令它等于0，可以求出&lt;span class=&quot;math inline&quot;&gt;\(P(K)\)&lt;/span&gt;最大时&lt;span class=&quot;math inline&quot;&gt;\(x=\frac{1}{e}\)&lt;/span&gt;。这里的&lt;span class=&quot;math inline&quot;&gt;\(e\)&lt;/span&gt;就是数学当中经常出现的&lt;strong&gt;欧拉常数&lt;/strong&gt;，也叫自然底数，&lt;span class=&quot;math inline&quot;&gt;\(\frac{1}{e}\)&lt;/span&gt;约等于37%. 那么，算到了这个结果，这个问题也就有了答案。&lt;/p&gt;
&lt;p&gt;如果你是一个万人迷，那么你应该&lt;strong&gt;拒绝掉前面37%&lt;/strong&gt;的追求者，然后在剩下的63%的男士当中挑选一个比前面都强的作为配偶。那么你选到最佳配偶的概率达到最大值，它的概率为37%。&lt;/p&gt;
&lt;p&gt;虽然有了答案，但是我们并不知道这个答案对不对，但是没关系，我们是程序员，可以用代码来模拟。&lt;/p&gt;
&lt;p&gt;我们就按照万人迷的配置来设定好了，假设她一生当中会面临300个追求者。我们假设这三百个追求者的好坏层次不齐，按照分数排序，可以得到一个0到299的序号。排名越靠后，说明分数越大，男生越优质，然后我们再对这些男生进行乱序。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import random

def generateBoys():
    boys = [i for i in range(300)]
    random.shuffle(boys)
    return boys&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着我们来编写程序的主体，其实也很简单，我们模拟进行许多次同样的配偶选择，模拟出我们通过这种策略能够选中最佳配偶的概率，代码并不难写：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# iterations 是模拟择偶的次数
def simulation(iterations=10000):
    matched = 0
    for i in range(iterations):
        # 每次都创建新的追求者集合
        boys = generateBoys()
        # 最佳配偶的序号
        best = max(boys)
        maxi = 0
        partner = 0
        # 计算K， K=0.37 * 追求者总数
        pickedNum = int(0.37 * len(boys))
        for j in range(pickedNum):
            maxi = max(maxi, boys[j])
        # 一旦找到比前K个最好的都要好的，就结束
        for j in range(pickedNum, len(boys)):
            if boys[j] &amp;gt; maxi:
                partner = boys[j]
                break
        # 判断是否找到了最佳配偶
        if partner == best:
            matched += 1
    return matched / float(iterations)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后，我们运行代码，得出的答案是0.3629。当然这也不是一个精确值，也是一个会波动的&lt;strong&gt;估算结果&lt;/strong&gt;。迭代的次数越多，这个得到的结果越逼近真实值。&lt;strong&gt;用大量的实验去测算某个事件发生的概率&lt;/strong&gt;，这个也是统计学上常用的方法。&lt;/p&gt;
&lt;p&gt;通过建模，我们把一个抽象的，无从下手的问题，简化成了一个明确的数学问题。通过建立函数求最值的方法，求出了最优解。从结果上来看，如果真有一个姑娘能有这么多追求者，通过一种方法可以拥有37%的概率挑中她的真命天子，也算是非常棒了。&lt;/p&gt;
&lt;p&gt;但是数学模型的是理想的，现实和理想总是有些差别。现实中，我们的时间精力是有限的，我们不一定有时间来一一衡量前面追求者的优劣。而且追求者的&lt;strong&gt;分布也不一定是随机&lt;/strong&gt;的，很有可能随着我们自身的变化而变化。比如我们通过自己的努力，去往了更好的学校、公司，那么我们接触到的异性也会更好。&lt;/p&gt;
&lt;p&gt;不过尽管如此，这道算法问题对我们还是很有借鉴意义，希望能够给大家带来启发。&lt;/p&gt;
&lt;p&gt;今天的文章就到这里，希望大家有所收获。如果喜欢本文，请顺手点个&lt;strong&gt;关注&lt;/strong&gt;吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/1/16/16faba021b97325a?w=258&amp;amp;h=258&amp;amp;f=png&amp;amp;s=23988&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 16 Jan 2020 00:00:00 +0000</pubDate>
<dc:creator>TechFlow2019</dc:creator>
<og:description>本文始发于个人公众号： TechFlow 正文开始之前，我们先来讲一个故事。 在很久很久以前，有一个万人迷。 她从18岁开始就有数不完的追求者，追她的男生一个个在她的窗前排起了长队。但是她挑来挑去，终</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/techflow/p/12199491.html</dc:identifier>
</item>
<item>
<title>Go 每日一库之 go-ini - darjun</title>
<link>http://www.cnblogs.com/darjun/p/12199477.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/darjun/p/12199477.html</guid>
<description>&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;ini 是 Windows 上常用的配置文件格式。MySQL 的 Windows 版就是使用 ini 格式存储配置的。&lt;br/&gt;&lt;a href=&quot;https://github.com/go-ini/ini&quot;&gt;go-ini&lt;/a&gt;是 Go 语言中用于操作 ini 文件的第三方库。&lt;/p&gt;
&lt;p&gt;本文介绍&lt;code&gt;go-ini&lt;/code&gt;库的使用。&lt;/p&gt;
&lt;h2 id=&quot;快速使用&quot;&gt;快速使用&lt;/h2&gt;
&lt;p&gt;go-ini 是第三方库，使用前需要安装：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ go get gopkg.in/ini.v1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也可以使用 GitHub 上的仓库：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ go get github.com/go-ini/ini&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先，创建一个&lt;code&gt;my.ini&lt;/code&gt;配置文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;app_name = awesome web

# possible values: DEBUG, INFO, WARNING, ERROR, FATAL
log_level = DEBUG

[mysql]
ip = 127.0.0.1
port = 3306
user = dj
password = 123456
database = awesome

[redis]
ip = 127.0.0.1
port = 6381&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用 go-ini 库读取：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;package main

import (
  &quot;fmt&quot;
  &quot;log&quot;

  &quot;gopkg.in/ini.v1&quot;
)

func main() {
  cfg, err := ini.Load(&quot;my.ini&quot;)
  if err != nil {
    log.Fatal(&quot;Fail to read file: &quot;, err)
  }

  fmt.Println(&quot;App Name:&quot;, cfg.Section(&quot;&quot;).Key(&quot;app_name&quot;).String())
  fmt.Println(&quot;Log Level:&quot;, cfg.Section(&quot;&quot;).Key(&quot;log_level&quot;).String())

  fmt.Println(&quot;MySQL IP:&quot;, cfg.Section(&quot;mysql&quot;).Key(&quot;ip&quot;).String())
  mysqlPort, err := cfg.Section(&quot;mysql&quot;).Key(&quot;port&quot;).Int()
  if err != nil {
    log.Fatal(err)
  }
  fmt.Println(&quot;MySQL Port:&quot;, mysqlPort)
  fmt.Println(&quot;MySQL User:&quot;, cfg.Section(&quot;mysql&quot;).Key(&quot;user&quot;).String())
  fmt.Println(&quot;MySQL Password:&quot;, cfg.Section(&quot;mysql&quot;).Key(&quot;password&quot;).String())
  fmt.Println(&quot;MySQL Database:&quot;, cfg.Section(&quot;mysql&quot;).Key(&quot;database&quot;).String())

  fmt.Println(&quot;Redis IP:&quot;, cfg.Section(&quot;redis&quot;).Key(&quot;ip&quot;).String())
  redisPort, err := cfg.Section(&quot;redis&quot;).Key(&quot;port&quot;).Int()
  if err != nil {
    log.Fatal(err)
  }
  fmt.Println(&quot;Redis Port:&quot;, redisPort)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 ini 文件中，每个键值对占用一行，中间使用&lt;code&gt;=&lt;/code&gt;隔开。以&lt;code&gt;#&lt;/code&gt;开头的内容为注释。ini 文件是以分区（section）组织的。&lt;br/&gt;分区以&lt;code&gt;[name]&lt;/code&gt;开始，在下一个分区前结束。所有分区前的内容属于默认分区，如&lt;code&gt;my.ini&lt;/code&gt;文件中的&lt;code&gt;app_name&lt;/code&gt;和&lt;code&gt;log_level&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;go-ini&lt;/code&gt;读取配置文件的步骤如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先调用&lt;code&gt;ini.Load&lt;/code&gt;加载文件，得到配置对象&lt;code&gt;cfg&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;然后以分区名调用配置对象的&lt;code&gt;Section&lt;/code&gt;方法得到对应的分区对象&lt;code&gt;section&lt;/code&gt;，默认分区的名字为&lt;code&gt;&quot;&quot;&lt;/code&gt;，也可以使用&lt;code&gt;ini.DefaultSection&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;以键名调用分区对象的&lt;code&gt;Key&lt;/code&gt;方法得到对应的配置项&lt;code&gt;key&lt;/code&gt;对象；&lt;/li&gt;
&lt;li&gt;由于文件中读取出来的都是字符串，&lt;code&gt;key&lt;/code&gt;对象需根据类型调用对应的方法返回具体类型的值使用，如上面的&lt;code&gt;String&lt;/code&gt;、&lt;code&gt;MustInt&lt;/code&gt;方法。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;运行以下程序，得到输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;App Name: awesome web
Log Level: DEBUG
MySQL IP: 127.0.0.1
MySQL Port: 3306
MySQL User: dj
MySQL Password: 123456
MySQL Database: awesome
Redis IP: 127.0.0.1
Redis Port: 6381&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置文件中存储的都是字符串，所以类型为字符串的配置项不会出现类型转换失败的，故&lt;code&gt;String()&lt;/code&gt;方法只返回一个值。&lt;br/&gt;但如果类型为&lt;code&gt;Int/Uint/Float64&lt;/code&gt;这些时，转换可能失败。所以&lt;code&gt;Int()/Uint()/Float64()&lt;/code&gt;返回一个值和一个错误。&lt;/p&gt;
&lt;p&gt;要留意这种不一致！如果我们将配置中 redis 端口改成非法的数字 x6381，那么运行程序将报错：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;2020/01/14 22:43:13 strconv.ParseInt: parsing &quot;x6381&quot;: invalid syntax&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;must便捷方法&quot;&gt;&lt;code&gt;Must*&lt;/code&gt;便捷方法&lt;/h2&gt;
&lt;p&gt;如果每次取值都需要进行错误判断，那么代码写起来会非常繁琐。为此，&lt;code&gt;go-ini&lt;/code&gt;也提供对应的&lt;code&gt;MustType&lt;/code&gt;（Type 为&lt;code&gt;Init/Uint/Float64&lt;/code&gt;等）方法，这个方法只返回一个值。&lt;br/&gt;同时它接受可变参数，如果类型无法转换，取参数中第一个值返回，并且该参数设置为这个配置的值，下次调用返回这个值：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;package main

import (
  &quot;fmt&quot;
  &quot;log&quot;

  &quot;gopkg.in/ini.v1&quot;
)

func main() {
  cfg, err := ini.Load(&quot;my.ini&quot;)
  if err != nil {
    log.Fatal(&quot;Fail to read file: &quot;, err)
  }

  redisPort, err := cfg.Section(&quot;redis&quot;).Key(&quot;port&quot;).Int()
  if err != nil {
    fmt.Println(&quot;before must, get redis port error:&quot;, err)
  } else {
    fmt.Println(&quot;before must, get redis port:&quot;, redisPort)
  }

  fmt.Println(&quot;redis Port:&quot;, cfg.Section(&quot;redis&quot;).Key(&quot;port&quot;).MustInt(6381))

  redisPort, err = cfg.Section(&quot;redis&quot;).Key(&quot;port&quot;).Int()
  if err != nil {
    fmt.Println(&quot;after must, get redis port error:&quot;, err)
  } else {
    fmt.Println(&quot;after must, get redis port:&quot;, redisPort)
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置文件还是 redis 端口为非数字 x6381 时的状态，运行程序：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;before must, get redis port error: strconv.ParseInt: parsing &quot;x6381&quot;: invalid syntax
redis Port: 6381
after must, get redis port: 6381&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们看到第一次调用&lt;code&gt;Int&lt;/code&gt;返回错误，以 6381 为参数调用&lt;code&gt;MustInt&lt;/code&gt;之后，再次调用&lt;code&gt;Int&lt;/code&gt;，成功返回 6381。&lt;code&gt;MustInt&lt;/code&gt;源码也比较简单：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;// gopkg.in/ini.v1/key.go
func (k *Key) MustInt(defaultVal ...int) int {
  val, err := k.Int()
  if len(defaultVal) &amp;gt; 0 &amp;amp;&amp;amp; err != nil {
    k.value = strconv.FormatInt(int64(defaultVal[0]), 10)
    return defaultVal[0]
  }
  return val
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;分区操作&quot;&gt;分区操作&lt;/h2&gt;
&lt;h3 id=&quot;获取信息&quot;&gt;获取信息&lt;/h3&gt;
&lt;p&gt;在加载配置之后，可以通过&lt;code&gt;Sections&lt;/code&gt;方法获取所有分区，&lt;code&gt;SectionStrings()&lt;/code&gt;方法获取所有分区名。&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;sections := cfg.Sections()
names := cfg.SectionStrings()

fmt.Println(&quot;sections: &quot;, sections)
fmt.Println(&quot;names: &quot;, names)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行输出 3 个分区：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[DEFAULT mysql redis]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用&lt;code&gt;Section(name)&lt;/code&gt;获取名为&lt;code&gt;name&lt;/code&gt;的分区，如果该分区不存在，则自动创建一个分区返回：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;newSection := cfg.Section(&quot;new&quot;)

fmt.Println(&quot;new section: &quot;, newSection)
fmt.Println(&quot;names: &quot;, cfg.SectionStrings())&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建之后调用&lt;code&gt;SectionStrings&lt;/code&gt;方法，新分区也会返回：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;names:  [DEFAULT mysql redis new]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也可以手动创建一个新分区，如果分区已存在，则返回错误：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;err := cfg.NewSection(&quot;new&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;父子分区&quot;&gt;父子分区&lt;/h3&gt;
&lt;p&gt;在配置文件中，可以使用占位符&lt;code&gt;%(name)s&lt;/code&gt;表示用之前已定义的键&lt;code&gt;name&lt;/code&gt;的值来替换，这里的&lt;code&gt;s&lt;/code&gt;表示值为字符串类型：&lt;/p&gt;
&lt;pre class=&quot;parent_child.ini&quot;&gt;
&lt;code&gt;NAME = ini
VERSION = v1
IMPORT_PATH = gopkg.in/%(NAME)s.%(VERSION)s

[package]
CLONE_URL = https://%(IMPORT_PATH)s

[package.sub]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面在默认分区中设置&lt;code&gt;IMPORT_PATH&lt;/code&gt;的值时，使用了前面定义的&lt;code&gt;NAME&lt;/code&gt;和&lt;code&gt;VERSION&lt;/code&gt;。&lt;br/&gt;在&lt;code&gt;package&lt;/code&gt;分区中设置&lt;code&gt;CLONE_URL&lt;/code&gt;的值时，使用了默认分区中定义的&lt;code&gt;IMPORT_PATH&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;我们还可以在分区名中使用&lt;code&gt;.&lt;/code&gt;表示两个或多个分区之间的父子关系，例如&lt;code&gt;package.sub&lt;/code&gt;的父分区为&lt;code&gt;package&lt;/code&gt;，&lt;code&gt;package&lt;/code&gt;的父分区为默认分区。&lt;br/&gt;如果某个键在子分区中不存在，则会在它的父分区中再次查找，直到没有父分区为止：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;cfg, err := ini.Load(&quot;parent_child.ini&quot;)
if err != nil {
  fmt.Println(&quot;Fail to read file: &quot;, err)
  return
}

fmt.Println(&quot;Clone url from package.sub:&quot;, cfg.Section(&quot;package.sub&quot;).Key(&quot;CLONE_URL&quot;).String())&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行程序输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Clone url from package.sub: https://gopkg.in/ini.v1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;子分区中&lt;code&gt;package.sub&lt;/code&gt;中没有键&lt;code&gt;CLONE_URL&lt;/code&gt;，返回了父分区&lt;code&gt;package&lt;/code&gt;中的值。&lt;/p&gt;
&lt;h2 id=&quot;保存配置&quot;&gt;保存配置&lt;/h2&gt;
&lt;p&gt;有时候，我们需要将生成的配置写到文件中。例如在写工具的时候。保存有两种类型的接口，一种直接保存到文件，另一种写入到&lt;code&gt;io.Writer&lt;/code&gt;中：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;err = cfg.SaveTo(&quot;my.ini&quot;)
err = cfg.SaveToIndent(&quot;my.ini&quot;, &quot;\t&quot;)

cfg.WriteTo(writer)
cfg.WriteToIndent(writer, &quot;\t&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面我们通过程序生成前面使用的配置文件&lt;code&gt;my.ini&lt;/code&gt;并保存：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;package main

import (
  &quot;fmt&quot;
  &quot;os&quot;

  &quot;gopkg.in/ini.v1&quot;
)

func main() {
  cfg := ini.Empty()

  defaultSection := cfg.Section(&quot;&quot;)
  defaultSection.NewKey(&quot;app_name&quot;, &quot;awesome web&quot;)
  defaultSection.NewKey(&quot;log_level&quot;, &quot;DEBUG&quot;)

  mysqlSection, err := cfg.NewSection(&quot;mysql&quot;)
  if err != nil {
    fmt.Println(&quot;new mysql section failed:&quot;, err)
    return
  }
  mysqlSection.NewKey(&quot;ip&quot;, &quot;127.0.0.1&quot;)
  mysqlSection.NewKey(&quot;port&quot;, &quot;3306&quot;)
  mysqlSection.NewKey(&quot;user&quot;, &quot;root&quot;)
  mysqlSection.NewKey(&quot;password&quot;, &quot;123456&quot;)
  mysqlSection.NewKey(&quot;database&quot;, &quot;awesome&quot;)

  redisSection, err := cfg.NewSection(&quot;redis&quot;)
  if err != nil {
    fmt.Println(&quot;new redis section failed:&quot;, err)
    return
  }
  redisSection.NewKey(&quot;ip&quot;, &quot;127.0.0.1&quot;)
  redisSection.NewKey(&quot;port&quot;, &quot;6381&quot;)

  err = cfg.SaveTo(&quot;my.ini&quot;)
  if err != nil {
    fmt.Println(&quot;SaveTo failed: &quot;, err)
  }

  err = cfg.SaveToIndent(&quot;my-pretty.ini&quot;, &quot;\t&quot;)
  if err != nil {
    fmt.Println(&quot;SaveToIndent failed: &quot;, err)
  }

  cfg.WriteTo(os.Stdout)
  fmt.Println()
  cfg.WriteToIndent(os.Stdout, &quot;\t&quot;)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行程序，生成两个文件&lt;code&gt;my.ini&lt;/code&gt;和&lt;code&gt;my-pretty.ini&lt;/code&gt;，同时控制台输出文件内容。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;my.ini&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;app_name  = awesome web
log_level = DEBUG

[mysql]
ip       = 127.0.0.1
port     = 3306
user     = root
password = 123456
database = awesome

[redis]
ip   = 127.0.0.1
port = 6381&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;my-pretty.ini&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;app_name  = awesome web
log_level = DEBUG

[mysql]
    ip       = 127.0.0.1
    port     = 3306
    user     = root
    password = 123456
    database = awesome

[redis]
    ip   = 127.0.0.1
    port = 6381&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;*Indent&lt;/code&gt;方法会对子分区下的键增加缩进，看起来美观一点。&lt;/p&gt;
&lt;h2 id=&quot;分区与结构体字段映射&quot;&gt;分区与结构体字段映射&lt;/h2&gt;
&lt;p&gt;定义结构变量，加载完配置文件后，调用&lt;code&gt;MapTo&lt;/code&gt;将配置项赋值到结构变量的对应字段中。&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;package main

import (
  &quot;fmt&quot;

  &quot;gopkg.in/ini.v1&quot;
)

type Config struct {
  AppName   string `ini:&quot;app_name&quot;`
  LogLevel  string `ini:&quot;log_level&quot;`

  MySQL     MySQLConfig `ini:&quot;mysql&quot;`
  Redis     RedisConfig `ini:&quot;redis&quot;`
}

type MySQLConfig struct {
  IP        string `ini:&quot;ip&quot;`
  Port      int `ini:&quot;port&quot;`
  User      string `ini:&quot;user&quot;`
  Password  string `ini:&quot;password&quot;`
  Database  string `ini:&quot;database&quot;`
}

type RedisConfig struct {
  IP      string `ini:&quot;ip&quot;`
  Port    int `ini:&quot;port&quot;`
}

func main() {
  cfg, err := ini.Load(&quot;my.ini&quot;)
  if err != nil {
    fmt.Println(&quot;load my.ini failed: &quot;, err)
  }

  c := Config{}
  cfg.MapTo(&amp;amp;c)

  fmt.Println(c)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;MapTo&lt;/code&gt;内部使用了反射，&lt;strong&gt;所以结构体字段必须都是导出的&lt;/strong&gt;。如果键名与字段名不相同，那么需要在结构标签中指定对应的键名。&lt;br/&gt;这一点与 Go 标准库&lt;code&gt;encoding/json&lt;/code&gt;和&lt;code&gt;encoding/xml&lt;/code&gt;不同。标准库&lt;code&gt;json/xml&lt;/code&gt;解析时可以将键名&lt;code&gt;app_name&lt;/code&gt;对应到字段名&lt;code&gt;AppName&lt;/code&gt;。&lt;br/&gt;或许这是&lt;code&gt;go-ini&lt;/code&gt;库可以优化的点？&lt;/p&gt;
&lt;p&gt;先加载，再映射有点繁琐，直接使用&lt;code&gt;ini.MapTo&lt;/code&gt;将两步合并：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;err = ini.MapTo(&amp;amp;c, &quot;my.ini&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也可以只映射一个分区：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;mysqlCfg := MySQLConfig{}
err = cfg.Section(&quot;mysql&quot;).MapTo(&amp;amp;mysqlCfg)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还可以通过结构体生成配置：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;cfg := ini.Empty()

c := Config {
  AppName:  &quot;awesome web&quot;,
  LogLevel:     &quot;DEBUG&quot;,
  MySQL: MySQLConfig {
    IP:     &quot;127.0.0.1&quot;,
    Port:   3306,
    User:   &quot;root&quot;,
    Password:&quot;123456&quot;,
    Database:&quot;awesome&quot;,
  },
  Redis: RedisConfig {
    IP:     &quot;127.0.0.1&quot;,
    Port:   6381,
  },
}

err := ini.ReflectFrom(cfg, &amp;amp;c)
if err != nil {
  fmt.Println(&quot;ReflectFrom failed: &quot;, err)
  return
}

err = cfg.SaveTo(&quot;my-copy.ini&quot;)
if err != nil {
  fmt.Println(&quot;SaveTo failed: &quot;, err)
  return
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;本文介绍了&lt;code&gt;go-ini&lt;/code&gt;库的基本用法和一些有趣的特性。示例代码已上传&lt;a href=&quot;https://github.com/darjun/go-daily-lib/tree/master/go-ini&quot;&gt;GitHub&lt;/a&gt;。&lt;br/&gt;其实&lt;code&gt;go-ini&lt;/code&gt;还有很多高级特性。&lt;a href=&quot;https://ini.unknwon.io/&quot;&gt;官方文档&lt;/a&gt;非常详细，推荐去看，而且有中文哟~&lt;br/&gt;作者&lt;a href=&quot;https://github.com/unknwon&quot;&gt;无闻&lt;/a&gt;，相信做 Go 开发的都不陌生。&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/go-ini/ini&quot;&gt;go-ini&lt;/a&gt; GitHub 仓库&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://ini.unknwon.io/&quot;&gt;go-ini&lt;/a&gt; 官方文档&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;我&quot;&gt;我&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://darjun.github.io&quot;&gt;我的博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎关注我的微信公众号【GoUpUp】，共同学习，一起进步~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1919725/202001/1919725-20200116065949924-216879341.jpg&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;4.1509433962264&quot;&gt;
&lt;p&gt;本文由博客一文多发平台 &lt;a href=&quot;https://openwrite.cn?from=article_bottom&quot;&gt;OpenWrite&lt;/a&gt; 发布！&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 15 Jan 2020 23:00:00 +0000</pubDate>
<dc:creator>darjun</dc:creator>
<og:description>简介 ini 是 Windows 上常用的配置文件格式。MySQL 的 Windows 版就是使用 ini 格式存储配置的。 &amp;quot;go ini&amp;quot; 是 Go 语言中用于操作 ini 文</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/darjun/p/12199477.html</dc:identifier>
</item>
<item>
<title>玩玩24点（中） - jerry_fuyi</title>
<link>http://www.cnblogs.com/jerry-fuyi/p/12194569.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jerry-fuyi/p/12194569.html</guid>
<description>&lt;p&gt;《玩玩24点》系列：&lt;/p&gt;
&lt;h3 id=&quot;序&quot;&gt;序&lt;/h3&gt;
&lt;p&gt;在上篇中，我用上位机程序遍历了4个1~13的数的1820种组合，通过递归穷举计算出其中1362组的24点接法，并转换为二进制形式，放到单片机程序中，减少了单片机24点游戏程序的计算量，获得了不错的游戏体验。&lt;/p&gt;
&lt;p&gt;上篇的最后留了一个疯狂暗示，但时至如今我也没有实现出来，因为写完上篇过后一直在准备各种比赛和考试，这两天也在写AVR单片机教程，一直都没有空去管它。&lt;/p&gt;
&lt;p&gt;写这篇中篇的原因，是几个没有作业写甚至不需要高考的同学在玩一种24点游戏的升级版——用计算器按出5个1~20的随机整数，通过四则运算获得不超过50的最大有理数。经过一整个晚自修的手算后，他们想起我之前写的24点，来问我他们算出的是不是上界。&lt;/p&gt;
&lt;p&gt;我写算法注重可复用性，毕竟不是&lt;code&gt;std::&lt;/code&gt;都不写的OI。于是我很快就在上次程序的基础上写成了他们要的算法。&lt;/p&gt;
&lt;p&gt;这个程序，以及人机计算能力的对比，虽然毫无悬念，但是先放一边。我对上篇所写的内容有一些更深的思考。&lt;/p&gt;
&lt;h3 id=&quot;算式的可读性&quot;&gt;算式的可读性&lt;/h3&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;实际上这个24点程序还远不完美。单片机经常在屏幕上输出诡异的解法，比如&lt;code&gt;10 * 12 = 120, 120 / 5 = 24&lt;/code&gt;，这些是不符合人类计算逻辑的，正常人想到的都是&lt;code&gt;10 / 5 = 2, 2 * 12 = 24&lt;/code&gt;。一个可行的方法是把递归搜索的顺序换一下，先减再加，先除后乘，在除法中优先用最大的数除以最小的数。但还是会出现&lt;code&gt;12 / 5 = 12/5, 12/5 * 10 = 24&lt;/code&gt;这样的式子，最根本的算法还是根据表达式建立树，在树上调整顺序。也许4个数算24点的情况不需要这么复杂，但这是万能的、具有可扩展性的做法（也有可能是我想多了）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是上篇中提出的问题与解决方案，现在我认为需要修改。&lt;/p&gt;
&lt;p&gt;首先，对于&lt;code&gt;5, 10, 12&lt;/code&gt;的例子，我已经找到简单方法来使程序输出符合人类逻辑的算式了：搜索顺序改为减法、加法、结果为整数的除法、乘法、结果为分数的除法（代码可以在后面的程序中找到，这里就不单独放了）。在更新算法后我试玩了几十组，发现程序给出的结果都是比较正常的，因此这个问题至少在4数24点的问题中算是解决了。&lt;/p&gt;
&lt;p&gt;其次，作为看似更好的算法，即使我能克服学数据结构时对树的恐惧，成功地用二叉树表达了算式，“在树上调整顺序”的概念也是模糊的。用什么规则来调整呢？如果是整数优先，那么&lt;code&gt;10 / 5&lt;/code&gt;可以保证，但是在新的游戏规则中，如果运算数是&lt;code&gt;2, 3, 33&lt;/code&gt;，最优结果是&lt;code&gt;99/2&lt;/code&gt;，程序会先计算&lt;code&gt;33 * 3&lt;/code&gt;，再计算&lt;code&gt;99 / 2&lt;/code&gt;，而我的思路会是&lt;code&gt;33 * 1.5&lt;/code&gt;。那么这算什么规则呢？其他的情况呢？理不清。&lt;/p&gt;
&lt;p&gt;所以，调整一下搜索顺序，见好就收吧。&lt;/p&gt;
&lt;h3 id=&quot;数24点的优化&quot;&gt;4数24点的优化&lt;/h3&gt;
&lt;p&gt;一位对计算机程序一无所知的数学竞赛同学对求解24点的算法十分感兴趣。在我绞尽脑汁跟他解释通这个程序后，他认为这个算法不好，因为有大量的重复计算。&lt;/p&gt;
&lt;p&gt;有道理。比方说&lt;code&gt;1, 2, 3&lt;/code&gt;，原来的算法会先算&lt;code&gt;1 + 2&lt;/code&gt;，替换为&lt;code&gt;3&lt;/code&gt;，用&lt;code&gt;3, 3&lt;/code&gt;递归调用，得到&lt;code&gt;6&lt;/code&gt;，这是&lt;code&gt;1 + 2 + 3&lt;/code&gt;，然后还有&lt;code&gt;1 + 3 + 2&lt;/code&gt;和&lt;code&gt;2 + 3 + 1&lt;/code&gt;；&lt;code&gt;1, 2, 3, 4&lt;/code&gt;就更多了。&lt;/p&gt;
&lt;p&gt;他提出“分治”的策略：&lt;code&gt;24&lt;/code&gt;一定是由两个中间结果加减乘除得到的，而每个中间结果也都是由两个运算数得到的。在为他凭空想出分治而震惊之余，我指出这是错的，这很显然。&lt;/p&gt;
&lt;p&gt;但这个想法还是有一定启发性的。为了优化4数24点的求解算法，我想还不如枚举出所有可能的运算结构算了：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;
&lt;p&gt;&lt;code&gt;a * b * c * d&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;a + b + c + d&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;a * b + c + d&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;a * b * (c + d)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;a * b * c + d&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;a * (b + c + d)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;a * b + c * d&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;(a + b) * (c + d)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;(a * b + c) * d&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;(a + b) * c + d&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;其中&lt;code&gt;+&lt;/code&gt;代表加或减，&lt;code&gt;*&lt;/code&gt;代表乘或除。偶数序号的结构都是前一个奇数序号结构的对偶，指把加减与乘除互换，加括号保证原有的优先级。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;inline bool read_bit(int c, int b)
{
    return c &amp;amp; (1 &amp;lt;&amp;lt; b);
}

class fast_vector
{
public:
    void push_back(const Rational&amp;amp; r)
    {
        data[size++] = r;
    }
    Rational* begin()
    {
        return data;
    }
    Rational* end()
    {
        return data + size;
    }
private:
    Rational data[1 &amp;lt;&amp;lt; max_count];
    int size = 0;
};

using vector_type = fast_vector;

void all_sum(const std::vector&amp;lt;Rational&amp;gt;&amp;amp; data, vector_type&amp;amp; result)
{
    auto end = (1 &amp;lt;&amp;lt; data.size()) - 1;
    for (int c = 0; c != end; ++c)
    {
        Rational sum = 0;
        bool valid = true;
        for (int b = 0; b != data.size(); ++b)
            if (!read_bit(c, b))
                sum += data[b];
        for (int b = 0; b != data.size(); ++b)
            if (read_bit(c, b))
            {
                if (sum &amp;lt; data[b])
                {
                    valid = false;
                    break;
                }
                sum -= data[b];
            }
        if (valid)
            result.push_back(sum);
    }
}

void all_pro(const std::vector&amp;lt;Rational&amp;gt;&amp;amp; data, vector_type&amp;amp; result)
{
    auto end = (1 &amp;lt;&amp;lt; data.size()) - 1;
    for (int c = 0; c != end; ++c)
    {
        Rational pro = 1;
        bool valid = true;
        for (int b = 0; b != data.size(); ++b)
        {
            if (read_bit(c, b))
            {
                if (data[b] == 0)
                {
                    valid = false;
                    break;
                }
                pro /= data[b];
            }
            else
                pro *= data[b];
        }
        if (valid)
            result.push_back(pro);
    }
}

bool test_sum(const Rational&amp;amp; lhs, const Rational&amp;amp; rhs)
{
    if (lhs + rhs == target)
        return true;
    if (lhs &amp;lt; rhs &amp;amp;&amp;amp; rhs - lhs == target)
        return true;
    if (rhs &amp;lt; lhs &amp;amp;&amp;amp; lhs - rhs == target)
        return true;
    return false;
}

bool test_pro(const Rational&amp;amp; lhs, const Rational&amp;amp; rhs)
{
    if (lhs * rhs == target)
        return true;
    if (rhs != 0 &amp;amp;&amp;amp; rhs / lhs == target)
        return true;
    if (lhs != 0 &amp;amp;&amp;amp; lhs / rhs == target)
        return true;
    return false;
}

bool solve(int a, int b, int c, int d)
{
    std::vector&amp;lt;Rational&amp;gt; data(4);
    data[0] = a;
    data[1] = b;
    data[2] = c;
    data[3] = d;

    // a * b * c * d
    {
        vector_type pro;
        all_pro(data, pro);
        for (const auto&amp;amp; r : pro)
            if (r == target)
                return true;
    }

    // a + b + c + d
    {
        vector_type sum;
        all_sum(data, sum);
        for (const auto&amp;amp; r : sum)
            if (r == target)
                return true;
    }

    // a * b + c + d
    for (int i = 0; i != 3; ++i)
        for (int j = i + 1; j != 4; ++j)
        {
            auto pm = data;
            pm.erase(pm.begin() + j);
            pm.erase(pm.begin() + i);
            std::vector&amp;lt;Rational&amp;gt; md{ data[i], data[j] };
            vector_type pro;
            all_pro(md, pro);
            for (const auto&amp;amp; r : pro)
            {
                pm.push_back(r);
                vector_type sum;
                all_sum(pm, sum);
                for (const auto&amp;amp; r : sum)
                    if (r == target)
                        return true;
                pm.pop_back();
            }
        }

    // a * b * (c + d)
    for (int i = 0; i != 3; ++i)
        for (int j = i + 1; j != 4; ++j)
        {
            auto md = data;
            md.erase(md.begin() + j);
            md.erase(md.begin() + i);
            std::vector&amp;lt;Rational&amp;gt; pm{ data[i], data[j] };
            vector_type sum;
            all_sum(pm, sum);
            for (const auto&amp;amp; r : sum)
            {
                md.push_back(r);
                vector_type pro;
                all_pro(md, pro);
                for (const auto&amp;amp; r : pro)
                    if (r == target)
                        return true;
                md.pop_back();
            }
        }

    // a * b * c + d
    for (int i = 0; i != 4; ++i)
    {
        auto md = data;
        md.erase(md.begin() + i);
        vector_type pro;
        all_pro(md, pro);
        for (const auto&amp;amp; r : pro)
            if (test_sum(data[i], r))
                return true;
    }

    // a * (b + c + d)
    for (int i = 0; i != 4; ++i)
    {
        auto pm = data;
        pm.erase(pm.begin() + i);
        vector_type sum;
        all_sum(pm, sum);
        for (const auto&amp;amp; r : sum)
            if (test_pro(data[i], r))
                return true;
    }

    // a * b + c * d
    for (int i = 0; i != 3; ++i)
        for (int j = i + 1; j != 4; ++j)
        {
            auto md2 = data;
            md2.erase(md2.begin() + j);
            md2.erase(md2.begin() + i);
            decltype(md2) md1{ data[i], data[j] };
            vector_type pro1, pro2;
            all_pro(md1, pro1);
            all_pro(md2, pro2);
            for (const auto&amp;amp; r1 : pro1)
                for (const auto&amp;amp; r2 : pro2)
                    if (test_sum(r1, r2))
                        return true;
        }

    // (a + b) * (c + d)
    for (int i = 0; i != 3; ++i)
        for (int j = i + 1; j != 4; ++j)
        {
            auto pm2 = data;
            pm2.erase(pm2.begin() + j);
            pm2.erase(pm2.begin() + i);
            decltype(pm2) pm1{ data[i], data[j] };
            vector_type sum1, sum2;
            all_sum(pm1, sum1);
            all_sum(pm2, sum2);
            for (const auto&amp;amp; r1 : sum1)
                for (const auto&amp;amp; r2 : sum2)
                    if (test_pro(r1, r2))
                        return true;
        }

    // (a * b + c) * d
    for (int i = 0; i != 3; ++i)
        for (int j = i + 1; j != 4; ++j)
        {
            auto rest = data;
            rest.erase(rest.begin() + j);
            rest.erase(rest.begin() + i);
            std::vector&amp;lt;Rational&amp;gt; md{ data[i], data[j] };
            vector_type pro;
            all_pro(md, pro);
            for (const auto&amp;amp; r : pro)
            {
                for (int k = 0; k != 2; ++k)
                {
                    std::vector&amp;lt;Rational&amp;gt; pm{ r, rest[k] };
                    vector_type sum;
                    all_sum(pm, sum);
                    for (const auto&amp;amp; r : sum)
                        if (test_pro(r, rest[1 - k]))
                            return true;
                }
            }
        }

    // (a + b) * c + d
    for (int i = 0; i != 3; ++i)
        for (int j = i + 1; j != 4; ++j)
        {
            auto rest = data;
            rest.erase(rest.begin() + j);
            rest.erase(rest.begin() + i);
            std::vector&amp;lt;Rational&amp;gt; pm{ data[i], data[j] };
            vector_type sum;
            all_sum(pm, sum);
            for (const auto&amp;amp; r : sum)
            {
                for (int k = 0; k != 2; ++k)
                {
                    std::vector&amp;lt;Rational&amp;gt; md{ r, rest[k] };
                    vector_type pro;
                    all_pro(md, pro);
                    for (const auto&amp;amp; r : pro)
                        if (test_sum(r, rest[1 - k]))
                            return true;
                }
            }
        }

    return false;
}

int main()
{
    auto start_time = std::clock();
    int count = 0;
    for (int a = 1; a &amp;lt;= max_num; ++a)
        for (int b = a; b &amp;lt;= max_num; ++b)
            for (int c = b; c &amp;lt;= max_num; ++c)
                for (int d = c; d &amp;lt;= max_num; ++d)
                    if (solve(a, b, c, d))
                        ++count;
    std::cout &amp;lt;&amp;lt; count &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; (static_cast&amp;lt;double&amp;gt;(std::clock()) - start_time) * 1000
        / CLOCKS_PER_SEC &amp;lt;&amp;lt; &quot;ms&quot; &amp;lt;&amp;lt; std::endl;
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Integer&lt;/code&gt;为&lt;code&gt;int&lt;/code&gt;，&lt;code&gt;Rational&lt;/code&gt;和&lt;code&gt;Expression&lt;/code&gt;的定义见上篇。&lt;/p&gt;
&lt;p&gt;原算法没有使用&lt;code&gt;std::vector&lt;/code&gt;数据结构，由于STL的糟糕性能，我写了个不涉及动态内存分配的&lt;code&gt;fast_vector&lt;/code&gt;来替换存储运算结果的&lt;code&gt;std::vector&lt;/code&gt;；运算数的懒得改了。&lt;/p&gt;
&lt;p&gt;算法的核心在于&lt;code&gt;all_sum&lt;/code&gt;函数，用于求出&lt;code&gt;data&lt;/code&gt;数组中的元素通过加减法可以得到的所有结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void all_sum(const std::vector&amp;lt;Rational&amp;gt;&amp;amp; data, vector_type&amp;amp; result)
{
    auto end = (1 &amp;lt;&amp;lt; data.size()) - 1;
    for (int c = 0; c != end; ++c)
    {
        Rational sum = 0;
        bool valid = true;
        for (int b = 0; b != data.size(); ++b)
            if (!read_bit(c, b))
                sum += data[b];
        for (int b = 0; b != data.size(); ++b)
            if (read_bit(c, b))
            {
                if (sum &amp;lt; data[b])
                {
                    valid = false;
                    break;
                }
                sum -= data[b];
            }
        if (valid)
            result.push_back(sum);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;函数用一个整数&lt;code&gt;c&lt;/code&gt;表示&lt;code&gt;data&lt;/code&gt;数组中各元素取加号还是减号，当二进制&lt;code&gt;c&lt;/code&gt;的第&lt;code&gt;b&lt;/code&gt;位为&lt;code&gt;0&lt;/code&gt;时（最低位为第&lt;code&gt;0&lt;/code&gt;位），下标为&lt;code&gt;b&lt;/code&gt;的元素取加号，否则取减号；&lt;code&gt;c&lt;/code&gt;取不到&lt;code&gt;0b11...1&lt;/code&gt;（&lt;code&gt;data.size()&lt;/code&gt;个&lt;code&gt;1&lt;/code&gt;），是因为不能所有元素都取减号。对于每个&lt;code&gt;c&lt;/code&gt;，如果算出来的值是有效的，就把它追加到结果的数组中去。我把返回值写成了引用参数，虽然编译器很可能RVO（返回值优化），我还是手动写出来以明确我提升性能的意图。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;all_pro&lt;/code&gt;函数类似，只不过计算的是积与商。&lt;/p&gt;
&lt;p&gt;程序在VS2019中编译，配置为Release、x86，在没插电的最节能配置下的i7-7700HQ上测试，从命令行调用，优化算法的平均运行时间为55ms，而原算法为82ms，是有明显提升的。&lt;/p&gt;
&lt;h3 id=&quot;概率问题&quot;&gt;概率问题&lt;/h3&gt;
&lt;p&gt;在一篇研究24点游戏的文章中，有这样一句话：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;其实还有一个原因，就是有解的概率太小了。4个数字的话也就大约80%的题能算，如果算上人头牌，可解的题就只有75%了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;没错，在1820种可能的4数组合中，有1362种有解，比例为74.8%。&lt;/p&gt;
&lt;p&gt;但是注意，我说的是“比例”而不是“概率”，这两者是有区别的。要计算“有解的概率”，必须先确定出题的方式。&lt;/p&gt;
&lt;p&gt;如果是从1820道题目的题库中等概率地选择一道，类似与上篇中提到的单片机程序一样，这样每一道题被选中都是古典概型中的基本事件，有解概率就是74.8%。&lt;/p&gt;
&lt;p&gt;如果是从52张扑克牌中等概率地选择4张，那么概率就不是74.8%，因为每一种题目出现的概率是不相等的。比如，&lt;code&gt;6, 6, 6, 6&lt;/code&gt;出现的概率为&lt;span class=&quot;math inline&quot;&gt;\(1 / C_{52}^{4}\)&lt;/span&gt;，而&lt;code&gt;1, 2, 3, 4&lt;/code&gt;出现的概率为&lt;span class=&quot;math inline&quot;&gt;\(4! / C_{52}^{4}\)&lt;/span&gt;，两者相差24倍。每一种4数的有序排列都是古典概型中的基本事件，有解概率需要重新计算。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;std::set&amp;lt;std::vector&amp;lt;Integer&amp;gt;&amp;gt; solution;
int solved = 0;
int total = 0;
int card[4];
std::vector&amp;lt;Integer&amp;gt; comb(4);
for (card[0] = 0; card[0] != 49; ++card[0])
    for (card[1] = card[0] + 1; card[1] != 50; ++card[1])
        for (card[2] = card[1] + 1; card[2] != 51; ++card[2])
            for (card[3] = card[2] + 1; card[3] != 52; ++card[3])
            {
                ++total;
                for (int i = 0; i != 4; ++i)
                    comb[i] = card[i] / 4 + 1;
                if (solution.find(comb) != solution.end())
                    ++solved;
            }
std::cout &amp;lt;&amp;lt; solved &amp;lt;&amp;lt; &quot; / &quot; &amp;lt;&amp;lt; total &amp;lt;&amp;lt; std::endl;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中，&lt;code&gt;solution&lt;/code&gt;已经保存了有解的4数组合。程序的输出为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;217817 / 270725&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个比例为80.5%，也是这种模型下有解的概率。&lt;/p&gt;
&lt;h3 id=&quot;新款50点游戏&quot;&gt;新款50点游戏&lt;/h3&gt;
&lt;p&gt;未完待续，明天更。&lt;/p&gt;
</description>
<pubDate>Wed, 15 Jan 2020 16:59:00 +0000</pubDate>
<dc:creator>jerry_fuyi</dc:creator>
<og:description>《玩玩24点》系列： &amp;quot;上篇&amp;quot; &amp;quot;中篇&amp;quot; 序 在上篇中，我用上位机程序遍历了4个1~13的数的1820种组合，通过递归穷举计算出其中1362组的24点接法，并转</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jerry-fuyi/p/12194569.html</dc:identifier>
</item>
<item>
<title>带你重新认识指针(下) - 龙跃十二</title>
<link>http://www.cnblogs.com/zhonglongbo/p/12199365.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhonglongbo/p/12199365.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;真的猛士，敢于直面惨淡的人生，敢于正视淋漓的鲜血。这是怎样的哀痛者和幸福者？然而造化又常常为庸人设计，以时间的流驶，来洗涤旧迹，仅使留下淡红的血色和微漠的悲哀。在这淡红的血色和微漠的悲哀中，又给人暂得偷生，维持着这似人非人的世界。我不知道这样的世界何时是一个尽头！我们还在这样的世上活着；我也早觉得有写一点东西的必要了。 ——鲁迅&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p align=&quot;center&quot;&gt;本文已经收录至我的GitHub,欢迎大家踊跃star 和 issues。&lt;/p&gt;
&lt;h4 align=&quot;center&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://github.com/midou-tech/articles&quot; target=&quot;_blank&quot;&gt;https://github.com/midou-tech/articles&lt;/a&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;点关注，不迷路！！！&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt; &lt;strong&gt;看完我上一篇指针的讲解之后很多同学反馈很不错，有网友给私信说之前在大学里面一直搞不懂指针的问题，说到指针都是云里雾里，老师讲的也是很难听懂 ，&lt;a href=&quot;https://mp.weixin.qq.com/s/tdyCTqH9WYMrS0HmRtVPng&quot;&gt;点击即可进入 指针(上)&lt;/a&gt;。也有很多网友表示非常期待指针下的文章，所以我就马不停蹄的继续写&lt;/strong&gt;，下 主要讲解指针的特性以及指针安全问题。&lt;/p&gt;
&lt;h3 id=&quot;h&quot;&gt;&lt;span&gt;指针的特性&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;h-1&quot;&gt;&lt;span&gt;指针和常量&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt; 先说下什么是常量，常量就是不可变的量，一旦定义该常量，其值在整个程序生命周期都是不可变的，常量存放在虚拟地址空间的常量区。&lt;/p&gt;
&lt;p&gt; 在C语言里面有两种定义常量的方法。&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;使用const关键字 ，&lt;strong&gt;const&lt;/strong&gt; 定义的是变量不是常量，只是这个变量的值不允许改变是常变量，带有类型。编译运行的时候起作用存在类型检查。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;使用#define预处理器， &lt;strong&gt;define&lt;/strong&gt; 定义的是不带类型的常数，只进行简单的字符替换。在预编译的时候起作用，不存在类型检查。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; 其实很多时候我们错误的以为常量就是const 修饰的变量，这个说法其实是有瑕疵的。&lt;/p&gt;
&lt;h5 id=&quot;h-2&quot;&gt;&lt;span&gt;指针常量&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt; 很多网友在学习指针和指针的特性等问题上总是会绕进去，其实不要绕进去最重要的一点是 &lt;strong&gt;要把握住核心本质&lt;/strong&gt;。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gau91rldy1j305i05i747.jpg&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt; 本质上是一个常量，指针用来说明常量的类型，表示该常量是一个指针类型的常量。&lt;strong&gt;在指针常量中，指针自身的值是一个常量，不可改变，始终指向同一个地址。在定义的同时必须初始化&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;c language-c hljs cpp&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; num = &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; *&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; p = &amp;amp;num;  &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;3&lt;/span&gt;*p = &lt;span class=&quot;hljs-number&quot;&gt;70&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; snum = &lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; *sp = &amp;amp;snum;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;6&lt;/span&gt;p = sp;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt; 聪明的你一定看出上面代码有个地方会报错，是的 p 被我们声明为一个指针常量，此时指针p具有了常量的属性，其不能在改变指向，但是其指向的值是可以改变的。所以报错的代码是&lt;code&gt;p = sp&lt;/code&gt;这句。&lt;/p&gt;
&lt;h5 id=&quot;h-3&quot;&gt;&lt;span&gt;常量指针&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt; 常量指针本质上是一个指针，常量表示指针指向的内容，说明该指针指向一个“常量”。&lt;strong&gt;在常量指针中，指针指向的内容是不可改变的，指针看起来好像指向了一个常量。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;c language-c hljs cpp&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; num = &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; *p = &amp;amp;num;   &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; *sp = &amp;amp;num;  &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;4&lt;/span&gt;*p = &lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;；&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; snum = &lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;6&lt;/span&gt;p = &amp;amp;snum;   &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;7&lt;/span&gt;sp = &amp;amp;snum;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt; 是不是又发现上面的代码有一处报错，你太聪明了，基本搞懂了常量和指针的本质。指针p和sp只是申明格式不同，本质完全一样。p被声明为一个指针，指向一个常量。换句话说就是一个常量的地址存放在指针p中。此时报错的就是&lt;code&gt;*p = 20&lt;/code&gt;,因为常量是不可变的。&lt;/p&gt;
&lt;p&gt; 到这里你基本掌握了常量和指针的关系，其实还是很简单的，也没大家在学校学的那么绕。接下来给大家在介绍一个进阶的关系。&lt;/p&gt;
&lt;h5 id=&quot;h-4&quot;&gt;&lt;span&gt;常量指针常量&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt; 本质上是一个常量，该常量被一个常量指针指向。也就是说一个常量指针里面放置一个常量的地址，千万不要多看一眼这句话，你会被绕进去。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;c language-c hljs cpp&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; num = &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;;   &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; * &lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; p = &amp;amp;num;  &lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt; 千万不要绕进去了，其实认真理解了上面的指针常量和常量指针的问题，这个问题看起来会简单很多，就是一个常量，和一个常量指针。num是一个不可改变的常量，p只一个指针，该指针也是不可改变指向的。&lt;/p&gt;
&lt;p&gt; 指针和常量这个问题在面试中会被问到，好好理解下，同时有助于你更好的理解指针。&lt;/p&gt;
&lt;h4 id=&quot;h-5&quot;&gt;&lt;span&gt;指针和函数&lt;/span&gt;&lt;/h4&gt;
&lt;h4 id=&quot;h-6&quot;&gt;&lt;span&gt;函数指针&lt;/span&gt;&lt;/h4&gt;
&lt;h5 id=&quot;h-7&quot;&gt;&lt;span&gt;什么是函数指针&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt; 如果在程序中定义了一个函数，那么在编译时系统就会为这个函数代码分配一段存储空间，这段存储空间的首地址称为这个函数的地址。而且函数名表示的就是这个地址。既然是地址我们就可以定义一个指针变量来存放，这个指针变量就叫作函数指针变量，简称函数指针。&lt;/p&gt;
&lt;p&gt; 函数指针的定义和普通指针不太一样。&lt;code&gt;函数返回值类型 (* 指针变量名) (函数参数列表);&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;c language-c hljs cpp&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;bool&lt;/span&gt;(*p)(&lt;span class=&quot;hljs-keyword&quot;&gt;char&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;); &lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt; 还是很简单的，这就知道怎么定义一个函数指针变量了，当然也有很复杂的函数指针变量，面试的时候面试官可能会问一些变态的面试题，比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;c language-c hljs cpp&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; (*(&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; (*)())&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;)();&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; (*signal(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; , &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt;(*)(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;)))(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt; 不过还是那句话，要把握核心本质，函数指针的核心本质是：&lt;code&gt;函数返回值类型 (* 指针变量名) (函数参数列表);&lt;/code&gt;&lt;/p&gt;
&lt;h5 id=&quot;h-8&quot;&gt;&lt;span&gt;函数指针使用&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt; 很多人会说，搞这么难干嘛，平时有使用么？哈哈，还真的经常用到，尤其是标准库中用的那叫一个多，比如sort中的比较函数就是一个函数指针。&lt;/p&gt;
&lt;h4 id=&quot;h-9&quot;&gt;&lt;span&gt;指针作为函数参数&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt; 用指针变量作函数参数可以将函数外部的地址传递到函数内部，使得在函数内部可以操作函数外部的数据，并且这些数据不会随着函数的结束而被销毁。&lt;/p&gt;
&lt;p&gt; 这不得不使我想起一个经典案例，大学老师一定会讲的，而且当时也是很多同学一直半解的。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;c language-c hljs cpp&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 1&lt;/span&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; a,&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; b)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 2&lt;/span&gt;  &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; tmp = a;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 3&lt;/span&gt;  a = b;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 4&lt;/span&gt;  b = tmp;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 5&lt;/span&gt;}&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 6&lt;/span&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 7&lt;/span&gt;  &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; x = &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 8&lt;/span&gt;  &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; x = &lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 9&lt;/span&gt;  &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;swap before:%d,%d&quot;&lt;/span&gt;,x,y);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;10&lt;/span&gt;  swap(a,b);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;11&lt;/span&gt;  &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;swap after:%d,%d&quot;&lt;/span&gt;,x,y);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;12&lt;/span&gt;  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;13&lt;/span&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt; 是不是历历在目。。。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gave41cn8jg30730740w1.gif&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt; 这个简单的问题，要搞明白可以学到好几个知识点。第一个，函数栈问题；第二个，函数的参数传递是值传递还是地址传递；第三个，指针作为函数参数。不过我这里就不讲前面两个了，相信大家能来看指针问题说明前面基础知识都差不多了，要是你真的不会的话，你可以找龙叔我，我一定把你整明白，微信搜索公众号 龙跃十二 即可找到龙叔微信，同时有机会加入龙叔技术交流群，千万别错过喔。&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gave8qqnvvg306f06pgmg.gif&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;求点赞👍 求关注❤️&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt; 交换两个数值问题，使用指针传递可以很轻松实现交换，原理如图。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;c language-c hljs cpp&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 1&lt;/span&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; *pa,&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; *pb)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 2&lt;/span&gt;  &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; tmp = *pa;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 3&lt;/span&gt;  *pa = *pb;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 4&lt;/span&gt;  *pb = tmp;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 5&lt;/span&gt;}&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 6&lt;/span&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 7&lt;/span&gt;  &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; x = &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 8&lt;/span&gt;  &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; x = &lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 9&lt;/span&gt;  &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;swap before:%d,%d&quot;&lt;/span&gt;,x,y);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;10&lt;/span&gt;  swap(&amp;amp;a,&amp;amp;b);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;11&lt;/span&gt;  &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;swap after:%d,%d&quot;&lt;/span&gt;,x,y);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;12&lt;/span&gt;  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;13&lt;/span&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gavepkd638j31bg0famz5.jpg&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt; 指针作为函数参数并不简单是这点用处，更大的用处在于传递复杂的结构体或者大容量的数组，减少数据拷贝产生的零时变量。举个例子&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;c language-c hljs cpp&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 1&lt;/span&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Person&lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 2&lt;/span&gt;  &lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt; name;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 3&lt;/span&gt;  &lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt; addr;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 4&lt;/span&gt;  &lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt; number;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 5&lt;/span&gt;  &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; age;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 6&lt;/span&gt;  &lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt; hobby;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 7&lt;/span&gt;  ...&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 8&lt;/span&gt;};&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Fun&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(struct Person person)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;11&lt;/span&gt;  &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;12&lt;/span&gt;}&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;13&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;14&lt;/span&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Fun&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(struct Person *person)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;15&lt;/span&gt;  &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;16&lt;/span&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt; 此时足以见得用指针的好处，可以减少零时变量的产生。有一个问题必须说一下 &lt;strong&gt;指针作为函数参数依然是值传递。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;h-10&quot;&gt;&lt;span&gt;指针作为函数返回值&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt; 函数的返回值是一个指针（地址），我们将这样的函数称为指针函数。举个例子&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;c language-c hljs cpp&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;char&lt;/span&gt; *&lt;span class=&quot;hljs-title&quot;&gt;strlong&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;char&lt;/span&gt; *str1, &lt;span class=&quot;hljs-keyword&quot;&gt;char&lt;/span&gt; *str2)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;2&lt;/span&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;strlen&lt;/span&gt;(str1) &amp;gt;= &lt;span class=&quot;hljs-built_in&quot;&gt;strlen&lt;/span&gt;(str2)){&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;3&lt;/span&gt;        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; str1;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;4&lt;/span&gt;    }&lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;5&lt;/span&gt;        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; str2;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;6&lt;/span&gt;    }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;7&lt;/span&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt; 用指针作为函数返回值时需要注意的一点是，函数运行结束后会销毁在它内部定义的所有局部数据，包括局部变量、局部数组和形式参数，函数返回的指针请尽量不要指向这些数据，C语言没有任何机制来保证这些数据会一直有效，它们在后续使用过程中可能会引发运行时错误。总结一句话 &lt;strong&gt;不要让返回的指针指向一个局部性的对象&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;hc&quot;&gt;&lt;span&gt;指针和C语言的内存管理&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt; C语言的动态内存分配使用的是malloc系列函数，看下库函数的声明。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;c language-c hljs cpp&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt;    *&lt;span class=&quot;hljs-title&quot;&gt;malloc&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;size_t&lt;/span&gt; __size)&lt;/span&gt; __result_use_check __&lt;span class=&quot;hljs-title&quot;&gt;alloc_size&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt;    *&lt;span class=&quot;hljs-title&quot;&gt;calloc&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;size_t&lt;/span&gt; __count, &lt;span class=&quot;hljs-keyword&quot;&gt;size_t&lt;/span&gt; __size)&lt;/span&gt; __result_use_check __&lt;span class=&quot;hljs-title&quot;&gt;alloc_size&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;malloc系列函数返回值都是一个指针，而且是void*类型的，所以用malloc系列函数分配的内存必须用一个指针指向该内存，而且指针类型自己一定要强制转换。分配的内存是一个内存块，返回的是内存的首地址，指针存储的也是首地址。这一点内容较为简单，主要还是把握住指针的核心本质。&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;求点赞👍 求关注❤️&lt;/span&gt;&lt;/h4&gt;
&lt;h3 id=&quot;h-11&quot;&gt;&lt;span&gt;指针安全问题&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt; 说到这里指针的问题基本告一段落了，当然还有一个最重要的问题，那就是指针的安全问题。不可忽略，必须学懂，否则就不要把指针用在工程代码里面。&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gavfkw5hlgj307806zdfv.jpg&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;h-12&quot;&gt;&lt;span&gt;数组越界访问&lt;/span&gt;&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;c language-c hljs cpp&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;2&lt;/span&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; arr[&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;] = {&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;};&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;3&lt;/span&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; *p = arr;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;4&lt;/span&gt;    &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;value:%d,%d,%d,%d\n&quot;&lt;/span&gt;,p[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;],p[&lt;span class=&quot;hljs-number&quot;&gt;-2&lt;/span&gt;],p[&lt;span class=&quot;hljs-number&quot;&gt;16&lt;/span&gt;],p[&lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;]);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;5&lt;/span&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt; 把数组转为指针访问的时候很容易出现这样的错误，但是你要是拿着数组下表访问，这段代码编译会报warning。这个错误也是天知道结果会是怎样，反正程序可以正常跑着，结果就是不多。&lt;/p&gt;
&lt;h4 id=&quot;h-13&quot;&gt;&lt;span&gt;不要随便强转指针的类型&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt; 先看段简单的代码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;c language-c hljs cpp&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;2&lt;/span&gt;  &lt;span class=&quot;hljs-keyword&quot;&gt;char&lt;/span&gt; c = &lt;span class=&quot;hljs-string&quot;&gt;'a'&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;3&lt;/span&gt;  &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; *p = (&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; *)&amp;amp;c;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;4&lt;/span&gt;  *p = &lt;span class=&quot;hljs-number&quot;&gt;1314&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;5&lt;/span&gt;  &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;value:%d\n&quot;&lt;/span&gt;,*p);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;6&lt;/span&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt; 这段代码有多恐怖，我真的难以想象他的恐怖程度。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gawivhevvfg306o06o7g8.gif&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;如果你在工程里面这样写了这样的代码，天知道会出现什么样的结果。p指针指向了一个不属于自己的空间地址，那片地址有可能是别的程序或者其他代码正在使用，你就这样改了别人的地址上的内容，天知道会出现什么。。。&lt;/p&gt;
&lt;p&gt;重点来了 &lt;strong&gt;不要随便强制转换指针的数据类型，一定要清楚转类型之后会不会越界访问到其他内容。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;h-14&quot;&gt;&lt;span&gt;迷途指针&lt;/span&gt;&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;c language-c hljs cpp&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; *p = (&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; *) &lt;span class=&quot;hljs-built_in&quot;&gt;malloc&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;));&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;2&lt;/span&gt;*p = &lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;free&lt;/span&gt;(p);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;4&lt;/span&gt;*p = &lt;span class=&quot;hljs-number&quot;&gt;200&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt; 从内存中删除一个对象或者返回时删除栈帧后，并不会改变相关的指针的值。该指针仍然指向原来的内存地址，即使引用已经删除，现在也可能已经被其它进程使用了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决迷途指针的方法&lt;/strong&gt;就是，我们释放指针对应的内存之后切记一定要把指针置为NULL，置空之后对指针使用会造成 segmentation fault error ，程序会崩溃。&lt;/p&gt;
&lt;h4 id=&quot;h-15&quot;&gt;&lt;span&gt;解引用空指针&lt;/span&gt;&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;c language-c hljs cpp&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; *p = (&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; *) &lt;span class=&quot;hljs-built_in&quot;&gt;malloc&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;)*&lt;span class=&quot;hljs-number&quot;&gt;1000&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;2&lt;/span&gt;*p = &lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;free&lt;/span&gt;(p);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;4&lt;/span&gt;p = &lt;span class=&quot;hljs-literal&quot;&gt;NULL&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt; 这段代码看起来没啥问题，仔细看看也没啥问题。但是这段代码不知道会在线上崩溃到那一天，malloc返回的地址不是一定保证正确的，万一内存分配不出来或者分配失败了，你的程序瞬间就崩掉了。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gawk962xxxg3046046n0p.gif&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;h3 id=&quot;h-16&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt; 指针有很多好处，同时也有很多坏处。怎样去平衡好处与坏处，我们一定要规范我们使用指针的姿势，防止因为我们使用姿势的问题导致线上崩溃。把握指针的本质，了解内存的原理，掌握这两个重要的点能减少你平时在工作中的很多错误。&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;求点赞👍 求关注❤️&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;「转发」是明目张胆的喜欢，「在看」是偷偷摸摸的爱。&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;如果有人想发文章，我这里提供&lt;/code&gt;&lt;span&gt;有偿征文&lt;/span&gt;&lt;code&gt;(具体细则微信联系)，欢迎投稿或推荐你的项目。提供以下几种投稿方式：&lt;/code&gt;&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;去我的github提交 issue:&lt;/code&gt; https://github.com/midou-tech/articles&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;发送到邮箱: 2507367760@qq.com 或者 longyueshier@163.com 或者 longyueshier@gmail.com&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;微信发送: 扫描下面二维码，公众号里面有作者微信号。&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;精选文章都同步在公众号里面，公众号看起会更方便，随时随地想看就看。微信搜索 龙跃十二 或者扫码即可订阅。&lt;/code&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1galsp9a07kj30p00dwae3.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 15 Jan 2020 16:18:00 +0000</pubDate>
<dc:creator>龙跃十二</dc:creator>
<og:description>指针是学习编程的人最头疼的问题，但是指针又是灵活性很高，性能很好的不二之选。指针灵活性很好，性能更是指针最大的优点，同时也有可控性不好的缺点。怎样才能让指针变的可控呢？本篇文章将带你了解指针的深层特性</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhonglongbo/p/12199365.html</dc:identifier>
</item>
<item>
<title>.Net Core使用分布式缓存Redis：Lua脚本 - 树杈</title>
<link>http://www.cnblogs.com/xwc1996/p/12188963.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xwc1996/p/12188963.html</guid>
<description>&lt;h3&gt;一、前言&lt;/h3&gt;
&lt;p&gt;　　运行环境window，redis版本3.2.1。此处暂不对Lua进行详细讲解，只从Redis的方面讲解。&lt;/p&gt;
&lt;h3&gt;二、Redis的Lua脚本&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　在Redis的2.6版本推出了脚本功能，允许开发者使用Lua语言编写脚本传到Redis中执行，在Lua脚本中也可以调用大部分的Redis命令。使用脚本有以下三个好处：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　(1) 减少网络开销：有些时候需要多次请求Redis获取处理数据，而使用脚本功能就可以只使用一次请求完成相同操作，减少了网络往返时延。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　(2) 原子操作：Redis会将整个脚本作为一个整体执行，中间不会被其他命令插入。也就是说在编写脚本的过程中无须担心会出现竞态条件，也就是无须使用事务。事务可以完成的所有功能，都可以用脚本来完成。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　(3) 复用：客户端发送的脚本会永久存储在Redis中，这就意味着其他客户端(可以是其他语言开发的项目)可以复用这一脚本而不需要使用代码完成同样的逻辑。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;三、Redis调用Lua&lt;/h3&gt;
&lt;p&gt;　　&lt;strong&gt;1、EVAL命令&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　编写完脚本后最重要的就是在程序中执行脚本。Redis提供了EVAL命令可以使开发者像调用其他Redis内置命令一样调用脚本。EVAL的命令格式如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt; eval script numkeys key [key ...] arg [arg ...]  
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　script：脚本内容。numkeys：key参数的数量。key和arg：这两个参数向脚本传递数据，它们的值可以在脚本中分别使用KEYS[index]和ARGV[index]两个表类型的全局变量访问，numkeys为key的数量和其索引的最大值，argv的索引为key和argv数量总和减去numkeys，它们的索引都是从1开始，超出则返回nil。如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
C:\Users\Xu&amp;gt;redis-&lt;span&gt;cli
&lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt; eval &lt;span&gt;'&lt;/span&gt;&lt;span&gt;return ARGV[3]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt; key1 key2 value1 value2 value3
&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt; eval &lt;span&gt;'&lt;/span&gt;&lt;span&gt;return KEYS[2]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt; key1 key2 value1 value2 value3
&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt; eval &lt;span&gt;'&lt;/span&gt;&lt;span&gt;return KEYS[3]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt; key1 key2 value1 value2 value3
(nil)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　其中要读写的键名应该为key参数，其他数据都作为arg参数。&lt;/p&gt;
&lt;p&gt;　　除了上面直接写lua脚本，还可以读取lua脚本文件来执行脚本，命令如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
C:\Users\Xu&amp;gt;redis-cli --eval lua_file_path key1 key2 , arg1 arg2 arg3
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　注意不需要numkeys，逗号前后必须有空格，否则会被认为一个连起来的字符串。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;lua文件内容&lt;/span&gt;
&lt;span&gt;return&lt;/span&gt; ARGV[&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行命令&lt;/span&gt;
C:\Users\Xu&amp;gt;redis-cli.exe --&lt;span&gt;eval e:\redis\a.lua key1 , value1 value2
&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
C:\Users\Xu&lt;/span&gt;&amp;gt;redis-cli.exe --&lt;span&gt;eval e:\redis\a.lua key1 , value1 value2,value3
&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value2,value3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;　　2、EVALSHA命令&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 　　考虑到在脚本比较长的时候，如果每次调用脚本都需要将整个脚本传给Redis会占用较多的带宽。所以，Redis提供了EVALSHA命令允许开发者通过脚本内容的SHA1摘要来执行脚本，该命令的用法和EVAL一样，不过就是将脚本内容的script替换为它的SHA1摘要。&lt;/p&gt;
&lt;p&gt;　　Redis在执行EVAL命令时会计算脚本的SHA1摘要并记录在脚本缓存中，如果执行EVALSHA命令时没有从脚本缓存中找到相应的摘要，则返回错误。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt; evalsha c349a436bd639369c62c971941fc5f7a80626ee6 &lt;span&gt;1&lt;/span&gt;&lt;span&gt; key1 value1
(integer) &lt;/span&gt;&lt;span&gt;666&lt;/span&gt;
&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt; evalsha c349a436bd639369c62c971941fc5f7a80626ee61 &lt;span&gt;1&lt;/span&gt;&lt;span&gt; key1 value1
(error) NOSCRIPT No matching script. Please use EVAL.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在程序中使用EVALSHA的流程如下：&lt;/p&gt;
&lt;p&gt;　　(1) 先计算脚本SHA1摘要，并使用EVALSHA执行。&lt;/p&gt;
&lt;p&gt;　　(2) 获得返回值，如果返回错误则使用EVAL重新执行脚本。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;3、SCRIPT LOAD命令&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　如果只是想将脚本加入到脚本缓存中而不执行则则可以用SCRIPT LOAD命令，返回值时脚本的SHA1摘要。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt; script load &lt;span&gt;'&lt;/span&gt;&lt;span&gt;return 666&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;c349a436bd639369c62c971941fc5f7a80626ee6&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　&lt;strong&gt;　4、SCRIPT EXISTS命令&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　SCRIPT EXISTS命令可以同时查找一个或者多个脚本的SHA1摘要是否已经本缓存，1为存在0为不存在。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt; script exists c349a436bd639369c62c971941fc5f7a80626ee6 123ls436bd639369c62c971941fc5f7a80626ee6
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;) (integer) &lt;span&gt;1&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;) (integer) &lt;span&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;5、SCRIPT FLUSH命令&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 　　Redis将脚本的SHA1摘要加入到脚本缓存后会永久保存，不会删除，但是可以用SCRIPT FLUSH删除所有脚本缓存。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt; script flush
OK
(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;.51s)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;　　6、SCRIPT KILL 和 SHUTDOWN NOSAVE&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 　　由于Redis的脚本是原子性的，脚本执行期间不会执行其他命令。为了防止某个脚本执行时间过长导致Redis无法提供服务(比如死循环)，Redis提供了lua-time-limit参数限制脚本最长运行时间，默认是5秒。再脚本执行期间，执行其他命令会返回“BUSY”错误，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
(A)&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt; eval &lt;span&gt;'&lt;/span&gt;&lt;span&gt;while true do end&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;0&lt;br/&gt;&lt;/span&gt;&lt;span&gt;
(B)&lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt; &lt;span&gt;get&lt;/span&gt;&lt;span&gt; foo
(error) BUSY Redis &lt;/span&gt;&lt;span&gt;is&lt;/span&gt; busy running a script. You can only call SCRIPT KILL or SHUTDOWN NOSAVE.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　此时Redis只会接受并执行两个命令：SCRIPT KILL 和 SHUTDOWN NOSVAE。&lt;/p&gt;
&lt;p&gt;　　通过SCRIPT KILL 可以终止当前脚本的运行，脚本停止并返回错误：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
(B)&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt; script kill
OK
(B)&lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt; &lt;span&gt;get&lt;/span&gt;&lt;span&gt; foo
(nil)

(A)&lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt; eval &lt;span&gt;'&lt;/span&gt;&lt;span&gt;while true do end&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
(error) ERR Error running script (call to f_694a5fe1ddb97a4c6a1bf299d9537c7d3d0f84e7): @user_script:&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;: Script killed by user with SCRIPT KILL...
(&lt;/span&gt;&lt;span&gt;175&lt;/span&gt;.99s)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　如果当前执行的脚本对Redis的数据进行了修改，则SCRIPT KILL不会终止脚本的运行，因为这样违背了原子性。那么需要通过SHUTDOWN NOSAVE来强制终止Redis将原先脚本的修改操作返回，不进行持久化操作，这意味着所有发送在上一次的快照后的数据库修改都会丢失。&lt;/p&gt;
&lt;h3&gt; 四、Redis获取脚本中的返回值&lt;/h3&gt;
&lt;p&gt; 　　很多情况下，都需要脚本通过return返回值，如果没有执行return则默认返回nil。因为我们可以像调用其他Redis内置命令一样调用我们自己写的脚本，所以同样Redis会自动将脚本返回值的Lua数据类型转化成Redis的返回值类型。具体的转换规则如下：&lt;/p&gt;
&lt;p&gt;　　(1) Lua的数字类型，Redis为整数类型。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt; eval &lt;span&gt;'&lt;/span&gt;&lt;span&gt;return 1.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
(integer) &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　(2) Lua的字符串类型，Redis也是字符串类型&lt;/p&gt;
&lt;p&gt;　　(3) Lua的表类型(数组形式)，Redis会返回多行字符串&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt; eval &lt;span&gt;'&lt;/span&gt;&lt;span&gt;return {0,1}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;
&lt;span&gt;1&lt;/span&gt;) (integer) &lt;span&gt;0&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;) (integer) &lt;span&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　(4) Lua表类型(只有一个ok字段存储状态信息)，Redis为成功状态回复&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt; eval &lt;span&gt;'&lt;/span&gt;&lt;span&gt;return {ok=&quot;this is ok&quot;}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;
&lt;span&gt;this&lt;/span&gt; &lt;span&gt;is&lt;/span&gt; ok
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　(5)Lua表类型(只有一个err字段存储状态信息)，Redis为错误状态回复&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt; eval &lt;span&gt;'&lt;/span&gt;&lt;span&gt;return {err=&quot;so bad&quot;}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
(error) so bad&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　(6)Lua的bool类型中true为Redis的1，false为nil&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt; eval &lt;span&gt;'&lt;/span&gt;&lt;span&gt;return true&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
(integer) &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt; eval &lt;span&gt;'&lt;/span&gt;&lt;span&gt;return false&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
(nil)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;五、沙盒与随机数&lt;/h3&gt;
&lt;p&gt;　　Redis脚本禁止使用Lua标准库中与文件或系统调用相关的函数，在脚本中只允许对Redis的数据进行处理。并且Redis还通过禁用脚本的全局变量的方式保证每个脚本都是相对隔离的，不会互相干扰。&lt;/p&gt;
&lt;p&gt;　　使用沙盒不仅是为了保证服务器的安全性，而且还确保了脚本的执行结果只有和脚本本身和执行时传递的参数有关，不依赖外界条件(如系统时间、系统中某个文件的内容、其他脚本执行结果登)。这是因为在执行复制和AOF持久话操作时记录的脚本的内容而不是脚本调用的命令，所以必须保证在脚本内容和参数一样的前提下脚本的执行结果必须一样。&lt;/p&gt;
&lt;p&gt;　　对于随机数，Redis替换了math.random和math。randomseed函数使得每次执行脚本时生成的随机数列都相同，如果希望获得不同的随机数序列，最简单的方法时由程序生成随机数并通过参数传递给脚本，或者采用更灵活的方法，即在程序中生成随机数传给脚本作为随机数种子。&lt;/p&gt;
&lt;h3&gt;六、在net core中使用脚本&lt;/h3&gt;
&lt;p&gt;　　很简单，直接上代码，这里举例最基本的，还有很多的重写方法大家可以自己试试。最简单的使用eval。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; script = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; return KEYS[1];&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; keys = &lt;span&gt;new&lt;/span&gt; RedisKey[]{ &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;};
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; values = &lt;span&gt;new&lt;/span&gt; RedisValue[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;await&lt;/span&gt; redisConnection.GetDatabase().ScriptEvaluateAsync(script, keys, values);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　缓存脚本，并使用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; bytes = &lt;span&gt;await&lt;/span&gt; redisConnection.GetServer(Config.Get(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ConnectionStrings:Redis:ConnectionString&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)).ScriptLoadAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;return 1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result = &lt;span&gt;await&lt;/span&gt; redisConnection.GetDatabase().ScriptEvaluateAsync(bytes, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　脚本是否已缓存。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;bool&lt;/span&gt; exist = &lt;span&gt;await&lt;/span&gt; redisConnection.GetServer(Config.Get(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ConnectionStrings:Redis:ConnectionString&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)).ScriptExistsAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;return 1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　删除所有脚本缓存，这个操作需要连接的ConfigurationOptions配置中AllowAdmin = true，没有会报错哦。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
redisConnection.GetServer(Config.Get(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ConnectionStrings:Redis:ConnectionString&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)).ScriptFlush();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　还有LuaScript和LoadedLuaScript两个类可以对脚本进行更多复杂的脚本，LuaScript将@myVar形式的脚本中的变量重写为redis所需的合适的ARGV[someIndex]。如果传递的参数是RedisKey类型，它将作为KEYS集合的一部分自动发送。如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; lua = LuaScript.Prepare(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;return @key&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result = redisConnection.GetDatabase().ScriptEvaluate(lua,&lt;span&gt;new&lt;/span&gt; {key= (RedisKey)&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,value = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; });
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Wed, 15 Jan 2020 15:49:00 +0000</pubDate>
<dc:creator>树杈</dc:creator>
<og:description>一、前言 运行环境window，redis版本3.2.1。此处暂不对Lua进行详细讲解，只从Redis的方面讲解。 二、Redis的Lua脚本 在Redis的2.6版本推出了脚本功能，允许开发者使用L</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xwc1996/p/12188963.html</dc:identifier>
</item>
<item>
<title>自适应滤波器分块分段技术详解 - 爱酷媒</title>
<link>http://www.cnblogs.com/icoolmedia/p/mdf_detailed.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/icoolmedia/p/mdf_detailed.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　先说下目的：对在频域计算FIR自适应滤波器，同时避免使用长滤波器时产生的大延迟的技术进行详细的分解。即要对滤波器分块又分段的过程进行细致的分析。这里假设读者有相应的LMS自适滤波器的基础&lt;/p&gt;
&lt;h2&gt;一、滤波器分析准备&lt;/h2&gt;
&lt;p&gt;　　先从时域LMS滤波器说起，设列向量&lt;/p&gt;
&lt;p&gt;\[{\bf{x}}(n) = {\left[ {x(n),x(n - 1),...,x(n - M + 1)} \right]^T}\]&lt;br/&gt;\[{\bf{w}}(n) = {\left[ {{w_0}(n),{w_1}(n),...,{w_{M - 1}}(n)} \right]^T}\]&lt;/p&gt;
&lt;p&gt;　　这里列向量长度为M。考虑通过系数为&lt;strong&gt;w&lt;/strong&gt;(n)的FIR滤波器对序列&lt;strong&gt;x&lt;/strong&gt;(n)滤波，用卷积运算表示为\[y(n) = \sum\limits_{i = 0}^{M - 1} {{w_i}x(n - i)} \]&lt;/p&gt;
&lt;p&gt;　　写成向量形式：&lt;/p&gt;
&lt;p&gt;\[y(n) = {{\bf{w}}^T}(n){\bf{x}}(n)\]&lt;/p&gt;
&lt;p&gt;　　简单从公式上，初学者其实不容易理解FIR滤波器的工作过程，这里换一种表达方式：把向量和矩阵用时间序列索引与符号来表示。应该就会比较好理解一些，对于序列：7，2，-3，-6，12，8，-7，-5，4，6。通过一个长度为4的FIR滤波器，输入向量 随时间序列的迭代变化表示为&lt;/p&gt;
&lt;p&gt;\[\begin{array}{*{20}{c}}&lt;br/&gt;{n = 0} \hfill &amp;amp; {{\bf{x}} = {{\left[ {\begin{array}{*{20}{c}}&lt;br/&gt;7 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\&lt;br/&gt;\end{array}} \right]}^T}} \hfill \\&lt;br/&gt;{n = 1} \hfill &amp;amp; {{\bf{x}} = {{\left[ {\begin{array}{*{20}{c}}&lt;br/&gt;2 &amp;amp; 7 &amp;amp; 0 &amp;amp; 0 \\&lt;br/&gt;\end{array}} \right]}^T}} \hfill \\&lt;br/&gt;{n = 2} \hfill &amp;amp; {{\bf{x}} = {{\left[ {\begin{array}{*{20}{c}}&lt;br/&gt;{ - 3} &amp;amp; 2 &amp;amp; 7 &amp;amp; 0 \\&lt;br/&gt;\end{array}} \right]}^T}} \hfill \\&lt;br/&gt;{n = 3} \hfill &amp;amp; {{\bf{x}} = {{\left[ {\begin{array}{*{20}{c}}&lt;br/&gt;{ - 6} &amp;amp; { - 3} &amp;amp; 2 &amp;amp; 7 \\&lt;br/&gt;\end{array}} \right]}^T}} \hfill \\&lt;br/&gt;{n = 4} \hfill &amp;amp; {{\bf{x}} = {{\left[ {\begin{array}{*{20}{c}}&lt;br/&gt;{12} &amp;amp; { - 6} &amp;amp; { - 3} &amp;amp; 2 \\&lt;br/&gt;\end{array}} \right]}^T}} \hfill \\&lt;br/&gt;\end{array}\]&lt;/p&gt;
&lt;h2&gt;二、滤波器分块处理&lt;/h2&gt;
&lt;p&gt;　　下面准备写成时间序列索引的形式(向量各元素用时间序列对应的索引号代替，如：[0 -1 -2 -3]&lt;sup&gt;T&lt;/sup&gt;)，这样有利于在接下来的分析中看的更清楚一些，对于矩阵，也会沿用这样的方式。&lt;/p&gt;
&lt;p&gt;　　先从频域矩阵分块处理说起，分块方法是一种批处理方法，为了说的更清楚一些，这里用一个示例来说明，设滤波器长度M = 6，块长度N = 4，表示每次批处理4个单元&lt;/p&gt;
&lt;p&gt;\[\left[ {\begin{array}{*{20}{c}}&lt;br/&gt;\hfill 0 &amp;amp; \hfill { - 1} &amp;amp; \hfill { - 2} &amp;amp; \hfill { - 3} &amp;amp; \hfill { - 4} &amp;amp; \hfill { - 5} \\&lt;br/&gt;\hfill 1 &amp;amp; \hfill 0 &amp;amp; \hfill { - 1} &amp;amp; \hfill { - 2} &amp;amp; \hfill { - 3} &amp;amp; \hfill { - 4} \\&lt;br/&gt;\hfill 2 &amp;amp; \hfill 1 &amp;amp; \hfill 0 &amp;amp; \hfill { - 1} &amp;amp; \hfill { - 2} &amp;amp; \hfill { - 3} \\&lt;br/&gt;\hfill 3 &amp;amp; \hfill 2 &amp;amp; \hfill 1 &amp;amp; \hfill 0 &amp;amp; \hfill { - 1} &amp;amp; \hfill { - 2} \\&lt;br/&gt;\end{array}} \right]\left[ {\begin{array}{*{20}{c}}&lt;br/&gt;{{w_0}} \hfill \\&lt;br/&gt;{{w_1}} \hfill \\&lt;br/&gt;{{w_2}} \hfill \\&lt;br/&gt;{{w_3}} \hfill \\&lt;br/&gt;{{w_4}} \hfill \\&lt;br/&gt;{{w_5}} \hfill \\&lt;br/&gt;\end{array}} \right] = \left[ {\begin{array}{*{20}{c}}&lt;br/&gt;{{y_0}} \hfill \\&lt;br/&gt;{{y_1}} \hfill \\&lt;br/&gt;{{y_2}} \hfill \\&lt;br/&gt;{{y_3}} \hfill \\&lt;br/&gt;\end{array}} \right]\]&lt;/p&gt;
&lt;p&gt;　　观察输入向量组成的矩阵可以发现，这是一个Toeplitz矩阵。要转到频域进行处理，一个比较可行的方式是把Toeplitz矩阵转为循环矩阵。再利用DFT把循环矩阵对角化。&lt;/p&gt;
&lt;p&gt;　　那这个循环矩阵的大小是多少比较合适呢，由卷积过程可知，卷积后输出长度为L = M + N – 1 = 9，也就是说，用M + N – 1个卷积长度完全可以表达出来，也就是说循环矩阵C的大小为LxL应该是足够的。用循环矩阵表示如下：&lt;/p&gt;
&lt;p&gt;\[\left[ {\begin{array}{*{20}{c}}&lt;br/&gt;\hfill { - 5} &amp;amp; \hfill 3 &amp;amp; \hfill 2 &amp;amp; \hfill 1 &amp;amp; \hfill 0 &amp;amp; \hfill { - 1} &amp;amp; \hfill { - 2} &amp;amp; \hfill { - 3} &amp;amp; \hfill { - 4} \\&lt;br/&gt;\hfill { - 4} &amp;amp; \hfill { - 5} &amp;amp; \hfill 3 &amp;amp; \hfill 2 &amp;amp; \hfill 1 &amp;amp; \hfill 0 &amp;amp; \hfill { - 1} &amp;amp; \hfill { - 2} &amp;amp; \hfill { - 3} \\&lt;br/&gt;\hfill { - 3} &amp;amp; \hfill { - 4} &amp;amp; \hfill { - 5} &amp;amp; \hfill 3 &amp;amp; \hfill 2 &amp;amp; \hfill 1 &amp;amp; \hfill 0 &amp;amp; \hfill { - 1} &amp;amp; \hfill { - 2} \\&lt;br/&gt;\hfill { - 2} &amp;amp; \hfill { - 3} &amp;amp; \hfill { - 4} &amp;amp; \hfill { - 5} &amp;amp; \hfill 3 &amp;amp; \hfill 2 &amp;amp; \hfill 1 &amp;amp; \hfill 0 &amp;amp; \hfill { - 1} \\&lt;br/&gt;\hfill { - 1} &amp;amp; \hfill { - 2} &amp;amp; \hfill { - 3} &amp;amp; \hfill { - 4} &amp;amp; \hfill { - 5} &amp;amp; \hfill 3 &amp;amp; \hfill 2 &amp;amp; \hfill 1 &amp;amp; \hfill 0 \\&lt;br/&gt;\hfill 0 &amp;amp; \hfill { - 1} &amp;amp; \hfill { - 2} &amp;amp; \hfill { - 3} &amp;amp; \hfill { - 4} &amp;amp; \hfill { - 5} &amp;amp; \hfill 3 &amp;amp; \hfill 2 &amp;amp; \hfill 1 \\&lt;br/&gt;\hfill 1 &amp;amp; \hfill 0 &amp;amp; \hfill { - 1} &amp;amp; \hfill { - 2} &amp;amp; \hfill { - 3} &amp;amp; \hfill { - 4} &amp;amp; \hfill { - 5} &amp;amp; \hfill 3 &amp;amp; \hfill 2 \\&lt;br/&gt;\hfill 2 &amp;amp; \hfill 1 &amp;amp; \hfill 0 &amp;amp; \hfill { - 1} &amp;amp; \hfill { - 2} &amp;amp; \hfill { - 3} &amp;amp; \hfill { - 4} &amp;amp; \hfill { - 5} &amp;amp; \hfill 3 \\&lt;br/&gt;\hfill 3 &amp;amp; \hfill 2 &amp;amp; \hfill 1 &amp;amp; \hfill 0 &amp;amp; \hfill { - 1} &amp;amp; \hfill { - 2} &amp;amp; \hfill { - 3} &amp;amp; \hfill { - 4} &amp;amp; \hfill { - 5} \\&lt;br/&gt;\end{array}} \right]\left[ {\begin{array}{*{20}{c}}&lt;br/&gt;{{w_0}} \\&lt;br/&gt;{{w_1}} \\&lt;br/&gt;{{w_2}} \\&lt;br/&gt;{{w_3}} \\&lt;br/&gt;{{w_4}} \\&lt;br/&gt;{{w_5}} \\&lt;br/&gt;0 \\&lt;br/&gt;0 \\&lt;br/&gt;0 \\&lt;br/&gt;\end{array}} \right] = \left[ {\begin{array}{*{20}{c}}&lt;br/&gt;\times \\&lt;br/&gt;\times \\&lt;br/&gt;\times \\&lt;br/&gt;\times \\&lt;br/&gt;\times \\&lt;br/&gt;{{y_0}} \\&lt;br/&gt;{{y_1}} \\&lt;br/&gt;{{y_2}} \\&lt;br/&gt;{{y_3}} \\&lt;br/&gt;\end{array}} \right]\]&lt;/p&gt;
&lt;p&gt;　　这里输出向量中的X部分是循环卷积的结果，是要舍弃的部分。重写以上过程&lt;/p&gt;
&lt;p&gt; \[{\bf{y}}(n) = P_{L \times L}^{01}C{\bf{\hat w}}(n) = P_{L \times L}^{01}{F^{ - 1}}FC{F^{ - 1}}F{\bf{\hat w}}(n)\]&lt;/p&gt;
&lt;p&gt;　　分解为4步：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/789569/202001/789569-20200115222733814-1790555962.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;是一个对角矩阵，在编程实现中，可以取循环矩阵C的第一列变换到频域来代替&lt;/li&gt;
&lt;li&gt;是把后面补0后的滤波器系数变换到频域&lt;/li&gt;
&lt;li&gt;是一个逆FFT变换&lt;/li&gt;
&lt;li&gt;是为了只选取最后N个做为滤波器的输出结果，编程中做到这点很方便&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　再看滤波器的更新过程，这里把步长参数省去&lt;/p&gt;
&lt;p&gt;\[w(n + 1) = w(n) + \left[ {\begin{array}{*{20}{c}}&lt;br/&gt;\hfill 0 &amp;amp; \hfill 1 &amp;amp; \hfill 2 &amp;amp; \hfill 3 \\&lt;br/&gt;\hfill { - 1} &amp;amp; \hfill 0 &amp;amp; \hfill 1 &amp;amp; \hfill 2 \\&lt;br/&gt;\hfill { - 2} &amp;amp; \hfill { - 1} &amp;amp; \hfill 0 &amp;amp; \hfill 1 \\&lt;br/&gt;\hfill { - 3} &amp;amp; \hfill { - 2} &amp;amp; \hfill { - 1} &amp;amp; \hfill 0 \\&lt;br/&gt;\hfill { - 4} &amp;amp; \hfill { - 3} &amp;amp; \hfill { - 2} &amp;amp; \hfill { - 1} \\&lt;br/&gt;\hfill { - 5} &amp;amp; \hfill { - 4} &amp;amp; \hfill { - 3} &amp;amp; \hfill { - 2} \\&lt;br/&gt;\end{array}} \right]\left[ {\begin{array}{*{20}{c}}&lt;br/&gt;{{e_0}} \\&lt;br/&gt;{{e_1}} \\&lt;br/&gt;{{e_2}} \\&lt;br/&gt;{{e_3}} \\&lt;br/&gt;\end{array}} \right]\]&lt;/p&gt;
&lt;p&gt;　　用循环矩阵表示梯度向量的计算过程&lt;/p&gt;
&lt;p&gt;\[\left[ {\begin{array}{*{20}{c}}&lt;br/&gt;1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\&lt;br/&gt;0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\&lt;br/&gt;0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\&lt;br/&gt;0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\&lt;br/&gt;0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\&lt;br/&gt;0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\&lt;br/&gt;0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\&lt;br/&gt;0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\&lt;br/&gt;0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\&lt;br/&gt;\end{array}} \right]\left[ {\begin{array}{*{20}{c}}&lt;br/&gt;\hfill { - 5} &amp;amp; \hfill { - 4} &amp;amp; \hfill { - 3} &amp;amp; \hfill { - 2} &amp;amp; \hfill { - 1} &amp;amp; \hfill 0 &amp;amp; \hfill 1 &amp;amp; \hfill 2 &amp;amp; \hfill 3 \\&lt;br/&gt;\hfill 3 &amp;amp; \hfill { - 5} &amp;amp; \hfill { - 4} &amp;amp; \hfill { - 3} &amp;amp; \hfill { - 2} &amp;amp; \hfill { - 1} &amp;amp; \hfill 0 &amp;amp; \hfill 1 &amp;amp; \hfill 2 \\&lt;br/&gt;\hfill 2 &amp;amp; \hfill 3 &amp;amp; \hfill { - 5} &amp;amp; \hfill { - 4} &amp;amp; \hfill { - 3} &amp;amp; \hfill { - 2} &amp;amp; \hfill { - 1} &amp;amp; \hfill 0 &amp;amp; \hfill 1 \\&lt;br/&gt;\hfill 1 &amp;amp; \hfill 2 &amp;amp; \hfill 3 &amp;amp; \hfill { - 5} &amp;amp; \hfill { - 4} &amp;amp; \hfill { - 3} &amp;amp; \hfill { - 2} &amp;amp; \hfill { - 1} &amp;amp; \hfill 0 \\&lt;br/&gt;\hfill 0 &amp;amp; \hfill 1 &amp;amp; \hfill 2 &amp;amp; \hfill 3 &amp;amp; \hfill { - 5} &amp;amp; \hfill { - 4} &amp;amp; \hfill { - 3} &amp;amp; \hfill { - 2} &amp;amp; \hfill { - 1} \\&lt;br/&gt;\hfill { - 1} &amp;amp; \hfill 0 &amp;amp; \hfill 1 &amp;amp; \hfill 2 &amp;amp; \hfill 3 &amp;amp; \hfill { - 5} &amp;amp; \hfill { - 4} &amp;amp; \hfill { - 3} &amp;amp; \hfill { - 2} \\&lt;br/&gt;\hfill { - 2} &amp;amp; \hfill { - 1} &amp;amp; \hfill 0 &amp;amp; \hfill 1 &amp;amp; \hfill 2 &amp;amp; \hfill 3 &amp;amp; \hfill { - 5} &amp;amp; \hfill { - 4} &amp;amp; \hfill { - 3} \\&lt;br/&gt;\hfill { - 3} &amp;amp; \hfill { - 2} &amp;amp; \hfill { - 1} &amp;amp; \hfill 0 &amp;amp; \hfill 1 &amp;amp; \hfill 2 &amp;amp; \hfill 3 &amp;amp; \hfill { - 5} &amp;amp; \hfill { - 4} \\&lt;br/&gt;\hfill { - 4} &amp;amp; \hfill { - 3} &amp;amp; \hfill { - 2} &amp;amp; \hfill { - 1} &amp;amp; \hfill 0 &amp;amp; \hfill 1 &amp;amp; \hfill 2 &amp;amp; \hfill 3 &amp;amp; \hfill { - 5} \\&lt;br/&gt;\end{array}} \right]\left[ {\begin{array}{*{20}{c}}&lt;br/&gt;0 \\&lt;br/&gt;0 \\&lt;br/&gt;0 \\&lt;br/&gt;0 \\&lt;br/&gt;0 \\&lt;br/&gt;{{e_0}} \\&lt;br/&gt;{{e_1}} \\&lt;br/&gt;{{e_2}} \\&lt;br/&gt;{{e_3}} \\&lt;br/&gt;\end{array}} \right]\]&lt;/p&gt;
&lt;p&gt;　　重写滤波器系数更新公式如下： &lt;/p&gt;
&lt;p&gt;\[\begin{array}{l}&lt;br/&gt;w(n + 1) = w(n) + P_{L \times L}^{10}{C^T}{{\bf{e}}_L} = w(n) + P_{L \times L}^{10}{F^{ - 1}}F{C^T}{F^{ - 1}}F{{\bf{e}}_L} \\&lt;br/&gt;W(n + 1) = W(n) + FP_{L \times L}^{10}{F^{ - 1}}F{C^T}{F^{ - 1}}E \\&lt;br/&gt;\end{array}\]&lt;/p&gt;
&lt;p&gt;这里W向量是滤波器系数的频域表示。同样做4步分解：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/789569/202001/789569-20200115233845109-2110995350.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;ol&gt;&lt;li&gt; 仍然是一个对解矩阵，可取循环矩阵C的第一列变换到频域后再取共轭来实现&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;E&lt;/strong&gt;是把前面补0后的误差信号变换到频域&lt;/li&gt;
&lt;li&gt;这步是比较麻烦的地方。如果为了计算量忽略这一步（webrtc的做法），就是不对梯度做约束，而speex是通过变换到时域再置后面部分为0来避免直接矩阵运算的，个人比较喜欢speex的实现方式。当然，由于这是一个定值，不考虑计算量的话，也可以直接在频域进行矩阵的乘法&lt;/li&gt;
&lt;li&gt;与W(n)在频域相加&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　至此，已经完成了滤波器分块的频域处理分析，但要注意的是，这里滤波器的长度是L = M + N – 1，分块处理转到频域虽然计算上方便了，但随着时域滤波器系数长度M和分块长度N越来越大，延时也会随之线性增大，接下来，就着手解决这个问题。&lt;/p&gt;
&lt;h2&gt;三、对滤波器进行分割（分段）&lt;/h2&gt;
&lt;p&gt;　　当滤波器长度M很大，且使用一个比M小很多的块长度时，可以把卷积和的运算过程分割为多个块的和，用多个分块滤波器的和来合成最终的结果，这样处理就可以使滤波器的延时大幅度的缩短。以M = 8，P = 2，N = 4为例进行说明这个分割过程。也就是说，如果对一个长度M = 8的滤波器，把滤波器分成2个块，每块4个数据，可以把卷积过程写为&lt;/p&gt;
&lt;p&gt;\[\begin{array}{l}&lt;br/&gt;y(n) = \sum\limits_{l = 0}^{P - 1} {{y_l}(n)} \\&lt;br/&gt;{y_l}(n) = \sum\limits_{i = 0}^{N - 1} {{w_{i + lN}}x(n - lN - i)} \\&lt;br/&gt;\end{array}\]&lt;/p&gt;
&lt;p&gt;　　用矩阵的方式表示出来：&lt;/p&gt;
&lt;p&gt;\[\left[ {\begin{array}{*{20}{c}}&lt;br/&gt;\hfill 0 &amp;amp; \hfill { - 1} &amp;amp; \hfill { - 2} &amp;amp; \hfill { - 3} &amp;amp; \hfill | &amp;amp; \hfill { - 4} &amp;amp; \hfill { - 5} &amp;amp; \hfill { - 6} &amp;amp; \hfill { - 7} \\&lt;br/&gt;\hfill 1 &amp;amp; \hfill 0 &amp;amp; \hfill { - 1} &amp;amp; \hfill { - 2} &amp;amp; \hfill | &amp;amp; \hfill { - 3} &amp;amp; \hfill { - 4} &amp;amp; \hfill { - 5} &amp;amp; \hfill { - 6} \\&lt;br/&gt;\hfill 2 &amp;amp; \hfill 1 &amp;amp; \hfill 0 &amp;amp; \hfill { - 1} &amp;amp; \hfill | &amp;amp; \hfill { - 2} &amp;amp; \hfill { - 3} &amp;amp; \hfill { - 4} &amp;amp; \hfill { - 5} \\&lt;br/&gt;\hfill 3 &amp;amp; \hfill 2 &amp;amp; \hfill 1 &amp;amp; \hfill 0 &amp;amp; \hfill | &amp;amp; \hfill { - 1} &amp;amp; \hfill { - 2} &amp;amp; \hfill { - 3} &amp;amp; \hfill { - 4} \\&lt;br/&gt;\end{array}} \right]\left[ {\frac{{\begin{array}{*{20}{c}}&lt;br/&gt;{{w_0}} \\&lt;br/&gt;{{w_1}} \\&lt;br/&gt;{{w_2}} \\&lt;br/&gt;{{w_3}} \\&lt;br/&gt;\end{array}}}{{\begin{array}{*{20}{c}}&lt;br/&gt;{{w_4}} \\&lt;br/&gt;{{w_5}} \\&lt;br/&gt;{{w_6}} \\&lt;br/&gt;{{w_7}} \\&lt;br/&gt;\end{array}}}} \right] \Rightarrow \begin{array}{*{20}{c}}&lt;br/&gt;{\left[ {\begin{array}{*{20}{c}}&lt;br/&gt;\hfill 0 &amp;amp; \hfill { - 1} &amp;amp; \hfill { - 2} &amp;amp; \hfill { - 3} \\&lt;br/&gt;\hfill 1 &amp;amp; \hfill 0 &amp;amp; \hfill { - 1} &amp;amp; \hfill { - 2} \\&lt;br/&gt;\hfill 2 &amp;amp; \hfill 1 &amp;amp; \hfill 0 &amp;amp; \hfill { - 1} \\&lt;br/&gt;\hfill 3 &amp;amp; \hfill 2 &amp;amp; \hfill 1 &amp;amp; \hfill 0 \\&lt;br/&gt;\end{array}} \right]\left[ {\begin{array}{*{20}{c}}&lt;br/&gt;{{w_0}} \\&lt;br/&gt;{{w_1}} \\&lt;br/&gt;{{w_2}} \\&lt;br/&gt;{{w_3}} \\&lt;br/&gt;\end{array}} \right] = \left[ {\begin{array}{*{20}{c}}&lt;br/&gt;{{y_{\begin{array}{*{20}{c}}&lt;br/&gt;0 &amp;amp; 0 \\&lt;br/&gt;\end{array}}}} \\&lt;br/&gt;{{y_{\begin{array}{*{20}{c}}&lt;br/&gt;0 &amp;amp; 1 \\&lt;br/&gt;\end{array}}}} \\&lt;br/&gt;{{y_{\begin{array}{*{20}{c}}&lt;br/&gt;0 &amp;amp; 2 \\&lt;br/&gt;\end{array}}}} \\&lt;br/&gt;{{y_{\begin{array}{*{20}{c}}&lt;br/&gt;0 &amp;amp; 3 \\&lt;br/&gt;\end{array}}}} \\&lt;br/&gt;\end{array}} \right]} \\&lt;br/&gt;{\left[ {\begin{array}{*{20}{c}}&lt;br/&gt;\hfill { - 4} &amp;amp; \hfill { - 5} &amp;amp; \hfill { - 6} &amp;amp; \hfill { - 7} \\&lt;br/&gt;\hfill { - 3} &amp;amp; \hfill { - 4} &amp;amp; \hfill { - 5} &amp;amp; \hfill { - 6} \\&lt;br/&gt;\hfill { - 2} &amp;amp; \hfill { - 3} &amp;amp; \hfill { - 4} &amp;amp; \hfill { - 5} \\&lt;br/&gt;\hfill { - 1} &amp;amp; \hfill { - 2} &amp;amp; \hfill { - 3} &amp;amp; \hfill { - 4} \\&lt;br/&gt;\end{array}} \right]\left[ {\begin{array}{*{20}{c}}&lt;br/&gt;{{w_4}} \\&lt;br/&gt;{{w_5}} \\&lt;br/&gt;{{w_6}} \\&lt;br/&gt;{{w_7}} \\&lt;br/&gt;\end{array}} \right] = \left[ {\begin{array}{*{20}{c}}&lt;br/&gt;{{y_{\begin{array}{*{20}{c}}&lt;br/&gt;1 &amp;amp; 0 \\&lt;br/&gt;\end{array}}}} \\&lt;br/&gt;{{y_{\begin{array}{*{20}{c}}&lt;br/&gt;1 &amp;amp; 1 \\&lt;br/&gt;\end{array}}}} \\&lt;br/&gt;{{y_{\begin{array}{*{20}{c}}&lt;br/&gt;1 &amp;amp; 2 \\&lt;br/&gt;\end{array}}}} \\&lt;br/&gt;{{y_{\begin{array}{*{20}{c}}&lt;br/&gt;1 &amp;amp; 3 \\&lt;br/&gt;\end{array}}}} \\&lt;br/&gt;\end{array}} \right]} \\&lt;br/&gt;\end{array}\]&lt;/p&gt;
&lt;p&gt;\[\begin{array}{*{20}{c}}&lt;br/&gt;{{y_0} = {y_{\begin{array}{*{20}{c}}&lt;br/&gt;0 &amp;amp; 0 \\&lt;br/&gt;\end{array}}} + {y_{\begin{array}{*{20}{c}}&lt;br/&gt;1 &amp;amp; 0 \\&lt;br/&gt;\end{array}}}} \\&lt;br/&gt;{{y_1} = {y_{\begin{array}{*{20}{c}}&lt;br/&gt;0 &amp;amp; 1 \\&lt;br/&gt;\end{array}}} + {y_{\begin{array}{*{20}{c}}&lt;br/&gt;1 &amp;amp; 1 \\&lt;br/&gt;\end{array}}}} \\&lt;br/&gt;{{y_2} = {y_{\begin{array}{*{20}{c}}&lt;br/&gt;0 &amp;amp; 2 \\&lt;br/&gt;\end{array}}} + {y_{\begin{array}{*{20}{c}}&lt;br/&gt;1 &amp;amp; 2 \\&lt;br/&gt;\end{array}}}} \\&lt;br/&gt;{{y_3} = {y_{\begin{array}{*{20}{c}}&lt;br/&gt;0 &amp;amp; 3 \\&lt;br/&gt;\end{array}}} + {y_{\begin{array}{*{20}{c}}&lt;br/&gt;1 &amp;amp; 3 \\&lt;br/&gt;\end{array}}}} \\&lt;br/&gt;\end{array}\]&lt;/p&gt;
&lt;p&gt;　　接下来再分别把这两个分割出来的NxN矩阵块分别转换为循环矩阵的形式。（这里只写出第一个，第二个块有兴趣的朋友自己推吧）&lt;/p&gt;
&lt;p&gt;\[\left[ {\begin{array}{*{20}{c}}&lt;br/&gt;\hfill { - 3} &amp;amp; \hfill 3 &amp;amp; \hfill 2 &amp;amp; \hfill 1 &amp;amp; \hfill 0 &amp;amp; \hfill { - 1} &amp;amp; \hfill { - 2} \\&lt;br/&gt;\hfill { - 2} &amp;amp; \hfill { - 3} &amp;amp; \hfill 3 &amp;amp; \hfill 2 &amp;amp; \hfill 1 &amp;amp; \hfill 0 &amp;amp; \hfill { - 1} \\&lt;br/&gt;\hfill { - 1} &amp;amp; \hfill { - 2} &amp;amp; \hfill { - 3} &amp;amp; \hfill 3 &amp;amp; \hfill 2 &amp;amp; \hfill 1 &amp;amp; \hfill 0 \\&lt;br/&gt;\hfill 0 &amp;amp; \hfill { - 1} &amp;amp; \hfill { - 2} &amp;amp; \hfill { - 3} &amp;amp; \hfill 3 &amp;amp; \hfill 2 &amp;amp; \hfill 1 \\&lt;br/&gt;\hfill 1 &amp;amp; \hfill 0 &amp;amp; \hfill { - 1} &amp;amp; \hfill { - 2} &amp;amp; \hfill { - 3} &amp;amp; \hfill 3 &amp;amp; \hfill 2 \\&lt;br/&gt;\hfill 2 &amp;amp; \hfill 1 &amp;amp; \hfill 0 &amp;amp; \hfill { - 1} &amp;amp; \hfill { - 2} &amp;amp; \hfill { - 3} &amp;amp; \hfill 3 \\&lt;br/&gt;\hfill 3 &amp;amp; \hfill 2 &amp;amp; \hfill 1 &amp;amp; \hfill 0 &amp;amp; \hfill { - 1} &amp;amp; \hfill { - 2} &amp;amp; \hfill { - 3} \\&lt;br/&gt;\end{array}} \right]\left[ {\begin{array}{*{20}{c}}&lt;br/&gt;{{w_0}} \\&lt;br/&gt;{{w_1}} \\&lt;br/&gt;{{w_2}} \\&lt;br/&gt;{{w_3}} \\&lt;br/&gt;0 \\&lt;br/&gt;0 \\&lt;br/&gt;0 \\&lt;br/&gt;\end{array}} \right] = \left[ {\begin{array}{*{20}{c}}&lt;br/&gt;\times \\&lt;br/&gt;\times \\&lt;br/&gt;\times \\&lt;br/&gt;{{y_{\begin{array}{*{20}{c}}&lt;br/&gt;0 &amp;amp; 0 \\&lt;br/&gt;\end{array}}}} \\&lt;br/&gt;{{y_{\begin{array}{*{20}{c}}&lt;br/&gt;0 &amp;amp; 1 \\&lt;br/&gt;\end{array}}}} \\&lt;br/&gt;{{y_{\begin{array}{*{20}{c}}&lt;br/&gt;0 &amp;amp; 2 \\&lt;br/&gt;\end{array}}}} \\&lt;br/&gt;{{y_{\begin{array}{*{20}{c}}&lt;br/&gt;0 &amp;amp; 3 \\&lt;br/&gt;\end{array}}}} \\&lt;br/&gt;\end{array}} \right]\]&lt;/p&gt;
&lt;p&gt;　　这样就可以方便的转到频域进行处理，再把每块的处理结果相加，就完成了分段分块的频域卷积运算。滤波器的系数更新也是同理&lt;/p&gt;
&lt;p&gt;　　另外，虽然2N-1个长度的频域复向量足以完成必要的卷积过程，实际算法中FFT长度通常取2N，这样计算更方便，这时分割后的第一个块的循环矩阵如下所示：&lt;/p&gt;
&lt;p&gt;\[\left[ {\begin{array}{*{20}{c}}&lt;br/&gt;\hfill { - 4} &amp;amp; \hfill 3 &amp;amp; \hfill 2 &amp;amp; \hfill 1 &amp;amp; \hfill 0 &amp;amp; \hfill { - 1} &amp;amp; \hfill { - 2} &amp;amp; \hfill { - 3} \\&lt;br/&gt;\hfill { - 3} &amp;amp; \hfill { - 4} &amp;amp; \hfill 3 &amp;amp; \hfill 2 &amp;amp; \hfill 1 &amp;amp; \hfill 0 &amp;amp; \hfill { - 1} &amp;amp; \hfill { - 2} \\&lt;br/&gt;\hfill { - 2} &amp;amp; \hfill { - 3} &amp;amp; \hfill { - 4} &amp;amp; \hfill 3 &amp;amp; \hfill 2 &amp;amp; \hfill 1 &amp;amp; \hfill 0 &amp;amp; \hfill { - 1} \\&lt;br/&gt;\hfill { - 1} &amp;amp; \hfill { - 2} &amp;amp; \hfill { - 3} &amp;amp; \hfill { - 4} &amp;amp; \hfill 3 &amp;amp; \hfill 2 &amp;amp; \hfill 1 &amp;amp; \hfill 0 \\&lt;br/&gt;\hfill 0 &amp;amp; \hfill { - 1} &amp;amp; \hfill { - 2} &amp;amp; \hfill { - 3} &amp;amp; \hfill { - 4} &amp;amp; \hfill 3 &amp;amp; \hfill 2 &amp;amp; \hfill 1 \\&lt;br/&gt;\hfill 1 &amp;amp; \hfill 0 &amp;amp; \hfill { - 1} &amp;amp; \hfill { - 2} &amp;amp; \hfill { - 3} &amp;amp; \hfill { - 4} &amp;amp; \hfill 3 &amp;amp; \hfill 2 \\&lt;br/&gt;\hfill 2 &amp;amp; \hfill 1 &amp;amp; \hfill 0 &amp;amp; \hfill { - 1} &amp;amp; \hfill { - 2} &amp;amp; \hfill { - 3} &amp;amp; \hfill { - 4} &amp;amp; \hfill 3 \\&lt;br/&gt;\hfill 3 &amp;amp; \hfill 2 &amp;amp; \hfill 1 &amp;amp; \hfill 0 &amp;amp; \hfill { - 1} &amp;amp; \hfill { - 2} &amp;amp; \hfill { - 3} &amp;amp; \hfill { - 4} \\&lt;br/&gt;\end{array}} \right]\left[ {\begin{array}{*{20}{c}}&lt;br/&gt;{{w_0}} \\&lt;br/&gt;{{w_1}} \\&lt;br/&gt;{{w_2}} \\&lt;br/&gt;{{w_3}} \\&lt;br/&gt;0 \\&lt;br/&gt;0 \\&lt;br/&gt;0 \\&lt;br/&gt;0 \\&lt;br/&gt;\end{array}} \right] = \left[ {\begin{array}{*{20}{c}}&lt;br/&gt;\times \\&lt;br/&gt;\times \\&lt;br/&gt;\times \\&lt;br/&gt;\times \\&lt;br/&gt;{{y_{\begin{array}{*{20}{c}}&lt;br/&gt;0 &amp;amp; 0 \\&lt;br/&gt;\end{array}}}} \\&lt;br/&gt;{{y_{\begin{array}{*{20}{c}}&lt;br/&gt;0 &amp;amp; 1 \\&lt;br/&gt;\end{array}}}} \\&lt;br/&gt;{{y_{\begin{array}{*{20}{c}}&lt;br/&gt;0 &amp;amp; 2 \\&lt;br/&gt;\end{array}}}} \\&lt;br/&gt;{{y_{\begin{array}{*{20}{c}}&lt;br/&gt;0 &amp;amp; 3 \\&lt;br/&gt;\end{array}}}} \\&lt;br/&gt;\end{array}} \right]\]&lt;/p&gt;
&lt;p&gt;　　另一个分割块也是同理，这里不再详细列出来，有兴趣的朋友可以自己手画一遍玩玩，上图有一个小细节的哦，循环矩阵的对角元素可以是任意的，不影响最终效果，但通常大家都取前一个块的第一个元素。&lt;/p&gt;
&lt;p&gt;　　剩下的活，就是前面转到频域的处理过程了，不再详述。&lt;/p&gt;
&lt;p&gt;　　最后还有一个问题，是不是分割（段）越多越好，也不再详细分析了，直接给出结果：不是分割数P越大越好。由于分割过程改变了输入向量，也就改变了输入向量相关矩阵特征值的扩散度（条件数）。当P越大时，特征值的扩散度就越大，算法收敛就越慢，也更容易出现发散的可能。&lt;/p&gt;
&lt;h2&gt;参考文献：&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;Advances in Network and Acoustic Echo Cancellation&lt;/li&gt;
&lt;li&gt;Adaptive Filters Theory and Applications Second Edition&lt;/li&gt;
&lt;li&gt;Adaptive Signal Processing Applications to Real-World Problems&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Wed, 15 Jan 2020 15:04:00 +0000</pubDate>
<dc:creator>爱酷媒</dc:creator>
<og:description>对在频域计算FIR自适应滤波器，同时避免使用长滤波器时产生的大延迟的技术进行详细的分解，也就是通常所说的PBFDAF技术，有的地方也叫做MDF。这个技术是很多频域自适应滤波器的基础。也是困惑很多人的地</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/icoolmedia/p/mdf_detailed.html</dc:identifier>
</item>
<item>
<title>Rust入坑指南：海纳百川 - Jackeyzhe</title>
<link>http://www.cnblogs.com/Jackeyzhe/p/12199191.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Jackeyzhe/p/12199191.html</guid>
<description>&lt;p&gt;今天来聊Rust中两个重要的概念：泛型和trait。很多编程语言都支持泛型，Rust也不例外，相信大家对泛型也都比较熟悉，它可以表示任意一种数据类型。trait同样不是Rust所特有的特性，它借鉴于Haskell中的Typeclass。简单来讲，Rust中的trait就是对类型行为的抽象，你可以把它理解为Java中的接口。&lt;/p&gt;
&lt;h3 id=&quot;泛型&quot;&gt;泛型&lt;/h3&gt;
&lt;p&gt;在前面的文章中，我们其实已经提及了一些泛型类型。例如Option、Vec和Result&amp;lt;T, E&amp;gt;。泛型可以在函数、数据结构、Enum和方法中进行定义。在Rust中，我们习惯使用T作为通用的类型名称，当然也可以是其他名称，只不过习惯上优先使用T（Type）来表示。它可以帮我们消除一些重复代码，例如实现逻辑相同但参数类型不同的两个函数，我们就可以通过泛型技术将其进行合并。下面我们分别演示泛型的几种定义。&lt;/p&gt;
&lt;h4 id=&quot;在函数中定义&quot;&gt;在函数中定义&lt;/h4&gt;
&lt;p&gt;泛型在函数的定义中，可以是参数，也可以是返回值。前提是必须要在函数名的后面加上。&lt;/p&gt;
&lt;pre class=&quot;rust&quot;&gt;
&lt;code&gt;fn largest&amp;lt;T&amp;gt;(list: &amp;amp;[T]) -&amp;gt; T {&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;在数据结构中定义&quot;&gt;在数据结构中定义&lt;/h4&gt;
&lt;p&gt;如果数据结构中某个字段可以接收任意数据类型，那么我们可以把这个字段的类型定义为T，同样的，为了让编译器认识这个T，我们需要在结构体名称后边标识一下。&lt;/p&gt;
&lt;pre class=&quot;rust&quot;&gt;
&lt;code&gt;struct Point&amp;lt;T&amp;gt; {
    x: T,
    y: T,
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的例子中，x和y都是可以接受任意类型，但是，它们两个的类型必须相同，如果传入的类型不同，编译器仍然会报错。那如果想要让x和y能够接受不同的类型应该怎么办呢？其实也很简单，我们定义两种不同的泛型就好了。&lt;/p&gt;
&lt;pre class=&quot;rust&quot;&gt;
&lt;code&gt;struct Point&amp;lt;T, U&amp;gt; {
    x: T,
    y: U,
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;在enum中定义&quot;&gt;在Enum中定义&lt;/h4&gt;
&lt;p&gt;在Enum中定义泛型我们已经接触过比较多了，最常见的例子就是Option和Result&amp;lt;T, E&amp;gt;。其定义方法也和在数据结构中的定义方法类似&lt;/p&gt;
&lt;pre class=&quot;rust&quot;&gt;
&lt;code&gt;enum Result&amp;lt;T, E&amp;gt; {
    Ok(T),
    Err(E),
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;在方法中定义&quot;&gt;在方法中定义&lt;/h4&gt;
&lt;p&gt;我们在实现定义了泛型的数据结构或Enum时，方法中也可以定义泛型。例如我们对刚刚定义的Point进行实现。&lt;/p&gt;
&lt;pre class=&quot;rust&quot;&gt;
&lt;code&gt;impl&amp;lt;T&amp;gt; Point&amp;lt;T&amp;gt; {
    fn x(&amp;amp;self) -&amp;gt; &amp;amp;T {
        &amp;amp;self.x
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，我们的方法返回值的类型是T的引用，为了让编译器识别T，我们必须要在&lt;code&gt;impl&lt;/code&gt;后面加上&lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;另外，我们在对结构体进行实现时，也可以实现指定的类型，这样就不需要在&lt;code&gt;impl&lt;/code&gt;后面加标识了。&lt;/p&gt;
&lt;pre class=&quot;rust&quot;&gt;
&lt;code&gt;impl Point&amp;lt;f32&amp;gt; {
    fn distance_from_origin(&amp;amp;self) -&amp;gt; f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;了解了泛型的几种定义之后，你有没有想过一个问题：Rust中使用泛型会对程序运行时的性能造成不良影响吗？答案是不会，因为Rust对于泛型的处理都是在编译阶段进行的，对于我们定义的泛型，Rust编译器会对其进行单一化处理，也就是说，我们定义一个具有泛型的函数（或者其他什么的），Rust会根据需要将其编译为具有具体类型的函数。&lt;/p&gt;
&lt;pre class=&quot;rust&quot;&gt;
&lt;code&gt;let integer = Some(5);
let float = Some(5.0);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例如我们的代码使用了这两种类型的Option，那么Rust编译器就会在编译阶段生成两个指定具体类型的Option。&lt;/p&gt;
&lt;pre class=&quot;rust&quot;&gt;
&lt;code&gt;enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样我们在运行阶段直接使用对应的Option就可以了，而不需要再进行额外复杂的操作。所以，如果我们泛型定义并使用的范围很大，也不会对运行时性能造成影响，受影响的只有编译后程序包的大小。&lt;/p&gt;
&lt;h3 id=&quot;trait&quot;&gt;Trait&lt;/h3&gt;
&lt;p&gt;Trait可以说是Rust的灵魂，Rust中所有的抽象都是依靠Trait来实现的。&lt;/p&gt;
&lt;p&gt;我们先来看看如何定义一个Trait。&lt;/p&gt;
&lt;pre class=&quot;rust&quot;&gt;
&lt;code&gt;pub trait Summary {
    fn summarize(&amp;amp;self) -&amp;gt; String;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定义trait使用了关键字&lt;code&gt;trait&lt;/code&gt;，后面跟着trait的名称。其内容是trait的「行为」，也就是一个个函数。但是这里的函数没有实现，而是直接以&lt;code&gt;;&lt;/code&gt;结尾。不过这这并不是必须的，Rust也支持下面这种写法：&lt;/p&gt;
&lt;pre class=&quot;rust&quot;&gt;
&lt;code&gt;pub trait Summary {
    fn summarize(&amp;amp;self) -&amp;gt; String {
        String::from(&quot;(Read more...)&quot;)
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于这样的写法，它表示summarize函数的默认实现。&lt;/p&gt;
&lt;h4 id=&quot;trait的实现&quot;&gt;Trait的实现&lt;/h4&gt;
&lt;p&gt;上面是一种默认实现，接下来我们介绍一下在Rust中，对一个Trait的常规实现。Trait的实现是需要针对结构体的，即我们要写明是哪个结构体的哪种行为。&lt;/p&gt;
&lt;pre class=&quot;rust&quot;&gt;
&lt;code&gt;pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&amp;amp;self) -&amp;gt; String {
        format!(&quot;{}, by {} ({})&quot;, self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summary for Tweet {
    fn summarize(&amp;amp;self) -&amp;gt; String {
        format!(&quot;{}: {}&quot;, self.username, self.content)
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述代码中，我们分别定义了结构体NewArticle和Tweet，然后为它们实现了trait，定义了summarize函数对应的逻辑。&lt;/p&gt;
&lt;h4 id=&quot;作为参数的trait&quot;&gt;作为参数的Trait&lt;/h4&gt;
&lt;p&gt;此外，trait还可以作为函数的参数，也就是需要传入一个实现了对应trait的结构体的实例。&lt;/p&gt;
&lt;pre class=&quot;rust&quot;&gt;
&lt;code&gt;pub fn notify(item: impl Summary) {
    println!(&quot;Breaking news! {}&quot;, item.summarize());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;作参数时，我们需要使用&lt;code&gt;impl&lt;/code&gt;关键字来定义参数类型。&lt;/p&gt;
&lt;p&gt;Rust还提供了另一种语法糖来，即&lt;strong&gt;Trait限定&lt;/strong&gt;，我们可以使用泛型约束的语法来限定Trait参数。&lt;/p&gt;
&lt;pre class=&quot;rust&quot;&gt;
&lt;code&gt;pub fn notify&amp;lt;T: Summary&amp;gt;(item: T) {
    println!(&quot;Breaking news! {}&quot;, item.summarize());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上述代码，我们可以通过Trait来限定泛型T的范围。这样的语法糖可以在多个参数的函数中帮助我们简化代码。下面两行代码就有比较明显的对比&lt;/p&gt;
&lt;pre class=&quot;rust&quot;&gt;
&lt;code&gt;pub fn notify(item1: impl Summary, item2: impl Summary) {

pub fn notify&amp;lt;T: Summary&amp;gt;(item1: T, item2: T) {&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果某个参数有多个trait限定，就可以使用&lt;code&gt;+&lt;/code&gt;来表示&lt;/p&gt;
&lt;pre class=&quot;rust&quot;&gt;
&lt;code&gt;pub fn notify&amp;lt;T: Summary + Display&amp;gt;(item: T) {&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果我们有更多的参数，并且有每个参数都有多个trait限定，及时我们使用了上面这种语法糖，代码仍然有些繁杂，会降低可读性。所以Rust又为我们提供了&lt;code&gt;where&lt;/code&gt;关键字。&lt;/p&gt;
&lt;pre class=&quot;rust&quot;&gt;
&lt;code&gt;fn some_function&amp;lt;T, U&amp;gt;(t: T, u: U) -&amp;gt; i32
    where T: Display + Clone,
          U: Clone + Debug
{&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它帮助我们在函数定义的最后写一个trait限定列表，这样可以使代码的可读性更高。&lt;/p&gt;
&lt;h4 id=&quot;trait作为返回值&quot;&gt;Trait作为返回值&lt;/h4&gt;
&lt;pre class=&quot;rust&quot;&gt;
&lt;code&gt;fn returns_summarizable() -&amp;gt; impl Summary {
    Tweet {
        username: String::from(&quot;horse_ebooks&quot;),
        content: String::from(&quot;of course, as you probably already know, people&quot;),
        reply: false,
        retweet: false,
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Trait作为返回值类型，和作为参数类似，只需要在定义返回类型时使用&lt;code&gt;impl Trait&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;本文我们简单介绍了泛型和Trait，包括它们的定义和使用方法。泛型主要是针对数据类型的一种抽象，而Trait则是对数据类型行为的一种抽象，Rust中并没有严格意义上的继承，多是用组合的形式。这也体现了「多组合，少继承」的设计思想。&lt;/p&gt;
&lt;p&gt;最后留个预告，这个坑还没完，我们下次继续往深处挖。&lt;/p&gt;
</description>
<pubDate>Wed, 15 Jan 2020 14:59:00 +0000</pubDate>
<dc:creator>Jackeyzhe</dc:creator>
<og:description>今天来聊Rust中两个重要的概念：泛型和trait。很多编程语言都支持泛型，Rust也不例外，相信大家对泛型也都比较熟悉，它可以表示任意一种数据类型。trait同样不是Rust所特有的特性，它借鉴于H</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Jackeyzhe/p/12199191.html</dc:identifier>
</item>
</channel>
</rss>