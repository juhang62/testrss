<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>HashMap,你知道多少？ - 玉树临枫</title>
<link>http://www.cnblogs.com/yuanfy008/p/10958041.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuanfy008/p/10958041.html</guid>
<description>&lt;p&gt;HashMap在面试中是个火热的话题，那么你能应付自如吗？下面抛出几个问题看你是否知道，如果知道那么本文对于你来说就不值一提了。&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;HashMap的内部数据结构是什么？&lt;/li&gt;
&lt;li&gt;HashMap扩容机制时什么？什么时候扩容？&lt;/li&gt;
&lt;li&gt;HashMap其长度有什么特征？为什么是这样？&lt;/li&gt;
&lt;li&gt;HashMap为什么线程不安全？并发的场景会出现什么的情况？&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;本文是基于JDK1.7.0_79版本进行研究的。&lt;/p&gt;

&lt;h3 id=&quot;2038-1559019535244&quot;&gt;1、类的继承关系&lt;/h3&gt;
&lt;div id=&quot;7634-1559032316498&quot; data-theme=&quot;default&quot; data-language=&quot;javascript&quot; readability=&quot;8.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; HashMap&amp;lt;K,V&amp;gt; &lt;span&gt;extends&lt;/span&gt; AbstractMap&amp;lt;K,V&amp;gt; &lt;span&gt;implements&lt;/span&gt; Map&amp;lt;K,V&amp;gt;, Cloneable, Serializable
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;其中继承了AbstractMap抽象类，别小看了这个抽象类哦，它实现了Map接口的许多重要方法，大大减少了实现此接口的工作量。&lt;/p&gt;
&lt;h3 id=&quot;7067-1559019535245&quot;&gt;2、属性解析&lt;/h3&gt;
&lt;h3 id=&quot;2819-1559032326377&quot;&gt;2.1、capacity：容量&lt;/h3&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;DEFAULT_INITIAL_CAPACITY&lt;/strong&gt;：默认的初始容量-必须是2的幂。为什么呢？先留个疑问在这&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * The default initial capacity - MUST be a power of two.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_INITIAL_CAPACITY = 1 &amp;lt;&amp;lt; 4; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; aka 16&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;MAXIMUM_CAPACITY&lt;/strong&gt;：最大容量为2^30。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;h3&gt;2.2 threshold：阈值&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * The next size value at which to resize (capacity * load factor).
 * &lt;/span&gt;&lt;span&gt;@serial&lt;/span&gt;
 &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; If table == EMPTY_TABLE then this is the initial capacity at which the
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; table will be created when inflated.&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; threshold;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从上面注释可以看出， 它的值是由容量和加载因子决定的。&lt;/p&gt;
&lt;h3 id=&quot;2250-1559040703119&quot;&gt;2.3 loadFactor：加载因子，默认为0.75&lt;/h3&gt;
&lt;div id=&quot;5580-1559040760760&quot; data-theme=&quot;default&quot; data-language=&quot;javascript&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * The load factor used when none specified in constructor.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; DEFAULT_LOAD_FACTOR = 0.75f;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&quot;6970-1559032487930&quot;&gt;2.4 size：键值对长度&lt;/h3&gt;
&lt;div id=&quot;7892-1559040943762&quot; data-theme=&quot;default&quot; data-language=&quot;javascript&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * The number of key-value mappings contained in this map.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;transient&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; size;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2.5 modCount：修改内部结构的次数&lt;/h3&gt;
&lt;/div&gt;
&lt;div id=&quot;5135-1559041163800&quot; data-theme=&quot;default&quot; data-language=&quot;javascript&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;transient&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; modCount;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;上面五个属性字段都很重要， 后面再分析体现其重要。&lt;/p&gt;

&lt;h3 id=&quot;3882-1559041559217&quot;&gt;3、底层数据结构&lt;/h3&gt;
&lt;div id=&quot;3050-1559041459472&quot; data-theme=&quot;default&quot; data-language=&quot;javascript&quot; readability=&quot;9&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Entry&amp;lt;?,?&amp;gt;[] EMPTY_TABLE =&lt;span&gt; {};

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * The table, resized as necessary. Length MUST Always be a power of two.
 * 这里也强调扩容时，长度必须是2的指数次幂
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;transient&lt;/span&gt; Entry&amp;lt;K,V&amp;gt;[] table = (Entry&amp;lt;K,V&amp;gt;[]) EMPTY_TABLE;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Entry内部结构如下：&lt;/p&gt;
&lt;div id=&quot;3069-1559041721372&quot; data-theme=&quot;default&quot; data-language=&quot;javascript&quot; readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Entry&amp;lt;K,V&amp;gt; &lt;span&gt;implements&lt;/span&gt; Map.Entry&amp;lt;K,V&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt;&lt;span&gt; K key;
    V value;
    Entry&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; next;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; hash;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;经分析后其数据结构为数组+链表的形式，展示图如下：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/src/AAD6BF3FCAAE4215973FA705F887CE15&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/690169/201905/690169-20190531230029537-946759634.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/src/AAD6BF3FCAAE4215973FA705F887CE15&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&quot;9613-1559043141771&quot;&gt;4、重要函数&lt;/h3&gt;
&lt;h3 id=&quot;8850-1559041200175&quot;&gt;4.1 构造函数&lt;/h3&gt;
&lt;p&gt;总共有四个构造函数， 主要分析含有两个参数的构造函数：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/690169/201905/690169-20190531230155492-424329469.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/src/F20D060F65B04A20AFD9EE2F5052A820&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;11&quot;&gt;其实这个构造函数也主要是初始化加载因子和阈值。（可能1.7的其他版本会有点不一样，会在构造函数中初始化table）
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; HashMap(&lt;span&gt;int&lt;/span&gt; initialCapacity, &lt;span&gt;float&lt;/span&gt;&lt;span&gt; loadFactor) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (initialCapacity &amp;lt; 0&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&quot;Illegal initial capacity: &quot; +&lt;span&gt;
                                           initialCapacity);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (initialCapacity &amp;gt;&lt;span&gt; MAXIMUM_CAPACITY)
        initialCapacity &lt;/span&gt;=&lt;span&gt; MAXIMUM_CAPACITY;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (loadFactor &amp;lt;= 0 ||&lt;span&gt; Float.isNaN(loadFactor))
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&quot;Illegal load factor: &quot; +&lt;span&gt;
                                           loadFactor);

    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.loadFactor =&lt;span&gt; loadFactor;
    threshold &lt;/span&gt;=&lt;span&gt; initialCapacity;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 供子类实现&lt;/span&gt;
&lt;span&gt;    init();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;h3 id=&quot;8877-1559049318185&quot;&gt;4.2 put()函数&lt;/h3&gt;
&lt;div id=&quot;3384-1559049500443&quot; data-theme=&quot;default&quot; data-language=&quot;javascript&quot; readability=&quot;16.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; V put(K key, V value) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1 如果table为空则需要初始化&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (table ==&lt;span&gt; EMPTY_TABLE) {
        inflateTable(threshold);
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2 如果key为空,则单独处理&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (key == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; putForNullKey(value);
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3 根据key获取hash值   &lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; hash =&lt;span&gt; hash(key);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 4 根据hash值和长度求取索引值。&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; i =&lt;span&gt; indexFor(hash, table.length);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 5 根据索引值获取数组下的链表进行遍历，判断元素是否存在相同的key&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (Entry&amp;lt;K,V&amp;gt; e = table[i]; e != &lt;span&gt;null&lt;/span&gt;; e =&lt;span&gt; e.next) {
        Object k;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e.hash == hash &amp;amp;&amp;amp; ((k = e.key) == key ||&lt;span&gt; key.equals(k))) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果相等，则将新值替换旧值&lt;/span&gt;
            V oldValue =&lt;span&gt; e.value;
            e.value &lt;/span&gt;=&lt;span&gt; value;
            e.recordAccess(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; oldValue;
        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 6 如果不存在重复的key, 则需要创建新的Entry，然后添加至链表中。
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 先将修改次数加一&lt;/span&gt;
    modCount++&lt;span&gt;;
    addEntry(hash, key, value, i);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;第一步：当table还没有初始化时，看下inflateTable()函数做了什么操作。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; inflateTable(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; toSize) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Find a power of 2 &amp;gt;= toSize&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; capacity =&lt;span&gt; roundUpToPowerOf2(toSize);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 其中阈值=容量*加载因子，然后再初始化数组。&lt;/span&gt;
    threshold = (&lt;span&gt;int&lt;/span&gt;) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1&lt;span&gt;);
    table &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Entry[capacity];
    initHashSeedAsNeeded(capacity);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;其中容量是根据toSize取第一个大于它的2的指数次幂的值， 如下，其中highestOneBit函数是返回其最高位的权值，用的最巧的就是(number - 1) &amp;lt;&amp;lt; 1 其实就是取number的倍数， 但综合使用却能取得&lt;span&gt;第一个大于等于该值的2的指数次幂&lt;/span&gt;。（用的牛逼）&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; roundUpToPowerOf2(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; number) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; assert number &amp;gt;= 0 : &quot;number must be non-negative&quot;;&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; number &amp;gt;=&lt;span&gt; MAXIMUM_CAPACITY
            &lt;/span&gt;?&lt;span&gt; MAXIMUM_CAPACITY
            : (number &lt;/span&gt;&amp;gt; 1) ? Integer.highestOneBit((number - 1) &amp;lt;&amp;lt; 1) : 1&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;接着看put函数的第二步：&lt;span&gt;当key为null时，会取数组下标为0的&lt;/span&gt;位置进行链表遍历，如果存在key=null，则替换值并返回。否则进入第六步（注意：索引值依然指定是0）。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div readability=&quot;9.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt;&lt;span&gt; V putForNullKey(V value) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 取数组下标为0的链表&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (Entry&amp;lt;K,V&amp;gt; e = table[0]; e != &lt;span&gt;null&lt;/span&gt;; e =&lt;span&gt; e.next) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e.key == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            V oldValue &lt;/span&gt;=&lt;span&gt; e.value;
            e.value &lt;/span&gt;=&lt;span&gt; value;
            e.recordAccess(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; oldValue;
        }
    }
    modCount&lt;/span&gt;++&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注意：索引值依然指定是0&lt;/span&gt;
    addEntry(0, &lt;span&gt;null&lt;/span&gt;, value, 0&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;第三步：根据key的hashCode求取hash值，这又是个神奇的算法，这里不做多解释。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div id=&quot;1100-1559053508612&quot; data-theme=&quot;default&quot; data-language=&quot;javascript&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; hash(Object k) {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; h =&lt;span&gt; hashSeed;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (0 != h &amp;amp;&amp;amp; k &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; String) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; sun.misc.Hashing.stringHash32((String) k);
    }
    
    h &lt;/span&gt;^=&lt;span&gt; k.hashCode();

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; This function ensures that hashCodes that differ only by
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; constant multiples at each bit position have a bounded
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; number of collisions (approximately 8 at default load factor).&lt;/span&gt;
    h ^= (h &amp;gt;&amp;gt;&amp;gt; 20) ^ (h &amp;gt;&amp;gt;&amp;gt; 12&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; h ^ (h &amp;gt;&amp;gt;&amp;gt; 7) ^ (h &amp;gt;&amp;gt;&amp;gt; 4&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;第四步：根据hash值和底层数组的长度计算索引下标。&lt;span&gt;因为数组的长度是2的幂，所以h &amp;amp; (length-1)运算其实就是h与（length-1）的取模运算&lt;/span&gt;。不得不服啊，将计算运用的如此高效。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div id=&quot;8187-1559053719547&quot; data-theme=&quot;default&quot; data-language=&quot;javascript&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; indexFor(&lt;span&gt;int&lt;/span&gt; h, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; length) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; assert Integer.bitCount(length) == 1 : &quot;length must be a non-zero power of 2&quot;;&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; h &amp;amp; (length-1&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;找个数验证下：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/690169/201905/690169-20190531230548897-32703954.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/src/A597BA97C037489BA72D5F8C5A66D717&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;第五步是验证是否有重复key,如果有则替换新值然后返回，源码很详细了就不再做解释了。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;第六步：是将值添加到entry数组中，详细看下addEntry()函数。&lt;span&gt;首先根据size和阈值判断是否需要扩容（进行两倍扩容），如果需要扩容则先扩容重新计算索引，则创建新的元素添加至数组&lt;/span&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div id=&quot;3487-1559054509957&quot; data-theme=&quot;default&quot; data-language=&quot;javascript&quot; readability=&quot;14.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; addEntry(&lt;span&gt;int&lt;/span&gt; hash, K key, V value, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; bucketIndex) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果长度大于阈值，则需要进行扩容&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; ((size &amp;gt;= threshold) &amp;amp;&amp;amp; (&lt;span&gt;null&lt;/span&gt; !=&lt;span&gt; table[bucketIndex])) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 进行2倍扩容&lt;/span&gt;
        resize(2 *&lt;span&gt; table.length);
        hash &lt;/span&gt;= (&lt;span&gt;null&lt;/span&gt; != key) ? hash(key) : 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 扩容之后因为长度变化了，需要重新计算下索引值。&lt;/span&gt;
        bucketIndex =&lt;span&gt; indexFor(hash, table.length);
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 然后进行添加元素&lt;/span&gt;
&lt;span&gt;    createEntry(hash, key, value, bucketIndex);
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; createEntry(&lt;span&gt;int&lt;/span&gt; hash, K key, V value, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; bucketIndex) {
    Entry&lt;/span&gt;&amp;lt;K,V&amp;gt; e =&lt;span&gt; table[bucketIndex];
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 往表头插入&lt;/span&gt;
    table[bucketIndex] = &lt;span&gt;new&lt;/span&gt; Entry&amp;lt;&amp;gt;&lt;span&gt;(hash, key, value, e);
    size&lt;/span&gt;++&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;10.5&quot;&gt;其中扩容机制resize()函数需要重点捞出来晒下：&lt;span&gt;newCapacity = 2 * length，理论上会进行两倍扩容但会根最大容量进行对比取最小， 创建新数组然后将就数组中的值拷贝至新数组（其中会重新计算索引下标），然后再赋值给table, 最后再重新计算阈值。&lt;/span&gt;
&lt;div class=&quot;cnblogs_code _mce_tagged_br&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; resize(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; newCapacity) {
    Entry[] oldTable &lt;/span&gt;=&lt;span&gt; table;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; oldCapacity =&lt;span&gt; oldTable.length;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 两倍容量与最大容量取最小&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (oldCapacity ==&lt;span&gt; MAXIMUM_CAPACITY) {
        threshold &lt;/span&gt;=&lt;span&gt; Integer.MAX_VALUE;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建新数组&lt;/span&gt;
    Entry[] newTable = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Entry[newCapacity];
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 拷贝数组（重新计算索引下标）&lt;/span&gt;
&lt;span&gt;    transfer(newTable, initHashSeedAsNeeded(newCapacity));
    table &lt;/span&gt;=&lt;span&gt; newTable;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 重新计算阈值&lt;/span&gt;
    threshold = (&lt;span&gt;int&lt;/span&gt;)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;　　接着看transfer()函数，多注意这个函数中循环的内容&lt;/p&gt;
&lt;div id=&quot;1533-1559224319437&quot; data-theme=&quot;default&quot; data-language=&quot;javascript&quot; readability=&quot;12.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; transfer(Entry[] newTable, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; rehash) {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; newCapacity =&lt;span&gt; newTable.length;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Entry&amp;lt;K,V&amp;gt;&lt;span&gt; e : table) {
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;null&lt;/span&gt; !=&lt;span&gt; e) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定一个next&lt;/span&gt;
            Entry&amp;lt;K,V&amp;gt; next =&lt;span&gt; e.next;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (rehash) {
                e.hash &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt; == e.key ? 0&lt;span&gt; : hash(e.key);
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 重新计算索引下标。&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; i =&lt;span&gt; indexFor(e.hash, newCapacity);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 头插法，&lt;/span&gt;
            e.next =&lt;span&gt; newTable[i];
            newTable[i] &lt;/span&gt;=&lt;span&gt; e;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 接着下个节点继续遍历&lt;/span&gt;
            e =&lt;span&gt; next;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　通过上面分析，其实put函数还是简单的，不是很绕。那么能从其中找到开头的第二和第三个问题的答案吗？下面总结下顺便回答下这两个问题：&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;1、&lt;strong&gt;数组长度不管是初始化还是扩容时，都始终保持是2的指数次幂。&lt;/strong&gt;&lt;/span&gt;为什么呢？下面我的分析：&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;能使元素均匀分布，增大空间利用率&lt;/span&gt;。put值时需要根据key的hash值与长度进行取模运算得到索引下标，如果是2的幂，那么length一定是偶数，则length-1一定是奇数，那么它对应的二进制的最后一位一定是1，所以它能保证h&amp;amp;（length-1）既能到奇数也能得到偶数，这样保证了散列的均匀性。相反如果不是2的幂，那么length-1可能是偶数，这样h&amp;amp;(length-1)得到的都是偶数，就会浪费一半的空间了。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;运算效率高效。位运算比%运算高效。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2、&lt;/span&gt;&lt;strong&gt;&lt;span&gt;重复key的值会被新值替换，允许key为空且统一放在下标为0的链表上。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、&lt;strong&gt;&lt;span&gt;当&lt;/span&gt;size大于等于阈值（容量*加载因子）时，会进行扩容&lt;/strong&gt;&lt;/span&gt;。扩容机制是：扩容量为原来数组长度的两倍，根据扩容量创建新数组然后进行数组拷贝，新元素落位需要重新计算索引下标。扩容后，阈值需要重新计算，需要插入的元素落位的索引下标也需要重新计算。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、扩容很耗时，而扩容的次数主要取决于加载因子的值，因为它决定这扩容的次数。下面讲下它的取值的重要性：&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;加载因子越小，优点：存储的冲突机会减少；缺点：扩容次数越多（消耗性能就越大）、同时浪费空间较大（很多空间还没用，就开始扩容了）&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;加载因子越大，有点：扩容次数较少，空间利用率高；缺点：冲突几率就变大了、链表（后面介绍）长度会变长，查找的效率降低。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;5、扩容时会重新计算索引下标。也就是所谓的rehash过程&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6、插入元素都是表头插入，而不是链表尾插入。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;4.3、get()函数&lt;/h3&gt;
&lt;div readability=&quot;14&quot;&gt;知道了put方法的原理，那么get方法就很简单了。
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; V get(Object key) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (key == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; getForNullKey();
    Entry&lt;/span&gt;&amp;lt;K,V&amp;gt; entry =&lt;span&gt; getEntry(key);

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt; == entry ? &lt;span&gt;null&lt;/span&gt;&lt;span&gt; : entry.getValue();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一步：如果key为空，则直接从table[0]所对应的链表中查找（应该还记得put的时候为null的key放在哪）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt;&lt;span&gt; V getForNullKey() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (size == 0&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Entry&amp;lt;K,V&amp;gt; e = table[0]; e != &lt;span&gt;null&lt;/span&gt;; e =&lt;span&gt; e.next) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e.key == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; e.value;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/src/56D65A7810904698BA57FE9097738528&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;p&gt;第二步：如果key不为空，则根据key获取hash值，然后再根据hash和length-1取模得到索引，然后再遍历索引对应的链表，存在与key相等的则返回。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/src/37AC937E5DFE4843AC4D6DC4F3F339B2&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;final&lt;/span&gt; Entry&amp;lt;K,V&amp;gt;&lt;span&gt; getEntry(Object key) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (size == 0&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; hash = (key == &lt;span&gt;null&lt;/span&gt;) ? 0&lt;span&gt; : hash(key);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Entry&amp;lt;K,V&amp;gt; e =&lt;span&gt; table[indexFor(hash, table.length)];
             e &lt;/span&gt;!= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
             e &lt;/span&gt;=&lt;span&gt; e.next) {
            Object k;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e.hash == hash &amp;amp;&amp;amp;&lt;span&gt;
                ((k &lt;/span&gt;= e.key) == key || (key != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; key.equals(k))))
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; e;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;h3 id=&quot;2656-1559228167383&quot;&gt;1、肯定不能保证数据的安全性，因为内部方法没有一个是线程安全的。&lt;/h3&gt;
&lt;h3 id=&quot;2733-1559228248142&quot;&gt;2、有时会出现死锁情况。为什么呢？下面列个场景简单分析下：&lt;/h3&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;假设当前容量为4， 有三个元素（a, b, c）都在table[2]下的链表中，另一个元素(d)在table[3]下。如图&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/690169/201905/690169-20190531231556066-169459484.png&quot; alt=&quot;&quot; width=&quot;283&quot; height=&quot;305&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/src/E76B9D80244F463FA157C2EA4212DF33&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;假设此时有A,B两个线程都要往map中put一个元素则都需要扩容，当遍历到table[2]时，假设线程B先进入循环体的第一步：e 指向a, next指向b, 如图：&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div id=&quot;3036-1559229448173&quot; data-theme=&quot;default&quot; data-language=&quot;javascript&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Entry&amp;lt;K,V&amp;gt; next = e.next;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/690169/201905/690169-20190531232401635-2108546323.png&quot; alt=&quot;&quot; width=&quot;298&quot; height=&quot;360&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/src/3C292C2CB9B947158AC05D37318DF861&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;此时线程B让出时间片，让A线程一直执行完扩容操作，最终落位同样也是落位到table[2],其链表元素已经倒序了。如图：&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/690169/201905/690169-20190531232442552-1836626201.png&quot; alt=&quot;&quot; width=&quot;394&quot; height=&quot;232&quot;/&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/src/FFC4FC998F1B454AB2F54C3EA84AA76E&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;A线程让出时间片，B线程操作：接着循环继续执行，执行到循环末尾的时候，table[2] 指向a, 同时 e 和 next 都是指向b,如图：&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div id=&quot;4848-1559229811430&quot; data-theme=&quot;default&quot; data-language=&quot;javascript&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 同理落位到2&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; i =&lt;span&gt; indexFor(e.hash, newCapacity);
e.next &lt;/span&gt;=&lt;span&gt; newTable[i];
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 指向a&lt;/span&gt;
newTable[i] =&lt;span&gt; e;
e &lt;/span&gt;= next;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/690169/201905/690169-20190531232542569-1498379744.png&quot; alt=&quot;&quot; width=&quot;390&quot; height=&quot;245&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/src/11E3688D73E146FC86F2F1F48A8B231C&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;接着第二轮循环， e = b, next = a, 进行第二轮循环后的结果是e = next 且 table[2] 指向b元素，b元素再指向a元素，如图：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/690169/201905/690169-20190531232701928-1836301490.png&quot; alt=&quot;&quot; width=&quot;410&quot; height=&quot;244&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/src/883135FA3DA4454C8694201AD817FE0A&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;接着第三轮循环， e = a, a的下个元素为null, 所以next = null，但是当执行到下面这步就改变形式了，e.next 又指向了b，此时a和b已经出现了环形。因为next = null，所以终止了循环。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div id=&quot;9663-1559230253376&quot; data-theme=&quot;default&quot; data-language=&quot;javascript&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
e.next = newTable[i];
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/690169/201905/690169-20190531232742732-424651424.png&quot; alt=&quot;&quot; width=&quot;467&quot; height=&quot;279&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/src/CC35D5AEAD1645BD90BD1B6CC1496CE4&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;此时，问题还没有直接产生。&lt;strong&gt;当调用get()函数查找一个不存在的Key，而这个Key的Hash结果恰好等于3的时候，由于位置3带有环形链表，所以程序将会进入死循环！&lt;/strong&gt;（上面图形均忽略四个元素和要插入元素的规划）&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;

&lt;div id=&quot;2042-1559228095436&quot;&gt;
&lt;ul&gt;&lt;li&gt;1、创建HashMap时，指定足够大的容量，减少扩容次数。最好为：需要存的实际个数/除以加载因子。可以使用guava包中的Maps.newHashMapWithExpectedSize()方法。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;为什么要这样指定大小呢？ 再去上面回顾下扩容时机吧&lt;/p&gt;
&lt;div id=&quot;4427-1559228807740&quot;&gt;
&lt;ul&gt;&lt;li&gt;2、不要在并发场景中使用HashMap，如硬要使用通过Collections工具类创建线程安全的map,如：Collections.synchronizedMap(new HashMap&amp;lt;String, Object&amp;gt;());&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;

</description>
<pubDate>Fri, 31 May 2019 15:33:00 +0000</pubDate>
<dc:creator>玉树临枫</dc:creator>
<og:description>一、前言 HashMap在面试中是个火热的话题，那么你能应付自如吗？下面抛出几个问题看你是否知道，如果知道那么本文对于你来说就不值一提了。 HashMap的内部数据结构是什么？ HashMap扩容机制</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yuanfy008/p/10958041.html</dc:identifier>
</item>
<item>
<title>Java泛型(T)与通配符？ - 爱我-中华</title>
<link>http://www.cnblogs.com/jinliang374003909/p/10949283.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jinliang374003909/p/10949283.html</guid>
<description>&lt;p&gt;前言：使用泛型的目的是利用Java编译机制，在编译过程中帮我们检测代码中不规范的有可能导致程序错误的代码。例如，我们都知道list容器可以持有任何类型的数据，所以我们可以把String类型和Integer等等同时可以放入同一个list容器中，但这种做法是极其危险的。在泛型机制中这种操作是编译不通过，会强制你修改。故帮我们减少了隐藏的bug.&lt;/p&gt;
&lt;h3&gt;一：泛型  T&lt;/h3&gt;
&lt;h4&gt;1.1  泛型用法&lt;/h4&gt;
&lt;p&gt;根据泛型使用的位置，即用在类(class)，属性(filed)和方法(method)的不同位置，我把它分别总结如下几种&lt;/p&gt;
&lt;p&gt;　　泛型类：即在类名后添加泛型标识(&amp;lt;T ....&amp;gt;)，表示该class持有的一种类型。&lt;/p&gt;
&lt;p&gt;　　泛型属性：泛型属性必须结合泛型类使用，用于接受泛型类持有的类型T&lt;/p&gt;
&lt;p&gt;　　泛型方法：即在方法的返回值前声明泛型&amp;lt;T extends ***&amp;gt;,该泛型T是对该方法的参数T的一种限定。&lt;/p&gt;
&lt;p&gt;　　备注1：如果泛型T没有被extends修饰（包含类和方法），我们称之为无界泛型，如果被extends修饰我们称之为有界泛型如下。&lt;/p&gt;
&lt;p&gt;　　备注2：如果方法参数中有泛型T，而方法的返回类型前没有泛型T，该类型不是泛型方法，而是泛型类。&lt;/p&gt;
&lt;p&gt;　　备注3：泛型方法常用在工具类中(即该方法只是一种工具)，即与类的实例对象关系(持有的方法无关)。&lt;/p&gt;
&lt;p&gt;　　备注4：当泛型方法中的泛型T与类中的泛型T同名时会产生警报，因为编译器不确定你要使用那个(方法中一个，类中也一个)持有对象。&lt;/p&gt;
&lt;h4&gt;1.2  有界泛型&lt;/h4&gt;
&lt;p&gt;　　相较于无界泛型（没有限定类型）&amp;lt;T&amp;gt;的用法，我们可以使用有界泛型&amp;lt;T extends ****&amp;gt;来限定类持有对象的范围，或泛型方法传入该方法参数的范围。以保证业务逻辑的正确执行。&lt;/p&gt;
&lt;p&gt;备注1：有界泛型只有上界(extends)，没有下界的用法(相比于通配符?)。&lt;/p&gt;
&lt;h4&gt;1.3  泛型继承&lt;/h4&gt;
&lt;p&gt;       一行代码加两幅图带你体会它与我们接口，抽象类和类的区别&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
ArrayList&amp;lt;String&amp;gt; arrayList = new ArrayList&amp;lt;&amp;gt;();
Object object = new Object();
//The method add(String) in the type ArrayList&amp;lt;String&amp;gt; is not applicable for the arguments (Object)
&lt;span&gt;arrayList.add(object)&lt;/span&gt;;//因为 ArrayList&amp;lt;String&amp;gt;不是 ArrayList&amp;lt;Object&amp;gt;的子类  。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1596007/201905/1596007-20190530151628867-1308901920.png&quot; alt=&quot;&quot; width=&quot;390&quot; height=&quot;180&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1596007/201905/1596007-20190530151650453-1909320653.png&quot; alt=&quot;&quot; width=&quot;252&quot; height=&quot;175&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;二：通配符？&lt;/h3&gt;
&lt;p&gt;     这是一段java官方对通配符的定义，In generic code, the question mark (&lt;tt&gt;?&lt;/tt&gt;), called the &lt;em&gt;wildcard&lt;/em&gt;, represents an unknown type. The wildcard can be used in a variety of situations: as the type of a parameter, field, or local variable; sometimes as a return type (though it is better programming practice to be more specific). The wildcard is never used as a type argument for a generic method invocation, a generic class instance creation, or a supertype.从这里我们可以看出通配符？是一种未知的类型。&lt;/p&gt;
&lt;p&gt;个人小结：常用在方法上(注意与泛型方法的区别，其不需要再方法的返回类型前声明)&lt;/p&gt;
&lt;h4&gt;2.1 上界通配&lt;/h4&gt;
&lt;p&gt; 　　即定义通配符的上界，用关键字extends声明，例如&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;public static void process（List &lt;/span&gt;&lt;strong&gt;&amp;lt;？extends Foo&amp;gt;&lt;/strong&gt;&lt;span&gt; list）{/ * ... * /}&lt;/span&gt;
&lt;/pre&gt;
&lt;h4&gt;2.2 无界通配&lt;/h4&gt;
&lt;p&gt;　　即不限制通配符的界限，不需要任何关键字修饰‘？’，例如&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;public static void printList（List &amp;lt;？&amp;gt; list）{/*........*/}&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;说明其功能形式 public static void printList（List &amp;lt;Object&amp;gt; list）{/*........*/}，但还是有区别的。&lt;/p&gt;
&lt;p&gt;　　注意：&lt;tt&gt;List &amp;lt;Object&amp;gt;&lt;/tt&gt;&lt;span&gt;和&lt;/span&gt;&lt;tt&gt;List &amp;lt;？&amp;gt;&lt;/tt&gt;&lt;span&gt;&lt;span&gt;是不一样的。List &amp;lt;Object&amp;gt; &lt;/span&gt;&lt;span&gt;可以插入Object&lt;/span&gt;&lt;/span&gt;&lt;span&gt;，或任何Object&lt;/span&gt;&lt;tt&gt;对象的子类&lt;/tt&gt;&lt;span&gt;，成&lt;/span&gt;&lt;tt&gt;列表&amp;lt;对象&amp;gt;&lt;/tt&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;但是你只能&lt;/span&gt;&lt;span&gt;在&lt;/span&gt;&lt;tt&gt;&lt;span&gt;List &amp;lt;？&amp;gt;中&lt;/span&gt;&lt;/tt&gt;&lt;span&gt;插入&lt;/span&gt;&lt;/span&gt;&lt;tt&gt;null()&lt;/tt&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class TestWildcard {
        public  void printList(List&amp;lt;String&amp;gt; list) {
                for (Object elem: list)
                System.out.print(elem + &quot; &quot;);
            System.out.println();
        }
        public  void printList2(List&amp;lt;?&amp;gt; list) {
            for (Object elem: list)
                System.out.print(elem + &quot; &quot;);
            System.out.println();
        }
        public static void main(String[] args) {
                TestWildcard testWildcard = new TestWildcard();
                ArrayList&amp;lt;? extends Object&amp;gt; arrayList = new ArrayList&amp;lt;&amp;gt;();
                ArrayList&amp;lt;Object&amp;gt; arrayList2 = new ArrayList&amp;lt;&amp;gt;();
                arrayList.add(null);
                //arrayList.add(testWildcard);
                arrayList2.add(null);
                arrayList2.add(&quot;2&quot;);
                
                
                List&amp;lt;Integer&amp;gt; li = Arrays.asList(1, 2, 3);
                List&amp;lt;String&amp;gt;  ls = Arrays.asList(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;);
                testWildcard.printList2(li);
                testWildcard.printList2(ls);    
                //testWildcard.printList(li);报错
                testWildcard.printList(ls);
                
        }
}　
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;2.3 下届通配&lt;/h4&gt;
&lt;p&gt;  即定义通配符的下super界，用关键字extends声明，例如&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;public static void addNumbers（List &amp;lt;？super Integer&amp;gt; list）{}&lt;/span&gt;
&lt;/pre&gt;
&lt;h4&gt;2.4 通配子类&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1596007/201905/1596007-20190531163348716-861872287.png&quot; alt=&quot;&quot;/&gt;                                 &lt;img src=&quot;https://img2018.cnblogs.com/blog/1596007/201905/1596007-20190531163356441-367972944.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;The common parent is &lt;tt&gt;List&amp;lt;?&amp;gt;&lt;/tt&gt;.                                                               A hierarchy of several generic &lt;tt&gt;List&lt;/tt&gt; class declarations.&lt;/p&gt;
&lt;h4&gt;2.5 通配捕获与辅助方法&lt;/h4&gt;
&lt;p&gt;通配捕获：即操作通配符？参数  会抛出异常，除null外，例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class WildcardError {
    void foo(List&amp;lt;?&amp;gt; i) {
        i.set(0, i.get(0));
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;分析：根据编译器推断,?是一个Object类型(故可以遍历出？所代表的对象)，但如果要操作List&amp;lt;?&amp;gt;对象,编译器会要求？代表的具体类型，而编译器通过现有的规则(真对 ？的规则)是不允许的，故会包错。&lt;/p&gt;
&lt;p&gt;解决捕获辅助方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class WildcardFixed {
    void foo(List&amp;lt;?&amp;gt; i) {
        fooHelper(i);
    }
    // Helper method created so that the wildcard can be captured
    // through type inference.
    private &amp;lt;T&amp;gt; void fooHelper(List&amp;lt;T&amp;gt; l) {
        l.set(0, l.get(0));
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　通过一个辅助方法  ***  fooHelper(List&amp;lt;T&amp;gt; l){}就解决了&lt;/p&gt;
&lt;p&gt;分析：根据规则(真对T)，编译器就知道T的具体类型，故可以安全的操作该对象。&lt;/p&gt;
&lt;p&gt;三：小结&lt;/p&gt;
&lt;p&gt;泛型与通配符区别：最根本的区别就是，java编译器，把T(泛型)推断成具体类型，而把通配符?推断成未知类型。而java编辑器只能操作具体类型，不能操作未知类型。导致如果有对参数有修改的操作就必须要使用泛型，如果仅是查看就可以使用通配符.&lt;/p&gt;
&lt;p&gt;利用以上推断，我们可以利用通配符特性设计出安全的接口，比如我在一个接口的方法定义了通配符参数，则继承该接口的所有方法，都不能修改该方法传递过来的参数。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
public interface GInterface {
        
        &amp;lt;T&amp;gt; void foo(List&amp;lt;? extends T&amp;gt; list);
}



public class GIterfaceImpl implements GInterface{

        @Override
        public &amp;lt;T&amp;gt; void foo(List&amp;lt;? extends T&amp;gt; list) {
                /**
                 * 只能遍历list，不能修改list
                 */
                for (T t : list) {
                        System.out.println(t);
                }
                //list.add(new Object());
        }
        
        public static void main(String[] args) {
                GIterfaceImpl gIterfaceImpl = new GIterfaceImpl();
                ArrayList&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
                list.add(&quot;1&quot;);
                gIterfaceImpl.foo(list);
                
        }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;四：延伸&lt;/p&gt;
&lt;p&gt;泛型与java8:&lt;/p&gt;
&lt;p&gt;参考资料：&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/generics/index.html&quot;&gt;https://docs.oracle.com/javase/tutorial/java/generics/index.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 31 May 2019 15:06:00 +0000</pubDate>
<dc:creator>爱我-中华</dc:creator>
<og:description>前言：使用泛型的目的是利用Java编译机制，在编译过程中帮我们检测代码中不规范的有可能导致程序错误的代码。例如，我们都知道list容器可以持有任何类型的数据，所以我们可以把String类型和Integ</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jinliang374003909/p/10949283.html</dc:identifier>
</item>
<item>
<title>Entitas实现简析 - blueberryzzz</title>
<link>http://www.cnblogs.com/blueberryzzz/p/10957921.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/blueberryzzz/p/10957921.html</guid>
<description>&lt;p&gt;  这里主要讲Entitas的执行原理，不讲Entitas的代码生成方面。&lt;/p&gt;

&lt;p&gt;  ECS(实体-组件-系统)是一种常用于游戏开发的架构模式。&lt;br/&gt;  &lt;strong&gt;实体：&lt;/strong&gt; 实体只是一个ID或一个容器，用来标记或存储一系列组件。&lt;br/&gt;  &lt;strong&gt;组件：&lt;/strong&gt; 没有任何逻辑，单纯用来存储数据。&lt;br/&gt;  &lt;strong&gt;系统：&lt;/strong&gt; 循环处理特定的组件。&lt;br/&gt;  &lt;strong&gt;ECS主要强调了两个方面：&lt;/strong&gt;&lt;br/&gt;  1.用数据的组合去描述对象，而不是继承。&lt;br/&gt;  2.数据和逻辑的分离。&lt;/p&gt;

&lt;p&gt;  Unity采用了EC的设计思路，和传统ECS不同，Unity的Component除了存储数据，还保留了操作Component中数据的方法。&lt;br/&gt;  Unity中的Entiy就是GameObject，Component就是GameObject上挂载的组件各种组件，如Transform。&lt;br/&gt;  GameObject是各种Component的容器，本身并没有实际意义(与ECS中Entity的定义略有不同，GameObject包含了tag、name、activeSelf等属性。如果是在纯粹的ECS系统中，tag等属性应该作为Component挂载在GameObject)。&lt;br/&gt;  比如场景中的一个Cube，由Transform、MeshFilter、MeshRenderer、BoxCollider四个组件组成。我们能在场景中看到这个Cube是因为Unity从MeshFilter得到了Mesh信息，告诉了GPU这是一个立方体，从MeshRenderer中的到了渲染这个Mesh的信息，告诉GPU这个Mesh上的UV对应的是哪张贴图的坐标，渲染成什么颜色等信息。从Transform中得知了该将这个Cube渲染在哪个位置，旋转多少度等。Unity通过BoxCollider和Transform信息去做碰撞检测。(在Cube的渲染这个例子中，可以把Unity自身看作ECS中的System的集合，因为Unity中的各个模块获取了这个Cube中&lt;strong&gt;特定&lt;/strong&gt;Component中的信息，根据这些信息做一些事情)&lt;br/&gt;  &lt;strong&gt;Unity中的EC与传统ECS最大的两个区别就是：&lt;/strong&gt;&lt;br/&gt;  1.Entity上带着一些属性数据name、tag等，Component不仅有数据，还集成了大量的方法。比如在Unity中希望旋转一个Transform会直接调用Transform的Rotate方法，而在传统ECS中，很可能是在Cube这个Entity上挂载一个Rotate组件，然后由专门的RotateSystem去处理这个转动。&lt;br/&gt;  2.没有System对Component进行统一的处理。&lt;/p&gt;

&lt;p&gt;  Entitas是一个用C#实现的ECS框架，提供了方便的代码生成功能。&lt;br/&gt;  用法的介绍官方项目写的比较详细，这里就不多做介绍。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1362861/201905/1362861-20190531225036556-1995562595.png&quot;/&gt;&lt;br/&gt;  也就是说整个ECS系统的内部数据维护(Group、Collector、EntityIndex)复杂度主要放在Entity的修改上了。&lt;br/&gt;  在给一个Entity添加一个Component时，不仅仅是对Entity进行了修改，还会通过事件将这个添加传递给Context，Context遍历所有Group，找到满足这次修改条件的Group，对所有受到影响的Group进行修改。然后再通过Group将这次修改事件分发到Collector或其他监听该Group的模块中去。&lt;br/&gt;  这种方式带来的好处十分明显，那就是获取一种类型的Entity（也就是一个Group），只有第一次会遍历所有的Entity生成这个Group，之后再获取该类型Entity的复杂度就只有O(1)。&lt;br/&gt;  但是也有一定的隐患，当Group和Collector比较少时，这不是一个高消耗操作，但是Group、Collector很多，且在每一帧对Entity进行频繁修改的时候。这可能会成为一个高消耗操作。&lt;/p&gt;

&lt;p&gt;  1.在销毁一个Entity时，会移除Entity身上所有的Component，然后再进行回收。在移除Component时可能会通过Group把这个移除事件发送到监听Remove行为的Collector中，Collector会持有这个被销毁的Entity。所以在filter、或execute时不能直接依赖Collector的收集条件，还需要对Entity的Component做独立的判断。&lt;br/&gt;  其实任何时候filter都需要对Entity的Component做判断，因为Collector收集的Entity很可能在其他地方被改变。&lt;/p&gt;
&lt;p&gt;  2.Entity不应该被ECS系统外的模块持有，因为系统外对Entity的持有不会被自动引用计数（可以自己添加）。可能会导致一个Entity被销毁然后又从池子中重新取出来， 外部模块对这个Entity的引用没有改变，但已经可能不是自己持有的那个Entity了。&lt;br/&gt;  需要避免在外界持有Entity或通过持有uuid间接从context中持有这个Entity。&lt;/p&gt;
&lt;p&gt;  3.在replaceComponent时，发送了Remove、Add、Update三个事件，而不是只发送了Update事件。&lt;/p&gt;
&lt;p&gt;  4.在代码生成时，对单Componet的Matcher进行了缓存，如游戏中常用的Postion和Name等Component，但是对组合Component的Matcher没有进行缓存。所在在两个不同的ReactiveSystem中使用Matcher相同的Collector时，如：&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;//1,2代表Postion和Name的Index
//在使用代码生成时会生成类似Matcher.Position、Matcher.Name的静态函数，方便开发者使用
context.CreateCollector(Matcher.AllOf(1,2));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  这样会生成两个Matcher相同的Group实例。&lt;br/&gt;  如果在意这一点的话可以自己对Matcher进行缓存。&lt;/p&gt;

&lt;p&gt;  在对ECS架构模式的理解和Entitas的使用上我还是一个新手，只是刚刚开始使用，如果有什么写的不对的地方，各位大佬可以留言指正。&lt;/p&gt;
</description>
<pubDate>Fri, 31 May 2019 14:51:00 +0000</pubDate>
<dc:creator>blueberryzzz</dc:creator>
<og:description>Entitas实现简析   这里主要讲Entitas的执行原理，不讲Entitas的代码生成方面。 ECS简介   ECS(实体 组件 系统)是一种常用于游戏开</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/blueberryzzz/p/10957921.html</dc:identifier>
</item>
<item>
<title>算法图解之快速排序 - 挑战者V</title>
<link>http://www.cnblogs.com/youcong/p/10957896.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/youcong/p/10957896.html</guid>
<description>&lt;h2&gt;&lt;span id=&quot;分而治之又称dampc&quot;&gt;分而治之(又称D&amp;amp;C)&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;书中举了一个例子，假设你是农场主，有一块土地，如图所示:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1255290/201905/1255290-20190531224002515-1499324441.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;你要将这块地均匀分成方块，且分出的方块要尽可能大。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1255290/201905/1255290-20190531224042315-1940322854.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;从图上看，显然是不符合预期结果的。&lt;/p&gt;&lt;p&gt;那么如何将一块地均匀分成方块，并确保分出的方块是最大的呢？使用D&amp;amp;C策略。&lt;/p&gt;
&lt;p&gt;(1)D&amp;amp;C算法是递归的;&lt;br/&gt;(2)使用D&amp;amp;C解决问题的过程包括两个步骤:&lt;br/&gt;a.找出基线条件，这种条件必须尽可能简单;&lt;br/&gt;b.不断将问题分解(或者说缩小规模)，直到符合基线条件;&lt;/p&gt;
&lt;p&gt;就如何保证分出的方块是最大的呢？《算法图解》中的快速排序一章提到了欧几里得算法。&lt;/p&gt;
&lt;p&gt;什么是欧几里得算法?&lt;br/&gt;欧几里得算法又称辗转相除法，是指用于计算两个正整数a,b的最大公约数。&lt;br/&gt;应用领域有数学和计算机两个方面。&lt;/p&gt;
&lt;p&gt;举个代码例子说一下欧几里得算法:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package cn.pratice.simple;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Euclid {

    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; m = &lt;span&gt;63&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n = &lt;span&gt;18&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; remainer = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(n!=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
            remainer &lt;/span&gt;= m %&lt;span&gt; n;
            m &lt;/span&gt;=&lt;span&gt; n;
            n &lt;/span&gt;=&lt;span&gt; remainer;
        }
        
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt;.println(m);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;最终的结果是9，正好63和18的最大公因数也是9.&lt;br/&gt;其中也体现着分而治之的思想。记住，分而治之并非可用于解决问题的算法而是一种解决问题的思路。&lt;/p&gt;
&lt;p&gt;再举个例子说明，如图所示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1255290/201905/1255290-20190531224106809-2033648947.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;需要将这些数字相加，并返回结果，使用循环很容易完成这种任务，以Java为例:&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package cn.pratice.simple;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Euclid {

    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; []num = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[] {&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;&lt;span&gt;};
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; total = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; num.length; i++&lt;span&gt;) {
            total &lt;/span&gt;+=&lt;span&gt; num[i];
                    
        }
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt;.println(total);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span id=&quot;快速排序&quot;&gt;快速排序&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;快速排序是一种常用的排序算法，比选择排序快的多。&lt;br/&gt;代码示例如下(快速排序):&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package cn.pratice.simple;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; QuickSort {
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明静态的 getMiddle() 方法，该方法需要返回一个 int 类型的参数值，在该方法中传入 3 个参数&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; getMiddle(&lt;span&gt;int&lt;/span&gt;[] list,&lt;span&gt;int&lt;/span&gt; low,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; high) {
        
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; tmp = list[low];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数组的第一个值作为中轴(分界点或关键数据)&lt;/span&gt;
        
        &lt;span&gt;while&lt;/span&gt;(low&amp;lt;&lt;span&gt;high) {
            
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(low&amp;lt;high &amp;amp;&amp;amp; list[high]&amp;gt;&lt;span&gt;tmp) {
                high&lt;/span&gt;--&lt;span&gt;;
            }
            
            list[low] &lt;/span&gt;= list[high];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;比中轴小的记录移到低端&lt;/span&gt;
            
            &lt;span&gt;while&lt;/span&gt;(low&amp;lt;high&amp;amp;&amp;amp;list[low]&amp;lt;&lt;span&gt;tmp) {
                low&lt;/span&gt;++&lt;span&gt;;
            }
            
            list[high]&lt;/span&gt;=list[low];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;比中轴大的记录移到高端&lt;/span&gt;
&lt;span&gt;        }
        
        list[low] &lt;/span&gt;= tmp;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;中轴记录到尾&lt;/span&gt;
        
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; low;
    }
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建静态的 unckSort() 方法，在该方法中判断 low 参数是否小于 high 参数，如果是则调用 getMiddle() 方法，将数组一分为二，并且调用自身的方法进行递归排序&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; unckSort(&lt;span&gt;int&lt;/span&gt;[] list,&lt;span&gt;int&lt;/span&gt; low,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; high) {
        
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(low&amp;lt;&lt;span&gt;high) {
            
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; middle = getMiddle(list,low,high);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将list数组一分为二&lt;/span&gt;
            unckSort(list,low,middle-&lt;span&gt;1&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对低字表进行递归排序&lt;/span&gt;
            unckSort(list,middle+&lt;span&gt;1&lt;/span&gt;,high);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对高字表进行递归排序&lt;/span&gt;
&lt;span&gt;        }
    }
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明静态的 quick() 方法，在该方法中判断传入的数组是否为空，如果不为空，则调用 unckSort() 方法进行排序&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; quick(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] str) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(str.length&amp;gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;查看数组是否为空&lt;/span&gt;
            unckSort(str,&lt;span&gt;0&lt;/span&gt;,str.length-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
        }
    }
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;测试&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;[] number = {&lt;span&gt;13&lt;/span&gt;,&lt;span&gt;15&lt;/span&gt;,&lt;span&gt;24&lt;/span&gt;,&lt;span&gt;99&lt;/span&gt;,&lt;span&gt;14&lt;/span&gt;,&lt;span&gt;11&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;&lt;span&gt;};
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;排序前:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i : number) {
            System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.print(i+&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
        
        quick(number);
        
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r排序后:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i : number) {
            System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.print(i+&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此示例来自&lt;a href=&quot;http://c.biancheng.net/view/929.html&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;Java数组排序：Java快速排序（Quicksort）法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;没有什么比代码示例来的直接痛快。&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;再谈大o表示法&quot;&gt;再谈大O表示法&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;快速排序的独特之处在于，其速度取决于选择的基准值。&lt;/p&gt;
&lt;p&gt;常见的大O运行时间图，如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1255290/201905/1255290-20190531224155856-1146862621.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;上述图表中的时间是基于每秒执行10次操作计算得到的。这些数据并不准确，这里提供它们只是想让你对这些运行时间的差别有大致认识。实际上，计算机每秒执行的操作远远不止10次。 在该节中，作者说合并排序比选择排序要快的多。合并排序，用数学公式表示为O(n log n)，而选择排序为O(n的2次方)。&lt;br/&gt;合并代码排序例子如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package cn.pratice.simple;

import java.util.Arrays;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MergeSort {



    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; mergeSort(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] original) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (original == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; NullPointerException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;The array can not be null !!!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; length =&lt;span&gt; original.length;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (length &amp;gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; middle = length / &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; partitionA[] = Arrays.copyOfRange(original, &lt;span&gt;0&lt;/span&gt;, middle);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 拆分问题规模&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; partitionB[] =&lt;span&gt; Arrays.copyOfRange(original, middle, length);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 递归调用&lt;/span&gt;
&lt;span&gt;            mergeSort(partitionA);
            mergeSort(partitionB);
            sort(partitionA, partitionB, original);
        }
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; sort(&lt;span&gt;int&lt;/span&gt;[] partitionA, &lt;span&gt;int&lt;/span&gt;[] partitionB, &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] original) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; k = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (i &amp;lt; partitionA.length &amp;amp;&amp;amp; j &amp;lt;&lt;span&gt; partitionB.length) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (partitionA[i] &amp;lt;=&lt;span&gt; partitionB[j]) {
                original[k] &lt;/span&gt;=&lt;span&gt; partitionA[i];
                i&lt;/span&gt;++&lt;span&gt;;
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                original[k] &lt;/span&gt;=&lt;span&gt; partitionB[j];
                j&lt;/span&gt;++&lt;span&gt;;
            }
            k&lt;/span&gt;++&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i ==&lt;span&gt; partitionA.length) {
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (k &amp;lt;&lt;span&gt; original.length) {
                original[k] &lt;/span&gt;=&lt;span&gt; partitionB[j];
                k&lt;/span&gt;++&lt;span&gt;;
                j&lt;/span&gt;++&lt;span&gt;;
            }
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (j ==&lt;span&gt; partitionB.length) {
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (k &amp;lt;&lt;span&gt; original.length) {
                original[k] &lt;/span&gt;=&lt;span&gt; partitionA[i];
                k&lt;/span&gt;++&lt;span&gt;;
                i&lt;/span&gt;++&lt;span&gt;;
            }
        }
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; print(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] array) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (array == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; NullPointerException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;The array can not be null !!!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
        StringBuilder sb &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; StringBuilder(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt;&lt;span&gt; element : array) {
            sb.append(element &lt;/span&gt;+ &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
        sb.replace(sb.length() &lt;/span&gt;- &lt;span&gt;2&lt;/span&gt;, sb.length(), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt;.println(sb.toString());
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; startTime = System.currentTimeMillis();    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取开始时间&lt;/span&gt;

        &lt;span&gt;int&lt;/span&gt; original[] = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[] { &lt;span&gt;13&lt;/span&gt;,&lt;span&gt;15&lt;/span&gt;,&lt;span&gt;24&lt;/span&gt;,&lt;span&gt;99&lt;/span&gt;,&lt;span&gt;14&lt;/span&gt;,&lt;span&gt;11&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;&lt;span&gt; };
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; original.length; i++&lt;span&gt;) {
            System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.print(original[i]+&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
        mergeSort(original);
        print(original);
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; endTime = System.currentTimeMillis();    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取结束时间&lt;/span&gt;
&lt;span&gt;
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;程序运行时间：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + (endTime - startTime) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ms&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出程序运行时间&lt;/span&gt;
&lt;span&gt;        
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此示例来自&lt;a href=&quot;https://blog.csdn.net/hjxaslzyy/article/details/61463470&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;&lt;br/&gt;java实现合并排序算法&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;比较快速排序与合并排序&quot;&gt;比较快速排序与合并排序&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;还是以上面的代码例子为例:&lt;br/&gt;快速排序代码例子，如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;81&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; getMiddle(&lt;span&gt;int&lt;/span&gt;[] list,&lt;span&gt;int&lt;/span&gt; low,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; high) {
        
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; tmp = list[low];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数组的第一个值作为中轴(分界点或关键数据)&lt;/span&gt;
        
        &lt;span&gt;while&lt;/span&gt;(low&amp;lt;&lt;span&gt;high) {
            
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(low&amp;lt;high &amp;amp;&amp;amp; list[high]&amp;gt;&lt;span&gt;tmp) {
                high&lt;/span&gt;--&lt;span&gt;;
            }
            
            list[low] &lt;/span&gt;= list[high];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;比中轴小的记录移到低端&lt;/span&gt;
            
            &lt;span&gt;while&lt;/span&gt;(low&amp;lt;high&amp;amp;&amp;amp;list[low]&amp;lt;&lt;span&gt;tmp) {
                low&lt;/span&gt;++&lt;span&gt;;
            }
            
            list[high]&lt;/span&gt;=list[low];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;比中轴大的记录移到高端&lt;/span&gt;
&lt;span&gt;        }
        
        list[low] &lt;/span&gt;= tmp;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;中轴记录到尾&lt;/span&gt;
        
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; low;
    }
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建静态的 unckSort() 方法，在该方法中判断 low 参数是否小于 high 参数，如果是则调用 getMiddle() 方法，将数组一分为二，并且调用自身的方法进行递归排序&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; unckSort(&lt;span&gt;int&lt;/span&gt;[] list,&lt;span&gt;int&lt;/span&gt; low,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; high) {
        
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(low&amp;lt;&lt;span&gt;high) {
            
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; middle = getMiddle(list,low,high);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将list数组一分为二&lt;/span&gt;
            unckSort(list,low,middle-&lt;span&gt;1&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对低字表进行递归排序&lt;/span&gt;
            unckSort(list,middle+&lt;span&gt;1&lt;/span&gt;,high);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对高字表进行递归排序&lt;/span&gt;
&lt;span&gt;        }
    }
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明静态的 quick() 方法，在该方法中判断传入的数组是否为空，如果不为空，则调用 unckSort() 方法进行排序&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; quick(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] str) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(str.length&amp;gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;查看数组是否为空&lt;/span&gt;
            unckSort(str,&lt;span&gt;0&lt;/span&gt;,str.length-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
        }
    }
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;测试&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; startTime = System.currentTimeMillis();    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取开始时间&lt;/span&gt;

        &lt;span&gt;int&lt;/span&gt;[] number = { &lt;span&gt;13&lt;/span&gt;,&lt;span&gt;15&lt;/span&gt;,&lt;span&gt;24&lt;/span&gt;,&lt;span&gt;99&lt;/span&gt;,&lt;span&gt;14&lt;/span&gt;,&lt;span&gt;11&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;32&lt;/span&gt;,&lt;span&gt;4321&lt;/span&gt;,&lt;span&gt;432&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;14&lt;/span&gt;,&lt;span&gt;153&lt;/span&gt;,&lt;span&gt;23&lt;/span&gt;,&lt;span&gt;42&lt;/span&gt;,&lt;span&gt;12&lt;/span&gt;,&lt;span&gt;34&lt;/span&gt;,&lt;span&gt;15&lt;/span&gt;,&lt;span&gt;312&lt;/span&gt;,&lt;span&gt;12&lt;/span&gt;,&lt;span&gt;43&lt;/span&gt;,&lt;span&gt;3214&lt;/span&gt;,&lt;span&gt;43214&lt;/span&gt;,&lt;span&gt;43214&lt;/span&gt;,&lt;span&gt;43214&lt;/span&gt;,&lt;span&gt;12&lt;/span&gt;,&lt;span&gt;2432&lt;/span&gt;,&lt;span&gt;12&lt;/span&gt;,&lt;span&gt;34&lt;/span&gt;,&lt;span&gt;24&lt;/span&gt;,&lt;span&gt;4532&lt;/span&gt;,&lt;span&gt;1234&lt;/span&gt;&lt;span&gt;};

        quick(number);
        
    
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i : number) {
            System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.print(i+&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; endTime = System.currentTimeMillis();    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取结束时间&lt;/span&gt;
&lt;span&gt;
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;程序运行时间：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + (endTime - startTime) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ms&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出程序运行时间&lt;/span&gt;
&lt;span&gt;        
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果，如图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1255290/201905/1255290-20190531224245112-430642950.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;半天看不到输出结果，而程序仍在运行中。如果将数组中的元素还原为原来那几个，则很快看到结果。&lt;/p&gt;
&lt;p&gt;合并代码例子，如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;80&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package cn.pratice.simple;

import java.util.Arrays;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MergeSort {



    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; mergeSort(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] original) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (original == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; NullPointerException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;The array can not be null !!!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; length =&lt;span&gt; original.length;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (length &amp;gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; middle = length / &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; partitionA[] = Arrays.copyOfRange(original, &lt;span&gt;0&lt;/span&gt;, middle);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 拆分问题规模&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; partitionB[] =&lt;span&gt; Arrays.copyOfRange(original, middle, length);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 递归调用&lt;/span&gt;
&lt;span&gt;            mergeSort(partitionA);
            mergeSort(partitionB);
            sort(partitionA, partitionB, original);
        }
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; sort(&lt;span&gt;int&lt;/span&gt;[] partitionA, &lt;span&gt;int&lt;/span&gt;[] partitionB, &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] original) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; k = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (i &amp;lt; partitionA.length &amp;amp;&amp;amp; j &amp;lt;&lt;span&gt; partitionB.length) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (partitionA[i] &amp;lt;=&lt;span&gt; partitionB[j]) {
                original[k] &lt;/span&gt;=&lt;span&gt; partitionA[i];
                i&lt;/span&gt;++&lt;span&gt;;
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                original[k] &lt;/span&gt;=&lt;span&gt; partitionB[j];
                j&lt;/span&gt;++&lt;span&gt;;
            }
            k&lt;/span&gt;++&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i ==&lt;span&gt; partitionA.length) {
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (k &amp;lt;&lt;span&gt; original.length) {
                original[k] &lt;/span&gt;=&lt;span&gt; partitionB[j];
                k&lt;/span&gt;++&lt;span&gt;;
                j&lt;/span&gt;++&lt;span&gt;;
            }
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (j ==&lt;span&gt; partitionB.length) {
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (k &amp;lt;&lt;span&gt; original.length) {
                original[k] &lt;/span&gt;=&lt;span&gt; partitionA[i];
                k&lt;/span&gt;++&lt;span&gt;;
                i&lt;/span&gt;++&lt;span&gt;;
            }
        }
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; print(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] array) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (array == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; NullPointerException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;The array can not be null !!!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
        StringBuilder sb &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; StringBuilder(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt;&lt;span&gt; element : array) {
            sb.append(element &lt;/span&gt;+ &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
        sb.replace(sb.length() &lt;/span&gt;- &lt;span&gt;2&lt;/span&gt;, sb.length(), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt;.println(sb.toString());
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; startTime = System.currentTimeMillis();    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取开始时间&lt;/span&gt;

        &lt;span&gt;int&lt;/span&gt; original[] = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[] { &lt;span&gt;13&lt;/span&gt;,&lt;span&gt;15&lt;/span&gt;,&lt;span&gt;24&lt;/span&gt;,&lt;span&gt;99&lt;/span&gt;,&lt;span&gt;14&lt;/span&gt;,&lt;span&gt;11&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;32&lt;/span&gt;,&lt;span&gt;4321&lt;/span&gt;,&lt;span&gt;432&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;14&lt;/span&gt;,&lt;span&gt;153&lt;/span&gt;,&lt;span&gt;23&lt;/span&gt;,&lt;span&gt;42&lt;/span&gt;,&lt;span&gt;12&lt;/span&gt;,&lt;span&gt;34&lt;/span&gt;,&lt;span&gt;15&lt;/span&gt;,&lt;span&gt;312&lt;/span&gt;,&lt;span&gt;12&lt;/span&gt;,&lt;span&gt;43&lt;/span&gt;,&lt;span&gt;3214&lt;/span&gt;,&lt;span&gt;43214&lt;/span&gt;,&lt;span&gt;43214&lt;/span&gt;,&lt;span&gt;43214&lt;/span&gt;,&lt;span&gt;12&lt;/span&gt;,&lt;span&gt;2432&lt;/span&gt;,&lt;span&gt;12&lt;/span&gt;,&lt;span&gt;34&lt;/span&gt;,&lt;span&gt;24&lt;/span&gt;,&lt;span&gt;4532&lt;/span&gt;,&lt;span&gt;1234&lt;/span&gt;&lt;span&gt;};
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; original.length; i++&lt;span&gt;) {
            System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.print(original[i]+&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
        mergeSort(original);
        print(original);
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; endTime = System.currentTimeMillis();    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取结束时间&lt;/span&gt;
&lt;span&gt;
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;程序运行时间：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + (endTime - startTime) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ms&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出程序运行时间&lt;/span&gt;
&lt;span&gt;        
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果，如图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1255290/201905/1255290-20190531224321184-505777610.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过两者对比，我们很容易得出合并排序比快速排序快。&lt;/p&gt;
&lt;p&gt;参考这个&lt;a href=&quot;https://www.cnblogs.com/stwzhong/p/3380395.html&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;合并排序和快速排序执行时间比较&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者通过实验得出一个结论:&lt;strong&gt;当数据量较小的时候，快速排序比合并排序运行时间要短，运行时间短就表示快，但是当数据量大的时候，合并排序比快速排序运行时间要短&lt;/strong&gt;。&lt;br/&gt;由此通过我上述的代码实验和该文章作者试验，可证实这个结论。&lt;/p&gt;
</description>
<pubDate>Fri, 31 May 2019 14:47:00 +0000</pubDate>
<dc:creator>挑战者V</dc:creator>
<og:description>分而治之(又称D&amp;C) 书中举了一个例子，假设你是农场主，有一块土地，如图所示: 你要将这块地均匀分成方块，且分出的方块要尽可能大。 从图上看，显然是不符合预期结果的。那么如何将一块地均匀分成</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/youcong/p/10957896.html</dc:identifier>
</item>
<item>
<title>Java微信公众平台开发(十二)--微信JSSDK的使用 - g歌德a</title>
<link>http://www.cnblogs.com/gede/p/10957701.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gede/p/10957701.html</guid>
<description>&lt;p&gt;&lt;span&gt;在前面的文章中有介绍到我们在微信web开发过程中常常用到的 &lt;a href=&quot;https://www.cnblogs.com/gede/p/10949458.html&quot; target=&quot;_blank&quot;&gt;【微信JSSDK中Config配置】 &lt;/a&gt;，但是我们在真正的使用中我们不仅仅只是为了配置Config而已，而是要在我们的项目中真正去使用微信JS-SDK给我们带来便捷，那么这里我们就简述如何在微信web开发中使用必要的方法！在开始之前，上一篇有朋友有疑问，如何在手机端显示，这里我们来补充一下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里的前提是你要跟着做到，浏览器显示返回200 状态码。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;(一)修改我们的menue。&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;打开我们的menueMain，将Button修改，修改后的代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Component
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MenuMain {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; createMenu(){
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;          ViewButton cbt=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ViewButton();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             cbt.setUrl(&quot;http://zqfbk.iok.la/mychat/jssdkconfig.jsp&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             cbt.setName(&quot;测试&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             cbt.setType(&quot;view&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;              
&lt;span&gt; 9&lt;/span&gt;              
&lt;span&gt;10&lt;/span&gt;             ViewButton vbt=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ViewButton();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             vbt.setUrl(&quot;https://www.cnblogs.com/gede&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             vbt.setName(&quot;博客&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             vbt.setType(&quot;view&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;              
&lt;span&gt;15&lt;/span&gt;             JSONArray sub_button=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; JSONArray();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            sub_button.add(cbt);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            sub_button.add(vbt);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;              
&lt;span&gt;19&lt;/span&gt;              
&lt;span&gt;20&lt;/span&gt;             JSONObject buttonOne=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; JSONObject();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             buttonOne.put(&quot;name&quot;, &quot;菜单&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             buttonOne.put(&quot;sub_button&quot;&lt;span&gt;, sub_button);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;              
&lt;span&gt;24&lt;/span&gt;             JSONArray button=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; JSONArray();
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;            button.add(vbt);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            button.add(buttonOne);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;            button.add(cbt);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;              
&lt;span&gt;29&lt;/span&gt;             JSONObject menujson=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; JSONObject();
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             menujson.put(&quot;button&quot;&lt;span&gt;, button);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;            System.out.println(menujson);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             
&lt;span&gt;33&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里为请求接口的url   +号后面的是token，这里就不做过多对token获取的方法解释&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;             String url=&quot;https://api.weixin.qq.com/cgi-bin/menu/create?access_token=&quot;+GlobalConstants.getInterfaceUrl(&quot;access_token&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;              
&lt;span&gt;36&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;                 String rs=&lt;span&gt;HttpUtils.sendPostBuffer(url, menujson.toJSONString());
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;                System.out.println(rs);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;             }&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(Exception e){
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;                 System.out.println(&quot;请求错误！&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改完成后，运行项目，调用我们的生成菜单方法：在浏览器中输入：&lt;a href=&quot;http://zqfbk.iok.la/mychat/menue/&quot;&gt;http://zqfbk.iok.la/mychat/menue/&lt;/a&gt;。调用成功，后台会返回如下信息：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1565130/201905/1565130-20190531213225913-365091861.jpg&quot; alt=&quot;&quot; width=&quot;1197&quot; height=&quot;146&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;（二）测试&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;进入我们的公众号，点击测试，如下图，则配置成功：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1565130/201905/1565130-20190531213616690-1119710006.png&quot; alt=&quot;&quot; width=&quot;487&quot; height=&quot;335&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1565130/201905/1565130-20190531213715030-1611383193.jpg&quot; alt=&quot;&quot; width=&quot;846&quot; height=&quot;808&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接下来这里我们就简述如何在微信web开发中使用必要的方法！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在微信公众号提供的所有接口中我们可以按照接口实现的难易程度分成两个部分：&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot; list-paddingleft-2&quot; readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;较易实现：基础接口、分享接口、设备信息接口、地理位置接口、界面操作接口、微信扫一扫接口；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;较难实现：图像接口、音频接口、智能接口、微信小店接口、微信卡券接口、微信支付接口；（注：这里说较难是因为需要后端和本地文件配合接口）&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;在这里我们将讲述所有较易实现的接口的具体实现方法，在文在文章 &lt;a href=&quot;https://www.cnblogs.com/gede/p/10949458.html&quot;&gt;https://www.cnblogs.com/gede/p/10949458.html&lt;/a&gt;中讲述过了如何配置和引入需要的js，通过这些配置之后我们就可以开始使用js的方法了！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;①基础接口-判断当前浏览器是否支持某些js接口&lt;/p&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_951968&quot; class=&quot;syntaxhighlighter js&quot; readability=&quot;8.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * 注意：
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; *  所有的JS接口只能在公众号绑定的域名下调用，公众号开发者需要先登录微信公众平台进入“公众号设置”的“功能设置”里填写“JS接口安全域名”。
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; wx.ready(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1. 判断当前版本是否支持指定 JS 接口，支持批量判断，只需要将需要判断的接口放入到jsApiList中即可&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt; checkJsApifunction () {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    wx.checkJsApi({
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;      jsApiList: [
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         'getNetworkType'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         'previewImage'
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;      ],
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;       success: &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (res) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        alert(JSON.stringify(res));
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    });
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;   };
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;②分享接口，这里包含：分享给朋友、分享到朋友圈、分享到qq、分享到微博、分享到qq空间(但是这里要提醒要注意不要有诱导分享等违规行为，对于诱导分享行为将永久回收公众号接口权限&lt;span&gt;  &lt;/span&gt;&lt;/p&gt;

&lt;div readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;③设备信息接口--这里是获取设备网络状态，以防在页面中存在视频或者大流量文件播放的时候对用户给出友好提示！&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div id=&quot;highlighter_42286&quot; class=&quot;syntaxhighlighter js&quot; readability=&quot;11&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3 设备信息接口&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3.1 获取当前网络状态&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;  getNetworkTypefunction () {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    wx.getNetworkType({
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;       success: &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (res) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        alert(res.networkType);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; networkType = res.networkType; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回网络类型2g，3g，4g，wifi&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(networkType=='3g'&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             alert(&quot;您好，您的网络状态是3g网络，这里将播放视频文件会产生大流程!&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;      },
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;       fail: &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (res) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        alert(JSON.stringify(res));
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    });
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;   };
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;④地理位置接口，这里包含查看经纬度对应的地图位置和获取当前位置的经纬度，可用做地图位置展示的第一步！&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div id=&quot;highlighter_117556&quot; class=&quot;syntaxhighlighter js&quot; readability=&quot;13.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 4 地理位置接口&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 4.1 查看地理位置&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;  openLocationfunction () {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    wx.openLocation({
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;       latitude: 23.099994&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;       longitude: 113.324520&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;       name: 'TIT 创意园'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;       address: '广州市海珠区新港中路 397 号'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;       scale: 14&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;       infoUrl: 'http://weixin.qq.com'
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    });
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;  };
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;  
&lt;span&gt;14&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 4.2 获取当前地理位置&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;  getLocationfunction () {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    wx.getLocation({
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;       success: &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (res) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        alert(JSON.stringify(res));
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;      },
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;       cancel: &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (res) {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         alert('用户拒绝授权获取地理位置'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    });
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;   };
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;⑤界面操作接口，这里说的界面操作其实就是在微信浏览器中操作和改名的那右上角的【三个点】，对这里隐藏的菜单进行操作和关闭微信浏览器！&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div id=&quot;highlighter_313171&quot; class=&quot;syntaxhighlighter js&quot; readability=&quot;14.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 5 界面操作接口&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 5.1 隐藏右上角菜单&lt;/span&gt;
&lt;span&gt;  hideOptionMenufunction () {
    wx.hideOptionMenu();
  };
 
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 5.2 显示右上角菜单&lt;/span&gt;
&lt;span&gt;  showOptionMenufunction () {
    wx.showOptionMenu();
  };
 
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 5.3 批量隐藏菜单项&lt;/span&gt;
&lt;span&gt;  hideMenuItemsfunction () {
    wx.hideMenuItems({
      menuList: [
        &lt;/span&gt;'menuItem:readMode', &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 阅读模式&lt;/span&gt;
        'menuItem:share:timeline', &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 分享到朋友圈&lt;/span&gt;
        'menuItem:copyUrl' &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 复制链接&lt;/span&gt;
&lt;span&gt;      ],
      success: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (res) {
        alert(&lt;/span&gt;'已隐藏“阅读模式”，“分享到朋友圈”，“复制链接”等按钮'&lt;span&gt;);
      },
      fail: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (res) {
        alert(JSON.stringify(res));
      }
    });
  };
 
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 5.4 批量显示菜单项&lt;/span&gt;
&lt;span&gt;  showMenuItemsfunction () {
    wx.showMenuItems({
      menuList: [
        &lt;/span&gt;'menuItem:readMode', &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 阅读模式&lt;/span&gt;
        'menuItem:share:timeline', &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 分享到朋友圈&lt;/span&gt;
        'menuItem:copyUrl' &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 复制链接&lt;/span&gt;
&lt;span&gt;      ],
      success: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (res) {
        alert(&lt;/span&gt;'已显示“阅读模式”，“分享到朋友圈”，“复制链接”等按钮'&lt;span&gt;);
      },
      fail: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (res) {
        alert(JSON.stringify(res));
      }
    });
  };
 
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 5.5 隐藏所有非基本菜单项&lt;/span&gt;
&lt;span&gt;  hideAllNonBaseMenuItemfunction () {
    wx.hideAllNonBaseMenuItem({
      success: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        alert(&lt;/span&gt;'已隐藏所有非基本菜单项'&lt;span&gt;);
      }
    });
  };
 
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 5.6 显示所有被隐藏的非基本菜单项&lt;/span&gt;
&lt;span&gt;  showAllNonBaseMenuItemfunction () {
    wx.showAllNonBaseMenuItem({
      success: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        alert(&lt;/span&gt;'已显示所有非基本菜单项'&lt;span&gt;);
      }
    });
  };
 
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 5.7 关闭当前窗口&lt;/span&gt;
&lt;span&gt;  closeWindowfunction () {
    wx.closeWindow();
  };&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;⑥微信扫一扫接口，这个接口可以在页面调用微信的扫一扫功能，其中参数needResult可以设置扫描之后的处理方式；&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div id=&quot;highlighter_305918&quot; class=&quot;syntaxhighlighter js&quot; readability=&quot;11&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 6 微信原生接口&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt; wx.scanQRCode({
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     needResult: 0, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 默认为0，扫描结果由微信处理，1则直接返回扫描结果，&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;     scanType: [&quot;qrCode&quot;,&quot;barCode&quot;], &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 可以指定扫二维码还是一维码，默认二者都有&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;     success: &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (res) {
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; result = res.resultStr; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当needResult 为 1 时，扫码返回的结果&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么到这里微信JS-SDK方法实现中的简答实现部分基本就讲述完成了！&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;最后我们写一个简单的页面，来调用不同的js。简单代码如下：&lt;/p&gt;

</description>
<pubDate>Fri, 31 May 2019 13:46:00 +0000</pubDate>
<dc:creator>g歌德a</dc:creator>
<og:description>在前面的文章中有介绍到我们在微信web开发过程中常常用到的 【微信JSSDK中Config配置】 ，但是我们在真正的使用中我们不仅仅只是为了配置Config而已，而是要在我们的项目</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/gede/p/10957701.html</dc:identifier>
</item>
<item>
<title>如何使用 RxJS 更优雅地进行定时请求 - 叙帝利</title>
<link>http://www.cnblogs.com/nzbin/p/10956065.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nzbin/p/10956065.html</guid>
<description>&lt;p&gt;在用 Angular 做项目的时候，遇到了一个有点麻烦的问题。具体问题如下：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;轮循请求某个接口，如何保证接口返回的数据与请求的顺序相同？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;实际的业务场景是这样的：前端需要轮循请求后端接口获取文件处理进度，并在前端用进度条展示。如下方所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/999445/201905/999445-20190531170304319-269435954.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先想到的肯定是使用 &lt;code&gt;setTimeout&lt;/code&gt; 或者 &lt;code&gt;setInterval&lt;/code&gt; 进行定时请求。然而结果有点诡异，进度条的变化不是递增，而是有快有慢，比如 30%，20%，50%，40%这样。仔细一想也知道问题出在哪，异步请求的结果并不是按顺序返回的。&lt;/p&gt;
&lt;p&gt;我在之前的工作中还没有遇到过这类需求，所以我并不是很清楚如果用传统方式应该如何解决。然而很庆幸的是 RxJS 正好擅长处理这样的问题。我立即翻了一下&lt;a href=&quot;https://rxjs-dev.firebaseapp.com/api/index/function/interval&quot;&gt;文档&lt;/a&gt;，&lt;code&gt;interval&lt;/code&gt; 操作符可以处理定时任务，而且更强大的是返回结果也是有顺序的。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;interval(period: 0 = 0, scheduler: SchedulerLike = async): Observable&amp;lt;number&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先看一下 &lt;code&gt;interval&lt;/code&gt; 的说明：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;创建一个可观察对象，在规定的调度程序中，以规定的时间间隔发出连续的数值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/999445/201905/999445-20190531210226238-1652995715.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;interval&lt;/code&gt; 返回一个可观察对象，它可以周期性的发出递增数值，但是第一次发出值是在第一个周期结束之后执行的。&lt;/p&gt;
&lt;p&gt;以下是官方例子：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;import { interval } from 'rxjs';
import { take } from 'rxjs/operators';

const numbers = interval(1000);

const takeFourNumbers = numbers.pipe(take(4));

takeFourNumbers.subscribe(x =&amp;gt; console.log('Next: ', x));

// Logs:
// Next: 0
// Next: 1
// Next: 2
// Next: 3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不过只看官方例子还是有点懵，如果是 http 请求的话应该怎么写参数呢？或者说应该把 http 请求写在哪里？&lt;/p&gt;
&lt;p&gt;这个地方的坑有点深，通过翻阅外文资料终于找到答案。直接上代码。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// 间隔 1s 请求
this.timer$ = interval(1000)
    .pipe(
        // 取消过时的请求值
        switchMap(() =&amp;gt; {
            return this.http.get(API);
        }),
    )
    .subscribe(
        (res: any) =&amp;gt; {
            // 百分数处理逻辑
        },
        () =&amp;gt; {
            this.timer$.unsubscribe();
        },
        () =&amp;gt; {
            this.timer$.unsubscribe();
        },
    );&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;总的来说就是通过管道处理请求。最终的效果很完美。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;RxJS 确实是一个非常强大的工具库，尤其处理异步交互真的是省时省力，但是国内技术文章偏少，遇到疑难问题还需要查阅国外文章。欢迎大家评论交流。&lt;/p&gt;
</description>
<pubDate>Fri, 31 May 2019 13:16:00 +0000</pubDate>
<dc:creator>叙帝利</dc:creator>
<og:description>在用 Angular 做项目的时候，遇到了一个有点麻烦的问题。具体问题如下： 轮循请求某个接口，如何保证接口返回的数据与请求的顺序相同？ 实际的业务场景是这样的：前端需要轮循请求后端接口获取文件处理进</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/nzbin/p/10956065.html</dc:identifier>
</item>
<item>
<title>浅谈贪心与动归 - lidasu</title>
<link>http://www.cnblogs.com/lidasu/p/10957495.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lidasu/p/10957495.html</guid>
<description>&lt;p&gt;初学时 想必都会对两者的认识有一些混淆&lt;br/&gt;概念性质的就不赘述了&lt;br/&gt;来谈谈我在刷题过程中对两者的见解（诚心接受各位的指正）&lt;br/&gt;&lt;a href=&quot;https://www.luogu.org/blog/funny-talk/funny-solution-p1478&quot;&gt;从搜索到贪心——求解算法的优化&lt;/a&gt; 这篇文章非常值得一看&lt;br/&gt;&lt;a href=&quot;https://www.luogu.org/problemnew/show/P1478&quot;&gt;P1478 陶陶摘苹果（升级版）&lt;/a&gt; 对应的oj题目&lt;/p&gt;
&lt;h2 id=&quot;对比&quot;&gt;对比&lt;/h2&gt;
&lt;p&gt;贪心像是动归的一个&lt;strong&gt;特例&lt;/strong&gt;&lt;br/&gt;动归的核心在于：状态转移，找出那个转移方程&lt;br/&gt;贪心的核心在于：局部选取最优解，并且选取的贪心策略&lt;strong&gt;不会影响到其他的状态&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;用01背包举个例子&quot;&gt;用01背包举个例子&lt;/h3&gt;
&lt;p&gt;在n件物品取出若干件放在空间为c的背包里，每件物品的体积为w1 w2...wn，与之相对应的价值为v1 v2...vn，最终使背包所装物品的总价值最高&lt;br/&gt;代码如下，基本上大家都会写&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;int dp[i][j]; //dp[i][j] 表示取到第i个物品，背包容量为j
int pack01(int v[],int w[],int n,int c){ //value weight number capacity 
    for(int i=1;i&amp;lt;=n;++i)
        for(int j=1;j&amp;lt;=c;++j){
            if(w[i]&amp;gt;j) dp[i][j]=dp[i-1][j];
            else dp[i][j]=max(dp[i-1][j],dp[i-1][j-w[i]]+v[i]);
        }
}
空间优化 一维
for(int i=1;i&amp;lt;=n;i++)
    for(int j=c;j&amp;gt;=1;j--){ //注意从后往前
        if(w[i]&amp;lt;=j){ //二维变一维
            dp[j]=max(dp[j],dp[j-w[i]]+v[i]);
        }
    }
更简洁
for(int i=1;i&amp;lt;=n;i++)
    for(int j=c;j&amp;gt;=w[i];j--){
        dp[j]=max(dp[j],dp[j-w[i]]+v[i]);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但如果将v1 v2...vn这些每个物品对应的&lt;strong&gt;价值都变成1&lt;/strong&gt;（v1=v2=...=vn=1）&lt;br/&gt;这样一来，每个物品的价值都相同。无论你有多重，你的价值和别人都一样&lt;br/&gt;很显然，我们只要把物品的重量进行排序，先拿轻的再拿重的，结果必然最优&lt;/p&gt;
&lt;p&gt;动归加上一个特例 就这样成为了贪心可解决的题目&lt;br/&gt;并且时间复杂度O(n)直接下降到排序的nlogn&lt;/p&gt;
&lt;p&gt;再来举个更接地气的栗子&lt;/p&gt;
&lt;h3 id=&quot;找纸币&quot;&gt;找纸币&lt;/h3&gt;
&lt;p&gt;基本上每个国家设计的货币都是符合贪心原则的&lt;br/&gt;我国的纸币面额分别为：100元、50元、20元、10元、5元、2元、1元&lt;br/&gt;当需要找钱给别人时，先找大面值的纸币再找小面值的，最后一定是&lt;strong&gt;纸币数量最少的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;但如果面额是1元、5元、11元的纸币&lt;br/&gt;当你找别人15元时，按照贪心规则，找的是一张11元和4张1元的，一共5张&lt;br/&gt;而正确答案显而易见是3张5元的，一共3张&lt;br/&gt;这就不符合贪心策略了，这时怎么来找到最少的？这就需要用到动归了&lt;/p&gt;
&lt;p&gt;这其实是&lt;strong&gt;完全背包&lt;/strong&gt;（每件物品可以取多次）的模板&lt;br/&gt;必须把背包装满，即正好找出零钱，不多也不少（会影响初始化，文末见背包九讲）&lt;br/&gt;每个物品价值 v[i]=1，并且不是总价值最大，而是纸币数量最小 max-&amp;gt;min&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;int m[4]={0,1,5,11};
int dp[5][20]; //dp[i][j] i表示纸币种类，j表示找回的零钱
//转移方程 dp[i][j]=min(dp[i-1][j],dp[i][j-m[i]]+1);
#define inf 10000 //若背包则是-∞
//初始化
for(int i=0;i&amp;lt;=3;++i)
    for(int j=0;j&amp;lt;=15;++j){
        if(j==0) dp[i][j]=0;
        else dp[i][j]=inf;
    }

for(int i=1;i&amp;lt;=3;++i){
    for(int j=0;j&amp;lt;=15;++j){
        if(j&amp;gt;=m[i]) dp[i][j]=min(dp[i-1][j],dp[i][j-m[i]]+1);
        else dp[i][j]=dp[i-1][j];
        //请注意转移方程中dp[i][j-m[i]]+1里的[i]
        //而01背包是[i-1]，这是物品能否取多次的关键所在
    }
}
cout&amp;lt;&amp;lt;dp[3][15];&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;空间优化&quot;&gt;空间优化&lt;/h4&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;int m[4]={0,1,5,11};
int dp[20];
#define inf 10000
for(int j=0;j&amp;lt;=15;++j){
    if(j==0) dp[j]=0;
    else dp[j]=inf;
}
for(int i=1;i&amp;lt;=3;++i){
    for(int j=m[i];j&amp;lt;=15;++j){
        dp[j]=min(dp[j],dp[j-m[i]]+1);
    }
}
cout&amp;lt;&amp;lt;dp[15];&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;如果是第一种问法，要求恰好装满背包，那么在初始化时除了 F[0] 为 0 ，其它&lt;br/&gt;F[1..V ] 均设为 −∞ ，这样就可以保证最终得到的 F[V ] 是一种恰好装满背包的最优解。&lt;br/&gt;如果并没有要求必须把背包装满，而是只希望价格尽量大，初始化时应该将 F[0..V ]&lt;br/&gt;全部设为 0 。&lt;br/&gt;这是为什么呢？可以这样理解：初始化的 F 数组事实上就是在没有任何物品可以放&lt;br/&gt;入背包时的合法状态。如果要求背包恰好装满，那么此时只有容量为 0 的背包可以在什&lt;br/&gt;么也不装且价值为 0 的情况下被“恰好装满”，其它容量的背包均没有合法的解，属于&lt;br/&gt;未定义的状态，应该被赋值为 -∞ 了。如果背包并非必须被装满，那么任何容量的背包&lt;br/&gt;都有一个合法解“什么都不装”，这个解的价值为 0 ，所以初始时状态的值也就全部为 0&lt;br/&gt;了。&lt;br/&gt;取自《背包问题九讲》1.4 初始化的细节问题&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 31 May 2019 12:55:00 +0000</pubDate>
<dc:creator>lidasu</dc:creator>
<og:description>浅谈贪心与动归 初学时 想必都会对两者的认识有一些混淆 概念性质的就不赘述了 来谈谈我在刷题过程中对两者的见解（诚心接受各位的指正） '从搜索到贪心——求解算法的优化' 这篇文章非常值得一看 'P14</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lidasu/p/10957495.html</dc:identifier>
</item>
<item>
<title>刚做测试工作一年的时候，我是怎样的？ - Refain</title>
<link>http://www.cnblogs.com/longronglang/p/10957399.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/longronglang/p/10957399.html</guid>
<description>&lt;p&gt;刚落笔前，我想了好久，该如何诠释这段经历。&lt;/p&gt;

&lt;p&gt;也许你现在也和我当时一样，但是，相信我，北京是个有实力说话的好地方，所以&lt;strong&gt;让努力擦亮自己，让自己的光显得格外抢眼。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;时光仿佛又定格在我刚入京那一刻，一切是那么亲切而熟悉，有我喜欢的路边摊，喜欢的天桥及凌晨灯火通明的静谧，更有我难忘的恩师和朋友，一切的一切都是的那么美好而令人难忘……&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;关于租房&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;刚到北京那会，北京的租房价格，比我想象的要贵好多，而且难以接受，二手房东比我想象中的套路多，重点是被骗过。我和两个小伙伴一起来的北京，来了第三天后，他们都因房子太贵不好租，环境太差回了老家。&lt;/p&gt;

&lt;p&gt;后来我租了个床位，一个月大概300元的样子，里面住满了鱼龙混杂、形形色色的人，&lt;strong&gt;穿越在其中，我有时也不知道自己是谁。&lt;/strong&gt;每天要担心随时丢东西的可能，做什么的都有，总会被凌晨两三点回来洗漱的声音吵醒， 每天会为早上排卫生间而发愁，大家话不多，他们俩走之后，告诉自己一定要活下来，不能低头。&lt;/p&gt;

&lt;p&gt;我第一家公司在丰台那边，八点半上班，每天我都要早上五点起床排卫生间，五点半从家走，晚上大约十点半多到家，这样的生活持续了三个月，后来把房子换到了丰台那边的小村里，相对来说，我很喜欢这里的安逸和生活环境，渐渐地自己一个人便开始了北漂生活…&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;关于生活&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;相对简单，两点一线，家里和公司，平时周末，要去找找兼职做。&lt;/p&gt;

&lt;p&gt;还记得刚来工作那会因为买完高铁票，交完房租，兜里只剩五块钱，差三天公司开资，长这么大第一次挨饿，我买了一袋老饼干，&lt;strong&gt;过分到我按照每天吃多少块去挨这三天。&lt;/strong&gt;来公司时间不长，不爱说话，没朋友，所以就挺着，那会我就发誓，以后绝不让自己饿着，不能亏了自己的肚子，现在也是，这是原则，再后来开工资后，自己吃到撑，现在想想自己好傻呀。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;要追着生活跑，不要让生活赶着我们跑。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;后来就有了兼职这个念头，去晚上大排档当服务员，每个小时约有15-20的收入，每每收到兼职收入，心里就会有个声音说，明天的午饭有保证了，这段经历父母到现在也不知道，我也未和任何人提过，想想这也是断特别的经历呀。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;关于工作&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;当时发的offer是测试，后来入职后发现是个运维的活。组长是测试经理，算我就俩测试，刚开始&lt;strong&gt;写过验收文档，用户操作手册，测试用例，测试计划，写完就写完了，并没人告诉我对不对。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;后来让我负责服务器的管理，一个人负责好几十台服务器重启和维护，每当电话响了，脑袋就会冒出一大串想法，服务器又挂了？再就是网关死了？消息队列堵塞？然后就去查服务器日志看哪个服务是死了没启动，并仔细排查，帮客户解决。&lt;/p&gt;

&lt;p&gt;先期是客服，给我打电话，告诉我哪个服务不好使了，后来客服直接把我电话给了客户，我莫名成了客服，每天电话响的时候，我是最慌的。时常凌晨、半夜总会接到电话说，服务挂了，宕机了，然后我就得半夜起来排查维护，搞得我那会每天有效睡眠也就4个小时。&lt;/p&gt;

&lt;p&gt;在公司一年下来我发现自己黑眼圈明显严重不少，而且下不去了，直到现在也是如此，后来总有朋友打趣说我是不是纵欲过度了，然后我们就是哈哈大笑…&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;关于爱情&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;我是毕业就分手了，也许是作为毕业后，必须经历的，到了个新的城市肯定是孤独的。&lt;/p&gt;

&lt;p&gt;刚去北京那会，有次去邮政银行取钱，排队的时候，哭的特别伤心，眼睛红红的，眼泪不止，一个老大爷过来问我小伙子，怎么了，哭的这么伤心，我又不能说失恋，只能说钱包丢了，大爷没再说话了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;哭泣并不能解决任何问题，只会让别人为你担心着急。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在那之后我就再没哭过了，而且大部分时间都在学习和看书，把时间排的满满的。要么读书，要么拿着手机读书，这样五年过得很快，当然结果北漂五年没恋爱……&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;关于感恩&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;我得感谢我的恩师，马哥，不嫌弃我笨，无数次的鼓励和支持，关于他给我的帮助，真的是无以言表。&lt;/p&gt;

&lt;p&gt;这事还得从我组长说起，组长是12306的测试同学，当时作为跨专业就业的我，计算机是个啥完全没概念，每天看他在窗口输入命令、“秀操作”。&lt;/p&gt;

&lt;p&gt;后来侧面打听，那个是Linux呀，感觉好厉害，羡慕着急。&lt;/p&gt;

&lt;p&gt;一次偶然情况遇到我师傅，我发现他更厉害，因为每天好多人找他处理技术问题，没错就是开发经理，带了十多个人，因为我每天下班都比较晚，有次他就问我小伙子，有没有兴趣学编码，干测试赚的少，学编码赚的多。&lt;/p&gt;

&lt;p&gt;对于我而言，开心到不会说话，我大约愣了半分钟，我说好呀，之后公司每天最晚的身影永远只有我和师傅。&lt;/p&gt;

&lt;p&gt;后来和师傅熟悉了，师傅知道我周末总去兼职，总带着我一去吃饭，重来不让我出钱，这样的生活持续了半年多吧，&lt;strong&gt;试问谁会这么为一个仅仅认识小半年的人，做到这份上。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;北京的冬天，不是那么太冷，但是半夜也很冷，三床被，盖在一起，插电褥子，一早起来，鼻子和脚都是凉的。有时候，我感觉和住外面没什么区别。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;那时候，每天醒来，感觉就是活着真好。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一次加班太晚，师傅打车说顺我一道回家，一看我住的地方冬天没暖气，就和我说，你这小子真抗冻呀。&lt;/p&gt;

&lt;p&gt;其实相当于住在库房，后来师傅几乎每天都以加班为由，带我去酒店加班，其实去每次都给我讲点知识，有时扯扯蛋，看看武林风，吹吹牛……很是充实、开心，我一周基本在家住也就1-2天，有次房东一早碰到我，以为我出差了呢。&lt;/p&gt;

&lt;p&gt;因为一直自己住，我有那么一会，很害怕，怕是自己生病或者死掉，都没有人知道，&lt;strong&gt;北京好大，有的时候，就算自己拼劲全力大声呼喊，也不会有任何回声&lt;/strong&gt;，因为遇到了师傅，这个老大哥，让我感受到了偌大的北京，有了一些归属感……&lt;/p&gt;

&lt;p&gt;依稀还记得，我师父在年会喝酒喝多了说的一句话。当时老板问我师父，你为什么那么爱教他帮他，我师父说，别看他笨呀，可是我就喜欢教他……此时写到这里，我鼻子有点酸了，回老家后，和师傅联系很少了，只是偶尔会通个电话……&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;关于学习&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;你可能不会想到，我有多么笨，一个开发环境搭建需要一周甚至更久，那会只要有时间我就去百度研究尝试，一找他，他就告诉我你先自己搞，连个环境都搞不明白，写JM代码，我听的最多的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一件事刚开始的时候，也是毫无成就感的时候，挫败感极强。但如果不坚持下去，永远没有能得到自信的那一天，一辈子都会有挫败感。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;刚开始确实很难受的，但是每次师傅都认真给我说问题出在哪。后来接着教我三层架构，Linux，sql、linq……好多，每当代码报错，就总打趣说是不是内裤（类库）丢了，慢慢我写代码有了些感觉。&lt;/p&gt;

&lt;p&gt;然后开始让我改线上的bug,有一次改完报表的一个bug后，发现直接某功能不能用了，我吓坏了，师傅说没事，随便改，你当你什么都会不用怕，有我呢，咱们先排查问题，要不怎么成长，这样你才会记忆深刻，下次不犯错，我一想确实，在那之后，我确实更大胆了，但是也更细致了，没在出过事故了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;崩溃时，想什么都是昏暗无光的，没有任何希望。心情的一落千丈，决定工作全面崩盘，无法再进行下去了！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;但慢慢的，我发现，即使发生了天大的事情，脑子里立刻呈现的不是怎么办，而是罗列出一二三四怎么解决，并且迅速冷静下来，就这样，我从一个菜逼在慢慢成长了起来……&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;关于未来&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;从第一家公司离职后，我陷入了极度恐慌中，我做.net开发？测试？运维？哪个我都不精，后来抉择了下，做测试，会编码也许方便我定位问题。&lt;/p&gt;

&lt;p&gt;后来换了公司，试用期时候，被副总说了测试用例编写不合格，差点被劝退，就给我七天时间，在写一版本用例，我写完后发给老宋，老宋很够意思，指出我写用例的不足，还有遗漏的点，再发给副总，这次用例他很满意，危险期就安全过了，看到这你可能没想到六哥，&lt;strong&gt;在工作一年的时候，测试用例都不会写。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;再后来副总看中了我的代码功底，让我学Java写自动化测试框架，给我三个月时间，我在边学Java边熟悉前同事代码的情况下，将其框架重构按时交付，我都没想到自己还有这种潜力……&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;真正的稳定，是自己能力的不断进步和加持，而不是坐在一张凳子上不断重复昨日的时光。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;和大多数北漂者一样，渴望有那么一刻自己被点亮，想做一番事业，渴望被认可与尊重，在漫长的孤独侵蚀下，慢慢磨砺成长。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一件事刚开始的时候，也是毫无成就感的时候，挫败感极强。但如果不坚持下去，永远没有能得到自信的那一天，一辈子都会有挫败感。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;坚持做自己认为对的事，至于是对是错，并不重要，时间长了，自然就会有有分晓。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总有一天你也会和我一样，感谢曾经努力的自己。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 31 May 2019 12:37:00 +0000</pubDate>
<dc:creator>Refain</dc:creator>
<og:description>刚落笔前，我想了好久，该如何诠释这段经历。 也许你现在也和我当时一样，但是，相信我，北京是个有实力说话的好地方，所以让努力擦亮自己，让自己的光显得格外抢眼。 时光仿佛又定格在我刚入京那一刻，一切是那么</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/longronglang/p/10957399.html</dc:identifier>
</item>
<item>
<title>新浪微博相册图片外链限制，图床不显示解决方法总结！ - 十年1一梦</title>
<link>http://www.cnblogs.com/wangdadaer/p/sinaimg404.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangdadaer/p/sinaimg404.html</guid>
<description>&lt;p&gt;近期新浪微博抽风，很多站长的图片都存在微博相册，导致绝大部分网站的图片无法显示，文主的站也不幸沦陷，找了各种方法解决此问题，后来综合各种说法自己找了个方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1039012/201905/1039012-20190531195325378-1194707705.jpg&quot; alt=&quot;&quot; width=&quot;640px&quot;/&gt;&lt;/p&gt;
&lt;p&gt;新浪微博相册外链图片不显示的其它一些解决办法：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、修改域名：&lt;/strong&gt;ww1.sinaimg.cn 改为 ww4.sinaimg.cn 不好使；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、修改referrer：&lt;/strong&gt;在Header中新增：&amp;lt;meta name=”referrer” content=”no-referrer” /&amp;gt;，不推荐，对整站有影响；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、给img标签添加 referrerpolicy=”no-referrer” 属性：&lt;/strong&gt;&amp;lt;img src=”https://ws3.sinaimg.cn/thumb150/xxoo.jpg” referrerpolicy=”no-referrer”&amp;gt;，本文用的方法，只修改文章内容版块的 img 标签，其它不受影响；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、切换HTTP：&lt;/strong&gt;直接使用HTTP链接，不要用HTTPS~~~&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5、内嵌iframe：&lt;/strong&gt;原理有点像no-referrer~ 使用iframe加载图片不会跟踪到原请求域名，可以加载图片！但是这个方法改动太大了，累死人~~~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1039012/201905/1039012-20190531194934168-474126781.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6、第三方反代&lt;/strong&gt;：有许多大佬提供反代方案，比如将 sinaimg.cn 替换成 sinaimg.in，不多介绍~~~临时方案。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7、付费服务：&lt;/strong&gt;七牛、阿里云、付费图床等等；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;8、自建图床。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;说明：本方法不一定适合每一个站长，但是值得试一试，万一行了呢！&lt;/p&gt;
&lt;p&gt;工具：editplus、jquery、简单HTML知识；&lt;/p&gt;
&lt;p&gt;解决办法原理，以下面网址做说明：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;img src=&quot;http://wx3.sinaimg.cn/mw690/005Cikyoly1fy3yd869pfg30hs09yhe4.gif&quot; /&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个图片在本站域名下用 img 标签是不显示的，但是改为以下格式就会显示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;http://wx3.sinaimg.cn/&lt;span&gt;large&lt;/span&gt;/005Cikyoly1fy3yd869pfg30hs09yhe4.gif&quot;&lt;/span&gt;&lt;span&gt; referrerpolicy=&quot;no-referrer&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也就是表面这个 img 标签下有两处改动，将 mw690 替换为 large，img 标签属性添加 referrerpolicy=&quot;no-referrer&quot; 这个属性。&lt;/p&gt;
&lt;p&gt;由此可知，我们只需将原网址下的 &lt;span&gt;mw690&lt;/span&gt; 替换为 &lt;span&gt;large&lt;/span&gt;，然后添加属性 &lt;span&gt;&lt;strong&gt;referrerpolicy=&quot;no-referrer&quot;&lt;/strong&gt;&lt;/span&gt; 即可。&lt;/p&gt;
&lt;p&gt;那么我们直接操作，首先是结构代码，这个代码是本站的结构代码，自己网站是什么结构自己看下，因地制宜：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;postlist&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;table&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;table&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;table&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;table&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;table&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tbody&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;第一个td&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;pct&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;https://user-images.githubusercontent.com/23384966/57830772-c0f4de00-77e5-11e9-8179-3495a36c25c4.gif&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;http://www.gifdtm.com/data/attachment/forum/201806/13/211440j2fgmqgtg7ffy75p.jpg&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;选择这个元素下的所有img标签&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;http://wx3.sinaimg.cn/large/005Cikyoly1fy3yd869pfg30hs09yhe4.gif&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tbody&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;table&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;table&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;table&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面是修改代码的步骤，可能有点差，高手勿喷：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&amp;lt;script src=&quot;jquery.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;postlist 下面第一个 div 的 table 下面的 img 标签添加 referrerpolicy=&quot;no-referrer&quot;属性&lt;/span&gt;

&lt;span&gt;var&lt;/span&gt; imgs = $(&quot;#postlist .pct img&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;选择 img 标签&lt;/span&gt;
imgs.attr(&quot;referrerpolicy&quot;,&quot;no-referrer&quot;&lt;span&gt;);
imgs.attr(&lt;/span&gt;&quot;alt&quot;,&quot;alt文字&quot;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;console.log(typeof imgs.attr(&quot;src&quot;));//返回的是一个img的src&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;console.log(typeof imgs);//返回 imgs 类型，object类型&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明空数组，等待接受元素&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; arr = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Array();

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历 imgs 对象，以便取到 imgs 中的所有img标签&lt;/span&gt;
$.each(imgs,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(i,value){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;console.log(src + &quot; &quot; + value.src); //测试输出索引和值&lt;/span&gt;
    str = value.src.replace(/\/mw690\//ig, &quot;/large/&quot;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;正则表达式替换字符串&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;console.log(str); //测试输出字符串&lt;/span&gt;
    arr.push(str); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将替换后字符串添加到arr数组&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;console.log(arr);&lt;/span&gt;
    $(&lt;span&gt;this&lt;/span&gt;).attr(&quot;src&quot;,arr[i]); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将对应的当前第i个img标签的src属性设置为替换后字符串&lt;/span&gt;
&lt;span&gt;});

&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
好了基本思路和代码就是这样，希望有更好的方法，欢迎留言讨论哦~~~~&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1039012/201905/1039012-20190531195459118-1713851824.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 31 May 2019 12:00:00 +0000</pubDate>
<dc:creator>十年1一梦</dc:creator>
<og:description>近期新浪微博抽风，很多站长的图片都存在微博相册，导致绝大部分网站的图片无法显示，文主的站也不幸沦陷，找了各种方法解决此问题，后来综合各种说法自己找了个方法。 新浪微博相册外链图片不显示的其它一些解决办</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wangdadaer/p/sinaimg404.html</dc:identifier>
</item>
<item>
<title>不知道Java类文件结构的同学，看这篇文章就够了 - rainple</title>
<link>http://www.cnblogs.com/rainple/p/10846917.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rainple/p/10846917.html</guid>
<description>&lt;p&gt;　　代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。经过多年的发展，目前的计算机仍然只能识别0和1，但是由于近10年内虚拟机以及大量建立在虚拟机之上的程序语言如雨后春笋般出现并蓬勃发展，将我们编写的程序编译成二进制本地机器码（Native Code）已不再是唯一的选择，越来越多的程序语言选择了操作系统和机器指令集无关的、平台中立的格式作为程序编译后的存储格式。&lt;/p&gt;

&lt;p&gt;　　Class文件是一组以8位字节为基础单位的二进制流，各项数据严格的按照顺序紧凑的地排列在Class文件中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。当遇到需要占用8个字节以上空间的数据项时，则会按照高位在前的方式分割成若干个8位字节进行存储。&lt;/p&gt;
&lt;p&gt;　　根据Java虚拟机规范的规定，Class文件格式采用一种类似于Ｃ语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型L:无符号和表，后面的解析都要以这两种数据类型为基础，所以这里先介绍这两个概念；无符号属于基本数据类型，以ｕ１，ｕ２，ｕ４，ｕ８来分别代表１个字节，２个字节，４个字节和８个字节的无符号数，无符号数可以用来描述数字、索引引用、数量或者按照ｕｔｆ－８编码构成字符串值。表是由多个无符号或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以“＿ｉｎｆｏ”结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一张表，他由一下表格中的数据项构成：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519364/201905/1519364-20190515231612527-296022021.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常会使用一个前置的容量计数器加若干个连续的数据项的形式，这是称这一系列连续的某一类型的数据为某一类型的集合。&lt;/p&gt;

&lt;p&gt;　　每个Class文件的头4个字节称为魔数（Magic Number），它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Calss文件。很多文件存储标准中都使用魔数来进行身份识别，使用魔数而不是使用拓展名来进行识别主要是基于安全方面的考虑，因为文件的拓展名可以随意的改动。Class文集爱你的魔数值为“0xCAFEBABE”,这个魔数值在Java还称为“Oak”的时候就已经确定下来了。&lt;/p&gt;
&lt;p&gt;　　紧接着摸数的4个字节存储的是Class文件的版本号：第5和第6个字节是次版本号，第7和第8个字节是主版本号。Java版本号是从45开始的。JDK1.1之后的每一个JDK大版本发布主版本号向上加1，高版本的JDK能向下兼容以前的版本的Class文件，但是不能运行以后的版本的Class文件，即使文件格式并没有发生任何变化，虚拟机也必须拒绝执行超过其版本号的Class文件。&lt;/p&gt;

&lt;p&gt;　　在主版本和次版本之后的是常量池的入口，由于常量池的中常量数量是不固定的，所以常量池的入口通常需要放置一个常量池容量计数器，计数器是从1开始而不是从0开始，其目的是为了在特殊情况下表达“不引用任何常量池的项目”的情况。&lt;/p&gt;
&lt;p&gt;　　常量池是Class文件中与其他项目关联最多的数据类型，也是占用Class文件空间最大的数据项目之一。常量池的常量的类型分为：字面量和符号引用。字面量比较接近Java层面的常量的概念，比如文本字符串“abc”,被声声明卫final的常量等。符号引用属于编译原理的概念，包括以下3个方面：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;类和接口的全限定名，比如： java.lang.String&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;字段的名称的描述符，比如private，static等&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;方法的名称和描述符，比如private，static等描述&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　常量池中每一个常量都是一个表，在jdk1.7后提供了14种表结构，他们都有一个共同的特点，就是表开始第一个位置是一个u1类型的标志位，代表当前的常量是属于哪一种类型的。如下表：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519364/201905/1519364-20190531113945302-544021231.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　常量池结束后就是访问标志（access_flag）了,用于标识一些类或接口的访问信息，比如这个Class是类还是接口，是public还是private，是否为abstract等，每种访问信息都是由一个16进制的标志值表示，如果同时表示多种访问信息，则得到的标志值为这几种访问信息的逻辑或，其标志位和含义如下表：&lt;/p&gt;
&lt;table border=&quot;2&quot; align=&quot;center&quot;&gt;&lt;tbody readability=&quot;4.5&quot;&gt;&lt;tr&gt;&lt;td&gt;标志名称&lt;/td&gt;
&lt;td&gt;&lt;br/&gt;标志值&lt;/td&gt;
&lt;td&gt;&lt;br/&gt;含义&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;ACC_PUBLIC&lt;/td&gt;
&lt;td&gt;0X0001&lt;/td&gt;
&lt;td&gt;是否为public类型&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;ACC_FINAL&lt;/td&gt;
&lt;td&gt;0X0010&lt;/td&gt;
&lt;td&gt;&lt;br/&gt;是否被声明为final，只有类可以设置&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;ACC_SUPER&lt;/td&gt;
&lt;td&gt;0X0020&lt;/td&gt;
&lt;td&gt;是否允许使用invokespecial字节码指令的新语意，invokespecial指令的语意在JDK1.0.2发生过改变，为了区别这条指令使用哪种语意，JDK1.0.2之后编译&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;ACC_INTERFACE&lt;/td&gt;
&lt;td&gt;0X0200&lt;/td&gt;
&lt;td&gt;标志这是一个接口&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;ACC_ABSTRACT&lt;/td&gt;
&lt;td&gt;0X0400&lt;/td&gt;
&lt;td&gt;是否为abstract类型，对于接口或者抽象类来说，此标志值为真，其他类为假&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;ACC_SYNTHETIC&lt;/td&gt;
&lt;td&gt;0X1000&lt;/td&gt;
&lt;td&gt;标志这个类并非由用户代码产生的&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;ACC_ANNOTATION&lt;/td&gt;
&lt;td&gt;&lt;br/&gt;0X2000&lt;/td&gt;
&lt;td&gt;标志这是一个注解&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;ACC_ENUM&lt;/td&gt;
&lt;td&gt;0X4000&lt;/td&gt;
&lt;td&gt;标志这是一个枚举&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;　　类索引和父类索引都是一个u2的类型，而接口索引是一个u2类的数据集合，Class中由这三项数据来确定类的继承关系。类索引、父类索引和接口索引集合都是有序的排列在访问标识之后，类索引和父类索引两个u2类型的索引值表示，他们各自指向一个类型为COMNSTANT_Class_info的类描述符常量，通过该常量的索引值找到定义在COMNSTANT_Utf8_info类型的常量中的全限定名字符串，而接口索引集合用来描述这个类实现了哪些接口，这些被实现的接口按implements语句后的接口顺序从左往右排列在接口集合中。&lt;/p&gt;

&lt;p&gt;　　字段表（field_info）用于描述类或者接口中声明的变量。字段包括了类级别变量和实例变量，但是不包括声明在方法中的变量。字段的名称，类型和修饰符等都是无法固定的，只能引用常量池中的常量来描述，可以包括的信息有：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;字段的作用域，如public，private等修饰符。&lt;/li&gt;
&lt;li&gt;示例变量还是类变量，如static修饰符。&lt;/li&gt;
&lt;li&gt;可变性，final修饰符&lt;/li&gt;
&lt;li&gt;并发可见性，volatile修饰符。&lt;/li&gt;
&lt;li&gt;可否被序列化，transient修饰符。&lt;/li&gt;
&lt;li&gt;字段数据类型，基本数据类型，数组，引用类型等。&lt;/li&gt;
&lt;li&gt;字段名称&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　字段表结构如下：&lt;/p&gt;
&lt;table border=&quot;2&quot; align=&quot;center&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;类型&lt;/td&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;数量&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;u2&lt;/td&gt;
&lt;td&gt;access_flags&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;u2&lt;/td&gt;
&lt;td&gt;name_index&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;u2&lt;/td&gt;
&lt;td&gt;descriptor_index&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;u2&lt;/td&gt;
&lt;td&gt;attribute_count&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;attribute_info&lt;/td&gt;
&lt;td&gt;attributes&lt;/td&gt;
&lt;td&gt;attribute_count&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;　　其中的access_flags与类中的access_flags非常类似，表示数据类型的修饰符，比如public，private，protected等，后面的name_index和descriptor_index都是对常量池的引用，分别表示字段的简单名称以及字段和方法的描述符。描述符的作用是用来描述字段的类型，方法的参数列表和返回值，根据描述符的规则，详细的描述符含义如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519364/201905/1519364-20190531163452609-1920201493.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　对于数组类型，每一个维度都将使用一个前置的“[”字符来描述，如一个整数数组int[] 将被记录为 &quot;[I&quot;，二维整数数组int[][] 记录为 &quot;[[I&quot;。而对于对于一个对象类型比如 String[] 数组，将被记录为 &quot;[Ljava/lang/String&quot;。用方法描述符描述方法时，先按照方法参数的顺序，然后再返回值的顺序来描述，比如 int get(String name,int[] index,int i,char c)方法的描述符为 &quot;(Ljava/lang/String[IIC)I&quot;。字段表都包含的固定的数据项在descriptor_index为止，不过在descriptor_index后是一个属性表集合，用于存储一些额外的信息。&lt;/p&gt;

&lt;p&gt;　　放发表（method_info）的结构与属性表的就够相同，方法里的Java代码经过编译器编译后编程字节码指令，然后存放在方法属性表的一个名为“Code”的属性里，关于属性表的项目，同样会在后面跟进行详细的介绍。&lt;/p&gt;
&lt;p&gt;　　与字段表集合相对应，如果父类方法在子类中没有被覆盖，方法表中就不会出现父类的方法的信息，但同样，有可能会出现会出现由编译器自动添加的方法，最典型的就是类构造器“&amp;lt;cinit&amp;gt;”方法和实例狗构造器&quot;&amp;lt;init&amp;gt;&quot;方法。&lt;/p&gt;
&lt;p&gt;　　在Java语言中，要重载一个方法，除了要方法与原方法的简单名称一样之外，还必须要求拥有一个与原方法不同的特征签名，特诊签名就是一个方法中各个参数在常量池中字段符号引用的集合，但是返回值不包含在特征签名中，因此Java语言中想要覆盖一个方法的话，如果是返回值不同是无法覆盖的。&lt;/p&gt;
&lt;p&gt;　　方法表的结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519364/201905/1519364-20190531171236493-1363604282.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　方法访问标志：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519364/201905/1519364-20190531171342437-1321103962.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　在Class文件，字段表和方法表中都可以携带自己的属性表集合，用于描述某些场景下专有的信息。属性表集合没有那么严格的限定，不再要求各个属性表具有严格的顺序，并且只要不予已有的属性表的名字重复，任何人实现的编译器都可以想属性表中写入自己定义的属性信息，但Java虚拟机在运行时会忽略掉它不认识的属性。Java虚拟机规范中预定义了9中虚拟机应当被识别的属性（jdk1.5后又增加了一些新的特性），如下表：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519364/201905/1519364-20190531172051850-1526359245.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　对于每个属性，它的名称都需要从常量池中引用的一个CONSTANT_Utf8_info类型的常量来表示，每个属性值的结构完全可以自定义，只需说明属性值所需暂用的位数长度即可，一个符合规范的属性表至少应具备attribute_name_info”、“attribute_length”和至少一项信息属性。&lt;/p&gt;
&lt;h2&gt;　　1）Code属性&lt;/h2&gt;
&lt;p&gt;　　前面已经提到过，Java程序的方法体中的代码经过编译器编译后，生成的字节码指令会存储在Code属性中，但并非所有的方法表都有属性表，比如抽象类和接口中可能不存在属性表。属性表的结构如下如所示：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519364/201905/1519364-20190531172645529-682692057.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　attribute_name_index是一项指向CONSTANT_Utf8_info型常量的索引，常量固定值为 &quot;Code&quot;，它代表了该属性的名称。attribute_length表示属性值的长度，由于属性名称索引与属性长度一共是6个字节，所以属性值长度为整个属性表长度减去 6个字节。&lt;/p&gt;
&lt;p&gt;　　max_stack代表操作数栈的最大深度，max_locals代表了局部变量表所需要的空间，它的单位为slot。&lt;/p&gt;
&lt;p&gt;　　code_length和code是用来存储Java源程序编译后生成的字节码指令。code用于存储字节码指令的一些列字节流，它是u1类型的单字节，因此取值范围为0x00到0xFF，那么一共可以存储256条指令，目前，Java虚拟机规范中已经定义了200条指令。code_length为u4类型，理论上可以达到2^32-1，但是虚拟机中明确的规定了一个方法不允许超过65525条字节码指令，如果超过了这个数值，编译器将拒绝编译。&lt;/p&gt;
&lt;p&gt;　　字节码指令之后是这个方法显示处理的异常表集合（exception_table），对于属性表来说这个属性不是必须存在的，它的格式如下表所示：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519364/201905/1519364-20190531175446703-2107502832.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　它包含四个字段，这些字段的含义是如果字节从 start_pc 到 end_pc 行之间（不含end_pc）出现了 catch_pc类型或者它的子类类型的异常（catch_type为指向一个CONSTANT_Class_info型常量的索引），则转到第handler_pc行继续处理，当catch_pc为0时，代表任何的异常都要转到handler_pc行进行处理。异常表实际上的Java代码的一部分，编译器使用异常表而不是简单地使用跳转的命令来实现Java的异常即finally处理机制，也因此，finally里面的代码内容会在try或catch中的return语句调用之前调用。&lt;/p&gt;
&lt;h2&gt;　　2）Exception属性&lt;/h2&gt;
&lt;p&gt;　　这里的Exception属性的作用是列举出方法中可能会出现的受检查异常，也就是方法描述是throws关键字后面列举的异常，它的结构很简单，只有attribute_name_index、attribute_length、number_of_exceptions、exception_index_table四项。&lt;/p&gt;
&lt;h2&gt;　　3）LineNumberTable属性&lt;/h2&gt;
&lt;p&gt;    　　它用于描述Java源码行号与字节码行号之间的对应关系。&lt;/p&gt;
&lt;h2&gt;      4）LocalVariableTable属性&lt;/h2&gt;
&lt;p&gt;     它用于描述栈帧中局部变量表中的变量与Java源码中定义的变量之间的对应关系。&lt;/p&gt;
&lt;h2&gt;     5）SourceFile属性&lt;/h2&gt;
&lt;p&gt;     它用于记录生成这个Class文件的源码文件名称。&lt;/p&gt;
&lt;h2&gt;     6）ConstantValue属性&lt;/h2&gt;
&lt;p&gt;　　ConstantValue属性的作用是通知虚拟机自动为静态变量赋值，只有被static修饰的变量才可以使用这项属性，在Java中对非static属性的赋值是在构造器中完成的，而对于类变量，则有两种方法可以选择，在类构造器赋值，或者在ConstantValue属性赋值。&lt;/p&gt;
&lt;h2&gt;　　7）InnerClasses属性&lt;/h2&gt;
&lt;p&gt;     该属性用于记录内部类与宿主类之间的关联。如果一个类中定义了内部类，那么编译器将会为它及它所包含的内部类生成InnerClasses属性。&lt;/p&gt;
&lt;h2&gt;     8）Deprecated属性和Synthetic属性&lt;/h2&gt;
&lt;p&gt;     该属性用于表示某个类、字段和方法，已经被程序作者定为不再推荐使用，它可以通过在代码中使用@Deprecated注释进行设置。&lt;/p&gt;
&lt;h2&gt;     9）Synthetic属性&lt;/h2&gt;
&lt;p&gt;     该属性代表此字段或方法并不是Java源代码直接生成的，而是由编译器自行添加的，如this字段和实例构造器、类构造器等。&lt;/p&gt;

&lt;p&gt;　　参考资料： 《深入理解Java虚拟机-JVM高级特性与最佳实践》 -周志明&lt;/p&gt;

&lt;h2&gt;　　&lt;span&gt;Java虚拟机相关系列博客推荐：&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　1、&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/rainple/p/10765752.html&quot;&gt;深入理解java虚拟机之java内存区域&lt;/a&gt; 　　&lt;/p&gt;
&lt;p&gt;　　2、&lt;a class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/rainple/p/10781203.html&quot;&gt;深入理解java虚拟机之对象真的死了吗&lt;/a&gt;  　　&lt;/p&gt;
&lt;p&gt;　　3、&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/rainple/p/10793500.html&quot;&gt;Java垃圾收集算法&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;　　4、&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/rainple/p/10829144.html&quot;&gt;深入理解java虚拟机之垃圾收集器&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　喜欢我写的博客的同学可以关注订阅号【Java解忧杂货铺】，里面不定期发布一些技术干活，也可以免费获取大量最新最流行的技术教学视频&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519364/201905/1519364-20190531212722668-467913550.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519364/201905/1519364-20190531212729391-1705085657.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519364/201905/1519364-20190531212750215-381322163.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 31 May 2019 10:41:00 +0000</pubDate>
<dc:creator>rainple</dc:creator>
<og:description>一、前言 代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。经过多年的发展，目前的计算机仍然只能识别0和1，但是由于近10年内虚拟机以及大量建立在虚拟机之上的程</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/rainple/p/10846917.html</dc:identifier>
</item>
</channel>
</rss>