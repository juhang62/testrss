<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>前端部署发展史 - 山月水风</title>
<link>http://www.cnblogs.com/xianwang/p/11846570.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xianwang/p/11846570.html</guid>
<description>&lt;p&gt;前端一说起刀耕火种，那肯定紧随着前端工程化这一话题。随着 &lt;code&gt;react&lt;/code&gt;/&lt;code&gt;vue&lt;/code&gt;/&lt;code&gt;angular&lt;/code&gt;，&lt;code&gt;es6+&lt;/code&gt;，&lt;code&gt;webpack&lt;/code&gt;，&lt;code&gt;babel&lt;/code&gt;，&lt;code&gt;typescript&lt;/code&gt; 以及 &lt;code&gt;node&lt;/code&gt; 的发展，前端已经在逐渐替代过去 &lt;code&gt;script&lt;/code&gt; 引 &lt;code&gt;cdn&lt;/code&gt; 开发的方式了，掀起了工程化这一大浪潮。得益于工程化的发展与开源社区的良好生态，前端应用的可用性与效率得到了很大提高。&lt;/p&gt;
&lt;p&gt;前端以前是刀耕火种，那前端应用部署在以前也是刀耕火种。那前端应用部署的发展得益于什么，随前端工程化带来的副产品？&lt;/p&gt;
&lt;p&gt;这只是一部分，而更重要的原因是 &lt;code&gt;devops&lt;/code&gt; 的崛起。&lt;/p&gt;
&lt;p&gt;为了更清晰地理解前端部署的发展史，了解部署时运维和前端（或者更广泛地说，业务开发人员）的职责划分，当每次前端部署发生改变时，可以思考两个问题&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;缓存，前端应用中http 的 &lt;code&gt;response header&lt;/code&gt; 由谁来配？得益于工程化发展，可以对打包后得到带有 hash 值的文件可以做永久缓存&lt;/li&gt;
&lt;li&gt;跨域，&lt;code&gt;/api&lt;/code&gt; 的代理配置由谁来配？在开发环境前端可以开个小服务，启用 &lt;code&gt;webpack-dev-server&lt;/code&gt; 配置跨域，那生产环境呢&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这两个问题都是前端面试时的高频问题，但话语权是否掌握在前端手里&lt;/p&gt;
&lt;p&gt;时间来到 &lt;code&gt;React&lt;/code&gt; 刚刚发展起来的这一年，这时已经使用 &lt;code&gt;React&lt;/code&gt; 开发应用，使用 &lt;code&gt;webpack&lt;/code&gt; 来打包。但是前端部署，仍是刀耕火种&lt;/p&gt;
&lt;h2 id=&quot;刀耕火种&quot;&gt;刀耕火种&lt;/h2&gt;
&lt;p&gt;一台跳板机&lt;/p&gt;
&lt;p&gt;一台生产环境服务器&lt;/p&gt;
&lt;p&gt;一份部署脚本&lt;/p&gt;
&lt;p&gt;前端调着他的 &lt;code&gt;webpack&lt;/code&gt;，开心地给运维发了部署邮件并附了一份部署脚本，想着第一次不用套后端的模板，第一次前端可以独立部署。想着自己基础盘进一步扩大，前端不禁开心地笑了&lt;/p&gt;
&lt;p&gt;运维照着着前端发过来的部署邮件，一遍又一遍地拉着代码，改着配置，写着 &lt;code&gt;try_files&lt;/code&gt;， 配着 &lt;code&gt;proxy_pass&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这时候，前端静态文件由 &lt;code&gt;nginx&lt;/code&gt; 托管，&lt;code&gt;nginx&lt;/code&gt; 配置文件大致长这个样子&lt;/p&gt;
&lt;pre class=&quot;nginx&quot;&gt;
&lt;code&gt;server {
  listen 80;
  server_name shanyue.tech;

  location / {
    # 避免非root路径404
    try_files $uri $uri/ /index.html;
  }

  # 解决跨域
  location /api {
    proxy_pass http://api.shanyue.tech;
  }

  # 为带 hash 值的文件配置永久缓存
  location ~* \.(?:css|js)$ {
      try_files $uri =404;
      expires 1y;
      add_header Cache-Control &quot;public&quot;;
  }

  location ~ ^.+\..+$ {
      try_files $uri =404;
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不过...经常有时候跑不起来&lt;/p&gt;
&lt;p&gt;运维抱怨着前端的部署脚本没有标好 &lt;code&gt;node&lt;/code&gt; 版本，前端嚷嚷着测试环境没问题&lt;/p&gt;
&lt;p&gt;这个时候运维需要费很多心力放在部署上，甚至测试环境的部署上，前端也要费很多心力放在运维如何部署上。这个时候由于怕影响线上环境，上线往往选择在深夜，前端和运维身心俱疲&lt;/p&gt;
&lt;p&gt;不过向来如此&lt;/p&gt;
&lt;p&gt;鲁迅说，向来如此，那便对么。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这个时候，无论跨域的配置还是缓存的配置，都是运维来管理，运维不懂前端。但配置方式却是前端在提供，而前端并不熟悉 nginx&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;使用-docker-构建镜像&quot;&gt;使用 docker 构建镜像&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;docker&lt;/code&gt; 的引进，很大程度地解决了部署脚本跑不了这个大BUG。&lt;strong&gt;&lt;code&gt;dockerfile&lt;/code&gt; 即部署脚本，部署脚本即 &lt;code&gt;dockerfile&lt;/code&gt;&lt;/strong&gt;。这也很大程度缓解了前端与运维的摩擦，毕竟前端越来越靠谱了，至少部署脚本没有问题了 (笑&lt;/p&gt;
&lt;p&gt;这时候，前端不再提供静态资源，而是提供服务，一个 &lt;code&gt;http&lt;/code&gt; 服务&lt;/p&gt;
&lt;p&gt;前端写的 &lt;code&gt;dockerfile&lt;/code&gt; 大致长这个样子&lt;/p&gt;
&lt;pre class=&quot;dockerfile&quot;&gt;
&lt;code&gt;FROM node:alpine

# 代表生产环境
ENV PROJECT_ENV production
# 许多 package 会根据此环境变量，做出不同的行为
# 另外，在 webpack 中打包也会根据此环境变量做出优化，但是 create-react-app 在打包时会写死该环境变量
ENV NODE_ENV production
WORKDIR /code
ADD . /code
RUN npm install &amp;amp;&amp;amp; npm run build &amp;amp;&amp;amp; npm install -g http-server
EXPOSE 80

CMD http-server ./public -p 80&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;单单有 &lt;code&gt;dockerfile&lt;/code&gt; 也跑不起来，另外前端也开始维护一个 &lt;code&gt;docker-compose.yaml&lt;/code&gt;，交给运维执行命令 &lt;code&gt;docker-compose up -d&lt;/code&gt; 启动前端应用。前端第一次写 &lt;code&gt;dockerfile&lt;/code&gt; 与 &lt;code&gt;docker-compose.yaml&lt;/code&gt;，在部署流程中扮演的角色越来越重要。想着自己基础盘进一步扩大，前端又不禁开心地笑了&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;version: &quot;3&quot;
services:
  shici:
    build: .
    expose:
      - 80&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运维的 &lt;code&gt;nginx&lt;/code&gt; 配置文件大致长这个样子&lt;/p&gt;
&lt;pre class=&quot;nginx&quot;&gt;
&lt;code&gt;server {
  listen 80;
  server_name shanyue.tech;

  location / {
    proxy_pass http://static.shanyue.tech;
  }

  location /api {
    proxy_pass http://api.shanyue.tech;
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运维除了配置 &lt;code&gt;nginx&lt;/code&gt; 之外，还要执行一个命令: &lt;code&gt;docker-compose up -d&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这时候再思考文章最前面两个问题&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;缓存，由于从静态文件转换为服务，缓存开始交由前端控制 (但是镜像中的 &lt;code&gt;http-server&lt;/code&gt; 不太适合做这件事情)&lt;/li&gt;
&lt;li&gt;跨域，跨域仍由运维在 &lt;code&gt;nginx&lt;/code&gt; 中配置&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;前端可以做他应该做的事情中的一部分了，这是一件令人开心的事情&lt;/p&gt;
&lt;p&gt;当然，前端对于 &lt;code&gt;dockerfile&lt;/code&gt; 的改进也是一个慢慢演进的过程，那这个时候镜像有什么问题呢？&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;构建镜像体积过大&lt;/li&gt;
&lt;li&gt;构建镜像时间过长&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;使用多阶段构建优化镜像&quot;&gt;使用多阶段构建优化镜像&lt;/h2&gt;
&lt;p&gt;这中间其实经历了不少坎坷，其中过程如何，详见我的另一篇文章: &lt;a href=&quot;https://juejin.im/post/5c83cbaa6fb9a04a0f65fdaa&quot;&gt;如何使用 docker 部署前端应用&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;其中主要的优化也是在上述所提到的两个方面&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;构建镜像体积由 1G+ 变为 10M+&lt;/li&gt;
&lt;li&gt;构建镜像时间由 5min+ 变为 1min (视项目复杂程度，大部分时间在构建时间与上传静态资源时间)&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;dockerfile&quot;&gt;
&lt;code&gt;FROM node:alpine as builder

ENV PROJECT_ENV production
ENV NODE_ENV production

WORKDIR /code

ADD package.json /code
RUN npm install --production

ADD . /code

# npm run uploadCdn 是把静态资源上传至 oss 上的脚本文件，将来会使用 cdn 对 oss 加速
RUN npm run build &amp;amp;&amp;amp; npm run uploadCdn

# 选择更小体积的基础镜像
FROM nginx:alpine
COPY --from=builder code/public/index.html code/public/favicon.ico /usr/share/nginx/html/
COPY --from=builder code/public/static /usr/share/nginx/html/static&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那它怎么做的&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;先 &lt;code&gt;ADD package.json /code&lt;/code&gt;, 再 &lt;code&gt;npm install --production&lt;/code&gt; 之后 &lt;code&gt;Add&lt;/code&gt; 所有文件。充分利用镜像缓存，减少构建时间&lt;/li&gt;
&lt;li&gt;多阶段构建，大大减小镜像体积&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;另外还可以有一些小优化，如&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;npm cache&lt;/code&gt; 的基础镜像或者 &lt;code&gt;npm&lt;/code&gt; 私有仓库，减少 &lt;code&gt;npm install&lt;/code&gt; 时间，减小构建时间&lt;/li&gt;
&lt;li&gt;&lt;code&gt;npm install --production&lt;/code&gt; 只装必要的包&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;前端看着自己优化的 &lt;code&gt;dockerfile&lt;/code&gt;，想着前几天还被运维吵，说什么磁盘一半的空间都被前端的镜像给占了，想着自己节省了前端镜像几个数量级的体积，为公司好像省了不少服务器的开销，想着自己的基础盘进一步扩大，又不禁开心的笑了&lt;/p&gt;
&lt;p&gt;这时候再思考文章最前面两个问题&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;缓存，缓存由前端控制，缓存在oss上设置，将会使用 cdn 对 oss 加速。此时缓存由前端写脚本控制&lt;/li&gt;
&lt;li&gt;跨域，跨域仍由运维在 &lt;code&gt;nginx&lt;/code&gt; 中配置&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;cicd-与-gitlab&quot;&gt;CI/CD 与 gitlab&lt;/h2&gt;
&lt;p&gt;此时前端成就感爆棚，运维呢？运维还在一遍一遍地上线，重复着一遍又一遍的三个动作用来部署&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;拉代码&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker-compose up -d&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;重启 nginx&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;运维觉得再也不能这么下去了，于是他引进了 &lt;code&gt;CI&lt;/code&gt;: 与现有代码仓库 &lt;code&gt;gitlab&lt;/code&gt; 配套的 &lt;code&gt;gitlab ci&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;CI&lt;/code&gt;，&lt;code&gt;Continuous Integration&lt;/code&gt;，持续集成&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CD&lt;/code&gt;，&lt;code&gt;Continuous Delivery&lt;/code&gt;，持续交付&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;重要的不是 &lt;code&gt;CI/CD&lt;/code&gt; 是什么，重要的是现在运维不用跟着业务上线走了，不需要一直盯着前端部署了。这些都是 &lt;code&gt;CI/CD&lt;/code&gt; 的事情了，它被用来做自动化部署。上述提到的三件事交给了 &lt;code&gt;CI/CD&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;.gitlab-ci.yml&lt;/code&gt; 是 &lt;code&gt;gitlab&lt;/code&gt; 的 CI 配置文件，它大概长这个样子&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;deploy:
  stage: deploy
  only:
    - master
  script:
    - docker-compose up --build -d
  tags:
    - shell&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;CI/CD&lt;/code&gt; 不仅仅更解放了业务项目的部署，也在交付之前大大加强了业务代码的质量，它可以用来 &lt;code&gt;lint&lt;/code&gt;，&lt;code&gt;test&lt;/code&gt;，&lt;code&gt;package&lt;/code&gt; 安全检查，甚至多特性多环境部署，我将会在我以后的文章写这部分事情&lt;/p&gt;
&lt;p&gt;我的一个服务器渲染项目 &lt;a href=&quot;https://github.com/shfshanyue/shici&quot;&gt;shfshanyue/shici&lt;/a&gt; 以前在我的服务器中就是以 &lt;code&gt;docker&lt;/code&gt;/&lt;code&gt;docker-compose/gitlab-ci&lt;/code&gt; 的方式部署，有兴趣的可以看看它的配置文件&lt;/p&gt;
&lt;p&gt;如果你有个人服务器的话，也建议你做一个自己感兴趣的前端应用和配套的后端接口服务，并且配套 &lt;code&gt;CI/CD&lt;/code&gt; 把它部署在自己的自己服务器上&lt;/p&gt;
&lt;p&gt;而你如果希望结合 &lt;code&gt;github&lt;/code&gt; 做 &lt;code&gt;CI/CD&lt;/code&gt;，那可以试一试 &lt;code&gt;github&lt;/code&gt; + &lt;code&gt;github action&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;另外，也可以试试 &lt;code&gt;drone.ci&lt;/code&gt;，如何部署可以参考我以前的文章: &lt;a href=&quot;https://juejin.im/post/5dc0b563f265da4cef190b8a&quot;&gt;github 上持续集成方案 drone 的简介及部署&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;使用-kubernetes-部署&quot;&gt;使用 kubernetes 部署&lt;/h2&gt;
&lt;p&gt;随着业务越来越大，镜像越来越多，&lt;code&gt;docker-compose&lt;/code&gt; 已经不太能应付，&lt;code&gt;kubernetes&lt;/code&gt; 应时而出。这时服务器也从1台变成了多台，多台服务器就会有分布式问题&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一门新技术的出现，在解决以前问题的同时也会引进复杂性。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;k8s 部署的好处很明显: 健康检查，滚动升级，弹性扩容，快速回滚，资源限制，完善的监控等等&lt;/p&gt;
&lt;p&gt;那现在遇到的新问题是什么？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;构建镜像的服务器，提供容器服务的服务器，做持续集成的服务器是一台！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;需要一个私有的镜像仓库，这是运维的事情，&lt;code&gt;harbor&lt;/code&gt; 很快就被运维搭建好了，但是对于前端部署来说，复杂性又提高了&lt;/p&gt;
&lt;p&gt;先来看看以前的流程:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;前端配置 &lt;code&gt;dockerfile&lt;/code&gt; 与 &lt;code&gt;docker-compose&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;生产环境服务器的 &lt;code&gt;CI runner&lt;/code&gt; 拉代码(可以看做以前的运维)，&lt;code&gt;docker-compose up -d&lt;/code&gt; 启动服务。然后再重启 &lt;code&gt;nginx&lt;/code&gt;，做反向代理，对外提供服务&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;以前的流程有一个问题: &lt;strong&gt;构建镜像的服务器，提供容器服务的服务器，做持续集成的服务器是一台！&lt;/strong&gt;，所以需要一个私有的镜像仓库，一个能够访问 &lt;code&gt;k8s&lt;/code&gt; 集群的持续集成服务器&lt;/p&gt;
&lt;p&gt;流程改进之后结合 &lt;code&gt;k8s&lt;/code&gt; 的流程如下&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;前端配置 &lt;code&gt;dockerfile&lt;/code&gt;，构建镜像，推到镜像仓库&lt;/li&gt;
&lt;li&gt;运维为前端应用配置 &lt;code&gt;k8s&lt;/code&gt; 的资源配置文件，&lt;code&gt;kubectl apply -f&lt;/code&gt; 时会重新拉取镜像，部署资源&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;运维问前端，需不需要再扩大下你的基础盘，写一写前端的 &lt;code&gt;k8s&lt;/code&gt; 资源配置文件，并且列了几篇文章&lt;/p&gt;
&lt;p&gt;前端看了看后端十几个 k8s 配置文件之后，摇摇头说算了算了&lt;/p&gt;
&lt;p&gt;这个时候，&lt;code&gt;gitlab-ci.yaml&lt;/code&gt; 差不多长这个样子，配置文件的权限由运维一人管理&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;deploy:
  stage: deploy
  only:
    - master
  script:
    - docker build -t harbor.shanyue.tech/fe/shanyue
    - docker push harbor.shanyue.tech/fe/shanyue
    - kubectl apply -f https://k8s-config.default.svc.cluster.local/shanyue.yaml
  tags:
    - shell&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时候再思考文章最前面两个问题&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;缓存，缓存由前端控制&lt;/li&gt;
&lt;li&gt;跨域，跨域仍由运维控制，在后端 &lt;code&gt;k8s&lt;/code&gt; 资源的配置文件中控制 &lt;code&gt;Ingress&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;使用-helm-部署&quot;&gt;使用 helm 部署&lt;/h2&gt;
&lt;p&gt;这时前端与运维已不太往来，除了偶尔新起项目需要运维帮个忙以外&lt;/p&gt;
&lt;p&gt;但好景不长，突然有一天，前端发现自己连个环境变量都没法传！于是经常找运维修改配置文件，运维也不胜其烦&lt;/p&gt;
&lt;p&gt;于是有了 &lt;code&gt;helm&lt;/code&gt;，如果用一句话解释它，那它就是一个带有模板功能的 &lt;code&gt;k8s&lt;/code&gt; 资源配置文件。作为前端，你只需要填参数。更多详细的内容可以参考我以前的文章 &lt;a href=&quot;https://juejin.im/post/5dbf7909f265da4d4b5fe7b4&quot;&gt;使用 helm 部署 k8s 资源&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;假如我们使用 &lt;a href=&quot;https://hub.helm.sh/charts/bitnami/nginx&quot;&gt;bitnami/nginx&lt;/a&gt; 作为 &lt;code&gt;helm chart&lt;/code&gt;，前端可能写的配置文件长这个样子&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;image:
  registry: harbor.shanyue.tech
  repository: fe/shanyue
  tag: 8a9ac0

ingress:
  enabled: true
  hosts:
  - name: shanyue.tech
    path: /

  tls:
  - hosts:
      - shanyue.tech
    secretName: shanyue-tls

    # livenessProbe:
    #   httpGet:
    #     path: /
    #     port: http
    #   initialDelaySeconds: 30
    #   timeoutSeconds: 5
    #   failureThreshold: 6
    #
    # readinessProbe:
    #   httpGet:
    #     path: /
    #     port: http
    #   initialDelaySeconds: 5
    #   timeoutSeconds: 3
    #   periodSeconds: 5&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时候再思考文章最前面两个问题&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;缓存，缓存由前端控制&lt;/li&gt;
&lt;li&gt;跨域，跨域由后端控制，配置在后端 Chart 的配置文件 &lt;code&gt;values.yaml&lt;/code&gt; 中&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;到了这时前端和运维的职责所在呢？&lt;/p&gt;
&lt;p&gt;前端需要做的事情有:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;写前端构建的 &lt;code&gt;dockerfile&lt;/code&gt;，这只是一次性的工作，而且有了参考&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;helm&lt;/code&gt; 部署时指定参数&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;那运维要做的事情呢&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;提供一个供所有前端项目使用的 &lt;code&gt;helm chart&lt;/code&gt;，甚至不用提供，如果运维比较懒那就就使用 &lt;a href=&quot;https://hub.helm.sh/charts/bitnami/nginx&quot;&gt;bitnami/nginx&lt;/a&gt; 吧。也是一次性工作&lt;/li&gt;
&lt;li&gt;提供一个基于 &lt;code&gt;helm&lt;/code&gt; 的工具，禁止业务过多的权限，甚至不用提供，如果运维比较懒那就直接使用 &lt;code&gt;helm&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这时前端可以关注于自己的业务，运维可以关注于自己的云原生，职责划分从未这般清楚&lt;/p&gt;
&lt;h2 id=&quot;统一前端部署平台&quot;&gt;统一前端部署平台&lt;/h2&gt;
&lt;p&gt;后来运维觉得前端应用的本质是一堆静态文件，较为单一，容易统一化，来避免各个前端镜像质量的参差不齐。于是运维准备了一个统一的 &lt;code&gt;node&lt;/code&gt; 基础镜像，做了一个前端统一部署平台，而这个平台可以做什么呢&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;CI/CD&lt;/code&gt;: 当你 push 代码到仓库的特定分支会自动部署&lt;/li&gt;
&lt;li&gt;&lt;code&gt;http headers&lt;/code&gt;: 你可以定制资源的 &lt;code&gt;http header&lt;/code&gt;，从而可以做&lt;strong&gt;缓存优化&lt;/strong&gt;等&lt;/li&gt;
&lt;li&gt;&lt;code&gt;http redirect/rewrite&lt;/code&gt;: 如果一个 &lt;code&gt;nginx&lt;/code&gt;，这样可以配置 &lt;code&gt;/api&lt;/code&gt;，解决跨域问题&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hostname&lt;/code&gt;: 你可以设置域名&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CDN&lt;/code&gt;: 把你的静态资源推到 CDN&lt;/li&gt;
&lt;li&gt;&lt;code&gt;https&lt;/code&gt;: 为你准备证书&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Prerender&lt;/code&gt;: 结合 &lt;code&gt;SPA&lt;/code&gt;，做预渲染&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;前端再也不需要构建镜像，上传 CDN 了，他只需要写一份配置文件就可以了，大致长这个样子&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;build:
  command: npm run build
  dist: /dist

hosts:
- name: shanyue.tech
  path: /

headers:
- location: /*
  values:
  - cache-control: max-age=7200
- location: assets/*
  values:
  - cache-control: max-age=31536000

redirects:
- from : /api
  to: https://api.shanyue.tech
  status: 200&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时，前端只需要写一份配置文件，就可以配置缓存，配置 &lt;code&gt;proxy&lt;/code&gt;，做应该属于前端做的一切，而运维也再也不需要操心前端部署的事情了&lt;/p&gt;
&lt;p&gt;前端看着自己刚刚写好的配置文件，怅然若失的样子...&lt;/p&gt;
&lt;p&gt;不过一般只有大厂会有这么完善的前端部署平台，如果你对它有兴趣，你可以尝试下 &lt;code&gt;netlify&lt;/code&gt;，可以参考我的文章: &lt;a href=&quot;https://shanyue.tech/op/deploy-fe-with-netlify.html&quot;&gt;使用 netlify 部署你的前端应用&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;服务端渲染与后端部署&quot;&gt;服务端渲染与后端部署&lt;/h2&gt;
&lt;p&gt;大部分前端应用本质上是静态资源，剩下的少部分就是服务端渲染了，服务端渲染的本质上是一个后端服务，它的部署可以视为后端部署&lt;/p&gt;
&lt;p&gt;后端部署的情况更为复杂，比如&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;配置服务，后端需要访问敏感数据，但又不能把敏感数据放在代码仓库。你可以在 &lt;code&gt;environment variables&lt;/code&gt;， &lt;code&gt;consul&lt;/code&gt; 或者 &lt;code&gt;k8s configmap&lt;/code&gt; 中维护&lt;/li&gt;
&lt;li&gt;上下链路服务，你需要依赖数据库，上游服务&lt;/li&gt;
&lt;li&gt;访问控制，限制 IP，黑白名单&lt;/li&gt;
&lt;li&gt;RateLimit&lt;/li&gt;
&lt;li&gt;等等&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我将在以后的文章分享如何在 k8s 中部署一个后端&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;随着 &lt;code&gt;devops&lt;/code&gt; 的发展，前端部署越来越简单，可控性也越来越高，建议所有人都稍微学习一下 &lt;code&gt;devops&lt;/code&gt; 的东西。&lt;/p&gt;
&lt;p&gt;道阻且长，行则将至。&lt;/p&gt;
&lt;h2 id=&quot;相关文章&quot;&gt;相关文章&lt;/h2&gt;
</description>
<pubDate>Wed, 13 Nov 2019 00:22:00 +0000</pubDate>
<dc:creator>山月水风</dc:creator>
<og:description>前端一说起刀耕火种，那肯定紧随着前端工程化这一话题。随着 /`vue angular es6+ webpack babel typescript node script cdn` 开发的方式了，掀起了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xianwang/p/11846570.html</dc:identifier>
</item>
<item>
<title>[ASP.NET Core 3框架揭秘] 依赖注入[7]：服务消费 - Artech</title>
<link>http://www.cnblogs.com/artech/p/inside-asp-net-core-03-07.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/artech/p/inside-asp-net-core-03-07.html</guid>
<description>&lt;p&gt;包含服务注册信息的IServiceCollection集合最终被用来创建作为依赖注入容器的IServiceProvider对象。当需要消费某个服务实例的时候，我们只需要指定服务类型调用IServiceProvider的GetService方法即可，IServiceProvider对象就会根据对应的服务注册提供所需的服务实例。&lt;/p&gt;

&lt;p&gt;如下面的代码片段所示，IServiceProvider接口定义了唯一的&lt;span&gt;GetService&lt;/span&gt;方法根据指定的类型来提供对应的服务实例。当利用包含服务注册的IServiceCollection对象创建出IServiceProvider对象之后，我们只需要将服务注册的服务类型（对应于ServiceDescriptor的ServiceType属性）作为参数调用GetService方法，该方法就能根据服务注册信息为我们提供对应的服务实例。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IServiceProvider
{
    &lt;/span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt; GetService(Type serviceType);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;针对IServiceProvider对象的创建体现在IServiceCollection接口的三个BuildServiceProvider扩展方法重载上。如下的代码片段所示，这三个扩展方法提供的都是一个类型为ServiceProvider的对象，该对象根据提供的配置选项来创建。配置选项类型ServiceProviderOptions提供了两个属性，其中&lt;span&gt;ValidateScopes&lt;/span&gt;属性表示是否需要开启针对服务范围的验证，而&lt;span&gt;ValidateOnBuild&lt;/span&gt;属性则表示是否需要预先检验作为服务注册的每个ServiceDescriptor对象能否提供对应的服务实例。默认情况下这两种类型的检验都是关闭的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ServiceProviderOptions
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; ValidateScopes { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; ValidateOnBuild { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;internal&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; ServiceProviderOptions Default  = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServiceProviderOptions();
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ServiceCollectionContainerBuilderExtensions
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ServiceProvider BuildServiceProvider( &lt;span&gt;this&lt;/span&gt;&lt;span&gt; IServiceCollection services)
        &lt;/span&gt;=&amp;gt;&lt;span&gt; BuildServiceProvider(services, ServiceProviderOptions.Default);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ServiceProvider BuildServiceProvider( &lt;span&gt;this&lt;/span&gt; IServiceCollection services, &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; validateScopes)
        &lt;/span&gt;=&amp;gt; services.BuildServiceProvider(&lt;span&gt;new&lt;/span&gt; ServiceProviderOptions {  ValidateScopes =&lt;span&gt; validateScopes });

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ServiceProvider BuildServiceProvider( &lt;span&gt;this&lt;/span&gt;&lt;span&gt; IServiceCollection services, ServiceProviderOptions options)
        &lt;/span&gt;=&amp;gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServiceProvider(services, options);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;虽然调用IServiceCollection的BuildServiceProvider扩展方法返回总是一个ServiceProvider对象，但是我并不打算详细介绍这个类型，这是因为ServiceProvider涉及到一系列内部类型和接口，并且实现在该类型中针对服务实例的提供机制一直在不断的变化，而且这个变化趋势在未来版本更替过程中可能还将继续下去。&lt;/p&gt;
&lt;p&gt;除了定义在IServiceProvider接口中的GetService方法，该接口还具有如下这些扩展方法来提供服务实例。GetService&amp;lt;T&amp;gt;方法以泛型参数的形式指定了服务类型，返回的服务实例也会作对应的类型转换。如果指定服务类型的服务注册不存在，GetService方法会返回Null，如果调用GetRequiredService或者GetRequiredService&amp;lt;T&amp;gt;方法则会抛出一个InvalidOperationException类型的异常。如果所需的服务实例是必需的，我们一般会调用这两个扩展方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ServiceProviderServiceExtensions
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; T GetService&amp;lt;T&amp;gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IServiceProvider provider);

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; T GetRequiredService&amp;lt;T&amp;gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IServiceProvider provider);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; GetRequiredService(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IServiceProvider provider,  Type serviceType);
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IEnumerable&amp;lt;T&amp;gt; GetServices&amp;lt;T&amp;gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IServiceProvider provider);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IEnumerable&amp;lt;&lt;span&gt;object&lt;/span&gt;&amp;gt; GetServices(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IServiceProvider provider,  Type serviceType);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;正如前面多次提到的，如果针对某个类型添加了多个服务注册，那么GetService方法总是会采用最新添加的服务注册来提供服务实例。如果希望利用所有的服务注册来创建一组服务实例列表，我们可以调用GetServices或者GetServices&amp;lt;T&amp;gt;方法，也可以调用GetService&amp;lt;IEnumerable&amp;lt;T&amp;gt;&amp;gt;方法。&lt;/p&gt;

&lt;p&gt;对于通过调用IServiceCollection集合的BuildServiceProvider方法创建的IServiceProvider对象来说，当我们通过指定服务类型调用其GetService方法以获取对应的服务实例的时候，它总是会根据提供的服务类型从服务注册列表中找到对应的ServiceDescriptor对象，并根据它来提供所需的服务实例。&lt;/p&gt;
&lt;p&gt;ServiceDescriptor具有&lt;span&gt;三个不同的构造函数&lt;/span&gt;，分别对应着服务实例最初的三种提供方式，我们可以提供一个&lt;span&gt;Func&amp;lt;IServiceProvider, object&amp;gt;&lt;/span&gt;对象作为工厂来创建对应的服务实例，也可以&lt;span&gt;直接提供一个创建好的服务实例&lt;/span&gt;。如果我们提供的是服务的实现类型，那么最终提供的服务实例将通过调用该类型的某个构造函数来创建，那么构造函数是通过怎样的策略被选择出来的呢？&lt;/p&gt;
&lt;p&gt;如果IServiceProvider对象试图通过调用构造函数的方式来创建服务实例，传入构造函数的所有参数必须先被初始化，所以最终被选择出来的构造函数必须具备一个基本的条件，那就是&lt;span&gt;IServiceProvider能够提供构造函数的所有参数&lt;/span&gt;。为了让读者朋友能够更加深刻地理解IServiceProvider在构造函数选择过程中采用的策略，我们会采用实例演示的方式对此进行讲述。&lt;/p&gt;
&lt;p&gt;我们在一个控制台应用中定义了四个服务接口（IFoo、IBar、IBaz和IGux）以及实现它们的四个类（Foo、Bar、Baz和Gux）。如下面的代码片段所示，我们为Gux定义了三个构造函数，参数均为我们定义了服务接口类型。为了确定IServiceProvider最终选择哪个构造函数来创建目标服务实例，我们在构造函数执行时在控制台上输出相应的指示性文字。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IFoo {}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IBar {}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IBaz {}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IGux {}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo : IFoo {}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Bar : IBar {}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Baz : IBaz {}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Gux : IGux
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Gux(IFoo foo)  =&amp;gt; Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Selected constructor: Gux(IFoo)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Gux(IFoo foo, IBar bar)  =&amp;gt; Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Selected constructor: Gux(IFoo, IBar)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Gux(IFoo foo, IBar bar, IBaz baz)  =&amp;gt; Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Selected constructor: Gux(IFoo, IBar, IBaz)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在如下这段演示程序中我们创建了一个ServiceCollection对象并在其中添加针对IFoo、IBar以及IGux这三个服务接口的服务注册，针对服务接口IBaz的注册并未被添加。我们利用由它创建的IServiceProvider来提供针对服务接口IGux的实例，究竟能否得到一个Gux对象呢？如果可以，它又是通过执行哪个构造函数创建的呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
    {       
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServiceCollection()
            .AddTransient&lt;/span&gt;&amp;lt;IFoo, Foo&amp;gt;&lt;span&gt;()
            .AddTransient&lt;/span&gt;&amp;lt;IBar, Bar&amp;gt;&lt;span&gt;()
            .AddTransient&lt;/span&gt;&amp;lt;IGux, Gux&amp;gt;&lt;span&gt;()
            .BuildServiceProvider()
            .GetServices&lt;/span&gt;&amp;lt;IGux&amp;gt;&lt;span&gt;();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于定义在Gux中的三个构造函数来说，由于创建IServiceProvider提供的IServiceCollection集合包含针对接口IFoo和IBar的服务注册，所以它能够提供前面两个构造函数的所有参数。由于第三个构造函数具有一个类型为IBaz的参数，这无法通过IServiceProvider对象来提供。根据我们前面介绍的第一个原则（IServiceProvider对象能够提供构造函数的所有参数），Gux的前两个构造函数会成为合法的候选构造函数，那么IServiceProvider最终会选择哪一个呢？&lt;/p&gt;
&lt;p&gt;在所有合法的候选构造函数列表中，最终被选择出来的构造函数具有这么一个特征：每一个候选构造函数的参数类型集合都是这个构造函数参数类型集合的子集。如果这样的构造函数并不存在，一个InvalidOperationException类型的异常会被抛出来。根据这个原则，Gux的第二个构造函数的参数类型包括IFoo和IBar，而第一个构造函数仅仅具有一个类型为IFoo的参数，最终被选择出来的会是Gux的第二个构造函数，所以运行我们的实例程序将会在控制台上产生如下图所示的输出结果。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/201911/19327-20191113081628444-242226879.png&quot;&gt;&lt;img width=&quot;389&quot; height=&quot;124&quot; title=&quot;4-6&quot; alt=&quot;4-6&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/201911/19327-20191113081628781-1309652307.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;接下来我们对实例程序略加改动。如下面的代码片段所示，我们只为Gux定义两个构造函数，它们都具有两个参数，参数类型分别为IFoo &amp;amp; IBar和IBar &amp;amp; IBaz。我们将针对IBaz / Baz的服务注册添加到创建的ServiceCollection集合中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
    {       
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServiceCollection()
            .AddTransient&lt;/span&gt;&amp;lt;IFoo, Foo&amp;gt;&lt;span&gt;()
            .AddTransient&lt;/span&gt;&amp;lt;IBar, Bar&amp;gt;&lt;span&gt;()
          &lt;/span&gt;&lt;span&gt;&lt;strong&gt;  .AddTransient&amp;lt;IBaz, Baz&amp;gt;()&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;
            .AddTransient&lt;/span&gt;&amp;lt;IGux, Gux&amp;gt;&lt;span&gt;()
            .BuildServiceProvider()
            .GetServices&lt;/span&gt;&amp;lt;IGux&amp;gt;&lt;span&gt;();
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Gux : IGux
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Gux(IFoo foo, IBar bar) {}
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Gux(IBar bar, IBaz baz) {}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于Gux的两个构造函数，虽然它们的参数均能够由IServiceProvider对象来提供，但是并没有一个构造函数的参数类型集合能够成为所有有效构造函数参数类型集合的超集，所以IServiceProvider无法选择出一个最佳的构造函数。运行该程序后会抛出如下图所示的InvalidOperationException异常，并提示无法从两个候选的构造函数中选择出一个最优的来创建服务实例。（S409）&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/201911/19327-20191113081628989-1392128222.png&quot;&gt;&lt;img width=&quot;502&quot; height=&quot;212&quot; title=&quot;4-7&quot; alt=&quot;4-7&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/201911/19327-20191113081629275-403837260.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-01.html&quot;&gt;[ASP.NET Core 3框架揭秘] 依赖注入[1]：控制反转&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-02.html&quot;&gt;[ASP.NET Core 3框架揭秘] 依赖注入[2]：IoC模式&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-03.html&quot;&gt;[ASP.NET Core 3框架揭秘] 依赖注入[3]：依赖注入模式&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-04.html&quot;&gt;[ASP.NET Core 3框架揭秘] 依赖注入[4]：一个迷你版DI框架&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-05.html&quot;&gt;[ASP.NET Core 3框架揭秘] 依赖注入[5]：利用容器提供服务&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-06.html&quot;&gt;[ASP.NET Core 3框架揭秘] 依赖注入[6]：服务注册&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-07.html&quot;&gt;[ASP.NET Core 3框架揭秘] 依赖注入[7]：服务消费&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-08.html&quot;&gt;[ASP.NET Core 3框架揭秘] 依赖注入[8]：服务实例的生命周期&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-09.html&quot;&gt;[ASP.NET Core 3框架揭秘] 依赖注入[9]：实现概述&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-10.html&quot;&gt;[ASP.NET Core 3框架揭秘] 依赖注入[10]：与第三方依赖注入框架的适配&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 13 Nov 2019 00:16:00 +0000</pubDate>
<dc:creator>Artech</dc:creator>
<og:description>包含服务注册信息的IServiceCollection集合最终被用来创建作为依赖注入容器的IServiceProvider对象。当需要消费某个服务实例的时候，我们只需要指定服务类型调用IService</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/artech/p/inside-asp-net-core-03-07.html</dc:identifier>
</item>
<item>
<title>《JS高程》-教你如何写出可维护的代码 - Peerless1029</title>
<link>http://www.cnblogs.com/peerless1029/p/11846404.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/peerless1029/p/11846404.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;1、前言&lt;/h3&gt;
&lt;p&gt;  在平时工作开发中，大部分开发人员都花费大量的时间在维护其他人员的代码。很难从头开始开发新代码，很多情况下都是以他人成果为基础的，或者新增修改需求，自己写的代码也会被其他开发人员调用，所以写好一份高质量可维护的代码就显得十分重要。&lt;/p&gt;
&lt;h3 id=&quot;什么是可维护代码&quot;&gt;2、什么是可维护代码&lt;/h3&gt;
&lt;p&gt;可维护代码需要遵循以下几个特点。&lt;/p&gt;
&lt;p&gt;1.&lt;strong&gt;可理解性&lt;/strong&gt;-其他人可以接手代码并理解它的意图和一般途径。&lt;br/&gt;2.&lt;strong&gt;直观性&lt;/strong&gt;-代码中的东西一看就明白，不管其操作过程有多复杂。&lt;br/&gt;3.&lt;strong&gt;可适应性&lt;/strong&gt;-代码以一种数据变化不要求完全重写的方法撰写。&lt;br/&gt;4.&lt;strong&gt;可扩展性&lt;/strong&gt;-在代码架构上已考虑在未来允许对核心功能进行扩展。&lt;br/&gt;5.&lt;strong&gt;可调试性&lt;/strong&gt;-当有地方出错时，代码可以给你足够的信息快速直接找出问题的所在。&lt;/p&gt;
&lt;h3 id=&quot;代码约定&quot;&gt;3、代码约定&lt;/h3&gt;
&lt;p&gt;  一种让代码变得可维护的简单途径是形成一套JavaScript代码的书写约定。由于JavaScript的可适应性，代码约定对它很重要。以下小节讨论代码约定的概论。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.可读性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  要让代码可维护，首先它必须可读。可读性的大部分内容和代码缩进相关的，代码整齐的缩进能一眼看出代码块是属于那个功能的，很常见的缩进大小为4个空格，现在大部分编辑器也支持一件格式化代码。可读性另一方面是注释，一般来说，有如下一些地方需要进行注释。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;函数和方法&lt;/strong&gt;-每个方法或注释都应该包含一个注释，用于描述其目的和用于完成任务所可能使用的算法。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;大段代码&lt;/strong&gt;-用于完成单个任务的多行代码应该在前面放一个描述任务的注释。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;复杂的算法&lt;/strong&gt;-使用独特的方式来解决某个问题加以注释来解释如何做的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Hack&lt;/strong&gt;-浏览器兼容性处理。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;2.变量和函数的命名&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  话说在平时开发中最让人头疼的事莫过于命名了，无论是class的命名还是一些变量与方法的命名，所以有时候不得不靠一些翻译软件来帮助命名。适当给变量和函数起名字对于增加代码的可理解性和可维护性是非常重要的。命名规则一般如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;变量名应为名词如car或person。&lt;/li&gt;
&lt;li&gt;函数名应以动词开始，如getName()。&lt;/li&gt;
&lt;li&gt;返回布尔类型的函数一般用is开头，如isEnable()。&lt;/li&gt;
&lt;li&gt;常量应该用全部大写表示，如MAX_LENGTH。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;3.变量类型透明&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  由于在JavaScript中变量是松散类型的，很容易忘记变量所包含的数据类型。合适的命名方式在一定程度上可以缓解这个问题，但是放到所有的情况下看还不够，还有三种变量数据来表示数据类型的方式。&lt;/p&gt;
&lt;p&gt;3.3.1、初始化&lt;/p&gt;
&lt;p&gt;  当定义一个变量后，它应该被初始化一个值，来暗示它将来应该如何应用。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 通过初始化指定变量类型
var found=false; //布尔型
var count=-1; //数字型
var name=&quot;&quot;; //字符串
var person=null; //对象&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.3.2、使用匈牙利标记法指定变量类型&lt;/p&gt;
&lt;p&gt;  匈牙利标记法在变量名之前加上一个或多个字符来表示数据类型。JS中最传统的匈牙利标记法是用单个字符来表示基本类型：0-对象，s-字符串，i-整数，f-浮点数，b-布尔类型。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 用于指定数据类型的匈牙利命名法
var bFound //布尔型
var iCount; //数字型
var sName; //字符串
var oPerson; //对象&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;匈牙利命名法好处是函数参数也一样可以使用，但它缺点是让代码在某种程度上那一阅读。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;3.3.3、使用类型注释&lt;/p&gt;
&lt;p&gt;  最后一种指定变量类型的方式是使用类型注释。类型注释放在变量名右边，但是在初始化前面。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 用于指定类型的类型注释
var found /*Boolean*/ = false;
var count /*int*/ = 10;
var name /*String*/ = &quot;Tom&quot;;
var person /*Object*/ = null;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;缺点：多行注释会与代码块冲突&lt;/em&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;这三种常见的指定变量数据类型的方法，各有优势与劣势，根据自己项目加以评估再进行使用，也可以学习使用下TypeScript。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;松散耦合&quot;&gt;4、松散耦合&lt;/h3&gt;
&lt;p&gt;  只要应用的某个部分过分依赖另一部分，代码就是偶尔过紧，难以维护。因为Web应用技术，有多种情况回使它变得耦合过紧，因此应该避免这些情况，并尽可能维护弱耦合代码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.解耦HTML/JavaScript&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  直接在HTML中的javaScript,使用包含内联代码的&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;元素或者是使用HTML属性来分配事件处理顺序，都是过于紧密耦合。&lt;br/&gt;看看以下的代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;button onclick=&quot;doSomeThing()&quot;&amp;gt;Click Me&amp;lt;/button&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  在这个例子中，可能在doSomeThing()函数可用之前，就已经按下按钮，导致js错误，因为任何对按钮行为的更改要同时触及HTML和js,影响可维护性。&lt;/p&gt;
&lt;p&gt;同理js中包含大量的HTML&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 将HTML紧密耦合到js中
function insertMessage(){
  document.getElementById('container').innerHTML='&amp;lt;div&amp;gt;Hello World&amp;lt;/div&amp;gt;'
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码的方法会动态生成一段代码块插入到页面中，当代码很多时候难以定位到错误。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;将 HTML 和 JavaScript 解耦可以在调试过程中节省时间，更加容易确定错误的来源，也减轻维护的难度：更改行为只需要在 JavaScript 文件中进行，而更改标记则只要在渲染文件中&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;2.解耦CSS/JavaScript&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  另一个 Web 层则是 CSS，它主要负责页面的显示。JavaScript 和 CSS 也是非常紧密相关的：他们都是 HTML 之上的层次，因此常常一起使用。但是，和 HTML 与 JavaScript 的情况一样，CSS 和 JavaScript也可能会过于紧密地耦合在一起。最常见的紧密耦合的例子是使用 JavaScript 来更改某些样式，如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//CSS 对 JavaScript 的紧密耦合
element.style.color = &quot;red&quot;; 
element.style.backgroundColor = &quot;blue&quot;;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;遇到这种直接修改css样式的，我们直接可以通过修改元素标签class类名来控制样式更方便。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;3.解耦应用逻辑/事件处理程序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  每个 Web 应用一般都有相当多的事件处理程序，监听着无数不同的事件。然而，很少有能仔细得将应用逻辑从事件处理程序中分离的。请看以下例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function handleKeyPress(event) {
        event = EventUtil.getEvent(event);
        if (event.keyCode == 13) {
            var target = EventUtil.getTarget(event);
            var value = 5 * parseInt(target.value);
            if (value &amp;gt; 10) {
                document.getElementById(&quot;error-msg&quot;).style.display = &quot;block&quot;;
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  这个事件处理程序除了包含了应用逻辑，还进行了事件的处理。这种方式的问题有其双重性。首先，除了通过事件之外就再没有方法执行应用逻辑，这让调试变得困难。如果没有发生预想的结果怎么办？是不是表示事件处理程序没有被调用还是指应用逻辑失败？其次，如果一个后续的事件引发同样的应用逻辑，那就必须复制功能代码或者将代码抽取到一个单独的函数中。无论何种方式，都要作比实际所需更多的改动。&lt;/p&gt;
&lt;p&gt;  较好的方法是将应用逻辑和事件处理程序相分离，这样两者分别处理各自的东西。一个事件处理程序应该从事件对象中提取相关信息，并将这些信息传送到处理应用逻辑的某个方法中。例如，前面的代码可以被重写为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; function validateValue(value) {
        value = 5 * parseInt(value);
        if (value &amp;gt; 10) {
            document.getElementById(&quot;error-msg&quot;).style.display = &quot;block&quot;;
        }
    }

    function handleKeyPress(event) {
        event = EventUtil.getEvent(event);
        if (event.keyCode == 13) {
            var target = EventUtil.getTarget(event);
            validateValue(target.value);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;应用和业务逻辑之间松散耦合的几条原则：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;勿将 event 对象传给其他方法；只传来自 event 对象中所需的数据；&lt;/li&gt;
&lt;li&gt;任何可以在应用层面的动作都应该可以在不执行任何事件处理程序的情况下进行；&lt;/li&gt;
&lt;li&gt;任何事件处理程序都应该处理事件，然后将处理转交给应用逻辑。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;牢记这几条可以在任何代码中都获得极大的可维护性的改进，并且为进一步的测试和开发制造了很多可能。&lt;/p&gt;
&lt;h3 id=&quot;编程实践&quot;&gt;5、编程实践&lt;/h3&gt;
&lt;p&gt;  书写可维护的 JavaScript 并不仅仅是关于如何格式化代码；它还关系到代码做什么的问题。在企业环境中创建的 Web 应用往往同时由大量人员一同创作。这种情况下的目标是确保每个人所使用的浏览器环境都有一致和不变的规则。因此，最好坚持以下一些编程实践。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.尊重对象所有权&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  JavaScript 的动态性质使得几乎任何东西在任何时间都可以修改。也许在企业环境中最重要的编程实践就是尊重对象所有权，它的意思是你不能修改不属于你的对象。简单地说，如果你不负责创建或维护某个对象、它的对象或者它的方法，那么你就不能对它们进行修改。更具体地说：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;不要为实例或原型添加属性；&lt;/li&gt;
&lt;li&gt;不要为实例或原型添加方法；&lt;/li&gt;
&lt;li&gt;不要重定义已存在的方法。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;2.避免全局变量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  与尊重对象所有权密切相关的是尽可能避免全局变量和函数。这也关系到创建一个脚本执行的一致的和可维护的环境。最多创建一个全局变量，让其他对象和函数存在其中。请看以下例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 两个全局量——避免！！
var name = &quot;Nicholas&quot;; 
function sayName(){ 
 alert(name); 
} &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码包含了两个全局量：变量 name 和函数 sayName()。其实可以创建一个包含两者的对象，如下例所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 一个全局量——推荐
var MyApplication = { 
 name: &quot;Nicholas&quot;, 
 sayName: function(){ 
 alert(this.name); 
 } 
}; &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  这段重写的代码引入了一个单一的全局对象 MyApplication，name 和 sayName()都附加到其上。这样做消除了一些存在于前一段代码中的一些问题。首先，变量 name 覆盖了 window.name 属性，可能会与其他功能产生冲突；其次，它有助消除功能作用域之间的混淆。调用 MyApplication.sayName()在逻辑上暗示了代码的任何问题都可以通过检查定义 MyApplication 的代码来确定。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.使用常量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以下一些类型的值适合使用常量来定义：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;重复值——任何在多处用到的值都应抽取为一个常量。这就限制了当一个值变了而另一个没变的时候会造成的错误。这也包含了 CSS 类名。&lt;/li&gt;
&lt;li&gt;用户界面字符串 —— 任何用于显示给用户的字符串，都应被抽取出来以方便国际化。&lt;/li&gt;
&lt;li&gt;URLs ——在 Web 应用中，资源位置很容易变更，所以推荐用一个公共地方存放所有的URL。&lt;/li&gt;
&lt;li&gt;任意可能会更改的值 —— 每当你在用到字面量值的时候，你都要问一下自己这个值在未来是不是会变化。如果答案是“是”，那么这个值就应该被提取出来作为一个常量。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;以上是阅读js高程一些笔记同时也反思一下自己在平时项目开发中存在的问题看来提高一些基本编码小技巧编写出可维护的代码还是很有必要的&quot;&gt;以上是阅读《JS高程》一些笔记，同时也反思一下自己在平时项目开发中存在的问题。看来提高一些基本编码小技巧，编写出可维护的代码还是很有必要的。&lt;/h4&gt;
&lt;hr/&gt;&lt;p&gt;参考资料：&lt;br/&gt;《JavaScript高级教程》&lt;/p&gt;
</description>
<pubDate>Wed, 13 Nov 2019 00:12:00 +0000</pubDate>
<dc:creator>Peerless1029</dc:creator>
<og:description>1、前言 &amp;emsp;&amp;emsp;在平时工作开发中，大部分开发人员都花费大量的时间在维护其他人员的代码。很难从头开始开发新代码，很多情况下都是以他人成果为基础的，或者新增修改需求，自己写的代码也会被其</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/peerless1029/p/11846404.html</dc:identifier>
</item>
<item>
<title>java应用性能调优之详解System的gc垃圾回收方法 - 字母哥博客</title>
<link>http://www.cnblogs.com/zimug/p/11846543.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zimug/p/11846543.html</guid>
<description>&lt;h2 id=&quot;一什么是system.gc&quot;&gt;一、什么是System.gc()？&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;System.gc()&lt;/code&gt;是用Java，C＃和许多其他流行的高级编程语言提供的API。当它被调用时，它将尽最大努力从内存中清除垃圾（即未被引用的对象）。名词解释：GC，Garbage Collection，垃圾回收，下文会经常使用。&lt;/p&gt;
&lt;h2 id=&quot;二谁可以调用system.gc&quot;&gt;二、谁可以调用System.gc()？&lt;/h2&gt;
&lt;p&gt; &lt;code&gt;System.gc()&lt;/code&gt; 可以从应用程序堆栈的各个部分调用：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;您自己开发的应用程序可以显式的调用 &lt;code&gt;System.gc()&lt;/code&gt; 方法。&lt;/li&gt;
&lt;li&gt; &lt;code&gt;System.gc()&lt;/code&gt; 也可以由您的第三方库，框架触发。&lt;/li&gt;
&lt;li&gt;可以由外部工具（如VisualVM）通过使用JMX触发&lt;/li&gt;
&lt;li&gt;如果您的应用程序使用了RMI，RMI会定期调用 &lt;code&gt;System.gc()&lt;/code&gt; 。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;三调用system.gc有什么弊端&quot;&gt;三、调用System.gc()有什么弊端？&lt;/h2&gt;
&lt;p&gt;当 &lt;code&gt;System.gc()&lt;/code&gt; 或 &lt;code&gt;Runtime.getRuntime().gc()&lt;/code&gt;API被调用时，将触发完整的GC事件。在GC完成之前，整个JVM将冻结（即正在运行的所有服务将被暂停），通常完整的GC需要很长时间才能完成。因此在不合适的时间运行GC，将导致不良的用户体验，甚至是崩溃。&lt;br/&gt;JVM具有复杂的算法，该算法始终在后台运行，进行所有计算以及有关何时触发GC的计算。当您显式调用System.gc()调用时，所有这些计算都将被抛掉。&lt;/p&gt;
&lt;h2 id=&quot;四哪些场景适合显式调用system.gc&quot;&gt;四、哪些场景适合显式调用System.gc()？&lt;/h2&gt;
&lt;p&gt;GC操作应该由JVM自行控制，在绝大部分的场景都不建议程序员手动写代码显式进行System.gc()操作，但是也不排除其中个别例外：在我们开发多个微服务时，每个服务都有多个备份节点。在非业务高峰时段，我们可以从微服务-负载均衡的节点池中取出其中一个JVM实例。然后通过该JVM上的JMX显式触发System.gc()调用，一旦GC事件完成并且从内存中清除了垃圾，将该JVM放回到微服务-负载均衡的节点池中。&lt;br/&gt;当然这个过程需要很好的微服务管理及服务发布机制配合，这样既能保证JVM垃圾内存的有效清理，又不影响业务的正常运行。&lt;/p&gt;
&lt;h2 id=&quot;五如何检测您的应用程序正在进行system.gc&quot;&gt;五、如何检测您的应用程序正在进行System.gc()？&lt;/h2&gt;
&lt;p&gt;如第二小节所讲： &lt;code&gt;System.gc()&lt;/code&gt; 可以从多个渠道进行的调用，而不仅仅是从您的应用程序源代码进行的调用。因此，搜索您的应用程序代码&lt;code&gt;System.gc()&lt;/code&gt; 字符串，不足以知道 GC是否正在被调用。这就构成了一个挑战：如何检测应用程序是否正在进行垃圾回收？这就是GC日志派上用场的地方。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// java 8 启用GC日志：
// -XX:+PrintGCDetails -Xloggc:&amp;lt;gc-log-file-path&amp;gt; ,例如下面这行代码
-XX:+PrintGCDetails -Xloggc:/opt/tmp/myapp-gc.log

// java 9 启用GC日志：-Xlog:gc*:file=&amp;lt;gc-log-file-path&amp;gt; ,例如下面这行代码
-Xlog:gc*:file=/opt/tmp/myapp-gc.log&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;建议始终在所有生产服务器中始终启用GC日志，因为它有助于您排除故障并优化应用程序性能。启用GC日志只会增加微不足道的开销。还可以将您的GC日志上传到垃圾收集日志分析器工具，例如GCeasy，HP JMeter等。这些工具将生成丰富的垃圾收集分析报告。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1815316/201911/1815316-20191113074952735-1029597144.png&quot; alt=&quot;GCeasy.io工具报告的GC原因&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图摘自GCeasy生成的报告。&lt;/p&gt;
&lt;h2 id=&quot;六如何禁止gc显式调用或调整调用gc的频率&quot;&gt;六、如何禁止GC显式调用或调整调用GC的频率？&lt;/h2&gt;
&lt;p&gt;如果我们就是想避免程序员显式调用GC，避免不成熟的程序员在不合适时间调用GC，避免人为造成的GC崩溃，该怎么办？可以通过如下方法：&lt;/p&gt;
&lt;h3 id=&quot;搜索和替换&quot;&gt;搜索和替换&lt;/h3&gt;
&lt;p&gt;在代码库中搜索 &lt;code&gt;System.gc()&lt;/code&gt; 和&lt;code&gt;Runtime.getRuntime().gc()&lt;/code&gt;。如果看到匹配项，则将其删除。但是这种方法无法避免第三方库、框架或通过外部源进行调用，那么参考第二种方法。&lt;/p&gt;
&lt;h3 id=&quot;通过jvm参数强制禁止&quot;&gt;通过JVM参数强制禁止&lt;/h3&gt;
&lt;p&gt;通过传递JVM参数  &lt;code&gt;-XX:+DisableExplicitGC&lt;/code&gt;来强制禁止显式调用。这种方式强制、有效，应用程序内的任何GC显式代码调用&lt;code&gt;System.gc()&lt;/code&gt; 都将被禁止生效。JVM自身的GC策略不受此参数影响，只禁止人为的触发GC。&lt;/p&gt;
&lt;h3 id=&quot;rmi&quot;&gt;RMI&lt;/h3&gt;
&lt;p&gt;如果您的应用程序正在使用RMI，则可以控制GC调用的频率 。启动应用程序时，可以使用以下JVM参数配置该频率：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt; &lt;code&gt;-Dsun.rmi.dgc.server.gcInterval=n&lt;/code&gt;&lt;/li&gt;
&lt;li&gt; &lt;code&gt;-Dsun.rmi.dgc.client.gcInterval=n&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这些属性的默认值在&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;JDK 1.4.2和5.0是60000毫秒（即60秒）&lt;/li&gt;
&lt;li&gt;JDK 6和更高版本是3600000毫秒（即60分钟）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果您的应用主机内存资源非常富余，您可以将这些属性设置为很高的值，以便可以将GC带来的对应用程序的影响最小化。这也是应用程序性能优化的一种方式之一。&lt;/p&gt;
&lt;h2 id=&quot;期待您的关注&quot;&gt;期待您的关注&lt;/h2&gt;
</description>
<pubDate>Tue, 12 Nov 2019 23:50:00 +0000</pubDate>
<dc:creator>字母哥博客</dc:creator>
<og:description>一、什么是System.gc()？ 是用Java，C＃和许多其他流行的高级编程语言提供的API。当它被调用时，它将尽最大努力从内存中清除垃圾（即未被引用的对象）。名词解释：GC，Garbage Col</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zimug/p/11846543.html</dc:identifier>
</item>
<item>
<title>Nginx 的进程结构，你明白吗？ - 武培轩</title>
<link>http://www.cnblogs.com/wupeixuan/p/11846400.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wupeixuan/p/11846400.html</guid>
<description>&lt;p&gt;这篇文章我们来看下 Nginx 的进程结构，Nginx 其实有两种进程结构：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;单进程结构&lt;/li&gt;
&lt;li&gt;多进程结构&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;单进程结构实际上不适用于生产环境，只适合我们做开发调试使用。因为在生产环境中我们必须保持 Nginx 足够健壮以及 Nginx 可以利用多核的一个特性，而单进程的 Nginx 是做不到这一点的，所以默认的配置中都是打开为多进程的 Nginx。&lt;/p&gt;
&lt;p&gt;我们来看一下，多进程的 Nginx 结构中它的进程模型是怎样的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1356806/201911/1356806-20191113011956477-1734058505.png&quot; alt=&quot;Nginx进程结构&quot;/&gt;&lt;/p&gt;
&lt;p&gt;多进程中的 Nginx 进程架构如下图所示，会有一个父进程（Master Process），它会有很多子进程（Child Processes），这些子进程会分为两类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;worker 进程&lt;/li&gt;
&lt;li&gt;cache 相关的进程&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;为什么-nginx-采用多进程结构而不是多线程结构呢&quot;&gt;为什么 Nginx 采用多进程结构而不是多线程结构呢？&lt;/h2&gt;
&lt;p&gt;因为 Nginx 最核心的一个目的是要保持高可用性、高可靠性，而当 Nginx 如果使用的是多线程结构的时候，因为线程之间是共享同一个地址空间的，所以当某一个第三方模块引发了一个地址空间导致的段错误时、在地址越界出现时，会导致整个 Nginx 进程全部挂掉。而当采用多进程模型时，往往不会出现这样的问题。从上图可以看到 Nginx 在做进程设计时，同样遵循了实现高可用、高可靠这样的一个目的。&lt;/p&gt;
&lt;p&gt;比如说在 master 进程中，通常第三方模块是不会在 master 部分加入自己的功能代码的。虽然 Nginx 在设计时，允许第三方模块在 master 进程中添加自己独有的、自定义的一些方法，但是通常没有第三方模块这么做。&lt;/p&gt;
&lt;p&gt;master 进程被设计用来的目的是做 worker 进程的管理的，也就是所有的 worker 进程是处理真正的请求的，而 master 进程负责监控每个 worker 进程是不是在正常的工作、需不需要做重新载入配置文件、需不需要做热部署。&lt;/p&gt;
&lt;p&gt;而 cache （缓存）是在多个 worker 进程间共享的，而且缓存不仅要被 worker 进程使用，还要被 cache manager 和 cache loader进程 使用。cache manager 和 cache loader 也是为反向代理时，后端发来的动态请求做缓存所使用的，cache loader 只是用来做缓存的载入、cache manager 用来做缓存的管理。实际上每个请求处理时，使用到缓存还是由 worker 进程来进行的。&lt;/p&gt;
&lt;p&gt;这些进程间的通讯，都是使用共享内存来解决的。可以看到cache manager 和 cache loader各有一个进程，master 进程因为是父进程，所以肯定只有一个。那么 worker 进程为什么会有很多呢？这是因为 Nginx 采用了事件驱动引擎以后，他希望每一个 worker 进程从头到尾占有一颗CPU，所以往往不止要把 worker 进程的数量配置与我们服务器上的 CPU核数一致以外，还需要把每一个worker进程与某一颗CPU核绑定在一起，这样可以更好的使用每颗CPU核上面的CPU缓存来减少缓存失效的命中率。&lt;/p&gt;
&lt;p&gt;以上就是 Nginx 的进程结构的介绍，了解这些后更有助于我们去配置 Nginx。&lt;/p&gt;
&lt;p&gt;刚才我们介绍了 Nginx 使用了多进程模型，由 master 作为父进程启动许多子进程，也知道了 Nginx 父子进程之间是通过信号来管理的，接下来通过一个实例给大家直观的看下父子进程以及信号之间是如何工作的。&lt;/p&gt;
&lt;h2 id=&quot;nginx-的进程结构实例&quot;&gt;Nginx 的进程结构实例&lt;/h2&gt;
&lt;p&gt;首先启动 Nginx，并在 Nginx 中启动了两个 worker 进程，通过 ps 命令可以看到当前进程 PID 和父进程 PID，有一个 nginx master 进程是由 root 用户起的，进程 PID 是 2368。还有两个 worker 进程和 cache 进程，它们是由 2368 进程起来的。它们的进程 PID 分别为 8652，8653，8655。&lt;/p&gt;
&lt;p&gt;现在我们使用 &lt;code&gt;./sbin/nginx -s reload&lt;/code&gt; 命令，会把之前的 worker 进程和 cache 进程优雅的退出，然后再使用的新的配置项启动新的 worker 进程，这里我们并没有改变配置，但是我们可以看到老的三个子进程会退出，并生成新的子进程。&lt;/p&gt;
&lt;p&gt;可以看到，之前的三个子进程，现在已经都不在了，反而由 2368 新起了 8657，8658，8660 三个子进程。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@wupx nginx]# ps -ef|grep nginx
root      2368     1  0 Sep21 ?        00:00:00 nginx: master process /usr/sbin/nginx
root      4751  4688  0 11:41 pts/0    00:00:00 grep --color=auto nginx
nginx     8652  2368  0 Nov12 ?        00:00:00 nginx: worker process
nginx     8653  2368  0 Nov12 ?        00:00:00 nginx: worker process
nginx     8655  2368  0 Nov12 ?        00:00:00 nginx: cache manager process
[root@wupx nginx]# ./sbin/nginx -s reload
[root@wupx nginx]# ps -ef|grep nginx
root      2368     1  0 Sep21 ?        00:00:00 nginx: master process /usr/sbin/nginx
root      4753  4688  0 11:43 pts/0    00:00:00 grep --color=auto nginx
nginx     8657  2368  0 Nov12 ?        00:00:00 nginx: worker process
nginx     8658  2368  0 Nov12 ?        00:00:00 nginx: worker process
nginx     8660  2368  0 Nov12 ?        00:00:00 nginx: cache manager process&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行命令之后可以看到 worker 的 PID 已经变化了（之前讲过 &lt;code&gt;./sbin/nginx -s reload&lt;/code&gt; 跟 &lt;code&gt;kill -SIGHUP&lt;/code&gt; 作用是一样的。）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;kill -SIGTERM&lt;/code&gt; 是向现有的 worker 进程发送退出的信号，对应的 worker 进程就会退出；进程在退出时，会自动向父进程 master 发送一个退出信号，master 就知道他的子进程退出了，然后新起一个 worker 进程。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@wupx nginx]# ps -ef|grep nginx
root      2368     1  0 Sep21 ?        00:00:00 nginx: master process /usr/sbin/nginx
root      4753  4688  0 11:43 pts/0    00:00:00 grep --color=auto nginx
nginx     8657  2368  0 Nov12 ?        00:00:00 nginx: worker process
nginx     8658  2368  0 Nov12 ?        00:00:00 nginx: worker process
nginx     8660  2368  0 Nov12 ?        00:00:00 nginx: cache manager process
[root@wupx nginx]# kill -SIGTERM 8658
[root@wupx nginx]# ps -ef|grep nginx
root      2368     1  0 Sep21 ?        00:00:00 nginx: master process /usr/sbin/nginx
root      4753  4688  0 11:44 pts/0    00:00:00 grep --color=auto nginx
nginx     8657  2368  0 Nov12 ?        00:00:00 nginx: worker process
nginx     8660  2368  0 Nov12 ?        00:00:00 nginx: cache manager process
nginx     8663  2368  0 Nov12 ?        00:00:00 nginx: worker process&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过实例演示，我们可以看到 Nginx 的进程结构以及 Nginx 使用信号的方式，其实命令行中的许多子命令就是再向 master 进程发送信号而已。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1356806/201911/1356806-20191113011957119-106116467.png&quot; alt=&quot;进程模型&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 12 Nov 2019 17:20:00 +0000</pubDate>
<dc:creator>武培轩</dc:creator>
<og:description>Nginx 进程结构 这篇文章我们来看下 Nginx 的进程结构，Nginx 其实有两种进程结构： 单进程结构 多进程结构 单进程结构实际上不适用于生产环境，只适合我们做开发调试使用。因为在生产环境中</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wupeixuan/p/11846400.html</dc:identifier>
</item>
<item>
<title>用OpenGL画线 - 落单的毛毛虫</title>
<link>http://www.cnblogs.com/mmc1206x/p/11846238.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mmc1206x/p/11846238.html</guid>
<description>&lt;p&gt;．　两点之间的连线称之为线段，在屏幕上显示线段放在现在已经不是稀奇的事情，大多数高级图形ＡＰＩ都可以轻松实现，我尝试用ＯｐｅｎＧＬ画线，在这里记录一下收获．&lt;/p&gt;
&lt;p&gt;．　ＯｐｅｎＧＬ这个级别的图形ＡＰＩ，通常会提供一些绘制基本图形的接口，这些基本图形称之为&lt;strong&gt;图元&lt;/strong&gt;，而ＯｐｅｎＧＬ提供了点，线段，三角形三种图元绘制接口，说出来你可能不信，ＯｐｅｎＧＬ就只能绘制这三种图形，本篇博文的主题是画线，ＯｐｅｎＧＬ能直接绘制的图元之一．&lt;/p&gt;
&lt;hr/&gt;&lt;h4 id=&quot;用ｏｐｅｎｇｌ绘制线段图元&quot;&gt;用ＯｐｅｎＧＬ绘制线段图元&lt;/h4&gt;
&lt;p&gt;给出两点的坐标，调用ＡＰＩ即可直接画出线段．&lt;/p&gt;
&lt;pre class=&quot;c++&quot;&gt;
&lt;code&gt;//  伪代码
glVertex(x0, y0);           //  点A
glVertex(x1, y1);           //  点B
glDrawPrimitive(GL_LINES);  //  绘制线段图元&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果执行正确，你可以看到一条线段．&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/596122/201911/596122-20191112233910199-880734738.png&quot; alt=&quot;opengl_线段&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ＯｐｅｎＧＬ同时还提供调整线段宽度和颜色的接口．&lt;/p&gt;
&lt;pre class=&quot;c++&quot;&gt;
&lt;code&gt;//  伪代码
glLineWidth(width)          //  宽度
glLineColor(r, g, b, a)     //  颜色
glVertex(x0, y0);           //  点A
glVertex(x1, y1);           //  点B
glDrawPrimitive(GL_LINES);  //  绘制线段图元&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/596122/201911/596122-20191112233935039-531884465.png&quot; alt=&quot;opengl_线段粗&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果这篇博文有读者，如果恰好你就是这篇博文的读者，看到这里，你大概已经被ＯｐｅｎＧＬ的威力震慑住了，冷静一下，接着往下看．&lt;/p&gt;
&lt;p&gt;很多时候，我们想要绘制连续的线段，ＯｐｅｎＧＬ可以轻松搞定这个问题，你只需要重复上述代码就可以了．&lt;/p&gt;
&lt;pre class=&quot;c++&quot;&gt;
&lt;code&gt;//  伪代码
glLineWidth(width)          //  宽度
glLineColor(r, g, b, a)     //  颜色
glVertex(x0, y0);           //  第一条线段点A
glVertex(x1, y1);           //  第一条线段点B
glVertex(x2, y2);           //  第二条线段点A
glVertex(x3, y3);           //  第二条线段点B
glDrawPrimitive(GL_LINES);  //  绘制线段图元&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/596122/201911/596122-20191112233957971-1215781181.png&quot; alt=&quot;opengl_线段2&quot;/&gt;&lt;/p&gt;
&lt;p&gt;只需要短短几行代码，就可以画出两条线段，在惊叹之余，你可能没有发现，在两条线段交接处，很明显缺掉了一块，这是因为绘制的线段宽度是３像素，而且ＯｐｅｎＧＬ绘制的线段是直角，实际上上图是两个首尾相连的长方形，通过下面的图能清晰的看出问题所在．&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/596122/201911/596122-20191112234012842-505993222.png&quot; alt=&quot;opengl_线段22&quot;/&gt;&lt;/p&gt;
&lt;p&gt;很容易想象，线越宽，线段交接处的缺口越大，大多数人都接受不了这种缺陷，同时大多数人都认为它不是个问题，如果这篇博文有观众，且恰好就是你，你肯定有同感，但事实上，你猜的没错，因为ＯｐｅｎＧＬ在绘制线段图元的设计上就没考虑过这个问题，所以按上述思路去画线，这个问题无解，无解的问题就不是问题，所以这的确不是个问题．&lt;/p&gt;
&lt;hr/&gt;&lt;h4 id=&quot;用三角形图元来绘制线段&quot;&gt;用三角形图元来绘制线段&lt;/h4&gt;
&lt;p&gt;．　很多新人经常会被线段图元迷惑，误以为ＯｐｅｎＧＬ画线就的用它，实际上ＯｐｅｎＧＬ对线段图元提供的接口非常有限，即便如此，它还是有能发挥特长的使用场景，但本文所描述的场景它并不适合．&lt;/p&gt;
&lt;p&gt;．　要解决＂缺口＂的问题，得换一种思路，先生成线段的网格，再填充网格，这样灵活度就高多了．&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/596122/201911/596122-20191112234039243-156951881.png&quot; alt=&quot;线段_网格&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/596122/201911/596122-20191112234055046-551183348.png&quot; alt=&quot;线段_网格_填充&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图可以看出，线段的交接处看起来没有那么突兀了．&lt;/p&gt;
&lt;p&gt;此外，因为线段是用网格填充的，所以我们可以随心所欲的修改网格，以及通过可编程管线调整它．&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;基于上述内容画的一些线段&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;闪电&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/596122/201911/596122-20191112234108621-1006331447.png&quot; alt=&quot;闪电线段&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/596122/201911/596122-20191112234121061-1934685138.png&quot; alt=&quot;闪电&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/596122/201911/596122-20191112234140251-1752203018.gif&quot; alt=&quot;闪电&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;曲线&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/596122/201911/596122-20191112234159547-1969998426.png&quot; alt=&quot;曲线_网格&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/596122/201911/596122-20191112234213188-570204813.png&quot; alt=&quot;曲线&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/596122/201911/596122-20191112234225607-1860591771.gif&quot; alt=&quot;曲线&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 12 Nov 2019 15:43:00 +0000</pubDate>
<dc:creator>落单的毛毛虫</dc:creator>
<og:description>．　两点之间的连线称之为线段，在屏幕上显示线段放在现在已经不是稀奇的事情，大多数高级图形ＡＰＩ都可以轻松实现，我尝试用ＯｐｅｎＧＬ画线，在这里记录一下收获． ．　ＯｐｅｎＧＬ这个级别的图形ＡＰＩ，通常</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mmc1206x/p/11846238.html</dc:identifier>
</item>
<item>
<title>自己实现 aop 和 spring aop - sanri1993</title>
<link>http://www.cnblogs.com/sanri1993/p/11846216.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sanri1993/p/11846216.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/sanri1993/article/details/102964547&quot;&gt;上文&lt;/a&gt;说到，我们可以在 &lt;code&gt;BeanPostProcessor&lt;/code&gt; 中对 bean 的初始化前化做手脚，当时也说了，我完全可以生成一个代理类丢回去。&lt;/p&gt;
&lt;p&gt;代理类肯定要为用户做一些事情，不可能像学设计模式的时候创建个代理类，然后简单的在前面打印一句话，后面打印一句话，这叫啥事啊，难怪当时听不懂。最好是这个方法的前后过程可以自户自己定义。&lt;/p&gt;
&lt;p&gt;小明说，这还不好办，cglib 已经有现成的了，jdk 也可以实现动态代理，看 mybatis 其实也是这么干的，不然你想它一个接口怎么就能找到 xml 的实现呢，可以参照下 mybatis 的代码。&lt;/p&gt;
&lt;p&gt;所以首先学习下 cglib 和 jdk 的动态代理，我们来模拟下 mybatis 是如何通过接口来实现方法调用的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;cglib&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;目标接口：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface UserOperator {
    User queryUserByName(String name);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代理处理类：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import net.sf.cglib.proxy.MethodInterceptor;
import net.sf.cglib.proxy.MethodProxy;

public class ProxyHandle implements MethodInterceptor{
    // 实现 MethodInterceptor 的代理拦截接口
    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
        System.out.println(&quot;获取到 sqlId:&quot;+method);
        System.out.println(&quot;获取到执行参数列表：&quot;+args[0]);
        System.out.println(&quot;解析 spel 表达式，并获取到完整的 sql 语句&quot;);
        System.out.println(&quot;执行 sql &quot;);
        System.out.println(&quot;结果集处理，并返回绑定对象&quot;);
        return new User(&quot;sanri&quot;,1);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;真正调用处：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Enhancer enhancer = new Enhancer();

enhancer.setSuperclass(UserOperator.class);
enhancer.setCallback(new ProxyHandle());

//可以把这个类添加进 ioc 容器，这就是真正的代理类
UserOperator userOperator = (UserOperator) enhancer.create();

User sanri = userOperator.queryByName(&quot;sanri&quot;);
System.out.println(sanri);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;jdk&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import java.lang.reflect.InvocationHandler;
public class ProxyHandler implements InvocationHandler {
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println(&quot;获取到 sqlId:&quot;+method);
        System.out.println(&quot;获取到执行参数列表：&quot;+args[0]);
        System.out.println(&quot;解析 spel 表达式，并获取到完整的 sql 语句&quot;);
        System.out.println(&quot;执行 sql &quot;);
        System.out.println(&quot;结果集处理，并返回绑定对象&quot;);
        return new User(&quot;sanri&quot;,1);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;真正调用处：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;UserOperator proxyInstance = (UserOperator)Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), new Class[]{UserOperator.class}, new ProxyHandler());
User sanri = proxyInstance.queryByName(&quot;sanri&quot;);
System.out.println(sanri);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注：jdk 只能支持代理接口，但 cglib 是接口和实体类都可以代理； jdk 是使用实现接口方式，可以多实现，但 cglib 是继承方式，也支持接口方式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代理模式和装饰模式的区别：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从这也可以看到代理模式和装饰模式的区别 ，代理模式的方法签名一般是不动的，但装饰模式是为了方法的增强，一般会使用别的更好的方法来代替原方法。&lt;/p&gt;
&lt;h3 id=&quot;如何织入&quot;&gt;如何织入&lt;/h3&gt;
&lt;p&gt;回到正文，这时我们已经可以创建一个代理类了，如何把用户行为给弄进来呢，哎，又只能 &lt;strong&gt;回调&lt;/strong&gt; 了，我们把现场信息给用户，用户实现我的接口，然后我找到接口的所有实现类进行顺序调用，但这时候小明想到了几个问题&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;用户不一定每个方法都要做代理逻辑，可能只是部分方法需要，我们应该能够识别出是哪些方法需要做代理逻辑 (Pointcut)&lt;/li&gt;
&lt;li&gt;方法加代理逻辑的位置，方法执行前(Before)，方法执行后(After)，方法返回数据后(AfterReturning)，方法出异常后(AfterThrowing)，自定义执行(Around)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;根据单一职责原则，得写五个接口，每个接口要包含 getPointCut() 方法和 handler() 方法，或者绕过单一职责原则，在一个接口中定义 6 个方法，用户不想实现留空即可。总得来说，用户只需要提交一份规则给我就行，这个规则你不管是用 json，xml ，或者 注解的方式，只要我能够识别在 这个 pointcut 下，需要有哪些自定义行为，在另一个 pointcut 下又有哪些自定义行为即可。&lt;/p&gt;
&lt;p&gt;现拿到用户行为了和切点了，还需要创建目标类的代理类，并把行为给绑定上去，在什么时候创建代理类呢，肯定在把 bean 交给容器的时候悄悄的换掉啊，&lt;a href=&quot;https://blog.csdn.net/sanri1993/article/details/102964547&quot;&gt;上文&lt;/a&gt; 说到 bean 有一个生命周期是用于做所有 bean 拦截的，并且可以在初始化前和初始化后进行拦截，没错，就是 &lt;code&gt;BeanPostProcessor&lt;/code&gt; 我们可以在初始化后生成代理类。&lt;/p&gt;
&lt;p&gt;这里需要注意，并不是所有类都需要创建代理。我们可以这样检测，让 pointcut 提供一个方法用于匹配当前方法是否需要代理，当然这也是 pointcut 的职责，如果当前类有一个方法需要代理，那么当前类是需要代理的，否则认为不需要代理，这么做需要遍历所有类的所有方法，如果运气差的话，看上去很耗费性能 ，但 spring 也是这么干的。。。。。。优化的方案可以这么玩，如果方法需要代理，在类上做一个标识，如果类上存在这个标识，则可以直接创建代理类。&lt;/p&gt;
&lt;p&gt;现在我们把用户行为绑定到代理类，根据上面 jdk 动态代理和 cglib 动态代理的学习，我们发现，它们都有一个共同的家伙，那就是方法拦截，用于拦截目标类的当前正在执行的方法，并增强其功能，我们可以在创建代理类的时候找到所有的用户行为并按照顺序和类型依次绑定，可以用责任链模式。&lt;/p&gt;
&lt;h3 id=&quot;看一下-spring-是怎么玩的&quot;&gt;看一下 spring 是怎么玩的&lt;/h3&gt;
&lt;p&gt;spring 也是在 &lt;code&gt;BeanPostProcessor&lt;/code&gt; 接口的 &lt;code&gt;postProcessAfterInitialization&lt;/code&gt; 生命周期进行拦截&lt;/p&gt;
&lt;p&gt;spring 配置切面有两种方式，使用注解和使用配置，当然，现在流行注解的方式，更方便，但不管是配置还是注解，最后都会被解析成 Advisor(&lt;code&gt;InstantiationModelAwarePointcutAdvisorImpl&lt;/code&gt;)&lt;/p&gt;
&lt;p&gt;紧接着，spring 会使使用 Advisor 中的 pointcut 来看当前类是否需要创建代理类，跟进方法可以看到 canApply 方法中是遍历了所有方法一个个匹配来看是否需要创建代理类的，如果有一个需要，则直接返回 true 。当然 spring 更严谨一些，它考虑到了可能有接口的方法需要有代理，我上面说在类加标识是不正确的。&lt;/p&gt;
&lt;p&gt;然后通过 createProxy 创建了代理类，里面有区分 cglib 还是 aop ，下面单拿 cglib 来说&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;CglibAopProxy.getProxy&lt;/code&gt; 中对类进行增强，主要看 &lt;code&gt;Enhancer&lt;/code&gt; 类是如何设置的就好了，有一个 callback 参数 ，我们一般是第 0 个 callback 也即 &lt;code&gt;DynamicAdvisedInterceptor&lt;/code&gt; 它是一个 cglib 的 MethodInterceptor&lt;/p&gt;
&lt;p&gt;它重写的是 MethodInterceptor 的 intercept 方法，下面看这个方法，&lt;code&gt;this.advised&lt;/code&gt; 是前面传过来的用户行为，&lt;code&gt;getInterceptorsAndDynamicInterceptionAdvice&lt;/code&gt; 通过适配器模式把 &lt;code&gt;Advisor&lt;/code&gt; 适配成了 &lt;code&gt;AbstractAspectJAdvice&lt;/code&gt; 它的五个实现类如下 ，分别对应切面的五种行为&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;AbstractAspectJAdvice
  |- AspectJAfterReturningAdvice
  |- AspectJAfterAdvice implements org.aopalliance.intercept.MethodInterceptor
  |- AspectJAroundAdvice implements org.aopalliance.intercept.MethodInterceptor
  |- AspectJAfterThrowingAdvice implements org.aopalliance.intercept.MethodInterceptor
  |- AspectJMethodBeforeAdvice&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后它封装一个执行器，根据顺序调用拦截器链，也即用户行为列表，封装执行的时候是强转 &lt;code&gt;org.aopalliance.intercept.MethodInterceptor&lt;/code&gt; 来执行的，但 &lt;code&gt;AspectJAfterReturningAdvice&lt;/code&gt; 和 &lt;code&gt;AspectJMethodBeforeAdvice&lt;/code&gt; 没有实现 &lt;code&gt;org.aopalliance.intercept.MethodInterceptor&lt;/code&gt; 怎么办，所以 spring 在获取用户行为链的时候增加了一个适配器，专门用于把这两种转换成 &lt;code&gt;MethodInterceptor&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;其它说明&quot;&gt;其它说明&lt;/h3&gt;
&lt;p&gt;cglib 的 callback 只能写一个，filter 用于选择是第几个 callback ，不要让为也是链式的&lt;/p&gt;
&lt;p&gt;spring aop 中有比较多的设计模式，学设计模式的可以看下这块的源码 ，至少责任链，适配器，动态代理都可以在这看到&lt;/p&gt;
&lt;h2 id=&quot;一点小推广&quot;&gt;一点小推广&lt;/h2&gt;
&lt;p&gt;创作不易，希望可以支持下我的开源软件，及我的小工具，欢迎来 gitee 点星，fork ，提 bug 。&lt;/p&gt;
&lt;p&gt;Excel 通用导入导出，支持 Excel 公式&lt;br/&gt;博客地址：&lt;a href=&quot;https://blog.csdn.net/sanri1993/article/details/100601578&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/sanri1993/article/details/100601578&lt;/a&gt;&lt;br/&gt;gitee：&lt;a href=&quot;https://gitee.com/sanri/sanri-excel-poi&quot; class=&quot;uri&quot;&gt;https://gitee.com/sanri/sanri-excel-poi&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用模板代码 ，从数据库生成代码 ，及一些项目中经常可以用到的小工具&lt;br/&gt;博客地址：&lt;a href=&quot;https://blog.csdn.net/sanri1993/article/details/98664034&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/sanri1993/article/details/98664034&lt;/a&gt;&lt;br/&gt;gitee：&lt;a href=&quot;https://gitee.com/sanri/sanri-tools-maven&quot; class=&quot;uri&quot;&gt;https://gitee.com/sanri/sanri-tools-maven&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 12 Nov 2019 15:36:00 +0000</pubDate>
<dc:creator>sanri1993</dc:creator>
<og:description>'上文 ' 说到，我们可以在 中对 bean 的初始化前化做手脚，当时也说了，我完全可以生成一个代理类丢回去。 代理类肯定要为用户做一些事情，不可能像学设计模式的时候创建个代理类，然后简单的在前面打印</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sanri1993/p/11846216.html</dc:identifier>
</item>
<item>
<title>吐血推荐珍藏的Visual Studio Code插件 - Jackeyzhe</title>
<link>http://www.cnblogs.com/Jackeyzhe/p/11846204.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Jackeyzhe/p/11846204.html</guid>
<description>&lt;p&gt;作为一名Java工程师，由于工作需要，最近一个月一直在写NodeJS，这种经历可以说是一部辛酸史了。好在有神器Visual Studio Code陪伴，让我的这段经历没有更加困难。眼看这段经历要告一段落了，今天就来给大家分享一下我常用的一些VSC的插件。&lt;/p&gt;
&lt;p&gt;VSC的插件安装方法很简单，只需要点击左侧最下方的插件栏选项，然后就可以搜索你想要的插件了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dxydgihag/image/upload/v1573309990/Blog/js/vsc/vs3.gif&quot; alt=&quot;extends install&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面我们进入正题&lt;/p&gt;
&lt;h3 id=&quot;material-theme&quot;&gt;Material Theme&lt;/h3&gt;
&lt;p&gt;第一个是Material Theme，这个插件可以帮助我们修改主题色，帮助你摆脱只有黑色和白色的世界。当然你也可以通过修改setting文件来自定义主题颜色。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dxydgihag/image/upload/v1573310011/Blog/js/vsc/vs4.jpg&quot; alt=&quot;Material Theme&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;auto-import&quot;&gt;Auto Import&lt;/h3&gt;
&lt;p&gt;在写Java时，通常我是直接在代码中写出类名，然后使用IDEA自动导入相应的包的，但是使用VSC时没有这个功能，这个问题就让我很困扰，这意味着作为高级crtlCV工程师，粘贴过来的代码无法直接使用，你还要去查一些引用是属于哪个包的，怎么导入。&lt;/p&gt;
&lt;p&gt;而Auto Import帮我解决了这个大问题，它可以自动识别，解析和增加一些对应的包。有了它，我就可以继续做ctrlCV工程师了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dxydgihag/image/upload/v1573310651/Blog/js/vsc/vs5.gif&quot; alt=&quot;Auto Import&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;import-cost&quot;&gt;Import Cost&lt;/h3&gt;
&lt;p&gt;写过NodeJS的同学可能都会有一个体会，自己可能只写了几行代码，但是要安装的包竟然达到几个G，可能有些夸张，但是大量的node_modules真的很令人崩溃。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dxydgihag/image/upload/v1573311007/Blog/js/vsc/nj.jpg&quot; alt=&quot;node_modules&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这时你需要的是Import Cost来帮你控制一下你导入包的大小。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dxydgihag/image/upload/v1573311163/Blog/js/vsc/vs6.gif&quot; alt=&quot;Import Cost&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当你写了一个导入语句时，它会提醒你这个包的大小，如果你发现某个包太大时，就需要考虑一下你是否真的需要引入整个包了。&lt;/p&gt;
&lt;h3 id=&quot;indent-rainbow&quot;&gt;Indent-Rainbow&lt;/h3&gt;
&lt;p&gt;这个插件是帮助你提升读代码的体验的，对于刚开始接触NodeJS的同学来说，读代码的时间往往比写代码的时间要多。如果项目过大时，新同学往往会迷失在很多的代码块中，分辨代码块只能靠行前缩紧数量。但是有时缩紧数量又无法一眼看出。而Indent-Rainbow就是用来帮你快速分辨代码的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dxydgihag/image/upload/v1573312918/Blog/js/vsc/vs7.png&quot; alt=&quot;Indent-Rainbow&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;prettier-code-formatter&quot;&gt;Prettier — Code Formatter&lt;/h3&gt;
&lt;p&gt;Prettier插件是用来格式化代码的。&lt;/p&gt;
&lt;p&gt;符合代码规范的代码可以说是一个工程师的脸面，而Prettier可以说是专门帮你维护脸面的插件。有了它，你在写代码时就可以肆无忌惮了，只需要在写完以后按一下对应的快捷键。你的代码就会马上变漂亮。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dxydgihag/image/upload/v1573313646/Blog/js/vsc/vs10.png&quot; alt=&quot;Prettier&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;sublime-text-keymap-and-settings-importer&quot;&gt;Sublime Text Keymap and Settings Importer&lt;/h3&gt;
&lt;p&gt;不知道有多少同学和我一样比较喜欢用Sublime Text。虽然ST3也非常强大，可以用来写JS代码，但是我觉得它还是比不上专业的IDE，所以我更喜欢把ST3当作「记事本」来用，如果你已经比较习惯了ST3的快捷键，并且不想因为使用VSC而改变这个习惯，那么就可以使用这个插件，它会在VSC中模仿ST3的快捷键设置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dxydgihag/image/upload/v1573314683/Blog/js/vsc/vs12.png&quot; alt=&quot;ST3&quot;/&gt;&lt;/p&gt;
&lt;p&gt;你可以使用command+P来唤起命令窗口，然后输入&lt;code&gt;&amp;gt;&lt;/code&gt;开始像在ST3中那样操作。&lt;/p&gt;
&lt;h3 id=&quot;npm-intellisense&quot;&gt;npm Intellisense&lt;/h3&gt;
&lt;p&gt;npm Intellisense插件可以帮助你将你想要的node modules补充完整。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dxydgihag/image/upload/v1573315069/Blog/js/vsc/vs14.gif&quot; alt=&quot;npm Intellisense&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;file-utils&quot;&gt;File Utils&lt;/h3&gt;
&lt;p&gt;File Utils在我看来是一个非常方（zhuang）便（bi）的插件，它可以帮助你不使用鼠标就可以创建、移动、删除文件。看起来是不是很酷。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dxydgihag/image/upload/v1573315346/Blog/js/vsc/vs19.gif&quot; alt=&quot;File Utils&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;bracket-pair-colorizer&quot;&gt;Bracket Pair Colorizer&lt;/h3&gt;
&lt;p&gt;前面我们提到了缩紧的识别，这里还有一个括号颜色标识的插件。它可以把括号标为不同的颜色，方便识别括号匹配。这种插件我在IDEA中也会用，可以极大的提高读代码的效率。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dxydgihag/image/upload/v1573315991/Blog/js/vsc/vs20.png&quot; alt=&quot;Bracket Pair Colorizer&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;trailing-spaces&quot;&gt;Trailing Spaces&lt;/h3&gt;
&lt;p&gt;这个插件会帮我们标出一些无用的尾部空格，如果发现，请立即删除它们。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dxydgihag/image/upload/v1573316228/Blog/js/vsc/vs25.png&quot; alt=&quot;Trailing Spaces&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;wakatime&quot;&gt;WakaTime&lt;/h3&gt;
&lt;p&gt;这个插件很有意思，它会统计你编码的一些数据，例如各种语言的占比，日平均编码时间等。你可以用它来统计一下你每天大概的有效工作时间是多少，如果数据比较漂亮，可以不经意间让领导看到一下，哈哈哈。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dxydgihag/image/upload/v1573316810/Blog/js/vsc/vs27.png&quot; alt=&quot;WakaTime&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;vscode-icons&quot;&gt;Vscode-icons&lt;/h3&gt;
&lt;p&gt;你是否对VSC的默认icon感到厌烦呢？你想直接通过图标看出某个文件的文件格式吗？Vscode-icons插件来帮你实现。&lt;/p&gt;
&lt;p&gt;它会让文件的icon更加友好，也可以下载一些你喜欢的icon。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dxydgihag/image/upload/v1573317020/Blog/js/vsc/vs32.gif&quot; alt=&quot;Vscode-icons&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上就是我常用的一些VSCode的插件。喜欢的同学可以直接去市场下载体验。这些插件可能大部分都是用于提升读代码，因为我最近也是读代码比较多。如果其他同学有好用的插件也可以分享出来。&lt;/p&gt;
&lt;p&gt;后面我也会考虑分享一些IDEA的插件，做Java的同学可以期待一波。&lt;/p&gt;
</description>
<pubDate>Tue, 12 Nov 2019 15:32:00 +0000</pubDate>
<dc:creator>Jackeyzhe</dc:creator>
<og:description>作为一名Java工程师，由于工作需要，最近一个月一直在写NodeJS，这种经历可以说是一部辛酸史了。好在有神器Visual Studio Code陪伴，让我的这段经历没有更加困难。眼看这段经历要告一段</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Jackeyzhe/p/11846204.html</dc:identifier>
</item>
<item>
<title>曹工杂谈：为什么很少需要改Spring源码，因为扩展点太多了，说说Spring的后置处理器 - 三国梦回</title>
<link>http://www.cnblogs.com/grey-wolf/p/11830319.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/grey-wolf/p/11830319.html</guid>
<description>&lt;p&gt;最近发了好几篇，都是覆盖框架源码，但是spring的代码，我是从没覆盖过，毕竟，如果方便扩展，没谁想去改源码，而spring就是不需要改源码的那个，真的是“对扩展开放，对修改关闭”的典范。&lt;/p&gt;
&lt;p&gt;就我说曾经用过的，spring的扩展点，就包括了&lt;code&gt;listener&lt;/code&gt;、&lt;code&gt;beanFactoryPostProcessor&lt;/code&gt;、&lt;code&gt;beanPostProcessor&lt;/code&gt;，而spring boot的扩展点，除了&lt;code&gt;properties&lt;/code&gt;、&lt;code&gt;yml&lt;/code&gt;、&lt;code&gt;java config&lt;/code&gt;覆盖自动配置、&lt;code&gt;org.springframework.boot.CommandLineRunner&lt;/code&gt;，还包括了&lt;code&gt;META-INF&lt;/code&gt;下的&lt;code&gt;spring.factory&lt;/code&gt;等。&lt;/p&gt;
&lt;p&gt;眼下就有以前的一个例子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/519126/201911/519126-20191112231047412-1924130100.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这次，只简单说说后置处理器，主要是&lt;code&gt;beanFactoryPostProcessor&lt;/code&gt;、&lt;code&gt;beanPostProcessor&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;这两个比较像，都是后置处理器，但是处理的对象不同，前者是针对beanFactory，后者是针对bean实例。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;beanFactoryPostProcessor&lt;/code&gt;的注释如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Allows for custom modification of an application context's bean definitions, adapting the bean property values of the context's underlying bean factory.
Application contexts can auto-detect BeanFactoryPostProcessor beans in their bean definitions and apply them before any other beans get created.

Useful for custom config files targeted at system administrators that override bean properties configured in the application context.

See PropertyResourceConfigurer and its concrete implementations for out-of-the-box solutions that address such configuration needs.

A BeanFactoryPostProcessor may interact with and modify bean definitions, but never bean instances. Doing so may cause premature bean instantiation, violating the container and causing unintended side-effects. If bean instance interaction is required, consider implementing BeanPostProcessor instead.

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;简单来说，允许对&lt;code&gt;bean definition&lt;/code&gt;进行修改。&lt;/p&gt;
&lt;h2 id=&quot;bean-definition定义&quot;&gt;bean definition定义&lt;/h2&gt;
&lt;p&gt;所谓的&lt;code&gt;bean definition&lt;/code&gt;呢，就是bean的元数据，比如bean的name、scope、class、是否延迟初始化(is-lazy-init)、依赖的bean等等。&lt;/p&gt;
&lt;h2 id=&quot;负责维护bean-definition-的注册表&quot;&gt;负责维护bean definition 的注册表&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;bean definition&lt;/code&gt;放在哪里呢，就在&lt;code&gt;org.springframework.beans.factory.support.BeanDefinitionRegistry&lt;/code&gt;里，看名字可以知道，这是一个注册表，具体存储来说，一般会选择我们熟悉的&lt;code&gt;hashmap&lt;/code&gt;，key是&lt;code&gt;beanDefinition&lt;/code&gt;的类名，value就是&lt;code&gt;beanDefinition&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;当然，这只是个接口，其提供了增删改查的方法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface BeanDefinitionRegistry extends AliasRegistry {
    //注册bean Definition
    void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)
            throws BeanDefinitionStoreException;
    //删除bean Definition
    void removeBeanDefinition(String beanName) throws NoSuchBeanDefinitionException;
    //获取beanDefinition
    BeanDefinition getBeanDefinition(String beanName) throws NoSuchBeanDefinitionException;
    //判断是否包含指定的bean Definition
    boolean containsBeanDefinition(String beanName);
    //获取所有的beanDefinition的名称
    String[] getBeanDefinitionNames();
    //获取beanDefinition的数量
    int getBeanDefinitionCount();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那我们再看看这个接口的实现：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/519126/201911/519126-20191110123930238-346082445.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里面可以看出来，&lt;code&gt;ApplicationContext&lt;/code&gt;就是这个接口的实现，这里可以稍微看下&lt;code&gt;registerBean&lt;/code&gt;的实现：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;org.springframework.context.support.GenericApplicationContext#registerBeanDefinition
@Override
public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition) {
    //代理给beanFactory
    this.beanFactory.registerBeanDefinition(beanName, beanDefinition);
}
这里的beanFactory类型为：org.springframework.beans.factory.support.DefaultListableBeanFactory
    @Override
    public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition){

        BeanDefinition existingDefinition = this.beanDefinitionMap.get(beanName);
        if (existingDefinition != null) {
            //...省略无关代码
            //往hashmap里存放beanName--》beanDefinition
            this.beanDefinitionMap.put(beanName, beanDefinition);
        }
        //...省略无关代码
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;beanfactorypostprocessor的实现类&quot;&gt;beanFactoryPostProcessor`的实现类&lt;/h2&gt;
&lt;p&gt;经过上面的介绍，想来大家比较了解&lt;code&gt;beanFactoryPostProcessor&lt;/code&gt;了，我们看看这个接口的实现类呢：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/519126/201911/519126-20191110134816779-1337074293.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;拿以上实现类来说，&lt;/p&gt;
&lt;p&gt;&lt;code&gt;org.springframework.boot.web.servlet.ServletComponentRegisteringPostProcessor&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;这个是处理&lt;code&gt;ServletComponentScan&lt;/code&gt;注解，将&lt;code&gt;@WebServlet&lt;/code&gt;,&lt;code&gt;@WebFilter&lt;/code&gt;等注解的servlet组件，注册到&lt;code&gt;applicationContext&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;默认情况下，spring boot web应用，会有如下这个实现类：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;org.springframework.context.annotation.ConfigurationClassPostProcessor&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;主要就是用于处理&lt;code&gt;@Configuration&lt;/code&gt;注解的java类。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;org.springframework.context.annotation.ConfigurationClassPostProcessor#postProcessBeanFactory
    /**
     * Prepare the Configuration classes for servicing bean requests at runtime
     * by replacing them with CGLIB-enhanced subclasses.
     */
    @Override
    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {
        int factoryId = System.identityHashCode(beanFactory);
        this.factoriesPostProcessed.add(factoryId);
        if (!this.registriesPostProcessed.contains(factoryId)) {
            // BeanDefinitionRegistryPostProcessor hook apparently not supported...
            // Simply call processConfigurationClasses lazily at this point then.
            processConfigBeanDefinitions((BeanDefinitionRegistry) beanFactory);
        }
        //对configuration注解的类进行cglib代理，保证@bean注解的方法，即使多次调用，也只会有一个实例
        enhanceConfigurationClasses(beanFactory);
        //新增一个bean后置处理器
        beanFactory.addBeanPostProcessor(new ImportAwareBeanPostProcessor(beanFactory));
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;自定义beanfactorypostprocessor并使之生效&quot;&gt;自定义beanFactoryPostProcessor，并使之生效&lt;/h2&gt;
&lt;p&gt;很简单，像下面这样，定义一个类，实现&lt;code&gt;BeanFactoryPostProcessor&lt;/code&gt;，并保证被扫描到即可。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Component
@Slf4j
public class CustomBeanDefinitionPostProcessor implements BeanFactoryPostProcessor{

    @Override
    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
        BeanDefinition definition = beanFactory.getBeanDefinition(&quot;customBeanDefinitionPostProcessor&quot;);
        log.info(&quot;definition:{}&quot;,definition);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动时，输出如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;11-12 15:49:48.627 [restartedMain] INFO  c.c.cad.config.CustomBeanDefinitionPostProcessor
                    - definition:Generic bean: class [com.ceiec.cad.config.CustomBeanDefinitionPostProcessor]; scope=singleton; abstract=false; lazyInit=false; autowireMode=0; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=null; factoryMethodName=null; initMethodName=null; destroyMethodName=null; defined in file [F:\working_code\****\CustomBeanDefinitionPostProcessor.class] [CustomBeanDefinitionPostProcessor.java:20]
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;接口定义&quot;&gt;接口定义&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Factory hook that allows for custom modification of new bean instances, e.g. checking for marker interfaces or wrapping them with proxies.
ApplicationContexts can autodetect BeanPostProcessor beans in their bean definitions and apply them to any beans subsequently created. Plain bean factories allow for programmatic registration of post-processors, applying to all beans created through this factory.

Typically, post-processors that populate beans via marker interfaces or the like will implement postProcessBeforeInitialization(java.lang.Object, java.lang.String), while post-processors that wrap beans with proxies will normally implement postProcessAfterInitialization(java.lang.Object, java.lang.String).
//对bean的实例进行修改，或者用一个代理来包装它们，这个和上面的重要差别就出来了，一个是在bean还没实例化之前，处理beanFactory里的bean definition；一个是处理实例化后的bean。
public interface BeanPostProcessor {
    default Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        return bean;
    }

    @Nullable
    default Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        return bean;
    }

}   &lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;接口的实现类&quot;&gt;接口的实现类&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/519126/201911/519126-20191110144632266-124966052.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上有大家熟悉的，比如 &lt;code&gt;ApplicationContextAwareProcessor&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    org.springframework.context.support.ApplicationContextAwareProcessor#invokeAwareInterfaces
    private void invokeAwareInterfaces(Object bean) {
        if (bean instanceof Aware) {
            //....省略无关
            if (bean instanceof ApplicationContextAware) {
                ((ApplicationContextAware) bean).setApplicationContext(this.applicationContext);
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;aop代理的实现&quot;&gt;aop代理的实现&lt;/h3&gt;
&lt;p&gt;另一个广泛应用的，就是aop用到的&lt;code&gt;org.springframework.aop.framework.AbstractAdvisingBeanPostProcessor&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;AbstractAdvisingBeanPostProcessor#postProcessAfterInitialization
public Object postProcessAfterInitialization(Object bean, String beanName) {
        if (this.advisor == null || bean instanceof AopInfrastructureBean) {
            // Ignore AOP infrastructure such as scoped proxies.
            return bean;
        }

        if (bean instanceof Advised) {
            Advised advised = (Advised) bean;
            if (!advised.isFrozen() &amp;amp;&amp;amp; isEligible(AopUtils.getTargetClass(bean))) {
                // Add our local Advisor to the existing proxy's Advisor chain...
                if (this.beforeExistingAdvisors) {
                    advised.addAdvisor(0, this.advisor);
                }
                else {
                    advised.addAdvisor(this.advisor);
                }
                return bean;
            }
        }

        if (isEligible(bean, beanName)) {
            ProxyFactory proxyFactory = prepareProxyFactory(bean, beanName);
            //是否对目标类进行代理（cglib），如果不是的话，则获取bean的接口，进行接口代理，即jdk代理
            if (!proxyFactory.isProxyTargetClass()) {
                evaluateProxyInterfaces(bean.getClass(), proxyFactory);
            }
            proxyFactory.addAdvisor(this.advisor);
            customizeProxyFactory(proxyFactory);
            return proxyFactory.getProxy(getProxyClassLoader());
        }

        // No proxy needed.
        return bean;
    }
    protected ProxyFactory prepareProxyFactory(Object bean, String beanName) {
        ProxyFactory proxyFactory = new ProxyFactory();
        proxyFactory.copyFrom(this);
        proxyFactory.setTarget(bean);
        return proxyFactory;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;自定义beanpostprocessor并生效&quot;&gt;自定义beanPostProcessor，并生效&lt;/h2&gt;
&lt;p&gt;很简单，直接在你的代码里，像下面这样写一个类，实现&lt;code&gt;BeanPostProcessor&lt;/code&gt;，并保证被扫描到即可。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Component
@Slf4j
public class CustomBeanPostProcessor implements BeanPostProcessor{

    @Nullable
    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        if (bean instanceof RabbitTemplate) {
            log.info(&quot;hahah RabbitTemplate&quot;);
        }
        return bean;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面是我这边运行的效果：&lt;img src=&quot;https://img2018.cnblogs.com/blog/519126/201911/519126-20191112222845976-1738446336.png&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;相同点&quot;&gt;相同点&lt;/h2&gt;
&lt;h3 id=&quot;操作对象不同&quot;&gt;1、操作对象不同&lt;/h3&gt;
&lt;p&gt;前面也说了，beanFactoryPostProcessor对bean的图纸进行修改，beanPostProcessor则是对生产出来的东西，进行修改或者替换（为什么说替换，因为也可能照着生产出来的产品，搞一个代理，比如aop就是基于此实现。）&lt;/p&gt;
&lt;h3 id=&quot;生效时机不同&quot;&gt;2、生效时机不同&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/519126/201911/519126-20191112225541004-921735033.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;相同点-1&quot;&gt;相同点&lt;/h2&gt;
&lt;p&gt;相同点呢，就是，这都是spring给我们提供出来的扩展点，相当方便，不是吗？&lt;/p&gt;
</description>
<pubDate>Tue, 12 Nov 2019 15:18:00 +0000</pubDate>
<dc:creator>三国梦回</dc:creator>
<og:description>前言 最近发了好几篇，都是覆盖框架源码，但是spring的代码，我是从没覆盖过，毕竟，如果方便扩展，没谁想去改源码，而spring就是不需要改源码的那个，真的是“对扩展开放，对修改关闭”的典范。 就我</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/grey-wolf/p/11830319.html</dc:identifier>
</item>
<item>
<title>python机器学习——自适应线性神经元 - Xlgd</title>
<link>http://www.cnblogs.com/Dzha/p/11846125.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Dzha/p/11846125.html</guid>
<description>&lt;p&gt;上篇博客我们说了感知器，这篇博客主要记录自适应线性神经元的实现算法及一些其他的训练细节，自适应线性神经元（简称为Adaline）由Bernard Widrow和他的博士生Tedd Hoff提出，对感知器算法进行了改进。&lt;/p&gt;
&lt;p&gt;当然Adaline对输入向量x的处理和感知器是一样的，都是使用一个权重向量w与x线性组合后得到z，再使用激活函数将z压缩到二元输入（1/-1），区别在于Adaline使用梯度下降法来更新w。&lt;/p&gt;
&lt;p&gt;因为我们的目的是准确分类，那么我们需要来衡量分类效果的好坏，在这里我们介绍目标函数：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ J(w) = \frac12 \sum_i^n(y^i - \phi(z^i))^2 \]&lt;/span&gt;&lt;br/&gt;它也可以叫做损失函数，通过上式我们可以大致理解为什么叫做损失函数，此函数可以计算出所有训练样本的真实值和预测值之间的误差平方和（Sum of Squared Errors，简称SSE），式子前面的那个1/2是为了之后求导方便添加的，没有其他意义。&lt;/p&gt;
&lt;p&gt;有了损失函数，于是我们的目的更具体一点，就是为了选择合适的w，使损失函数取得最小值，损失函数越小，就意味着错误分类的情况越少，算法的分类效果也就越好。而因为Adaline的损失函数是一个凸函数，所以我们可以使用梯度下降来找到使损失函数取值最小的权重向量w，我们可以想象为一个小球滚下山：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133903/201911/1133903-20191112231226428-994218418.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;刚开始的w也许会得到一个很大的损失函数，但是由于损失函数J是w的函数，并且也是一个凸函数，它存在一个最小值，学过微积分的朋友应该知道，要找到一个函数的最值，一般的方法通过求导并使导数为零，解出的那个x就是最值，在这里的梯度下降也就是求导，但由于w是一个权重向量，是多维的，所以需要损失函数对w求偏导，得到w中每个分量的偏导数，然后再更新整个w，具体的推导过程如下：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ 注意：w为向量，w_j为向量w中的某一分量\\w = w + \Delta w\\\Delta w = -\eta\Delta J(w)\\\frac{\partial J}{\partial w_j} = \frac{\partial }{\partial w_j} \frac 12 \sum_i(y^i-\phi(z^i))^2 \\= \frac 12 \frac{\partial }{\partial w_j} \sum_i(y^i-\phi(z^i))^2 \\= \frac 12 \sum_i2(y^i-\phi(z^i)) \frac{\partial }{\partial w_j}(y^i-\phi(z^i))\\= \sum_i(y^i-\phi(z^i))\frac{\partial }{\partial w_j}(y^i-\sum_i(w_j^ix_j^i))\\=\sum_i(y^i-\phi(z^i))(-x_j^i)\\=-\sum_i(y^i-\phi(z^i))x_j^i\\所以\Delta w_j = -\eta\frac{\partial J}{\partial w_j}=\eta\sum_i(y^i-\phi(z^i))x_j^i \]&lt;/span&gt;&lt;br/&gt;一点要注意所以的权重向量w中的分量是同时更新的，而且每次更新都用到了所有的训练样本，所以梯度下降法也被称为批量梯度下降（batch gradient descent）&lt;/p&gt;
&lt;p&gt;接下来我们具体来实现自适应线性神经元，由于和感知机的学习规则很相似，所以直接在感知器的基础上进行修改得到，其中需要修改fit方法，因为在这里我们要使用梯度下降算法。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class AdalineGD(object):
    &quot;&quot;&quot;ADAptive LInear NEuron classifier.

    Parameters
    ----------
    eta:float
        Learning rate(between 0.0 and 1.0
    n_iter:int
        Passes over the training dataset.

    Attributes
    ----------
    w_:1d-array
        weights after fitting.
    errors_:list
        Number of miscalssifications in every epoch.

    &quot;&quot;&quot;

    def __init__(self, eta=0.01, n_iter=10):
        self.eta = eta
        self.n_iter = n_iter

    def fit(self, X, y):
        &quot;&quot;&quot;Fit training data.

        :param X:{array-like}, shape=[n_samples, n_features]
        Training vectors,
        :param y: array-like, shape=[n_samples]
        Target values.
        :return:
        self:object

        &quot;&quot;&quot;

        self.w_ = np.zeros(1 + X.shape[1]) # Add w_0
        self.cost_ = []

        for i in range(self.n_iter):
            output = self.net_input(X)
            errors = (y - output)
            self.w_[1:] += self.eta * X.T.dot(errors)
            self.w_[0] += self.eta * errors.sum()
            cost = (errors ** 2).sum() / 2.0
            self.cost_.append(cost)
        return self

    def net_input(self, X):
        &quot;&quot;&quot;Calculate net input&quot;&quot;&quot;
        return np.dot(X, self.w_[1:]) + self.w_[0]
    
    def activation(self, X):
        &quot;&quot;&quot;Computer linear activation&quot;&quot;&quot;
        return self.net_input(X)
    
    def predict(self, X):
        &quot;&quot;&quot;Return class label after unit step&quot;&quot;&quot;
        return np.where(self.activation(X) &amp;gt;= 0.0, 1, -1)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;分别使用不同的学习率（0.01和0.0001）训练，观察神经元学习过程。其中学习率、迭代次数我们称他们为超参数（hyperparameters），我们可以手动设置，超参数设置的是否合适对于整个训练过程都很重要。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;fig, ax = plt.subplots(nrows=1, ncols=2, figsize=(8,4))
ada1 = AdalineGD(n_iter=10, eta=0.01).fit(X, y)
ax[0].plot(range(1, len(ada1.cost_) + 1), np.log10(ada1.cost_), marker='o')
ax[0].set_xlabel('Epochs')
ax[0].set_ylabel('log(Sum-squared-error)')
ax[0].set_title('Adaline - Learning rate 0.01')
ada2 = AdalineGD(n_iter=10, eta=0.0001).fit(X, y)
ax[1].plot(range(1, len(ada2.cost_) + 1), ada2.cost_, marker='o')
ax[1].set_xlabel('Epochs')
ax[1].set_ylabel('Sum-squared-error')
ax[1].set_title('Adaline - Learning rate 0.0001')
plt.show()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133903/201911/1133903-20191112231346841-593728871.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看出，左图中学习率为0.01，随着迭代次数的增加，误差在增加，说明学习率设置的不合适，产生了很大的危害，而右图学习率为0.0001，随着迭代次数的增加，误差在减少，但是减少的过于缓慢，算法收敛的很慢，训练的效率太低，所以我们可以看出过大或过小的学习率都是不合适的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133903/201911/1133903-20191112231404872-342294516.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由右图可以看出，如果学习率过大，就会导致每次梯度下降时都跳过了对应最小值的权重向量w，使得算法无法收敛。&lt;/p&gt;
&lt;p&gt;接下来我们介绍一种数据预处理方法，在训练前将特征进行某种缩放操作，这里我们称为特征标准化，可以使所有特征数据缩放成平均值为0，方差为1，加快模型的训练速度，而且可以避免模型学习的很扭曲。&lt;/p&gt;
&lt;p&gt;具体公式如下：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ x_j^, = \frac {x_j-\mu_j}{\sigma_j} \]&lt;/span&gt;&lt;br/&gt;具体实现如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;X_std = np.copy(X)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;X_std[:, 0] = (X[:,0] - X[:,0].mean()) / X[:,0].std()&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;X_std[:, 1] = (X[:,1] - X[:,1].mean()) / X[:,1].std()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;数据已经预处理结束，接下来我们开始训练模型&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;ada = AdalineGD(n_iter=15, eta=0.01)
ada.fit(X_std, y)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;plot_decision_region(X_std, y, classifier=ada)
plt.title('Adaline - Gradient Descent')
plt.xlabel('sepal length [standardized]')
plt.ylabel('petal length [standardized]')
plt.legend(loc='upper left')
plt.show()

plt.plot(range(1, len(ada.cost_) + 1), ada.cost_, marker='o')
plt.xlabel('Epoches')
plt.ylabel('Sum-squared_error')
plt.show()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133903/201911/1133903-20191112231508350-224744004.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133903/201911/1133903-20191112231520104-1712211155.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图看出，随着迭代次数的增加，误差逐渐降低，虽然学习率为0.01，在进行标准化之前，算法并不能收敛，但经过标准化后，算法最终收敛。&lt;/p&gt;
</description>
<pubDate>Tue, 12 Nov 2019 15:18:00 +0000</pubDate>
<dc:creator>Xlgd</dc:creator>
<og:description>上篇博客我们说了感知器，这篇博客主要记录自适应线性神经元的实现算法及一些其他的训练细节，自适应线性神经元（简称为Adaline）由Bernard Widrow和他的博士生Tedd Hoff提出，对感知</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Dzha/p/11846125.html</dc:identifier>
</item>
</channel>
</rss>