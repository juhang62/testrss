<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Unity游戏开发之C#快速入门 - 鱼桑燕子梁</title>
<link>http://www.cnblogs.com/mthz/p/unity0.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mthz/p/unity0.html</guid>
<description>&lt;p&gt;C#是微软团队在开发.NET框架时开发的，它的构想接近于C、C++，也和JAVA十分相似，有许多强大的编程功能。&lt;br/&gt;个人感受是C#吸收了众多编程语言的优点，从中可以看到C、C++、Java、Javascript、python的影子，设计思想都是相通的(过段时间一定要看看设计模式)，对比迁移地学习基本只需要记关键字、语法和包的用法。我是为了unity游戏开发课程学的，不是很深入，某些细节可能也没有涉及到。 就先复习了以前学C++、java的笔记，然后对照着简单学了C#，会重点学unity中用到的包。&lt;/p&gt;
&lt;h2 id=&quot;c程序结构&quot;&gt;1.C#程序结构&lt;/h2&gt;
&lt;p&gt;C# 中的关键组织结构概念包括&lt;strong&gt;程序、命名空间、类型、成员和程序集&lt;/strong&gt;。&lt;br/&gt;一个C#版HelloWorld直观感受一下。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;using System;                               //包含命名空间
namespace HelloWorldApplication         //声明一个命名空间
{
   class HelloWorld                 //类声明
   {
      static void Main(string[] args)           //Main入口函数
      {
         /* 我的第一个 C# 程序*/
         Console.WriteLine(&quot;Hello World&quot;);  //输出
         Console.ReadKey();
      }
   }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;与 Java 不同，文件名可以不同于类的名称。&lt;/p&gt;
&lt;h2 id=&quot;数据类型类型转换&quot;&gt;2.数据类型、类型转换&lt;/h2&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li&gt;&lt;strong&gt;值类型&lt;/strong&gt; (从System.ValueType中派生)&lt;br/&gt;bool、byte、char、decimal、double、float、int、long、sbyte、short、uint、ulong、ushort、结构体struct、枚举enum&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;引用类型&lt;/strong&gt;&lt;br/&gt;引用类型不包含存储在变量中的实际数据，而是包含对变量的引用。&lt;br/&gt;内置的引用类型有：object、dynamic 和 string。&lt;br/&gt;自定义的有：类&lt;code&gt;class C {...}&lt;/code&gt;、接口&lt;code&gt;interface I {...}&lt;/code&gt;、委托&lt;code&gt;delegate int D(...)&lt;/code&gt;、数组&lt;code&gt;int[]&lt;/code&gt; 和 &lt;code&gt;int[,]&lt;/code&gt;。&lt;br/&gt;对象类型变量的类型检查是在编译时发生。&lt;br/&gt;动态类型变量的类型检查是在运行时发生。&lt;br/&gt;@引号的字符串会将转义字符（）当作普通字符，可以任意换行，换行符及缩进空格都计算在字符串长度之内。&lt;br/&gt;字符串的占位符为{}，如：&lt;code&gt;String.Format(“{0},{1}”,c,d);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;指针类型&lt;/strong&gt;&lt;br/&gt;指针类型变量存储另一种类型的内存地址。&lt;br/&gt;例如：&lt;code&gt;char* cptr;&lt;/code&gt;&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;可空类型&lt;/strong&gt;&lt;br/&gt;null是引用类型变量的默认值，null不允许被赋给值类型的变量，但有时我们希望值类型的数据可以为null，就有了可空类型。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  int a = null;    // 非法
  int? a = null;      // 合法，可空类型
  Nullable&amp;lt;int&amp;gt; i = new Nullable&amp;lt;int&amp;gt;(3);//可空类型&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;合并运算符（??）定义了一个预设值，以防可空类型的值为null。&lt;br/&gt;如:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;double? num1 = null;
double num3 = num1 ?? 5.34;      // num1 如果为空值则返回 5.34&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;类型转换如：&lt;code&gt;i = (int)d;i.ToString();s.ToBoolean();&lt;/code&gt;&lt;br/&gt;C#的运算符，判断、循环语句和C++的语法基本一致，不做过多说明。&lt;/p&gt;
&lt;h2 id=&quot;方法类接口泛型&quot;&gt;3.方法、类、接口、泛型&lt;/h2&gt;
&lt;p&gt;一个 访问修饰符 定义了一个类成员的范围和可见性。&lt;br/&gt;C# 支持的访问修饰符如下所示：&lt;br/&gt;public：所有对象都可以访问；&lt;br/&gt;private：对象本身在对象内部可以访问；&lt;br/&gt;protected：只有该类对象及其子类对象可以访问&lt;br/&gt;internal：同一个程序集的对象可以访问；&lt;br/&gt;protected internal：访问限于当前程序集或派生自包含类的类型。&lt;/p&gt;
&lt;p&gt;C# 中定义方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;Access Specifier&amp;gt; &amp;lt;Return Type&amp;gt; &amp;lt;Method Name&amp;gt;(Parameter List)
{
   Method Body
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;C#中的类和java是很像的，不过继承的时候用的:,而不是extends。&lt;br/&gt;类中也有构造函数、析构函数、静态成员（static）。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Line
   {
      private double length;   // 线条的长度
      public Line()  // 构造函数
      {
         Console.WriteLine(&quot;对象已创建&quot;);
      }
      ~Line() //析构函数
      {
         Console.WriteLine(&quot;对象已删除&quot;);
      }

      public void setLength( double len )
      {
         length = len;
      }
   }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;类的继承:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class &amp;lt;派生类&amp;gt; : &amp;lt;基类1&amp;gt;,&amp;lt;基类2&amp;gt;,...
{
 ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接口的继承和实现也是用的冒号：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;interface IMyInterface : IParentInterface
{
}
class InterfaceImplementer : IMyInterface
{
    //接口中方法的实现
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;泛型：&lt;br/&gt;&lt;code&gt;using System.Collections.Generic;&lt;/code&gt;&lt;br/&gt;&lt;code&gt;GenericList&amp;lt;float&amp;gt; list1 = new GenericList&amp;lt;float&amp;gt;();&lt;/code&gt;&lt;br/&gt;C#的泛型和C++模板类似，但也有&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/generics/differences-between-cpp-templates-and-csharp-generics&quot;&gt;不同&lt;/a&gt;&lt;br/&gt;泛型可以通过使用 where 上下文关键字指定约束。&lt;/p&gt;
&lt;h2 id=&quot;域field属性peoperty索引器indexer&quot;&gt;4.域（Field）、属性（Peoperty）、索引器（Indexer）&lt;/h2&gt;
&lt;h4 id=&quot;域和属性的区别&quot;&gt;域和属性的区别&lt;/h4&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;逻辑性&lt;/td&gt;
&lt;td&gt;逻辑字段，在改变字段时&lt;br/&gt;能改变对象的其他一些状态&lt;/td&gt;
&lt;td&gt;不经过逻辑处理&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;存储性&lt;/td&gt;
&lt;td&gt;不占用实际内存&lt;/td&gt;
&lt;td&gt;占内存空间及位置&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;访问性&lt;/td&gt;
&lt;td&gt;由get、set访问器决定读写属性&lt;/td&gt;
&lt;td&gt;由访问修饰符决定&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;安全性&lt;/td&gt;
&lt;td&gt;增加了数据的安全性&lt;/td&gt;
&lt;td&gt;不太安全&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;为了实现对字段的封装，保证字段的安全性，而产生了属性，其本质是方法,通常是配合使用的，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Student
   {
      private string name = &quot;not known&quot;;

      // 声明类型为 string 的 Name 属性
      public string Name
      {
         get
         {
            return name;
         }
         set
         {
            name = value;
         }
      }
   }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;索引器&quot;&gt;索引器&lt;/h4&gt;
&lt;p&gt;索引器（Indexer）允许一个对象可以像数组一样被索引。&lt;br/&gt;和属性类似，可使用 get 和 set 访问器来定义索引器，而索引器返回或设置对象实例的一个特定值。&lt;/p&gt;
&lt;h2 id=&quot;委托匿名函数事件&quot;&gt;5.委托、匿名函数、事件&lt;/h2&gt;
&lt;h4 id=&quot;委托&quot;&gt;委托&lt;/h4&gt;
&lt;p&gt;委托可以理解为函数指针，是对函数原型的包装。&lt;br/&gt;但相比于函数指针，委托面向对象，类型更安全，有多播的功能。&lt;br/&gt;通过委托，可以将方法视为可分配给变量并可作为参数传递的实体。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;申明委托：&lt;code&gt;delegate void TestDelegate(string s);&lt;/code&gt;&lt;br/&gt;  可以再任何地方声明委托，可以带访问修饰符。&lt;br/&gt;  委托不关心引用的方法的类，只关心引用的方法是否与委托有相同的参数和返回类型。&lt;/li&gt;
&lt;li&gt;实例化委托：&lt;code&gt;TestDelegate testdelA = new TestDelegate(M);&lt;/code&gt;&lt;br/&gt;  用某个方法实例化这个委托,也就是说，使函数指针指向一个方法。&lt;/li&gt;
&lt;li&gt;调用委托：&lt;code&gt;testdelA(&quot;Hello&quot;);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;委托可以多播&lt;br/&gt;  委托间可以使用+、-来组合、移除，委托判等是根据它引用的方法判断。&lt;/li&gt;
&lt;li&gt;泛型委托：&lt;code&gt;delegate T NumberChanger&amp;lt;T&amp;gt;(T n);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;匿名函数与lambda表达式&quot;&gt;匿名函数与Lambda表达式&lt;/h4&gt;
&lt;p&gt;匿名方法（Anonymous methods） 提供了一种传递代码块作为委托参数的技术。&lt;br/&gt;匿名方法没有名称只有主体，不需要指定返回类型，它是从方法主体内的 return 语句推断的。&lt;br/&gt;匿名函数与委托的使用步骤相同，实例化时格式不同，格式如下：&lt;br/&gt;&lt;code&gt;委托名 实例变量 =delegate(形参列表){方法体};&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Lambda表达式也是匿名函数，语法更加简洁：&lt;br/&gt;&lt;code&gt;(参数列表) =&amp;gt; {方法体}&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;事件&quot;&gt;事件&lt;/h4&gt;
&lt;p&gt;事件使用 发布-订阅（publisher-subscriber） 模型。&lt;br/&gt;在类的内部声明事件，首先必须声明该事件的委托类型。例如：&lt;br/&gt;&lt;code&gt;public delegate void BoilerLogHandler(string status);&lt;/code&gt;&lt;br/&gt;然后，使用 event 关键字声明事件本身：&lt;br/&gt;&lt;code&gt;public event BoilerLogHandler BoilerEventLog;&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;c常用类库&quot;&gt;6.C#常用类库&lt;/h2&gt;
&lt;p&gt;System.Collections&lt;br/&gt;集合（Collection）类是专门用于数据存储和检索的类。常用的有:&lt;/p&gt;
&lt;table readability=&quot;4.5&quot;&gt;&lt;tr&gt;&lt;td&gt;集合类&lt;/td&gt;
&lt;td&gt;常用方法&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;动态数组&lt;br/&gt;ArrayList&lt;/td&gt;
&lt;td&gt;Add(item)、Clear()、Contains()、IndexOf()、&lt;br/&gt;Remove()、Sort()、Reverse()&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;哈希表&lt;br/&gt;Hashtable&lt;/td&gt;
&lt;td&gt;Add(key,value)、Clear()、Remove(key)、&lt;br/&gt;ContainsKey(key)、ContainsValue(value)&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;堆栈&lt;br/&gt;Stack&lt;/td&gt;
&lt;td&gt;Clear()、Contains()、Peek()、 Pop()、PushToArray()&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;队列&lt;br/&gt;Queue&lt;/td&gt;
&lt;td&gt;Clear()、Contains()、Dequeue()、&lt;br/&gt;Enqueue()、ToArray()、TrimToSize()&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td/&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;点阵列&lt;br/&gt;BitArray&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td/&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;排序列表&lt;br/&gt;SortedList&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;p&gt;个人笔记型博客，仔细学习可移步&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/csharp/index&quot;&gt;C#官方文档&lt;/a&gt;或&lt;a href=&quot;http://www.runoob.com/csharp/csharp-tutorial.html&quot;&gt;菜鸟教程-C#教程&lt;/a&gt;。&lt;/p&gt;
</description>
<pubDate>Sun, 07 Apr 2019 07:25:00 +0000</pubDate>
<dc:creator>鱼桑燕子梁</dc:creator>
<og:description>C 是微软团队在开发.NET框架时开发的，它的构想接近于C、C++，也和JAVA十分相似，有许多强大的编程功能。 个人感受是C 吸收了众多编程语言的优点，从中可以看到C、C++、Java、Javasc</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mthz/p/unity0.html</dc:identifier>
</item>
<item>
<title>Java基础9：解读Java回调机制 - 黄小斜</title>
<link>http://www.cnblogs.com/xll1025/p/10665282.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xll1025/p/10665282.html</guid>
<description>&lt;p&gt;&lt;strong&gt;更多内容请关注微信公众号【Java技术江湖】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这是一位阿里 Java 工程师的技术小站，作者黄小斜，专注 Java 相关技术：SSM、SpringBoot、MySQL、分布式、中间件、集群、Linux、网络、多线程，偶尔讲点Docker、ELK，同时也分享技术干货和学习经验，致力于Java全栈开发！（关注公众号后回复”资料“即可领取 3T 免费技术学习资源以及我我原创的程序员校招指南、Java学习指南等资源）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/4/6/169f1735fd0d1d16?w=900&amp;amp;h=500&amp;amp;f=jpeg&amp;amp;s=109856&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本文主要介绍了Java中的回调机制，以及Java多线程中类似回调的机制。&lt;/p&gt;
&lt;p&gt;具体代码在我的GitHub中可以找到&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/h2pl/MyTech&quot;&gt;https://github.com/h2pl/MyTech&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文章首发于我的个人博客：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://h2pl.github.io/2018/04/26/javase9&quot;&gt;https://h2pl.github.io/2018/04/26/javase9&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;更多关于Java后端学习的内容请到我的CSDN博客上查看：&lt;a href=&quot;https://blog.csdn.net/a724888&quot;&gt;https://blog.csdn.net/a724888&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;模块间的调用&lt;/h4&gt;
&lt;p&gt;本部分摘自https://www.cnblogs.com/xrq730/p/6424471.html&lt;/p&gt;
&lt;p&gt;在一个应用系统中，无论使用何种语言开发，必然存在模块之间的调用，调用的方式分为几种：&lt;/p&gt;
&lt;p&gt;（1）同步调用&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;同步调用是最基本并且最简单的一种调用方式，类A的方法a()调用类B的方法b()，一直等待b()方法执行完毕，a()方法继续往下走。这种调用方式适用于方法b()执行时间不长的情况，因为b()方法执行时间一长或者直接阻塞的话，a()方法的余下代码是无法执行下去的，这样会造成整个流程的阻塞。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt=&quot;image&quot; src=&quot;https://user-gold-cdn.xitu.io/2019/4/7/169f677fb3b5b0a7?w=347&amp;amp;h=117&amp;amp;f=png&amp;amp;s=3749&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）异步调用&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;image&quot; src=&quot;https://user-gold-cdn.xitu.io/2019/4/7/169f677fb19fde5d?w=343&amp;amp;h=110&amp;amp;f=png&amp;amp;s=3682&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;17&quot;&gt;
&lt;p&gt;异步调用是为了解决同步调用可能出现阻塞，导致整个流程卡住而产生的一种调用方式。类A的方法方法a()通过新起线程的方式调用类B的方法b()，代码接着直接往下执行，这样无论方法b()执行时间多久，都不会阻塞住方法a()的执行。&lt;/p&gt;
&lt;p&gt;但是这种方式，由于方法a()不等待方法b()的执行完成，在方法a()需要方法b()执行结果的情况下（视具体业务而定，有些业务比如启异步线程发个微信通知、刷新一个缓存这种就没必要），必须通过一定的方式对方法b()的执行结果进行监听。&lt;/p&gt;
&lt;p&gt;在Java中，可以使用Future+Callable的方式做到这一点，具体做法可以参见我的这篇文章Java多线程21：多线程下其他组件之CyclicBarrier、Callable、Future和FutureTask。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;（3）回调&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;image&quot; src=&quot;https://user-gold-cdn.xitu.io/2019/4/7/169f677fb2866321?w=450&amp;amp;h=255&amp;amp;f=png&amp;amp;s=10812&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后是回调，回调的思想是：&lt;/p&gt;
&lt;p&gt;类A的a()方法调用类B的b()方法 类B的b()方法执行完毕主动调用类A的callback()方法 这样一种调用方式组成了上图，也就是一种双向的调用方式。&lt;/p&gt;
&lt;h4&gt;回调实例：Tom做题&lt;/h4&gt;
&lt;p&gt;数学老师让Tom做一道题，并且Tom做题期间数学老师不用盯着Tom，而是在玩手机，等Tom把题目做完后再把答案告诉老师。&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;1 数学老师需要Tom的一个引用，然后才能将题目发给Tom。&lt;/p&gt;
&lt;p&gt;2 数学老师需要提供一个方法以便Tom做完题目以后能够将答案告诉他。&lt;/p&gt;
&lt;p&gt;3 Tom需要数学老师的一个引用，以便Tom把答案给这位老师，而不是隔壁的体育老师。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;回调接口，可以理解为老师接口&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    //回调指的是A调用B来做一件事，B做完以后将结果告诉给A，这期间A可以做别的事情。
    //这个接口中有一个方法，意为B做完题目后告诉A时使用的方法。
    //所以我们必须提供这个接口以便让B来回调。
    //回调接口，
    public interface CallBack {
        void tellAnswer(int res);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;数学老师类&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    //老师类实例化回调接口，即学生写完题目之后通过老师的提供的方法进行回调。
    //那么学生如何调用到老师的方法呢，只要在学生类的方法中传入老师的引用即可。
    //而老师需要指定学生答题，所以也要传入学生的实例。
public class Teacher implements CallBack{
    private Student student;

    Teacher(Student student) {
        this.student = student;
    }

    void askProblem (Student student, Teacher teacher) {
        //main方法是主线程运行，为了实现异步回调，这里开启一个线程来操作
        new Thread(new Runnable() {
            @Override
            public void run() {
                student.resolveProblem(teacher);
            }
        }).start();
        //老师让学生做题以后，等待学生回答的这段时间，可以做别的事，比如玩手机.\
        //而不需要同步等待，这就是回调的好处。
        //当然你可以说开启一个线程让学生做题就行了，但是这样无法让学生通知老师。
        //需要另外的机制去实现通知过程。
        // 当然，多线程中的future和callable也可以实现数据获取的功能。
        for (int i = 1;i &amp;lt; 4;i ++) {
            System.out.println(&quot;等学生回答问题的时候老师玩了 &quot; + i + &quot;秒的手机&quot;);
        }
    }

    @Override
    public void tellAnswer(int res) {
        System.out.println(&quot;the answer is &quot; + res);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;学生接口&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    //学生的接口，解决问题的方法中要传入老师的引用，否则无法完成对具体实例的回调。
    //写为接口的好处就是，很多个学生都可以实现这个接口，并且老师在提问题时可以通过
    //传入List&amp;lt;Student&amp;gt;来聚合学生，十分方便。
public interface Student {
    void resolveProblem (Teacher teacher);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;学生Tom&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Tom implements Student{

    @Override
    public void resolveProblem(Teacher teacher) {
        try {
            //学生思考了3秒后得到了答案，通过老师提供的回调方法告诉老师。
            Thread.sleep(3000);
            System.out.println(&quot;work out&quot;);
            teacher.tellAnswer(111);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试类&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Test {
    public static void main(String[] args) {
        //测试
        Student tom = new Tom();
        Teacher lee = new Teacher(tom);
        lee.askProblem(tom, lee);
        //结果
//        等学生回答问题的时候老师玩了 1秒的手机
//        等学生回答问题的时候老师玩了 2秒的手机
//        等学生回答问题的时候老师玩了 3秒的手机
//        work out
//        the answer is 111
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4&gt;多线程中的“回调”&lt;/h4&gt;
&lt;p&gt;Java多线程中可以通过callable和future或futuretask结合来获取线程执行后的返回值。实现方法是通过get方法来调用callable的call方法获取返回值。&lt;/p&gt;
&lt;p&gt;其实这种方法本质上不是回调，回调要求的是任务完成以后被调用者主动回调调用者的接口。而这里是调用者主动使用get方法阻塞获取返回值。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class 多线程中的回调 {
    //这里简单地使用future和callable实现了线程执行完后
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        ExecutorService executor = Executors.newCachedThreadPool();
        Future&amp;lt;String&amp;gt; future = executor.submit(new Callable&amp;lt;String&amp;gt;() {
            @Override
            public String call() throws Exception {
                System.out.println(&quot;call&quot;);
                TimeUnit.SECONDS.sleep(1);
                return &quot;str&quot;;
            }
        });
        //手动阻塞调用get通过call方法获得返回值。
        System.out.println(future.get());
        //需要手动关闭，不然线程池的线程会继续执行。
        executor.shutdown();

    //使用futuretask同时作为线程执行单元和数据请求单元。
    FutureTask&amp;lt;Integer&amp;gt; futureTask = new FutureTask(new Callable&amp;lt;Integer&amp;gt;() {
        @Override
        public Integer call() throws Exception {
            System.out.println(&quot;dasds&quot;);
            return new Random().nextInt();
        }
    });
    new Thread(futureTask).start();
    //阻塞获取返回值
    System.out.println(futureTask.get());
}
@Test
public void test () {
    Callable callable = new Callable() {
        @Override
        public Object call() throws Exception {
            return null;
        }
    };
    FutureTask futureTask = new FutureTask(callable);

}
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sun, 07 Apr 2019 06:34:00 +0000</pubDate>
<dc:creator>黄小斜</dc:creator>
<og:description>更多内容请关注微信公众号【Java技术江湖】这是一位阿里 Java 工程师的技术小站，作者黄小斜，专注 Java 相关技术：SSM、SpringBoot、MySQL、分布式、中间件、集群、Linux、</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xll1025/p/10665282.html</dc:identifier>
</item>
<item>
<title>关于Java 值传递 深度分析 - 昆明--菜鸟入门</title>
<link>http://www.cnblogs.com/kunming97/p/10665287.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kunming97/p/10665287.html</guid>
<description>&lt;p&gt;首先说观点：java只有值传递没有引用传递&lt;/p&gt;
&lt;p&gt;然后再来看看值传递与引用传递两者的定义&lt;/p&gt;
&lt;p&gt;值传递（pass by value）是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。&lt;/p&gt;
&lt;p&gt;引用传递（pass by reference）是指在调用函数时将实际参数的地址直接传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。&lt;/p&gt;
&lt;p&gt;这里牢记值传递中将&lt;span&gt;实际参数复制一份。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;然后就是对于参数类型：值类型 和 引用类型。&lt;/p&gt;
&lt;p&gt;结合起来理解就是：值类型传递，java是将其值内容复制一份给形参；对于引用类型传递，java是将其&lt;span&gt;地址复制&lt;/span&gt;一份给形参。&lt;/p&gt;
&lt;p&gt;下面结合实例深入理解为什么java只有值传递&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; 字符串;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; 值传递 {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)
    {
        String str1&lt;/span&gt;=&quot;abc&quot;&lt;span&gt;;
        updateStr1(str1);
        System.out.println(&lt;/span&gt;&quot;main函数中&quot;+&lt;span&gt;str1);
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; updateStr1(String str1)
    {
        str1&lt;/span&gt;=&quot;cba&quot;;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;&amp;lt;注解&amp;gt;&lt;/span&gt;
        System.out.println(&quot;调用函数中&quot;+&lt;span&gt;str1);
    }
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1124164/201904/1124164-20190407130414892-65924395.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这里我们能够清晰看到我们传递的是String类型的对象即（引用类型），并且在调用函数中我们修改了str1为cba，如果是引用传递那么我们在主函数打印则应该是cba，&lt;/p&gt;
&lt;p&gt;但是很遗憾我们在主函数中仍然打印出来的是abc。所以我们可以说java是值传递类型了吗，答案是不完全的。&lt;/p&gt;
&lt;p&gt;接下来再看这一段代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; 字符串;&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;　　public class person {&lt;br/&gt; 　　private int age;&lt;br/&gt; 　　public int getAge() {&lt;br/&gt;  return age;&lt;br/&gt; }&lt;br/&gt; public void setAge(int age) {&lt;br/&gt;  this.age = age;&lt;br/&gt; }&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; 值传递2 {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)
    {
        person p1&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; person();
        p1.setAge(&lt;/span&gt;10&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;我在主函数里对p1的年龄属性赋值为&quot;+&lt;span&gt;p1.getAge());
        setage(p1);
        System.out.println(&lt;/span&gt;&quot;我再从主函数里获取P1的年龄属性&quot;+&lt;span&gt;p1.getAge());
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setage(person p1)
    {
        p1.setAge(&lt;/span&gt;18);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;不是我们对它的地址进行了操作，而是我们对它地址的内容进行了操作&lt;/span&gt;
        System.out.println(&quot;我在调用函数里对p1的年龄属性重新赋值为&quot;+&lt;span&gt;p1.getAge());
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1124164/201904/1124164-20190407131514009-1974530001.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;咦，怎么回事这次也是传递的对象（引用类型），为什么这次我们对年龄这个字段的修改在主函数同步了呢？&lt;/p&gt;
&lt;p&gt;别急，下面我们先来分析这两个例子。&lt;/p&gt;
&lt;p&gt;首先第一个类型的例子中，我们传递的是String类型的变量，它是一个特殊的类型的引用变量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;（不可变字符串：编译器可让字符串共享，即将各种字符串存放于公共存储池中，字符串变量&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;是指向其中相应位置    --出自《Java核心技术&lt;/span&gt; &lt;span&gt;卷1》）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;出于这句话的理解就是每个字符串都对应一个地址：我们例一中是将str1的地址&lt;span&gt;复制&lt;/span&gt;给了我们的形参str1，并且形参中str1的地址进行了改变指向了“cba”的地址。所以说在主函数中的str1的地址&lt;/strong&gt;&lt;strong&gt;仍然指向的是“abc”所对应的地址。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所以说对于String类型的变量，我们对于给它重新赋值不是改变了它的内容，而是改变了它指向字符串的位置。这也就解释了为什么java中String类型是不可变类型。&lt;/p&gt;
&lt;p&gt;而在我们例二中，我们将p1的地址&lt;strong&gt;&lt;span&gt;复制&lt;/span&gt;&lt;/strong&gt;给了我们形参中的p1,&lt;strong&gt;&lt;span&gt;此时他们都指向的内存中一块相同的地址这里存放着相同内容&lt;/span&gt;&lt;/strong&gt;，所以我们在调用函数对这个地址中的内容进行修改时就会同步到我们主函数中的p1。所以这个并不意味着这个是引用传递。&lt;/p&gt;
&lt;p&gt;好吧，那怎么才能解释好Java确实是值传递呢（上面String类型例子是特殊的引用类型不方便解释）&lt;/p&gt;
&lt;p&gt;下面我们通过这个例子说明：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; 字符串;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; person {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getAge() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; age;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setAge(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; age) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
    }

}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; 值传递3 {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        person p1&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; person();
        person p2&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; person();
        p1.setAge(&lt;/span&gt;10&lt;span&gt;);
        p2.setAge(&lt;/span&gt;18&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;我在主函数里对p1的年龄属性赋值为&quot;+&lt;span&gt;p1.getAge());
        System.out.println(&lt;/span&gt;&quot;我在主函数里对p2的年龄属性赋值为&quot;+&lt;span&gt;p2.getAge());
        swap(p1,p2); 
        System.out.println(&lt;/span&gt;&quot;************我是主函数里的分割线***************&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;我再在主函数里分别对p1,p2获取他们的年龄，若为引用传递则p1的年龄应该为18，p2为10.&lt;/span&gt;
        System.out.println(&quot;我在主函数里获取p1的年龄&quot;+&lt;span&gt;p1.getAge());
        System.out.println(&lt;/span&gt;&quot;我在主函数里获取p1的年龄&quot;+&lt;span&gt;p2.getAge());
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; swap(person p1,person p2)
    {
        System.out.println(&lt;/span&gt;&quot;************我是调用函数里的分割线***************&quot;&lt;span&gt;);
        person temp&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; person();
        temp&lt;/span&gt;=&lt;span&gt;p1;
        p1&lt;/span&gt;=&lt;span&gt;p2;
        p2&lt;/span&gt;=&lt;span&gt;temp;
        System.out.println(&lt;/span&gt;&quot;我在调用函数里交换了p1和p2指向的地址&quot;&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;我在调用函数里对p1的年龄属性赋值为&quot;+&lt;span&gt;p1.getAge());
        System.out.println(&lt;/span&gt;&quot;我在调用函数里对p2的年龄属性赋值为&quot;+&lt;span&gt;p2.getAge());
        
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1124164/201904/1124164-20190407134411979-1301569944.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看到没，这就是充分说明Java是值传递的例子。在这个例子中我们依然传递的是person类的对象p1,p2（引用类型），他们将各自的地址&lt;strong&gt;&lt;span&gt;复制&lt;/span&gt;&lt;/strong&gt;一份到了形参p1、p2。&lt;/p&gt;
&lt;p&gt;然后我们在调用函数中交换了他们的地址，确实在调用函数中他们的age属性发生交换。但是再当我们在主函数获取他们的age时，如果是引用传递则应该p1的age为18，p2的age为10，&lt;/p&gt;
&lt;p&gt;和我们在调用函数中打印结果一致。但是，很遗憾在主函数中他们的值仍然是p1(10),p2(18)。所以这也充分印证了java是值传递。&lt;/p&gt;
&lt;p&gt;那么什么是引用传递呢？我们把代码放入C#看看。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace 值传递or引用传递
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; person
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getAge()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; age;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setAge(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; age)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
        }

    }
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main(string[] args)
        {
            person p1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; person();
            person p2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; person();
            person p3 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; person();
            p1.setAge(&lt;/span&gt;10&lt;span&gt;);
            p2.setAge(&lt;/span&gt;18&lt;span&gt;);
            p3.setAge(&lt;/span&gt;15&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&quot;我在主函数里对p1的年龄属性赋值为&quot; +&lt;span&gt; p1.getAge());
            Console.WriteLine(&lt;/span&gt;&quot;我在主函数里对p2的年龄属性赋值为&quot; +&lt;span&gt; p2.getAge());
            Console.WriteLine(&lt;/span&gt;&quot;我在主函数里对p3的年龄属性赋值为&quot; +&lt;span&gt; p3.getAge());
            swap(ref p1,ref p2,p3);
            Console.WriteLine(&lt;/span&gt;&quot;************我是主函数里的分割线***************&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;我再在主函数里分别对p1,p2获取他们的年龄，若为引用传递则p1的年龄应该为18，p2为10.&lt;/span&gt;
            Console.WriteLine(&quot;我在主函数里获取p1的年龄&quot; +&lt;span&gt; p1.getAge());
            Console.WriteLine(&lt;/span&gt;&quot;我在主函数里获取p2的年龄&quot; +&lt;span&gt; p2.getAge());
            Console.WriteLine(&lt;/span&gt;&quot;我在主函数里获取p3的年龄&quot; +&lt;span&gt; p3.getAge());
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; swap(ref person p1,ref person p2, person p3)
        {
            Console.WriteLine(&lt;/span&gt;&quot;************我是调用函数里的分割线***************&quot;&lt;span&gt;);
            person temp &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; person();
            temp &lt;/span&gt;=&lt;span&gt; p1;
            p1 &lt;/span&gt;=&lt;span&gt; p2;
            p2 &lt;/span&gt;=&lt;span&gt; temp;
            p3.setAge(&lt;/span&gt;20&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&quot;我在调用函数里交换了p1和p2指向的地址&quot;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&quot;我在调用函数里对p1交换地址后年龄为&quot; +&lt;span&gt; p1.getAge());
            Console.WriteLine(&lt;/span&gt;&quot;我在调用函数里对p2交换地址后年龄为&quot; +&lt;span&gt; p2.getAge());
            Console.WriteLine(&lt;/span&gt;&quot;我在调用函数里修改p3年龄为&quot; +&lt;span&gt; p3.getAge());

        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1124164/201904/1124164-20190407135412245-1695706384.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;请注意在C#中如果我们要实现引用传递，请加上关键字ref，否则，它执行的原理仍然与我们java中执行的机制一样，即拷贝一份地址给形参。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;如果你还有点晕，不妨我们来看看下面两张图。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1124164/201904/1124164-20190407142513651-149496647.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1124164/201904/1124164-20190407143123266-980093415.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 为了方便大家理解把图画成这样，然后关于java的值传递深度分析就到这里。欢迎大家一起讨论。（可以打脸/哈哈）&lt;/p&gt;

</description>
<pubDate>Sun, 07 Apr 2019 06:34:00 +0000</pubDate>
<dc:creator>昆明--菜鸟入门</dc:creator>
<og:description>首先说观点：java只有值传递没有引用传递 然后再来看看值传递与引用传递两者的定义 值传递（pass by value）是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kunming97/p/10665287.html</dc:identifier>
</item>
<item>
<title>搞懂Redis到底快在哪里 - GrimMjx</title>
<link>http://www.cnblogs.com/GrimMjx/p/10662254.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/GrimMjx/p/10662254.html</guid>
<description>&lt;h2&gt; 前言&lt;/h2&gt;
&lt;p&gt; 　　&lt;span&gt;Redis是一种基于键值对(Key-Value)的NoSQL数据库&lt;/span&gt;，Redis的Value可以由String，hash，list，set，zset，Bitmaps，HyperLogLog等多种数据结构和算法组成。Redis还提供了键过期，发布订阅，事务，Lua脚本，哨兵，Cluster等功能。Redis执行命令的速度非常快，根据官方给的性能可以达到10w+qps。那么本文主要介绍到底Redis快在哪里，主要有以下几点：&lt;/p&gt;

&lt;h2&gt;一.开发语言&lt;/h2&gt;
&lt;p&gt;　　现在我们都用高级语言来编程，比如Java、python等。也许你会觉得C语言很古老，但是它真的很有用，毕竟unix系统就是用C实现的，所以C语言是非常贴近操作系统的语言。&lt;span&gt;Redis就是用C语言开发的，所以执行会比较快。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　另外多说一句，大学生们好好学C，会让你更好的理解计算机操作系统。别觉得学了高级语言就可以不用关注底层，欠的债总归要还的。此处推荐一本比较难啃的书《深入理解计算系统》。&lt;/p&gt;

&lt;h2&gt;二.纯内存访问&lt;/h2&gt;
&lt;p&gt;　　Redis将所有数据放在内存中，非数据同步正常工作中，是不需要从磁盘读取数据的，&lt;span&gt;0次IO&lt;/span&gt;&lt;span&gt;。内存响应时间大约为100纳秒，这是Redis速度快的重要基础。&lt;/span&gt;先看看CPU的速度：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1465200/201904/1465200-20190407144034852-353807136.png&quot; alt=&quot;&quot; width=&quot;598&quot; height=&quot;341&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　拿我的电脑来说，主频是3.1G，也就是说每秒可以执行3.1*10^9个指令。所以说CPU看世界是非常非常慢的，内存比它慢百倍，磁盘比他慢百万倍，你说快不快？&lt;/p&gt;
&lt;p&gt;　　借了一张《深入理解计算机系统》的图，展示了一个典型的存储器层次结构，&lt;span&gt;在L0层，CPU可以在一个时钟周期访问到，基于SRAM的高速缓存春续期，可以在几个CPU时钟周期访问到，然后是基于DRAM的主存，可以在几十到几百个时钟周期访问到他们。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1465200/201904/1465200-20190406195338927-1401833225.png&quot; alt=&quot;&quot; width=&quot;579&quot; height=&quot;365&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;三.单线程&lt;/h2&gt;
&lt;p&gt;　　第一，&lt;span&gt;单线程简化算法的实现&lt;/span&gt;，并发的数据结构实现不但困难且测试也麻烦。第二，&lt;span&gt;单线程避免了线程切换以及加锁释放锁带来的消耗&lt;/span&gt;，对于服务端开发来说，锁和线程切换通常是性能杀手。当然了，单线程也会有它的缺点，也是Redis的噩梦：&lt;strong&gt;&lt;span&gt;阻塞。如果执行一个命令过长，那么会造成其他命令的阻塞，对于Redis是十分致命的&lt;/span&gt;&lt;/strong&gt;，所以Redis是面向快速执行场景的数据库。&lt;/p&gt;
&lt;p&gt;　　除了Redis之外，Node.js也是单线程，Nginx也是单线程，但他们都是服务器高性能的典范。&lt;/p&gt;

&lt;h2&gt;四.非阻塞多路I/O复用机制&lt;/h2&gt;
&lt;p&gt;　　在这之前先要说一下传统的阻塞I/O是如何工作的：当使用read或者write对某一文件描述符（File Descriptor FD）进行读写的时候，如果数据没有收到，那么该线程会被挂起，直到收到数据。阻塞模型虽然易于理解，但是&lt;span&gt;在需要处理多个客户端任务的时候，不会使用阻塞模型。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1465200/201904/1465200-20190407131907925-1548645894.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;　I/O多路复用实际上是指多个连接的&lt;strong&gt;管理可以在同一进程。&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;多路是指网络连接，复用只是同一个线程。&lt;/span&gt;在网络服务中，I/O多路复用起的作用是一次性把多个连接的事件通知业务代码处理，处理的方式由业务代码来决定。在I/O多路复用模型中，最重要的函数调用就是I/O 多路复用函数，该方法能同时监控多个文件描述符（fd）的读写情况，当其中的某些fd可读/写时，该方法就会返回可读/写的fd个数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1465200/201904/1465200-20190407132030030-945294836.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;Redis使用epoll作为I/O多路复用技术的实现，再加上Redis自身的事件处理模型将epoll的read、write、close等都转换成事件，不在网络I/O上浪费过多的时间。&lt;/span&gt;实现对多个FD读写的监控，提高性能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1465200/201904/1465200-20190407132447091-1828185678.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　举个形象的例子吧。比如一个tcp服务器处理20个客户端socket。A方案：顺序处理，如果第一个socket因为网卡读数据处理慢了，一阻塞后面都玩蛋去。B方案：每个socket请求都创建一个分身子进程来处理，不说每个进程消耗大量系统资源，光是进程切换就够操作系统累的了。C方案&lt;strong&gt;&lt;span&gt;（I/O复用模型，epoll）&lt;/span&gt;&lt;/strong&gt;：将用户socket对应的fd注册进epoll（实际上服务器和操作系统之间传递的不是socket的fd而是fd_set的数据结构），&lt;strong&gt;&lt;span&gt;然后epoll只告诉哪些需要读/写的socket，只需要处理那些活跃的、有变化的socket fd的就好了。&lt;/span&gt;&lt;/strong&gt;这样，整个过程只在调用epoll的时候才会阻塞，收发客户消息是不会阻塞的。&lt;/p&gt;


&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;《Redis实战》&lt;/p&gt;
&lt;p&gt;《Redis开发》&lt;/p&gt;
&lt;p&gt;《Redis Cookbook》&lt;/p&gt;
&lt;p&gt;《深入理解计算机系统》&lt;/p&gt;
&lt;p&gt;《码农翻身》&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://draveness.me/redis-io-multiplexing&quot; target=&quot;_blank&quot;&gt;https://draveness.me/redis-io-multiplexing&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/28594409/answer/52835876&quot; target=&quot;_blank&quot;&gt;https://www.zhihu.com/question/28594409/answer/52835876&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.masterraghu.com/subjects/np/introduction/unix_network_programming_v1.3/ch06lev1sec2.html&quot; target=&quot;_blank&quot;&gt;http://www.masterraghu.com/subjects/np/introduction/unix_network_programming_v1.3/ch06lev1sec2.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 07 Apr 2019 05:33:00 +0000</pubDate>
<dc:creator>GrimMjx</dc:creator>
<og:description>前言 Redis是一种基于键值对(Key-Value)的NoSQL数据库，Redis的Value可以由String，hash，list，set，zset，Bitmaps，HyperLogLog等多种数</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/GrimMjx/p/10662254.html</dc:identifier>
</item>
<item>
<title>java多线程——线程池源码分析（一） - cdream</title>
<link>http://www.cnblogs.com/cdream-zs/p/10665047.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cdream-zs/p/10665047.html</guid>
<description>&lt;blockquote readability=&quot;6.6347826086957&quot;&gt;
&lt;p&gt;本文首发于&lt;a href=&quot;https://icdream.github.io/2019/03/31/thread02/&quot;&gt;cdream&lt;/a&gt;的个人博客，点击获得更好的阅读体验！&lt;/p&gt;
&lt;p&gt;欢迎转载，转载请注明出处。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通常应用多线程技术时，我们并不会直接创建一个线程，因为系统启动一个新线程的成本是比较高的，涉及与操作系统的交互，而是使用线程池来对线程进行管理，尤其是有很多生命周期很短的线程，线程池会显著提升多线程程序的性能。&lt;/p&gt;
&lt;p&gt;本文主要对线程池的源码进行分析，了解了源码，我们才能够更高效的使用线程池，同时出现异常时也能更容易的进行排查。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tNc79ly1g1tvwbua5yj315i0pawh6.jpg&quot; alt=&quot;image-20190407105748909&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1.阅读本文时，务必开启IDE&lt;br/&gt;2.本文篇幅较大，可根据需要跳转到需要的章节阅读&lt;/p&gt;
&lt;h2 id=&quot;一线程池的继承关系及接口方法&quot;&gt;一、线程池的继承关系及接口方法&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/006tKfTcly1g1m61isj1fj30r20lqdh6.jpg&quot; alt=&quot;image-20190331184421413&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;executor是最基础的执行接口&quot;&gt;Executor：是最基础的执行接口；&lt;/h5&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;void execute(Runnable command);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;仅提供一个执行线程使用的方法。这个线程会在未来一段时间进行执行，这个任务可能会执行in a new thread,in a pooled thread,or in the calling thread，和具体的实现相关。&lt;/p&gt;
&lt;h5 id=&quot;executorservice继承了executor并提供了shutdownsubmit等方法可以说是真正的线程池接口&quot;&gt;ExecutorService：继承了Executor，并提供了shutdown()、submit()等方法，可以说是真正的线程池接口；&lt;/h5&gt;
&lt;p&gt;与shutdown相关的方法&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 对之前提交的任务进行一次有顺序的关闭，并且不会接受新的任务，如果已经关闭继续执行不会有额外影响。
 * 这个方法不会等待之前提交的任务执行完毕。
 */
void shutdown();
 
/**
 * 尝试停止所有正在执行的任务，暂停处理正在等待的任务，返回等待执行的任务集合
 * 这个方法不会等待正在执行的任务终止
 * 本方法不提供担保，任务的fail response都可能不会终止
 */
List&amp;lt;Runnable&amp;gt; shutdownNow();
 
/**
 * 判断executor是否被关闭
 * 如果已经被shutdown，返回true
 */
boolean isShutdown();
 
/**
 * 判断用用shutdown/shutdownNow后是否所有的任务都被结束。
 * 如果所有任务都已经被终止，返回true
 * 是否为终止状态
 */
boolean isTerminated();
 
/**
 * 在一个shutdown请求后，阻塞等待所有任务执行完毕
 * 或者到达超时时间，或者当前线程被中断
 */
boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;与submit相关的方法&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 提交一个可执行的（Runnable）任务，返回一个Future代表这个任务执行状态
 * 等到任务成功执行，Future#get()方法会返回null
 */
Future&amp;lt;?&amp;gt; submit(Runnable task);

/**
 * 提交一个可以执行的任务，返回一个Future代表这个任务执行状态
 * 等到任务执行结束，Future#get()方法会返回这个给定的result
 */
&amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt; submit(Runnable task, T result);
 
/**
 * 提交一个有返回值的任务，并返回一个Future代表等待的任务执行的结果
 * 等到任务成功执行，Future#get()方法会返回任务执行的结果
 */
&amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt; submit(Callable&amp;lt;T&amp;gt; task);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;与invoke相关的方法&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 执行给定任务，当所有任务完成后返回一个List&amp;lt;Futrue&amp;lt;T&amp;gt;&amp;gt;列表，持有任务执行的结果与状态
 */
&amp;lt;T&amp;gt; List&amp;lt;Future&amp;lt;T&amp;gt;&amp;gt; invokeAll(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt; tasks)
    throws InterruptedException;
/**
 * 执行给定任务，当所有任务完成或超时后返回一个List&amp;lt;Futrue&amp;lt;T&amp;gt;&amp;gt;列表，持有任务执行的结果与状态
 * 如果超时会取消其他未执行完成的任务
 */
&amp;lt;T&amp;gt; List&amp;lt;Future&amp;lt;T&amp;gt;&amp;gt; invokeAll(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt; tasks,
                              long timeout, TimeUnit unit)
    throws InterruptedException;
/**
 * 执行给定任务，有一个任务完成后，无论异常还是正常
 * 返回一个Futrue&amp;lt;T&amp;gt;，持有任务执行的结果与状态
 */
&amp;lt;T&amp;gt; T invokeAny(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt; tasks)
    throws InterruptedException, ExecutionException;
/**
 * 执行给定任务，有一个任务完成或超时，无论异常还是正常
 * 返回一个Futrue&amp;lt;T&amp;gt;，持有任务执行的结果与状态
 * 超时取消正在执行的任务
 */
&amp;lt;T&amp;gt; T invokeAny(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt; tasks,
                long timeout, TimeUnit unit)
    throws InterruptedException, ExecutionException, TimeoutException;&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;abstractexecutorservice对excutorservice中的大多数方法做了基本实现&quot;&gt;AbstractExecutorService：对ExcutorService中的大多数方法做了基本实现；&lt;/h5&gt;
&lt;h5 id=&quot;theadpoolexecutor这个是线程池的具体实现也是我们代码分析的主要部分&quot;&gt;TheadPoolExecutor：这个是线程池的具体实现，也是我们代码分析的主要部分；&lt;/h5&gt;
&lt;h5 id=&quot;scheduledexecutorservice继承了executorservice接口提供与执行周期性任务相关的功能&quot;&gt;ScheduledExecutorService：继承了ExecutorService接口，提供与执行周期性任务相关的功能；&lt;/h5&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 在给定延时后，创建并执行一个一次性的Runnable任务
 * 任务执行完毕后，ScheduledFuture#get()方法会返回null
 */
public ScheduledFuture&amp;lt;?&amp;gt; schedule(Runnable command, long delay, TimeUnit unit);
 
/**
 * 在给定延时后，创建并执行一个ScheduledFutureTask
 * 返回ScheduledFuture 可以获取结果或取消任务
 */
public &amp;lt;V&amp;gt; ScheduledFuture&amp;lt;V&amp;gt; schedule(Callable&amp;lt;V&amp;gt; callable, ong delay, TimeUnit unit);
 
/**
 * 创建并执行一个在给定初始延迟后首次启用的定期操作，后续操作具有给定的周期
 * 也就是将在 initialDelay 后开始执行，然后在 initialDelay+period 后执行，接着在 initialDelay 
 * + 2 * period 后执行，依此类推
 * 如果执行任务发生异常，随后的任务将被禁止，否则任务只会在被取消或者Executor被终止后停止
 * 如果任何执行的任务超过了周期，随后的执行会延时，不会并发执行
 * 例如延时为3s，第2s开始执行任务，下一次执行就会是第5s，下下次就是8s
 */
public ScheduledFuture&amp;lt;?&amp;gt; scheduleAtFixedRate(Runnable command,
                                                  long initialDelay,
                                                  long period,
                                                  TimeUnit unit);
 
/**
 * 创建并执行一个在给定初始延迟后首次启用的定期操作，随后，在每一次执行终止和下一次执行开始之间都存在给
 * 定的延迟
 * 如果执行任务发生异常，随后的任务将被禁止，否则任务只会在被取消或者Executor被终止后停止
 * 例如延时为3s，任务执行4s，第2s开始执行任务，下一次执行任务就是9s，下下次就是16s
 */
public ScheduledFuture&amp;lt;?&amp;gt; scheduleWithFixedDelay(Runnable command,
                                                     long initialDelay,
                                                     long delay,
                                                     TimeUnit unit);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;scheduledthreadpoolexecutor是可以执行周期性任务的线程池的具体实现&quot;&gt;ScheduledThreadPoolExecutor：是可以执行周期性任务的线程池的具体实现;&lt;/h5&gt;
&lt;h2 id=&quot;二threadpoolexecutor分析&quot;&gt;二、ThreadPoolExecutor分析&lt;/h2&gt;
&lt;h3 id=&quot;构造函数及参数含义&quot;&gt;构造函数及参数含义&lt;/h3&gt;
&lt;p&gt;ThreadPoolExecutor提供四个构造函数，但其他三个都是基于下面这构造函数&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue&amp;lt;Runnable&amp;gt; workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler) {}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数含义：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;corePoolSize&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;线程池中的核心线程数量，当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于corePoolSize，即使有其他空闲线程能执行新来的任务，也会继续创建新的线程；&lt;/li&gt;
&lt;li&gt;如果当前线程数为corePoolSize，继续提交的任务被保存到阻塞队列中，等待被执行；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;maximumPoolSize&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;线程池允许线程的最大数量，在阻塞队列被填满后，会创建新的线程执行任务，前提是当前线程数小于maximumPoolSize&lt;/li&gt;
&lt;li&gt;当workQueue为无界队列时，maxiumPoolSize则不会起作用，因为新的任务会一直放入到workQueue中&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;workQueue&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;线程存活时间，当线程没有任务执行时，继续存活的时间，默认情况只对线程数大于corePoolSize是有用。&lt;/li&gt;
&lt;li&gt;阻塞队列的选择
&lt;ul&gt;&lt;li&gt;ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序，指定队列的最大长度，使用有界队列可以防止资源耗尽，但会出现任务过多时的拒绝问题，需要进行协调。&lt;/li&gt;
&lt;li&gt;LinkedBlockingQueue：一个基于链表结构的有界阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。&lt;/li&gt;
&lt;li&gt;SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。&lt;/li&gt;
&lt;li&gt;PriorityBlockingQueue：一个具有优先级的无限阻塞队列。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;keepAliveTime&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;线程空闲时的存活时间，默认情况下，该参数只在线程数大于corePoolSize时才有用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TimeUnit&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;keepAliveTime的单位&lt;/li&gt;
&lt;li&gt;TimeUnit静态类提供常量&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;threadFactory&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;创建线程的工厂，通过自定义的线程工厂可以给每个新建的线程设置一个具有识别度的线程名。默认为DefaultThreadFactory，自定义可以实现ThreadFactory接口&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;handler&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;线程池的饱和策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务&lt;/li&gt;
&lt;li&gt;线程池提供如下四种策略
&lt;ul&gt;&lt;li&gt;AbortPolicy：直接抛出异常，默认策略&lt;/li&gt;
&lt;li&gt;CallerRunsPolicy：用调用者所在的线程来执行任务&lt;/li&gt;
&lt;li&gt;DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务&lt;/li&gt;
&lt;li&gt;DiscardPolicy：直接丢弃任务&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;可以根据具体使用场景，实现RejectedExecutionHandler接口，自定义拒绝策略&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;线程池的执行流程&quot;&gt;线程池的执行流程&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;如果当前worker数量小于corePoolSize，则新建一个woker并把当前任务分配给该woker线程&lt;/li&gt;
&lt;li&gt;如果当前worker数量大于corePoolSize，则会将任务加入到workerQueue中&lt;/li&gt;
&lt;li&gt;如果wokerQueue是有界队列，并且已经填满，则会判断当前woker数量小于maximumPoolSize，如果小于，则新建一个woker并把当前任务分配给该woker线程，成功则返回。&lt;/li&gt;
&lt;li&gt;当worker的数量已经等于maximumPoolSize则调用拒绝策略处理该任务。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tKfTcly1g1oohac29uj30yq092q7o.jpg&quot; alt=&quot;image-20190402225324214&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外，当线程池中线程大于corePoolSize，并且空闲时间超过keepAliveTime时，将会被移出线程池。&lt;/p&gt;
&lt;h3 id=&quot;源码分析&quot;&gt;源码分析&lt;/h3&gt;
&lt;h4 id=&quot;线程池的状态&quot;&gt;线程池的状态&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// ct1是一个原子整数型，其中打包了两个概念概念
// 其中高3位是维护线程池的运行状态，低29位是用来位置线程池中线程的数量
// 3位的原因是因为线程有五种状态，向上取2次方数是8也就是3位
private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
// 这个是29，做位运算用的
private static final int COUNT_BITS = Integer.SIZE - 3;
// 这个是线程的容量，也就是低29位的最大值
private static final int CAPACITY   = (1 &amp;lt;&amp;lt; COUNT_BITS) - 1;

// runState is stored in the high-order bits
// 高3位分别是100-&amp;gt;000-&amp;gt;001-&amp;gt;010-&amp;gt;011
// 注意高1位是符号位，低29位都是0
private static final int RUNNING    = -1 &amp;lt;&amp;lt; COUNT_BITS;
private static final int SHUTDOWN   =  0 &amp;lt;&amp;lt; COUNT_BITS;
private static final int STOP       =  1 &amp;lt;&amp;lt; COUNT_BITS;
private static final int TIDYING    =  2 &amp;lt;&amp;lt; COUNT_BITS;
private static final int TERMINATED =  3 &amp;lt;&amp;lt; COUNT_BITS;

// Packing and unpacking ctl
// 当与~Capcity做且运算时获得的是高3位的值，也就是线程池的状态
private static int runStateOf(int c)     { return c &amp;amp; ~CAPACITY; }
// 这里可以看下图的情况，当与Capacity做且运算时获得的是低29位的值，也就是运行的线程的数量
private static int workerCountOf(int c)  { return c &amp;amp; CAPACITY; }
// 将线程池状态和运行的线程数量进行打包
private static int ctlOf(int rs, int wc) { return rs | wc; }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tNc79ly1g1refmrsaaj30yu0hatj2.jpg&quot; alt=&quot;image-20190405072232285&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这张图我只做了一个16位的情况，前两个是补码和非运算后的数据，下面四个是一次简单的绩过程。&lt;/p&gt;

&lt;h4 id=&quot;构造方法&quot;&gt;构造方法&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue&amp;lt;Runnable&amp;gt; workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler) {
    // 参数出校验，出现异常抛出参数非法异常
    if (corePoolSize &amp;lt; 0 ||
        maximumPoolSize &amp;lt;= 0 ||
        maximumPoolSize &amp;lt; corePoolSize ||
        keepAliveTime &amp;lt; 0)
        throw new IllegalArgumentException();
    // 几个引用类型的非空检验，空了抛出空指针异常
    if (workQueue == null || threadFactory == null || handler == null)
        throw new NullPointerException();
    // 在执行finalize()方法时使用，并不影响对线程池的理解
    this.acc = System.getSecurityManager() == null ?
            null :
            AccessController.getContext();
    // 将传递的参数复值给实例变量
    this.corePoolSize = corePoolSize;
    this.maximumPoolSize = maximumPoolSize;
    this.workQueue = workQueue;
    this.keepAliveTime = unit.toNanos(keepAliveTime);
    this.threadFactory = threadFactory;
    this.handler = handler;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;execute方法&quot;&gt;execute方法&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 本方法就是上述线程池执行流程的代码形式
public void execute(Runnable command) {
    if (command == null)
        throw new NullPointerException();
    // 获取控制变量的值c
    int c = ctl.get();
    // 如果活跃线程数量小于corePoolSize数量，调用addWorker方法，创建线程执行任务
    if (workerCountOf(c) &amp;lt; corePoolSize) {
        // 如果成功了，直接返回，ture是
        if (addWorker(command, true))
            return;
        // 否则获取控制变量c,进行下一步操作，凡是需要使用ctl进行判断都要重新获取c
        c = ctl.get();
    }
    // 判断线程池是否处于Running状态并且顺利将任务加入到阻塞队列中
    // 如果加入顺利仍要进行double-check是否需要加入一个新的线程或任务进入这个方式时线程池已经关闭
    if (isRunning(c) &amp;amp;&amp;amp; workQueue.offer(command)) {
        int recheck = ctl.get();
        /** 
         * 如果线程池不是运行状态并且将任务移除成功，拒绝任务
         * 如果线程池是运行状态或任务移除失败，判断是否有活跃线程，如果没有就创建一个
         */
        if (! isRunning(recheck) &amp;amp;&amp;amp; remove(command))
            // 拒绝命令
            reject(command);
       //这里是添加了一个任务为null的线程，只要有一个线程就可出执行workQueue中的命令
        else if (workerCountOf(recheck) == 0)
            addWorker(null, false);
    }
    // 如果向队列添加失败，尝试扩充线程池，将任务分配给新的线程，只要不大于maximumPoolSize就可以。
    else if (!addWorker(command, false))
        // 拒绝命令
        reject(command);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;addworker方法&quot;&gt;addWorker方法&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; private boolean addWorker(Runnable firstTask, boolean core) {
        // 外层循环用于判断线程池状态
        retry:
        for (;;) {
            int c = ctl.get();
            int rs = runStateOf(c);

            // 这个判断条件比较复杂，看下面的分析
            // 概括一下就是当前线程池是否是可添加新线程的状态
            if (rs &amp;gt;= SHUTDOWN &amp;amp;&amp;amp;
                ! (rs == SHUTDOWN &amp;amp;&amp;amp;
                   firstTask == null &amp;amp;&amp;amp;
                   ! workQueue.isEmpty()))
                return false;
            // 内存循环对线程数量进行cas+1处理
            for (;;) {
                int wc = workerCountOf(c);
                // 这里是判断一下工作线程数量是不是已经大于等于corePoolSize/maximumPoolSize
                // addWorked参数里的true/false就是决定比corePoolSize还是maximumPoolSize
                if (wc &amp;gt;= CAPACITY ||
                    wc &amp;gt;= (core ? corePoolSize : maximumPoolSize))
                    return false;
                // 这里添加一个线程，成功就跳出循环
                if (compareAndIncrementWorkerCount(c))
                    break retry;
                c = ctl.get();  // Re-read ctl
                // 添加失败就重试
                if (runStateOf(c) != rs)
                    continue retry;
                // else CAS failed due to workerCount change; retry inner loop
            }
        }
     
    // ------上面的循环是调整线程池状态，下面是真正的添加线程--------
        // work启动标志
        boolean workerStarted = false;
        // work是否被添加到线程池中的标志
        boolean workerAdded = false;
        Worker w = null;
        try {
            // 新建worker将传入的任务赋值给worker的
            w = new Worker(firstTask);
            final Thread t = w.thread;
            // 如果线程创建成功
            if (t != null) {
                // 获取锁
                final ReentrantLock mainLock = this.mainLock;
                mainLock.lock();
                try {
                    // 检查是否为可以添加线程的状态，如果是运行状态
                    // 或者shutdown，但队列中有任务(注意这里是创建线程，不是添加任务)
                    int rs = runStateOf(ctl.get());
                    if (rs &amp;lt; SHUTDOWN ||
                        (rs == SHUTDOWN &amp;amp;&amp;amp; firstTask == null)) {
                        // 如果线程已运行，抛出异常并执行addWorkerFailed
                        if (t.isAlive()) 
                            throw new IllegalThreadStateException();
                        // 这里将新建的work加入到set中，workers是维护线程池中所有线程的hashSet
                        // 并更新相关状态
                        workers.add(w);
                        int s = workers.size();
                        if (s &amp;gt; largestPoolSize)
                            largestPoolSize = s;
                        workerAdded = true;
                    }
                } finally {
                    // 处理完成后释放锁
                    mainLock.unlock();
                }
                // 添加成功线程
                if (workerAdded) {
                    t.start();
                    workerStarted = true;
                }
            }
        } finally {
            // 如果处理启动失败就会将失败的线程从worker中移除
            if (! workerStarted)
                addWorkerFailed(w);
        }
        return workerStarted;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;return false的条件分析&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;code&gt;rs &amp;gt;= SHUTDOWN &amp;amp;&amp;amp;! (rs == SHUTDOWN &amp;amp;&amp;amp;firstTask == null &amp;amp;&amp;amp;! workQueue.isEmpty())&lt;/code&gt;如何成立&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;线程池至少是&lt;code&gt;SHUTDOWN&lt;/code&gt;状态,&lt;code&gt;rs&amp;gt;=SHUTDOWN&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;下面三个条件至少有一个是不成立的&lt;br/&gt;&lt;code&gt;rs == SHUTDOWN &amp;amp;&amp;amp;firstTask == null &amp;amp;&amp;amp;! workQueue.isEmpty()&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;rs == SHUTDOWN&lt;/code&gt; 前提条件&lt;code&gt;（rs&amp;gt;=SHUTDOWN）&lt;/code&gt; --&amp;gt; false &lt;code&gt;rs&amp;gt;SHUTDOWN&lt;/code&gt;&lt;br/&gt;​ 这种情况是线程池已经处于&lt;code&gt;STOP、TYDING、TERMINATED&lt;/code&gt;状态&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;firstTask == null&lt;/code&gt; 前提条件 &lt;code&gt;rs== SHUTDOWN&lt;/code&gt; --&amp;gt;false &lt;code&gt;firstTask!=null&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;​ 这种情况是线程池处于&lt;code&gt;SHUTDOWN&lt;/code&gt;状态，线程池已经不接收新的任务了&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;code&gt;! workQueue.isEmpty()&lt;/code&gt; 前提条件 &lt;code&gt;rs==SHUTDOWN &amp;amp;&amp;amp; firstTask==null&lt;/code&gt; --&amp;gt;false&lt;/p&gt;
&lt;p&gt;​ 这种情况是线程池处于&lt;code&gt;SHUTDWON&lt;/code&gt;状态，并且新来的任务为null，没必要新开线程&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;本方法的几种形式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、addWorker(command, true)&lt;/p&gt;
&lt;p&gt;2、addWorker(command, false)&lt;/p&gt;
&lt;p&gt;3、addWorker(null, false)&lt;/p&gt;
&lt;p&gt;4、addWorker(null, true)&lt;/p&gt;
&lt;p&gt;在execute方法中就使用了前3种&lt;br/&gt;​ 第一个：线程数小于corePoolSize时，放一个需要处理的task进Workers Set。如果Workers Set长度超过corePoolSize，就返回false&lt;br/&gt;​ 第二个：当队列被放满时，就尝试将这个新来的task直接放入Workers Set，而此时Workers Set的长度限制是maximumPoolSize。如果线程池也满了的话就返回false&lt;br/&gt;​ 第三个：放入一个空的task进workers Set，长度限制是maximumPoolSize。这样一个task为空的worker在线程执行的时候会去任务队列里拿任务，这样就相当于创建了一个新的线程，只是没有马上分配任务&lt;br/&gt;​ 第四个：这个方法就是放一个null的task进Workers Set，而且是在小于corePoolSize时，如果此时Set中的数量已经达到corePoolSize那就返回false，什么也不干。实际使用中是在prestartAllCoreThreads()方法，这个方法用来为线程池预先启动corePoolSize个worker等待从workQueue中获取任务执行&lt;/p&gt;
&lt;h4 id=&quot;worker类&quot;&gt;Worker类&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * Worker类主要是有两个作用，启动线程、管理线程的中断状态
 * Worker类通过继承AQS来实现了一个不可重入的锁，为了确保Worker在执行后在被中断
 */
private final class Worker
    extends AbstractQueuedSynchronizer
    implements Runnable
{
    private static final long serialVersionUID = 6138294804551838833L;

    final Thread thread;
    Runnable firstTask;
    // 之前完成的Task数量
    volatile long completedTasks;

    // 构造方法，重点是将state设置为-1，避免了在runWorker执行之前线程被interrupt
    Worker(Runnable firstTask) {
        setState(-1); // inhibit interrupts until runWorker
        this.firstTask = firstTask;
        this.thread = getThreadFactory().newThread(this);
    }
    // 启动线程执行任务使用
    public void run() {
        runWorker(this);
    }
    // 是否持有独占锁，如果state=0是未加锁状态，其他为加锁状态
    protected boolean isHeldExclusively() {
        return getState() != 0;
    }
    // 尝试获取锁，是对AQS中的方法的实现,这里在获取锁时与0对比，所以在runWorker之前是无法获取锁的
    protected boolean tryAcquire(int unused) {
        if (compareAndSetState(0, 1)) {
            setExclusiveOwnerThread(Thread.currentThread());
            return true;
        }
        return false;
    }
    // 尝试释放锁，对AQS中方法的实现
    protected boolean tryRelease(int unused) {
        setExclusiveOwnerThread(null);
        setState(0);
        return true;
    }

    public void lock()        { acquire(1); }
    public boolean tryLock()  { return tryAcquire(1); }
    public void unlock()      { release(1); }
    public boolean isLocked() { return isHeldExclusively(); }
    // 这里就能看出在state=-1的状态是不能interrput,只有调用runWorker方法后会将状态置为1
    void interruptIfStarted() {
        Thread t;
        if (getState() &amp;gt;= 0 &amp;amp;&amp;amp; (t = thread) != null &amp;amp;&amp;amp; !t.isInterrupted()) {
            try {
                t.interrupt();
            } catch (SecurityException ignore) {
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;之所以要在Runnable外面包一层Worker是为了通过Worker来控制中断，而Runnable只需要执行业务逻辑就可以了。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里我也有一疑问，为什么不允许Worker在runWorker前就被中止呢？为什么呢？&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;runworker方法&quot;&gt;runWorker方法&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;final void runWorker(Worker w) {
    Thread wt = Thread.currentThread();
    Runnable task = w.firstTask;
    w.firstTask = null;
    w.unlock(); // allow interrupts
    boolean completedAbruptly = true;
    try {
        while (task != null || (task = getTask()) != null) {
            w.lock();
            // 确保线程在stopping时被设置中断标志，否则清除中断标志
            // 1.如果线程池处于STOP状态，并且当前线程并不是中断状态，调用wt.interrupt确保线程中断
            // 2.如果线程池不是STOP状态，但Thread.interrupted()返回是true
            // [表示当前线程是中断状态，并且清除了中断标志] 然后再次判断线程池状态是否是STOP状态
            // 如果是就再次调用wt.interrupt确保线程中断
            if ((runStateAtLeast(ctl.get(), STOP) ||
                 (Thread.interrupted() &amp;amp;&amp;amp;
                  runStateAtLeast(ctl.get(), STOP))) &amp;amp;&amp;amp;
                !wt.isInterrupted())
                wt.interrupt();
            try {
                // 本类中是空实现，子类有需要可依据情况实现，Tomcat中的线程池就重写了该方法
                beforeExecute(wt, task);
                Throwable thrown = null;
                try {
                    // 执行任务
                    task.run();
                } catch (RuntimeException x) {
                    thrown = x; throw x;
                } catch (Error x) {
                    thrown = x; throw x;
                } catch (Throwable x) {
                    thrown = x; throw new Error(x);
                } finally {
                    afterExecute(task, thrown);
                }
            } finally {
                task = null;
                // 完成任务+1
                w.completedTasks++;
                // 释放锁
                w.unlock();
            }
        }
        completedAbruptly = false;
    } finally {
        processWorkerExit(w, completedAbruptly);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;本方法先是使线程进入执行状态，并且可以进行中断，然后循环执行任务，直到getTask()获取不到任务则进行退出。&lt;/p&gt;
&lt;h4 id=&quot;gettask方法&quot;&gt;getTask方法&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private Runnable getTask() {
    boolean timedOut = false; // Did the last poll() time out?

    for (;;) {
        int c = ctl.get();
        int rs = runStateOf(c);

        // 两种可能减少工作线程的数量
        // 1.线程池处于STOP以上的状态
        // 2.线程池处于SHUTDOWN状态，但时阻塞队列为空
        if (rs &amp;gt;= SHUTDOWN &amp;amp;&amp;amp; (rs &amp;gt;= STOP || workQueue.isEmpty())) {
            decrementWorkerCount();
            return null;
        }

        int wc = workerCountOf(c);

        // allowCoreThreadTimeOut默认为false
        // 如果allowCoreThreadTimeOut为true，说明后面的执行的任务一定要需要定时
        // 活跃线程数量是否已经大于corePoolSize，也需要定时
        boolean timed = allowCoreThreadTimeOut || wc &amp;gt; corePoolSize;
        // 1. 活跃线程&amp;gt;线程池最大线程的情况下
        //    或者上一次提交任务超时并且timed为true时
        // 2. wc&amp;gt;1或阻塞队列为空，减少线程，返回null
        if ((wc &amp;gt; maximumPoolSize || (timed &amp;amp;&amp;amp; timedOut))
            &amp;amp;&amp;amp; (wc &amp;gt; 1 || workQueue.isEmpty())) {
            if (compareAndDecrementWorkerCount(c))
                return null;
            // 减少线程失败
            continue;
        }

        try {
            // 获取阻塞队列中的任务
            Runnable r = timed ?
                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
                workQueue.take();
            if (r != null)
                return r;
            timedOut = true;
        } catch (InterruptedException retry) {
            timedOut = false;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;本方法主要是从阻塞队列中获取任务，在以下状态时会返回null:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;超过了maximumPoolSize设置的线程数量;&lt;/li&gt;
&lt;li&gt;线程池被stop&lt;/li&gt;
&lt;li&gt;线程池被shutdown，并且workQueue空了&lt;/li&gt;
&lt;li&gt;线程等待任务超时&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;processworkerexit&quot;&gt;processWorkerExit&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private void processWorkerExit(Worker w, boolean completedAbruptly) {
    /**
     * 1、worker数量-1
     * 如果是突然终止，说明是task执行时异常情况导致
     * 即run()方法执行时发生了异常，那么正在工作的worker线程数量需要-1
     * 如果不是突然终止，说明是worker线程没有task可执行了
     * 不用-1，因为已经在getTask()方法中-1了
     */
    if (completedAbruptly) 
        decrementWorkerCount();
    /**
     * 2、从Workers Set中移除worker
     */
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        completedTaskCount += w.completedTasks; //把worker的完成任务数加到线程池的完成任务数
        workers.remove(w); //从HashSet&amp;lt;Worker&amp;gt;中移除
    } finally {
        mainLock.unlock();
    }
 
    /**
     * 3、在对线程池有负效益的操作时，都需要“尝试终止”线程池
     * 主要是判断线程池是否满足终止的状态
     * 如果状态满足，但还有线程池还有线程，尝试对其发出中断响应，使其能进入退出流程
     * 没有线程了，更新状态为tidying-&amp;gt;terminated
     */
    tryTerminate();
 
    /**
     * 4、是否需要增加worker线程
     * 线程池状态是running 或 shutdown
     * 如果当前线程是突然终止的，addWorker()
     * 如果当前线程不是突然终止的，但当前线程数量 &amp;lt; 要维护的线程数量，addWorker()
     * 故如果调用线程池shutdown()，直到workQueue为空前，
     * 线程池都会维持corePoolSize个线程，然后再逐渐销毁这corePoolSize个线程
     */
    int c = ctl.get();
    // 如果状态是running、shutdown
    // 即tryTerminate()没有成功终止线程池，尝试再添加一个worker
    if (runStateLessThan(c, STOP)) {
        // 不是突然完成的，即没有task任务可以获取而完成的，
        // 计算min，并根据当前worker数量判断是否需要addWorker()
        if (!completedAbruptly) {
            //allowCoreThreadTimeOut默认为false，即min默认为corePoolSize
            int min = allowCoreThreadTimeOut ? 0 : corePoolSize; 
            
             
            //如果min为0，即不需要维持核心线程数量，且workQueue不为空，至少保持一个线程
            if (min == 0 &amp;amp;&amp;amp; ! workQueue.isEmpty())
                min = 1;
             
            //如果线程数量大于最少数量，直接返回，否则下面至少要addWorker一个
            if (workerCountOf(c) &amp;gt;= min)
                return; // replacement not needed
        }
         
        // 添加一个没有firstTask的worker
        // 只要worker是completedAbruptly突然终止的
        // 或者线程数量小于要维护的数量，就新添一个worker线程，即使是shutdown状态
        addWorker(null, false);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;三总结&quot;&gt;三、总结&lt;/h2&gt;
&lt;p&gt;线程池需要说的东西很多，本文分为两个部分，第一部分是描述线程池的继承关系，第二部分ThreadPoolExecutor源码分析，原理上线程池并没有像HashMap源码那么复杂，重要的是在方法中不断的进行判断线池状态容易让人产生疑惑，本文根据情况选择需要的阅读部分~&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/keeya/p/9361316.html&quot;&gt;吃透线程池源码&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/qingquanzi/p/8146638.html&quot;&gt;线程池的工作原理与源码解读&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/trust-freedom/p/6594270.html&quot;&gt;Java线程池ThreadPoolExecutor使用和分析(一)&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;em&gt;注：这里强烈推荐参考资料3，非常完成的线程池分析&lt;/em&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 07 Apr 2019 05:24:00 +0000</pubDate>
<dc:creator>cdream</dc:creator>
<og:description>本文首发于 'cdream' 的个人博客，点击获得更好的阅读体验！ 欢迎转载，转载请注明出处。 通常应用多线程技术时，我们并不会直接创建一个线程，因为系统启动一个新线程的成本是比较高的，涉及与操作系统</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cdream-zs/p/10665047.html</dc:identifier>
</item>
<item>
<title>JUC同步器框架AbstractQueuedSynchronizer源码图文分析 - throwable</title>
<link>http://www.cnblogs.com/throwable/p/10664926.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/throwable/p/10664926.html</guid>
<description>&lt;h2 id=&quot;前提&quot;&gt;前提&lt;/h2&gt;
&lt;p&gt;Doug Lea大神在编写JUC(&lt;code&gt;java.util.concurrent&lt;/code&gt;)包的时候引入了&lt;code&gt;java.util.concurrent.locks.AbstractQueuedSynchronizer&lt;/code&gt;，Abstract Queued Synchronizer，也就是&quot;基于队列实现的抽象同步器&quot;，一般我们称之为AQS。其实Doug Lea大神编写AQS是有严谨的理论基础的，他的个人博客上有一篇论文《&lt;a href=&quot;http://gee.cs.oswego.edu/dl/papers/aqs.pdf&quot;&gt;The java.util.concurrent Synchronizer Framework&lt;/a&gt;》，文章在&lt;a href=&quot;http://ifeve.com&quot; class=&quot;uri&quot;&gt;http://ifeve.com&lt;/a&gt;上可以找到相关的译文(《JUC同步器框架》)，如果想要深入研究AQS必须要理解一下该论文的内容，然后详细分析一下AQS的源码实现。本文在阅读AQS源码的时候选用的JDK版本是JDK11。&lt;/p&gt;
&lt;h2 id=&quot;aqs的主要功能&quot;&gt;AQS的主要功能&lt;/h2&gt;
&lt;p&gt;AQS是JUC包中用于构建锁或者其他同步组件(信号量、事件等)的基础框架类。AQS从它的实现上看主要提供了下面的功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;同步状态的原子性管理。&lt;/li&gt;
&lt;li&gt;线程的阻塞和解除阻塞。&lt;/li&gt;
&lt;li&gt;提供阻塞线程的存储队列。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;基于这三大功能，衍生出下面的附加功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通过中断实现的任务取消，基于线程中断实现。&lt;/li&gt;
&lt;li&gt;可选的超时设置，也就是调用者可以选择放弃等待。&lt;/li&gt;
&lt;li&gt;定义了&lt;code&gt;Condition接口&lt;/code&gt;，用于支持管程形式的await/signal/signalAll操作，代替了&lt;code&gt;Object&lt;/code&gt;类基于JNI提供的wait/notify/notifyAll。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;AQS&lt;/code&gt;还根据同步状态的不同管理方式区分为两种不同的实现：&lt;strong&gt;独占状态的同步器&lt;/strong&gt;和&lt;strong&gt;共享状态的同步器&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;juc同步器框架原理&quot;&gt;JUC同步器框架原理&lt;/h2&gt;
&lt;p&gt;《&lt;a href=&quot;http://gee.cs.oswego.edu/dl/papers/aqs.pdf&quot;&gt;The java.util.concurrent Synchronizer Framework&lt;/a&gt;》一文中其实有提及到同步器框架的伪代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// acquire操作如下：
while (synchronization state does not allow acquire) {
    enqueue current thread if not already queued;
    possibly block current thread;
}
dequeue current thread if it was queued;

//release操作如下：
update synchronization state;
if (state may permit a blocked thread to acquire){
    unblock one or more queued threads;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;翻译一下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// acquire操作如下：
while(同步状态申请获取失败){
    if(当前线程未进入等待队列){
        当前线程放入等待队列;
    }
    尝试阻塞当前线程;
}
当前线程移出等待队列

//release操作如下：
更新同步状态
if(同步状态足够允许一个阻塞的线程申请获取){
    解除一个或者多个等待队列中的线程的阻塞状态;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了实现上述操作，需要下面三个基本组件的相互协作：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;同步状态的原子性管理。&lt;/li&gt;
&lt;li&gt;等待队列的管理。&lt;/li&gt;
&lt;li&gt;线程的阻塞与解除阻塞。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其实基本原理很简单，但是为了应对复杂的并发场景和并发场景下程序执行的正确性，同步器框架在上面的acquire操作和release操作中使用了死循环和CAS等操作，很多时候会让人感觉逻辑过于复杂。&lt;/p&gt;
&lt;h3 id=&quot;同步状态管理&quot;&gt;同步状态管理&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;AQS&lt;/code&gt;内部内部定义了一个32位整型的state变量用于保存同步状态：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * The synchronization state.
 */
private volatile int state;

// 获取state
protected final int getState() {
    return state;
}

// 直接覆盖设置state
protected final void setState(int newState) {
    state = newState;
}

// CAS设置state
protected final boolean compareAndSetState(int expect, int update) {
    return STATE.compareAndSet(this, expect, update);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同步状态state在不同的实现中可以有不同的作用或者表示意义，它可以代表资源数、锁状态等等，遇到具体的场景我们再分析它表示的意义。&lt;/p&gt;
&lt;h3 id=&quot;clh队列变体&quot;&gt;CLH队列变体&lt;/h3&gt;
&lt;p&gt;CLH锁即Craig, Landin, and Hagersten (CLH) locks，因为它底层是基于队列实现，一般也称为CLH队列锁。CLH锁也是一种基于链表的可扩展、高性能、公平的自旋锁，申请线程仅仅在本地变量上自旋，它不断轮询前驱的状态，假设发现前驱释放了锁就结束自旋。从实现上看，CLH锁是一种自旋锁，能确保无饥饿性，提供先来先服务的公平性。先看简单的CLH锁的一个简单实现：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class CLHLock implements Lock {

    AtomicReference&amp;lt;QueueNode&amp;gt; tail = new AtomicReference&amp;lt;&amp;gt;(new QueueNode());

    ThreadLocal&amp;lt;QueueNode&amp;gt; pred;
    ThreadLocal&amp;lt;QueueNode&amp;gt; current;

    public CLHLock() {
        current = ThreadLocal.withInitial(QueueNode::new);
        pred = ThreadLocal.withInitial(() -&amp;gt; null);
    }

    @Override
    public void lock() {
        QueueNode node = current.get();
        node.locked = true;
        QueueNode pred = tail.getAndSet(node);
        this.pred.set(pred);
        while (pred.locked) {
        }
    }

    @Override
    public void unlock() {
        QueueNode node = current.get();
        node.locked = false;
        current.set(this.pred.get());
    }

    static class QueueNode {

        boolean locked;
    }

    // 忽略其他接口方法的实现
}   &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面是一个简单的CLH队列锁的实现，内部类&lt;code&gt;QueueNode&lt;/code&gt;只使用了一个简单的布尔值locked属性记录了每个线程的状态，如果该属性为true，则相应的线程要么已经获取到锁，要么正在等待锁，如果该属性为false，则相应的线程已经释放了锁。新来的想要获取锁的线程必须对tail属性调用&lt;code&gt;getAndSet()&lt;/code&gt;方法，使得自身成为队列的尾部，同时得到一个指向前驱节点的引用pred，最后线程所在节点在其前驱节点的locked属性上自旋，值得前驱节点释放锁。上面的实现是无法运行的，因为一旦自旋就会进入死循环导致CPU飙升，可以尝试使用下面将要提到的&lt;code&gt;LockSupport&lt;/code&gt;进行改造。&lt;/p&gt;
&lt;p&gt;CLH队列锁本质是使用队列(实际上是单向链表)存放等待获取锁的线程，等待的线程总是在其所在节点的前驱节点的状态上自旋，直到前驱节点释放资源。&lt;strong&gt;从实际来看，过度自旋带来的CPU性能损耗比较大，并不是理想的线程等待队列实现&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;基于原始的CLH队列锁中提供的等待队列的基本原理，&lt;strong&gt;&lt;code&gt;AQS&lt;/code&gt;实现一种了CLH锁队列的变体(variant)&lt;/strong&gt;。&lt;code&gt;AQS&lt;/code&gt;类的protected修饰的构造函数里面有一大段注释用于说明&lt;code&gt;AQS&lt;/code&gt;实现的等待队列的细节事项，这里列举几点重要的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;AQS&lt;/code&gt;实现的等待队列没有直接使用CLH锁队列，但是参考了其设计思路，等待节点会保存前驱节点中线程的信息，内部也会维护一个控制线程阻塞的状态值。&lt;/li&gt;
&lt;li&gt;每个节点都设计为一个持有单独的等待线程并且&quot;带有具体的通知方式&quot;的监视器，这里所谓通知方式就是自定义唤醒阻塞线程的方式而已。&lt;/li&gt;
&lt;li&gt;一个线程是等待队列中的第一个等待节点的持有线程会尝试获取锁，但是并不意味着它一定能够获取锁成功(这里的意思是存在公平和非公平的实现)，获取失败就要重新等待。&lt;/li&gt;
&lt;li&gt;等待队列中的节点通过prev属性连接前驱节点，通过next属性连接后继节点，简单来说，就是双向链表的设计。&lt;/li&gt;
&lt;li&gt;CLH队列本应该需要一个虚拟的头节点，但是在&lt;code&gt;AQS&lt;/code&gt;中没有直接提供虚拟的头节点，而是延迟到第一次竞争出现的时候懒创建虚拟的头节点(其实也会创建尾节点，初始化时头尾节点是同一个节点)。&lt;/li&gt;
&lt;li&gt;Condition(条件)等待队列中的阻塞线程使用的是相同的&lt;code&gt;Node&lt;/code&gt;结构，但是提供了另一个链表用来存放，Condition等待队列的实现比非Condition等待队列复杂。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;线程阻塞与唤醒&quot;&gt;线程阻塞与唤醒&lt;/h3&gt;
&lt;p&gt;线程的阻塞和唤醒在JDK1.5之前，一般只能依赖于&lt;code&gt;Object&lt;/code&gt;类提供的&lt;code&gt;wait()&lt;/code&gt;、&lt;code&gt;notify()&lt;/code&gt;和&lt;code&gt;notifyAll()&lt;/code&gt;方法，它们都是JNI方法，由JVM提供实现，并且它们必须运行在获取监视器锁的代码块内(&lt;code&gt;synchronized&lt;/code&gt;代码块中)，这个局限性先不谈性能上的问题，代码的简洁性和灵活性是比较低的。JDK1.5引入了&lt;code&gt;LockSupport&lt;/code&gt;类，底层是基于&lt;code&gt;Unsafe&lt;/code&gt;类的&lt;code&gt;park()&lt;/code&gt;和&lt;code&gt;unpark()&lt;/code&gt;方法，提供了线程阻塞和唤醒的功能，它的机制有点像只有一个允许使用资源的信号量&lt;code&gt;java.util.concurrent.Semaphore&lt;/code&gt;，也就是一个线程只能通过&lt;code&gt;park()&lt;/code&gt;方法阻塞一次，只能调用&lt;code&gt;unpark()&lt;/code&gt;方法解除调用阻塞一次，线程就会唤醒(多次调用&lt;code&gt;unpark()&lt;/code&gt;方法也只会唤醒一次)，可以想象是内部维护了一个0-1的计数器。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;LockSupport&lt;/code&gt;类如果使用得好，可以提供更灵活的编码方式，这里举个简单的使用例子：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class LockSupportMain implements Runnable {

    private static final DateTimeFormatter FORMATTER = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;);

    private Thread thread;

    private void setThread(Thread thread) {
        this.thread = thread;
    }

    public static void main(String[] args) throws Exception {
        LockSupportMain main = new LockSupportMain();
        Thread thread = new Thread(main, &quot;LockSupportMain&quot;);
        main.setThread(thread);
        thread.start();
        Thread.sleep(2000);
        main.unpark();
        Thread.sleep(2000);
    }

    @Override
    public void run() {
        System.out.println(String.format(&quot;%s-步入run方法,线程名称:%s&quot;, FORMATTER.format(LocalDateTime.now()),
                Thread.currentThread().getName()));
        LockSupport.park();
        System.out.println(String.format(&quot;%s-解除阻塞,线程继续执行,线程名称:%s&quot;, FORMATTER.format(LocalDateTime.now()),
                Thread.currentThread().getName()));
    }

    private void unpark() {
        LockSupport.unpark(thread);
    }
}
// 某个时刻的执行结果如下：
2019-02-25 00:39:57.780-步入run方法,线程名称:LockSupportMain
2019-02-25 00:39:59.767-解除阻塞,线程继续执行,线程名称:LockSupportMain&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;LockSupport&lt;/code&gt;类&lt;code&gt;park()&lt;/code&gt;方法也有带超时的变体版本方法，有些适合使用阻塞超时的场景不妨可以使用。&lt;/p&gt;
&lt;h2 id=&quot;独占线程的保存&quot;&gt;独占线程的保存&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;AbstractOwnableSynchronizer&lt;/code&gt;是&lt;code&gt;AQS&lt;/code&gt;的父类，一个同步器框架有可能在一个时刻被某一个线程独占，&lt;code&gt;AbstractOwnableSynchronizer&lt;/code&gt;就是为所有的同步器实现和锁相关实现提供了基础的保存、获取和设置独占线程的功能，这个类的源码很简单：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public abstract class AbstractOwnableSynchronizer
    implements java.io.Serializable {

    private static final long serialVersionUID = 3737899427754241961L;

    protected AbstractOwnableSynchronizer() { }

    private transient Thread exclusiveOwnerThread;

    protected final void setExclusiveOwnerThread(Thread thread) {
        exclusiveOwnerThread = thread;
    }

    protected final Thread getExclusiveOwnerThread() {
        return exclusiveOwnerThread;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它就提供了一个保存独占线程的变量对应的Setter和Getter方法，方法都是final修饰的，子类只能使用不能覆盖。&lt;/p&gt;
&lt;h2 id=&quot;clh队列变体的实现&quot;&gt;CLH队列变体的实现&lt;/h2&gt;
&lt;p&gt;这里先重点分析一下&lt;code&gt;AQS&lt;/code&gt;中等待队列的节点&lt;code&gt;AQS$Node&lt;/code&gt;的源码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;static final class Node {
   // 标记一个节点处于共享模式下的等待
   static final Node SHARED = new Node();
   // 标记一个节点处于独占模式下的等待
   static final Node EXCLUSIVE = null;
   // 取消状态
   static final int CANCELLED =  1;
   // 唤醒状态
   static final int SIGNAL    = -1;
   // 条件等待状态
   static final int CONDITION = -2;
   // 传播状态
   static final int PROPAGATE = -3;
   // 等待状态，初始值为0，其他可选值是上面的4个值
   volatile int waitStatus;
   // 当前节点前驱节点的引用
   volatile Node prev;
   // 当前节点后继节点的引用
   volatile Node next;
   // 当前节点持有的线程，可能是阻塞中等待唤醒的线程
   volatile Thread thread;
   // 下一个等待节点
   Node nextWaiter;
   // 当前操作的节点是否处于共享模式
   final boolean isShared() {
      return nextWaiter == SHARED;
   }
   // 获取当前节点的前驱节点，确保前驱节点必须存在，否则抛出NPE  
   final Node predecessor() {
        Node p = prev;
        if (p == null)
            throw new NullPointerException();
        else
            return p;
    }
    
    // 空节点，主要是首次创建队列的时候创建的头和尾节点使用
    Node() {}

    // 设置下一个等待节点，设置持有线程为当前线程
    Node(Node nextWaiter) {
        this.nextWaiter = nextWaiter;
        THREAD.set(this, Thread.currentThread());
    }

    // 设置waitStatus，设置持有线程为当前线程
    Node(int waitStatus) {
        WAITSTATUS.set(this, waitStatus);
        THREAD.set(this, Thread.currentThread());
    }

    // CAS更新waitStatus  
    final boolean compareAndSetWaitStatus(int expect, int update) {
        return WAITSTATUS.compareAndSet(this, expect, update);
    }
    // CAS设置后继节点
    final boolean compareAndSetNext(Node expect, Node update) {
        return NEXT.compareAndSet(this, expect, update);
    }
    // 设置前驱节点
    final void setPrevRelaxed(Node p) {
        PREV.set(this, p);
    }

    // 下面是变量句柄的实现，在VarHandle出现之前使用的是Unsafe，其实底层还是照样使用Unsafe
    private static final VarHandle NEXT;
    private static final VarHandle PREV;
    private static final VarHandle THREAD;
    private static final VarHandle WAITSTATUS;
    static {
        try {
            MethodHandles.Lookup l = MethodHandles.lookup();
            NEXT = l.findVarHandle(Node.class, &quot;next&quot;, Node.class);
            PREV = l.findVarHandle(Node.class, &quot;prev&quot;, Node.class);
            THREAD = l.findVarHandle(Node.class, &quot;thread&quot;, Thread.class);
            WAITSTATUS = l.findVarHandle(Node.class, &quot;waitStatus&quot;, int.class);
        } catch (ReflectiveOperationException e) {
            throw new ExceptionInInitializerError(e);
        }
    }     
}   &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中，变量句柄(VarHandle)是JDK9引用的新特性，其实底层依赖的还是&lt;code&gt;Unsafe&lt;/code&gt;的方法，总体和JDK8的实现是基本一致。这里需要关注一下&lt;code&gt;Node&lt;/code&gt;里面的几个属性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;waitStatus：当前&lt;code&gt;Node&lt;/code&gt;实例的等待状态，可选值有5个。
&lt;ol&gt;&lt;li&gt;初始值整数0：当前节点如果不指定初始化状态值，默认值就是0，侧面说明节点正在等待队列中处于等待状态。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Node#CANCELLED&lt;/code&gt;整数值1：表示当前节点实例因为超时或者线程中断而被取消，等待中的节点永远不会处于此状态，被取消的节点中的线程实例不会阻塞。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Node#SIGNAL&lt;/code&gt;整数值-1：表示当前节点的后继节点是(或即将是)阻塞的(通过&lt;code&gt;park&lt;/code&gt;)，当它释放或取消时，当前节点必须&lt;code&gt;unpark&lt;/code&gt;它的后继节点。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Node#CONDITION&lt;/code&gt;整数值-2：表示当前节点是条件队列中的一个节点，当它转换为同步队列中的节点的时候，状态会被重新设置为0。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Node#PROPAGATE&lt;/code&gt;整数值-3：此状态值通常只设置到调用了&lt;code&gt;doReleaseShared()&lt;/code&gt;方法的头节点，确保&lt;code&gt;releaseShared()&lt;/code&gt;方法的调用可以传播到其他的所有节点，简单理解就是共享模式下节点释放的传递标记。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;prev、next：当前&lt;code&gt;Node&lt;/code&gt;实例的前驱节点引用和后继节点引用。&lt;/li&gt;
&lt;li&gt;thread：当前&lt;code&gt;Node&lt;/code&gt;实例持有的线程实例引用。&lt;/li&gt;
&lt;li&gt;nextWaiter：这个值是一个比较容易令人生疑的值，虽然表面上它称为&quot;下一个等待的节点&quot;，但是实际上它有三种取值的情况。
&lt;ol&gt;&lt;li&gt;值为静态实例&lt;code&gt;Node.EXCLUSIVE&lt;/code&gt;(也就是null)，代表当前的&lt;code&gt;Node&lt;/code&gt;实例是独占模式。&lt;/li&gt;
&lt;li&gt;值为静态实例&lt;code&gt;Node.SHARED&lt;/code&gt;，代表当前的&lt;code&gt;Node&lt;/code&gt;实例是共享模式。&lt;/li&gt;
&lt;li&gt;值为非&lt;code&gt;Node.EXCLUSIVE&lt;/code&gt;和&lt;code&gt;Node.SHARED&lt;/code&gt;的其他节点实例，&lt;strong&gt;代表Condition等待队列中当前节点的下一个等待节点&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;Node&lt;/code&gt;类的等待状态waitStatus理解起来是十分费劲的，下面分析其他源码的时候会标识此状态变化的时机。&lt;/p&gt;
&lt;p&gt;其实上面的&lt;code&gt;Node&lt;/code&gt;类可以直接拷贝出来当成一个新建的类，然后尝试构建一个双向链表自行调试，这样子就能深刻它的数据结构。例如：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class AqsNode {

    static final AqsNode SHARED = new AqsNode();
    static final AqsNode EXCLUSIVE = null;

    static final int CANCELLED = 1;
    static final int SIGNAL = -1;
    static final int CONDITION = -2;
    static final int PROPAGATE = -3;

    volatile int waitStatus;

    volatile AqsNode prev;

    volatile AqsNode next;

    volatile Thread thread;

    AqsNode nextWaiter;

    final boolean isShared() {
        return nextWaiter == SHARED;
    }

    final AqsNode predecessor() {
        AqsNode p = prev;
        if (p == null)
            throw new NullPointerException();
        else
            return p;
    }

    AqsNode() {
    }

    AqsNode(AqsNode nextWaiter) {
        this.nextWaiter = nextWaiter;
        THREAD.set(this, Thread.currentThread());
    }

    AqsNode(int waitStatus) {
        WAITSTATUS.set(this, waitStatus);
        THREAD.set(this, Thread.currentThread());
    }

    final boolean compareAndSetWaitStatus(int expect, int update) {
        return WAITSTATUS.compareAndSet(this, expect, update);
    }

    final boolean compareAndSetNext(AqsNode expect, AqsNode update) {
        return NEXT.compareAndSet(this, expect, update);
    }

    final void setPrevRelaxed(AqsNode p) {
        PREV.set(this, p);
    }

    private static final VarHandle NEXT;
    private static final VarHandle PREV;
    private static final VarHandle THREAD;
    private static final VarHandle WAITSTATUS;

    static {
        try {
            MethodHandles.Lookup l = MethodHandles.lookup();
            NEXT = l.findVarHandle(AqsNode.class, &quot;next&quot;, AqsNode.class);
            PREV = l.findVarHandle(AqsNode.class, &quot;prev&quot;, AqsNode.class);
            THREAD = l.findVarHandle(AqsNode.class, &quot;thread&quot;, Thread.class);
            WAITSTATUS = l.findVarHandle(AqsNode.class, &quot;waitStatus&quot;, int.class);
        } catch (ReflectiveOperationException e) {
            throw new ExceptionInInitializerError(e);
        }
    }

    public static void main(String[] args) throws Exception {
        AqsNode head = new AqsNode();
        AqsNode next = new AqsNode(AqsNode.EXCLUSIVE);
        head.next = next;
        next.prev = head;
        AqsNode tail = new AqsNode(AqsNode.EXCLUSIVE);
        next.next = tail;
        tail.prev = next;
        List&amp;lt;Thread&amp;gt; threads = new ArrayList&amp;lt;&amp;gt;();
        for (AqsNode node = head; node != null; node = node.next) {
            threads.add(node.thread);
        }
        System.out.println(threads);
    }
}
// 某次执行的输出：
[null, Thread[main,5,main], Thread[main,5,main]]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实际上，&lt;code&gt;AQS&lt;/code&gt;中一共存在两种等待队列，其中一种是普通的同步等待队列，这里命名为Sync-Queue，另一种是基于Sync-Queue实现的条件等待队列，这里命名为Condition-Queue。&lt;/p&gt;
&lt;h3 id=&quot;sync-queue&quot;&gt;Sync-Queue&lt;/h3&gt;
&lt;p&gt;前面已经介绍完&lt;code&gt;AQS&lt;/code&gt;的同步等待队列节点类，下面重点分析一下同步等待队列的相关源码，&lt;strong&gt;下文的Sync队列、同步队列和同步等待队列是同一个东西&lt;/strong&gt;。首先，我们通过分析&lt;code&gt;Node&lt;/code&gt;节点得知Sync队列一定是双向链表，&lt;code&gt;AQS&lt;/code&gt;中有两个瞬时成员变量用来存放头节点和尾节点：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 头节点引用
private transient volatile Node head;
// 尾节点引用
private transient volatile Node tail;

// 变量句柄相关，用于CAS操作头尾节点
private static final VarHandle STATE;
private static final VarHandle HEAD;
private static final VarHandle TAIL;

static {
    try {
        MethodHandles.Lookup l = MethodHandles.lookup();
        STATE = l.findVarHandle(AbstractQueuedSynchronizer.class, &quot;state&quot;, int.class);
        HEAD = l.findVarHandle(AbstractQueuedSynchronizer.class, &quot;head&quot;, Node.class);
        TAIL = l.findVarHandle(AbstractQueuedSynchronizer.class, &quot;tail&quot;, Node.class);
    } catch (ReflectiveOperationException e) {
            throw new ExceptionInInitializerError(e);
    }
    // 确保LockSupport类已经初始化 - 这里应该是为了修复之前一个因为LockSupport未初始化导致的BUG
    Class&amp;lt;?&amp;gt; ensureLoaded = LockSupport.class;
}

// 初始化同步队列，注意初始化同步队列的时候，头尾节点都是指向同一个新的Node实例
private final void initializeSyncQueue() {
    Node h;
    if (HEAD.compareAndSet(this, null, (h = new Node())))
        tail = h;
}

// CAS设置同步队列的尾节点
private final boolean compareAndSetTail(Node expect, Node update) {
    return TAIL.compareAndSet(this, expect, update);
}

// 设置头节点，重点注意这里：传入的节点设置成头节点之后，前驱节点和持有的线程会置为null，这是因为：
// 1.头节点一定没有前驱节点。
// 2.当节点被设置为头节点，它所在的线程一定是已经解除了阻塞。
private void setHead(Node node) {
    head = node;
    node.thread = null;
    node.prev = null;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当前线程加入同步等待队列和同步等待队列的初始化是同一个方法，前文提到过：同步等待队列的初始化会延迟到第一次可能出现竞争的情况，这是为了避免无谓的资源浪费，具体方法是&lt;code&gt;addWaiter(Node mode)&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 添加等待节点到同步等待队列，实际上初始化队列也是这个方法完成的
private Node addWaiter(Node mode) {
    // 基于当前线程创建一个新节点，节点的模式由调用者决定
    Node node = new Node(mode);
    for (;;) {
        Node oldTail = tail;
       // 尾节点不为空说明队列已经初始化过，则把新节点加入到链表中，作为新的尾节点，建立和前驱节点的关联关系
        if (oldTail != null) {
            node.setPrevRelaxed(oldTail);
            if (compareAndSetTail(oldTail, node)) {
                oldTail.next = node;
                return node;
            }
        } else {
        // 尾节点为空说明队列尚未初始化过，进行一次初始化操作
            initializeSyncQueue();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在首次调用&lt;code&gt;addWaiter()&lt;/code&gt;方法，死循环至少执行两轮再跳出，因为同步队列必须初始化完成后(第一轮循环)，然后再把当前线程所在的新节点实例添加到等待队列中再返回(第二轮循环)当前的节点，&lt;strong&gt;这里需要注意的是新加入同步等待队列的节点一定是添加到队列的尾部并且会更新&lt;code&gt;AQS&lt;/code&gt;中的tail属性为最新入队的节点实例&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;假设我们使用&lt;code&gt;Node.EXCLUSIVE&lt;/code&gt;模式入队列，手上有三个线程分别是thread-1、thread-2和thread-3，线程入队的时候都处于阻塞状态，模拟一下依次调用上面的入队方法的同步队列的整个链表的状态。&lt;/p&gt;
&lt;p&gt;先是线程thread-1加入等待队列：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/201904/j-a-q-s-1.png&quot; alt=&quot;j-a-q-s-1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接着是线程thread-2加入等待队列：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/201904/j-a-q-s-2.png&quot; alt=&quot;j-a-q-s-2&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后是线程thread-3加入等待队列：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/201904/j-a-q-s-3.png&quot; alt=&quot;j-a-q-s-3&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果仔细研究会发现，如果所有的入队线程都处于阻塞状态的话，新入队的线程总是添加到队列的tail节点，阻塞的线程总是&quot;争抢&quot;着成为head节点，这一点和CLH队列锁的阻塞线程总是基于前驱节点自旋以获取锁的思路是一致的。下面将会分析的&lt;strong&gt;独占模式与共享模式，线程加入等待队列都是通过&lt;code&gt;addWaiter()&lt;/code&gt;方法&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;condition-queue&quot;&gt;Condition-Queue&lt;/h3&gt;
&lt;p&gt;前面已经相对详细地介绍过同步等待队列，在&lt;code&gt;AQS&lt;/code&gt;中还存在另外一种相对特殊和复杂的等待队列-条件等待队列。介绍条件等待队列之前，要先介绍&lt;code&gt;java.util.concurrent.locks.Condition&lt;/code&gt;接口。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface Condition {
    
    // 当前线程进入等待状态直到被唤醒或者中断
    void await() throws InterruptedException;
    // 当前线程进入等待状态，不响应中断，阻塞直到被唤醒
    void awaitUninterruptibly();
    // 当前线程进入等待状态直到被唤醒或者中断，阻塞带时间限制
    long awaitNanos(long nanosTimeout) throws InterruptedException;
    // 当前线程进入等待状态直到被唤醒或者中断，阻塞带时间限制
    boolean await(long time, TimeUnit unit) throws InterruptedException;
    // 当前线程进入等待状态直到被唤醒或者中断，阻塞带时间限制
    boolean awaitUntil(Date deadline) throws InterruptedException;
    // 唤醒单个阻塞线程
    void signal();
    // 唤醒所有阻塞线程
    void signalAll();
}    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Condition&lt;/code&gt;可以理解为&lt;code&gt;Object&lt;/code&gt;中的&lt;code&gt;wait()&lt;/code&gt;、&lt;code&gt;notify()&lt;/code&gt;和&lt;code&gt;notifyAll()&lt;/code&gt;的替代品，因为&lt;code&gt;Object&lt;/code&gt;中的相应方法是JNI(Native)方法，由JVM实现，对使用者而言并不是十分友好(可能需要感知JVM的源码实现)，而&lt;code&gt;Condition&lt;/code&gt;是基于数据结构和相应算法实现对应的功能，我们可以从源码上分析其实现。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Condition&lt;/code&gt;的实现类是&lt;code&gt;AQS&lt;/code&gt;的公有内部类&lt;code&gt;ConditionObject&lt;/code&gt;。&lt;code&gt;ConditionObject&lt;/code&gt;提供的入队列方法如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ConditionObject implements Condition, java.io.Serializable {
    private static final long serialVersionUID = 1173984872572414699L;
    /** First node of condition queue. */ - 条件队列的第一个节点
    private transient Node firstWaiter;
    /** Last node of condition queue. */ - 条件队列的最后一个节点
    private transient Node lastWaiter;
    // 公有构造函数
    public ConditionObject() { }
    // 添加条件等待节点
    private Node addConditionWaiter() {
        // 这里做一次判断，当前线程必须步入此同步器实例
        if (!isHeldExclusively())
            throw new IllegalMonitorStateException();
        // 临时节点t赋值为lastWaiter引用
        Node t = lastWaiter;
        // If lastWaiter is cancelled, clean out.
        // 最后一个节点不为条件等待状态，则是取消状态
        if (t != null &amp;amp;&amp;amp; t.waitStatus != Node.CONDITION) {
            // 解除所有取消等待的节点的连接
            unlinkCancelledWaiters();
            t = lastWaiter;
        }
        // 基于当前线程新建立一个条件等待类型的节点
        Node node = new Node(Node.CONDITION);
        // 首次创建Condition的时候，最后一个节点临时引用t为null，则把第一个节点置为新建的节点
        if (t == null)
            firstWaiter = node;
        else
            // 已经存在第一个节点，则通过nextWaiter连接新的节点
            t.nextWaiter = node;
        // 最后一个节点的引用更新为新节点的引用    
        lastWaiter = node;
        return node;
    } 
    // 从条件等待队列解除所有取消等待的节点的连接，其实就是所有取消节点移除的操作，涉及到双向链表的断链操作、第一个和最后一个节点的引用更新
    private void unlinkCancelledWaiters() {
        Node t = firstWaiter;
        Node trail = null;
        while (t != null) {
            Node next = t.nextWaiter;
            // 注意这里等待状态的判断
            if (t.waitStatus != Node.CONDITION) {
                t.nextWaiter = null;
                if (trail == null)
                    firstWaiter = next;
                else
                    trail.nextWaiter = next;
                if (next == null)
                    lastWaiter = trail;
            }
            else
                trail = t;
            t = next;
        }
    } 
    // 当前同步器实例持有的线程是否当前线程(currentThread())
    protected boolean isHeldExclusively() {
        throw new UnsupportedOperationException();
    } 

// 暂时不分析其他方法             
}        &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实际上，&lt;code&gt;Condition&lt;/code&gt;的所有&lt;code&gt;await()&lt;/code&gt;方法变体都调用&lt;code&gt;addConditionWaiter()&lt;/code&gt;添加阻塞线程到条件队列中。我们按照分析同步等待队列的情况，分析一下条件等待队列。正常情况下，假设有2个线程thread-1和thread-2进入条件等待队列，都处于阻塞状态。&lt;/p&gt;
&lt;p&gt;先是thread-1进入条件队列：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/201904/j-a-q-s-4.png&quot; alt=&quot;j-a-q-s-4&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后是thread-2进入条件队列：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/201904/j-a-q-s-5.png&quot; alt=&quot;j-a-q-s-5&quot;/&gt;&lt;/p&gt;
&lt;p&gt;条件等待队列看起来也并不复杂，但是它并不是单独存在和使用的，一般依赖于同步等待队列，下面的一节分析Condition的实现的时候再详细分析。&lt;/p&gt;
&lt;h2 id=&quot;独占模式与共享模式&quot;&gt;独占模式与共享模式&lt;/h2&gt;
&lt;p&gt;前文提及到，同步器涉及到独占模型和共享模式。下面就针对这两种模式详细分析一下&lt;code&gt;AQS&lt;/code&gt;的具体实现源码。&lt;/p&gt;
&lt;h3 id=&quot;独占模式&quot;&gt;独占模式&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;AQS&lt;/code&gt;同步器如果使用独占(EXCLUSIVE)模式，那么意味着同一个时刻，只有节点所在一个线程获取(acuqire)原子状态status成功，此时该线程可以从阻塞状态解除继续运行，而同步等待队列中的其他节点持有的线程依然处于阻塞状态。独占模式同步器的功能主要由下面的四个方法提供：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;acquire(int arg)&lt;/code&gt;；申请获取arg个原子状态status(申请成功可以简单理解为&lt;code&gt;status = status - arg&lt;/code&gt;)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;acquireInterruptibly(int arg)&lt;/code&gt;：申请获取arg个原子状态status，响应线程中断。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tryAcquireNanos(int arg, long nanosTimeout)&lt;/code&gt;：申请获取arg个原子状态status，带超时的版本。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;release(int arg)&lt;/code&gt;：释放arg个原子状态status(释放成功可以简单理解为&lt;code&gt;status = status + arg&lt;/code&gt;)。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;独占模式下，&lt;code&gt;AQS&lt;/code&gt;同步器实例初始化时候传入的status值，可以简单理解为&quot;允许申请的资源数量的上限值&quot;，下面的&lt;code&gt;acquire&lt;/code&gt;类型的方法暂时称为&quot;获取资源&quot;，而&lt;code&gt;release&lt;/code&gt;方法暂时称为&quot;释放资源&quot;。接着我们分析前面提到的四个方法的源码，先看&lt;code&gt;acquire(int arg)&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public final void acquire(int arg) {
    // 获取资源成功或者新增一个独占类型节点到同步等待队列成功则直接返回，否则中断当前线程
    if (!tryAcquire(arg) &amp;amp;&amp;amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}

// 此方法必须又子类覆盖，用于决定是否获取资源成功
protected boolean tryAcquire(int arg) {
    throw new UnsupportedOperationException();
}

// 中断当前线程
static void selfInterrupt() {
    Thread.currentThread().interrupt();
}

// 不可中断的独占模式下，同步等待队列中的线程获取资源的方法
final boolean acquireQueued(final Node node, int arg) {
    boolean interrupted = false;
    try {
        for (;;) {
            // 获取新入队节点的前驱节点
            final Node p = node.predecessor();
            // 前驱节点为头节点并且尝试获取资源成功，也就是每一轮循环都会调用tryAcquire尝试获取资源，除非阻塞或者跳出循环
            if (p == head &amp;amp;&amp;amp; tryAcquire(arg)) {
                // 设置新入队节点为头节点，原来的节点会从队列中断开
                setHead(node);
                p.next = null; // help GC
                return interrupted;   // &amp;lt;== 注意，这个位置是跳出死循环的唯一位置
            }
            // 判断是否需要阻塞当前获取资源失败的节点中持有的线程
            if (shouldParkAfterFailedAcquire(p, node))
                // 阻塞当前线程，如果被唤醒则返回并清空线程的中断标记
                interrupted |= parkAndCheckInterrupt();
        }
    } catch (Throwable t) {
        cancelAcquire(node);
        if (interrupted)
            selfInterrupt();
        throw t;
    }
}

/**
 * 检查并且更新获取资源失败的节点的状态，返回值决定线程是否需要被阻塞。
 * 这个方法是所有循环获取资源方法中信号控制的主要方法
 */
private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
    // 这里记住ws是当前处理节点的前驱节点的等待状态
    int ws = pred.waitStatus;
    if (ws == Node.SIGNAL)
        // 前驱节点状态设置成Node.SIGNAL成功，等待被release调用释放，后继节点可以安全地进入阻塞状态
        return true;
    if (ws &amp;gt; 0) {
        // ws大于0只有一种情况Node.CANCELLED，说明前驱节点已经取消获取资源，
        // 这个时候会把所有这类型取消的前驱节点移除，找到一个非取消的节点重新通过next引用连接当前节点
        do {
           node.prev = pred = pred.prev;
        } while (pred.waitStatus &amp;gt; 0);
        pred.next = node;
    } else {
        // 其他等待状态直接修改前驱节点等待状态为Node.SIGNAL
        pred.compareAndSetWaitStatus(ws, Node.SIGNAL);
    }
    return false;
}

// 阻塞当前线程，获取并且重置线程的中断标记位
private final boolean parkAndCheckInterrupt() {
    // 这个就是阻塞线程的实现，依赖Unsafe的API
    LockSupport.park(this);
    return Thread.interrupted();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码虽然看起来能基本理解，但是最好用图推敲一下&quot;空间上的变化&quot;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/201904/j-a-q-s-6.png&quot; alt=&quot;j-a-q-s-6&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/201904/j-a-q-s-7.png&quot; alt=&quot;j-a-q-s-7&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接着分析一下&lt;code&gt;release(int arg)&lt;/code&gt;的实现：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 释放资源
public final boolean release(int arg) {
    // 尝试释放资源
    if (tryRelease(arg)) {
        Node h = head;
        if (h != null &amp;amp;&amp;amp; h.waitStatus != 0)
            unparkSuccessor(h);
        return true;
    }
    return false;
}

// 尝试释放资源，独占模式下，尝试通过重新设置status的值从而实现释放资源的功能
// 这个方法必须由子类实现
protected boolean tryRelease(int arg) {
    throw new UnsupportedOperationException();
}

// 解除传入节点(一般是头节点)的第一个后继节点的阻塞状态，当前处理节点的等待状态会被CAS更新为0
private void unparkSuccessor(Node node) {
    int ws = node.waitStatus;
    // 当前处理的节点(一般是头节点)状态小于0则直接CAS更新为0
    if (ws &amp;lt; 0)
        node.compareAndSetWaitStatus(ws, 0);
    Node s = node.next;
    if (s == null || s.waitStatus &amp;gt; 0) {
        s = null;
        // 如果节点的第一个后继节点为null或者等待状态大于0(取消)，则从等待队列的尾节点向前遍历，
        // 找到最后一个不为null，并且等待状态小于等于0的节点
        for (Node p = tail; p != node &amp;amp;&amp;amp; p != null; p = p.prev)
            if (p.waitStatus &amp;lt;= 0)
                s = p;
    }
    // 解除上面的搜索到的节点的阻塞状态
    if (s != null)
        LockSupport.unpark(s.thread);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着用上面的图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/201904/j-a-q-s-8.png&quot; alt=&quot;j-a-q-s-8&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面图中thread-2晋升为头节点的第一个后继节点，等待下一个&lt;code&gt;release()&lt;/code&gt;释放资源唤醒之就能晋升为头节点，一旦晋升为头节点也就是意味着可以解除阻塞继续运行。接着我们可以看&lt;code&gt;acquire()&lt;/code&gt;的响应中断版本和带超时的版本。先看&lt;code&gt;acquireInterruptibly(int arg)&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public final void acquireInterruptibly(int arg)
            throws InterruptedException {
    // 获取并且清空线程中断标记位，如果是中断状态则直接抛InterruptedException异常
    if (Thread.interrupted())
        throw new InterruptedException();
    // 如果获取资源失败
    if (!tryAcquire(arg))
        doAcquireInterruptibly(arg);
}

// 独占模式下响应中断的获取资源方法
private void doAcquireInterruptibly(int arg) throws InterruptedException {
    // 基于当前线程新增一个独占的Node节点进入同步等待队列中
    final Node node = addWaiter(Node.EXCLUSIVE);
    try {
        for (;;) {
            final Node p = node.predecessor();
            if (p == head &amp;amp;&amp;amp; tryAcquire(arg)) {
                setHead(node);
                p.next = null; // help GC
                return;
            }
            // 获取资源失败进入阻塞状态
            if (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp; parkAndCheckInterrupt())
                    // 解除阻塞后直接抛出InterruptedException异常
                    throw new InterruptedException();
            }
         } catch (Throwable t) {
            cancelAcquire(node);
            throw t;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;doAcquireInterruptibly(int arg)&lt;/code&gt;方法和&lt;code&gt;acquire(int arg)&lt;/code&gt;类似，最大的不同点在于阻塞线程解除阻塞后并不是正常继续运行，而是直接抛出&lt;code&gt;InterruptedException&lt;/code&gt;异常。最后看&lt;code&gt;tryAcquireNanos(int arg, long nanosTimeout)&lt;/code&gt;的实现：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 独占模式下尝试在指定超时时间内获取资源，响应线程中断
public final boolean tryAcquireNanos(int arg, long nanosTimeout) throws InterruptedException {
    if (Thread.interrupted())
        throw new InterruptedException();
    return tryAcquire(arg) || doAcquireNanos(arg, nanosTimeout);
}

// 独占模式下带超时时间限制的获取资源方法
private boolean doAcquireNanos(int arg, long nanosTimeout) throws InterruptedException {
    // 超时期限小于0纳秒，快速失败
    if (nanosTimeout &amp;lt;= 0L)
        return false;
    // 超时的最终期限是当前系统时钟纳秒+外部指定的nanosTimeout增量
    final long deadline = System.nanoTime() + nanosTimeout;
    final Node node = addWaiter(Node.EXCLUSIVE);
    try {
        for (;;) {
            final Node p = node.predecessor();
            if (p == head &amp;amp;&amp;amp; tryAcquire(arg)) {
                setHead(node);
                p.next = null; // help GC
                return true;
            }
            // 计算出剩余的超时时间
            nanosTimeout = deadline - System.nanoTime();
            // 剩余超时时间小于0说明已经超时则取消获取
            if (nanosTimeout &amp;lt;= 0L) {
                cancelAcquire(node);
                return false;
            }
            // 这里会判断剩余超时时间大于1000纳秒的时候才会进行带超时期限的线程阻塞，否则会进入下一轮获取尝试
            if (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp; nanosTimeout &amp;gt; SPIN_FOR_TIMEOUT_THRESHOLD)
                    LockSupport.parkNanos(this, nanosTimeout);
            if (Thread.interrupted())
                throw new InterruptedException();
            }
    } catch (Throwable t) {
        cancelAcquire(node);
        throw t;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;tryAcquireNanos(int arg, long nanosTimeout)&lt;/code&gt;其实和&lt;code&gt;doAcquireInterruptibly(int arg)&lt;/code&gt;类似，它们都响应线程中断，不过&lt;code&gt;tryAcquireNanos()&lt;/code&gt;在获取资源的每一轮循环尝试都会计算剩余可用的超时时间，只有同时满足获取失败需要阻塞并且剩余超时时间大于&lt;code&gt;SPIN_FOR_TIMEOUT_THRESHOLD(1000纳秒)&lt;/code&gt;的情况下才会进行阻塞。&lt;/p&gt;
&lt;p&gt;独占模式的同步器的一个显著特点就是：头节点的第一个有效(非取消)的后继节点，总是尝试获取资源，一旦获取资源成功就会解除阻塞并且晋升为头节点，原来所在节点会移除出同步等待队列，原来的队列长度就会减少1，然后头结点的第一个有效的后继节点继续开始竞争资源。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/201904/j-a-q-s-9.png&quot; alt=&quot;j-a-q-s-9&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用独占模式同步器的主要类库有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;可重入锁&lt;code&gt;ReentrantLock&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;读写锁&lt;code&gt;ReentrantReadWriteLock&lt;/code&gt;中的写锁&lt;code&gt;WriteLock&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;共享模式&quot;&gt;共享模式&lt;/h3&gt;
&lt;p&gt;共享(SHARED)模式中的&quot;共享&quot;的含义是：同一个时刻，如果有一个节点所在线程获取(acuqire)原子状态status成功，那么它会解除阻塞被唤醒，并且会把&lt;strong&gt;唤醒状态传播&lt;/strong&gt;到所有的后继节点(换言之就是唤醒整个同步等待队列中的所有节点)。共享模式同步器的功能主要由下面的四个方法提供：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;acquireShared(int arg)&lt;/code&gt;；申请获取arg个原子状态status(申请成功可以简单理解为&lt;code&gt;status = status - arg&lt;/code&gt;)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;acquireSharedInterruptibly(int arg)&lt;/code&gt;：申请获取arg个原子状态status，响应线程中断。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tryAcquireSharedNanos(int arg, long nanosTimeout)&lt;/code&gt;：申请获取arg个原子状态status，带超时的版本。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;releaseShared(int arg)&lt;/code&gt;：释放arg个原子状态status(释放成功可以简单理解为&lt;code&gt;status = status + arg&lt;/code&gt;)。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;先看&lt;code&gt;acquireShared(int arg)&lt;/code&gt;的源码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 共享模式下获取资源
public final void acquireShared(int arg) {
    // 注意tryAcquireShared方法值为整型，只有小于0的时候才会加入同步等待队列
    if (tryAcquireShared(arg) &amp;lt; 0)
        doAcquireShared(arg);
}

// 共享模式下尝试获取资源，此方法需要由子类覆盖
protected int tryAcquireShared(int arg) {
    throw new UnsupportedOperationException();
}

// 共享模式下获取资源和处理同步等待队列的方法
private void doAcquireShared(int arg) {
    // 基于当前线程新建一个标记为共享的新节点
    final Node node = addWaiter(Node.SHARED);
    boolean interrupted = false;
    try {
        for (;;) {
            final Node p = node.predecessor();
            // 如果当前节点的前驱节点是头节点
            if (p == head) {
                // 每一轮循环都会调用tryAcquireShared尝试获取资源，除非阻塞或者跳出循环
                int r = tryAcquireShared(arg);
                if (r &amp;gt;= 0) {  // &amp;lt;= tryAcquireShared方法&amp;gt;=0说明直资源获取成功
                    // 设置头结点，并且传播获取资源成功的状态，这个方法的作用是确保唤醒状态传播到所有的后继节点
                    // 然后任意一个节点晋升为头节点都会唤醒其第一个有效的后继节点，起到一个链式释放和解除阻塞的动作
                    setHeadAndPropagate(node, r);
                    p.next = null; // help GC
                    return;
                }
            }
            // 判断获取资源失败是否需要阻塞，这里会把前驱节点的等待状态CAS更新为Node.SIGNAL
            if (shouldParkAfterFailedAcquire(p, node))
                interrupted |= parkAndCheckInterrupt();
        }
    } catch (Throwable t) {
        cancelAcquire(node);
        throw t;
    } finally {
        if (interrupted)
            selfInterrupt();
    }
}

// 设置同步等待队列的头节点，判断当前处理的节点的后继节点是否共享模式的节点，如果共享模式的节点，
// propagate大于0或者节点的waitStatus为PROPAGATE则进行共享模式下的释放资源
private void setHeadAndPropagate(Node node, int propagate) {
    // h为头节点的中间变量
    Node h = head;
    // 设置当前处理节点为头节点
    setHead(node);
    // 这个判断条件比较复杂：入参propagate大于0 || 头节点为null || 头节点的状态为非取消 || 再次获取头节点为null || 再次获取头节点不为取消
    if (propagate &amp;gt; 0 || h == null || h.waitStatus &amp;lt; 0 || (h = head) == null || h.waitStatus &amp;lt; 0) {
        Node s = node.next;
        // 当前节点(其实已经成为头节点)的第一个后继节点为null或者是共享模式的节点
        if (s == null || s.isShared())
            doReleaseShared();
    }
}

// Release action for shared mode：共享模式下的释放资源动作
private void doReleaseShared() {
    for (;;) {
        Node h = head;
        // 头节点不为null并且不为尾节点
        if (h != null &amp;amp;&amp;amp; h != tail) {
            int ws = h.waitStatus;
            // 如果头节点等待状态为SIGNAL(-1)则CAS更新它为0，更新成功后唤醒和解除其后继节点的阻塞
            if (ws == Node.SIGNAL) {
                if (!h.compareAndSetWaitStatus(Node.SIGNAL, 0))
                    continue;
                // 唤醒头节点的后继节点
                unparkSuccessor(h);
            }
            // 如果头节点的等待状态为0，则CAS更新它为PROPAGATE(-3)
            else if (ws == 0 &amp;amp;&amp;amp; !h.compareAndSetWaitStatus(0, Node.PROPAGATE))
                continue;
            }
        // 头节点没有变更，则跳出循环
        if (h == head)
            break;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实代码的实现和独占模式有很多类似的地方，一个很大的不同点是：共享模式同步器当节点获取资源成功晋升为头节点之后，它会把自身的等待状态通过CAS更新为&lt;code&gt;Node.PROPAGATE&lt;/code&gt;，下一个加入等待队列的新节点会把头节点的等待状态值更新回&lt;code&gt;Node.SIGNAL&lt;/code&gt;，标记后继节点处于可以被唤醒的状态，如果遇上资源释放，那么这个阻塞的节点就能被唤醒解除阻塞。我们还是画图理解一下，先假设&lt;code&gt;tryAcquireShared(int arg)&lt;/code&gt;总是返回小于0的值，入队两个阻塞的线程thread-1和thread-2，然后进行资源释放确保&lt;code&gt;tryAcquireShared(int arg)&lt;/code&gt;总是返回大于0的值：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/201904/j-a-q-s-10.png&quot; alt=&quot;j-a-q-s-10&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看起来和独占模式下的同步等待队列差不多，实际上真正不同的地方在于有节点解除阻塞和晋升为头节点的过程。因此我们可以先看&lt;code&gt;releaseShared(int arg)&lt;/code&gt;的源码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 共享模式下释放资源
public final boolean releaseShared(int arg) {
    // 尝试释放资源成功则调用前面分析过的doReleaseShared以传播唤醒状态和unpark头节点的后继节点
    if (tryReleaseShared(arg)) {
        doReleaseShared();
        return true;
    }
    return false;
}

// 共享模式下尝试释放资源，必须由子类覆盖
protected boolean tryReleaseShared(int arg) {
    throw new UnsupportedOperationException();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;releaseShared(int arg)&lt;/code&gt;就是在&lt;code&gt;tryReleaseShared(int arg)&lt;/code&gt;调用返回true的情况下主动调用一次&lt;code&gt;doReleaseShared()&lt;/code&gt;从而基于头节点传播唤醒状态和&lt;code&gt;unpark&lt;/code&gt;头节点的后继节点。接着之前的图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/201904/j-a-q-s-11.png&quot; alt=&quot;j-a-q-s-11&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/201904/j-a-q-s-12.png&quot; alt=&quot;j-a-q-s-12&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接着看&lt;code&gt;acquireSharedInterruptibly(int arg)&lt;/code&gt;的源码实现：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 共享模式下获取资源的方法，响应线程中断
public final void acquireSharedInterruptibly(int arg) throws InterruptedException {
    if (Thread.interrupted())
        throw new InterruptedException();
    if (tryAcquireShared(arg) &amp;lt; 0)
        doAcquireSharedInterruptibly(arg);
}

private void doAcquireSharedInterruptibly(int arg) throws InterruptedException {
    final Node node = addWaiter(Node.SHARED);
    try {
        for (;;) {
            final Node p = node.predecessor();
            if (p == head) {
                int r = tryAcquireShared(arg);
                if (r &amp;gt;= 0) {
                    setHeadAndPropagate(node, r);
                    p.next = null; // help GC
                    return;
                }
            }
            // 和非响应线程中断的acquireShared方法类似，不过这里解除阻塞之后直接抛出异常InterruptedException
            if (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp; parkAndCheckInterrupt())
                throw new InterruptedException();
        }
    } catch (Throwable t) {
        cancelAcquire(node);
        throw t;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后看&lt;code&gt;tryAcquireSharedNanos(int arg, long nanosTimeout)&lt;/code&gt;的源码实现：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 共享模式下获取资源的方法，带超时时间版本
public final boolean tryAcquireSharedNanos(int arg, long nanosTimeout) throws InterruptedException {
        if (Thread.interrupted())
            throw new InterruptedException();
        // 注意这里只要tryAcquireShared &amp;gt;= 0或者doAcquireSharedNanos返回true都认为获取资源成功
        return tryAcquireShared(arg) &amp;gt;= 0 || doAcquireSharedNanos(arg, nanosTimeout);
}

private boolean doAcquireSharedNanos(int arg, long nanosTimeout) throws InterruptedException {
    if (nanosTimeout &amp;lt;= 0L)
        return false;
    // 计算超时的最终期限    
    final long deadline = System.nanoTime() + nanosTimeout;
    final Node node = addWaiter(Node.SHARED);
    try {
        for (;;) {
            final Node p = node.predecessor();
            if (p == head) {
                int r = tryAcquireShared(arg);
                if (r &amp;gt;= 0) {
                    setHeadAndPropagate(node, r);
                    p.next = null; // help GC
                    return true;
                }
            }
            //重新计算剩余的超时时间 
            nanosTimeout = deadline - System.nanoTime();
            // 超时的情况下直接取消获取
            if (nanosTimeout &amp;lt;= 0L) {
                cancelAcquire(node);
                return false;
            }
            // 满足阻塞状态并且剩余的超时时间大于阀值1000纳秒则通过LockSupport.parkNanos()阻塞线程
            if (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp; nanosTimeout &amp;gt; SPIN_FOR_TIMEOUT_THRESHOLD)
                LockSupport.parkNanos(this, nanosTimeout);
            // 解除阻塞后判断线程的中断标记并且清空标记位，如果是处于中断状态则抛出InterruptedException 
            if (Thread.interrupted())
                throw new InterruptedException();
        }
    } catch (Throwable t) {
        cancelAcquire(node);
        throw t;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;共享模式的同步器的一个显著特点就是：头节点的第一个有效(非取消)的后继节点，总是尝试获取资源，一旦获取资源成功就会解除阻塞并且晋升为头节点，原来所在节点会移除出同步等待队列，原来的队列长度就会减少1，重新设置头节点的过程会传播唤醒的状态，简单来说就是唤醒一个有效的后继节点，只要一个节点可以晋升为头节点，它的后继节点就能被唤醒。&lt;strong&gt;节点的唤醒顺序遵循类似于FIFO的原则，通俗说就是先阻塞或者阻塞时间最长则先被唤醒&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/201904/j-a-q-s-13.png&quot; alt=&quot;j-a-q-s-13&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用共享模式同步器的主要类库有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;信号量&lt;code&gt;Semaphore&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;倒数栅栏&lt;code&gt;CountDownLatch&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;condition的实现&quot;&gt;Condition的实现&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Condition&lt;/code&gt;实例的建立是在&lt;code&gt;Lock&lt;/code&gt;接口的&lt;code&gt;newCondition()&lt;/code&gt;方法，它是锁条件等待的实现，基于作用或者语义可以见&lt;code&gt;Condition&lt;/code&gt;接口的相关API注释：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Condition是对象监视器锁方法Object#wait()、Object#notify()和Object#notifyAll()的替代实现，对象监视器锁实现锁的时候作用的效果是每个锁对象必须使用多个wait-set(JVM内置的等待队列)，通过Object提供的方法和监视器锁结合使用就能达到Lock的实现效果。如果替换synchronized方法和语句并且结合使用Lock和Condition，就能替换并且达到对象监视器锁的效果。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;Condition&lt;/code&gt;必须固有地绑定在一个&lt;code&gt;Lock&lt;/code&gt;的实现类上，也就是要通过&lt;code&gt;Lock&lt;/code&gt;的实例建立&lt;code&gt;Condition&lt;/code&gt;实例，而且&lt;code&gt;Condition&lt;/code&gt;的方法调用使用必须在&lt;code&gt;Lock&lt;/code&gt;的&quot;锁定代码块&quot;中，这一点和&lt;code&gt;synchronized&lt;/code&gt;关键字以及&lt;code&gt;Object&lt;/code&gt;的相关JNI方法使用的情况十分相似。&lt;/p&gt;
&lt;p&gt;前文介绍过&lt;code&gt;Condition&lt;/code&gt;接口提供的方法以及&lt;code&gt;Condition&lt;/code&gt;队列，也就是条件等待队列，通过PPT画图简单介绍了它的队列节点组成。实际上，条件等待队列需要结合同步等待队列使用，这也刚好对应于&lt;strong&gt;前面提到的&lt;code&gt;Condition&lt;/code&gt;的方法调用使用必须在&lt;code&gt;Lock&lt;/code&gt;的锁定代码块中&lt;/strong&gt;。听起来很懵逼，我们慢慢分析一下&lt;code&gt;ConditionObject&lt;/code&gt;的方法源码就能知道具体的原因。&lt;/p&gt;
&lt;p&gt;先看&lt;code&gt;ConditionObject#await()&lt;/code&gt;方法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 退出等待后主动进行中断当前线程
private static final int REINTERRUPT = 1;
// 退出等待后抛出InterruptedException异常
private static final int THROW_IE   = -1;
/** 
 * 可中断的条件等待实现
 * 1、当前线程处于中断状态则抛出InterruptedException
 * 2、保存getState返回的锁状态，并且使用此锁状态调用release释放所有的阻塞线程
 * 3、线程加入等待队列进行阻塞，直到signall或者中断
 * 4、通过保存getState返回的锁状态调用acquire方法
 * 5、第4步中阻塞过程中中断则抛出InterruptedException
 */
public final void await() throws InterruptedException {
    // 如果线程是中断状态则清空中断标记位并且抛出InterruptedException
    if (Thread.interrupted())
        throw new InterruptedException();
    // 当前线程所在的新节点加入条件等待队列
    Node node = addConditionWaiter();
    // 释放当前AQS中的所有资源返回资源的status保存值，也就是基于status的值调用release(status) - 其实这一步是解锁操作
    int savedState = fullyRelease(node);
    // 初始化中断模式
    int interruptMode = 0;
    // 如果节点新建的节点不位于同步队列中(理论上应该是一定不存在)，则对节点所在线程进行阻塞，第二轮循环理论上节点一定在同步等待队列中
    while (!isOnSyncQueue(node)) {
        LockSupport.park(this);
        // 处理节点所在线程中断的转换操作
        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
            break;
    }
    // 节点所在线程被唤醒后，如果节点所在线程没有处于中断状态，则以独占模式进行头节点竞争
    // 注意这里使用的status是前面释放资源时候返回的保存下来的status
    if (acquireQueued(node, savedState) &amp;amp;&amp;amp; interruptMode != THROW_IE)
        interruptMode = REINTERRUPT;
    // 下一个等待节点不空，则从等待队列中移除所有取消的等待节点
    if (node.nextWaiter != null) // clean up if cancelled
        unlinkCancelledWaiters();
    // interruptMode不为0则按照中断模式进行不同的处理
    if (interruptMode != 0)
        reportInterruptAfterWait(interruptMode);
}

// 释放当前AQS中的所有资源，其实也就是基于status的值调用release(status)
// 这一步对于锁实现来说，就是一个解锁操作
final int fullyRelease(Node node) {
    try {
        int savedState = getState();
        if (release(savedState))
            return savedState;
        throw new IllegalMonitorStateException();
    } catch (Throwable t) {
        // 释放失败则标记等待状态为取消
        node.waitStatus = Node.CANCELLED;
        throw t;
    }
}

// 传入的节点是否在同步队列中
final boolean isOnSyncQueue(Node node) {
    // 节点等待您状态为CONDITION或者前驱节点为null则返回false
    if (node.waitStatus == Node.CONDITION || node.prev == null)
        return false;
    // 因为等待队列是通过nextWaiter连接，next引用存在说明节点位于同步队列
    if (node.next != null)
        return true;
    // 从同步队列的尾部向前遍历是否存在传入的节点实例
    return findNodeFromTail(node);
}

// 从同步队列的尾部向前遍历是否存在传入的节点实例
private boolean findNodeFromTail(Node node) {
    for (Node p = tail;;) {
        if (p == node)
            return true;
        if (p == null)
            return false;
        p = p.prev;
    }
}

// 这是一个很复杂的判断，用了两个三目表达式，作用是如果新建的等待节点所在线程中断，
// 则把节点的状态由CONDITION更新为0，并且加入到同步等待队列中，返回THROW_IE中断状态，如果加入同步队列失败，返回REINTERRUPT
// 如果新建的等待节点所在线程没有中断，返回0，也就是初始状态的interruptMode
private int checkInterruptWhileWaiting(Node node) {
    return Thread.interrupted() ? (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) : 0;
}

// 节点线程中断取消等待后的转换操作
final boolean transferAfterCancelledWait(Node node) {
    // CAS更新节点的状态由CONDITION更改为0
    if (node.compareAndSetWaitStatus(Node.CONDITION, 0)) {
        // 节点加入同步等待队列
        enq(node);
        return true;
    }
    // 这里尝试自旋，直到节点加入同步等待队列成功
    while (!isOnSyncQueue(node))
        Thread.yield();
    return false;
}

// 等待完毕后报告中断处理，前边的逻辑得到的interruptMode如果为THROW_IE则抛出InterruptedException，如果为REINTERRUPT则中断当前线程
private void reportInterruptAfterWait(int interruptMode) throws InterruptedException {
    if (interruptMode == THROW_IE)
        throw new InterruptedException();
    else if (interruptMode == REINTERRUPT)
        selfInterrupt();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实上面的&lt;code&gt;await()&lt;/code&gt;逻辑并不复杂，前提是理解了对象监视器锁那套等待和唤醒的机制(由JVM实现，C语言学得好的可以去看下源码)，这里只是通过算法和数据结构重新进行了一次实现。&lt;code&gt;await()&lt;/code&gt;主要使用了两个队列：同步等待队列和条件等待队列。我们先假设有两个线程thread-1和thread-2调用了下面的代码中的&lt;code&gt;process()&lt;/code&gt;方法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;ReentrantLock lock = new ReentrantLock();
Condition condition = lock.newCondition();

public void process(){
    try{
        lock.lock();
        condition.await();
        // 省略其他逻辑...
    }finally{
        lock.unlock();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ReentrantLock&lt;/code&gt;使用的是AQS独占模式的实现，因此在调用&lt;code&gt;lock()&lt;/code&gt;方法的时候，同步等待队列的一个瞬时快照(假设线程thread-1先加入同步等待队列)可能如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/201904/j-a-q-s-14.png&quot; alt=&quot;j-a-q-s-14.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接着，线程thread-1所在节点是头节点的后继节点，获取锁成功，它解除阻塞后可以调用&lt;code&gt;await()&lt;/code&gt;方法，这个时候会释放同步等待队列中的所有等待节点，也就是线程thread-2所在的节点也被释放，因此线程thread-2也会调用&lt;code&gt;await()&lt;/code&gt;方法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/201904/j-a-q-s-15.png&quot; alt=&quot;j-a-q-s-15.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;只要有线程能够到达&lt;code&gt;await()&lt;/code&gt;方法，那么原来的同步器中的同步等待队列就会释放所有阻塞节点，表现为释放锁，然后这些释放掉的节点会加入到等待队列中，等待队列中的节点也是阻塞的，这个时候只有通过&lt;code&gt;signal()&lt;/code&gt;或者&lt;code&gt;signalAll()&lt;/code&gt;进行&lt;strong&gt;队列元素转移&lt;/strong&gt;才有机会唤醒阻塞的线程。因此接着看&lt;code&gt;signal()&lt;/code&gt;和&lt;code&gt;signalAll()&lt;/code&gt;的源码实现：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 从等待队列中移动一个等待时间最长的线程(如果过存在的话)到锁同步等待队列中
public final void signal() {
    // 判断当前线程是否和独占线程一致，其实就是此操作需要在锁代码块中执行
    if (!isHeldExclusively())
        throw new IllegalMonitorStateException();
    Node first = firstWaiter;
    if (first != null)
        doSignal(first);
}

// 基于第一个等待节点进行Signal操作
private void doSignal(Node first) {
    do {
        // 首节点的下一个等待节点为空，说明只剩下一个等待节点
        if ( (firstWaiter = first.nextWaiter) == null)
            lastWaiter = null;
        // 当前处理节点从链表从移除    
        first.nextWaiter = null;
    } while (!transferForSignal(first) &amp;amp;&amp;amp; (first = firstWaiter) != null);
}

// 唤醒的转换操作
final boolean transferForSignal(Node node) {
    // CAS更新节点状态由CONDITION到0，更新失败则返回false不唤醒
    if (!node.compareAndSetWaitStatus(Node.CONDITION, 0))
        return false;
    // 节点作为新节点重新加入到同步等待队列
    Node p = enq(node);
    int ws = p.waitStatus;
    // 取消或者更新节点等待状态为SIGNAL的节点需要解除阻塞进行重新同步，这里的操作只针对取消和状态异常的节点
    if (ws &amp;gt; 0 || !p.compareAndSetWaitStatus(ws, Node.SIGNAL))
        LockSupport.unpark(node.thread);
    return true;
}

// 从等待队列中移动所有等待时间最长的线程(如果过存在的话)到锁同步等待队列中
public final void signalAll() {
    if (!isHeldExclusively())
        throw new IllegalMonitorStateException();
    Node first = firstWaiter;
        if (first != null)
        doSignalAll(first);
}

// 基于第一个等待节点进行SignalAll操作
private void doSignalAll(Node first) {
    // 置空lastWaiter和firstWaiter
    lastWaiter = firstWaiter = null;
    do {
        // 获取下一个等待节点
        Node next = first.nextWaiter;
        // 当前处理节点从链表从移除
        first.nextWaiter = null;
        // 处理当前节点
        transferForSignal(first);
        // 更新中间引用
        first = next;
    } while (first != null);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实&lt;code&gt;signal()&lt;/code&gt;或者&lt;code&gt;signalAll()&lt;/code&gt;会对取消的节点或者短暂中间状态的节点进行解除阻塞，但是正常情况下，它们的操作结果是把阻塞等待时间最长的一个或者所有节点重新加入到AQS的同步等待队列中。例如，上面的例子调用&lt;code&gt;signal()&lt;/code&gt;方法后如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/201904/j-a-q-s-16.png&quot; alt=&quot;j-a-q-s-16.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样子，相当于线程thread-1重新加入到AQS同步等待队列中，并且开始竞争头节点，一旦竞争成功，就能够解除阻塞。这个时候从逻辑上看，&lt;code&gt;signal()&lt;/code&gt;方法最终解除了对线程thread-1的阻塞。&lt;code&gt;await()&lt;/code&gt;的其他变体方法的原理是类似的，这里因为篇幅原因不再展开。这里小结一下&lt;code&gt;Condition&lt;/code&gt;的显著特点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1、同时依赖两个同步等待队列，一个是AQS提供，另一个是&lt;code&gt;ConditionObject&lt;/code&gt;提供的。&lt;/li&gt;
&lt;li&gt;2、&lt;code&gt;await()&lt;/code&gt;方法会释放AQS同步等待队列中的阻塞节点，这些节点会加入到条件队列中进行阻塞。&lt;/li&gt;
&lt;li&gt;3、&lt;code&gt;signal()&lt;/code&gt;或者&lt;code&gt;signalAll()&lt;/code&gt;会把条件队列中的节点重新加入AQS同步等待队列中，并不解除正常节点的阻塞状态。&lt;/li&gt;
&lt;li&gt;4、接第3步，这些进入到AQS同步等待队列的节点会重新竞争成为头节点，其实也就是前面分析过的独占模式下的AQS的运作原理。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;取消获取资源cancelacquire&quot;&gt;取消获取资源(cancelAcquire)&lt;/h2&gt;
&lt;p&gt;新节点加入等待队列失败导致任何类型的异常或者带超时版本的API调用的时候剩余超时时间小于等于零的时候，就会调用&lt;code&gt;cancelAcquire()&lt;/code&gt;方法，用于取消该节点对应节点获取资源的操作。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 取消节点获取资源的操作
private void cancelAcquire(Node node) {
    // 节点为null直接返回
    if (node == null)
        return;
    // 置空节点持有的线程，因为此时节点线程已经发生中断
    node.thread = null;
    Node pred = node.prev;
    // 这个循环是为了获取当前节点的上一个不为取消状态的节点，也就是中间如果发生了取消的节点都直接断开
    while (pred.waitStatus &amp;gt; 0)
        node.prev = pred = pred.prev;
    // 保存当前节点的上一个不为取消状态的节点的后继节点    
    Node predNext = pred.next;
    // 当前节点等待状态更新为CANCELLED
    node.waitStatus = Node.CANCELLED;
    // 如果当前节点为尾节点，则直接更新尾节点为当前节点的上一个不为取消状态的节点
    if (node == tail &amp;amp;&amp;amp; compareAndSetTail(node, pred)) {
         // 然后更新该节点的后继节点为null，因为它已经成为新的尾节点
         pred.compareAndSetNext(predNext, null);
    } else {
        int ws;
        // 当前节点的上一个不为取消状态的节点已经不是头节点的情况，需要把当前取消的节点从AQS同步等待队列中断开
        if (pred != head &amp;amp;&amp;amp;
            ((ws = pred.waitStatus) == Node.SIGNAL || (ws &amp;lt;= 0 &amp;amp;&amp;amp; pred.compareAndSetWaitStatus(ws, Node.SIGNAL))) &amp;amp;&amp;amp; pred.thread != null) {
            Node next = node.next;
            if (next != null &amp;amp;&amp;amp; next.waitStatus &amp;lt;= 0)
                pred.compareAndSetNext(predNext, next);
        } else {
            // 当前节点的上一个不为取消状态的节点已经是头节点，相当于头节点之后的节点都是取消，需要唤醒当前节点的后继节点
            unparkSuccessor(node);
        }
        // 节点后继节点设置为自身，那么就不会影响后继节点
        node.next = node;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;cancelAcquire()&lt;/code&gt;方法有多处调用，主要包括下面的情况：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1、节点线程在阻塞过程中主动中断的情况下会调用。&lt;/li&gt;
&lt;li&gt;2、&lt;code&gt;acquire&lt;/code&gt;的处理过程发生任何异常的情况下都会调用，包括&lt;code&gt;tryAcquire()&lt;/code&gt;、&lt;code&gt;tryAcquireShared()&lt;/code&gt;等。&lt;/li&gt;
&lt;li&gt;3、新节点加入等待队列失败导致任何类型的异常或者带超时版本的API调用的时候剩余超时时间小于等于零的时候。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;cancelAcquire()&lt;/code&gt;主要作用是把取消的节点移出同步等待队列，必须时候需要进行后继节点的唤醒。&lt;/p&gt;
&lt;h2 id=&quot;实战篇&quot;&gt;实战篇&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;AQS&lt;/code&gt;是一个抽象的同步器基础框架，其实我们也可以直接使用它实现一些高级的并发框架。下面基于&lt;code&gt;AQS&lt;/code&gt;实现一些非内建的功能，这两个例子来自于&lt;code&gt;AQS&lt;/code&gt;的注释中。&lt;/p&gt;
&lt;h3 id=&quot;metux&quot;&gt;metux&lt;/h3&gt;
&lt;p&gt;大学C语言课程中经常提及到的只有一个资源的metux(互斥区)，也就是说，同一个时刻，只能有一个线程获取到资源，其他获取资源的线程需要阻塞等待到前一个线程释放资源。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Metux implements Lock, Serializable {

    private static class Sync extends AbstractQueuedSynchronizer {

        @Override
        protected boolean tryAcquire(int arg) {
            assert 1 == arg;
            if (compareAndSetState(0, 1)) {
                setExclusiveOwnerThread(Thread.currentThread());
                return true;
            }
            return false;
        }

        @Override
        protected boolean tryRelease(int arg) {
            assert 1 == arg;
            if (!isHeldExclusively()) {
                throw new IllegalMonitorStateException();
            }
            setExclusiveOwnerThread(null);
            setState(0);
            return true;
        }

        public Condition newCondition() {
            return new ConditionObject();
        }

        public boolean isLocked() {
            return getState() != 0;
        }

        @Override
        public boolean isHeldExclusively() {
            return getExclusiveOwnerThread() == Thread.currentThread();
        }

        private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException {
            s.defaultReadObject();
            setState(0);
        }
    }

    private final Sync sync = new Sync();

    @Override
    public void lock() {
        sync.acquire(1);
    }

    @Override
    public void lockInterruptibly() throws InterruptedException {
        sync.acquireInterruptibly(1);
    }

    @Override
    public boolean tryLock() {
        return sync.tryAcquire(1);
    }

    @Override
    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {
        return sync.tryAcquireNanos(1, unit.toNanos(time));
    }

    public boolean isLocked() {
        return sync.isLocked();
    }

    public boolean isHeldByCurrentThread() {
        return sync.isHeldExclusively();
    }

    @Override
    public void unlock() {
        sync.release(1);
    }

    @Override
    public Condition newCondition() {
        return sync.newCondition();
    }

    public static void main(String[] args) throws Exception {
        final Metux metux = new Metux();
        new Thread(() -&amp;gt; {
            metux.lock();
            System.out.println(String.format(&quot;%s-thread-1获取锁成功休眠3秒...&quot;, LocalDateTime.now()));
            try {
                Thread.sleep(3000);
            } catch (InterruptedException e) {
                //ignore
            }
            metux.unlock();
            System.out.println(String.format(&quot;%s-thread-1获解锁成功...&quot;, LocalDateTime.now()));
            return;
        }, &quot;thread-1&quot;).start();
        new Thread(() -&amp;gt; {
            metux.lock();
            System.out.println(String.format(&quot;%s-thread-2获取锁成功...&quot;,LocalDateTime.now()));
            return;
        }, &quot;thread-2&quot;).start();
        Thread.sleep(Integer.MAX_VALUE);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;某个时间的某次运行结果如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;2019-04-07T11:49:27.858791200-thread-1获取锁成功休眠3秒...
2019-04-07T11:49:30.876567-thread-2获取锁成功...
2019-04-07T11:49:30.876567-thread-1获解锁成功...&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;二元栅栏&quot;&gt;二元栅栏&lt;/h3&gt;
&lt;p&gt;二元栅栏是&lt;code&gt;CountDownLatch&lt;/code&gt;的简化版，只允许一个线程阻塞，由另一个线程负责唤醒。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class BooleanLatch {

    private static class Sync extends AbstractQueuedSynchronizer {

        boolean isSignalled() {
            return getState() != 0;
        }

        @Override
        protected int tryAcquireShared(int ignore) {
            return isSignalled() ? 1 : -1;
        }

        @Override
        protected boolean tryReleaseShared(int ignore) {
            setState(1);
            return true;
        }
    }

    private final Sync sync = new Sync();

    public boolean isSignalled() {
        return sync.isSignalled();
    }

    public void signal() {
        sync.releaseShared(1);
    }

    public void await() throws InterruptedException {
        sync.acquireSharedInterruptibly(1);
    }

    public static void main(String[] args) throws Exception {
        BooleanLatch latch = new BooleanLatch();
        new Thread(()-&amp;gt; {
            try {
                Thread.sleep(3000);
            } catch (InterruptedException e) {
                //ignore
            }
            latch.signal();
        }).start();
        System.out.println(String.format(&quot;[%s]-主线程进入阻塞...&quot;, LocalDateTime.now()));
        latch.await();
        System.out.println(String.format(&quot;[%s]-主线程进被唤醒...&quot;, LocalDateTime.now()));
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;某个时间的某次运行结果如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;[2019-04-07T11:55:12.647816200]-主线程进入阻塞...
[2019-04-07T11:55:15.632088]-主线程进被唤醒...&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;在JUC的重要并发类库或者容器中，&lt;code&gt;AQS&lt;/code&gt;起到了基础框架的作用，理解同步器的实现原理，有助于理解和分析其他并发相关类库的实现。这篇文章前后耗费了接近1个月时间编写，DEBUG过程最好使用多线程断点，否则很难模拟真实的情况。&lt;code&gt;AQS&lt;/code&gt;里面的逻辑是相对复杂的，很敬佩并发大师Douglas S. Lea如此精巧的类库设计。&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;《The Art of Multiprocessor Programming》&lt;/li&gt;
&lt;li&gt;《The java.util.concurrent Synchronizer Framework》&lt;/li&gt;
&lt;li&gt;JDK11相关源码&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;(本文完 c-a-30-d e-a-20190407)&lt;/p&gt;
</description>
<pubDate>Sun, 07 Apr 2019 04:28:00 +0000</pubDate>
<dc:creator>throwable</dc:creator>
<og:description>JUC同步器框架AbstractQueuedSynchronizer源码图文分析 前提 Doug Lea大神在编写JUC( )包的时候引入了 ，Abstract Queued Synchronizer</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/throwable/p/10664926.html</dc:identifier>
</item>
<item>
<title>原型模式 - 杰克·斯帕罗、</title>
<link>http://www.cnblogs.com/JackSparrow-/p/10663289.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JackSparrow-/p/10663289.html</guid>
<description>&lt;p&gt;原型模式是用于创建重复的对象，同时又能保证性能，通过复制现有实例来创建新的实例，无需知道类的信息。&lt;/p&gt;
&lt;p&gt;与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的。&lt;/p&gt;
&lt;p&gt;那么java中是如何实现原型模式的呢？原型模式的本质就是克隆，拷贝一个一模一样的对象。&lt;/p&gt;
&lt;p&gt;java中的实现原型模式可以分为两种，一种是浅拷贝，一种是深拷贝。&lt;/p&gt;
&lt;p&gt;浅拷贝实现原型模式就是实现了一个克隆接口，该接口就是用于创建当前对象的克隆。下面通过代码来实现浅拷贝。&lt;/p&gt;
&lt;p&gt; 首先定义一个类，这个类实现Cloneable接口里面的clone()方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Person &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Cloneable {

    String name;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] a;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object clone() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; CloneNotSupportedException{
        Object obj &lt;/span&gt;= &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.clone();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; obj;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String name) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getAge() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; age;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setAge(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; age) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] getA() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; a;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setA(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] a) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.a =&lt;span&gt; a;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Person{&quot; +
                &quot;name='&quot; + name + '\'' +
                &quot;, age=&quot; + age +
                &quot;, a=&quot; + Arrays.toString(a) +
                '}'&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; CloneNotSupportedException{
        Person p &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person();
        p.setAge(&lt;/span&gt;10&lt;span&gt;);
        p.setName(&lt;/span&gt;&quot;Jack&quot;&lt;span&gt;);
        p.setA(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[]{1&lt;span&gt;});
        System.out.println(&lt;/span&gt;&quot;克隆前p的值：&quot;+&lt;span&gt;p);
        Person p2 &lt;/span&gt;=&lt;span&gt; (Person)p.clone();
        System.out.println(&lt;/span&gt;&quot;克隆前未修改p2的值:&quot;+&lt;span&gt;p2);
        p2.setAge(&lt;/span&gt;11&lt;span&gt;);
        p2.setName(&lt;/span&gt;&quot;Tom&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;[] a =&lt;span&gt; p2.getA();
        a[&lt;/span&gt;0] = 2&lt;span&gt;;
        p2.setA(a);
        System.out.println(&lt;/span&gt;&quot;克隆后修改p2的值，p2的值为:&quot;+&lt;span&gt;p2);
        System.out.println(&lt;/span&gt;&quot;克隆后修改p2的值，p的值为:&quot;+&lt;span&gt;p);
    }

克隆前p的值：Person{name&lt;/span&gt;='Jack', age=10, a=[1&lt;span&gt;]}
克隆前未修改p2的值:Person{name&lt;/span&gt;='Jack', age=10, a=[1&lt;span&gt;]}
克隆后修改p2的值:Person{name&lt;/span&gt;='Tom', age=11, a=[2&lt;span&gt;]}
克隆后修改p2的值，p的值为:Person{name&lt;/span&gt;='Jack', age=10, a=[2]}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过上面这一段代码，我们发现，修改由p克隆出来的p2的String和int类型的值，p的对应的类型的值并没有发生改变，但是修改引用类型int[] 的值时，p对应的类型也发生了改变，这就说明，对于基本类型而言，浅拷贝，对值类型的成员变量进行值的复制，对于引用类型的变量进行引用的复制，不复制引用的对象。String是一个特殊的类型，它的数据是放在常量池中的，对p2的修改是将它String类型的引用从“Jack”指向了“Tom”，而p的String类型的指向仍然是“Jack”，并没有发生改变。&lt;/p&gt;
&lt;p&gt;那么，有很多时候，我并不希望对拷贝对象的修改会影响到原来的对象，这时候我们就需要进行深拷贝了。&lt;/p&gt;
&lt;p&gt;深拷贝：对值类型的成员变量进行值拷贝，对引用类型的变量进行引用的复制，并且复制引用的对象。简单点来说，所谓的深拷贝就是对于那些只是拷贝引用而不拷贝对象的属性进行单独拷贝。&lt;/p&gt;
&lt;p&gt;第一种方法：将引用类型的对象再单独拷贝一下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Person &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Cloneable {

    String name;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] a;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Person clone() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; CloneNotSupportedException{

        Person person &lt;/span&gt;= (Person)&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.clone();
        person.a &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.a.clone();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; person;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String name) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getAge() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; age;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setAge(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; age) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] getA() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; a;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setA(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] a) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.a =&lt;span&gt; a;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Person{&quot; +
                &quot;name='&quot; + name + '\'' +
                &quot;, age=&quot; + age +
                &quot;, a=&quot; + Arrays.toString(a) +
                '}'&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;直接在clone()方法中将int[]数组类型的引用单独再拷贝一份，即可实现深拷贝。&lt;/p&gt;
&lt;p&gt;第二种方法：使用javaIO流的方式，将对象序列化为字节序列后，默认会将该对象的整个对象图进行序列化，再通过反序列即可完美地实现深拷贝。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception{
        Person person &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person();
        person.setAge(&lt;/span&gt;10&lt;span&gt;);
        person.setName(&lt;/span&gt;&quot;Jack&quot;&lt;span&gt;);
        person.setA(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[]{1&lt;span&gt;});

        ByteArrayOutputStream bos &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ByteArrayOutputStream();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ObjectOutputStream 对象输出流&lt;/span&gt;
        ObjectOutputStream oos = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ObjectOutputStream(bos);
        oos.writeObject(person);
        oos.flush();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ObjectOutputStream 对象输入流&lt;/span&gt;
        ObjectInputStream ois = &lt;span&gt;new&lt;/span&gt; ObjectInputStream(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ByteArrayInputStream(bos.toByteArray()));
        Person person2 &lt;/span&gt;=&lt;span&gt; (Person)ois.readObject();
        System.out.println(&lt;/span&gt;&quot;深拷贝后修改person2的值:&quot;+&lt;span&gt;person2);
        person2.setName(&lt;/span&gt;&quot;Tom&quot;&lt;span&gt;);
        person2.setAge(&lt;/span&gt;12&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;[] a =&lt;span&gt; person2.getA();
        a[&lt;/span&gt;0] = 3&lt;span&gt;;
        person2.setA(a);
        System.out.println(&lt;/span&gt;&quot;深拷贝后修改person2的值:&quot;+&lt;span&gt;person2);
        System.out.println(&lt;/span&gt;&quot;深拷贝后修改person2的值，person的值为：&quot;+&lt;span&gt;person);
    }

深拷贝后修改person2的值:Person{name&lt;/span&gt;='Jack', age=10, a=[1&lt;span&gt;]}
深拷贝后修改person2的值:Person{name&lt;/span&gt;='Tom', age=12, a=[3&lt;span&gt;]}
深拷贝后修改person2的值，person的值为：Person{name&lt;/span&gt;='Jack', age=10, a=[1]}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们看到，深拷贝后，修改person2的值并未影响到person的值。需要注意的是，如果有属性使用transient关键词修饰的话，这个属性是不会被序列化的。&lt;/p&gt;

</description>
<pubDate>Sun, 07 Apr 2019 03:39:00 +0000</pubDate>
<dc:creator>杰克·斯帕罗、</dc:creator>
<og:description>原型模式是用于创建重复的对象，同时又能保证性能，通过复制现有实例来创建新的实例，无需知道类的信息。 与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的。 那么ja</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/JackSparrow-/p/10663289.html</dc:identifier>
</item>
<item>
<title>Jmeter（1）：使用TCP取样器与socket接口进行简单通信 - 清均qj</title>
<link>http://www.cnblogs.com/qjqj0-0/p/10664398.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qjqj0-0/p/10664398.html</guid>
<description>&lt;p&gt;一个小任务：服务器与客户端连接，每次发送50个随机生成的字符，两秒发送一次&lt;/p&gt;
&lt;p&gt;失败过太多次，然后昨晚终于跑通了，心情激动，于是清均第一篇博客就诞生了。&lt;/p&gt;
&lt;p&gt;之前不了解jmeter，想过单纯用java编写服务器和客户端，但代码多。然后老师介绍了jmeter。还用过tomcat做接收端，但试了两天都不行。&lt;/p&gt;
&lt;p&gt;最后成功的方法：&lt;/p&gt;
&lt;p&gt;用java写服务器，jmeter模拟客户端。&lt;/p&gt;
&lt;p&gt;先介绍java写服务器这方面，仿照教材写了一个简单的服务器。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; java.net.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; java.io.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ServerSocketTest {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt;&lt;span&gt; BufferedReader reader;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt;&lt;span&gt; ServerSocket server;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; Socket socket;                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建三个对象，服务器，套接字，还有用来读取的reader&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;void&lt;/span&gt;&lt;span&gt; getserver() {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 server = &lt;span&gt;new&lt;/span&gt; ServerSocket(8055);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;不能重复创建port一样的ServerSocket,否则会报错&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;                 System.out.println(&quot;服务器套接字已经创建成功&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;) {                                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;true的意思是套接字是连接状态&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;                     System.out.println(&quot;等待客户机的连接&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                     socket = server.accept();   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;等待客户机的连接，若连接，则创建一套接字&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;                     reader = &lt;span&gt;new&lt;/span&gt; BufferedReader(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; InputStreamReader(socket.getInputStream()));
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;                    getClientMessage();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             }&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;                e.printStackTrace();
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; getClientMessage() {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取客户端信息&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt;                  System.out.println(&quot;客户机：&quot;+reader.readLine());  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;很重要的一个方法，获取客户端信息&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt;             }&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;                e.printStackTrace();
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;接收到信息就关闭&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; 
&lt;span&gt;39&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (reader !=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;                    reader.close();
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (socket !=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;                    socket.close();
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; 
&lt;span&gt;46&lt;/span&gt;             }&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;                e.printStackTrace();
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; 
&lt;span&gt;51&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;                 ServerSocketTest tcp = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServerSocketTest();
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;                tcp.getserver();
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; 
&lt;span&gt;55&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; 
&lt;span&gt;57&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;启动这个类的main函数，就相当于启动了这个服务器。如下图所示。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1648514/201904/1648514-20190407102751613-953936447.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Jmeter部分：&lt;/p&gt;
&lt;p&gt;Jmeter的下载安装配置我就不详细介绍了，网上可以找到很多教程。&lt;/p&gt;
&lt;p&gt;打开bin文件夹，打开名为ApacheJmeter的jar包。等待jmeter启动。&lt;/p&gt;
&lt;p&gt;会看到一个测试计划，可以重命名。&lt;/p&gt;
&lt;p&gt;右键测试计划，新建线程组——右键线程组--添加--sampler--tcp取样器——右键tcp取样器，添加监听器。&lt;/p&gt;
&lt;p&gt;一个框架大概就做好了。&lt;/p&gt;
&lt;p&gt;在线程组里设置线程数，总时间和循环次数，我分别设置的是4，8，1&lt;/p&gt;
&lt;p&gt;在tcp取样器中添加服务器的ip地址和端口号，设置连接和响应时间。&lt;/p&gt;
&lt;p&gt;点击左上角选项——函数助手对话框——选择功能__RandomString——长度填50，下一行输入生成字符串的范围。如1234567890qingjun，再下一行不用填。&lt;/p&gt;
&lt;p&gt;——点击生成，可以拷贝函数到tcp取样器要发送的文本里，然后按回车空一行，不然发送不成功。&lt;/p&gt;
&lt;p&gt;点击右上角的黄色警示图标可以看到jmeter运行情况。&lt;/p&gt;
&lt;p&gt;点击绿色三角启动，或者左上角运行--启动。&lt;/p&gt;
&lt;p&gt;jmeter：&lt;/p&gt;
&lt;p&gt;结果树：绿色√表示成功了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1648514/201904/1648514-20190407105321618-1270153911.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;汇总报告：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1648514/201904/1648514-20190407105733419-1167935154.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;服务器显示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1648514/201904/1648514-20190407105353289-1329599888.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;由简入繁，但最后明白了大道至简。总之第一步成功了。&lt;/p&gt;
&lt;p&gt;开心。&lt;/p&gt;

&lt;p&gt;接下来的学习总结还会发布在博客园，希望自己能坚持下去。&lt;/p&gt;

</description>
<pubDate>Sun, 07 Apr 2019 03:08:00 +0000</pubDate>
<dc:creator>清均qj</dc:creator>
<og:description>一个小任务：服务器与客户端连接，每次发送50个随机生成的字符，两秒发送一次 失败过太多次，然后昨晚终于跑通了，心情激动，于是清均第一篇博客就诞生了。 之前不了解jmeter，想过单纯用java编写服务</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qjqj0-0/p/10664398.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core使用Jaeger实现分布式追踪 - Catcher8</title>
<link>http://www.cnblogs.com/catcher1994/p/10662999.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/catcher1994/p/10662999.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;最近我们公司的部分.NET Core的项目接入了Jaeger，也算是稍微完善了一下.NET团队的技术栈。&lt;/p&gt;
&lt;p&gt;至于为什么选择Jaeger而不是Skywalking，这个问题我只能回答，大佬们说了算。&lt;/p&gt;
&lt;p&gt;前段时间也在CSharpCorner写过一篇类似的介绍&lt;br/&gt;&lt;a href=&quot;https://www.c-sharpcorner.com/article/exploring-distributed-tracing-using-asp-net-core-and-jaeger/&quot;&gt;Exploring Distributed Tracing Using ASP.NET Core And Jaeger&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;下面回到正题，我们先看一下Jaeger的简介&lt;/p&gt;
&lt;h2 id=&quot;jaeger的简单介绍&quot;&gt;Jaeger的简单介绍&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/558945/201904/558945-20190406212745042-44304154.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Jaeger是Uber开源的一个分布式追踪的工具，主要为基于微服务的分布式系统提供监测和故障诊断。包含了下面的内容&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Distributed context propagation&lt;/li&gt;
&lt;li&gt;Distributed transaction monitoring&lt;/li&gt;
&lt;li&gt;Root cause analysis&lt;/li&gt;
&lt;li&gt;Service dependency analysis&lt;/li&gt;
&lt;li&gt;Performance / latency optimization&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面就通过一个简单的例子来体验一下。&lt;/p&gt;
&lt;h2 id=&quot;示例&quot;&gt;示例&lt;/h2&gt;
&lt;p&gt;在这个示例的话，我们只用了&lt;code&gt;jaegertracing/all-in-one&lt;/code&gt;这个docker的镜像来搭建，因为是本地的开发测试环境，不需要搭建额外的存储，这个感觉还是比较贴心的。&lt;/p&gt;
&lt;p&gt;我们会用到两个主要的nuget包&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;Jaeger&lt;/code&gt; 这个是官方的client&lt;/li&gt;
&lt;li&gt;&lt;code&gt;OpenTracing.Contrib.NetCore.Unofficial&lt;/code&gt; 这个是对.NET Core探针的处理，从&lt;a href=&quot;https://github.com/opentracing-contrib/csharp-netcore/&quot;&gt;opentracing-contrib/csharp-netcore&lt;/a&gt;这个项目移植过来的(这个项目并不活跃，只能自己做扩展)&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;然后我们会建两个API的项目，一个是&lt;code&gt;AService&lt;/code&gt;，一个是&lt;code&gt;BService&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;其中&lt;code&gt;BService&lt;/code&gt;会提供一个接口，从缓存中读数据，如果读不到就通过EF Core去从sqlite中读，然后写入缓存，最后再返回结果。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;AService&lt;/code&gt; 会通过HttpClient去调用&lt;code&gt;BService&lt;/code&gt;的接口，从而会形成调用链。&lt;/p&gt;
&lt;p&gt;开始之前，我们先把&lt;code&gt;docker-compose.yml&lt;/code&gt;配置一下&lt;/p&gt;
&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;version: '3.4'

services:
  aservice:
    image: ${DOCKER_REGISTRY-}aservice
    build:
      context: .
      dockerfile: AService/Dockerfile
    ports:
      - &quot;9898:80&quot;  
    depends_on:
      - jagerservice
      - bservice
    networks:  
      backend:
      
  bservice:
    image: ${DOCKER_REGISTRY-}bservice
    build:
      context: .
      dockerfile: BService/Dockerfile
    ports:
      - &quot;9899:80&quot;
    depends_on:
      - jagerservice    
    networks:  
      backend:
      
  jagerservice:
    image: jaegertracing/all-in-one:latest
    environment:
      - COLLECTOR_ZIPKIN_HTTP_PORT=9411 
    ports:
      - &quot;5775:5775/udp&quot;
      - &quot;6831:6831/udp&quot;
      - &quot;6832:6832/udp&quot;
      - &quot;5778:5778&quot;
      - &quot;16686:16686&quot;
      - &quot;14268:14268&quot;
      - &quot;9411:9411&quot;
    networks:  
      backend:
      
networks:  
  backend:      
    driver: bridge&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后就在两个项目的&lt;code&gt;Startup&lt;/code&gt;加入下面的一些配置，主要是和&lt;code&gt;Jaeger&lt;/code&gt;相关的。&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;public void ConfigureServices(IServiceCollection services)
{
    // others ....
    
    // Adds opentracing
    services.AddOpenTracing();

    // Adds the Jaeger Tracer.
    services.AddSingleton&amp;lt;ITracer&amp;gt;(serviceProvider =&amp;gt;
    {
        string serviceName = serviceProvider.GetRequiredService&amp;lt;IHostingEnvironment&amp;gt;().ApplicationName;
        
        var loggerFactory = serviceProvider.GetRequiredService&amp;lt;ILoggerFactory&amp;gt;();
        var sampler = new ConstSampler(sample: true);
        var reporter = new RemoteReporter.Builder()
                .WithLoggerFactory(loggerFactory)
                .WithSender(new UdpSender(&quot;jagerservice&quot;, 6831, 0))
                .Build();

        var tracer = new Tracer.Builder(serviceName)
            .WithLoggerFactory(loggerFactory)
            .WithSampler(sampler)
            .WithReporter(reporter)
            .Build();

        GlobalTracer.Register(tracer);

        return tracer;
    });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;这里需要注意的是我们要根据情况来选择sampler，演示这里用了最简单的ConstSampler。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;回到&lt;code&gt;BService&lt;/code&gt;这个项目，我们添加SQLite和EasyCaching的相关支持。&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;public void ConfigureServices(IServiceCollection services)
{
    // Adds an InMemory-Sqlite DB to show EFCore traces.
    services
        .AddEntityFrameworkSqlite()
        .AddDbContext&amp;lt;BDbContext&amp;gt;(options =&amp;gt;
        {
            var connectionStringBuilder = new SqliteConnectionStringBuilder
            {
                DataSource = &quot;:memory:&quot;,
                Mode = SqliteOpenMode.Memory,
                Cache = SqliteCacheMode.Shared
            };
            var connection = new SqliteConnection(connectionStringBuilder.ConnectionString);

            connection.Open();
            connection.EnableExtensions(true);

            options.UseSqlite(connection);
        });

    // Add EasyCaching Inmemory provider.
    services.AddEasyCaching(options =&amp;gt;
    {
        options.UseInMemory(&quot;m1&quot;);
    });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后控制器上面就比较简单了。&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;// GET api/values
[HttpGet]
public async Task&amp;lt;IActionResult&amp;gt; GetAsync()
{
    var provider = _providerFactory.GetCachingProvider(&quot;m1&quot;);

    var obj = await provider.GetAsync(&quot;mykey&quot;, async () =&amp;gt; await _dbContext.DemoObjs.ToListAsync(), TimeSpan.FromSeconds(30));

    return Ok(obj);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;AService&lt;/code&gt;就是通过HttpClient去调用上面的这个接口即可。&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;// GET api/values
[HttpGet]
public async Task&amp;lt;string&amp;gt; GetAsync()
{
    var res = await GetDemoAsync();
    return res;
}
        
private async Task&amp;lt;string&amp;gt; GetDemoAsync()
{
    var client = _clientFactory.CreateClient();

    var request = new HttpRequestMessage
    {
        Method = HttpMethod.Get,
        RequestUri = new Uri($&quot;http://bservice/api/values&quot;)
    };

    var response = await client.SendAsync(request);

    response.EnsureSuccessStatusCode();

    var body = await response.Content.ReadAsStringAsync();

    return body;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到这里的话，代码这块是ok了，下面就来看看效果。&lt;/p&gt;
&lt;p&gt;先通过&lt;code&gt;http://localhost:9898/api/values/&lt;/code&gt;访问几次&lt;code&gt;AService&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;大概能得到一个这样的结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/558945/201904/558945-20190406213011061-1923126222.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后去Jaeger的界面上我们可以看到，两个服务已经注册上来了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/558945/201904/558945-20190406213129372-2110237460.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选A，B其中一个去搜索，就可以看到下面的结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/558945/201904/558945-20190406213312195-1742927969.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个就最外层，能看到这些请求一些宏观的信息。&lt;/p&gt;
&lt;p&gt;我们选界面上最后一个，也就是第一个请求，进去看看细节&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/558945/201904/558945-20190406213357566-1210415510.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上面这个图大概也能看出来，做了一些什么操作，请求来到&lt;code&gt;AService&lt;/code&gt;，它就发起了HTTP请求到&lt;code&gt;BService&lt;/code&gt;，&lt;code&gt;BService&lt;/code&gt;则是先通过EasyCaching去取缓存，显然缓存中没数据，它就去读数据库了。&lt;/p&gt;
&lt;p&gt;和另外的请求对比一下，可以发现是少了查数据库这一步操作的。这也是为什么上面的是10个span，而下面的才8个。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/558945/201904/558945-20190406213442479-411036847.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再来看看两个请求的对比图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/558945/201904/558945-20190406213506925-1399536480.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图中那些红色和绿色的块就是两个请求的差异点了。&lt;/p&gt;
&lt;p&gt;回去看看其他细节，可以发现类似下面的内容&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/558945/201904/558945-20190406213533041-1233380308.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有很多日志相关的东西，这些东西在这里可能没有太多实际的作用，我们可以通过调整日志的级别来不让它写入到Jaeger中。&lt;/p&gt;
&lt;p&gt;或者是通过下面的方法来过滤&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;services.AddOpenTracing(new System.Collections.Generic.Dictionary&amp;lt;string,LogLevel&amp;gt;
{
    {&quot;AService&quot;, LogLevel.Information}
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后就是依赖图了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/558945/201904/558945-20190406213641333-867609474.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;写在最后&quot;&gt;写在最后&lt;/h2&gt;
&lt;p&gt;虽说Jaeger用起来挺简单的，但是也是有点美中不足的，不过这个锅不应该是Jaeger来背的，主要还是很多我们常用的库没有直接的支持&lt;code&gt;Diagnostic&lt;/code&gt;，所以能监控到的东西还是略少。&lt;/p&gt;
&lt;p&gt;不过在github发现了&lt;a href=&quot;https://github.com/caozhiyuan/ClrProfiler.Trace&quot;&gt;ClrProfiler.Trace&lt;/a&gt;这个项目，可以通过clrprofiler来解决上面的问题。&lt;/p&gt;
&lt;p&gt;最后是本文的示例代码&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/catcherwong-archive/2019/tree/master/04/JaegerDemo&quot;&gt;JaegerDemo&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 07 Apr 2019 02:16:00 +0000</pubDate>
<dc:creator>Catcher8</dc:creator>
<og:description>ASP.NET Core使用Jaeger实现分布式追踪</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/catcher1994/p/10662999.html</dc:identifier>
</item>
<item>
<title>TensorFlow从1到2（一）续讲从锅炉工到AI专家 - 俺踏月色而来</title>
<link>http://www.cnblogs.com/andrewwang/p/10664168.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/andrewwang/p/10664168.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;http://files.17study.com.cn/201801/ml/tensorflowlogo.jpg&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;引言&quot;&gt;引言&lt;/h4&gt;
&lt;p&gt;原来引用过一个段子，这里还要再引用一次。是关于苹果的。大意是，苹果发布了新的开发语言Swift，有非常多优秀的特征，于是很多时髦的程序员入坑学习。不料，经过一段头脑体操一般的勤学苦练，发现使用Swift做开发，不仅要学习Swift，还要学习Swift2、Swift3、Swift4...&lt;br/&gt;后来我发现，这个段子很有普遍性，并非仅仅苹果如此，今天的TensorFlow 2.0也有点这样的趋势。以至于我不得不专门写一个课程的续集，来面对使用新版本软件开始机器学习的读者。&lt;br/&gt;事实上大多具有革命性的公司都是这样，一方面带来令人兴奋的新特征，另一方面则是高企不落的学习成本。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.17study.com.cn/2018/01/08/tensorFlow-series-1/&quot;&gt;《从锅炉工到AI专家》&lt;/a&gt;一文中，已经对机器学习的基本概念做了很详细的介绍。所以在这里我们就省掉闲言絮语，直接从TensorFlow2.0讲起。&lt;br/&gt;当然即便没有看过这个系列，假设你对TensorFlow 1.x很熟悉，也可以直接通过阅读本文，了解从TensorFlow 1.x迁移至2.x的知识。&lt;br/&gt;如果你不了解机器学习的概念，试图通过直接学习TensorFlow 2.0开始AI开发，那可能比较困难。TensorFlow只是工具。没有技能，只凭工具，你恐怕无法踏上旅程。&lt;/p&gt;
&lt;h4 id=&quot;安装&quot;&gt;安装&lt;/h4&gt;
&lt;p&gt;截至本文写作的时候，TensorFlow 2.0尚未正式的发布。pip仓库中仍然是1.13稳定版。所以如果想开始TensorFlow 2.0的学习，需要指定版本号来安装。此外由于Python2系列将于2020年元月停止官方维护，本文的示例使用Python3的代码来演示：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ pip3 install tensorflow==2.0.0-alpha0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(注: 上面$是Mac/Linux的提示符，假如用Windows,你看到的提示符应当类似C:\Users\Administrator&amp;gt;这样子。)&lt;/p&gt;
&lt;p&gt;如果希望使用GPU计算，安装的预先准备会麻烦一些，请参考这篇文档：&lt;a href=&quot;https://www.tensorflow.org/install/gpu&quot; class=&quot;uri&quot;&gt;https://www.tensorflow.org/install/gpu&lt;/a&gt;。主要是安装CUDA/cuDNN等计算平台的工具包。其中CUDA可以使用安装程序直接安装。cuDNN是压缩包，如果不打算自己编译TensorFlow的话，放置到CUDA相同目录会比较省事。&lt;br/&gt;这里提醒一下，除非自己编译TensorFlow，否则一定使用CUDA 10.0的版本，低了、高了都不成，因为官方的2.0.0-alpha0使用了CUDA 10.0的版本编译。&lt;br/&gt;此外TensorFlow的安装请使用如下命令：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ pip3 install tensorflow-gpu==2.0.0-alpha0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装完成后，可以在Python的交互模式，来确认TensorFlow正常工作：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ python3
Python 3.7.2 (default, Feb 13 2019, 13:59:29) 
[Clang 10.0.0 (clang-1000.11.45.5)] on darwin
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&amp;gt;&amp;gt;&amp;gt; import tensorflow as tf
&amp;gt;&amp;gt;&amp;gt; tf.__version__
'2.0.0-alpha0'
&amp;gt;&amp;gt;&amp;gt; &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;本文中还会用到几个第三方的python扩展库，也是在机器学习中非常常用的，建议一起安装：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ pip3 install numpy matplotlib pillow pandas seaborn sklearn&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;第一个例子房价预测&quot;&gt;第一个例子：房价预测&lt;/h4&gt;
&lt;p&gt;本示例中的源码来自于&lt;a href=&quot;http://blog.17study.com.cn/2018/01/08/tensorFlow-series-2/&quot;&gt;《从锅炉工到AI专家》系列2&lt;/a&gt;，使用了最简单的线性函数来做房价预测。原始TensorFlow 1.x/ Python 2.x代码如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;#!/usr/bin/env python 
# -*- coding=UTF-8 -*-

#本代码在mac电脑，python2.7环境测试通过
#第一行是mac/Linux系统脚本程序的标志，表示从环境参量中寻找python程序解释器来执行本脚本
#省去了每次在命令行使用 python &amp;lt;脚本名&amp;gt; 这样的执行方式
#第二行表示本脚本文本文件存盘使用的代码是utf-8,并且字符串使用的编码也是utf-8,
#在本源码中，这一点其实没有什么区别，但如果需要中文输出的时候，这一行就必须要加了。

#引入TensorFlow库
import tensorflow as tf
#引入数值计算库
import numpy as np

#使用 NumPy 生成假数据集x,代表房间的平米数，这里的取值范围是0-1的浮点数，
#原因请看正文中的说明，属于是“规范化”之后的数据
# 生成的数据共100个，式样是100行，每行1个数据
x = np.float32(np.random.rand(100,1))
#我们假设每平米0.5万元，基础费用0.7万，这个数值也是规范化之后的，仅供示例
#最终运行的结果，应当求出来0.5/0.7这两个值代表计算成功
#计算最终房价y，x和y一同当做我们的样本数据
# np.dot的意思就是向量x * 0.5
y = np.dot(x,0.5) + 0.7
#---------------------------------数据集准备完成
#以下使用TensorFlow构建数学模型，在这个过程中，
#直到调用.run之前，实际上都是构造模型，而没有真正的运行。
#这跟上面的numpy库每一次都是真正执行是截然不同的区别
# 请参考正文，我们假定房价的公式为：y=a*x+b

#tf.Variable是在TensorFlow中定义一个变量的意思
#我们这里简单起见，人为给a/b两个初始值，都是0.3，注意这也是相当于规范化之后的数值
b = tf.Variable(np.float32(0.3))
a = tf.Variable(np.float32(0.3))

#这是定义主要的数学模型，模型来自于上面的公式
#注意这里必须使用tf的公式，这样的公式才是模型
#上面使用np的是直接计算，而不是定义模型
# TensorFlow的函数名基本就是完整英文，你应当能读懂
y_value = tf.multiply(x,a) + b

# 这里是代价函数，同我们文中所讲的唯一区别是用平方来取代求绝对值，
#目标都是为了得到一个正数值，功能完全相同，
#平方计算起来会更快更容易,这种方式也称为“方差“
loss = tf.reduce_mean(tf.square(y_value - y))
# TensorFlow内置的梯度下降算法，每步长0.5
optimizer = tf.train.GradientDescentOptimizer(0.5)
# 代价函数值最小化的时候，代表求得解
train = optimizer.minimize(loss)

# 初始化所有变量，也就是上面定义的a/b两个变量
init = tf.global_variables_initializer()

#启动图
sess = tf.Session()
#真正的执行初始化变量，还是老话，上面只是定义模型，并没有真正开始执行
sess.run(init)

#重复梯度下降200次，每隔5次打印一次结果
for step in xrange(0, 200):
    sess.run(train) 
    if step % 5 == 0:
        print step, sess.run(loss),sess.run(a), sess.run(b)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码保留了原始的注释，希望如果概念已经没有问题的话，可以让你不用跑回原文去看详细讲解。&lt;br/&gt;程序使用numpy生成了一组样本集，样本集是使用线性函数生成的。随后使用TensorFlow学习这些样本，从而得到线性函数中未知的权重(Weight)和偏移(Bias)值。&lt;br/&gt;原文中已经说了，这个例子并没有什么实用价值，只是为了从基础开始讲解“机器学习”的基本原理。&lt;/p&gt;
&lt;h4 id=&quot;使用2.0中的v1兼容包来沿用1.x代码&quot;&gt;使用2.0中的v1兼容包来沿用1.x代码&lt;/h4&gt;
&lt;p&gt;TensorFlow 2.0中提供了tensorflow.compat.v1代码包来兼容原有1.x的代码，可以做到几乎不加修改的运行。社区的contrib库因为涉及大量直接的TensorFlow引用代码或者自己写的Python扩展包，所以无法使用这种模式。TensorFlow 2.0中也已经移除了contrib库，这让人很有点小遗憾的。&lt;br/&gt;使用这种方式升级原有代码，只需要把原有程序开始的TensorFlow引用:&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import tensorflow as tf&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;替换为以下两行就可以正常的继续使用：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import tensorflow.compat.v1 as tf
tf.disable_v2_behavior()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其它代码无需修改。个人觉得，如果是稳定使用中、并且没有重构意愿的代码，这种方式算的上首选。&lt;/p&gt;
&lt;h4 id=&quot;使用迁移工具来自动迁移1.x代码到2.0&quot;&gt;使用迁移工具来自动迁移1.x代码到2.0&lt;/h4&gt;
&lt;p&gt;TensorFlow 2.0中提供了命令行迁移工具，来自动的把1.x的代码转换为2.0的代码。工具使用方法如下(假设我们的程序文件名称为first-tf.py)：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;tf_upgrade_v2 --infile first-tf.py --outfile first-tf-v2.py&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;迁移工具还可以对整个文件夹的程序做升级，请参考工具自身的帮助文档。&lt;br/&gt;使用迁移工具升级的代码，实质上也是使用了tensorflow.compat.v1兼容包来提供在TensorFlow 2.0环境中执行1.x的代码。这里贴出自动转换后的新代码供你对比参考：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;#引入TensorFlow库
import tensorflow as tf
#import tensorflow.compat.v1 as tf
tf.compat.v1.disable_v2_behavior()

#引入数值计算库
import numpy as np

#使用 NumPy 生成假数据集x,代表房间的平米数，这里的取值范围是0-1的浮点数，
#原因请看正文中的说明，属于是“规范化”之后的数据
# 生成的数据共100个，式样是100行，每行1个数据
x = np.float32(np.random.rand(100,1))
#我们假设每平米0.5万元，基础费用0.7万，这个数值也是规范化之后的，仅供示例
#最终运行的结果，应当求出来0.5/0.7这两个值代表计算成功
#计算最终房价y，x和y一同当做我们的样本数据
# np.dot的意思就是向量x * 0.5
y = np.dot(x,0.5) + 0.7
#---------------------------------数据集准备完成
#以下使用TensorFlow构建数学模型，在这个过程中，
#直到调用.run之前，实际上都是构造模型，而没有真正的运行。
#这跟上面的numpy库每一次都是真正执行是截然不同的区别
# 请参考正文，我们假定房价的公式为：y=a*x+b

#tf.Variable是在TensorFlow中定义一个变量的意思
#我们这里简单起见，人为给a/b两个初始值，都是0.3，注意这也是相当于规范化之后的数值
b = tf.Variable(np.float32(0.3))
a = tf.Variable(np.float32(0.3))

#这是定义主要的数学模型，模型来自于上面的公式
#注意这里必须使用tf的公式，这样的公式才是模型
#上面使用np的是直接计算，而不是定义模型
# TensorFlow的函数名基本就是完整英文，你应当能读懂
y_value = tf.multiply(x,a) + b

# 这里是代价函数，同我们文中所讲的唯一区别是用平方来取代求绝对值，
#目标都是为了得到一个正数值，功能完全相同，
#平方计算起来会更快更容易,这种方式也称为“方差“
loss = tf.reduce_mean(input_tensor=tf.square(y_value - y))
# TensorFlow内置的梯度下降算法，每步长0.5
optimizer = tf.compat.v1.train.GradientDescentOptimizer(0.5)
# 代价函数值最小化的时候，代表求得解
train = optimizer.minimize(loss)

# 初始化所有变量，也就是上面定义的a/b两个变量
init = tf.compat.v1.global_variables_initializer()

#启动图
sess = tf.compat.v1.Session()
#真正的执行初始化变量，还是老话，上面只是定义模型，并没有真正开始执行
sess.run(init)

#重复梯度下降200次，每隔5次打印一次结果
for step in range(0, 200):
    sess.run(train) 
    if step % 5 == 0:
        print(step, sess.run(loss),sess.run(a), sess.run(b))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;转换之后，代码中的注释部分会完美的保留，喜欢用代码来代替文档的程序员可以放心。所有2.0中变更了的类或者方法，转换工具将使用tensorflow.compat.v1中的对应类或方法来替代，比如：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;optimizer = tf.compat.v1.train.GradientDescentOptimizer(0.5)
train = optimizer.minimize(loss)
init = tf.compat.v1.global_variables_initializer()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以从本质上，这种方式跟第一种方法，采用tensorflow.compat.v1包作为tensorflow替代包的方式是完全相同的。&lt;/p&gt;
&lt;h4 id=&quot;编写原生的tensorflow-2.0程序&quot;&gt;编写原生的TensorFlow 2.0程序&lt;/h4&gt;
&lt;p&gt;推荐的演进方式，当然还是学习TensorFlow 2.0的相关特征，重构原有代码为新版本代码才是正路。平心而论，毕竟绝大多数系统的升级都是为了提供更多功能和降低使用门槛。TensorFlow 2.0也是大幅的降低了使用门槛的。大多数的工作比起1.x版本来，都能使用更少的代码量来完成。&lt;br/&gt;首先了解一下TensorFlow 2.0同1.x之间的重要区别：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在API层面的类、方法有了较大的变化，这个需要在使用中慢慢熟悉&lt;/li&gt;
&lt;li&gt;取消了Session机制，每一条命令直接执行，而不需要等到Session.run&lt;/li&gt;
&lt;li&gt;因为取消了Session机制，原有的数学模型定义，改为使用Python函数编写。原来的feed_dict和tf.placeholder，成为了函数的输入部分；原来的fetches，则成为了函数的返回值。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;使用keras的模型体系对原有的TensorFlow API进行高度的抽象，使用更容易&lt;/li&gt;
&lt;li&gt;使用tf.keras.Model.fit来替代原有的训练循环。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;正常情况下，最后一项tf.keras.Model.fit能够大大的降低训练循环的代码量。但在本例中，我们模拟了一个现实中并不适用的例子，keras中并未对这种情形进行优化。所以在本例中反而无法使用tf.keras.Model.fit（实际上一定要使用也是可以的，不过要自定义模型，工作量更不划算）。因此本例中仍然要自己编写训练循环。并且因为2.0中API的变化，代码更复杂了。不过相信我，等到比较正式应用中，使用神经网络、卷积等常用算法，代码就极大的简化了。&lt;br/&gt;使用TensorFlow 2.0原生代码的程序代码如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;#!/usr/bin/env python3
#上面一行改为使用python3解释本代码

#引入python新版本的语言特征
from __future__ import absolute_import, division, print_function

#引入TensorFlow库,版本2.0
import tensorflow as tf

#引入数值计算库
import numpy as np

#使用 NumPy 生成假数据集x,代表房间的平米数，这里的取值范围是0-1的浮点数，
#原因请看正文中的说明，属于是“规范化”之后的数据
# 生成的数据共100个，式样是100行，每行1个数据
x = np.float32(np.random.rand(100,1))
#我们假设每平米0.5万元，基础费用0.7万，这个数值也是规范化之后的，仅供示例
#最终运行的结果，应当求出来0.5/0.7这两个值代表计算成功
#计算最终房价y，x和y一同当做我们的样本数据
y = np.dot(x,0.5) + 0.7
#---------------------------------数据集准备完成
# 请参考正文，我们假定房价的公式为：y=a*x+b
#定义tensorflow变量，a是权重，b是偏移
b = tf.Variable(np.float32(0.3))
a = tf.Variable(np.float32(0.3))

#以上代码基本同tensorflow1.x版本一致
#以下有了区别
#使用python语言定义数学模型，模型来自于上面的公式
#上面使用np的是直接计算得到训练样本，而不是定义模型
#模型中并非必须使用tensorflow的计算函数来代替python的乘法运算
@tf.function
def model(x):
        return a*x+b

#定义代价函数，也是python函数
def loss(predicted_y, desired_y):
    return tf.reduce_sum(tf.square(predicted_y - desired_y))

# TensorFlow内置Adam算法，每步长0.1
optimizer = tf.optimizers.Adam(0.1)
# 还可以选用TensorFlow内置SGD(随机最速下降)算法，每步长0.001
#不同算法要使用适当的步长，步长过大会导致模型无法收敛
#optimizer = tf.optimizers.SGD(0.001)

#重复梯度下降200次，每隔5次打印一次结果
for step in range(0, 200):
        with tf.GradientTape() as t:
                outputs = model(x)  #进行一次计算
                current_loss = loss(outputs, y) #得到当前损失值
                grads = t.gradient(current_loss, [a, b])    #调整模型中的权重、偏移值
                optimizer.apply_gradients(zip(grads,[a, b]))    #调整之后的值代回到模型
        if step % 5 == 0:   #每5次迭代显示一次结果
                print( &quot;Step:%d loss:%%%2.5f weight:%2.7f bias:%2.7f &quot; % 
                        (step,current_loss.numpy(), a.numpy(), b.numpy()))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;程序在升级中所做的修改和特殊的处理，都使用注释保留在了源码中。我觉得这种方式比打散摘出来讲解的能更透彻。&lt;br/&gt;最后看一下新版程序的执行结果：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;Step:0 loss:%25.78244 weight:0.4000000 bias:0.4000000 
Step:5 loss:%2.71975 weight:0.7611420 bias:0.7740188 
Step:10 loss:%3.09600 weight:0.6725605 bias:0.7224629 
Step:15 loss:%0.87834 weight:0.4931822 bias:0.5800986 
Step:20 loss:%1.24737 weight:0.4960071 bias:0.6186275 
Step:25 loss:%0.22444 weight:0.5730734 bias:0.7264798 
Step:30 loss:%0.47145 weight:0.5464076 bias:0.7252067 
Step:35 loss:%0.09156 weight:0.4736322 bias:0.6712209 
Step:40 loss:%0.14845 weight:0.4771673 bias:0.6866464 
Step:45 loss:%0.06199 weight:0.5101752 bias:0.7255269 
Step:50 loss:%0.03108 weight:0.4946054 bias:0.7112849 
Step:55 loss:%0.04115 weight:0.4770990 bias:0.6918764 
Step:60 loss:%0.00145 weight:0.4950625 bias:0.7060429 
Step:65 loss:%0.01781 weight:0.5029647 bias:0.7096580 
Step:70 loss:%0.00211 weight:0.4934593 bias:0.6963260 
Step:75 loss:%0.00298 weight:0.4983235 bias:0.6982682 
Step:80 loss:%0.00345 weight:0.5049748 bias:0.7031375 
Step:85 loss:%0.00004 weight:0.5001755 bias:0.6976562 
Step:90 loss:%0.00102 weight:0.5002422 bias:0.6978318 
Step:95 loss:%0.00065 weight:0.5029225 bias:0.7010939 
Step:100 loss:%0.00001 weight:0.5000774 bias:0.6990223 
Step:105 loss:%0.00021 weight:0.4996552 bias:0.6993059 
Step:110 loss:%0.00015 weight:0.5007215 bias:0.7008768 
Step:115 loss:%0.00000 weight:0.4993480 bias:0.6997767 
Step:120 loss:%0.00003 weight:0.4995552 bias:0.7000407 
Step:125 loss:%0.00004 weight:0.5001000 bias:0.7004969 
Step:130 loss:%0.00001 weight:0.4995880 bias:0.6998325 
Step:135 loss:%0.00000 weight:0.4999941 bias:0.7000810 
Step:140 loss:%0.00001 weight:0.5001197 bias:0.7000892 
Step:145 loss:%0.00000 weight:0.4999250 bias:0.6998329 
Step:150 loss:%0.00000 weight:0.5001498 bias:0.7000451 
Step:155 loss:%0.00000 weight:0.5000388 bias:0.6999565 
Step:160 loss:%0.00000 weight:0.4999948 bias:0.6999494 
Step:165 loss:%0.00000 weight:0.5000526 bias:0.7000424 
Step:170 loss:%0.00000 weight:0.4999576 bias:0.6999717 
Step:175 loss:%0.00000 weight:0.4999971 bias:0.7000214 
Step:180 loss:%0.00000 weight:0.4999900 bias:0.7000131 
Step:185 loss:%0.00000 weight:0.4999775 bias:0.6999928 
Step:190 loss:%0.00000 weight:0.5000094 bias:0.7000152 
Step:195 loss:%0.00000 weight:0.4999923 bias:0.6999906 &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;模型通过学习后，得到的结果是很接近我们的预设值的。&lt;br/&gt;程序中还可以考虑使用随机快速下降算法(SGD)，你可以把当前的Adam算法使用注释符屏蔽上，打开SGD算法的注释屏蔽来尝试一下。对于本例中的数据集来讲，SGD的下降步长需要的更小，同样循环次数下，求解的精度会低一些。可以看出对于本例，Adam算法显然是更有效率的。而在TensorFlow的支持下，对于同样的数据集和数学模型，变更学习算法会很容易。&lt;/p&gt;
&lt;p&gt;（待续...）&lt;/p&gt;
</description>
<pubDate>Sun, 07 Apr 2019 01:57:00 +0000</pubDate>
<dc:creator>俺踏月色而来</dc:creator>
<og:description>引言 原来引用过一个段子，这里还要再引用一次。是关于苹果的。大意是，苹果发布了新的开发语言Swift，有非常多优秀的特征，于是很多时髦的程序员入坑学习。不料，经过一段头脑体操一般的勤学苦练，发现使用S</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/andrewwang/p/10664168.html</dc:identifier>
</item>
</channel>
</rss>