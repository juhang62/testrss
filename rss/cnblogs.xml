<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>简单的贝叶斯拼写检查器 - 明天去你那玩</title>
<link>http://www.cnblogs.com/guandaoren/p/10658885.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/guandaoren/p/10658885.html</guid>
<description>&lt;p&gt;                                                             最近在学习机器学习这块，尝试写次关于贝叶斯算法的博客，希望能帮到新手朋友们 orz&lt;/p&gt;
&lt;p&gt;关于理论部分相信网上有更详细的展开了，这里略过(0.0)直接上代码&lt;/p&gt;
&lt;p&gt;首先引入包(对语料库去除特殊字符)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;引入 re collections 包&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt; re,collections
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 去掉语料库的特殊字符&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt; words(text): &lt;span&gt;return&lt;/span&gt; re.findall(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;[a-z]+&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,text.lower())
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义函数统计各单词出现个数&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; train(features):
    model&lt;/span&gt;=collections.defaultdict(&lt;span&gt;lambda&lt;/span&gt;: 1&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; f &lt;span&gt;in&lt;/span&gt;&lt;span&gt; features:
        model[f]&lt;/span&gt;+=1
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; model
&lt;/span&gt;
NWORDS=train(words(open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;big.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).read()))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;定义字母集用来对输入单词修改或插入某个字母&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
alphabet = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;abcdefghijklmnopqrstuvwxyz&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;定义编辑距离为1的函数(输入单词可能是多打了一个字母，次序错了，打错了一个字母，少打了一个字母，返回这些集合)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; edits1(word):
    n&lt;/span&gt;=&lt;span&gt;len(word)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; set(
    [word[0:i]&lt;/span&gt;+word[i+1:] &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(n)]+  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;原单词多打了一个字母 range(n)返回删除一个字母的列表 (ord wrd wod wor)&lt;/span&gt;
    [word[0:i]+word[i+1]+word[i]+word[i+2:] &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(n-1)]+  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;原单词交换一次位置的可能列表 （owrd wrod wodr）&lt;/span&gt;
    [word[0:i]+c+word[i+1:] &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(n) &lt;span&gt;for&lt;/span&gt; c &lt;span&gt;in&lt;/span&gt; alphabet]+  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;原单词某字母需被修改可能列表 （~ord  w~rd wo~d wor~）&lt;/span&gt;
    [word[0:i]+c+word[i:] &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(n+1) &lt;span&gt;for&lt;/span&gt; c &lt;span&gt;in&lt;/span&gt; alphabet]  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;原单词需插入一个字母的可能 &lt;/span&gt;
    )
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;定义编辑距离为2的函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;判断该单词是否为语料库的'真实'单词&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; known(words):&lt;span&gt;return&lt;/span&gt; set(w &lt;span&gt;for&lt;/span&gt; w &lt;span&gt;in&lt;/span&gt; words &lt;span&gt;if&lt;/span&gt; w &lt;span&gt;in&lt;/span&gt;&lt;span&gt; NWORDS)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;编辑距离为2的可能列表中的真实单词&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; known_edits2(word):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; set(e2 &lt;span&gt;for&lt;/span&gt; e1 &lt;span&gt;in&lt;/span&gt; edits1(word) &lt;span&gt;for&lt;/span&gt; e2 &lt;span&gt;in&lt;/span&gt; edits1(e1) &lt;span&gt;if&lt;/span&gt; e2 &lt;span&gt;in&lt;/span&gt; NWORDS)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;定义检查函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;主函数拼写器  返回优先级 真实单词&amp;gt;编辑距离1&amp;gt;编辑距离2&amp;gt;不存在的原单词&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; correct(word):
    candidates &lt;/span&gt;= known([word]) &lt;span&gt;or&lt;/span&gt; known(edits1(word)) &lt;span&gt;or&lt;/span&gt; known_edits2(word) &lt;span&gt;or&lt;/span&gt;&lt;span&gt; [word]
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; max(candidates, key=&lt;span&gt;lambda&lt;/span&gt; w: NWORDS[w])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后调用即可&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
correct(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ope&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果 ‘one’&lt;/p&gt;
&lt;p&gt;（题外话，我怎么感觉这家伙好像没用到贝叶斯算法吧，就是最后返回某单词在语料库出现次数最多的单词）&lt;/p&gt;

</description>
<pubDate>Fri, 05 Apr 2019 07:41:00 +0000</pubDate>
<dc:creator>明天去你那玩</dc:creator>
<og:description>最近在学习机器学习这块，尝试写次关于贝叶斯算法的博客，希望能帮到新手朋友们 orz 关于理论部分相信网上有更详细的展开了，这里略过(0.0)直接上代码 首先引入包(对语料库去除特殊字符) 去掉语料库的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/guandaoren/p/10658885.html</dc:identifier>
</item>
<item>
<title>Java的序列化和反序列化 - 农码关山北</title>
<link>http://www.cnblogs.com/dslx/p/10648414.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dslx/p/10648414.html</guid>
<description>&lt;h3&gt;概述&lt;/h3&gt;
&lt;p&gt; Java对象的序列化和反序列化，这个词对我来说追溯到大学阶段，学Java对象流时知道有这东西。老师告诉我们可以把Java对象化作字节流，储存文件或网络通信。然后就是巴啦巴拉，一脸懵逼。举个例子，有一台北京的Java虚拟机现在运行的某个对象要调用一台在长春运行的Java虚拟机内的某个对象，这是两个不同的Java虚拟机进程，我们没办法直接传递对象的引用，现在我们只能把长春的这个对象序列化，变成一块一块碎片，传给北京的虚拟机，北京虚拟机反序列化后就造出了一个对象，然后就可以正常使用。说得通俗点，这个序列化就是跨进程数据传输。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1333075/201904/1333075-20190403224028051-286777114.png&quot; alt=&quot;&quot; width=&quot;700&quot; height=&quot;375&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;序列化（Serializable接口）&lt;/h3&gt;
&lt;p&gt;要序列化的类通过实现&lt;strong&gt;java.io.Serializable&lt;/strong&gt;接口启动序列化的功能，如果它有子类，所有的子类本身也都可序列化。&lt;/p&gt;
&lt;p&gt;Person类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Person &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Serializable
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String sex;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Person(String name,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; age,String sex)
    {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sex =&lt;span&gt; sex;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getAge()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; age;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
    }


    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getSex()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; sex;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;姓名:&quot; + &lt;span&gt;this&lt;/span&gt;.name + &quot;,年龄:&quot; + &lt;span&gt;this&lt;/span&gt;.age + &quot;,性别:&quot; + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.sex;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;serializable&lt;/strong&gt;接口没有函数或者字段，我们可以看到我们&lt;span&gt;implements&lt;/span&gt;接口，没实现任何的函数，它仅仅用于标识可序列化，如果我们没有实现这个标识接口而进行序列化，会抛出一个&lt;span&gt;&lt;strong&gt;NotSerializableException&lt;/strong&gt;&lt;span&gt;异常&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;Main类&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Main
{

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)
    {
        serializePerson();
    }


    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; serializePerson()
    {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            Person customer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Person(&quot;张三&quot;,15,&quot;男&quot;&lt;span&gt;);
            ObjectOutputStream objectOutputStream &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ObjectOutputStream(&lt;span&gt;new&lt;/span&gt; FileOutputStream(&quot;E:/Person&quot;&lt;span&gt;));
            objectOutputStream.writeObject(customer);
            System.out.println(&lt;/span&gt;&quot;Person序列化完成。。。&quot;&lt;span&gt;);
            objectOutputStream.close();
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e){
            e.printStackTrace();
            System.out.println(&lt;/span&gt;&quot;Person序列化出错。。。&quot;&lt;span&gt;);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Person序列化完成。。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在 E盘下就会有一个Person文件，用notepad++打开，依稀可以见到一些熟悉的字眼&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1333075/201904/1333075-20190404143738540-265262812.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们用二进制查看器打开这个文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1333075/201904/1333075-20190404144809108-1517180767.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 左边第一个部分是序列化的文件头AC ED 00 05,其他还有关于序列化的类描述，里面的各个属性值，还有父类的信息，lz实在看不懂了，有大佬分析过序列化文件，有兴趣可自行百度查看。&lt;/p&gt;
&lt;h3&gt;反序列化&lt;/h3&gt;
&lt;p&gt; Main类添加DeserializePerson函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Object DeserializePerson()
    {
        ObjectInputStream objectInputStream &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            objectInputStream &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ObjectInputStream(&lt;span&gt;new&lt;/span&gt; FileInputStream(&lt;span&gt;new&lt;/span&gt; File(&quot;E:/Person&quot;&lt;span&gt;)));
            Object object &lt;/span&gt;=&lt;span&gt; objectInputStream.readObject();
            System.out.println(&lt;/span&gt;&quot;反序列化完成。。。&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; object;
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e)
        {
            e.printStackTrace();
        }&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (objectInputStream != &lt;span&gt;null&lt;/span&gt;&lt;span&gt; )
            {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
                {
                    objectInputStream.close();
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e)
                {
                    e.printStackTrace();
                }
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;反序列化完成。。。
姓名:张三,年龄:&lt;/span&gt;15,性别:男
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;serialVersionUID（标识）&lt;/h3&gt;
&lt;p&gt;知道serializable是标识的语义，这个标识是在哪？如果我们没特意指定，在编译过程中Java编译器会默认赋予它一个独一无二的编号，保证它是唯一的。但这样做是否会给我们带来影响？&lt;/p&gt;
&lt;p&gt;Person类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Person &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Serializable
{

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String sex;
　　 //&lt;span&gt;添加了一个属性
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String number;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Person(String name,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; age,String sex)
    {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sex =&lt;span&gt; sex;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getAge()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; age;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
    }


    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getSex()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; sex;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;姓名:&quot; + &lt;span&gt;this&lt;/span&gt;.name + &quot;,年龄:&quot; + &lt;span&gt;this&lt;/span&gt;.age + &quot;,性别:&quot; + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.sex;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Main类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Main
{

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;serializePerson();&lt;/span&gt;
        Person person =&lt;span&gt; (Person) DeserializePerson();
        System.out.println(person);
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Object DeserializePerson()
    {
        ObjectInputStream objectInputStream &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            objectInputStream &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ObjectInputStream(&lt;span&gt;new&lt;/span&gt; FileInputStream(&lt;span&gt;new&lt;/span&gt; File(&quot;E:/Person&quot;&lt;span&gt;)));
            Object object &lt;/span&gt;=&lt;span&gt; objectInputStream.readObject();
            System.out.println(&lt;/span&gt;&quot;反序列化完成。。。&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; object;
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e)
        {
            e.printStackTrace();
        }&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (objectInputStream != &lt;span&gt;null&lt;/span&gt;&lt;span&gt; )
            {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
                {
                    objectInputStream.close();
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e)
                {
                    e.printStackTrace();
                }
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; serializePerson()
    {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            Person customer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Person(&quot;张三&quot;,15,&quot;男&quot;&lt;span&gt;);
            ObjectOutputStream objectOutputStream &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ObjectOutputStream(&lt;span&gt;new&lt;/span&gt; FileOutputStream(&quot;E:/Person&quot;&lt;span&gt;));
            objectOutputStream.writeObject(customer);
            System.out.println(&lt;/span&gt;&quot;Person序列化完成。。。&quot;&lt;span&gt;);
            objectOutputStream.close();
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e){
            e.printStackTrace();
            System.out.println(&lt;/span&gt;&quot;Person序列化出错。。。&quot;&lt;span&gt;);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;发现抛出了一个异常&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1333075/201904/1333075-20190404161413216-1583157788.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本地的文件流中的class（序列化）和修改完的Person.class，不兼容了（&lt;span&gt;UID&lt;/span&gt;），处于安全机制考虑，程序抛出错误，拒绝载入。如何保证UID版本一致，那只能自己指定UID，在序列化后，去添加字段或者函数，就不会影响后期还原。&lt;/p&gt;
&lt;p&gt;Person类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Person &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Serializable
{

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; serialVersionUID = 55555L&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String sex;
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Person(String name,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; age,String sex)
    {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sex =&lt;span&gt; sex;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getAge()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; age;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
    }


    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getSex()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; sex;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;姓名:&quot; + &lt;span&gt;this&lt;/span&gt;.name + &quot;,年龄:&quot; + &lt;span&gt;this&lt;/span&gt;.age + &quot;,性别:&quot; + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.sex;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Main类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Main
{

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)
    {
        serializePerson();
        Person person &lt;/span&gt;=&lt;span&gt; (Person) DeserializePerson();
        System.out.println(person);
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Object DeserializePerson()
    {
        ObjectInputStream objectInputStream &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            objectInputStream &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ObjectInputStream(&lt;span&gt;new&lt;/span&gt; FileInputStream(&lt;span&gt;new&lt;/span&gt; File(&quot;E:/Person&quot;&lt;span&gt;)));
            Object object &lt;/span&gt;=&lt;span&gt; objectInputStream.readObject();
            System.out.println(&lt;/span&gt;&quot;反序列化完成。。。&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; object;
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e)
        {
            e.printStackTrace();
        }&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (objectInputStream != &lt;span&gt;null&lt;/span&gt;&lt;span&gt; )
            {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
                {
                    objectInputStream.close();
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e)
                {
                    e.printStackTrace();
                }
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; serializePerson()
    {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            Person customer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Person(&quot;张三&quot;,15,&quot;男&quot;&lt;span&gt;);
            ObjectOutputStream objectOutputStream &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ObjectOutputStream(&lt;span&gt;new&lt;/span&gt; FileOutputStream(&quot;E:/Person&quot;&lt;span&gt;));
            objectOutputStream.writeObject(customer);
            System.out.println(&lt;/span&gt;&quot;Person序列化完成。。。&quot;&lt;span&gt;);
            objectOutputStream.close();
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e){
            e.printStackTrace();
            System.out.println(&lt;/span&gt;&quot;Person序列化出错。。。&quot;&lt;span&gt;);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;序列化后，我们注释掉main函数里的&lt;span&gt;serializePerson()；修改Person类，添加或修改字段，进行反序列化。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;反序列化完成。。。
姓名:张三,年龄:&lt;/span&gt;15,性别:男
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 我们可以发现，由编译器默认自动给我们生成的UID编码，并不可控，对同一个类，A编译器编译，赋予一个UID的值和B编译器编译赋予的UID值也有可能不同，所以为了提高可控性，确定性，我们在一个可序列化的类中应该明确为它赋值。&lt;/p&gt;
&lt;h3&gt;Externalizable接口&lt;/h3&gt;
&lt;p&gt;以上我们可以发现，所有的序列化操作都是默认的，自动帮我们完成。但有时我们并不想这样，有些属性我们并不想序列化，想要自定义的方式去序列化它。为此，Java提供了一个&lt;strong&gt;Externalizable&lt;/strong&gt;接口，方便用户自定义序列化过程，它和&lt;span&gt;Serializable&lt;/span&gt;有什么区别？&lt;/p&gt;
&lt;p&gt; Person类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Person &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Externalizable
{

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; serialVersionUID = 55555L&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String sex;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Person()
    {

    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Person(String name,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; age,String sex)
    {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sex =&lt;span&gt; sex;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getAge()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; age;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
    }


    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getSex()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; sex;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;姓名:&quot; + &lt;span&gt;this&lt;/span&gt;.name + &quot;,年龄:&quot; + &lt;span&gt;this&lt;/span&gt;.age + &quot;,性别:&quot; + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.sex;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; writeExternal(ObjectOutput out) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException
    {

    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; readExternal(ObjectInput in) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException, ClassNotFoundException
    {

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Main类不变，输出&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Person序列化完成。。。
反序列化完成。。。
姓名:&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;,年龄:0,性别:&lt;span&gt;null&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;与serialization接口相比，我们很快就能看出，&lt;span&gt;Externalizable&lt;/span&gt;接口对Person类进行序列化和反序列化之后得到的对象的状态并没有保存下来，所有属性的值都变成默认值。它们之间有什么关系和区别？&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Externalizable继承了Serializable，它定义了两个抽象函数，&lt;strong&gt;&lt;span&gt;writeExternal&lt;/span&gt;&lt;/strong&gt;和&lt;strong&gt;&lt;span&gt;readExternal&lt;span&gt;，&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;我们进行序列化和反序列需要重写，可以指定序列化哪些属性。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;Externalizable序列化的类必须有一个无参构造函数，否则会报错。因为&lt;span&gt;&lt;span&gt;Externalizable&lt;/span&gt;&lt;/span&gt;序列化的时候，读取对象时，会调用无参构造函数创建一个新的对象，之后将保存对象的字段的值填充到新对象中。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;修改Person类，重新序列化&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; writeExternal(ObjectOutput out) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException
    {
        out.writeObject(name);
        out.writeObject(age);
        out.writeObject(sex);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; readExternal(ObjectInput in) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException, ClassNotFoundException
    {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; (String)in.readObject();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age = (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)in.readObject();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sex =&lt;span&gt; (String)in.readObject();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Person序列化完成。。。
反序列化完成。。。
姓名:张三,年龄:&lt;/span&gt;15,性别:男
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 重写完两个函数，发现对象持久化完成。但细心的小伙伴可能会发现，我们序列化的成员变量都是实例变量。就会有一个疑问，换成静态变量试试？&lt;/p&gt;
&lt;h3&gt;静态变量被序列化？&lt;/h3&gt;
&lt;p&gt; 其实序列化（默认序列化）被不保存静态变量，因为静态变量属于类本身，对象序列化，顾名思义就是指的对象本身状态，并不包含静态变量。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Person &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Serializable
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; serialVersionUID = 55555L&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String sex;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; String money;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Person(String name,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; age,String sex,String money)
    {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sex =&lt;span&gt; sex;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.money =&lt;span&gt; money;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getAge()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; age;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
    }


    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getSex()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; sex;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;姓名:&quot; + &lt;span&gt;this&lt;/span&gt;.name + &quot;,年龄:&quot; + &lt;span&gt;this&lt;/span&gt;.age + &quot;,性别:&quot; + &lt;span&gt;this&lt;/span&gt;.sex + &quot;,资产:&quot; +&lt;span&gt; money;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Main类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Main {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        serializablePerson();
        Person person &lt;/span&gt;=&lt;span&gt; (Person)DeserializablePerson();
        System.out.println(person);

    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;演示使用，并不规范&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; serializablePerson() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        Person person &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Person(&quot;张三&quot;,15,&quot;男&quot;,&quot;5000000&quot;&lt;span&gt;);
        ObjectOutputStream objectOutputStream &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ObjectOutputStream(&lt;span&gt;new&lt;/span&gt; FileOutputStream(&quot;D:/Person&quot;&lt;span&gt;));
        objectOutputStream.writeObject(person);
        objectOutputStream.close();
        System.out.println(&lt;/span&gt;&quot;序列化完成。。。&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Object DeserializablePerson() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception
    {
        ObjectInputStream objectInputStream &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ObjectInputStream(&lt;span&gt;new&lt;/span&gt; FileInputStream(&lt;span&gt;new&lt;/span&gt; File(&quot;D:/Person&quot;&lt;span&gt;)));
        Object object &lt;/span&gt;=&lt;span&gt; objectInputStream.readObject();
        objectInputStream.close();
        System.out.println(&lt;/span&gt;&quot;反序列完成。。。&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; object;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;序列化完成。。。
反序列完成。。。
姓名:张三,年龄:&lt;/span&gt;15,性别:男,资产:5000000
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果跟我们的结论出乎意料，静态变量被序列化了，真的是这样吗？导致这个原因是因为我们测试都是在一个进程里面的。JVM把money这个变量加载进来了，所以导致我们看到的是加载过的money。我们可以这样做，多写一个Main类，让JVM退出后，重新加载。&lt;/p&gt;
&lt;p&gt;MainTest类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MainTest {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        Person person &lt;/span&gt;=&lt;span&gt; (Person)DeserializablePerson();
        System.out.println(person);
    }
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Object DeserializablePerson() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception
    {
        ObjectInputStream objectInputStream &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ObjectInputStream(&lt;span&gt;new&lt;/span&gt; FileInputStream(&lt;span&gt;new&lt;/span&gt; File(&quot;D:/Person&quot;&lt;span&gt;)));
        Object object &lt;/span&gt;=&lt;span&gt; objectInputStream.readObject();
        objectInputStream.close();
        System.out.println(&lt;/span&gt;&quot;反序列化完成。。。&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; object;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在先运行Main类，得到的是我们上面的接口，现在运行MainTest类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;反序列化完成。。。
姓名:张三,年龄:&lt;/span&gt;15,性别:男,资产:&lt;span&gt;null&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以发现静态成员变量并没有被保存下来，变成一个默认值。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;transient关键字（默认序列化）&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;有时候我们并不想自定义序列化，然而有些成员变量我们也不想序列化。那么&lt;strong&gt;transient&lt;/strong&gt;这个关键字就是你的不二人选，它的作用很简单，就是控制变量的序列化，在变量声明前加上这个关键字即可。&lt;/p&gt;
&lt;p&gt;Person类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Person &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Serializable
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; serialVersionUID = 55555L&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String sex;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; String money;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;银行账户&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;transient&lt;/span&gt;&lt;span&gt; String bankNumber;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;银行密码&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;transient&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; passWord;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Person(String name,&lt;span&gt;int&lt;/span&gt; age,String sex,String money,String bankNumber,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; passWord)
    {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sex =&lt;span&gt; sex;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.money =&lt;span&gt; money;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.bankNumber =&lt;span&gt; bankNumber;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.passWord =&lt;span&gt; passWord;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getAge()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; age;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
    }


    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getSex()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; sex;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;姓名:&quot; + &lt;span&gt;this&lt;/span&gt;.name + &quot;,年龄:&quot; + &lt;span&gt;this&lt;/span&gt;.age + &quot;,性别:&quot; + &lt;span&gt;this&lt;/span&gt;.sex + &quot;,资产:&quot; + money + &quot;，我的银行账户是:&quot; + &lt;span&gt;this&lt;/span&gt;.bankNumber + &quot;,我的银行密码:&quot; +  &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.passWord;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Main类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Main {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        serializablePerson();
        Person person &lt;/span&gt;=&lt;span&gt; (Person)DeserializablePerson();
        System.out.println(person);

    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;演示使用，并不规范&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; serializablePerson() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        Person person &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Person(&quot;张三&quot;,15,&quot;男&quot;,&quot;5000000&quot;,&quot;564654979797464646&quot;,123456&lt;span&gt;);
        ObjectOutputStream objectOutputStream &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ObjectOutputStream(&lt;span&gt;new&lt;/span&gt; FileOutputStream(&quot;D:/Person&quot;&lt;span&gt;));
        objectOutputStream.writeObject(person);
        objectOutputStream.close();
        System.out.println(&lt;/span&gt;&quot;序列化完成。。。&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Object DeserializablePerson() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception
    {
        ObjectInputStream objectInputStream &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ObjectInputStream(&lt;span&gt;new&lt;/span&gt; FileInputStream(&lt;span&gt;new&lt;/span&gt; File(&quot;D:/Person&quot;&lt;span&gt;)));
        Object object &lt;/span&gt;=&lt;span&gt; objectInputStream.readObject();
        objectInputStream.close();
        System.out.println(&lt;/span&gt;&quot;反序列完成。。。&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; object;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;序列化完成。。。
反序列完成。。。
姓名:张三,年龄:&lt;/span&gt;15,性别:男,资产:5000000，我的银行账户是:&lt;span&gt;null&lt;/span&gt;,我的银行密码:0
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这些关键信息就都不会被序列化到文件中，当然我有500w的话&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;序列化的存储规则&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Java序列化为了节省存储空间，有特定的存储规则，写入文件为同一对象的时候，并不会再将对象的内容存储，而只是再次存储一份引用。&lt;/p&gt;
&lt;p&gt;Main类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Main {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        serializablePerson();
        Person person &lt;/span&gt;=&lt;span&gt; (Person) DeserializablePerson();
        System.out.println(person);

    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;演示使用，并不规范&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; serializablePerson() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        Person person &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Person(&quot;张三&quot;,15,&quot;男&quot;,&quot;5000000&quot;,&quot;564654979797464646&quot;,123456&lt;span&gt;);
        ObjectOutputStream objectOutputStream &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ObjectOutputStream(&lt;span&gt;new&lt;/span&gt; FileOutputStream(&quot;D:/Person&quot;&lt;span&gt;));
        objectOutputStream.writeObject(person);
        objectOutputStream.flush();
        System.out.println(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; File(&quot;D:/Person&quot;&lt;span&gt;).length());
        objectOutputStream.writeObject(person);
        objectOutputStream.close();
        System.out.println(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; File(&quot;D:/Person&quot;&lt;span&gt;).length());
        System.out.println(&lt;/span&gt;&quot;序列化完成。。。&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Object DeserializablePerson() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception
    {
        ObjectInputStream objectInputStream &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ObjectInputStream(&lt;span&gt;new&lt;/span&gt; FileInputStream(&lt;span&gt;new&lt;/span&gt; File(&quot;D:/Person&quot;&lt;span&gt;)));
        Person person &lt;/span&gt;=&lt;span&gt;(Person) objectInputStream.readObject();
        Person person1 &lt;/span&gt;=&lt;span&gt;(Person) objectInputStream.readObject();
        objectInputStream.close();
        System.out.println(&lt;/span&gt;&quot;反序列完成。。。&quot;&lt;span&gt;);
        System.out.print(&lt;/span&gt;&quot;是否同一个对象=====&amp;gt;&quot;&lt;span&gt;);
        System.out.println(person &lt;/span&gt;==&lt;span&gt; person1);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; person;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
108
113&lt;span&gt;
序列化完成。。。
反序列完成。。。
是否同一个对象&lt;/span&gt;=====&amp;gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
姓名:张三,年龄:&lt;/span&gt;15,性别:男,资产:5000000，我的银行账户是:&lt;span&gt;null&lt;/span&gt;,我的银行密码:0
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;多出五字节存储空间就是新增引用和一些控制信息空间，反序列时，恢复引用关系，person和person1都指向唯一的对象，二者相等，输出true，这样的存储规则就极大节省了存储的空间。&lt;/p&gt;
&lt;h3&gt;注意事项&lt;/h3&gt;
&lt;p&gt;可以发现，我很多地方加了默认序列化的情况下，如果是自定义序列化，那么&lt;strong&gt;transient&lt;/strong&gt;这些就统统无效，是不是感觉可控性增强不少，序列化还得注意几个点。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如果有内部类，或者是要序列化的对象的成员变量是一个对象类，那么也必须继承序列化的接口，否则会出错滴。&lt;/li&gt;
&lt;li&gt;子类即使没有实现序列化的接口，只要父类实现了，那子类就可以直接序列化。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;参考:&lt;a href=&quot;https://www.ibm.com/developerworks/cn/java/j-lo-serial/&quot; target=&quot;_blank&quot;&gt;Java序列化的高级认识&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;===============================================================&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如发现错误，请及时留言，lz及时修改，避免误导后来者。感谢！！！&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 05 Apr 2019 07:30:00 +0000</pubDate>
<dc:creator>农码关山北</dc:creator>
<og:description>概述 Java对象的序列化和反序列化，这个词对我来说追溯到大学阶段，学Java对象流时知道有这东西。老师告诉我们可以把Java对象化作字节流，储存文件或网络通信。然后就是巴啦巴拉，一脸懵逼。举个例子，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dslx/p/10648414.html</dc:identifier>
</item>
<item>
<title>【朝花夕拾】设计模式之中介者模式 - 艾心❤</title>
<link>http://www.cnblogs.com/edison0621/p/10658807.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/edison0621/p/10658807.html</guid>
<description>&lt;p&gt;提供一个中介对象出来，用于封装一系列对象的交互，从而使各对象不需要直接交互，进一步降低了对象间的耦合度。这是一种行为型设计模式。&lt;/p&gt;
&lt;p&gt;由此可见，中介者模式主要解决的是对象间所存在的大量关系，我们都知道，对象间一旦关联紧密，必然会导致系统的复杂性增加，一旦某个对象有所修改，其关联对象也有可能会有跟着更改，这自然不是我们所希望的。有些朋友可能会说，如果交互很多，是不是可以将对象合并，从某种角度上来说，我们可以考虑对象合并。但是，我们并不能这样去做，因为对象存在的层级可能是不同的，有些是处理数据交互的，有些是处理业务级的，合并起来会导致系统层次不明，引入更大的风险。&lt;/p&gt;
&lt;p&gt;在现实生活中，中介者更多的体现为调度平台或者房产中介，再或者就是红娘了。我们以红娘为例，&lt;/p&gt;
&lt;p&gt;程序员找个女朋友实在是太难，而且时间也不多，圈子也不大，一个一个去认识，鬼知道哪一个要找对象的，耗费精力不说，尼玛，还少敲了好几段代码。所以，一般通过红娘会更方便一点，会使得我们的目的更加明确，就是找对象，筛选、信息收集、匹配的事情交给红娘做就好了。毕竟红娘可是掌握着很多女孩子的信息及其择偶要求的，程序员过去把信息或者要求填写一下即可，红娘帮你匹配合适的女孩子，一旦有较高的匹配度，就可以约会见见了，说不准很快就成了，这样代码没少敲，对象也不耽误找，是不是很爽……&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;

&lt;p&gt;以上，我们可以发现，在中介者模式里面，中介者承担的职能主要包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;业务通道的聚合，把之前繁琐的对象交互抽象出来，所有的交互通过中介者通道进行。&lt;/li&gt;
&lt;li&gt;信息的中转，在中介者模式里，对象间的信息通过中介者转发到对应的对象处。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;

&lt;p&gt;UML描述的是程序员相亲的例子&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/533598/201904/533598-20190405151512585-1707594675.png&quot;&gt;&lt;img title=&quot;zhongjiezhe&quot; src=&quot;https://img2018.cnblogs.com/blog/533598/201904/533598-20190405151512866-965648457.png&quot; alt=&quot;zhongjiezhe&quot; width=&quot;984&quot; height=&quot;493&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;14&quot;&gt;

&lt;p&gt;通过以上UML图，我们可以知道，中介者模式主要有以下几个角色&lt;/p&gt;
&lt;p&gt;Mediator: 抽象中介者。定义了同事对象与中介者对象进行交互的接口。&lt;/p&gt;
&lt;p&gt;ConcreteMediator: 具体中介者，实现抽象中介者的方法。&lt;/p&gt;
&lt;p&gt;Colleague: 抽象同事类。&lt;/p&gt;
&lt;p&gt;ConcreteColleague: 具体同事类。每个具体同事类都只需要知道自己的行为即可，他们是直接与中介者打交道的类。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;接下来我们以程序员找对象为例，这里的中介者就是程序员与妹子之间协调的红娘了，来看看如何通过代码编写&lt;/p&gt;
&lt;p&gt;核心逻辑代码：&lt;/p&gt;
&lt;div class=&quot;csharpcode&quot; readability=&quot;71&quot;&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   1:  &lt;/span&gt;&lt;span class=&quot;rem&quot;&gt;/// &amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   2:  &lt;/span&gt;&lt;span class=&quot;rem&quot;&gt;/// 抽象中介者&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   3:  &lt;/span&gt;&lt;span class=&quot;rem&quot;&gt;/// &amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   4:  &lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;class&lt;/span&gt; Mediator
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   5:  &lt;/span&gt;{
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   6:  &lt;/span&gt;    &lt;span class=&quot;rem&quot;&gt;/// &amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   7:  &lt;/span&gt;    &lt;span class=&quot;rem&quot;&gt;/// 相亲&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   8:  &lt;/span&gt;    &lt;span class=&quot;rem&quot;&gt;/// &amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   9:  &lt;/span&gt;    &lt;span class=&quot;kwrd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;void&lt;/span&gt; BlindDate(Colleague colleague, &lt;span class=&quot;kwrd&quot;&gt;string&lt;/span&gt; msg);
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  10:  &lt;/span&gt;}
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  11:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  12:  &lt;/span&gt;&lt;span class=&quot;rem&quot;&gt;/// &amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  13:  &lt;/span&gt;&lt;span class=&quot;rem&quot;&gt;/// 抽象同事类&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  14:  &lt;/span&gt;&lt;span class=&quot;rem&quot;&gt;/// &amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  15:  &lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;class&lt;/span&gt; Colleague
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  16:  &lt;/span&gt;{
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  17:  &lt;/span&gt;    &lt;span class=&quot;kwrd&quot;&gt;protected&lt;/span&gt; Mediator mediator;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  18:  &lt;/span&gt;    &lt;span class=&quot;kwrd&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;string&lt;/span&gt; msg;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  19:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  20:  &lt;/span&gt;    &lt;span class=&quot;kwrd&quot;&gt;public&lt;/span&gt; Colleague(Mediator mediator, &lt;span class=&quot;kwrd&quot;&gt;string&lt;/span&gt; msg)
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  21:  &lt;/span&gt;    {
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  22:  &lt;/span&gt;        &lt;span class=&quot;kwrd&quot;&gt;this&lt;/span&gt;.mediator = mediator;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  23:  &lt;/span&gt;        &lt;span class=&quot;kwrd&quot;&gt;this&lt;/span&gt;.msg = msg;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  24:  &lt;/span&gt;    }
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  25:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  26:  &lt;/span&gt;    &lt;span class=&quot;kwrd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;void&lt;/span&gt; Communication(&lt;span class=&quot;kwrd&quot;&gt;string&lt;/span&gt; msg);
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  27:  &lt;/span&gt;}
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  28:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  29:  &lt;/span&gt;&lt;span class=&quot;rem&quot;&gt;/// &amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  30:  &lt;/span&gt;&lt;span class=&quot;rem&quot;&gt;/// 媒婆或者说是红娘&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  31:  &lt;/span&gt;&lt;span class=&quot;rem&quot;&gt;/// &amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  32:  &lt;/span&gt;&lt;span class=&quot;rem&quot;&gt;/// &amp;lt;seealso cref=&quot;ConsoleApp2.Colleague&quot; /&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  33:  &lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;class&lt;/span&gt; Matchmaker : Colleague
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  34:  &lt;/span&gt;{
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  35:  &lt;/span&gt;    &lt;span class=&quot;kwrd&quot;&gt;public&lt;/span&gt; Matchmaker(Mediator mediator, &lt;span class=&quot;kwrd&quot;&gt;string&lt;/span&gt; msg) : &lt;span class=&quot;kwrd&quot;&gt;base&lt;/span&gt;(mediator, msg)
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  36:  &lt;/span&gt;    {
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  37:  &lt;/span&gt;    }
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  38:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  39:  &lt;/span&gt;    &lt;span class=&quot;kwrd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;void&lt;/span&gt; BlindDate()
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  40:  &lt;/span&gt;    {
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  41:  &lt;/span&gt;        &lt;span class=&quot;kwrd&quot;&gt;this&lt;/span&gt;.mediator.BlindDate(&lt;span class=&quot;kwrd&quot;&gt;this&lt;/span&gt;, &lt;span class=&quot;kwrd&quot;&gt;this&lt;/span&gt;.msg);
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  42:  &lt;/span&gt;    }
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  43:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  44:  &lt;/span&gt;    &lt;span class=&quot;kwrd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;void&lt;/span&gt; Communication(&lt;span class=&quot;kwrd&quot;&gt;string&lt;/span&gt; msg)
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  45:  &lt;/span&gt;    {
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  46:  &lt;/span&gt;        Console.WriteLine(&lt;span class=&quot;kwrd&quot;&gt;this&lt;/span&gt;.msg + &lt;span class=&quot;str&quot;&gt;&quot;:&quot;&lt;/span&gt; + msg);
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  47:  &lt;/span&gt;    }
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  48:  &lt;/span&gt;}
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  49:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  50:  &lt;/span&gt;&lt;span class=&quot;rem&quot;&gt;/// &amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  51:  &lt;/span&gt;&lt;span class=&quot;rem&quot;&gt;/// 相亲者&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  52:  &lt;/span&gt;&lt;span class=&quot;rem&quot;&gt;/// &amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  53:  &lt;/span&gt;&lt;span class=&quot;rem&quot;&gt;/// &amp;lt;seealso cref=&quot;ConsoleApp2.Colleague&quot; /&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  54:  &lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;class&lt;/span&gt; Programmer : Colleague
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  55:  &lt;/span&gt;{
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  56:  &lt;/span&gt;    &lt;span class=&quot;kwrd&quot;&gt;public&lt;/span&gt; Programmer(Mediator mediator, &lt;span class=&quot;kwrd&quot;&gt;string&lt;/span&gt; msg) : &lt;span class=&quot;kwrd&quot;&gt;base&lt;/span&gt;(mediator, msg)
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  57:  &lt;/span&gt;    {
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  58:  &lt;/span&gt;    }
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  59:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  60:  &lt;/span&gt;    &lt;span class=&quot;kwrd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;void&lt;/span&gt; BlindDate()
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  61:  &lt;/span&gt;    {
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  62:  &lt;/span&gt;        &lt;span class=&quot;kwrd&quot;&gt;this&lt;/span&gt;.mediator.BlindDate(&lt;span class=&quot;kwrd&quot;&gt;this&lt;/span&gt;, &lt;span class=&quot;kwrd&quot;&gt;this&lt;/span&gt;.msg);
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  63:  &lt;/span&gt;    }
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  64:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  65:  &lt;/span&gt;    &lt;span class=&quot;kwrd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;void&lt;/span&gt; Communication(&lt;span class=&quot;kwrd&quot;&gt;string&lt;/span&gt; msg)
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  66:  &lt;/span&gt;    {
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  67:  &lt;/span&gt;        Console.WriteLine(&lt;span class=&quot;kwrd&quot;&gt;this&lt;/span&gt;.msg + &lt;span class=&quot;str&quot;&gt;&quot;:&quot;&lt;/span&gt; + msg);
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  68:  &lt;/span&gt;    }
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  69:  &lt;/span&gt;}
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  70:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  71:  &lt;/span&gt;&lt;span class=&quot;rem&quot;&gt;/// &amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  72:  &lt;/span&gt;&lt;span class=&quot;rem&quot;&gt;/// 这里就是中介机构了，暂且叫做结婚吧，作为一个中介结构，里面的信息是完全的&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  73:  &lt;/span&gt;&lt;span class=&quot;rem&quot;&gt;/// &amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  74:  &lt;/span&gt;&lt;span class=&quot;rem&quot;&gt;/// &amp;lt;seealso cref=&quot;ConsoleApp2.Mediator&quot; /&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  75:  &lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;class&lt;/span&gt; MarryMediator : Mediator
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  76:  &lt;/span&gt;{
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  77:  &lt;/span&gt;    &lt;span class=&quot;kwrd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;void&lt;/span&gt; BlindDate(Colleague colleague, &lt;span class=&quot;kwrd&quot;&gt;string&lt;/span&gt; msg)
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  78:  &lt;/span&gt;    {
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  79:  &lt;/span&gt;        colleague.Communication(msg);
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  80:  &lt;/span&gt;    }
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  81:  &lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;调用：&lt;/p&gt;
&lt;div class=&quot;csharpcode&quot; readability=&quot;22&quot;&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   1:  &lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;class&lt;/span&gt; Program
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   2:  &lt;/span&gt;{
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   3:  &lt;/span&gt;    &lt;span class=&quot;kwrd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;void&lt;/span&gt; Main(&lt;span class=&quot;kwrd&quot;&gt;string&lt;/span&gt;[] args)
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   4:  &lt;/span&gt;    {
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   5:  &lt;/span&gt;        Mediator mediator = &lt;span class=&quot;kwrd&quot;&gt;new&lt;/span&gt; MarryMediator();
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   6:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   7:  &lt;/span&gt;        &lt;span class=&quot;rem&quot;&gt;//红娘&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   8:  &lt;/span&gt;        Matchmaker matchmaker = &lt;span class=&quot;kwrd&quot;&gt;new&lt;/span&gt; Matchmaker(mediator, &lt;span class=&quot;str&quot;&gt;&quot;金牌红娘&quot;&lt;/span&gt;);
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   9:  &lt;/span&gt;        &lt;span class=&quot;rem&quot;&gt;//程序员&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  10:  &lt;/span&gt;        Programmer programmer = &lt;span class=&quot;kwrd&quot;&gt;new&lt;/span&gt; Programmer(mediator, &lt;span class=&quot;str&quot;&gt;&quot;光棍程序员&quot;&lt;/span&gt;);
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  11:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  12:  &lt;/span&gt;        mediator.BlindDate(matchmaker, &lt;span class=&quot;str&quot;&gt;&quot;请问你是要相亲吗，我们这边的优质女生有很多&quot;&lt;/span&gt;);
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  13:  &lt;/span&gt;        mediator.BlindDate(programmer, &lt;span class=&quot;str&quot;&gt;&quot;是的，帮我介绍一个温柔贤惠的妹子吧&quot;&lt;/span&gt;);
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  14:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  15:  &lt;/span&gt;        Console.Read();
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  16:  &lt;/span&gt;    }
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  17:  &lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/533598/201904/533598-20190405151513174-194502362.png&quot;&gt;&lt;img title=&quot;1554447454(1)&quot; src=&quot;https://img2018.cnblogs.com/blog/533598/201904/533598-20190405151513425-55319564.png&quot; alt=&quot;1554447454(1)&quot; width=&quot;976&quot; height=&quot;486&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;就这样，让人期待已久的相亲开始了，后面的事情，就交给程序员自己发挥了&lt;/p&gt;

&lt;blockquote readability=&quot;8&quot;&gt;

&lt;p&gt;优点：&lt;/p&gt;
&lt;p&gt;中介者模式简化并理清了对象间的关系，降低了类本身的复杂度，松散了对象间的耦合&lt;/p&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;p&gt;中介者本身承担着太过沉重的职责，以至于中介者挂掉，可能系统也会挂掉&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;中介者模式，比较适合处理比较稳定的场景，对于一组定义比较良好的对象，预期可变性不是那么强，想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。 比如在DDD领域驱动中，服务层与领域对象的交互就是一个非常稳定的场景，在这个场景里中介者模式得到了比较广泛的运用。&lt;/p&gt;
</description>
<pubDate>Fri, 05 Apr 2019 07:16:00 +0000</pubDate>
<dc:creator>艾心❤</dc:creator>
<og:description>中介者模式简介 提供一个中介对象出来，用于封装一系列对象的交互，从而使各对象不需要直接交互，进一步降低了对象间的耦合度。这是一种行为型设计模式。 由此可见，中介者模式主要解决的是对象间所存在的大量关系</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/edison0621/p/10658807.html</dc:identifier>
</item>
<item>
<title>如何免费创建云端爬虫集群 - my8100</title>
<link>http://www.cnblogs.com/my8100/p/scrapyd-cluster-on-heroku.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/my8100/p/scrapyd-cluster-on-heroku.html</guid>
<description>&lt;h2&gt;在线体验&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://scrapydweb.herokuapp.com/&quot; rel=&quot;nofollow&quot;&gt;scrapydweb.herokuapp.com&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;网络拓扑图&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/892328/201904/892328-20190405144148631-757290246.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;注册帐号&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;Heroku&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;访问 &lt;a href=&quot;https://signup.heroku.com/&quot; rel=&quot;nofollow&quot;&gt;heroku.com&lt;/a&gt; 注册免费账号（注册页面需要调用 google recaptcha 人机验证，登录页面也需要&lt;strong&gt;科学地进行上网&lt;/strong&gt;，访问 APP 运行页面则没有该问题），免费账号最多可以&lt;strong&gt;创建和运行5个 APP&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/892328/201904/892328-20190405145316985-1552219166.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;Redis Labs（可选）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;访问 &lt;a href=&quot;https://redislabs.com/&quot; rel=&quot;nofollow&quot;&gt;redislabs.com&lt;/a&gt; 注册免费账号，提供30MB 存储空间，用于下文通过 &lt;a href=&quot;https://github.com/rmax/scrapy-redis&quot;&gt;scrapy-redis&lt;/a&gt; 实现分布式爬虫。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/892328/201904/892328-20190405145340183-1787943396.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;通过浏览器部署 Heroku APP&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;访问 &lt;a href=&quot;https://github.com/my8100/scrapyd-cluster-on-heroku-scrapyd-app&quot;&gt;my8100/scrapyd-cluster-on-heroku-scrapyd-app&lt;/a&gt; 一键部署 Scrapyd APP。（注意更新页面表单中 Redis 服务器的主机，端口和密码）&lt;/li&gt;
&lt;li&gt;重复第1步完成4个 Scrapyd APP 的部署，假设应用名称为  &lt;span class=&quot;cnblogs_code&quot;&gt;svr-&lt;span&gt;1&lt;/span&gt;&lt;/span&gt; ,  &lt;span class=&quot;cnblogs_code&quot;&gt;svr-&lt;span&gt;2&lt;/span&gt;&lt;/span&gt; ,  &lt;span class=&quot;cnblogs_code&quot;&gt;svr-&lt;span&gt;3&lt;/span&gt;&lt;/span&gt;  和  &lt;span class=&quot;cnblogs_code&quot;&gt;svr-&lt;span&gt;4&lt;/span&gt;&lt;/span&gt; &lt;/li&gt;
&lt;li&gt;访问 &lt;a href=&quot;https://github.com/my8100/scrapyd-cluster-on-heroku-scrapydweb-app&quot;&gt;my8100/scrapyd-cluster-on-heroku-scrapydweb-app&lt;/a&gt; 一键部署 ScrapydWeb APP，取名  &lt;span class=&quot;cnblogs_code&quot;&gt;myscrapydweb&lt;/span&gt; &lt;/li&gt;
&lt;li&gt;（可选）点击 &lt;a href=&quot;https://dashboard.heroku.com/apps/myscrapydweb/settings&quot; rel=&quot;nofollow&quot;&gt;dashboard.heroku.com/apps/myscrapydweb/settings&lt;/a&gt; 页面中的 Reveal Config Vars 按钮相应添加更多 Scrapyd server，例如 KEY 为  &lt;span class=&quot;cnblogs_code&quot;&gt;SCRAPYD_SERVER_2&lt;/span&gt; , VALUE 为  &lt;span class=&quot;cnblogs_code&quot;&gt;svr-&lt;span&gt;2&lt;/span&gt;.herokuapp.com:&lt;span&gt;80&lt;/span&gt;#group2&lt;/span&gt; &lt;/li&gt;
&lt;li&gt;访问 &lt;a href=&quot;https://myscrapydweb.herokuapp.com/&quot; rel=&quot;nofollow&quot;&gt;myscrapydweb.herokuapp.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;跳转 &lt;strong&gt;部署和运行分布式爬虫&lt;/strong&gt; 章节继续阅读。&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;自定义部署&lt;/h2&gt;
&lt;h3&gt;安装工具&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://git-scm.com/book/en/v2/Getting-Started-Installing-Git&quot; rel=&quot;nofollow&quot;&gt;Git&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://devcenter.heroku.com/articles/heroku-cli&quot; rel=&quot;nofollow&quot;&gt;Heroku CLI&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://pypi.org/project/redis/&quot; rel=&quot;nofollow&quot;&gt;Python client for Redis&lt;/a&gt;：运行  &lt;span class=&quot;cnblogs_code&quot;&gt;pip &lt;span&gt;install&lt;/span&gt; redis&lt;/span&gt;  命令即可。&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;下载配置文件&lt;/h3&gt;
&lt;p&gt;新开一个命令行提示符：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
git clone https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;github.com/my8100/scrapyd-cluster-on-heroku&lt;/span&gt;
cd scrapyd-cluster-on-heroku
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;登录 Heroku&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
heroku &lt;span&gt;login&lt;/span&gt;&lt;span&gt;
# outputs:
# heroku: Press any key to open up the browser to &lt;/span&gt;&lt;span&gt;login&lt;/span&gt;&lt;span&gt; or q to exit:
# Opening browser to https:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;cli-auth.heroku.com/auth/browser/12345-abcde&lt;/span&gt;
# Logging &lt;span&gt;in&lt;/span&gt;... &lt;span&gt;done&lt;/span&gt;&lt;span&gt;
# Logged &lt;/span&gt;&lt;span&gt;in&lt;/span&gt; as username@gmail.com
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;创建 Scrapyd 集群&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;新建 Git 仓库&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;cd scrapyd
git init
# explore and update the files &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; needed
git status
git add .
git commit &lt;/span&gt;-a -m &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;first commit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
git status&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;部署 Scrapyd APP&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
heroku apps:create svr-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
heroku git:remote &lt;/span&gt;-a svr-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
git remote &lt;/span&gt;-&lt;span&gt;v
git push heroku master
heroku logs &lt;/span&gt;--&lt;span&gt;tail&lt;/span&gt;&lt;span&gt;
# Press ctrl&lt;/span&gt;+&lt;span&gt;c to stop logs outputting
# Visit https:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;svr-1.herokuapp.com&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;ol start=&quot;3&quot; readability=&quot;-1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;添加环境变量&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;设置时区&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
# python -c &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;import tzlocal; print(tzlocal.get_localzone())&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
heroku config:set TZ&lt;/span&gt;=Asia/&lt;span&gt;Shanghai
# heroku config:get TZ&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;&lt;li&gt;添加 Redis 账号（可选，详见 &lt;em&gt;scrapy_redis_demo_project.zip&lt;/em&gt; 中的 &lt;em&gt;settings.py&lt;/em&gt;）&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
heroku config:set REDIS_HOST=your-redis-&lt;span&gt;host
heroku config:set REDIS_PORT&lt;/span&gt;=your-redis-&lt;span&gt;port
heroku config:set REDIS_PASSWORD&lt;/span&gt;=your-redis-password
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;重复上述第2步和第3步完成余下三个 Scrapyd APP 的部署和配置： &lt;span class=&quot;cnblogs_code&quot;&gt;svr-&lt;span&gt;2&lt;/span&gt;&lt;/span&gt; ， &lt;span class=&quot;cnblogs_code&quot;&gt;svr-&lt;span&gt;3&lt;/span&gt;&lt;/span&gt;  和  &lt;span class=&quot;cnblogs_code&quot;&gt;svr-&lt;span&gt;4&lt;/span&gt;&lt;/span&gt; &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;创建 ScrapydWeb APP&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;新建 Git 仓库&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;cd ..
cd scrapydweb
git init
# explore and update the files &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; needed
git status
git add .
git commit &lt;/span&gt;-a -m &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;first commit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
git status&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;部署 ScrapydWeb APP&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;heroku apps:create myscrapydweb
heroku git:remote &lt;/span&gt;-&lt;span&gt;a myscrapydweb
git remote &lt;/span&gt;-&lt;span&gt;v
git push heroku master&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;ol start=&quot;3&quot; readability=&quot;-1.8841870824053&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;添加环境变量&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;设置时区&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
heroku config:set TZ=Asia/Shanghai
&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;&lt;li&gt;添加 Scrapyd server（详见 &lt;em&gt;scrapydweb&lt;/em&gt; 目录下的 &lt;em&gt;scrapydweb_settings_v8.py&lt;/em&gt;）&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
heroku config:set SCRAPYD_SERVER_1=svr-&lt;span&gt;1&lt;/span&gt;.herokuapp.com:&lt;span&gt;80&lt;/span&gt;&lt;span&gt;
heroku config:set SCRAPYD_SERVER_2&lt;/span&gt;=svr-&lt;span&gt;2&lt;/span&gt;.herokuapp.com:&lt;span&gt;80&lt;/span&gt;&lt;span&gt;#group1
heroku config:set SCRAPYD_SERVER_3&lt;/span&gt;=svr-&lt;span&gt;3&lt;/span&gt;.herokuapp.com:&lt;span&gt;80&lt;/span&gt;&lt;span&gt;#group1
heroku config:set SCRAPYD_SERVER_4&lt;/span&gt;=svr-&lt;span&gt;4&lt;/span&gt;.herokuapp.com:&lt;span&gt;80&lt;/span&gt;#group2
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li readability=&quot;-0.27777777777778&quot;&gt;
&lt;p&gt;访问 &lt;a href=&quot;https://myscrapydweb.herokuapp.com/&quot; rel=&quot;nofollow&quot;&gt;myscrapydweb.herokuapp.com&lt;/a&gt; &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/892328/201904/892328-20190405144919207-313578767.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;部署和运行分布式爬虫&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;上传 demo 项目，即 &lt;em&gt;scrapyd-cluster-on-heroku&lt;/em&gt; 目录下的压缩文档 &lt;em&gt;scrapy_redis_demo_project.zip&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;将种子请求推入  &lt;span class=&quot;cnblogs_code&quot;&gt;mycrawler:start_urls&lt;/span&gt;  触发爬虫并查看结果&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
In [1]: &lt;span&gt;import&lt;/span&gt; redis  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; pip install redis&lt;/span&gt;
&lt;span&gt;
In [&lt;/span&gt;2]: r = redis.Redis(host=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;your-redis-host&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, port=your-redis-port, password=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;your-redis-password&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

In [&lt;/span&gt;3]: r.delete(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;mycrawler_redis:requests&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;mycrawler_redis:dupefilter&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;mycrawler_redis:items&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
Out[&lt;/span&gt;3&lt;span&gt;]: 0

In [&lt;/span&gt;4]: r.lpush(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;mycrawler:start_urls&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://books.toscrape.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://quotes.toscrape.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
Out[&lt;/span&gt;4]: 2

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; wait for a minute&lt;/span&gt;
In [5]: r.lrange(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;mycrawler_redis:items&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 0, 1&lt;span&gt;)
Out[&lt;/span&gt;5&lt;span&gt;]:
[b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;{&quot;url&quot;: &quot;http://quotes.toscrape.com/&quot;, &quot;title&quot;: &quot;Quotes to Scrape&quot;, &quot;hostname&quot;: &quot;d6cf94d5-324e-4def-a1ab-e7ee2aaca45a&quot;, &quot;crawled&quot;: &quot;2019-04-02 03:42:37&quot;, &quot;spider&quot;: &quot;mycrawler_redis&quot;}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
 b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;{&quot;url&quot;: &quot;http://books.toscrape.com/index.html&quot;, &quot;title&quot;: &quot;All products | Books to Scrape - Sandbox&quot;, &quot;hostname&quot;: &quot;d6cf94d5-324e-4def-a1ab-e7ee2aaca45a&quot;, &quot;crawled&quot;: &quot;2019-04-02 03:42:37&quot;, &quot;spider&quot;: &quot;mycrawler_redis&quot;}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/892328/201904/892328-20190405145134824-1004981760.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;优点
&lt;ul&gt;&lt;li&gt;免费&lt;/li&gt;
&lt;li&gt;可以爬 Google 等外网&lt;/li&gt;
&lt;li&gt;可扩展（借助于 &lt;a href=&quot;https://github.com/my8100/scrapydweb&quot;&gt;ScrapydWeb&lt;/a&gt;）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;缺点
&lt;ul&gt;&lt;li&gt;注册和登录需要科学地进行上网&lt;/li&gt;
&lt;li&gt;Heroku APP 每天至少自动重启一次并且重置所有文件，因此需要外接数据库保存数据，详见 &lt;a href=&quot;https://devcenter.heroku.com/articles/dynos#restarting&quot; rel=&quot;nofollow&quot;&gt;devcenter.heroku.com&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;GitHub 开源&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/my8100/scrapyd-cluster-on-heroku/blob/master/README_CN.md&quot; target=&quot;_blank&quot;&gt;my8100/scrapyd-cluster-on-&lt;/a&gt;heroku&lt;/p&gt;

</description>
<pubDate>Fri, 05 Apr 2019 07:10:00 +0000</pubDate>
<dc:creator>my8100</dc:creator>
<og:description>在线体验 scrapydweb.herokuapp.com 网络拓扑图 注册帐号 访问 heroku.com 注册免费账号（注册页面需要调用 google recaptcha 人机</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/my8100/p/scrapyd-cluster-on-heroku.html</dc:identifier>
</item>
<item>
<title>Effective Java 第三版—— 87. 考虑使用自定义序列化形式 - 林本托</title>
<link>http://www.cnblogs.com/IcanFixIt/p/10658764.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/IcanFixIt/p/10658764.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;Tips&lt;br/&gt;书中的源代码地址：https://github.com/jbloch/effective-java-3e-source-code&lt;br/&gt;注意，书中的有些代码里方法是基于Java 9 API中的，所以JDK 最好下载 JDK 9以上的版本。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4366140-8966e457a14bc8b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Effective Java, Third Edition&quot;/&gt;&lt;/p&gt;

&lt;p&gt;当在时间紧迫的情况下编写类时，通常应该将精力集中在设计最佳API上。有时这意味着发布一个“一次性使用（throwaway）”实现，将在将来的版本中替换它。通常这不是一个问题，但是如果类实现Serializable并使用默认的序列化形式，将永远无法完全“摆脱一次性使用”的实现了。它永远决定序列化的形式。这不仅仅是一个理论问题。这种情况发生在Java类库中的几个类上，包括BigInteger。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果没有考虑是否合适，请不要接受默认的序列化形式&lt;/strong&gt;。 接受默认的序列化形式应该有意识地决定，从灵活性，性能和正确性的角度来看这种编码是合理的。 一般来说，只有在与设计自定义序列化形式时所选择的编码大致相同的情况下，才应接受默认的序列化形式。&lt;/p&gt;
&lt;p&gt;对象的默认序列化形式是对象图（object graph）的物理表示形式的一种相当有效的编码，该表示形式以对象为根。换句话说，它描述了对象中包含的数据以及从该对象可以访问的每个对象中的数据。它还描述了所有这些对象相互关联的拓扑结构。理想的对象序列化形式只包含对象所表示的逻辑数据。它独立于物理表示。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果对象的物理表示与其逻辑内容相同，则默认的序列化形式可能是合适的&lt;/strong&gt;。例如，默认的序列化形式对于下面的类来说是合理的，它简单地表示一个人的名字:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Good candidate for default serialized form
public class Name implements Serializable {
    /**
     * Last name. Must be non-null.
     * @serial
     */
    private final String lastName;

    /**
     * First name. Must be non-null.
     * @serial
     */
    private final String firstName;

    /**
     * Middle name, or null if there is none.
     * @serial
     */
    private final String middleName;

    ... // Remainder omitted
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从逻辑上讲，名称由三个字符串组成，分别表示姓、名和中间名。名称中的实例属性精确地反映了这个逻辑内容。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;即使你确定默认的序列化形式是合适的，通常也必须提供readObject方法以确保不变性和安全性&lt;/strong&gt;。 对于Name类，readObject方法必须确保属性lastName和firstName为非null。 条目 88和90详细讨论了这个问题。&lt;/p&gt;
&lt;p&gt;注意，虽然lastName、firstName和middleName属性是私有的，但是它们都有文档注释。这是因为这些私有属性定义了一个公共API，它是类的序列化形式，并且必须对这个公共API进行文档化。&lt;code&gt;@serial&lt;/code&gt;标签的存在告诉Javadoc将此文档放在一个特殊的页面上，该页面记录序列化的形式。&lt;/p&gt;
&lt;p&gt;与Name类的另一极端，考虑下面的类，它表示一个字符串列表(暂时忽略使用标准List实现可能更好的建议):&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Awful candidate for default serialized form
public final class StringList implements Serializable {
    private int size = 0;
    private Entry head = null;

    private static class Entry implements Serializable {
        String data;
        Entry  next;
        Entry  previous;
    }

    ... // Remainder omitted
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从逻辑上讲，这个类表示字符串序列。在物理上，它将序列表示为双链表。如果接受默认的序列化形式，则序列化形式将煞费苦心地镜像链表中的每个entry，以及每一个entry之间的所有双向链接。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当对象的物理表示与其逻辑数据内容有很大差异时，使用默认的序列化形式有四个缺点&lt;/strong&gt;:&lt;/p&gt;
&lt;ul readability=&quot;7&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;它将导出的API永久绑定到当前类的内部表示&lt;/strong&gt;。 在上面的示例中，私有&lt;code&gt;StringList.Entry&lt;/code&gt;类成为公共API的一部分。 如果在将来的版本中更改了表示，则StringList类仍需要接受输入上的链表表示，并在输出时生成它。 该类永远不会消除处理链表entry的所有代码，即使不再使用它们。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;它会消耗过多的空间&lt;/strong&gt;。 在上面的示例中，序列化形式不必要地表示链接列表中的每个entry和所有链接。 这些entry和链接仅仅是实现细节，不值得包含在序列化形式中。 由于序列化形式过大，将其写入磁盘或通过网络发送将会非常慢。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;它会消耗过多的时间&lt;/strong&gt;。 序列化逻辑不了解对象图的拓扑结构，因此必须经历昂贵的图遍历。 在上面的例子中，仅仅遵循下一个引用就足够了。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;&lt;strong&gt;它会导致堆栈溢出&lt;/strong&gt;。 默认的序列化过程执行对象图的递归遍历，即使对于中等大小的对象图，也可能导致堆栈溢出。 使用1,000-1,800个元素序列化StringList实例，就会在我的机器上生成StackOverflowError异常。 令人惊讶的是，序列化导致堆栈溢出的最小列表大小因运行而异（在我的机器上）。 显示此问题的最小列表大小可能取决于平台实现和命令行标记; 某些实现可能根本没有这个问题。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;StringList的合理序列化形式，就是列表中的字符串数量，然后紧跟着字符串本身。这构成了由StringList表示的逻辑数据，去掉了其物理表示的细节。下面是修改后的StringList版本，包含实现此序列化形式的writeObject和readObject方法。提醒一下，transient修饰符表示要从类的默认序列化形式中省略一个实例属性:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// StringList with a reasonable custom serialized form
public final class StringList implements Serializable {
    private transient int size   = 0;
    private transient Entry head = null;

    // No longer Serializable!
    private static class Entry {
        String data;
        Entry  next;
        Entry  previous;
    }

    // Appends the specified string to the list
    public final void add(String s) { ... }

    /**
     * Serialize this {@code StringList} instance.
     *
     * @serialData The size of the list (the number of strings
     * it contains) is emitted ({@code int}), followed by all of
     * its elements (each a {@code String}), in the proper
     * sequence.
     */
    private void writeObject(ObjectOutputStream s)
            throws IOException {
        s.defaultWriteObject();
        s.writeInt(size);

        // Write out all elements in the proper order.
        for (Entry e = head; e != null; e = e.next)
            s.writeObject(e.data);
    }

    private void readObject(ObjectInputStream s)
            throws IOException, ClassNotFoundException {
        s.defaultReadObject();
        int numElements = s.readInt();

        // Read in all elements and insert them in list
        for (int i = 0; i &amp;lt; numElements; i++)
            add((String) s.readObject());
    }

    ... // Remainder omitted
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;writeObject做的第一件事就是调用defaultWriteObject方法，而readObject做的第一件事就是调用defaultReadObject，即使所有StringList的属性都是瞬时状态（transient）的。 你可能会听到它说如果所有类的实例属性都是瞬时状态的，那么可以省去调用defaultWriteObject和defaultReadObject，但序列化规范要求无论如何都要调用它们。 这些调用的存在使得可以在以后的版本中添加非瞬时状态的实例属性，同时保持向后和向前兼容性。 如果实例在更高版本中序列化，并在早期版本中反序列化，则添加的属性将被忽略。 如果早期版本的readObject方法无法调用defaultReadObject，则反序列化将失败，抛出StreamCorruptedException异常。&lt;/p&gt;
&lt;p&gt;请注意，writeObject方法有一个文档注释，即使它是私有的。 这类似于Name类中私有属性的文档注释。 此私有方法定义了一个公共API，它是序列化形式，并且应该记录公共API。 与属性的&lt;code&gt;@serial&lt;/code&gt;标签一样，方法的&lt;code&gt;@serialData&lt;/code&gt;标签告诉Javadoc实用程序将此文档放在序列化形式的页面上。&lt;/p&gt;
&lt;p&gt;为了给前面的性能讨论提供一定的伸缩性，如果平均字符串长度是10个字符，那么经过修改的StringList的序列化形式占用的空间大约是原始字符串序列化形式的一半。在我的机器上，长度为10的列表，序列化修订后的StringList的速度是序列化原始版本的两倍多。最后，在修改后的序列化形式中没有堆栈溢出问题，因此对于可序列化的StringList的大小没有实际的上限。&lt;/p&gt;
&lt;p&gt;虽然默认的序列化形式对于StringList来说是不好的，但是对于有些类会可能更糟糕。 对于StringList，默认的序列化形式是不灵活的，并且执行得很糟糕，但是在序列化和反序列化StringList实例，它产生了原始对象的忠实副本，其所有不变性都是完整的。 对于其不变性与特定实现的详细信息相关联的任何对象，情况并非如此。&lt;/p&gt;
&lt;p&gt;例如，考虑哈希表（hash table）的情况。它的物理表示是一系列包含键值（key-value）项的哈希桶。每一项所在桶的位置，是其键的散列代码的方法决定的，通常情况下，不能保证从一个实现到另一个实现是相同的。事实上，它甚至不能保证每次运行都是相同的。因此，接受哈希表的默认序列化形式会构成严重的错误。对哈希表进行序列化和反序列化可能会产生一个不变性严重损坏的对象。&lt;/p&gt;
&lt;p&gt;无论是否接受默认的序列化形式，当调用defaultWriteObject方法时，没有标记为transient的每个实例属性都会被序列化。因此，可以声明为transient的每个实例属性都应该是。这包括派生（derived）属性，其值可以从主要数据属性（primary data fields）(如缓存的哈希值)计算。它还包括一些属性，这些属性的值与JVM的一个特定运行相关联，比如表示指向本地数据结构指针的long型属性。&lt;strong&gt;在决定使非瞬时状态的属性之前，请确信它的值是对象逻辑状态的一部分&lt;/strong&gt;。如果使用自定义序列化形式，则大多数或所有实例属性都应该标记为transient，如上面的StringList示例所示。&lt;/p&gt;
&lt;p&gt;如果使用默认的序列化形式，并且标记了一个或多个属性为transient，请记住，当反序列化实例时，这些属性将初始化为默认值：对象引用属性为null，基本数字类型的属性为0，布尔属性为false [JLS, 4.12.5]。如果这些值对于任何瞬时状态的属性都不可接受，则必须提供一个readObject方法，该方法调用defaultReadObject方法，然后将瞬时状态的属性恢复为可接受的值(条目 88)。或者，这些属性可以在第一次使用时进行延迟初始化（条目 83）。&lt;/p&gt;
&lt;p&gt;无论是否使用默认的序列化形式，&lt;strong&gt;必须对对象序列化加以同步，也要对读取对象的整个状态的任何方法施加同步。&lt;/strong&gt;。 因此，例如如果有一个线程安全的对象（条目 82）通过同步每个方法来实现其线程安全，并且选择使用默认的序列化形式，请使用以下write-Object方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// writeObject for synchronized class with default serialized form
private synchronized void writeObject(ObjectOutputStream s)
        throws IOException {
    s.defaultWriteObject();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果将同步放在writeObject方法中，则必须确保它遵守与其他活动相同的锁排序( lock-ordering)约束，否则将面临资源排(resource-ordering)序死锁的风险[Goetz06, 10.1.5]。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;无论选择哪种序列化形式，都要在编写的每个可序列化类中声明显式的序列版本UID&lt;/strong&gt;。这消除了序列版本UID作为不兼容性的潜在来源(条目 86)。还有一个小的性能优势。如果没有提供序列版本UID，则需要执行昂贵的计算来在运行时生成一个UID。&lt;/p&gt;
&lt;p&gt;声明序列版本UID很简单。只需要在类中添加这一行:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private static final long serialVersionUID = randomLongValue;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如编写一个新类，为&lt;code&gt;randomLongValue&lt;/code&gt;选择什么值并不重要。可以通过在类上运行serialver实用程序来生成该值，但是也可以凭空选择一个数字。序列版本UID不需要是惟一的。如果修改缺少序列版本UID的现有类，并且希望新版本接受现有的序列化实例，则必须使用为旧版本自动生成的值。可以通过在类的旧版本上运行serialver实用程序(序列化实例存在于旧版本上)来获得这个数字。&lt;/p&gt;
&lt;p&gt;如果想要创建与现有版本不兼容的类的新版本，只需更改序列版本UID声明中的值即可。 这将导致尝试反序列化先前版本的序列化实例抛出InvalidClassException异常。 &lt;strong&gt;不要更改序列版本UID，除非想破坏与类的所有现有序列化实例的兼容性&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;总而言之，如果你已确定某个类应该可序列化（条目 86），请仔细考虑序列化形式应该是什么。 仅当它是对象逻辑状态的合理描述时，才使用默认的序列化形式；否则设计一个适当描述对象的自定义序列化形式。 在分配设计导出方法时，应该分配尽可能多的时间来设计类的序列化形式（条目 51）。 正如无法从将来的版本中删除导出的方法一样，也无法从序列化形式中删除属性；必须永久保存它们以确保序列化兼容性。 选择错误的序列化形式会对类的复杂性和性能产生永久性的负面影响。&lt;/p&gt;
</description>
<pubDate>Fri, 05 Apr 2019 07:05:00 +0000</pubDate>
<dc:creator>林本托</dc:creator>
<og:description>Tips 书中的源代码地址：https://github.com/jbloch/effective java 3e source code 注意，书中的有些代码里方法是基于Java 9 API中的，所</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/IcanFixIt/p/10658764.html</dc:identifier>
</item>
<item>
<title>[开源]快速构建文件下载，支持文件加密，自定义限速 - MeetYan</title>
<link>http://www.cnblogs.com/MeetYan/p/10658762.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MeetYan/p/10658762.html</guid>
<description>&lt;p&gt;在WebForm下新建一般处理程序，并实现DownloadHandler抽象类&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
///     FileDownloadHandler 的摘要说明
/// &amp;lt;/summary&amp;gt;
public class FileDownloadHandler : DownloadHandler, IHttpHandler
{
    public void ProcessRequest(HttpContext context)
    {
        var fileName = context.Request[&quot;fileName&quot;];
        StartDownloading(context, fileName);
    }

    public bool IsReusable =&amp;gt; false;

    public override void OnDownloadFailed(HttpContext context, string fileName, string filePath, string ex)
    {
        context.Response.Write(ex);
    }

    public override void OnDownloadSucceed(HttpContext context, string fileName, string filePath)
    {
        var result = $&quot;文件[{fileName}]下载成功，映射路径：{filePath}&quot;;
        context.Response.Write(result);
    }
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 05 Apr 2019 07:04:00 +0000</pubDate>
<dc:creator>MeetYan</dc:creator>
<og:description>项目说明 1. 目前支持WebForm文件下载，后续支持Mvc 2. 支持下载文件加密以及下载限速 3. 项目源码： 'MasterChief.DotNet.Framework.Download' 4</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/MeetYan/p/10658762.html</dc:identifier>
</item>
<item>
<title>font and face, 浅探Emacs字体选择机制及部分记录 - 不为己身之荣光</title>
<link>http://www.cnblogs.com/eadle/p/10658661.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/eadle/p/10658661.html</guid>
<description>&lt;h2 id=&quot;缘起&quot;&gt;缘起&lt;/h2&gt;
&lt;p&gt;最近因为仰慕org-mode，从vim迁移到了Emacs。偶然发现org-mode中调出的calendar第一行居然没有对齐，排查一下发现是字体的问题。刚好也想改改Emacs的字体，于是我就开始了一段查找资料的过程。&lt;/p&gt;
&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;p&gt;纯原始Emacs，init.el中仅有Customize的theme信息，以前一直使用的是&lt;strong&gt;默认&lt;/strong&gt;字体。笔者刚开始使用Emacs三天，因假期在即得以偷闲有时间查资料。&lt;/p&gt;
&lt;h2 id=&quot;浅探&quot;&gt;浅探&lt;/h2&gt;
&lt;p&gt;现象：Org mode使用C-c .调出的Calendar第一行日期没有对齐，看起来非常别扭。&lt;/p&gt;
&lt;p&gt;过程：再横排出现问题但是竖排没有，Google之，是字体不等宽的问题。于是乎，最简单的方式就是设置一个等宽字体，Google 一下“Emacs设置等宽字体”得到函数set-face-attribute，抄之，写作&lt;/p&gt;
&lt;pre class=&quot;elisp&quot;&gt;
&lt;code&gt;(set-face-attribute 'default nil :font &quot;Fira Code Retina&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中，Fira Code是我很喜欢的一个等宽字体。&lt;/p&gt;
&lt;p&gt;结果：Calendar显示正常。&lt;/p&gt;
&lt;h2 id=&quot;追究&quot;&gt;追究&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;技术就是解决问题，当问题被解决后继续投入精力就是浪费精力。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然而字体问题远不止这么简单，现在我设置了一个等宽字体，如果我想再换一个中文字体呢？再使用一遍&lt;code&gt;set-face-attribute&lt;/code&gt;显然是行不通的。使用微软雅黑等宽这样的特制字体自然是很方便，但是这样就限制了选择字体的自由。&lt;/p&gt;
&lt;h3 id=&quot;路线&quot;&gt;路线&lt;/h3&gt;
&lt;p&gt;明确一下，我的目标是能够为不同语言定制字体，最好保持等宽，并且能够适应放大缩小。&lt;/p&gt;
&lt;p&gt;很显然，问题在于emac在背后是如何选择一个字体(font)的。从头捋一遍，思路如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Emacs内部使用的编码集是什么？是否支持Unicode？&lt;/li&gt;
&lt;li&gt;Emacs对编码方式的支持如何？&lt;/li&gt;
&lt;li&gt;对特定的character，Emacs如何选择字体？&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;set-face-attribute&lt;/code&gt;&lt;/strong&gt;是如何起作用的？应该用什么方式实现定制？&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;前两个问题使用Google可以得到，Emacs在最近（实际上也是很久以前了）的版本中使用Unicode重新实现了一遍，我的Emacs是24，支持Unicode；Emacs支持多种编码方式，至少utf-8、gb2312、gbk这样的编码方式是支持的。&lt;/p&gt;
&lt;h3 id=&quot;face&quot;&gt;face&lt;/h3&gt;
&lt;p&gt;对于第三个问题，GNU Emacs Manual的&lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/elisp/Font-Selection.html&quot;&gt;font slection&lt;/a&gt;一节中指出：&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;在Emacs将一个字符绘制到图形显示设备之前，它必须为这个字符选择一个字体。正常来说，Emacs会自动根据该font被赋予的那个&lt;strong&gt;face&lt;/strong&gt;的属性选择字体——具体而言，就是face属性&lt;code&gt;:family&lt;/code&gt;, &lt;code&gt;:weight&lt;/code&gt;, &lt;code&gt;:slant&lt;/code&gt;, and &lt;code&gt;:width&lt;/code&gt;。这个选择过程也依赖于被显示的那个字符——某些字体只能显示有限的字符。如果没有精确符合条件的字体，Emacs就会&lt;strong&gt;寻找匹配程度最高的字体。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么，什么是face呢？继续查阅Emacs手册，在&lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/elisp/Displaying-Faces.html&quot;&gt;Display Faces&lt;/a&gt;一节中，有：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;当Emacs显示给定的文本片段时，文本的视觉外观可以由从不同来源指定的face确定。如果这些来源同时对某个特定的字符指定了超过一个的face，那么Emacs将会把这些faces的属性合并起来。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;无论是Wiki还是能找到的资料，对于Face的定义都是”关于要显示出来的东西的外在属性的定义“，包括font的属性（family，width，slant等等），还有颜色、下划线等等等等（Emacs wiki上甚至说“我们需要一个明确的定义”）。话句话说，face指定了我们会看到什么东西。&lt;/p&gt;
&lt;p&gt;同一节指出了合并face的属性的优先级。其中最低的优先级是default face，也就是我一开始查到的命令所设置的东西，使用&lt;code&gt;M-h f set-face-attribute&lt;/code&gt;可以得到&lt;/p&gt;
&lt;blockquote readability=&quot;14&quot;&gt;
&lt;p&gt;(set-face-attribute FACE FRAME &amp;amp;rest ARGS)&lt;/p&gt;
&lt;p&gt;Set attributes of FACE on FRAME from ARGS.&lt;br/&gt;This function overrides the face attributes specified by FACE's&lt;br/&gt;face spec. It is mostly intended for internal use only.&lt;/p&gt;
&lt;p&gt;If FRAME is nil, set the attributes for all existing frames, as&lt;br/&gt;well as the default for new frames. If FRAME is t, change the&lt;br/&gt;default for new frames only.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因为设置了默认的face，并且init.el和别的插件（org）也没有更改face，所以对于能够用Fira Code显示的character，Emacs自动选择了Fira Code。&lt;/p&gt;
&lt;p&gt;那么，Emacs又是如何&lt;em&gt;寻找&lt;/em&gt;”匹配程度最高“的字体的呢？这就不得不说到另外一个概念了：fontset&lt;/p&gt;
&lt;h3 id=&quot;fontset&quot;&gt;fontset&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://www.emacswiki.org/emacs/FontSets&quot;&gt;Emacs Wiki&lt;/a&gt;上对fontset有一个基本的描述，总结起来要点如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;fontset是能够确定某个font能表示&lt;strong&gt;哪些&lt;/strong&gt;character。它使用&amp;lt;CHARSET or CHAR RANGE&amp;gt; - &amp;lt;FONT NAME&amp;gt;的二元组的表来实现这一点。&lt;/li&gt;
&lt;li&gt;fontset可以被&lt;strong&gt;修改&lt;/strong&gt;，因而如果想使用某种特殊的font来绘制某些字符，使用标准fontset并修改它是最好的选择。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;使用&lt;code&gt;M-x describe-fontset &amp;lt;RET&amp;gt; &amp;lt;RET&amp;gt;&lt;/code&gt;可以查询到当前fontset的详细信息（运行比较慢），我的显示如下（经过了修改）：&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;Fontset: -outline-Fira Code Retina-normal-normal-normal-mono-17-&lt;em&gt;-&lt;/em&gt;-&lt;em&gt;-c-&lt;/em&gt;-fontset-auto1&lt;br/&gt;CHAR RANGE (CODE RANGE)&lt;br/&gt;FONT NAME (REQUESTED and [OPENED])&lt;br/&gt;C-@ ..  (#x43 .. #x9F)&lt;br/&gt;-&lt;em&gt;-&lt;/em&gt;-&lt;em&gt;-&lt;/em&gt;-&lt;em&gt;-&lt;/em&gt;-&lt;em&gt;-&lt;/em&gt;-&lt;em&gt;-&lt;/em&gt;-&lt;em&gt;-&lt;/em&gt;-iso8859-1&lt;br/&gt;  (#xA0)&lt;br/&gt;-&lt;em&gt;-微软雅黑-&lt;/em&gt;-&lt;em&gt;-&lt;/em&gt;-&lt;em&gt;-&lt;/em&gt;-&lt;em&gt;-&lt;/em&gt;-&lt;em&gt;-&lt;/em&gt;-&lt;em&gt;-&lt;/em&gt;-&lt;em&gt;&lt;br/&gt;¡ .. « (#xA1 .. #xAB)&lt;br/&gt;-&lt;/em&gt;-&lt;em&gt;-&lt;/em&gt;-&lt;em&gt;-&lt;/em&gt;-&lt;em&gt;-&lt;/em&gt;-&lt;em&gt;-&lt;/em&gt;-&lt;em&gt;-&lt;/em&gt;-&lt;em&gt;-iso8859-1&lt;br/&gt;¬ (#xAC)&lt;br/&gt;-&lt;/em&gt;-微软雅黑-&lt;em&gt;-&lt;/em&gt;-&lt;em&gt;-&lt;/em&gt;-&lt;em&gt;-&lt;/em&gt;-&lt;em&gt;-&lt;/em&gt;-&lt;em&gt;-&lt;/em&gt;-&lt;em&gt;-&lt;/em&gt;&lt;br/&gt;­ .. ¯ (#xAD .. #xAF)&lt;br/&gt;-&lt;em&gt;-&lt;/em&gt;-&lt;em&gt;-&lt;/em&gt;-&lt;em&gt;-&lt;/em&gt;-&lt;em&gt;-&lt;/em&gt;-&lt;em&gt;-&lt;/em&gt;-&lt;em&gt;-&lt;/em&gt;-iso8859-1&lt;br/&gt;° .. ± (#xB0 .. #xB1)&lt;br/&gt;-&lt;em&gt;-微软雅黑-&lt;/em&gt;-&lt;em&gt;-&lt;/em&gt;-&lt;em&gt;-&lt;/em&gt;-&lt;em&gt;-&lt;/em&gt;-&lt;em&gt;-&lt;/em&gt;-&lt;em&gt;-&lt;/em&gt;-*&lt;br/&gt;...&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;CHAR RANGE打头的第二行以及第三行是表头，下面每两行是一组，每组第一行格式是&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;范围开始处符号&amp;gt; .. &amp;lt;范围结束处符号&amp;gt; (&amp;lt;范围开始处符号码值&amp;gt; .. &amp;lt;范围结束处符号码值&amp;gt;)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;第二行即是&lt;a href=&quot;https://en.wikipedia.org/wiki/X_logical_font_description&quot;&gt;XLFD格式&lt;/a&gt;的font描述，这是X window system的字体标准。&lt;/p&gt;
&lt;p&gt;当Emacs发现指定的face中的font（我的是Fira Code）无法显示这个字符时，它就会按照字符集到fontset中找到能够显示这个字符的字体，并且使用之。&lt;/p&gt;
&lt;p&gt;fontset可以使用&lt;code&gt;set-fontset-font&lt;/code&gt;来进行修改。我设置中文字符的代码如下，其中script的顺序来自&lt;a href=&quot;http://zhuoqiang.me/torture-emacs.html&quot;&gt;这篇博客&lt;/a&gt;：&lt;/p&gt;
&lt;pre class=&quot;elisp&quot;&gt;
&lt;code&gt;(dolist (charset '(kana han symbol cjk-misc bopomofo))
(set-fontset-font (frame-parameter nil 'font)
            charset (font-spec :family &quot;微软雅黑&quot;))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;set-fontset-font的使用非常易于理解，&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;(set-fontset-font NAME TARGET FONT-SPEC &amp;amp;optional FRAME ADD)&lt;/p&gt;
&lt;p&gt;Modify fontset NAME to use FONT-SPEC for TARGET characters.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以上代码其实就是从frame-parameter中取出当前frame的fontset，然后向这个fontset插入某些字符的字体。TARGET可以是字符范围的起始和结束的cons；可以是script的名字（我的就是script的名字），也可以是一个charset。FONT-SPEC可以用font-spec来确定字体，&lt;strong&gt;不用&lt;/strong&gt;手写XLFD了。&lt;/p&gt;
&lt;p&gt;使用按键组合&lt;code&gt;C-u C-x =&lt;/code&gt;可以查看point下的那个character的信息，比如笔者在”你“字上按下之后显示如此：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&lt;br/&gt;position: 192 of 192 (99%), column: 0&lt;br/&gt;character: 你 (displayed as 你) (codepoint 20320, #o47540, #x4f60)&lt;br/&gt;preferred charset: chinese-gbk (GBK Chinese simplified.)&lt;br/&gt;code point in charset: 0xC4E3&lt;br/&gt;script: han&lt;br/&gt;syntax: w which means: word&lt;br/&gt;category: .:Base, C:2-byte han, L:Left-to-right (strong), c:Chinese, j:Japanese, |:line breakable&lt;br/&gt;to input: type &quot;C-x 8 RET HEX-CODEPOINT&quot; or &quot;C-x 8 RET NAME&quot;&lt;br/&gt;buffer code: #xE4 #xBD #xA0&lt;br/&gt;file code: #xC4 #xE3 (encoded by coding system chinese-gbk-dos)&lt;br/&gt;display: by this font (glyph code)&lt;br/&gt;uniscribe:-outline-微软雅黑-normal-normal-normal-sans-20-&lt;em&gt;-&lt;/em&gt;-&lt;em&gt;-p-&lt;/em&gt;-iso8859-1 (#x482)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Character code properties: customize what to show&lt;br/&gt;name: CJK IDEOGRAPH-4F60&lt;br/&gt;general-category: Lo (Letter, Other)&lt;br/&gt;decomposition: (20320) ('你')&lt;br/&gt;&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;中英混排等宽&quot;&gt;中英混排等宽&lt;/h3&gt;
&lt;p&gt;关于emacs的中英文混排下的等宽以及放缩兼容，这篇博客&lt;a href=&quot;http://baohaojun.github.io/perfect-emacs-chinese-font.html&quot;&gt;狠狠地折腾了一把Emacs中文字体&lt;/a&gt;进行了一系列探索，改进了把中文字体和英文字体各自设置一个固定的值的方法，转为某种字体设置放缩系数，最终得到了一个不错的结果。&lt;/p&gt;
&lt;p&gt;但是字体之间的宽度并不是一个固定的比例，对于每种不同的中文——英文字体组合，使用者都需要找不同的参数，还是比较麻烦的。虽然字体并不是一个常换的东西（也许。从这个角度讲，或许直接换一个中英文兼有的等宽字体才是正道。&lt;/p&gt;
&lt;p&gt;github上也有个项目&lt;a href=&quot;https://github.com/tumashu/cnfonts&quot;&gt;cnfonts&lt;/a&gt;，能够解决中英混排等宽的问题，作者自述原理是”让中文字体和英文字体使用不同的字号，从而实现中英文对齐“，效果非常不错，安装也很方便，推荐大家试试。&lt;/p&gt;
&lt;h2 id=&quot;结论&quot;&gt;结论&lt;/h2&gt;
&lt;p&gt;鱼和熊掌不可得兼，选择了选取字体的自由后，就势必牺牲了适配的便捷性。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;可以set-face-attribute设置一个默认的中英文等宽字体&lt;/li&gt;
&lt;li&gt;通过修改fontset来修改特定的字体&lt;/li&gt;
&lt;li&gt;可以使用第三方包来解决问题。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;另外，找完之后才发现，我上一秒还在看Org-mode学习timestamp的用法，回过神来就已经开了十几个网页学习Emacs的font了。这种time-killer的折腾还是需要谨慎。&lt;/p&gt;
</description>
<pubDate>Fri, 05 Apr 2019 06:37:00 +0000</pubDate>
<dc:creator>不为己身之荣光</dc:creator>
<og:description>最近因为仰慕org-mode，从vim迁移到了Emacs。偶然发现org-mode中调出的calendar第一行居然没有对齐，排查一下发现是字体的问题。刚好也想改改Emacs的字体，于是我就开始了一段</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/eadle/p/10658661.html</dc:identifier>
</item>
<item>
<title>MongoDB学习（操作集合中的文档） - 殇灬央</title>
<link>http://www.cnblogs.com/shangyang/p/10649786.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shangyang/p/10649786.html</guid>
<description>&lt;p&gt;　　文档的数据结构和JSON基本一样。&lt;/p&gt;
&lt;p&gt;　　所有存储在集合中的数据都是BSON格式。&lt;/p&gt;
&lt;p&gt;　　BSON是一种类json的一种二进制形式的存储格式,简称Binary JSON。&lt;/p&gt;


&lt;h3&gt;insert（）方法&lt;/h3&gt;
&lt;p&gt;　　要将数据插入到 MongoDB 集合中，可以使用 insert() 方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
db.collection_name.insert(document)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1591870/201904/1591870-20190403153239523-403084168.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　其中test为集合名。如果数据库中不存在集合，则MongoDB将创建此集合，并将文档插入到该集合中。&lt;/p&gt;
&lt;p&gt;　　在插入的文档中，如果不指定 _id 参数，MongoDB会为此文档分配一个唯一的Object_id。&lt;/p&gt;
&lt;p&gt;　　_id 为集合中的每一个文档的12个字节的十六进制数。12 字节划分为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
id: ObjectId( 4 bytes timestamp, 3 bytes machine id, 2 bytes process id, 3 bytes incrementer)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　要在单个语句中插入多个文档，可以在 insert() 命令中传递文档数组。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('e8b95044-9dd9-47e7-b91d-f60968274093')&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_e8b95044-9dd9-47e7-b91d-f60968274093&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_e8b95044-9dd9-47e7-b91d-f60968274093&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('e8b95044-9dd9-47e7-b91d-f60968274093',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e8b95044-9dd9-47e7-b91d-f60968274093&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &amp;gt;&lt;span&gt; db.test.insert([
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; ... {name:&quot;uzi&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; ... like:[&quot;MongoDB&quot;,&quot;JAVA&quot;,&quot;Database&quot;&lt;span&gt;],
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;... },
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; ... {name:&quot;957&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;... parents:[{
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; ... father:&quot;letme&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; ... mather:&quot;mlxg&quot;}],}])
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;添加代码&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1591870/201904/1591870-20190403162300676-1668678006.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1591870/201904/1591870-20190403162343485-1317780484.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;save()方法&lt;/h3&gt;
&lt;p&gt;　　要插入文档，也可以使用 db.collection_name.save() 方法。与 insert() 方法不同的是，当输入的id值相同时， insert() 方法无法插入，但 save() 方法会更新包含 该 id 值的文档的全部数据。&lt;/p&gt;
&lt;h3&gt;insertOne()方法&lt;/h3&gt;
&lt;p&gt;　　db.collection_name.insertOne() 方法将单个文档插入到集合中。如果没有指定 _id ，MongoDB会自动将添加。&lt;/p&gt;
&lt;p&gt;　　该方法会返回包含新插入的文档的 ”_id&quot;字段值的文档。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1591870/201904/1591870-20190403164338273-131047732.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;insertMany()方法&lt;/h3&gt;
&lt;p&gt;　　db.collection_name.insertMany() 方法可以将多个文档插入到集合中。如果没有指定 _id，则自动添加ObjectId&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1591870/201904/1591870-20190403165523167-1117311290.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;更新运算符&lt;/h3&gt;
&lt;p&gt;　　在MongoDB中进行更新操作时，可以使用运算符进行文档数据的局部修改。&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;32&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;运算符&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;描述&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;语法&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;span&gt;$set&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;更新字段的值，如果字段不存在则进行添加&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;{ $set : { field : value } }&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;&lt;span&gt;$inc　&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;将字段值增加指定的量&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;{ $inc : { field : value } }&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;&lt;span&gt;$rename&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;重命名字段名（键名）&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;{ $rename : { field : value } }&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;&lt;span&gt;$unset&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;删除指定的字段（键）&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt; &lt;span&gt;{ $unset : { field : &quot;1&quot; } }&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;&lt;span&gt;$setOnInsert&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;在更新操作中新建文档时设置字段的值&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;&lt;span&gt;{ $setOnInsert : { field : value } }&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;&lt;span&gt;$addToSet&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;在已有数组中添加元素，如果元素存在则不操作&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;&lt;span&gt;{ $addToSet : { field : value } }&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt;&lt;span&gt;$pop&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;删除数组的第一个或最后一个元素。如果值为“-1&quot;，则删除第一个元素；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果值为”1&quot;，则删除最后一个元素。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;&lt;span&gt;{ $pop : { field : value } }&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;td&gt;&lt;span&gt;$push&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span&gt;1.如果指定的键是数组则追加新的值；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.如果指定的键不是数组则无法成功执行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.如果不存在指定的字段（键）则创建数组类型的键值对&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;&lt;span&gt;{ $push : { field : value } }&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt;&lt;span&gt;$pushAll&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;用法与 $push 类似，一次可以添加多个值到数组&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;&lt;span&gt;{ $pushAll : { field : [ value1,value2,...] } }&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;&lt;span&gt;$pull&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;从数组中删除指定值&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;&lt;span&gt;{ $pull : { field : value } }&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt;&lt;span&gt;$pullAll&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;从数组中删除多个值，要删除的值是以数组指定的&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;&lt;span&gt;{ $pullAll : { field : [ value1,value2,...] } }&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td&gt;&lt;span&gt;$each&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;用于运算符$push和$addToSet 的限定符，用于在数组中添加多个单独的元素，防止直接添加进数组元素&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt; &lt;span&gt;field : { $each : [ value1,...] }&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;&lt;span&gt;$slice&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;用于运算符 $push 的限定符，用于限制更新后的数组长度&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;&lt;span&gt;field : { $slice : &amp;lt; num &amp;gt; }&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;span&gt;$sort&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;用于运算符 $push 的限定符，用于将数组中的文档重新排序&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;span&gt;$bit&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;对整数值执行按位与和或运算。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3&gt;更新方法 update()&lt;/h3&gt;
&lt;p&gt;　　Collection 对象的 update() 方法可以更新集合中的文档。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    db.collection.update(    
        &lt;/span&gt;&amp;lt;query&amp;gt;&lt;span&gt;, 
        &lt;/span&gt;&amp;lt;update&amp;gt;&lt;span&gt;, 
        {       
            upsert: &lt;/span&gt;&amp;lt;&lt;span&gt;boolean&lt;/span&gt;&amp;gt;&lt;span&gt;,   
            multi: &lt;/span&gt;&amp;lt;&lt;span&gt;boolean&lt;/span&gt;&amp;gt;&lt;span&gt;,  
            writeConcern: &lt;/span&gt;&amp;lt;document&amp;gt;&lt;span&gt;
        }
    )&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　参数说明：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;　　query：查询条件，类似sql update查询内where后面的条件。&lt;/li&gt;
&lt;li&gt;　　update：要更新的内容和一些更新的操作符（如 $set...)等，类似sql update查询内set后面的参数。&lt;/li&gt;
&lt;li&gt;　　upsert：可选。参数upsert是个布尔值，如果为 true 且没有文档与查询匹配，则插入一个新文档；如果为 false 则不插入。 默认为 false。&lt;/li&gt;
&lt;li&gt;　　multi：可选。mongodb 默认是false，只更新找到的第一条记录，如果这个参数为true，就把按条件查出来的多条记录全部更新。&lt;/li&gt;
&lt;li&gt;　　writeConcern：可选。抛出异常的级别。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　&lt;span&gt;注意：如果不使用运算符，则update内容不会进行局部修改，而是全局修改。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　示例：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1591870/201904/1591870-20190405123200868-2119458769.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('0441bfe5-3356-4e82-85df-fa6b21b7bada')&quot; readability=&quot;37.5&quot;&gt;&lt;img id=&quot;code_img_closed_0441bfe5-3356-4e82-85df-fa6b21b7bada&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_0441bfe5-3356-4e82-85df-fa6b21b7bada&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('0441bfe5-3356-4e82-85df-fa6b21b7bada',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_0441bfe5-3356-4e82-85df-fa6b21b7bada&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;70&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#将name为uzi的学生的age加5
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; db.student.update({name:&quot;uzi&quot;},{$inc:{age:5&lt;span&gt;}})
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;#把uzi的sex改为boy
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; db.student.update({name:&quot;uzi&quot;},{$set:{sex:&quot;boy&quot;&lt;span&gt;}})
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;#把uzi的like字段删除
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; db.student.update({name:&quot;uzi&quot;},{$unset:{like:1&lt;span&gt;}})
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;#给uzi的添加别名dog
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; db.student.update({name:&quot;uzi&quot;},{$push:{aname:&quot;dog&quot;&lt;span&gt;}})
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;#给uzi添加多个别名
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; db.student.update({name:&quot;uzi&quot;},{$pushAll:{aname:[&quot;A1&quot;,&quot;A2&quot;&lt;span&gt;]}})
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;#给uzi的别名数组里再添加一个数组
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; db.student.update({name:&quot;uzi‘},{$addToSet:{aname:[&quot;A3&quot;,&quot;A4&quot;&lt;span&gt;]}})
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;#删除别名数组内第一个别名
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; db.student.update({name:&quot;uzi&quot;&lt;span&gt;},{$pop:{aname:-1}})
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;#删除别名 A2
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; db.student.update({name:&quot;uzi&quot;},{$pull:{aname:&quot;A2&quot;}})
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;局部更新语句示例&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;save() 方法&lt;/h3&gt;
&lt;p&gt;　　save() 方法通过传入的文档来替换已有文档。语法格式如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    db.collection.save(    
        &lt;/span&gt;&amp;lt;document&amp;gt;&lt;span&gt;,     
        {      
            writeConcern: &lt;/span&gt;&amp;lt;document&amp;gt;&lt;span&gt; 
        }  
    )  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;　　document：文档数据&lt;/li&gt;
&lt;li&gt;　　writeConcern：可选。抛出的异常级别。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　无需指定query和update对象，直接将新文档替换掉原来的旧文档。它通过文档中的_id字段确定要修改的字段。&lt;/p&gt;
&lt;p&gt;　　如果集合中没有与传入文档的_id字段值相等的文档，则会添加新的文档。&lt;/p&gt;
&lt;p&gt;　　save() 函数的执行效率要低于update()。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1591870/201904/1591870-20190405135417150-1698216232.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;　　查看集合中的文档，可以使用find()方法。&lt;/p&gt;
&lt;p&gt;　　db.collection_name.find() 可以以非结构化的方式显示集合中的所有文档。&lt;/p&gt;
&lt;p&gt;　　db.collection_name.find().pretty() 可以以结构化的方式显示集合中的所有文档。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1591870/201904/1591870-20190405140649214-960463127.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;　　remove()函数可以用来删除集合中的文档。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    db.collection_name.remove(     
        &lt;/span&gt;&amp;lt;query&amp;gt;&lt;span&gt;,     
        {       
            justOne: &lt;/span&gt;&amp;lt;&lt;span&gt;boolean&lt;/span&gt;&amp;gt;&lt;span&gt;,
            writeConcern: &lt;/span&gt;&amp;lt;document&amp;gt;&lt;span&gt; 
        } 
    )&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;　　query：可选。删除的文档的条件。&lt;/li&gt;
&lt;li&gt;　　justOne：可选。如果为true 或 1，则只删除一个文档。默认为false。&lt;/li&gt;
&lt;li&gt;　　writeConcern：可选。抛出异常的级别。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1591870/201904/1591870-20190405142106355-47214830.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1591870/201904/1591870-20190405142118297-1234194493.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;注意：如果要删除集合中的全部文档，可以使用&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
db.collection_name.remove({})
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Fri, 05 Apr 2019 06:24:00 +0000</pubDate>
<dc:creator>殇灬央</dc:creator>
<og:description>mongodb对集合文档的操作，添加文档、查看文档、删除文档、更新文档及常用的局部更新运算符</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shangyang/p/10649786.html</dc:identifier>
</item>
<item>
<title>腾讯云点播视频存储(Web端视频上传) - wangzaiplus</title>
<link>http://www.cnblogs.com/wangzaiplus/p/10658638.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangzaiplus/p/10658638.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://cloud.tencent.com/document/product/266/9219&quot;&gt;官方文档&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;br/&gt;所谓视频上传，是指开发者或其用户将视频文件上传到点播的视频存储中，以便进行视频处理、分发等。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;腾讯云点播支持如下几种视频上传方式：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;控制台上传：在点播控制台上进行操作，将本地视频上传到云点播，适用于直接管理少量视频的场景，具有方便快捷、无技术门槛的优点；&lt;/li&gt;
&lt;li&gt;服务端上传：开发者将存储在其后台服务器中的视频上传到云点播，适用于自动化、系统化的运营场景；&lt;/li&gt;
&lt;li&gt;客户端上传：终端用户将客户端本地视频上传到云点播，适用于 UGC、PGC 等场景，支持如下三端：
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;本文将介绍第三种视频上传方式: &lt;strong&gt;Web客户端上传&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所谓客户端视频上传，是指 App 的最终用户将本地视频上传到点播平台。客户端上传的整体流程如下图所示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4931997-115ec224a5281da1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;流程图&quot;/&gt;&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;开通服务&lt;/li&gt;
&lt;li&gt;获取云 API 密钥&lt;/li&gt;
&lt;li&gt;服务端派发签名&lt;/li&gt;
&lt;li&gt;客户端集成&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt; 前2步参照腾讯云官方文档指引自己完成, 本文着重讲解后2步代码实现&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4931997-f7f5e8aa30f8f51a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;上传中&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4931997-b80ff3f51eeeeb89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;直接播放上传后的视频&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4931997-8701dca49b9a3e66.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;控制台视频管理&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;服务端派发签名&quot;&gt;1、服务端派发签名&lt;/h2&gt;
&lt;p&gt;首先, 为什么要这一步, 因为, 在客户端上传场景下，客户端是直接将视频文件上传到腾讯云点播，不需要由 App 服务端进行中转。因此，腾讯云点播必须对发起请求的客户端进行鉴权。但由于 SecretKey 的权限过大，App 不应该将此信息泄露到客户端，否则将会造成严重的安全问题。&lt;br/&gt;因此，客户端在发起上传之前，必须要到 App 的签名派发服务申请上传签名，即流程图中的第1步。&lt;/p&gt;
&lt;h2 id=&quot;获取签名代码&quot;&gt;2、获取签名代码&lt;/h2&gt;
&lt;p&gt;获取签名一共只需要两个类: &lt;strong&gt;Signature&lt;/strong&gt;和&lt;strong&gt;SignatureController&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;signature&quot;&gt;1)、Signature&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;package com.cn.pinliang.admin.media.upload;

import sun.misc.BASE64Encoder;

import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;

public class Signature {
    private String secretId;
    private String secretKey;
    private long currentTime;
    private int random;
    private int signValidDuration;

    private static final String HMAC_ALGORITHM = &quot;HmacSHA1&quot;;
    private static final String CONTENT_CHARSET = &quot;UTF-8&quot;;

    public static byte[] byteMerger(byte[] byte1, byte[] byte2) {
        byte[] byte3 = new byte[byte1.length + byte2.length];
        System.arraycopy(byte1, 0, byte3, 0, byte1.length);
        System.arraycopy(byte2, 0, byte3, byte1.length, byte2.length);
        return byte3;
    }

    public String getUploadSignature() throws Exception {
        String strSign;
        String contextStr = &quot;&quot;;

        long endTime = (currentTime + signValidDuration);
        contextStr += &quot;secretId=&quot; + java.net.URLEncoder.encode(secretId, &quot;utf8&quot;);
        contextStr += &quot;&amp;amp;currentTimeStamp=&quot; + currentTime;
        contextStr += &quot;&amp;amp;expireTime=&quot; + endTime;
        contextStr += &quot;&amp;amp;random=&quot; + random;

        try {
            Mac mac = Mac.getInstance(HMAC_ALGORITHM);
            SecretKeySpec secretKey = new SecretKeySpec(this.secretKey.getBytes(CONTENT_CHARSET), mac.getAlgorithm());
            mac.init(secretKey);

            byte[] hash = mac.doFinal(contextStr.getBytes(CONTENT_CHARSET));
            byte[] sigBuf = byteMerger(hash, contextStr.getBytes(&quot;utf8&quot;));
            strSign = new String(new BASE64Encoder().encode(sigBuf).getBytes());
            strSign = strSign.replace(&quot; &quot;, &quot;&quot;).replace(&quot;\n&quot;, &quot;&quot;).replace(&quot;\r&quot;, &quot;&quot;);
        } catch (Exception e) {
            throw e;
        }
        return strSign;
    }

    public void setSecretId(String secretId) {
        this.secretId = secretId;
    }

    public void setSecretKey(String secretKey) {
        this.secretKey = secretKey;
    }

    public void setCurrentTime(long currentTime) {
        this.currentTime = currentTime;
    }

    public void setRandom(int random) {
        this.random = random;
    }

    public void setSignValidDuration(int signValidDuration) {
        this.signValidDuration = signValidDuration;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;signaturecontroller&quot;&gt;2)、SignatureController&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;package com.cn.pinliang.admin.controller;

import com.cn.pinliang.JsonResult;
import com.cn.pinliang.admin.media.upload.Signature;
import com.ctt.framework.ConfigUtil;
import com.google.common.collect.Maps;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

import java.util.Map;
import java.util.Random;

@Controller
@RequestMapping(&quot;/signature&quot;)
public class SignatureController{

    @RequestMapping(&quot;getUgcUploadSign&quot;)
    @ResponseBody
    public JsonResult getUgcUploadSign() {
        String secretId = &quot;your secretId&quot;;
        String secretKey = &quot;your secretKey&quot;;

        Signature sign = new Signature();
        sign.setSecretId(secretId);
        sign.setSecretKey(secretKey);
        sign.setCurrentTime(System.currentTimeMillis() / 1000);
        sign.setRandom(new Random().nextInt(java.lang.Integer.MAX_VALUE));
        sign.setSignValidDuration(3600 * 24 * 2);

        try {
            String signature = sign.getUploadSignature();
            Map&amp;lt;String, String&amp;gt; map = Maps.newHashMap();
            map.put(&quot;signature&quot;, signature);
            return JsonResult.succeed(map);
        } catch (Exception e) {
            e.printStackTrace();
            return JsonResult.fail(&quot;获取签名失败&quot;);
        }
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;好了, 现在可以调用getUgcUploadSign获取签名了&lt;/p&gt;
&lt;h2 id=&quot;客户端集成&quot;&gt;3、客户端集成&lt;/h2&gt;
&lt;h3 id=&quot;说明&quot;&gt;1)、说明&lt;/h3&gt;
&lt;p&gt;说是客户端集成, 其实就是前端js+css+html实现视频的上传, 看了官方文档和GitHub demo, 发现有一个问题, 那就是难道每次上传视频都要copy这些代码到我们自己的页面吗, 能不能抽离出单独的js直接调用就行了? 可以, 但是:&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4931997-5b7f3dcfa07b2800.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;problem&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以, 我们不能直接剥离这些js, 还得封装一下才行&lt;/p&gt;
&lt;h3 id=&quot;封装干货才开始&quot;&gt;2)、封装(干货才开始)&lt;/h3&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;先看下经过后面代码的封装上传视频有多么简单, 真正做到一行代码解决视频加载与上传:&lt;br/&gt;&lt;code&gt;loadAndUploadVideo('form_id', 'teachingVideo', &quot;uploadVideo&quot;, &quot;videoFileId&quot;, 200);&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;首先, 既然要用别人的SDK, 我们得引入相关依赖才行, 在jsp页面引入:&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;%--腾讯云上传视频js依赖--%&amp;gt;
&amp;lt;script src=&quot;https://cdn.jsdelivr.net/npm/es6-promise@4/dist/es6-promise.auto.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.21/vue.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/axios/0.18.0/axios.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&quot;https://unpkg.com/vod-js-sdk-v6&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;%--上传进度div--%&amp;gt;
&amp;lt;div class=&quot;center-in-center&quot; id=&quot;txUploadProgress&quot; style=&quot;display: none&quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;a. 官方文档用的是vue.js, 虽然没学过, 但好歹有点js基础, 万变不离其宗, 不会的查下相关文档就行了&lt;/p&gt;
&lt;p&gt;b. 与官方demo上传进度有点不一样的是, 我在上传时加了一层遮罩层, 页面中心显示上传进度, 所以引入了上传进度div, 总之, 根据自己实际项目需要来&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;然后, 在你的页面嵌入:&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;                        &amp;lt;div id=&quot;uploadVideo&quot; style=&quot;margin-left: 40px; margin-top: 20px&quot;&amp;gt;
                            &amp;lt;input type=&quot;hidden&quot; id=&quot;teachingVideo&quot; value=&quot;${hotProduct.teachingVideo}&quot;/&amp;gt;
                            &amp;lt;form ref=&quot;vExample&quot;&amp;gt;
                                &amp;lt;input type=&quot;file&quot; style=&quot;display:none;&quot; ref=&quot;vExampleFile&quot; @change=&quot;vExampleUpload($event)&quot; id=&quot;videoFileId&quot; accept=&quot;video/mp4&quot;/&amp;gt;
                            &amp;lt;/form&amp;gt;
                            &amp;lt;div class=&quot;btn btn-app btn-default btn-sm pr&quot; style=&quot;width: 160px; &quot;&amp;gt;
                                &amp;lt;i @click=&quot;vExampleAdd&quot; class=&quot;ace-icon fa fa-cloud-upload bigger-200&quot; style=&quot;font-size: 20px&quot;&amp;gt;上传视频&amp;lt;/i&amp;gt;
                            &amp;lt;/div&amp;gt;
                        &amp;lt;/div&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt;&lt;br/&gt;调用时指定的id与此页面元素id一一对应&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;然后, 新建js文件, 代码:&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;/**
 * 腾讯云视频上传
 */

var progressId = 'txUploadProgress';// 上传进度id

/**
 * 加载和上传视频: 页面初始化时调用, 可以直接通过视频url加载视频到页面
 * 除maxSize字段非必传外, 其他字段均必传, 否则后果自负
 * @param formId form表单id
 * @param name 与后端绑定的name字段, 如shortVideo字段, 此字段必须与隐藏域id字段相同, 即id name一致
 * @param uploadVideoDivId 视频上传相关的div块id
 * @param videoFileId 视频文件id, 此字段作用是解决vue无法再次上传相同文件的问题, 将此id值清空即可再次上传
 * @param maxSize 文件大小, M为单位, 不传表示不限制文件大小
 */
function loadAndUploadVideo(formId, name, uploadVideoDivId, videoFileId, maxSize) {
    loadVideo(uploadVideoDivId, name);
    uploadVideo(formId, name, uploadVideoDivId, videoFileId, maxSize)
}

/**
 * 加载视频
 * @param uploadVideoDivId 将视频追加到此id后面
 * @param name 根据name获取原视频值, 因此id与name字段必须相同才能拿到旧值
 */
function loadVideo(uploadVideoDivId, name) {
    var oldVideoUrl = $(&quot;#&quot; + name).val();
    if (oldVideoUrl != null &amp;amp;&amp;amp; oldVideoUrl != &quot;&quot;){
        var str = '';
        str += '&amp;lt;div class=&quot;video&quot;&amp;gt;' ;
        str += '    &amp;lt;video src=&quot;'+oldVideoUrl+'&quot; controls=&quot;controls&quot; &amp;gt;';
        str += '&amp;lt;/div&amp;gt;';
        $(&quot;#&quot; + uploadVideoDivId + &quot; .video&quot;).remove();
        $(&quot;#&quot; + uploadVideoDivId).append(str);
    }
}

/**
 * 上传视频, 腾讯云官方demo + 改造
 * @param formId
 * @param name
 * @param uploadVideoDivId
 * @param videoFileId
 * @param maxSize 文件大小, M为单位, 不传表示不限制文件大小
 */
function uploadVideo(formId, name, uploadVideoDivId, videoFileId, maxSize) {
    // 获取签名, 腾讯云要求直接上传视频的客户端必须获取签名
    function getSignature() {
        var url = &quot;&quot; + ctx + &quot;signature/getUgcUploadSign.action&quot;
        return axios.post(url).then(function (response) {
            return response.data.data.signature
        })
    };
    var app = new Vue({
        el: '#' + uploadVideoDivId,
        data: {
            uploaderInfos: [],
        },
        created: function () {
            this.tcVod = new TcVod.default({
                getSignature: getSignature
            })
        },
        methods: {
            vExampleAdd: function () {
                this.$refs.vExampleFile.click()
            },
            vExampleUpload: function (event) {
                if (!checkVideo(event, maxSize, videoFileId)) {
                    return;
                }
                onVideoSelected()
                var self = this;
                var videoFile = this.$refs.vExampleFile.files[0]
                var uploader = this.tcVod.upload({
                    videoFile: videoFile,
                })
                uploader.on('video_progress', function (info) {
                    uploaderInfo.progress = info.percent;
                    // 上传进度
                    var percent = Math.floor(uploaderInfo.progress * 100) + '%'
                    $(&quot;#&quot; + progressId).text(&quot;正在上传 : &quot; + percent)
                })
                uploader.on('video_upload', function (info) {
                    uploaderInfo.isVideoUploadSuccess = true;
                })
                var uploaderInfo = {
                    videoInfo: uploader.videoInfo,
                    isVideoUploadSuccess: false,
                    isVideoUploadCancel: false,
                    progress: 0,
                    fileId: '',
                    videoUrl: '',
                    cancel: function() {
                        uploaderInfo.isVideoUploadCancel = true;
                        uploader.cancel()
                    },
                }
                this.uploaderInfos.push(uploaderInfo)
                uploader.done().then(function(doneResult) {
                    uploaderInfo.fileId = doneResult.fileId;
                    return doneResult.video.url;
                }).then(function (videoUrl) {
                    uploaderInfo.videoUrl = videoUrl
                    onVideoUploaded(formId, name, videoUrl, videoFileId, uploadVideoDivId);
                })
            }
        },
    })
}

/**
 * 选择视频后显示上传进度
 */
function onVideoSelected() {
    $(&quot;#&quot; + progressId).text(&quot;正在上传 : 0%&quot;)
    $(&quot;#&quot; + progressId).show()
    startLoadding();
}

/**
 * 视频上传完成
 * @param formId
 * @param name
 * @param videoUrl
 * @param videoFileId
 * @param uploadVideoDivId
 */
function onVideoUploaded(formId, name, videoUrl, videoFileId, uploadVideoDivId) {
    endLoadding();
    $(&quot;#&quot; + progressId).hide();
    layerAlert(&quot;上传完成&quot;)
    // 上传完成后清空fileId, 否则vue无法再次选择此文件
    $(&quot;#&quot; + videoFileId).val('')
    // 将上传成功后的视频url追加到表单
    formAppendVideo(formId, name, videoUrl);

    if (videoUrl != &quot;&quot;){
        var str = '';
        str += '&amp;lt;div class=&quot;video&quot;&amp;gt;';
        str += '    &amp;lt;video src=&quot;'+videoUrl+'&quot; controls=&quot;controls&quot; &amp;gt;';
        str += '&amp;lt;/div&amp;gt;';
        $(&quot;#&quot; + uploadVideoDivId + &quot; .video&quot;).remove();
        $(&quot;#&quot; + uploadVideoDivId).append(str);
    }
}

/**
 * 删除视频, 删除页面视频只需要uploadVideoDivId字段即可, 但同时还应清空form表单的videoUrl
 * @param formId
 * @param uploadVideoDivId
 * @param name
 */
function deleteVideo(formId, uploadVideoDivId, name) {
    $(&quot;#&quot; + uploadVideoDivId + &quot; .video&quot;).remove();
    formAppendVideo(formId, name, null);
}

/**
 * 追加视频url到form
 * @param formId
 * @param name
 * @param videoUrl
 */
function formAppendVideo(formId, name, videoUrl){
    videoUrl = null == videoUrl ? '' : videoUrl;
    var form = $('#' + formId);
    var tmpInput = $('&amp;lt;input type=&quot;hidden&quot; name=&quot;'+name+'&quot; value=&quot;'+videoUrl+'&quot; /&amp;gt;');
    form.append(tmpInput);
}

/**
 * 校验视频格式和大小
 * @param event
 * @param maxSize 不传表示不限制文件大小
 * @returns {boolean}
 */
function checkVideo(event, maxSize, videoFileId) {
    var flag = true;
    var accept = event.target.accept;
    var file = event.target.files[0];
    var type = file.type
    if(accept.indexOf(type) == -1) {
        layerAlert('文件格式不正确');
        $(&quot;#&quot; + videoFileId).val('')
        flag = false;
    }
    if (maxSize != undefined) {
        if(file.size &amp;gt; 1024 * 1024 * maxSize) {
            layerAlert('文件不能大于' + maxSize + 'M');
            $(&quot;#&quot; + videoFileId).val('')
            flag = false;
        }
    }
    return flag
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;a.&lt;/strong&gt; 代码注释足够详细了&lt;br/&gt;&lt;strong&gt;b.&lt;/strong&gt; 视频上传核心代码在uploadVideo方法&lt;br/&gt;稍微解释下uploadVideo方法:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;先调用SignatureController里面的getUgcUploadSign方法获取签名&lt;/li&gt;
&lt;li&gt;再通过vue定义视频文件点击、选择、上传后的事件&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;c.&lt;/strong&gt; 有人会问不是上传视频吗, 为什么还有loadVideo, 因为, 编辑时进入页面不可能之前的视频就不显示吧, 所以, 初始化调用loadAndUploadVideo方法时就会将原视频嵌入到页面中了&lt;br/&gt;&lt;strong&gt;d.&lt;/strong&gt; 本文还加了上传视频的一些限制, 比如格式、大小之类的&lt;br/&gt;&lt;strong&gt;e.&lt;/strong&gt; formAppendVideo方法需要说明一下, 这个方法作用是上传视频后直接将视频url以name形式追加到表单元素, 这样就不用再form submit的时候再获取videoUrl了, 直接提交到后端, 这也是一行代码搞定视频上传的必要方法&lt;/p&gt;
&lt;h3 id=&quot;使用&quot;&gt;3)、使用&lt;/h3&gt;
&lt;p&gt;上述代码就可以实现一行代码搞定视频上传加载了, 通过在页面初始化时调用loadAndUploadVideo方法即可, 具体如下:&lt;br/&gt;&lt;strong&gt;a:&lt;/strong&gt; jsp页面引入相关vue js&lt;br/&gt;&lt;strong&gt;b:&lt;/strong&gt; jsp页面嵌入html&lt;br/&gt;&lt;strong&gt;c:&lt;/strong&gt; 新建js, 将上述js代码copy进去&lt;br/&gt;&lt;strong&gt;d:&lt;/strong&gt; 页面加载完毕初始化时调用:&lt;br/&gt;&lt;code&gt;loadAndUploadVideo('form_id', 'teachingVideo', &quot;uploadVideo&quot;, &quot;videoFileId&quot;, 200);&lt;/code&gt;即可&lt;/p&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;结语: 本文通过参考腾讯云点播官方文档, 实现了对视频上传和加载功能的封装, 最终能够通过调用一行代码实现功能, 由于每个项目不同, 小伙伴需要根据自己实际情况修改进行代码适配, 谢谢&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 05 Apr 2019 06:23:00 +0000</pubDate>
<dc:creator>wangzaiplus</dc:creator>
<og:description>'官方文档' 前言 所谓视频上传，是指开发者或其用户将视频文件上传到点播的视频存储中，以便进行视频处理、分发等。 一、简介 腾讯云点播支持如下几种视频上传方式： 1. 控制台上传：在点播控制台上进行操</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wangzaiplus/p/10658638.html</dc:identifier>
</item>
<item>
<title>分享一个自己写的vue多语言插件smart-vue-i18n - 村长村长</title>
<link>http://www.cnblogs.com/net-xiejun/p/10658562.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/net-xiejun/p/10658562.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;目前有比较成熟的方案（vue-i18n）了解了下，并且实用了一下感觉对于我在使用的项目来说略显臃肿,功能比较多，所以压缩的会比较大，在移动端不太适合所以自己花一天时间撸了一个vue多语言插件，压缩后大小不超过2kb&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;使用方法&quot;&gt;使用方法&lt;/h2&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;通过Vue.js公开方法install安装,参数 lang 为初始化默认语言,参数 messages 为初始语言库,也可以在组件中新增多语言,语言库格式参照其他开源的国际化项目&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;安装&quot;&gt;安装&lt;/h3&gt;
&lt;p&gt;github地址: &lt;a href=&quot;https://github.com/xiejun-net/smart-vue-i18n&quot;&gt;smart-vue-i18n&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;yarn add smart-vue-i18n&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;初始化&quot;&gt;初始化&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;// 插件方式引用
// messages 为语言库
import { messages } from '@/utils/i18n-message/open-account/apply/index.js'
import i18n from 'smart-vue-i18n'

Vue.use(i18n, {
    lang: 'zhCHT',
    messages
})&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;语言库格式&quot;&gt;语言库格式&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;// 语言库格式
import { zhCHS } from './zh-chs'
import { zhCHT } from './zh-cht'

export const messages = {
    //简体中文
    zhCHS,
    //繁体中文
    zhCHT
}

// './zh-chs'
export const zhCHS = {
    personalInfo: '个人资料',
}

// './zh-cht'
export const zhCHT = {
    personalInfo: '個人資料',
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;组件内使用&quot;&gt;组件内使用&lt;/h3&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;直接在组件内定义i18n多语言源 然后可以在页面使用切换语言可以不用刷新页面 方法 &lt;code&gt;this.$i18n.setLang('zhCHS')&lt;/code&gt;组件内js使用 &lt;code&gt;this.$t('personalInfo')&lt;/code&gt;组件内html使用 &lt;code&gt;$t('personalInfo')&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;template lang=&quot;pug&quot;&amp;gt;
yx-container.apply-home
    .apply-main(slot=&quot;main&quot;)
        .personalInfo {{$t('personalInfo')}}
        .apply-main-add-credit(@click=&quot;testHandler&quot;) {{$t('test.a')}}
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
export default {
    i18n: {
        zhCHS: {
            test: {
                a: '简体'
            }
        },
        zhCHT: {
            test: {
                a: '简体'
            }
        }
    },
    methods: {
        testHandler() {
            this.$i18n.setLang(this.$i18n.lang === 'zhCHS' ? 'zhCHT' : 'zhCHS')
            console.log(this, this.$i18n.lang)
        }
    }
}
&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;原理解析&quot;&gt;原理解析&lt;/h2&gt;
&lt;p&gt;核心代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const _vm = new Vue({
    data: options
})
Object.defineProperty(Vue.prototype.$i18n, 'lang', {
    get() {
        return _vm.lang
    }
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将多语言挂载到vue原型上&lt;br/&gt;然后 &lt;code&gt;Object.defineProperty&lt;/code&gt; 监听&lt;code&gt;Vue.prototype.$i18n&lt;/code&gt;变化&lt;br/&gt;通过&lt;code&gt;new Vue()&lt;/code&gt; 创建实例来实现语言切换实时渲染，可以不需要刷新页面&lt;/p&gt;
&lt;h2 id=&quot;其他&quot;&gt;其他&lt;/h2&gt;
&lt;p&gt;时间仓促，一些常用的功能暂时没有，后续加上&lt;/p&gt;
&lt;p&gt;欢迎使用并提出意见&lt;/p&gt;
</description>
<pubDate>Fri, 05 Apr 2019 05:55:00 +0000</pubDate>
<dc:creator>村长村长</dc:creator>
<og:description>前言 目前有比较成熟的方案（vue i18n）了解了下，并且实用了一下感觉对于我在使用的项目来说略显臃肿,功能比较多，所以压缩的会比较大，在移动端不太适合所以自己花一天时间撸了一个vue多语言插件，压</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/net-xiejun/p/10658562.html</dc:identifier>
</item>
</channel>
</rss>